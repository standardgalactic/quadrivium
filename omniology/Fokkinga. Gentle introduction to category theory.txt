A Gentle Introduction to Category
Theory
— the calculational approach —
Maarten M. Fokkinga
Version of June 6, 1994

c⃝M.M. Fokkinga, 1992
Maarten M. Fokkinga
University of Twente, dept. INF
PO Box 217
NL 7500 AE ENSCHEDE
The Netherlands
e-mail: fokkinga@cs.utwente.nl

Contents
0
Introduction
3
1
The main concepts
7
1a
Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7
1b
Functors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
1c
Naturality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
1d
Adjunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
1e
Duality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
2
Constructions in categories
31
2a
Iso, epic, and monic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
2b
Initiality and ﬁnality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
2c
Products and Sums . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
2d
Coequalisers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
2e
Colimits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
A More on adjointness
59
Chapters 3 and 5 of ‘Law and Order in Algorithmics’ [4]
present a categorical approach to algebras. Those chap-
ters don’t use the notions of adjunction and colimit. So
you may skip Sections 1d, and 2e, and Appendix A when
you are primarily interested in reading those chapters.
1

2
CONTENTS

Chapter 0
Introduction
0.1
Aim.
In these notes we present the important notions from category theory. The
intention is to provide a fairly good skill in manipulating with those concepts formally.
What you probably will not acquire from these notes is the ability to recognise the concepts
in your daily work when that diﬀers from algorithmics, since we give only a few examples
and those are taken from algorithmics. For such an ability you need to work through many,
very many examples, in diverse ﬁelds of applications.
This text diﬀers from most other introductions to category theory in the calculational
style of the proofs (especially in Chapter 2 and Appendix A), the restriction to applications
within algorithmics, and the omission of many additional concepts and facts that I consider
not helpful in a ﬁrst introduction to category theory.
0.2
Acknowledgements.
This text is a compilation and extension of work that I’ve
done for my thesis. That project would have been a failure without the help or stimulation
by many people. Regarding the technical contents, Roland Backhouse, Grant Malcolm,
Lambert Meertens and Jaap van der Woude may recognise their ideas and methodological
and notational suggestions.
0.3 Why category theory?
There are various views on what category theory is about,
and what it is good for. Here are some.
• Category theory is a relatively young branch of mathematics, stemming from alge-
braic topology, and designed to describe various structural concepts from diﬀerent
mathematical ﬁelds in a uniform way. Indeed, category theory provides a bag of
concepts (and theorems about those concepts) that form an abstraction of many
concrete concepts in diverse branches of mathematics, including computing science.
Hence it will come as no surprise that the concepts of category theory form an
abstraction of many concepts that play a role in algorithmics.
• Quoting Hoare [6]: “Category theory is quite the most general and abstract branch of
pure mathematics. [ . . . ] The corollary of a high degree of generality and abstraction
3

4
CHAPTER 0. INTRODUCTION
is that the theory gives almost no assistance in solving the more speciﬁc problems
within any of the subdisciplines to which it applies. It is a tool for the generalist, of
little beneﬁt to the practitioner [ . . . ].”
Hence it will come as no surprise that, for algorithmics too, category is mainly useful
for theory development; hardly for individual program derivation.
• Quoting Asperti and Longo [1]: “Category theory is a mathematical jargon. [ . . . ]
Many diﬀerent formalisms and structures may be proposed for what is essentially the
same concept; the categorical language and approach may simplify through abstrac-
tion, display the generality of concepts, and help to formulate uniform deﬁnitions.”
• Quoting Scott [7]: “[Category theory oﬀers] a pure theory of functions, not a theory
of functions derived from sets.”
To this I want to add that the language of category theory facilitates an elegant
style of expression and proof (equational reasoning); for the use in algorithmics this
happens to be reasoning at the function level, without the need (and the possibility)
to introduce arguments explicitly. Also, the formulas often suggest and ease a far-
reaching generalisation, much more so than the usual set-theoretic formulations.
Category theory has itself grown to a branch in mathematics, like algebra and analysis,
that is studied like any other one. One should not confuse the potential beneﬁts that
category theory may have (for the theory underlying algorithmics, say) with the diﬃculty
and complexity, and fun, of doing category theory as a specialisation in itself.
0.4
Preliminaries:
sequences.
Our examples frequently involve ﬁnite lists, or se-
quences as we like to call them. Here is our notation.
A sequence is a ﬁnite list of elements of a certain type, denoted [a0, . . . , an−1] . The
set of sequences over A is denoted Seq A . Further operations are:
tip
=
a 7→[a]
:
A →Seq A
:
=
(a, [a0, . . . , an−1]) 7→[a, a0, . . . , an−1]
:
A × Seq A →Seq A
cons
=
preﬁx written operation
:
++
=
([a0, . . . , am−1], [am, . . . , an−1]) 7→[a0, . . . , an−1]
:
Seq A × Seq A →Seq A
join
=
preﬁx written operation
++
Seq f
=
[a0, . . . , an−1] 7→[f a0, . . . , f an−1]
:
Seq A →Seq B whenever f: A →B
⊕/
=
[a0, . . . , an−1] 7→a0 ⊕. . . ⊕an−1
:
Seq A →A whenever ⊕: A × A →A and

5
⊕is associative and has a neutral element
Function Seq f is often called map f .
Function ⊕/ is called the reduce-with-⊕or
the fold-with-⊕; the neutral element of ⊕is the outcome on the empty sequence [ ] .
Associativity of ⊕implies that the speciﬁcation of ⊕/ is unambiguous, not depending on
the parenthesisation within a0 ⊕. . . ⊕an−1 .
Exercise: ﬁnd a non-associative operation for which ⊕/ is well deﬁned. Conclude that
associativity of ⊕is a suﬃcient, but not necessary condition for ⊕/ to be a well deﬁned
function on sequences.
You may familiarise yourself with these operations by proving the laws listed in para-
graph 1.49 on account of the above deﬁnitions (noting that f ; g = g ◦f = the composition
‘ f followed by g ’).

6
CHAPTER 0. INTRODUCTION

Chapter 1
The main concepts
This introductory chapter gives a brief overview of the important categorical concepts,
namely category, functor, naturality, adjunction, duality. In the next chapter we will show
how to express familiar set-theoretic notions in category theoretic terms.
1a
Categories
A category is a collection of data that satisfy some particular properties. So, saying that
such-and-so forms a category is merely short for asserting that such-and-so satisfy all the
axioms of a category. Since a large body of concepts and theorems have been developed
that are based on the categorical axioms only, those concepts and theorems are immediately
available for such-and-so if that forms a category.
For an intuitive understanding in the following deﬁnition, one may interpret objects as
sets, and morphisms as typed total functions. We shall later provide some more and quite
diﬀerent examples of a category, in which the objects aren’t sets and the morphisms aren’t
functions.
1.1
Deﬁnition.
A category is: the following data, subject to the axioms listed in
paragraph 1.2.
• A collection of things called objects.
By default, A, B, C, . . . vary over objects.
• A collection of things called morphisms, sometimes called arrows.
By default, f, g, h, . . ., and later on also α, β, ϕ, ψ, χ, . . ., vary over morphisms.
• A relation on morphisms and pairs of objects, called typing of the morphisms.
By default, the relation is denoted f: A →B , for morphism f and objects A, B .
In this case we also say that A →B is the type of f , and that f is a morphism
from A to B . In view of the axioms below we may deﬁne the source and target
7

8
CHAPTER 1. THE MAIN CONCEPTS
by
src f = A and tgt f = B
whenever f: A →B .
• A binary partial operation on morphisms, called composition.
By default, f
; g is the notation of the composition of morphisms f and g . An
alternative notation is g ◦f , and even g f , with the convention f ; g = g ◦f = g f .
Within a term denoting a morphism, symbol
; has weakest binding power, whereas
juxtaposition binds strongest. We shall hardly use symbol ◦to denote composition.
• For each object A a distinguished morphism, called identity on A .
By default, id A , or id when A is clear from the context, denotes the identity on
object A .
By default, A, B, C, . . . vary over categories, and particular categories are named after
their objects (rather than their morphisms). Actually, these data deﬁne the basic terms
of the categorical language in which properties of the category can be stated. A cate-
gorical statement is an expression built from (notations for) objects, typing, morphisms,
composition and identities by means of the usual logical connectives and quantiﬁcations
and equality. If you happen to know what the objects really are, you may use those aspects
in your statements, but then you are not expressing yourself categorically.
Sometimes there are several categories under discussion. Then the name of the category
may and must be added to the above notations, as a subscript or otherwise, in order to
avoid ambiguity. So, let A be a category. Then we may write speciﬁcally f: A →A B ,
srcA , tgtA , f
;A g , and id A,A . There is no requirement in the deﬁnition of a category
stating that the morphisms of one should be diﬀerent from those of another; a morphism
of A may also be a morphism of B . In such a case the indication of A in f: A →A B
and srcA f is quite important.
1.2 Axioms.
There are three ‘typing’ axioms, and two axioms for equality. The typing
axioms are these:
f: A →B and f: A′ →B′
⇒
A = A′ and B = B′
1.3
unique-Type
f: A →B and g: B →C
⇒
f ; g :
A →C
1.4
composition-Type
id A: A →A
1.5
identity-Type
A morphism term f is well-typed if: a typing f: A →B can be derived for some objects
A, B according to these axioms (and the Type properties of deﬁned notions that will be
given in the sequel).
Convention.
Whenever we write a term, we assume that the variables are typed (at
their introduction — mostly an implicit universal quantiﬁcation in front of the formula)
in such a way that the term is well-typed.
This convention allows us to simplify the
formulations considerably, as illustrated in the following axioms.

1A. CATEGORIES
9
Here are the two axioms for equality of morphisms.
(f ; g) ; h = f ; (g ; h)
1.6
composition-Assoc
id ; f = f = f ; id
1.7
Identity
In accordance with the convention explained a few lines up, axiom composition-Assoc
is universally quantiﬁed with “for all objects A, B, C, D and all morphisms f, g, h with
f: A →B , g: B →C , and h: C →D ”, or slightly simpler, “for all f, g, h with
tgt f = src g and tgt g = src h ”. In accordance with that same convention, axiom Identity
actually reads id srcf
; f = f = f
; id tgtf , or even “for all objects A, B and all morphisms
f with f: A →B , id A ; f = f = f ; id B ”.
Convention.
The category axioms are so basic that we shall mostly use them tacitly.
In particular, we shall use composition-Assoc implicitly by omitting the parentheses in a
composition, thus writing f ; g ; h instead of either (f ; g) ; h or f ; (g ; h) .
1.8
Pre-category.
If the requirement unique-Type is dropped in the deﬁnition of a
category, then one gets the deﬁnition of a pre-category.
Quite often we shall encounter data that form a pre-category. By a simple trick, those
data also determine a category: take multiple copies of the morphisms and make them
distinct by incorporating a “source” and “target” into them. Formally, let A be a pre-
category, and deﬁne B by
an object in B
is:
an object in A
a morphism in B
is:
a triple (A, f, B) with f: A →A B
f: A →B B
≡
A = A′ and B = B′ where (A′, f ′, B′) = f
f ;B g
=
(A,
f ′
;A g′,
C)
where (A, f ′, B) = f and (B, g′, C) = g
id B,A
=
(A, id A,A, A) .
Then B is a category. (Exercise: prove this.)
In the sequel, we shall sometimes pretend that a pre-category is a category, that is, we
shall deﬁne a category out of it by the above construction, but keep writing f instead of
(A, f, B) for the morphisms.
A big technical advantage of categories over pre-categories is that there is no need to
specify the source and target of a morphism; they are determined by morphism f as src f
and tgt f , respectively. (Nevertheless we shall often explicitly name the source and target
of a morphism, for clarity.) A big conceptual advantage of pre-categories over categories
is that the morphisms more closely correspond to the structure preserving transformations
of interest. It seems that most concepts and theorems for categories can be generalised to
pre-categories.

10
CHAPTER 1. THE MAIN CONCEPTS
1.9 Example: Set .
Set ′ is: the pre-category whose objects are sets, whose morphisms
are total functions, and whose composition and identities are function composition and
identity functions respectively. Further, deﬁne f: A →B to mean that, for each a ∈
A , fa is well-deﬁned and fa ∈B . Thus, for the squaring function square we have
square: nat →nat as well as square: real →real , and so on. With this deﬁnition the
axioms listed in paragraph 1.2, except for unique-Type, are fulﬁlled. (Exercise: verify the
axioms.)
Now deﬁne category Set out of pre-category Set ′ by the construction given in para-
graph 1.8. We keep saying that the morphisms in Set are total functions; it may be more
accurate to say that they are ‘typed’ total functions, since they carry their type (source
and target) with them. We also keep the notation fa for the application of f on a ,
whenever f: A →Set B and a ∈A .
Doing set theory in the categorical language enforces the strait jacket of expressing every-
thing with function composition only, without using explicit arguments, membership and
function application. Once mastered it is often, not always, an elegant way of expressing.
We shall mostly illustrate the notions of category theory in terms of categories where
the morphisms are functions and composition is function composition, like in Set . But
beware, even if the morphisms are functions, the objects need not at all be sets: sometimes
the objects are operations (with an appropriate deﬁnition for the typing of the functions).
The categories of F -algebras are an example of this; a special case is Alg(II) discussed
in paragraph 1.22, and Mon in paragraph 1.23. Other times we’ll take “structures” (of
structured data) as objects, again with an appropriate interpretation for the typing of the
morphisms; this occurs in category Ftr(A, B) deﬁned in paragraph 1.37.
1.10
Example: graphs and pre-orders.
One should not be mislead by our illus-
trations, where morphisms are functions. There are many more mathematical data that
can be viewed as a category. To mention just one generic example, each directed graph
determines a category as follows. Take the nodes as objects, and all paths as morphisms
typed with their start and end nodes. Composition is concatenation of paths, and the
identities are the empty paths. Thus deﬁned, these data do satisfy the axioms listed in
paragraph 1.2, hence form a category. (Exercise: verify this.)
Here is yet another important example of a class of categories.
We don’t need it
in our discussion of algorithmics, but it provides sometimes instructive examples. Each
pre-ordered set (A, ≤) can be considered a category, in the following way. The elements
a, b, . . . of A are the objects of the category and there is a morphism from a to b precisely
when a ≤b . Formally, the category is deﬁned as follows.
an object
is:
an element in A
a morphism
is:
a pair (a, b) with a ≤b in A
(a, b): c →d
≡
a = c
∧
b = d
(a, b) ; (b, c)
=
(a, c)
id a
=
(a, a) .

1A. CATEGORIES
11
Thus deﬁned, these data do satisfy the axioms of a category.
Exercise: check that laws composition-Assoc and -Identity are satisﬁed, and that the typing
axioms follow from the deﬁnition of the typing relation, and that the well-deﬁnedness of
;
and id follow from the transitivity and reﬂexivity of the preorder ≤, respectively.
Exercise: deﬁne a category where the morphisms are numbers, and the composition is
addition.
1.11
Cartesian closed categories, and Topoi.
The axioms on the morphisms and
composition are very weak, so that many mathematical structures can be rendered as a
category. By imposing extra axioms, still in the categorical language, the categories may
have more of the properties you are actually interested in.
For example, a cartesian closed category is a category in which the extra properties
make the morphisms behave more like real functions: in particular, there is a notion of
currying and of applying a curried morphism. There is a close relationship between this
type of categories and typed λ -calculi.
As another example, a topos (plural: topoi or toposes) is a cartesian closed category
in which the extra properties make the objects have more of the properties of real sets: in
particular, for each object there exists an object of its ‘subobjects’.
In these notes, we shall nowhere need the extra properties. As a result, the notions
deﬁned here, and the theorems proved, are very general and very weak at the same time.
1.12 Discussion.
Quoting Asperti and Longo [1]: “The basic premise of category theory
is that every kind of mathematically structured object comes equipped with a notion of
[ . . . ] transformation, called ‘morphism’, that preserves the structure of the object.” By
means of the categorical language one cannot express properties of the internal structure
of objects.
The internal structure of objects is accessible only externally through the
morphisms between the objects. The morphisms may seem (and sometimes are) functions,
but the categorical language doesn’t express that; it only provides a way to express the
composition of morphisms. The discipline of expressing internal structure only externally is
the key to the uniformity of describing structural concepts in various diﬀerent application
ﬁelds.
Since each graph is a category, the above interpretation of “internal structure” of objects
doesn’t always make sense.
Exercise.
What functions are precisely the functions that preserve a partial order?
(Deﬁne a category in which these functions are the morphisms.)
What functions are
precisely the functions that preserve a partial order and the limits? (Deﬁne a category in
which these functions are the morphisms.) What structure of sets is preserved by precisely
all total functions? (What category has these functions as morphisms?)
1.13
Expressing concepts categorically.
In the following chapters we shall show
how all kinds of familiar concepts can be expressed categorically, that is, using only the

12
CHAPTER 1. THE MAIN CONCEPTS
notions of object, morphism, typing, composition, identity, and notions that can be deﬁned
in terms of these, and further the usual logical connectives and quantiﬁcations.
To appreciate the problems and delight involved, the reader may spend some (not
too much) time in trying to ﬁnd a categorically expressed property P such that in Set
property P holds precisely for the empty set, that is, P(A) ≡A=∅. Similarly, you may
think about categorically expressed properties P such that in Set the following holds:
P(A)
≡
A = {17}
P(A)
≡
A is a singleton set
P(A, B)
≡
A ⊆B
P(f)
≡
f is surjective
P(f)
≡
f is injective
P(A, B, C)
≡
C = A ∪B
P(A, B, C, f, g)
≡
C is the disjoint union of A and B
with injections f: A →C and g: B →C .
Also, think about a way to represent a binary relation R on A categorically; what collec-
tion of sets and functions may carry the same information as R ?
Just for fun you may also think about categorically expressed properties P such that
in a pre-order considered as a category (see paragraph 1.10) the following holds:
P(a)
≡
a is a least element
P(a)
≡
a is a greatest element
P(a, b, c)
≡
c is a greatest lower bound of a and b ,
and what is the interpretation of these properties in Set ?
1.14 Constructing new categories.
There are several ways in which new categories
can be constructed out of given ones. Here, we give just two ways, and in paragraph 1.24
we’ll sketch some other ways.
A subcategory of A is completely determined by its objects and morphisms, and A .
Formally, a subcategory of a category A is: a category in which each object, morphism,
and identity is an object, morphism, and identity in A , and in which the typing and
composition is the typing and composition of A restricted to the objects and morphisms
of the subcategory.
A full subcategory of A is completely determined by its objects, and A . Formally, a
subcategory of a category A is a full subcategory of A if: for each A, B in the subcategory,
all the morphisms with type A →B in A are morphisms in the subcategory.
A category is built upon a category A if: its morphisms are morphisms in A , and the
composition and identities are inherited from A , and further, its objects are collections of
morphisms of A , and its typing f: A →B is deﬁned as a collection of equations between

1B. FUNCTORS
13
the morphisms f, A, B in A . An example is spelled out in detail in paragraph 1.22: cate-
gory Alg(II) is built upon Set , and has binary operations as objects and homomorphisms
as morphisms. Also, in paragraph 1.23 category Mon will be deﬁned as a subcategory of
Alg(II) , and hence Mon is built upon Set too.
Exercise: prove that ‘being a subcategory of’ is a partial order: reﬂexive, antisymmetric,
and transitive. Also, prove that a subcategory of a category built upon A is itself built
upon A .
1b
Functors
A functor is a mapping from one category to another that preserves the categorical struc-
ture, that is, it preserves the property of being an object, the property of being a morphism,
the typing, the composition, and the identities. The signiﬁcance of functors is manifold:
they map one mathematical structure (category, piece of mathematics) to another, they
turn up as objects of interesting categories, they are the mathematically obvious type of
transformation between categories, and, last but not least, they form a categorical tool to
deal with “structured” objects (as we shall explain in paragraph 1.21).
1.15
Deﬁnition.
Let A and B be categories; then a functor from A to B is: a
mapping F that sends objects of A to objects of B , and morphisms of A to morphisms
of B in such a way that
Ff
:
FA →B FB
whenever f: A →A B
1.16
ftr-Type
Fid A
=
id F A
for each object A in A
1.17
Functor
F(f ; g)
=
Ff ; Fg
whenever f ; g is well-typed
1.18
Functor
Formula F: A →B means that F is a functor from A to B , and we say that A →B is
a (the) type of F . An endofunctor is: a functor of type A →A , for some A ; its source
and target are equal. By default, F, G, H, J, . . . vary over functors.
The two axioms Functor are equivalent to the single statement that functors distribute
over ﬁnite compositions:
F(f ; . . . ; g)
=
Ff ; . . . ; Fg ,
with id being the empty composition.
1.19 Example: functor II .
Consider category Set . Deﬁne mapping II (pronounced
twin, or bin from binary) as follows.
II A
=
A × A
a set, hence object in Set
II f
=
(a, a′) 7→(fa, fa′)
:
II A →II B
whenever f: A →B .

14
CHAPTER 1. THE MAIN CONCEPTS
For example, IInat is the set of pairs of natural numbers, and IIsucc maps (19, 48) onto
(20, 49) .
Mapping II satisﬁes the functor properties; it is a functor II: Set →Set .
(Exercise: verify the functor axioms.)
Functor II can be used to characterise binary
operations in a neat way. For example,
+
:
IInat →nat
n 7→(n div 10, n mod 10)
:
nat →IInat .
We shall say that the binary operations are II -ary operations.
1.20
Example: functor Seq .
Mapping Seq discussed in paragraph 0.4 is a functor
with type Set →Set . To see this, recall that:
Seq A
=
the set of ﬁnite sequences over A ,
an object in Set
Seq f
=
[a0, . . . , an−1] 7→[fa0, . . . , fan−1]
:
Seq A →Seq B
whenever f: A →B .
Property ftr-Type is the second line of the above equation for Seq f , and the equations
Seq id A = id Seq A and Seq(f
; g) = Seq f
; Seq g are easily veriﬁed. (Exercise: do this.)
Functions on or to sequences have Seq in their source or target type, respectively. For
example, function rev A that reverses sequences over A , has type Seq A →Seq A .
1.21
A use of functors.
In the deﬁnition of a category, objects are “just things”
for which no internal structure is observable by categorical means (composition, identities,
morphisms, and typing). Functors form the tool to deal with “structured” objects. Indeed,
in Set an (the?) aspect of a structure is that it has “constituents”, and that it is possible
to apply a function to all the individual constituents; this is done by Ff: FA →FB .
So II is or represents the structure of pairs; IIA is the set of pairs of A , and IIf is
the functions that applies f to each constituent of a pair. Also, Seq is or represents
the structure of sequences; Seq A is the structure of sequences over A , and Seq f is the
function that applies f to each constituent of a sequence.
Even though FA is still just an object, a thing with no observable internal structure,
the functor properties enable to exploit the “structure” of FA . The following example
may make this clear; it illustrates how functor II is or represents the structure of pairs. It
illustrates at the same time where and how the functor properties play a rˆole.
For this, let ⊕: IIA →A and ⊗: IIB →B be binary operations on sets A and B
respectively, and let f: A →B be a function. We deﬁne the notation
f
:
⊕→II ⊗
to mean
⊕; f
=
IIf ; ⊗.

1B. FUNCTORS
15
Expressed in set-theoretic terms, property f: ⊕→II ⊗means that f(x ⊕y) = f x ⊗f y
for all x, y in the source set of ⊕. Following mathematical terminology we call such a
function f a homomorphism from ⊕to ⊗.
Now, property ftr-Type implies well-typedness of the deﬁning equation of →II , indepen-
dently of the actual meaning of II . (Exercise: verify this claim.) The two other properties,
Functor, enable us to prove the following theorem independently of the actual meaning of
II . The theorem expresses that for each operation the identity is a homomorphism from
that operation to itself, and that the composition of homomorphisms is a homomorphism
again.
Theorem
id: ⊕→II ⊕
f: ⊕→II ⊗and g: ⊗→II ⊙
⇒
f ; g: ⊕→II ⊙.
Indeed, for the former we argue
id: ⊕→II ⊕
≡
deﬁnition →II
⊕; id = IIid ; ⊕
≡
lhs: Identity
id ; ⊕= IIid ; ⊕
⇐
Leibniz
id = IIid
≡
Functor
true.
For the latter we argue
f ; g: ⊕→II ⊙
≡
deﬁnition →II
⊕; f ; g = II(f ; g) ; ⊙
≡
lhs: premise f: ⊕→II ⊗, and deﬁnition →II
IIf ; ⊗; g = II(f ; g) ; ⊙
≡
lhs: premise g: ⊗→II ⊙, and deﬁnition →II
IIf ; IIg ; ⊙= II(f ; g) ; ⊙
⇐
Leibniz
IIf ; IIg = II(f ; g)
≡
Functor
true.
Not only is the actual meaning of II nowhere used, but also it is nowhere used that A, B
are sets (there is nowhere a membership ∈) or that f, g, ⊕, . . . are functions or opera-
tions, respectively. Only the category axioms (all except unique-Type) and the functor

16
CHAPTER 1. THE MAIN CONCEPTS
axioms (all of them) have been used. So the above deﬁnition, theorem, and proof are
valid for any functor and any category, not just for functor II and category Set . Here
we see how a categorical formulation suggests or eases a far-reaching generalisation: re-
place II by an arbitrary functor F , and you have a deﬁnition of ‘ F -ary operation’ and
‘ F -homomorphism’, and a theorem together with its proof about that notion, and these
are valid for an arbitrary category.
Exercise: generalise the above theorem and proof by replacing II everywhere by an arbi-
trary functor F ; check each step. Also, generalise from Set to an arbitrary category.
This concludes an illustration of the use of the functor axioms, and of using functors to
deal with “structured objects”.
1.22 Category Alg(II) .
The theorem in paragraph 1.21 gives rise to another category,
to be called Alg(II) ; an important one for algorithmics, as will become clear in the sequel.
In words, Alg(II) has the II -ary operations in Set as objects, the homomorphisms for
these operations as morphisms, and it inherits the composition and identities from Set .
(This ﬁxes everything except the typing.) Formally, Alg(II) is deﬁned thus:
an Alg(II) -object
is:
a II -ary operation in Set
an Alg(II) -morphism
is:
a homomorphism for II -ary operations, in Set
f: ⊕→Alg(II) ⊗
≡
f: ⊕→II ⊗
≡
⊕; f = II f ; ⊗
f ;Alg(II) g
=
f ;Set g
idAlg(II),⊕
=
id Set,A where A = tgtSet (⊕) .
Thus, Alg(II) is built upon Set (see paragraph 1.14 for ‘built upon’). Let us see whether
the category axioms are fulﬁlled for Alg(II) .
The theorem in paragraph 1.21 asserts
that axioms composition-Type and identity-Type are fulﬁlled. The axioms composition-
Assoc and Identity are fulﬁlled since the composition and the identities are inherited from
category Set . So, Alg(II) is at least a pre-category. With the deﬁnition above axiom
unique-Type is not fulﬁlled so that Alg(II) is not a category. The reason is that a function
can be a homomorphism for several distinct operations, that is, f: ⊕→II ⊗and f: ⊕′ →II
⊗′ can both be true while the pair ⊕, ⊗diﬀers from the pair ⊕′, ⊗′ . (Exercise: ﬁnd such
a function and operations.)
In the sequel we shall pretend that Alg(II) is made into a category (re-deﬁning it) by
the technique of constructing a category out of a pre-category, see paragraph 1.8. Thus,
f: ⊕→Alg(II) ⊗denotes the typing in Alg(II) , and implies that tgtAlg(II) f = ⊕, whereas
formula f: ⊕→II ⊗keeps to mean only that ⊕; f = II f ; ⊗.
Exercise: generalise the construction above to an arbitrary category A instead of Set .
That is, given an arbitrary category A , deﬁne the (pre)category Alg A(II) analogous to
Alg(II) above. Also, generalise II to an arbitrary functor F .
The name ‘Alg’ is mnemonic for ‘algebra’ and derives from the following observation. The
II -ary operations are, in fact, very simple algebras. Conventionally, an algebra with a

1B. FUNCTORS
17
single operation ⊕: II A →A is the pair (A; ⊕) , and A is called the carrier. Thanks
to axiom unique-Type the carrier is fully determined by the operation itself, so that the
operation itself can be considered the algebra.
1.23 Category Mon .
Now that we have deﬁned category Alg(II) , we take the oppor-
tunity to present another category, to be called Mon (mnemonic for ‘monoid’). It will be
used in Section 1d below.
First recall the notion of monoid. A monoid operation is: a binary operation that is
associative and has a neutral element (sometimes called unit, or even identity). Conven-
tionally, a monoid is: a triple (A; ⊕, e) , where ⊕: II A →A is a monoid operation and
e is its neutral element. The carrier A is uniquely determined by ⊕(thanks to axiom
unique-Type, A = tgt(⊕) ). Also, the neutral element for ⊕is unique, since e = e⊕e′ = e′
for any two neutral elements e and e′ . So, we might say that ⊕alone is, or represents,
the monoid. Anyway, we shall talk of monoid operations, rather than of monoids.
The signiﬁcance of monoid operations for algorithmics is that the reduce-with-⊕is a
well-deﬁned function of type Seq A →A when ⊕is a monoid operation; see paragraph 0.4.
Category Mon is: the subcategory of Alg(II) whose objects are the monoid operations,
and whose morphisms are those f for which f: ⊕→II ⊗and f(e) = e′ where e, e′ are
the neutral elements of ⊕, ⊗.
Exercise: give an explicit deﬁnition of the objects, morphisms, typing, composition, and
identities in Mon , and prove that the category axioms are fulﬁlled.
Exercise: prove that, in Set , Mon is not a full subcategory of Alg(II) .
1.24
More functors, new categories.
Up to now we have seen only endofunctors,
namely II and Seq ; that is, functors whose source and target are equal. There are several
reasons why it is useful to allow the source and target category of a functor to diﬀer from
each other. We brieﬂy mention three of such reasons here. At the same time, these reasons
demonstrate the need for building new categories out of given ones.
First, there is no problem in deﬁning a notion of a 2-place functor, also called a bifunc-
tor. (Exercise: try to deﬁne the notion of bifunctor formally; how would the bifunctor
axioms read?) However, by a suitable deﬁnition of the product of two categories (like
the cartesian product of sets), a 2-place functor on category A is just a normal functor
F: A × A →A . (Exercise: try to deﬁne the notion of the product category A × B of
two categories A and B . What are the objects, morphisms, typing, composition, and
identities? Prove that these satisfy the category axioms.)
Second, let A be an arbitrary category, and consider the following mapping F from
A to Set .
FA
=
{g | g is a morphism in A with src g = A},
an object in Set
Ff
=
g 7→f ;A g
:
FA →Set FB
whenever f: B →A A .

18
CHAPTER 1. THE MAIN CONCEPTS
In view of the equation for Ff we might call Ff : ‘precede with f ’, and we might write
Ff alternatively as (f ;) or (◦f) . Mapping F is like a functor; it has the properties that
f: B →A A
⇒
Ff: FA →Set FB
Fid
=
id
F(g ; f)
=
Ff ;Set Fg .
Notice that in the left hand side A and B , and also f and g , are at the wrong place for
F to be a functor. There is no problem in deﬁning a notion of a contravariant functor,
so that F is a contravariant functor. (Exercise: try to deﬁne the notion of a contravariant
functor; how would the functor axioms read?) However, by a suitable deﬁnition of the
opposite Aop of a category A , mapping F is just a normal functor F: Aop →Set .
Category Aop is obtained from A by taking the objects, morphisms and identities from
A , and deﬁning the typing and composition as follows:
f: A →Aop B
≡
f: B →A A
f ;Aop g
=
g ;A f .
One says that Aop is obtained from A by “reversing all arrows”. (Exercise: verify that
Aop is a category indeed. Verify also that mapping F above is a functor F: Aop →Set .)
Third, sometimes we need to speak about, say, pairs of morphisms in B with a common
source. (For example, the two extraction functions from a cartesian product form such a
pair.) We can do this categorically as follows. Let A be the category determined by the
following graph:
•
f
←−•
g
−→•
Then each functor F: A →B determines a pair (Ff, Fg) of morphisms in B with a
common source; and each such pair (f ′, g′) in B can so be obtained by deﬁning a suitable
functor F ′: A →B . Moreover, such pairs and such functors determine each other uniquely.
So, those pairs in B are in a precise sense equivalent to functors of type A →B , where A
is as above. (Exercise: how can you similarly express triples of morphisms with a common
target? And what about triples (f, g, h) that satisfy f ; g = h ?)
These three examples not only illustrate the usefulness of allowing a functor to have a
diﬀerent source and target, but also demonstrate the usefulness of deﬁning new categories
out of given ones, such as the product of categories, the opposite of a category, and several
ﬁnite categories.
1.25
Composite functors.
For functors F: A →B and G: B →C we deﬁne the
mappings IA and GF by
IA x
=
x
(GF)x
=
G(Fx)

1C. NATURALITY
19
for all objects and morphisms x in A . In view of the deﬁning equation we can write GFx
without semantic ambiguity. We also write just I instead of IA if A is irrelevant or clear
from the context. Thus deﬁned, I and GF are functors:
IA: A →A
F: A →B and G: B →C
⇒
GF: A →C .
The properties ftr-Type and Functor are easily veriﬁed. (Exercise: do this.) Other impor-
tant properties of these functors are: associativity of functor composition and neutrality
of I with respect to functor composition:
H (G F)
=
(H G) F
F IA
=
F
=
IB F
for F: A →B .
The associativity implies that writing H G F without parentheses causes no semantic
ambiguity.
(Exercise: are Seq II and II Seq well deﬁned, and if so, what structure do they represent?
And what about Seq Seq ?)
1.26
Category Cat .
The above properties of functors suggest a (pre)category, called
Cat . Take as objects all categories, as morphisms all functors, as typing the functor typing,
as identity on A the identity functor IA , and as composition the functor composition.
As usual, we can make a category of Cat , see paragraph 1.8. Thus our talking of ‘type’ of
functors is justiﬁed.
However, there is a foundational problem lurking here. Is this new category Cat an
object in itself? An answer, be it yes or no, would give similar problems as the supposition
that the set of all sets exists. We will neither use the new category in a formal reasoning,
nor discuss ways out of this paradox.
1c
Naturality
A natural transformation is nothing but a structure preserving map between functors.
‘Structure preservation’ makes sense, here, since we’ve seen already that a functor is, or
represents, a structure that objects might have. We shall ﬁrst give an example, and then
present the formal deﬁnition.
1.27
Naturality in Set .
Let F, G: A →Set be functors.
In the terminology of
paragraph 1.21 each FA denotes a structured set and F denotes the structure itself.
For example, II is the structure of pairs, Seq the structure of sequences, II Seq the
structure of pairs of sequences, Seq Seq the structure of sequences of sequences, and so
on.
A ‘transformation’ from structure F to structure G is: a family t of functions
tA: FA →GA , mapping set FA to set GA for each A . A transformation t is ‘natural’

20
CHAPTER 1. THE MAIN CONCEPTS
if: each tA doesn’t aﬀect the constituents of the structured elements in FA but only
reshapes the structure of the elements, from an F -structure into a G -structure; in other
words,
reshaping the structure by means of t
commutes with
subjecting the constituents to an arbitrary morphism:
that is, Ff ; tA′ = tA ; Gf for all f: A →A A′ .
As an example, consider the functions joinA: II Seq A →Seq A in Set . Family join
is a natural transformation from II Seq to Seq , since
II Seq f ; joinA′
=
joinA ; Seq f
for each f: A →A′ ,
as you can easily verify. Transformation join reshapes each II Seq -structure into a Seq -
structure, and doesn’t aﬀect the constituents of the elements in the structure.
In the next paragraph, naturality in general is deﬁned like naturality in Set ; we abstract
from Set and replace it by an arbitrary category B . The formulas remain the same, but
the interpretation above (in terms of functions, sets, and elements) may change.
1.28 Deﬁnition.
Let A, B be categories, and F, G: A →B be functors. A transfor-
mation in B from F to G is: a family ε of morphisms
εA
:
FA →B GA
for each A in A .
1.29
ntrf-Type
A transformation ε in B from F to G is natural, denoted ε: F .→G or ε: F .→B G , if:
Ff ; εB
=
εA ; Gf
for each f: A →A B .
1.30
Ntrf
This formula is (so natural that it is) easy to remember: morphism εtarget f has type
F(target f) →G(target f) and therefore occurs at the target side of an occurrence of f ;
similarly εsource f occurs at the source side of an f . Moreover, since ε is a transformation
from F to G , functor F occurs at the source side of an ε and functor G at the target
side.
The notation εA is an alternative for εA , and uses ε as a function. We also say that
ε is natural in its parameter. By default, γ, δ, ε, η, κ range over natural transformations.
Exercise: prove that 1.29 follows from the assumption that 1.30 is well-typed. (So you
need only remember 1.30.)
1.31
Example.
Natural transformations are all over the place; we give here just two
simple examples, and in paragraph 1.38 one application. The category under discussion is
Set .
First, consider the transformation rev that yields the reversal of its argument:
rev A
:
Seq A →Seq A

1C. NATURALITY
21
rev A
=
[a0, . . . , an−1] 7→[an−1, . . . , a0] .
Thus, rev reshapes a Seq -structure into a Seq -structure, not aﬀecting the constituents
of its arguments. Family rev is a natural transformation typed
rev
:
Seq .→Seq ,
since for all f: A →B
Seq f ; rev B
=
rev A ; Seq f ,
as is easily veriﬁed.
Second, consider the transformation inits that yields all initial parts of its argument:
initsA
:
Seq A →Seq Seq A
initsA
=
[a0, . . . , an−1] 7→[[ ], [a0], . . . , [a0, . . . , an−1]] .
Thus, inits reshapes a Seq -structure into a Seq Seq -structure, not aﬀecting the con-
stituents of its arguments. Family inits is a natural transformation typed
inits
:
Seq .→Seq Seq ,
since for all f: A →B
Seq f ; initsB
=
initsA ; Seq Seq f ,
as is easily veriﬁed.
Exercise: verify that each of the following well-known operations is a natural transfor-
mation of the given type:
tip
:
I .→Seq
concat
:
Seq Seq .→Seq
equals ++/,
also called ﬂatten
segs
:
Seq .→Seq Seq
parts
:
Seq .→Seq Seq Seq
yields all partitions of its argument
take n
:
Seq .→Seq
zip
:
II Seq .→Seq II
rotate
:
Seq .→Seq
swap
:
II .→II
swaps the components of its argument
exl
:
II .→I
extracts the left component of a pair .
We shall later see how to formulate the naturality of
:
and nil , and of take (not ﬁxing
one of its arguments), and how to formulate a more general naturality of swap and exl
(not restricting their arguments to the same type), and that reduce itself, operation
/ , is
a natural transformation in category Mon .

22
CHAPTER 1. THE MAIN CONCEPTS
1.32 Composition of natural transformations.
For functors F, G, H, J, K and nat-
ural transformations ε: F .→G and η: G .→H we deﬁne transformations id F, ε ; η, Jε,
and εK by
(id F)A
=
id (F A)
(ε ; η)A
=
εA ; ηA
(Jε)A
=
J(εA)
(εK)A
=
εKA .
We shall write id F A and JεA and εK A without parentheses; in view of the equations this
causes no semantic ambiguity. An alternative notation for εK is εK ; so (εK)A = ε(KA)
and we then write εKA without parentheses too. Similarly, (Jε)K = J(εK) and we
write simply JεK . These transformations are natural:
id F: F .→F
1.33
ntrf-Id
ε: F .→G and η: G .→H
⇒
ε ; η: F .→H
1.34
ntrf-Compose
ε: F .→G
⇒
Jε: JF .→JG
1.35
ntrf-Ftr
ε: F .→G
⇒
εK: FK .→GK
1.36
ntrf-Poly
Notice that for laws 1.35 and 1.36 to make sense, F and G have a common source and
a common target, the source of J is the target of F and G , and the target of K is the
source of F and G . The proofs are quite simple; we prove only law ntrf-Compose. As
regards property ntrf-Type for ε ; η we argue
(ε ; η)A: FA →HA
≡
deﬁnition of ε ; η
εA ; ηA: FA →HA
⇐
composition-Type
εA: FA →GA and ηA: GA →HA
⇐
deﬁnition
.→
ε: F .→G and η: G .→H.
And to show the naturality, property Ntrf, for ε ; η , we argue, for arbitrary f: A →B ,
Ff ; (ε ; η)B = (ε ; η)A ; Hf
≡
deﬁnition (ε ; η)
Ff ; εB ; ηB = εA ; ηA ; HF
≡
premise: naturality ε and η
εA ; Gf ; ηB = εA ; Gf ; ηB
≡
equality
true.

1C. NATURALITY
23
(Exercise: prove laws 1.33, 1.35, and 1.36.)
Further important properties of natural transformations are associativity of composition
and neutrality of id F with respect to composition of natural transformations:
ε ; (η ; θ)
=
(ε ; η) ; θ
id F
; ε
=
ε
=
ε ; id G
for ε: F .→G . The proof of these properties is simple; the properties are inherited from
composition and identities of the category. (Exercise: prove these claims.)
1.37
Category Ftr(A, B) .
The properties of composite natural transformations sug-
gest a category. Let A and B be a category. Form a new category, commonly denoted
Ftr(A, B) , as follows. Take as objects all functors from A to B , as morphisms all natural
transformations (from functors with type A →B to functors with type A →B ), as
typing the typing of naturality (above denoted
.→), as identities all identity natural trans-
formations id F , and as composition the composition of natural transformations deﬁned
above. Thus deﬁned, Ftr(A, B) is a pre-category and even a category. (Exercise: verify
this.)
1.38 Application.
Continuing the example of paragraph 1.31, we deﬁne a family tails
as follows. Function tailsA yields all tail parts of its argument sequence as its result:
tailsA
:
Seq A →Seq Seq A
tailsA
=
rev A ; initsA ; Seq rev A .
One may now suspect that, for all f: A →B ,
Seq f ; tailsB
=
tailsA ; Seq Seq f ,
so that tails: Seq .→Seq Seq . Indeed, this is almost immediate by the laws given in the
previous paragraph:
tails: Seq .→Seq Seq
≡
deﬁnition tails
rev ; inits ; Seq rev: Seq .→Seq Seq
⇐
ntrf-Compose
rev: Seq .→Seq,
inits: Seq .→Seq Seq,
Seq rev: Seq Seq .→Seq Seq
⇐
ntrf-Ftr, premises: naturality rev and inits
true.
In eﬀect, the proof of this semantic property is nothing but type checking (viewing “ : .→”
as a typing, and nowhere using the actual meaning of inits , rev , and tails ). Hadn’t we

24
CHAPTER 1. THE MAIN CONCEPTS
had available the concept and properties of naturality, the proof would have been much
longer. Indeed, explicitly using the equalities
Seq f ; rev B
=
rev A ; Seq f
Seq f ; initsB
=
initsA ; Seq Seq f
for all f: A →B , the proof of Seq f ; tails B = tailsA ; Seq Seq f would run as follows.
Seq f ; tailsB
=
deﬁnition tails
Seq f ; rev B ; initsB ; Seq rev B
=
equation for rev
rev A ; Seq f ; initsB ; Seq rev B
=
equation for inits
rev A ; initsA ; Seq Seq f ; Seq rev B
=
Functor for Seq
rev A ; initsA ; Seq(Seq f ; rev B)
=
equation for rev
rev A ; initsA ; Seq(rev A ; Seq f)
=
Functor for Seq
rev A ; initsA ; Seq rev A ; Seq Seq f
=
deﬁnition tails
tailsA ; Seq Seq f.
1.39 Omitting subscripts.
For readability we shall often omit the subscripts or argu-
ments to natural transformations when they can be retrieved from contextual information.
Here is an example; you are not supposed to understand the ‘meaning’ of the formulas.
Let the following be given:
F
:
A →B
G
:
B →A
η
:
IA .→GF
ε
:
FG .→IB ,
and consider formula
η ; Gε
=
id .
The following procedure gives the most general subscripts that make the formula well typed.
Use a, b, c, . . . as type variables (the “unknows”), use these as the subscripts, and write

1C. NATURALITY
25
the source and target type within braces at the source and target side of the morphisms,
thus:
{a}
ηb {c}
; {d}
G( {e}
εf
{g} ) {h}
=
{j}
id k {l} .
The typing axioms generate a collection of equations for the type variables:
typing η :
a, c = b, GFb
on account of ntrf-Type
typing
; :
c = d
on account of composition-Type
typing Gε :
d, h = Ge, Gg
on account of ftr-Type
typing ε :
e, g = FGf, f
on account of ntrf-Type
typing id :
j = k = l
on account of identity-Type
typing = :
a, h = j, l .
A most general (least constraining) solution for this collection of equations can be found
by the uniﬁcation algorithm, and yields
a = b = h = j = l = k = Gf
c = d = GFGf
e = FGf
g = f .
Hence, writing B for type variable f , and ﬁlling in the subscripts, the formula reads: for
arbitrary object B in B ,
ηGB ; GεB
=
id GB
:
GB →A GB ,
or, writing the subscripts as arguments, and abstracting from B ,
ηG ; Gε
=
idG
:
G .→G .
Exercise: infer in a similar way the categories, and the typing of the functors in:
η
:
I .→GF
ε
:
FG .→I .
Exercise: assuming
ε, η
:
F .→F F
κ
:
F F .→F ,
ﬁnd the most general subscripts that make ε
; Fη
; κ a well-typed term denoting a
morphism. (What function does the term denote if the category is Set , F = Seq , and
ε, η, κ = inits, tails, join/ ?)

26
CHAPTER 1. THE MAIN CONCEPTS
1d
Adjunctions
An adjunction is a particular one-one correspondence between, on the one hand, the mor-
phisms of a certain type in one category, and, on the other hand, the morphisms of a certain
type in another category. The correspondence can be formulated as an equivalence between
two equations (in the two categories, respectively). An adjunction has many properties,
and many diﬀerent but equivalent deﬁnitions.
1.40 Example.
Here is a law for sequences; it has a lot of well-known consequences, as
we shall show in a while.
“Each homomorphism on sequences is uniquely determined (as a ‘map’ followed by
a reduce) by its restriction to the singleton sequences.”
To be precise, the law reads as follows.
Let A be an arbitrary set, and ⊗be an arbitrary monoid operation, say with target
set B . Then, for all f: A →B and all g: (++A) →Mon ⊗,
f = tipA ; g
≡
Seq f ; ⊗/ = g .
SeqAdj
Thus we may call f the ‘restriction of g to the tip elements’ and write f = ⌊⌊g⌋⌋A,⊗=
tipA ; g . Also, we may call g the ‘extension of f to a homomorphism from (++A) to ⊗’
and write g = ⌈⌈f⌉⌉A,⊗= Seq f
; ⊗/ . With these deﬁnitions, and omitting the subscripts,
the equivalence reads:
f = ⌊⌊g⌋⌋
≡
⌈⌈f⌉⌉= g .
This equivalence expresses that ⌊⌊⌋⌋and ⌈⌈⌉⌉are each other’s inverse, and constitute a one-
one correspondence between functions (of a certain type) and homomorphisms (of a certain
type). Mappings ⌊⌊⌋⌋and ⌈⌈⌉⌉are called lad and rad, respectively, from left adjungate
and right adjungate; these names and notations are not standard in category theory.
The above law is an (almost full-ﬂedged) instance of an adjunction. The signiﬁcance for
algorithmics may be evident from the consequences of SeqAdj listed in paragraph 1.49.
1.41 Deﬁnition.
An adjunction involves several data:
• Two categories A and B .
[In the above example A = Set and B = Mon .]
• Two functors F: A →B and G: B →A .
[Above Ff = Seq f and Gg = g for morphisms f and g . (The fact that above
G is the identity on morphisms and therefore is invisible in the left-hand equation,
makes the example a bit special.)
For objects the above functors act as follows:
FA = (++A) , a monoid operation, and G(⊕) = the target set of ⊕.
Exercise:
check that, thus deﬁned, F and G are functors.]

1D. ADJUNCTIONS
27
• Two transformations η: I →GF in A and ε: FG →I in B .
[Above η = tip and ε⊗= ⊗/ .]
An adjunction is: such a sextuple A, B, F, G, η, ε satisfying the following property:
For arbitrary objects A in A and B in B , and morphisms f: A →A GB and
g: FA →B B ,
f = ηA ; Gg
≡
Ff ; εB = g .
1.42
Adjunction
If, given A, B, F, G , there exist η, ε such that the sextuple forms an adjunction, then
F is called left adjoint to G , and G right adjoint to F .
Exercise: verify that the law for sequences in paragraph 1.40 is an adjunction indeed, with
A, B, F, G, η, ε deﬁned as suggested a few lines up.
1.43 Corollaries.
An adjunction satisﬁes a lot of properties, some of which enable an
alternative, equivalent deﬁnition. Here we mention just a few of the properties, postponing
the (mostly simple) proofs to a later time. We list these properties only to give some idea
of the richness and importance of the notion of adjunction.
Let A, B, F, G, η, ε form an adjunction.
1. Then η and ε determine each other, and they are natural transformations η: I .→GF
and ε: FG .→I . This gives rise to two alternative characterisations of an adjunction,
one not involving η and another not involving ε .
Exercise: check the naturality of ηA = tipA in Set and of ε⊗= ⊗/ in Mon .
2. Deﬁne mappings ⌊⌊⌋⌋,
and ⌈⌈⌉⌉, , sending morphisms (of a certain type) from B
to A , and from A to B respectively, by:
⌊⌊g⌋⌋A,B
=
ηA ; Gg
: A →A GB whenever g: FA →B B
1.44
lad-Def
⌈⌈f⌉⌉A,B
=
Ff ; εB
: FA →B B whenever f: A →A GB
1.45
rad-Def
Then, for f and g of the appropriate type, and omitting the subscripts,
f = ⌊⌊g⌋⌋
≡
⌈⌈f⌉⌉= g ,
1.46
Inverse
and ⌊⌊⌋⌋and ⌈⌈⌉⌉satisfy the following fusion properties:
⌊⌊Fx ; g ; y⌋⌋
=
x ; ⌊⌊g⌋⌋; Gy
1.47
lad-Fusion
⌈⌈x ; f ; Gy⌉⌉
=
Fx ; ⌈⌈f⌉⌉; y ,
1.48
rad-Fusion
for x: A′ →A, f: A →GB in A , and g: FA →B, y: B →B′ in B .
3. From ⌊⌊⌋⌋and ⌈⌈⌉⌉that satisfy 1.46, 1.47, and 1.48, natural transformations η and
ε can be retrieved. This gives again another characterisation of an adjunction, in
which ⌊⌊⌋⌋and ⌈⌈⌉⌉do occur and η and ε don’t.
4. In addition, such ⌊⌊⌋⌋and ⌈⌈⌉⌉determine each other. This gives rise to yet another
pair of characterisations of an adjunction; one in which ⌊⌊⌋⌋doesn’t occur, and one
in which ⌈⌈⌉⌉doesn’t occur.

28
CHAPTER 1. THE MAIN CONCEPTS
1.49 Example continued.
Here are some consequences of the adjunction in mentioned
in paragraph 1.40. Actually, all these properties are instantiations of the corollaries men-
tioned in paragraph 1.43. So, these properties can be proved from the adjunction property
alone, without referring to the actual meaning of tip,
/, Seq, and the very notion of
‘sequences’.
tip ; Seq f
=
f ; tip
Seq g ; ⊗/
=
⊕/ ; g
whenever g: ⊕→II ⊗
tip ; Seq f ; ⊕/
=
f
Seq(tip ; g) ; ⊕/
=
g
whenever g: (++) →II ⊕
tip ; ⊕/
=
id
Seq tip ; ++/
=
id .
Exercise: derive these properties from the adjunction property. Take care not to use the
actual meaning of tip,
/, and Seq .
Exercise: try to give some subcollections of this list of properties that are equivalent to
the adjunction property.
Exercise: try to formulate these properties in terms of A, B, F, G, η, ε, ⌊⌊⌋⌋, ⌈⌈⌉⌉, and try to
derive them from the adjunction property. (This will be done for you in a later section.)
1.50 More corollaries.
Here are some more corollaries. Again we list them here only
to show the importance of the concept. These corollaries may be harder to understand
than those in paragraph 1.43, due to the higher level of abstraction.
1. Adjoint functors determine each other “up to isomorphism”. We shall explain the
concept of isomorphism later. More precisely, if A, B, G can be completed to an
adjunction A, B, F, G, η, ε, then F is unique up to isomorphism.
As a consequence, the existence of some F ′, η′, ε′ for which the sextuple Set, Mon,
F ′, G, η′, ε′ (with G as in the above example) forms an adjunction, is equivalent to
the existence of a monoid operation ++′A (= F ′A) that has the categorical properties
of ‘the monoid operation of sequences’. Thus, a datatype like that of sequences can
be deﬁned by a certain adjunction.
Exercise: suppose there exist Seq′, tip′,
/′, and ++′A that, substituted for Seq,
tip, /, and ++A, make the adjunction property in paragraph 1.40 well-typed and
true. Convince yourself (informally) that (tgt(++′A); ++′
A, tip′
A, the neutral element
of ++′
A) might be called ‘the datatype of sequences’.
2. (Surely, it’ll take some time and exercising before you can easily grasp the following
highly abstract statement.)
The fusion properties of ⌊⌊⌋⌋and ⌈⌈⌉⌉are equivalent
to the statement that ⌊⌊⌋⌋and ⌈⌈⌉⌉are morphisms of a certain type in category
Ftr(Aop × B, Set) (where the objects are functors and the morphisms are natural
transformations, see paragraph 1.37). So, ⌊⌊⌋⌋and ⌈⌈⌉⌉are natural transformations

1E. DUALITY
29
“of a higher type”, and the omission of the subscripts to ⌊⌊⌋⌋and ⌈⌈⌉⌉thus falls under
our convention for natural transformations.
3. If F is left adjoint to G , or, equivalently, G is right adjoint to F , then F preserves
colimits (such as initial objects and sums; all these notions will be deﬁned later), and
G preserves limits (such as ﬁnal objects and products, again to be deﬁned later).
1.51
More on adjointness.
In Appendix A we give formalisations of (most of) the
above claims, as well as their formal proofs. With the exception of the part ‘Initiality and
colimit as adjointness’, that text uses no other concepts than those known here, so that
you may start reading it right now. It is an excellent demonstration of the calculational
approach to category theory.
1e
Duality
Dualisation is a formal manipulation with practical signiﬁcance. For example, the set-
theoretic notions of cartesian product and disjoint union are characterised categorically by
notions that are each other’s dual. As another example, the categorical characterisation
of a ‘datatype for which functions can be deﬁned by induction on the structure of the
argument’ (like the datatype of sequences) is dual to the categorical characterisation of a
‘datatype for which functions can be deﬁned by induction on the structure of their result’
(like the datatype of inﬁnite lists, or streams). Dualisation also applies to theorems and
proofs, thus cutting work in half.
1.52 Deﬁnition.
The dual of a term in the categorical language is deﬁned by:
dual A
=
A
for object term A
dual x
=
x
for morphism variable x
dual(f: A →B)
=
dual f: B →A
(note the swap of A and B )
dual(f ; g)
=
dual g ; dual f
(note the swap of f and g )
dual(id A)
=
id A .
Clearly, dualising is its own inverse, that is, dual(dual t) = t for each term t . Another
easy way of dualising a morphism term is simply replacing each
; by
◦. However, the
presence of both compositions for the same morphisms is not practical. As an example,
the following two statements are each other’s dual.
∀B ∃!f ::
f: A →B
1.53
∀B ∃!f ::
f: B →A .
1.54
Dualising a less trivial statement may be more instructive.
Here is one; don’t try to
understand what it means, we’ll meet it in the sequel. Apart from dualising the statement,

30
CHAPTER 1. THE MAIN CONCEPTS
we also rename some bound variables and interchange the sides of the left-hand equation
(which doesn’t aﬀect the meaning).
∃([ ])
∀B
∀f: A →B
∀ϕ: FB →B ::
α ; f = Ff ; ϕ
≡
f = ([ϕ])
∃⌈⌊( )⌉⌋
∀B
∀g: B →A
∀ψ: B →FB ::
ψ ; Fg = g ; α
≡
g = ⌈⌊(ψ)⌉⌋.
Exercise: infer the typing of F, α, ([ ]), and ⌈⌊( )⌉⌋in these formulas. Notice that the type
of the free variable α changes due to the dualisation.
1.55 Corollary.
For each deﬁnition expressed in the categorical language, of a concept
or construction xxx, you obtain another concept, often called co-xxx if no better name
suggests itself, by dualising each term in the deﬁnition. For example, an object A is initial
in a category if: formula 1.53 holds for A . (In Set the only initial object is the empty set.)
Dually, an object A is co-initial, conventionally called ﬁnal or terminal, if: formula 1.54
holds for A . (In Set the ﬁnal objects are precisely the singleton sets.) Similarly, the other
two formulas above deﬁne dual notions of α .
Also, for each equation f = g provable from the axioms of category theory (hence valid
for all categories), the equation dual f = dual g is provable too. (Exercise: check this for
the axioms of a category.) Thus dualisation cuts work in half, and gives each time two
concepts or theorems for the price of one.
1.56
Examples.
We shall meet many examples in the sequel, notably the examples
mentioned in the introduction to this section.
Let it it suﬃce here to say that the opposite category Aop (deﬁned in paragraph 1.24)
is obtained by dualising each notion of A , that is,
an object in Aop
is:
dual A for some object A in A
a morphism in Aop
is:
dual f for some morphism f in A
f: A →B in Aop
≡
dual(f: A →B) in A
f ;Aop g
=
dual(f ;A g)
id Aop,A
=
dual(id A,A) .
It follows that (Aop)op = A , and that the dual of a statement holds for A if and only if
the statement itself holds for Aop . (So again, if a statement is true for all categories, then
its dual is true for all categories too.)
Exercise: prove that F: A →B equivales F: Aop →Bop .
Exercise: dualise the notion of natural transformation.
Exercise: dualise the notion of adjunction, and of ‘being a left adjoint’.

Chapter 2
Constructions in categories
In this chapter we discuss some categorical concepts by which some familiar (set-theoretic
or other) concepts can be expressed in categorical terms. It turns out that most charac-
terisations do not ﬁx the objects and morphisms exactly, but only ‘up to isomorphism’.
Isomorphic objects are essentially the same, as regards the “observations” by the mor-
phisms of the category.
There is a general pattern in several deﬁnitions; they turn out to deﬁne an initial or
ﬁnal object in a category built upon the category of interest (“the universe of discourse”).
Therefore we shall discuss initiality and ﬁnality extensively before we turn to the other
concepts.
2.1 Default category.
The declaration that a category is the default category means
that it is this category, rather than another one, that should be mentioned whenever there
is an ambiguity. For example, when A is declared the default category, and several other
(auxiliary) categories are discussed in the same context (in particular categories built upon
A ), then a formula like f: A →B really means f: A →A B , and ‘an object’ really means
‘an object in A ’.
2a
Iso, epic, and monic
All of the following deﬁnitions are relative to a category, the default one, which we don’t
mention explicitly to simplify the formulas. As usual, each formula is understood to be
universally quantiﬁed with “for all ⟨variables not mentioned in the context⟩of the ap-
propriate type”. Appropriateness of the type means that the formula is well-typed; see
paragraph 1.2.
2.2 Deﬁnition.
A post-inverse of a morphism f is: a morphism g such that
f ; g = id .
31

32
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
A pre-inverse of a morphism f is: a morphism g such that
g ; f = id .
An inverse of a morphism f is: a morphism g that is a pre- and post-inverse of f :
f ; g = id
∧
g ; f = id .
A morphism f has at most one inverse (see below); it is denoted f ∪if it exists.
An isomorphism is: a morphism that has an inverse.
A morphism f is epic or an epimorphism if:
f ; x = f ; y
≡
x = y .
A morphism f is monic or an monomorphism if:
x ; f = y ; f
≡
x = y .
In both equivalences the ⇐-part is an application of Leibniz.
Two objects are isomorphic if: there exists an isomorphism between them. If A and B
are isomorphic, and f: A →B is an isomorphism, then we write A ∼= B and f: A ∼= B ,
supplying a subscript A when appropriate.
2.3
Facts.
In Set , an isomorphism is a bijective function, a monomorphism is an
injective function, and an epimorphism is a surjective function, and vice versa. (Exercise:
prove this.) So, in Set a morphism is an isomorphism if and only if it is both monic and
epic. This does not hold in general: in the category suggested by • −→• (containing
three morphisms in total), the non-identity morphism is both epic and monic, and not an
isomorphism.
A morphism has at most one inverse.
For suppose that f: A →B has inverses
g, h: B →A . Then g and h are equal:
g = h
≡
Identity on both sides
id B ; g = h ; id A
≡
lhs: h is a pre-inverse of f , that is, id B = h ; f ,
rhs: g is a post-inverse of f , that is, id A = f ; g
h ; f ; g = h ; f ; g
≡
equality
true.
In fact, this calculation shows that a pre- and a post-inverse for the same morphism are
equal.
It is not true that there is at most one isomorphism between a pair of objects: in Set
all sets of cardinality n are isomorphic in n! ways.
The notions of pre- and post-inverse, and of epi- and monomorphism are each other’s
dual. The notions of inverse, and of isomorphism, are their own dual.

2A. ISO, EPIC, AND MONIC
33
Exercise: what does it mean for two sets to be isomorphic in Set ?
Exercise: what does it mean for two elements of a pre-ordered set to be isomorphic as
objects in the category determined by the pre-ordered set (see paragraph 1.10)?
Exercise: spell out in terms of Set what it means for two II -ary operations to be isomorphic
objects in Alg(II) .
Exercise: spell out in terms of B what it means for two functors from A to B to be
isomorphic as objects in Ftr(A, B) . (You may wonder whether this notion of isomorphic
functors coincides with your intuitive, informal, notion of isomorphic ‘structures’, viewing
a functor as a structure, as in paragraph 1.27.) Are functors II Seq and Seq II isomorphic
in Ftr(Set, Set) ?
Exercise: prove that the composition of isomorphisms is an isomorphism again. What is
the inverse of a composite isomorphism?
Exercise: prove that each isomorphism is both monic and epic.
Exercise: given that A is a subcategory of B , prove that each monomorphism in B is
monic in A .
Exercise: prove in Set that a function is epic iﬀit has a pre-inverse. It is not true that in
each category a morphism is epic iﬀit has a pre-inverse. Similarly, in Set a morphism is
injective iﬀit has a post-inverse, but this is not so in an arbitrary category.
2.4
“Up to isomorphism”.
The relation ∼= is an equivalence relation: reﬂexive,
symmetric and transitive. Let P be a property of objects that holds for all objects of
precisely one class of isomorphic objects. Then we sometimes speak of the P -object,
meaning: an arbitrary but ﬁxed object for which P holds. And we also say that the P -
object is unique up to isomorphism. For example, in Set “the set with 17 elements”
is unique up to isomorphism.
If a property P holds for precisely one class of isomorphic objects, and for any two
objects in the class there is precisely one isomorphism from the one to the other, then we
say that the P -object is unique up to a unique isomorphism. For example, in Set
the one-point set is unique up to a unique isomorphism, and the two-point set is not.
2.5 Discussion.
Isomorphic objects are often called ‘abstractly the same’ since for most
categorical purposes one is as good as the other: each morphism to/from the one can be
extended to a morphism to/from the other using the morphisms that establish the isomor-
phism. (The preceding sentence is informal intuition; I do not know of a formalisation of
the idea as a theorem.) This holds, of course, even more so if the isomorphism is unique.
For example, in Set all sets of the same cardinality are isomorphic, hence ‘abstractly the
same’. If you want to distinguish sets of the same cardinality on account of structural
properties, a partial order say, you should not take Set as the category but another one
in which the morphisms better reﬂect your intention. (In the case of partial orders, you
could take the order-preserving functions as the morphisms, rather than all functions.)

34
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
2b
Initiality and ﬁnality
All of the following deﬁnitions are relative to a category, the default one, which we don’t
mention explicitly to simplify the formulas. The category may and must be added to the
notations, as a subscript or otherwise, in case of ambiguity.
2.6
Conventional deﬁnition.
An object A is initial if: for each object B there is
precisely one morphism from A to B , called the mediating morphism:
∀B ::
∃!f ::
f: A →B .
Equivalently, an object A is initial if for each object B there is precisely one (at least one
and at most one) solution for f in the statement
f: A →B .
2.7
A trick.
Although the formulations of the conventional deﬁnition are quite clear,
they are not very well suited for algebraic manipulation. The formulation in paragraph 2.8
hasn’t this drawback, as will appear from the calculations in the chapters to come. (Exer-
cise: prove that initial objects are unique up to a unique isomorphism, and compare your
proof with the one given below in paragraph 2.22.) The trick to arrive at the convenient
formulation is skolemisation, named after the logician Skolem, which we’ll now explain.
An assertion of the form
∀x ::
∃! y ::
. . . y . . .
is equivalent to:
there exists a function F such that
∀x, y ::
. . . y . . .
≡
y = F x .
(∗)
In the former formulation it is the existential quantiﬁcation ( ∃y ) inside the scope of a
universal one that hinders eﬀective calculation. In the latter formulation the existence
claim is brought to a more global level; a reasoning need no longer be interrupted by the
declaration and naming of the existence of a unique y that depends on x : it can be
denoted just Fx .
In view of the important role of the various unique y’s , these y’s deserve a particular
notation that triggers the reader of their particular properties. The notations Fx , x′, and
x♯are not speciﬁc enough. Below we employ the bracket notation ([x]) and ⌈⌊(x)⌉⌋for such
Fx , and in the case of adjunctions we use the notation ⌊⌊x⌋⌋and ⌈⌈x⌉⌉. An additional
advantage of the bracket notation is that no extra parentheses are needed for composite
arguments x (which we expect to occur often).
As usual we omit in line (∗) the universal quantiﬁcations that are outermost, thus
simplifying the formulation once more.

2B. INITIALITY AND FINALITY
35
2.8
Convenient deﬁnition.
An object A is initial if: there exists a mapping ([ ])
(from objects to morphisms) such that
f: A →B
≡
f = ([B]) .
2.9
init-Charn
Mapping ([ ]) is called the mediator, and to make clear the dependency on A it is some-
times written ([A →]) . In typewriter font I would write med( ) for ([ ]) .
The initial object, if it exists, is unique up to a unique isomorphism (see paragraph 2.22
below); the default notation for it is 0 . An alternative notation for ([0 →B]) is ¡B .
Dually, an object A is ﬁnal if, for each object B , there is precisely one morphism from
B to A . In other words, an object A is ﬁnal if: there exists a mapping ⌈⌊( )⌉⌋such that
f: B →A
≡
f = ⌈⌊(B)⌉⌋
2.10
ﬁnal-Charn
Again, mapping ⌈⌊( )⌉⌋is called the mediator, and it is sometimes written ⌈⌊(
→A)⌉⌋to make
clear the dependency on A . In typewriter font I would write dem( ), the ‘dual’ of med.
By duality, the ﬁnal object, if it exists, is unique up to a unique isomorphism; the
default notation for it is 1 . An alternative notation for ⌈⌊(B →1)⌉⌋is !B .
2.11 Examples.
In Set there is just one initial object, namely the empty set. Function
([B]) is the ‘empty function’, that is, the empty set of (argument, result)-pairs. In Set
each singleton set is a ﬁnal object. Function ⌈⌊(B)⌉⌋maps each b ∈B to the sole member
of the arbitrary but ﬁxed singleton set 1 .
We shall see later that the datatype of sequences is ‘the’ initial object in a suitably
deﬁned category built upon Set , and that the datatype of streams (inﬁnite lists) is ‘the’
ﬁnal object in another suitably deﬁned category built upon Set . The morphisms in these
categories are homomorphisms, and the mediators ([ ]) and ⌈⌊( )⌉⌋capture “deﬁnitions by
induction on the structure” (structure of the argument and of the result, respectively).
We shall also see that the disjoint union and the cartesian product can be characterised
by initiality and ﬁnality, respectively, in a suitably deﬁned category built upon Set .
2.12 Corollaries.
Let A be an initial object in the category, with mediator ([ ]) . Here
are some consequences of init-Charn.
([A →B]): A →B
2.13
init-Self
id A = ([A →A])
2.14
init-Id
f, g: A →B
⇒
f = g
2.15
init-Uniq
f: B →C
⇒
([A →B]) ; f = ([A →C])
2.16
init-Fusion
Law init-Self is an instantiation of init-Charn in such a way that the right-hand side of
init-Charn becomes true: take f := ([A →B]) . The name Self derives from the fact that
([B]) itSelf is a solution for x in x: A →B .

36
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
Law init-Id is an instantiation of init-Charn in such a way that the left-hand side of init-
Charn becomes true: take B, f := A, id A .
The ‘proof’ of init-Uniq is left to the reader. The name Uniq derives from the fact that a
solution for x in x: A →B is unique.
For init-Fusion we argue (suppressing A ):
([B]) ; f = ([C])
≡
init-Charn[ B, f := C, ([B]) ; f ]
([B]) ; f: A →C
⇐
composition-Type
([B]): A →B
∧
f: B →C
≡
init-Self, and premise
true.
These ﬁve laws become much more interesting in case the category is built upon another
one, Set for example, and the typing is expressed as one or more equations in the underly-
ing category Set . In particular the importance of law Fusion cannot be over-emphasised;
we shall use it quite often.
Exercise: give a fully calculational proof of init-Uniq, starting with the obligation ‘ f = g ’
at the top line of your calculation.
Exercise: give a calculational proof of the equality ([1]) = ⌈⌊(0)⌉⌋.
Exercise: dualise the init-laws to ﬁnal-laws; prove ﬁnal-Fusion yourself, and see whether
your proof is the dual of the one given above for init-Fusion.
2.17 Proving initiality.
One may prove that an object A is initial in the category, by
providing a deﬁnition for ([ ]) and establishing init-Charn. Almost every such a proof in
the sequel has the following format. For arbitrary f and B ,
f: A →B
≡...
≡
f = an expression not involving f
≡
deﬁne ([B]) = the right-hand side of the previous equation
f = ([B]).
Actually, the last two lines in the calculation are superﬂuous: the remaining lines clearly
show that the statement f: A →B has precisely one solution for f . Nevertheless, we shall
not omit the last two lines for the sake of clarity. Sometimes the proof has the following
format:
f: A →B
⇒

2B. INITIALITY AND FINALITY
37
...
⇒
f = expression not involving f
= ([B]) , by suitably deﬁning ([ ])
⇒...
⇒
f: A →B.
In this case we say that we establish the equivalence init-Charn by circular implication.
In general the formulas are not as simple as suggested in the above calculations, since
mostly we will be dealing with initiality in categories built upon another one, so that the
typing f: A →B is a collection of equations in the underlying category.
2.18
Fact.
Law init-Self says that there exists at least one morphism from A to B .
Law init-Uniq says that there exists at most one morphism from A to B . Together they
are equivalent to init-Charn:
[Self] and [Uniq]
≡
[Charn]
2.19
where the square brackets denote the universal quantiﬁcation that was implicit in the
formulations above. The ⇐-part has been argued in paragraph 2.12; for the ⇒-part we
show equivalence init-Char by circular implication:
f: A →B
(left-hand side of init-Charn)
≡
init-Self
f: A →B and ([B]): A →B
⇒
init-Uniq
f = ([B])
(right-hand side of init-Charn)
≡
init-Self
f = ([B]) and ([B]): A →B
⇒
proposition logic, equality
f: A →B
(left-hand side of init-Charn)
In our experience, proving initiality by establishing init-Self (for some morphism denoted
([B]) ) and init-Uniq is by no means simpler or more elegant than establishing init-Charn
directly, in the way explained in paragraph 2.17.
2.20
Well-formedness condition.
Frequently we encounter the situation that there
is a category A and another one, B say, that is built upon A . Then the well-formedness
condition for the notation ([B])B (where B is a composite entity in the underlying category
A ) is the condition that B an object in B ; this is not a purely syntactic condition.
B is an object in B
⇒
([B])B is a morphism in A
2.21
init-Type
In the sequel we adhere to the (dangerous?) convention that in each law the free variables
are quantiﬁed implicitly in such a way that the well-formedness condition, the premise of
init-Type, is met.

38
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
2.22
Application.
Here is an example of calculating with initiality: proving that an
initial object is unique up to a unique isomorphism. Suppose that both A and B are
initial. We claim that ([A →B]) and ([B →A]) establish the isomorphism and are unique
in doing so. By init-Self they have the correct typing. We shall show
f = ([A →B]) ∧g = ([B →A])
≡
f ; g = id A ∧g ; f = id B ,
that is, both compositions of ([A →B]) and ([B →A]) are the identity, and conversely the
identities can be factored (as in the right-hand side) only in this way. We prove both
implications of the equivalence at once.
f = ([A →B])
∧
g = ([B →A])
≡
init-Charn
f: A →B
∧
g: B →A
≡
composition
f ; g: A →A
∧
g ; f: B →B
≡
init-Charn
f ; g = ([A →A])
∧
g ; f = ([B →B])
≡
init-Id
f ; g = id A
∧
g ; f = id B.
The equality ([A →B])
; ([B →A]) = id A can be proved alternatively using init-Id, init-
Fusion, and init-Self in that order. (This gives a nice proof of the weaker claim that initial
objects are isomorphic.)
2c
Products and Sums
Products and sums are dual categorical concepts that, specialised to category Set, yield the
well-known notions of cartesian product and disjoint union. (In other categories products
and sums may get a diﬀerent interpretation.)
2.23
Disjoint union.
As an introduction to the deﬁnition of the categorical sum, we
present here a categorical description of the disjoint union. Let the default category be
Set . The disjoint union of sets A and B is a set, usually called A + B , with several
operations associated with it. There are the injections
inl: A →A + B
inr: B →A + B ,
and there may be a predicate that tests whether an element in A + B is inl(x) or inr(y)
for some x ∈A or some y ∈B . Using the predicate one can deﬁne an operation that in

2C. PRODUCTS AND SUMS
39
programming languages is known as a case construct, and vice versa. The case construct
of f and g is denoted f ∇g and has the following typing and semantics.
f ∇g: A + B →C
for f: A →C and g: B →C
and
inl ; f ∇g
=
x 7→f x
for each x ∈A
inr ; f ∇g
=
y 7→g y
for each y ∈B .
By extensionality the two equations read:
inl ; f ∇g
=
f
inr ; f ∇g
=
g .
Moreover, f ∇g is the only solution for h in the two equations:
inl ; h
=
f
inr ; h
=
g .
This is an important observation; it holds for each representation of disjoint unions! Indeed,
a ‘disjoint union’-like concept for which the claim does not hold, is normally not considered
to be a proper ‘disjoint union’ of A and B .
Exercise: consider the representation A + B = {0}×A ∪{1}×B , and work out operations
inl, inr, and f ∇g . Also, think of another representation for A + B , and work out the
operations again. Prove in each case the above claims. Would you call A ∪B a disjoint
union of A and B ? Why, or why not?
In summary, we call functions inl: A →D and inr: B →D together with their target D
a disjoint union of A and B if, and only if, for each f: A →C and g: B →C there is
precisely one function h , henceforth denoted f ∇g , such that
inl ; h = f ∧inr ; h = g .
2.24
This is an entirely categorical formulation. In addition, the formulation suggests to look
for a characterisation by means of initiality (or ﬁnality). With a suitable deﬁnition for
W(A, B) (given below), the above pair of equations can be formulated as
h: (inl, inr) →W
(A,B) (f, g) .
2.25
So (inl, inr) is initial in W(A, B) .
Having available the pair (inl, inr) (as ‘the’ initial
object in
W(A, B) ), the set A + B can be deﬁned by A + B = tgt inl = tgt inr . Thus the
notion of disjoint union has been characterised categorically, by initiality, and it turns out
that the injections inl, inr and operation
∇are as relevant for the notion of disjoint union
of A and B as the set A + B itself.

40
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
2.26
Category
W( ⃗A) .
Let A be a category, the default one; in the above discussion
we had A = Set . Let ⃗A be an n -tuple of objects. Then category W( ⃗A) is: the category
built upon A with the following objects, morphisms, and typing. An object in
W( ⃗A) is:
an n -tuple of morphisms in A with a common target and the objects ⃗A as sources.
•
•
•
· · ·
•
•
A
A
A
A
A
A
A
A
AAU
C
C
C
C
C
C
C
C
CCW?









...
⃗A
⃗f
•
· · ·
•
•
•
?
          	
...
@
@
@
@
@
@
@
@
@
@
R ?
...
-
⃗A
⃗f
⃗g
h
Let ⃗f and ⃗g be such objects; then a morphism from ⃗f to ⃗g in
W( ⃗A) is: a morphism h in
A satisfying fi ; h = gi for each index i of the n -tuple. It follows that h: tgt ⃗f →A tgt⃗g .
Exercise: spell out the deﬁnition of W(A) . This category is commonly called the ‘co-slice’
category ‘under A ’.
Exercise: does the text above deﬁne a category or a pre-category?
Exercise: spell out the deﬁnition of
W(A, B) , taking A to be Set . Verify the equivalence
of formulas 2.24 and 2.25.
Exercise: check the sensefulness of the following deﬁnition. A parallel pair with source
A is: an object in
W(A, A) .
Exercise: deﬁne V( ⃗A) dually to W( ⃗A) .
Having discussed a categorical characterisation (deﬁnition) of disjoint unions, we now ab-
stract from Set , and thus obtain a deﬁnition of sums.
2.27
Sum.
Let A be an arbitrary category, the default category, and let A, B be
objects. A sum of A and B is: an initial object in
W(A, B) ; it may or may not exist. Let
(inl, inr) be a sum of A and B ; their common target is denoted A + B . We abbreviate
([(inl, inr) →(f, g)])W
(A,B) to just f ∇g , not mentioning the dependency on A, B and inl, inr .
Working out ‘being an object in W(A, B) ’ in terms of A yields the following instantiation
of init-Type:
f: A →C ∧g: B →C
⇒
f ∇g: A + B →C
∇-Type
Working out the typing in W(A, B) in terms of equations in A yields the following in-
stantiations of the laws for initiality:
inl ; f = g ∧inr ; f = h
≡
f = g ∇h
∇-Charn
inl ; f ∇g = f ∧inr ; f ∇g = g
∇-Self
inl ∇inr = id
∇-Id

2C. PRODUCTS AND SUMS
41
inl ; f = inl ; g ∧inr ; f = inr ; g
⇒
f = g
∇-Uniq
f ; k = h ∧g ; k = j
⇒
f ∇g ; k = h ∇j
∇-Fusion
Law
∇-Uniq says that the pair inl, inr is jointly epic.
Law
∇-Fusion simpliﬁes to an
unconditional law by substituting h, j := f ; h, g ; h :
f ∇g ; h = (f ; h) ∇(g ; h)
∇-Fusion
Similar simpliﬁcations will be done tacitly in the sequel.
Notice that for given f: A + B →C the equation x ∇y = f deﬁnes x and y , since
by
∇-Charn that one equation equivales the two equations x = inl
; f and y = inr
; f .
We shall quite often use this form of deﬁnition.
The usual categorical notation for f ∇g is [f, g] ; the symbol
∇was ﬁrst used for this
purpose by Fokkinga and Meijer [5]. Operation
∇is sometimes called junc, from junction;
I myself like the name dis, from disjunction, and in typewriter font I would write dis.
Morphisms inl and inr are called injections. In the case of the straightforward gener-
alisation of an n -fold sum, we denote the injections by in0, . . . , inn−1 , possibly decorated
with n as well.
Exercise: verify that all ﬁve
∇-laws above are instantiations of the laws for initiality by
substituting, amongst others, A, A := W(A, B), (inl, inr) in the init-laws.
Exercise: take A = Set , so that a sum of two sets is a disjoint union of the sets, and
prove the laws Self, . . . Fusion in set-theoretic terms for one particular representation for
the disjoint union.
Exercise: initial objects are unique up to a unique isomorphism; work out in terms of A
what that means for (inl, inr) .
2.28 Product.
Products are, by deﬁnition, dual to sums. Let exl, exr be a product of
A and B , supposing one exists; its common source is denoted A × B . We abbreviate
⌈⌊(f, g →exl, exr)⌉⌋V
(A,B) to just f ∆g . The typing law works out as follows:
f: C →A ∧g: C →B
⇒
f ∆g: C →A × B
∆-Type
The laws for exl , exr and
∆work out as follows:
f ; exl = g ∧f ; exr = h
≡
f = g ∆h
∆-Charn
f ∆g ; exl = f ∧f ∆g ; exr = g
∆-Self
exl ∆exr = id
∆-Id
f ; exl = g ; exl ∧f ; exr = g ; exr
⇒
f = g
∆-Uniq
f ; g ∆h = (f ; g) ∆(f ; h)
∆-Fusion
Law
∆-Uniq says that the pair (exl, exr) is jointly monic. Law
∆-Fusion has been simpliﬁed
to an unconditional form.

42
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
Notice that for given f: A →B × C the equation x ∆y = f deﬁnes x and y , since
by
∆-Charn that one equation equivales the two equations x = f ; exl and y = f ; exr .
The usual categorical notation for f ∆g is ⟨f, g⟩; the symbol
∆was ﬁrst used for this
purpose by Fokkinga and Meijer [5]. Operation
∆is sometimes called split; I myself like
the name con, from conjunction, and in typewriter font I would write con. Morphisms
exl and exr are called extractions. In the case of the straightforward generalisation of
an n -fold product, we denote the extractions by ex 0, . . . , ex n−1 , possibly decorated with
n as well.
Exercise: check that these laws are the dual of those for sums.
2.29 Application.
As an application of the laws for sum and product we show that
∇
and
∆abide. Two binary operations
|⃝and ⊖abide with each other if: for all values
a, b, c, d
(a |⃝b) ⊖(c |⃝d)
=
(a ⊖c) |⃝(b ⊖d) .
Writing a |⃝b as a | b and a ⊖b as
a
b , the equation reads
a | b
c | d
=
a
c | b
d .
The term abide has been coined by Bird [3] and comes from “above-beside.” In category
theory this property is called a ‘middle exchange rule’ or ‘interchange rule’.
Here is a proof that
∇and
∆abide:
(f ∇g) ∆(h ∇j) = (f ∆h) ∇(g ∆j)
≡
∇-Charn [f, g, h := lhs, f ∆h, g ∆j]
inl ; (f ∇g) ∆(h ∇j) = f ∆h
∧
inr ; (f ∇g) ∆(h ∇j) = g ∆j
≡
∆-Fusion (at two places)
(inl ; f ∇g) ∆(inl ; h ∇j) = f ∆h
∧
(inr ; f ∇g) ∆(inr ; h ∇j) = g ∆j
≡
∇-Self (at four places)
f ∆h = f ∆h
∧
g ∆j = g ∆j
≡
equality
true.
Exercise: give another proof in which you start with
∆-Charn rather than
∇-Charn.
Exercise: give another proof in which you start as above and then apply
∆-Charn at the
second step (at two places).
Exercise: choose an explicit representation for the disjoint union (and cartesian product),
and prove the abides law in set-theoretic terms, using the chosen representation.

2D. COEQUALISERS
43
2.30
More laws.
For arbitrary categories in which sums and products, respectively,
exist, we deﬁne, for f: A →B and g: C →D ,
f + g
=
(f ; inl) ∇(g ; inr)
:
A + C →B + D
f × g
=
(exl ; f) ∆(exr ; g)
:
A × C →B × D .
In case the category is Set , function f × g acts componentwise: (a, b)
f×g
7→(fa, gb) ; sim-
ilarly, inl(a)
f+g
7→inl(fa) and inr(b)
f+g
7→inr(gb) . The mappings + and × are bifunctors:
id + id = id and f + g
; h + j = (f ; h) + (g ; j) , and similarly for × . Throughout the
text we shall use several properties of product and sum. These are referred to by the hint
‘product’ or ‘sum’. Here is a list; some of these are just the laws presented before.
f × g ; exl
=
exl ; f
inl ; f + g
=
f ; inl
f ∆g ; exl
=
f
inl ; f ∇g
=
f
f × g ; exr
=
exr ; g
inr ; f + g
=
g ; inr
f ∆g ; exr
=
g
inr ; f ∇g
=
g
f ; g ∆h
=
(f ; g) ∆(f ; h)
f ∇g ; h
=
(f ; h) ∇(g ; h)
exl ∆exr
=
id
inl ∇inr
=
id
(h ; exl) ∆(h ; exr)
=
h
(inl ; h) ∇(inr ; h)
=
h
f ∆g ; h × j
=
(f ; h) ∆(g ; j)
f + g ; h ∇j
=
(f ; h) ∇(g ; j)
f × g ; h × j
=
(f ; h) × (g ; j)
f + g ; h + j
=
(f ; h) + (g ; j)
f ∆g = h ∆j
≡
f = h ∧g = j
f ∇g = h ∇j
≡
f = h ∧g = j
Exercise: identify the laws that we’ve seen already, and prove the others.
Exercise: above we’ve explained f ×g and f +g in set-theoretic terms in case the category
is Set ; which of the equations comes closest to those speciﬁcations “at the point-level”?
Exercise: what about the following equivalences:
f × g = h × j
?≡
f = h ∧g = j
f + g = h + j
?≡
f = h ∧g = j
Are these true in each category? (Answer: no. Hint: in Set we have A × ∅= ∅for each
A . Now take f, h: A →A arbitrary, and g = j = id ∅.)
Exercise: prove that in each category each exl A,A is epic, whereas exl A,B is not necessarily
epic. (Hint: take B = ∅in Set .)
Exercise: prove that in each category that has products and a ﬁnal object, 1×A ∼= A and
A × (B × C) ∼= (A × B) × C .
2d
Coequalisers
As another example of a categorical characterisation by initiality, we present here the
notion of coequaliser. A coequaliser is a categorical notion that, specialised to category
Set , yields the well-known and important notion of induced equivalence relation.

44
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
2.31 Category
W(f ∥g) .
In order to characterise coequalisers by initiality, we need the
auxiliary notion of W(f ∥g) .
Let A be a category, the default one (think for example of Set ). Let (f, g) be a parallel
pair, that is, f and g have a common source and a common target. Then W(f ∥g) is the
category built upon A as follows. An object in
W(f ∥g) is: a morphism p in A satisfying
f
; p = g ; p . Let p and q be objects in W(f ∥g) ; then a morphism in W(f ∥g) from p
to q is: a morphism x in A such that p ; x = q .
•
-
f
-
g
•
-
p
HHHHHHH
j
q
•
?x
•
The phrase ‘ p is an object in W(f ∥g) ’ is just a concise way of saying ‘ p is a morphism
satisfying f ; p = g ; p ’. Unfortunately there is no simple noun or verb for this property.
2.32
Deﬁnition.
Let A be a category, the default one. Let (f, g) be a parallel pair.
Then, a coequaliser of f, g is: an initial object in
W(f ∥g) .
Let p be a coequaliser of (f, g) , supposing one exists. We write p\f,gq or simply p\q
instead of ([p →q])W
(f∥g) since, as we shall explain, the fraction notation better suggests
the calculational properties. Working out the deﬁnition of being an object in
W(f ∥g) in
terms of equations in A , we obtain the following instantiation of the laws for initiality.
f ; q = g ; q
⇒
p\q: tgt p →tgt q
\-Type
and further:
p ; x = q
≡
x = p\q
\-Charn
p ; p\q = q
\-Self
id = p\p
\-Id
p ; x = q ∧p ; y = q
⇒
x = y
\-Uniq
q ; x = r
⇒
p\q ; x = p\r
\-Fusion
In accordance with the convention explained in paragraph 2.20 we have omitted in laws
\-Charn, \-Self and \-Fusion the well-formedness condition that q is an object in W(f∥g) ;
the notation ...\q is only senseful if f
; q = g ; q , like in arithmetic where the notation
m/n is only senseful if n diﬀers from 0 . Notice that \ -Uniq and \ -Fusion simplify to:
p ; x = p ; y
⇒
x = y
\-Uniq
p\q ; x = p\(q ; x)
\-Fusion
Thus, \ -Uniq expresses that a coequaliser is epic.

2D. COEQUALISERS
45
2.33 Additional laws.
The following law conﬁrms the choice of notation once more.
p\q ; q\r = p\r
\-Compose
Here is one way to prove it.
p\q ; q\r
=
\-Fusion
p\(q ; q\r)
=
\-Self
p\r.
An interesting aspect is that the omitted subscripts to \ may diﬀer: e.g., p\f,gq and
q\h,jr , and q is not necessarily a coequaliser of f, g .
Rephrased in the notation for
initiality in general, law \-Compose reads:
([A →B])A ; ([B →C])B = ([A →C])A
2.34
init-Compose
where A and B are full subcategories of some category C and objects B, C are in both
A and B ; in our case A = W(f∥g) , B = W(h∥j) , and C = W(D) where D is the common
target of f, g, h, j . Then the proof runs as follows.
([A →B])A ; ([B →C])B = ([A →C])A
⇐
init-Fusion
([B →C])B: B →A C
≡
both A and B are full subcategories of C ,
each containing both B and C
([B →C])B: B →B C
≡
init-Self
true.
Here is another law; its proof shows two of the above laws in action. As before, let p be
a coequaliser. Then
F(p\q) = Fp\Fq
\-Ftr
The implicit well-formedness condition here is that Fp is a coequaliser.
Clearly, this
condition is valid when F preserves coequalisers. The proof of the law reads:
F(p\q) = Fp\Fq
≡
\-Charn
Fp ; F(p\q) = Fq
≡
functor

46
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
F(p ; p\q) = Fq
≡
\-Self
true.
Exercise: let p be a coequaliser of a parallel pair (f, g) , and let h be an epimorphism
with tgt h = src f = src g . Prove that p is a coequaliser of (h ; f, h ; g) .
Exercise: let pi be a coequaliser of a pair (fi, gi) , for i = 0, 1 . Prove that p0 + p1 is a
coequaliser of (f0 + f1, g0 + g1) , assuming that sums exist.
2.35
Interpretation in Set .
Take A = Set , the default category, and let A be a
set. Each parallel pair (f, g) with target A determines a binary relation Rf,g on A ,
and conversely, each binary relation R on A determines a parallel pair (fR, gR) in the
following way:
Rf,g
=
{(fx, gx) | x ∈src f}
⊆A × A
fR
=
exl
: {(x, y) | x R y} →A
gR
=
exr
: {(x, y) | x R y} →A .
In this way parallel pairs with target A represent binary relations on A .
In a similar but diﬀerent way, functions with source A (that is, objects in W(A) )
represent equivalence relations. Speciﬁcally, each function q with source A determines
an equivalence relation Eq on A , and conversely, each equivalence relation E on A
determines such a function qE , in the following way:
Eq
=
{(x, y) | qx = qy}
⊆A × A
qE
=
x 7→the E -equivalence class containing x
: A →A/E .
Exercise: check, or prove, each of the following claims. Category
W(f ∥g) is a subcategory
of W(A) . For object p in W(A) , relation Ep is an equivalence relation. For objects p, q
in W(A) , there exists a function x with x: p →W
(A) q if and only if Ep ⊆Eq . For
each object q in W(f ∥g) , Rf,g ⊆Eq . Let p be a coequaliser of (f, g) ; then Ep is the
least equivalence relation including Rf,g , that is, Ep is the equivalence relation induced
by Rf,g .
Exercise: let p be a coequaliser of a parallel pair (f, g) with target A , and deﬁne B
and q: A →B by:
B
=
tgt p ∪{•}
q
=
x 7→px,
for each x ∈A
:
A →B .
Is q also a coequaliser of (f, g) ? (Hint: by construction, q is not surjective.) Give x
and y satisfying x: p →W
(A) q and y: q →W
(A) p , if they exist. Let r be an object in
W(f ∥g) ; prove or disprove the existence of at least one solution for x in x: q →W
(f∥g) r ,
and prove or disprove the existence of at most one solution for x .

2E. COLIMITS
47
2e
Colimits
The notion of colimit is a far-reaching generalisation of the notions of sum, coequaliser,
and several others. Each colimit is a certain initial object, and each initial object is a
certain colimit. We shall brieﬂy deﬁne the notion of colimit, and present its calculational
properties derived from the characterisation by initiality. We shall also give a nontrivial
application involving colimits.
By deﬁnition, limits are dual to colimits. So by duality limits generalise such notions
as product, equaliser, and several others. Each limit is a certain ﬁnal object, and each ﬁnal
object is a certain limit.
The formal deﬁnition uses the notions of a diagram D and of the cocone category WD ,
which we now present.
2.36
Diagram.
Let A be a category, the default one. A diagram in A is: a graph
whose nodes are labelled with objects and whose edges are labeled with morphisms, in such
a way that the labeling is “consistent” with the typing of the category, that is, for labeling
A•
f
−→
B• in the diagram, it is required that f: A →B in the category. As a consequence,
if
f
−→•
g
−→is in the diagram, then tgt f = src g in the category.
Although a diagram in A is (or: determines) a category, that category is not necessarily
a subcategory of A ; distinct edges may have the same label. Here is a counterexample.
Let A be the category determined by:
•A
-
f
•B
-
g
•C
and put h = f ; g . Then these are diagrams in A :
•A
-
f
-
f
•B
•A
-
f
•B
-
g
•C

	
h

In the left diagram there are two edges (morphisms) from A to B , whereas in A there
is only one. In the right diagram there are two edges (morphisms) from A to C , labelled
f ; g and h respectively, whereas in A there is only one; by deﬁnition h = f ; g .
Extreme cases of diagrams are diagrams with zero, one, or more nodes only, and no
edges at all.
For simplicity in the formulations to come, we consider a diagram in A to be a functor
D: D →A , where D is a graph (hence category) giving the shape of the diagram in A ,
and D gives the labeling: a node A in D is labeled DA (an object in A ), and an edge
f in D is labeled Df (a morphism in A ).

48
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
2.37
Category
WD .
Let A be a category, the default one, and let D: D →A be a
functor, hence diagram in A . Then category WD , built upon A , is deﬁned as follows; its
objects are called cocones for D .




•
DA
-
Df • DB · · ·
• C
A
A
A
A
A
A
A
A
AAU
C
C
C
C
C
C
C
C
CCW?









DD
γ
γA
γB




•
DA
· · ·
•
•
?









         	
...
@
@
@
@
@
@
@
@@
R
S
S
S
S
S
S
S
S
SSw ?
...
-
DD
γ
δ
x
A cocone for D is: a family γA: DA →C of morphisms (for some C ), one for each A
in D , satisfying:
Df ; γB
=
γA
for each f: A →D B .
This condition is called ‘commutativity of the triangles’. Using naturality and constant
functors there is a technically simpler deﬁnition of a cocone. Deﬁne C to be the constant
functor, C x = C for each object x , and C f = id C for each morphism f . Now, each
cocone for D is a natural transformation γ: D .→C in A (for some C ), and vice versa.
(Exercise: check this.)
We deﬁne, for the γ above, tgt γ = C .
(Notice that γ is a
morphism in the functor category F = Ftr(D, A) , so that tgtF γ = C . The object C
really forms part of the cocone, even if D is empty and, hence, γ is an empty family. To
stress this fact, one might prefer to deﬁne a cocone as a pair (C, γ) .)
Continuing the deﬁnition of category
WD , let γ and δ be cocones for D ; then, a
morphism from γ to δ in WD is: a morphism x satisfying γA ; x = δA for each object
A in D . It follows that x: tgt γ →tgt δ . The condition on x can be written simply
γ ; x = δ , when we deﬁne the composition of a cocone with a morphism by:
(γ ; x)A
=
γA ; x .
(composition of a cocone with a morphism)
Then
γ: D .→C and x: C →C′
⇒
γ ; x: D .→C′ .
(An alternative would be to write γ
; x , since for x: C →C′ the constant function
x = A 7→x is a natural transformation of type C .→C′ .)
2.38
Deﬁnition.
Let A be a category, the default one, and let D diagram in A . A
colimit for D is: an initial object in WD ; it may or may not exist.
Let γ be a colimit for D . We write ([ ]) as γ\ . Working out the deﬁnition of cocone
in terms of equations in A , we obtain the following characterisation of a colimit. There
exists a mapping γ\
such that
δ cocone for D
⇒
γ\δ: tgt γ →tgt δ
\ -Type

2E. COLIMITS
49
and further \ -Charn holds, and its corollaries too:
γ ; x = δ
≡
x = γ\δ
\-Charn
γ ; γ\δ = δ
\-Self
γ\γ = id
\-Id
γ ; x = γ ; y
⇒
x = y
\-Uniq
γ\δ ; x = γ\(δ ; x)
\-Fusion
γ\δ ; δ\ε = γ\ε
\-Compose
F(γ\δ) = Fγ\Fδ
\-Ftr
for D -cocones δ and ε ( δ and Fγ being a colimit when occurring as the left argument
of \ .) Law \ -Uniq asserts that each colimit is ‘jointly epic’. For the proof of \ -Compose
and \ -Ftr see law init-Compose and \ -Ftr in paragraph 2.33.
2.39 Another law.
Here is another law. Write the subscripts to natural transformations
as proper arguments: γA = γA , and recall the deﬁnition (γF)A = γ(FA) , for a functor
F . Let both γ and γF be colimits (for the same diagram). Then, for each cocone δ for
that same diagram:
γF\δF
=
γ\δ
Here is the proof:
γF\δF = γ\δ
≡
\ -Charn [γ, δ, x := γF, δF, γ\δ]
γF
; γ\δ = δF
≡
\ -Self applied within the right-hand side: δ = γ ; γ\δ
γF
; γ\δ = (γ ; γ\δ)F
≡
extensionality
(γF
; γ\δ)A = (γ ; γ\δ)FA
for each A
≡
composition of cocone with a morphism
true.
We shall now show in paragraphs 2.40, 2.41, and 2.42 that initial objects, sums, and
coequalisers are colimits. Then we give in paragraph 2.43 an example of a colimit that
explains the term ‘limit’. Finally in paragraph 2.44 we give an nontrivial application of
the laws for colimits. In paragraph A.55 it is shown that left adjoints preserve colimits.

50
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
2.40
Initiality as colimit.
Let A be a category, the default one. Take D empty, so
that D: D →A is the empty functor. Then a cocone δ for D is the empty family ( )B
of morphisms, where B = tgt δ .
Suppose γ = ( )A is a colimit for D ; it may or may not exist. Then A is initial in
A . To show this, we establish init-Charn, constructing ([ ]) along the way. For arbitrary
object B and morphism x ,
x: A →B
≡
property of the empty natural transformations ( )A and ( )B
( )A ; x = ( )B
≡
γ = ( )A is colimit for D , and ( )B is cocone for D ; \ -Charn
x = γ\( )B
≡
deﬁne ([B]) = γ\( )B
x = ([B]).
Exercise: show that, if there exists an initial object in A , then there exists a colimit for
the diagram D above.
2.41
Sum as colimit.
Let A be the default category, and let A and B be objects.
Take D and D as suggested by DD = (
A•
B•) . Then a cocone δ for D is a two-member
family δ = (f, g) with f: A →C and g: B →C , where C = tgt δ .
Let γ = (inl ′, inr ′) be a colimit for D . Then γ is a sum of A and B . To show this,
we establish the existence of
∇′
for which
∇′ -Charn holds, constructing
∇′ along the
way. For arbitrary f: A →C , g: B →C , and morphism x ,
inl ′
; x = f and inr ′ ; x = g
≡
composition of a cocone with a morphism, extensionality
(inl ′, inr ′) ; x = (f, g)
≡
γ = (inl ′, inr ′) is colimit and (f, g) is cocone for D ; \ -Charn
x = γ\(f, g)
≡
deﬁne f ∇′ g = γ\(f, g)
x = f ∇′ g.
Exercise: show that, if a sum of A and B exists, then there exists a colimit for the
diagram D above.
2.42
Coequaliser as colimit.
Let A be the default category, and let (f, g) be a
parallel pair, with source A′ and target A say. Take D and D as suggested in the top
lines of the following pictures.

2E. COLIMITS
51
•
A′
-
f
-
g
• A
C
C
C
C
C
C
C
C
CCW









q′
q
•
•
A′
-
f
-
g
• A
?
A
A
A
A
A
A
A
A
AAU









?
p′ p
q′ q
•
•
-
x
Then a cocone δ for D is a two-member family δ = (q′, q) with q′: A′ →C and
q: A →C , where C = tgt δ , and q′ = f
; q = g ; q (hence q′ is fully determined by q
alone).
Let γ = (p′, p) be a colimit for D ; it may or may not exist. Then p is a coequaliser
of (f, g) . To show this, we establish the existence of a mapping p\
for which coeq-Charn
holds, constructing p\
along the way. For arbitrary q with f ; q = g ; q , and morphism
x ,
p ; x = q
≡
put p′ = f ; p = g ; p and q′ = f ; q = g ; q
p′ ; x = q′ and p ; x = q
≡
composition of a cocone with a morphism, extensionality
(p′, p) ; x = (q′, q)
≡
γ = (p′, p) is colimit and (q′, q) is cocone for D ; \ -Charn
x = γ\(q′, q)
≡
deﬁne p\q = γ\(q′, q) where q′ = f ; q = g ; q
x = p\q.
Exercise: show that, if there exists a coequaliser for the parallel pair (f, g) , then there
exists a colimit for the diagram D above.
2.43
“Limit point” as colimit.
This example explains the name ‘limit’: (co)limits
may deﬁne real limiting points. Let Set be the default category, and consider an inﬁnite
sequence of sets, each including the previous one: A0 ⊆A1 ⊆A2 . . . . The subsets are
partly identical (they have some elements in common), but categorically they are diﬀerent
objects. An inclusion A ⊆A′ is expressed categorically by the existence of an injective
function f: A →A′ that embeds each element from A into A′ . (In this way, a set may
be a subset of another one in several distinct ways.) So the sequence of embeddings is
expressed by the diagram:
•
A0
-
f0
•
A1
-
f1
•
A2
· · ·
Each composition fi
; fi+1
; · · · ; fj−1: Ai →Aj denotes the accumulated embedding of
Ai into Aj . Now consider a cocone δ for that diagram:

52
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
•
A0
-
f0
•
A1
-
f1
•
A2
· · ·
•B
&
%
δ0
&
%
δ1
&
%
δ2
6
δ
The equalities fi
; δi+1 = δi imply that fi
; fi+1
; · · · ; fj−1
; δj = δi . So each element
from each of the subsets is mapped “unambiguously” into B via δ . (It is not true in
general that B includes each Ai , since δi need not be injective; indeed, B might be the
one-point set.)
Let A = S(n :: An) , the inﬁnite union of all the subsets, and let γi be the embedding of
Ai in A in such a way that each element of each of the subsets is mapped “unambiguously”
(as explained for δ above) into A . We claim that γ is a colimit for that diagram.
•
A0
-
f0
•
A1
-
f1
•
A2
· · ·
•A
-
x
•B
&
%
&
%
&
%
6
γ
&
%
&
%
&
%
6
δ
To prove the claim, we must show that, for arbitrary cocone δ for that diagram, there is
precisely one solution x for the equation γ ; x = δ . Consider the function x′ that maps
an element a ∈A onto δi(a′) ∈B , where i, a′ are such that γi(a′) = a . There exists for
every a ∈A a pair i, a′ with γi(a′) = a , since by deﬁnition A is the least set including all
Ai . The ‘commutativity of the triangles’ (of both γ and δ ) implies that the speciﬁcation
of x′ is unambiguous: δi(a′) = δj(a′′) if γi(a′) = γj(a′′) . Clearly, this x′ is a solution for
x in γ ; x = δ ; we leave it as an exercise to show that it is the only solution.
In eﬀect, γ represents the inﬁnite composition (embedding) f0
; f1
; f2
; · · · ; more
precisely, γ is the limit of f0 ; f1 ; f2 ; · · · .
2.44
Application.
We present the well-known construction of an initial F -algebra.
Our interest is solely in the algebraic, calculational style of various subproofs, not in the
outline of the main proof. For completeness we will brieﬂy deﬁne the notion of algebra;
without any explanation. So you may postpone reading this application until you know
what algebras are good for. The construction will require that the category has an initial
object and a colimit for each ω -chain, and that functor F preserves colimits of ω -chains;
brieﬂy: the category is an ω -category and F is ω -cocontinuous.
Here is the deﬁnition of the notion of algebra and the category of F -algebras. Let C be a
category, the default one. Let F: C →C be a functor. The category Alg(F) , built upon

2E. COLIMITS
53
C , is deﬁned as follows. An object in Alg(F) is: a morphism ϕ in C of type FA →A ,
for some A . Let ϕ and ψ be objects in Alg(F) ; then a morphism from ϕ to ψ in
Alg(F) is: a morphism f in C satisfying ϕ ; f = Ff ; ψ . (Actually, thus deﬁned Alg(F)
is a pre-category rather than a category.)
The objects and morphisms in Alg(F) are
called F -algebras and F -homomorphisms, respectively. Using the laws for initiality,
instantiated to Alg(F) , one can easily show that if α: FA →A is initial in Alg(F) , then
α is an isomorphism, α: FA ∼= A .
Let C be a category, the default one.
Given endofunctor F we wish to construct an
F -algebra, α: FA →A say, that is initial in Alg(F) . Forgoing initiality for the time
being, we derive a construction of an α: FA →A as follows. (Read the steps and their
explanation below in parallel!)




DD
• A
A
A
A
A
A
A
A
A
AAU









γ




FDD,
= DSD
•
FA
• A
?
         	
@
@
@
@
@
@
@
@@
R ?
-
Fγ
γS
α
α: FA →A
⇐
deﬁnition isomorphism
(a)
α: FA ∼= A
⇐
deﬁnition cocone morphism (taking A = tgtγ = tgtγS )
(b)
α: Fγ ∼= γS in W(FD)
∧
FD = DS
≡
Fγ is colimit for FD (taking α = Fγ\γS )
(c)
γS is colimit for DS
∧
FD = DS.
Step (a): this is motivated by the wish that α be initial in Alg(F) , and so α will be an
isomorphism; in other words, in view of the required initiality the step is no strengthening.
Step (b): here we merely decide that α, A come from a (co)limit construction; this is
true for many categorical constructions. So we aim at α: Fγ ∼= ... , where γ is a colimit
(which we assume to exist) for a diagram D yet to be deﬁned. Since Fγ is a FD -cocone,
there has to be another FD -cocone on the dots. To keep things simple, we aim at an
FD -cocone constructed from γ , say γS , where S is an endofunctor on srcD . Since
γS is evidently a DS -cocone, and must be an FD -cocone, it follows that FD = DS is
another requirement.
Step (c): the hint ‘ Fγ is colimit for FD ’ follows from the assumption that F preserves
colimits, and the deﬁnition α = Fγ\γS is forced by (the proof of) the uniqueness of
initial objects. (It is indeed very easy to verify that Fγ\γS and γS\Fγ are each other’s
inverse.)
We shall now complete the construction in the following three parts.

54
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
1. Construction of D, S such that FD = DS .
2. Proof of ‘ γS is colimit for DS ’ where γ is a colimit for D .
3. Proof of ‘ α is initial in Alg(F) ’ where α = Fγ\γS .
Part 1.
(Construction of D, S such that FD = DS .) The requirement FD = DS says
that FD is a ‘subdiagram’ of D . This is easily achieved by making D a chain of iterated
F applications, as follows.
Let ω be the category with objects 0, 1, 2, . . . and a unique arrow from i to j (denoted
i≤j ) for every i ≤j . So ω is the shape of a chain. The zero and successor functors
0, S: ω →ω are deﬁned by 0(i≤j) = 0≤0 and S(i≤j) = (i+1)≤(j+1) .
Assume that C has an initial object, 0 say.
Deﬁne the diagram D: ω →C by
D(i≤j) = F i([F j−i0]) , where ([ ]) abbreviates ([0 →])C . It is quite easy to show that D is
a functor, that is, D(i≤j ; j≤k) = D(i≤j) ; D(j≤k) . It is also immediate that FD = DS ,
since for arbitrary morphism i≤j :
FD(i≤j)
=
FF i([F j−i0])
=
F i+1([F (j+1)−(i+1)0])
=
D((i+1)≤(j+1))
=
DS(i≤j).
Thanks to the form of ω , natural transformations of the form ε: D .→G (arbitrary
G ) can be deﬁned by induction, that is, by deﬁning
ε0
:
D0 .→G0
or, equivalently,
ε0: D0 →G0
εS
:
DS .→GS .
We shall use this form of deﬁnition in Part 2 and Part 3 below.
Assume that C has a colimit γ for diagram D .
Part 2.
(Proof of ‘ γS is colimit for DS ’ where γ is a colimit for D .) Our task is to
construct for arbitrary DS -cocone δ a morphism ([γS →δ])W
(DS) such that
γS ; x = δ
≡
x = ([γS →δ])W
(DS) .
(♠)
Our guess is that γ\ε may be chosen for ([γS →δ])W
(DS) for some suitably chosen ε:
D .→tgtδ that depends on δ . This guess is suﬃcient to start the proof of (♠) ; we shall
derive a deﬁnition of ε (more speciﬁcally, for ε0 and εS ) along the way.
x = γ\ε
≡
\-Charn

2E. COLIMITS
55
γ ; x = ε
≡
observation at the end of Part 1
(γ ; x)0 = ε0
∧
(γ ; x)S = εS
≡
composition of a cocone with a morphism, extensionality
γ0 ; x = ε0
∧
γS ; x = εS
≡
{ aiming at the left hand side of (♠) }
deﬁne εS = δ (noting that δ: DS .→tgtδ = DS .→tgtδ S )
γ0 ; x = ε0
∧
γS ; x = δ
≡
deﬁne ε0 below such that γS ; x = δ ⇒γ0 ; x = ε0 for all x
(∗)
γS ; x = δ.
In order to deﬁne ε0 satisfying the requirement derived at step (∗) , we calculate
γ0 ; x
=
{ anticipating next steps, introduce an identity }
(recall that tgtγ has been called A , so that γ: D .→A )
γ0 ; A(0≤1) ; x
=
naturality γ (‘commutativity of the triangle’)
D(0≤1) ; γ1 ; x
=
assumption γS ; x = δ
D(0≤1) ; δ0
so that the requirement at step (∗) is fulﬁlled by deﬁning ε0 = D(0≤1) ; δ0 .
Part 3.
(Proof of ‘ α is initial in Alg(F) ’ where α = Fγ\γS .) Put again A = tgtα =
tgtγ , so that γ: D .→A and α: FA →A . Let ϕ: FB →B be arbitrary. We have to
construct a morphism in C from A to B , denoted ([α →ϕ])F , such that
Fγ\γS ; x = Fx ; ϕ
≡
x = ([α →ϕ])F .
(♣)
Our guess is that the required morphism ([α →ϕ])F can be written as γ\δ for some suitably
chosen D -cocone δ . This guess is suﬃcient to start the proof of (♣) , deriving a deﬁnition
for δ (more speciﬁcally, for δ0 and δS ) along the way:
Fγ\γS ; x = Fx ; ϕ
≡
\ -Fusion
Fγ\(γS ; x) = Fx ; ϕ
≡
\ -Charn[ γ, δ, x := Fγ, γS ; x, Fx ; ϕ ]
Fγ ; Fx ; ϕ = γS ; x
≡
lhs: functor, rhs: composition of cocone with a morphism

56
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES
F(γ ; x) ; ϕ = (γ ; x)S
≡
explained and proved below (deﬁning δ )
(∗)
γ ; x = δ
≡
\ -Charn
x = γ\δ.
Arriving at the line above (∗) I see no way to make progress except to work bottom-up
from the last line. Having the lines above and below (∗) available, we deﬁne δSn in terms
of δn by
δS
=
Fδ ; ϕ ,
a deﬁnition that is also suggested by type considerations alone. Now part ⇐of equivalence
(∗) is immediate:
F(γ ; x) ; ϕ = (γ ; x)S
⇐
deﬁnition δS : Fδ ; ϕ = δS
γ ; x = δ.
For part ⇒of equivalence (∗) we argue as follows, assuming the line above (∗) as a
premise, and deﬁning δ0 along the way.
γ ; x = δ
≡
induction principle
(γ ; x)0 = δ0
∧
∀(n ::
(γ ; x)n = δn ⇒(γ ; x)Sn = δSn)
≡
proved below: the ‘base’ in (i), and the ‘induction step’ in (ii)
true.
For (i), the induction base, we calculate:
γ0 ; x
=
init-Charn, using γ0: 0 →A
([A])C ; x
=
init-Fusion, using x: A →B
([B])C
=
deﬁne δ0 = ([B])C
true.
And for (ii), the induction step, we calculate for arbitrary n , using the induction hypothesis
(γ ; x)n = δn ,
(γ ; x)Sn
=
line above (∗)

2E. COLIMITS
57
(F(γ ; x) ; ϕ)n
=
hypothesis (γ ; x)n = δn
(Fδ ; ϕ)n
=
deﬁnition δS
(δS)n
as desired. This completes the entire construction and proof.

58
CHAPTER 2. CONSTRUCTIONS IN CATEGORIES

Appendix A
More on adjointness
We give several equivalent deﬁnitions of adjointness, and some corollaries and theorems.
[Note — added in proof: you’d better read the paper “Adjunctions” written by Fokkinga
and Meertens, Draft version printed in December 1992.]
A.1 Global constants.
Let A and B be categories, and let F: A →B and G: B →A
be functors, ﬁxed throughout the sequel.
A.2
Default typing.
Unless stated otherwise, variables A′, A, f, ϕ (all in A ) and
B, B′, g, ψ (all in B ) are arbitrary, and have the typing indicated below.
A′, A
∈
Objects of A
f
:
A′ →A A
ϕ
:
A →A GB
B, B′
∈
Objects of B
g
:
B →B B′
ψ
:
FA →B B
In addition, entities η, ⌊⌊⌋⌋(“to A ”) and ε, ⌈⌈⌉⌉(“to B ”) depend on F, G and have the
following typing.
ηA
:
A →A GFA
ψ: FA →B B
⌊⌊ψ⌋⌋A,B: A →A GB
εB
:
FGB →B B
ϕ: A →A GB
⌈⌈ϕ⌉⌉A,B: FA →B B
Mappings ⌊⌊⌋⌋and ⌈⌈⌉⌉are called lad and rad, respectively, from left adjungate and right
adjungate. As a memory aid: the ﬁrst symbol of ⌊⌊⌋⌋has the shape of an ‘L’ and therefore
denotes lad. In typewriter font I would write lad( ) and rad( ). For readability I will
omit the typing information whenever appropriate, as well as most subscripts. Omitting
the subscripts is dangerous (and even erroneous) if categories A and B are built upon
another one. For example, when B itself is a morphism in an underlying category, then
εB might be a morphism that depends on (and is expressed in) B .
Nevertheless, in
the following calculations the subscripts are derivable from the context (in a mechanical
way, like type inference in modern functional languages), thus justifying the omission; see
paragraph 1.39.
59

60
APPENDIX A. MORE ON ADJOINTNESS
A.3 Remark.
The following theorem asserts the equivalence of several statements. Each
of them deﬁnes “ F is left adjoint to G ”.
So, in order to prove that F is left adjoint to G it suﬃces to establish just one of
the statements, and when you know that F is left adjoint to G you may use all of the
statements. Before we present the proof of the theorem, we also give some corollaries:
additional properties of an adjunction.
A.4
Theorem.
Statements Adjunction, Units, LadAdj, RadAdj, Fusions, and Charns
are equivalent. Moreover, the various ⌊⌊⌋⌋that are asserted to exist, can all be chosen
equal; the same holds for ⌈⌈⌉⌉, η, and ε .
Adjunction. There exist η
and ε
typed as in paragraph A.2 and satisfying
ϕ = η ; Gψ
≡
Fϕ ; ε = ψ
A.5
Adjunction
Units. There exist η
and ε
typed as in paragraph A.2 and satisfying
η: I .→A GF
A.6
unit-Ntrf
ε: FG .→B I
A.7
co-unit-Ntrf
η ; Gε = id
A.8
unit-Inv
Fη ; ε = id
A.9
Inv-co-unit
LadAdj. There exist ⌊⌊⌋⌋,
and ε
typed as in paragraph A.2 and satisfying
ε: FG .→I
A.10
co-unit-Ntrf
Fϕ ; ε = ψ
≡
ϕ = ⌊⌊ψ⌋⌋
A.11
lad-Charn
RadAdj. There exist ⌈⌈⌉⌉,
and η
typed as in paragraph A.2 and satisfying
η: I .→GF
A.12
unit-Ntrf
ϕ = η ; Gψ
≡
⌈⌈ϕ⌉⌉= ψ
A.13
rad-Charn
Fusions. There exist ⌊⌊⌋⌋,
and ⌈⌈⌉⌉,
typed as in paragraph A.2 and satisfying
⌊⌊Ff ; ψ ; g⌋⌋
=
f ; ⌊⌊ψ⌋⌋; Gg
A.14
lad-Fusion
⌈⌈f ; ϕ ; Gg⌉⌉
=
Ff ; ⌈⌈ϕ⌉⌉; g
A.15
rad-Fusion
ϕ = ⌊⌊ψ⌋⌋
=
⌈⌈ϕ⌉⌉= ψ
A.16
Inverse
Charns. There exist ⌊⌊⌋⌋,
and ⌈⌈⌉⌉, , and η , ε
typed as in A.2 and satisfying
Fϕ ; ε = ψ
≡
ϕ = ⌊⌊ψ⌋⌋
A.17
lad-Charn
ϕ = η ; Gψ
≡
⌈⌈ϕ⌉⌉= ψ
A.18
rad-Charn
ϕ = ⌊⌊ψ⌋⌋
=
⌈⌈ϕ⌉⌉= ψ
A.19
Inverse

61
A.20 Corollary.
Let F be left adjoint to G via η , ε , ⌊⌊⌋⌋, , ⌈⌈⌉⌉, . Then:
η = ⌊⌊id⌋⌋
A.21
unit-Def
⌊⌊ψ⌋⌋= η ; Gψ
A.22
lad-Def
F⌊⌊ψ⌋⌋; ε = ψ
A.23
lad-Self
Fϕ ; ε = Fϕ′
; ε
⇒
ϕ = ϕ′
A.24
lad-Uniq
ε = ⌈⌈id⌉⌉
A.25
co-unit-Def
⌈⌈ϕ⌉⌉= Fϕ ; ε
A.26
rad-Def
η ; G⌈⌈ϕ⌉⌉= ϕ
A.27
rad-Self
η ; Gψ = η ; Gψ′
⇒
ψ = ψ′
A.28
rad-Uniq
A.29
Discussion.
A quick glance at the formulas of the Theorem and the Corollary
reveals that the same subexpressions turn up over and over again. In particular, a deﬁnition
for ⌊⌊⌋⌋and ⌈⌈⌉⌉(see lad- and rad-Def) can be read oﬀdirectly from Adjunction; it is then
also immediate that ⌊⌊⌋⌋and ⌈⌈⌉⌉are each other’s inverse, as expressed by law Inverse.
Also, the pattern of the left-hand side of unit-Inv is clearly recognizable in Adjunction.
The left-hand sides of laws lad- and rad-Charn are the same as the two sides of Adjunction.
(It seems to me that law Adjunction is in general the easiest to work with when deriving
consequences of an adjunction.)
Another reading of Adjunction is this: there is precisely one solution for ψ in the
left-hand side equation, namely the ψ given by the right-hand side equation; and, also,
there is precisely one solution for ϕ in the right-hand side equation, namely the one given
by the left-hand side equation. The uniqueness of the solutions is also expressed by laws
lad- and rad-Charn separately, and the solutions themselves are given by ⌊⌊⌋⌋and ⌈⌈⌉⌉.
(See also paragraph 2.7 that explains the trick of expressing uniqueness of solutions in a
way that is suitable for calculation.)
Law unit-Inv asserts that η has a post-inverse, law Inv-co-unit asserts that ε has a
pre-inverse, and lad-Uniq asserts a kind of monic-ness for ε , and rad-Uniq asserts a kind
of epic-ness for η . Law lad-Self shows that the eﬀect of ⌊⌊⌋⌋can be undone; indeed, the
deﬁnition of ⌈⌈⌉⌉follows the pattern of the left-hand side of lad-Self. The name ‘Self’
derives from the observation that ⌊⌊ψ⌋⌋itself is a solution for ϕ in the ever recurring
equation Fϕ ; ε = ψ . That nomenclature is consistent with the nomenclature that we’ve
proposed for the laws of initiality.
The names of the laws and the symbols ⌊⌊⌋⌋and ⌈⌈⌉⌉are not standard in category
theory.
A.31 Lemma.
[Inverse]
⇒
([lad-Fusion] ≡[rad-Fusion]) .

62
APPENDIX A. MORE ON ADJOINTNESS
So, to prove Fusions it suﬃces to establish Inverse and either lad-Fusion or rad-Fusion.
The proof of the lemma is simple:
⌊⌊Ff ; ψ ; g⌋⌋= f ; ⌊⌊ψ⌋⌋; Gg
≡
Inverse
Ff ; ψ ; g = ⌈⌈f ; ⌊⌊ψ⌋⌋; Gg⌉⌉
≡
for ‘ ⇒’ substitute ψ := ⌈⌈ϕ⌉⌉(hence by Inverse ⌊⌊ψ⌋⌋= ϕ ), and
for ‘ ⇐’ substitute ϕ := ⌊⌊ψ⌋⌋(hence by Inverse ⌈⌈ϕ⌉⌉= ψ )
Ff ; ⌈⌈ϕ⌉⌉; g = ⌈⌈f ; ϕ ; Gg⌉⌉.
A.31 Proof of Theorem A.4.
We prove the theorem by circular implication:
... Adjunction ⇒Units ⇒LadAdj ⇒Fusions ⇒RadAdj ⇒Charn ⇒...
We urge the readers to try and prove some of the im-
plications themselves, before reading all of the proofs
below.
It is an excellent exercise to become familiar
with the calculational properties of an adjunction.
A.32
Proof of
Adjunction ⇒Units.
We establish co-unit-Ntrf; and unit-Inv along
the way at line (∗) .
ε: FG .→B I
≡
deﬁnition
.→:
For all g: B →B B′
FGg ; εB′ = εB ; g
≡
Adjunction[ ϕ, ψ := Gg, (ε ; g) ] (from right to left)
Gg = η ; G(ε ; g)
≡
functor
Gg = η ; Gε ; Gg
⇐
Leibniz
id = η ; Gε
(∗)
(unit-Inv)
≡
Adjunction[ ϕ, ψ := id, ε ] (from left to right)
Fid ; ε = ε
≡
functor, identity
true.
Similarly for unit-Ntrf and Inv-co-unit.

63
A.33 Proof of Units ⇒LadAdj.
We establish the equivalence LadCharn by circular
‘follows from’, deﬁning ⌊⌊⌋⌋along the way:
Fϕ ; ε = ψ
≡
Inv-co-unit
Fϕ ; ε = Fη ; ε ; ψ
≡
co-unit-Ntrf
Fϕ ; ε = Fη ; FGψ ; ε
⇐
functor, Leibniz
ϕ = η ; Gψ
= ⌊⌊ψ⌋⌋by deﬁning ⌊⌊ψ⌋⌋= η ; Gψ
(right hand side)
≡
unit-Inv
ϕ ; η ; Gε = η ; Gψ
≡
unit-Ntrf
η ; GFϕ ; Gε = η ; Gψ
⇐
functor, Leibniz
Fϕ ; ε = ψ.
Actually, the above calculation also shows Units ⇒Adjunction.
A.34 Proof of LadAdj ⇒Fusions.
We establish lad-Fusion as follows:
⌊⌊Ff ; ψ ; g⌋⌋= f ; ⌊⌊ψ⌋⌋; Gg
≡
lad-Charn [ϕ, ψ := rhs, lhs]
Ff ; ψ ; g = F(f ; ⌊⌊ψ⌋⌋; Gg) ; ε
≡
functor, co-unit-Ntrf
Ff ; ψ ; g = Ff ; F⌊⌊ψ⌋⌋; ε ; g
⇐
Leibniz
ψ = F⌊⌊ψ⌋⌋; ε
≡
lad-Charn[ ϕ := ⌊⌊ψ⌋⌋]
⌊⌊ψ⌋⌋= ⌊⌊ψ⌋⌋
≡
equality
true.
We establish Inverse, deﬁning ⌈⌈⌉⌉along the way:
ϕ = ⌊⌊ψ⌋⌋
≡
lad-Charn
Fψ ; ε = ψ
≡
deﬁne ⌈⌈ψ⌉⌉= Fψ ; ε

64
APPENDIX A. MORE ON ADJOINTNESS
⌈⌈ϕ⌉⌉= ψ.
Now rad-Fusion follows by Lemma A.30.
A.35 Proof of Fusions ⇒RadAdj.
We establish rad-Charn, starting with the right-
hand side, since that doesn’t contain the unknown η , and deﬁning η along the way:
ψ = ⌈⌈ϕ⌉⌉
≡
Inverse
⌊⌊ψ⌋⌋= ϕ
≡
lad-Fusion
⌊⌊id⌋⌋; Gψ = ϕ
≡
deﬁne η = ⌊⌊id⌋⌋
η ; Gψ = ϕ.
Now we establish unit-Ntrf:
η: I .→GF
≡
deﬁnition naturality
For all f :
f ; η = η ; GFf
≡
deﬁnition η (derived above)
f ; ⌊⌊id⌋⌋= ⌊⌊id⌋⌋; GFf
≡
lad-Fusion at both sides
⌊⌊Ff ; id⌋⌋= ⌊⌊id ; Ff⌋⌋
≡
identity, equality
true.
A.36 Proof of RadAdj ⇒Charns.
First we establish Inverse, deﬁning ⌊⌊⌋⌋along the
way:
⌈⌈ϕ⌉⌉= ψ
≡
rad-Charn
ϕ = η ; Gψ
≡
deﬁne ⌊⌊ψ⌋⌋= η ; Gψ
ϕ = ⌊⌊ψ⌋⌋.
Next we establish lad-Charn, deﬁning ε along the way:
ϕ = ⌊⌊ψ⌋⌋
≡
Inverse (just derived)

65
⌈⌈ϕ⌉⌉= ψ
≡
rad-Fusion (see below)
(∗)
Fϕ ; ⌈⌈id⌉⌉= ψ
≡
deﬁne ε = ⌈⌈id⌉⌉
Fϕ ; ε = ψ.
In step (∗) we have used rad-Fusion. This law follows from RadAdj in the same way as
lad-Fusion follows from LadAdj, see paragraph A.34.
A.37 Proof of Charns ⇒Adjunction.
ϕ = η ; Gψ
≡
rad-Charn
ψ = ⌈⌈ϕ⌉⌉
≡
Inverse
⌊⌊ψ⌋⌋= ϕ
≡
lad-Charn
Fϕ ; ε = ψ.
This completes the proof of Theorem A.4.
A.38 Proof of Corollary A.20.
For unit-Def we argue:
η = ⌊⌊id⌋⌋
≡
lad-Charn
Fη ; ε = id
≡
Inv-co-unit
true.
For rad-Def, and rad-Self at line (∗) , we argue:
⌈⌈ϕ⌉⌉= Fϕ ; ε
≡
Adjunction[ ψ := ⌈⌈ϕ⌉⌉]
ϕ = η ; G⌈⌈ϕ⌉⌉
(∗)
(rad-Self)
≡
rad-Charn[ ψ := ⌈⌈ϕ⌉⌉]
⌈⌈ϕ⌉⌉= ⌈⌈ϕ⌉⌉
≡
equality
true.
For rad-Uniq we argue
ϕ = ϕ′
⇐
logic

66
APPENDIX A. MORE ON ADJOINTNESS
ϕ = ⌈⌈ψ⌉⌉= ϕ′
for some ψ
≡
rad-Charn
Fϕ ; ε = ψ = Fϕ′ ; ε
for some ψ
≡
logic
Fϕ ; ε = Fϕ′ ; ε.
The other parts are proved similarly.
A.39
Exercise.
For each X , Y ∈{ Adjunction, LadAdj, RadAdj, Fusions, Charn,
Units } , see whether you can prove X ≡Y or X ⇒Y directly, without relying on
Theorem A.4. There are a lot of possibilities!!
A.40 Exercise.
Give alternative proofs for each of the corollaries. For example, law unit-
Def may also be proved directly from Charn by reducing the obligation η = ⌊⌊id⌋⌋to true
by applying ‘functor and identity’ (introducing Gid after η ), rad-Charn[ ϕ, ψ := ⌊⌊id⌋⌋, id ],
and Inverse, in that order. Another possibility is to apply lad-Charn, Adjunction, ‘functor
and identity’. Yet another possibility is to reduce the obligation η = ⌊⌊id⌋⌋to true by
applying Inverse, Charn, ‘functor and identity’.
A.41 Exercise.
Barr and Wells [2] present RadAdj as a deﬁnition of “ F is adjoint to
G ”, and they prove LadAdj as a proposition. Compare our calculational proof of LadAdj
⇒RadAdj with the two-and-a-half page proof of Barr and Wells (Proposition 12.2.2,
containing eight diagrams).
A.42 Exercise.
Derive the typing (and the subscripts to ⌊⌊⌋⌋, ⌈⌈⌉⌉, η, and ε ) for each
of the laws, following the procedure of paragraph 1.39.
A.43
Exercise.
Let F be left-adjoint to G via η, ε and also via η, ε′ . Prove that
ε = ε′ .
A.44 Exercise.
Find F and G such that F is left-adjoint to G via η, ε as well as via
η′, ε′ with (η, ε) ̸= (η′, ε′) . (Hint: take F = G = I , and A = B = a category with one
object and two morphisms.) So an adjointness does not determine the unit and co-unit
uniquely.
A.45 Exercise.
Suppose that F and F ′ are both left-adjoint to G . Prove that F ∼= F ′
(in category Ftr(A, B) ). (Hint: ﬁrst establish the existence of natural transformations
κ: F .→F ′ and, by symmetry, κ′: F ′ .→F ; then show that κ ; κ′ = id and, by symmetry,
κ′ ; κ = id .) Conclude that κ and κ′ are, in general, not uniquely determined by F, F ′, G .
(Hint: see Exercise A.44.)

67
Yet another formulation
Here is another, important, elegant and compact, formulation of “ F is adjoint to G ”. We
ﬁrst need some notation.
A.46 Hom-functor, notation.
For arbitrary category C we deﬁne the two-place map-
ping ( →) by:
(C →C′)
=
{h in C |
h: C →C C′}
an object in Set
(h →h′)
=
λχ.
h ; χ ; h′
a morphism in Set typed
(tgt h →src h′) →Set (src h →tgt h′)
It follows that ( →) is a functor (contravariant in its ﬁrst parameter, since src h and
tgt h change place in the source and target type of (h →h′) ):
( →)
:
Cop × C →Set .
This functor is called the hom-functor, and is usually written Hom( , ) . Our notation is
motivated by, amongst others, the observation that h: C →C′ equivales h ∈(C →C′) .
For bifunctor
⊕
and functors F, G , we write F ⊕G for the functor x 7→Fx ⊕Gx .
Further, let
X
=
Exl Aop,B
:
Aop × B →Aop
Y
=
Exr Aop,B
:
Aop × B →B
denote the obvious extraction functors.
With all this notation (F X →Y ) and (X →G Y ) are functors of type Aop×B →Set
that satisfy the following equations:
(F X →Y )(A, B)
=
(F A →B)
=
{g in B|
g: FA →B B}
(F X →Y )(f, g)
=
(F f →g)
=
λψ.
Ff ; ψ ; g
and
(X →G Y )(A, B)
=
(A →G B)
=
{f in A|
f: A →A G B}
(X →G Y )(f, g)
=
(f →G g)
=
λϕ.
f ; ϕ ; Gg .
Exercise: check the claims of the last sentence (‘are functors’, ‘of type’, ‘satisfy the equa-
tions’).
A.47 Theorem.
The statement “ F is left adjoint to G ” is equivalent to IsoAdj.
IsoAdj.
(F X →Y )
∼=
(X →G Y )
A.48
Iso

68
APPENDIX A. MORE ON ADJOINTNESS
A.49 Proof of IsoAdj ≡Fusions.
The isomorphism in Iso is apparently in the category
where functors are the objects and natural transformations are the morphisms. So Iso
abbreviates the following:
there exist natural transformations
⌊⌊⌋⌋,
:
(F X →Y )
.→
(X →G Y )
A.50
lad-Ntrf
⌈⌈⌉⌉,
:
(X →G Y )
.→
(F X →Y )
A.51
rad-Ntrf
that are each other’s inverse.
A.52
Inverse
Now, law lad-Fusion is nothing but a detailed formulation of lad-Ntrf:
⌊⌊⌋⌋: (F X →Y ) .→(X →G Y )
≡
deﬁnition naturality
For all (f, g): (A, B) →(A′, B′) in Aop × B :
(F X →Y )(f, g) ; ⌊⌊⌋⌋A′,B′ = ⌊⌊⌋⌋A,B ; (X →G Y )
≡
property (F X →Y )(f, g) = (Ff →g) and similarly for G
(Ff →g) ; ⌊⌊⌋⌋A′,B′ = ⌊⌊⌋⌋A,B ; (f →Gg)
≡
extensionality (in Set )
For all ψ ∈(FA →B) :
((Ff →g) ; ⌊⌊⌋⌋A′,B′)ψ = (⌊⌊⌋⌋A,B ; (f →Gg))ψ
≡
composition applied: (F ; G)x = G(Fx)
⌊⌊⌋⌋A′,B′ ((Ff →g)ψ) = (f →Gg) (⌊⌊⌋⌋A,Bψ)
≡
deﬁnition hom-functor ( →) , writing ⌊⌊⌋⌋, xyz as ⌊⌊xyz⌋⌋,
⌊⌊Ff ; ψ ; g⌋⌋A′,B′ = f ; ⌊⌊ψ⌋⌋A,B ; Gg.
Similarly for rad.
Initiality and colimit as adjointness
In this subsection we assume that you are familiar with the characterisation of initiality
and colimits by laws init- and \ -Charn; see Section 2b and 2e.
A.53 Left-adjoints preserve initiality.
Let A, B be arbitrary categories, and suppose
that A has an initial object 0 and that A, B, F, G, η, ε is an adjunction. We claim that F0
is initial in B . To prove this, we establish the equivalence init-Charn [f, A, B := g, F0, B]
by circular implication, constructing ([ ])B along the way:
g: F0 →B B
⇒
typing rules (composition, functor), η: I .→GF

69
η0 ; Gg: 0 →A GB
≡
init-Charn [f, A, B := (η0 ; Gg), 0, GB] in A
([GB])A = η0 ; Gg
≡
Adjunction [ϕ, ψ := ([GB])A, g]
F([GB])A ; εB = g
= ([B])B
by deﬁning ([B])B = F([GB])A ; εB
⇒
typing rules, ε: FG .→I , and ([GB])A: 0 →A GB
g: F0 →B.
Exercise: is the ﬁrst step also valid with ≡instead of ⇒, thus shortening the proof?
Exercise: give an alternative proof, using ⌊⌊⌋⌋and ⌈⌈⌉⌉and Inverse. Is there an essential
diﬀerence between your proof and the one above?
Exercise: instantiate this proof to the case where G = 0 , the constant functor mapping
each B to 0 and each g to id 0 . What is, in this case, ([ ])B ?
Exercise: formulate the theorem as concise as possible for the special case that A is taken
to be 1 , the category with one object and one morphism.
A.54
Initiality determines an adjunction.
Let B be a category with an initial
object 0 . Then, for each category A with a ﬁnal object 1 (for example, A = 1 ), there
is an adjunction between A and B .
Proof.
Let F and G be the constant functors F = 0: A →B and G = 1: B →A . We
claim that F is left-adjoint to G . To prove this, we establish Adjunction, constructing η
and ε along the way. For arbitrary A, B and f: A →A GB and g: FA →B B ,
f = ηA ; Gg
≡
Ff ; εB = g
≡
deﬁnition F and G , identity
f = ηA
≡
εB = g
≡
anticipating the next two steps, deﬁne ηA = ⌈⌊(A)⌉⌋A and εB = ([B])B
f = ⌈⌊(A)⌉⌋
≡
([B]) = g
≡
ﬁnal-Charn and init-Charn
f: A →1
≡
g: 0 →B
≡
typing f, g , and deﬁnition F, G
true
≡
true.
Actually, we have shown both sides of the equivalence to be true, rather than to be the
same truth value. It still remains to prove that η and ε are natural; this is left as an
exercise.
Exercise: show that B has an initial object if, and only if, there exists an adjunction
between 1 (the category with one object and one morphism) and B .
A.55
Left-adjoints preserve colimits.
Let A and B be arbitrary categories. Let
F: A →B be left-adjoint to G: B →A , and let D: D →A be a functor (a diagram in

70
APPENDIX A. MORE ON ADJOINTNESS
A ). Suppose that γ is a colimit in A for D . Then Fγ is a colimit in B for FD .
Proof.
First observe that functors preserve cocones: if δ is a cocone for D: D →A ,
then Fδ is a cocone for FD: D →B . We claim that Fγ is a colimit for FD . To prove
this, we establish colimit-Charn, constructing Fγ\
along the way. For arbitrary cocone
δ in B for FD ,
Fγ ; x = δ
≡
composition of cocone with a morphism, extensionality
FγA ; x = δA
for each A in D
≡
Inverse, noting that both sides have type FDA →B tgt δ
⌊⌊FγA ; x⌋⌋= ⌊⌊δA⌋⌋
for each A in D
≡
lad-Fusion
γA ; ⌊⌊x⌋⌋= ⌊⌊δA⌋⌋
for each A in D
≡
for ⇒: deﬁne δ′ by δ′
A = ⌊⌊δA⌋⌋for each A in D
(∗)
for ⇐: note that by (⋆) we have δ′
A = ⌊⌊δA⌋⌋for each A in D
γ ; ⌊⌊x⌋⌋= δ′
≡
γ is colimit for D , colimit-Charn
⌊⌊x⌋⌋= γ\δ′
≡
Inverse
x = ⌈⌈γ\δ′⌉⌉
≡
deﬁne Fγ\δ = ⌈⌈γ\δ′⌉⌉where δ′
A = ⌊⌊δA⌋⌋; observation below
(⋆)
x = Fγ\δ.
The deﬁnition of Fγ\
in step (⋆) requires some care. First, even though in general γ
is not recoverable from Fγ , here γ is known from the data of the theorem. Second, the
notation ...γ\δ′... requires that δ′ is a cocone for D , that is, δ′: D .→X for some object
X in A . It is almost trivial that δ′ is a transformation from D to some X ; indeed, for
arbitrary A in D :
δ′
A: DA →A X
⇐
deﬁnition δ′
A = ⌊⌊δA⌋⌋, typing ⌊⌊⌋⌋
δA: FDA →B tgt δ and X = G tgt δ
⇐
assumption δ: FD .→I , deﬁne X = G tgt δ
true.
The veriﬁcation of the naturality of δ′ is less trivial:
δ′: D .→G tgt δ
≡
deﬁnition
.→;
For arbitrary f: A →D A′ :

71
Df ; δ′
A′ = δ′
A ; id
≡
deﬁnition δ′ , identity
Df ; ⌊⌊δA′⌋⌋= ⌊⌊δA⌋⌋
≡
lad-Fusion
⌊⌊FDf ; δA′⌋⌋= ⌊⌊δA⌋⌋
⇐
Leibniz, δ: FD .→tgt δ
true.
Exercise: an alternative, much more abstract, proof might be obtained by considering
colimits for D as initial objects in WD , and lifting functors to the cocone categories.
Exercise: check the proof for the case of the empty diagram.
Exercise: specialise this proof to sums, being particular colimits, and compare it with the
proof by Barr and Wells [2] (Proposition 12.3.6, nine lines long).

72
APPENDIX A. MORE ON ADJOINTNESS

Bibliography
[1] A. Asperti and G. Longo. categories, Types, and Structures. Foundations of Computing
Series. The MIT Press, Cambridge, Ma, 1991.
[2] M. Barr and C. Wells. Category Theory for Computing Science. Prentice Hall, 1990.
[3] R.S. Bird. Lecture notes on constructive functional programming. In M. Broy, editor,
Constructive Methods in Computing Science. International Summer School directed by
F.L. Bauer [et al.], Springer Verlag, 1989. NATO Advanced Science Institute Series
(Series F: Computer and System Sciences Vol. 55).
[4] M.M. Fokkinga. Law and Order in Algorithmics. PhD thesis, University of Twente,
dept Comp Sc, Enschede, The Netherlands, 1992.
[5] M.M. Fokkinga and E. Meijer. Program calculation properties of continuous algebras.
Technical Report CS-R9104, CWI, Amsterdam, January 1991.
[6] C.A.R. Hoare. Notes on an Approach to Category Theory for Computer Scientists. In
M. Broy, editor, Constructive Methods in Computing Science, pages 245–305. Interna-
tional Summer School directed by F.L. Bauer [et al.], Springer Verlag, 1989. NATO
Advanced Science Institute Series (Series F: Computer and System Sciences Vol. 55).
[7] D.S. Scott. Relating theories of the lambda calculus. In J.P. Seldin and J.R. Hindley,
editors, To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formal-
ism, page 406. Academic Press, 1980.
73

74
BIBLIOGRAPHY

Introduction to
“Law and Order in Algorithmics”, Ph.D. Thesis by M. Fokkinga,
Chapter 3: Algebras categorically, and
Chapter 5: Datatypes without Signatures
There is a slight discrepancy between the notational conventions in the preceding chapters
and my thesis [4]. In the thesis following conventions prevail.
• The default notation for objects is a, b, c, . . . instead of A, B, C, . . . , and the default
notation for ‘the’ initial and ﬁnal object is
0 and 1 , respectively. Variables x, y, z
range over various entities, mostly morphisms but also objects. Variables ϕ, ψ, χ
range over morphisms whose type has the form Fa →Ga , for some object a (and
given functors F, G ).
Moreover:
• If † is a bifunctor (like × and + ) and F, G are functors, then F † G denotes the
functor deﬁned by
(F † G)x
=
Fx † Gx
for all objects and morphisms x .
In particular, II = I × I ; it maps each x onto x × x . (Similarly, if the need arises,
I would deﬁne 2 = I + I , so that 2 x = x + x for each object and morphism x .)
• For product categories the extraction functors are denoted Exl , Exr while the symbol
∆also denotes the tupling (pairing) of functors.
• Juxtaposition associates to the right, so that UµFa = U(µ(Fa)) , and binds stronger
than any binary operation symbol, so that Fa † = (Fa)† . Binary operation sym-
bol
; binds the weakest of all operation symbols in a term denoting a morphism.
As usual, × has priority over + .
• For each object a , we use a to denote the constant functor:
a b
=
a
for each object b
a f
=
id a
for each morphism f .
75

76
So, 1 + a × I is a functor, mapping each object b onto 1 + a × b and mapping each
morphism f onto id 1 + id a × f .
The same notation is also used for the constant function: x maps each argument
onto x .
In the examples of Chapter 3 there occur references to paragraph 1.12, which introduces
several datatypes informally. Here is a copy of that paragraph:
“Paragraph 1.12: Naturals, lists, streams”.
We shall frequently use naturals, cons
lists, cons′ lists, and streams in examples, assuming that you know these concepts. Here
is some informal explanation; the default category is Set .
A distinguished one-element set is denoted
1 .
Function !a: a →1 is the unique
function from a to 1 . Constants, like the number zero, will be modeled by functions with
1 as source, thus zero: 1 →nat . The sole member of 1 is sometimes written ( ) , so that
zero( ) ∈nat and zero is called a nullary function.
For the naturals we use several known operations.
zero
:
1 →nat
zero, considered as a function from 1
succ
:
nat →nat
the successor function
add
:
II nat →nat
addition .
The set nat consists of all natural numbers. Functions on nat may be deﬁned by induction
on the zero, succ -structure of their argument.
For lists we distinguish between several variants.
The datatype of cons lists over a has as carrier the set La that consists of ﬁnite lists
only. There are two functions nil and cons .
nil
:
1 →La
cons
:
a × La →La .
Depending on the context, nil and cons are ﬁxed for one speciﬁc set a , or they are
considered to be polymorphic, that is, having the indicated type for each set a . In a very
few cases a subscript will make this explicit. Each element from La can be written as a
ﬁnite expression
cons(x0, cons(x1, . . . cons(xn−1, nil))) .
So, functions over La can be deﬁned by induction on the nil, cons structure of their
argument. For example, deﬁnitions of size: La →nat and isempty: La →La + La read
nil ; size
=
zero
cons ; size
=
id × size ; add
and

77
nil ; isempty
=
nil ; inl
cons ; isempty
=
cons ; inr .
Function isempty sends its argument unaﬀected to the left/right component of its result
type according to whether it is/isn’t the empty list. A boolean result may be obtained by
post-composing isempty with true ∇false , see Section 2c for the case construct
∇. For
each function f: a →b the so-called map f for cons lists, denoted Lf , is deﬁned by
nil a ; Lf
=
nil b
consa ; Lf
=
f × Lf ; consb .
If L were a functor, these equations assert that nil and cons are natural transformations:
nil
:
1 .→L
cons
:
I × L .→L .
We shall see that L really is a functor.
The datatype of streams over a has as carrier the set Sa that consists of inﬁnite lists
only. There are two functions to destruct a stream into a head in a and a tail that is a
stream over a again.
hd
:
Sa →a
tl
:
Sa →Sa .
A function yielding a stream can be deﬁned by inductively describing what its result is, in
terms of applications of hd and tl . For example, the lists of naturals is deﬁned as follows.
from
:
nat →S nat
from ; hd
=
id
from ; tl
=
succ ; from
nats
:
1 →S nat
nats
=
zero ; from
By induction on n one can prove that
nats ; tl n
; hd
=
zero ; succn .
These functions act on inﬁnite datastructures and the evaluation of nats on a computing
engine requires an inﬁnite amount of time. Yet these functions are total; for each argument
the result is well-deﬁned. For each function f: a →b the so-called map f for streams,
denoted Sf , is deﬁned by
Sf ; hd b
=
hd a ; f
Sf ; tl b
=
tl a ; Sf .

78
If S were a functor, these equations assert that hd and tl are natural transformations:
hd
:
S .→I
tl
:
S .→S .
We shall see that S really is a functor.
The datatype of cons′ lists over a has as carrier the set L′a that consists of all ﬁnite
and inﬁnite lists, called cons′ lists. There are several relevant functions.
nil ′
:
1 →L′a
cons′
:
a × L′a →L′a
destruct ′
:
L′a →1 + a × L′a
isempty′
:
L′a →L′a + L′a
with
nil ′
; destruct ′
=
inl
cons′
; destruct ′
=
inr
nil ′
; isempty′
=
nil ′
; inl
cons′
; isempty′
=
cons′
; inr .
Since cons′ lists are possibly inﬁnite, a ‘deﬁnition’ by induction on the nil ′, cons′ -structure
of cons′ lists is in general not possible; that would give partially deﬁned functions, and
these do not exist in our intended universe of discourse Set . For example, consider the
following equations with “unknown size′ ”.
nil ′
; size′
=
zero
cons′
; size′
=
id × size′
; add
These do not deﬁne a total function size′: L′a →nat , in contrast to the situation for
cons lists. (Notice also the diﬀerence with the usual datatype of lists of nonstrict functional
programming languages: next to ﬁnite and inﬁnite lists, it comprises also partially deﬁned
lists.)

