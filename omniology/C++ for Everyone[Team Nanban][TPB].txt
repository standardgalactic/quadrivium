 

   
This book gives an introduction into C++ and computer programming that focuses on the essentials—and on
effective learning. The book is suitable for a first course in programming for computer scientists, engineers, and
students in other technical or scientific disciplines. No prior programming experience is required, and only a
modest amount of high school algebra is needed. Here are the key features of this new book:
•  A Visual Approach Motivates the Reader and Eases Navigation.   This book
contains many more photographs, diagrams, and tables than other programming books. It is easy to get the
“lay of the land” by browsing the visuals, before focusing on the textual material.
Visual features help the reader with navigation.
•  Guidance and Worked Examples Help Students Succeed.   Beginning programmers
often ask “How do I start? Now what do I do?” Of course, an activity as complex as programming cannot be
reduced to cookbook-style instructions. However, step-by-step guidance is immensely helpful for building
confidence and providing an outline for the task at hand. The book contains a large number of “How To”
guides for common tasks, together with additional worked examples on the web.
•  Practice Makes Perfect.   Of course, programming students need to be able to implement
nontrivial programs, but they first need to have the confidence that they can succeed. This book contains a
substantial number of self-check questions (at the end of each section), simple programming assignments,
and an electronic test bank.
•  Teach Computer Science Principles, Not Just C++ or Object-Orientation.  
This book uses the C++ programming language as a vehicle for introducing computer science concepts. A
substantial subset of the C++ language is covered, focusing on the modern features of standard C++ that
make students productive. The book starts gently by showing how to use objects (in particular, strings and
streams). Then it takes a traditional route, stressing functions and procedural decomposition, before turning
to the design of classes in the final chapters.
•  Focus on the Essentials While Being Technically Accurate.   An encyclopedic
coverage is not helpful for a beginning programmer, but neither is the opposite—reducing the material to a
list of simplistic bullet points. In this book, the essential essentials of each subject are presented in digestible
chunks, with separate notes that go deeper into good practices or language features when the reader is ready
for the additional information. You will not find artificial over-simplifications that give an illusion of
knowledge.
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 10
2/1/2010 2:56 PM

The core material of the book is:
Chapter 1. Introduction
Chapter 2. Fundamental Data Types
Chapter 3. Decisions
Chapter 4. Loops
Chapter 5. Functions
Chapter 6. Arrays and Vectors
In a course for engineers with a need for systems and embedded programming, you will want to cover Chapter 7 on pointers.
Sections 7.1 and 7.4 are sufficient for using pointers with polymorphism in Chapter 10.
File processing is the subject of Chapter 8. Section 8.1 is sufficient for an introduction into reading and writing text files. The
remainder of the chapter gives additional material for practical applications.
Chapters 9 and 10 introduce the object-oriented features of C++. Chapter 9 contains an introduction to class design and
implementation. Chapter 10 covers inheritance and polymorphism.
 Four additional chapters are available on the Web. They can be used individually for a capstone chapter, or they can be
combined for teaching a two-semester course. (They can also be incorporated into a custom print version of the text; ask your
Wiley sales representative for details.)
Chapter 11. Recursion
Chapter 12. Sorting and Searching
Chapter 13. Lists, Queues, and Stacks
Chapter 14. Sets, Maps, and Priority Queues
Figure 1 shows the dependencies between the chapters.
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 10
2/1/2010 2:56 PM

  Figure 1   Chapter Dependencies
Appendices
Appendix A contains a programming style guide. Using a style guide for programming assignments benefits students by
directing them toward good habits and reducing gratuitous choice. The style guide is available in electronic form so that
instructors can modify it to reflect their preferred style.
Appendices B and C summarize C++ reserved words and operators.
Appendix D lists character escape sequences and ASCII character code values.
Appendix E documents all of the library functions and classes used in this book. An expanded version of this Appendix that
includes the functions and classes used in the four optional chapters, 11—14, is available on the Web and in WileyPLUS.
Appendices F, G, and H cover number systems, bit and shift operations, and a comparison of C++ and Java; all three are on the
Web and in WileyPLUS.
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 10
2/1/2010 2:56 PM

The pedagogical elements in this book work together to focus on and reinforce key concepts and fundamental principles of
programming, with additional tips and detail organized to support and deepen these fundamentals. In addition to traditional
features, such as chapter objectives and a wealth of exercises, each chapter contains elements geared to today's visual learner.
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 10
2/1/2010 2:56 PM

Special Features
Seven special features add detail and provide step-by-step guidance. Identified with the icons shown here, they are set off so
they don't interrupt the flow of the main material. Some of these are quite short; others extend over a page. Each topic is given
the space that is needed for a full and convincing explanation—instead of being forced into a one-paragraph “tip”. You can use
the tables on pages xxii—xxv to see the features in each chapter and the page numbers where they can be found.
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 10
2/1/2010 2:56 PM

Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 10
2/1/2010 2:56 PM

The book is supplemented by a complete suite of online resources and a robust WileyPLUS course.
Student and Instructor Resources
The following resources for students and instructors can be obtained by visiting www.wiley.com/college/horstmann (or the
WileyPLUS course for the book). Two companion web sites accompany the book—one for students, and a password-protected
site for instructors only.
•  Solutions to all exercises (for instructors only)
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 10
2/1/2010 2:56 PM

•  A test bank (for instructors only)
•  Lecture presentation slides that summarize each chapter and include code listings and figures from the book (for
instructors only)
•  Source code for all examples in the book
•  Additional worked examples and appendices (identified by an icon, 
)
•  Four additional chapters on recursion, sorting and searching, and data structures
•  The programming style guide in electronic form, so you can modify it to suit local preferences
Students can locate the Worked Examples and other content marked with a plus icon, 
, in the WileyPLUS course
or on the web site for the book at www.wiley.com/college/horstmann.
WileyPLUS
The first two pages of this book describe an innovative online tool for teachers and students: WileyPLUS is an online learning
environment that combines all of the resources of a learning management system with an ebook.
With WileyPLUS, instructors can manage reading and homework assignments, create tests, assign quizzes, and store results in
an online gradebook. A WileyPLUS adoption also enables students to purchase an eBook at a fraction of the price of the print
edition. In addition to the eBook, WileyPLUS integrates all of the instructor and student web resources into an online version
of this text. For more information and a demo, please visit the web site listed on pages i-ii, or talk to your Wiley representative.
Many thanks to Dan Sayre, Lauren Sapira, Lisa Gee, and Carolyn Weisman at John Wiley & Sons, and to the team at Publishing
Services for their hard work and support for this book project. An especially deep acknowledgment and thanks to Cindy
Johnson, who, through enormous patience and attention to detail, made this book a reality. We would also like to thank
Jonathan Tolstedt, North Dakota State University, for working with us to prepare the solutions.
We are very grateful to the many individuals who reviewed the book and made many valuable suggestions for improvement.
They include:
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
8 of 10
2/1/2010 2:56 PM

Charles D. Allison, Utah Valley State College
Fred Annexstein, University of Cincinnati
Stefano Basagni, Northeastern University
Noah D. Barnette, Virginia Tech
Peter Breznay, University of Wisconsin, Green Bay
Kuang-Nan Chang, Eastern Kentucky University
Joseph DeLibero, Arizona State University
Subramaniam Dharmarajan, Arizona State University
Stephen Gilbert, Orange Coast Community College
Barbara Guillott, Louisiana State University
Jon Hanrath, Illinois Institute of Technology
Neil Harrison, Utah Valley University
Debbie Kaneko, Old Dominion University
Mir Behrad Khamesee, University of Waterloo
Sung-Sik Kwon, North Carolina Central University
W. James MacLean, University of Toronto
Ethan V. Munson, University of Wisconsin, Milwaukee
Philip Regalbuto, Trident Technical College
John P. Russo, Wentworth Institute of Technology
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
9 of 10
2/1/2010 2:56 PM

Kurt Schmidt, Drexel University
William Shay, University of Wisconsin, Green Bay
Michele A. Starkey, Mount Saint Mary College
William Stockwell, University of Central Oklahoma
Jonathan Tolstedt, North Dakota State University
Kerstin Voigt, California State University, San Bernardino
David P. Voorhees, Le Moyne College
Salih Yurttas, Texas A&M University
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Preface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
10 of 10
2/1/2010 2:56 PM

Chapter
   
    
    
Chapter Goals
•  To learn about the architecture of computers
•  To learn about machine languages and higher-level programming languages
•  To become familiar with your compiler
•  To compile and run your first C++ program
•  To recognize syntax and logic errors
•  To understand the notion of an algorithm
•  To understand the activity of programming
This chapter contains a brief introduction to the architecture of computers and an overview of programming
languages. You will learn about the activity of programming: how to write and run your first C++ program, how
to diagnose and fix programming errors, and how to plan your programming activities.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To learn abo ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:21 AM

You have probably used a computer for work or fun. Many people use computers for everyday tasks such as electronic banking
or writing a term paper. Computers are good for such tasks. They can handle repetitive chores, such as totaling up numbers or
placing words on a page, without getting bored or exhausted.
Computers execute very basic operations in rapid
succession.
The flexibility of a computer is quite an amazing phenomenon. The same machine can balance your checkbook, print your term
paper, and play a game. In contrast, other machines carry out a much narrower range of tasks; a car drives and a toaster toasts.
Computers can carry out a wide range of tasks because they execute different programs, each of which directs the computer to
work on a specific task.
The computer itself is a machine that stores data (numbers, words, pictures), interacts with devices (the monitor, the sound
system, the printer), and executes programs. A computer program tells a computer, in minute detail, the sequence of steps that
are needed to fulfill a task. The physical computer and peripheral devices are collectively called the hardware. The programs
the computer executes are called the software.
A computer program is a sequence of instructions and
decisions.
Today's computer programs are so sophisticated that it is hard to believe that they are composed of extremely primitive
operations. A typical operation may be one of the following:
• Put a red dot at this screen position.
• Add up these two numbers.
• If this value is negative, continue the program at a certain instruction.
The computer user has the illusion of smooth interaction because a program contains a huge number of such operations, and
because the computer can execute them at great speed.
The act of designing and implementing computer programs is called programming. In this book, you will learn how to
program a computer—that is, how to direct the computer to execute tasks.
Programming is the act of designing and implementing
computer programs.
To write a computer game with motion and sound effects or a word processor that supports fancy fonts and pictures is a
complex task that requires a team of many highly skilled programmers. Your first programming efforts will be more mundane.
The concepts and skills you learn in this book form an important foundation, and you should not be disappointed if your first
programs do not rival the sophisticated software that is familiar to you. Actually, you will find that there is an immense thrill
even in simple programming tasks. It is an amazing experience to see the computer precisely and quickly carry out a task that
would take you hours of drudgery, to make small changes in a program that lead to immediate improvements, and to see the
computer become an extension of your mental powers.
Self Check
1.  What is required to play music on a computer?
2.  Why is a CD player less flexible than a computer?
3.  What does a computer user need to know about programming in order to play a video game?
What is a Computer?
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:21 AM

To understand the programming process, you need to have a rudimentary understanding of the building blocks that make up a
computer. We will look at a personal computer. Larger computers have faster, larger, or more powerful components, but they
have fundamentally the same design.
At the heart of the computer lies the central processing unit (CPU) (see Figure 1). It consists of a single chip, or a small
number of chips. A computer chip (integrated circuit) is a component with a plastic or metal housing, metal connectors, and
inside wiring made principally from silicon. For a CPU chip, the inside wiring is enormously complicated. For example, the
Pentium chip (a popular CPU for personal computers at the time of this writing) is composed of several million structural
elements, called transistors.
Figure 1   Central Processing Unit
Copyright © 2008, Intel Corporation.
The CPU performs program control and data processing. That is, the CPU locates and executes the program instructions; it
carries out arithmetic operations such as addition, subtraction, multiplication, and division; it fetches data from external
memory or devices and stores data back. All data must travel through the CPU whenever it is moved from one location to
another.
The central processing unit (CPU) performs program
control and data processing.
The computer stores data and programs in memory. There are two kinds of memory. Primary storage is made from memory
chips: random-access memory (RAM) and read-only memory (ROM). Read-only memory contains certain programs that must
always be present—for example, the code needed to start the computer. Random-access memory might have been better called
“read-write memory”, because the CPU can read data from it and write data back to it. That makes RAM suitable to hold
changing data and programs that do not have to be available permanently. RAM memory has two disadvantages. It is
comparatively expensive, and it loses all its data when the power is turned off. Secondary storage, usually a hard disk (see
Figure 2), provides less expensive storage that persists without electricity. A hard disk consists of rotating platters, which are
coated with a magnetic material, and read/write heads, which can detect and change the magnetic flux on the platters. Programs
and data are typically stored on the hard disk and loaded into RAM when the program starts. The program then updates the data
in RAM and writes the modified data back to the hard disk.
The Anatomy of a Computer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 8:22 AM

Figure 2   A Hard Disk
PhotoDisc, Inc./Getty Images.
Storage devices include random-access memory
(RAM) and secondary storage.
To interact with a human user, a computer requires peripheral devices. The computer transmits information (called output) to
the user through a display screen, speakers, and printers. The user can enter information (called input) for the computer by
using a keyboard or a pointing device such as a mouse.
Some computers are self-contained units, whereas others are interconnected through networks. Through the network cabling,
the computer can read data and programs from central storage locations or send data to other computers. For the user of a
networked computer it may not even be obvious which data reside on the computer itself and which are transmitted through the
network.
Figure 3 gives a schematic overview of the architecture of a personal computer. Program instructions and data (such as text,
numbers, audio, or video) are stored on the hard disk, on a CD-ROM, or elsewhere on the network. When a program is started,
it is brought into RAM memory, from where the CPU can read it. The CPU reads the program one instruction at a time. As
directed by these instructions, the CPU reads data, modifies it, and writes it back to RAM memory or the hard disk. Some
program instructions will cause the CPU to place dots on the display screen or printer or to vibrate the speaker. As these
actions happen many times over and at great speed, the human user will perceive images and sound. Some program instructions
read user input from the keyboard or mouse. The program analyzes the nature of these inputs and then executes the next
appropriate instructions.
The Anatomy of a Computer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 8:22 AM

Figure 3   Schematic Design of a Personal Computer
Self Check
4.  Where is a program stored when it is not currently running?
5.  Which part of the computer carries out arithmetic operations, such as addition and multiplication?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The Anatomy of a Computer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 8:22 AM

Random Fact 1.1
RANDOM FACT 1.1 The ENIAC and the Dawn of Computing
The ENIAC (electronic numerical integrator and computer) was the first usable electronic computer. It was
designed by J. Presper Eckert and John Mauchly at the University of Pennsylvania and was completed in 1946—two
years before transistors were invented. The computer was housed in a large room and consisted of many cabinets
containing about 18,000 vacuum tubes (see Figure 4). Vacuum tubes burned out at the rate of several tubes per day.
An attendant with a shopping cart full of tubes constantly made the rounds and replaced defective ones. The
computer was programmed by connecting wires on panels. Each wiring configuration would set up the computer
for a particular problem. To have the computer work on a different problem, the wires had to be replugged.
Figure 4   The ENIAC
Courtesy of Sperry Univac, Division of Sperry Corporation.
Work on the ENIAC was supported by the U.S. Navy, which was interested in computations of ballistic tables that
would give the trajectory of a projectile, depending on the wind resistance, initial velocity, and atmospheric
conditions. To compute the trajectories, one must find the numerical solutions of certain differential equations;
hence the name “numerical integrator”. Before machines like the ENIAC were developed, humans did this kind of
work, and until the 1950s the word “computer” referred to these people. The ENIAC was later used for peaceful
purposes such as the tabulation of U.S. Census data.
RANDOM FACT 1.1 The ENIAC and the Dawn of Computing
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:22 AM

On the most basic level, computer instructions are extremely primitive. The processor executes machine instructions. A
typical sequence of machine instructions is
1.  Move the contents of memory location 40000 into the CPU.
2.  If that value is > 100, continue with the instruction that is stored in memory location 11280.
Actually, machine instructions are encoded as numbers so that they can be stored in memory. On a Pentium processor, this
sequence of instruction is encoded as the sequence of numbers
Computer programs are stored as machine instructions
in a code that depends on the processor type.
On a processor from a different manufacturer, the encoding would be different. When this kind of processor fetches this
sequence of numbers, it decodes them and executes the associated sequence of commands.
How can we communicate the command sequence to the computer? The simplest method is to place the actual numbers into
the computer memory. This is, in fact, how the very earliest computers worked. However, a long program is composed of
thousands of individual commands, and it is a tedious and error-prone affair to look up the numeric codes for all commands
and place the codes manually into memory. As already mentioned, computers are really good at automating tedious and
error-prone activities. It did not take long for computer programmers to realize that the computers themselves could be
harnessed to help in the programming process.
A special computer program, a compiler, translates the higher-level description into machine instructions for a particular
processor.
For example, in C++ , the high-level programming language that we will use in this book, you might give the following
instruction:
This means, “If the interest rate is over 100, display an error message”. It is then the job of the compiler program to look at
each C++ instruction and translate it into the machine instructions for the particular processor.
High-level languages are independent of the underlying hardware. C++ instructions work equally well on an Intel Pentium and
a processor in a cell phone. Of course, the compiler-generated machine instructions are different, but the programmer who uses
the compiler need not worry about these differences.
High-level programming languages are independent of
the processor.
Self Check
6.  Is the compiler a part of the computer hardware or software?
7.  Does a person who uses a computer for office work ever run a compiler?
Machine Code and Programming Languages
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:22 AM

C++ is built upon the C programming language, which was developed to be translated into fast machine code with a minimum
of housekeeping overhead. C++ built on C by adding features for “object-oriented programming”, a programming style that
enables modeling of real-world objects.
The initial version of the C language was designed about 1972. Additional features were added to it over the years. Because
different compiler writers added different features, the language actually sprouted various dialects. Some programming
instructions were understood by one compiler but rejected by another. Such divergence is a major obstacle to a programmer
who wants to move code from one computer to another. An effort got underway to iron out the differences and come up with a
standard version of C. The design process ended in 1989 with the completion of the ANSI (American National Standards
Institute) standard. In the meantime, Bjarne Stroustrup of AT&T added features of the language Simula (an object-oriented
language designed for carrying out simulations) to C. The resulting language was called C++.
From 1985 until today, C++ has grown by the addition of many features. A standardization process culminated in the
publication of the international C++ standard in 1998. A minor update to the standard was issued in 2003, and a major
revision is expected to come to fruition around 2010.
At this time, C++ is the most commonly used language for developing system software such as databases and operating
systems. Just as importantly, C++ is increasingly used for programming “embedded systems”, small computers that control
devices such as automobile engines or cellular telephones.
C++ is a general-purpose language that is in
widespread use for systems and embedded
programming.
Self Check
8.  What was added to the C language to create C++?
9.  What are the most important uses for C++?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The Evolution of C++
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:23 AM

Random Fact 1.2
RANDOM FACT 1.2 Standards Organizations
Two organizations, the American National Standards Institute (ANSI) and the International Organization for
Standardization (ISO), have jointly developed the definitive standard for the C++ language.
iStockphoto.
Why have standards? You encounter the benefits of standardization every day. When you buy a light bulb, you can
be assured that it fits in the socket without having to measure the socket at home and the bulb in the store. In fact,
you may have experienced how painful the lack of standards can be if you have ever purchased a flashlight with
nonstandard bulbs. Replacement bulbs for such a flashlight can be difficult and expensive to obtain.
The ANSI and ISO standards organizations are associations of industry professionals who develop standards for
everything from car tires and credit card shapes to programming languages. Having a standard for a programming
language such as C++ means that you can take a program that you developed on one system with one
manufacturer's compiler to a different system and be assured that it will continue to work.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 1.2 Standards Organizations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:29 AM

As you use this book, you may well be doing your work on an un-familiar computer system. You should spend some time
making yourself familiar with the computer. Because computer systems vary widely, this book can only give an outline of the
steps you need to follow. Using a new and unfamiliar computer system can be frustrating. Look for training courses that your
campus offers, or just ask a friend to give you a brief tour.
Set aside some time to become familiar with the
computer system and the C++ compiler that you will
use for your class work.
Step 1  Log In
If you use your own home computer, you don't need to worry about logging in. Computers in a lab, however,
are usually not open to everyone. Access is usually restricted to those who paid the necessary fees and who can
be trusted to use the lab responsibly. You will likely need an account number and a password to gain access to
the system.
Step 2  Locate the C++ Compiler
Computer systems differ greatly in this regard. Some systems let you start the compiler by selecting an icon or
menu. On other systems you must use the keyboard to type a command to launch the compiler. On many
personal computers there is an integrated environment in which you can write and test your programs. On other
computers you must first launch one program that functions like a word processor, in which you can enter your
C++ instructions; then launch another program to translate them to machine code; and then run the resulting
machine code.
Step 3  Understand Files and Folders
As a programmer, you will write C++ programs, try them out, and improve them. You will be provided a place
on the computer to store them, and you need to find out where that place is. You will store your programs in
files. A C++ file is a container of C++ instructions. Files have names, and the rules for legal names differ from
one system to another. Some systems allow spaces in file names; others don't. Some distinguish between upper-
and lowercase letters; others don't. Most C++ compilers require that C++ files end in an extension 
,
, or 
; for example, 
.
Files are stored in folders or directories. These file containers can be nested. A folder can contain files as well
as other folders, which themselves can contain more files and folders (see Figure 5). This hierarchy can be quite
large, especially on networked computers where some of the files may be on your local disk, others elsewhere
on the network. While you need not be concerned with every branch of the hierarchy, you should familiarize
yourself with your local environment. Different systems have different ways of showing files and directories.
Some use a graphical display and let you move around by clicking the mouse on folder icons. In other systems,
you must enter commands to visit or inspect different locations.
Becoming Familiar with Your Computer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 8:30 AM

Figure 5   A Directory Hierarchy
Step 4  Write a Simple Program
In the next section, we will introduce a very simple program. You will need to learn how to type it in, run it, and
fix mistakes.
Step 5  Save Your Work
Develop a strategy for keeping backup copies of
your work before disaster strikes.
You will spend many hours typing C++ programs in and improving them. The resulting program files have some
value, and you should treat them as you would other important property. A conscientious safety strategy is
particularly important for computer files. They are more fragile than paper documents or other more tangible
objects. It is easy to delete a file by accident, and occasionally files are lost because of a computer malfunction.
Unless you keep another copy, you must retype the contents. Because you are unlikely to remember the entire
file, you will likely find yourself spending almost as much time as you did to enter and improve it in the first
place. This lost time may cause you to miss deadlines. It is therefore crucially important that you learn how to
safeguard files and get in the habit of doing so before disaster strikes. You can make safety or backup copies of
files by saving copies on a memory stick or on another computer.
Becoming Familiar with Your Computer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 8:30 AM

Self Check
10.  How are programming projects stored on a computer?
11.  What do you do to protect yourself from data loss when you work on programming projects?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Becoming Familiar with Your Computer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 8:30 AM

Productivity Hint 1.1
PRODUCTIVITY HINT 1.1 Backup Copies
Backing up files on a memory stick is an easy and convenient storage method for many people. Another
increasingly popular form of backup is Internet file storage. Here are a few pointers to keep in mind.
•  Back Up Often.   Backing up a file takes only a few seconds, and you will hate yourself if you have to
spend many hours recreating work that you could have saved easily. I recommend that you back up your work
once every thirty minutes.
•  Rotate Backups.   Use more than one directory for backups, and rotate them. That is, first back up
onto the first directory. Then back up onto the second directory. Then use the third, and then go back to the
first. That way you always have three recent backups. If your recent changes made matters worse, you can
then go back to the older version.
•  Back Up Source Files Only.   The compiler translates the files that you write into files consisting
of machine code. There is no need to back up the machine code files, since you can recreate them easily by
running the compiler again. Focus your backup activity on those files that represent your effort. That way
your backup disks won't fill up with files that you don't need.
•  Pay Attention to the Backup Direction.   Backing up involves copying files from one place to
another. It is important that you do this right—that is, copy from your work location to the backup location.
If you do it the wrong way, you will overwrite a newer file with an older version.
•  Check Your Backups Once in a While.   Double-check that your backups are where you think
they are. There is nothing more frustrating than to find out that the backups are not there when you need
them.
•  Relax, then Restore.   When you lose a file and need to restore it from backup, you are likely to be
in an unhappy, nervous state. Take a deep breath and think through the recovery process before you start. It is
not uncommon for an agitated computer user to wipe out the last backup when trying to restore a damaged
file.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
PRODUCTIVITY HINT 1.1 Backup Copies
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:30 AM

You are now ready to write and run your first C++ program. The traditional choice for the very first program in a new
programming language is a program that displays a simple greeting: “Hello, World!” We follow that tradition. Here is the
“Hello, World!” program in C++.
ch01/hello.cpp 
Program Run
We will explain this program in a minute. For now, you should make a new program file and call it 
. Enter the
program instructions and compile and run the program, following the procedure that is appropriate for your compiler. (The
line numbers are not part of the program. They are included so that your instructor can reference them during lectures.)
When you type in this program, be aware that C++ is case-sensitive. You must enter upper- and lowercase letters exactly as
they appear in the program listing. Do not type 
 or 
. On the other hand, C++ has free-form layout. The amount of
spaces, tabs, and line breaks (collectively called white space) used for layout is not important. You can even write the entire
program on a single line:
However, you should always use a layout that makes your programs easy to read.
When you run the program, the message
will appear on the screen. On some systems, you may need to switch to a different window to find the message.
Now that you have seen the program working, it is time to understand its makeup. The basic structure of a C++ program is
shown in Syntax 1.1.
The first line,
tells the compiler to include a service for “stream input/output”. You will learn in Chapter 8 what a stream is. For now, you
should simply remember to add this line into all programs that perform input or output.
The next line,
tells the compiler to use the “standard namespace”. Namespaces are a mechanism for avoiding naming conflicts in large
programs. You need not be concerned about namespaces. For the programs that you will be writing in this book, you will
Compiling a Simple Program
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 8:24 AM

always use the standard namespace. Simply add the directive 
; at the top of every program that you
write, just below the 
 directives.
Every C++ program contains 
 directives
and a function called 
.
The construction
defines a function called 
 that “returns” the integer 0 (which indicates that the program finished successfully). A
function is a collection of programming instructions that carry out a particular task. Every C++ program must have a 
function. Most C++ programs contain other functions besides 
, but it will take us until Chapter 5 to discuss functions
and return values.
For now, it is a good idea to consider all these parts as the plumbing that is necessary to write a simple program. Simply place
the code that you want to execute inside the braces of the 
 function.
To display values on the screen, you send them to an entity called 
. The << operator denotes the “send to” command. For
example, the statement
displays the number 42.
Use 
 and the << operator to display values on the
screen.
The statement
displays the string 
. A string is a sequence of characters. You must enclose the contents of a string inside quotation
marks so that the compiler knows you literally mean the text 
 and not a function with the same name.
Enclose text strings in quotation marks.
You can send more than one item to 
. Use a 
 before each one of them. For example,
displays The 
 (in C++, the * denotes multiplication).
Use  to add two numbers and  to multiply two
numbers.
The 
 symbol denotes an end of line marker. When this marker is sent to 
, the cursor is moved to the first column in
the next screen row. If you don't use an end of line marker, then the next displayed item will simply follow the current string on
the same line. In this program we only printed one item, but in general we will want to print multiple items, and it is a good
habit to end all lines of output with an end of line marker.
Send 
 to 
 to end a line of displayed output.
Compiling a Simple Program
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 8:24 AM

Finally, note that each statement in C++ ends in a semicolon, just as every English sentence ends in a period.
End each statement with a semicolon.
Self Check
12.  How do you modify the 
 program to greet you instead?
13.  What is wrong with this program?
14.  What does the following sequence of statements print?
15.  What does the following statement print?
16.  What does the following statement print?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Compiling a Simple Program
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 8:24 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 1.1 C++ Program
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:31 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 1.2 Output Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:25 AM

Common Error 1.1
COMMON ERROR 1.1 Omitting Semicolons
In C++ every statement must end in a semicolon. Forgetting to type a semicolon is a common error. It confuses the
compiler because the compiler uses the semicolon to find where one statement ends and the next one starts. The
compiler does not use line ends or closing braces to recognize the ends of statements. For example, the compiler
considers
a single statement, as if you had written
and then it doesn't understand that statement, because it does not expect the word 
 in the middle of an
output command. The remedy is simple. Just scan every statement for a terminating semicolon, just as you would
check that every English sentence ends in a period.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 1.1 Omitting Semicolons
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:25 AM

Advanced Topic 1.1
ADVANCED TOPIC 1.1 Escape Sequences
How can you display a string containing quotation marks, such as
You can't use
As soon as the compiler reads 
, it thinks the string is finished, and then it gets all confused about
. Compilers have a one-track mind, and if a simple analysis of the input doesn't make sense to them, they just
refuse to go on, and they report an error. In contrast, a human would probably realize that the second and third
quotation marks were supposed to be part of the string.
Well, how do we then display quotation marks on the screen? The designers of C++ provided an escape hatch.
Mark each quotation mark with a backslash character ( ), like this:
The sequence 
 denotes a literal quote, not the end of a string. Such a sequence is called an escape sequence.
There are a few other escape sequences. If you actually want to show a backslash on the display, you use the escape
sequence 
. The statement
prints
Finally, the escape sequence 
 denotes a newline character that starts a new line on the screen. The command
has exactly the same effect as
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 1.1 Escape Sequences
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:25 AM

Programming languages follow very strict conventions. When you talk to another person, and you scramble or omit a word or
two, your conversation partner will usually still understand what you have to say. But when you make an error in a C++
program, the compiler will not try to guess what you meant. (This is actually a good thing. If the compiler were to guess
wrongly, the resulting program would do the wrong thing—quite possibly with disastrous effects.) It is important that you
learn to understand the compiler's error messages.
Experiment a little with the 
 program. What happens if you make a typing error such as
A syntax error is a part of a program that does not
conform to the rules of the programming language.
In the first case, the compiler will complain that it has no clue what you mean by 
. The exact wording of the error message
is dependent on the compiler, but it might be something like 
. This is a compile-time error
or syntax error. Something is wrong according to the language rules, and the compiler finds it. When the compiler finds one
or more errors, it will not translate the program to machine code, and as a consequence there is no program to run. You must
fix the error and compile again. It is common to go through several rounds of fixing compile-time errors before compilation
succeeds for the first time.
If the compiler finds an error, it will not simply stop and give up. It will try to report as many errors as it can find, so you can
fix them all at once. Sometimes, however, one error throws it off track. This is likely to happen with the error in the second
line. Since the programmer forgot the closing quote, the compiler will keep looking for the end of the string. In such cases, it is
common for the compiler to emit bogus error reports for neighboring lines. You should fix only those error messages that
make sense to you and then recompile.
The error in the third line is of a different kind. The program will compile and run, but its output will be wrong. It will print
This is a run-time error or logic error. The program is syntactically correct and does something, but it doesn't do what it is
supposed to do. The compiler cannot find the error, and it must be flushed out when the program runs, by testing it and
carefully looking at its output.
Logic errors are errors in a program that executes
without performing the intended action.
During program development, errors are unavoidable. Once a program is longer than a few lines, it requires superhuman
concentration to enter it correctly without slipping up once. You will find yourself omitting semicolons or quotes more often
than you would like, but the compiler will track down these problems for you.
Logic errors are more troublesome. The compiler will not find them—in fact, the compiler will cheerfully translate any
program as long as its syntax is correct—but the resulting program will do something wrong. It is the responsibility of the
program author to test the program and find any logic errors. Program testing is an important topic that you will encounter
many times in this book.
The programmer is responsible for inspecting and
testing the program to guard against logic errors.
Errors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:32 AM

Self Check
17.  Suppose you omit the () characters after 
 from the 
 program. Will you get a compile-time
error or a run-time error?
18.  How can you find logic errors in a program?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Errors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 8:32 AM

Common Error 1.2
COMMON ERROR 1.2 Misspelling Words
If you accidentally misspell a word, strange things may happen, and it may not always be completely obvious from
the error messages what went wrong. Here is a good example of how simple spelling errors can cause trouble:
This code defines a function called 
. The compiler will not consider this to be the same as the 
 function,
because 
 starts with an uppercase letter and the C++ language is case-sensitive. Upper- and lowercase
letters are considered to be completely different from each other, and to the compiler 
 is no better match for
 than 
. The compiler will compile your 
 function, but when the linker is ready to build the
executable file (see Section 1.8), it will complain about the missing 
 function and refuse to link the program.
Of course, the message “missing 
 function” should give you a clue where to look for the error.
If you get an error message that seems to indicate that the compiler is on the wrong track, it is a good idea to check
for spelling and capitalization. In C++ , most names use only lowercase letters. If you misspell the name of a
symbol (for example 
 instead of 
), the compiler will complain about an “undefined symbol”. This error
message is usually a good clue that you made a spelling error.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 1.2 Misspelling Words
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:32 AM

Some C++ development environments are very convenient to use. You just enter the code in one window, click on a button or
menu to compile, and click on another button or menu to run your code. Error messages show up in a second window, and the
program runs in a third window. Figure 6 shows the screen layout of a popular C++ compiler with these features. With such an
environment you are completely shielded from the details of the compilation process. On other systems you must carry out
every step manually.
  Figure 6   Screen Layout of an Integrated C++ Environment
Even if you use a convenient C++ environment, it is useful to know what goes on behind the scenes, mainly because knowing
the process helps you solve problems when something goes wrong.
You first enter the program statements into a text editor. The editor stores the text and gives it a name such as 
. If
the editor window shows a name like 
, you should change the name. You should save the file to disk frequently,
because otherwise the editor only stores the text in the computer's RAM memory. If something goes wrong with the computer
and you need to restart it, the contents of the RAM (including your program text) are lost, but anything stored on a hard disk is
permanent even if you need to restart the computer.
When you compile your program, the compiler translates the C++ source code (that is, the statements that you wrote) into
machine code. The resulting file consists of machine instructions and information on how to load the program into memory
prior to execution. Machine code is sometimes called object code, but we do not use that terminology to avoid confusion with
C++ objects. Machine code files usually have the extension 
 or 
. For example, the machine code for the 
program might be stored in 
.
The compiler translates C++ programs into machine
code.
The machine code file contains only the translation of the code that you wrote. That is not enough to actually run the program.
The Compilation Process
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 8:32 AM

To display a string on a window, quite a bit of low-level activity is necessary. The authors of the 
 package (which
defines 
 and its functionality) have implemented all necessary actions and placed the required machine code into a library.
A library is a collection of code that has been programmed and translated by someone else, ready for you to use in your
program. (More complicated programs are built from more than one machine code file and more than one library.) A special
program called the linker takes your machine code file and the necessary parts from the 
 library and builds an
executable file. (Figure 7 gives an overview of these steps.) The executable file is usually called 
 or 
,
depending on your computer system. It contains all machine code necessary to run the program. You can run the program by
typing 
 at a command prompt, or by clicking on the file icon, even after you exit the C++ environment. You can email
that file to another user who doesn't have a C++ compiler or who may not know that there is such a thing as C++, and that
person can run the program in the same way.
The linker combines machine code with library code
into an executable program.
  Figure 7   From Source Code to Executable Program
Your programming activity centers around these files. You start in the editor, writing the source file. You compile the
program and look at the error messages. You go back to the editor and fix the syntax errors. When the compiler succeeds, the
linker builds the executable file. You run the executable file. If you find an error, you need to find the cause of the error, go
back to the editor and fix it. You compile, link, and run again to see whether the error has gone away. If not, you go back to the
editor. This is called the edit-compile-run loop (see Figure 8).
The Compilation Process
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 8:32 AM

  Figure 8   Edit-Compile-Run Loop
Self Check
19.  What do you expect to see when you load an executable file into your text editor?
20.  Why can't you test a program for run-time errors when it has compiler errors?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The Compilation Process
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 8:32 AM

You will soon learn how to program calculations and decision making in C++ . But before we look at the mechanics of
implementing computations in the next chapter, let's consider the planning process that precedes implementation.
You may have run across advertisements that encourage you to pay for a computerized service that matches you up with a love
partner. Think how this might work. You fill out a form and send it in. Others do the same. The data are processed by a
computer program. Is it reasonable to assume that the computer can perform the task of finding the best match for you?
Suppose your younger brother, not the computer, had all the forms on his desk. What instructions could you give him? You
can't say, “Find the best-looking person of the opposite sex who likes inline skating and browsing the Internet”. There is no
objective standard for good looks, and your brother's opinion (or that of a computer program analyzing the digitized photo)
will likely be different from yours. If you can't give written instructions for someone to solve the problem, there is no way the
computer can magically solve the problem. The computer can only do what you tell it to do. It just does it faster, without
getting bored or exhausted.
Now consider the following investment problem:
You put $10,000 into a bank account that earns 5 percent interest per year. How many years does it take for the account
balance to be double the original?
Could you solve this problem by hand? Sure, you could. You figure out the balance as follows:
You keep going until the balance is at least $20,000. Then the last number in the year column is the answer.
Of course, carrying out this computation is intensely boring to you or your younger brother. But computers are very good at
carrying out repetitive calculations quickly and flawlessly. What is important to the computer is a description of the steps for
finding the solution. Each step must be clear and unambiguous, requiring no guesswork. Here is such a description:
Start with a year value of 0 and a balance of $10,000
Repeat the following steps while the balance is less than $20,000
Add 1 to the year value
Multiply the balance value by 1.05 (a 5 percent increase)
Report the final year value as the answer
Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 8:33 AM

Of course, these steps are not yet in a language that a computer can understand, but you will soon learn how to formulate them
in C++ . This informal description is called pseudocode. What is important is that the method described is
•  Unambiguous
•  Executable
•  Terminating
A method is unambiguous when there are precise instructions for what to do at each step and where to go next. There is no
room for guesswork or creativity. A method is executable when each step can be carried out in practice. Had we asked to use
the actual interest rate that will be charged in years to come, and not a fixed rate of 5 percent per year, our method would not
have been executable, because there is no way for anyone to know what that interest rate will be. A method is terminating if it
will eventually come to an end. In our example, it requires a bit of thought to see that the method will not go on forever: With
every step, the balance goes up by at least $500, so eventually it must reach $20,000.
Pseudocode is an informal description of a sequence of
steps for solving a problem.
An algorithm is a recipe for finding a solution.
Claudia DeWald/iStockphoto.
A sequence of steps that is unambiguous, executable, and terminating is called an algorithm. We have found an algorithm to
solve our investment problem, and thus we can find the solution by programming a computer. The existence of an algorithm is
an essential prerequisite for programming a task. You need to first discover and describe an algorithm for the task that you
want to solve before you start programming (see Figure 9).
An algorithm for solving a problem is a sequence of
steps that is unambiguous, executable, and terminating.
Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 8:33 AM

  Figure 9   The Software Development Process
Self Check
21.  Suppose the interest rate was 20 percent. How long would it take for the investment to double?
22.  Suppose your cell phone carrier charges you $29.95 for up to 300 minutes of calls, and $0.45 for each
additional minute, plus 12.5 percent taxes and fees. Give an algorithm to compute the monthly charge from a
given number of minutes.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 8:33 AM

How To 1.1
HOW TO 1.1 Describing an Algorithm with Pseudocode
This is the first of many “How To” sections in this book that give you step-by-step procedures for carrying out
important tasks in developing computer programs.
Before you are ready to write a program in C++, you need to develop an algorithm—a method for arriving at a
solution for a particular problem. Describe the algorithm in pseudocode: a sequence of precise steps formulated in
English.
For example, consider this problem: You have the choice of buying two cars. One is more fuel efficient than the
other, but also more expensive. You know the price and fuel efficiency (in miles per gallon, mpg) of both cars. You
plan to keep the car for ten years. Assume a price of $4 per gallon of gas and usage of 15,000 miles per year. You
will pay cash for the car and not worry about financing costs. Which car is the better deal?
David H. Lewis/iStockphoto.
Step 1  Determine the inputs and outputs.
In our sample problem, we have these inputs:
•  purchase price1 and fuel efficiency1, the price and fuel efficiency (in mpg) of the first
car
•  purchase price2 and fuel efficiency2, the price and fuel efficiency of the second car
We simply want to know which car is the better buy. That is the desired output.
Step 2  Break down the problem into smaller tasks.
For each car, we need to know the total cost of driving it. Let's do this computation separately for
each car. Once we have the total cost for each car, we can decide which car is the better deal.
The total cost for each car is purchase price+operating cost .
We assume a constant usage and gas price for ten years, so the operating cost depends on the cost of
driving the car for one year.
The operating cost is 10 × annual fuel costys .
HOW TO 1.1 Describing an Algorithm with Pseudocode
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:36 AM

The annual fuel cost is price per gallon × annual fuel consumed .
The annual fuel consumed is annual miles driven / fuel efficiency . For example, if you drive
the car for 15,000 miles and the fuel efficiency is 15 miles/gallon, the car consumes 1,000 gallons.
Step 3  Describe each subtask in pseudocode.
In your description, arrange the steps so that any intermediate values are computed before they are
needed in other computations. For example, list the step
total cost = purchase price + operating cost
after you have computed operating cost .
Here is the algorithm for deciding which car to buy.
For each car, compute the total cost as follows
annual fuel consumed = annual miles driven / fuel efficiency
annual fuel cost = price per gallon × annual fuel consumed
operating cost = 10 × annual fuel cost
total cost = purchase price + operating cost
If total cost1 < total cost 2
Choose car 1
Else
Choose car 2
Step 4  Test your pseudocode by working a problem.
We will use these sample values:
Car 1: $25,000, 50 miles/gallon
Car 2: $20,000, 30 miles/gallon
Here is the calculation for the cost of the first car.
annual fuel consumed = annual miles driven / fuel efficiency = 15000 / 50 = 300
annual fuel cost = price per gallon × annual fuel consumed = 4 × 300 = 1200
operating cost = 10 × annual fuel cost = 10 × 1200 = 12000
total cost = purchase price + operating cost = 25000 + 12000 = 37000
Similarly, the total cost for the second car is $40,000. Therefore, the output of the algorithm is to
choose car 1.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
HOW TO 1.1 Describing an Algorithm with Pseudocode
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 8:36 AM

Worked Example 1.1
WORKED EXAMPLE 1.1 Writing an Algorithm for Tiling a Floor
Your task is to tile a rectangular bathroom floor with alternating black and white tiles measuring 4 × 4 inches. The floor dim
Step 1  Determine the inputs and outputs.
The inputs are the floor dimensions (length × width), measured in inches. The output is a tiled floor.
Step 2  Break down the problem into smaller tasks.
A natural subtask is to lay one row of tiles. If you can solve that task, then you can solve the problem by layin
opposite wall.
How do you lay a row? Start with a tile at one wall. If it is white, put a black one next to it. If it is black, put a
The row will contain width / 4 tiles.
Step 3  Describe each subtask in pseudocode.
In the pseudocode, you want to be more precise about exactly where the tiles are placed.
Place a black tile in the northwest corner
While the floor is not yet filled, repeat the following steps
Repeat this step width / 4 - 1 times
Place a tile east of the previously placed tile. If the previously placed tile was w
otherwise, a white one
Locate the tile at the beginning of the row that you just placed. If there is space t
Step 4  Test your pseudocode by working a problem.
Suppose you want to tile an area measuring 20 × 12 inches.
The first step is to place a black tile in the northwest corner.
Next, alternate four tiles until reaching the east wall. (width / 4 - 1 = 20 / 4 - 1 = 4 )
There is room to the south. Locate the tile at the beginning of the completed row. It is black. Place a white til
WORKED EXAMPLE 1.1 Writing an Algorithm for Tiling a Floor
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:37 AM

Complete the row.
There is still room to the south. Locate the tile at the beginning of the completed row. It is white. Place a blac
Complete the row.
Now the entire floor is filled, and you are done.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
WORKED EXAMPLE 1.1 Writing an Algorithm for Tiling a Floor
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 8:37 AM

1.  Computers execute very basic operations in rapid succession.
2.  A computer program is a sequence of instructions and decisions.
3.  Programming is the act of designing and implementing computer programs.
4.  The central processing unit (CPU) performs program control and data processing.
5.  Storage devices include random-access memory (RAM) and secondary storage.
6.  Computer programs are stored as machine instructions in a code that depends on the processor type.
7.  High-level programming languages are independent of the processor.
8.  C++ is a general-purpose language that is in widespread use for systems and embedded programming.
9.  Set aside some time to become familiar with the computer system and the C++ compiler that you will use for your
class work.
10.  Develop a strategy for keeping backup copies of your work before disaster strikes.
11.  Every C++ program contains 
 directives and a function called 
.
12.  Use 
 and the 
 operator to display values on the screen.
13.  Enclose text strings in quotation marks.
14.  Use  to add two numbers and  to multiply two numbers.
15.  Send 
 to 
 to end a line of displayed output.
16.  End each statement with a semicolon.
17.  A syntax error is a part of a program that does not conform to the rules of the programming language.
18.  Logic errors are errors in a program that executes without performing the intended action.
19.  The programmer is responsible for inspecting and testing the program to guard against logic errors.
20.  The compiler translates C++ programs into machine code.
21.  The linker combines machine code with library code into an executable program.
22.  Pseudocode is an informal description of a sequence of steps for solving a problem.
23.  An algorithm for solving a problem is a sequence of steps that is unambiguous, executable, and terminating.
Claudia DeWald/iStockphoto.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 8:38 AM

Exercise R1.1.    
Explain the difference between using a computer program and programming a computer.
Exercise R1.2.    
Which parts of a computer can store program code? Which can store user data?
Exercise R1.3.    
Which parts of a computer serve to give information to the user? Which parts take user input?
Exercise R1.4.    
A toaster is a single-function device, but a computer can be programmed to carry out different tasks. Is your cell phone a
single-function device, or is it a programmable computer? (Your answer will depend on your cell phone model.)
Exercise R1.5.    
Explain two benefits of using C++ over machine code.
Exercise R1.6.    
On your own computer or on your lab computer, find the exact location (folder or directory name) of
(a)  The sample file 
 (after you saved it in your development environment).
(b)  The standard header file 
.
Exercise R1.7.    
What does this program print?
Exercise R1.8.    
What does this program print?
Pay close attention to spaces.
Exercise R1.9.    
What does this program print?
Exercise R1.10.    
Review Exercise
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:39 AM

Write three versions of the 
 program that have different syntax errors. Write a version that has a logic error.
Exercise R1.11.    
How do you discover syntax errors? How do you discover logic errors?
Exercise R1.12.    
Write an algorithm to settle the following question: A bank account starts out with $10,000. Interest is compounded
monthly at 6 percent per year (0.5 percent per month). Every month, $500 is withdrawn to meet college expenses. After
how many years is the account depleted?
Exercise R1.13.    
Consider the question in Exercise R1.12.. Suppose the numbers ($10,000, 6 percent, $500) were user selectable. Are there
values for which the algorithm you developed would not terminate? If so, change the algorithm to make sure it always
terminates.
Exercise R1.14.    
In order to estimate the cost of painting a house, a painter needs to know the surface area of the exterior. Develop an
algorithm for computing that value. Your inputs are the width, length, and height of the house, the number of windows and
doors, and their dimensions. (Assume the windows and doors have a uniform size.)
Exercise R1.15.    
You want to decide whether you should drive your car to work or take the train. You know the one-way distance from your
home to your place of work, and the fuel efficiency of your car (in miles per gallon). You also know the one-way price of a
train ticket. You assume the cost of gas at $4 per gallon, and car maintenance at 5 cents per mile. Write an algorithm to
decide which commute is cheaper.
Exercise R1.16.    
You want to find out which fraction of your car use is for commuting to work, and which is for personal use. You know
the one-way distance from your home to your place of work. For a particular period, you recorded the beginning and
ending mileage on the odometer and the number of work days. Write an algorithm to settle this question.
Exercise R1.17.    
In the problem described in How To 1.1 on page 24, you made assumptions about the price of gas and the annual usage.
Ideally, you would like to know which car is the better deal without making these assumptions. Why can't a computer
program solve that problem?
Exercise R1.18.    
The value of π can be computed according to the following formula:
Write an algorithm to compute π. Because the formula is an infinite series and an algorithm must stop after a finite number
of steps, you should stop when you have the result determined to six significant digits.
Exercise R1.19.    
Suppose you put your younger brother in charge of backing up your work. Write a set of detailed instructions for carrying
out his task. Explain how often he should do it, and what files he needs to copy from which folder to which location.
Explain how he should verify that the backup was carried out correctly.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercise
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 8:39 AM

Exercise P1.1.    
Write a program that prints a greeting of your choice, perhaps in another language.
Exercise P1.2.    
Write a program that prints the message, “Hello, my name is Hal!” Then, on a new line, the program should print the
message “What would you like me to do?” Then it's the user's turn to type in an input. You haven't yet learned how to do
it—just use the following lines of code:
Finally, the program should ignore the user input and print the message “I am sorry, I cannot do that.”
This program uses the 
 data type. To access this feature, you must place the line
before the 
 function.
Here is a typical program run. The user input is printed in color.
When running the program, remember to hit the Enter key after typing the last word of the input line.
Exercise P1.3.    
Write a program that prints out a message “Hello, my name is Hal!” Then, on a new line, the program should print the
message “What is your name?” As in Exercise P1.2., just use the following lines of code:
Finally, the program should print the message “Hello, user name. I am glad to meet you!” To print the user name, simply
use
As in Exercise P1.2., you must place the line
before the 
 function.
Here is a typical program run. The user input is printed in color.
Exercise P1.4.    
Write a program that prints the sum of the first ten positive integers, 1 + 2 + ··· + 10.
Exercise P1.5.    
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 8:40 AM

Write a program that prints the product of the first ten positive integers, 1 × 2 × ··· × 10. (Remember to use * for
multiplication in C++.)
Exercise P1.6.    
Write a program that prints the balance of an account that earns 5 percent interest per year after the first, second, and third
year.
Exercise P1.7.    
Write a program that displays your name inside a box on the terminal screen, like this:
Do your best to approximate lines with characters such as | - +.
Exercise P1.8.    
Write a program that prints your name in large letters, such as
Exercise P1.9.    
Write a program that prints a face similar to (but different from) the following:
Exercise P1.10.    
Write a program that prints a house that looks exactly like the following:
Exercise P1.11.    
Write a program that prints an animal speaking a greeting, similar to (but different from) the following
Exercise P1.12.    
Write a program that prints three items, such as the names of your three best friends or favorite movies, on three separate
lines.
Exercise P1.13.    
Write a program that prints a poem of your choice. If you don't have a favorite poem, search the Internet for “Emily
Dickinson” or “e e cummings”.
Exercise P1.14.    
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 8:40 AM

Write a program that prints an imitation of a Piet Mondrian painting. (Search the Internet if you are not familiar with his
paintings.) Use character sequences such as @@@ or ::: to indicate different colors, and use - and | to form lines.
Exercise P1.15.    
Write a program that prints the United States flag, using * and = characters.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 8:40 AM

1.  A program that reads the data on the CD and sends output to the speakers and the screen.
2.  A CD player can do one thing—play music CDs. It cannot execute programs.
3.  Nothing.
4.  In secondary storage, typically a hard disk.
5.  The central processing unit.
6.  Software.
7.  No—a compiler is intended for programmers, to translate high-level programming instructions into machine code.
8.  Support for object-oriented programming.
9.  System software and embedded systems
10.  Programs are stored in files, and files are stored in folders or directories.
11.  You back up your files and folders.
12.  Replace 
 with your name, for example:
13.  There are no quotes around 
, 
.
14.  It prints 
, without a space or comma.
15.  42, without a space.
16.  
with a blank line between the two words.
17.  A compile-time error.
18.  Run the program and observe its behavior.
19.  A sequence of random characters, some funny-looking. Executable files contain machine instructions that are encoded as
binary numbers.
20.  When a program has compiler errors, no executable file is produced, and there is nothing to run.
21.  4 years:
0 10,000
1 12,000
2 14,400
3 17,280
4 20,736
22.  Is the number of minutes at most 300?
(a)  If so, the answer is $29.95 × 1.125 = $33.70.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 8:40 AM

(b)  If not,
1.  Compute the difference: (number of minutes) - 300.
2.  Multiply that difference by 0.45.
3.  Add $29.95.
4.  Multiply the total by 1.125. That is the answer.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 8:40 AM

Worked Example 1.1
•
Writing an Algorithm for Tiling a Floor
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Writing an Algorithm for Tiling a Floor
Your task is to tile a rectangular bathroom ﬂoor with alternating black and white tiles mea-
suring 4 × 4 inches. The ﬂoor dimensions, measured in inches, are multiples of 4.
Step 1
Determine the inputs and outputs.
The inputs are the ﬂoor dimensions (length × width), measured in inches. The output is a
tiled ﬂoor. 
Step 2
Break down the problem into smaller tasks.
A natural subtask is to lay one row of tiles. If you can solve that task, then you can solve the
problem by laying one row next to the other, starting from a wall, until you reach the oppo-
site wall. 
How do you lay a row? Start with a tile at one wall. If it is white, put a black one next to
it. If it is black, put a white one next to it. Keep going until you reach the opposite wall. The
row will contain width / 4 tiles. 
Step 3
Describe each subtask in pseudocode.
In the pseudocode, you want to be more precise about exactly where the tiles are placed. 
Place a black tile in the northwest corner.
While the floor is not yet filled, repeat the following steps:
Repeat this step width / 4 – 1 times: 
Place a tile east of the previously placed tile. If the previously placed tile was white, pick a black one;
otherwise, a white one.
Locate the tile at the beginning of the row that you just placed. If there is space to the south, place a tile 
of the opposite color below it.
Step 4
Test your pseudocode by working a problem.
Suppose you want to tile an area measuring 20 × 12 inches. 
The ﬁrst step is to place a black tile in the northwest corner.
WORKED EXAMPLE 1.1
1
20 inches
12

2
C++ for Everyone  •  CHAPTER 1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Next, alternate four tiles until reaching the east wall. (width / 4 – 1 = 20 / 4 – 1 = 4)
There is room to the south. Locate the tile at the beginning of the completed row. It is black.
Place a white tile south of it.
Complete the row.
There is still room to the south. Locate the tile at the beginning of the completed row. It is
white. Place a black tile south of it.
Complete the row.
Now the entire ﬂoor is ﬁlled, and you are done.
1
2
3
4
5
1
6
2
3
4
5
1
6
2
3
4
5
7
8
9
10
1
6
2
3
4
5
11
7
8
9
10
1
6
2
3
4
5
11 12 13 14 15
7
8
9
10

Chapter
   
    
    
Chapter Goals
•  To understand the properties and limitations of integer and floating-point numbers
•  To write arithmetic expressions and assignment statements in C++
•  To appreciate the importance of comments and good code layout
•  To be able to define and initialize variables and constants
•  To learn how to read user input and display program output
•  To use the standard C++ 
 type to define and manipulate character strings
•  To be able to write simple programs that read numbers and text, process the input, and display the results
In this and the four following chapters, you will learn the basic skills needed to write programs in C++. This
chapter teaches you how to manipulate numbers and character strings in C++. The goal of this chapter is to write
simple programs using these basic data types.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To understan ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:11 AM

When your program carries out computations, you will want to store values so that you can use them later. In a C++ program,
you use variables to store values. In this section, you will learn how to define and use variables.
To illustrate the use of variables, we will develop a program that solves the following problem. Soft drinks are sold in cans and
bottles. A store offers a six-pack of 12-ounce cans for the same price as a two-liter bottle. Which should you buy? (12 fluid
ounces equal approximately 0.355 liters.)
In our program, we will define variables for the number of cans per pack and for the volume of each can. Then we will
compute the volume of a six-pack in liters and print out the answer.
What contains more soda? A six-pack of 12-ounce cans or a two-liter bottle?
iStockphoto; travis manley/iStockphoto.
2.1.1 Variable Definitions
The following statement defines a variable named 
:
Like a variable in a computer program, a parking space has an identifier and a contents.
Javier Larrea/Age Fotostock America, Inc.
Defining Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 9:12 AM

A variable is a storage location in a computer program. Each variable has a name and holds a value.
A variable is a storage location with a name.
A variable is similar to a parking space in a parking garage. The parking space has an identifier (such as “J 053”), and it can
hold a vehicle. A variable has a name (such as 
), and it can hold a value (such as 6).
When defining a variable, you usually want to initialize it. That is, you specify the value that should be stored in the variable.
Consider again this variable definition:
= 6
The variable 
 is initialized with the value 6.
When defining a variable, you usually specify an intial
value.
Like a parking space that is restricted to a certain type of vehicle (such as a compact car, motorcycle, or electric vehicle), a
variable in C++ stores data of a specific type. C++ supports quite a few data types: numbers, text strings, files, dates, and many
others. You must specify the type whenever you define a variable (see Syntax 2.1).
When defining a variable, you also specify the type of
its values.
Each parking space is suitable for a particular type of vehicle, just as each variable holds a value of a particular type.
Graham Harrison/drr.net.
The 
 variable is an integer, a whole number without a fractional part. In C++, this type is called 
. (See
the next section for more information about number types in C++.)
Note that the type comes before the variable name:
Table 1 shows variations of variable definitions.
Table 1    Variable Definitions in C++
Variable Name
Comment
Defining Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 9:12 AM

Variable Name
Comment
  
Defines an integer variable and initializes it with 6.
  
The initial value need not be a constant. (Of course, 
 and 
must have been previously defined.)
 
Error: The type is missing. This statement is not a definition but an
assignment of a new value to an existing variable—see Section 2.2.
 
Error: You cannot initialize a number with a string.
  
Defines an integer variable without initializing it. This can be a cause for
errors—see Common Error 2.2 on page 40.
  
Defines two integer variables in a single statement. In this book, we will
Define each variable in a separate statement.
2.1.2 Number Type
In C++, there are several different types of numbers. You use the integer number type, called 
 in C++, to denote a whole
number without a fractional part. For example, there must be an integer number of cans in any pack of cans—you cannot have
a fraction of a can. When a fractional part is required (such as in the number 0.335), we use floating-point numbers. The
most commonly used type for floating-point numbers in C++ is called 
. (If you want to know the reason, read
Advanced Topic 2.1 on page 41.) Here is the definition of a floating-point variable:
Use the 
 type for numbers that cannot have a
fractional part.
When a value such as 6 or 0.335 occurs in a C++ program, it is called a number literal. Table 2 shows how to write integer
and floating-point literals in C++.
Use the 
 type for floating-point numbers.
Table 2    Number Literals in C++
Number
Type
Comment
  6
An integer has no fractional part.
  -6
Integers can be negative.
  0
Zero is an integer.
  0.5
A number with a fractional part has type 
.
  1.0
An integer with a fractional part .0 has type 
.
  1E6
A number in exponential notation: 1 × 106 or 1000000.
 
 
Numbers in exponential notation always have type 
.
  2.96E-2
Negative exponent: 2.96 × 10-2 = 2.96 / 100 = 0.0296
 100,000
 
Error: Do not use a comma as a decimal separator.
 3 1/2
 
Error: Do not use fractions; use decimal notation: 3.5
Defining Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 9:12 AM

2.1.3 Variable Names
When you define a variable, you should pick a name that explains its purpose. For example, it is better to use a descriptive
name, such as 
, than a terse name, such as 
.
In C++, there are a few simple rules for variable names:
1.  Variable names must start with a letter or the underscore (_) character, and the remaining characters must be letters,
numbers, or underscores.
2.  You cannot use other symbols such as $ or %. Spaces are not permitted inside names either. You can use an
underscore instead, as in 
.
3.  Variable names are case-sensitive, that is, 
 and 
 are different names. For that reason, it is a
good idea to use only lowercase letters in variable names.
4.  You cannot use reserved words such as 
 or 
 as names; these words are reserved exclusively for
their special C++ meanings. (See Appendix B.)
Table 3 shows examples of legal and illegal variable names in C++.
Table 3    Variable Names in C++
Variable Name
Comment
  
Variable names consist of letters, numbers, and the underscore character.
  
In mathematics, you use short variable names such as x or y. This is legal in C++, but not very
common, because it can make programs harder to understand (see Quality Tip 2.1 on page 41).
 
Caution: Variable names are case-sensitive. This variable name is different from 
.
 
Error: Variable names cannot start with a number.
 
Error: Variable names cannot contain spaces.
 
Error: You cannot use a reserved word as a variable name.
 
Error: You cannot use symbols such as / or.
2.1.4 Comments
As your programs get more complex, you should add comments, explanations for human readers of your code. For example,
here is a comment that explains the value used in a variable initialization:
Liters in a 12-ounce can
This comment explains the significance of the value 0.355 to a human reader. The compiler does not process comments at all.
It ignores everything from a // delimiter to the end of the line.
Use comments to add explanations for humans who
read your code. The complier ignores comments.
You use the // syntax for short comments. If you have a longer comment, enclose it between /* and */ delimiters. The compiler
ignores these delimiters and everything in between.
Here is a typical example, a long comment at the beginning of a program, to explain the program's purpose:
This program computes the volume (in liters) of a six-pack of
soda cans.
We are now ready to finish our program. The program consists of the two variable definitions that we just discussed, followed
Defining Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 9:12 AM

by a statement to print their product. Since the result is larger than 2, we know that the six-pack contains more soda than the
two-liter bottle.
ch02/volume1.cpp
This program computes the volume (in liters) of a six-pack of
soda cans.
Liters in a 12-ounce can
Program Run
Self Check
1.  Define a variable suitable for holding the number of bottles in a case. 
2.  What is wrong with the following variable definition? 
3.  Define and initialize two variables, 
 and 
, to contain the unit price of a single bottle and
the number of bottles purchased. Use reasonable initial values. 
4.  Use the variables defined in Self Check 3. to display the total purchase price. 
5.  Some drinks are sold in four-packs instead of six-packs. How would you change the 
 program to
compute the total volume? 
6.  What is wrong with this comment? 
7.  Suppose the type of the 
 variable in the 
 was changed from 
 to 
.
What would be the effect on the program? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Defining Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 9:12 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 2.1 Variable Definition
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:12 AM

Common Error 2.1
COMMON ERROR 2.1 Using Undefined Variables
You must define a variable before you use it for the first time. For example, the following sequence of statements
would not be legal:
In your program, the statements are compiled in order. When the compiler reaches the first statement, it does not
know that 
 will be defined in the next line, and it reports an error.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 2.1 Using Undefined Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:12 AM

Common Error 2.2
COMMON ERROR 2.2 Using Uninitialized Variables
If you define a variable but leave it uninitialized, then your program can act unpredictably. To understand why,
consider what happens when you define a variable. Just enough space is set aside in memory to hold values of the
type you specify. For example, with the definition
a block of memory big enough to hold integers is reserved. There is already some value in that memory. After all,
you don't get freshly minted transistors—just an area of memory that has previously been used, filled with flotsam
left over from prior computations. (In this regard, a variable differs from a parking space. A parking space can be
empty, containing no vehicle. But a variable always holds some value.)
If you use the variable without initializing it, then that prior value will be used, yielding unpredictable results. For
example, consider the program segment
Forgot to initialize
Result is unpredictable
There is no way of knowing what value will be computed. If you are unlucky, a plausible value will happen to
appear when you run the program at home, and an entirely different result will occur when the program is graded.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 2.2 Using Uninitialized Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:13 AM

Quality Tip 2.1
QUALITY TIP 2.1 Choose Descriptive Variable Names
We could have saved ourselves a lot of typing by using shorter variable names, as in
Compare this definition with the one that we actually used, though. Which one is easier to read? There is no
comparison. Just reading 
 is a lot less trouble than reading cv and then figuring out it must mean “can
volume”.
In practical programming, this is particularly important when programs are written by more than one person. It may
be obvious to you that 
 stands for can volume and not current velocity, but will it be obvious to the person who
needs to update your code years later? For that matter, will you remember yourself what 
 means when you look
at the code three months from now?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 2.1 Choose Descriptive Variable Names
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:13 AM

Advanced Topic 2.1
ADVANCED TOPIC 2.1 Numeric Types in C++
In addition to the 
 and 
 types, C++ has several other numeric types.
C++ has two floating-point types. The 
 type uses half the storage of the 
 type that we use in this
book, but it can only store 6—7 digits. Many years ago, when computers had far less memory than they have today,
 was the standard type for floating-point computations, and programmers would indulge in the luxury of
“double precision” only when they needed the additional digits. Today, the 
 type is rarely used.
By the way, these numbers are called “floating-point” because of their internal representation in the computer.
Consider numbers 29600, 2.96, and 0.0296. They can be represented in a very similar way: namely, as a sequence
of the significant digits—296—and an indication of the position of the decimal point. When the values are
multiplied or divided by 10, only the position of the decimal point changes; it “floats”. Computers use base 2, not
base 10, but the principle is the same.
In addition to the 
 type, C++ has integer types 
, 
, and 
. For each integer type, there is
an 
 equivalent. For example, the 
 type typically has a range from -32,768 to 32,767, whereas
 has a range from 0 to 65,535. These strange-looking limits are the result of the use of binary
numbers in computers. A 
 value uses 16 binary digits, which can encode 216 = 65,536 values. Keep in mind
that the ranges for integer types are not standardized, and they differ among compilers. The following table contains
typical values.
Table 4    Number Types
Type
Typical Range
Typical
Size
-2,147,483,648 … 2,147,483,647 (about 2 billion)
4 bytes
0 … 4,294,967,295
4 bytes
-32,768 … 32,767
2 bytes
0 … 65,535
2 bytes
-9,223,372,036,854,775,808 … 9,223,372,036,854,775,807
8 bytes
The double-precision floating-point type, with a range of about ±10308
and about 15 signi.cant decimal digits
8 bytes
The single-precision floating-point type, with a range of about ±1038
and about 7 significant decimal digits
4 bytes
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 2.1 Numeric Types in C++
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:13 AM

Advanced Topic 2.2
ADVANCED TOPIC 2.2 Numeric Ranges and Precisions
Because numbers are represented in the computer with a limited number of digits, they cannot represent arbitrary
integer or floating—point numbers.
The 
 type has a limited range: On most platforms, it can represent numbers up to a little more than two billion.
For many applications, this is not a problem, but you cannot use an int to represent the world population.
If a computation yields a value that is outside the 
 range, the result overflows. No error is displayed. Instead, the
result is truncated, yielding a useless value. For example,
displays -1294967296.
In situations such as this, you can switch to 
 values. However, read Common Error 2.6 on page 59 for
more information about a related issue: roundoff errors.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 2.2 Numeric Ranges and Precisions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:13 AM

The contents of a variable can vary over time. In the following three sections, you will see how to change the value of a
variable.
2.2.1 The Assignment Statement
You use the assignment statement to place a new value into a variable. Here is an example:
The left-hand side of an assignment statement consists of a variable. The right-hand side is an expression that has a value. That
value is stored in the variable, overwriting its previous contents.
An assignment statement stores a new value in a
variable, replacing the previously stored value.
There is an important difference between a variable definition and an assignment statement:
Variable definition
Assignment statement
The first statement is the definition of 
. It is an instruction to create a new variable of type 
, to give it
the name 
, and to initialize it with 6. The second statement is an assignment statement: an instruction to
replace the contents of the existing variable 
 with another value.
The assignment operator = does not denote
mathematical equality.
The = sign doesn't mean that the left-hand side is equal to the right-hand side but that the right-hand side value is copied into
the left-hand side variable. You should not confuse this assignment operation with the = used in algebra to denote equality.
The assignment operator is an instruction to do something, namely place a value into a variable. The mathematical equality
states the fact that two values are equal. For example, in C++, it is perfectly legal to write
It means to look up the value stored in the variable 
, add 1 to it, and store the result into 
. (See Figure 1.) The
net effect of executing this statement is to increment 
 by 1. For example, if 
 was 3 before execution of the
statement, it is set to 4 afterwards. Of course, in mathematics it would make no sense to write that counter = counter + 1; no
value can equal itself plus 1.
Modifying Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 6
2/1/2010 9:13 AM

  Figure 1   Incrementing a Variable
2.2.2 Increment and Decrement
Changing a variable by adding or subtracting 1 is so common that there is a special shorthand for it, namely
The 
 increment operator gave the C++ programming language its name. C++ is the incremental improvement of the C
language.
The 
 operator adds 1 to a variable; the -- operator
subtracts 1.
2.2.3 Input
In this section, you will see how to place user input into a variable. Consider for example the 
 program on page
39. Rather than assuming that the price for the two-liter bottle and the six-pack of cans are identical, we can ask the program
user for the prices.
When a program asks for user input, it should first print a message that tells the user which input is expected. Such a message
is called a prompt.
Display prompt
Do not add an 
 after the prompt. You want the input to appear after the colon, not on the following line.
Use the  operator to read a value and place it in a
variable.
Next, the program issues a command to read the input. The 
 object reads input from the console window. You use the 
operator to place an input value into a variable, like this:
When the program executes the input statement, it waits for the user to provide input. The user also needs to hit the enter key
Modifying Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 6
2/1/2010 9:13 AM

so that the program accepts the input. After the user supplies the input, the number is placed into the 
variable, and the
program continues.
You can read more than one value in a single input statement:
The user can supply both inputs on the same line:
2 6
Alternatively, the user can hit the Enter key after each input:
2
6
2.2.4 Constants
When a variable is defined with the reserved word 
, its value can never change. Constants are commonly written using
capital letters to distinguish them visually from regular variables:
It is good programming style to use named constants in your program to explain the meanings of numeric values. For example,
compare the statements
and
A programmer reading the first statement may not understand the significance of the number 2. The second statement, with a
named constant, makes the computation much clearer.
You cannot change the value of a variable that is
definied 
.
The following program demonstrates the use of assignment statements, input operations, and constants. The program computes
the total volume of a number of bottles and cans. First, we ask for the number of bottles and set 
 to the volume
of the bottles. Then we ask for the number of cans and add their volume to the total, using the following statement:
It means, “Compute the volume from the cans (
), add it to the value of 
, and place the result
again into the variable 
” (see Figure 2).
Modifying Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 6
2/1/2010 9:13 AM

  Figure 2   Assignment
ch02/volume2.cpp
Read number of bottles
Display prompt
Start the computation of the total volume
Read number of cans
Modifying Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 6
2/1/2010 9:13 AM

Update the total volume
Program Run
2
6
Table 5    Modifying a Variable
Statements
Contents of
counter
Comments
  
1
The previous content of the variable has been replaced.
  
2
Adds 1 to counter. Note that = is not mathematical
equality.
  
3
++ is a shorthand for adding 1 to a variable.
  
2
-- is a shorthand for subtracting 1.
  
The input value
Waits for the user to enter a value, and storesthe value in
the variable.
 
 
Error: This is not an assignment but an attempt to define a
second variable named 
.
Self Check
8.  What is the value of 
 after this sequence of statements? 
9.  What is wrong with the following sequence of statements? 
10.  How would you explain assignment using the parking space analogy? 
11.  What is wrong with the following statement sequence? 
Modifying Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 6
2/1/2010 9:13 AM

12.  What is problematic about the following statement sequence? 
13.  Why can the variables 
 and 
 not be declared as 
? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Modifying Variables
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 6
2/1/2010 9:13 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 2.2 Assignment
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:14 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 2.3 Input Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:16 AM

Advanced Topic 2.3
ADVANCED TOPIC 2.3 Combining Assignment and Arithmetic
In C++, you can combine arithmetic and assignment. For example, the instruction
is a shortcut for
Similarly,
is another way of writing
Many programmers find this a convenient shortcut. If you like it, go ahead and use it in your own code. For
simplicity, we won't use it in this book, though.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 2.3 Combining Assignment and Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:16 AM

Quality Tip 2.2
QUALITY TIP 2.2 Do Not Use Magic Numbers
A magic number is a numeric constant that appears in your code without explanation. For example,
Why 2? Are bottles twice as voluminous as cans? No, the reason is that every bottle contains 2 liters. Use a named
constant to make the code self-documenting:
There is another reason for using named constants. Suppose circumstances change, and the bottle volume is now
1.5 liters. If you used a named constant, you make a single change, and you are done. Otherwise, you have to look
at every value of 2 in your program and ponder whether it meant a bottle volume, or something else. In a program
that is more than a few pages long, that is incredibly tedious and error—prone.
Even the most reasonable cosmic constant is going to change one day. You think there are seven days per week?
Your customers on Mars are going to be pretty unhappy about your silly prejudice. Make a constant
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 2.2 Do Not Use Magic Numbers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:17 AM

In the following sections, you will learn how to carry out arithmetic calculations in C++.
2.3.1 Arithmetic Operators
C++ supports the same four basic arithmetic operations as a calculator—addition, subtraction, multiplication, and
division—but it uses different symbols for multiplication and division.
You must write 
 to denote multiplication. Unlike in mathematics, you can not write 
, 
 or 
. Similarly,
division is always indicated with a /, never a ÷ or a fraction bar.
Yunus Arakon/iStockphoto.
For example, 
 becomes 
.
Parentheses are used just as in algebra: to indicate in which order the subexpressions should be computed. For example, in the
expression 
, the sum 
 is computed first, and then the sum is divided by 2. In contrast, in the expression
only  is divided by 2, and then the sum of  and 
 is formed. Just as in regular algebraic notation, multiplication and
division have a higher precedence than addition and subtraction. For example, in the expression 
, the  is carried
out first, even though the  operation occurs further to the left.
2.3.2 Integer Division and Remainder
Division works as you would expect, as long as at least one of the numbers involved is a floating-point number. That is,
all yield 1.75. However, if both numbers are integers, then the result of the division is always an integer, with the remainder
discarded. That is,
evaluates to 1 because 7 divided by 4 is 1 with a remainder of 3 (which is discarded). This can be a source of subtle
programming errors—see Common Error 2.3 on page 56.
If both arguments of  are integers, the remainder is
discarded.
The  operator computes the remainder of an integer
division.
Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 7
2/1/2010 9:17 AM

If you are interested in the remainder only, use the  operator:
is 3, the remainder of the integer division of 7 by 4. The  symbol has no analog in algebra. It was chosen because it looks
similar to /, and the remainder operation is related to division. The operator is called modulus.
Integer division and the  operator yield the dollar and cent values of a piggybank full of pennies.
Michael Flippo/iStockphoto.
(Some people call it modulo or mod.) It has no relationship with the percent operation that you find on some calculators.
Here is a typical use for the integer  and  operations. Suppose you have an amount of pennies in a piggybank:
You want to determine the value in dollars and cents. You obtain the dollars through an integer division by 100.
Sets dollars to 17
The integer division discards the remainder. To obtain the remainder, use the  operator:
Sets cents to 29
Table 6    Arithmetic Expressions
Mathematical
Expression
C++ Expression
Comments
The parentheses are required; 
 computes 
.
Parentheses are not required; operators with the same
precedence are evaluated left to right.
Remember to add 
 to the top of your
program.
 is simpler than 
.
If i, j, and k are integers, using a denominator of 3.0 forces
floating-point division.
2.3.3 Powers and Roots
In C++, there are no symbols for powers and roots. To compute them, you must call functions. To take the square root of a
number, you use the 
 function. For example, 
 is written as 
. To compute xn, you write 
.
Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 7
2/1/2010 9:17 AM

The C++ library defines many mathematical functions
such as 
 (square root) and 
 raising to a power).
To use the 
 and 
 functions, you must place the line 
 at the top of your program file. The header
file 
 is a standard C++ header that is available with all C++ systems, as is 
.
As you can see, the effect of the , 
, and 
 operations is to flatten out mathematical terms. In algebra, you use fractions,
exponents, and roots to arrange expressions in a compact two-dimensional form. In C++, you have to write all expressions in a
linear arrangement. For example, the mathematical expression
becomes
Figure 3 shows how to analyze such an expression.
  Figure 3   Analyzing an Expression
Table 7 shows additional functions that are declared in the 
 header. Inputs and outputs are floating-point numbers.
Table 7    Other Mathematical Functions
Function
Description
sine of x (x in radians)
cosine of x
tangent of x
(decimal log) log10 (x), x > 0
absolute value |x|
2.3.4 Converting Floating-Point Numbers to Integers
When a floating-point value is assigned to an integer variable, the fractional part is discarded:
Sets dollars to 2
Discarding the fractional part is not always what you want. Often, you want to round to the nearest integer. To round a
positive floating-point value to thenearest integer, add 0.5 and then convert to an integer:
Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 7
2/1/2010 9:17 AM

Rounds to the nearest integer
In our example, adding 0.5 turns all values above 2.5 into values above 3. In particular, 2.55 is turned into 3.05, which is then
truncated to 3. (For a negative floating-point value, you subtract 0.5.)
Because truncation is a potential cause for errors, your compiler may issue a warning that assigning a floating-point value to
an integer variable is unsafe. See Advanced Topic 2.4 on page 60 on how to avoid this warning.
2.3.5 Formatted Output
When you print the result of a computation, you often want some control over its appearance. For example, when you print an
amount in dollars and cents, you usually want it to be rounded to two significant digits. That is, you want the output to look
like
instead of
You send manipulators to 
 to specify how values
should be formatted.
The following command instructs 
 to use two digits after the decimal point for all floating-point numbers:
This command does not produce any output; it just manipulates 
 so that it will change the output format. The values
 and 
 are called manipulators. We will discuss manipulators in detail in Chapter 8.
You use manipulators to line up your output in neat columns.
Rich Koele/iStockphoto.
For now, just remember to include the statement given above whenever you want currency values displayed neatly.
To use manipulators, you must include the 
 header in your program:
You can combine the manipulators and the values to be displayed into a single statement.
Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 7
2/1/2010 9:17 AM

There is another manipulator that is sometimes handy. When you display several rows of data, you usually want the columns to
line up.
You use the 
 manipulator to set the width of the next output field. The width is the total number of characters used for
showing the value, including digits, the decimal point, and spaces. Controlling the width is important when you want columns
of numbers to line up.
Table 8    Formatting Output
Output Statement
Output
Comment
12.345678;
By default, a number is printed with 6 significant digits.
Use the 
 and 
 manipulators to control
the number of digits after the decimal point.
Four spaces are printed before the number, for a total width of
6 characters.
If the width not sufficient, it is ignored.
The width only refers to the next item. Here, the : is preceded by
five spaces.
For example, if you want a number to be printed in a column that is eight characters wide, you use
This command prints the value 
 in a field of width 8, for example
(where each 
 represents a space).
There is a notable difference between the 
 and 
 manipulators. Once you set the precision, that value is
used for all subsequent floating-point numbers. But the width affects only the next value. Subsequent values are formatted
without any padding.
Our next example program will prompt for the price of a six-pack and then print out the price per liter. The program puts to
work what you just learned about arithmetic and formatting.
ch02/volume3.cpp
Read price per pack
Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 7
2/1/2010 9:17 AM

Compute pack volume
Compute and print price per liter
Program Run
2.60
Self Check
14.  A bank account earns interest of p percent per year. In C++, how do you compute the interest earned in one
year? Assume variables  and 
 of type double have already been defined. 
15.  In C++, how do you compute the side length of a square whose area is stored in the variable 
?
16.  The volume of a sphere is given by 
.
If the radius is given by a variable 
 of type 
, write a C++ expression for the volume. You may
assume that π is defined by a constant 
. 
17.  What is the value of 
 and 
? 
18.  Suppose a punch recipe calls for a given amount of orange soda, measured in ounces. 
We can compute the number of 12-ounce cans needed, assuming that the amountdoes not evenly divide into
12:
Use the % operator to determine how many ounces will be left over. For example, if 32 ounces are required,
we need 3 cans and have 4 ounces left over.
Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 7
2/1/2010 9:17 AM

Joe McDaniel/iStockphoto.
19.  What is the output of the following statement sequence? 
20.  Using the 
 manipulator, improve the output statement 
so that the output looks like this:
The numbers to the right should line up. (You may assume that the numbers have at most 8 digits.)
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Arithmetic
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 7
2/1/2010 9:17 AM

Common Error 2.3
COMMON ERROR 2.3 Unintended Integer Division
It is unfortunate that C++ uses the same symbol, namely , for both integer and floating-point division. These are
really quite different operations. It is a common error to use integer division by accident. Consider this segment
that computes the average of three integers.
Error
What could be wrong with that? Of course, the average of 
, 
, and 
 is
Here, however, the / does not mean division in the mathematical sense. It denotesinteger division because both
 and  are integers. For example, if the scores add up to 14, the average is computed to be 4, the
result of the integerdivision of 14 by 3. That integer 4 is then moved into the floating-point variable 
.
The remedy is to make the numerator or denominator into a floating-point number:
or
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 2.3 Unintended Integer Division
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:17 AM

Common Error 2.4
COMMON ERROR 2.4 Unbalanced Parentheses
Consider the expression
What is wrong with it? Count the parentheses. There are three ( and two ). The parentheses are unbalanced. This
kind of typing error is very common with complicated expressions. Now consider this expression.
This expression has three  and three , but it still is not correct. In the middle of the expression,
)
↑
there are only two  but three , which is an error. In the middle of an expression, the count of  must be greater
than or equal to the count of , and at the end of the expression the two counts must be the same.
Here is a simple trick to make the counting easier without using pencil and paper. It is difficult for the brain to
keep two counts simultaneously. Keep only one count when scanning the expression. Start with 1 at the first
opening parenthesis, add 1 whenever you see an opening parenthesis, and subtract one whenever you see a closing
parenthesis. Say the numbers aloud as you scan the expression. If the count ever drops below zero, or is not zero at
the end, the parentheses are unbalanced. For example, when scanning the previous expression, you would mutter
1
2
1  0 - 1
and you would find the error.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 2.4 Unbalanced Parentheses
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:18 AM

Common Error 2.5
COMMON ERROR 2.5 Forgetting Header Files
Every program that carries out input or output needs the 
 header. If you use mathematical functions such
as 
, you need to include 
. If you forget to include the appropriate header file, the compiler will not know
symbols such as 
 or 
. If the compiler complains about an undefined function or symbol, check your header
files.
Sometimes you may not know which header file to include. Suppose you want to compute the absolute value of an
integer using the 
 function. As it happens, 
 is not defined in 
 but in 
. How can you find the
correct header file? You need to locate the documentation of the 
 function, preferably using the online help of
your development environment or a reference site on the Internet such as http://www.cplusplus.com (see Figure 4).
The documentation includes a short description of the function and the name of the header file that you must
include.
  Figure 4   Online Documentation
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 2.5 Forgetting Header Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:18 AM

Common Error 2.6
COMMON ERROR 2.6 Roundoff Errors
Roundoff errors are a fact of life when calculating with floating-point numbers. You probably have encountered
that phenomenon yourself with manual calculations. If you calculate 1/3 to two decimal places, you get 0.33.
Multiplying again by 3, you obtain 0.99, not 1.00.
In the processor hardware, numbers are represented in the binary number system, not in decimal. You still get
roundoff errors when binary digits are lost. They just may crop up at different places than you might expect. Here is
an example.
Should be
Prints
Of course, one hundred times 4.35 is 435, but the program prints 434.
Most computers represent numbers in the binary system. In the binary system, there is no exact representation for
4.35, just as there is no exact representation for 1/3 in the decimal system. The representation used by the computer
is just a little less than 4.35, so 100 times that value is just a little less than 435. When a floating-point value is
converted to an integer, the entire fractional part, which is almost 1, is thrown away, and the integer 434 is stored
in cents. The remedy is to add 0.5 in order to round to the nearest integer:
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 2.6 Roundoff Errors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:18 AM

Advanced Topic 2.4
ADVANCED TOPIC 2.4 Casts
Occasionally, you need to store a value into a variable of a different type. Whenever there is the risk of information
loss, the compiler issues a warning. For example, if you store a 
 value into an 
 variable, you can lose
information in two ways:
•  The fractional part is lost.
•  The magnitude may be too large.
For example,
NO
is not likely to work, because 10100 is larger than the largest representable integer.
Nevertheless, sometimes you do want to convert a floating-point value into an integer value. If you are prepared to
lose the fractional part and you know that this particular floating-point number is not larger than the largest
possible integer, then you can turn off the warning by using a cast. A cast is a conversion from one type (such as
) to another type (such as 
) that is not safe in general, but that you know to be safe in a particular
circumstance. You express a cast in C++ as follows:
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 2.4 Casts
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:18 AM

Quality Tip 2.3
QUALITY TIP 2.3 Spaces in Expressions
It is easier to read
than
Simply put spaces around all operators 
. However, don't put a space after a unary minus: a - used
to negate a single quantity, such as 
. That way, it can be easily distinguished from a binary minus, as in 
.
It is customary not to put a space after a function name. That is, write 
 and not 
.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 2.3 Spaces in Expressions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:18 AM

Random Fact 2.1
RANDOM FACT 2.1 The Pentium Floating-Point Bug
In 1994, Intel Corporation released what was then its most powerful processor, the Pentium. Unlike previous
generations of its processors, it had a very fast floating-point unit. Intel's goal was to compete aggressively with the
makers of higher-end processors for engineering workstations. The Pentium was a huge success immediately.
In the summer of 1994, Dr. Thomas Nicely of Lynchburg College in Virginia ran an extensive set of computations
to analyze the sums of reciprocals of certain sequences of prime numbers. The results were not always what his
theory predicted, even after he took into account the inevitable roundoff errors. Then Dr. Nicely noted that the
same program did produce the correct results when running it on the slower 486 processor that preceded the
Pentium in Intel's lineup. This should not have happened. The optimal roundoff behavior of floating-point
calculations has been standardized by the Institute for Electrical and Electronic Engineers (IEEE) and Intel claimed
to adhere to the IEEE standard in both the 486 and the Pentium processors. Upon further checking, Dr. Nicely
discovered that indeed there was a very small set of numbers for which the product of two numbers was computed
differently on the two processors. For example,
is mathematically equal to 0, and it did compute as 0 on a 486 processor. On his Pentium processor the result was
256.
As it turned out, Intel had independently discovered the bug in its testing and had started to produce chips that fixed
it. The bug was caused by an error in a table that was used to speed up the floating-point multiplication algorithm
of the processor. Intel determined that the problem was exceedingly rare. They claimed that under normal use, a
typical consumer would only notice the problem once every 27,000 years. Unfortunately for Intel, Dr. Nicely had
not been a normal user.
Now Intel had a real problem on its hands. It figured that the cost of replacing all Pentium processors that it had
already sold would cost a great deal of money. Intel already had more orders for the chip than it could produce, and
it would be particularly galling to have to give out the scarce chips as free replacements instead of selling them.
Intel's management decided to punt on the issue and initially offered to replace the processors only for those
customers who could prove that their work required absolute precision in mathematical calculations. Naturally,
that did not go over well with the hundreds of thousands of customers who had paid retail prices of $700 and more
for a Pentium chip and did not want to live with the nagging feeling that perhaps, one day, their income tax
program would produce a faulty return.
Ultimately, Intel caved in to public demand and replaced all defective chips, at a cost of about 475 million dollars.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 2.1 The Pentium Floating-Point Bug
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:18 AM

How To 2.1
HOW TO 2.1 Carrying Out Computations
Many programming problems require that you carry out arithmetic computations. This How To shows you how to
turn a problem statement into pseudocode and, ultimately, a C++ program.
Step 1  Understand the problem: What are the inputs? What are the desired outputs?
For example, suppose you are asked to write a program that simulates a vending machine. A
customer selects an item for purchase and inserts a bill into the vending machine. The vending
machine dispenses the purchased item and gives change. We will assume that all item prices are
multiples of 25 cents, and the machine gives all change in dollar coins and quarters. Your task is to
compute how many coins of each type to return.
A vending machine takes bills and gives change in coins.
Photos.com/Jupiter Images.
In this problem, there are two inputs:
•  The denomination of the bill that the customer inserts
•  The price of the purchased item
There are two desired outputs:
•  The number of dollar coins that the machine returns
•  The number of quarters that the machine returns
Step 2  Work out examples by hand.
This is a very important step. If you can't compute a couple of solutions by hand, it's unlikely that
you'll be able to write a program that automates the computation.
Let's assume that a customer purchased an item that cost $2.25 and inserted a $5 bill. The customer
is due $2.75, or two dollar coins and three quarters.
That is easy for you to see, but how can a C++ program come to the same conclusion? The key is to
work in pennies, not dollars. The amount due the customer is 275 pennies. Dividing by 100 yields 2,
the number of dollars. Dividing the remainder (75) by 25 yields 3, the number of quarters.
HOW TO 2.1 Carrying Out Computations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:19 AM

Step 3  Write pseudocode for computing the answers.
In the previous step, you worked out a specific instance of the problem. You now need to come up
with a method that works in general.
Given an arbitrary item price and payment, how can you compute the coins due? First, compute the
amount due in pennies:
amount due = 100 × bill value - item price in pennies
To get the dollars, divide by 100 and discard the remainder:
dollar coins = amount due / 100 (without remainder)
The remaining amount due can be computed in two ways. If you are familiar with the modulus
operator, you can simply compute
amount due = amount due % 100
Alternatively, subtract the penny value of the dollar coins from the amount due:
amount due = amount due - 100 × dollar coins
To get the quarters due, divide by 25:
quarters = amount due / 25
Step 4  Define the variables and constants that you need, and specify their types.
Here, we have five variables:
•  
•  
•  
•  
•  
Should we introduce constants to explain 100 and 25 as 
 and
 Doing so will make it easier to convert the program to international
markets, so we will take this step.
It is very important that 
 and 
 are of type 
 because the
computation of 
 uses integer division. Similarly, the other variables are integers.
Step 5  Turn the pseudocode into C++ statements.
If you did a thorough job with the pseudocode, this step should be easy. Of course, you have to
know how to express mathematical operations (such as powers or integer division) in C++.
Step 6  Provide input and output.
Before starting the computation, we prompt the user for the bill value and item price:
When the computation is finished, we display the result. For extra credit, we use the 
manipulator to make sure that the output lines up neatly.
HOW TO 2.1 Carrying Out Computations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:19 AM

Step 7  Include the required headers and provide a 
 function.
We need the 
 header for all input and output. Because we use the 
 manipulator, we
also require 
. This program does not use any special mathematical functions. Therefore,
we do not include the 
 header.
In the 
 function, you need to define constants and variables (Step 4), carry out computations
(Step 5), and provide input and output (Step 6). Clearly, you will want to first get the input, then do
the computations, and finally show the output. Define the constants at the beginning of the function,
and define each variable just before it is needed.
Here is the complete program, 
:
Program Run
5
225
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
HOW TO 2.1 Carrying Out Computations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 9:19 AM

Worked Example 2.1
WORKED EXAMPLE 2.1 Computing the Cost of Stamps
You are asked to simulate a postage stamp vending machine. A customer inserts dollar bills into the vending machine
and then pushes a “purchase” button. The vending machine gives out as many first-class stamps as the customer paid
for, and returns the change in penny (one-cent) stamps. A first-class stamp cost 42 cents at the time this book was
written.
Step 1  Understand the problem: What are the inputs? What are the desired outputs?
In this problem, there is one input:
•  The amount of money the customer inserts
There are two desired outputs:
•  The number of first-class stamps the machine returns
•  The number of penny stamps the machine returns
Step 2  Work out examples by hand.
Let's assume that a first-class stamp costs 42 cents and the customer inserts $1.00. That's enough for two
stamps (84 cents) but not enough for three stamps ($1.26). Therefore, the machine returns two first-class
stamps and 16 penny stamps.
Step 3  Write pseudocode for computing the answers.
Given an amount of money and the price of a first-class stamp, how can you compute how many
first-class stamps can be purchased with the money? Clearly, the answer is related to the quotient
For example, suppose the customer paid $1.00. Use a pocket calculator to compute the quotient:
$1.00/$0.42 ≈ 2.38.
How do you get “2 stamps” out of 2.38? It's the quotient without the remainder. In C++, this is easy to
compute if both arguments are integers. Therefore, let's switch our computation to pennies. Then we
have
number of first-class stamps = 100 / 42 (integer division, without remainder)
What if the user inputs two dollar? Then the numerator becomes 200. What if the price of a stamp goes
up? A more general equation is
number of first-class stamps = 100 × dollars / price of first-class stamps in cents
How about the change? Here is one way of computing it. When the customer gets the stamps, the change
is the customer payment, reduced by the value of the stamps purchased. In our example, the change is 16
cents—the difference between 100 and 2 · 42. Here is the general formula:
change = 100 × dollars - number of first-class stamps × price of first-class stamp
Step 4  Define the variables and constants that you need, and specify their types.
Here, we have three variables:
•  
WORKED EXAMPLE 2.1 Computing the Cost of Stamps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:19 AM

•  
•  
There is one constant, 
.
The variables 
 and 
 must be of type 
 since the computation of
 uses integer division. The remaining variables are also integers, counting the
number of first-class and penny stamps. Thus, we have
Price in pennies
Filled through input statement
Step 5  Turn the pseudocode into C++ statements.
Our computation depends on the number of dollars that the user provides. Translating the math into C++
yields the following statements:
Step 6  Provide input and output.
Before starting the computation, we prompt the user for the number of dollars:
When the computation is finished, we display the result.
Step 7  Include the required headers and provide a 
 function.
We need the 
 header for all input and output. Because we use the 
 manipulator, we also
require 
.
Here is the complete program, 
:
Price in pennies
Program Run
WORKED EXAMPLE 2.1 Computing the Cost of Stamps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:19 AM

4
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
WORKED EXAMPLE 2.1 Computing the Cost of Stamps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 9:19 AM

Many programs process text, not numbers. Text consists of characters: letters, numbers, punctuation, spaces, and so on. A
string is a sequence of characters. For example, the string 
 is a sequence of five characters.
Strings are sequences of characters.
2.4.1 The string Type
You can define variables that hold strings.
The 
 type is a part of the C++ standard. To use it, simply include the header file, 
:
We distinguish between string variables (such as the variable 
 defined above) and string literals (character sequences
enclosed in quotes, such as 
). The string stored in a string variable can change. A string literal denotes a particular
string, just as a number literal (such as 2) denotes a particular number.
Unlike number variables, string variables are guaranteed to be initialized even if you do not supply an initial value. By default,
a string variable is set to an empty string: a string containing no characters. An empty string literal is written as 
. The
definition
has the same effect as
2.4.2 Concatenation
Given two strings, such as 
 and 
, you can concatenate them to one long string. The result consists of all
characters in the first string, followed by all characters in the second string. In C++, you use the + operator to concatenate two
strings.
Use the + operator to concatenate strings; that is, put
them together to yield a longer string.
For example,
+
results in the string
What if you'd like the first and last name separated by a space? No problem:
This statement concatenates three strings: 
, the string literal 
, and 
. The result is
Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 9:20 AM

You cannot use the + operator to concatenate two string literals. For example, the expression 
 is not legal.
Simply use 
 instead.
2.4.3 String Input
You can read a string from the console:
When a string is read with the >> operator, only one word is placed into the string variable. For example, suppose the user
types
as the response to the prompt. This input consists of two words. After the call 
, the string 
 is placed
into the variable 
. Use another input statement to read the second word.
2.4.4 String Functions
The number of characters in a string is called the length of the string. For example, the length of 
 is 5. You can
compute the length of a string with the 
 function. Unlike the 
 or 
 function, the 
 function is invoked
with the dot notation. That is, you write the string whose length you want, then a period, then the name of the function,
followed by parentheses:
Many C++ functions require you to use this dot notation, and you must memorize (or look up) which do and which don't.
These functions are called member functions. We say that the member function 
 is invoked on the variable 
.
The 
 member function yields the number of
characters in a string.
A member function is invoked using the dot notation.
Once you have a string, you can extract substrings by using the 
 member function. The member function call
returns a string that is made from the characters in the string , starting at character 
, and containing 
 characters.
Here is an example:
sub is "
"
The 
 operation makes a string that consists of five characters taken from the string 
. Indeed, 
 is a
string of length 5 that occurs inside 
. A curious aspect of the 
 operation is the starting position. Starting
position 0 means “start at the beginning of the string”. The first position in a string is labeled 0, the second one 1, and so on.
For example, here are the position numbers in the 
 string:
The position number of the last character (12) is always one less than the length of the string.
Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 9:20 AM

Table 9    String Operations
Statement
Result
Comment
  
 is set to 
When applied to strings, + denotes
concatenation.
 
Error
Error: You cannot concatenate
twostring literals.
(User input: Harry Morgan)
 contains
The  operator places the next word
into the 
 variable.
  (User input: Harry Morgan)
 contains
, 
contains 
Use multiple  operators to read more
than one word.
 is set to 5
Each space counts as one character.
 is set to 
Extracts the substring of length 3
starting at position 1. (The initial
position is 0.)
 is set to 
If you omit the length, all characters
from the position until the end are
included.
   
;
 is set to the initial
letter in 
Extracts the substring of length 1
starting at position 0.
   
         
 is set to the last letter
in 
The last letter has position
. We need not
specify the length.
Let's figure out how to extract the substring 
. Count characters starting at 0, not 1. You find that , the 8th character,
has position number 7. The string you want is 5 characters long. Therefore, the appropriate substring command is
If you omit the length, you get all characters from the given position to the end of the string. For example,
is the string 
 (including the exclamation mark).
Here is a simple program that puts these concepts to work. The program asks for your name and that of your significant other.
Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 9:20 AM

It then prints out your initials.
The operation 
 makes a string consisting of one character, taken from the start of 
. The program
does the same for the 
. Then it concatenates the resulting one-character strings with the string literal "&" to get a
string of length 3, the 
 string. (See Figure 5.)
  Figure 5   Building the 
 String
Initials are formed from the first letter of each name.
Rich Legg/iStockphoto.
ch02/initials.cpp
Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 9:20 AM

Program Run
Self Check
21.  What is the length of the string 
? 
22.  Consider this string variable. 
Give a call to the 
 member function that returns the substring 
.
23.  Use string concatenation to turn the string variable str from Self Check 22. to 
.
24.  What does the following statement sequence print? 
25.  Give an input statement to read a name of the form “John Q. Public”. 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 9:20 AM

Random Fact 2.2
RANDOM FACT 2.2 The First Programmer
Before pocket calculators and personal computers existed, navigators and engineers used mechanical adding
machines, slide rules, and tables of logarithms and trigonometric functions to speed up computations.
Unfortunately, the tables—for which values had to be computed by hand—were notoriously inaccurate. The
mathematician Charles Babbage (1791–1871) had the insight that if a machine could be constructed that produced
printed tables automatically, both calculation and typesetting errors could be avoided. Babbage set out to develop a
machine for this purpose, which he called a Difference Engine because it used successive differences to compute
polynomials. For example, consider the function f (x) = x3. Write down the values for f(1), f(2), f(3), and so on.
Then take the differences between successive values:
Repeat the process, taking the difference of successive values in the second column, and then repeat once again:
Now the differences are all the same. You can retrieve the function values by a pattern of additions—you need to
know the values at the fringe of the pattern and the constant difference. This method was very attractive, because
mechanical addition machines had been known for some time. They consisted of cog wheels, with 10 cogs per
wheel, to represent digits, and mechanisms to handle the carry from one digit to the next. Mechanical
multiplication machines, on the other hand, were fragile and unreliable. Babbage built a successful prototype of the
Difference Engine (the Babbage's Difference Engine figure) and, with his own money and government grants,
proceeded to build the table-printing machine. However, because of funding problems and the difficulty of
building the machine to the required precision, it was never completed.
While working on the Difference Engine, Babbage conceived of a much grander vision that he called the Analytical
Engine. The Difference Engine was designed to carry out a limited set of computations—it was no smarter than a
pocket calculator is today. But Babbage realized that such a machine could be made programmable by storing
programs as well as data. The internal storage of the Analytical Engine was to consist of 1,000 registers of 50
decimal digits each. Programs and constants were to be stored on punched cards—a technique that was, at that
time, commonly used on looms for weaving patterned fabrics.
RANDOM FACT 2.2 The First Programmer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:20 AM

Babbage's Difference Engine
Topham/The Image Works.
Ada Augusta, Countess of Lovelace (1815–1852), the only child of Lord Byron, was a friend and sponsor of
Charles Babbage. Ada Lovelace was one of the first people to realize the potential of such a machine, not just for
computing mathematical tables but for processing data that were not numbers. She is considered by many to be the
world's first programmer.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 2.2 The First Programmer
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:20 AM

1.  A variable is a storage location with a name.
Javier Larrea/Age Fotostock America, Inc.
2.  When defining a variable, you usually specify an initial value.
3.  When defining a variable, you also specify the type of its values.
Graham Harrison/drr.net.
4.  Use the 
 type for numbers that cannot have a fractional part.
5.  Use the 
 type for floating-point numbers.
6.  Use comments to add explanations for humans who read your code. The compiler ignores comments.
7.  An assignment statement stores a new value in a variable, replacing the previously stored value.
8.  The assignment operator  does not denote mathematical equality.
9.  The 
 operator adds 1 to a variable; the 
 operator subtracts 1.
10.  Use the  operator to read a value and place it in a variable.
11.  You cannot change the value of a variable that is defined as 
.
12.  If both arguments of  are integers, the remainder is discarded.
13.  The  operator computes the remainder of an integer division.
Michael Flippo/iStockphoto.
14.  The C++ library defines many mathematical functions such as 
 (square root) and 
 (raising to a power).
15.  You send manipulators to 
 to specify how values should be formatted.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:20 AM

Rich Koele/iStockphoto.
16.  String are sequence of characters.
17.  Use the  operator to concatenate strings; that is, put them together to yield a longer string.
18.  The 
 member function yields the number of charcters in a string.
19.  A member function is invoked using the dot notation.
20.  Use the 
 member function to extract a substring of a string.
Rich Legg/iStockphoto.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:20 AM

R2.1.  Write the following mathematical expressions in C++.
R2.2.  Write the following C++ expressions in mathematical notation.
(a)  
(b)  
(c)  
(d)  
R2.3.  What are the values of the following expressions? In each line, assume that
(a)  
(b)  
(c)  
(d)  
(e)  
(f)  
(g)  
(h)  
(i)  
(j)  
R2.4.  Find at least five syntax errors in the following program.
R2.5.  Find at least four logic errors in the following program.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:20 AM

R2.6.  Explain the differences between , 
, 
, and 
.
R2.7.  Explain what each of the following program segments computes:
(a)  
(b)  
R2.8.  Write pseudocode for a program that reads a word and then prints the first character, the last character, and the characters i
the middle. For example, if the input is 
, the program prints 
.
R2.9.  Write pseudocode for a program that reads a name (such as 
) and then prints a monogram
consisting of the initial letters of the first, middle, and last name (such as 
).
R2.10.  Write pseudocode for a program that computes the first and last digit of a number. For example, if the input is 
program should print out  and . Hint: %, 
.
R2.11.  Modify the pseudocode for the program in How To 2.1 on page 61 so that the program gives change in quarters, dimes, a
nickels. You can assume that the price is a multiple of 5 cents.
R2.12.  The following pseudocode describes how to obtain the name of a day, given the day number (0 = Sunday, 1 = Monday, a
so on.)
Define a string called names containing "SunMonTueWedThuFriSat".
Compute the starting position as 3 × the day number.
Extract the substring of names at the starting position with length 3.
Check this pseudocode, using the day number 4. Draw a diagram of the string that is being computed, similar to Figure 5
R2.13.  The following pseudocode describes how to swap two letters in a word.
We are given a string str and two positions i and j. (i comes before j)
Set first to the substring from the start of the string to the last position before i.
Set middle to the substring from positions i + 1 to j - 1.
Set last to the substring from position j + 1 to the end of the string.
Concatenate the following five strings: first, the string containing just the character at position
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:20 AM

middle, the string containing just the character at position i, and last.
Check this pseudocode, using the string 
 and positions 2 and 4. Draw a diagram of the string that is being
computed, similar to Figure 5.
R2.14.  Run the following program, and explain the output you get.
Note the trace messages that are inserted to show the current contents of the 
 variable. How do you fix the
program? (The program has two separate errors.)
R2.15.  Write a program that prints the values
Explain the results.
R2.16.  This chapter contains a number of recommendations regarding variables and constants that make programs easier to read
and maintain. Briefly summarize these recommendations.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 9:20 AM

P2.1.  Write a program that reads a number and displays the square, cube, and fourth power. Use the 
 function only for the fo
power.
P2.2.  Write a program that prompts the user for two integers and then prints
• The sum
• The difference
• The product
• The average
• The distance (absolute value of the difference)
• The maximum (the larger of the two)
• The minimum (the smaller of the two)
Hint: The 
 and 
 functions are defined in the 
 header.
P2.3.  Write a program that prompts the user for a measurement in meters and then converts it to miles, feet, and inches.
P2.4.  Write a program that prompts the user for a radius and then prints
• The area and circumference of a circle with that radius
• The volume and surface area of a sphere with that radius
P2.5.  Write a program that asks the user for the lengths of the sides of a rectangle. Then print
• The area and perimeter of the rectangle
• The length of the diagonal (use the Pythagorean theorem)
P2.6.  Improve the program discussed in the How To on page 61 to allow input of quarters in addition to bills.
P2.7.  Write a program that helps a person decide whether to buy a hybrid car. Your program's inputs should be:
• The cost of a new car
• The estimated miles driven per year
• The estimated gas price
• The estimated resale value after 5 years
Compute the total cost of owning the car for 5 years. (For simplicity, we will not take the cost of financing into account.) 
realistic prices for a new and used hybrid and a comparable car from the Web. Run your program twice, using today's gas p
and 15,000 miles per year. Include pseudocode and the program runs with your assignment.
P2.8.  The following pseudocode describes how a bookstore computes the price of an order from the total price and the number 
books that were ordered.
Read the total book price and the number of books.
Compute the tax (7.5% of the total book price).
Compute the shipping charge ($2 per book).
The price of the order is the sum of the total book price, the tax, and the shipping charge.
Print the price of the order.
Translate this pseudocode into a C++ program.
P2.9.  The following pseudocode describes how to turn a string containing a ten-digit phone number (such as 
a more readable string with parentheses and dashes, like this: 
.
Take the substring consisting of the first three characters and surround it with "(" and ")". This 
area code.
Concatenate the area code, the substring consisting of the next three characters, a hyphen, and
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:21 AM

substring consisting of the last four characters. This is the formatted number.
Translate this pseudocode into a C++ program that reads a telephone number into a string variable, computes the formatte
number, and prints it.
P2.10.  The following pseudocode describes how to extract the dollars and cents from a price given as a floating-point value. Fo
example, a price 2.95 yields values 2 and 95 for the dollars and cents.
Assign the price to an integer variable dollars.
Multiply the difference price - dollars by 100 and add 0.5.
Assign the result to an integer variable cents.
Translate this pseudocode into a C++ program. Read a price and print the dollars and cents. Test your program with inpu
and 4.35.
P2.11.  Giving change. Implement a program that directs a cashier how to give change. The program has two inputs: the amount
and the amount received from the customer. Display the dollars, quarters, dimes, nickels, and pennies that the customer s
receive in return.
P2.12.  Write a program that asks the user to input
• The number of gallons of gas in the tank
• The fuel efficiency in miles per gallon
• The price of gas per gallon
Then print the cost per 100 miles and how far the car can go with the gas in the tank.
P2.13.  File names and extensions. Write a program that prompts the user for the drive letter ( ), the path (
),
name (
), and the extension (
). Then print the complete file name 
(If 
UNIX or a Macintosh, skip the drive name and use  instead of \ to separate directories.)
P2.14.  Write a program that reads a number greater than or equal to 1,000 from the user and prints it with a comma separating
thousands. Here is a sample dialog; the user input is in color:
P2.15.  Write a program that reads a number between 1,000 and 999,999 from the user, where the user enters a comma in the inp
Then print the number without a comma. Here is a sample dialog; the user input is in color:
Hint: Read the input as a string. Measure the length of the string. Suppose it contains n characters. Then extract substring
consisting of the first n – 4 characters and the last three characters.
P2.16.  Printing a grid. Write a program that prints the following grid to play tic-tac-toe.
Of course, you could simply write seven statements of the form
You should do it the smart way, though. Define string variables to hold two kinds of patterns: a comb-shaped pattern and
bottom line. Print the comb three times and the bottom line once.
P2.17.  Write a program that reads in an integer and breaks it into a sequence of individual digits. For example, the input 16384 
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:21 AM

1.  One possible answer is
You may choose a different variable name or a different initialization value, but your variable should have type 
.
2.  There are three errors:
•  You cannot have spaces in variable names.
•  The variable type should be 
 because it holds a fractional value.
•  There is a semicolon missing at the end of the statement.
3.  
4.  
5.  Change the definition of 
 to
6.  You need to use a 
 delimiter to close a comment that begins with a 
:
 Liters in a 12-ounce can 
7.  The program would compile, and it would display the same result. However, a person reading the program might find it
confusing that fractional cans are being considered.
8.  The variable 
 is initialized to 1. The assignment statement changes 
 to –1. The increment statement
changes it to 0.
9.  The last statement is a variable definition, but 
 has already been defined. Remedy: Drop the 
 in the last
statement.
10.  Assignment would occur when one car is replaced by another in the parking space.
11.  There is no prompt that alerts the program user to enter the quantity.
12.  The 
 variable is defined as an 
. If the user were to enter a price such as 
, only the 1 would be placed
into the variable.
13.  Their values are modified by the input statements.
14.  
15.  
16.  
17.  172 and 9
18.  
19.  The output is
Note that there is no space between the 
 and 
.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:21 AM

20.  
Note that the setw manipulator appears twice. Also note the added spaces in the string 
.
21.  The length is 11. The space counts as a character.
22.  
23.  
;
24.  
25.  
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:21 AM

Worked Example 2.1
•
Computing the Cost of Stamps
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Computing the Cost of Stamps
You are asked to simulate a postage stamp vending machine. A customer inserts dollar bills
into the vending machine and then pushes a “purchase” button. The vending machine gives
out as many ﬁrst-class stamps as the customer paid for, and returns the change in penny
(one-cent) stamps. A ﬁrst-class stamp cost 42 cents at the time this book was written. 
Step 1
Understand the problem: What are the inputs? What are the desired outputs?
In this problem, there is one input:
• The amount of money the customer inserts
There are two desired outputs: 
• The number of ﬁrst-class stamps the machine returns
• The number of penny stamps the machine returns
Step 2
Work out examples by hand. 
Let’s assume that a ﬁrst-class stamp costs 42 cents and the customer inserts $1.00. That’s
enough for two stamps (84 cents) but not enough for three stamps ($1.26). Therefore, the
machine returns two ﬁrst-class stamps and 16 penny stamps. 
Step 3
Write pseudocode for computing the answers. 
Given an amount of money and the price of a ﬁrst-class stamp, how can you compute how
many ﬁrst-class stamps can be purchased with the money? Clearly, the answer is related to
the quotient 
For example, suppose the customer paid $1.00. Use a pocket calculator to compute the quo-
tient: $1.00/$0.42 ≈ 2.38. 
How do you get “2 stamps” out of 2.38? It’s the quotient without the remainder. In C++,
this is easy to compute if both arguments are integers. Therefore, let’s switch our computa-
tion to pennies. Then we have 
number of first-class stamps = 100 / 42 (integer division, without remainder)
What if the user inputs two dollar? Then the numerator becomes 200. What if the price of a
stamp goes up? A more general equation is 
number of first-class stamps = 100 x dollars / price of first-class stamps in cents
How about the change? Here is one way of computing it. When the customer gets the
stamps, the change is the customer payment, reduced by the value of the stamps purchased.
In our example, the change is 16 cents—the difference between 100 and 2 · 42. Here is the
general formula:
change = 100 x dollars – number of first-class stamps x price of first-class stamp
WORKED EXAMPLE 2.1
amount of money
price of first-class stamp

2
C++ for Everyone  •  CHAPTER 2
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Step 4
Deﬁne the variables and constants that you need, and specify their types.
Here, we have three variables:
•
dollars
•
first_class_stamps
•
change
There is one constant, FIRST_CLASS_STAMP_PRICE. 
The variables dollars and FIRST_CLASS_STAMP_PRICE must be of type int since the com-
putation of first_class_stamps uses integer division. The remaining variables are also inte-
gers, counting the number of ﬁrst-class and penny stamps. Thus, we have
const int FIRST_CLASS_STAMP_PRICE = 42; // Price in pennies
int dollars; // Filled through input statement
int first_class_stamps = 100 * dollars / FIRST_CLASS_STAMP_PRICE;
int change = 100 * dollars - first_class_stamps * FIRST_CLASS_STAMP_PRICE;
Step 5
Turn the pseudocode into C++ statements. 
Our computation depends on the number of dollars that the user provides. Translating the
math into C++ yields the following statements:
first_class_stamps = 100 * dollars / FIRST_CLASS_STAMP_PRICE;
change = 100 * dollars - first_class_stamps * FIRST_CLASS_STAMP_PRICE;
Step 6
Provide input and output. 
Before starting the computation, we prompt the user for the number of dollars:
cout << "Enter number of dollars: ";
cin >> dollars;
When the computation is ﬁnished, we display the result. 
cout << "First class stamps: " << setw(6) << first_class_stamps << endl
     << "Penny stamps:       " << setw(6) << change << endl;
Step 7
Include the required headers and provide a main function.
We need the iostream header for all input and output. Because we use the setw manipulator,
we also require iomanip.  
Here is the complete program, ch02/stamps.cpp:
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
   const int FIRST_CLASS_STAMP_PRICE = 42; // Price in pennies
   cout << "Enter number of dollars: ";
   int dollars; 
   cin >> dollars;

Worked Example 2.1
•
Computing the Cost of Stamps
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   int first_class_stamps = 100 * dollars / FIRST_CLASS_STAMP_PRICE;
   int change = 100 * dollars - first_class_stamps * FIRST_CLASS_STAMP_PRICE;
   cout << "First class stamps: " << setw(6) << first_class_stamps << endl
        << "Penny stamps:       " << setw(6) << change << endl;
   return 0;
}
Program Run
Enter number of dollars: 4
First class stamps:      9
Penny stamps:           22

Chapter
   
    
    
Chapter Goals
•  To be able to implement decisions using if statements
•  To learn how to compare integers, floating-point numbers, and strings
•  To understand the Boolean data type
•  To develop strategies for validating user input
The programs you have seen to this point are able to do fast computations but they are very inflexible. Except for
variations in the input, they work the same way with every program run.
One of the essential features of nontrivial computer programs is their ability to make decisions and to carry out
different actions, depending on the nature of the inputs. In this chapter, you will learn how to program simple and
complex decisions. You will apply what you learn to the task of checking that user-supplied input can safely be
used in your program.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To be able to ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:46 AM

The 
 statement is used to implement a decision. When a condition is fulfilled, one set of statements is executed. Otherwise,
another set of statements is executed (see Syntax 3.1).
An 
 statement is like a fork in the road. Depending upon a decision, different parts of the program are executed.
Creatas/Media Bakery.
The 
 statement allows a program to carry out
different actions depending on the nature of the data to
be processed.
Here is an example using the 
 statement. In many countries, the number 13 is considered unlucky. Rather than offending
superstitious tenants, building owners sometimes skip the thirteenth floor; floor 12 is immediately followed by floor 14. Of
course, floor 13 is not usually left empty or, as some conspiracy theorists believe, filled with secret offices and research labs. It
is simply called floor 14. The computer that controls the building elevators needs to compensate for this foible and adjust all
floor numbers above 13.
Let's simulate this process in C++. We will ask the user to type in the desired floor number and then compute the actual floor.
When the input is above 13, then we need to decrement the input to obtain the actual floor. For example, if the user provides
an input of 20, the program determines the actual floor as 19. Otherwise, we simply use the supplied floor number.
The if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 9:46 AM

This elevator panel “skips” the thirteenth floor. The floor is not actually missing—the computer that controls the elevator
adjusts the floor numbers above 13.
Oleksandr Gumerov/iStockphoto.
The flowchart in Figure 1. shows the branching behavior.
  Figure 1   Flowchart for 
 Statement
In our example, each branch of the 
 statement contains a single statement. You can include as many statements in each
branch as you like. Sometimes, it happens that there is nothing to do in the 
 branch of the statement. In that case, you can
omit it entirely, such as in this example:
No else needed
The if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 9:46 AM

The following program puts the 
 statement to work. This program asks for the desired floor and then prints out the actual
floor.
ch03/elevator1.cpp
Program Run
20
Self Check
1.  In some Asian countries, the number 14 is considered unlucky. Some building owners play it safe and skip both
the thirteenth and the fourteenth floor. How would you modify the sample program to handle such a building?
2.  Consider the following 
 statement to compute a discounted price: 
What is the discounted price if the original price is 
3.  Compare this 
 statement with the one in Self Check 2.: 
The if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 9:46 AM

Do the two statements always compute the same value? If not, when do the values differ?
4.  Consider the following statements to compute a discounted price: 
What is the discounted price if the original price is 
5.  The variables 
 and 
 hold the actual amount of fuel and the size of the fuel tank of
a vehicle. If less than 10 percent is remaining in the tank, a status light should show a red color; otherwise it
shows a green color. Simulate this process by printing out either 
 or 
. 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 9:46 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 3.1 if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:48 AM

Quality Tip 3.1
QUALITY TIP 3.1 Brace Layout
The compiler doesn't care where you place braces. In this book, we follow the simple rule of making { and } line
up.
This style makes it easy to spot matching braces. Some programmers put the opening brace on the same line as the
:
This style makes it harder to match the braces, but it saves a line of code, allowing you to view more code on the
screen without scrolling. There are passionate advocates of both styles.
It is important that you pick a layout style and stick with it consistently within a given programming project. Which
style you choose may depend on your personal preference or a coding style guide that you need to follow.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 3.1 Brace Layout
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:48 AM

Quality Tip 3.2
QUALITY TIP 3.2 Always Use Braces
When the body of an 
 statement consists of a single statement, you need not use braces. For example, the
following is legal:
However, it is a good idea to always include the braces:
The braces makes your code easier to read, and you are less likely to make errors such as the one described in
Common Error 3.1.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 3.2 Always Use Braces
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:48 AM

Common Error 3.1
COMMON ERROR 3.1 A Semicolon After the 
 Condition
The following code fragment has an unfortunate error:
ERROR
There should be no semicolon after the 
 condition. The compiler interprets this statement as follows: If 
is greater than 13, execute the statement that is denoted by a single semicolon, that is, the do-nothing statement.
The statement enclosed in braces is no longer a part of the 
 statement. It is always executed. In other words even
if the value of 
 is not above 13, it is decremented.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 3.1 A Semicolon After the if Condition
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:48 AM

Productivity Hint 3.1
PRODUCTIVITY HINT 3.1 Tabs
Block-structured code has the property that nested statements are indented by one or more levels:
How do you move the cursor from the leftmost column to the appropriate indentation level? A perfectly
reasonable strategy is to hit the space bar a sufficient number of times. However, many programmers use the Tab
key instead. A tab moves the cursor to the next indentation level.
As nice as tabs are for data entry, they have one disadvantage: They can lead to problems when you send your file to
another person or a printer. There is no universal agreement on the width of indentations, and some software will
ignore tabs altogether. It is therefore best to save your files with spaces instead of tabs. Most development
environments have settings to automatically convert all tabs to spaces. Look at the documentation of your
development environment to find out how to activate this useful setting.
Photo by Vincent LaRussa/© John Wiley & Sons, Inc.
PRODUCTIVITY HINT 3.1 Tabs
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:48 AM

Advanced Topic 3.1
ADVANCED TOPIC 3.1 The Selection Operator
C++ has a selection operator of the form
condition
value
value
The value of that expression is either value1 if the test passes or value2 if it fails. For example, we can compute the
actual floor number as
which is equivalent to
You can use the selection operator anywhere that a value is expected, for example:
We don't use the selection operator in this book, but it is a convenient construct that you will find in many C++
programs.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 3.1 The Selection Operator
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:49 AM

Quality Tip 3.3
QUALITY TIP 3.3 Avoid Duplication in Branches
Look to see whether you duplicate code in each branch. If so, move it out of the 
 statement. Here is an example
of such duplication:
The output statement is exactly the same in both branches. This is not an error—the program will run correctly.
However, you can simplify the program by moving the duplicated statement, like this:
Removing duplication is particularly important when programs are maintained for a long time. When there are two
sets of statements with the same effect, it can easily happen that a programmer modifies one set but not the other.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 3.3 Avoid Duplication in Branches
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:49 AM

Every 
 statement contains a condition. In many cases, the condition involves comparing two values. For example, in the
previous examples we tested 
. The comparison > is called a relational operator. C++ has six relational
operators (see Table 1).
Relational operators 
 are
used to compare numbers and strings.
Table 1    Relational Operators
C++
Math Notation
Description
>
Greater than
≥
Greater than or equal
<
Less than
≤
Less than or equal
=
Equal
≠
Not equal
As you can see, only two C++ relational operators (  and ) look as you would expect from the mathematical notation.
Computer keyboards do not have keys for ≥,≤, or ≠, but the 
, and 
 operators are easy to remember because they look
similar. The 
 operator is initially confusing to most newcomers to C++. In C++,  already has a meaning, namely
assignment. The 
 operator denotes equality testing:
Assign
 to
Test whether
equals
You must remember to use == inside tests and to use = outside tests. (See Common Error 3.2 on page 92 for more
information.)
You can compare strings as well:
Use 
 to check whether two strings are different. In C++, letter case matters. For example, 
 and 
 are not the
same string.
Table 2 summarizes how to use relational operators in C++.
Table 2    Relational Operator Examples
Expression
Value
Comment
  
3 is less than 4; 
 tests for “less than or
equal”.
 
The “less than or equal“ operator is 
, not
, with the “less than” symbol first.
  
 is the opposite of 
.
  
The left-hand side must be strictly smaller
than the right-hand side.
Relational Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:49 AM

Expression
Value
Comment
  
Both sides are equal; 
 tests for “less than
or equal”.
  
 tests for equality.
  
 tests for inequality. It is true that 3 is not
5 - 1.
 
Use 
 to test for equality.
  
Although the values are very close to one
another, they are not exactly equal. See
Common Error 3.3 on page 93.
 
You cannot compare a string to a number.
In C++, you use a relational operator to check whether one value is greater than another.
Paul Kooi/iStockphoto.
Self Check
6.  Which of the following conditions are true, provided a is  and  is ? 
(a)  
(b)  
(c)  
7.  Give the opposite of the condition 
8.  What is the error in this statement? 
Relational Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:49 AM

9.  Supply a condition in this 
 statement to test whether the user entered a Y: 
10.  How do you test that a string 
 is not the empty string? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Relational Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 9:49 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 3.2 Comparisons
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:49 AM

Common Error 3.2
COMMON ERROR 3.2 Confusing  and 
The rule for the correct usage of  and 
 is very simple: In tests, always use 
 and never use . If it is so simple,
why can't the compiler be helpful and flag any errors?
Actually, the C++ language allows the use of  inside tests. To understand this, we have to go back in time. The
creators of C, the predecessor to C++, were very frugal. They did not want to have special values 
 and 
.
Instead, they allowed any numeric value inside a condition, with the convention that 0 denotes false and any non-0
value denotes true. Furthermore, in C and C++ assignments have values. For example, the value of the assignment
expression 
 is 13.
These two features—namely that numbers can be used as truth values and that assignments are expressions with
values—conspire to make a horrible pitfall. The test
ERROR
is legal C++, but it does not test whether 
 and 
 are equal. Instead, the code sets 
 to 
, and since
that value is not zero, the condition of the 
 statement is always fulfilled.
Fortunately, most compilers issue a warning when they encounter such a statement. You should take such
warnings seriously. (See Quality Tip 3.4 on page 92 for more advice about compiler warnings.)
Some shell-shocked programmers are so nervous about using  that they use 
 even when they want to make an
assignment:
ERROR
This statement tests whether 
 equals 
. It doesn't do anything with the outcome of the test, but
that is not an error. Some compilers will warn that “the code has no effect”, but others will quietly accept the code.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 3.2 Confusing = and ==
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:50 AM

Quality Tip 3.4
QUALITY TIP 3.4 Compile with Zero Warnings
There are two kinds of messages that the compiler gives you: errors and warnings. Error messages are fatal; the
compiler will not translate a program with one or more errors. Warning messages are advisory; the compiler will
translate the program, but there is a good chance that the program will not do what you expect it to do.
It is a good idea to learn how to activate warnings with your compiler, and to write code that emits no warnings at
all. For example, consider the test
One C++ compiler emits a curious warning message: “Suggest parentheses around assignment used as truth
value”. Sadly, the message is misleading because it was not written for students. Nevertheless, such a warning
gives you another chance to look at the offending statement and fix it, in this case, by replacing the  with an 
.
In order to make warnings more visible, many compilers require you to take some special action. This might
involve clicking a checkbox in an integrated environment or supplying a special option on the command line. Ask
your instructor or lab assistant how to turn on warnings for your compiler.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 3.4 Compile with Zero Warnings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:50 AM

Common Error 3.3
COMMON ERROR 3.3 Exact Comparison of Floating-Point Numbers
Floating-point numbers have only a limited precision, and calculations can introduce roundoff errors. You must
take these inevitable roundoffs into account when comparing floating-point numbers. For example, the following
code multiplies the square root of 2 by itself. Ideally, we expect to get the answer 2:
This program displays
It does not make sense in most circumstances to compare floating-point numbers exactly. Instead, we should test
whether they are close enough. That is, the magnitude of their difference should be less than some threshold.
Mathematically, we would write that x and y are close enough if
for a very small number, ε. ε is the Greek letter epsilon, a letter used to denote a very small quantity. It is common
to set ε to 10-14 when comparing 
 numbers:
Include the 
 header to use the 
 function.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 3.3 Exact Comparison of Floating-Point Numbers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:50 AM

Advanced Topic 3.2
ADVANCED TOPIC 3.2 Lexicographic Ordering of Strings
If you compare strings using 
, they are compared in “lexicographic” order. This ordering is very similar
to the way in which words are sorted in a dictionary.
For example, consider this code fragment.
The condition is not fulfilled, because in the dictionary Dick comes before Tom. There are a few differences
between the ordering in a dictionary and in C++. In C++:
•  All uppercase letters come before the lowercase letters. For example, 
 comes before 
.
•  The space character comes before all printable characters.
•  Numbers come before letters.
•  For the ordering of punctuation marks, see Appendix D.
Lexicographic order is used to compare strings.
When comparing two strings, you compare the first letters of each word, then the second letters, and so on, until
either one of the strings ends or you find the first letter pair that doesn't match.
To see which of two terms comes first in the dictionary, consider the first letter in which they differ.
Corbis Digital Stock.
If one of the strings ends, the longer string is considered the “larger” one. For example, compare 
 with
. The first three letters match, and we reach the end of the first string. Therefore 
 comes before
 in lexicographic ordering.
When you reach a mismatch, the string containing the “larger” character is considered “larger”. For example, let's
compare 
 with 
. The first two letters match. Since  comes after , the string 
 comes after
 in the lexicographic ordering. (See Figure 2.)
ADVANCED TOPIC 3.2 Lexicographic Ordering of Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:50 AM

  Figure 2   Lexicographic Ordering
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 3.2 Lexicographic Ordering of Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:50 AM

How To 3.1
HOW TO 3.1 Implementing an 
 Statement
This How To walks you through the process of implementing an 
 statement. We will illustrate the steps with the
following example problem:
Sales discounts are often higher for expensive products. Use the 
 statement to implement such a decision.
iStockphoto.
The university bookstore has a Kilobyte Day sale every October 24, giving an 8 percent discount on all computer
accessory purchases if the price is less than $128, and a 16 percent discount if the price is at least $128. Write a
program that asks the cashier for the original price and then prints the discounted price.
Step 1  Decide upon the branching condition.
In our sample problem, the obvious choice for the condition is:
original price < 128?
That is just fine, and we will use that condition in our solution.
But you could equally well come up with a correct solution if you choose the opposite condition: Is
the original price at least $128? You might choose this condition if you put yourself into the
position of a shopper who wants to know when the bigger discount applies.
Step 2  Give pseudocode for the work that needs to be done when the condition is fulfilled.
In this step, you list the action or actions that are taken in the “positive” branch. The details depend
on your problem. You may want to print a message, compute values, or even exit the program.
In our example, we need to apply an 8 percent discount:
discounted price = 0.92 × original price
Step 3  Give pseudocode for the work (if any) that needs to be done when the condition is not fulfilled.
What do you want to do in the case that the condition of Step 1 is not fulfilled? Sometimes, you
want to do nothing at all. In that case, use an 
 statement without an 
 branch.
In our example, the condition tested whether the price was less than $128. If that condition is not
fulfilled, the price is at least $128, so the higher discount of 16 percent applies to the sale:
discounted price = 0.84 × original price
HOW TO 3.1 Implementing an if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:50 AM

Step 4  Double-check relational operators.
First, be sure that the test goes in the right direction. It is a common error to confuse  and . Next,
consider whether you should use the  operator or its close cousin, the 
 operator.
What should happen if the original price is exactly $128? Reading the problem carefully, we find
that the lower discount applies if the original price is less than $128, and the higher discount applies
when it is at least $128. A price of $128 should therefore not fulfill our condition, and we must use
, not 
.
Step 5  Remove duplication.
Check which actions are common to both branches, and move them outside. (See Quality Tip 3.3 on
page 88.)
In our example, we have two statements of the form
discounted price =
 × original price
They only differ in the discount rate. It is best to just set the rate in the branches, and to do the
computation afterwards:
If original price < 128
{
discount rate = 0.92
}
Else
{
discount rate = 0.84
}
discounted price = discount rate × original price
Step 6  Test both branches.
Formulate two test cases, one that fulfills the condition of the 
 statement, and one that does not.
Ask yourself what should happen in each case. Then follow the pseudocode and act each of them
out.
In our example, let us consider two scenarios for the original price: $100 and $200. We expect that
the first price is discounted by $8, the second by $32.
When the original price is 100, then the condition 100 < 128 is true, and we get
discount rate = 0.92
discounted price = 0.92 × 100 = 92
When the original price is 200, then the condition 200 < 128 is false, and
discount rate = 0.84
discounted price = 0.84 × 200 = 168
In both cases, we get the expected answer.
Step 7  Assemble the 
 statement in C++.
Type the skeleton
and fill it in, as shown in Syntax 3.1 on page 83. Omit the 
 branch if it is not needed.
In our example, the completed statement is
HOW TO 3.1 Implementing an if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:50 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
HOW TO 3.1 Implementing an if Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 9:50 AM

Worked Example 3.1
WORKED EXAMPLE 3.1 Extracting the Middle
Your task is to extract a string containing the middle character from a given string 
. For example, if the string is
, the result is the string 
. However, if the string has an even number of letters, extract the middle two
characters. If the string is 
, the result is 
.
Step 1  Decide upon the branching condition.
We need to take different actions for strings of odd and even length. Therefore, the condition is
Is the length of the string odd?
In C++, you use the remainder of division by 2 to find out whether a value is even or odd. Then the
test becomes
str.length() % 2 == 1?
Step 2  Give pseudocode for the work that needs to be done when the condition is fulfilled. We need to find
the position of the middle character. If the length is 5, the position is 2.
In general,
position = str.length() / 2 (with the remainder discarded)
result = str.substr(position, 1)
Step 3  Give pseudocode for the work (if any) that needs to be done when the condition is not fulfilled.
Again, we need to find the position of the middle character. If the length is 6, the starting position is
2, and the ending position is 3.
In general,
position = str.length() / 2 - 1
result = str.substr(position, 2)
Step 4  Double-check relational operators.
Do we really want str.length() % 2 == 1? For example, when the length is 5, 
 is the
remainder of the division 5 / 2, which is 1. In general, dividing an odd number by 2 leaves a
remainder of 1. (Actually, dividing a negative odd number by 2 leaves a remainder of -1, but the
string length is never negative.) Therefore, our condition is correct.
Step 5  Remove duplication.
Here is the statement that we have developed:
If str.length() % 2 == 1
{
WORKED EXAMPLE 3.1 Extracting the Middle
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:52 AM

   position = str.length() / 2 (with remainder discarded)
   result = str.substr(position, 1)
}
Else
{
   position = str.length() / 2 - 1
   result = str.substr(position, 2)
}
The second statement in each branch is almost identical, but the length of the substring differs. Let's
set the length in each branch:
If str.length() % 2 == 1
{
   position = str.length() / 2 (with remainder discarded)
   length = 1
}
Else
{
   position = str.length() / 2 - 1
   length = 2
}
result = str.substr(position, length)
Step 6  Test both branches.
We will use a different set of strings for testing. For an odd-length string, consider 
. We
get
position = str.length() / 2 = 7 / 2 = 3 (with remainder discarded)
length = 1
result = str.substr(3, 1) = "i"
For the even-length string 
, we get
position = str.length() / 2 - 1 = 8 / 2 - 1 = 3 (with remainder discarded)
length = 2
result = str.substr(3, 2) = "it"
Step 7  Assemble the 
 statement in C++.
Here's the completed code segment.
WORKED EXAMPLE 3.1 Extracting the Middle
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:52 AM

Random Fact 3.1
RANDOM FACT 3.1 The Denver Airport Luggage Handling System
Making decisions is an essential part of any computer program. Nowhere is this more obvious than in a computer
system that helps sort luggage at an airport. After scanning the luggage identification codes, the system sorts the
items and routes them to different conveyor belts. Human operators then place the items onto trucks. When the city
of Denver built a huge airport to replace an outdated and congested facility, the luggage system contractor went a
step further. The new system was designed to replace the human operators with robotic carts. Unfortunately, the
system plainly did not work. It was plagued by mechanical problems, such as luggage falling onto the tracks and
jamming carts. Just as frustrating were the software glitches. Carts would uselessly accumulate at some locations
when they were needed elsewhere.
The Denver airport originally had a fully automatic system for moving luggage, replacing human operators with
robotic carts. Unfortunately, the system never worked and was dismantled before the airport was opened.
Bob Daemmrich/Getty Images.
The airport had been scheduled for opening in 1993, but without a functioning luggage system, the opening was
delayed for over a year while the contractor tried to fix the problems. The contractor never succeeded, and
ultimately a manual system was installed. The delay cost the city and airlines close to a billion dollars, and the
contractor, once the leading luggage systems vendor in the United States, went bankrupt.
Clearly, it is very risky to build a large system based on a technology that has never been tried in a smaller scale. As
robots and the software that controls them get better over time, they will take on a larger share of luggage handling
in the future. But it is likely that this will happen in an incremental fashion.
RANDOM FACT 3.1 The Denver Airport Luggage Handling System
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:52 AM

In Section 3.1, you saw how to program a two-way branch with an 
 statement. In many situations, there are more than two
cases. In this section, you will see how to implement a decision with multiple alternatives.
Multiple 
 statements can be combined to evaluate
complex decisions.
For example, consider a program that displays the effect of an earthquake, as measured by the Richter scale (see Table 3). The
Richter scale is a measurement of the strength of an earthquake. Every step in the scale, for example from 6.0 to 7.0, signifies a
tenfold increase in the strength of the quake.
The 1989 Loma Prieta earthquake that damaged the Bay Bridge in San Francisco and destroyed many buildings measured
7.1 on the Richter scale.
Kevin Russ/iStockphoto.
Table 3    Richter Scale
Value
Effect
8
Most structures fall
7
Many buildings destroyed
6
Many buildings considerably damaged, some collapse
4.5
Damage to poorly constructed buildings
In this case, there are five branches: one each for the four descriptions of damage, and one for no destruction. Figure 3 shows
the flowchart for this multiple-branch statement.
Multiple Alternatives
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 9:53 AM

  Figure 3   Multiple Alternatives
You use multiple 
 statements to implement multiple alternatives, like this:
Multiple Alternatives
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 9:53 AM

As soon as one of the four tests succeeds, the effect is displayed, and no further tests are attempted. If none of the four cases
applies, the final 
 clause applies, and a default message is printed. (See 
 for the full
program.)
Here you must sort the conditions and test against the largest cutoff first. Suppose we reverse the order of tests:
Tests in wrong order
This does not work. Suppose the value of 
 is 7.1. That value is at least 4.5, matching the first case. The other tests
will never be attempted.
In this example, it is also important that we use an 
 sequence, not just multiple independent 
 statements.
Consider this sequence of independent tests.
Didn't use
Now the alternatives are no longer exclusive. If 
 is 7.1, then the last three tests all match, and three messages are
printed.
When using multiple 
 statements, pay attention to
the order of the conditions.
Multiple Alternatives
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 9:53 AM

Self Check
11.  In a game program, the scores of players A and B are stored in variables 
 and 
. Assuming
that the player with the larger score wins, write an 
 sequence that prints out 
, 
, or 
. 
12.  Write a conditional statement with three branches that sets  to 1 if  is positive, to -1 if  is negative, and to
0 if  is zero. 
13.  How could you achieve the task of Self Check 12. with only two branches? 
14.  Beginners sometimes write statements such as the following: 
Explain how this code can be improved.
15.  Suppose the user enters -1 into the 
 program. What is printed? 
16.  Suppose we want to have the 
 program check whether the user entered a negative number.
What branch would you add to the 
 statement, and where? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Multiple Alternatives
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 9:53 AM

Advanced Topic 3.3
ADVANCED TOPIC 3.3 The 
 Statement
A sequence of 
 that compares a single integer value against several constant alternatives can
be implemented as a 
 statement. For example,
This is a shortcut for
Well, it isn't much of a shortcut, but it has one advantage—it is obvious that all branches test the same value,
namely 
.
The 
 statement can be applied only in narrow circumstances. The test cases must be constants, and they must
be integers. You cannot use
Error
Every branch of the switch must be terminated by a 
 instruction. If the 
 is missing, execution falls
through to the next branch, and so on, until finally a 
 or the end of the 
 is reached. In practice, this
fall-through behavior is rarely useful, but it is a common cause of errors. If you accidentally forget the 
statement, your program compiles but executes unwanted code. Many programmers consider the 
 statement
ADVANCED TOPIC 3.3 The switch Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:54 AM

somewhat dangerous and prefer the 
 statement.
We leave it to you to use the 
 statement for your own code or not. At any rate, you need to have a reading
knowledge of 
 in case you find it in other programmers' code.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 3.3 The switch Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:54 AM

It is often necessary to include an 
 statement inside another. Such an arrangement is called a nested set of statements. Here is
a typical example.
In the United States different tax rates are used depending on the taxpayer's marital status. There are different tax schedules for
single and for married taxpayers. Married taxpayers add their income together and pay taxes on the total. Table 4 gives the tax
rate computations, using a simplification of the schedules in effect for the 2008 tax year. A different tax rate applies to each
“bracket”. In this schedule, the income at the first bracket is taxed at 10 percent, and the income at the second bracket is taxed
at 25 percent. The income limits for each bracket depend on the marital status.
Computing income taxes requires multiple levels of decisions.
iStockphoto.
Table 4    Federal Tax Rate Schedule
If your status is Single and if the taxable income is over
but not over
the tax is
of the amount over
$0
$32,000
10%
$0
$32,000
 
$3,200 + 25%
$32,000
If your status is Married and if the taxable income is over
but not over
the tax is
of the amount over
$0
$64,000
10%
$0
$64,000
 
$6,400 + 25%
$64,000
Now compute the taxes due, given a filing status and an income figure. The key point is that there are two levels of decision
making. First, you must branch on the marital status. Then, for each filing status, you must have another branch on income
level.
The two-level decision process is reflected in two levels of 
 statements in the program at the end of this section.(See Figure
4 for a flowchart.) In theory, nesting can go deeper than two levels. A three-level decision process (first by state, then by filing
status, then by income level) requires three nesting levels.
Nested Branches
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:54 AM

  Figure 4   Income Tax Computation
ch03/tax.cpp
Nested Branches
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:54 AM

Program Run
80000
m
Self Check
17.  What is the amount of tax that a single taxpayer pays on an income of $32,000? 
18.  Would that amount change if the first nested 
 statement changed from 
19.  Suppose Harry and Sally each make $40,000 per year. Would they save taxes if they married? 
20.  How would you modify the 
 program in order to check that the user entered a correct value for the
marital status (i.e.,  or )? 
21.  Some people object to higher tax rates for higher incomes, claiming that you might end up with less money
after taxes when you get a raise for working hard. What is the flaw in this argument? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Nested Branches
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 9:54 AM

Productivity Hint 3.2
PRODUCTIVITY HINT 3.2 Hand-Tracing
A very useful technique for understanding whether a program works correctly is called hand-tracing. You
simulate the program's activity on a sheet of paper. You can use this method with pseudocode or C++ code.
Get an index card, a cocktail napkin, or whatever sheet of paper is within reach. Make a column for each variable.
Have the program code ready. Use a marker, such as a paper clip, to mark the current statement. In your mind,
execute statements one at a time. Every time the value of a variable changes, cross out the old value and write the
new value below the old one.
For example, let's trace the tax program with the data from the program run on page 104. In lines 13 and 14, 
and 
 are initialized to 0.
In lines 18 and 22, 
 and 
 are initialized by input statements
PRODUCTIVITY HINT 3.2 Hand-Tracing
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 9:54 AM

Because 
 is not 
, we move to the 
 branch of the outer 
 statement (line 36)
Since 
 is not 
, we move to the 
 branch of the inner 
 statement (line 42)
The values of 
 and 
 are updated.
Their sum 
 is computed and printed. Then the program ends.
PRODUCTIVITY HINT 3.2 Hand-Tracing
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 9:54 AM

Because the program trace shows the expected output ($10,400), it successfully demonstrated that this test case
works correctly.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
PRODUCTIVITY HINT 3.2 Hand-Tracing
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 9:54 AM

Quality Tip 3.5
QUALITY TIP 3.5 Prepare Test Cases Ahead of Time
Consider how to test the tax computation program. Of course, you cannot try out all possible inputs of filing status
and income level. Even if you could, there would be no point in trying them all. If the program correctly computes
one or two tax amounts in a given bracket, then we have a good reason to believe that all amounts will be correct.
You want to aim for complete coverage of all decision points. Here is a plan for obtaining a comprehensive set of
test cases:
•  There are two possibilities for the filing status and two tax brackets for each status, yielding four test cases.
•  Test a handful of boundary conditions, such as an income that is at the boundary between two brackets, and a
zero income.
•  If you are responsible for error checking (which is discussed in Section 3.7), also test an invalid input, such
as a negative income.
Make a list of the test cases and the expected outputs:
It is always a good idea to design test cases before starting to code. Working through the test cases gives you a
better understanding of the algorithm that you are about to implement.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 3.5 Prepare Test Cases Ahead of Time
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:54 AM

Productivity Hint 3.3
PRODUCTIVITY HINT 3.3 Make a Schedule and Make Time for
Unexpected Problems
Commercial software is notorious for being delivered later than promised. For example, Microsoft originally
promised that its Windows Vista operating system would be available late in 2003, then in 2005, then in March
2006; it finally was released in January 2007. Some of the early promises might not have been realistic. It was in
Microsoft's interest to let prospective customers expect the imminent availability of the product. Had customers
known the actual delivery date, they might have switched to a different product in the meantime. Undeniably,
though, Microsoft had not anticipated the full complexity of the tasks it had set itself to solve.
Microsoft can delay the delivery of its product, but it is likely that you cannot. As a student or a programmer, you
are expected to manage your time wisely and to finish your assignments on time. You can probably do simple
programming exercises the night before the due date, but an assignment that looks twice as hard may well take four
times as long, because more things can go wrong. You should therefore make a schedule whenever you start a
programming project.
First, estimate realistically how much time it will take you to:
•  Design the program logic.
•  Develop test cases.
•  Type the program in and fix syntax errors.
•  Test and debug the program.
For example, for the income tax program I might estimate an hour for the design; 30 minutes for developing test
cases; an hour for data entry and fixing syntax errors; and an hour for testing and debugging. That is a total of 3.5
hours. If I work two hours a day on this project, it will take me almost two days.
Make a schedule for your programming work and build in time for problems.
Bananastock/Media Bakery.
Then think of things that can go wrong. Your computer might break down. You might be stumped by a problem
with the computer system. (That is a particularly important concern for beginners. It is very common to lose a day
over a trivial problem just because it takes time to track down a person who knows the magic command to
overcome it.) As a rule of thumb, double the time of your estimate. That is, you should start four days, not two
PRODUCTIVITY HINT 3.3 Make a Schedule and Make Time for Unexpe...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:54 AM

days, before the due date. If nothing went wrong, great; you have the program done two days early. When the
inevitable problem occurs, you have a cushion of time that protects you from embarrassment and failure.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
PRODUCTIVITY HINT 3.3 Make a Schedule and Make Time for Unexpe...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:54 AM

Common Error 3.4
COMMON ERROR 3.4 The Dangling 
 Problem
When an 
 statement is nested inside another 
 statement, the following error may occur.
$5 inside continental U.S.
Hawaii is more expensive
Pitfall!
As are foreign shipments
The indentation level seems to suggest that the 
 is grouped with the test 
. Unfortunately,
that is not the case. The compiler ignores all indentation and matches the 
 with the preceding 
. That is, the
code is actually
$5 inside continental U.S.
Hawaii is more expensive
Pitfall!
As are foreign shipments
That isn't what you want. You want to group the 
 with the first 
.
The ambiguous 
 is called a dangling 
 You can avoid this pitfall if you always use braces, as
recommended in Quality Tip 3.2 on page 86:
$5 inside continental U.S.
Hawaii is more expensive
As are foreign shipments
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 3.4 The Dangling else Problem
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:54 AM

Sometimes, you need to evaluate a logical condition in one part of a program and use it elsewhere. To store a condition that
can be true or false, you use a Boolean variable. Boolean variables are named after the mathematician George Boole.
The Boolean type 
 has two values, 
 and
.
In C++, the 
 data type represents the Boolean type. Variables of type 
 can hold exactly two values, denoted false and
true. These values are not strings or integers; they are special values, just for Boolean variables. Here is a definition of a
Boolean variable:
You can use the value later in your program to make a decision:
 // Only executed if 
 has been set to 
Boolean variables are named after the mathematician George Boole (1815-1864), a pioneer in the study of logic.
© 2008 Sidney Harris.
When you make complex decisions, you often need to combine Boolean values. An operator that combines Boolean conditions
is called a Boolean operator. In C++, the 
 operator (called and) yields true only when both conditions are true. The 
operator (called or) yields the result 
 if at least one of the conditions is true.
C++ has two Boolean operators that combine
conditions: 
 (and) and 
 (or).
Boolean Variables and Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 9:55 AM

Suppose you write a program that processes temperature values, and you want to test whether a given temperature corresponds
to liquid water. (At sea level, water freezes at 0 degrees Celsius and boils at 100 degrees.) Water is liquid if the temperature is
greater than zero and less than 100:
&&
The condition of the test has two parts, joined by the 
 operator. Each part is a Boolean value that can be true or false. The
combined expression is true if both individual expressions are true. If either one of the expressions is false, then the result is
also false (see Figure 5).
  Figure 5   Boolean Truth Tables
Conversely, let's test whether water is not liquid at a given temperature. That is the case when the temperature is at most 0 or at
least 100. Use the 
 (or) operator to combine the expressions:
Figure 6 shows flowcharts for these examples.
At this geyser in Iceland, you can see ice, liquid water, and steam.
Alamy.
Boolean Variables and Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 9:55 AM

  Figure 6   Flowcharts for and and or Combinations
Sometimes you need to invert a condition with the not logical operator. The  operator takes a single condition and evaluates
to true if that condition is false and to 
 if the condition is true. In this example, output occurs if the value of the
Boolean variable 
 is 
:
!
To invert a condition, use the  (not) operator.
Table 5 illustrates additional examples of evaluating Boolean operators.
Table 5    Boolean Operators
Expression
Value
Comment
  
Only the first condition is true.
  
The first condition is true.
  
The 
 is not a test for “either-or”.
If both conditions are true, the
result is true.
 
Error: The expression 
is 
, which is converted to .
The expression 
 is 
.
You never want to write such an
expression; see Common Error 3.5
on page 112.
 
Error: -10 is not zero. It is
converted to true. You never want
to write such an expression; see
Common Error 3.5.
  
The 
 operator binds more
strongly than the 
 operator.
  
 is 
, therefore its
negation is 
.
Boolean Variables and Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 9:55 AM

Expression
Value
Comment
  
There is no need to compare a
Boolean variable with 
.
  
It is clearer to use  than to
compare with 
.
Self Check
22.  Suppose  and  are two integers. How do you test whether both of them are zero? 
23.  How do you test whether at least one of them is zero? 
24.  How do you test whether exactly one of them is zero? 
25.  What is the value of 
 
26.  What is the advantage of using the type 
 rather than strings 
 or integers 0/1?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Boolean Variables and Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 9:55 AM

Common Error 3.5
COMMON ERROR 3.5 Combining Multiple Relational Operators
Consider the expression
Error
This looks just like the mathematical test 
≤
≤
. Unfortunately, it is not.
Let us dissect the expression 
. The first half, 
, is a test with outcome 
 or
, depending on the value of 
. The outcome of that test (
 or 
) is then compared against 100.
This seems to make no sense. Can one compare truth values and floating-point numbers? Is 
 larger than 100 or
not? Unfortunately, to stay compatible with the C language, C++ converts 
 to 0 and 
 to 1. Therefore,
the expression will always evaluate to true.
You must be careful not to mix logical and arithmetic expressions in your programs. Instead, use and to combine
two separate tests:
Another common error, along the same lines, is to write
Error
instead of
Unfortunately, the compiler will not issue an error message. Instead, it converts  to 
 or 
. Zero is
converted to 
, and any nonzero value is converted to 
. If  is not zero, then it tests whether  is greater
than 0, and finally it computes the and of these two truth values. Naturally, that computation makes no sense.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 3.5 Combining Multiple Relational Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:55 AM

Common Error 3.6
COMMON ERROR 3.6 Confusing && and || Conditions
It is a surprisingly common error to confuse and and or conditions. A value lies between 0 and 100 if it is at least
0 and at most 100. It lies outside that range if it is less than 0 or greater than 100. There is no golden rule; you just
have to think carefully.
Often the and or or is clearly stated, and then it isn't too hard to implement it. But sometimes the wording isn't as
explicit. It is quite common that the individual conditions are nicely set apart in a bulleted list, but with little
indication of how they should be combined. Consider these instructions for filing a tax return. You can claim
single filing status if any one of the following is true:
•  You were never married.
•  You were legally separated or divorced on the last day of the tax year.
•  You were widowed, and did not remarry.
Since the test passes if any one of the conditions is true, you must combine the conditions with or. Elsewhere, the
same instructions state that you may use the more advantageous status of married filing jointly if all five of the
following conditions are true:
•  Your spouse died less than two years ago and you did not remarry.
•  You have a child whom you can claim as dependent.
•  That child lived in your home for all of the tax year.
•  You paid over half the cost of keeping up your home for this child.
•  You filed a joint return with your spouse the year he or she died.
Because all of the conditions must be true for the test to pass, you must combine them with an and.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 3.6 Confusing && and || Conditions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:55 AM

Advanced Topic 3.4
ADVANCED TOPIC 3.4 Lazy Evaluation of Boolean Operators
The 
 and 
 operators are computed using lazy evaluation. In other words, logical expressions are evaluated
from left to right, and evaluation stops as soon as the truth value is determined. When an 
 is evaluated and the
first condition is false, the second condition is not evaluated, because it does not matter what the outcome of the
second test is.
The 
 and 
 operators are computed lazily:
As soon as the truth value is determined, no
further conditions are evaluated.
For example, consider the expression
Suppose the value of 
 is zero. Then the test 
 fails, and the second test is not attempted. That
is just as well, because it is illegal to divide by zero.
Similarly, when the first condition of an 
 expression is true, then the remainder is not evaluated since the result
must be true.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 3.4 Lazy Evaluation of Boolean Operators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 9:55 AM

Advanced Topic 3.5
ADVANCED TOPIC 3.5 De Morgan's Law
Humans generally have a hard time comprehending logical conditions with not operators applied to and/or
expressions. De Morgan's Law, named after the logician Augustus De Morgan (1806-1871), can be used to
simplify these Boolean expressions.
Suppose we want to charge a higher shipping rate if we don't ship within the continental United States.
This test is a little bit complicated, and you have to think carefully through the logic. When it is not true that the
country is USA and the state is not Alaska and the state is not Hawaii, then charge $20.00. Huh? It is not true that
some people won't be confused by this code.
The computer doesn't care, but it takes human programmers to write and maintain the code. Therefore, it is useful
to know how to simplify such a condition.
De Morgan's law tells you how to negate 
 and
 conditions.
De Morgan's Law has two forms: one for the negation of an and expression and one for the negation of an or
expression:
Pay particular attention to the fact that the and and or operators are reversed by moving the not inward. For
example, the negation of “the state is Alaska or it is Hawaii”,
is “the state is not Alaska and it is not Hawaii”:
That is, of course, the same as
Now apply the law to our shipping charge computation:
ADVANCED TOPIC 3.5 De Morgan's Law
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:55 AM

To simplify conditions with negations of and or or expressions, it is usually a good idea to apply De Morgan's Law
to move the negations to the innermost level.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 3.5 De Morgan's Law
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:55 AM

Random Fact 3.2
RANDOM FACT 3.2 Artificial Intelligence
When one uses a sophisticated computer program such as a tax preparation package, one is bound to attribute some
intelligence to the computer. The computer asks sensible questions and makes computations that we find a mental
challenge. After all, if doing one's taxes were easy, we wouldn't need a computer to do it for us.
As programmers, however, we know that all this apparent intelligence is an illusion. Human programmers have
carefully “coached” the software in all possible scenarios, and it simply replays the actions and decisions that were
programmed into it.
Would it be possible to write computer programs that are genuinely intelligent in some sense? From the earliest
days of computing, there was a sense that the human brain might be nothing but an immense computer, and that it
might well be feasible to program computers to imitate some processes of human thought. Serious research into
artificial intelligence began in the mid-1950s, and the first twenty years brought some impressive successes.
Programs that play chess–surely an activity that appears to require remarkable intellectual powers–have become so
good that they now routinely beat all but the best human players. As far back as 1975, an expert-system program
called Mycin gained fame for being better in diagnosing meningitis in patients than the average physician.
However, there were serious setbacks as well. From 1982 to 1992, the Japanese government embarked on a
massive research project, funded at over 40 billion Japanese yen. It was known as the Fifth-Generation Project. Its
goal was to develop new hardware and software to greatly improve the performance of expert system software. At
its outset, the project created fear in other countries that the Japanese computer industry was about to become the
undisputed leader in the field. However, the end results were disappointing and did little to bring artificial
intelligence applications to market.
From the very outset, one of the stated goals of the AI community was to produce software that could translate text
from one language to another, for example from English to Russian. That undertaking proved to be enormously
complicated. Human language appears to be much more subtle and interwoven with the human experience than had
originally been thought. Even the grammar-checking tools that come with word-processing programs today are
more of a gimmick than a useful tool, and analyzing grammar is just the first step in translating sentences.
The CYC (from encyclopedia) project, started by Douglas Lenat in 1984, tries to codify the implicit assumptions
that underlie human speech and writing. The team members started out analyzing news articles and asked
themselves what unmentioned facts are necessary to actually understand the sentences. For example, consider the
sentence “Last fall she enrolled in Michigan State”. The reader automatically realizes that “fall” is not related to
falling down in this context, but refers to the season. While there is a state of Michigan, here Michigan State
denotes the university. A priori, a computer program has none of this knowledge. The goal of the CYC project is to
extract and store the requisite facts–that is, (1) people enroll in universities; (2) Michigan is a state; (3) many states
have universities named X State University, often abbreviated as X State; (4) most people enroll in a university in
the fall. By 1995, the project had codified about 100,000 common-sense concepts and about a million facts of
knowledge relating them. Even this massive amount of data has not proven sufficient for useful applications.
RANDOM FACT 3.2 Artificial Intelligence
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:55 AM

  Figure 7   The Winner of the 2007 DARPA Urban Challenge
In recent years, artificial intelligence technology has seen substantial advances. One of the most astounding
examples is the outcome of a series of “grand challenges” for autonomous vehicles posed by the Defense Advanced
Research Projects Agency (DARPA). Competitors were invited to submit a computer-controlled vehicle that had
to complete an obstacle course without a human driver or remote control. The first event, in 2004, was a
disappointment, with none of the entrants finishing the route. In 2005, five vehicles completed a grueling 212 km
course in the Mojave desert. Stanford's Stanley came in first, with an average speed of 30 km/h. In 2007, DARPA
moved the competition to an “urban” environment, an abandoned air force base. Vehicles had to be able to interact
with each other, following California traffic laws. As Stanford's Sebastian Thrun explained: “In the last Grand
Challenge, it didn't really matter whether an obstacle was a rock or a bush, because either way you'd just drive
around it. The current challenge is to move from just sensing the environment to understanding the environment.”
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 3.2 Artificial Intelligence
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:55 AM

An important application for the 
 statement is input validation. Whenever your program accepts user input, you need to
make sure that the user-supplied values are valid before you use them in your computations.
Like a quality control worker, you want to make sure that user input is correct before processing it.
Tetra Images/Media Bakery.
Consider our elevator program. Assume that the elevator panel has buttons labeled 1 through 20 (but not 13). The following
are illegal inputs:
•  The number 13
•  Zero or a negative number
•  A number larger than 20
•  A value that is not a sequence of digits, such as 
In each of these cases, we will want to give an error message and exit the program.
It is simple to guard against an input of 13:
The statement
immediately exits the 
 function and therefore terminates the program. It is a convention to return with the value 0 if the
program completed normally, and with a non-zero value when an error was encountered.
Application: Input Validation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 9:56 AM

Here is how you ensure that the user doesn't enter a number outside the valid range:
However, dealing with an input that is not a valid integer is a more serious problem. When the statement
is executed, and the user types in an input that is not an integer (such as 
), then the integer variable 
 is not set.
Instead, the input stream 
 is set to a failed state. You call the 
 member function to test for that failed state.
The order of the 
 statements is important. You must first test for 
. After all, if the input failed, no value has
been assigned to 
, and it makes no sense to compare it against other values.
Use the 
 function to test whether stream input
has failed.
Input failure is quite serious in C++. Once input has failed, all subsequent attempts at input will fail as well. You will learn in
Chapter 8 how to write programs that are more tolerant of bad input. For now, our goal is simply to detect bad input and to
exit the program when it occurs.
Here is the complete elevator program with input validation.
ch03/elevator2.cpp
The following statements check various input errors
Application: Input Validation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 9:56 AM

Now we know that the input is valid
Program Run
13
Self Check
27.  Consider the 
 program. What output do you get when the input is 
(a)  100
(b)  -1
(c)  20
(d)  thirteen
28.  Your task is to rewrite the 
 program so that there is a single 
 statement with a complex
condition: 
What is the condition?
29.  In the Sherlock Holmes story “The Adventure of the Sussex Vampire”, the inimitable detective uttered these
words: “Matilda Briggs was not the name of a young woman, Watson,… It was a ship which is associated
with the giant rat of Sumatra, a story for which the world is not yet prepared.” Over a hundred years later,
researchers found giant rats in Western New Guinea, another part of Indonesia.
Application: Input Validation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 9:56 AM

When processing inputs, you want to reject values that are too large. But how large is too large? These
giant rats, found in Western New Guinea, are about five times the size of a city rat.
Bruce M. BEEHLER/AFP/Getty Images.
Suppose you are charged with writing a program that processes rat weights. It contains the statements
What input checks should you supply?
30.  Consider the following test program: 
Run this program and enter 
 at the first prompt. What happens? Why?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Application: Input Validation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 9:56 AM

1.  The 
 statement allows a program to carry out different actions depending on the nature of the data to be processed.
Creatas/Media Bakery.
2.  Relational operators (
) are used to compare numbers and strings.
Paul Kooi/iStockphoto.
3.  Lexicographic order is used to compare strings.
Corbis Digital Stock.
4.  Multiple 
 statements can be combined to evaluate complex decisions.
Kevin Russ/iStockphoto.
5.  When using multiple 
 statements, pay attention to the order of the conditions.
6.  The Boolean type 
 has two values, 
 and 
.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:56 AM

© 2008 Sidney Harris.
7.  C++ has two Boolean operators that combine conditions: 
 (and) and 
 (or).
8.  To invert a condition, use the  (not) operator.
9.  The 
 and 
 operators are computed lazily: As soon as the truth value is determined, no further conditions are
evaluated.
10.  De Morgan's law tells you how to negate 
 and 
 conditions.
11.  Use the 
 function to test whether stream input has failed.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:56 AM

Exercise R3.1.    
Find the errors in the following 
 statements.
(a)  
(b)  
(c)  
(d)  
Exercise R3.2.    
What do these code fragments print?
(a)  
(b)  
(c)  
(d)  
Exercise R3.3.    
Suppose  and  are variables of type 
. Write a code fragment that sets  to  if  is positive and to 0 otherwise.
Exercise R3.4.    
Suppose  and  are variables of type 
. Write a code fragment that sets  to the absolute value of  without calling
the 
 function. Use an 
 statement.
Exercise R3.5.    
Explain why it is more difficult to compare floating-point numbers than integers. Write C++ code to test whether an
integer  equals 10 and whether a floating-point number  equals 10.
Exercise R3.6.    
Common Error 3.2 on page 92 explains that a C++ compiler will not report an error when you use an assignment operator
instead of a test for equality, but it may issue a warning. Write a test program containing a statement
What does your compiler do when you compile the program?
Exercise R3.7.    
Each square on a chess board can be described by a letter and number, such as 
 in this example:
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 9:56 AM

The following pseudocode describes an algorithm that determines whether a square with a given letter and number is dark
(black) or light (white).
If the letter is an a, c, e, or g
{
    If the number is odd
    {
        color = "black"
    }
    Else
    {
       color = "white"
    }
}
Else
{
   If the number is even
   {
       color = "black"
   }
   Else
   {
      color = "white"
   }
}
Using the procedure in Productivity Hint 3.2 on page 105, trace this pseudocode with input 
.
Exercise R3.8.    
Give a set of four test cases for the algorithm of Exercise R3.7. that covers all branches.
Exercise R3.9.    
In a scheduling program, we want to check whether two appointments overlap. For simplicity, appointments start at a full
hour, and we use military time (with hours 0-24). The following pseudocode describes an algorithm that determines
whether the appointment with start time start1 and end time end1 overlaps with the appointment with start time start2
and end time end2 .
If start1 > start2
{
   s = start1
}
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 9:56 AM

Else
{
   s = start2
}
If end1 < end2
{
   e = endl
}
Else
{
   e = end2
}
If s < e
{
   The appointments overlap.
}
Else
{
   The appointments don't overlap.
}
Trace this algorithm with an appointment from 10-12 and one from 11-13, then with an appointment from 10-11 and one
from 12-13.
Exercise R3.10.    
Write pseudocode for a program that prompts the user for a month and day and prints out whether it is one of the following
four holidays:
•  New Year's Day (January 1)
•  Independence Day (July 4)
•  Veterans Day (November 11)
•  Christmas Day (December 25)
Exercise R3.11.    
Write pseudocode for a program that assigns letter grades for a quiz, according to the following table:
Exercise R3.12.    
Explain how the lexicographic ordering of strings in C++ differs from the ordering of words in a dictionary or telephone
book. Hint: Consider strings such as 
, wiley.com, 
, and 
.
Exercise R3.13.    
Of the following pairs of strings, which comes first in lexicographic order?
(a)  
(b)  
(c)  
(d)  
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 9:56 AM

(e)  
(f)  
(g)  
(h)  
(i)  
Exercise R3.14.    
Explain the difference between an 
 sequence and nested if statements. Give an example for each.
Exercise R3.15.    
Give an example for an 
 sequence where the order of the tests does not matter. Give an example where
the order of the tests matters.
Exercise R3.16.    
Give a set of test cases for the tax program in Exercise R3.18.. Manually compute the expected results.
Exercise R3.17.    
Make up another C++ code example that shows the dangling 
 problem, using the following statement. A student with
a GPA of at least 1.5, but less than 2, is on probation. With less than 1.5, the student is failing.
Exercise R3.18.    
Complete the following truth table by finding the truth values of the Boolean expressions for all combinations of the
Boolean inputs 
 and .
 
 
 
 
 
 
 
…
 
 
 
5 more combinations
 
 
 
…
 
 
 
Exercise R3.19.    
True or false? A 
 B is the same as B 
 A for any Boolean conditions A and B.
Exercise R3.20.    
The “advanced search” features of many search engines allow you to use Boolean operators for complex queries, such as
“(cats OR dogs) AND NOT pets”. Contrast these search operators with the Boolean operators in C++.
Exercise R3.21.    
Suppose the value of  is 
 and the value of  is 0. What is the value of the following expressions?
(a)  
(b)  
(c)  
(d)  
(e)  
(f)  
(g)  
(h)  
Exercise R3.22.    
Simplify the following expressions. Here,  is a variable of type 
.
(a)  
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 9:56 AM

(b)  
(c)  
(d)  
Exercise R3.23.    
Simplify the following statements. Here,  is a variable of type 
 and  is a variable of type 
.
(a)  
(Hint: What is the value of 
)
(b)  
(c)  
(d)  
Exercise R3.24.    
What is wrong with the following program?
Exercise R3.25.    
Reading numbers is surprisingly difficult because a C++ input stream looks at the input one character at a time. First, white
space is skipped. Then the stream consumes those input characters that can be a part of a number. Once the stream has
recognized a number, it stops reading if it finds a character that cannot be a part of a number. However, if the first
non-white space character is not a digit or a sign, or if the first character is a sign and the second one is not a digit, then the
stream fails.
Consider a program reading an integer:
For each of the following user inputs, circle how many characters have been read and whether the stream is in the failed
state or not.
(a)  
(b)  
(c)  
(d)  
(e)  
(f)  
(g)  
(h)  
(i)  
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 9:56 AM

Programming Exercises 
 
 
Exercise P3.1.     
Write a program that reads a temperature value and the letter C for Celsius or F for 
Fahrenheit. Print whether water is liquid, solid, or gaseous at the given temperature at sea 
level. 
 
Exercise P3.2.     
The boiling point of water drops by about one degree centigrade for every 300 meters (or 
1,000 feet) of altitude. Improve the program of Exercise P3.1. to allow the user to supply the 
altitude in meters or feet. 
 
Exercise P3.3.     
Write a program that translates a letter grade into a number grade. Letter grades are A, B, C, 
D, and F, possibly followed by + or -. Their numeric values are 4, 3, 2, 1, and 0. There is no 
F+ or F-. A + increases the numeric value by 0.3, a - decreases it by 0.3. However, an A+ has 
value 4.0.  
Enter a letter grade: B- 
The numeric value is 2.7. 
 
Exercise P3.4.     
Write a program that translates a number between 0 and 4 into the closest letter grade. For 
example, the number 2.8 (which might have been the average of several grades) would be 
converted to B-. Break ties in favor of the better grade; for example 2.85 should be a B. 
 
Exercise P3.5.     
Write a program that takes user input describing a playing card in the following shorthand 
notation:  
A
Ace 
2 … 10
Card values
J
Jack 
Q
Queen 
K
King 
D
Diamonds 
H
Hearts 
S
Spades 
C
Clubs 
 
Your program should print the full description of the card. For example,  
Enter the card notation: QS 
Queen of Spades 
 
Exercise P3.6.     
Write a program that prompts the user for a wavelength value and prints a description of the 
corresponding part of the electromagnetic spectrum, as given in Table 6. 

 
Table 6    Electromagnetic Spectrum
Type 
Wavelength (m) 
Frequency (Hz) 
Radio Waves 
> 10-1 
< 3 × 109 
Microwaves 
10-3 to 10-1 
3 × 109 to 3 × 1011 
Infrared 
7 × 10-7 to 10-3 
3 × 1011 to 4 × 1014 
Visible light 
4 × 10-7 to 7 × 10-7
4 × 1014 to 7.5 × 1014 
Ultraviolet 
10-8 to 4 × 10-7 
7.5 × 1014 to 3 × 1016 
X-rays 
10-11 to 10-8 
3 × 1016 to 3 × 1019 
Gamma rays 
 < 10-11 
 > 3 × 1019 
 
 
 
 
 
Exercise P3.7.     
Repeat Exercise P3.6., modifying the program so that it prompts for the frequency instead. 
 
Exercise P3.8.     
Repeat Exercise P3.6., modifying the program so that it first asks the user whether the input 
will be a wavelength or a frequency. 
 
Exercise P3.9.     
Write a program that reads in three floating-point numbers and prints the largest of the three 
inputs. For example:  
Please enter three numbers: 4 9 2.5 
The largest number is 9. 
 
Exercise P3.10.     
Write a program that reads in three strings and sorts them lexicographically.  
Enter three strings: Charlie Able Baker 
Able 
Baker 
Charlie 
 
Exercise P3.11.     
When two points in time are compared, each given as hours (in military time, ranging from 0 
and 23) and minutes, the following pseudocode determines which comes first.  
If hour1 < hour2 
{ 
   time1 comes first. 
} 
Else if hour1 and hour2 are the same 
{ 
   If minute1 < minute2 
   { 
      time1 comes first. 
   } 
   Else if minute1 and minute2 are the same 
   { 
      time1 and time2 are the same. 
   } 
   Else 

   { 
      time2 comes first. 
   } 
} 
Else 
{ 
   time2 comes first. 
} 
Write a program that prompts the user for two points in time and prints the time that comes 
first, then the other time. 
 
Exercise P3.12.     
The following algorithm yields the season (Spring, Summer, Fall, or Winter) for a given 
month and day.  
If month is 1, 2, or 3 { season = "Winter"} 
Else if month is 4, 5, or 6 { season = "Spring" } 
Else if month is 7, 8, or 9 { season = "Summer" } 
Else if month is 10, 11, or 12 { season = "Fall" } 
If month is divisible by 3 and day >= 21 
{ 
   If season is "Winter" { season = "Spring" } 
   Else if season is "Spring" { season = "Summer" } 
   Else if season is "Summer" { season = "Fall" } 
   Else { season = "Winter" } 
} 
Write a program that prompts the user for a month and day and then prints the season, as 
determined by this algorithm. 
 
Exercise P3.13.     
Write a program that reads in two floating-point numbers and tests whether they are the same 
up to two decimal places. Here are two sample runs.  
Enter two floating-point numbers: 2.0 1.99998 
They are the same up to two decimal places. 
Enter two floating-point numbers: 2.0 1.98999 
They are different. 
 
Exercise P3.14.     
Write a program to simulate a bank transaction. There are two bank accounts: checking and 
savings. First, ask for the initial balances of the bank accounts; reject negative balances. Then 
ask for the transactions; options are deposit, withdrawal, and transfer. Then ask for the 
account; options are checking and savings. Then ask for the amount; reject transactions that 
overdraw an account. At the end, print the balances of both accounts. 
 
Exercise P3.15.     
Write a program that reads in the name and salary of an employee. Here the salary will denote 
an hourly wage, such as $9.25. Then ask how many hours the employee worked in the past 
week. Be sure to accept fractional hours. Compute the pay. Any overtime work (over 40 hours 
per week) is paid at 150 percent of the regular wage. Print a paycheck for the employee. 
 
Exercise P3.16.     
Write a program that prompts for the day and month of the user's birthday and then prints a 
horoscope. Make up fortunes for programmers, like this:  
Please enter your birthday (month and day): 6 16 
Gemini are experts at figuring out the behavior of complicated programs. 

You feel where bugs are coming from and then stay one step ahead. Tonight, 
your style wins approval from a tough critic. 
Each fortune should contain the name of the astrological sign. (You will find the names and 
date ranges of the signs at a distressingly large number of sites on the Internet.) 
 
Exercise P3.17.     
The original U.S. income tax of 1913 was quite simple. The tax was  
 
•  1 percent on the first $50,000. 
 
•  2 percent on the amount over $50,000 up to $75,000. 
 
•  3 percent on the amount over $75,000 up to $100,000. 
 
•  4 percent on the amount over $100,000 up to $250,000. 
 
•  5 percent on the amount over $250,000 up to $500,000. 
 
•  6 percent on the amount over $500,000. 
 
There was no separate schedule for single or married taxpayers. Write a program that 
computes the income tax according to this schedule. 
 
Exercise P3.18.     
Write a program that computes taxes for the following schedule.  
 
If your status is Single and if the 
taxable income is over 
but not 
over 
the tax is 
of the amount 
over 
$0 
$8,000 
10% 
$0 
$8,000 
$32,000 
$800 + 15% 
$8,000 
$32,000 
  
$4,400 + 25% 
$32,000 
If your status is Married and if the 
taxable income is over 
but not 
over 
the tax is 
of the amount 
over 
$0 
$16,000 
10% 
$0 
$16,000 
$64,000 
$1,600 + 15% 
$16,000 
$64,000 
  
$8,800 + 25% 
$64,000 
 
 
 
 
 
Exercise P3.19.     
The tax.cpp program uses a simplified version of the 2008 U.S. income tax schedule. Look 
up the tax brackets and rates for the current year, for both single and married filers, and 
implement a program that computes the actual income tax. 
 
Exercise P3.20.     
Unit conversion. Write a unit conversion program that asks the users from which unit they 
want to convert (fl. oz, gal, oz, lb, in, ft, mi) and to which unit they want to convert (ml, l, g, 
kg, mm, cm, m, km). Reject incompatible conversions (such as gal → km). Ask for the value 
to be converted, then display the result:  
Convert from? gal 
Convert to? ml 
Value? 2.5 
2.5 gal = 9462.5 ml 
 

Exercise P3.21.     
Write a program that prompts the user to provide a single character from the alphabet. Print 
Vowel or Consonant, depending on the user input. If the user input is not a letter (between 
a and z or A and Z), or is a string of length > 1, print an error message. 
 
Exercise P3.22.     
Roman numbers. Write a program that converts a positive integer into the Roman number 
system. The Roman number system has digits  
I 
1 
V
5 
X
10 
L 
50 
C
100 
D
500 
M
1,000
 
Numbers are formed according to the following rules. (1) Only numbers up to 3,999 are 
represented. (2) As in the decimal system, the thousands, hundreds, tens, and ones are 
expressed separately. (3) The numbers 1 to 9 are expressed as  
I 
1
II 
2
III 
3
IV 
4
V 
5
VI 
6
VII 
7
VIII
8
IX 
9
 
As you can see, a I preceding a V or X is subtracted from the value, and you can never have 
more than three I's in a row. (4) Tens and hundreds are done the same way, except that the 
letters X, L, C and C, D, M are used instead of I, V, X, respectively. 
 
Your program should take an input, such as 1978, and convert it to Roman numerals, 
MCMLXXVIII. 
 
Exercise P3.23.     
Write a program that asks the user to enter a month (1 for January, 2 for February, and so on) 
and then prints the number of days in the month. For February, print “28 or 29 days”.  

Enter a month: 5 
30 days 
 
Exercise P3.24.     
A year with 366 days is called a leap year. A year is a leap year if it is divisible by four (for 
example, 1980), except that it is not a leap year if it is divisible by 100 (for example, 1900); 
however, it is a leap year if it is divisible by 400 (for example, 2000). There were no 
exceptions before the introduction of the Gregorian calendar on October 15, 1582 (1500 was a 
leap year). Write a program that asks the user for a year and computes whether that year is a 
leap year. 
 
 
 
 
 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved. 
 

1.  Change the 
 statement to
2.  85. 90. 85.
3.  The only difference is if 
 is 100. The statement in Self Check 2. sets 
 to 90; this
one sets it to 80.
4.  95. 100. 95
5.  
6.  (a) and (b) are both true, (c) is false.
7.  
8.  The values should be compared with == , not = .
9.  
10.  
11.  
12.  
13.  You could first set s to one of the three values:
14.  The 
 can be omitted, making it clear that the 
 branch is the sole alternative.
15.  No destruction of buildings
16.  Add a branch
17.  3200
18.  No. Then the computation is 0.10 × 32000 + 0.25 (32000 - 32000).
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 9:58 AM

19.  No. Their individual tax is $5,200 each, and if they married, they would pay $10,400. Actually, taxpayers in higher tax
brackets (which our program does not model) may pay higher taxes when they marry, a phenomenon known as the
marriage penalty.
20.  Change 
 in line 36 to 
 and add another branch after line 47:
21.  The higher tax rate is only applied on the income in the higher bracket. Suppose you are single and make $31,900. Should
you try to get a $200 raise? Absolutely: you get to keep 90 percent of the first $100 and 75 percent of the next $100.
22.  
23.  
24.  
25.  The same as the value of 
.
26.  You are guaranteed that there are no other values. With strings or integers, you would need to check that no values such
as 
 or -1 enter your calculations.
27.  (a) 
. (b) 
. (c) 
 (d) 
.
28.  
29.  Check for 
, to make sure a researcher didn't supply an input such as 
. Check for 
,
since any rat must surely have a positive weight. We don't know how giant a rat could be, but the New Guinea rats
weighed no more than 2 kg. A regular house rat (rattus rattus) weighs up to 0.2 kg, so we'll say that any weight > 10 kg
was surely an input error, perhaps confusing grams and kilograms. Thus, the checks are
30.  The first input fails. The value of  is unchanged. Because a previous input failed, the next input doesn't even try to get
additional keystrokes. It also fails, and  is unchanged. The program prints 
.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 9:58 AM

Worked Example 3.1
•
Extracting the Middle
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Extracting the Middle
Your task is to extract a string containing the middle character from a given string str. For
example, if the string is "crate", the result is the string "a". However, if the string has an even
number of letters, extract the middle two characters. If the string is "crates", the result is
"at".
Step 1
Decide upon the branching condition.
We need to take different actions for strings of odd and even length. Therefore, the condition
is
Is the length of the string odd?
In C++, you use the remainder of division by 2 to ﬁnd out whether a value is even or odd.
Then the test becomes
str.length() % 2 == 1?
Step 2
Give pseudocode for the work that needs to be done when the condition is fulﬁlled.
We need to ﬁnd the position of the middle character. If the length is 5, the position is 2.
In general,
position = str.length() / 2 (with the remainder discarded) 
result = str.substr(position, 1)
Step 3
Give pseudocode for the work (if any) that needs to be done when the condition is
not fulﬁlled. 
Again, we need to ﬁnd the position of the middle character. If the length is 6, the starting
position is 2, and the ending position is 3.
In general,
position = str.length() / 2 - 1
result = str.substr(position, 2)
Step 4
Double-check relational operators. 
Do we really want str.length() % 2 == 1? For example, when the length is 5, 5 % 2 is the remain-
der of the division 5 / 2, which is 1. In general, dividing an odd number by 2 leaves a
remainder of 1. (Actually, dividing a negative odd number by 2 leaves a remainder of –1, but
the string length is never negative.) Therefore, our condition is correct.
WORKED EXAMPLE 3.1
0
1
2
3
4
c
r
a
t
e
0
1
2
3
4
5
c
r
a
t
e
s

2
C++ for Everyone  •  CHAPTER 3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Step 5
Remove duplication.
Here is the statement that we have developed:
If str.length() % 2 == 1
{
position = str.length() / 2 (with remainder discarded)
result = str.substr(position, 1)
}
Else
{
position = str.length() / 2 - 1
result = str.substr(position, 2)
}
The second statement in each branch is almost identical, but the length of the substring dif-
fers. Let’s set the length in each branch:
If str.length() % 2 == 1
{
position = str.length() / 2 (with remainder discarded)
length = 1
}
Else
{
position = str.length() / 2 - 1
length = 2
}
result = str.substr(position, length)
Step 6
Test both branches.
We will use a different set of strings for testing. For an odd-length string, consider
"monitor". We get 
position = str.length() / 2 = 7 / 2 = 3 (with remainder discarded)
length = 1
result = str.substr(3, 1) = "i" 
For the even-length string "monitors", we get 
position = str.length() / 2 - 1 = 8 / 2 - 1 = 3 (with remainder discarded)
length = 2
result = str.substr(3, 2) = "it" 
Step 7
Assemble the if statement in C++.
Here’s the completed code segment.
if (str.length() % 2 == 1)
{
   position = str.length() / 2;
   length = 1;
}
else
{

Worked Example 3.1
•
Extracting the Middle
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   position = str.length() / 2 - 1;
   length = 2;
}
result = str.substr(position, length);

Chapter
   
    
    
Chapter Goals
•  To learn about 
, 
, and 
 loops
•  To avoid infinite loops and off-by-one errors
•  To understand nested loops
•  To implement programs that read and process data sets
•  To use a computer for simulations
This chapter presents the various iteration constructs that are available in C++. These constructs execute one or
more statements repeatedly until a goal is reached. You will see how the techniques that you learn in this chapter
can be applied to the processing of input data and the programming of simulations.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To learn abo ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 10:44 AM

In this section, you will learn how to repeatedly execute statements until a goal has been reached.
Because the interest earned also earns interest, a bank balance grows exponentially.
iStockphoto.
Recall the investment problem from Chapter 1. You put $10,000 into a bank account that earns 5 percent interest per year.
How many years does it take for the account balance to be double the original investment?
In Chapter 1 we developed the following algorithm for this problem:
Start with a year value of 0 and a balance of $10,000.
Repeat the following steps while the balance is less than $20,000
Add 1 to the year value
Multiply the balance value by 1.05 (a 5 percent increase)
Report the final year value as the answer
You now know how to define and update the variables in C++. What you don't yet know is how to carry out “Repeat steps
while the balance is less than $20,000”.
In a particle accelerator, subatomic particles traverse a loop-shaped tunnel multiple times, gaining the speed required for
physical experiments. Similarly, in computer science, statements in a loop are executed while a condition is true.
Fermi National Accelerator Laboratory/Photo Researchers, Inc.
In C++, the 
 statement implements such a repetition (see Syntax 4.1). The code
condition
The while Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 10:45 AM

statements
keeps executing the statements while the condition is true. In our case, we want to increment the year counter and add interest
while the balance is less than the target balance of $20,000:
Loops execute a block of code repeatedly while a
condition remains true.
A 
 statement is an example of a loop. If you draw a flowchart, the flow of execution loops again to the point where the
condition is tested (see Figure 1).
Figure 1   Flowchart of a 
 Loop
Here is the program that solves the investment problem. Figure 2 illustrates the program's execution.
The while Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 10:45 AM

Figure 2   Execution of the 
 Loop
ch04/doublinv.cpp
The while Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 10:45 AM



Productivity Hint 4.1
PRODUCTIVITY HINT 4.1 Hand-Tracing Loops
In Productivity Hint 3.2, you learned about the method of hand tracing. This method is particularly effective for
understanding how a loop works.
Consider this example. What value is printed?
There are three variables: 
, and 
.
The first two variables are initialized with 1729 and 0 before the loop is entered.
Now enter the loop. The variable 
 is set to 9 (the remainder of dividing 1729 by 10). The variable 
 is set
to 0 + 9 = 9. Finally,  becomes 172. (Recall that the remainder in the division 1729 / 10 is discarded because both
arguments are integers.). Cross out the old values and write the new ones under the old ones.
PRODUCTIVITY HINT 4.1 Hand-Tracing Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 10:47 AM

Since 
, we repeat the loop. Now 
 becomes 2, 
 is set to 9 + 2 = 11, and  is set to 17.
Because  is still not zero, we repeat the loop, setting 
 to 7, 
 to 11 + 7 = 18, and  to 1.
We enter the loop for one last time. Now 
 is set to 1, 
 to 19, and  becomes zero. The condition 
is now false, and we continue with the output statement after the loop. The value that is output is 19.
Of course, you can get the same answer by just running the code. The hope is that by hand-tracing, you gain an
insight. Consider again what happens in each iteration:
•  We extract the last digit of 
•  We add that digit to 
•  We strip the digit off 
In other words, the loop forms the sum of the digits in . You now know what the loop does for any value of ,
not just the one in the example.
Why would anyone want to form the sum of the digits? Operations of this kind are useful for checking the validity
PRODUCTIVITY HINT 4.1 Hand-Tracing Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 10:47 AM

of credit card numbers and other forms of ID numbers—see Exercise P4.2.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
PRODUCTIVITY HINT 4.1 Hand-Tracing Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 10:47 AM

Common Error 4.1
COMMON ERROR 4.1 Infinite Loops
A very annoying loop error is an infinite loop: a loop that runs forever and can be stopped only by killing the
program or restarting the computer. If there are output statements in the program, then reams and reams of output
flash by on the screen. Otherwise, the program just sits there and hangs, seeming to do nothing. On some systems,
you can kill a hanging program by hitting Ctrl + C. On others, you can close the window in which the program
runs.
A common reason for infinite loops is forgetting to update the variable that controls the loop:
Here the programmer forgot to add a 
 command in the loop. As a result, the year always stays at 1, and the
loop never comes to an end.
Another common reason for an infinite loop is accidentally incrementing a counter that should be decremented (or
vice versa). Consider this example:
The 
 variable really should have bezen decremented, not incremented. This is a common error because
incrementing counters is so much more common than decrementing that your fingers may type the ++ on autopilot.
As a consequence, 
 is always larger than 0, and the loop never ends. (Actually, 
 may eventually exceed
the largest representable positive integer and wrap around to a negative number. Then the loop ends—of course,
with a completely wrong result.)
COMMON ERROR 4.1 Infinite Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 10:48 AM

In this famous engraving by M.C. Escher, the hooded figures traverse an infinite loop, a loop that never ends.
M.C. Escher's “Ascending and Descending” © 2008 The M.C. Escher Company-Holland. All rights reserved.
www.mcescher.com.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 4.1 Infinite Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 10:48 AM

Common Error 4.2
COMMON ERROR 4.2 Don't Think “Are We There Yet?”
When doing something repetitive, most of us want to know when we are done. For example, you may think, “I
want to get at least $20,000,” and set the loop condition to
But the 
 loop thinks the opposite: How long am I allowed to keep going? The correct loop condition is
In other words: “Keep at it while the balance is less than the target”.
When writing a loop condition, don't ask, “Are we there yet?” The condition determines how long the loop will
keep going.
Karen Town/iStockphoto.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 4.2 Don't Think "Are We There Yet?"
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 10:48 AM

Common Error 4.3
COMMON ERROR 4.3 Off-by-One Errors
Consider our computation of the number of years that are required to double an investment:
Should 
 start at 0 or at 1? Should you test for 
 or for 
 It is
easy to be off by one in these expressions.
Some people try to solve off-by-one errors by randomly inserting 
 or 
 until the program seems to work—a
terrible strategy. It can take a long time to compile and test all the various possibilities. Expending a small amount
of mental effort is a real time saver.
Fortunately, off-by-one errors are easy to avoid, simply by thinking through a couple of test cases and using the
information from the test cases to come up with a rationale for your decisions.
An off-by-one error is a common error when
programming loops. Think through simple test
cases to avoid this type of error.
Should 
 start at 0 or at 1? Look at a scenario with simple values: an initial balance of $100 and an interest
rate of 50 percent. After year 1, the balance is $150, and after year 2 it is $225, or over $200. So the investment
doubled after 2 years. The loop executed two times, incrementing 
 each time. Hence 
 must start at 0,
not at 1.
In other words, the 
 variable denotes the balance after the end of the year. At the outset, the 
variable contains the balance after year 0 and not after year 1.
Next, should you use a  or 
 comparison in the test? This is harder to figure out, because it is rare for the
balance to be exactly twice the initial balance. There is one case when this happens, namely when the interest is 100
percent. The loop executes once. Now 
 is 1, and 
 is exactly equal to 
. Has the
investment doubled after one year? It has. Therefore, the loop should not execute again. If the test condition is
, the loop stops, as it should. If the test condition had been 
, the
COMMON ERROR 4.3 Off-by-One Errors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 10:48 AM

loop would have executed once more.
In other words, you keep adding interest while the balance has not yet doubled.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 4.3 Off-by-One Errors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 10:48 AM

Random Fact 4.1
RANDOM FACT 4.1 The First Bug
According to legend, the first bug was found in the Mark II, a huge electromechanical computer at Harvard
University. It really was caused by a bug—a moth was trapped in a relay switch.
Actually, from the note that the operator left in the log book next to the moth (see Figure 3), it appears as if the
term “bug” had already been in active use at the time.
Figure 3   The First Bug
Naval Surface Weapons Center, Dahlgren, VA.
The pioneering computer scientist Maurice Wilkes wrote: “Somehow, at the Moore School and afterwards, one
had always assumed there would be no particular difficulty in getting programs right. I can remember the exact
instant in time at which it dawned on me that a great part of my future life would be spent finding mistakes in my
own programs.”
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 4.1 The First Bug
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 10:49 AM

The for loop is used when a value runs from a starting
point to an ending point with a constant increment or
decrement.
It often happens that you want to execute a sequence of statements a given number of times. You can use a 
 loop that is
controlled by a counter, as in the following example:
Initialize the counter
Check the counter
Update the counter
Because this loop type is so common, there is a special form for it, called the 
 loop (see Syntax 4.2).
In general, the for loop:
initialization
condition
update
statements
has exactly the same effect as the 
 loop:
initialization
condition
statements
update
The for Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 6
2/1/2010 10:49 AM

You can visualize the for loop as an orderly sequence of steps.
Enrico Fianchini/iStockphoto.
When a loop is controlled by a counter, the 
 loop looks neater than a 
 loop because it groups the initialization,
condition, and update expressions together. However, it is important to realize that these expressions are not executed together
(see Figure 4).
•  The initialization is executed once, before the loop is entered. 
•  The condition is checked before each iteration. 
 
•  The update is executed after each iteration. 
The for Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 6
2/1/2010 10:49 AM

Figure 4   Execution of a 
 Loop
A 
 loop can count down instead of up:
The increment or decrement need not be in steps of 1:
See Table 2 on page 150 for additional variations.
Table 2    
 Loop Examples
Loop
Values of 
Comment
0 1 2 3 4 5
Note that the loop is executed 6 times. (See
Quality Tip 4.3 on page 151.)
5 4 3 2 1 0
Use 
 for decreasing values.
0 2 4 6 8
Use 
 for a step size of 2.
0 2 4 6 8 10 12 14 …
(infinite loop)
You can use < or <= instead of != to avoid this
problem.
The for Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 6
2/1/2010 10:49 AM

Loop
Values of 
Comment
1 2 4 8 16
You can specify any rule for modifying , such as
doubling it in every step.
0 1 2 … until the last
valid index of the string
In the loop body, use the expression
 to get a string containing the
th character.
So far, we assumed that the 
 variable had already been defined before the 
 loop. Alternatively, you can define a
variable in the loop initialization. Such a variable is defined only in the loop:
 no longer defined here
Here is a typical use of the 
 loop. We want to print the balance of our savings account over a period of years, as shown in
this table:
Year
Balance
1
10500.00
2
11025.00
3
11576.25
4
12155.06
5
12762.82
The 
 loop pattern applies because the variable 
 starts at 1 and then moves in constant increments until it reaches the
target:
Update balance.
Print year and balance.
Here is the complete program. Figure 5 shows the corresponding flowchart.
The for Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 6
2/1/2010 10:49 AM

Figure 5   Flowchart of a 
 Loop
ch04/invtable.cpp
The for Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 6
2/1/2010 10:49 AM

Program Run
10
Self Check
6.  Write the 
 loop of the 
 program as a 
 loop. 
7.  How many numbers does this loop print? 
8.  Write a 
 loop that prints all even numbers between 10 and 20 (inclusive). 
9.  Write a 
 loop that computes the sum of the integers from 1 to . 
10.  How would you modify the 
 loop of the 
 program to print all balances until the
investment has doubled? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The for Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 6
2/1/2010 10:49 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 4.2 for Statement
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 10:49 AM

Quality Tip 4.1
QUALITY TIP 4.1 Use 
 Loops for their Intended Purpose Only
A 
 loop is an idiom for a loop of a particular form. A value runs from the start to the end, with a constant
increment or decrement.
The compiler won't check whether the initialization, condition, and update expressions are related. For example,
the following loop is legal:
Confusing–unrelated expressions
However, programmers reading such a 
 loop will be confused because it does not match their expectations.
Use a 
 loop for iterations that do not follow the 
 idiom.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 4.1 Use for Loops for their Intended Purpose Only
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 10:49 AM

Quality Tip 4.2
QUALITY TIP 4.2 Choose Loop Bounds that Match Your Task
Suppose you want to print line numbers that go from 1 to 10. Of course, you will want to use a loop
The values for  are bounded by the relation 
≤
≤
. Because there are ≤ on both bounds, the bounds are
called symmetric.
When traversing the characters in a string, it is more natural to use the bounds
In this loop,  traverses all valid positions in the string. You can access the th character as 
.
The values for  are bounded by 
≤
, with a ≤ to the left and a < to the right. That is
appropriate, because 
 is not a valid position. Such bounds are called asymmetric.
In this case, it is not a good idea to use symmetric bounds:
Use < instead
The asymmetric form is easier to understand.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 4.2 Choose Loop Bounds that Match Your Task
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 10:50 AM

Quality Tip 4.3
QUALITY TIP 4.3 Count Iterations
Finding the correct lower and upper bounds for an iteration can be confusing. Should you start at 0 or at 1? Should
you use 
 or 
 as a termination condition?
Counting the number of iterations is a very useful device for better understanding a loop. Counting is easier for
loops with asymmetric bounds. The loop
is executed 
 times. For example, the loop traversing the characters in a string,
runs 
 times. That makes perfect sense, since there are 
 characters in a string.
The loop with symmetric bounds,
is executed 
 times. That “+1” is the source of many programming errors.
For example,
runs 11 times. Maybe that is what you want; if not, start at 1 or use < 10.
One way to visualize this “+1” error is by looking at a fence. Each section has one fence post to the left, and there
is a final post on the right of the last section. Forgetting to count the last value is often called a “fence post error”.
QUALITY TIP 4.3 Count Iterations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 10:50 AM

How many posts do you need for a fence with four sections? It is easy to be “off by one” with problems such as
this one.
iStockphoto.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 4.3 Count Iterations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 10:50 AM

The do loop is appropriate when the loop body must be
executed at least once.
Sometimes you want to execute the body of a loop at least once and perform the loop test after the body is executed. The do
loop serves that purpose:
statements
condition
The body of the 
 loop is executed first, then the condition is tested.
A typical example for such a loop is input validation. Suppose you ask a user to enter a value < 100. If the user didn't pay
attention and entered a larger value, you ask again, until the value is correct. Of course, you cannot test the value until the user
has entered it. This is a perfect fit for the 
 loop (see Figure 6):
The do Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 10:50 AM

Figure 6   Flowchart of a do Loop
Self Check
11.  Suppose that we want to check for inputs that are at least 0 and at most 100. Modify the 
 loop for this
check. 
12.  Rewrite the input check using a 
 loop. What is the disadvantage of your solution? 
13.  Suppose C++ didn't have a 
 loop. Could you rewrite any 
 loop as a 
 loop? 
14.  Write a 
 loop that reads integers and computes their sum. Stop when reading the value 0. 
15.  Write a 
 loop that reads positive integers and computes their sum. Stop when reading the same value twice
in a row. For example, if the input is 1 2 3 4 4, then the sum is 14 and the loop stops. 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The do Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 10:50 AM

How To 4.1
HOW TO 4.1 Writing a Loop
This How To walks you through the process of implementing a loop statement. We will illustrate the steps with the following example problem:
Steve Geer/iStockphoto.
Read twelve temperature values (one for each month), and display the number of the month with the highest temperature. For example, according
to http://worldclimate.com, the average maximum temperatures for Death Valley are (in order by month):
18.2
22.6
26.4
31.1
36.6
42.2
45.7
44.5
40.2
33.1
24.2
17.6
In this case, the month with the highest temperature (45.7 degrees Celsius) is July, and the program should display 7.
Step 1  Decide what work must be done inside the loop.
Every loop needs to do some kind of repetitive work, such as
•  Reading another item.
•  Updating a value (such as a bank balance or total).
•  Incrementing a counter.
If you can't figure out what needs to go inside the loop, start by writing down the steps that you would take if you solved the
problem by hand. For example, with the temperature reading problem, you might write
Read first value
Read second value
If second value is higher than the first, set highest temperature to that value, highest month to 2
Read next value
If value is higher than the first and second, set highest temperature to that value, highest month to 3
Read next value
If value is higher than the highest temperature seen so far, set highest temperature to that value,
highest month to 4
Now look at these steps and reduce them to a set of uniform actions that can be placed into the loop body. The first action is easy:
Read next value
The next action is trickier. In our description, we used tests “higher than the first”, “higher than the first and second”, “higher than
the highest temperature seen so far”. We need to settle on one test that works for all iterations. The last formulation is the most
general.
Similarly, we must find a general way of setting the highest month. We need a variable that stores the current month, running from
1 to 12. Then we can formulate the second loop action:
If value is higher than the highest temperature, set highest temperature to that value,
highest month to current month
HOW TO 4.1 Writing a Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 10:50 AM

Altogether our loop is
Loop
{
Read next value
If value is higher than the highest temperature, set highest temperature to that value
highest month to current month
Increment current month
}
Step 2  Specify the loop condition.
What goal do you want to reach in your loop? Typical examples are
•  Has the counter reached the final value?
•  Have you read the last input value?
•  Has a value reached a given threshold?
In our example, we simply want the current month to reach 12.
Step 3  Find out how often the loop is repeated, and choose the loop type.
•  If you know in advance how many times a loop is repeated, use a 
 loop.
•  If the loop must be executed at least once, use a 
 loop.
•  Otherwise, use a 
 loop.
In our example, we read 12 temperature values. Therefore, we choose a 
 loop.
Step 4  Set up variables for entering the loop for the first time.
List all variables that are used and updated in the loop, and determine how to initialize them. Commonly, counters are initialized
with 0 or 1, totals with 0.
In our example, the variables are
current month
highest value
highest month
We need to be careful how we set up the highest temperature value. We can't simply set it to 0. After all, our program needs to
work with temperature values from Antarctica, all of which may be negative.
A good option is to set the highest temperature value to the first input value. Of course, then we need to remember to only read in
another 11 values, with the current month starting at 2.
We also need to initialize the highest month with 1. After all, in an Australian city, we may never find a month that is warmer than
January.
Step 5  Process the result after the loop has finished.
In many cases, the desired result is simply a variable that was updated in the loop body. For example, in our temperature program,
the result is the highest month. Sometimes, the loop computes values that contribute to the final result. For example, suppose you
are asked to average the temperatures. Then the loop should compute the sum, not the average. After the loop has completed, you
are ready compute the average: divide the sum by the number of inputs.
Here is our complete loop.
Read first value; store as highest value
highest month = 1
for (current month = 2; current month <= 12; current month++)
{
Read next value
If value is higher than the highest value, set highest value to that value
highest month to current month
}
Step 6  Trace the loop with typical examples.
Hand trace your loop code, as described in Productivity Hint 4.1 on page 141. Choose example values that are not too complex
—executing the loop 3–5 times is enough to check for the most common errors. Pay special attention when entering the loop for
the first and last time.
Sometimes, you want to make a slight modification to make tracing feasible. For example, when hand tracing the investment
doubling problem, use an interest rate of 20 percent rather than 5 percent. When hand tracing the temperature loop, use 4 data
values, not 12.
Let's say the data are 22.6 36.6 44.5 24.2. Here is the walkthrough:
HOW TO 4.1 Writing a Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 10:50 AM

The trace demonstrates that highest month and highest value are properly set.
Step 7  Implement the loop in C++.
Here's the loop for our example. Exercise P4.1. asks you to complete the program.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
HOW TO 4.1 Writing a Loop
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 10:50 AM

Worked Example 4.1
WORKED EXAMPLE 4.1 Credit Card Processing
One of the minor annoyances of online shopping is that many web sites require you to enter a credit card without
spaces or dashes, which makes double-checking the number rather tedious. How hard can it be to remove dashes or
spaces from a string? Not hard at all, as this worked example shows.
Your task is to remove all spaces or dashes from a string 
. For example, if
 is 
, then you should set it to
Step 1  Decide what work must be done inside the loop.
In the loop, we visit each character in turn. You can get the th character as
If it is not a dash or space, we move on to the next character. If it is a dash or space, we remove the
offending character.
Loop
{
ch = the ith character of credit_card_number
If ch is a space or dash
{
Remove the character from credit_card_number.
}
Else
{
Increment i.
}
}
You may wonder how to remove a character from a string in C++. Here is the procedure for
removing the character at position : Take the substrings that end before  and start after , and
concatenate them.
WORKED EXAMPLE 4.1 Credit Card Processing
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 10:50 AM

Note that we do not increment  after removing a character. For example, in the figure above,  was
4, and we removed the dash at position 4. The next time we enter the loop, we want to reexamine
position 4 which now contains the character 5.
Step 2  Specify the loop condition.
We stay in the loop while the index  is a valid position. That is,
Step 3  Find out how often the loop is repeated, and choose the loop type.
We don't know at the outset how often the loop is repeated. It depends on the number of dashes and
spaces that we find. Therefore, we will choose a 
 loop. Why not a do loop? If we are given an
empty string (because the user has not provided any credit card number at all), we do not want to
enter the loop at all.
Step 4  Process the result after the loop has finished.
In this case, the result is simply the string.
Step 5  Trace the loop with typical examples.
The complete loop is
i = 0
While i < credit_card_number.length()
{
ch = the ith character of credit_card_number.
If ch is a space or dash
{
Remove the character from credit_card_number.
}
Else
{
Increment i.
}
}
It is a bit tedious to trace a string with 20 characters, so we will use a shorter example:
WORKED EXAMPLE 4.1 Credit Card Processing
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 10:50 AM

Step 6  Implement the loop in C++.
Here's the complete program, 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
WORKED EXAMPLE 4.1 Credit Card Processing
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 10:50 AM

 
In Section 3.4, you saw how to nest two 
 statements. Similarly, complex iterations sometimes require a nested loop: a loop
inside another loop statement. When processing tables, nested loops occur naturally. An outer loop iterates over all rows of the
table. An inner loop deals with the columns in the current row.
Nested loops are commonly used for processing
tabular structures.
In this section you will see how to print a table. For simplicity, we will simply print powers xn, as in the table at right.
Here is the pseudocode for printing the table.
Print table header.
For x from 1 to 10
{
Print table row.
Print endl.
}
x1
x2
x3
x4
1
1
1
1
2
4
8
16
3
9
27
81
…
…
…
…
10
100
1000
10000
How do you print a table row? You need to print a value for each exponent. This requires a second loop.
For n from 1 to 4
{
Print xn.
}
This loop must be placed inside the preceding loop. We say that the inner loop is nested inside the outer loop.
There are 10 rows in the outer loop. For each x, the program prints four columns in the inner loop. Thus, a total of 10 × 4 = 40
values are printed.
Nested Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 10:51 AM

The hour and minute displays in a digital clock are an example of nested loops. The hours loop 12 times, and for each hour,
the minutes loop 60 times.
david kahn/iStockphoto.
Here is the complete program. Note that we also use loops to print the table header. However, those loops are not nested.
ch04/powtable.cpp
Print table header
Print table body
Print table row
Program Run
Nested Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 10:51 AM

Table 3    Nested Loop Examples
Nested Loops
Output
Explanation
Prints 3 rows of 4 asterisks each.
Prints 4 rows of 3 asterisks each.
Prints 4 rows of lengths 1, 2, 3, and
4.
Prints asterisks in even columns,
dashes in odd columns.
Prints a checkerboard pattern.
Self Check
Nested Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 10:51 AM

16.  Why is there a statement 
 in the outer loop but not in the inner loop? 
17.  How would you change the program so that all powers from x0 to x5 are displayed? 
18.  If you make the change in Self Check 17., how many values are displayed? 
19.  What do the following nested loops display? 
20.  Write nested loops that make the following pattern of brackets: 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Nested Loops
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 10:51 AM

In this section, you will learn how to read and process a sequence of input values.
A sentinel value denotes the end of a data set, but it is
not part of the data.
Whenever you read a sequence of inputs, you need to have some method of indicating the end of the sequence. Sometimes you
are lucky and no input value can be zero. Then you can prompt the user to keep entering numbers, or 0 to finish the sequence. If
zero is allowed but negative numbers are not, you can use -1 to indicate termination.
Such a value, which is not an actual input, but serves as a signal for termination, is called a sentinel.
In the military, a sentinel guards a border. In computer science, a sentinel value denotes the border between a data set and
unrelated input.
Altrendo Travel/Getty Images.
Let's put this technique to work in a program that computes the average of a set of salary values. In our sample program, we
will use -1 as a sentinel. An employee would surely not work for a negative salary, but there may be volunteers who work for
free.
Inside the loop, we read an input. If the input is not -1, we process it. In order to compute the average, we need the total sum of
all salaries, and the number of inputs.
We stay in the loop while the sentinel value is not detected.
Processing Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 10:51 AM

There is just one problem: When the loop is entered for the first time, no data value has been read. We must make sure to
initialize 
 with some value other than the sentinel:
 // Any value other than -1 will do
After the loop has finished, we compute and print the average. Here is the complete program.
ch04/sentinel.cpp
Program Run
10 10 40 -1
Sentinels only work if there is some restriction on the input. In many cases, though, there isn't. Suppose you want to compute
the average of a data set that may contain 0 or negative values. Then you cannot use 0 or -1 to indicate the end of the input.
In such a situation, you can read input data until input fails. As you have seen in Section 3.6, the condition
is 
 if the preceding input has failed. For example, suppose that the input was read with these statements:
Processing Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 10:51 AM

If the user enters a value that is not a number (such as ), then the input fails.
You can use a Boolean variable to control a loop. Set
the variable to 
 before entering the loop, then set it
to 
 to leave the loop.
We now encounter an additional complexity. You only know that input failed after you have entered the loop and attempted to
read it. To remember the failure, use a Boolean variable:
Process value.
Some programmers dislike the introduction of a Boolean variable to control a loop. Advanced Topic 4.1 on page 163 shows
an alternative mechanism for leaving a loop. However, when reading from a stream, there is an easier way. The expression
can be used in a condition. It evaluates to 
 if the stream has not failed after reading 
. Therefore, you can read and
process a set of inputs with the following loop:
Process value.
This loop is suitable for processing a single sequence of inputs. You will learn more about reading inputs in Chapter 8.
Self Check
21.  What does the 
 program print when the user immediately types -1 when prompted for a
value? 
22.  Why does the 
 program have two checks of the form 
23.  What would happen if the definition of the 
 variable in 
 was changed to
Processing Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 10:51 AM

24.  We prompt the user “Enter values, Q to quit.” What happens when the user enters a different letter?
25.  What is wrong with the following loop for reading a sequence of values? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Processing Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 10:51 AM

Advanced Topic 4.1
ADVANCED TOPIC 4.1 The Loop-and-a-Half Problem and the Break
Statement
Some programmers dislike loops that are controlled by a Boolean variable, such as:
Process value.
The actual test for loop termination is in the middle of the loop, not at the top. This is called a loop and a half
because one must go halfway into the loop before knowing whether one needs to terminate.
As an alternative, you can use the 
 reserved word.
Process value.
The 
 statement breaks out of the enclosing loop, independent of the loop condition.
In the loop-and-a-half case, 
 statements can be beneficial. But it is difficult to lay down clear rules as to
when they are safe and when they should be avoided. We do not use the 
 statement in this book.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 4.1 The Loop-and-a-Half Problem and the Break St...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 10:51 AM

In a simulation program, you use the computer to
simulate an activity. You can introduce randomness by
calling the random number generator.
A simulation program uses the computer to simulate an activity in the real world (or an imaginary one). Simulations are
commonly used for predicting climate change, analyzing traffic, picking stocks, and many other applications in science and
business. In the following sections, you will learn how to implement simulations that model phenomena with a degree of
randomness.
4.6.1 Generating Random Numbers
Many events in the real world are difficult to predict with absolute precision, yet we can sometimes know the average behavior
quite well. For example, a store may know from experience that a customer arrives every five minutes. Of course, that is an
average—customers don't arrive in five minute intervals. To accurately model customer traffic, you want to take that random
fluctuation into account. Now, how can you run such a simulation in the computer?
The C++ library has a random number generator, which produces numbers that appear to be completely random. Calling
 yields a random integer between  and 
 (which is an implementation-dependent constant, typically, but not
always, the largest valid 
 value). Call 
 again, and you get a different number. The 
 function is defined in the
 header.
The following program calls the 
 function ten times.
ch04/random.cpp
Program Run
Random Numbers and Simulations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 10:52 AM

Actually, the numbers are not completely random. They are drawn from very long sequences of numbers that don't repeat for a
long time. These sequences are actually computed from fairly simple formulas; they just behave like random numbers. For that
reason, they are often called pseudorandom numbers.
Try running the program again. You will get the exact same output! This confirms that the random numbers are generated by
formulas. However, when running simulations, you don't always want to get the same results. To overcome this problem,
specify a seed for the random number sequence. Every time you use a new seed, the random number generator starts generating
a new sequence. The seed is set with the 
 function. A simple value to use as a seed is the current time:
Simply make this call once in your program, before generating any random numbers. Then the random numbers will be
different in every program run.
4.6.2 Simulating Die Tosses
In actual applications, you need to transform the output from the random number generator into different ranges. For example,
to simulate the throw of a die, you need random numbers between 1 and 6.
Kiyoshi Takahase/iStockphoto.
Here is the general recipe for computing random integers between two bounds  and . As you know from Quality Tip 4.3 on
page 151, there are 
 values between  and , including the bounds themselves. First compute 
 to obtain a random value between  and 
, then add , yielding a random value between  and :
Here is a program that simulates the throw of a pair of dice:
ch04/dice.cpp
Random Numbers and Simulations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 10:52 AM

Program Run
4.6.3 The Monte Carlo Method
The Monte Carlo method is an ingenious method for finding approximate solutions to problems that cannot be precisely
solved. (The method is named after the famous casino in Monte Carlo.) Here is a typical example. It is difficult to compute the
number π, but you can approximate it quite well with the following simulation.
Tim Starkey/iStockphoto.
Simulate shooting a dart into a square surrounding a circle of radius 1. That is easy: generate random x and y coordinates
between -1 and 1.
Random Numbers and Simulations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 10:52 AM

If the generated point lies inside the circle, we count it as a hit. That is the case when x2 + y2 ≤ 1. Because our shots are entirely
random, we expect that the ratio of hits / tries is approximately equal to the ratio of the areas of the circle and the square, that
is, π / 4. Therefore, our estimate for π is 4 × hits / tries. This method yields an estimate for π, using nothing but simple
arithmetic.
To run the Monte Carlo simulation, you have to work a little harder with random number generation. When you throw a die, it
has to come up with one of six faces. When throwing a dart, however, there are many possible outcomes. You must generate a
random floating-point number.
First, generate the following value:
Between 0 and 1
The value  is a random floating-point value between 0 and 1. (You have to multiply by 
 to ensure that one of the
operands of the / operator is a floating-point number. The division 
 would be an integer division—see
Common Error 2.3.)
To generate a random value between -1 and 1, you compute:
Between -1 and 1
As  ranges from 0 to 1,  ranges from -1 + 2 × 0 = -1 to -1 + 2 × 1 = 1.
Here is the program that carries out the simulation.
ch04/montecarlo.cpp
Between 0 and 1
Between -1 and 1
Program Run
Random Numbers and Simulations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 10:52 AM

Self Check
26.  How do you simulate a coin toss with the 
 function? 
27.  How do you simulate the picking of a random playing card? 
28.  Why does the 
 file include the 
 header? 
29.  In many games, you throw a pair of dice to get a value between 2 and 12. What is wrong with this simulated
throw of a pair of dice? 
30.  How do you generate a random floating-point number between 0 and 100? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Random Numbers and Simulations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 10:52 AM

Random Fact 4.2
RANDOM FACT 4.2 Software Piracy
As you read this, you have written a few computer programs, and you have experienced firsthand how much effort
it takes to write even the humblest of programs. Writing a real software product, such as a financial application or
a computer game, takes a lot of time and money. Few people, and fewer companies, are going to spend that kind of
time and money if they don't have a reasonable chance to make more money from their effort. (Actually, some
companies give away their software in the hope that users will upgrade to more elaborate paid versions. Other
companies give away the software that enables users to read and use files but sell the software needed to create
those files. Finally, there are individuals who donate their time, out of enthusiasm, and produce programs that you
can copy freely.)
When selling software, a company must rely on the honesty of its customers. It is an easy matter for an
unscrupulous person to make copies of computer programs without paying for them. In most countries that is
illegal. Most governments provide legal protection, such as copyright laws and patents, to encourage the
development of new products. Countries that tolerate widespread piracy have found that they have an ample cheap
supply of foreign software, but no local manufacturers willing to design good software for their own citizens, such
as word processors in the local script or financial programs adapted to the local tax laws.
Don Bayley/iStockphoto.
When a mass market for software first appeared, vendors were enraged by the money they lost through piracy. They
tried to fight back by various schemes to ensure that only the legitimate owner could use the software. Some
manufacturers used key disks: disks with special patterns of holes burned in by a laser, which couldn't be copied.
Others used dongles: devices that are attached to a printer port. Legitimate users hated these measures. They paid
for the software, but they had to suffer through the inconvenience of inserting a key disk every time they started the
software or having multiple dongles stick out from their computer. In the United States, market pressures forced
most vendors to give up on these copy protection schemes, but they are still commonplace in other parts of the
world.
Because it is so easy and inexpensive to pirate software, and the chance of being found out is minimal, you have to
make a moral choice for yourself. If a package that you would really like to have is too expensive for your budget,
do you steal it, or do you stay honest and get by with a more affordable product?
RANDOM FACT 4.2 Software Piracy
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 10:52 AM

Of course, piracy is not limited to software. The same issues arise for other digital products as well. You may have
had the opportunity to obtain copies of songs or movies without payment. Or you may have been frustrated by a
copy protection device on your music player that made it difficult for you to listen to songs that you paid for.
Admittedly, it can be difficult to have a lot of sympathy for a musical ensemble whose publisher charges a lot of
money for what seems to have been very little effort on their part, at least when compared to the effort that goes
into designing and implementing a software package. Nevertheless, it seems only fair that artists and authors
receive some compensation for their efforts. How to pay artists, authors, and programmers fairly, without
burdening honest customers, is an unsolved problem at the time of this writing, and many computer scientists are
engaged in research in this area.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 4.2 Software Piracy
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 10:52 AM

1.  Loops execute a block of code repeatedly while a condition remains true.
Fermi National Accelerator Laboratory/Photo Researchers, Inc.
2.  An off-by-one error is a common error when programming loops. Think through simple test cases to avoid this type of
error.
iStockphoto.
3.  The 
 loop is used when a value runs from a starting point to an ending point with a constant increment or
decrement.
Enrico Fianchini/iStockphoto.
4.  The 
 loop is appropriate when the loop body must be executed at least once.
5.  Nested loops are commonly used for processing tabular structures.
david kahn/iStockphoto.
6.  A sentinel value denotes the end of a data set, but it is not part of the data.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 10:52 AM

Altrendo Travel/Getty Images.
7.  You can use a Boolean variable to control a loop. Set the variable to 
 before entering the loop, then set it to
 to leave the loop.
8.  In a simulation program, you use the computer to simulate an activity. You can introduce randomness by calling the
random number generator.
Kiyoshi Takahase/iStockphoto.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 10:52 AM

Exercise R4.1.    
Write a loop that computes
(a)  The sum of all even numbers between 2 and 100 (inclusive).
(b)  The sum of all squares between 1 and 100 (inclusive).
(c)  The sum of all odd numbers between  and  (inclusive).
(d)  The sum of all odd digits of . (For example, if  is 
, the sum would be 3 + 7 + 7 = 17.)
Exercise R4.2.    
Provide trace tables for these loops.
(a)  
(b)  
(c)  
(d)  
Exercise R4.3.    
What do these loops print?
(a)  
(b)  
(c)  
(d)  
(e)  
(f)  
Exercise R4.4.    
What is an infinite loop? On your computer, how can you terminate a program that executes an infinite loop?
Exercise R4.5.    
What is an “off-by-one” error? Give an example from your own programming experience.
Exercise R4.6.    
What is a sentinel value? Give a simple rule when it is appropriate to use a numeric sentinel value.
Exercise R4.7.    
Which loop statements does C++ support? Give simple rules when to use each loop type.
Exercise R4.8.    
Is the following code legal?
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 10:52 AM





Exercise P4.1.    
Complete the program in How To 4.1 on page 154. Your program should read twelve temperature values and print the
month with the highest temperature.
Exercise P4.2.    
Credit Card Number Check. The last digit of a credit card number is the check digit, which protects against transcription
errors such as an error in a single digit or switching two digits. The following method is used to verify actual credit card
numbers but, for simplicity, we will describe it for numbers with 8 digits instead of 16:
•  Starting from the rightmost digit, form the sum of every other digit. For example, if the credit card number is 4358
9795, then you form the sum 5 + 7 + 8 + 3 = 23.
•  Double each of the digits that were not included in the preceding step. Add all digits of the resulting numbers. For
example, with the number given above, doubling the digits, starting with the next-to-last one, yields 18 18 10 8.
Adding all digits in these values yields 1 + 8 + 1 + 8 + 1 + 0 + 8 = 27.
•  Add the sums of the two preceding steps. If its last digit of the result is 0, the number is valid. In our case,
23 + 27 = 50, so the number is valid.
Write a program that implements this algorithm. The user should supply an 8-digit number, and you should print out
whether the number is valid or not. If it is not valid, you should print out the value of the check digit that would make the
number valid.
Exercise P4.3.    
Currency conversion. Write a program that first asks the user to type today's exchange rate between U.S. dollars and
Japanese yen, then reads U.S. dollar values and converts each to yen. Use 0 as a sentinel.
Exercise P4.4.    
Write a program that first asks the user to type in today's exchange rate between U.S. dollars and Japanese yen, then reads
U.S. dollar values and converts each to Japanese yen. Use 0 as the sentinel value to denote the end of dollar inputs. Then the
program reads a sequence of yen amounts and converts them to dollars. The second sequence is terminated by another zero
value.
Exercise P4.5.    
Write a program that reads a set of floating-point values. Ask the user to enter the values, then print
•  the average of the values.
•  the smallest of the values.
•  the largest of the values.
•  the range, that is the difference between the smallest and largest.
Of course, you may only prompt for the values once.
Exercise P4.6.    
Translate the following pseudocode for finding the minimum value from a set of inputs into a C++ program.
Set a Boolean variable "first" to true.
While another value has been read successfully
{
If first is true
{
Set the minimum to the value.
Set first to false.
}
Else if the value is less than the minimum
{
Set the minimum to the value.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 7
2/1/2010 10:52 AM

}
}
Print the minimum.
Exercise P4.7.    
Translate the following pseudocode for randomly permuting the characters in a string into a C++ program.
Read a word.
Repeat word.length() times
{
Pick a random position i in the word.
Pick a random position j > i in the word.
Swap the letters at positions j and i.
}
Print the word.
To swap the letters, construct substrings as follows:
Then replace the string with
Exercise P4.8.    
Write a program that reads a word and prints each character of the word on a separate line. For example, if the user
provides the input 
, the program prints
Exercise P4.9.    
Write a program that reads a word and prints the word in reverse. For example, if the user provides the input “
”, the
program prints
Exercise P4.10.    
Write a program that reads a word and prints the number of vowels in the word. For this exercise, assume that 
 are vowels. For example, if the user provides the input “
”, the program prints 
.
Exercise P4.11.    
Write a program that reads a word and prints the number of syllables in the word. For this exercise, assume that syllables
are determined as follows: Each sequence of vowels 
, except for the last  in a word, is a vowel. However,
if that algorithm yields a count of 0, change it to 1. For example,
Exercise P4.12.    
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 7
2/1/2010 10:52 AM

Write a program that reads a word and prints all substrings, sorted by length. For example, if the user provides the input
“
”, the program prints
Exercise P4.13.    
Write a program that prints all powers of 2 from 20 up to 220.
Exercise P4.14.    
Write a program that reads a number and prints all of its binary digits: Print the remainder 
, then replace the
number with 
. Keep going until the number is 0. For example, if the user provides the input 13, the output
should be
Exercise P4.15.    
Mean and standard deviation. Write a program that reads a set of floating-point data values. Choose an appropriate
mechanism for prompting for the end of the data set. When all values have been read, print out the count of the values, the
average, and the standard deviation. The average of a data set {x1, …, xn} is 
, where 
 is
the sum of the input values. The standard deviation is
However, this formula is not suitable for the task. By the time the program has computed , the individual xi are long gone.
Until you know how to save these values, use the numerically less stable formula
You can compute this quantity by keeping track of the count, the sum, and the sum of squares as you process the input
values.
Exercise P4.16.    
The Fibonacci numbers are defined by the sequence
Reformulate that as
After that, discard 
, which is no longer needed, and set 
 to 
 and 
 to 
. Repeat 
 an
appropriate number of times.
Implement a program that computes the Fibonacci numbers in that way.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 7
2/1/2010 10:52 AM

Exercise P4.17.    
Factoring of integers. Write a program that asks the user for an integer and then prints out all its factors. For example,
when the user enters 150, the program should print
Exercise P4.18.    
Prime numbers. Write a program that prompts the user for an integer and then prints out all prime numbers up to that
integer. For example, when the user enters 20, the program should print
Recall that a number is a prime number if it is not divisible by any number except 1 and itself.
Exercise P4.19.    
Write a program that prints a multiplication table, like this:
Exercise P4.20.    
Write a program that reads an integer and displays, using asterisks, a filled and hollow square, placed next to each other.
For example if the side length is 5, the program should display
Exercise P4.21.    
Write a program that reads an integer and displays, using asterisks, a filled diamond of the given side length. For example,
if the side length is 4, the program should display
Exercise P4.22.    
Projectile flight. Suppose a cannonball is propelled straight into the air with a starting velocity v0. Any calculus book will
state that the position of the ball after t seconds is 
, where g = 9.81 m/sec2 is the gravitational force
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 7
2/1/2010 10:52 AM

of the earth. No calculus book ever mentions why someone would want to carry out such an obviously dangerous
experiment, so we will do it in the safety of the computer.
In fact, we will confirm the theorem from calculus by a simulation. In our simulation, we will consider how the ball moves
in very short time intervals Δt. In a short time interval the velocity v is nearly constant, and we can compute the distance the
ball moves as Δs = vΔt. In our program, we will simply set
and update the position by
The velocity changes constantly—in fact, it is reduced by the gravitational force of the earth. In a short time interval,
Δv = -gΔt, we must keep the velocity updated as
In the next iteration the new velocity is used to update the distance.
Now run the simulation until the cannonball falls back to the earth. Get the initial velocity as an input (100 m/sec is a good
value). Update the position and velocity 100 times per second, but print out the position only every full second. Also print
out the values from the exact formula 
 for comparison.
What is the benefit of this kind of simulation when an exact formula is available? Well, the formula from the calculus
book is not exact. Actually, the gravitational force diminishes the further the cannonball is away from the surface of the
earth. This complicates the algebra sufficiently that it is not possible to give an exact formula for the actual motion, but the
computer simulation can simply be extended to apply a variable gravitational force. For cannonballs, the calculus-book
formula is actually good enough, but computers are necessary to compute accurate trajectories for higher-flying objects
such as ballistic missiles.
Exercise P4.23.    
The game of Nim. This is a well-known game with a number of variants. The following variant has an interesting winning
strategy. Two players alternately take marbles from a pile. In each move, a player chooses how many marbles to take. The
player must take at least one but at most half of the marbles. Then the other player takes a turn. The player who takes the
last marble loses.
You will write a program in which the computer plays against a human opponent. Generate a random integer between 10
and 100 to denote the initial size of the pile. Generate a random integer between 0 and 1 to decide whether the computer or
the human takes the first turn. Generate a random integer between 0 and 1 to decide whether the computer plays smart or
stupid. In stupid mode the computer simply takes a random legal value (between 1 and n/2) from the pile whenever it has a
turn. In smart mode the computer takes off enough marbles to make the size of the pile a power of two minus 1—that is, 3,
7, 15, 31, or 63. That is always a legal move, except when the size of the pile is currently one less than a power of two. In
that case, the computer makes a random legal move.
You will note that the computer cannot be beaten in smart mode when it has the first move, unless the pile size happens to
be 15, 31, or 63. Of course, a human player who has the first turn and knows the winning strategy can win against the
computer.
Exercise P4.24.    
The Drunkard's Walk. A drunkard in a grid of streets randomly picks one of four directions and stumbles to the next
intersection, then again randomly picks one of four directions, and so on. You might think that on average the drunkard
doesn't move very far because the choices cancel each other out, but that is actually not the case.
Represent locations as integer pairs (x, y). Implement the drunkard's walk over 100 intersections and print the beginning
and ending location.
Exercise P4.25.    
The Monty Hall Paradox. Marilyn vos Savant described the following problem (loosely based on a game show hosted by
Monty Hall) in a popular magazine: “Suppose you're on a game show, and you're given the choice of three doors: Behind
one door is a car; behind the others, goats. You pick a door, say No. 1, and the host, who knows what's behind the doors,
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 7
2/1/2010 10:52 AM

opens another door, say No. 3, which has a goat. He then says to you, “Do you want to pick door No. 2?” Is it to your
advantage to switch your choice?”
Ms. vos Savant proved that it is to your advantage, but many of her readers, including some mathematics professors,
disagreed, arguing that the probability would not change because another door was opened.
Your task is to simulate this game show. In each iteration, randomly pick a door number between 1 and 3 for placing the
car. Randomly have the player pick a door. Randomly have the game show host pick one of the two doors having a goat.
Now increment a counter for strategy 1 if the player wins by switching to the third door, and increment a counter for
strategy 2 if the player wins by sticking with the original choice. Run 1,000 iterations and print both counters.
Exercise P4.26.    
The Buffon Needle Experiment. The following experiment was devised by Comte Georges-Louis Leclerc de Buffon
(1707–1788), a French naturalist. A needle of length 1 inch is dropped onto paper that is ruled with lines 2 inches apart. If
the needle drops onto a line, we count it as a hit. (See Figure 7.) Buffon conjectured that the quotient tries/hits
approximates π.
Figure 7   The Buffon Needle Experiment
For the Buffon needle experiment, you must generate two random numbers: one to describe the starting position and one to
describe the angle of the needle with the x-axis. Then you need to test whether the needle touches a grid line.
Generate the lower point of the needle. Its x-coordinate is irrelevant, and you may assume its y-coordinate ylow to be any
random number between 0 and 2. The angle α between the needle and the x-axis can be any value between 0 degrees and
180 degrees (π radians). The upper end of the needle has y-coordinate
The needle is a hit if yhigh is at least 2, as shown in Figure 8.
Figure 8   A Hit in the Buffon Needle Experiment
Stop after 10,000 tries and print the quotient tries/hits. (This program is not suitable for computing the value of π. You
need π in the computation of the angle.)
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 7
2/1/2010 10:52 AM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 7
2/1/2010 10:52 AM

1.  23 years.
2.  7 years.
3.  Add a statement
as the last statement in the 
 loop.
4.  The program prints the same output. This is because the balance after 14 years is slightly below $20,000, and after 15
years, it is slightly above $20,000.
5.  
Note that the value 128 is printed even though it is larger than 100.
6.  
7.  11 numbers: 
8.  
9.  
10.  
However, it is best not to use a 
 loop in this case because the loop condition does not relate to the 
 variable. A
 loop would be a better choice.
11.  
12.  
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 10:53 AM

Here, the variable value had to be initialized with an artificial value to ensure that the loop is entered at least once.
13.  Yes. The do loop
body
condition
is equivalent to this while loop:
condition
body
14.  
15.  
16.  All values in the inner loop should be displayed on the same line.
17.  Change lines 14, 19, and 31 to 
. Change 
 to 5.
18.  60: The outer loop is executed 10 times, and the inner loop 6 times.
19.  
20.  
21.  
22.  The first check ends the loop after the sentinel has been read. The second check ensures that the sentinel is not processed
as an input value.
23.  The 
 loop would never be entered. The user would never be prompted for input. Since 
 stays 0, the program
would then print “
”.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 10:53 AM

24.  The stream also fails. A more accurate prompt would have been: “Enter values, a key other than a digit to quit.” But that
might be more confusing to the program user who would need now ponder which key to choose.
25.  You don't know whether the input fails until after you try reading input.
26.  Compute 
, and use 0 for heads, 1 for tails, or the other way around.
27.  Compute 
 and associate the numbers 0 … 3 with the four suits. Then compute 
 and
associate the numbers 0 … 12 with Jack, Ace, 2 … 10, Queen, and King
28.  It is required for calling the 
 function.
29.  The call will produce a value between 2 and 12, but all values have the same probability. When throwing a pair of dice,
the number 7 is six times as likely as the number 2. The correct formula is
30.  
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 10:53 AM

Worked Example 4.1
•
Credit Card Processing
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Credit Card Processing
One of the minor annoyances of online shopping is that many web sites require you to enter
a credit card without spaces or dashes, which makes double-checking the number rather
tedious. How hard can it be to remove dashes or spaces from a string? Not hard at all, as this
worked example shows. 
Your task is to remove all spaces or dashes from a string credit_card_number. For example, if
credit_card_number is "4123-5678-9012-3450", then you should set it to "4123567890123450"
Step 1
Decide what work must be done inside the loop.
In the loop, we visit each character in turn. You can get the ith character as
string ch = credit_card_number.substr(i, 1);
If it is not a dash or space, we move on to the next character. If it is a dash or space, we
remove the offending character. 
Loop
{
ch = the ith character of credit_card_number
If ch is a space or dash
{
Remove the character from credit_card_number.
}
Else 
{
Increment i.
}
}
You may wonder how to remove a character from a string in C++. Here is the procedure for
removing the character at position i: Take the substrings that end before i and start after i,
and concatenate them.
WORKED EXAMPLE 4.1
i
4
1
2
3
-
5
6
7
8
-
9
0
1
2
-
3
4
5
0
before
after

2
C++ for Everyone  •  CHAPTER 4
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
string before = credit_card_number.substr(0, i);
string after = credit_card_number.substr(i + 1);
credit_card_number = before + after;
Note that we do not increment i after removing a character. For example, in the ﬁgure above,
i was 4, and we removed the dash at position 4. The next time we enter the loop, we want to
reexamine position 4 which now contains the character 5.
Step 2
Specify the loop condition.
We stay in the loop while the index i is a valid position. That is, 
i < credit_card_number.length()
Step 3
Find out how often the loop is repeated, and choose the loop type.
We don’t know at the outset how often the loop is repeated. It depends on the number of
dashes and spaces that we ﬁnd. Therefore, we will choose a while loop. Why not a do loop?
If we are given an empty string (because the user has not provided any credit card number at
all), we do not want to enter the loop at all.
Step 4
Process the result after the loop has ﬁnished.
In this case, the result is simply the string. 
Step 5
Trace the loop with typical examples.
The complete loop is
i = 0
While i < credit_card_number.length()
{
ch = the ith character of credit_card_number.
If ch is a space or dash
{
Remove the character from credit_card_number.
}
Else 
{
Increment i.
}
}
It is a bit tedious to trace a string with 20 characters, so we will use a shorter example: 
 credit_card_number 
i 
ch
 
4-56-7 
0 
4
 
4-56-7 
1 
-
 
456-7 
1 
5
 
456-7 
2 
6
 
456-7 
3 
-
 
4567 
3 
7

Worked Example 4.1
•
Credit Card Processing
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Step 6
Implement the loop in C++. 
Here’s the complete program, ch04/ccnumber.cpp.
#include <iostream>
#include <string>
using namespace std;
int main()
{
   string credit_card_number = "4123-5678-9012-3450";
   int i = 0;
   while (i < credit_card_number.length())
   {
      string ch = credit_card_number.substr(i, 1);
      if (ch == " " || ch == "-")
      {
         string before = credit_card_number.substr(0, i);
         string after = credit_card_number.substr(i + 1);
         credit_card_number = before + after;
      }
      else
      {
         i++;
      }
   }
   cout << credit_card_number << endl;
   return 0;
}

Chapter
   
    
    
Chapter Goals
•  To be able to implement functions
•  To become familiar with the concept of parameter passing
•  To appreciate the importance of function comments
•  To develop strategies for decomposing complex tasks into simpler ones
•  To be able to determine the scope of a variable
•  To recognize when to use value and reference parameters
Functions are a fundamental building block of C++ programs. A function packages a computation into a form
that can be easily understood and reused. In this chapter, you will learn how to design and implement your own
functions, and how to break up complex tasks into sets of cooperating functions.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To be able t ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:19 PM

A function is a sequence of instructions with a name. You have already encountered several functions. For example, the
function named 
, which was introduced in Chapter 2, contains instructions to compute a power xy. Moreover, every C++
program has a function called 
.
A function is a named sequence of instructions.
You call a function in order to execute its instructions. For example, consider the following program:
By using the expression 
 calls the 
 function, asking it to compute 23. The 
 function is temporarily
suspended. The instructions of the 
 function execute and compute the result. The 
 function returns its result back to
, and the 
 function resumes execution (see Figure 1).
  Figure 1   Execution Flow During a Function Call
When another function calls the 
 function, it provides “inputs”, such as the values  and  in the call 
. In order
to avoid confusion with inputs that are provided by a human user, these values are called parameter values. The “output”
that the 
 function computes is called the return value.
Functions can have multiple parameter values, but they have only one return value.
Parameter values are supplied when a function is
called. The return value is the result that the function
computes.
Functions as Black Boxes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:19 PM

Note that the return value of a function is returned to the calling function, not displayed on the screen. For example, suppose
your program contains a statement
When the 
 function returns its result, the return value is stored in the variable . If you want the value to be displayed, you
need to add a statement such as 
.
At this point, you may wonder how the 
 function performs its job. For example, how does 
 compute that 23 is
8? By multiplying 2 × 2 × 2? With logarithms? Fortunately, as a user of the function, you don't need to know how the
function is implemented. You just need to know the specification of the function: If you provide parameter values x and y, the
function returns xy. Engineers use the term black box for a device with a given specification but unknown implementation.
You can think of 
 as a black box, as shown in Figure 2.
Even though a thermostat is usually white, you can think of it as a black box. The input is the desired temperature, and the
output is a signal to the heater or air conditioner.
Yenwen Lu/iStockphoto.
  Figure 2   The 
 Function as a Black Box
When you design your own functions, you will want to make them appear as black boxes to other programmers. Those
programmers want to use your functions without knowing what goes on inside. Even if you are the only person working on a
program, making each function into a black box pays off: there are fewer details that you need to keep in mind.
Self Check
1.  Consider the function call 
. What are the parameter and return values? 
2.  What is the return value of the function call 
? 
3.  The 
 function in the C++ standard library takes a single parameter value x and returns the smallest
integer ≥ x. What is the return value of 
? 
4.  It is possible to determine the answer to Self Check 3. without knowing how the 
 function is
Functions as Black Boxes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:19 PM

implemented. Use an engineering term to describe this aspect of the 
function. 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Functions as Black Boxes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:19 PM

5.2  Implementing Functions 
 
 
In this section, you will learn how to implement a function from a given specification. We will 
use a very simple example: a function to compute the volume of a cube with a given side length.  
 
 
The cube_volume function uses a given side length to compute the volume of a cube.
dieter Spears/iStockphoto. 
 
 
 
 
When defining a function, you provide a 
name for the function, a name and type 
for each parameter, and a type for the 
result. 
 
 
 
 
When writing this function, you need to  
 
• Pick a name for the function (cube_volume). 
 
• Give a type and a name for each parameter variable (double side_length). 
 
• Specify the type of the return value (double). 
 
Put all this information together to form the first line of the function's definition:  
double cube_volume(double side_length) 
Next, specify the body of the function: the statements that are executed when the function is 
called. 
 
The volume of a cube of side length s is s × s × s. However, for greater clarity, our parameter 
variable has been called side_length, not s, so we need to compute side_length * 
side_length * side_length. 
 
We will store this value in a variable called volume:  
double volume = side_length * side_length * side_length; 
In order to return the result of the function, use the return statement:  
return volume; 
The body of a function is enclosed in braces. Here is the complete function:  
double cube_volume(double side_length) 
{
   double volume = side_length * side_length * side_length; 
   return volume; 
}
Let's put this function to use. We'll supply a main function that calls the cube_volume 
function twice.  

int main() 
{
   double result1 = cube_volume(2); 
   double result2 = cube_volume(10); 
   cout << "A cube with side length 2 has volume " << result1 << endl; 
   cout << "A cube with side length 10 has volume " << result2 << endl; 
   return 0; 
}
When the function is called with different parameter values, the function returns different results. 
Consider the call cube_volume(2). The parameter value 2 corresponds to the 
side_length parameter variable. Therefore, in this call, side_length is 2. The function 
computes side_length * side_length * side_length, or 2 * 2 * 2. When the 
function is called with a different parameter value, say 10, then the function computes 10 * 
10 * 10. 
 
Now we combine both functions into a test program. Because main calls cube_volume, the 
cube_volume function must be known before the main function is defined. This is easily 
achieved by placing cube_volume first and main last in the source file. (See Advanced Topic 
5.1 on page 197 for an alternative.) Here is the complete program. Note the comment that 
describes the behavior of the function. (Productivity Hint 5.1 on page 191 describes the format of 
the comment.) 
 
ch05/cube.cpp
 
1  #include <iostream> 
2
3
using namespace std; 
4
5  /** 
6
Computes the volume of a cube.
7     @param side_length the side length of the cube
8     @return the volume
9  */ 
10
double cube_volume(double side_length) 
11  { 
12
double volume = side_length * side_length * side_length; 
13
return volume; 
14  } 
15
16
int main() 
17  { 
18
double result1 = cube_volume(2);
19
double result2 = cube_volume(10);
20     cout << "A cube with side length 2 has volume " << result1 << endl; 
21     cout << "A cube with side length 10 has volume " << result2 << endl; 
22
23
return 0; 
24  } 
Program Run 

A cube with side length 2 has volume 8 
A cube with side length 10 has volume 1000 
 
 
 
  
 
Self Check
 
 
 
 
5.  What is the value of cube_volume(3)? 
 
 
 
6.  What is the value of cube_volume(cube_volume(2))? 
 
 
 
7.  Provide an alternate implementation of the body of the cube_volume function 
by calling the pow function. 
 
 
 
8.  Define a function square_area that computes the area of a square of a given 
side length. 
 
 
 
9.  Consider this function: 
 
int mystery(int x, int y) 
{
   double result = (x + y) / (y - x); 
   return result; 
}
What is the result of the call mystery(2, 3)? 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
Productivity Hint 5.1 
 
 
 
 
 
 
PRODUCTIVITY HINT 5.1 Function Comments 
 
 
Whenever you write a function, you should comment its behavior. Comments are for 
human readers, not compilers, and there is no universal standard for the layout of a 
function comment. In this book, we will use the following layout:  
/**
   Computes the volume of a cube. 
   @param side_length the side length of the cube 
   @return the volume 
*/
double cube_volume(double side_length) 
{
   double volume = side_length * side_length * side_length; 
   return volume; 
}
 
This particular documentation style is borrowed from the Java programming language. 
It is widely supported by C++ tools as well, for example by the Doxygen tool 
(http://www.stack.nl/~dimitri/doxygen/).  
 
Function comments explain the 
purpose of the function, the 
meaning of the parameters and 
return value, as well as any special 
requirements. 
 
 
 
 
The first line of the comment describes the purpose of the function. Each @param 
clause describes a parameter variable and the @return clause describes the return 
value. 
 
Note that the function comment does not document the implementation (how the 
function does what it does) but rather the design (what the function does, its inputs, 
and its results). The comment allows other programmers to use the function as a 
“black box”. 
 
 
 
 
 
 
 

 
 
 
Productivity Hint 5.2 
 
 
 
 
PRODUCTIVITY HINT 5.2 Turn Repeated Code Into a Function 
 
 
When you write nearly identical code multiple times, you should probably introduce a 
function. Consider these statements:  
int hours; 
do
{
   cout << "Enter a value between 1 and 12: "; 
   cin >> hours; 
}
while (hours < 1 || hours > 12); 
int minutes; 
do
{
   cout << "Enter a value between 0 and 59: "; 
   cin >> minutes; 
}
while (minutes < 0 || minutes > 59); 
Here, we read two variables, making sure that each of them is within a certain range. It is 
easy to extract the common behavior into a function:  
/**
   Prompts a user to enter a value in a given range until the user 
   provides a valid input. 
   @param low the low end of the range 
   @param high the high end of the range 
   @return the value provided by the user 
*/
int read_value_between(int low, int high) 
{
   int input; 
   do 
   { 
      cout << "Enter a value between " << low << " and " << high << ": ";
      cin >> input; 
   } 
   while (input < low || input > high); 
   return input; 
}
Then use this function twice:  
int hours = read_value_between(1, 12); 
int minutes = read_value_between(0, 59); 
Note how the code has become much easier to understand. 
5.3  Parameter Passing 
 

 
In this section, we examine the mechanism of parameter passing more closely. When a 
function is called, a variable is created for each parameter. This variable is called a 
parameter variable. (Another commonly used term is formal parameter.) In the function 
call, a value is supplied for each parameter, called the parameter value. (Other commonly 
used terms for this value are actual parameter and argument.) Each parameter variable is 
initialized with the corresponding parameter value. 
 
Consider the function call illustrated in Figure 3:  
double result1 = cube_volume(2); 
• The parameter variable side_length of the cube_volume function is created. 
 
 
• The parameter variable is initialized with the value that was passed in the call. In our 
case, side_length is set to 2. 
 
 
• The function computes the expression side_length * side_length * 
side_length, which has the value 8. That value is stored in the variable volume. 
 
 
• The function returns. All of its variables are removed. The return value is transferred 
to the caller, that is, the function calling the cube_volume function. 
 
 
 
 
 
 
 
 
 
  Figure 3   Parameter Passing
 
 
 

 
 
 
A recipe for a fruit pie may say to use any kind of fruit. Here, “fruit” is an example 
of a parameter variable. 
Klaudia Steiner/iStockphoto (cherries); christine balderas/iStockphoto (cherry pie); 
iStockphoto (apples); dieter Spears/iStockphoto (apple pie). 
 
 
Now consider what happens in a subsequent call cube_volume(10). A new parameter 
variable is created. (Recall that the previous parameter variable was removed when the first 
call to cube_volume returned.) It is initialized with 10, and the process repeats. After the 
second function call is complete, its variables are again removed. 
 
 
 
 
Self Check
 
 
 
 
 
10.  What does this program print? Use a diagram like Figure 3 to find the 
answer. 
 
double mystery(int x, int y) 
{
   double z = x + y; 
   z = z / 2.0; 
   return z; 
}
int main() 
{
   int a = 5; 
   int b = 7; 
   cout << mystery(a, b) << endl; 
}
 
 
11.  What does this program print? Use a diagram like Figure 3 to find the 
answer. 
 
int mystery(int x) 
{
   int y = x * x; 
   return y; 
}
int main() 
{
   int a = 4; 
 

   cout << mystery(a + 1) << endl; 
}
 
 
12.  What does the following program print? Use a diagram like Figure 3 to find 
the answer. 
 
int mystery(int n) 
{
   n++; 
   n++; 
   return n; 
}
int main() 
{
   int a = 5; 
   cout << mystery(a) << endl; 
}
 
 
 
 
 
 
 
 
 
 
 
Quality Tip 5.1 
 
 
 
 
 
QUALITY TIP 5.1 Do Not Modify Parameter Variables 
 
 
In C++, a parameter variable is just like any other variable. You can modify 
the values of the parameter variables in the body of a function. For example,  
int total_cents(int dollars, int cents) 
{
   cents = dollars * 100 + cents; // Modifies parameter 
variable
   return cents; 
}
 
However, many programmers find this practice confusing. It mixes the 
concept of a parameter (input to the function) with that of a variable (storage 
for a value). To avoid the confusion, simply introduce a separate variable: 
 
int total_cents(int dollars, int cents) 
{
   int result = dollars * 100 + cents; 
   return result; 
}
 
5.4  Return Value 
 
 
You use the return statement to specify the result of a function. When the return 
statement is processed, the function exits immediately. This behavior is convenient for 
handling exceptional cases at the beginning:  
double cube_volume(double side_length) 

{
if (side_length < 0) return 0;
   double volume = side_length * side_length * side_length; 
   return volume; 
}
If the function is called with a negative value for side_length, then the function 
returns 0 and the remainder of the function is not executed. (See Figure 4.)  
 
 
The return statement terminates a 
function call and yields the function 
result. 
 
 
 
 
 
 
 
 
   Figure 4   A return Statement Exits a Function Immediately 
 
Natalia Bratslavsky/iStockphoto. 
 
 
 
In the preceding example, each return statement returned a constant or a variable. 
Actually, the return statement can return the value of any expression. Instead of saving 
the return value in a variable and returning the variable, it is often possible to eliminate 
the variable and return a more complex expression:  
double cube_volume(double side_length) 
{
return side_length * side_length * side_length;
}
It is important that every branch of a function return a value. Consider the following 
incorrect function:  
double cube_volume(double side_length) 
{
   if (side_length >= 0) 
   { 
      return side_length * side_length * side_length; 
   } // Error 
}
Suppose you call cube_volume with a negative value for the side length. Of course, 

you are't supposed to call that, but it might happen as the result of a coding error. Because 
the if condition is not true, the return statement is not executed. However, the 
function must return something. Depending on circumstances, the compiler might flag 
this as an error, or the function might return a random value. Protect against this problem 
by returning some safe value:  
double cube_volume(double side_length) 
{
   if (side_length >= 0) 
   { 
      return side_length * side_length * side_length; 
   } 
return 0;
}
The last statement of every function ought to be a return statement. This ensures that 
some value gets returned when the function reaches the end. 
 
 
 
 
 
 
Common Error 5.1 
 
 
 
 
 
COMMON ERROR 5.1 Missing Return Value 
 
 
A function always needs to return something. If the code of the function 
contains several branches, make sure that each one of them returns a value:  
int sign(double x) 
{
   if (x < 0) return -1; 
   if (x > 0) return 1; 
   // Error: missing return value if x equals 0 
}
This function computes the sign of a number: -1 for negative numbers and +1 
for positive numbers. If the parameter value is zero, however, no value is 
returned. Most compilers will issue a warning in this situation, but if you 
ignore the warning and the function is ever called with a parameter value of 0, 
a random quantity will be returned. 
 
 
 
 
 
 
 
 
 
 
 
 
Advanced Topic 5.1 
 
 
 
 
 

ADVANCED TOPIC 5.1 Function Declarations 
 
 
Functions need to be known before they can be used. This can be achieved 
easily if you first define lower-level helper functions, then the midlevel 
workhorse functions, and finally main in your program. 
 
Some programmers prefer to list the main function first in their programs. If 
you share that preference, you need to learn how to declare the other functions 
at the top of the program. A declaration of a function lists the return type, 
function name, and parameter variables, but it contains no body:  
double cube_volume(double side_length); 
This is an advertisement that promises that the function is implemented 
elsewhere. It is easy to distinguish declarations from definitions: Declarations 
end in a semicolon, whereas definitions are followed by a {…} block. 
Declarations are also called prototypes. 
 
The declarations of common functions such as pow are contained in header 
files. If you have a look inside cmath, you will find the declaration of pow 
and the other math functions. 
 
Here is an alternate organization of the cube.cpp file:  
#include <iostream> 
using namespace std; 
// Declaration of cube_volume 
double cube_volume(double side_length); 
int main() 
{
   double result1 = cube_volume(2); // Use of cube_volume 
   double result2 = cube_volume(10); 
   cout << "A cube with side length 2 has volume 
" << result1 << endl; 
   cout << "A cube with side length 10 has volume 
" << result2 << endl; 
   return 0; 
}
// Definition of cube_volume 
double cube_volume(double side_length) 
{
   return side_length * side_length * side_length; 
}
If you prefer this approach, go ahead and use it in your programs. You just 
need to be aware of one drawback. Whenever you change the name of a 
function or one of the parameter types, you need to fix it in both places: in the 

declaration and in the definition. 
 
 
 
 
 
 
 
 
 
 
 
How To 5.1 
 
 
 
 
 
HOW TO 5.1 Implementing a Function 
 
 
A function is a computation that can be used multiple times with different 
parameter values, either in the same program or in different programs. 
Whenever a computation is needed more than once, turn it into a function.  
 
 
Turn computations that can be 
reused into functions. 
 
 
 
 
To illustrate this process, suppose that you are helping archaeologists who 
research Egyptian pyramids. You have taken on the task of writing a function 
that determines the volume of a pyramid, given its height and base length.  
 
 
Holger Mette/iStockphoto. 
 
 
 
Step 1   Describe what the function should do. 
Provide a simple English description, such as “Compute the volume 
of a pyramid whose base is a square.” 
 
Step 2   Determine the function's “inputs”. 
Make a list of all the parameters that can vary. It is common for 
beginners to implement functions that are overly specific. For 
example, you may know that the great pyramid of Giza, the largest 
of the Egyptian pyramids, has a height of 146 meters and a base 
 

length of 230 meters. You should not use these numbers in your 
calculation, even if the original problem only asked about the great 
pyramid. It is just as easy–and far more useful–to write a function 
that computes the volume of any pyramid. 
In our case, the parameters are the pyramid's height and base 
length. At this point, we have enough information to document the 
function:  
/**
   Computes the volume of a pyramid whose base is a 
square.
   @param height the height of the pyramid 
   @param base_length the length of one side of the 
pyramid's base 
   @return the volume of the pyramid 
*/
 
Step 3   Determine the types of the parameters and the return value. 
The height and base length can both be floating-point numbers. 
Therefore, we will choose the type double for both parameter 
variables. The computed volume is also a floating-point number, 
yielding a return type of double. Therefore, the function will be 
defined as  
double pyramid_volume(double height, double 
base_length)
 
Step 4   Write pseudocode for obtaining the desired result. 
In most cases, a function needs to carry out several steps to find the 
desired answer. You may need to use mathematical formulas, 
branches, or loops. Express your function in pseudocode. 
An Internet search yields the fact that the volume of a pyramid is 
computed as  
volume = 1/3 × height × base area 
Since the base is a square, we have  
base area = base length × base length 
Using these two equations, we can compute the volume from the 
parameter values. 
 
Step 5   Implement the function body. 
In our example, the function body is quite simple. Note the use of 
the return statement to return the result.  
{
   double base_area = base_length * base_length; 
   return height * base_area / 3; 
}
 
Step 6   Test your function. 
After implementing a function, you should test it in isolation. Such 
a test is called a unit test. Work out test cases by hand, and make 
sure that the function produces the correct results. 
For example, for a pyramid with height 9 and base length 10, we 
expect the area to be 1/3 × 9 × 100 = 300. If the height is 0, we 
expect an area of 0.  
int main() 

{
   cout << "Volume: " << pyramid_volume(9, 
10) << endl; 
   cout << "Expected: 300" 
   cout << "Volume: " << pyramid_volume(0, 
10) << endl; 
   cout << "Expected: 0" 
   return 0; 
}
The output confirms that the function worked as expected:  
Volume: 300 
Expected: 300 
Volume: 0 
Expected: 0 
 
 
 
 
 
 
 
 
 
 
 
 
 
Worked Example 5.1 
 
 
 
 
 
WORKED EXAMPLE 5.1 Matching and Replacing Parts of a String 
 
 
Searching and replacing text is a common word processor function. Your task 
is to write a function that replaces the first occurrence of one string with 
another in a given string. For example, when asked to replace "ss" with "n" 
in "Mississippi", the result is "Minissippi".  
Step 1   Describe what the function should do. 
This has been given to us already. 
 
Step 2   Determine the function's “inputs”. 
There are three parameters: 
• The string that is being edited (such as "Mississippi") 
 
• The string that is being replaced (such as "ss") 
 
• The replacement string (such as "n") 
 
At this point, we have enough information to document the 
function:  
/**
   Replaces the first occurrence of match in str with 
repl.
   @param str the string that is being edited 
   @param match the string that is being replaced 
   @param repl the replacement string 
*/
 
Step 3   Determine the types of the parameters and the return value. 
 

The parameters are all strings. However, because the first parameter 
is being modified, its type is string&. The function modifies the 
first parameter, and it does not return a value. Therefore, the return 
type is void. 
The function will be defined as  
void replace_first(string& str, string match, string 
repl)
 
Step 4   Write pseudocode for obtaining the desired result. 
We first need to find the position in which match occurs. (If it 
doesn't occur anywhere, we do nothing.) For example, the string 
"ss" is found in position 2 in "Mississippi". Let us assume 
that we know that position, and call it i. Then the answer is 
obtained by concatenating 
• the substring of str from 0 to i - 1 
 
• the replacement string 
 
• the substring of str from i + match.length() to the 
end 
 
How do we find that position? In the spirit of stepwise refinement, 
we will delegate that task to another function. That starts a new 
sequence of steps, which, for greater clarity, we will place after the 
steps for this function. 
 
Step 5   Implement the function body. 
We simply translate the plan into C++:  
{
   int i = find_index(str, match); 
   if (i == -1) { return; } // No match 
   str = str.substr(0, 
i) + repl + str.substr(i + match.length()); 
}
 
Step 6   Test your function. 
We first test whether "Mississippi" is edited as expected, and 
then we add a couple of additional tests.  
int main() 
{
   string river = "Mississippi"; 
   replace_first(river, "ss", "n"); 
   cout << river << endl; 
   cout << "Expected: Minissippi" << endl; 
   replace_first(river, "ss", "n"); 
   cout << river << endl; 
   cout << "Expected: Mininippi" << endl; 
   replace_first(river, "ss", "n"); // No more match—
should do nothing 
   cout << river << endl; 
   cout << "Expected: Mininippi" << endl; 
   return 0; 
}
 
 
Repeat for the Helper Function

 
Now it is time to turn to the helper function for finding the match position.  
Step 1   Describe what the function should do. 
It should find and return the first index in which a substring occurs 
in a given string, or return -1 if the substring doesn't occur 
anywhere. 
 
Step 2   Determine the function's “inputs”. 
There are two parameters: 
• The string that is being searched (such as "Mississippi") 
 
• The substring that is being matched (such as "ss") 
 
At this point, we have enough information to document the 
function:  
/**
   Finds the index of the first occurrence of match in 
str.
   @param str the string that is being searched 
   @param match the substring that is being matched 
   @return the first index at which match occurs in 
str, or -1 if it doesn't 
   occur anywhere 
*/
 
Step 3   Determine the types of the parameters and the return value. 
The parameters are both strings. Neither of them is being modified. 
Therefore, they are both value parameters. The return type is int. 
The function will be defined as  
int find_index(string str, string match) 
 
Step 4   Write pseudocode for obtaining the desired result. 
We start at index 0. Let n be the length of match. If 
str.substr(0, n) equals match, we have found our match. 
If not, we increment the index. If i denotes the current index, we 
test whether str.substr(i, n) equals match. If so, we 
return i. We keep incrementing i while there is still a hope of a 
match. Eventually, the unexamined tail of str is shorter than 
match, and we stop, returning -1. 
 
Step 5   Implement the function body. 
We translate the plan into C++:  
{
   int n = match.length(); 
   for (int i = 0; i <= str.length() - match.length();
i++)
   { 
      if (str.substr(i, n) == match) { return i; } 
   } 
   return -1; 
}
 
Step 6   Test your function. 
We first test whether the "ss" in "Mississippi" is located at 
the expected position, and then we try a string that doesn't occur.  
int main() 

{
   string river = "Mississippi"; 
   int n = find_index(river, "ss"); 
   cout << n << endl; 
   cout << "Expected: 2" << endl; 
   n = find_index(river, "tt"); 
   cout << n << endl; 
   cout << "Expected: -1" << endl; 
   return 0; 
}
See ch05/match.cpp
 for the complete program with both 
functions. 
 
 
 
 
 
 
 
 
 
 
5.5  Functions without Return Values 
 
 
Sometimes, you need to carry out a sequence of instructions that does not yield a value. If 
that instruction sequence occurs multiple times, you will want to package it into a 
function. In C++, you use the return type void to indicate the absence of a return value. 
 
 
Use a return type of void to indicate 
that a function does not return a 
value. 
 
 
 
 
Here is a typical example. Your task is to print a string in a box, like this:  
-------
!Hello!
-------
However, different strings can be substituted for Hello. A function for this task can be 
defined as follows:  
void box_string(string str) 
Now you develop the body of the function in the usual way, by formulating a general 
method for solving the task.  
 
• Print a line that contains the - character n + 2 times, where n is the length of the 
string.  
 
• Print a line containing the string, surrounded with a ! to the left and right.  
 
• Print another line containing the - character n + 2 times.  
 
Here is the function implementation:  
/**
   Prints a string in a box. 
   @param str the string to print 
*/
void box_string(string str) 
{
   int n = str.length(); 
   for (int i = 0; i < n + 2; i++) { cout << "-"; } 

   cout << endl; 
   cout << "!" << str << "!" << endl; 
   for (int i = 0; i < n + 2; i++) { cout << "-"; } 
   cout << endl; 
}
Note that this function doesn't compute any value. It performs some actions and then 
returns to the caller. (See the sample program ch05/box.cpp.
) 
 
Because there is no return value, you cannot use box_string in an expression. You 
can call  
box_string("Hello");
but not  
result = box_string("Hello"); // Error: box_string doesn't return a 
result. 
 
If you want to return from a void function before reaching the end, you use a return 
statement without a value. For example,  
void box_string(string str) 
{
   int n = str.length(); 
   if (n == 0) 
   { 
      return; // Return immediately 
   } 
   . . . 
}
 
 
  
 
Self Check
 
 
 
 
13.  How do you generate the following printout, using the box_string 
function? 
 
-------
!Hello!
-------
-------
!World!
-------
 
 
14.  What is wrong with the following statement? 
 
cout << box_string("Hello"); 
 
 
15.  Implement a function shout that prints a line consisting of a string 
followed by three exclamation marks. For example, shout ("Hello")
should print Hello!!!. The function should not return a value. 
 
 
 
16.  How would you modify the box_string function to leave a space 
around the string that is being boxed, like this: 
 
---------
! Hello ! 
 

---------
 
 
17.  The box_string function contains the code for printing a line of - 
characters twice. Place that code into a separate function print_line, 
and use that function to simplify box_string. What is the code of both 
functions? 
 
 
 
 
 
 
 
 
 
 
 
 
 
5.6  Stepwise Refinement 
 
 
One of the most powerful strategies for problem solving is the process of stepwise 
refinement. To solve a difficult task, break it down into simpler tasks. Then keep 
breaking down the simpler tasks into even simpler ones, until you are left with tasks that 
you know how to solve.  
 
 
Use the process of stepwise 
refinement to decompose complex 
tasks into simpler ones. 
 
 
 
 
Now apply this process to a problem of everyday life. You get up in the morning and 
simply must get coffee. How do you get coffee? You see whether you can get someone 
else, such as your mother or mate, to bring you some. If that fails, you must make coffee. 
How do you make coffee? If there is instant coffee available, you can make instant 
coffee. How do you make instant coffee? Simply boil water and mix the boiling water 
with the instant coffee. How do you boil water? If there is a microwave, then you fill a 
cup with water, place it in the microwave and heat it for three minutes. Otherwise, you 
fill a kettle with water and heat it on the stove until the water comes to a boil. On the 
other hand, if you don't have instant coffee, you must brew coffee. How do you brew 
coffee? You add water to the coffee maker, put in a filter, grind coffee, put the coffee in 
the filter, and turn the coffee maker on. How do you grind coffee? You add coffee beans 
to the coffee grinder and push the button for 60 seconds. 
 
Figure 5 shows a flowchart view of the coffee-making solution. Refinements are shown 
as expanding boxes. In C++, you implement a refinement as a function. For example, a 
function brew_coffee would call grind_coffee, and it would be called from a 
function make_coffee. 
 
 

 
 
 
   Figure 5   Flowchart of Coffee-Making Solution 
 
 
 
Let us apply the process of stepwise refinement to a programming problem. When 
printing a check, it is customary to write the check amount both as a number (“$274.15”) 
and as a text string (“two hundred seventy four dollars and 15 cents”). Doing so reduces 
the recipient's temptation to add a few digits in front of the amount (see Figure 6). For a 
human, this isn't particularly difficult, but how can a computer do this? There is no built-
in function that turns 274 into "two hundred seventy four". We need to 
program this function. Here is the description of the function we want to write:  
/**
   Turns a number into its English name. 

   @param number a positive integer < 1,000 
   @return the name of number (e.g., "two hundred seventy four") 
*/
string int_name(int number) 
Before starting to program, we need to have a plan. Consider a simple case. If the number 
is between 1 and 9, we need to compute "one" … "nine". In fact, we need the same 
computation again for the hundreds (two hundred). Any time you need something 
more than once, it is a good idea to turn that into a function. Rather than writing the entire 
function, write only the comment:  
/**
   Turns a digit into its English name. 
   @param digit an integer between 1 and 9 
   @return the name of digit ("one" . . . "nine") 
*/
string digit_name(int digit) 
This sounds simple enough to implement, using an if statement with nine branches, so 
we will worry about the implementation later. 
 
 
 
 
 
   Figure 6    Check Showing the Amount as Both a Number and a String
 
 
 
Numbers between 10 and 19 are special cases. Let's have a separate function 
teen_name that converts them into strings "eleven", "twelve", "thirteen", 
and so on:  
/**
   Turns a number between 10 and 19 into its English name. 
   @param number an integer between 10 and 19 
   @return the name of the number ("ten" . . . "nineteen") 
*/
string teen_name(int number) 
Next, suppose that the number is between 20 and 99. Then we show the tens as 
"twenty", "thirty", …, "ninety". For simplicity and consistency, put that 
computation into a separate function:  
/**
   Gives the name of the tens part of a number between 20 and 99. 

   @param number an integer between 20 and 99 
   @return the name of the tens part of the number ("twenty" . . . 
"ninety")
*/
string tens_name(int number) 
Now suppose the number is at least 20 and at most 99. If the number is evenly divisible 
by 10, we use tens_name, and we are done. Otherwise, we print the tens with 
tens_name and the ones with digit_name. If the number is between 100 and 999, 
then we show a digit, the word "hundred", and the remainder as described previously.
 
Here is the pseudocode of the algorithm.  
part = number (The part that still needs to be converted) 
name = "" (The name of the number) 
If part >= 100 
{
    name = name of hundreds in part + " hundred" 
    Remove hundreds from part. 
}
If part >= 20 
{
    Append tens_name(part) to name. 
    Remove tens from part. 
}
Else if part >= 10 
{
    Append teen_name(part) to name. 
    part = 0 
}
If  (part > 0) 
{
    Append digit_name(part) to name. 
}
This pseudocode has a number of important improvements over the verbal description. It 
shows how to arrange the tests, starting with the comparisons against the larger numbers, 
and it shows how the smaller number is subsequently processed in further if statements.
 
On the other hand, this pseudocode is vague about the actual conversion of the pieces, 
just referring to “name of hundreds” and the like. Furthermore, we were vague about 
spaces. As it stands, the code would produce strings with no spaces, 
twohundredseventyfour, for example. Compared to the complexity of the main 
problem, one would hope that spaces are a minor issue. It is best not to muddy the 
pseudocode with minor details. 
 
Now turn the pseudocode into real code. The last three cases are easy, because helper 
functions are already developed for them:  
if (part >= 20) 
{
   name = name + " " + tens_name(part); 
   part = part % 10; 
}
else if (part >= 10) 

{
   name = name + " " + teen_name(part); 
   part = 0; 
}
if (part > 0) 
{
   name = name + " " + digit_name(part); 
}
Finally, let us tackle the case of numbers between 100 and 999. Because 
part < 1000, part / 100 is a single digit, and we obtain its name by calling 
digit_name. Then we add the “hundred” suffix:  
if (part >= 100) 
{
   name = digit_name(part / 100) + " hundred"; 
   part = part % 100; 
}
Now you have seen all the important building blocks for the int_name function. Here 
is the complete program. 
 
ch05/intname.cpp
 
1 #include <iostream> 
2 #include <string> 
3
4 using namespace std; 
5
6 /** 
7
Turns a digit into its English name.
8    @param digit an integer between 1 and 9
9    @return the name of digit
("one" . . . "nine")
10 */ 
11 string digit_name(int digit) 
12 { 
13
if (digit == 1) return "one";
14
if (digit == 2) return "two";
15
if (digit == 3) return "three";
16
if (digit == 4) return "four";
17
if (digit == 5) return "five";
18
if (digit == 6) return "six";
19
if (digit == 7) return "seven";
20
if (digit == 8) return "eight";
21
if (digit == 9) return "nine";
22
return "";
23 } 
24
25 /** 
26
Turns a number between 10 and 19 into its English name.
27    @param number an integer between 10 and 19
28    @return the name of the given number ("ten" . . . "nineteen")
29 */ 
30 string teen_name(int number) 

31 { 
32
if (number == 10) return "ten";
33
if (number == 11) return "eleven";
34
if (number == 12) return "twelve";
35
if (number == 13) return "thirteen";
36
if (number == 14) return "fourteen";
37
if (number == 15) return "fifteen";
38
if (number == 16) return "sixteen";
39
if (number == 17) return "seventeen";
40
if (number == 18) return "eighteen";
41
if (number == 19) return "nineteen";
42
return "";
43 } 
44
45 /** 
46
Gives the name of the tens part of a number between 20 and 99.
47    @param number an integer between 20 and 99
48    @return the name of the tens part of the number ("twenty" . . . "ninety")
49 */ 
50 string tens_name(int number) 
51 { 
52
if (number >= 90) return "ninety";
53
if (number >= 80) return "eighty";
54
if (number >= 70) return "seventy";
55
if (number >= 60) return "sixty";
56
if (number >= 50) return "fifty";
57
if (number >= 40) return "forty";
58
if (number >= 30) return "thirty";
59
if (number >= 20) return "twenty";
60
return "";
61 }
62
63 /** 
64
Turns a number into its English name.
65    @param number a positive integer < 1,000
66    @return the name of the number (e.g. "two hundred seventy four")
67 */ 
68 string int_name(int number) 
69 { 
70
int part = number; // The part that still needs to be converted
71    string name; // The return value
72
73
if (part >= 100)
74    { 
75       name = digit_name(part / 100) + " hundred";
76       part = part % 100;
77    } 
78
79
if (part >= 20)
80    { 
81       name = name + " " + tens_name(part); 
82       part = part % 10;
83    } 
84
else if (part >= 10)
85    { 
86       name = name + " " + teen_name(part); 

87       part = 0;
88    } 
89
90
if (part > 0)
91    { 
92       name = name + " " + digit_name(part); 
93    } 
94
95
return name; 
96 } 
97
98 int main() 
99 { 
100    cout << "Please enter a positive integer: ";
101
int input; 
102    cin >> input; 
103    cout << int_name(input) << endl; 
104
return 0;
105 } 
Program Run 
  Please enter a positive integer: 729
  seven hundred twenty nine 
 
 
 
  
 
Self Check
 
 
 
 
18.  Explain how you can improve the int_name function so that it can 
handle parameter values up to 9999. 
 
 
 
19.  Why does line 87 set part = 0? 
 
 
 
20.  What happens when you call int_name(0)? How can you change the 
int_name function to handle this case correctly? 
 
 
 
21.  Trace the function call int_name(72), as described in Productivity 
Hint 5.3. 
 
 
 
22.  Use the process of stepwise refinement to break down the task of printing 
the following table into simpler tasks. 
 
+-----+-----------+
|   i | i * i * i | 
+-----+-----------+
|   1 |         1 | 
|   2 |         8 | 
  ... 
|  20 |      8000 | 
+-----+-----------+
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
Quality Tip 5.2 
 
 
 
 
 
QUALITY TIP 5.2 Keep Functions Short 
 
 
There is a certain cost for writing a function. You need to design, code, and 
test the function. The function needs to be documented. You need to spend 
some effort to make the function reusable rather than tied to a specific context. 
To avoid this cost, it is always tempting just to stuff more and more code in 
one place rather than going through the trouble of breaking up the code into 
separate functions. It is quite common to see inexperienced programmers 
produce functions that are several hundred lines long. 
 
As a rule of thumb, a function that is so long that its code will not fit on a 
single screen in your development environment should probably be broken up. 
 
 
 
 
 
 
 
 
 
 
Productivity Hint 5.3 
 
 
 
 
 
PRODUCTIVITY HINT 5.3 Tracing Functions 
 
 
When you design a complex set of functions, it is a good idea to carry out a 
manual walkthrough before entrusting your program to the computer. 
 
Take an index card, or some other piece of paper, and write down the function 
call that you want to study. Write the name of the function and the names and 
values of the parameter variables, like this:  
 
 
 
 

Then write the names of the function variables. Write them in a table, since 
you will update them as you walk through the code.  
 
 
 
We enter the test part >= 100. part / 100 is 4 and part % 100 is 
16. digit_name(4) is easily seen to be "four". (Had digit_name 
been complicated, you would have started another sheet of paper to figure out 
that function call. It is quite common to accumulate several sheets in this way.)
 
Now name has changed to name + " " + digit_name(part / 
100) + " hundred", that is "four hundred", and part has changed 
to part % 100, or 16.  
 
 
 
Now you enter the branch part >= 10. teens_name(16) is 
sixteen, so the variables now have the values  
 
 
 
Now it becomes clear why you need to set part to 0. Otherwise, you would 
enter the next branch and the result would be "four hundred sixteen 
six". Tracing the code is an effective way to understand the subtle aspects of 
a function. 
 
 
 
 
 
 
 
 
 

 
 
Productivity Hint 5.4 
 
 
 
 
 
PRODUCTIVITY HINT 5.4 Stubs 
 
 
When writing a larger program, it is not always feasible to implement and test 
all functions at once. You often need to test a function that calls another, but 
the other function hasn't yet been implemented. Then you can temporarily 
replace the missing function with a stub. A stub is a function that returns a 
simple value that is sufficient for testing another function. Here are examples 
of stub functions.  
/**
   Turns a digit into its English name. 
   @param digit an integer between 1 and 9 
   @return the name of digit ("one" . . . "nine") 
*/
string digit_name(int digit) 
{
   return "mumble"; 
}
/**
   Gives the name of the tens part of a number between 20 and 
99.
   @param number an integer between 20 and 99 
   @return the tens name of the number ("twenty" . . . 
"ninety")
*/
string tens_name(int number) 
{
   return "mumblety"; 
}
If you combine these stubs with the int_name function and test it with a 
parameter value of 274, you will get a result of "mumble hundred 
mumblety mumble", which indicates that the basic logic of the int_name
function is working correctly. 
 
 
 
 
 
 
 
 
 
Worked Example 5.2 
 
 
 
 
 
WORKED EXAMPLE 5.2 Calculating a Course Grade 
 

 
 
Students in this course take four exams and earn a letter grade (A+, A, A-, B+, 
B, B-, C+, C, C-, D+, D, D-, or F) for each of them. The course grade is 
determined by dropping the lowest grade and averaging the three remaining 
grades. To average grades, first convert them to number grades, using the 
usual scheme A+ = 4.3, A = 4.0, A- = 3.7, B+ = 3.3, …, D- = 0.7, F = 0. Then 
compute their average and convert it back to the closest letter grade. For 
example, an average of 3.51 would be an A-. 
 
Your task is to read inputs of the form:  
letter_grade1 letter_grade2 letter_grade3 letter_grade4
For example,  
A- B+ C A 
For each input line, your output should be  
letter_grade
where the letter grade is the grade earned in the course, as just described. For 
example,  
A-
The end of inputs will be indicated by a letter_grade1 field of Q.  
Step 1   Carry out stepwise refinement. 
We will use the process of stepwise refinement. To process the 
inputs, we can process each line individually. Therefore, we define 
a task process line . 
To process a line, we read the first grade and bail out if it is a Q. 
Otherwise, we read the four grades. Since we need them in their 
numeric form, we identify a task convert letter grade to number . 
We then have four numbers and need to find the smallest one. That 
is another task, find smallest of four numbers . To average the 
remaining ones, we compute the sum of all values, subtract the 
smallest, and divide by three. Let's say that is not worth making 
into a subtask. 
Next, we need to convert the result back into a letter grade. That is 
yet another subtask convert number grade to letter . Finally, we 
print the letter grade. That is again so simple that it requires no 
subtask. 
 
Step 2   Convert letter grade to number. 
How do we convert a letter grade to a number? Take the first 
character, and convert A to 4, B to 3, C to 2, D to 1, and F to 0. If 
there is a + suffix, add 0.3, and if there is a - suffix, subtract 0.3. 
Here is a function for that task.  
/**
   Converts a letter grade to a number. 
   @param grade a letter grade (A+, A, A-, . . ., D-, 

F)
   @return the equivalent number grade 
*/
double grade_to_number(string grade) 
{
   double result = 0; 
   string first = grade.substr(0, 1); 
   if (first == "A") { result = 4; } 
   else if (first == "B") { result = 3; } 
   else if (first == "C") { result = 2; } 
   else if (first == "D") { result = 1; } 
   if (grade.length() > 1) 
   { 
      if (grade.substr(1, 1) == "+") 
      { 
         result = result + 0.3; 
      } 
      else 
      { 
         result = result - 0.3; 
      } 
   } 
   return result; 
}
 
Step 3   Convert number grade to letter. 
How do we do the opposite conversion? Here, the challenge is that 
we need to convert to the nearest letter grade. For example, if x is 
the number grade, then we have:  
2.5  x < 2.85: B-
2.85  x < 3.15: B
3.15  x < 3.5: B+
We can make a function with 13 branches, one for each valid letter 
grade.  
/**
   Converts a number to the nearest letter grade. 
   @param x a number between 0 and 4.3 
   @return the nearest letter grade 
*/
string number_to_grade(double x) 
{
   if (x >= 4.15) { return "A+"; } 
   if (x >= 3.85) { return "A"; } 
   if (x >= 3.5) { return "A-"; } 
   if (x >= 3.15) { return "B+"; } 
   if (x >= 2.85) { return "B"; } 
   if (x >= 2.5) { return "B-"; } 
   if (x >= 2.15) { return "C+"; } 
   if (x >= 1.85) { return "C"; } 
   if (x >= 1.5) { return "C-"; } 
   if (x >= 1.15) { return "D+"; } 
   if (x >= 0.85) { return "D"; } 
   if (x >= 0.5) { return "D-"; } 
   return "F"; 
}

 
Step 4   Find the minimum of four numbers. 
Finally, how do we find the smallest of four numbers? Let's 
suppose we can find the smallest of two numbers, with a function 
min(x, y). Then the smallest of four numbers is 
min(min(x1, x2), min(x3, x4)). Finding the smallest of 
two numbers is easy.  
/**
   Returns the smaller of two numbers. 
   @param x a number 
   @param y a number 
   @return the smaller of x and y 
*/
double min(double x, double y) 
{
   if (x < y) 
   { 
      return x; 
   } 
   else 
   { 
      return y; 
   } 
}
 
Step 5   Process a line. 
As previously described, to process a line, we read in the four input 
strings, convert grades to numbers, and compute the average after 
dropping the lowest grade. Then we print the grade corresponding 
to that average. 
However, if we read the first input string and find a Q, we need to 
signal to the caller that we have reached the end of the input set and 
that no further calls should be made. 
Our function will return a bool value, true if it was successful, 
false if it encountered the sentinel.  
/**
   Processes one line of input. 
   @return true if the sentinel was not encountered 
*/
bool process_line() 
{
   cout << "Enter four grades or Q to quit: "; 
   string g1; 
   cin >> g1; 
   if (g1 == "Q") { return false; } 
   string g2; 
   string g3; 
   string g4; 
   cin >> g2 >> g3 >> g4; 
   double x1 = grade_to_number(g1); 
   double x2 = grade_to_number(g2); 
   double x3 = grade_to_number(g3); 
   double x4 = grade_to_number(g4); 
   double xlow = min(min(x1, x2), min(x3, x4)); 
   double avg = (x1 + x2 + x3 + x4 - xlow) / 3; 

   cout << number_to_grade(avg) << endl; 
   return true; 
}
 
Step 6   Write the main function. 
The main function is now utterly trivial. We keep calling 
process_line while it returns true.  
int main() 
{
   while (process_line()) 
   { 
   } 
   return 0; 
}
See ch05/grades.cpp
 for the complete program. 
 
 
 
 
 
 
 
 
 
 
5.7  Variable Scope and Global Variables 
 
 
It is possible to define the same variable name more than once in a program. When the 
variable name is used, you need to know to which definition it belongs. In this section, 
we discuss the rules for dealing with multiple definitions of the same name.  
 
 
 
 
In the same way that there can be a street named “Main Street” in different cities, a 
C++ program can have multiple variables with the same name. 
Joan Champ/iStockphoto (Railway and Main); Steven Johnson/iStockphoto (Main 
and N. Putnam); Jeffrey Smith/iStockphoto (Main and South). 
 
 
 
 
The scope of a variable is the part of 

the program in which it is visible. 
 
 
 
A variable that is defined within a function is visible from the point at which it is defined 
until the end of the block in which it was defined. This area is called the scope of the 
variable. 
 
Consider the volume variables in the following example:  
double cube_volume(double side_length) 
{
   double volume = side_length * side_length * side_length; 
   return volume; 
}
int main() 
{
   double volume = cube_volume(2); 
   cout << volume << endl; 
   return 0; 
}
Each volume variable is defined in a separate function, and their scopes do not overlap. 
 
It is not legal to define two variables with the same name in the same scope. For example, 
the following is not legal:  
int main() 
{
   double volume = cube_volume(2); 
   double volume = cube_volume(10); 
      // ERROR: cannot define another volume variable in this scope 
   . . . 
}
However, you can define another variable with the same name in a nested block. Here, 
we define two variables called amount.  
double withdraw(double balance, double amount) 
{
   if (. . .) 
   { 
      double amount = 10; // Another variable named amount 
      . . . 
   } 
   . . . 
}
The scope of the parameter variable amount is the entire function, except the nested 
block. Inside the nested block, amount refers to the variable that was defined in that 
block. You should avoid this potentially confusing situation in the functions that you 
write, simply by renaming one of the variables.  
 
 
A local variable is defined inside a 
function. A global variable is defined 
outside a function. 
 
 
 

 
Variables that are defined inside functions are called local variables. C++ also supports 
global variables: variables that are defined outside functions. A global variable is visible 
to all functions that are defined after it. For example, the <iostream> header defines 
global variables cin and cout. 
 
Here is an example of a global variable:  
int balance = 10000; // A global variable 
void withdraw(double amount) 
{
   if (balance >= amount) 
   { 
      balance = balance - amount; 
   } 
}
int main() 
{
   withdraw(1000); 
   cout << balance << endl; 
   return 0; 
}
The scope of the variable balance extends over both the withdraw and the main 
functions. 
 
Generally, global variables are not a good idea. When multiple functions update global 
variables, the result can be difficult to predict. Particularly in larger programs that are 
developed by multiple programmers, it is very important that the effect of each function 
be clear and easy to understand. You should avoid global variables in your programs. 
 
 
  
 
Self Check
 
 
 
 
Consider this program:  
1  int x; 
2  int mystery(int x) 
3  { 
4     int s = 0; 
5     for (int i = 0; i < x; x++) 
6     { 
7        int x = i + 1; 
8        s = s + x; 
9     } 
10     return x; 
11  } 
12  int main() 
13  { 
14     x = 4; 
15     int s = mystery(x); 
16     cout << s << endl; 
17  } 
 

 
23.  Which line defines a global variable? 
 
 
 
24.  Which lines define local variables named x? 
 
 
 
25.  Which lines are in the scope of the definition of x in line 2? 
 
 
 
26.  Which variable is changed by the assignment in line 14? 
 
 
 
27.  This program defines two variables with the same name whose scopes 
don't overlap. What are they? 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Quality Tip 5.3 
 
 
 
 
 
QUALITY TIP 5.3 Avoid Global Variables 
 
 
There are a few cases where global variables are required (such as cin and 
cout), but they are quite rare. Programs with global variables are difficult to 
maintain and extend because you can no longer view each function as a “black 
box” that simply receives parameter values and returns a result. When 
functions modify global variables, it becomes more difficult to understand the 
effect of function calls. As programs get larger, this difficulty mounts quickly. 
Instead of using global variables, use function parameters to transfer 
information from one part of a program to another. 
 
 
 
 
 
 
 
 
 
 
5.8  Reference Parameters 
 
 
If you want to write a function that changes the value of a parameter, you must use a 
reference parameter in order to allow the change. We first explain why a different 
parameter type is necessary, then we show you the syntax for reference parameters. 
 
Consider a function that simulates withdrawing a given amount of money from a bank 
account, provided that sufficient funds are available. If the amount of money is 
insufficient, a $10 penalty is deducted instead. The function would be used as follows:  
double harrys_account=1000; 
withdraw(harrys_account, 100); // Now harrys_account is 900 
withdraw(harrys_account, 1000); // Insufficient funds. Now 

harrys_account is 890 
Here is a first attempt:  
void withdraw(double balance, double amount) // Does not work 
{
   const double PENALTY = 10; 
   if (balance >= amount) 
   { 
      balance = balance - amount; 
   } 
   else 
   { 
      balance = balance - PENALTY; 
   } 
}
But this doesn't work. 
 
Let's walk through the function call withdraw(harrys_account, 100)—see 
Figure 7. As the function starts, the parameter variable balance is created 
and set to 
the same value as harrys_account, and amount is set to 100 
. Then balance is
modified 
. Of course, that modification has no effect on harrys_account, because 
balance is a separate variable. When the function returns, balance is forgotten, and 
no money was withdrawn from harrys_account 
. 
 
 
 

 
 
 
 
  Figure 7   Value Parameters
 
 
 
A parameter such as balance is called a value parameter, because it is initialized with a 
value supplied by the caller. All parameters in the functions that we have written so far 
have been value parameters. In this situation, though, we don't just want balance to 
have the same value as harrys_account. We want balance to refer to the actual 
variable harrys_account (or joes_account or whatever variable is supplied in 
the call). The contents of that variable should be updated.  
 
 
A reference parameter refers to a 
variable that is supplied in a function 
call. 
 
 
 
 
You use a reference parameter when you want to update a variable that was supplied in 
the function call. When we make balance into a reference parameter, then balance is 
not a new variable but a reference to an existing variable. Any change in balance is 
actually a change in the variable to which balance refers in that particular call. 

 
Figure 8 shows the difference between value and reference parameters. 
 
 
 
 
 
 
   Figure 8   Reference and Value Parameters
 
 
 
To indicate a reference parameter, you place an & after the type name.  
void withdraw(double& balance, double amount) 
The type double& is read “a reference to a double” or, more briefly, “double 
ref”. 
 
The withdraw function has two parameters: one of type “double ref” and the other 
a value parameter of type double. The body of the function is unchanged. What has 
changed is the meaning of the assignments to the balance variable.  
 
 
 
A reference parameter for a bank balance is like an ATM card—it allows you to 
change the balance. In contrast, a value parameter can only tell you the balance. 
Winston Davidian/iStockphoto. 
 
 
 
The assignment  
  balance = balance - amount; 
now changes the variable that was passed to the function. For example, the call  

  withdraw(harrys_account, 500); 
modifies the variable harrys_account, and the call  
  withdraw(sallys_account, 150); 
modifies the variable sallys_account. 
 
A reference parameter must always be called with a variable. It would be an error to 
supply a number:  
  withdraw(1000, 500); // Error: reference parameter must be a variable 
The reason is clear–the function modifies the reference parameter, but it is impossible to 
change the value of a number. For the same reason, you cannot supply an expression:  
withdraw(harrys_account + 150, 500); 
   // Error: reference parameter must be a variable 
 
ch05/account.cpp
 
1  #include <iostream> 
2
3
using namespace std; 
4
5  /** 
6
Withdraws the amount from the given balance, or withdraws
7
a penalty if the balance is insufficient.
8     @param balance the balance from which to make the withdrawal
9     @param amount the amount to withdraw
10  */ 
11
void withdraw(double& balance, double amount) 
12  { 
13
const double PENALTY = 10;
14
if (balance >= amount) 
15     { 
16        balance = balance - amount; 
17     } 
18
else
19     { 
20        balance = balance - PENALTY; 
21     } 
22  } 
23
24
int main() 
25  { 
26
double harrys_account = 1000;
27
double sallys_account = 500;
28     withdraw(harrys_account, 100);
29        // Now harrys_account is 900
30     withdraw(harrys_account, 1000); // Insufficient funds
31        // Now harrys_account is 890
32     withdraw(sallys_account, 150);
33     cout << "Harry's account: " << harrys_account << endl; 
34     cout << "Sally's account: " << sallys_account << endl; 
35
36
return 0;

37  } 
Program Run 
  Harry's account: 890 
  Sally's account: 350 
 
 
 
  
 
Self Check
 
 
 
 
28.  Would the withdraw function work correctly if the amount parameter 
was defined as double& instead of double? 
 
 
 
29.  The following function is intended to transfer the given amount of money 
from one account to another. Supply the function parameters. 
 
void transfer(. . .) 
{
   if (balance1 >= amount) 
   { 
      balance1 = balance1 - amount; 
      balance2 = balance2 + amount; 
   } 
}
 
 
30.  Change the withdraw function so that it returns a bool value indicating 
whether the withdrawal was successful. Do not charge a penalty if the 
balance was insufficient. 
 
 
 
31.  Write a function minmax so that the call minmax(x, y, a, b) sets 
a to the smaller of x and y and b to the larger of x and y. 
 
 
 
32.  What does this program print? 
 
void mystery(int& a, int& b) 
{
   a = a - b; 
   b = b + a; 
   a = b - a; 
}
int main() 
{
   int x = 4; 
   int y = 3; 
   mystery(x, y); 
   cout << x << " " << y << endl; 
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Quality Tip 5.4 
 
 
 

 
 
QUALITY TIP 5.4 Prefer Return Values to Reference Parameters 
 
 
Some programmers use reference parameters as a mechanism for setting the 
result of a function. For example,  
void cube_volume(double side_length, double& volume) 
{
   volume = side_length * side_length * side_length; 
}
However, this function is less convenient than our previous cube_volume 
function. It cannot be used in expressions such as 
cout << cube_volume(2). 
 
Use a reference parameter only when a function needs to update a variable. 
 
 
 
 
 
 
 
 
 
 
 
 
Advanced Topic 5.2 
 
 
 
 
 
ADVANCED TOPIC 5.2 Constant References 
 
 
It is not very efficient to have a value parameter that is a large object (such as 
a string value). Copying the object into parameter value is less efficient 
than using a reference parameter. With a reference parameter, only the 
location of the variable, not its value, needs to be communicated to the 
function. 
 
You can instruct the compiler to give you the efficiency of call by reference 
and the meaning of call by value, by using a constant reference as shown 
below. The function  
void shout(const string& str) 
{
   cout << str << "!!!" << endl; 
}
works exactly the same as the function  
void shout(string str) 
{
   cout << str << "!!!" << endl; 
 

}
There is just one difference: Calls to the first function execute a bit faster. 
 
 
 
 
 
 
 
 
 
5.9  Recursive Functions (Optional) 
 
 
A recursive function is a function that calls itself. This is not as unusual as it sounds at 
first. Suppose you face the arduous task of cleaning up an entire house. You may well say 
to yourself, “I'll pick a room and clean it, and then I'll clean the other rooms.” In other 
words, the cleanup task calls itself, but with a simpler input. Eventually, all the rooms 
will be cleaned. 
 
 
 
 
 
Cleaning up a house can be solved recursively: Clean one room, then clean up the 
rest. 
Janice Richard/iStockphoto. 
 
 
 
In C++, a recursive function uses the same principle. Here is a typical example. We want 
to print triangle patterns like this:  
[]
[][]
[][][]
[][][][]
Specifically, our task is to provide a function  
void print_triangle(int side_length) 
The triangle given above is printed by calling print_triangle(4). To see how 
recursion helps, consider how a triangle with side length 4 can be obtained from a 
triangle with side length 3.  
[]
[][]

[][][]
[][][][]
Print the triangle with side length 3. 
Print a line with four []. 
More generally, here are the C++ instructions for an arbitrary side length:  
print_triangle(side_length - 1); 
for (int i = 0; i < side_length; i++) 
{
   cout << "[]"; 
}
cout << endl; 
There is just one problem with this idea. When the side length is 1, we don't want to call 
print_triangle(0), print_triangle(-1), and so on. The solution is simply 
to treat this as a special case, and not to print anything when side_length is less than 
1.  
void print_triangle(int side_length) 
{
   if (side_length < 1) return; 
   print_triangle(side_length - 1); 
   for (int i = 0; i < side_length; i++) 
   { 
      cout << "[]"; 
   } 
   cout << endl; 
}
 
 
A recursive computation solves a 
problem by using the solution of the 
same problem with simpler inputs. 
 
 
 
 
Look at the print_triangle function one more time and notice how utterly 
reasonable it is. If the side length is 0, nothing needs to be printed. The next part is just as 
reasonable. Print the smaller triangle and don't think about why that works. Then print a 
row of []. Clearly, the result is a triangle of the desired size. 
 
There are two key requirements to make sure that the recursion is successful:  
 
• Every recursive call must simplify the task in some way. 
 
• There must be special cases to handle the simplest tasks directly. 
 
 
 
For a recursion to terminate, there 
must be special cases for the simplest 
inputs. 
 
 
 
 
The print_triangle function calls itself again with smaller and smaller side lengths. 
Eventually the side length must reach 0, and the function stops calling itself. 
 
Here is what happens when we print a triangle with side length 4.  

 
• The call print_triangle(4) calls print_triangle(3).  
 
• The call print_triangle(3) calls print_triangle(2).  
 
• The call print_triangle(2) calls print_triangle(1).  
• The call print_triangle(1) calls print_triangle(0).  
• The call print_triangle(0) returns, doing nothing. 
 
 
 
• The call print_triangle(1) prints []. 
 
 
 
• The call print_triangle(2) prints [][]. 
 
 
 
• The call print_triangle(3) prints [][][]. 
 
 
 
• The call print_triangle(4) prints [][][][]. 
 
 
 
This set of Russian dolls looks similar to the call pattern of a recursive function.
Nicolae Popovici/iStockphoto. 
 
 
 
The call pattern of a recursive function looks complicated, and the key to the successful 
design of a recursive function is not to think about it. 
 
Recursion is not really necessary to print triangle shapes. You can use nested loops, like 
this:  
for (int i = 0; i < side_length; i++) 
{
   for (int j = 0; j < i; j++) 
   { 
      cout << "[]"; 
   } 
   cout << endl; 
}
However, this pair of loops is a bit tricky. Many people find the recursive solution 
simpler to understand. 
 
 
 
  
 
Self Check
 
 
 
 
33.  Consider this slight modification of the print_triangle function: 
 
void print_triangle(int side_length) 
{
 

   if (side_length < 1) return; 
   for (int i = 0; i < side_length; i++) 
   { 
      cout << "[]"; 
   } 
   cout << endl; 
   print_triangle(side_length - 1); 
}
What is the result of print_triangle(4)? 
 
 
34.  Consider this recursive function: 
 
int mystery(int n) 
{
   if (n <= 0) { return 0; } 
   return n + mystery(n - 1); 
}
What is mystery(4)? 
 
 
35.  Consider this recursive function: 
 
int mystery(int n) 
{
   if (n <= 0) { return 0; } 
   return mystery(n / 2) + 1; 
}
What is mystery(20)? 
 
 
36.  Write a recursive function for printing n box shapes [] in a row. 
 
 
 
37.  The int_name function in Section 5.6 accepted parameter 
values < 1,000. Using a recursive call, extend its range to 999,999. For 
example an input of 12,345 should return "twelve thousand 
three hundred forty five". 
 
 
 
 
 
 
 
 
 
 
 
 
 
How To 5.2 
 
 
 
 
 
HOW TO 5.2 Thinking Recursively 
 
 
To solve a problem recursively requires a different mindset than to solve it by 
programming loops. In fact, it helps if you are, or pretend to be, a bit lazy and 
let others do most of the work for you. If you need to solve a complex 
problem, pretend that “someone else” will do most of the heavy lifting and 
solve the problem for all simpler inputs. Then you only need to figure out how 
you can turn the solutions with simpler inputs into a solution for the whole 
problem.  
 
 

To illustrate the recursive thinking process, consider the problem of 
Productivity Hint 4.1, to compute the sum of the digits of a number. We want 
to design a function digit_sum that computes the sum of the digits of an 
integer n. For example, digit_sum(1729) = 1 + 7 + 2 + 9 = 19.  
Step 1   Break the input into parts that can themselves be inputs to the 
problem. 
In your mind, fix a particular input or set of inputs for the task that 
you want to solve, and think how you can simplify the inputs. Look 
for simplifications that can be solved by the same task, and whose 
solutions are related to the original task. 
 
The key step to finding a 
recursive solution is reducing 
the input to a simpler input for 
the same problem. 
 
 
 
In the digit sum problem, consider how we can simplify an input 
such as n = 1729. Would it help to subtract 1? After all, 
digit_sum(1729) = digit_sum(1728) + 1. But 
consider n = 1000. There seems to be no obvious relationship 
between digit_sum(1000) and digit_sum(999). 
A much more promising idea is to remove the last digit, that is, 
compute n / 10 = 172. The digit sum of 172 is directly related 
to the digit sum of 1729. 
 
Step 2   Combine solutions with simpler inputs into a solution of the 
original problem. 
In your mind, consider the solutions for the simpler inputs that you 
have discovered in Step 1. Don't worry how those solutions are 
obtained. Simply have faith that the solutions are readily available. 
Just say to yourself: These are simpler inputs, so someone else will 
solve the problem for me. 
 
When designing a recursive 
solution, do not worry about 
multiple nested calls. Simply 
focus on reducing a problem 
to a slightly simpler one. 
 
 
 
In the case of the digit sum task, ask yourself how you can obtain 
digit_sum(1729) if you know digit_sum(172). You 
simply add the last digit (9), and you are done. How do you get the 
last digit? As the remainder n % 10. The value digit_sum(n) 
can therefore be obtained as  
digit_sum(n / 10) + n % 10 
Don't worry how digit_sum(n / 10) is computed. The input 
is smaller, and therefore it just works. 
 
Step 3   Find solutions to the simplest inputs. 

A recursive computation keeps simplifying its inputs. To make sure 
that the recursion comes to a stop, you must deal with the simplest 
inputs separately. Come up with special solutions for them. That is 
usually very easy. 
Look at the simplest inputs for the digit_sum test: 
• A number with a single digit 
 
• 0 
 
A number with a single digit is its own digit sum, so you can stop 
the recursion when n < 10, and return n in that case. Or, if you 
prefer, you can be even lazier. If n has a single digit, then 
digit_sum(n / 10) + n % 10 equals 
digit_sum(0) + n. You can simply terminate the recursion 
when n is zero. 
 
Step 4   Implement the solution by combining the simple cases and the 
reduction step. 
Now you are ready to implement the solution. Make separate cases 
for the simple inputs that you considered in Step 3. If the input isn't 
one of the simplest cases, then implement the logic you discovered 
in Step 2. 
Here is the complete digit_sum function:  
int digit_sum(int n) 
{
   // Special case for terminating the recursion 
   if (n == 0) return 0; 
   // General case 
   return digit_sum(n / 10) + n % 10; 
}
 
 
 
 
 
 
 
 
 
 
 
Random Fact 5.1 
 
 
 
 
RANDOM FACT 5.1 The Explosive Growth of Personal Computers 
 
 
In 1971, Marcian E. “Ted” Hoff, an engineer at Intel Corporation, was 
working on a chip for a manufacturer of electronic calculators. He realized 
that it would be a better idea to develop a general-purpose chip that could be 
programmed to interface with the keys and display of a calculator, rather 
than to do yet another custom design. Thus, the microprocessor was born. At 
the time, its primary application was as a controller for calculators, washing 
machines, and the like. It took years for the computer industry to notice that a 

genuine central processing unit was now available as a single chip. 
 
Hobbyists were the first to catch on. In 1974 the first computer kit, the Altair 
8800, was available from MITS Electronics for about $350. The kit consisted 
of the microprocessor, a circuit board, a very small amount of memory, 
toggle switches, and a row of display lights. Purchasers had to solder and 
assemble it, then program it in machine language through the toggle 
switches. It was not a big hit. 
 
The first big hit was the Apple II. It was a real computer with a keyboard, a 
monitor, and a floppy disk drive. When it was first released, users had a 
$3,000 machine that could play Space Invaders, run a primitive bookkeeping 
program, or let users program it in BASIC. The original Apple II did not 
even support lowercase letters, making it worthless for word processing. The 
breakthrough came in 1979 with a new spreadsheet program, VisiCalc. In a 
spreadsheet, you enter financial data and their relationships into a grid of 
rows and columns (see Figure 9). Then you modify some of the data and 
watch in real time how the others change. For example, you can see how 
changing the mix of widgets in a manufacturing plant might affect estimated 
costs and profits. Middle managers in companies, who understood computers 
and were fed up with having to wait for hours or days to get their data runs 
back from the computing center, snapped up VisiCalc and the computer that 
was needed to run it. For them, the computer was a spreadsheet machine. 
 
 

 
 
 
   Figure 9   The VisiCalc Spreadsheet Running on an Apple II 
 
Reprint Courtesy of International Business Machines 
Corporation, copyright © International Business 
Machines Corporation. 
 
 
 
The next big hit was the IBM Personal Computer, ever after known as the 

PC. It was the first widely available personal computer that used Intel's 16-
bit processor, the 8086, whose successors are still being used in personal 
computers today. The success of the PC was based not on any engineering 
breakthroughs but on the fact that it was easy to clone. IBM published 
specifications for plug-in cards, and it went one step further. It published the 
exact source code of the so-called BIOS (Basic Input/Output System), which 
controls the keyboard, monitor, ports, and disk drives and must be installed 
in ROM form in every PC. This allowed third-party vendors of plug-in cards 
to ensure that the BIOS code, and third-party extensions of it, interacted 
correctly with the equipment. Of course, the code itself was the property of 
IBM and could not be copied legally. Perhaps IBM did not foresee that 
functionally equivalent versions of the BIOS nevertheless could be recreated 
by others. Compaq, one of the first clone vendors, had fifteen engineers, who 
certified that they had never seen the original IBM code, write a new version 
that conformed precisely to the IBM specifications. Other companies did the 
same, and soon a variety of vendors were selling computers that ran the same 
software as IBM's PC but distinguished themselves by a lower price, 
increased portability, or better performance. In time, IBM lost its dominant 
position in the PC market. It is now one of many companies producing IBM 
PC-compatible computers. 
 
IBM never produced an operating system for its PCs–that is, the software 
that organizes the interaction between the user and the computer, starts 
application programs, and manages disk storage and other resources. Instead, 
IBM offered customers the option of three separate operating systems. Most 
customers couldn't care less about the operating system. They chose the 
system that was able to launch most of the few applications that existed at the 
time. It happened to be DOS (Disk Operating System) by Microsoft. 
Microsoft cheerfully licensed the same operating system to other hardware 
vendors and encouraged software companies to write DOS applications. A 
huge number of useful application programs for PC-compatible machines 
was the result. 
 
PC applications were certainly useful, but they were not easy to learn. Every 
vendor developed a different user interface: the collection of keystrokes, 
menu options, and settings that a user needed to master to use a software 
package effectively. Data exchange between applications was difficult, 
because each program used a different data format. The Apple Macintosh 
changed all that in 1984. The designers of the Macintosh had the vision to 
supply an intuitive user interface with the computer and to force software 
developers to adhere to it. It took Microsoft and PC-compatible 
manufacturers years to catch up. 
 
Most personal computers are used for accessing information from online 
sources, entertainment, word processing, and home finance (banking, 
budgeting, taxes). Some analysts predict that the personal computer will 

merge with the television set and cable network into an entertainment and 
information appliance. 
 
 
 
 
 
 
Chap
ter 
Sum
mary
 
 
 
1.   A function is a named sequence of instructions.  
Yenwen Lu/iStockphoto.
 
 
2.   Parameter values are supplied when a function is called. The return value is the 
result that the function computes. 
 
3.   When defining a function, you provide a name for the function, a name and type 
for each parameter, and a type for the result. 
 
4.   Function comments explain the purpose of the function, the meaning of the 
parameters and return value, as well as any special requirements. 
 
5.   Parameter variables hold the parameter values supplied in the function call.  
 
 
 
Klaudia Steiner/iStockphoto (cherries); christine balderas/iStockphoto 
(cherry pie); iStockphoto (apples); dieter Spears/iStockphoto (apple pie). 
 
 
 
 
6.   The return statement terminates a function call and yields the function result.  
 

 
Natalia Bratslavsky/iStockphoto.
 
 
 
 
7.   Turn computations that can be reused into functions. 
 
8.   Use a return type of void to indicate that a function does not return a value. 
 
9.   Use the process of stepwise refinement to decompose complex tasks into simpler 
ones. 
 
10.  The scope of a variable is the part of the program in which it is visible.  
 
 
Joan Champ/iStockphoto (Railway and Main); Steven Johnson/iStockphoto 
(Main and N. Putnam); Jeffrey Smith/iStockphoto (Main and South). 
 
 
 
 
11.  A local variable is defined inside a function. A global variable is defined outside a 
function. 
 
12.  A reference parameter refers to a variable that is supplied in a function call. 
 
13.  A recursive computation solves a problem by using the solution of the same 
problem with simpler inputs.  
Nicolae Popovici/iStockphoto.
 
 
14.  For a recursion to terminate, there must be special cases for the simplest inputs. 
 
15.  The key step to finding a recursive solution is reducing the input to a simpler 
input for the same problem. 
 
16.  When designing a recursive solution, do not worry about multiple nested calls. 
Simply focus on reducing a problem to a slightly simpler one. 
 
 
 

 
Review Exercises 
 
 
Exercise R5.1.     
In which sequence are the lines of the 
program cube.cpp on page 190 
executed, starting with the first line of 
main? 
 
Exercise R5.2.     
Give examples of the following, either 
from the C++ library or from the functions 
discussed in this chapter:  
(a)   A function with two double 
parameters and a double return 
value 
 
(b)   A function with a double 
parameter and a double return 
value 
 
(c)   A function with two int 
parameters and an int return value
 
(d)   A function with an int parameter 
and a string return value 
 
(e)   A function with a string 
parameter and no return value 
 
(f)   A function with a double& and a 
double parameter and no return 
value 
 
(g)   A function with no parameter and 
an int return value 
 
 
 
Exercise R5.3.     
True or false?  
(a)   A function has exactly one 
return statement. 
 
(b)   A function has at least one 
return statement. 
 
(c)   A function has at most one return 
value. 
 
(d)   A function with return value void 
never has a return statement. 
 
(e)   When executing a return 
statement, the function exits 
immediately. 
 

(f)   A function with return value void 
must print a result. 
 
(g)   A function without parameters 
always returns the same value. 
 
 
 
Exercise R5.4.     
Consider these functions:  
double f(double x) { return 
g(x) + sqrt(h(x)); } 
double g(double x) { return 4 * 
h(x); } 
double h(double x) { return x * 
x + k(x) - 1; } 
double k(double x) { return 2 * 
(x + 1); } 
 
Without actually compiling and running a 
program, determine the results of the 
following function calls.  
(a)   double x1 = f(2);
 
(b)   double x2 = g(h(2));
 
(c)   double 
x3 = k(g(2) + h(2));
 
(d)   double 
x4 = f(0) + f(1) + f(2);
 
(e)   double x5 = f( -
 1) + g( - 1) + h( -
 1) + k( - 1); 
 
 
 
Exercise R5.5.     
What is the difference between a 
parameter value and a return value? What 
is the difference between a parameter 
value and a parameter variable? What is 
the difference between a parameter value 
and a value parameter? 
 
Exercise R5.6.     
Write pseudocode for a function that 
translates a telephone number with letters 
in it (such as 1-800-FLOWERS) into the 
actual phone number. Use the standard 
letters on a phone pad.  
 

 
Stacey Newman/iStockphoto.
 
 
 
 
Exercise R5.7.     
For each of the variables in the following 
program, indicate the scope. Then 
determine what the program prints, 
without actually running the program.  
int a = 0; 
int b = 0; 
int f(int c) 
{
   int n = 0; 
   a = c; 
   if (n < c) 
   { 
      n = a + b; 
   } 
   return n; 
}
int g(int c) 
{
   int n = 0; 
   int a = c; 
   if (n < f(c)) 
   { 
      n = a + b; 
   } 
   return n; 
}
int main() 
{
   int i = 1; 
   int b = g(i); 
   cout << a + b + i << endl; 
   return 0; 
}
 
Exercise R5.8.     
We have seen three kinds of variables in 
C++: global variables, parameter variables, 
and local variables. Classify the variables 

of Exercise R5.7. according to these 
categories. 
 
Exercise R5.9.     
Use the process of stepwise refinement to 
describe the process of making scrambled 
eggs. Discuss what you do if you do not 
find eggs in the refrigerator. 
 
Exercise R5.10.     
How many parameters does the following 
function have? How many return values 
does it have? Hint: The C ++ notions of 
“parameter value” and “return value” are 
not the same as the intuitive notions of 
“input” and “output”.  
void average(double& avg) 
{
   cout << "Please enter two 
numbers: "; 
   double x; 
   double y; 
   cin >> x >> y; 
   avg = (x + y) / 2; 
}
 
Exercise R5.11.     
Perform a walkthrough of the int_name 
function with the following parameter 
values:  
(a)   5 
 
(b)   12 
 
(c)   21 
 
(d)   301 
 
(e)   324 
 
(f)   0 
 
(g)   -2 
 
 
 
Exercise R5.12.     
Consider the following function:  
int f(int n) 
{
   if (n <= 1) { return 1; } 
   if (n % 2 == 0) // n is even 
   { 
      return f(n / 2); 
   } 
   else { return f(3 * n + 1); } 
}
Perform traces of the computations f(1), 
f(2), f(3), f(4), f(5), 

f(6), f(7), f(8), f(9), and 
f(10). 
 
Exercise R5.13.     
Consider the following function that is 
intended to swap the values of two 
integers:  
void false_swap1(int& a, int& b) 
{
   a = b; 
   b = a; 
}
int main() 
{
   int x = 3; 
   int y = 4; 
   false_swap1(x, y); 
   cout << x << " " << y << endl; 
   return 0; 
}
Why doesn't the function swap the 
contents of x and y? How can you rewrite 
the function to work correctly? 
 
Exercise R5.14.     
Consider the following function that is 
intended to swap the values of two 
integers:  
void false_swap2(int a, int b) 
{
   int temp = a; 
   a = b; 
   b = temp; 
}
int main() 
{
   int x = 3; 
   int y = 4; 
   false_swap2(x, y); 
   cout << x << " " << y << endl; 
   return 0; 
}
Why doesn't the function swap the 
contents of x and y? How can you rewrite 
the function to work correctly? 
 
Exercise R5.15.     
The following function swaps two 
integers, without requiring a temporary 
variable.  
void tricky_swap(int& a, int& b) 
{

   a = a - b; 
   b = a + b; 
   a = b - a; 
}
However, it fails in one important case, 
namely when calling tricky swap(x, 
x). Explain what should happen and what 
actually happens. 
 
Exercise R5.16.     
Give pseudocode for a recursive function 
for printing all substrings of a given string. 
For example, the substrings of the string 
"rum" are "rum" itself, "ru", "um", 
"r", "u", "m", and the empty string. 
You may assume that all letters of the 
string are different. 
 
Exercise R5.17.     
Give pseudocode for a recursive function 
that sorts all letters in a string. For 
example, the string "goodbye" would be 
sorted into "bdegooy". 
 
 
 
Programming Exercises 
 
 
Exercise P5.1.     
Write a function that computes the balance of a bank 
account with a given initial balance and interest rate, 
after a given number of years. Assume interest is 
compounded yearly. 
 
Exercise P5.2.     
Write a function  
string repeat(string str, int n) 
that returns the string str repeated n times. For 
example, repeat("ho", 3) returns "hohoho". 
 
Exercise P5.3.     
Write a function  
int count_vowels(string str) 
that returns a count of all vowels in the string str. 
Vowels are the letters a, e, i, o, and u, and their 
uppercase variants. 
 
Exercise P5.4.     
Write a function  
int count_words(string str) 
that returns a count of all words in the string str. 
Words are separated by spaces. For example, 
count_words("Mary had a little lamb")

should return 5. 
 
Exercise P5.5.     
It is a well-known phenomenon that most people are 
easily able to read a text whose words have two 
characters flipped, provided the first and last letter of 
each word are not changed. For example: 
 
I dn'ot gvie a dman for a man taht can olny sepll a wrod 
one way. (Mrak Taiwn) 
 
Write a function string scramble(string 
word) that constructs a scrambled version of a given 
word, randomly flipping two characters other than the 
first and last one. Then write a program that reads words 
from cin and prints the scrambled words. 
 
Exercise P5.6.     
Write functions  
double sphere_volume(double r) 
double sphere_surface(double r) 
double cylinder_volume(double r, double h) 
double cylinder_surface(double r, double h) 
double cone_volume(double r, double h) 
double cone_surface(double r, double h) 
that compute the volume and surface area of a sphere 
with radius r, a cylinder with a circular base with radius 
r and height h, and a cone with a circular base with 
radius r and height h. Then write a program that 
prompts the user for the values of r and h, calls the six 
functions, and prints the results. 
 
Exercise P5.7.     
Write a function  
double read_double(string prompt) 
that displays the prompt string, followed by a space, 
reads a floating-point number in, and returns it. Here is a 
typical usage:  
salary = read_double("Please enter your 
salary:");
perc_raise = read_double("What percentage 
raise would you like?"); 
 
Exercise P5.8.     
Write a function void sort2(int& a, int& b) 
that swaps the values of a and b if a is greater than b 
and otherwise leaves a and b unchanged. For example,  
int u = 2; 
int v = 3; 
int w = 4; 
int x = 1; 
sort2(u, v); // u is still 2, v is still 3 

sort2(w, x); // w is now 1, x is now 4 
 
Exercise P5.9.     
Write a function sort3(int& a, int& b, int& 
c) that swaps its three parameters to arrange them in 
sorted order. For example,  
int v = 3; 
int w = 4; 
int x = 1; 
sort3(v, w, x); // v is now 1, w is now 3, x 
is now 4 
Hint: Use sort2 of Exercise P5.8. 
 
Exercise P5.10.     
Enhance the int_name function so that it works 
correctly for values < 1,000,000,000. 
 
Exercise P5.11.     
Enhance the int_name function so that it works 
correctly for negative values and zero. Caution: Make 
sure the improved function doesn't print 20 as "twenty 
zero". 
 
Exercise P5.12.     
For some values (for example, 20), the int_name 
function returns a string with a leading space (" 
twenty"). Repair that blemish and ensure that spaces 
are inserted only when necessary. Hint: There are two 
ways of accomplishing this. Either ensure that leading 
spaces are never inserted, or remove leading spaces 
from the result before returning it. 
 
Exercise P5.13.     
Write a program that prints a paycheck. Ask the 
program user for the name of the employee, the hourly 
rate, and the number of hours worked. If the number of 
hours exceeds 40, the employee is paid “time and a 
half”, that is, 150 percent of the hourly rate on the hours 
exceeding 40. Your check should look similar to that in 
Figure 6. Use fictitious names for the payer and the 
bank. Be sure to use stepwise refinement and break your 
solution into several functions. Use the int_name 
function to print the dollar amount of the check. 
 
Exercise P5.14.     
Leap years. Write a function  
bool leap_year(int year) 
that tests whether a year is a leap year: that is, a year 
with 366 days. Leap years are necessary to keep the 
calendar synchronized with the sun because the earth 
revolves around the sun once every 365.25 days. 

Actually, that figure is not entirely precise, and for all 
dates after 1582 the Gregorian correction applies. 
Usually years that are divisible by 4 are leap years, for 
example 1996. However, years that are divisible by 100 
(for example, 1900) are not leap years, but years that are 
divisible by 400 are leap years (for example, 2000). 
 
Exercise P5.15.     
Write a program that converts a Roman number such as 
MCMLXXVIII to its decimal number representation. 
Hint: First write a function that yields the numeric value 
of each of the letters. Then use the following algorithm: 
total = 0 
While the roman number string is not empty 
{
   If the first character has a larger value 
than the second, or the string has length 1 
   { 
       Add value(first character) to total. 
       Remove the character. 
   } 
   Else 
   { 
       Add value(second character) - 
value(first character) to total. 
       Remove both characters. 
   } 
}
 
Exercise P5.16.     
In Exercise P3.22. you were asked to write a program to 
convert a number to its representation in Roman 
numerals. At the time, you did not know how to factor 
out common code, and as a consequence the resulting 
program was rather long. Rewrite that program by 
implementing and using the following function:  
string roman_digit(int n, string one, string 
five, string ten) 
That function translates one digit, using the strings 
specified for the one, five, and ten values. You would 
call the function as follows:  
roman_ones = roman_digit(n % 10, "I", "V", 
"X");
n = n / 10; 
roman_tens = roman_digit(n % 10, "X", "L", 
"C");
. . . 
 
Exercise P5.17.     
Postal bar codes. For faster sorting of letters, the United 
States Postal Service encourages companies that send 
large volumes of mail to use a bar code denoting the zip 

code (see Figure 10). 
 
 
 
 
 
 
  Figure 10    A Postal Bar Code
 
 
 
 
The encoding scheme for a five-digit zip code is shown 
in Figure 11. There are full-height frame bars on each 
side. The five encoded digits are followed by a check 
digit, which is computed as follows: Add up all digits, 
and choose the check digit to make the sum a multiple 
of 10. For example, the zip code 95014 has a sum of 19, 
so the check digit is 1 to make the sum equal to 20. 
 
 
 
 
 
 
   Figure 11    Encoding for Five-Digit Bar 
Codes 
 
 
 
 
Each digit of the zip code, and the check digit, is 
encoded according to the following table where 0 
denotes a half bar and 1 a full bar.  
 
  7 4 2
1
0
1 0 0 0
1
1
2 0 0 1
0
1
3 0 0 1
1
0
4 0 1 0
0
1
5 0 1 0
1
0
6 0 1 1
0
0

7 1 0 0
0
1
8 1 0 0
1
0
9 1 0 1
0
0
0 1 1 0
0
0
 
 
 
 
The digit can be easily computed from the bar code 
using the column weights 7, 4, 2, 1, 0. For example, 
01100 is 0 × 7 + 1 × 4 + 1 × 2 + 0 × 1 × 0 × 0 = 6. The 
only exception is 0, which would yield 11 according to 
the weight formula. 
 
Write a program that asks the user for a zip code and 
prints the bar code. Use : for half bars, | for full bars. For 
example, 95014 becomes  
||:|:::|:|:||::::::||:|::|:::|||
 
Exercise P5.18.     
Write a program that reads in a bar code (with : denoting 
half bars and | denoting full bars) and prints out the zip 
code it represents. Print an error message if the bar code 
is not correct. 
 
Exercise P5.19.     
Write a program that prints instructions to get coffee, 
asking the user for input whenever a decision needs to 
be made. Decompose each task into a function, for 
example:  
void brew_coffee() 
{
   cout << "Add water to the coffee 
maker." << endl; 
   cout << "Put a filter in the coffee 
maker." << endl; 
   grind_coffee(); 
   cout << "Put the coffee in the 
filter." << endl; 
   . . . 
}
 
Exercise P5.20.     
Write a recursive function  
string reverse(string str) 
that computes the reverse of a string. For example, 
reverse("flow") should return "wolf". Hint: 
Reverse the substring starting at the second character, 
then add the first character at the end. For example, to 
reverse "flow", first reverse "low" to "wol", then 
add the "f" at the end. 
 

Exercise P5.21.     
Write a recursive function  
bool is_palindrome(string str) 
that returns true if str is a palindrome, that is, a word 
that is the same when reversed. Examples of palindrome 
are “deed”, “rotor”, or “aibohphobia”. Hint: A word is a 
palindrome if the first and last letters match and the 
remainder is also a palindrome. 
 
Exercise P5.22.     
Use recursion to implement a function bool 
find(string str, string match) that tests 
whether match is contained in str:  
bool b = find("Mississippi", "sip"); // Sets 
b to true 
Hint: If str starts with match, then you are done. If 
not, consider the string that you obtain by removing the 
first character. 
 
Exercise P5.23.     
Use recursion to determine the number of digits in a 
number n. Hint: If n is < 10, it has one digit. Otherwise, 
it has one more digit than n / 10. 
 
Exercise P5.24.     
Use recursion to compute an, where n is a positive 
integer. Hint: If n is 1, then an = a. If n is even, then 
an = (an/2)2. Otherwise, an = a × an-1. 
 
 
 
Answers to Self-Check 
Questions 
 
 
1.  The parameter values are 3 and 2. The return value is 9. 
 
 
2.  The inner call to pow returns 22 = 4. Therefore, the outer call returns 42 = 16. 
 
 
3.  3 
 
 
4.  Users of the function can treat it as a black box. 
 
 
5.  27 
 
 
6.  8 × 8 × 8 = 512 
 
 
7.  double volume = pow(side_length, 3); 
return volume; 
 
 
8.  double square_area(double side_length) 
{
   double area = side_length * side_length; 
   return area; 
}
 
 
9.  (2 + 3) / (3 - 2) = 5
 
 
10.  When the function is called, x is set to 5, y is set to 7, and z becomes 12. Then z is 

changed to 6, and that value is returned and printed. 
 
 
11.  When the function is called, x is set to 5. Then y is set to 25, and that value is 
returned and printed. 
 
 
12.  When the function is called, n is set to 5. Then n is incremented twice, setting it to 7. 
That value is returned and printed. 
 
 
13.  box_string("Hello");
box_string("World");
 
 
14.  The box_string function does not return a value. Therefore, you cannot use it in a 
 <<  expression. 
 
 
15.  void shout(string str) 
{
cout << str << "!!!" << endl; 
}
 
 
16.  void box_string(string str) 
{
   int n = str.length(); 
   for (int i = 0; i < n + 4; i++) { cout << "-"; } 
   cout << endl; 
   cout << "! " << str << " !" << endl; 
   for (int i = 0; i < n + 4; i++) { cout << "-"; } 
   cout << endl; 
}
 
 
17.  void print_line(int count) 
{
   for (int i = 0; i < count; i++) { cout << "-"; } 
   cout << endl; 
}
void box_string(string str) 
{
   int n = str.length(); 
   print_line(n + 2); 
   cout << "!" << str << "!" << endl; 
   print_line(n + 2); 
}
 
 
18.  Change line 75 to  
name = name + digit_name(part / 100) + " hundred"; 
In line 72, add the statement  
if (part >= 1000) 
{
   name = digit_name(part / 1000) + "thousand "; 
   part = part % 1000; 
}
In line 65, change 1000 to 10000 in the comment. 
 
 
19.  In the case of “teens”, we already have the last digit as part of the name. 
 
 
20.  Nothing is printed. One way of dealing with this case is to add the following 
statement before line 70.  
if (number == 0) { return "zero"; } 
 
 
21.  Here is the approximate trace:  

 
 
 
Note that the string starts with a blank space. Exercise P5.12. asks you to eliminate it.
 
 
22.  Here is one possible solution. Break up the task print table into print header and print 
body . The print header task calls print separator , prints the header cells, and calls 
print separator again. The print body task repeatedly calls print row and then calls 
print separator . 
 
 
23.  1 
 
 
24.  2, 7 
 
 
25.  Lines 3, 4, 5, 6, 10, 11, but not 7 through 9 
 
 
26.  The global variable defined in line 1. 
 
 
27.  The variables s defined in lines 4 and 15. 
 
 
28.  Yes, but since the function does not modify the amount parameter variable, there is 
no need to do so. 
 
 
29.  void transfer(double& balance1, double& balance2, double amount) 
 
 
30.  bool withdraw(double& balance, double amount) 
{
   if (balance >= amount) 
   { 
      balance = balance - amount; 
      return true; 
   } 
   else 
   { 
      return false; 
   } 
}
 
 
31.  void minmax(double x, double y, double& a, double& b) 
{
   if (x < y) { a = x; b = y; } 
   else { a = y; b = x; } 
}
 
 
32.  The program sets x to 1, then y to 4, then x to 3. It prints 3 4. 
 
 
33.  [][][][]
[][][]
[][]
[]
 
 
34.  4 + 3 + 2 + 1 + 0 = 10 
 
 
35.mystery(10) + 1 = mystery(5) + 2 = mystery(2) + 3 = mystery(1) + 4 = 

   mystery(0) + 5 = 5 
 
 
36.  The idea is to print one [], then print n - 1 of them.  
void print_boxes(int n) 
{
   if (n == 0) { return; } 
   cout << "[]"; 
   print_boxes(n - 1); 
}
 
 
37.  Simply add the following to the beginning of the function:  
if (part >= 1000) 
{
   return int_name(part / 1000) + " thousand " + int_name(part % 
1000);
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

Worked Example 5.1
•
Matching and Replacing Parts of a String
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Matching and Replacing Parts of a String
Searching and replacing text is a common word processor function. Your task is to write a
function that replaces the ﬁrst occurrence of one string with another in a given string. For
example, when asked to replace "ss" with "n" in "Mississippi", the result is "Minissippi".
Step 1
Describe what the function should do.
This has been given to us already. 
Step 2
Determine the function’s “inputs”.
There are three parameters:
• The string that is being edited (such as "Mississippi")
• The string that is being replaced (such as "ss")
• The replacement string (such as "n")
At this point, we have enough information to document the function:
/**
   Replaces the ﬁrst occurrence of match in str with repl.
   @param str the string that is being edited
   @param match the string that is being replaced 
   @param repl the replacement string
*/
Step 3
Determine the types of the parameters and the return value.
The parameters are all strings. However, because the ﬁrst parameter is being modiﬁed, its
type is string&. The function modiﬁes the ﬁrst parameter, and it does not return a value.
Therefore, the return type is void.
The function will be deﬁned as
void replace_first(string& str, string match, string repl)
Step 4
Write pseudocode for obtaining the desired result. 
We ﬁrst need to ﬁnd the position in which match occurs. (If it doesn’t occur anywhere, we do
nothing.) For example, the string "ss" is found in position 2 in "Mississippi". Let us assume
that we know that position, and call it i. Then the answer is obtained by concatenating
• the substring of str from 0 to i - 1
• the replacement string
• the substring of str from i + match.length() to the end
How do we ﬁnd that position? In the spirit of stepwise reﬁnement, we will delegate that task
to another function. That starts a new sequence of steps, which, for greater clarity, we will
place after the steps for this function.
WORKED EXAMPLE 5.1

2
C++ for Everyone  •  CHAPTER 5
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Step 5
Implement the function body.
We simply translate the plan into C++:
{
   int i = find_index(str, match);
   if (i == -1) { return; } // No match
   str = str.substr(0, i) + repl + str.substr(i + match.length());
}
Step 6
Test your function.
We ﬁrst test whether "Mississippi" is edited as expected, and then we add a couple of addi-
tional tests.
int main()
{
   string river = "Mississippi";
   replace_first(river, "ss", "n");
   cout << river << endl;
   cout << "Expected: Minissippi" << endl;
   replace_first(river, "ss", "n");
   cout << river << endl;
   cout << "Expected: Mininippi" << endl;
   replace_first(river, "ss", "n"); // No more match––should do nothing
   cout << river << endl;
   cout << "Expected: Mininippi" << endl;
   return 0;
}
Repeat for the Helper Function
Now it is time to turn to the helper function for ﬁnding the match position.
Step 1
Describe what the function should do.
It should ﬁnd and return the ﬁrst index in which a substring occurs in a given string, or
return –1 if the substring doesn’t occur anywhere.
Step 2
Determine the function’s “inputs”.
There are two parameters:
• The string that is being searched (such as "Mississippi")
• The substring that is being matched (such as "ss")
At this point, we have enough information to document the function:
/**
   Finds the index of the ﬁrst occurrence of match in str.
   @param str the string that is being searched
   @param match the substring that is being matched 
   @return the ﬁrst index at which match occurs in str, or -1 if it doesn’t 
      occur anywhere
*/

Worked Example 5.1
•
Matching and Replacing Parts of a String
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Step 3
Determine the types of the parameters and the return value.
The parameters are both strings. Neither of them is being modiﬁed. Therefore, they are both
value parameters. The return type is int. The function will be deﬁned as
int find_index(string str, string match)
Step 4
Write pseudocode for obtaining the desired result. 
We start at index 0. Let n be the length of match. If str.substr(0, n) equals match, we have
found our match. If not, we increment the index. If i denotes the current index, we test
whether str.substr(i, n) equals match. If so, we return i. We keep incrementing i while
there is still a hope of a match. Eventually, the unexamined tail of str is shorter than match,
and we stop, returning –1.
Step 5
Implement the function body.
We translate the plan into C++:
{
   int n = match.length();
   for (int i = 0; i <= str.length() - match.length(); i++)
   {
      if (str.substr(i, n) == match) { return i; }
   }
   return -1;
}
Step 6
Test your function.
We ﬁrst test whether the "ss" in "Mississippi" is located at the expected position, and then
we try a string that doesn’t occur. 
int main()
{
   string river = "Mississippi";
   int n = find_index(river, "ss");
   cout << n << endl;
   cout << "Expected: 2" << endl;
   n = find_index(river, "tt");
   cout << n << endl;
   cout << "Expected: -1" << endl;
   return 0;
}
See ch05/match.cpp for the complete program with both functions.

Worked Example 5.2
•
Calculating a Course Grade
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Calculating a Course Grade
Students in this course take four exams and earn a letter grade (A+, A, A–, B+, B, B–, C+, C,
C–, D+, D, D–, or F) for each of them. The course grade is determined by dropping the low-
est grade and averaging the three remaining grades. To average grades, ﬁrst convert them to
number grades, using the usual scheme A+ = 4.3, A = 4.0, A– = 3.7, B+ = 3.3, ..., D– = 0.7,
F = 0. Then compute their average and convert it back to the closest letter grade. For exam-
ple, an average of 3.51 would be an A–. 
Your task is to read inputs of the form:
letter_grade1 letter_grade2 letter_grade3 letter_grade4
For example,
A- B+ C A
For each input line, your output should be
letter_grade
where the letter grade is the grade earned in the course, as just described. For example,
A-
The end of inputs will be indicated by a letter_grade1 ﬁeld of Q.
Step 1
Carry out stepwise reﬁnement.
We will use the process of stepwise reﬁnement. To process the inputs, we can process each
line individually. Therefore, we deﬁne a task process line. 
To process a line, we read the ﬁrst grade and bail out if it is a Q. Otherwise, we read the
four grades. Since we need them in their numeric form, we identify a task convert letter grade to
number. 
We then have four numbers and need to ﬁnd the smallest one. That is another task, find
smallest of four numbers. To average the remaining ones, we compute the sum of all values, sub-
tract the smallest, and divide by three. Let’s say that is not worth making into a subtask.
Next, we need to convert the result back into a letter grade. That is yet another subtask
convert number grade to letter. Finally, we print the letter grade. That is again so simple that it
requires no subtask.
Step 2
Convert letter grade to number.
How do we convert a letter grade to a number? Take the ﬁrst character, and convert A to 4,
B to 3, C to 2, D to 1, and F to 0. If there is a + sufﬁx, add 0.3, and if there is a – sufﬁx,
subtract 0.3. 
Here is a function for that task.
/**
   Converts a letter grade to a number.
   @param grade a letter grade (A+, A, A-, ..., D-, F)
   @return the equivalent number grade
*/
double grade_to_number(string grade)
{
WORKED EXAMPLE 5.2

2
C++ for Everyone  •  CHAPTER 5
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   double result = 0;
   string first = grade.substr(0, 1);
   if (first == "A") { result = 4; }
   else if (first == "B") { result = 3; }
   else if (first == "C") { result = 2; }
   else if (first == "D") { result = 1; }
   if (grade.length() > 1)
   {
      if (grade.substr(1, 1) == "+")
      {
         result = result + 0.3;
      }
      else 
      {
         result = result - 0.3;
      }
   }
   return result;
}
Step 3
Convert number grade to letter.
How do we do the opposite conversion? Here, the challenge is that we need to convert to the
nearest letter grade. For example, if x is the number grade, then we have:
2.5 ≤ x < 2.85:  B-
2.85 ≤ x < 3.15:  B
3.15 ≤ x < 3.5:  B+
We can make a function with 13 branches, one for each valid letter grade.
/**
   Converts a number to the nearest letter grade.
   @param x a number between 0 and 4.3
   @return the nearest letter grade
*/
string number_to_grade(double x)
{
   if (x >= 4.15) { return "A+"; }
   if (x >= 3.85) { return "A"; }
   if (x >= 3.5) { return "A-"; }
   if (x >= 3.15) { return "B+"; }
   if (x >= 2.85) { return "B"; }
   if (x >= 2.5) { return "B-"; }
   if (x >= 2.15) { return "C+"; }
   if (x >= 1.85) { return "C"; }
   if (x >= 1.5) { return "C-"; }
   if (x >= 1.15) { return "D+"; }
   if (x >= 0.85) { return "D"; }
   if (x >= 0.5) { return "D-"; }
   return "F";
}

Worked Example 5.2
•
Calculating a Course Grade
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Step 4
Find the minimum of four numbers.
Finally, how do we ﬁnd the smallest of four numbers? Let’s suppose we can ﬁnd the smallest
of two numbers, with a function min(x, y). Then the smallest of four numbers is
min(min(x1, x2), min(x3, x4)). Finding the smallest of two numbers is easy.
/**
   Returns the smaller of two numbers.
   @param x a number
   @param y a number
   @return the smaller of x and y
*/
double min(double x, double y) 
{ 
   if (x < y) 
   { 
      return x; 
   } 
   else 
   { 
      return y; 
   }
}
Step 5
Process a line.
As previously described, to process a line, we read in the four input strings, convert grades to
numbers, and compute the average after dropping the lowest grade. Then we print the grade
corresponding to that average. 
However, if we read the ﬁrst input string and ﬁnd a Q, we need to signal to the caller that
we have reached the end of the input set and that no further calls should be made. 
Our function will return a bool value, true if it was successful, false if it encountered the
sentinel.
/**
   Processes one line of input.
   @return true if the sentinel was not encountered
*/
bool process_line()
{
   cout << "Enter four grades or Q to quit: ";
   string g1;
   cin >> g1;
   if (g1 == "Q") { return false; }
   string g2;
   string g3;
   string g4;
   cin >> g2 >> g3 >> g4;
   double x1 = grade_to_number(g1);
   double x2 = grade_to_number(g2);
   double x3 = grade_to_number(g3);
   double x4 = grade_to_number(g4);
   double xlow = min(min(x1, x2), min(x3, x4));
   double avg = (x1 + x2 + x3 + x4 - xlow) / 3;

4
C++ for Everyone  •  CHAPTER 5
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   cout << number_to_grade(avg) << endl;
   return true;
}
Step 6
Write the main function.
The main function is now utterly trivial. We keep calling process_line while it returns true.
int main()
{
   while (process_line())
   {
   }
   return 0;
}
See ch05/grades.cpp for the complete program.

Chapter
   
    
    
Chapter Goals
•  To become familiar with using arrays and vectors to collect values
•  To learn about common algorithms for processing arrays and vectors
•  To write functions that receive and return arrays and vectors
•  To learn how to use two-dimensional arrays
In many programs, you need to collect large numbers of values. In standard C++, the vector construct allows you
to conveniently manage collections that automatically grow to any desired size. A lower-level construct, the array,
is less convenient but sometimes required for efficiency or compatibility with older software. In this chapter, you
will learn about arrays, vectors, and common algorithms for processing them.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To become fa ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:20 PM

Using Arrays and Vectors
In the following sections, we introduce the array and vector constructs. Arrays and vectors allow you to store a sequence of values of the same type. You will learn how to define
and use arrays and vectors, and how to decide which of the two is the best choice for a particular problem.
Use an array or vector to collect a sequence of values of the same type.
6.1.1 Arrays
Suppose you write a program that reads a sequence of values and prints out the sequence, marking the largest value, like this:
You do not know which value to mark as the largest one until you have seen them all. After all, the last value might be the largest one. Therefore, the program must first store all
values before it can print them.
Could you simply store each value in a separate variable? If you know that there are ten inputs, then you can store the data in ten variables 
, 
, 
, …, 
.
However, such a sequence of variables is not very practical to use. You would have to write quite a bit of code ten times, once for each of the variables. In C++, an arrray is a
much better choice for storing a sequence of values.
Here we define an array that can hold ten values:
This is the definition of a variable 
 whose type is “array of 
”. That is, 
 stores a sequence of floating-point numbers. The 
 indicates the size of the array.
(See Figure 1.) The array size must be a constant that is known at compile-time.
Figure 1   An Array of Size 10
When you define an array, you can specify the initial values. For example,
When you supply initial values, you don't need to specify the array size.The compiler determines the size by counting the values.
In general, array variables are defined as in Syntax 6.1. To access a value in the 
 array, you must specify which “slot” you want to use. That is done with the 
 operator:
Individual elements in an array data are accessed by an integer index , using the
notation 
.
Using Arrays and Vectors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:21 PM

Like a post office box that is identified by a box number, an array elementis identified by an index.
Max Dimyadi/iStockphoto.
Now the number 4 slot of 
 is filled with 35. (See Figure 2). This “slot number” is called an index. Each slot in an array is called an element.
An array element can be used like any variable.
Figure 2   Filling an Array Element
Because 
 is an array of 
 values, each element 
 can be used like any variable of type 
. For example, you can display the contents of the element with
index 4 with the following command:
Before continuing, we must take care of an important detail of C++ arrays. If you look carefully at Figure 2, you will find that the fifth element was filledwith data when we
changed 
. In C++, the elements of arrays are numbered starting at 0. That is, the legal elements for the 
 array are
You will see in Chapter 7 why this numbering scheme was chosen in C++.
An array index must be at least zero and less than the size of the array.
You have to be careful about index values. Trying to access a element that does not exist in the array is a serious error. For example, if 
 has ten elements, you are not
allowed to access 
. Attempting to access an element whose index is not within the valid index range is called a bounds error. The compiler does not catch this type of
error. Even the running program generates no error message. If you make a bounds error, you silently read or overwrite anothermemory location. As a consequence, your program
may have random errors, and it can even crash.
The most common bounds error is the following:
There is no 
 in an array with ten elements—the legal index values range from 0 to 9.
A bounds error, which occurs if you supply an invalid array index, can corrupt
data or cause your program to terminate.
To visit all elements of an array, use a variable for the index. Suppose 
 has ten elements and the integer variable  takes values 0, 1, 2, and so on, up to 9. Then the
expression 
 yields each element in turn. For example, this loop displays all elements.
Note that the loop condition is that the index is less than 10 because there is no element corresponding to 
.
Table 1    Defining Arrays
  
An array of ten integers.
  
  
It is a good idea to use a named constantfor the size.
 
Error: The size must be a constant.
  
An array of five integers, with initial values.
  
You can omit the array size if you supply initial values. The size is set to the number of initial values.
  
If you supply fewer initial values than the size, the remaining values are set to 0. This array contains 0, 1, 4, 0, 0.
  
An array of three strings.
Using Arrays and Vectors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:21 PM

6.1.2 Vectors
When you write a program that collects values from user input, you don't always know how many values you will have. Unfortunately, the size of the array hasto be known when
the program is compiled. The vector construct has been designed to solve this problem. A vector collects a sequence of values, just like an array does, but its size can change.
A vector stores a sequence of values whose size can change.
When you define a vector, you can specify the initial size. For example, here is a definition of a vector whose initial size is 10.
Use the 
 member function to add more elements to a vector. Use
 to reduce the size.
You access the vector elements as 
, just like you do with arrays. If you need additional elements, you use the 
 function to add an element to the end of the
vector, thereby increasing its size by 1. The 
 function is a member function that you must call with the dot notation, like this:
After this call, the vector 
 has size 11, and 
 contains the value 37.5 (see Figure 3).
Figure 3   Adding an Element with 
When you define a vector, you need not specify an initial size. By default, a vector is empty.
Now
is empty
Note that the element type is enclosed in angle brackets.
You can then use the 
 function to fill it. For example,
Now
has size
and element
Now
has size 
and elements
Now
has size
and elements
In particular, you will want to use the 
 function when filling a vector with input values.
Another member function, 
, removes the last element of a vector, shrinking its size by one.
Table 2    Defining Vectors
  
A vector of ten integers.
  
A vector of three strings.
  
A vector of size 0.
 
Error: Does not define a vector.
  
A vector of ten integers, filled with 1, 2, 3, …, 10.
Using Arrays and Vectors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:21 PM

  
Another way of defining a vector of ten integers and filling it with 1, 2, 3, …, 10.
The 
 member function returns the current size of a vector. In a loop that visits all vector elements, use the 
 member function like this:
In order to use vectors in your program, you need to include the 
 header.
Use the 
 function to obtain the current size of a vector.
6.1.3 Partially-Filled Arrays
Unlike a vector, an array cannot change size at run time. There is no analog to the 
 or 
 member functions. This is a problem when you don't know in
advance how many elements you need. In that situation, you must come up with a good guess on the maximum number of elements that you need to store. We call this quantity
the capacity. For example, we may decide that we sometimes want to store more than ten values, but never more than 100:
In a typical program run, only a part of the array will be occupied by actual elements. We call such an array a partially-filled array. You must keep a companion variable that
counts how many elements are actually used. In Figure 4 we call the companion variable 
.
With a partially-filled array, keep a companion variable for the current 
.
Figure 4   A Partially-Filled Array
The following loop collects data and fills up the 
 array.
At the end of this loop, 
 contains the actual number of elements in the array. Note that you have to stop accepting inputs if the size of the array reaches the capacity.
To process the gathered array elements, you again use the companion variable, not the capacity. This loop prints the partially filled array:
Self Check
1.  Define an array of integers containing the first five prime numbers. 
2.  Assume the array 
 has been initialized as described in Self Check 1. What is its contents after executing the following loop? 
Using Arrays and Vectors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:21 PM

3.  Assume the array 
 has been initialized as described in Self Check 1. What is its contents after executing the following loop? 
4.  Given the definition 
write statements to put a zero into the elements of the array 
 with the lowest and the highest valid index.
5.  Given the array defined in Self Check 4, write a loop to print the elements of the array 
 in reverse order, starting with the last element. 
6.  Define an array called 
 that can hold ten values of type 
. 
7.  Define an array containing two strings, 
, and 
. 
8.  Define a vector of integers that contains the first five prime numbers (2, 3, 5, 7, and 11). 
9.  What is the contents of the vector 
 after the following statements? 
10.  Suppose you want to store the names of the weekdays. Should you use a vector or an array of seven strings? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Using Arrays and Vectors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:21 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 6.1 Defining an Array
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:21 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 6.2 Defining a Vector
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:22 PM

Common Error 6.1
COMMON ERROR 6.1 Bounds Errors
Perhaps the most common error with using arrays and vectors is accessing a nonexistent element.
Error—data has 10 elements with subscripts 0 to 9
If your program accesses an array or vector through an out-of-bounds subscript, there is no error message. Instead,
the program will quietly (or not so quietly) corrupt some memory. Except for very short programs, in which the
problem may go unnoticed, that corruption will make the program act unpredictably, and it can even cause the
program to terminate. These are serious errors that can be difficult to detect.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 6.1 Bounds Errors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:22 PM

Productivity Hint 6.1
PRODUCTIVITY HINT 6.1 Prefer Vectors over Arrays
For most programming tasks, vectors are easier to use than arrays. Vectors can grow and shrink. Even if a vector
always stays the same size, it is convenient that a vector remembers its size. For a beginner, the sole advantage of
an array is the initialization syntax. Advanced programmers sometimes prefer arrays because they are a bit more
efficient. Moreover, you need to know how to use arrays if you work with older programs.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
PRODUCTIVITY HINT 6.1 Prefer Vectors over Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:22 PM

Common Error 6.2
COMMON ERROR 6.2 Arrays Cannot Be Assigned
Suppose you have two arrays
The following assignment is an error:
Error
You must use a loop to copy all elements:
Vectors do not suffer from this limitation. Consider this example:
Initially empty
Now
contains the same elements as
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 6.2 Arrays Cannot Be Assigned
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:22 PM

Random Fact 6.1
RANDOM FACT 6.1 An Early Internet Worm
In November 1988, Robert Morris, a college student at Cornell University launched a so-called virus program that
infected about 6,000 computers connected to the Internet across the United States. Tens of thousands of computer
users were unable to read their e-mail or otherwise use their computers. All major universities and many high-tech
companies were affected. (The Internet was much smaller then than it is now.)
The particular kind of virus used in this attack is called a worm. The virus program crawled from one computer on
the Internet to the next. The worm would attempt to connect to 
, a program in the UNIX operating system
for finding information on a user who has an account on a particular computer on the network. Like many
programs in UNIX, 
 was written in the C language. C does not have vectors, only arrays, and when you
construct an array in C, you have to make up your mind how many elements you need. To store the user name to be
looked up (say, walters@cs.sjsu.edu), the 
 program allocated an array of 512 characters, under the
assumption that nobody would ever provide such a long input. Unfortunately, C does not check that an array index
is less than the length of the array. If you write into an array, using an index that is too large, you simply overwrite
memory locations that belong to some other objects. In some versions of the 
 program, the programmer
had been lazy and had not checked whether the array holding the input characters was large enough to hold the
input. So the worm program purposefully filled the 512-character array with 536 bytes. The excess 24 bytes would
overwrite a return address, which the attacker knew was stored just after the line buffer. When that function was
finished, it didnÕt return to its caller but to code supplied by the worm (see Figure 5). That code ran under the
same super-user privileges as 
, allowing the worm to gain entry into the remote system. Had the
programmer who wrote 
 been more conscientious, this particular attack would not be possible. In C++,
as in C, all programmers must be very careful not to overrun array boundaries.
Figure 5   A “Buffer Overrun” Attack
One may well speculate what would possess the virus author to spend many weeks to plan the antisocial act of
breaking into thousands of computers and disabling them. It appears that the break-in was fully intended by the
author, but the disabling of the computers was a bug, caused by continuous reinfection. Morris was sentenced to 3
years probation, 400 hours of community service, and a $10,000 fine.
In recent years, computer attacks have intensified and the motives have become more sinister. Instead of disabling
computers, viruses often steal financial data or use the attacked computers for sending spam e-mail. Sadly, many of
these attacks continue to be possible because of poorly written programs that are susceptible to buffer overrun
errors.
RANDOM FACT 6.1 An Early Internet Worm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:22 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 6.1 An Early Internet Worm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:22 PM

In the following sections, we discuss some of the most common algorithms for working with arrays and vectors. For
simplicity, we will use vectors in our examples. If you use arrays, remember to replace the 
 member function with the
array's size (or the companion variable used to represent it).
6.2.1 Filling
This loop fills a vector with zeroes:
Here, we fill a vector with squares (0, 1, 4, 9, 16, …). Note that the element with index 0 contains 02, the element with index 1
contains 12, and so on.
6.2.2 Sum and Average Value
To compute the sum of all elements in a vector, simply keep a running total.
To obtain the average, divide by the number of elements:
Be sure to check that the size is not zero.
6.2.3 Maximum and Minimum
To compute the largest value in a vector, keep a variable that stores the largest element that you have encountered, and update
it when you find a larger one.
Note that the loop starts at 1 because we initialize 
 with 
. Similarly, the following loop computes the
smallest value:
Common Array and Vector Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 6
2/1/2010 2:22 PM

The only difference is that we reverse the comparison.
These algorithms require that the vector (or array) contain at least one element.
To find the height of the tallest bus rider, remember the largest value so far, and update it whenever you see a taller one.
matt matthews/iStockphoto.
6.2.4 Element Separators
When you display the elements of a vector, you usually want to separate them, often with commas or vertical lines, like this:
Note that there is one fewer separator than there are numbers. Print the separator before each element except the initial one
(with index 0):
6.2.5 Counting Matches
A common task is to count how many elements of a vector fulfill a particular criterion. Keep a counter and increment it for
each matching element. For example, this loop counts how many elements are greater than 100.
Common Array and Vector Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 6
2/1/2010 2:22 PM

6.2.6 Collecting Matches
Sometimes, it is not enough to know how many elements of a vector fulfill a criterion, but you actually want to know what
those elements are. This, too, is easily achieved: use a second vector to collect the matches. Here we collect all elements that
are greater than 100.
Note how similar this loop is to the counting loop. The only difference is that we collect the matches instead of incrementing a
counter.
6.2.7 Finding the Position of an Element
You often need to locate the position of an element so that you can replace or remove it. Visit all elements until you have
found a match or you have come to the end of the vector. Here we locate the position of the first element that is larger than
100.
6.2.8 Removing an Element
Suppose you want to remove the element with index 
 from the vector 
. If the elements in the vector are not in any
particular order, that task is easy to accomplish. Simply overwrite the element to be removed with the last element of the
vector, then shrink the size of the vector. (See Figure 6.)
The situation is more complex if the order of the elements matters. Then you must move all elements following the element to
be removed down (to a lower index), and then shrink the size of the vector. (See Figure 7.)
Common Array and Vector Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 6
2/1/2010 2:22 PM

Figure 6   Removing an Element in an Unordered Vector
Figure 7   Removing an Element in an Ordered Vector
6.2.9 Inserting an Element
If the order of the elements does not matter, you can simply insert new elements at the end, using the 
 member
function.
It is more work to insert an element at a particular position in the middle of a vector. First, add a new element at the end of the
vector. Next, move all elements above the insertion location up (to a higher index). Finally, insert the new element
Note the order of the movement: When you remove an element, you first move the next element down to a lower index, then
the one after that, until you finally get to the end of the vector. When you insert an element, you start at the end of the vector,
move that element up to a higher index, then move the one before that, and so on until you finally get to the insertion location
(see Figure 8).
The following program solves the task that we set ourselves at the beginning of this chapter, to mark the largest value in an
input sequence.
ch06/largest.cpp
Common Array and Vector Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 6
2/1/2010 2:22 PM

Program Run
Figure 8   Inserting an Element in an Ordered Vector
Common Array and Vector Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 6
2/1/2010 2:22 PM

Self Check
11.  What is the output of the 
 program when the inputs are 20 10 20 Q 
12.  Write a loop that counts how many elements in a vector are equal to zero. 
13.  How can you combine the tasks of Sections 6.2.5 and 6.2.6, that is, count and collect matches? 
14.  Consider the algorithm to find the largest element in a vector. Why don't we initialize 
 and  with
zero, like this? 
0
0
15.  When printing separators, we skipped the separator before the initial element. Rewrite the loop so that the
separator is printed after each element, except for the last element. 
16.  What is wrong with these statements for printing a vector with separators? 
17.  When finding the position of a match, we used a 
 loop, not a 
 loop. What is wrong with using this
loop instead? 
18.  When inserting an element into a vector, we moved the elements with larger index values, starting at the end
of the vector. Why is it wrong to start at the insertion location, like this: 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Common Array and Vector Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 6
2/1/2010 2:22 PM

Advanced Topic 6.1
ADVANCED TOPIC 6.1 Sorting with the C++ Library
You often want to sort the elements of a vector or array. Advanced Topic 6.2 shows you a sorting algorithm that is
relatively simple but not very efficient. Efficient sorting algorithms are significantly more complex. Fortunately,
the C++ library provides an efficient 
 function. To 
 a vector 
, make this call:
To sort an array a with 
 elements, call
To fully understand the curious syntax of these calls, you will need to know advanced C++ that is beyond the scope
of this book. But don't hesitate to call the sort function whenever you need to sort an array or vector.
To use the sort function, include the 
 header in your program.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 6.1 Sorting with the C++ Library
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:23 PM



In this section, we will explore how to write functions that process vectors and arrays, highlighting the key differences in
working with each.
Vectors can occur as function parameters and return
values.
You can use vectors as function parameters in exactly the same way as any other values. For example, the following function
computes the sum of a vector of floating-point numbers:
This function visits the vector elements, but it does not modify them. If your function modifies the elements, use a reference
parameter. The following function multiplies all values of a vector with a given factor.
Note the
A function can return a vector. Again, vectors are no different from any other values in this regard. Simply build up the result
in the function and return it. In this example, the 
 function returns a vector of squares from 02 up to (n - 1)2:
As you can see, it is easy to use vectors with functions—there are no special rules to keep in mind. You have to be much more
careful when using arrays with functions.
When you pass an array to a function, you also need to pass the size of the array. The function has no other way of querying the
size of the array—there is no 
 member function. Here is the 
 function again, this time with an array parameter:
Vectors and Arrays in Functions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:23 PM

Note the special syntax for array parameters. When writing an array parameter, you place an empty 
 behind the parameter
name. Do not specify the size of the array inside the brackets.
Array parameters are always passed by reference.
Unlike all other parameters, array parameters are always passed by reference. (You will see the reason in Chapter 7.)
Functions can modify array parameters, and those modifications affect the array that was passed into the function. For
example, the following 
 function updates all elements in the array.
No
A function's return type cannot be an array.
Although arrays can be function parameters, they cannot be function return types. If a function computes multiple values, the
caller of the function must provide an array parameter to hold the result.
The following example program reads values from standard input, doubles them, and prints the result. The program uses three
functions:
•  The 
 function returns a vector.
•  The 
 function has a vector as a reference parameter.
•  The 
 function has a vector as a value parameter.
ch06/vecfuns.cpp
Reads a sequence of floating-point numbers.
a vector containing the numbers
Vectors and Arrays in Functions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:23 PM

Multiplies all elements of a vector by a factor.
a vector
the value with which element is multiplied
Prints the elements of a vector, separated by commas.
a vector
Program Run
Vectors and Arrays in Functions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:23 PM

Self Check
19.  Consider this partially completed function that appends the elements of one vector to another. 
Specify whether the parameters should be value or reference parameters.
20.  What happens if you declare a vector parameter as a reference parameter even though the function never
modifies it? For example, 
21.  What happens if you call the array version of the 
 function and you lie about the size? For example, calling
even though data has size 100.
22.  How do you call the vector version of the 
 function to compute the first five squares and store the
result in a vector 
 
23.  How do you call the array version of the 
 function to compute the first five squares and store the
result in an array 
 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Vectors and Arrays in Functions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:23 PM

Advanced Topic 6.3
ADVANCED TOPIC 6.3 Constant Vector References and Array
Parameters
Passing a vector into a function by value is unfortunately somewhat inefficient, because the function must make a
copy of all elements. As explained in Advanced Topic 5.2, the cost of a copy can be avoided by using a constant
reference. Simply write
instead of
This is a useful optimization that greatly increases performance.
Similarly, when a function doesn't modify an array parameter, it is considered good style to add the 
 reserved
word, like this:
In this case, the reason is not efficiency. Arrays are always passed by reference. However, the 
 reserved word
helps the reader of the code, making it clear that the function keeps the array elements unchanged.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 6.3 Constant Vector References and Array Parameters
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:23 PM

How To 6.1
HOW TO 6.1 Working with Vectors and Arrays
When you process a sequence of values, you usually need to use vectors or arrays. (In some very simple situations,
you can process data as you read them in, without storing them.) This How To walks you through the necessary
steps.
Consider this example problem: You are given the quiz scores of a student. You are to compute the final quiz
score, which is the sum of all scores after dropping the lowest one. For example, if the scores are
then the final score is 50.
Step 1  Decompose your task into steps.
You will usually want to break down your task into multiple steps, such as
•  Reading the data into a vector or array.
•  Processing the data in one or more steps.
•  Displaying the results.
When deciding how to process the data, you should be familiar with the array algorithms in Section
6.2. Most processing tasks can be solved by using one or more of these algorithms.
In our sample problem, we will want to read the data. Then we will remove the minimum and
compute the total. For example, if the input is 
, we will remove the
minimum of , yielding 
. The sum of those values is the final score of
.
Thus, we have identified three steps:
Read inputs
Remove the minimum
Calculate the sum
(It is possible to solve this problem using a different sequence of steps—see Exercise P6.3.).
Step 2  Choose between vectors and arrays.
Generally, vectors are more convenient than arrays. You would choose arrays if one of the following
applies:
•  You know in advance how many elements you will collect, and the size will not change.
•  You interact with pre-existing code that uses arrays.
None of these cases applies here, so we will store the scores in a vector.
Step 3  Determine which algorithm(s) you need for each step.
Sometimes, a step corresponds to exactly one of the basic array algorithms. That is the case with
calculating the sum. At other times, you need to combine several algorithms. To remove the
minimum value, you can find the minimum value (Section 6.2.3), find its position (Section 6.2.7),
and remove the element at that position (Section 6.2.8). (There is a more efficient way of removing
the minimum from a Exercise P6.4..)
HOW TO 6.1 Working with Vectors and Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:24 PM

Step 4  Determine functions, parameters, and return values.
Even though it may be possible to put all steps into the 
 function, this is rarely a good idea. The
simplest and best approach is to make each step into a separate function. In our example, we will
implement three functions:
•  
•  
•  
If a function modifies a vector, then you need to pass it by reference. Removing the smallest value
modifies a vector, but computing the sum does not:
If you follow Advanced Topic 6.3 on page 261, you can use the more efficient
When reading data, you have two choices. You can return a vector with the data that you read:
Or you can pass a vector that should be filled:
The first approach is generally considered in better taste and easier to understand, but the second is a
bit more efficient. We will opt for good taste.
If you had used an array instead of a vector, then the first two functions would have been
See Advanced Topic 6.3 for the
optional
Returning an array from a function is not an option, so the 
 function would need to
supply a parameter for holding the values that the user supplied. The function also needs to know the
capacity of that array, and it needs to set the actual number of values read:
You can see once again that arrays are not a comfortable choice for storing a data set whose size is
unknown.
Step 5  Document and implement each function, using helper functions when needed.
We won't show the code for the 
 and 
 functions because you have seen them
already, but we will consider the function 
. A safe strategy is to implement it with three
helper functions, 
, 
, and 
:
Removes the minimum from a vector.
 a vector of size >= 1
The helper functions use the algorithms from Section 6.2
HOW TO 6.1 Working with Vectors and Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:24 PM

Gets the minimum value from a vector.
 a vector of size >= 1
 the smallest element of data
Returns the index of the first element that matches a given element.
 a vector
 the element to match
 the smallest i such that 
,
or -1 if there is no such element
Removes an element from a vector. The order of the elements is not
preserved.
 a vector
 the index of the element to be removed (must be valid)
Most functions that operate on vectors and arrays are a bit intricate, and you have to be careful that
you handle both normal and exceptional situations. What happens with an empty array? An array that
contains a single element? When no match is found? When there are multiple matches? Consider
these boundary conditions and make sure that your functions work correctly.
HOW TO 6.1 Working with Vectors and Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:24 PM

In the 
 function, we require that the vector contain at least one element. Therefore, the
 function will find the smallest element. Since that element is a part of the vector, the
 method will yield a valid position.
What if there are multiple matches? That means that a student had more than one test with a low
score. The 
 function removes only one of the occurrences of that low score, and that is
the desired behavior.
Step 6  Assemble and test the complete program.
Now we are ready to combine the individual functions into a complete program. Before doing this,
consider some test cases and their expected output:
Test Case
Expected
Output
Comment
 8 7 8.5 9.5 7 5
10
50
See Step 1.
8 7 7 9
24
Only one instance of the low score should be
removed.
8
 0
After removing the low score,no score remains.
(no inputs)
Error
That is not a legal input.
This 
 function completes the solution (see 
).
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
HOW TO 6.1 Working with Vectors and Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:24 PM

Worked Example 6.1
WORKED EXAMPLE 6.1 Rolling the Dice
Your task is to analyze whether a six-sided die is fair by counting how often the values 1, 2, …, 6 appear. You are
given a vector of die toss values, and you should fill an array of counters, where 
 is the number of
times the value  was tossed. (Leave 
 unused.)
Step 1  Decompose your task into steps.
Overtly, we are given a task that can be solved in one step, namely to visit the die toss values and
increment the counters. However, to produce a runnable program, we also need to produce a vector
of test values, and we need to display the outcome. Thus, we have three steps:
•  Produce test values.
•  Count the occurrences of each value.
•  Display the results.
Step 2  Choose between vectors and arrays.
In this situation, we are told that the die toss values are stored in a vector. This was a reasonable
choice since each die toss experiment may produce a different number of tosses. We are also told to
use an array of counters. That too is reasonable, since the size of the array is known at compile time.
We need seven counters, the unused 
 and 
 to 
.
Step 3  Determine which algorithm(s) you need for each step.
To produce test values, we could generate random numbers between 1 and 6, but then we wouldn't
know whether we get the correct answer. Instead, let us generate test values for which we know the
answer, and fill the vector as follows:
We now expect the following counts:
We would like to format the output in this way. We haven't seen this exact output format loop in
this chapter, but it is plausible that a simple loop can generate the desired output.
Finally, let us turn to the task of counting the occurrences of each value. Section 6.2.5 shows how to
count the number of 1s, with a loop
WORKED EXAMPLE 6.1 Rolling the Dice
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:24 PM

We could have six loops of this form, but that is not very elegant. After all, when you have a die
value, you know which counter needs to be incremented. It is the counter corresponding to the value
itself. Therefore, the following loop solves our problem.
Step 4  Determine functions, parameters, and return values.
We will provide a function for each step:
•  
•  
•  
The 
 function returns a vector of test values. It has no parameters.
The 
 function receives the die toss values, and it must also receive the array of
counters so that it can update them:
We don't need to supply the size of the counters array because we know it contains seven elements.
But let us pause for a minute. Suppose the researchers changed their mind and wanted to investigate
12-sided dice.
Ryan Ruffatti/iStockphoto.
The same algorithm works, but we need more counters. Let's implement the more general function.
Since the function does not modify the vector of die toss values, the vector is not passed by
reference. The function modifies the 
 array. This is not a problem since arrays are always
passed by reference.
Finally, the 
 function prints the value of the counters. Again, we will want to
support an arbitrary number of die faces, so we will supply that number as a parameter.
Step 5  Document and implement each function, using helper functions when needed.
We start with the 
 function.
Generates a sequence of die toss values for testing.
WORKED EXAMPLE 6.1 Rolling the Dice
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:24 PM

 the vector of die toss values
Here are the 
 and 
 functions. It is a good idea to document clearly
which assumptions underly these functions:
Counts the number of times each value occurs in a sequence of die tosses.
 a vector of die toss values. Each element is >= 1 and <= faces.
 the number of faces of the die
 an array of counters of length faces
is filled with the count of elements of values that equal 
 is
not used.
Prints a table of die value counters.
 the number of faces of the die.
 an array of counters of length faces
 is not printed.
Step 6  Assemble and test the complete program.
The 
 function allocates the array of counters, generates the test values, fills the counters, and
prints them.
WORKED EXAMPLE 6.1 Rolling the Dice
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:24 PM

Here is the complete program, 
:
Generates a sequence of die toss values for testing.
 the vector of die toss values
Counts the number of times each value occurs in a sequence of die tosses.
 a vector of die toss values. Each element is >= 1 and <= faces.
 the number of faces of the die
 an array of counters of length faces + 1. counters[j]
is filled with the count of elements of values that equal j. counters[0] is
not used.
Prints a table of die value counters.
 the number of faces of the die
 an array of counters of length faces + 1.
counters[0] is not printed.
WORKED EXAMPLE 6.1 Rolling the Dice
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:24 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
WORKED EXAMPLE 6.1 Rolling the Dice
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:24 PM

It often happens that you want to store collections of values that have a two-dimensional layout. Such data sets commonly
occur in financial and scientific applications. An arrangement consisting of rows and columns of values is called a
two-dimensional array, or a matrix.
Chris Burt/iStockphoto.
Let's explore how to store the example data shown in Figure 9: the medal counts of the figure skating competitions at the 2006
Winter Olympics.
Figure 9   Figure Skating Medal Counts
Gian Mattia D'Alberto/LaPresse/Zuma Press.
6.4.1 Defining Two-Dimensional Arrays
C++ uses an array with two subscripts to store a two-dimensional array. For example, here is the definition of an array with 7
rows and 3 columns and suitable for storing our medal count data:
Two-Dimensional Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 7
2/1/2010 2:24 PM

You can initialize the array by grouping each row, as follows:
Just as with one-dimensional arrays, you cannot change the size of a two-dimensional array once it has been defined.
Use a two-dimensional array to store tabular data.
6.4.2 Accessing Elements
To access a particular element in the two-dimensional array, you need to specify two subscripts in separate brackets to select
the row and column, respectively (see Syntax 6.3 and Figure 10):
To access all values in a two-dimensional array, you use two nested loops.
Individual elements in a two-dimensional array are
accessed by using two subscripts, 
.
Figure 10   Accessing an Element in a Two-Dimensional Array
For example, the following loop prints all elements of 
.
Process the ith row
Process the jth column in the ith row
Start a new line at the end of the row
Two-Dimensional Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 7
2/1/2010 2:24 PM

6.4.3 Computing Row and Column Totals
A common task is to compute row or column totals. In our example, the row totals give us the total number of medals won by
a particular country.
Finding the right index values is a bit tricky, and it is a good idea to make a quick sketch. To compute the total of row , we
need to visit the following elements:
As you can see, we need to compute the sum of 
, where  ranges from  to 
. The following loop
computes the total:
Computing column totals is similar. Form the sum of 
, where  ranges from  to 
.
6.4.4 Two-Dimensional Array Parameters
When passing a two-dimensional array to a function, you must specify the number of columns as a constant with the
parameter type. For example, this function computes the total of a given row.
Two-Dimensional Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 7
2/1/2010 2:24 PM

This function can compute row totals of a two-dimensional array with an arbitrary number of rows, but the array must have 3
columns. You have to write a different function if you want to compute row totals of a two-dimensional array with 4 columns.
A two-dimensional array parameter must have a fixed
number of columns.
To understand this limitation, you need to know how the array elements are stored in memory. Although the array appears to be
two-dimensional, the elements are still stored as a linear sequence. Figure 11 shows how the 
 array is stored, row by
row.
Figure 11   A Two-Dimensional Array Is Stored as a Sequence of Rows
For example, to reach
the program must first skip past rows 0, 1, and 2 and then locate offset 1 in row 3. The offset from the start of the array is
3 × number of columns + 1
Now consider the 
 function. The compiler generates code to find the element
by computing the offset
The compiler uses the value that you supplied in the second pair of brackets when declaring the parameter:
Note that the first pair of brackets should be empty, just as with one-dimensional arrays.
The 
 function did not need to know the number of rows of the array. If the number of rows is required, pass it as a
variable, as in this example:
Two-Dimensional Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 7
2/1/2010 2:24 PM

Working with two-dimensional arrays is illustrated in the following program. The program prints out the medal counts and the
row totals.
ch06/medals.cpp
Computes the total of a row in a table.
a table with 3 columns
the row that needs to be totaled
the sum of all elements in the given row
Two-Dimensional Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 7
2/1/2010 2:24 PM

Print countries, counts, and row totals
Process the ith row
Program Run
Self Check
24.  What results do you get if you total the columns in our sample data? 
25.  Consider an 8 × 8 array for a board game: 
Using two nested loops, initialize the board so that zeroes and ones alternate, as on a checkerboard:
Hint: Check whether 
 is even.
26.  Define a two-dimensional array for representing a tic-tac-toe board. The board has three rows and columns
and contains strings 
, 
, and 
. 
27.  Write an assignment statement to place an 
 in the upper right corner of the tic-tac-toe board. 
28.  Which elements are on the diagonal joining the upper-left and the lower-right corners of the tic-tac-toe board?
Two-Dimensional Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 7
2/1/2010 2:24 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Two-Dimensional Arrays
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 7
2/1/2010 2:24 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 6.3 Two-Dimensional Array Definition
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:24 PM

Common Error 6.3
COMMON ERROR 6.3 Omitting the Column Size of a Two-Dimensional
Array Parameter
When passing a one-dimensional array to a function, you specify the size of the array as a separate parameter:
This function can print arrays of any size. However, for two-dimensional arrays you cannot simply pass the
numbers of rows and columns as parameters:
NO!
The function must know at compile time how many columns the two-dimensional array has. You must specify the
number of columns in the array parameter. This number must be a constant:
OK
This function can print tables with any number of rows, but the column size is fixed.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 6.3 Omitting the Column Size of a Two-Dimensional ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:24 PM

Worked Example 6.2
WORKED EXAMPLE 6.2 A World Population Table
Consider the following population data.
Population Per Continent (in millions)
Year
1750
1800
1850
1900
1950
2000
2050
Africa
106
107
111
133
221
767
1766
Asia
502
635
809
947
1402
3634
5268
Australia
2
2
2
6
13
30
46
Europe
163
203
276
408
547
729
628
North America
2
7
26
82
172
307
392
South America
16
24
38
74
167
511
809
You are to print the data in tabular format and add column totals that show the total world populations in the given
years.
First, we break down the task into steps:
•  Initialize the table data.
•  Print the table.
•  Compute and print the column totals.
Initialize the table as a sequence of rows:
To print the row headers, we also need a one-dimensional array of the continent names. Note that it has the same
number of rows as our table.
WORKED EXAMPLE 6.2 A World Population Table
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:25 PM

To print a row, we first print the continent name, then all columns. This is achieved with two nested loops. The
outer loop prints each row:
Print data
Print the ith row
Start a new line at the end of the row
To print a row, we first print the row header, then all columns:
To print the column sums, we use a helper function, as described in Section 6.4.4. We call that function once for
each column.
Here is the complete program, 
.
Computes the total of a column in a table.
 a table with 7 columns
 the number of rows of the table
 the column that needs to be totaled
 the sum of all elements in the given column
WORKED EXAMPLE 6.2 A World Population Table
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:25 PM

Print data
Print the ith row
Start a new line at the end of the row
Print column totals
Program Run
WORKED EXAMPLE 6.2 A World Population Table
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:25 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
WORKED EXAMPLE 6.2 A World Population Table
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:25 PM

Random Fact 6.2
RANDOM FACT 6.2 International Alphabets
The English alphabet is pretty simple: upper- and lowercase a to z. Other European languages have accent marks and
special characters. For example, German has three so-called umlaut characters, ä, ö, ü, and a double-s character β.
These are not optional frills; you couldn't write a page of German text without using these characters a few times.
German computer keyboards have keys for these characters (see Figure 12).
Figure 12   The German Keyboard
This poses a problem for computer users and designers. The American standard character encoding (called ASCII, for
American Standard Code for Information Interchange) specifies 128 codes: 52 upper- and lowercase characters, 10
digits, 32 typographical symbols, and 34 control characters (such as space, newline, and 32 others for controlling
printers and other devices). The umlaut and double-s are not among them. Some German data processing systems
replace seldom-used ASCII characters with German letters: [\] {|}~ are replaced with Ä Ö Ü ä ö ü β. While most
people can live without these characters, C++ programmers definitely cannot. Other encoding schemes take
advantage of the fact that one byte can encode 256 different characters, of which only 128 are standardized by ASCII.
Unfortunately, there are multiple incompatible standards for such encodings, resulting in a certain amount of
aggravation among European computer users.
Many countries don't use the Roman script at all. Russian, Greek, Hebrew, Arabic, and Thai letters, to name just a
few, have completely different shapes (see Figure 13). To complicate matters, Hebrew and Arabic are typed from
right to left. Each of these alphabets has between 30 and 100 letters, and the countries using them have established
encoding standards for them.
RANDOM FACT 6.2 International Alphabets
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:25 PM

Figure 13   The Thai Script
The situation is much more dramatic in languages that use the Chinese script: the Chinese dialects, Japanese, and
Korean. The Chinese script is not alphabetic but ideographic (see Figure 14). A character represents an idea or
thing. Most words are made up of one, two, or three of these ideographic characters. Over 50,000 ideographs are
known, of which about 20,000 are in active use. Therefore, two bytes are needed to encode them. China, Taiwan,
Japan, and Korea have incompatible encoding standards for them. (Japanese and Korean writing uses a mixture of
native syllabic and Chinese ideographic characters.)
Figure 14   The Chinese Script
The inconsistencies among character encodings have been a major nuisance for international electronic
communication and for software manufacturers vying for a global market. Starting in 1988, a consortium of
hardware and software manufacturers developed a uniform 21-bit encoding scheme called unicode that is capable of
encoding text in essentially all written languages of the world. About 100,000 characters have been given codes,
including more than 70,000 Chinese, Japanese, and Korean ideographs. There are even plans to add codes for extinct
languages, such as Egyptian hieroglyphs.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 6.2 International Alphabets
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:25 PM

1.  Use an array or vector to collect a sequence of values of the same type.
Max Dimyadi/iStockphoto.
2.  Individual elements in an array 
 are accessed by an integer index , using the notation 
.
3.  An array element can be used like any variable.
4.  An array index must be at least zero and less than the size of the array.
5.  A bounds error, which occurs if you supply an invalid array index, can corrupt data or cause your program to
terminate.
6.  A vector stores a sequence of values whose size can change.
7.  Use the 
 member function to add more elements to a vector. Use 
 to reduce the size.
8.  Use the 
 function to obtain the current size of a vector.
9.  With a partially-filled array, keep a companion variable for the current size.
10.  Vectors can occur as function parameters and return values.
matt matthews/iStockphoto.
11.  Array parameters are always passed by reference.
12.  A function's return type cannot be an array.
13.  Use a two-dimensional array to store tabular data.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:25 PM

Chris Burt/iStockphoto.
14.  Individual elements in a two-dimensional array are accessed by using two subscripts, 
.
15.  A two-dimensional array parameter must have a fixed number of columns.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:25 PM

Exercise R6.1.    
Write code that fills a vector 
 with each set of values below
(a)  1 2 3 4 5 6 7 8 9 10
(b)  0 2 4 6 8 10 12 14 16 18 20
(c)  1 4 9 16 25 36 49 64 81 100
(d)  0 0 0 0 0 0 0 0 0 0
(e)  1 4 9 16 9 7 4 9 11
(f)  0 1 0 1 0 1 0 1 0 1
(g)  0 1 2 3 4 0 1 2 3 4
Exercise R6.2.    
Consider the following array:
What is the value of 
 after the following loops complete?
(a)  
(b)  
(c)  
(d)  
(e)  
(f)  
(g)  
(h)  
Exercise R6.3.    
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:25 PM

Consider the following array:
What are the contents of the array  after the following loops complete?
(a)  
(b)  
(c)  
(d)  
(e)  
(f)  
(g)  
(h)  
Exercise R6.4.    
Write a loop that fills a vector 
 with ten random numbers between 1 and 100. Write code for two nested loops that fill
 with ten different random numbers between 1 and 100.
Exercise R6.5.    
Write C++ code for a loop that simultaneously computes both the maximum and minimum of a vector.
Exercise R6.6.    
What is wrong with the following loop?
Explain two ways of fixing the error.
Exercise R6.7.    
What is an index of a vector or an array? What are the legal index values? What is a bounds error?
Exercise R6.8.    
Write a program that contains a bounds error. Run the program. What happens on your computer?
Exercise R6.9.    
Write a loop that reads ten numbers and a second loop that displays them in the opposite order from which they were
entered.
Exercise R6.10.    
Trace the flow of the loop in Section 6.2.4 with the given example. Show two columns, one with the value of  and one
with the output.
Exercise R6.11.    
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:25 PM

Trace the flow of the loop in Section 6.2.6, where 
contains the values 110 90 100 120 80. Show two columns, for 
and 
.
Exercise R6.12.    
Trace the flow of the loop in Section 6.2.7, where 
 contains the values 80 90 100 120 110. Show two columns, for
 and 
. Repeat the trace when 
 contains 80 90 100 70.
Exercise R6.13.    
Trace both mechanisms for removing an element described in Section 6.2.8. Use a vector 
 with values 110 90 100
120 80, and remove the element at index 2.
Exercise R6.14.    
From the examples in this chapter, name
(a)  A function that has a vector as a value parameter.
(b)  A function that has a vector as a reference parameter.
(c)  A function that has a vector as a return value.
Exercise R6.15.    
A function that has a vector as a reference parameter can change the vector in two ways. It can change the contents of
individual vector elements, or it can rearrange the elements. From the examples in this chapter, name two functions that
change a vector in each of the two ways just described.
Exercise R6.16.    
Give pseudocode for a function that rotates the elements of a vector by one position, moving the initial element to the end
of the vector, like this:
Exercise R6.17.    
Give pseudocode for a function that removes all negative values from a vector, preserving the order of the remaining
elements.
Exercise R6.18.    
Suppose 
 is a sorted vector of integers. Give pseudocode that describes how a new value can be inserted in its proper
position so that the resulting vector stays sorted.
Exercise R6.19.    
A run is a sequence of adjacent repeated values. Give pseudocode for computing the length of the longest run in a vector.
For example, the longest run in the vector with elements
has length 4.
Exercise R6.20.    
How do you perform the following tasks with vectors in C++?
(a)  Test that two vectors contain the same elements in the same order.
(b)  Copy one vector to another.
(c)  Fill a vector with zeroes, overwriting all elements in it.
(d)  Remove all elements from a vector.
Exercise R6.21.    
True or false?
(a)  All elements of a vector are of the same type.
(b)  Vector subscripts must be integers.
(c)  Vectors cannot contain strings as elements.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:25 PM

(d)  Vectors cannot use strings as subscripts.
(e)  Two-dimensional arrays always have the same numbers of rows and columns.
(f)  Elements of different columns in a two-dimensional array can have different types.
(g)  All vector parameters are reference parameters.
(h)  A function cannot return a two-dimensional array.
(i)  A function cannot change the dimensions of a two-dimensional array that is passed as a parameter.
(j)  A function cannot change the length of a vector that is passed by reference.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:25 PM

Exercise P6.1.    
Write a program that initializes an array with ten random integers and then prints four lines of output, containing
•  Every element at an even index.
•  Every even element.
•  All elements in reverse order.
•  Only the first and last element.
Exercise P6.2.    
Modify the 
 program to mark both the smallest and the largest element.
Exercise P6.3.    
Reimplement How To 6.1 on page 262 without removing the minimum from the vector of scores. Instead, compute the
final score as the difference of the sum and the minimum of the scores.
Exercise P6.4.    
Write a function 
 that removes the minimum value from a vector without calling other methods. Hint:
You can accomplish this task with two loops if you keep track of the index of the smallest value in the first loop.
Exercise P6.5.    
Write a function that computes the alternating sum of all elements in a vector. For example, if 
 is
called with a vector containing
then it computes
Exercise P6.6.    
Write a function 
 that reverses the sequence of elements in a vector. For example, if 
 is called with a
vector containing
then the vector is changed to
Exercise P6.7.    
Write a function
that appends one vector after another. For example, if  is
and  is
then 
 returns the vector
Exercise P6.8.    
Write a function
that merges two vectors, alternating elements from both vectors. If one vector is shorter than the other, then alternate as
long as you can and then append the remaining elements from the longer vector. For example, if  is
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 6
2/1/2010 2:26 PM

and  is
then 
 returns the vector
Exercise P6.9.    
Write a function
that merges two sorted vectors, producing a new sorted vector. Keep an index into each vector, indicating how much of it
has been processed already. Each time, append the smallest unprocessed element from either vector, then advance the index.
For example, if  is
and  is
then 
 returns the vector
Exercise P6.10.    
Write a function
that checks whether two vectors have the same elements in the same order.
Exercise P6.11.    
Write a function
that checks whether two vectors have the same elements in some order, ignoring duplicates. For example, the two vectors
and
would be considered identical. You will probably need one or more helper functions.
Exercise P6.12.    
Write a predicate function
that checks whether two vectors have the same elements in some order, with the same multiplicities. For example,
and
would be considered identical, but
and
would not. You will probably need one or more helper functions.
Exercise P6.13.    
Write a function that removes duplicates from a vector. For example, if 
 is called with a vector
containing
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 6
2/1/2010 2:26 PM

then the vector is changed to
Exercise P6.14.    
A run is a sequence of adjacent repeated values. Write a program that generates a sequence of 20 random die tosses and
that prints the die values, marking the runs by including them in parentheses, like this:
Use the following pseudocode:
Set a boolean variable in_run to false
For each valid index i in the vector
{
   If in_run
   {
       If values[i] is different from the preceding value
       {
           Print )
            in_run = false
       }
   }
   Else
   {
      If values[i] is the same as the following value
      {
          Print (
          in_run = true
      }
   }
   Print values[i]
}
If in_run, print )
Exercise P6.15.    
Write a program that generates a sequence of 20 random die tosses and that prints the die values, marking only the longest
run, like this:
If there is more than one run of maximum length, mark the first one.
Exercise P6.16.    
Write a program that generates a sequence of 20 random values between 0 and 99, prints the sequence, sorts it, and prints
the sorted sequence. Use the 
 function from the standard C++ library.
Exercise P6.17.    
Write a program that produces ten random permutations of the numbers 1 to 10. To generate a random permutation, you
need to fill a vector with the numbers 1 to 10 so that no two entries of the vector have the same contents. You could do it
by brute force, by generating random values until you have a value that is not yet in the vector. But that is inefficient.
Instead, follow this algorithm.
Make a second vector and fill it with the numbers 1 to 10
Repeat 10 times
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 6
2/1/2010 2:26 PM

{
   Pick a random element from the second vector
   Remove it and append it to the permutation vector
}
Exercise P6.18.    
It is a well-researched fact that men in a restroom generally prefer to maximize their distance from already occupied stalls,
by occupying the middle of the longest sequence of unoccupied places.
For example, consider the situation where all ten stalls are empty.
The first visitor will occupy a middle position:
The next visitor will be in the middle of the empty area at the right.
Given an array of 
 values, where 
 indicates an occupied stall, find the position for the next visitor. Your
computation should be placed in a function
Exercise P6.19.    
Magic squares. An n × n matrix that is filled with the numbers 1, 2, 3, …, n2 is a magic square if the sum of the elements
in each row, in each column, and in the two diagonals is the same value.
Write a program that reads in 16 values from the keyboard and tests whether they form a magic square when put into a
4 × 4 array. You need to test two features:
1.  Does each of the numbers 1, 2, …, 16 occur in the user input?
2.  When the numbers are put into a square, are the sums of the rows, columns, and diagonals equal to each other?
Exercise P6.20.    
Implement the following algorithm to construct magic n × n squares; it works only if n is odd.
Set row = n - 1, column = n / 2
For k = 1 . . . n
{
    Place k at [row][column]
    Increment row and column
    If the row or column is n, replace it with 0
    If the element at [row][column] has already been filled
        or you are in the lower right corner
    {
        Decrement row
    }
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 6
2/1/2010 2:26 PM

}
Here is the 5 × 5 square that you get if you follow this method:
Write a program whose input is the number n and whose output is the magic square of order n if n is odd.
Exercise P6.21.    
Write a function
that displays a bar chart of the values in 
, using asterisks, like this:
You may assume that all values in 
 are positive. First figure out the maximum value in 
. That value's bar should
be drawn with 40 asterisks. Shorter bars should use proportionally fewer asterisks.
Exercise P6.22.    
Improve the 
 function of Exercise P6.21. to work correctly when 
 contains negative values.
Exercise P6.23.    
Improve the 
 function of Exercise P6.21. by adding an array of captions for each bar. The output should look
like this:
Exercise P6.24.    
A theater seating chart is implemented as a two-dimensional array of ticket prices, like this:
Write a program that prompts users to pick either a seat or a price. Mark sold seats by changing the price to 0. When a user
specifies a seat, make sure it is available. When a user specifies a price, find any seat with that price.
Exercise P6.25.    
Write a program that plays tic-tac-toe. The tic-tac-toe game is played on a 3 × 3 grid as in
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 6
2/1/2010 2:26 PM

The game is played by two players, who take turns. The first player marks moves with a circle, the second with a cross. The
player who has formed a horizontal, vertical, or diagonal sequence of three marks wins. Your program should draw the
game board, ask the user for the coordinates of the next mark, change the players after every successful move, and
pronounce the winner.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 6
2/1/2010 2:26 PM

1.  
2.  
3.  
4.  
5.  
6.  
7.  
8.  
or
9.  
10.  Since you know the size of the array at compile time, there is no disadvantage to using an array, and it is easier to
initialize:
11.  
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:26 PM

12.  
13.  Simply collect the matches. The count is obtained as 
.
14.  If all elements of 
 are negative, then the result is incorrectly computed as 0.
15.  
Now you know why we set up the loop the other way.
16.  If the vector has no elements, then a random value is printed.
17.  If there is a match, then 
 is incremented before the loop exits.
18.  This loop sets all elements to 
.
19.  
 must be a reference parameter, 
 should be a value parameter.
20.  The function will compile and run correctly. However, programmers who look at the definition will scratch their heads.
21.  The 
 function will add up all the numbers in the 
 array and the next 900 numbers, yielding a random result.
(Actually, there is the chance that the program doesn't have the right to access all those numbers, in which case the
operating system will terminate it.)
22.  
23.  
24.  You get the total number of gold, silver, and bronze medals in the competition. In our example, there are four of each.
25.  
26.  
27.  
28.  
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:26 PM

Worked Example 6.2
•
A World Population Table
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
A World Population Table
Consider the following population data. 
You are to print the data in tabular format and add column totals that show the total
world populations in the given years.
First, we break down the task into steps:
• Initialize the table data.
• Print the table.
• Compute and print the column totals.
Initialize the table as a sequence of rows:
int data[ROWS][COLUMNS] = 
   { 
      { 106, 107, 111, 133, 221, 767, 1766 },
      { 502, 635, 809, 947, 1402, 3634, 5268 }, 
      { 2, 2, 2, 6, 13, 30, 46 }, 
      { 163, 203, 276, 408, 547, 729, 628 }, 
      { 2, 7, 26, 82, 172, 307, 392 }, 
      { 16, 24, 38, 74, 167, 511, 809 }
   }; 
To print the row headers, we also need a one-dimensional array of the continent names.
Note that it has the same number of rows as our table.
string continents[ROWS] = 
   { 
      "Africa", 
      "Asia", 
WORKED EXAMPLE 6.2
Population Per Continent (in millions)
Year
1750
1800
1850
1900
1950
2000
2050
Africa
106
107
111
133
221
767
1766
Asia
502
635
809
947
1402
3634
5268
Australia
2
2
2
6
13
30
46
Europe
163
203
276
408
547
729
628
North America
2
7
26
82
172
307
392
South America
16
24
38
74
167
511
809

2
C++ for Everyone  •  CHAPTER 6
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
      "Australia",
      "Europe", 
      "North America", 
      "South America" 
   };
To print a row, we ﬁrst print the continent name, then all columns. This is achieved with two
nested loops. The outer loop prints each row:
// Print data
for (int i = 0; i < ROWS; i++)
{      
   // Print the ith row
   ...
   cout << endl; // Start a new line at the end of the row
}
To print a row, we ﬁrst print the row header, then all columns:
cout << setw(20) << continents[i];
for (int j = 0; j < COLUMNS; j++)
{
   cout << setw(5) << data[i][j];
}
To print the column sums, we use a helper function, as described in Section 6.4.4. We call that
function once for each column.
for (int j = 0; j < COLUMNS; j++) 
{
   cout << setw(5) << column_total(data, ROWS, j);
}
Here is the complete program, ch06/worldpop.cpp.
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;
const int ROWS = 6;
const int COLUMNS = 7;
/**
   Computes the total of a column in a table.
   @param table a table with 7 columns
   @param rows the number of rows of the table
   @param column the column that needs to be totaled
   @return the sum of all elements in the given column
*/
int column_total(int table[][COLUMNS], int rows, int column)
{
   int total = 0; 
   for (int i = 0; i < rows; i++)
   {

Worked Example 6.2
•
A World Population Table
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
      total = total + table[i][column];
   }
   return total;
}
int main()
{
   int data[ROWS][COLUMNS] = 
   { 
      { 106, 107, 111, 133, 221, 767, 1766 },
      { 502, 635, 809, 947, 1402, 3634, 5268 }, 
      { 2, 2, 2, 6, 13, 30, 46 }, 
      { 163, 203, 276, 408, 547, 729, 628 },
      { 2, 7, 26, 82, 172, 307, 392 },
      { 16, 24, 38, 74, 167, 511, 809 }
   };
   string continents[ROWS] = 
      { 
         "Africa", 
         "Asia", 
         "Australia",
         "Europe", 
         "North America", 
         "South America" 
      };
   cout << "                Year 1750 1800 1850 1900 1950 2000 2050"
      << endl;
   // Print data
   for (int i = 0; i < ROWS; i++)
   {      
      // Print the ith row
      cout << setw(20) << continents[i];
      for (int j = 0; j < COLUMNS; j++)
      {
         cout << setw(5) << data[i][j];
      }
      cout << endl; // Start a new line at the end of the row
   }
   // Print column totals
   cout << "               World";
   for (int j = 0; j < COLUMNS; j++) 
   {
      cout << setw(5) << column_total(data, ROWS, j);
   }
   cout << endl;
   return 0;
}

4
C++ for Everyone  •  CHAPTER 6
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Program Run
                Year 1750 1800 1850 1900 1950 2000 2050
              Africa  106  107  111  133  221  767 1766
                Asia  502  635  809  947 1402 3634 5268
           Australia    2    2    2    6   13   30   46
              Europe  163  203  276  408  547  729  628
       North America    2    7   26   82  172  307  392
       South America   16   24   38   74  167  511  809
               World  791  978 1262 1650 2522 5978 8909

Chapter
   
    
    
Chapter Goals
•  To learn how to declare, initialize, and use pointers
•  To become familiar with dynamic memory allocation and deallocation
•  To understand the relationship between arrays and pointers
•  To be able to convert between string objects and character pointers
A variable contains a value, but a pointer specifies where a value is located. In C++, pointers are important for
several reasons. Pointers can refer to values that are allocated on demand. Pointers allow sharing of values.
Furthermore, as you will see in Chapter 10, pointers are necessary for implementing polymorphism, an
important concept in object-oriented programming.
In C++, there is a deep relationship between pointers and arrays. You will see in this chapter how this relationship
explains a number of special properties and limitations of arrays.
Chapter Goals To learn how ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:27 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To learn how ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:27 PM

Pointers allow you to write code that accesses different variables in a uniform way. Consider a person who wants a program
for making bank deposits and withdrawals, but who may not always use the same bank account. By using a pointer, it is
possible to switch to a different account without modifying the code for deposits and withdrawals.
Let's start with a variable for storing an account balance:
If Harry anticipates that he may not always use that account, he can use a pointer to access it or some other account. A pointer
tells you where a value is located, not what the value is.
A pointer denotes the location of a variable in memory.
Harry declares a pointer variable and initializes it with the address of an account:
The type 
*, or “pointer to 
”, denotes the location of a 
 variable. The  operator yields the location (or
address) of a variable. Taking the address of a 
 variable yields a value of type 
*.
The type T* denotes a pointer to a variable of type T.
Like a pointer that points to different locations on a blackboard, a C++ pointer can point to different memory locations.
Alexey Chuvarkov/iStockphoto.
Thinking about pointers can be rather abstract, but you can use a simple trick to make it more tangible. Every variable in a
computer program is located in a specific memory location. You don't know where each variable is stored, but you can pretend
you do. Let's pretend that we know that 
 is stored in location 20300. (That is just a made-up value.) As
shown in Figure 1, the value of 
 is 0, but the value of 
 is 20300. The value of
 is also 20300. In our diagrams, we will draw an arrow from a pointer to the location, but of course the
computer doesn't store arrows, just numbers.
Accessing Variables Through Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 6
2/1/2010 2:27 PM

Figure 1   A Pointer Variable
The  operator yields the location of a variable.
By using a pointer, Harry can switch to a different account at any time. To access a different account, simply change the pointer
value (see Figure 2):
Figure 2   Changing a Pointer
When you have a pointer to a variable, you will want to access the value to which it points. In C++ the * operator is used to
indicate the location associated with a pointer. (When used with pointers, the * operator has no relationship with
multiplication.) For example, this statement makes an initial deposit into the account:
In other words, you can use *
 in exactly the same way as 
 or 
. Which
account is used depends on the value of the pointer. When the program executes this statement, it fetches the address stored in
. It then uses the variable at that address, as shown in Figure 3.
Accessing Variables Through Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 6
2/1/2010 2:27 PM

Figure 3   Executing the Assignment *
 = 1000
The * operator locates the value to which a pointer
points.
An expression such as *
 can be on the left or the right of an assignment. When it occurs on the left, then a
value is stored in the location to which the pointer refers. When it occurs on the right, then the value is fetched from the
location. For example, this statement prints the account balance.
You can have *
 on both sides of an assignment. The following statement withdraws $100.
When a pointer variable is first defined, it contains a random address. Using that random address is an error. In practice, your
program will likely crash or mysteriously misbehave if you use an uninitialized pointer:
Forgot to initialize
NO!
 contains an unpredictable value
It is an error to use an uninitialized pointer.
There is a special value, 
, that you can use to indicate a pointer that doesn't point anywhere. If you define a pointer variable
and are not ready to initialize it quite yet, it is a good idea to set it to 
.
Will set later
Accessing Variables Through Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 6
2/1/2010 2:27 PM

You can later test whether the pointer is still 
. If it is, don't use it.
OK
Trying to access data through a 
 pointer is still illegal, and it will cause your program to terminate.
The 
 pointer does not point to any object.
Table 1 contains additional pointer examples.
Table 1    Pointer Syntax Examples
Assume the following declarations:
Assumed to be at address 20300
Assumed to be at address 20304
Expression
Value
Comment
  
20300
The address of .
  *
10
The value stored at that address.
  
20304
The address of .
  
;
 
Set  to the address of .
  
20
The value stored at the changed address.
  
;
 
Stores 20 into .
 
;
Error
 is an int value;  is an 
* pointer. The types are not
compatible.
 
Error
You can only take the address of a variable.
  
The address of , perhaps
20308
This is the location of a pointer variable, not the location of an
integer.
The following program demonstrates the behavior of pointers. We execute the same withdrawal statement twice, but with
different values for 
. Each time, a different account is modified.
ch07/accounts.cpp
Initial deposit
Withdraw $100
Print balance
Change the pointer value
Accessing Variables Through Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 6
2/1/2010 2:27 PM

The same statements affect a different account
Withdraw $100
Print balance
Program Run
Self Check
1.  Consider this set of statements. What is printed? 
2.  Consider this set of statements. What is printed? 
3.  Consider this set of statements. What is printed? 
4.  Consider this set of statements. What is printed? 
5.  Consider this set of statements. What is printed? 
Accessing Variables Through Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 6
2/1/2010 2:27 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Accessing Variables Through Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 6
2/1/2010 2:27 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 7.1 Pointer Syntax
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:27 PM

Common Error 7.1
COMMON ERROR 7.1 Confusing Pointers with the Data to Which They
Point
A pointer is a memory address—a number that tells where a value is located in memory. It is a common error to
confuse the pointer with the variable to which it points:
ERROR
The assignment statement does not set the joint account balance to 1000. Instead, it sets the pointer to point to
memory address 1000. The pointer 
 only describes where the joint account variable is, and it
almost certainly is not located at address 1000.
Most compilers will report an error for this assignment.
To actually access the variable, use *
:
OK
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 7.1 Confusing Pointers with the Data to Which They ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:27 PM

Quality Tip 7.1
QUALITY TIP 7.1 Defining Two Pointers on the Same Line
It is legal in C++ to define multiple variables together, like this:
This style is confusing when used with pointers:
The * associates only with the first variable. That is,  is a 
* pointer, and  is a 
 value. To avoid
any confusion, it is best to define each pointer variable separately:
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 7.1 Defining Two Pointers on the Same Line
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:28 PM

Pointers are particularly useful for understanding the peculiarities of arrays. Consider this declaration of an array:
The value of an array variable is a pointer to the
starting element of the array.
As you know, 
 denotes an array element. You can also use the variable name a without brackets. The name of the array
denotes a pointer to the starting element (see Figure 4). You can capture that pointer in a variable.
Now
points to
If you prefer, you can use a as a pointer: The statement
has the same effect as the statement
Figure 4   Pointers into an Array
Moreover, pointers into arrays support pointer arithmetic. You can add an integer offset to the pointer to point at another array
location. For example,
is a pointer to the array element with index 3. The expression
has exactly the same meaning as 
. In fact, for any integer , it is true that
Pointer arithmetic means adding an integer offset to an
array pointer, yielding a pointer that skips past the
Arrays and Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:28 PM

given number of elements.
This relationship is called the array/pointer duality law.
The array/pointer duality law states that 
 is
identical to *(
), where a is a pointer into an
array and  is an integer offset.
This law explains why all C++ arrays start with an index of zero. The pointer  (or 
) points to the starting element of
the array. That element must therefore be 
.
To better understand pointer arithmetic, let's again pretend that we know actual memory addresses. Suppose the array  starts at
address 20300. The array contains ten values of type 
. A 
 value occupies 8 bytes of memory. Therefore, the
array occupies 80 bytes, from 20300 to 20379. The starting value is located at address 20300, the next one at address 20308,
and so on (see Figure 4). Table 2 on page 297 shows pointer arithmetic and the array/pointer duality using this example.
Table 2    Arrays and Pointers
Expression
Value
Comment
20300
The starting address of the array, here assumed to be 20300.
0
The value stored at that address. (The array contains values 0, 1, 4, 9, ….)
20308
The address of the next 
 value in the array. A 
 occupies 8 bytes.
20324
The address of the element with index 3, obtained by skipping past 3 × 8 bytes.
9
The value stored at address 20324.
9
The same as *(
) by array/pointer duality.
3
The sum of *  and 3. Since there are no parentheses, the * refers only to .
20324
The address of the element with index 3, the same as 
.
Once you understand the connection between arrays and pointers, it becomes clear why array parameters are different from
other parameter types. As an example, consider this function that computes the sum of all values in an array:
Here is a call to the function (see Figure 5):
Initialize data
Arrays and Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:28 PM

Figure 5   Passing an Array to a Function
The value 
 is passed to the 
 function. It is actually a pointer of type 
*, pointing to the starting element of the
array. One would therefore expect that the function is declared as
When passing an array to a function, only the starting
address is passed.
However, if you look closely at the function definition, you will see that the parameter is declared as an array with empty
bounds:
As viewed by the C++ compiler, these parameter declarations are completely equivalent. The [] notation is “syntactic sugar”
for declaring a pointer. (Computer scientists use the term “syntactic sugar” to describe a notation that is easy to read for
humans and that masks a complex implementation detail.) The array notation gives human readers the illusion that an entire
array is passed to the function, but in fact the function receives only the starting address for the array.
Now consider this statement in the body of the function:
The C++ compiler considers a to be a pointer, not an array. The expression 
 is syntactic sugar for *(
). That
expression denotes the storage location that is  elements away from the address stored in the variable a, as shown in Figure 5.
You can now understand why it is always necessary to pass the size of the array. The function receives a single memory
address, which tells it where the array starts. That memory address enables the function to locate the values in the array. But the
function also needs to know where to stop.
Self Check
Arrays and Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:28 PM

For problems 6–9, draw the array and pointer as in Figure 4. Assume a starting address (20300 will work fine),
and assume that each 
 value occupies 4 bytes.
6.  What is the contents of the array a after these statements? 
7.  What is the contents of the array a after these statements? 
8.  What is the contents of the array a after these statements? 
9.  What do the following statements print? 
10.  In Chapter 6, we defined a function 
Declare the parameter using pointer notation.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Arrays and Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:28 PM

Advanced Topic 7.1
ADVANCED TOPIC 7.1 Using a Pointer to Step Through an Array
Now that you know that the first parameter of the 
 function is a pointer, you can implement the function in a
slightly different way. Rather than incrementing an integer index, you can increment a pointer variable to visit all
array elements in turn:
starts at the beginning of the array
Add the value to which
points
Advance
to the next array element
Initially, the pointer  points to the element 
. The increment
moves it to point to the next element (see Figure 6).
Figure 6   A Pointer Variable Traversing the Elements of an Array
It is a tiny bit more efficient to use and increment a pointer than to access an array element as 
. For this reason,
some programmers routinely use pointers instead of indexes to access array elements.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 7.1 Using a Pointer to Step Through an Array
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:28 PM

Quality Tip 7.2
QUALITY TIP 7.2 Program Clearly, Not Cleverly
Some programmers take great pride in minimizing the number of instructions, even if the resulting code is hard to
understand. For example, here is a legal implementation of the 
 function:
Loop size times
Add the value to which a points; increment
This implementation uses two tricks. First, the function parameters  and 
 are variables, and it is legal to
modify them. Moreover, the expressions
and
mean “decrement or increment the variable and return the old value”. Therefore, *
 increments the pointer to
the next element, but it returns the element to which it pointed before the increment.
Please do not use this programming style. Your job as a programmer is not to dazzle other programmers with your
cleverness, but to write code that is easy to understand and maintain.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 7.2 Program Clearly, Not Cleverly
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:28 PM

Common Error 7.2
COMMON ERROR 7.2 Returning a Pointer to a Local Variable
Consider this function that tries to return a pointer to an array containing two elements, the first and the last value
of an array.
ERROR!
The function returns a pointer to the starting element of the 
 array. However, that array is a local variable of
the 
 function. The local variable is no longer valid when the function exits, and the values will soon be
overwritten by other function calls.
You can solve this problem by returning a vector:
OK!
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 7.2 Returning a Pointer to a Local Variable
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:29 PM

Advanced Topic 7.2
ADVANCED TOPIC 7.2 Constant Pointers
The following definition specifies a constant pointer:
You cannot modify the value to which  points. That is, the following statement is illegal:
ERROR
Of course, you can read the value:
OK
A constant array parameter is syntactic sugar for a constant pointer. For example, consider the function
This definition is equivalent to
The function can use the pointer a to read the array elements, but it cannot modify them.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 7.2 Constant Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:29 PM

C++ has two mechanisms for manipulating strings. The 
 class supports character sequences of arbitrary length and
provides convenient operations such as concatenation and string comparison. However, C++ also inherits a more primitive
level of string handling from the C language, in which strings are represented as arrays of 
 values. In the following
sections, we will discuss the relationships between these types.
7.3.1 The 
 Type
The 
 type denotes an individual character. Character literals are delimited by single quotes; for example,
Each character is actually encoded as an integer value. (See Appendix D for the encoding using the ASCII code, which is used
on the majority of computers today.)
A value of type 
 denotes an individual character.
Character literals are enclosed in single quotes.
Note that 
 is a single character, which is quite different from 
, a string containing the 
 character.
Table 3 on page 302 shows typical character literals.
Table 3    Character Literals
  
The character 
  
The character for the digit 
. In the ASCII code, 
 has the value 48.
  
The space character
  
The newline character
  
The tab character
  
The null terminator of a string
 
Error: Not a 
 value
7.3.2 C Strings
In the C programming language, strings are always represented as character arrays. C++ programmers often refer to arrays of
char values as “C strings”.
A literal string (enclosed in double quotes) is an array
of 
 values with a zero terminator.
In particular, a literal string, such as 
, is not an object of type 
. Instead, it is an array of 
 values. As with
all arrays, a string literal can be assigned to a pointer variable that points to the initial character in the array:
Points to 'H'
A C string is terminated by a special character, called a null terminator, denoted 
. For example, the C string 
contains six characters, namely 
, 
, 
, 
, 
 and 
 (see Figure 7.)
C and C++ Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:29 PM

Figure 7   A Character Array
The terminator is a character that is encoded as the number zero—this is different from the character 
, the character
denoting the zero digit. (Under the ASCII encoding scheme, the character denoting the zero digit is encoded as the number 48.)
Functions that operate on C strings rely on this terminator. Here is a typical example, the 
 function declared in the
 header that computes the length of a character array. The function counts the number of characters until it reaches
the terminator.
Count characters before the null terminator
The call 
 returns 5.
7.3.3 Character Arrays
A literal string such as 
 is a constant. You are not allowed to modify its characters. If you want to modify the
characters in a string, define a character array instead. For example:
An array of 6 characters
The 
 variable is an array of 6 characters, containing 
, 
, 
, 
, 
, and a null terminator. The
compiler counts the characters in the string that is used for initializing the array, including the null terminator.
You can modify the characters in the array:
7.3.4 Converting Between C and C++ Strings
Before the C++ 
 class became widely available, direct manipulation of character arrays was common, but also quite
challenging (see Advanced Topic 7.3 on page 304). If you use functions that receive or return C strings, you need to know how
to convert between C strings and 
 objects.
Many library functions use pointers of type 
.
For example, the 
 header declares a useful function
The 
 function converts a character array containing digits into its integer value:
Now
is the integer 2012
C and C++ Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:29 PM

This functionality is inexplicably missing from the C++ 
 class. The 
 member function of the 
 class offers
an “escape hatch”. If  is a string, then 
 yields a 
* pointer to the characters in the string. Here is how you use
that member function to call the 
 function:
The 
 member function yields a 
 pointer
from a 
 object.
Conversely, converting from a C string to a C++ string is very easy. Simply initialize a 
 variable with the C string. For
example, the definition
initializes the C++ 
 object 
 with the C string 
.
You can initialize C++ 
 variables with C
strings.
7.3.5 C++ Strings are Vectors of Characters
Up to this point, we have always used the 
 member function to access individual characters in a C++ string. For
example, if a 
 variable is defined as
the expression
yields a string of length 1 containing the character at index 3.
You can access individual characters with the 
 operator:
You can access characters in a C++ 
 object
with the 
 operator.
Now the string is 
. The 
 operator is more convenient than the 
 function if you want to visit a string one
character at a time.
Here is a useful example. The following function makes a copy of a string and changes all characters to uppercase:
Makes an uppercase version of a string.
a string
 a string with the characters in 
 converted to uppercase
Make a copy of
C and C++ Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:29 PM

Convert each character to uppercase
For example, 
 returns a string with the characters 
.
The 
 function is defined in the 
 header. It converts lowercase characters to uppercase. (The 
function does the opposite.)
Self Check
11.  How many 
 values are stored in the character array 
, 
? 
12.  What is strlen(
, 
)? 
13.  Allocate a pointer variable that points to the string 
. 
14.  Consider this statement: 
Does the statement compile? What is its effect?
15.  Consider the following statements: 
If the input is not the letter , how do you extract the number stored in the string 
?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
C and C++ Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:29 PM

Advanced Topic 7.3
ADVANCED TOPIC 7.3 Working with C Strings
Before the 
 class became widely available, it was common to work with character arrays directly.
Table 4 shows several commonly used functions for manipulating C strings. All of these functions are declared in
the 
 header.
Table 4    C String Functons
In this table,  and  are character arrays;  is an integer.
Function
Description
Returns the length of .
Copies the characters from  into .
Copies at most  characters from  into .
Appends the characters from  after the end of the characters in .
;
Appends at most  characters from  after the end of the characters in .
Returns 0 if  and  have the same contents, a negative integer if  comes before  in
lexicographic order, a positive integer otherwise.
Consider the task of concatenating a first name and a last name into a string. The 
 class makes this very
easy:
Let us implement this task with C strings. Allocate an array of characters for the result:
This array can hold strings with a length of at most 39, because one character is required for the null terminator.
Now copy the first name, using 
:
You must be careful not to overrun the target array. It is unlikely that a first name is longer than 39 characters, but
a hacker could supply a longer input in order to overwrite memory.
Now, if there is still room, add a space and the last name, again being careful not to overrun the array boundaries.
ADVANCED TOPIC 7.3 Working with C Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:29 PM

Leave room for space, null terminator
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 7.3 Working with C Strings
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:29 PM

In many programming situations, you do not know beforehand how many values you need. To solve this problem, you can use
dynamic allocation and ask the C++ run-time system to create new values whenever you need them. The run-time system
keeps a large storage area, called the heap, that can allocate values and arrays of any type. When you ask for a
Use dynamic memory allocation if you do not know in
advance how many values you need.
then a storage location of type 
 is located on the heap, and a pointer to that location is returned. More usefully, the
expression
The new operator allocates memory from the heap.
allocates an array of size , and yields a pointer to the starting element. (Here  need not be a constant.)
You will want to capture that pointer in a variable:
You now use the pointer as described previously in this chapter. If you allocated an array, the magic of array/pointer duality
lets you use the array notation 
 to access the ith element.
When your program no longer needs memory that you previously allocated with the 
 operator, you must return it to the
heap, using the 
 operator:
However, if you allocated an array, you must use the 
 operator.
You must reclaim dynamically allocated objects with
the 
 operator.
This operator reminds the heap that the pointer points to an array, not a single value.
After you delete a memory block, you can no longer use it. The storage space may already be used elsewhere.
NO! You no longer own the memory of
Heap arrays have one significant advantage over array variables. If you declare an array variable, you must specify a fixed array
size when you compile the program. But when you allocate an array on the heap, you can choose the size at run time.
Moreover, if you later need more elements, you are not stuck. You can allocate a bigger heap array, copy the elements from the
smaller array into the bigger array, and delete the smaller array (see Figure 8):
Dynamic Memory Allocation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:29 PM

This is exactly what a 
 does behind the scenes.
Figure 8   Growing a Dynamic Array
Be sure to recycle any heap memory that your program no longer needs.
Carrie Bottomley/iStockphoto.
Heap allocation is a powerful feature, but you must be very careful to follow all rules precisely:
•  Every call to 
 must be matched by exactly one call to 
.
•  Use 
 to delete arrays.
•  Don't access a memory block after it has been deleted.
If you don't follow these rules, your program can crash or run unpredictably. Table 5 shows common errors.
Dynamic Memory Allocation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:29 PM

Table 5    Common Memory Allocation Errors
Statements
Error
There is no call to 
.
The first allocated memory block was never deleted.
The 
 operator should have been used.
The same memory block was deleted twice.
You can only delete memory blocks that you obtained from calling 
.
Self Check
16.  What does this statement sequence print? 
17.  What does this statement sequence print? 
18.  What is wrong with this sequence of statements? 
Dynamic Memory Allocation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:29 PM

19.  Consider this function 
What is the contents of the array to which  points after these statements?
20.  Consider the 
 function of Self Check 19. What must its caller remember to do? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Dynamic Memory Allocation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:29 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 7.2 Dynamic Memory Allocation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:30 PM

Common Error 7.3
COMMON ERROR 7.3 Dangling Pointers
A very common pointer error is to use a pointer that has not been initialized, or that has already been deleted. Such
a pointer is called a dangling pointer, because it does point somewhere. You can create real damage by writing to
the location to which it points. Even reading from the location can crash your program.
Using a dangling pointer (a pointer that has not
been initialized or has been deleted) is a serious
programming error.
An uninitialized pointer has a good chance of pointing to an address that your program doesn't own. On most
operating systems, attempting to access such a location causes a processor error, and the operating system shuts
down the program. You may have seen that happen to other programs—a dialog box with a bomb icon or a
message such as “general protection fault” or “segmentation fault” comes up, and the program is terminated.
If a dangling pointer points to a valid address inside your program, then writing to it will damage some part of your
program. You will change the value of one of your variables, or perhaps damage the control structures of the heap
so that it starts returning invalid pointers when you call 
.
When your program crashes and you restart it, the problem may not reappear, or it may manifest itself in different
ways because the random pointer is now initialized with a different random address.
Programming with pointers requires iron discipline.
•  Always initialize pointer variables. If you can't initialize them with the return value of 
 or the  operator,
then set them to 
.
•  Never use a pointer that has been deleted.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 7.3 Dangling Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:30 PM

Common Error 7.4
COMMON ERROR 7.4 Memory Leaks
Another very common pointer error is to allocate memory on the heap and never deallocate it. A memory block that
is never deallocated is called a memory leak.
If you allocate a few small blocks of memory and forget to deallocate them, this is not a huge problem. When the
program exits, all allocated memory is returned to the operating system.
But if your program runs for a long time, or if it allocates lots of memory (perhaps in a loop), then it can run out
of memory. Memory exhaustion will cause your program to crash. In extreme cases, the computer may freeze up if
your program exhausted all available memory. Avoiding memory leaks is particularly important in programs that
need to run for months or years, without restarting.
Every call to 
 should have a matching call to
.
Even if you write short-lived programs, you should make it a habit to avoid memory leaks. Make sure that every
call to the 
 operator has a corresponding call to the 
 operator.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 7.4 Memory Leaks
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:30 PM

When you have a sequence of pointers, you can place them into an array or vector. An array and a vector of ten 
 pointers
are defined as
The expression 
 or 
 denotes the pointer with index  in the sequence.
One application of such pointer sequences are two-dimensional arrays in which each row has a different length, such as the
triangular array shown in Figure 9.
Figure 9   A Triangular Array
In this situation, it would not be very efficient to use a two-dimensional array, because almost half of the elements would be
wasted.
We will develop a program that uses such an array for simulating a Galton board. A Galton board consists of a pyramidal
arrangement of pegs, and a row of bins at the bottom. Balls are dropped onto the top peg and travel toward the bins. At each
peg, there is a 50 percent chance of moving left or right. The balls in the bins approximate a bell-curve distribution.
The Galton board can only show the balls in the bins, but we can do better by keeping a counter for each peg, incrementing it as
a ball travels past it.
We will simulate a board with ten rows of pegs. Each row requires an array of counters. The following statements initialize the
triangular array:
Note that the first element 
 contains a pointer to an array of length 1, and the last element 
 contains a
pointer to an array of length 10.
Before doing the simulation, let us consider how to print out the values. The element 
 points to an array. The
element of index  of that array is
This loop prints all elements in the th row:
Arrays and Vectors of Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:30 PM

Now let's simulate a falling ball. The movements to the left and right in Figure 10 correspond to movements to the next row,
either straight down or to the right, in Figure 11 . More precisely, if the ball is currently at row  and column , then it will go
to row  + 1 and, with a 50 percent chance, either stay in column  or go to column  + 1.
Figure 10   A Galton Board
Figure 11   Movement of a Ball in the Galton Board Array
The program below has the details. In the sample program run, notice how 1,000 balls have hit the top peg, and how the
bottommost row of pegs approximates a bell-curve distribution.
ch07/galton.cpp
Arrays and Vectors of Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:30 PM

Allocate the rows
Simulate 1,000 balls
Add a ball to the top
Have the ball run to the bottom
If
is even, move down, otherwise to the right
Print all counts
Deallocate the rows
Program Run
Arrays and Vectors of Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:30 PM

Self Check
21.  Why didn't we initialize the triangular array with the following loop? 
22.  Suppose a program initializes a triangular array as we did in this section, and then accesses a non-existent
element with the statement 
Will the program compile? If so, what happens at run time?
23.  Initialize a triangular 10 × 10 array where the first row has length 10 and the last row has length 1.
24.  What changes would need to be made to the 
 program so that 
 is a 
?
25.  What changes would need to be made to the 
 program so that each row is a 
?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Arrays and Vectors of Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:30 PM

How To 7.1
HOW TO 7.1 Working with Pointers
You use pointers because you want flexibility in your program: the ability to change the relationships between
data. This How To walks you through the decision-making process for using pointers.
We will illustrate the steps with the task of simulating a part of the control logic for a departmental photocopier. A
person making a copy enters a user number. There are 100 different users, with numbers 0 to 99. Each user is
linked to a copy account, either the master account or one of ten project accounts. That linkage is maintained by the
administrator, and it can change as users work on different projects. When copies are made, the appropriate account
should be incremented.
Users identify themselves on the copier control panel. Using pointers, the relationships between users and copy
accounts can be flexible.
Bartosz Liszkowski/iStockphoto.
Step 1  Draw a picture.
Start with the data that will be accessed or modified through the pointers. These may be account
balances, counters, character strings, or other items. Focus on what is being pointed at.
Then draw the variable or variables that contain the pointers. These will be the front-end to your
system. You will start with a pointer, then locate the actual data.
Finally, draw the pointers as arrows. If the pointers will vary as the program executes, draw a typical
arrangement.
In our example, we need to track the copy accounts: a master account and ten project accounts. For
each user, we need a pointer to the copy account:
HOW TO 7.1 Working with Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:30 PM

Step 2  Declare pointer variables.
This step is usually easy. With numerical data, you will have pointers of type 
 or 
. If
you manipulate character arrays, you use 
 pointers. In Chapter 10, you will use pointers to
objects.
How many pointer variables do you have? If you only have one or two, just declare variables such as
If you have a sequence of pointers, use a vector or array, such as
In our example, the purpose is to manipulate copy counters. Therefore, our data are integers and the
pointers have type 
. We know that we will have exactly 100 pointers. Therefore, we can choose
an array
Step 3  Initialize the pointers with variable addresses or heap memory.
Will you allocate variables and then take their addresses with the  operator? That is fine if you
have a fixed amount of data that you want to reach through the pointers. Otherwise, use the 
operator to allocate memory dynamically. Be sure to deallocate the memory when you are done,
using the 
 or 
 operator.
In our example, there is no need for dynamic allocation, so we will just take addresses of variables.
Link a couple of project accounts to simulate the administrator
Step 4  Use the * or 
 operator to access your data.
When you access a single variable through a pointer, use the * operator to read or write the variable.
For example,
When you have a pointer to an array, use the 
 notation. Simply think of the pointer as the array:
If you have an array or vector of pointers, then you need brackets to get at an individual pointer.
Then supply another * or 
 to get at the value. You saw an example in the Galton board simulator
HOW TO 7.1 Working with Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:30 PM

where a count was accessed as
Implement your algorithm, keeping these access rules in mind.
In our example, we read the user ID and number of copies. Then we increment the copy account:
Exercise P7.10. asks you to complete this simulation.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
HOW TO 7.1 Working with Pointers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:30 PM




Random Fact 7.1
RANDOM FACT 7.1 Embedded Systems
An embedded system is a computer system that controls a device. The device contains a processor and other
hardware and is controlled by a computer program. Unlike a personal computer, which has been designed to be
flexible and run many different computer programs, the hardware and software of an embedded system are tailored
to a specific device. Computer controlled devices are becoming increasingly common, ranging from washing
machines to medical equipment, cell phones, automobile engines, and spacecraft.
Several challenges are specific to programming embedded systems. Most importantly, a much higher standard of
quality control applies. Vendors are often unconcerned about bugs in personal computer software, because they
can always make you install a patch or upgrade to the next version. But in an embedded system, that is not an
option. Few consumers would feel comfortable upgrading the software in their washing machines or automobile
engines. If you ever handed in a programming assignment that you believed to be correct, only to have the
instructor or grader find bugs in it, then you know how hard it is to write software that can reliably do its task for
many years without a chance of changing it. Quality standards are especially important in devices whose failure
would destroy property or endanger human life. Many personal computer purchasers buy computers that are fast
and have a lot of storage, because the investment is paid back over time when many programs are run on the same
equipment. But the hardware for an embedded device is not shared—it is dedicated to one device. A separate
processor, memory, and so on, are built for every copy of the device (see Figure 12). If it is possible to shave a few
pennies off the manufacturing cost of every unit, the savings can add up quickly for devices that are produced in
large volumes. Thus, the embedded-system programmer has a much larger economic incentive to conserve
resources than the programmer of desktop software. Unfortunately, trying to conserve resources usually makes it
harder to write programs that work correctly.
RANDOM FACT 7.1 Embedded Systems
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:31 PM

Figure 12   The Controller of an Embedded System
Courtesy of Professor Naehyuck Chang, Computer Systems Lab, Department of Computer
Engineering, Seoul National University.
C and C++ are commonly used languages for developing embedded systems.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 7.1 Embedded Systems
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:31 PM

1.  A pointer denotes the location of a variable in memory.
Alexey Chuvarkov/iStockphoto.
2.  The type 
 denotes a pointer to a variable of type .
3.  The  operator yields the location of a variable.
4.  The * operator locates the value to which a pointer points.
5.  It is an error to use an uninitialized pointer.
6.  The 
 pointer does not point to any object.
7.  The value of an array variable is a pointer to the starting element of the array.
8.  Pointer arithmetic means adding an integer offset to an array pointer, yielding a pointer that skips past the given
number of elements.
9.  The array/pointer duality law states that 
 is identical to 
, where a is a pointer into an array and  is
an integer offset.
10.  When passing an array to a function, only the starting address is passed.
11.  A value of type 
 denotes an individual character. Character literals are enclosed in single quotes.
12.  A literal string (enclosed in double quotes) is an array of 
 values with a zero terminator.
13.  Many library functions use pointers of type 
.
14.  The 
 member function yields a 
 pointer from a 
 object.
15.  You can initialize C++ 
 variables with C strings.
16.  You can access characters in a C++ 
 object with the 
 operator.
17.  Use dynamic memory allocation if you do not know in advance how many values you need.
18.  The 
 operator allocates memory from the heap.
19.  You must reclaim dynamically allocated objects with the 
 operator.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:31 PM

Carrie Bottomley/iStockphoto.
20.  Using a dangling pointer (a pointer that has not been initialized or has been deleted) is a serious programming error.
21.  Every call to 
 should have a matching call to 
.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:31 PM

Review Exercises
Exercise R7.1.    
Trace the following code. Assume that  and  are stored at 20300 and 20308. Your trace table should have entries for , , and .
Exercise R7.2.    
Trace the following code. Assume that  and  are stored at 20300 and 20308. Your trace table should have entries for , , , and .
Exercise R7.3.    
What does the following code print?
Exercise R7.4.    
Explain the mistakes in the following code. Not all lines contain mistakes. Each line depends on the lines preceding it.
Exercise R7.5.    
Suppose that a system allows the use of any string as a password, even the empty string. However, when a user connects to the system for the first time, no password has been assigned. Describe how you can use a
 variable and the 
 pointer to distinguish unassigned passwords from empty ones.
Exercise R7.6.    
Given the definitions
draw a diagram that explains the meanings of the following expressions:
(a)  
(b)  
(c)  
(d)  
(e)  
Exercise R7.7.    
Suppose the array 
, defined as
starts at memory location 20300. What are the values of
(a)  
(b)  
(c)  
(d)  
(e)  
(f)  
Exercise R7.8.    
Suppose the array 
 is defined as
Consider the 
 function discussed in Section 7.2. What are the values of
(a)  
(b)  
(c)  
(d)  
(e)  
Exercise R7.9.    
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:31 PM

Suppose the array 
, defined as
starts at memory location 20300. Trace the function call 
, using the definition of 
 from Advanced Topic 7.1 on page 298. In your trace table, show the values for , 
, 
, , and .
Exercise R7.10.    
Pointers are addresses and have a numerical value. You can print out the value of a pointer as 
. Write a program to compare 
 and 
, where  is an 
 and  is a
. Explain the results.
Exercise R7.11.    
A pointer variable can contain a pointer to a single variable, a pointer to an array, 
, or a random value. Write code that creates and sets four pointer variables , , , and  to show each of these possibilities.
Exercise R7.12.    
Implement a function 
 that obtains the first and last values in an array of integers and stores the result in an array parameter.
Exercise R7.13.    
Explain the meanings of the following expressions:
(a)  
(b)  
(c)  
(d)  
Exercise R7.14.    
What is the difference between the following two variable definitions?
(a)  
(b)  
Exercise R7.15.    
What is the difference between the following three variable definitions?
(a)  
(b)  
(c)  
Exercise R7.16.    
Consider this program segment:
What is the value of 
 at the end of the outer 
 loop?
Exercise R7.17.    
Consider the following code that repeats a C++ string three times.
Suppose  is a C string, and  is declared as
Write the equivalent code for C strings that stores the threefold repetition of  (or as much of it as will fit) into 
Exercise R7.18.    
Which of the following assignments are legal in C++?
Exercise R7.19.    
What happens if you forget to delete an object that you obtained from the heap? What happens if you delete it twice?
Exercise R7.20.    
Write a program that accesses a deleted pointer, an uninitialized pointer, and a 
 pointer. What happens when you run your program?
Exercise R7.21.    
Find the mistakes in the following code. Not all lines contain mistakes. Each line depends on the lines preceding it. Watch out for uninitialized pointers, 
 pointers, pointers to deleted objects, and confusing pointer
with objects.
Exercise R7.22.    
How do you define a triangular two-dimensional array using just vectors, not arrays or pointers?
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:31 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:31 PM

Exercise P7.1.    
Write a function that computes the average value of an array of floating-point data:
In the function, use a pointer variable, not an integer index, to traverse the array elements.
Exercise P7.2.    
Write a function that returns a pointer to the maximum value of an array of floating-point data:
If 
 is 0, return 
.
Exercise P7.3.    
Write a function that reverses the values of an array of floating-point data:
In the function, use two pointer variables, not integer indexes, to traverse the array elements.
Exercise P7.4.    
Implement the 
 function of the standard library.
Exercise P7.5.    
Implement the standard library function
that returns the length of the initial portion of s consisting of the characters in  (in any order).
Exercise P7.6.    
Write a function
that reverses a character string. For example, 
 becomes 
.
Exercise P7.7.    
Using the 
 and 
 functions, implement a function
that concatenates the strings  and  to the buffer 
. Be sure not to overrun the buffer. It can hold
 characters, not counting the 
 terminator. (That is, the buffer has 
 + 1
bytes available.)
Exercise P7.8.    
Write a function 
 that reads data from 
 until the user terminates input by entering .
The function should set the 
 reference parameter to the number of numeric inputs. Return a pointer to an array on the
heap. That array should have exactly 
 elements. Of course, you won't know at the outset how many elements the user
will enter. Start with an array of 10 elements, and double the size whenever the array fills up. At the end, allocate an array
of the correct size and copy all inputs into it. Be sure to delete any intermediate arrays.
Exercise P7.9.    
Enhance the Galton board simulation by printing a bar chart of the bottommost counters. Draw the bars vertically, below
the last row of numbers.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:31 PM

Exercise P7.10.    
Complete the copier simulation of How To 7.1 on page 314. Your program should first show the main menu:
For a user, prompt for the ID and the number of copies, increment the appropriate account, and return to the main menu.
For an administrator, show this menu:
In the balance option, show the balances of the master account and the ten project accounts. In the master option, prompt
for a user ID and link it to the master account. In the project option, prompt for user and project IDs. Afterward, return to
the main menu.
Exercise P7.11.    
Write a program that reads lines of text and appends them to a 
. Stop after reading 1,000
characters. As you read in the text, replace all newline characters 
 with 
 terminators. Establish an array
, so that the pointers in that array point to the beginnings of the lines in the text. Consider only 100
input lines if the input has more lines. Then display the lines in reverse order, starting with the last input line.
Exercise P7.12.    
The program in Exercise P7.11 is limited by the fact that it can only handle inputs of 1,000 characters or 100 lines.
Remove this limitation as follows. Concatenate the input in one long 
 object. Use the 
 member function to
obtain a 
 into the string's character buffer. Store the beginnings of the lines as a 
.
Exercise P7.13.    
Exercise P7.12. demonstrated how to use the 
 and 
 classes to implement resizable arrays. In this exercise,
you should implement that capability manually. Allocate a buffer of 1,000 characters from the heap (
). Whenever the buffer fills up, allocate a buffer of twice the size, copy the buffer contents, and delete the
old buffer. Do the same for the array of char* pointers—start with 
 and keep doubling the size.
Exercise P7.14.    
Modify Exercise P7.11. so that you first print the lines in the order that they were entered, then print them in sorted order.
When you sort the lines, only rearrange the pointers in the 
 array.
Exercise P7.15.    
When you read a long document, there is a good chance that many words occur multiple times. Instead of storing each
word, it may be beneficial to only store unique words, and to represent the document as a vector of pointers to the unique
words. Write a program that implements this strategy. Read a word at a time from 
. Keep a 
 of
words. If the new word is not contained in this vector, allocate memory, copy the word into it, and append a pointer to the
new memory. If the word is already present, then append a pointer to the existing word.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:31 PM



Worked Example 7.1
•
Producing a Mass Mailing
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Producing a Mass Mailing
We want to automate the process of producing mass mailings. A typical letter might look as
follows:
To: Ms. Sally Smith
123 Main Street
Anytown, NY 12345
Dear Ms. Smith: 
The Smith family may be the lucky winner in the C++ sweepstakes.
Wouldn't it be exciting if you were the first Anytown residents
to use ACME's new C++ development environment? etc. etc. 
Another letter with the same template but different values for the variable parts would look
like this:
To: Mr. Harry Morgan
456 Park Ave
Everyville, KS 67890
Dear Mr. Morgan: 
The Morgan family may be the lucky winner in the C++ sweepstakes.
Wouldn't it be exciting if you were the first Everyville residents
to use ACME's new C++ development environment? etc. etc. 
To set up such a mailing, we start with a template string in which each of the variable parts is
denoted by a digit 0 ... 9. (We assume that digits are not otherwise used in the template text.) 
To: 0 1 2
3
4, 5 6
Dear 0 2:
The 2 family may be the lucky winner in the C++ sweepstakes.
Wouldn't it be exciting if you were the first 4 residents
to use ACME's new C++ development environment? etc. etc. 
This template is set up in a string, like this:
char letter_template[] = "To: 0 1 2\n3\n4, 5 6\n\nDear 0 2: \n\n"
   "The 2 family may be the lucky winner in the C++ sweepstakes.\n"
   "Wouldn't it be exciting if you were the first 4 residents\n"
   "to use ACME's new C++ development environment? etc. etc. \n\n\n";
(To declare a literal string in C++ that does not ﬁt on a single line, you write a sequence of
literal strings. The compiler combines them into a single string.)
WORKED EXAMPLE 7.1

2
C++ for Everyone  •  CHAPTER 7
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Of course, we could produce a separate string for each mailing, by replacing the digits
with the values for a particular recipient. But there is a more efﬁcient way. Your task will be
to set up a vector of character pointers that point to successive fragments of the letter, either
from the template string or the variable parts. For example, the body of the letter above is
represented by pointers to the following strings:
•
": \n\nThe " 
• Variable 2 
•
" family may be ... were the first " 
• Variable 4 
•
" residents ... " 
The variable parts are stored in a two-dimensional array of characters. 
char variable_parts[10][VAR_LENGTH];
Each row of this array contains a variable:
strcpy(variable_parts[0], "Ms.");
strcpy(variable_parts[1], "Sally");
strcpy(variable_parts[2], "Smith");
strcpy(variable_parts[3], "123 Main Street");
strcpy(variable_parts[4], "Anytown");
strcpy(variable_parts[5], "NY");
strcpy(variable_parts[6], "12345");
Printing a letter is achieved with the following loop:
vector<char*> fragments = prepare_mailing(letter_template, variable_parts);
for (int i = 0; i < fragments.size(); i++)
{
   cout << fragments[i];      
}
Your task will be to implement the prepare_mailing function, and to produce a main func-
tion that prints the two letters given above.
Step 1
Draw a picture.
We start with the data that is being accessed through pointers: the strings in the letter tem-
plate (after replacing the variable placeholders with null terminators), and the strings in the
variable array. 
M
s
. \0
S
a
l
l
y \0
S
m
i
t
1
2
3
A
n
y
t
h
M
o
\0
a
w
i
n
n
\0
S
t
r
e
e
t \0
T
\n
\n
:
h
e
\0
f
a
m
i
l
y
f
i
r
s
t
\0
r
e
...
[0]
[1]
[2]
[3]
[4]
...
s
i
d
e
n

Worked Example 7.1
•
Producing a Mass Mailing
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
The pointers point into the template and variable strings, like this:
Step 2
Declare pointer variables.
We collect a sequence of char* pointers of unknown length. Therefore, we use a vector of
pointers
vector<char*> fragments;
Step 3
Initialize the pointers with variable addresses or heap memory.
This is the task of the prepare_mailing function. That function needs to scan the letter tem-
plate for variable indicators, replace them with null terminators, and store pointers in the
fragments vector. Here is the pseudocode:
Set the fragment start to the beginning of the letter template.
For each character in the letter template.
{
If the character is a digit
{
Add the fragment start to the fragments vector.
Add the row of the variable denoted by the digit to the fragments vector.
Replace the digit with a null terminator.
Set the fragment start to the following character.
}
}
You will ﬁnd the C++ code in the code listing below.
Step 4
Use the * or [] operator to access your data.
This step has already been completed in the problem statement. It was a requirement that the
fragments can be printed with the following loop:
for (int i = 0; i < fragments.size(); i++)
{
M
s
. \0
S
a
l
l
y \0
S
m
i
t
1
2
3
A
n
y
t
h
M
o
\0
a
w
i
n
n
\0
S
t
r
e
e
t \0
T
\n
\n
:
h
e
\0
f
a
m
i
l
y
f
i
r
s
t
\0
r
e
...
fragments =
...
...
[0]
[1]
[2]
[3]
[4]
...

4
C++ for Everyone  •  CHAPTER 7
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   cout << fragments[i];      
}
All that remains is to complete a main program that prints two letters, as shown in the code
listing. Note that the prepare_mailing function is only called once. Afterward, the variable
array is updated for each mailing, but the fragments vector never changes.
Here is the complete program, ch07/mail.cpp.
#include <cctype>
#include <iostream>
#include <string>
#include <vector>
using namespace std;
const int VAR_LENGTH = 20;
/**
   Prepares a letter template for a mass mailing.
   @param letter a string with placeholders 0 ... 9 (which will be replaced 
   with null terminators)
   @param vars a two-dimensional array for holding the variable parts of the letter
   @return a vector of fragments, pointing alternately to strings in the letter template
   and in the variable array)
*/
vector<char*> prepare_mailing(char* letter, char vars[][VAR_LENGTH])
{
   vector<char*> fragments;
   char* fragment_start = letter;
   for (char* p = letter; *p != '\0'; p++)
   {
      if (isdigit(*p))
      {
         fragments.push_back(fragment_start);
         fragment_start = p + 1;
         int var_index = *p - '0';
         fragments.push_back(vars[var_index]);
         *p = '\0';
      }
   }
   fragments.push_back(fragment_start);
   return fragments;
}
int main()
{
   char variable_parts[10][VAR_LENGTH];
   strcpy(variable_parts[0], "Ms.");
   strcpy(variable_parts[1], "Sally");
   strcpy(variable_parts[2], "Smith");
   strcpy(variable_parts[3], "123 Main Street");
   strcpy(variable_parts[4], "Anytown");

Worked Example 7.1
•
Producing a Mass Mailing
5
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   strcpy(variable_parts[5], "NY");
   strcpy(variable_parts[6], "12345");
   char letter_template[] = "To: 0 1 2\n3\n4, 5 6\n\nDear 0 2: \n\n"
      "The 2 family may be the lucky winner in the C++ sweepstakes.\n"
      "Wouldn't it be exciting if you were the first 4 residents\n"
      "to use ACME's new C++ development environment? etc. etc. \n\n\n";
   vector<char*> fragments = prepare_mailing(letter_template, variable_parts);
   for (int i = 0; i < fragments.size(); i++)
   {
      cout << fragments[i];      
   }
 
   strcpy(variable_parts[0], "Mr.");
   strcpy(variable_parts[1], "Harry");
   strcpy(variable_parts[2], "Morgan");
   strcpy(variable_parts[3], "456 Park Ave");
   strcpy(variable_parts[4], "Everyville");
   strcpy(variable_parts[5], "KS");
   strcpy(variable_parts[6], "67890");
   for (int i = 0; i < fragments.size(); i++)
   {
      cout << fragments[i];      
   }
   return 0;
}

Chapter
   
    
    
Chapter Goals
•  To be able to read and write files
•  To convert between strings and numbers using string streams
•  To learn how to process the command line
•  To understand the concepts of sequential and random access
•  To learn about encryption
All of the programs that you have written until now have read their input from the keyboard and displayed their
output on the screen. However, many programs need to be able to use disk files for reading input and writing
output. In this chapter, you will learn how to use the C++ stream library for file processing.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To be able t ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:32 PM

The C++ input/output library is based on the concept of streams. An input stream is a source of data, and an output stream
is a destination for data. The most common sources and destinations for data are the files on your hard disk.
Data arrive in an input stream just like items on a conveyor belt, one at a time.
iStockphoto.
To access a disk file, you use a file stream. There are three types of file streams: 
 (for input), 
 (for
output), and 
 (for both input and output). Include the 
 header when you use any of these file streams.
To read or write disk files, you use variables of type
, or 
.
In the following sections, you will learn how to process data from files.
8.1.1 Opening a Stream
To read anything from a file stream, you need to open it. When you open a stream, you give the name of the disk file. Suppose
you want to read data from a file named 
, located in the same directory as the program. Then you use the following
command to open the file:
This command call associates the variable 
 with the disk file named 
.
When opening a file stream, you supply the name of
the disk file.
Note that all streams are objects, and you use the dot notation for calling functions that manipulate them.
To open a file for writing, you use an 
 variable. To open the same file for both reading and writing, you use an
 variable.
File names can contain directory path information, such as
Reading and Writing Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 6
2/1/2010 2:33 PM

When you specify the file name as a string literal, and the name contains backslash characters (as in a Windows filename), you
must supply each backslash twice:
Recall that a single backslash inside a string literal is an escape character that is combined with another character to form a
special meaning, such as 
 for a newline character. The 
 combination denotes a single backslash.
If you want to pass a name that is stored in a 
 variable, use the 
 function to convert the C++ 
 to a C
string.
When the program ends, all streams that you have opened will be automatically closed. You can also manually close a stream
with the 
 member function:
Manual closing is only necessary if you want to open the file again in the same program run.
8.1.2 Reading from a File
Reading data from a file stream is completely straightforward: You simply use the same functions that you have always used
for reading from 
.
Read from a file stream with the same operations that
you use with 
.
The 
 function tells you whether input has failed. You have already used this function with 
, to check for errors in
numeric input. File streams behave in the same way. When you try to read a number from a file, and the next data item is not a
properly formatted number, then the stream fails. After reading data, you should test for success before processing:
Process input
Alternatively, you can use the fact that the >> operator returns a “not failed” condition, allowing you to combine an input
statement and a test:
Process input
When you read input from a file, number format errors are not the only reason for failure. Suppose you have consumed all of
the data contained in a file and try to read more items. A file stream enters the failed state, whereas 
 would just wait for
more user input. Moreover, if you open a file and the name is invalid, or if there is no file of that name, then the file stream is
Reading and Writing Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 6
2/1/2010 2:33 PM

also in a failed state. It is a good idea to test for failure immediately after calling 
.
8.1.3 Writing to a File
In order to write to a file, you define an 
 or 
 variable and open it. Then you send information to the output
file, using the same operations that you used with 
.
Write to a file stream with the same operations that
you use with 
.
8.1.4 A File Processing Example
Here is a typical example of processing data in a file. The Social Security Administration publishes lists of the most popular
baby names on their web site http://www.ssa.gov/OACT/babynames/. When querying the 1,000 most popular names for a
given decade, the browser displays the result on the screen (see Figure 1).
Figure 1   Querying Baby Names
Reading and Writing Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 6
2/1/2010 2:33 PM

To save the data as text, one simply selects it and pastes the result into a file. The book code contains a file 
with the data for the 1990s.
Each line in the file contains seven entries:
•  The rank (from 1 to 1,000)
•  The name, frequency, and percentage of the male name of that rank
•  The name, frequency, and percentage of the female name of that rank
Sellers of personalized items can find trends in popular names by processing data files from the Social Security
Administration.
age fotostock/SUPERSTOCK.
For example, the line
shows that the 10th most common boy's name was Joseph, with 260,365 births, or 1.2681 percent of all births during that
period. The 10th most common girl's name was Megan. Why are there many more Josephs than Megans? Parents seem to use a
wider set of girl's names, making each one of them less frequent.
Let us test that conjecture, by determining the names given to the top 50 percent of boys and girls in the list.
To process each line, we first read the rank:
We then read a set of three values for the boy's name:
Then we repeat that step for girls. Because the actions are identical, we supply a helper function 
 for that
purpose. To stop processing after reaching 50 percent, we can add up the frequencies and stop when they reach 50 percent.
However, it turns out to be a bit simpler to initialize a total with 50 and subtract the frequencies. We need separate totals for
boys and girls. When a total falls below 0, we stop printing. When both totals fall below 0, we stop reading.
Note that the 
 parameter of the 
 function is passed by reference. Reading or writing modifies a
stream variable. The file variable monitors how many characters have been read or written so far. Any read or write operation
changes that data. For that reason, you must always pass stream variables by reference.
Reading and Writing Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 6
2/1/2010 2:33 PM

Always use a reference parameter for a stream.
The complete program is shown below. As you can see, reading from a file is just as easy as reading keyboard input.
Have a look at the program output. Remarkably, only 69 boy names and 153 girl names account for half of all births. That's
good news for those who are in the business of producing personalized doodads. Exercise P8.10. asks you to study how this
distribution changed over the years.
ch08/babynames.cpp
 
Reads name information, prints the name if
, and adjusts the total.
the input stream
the total percentage that should still be processed
Check for failure after each input
Check for failure after opening
Reading and Writing Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 6
2/1/2010 2:33 PM

Program Run
Self Check
1.  What happens if you call 
? 
2.  What is wrong with the following code? 
3.  What is wrong with the following function? 
4.  How do you modify the 
 program so that you get the most common names that make up 10
percent of the population? 
5.  How do you modify the 
 program so that the program output is saved to a file 
?
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Reading and Writing Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 6
2/1/2010 2:33 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 8.1 Working with File Streams
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:33 PM

In the following sections, you will learn how to process text with complex contents that often occurs in real life situations.
8.2.1 Reading Words
You already know how to read the next word from a stream, using the  operator.
Here is precisely what happens when that operation is executed. Input characters that are white space are consumed first.
White space includes spaces, tab characters, and the newline characters that separate lines. The first character that is not white
space is added to word. More characters are added until either another white space character occurs, or the end of the file has
been reached.
8.2.2 Reading Characters
Instead of reading an entire word, you can read one character at a time by calling the get method:
The get function returns the “not failed" condition. The following loop processes all characters in a file:
Process the character ch
The get method reads white space characters. If you want to skip past white space, use the >> operator instead:
 is set to the next non-white space character
If you read a character and you regretted it, you can unget it, so that the next input operation can read it again. However, you
can unget only the last character. This is called one-character lookahead. You get a chance to look at the next character in the
input stream, and you can make a decision whether you want to consume it or put it back.
You can get individual characters from a stream and
unget the last one.
A typical situation for lookahead is to look for numbers:
Put the digit back so that it is part of the number
Read integer starting with
The 
 function is one of several useful functions that categorize characters—see Table 1 on page 337. You must
include the 
 header to use these functions.
Reading Text Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:34 PM

If you read a character from a stream and you don't like what you get, you can unget it.
altrendo images/Getty Images.
Table 1    Character Predicate Functions in 
Function
Accepted Characters
0 … 9
a … z, A … Z
a … z
A … Z
a … z, A … Z, 0 … 0
White space (space, tab, newline, and the rarely used carriage return, form feed, and vertical tab)
8.2.3 Reading Lines
When each line of a file is a data record, it is often best to read entire lines with the getline function:
The next input line (without the newline character) is placed into the string 
.
The 
 function returns the “not failed” condition. You can use the following loop to process each line in a file:
Process line
Note that 
 is not a member function, but an ordinary function that is not called with the dot notation.
Here is a typical example of processing lines in a file. A file with population data from the CIA Fact Book site
(http://www.cia.gov/library/publications/the-world-factbook/) contains lines such as the following:
Because each line is a data record, it is natural to use the 
 function for reading lines into a string variable. To extract
the data from that string, you need to find out where the name ends and the number starts.
Reading Text Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:34 PM

Locate the first digit:
Then go backward and skip white space:
Finally, extract the country name and population:
There is just one problem. The population is stored in a string, not a number. You will see in Section 8.4 how to extract the
population number.
Self Check
6.  Suppose the input stream contains the characters 
. What is the value of 
 and 
 after these
statements? 
7.  Suppose the input stream contains the characters 
. What is the value of 
 and 
 after
these statements? 
8.  Your input file contains a sequence of numbers, but sometimes a value is not available and marked as 
.
How can you read the numbers and skip over the markers? 
9.  What is the effect of the following loop? 
10.  Why can't you simply read the population data file with the following loop? 
Reading Text Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:34 PM

Process country name and population
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Reading Text Input
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:34 PM

You use the  operator to send strings and numbers to a stream. To write a single character, use
Control stream formatting with manipulators.
To control how the output is formatted, you use stream manipulators. A manipulator is an object that is sent to a stream using
the 
 operator, and that affects the behavior of the stream. The 
 manipulator, which you have already used, is a typical
example. The statement
does not cause any immediate output, but when the next item is written, it is padded with sufficient spaces so that the output
spans ten characters. (If a value does not fit into the given width, it is not truncated.)
Occasionally, you need to pad numbers with leading zeroes, for example to print hours and minutes as 09:01. This is achieved
with the 
 manipulator:
Now, a zero is used to pad the field. Afterward, the space is restored as the fill character.
By default, the fill characters appear before the item:
produces
The numbers line up to the right. That alignment works well for numbers, but not for strings. Usually, you want strings to line
up at the left. You use the 
 and 
 manipulators to set the alignment. The following example uses left alignment for
a string and then switches back to right alignment for a number:
A manipulator is like a control button on a sound mixer. It doesn't produce an output, but it affects how the output looks.
iStockphoto.
Writing Text Output
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:34 PM

The default format for floating-point numbers is called general format. That format displays as many digits as are specified by
the precision (6 by default), switching to scientific notation for large and small numbers. For example,
yields
The fixed format prints all values with the same number of digits after the decimal point. In the fixed format, the same numbers
are displayed as
Use the 
 manipulator to select that format, and the 
 manipulator to change the precision.
For example,
yields
Table 2 summarizes the stream manipulators. Note that all manipulators set the state of the stream object for all subsequent
operations, with the exception of 
. After each output operation, the field width is reset to 0.
Table 2    Stream Manipulators
Manipulator
Purpose
Example
Output
Sets the field width of the
next item only.
Sets the fill character for
padding a field. (The
default character is a
space.)
Selects left alignment.
Selects right alignment
(default).
Selects fixed format for
floating-point numbers.
Sets the number of
significant digits for
general format, the
number of digits after the
decimal point for fixed
format.
Self Check
Writing Text Output
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:34 PM

11.  What is the output of the following statement? 
12.  How do you change the statement so that the result is 
? 
13.  What is the output of the following statement? 
14.  What is the output of the following statement? 
15.  Why doesn't the following statement sequence line up the numbers? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Writing Text Output
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:34 PM

In the preceding section, you saw how file streams read characters from a file and write characters to a file. The
 class reads characters from a string, and the 
 class writes characters to a string. That
doesn't sound so exciting—we already know how to access and change the characters of a string. However, the string stream
classes have the same interface as the other stream classes. In particular, you can use the familiar  and 
 operators to read
and write numbers that are contained in strings. For that reasons, the 
 and 
 classes are
called adapters—they adapt strings to the stream interface. Include the 
 header when you use string streams.
Like an adapter that converts international power plugs to your outlets, the string stream adapters allow you to access
strings as streams.
iStockphoto.
Here is a typical example. Suppose the string date contains a date such as 
, and we want to separate it
into month, day, and year. First, construct an 
 object. Then use the 
 function to set the string that you
want to read:
Next, simply use the  operator to read off the month name, the day, the comma separator, and the year:
Now 
 is 
, day is 24, and 
 is 1973. Note that this input statement yields 
 and 
 as integers.
Had we taken the string apart with 
, we would have obtained only strings, not numbers.
In fact, converting strings that contain digits to their integer values is such a common operation that it is useful to write a
helper function for this purpose:
For example, 
 is the integer 1973.
By writing to a string stream, you can convert numbers to strings. First construct an 
 object:
String Streams
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:34 PM

Next, use the 
 operator to add a number to the stream. The number is converted into a sequence of characters:
Now the stream contains the string 
. To obtain that string from the stream, call the 
 member function:
You can build up more complex strings in the same way. Here we build a data string of the month, day, and year:
Now 
 is the string 
. Note that we converted the integers day and year into a string. Again,
converting an integer into a string is such a common operation that is useful to have a helper function for it:
For example, 
 is the string 
.
Self Check
16.  What is the value of  after these statements? 
17.  What does 
 return? 
18.  What does 
 return? 
19.  What is the value of 
 after these statements? 
20.  Write a function that converts a floating-point number into a string. Provide a parameter for the number of
digits after the decimal point. 
String Streams
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:34 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
String Streams
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:34 PM

Depending on the operating system and C++ development system used, there are different methods of starting a program—for
example, by selecting “Run” in the compilation environment, by clicking on an icon, or by typing the name of the program at a
prompt in a command shell window. The latter method is called “invoking the program from the command line”. When you
use this method, you must of course type the name of the program, but you can also type in additional information that the
program can use. These additional strings are called command line arguments. For example, if you start a program with the
command line
then the program receives two command line arguments: the strings 
 and 
. It is entirely up to the program
what to do with these strings. It is customary to interpret strings starting with a - as options and other strings as file names.
Programs that start from the command line can receive
the name of the program and the command line
arguments in the 
 function.
To receive command line arguments, you need to define the 
 function in a different way. You define two parameters: an
integer and an array of pointers to C character arrays.
Here 
 is the count of arguments, and 
 contains the values of the arguments. In our example, 
 is 3, and 
contains the three strings
Note that 
 is always the name of the program and that 
 is always at least 1.
Let us write a program that encrypts a file—that is, scrambles it so that it is unreadable except to those who know the
decryption method. Ignoring 2000 years of progress in the field of encryption, we will use a method familiar to Julius Caesar,
replacing A with a D, B with an E, and so on (see Figure 2).
Command Line Arguments
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:34 PM

The emperor Julius Caesar used a simple scheme to encrypt messages.
iStockphoto.
Figure 2   Caesar Cipher
The program takes the following command line arguments:
•  An optional -  flag to indicate decryption instead of encryption
•  The input file name
•  The output file name
For example,
encrypts the file 
 and places the result into 
.
decrypts the file 
 and places the result into 
.
ch08/caesar.cpp
Encrypts a stream using the Caesar cipher.
the stream to read from
the stream to write to
the encryption key
The number of files specified
Process all command-line arguments
Command Line Arguments
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:34 PM

The currently processed argument
The decryption option
It is a file name
The first file name
Exit the program if opening failed
The second file name
Exit if the user didn't specify two files
Self Check
21.  If the program is invoked with 
, what is 
, and what are the elements of
? 
22.  Trace the program when it is invoked as described in Self Check 21. 
23.  Encrypt CAESAR using the Caesar cipher. 
24.  What does the program do with spaces? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Command Line Arguments
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:34 PM

Random Fact 8.1
RANDOM FACT 8.1 Encryption Algorithms
The exercises at the end of this chapter give a few algorithms to encrypt text. Don't actually use any of those
methods to send secret messages to your lover. Any skilled cryptographer can break these schemes in a very short
time—that is, reconstruct the original text without knowing the secret keyword.
In 1978 Ron Rivest, Adi Shamir, and Leonard Adleman introduced an encryption method that is much more
powerful. The method is called RSA encryption, after the last names of its inventors. The exact scheme is too
complicated to present here, but it is not actually difficult to follow. You can find the details in
http://theory.lcs.mit.edu/~rivest/rsapaper.pdf.
RSA is a remarkable encryption method. There are two keys: a public key and a private key. (see Figure 3.) You can
print the public key on your business card (or in your e-mail signature block) and give it to anyone. Then anyone
can send you messages that only you can decrypt. Even though everyone else knows the public key, and even if they
intercept all the messages coming to you, they cannot break the scheme and actually read the messages. In 1994,
hundreds of researchers, collaborating over the Internet, cracked an RSA message encrypted with a 129-digit key.
Messages encrypted with a key of 230 digits or more are expected to be secure.
Figure 3   Public-Key Encryption
The inventors of the algorithm obtained a patent for it. A patent is a deal that society makes with an inventor. For a
period of 20 years, the inventor has an exclusive right for its commercialization, may collect royalties from others
wishing to manufacture the invention, and may even stop competitors from using it altogether. In return, the
inventor must publish the invention, so that others may learn from it, and must relinquish all claim to it after the
monopoly period ends. The presumption is that in the absence of patent law, inventors would be reluctant to go
through the trouble of inventing, or they would try to cloak their techniques to prevent others from copying their
devices.
There has been some controversy about the RSA patent. Had there not been patent protection, would the inventors
have published the method anyway, thereby giving the benefit to society without the cost of the 20-year monopoly?
In this case, the answer is probably yes. The inventors were academic researchers, who live on salaries rather than
sales receipts and are usually rewarded for their discoveries by a boost in their reputation and careers. Would their
followers have been as active in discovering (and patenting) improvements? There is no way of knowing, of
RANDOM FACT 8.1 Encryption Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:35 PM

course. Is an algorithm even patentable, or is it a mathematical fact that belongs to nobody? The patent office did
take the latter attitude for a long time. The RSA inventors and many others described their inventions in terms of
imaginary electronic devices, rather than algorithms, to circumvent that restriction. Nowadays, the patent office
will award software patents.
There is another interesting aspect to the RSA story. A programmer, Phil Zimmermann, developed a program called
PGP (for Pretty Good Privacy) that is based on RSA. Anyone can use the program to encrypt messages, and
decryption is not feasible even with the most powerful computers. You can get a copy of a free PGP
implementation from the GNU project (http://www.gnupg.org). The existence of strong encryption methods
bothers the United States government to no end. Criminals and foreign agents can send communications that the
police and intelligence agencies cannot decipher. The government considered charging Zimmermann with
breaching a law that forbids the unauthorized export of munitions, arguing that he should have known that his
program would appear on the Internet. There have been serious proposals to make it illegal for private citizens to
use these encryption methods, or to keep the keys secret from law enforcement.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 8.1 Encryption Algorithms
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:35 PM





Worked Example 8.1
WORKED EXAMPLE 8.1 Looking for for Duplicates
Your task is to write a program that reads a file and prints all lines that contain a repeated word (such as an
accidental “the the”), together with their line numbers.
Step 1  Understand the processing task.
Whenever we find a line containing a repeated word, we are to print it like this:
A word is only counted as repeated when it is the same as its predecessor. For example, a line that
contains two “the” that are not adjacent would not be reported. The words must be exactly the same.
For example, “Twinkle” and “twinkle” don't match.
Step 2  Determine which files you need to read and write.
We only need to read one file, the one with the words. The result is displayed in the console window;
no output file is required.
Step 3  Choose a method for obtaining the file names.
This is a student program with console output; we'll ask the user through the console.
Step 4  Choose between line, word, and character-based input.
We definitely want to use line-based input because we need to count line numbers and print the
entire line if it contains repeating words.
Step 5  With line-oriented input, extract the required data.
When we have an input line, we still need to extract the words. The easiest approach is to use a string
stream, and read words off that stream. We will keep a variable that holds the previous word.
For each word in the line
{
If word equals previous word
{
Found a duplicate.
}
Else
{
previous word = word
}
}
Step 6  Use functions to factor out common tasks.
In this program, there are no repeated tasks. But let's take the bigger view. Scanning lines and
printing out the ones that match a particular criterion is a fairly common task. Therefore, let's put the
checking for repeated words into a separate function,
WORKED EXAMPLE 8.1 Looking for for Duplicates
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:35 PM

Then the basic processing loop becomes very simple:
Step 7  If required, use manipulators to format the output.
There is only one formatting job: to print the line numbers so that the lines line up. Since an integer
has no more than 7 digits, we use
Here's the complete program, 
:
Checks whether a given line has repeated words (such as "the the").
a line of text
true if the line contains repeated words
This string stream reads the contents of the line
For each word in the line
Found a duplicate
Remember this word for the next iteration
WORKED EXAMPLE 8.1 Looking for for Duplicates
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:35 PM

For each line in the file
Print line if it has repeated words
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
WORKED EXAMPLE 8.1 Looking for for Duplicates
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:35 PM

In the following sections, you will learn how to read and write data at arbitrary positions in a file, and how to edit image files.
8.6.1 Random Access
So far, you've read from a file an item at a time and written to a file an item at a time, without skipping forward or backward. That
access pattern is called sequential access. In many applications, we would like to access specific items in a file without first
having to read all preceding items. This access pattern is called random access (see Figure 4). There is nothing “random” about
random access—the term means that you can read and modify any item stored at any location in the file.
Figure 4   Sequential and Random Access
You can access any position in a random access file by
moving the file pointer prior to a read or write
operation.
Only file streams support random access; the 
 and 
 streams, which are attached to the keyboard and the terminal, do not. Each
file stream has two special positions: the get position and the put position (see Figure 5). These positions determine where the next
character is read or written.
Figure 5   Get and Put Positions
The following function calls move the get and put positions to a given value, counted from the beginning of the stream.
To determine the current values of the get and put positions (counted from the beginning of the file), use
Random Access and Binary Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:35 PM

At a sit-down dinner, food is served sequentially. At a buffet, you have “random access” to all food items.
iStockphoto.
8.6.2 Binary Files
Many files, in particular those containing images and sounds, do not store information as text but as binary numbers. The numbers are
represented as sequences of bytes, just as they are in the memory of the computer. (Each byte is a value between 0 and 255.) In
binary format, a floating-point number always occupies 8 bytes. We will study random access with a binary file format for images.
We have to cover a few technical issues about binary files. To open a binary file for reading and writing, use the following command:
You read a byte with the call
This call returns a value between 0 and 255. To read an integer, read four bytes b0, b1, b2, b3 and combine them to
b0 + b1 · 256 + b2 · 2562 + b3 · 2563. We will supply a helper function for this task.
The  operator cannot be used to read numbers from a binary file.
8.6.3 Processing Image Files
In this section, you will learn how to write a program for editing image files in the BMP format. Unlike the more common GIF,
PNG, and JPEG formats, the BMP format is quite simple because it does not use data compression. As a consequence, BMP files are
huge and you will rarely find them in the wild. However, image editors can convert any image into BMP format.
There are different versions of the BMP format; we will only cover the simplest and most common one, sometimes called the 24-bit
true color format. In this format, each pixel is represented as a sequence of three bytes, one each for the blue, green, and red value.
For example, the color cyan (a mixture of blue and green) is 255 255 0, red is 0 0 255, and medium gray is 128 128 128.
A BMP file starts with a header that contains various pieces of information. We only need the following items:
Position
Item
2
The size of this file in bytes
10
The start of the image data
18
The width of the image in pixels
22
The height of the image in pixels
The image is stored as a sequence of pixel rows, starting with the pixels of the bottommost row of the image. Each pixel row
contains a sequence of blue/green/red triplets. The end of the row is padded with additional bytes so that the number of bytes in the
row is divisible by 4. (See Figure 6.) For example, if a row consisted of merely three pixels, one cyan, one red, and one medium gray
one, the row would be encoded as
x y z
Random Access and Binary Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:35 PM

where x y z are padding bytes to bring the row length up to 12, a multiple of 4. It is these little twists that make working with real-life
file formats such a joyful experience.
Figure 6   The BMP File Format for 24-bit True Color Images
The sample program at the end of this section reads every pixel of a BMP file and replaces it with its negative, turning white to black,
cyan to red, and so on. The result is a negative image of the kind that old-fashioned film cameras used to produce (see Figure 7). To
try out this program, take one of your favorite images, use an image editor to convert to BMP format (or use 
from the sample files for this book), then run the program and view the transformed file in an image editor. Exercises P8.21 and
P8.22 ask you to produce more interesting effects.
Figure 7   An Image and Its Negative
Cay Horstmann.
Random Access and Binary Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:35 PM

ch08/imagemod.cpp
 
Processes a pixel by forming the negative.
the blue value of the pixel
the green value of the pixel
the red value of the pixel
Gets an integer from a binary stream.
the stream
the offset at which to read the integer
the integer starting at the given offset
Open as a binary file
Get the image dimensions
Scan lines must occupy multiples of four bytes
Random Access and Binary Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:35 PM

Go to the start of the pixels
For each scan line
For each pixel
Go to the start of the pixel
Read the pixel
Process the pixel
Go back to the start of the pixel
Write the pixel
Skip the padding
Self Check
25.  In plain English, what does the following code segment do? 
26.  How would you modify the 
 program to flip the green and blue values of each pixel for a
psychedelic effect? 
27.  What happens if you run the 
 program twice on the same image file? 
28.  Could we have implemented the image modification program with sequential access only? If not, why not?
29.  Suppose a BMP file stores a 100 × 100 pixel image in BMP format, with the image data starting at offset 64. What
is the total file size? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Random Access and Binary Files
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:35 PM

Random Fact 8.2
RANDOM FACT 8.2 Databases and Privacy
Most companies use computers to keep huge data files of customer records and other business information.
Databases not only lower the cost of doing business; they improve the quality of service that companies can offer.
Nowadays it is almost unimaginable how time-consuming it used to be to withdraw money from a bank branch or
to make travel reservations.
Today most databases are organized according to the relational model. Suppose a company stores your orders and
payments. They will probably not repeat your name and address on every order; that would take unnecessary space.
Instead, they will keep one file of all their customer names and identify each customer by a unique customer
number.Only that customer number, not the entire customer information, is kept with an order record. (See Figure
8.)
Figure 8   Relational Database Files
To print an invoice, the database program must issue a query against both the customer and order files and pull the
necessary information (name, address, articles ordered) from both. Frequently, queries involve more than two files.
For example, the company may have a file of addresses of car owners and a file of people with good payment
history and may want to find all of its customers who placed an order in the last month, drive an expensive car, and
pay their bills, so they can send them another catalog. This kind of query is, of course, much faster if all customer
files use the same key, which is why so many organizations in the United States try to collect the Social Security
numbers of their customers.
The Social Security Act of 1935 provided that each contributor be assigned a Social Security number to track
RANDOM FACT 8.2 Databases and Privacy
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:36 PM

contributions into the Social Security Fund. These numbers have a distinctive format, such as 078-05-1120. (This
particular number was printed on sample cards that were inserted in wallets. It actually was the Social Security
number of the secretary of a vice president at the wallet manufacturer. When thousands of people used it as their
own, the number was voided, and the secretary received a new number.) Figure 9 shows a Social Security card.
Although they had not originally been intended for use as a universal identification number, Social Security
numbers have become just that.
Figure 9   Social Security Card
Some people are very concerned about the fact that just about every organization wants to store their Social
Security number and other personal information. There is the possibility that companies and the government can
merge multiple databases and derive information about us that we may wish they did not have or that simply may
be untrue. An insurance company may deny coverage, or charge a higher premium, if it finds that you have too
many relatives with a certain disease. You may be denied a job because of an inaccurate credit or medical report,
and you may not even know the reason. These are very disturbing developments that have had a very negative
impact for a small but growing number of people.
In many industrialized countries (but not currently in the United States), citizens have a right to control what
information about themselves should be communicated to others and under what circumstances.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 8.2 Databases and Privacy
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:36 PM

1.  To read or write disk files, you use variables of type 
, 
, or 
.
age fotostock/SUPERSTOCK.
2.  When opening a file stream, you supply the name of the disk file.
3.  Read from a file stream with the same operations that you use with 
.
4.  Write to a file stream with the same operations that you use with 
.
5.  Always use a reference parameter for a stream.
6.  You can get individual characters from a stream and unget the last one.
age fotostock/SUPERSTOCK.
7.  Control stream formatting with manipulators.
iStockphoto.
8.  Use string streams to read numbers that are contained in strings, or to convert between numbers and strings.
iStockphoto.
9.  Programs that start from the command line can receive the name of the program and the command line arguments in
the 
 function.
10.  You can access any position in a random access file by moving the file pointer prior to a read or write operation.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:36 PM

iStockphoto.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:36 PM

Exercise R8.1.    
When do you open a file as an 
, as an 
, or as an 
 Could you simply open all files as an
Exercise R8.2.    
What happens if you write to a file that you only opened for reading? Try it out if you don't know.
Exercise R8.3.    
What happens if you try to open a file for reading that doesn't exist? What happens if you try to open a file for writing that
doesn't exist?
Exercise R8.4.    
What happens if you try to open a file for writing, but the file or device is write-protected (sometimes called read-only)?
Try it out with a short test program.
Exercise R8.5.    
How do you open a file whose name contains a backslash, such as 
 or 
?
Exercise R8.6.    
Why is the 
 parameter of the 
 function in Section 8.1.4 a reference parameter and not a value
parameter?
Exercise R8.7.    
How can you convert the string 
 into the floating-point number 3.14? How can you convert the floating-point
number 3.14 into the string 
?
Exercise R8.8.    
What is a command line? How can a program read its command line?
Exercise R8.9.    
If a program 
 is started with the command
what is the value of 
, and what are the values of 
, and so on?
Exercise R8.10.    
What is the difference between sequential access and random access?
Exercise R8.11.    
What is the difference between a text file and a binary file?
Exercise R8.12.    
What are the get and put positions in a file? How do you move them? How do you tell their current positions?
Exercise R8.13.    
What happens if you try to move the get or put position past the end of a file? What happens if you try to move the get or
put position of cin or cout? Try it out and report your results.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:36 PM

Exercise P8.1.    
Write a program that carries out the following tasks:
Open a file with the name hello.txt
Store the message "Hello, World!" in the file
Close the file
Open the same file again
Read the message into a string variable and print it
Exercise P8.2.    
Write a program that reads a file containing floating-point numbers. Print the average of the numbers in the file. Prompt the user for the file name.
Exercise P8.3.    
Repeat Exercise P8.2., but allow the user to specify the file name on the command-line. If the user doesn't specify any file name, then prompt the user for the name.
Exercise P8.4.    
Write a program that reads a file containing two columns of floating-point numbers. Prompt the user for the file name. Print the average of each column.
Exercise P8.5.    
Write a program 
 that searches all files specified on the command line and prints out all lines containing a keyword. For example, if you call
then the program might print
The keyword is always the first command-line argument.
Exercise P8.6.    
Write a program that checks the spelling of all words in a file. It should read each word of a file and check whether it is contained in a word list. A word list is
available on most UNIX systems (including Linux and Mac OS X) in the file 
. (If you don't have access to a UNIX system, you can find a
copy of the file on the Internet by searching for 
.) The program should print out all words that it cannot find in the word list. Follow this
pseudocode:
Open the dictionary file
Define a vector of strings called words
For each word in the dictionary file
{
Append the word to the words vector
}
Open the file to be checked
For each word in that file
{
If the word is not contained in the words vector
{
Print the word
}
}
Exercise P8.7.    
Write a program that reads each line in a file, reverses its characters, and writes the resulting line to another file. For example, if the file input.txt contains the lines
and you run
then 
 contains
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:36 PM

Exercise P8.8.    
Write a program that reads each line in a file, reverses its characters, and writes the resulting line to the same file. Use the following pseudocode:
While the end of the file has not been reached
{
pos1 = current get position
Read a line.
If the line was successfully read
{
pos2 = current get position
Set put position to pos1.
Write the reversed line.
Set get position to pos2.
}
}
Exercise P8.9.    
Write a program that reads each line in a file, reverses its lines, and writes them to another file. For example, if the file 
 contains the lines
and you run
then 
 contains
Exercise P8.10.    
Get the data for names in prior decades from the Social Security Administration. Paste the table data in files named 
, etc. Modify the
 program so that it prompts the user for a file name. The numbers in the files have comma separators, so modify the program to handle them. Can
you spot a trend in the frequencies?
Exercise P8.11.    
Write a program that reads in 
 and produces two files 
 and 
 separating the data for the boys and girls.
Exercise P8.12.    
Write a program that reads a file in the same format as 
 and prints all names that are both boy and girl names (such as Alexis or Morgan).
Exercise P8.13.    
Write a program that reads the country data in the file 
 (included with the book code). Do not edit the file. Use the following algorithm for processing
each line. Add non-white space characters to the country name. When you encounter a white space, locate the next non-white space character. If it is not a digit, add a
space and that character to the country name. Otherwise unget it and read the number. Print the total of all country populations (excepting the entries for “World” and
“European Union”) and compare it with the entry for “World.”
Exercise P8.14.    
Write a program that asks the user for a file name and displays the number of characters, words, and lines in that file. Then have the program ask for the name of the
next file. When the user enters a file that doesn't exist (such as the empty string), the program should exit.
Exercise P8.15.    
Write a program 
 that copies one file to another. The file names are specified on the command line. For example,
Exercise P8.16.    
Write a program that concatenates the contents of several files into one file. For example,
makes a long file 
 that contains the contents of the files 
, 
, and 
. The target file is always the last file
specified on the command line.
Exercise P8.17.    
Random monoalphabet cipher. The Caesar cipher, which shifts all letters by a fixed amount, is far too easy to crack. Here is a better idea. As the key, don't use
numbers but words. Suppose the key word is 
 Then first remove duplicate letters, yielding 
 and append the other letters of the alphabet in reverse
order:
Now encrypt the letters as follows:
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:36 PM

Write a program that encrypts or decrypts a file using this cipher. For example,
decrypts a file using the keyword 
. It is an error not to supply a keyword.
Exercise P8.18.    
Letter frequencies. If you encrypt a file using the cipher of Exercise P8.17., it will have all of its letters jumbled up, and will look as if there is no hope of decrypting
it without knowing the keyword. Guessing the keyword seems hopeless too. There are just too many possible keywords. However, someone who is trained in
decryption will be able to break this cipher in no time at all. The average letter frequencies of English letters are well known. The most common letter is E, which
occurs about 13 percent of the time. Here are the average frequencies of the letters.
A
8%
H
4%
O
7%
U
3%
B
<1%
I
7%
P
3%
V
<1%
C
3%
J
<1%
Q
<1%
W
2%
D
4%
K
<1%
R
8%
X
<1%
E
13%
L
4%
S
6%
Y
2%
F
3%
M
3%
T
9%
Z
<1%
G
2%
N
8%
 
 
 
 
Write a program that reads an input file and displays the letter frequencies in that file. Such a tool will help a code breaker. If the most frequent letters in an encrypted
file are H and K, then there is an excellent chance that they are the encryptions of E and T.
Exercise P8.19.    
Vigenère cipher. In order to defeat a simple letter frequency analysis, the Vigenère cipher encodes a letter into one of several cipher letters, depending on its position
in the input document. Choose a keyword, for example TIGER. Then encode the first letter of the input text like this:
The encoded alphabet is just the regular alphabet shifted to start at , the first letter of the keyword 
. The second letter is encrypted according to the following
map.
The third, fourth, and fifth letters in the input text are encrypted using the alphabet sequences beginning with characters , , and , and so on. Because the key is only
five letters long, the sixth letter of the input text is encrypted in the same way as the first.
Write a program that encrypts or decrypts an input text according to this cipher.
Exercise P8.20.    
Playfair cipher. Another way of thwarting a simple letter frequency analysis of an encrypted text is to encrypt pairs of letters together. A simple scheme to do this is
the Playfair cipher. You pick a keyword and remove duplicate letters from it. Then you fill the keyword, and the remaining letters of the alphabet, into a 5 × 5 square.
(Since there are only 25 squares, I and J are considered the same letter.)
Here is such an arrangement with the keyword 
.
To encrypt a letter pair, say , look at the rectangle with corners  and :
The encoding of this pair is formed by looking at the other two corners of the rectangle, in this case, 
. If both letters happen to be in the same row or column, such
as , simply swap the two letters. Decryption is done in the same way.
Write a program that encrypts or decrypts an input text according to this cipher.
Exercise P8.21.    
Write a program that edits an image file and reduces the blue and green values by 30 percent, giving it a “sunset” effect.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:36 PM

Cay Horstmann.
Exercise P8.22.    
Write a program that edits an image file, turning it into grayscale.
Cay Horstmann.
Replace each pixel with a pixel that has the same grayness level for the blue, green, and red component. The grayness level is computed by adding 30 percent of the red
level, 59 percent of the green level and 11 percent of the blue level. (The color-sensing cone cells in the human eye differ in their sensitivity for red, green, and blue
light.)
Exercise P8.23.    
Junk mail. Write a program that reads in two files: a template and a database. The template file contains text and tags. The tags have the form 
… and
need to be replaced with the first, second, third, … field in the current database record.
A typical database looks like this:
And here is a typical form letter:
Exercise P8.24.    
Write a program that manipulates three database files. The first file contains the names and telephone numbers of a group of people. The second file contains the
names and Social Security numbers of a group of people. The third file contains the Social Security numbers and annual salaries of a group of people. The groups of
people should overlap but need not be completely identical. Your program should ask the user for a telephone number and then print the name, Social Security
number, and annual income, if it can determine that information.
Exercise P8.25.    
Write a program that prints out a student grade report. There is a file, 
, that contains the names of all classes taught at a college, such as
classes.txt
For each class, there is a file with student ID numbers and grades:
csc2.txt
Write a program that asks for a student ID and prints out a grade report for that student, by searching all class files. Here is a sample report
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:36 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:36 PM

1.  The stream will be in a failed state since there is no file with an empty name.
2.  The stream variable is declared as an input stream. It should have been an 
3.  The stream is not passed by reference.
4.  Initialize 
 and 
 with 10.
5.  Add the following code to the beginning of 
:
Change every 
 to 
.
Add an 
 parameter of type 
 to 
.
6.  
 is 6 because the comma is not recognized as a part of the number. 
 is 
.
7.  
 is 
 (including the !) and 
 is 
.
8.  
9.  The loop skips a sequence of white space.
10.  Some country names (such as United States) consist of multiple words.
11.  
, because the default precision is 6.
12.  
;
13.  
14.  
15.  Because the 
 command only affects the first output.
16.  123456
17.  123
18.  0
19.  3.3333. Note that in general format, the precision denotes the total number of digits, not the number of digits after the
decimal point.
20.  
21.  
 is 3, and 
 contains the strings 
, and 
.
22.  
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:37 PM

Then the program prints a message
and exits.
23.  FDHVDU
24.  It turns them into # characters. The ASCII code for a space is 32, and the # character has code 35.
25.  It replaces the initial byte of a file with 0.
26.  Change the 
 function to swap the values of the 
 and 
 parameters. The remainder of the program
stays unchanged.
27.  You get the original image back.
28.  We could have read the header values and pixel data sequentially, but to update the pixels, we had to move backwards.
29.  We need 3 × 100 bytes for each scan line. There is no padding since this number is divisible by 4. The total
size = 3 × 100 × 100 + 64 = 30,064 bytes.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:37 PM

Worked Example 8.1
•
Looking for for Duplicates
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Looking for for Duplicates
Your task is to write a program that reads a ﬁle and prints all lines that contain a repeated
word (such as an accidental “the the”), together with their line numbers. 
Step 1
Understand the processing task.
Whenever we ﬁnd a line containing a repeated word, we are to print it like this: 
    360:bat?' when suddenly, thump! thump! down she came upon a heap of 
   2103:'Twinkle, twinkle, twinkle, twinkle--' and went on so long that
A word is only counted as repeated when it is the same as its predecessor. For example, a line
that contains two “the” that are not adjacent would not be reported. The words must be
exactly the same. For example, “Twinkle” and “twinkle” don’t match. 
Step 2
Determine which ﬁles you need to read and write.
We only need to read one ﬁle, the one with the words. The result is displayed in the console
window; no output ﬁle is required.
Step 3
Choose a method for obtaining the ﬁle names.
This is a student program with console output; we’ll ask the user through the console.
Step 4
Choose between line, word, and character-based input.
We deﬁnitely want to use line-based input because we need to count line numbers and print
the entire line if it contains repeating words.
Step 5
With line-oriented input, extract the required data.
When we have an input line, we still need to extract the words. The easiest approach is to use
a string stream, and read words off that stream. We will keep a variable that holds the previ-
ous word. 
For each word in the line
{
If word equals previous word
{
Found a duplicate.
}
Else
{
previous word = word
}
}
Step 6
Use functions to factor out common tasks.
In this program, there are no repeated tasks. But let’s take the bigger view. Scanning lines and
printing out the ones that match a particular criterion is a fairly common task. Therefore,
let’s put the checking for repeated words into a separate function, 
bool has_repeated_words(string line)
WORKED EXAMPLE 8.1

2
C++ for Everyone  •  CHAPTER 8
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Then the basic processing loop becomes very simple:
string line;
int line_number = 0;
while (getline(in_file, line))
{
   line_number++;
   if (has_repeated_words(line))
   {
      cout << setw(7) << line_number << ":" << line << endl;
   }
}
Step 7
If required, use manipulators to format the output.
There is only one formatting job: to print the line numbers so that the lines line up. Since an
integer has no more than 7 digits, we use 
cout << setw(7) << line_number << ":" << line << endl;
Here’s the complete program, ch08/repeated.cpp:
#include <fstream>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <string>
using namespace std;
/**
   Checks whether a given line has repeated words (such as “the the”).
   @param line a line of text
   @return true if the line contains repeated words
*/
bool has_repeated_words(string line)
{
   istringstream strm;
   strm.str(line); // This string stream reads the contents of the line
   string previous_word = "";
   string word; 
   while (strm >> word) // For each word in the line
   {
      if (word == previous_word) // Found a duplicate
      {
         return true;
      }
      else // Remember this word for the next iteration
      {
         previous_word = word;
      }
   }
   return false;
}

Worked Example 8.1
•
Looking for for Duplicates
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
int main()
{
   string filename;
   cout << "Enter filename: ";
   cin >> filename;
   ifstream in_file;
   in_file.open(filename.c_str());
   
   int line_number = 0;
   string line;
   while (getline(in_file, line)) // For each line in the ﬁle
   {
      line_number++;
      // Print line if it has repeated words
      if (has_repeated_words(line)) 
      {
         cout << setw(7) << line_number << ":" << line << endl;
      }
   }
   return 0;
}

Chapter
   
    
    
Chapter Goals
•  To be able to implement your own classes
•  To master the separation of interface and implementation
•  To understand the concept of encapsulation
•  To design and implement accessor and mutator member functions
•  To understand object construction
•  To learn how to distribute a program over multiple source files
At this point, you are familiar with using objects from the 
 class and the stream classes. You have learned
how to work with these objects by using member functions—functions that are called with the dot notation.
In this chapter you will learn how to implement your own classes. You will see how to design classes that help
you solve programming problems, and you will study the mechanics of defining classes, constructors, and member
functions.
Chapter Goals To be able to ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:37 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To be able to ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:37 PM

You have learned how to structure your programs by decomposing tasks into functions. This is an excellent practice, but
experience shows that it does not go far enough. As programs get larger, it becomes increasingly difficult to maintain a large
collection of functions. It is common for larger programs to use a set of global variables that are manipulated by many
functions. Because every function is able to change any of the global variables, diagnosing errors and managing changes
becomes a challenge. Whenever some part of the global data is to be changed to improve performance or to add new
capabilities, a large number of functions may be affected, making program modifications expensive or impractical (see Figure
1.).
Figure 1   A Program Using Functions
An object holds data members that are accessed by
member functions.
To overcome this problem, computer scientists invented object-oriented programming, a programming style in which
tasks are solved by collaborating objects. An object has a set of variables (which are called data members) and functions that
can act upon them (which are called member functions). The data members are encapsulated—hidden from other parts of the
program and accessible only through their own member functions (Figure 2). When we want to change the way that an object
is implemented, only a small number of functions need to be updated. Program evolution becomes much more manageable.
Because most real-world programs need to be updated often during their lifetime, this is an important advantage of object-
oriented programming.
Object-Oriented Programming
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:38 PM

Figure 2   An Object-Oriented Program
Encapsulation is the act of hiding implementation
details.
Consider your own experience with using string or stream objects. When you access an object, you do not know its data
members. Encapsulation means that they are hidden from you. You can only access the object through its member functions.
You need not know how a string organizes a character sequence, or how a stream communicates with a file. You simply call
member functions such as 
, or an operator such as 
 or 
 . (These operators are also implemented as functions—see
Advanced Topic 9.2 on page 386).
You can drive a car by operating the steering wheel and pedals, without knowing how the engine works. Similarly, you use
an object through its member functions. The implementation is hidden.
Damir Cudic/iStockphoto.
Encapsulation benefits the programmer who uses an object. That programmer only needs to know about the set of functions
that can be invoked on the objects. It is also a benefit for the programmer who implements objects. That programmer is able to
choose a more efficient implementation without impacting the object user.
Object-Oriented Programming
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:38 PM

In C++, a programmer doesn't implement a single object. Instead, the programmer implements a class. A class describes a set
of objects with the same behavior. To define a class, you must specify the behavior by providing implementations for the
member functions, and by defining the data members for the objects. We will discuss this process in the following sections.
A class describes a set of objects with the same
behaviour.
When classifying real-life objects, you can group together objects with the same behavior. For example, a Car class
describes all passenger vehicles that have a certain capacity and shape.
Michael Shake/iStockphoto.
Self Check
1.  Suppose a program consists of 1,000 functions, and one of the global data items has been set to the wrong
value. How many functions could have caused the error? Suppose the program is instead implemented using
100 objects, each having 10 member functions. If a data member has been set to the wrong value, how many
functions could have caused the error? 
2.  In C++, is 
 an object or a class? Is 
 an object or a class? 
3.  When using a 
 object, you do not know how it stores its characters. How can you access them?
4.  Describe two possible ways in which a 
 object might store its characters. 
5.  Suppose the providers of your C++ compiler decide to change the way that a 
 object stores its
characters, and they update the 
 member functions accordingly. Which parts of your code do you need
to change when you get the new compiler? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Object-Oriented Programming
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:38 PM

To define a class, we first need to specify its public interface. The interface of a class consists of all functions that we want
to apply to its objects.
Every class has a public interface: collection of
member functions through which the objects of the
class can be manipulated.
Our first example of a class simulates a cash register.
James Richey/iStockphoto.
Let's consider a simple example. We want to use objects that simulate cash registers. A cashier who rings up a sale presses a
key to start the sale, then rings up each item. A display shows the amount owed as well as the total number of items purchased.
In our simulation, we want to call the following member functions on a cash register object:
•  Clear the cash register to start a new sale.
•  Add the price of an item.
•  Get the total amount owed, and the count of items purchased.
The interface is specified in the class definition, summarized in Syntax 9.1 on page 372. We will call our class
. (We follow the convention that the name of a programmer-defined class starts with an uppercase letter, as
does each word within the name. This naming convention is called camel case because the uppercase letters in the middle of
the name look like the humps of a camel.)
Eric Isselée/iStockphoto.
Interfaces
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:38 PM

Here is the C++ syntax for the 
 class definition:
data members—see section 9.3
The member functions are declared in the public section of the class. Any part of the program can call the member functions.
The data members are defined in the private section of the class. Only the member functions of the class can access those data
members; they are hidden from the remainder of the program.
The member function declarations look similar to the declarations of regular functions. These declarations do not provide any
implementation. You will see in Section 9.4 how to implement the member functions.
Member functions are invoked using the dot notation that you have already seen with string and stream functions:
 // Defines a 
 object
 // Invokes a member function
There are two kind of member functions, called mutators and accessors. A mutator is a function that modifies the data
members of the object. The 
 class has two mutators: 
 and 
. After you call either of these
functions, the amount due and item count are changed.
A mutator member function changes the object on
which it operates.
Accessors just query the object for some information without changing it. The 
 class has two accessors:
 and 
. Applying either of these functions to a 
 object simply returns a value and does not
modify the object. In C++, you should use the 
 reserved word to mark accessor functions (see Quality Tip 9.2 on page
382), like this:
Now we know what a 
 object can do, but not how it does it. Of course, to use 
 objects in
our programs, we don,t need to know. We simply use the public interface. Figure 3 shows the interface of the 
class. The mutator functions are shown with arrows pointing inside the private data to indicate that they modify the data. The
accessor functions are shown with arrows pointing the other way to indicate that they just read the data.
Figure 3   The Interface of the 
 Class
An accessor member function does not change the
object on which it operates. Use 
 with accessors.
Interfaces
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:38 PM

Self Check
6.  What does the following code segment print? 
7.  What is wrong with the following code segment? 
8.  Declare a member function 
 of the 
 class that yields the dollar value of the
total amount of the sale. 
9.  Name two accessor member functions of the 
 class. 
10.  Is the 
 member function of the 
 class an accessor or a mutator? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Interfaces
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:38 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 9.1 Class Interface
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:38 PM

Common Error 9.1
COMMON ERROR 9.1 Forgetting a Semicolon
Braces { } are common in C++ code, and usually you do not place a semicolon after the closing brace. However,
class definitions always end in };. A common error is to forget that semicolon:
Forgot semicolon
Many compilers report the error in this line
This error can be extremely confusing to many compilers. There is syntax, now obsolete but supported for
compatibility with old code, to define class types and variables of that type simultaneously. Because the compiler
doesn't know that you don't use that obsolete construction, it tries to analyze the code wrongly and ultimately
reports an error. Unfortunately, it may report the error several lines away from the line in which you forgot the
semicolon.
If the compiler reports bizarre errors in lines that you are sure are correct, check that each of the preceding class
definitions is terminated by a semicolon.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 9.1 Forgetting a Semicolon
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:38 PM

Each 
 object must store the total price and item count of the sale that is currently rung up. We have to choose
an appropriate data representation. In our example, we simply store the total price and the item count. (Different data
representations are explored in Exercise P9.1. and Exercise P9.2.)
The data members are defined in the private section of the class definition.
See Section 9.2
A driver of an electric car doesn't have to learn new controls even though the car engine is very different. Neither does the
programmer who uses an object with an improved implementation—as long as the same member functions are used.
Photo by Gary Lee/UPPA/Zuma Press. © Copyright 2006 by UPPA.
Every 
 object has a separate copy of these data members (Figure 4).
Encapsulation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:39 PM

Figure 4   Data Members of 
 Objects
Every object has its own set data members.
Because the data members are defined to be private, only the member functions of the class can access them. Programmers
using the 
 class cannot access the data members directly:
Error—use
 instead
All data access must occur through the public interface. Thus, the data members of an object are effectively hidden from the
programmer using the class. While it is theoretically possible in C++ to leave data members unencapsulated (by placing them
into the public section), this is very uncommon in practice. We will always make all data members private in this book.
Private data memebers can only be accessed by member
functions of the same class.
The 
 class is so simple that it is not obvious what benefit we gain from the encapsulation.
By keeping the implementation private, we product it
from being accidently corrupted.
One benefit of the encapsulation mechanism is the guarantee that the object data cannot accidentally be put in an incorrect
state. For example, we can be assured that 
 cannot be set to a negative value. There are only two functions that can
change the value, the 
 and 
 mutators. As you will see in the next section, these functions will never let
 be negative. Since no other function can touch the private data members, we can guarantee that their values are
always valid, thanks to the encapsulation mechanism.
Encapsulation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:39 PM

Encapsulation enables changes in the implementation
without affecting users of a class.
There is a second benefit of encapsulation that is particularly important in larger programs. Typically, implementation details
need to change over time. You want to be able to make your classes more efficient or more capable, without affecting the
programmers that use your classes. As long as those programmers do not depend on the implementation details, you are free to
change them at any time.
Self Check
11.  What is the value of 
,
and 
 after these statements? 
12.  What is wrong with this code segment? 
13.  Consider a class 
 that represents a point in time, such as 9 A.M. or 3:30 P.M. Give two different sets of
data members that can be used for implementing the 
 class. 
14.  Suppose the implementor of the 
 class changes from one implementation strategy to another, keeping
the public interface unchanged. What do the programmers who use the 
 class need to do? 
15.  Consider a class 
 that represents a letter grade, such as 
 or . Give two different sets of data
members that can be used for implementing the 
 class. 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Encapsulation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:39 PM

The definition of a class declares its member functions. Each member function is defined separately, after the class definition.
The following sections show how to define member functions.
9.4.1 Implementing Member Functions
Here is the implementation of the 
 function of the 
 class.
The 
 prefix makes it clear that we are defining the 
 function of the 
 class. In
C++ it is perfectly legal to have 
 functions in other classes as well, and it is important to specify exactly which
 function we are defining. (See Syntax 9.2 page 379.) You use the ClassName::
 syntax only when
defining the function, not when calling it. When you call the 
 member function, the call has the form
object.
(…).
Use the ClassName:: prefix when defining member
functions.
When defining an accessor member function, supply the reserved word const following the closing parenthesis of the
parameter list. Here is the 
 member function:
You will find the other member functions with the sample program at the end of this section.
9.4.2 Implict and Explicit Parameters
Whenever you refer to a data member, such as 
 or 
, in a member function, it denotes that data
member of the object on which the member function was invoked. For example, consider the call
The first statement in the 
 function is
Which 
 is incremented? In this call, it is the 
 of the 
 object. (See Figure 5.)
Member Function
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:39 PM

Figure 5   Implicit and Explicit Parameters
The object on which a member function is invoked is called the implicit parameter of the member function.
The object on which a member function is applied is
the implict parameter.
You can think of the code of the 
 function like this:
implicit parameter
implicit parameter
implicit parameter
In C++, you do not actually write the implicit parameter in the function definition. For that reason, the parameter is called
“implicit”.
In contrast, parameters that are explicitly mentioned in the function definition, such as the price parameter, are called explicit
parameters. Every member function has exactly one implicit parameter and zero or more explicit parameters.
Explicit parameters of a member function are listed in
the function definition.
9.4.3 Calling a Member Function from a Member Function
When one member function calls another member function on the same object, you do not use the dot notation. Instead, you
Member Function
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:39 PM

simply use the name of the other function. Here is an example. Suppose we want to implement a member function to add
multiple instances of the same item. An easy way to implement this function is to repeatedly call the 
 function:
implicit parameter
That parameter is the object on which the 
 function is invoked. For example, in the call
the 
 is invoked six times on 
.
When calling another member function on the same
object, do not use the dot notation.
ch09/registertest1.cpp
A simulated cash register that tracks the item count and
the total amount due.
Clears the item count and the total.
Adds an item to this cash register.
the price of this item
the total amount of the current sale
Member Function
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:39 PM

the item count of the current sale
Displays the item count and total price of a cash register.
the cash register to display
Program Run
Member Function
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:39 PM

Self Check
16.  What is wrong with this implementation of the 
 member function? 
17.  Implement the 
 member function described in Section 9.4.3 without calling 
.
18.  Implement a member function 
 of the 
 class that yields the amount of the
total sale as a dollar value without the cents. 
19.  Consider the 
 member function of the 
 class. How many parameters does it have, and what are
their types? 
20.  Consider the 
 member function of the 
 class. How many parameters does it have, and what
are their types? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Member Function
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:39 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
SYNTAX 9.2 Member Function Definition
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:39 PM

Quality Tip 9.1
QUALITY TIP 9.1 All Data Members Should Be Private; Most Member
Functions Should Be Public
It is possible to define data members in the public section of a class, but you should not do that in your own code.
Always use encapsulation, with private data members that are manipulated with member functions.
Generally, member functions should be public. However, sometimes you have a member function that is only used
as a helper function by other member functions. In that case, you can make the helper function private. Simply
declare it in the private section of the class.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 9.1 All Data Members Should Be Private; Most Member ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:40 PM

Quality Tip 9.2
QUALITY TIP 9.2 
 Correctness
You should declare all accessor functions in C++ with the 
 reserved word. (Recall that an accessor function
is a member function that does not modify its implicit parameter.)
For example, suppose you design the following class:
Bad style—no 
When you compile your code, no error is reported. But now suppose that another programmer uses your
 class in a function
That programmer is conscientious and declares the 
 parameter as 
. But then the call
 will not compile. Because 
 is not tagged as
, the compiler suspects that the call 
 may modify 
. But the
function promised not to modify the 
 array.
If you write a program with other team members who are conscientious about 
, it is very important that you
do your part as well. You should therefore get into the habit of using 
 with all accessor member functions.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 9.2 const Correctness
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:40 PM

A constructor is a member function that initializes the data members of an object. The constructor is automatically called
whenever an object is created. By supplying a constructor, you can ensure that all data members are properly set before any
member functions act on an object.
A constructor is called automatically whenever an
object is created.
To understand the importance of constructors, consider the following statements:
 // May not be 1
Here, the programmer forgot to call 
 before adding items. Therefore, the data members of the 
 object were
initialized with random values. Constructors guarantee that an object is always fully initialized when it is defined.
The name of a constructor is the same as the class
name.
The name of a constructor is identical to the name of its class. You declare constructors in the class definition, for example:
A constructor
Constructors never return values, but you do not use the 
 reserved word when declaring them.
Here is the definition of that constructor:
Constructors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:40 PM

A constructor is like a set of assembly instructions for an object.
Ann Marie Kurtz/iStockphoto.
In the constructor definition, the first 
 (before the ::) indicates that we are about to define a member function
of the 
 class. The second 
 is the name of that member function.
A default constructor has no parameters.
The constructor that you just saw has no parameters. Such a constructor is called a default constructor. It is used whenever
you define an object and do not specify any parameters for the construction. For example, if you define
then the default constructor is called. It sets 
 and 
 to zero.
A class can have multiple constructors.
Many classes have more than one constructor. This allows you to define objects in different ways. Consider for example a
 class that has two constructors:
Sets balance to 0
Sets balance to
Member functions omitted
Both constructors have the same name as the class, 
. But the default constructor has no parameters, whereas the
second constructor has a 
 parameter.
The complier picks the constructor that matches the
constructor parameters.
When you construct an object, the compiler chooses the constructor that matches the parameters that you supply. For example,
Constructors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:40 PM

Uses default constructor
Uses 
 constructor
When implementing a constructor, you need to pay particular attention to all data members that are numbers or pointers. These
types are not classes and therefore have no constructors. If you have a data member that is an object of a class (such as a
 object), then that class has a constructor, and the object will be initialized. For example, all 
 objects are
automatically initialized to the empty string. Consider this class:
Additional member functions omitted
In the 
 constructor, you need to set 
 to 0, but you need not initialize the 
 data member. It is
automatically initialized to the empty string.
If you do not supply any constructor for a class, the compiler automatically generates a default constructor that initializes all
data members of class type with their default constructors.
Self Check
21.  Provide an implementation for the default constructor of the 
 class. 
22.  Provide an implementation for the 
 constructor. 
23.  Provide an implementation for the default constructor of the 
. 
24.  Provide an implementation for the default constructor of the 
 class that calls the 
member function. 
25.  Which constructor is called in each of the following definitions? 
(a)  
(b)  
(c)  
(d)  
(e)  
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Constructors
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:40 PM

Common Error 9.2
COMMON ERROR 9.2 Trying to Call a Constructor
The constructor is invoked only when an object is first created. You cannot invoke it again. For example, you
cannot call the constructor to clear an object:
Error
It is true that the default constructor sets a new 
 object to the cleared state, but you cannot invoke
a constructor on an existing object.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 9.2 Trying to Call a Constructor
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:40 PM

Advanced Topic 9.1
ADVANCED TOPIC 9.1 Initializer Lists
When you construct an object whose data members are themselves objects, those objects are constructed by their
class's default constructor. However, if a data member belongs to a class without a default constructor, you need to
invoke the member's constructor explicitly. Here is an example.
This 
 class has no default constructor.
No other constructors
This 
 class has a data member of type 
.
The 
 constructor must call the 
 constructor. That is achieved with an initializer list. The initializer list is
placed before the opening brace of the constructor. The list starts with a colon and contains names of data members
with their construction parameters.
Initializers are separated by commas. The 
 constructor can also be written like this:
ADVANCED TOPIC 9.1 Initializer Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:40 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 9.1 Initializer Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:40 PM

Advanced Topic 9.2
ADVANCED TOPIC 9.2 Overloading
When the same function name is used for more than one function, then the name is overloaded. In C++ you can
overload function names provided the parameter types are different. For example, you can define two functions,
both called 
When the 
 function is called,
the compiler looks at the type of . If  is a 
 object, the first function is called. If  is an 
, the second function is called. If  is neither, the compiler generates an error.
We have not used the overloading feature in this book. Instead, we gave each function a unique name, such as
 or 
. However, we have no choice with constructors. C++ demands that the name of
a constructor equal the name of the class. If a class has more than one constructor, then that name must be
overloaded.
In addition to name overloading, C++ also supports operator overloading. It is possible to give new meanings to
the familiar C++ operators such as +, ==, and << . This is an advanced technique that we do not discuss in this
book.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 9.2 Overloading
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:41 PM

How To 9.1
HOW TO 9.1 Implementing a Class
A very common task is to implement a class whose objects can carry out a set of specified actions. This How To
walks you through the necessary steps.
As an example, consider a class 
. An object of this class can display a menu such as
Then the menu waits for the user to supply a value. If the user does not supply a valid value, the menu is
redisplayed, and the user can try again.
Step 1  Get an informal list of the responsibilities of your objects.
Be careful that you restrict yourself to features that are actually required in the problem. With
real-world items, such as cash registers or bank accounts, there are potentially dozens of features
that might be worth implementing. But your job is not to faithfully model the real world. You need
to determine only those responsibilities that you need for solving your specific problem.
In the case of the menu, you need to
Display the menu
Get user input
Now look for hidden responsibilities that aren't part of the problem description. How do objects get
created? Which mundane activities need to happen, such as clearing the cash register at the beginning
of each sale?
In the menu example, consider how a menu is produced. The programmer creates an empty menu
object and then adds options “Open new account”, “Help”, and so on. There is a hidden
responsibility:
Add an option
Step 2  Specify the public interface.
Turn the list in Step 1 into a set of member functions, with specific types for the parameters and the
return values. Be sure to mark accessors as 
. Many programmers find this step simpler if they
write out member function calls that are applied to a sample object, like this:
Add more options
Now we have a specific list of member functions.
•  
•  
HOW TO 9.1 Implementing a Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:41 PM

What about displaying the menu? There is no sense in displaying the menu without also asking the
user for input. However, 
 may need to display the menu more than once if the user
provides a bad input. Thus, 
 is a good candidate for a private member function.
To complete the public interface, you need to specify the constructors. Ask yourself what
information you need in order to construct an object of your class. Sometimes you will want two
constructors: one that sets all fields to a default and one that sets them to user-supplied values.
In the case of the menu example, we can get by with a single constructor that creates an empty menu.
Here is the public interface:
Step3  Document the public interface.
Supply a documentation comment for the class, then comment each member function.
A menu that is displayed on a console.
Constructs a menu with no options.
Adds an option to the end of this menu.
 option the option to add
Displays the menu, with options numbered starting with 1,
and prompts the user for input. Repeats until a valid input
is supplied.
 the number that the user supplied
Step 4  Determine data members.
Ask yourself what information an object needs to store to do its job. Remember, the member
functions can be called in any order! The object needs to have enough internal memory to be able to
process every member function using just its data members and the member function parameters. Go
through each member function, perhaps starting with a simple one or an interesting one, and ask
yourself what you need to carry out the member function's task. Make data members to store the
information that the member function needs.
In the menu example, we clearly need to store the menu options so that the menu can be displayed.
How should we store them? As a vector of strings? As one long string? Both approaches can be
HOW TO 9.1 Implementing a Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:41 PM

made to work. We will use a vector here. Exercise P9.5. asks you to implement the other approach.
When checking for user input, we need to know the number of menu items. Because we store them
in a vector, the number of menu items is simply obtained as the size of the vector. If you stored the
menu items in one long string, you might want to keep another data member that stores the item
count.
Step 5  Implement constructors and member functions.
Implement the constructors and member functions in your class, one at a time, starting with the
easiest ones. For example, here is the implementation of the 
 member function:
Here is the 
 member function. This member function is a bit more sophisticated. It loops
until a valid input has been obtained, and it calls the private 
 member function to display
the menu.
Finally, here is the 
 member function:
The 
 constructor is a bit odd. We need to construct a menu with no options. A vector is a class,
and it has a default constructor. That constructor does exactly what we want, namely to construct an
empty vector. Nothing else needs to be done:
If you find that you have trouble with the implementation of some of your member functions, you
may need to rethink your choice of data members. It is common for a beginner to start out with a set
of data members that cannot accurately describe the state of an object. Don't hesitate to go back and
HOW TO 9.1 Implementing a Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:41 PM

rethink your implementation strategy.
Once you have completed the implementation, compile your class and fix any compiler errors. (See
 in your book code for the completed class.)
Step 6  Test your class.
Write a short tester program and execute it. The tester program should carry out the member
function calls that you found in Step 2.
Program Run
5
3
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
HOW TO 9.1 Implementing a Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:41 PM

Worked Example 9.1
WORKED EXAMPLE 9.1 Implementing a Bank Account Class
Write a class that simulates a bank account. Customers can deposit and withdraw funds. If sufficient funds are not
available for withdrawal, a $10 overdraft penalty is charged. At the end of the month, interest is added to the
account. The interest rate can vary every month.
Step 1  Get an informal list of the responsibilities of your objects.
The following responsibilities are mentioned in the problem statement:
Deposit funds
Withdraw funds
Add interest
There is a hidden responsibility as well. We need to be able to find out how much money is
in the account.
Get balance
Step 2  Specify the public interface.
We need to supply parameters and determine which member functions are accessors. To
deposit or withdraw money, one needs to know the amount of the deposit or withdrawal.
To add interest, one needs to know the interest rate that is to be applied:
Clearly, all these member functions are mutators since they change the balance.
Finally, we have
This function is an accessor because inquiring about the balance does not change it.
Now we move on to constructors. A default constructor makes an account with a zero
balance. It can also be useful to supply a constructor with an initial balance.
Here is the complete public interface:
WORKED EXAMPLE 9.1 Implementing a Bank Account Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:41 PM

Step 3  Document the public interface.
   
A bank account whose balance can be changed by deposits and withdrawals.
      
Constructs a bank account with zero balance.
      
Constructs a bank account with a given balance.
      
 initial_balance the initial balance
      
Makes a deposit into this account.
      
 amount the amount of the deposit
      
Makes a withdrawal from this account, or charges a penalty if
      
sufficient funds are not available.
      
 amount the amount of the withdrawal
      
Adds interest to this account.
      
 rate the interest rate in percent
      
Gets the current balance of this bank account.
      
 the current balance
Step 4  Determine data members.
Clearly we need to store the bank balance.
WORKED EXAMPLE 9.1 Implementing a Bank Account Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:41 PM

Do we need to store the interest rate? No—it varies every month, and is supplied as a
parameter to 
 What about the withdrawal penalty? The problem
description states that it is a fixed $10, so we need not store it. If the penalty could vary
over time, as is the case with most real bank accounts, we would need to store it
somewhere (perhaps in a 
 object), but it is not our job to model every aspect of the
real world.
Step 5  Implement constructors and member functions.
Let's start with a dull one:
The 
 member function is a bit more interesting:
The 
 member function needs to charge a penalty if sufficient funds are not
available:
Finally, here is the 
 member function. We compute the interest and then
simply call the 
 member function to add the interest to the balance.
The constructors are once again quite dull:
WORKED EXAMPLE 9.1 Implementing a Bank Account Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:41 PM

This finishes the implementation (see 
 in your book code).
Step 6  Test your class.
Here is a simple test program that exercises all member functions:
Balance is now $1500
Balance is now $1490
Balance is now $1490 + 14.90
Program Run  
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
WORKED EXAMPLE 9.1 Implementing a Bank Account Class
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:41 PM

Random Fact 9.1
RANDOM FACT 9.1 Electronic Voting Machines
In the 2000 presidential elections in the United States, votes were tallied by a variety of machines. Some machines
processed cardboard ballots into which voters punched holes to indicate their choices (see Figure 6).When voters
were not careful, remains of paper–the now infamous “chads”–were partially stuck in the punch cards, causing
votes to be miscounted. A manual recount was necessary, but it was not carried out everywhere due to time
constraints and procedural wrangling. The election was very close, and there remain doubts in the minds of many
people whether the election outcome would have been different if the voting machines had accurately counted the
intent of the voters.
Figure 6   Punch Card Ballot
David Young-Wolff/PhotoEdit.
Subsequently, voting machine manufacturers have argued that electronic voting machines would avoid the
problems caused by punch cards or optically scanned forms. In an electronic voting machine, voters indicate their
preferences by pressing buttons or touching icons on a computer screen. Typically, each voter is presented with a
summary screen for review before casting the ballot. The process is very similar to using an automatic bank teller
machine (see Figure 7).
RANDOM FACT 9.1 Electronic Voting Machines
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:41 PM

Figure 7   Touch Screen Voting Machine
Lisa F. Young/iStockphoto.
It seems plausible that these machines make it more likely that a vote is counted in the same way that the voter
intends. However, there has been significant controversy surrounding some types of electronic voting machines. If
a machine simply records the votes and prints out the totals after the election has been completed, then how do you
know that the machine worked correctly? Inside the machine is a computer that executes a program, and, as you
may know from your own experience, programs can have bugs.
In fact, some electronic voting machines do have bugs. There have been isolated cases where machines reported
tallies that were impossible. When a machine reports far more or far fewer votes than voters, then it is clear that it
malfunctioned. Unfortunately, it is then impossible to find out the actual votes. Over time, one would expect these
bugs to be fixed in the software. More insidiously, if the results are plausible, nobody may ever investigate.
Many computer scientists have spoken out on this issue and confirmed that it is impossible, with today's
technology, to tell that software is error free and has not been tampered with. Many of them recommend that
electronic voting machines should employ a voter verifiable audit trail. (A good source of information is
http://verifiedvoting.org.) Typically, a voter-verifiable machine prints out a ballot. Each voter has a chance to
review the printout, and then deposits it in an old-fashioned ballot box. If there is a problem with the electronic
equipment, the printouts can be scanned or counted by hand.
As this book is written, this concept is strongly resisted both by manufacturers of electronic voting machines and
by their customers, the cities and counties that run elections. Manufacturers are reluctant to increase the cost of the
machines because they may not be able to pass the cost increase on to their customers, who tend to have tight
budgets. Election officials fear problems with malfunctioning printers, and some of them have publicly stated that
they actually prefer equipment that eliminates bothersome recounts.
What do you think? You probably use an automatic bank teller machine to get cash from your bank account. Do
you review the paper record that the machine issues? Do you check your bank statement? Even if you don't, do you
put your faith in other people who double-check their balances, so that the bank won't get away with widespread
cheating?
At any rate, is the integrity of banking equipment more important or less important than that of voting machines?
Won't every voting process have some room for error and fraud anyway? Is the added cost for equipment, paper,
and staff time reasonable to combat a potentially slight risk of malfunction and fraud? Computer scientists cannot
answer these questions–an informed society must make these tradeoffs. But, like all professionals, they have an
obligation to speak out and give accurate testimony about the capabilities and limitations of computing equipment.
RANDOM FACT 9.1 Electronic Voting Machines
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:41 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 9.1 Electronic Voting Machines
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:41 PM

When you are given a problem description and aim to provide a solution using objects and classes, you need to determine the
classes required for the implementation. You may be able to reuse existing classes, or you may need to implement new ones.
One simple approach for discovering classes and member functions is to look for the nouns and verbs in the problem
description. Often times, nouns correspond to classes, and verbs correspond to member functions.
To discover classes, look for nouns in the problem
description.
Many classes are abstractions of real-life entities.
•  
•  
Generally, concepts from the problem domain, be it science, business, or a game, make good classes. The name for such a class
should be a noun that describes the concept. Other frequently used classes represent system services such as files or menus.
Concepts from the problem domain are good
candidates for classes.
What might not be a good class? If you can't tell from the class name what an object of the class is supposed to do, then you
are probably not on the right track. For example, your homework assignment might ask you to write a program that prints
paychecks. Suppose you start by trying to design a class 
. What would an object of this class do? An
object of this class would have to do everything that the homework needs to do. That doesn't simplify anything. A better class
would be 
 Then your program can manipulate one or more 
 objects.
Another common mistake, particularly by students who are used to writing programs that consist of functions, is to turn an
action into a class. For example, if your homework assignment is to compute a paycheck, you may consider writing a class
 But can you visualize a “ComputePaycheck” object? The fact that “ComputePaycheck” isn't a noun tips
you off that you are on the wrong track. On the other hand, a 
 class makes intuitive sense. The word “paycheck” is
a noun. You can visualize a paycheck object. You can then think about useful member functions of the 
 class,
such as 
, that help you solve the assignment.
When you analyze a problem description, you often find that you need multiple classes. It is then helpful to consider how these
classes are related. One of the fundamental relationships between classes is the “aggregation” relationship (which is informally
known as the “has-a” relationship).
A class aggregates another if its objects contain objects
of the other class.
The aggregation relationship states that objects of one class contain objects of another class. Consider a quiz that is made up of
questions. Since each quiz has one or more questions, we say that the class 
 aggregates the class 
. There is a
standard notation, called a UML (Unified Modeling Language) class diagram, to describe class relationships. In the UML
notation, aggregation is denoted by a line with a diamond-shaped symbol (see Figure 8).
Discovering Classes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:41 PM

Figure 8   Class Diagram
Finding out about aggregation is very helpful for deciding how to implement classes. For example, when you implement the
 class, you will want to store the questions of a quiz as a data member. Since a quiz can have any number of questions,
you will choose a vector:
In summary, when you analyze a problem description, you will want to carry out these tasks:
•  Find the concepts that you need to implement as classes. Often, these will be nouns in the problem description.
•  Find the responsibilities of the classes. Often, these will be verbs in the problem description.
•  Find relationships between the classes that you have discovered. In this section, we described the aggregation
relationship. In the next chapter, you will learn about another important relationship between classes, called inheritance.
A car has a motor and tires. In object-oriented design, this “has-a” relationship is called aggregation.
Anastaslya Maksymenko/iStockphoto.
Self Check
26.  What is the rule of thumb for finding classes? 
27.  Your job is to write a program that plays chess. Might 
 be an appropriate class? How about
? 
28.  In an e-mail system, messages are stored in a mailbox. Draw a UML diagram that shows the appropriate
Discovering Classes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:41 PM

aggregation relationship. 
29.  You are implementing a system to manage a library, keeping track of which books are checked out by whom.
Should the 
 class aggregate 
 or the other way around? 
30.  In a library management system, what would be the relationship between classes 
 and 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Discovering Classes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:41 PM

Quality Tip 9.3
QUALITY TIP 9.3 Make Parallel Vectors into Vectors of Objects
Sometimes, you find yourself using vectors of the same length, each of which stores a part of what conceptually
should be an object. In that situation, it is a good idea to reorganize your program and use a single vector whose
elements are objects.
For example, suppose an invoice contains a series of item descriptions and prices. One solution is to keep two
vectors:
Each of the vectors will have the same length, and the th slice, consisting of 
 and
, contains data that needs to be processed together. These vectors are called parallel vectors (see
Figure 9).
Figure 9   Parallel Vectors
Parallel vectors become a headache in larger programs. The programmer must ensure that the vectors always have
the same length and that each slice is filled with values that actually belong together. Moreover, any function that
operates on a slice must get all vectors as parameters, which is tedious to program.
The remedy is simple. Look at the slice and find the concept that it represents. Then make the concept into a class.
In this example, each slice contains the description and price of an item; turn this into a class.
You can now eliminate the parallel vectors and replace them with a single vector:
QUALITY TIP 9.3 Make Parallel Vectors into Vectors of Objects
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:42 PM

Each slot in the resulting vector corresponds to a slice in the set of parallel vectors (see Figure 10).
Figure 10   Eliminating Parallel Vectors
Avoid parallel vectors by changing them into
vectors of objects.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
QUALITY TIP 9.3 Make Parallel Vectors into Vectors of Objects
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:42 PM

When you write and compile small programs, you can place all your code into a single source file. When your programs get
larger or you work in a team, that situation changes. You will want to split your code into separate source files. There are two
reasons why this split becomes necessary. First, it takes time to compile a file, and it seems silly to wait for the compiler to
keep translating code that doesn't change. If your code is distributed over several source files, then only those files that you
changed need to be recompiled. The second reason becomes apparent when you work with other programmers in a team. It
would be very difficult for multiple programmers to edit a single source file simultaneously. Therefore, the program code is
broken up so that each programmer is solely responsible for a separate set of files.
The code of complex programs is distributed over
multiple files.
If your program is composed of multiple files, some of these files will define data types or functions that are needed in other
files. There must be a path of communication between the files. In C++, that communication happens through the inclusion of
header files.
A header file contains
•  Definitions of classes.
•  Definitions of constants.
•  Declarations of nonmember functions.
Header files contain the definitions of classes and
declarations of nonmember functions.
The source file contains
•  Definitions of member functions.
•  Definitions of nonmember functions.
Source files contain function implementations.
For the 
 class, you create a pair of files, 
 and 
, that contain the
interface and the implementation, respectively.
The header file contains the class definition.
ch09/cashregister.h
   A simulated cash register that tracks the item count and
   the total amount due.
Separate Compilation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:42 PM

   Constructs a cash register with cleared item count and total.
   Clears the item count and the total.
   Adds an item to this cash register.
the price of this item
the total amount of the current sale
the item count of the current sale
You include this header file whenever the definition of the 
 class is required. Since this file is not a standard
header file, you must enclose its name in quotes, not <…>, when you include it, like this:
Note the set of directives that bracket the header file.
Suppose a file includes two header files: 
, and another header file that itself includes
. The effect of the directives is to skip the file when it is encountered the second time. If we did not have
that check, the compiler would complain when it saw the definition for the 
 class twice. (Sadly, it doesn't
check whether the definitions are identical.)
The source file simply contains the definitions of the member functions (including constructors).
Note that the source file 
 includes its own header file 
 The compiler needs to
know how the 
 class is defined in order to compile the member functions.
ch09/cashregister.cpp
Separate Compilation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:42 PM

Note that the function comments are in the header file, since they are a part of the interface, not the implementation.
The 
 file does not contain a 
 function. There are many potential programs that might make use of
the 
 class. Each of these programs will need to supply its own 
 function, as well as other functions and
classes.
Here is a simple test program that puts the 
 class to use. Its source file includes the 
header file.
ch09/registertest2.cpp
Displays the item count and total price of a cash register.
the cash register to display
Separate Compilation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:42 PM

To build the complete program, you need to compile both the 
 source
files (see Figure 11). The details depend on your compiler. For example, with the Gnu compiler, you issue the command
You have just seen the simplest and most common case for designing header and source files. There are a few additional
technical details that you should know.
Figure 11   Compiling a Program from Multiple Source Files
•  A header file should include all headers that are necessary for defining the class. For example, if a class uses the 
class, include the 
 header as well. Anytime you include a header from the standard library, also include the
directive
item.h
•  Place shared constants into a header file. For example,
volume.h
Separate Compilation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:42 PM

•  To share a nonmember function, place the function declaration into a header file and the definition of the function into
the corresponding source file.
cube.h
cube.cpp
Self Check
31.  Suppose the cash register is enhanced to carry out direct debits from bank accounts, and a member function
 is added to the 
 Which header file do you need to
include in 
? 
32.  In the enhancement described in Self Check 31., what additional file do you need to include in
 
33.  In the enhancement described in Self Check 31., what additional file do you need to include in the
 file? 
34.  Suppose we want to move the 
 function from 
 to the 
and 
 files. Explain how those files need to change. 
35.  Where is the header file located that you include with the 
 directive? 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Separate Compilation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:42 PM

The following sections discuss how to work with pointers to objects. As you will see in the next chapter, pointers to objects
are important when you work with multiple objects from related classes.
9.8.1 Dynamically Allocating Objects
It is common to allocate objects on the heap. As discussed in Section 7.4, you use the new operator to obtain memory from the
heap. For example, the call
returns a pointer to a 
 object. You can also supply construction parameters:
You usually want to store the pointer that the 
 operator returns:
Note that each of these definitions allocates two entities: a pointer variable and an object on the heap–see Figure 12.
Figure 12   Pointers and the Objects to Which They Point
When you no longer need a heap object, be sure to delete it:
9.8.2 The –> Operator
Because 
 is a pointer to a 
 object, the value *
 denotes the
 object itself. To invoke a member function on that object, you might call
The parentheses are necessary because in C++ the dot operator takes precedence over the * operator. The expression without
the parentheses would be a syntax error:
Error–you can't apply . to a pointer
Pointers to Objects
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:42 PM

Because the dot operator has higher precedence than *, the dot would be applied to a pointer, not an object.
Because calling a member function through a pointer is very common, the designers of C++ supply an operator to abbreviate
the “follow pointer and access member” operation. That operator is written -> and usually pronounced as “arrow”. Here is how
you use the “arrow” operator:
This call means: Invoke the 
 member function with implicit parameter *
 and explicit
parameter 1.95.
Use the -> operator to invoke a member function
through a pointer.
9.8.3 The this Pointer
Each member function has a special parameter variable, called 
, which is a pointer to the implicit parameter. For example,
consider the 
 function. If you call
then the 
 pointer has type 
 and points to the 
 object.
You can use the 
 pointer inside the definition of a member function. For example, you can implement the 
function as
Here, the expression 
 refers to the 
 data member of the object to which 
 points, that is, the
 member of the implicit parameter (which is 
 in our example). The 
 pointer is not
necessary, since by convention the expression 
 also refers to the field of the implicit parameter. Nevertheless, some
programmers like to use the 
 pointer to make it clear that 
 is a data member and not a variable.
In a member function, the this pointer points to the
implicit parameter.
Self Check
36.  Write a statement that dynamically allocates a 
 object and saves the address in a pointer variable
37.  Write a statement that deallocates the object that was allocated in Self Check 36. 
38.  Write a statement that dynamically allocates a 
 object with contents 
 and saves the address
in a pointer variable 
 
39.  Write a statement that invokes the 
 member function on the object that was allocated in Self Check
38. and prints the result. 
40.  What is the type of 
 when the 
 member function is called? 
Pointers to Objects
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:42 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Pointers to Objects
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:42 PM

Advanced Topic 9.3
ADVANCED TOPIC 9.3 Destructors and Resource Management
A destructor is a special member function that is automatically executed under two circumstances:
•  At the end of the block in which an object variable is defined
•  When a heap object is deleted
To understand the need for destructors, consider an implementation of a string class, similar to that of the C++ library.
The characters of a string are stored on the heap, and each 
 object contains a pointer to the array holding its
characters.
The constructor allocates and initializes the character array.
It is the job of the destructor to deallocate this memory. The name of the destructor is the ~ character followed by the
class name, that is, ~
 in our case. A class can have only one destructor, and it has no parameters.
When a 
 object is no longer needed, the destructor is automatically invoked, and the memory for the characters
is properly recycled (see Figure 13):
 heap memory is allocated by the  constructor   
 The destructor is invoked on name, and its heap memory is deallocated
As a rule of thumb, if a constructor calls 
, you should supply a destructor that calls 
.
ADVANCED TOPIC 9.3 Destructors and Resource Management
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:42 PM

Figure 13   The Destructor Deallocates Heap Memory
Unfortunately, just supplying a destructor is not enough. Consider this scenario:
The assignment has a very unfortunate effect: The memory for the first 
 has not been deallocated. (The
destructor is only called at the end of the block in which 
 is defined.) And the two 
 objects now share a
pointer to the same area of heap memory. Eventually, that memory location will be deleted twice (see Figure 14).
Figure 14   A Bad Assignment
To overcome this problem, you must define an 
= function so that the assignment of one string to another
manages heap memory correctly. However, doing so is beyond the scope of this book. (See Horstmann & Budd, Big
C++, 2nd Edition, Ch. 15, for details.)
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 9.3 Destructors and Resource Management
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:42 PM

Random Fact 9.2
RANDOM FACT 9.2 Open Source and Free Software
Most companies that produce software regard the source code as a trade secret. After all, if customers or
competitors had access to the source code, they could study it and create similar programs without paying the
original vendor. For the same reason, customers dislike secret source code. If a company goes out of business or
decides to discontinue support for a computer program, its users are left stranded. They are unable to fix bugs or
adapt the program to a new operating system.
Nowadays, some software packages are distributed with “open source” or “free software” licenses. Here, the term
“free” doesn't refer to price, but to the freedom to inspect and modify the source code. Richard Stallman, a famous
computer scientist and winner of a MacArthur “genius” grant, pioneered the concept of free software. He is the
inventor of the Emacs text editor and the originator of the GNU project that aims to create an entirely free version
of a Unix compatible operating system. All programs of the GNU project are licensed under the General Public
License or GPL. The GPL allows you to make as many copies as you wish, make any modifications to the source,
and redistribute the original and modified programs, charging nothing at all or whatever the market will bear. In
return, you must agree that your modifications also fall under the GPL. You must give out the source code to any
changes that you distribute, and anyone else can distribute them under the same conditions. The GPL, and similar
open source licenses, form a social contract. Users of the software enjoy the freedom to use and modify the
software, and in return they are obligated to share any improvements that they make. Many programs, such as the
Linux operating system and the GNU C++ compiler, are distributed under the GPL.
Some commercial software vendors have attacked the GPL as “viral” and “undermining the commercial software
sector”. Other companies have a more nuanced strategy, producing proprietary software while also contributing to
open source projects.
Frankly, open source is not a panacea and there is plenty of room for the commercial software sector. Open source
software often lacks the polish of commercial software because many of the programmers are volunteers who are
interested in solving their own problems, not in making a product that is easy to use by others. Some product
categories are not available at all as open source software because the development work is unattractive when there
is little promise of commercial gain. Open source software has been most successful in areas that are of interest to
programmers, such as the Linux operating system, Web servers, and programming tools.
On the positive side, the open software community can be very competitive and creative. It is quite common to see
several competing projects that take ideas from each other, all rapidly becoming more capable. Having many
programmers involved, all reading the source code, often means that bugs tend to get squashed quickly. Eric
Raymond describes open source development in his famous article “The Cathedral and the Bazaar” (http://catb.org
/~esr/writings/cathedral-bazaar/cathedral-bazaar/index.html). He writes “Given enough eyeballs, all bugs are
shallow”.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 9.2 Open Source and Free Software
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:42 PM

1.  An object holds data members that are accessed by member functions.
2.  Encapsulation is the act of hiding implementation details.
Damir Cudic/iStockphoto.
3.  A class describes a set of objects with the same behavior.
4.  Every class has a public interface: a collection of member functions through which the objects of the class can be
manipulated.
Michael Shake/iStockphoto.
5.  A mutator member function changes the object on which it operates.
6.  An accessor member function does not change the object on which it operates. Use 
 with accessors.
7.  Every object has its own set of data members.
8.  Private data members can only be accessed by member functions of the same class.
9.  By keeping the implementation private, we protect it from being accidentally corrupted.
10.  Encapsulation enables changes in the implementation without affecting users of a class.
Photo by Gary Lee/UPPA/Zuma Press. © Copyright 2006 by UPPA.
11.  Use the ClassName:: prefix when defining member functions.
12.  The object on which a member function is applied is the implicit parameter.
13.  Explicit parameters of a member function are listed in the function definition.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:43 PM

14.  When calling another member function on the same object, do not use the dot notation.
15.  A constructor is called automatically whenever an object is created.
Ann Marie Kurtz/iStockphoto.
16.  The name of a constructor is the same as the class name.
17.  A default constructor has no parameters.
18.  A class can have multiple constructors.
19.  The compiler picks the constructor that matches the construction parameters.
20.  Be sure to initialize all number and pointer data members in a constructor.
21.  To discover classes, look for nouns in the problem description.
22.  Concepts from the problem domain are good candidates for classes.
23.  A class aggregates another if its objects contain objects of the other class.
Anastaslya Maksymenko/iStockphoto.
24.  Avoid parallel vectors by changing them into vectors of objects.
25.  The code of complex programs is distributed over multiple files.
26.  Header files contain the definitions of classes and declarations of nonmember functions.
27.  Source files contain function implementations.
28.  Use the –> operator to invoke a member function through a pointer.
29.  In a member function, the 
 pointer points to the implicit parameter.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:43 PM

Exercise R9.1.    
What value is returned by the calls 
, and
 after these statements?
Exercise R9.2.    
Consider the 
 class in How To 9.1 on page 387. What is displayed when the following calls are executed?
Exercise R9.3.    
What is the interface of a class? How does it differ from the implementation of a class?
Exercise R9.4.    
What is a member function, and how does it differ from a nonmember function?
Exercise R9.5.    
What is a mutator function? What is an accessor function?
Exercise R9.6.    
What happens if you forget the 
 in an accessor function? What happens if you accidentally supply a 
 in a
mutator function?
Exercise R9.7.    
What is an implicit parameter? How does it differ from an explicit parameter?
Exercise R9.8.    
How many implicit parameters can a member function have? How many implicit parameters can a nonmember function
have? How many explicit parameters can a function have?
Exercise R9.9.    
What is a constructor?
Exercise R9.10.    
What is a default constructor? What is the consequence if a class does not have a default constructor?
Exercise R9.11.    
How many constructors can a class have? Can you have a class with no constructors? If a class has more than one
constructor, which of them gets called?
Exercise R9.12.    
What is encapsulation? Why is it useful?
Exercise R9.13.    
Data members are hidden in the private section of a class, but they aren't hidden very well at all. Anyone can read the private
section. Explain to what extent the 
 reserved word hides the private members of a class.
Exercise R9.14.    
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:43 PM

You can read the 
 data member of the 
class with the 
 accessor function. Should
there be a 
 mutator function to change it? Explain why or why not.
Exercise R9.15.    
In a nonmember function, it is easy to differentiate between calls to member functions and calls to nonmember functions.
How do you tell them apart? Why is it not as easy for functions that are called from a member function?
Exercise R9.16.    
Consider the following problem description:
 Users place coins in a vending machine and select a product by pushing a button.
 If the inserted coins are sufficient to cover the purchase price of the product,
 the product is dispensed and change is given.
 Otherwise, the inserted coins are returned to the user.
What classes should you use to implement it?
Exercise R9.17.    
Consider the following problem description:
 Employees receive their biweekly paychecks.
 They are paid their hourly rates for each hour worked;
 however, if they worked more than 40 hours per week,
 they are paid overtime at 150 percent of their regular wage.
What classes should you use to implement it?
Exercise R9.18.    
Consider the following problem description:
 Customers order products from a store.
 Invoices are generated to list the items and quantities ordered,
 payments received, and amounts still due.
 Products are shipped to the shipping address of the customer,
 and invoices are sent to the billing address.
What classes should you use to implement it?
Exercise R9.19.    
Suppose a vending machine contains products, and users insert coins into the vending machine to purchase products. Draw
a UML diagram showing the aggregation relationships between the classes 
, and 
.
Exercise R9.20.    
Suppose an 
 object contains descriptions of the products ordered, and the billing and shipping address of the
customer. Draw a UML diagram showing the aggregation relationships between the classes 
, and 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:43 PM

Exercise P9.1.    
Reimplement the 
 class so that it keeps track of the price of each added item in a 
.
Remove the 
 and 
 data members. Reimplement the 
, and
 member functions. Add a member function 
 that displays the prices of all items in the current
sale.
Exercise P9.2.    
Reimplement the 
 class so that it keeps track of the total price as an integer: the total cents of the price.
For example, instead of storing 17.29, store the integer 1729. Such an implementation is commonly used because it avoids
the accumulation of roundoff errors. Do not change the public interface of the class.
Exercise P9.3.    
Add a feature to the 
 class for computing sales tax. The tax rate should be supplied when constructing a
 object. Add 
 and 
 member functions. (Items added with 
are not taxable.)
Exercise P9.4.    
After closing time, the store manager would like to know how much business was transacted during the day. Modify the
 class to enable this functionality. Supply member functions 
 and 
 to
get the total amount of all sales and the number of sales. Supply a member function 
 that resets any counters
and totals so that the next day's sales start from zero.
Exercise P9.5.    
Reimplement the 
 class so that it stores all menu items in one long string. Hint: Keep a separate counter for the number
of options. When a new option is added, append the option count, the option, and a newline character.
Exercise P9.6.    
Implement a class 
. An address has a house number, a street, an optional apartment number, a city, a state, and a
postal code. Supply two constructors: one with an apartment number and one without. Supply a 
 member function
that prints the address with the street on one line and the city, state, and postal code on the next line. Supply a member
function 
 that tests whether one address comes before another when the addresses are compared by postal
code.
Exercise P9.7.    
Implement a class 
. This class has two objects, 
 and 
, of the type 
 that was
developed in Worked Example 9.1 (
 in your code files). Implement four member functions:
Here the account string is " " or " ". For the deposit or withdrawal, it indicates which account is affected. For a transfer, it
indicates the account from which the money is taken; the money is automatically transferred to the other account.
Exercise P9.8.    
Implement a class 
 with member functions 
 and 
. In the constructor,
supply the height and radius of the can.
Exercise P9.9.    
Implement a class 
 with the following properties. A car has a certain fuel efficiency (measured in miles/gallon) and a
certain amount of fuel in the gas tank. The efficiency is specified in the constructor, and the initial fuel level is 0. Supply a
member function 
 that simulates driving the car for a certain distance, reducing the fuel level in the gas tank, and
member functions 
, to return the current fuel level, and 
, to tank up. Sample usage:
50 miles per gallon
Tank 20 gallons
Drive 100 miles
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:43 PM

Print fuel remaining
Exercise P9.10.    
Implement a class 
. For the purpose of this exercise, a student has a name and a total quiz score. Supply an
appropriate constructor and functions 
, 
, and
. To compute the latter, you also need to store the number of quizzes that the student took.
Exercise P9.11.    
Modify the 
 class of Exercise P9.10. to compute grade point averages. Member functions are needed to add a
grade, and get the current GPA. Specify grades as elements of a class 
. Supply a constructor that constructs a grade
from a string, such as 
 You will also need a function that translates grades into their numeric values (for example,
 becomes 3.3).
Exercise P9.12.    
Define a class 
 that works like the combination lock in a gym locker, as shown here. The lock is constructed
with a combination–three numbers between 0 and 39. The 
 function resets the dial so that it points to 0. The
 and 
 functions turn the dial by a given number of ticks to the left or right. The 
 function
attempts to open the lock. The lock opens if the user first turned it right to the first number in the combination, then left to
the second, and then right to the third.
Steve Dibblee/iStockphoto.
Exercise P9.13.    
Define a class 
 that stores the name of the country, its population, and its area. Using that class, write a program
that reads in a set of countries and prints
•  The country with the largest area.
•  The country with the largest population.
•  The country with the largest population density (people per square kilometer).
Exercise P9.14.    
Design a class 
 that models an e-mail message. A message has a recipient, a sender, and a message text. Support
the following member functions:
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:43 PM



1.  1,000. 10.
2.  
 is an object, 
 is a class.
3.  Through the 
 member function and the 
 operator.
4.  As a 
 As a 
 array.
5.  None. The member functions will have the same effect, and your code could not have manipulated 
 objects in any
other way.
6.  2 1.90
7.  There is no member function named 
.
8.  
9.  
10.  A mutator. Getting a character removes it from the stream, thereby modifying it. Not convinced? Consider what happens
if you call the 
 function twice. You will usually get two different characters. But if you call an accessor twice on an
object (without a mutation between the two calls), you are sure to get the same result.
11.  2 1.85 1 1.90
12.  The code tries to access a private data member.
13.  
1.  
Between 1 and 12
Between 0 and 59
True for P.M., false for A.M.
2.  
Military time, between 0 and 23
Between 0 and 59
3.  
Between 0 and 60 * 24 - 1
14.  They need not change their programs at all since the public interface has not changed. They need to recompile with the
new version of the 
 class.
15.  
1.  
"A+", "B"
2.  
4.3, 3.0
16.  (1) The 
 is missing. (2) The 
 is missing.
17.  
18.  
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:43 PM

Truncates cents
19.  Three parameters: two explicit parameters of type 
, and one implicit parameter of type 
.
20.  One parameter: the implicit parameter of type 
. The function has no explicit parameters.
21.  
22.  
23.  
Note that the 
 data member need not be initialized.
24.  
25.  
(a)  Default constructor.
(b)  
 or 
(c)  
(d)  
(e)  Does not define an object.
26.  Look for nouns in the problem description.
27.  Yes (
) and no (
).
28.  
29.  Typically, a library system wants to track which books a patron has checked out, so it makes more sense to have 
aggregate 
. However, there is not always one true answer in design. If you feel strongly that it is important to
identify the patron who had checked out a particular book (perhaps to notify the patron to return it because it was
requested by someone else), then you can argue that the aggregation should go the other way around.
30.  There would be no relationship.
31.  The header file that defines the 
 class, probably named 
32.  None. The 
 file includes 
, which includes 
.
33.  None. The bank account need not know anything about cash registers.
34.  Add the following line to 
Add the implementation of the 
 function to 
.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:43 PM

35.  The answer depends on your system. On my system, the file is located at /
/
/
/
/
.
36.  
37.  
38.  
or
39.  
40.  
, or more accurately, 
 because 
 is an accessor function.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Answers to Self-Check Questions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:43 PM

Worked Example 9.1
•
Implementing a Bank Account Class
1
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Implementing a Bank Account Class
Write a class that simulates a bank account. Customers can deposit and withdraw funds. If
sufﬁcient funds are not available for withdrawal, a $10 overdraft penalty is charged. At the
end of the month, interest is added to the account. The interest rate can vary every month.
Step 1
Get an informal list of the responsibilities of your objects.
The following responsibilities are mentioned in the problem statement:
Deposit funds.
Withdraw funds.
Add interest.
There is a hidden responsibility as well. We need to be able to ﬁnd out how much money is
in the account.
Get balance.
Step 2
Specify the public interface.
We need to supply parameters and determine which member functions are accessors. 
To deposit or withdraw money, one needs to know the amount of the deposit or withdrawal. 
void deposit(double amount);
void withdraw(double amount);
To add interest, one needs to know the interest rate that is to be applied:
void add_interest(double rate);
Clearly, all these member functions are mutators since they change the balance. 
Finally, we have
double get_balance() const;
This function is an accessor because inquiring about the balance does not change it.
Now we move on to constructors. A default constructor makes an account with a zero
balance. It can also be useful to supply a constructor with an initial balance.
Here is the complete public interface:
class BankAccount
{
public:
   BankAccount();
   BankAccount(double initial_balance);
   void deposit(double amount);
   void withdraw(double amount);
   void add_interest(double rate);
   double get_balance() const;
private:
   ...
};
WORKED EXAMPLE 9.1

2
C++ for Everyone  •  CHAPTER 9
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Step 3
Document the public interface.
/**
   A bank account whose balance can be changed by deposits and withdrawals.
*/
class BankAccount
{
public:
   /**
      Constructs a bank account with zero balance.
   */
   BankAccount();
   /**
      Constructs a bank account with a given balance.
      @param initial_balance the initial balance
   */
   BankAccount(double initial_balance);
   /**
      Makes a deposit into this account.
      @param amount the amount of the deposit
   */
   void deposit(double amount);
   /**
      Makes a withdrawal from this account, or charges a penalty if
      sufﬁcient funds are not available.
      @param amount the amount of the withdrawal
   */
   void withdraw(double amount);
   /**
      Adds interest to this account.
      @param rate the interest rate in percent
   */
   void add_interest(double rate);
   /**
      Gets the current balance of this bank account.
      @return the current balance
   */
   double get_balance() const;
private:
   ...
};
Step 4
Determine data members.
Clearly we need to store the bank balance. 
class BankAccount
{
   ...

Worked Example 9.1
•
Implementing a Bank Account Class
3
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
private:
   double balance;
};
Do we need to store the interest rate? No—it varies every month, and is supplied as a param-
eter to add_interest. What about the withdrawal penalty? The problem description states
that it is a ﬁxed $10, so we need not store it. If the penalty could vary over time, as is the case
with most real bank accounts, we would need to store it somewhere (perhaps in a Bank
object), but it is not our job to model every aspect of the real world.
Step 5
Implement constructors and member functions.
Let’s start with a dull one:
double BankAccount::get_balance() const
{
   return balance;
}
The deposit member function is a bit more interesting:
void BankAccount::deposit(double amount)
{
   balance = balance + amount;
}
The withdraw member function needs to charge a penalty if sufﬁcient funds are not available:
void BankAccount::withdraw(double amount)
{
   const double PENALTY = 10;
   if (amount > balance)
   {
      balance = balance - PENALTY;
   }
   else
   {
      balance = balance - amount;
   }
}
Finally, here is the add_interest member function. We compute the interest and then simply
call the deposit member function to add the interest to the balance.
void BankAccount::add_interest(double rate)
{
   double amount = balance * rate / 100;
   deposit(amount);
}
The constructors are once again quite dull:
BankAccount::BankAccount()
{
   balance = 0;
}
BankAccount::BankAccount(double initial_balance)
{

4
C++ for Everyone  •  CHAPTER 9
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   balance = initial_balance;
}
This ﬁnishes the implementation (see ch09/account.cpp in your book code).
Step 6
Test your class.
Here is a simple test program that exercises all member functions:
int main()
{
   BankAccount harrys_account(1000);
   harrys_account.deposit(500); // Balance is now $1500
   harrys_account.withdraw(2000); // Balance is now $1490 
   harrys_account.add_interest(1); // Balance is now $1490 + 14.90
   cout << fixed << setprecision(2) 
      << harrys_account.get_balance() << endl;
   return 0;
}
Program Run
1504.90

Chapter
   
    
    
Chapter Goals
•  To understand the concepts of inheritance and polymorphism
•  To learn how to inherit and override member functions
•  To be able to implement constructors for derived classes
•  To be able to design and use virtual functions
In this chapter you will learn two of the most important concepts in object-oriented programming: inheritance
and polymorphism. Through inheritance, you will be able to define new classes that are extensions of existing
classes.
Polymorphism allows you to take advantage of the commonality between related classes, while still giving each
class the flexibility to implement specific behavior. Using polymorphism, it is possible to build very flexible and
extensible systems.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To understan ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:41 PM

10.1  Inheritance Hierarchies 
 
 
In object-oriented design, inheritance is a relationship between a more general class (called the 
base class) and a more specialized class (called the derived class). The derived class inherits data 
and behavior from the base class. For example, consider the relationships between different 
kinds of vehicles depicted in Figure 1. Every car is a vehicle. Cars share the common traits of all 
vehicles, such as the ability to transport people from one place to another. We say that the class 
Car inherits from the class Vehicle. In this relationship, the Vehicle class is the base class 
and the Car class is the derived class.  
 
 
A derived class inherits data and 
behavior from a base class. 
 
 
 
 
 
 
 
 
   Figure 1    An Inheritance Hierarchy of Vehicle Classes 
 
 
Tony Tremblay/iStockphoto (vehicle); Peter Dean/iStockphoto 
(motorcycle); nicholas belton/iStockphoto (car); Robert 
Pernell/iStockphoto (truck); Clay Blackburn/iStockphoto (sedan); 
iStockphoto (SUV). 
 
 
 
Suppose we have an algorithm that manipulates a Vehicle object. Since a car is a special kind 
of vehicle, we can supply a Car object to such an algorithm, and it will work correctly. This is 
an example of the substitution principle that states that you can always use a derived-class object 
when a base-class object is expected.  
 
 

You can always use a derived class 
object in place of a base class object. 
 
 
 
 
The inheritance relationship can give rise to hierarchies where classes get ever more specialized, 
as shown in Figure 1. The C++ stream classes, shown in Figure 2, are another example of such a 
hierarchy. Figure 2 uses the UML notation for inheritance where the base and derived class are 
joined with an arrow that points to the base class. 
 
 
 
 
 
   Figure 2    The Inheritance Hierarchy of Stream Classes
 
 
 
As you can see, an ifstream (an input stream that reads from a file) is a special case of an 
istream (an input stream that reads data from any source). If you have an ifstream, you can 
pass it to a function that expects an istream.  
void process_input(istream& in) // Can call with an ifstream object 
Why provide a function that processes istream objects instead of ifstream objects? That 
function is more useful because it can handle any kind of input stream (such as an 
istringstream, which is convenient for unit testing). This again is the substitution principle 
at work. 
 
In this chapter, we will consider a simpler hierarchy of classes. Most likely, you have taken 
computer-graded quizzes. A quiz consists of questions, and there are different kinds of questions:  
 

 
We will develop a simple but flexible quiz-taking program to illustrate inheritance. 
paul kline/iStockphoto. 
 
 
 
•  Fill-in-the-blank 
 
•  Choice (single or multiple) 
 
•  Numeric (where an approximate answer is ok; e.g., 1.33 when the actual answer is 4/3) 
 
•  Free response 
 
Figure 3 shows an inheritance hierarchy for these question types. 
 
 
 
 
 
  Figure 3   Inheritance Hierarchy of Question Types 
 
 
 
At the root of this hierarchy is the Question type. A question can display its text, and it can 
check whether a given response is a correct answer:  
class Question 
{ 
public: 
   Question(); 
   void set_text(string question_text); 
   void set_answer(string correct_response); 
   bool check_answer(string response) const; 

   void display() const; 
private: 
   string text; 
   string answer; 
}; 
How the text is displayed depends on the question type. Later in this chapter, you will see some 
variations, but the base class simply sends the question text to cout. How the response is 
checked also depends on the question type. As already mentioned, a numeric question might 
accept approximate answers (see Exercise P10.1). In Exercise P10.3, you will see another way of 
checking the response. But in the base class, we will simply require that the response match the 
correct answer exactly. 
 
In the following sections, you will see how to form derived classes that inherit the member 
functions and data members of this base class. 
 
Here is the implementation of the Question class and a simple test program. Note the the 
Question class constructor needs to do no work because the text and answer fields are 
automatically set to the empty string. The boolalpha stream manipulator in the main 
function causes Boolean values to be displayed as true and false instead of the default 1 and 
0.  
ch10/quiz1/test.cpp
 
 1  #include <iostream> 
 2  #include <sstream> 
 3  #include <string> 
 4 
 5  using namespace std; 
 6 
 7  class Question 
 8  { 
 9  public: 
10     /** 
11        Constructs a question with empty text and answer. 
12     */ 
13     Question(); 
14 
15     /** 
16        @param question_text the text of this question 
17     */ 
18     void set_text(string question_text); 
19 
20     /** 
21        @param correct_response the answer for this question 
22     */ 
23     void set_answer(string correct_response); 
24 
25     /** 
26        @param response the response to check 
27        @return true if the response was correct, false otherwise 
28     */ 

29     bool check_answer(string response) const; 
30 
31     /** 
32        Displays this question. 
33     */ 
34     void display() const; 
35 
36  private: 
37     string text; 
38     string answer; 
39  }; 
40 
41  Question::Question() 
42  { 
43  } 
44 
45  void Question::set_text(string question_text) 
46  { 
47     text = question_text; 
48  } 
49 
50  void Question::set_answer(string correct_response) 
51  { 
52     answer = correct_response; 
53  } 
54 
55  bool Question::check_answer(string response) const 
56  {  
57     return response == answer; 
58  } 
59 
60  void Question::display() const 
61  { 
62     cout << text << endl; 
63  } 
64 
65  int main() 
66  { 
67     string response; 
68     cout << boolalpha; // Show Boolean values as true, false 
69 
70     Question q1; 
71     q1.set_text("Who was the inventor of C++?"); 
72     q1.set_answer("Bjarne Stroustrup"); 
73 
74     q1.display(); 
75     cout << "Your answer: "; 
76     getline(cin, response); 
77     cout << q1.check_answer(response) << endl; 
78 
79     return 0; 
80  } 
Program Run 
Who was the inventor of C++? 

Your answer: Bjarne Stroustrup 
true 
 
 
  
 
Self Check
 
 
 
 
1.  Consider classes Manager and Employee. Which should be the base class and 
which should be the derived class? 
 
 
 
2.  What are the inheritance relationships between classes BankAccount, 
CheckingAccount, and SavingsAccount? 
 
 
 
3.  Consider the function do_something(istream& stream). List all stream 
classes from Figure 2 whose objects can be passed to this function. 
 
 
 
4.  Consider the function do_something(Car& c). List all vehicle classes from 
Figure 1 whose objects cannot be passed to this function. 
 
 
 
5.  Should a class Quiz inherit from the class Question? Why or why not? 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Quality Tip 10.1 
 
 
 
 
QUALITY TIP 10.1 Use a Single Class for Variation in Values, Inheritance for 
Variation in Behavior 
 
 
The purpose of inheritance is to model objects with different behavior. When students 
first learn about inheritance, they have a tendency to overuse it, by creating multiple 
classes even though the variation could be expressed with a simple data member. 
 
Consider a program that tracks the fuel efficiency of a fleet of cars by logging the 
distance traveled and the refueling amounts. Some cars in the fleet are hybrids. Should 
you create a derived class HybridCar? Not in this application. Hybrids don't behave 
any differently than other cars when it comes to driving and refueling. They just have a 
better fuel efficiency. A single Car class with a data member  
double miles_per_gallon; 
is entirely sufficient. 
 
However, if you write a program that shows how to repair different kinds of vehicles, 
then it makes sense to have a separate class HybridCar. When it comes to repairs, 
hybrid cars behave differently from other cars. 
 
 

 
 
 
10.2   Implementing Derived Classes 
 
 
In C++, you form a derived class from a base class by specifying what makes the 
derived class different. You define the member functions that are new to the derived 
class. The derived class inherits all member functions from the base class, but you can 
change the implementation if the inherited behavior is not appropriate. 
 
The derived class automatically inherits all data members from the base class. You 
only define the added data members. 
 
Here is the syntax for the definition of a derived class:  
class ChoiceQuestion : public Question 
{ 
public: 
   New and changed member functions 
private: 
   Additional data members 
}; 
The : symbol denotes inheritance. The reserved word public is required for a 
technical reason (see Common Error 10.1 on page 426).  
 
 
 
Like the manufacturer of a stretch limo, who starts with a regular car and 
modifies it, a programmer makes a derived class by modifying another class.  
Ivan Cholavov/iStockphoto. 
 
 
 
A ChoiceQuestion object differs from a Question object in three ways:  
•  Its objects store the various choices for the answer. 
 
•  There is a member function for adding another choice. 
 
•  The display function of the ChoiceQuestion class shows these choices so 
that the respondent can choose one of them. 
 
When the ChoiceQuestion class inherits from the Question class, it needs only 
to spell out these three differences:  
class ChoiceQuestion : public Question 
{ 
public: 

   ChoiceQuestion(); 
   void add_choice(string choice, bool correct); 
   void display() const; 
private: 
   vector<string> choices; 
}; 
Figure 4 shows the layout of a ChoiceQuestion object. It inherits the text and 
answer data members from the Question base object, and it adds an additional data 
member: the choices vector. 
 
 
 
 
 
   Figure 4   Data Layout of Derived Object
 
 
 
The add_choice function is specific to the ChoiceQuestion class. You can only 
apply it to ChoiceQuestion objects, not general Question objects. However, the 
display function is a redefinition of a function that exists in the base class, to take 
into account the special needs of the derived class. We say that the derived class 
overrides this function.  
 
 
A derived class can override a base 
class function by providing a new 
implementation. 
 
 
 
 
In the ChoiceQuestion class definition you specify only new member functions 
and data members. All other member functions and data members of the Question 
class are automatically inherited by the Question class. For example, each 
ChoiceQuestion object still has text and answer data members, and 
set_text, set_answer, and check_answer member functions.  
 
 
The derived class inherits all data 
members and all functions that it 
does not override. 
 
 
 
 
You can call the inherited member functions on a derived-class object:  
choice_question.set_answer("2"); 
However, the inherited data members are inaccessible. Since these members are private 
data of the base class, only the base class has access to them. The derived class has no 
more access rights than any other class. 
 

In particular, the ChoiceQuestion member functions cannot directly access the 
answer member. These member functions must use the public interface of the 
Question class to access its private data, just like every other function. 
 
To illustrate this point, let us implement the add_choice member function. The 
function has two parameters: the choice to be added (which is appended to the vector 
of choices), and a Boolean value to indicate whether this choice is correct. If it is true, 
set the answer to the current choice number. (We use an ostringstream to convert 
the number to a string—see Section 8.4 for details.)  
void ChoiceQuestion::add_choice(string choice, bool correct) 
{ 
   choices.push_back(choice); 
   if (correct) 
   { 
      // Convert choices.size() to string 
      ostringstream stream; 
      stream << choices.size(); 
      string num_str = stream.str(); 
      // Set num_str as the answer 
      . . . 
   } 
} 
You can't just access the answer member in the base class. Fortunately, the 
Question class has a set_answer member function. You can call that member 
function. On which object? The question that you are currently modifying—that is, the 
implicit parameter of the ChoiceQuestion::add_choice function. As you saw 
in Chapter 9, if you invoke a member function on the implicit parameter, you don't 
specify the parameter but just write the member function name:  
set_answer(num_str); 
The compiler interprets this call as  
implicit parameter.set_answer(num_str); 
 
 
  
 
Self Check
 
 
 
 
6.  Suppose q is an object of the class Question and cq an object of the 
class ChoiceQuestion. Which of the following calls are legal? 
 
(a)   q.set_answer(response)
 
(b)   cq.set_answer(response)
 
(c)   q.add_option(option, true)
 
(d)   cq.add_option(option, true)
 
 
 
 
7.  Define a class Manager that inherits from the class Employee and 
adds a data member bonus for storing a salary bonus. Omit the 
constructor declaration. 
 
 
 
8.  Suppose the class Employee is defined as follows: 
 
class Employee 
{ 
 

public: 
   Employee(); 
   void set_name(string new_name); 
   void set_base_salary(double new_salary); 
   string get_name(); 
   double get_salary() const; 
private: 
   string name; 
   double base_salary; 
} 
Which data members does the Manager class from Self Check 7 have? 
 
 
9.  Define a class Manager that inherits from the class Employee and 
overrides the get_salary function. 
 
 
 
10.  Which member functions does the Manager class from Self Check 9 
inherit? 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Common Error 10.1 
 
 
 
 
 
 
COMMON ERROR 10.1 Private Inheritance 
 
 
It is a common error to forget the reserved word public that must 
 
 

follow the colon after the derived-class name.  
class ChoiceQuestion : Question // Error 
{ 
   . . . 
}; 
The class definition will compile. The ChoiceQuestion still inherits 
from Question, but it inherits privately. That is, only the member 
functions of ChoiceQuestion get to call member functions of 
Question. Whenever another function invokes a Question member 
function on a ChoiceQuestion object, the compiler will flag this as 
an error:  
int main() 
{ 
   ChoiceQuestion q; 
   . . . 
   cout << q.check_answer(response); // Error 
} 
This private inheritance is rarely useful. In fact, it violates the spirit of 
using inheritance in the first place—namely, to create objects that are 
usable just like the base-class objects. You should always use public 
inheritance and remember to supply the public reserved word in the 
definition of the derived class. 
 
 
 
 
 
 
 
 
 
 
 
Advanced Topic 10.1 
 
 
 
 
 
 
ADVANCED TOPIC 10.1 Calling the Base-Class Constructor 
 
 
Consider the process of constructing a derived-class object. A derived-
class constructor can only initialize the data members of the derived 
class. But the base-class data members also need to be initialized. Unless 
you specify otherwise, the base-class data members are initialized with 
the default constructor of the base class.  
 
 
Unless specified otherwise, 
the base-class data members 
are initialized with the 
default constructor. 
 
 
 
 
In order to specify another constructor, you use an initializer list, as 
described in Advanced Topic 9.1. Specify the name of the base class and 
 

the construction parameters in the initializer list. For example, suppose 
the Question base class had a constructor for setting the question text. 
Here is how a derived-class constructor could call that base-class 
constructor:  
ChoiceQuestion::ChoiceQuestion(string question_text) 
   : Question(question_text) 
{ 
} 
The derived-class constructor calls the base-class constructor before 
executing the code inside the { }. 
 
In our example program, we used the default constructor of the base 
class. However, if a base class has no default constructor, you must use 
the initializer list syntax.  
 
 
The constructor of a derived 
class can pass parameters to a 
base-class constructor. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Common Error 10.2 
 
 
 
 
 
 
COMMON ERROR 10.2 Replicating Base-Class Members 
 

 
 
A derived class has no access to the data members of the base class.  
ChoiceQuestion::ChoiceQuestion(string question_text) 
{ 
   text = question_text; // Error–tries to access private 
base-class member 
} 
When faced with a compiler error, beginners commonly “solve” this 
issue by adding another data member with the same name to the derived 
class:  
class ChoiceQuestion : public Question 
{ 
  . . . 
private: 
   vector<string> choices; 
   string text; // Don't! 
} 
Sure, now the constructor compiles, but it doesn't set the correct text! 
Such a ChoiceQuestion object has two data members, both named 
text. The constructor sets one of them, and the display member 
function displays the other.  
 
 
 
 
 
 
 
 
 
 
 
 
10.3  Overriding Member Functions 
 
 
The derived class inherits the member functions from the base class. If you are not 
satisfied with the behavior of the inherited member function, you can override it by 
specifying a new implementation in the derived class. 
 
Consider the display function of the ChoiceQuestion class. It needs to 
override the base-class display function in order to show the choices for the 
answer. Specifically, the derived-class function needs to  
•  Display the question text . 
 
•  Display the answer choices . 
 

The second part is easy since the answer choices are a data member of the derived 
class.  
int ChoiceQuestion::display() const 
{ 
   // Display the question text 
   . . . 
   // Display the answer choices 
   for (int i = 0; i < choices.size(); i++) 
   { 
      cout << i + 1 << ": " << choices[i] << endl; 
   } 
} 
But how do you get the question text? You can't access the text member of the 
base class directly since it is private. 
 
Instead, you can call the display function of the base class.  
int ChoiceQuestion::display() const 
{ 
   // Display the question text 
   display(); // Invokes implicit parameter.display() 
   // Display the answer choices 
   . . . 
} 
However, this won't quite work. Because the implicit parameter of 
ChoiceQuestion::display is of type ChoiceQuestion, and there is a 
function named display in the ChoiceQuestion class, that function will be 
called—but that is just the function you are currently writing! The function would 
call itself over and over. 
 
To display the question text, you must be more specific about which function named 
display you want to call. You want Question::display:  
int ChoiceQuestion::display() const 
{ 
   // Display the question text 
   Question::display(); // OK 
   // Display the answer choices 
   . . . 
} 
 
When you override a function, you usually want to extend the functionality of the 
base-class version. Therefore, you often need to invoke the base-class version 
before extending it. To invoke it, you need to use the BaseClass:function notation. 
However, you have no obligation to call the base-class function. Occasionally, a 
derived class overrides a base-class function and specifies an entirely different 
functionality.  
 
 
Use BaseClass::function notation 
to explicitly call a base-class 
function. 
 
 
 
 

Here is the complete program that displays a plain Question object and a 
ChoiceQuestion object. (The definition of the Question class, which you 
have already seen, is placed into question.h, and the implementation is in 
question.cpp.) This example shows how you can use inheritance to form a 
more specialized class from a base class.  
ch10/quiz2/test.cpp
 
 
 1 #include <iostream> 
 2 #include <sstream> 
 3 #include <vector> 
 4 #include "question.h" 
 5 
 6 class ChoiceQuestion : public Question 
 7 { 
 8 public: 
 9    /** 
10        Constructs a choice question with no choices. 
11    */ 
12    ChoiceQuestion(); 
13 
14    /** 
15        Adds an answer choice to this question. 
16        @param choice the choice to add 
17        @param correct true if this is the correct choice, false otherwise 
18    */ 
19    void add_choice(string choice, bool correct); 
20 
21    void display() const; 
22 private: 
23    vector<string> choices; 
24 }; 
25 
26 ChoiceQuestion::ChoiceQuestion() 
27 { 
28 } 
29 
30 void ChoiceQuestion::add_choice(string choice, bool correct) 
31 { 
32    choices.push_back(choice); 
33    if (correct) 
34    { 
35       // Convert  choices.size() to string 
36       ostringstream stream; 
37       stream << choices.size(); 
38       string num_str = stream.str(); 
39       set_answer(num_str); 
40    } 
41 } 
42 
43 void ChoiceQuestion::display() const 
44 { 
45    // Display the question text 

46    Question::display(); 
47    // Display the answer choices 
48     for (int i = 0; i < choices.size(); i++) 
49     {    
50         cout << i + 1 << ":" << choices[i] << endl; 
51     } 
52 } 
53 
54 int main() 
55 
56    string response; 
57    cout << boolalpha; 
58 
59    // Ask a basic question 
60 
61    Question q1; 
62    q1.set_text("Who was the inventor of C++?"); 
63    q1.set_answer("Bjarne Stroustrup"); 
64 
65    q1.display(); 
66    cout << "Your answer:"; 
67    getline(cin, response); 
68    cout << q1.check_answer(response) << endl; 
69 
70    // Ask a choice question 
71 
72    ChoiceQuestion q2; 
73    q2.set_text("In which country was the inventor of C++ 
born?"); 
74    q2.add_choice("Australia", false); 
75    q2.add_choice("Denmark", true); 
76    q2.add_choice("Korea", false); 
77    q2.add_choice("United States", false); 
78 
79    q2.display(); 
80    cout << "Your answer: "; 
81    getline(cin, response); 
82    cout << q2.check_answer(response) << endl; 
83 
84    return 0; 
85 } 
Program Run 
Who was the inventor of C++? 
Your answer: Bjarne Stroustrup 
true 
In which country was the inventor of C++ born? 
1: Australia 
2: Denmark 
3: Korea 
4: United States 
Your answer: 2 
true 
 
 

  
 
Self Check
 
 
 
 
11.  What is wrong with the following 
implementation of the display function? 
 
void ChoiceQuestion::display() const 
{ 
   cout << text << endl; 
   for (int i = 0; i << choices.size(); 
i++) 
   { 
      cout << i + 1 << ": 
" << choices[i] << endl; 
   } 
} 
 
 
12.  What is wrong with the following 
implementation of the display function? 
 
void ChoiceQuestion::display() const 
{ 
   this->display(); 
   for (int i = 0; i < choices.size(); 
i++) 
   { 
      cout << i + 1 << ": 
" << choices[i] << endl; 
   } 
} 
 
 
13.  Look again at the implementation of the 
add_choice function that calls the 
set_answer function of the base class. Why 
don't you need to call 
Question::set_answer? 
 
 
 
14.  In the Manager class of Self Check 9., override 
the get_name function so that managers have a 
* before their name (such as *Lin, Sally). 
 
 
 
15.  In the Manager class of Self Check 7., override 
the get_salary function so that it returns the 
sum of the salary and the bonus. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

COMMON ERROR 10.3 Forgetting the Base-Class Name 
 
 
A common error in extending the functionality of a base-class function is to 
forget the base-class name. For example, to compute the salary of a manager, 
get the salary of the underlying Employee object and add a bonus:  
double Manager::get_salary() const 
{ 
   double base_salary = get_salary(); 
      // Error—should be Employee::get_salary() 
   return base_salary + bonus; 
} 
Here get_salary() refers to the get_salary function applied to the 
implicit parameter of the member function. The implicit parameter is of type 
Manager, and there is a Manager::get_salary function, so that function 
is called. Of course, that is a recursive call to the function that we are writing. 
Instead, you must be precise which get_salary function you want to call. In 
this case, you need to call Employee::get_salary explicitly. 
 
Whenever you call a base-class function from a derived-class function with the 
same name, be sure to give the full name of the function, including the base-
class name. 
 
 
 
10.4  Virtual Functions and Polymorphism 
 
 
In the preceding sections you saw one important use of inheritance: to form a 
more specialized class from a base class. In the following sections you will see 
an even more powerful application of inheritance: to work with a collection of 
objects whose type can vary at run time and that carry out common tasks in 
different ways. 
 
10.4.1 The Slicing Problem
 
In this section, we will discuss a problem that commonly arises when you work 
with a collection of objects that belong to different classes in a class hierarchy. 
 
If you look into the main function of quiz2/test.cpp 
, you will find 
that there was some repetitive code to display each question and check the 
responses. It would be nicer if all questions were collected in a vector and one 
could use a loop to present them to the user:  
vector<Question> quiz(2); 
quiz[0].set_text("Who was the inventor of C++?"); 

quiz[0].set_answer("Bjarne Stroustrup"); 
ChoiceQuestion cq; 
cq.set_text("In which country was the inventor of C++ born?"); 
cq.add_choice("Australia", false); 
. . . 
quiz[1] = cq; 
for (int i = 0; i < quiz.size(); i++) 
{ 
   quiz[i].display(); 
   cout << "Your answer: "; 
   getline(cin, response); 
   cout << quiz[i].check_answer(response) << endl; 
} 
The vector quiz holds objects of type Question. The compiler realizes that 
a ChoiceQuestion is a special case of a Question. Thus it permits the 
assignment from a choice question to a question:  
quiz[1] = cq; 
However, a ChoiceQuestion object has three data members, whereas a 
Question object has just two. There is no room to store the derived-class 
data. That data simply gets sliced away when you assign a derived-class object 
to a base-class variable (see Figure 5). 
 
If you run the resulting program, the options are not displayed:  
Who was the inventor of C++? 
Your answer: Bjarne Stroustrup 
true 
In which country was the inventor of C++ born? 
Your answer: 
 
 
 
 
 
 
   Figure 5   Slicing Away Derived-Class Data
 
 
 
This problem is very typical of code that needs to manipulate objects from a 
mixture of classes in an inheritance hierarchy. Derived-class objects are usually 
bigger than base-class objects, and objects of different derived classes have 
different sizes. A vector of objects cannot deal with this variation in sizes.  
 
 
When converting a derived class 
object to a base class, the 
derived class data is sliced 
away. 
 
 
 
 
Instead, you need to store the actual objects elsewhere and collect their 

locations in a vector by storing pointers. We will discuss the use of pointers in 
the next section. 
 
10.4.2 Pointers to Base and Derived Classes
 
To access objects from different classes in a class hierarchy, use pointers. 
Pointers to the various objects all have the same size—namely, the size of a 
memory address—even though the objects themselves may have different sizes.
 
Here is the code to set up the vector of pointers:  
vector < Question*> quiz(2); 
quiz[0] = new Question; 
quiz[0]->set_text("Who was the inventor of C++?"); 
quiz[0]->set_answer("Bjarne Stroustrup"); 
ChoiceQuestion* cq_pointer = new ChoiceQuestion; 
cq_pointer->set_text("In which country was the inventor of C++ 
born?"); 
cq_pointer->add_choice("Australia", false); 
. . . 
quiz[1] = cq_pointer; 
As the highlighted code shows, you simply define the vector to hold pointers, 
allocate all objects by calling new, and use the -> operator instead of the dot 
operator. 
 
 
 
 
 
 
   Figure 6   A Polymorphic Vector
 
 
 
Note that the last assignment assigns a derived-class pointer of type 
ChoiceQuestion* to a base-class pointer of type Question*. This is 
perfectly legal. A pointer is the starting address of an object. Because every 
ChoiceQuestion is a special case of a Question, the starting address of a 
ChoiceQuestion object is, in particular, the starting address of a 
Question object. The reverse assignment—from a base-class pointer to a 
derived-class pointer—is an error.  
 
 
A derived-class pointer can be 

converted to a base-class 
pointer. 
 
 
 
 
The code to present all questions is  
for (int i = 0; i < quiz.size(); i++) 
{ 
   quiz[i]->display(); 
   cout << "Your answer: "; 
   getline(cin, response); 
   cout << quiz[i]->check_answer(response) << endl; 
} 
Again, note the use of the - > operators because quiz[i] is a pointer. 
 
10.4.3 Virtual Functions 
 
When you collect objects of different classes in a class hierarchy, and then 
invoke a member function, you want the appropriate member function to be 
applied. For example, when you call the display member function on a 
Question* pointer that happens to point to a ChoiceQuestion, you want 
the choices to be displayed. 
 
For reasons of efficiency, this is not the default in C++. By default, a call  
quiz[i]- > display(); 
always calls Question::display because the type of quiz[i] is 
Question*. 
 
However, in this case you really want to determine the actual type of the object 
to which quiz[i] points, which can be either a Question or a 
ChoiceQuestion object, and then call the appropriate function. In C++, you 
must alert the compiler that the function call needs to be preceded by the 
appropriate function selection, which can be a different one for every iteration 
in the loop. You use the virtual reserved word for this purpose:  
class Question 
{ 
public: 
   Question(); 
   void set_text(string question_text); 
   void set_answer(string correct_response); 
   virtual bool check_answer(string response) const; 
   virtual void display() const; 
private: 
   . . . 
}; 
The virtual reserved word must be used in the base class. All functions with 
the same name and parameter types in derived classes are then automatically 
virtual. However, it is considered good taste to supply the virtual reserved 
word for the derived-class functions as well.  
class ChoiceQuestion : public Question 
{ 
public: 

   ChoiceQuestion(); 
   void add_choice(string choice, bool correct); 
   virtual void display() const; 
private: 
   . . . 
}; 
You do not supply the reserved word virtual in the function definition:  
void Question::display() const // No virtual reserved word 
{ 
   cout << text << endl; 
} 
 
Whenever a virtual function is called, the compiler determines the type of the 
implicit parameter in the particular call at run time. The appropriate function 
for that object is then called. For example, when the display function is 
declared virtual, the call  
quiz[i]->display(); 
always calls the function belonging to the actual type of the object to which 
display[i] points—either Question::display or 
ChoiceQuestion::display.  
 
 
When a virtual function is 
called, the version belonging to 
the actual type of the implicit 
parameter is invoked. 
 
 
 
 
 
 
 
In the same way that vehicles can differ in their method of locomotion, 
polymorphic objects carry out tasks in different ways  
Aleksandr Popov/iStockphoto. 
 
 
 
10.4.4 Polymorphism 
 
The quiz vector collects a mixture of both kinds of questions. Such a 
collection is called polymorphic (literally, “of multiple shapes”). Objects in a 
polymorphic collection have some commonality but are not necessarily of the 
same type. Inheritance is used to express this commonality, and virtual 

functions enable variations in behavior.  
 
 
Polymorphism (literally, 
“having multiple shapes”) 
describes objects that share a set 
of tasks and execute them in 
different ways. 
 
 
 
 
Virtual functions give programs a great deal of flexibility. The question 
presentation loop describes only the general mechanism: “Display the question, 
get a response, and check it”. Each object knows on its own how to carry out 
the specific tasks: “Display the question” and “Check a response”. 
 
Using virtual functions makes programs easily extensible. Suppose we want to 
have a new kind of question for calculations, where we are willing to accept an 
approximate answer. All we need to do is to define a new class 
NumericQuestion, with its own check_answer function. Then we can 
populate the quiz vector with a mixture of plain questions, choice questions, 
and numeric questions. The code that presents the questions need not be 
changed at all! The calls to the virtual functions automatically select the correct 
member functions of the newly defined classes. 
 
Here is the final version of the quiz program, using pointers and virtual 
functions. When you run the program, you will find that the appropriate 
versions of the virtual functions are called.  
ch10/quiz3/question.h
 
 1  #ifndef QUESTION_H 
 2  #define QUESTION_H 
 3 
 4  #include <string> 
 5 
 6  using namespace std; 
 7 
 8  class Question 
 9  {  
10  public: 
11     /** 
12        Constructs a question with empty question and answer. 
13     */ 
14     Question(); 
15 
16     /** 
17        @param question_text the text of this question 
18     */ 
19     void set_text(string question_text); 
20 

21     /** 
22        @param correct_response the answer for this question 
23     */ 
24     void set_answer(string correct_response); 
25 
26     /** 
27        @param response the response to check 
28        @return true if the response was correct, false otherwise 
29     */ 
30     virtual bool check_answer(string response) const; 
31 
32     /** 
33        Displays this question. 
34     */ 
35     virtual void display() const; 
36  private: 
37     string text; 
38     string answer; 
39  }; 
40 
41  #endif 
ch10/quiz3/choicequestion.h
 
 1  #ifndef CHOICEQUESTION_H 
 2  #define CHOICEQUESTION_H 
 3 
 4  #include <vector> 
 5  #include "question.h" 
 6 
 7  class ChoiceQuestion : public Question 
 8  { 
 9  public: 
10     /** 
11        Constructs a choice question with no choices. 
12     */ 
13     ChoiceQuestion(); 
14 
15     /** 
16        Adds an answer choice to this question. 
17        @param choice the choice to add 
18        @param correct true if this is the correct choice, false otherwise 
19     */ 
20     void add_choice(string choice, bool correct); 
21 
22     virtual void display() const; 
23  private: 
24     vector<string> choices; 
25  }; 
26 
27  #endif 

ch10/quiz3/test.cpp
 
 
 1  #include <iostream> 
 2  #include "question.h" 
 3  #include "choicequestion.h" 
 4 
 5  int main() 
 6  { 
 7    string response; 
 8    cout << boolalpha; 
 9 
10    // Make a quiz with two questions 
11    vector < Question* > quiz(2); 
12    quiz[0] = new Question; 
13    quiz[0]->set_text("Who was the inventor of C++?"); 
14    quiz[0]->set_answer("Bjarne Stroustrup"); 
15 
16    ChoiceQuestion* cq_pointer = new ChoiceQuestion; 
17    cq_pointer->set_text( 
18       "In which country was the inventor of C++ born?"); 
19    cq_pointer->add_choice("Australia", false); 
20    cq_pointer->add_choice("Denmark", true); 
21    cq_pointer->add_choice("Korea", false); 
22    cq_pointer->add_choice("United States", false); 
23    quiz[1] = cq_pointer; 
24 
25    // Check answers for all questions 
26    for (int i = 0; i < quiz.size(); i++) 
27    {  
28       quiz[i]->display(); 
29       cout << "Your answer:"; 
30       getline(cin, response); 
31       cout << quiz[i]->check_answer(response) << endl; 
32    } 
33   
34    return 0; 
35  } 
 
 
  
 
Self Check
 
 
 
 
16.  Why did the test program introduce the variable cq_pointer 
instead of directly calling quiz[1]-
>add_choice("Australia", false)? 
 
 
 
17.  Which of the following statements are legal? 
 
(a)   ChoiceQuestion q; Question a = q; 
 
(b)   ChoiceQuestion b = a; 
 
(c)   a.add_choice("Yes", true); 
 
(d)   b.add_choice("No", false); 
 
 
 
 
 

18.  Which of the following statements are legal? 
 
(a)   Question* p = new ChoiceQuestion; 
 
(b)   ChoiceQuestion* q = p; 
 
(c)   p->add_choice("Yes", true); 
 
(d)   q->add_choice("No", false); 
 
 
 
 
19.  What is displayed as the result of the following statements? 
 
ChoiceQuestion* p = new ChoiceQuestion; 
p->set_text("What is the answer?"); 
p->add_choice("42", true); 
p->add_choice("Something else", false); 
Question q = *p; 
q.display(); 
 
 
20.  Suppose check_answer was not declared virtual in 
question.h. How would the behavior of test.cpp 
change? 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Quality Tip 10.2 
 
 
 
 
 
QUALITY TIP 10.2 Don't Use Type Tags 
 
 
Some programmers build inheritance hierarchies in which each 
object has a tag that indicates its type, commonly a string. They then 
query that string:  
if (q->get_type() == "Question") 
{ 
   // Do something 
} 
else if (q->get_type() == "ChoiceQuestion") 
{ 
  // Do something else 
} 
This is a poor strategy. If a new class is added, then all these queries 
need to be revised. In contrast, consider the addition of a class 
NumericQuestion to our quiz program. Nothing needs to 
change in that program because it uses virtual functions, not type 
tags. 
 
 

Whenever you find yourself adding a type tag to a hierarchy of 
classes, reconsider and use virtual functions instead. 
 
 
 
 
 
 
 
 
 
 
 
Common Error 10.4 
 
 
 
 
 
COMMON ERROR 10.4 Slicing an Object 
 
 
In C++ it is legal to copy a derived-class object into a base-class 
variable. However, any derived-class information is lost in the 
process. For example, when a Manager object is assigned to a 
variable of type Employee, the result is only the employee portion 
of the manager data:  
Manager m; 
. . . 
Employee e = m; // Holds only the Employee base data of 
m 
Any information that is particular to managers is sliced off, because 
it would not fit into a variable of type Employee. To avoid slicing, 
you can use pointers. 
 
The slicing problem commonly occurs when a function has a 
polymorphic parameter (that is, a parameter that can belong to a base 
class or a derived class). In that case, the parameter must be a pointer
or a reference. Consider this example:  
void ask(Question q) // Error 
{ 
    q.display(); 
    cout << "Your answer: "; 
    getline(cin, response); 
    cout << q.check_answer(response) << endl; 
} 
If you call this function with a ChoiceQuestion object, then the 
parameter variable q is initialized with a copy of that object. But q is 
a Question object; the derived-class information is sliced away. 
The simplest remedy is to use a reference:  
void ask(const Question& q) 
Now only the address is passed to the function. A reference is really 
a pointer in disguise. No slicing occurs, and virtual functions work 
correctly. 
 
 
 
 
 
 

 
 
 
 
 
 
Advanced Topic 10.2 
 
 
 
 
 
ADVACED TOPIC 10.2 Virtual Self-Calls 
 
 
Suppose we add the following function to the Question class:  
void Question::ask() const 
{ 
   display(); 
   cout << "Your answer: "; 
   getline(cin, response); 
   cout << check_answer(response) << endl; 
} 
Now consider the call  
ChoiceQuestion cq; 
cq.set_text("In which country was the inventor of C++ 
born?"); 
. . . 
cq.ask(); 
Which display and check_answer function will the ask 
function call? If you look inside the code of the Question::ask 
function, you can see that these functions are executed on the 
implicit parameter.  
void Question::ask() const 
{ 
   implicit parameter.display(); 
   cout << "Your answer: "; 
   getline(cin, response); 
   cout << implicit 
parameter.check_answer(response) << endl; 
} 
The implicit parameter in our call is cq, an object of type 
ChoiceQuestion. Because the display and check_answer 
functions are virtual, the ChoiceQuestion versions of the 
functions are called automatically. This happens even though the ask 
function is defined in the Question class, which has no knowledge 
of the ChoiceQuestion class. 
 
As you can see, virtual functions are a very powerful mechanism. 
The Question class supplies an ask function that specifies the 
common nature of asking a question, namely to display it and check 
the response. How the displaying and checking are carried out is left 
to the derived classes. 
 

 
 
 
 
 
 
 
 
 
 
 
How To 10.1 
 
 
 
 
 
HOW TO 10.1 Developing an Inheritance Hierarchy 
 
 
When you work with a set of classes, some of which are more 
general and others more specialized, you want to organize them into 
an inheritance hierarchy. This enables you to process objects of 
different classes in a uniform way. 
 
As an example, we will consider a bank that offers its customers the 
following account types:  
•  A savings account that earns interest. The interest compounds 
monthly and is computed on the minimum monthly balance . 
 
•  A checking account that has no interest, gives you three free 
withdrawals per month, and charges a $1 transaction fee for 
each additional withdrawal . 
 
The program will manage a set of accounts of both types, and it 
should be structured so that other account types can be added 
without affecting the main processing loop. Supply a menu  
D)eposit W)ithdraw M)onth end Q)uit 
For deposits and withdrawals, query the account number and 
amount. Print the balance of the account after each transaction. 
 
In the “Month end” command, accumulate interest or clear the 
transaction counter, depending on the type of the bank account. Then 
print the balance of all accounts.  
Step 1   List the classes that are part of the hierarchy. 
In our case, the problem description yields two classes: 
SavingsAccount and CheckingAccount. To 
express the commonality between them, we will 
introduce a class BankAccount. 
 
Step 2   Organize the classes into an inheritance hierarchy. 
Draw a UML diagram that shows base and derived 
classes. Here is the diagram for our example.  
 
 
 

 
 
 
 
Step 3   Determine the common responsibilities. 
In Step 2, you will have identified a class at the base of 
the hierarchy. That class needs to have sufficient 
responsibilities to carry out the tasks at hand. 
To find out what those tasks are, write pseudocode for 
processing the objects.  
For each user command 
{ 
    If it is a deposit or withdrawal 
    { 
        Deposit or withdraw the amount from 
the specified account. 
        Print the balance. 
    } 
    If it is month end processing 
    { 
        For each account 
        { 
            Call month end processing. 
            Print the balance. 
        } 
    } 
} 
From the pseudocode, we obtain the following list of 
common responsibilities that every bank account must 
carry out:  
Deposit money. 
Withdraw money. 
Get the balance. 
Carry out month end processing. 
 
Step 4   Decide which functions are overridden in derived classes. 
For each derived class and each of the common 
responsibilities, decide whether the behavior can be 
inherited or whether it needs to be overridden. Declare 
any functions that are overridden as virtual in the root 
of the hierarchy. 
Getting the balance is common to all account types. 
Withdrawing and end of month processing are different 
for the derived classes, so they need to be declared 
virtual. Because it is entirely possible that some 

future account type will levy a fee for deposits, it seems 
prudent to declare the deposit member function virtual 
as well.  
class BankAccount 
{ 
public: 
   virtual void deposit(double amount); 
   virtual void withdraw(double amount); 
   virtual void month_end(); 
   double get_balance() const; 
private: 
   . . . 
}; 
 
Step 5   Define the public interface of each derived class. 
Typically, derived classes have responsibilities other than 
those of the base class. List those, as well as the member 
functions that need to be overridden. You also need to 
specify how the objects of the derived classes should be 
constructed. 
In this example, we need a way of setting the interest rate 
for the savings account. In addition, we need to specify 
constructors and overridden functions.  
class SavingsAccount : public BankAccount 
{ 
public: 
   /** 
         Constructs a savings account with a 
zero balance. 
     */ 
   SavingsAccount(); 
    
   /** 
         Sets the interest rate for this 
account. 
         @param rate the monthly interest rate 
in percent 
     */ 
   void set_interest_rate(double rate); 
    
   virtual void withdraw(double amount); 
   virtual void month_end(); 
private: 
   . . . 
}; 
 
class CheckingAccount : public BankAccount 
{ 
public: 
   /** 
         Constructs a checking account with a 
zero balance. 
     */ 
   CheckingAccount(); 
     

   virtual void withdraw(double amount); 
   virtual void month_end(); 
private: 
   . . . 
}; 
 
Step 6   Identify data members. 
List the data members for each class. If you find a data 
member that is common to all classes, be sure to place it 
in the base of the hierarchy. 
All accounts have a balance. We store that value in the 
BankAccount base class.  
class BankAccount 
{ 
    . . . 
private: 
   double balance; 
}; 
The SavingsAccount class needs to store the interest 
rate. It also needs to store the minimum monthly balance, 
which must be updated by all withdrawals.  
class SavingsAccount : public BankAccount 
{ 
   . . . 
private: 
   double interest_rate; 
   double min_balance; 
}; 
The CheckingAccount class needs to count the 
withdrawals, so that the charge can be applied after the 
free withdrawal limit is reached.  
class CheckingAccount : public BankAccount 
{ 
   . . . 
private: 
   int withdrawals; 
}; 
 
Step 7   Implement constructors and member functions. 
The member functions of the BankAccount class 
update or return the balance.  
BankAccount::BankAccount() 
{ 
   balance = 0; 
} 
 
void BankAccount::deposit(double amount) 
{ 
   balance = balance + amount; 
} 
 
void BankAccount::withdraw(double amount) 
{ 
   balance = balance - amount; 
} 

double BankAccount::get_balance() const 
{ 
   return balance; 
} 
At the level of the BankAccount base class, we can say 
nothing about end of month processing. We choose to 
make that function do nothing.  
void BankAccount::month_end() 
{ 
} 
In the withdraw member function of the 
SavingsAccount class, the minimum balance is 
updated. Note the call to the base-class member function.  
void SavingsAccount::withdraw(double amount) 
{ 
   BankAccount::withdraw(amount); 
   double balance = get_balance(); 
   if (balance < min_balance) 
   { 
      min_balance = balance; 
   } 
} 
In the month_end member function of the 
SavingsAccount class, the interest is deposited into 
the account. We must call the deposit member 
function since we have no direct access to the balance 
data member. The minimum balance is reset for the next 
month.  
void SavingsAccount::month_end() 
{ 
   double interest = min_balance * 
interest_rate / 100; 
   deposit(interest); 
   min_balance = get_balance(); 
} 
The withdraw function of the CheckingAccount 
class needs to check the withdrawal count. If there have 
been too many withdrawals, a charge is applied. Again, 
note how the function invokes the base-class function, 
using the BankAccount:: syntax.  
void CheckingAccount::withdraw(double amount) 
{ 
   const int FREE_WITHDRAWALS = 3; 
   const int WITHDRAWAL_FEE = 1; 
    
   BankAccount::withdraw(amount); 
   withdrawals++; 
   if (withdrawals > FREE_WITHDRAWALS) 
   { 
      BankAccount::withdraw(WITHDRAWAL_FEE); 
   } 
} 
End of month processing for a checking account simply 

resets the withdrawal count.  
void CheckingAccount::month_end() 
{ 
   withdrawals = 0; 
} 
 
Step 8   Allocate objects on the heap and process them. 
For polymorphism (that is, variation of behavior) to work 
in C++, you need to call virtual functions through 
pointers. The easiest strategy is to allocate all 
polymorphic objects on the heap, using the new operator. 
In our sample program, we allocate 5 checking accounts 
and 5 savings accounts and store their addresses in an 
array of bank accounts. Then we accept user commands 
and execute deposits, withdrawals, and monthly 
processing.  
int main() 
{ 
   cout << fixed << setprecision(2); 
 
   // Create accounts 
   const int ACCOUNTS_SIZE = 10; 
   BankAccount* accounts[ACCOUNTS_SIZE]; 
   for (int i = 0; i < ACCOUNTS_SIZE / 2; i++) 
   { 
      accounts[i] = new CheckingAccount; 
   } 
   for (int i = ACCOUNTS_SIZE / 2; 
i < ACCOUNTS_SIZE; i++) 
   { 
      SavingsAccount* account = new 
SavingsAccount; 
      account->set_interest_rate(0.75); 
      accounts[i] = account; 
   } 
 
   // Execute commands 
   bool more = true; 
   while (more) 
   { 
      cout << "D)eposit W)ithdraw M)onth end 
Q)uit: "; 
      string input; 
      cin >> input; 
      if (input == "D" || input == "W") // 
Deposit or withdrawal 
      { 
         cout << "Enter account number and 
amount: "; 
         int num; 
         double amount; 
         cin >> num >> amount; 
        
         if (input == "D") accounts[num]-
>deposit(amount); 

         else { accounts[num]-
>withdraw(amount); } 
        
         cout << "Balance: " << accounts[num]-
>get_balance() << endl; 
      } 
      else if (input == "M") // Month end 
processing 
      {  
         for (int n = 0; n < ACCOUNTS_SIZE(); 
n++) 
         { 
            accounts[n]->month_end(); 
            cout << n << " " << accounts[n]-
>get_balance() << endl; 
         } 
      } 
      else if (input == "Q") 
      { 
         more = false; 
      }           
   } 
 
   return 0; 
 
} 
 
See ch10/accounts.cpp 
for the complete 
program. 
 
 
 
 
 
 
 
 
 
 
 
Worked Example 10.1
 
 
 
 
 
WORKED EXAMPLE 10.1 Implementing an Employee Hierarchy 
for Payroll Processing 
 
 
Your task is to implement payroll processing for different kinds of 
employees.  
•  Hourly employees get paid an hourly rate, but if they work more 
than 40 hours per week,the excess is paid at "time and a half" . 
 
•  Salaried employees get paid their salary, no matter how many 
hours they work . 
 
•  Managers are salaried employees who get paid a salary and a 
bonus . 
 
 

Your program should compute the pay for a collection of employees. 
For each employee, ask for the number of hours worked in a given 
week, then display the wages earned.  
Step
1  
List the classes that are part of the hierarchy. 
In our case, the problem description lists three classes: 
HourlyEmployee, SalariedEmployee, and 
Manager. We need a class that expresses the 
commonality between them: Employee. 
 
Step
2  
Organize the classes into an inheritance hierarchy. 
Here is the UML diagram for our classes.  
 
 
 
 
 
Step
3  
Determine the common responsibilities of the classes. 
In order to discover the common responsibilities, write 
pseudocode for processing the objects.  
For each employee 
{ 
   Print the name of the employee. 
   Read the number of hours worked. 
   Compute the wages due for those hours. 
} 
We conclude that the Employee base class has these 
responsibilities:  
Get the name. 
Compute the wages due for a given number of 
hours. 
 
Step
4  
Decide which functions are overridden in derived classes. 
In our example, there is no variation in getting the 
employee's name, but the salary is computed differently in 
each derived class. Therefore, we will declare the 
weekly_pay member function as virtual in the 
Employee class.  
class Employee 

{ 
public: 
   Employee(); 
   string get_name() const; 
   virtual double weekly_pay(int hours_worked) 
const; 
   . . . 
private: 
   . . . 
}; 
 
Step
5  
Define the public interface of each class. 
We will construct employees by supplying their name and 
salary information.  
HourlyEmployee(string name, double wage); 
SalariedEmployee(string name, double salary); 
Manager(string name, double salary, double 
bonus); 
These constructors need to set the name of the Employee 
base object. We will supply an Employee member 
function set_name for this purpose. In this simple 
example, no further member functions are required. 
 
Step
6  
Identify data members. 
List the data members for each class. If you find a data 
member that is common to all classes, be sure to place it in 
the base of the hierarchy. 
All employees have a name. Therefore, the Employee 
class should have a data member name. (See Figure 1.) 
What about the salaries? Hourly employees have an hourly 
wage, whereas salaried employees have an annual salary. 
While it would be possible to store these values in a data 
member of the base class, it would not be a good idea. The 
resulting code, which would need to make sense of what 
that number means, would be complex and error-prone. 
 
 
 

 
 
 
  Figure 1   Employee Payroll Hierarchy 
 
 
 
 
Step
7  
Implement constructors and member functions. 
In a derived-class constructor, we need to remember to set 
the data members of the base class.  
SalariedEmployee::SalariedEmployee(string name, 
double salary) 
{ 
   set_name(name); 
   annual_salary = salary; 
} 
Here we use a member function. Advanced Topic 10.1 on 
page 427 shows how to invoke a base-class constructor. 
We use that technique in the Manager constructor:  
Manager::Manager(string name, double salary, 
double bonus) 
   : SalariedEmployee(name, salary) 
{ 
   weekly_bonus = bonus; 
} 
The weekly pay needs to be computed as specified in the 
problem description:  
double HourlyEmployee::weekly_pay(int 
hours_worked) const 
{ 
   double pay = hours_worked * hourly_wage; 
   if (hours_worked > 40) 
   { 
      pay = pay + ((hours_worked - 40) * 0.5) * 
hourly_wage; 
 
   } 
   return pay; 
} 

 
double SalariedEmployee::weekly_pay(int 
hours_worked) const 
{ 
   const int WEEKS_PER_YEAR = 52; 
   return annual_salary / WEEKS_PER_YEAR; 
} 
In the case of the Manager, we need to call the version 
from the SalariedEmployee base class:  
double Manager::weekly_pay(int hours) const 
{ 
   return 
SalariedEmployee::weekly_pay(hours) + weekly_bo
nus; 
} 
 
Step
8  
Allocate objects on the heap and process them. 
In our sample program, we populate a vector of pointers 
and compute the weekly salaries:  
vector<Employee*> staff; 
staff.push_back(new HourlyEmployee("Morgan, 
Harry", 30)); 
. . . 
for (int i = 0; i < staff.size(); i++) 
{ 
   cout << "Hours worked by " << staff[i]-
>get_name() << ": "; 
   int hours; 
   cin >> hours; 
   cout << "Salary: " << staff[i]-
>weekly_pay(hours) << endl; 
} 
The complete code for this program is contained in 
ch10/salaries.cpp. 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 
Random Fact 10.1 
 
 
 
 
 
RANDOM FACT 10.1 The Limits of Computation 
 
 
Have you ever wondered how your instructor or grader makes sure your 
programming homework is correct? In all likelihood, they look at your 
solution and perhaps run it with some test inputs. But usually they have a 
correct solution available. That suggests that there might be an easier way. 
Perhaps they could feed your program and their correct program into a 
“program comparator”, a computer program that analyzes both programs 
and determines whether they both compute the same results. Of course, your 
solution and the program that is known to be correct need not be identical–
what matters is that they produce the same output when given the same 
input. 
 
How could such a program comparator work? Well, the C++ compiler 
knows how to read a program and make sense of the classes, functions, and 
statements. So it seems plausible that someone could, with some effort, 
write a program that reads two C++ programs, analyzes what they do, and 
determines whether they solve the same task. Of course, such a program 
would be very attractive to instructors, because it could automate the 
grading process. Thus, even though no such program exists today, it might 
be tempting to try to develop one and sell it to universities around the world. 
 
However, before you start raising venture capital for such an effort, you 
should know that theoretical computer scientists have proven that it is 
impossible to develop such a program, no matter how hard you try. 
 
There are quite a few of these unsolvable problems. The first one, called the 
halting problem, was discovered by the British researcher Alan Turing in 
1936 (see Figure 7). Because his research occurred before the first actual 
computer was constructed, Turing had to devise a theoretical device, the 
Turing machine, to explain how computers could work. The Turing machine 
consists of a long magnetic tape, a read/write head, and a program that has 
numbered instructions of the form: “If the current symbol under the head is 
x, then replace it with y, move the head one unit left or right, and continue 
with instruction n” (see Figure 8). Interestingly enough, with just these 
 

instructions, you can program just as much as with C++, even though it is 
incredibly tedious to do so. Theoretical computer scientists like Turing 
machines because they can be described using nothing more than the laws of 
mathematics. 
 
 
 
 
 
   Figure 7   Alan Turing 
 
 
Science Photo Library/Photo Researchers, Inc. 
 
 
 
 
 
 
 

  Figure 8   A Turing Machine
 
 
 
Expressed in terms of C++, the halting problem states: “It is impossible to 
write a program with two inputs, namely the source code of an arbitrary 
C++ program P and a string I, that decides whether the program P, when 
executed with the input I, will halt without getting into an infinite loop”. Of 
course, for some kinds of programs and inputs, it is possible to decide 
whether the programs halt with the given input. The halting problem asserts 
that it is impossible to come up with a single decision-making algorithm that 
works with all programs and inputs. Note that you can't simply run the 
program P on the input I to settle this question. If the program runs for 1,000 
days, you don't know that the program is in an infinite loop. Maybe you just 
have to wait another day for it to stop. 
 
Such a “halt checker”, if it could be written, might also be useful for grading 
homework. An instructor could use it to screen student submissions to see if 
they get into an infinite loop with a particular input, and then not check them 
any further. However, as Turing demonstrated, such a program cannot be 
written. His argument is ingenious and quite simple. 
 
Suppose a “halt checker” program existed. Let's call it H. From H, we will 
develop another program, the “killer” program K. K does the following 
computation. Its input is a string containing the source code for a program R. 
It then applies the halting checker on the input program R and the input 
string R. That is, it checks whether the program R halts if its input is its own 
source code. It sounds bizarre to feed a program to itself, but it isn't 
impossible. For example, the C++ compiler is written in C++, and you can 
use it to compile itself. Or, as a simpler example, you can use a word count 
program to count the words in its own source code. 
 
When K gets the answer from H that R halts when applied to itself, it is 
programmed to enter an infinite loop. Otherwise K exits. In C++, the 
program might look like this:  
int main() 
{ 
   string r = read program input; 
   HaltChecker checker; 
   if (checker.check(r, r)) 
   { 
      while (true) // Infinite loop 
   } 
   else 
   { 
      return 0; 
   } 
} 
Now ask yourself: What does the halt checker answer when asked if K halts 
when given K as the input? Maybe it finds out that K gets into an infinite 

loop with such an input. But wait, that can&’t be right. That would mean 
that checker.check(r, r) returns false when r is the program code of 
K. As you can plainly see, in that case, the main function returns, so K 
didn't get into an infinite loop. That shows that K must halt when analyzing 
itself, so checker.check(r, r) should return true. But then the 
main function doesn't terminate–it goes into an infinite loop. That shows 
that it is logically impossible to implement a program that can check 
whether every program halts on a particular input. 
 
It is sobering to know that there are limits to computing. There are problems 
that no computer program, no matter how ingenious, can answer. 
 
Theoretical computer scientists are working on other research involving the 
nature of computation. One important question that remains unsettled to this 
day deals with prob-lems that in practice are very time-consuming to solve. 
It may be that these problems are intrinsically hard, in which case it would 
be pointless to try to look for better algorithms. Such theoretical research 
can have important practical applications. For example, right now, nobody 
knows whether the most common encryption schemes used today could be 
broken by discovering a new algorithm (see Random Fact 8.1 for more 
information on encryption algorithms). Knowing that no fast algorithms 
exist for breaking a particular code could make us feel more comfortable 
about the security of encryption. 
 
 
 
 
 
 
 
 
Chapter Summary 
 
 
 
 

 
 
Tony Tremblay/iStockphoto (vehicle); Peter Dean/iStockphoto (motorcycle); 
nicholas belton/iStockphoto (car); Robert Pernell/iStockphoto (truck); Clay 
Blackburn/iStockphoto (sedan); iStockphoto (SUV). 
 
 
1.   A derived class inherits data and behavior from a base class. 
 
2.   You can always use a derived class object in place of a base class object. 
 
3.   A derived class can override a base class function by providing a new 
implementation. 
 
4.   The derived class inherits all data members and all functions that it does not 
override.  
 
 
 
Ivan Cholavov/iStockphoto. 
 
 
 
 
5.   Unless specified otherwise, the base-class data members are initialized with the 
default constructor. 
 
6.   The constructor of a derived class can pass parameters to a base-class 
constructor. 
 
7.   Use BaseClass::function notation to explicitly call a base-class function. 
 
8.   When converting a derived class object to a base class, the derived class data is 
sliced away. 
 
9.   A derived-class pointer can be converted to a base-class pointer. 
 
10.  When a virtual function is called, the version belonging to the actual type of the 
implicit parameter is invoked.  
 
Aleksandr Popov/iStockphoto.
 
 
11.  Polymorphism (literally, “having multiple shapes”) describes objects that share 
a set of tasks and execute them in different ways. 
 
 
 
 

 
 
Review Exercises 
 
 
Exercise R10.1.     
Identify the base class and the derived class in each of the following pairs of classes. 
(a)   Employee, Manager
 
(b)  Polygon, Triangle
 
(c)   GraduateStudent, Student
 
(d)  Person, Student
 
(e)   Employee, Professor
 
(f)   BankAccount, CheckingAccount
 
(g)  Vehicle, Car 
 
(h)  Vehicle, Minivan
 
(i)   Car, Minivan 
 
(j)   Truck, Vehicle 
 
 
 
Exercise R10.2.     
What inheritance relatioanships would you establish among the following classes?  
 
Student 
Professor
TeachingAssistant
Employee
Secretary
DepartmentChair 
Janitor 
Person
Course 
Seminar
Lecture 
LabCourse
 
 
 
 
 
Exercise R10.3.     
An object-oriented traffic simulation system has the following classes:  
 
Vehicle
PickupTruck
Car 
SportUtilityVehicle
Truck
Minivan
Sedan
Bicycle
Coupe
Motorcycle
 
 
 
Draw a UML diagram that shows the inheritance relationships between these 
classes. 
 
Exercise R10.4.     
What inheritance relationships would you establish among the following classes?  

 
Student
Professor
Employee
Secretary
DepartmentChair
Janitor
Person
  
 
 
 
 
 
Exercise R10.5.     
Draw a UML diagram that shows the inheritance and aggregation relationships 
between the classes:  
 
Person
Employee
Student
Instructor
Course
  
 
 
 
 
 
Exercise R10.6.     
Consider a program for managing inventory in a small appliance store. Why isn't it 
useful to have a base class SmallAppliance and derived classes Toaster, 
CarVacuum, TravelIron, and so on? 
 
Exercise R10.7.     
Which functions does the SavingsAccount class in How To 10.1 on page 442 
inherit from its base class? Which functions does it override? Which functions does 
it add? 
 
Exercise R10.8.     
Which data members does the CheckingAccount class in How To 10.1 on page 
442 inherit from its base class? Which data members does it add? 
 
Exercise R10.9.     
Design an inheritance hierarchy for geometric shapes: rectangles, squares, and 
circles. Draw a UML diagram. Provide a virtual function to compute the area of a 
shape. Provide appropriate constructors for each class. Write the class definitions 
but do not provide implementations of the member functions. 
 
Exercise R10.10.     
Continue Exercise R10.9. by writing a main function that executes the following 
steps:  
Fill a vector of shape pointers with a rectangle, a square, and a 
circle. 
Print the area of each shape. 
Deallocate all heap objects. 
 
Exercise R10.11.     
Can you convert a base-class object into a derived-class object? A derived-class 
object into a base-class object? A base-class pointer into a derived-class pointer? A 
derived-class pointer into a base-class pointer? If so, give examples. If not, explain 
why not. 
 

Exercise R10.12.     
Consider a function process_file(ostream& str). Objects from which of 
the classes in Figure 2 can be passed as parameters to this function? 
 
Exercise R10.13.     
What does the following program print?  
class B 
{ 
public: 
   void print(int n) const; 
}; 
 
void B::print(int n) const 
{ 
   cout << n << endl; 
} 
 
class D : public B 
{ 
public: 
   void print(int n) const; 
}; 
 
void D::print(int n) const 
{ 
   if (n < = 1) B::print(n); 
   else if (n % 2 == 0) print(n / 2); 
   else print(3 * n + 1); 
} 
 
int main() 
{ 
   D d; 
   d.print(3); 
   return 0; 
} 
Determine the answer by hand, not by compiling and running the program. 
 
Exercise R10.14.     
Suppose the class D inherits from B. Which of the following assignments are legal? 
 
B b; 
 
D d; 
 
B* pb; 
 
D* pd; 
 
(a)   b = d; 
 
(b)  d = b; 
 
(c)   pd = pb; 
 

(d)  pb = pd; 
 
(e)   d = pd; 
 
(f)   b = *pd; 
 
(g)  *pd = *pb; 
 
 
 
Exercise R10.15.     
Suppose the class Sub is derived from the class Sandwich. Which of the 
following assignments are legal?  
(a)   Sandwich* x = new Sandwich(); 
 
(b)  Sub* y = new Sub(); 
 
(c)   x = y; 
 
(d)  y = x; 
 
(e)   y = new Sandwich(); 
 
(f)   x = new Sub(); 
 
(g)  *x = *y; 
 
(h)  *y = *x; 
 
 
 
Exercise R10.16.     
What does the program print? Explain your answers by tracing the flow of each call. 
class B 
{ 
public: 
   B(); 
   virtual void p() const; 
   void q() const; 
}; 
 
B::B() {} 
void B::p() const { cout << "B::p\n"; } 
void B::q() const { cout << "B::q\n"; } 
 
class D : public B 
{ 
public: 
   D(); 
   virtual void p() const; 
   void q() const; 
}; 
 
D::D(){} 
void D::p() const { cout << "D::p\n"; } 
void D::q() const { cout << "D::q\n"; } 
 
int main() 
{ 
   B b; 
   D d; 
   B* pb = new B; 
   B* pd = new D; 
   D* pd2 = new D; 
 

   b.p(); b.q(); 
   d.p(); d.q(); 
   pb->p(); pb->q(); 
   pd->p(); pd->q(); 
   pd2->p(); pd2->q(); 
   return 0; 
} 
 
Exercise R10.17.     
Using the Employee class from Worked Example 10.1: (ch10/salaries.cpp 
in your code files), form a subclass Volunteer of Employee and 
provide a constructor Volunteer(string name) that sets the salary to 0. 
 
Exercise R10.18.     
In the accounts.cpp 
program of How To 10.1, would it be reasonable to 
make the get_balance function virtual? Explain your reasoning. 
 
Exercise R10.19.     
What is the effect of declaring the display member function virtual only in the 
ChoiceQuestion class? 
 
 
 
 
Programming Exercises 
 
 
Exercise P10.1.     
Add a class NumericQuestion to the question hierarchy of Section 10.1. If the 
response and the expected answer differ by no more than 0.01, then accept it as 
correct. 
 
Exercise P10.2.     
Add a class FillInQuestion to the question hierarchy of Section 10.1. Such a 
question is constructed with a string that contains the answer, surrounded by _ _, for 
example, "The inventor of C++ was _Bjarne Stroustrup_". The 
question should be displayed as  
The inventor of C++ was ___ 
 
Exercise P10.3.     
Modify the check_answer member function of the Question class so that it 
does not take into account different spaces or upper/lowercase characters. For 
example, the response " bjarne stroustrup"; should match an answer of 
"Bjarne Stroustrup".  
 
Exercise P10.4.     
Add a class MultiChoiceQuestion to the question hierarchy of Section 10.1 
that allows multiple correct choices. The respondent should provide any one of the 
correct choices. The answer string should contain all of the correct choices, 
separated by spaces. 
 

Exercise P10.5.     
Add a class ChooseAllCorrect to the question hierarchy of Section 10.1 that 
allows multiple correct choices. The respondent should provide all correct choices, 
separated by spaces. 
 
Exercise P10.6.     
Add a member function add_text to the Question base class and provide a 
different implementation of ChoiceQuestion that calls add_text rather than 
storing a vector of choices. 
 
Exercise P10.7.     
Change the CheckingAccount class in How To 10.1 so that a $1 fee is levied for 
deposits or withdrawals in excess of three free monthly transactions. Place the code 
for computing the fee into a private member function that you call from the 
deposit and withdraw member functions. 
 
Exercise P10.8.     
Derive a class Programmer from Employee. Supply a constructor 
Programmer(string name, double salary) that calls the base-class 
constructor. Supply a function get_name that returns the name in the format 
"Hacker, Harry (Programmer)". 
 
Exercise P10.9.     
Implement a base class Person. Derive classes Student and Instructor from 
Person. A person has a name and a birthday. A student has a major, and an 
instructor has a salary. Write the class definitions, the constructors, and the member 
functions display for all classes. 
 
Exercise P10.10.     
Derive a class Manager from Employee. Add a data member named 
department of type string. Supply a function display that displays the 
manager's name, department, and salary. Derive a class Executive from 
Manager. Supply a function display that displays the string Executive, 
followed by the information stored in the Manager base object. 
 
Exercise P10.11.     
Implement a base class Account and derived classes Savings and Checking. 
In the base class, supply member functions deposit and withdraw. Provide a 
function daily_interest that computes and adds the daily interest. For 
calculations, assume that every month has 30 days. Checking accounts yield interest 
of 3 percent annually on balances over $1,000. Savings accounts yield interest of 6 
percent annually on the entire balance. Write a driver program that makes a month's 
worth of deposits and withdrawals and calculates the interest every day. 
 
Exercise P10.12.     
Implement a base class Appointment and derived classes Onetime, Daily, 
Weekly, and Monthly. An appointment has a description (for example, “see 
the dentist”) and a date and time. Write a virtual function occurs_on(int 
year, int month, int day) that checks whether the appointment occurs 
on that date. For example, for a monthly appointment, you must check whether the 

day of the month matches. Then fill a vector of Appointment* with a mixture of 
appointments. Have the user enter a date and print out all appointments that happen 
on that date. 
 
Exercise P10.13.     
Improve the appointment book program of Exercise P10.12.. Give the user the 
option to add new appointments. The user must specify the type of the appointment, 
the description, and the date and time. 
 
Exercise P10.14.     
Improve the appointment book program of Exercise P10.12. and P Exercise P10.13. 
by letting the user save the appointment data to a file and reload the data from a file. 
The saving part is straightforward: Make a virtual function save. Save out the type, 
description, date, and time. The loading part is not so easy. You must first determine 
the type of the appointment to be loaded, create an object of that type with its default
constructor, and then call a virtual load function to load the remainder. 
 
Exercise P10.15.     
Use polymorphism to carry out image manipulations such as those described in 
Exercise P8.10 and P8.11. Design a base class Effect and derived classes 
Sunset and Grayscale. Use a virtual function process. The file processing 
part of your program should repeatedly call process on an Effect* pointer, 
without having to know which effect is applied. 
 
 
 
 
Answers to Self-Check Questions 
 
 
1.  Because every manager is an employee but not the other way around, the Manager
class is more specialized. It is the derived class, and Employee is the base class. 
 
 
2.  CheckingAccount and SavingsAccount both inherit from the more general 
class BankAccount. 
 
 
3.  istream, istringstream, ifstream, iostream, fstream 
 
 
4.  Vehicle, truck, motorcycle 
 
 
5.  It shouldn't. A quiz isn't a question; it has questions. 
 
 
6.  a, b, d 
 
 
7.  class Manager : public Employee 
{ 
private: 
   double bonus; 
} 
 
 
8.  name, base_salary, and bonus
 
 
9.  class Manager : public Employee 
{ 
public: 
   double get_salary() const; 
} 
 
 

10.  get_name, set_name, set_base_salary
 
 
11.  The function is not allowed to access the text member from the base class. 
 
 
12.  The type of the this pointer is ChoiceQuestion*. Therefore, the display 
function of ChoiceQuestion is selected, and the function calls itself. 
 
 
13.  Because there is no ambiguity. The derived class doesn't have a set_answer 
function. 
 
 
14.  string Manager::get_name() const 
{ 
   return "*" + Employee::get_name(); 
} 
 
 
15.  double Manager::get_salary() const 
{ 
   return Employee::get_salary() + bonus; 
} 
 
 
16.  The type of quiz[1] is Question*, and the Question class has no member 
function called add_choice. 
 
 
17.  a and d are legal. 
 
 
18.  a and d are legal. 
 
 
19.  Only the question text, not the choices. The choices are sliced away when *p is 
assigned to the object q. 
 
 
20.  It wouldn't change. The function is never overridden in the classes used in our test 
program. 
 
 
 
 
 
 
 
 
 

Worked Example 10.1
•
Implementing an Employee Hierarchy for Payroll 
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Implementing an Employee Hierarchy for Payroll Processing
Your task is to implement payroll processing for different kinds of employees. 
• Hourly employees get paid an hourly rate, but if they work more than 40 hours per week, 
the excess is paid at “time and a half”.
• Salaried employees get paid their salary, no matter how many hours they work.
• Managers are salaried employees who get paid a salary and a bonus.
Your program should compute the pay for a collection of employees. For each employee, ask
for the number of hours worked in a given week, then display the wages earned.
Step 1
List the classes that are part of the hierarchy.
In our case, the problem description lists three classes: HourlyEmployee, SalariedEmployee,
and Manager. We need a class that expresses the commonality between them: Employee. 
Step 2
Organize the classes into an inheritance hierarchy.
Here is the UML diagram for our classes. 
Step 3
Determine the common responsibilities of the classes.
In order to discover the common responsibilities, write pseudocode for processing the objects.  
For each employee
{
Print the name of the employee.
Read the number of hours worked.
Compute the wages due for those hours.
}
WORKED EXAMPLE 10.1
Hourly
Employee
Salaried
Employee
Manager
Employee

2
C++ for Everyone  •  CHAPTER 10
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
We conclude that the Employee base class has these responsibilities:
Get the name.
Compute the wages due for a given number of hours.
Step 4
Decide which functions are overridden in derived classes.
In our example, there is no variation in getting the employee’s name, but the salary is com-
puted differently in each derived class. Therefore, we will declare the weekly_pay member
function as virtual in the Employee class.
class Employee
{
public:
   Employee();
   string get_name() const;
   virtual double weekly_pay(int hours_worked) const;
   ...
private:
   ...
};
Step 5
Deﬁne the public interface of each class.
We will construct employees by supplying their name and salary information.
HourlyEmployee(string name, double wage);
SalariedEmployee(string name, double salary);
Manager(string name, double salary, double bonus);
These constructors need to set the name of the Employee base object. We will supply an
Employee member function set_name for this purpose. In this simple example, no further
member functions are required. 
Step 6
Identify data members.
List the data members for each class. If you ﬁnd a data member that is common to all classes,
be sure to place it in the base of the hierarchy. 
All employees have a name. Therefore, the Employee class should have a data member
name. (See Figure 1.) What about the salaries? Hourly employees have an hourly wage,
whereas salaried employees have an annual salary. While it would be possible to store these
values in a data member of the base class, it would not be a good idea. The resulting code,
which would need to make sense of what that number means, would be complex and error-
prone. 
Step 7
Implement constructors and member functions.
In a derived-class constructor, we need to remember to set the data members of the base
class. 
SalariedEmployee::SalariedEmployee(string name, double salary)
{
   set_name(name);
   annual_salary = salary;
}

Worked Example 10.1
•
Implementing an Employee Hierarchy for Payroll 
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
Here we use a member function. Advanced Topic 10.1 on page 427 shows how to invoke a
base-class constructor. We use that technique in the Manager constructor:
Manager::Manager(string name, double salary, double bonus)
   : SalariedEmployee(name, salary)
{
   weekly_bonus = bonus;
}
The weekly pay needs to be computed as speciﬁed in the problem description:
double HourlyEmployee::weekly_pay(int hours_worked) const
{
   double pay = hours_worked * hourly_wage;
   if (hours_worked > 40)
   {
      pay = pay + ((hours_worked - 40) * 0.5) * hourly_wage;
   }
   return pay;
}
double SalariedEmployee::weekly_pay(int hours_worked) const
{
   const int WEEKS_PER_YEAR = 52;
   return annual_salary / WEEKS_PER_YEAR;
}
In the case of the Manager, we need to call the version from the SalariedEmployee base class:
double Manager::weekly_pay(int hours) const
{
Figure 1
Employee Payroll Hierarchy
HourlyEmployee
SalariedEmployee
Manager
Employee
set_name()
get_name()
weekly_pay()
name
weekly_pay()
hourly_wage
weekly_pay()
annual_salary
weekly_pay()
weekly_bonus

4
C++ for Everyone  •  CHAPTER 10
C++ for Everyone, Cay Horstmann, Copyright © 2009 John Wiley & Sons, Inc. All Rights Reserved.
   return SalariedEmployee::weekly_pay(hours) + weekly_bonus;
}
Step 8
Allocate objects on the heap and process them.
In our sample program, we populate a vector of pointers and compute the weekly salaries:
vector<Employee*> staff;
staff.push_back(new HourlyEmployee("Morgan, Harry", 30));
...
for (int i = 0; i < staff.size(); i++)
{
   cout << "Hours worked by " << staff[i]->get_name() << ": ";
   int hours;
   cin >> hours;
   cout << "Salary: " << staff[i]->weekly_pay(hours) << endl;
}
The complete code for this program is contained in ch10/salaries.cpp.

Chapter
   
    
    
Chapter Goals
•  To learn about the method of recursion
•  To understand the relationship between recursion and iteration
•  To analyze problems that are much easier to solve by recursion than by iteration
•  To learn to “think recursively”
•  To be able to use recursive helper functions
•  To understand when the use of recursion affects the efficiency of an algorithm
The method of recursion is a powerful technique to break up complex computational problems into simpler ones.
The term “recursion” refers to the fact that the same computation recurs, or occurs repeatedly, as the problem is
solved. Recursion is often the most natural way of thinking about a problem, and there are some computations
that are very difficult to perform without recursion. This chapter shows you both simple and complex examples of
recursion and teaches you how to “think recursively”.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To learn abo ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:44 PM

We begin this chapter with a very simple example that demonstrates the power of thinking recursively. In this example, we will
look at triangle shapes such as this:
We will compute the area of a triangle of width n, assuming that each [] square has area 1. This value is sometimes called the
nth triangle number. For example, as you can tell from looking at the above triangle, the third triangle number is 6.
You may know that there is a very simple formula to compute these numbers, but you should pretend for now that you don't
know about it. The ultimate purpose of this section is not to compute triangle numbers, but to learn about the concept of
recursion in a simple situation.
Here is the outline of the class that we will develop:
If the width of the triangle is 1, then the triangle consists of a single square, and its area is 1. Take care of this case first.
To deal with the general case, consider this picture.
Suppose you knew the area of the smaller, colored triangle. Then you could easily compute the area of the larger triangle as
How can you get the smaller area? Make a smaller triangle and ask it!
Now we can complete the 
 function:
Triangle Numbers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:45 PM

Here is an illustration of what happens when we compute the area of a triangle of width 4.
•  The 
 function makes a smaller triangle of width 3.
•  It calls 
 on that triangle.
•  That function makes a smaller triangle of width 2.
•  It calls 
 on that triangle.
•  That function makes a smaller triangle of width 1.
•  It calls 
 on that triangle.
•  That function returns 1.
•  The function returns 
 = 1 + 2 = 3.
•  The function returns 
 = 3 + 3 = 6.
•  The function returns 
 = 6 + 4 = 10.
This solution has one remarkable aspect. To solve the area problem for a triangle of a given width, we use the fact that we can
solve the same problem for a lesser width. This is called a recursive solution.
A recursive computation solves a problem by using the
solution to the same problem with simpler inputs.
The call pattern of a recursive function looks complicated, and the key to the successful design of a recursive function is not to
think about it. Instead, look at the 
 function one more time and notice how utterly reasonable it is. If the width is 1,
then of course the area is 1. The next part is just as reasonable. Compute the area of the smaller triangle and don't think about
why that works. Then the area of the larger triangle is clearly the sum of the smaller area and the width.
There are two key requirements to make sure that the recursion is successful:
•  Every recursive call must simplify the computation in some way.
•  There must be special cases to handle the simplest computations directly.
The 
 function calls itself again with smaller and smaller width values. Eventually the width must reach 1, and there
is a special case for computing the area of a triangle with width 1. Thus, the 
 function always succeeds.
For a recursion to terminate, there must be special
cases for the simplest inputs.
Actually, you have to be careful. What happens when you call the area of a triangle with width -1? It computes the area of a
triangle with width -2, which computes the area of a triangle with width -3, and so on. To avoid this, the 
 function
should return 0 if the width is ≤ 0.
Recursion is not really necessary to compute the triangle numbers. The area of a triangle equals the sum
Of course, we can program a simple loop:
Triangle Numbers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:45 PM

Many simple recursions can be computed as loops. However, loop equivalents for more complex recursions–such as the one in
our next example–can be complex.
Actually, in this case, you don't even need a loop to compute the answer. The sum of the first n integers can be computed as
Thus, the area equals
Therefore, neither recursion nor a loop are required to solve this problem. The recursive solution is intended as a “warm-up”
for the next section.
ch11/triangle.cpp
A class that describes triangle shapes like this:
Constructs a triangle with a given width.
the width of the triangle base
Computes the area of the triangle shape.
the area
Triangle Numbers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:45 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Triangle Numbers
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:45 PM

Common Error 11.1
COMMON ERROR 11.1 Infinite Recursion
A common programming error is an infinite recursion: a function calling itself over and over with no end in sight.
The computer needs some amount of memory for bookkeeping for each call. After some number of calls, all
memory that is available for this purpose is exhausted. Your program shuts down and reports a “stack fault”.
Infinite recursion happens either because the parameter values don't get simpler or because a terminating case is
missing. For example, suppose the 
 function computes the area of a triangle with width 0. If it weren't
for the special test, the function would have constructed triangles with width -1, -2, -3, and so on.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 11.1 Infinite Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:45 PM

In this section, we consider a more complex example of recursion that would be difficult to program with a simple loop. Our
task is to generate all permutations of a string. A permutation is simply a rearrangement of the letters. For example, the string
 has six permutations (including the original string itself):
We will develop a function
that generates all permutations of a word.
Here is how you would use the function. The following code displays all permutations of the string 
:
Now you need a way to generate the permutations recursively. Consider the string 
 and simplify the problem. First,
generate all permutations that start with the letter 
, then those that start with 
, and finally those that start with 
.
How do you generate the permutations that start with 
? You need to know the permutations of the substring 
. But
that's the same problem–to generate all permutations–with a simpler input, namely the shorter string 
. Using recursion
generates the permutations of the substring 
. You will get the strings
For each result of the simpler problem, add the letter 
 in front. Now you have all permutations of 
 that start with
, namely
e
e
Next, turn your attention to the permutations of 
 that start with 
. You must create the permutations of the
remaining letters, 
, namely:
Add the letter 
 to the front of the strings and obtain
a
a
Generate the permutations that start with 
 in the same way.
That's the idea. To carry it out, you must implement a loop that iterates through the character positions of the word. Each loop
iteration creates a shorter word that omits the current position:
Permutations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:45 PM

The next step is to compute the permutations of the shorter word.
For each of the shorter permutations, add the omitted letter:
The permutation generation algorithm is recursive–it uses the fact that we can generate the permutations of shorter words.
When does the recursion stop? You must build in a stopping point, a special case to handle words of length 1. A word of
length 1 has a single permutation, namely itself. Here is the dded code to handle a word of length 1.
The complete program is at the end of this section.
Could you generate the permutations without recursion? There is no obvious way of writing a loop that iterates through all
permutations. Exercise P11.2. shows that there is an iterative solution, but it is far more difficult to understand than the
recursive algorithm.
For generating permutations, it is much easier to use
recursion than iteration.
ch11/permute.cpp
Permutations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:45 PM

Generates all permutations of the characters in a string.
a string
a vector that is filled with all permutations
of the word
Program Run
arm
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Permutations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:45 PM

Common Error 11.2
COMMON ERROR 11.2 Tracing Through Recursive Functions
Debugging a recursive function can be somewhat challenging. When you set a breakpoint in a recursive function, the program stops as soon as that
program line is encountered in any call to the recursive function. Suppose you want to debug the recursive 
 function of the 
class. Run until the beginning of the 
 function (Figure 1). Inspect the 
 instance variable. It is 4.
Figure 1   Debugging a Recursive Function
Remove the breakpoint and now run until the statement
When you inspect 
 again, its value is 2! That makes no sense. There was no instruction that changed the value of 
 Is that a bug with
the debugger?
No. The program stopped in the first recursive call to 
 that reached the 
 statement. If you are confused, look at the call stack
COMMON ERROR 11.2 Tracing Through Recursive Functions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:46 PM

(Figure 2). You will see that three calls to 
 are pending.
Figure 2   Three Calls to 
 Are Pending
You can debug recursive functions with the debugger. You just need to be particularly careful, and watch the call stack to understand which nested
call you currently are in.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
COMMON ERROR 11.2 Tracing Through Recursive Functions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:46 PM

To solve a problem recursively requires a different mindset than to solve it by programming loops. In fact, it helps if you are,
or pretend to be, a bit lazy and let others do most of the work for you. If you need to solve a complex problem, pretend that
“someone else” will do most of the heavy lifting and solve the problem for all simpler inputs. Then you only need to figure out
how you can turn the solutions with simpler inputs into a solution for the whole problem.
This section gives you a step-by-step guide to the method of recursion. To illustrate the steps, use the following problem to
test whether a sentence is a palindrome—a string that is equal to itself when you reverse all characters. Typical examples of
palindromes are
•  rotor
•  A man, a plan, a canal—Panama!
•  Go hang a salami, I'm a lasagna hog
and, of course, the oldest palindrome of all:
•  Madam, I'm Adam
Our goal is to implement the predicate function
For simplicity, assume for now that the string has only lowercase letters and no punctuation marks or spaces. Exercise P11.13.
asks you to generalize the function to arbitrary strings.
Step 1  
Consider various ways for simplifying inputs.
In your mind, fix a particular input or set of inputs for the problem that you want to solve. Think how you can
simplify the inputs in such a way that the same problem can be applied to the simpler input.
When you consider simpler inputs, you may want to remove just a little bit from the original input–maybe
remove one or two characters from a string, or remove a small portion of a geometric shape. But sometimes it is
more useful to cut the input in half and then see what it means to solve the problem for both halves.
The key step in finding a recursive solution is
reducing the input to a simpler input for the same
problem.
In the palindrome test problem, the input is the string that we need to test. How can you simplify the input? Here
are several possibilities:
•  Remove the first character.
•  Remove the last character.
•  Remove both the first and the last character.
•  Remove a character from the middle.
•  Cut the string into two halves.
These simpler inputs are all potential inputs for the palindrome test.
Step 2  
Combine solutions with simpler inputs to a solution of the original problem.
In your mind, consider the solutions of your problem for the simpler inputs that you have discovered in Step 1.
Don't worry how those solutions are obtained. Simply have faith that the solutions are readily available. Just say
to yourself: These are simpler inputs, so someone else will solve the problem for me.
Now think how you can turn the solution for the simpler inputs into a solution for the input that you are
currently thinking about. Maybe you need to add a small quantity, related to the quantity that you lopped off to
arrive at the simpler input. Maybe you cut the original input in two halves and have solutions for both halves.
Thinking Recursively
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:46 PM

Then you may need to add both solutions to arrive at a solution for the whole.
Consider the methods for simplifying the inputs for the palindrome test. Cutting the string in half doesn't seem a
good idea. If you cut
in half, you get two strings:
and
Neither of them is a palindrome. Cutting the input in half and testing whether the halves are palindromes seems a
dead end.
The most promising simplification is to remove the first and last characters.
Removing the  at the front and back of 
 yields
Suppose you can verify that the shorter string is a palindrome. Then of course the original string is a
palindrome—we put the same letter in the front and the back. That's extremely promising. A word is a
palindrome if
•  The first and last letters match, and
•  The word obtained by removing the first and last letters is a palindrome.
Again, don't worry how the test works for the shorter string. It just works.
Step 3  
Find solutions to the simplest inputs.
A recursive computation keeps simplifying its inputs. Eventually it arrives at very simple inputs. To make sure
that the recursion comes to a stop, you must deal with the simplest inputs separately. Come up with special
solutions for them. That is usually very easy.
However, sometimes you get into philosophical questions dealing with degenerate inputs: empty strings, shapes
with no area, and so on. Then you may want to investigate a slightly larger input that gets reduced to such a
trivial input and see what value you should attach to the degenerate inputs so that the simpler value, when used
according to the rules you discovered in Step 2, yields the correct answer.
Look at the simplest strings for the palindrome test:
•  Strings with two characters
•  Strings with a single character
•  The empty string
You don't have to come up with a special solution for strings with two characters. Step 2 still applies to those
strings—either or both of the characters are removed. But you do need to worry about strings of length 0 and 1.
In those cases, Step 2 can't apply. There aren't two characters to remove.
A string with a single character, such as 
, is a palindrome.
The empty string is a palindrome—it's the same string when you read it backwards. If you find that too artificial,
consider a string 
. According to the rule discovered in Step 2, this string is a palindrome if the first and last
character of that string match and the remainder—that is, the empty string—is also a palindrome. Therefore, it
makes sense to consider the empty string a palindrome.
Thus, all strings of length 0 or 1 are palindromes.
Step 4  
Implement the solution by combining the simple cases and the reduction step.
Now you are ready to implement the solution. Make separate cases for the simple inputs that you considered in
Step 3. If the input isn't one of the simplest cases, then implement the logic you discovered in Step 2.
The following program shows the complete 
 function.
Thinking Recursively
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:46 PM

ch11/palindrome.cpp
Tests whether a string is a palindrome. A palindrome
is equal to its reverse, for example "rotor" or "racecar".
a string
true if
is a palindrome
Separate case for shortest strings
Get first and last character, converted to lowercase
Program Run
You have now seen several recursive algorithms, all of which work on the same principle. When given a complex input, they
first solve the problem with a simpler input. Then they turn the simpler result into the result for the more complex input. This
process is quite intuitive as long as you think about the solution on that level only. However, behind the scenes, the function
that computes the simpler input calls yet another function that works on even simpler input, which calls yet another, and so on,
until one function's input is so simple that it can compute the results without further help. It is interesting to think about that
process, but it can also be confusing. What's important is that you can focus on the one level that matters–putting a solution
together from the slightly simpler problem, ignoring the fact that it also uses recursion to get its results.
When designing a recursive solution, do not worry
Thinking Recursively
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:46 PM

about multiple nested calls. Simply focus on reducing
a problem to a slightly simpler one.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Thinking Recursively
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:46 PM

Sometimes it is easier to find a recursive solution if you change the original problem slightly. Then the original problem can be
solved by calling a recursive helper function.
Sometimes it is easier to find a recursive solution if
you make a slight change to the original problem.
Here is a typical example. Consider the palindrome test of the preceding section. It is a bit inefficient to construct new 
objects in every step. Now consider the following change in the problem. Rather than testing whether the entire sentence is a
palindrome, check whether a substring is a palindrome:
Tests whether a substring of a string is a palindrome.
the string to test
 the index of the first character of the substring
 the index of the last character of the substring
true if the substring is a palindrome
This function turns out to be even easier to implement than the original test. In the recursive calls, simply adjust the 
 and
 parameters to skip over matching letter pairs. There is no need to construct new 
 objects to represent the shorter
strings.
Separate case for substrings of length 0 and 1
Test substring that doesn't contain the first and last letters
You should supply a function to solve the whole problem–the user of your function shouldn't have to know about the trick
with the substring positions. Simply call the helper function with positions that test the entire string:
Note that the 
 function is not recursive. It just calls a recursive helper function.
Use the technique of recursive helper functions whenever it is easier to solve a recursive problem that is slightly different from
the original problem.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Recursive Helper Functions
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:46 PM

In the preceding examples, a function called itself to solve a simpler problem. Sometimes, a set of cooperating functions calls
each other in a recursive fashion. In this section, we will explore a typical situation of such a mutual recursion.
In a mutual recursion, a set of cooperating functions
calls each other repeatedly.
We will develop a program that can compute the values of arithmetic expressions such as
Computing such an expression is complicated by the fact that  and  bind more strongly than  and , and that parentheses
can be used to group subexpressions.
Figure 3 shows a set of syntax diagrams that describes the syntax of these expressions. An expression is either a term, or a sum
or difference of terms. A term is either a factor, or a product or quotient of factors. Finally, a factor is either a number or an
expression enclosed in parentheses.
Figure 3   Syntax Diagrams for Evaluating an Expression
Figure 4 shows how the expressions 
 and 
 are derived from the syntax diagram.
Mutual Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:46 PM

Figure 4   Syntax Trees for Two Expressions
Why do the syntax diagrams help us compute the value of the tree? If you look at the syntax trees, you will see that they
accurately represent which operations should be carried out first. In the first tree, 4 and 5 should be multiplied, and then the
result should be added to 3. In the second tree, 3 and 4 should be added, and the result should be multiplied by 5.
To compute the value of an expression, we implement three functions: 
, 
, and 
.
The 
 function first calls 
 to get the value of the first term of the expression. Then it checks
whether the next input character is one of  or . If so, it calls 
 again and adds or subtracts it.
The 
 function calls 
 in the same way, multiplying or dividing the factor values.
Finally, the 
 function checks whether the next input character is a 
 or a digit. In the latter case, the value is
simply the value of the number. However, if the function sees a parenthesis, the 
 function makes a recursive call
to 
. Thus, the three functions are mutually recursive.
Mutual Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:46 PM

read ")"
Assemble number value from digits
As always with a recursive solution, you need to ensure that the recursion terminates. In this situation, that is easy to see. If
 calls itself, the second call works on a shorter subexpression than the original expression. At each
recursive call, at least some of the characters of the input are consumed, so eventually the recursion must come to an end.
ch11/eval.cpp
Evaluates the next expression found in cin.
the value of the expression
Evaluates the next term found in cin.
the value of the term.
Mutual Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:46 PM

Evaluates the next factor found in cin.
the value of the factor.
Read ")"
Assemble number value from digits
Program Run
1+12*12*12
Mutual Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:46 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Mutual Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:46 PM

As you have seen in this chapter, recursion can be a powerful tool to implement complex algorithms. On the other hand,
recursion can lead to algorithms that perform poorly. In this section, we will analyze the question of when recursion is
beneficial and when it is inefficient.
Occasionally, a recursive solution runs much slower
than its iterative counterpart. However, in most cases,
the recursive solution runs at about the same speed.
The Fibonacci sequence is a sequence of numbers defined by the equation
That is, each value of the sequence is the sum of the two preceding values. The first ten terms of the sequence are
It is easy to extend this sequence indefinitely. Just keep appending the sum of the last two values of the sequence. For example,
the next entry is 34 + 55 = 89.
We would like to write a function that computes fn for any value of n. Suppose we translate the definition directly into a
recursive function:
ch11/fibtest.cpp
Computes a Fibonacci number.
an integer
the nth Fibonacci number
Program Run
The Efficiency of Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:46 PM

6
That is certainly simple, and the function will work correctly. But watch the output closely as you run the test program. For
small input values, the program is quite fast. Even for moderately large values, though, the program pauses an amazingly long
time between outputs. Try out some numbers between 30 and 50 to see this effect.
That makes no sense. Armed with pencil, paper, and a pocket calculator you could calculate these numbers pretty quickly, so it
shouldn't take the computer long.
To determine the problem, insert trace messages into the function:
ch11/fibtrace.cpp
Computes a Fibonacci number.
an integer
the nth Fibonacci number
Program Run
6
The Efficiency of Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:46 PM

Figure 5 shows the call tree.
Figure 5   Call Pattern of the Recursive fib Function
Now it is becoming apparent why the function takes so long. It is computing the same values over and over. For example, the
computation of 
 calls 
 twice and 
 three times. That is very different from the computation you
would do with pencil and paper. There you would just write down the values as they were computed and add up the last two to
get the next one until you reached the desired entry; no sequence value would ever be computed twice.
If you imitate the pencil-and-paper process, then you get the following program.
ch11/fibloop.cpp
Computes a Fibonacci number.
an integer
The Efficiency of Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:46 PM

the nth Fibonacci number
This function runs much faster than the recursive version.
In this example of the 
 function, the recursive solution was easy to program because it exactly followed the mathematical
definition, but it ran far more slowly than the iterative solution, because it computed many intermediate results multiple times.
Can you always speed up a recursive solution by changing it into a loop? Frequently, the iterative and recursive solution have
essentially the same performance. For example, here is an iterative solution for the palindrome test.
This solution keeps two index variables: 
 and 
. The first index starts at the beginning of the string and is advanced
whenever a letter has been matched or a non-letter has been ignored. The second index starts at the end of the string and moves
toward the beginning. When the two index variables meet, then the iteration stops.
Both the iteration and the recursion run at about the same speed. If a palindrome has n characters, the iteration executes the
loop n/2 times. Similarly, the recursive solution calls itself n/2 times, because two characters are removed in each step.
In such a situation, the iterative solution tends to be a bit faster, because each recursive function call takes a certain amount of
processor time. In principle, it is possible for a smart compiler to avoid recursive function calls if they follow simple patterns,
but most compilers don't do that. From that point of view, an iterative solution is preferable.
Often, recursive solutions are easier to understand and implement correctly than their iterative counterparts. There is a certain
The Efficiency of Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:46 PM

elegance and economy of thought to recursive solutions that makes them more appealing. As the computer scientist (and
creator of the GhostScript interpreter for the PostScript graphics description language) L. Peter Deutsch put it: “To iterate is
human, to recurse divine.”
In many cases, a recursive solution is easier to
understand and implement correctly than an iterative
solution.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The Efficiency of Recursion
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:46 PM

1.  A recursive computation solves a problem by using the solution to the same problem with simpler inputs.
2.  For a recursion to terminate, there must be special cases for the simplest inputs.
3.  For generating permutations, it is much easier to use recursion than iteration.
4.  The key step in finding a recursive solution is reducing the input to a simpler input for the same problem.
5.  When designing a recursive solution, do not worry about multiple nested calls. Simply focus on reducing a problem to
a slightly simpler one.
6.  Sometimes it is easier to find a recursive solution if you make a slight change to the original problem.
7.  In a mutual recursion, a set of cooperating functions calls each other repeatedly.
8.  Occasionally, a recursive solution runs much slower than its iterative counterpart. However, in most cases, the
recursive solution runs at about the same speed.
9.  In many cases, a recursive solution is easier to understand and implement correctly than an iterative solution.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:47 PM

Exercise R11.1.    
Define the terms
(a)  recursion
(b)  iteration
(c)  infinite recursion
(d)  mutual recursion
Exercise R11.2.    
The factorial function counts the number of permutations of n objects. It is recursively defined by the equations
n
n
n
and
Following this definition, determine the values for 1! and 2!. Explain why these are the correct counts for permutations of
1 and 2 objects.
Exercise R11.3.    
Outline, but do not implement, a recursive solution for finding the smallest value in an array.
Exercise R11.4.    
Outline, but do not implement, a recursive solution for sorting an array of numbers. Hint: First find the smallest value in
the array.
Exercise R11.5.    
Outline, but do not implement, a recursive solution for generating all subsets of the set {1, 2,…, n}.
Exercise R11.6.    
Exercise P11.12. shows an iterative way of generating all permutations of the sequence (0, 1,…, n - 1). Explain why the
algorithm produces the right result.
Exercise R11.7.    
Write a recursive definition of xn, where x ≥ 0, similar to the recursive definition of the Fibonacci numbers. Hint: How do
you compute xn from xn-1? How does the recursion terminate?
Exercise R11.8.    
Write a recursive definition of n! = 1 × 2 × … × n, similar to the recursive definition of the Fibonacci numbers.
Exercise R11.9.    
Find out how often the recursive version of 
 calls itself. Keep a global variable 
 and increment it once in
every call of 
. What is the relationship between 
 and 
?
Exercise R11.10.    
How many moves are required to move n disks in the “Towers of Hanoi” problem of Exercise P11.14.? Hint: As explained
in the exercise,
n
n
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:47 PM

Exercise P11.1.    
If a string has n letters, then the number of permutations is given by the factorial function:
n
n
For example, 3 ! = 1 × 2 × 3 = 6 and there are six permutations of the three-character string 
. Implement a recursive
 function, using the definitions
n
n
and
Exercise P11.2.    
Write a recursive function 
 that reverses a sentence. For example:
prints the string 
. Implement a recursive solution by removing the first character, reversing a sentence consisting
of the remaining text, and combining the two.
Exercise P11.3.    
Redo Exercise R11.2. with a recursive helper function that reverses a substring of the message text.
Exercise P11.4.    
Implement the 
 function of Exercise R11.2. as an iteration.
Exercise P11.5.    
Use recursion to implement a function 
 that tests whether a string  is contained in
a string :
Returns true
Hint: If the text starts with the string you want to match, then you are done. If not, consider the sentence that you obtain by
removing the first character.
Exercise P11.6.    
Use recursion to implement a function 
 that returns the starting position of the
first substring of the string  that matches . Return -1 if  is not a substring of . For example,
Returns 6
Hint: This is a bit trickier than Exercise P11.5., because you need to keep track of how far the match is from the beginning
of the sentence. Make that value a parameter of a helper function.
Exercise P11.7.    
Using recursion, find the largest element in a vector of integer values.
Hint: Find the largest element in the subset containing all but the last element. Then compare that maximum to the value of
the last element.
Exercise P11.8.    
Using recursion, compute the sum of all values in an array.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:47 PM

Exercise P11.9.    
Using recursion, compute the area of a polygon. Cut off a triangle and use the fact that a triangle with corners (x1 , y1), (x2 ,
y2) , (x3 , y3) has area (x1 y2 + x2 y3 + x3 y1 - y1 x2 - y2 x3 - y3 x1)/ 2.
Exercise P11.10.    
Implement a function
that generates all substrings of a string. For example, the substrings of the string 
 are the seven strings
Hint: First enumerate all substrings that start with the first character. There are n of them if the string has length n. Then
enumerate the substrings of the string that you obtain by removing the first character.
Exercise P11.11.    
Implement a function
that generates all subsets of characters of a string. For example, the subsets of characters of the string 
 are the eight
strings
Note that the subsets don't have to be substrings—for example, 
 isn't a substring of 
.
Exercise P11.12.    
The following program generates all permutations of the numbers 0, 1, 2,…, n - 1, without using recursion.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:47 PM



Chapter
   
    
    
Chapter Goals
•  To compare the selection sort and merge sort algorithms
•  To study the linear search and binary search algorithms
•  To appreciate that algorithms for the same task can differ widely in performance
•  To understand the big-Oh notation
•  To learn how to estimate and compare the performance of algorithms
•  To learn how to measure the running time of a program
One of the most common tasks in data processing is sorting. For example, a sequence of employees needs to be
printed out in alphabetical order or sorted by salary. You will learn several sorting methods in this chapter and
compare their performance.
Once a sequence of records is sorted, one can rapidly locate individual records. You will study the binary search
algorithm that carries out this fast lookup.
Chapter Goals To compare th ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:49 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To compare th ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:49 PM





 - ch12/seltime/seltime.cpp
 - ch12/seltime/util.cpp
 - ch12/seltime/util.h
 - ch12/seltime/ccc_time.cpp
 - ch12/seltime/ccc_time.h
To measure the performance of a program, one could simply run it and measure how long it takes by using a stopwatch.
However, most of our programs run very quickly, and it is not easy to time them accurately in this way. Furthermore, when a
program does take a noticeable time to run, a certain amount of that time may simply be used for loading the program from
disk into memory (for which it should not be penalized) or for screen output (whose speed depends on the computer model,
even for computers with identical CPUs). Instead we use the 
. Recall that
sets 
 to the current time.
Here is how to use the timer to measure the performance of the sorting algorithm. (See 
 
)
By measuring the time just before the sorting and stopping it just afterwards, you don't count the time it takes to initialize the
vector or the time during which the program waits for the user to type in . Table 1 shows the results of some sample runs.
Profiling the Selection Sort Algorithm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:49 PM

Table 1    Selection Sort
n
Seconds
10,000
1
20,000
3
30,000
6
40,000
11
50,000
17
60,000
25
These measurements were obtained on a Pentium processor with a clock speed of 1.67 GHz running Linux. On another
computer, the actual numbers will differ, but the relationship between the numbers will be the same. Figure 1 shows a plot of
the measurements.
Figure 1   Time Taken by Selection Sort
As you can see, doubling the size of the data set more than doubles the time needed to sort it.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Profiling the Selection Sort Algorithm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:49 PM

Let us count the number of operations that the program must carry out to sort a sequence using the selection sort algorithm.
Actually, we don't know how many machine operations are generated for each C++ instruction or which of those instructions
are more time-consuming than others, but we can make a simplification. Simply count how often an element is visited. Each
visit requires about the same amount of work by other operations, such as incrementing subscripts and comparing values.
Let n be the size of the vector. First, you must find the smallest of n numbers. To achieve this, you must visit n elements. Then
swap the elements, which takes two visits. (You may argue that there is a certain probability that you don't need to swap the
values. That is true, and one can refine the computation to reflect that observation. As we will soon see, doing so would not
affect the overall conclusion.) In the next step, you need to visit only n - 1 elements to find the minimum and then visit two of
them to swap them. In the following step, n - 2 elements are visited to find the minimum. The last run visits two elements to
find the minimum and requires two visits to swap the elements. Therefore, the total number of visits is
because
After multiplying out and collecting terms of n, you find that the number of visits is
This is a quadratic equation in n. That explains why the graph of Figure 1 looks approximately like a parabola.
Now simplify the analysis further. When you plug in a large value for n (for example, 1,000 or 2,000), then 
 is 500,000
or 2,000,000. The lower term, 
, doesn't contribute much at all; it is just 2,497 or 4,997, a drop in the bucket compared
to the hundreds of thousands or even millions of comparisons specified by the 
 term. Just ignore these lower-level terms.
Next, ignore the constant factor 
. You need not be interested in the actual count of visits for a single n. You need to compare
the ratios of counts for different values of n2. For example, you can say that sorting a sequence of 2,000 numbers requires four
times as many visits as sorting a sequence of 1,000 numbers:
The factor 
 cancels out in comparisons of this kind. We will simply say, “The number of visits is of order n2”. That way, we
can easily see that the number of comparisons increases fourfold when the size of the vector doubles: (2n)2 = 4n2.
To indicate that the number of visits is of order n2, computer scientists often use big-Oh notation: The number of visits is
O(n2). This is a convenient shorthand.
To turn an exact expression like
Analyzing the Performance of the Selection Sort Algorithm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:49 PM

into big-Oh notation, simply locate the fastest-growing term, n2, and ignore the constant coefficient 
.
In general, the expression f(n) = O(g(n)) means that f grows no faster than g, or, more formally, that for all n larger than some
threshold, the ratio f(n)/g(n) is less than a constant value C. The function g is usually chosen to be very simple, such as n2 in
our example.
Computer scientists use big-Oh notation to describe
how fast a function grows.
You observed before that the actual number of machine operations, and the actual number of microseconds that the computer
spends on them, is approximately proportional to the number of element visits. Maybe there are about 10 machine operations
(increments, comparisons, memory loads, and stores) for every element visit. The number of machine operations is then
approximately 
. Again, we aren't interested in the coefficient and can say that the number of machine operations, and
hence the time spent on the sorting, is of the order of n2 or O(n2).
Selection sort is an O(n2) algorithm. Doubling the data
set means a fourfold increase in processing time.
The sad fact remains that doubling the size of the vector causes a fourfold increase in the time required for sorting it. When the
size of the sequence increases by a factor of 100, the sorting time increases by a factor of 10,000. To sort a sequence of a
million entries, (for example, to create a telephone directory) takes 10,000 times as long as sorting 10,000 entries. If 10,000
entries can be sorted in about a second (as in our example), then sorting one million entries requires almost three hours. You
will see in the next section how one can dramatically improve the performance of the sorting process by choosing a more
sophisticated algorithm.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Analyzing the Performance of the Selection Sort Algorithm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:49 PM

In this section, you will learn about the merge sort algorithm, a much more efficient algorithm than selection sort. The basic
idea behind merge sort is very simple. Suppose you have a vector of 10 integers. Engage in a bit of wishful thinking and hope
that the first half of the vector is already perfectly sorted, and the second half is too, like this:
Now it is an easy matter to merge the two sorted sequences into a sorted sequence, simply by taking a new element from either
the first or the second subvector and choosing the smaller of the elements each time:
In fact, you probably performed this merging before when you and a friend had to sort a pile of papers. You and the friend split
up the pile in the middle, each of you sorted your half, and then you merged the results together.
This is all well and good, but it doesn't seem to solve the problem for the computer. It still has to sort the first and the second
half of the sequence, because it can't very well ask a few buddies to pitch in. As it turns out, though, if the computer keeps
dividing the vector into smaller and smaller subvectors, sorting each half and merging them back together, it carries out
dramatically fewer steps than the selection sort requires.
Let us write a program that implements this idea. Because we will call the sort procedure multiple times to sort portions of the
sequence, we will supply the range of elements that we would like to have sorted.
Sort the first and the second half
The 
 procedure is somewhat long but quite straightforward—see the following code listing for details.
ch12/mergesort/mergesort.cpp
 
 
Merge Sort
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:50 PM

Merges two adjacent ranges in a vector.
the vector with the elements to merge
the start of the first range
the end of the first range
the end of the second range
 Size of the range to be merged 
 Merge both halves into a temporary vector 
 Next element to consider in the first half 
 Next element to consider in the second half 
 Next open position in 
As long as neither i1 nor i2 is past the end, move the smaller
element into
Note that only one of the two while loops below is executed.
 Copy any remaining entries of the first half 
 Copy any remaining entries of the second half 
 Copy back from the temporary vector 
Merge Sort
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:50 PM

Sorts the elements in a range of a vector.
the vector with the elements to sort
start of the range to sort
end of the range to sort
 Sort the first and the second half 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Merge Sort
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:50 PM

 - ch12/mergetime/util.cpp
 - ch12/mergetime/util.h
 - ch12/mergetime/ccc_time.cpp
 - ch12/mergetime/ccc_time.h
The merge sort algorithm looks much more complicated than the selection sort algorithm, and it appears that it may well take
much longer to carry out these repeated subdivisions. However, the timing results for merge sort look much better than those
for selection sort (see 
 and the table below). Sorting a sequence with 60,000 elements takes less
than one second on our test machine, whereas the selection sort takes 25 seconds.
In order to get precise timing results, it is best to run the algorithm multiple times, and then divide the total time by the number
of runs. Here are typical results:
n
Merge Sort (seconds)
Selection Sort (seconds)
10,000
0.012
1
20,000
0.025
3
30,000
0.038
6
40,000
0.052
11
50,000
0.066
17
60,000
0.081
25
Figure 2 shows a graph plotting the relationship. Note that the graph does not have a parabolic shape. Instead, it appears as if
the running time grows approximately linearly with the size of the sequence.
Figure 2   Merge Sort Timing (blue) versus Selection Sort (red)
Analyzing the Merge Sort Algorithm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:50 PM

To understand why the merge sort algorithm is such a tremendous improvement, let us estimate the number of sequence
element visits. First, we tackle the merge process that happens after the first and second half have been sorted.
Each step in the merge process adds one more element to . There are  elements in . That element may come from the first
or second half of , and in most cases the elements from the two halves must be compared to see which one to take. Count that
as 3 visits (one for  and one each for the two halves of ) per element, or 3  visits total. Then you must copy back from  to
, yielding another 2  visits, for a total of 5 .
If you let T(n) denote the number of visits required to sort a range of n elements through the merge sort process, then you
obtain
because sorting each half takes T(n/2) visits. (Actually, if n is not even, then you have one subsequence of size (n - 1)/2 and
one of size (n + 1)/2. While it turns out that this detail does not affect the outcome of the computation, you can assume for
now that n is a power of 2, say n = 2m. This way, all subsequences can be evenly divided into two parts.)
Unfortunately, the formula
does not clearly tell you the relationship between n and T(n). To understand the relationship, evaluate T(n/2), using the same
formula:
Therefore
Do this again:
hence
This generalizes from 2, 4, 8, to arbitrary powers of 2:
Recall that you assume that n = 2m; hence, for k = m,
Because n = 2m, you have m = log2(n).
To establish the growth order, you drop the lower order term n and are left with 5n log2(n). Drop the constant factor 5. It is
also customary to drop the base of the logarithm because all logarithms are related by a constant factor. For example,
Hence we say that merge sort is an O(n log(n)) algorithm.
Merge sort is an O(n log(n)) algorithm. The n log(n)
function grows much more slowly than n2.
Analyzing the Merge Sort Algorithm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:50 PM

Is the O(n log(n)) merge sort algorithm better than an O(n2) selection sort algorithm? You bet it is. Recall that it took 1002 =
10,000 times as long to sort a million records as it took to sort 10,000 records with the O(n2) algorithm. With the O(n log(n))
algorithm, the ratio is
Suppose for the moment that merge sort takes the same time as selection sort to sort a sequence of 10,000 integers, that is, 1
second on the test machine. (Actually, as you have seen, it is much faster than that.) Then it would take about 150 seconds, or
less than three minutes, to sort 1,000,000 integers. Contrast that with selection sort, which would take almost 3 hours for the
same task. As you can see, even if it takes you several hours to learn about a better algorithm, that can be time well spent.
In this chapter you have barely begun to scratch the surface of this interesting topic. There are many sort algorithms, some with
even better performance than the merge sort algorithm, and the analysis of these algorithms can be quite challenging. If you are
a computer science major, you may revisit these important issues in a later computer science class.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Analyzing the Merge Sort Algorithm
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:50 PM



Searching for an element in a sequence is an extremely common task. As with sorting, the right choice of algorithms can make
a big difference.
Suppose you need to find the telephone number of your friend. If you have a telephone book, you can look up your friend's
name quickly, because the telephone book is sorted alphabetically. However, now suppose you have a telephone number and
you must know to whom it belongs (without actually calling the number). You could look through the telephone book, one
number at a time, until you find the number. This would obviously be a tremendous amount of work.
This thought experiment shows the difference between a search through an unsorted data set and a search through a sorted data
set.
If you want to find a number in a sequence of values that occur in arbitrary order, you must look through all elements until you
have found a match or until you reach the end. This is called a linear or sequential search.
A linear search examines all values in a sequence until
it finds a match or reaches the end.
Here is a function that performs a linear search through a vector  of integers for a value, value (see 
). The function then returns the index of the match, or -1 if value does not occur in .
How long does a linear search take? If you assume that the element  is present in the vector , then the average search visits
n/2 elements. If it is not present, then all n elements must be inspected to verify the absence. Either way, a linear search is an
O(n) algorithm.
A linear search locates a value in a sequence in O(n)
steps.
Now consider searching an item in a sequence that has been previously sorted. Of course, you could still do a linear search, but
it turns out you can do much better than that.
Here is a typical example. The data set is:
and you want to see whether the value 123 is in the data set. The last point in the first half of the data set, 
, is 100. It is
smaller than the value you are looking for; hence, you should look in the second half of the data set for a match, that is, in the
sequence
Searching
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:50 PM

Now the last value of the first half of this sequence is 290; hence, the value must be located in the sequence
The last value of the first half of this very short sequence is 115, which is smaller than the value that you are searching, so you
must look in the second half:
It is trivial to see that you don't have a match, because 123 ≠ 290. If you wanted to insert 123 into the sequence, you would
need to insert it just before 
.
This search process is called a binary search, because the size of the search is cut in half in each step. That cutting in half
works only because you know that the sequence of values is sorted.
A binary search locates a value in a sorted sequence by
determining whether the value occurs in the first or
second half, then repeating the search in one of the
halves.
The following function implements a binary search in a sorted sequence of integers (see 
). 
It returns the position of the match if the search succeeds, or -1 if the value is not found in :
Now determine the number of element visits required to carry out a search. Use the same technique as in the analysis of merge
sort. Because you look at the middle element, which counts as one comparison, and then search either the left or the right
subsequence, you have
Using the same equation,
By plugging this result into the original equation, you get
This generalizes to
As in the analysis of merge sort, you make the simplifying assumption that n is a power of 2, n = 2m, where m = log2(n). Then
you obtain
Searching
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:50 PM

Therefore, binary search is an O(log(n)) algorithm.
This result makes intuitive sense. Suppose that n is 100. Then after each search, the size of the search range is cut in half, to 50,
25, 12, 6, 3, and 1. After seven comparisons we are done. This agrees with our formula since log2(100) ≈ 6.64386, and indeed
the next larger power of 2 is 27 = 128.
Because a binary search is so much faster than a linear search, is it worthwhile to sort a sequence first and then use a binary
search? It depends. If you only search the sequence once, then it is more efficient to pay for an O(n) linear search than for an
O(n log(n)) sort and O(log(n)) binary search. But if one makes a number of searches in the same sequence, then sorting it is
definitely worthwhile.
A binary search locates a value in a sequence in
O(log(n)) steps.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Searching
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:50 PM

If you need to sort or search values in your own programs, there is no need to implement your own algorithms. You can simply
use functions in the C++ library. This section gives you a brief overview of the library functions for sorting and binary search.
For more information on using library algorithms see [1].
You sort a vector  by calling
The C++ library contains functions 
 and
.
The expressions 
 and 
 are iterators that denote the beginning and ending positions of the vector. (As
you will see in the next chapter, an iterator denotes a position in a container.)
If the values are stored in an array , then the call to the 
 method looks slightly different. You supply a pointer to the
beginning and the end of the array:
size
Here size is the size of the array. For example,
Now a contains 6, 39, 47, 60, 70
If you have a sorted vector or array, you can use the 
 function to test whether it contains a given value. For
example, the call
returns 
 if the vector  contains 
. (Unlike our binary search function from the preceding section, the library function
does not return the position where the value was found.)
To search an array, you call
size
To use the 
 or 
 functions, you must include the 
 header.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Library Functions for Sorting and Binary Search
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:50 PM

Advanced Topic 12.2
ADVANCED TOPIC 12.2 Defining an Ordering for Sorting Objects
When you use the 
 function, you must ensure that it is able to compare elements. Suppose that you want to
sort a 
. The compiler will complain that it does not know how to compare two employees.
There are several ways to overcome this problem. The simplest is to define the  operator for 
 objects:
The curious name 
 indicates that this function defines a comparison operator. (See
 for an example program.) For more information about defining your own operators, see
[1], Chapter 14.
This  operator compares employees by salary. If you call 
 to sort a sequence of employees, they will be
sorted by increasing salary.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 12.2 Defining an Ordering for Sorting Objects
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:51 PM

Random Fact 12.1
RANDOM FACT 12.1 Cataloging Your Necktie Collection
People and companies use computers to organize just about every aspect of their lives. On the whole, computers
are tremendously good for collecting and analyzing data. In fact, the power offered by computers and their software
makes them seductive solutions for just about any organizational problem. It is easy to lose sight of the fact that
using a computer is not always the best solution to a problem.
In 1983, the author John Bear wrote about a person who had come up with a novel use for the personal computers
that had recently become available. That person cataloged his necktie collection, putting descriptions of the ties
into a database and generating reports that listed them by color, price, or style. We can hope he had another use to
justify the purchase of a piece of equipment worth several thousand dollars, but that particular application was so
dear to his heart that he wanted the world to know about it. Perhaps not surprisingly, few other computer users
shared that excitement, and you don't find the shelves of your local software store lined with necktie-cataloging
software.
The phenomenon of using technology for its own sake is quite widespread. In the “Internet bubble” of 2000,
hundreds of companies were founded on the premise that the Internet made it technologically possible to order
items such as groceries and pet food from a home computer, and therefore the traditional stores would be replaced
by web stores. However, technological feasibility did not ensure economic success. Trucking groceries and pet
food to households was expensive, and few customers were willing to pay a premium for the added convenience.
At the same time, many elementary schools spent tremendous resources to bring computers and the Internet into the
classroom. Indeed, it is easy to understand why teachers, school administrators, parents, politicians and equipment
vendors are in favor of computers in classrooms. Isn't computer literacy absolutely essential for youngsters in the
new millennium? Isn't it particularly important to give low-income kids, whose parents may not be able to afford a
home computer, the opportunity to master computer skills? However, schools have found that the total cost of
running computers far exceeds the initial cost of the equipment. As schools purchased more equipment than could
be maintained by occasional volunteers, they had to make hard choices—should they lay off librarians and art
instructors to hire more computer technicians, or should they let the equipment become useless? Unfortunately,
many schools were so caught up in the technology hype that they never asked themselves whether the educational
benefits justified the expense. See 2 for more information.
As computer programmers, we like to computerize everything. As computer professionals, though, we owe it to
our employers and clients to understand which problems they want to solve and to deploy computers and software
only where they add more value than cost.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 12.1 Cataloging Your Necktie Collection
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:51 PM

1.  The selection sort algorithm sorts a sequence by repeatedly finding the smallest element of the unsorted tail region and
moving it to the front.
2.  Computer scientists use big-Oh notation to describe how fast a function grows.
3.  Selection sort is an O(n2) algorithm. Doubling the data set means a fourfold increase in processing time.
4.  Merge sort is an O(n log(n)) algorithm. The n log(n) function grows much more slowly than n2.
5.  A linear search examines all values in a sequence until it finds a match or reaches the end.
6.  A linear search locates a value in a sequence in O(n) steps.
7.  A binary search locates a value in a sorted sequence by determining whether the value occurs in the first or second half,
then repeating the search in one of the halves.
8.  A binary search locates a value in a sequence in O(log(n)) steps.
9.  The C++ library contains functions sort and 
.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:51 PM

Exercise R12.1.    
Checking against off-by-one errors. When writing the selection sort algorithm of Section 12.1, a programmer must make
the usual choices of  against 
, 
 against 
, and 
 against 
. This is fertile
ground for off-by-one errors. Make code walkthroughs of the algorithm with vectors of length 0, 1, 2, and 3 and check
carefully that all index values are correct.
Exercise R12.2.    
What is the difference between searching and sorting?
Exercise R12.3.    
For the following expressions, what is the order of the growth of each?
(a)  n2 + 2n + 1
(b)  n10 + 9n9 + 20n8 + 145n7
(c)  (n + 1)4
(d)  (n2 + n)2
(e)  n + 0.001n3
(f)  n3 - 1000n2 + 109
(g)  n + log(n)
(h)  n2 + n log(n)
(i)  2n + n2
(j)  
Exercise R12.4.    
You determined that the actual number of visits in the selection sort algorithm is
You then characterized this function as having O(n2) growth. Compute the actual ratios
and compare them with
where f(n) = n2.
Exercise R12.5.    
Suppose algorithm A takes five seconds to handle a data set of 1,000 records. If the algorithm A is an O(n) algorithm, how
long will it take to handle a data set of 2,000 records? Of 10,000 records?
Exercise R12.6.    
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:51 PM

Suppose an algorithm takes five seconds to handle a data set of 1,000 records. Fill in the following table, which shows the
approximate growth of the execution times depending on the complexity of the algorithm.
 
O(n)
O(n2)
O(n3)
O(n log(n))
O(2n)
1,000
5
5
5
5
5
2,000
 
 
 
 
 
3,000
 
45
 
 
 
10,000
 
 
 
 
 
For example, since 30002/10002 = 9, the O(n2) algorithm would take nine times as long, or 45 seconds, to handle a data
set of 3,000 records.
Exercise R12.7.    
Sort the following growth rates from slowest growth to fastest growth.
O(n)
O(nlog(n))
O(n3)
O(2n)
O(nn)
O
O(log(n))
O
O(n2log(n))
O(nlog(n))
Exercise R12.8.    
What is the order of complexity of the standard algorithm to find the minimum value of a sequence? Of finding both the
minimum and the maximum?
Exercise R12.9.    
What is the order of complexity of the following function?
Exercise R12.10.    
Your task is to remove all duplicates from a vector. For example, if the vector has the values
then the vector should be changed to
Here is a simple algorithm. Look at 
. Count how many times it occurs in . If the count is larger than 1, remove it.
What is the order of complexity of this algorithm?
Exercise R12.11.    
Consider the following algorithm to remove all duplicates from a vector. Sort the vector. For each element, look at its two
neighbors to decide whether it is present more than once. If so, remove it. Is this a faster algorithm than the one in Exercise
R12.10.?
Exercise R12.12.    
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:51 PM

Develop a fast algorithm for removing duplicates from a vector if the resulting vector must have the same ordering as the
original one.
Exercise R12.13.    
Consider the following sorting algorithm. To sort a vector a, make a second vector b of the same size. Then insert elements
from a into b, keeping b in sorted order. For each element, call the binary search function of Exercise P12.6. to determine
where it needs to be inserted. To insert an element into the middle of a vector, you need to move all elements above the
insert location up.
Is this an efficient algorithm? Estimate the number of element visits in the sorting process. Assume that on average half of
the elements of b need to be moved to insert a new element.
Exercise R12.14.    
Make a walkthrough of selection sort with the following data sets.
(a)  4 7 11 4 9 5 11 7 3 5
(b)  -7 6 8 7 5 9 0 11 10 5 8
Exercise R12.15.    
Make a walkthrough of merge sort with the following data sets.
(a)  5 11 7 3 5 4 7 11 4 9
(b)  9 0 11 10 5 8 -7 6 8 7 5
Exercise R12.16.    
Make a walkthrough of the following:
(a)  Linear search for 7 in -7 1 3 3 4 7 11 13
(b)  Binary search for 8 in -7 2 2 3 4 7 8 11 13
(c)  Binary search for 8 in -7 1 2 3 5 7 10 13
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:51 PM

Exercise P12.1.    
Modify the selection sort algorithm to sort a vector of integers in descending order.
Exercise P12.2.    
Modify the selection sort algorithm to sort a vector of employees by salary.
Exercise P12.3.    
Write a program that generates the table of sample runs of the selection sort times automatically. The program should ask
for the smallest and largest value of  and the number of measurements and then make all sample runs.
Exercise P12.4.    
Modify the merge sort algorithm to sort a vector of employees by salary.
Exercise P12.5.    
Write a telephone lookup program. Read a data set of 1,000 names and telephone numbers from a file that contains the
numbers in random order. Handle lookups by name and also reverse lookups by phone number. Use a binary search for both
lookups.
Exercise P12.6.    
Consider the binary search function in Section 12.7. If no match is found, the function returns -1. Modify the function so
that it returns a 
 value indicating whether a match was found. Add a reference parameter , which is set to the location
of the match if the search was successful. If a was not found, set  to the index of the next larger value instead, or to
 if a is larger than all the elements of the vector.
Exercise P12.7.    
Use the modification of the binary search function from Exercise P12.6. to sort a vector. Make a second vector of the same
size as the vector to be sorted. For each element in the first vector, call binary search on the second vector to find out where
the new element should be inserted. Then move all elements above the insertion point up by one slot and insert the new
element. Thus, the second vector is always kept sorted. Implement this algorithm and measure its performance.
Exercise P12.8.    
Implement the 
 procedure without recursion, where the size of the vector is a power of 2. First merge
adjacent regions of size 1, then adjacent regions of size 2, then adjacent regions of size 4, and so on.
Exercise P12.9.    
Implement the 
 procedure without recursion, where the size of the vector is an arbitrary number. Hint: Keep
merging adjacent areas whose size is a power of 2, and pay special attention to the last area in the sequence.
Exercise P12.10.    
Write a program that sorts a vector of 
 objects by increasing salary and prints the results. Use the sort function
from the C++ library.
Exercise P12.11.    
Write a program that sorts an array of 
 objects and prints the results. Use the 
 function from the C++ library.
Exercise P12.12.    
Write a program that keeps an appointment book. Make a class 
 that stores a description of the appointment,
the appointment day, the starting time, and the ending time. Your program should keep the appointments in a sorted vector.
Users can add appointments and print out all appointments for a given day. When a new appointment is added, use binary
search to find where it should be inserted in the vector. Do not add it if it conflicts with another appointment.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:51 PM

1.   Cay Horstmann and Tim Budd. Big C++, 2nd ed., John Wiley & Sons, 2009.
2.   Todd Oppenheimer. The Computer Delusion, The Atlantic Monthly 280, no. 1 (July 1997):
45–62, available online at http://www.catholiceducation.org/articles/education/ed0026.html.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Further Reading
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:52 PM

Chapter
   
    
    
Chapter Goals
•  To become familiar with the list, queue, and stack data types
•  To understand the implementation of linked lists
•  To understand the efficiency of vector and list operations
In this chapter, we introduce a new data structure, the linked list. You will learn how to use lists and the related
stack and queue types. You will study the implementation of linked lists and analyze when linked lists are more
efficient than vectors.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To become fam ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:52 PM

A linked list is a data structure for collecting a sequence of objects, such that addition and removal of elements in the middle
of the sequence is efficient.
To understand the need for such a data structure, imagine a program that maintains a vector of employee records, sorted by the
last name of the employees. When a new employee is hired, an object needs to be inserted into the vector. Unless the company
happens to hire employees in dictionary order, it is likely that a new employee object needs to be inserted into the middle of the
vector. In that case, many other objects must be moved toward the end. Conversely, if an employee leaves the company, the
hole in the sequence needs to be closed by moving all objects that came after it. Moving a large number of objects can involve
a substantial amount of computer time. We would like to structure the data in a way that minimizes this cost.
A linked list consists of a number of nodes, each of
which has a pointer to the neighboring nodes.
Rather than storing the data in a single block of memory, a linked list uses a different strategy. Each value is stored in its own
memory block, together with the locations of the neighboring blocks in the sequence (see Figure 1).
Figure 1   A Linked List
It is now an easy matter to add another value into the sequence, or to remove a value from the sequence, without moving the
others (see Figures 2 and 3).
Figure 2   Adding a Node to a Linked List
Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:53 PM

Figure 3   Removing a Node from a Linked List
Adding and removing elements in the middle of a
linked list is efficient.
What's the catch? Linked lists allow speedy insertion and removal, but element access can be slow. For example, suppose you
want to locate the fifth element. You must first traverse the first four. This is a problem if you need to access the elements in
arbitrary order. The term random access is used in computer science to describe an access pattern in which elements are
accessed in arbitrary (not necessarily random) order. In contrast, sequential access visits the elements in sequence. For example,
a binary search requires random access, whereas a linear search only requires sequential access.
Of course, if you mostly visit all elements in sequence (for example, to display or print the elements), the inefficiency of
random access is not a problem. You use linked lists when you are concerned about the efficiency of inserting or removing
elements and you rarely need element access in random order.
Visiting the elements of a linked list in sequential
order is efficient, but random access is not.
The standard C++ library has an implementation of the linked list container structure. In this section, you will learn how to use
the standard linked list structure. Later you will look “under the hood” and find out how to implement linked lists. (The linked
list of the standard C++ library has links going in both directions. Such a list is often called a doubly-linked list. A singly-
linked list lacks the links to the predecessor elements.)
Just like 
, the standard 
 is a template: You can declare lists for different types. For example, to make a list of
strings, define an object of type 
. Then you can use the 
 function to add strings to the end of the list.
The following code segment defines a list of strings, 
, and adds three strings to it:
This code looks exactly like the code that you would use to build a vector of strings. There is, however, one major difference.
Suppose you want to access the last element in the list. You cannot directly refer to 
. Since the values are not stored
in one contiguous block in memory, there is no immediate way to access the third element. Instead, you must visit each
element in turn, starting at the beginning of the list and then proceeding to the next element.
You can inspect and edit a linked list with an iterator.
An iterator points to a node in a linked list.
Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:53 PM

To visit an element, you use a list iterator. An iterator marks a position in the list. To get an iterator that marks the beginning
position in the list, you define an iterator variable, then call the 
 function of the 
 class to get the beginning
position:
To move the iterator to the next position, use the ++ operator:
You can also move the iterator backwards with the -- operator:
You find the value that is stored in the position marked with the  operator:
You have to be careful to distinguish between the iterator 
, which represents a position in the list, and the value 
,
which represents the value that is stored in the list. For example, if you change 
, then you update the contents in the list:
 The list value at the position is changed 
If you change 
, then you merely change the current position.
 The position is again at the beginning of the list 
To insert another string before the iterator position, use the 
 function:
The 
 function inserts the new element before the iterator position, rather than after it. This convention makes it easy to
insert a new element before the first value of the list:
That raises the question of how you insert a value after the end of the list. Each list has an end position that does not
correspond to any value in the list but that points past the list's end. The end function returns that position:
 Points past the end of the list 
 Insert past the end of the list 
It is an error to compute
 ERROR 
The 
 position does not point to any value, so you cannot look up the value at that position. This error is equivalent to the
error of accessing 
 in a vector with 10 elements.
The 
 position has another useful purpose: it is the stopping point for traversing the list. The following code iterates over
all elements of the list and prints them out:
Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:53 PM

The traversal can be described more concisely with a 
 loop:
Of course, this looks very similar to the typical 
 loop for traversing a vector:
Finally, to remove an element from a list, you move an iterator to the position that you want to remove, then call the 
function. The 
 function returns an iterator that points to the element after the one that has been erased.
The following code erases the second element of the list:
Now 
 points to the element that was previously the third element and is now the second element.
Here is a short example program that adds elements to a list, inserts and erases list elements, and finally traverses the resulting
list.
ch13/list1.cpp
 Add a value in fourth place 
 Remove the value in second place 
Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:53 PM

 Print all values 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:53 PM

The previous section showed you how to put linked lists to use. However, because the implementation of the 
 class is hidden
from you, you had to take it on faith that the list values are really stored in separate memory blocks. We will now walk through an
implementation of the list, node, and iterator classes.
For simplicity, we will implement linked lists of strings. To implement the linked list class in C++ that can hold values of arbitrary
types, you need to know how to program with templates (see [1], Chapter 16). To implement iterators that behave exactly like the
ones in the C++ library, you also need to know about operator overloading and nested classes (see [1], Chapters 17 and 18).
13.2.1 The Classes for Lists, Nodes, and Iterators
The 
 class of the standard library defines many useful member functions. For simplicity, we will only study the implementation
of the most useful ones: 
, 
, 
, and the iterator operations. We call our class 
, with an uppercase , to
differentiate it from the standard 
 class template.
When implementing a linked list, we need to define list,
node, and iterator classes.
A linked list stores each value in a separate object, called a node. A node object holds a value, together with pointers to the previous
and next nodes:
A list node contains pointers to the next and previous nodes.
Note the 
 declarations. They indicate that the 
 and 
 member functions are allowed to inspect and modify the
data members of the 
 class, which we will write presently.
A class should not grant friendship to another class lightly, because it breaks the privacy protection. In this case, it makes sense,
though, since the list and iterator functions do all the necessary work and the node class is just an artifact of the implementation that
is invisible to the users of the list class. Note that no code other than the member functions of the list and iterator classes can access
the node fields, so the data integrity is still guaranteed.
A list object contains pointers to the first and last node.
A list object holds the locations of the first and last nodes in the list:
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 12
2/1/2010 2:53 PM

If the list is empty, then the 
 and 
 pointers are 
. Note that a list object stores no data; it just knows where to find the
node objects that store the list contents.
An iterator contains a pointer to the current node, and to
the list that contains it.
Finally, an iterator denotes a position in the list. It holds a pointer to the node that denotes its current position, and a pointer to the
list that created it. We use member functions 
, 
, and 
 instead of operators , 
, and 
. For example, we will
call 
 instead of 
.
If the iterator points past the end of the list, then the 
 pointer is 
. In that case, the 
 member function uses the
 pointer to move the iterator back from the past-the-end position to the last element of the list. (This is only one
possible choice for implementing the past-the-end position. Another choice would be to store an actual dummy node at the end of
the list. Some implementations of the standard 
 class do just that.)
13.2.2 Implementing Iterators
Iterators are created by the 
 and 
 member functions of the 
 class. The 
 function creates an iterator whose
 pointer points to the first node in the list. The 
 function creates an iterator whose 
 pointer is 
.
The 
 function (which is the equivalent of the 
 operator) advances the iterator to the next position. This is a very typical
operation in a linked list; let us study it in detail. The 
 pointer points to the current node in the list. That node has a field
. Because 
 is a node pointer, the 
 field in the node to which 
 points is referred to as
That 
 field is itself a pointer, pointing to the next node in the linked list (see Figure 4). To make 
 point to that next
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 12
2/1/2010 2:53 PM

node, write
However, you can evaluate 
 only if 
 is not 
, because it is an error to dereference a 
 pointer. That
is, it is illegal to advance the iterator once it is in the past-the-end position.
Figure 4   Advancing an iterator
Here is the complete code for the 
 function:
The 
 function (which is the equivalent of the 
 operator) is a bit more complex. In the ordinary case, you move the
position backwards with the instruction
However, if the iterator is currently past the end, then you must make it point to the last element in the list. Also, when the iterator
points to the first element in the list, it is illegal to move it further backward.
The 
 function (which is the equivalent of the  operator) simply returns the 
 value of the node to which 
points—that is, 
. It is illegal to call 
 if the iterator points past the end ofthe list:
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 12
2/1/2010 2:53 PM

Finally, the 
 function (which is the equivalent of the 
 operator) compares two 
 pointers:
13.2.3 Implementing Insertion and Removal
In the last section you saw how to implement the iterators that traverse an existing list. Now you will see how to build up lists by
adding and removing elements, one step at a time.
List nodes are allocated on the heap, using the new
operator.
First, we will implement the 
 function. It appends an element to the end of the list (see Figure 5). Make a new node:
Figure 5   Appending a Node to the End of a Linked List
This new node must be integrated into the list after the node to which the 
 pointer points. That is, the 
 field of the last node
(which is currently 
) must be updated to 
. Also, the 
 field of the new node must point to what used to be the
last node:
Finally, you must update the 
 pointer to reflect that the new node is now the last node in the list:
However, there is a special case when 
 is 
, which can happen only when the list is empty. After the call to 
, the
list has a single node—namely, 
. In that case, both 
 and 
 must be set to 
:
 List is empty 
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 12
2/1/2010 2:53 PM

Inserting an element in the middle of a linked list is a little more difficult, because the node pointers in the two nodes surrounding
the new node need to be updated. The function declaration is
That is, a new node containing  is inserted before 
 (see Figure 6).
Figure 6   Inserting a Node into a Linked List
Give names to the surrounding nodes. Let 
 be the node before the insertion location, and let 
 be the node after that.
That is,
What happens if 
 is 
? After all, it is illegal to apply 
 to a 
 pointer. In this situation, you are inserting past the end of
the list. Simply call 
 to handle that case separately. Otherwise, you need to insert 
 between 
 and
:
You must also update the nodes from 
 and 
 to point to the new node:
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 12
2/1/2010 2:53 PM

 If before != NULL 
However, you must be careful. You know that 
 is not 
, but it is possible that 
 is 
. In that case, you are
inserting at the beginning of the list and need to adjust 
:
 Insert at beginning 
Here is the complete code for the 
 function:
 Insert at beginning 
Finally, look at the implementation of the 
 function:
You want to remove the node to which 
 points. It is illegal to erase the past-the-end position, so assert that
 points to an actual list element:
As before, give names to the node to be removed, the node before it, and the node after it:
You need to update the 
 and 
 pointers of the 
 and 
 nodes to bypass the node that is to be removed
(see Figure 7).
 If before != NULL 
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 12
2/1/2010 2:53 PM

Figure 7   Removing a Node from a Linked List
However, as before, you need to cope with the possibility that 
, or both are 
. If 
 is 
, you are erasing
the first element in the list. It has no predecessor to update, but you must change the 
 pointer of the list. Conversely, if 
is 
, you are erasing the last element of the list and must update the 
 pointer of the list:
You must adjust the iterator position so it no longer points to the removed element.
When a list node is erased, it is recycled to the heap with
the 
 operator.
Finally, you must remember to recycle the removed node:
Here is the complete 
 function. Note that the function returns an iterator to the element following the erased one:
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 12
2/1/2010 2:53 PM

Implementing these linked list operations is somewhat complex. It is also error-prone. If you make a mistake and misroute some of
the pointers, you can get subtle errors. For example, if you make a mistake with a 
 pointer, you may never notice it until
you traverse the list backwards. If a node has been deleted, then that same storage area may later be reallocated for a different
purpose, and if you have kept a pointer to it, following that invalid node pointer will lead to disaster. You must exercise special care
when implementing any operations that manipulate the node pointers directly.
Implementing operations that modify a linked list is
challenging—you need to make sure that you update all
node pointers correctly.
Here is a program that puts our linked list to use and demonstrates the 
 and 
 operations.
ch13/list2.cpp
Constructs a node with a given data value.
the data to store in this node
Constructs an empty list.
Appends an element to the list.
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
8 of 12
2/1/2010 2:53 PM

the value to append
Inserts an element into the list.
the position before which to insert
the value to append
Removes an element from the list.
the position to remove
an iterator pointing to the element after the
erased element
Gets the beginning position of the list.
an iterator pointing to the beginning of the list
Gets the past-the-end position of the list.
an iterator pointing past the end of the list
Constructs an iterator that does not point into any list.
Looks up the value at a position.
the value of the node to which the iterator points
Advances the iterator to the next node.
Moves the iterator to the previous node.
Compares two iterators.
the iterator to compare with this iterator
true if this iterator and b are equal
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
9 of 12
2/1/2010 2:53 PM

 List is empty 
 Insert at beginning 
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
10 of 12
2/1/2010 2:53 PM

Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
11 of 12
2/1/2010 2:53 PM

 Add a value in fourth place 
 Remove the value in second place 
 Print all values 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Implementing Linked Lists
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
12 of 12
2/1/2010 2:53 PM

In this section, we will formally analyze how efficient the fundamental operations on linked lists and vectors are. We will
consider these operations:
•  Getting the kth element
•  Adding and removing an element at a given position (an iterator or index)
•  Adding and removing an element at the end
To get the kth element of a linked list, you start at the beginning of the list and advance the iterator k times. Suppose it takes an
amount of time T to advance the iterator once. This quantity is independent of the iterator position—advancing an iterator does
some checking and then it follows the 
 pointer. Therefore, advancing the iterator to the kth element consumes kT time.
Therefore, locating the kth element is an O(k) operation.
To analyze the situation for vectors, we need to peek under the hood and see how the 
 class is implemented.
A vector maintains a pointer to an array of elements termed the buffer. An integer field, called the capacity, is the maximum
number of elements that can be stored in the current buffer. The buffer is usually larger than is necessary to hold the current
elements in the collection. The size is the number of elements actually being held by the container. Because vectors use
zero-based indexing, the size can also be interpreted as the first free location in the array. Figure 8 shows the internals of a
vector.
Figure 8   Internal Data Fields Maintained by Vector
To access the kth element, we simply use the expression 
. This is done in a constant amount of time that is
independent of k. We say that accessing a vector element takes O(1) time.
Next, consider the task of adding an element in the middle of a linked list. We assume that we already have an iterator to the
insertion location. It might have taken some time to get there, but we are now concerned with the cost of insertion after the
position has been established.
As shown in Figure 6, you add an element by modifying the 
 and 
 pointers of the new node and the surrounding
nodes. This operation takes a constant number of steps, independent of the position. The same holds for removing an element.
We conclude that list insertion and removal are O(1) operations.
For vectors, the situation is less rosy. To insert an element at position k, the elements with higher index values need to move
(see Figure 9). How many elements are affected? For simplicity, we will assume that insertions happen at random locations.
On average, each insertion moves n / 2 elements, where n is the size of the vector.
The Efficiency of List and Vector Operations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:53 PM

Figure 9   Inserting and Removing Vector Elements
The same argument holds for removing an element. On average, n / 2 elements need to be move. Therefore, we say that vector
insertion and removal are O(n) operations.
There is one situation where adding an element to a vector isn't so costly: when the insertion happens at the end. The
 member function carries out that operation.
If the size of the vector is less than the capacity, the new element is simply moved into place and the size is incremented, as
shown in Figure 10. This is an O(1) operation.
Figure 10   Vector After 
If, however, the size is equal to the capacity, it means that no more space is available. In order to make new space, a new and
larger buffer is allocated. This new buffer is typically twice the size of the current buffer. (See Figure 11.) The existing
elements are then copied into the new buffer, the old buffer is deleted, and insertion takes place as before. Reallocation is an
O(n) operation since all elements need to be copied to the new buffer.
Figure 11   Vector After a Buffer Reallocation
If we carefully an alyze the total cost of a sequence of 
 operations, it turns out that these reallocations are not as
expensive as they first appear. The key observation is that reallocation does not happen very often. Suppose we start with a
vector of capacity 10 and double the size with each reallocation. We must reallocate when the buffer reaches sizes 10, 20, 40,
80, 160, 320, 640, 1280, and so on.
Let us assume that one insertion without reallocation takes time T1 and that reallocation of k elements takes time k T2. What is
the cost of 1280 
 operations? Of course, we pay 1280 · T1 for the insertions. The reallocation cost is
The Efficiency of List and Vector Operations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:53 PM

Therefore, the total cost is a bit less than
In general, the total cost of n 
 operations is less than n · (T1 + 2 T2). Since the second factor is a constant, we
conclude that n 
 operations take O(n) time.
We know that it isn't quite true that an individual 
 operation takes O(1) time. After all, occasionally a 
is unlucky and must reallocate the buffer. But if the cost of that reallocation is distributed over the preceding 
operations, then the surcharge for each of them is still a constant amount. We say that 
 takes amortized O(1) time,
which is written as O(1)+. (Accountants say that a cost is amortized when it is distributed over multiple periods.)
Finally, we note that the 
 operation for a linked list takes O(1) time, provided that the linked list implementation
maintains a pointer to the last element of the list. Table 1 summarizes the execution times that we discussed in this section.
Table 1    Execution Times for Container Operations
Operation
Vector
Linked List
Add/remove element at end
O(1)+
O(1)
Add/remove element in the middle
O(n)
O(1)
Get kth element
O(1)
O(k)
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
The Efficiency of List and Vector Operations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:53 PM

In this section, you will consider two common data types that allow insertion and removal of items at the ends only, not in the
middle.
A queue is a container of items with “first in, first out”
retrieval.
A queue lets you add items to one end of the queue (the back) and remove them from the other end of the queue (the front). To
visualize a queue, simply think of people lining up (see Figure 12). People join the back of the queue and wait until they have
reached the front of the queue. Queues store items in a first in, first out or FIFO fashion. Items are removed in the same order
in which they have been added.
 - ch13/fifolifo.cpp
Figure 12   A Queue
There are many uses of queues in computer science. For example, consider a printer that receives requests to print documents
from multiple sources, either several computers or just several applications that print at the same time on one computer. If
each of the applications sends printing data to the printer at the same time, then the printouts will be garbled. Instead, each
application places all data that need to be sent to the printer into a file and inserts that file into the print queue. When the
printer is done printing one file, it retrieves the next one from the queue. Therefore, print jobs are printed using the first in, first
out rule, which is a fair arrangement for users of the shared printer.
The standard 
 template implements a queue in C++ . Following tradition, the addition and removal operations are called
 and 
. The 
 member function yields the first element of the queue (that is, the next one to be removed). The
 member function yields the element that was most recently added. You cannot access any other elements of the queue.
Here is an example of using a queue:
Queues and Stacks
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:54 PM

A Stack is a container with “last in, first out” retrieval.
A stack lets you insert and remove elements at one end only, traditionally called the top of the stack. To visualize a stack, think
of a stack of books (see Figure 13).
Figure 13   A Stack of Books
New items can be added to the top of the stack. Items are removed from the top of the stack as well. Therefore, they are
removed in the order that is opposite from the order in which they have been added, also called last in, first out or LIFO order.
For example, if you insert strings 
, 
, and 
 into a stack, and then remove them, then you will first see
, then 
, and finally 
.
To obtain a stack in the standard C++ library, you use the 
 template:
The 
 member removes the top of the stack without returning a value. If you want to obtain the value before popping it, first
call 
, then 
.
Figure 14 contrasts the behaviors of the stack and queue data types.
Queues and Stacks
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:54 PM

Figure 14   Stack and Queue Behavior
A good example of the use of stack operations is a program that simulates the execution of a Reverse Polish Notation (RPN,
or postfix) calculator. In RPN notation arguments are written before operators, so that an expression such as 
would be written as 
. This makes calculating the results easy. As each number is read it is pushed on a stack. As
each operator is read two values are popped from the stack, the appropriate operation is performed, and the result is pushed
back on the stack. The following program illustrates this technique. In addition to numbers and the four binary operators, it
adds two one-character commands; the command  will print the current top of the stack, and the command  will halt the
program.
ch13/calc.cpp
Queues and Stacks
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:54 PM

Convert input to integer
Program Run
1 2 4 * + p
3 - p
q
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Queues and Stacks
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:54 PM

Random Fact 13.1
RANDOM FACT 13.1 Polish Notation
When you write arithmetic expressions you are used to operators with different levels of precedence that appear
between the operands, except when parentheses are used to specify a different ordering. That is, an expression such
as 3 + (4 - 2 ) × 7 is evaluated by first subtracting the 2 from the 4, then multiplying the result by 7, and finally
adding the 3. Notice how the sequence of operations jumps around instead of being analyzed in a strict left to right
or right to left order.
In the 1920s a Polish mathematician, Jan Łukasiewicz, noticed that if you wrote the operators first, before the
operands, the need for both parentheses and precedence was eliminated and expressions could be read easily from
left to right 2. In Łukasiewicz's notation the expression would be written as + 3 × - 4 2 . Table 2 shows some other
examples.
Table 2    
Standard Notation
Łukasiewicz Notation
RPN
Evaluating an expression in Łukasiewicz's form is a simple recursive algorithm. Examine the next term; if it is a
constant, then that is your result; if it is a binary operator, then recursively examine the following two expressions,
and produce their result. The scheme was termed Polish Notation in Łukasiewicz's honor (although one can argue
it should be called Łukasiewicz Notation). Of course, an entrenched notation is not easily displaced, even when it
has distinct disadvantages, and Łukasiewicz's discovery did not cause much of a stir for about 50 years.
In the 1950s, Australian computer scientist Charles Hamblin noted that an even better scheme would be to have the
operators follow the operands [3]. This was termed Reverse Polish Notation, or RPN. The expression given would
be written as 
 in RPN. As you have seen, the evaluation of RPN is relatively simple if you have a
stack. Each operand is pushed on the stack. Each operator pops the appropriate number of values from the stack,
performs the operation, and pushes the result back onto the stack.
In 1972, Hewlett-Packard introduced the HP 35 calculator that used RPN. For example, to compute
, you enter 
. RPN calculators have no keys labeled with parentheses or an equals
symbol. There is only a key labeled ENTER to push a number onto a stack. For that reason, Hewlett-Packard's
marketing department used to refer to their product as “the calculators that have no equal”. Indeed, the Hewlett-
Packard calculators were a great advance over competing models that were unable to handle algebraic notation and
left users with no other choice but to write intermediate results on paper.
RANDOM FACT 13.1 Polish Notation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:54 PM

Over time, developers of high quality calculators have adapted to the standard algebraic notation rather than
forcing users to learn a new notation. However, those users who have made the effort of learning RPN tend to be
fanatic proponents, and some Hewlett-Packard calculator models still support it.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
RANDOM FACT 13.1 Polish Notation
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:54 PM

1.  A linked list consists of a number of nodes, each of which has a pointer to the neighboring nodes.
2.  Adding and removing elements in the middle of a linked list is efficient.
3.  Visiting the elements of a linked list in sequential order is efficient, but random access is not.
4.  You can inspect and edit a linked list with an iterator. An iterator points to a node in a linked list.
5.  When implementing a linked list, we need to define list, node, and iterator classes.
6.  A list object contains pointers to the first and last node.
7.  An iterator contains a pointer to the current node, and to the list that contains it.
8.  List nodes are allocated on the heap, using the 
 operator.
9.  When a list node is erased, it is recycled to the heap with the 
 operator.
10.  Implementing operations that modify a linked list is challenging—you need to make sure that you update all node
pointers correctly.
11.  A queue is a container of items with “first in, first out” retrieval.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:54 PM

Exercise R13.1.    
If a list has n elements, how many legal positions are there for inserting a new element? For erasing an element?
Exercise R13.2.    
What happens if you keep advancing an iterator past the end of the list? Before the beginning of the list? What happens if
you look up the value at an iterator that is past the end? Erase the past-the-end position? All these are illegal operations, of
course. What does the list implementation of your compiler do in these cases?
Exercise R13.3.    
Write a function that prints all values in a linked list, starting from the end of the list.
Exercise R13.4.    
The following code edits a linked list consisting of three nodes.
Draw a diagram showing how they are linked together after the following code is executed.
Exercise R13.5.    
Explain what the following code prints.
Exercise R13.6.    
The 
 procedure of Section 13.2 inserts a new element before the iterator position. To understand the updating of
the nodes, draw before/after node diagrams for the following four scenarios.
(a)  The list is completely empty.
(b)  The list is not empty, and the iterator is at the beginning of the list.
(c)  The list is not empty, and the iterator is at the end of the list.
(d)  The list is not empty, and the iterator is in the middle of the list.
Exercise R13.7.    
What advantages do lists have over vectors? What disadvantages do they have?
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:54 PM

Exercise R13.8.    
Suppose you needed to organize a collection of telephone numbers for a company division. There are currently about 6,000
employees, and you know that the phone switch can handle at most 10,000 phone numbers. You expect several hundred
lookups against the collection every day. Would you use a vector or a linked list to store the information?
Exercise R13.9.    
Suppose you needed to keep a collection of appointments. Would you use a linked list or a vector of 
objects?
Exercise R13.10.    
Suppose you write a program that models a card deck. Cards are taken from the top of the deck and given out to players. As
cards are returned to the deck, they are placed on the bottom of the deck. Would you store the cards in a stack or a queue?
Exercise R13.11.    
Consider the efficiency of locating the kth element in a linked list of length n. If k > n / 2, it is more efficient to start at the
end of the list and moving the iterator to the previous element. Why doesn't this increase in efficiency improve the big-Oh
estimate of random access in a linked list?
Exercise R13.12.    
Explain why inserting an element into the middle of a list is faster than inserting an element into the middle of a vector.
Exercise R13.13.    
Explain why the 
 operation with a vector is usually constant time, but occasionally much slower.
Exercise R13.14.    
Suppose a vector implementation were to add 10 elements at each relocation instead of doubling the capacity. Show that
the 
 operation no longer has amortized constant time.
Exercise R13.15.    
Write each of the following expressions in both Polish Notation and Reverse Polish Notation.
(a)  3 + 4
(b)  1 × 2 + 3
(c)  1 × (2 + 3)
(d)  (2 - 4) × (3 + 4)
(e)  1 + 2 + 3 + 4
Exercise R13.16.    
Suppose the strings 
 through 
 are pushed onto a stack. Then they are popped off the stack and pushed onto a second
stack. Finally, they are popped off the second stack and printed. In which order are the strings printed?
Exercise R13.17.    
What are the efficiencies of the 
 and 
 operations of a stack when it is implemented using a linked list? Explain
your answer.
Exercise R13.18.    
What are the efficiencies of the 
 and 
 operations of a stack when it is implemented using a vector? Explain your
answer.
Exercise R13.19.    
What are the efficiencies of the 
 and 
 operations of a queue when it is implemented using a linked list? Explain
your answer.
Exercise R13.20.    
What are the efficiencies of the 
 and 
 operations of a queue when it is implemented using a vector? Explain your
answer.
Exercise R13.21.    
Consider the following algorithm for traversing a maze such as this one:
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:54 PM

Make the cell at the entrance the current cell. Take the following actions, then repeat:
•  If the current cell is adjacent to the exit, stop.
•  Mark the current cell as visited.
•  Add all unvisited neighbors to the north, east, south, and west to a queue.
•  Remove the next element from the queue and make it the current cell.
In which order will the cells of the sample maze be visited?
Exercise R13.22.    
Repeat Exercise R13.21., using a stack instead of a queue.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:54 PM

Exercise P13.1.    
Write a function
that removes every second value from a linked list.
Exercise P13.2.    
Write a function 
 that computes the largest element in a 
.
Exercise P13.3.    
Write a function 
 that sorts the elements of a linked list (without copying them into a vector).
Exercise P13.4.    
Write a function 
 that merges two lists into one, alternating elements from each list until the end of one of the lists
has been reached, then appending the remaining elements of the other list. For example, merging the lists containing 
and 
 should yield the list 
.
Exercise P13.5.    
Provide a linked list of integers by modifying the 
, 
, and 
 classes of Section 13.2 to hold integers instead
of strings.
Exercise P13.6.    
Write a member function 
 that reverses the nodes in a list.
Exercise P13.7.    
Write a member function 
 that adds a value to the beginning of a list.
Exercise P13.8.    
Write a member function 
 that swaps the elements of this list and 
. Your method
should work in O(1) time.
Exercise P13.9.    
Write a member function 
 that computes the number of elements in the list, by counting the
elements until the end of the list is reached.
Exercise P13.10.    
Add a 
 field to the 
 class. Modify the 
 and 
 functions to update the 
 field so that it always
contains the correct size. Change the 
 function of Exercise P13.9. to take advantage of this data field.
Exercise P13.11.    
Turn the linked list implementation into a circular list: Have the 
 pointer of the first node point to the last node,
and the 
 pointer of the last node point to the first node. Then remove the 
 pointer in the 
 class since the value
can now be obtained as 
. Reimplement the member functions so that they have the same effect as before.
Exercise P13.12.    
Turn the linked list implementation into a singly-linked list: Drop the 
 pointer of the nodes and the 
member function of the iterator. Reimplement the other member functions so that they have the same effect as before. Hint:
In order to remove an element in constant time, iterators should store the predecessor of the current node.
Exercise P13.13.    
Modify the linked list implementation to use a dummy node for the past-the-end position whose 
 field is unused. A
past-the-end iterator should point to the dummy node. Remove the 
 pointer in the iterator class. Reimplement
the member functions so that they have the same effect as before.
Exercise P13.14.    
Write a class 
 that stores a polynomial such as
as a linked list of terms. A term contains the coefficient and the power of x. For example, you would store p(x) as
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:55 PM

Supply member functions to add, multiply, and print polynomials. Supply a constructor that makes a polynomial from a
single term. For example, the polynomial  can be constructed as
Then compute 
Exercise P13.15.    
Implement a 
 class, using a linked list of strings. Supply operations 
, 
, 
, and 
, just like in the
standard 
 template.
Exercise P13.16.    
Implement a 
 class, using a linked list of strings. Supply operations 
, 
, 
, 
, and 
, just like in
the standard 
 template.
Exercise P13.17.    
Using a queue of vectors, implement a non-recursive variant of the merge sort algorithm as follows. Start by inserting the
entire vector to be sorted. We assume its size is a power of 2. Keep removing vectors from the queue, splitting them into
two vectors of equal size, and adding the smaller vectors back into the queue. Once you encounter vectors of size 1, change
to the following behavior: Remove pairs of vectors from the queue, merge them into a single vector and add the result back
into the queue. Stop when the queue has size 1.
Exercise P13.18.    
Use a stack to enumerate all permutations of a string without using recursion. Suppose you want to find all permutations
of the string 
. Push the string 
 on the stack. Now repeat the following operations until the stack is empty.
•  Pop off the top of the stack.
•  If that string ends in a  (such as 
), remove the  and print the string
•  Otherwise, remove each letter in turn from the right of the , insert it just before the , and push the resulting string
on the stack. For example, after popping 
, you push 
, and 
.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:55 PM

1.   Cay Horstmann and Tim Budd. Big C++, 2nd ed., John Wiley & Sons, 2009.
2.   Jan Łukasiewicz, Elementy Logiki Matematyczny, Warsaw 1929; English translation: Elements
of Mathematical Logic, Pergamon Press, London, 1963.
3.   Charles L. Hamblin, Translation to and from Polish notation, Computing Journal, 5: 210–213,
1962.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Further Reading
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:55 PM

Chapter
   
    
    
Chapter Goals
•  To become familiar with the set, map, and priority queue data types
•  To understand the implementation of binary search trees and heaps
•  To learn about the efficiency of operations on tree structures
In this chapter, we continue our presentation of common data structures. You will learn how to use the set, map,
and priority queue types that are provided in the C++ library. You will see how these data structures are
implemented as tree-like structures, and how they trade off sequential ordering for fast element lookup.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Goals To become fam ...
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:55 PM

Vectors and linked lists have one characteristic in common: These data structures keep the elements in the same order in which
you inserted them. However, in many applications, you don't really care about the order of the elements in a collection. You
can then make a very useful tradeoff: Instead of keeping elements in order, you can find them quickly.
A set is an unordered collection of distinct elements.
In mathematics and computer science, an unordered collection of distinct items is called a set. As a typical example, consider a
print server: a computer that has access to multiple printers. The server may keep a collection of objects representing available
printers (see Figure 1). The order of the objects doesn't really matter.
Figure 1   A Set of Printers
The fundamental operations on a set are:
•  Adding an element
•  Removing an element
•  Finding an element
•  Traversing all elements
Sets don't have duplicates. Adding a duplicate of an
element that is already present is ignored.
A set rejects duplicates. If an object is already in the set, an attempt to add it again is ignored. That's useful in many
programming situations. For example, if we keep a set of available printers, each printer should occur at most once in the set.
Thus, we will interpret the 
 and 
 operations of sets just as we do in mathematics: Adding elements that are already
in the set, as well as removing elements that are not in the set, are valid operations, but they do not change the set.
In C++, you use the set class to construct a set. As with vectors and lists, 
 requires a type parameter. For example, a set of
strings is declared as follows:
You use the 
 and 
 member functions to add and remove elements:
Sets
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:56 PM

Has no effect: "
" is already in the set
Has no effect: "
" is no longer in the set
To find whether a value is in the set, use the 
 member function. It returns 1 if the value is in the set, 0 otherwise.
count returns 1
Finally, you can visit the elements of a set with an iterator. The iterator visits the elements in sorted order, not in the order in
which you inserted them. For example, consider what happens when we continue our set example as follows.
The standard C++ set class stores values in sorted
order.
The code prints the set elements in dictionary order:
A set cannot contain duplicates. A multiset (also called a bag) is an unordered container that can contain multiple copies of an
element. An example is a grocery bag that contains some grocery items more than once (see Figure 2).
A multiset (or bag) is similar to a set, but elements can
occur multiple times.
Figure 2   A Bag of Groceries
Sets
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:56 PM

In the C++ library, the 
 class implements this data type. You use a 
in the same way as a set. When you
insert an element multiple times, the element count reflects the number of insertions. Each call to 
 decrements the
element count until it reaches 0.
Now 
 is 2
Now 
 is 0
Has no effect: 
 is no longer in the bag
A good illustration of the use of sets is a program to check for misspelled words. Assume you have a file containing correctly
spelled words (that is, a dictionary), and a second file you wish to check. The program simply reads the correctly spelled words
into a set, then reads words from the second file and tests each in the set, printing the word if it is not found.
First put all words from dictionary into set.
Then read words from text
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Sets
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:56 PM

Advanced Topic 14.1
ADVANCED TOPIC 14.1 Defining an Ordering for Container Elements
The 
 and 
 classes need to compare elements, and the 
 class needs to compare keys. By default,
these classes use the  operator for comparisons.
Suppose that you want to build a 
. The compiler will complain that it does not know how to
compare two employees.
To solve this problem you can overload the  operator for 
 objects:
This  operator compares employees by name. To learn more about overloading operators, see Chapter 14 in 1.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 14.1 Defining an Ordering for Container Elements
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:56 PM

A set implementation is allowed to rearrange its elements in any way it chooses so that it can find elements quickly. Suppose a set
implementation sorts its entries. Then it can use binary search to locate elements in O(log(n)) steps, where n is the size of the set.
There is just one wrinkle with this idea. We can't use an array to store the elements of a set, because insertion and removal in an
array is slow; an O(n) operation.
In this section we will introduce the simplest of many tree data structures that computer scientists have invented to overcome that
problem.
A binary tree consists of nodes, each of which has at most
two child nodes.
A linked list is a one-dimensional data structure. Every node has a pointer to the next node. You can imagine that all nodes are
arranged in a line. In contrast, a binary tree is made of nodes with two node pointers, called the left and right children. You should
visualize it as a tree, except that it is traditional to draw the tree upside down, like a family tree or hierarchy chart (see Figure 3). In
a binary tree, every node has at most two children; hence the name binary.
Figure 3   A Binary Search Tree
Finally, a binary search tree is constructed to have the following important property:
•  The data values of all descendants to the left of any node are less than the data value stored in that node, and all descendants
to the right have greater data values.
All nodes in a binary search tree fulfill the property that
the descendants to the left have smaller data values than
the node data value, and the descendants to the right have
larger data values.
The tree in Figure 3 has this property. To verify the binary search property, you must check each node. Consider the node “Juliet”.
All descendants to the left have data before “Juliet”. All descendants on the right have data after “Juliet”. Move on to “Eve”. There
Binary Search Trees
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 7
2/1/2010 2:56 PM

is a child to the left, with data “Adam” before “Eve”, and a single child to the right, with data “Harry” after “Eve”. Check the
remaining nodes in the same way.
Figure 4 shows a binary tree that is not a binary search tree. Look carefully—the root node passes the test, but its two children do
not.
Figure 4   A Binary Tree That Is Not a Binary Search Tree
Let us implement these tree classes. Just as you needed classes for lists and their nodes, you need one class for the tree, containing a
pointer to the root node, and a separate class for the nodes. Each node contains two pointers (to the left and right child nodes) and a
data field. At the fringes of the tree, one or two of the child pointers are 
.
To insert data into the tree, use the following algorithm:
•  If you encounter a non-
 node, look at its data value. If the 
 value of that node is larger than the one you want to insert,
continue the process with the left child. If the existing 
 value is smaller, continue the process with the right child.
•  If you encounter a 
 node, replace it with the new node.
For example, consider the tree in Figure 5. It is the result of the following statements:
Binary Search Trees
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 7
2/1/2010 2:56 PM

Figure 5   Binary Search Tree After Four Insertions
We want to insert a new element 
 into it.
Start with the root, 
 comes after 
, so you move to the right subtree. You encounter the node 
comes before 
, so you move to the left subtree. But there is no left subtree. Hence, you insert a new 
 node as the left
child of 
 (see Figure 6).
Binary Search Trees
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 7
2/1/2010 2:56 PM

Figure 6   Binary Search Tree After Five Insertions
You should convince yourself that the resulting tree is still a binary search tree. When 
 is inserted, it must end up as a right
descendant of 
—that is what the binary search tree condition means for the root node 
. The root node doesn't care
where in the right subtree the new node ends up. Moving along to 
, the right child of 
, all it cares about is that the new
node 
 ends up somewhere on its left. There is nothing to its left, so 
 becomes the new left child, and the resulting tree
is again a binary search tree.
Here is the code for the 
 member function of the 
 class:
To insert a value in a binary search tree, recursively insert
it into the left or right subtree.
If the tree is empty, simply set its root to the new node. Otherwise, you know that the new node must be inserted somewhere within
the nodes, and you can ask the root node to perform the insertion. That node object calls the 
 member function of the
 class. That member function checks whether the new object is less than the object stored in the node. If so, the element
is inserted in the left subtree. If it is larger than the object stored in the node, it is inserted in the right subtree:
Binary Search Trees
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 7
2/1/2010 2:56 PM

Let us trace the calls to 
 when inserting 
 into the tree in Figure 5. The first call to 
 is
Because 
 points to 
, you compare 
 with 
 and find that you must call
The node 
 contains 
. Compare the data values again (
) and find that you must now move to the
left. Since 
 is 
, set 
 to 
, and the insertion is complete (see Figure 6).
We will now discuss the removal algorithm. Our task is to remove a node from the tree. Of course, we must first find the node to
be removed. That is a simple matter, due to the characteristic property of a binary search tree. Compare the data value to be removed
with the data value that is stored in the root node. If it is smaller, keep looking in the left subtree. Otherwise, keep looking in the
right subtree.
Let us now assume that we have located the node that needs to be removed. First, let us consider an easy case, when that node has
only one child (see Figure 7).
Figure 7   Removing a Node with One Child
To remove the node, simply modify the parent link that points to the node so that it points to the child instead.
If the node to be removed has no children at all, then the parent link is simply set to 
.
When removing a node with only one child from a binary
search tree, the child replaces the node to be removed.
The case in which the node to be removed has two children is more challenging. Rather than removing the node, it is easier to
replace its data value with the next larger value in the tree. That replacement preserves the binary search tree property.
(Alternatively, you could use the largest element of the left subtree—see Exercise P14.11.).
When removing a node with two children from a binary
search tree, replace it with the smallest node of the right
subtree.
Binary Search Trees
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 7
2/1/2010 2:56 PM

To locate the next larger value, go to the right subtree and find its smallest data value. Keep following the left child links. Once you
reach a node that has no left child, you have found the node containing the smallest data value of the subtree. Now remove that
node—it is easily removed because it has at most one child. Then store its data value in the original node that was slated for
removal. Figure 8 shows the details.
Figure 8   Removing a Node with Two Children
You will find the complete source code for the 
 class at the end of the next section. Now that you have seen
how to implement this complex data structure, you may well wonder whether it is any good. Like nodes in a list, tree nodes are
allocated one at a time. No existing elements need to be moved when a new element is inserted in the tree; that is an advantage. How
fast insertion is, however, depends on the shape of the tree. If the tree is balanced —that is, if each node has approximately as many
descendants on the left as on the right—then insertion takes O(log n) time, where n is the number of nodes in the tree. This is a
consequence of the fact that about half of the nodes are eliminated in each step. On the other hand, if the tree happens to be
unbalanced, then insertion can be slow—perhaps as slow as insertion into a linked list. (See Figure 9.)
If new elements are fairly random, the resulting tree is likely to be well balanced. However, if the incoming elements happen to be in
sorted order already, then the resulting tree is completely unbalanced. Each new element is inserted at the end, and the entire tree
must be traversed every time to find that end!
If a binary search tree is balanced, then inserting an
element takes O(log(n)) time.
There are more sophisticated tree structures whose functions keep trees balanced at all times. In these tree structures, one can
guarantee that finding, adding, and removing elements takes O(log(n)) time. The standard C++ library uses red-black trees, a
special form of balanced binary trees, to implement sets and maps.
Binary Search Trees
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 7
2/1/2010 2:56 PM

Figure 9   An Unbalanced Binary Search Tree
Table 1 summarizes the performance of the fundamental operations on vectors, lists, and balanced binary trees.
Table 1    Execution Times for Container Operations
Operation
Vector
Linked List
Balanced Binary Tree
Add/remove element at end
O(1)
O(1)
N/A
Add/remove element in the middle
O(n)
O(1)
O(log (n))
Get kth element
O(1)
O(k)
N/A
Find value
O(n)
O(n)
O(log (n))
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Binary Search Trees
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 7
2/1/2010 2:56 PM

Once data has been inserted into a binary search tree, it turns out to be surprisingly simple to print all elements in sorted order.
You know that all data in the left subtree of any node must come before the node and before all data in the right subtree. That
is, the following algorithm will print the elements in sorted order:
1.  Print the left subtree.
2.  Print the data.
3.  Print the right subtree.
Let's try this out with the tree in Figure 6. The algorithm tells us to
1.  Print the left subtree of 
; that is, 
 and descendants.
2.  Print 
.
3.  Print the right subtree of 
; that is, 
 and descendants.
How do you print the subtree starting at 
?
1.  Print the left subtree of 
. There is nothing to print.
2.  Print 
.
3.  Print the right subtree of 
, that is, 
.
That is, the left subtree of 
 is printed as
The right subtree of 
 is the subtree starting at 
. How is it printed? Again, using the same algorithm:
1.  Print the left subtree of 
, that is, 
.
2.  Print 
.
3.  Print the right subtree of 
. There is nothing to print.
Thus, the right subtree of 
 is printed as
Now put it all together: the left subtree, 
, and the right subtree:
The tree is printed in sorted order.
Let us implement the 
 member function. You need a worker function 
 of the 
 class:
To print the entire tree, start this recursive printing process at the root, with the following member function of the
 class.
Tree Traversal
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 5
2/1/2010 2:56 PM

Tree traversal schemes include preorder traversal,
inorder traversal, and postorder traversal.
This visitation scheme is called inorder traversal. There are two other traversal schemes, called preorder traversal and
postorder traversal.
In preorder traversal,
•  Visit the root
•  Visit the left subtree
•  Visit the right subtree
In postorder traversal,
•  Visit the left subtree
•  Visit the right subtree
•  Visit the root
These two traversals will not print the tree in sorted order. However, they are important in other applications of binary trees.
Tree traversals differ from an iterator in an important way. An iterator lets you visit a node at a time, and you can stop the
iteration whenever you like. The traversals, on the other hand, visit all elements.
It turns out to be a bit complex to implement an iterator that visits the elements of a binary tree. Just like a list iterator, a tree
iterator contains a pointer to a node. The iteration starts at the leftmost leaf. It then moves to the parent node, then to the right
child, then to the next unvisited parent's leftmost child, and so on, until it reaches the rightmost leaf. Exercise P14.12. and
Exercise P14.13. discuss two methods for implementing such a tree iterator.
ch14/bintree.cpp
Tree Traversal
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 5
2/1/2010 2:56 PM

Find node to be removed
Tree Traversal
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 5
2/1/2010 2:56 PM

contains data
If one of the children is empty, use the other
Found in root
Neither subtree is empty
Find smallest element of the right subtree
contains smallest child in right subtree
Move contents, unlink child
Tree Traversal
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 5
2/1/2010 2:56 PM

Removing leaf
Removing element with one child
Removing element with two children
Removing root
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Tree Traversal
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 5
2/1/2010 2:56 PM

A map is a data type that keeps associations between keys and values. Every key in the map has a unique value, but a value may
be associated with several keys. Figure 10 gives a typical example: a map that associates names with colors. This map might
describe the favorite colors of various people.
A map keeps associations between key and value
objects.
Figure 10   A Map
With the 
 class in the standard library, you use the 
 operator to associate keys and values. Here is an example:
You can read a score back with the same notation:
To find out whether a key is present in the map, use the 
 member function. It yields an iterator that points to the entry
with the given key, or past the end of the container if the key is not present.
The iterator of a 
 with key type  and value type  yields elements of type 
. The 
 class is a
simple class defined in the 
 header that stores a pair of values. It has two public (!) data fields 
 and 
.
Therefore, you have to go through this process to see if a key is present:
Call find
Check if there was a match
 points to a
As with pointers, you can write 
 instead of 
.
Maps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 4
2/1/2010 2:57 PM

The following loop shows how you iterate over the contents of a map:
A multimap can have multiple values associated with
the same key.
A multimap can have multiple values associated with the same key. Instead of using the 
 operator, you insert and erase pairs.
Here is an example:
Dick is a friend of Tom
Harry is also a friend of Tom
Dick is no longer a friend of Tom
The 
 function (also defined in the 
 header) makes a 
 object from its arguments.
To enumerate all values associated with a key, you obtain two iterators that define the range containing all pairs with a given
key.
Then you visit all pairs in that range.
Maps and multimaps are implemented as binary trees whose nodes contain key/value pairs. The entries are ordered by
increasing keys. You may need to define an 
 for the key type, as described in Advanced Topic 14.1.
A simple example to illustrate the use of maps and multimaps is a telephone database. The database associates names with
telephone numbers. One member function inserts elements into the database. There are member functions to look up the
number associated with a given name, and to carry out the inverse lookup of the names associated with a given number.
Because two people can have the same number, we use a 
 for the inverse lookup. The member function 
produces a listing of all entries. Because maps are stored in order based on their keys, this listing is naturally in alphabetical
order according to name.
ch14/tele.cpp
Maps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 4
2/1/2010 2:57 PM

maintains a map of name/number pairs
and an inverse multimap of numbers and names
Adds a new name/number pair to database.
the new name
the new numbe
Finds the number associated with a name.
the name being searched
the associated number, or zero
if not found in database
Finds the names associated with a number.
the number being searched
the associated names
Prints all entries.
Not found
Maps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 4
2/1/2010 2:57 PM

Program Run
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Maps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 4
2/1/2010 2:57 PM

Advanced Topic 14.2
ADVANCED TOPIC 14.2 Constant Iterators
If you carefully look at the source code of the preceding example, you will notice that the member functions for
finding and printing dictionary entries were not marked as 
. If you properly implement them as constant
member functions, the compiler will complain that the iterators are not constant. That is a legitimate problem since
you can modify a container through an iterator.
Each iterator type has a companion type for a constant iterator, similar to a constant pointer. Here is a 
-
correct implementation of the 
 function:
Not found
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 14.2 Constant Iterators
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:57 PM

The final container we will examine is the priority queue. A priority queue is a container optimized for one special task;
quickly locating the element with highest priority. Prioritization is a weaker condition than ordering. In a priority queue the
order of the remaining elements is irrelevant, it is only the highest priority element that is important.
A priority queue is a collection organized so as to
permit fast access to and removal of the largest
element.
Consider this example, where a priority queue contains strings denoting tasks:
The strings are formatted so that they start with a priority number. When it comes time to do work, we will want to retrieve and
remove the task with the top priority:
Returns "9 - Fix overflowing sink"
The term priority queue is actually a misnomer, because the priority queue does not have the “first in/first out” behavior as
does a true queue. In fact the interface for the priority queue is more similar to a stack than to a queue. The basic three
operations are 
, 
 and 
. 
 places a new element into the collection. 
 returns the element with highest priority;
 removes this element.
One obvious implementation for a priority queue is a sorted set. Then it is an easy matter to locate and remove the largest
element. However, another data structure, called a heap, is even more suitable for implementing priority queues. We will
describe heaps in the next section.
Here is a simple program that demonstrates a priority queue. Instead of storing strings, we use a 
 class. As
described in Advanced Topic 14.1, we supply an 
 function that compares work orders so that the priority queue
can find the most important one.
ch14/pqueue.cpp
Priorty Queues
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:57 PM

Program Run
Priorty Queues
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:57 PM

Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Priorty Queues
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:57 PM

Advanced Topic 14.3
ADVANCED TOPIC 14.3 Discrete Event simulations
A classic application of priority queues is in a type of simulation called a discrete event simulation. An event has a
time at which it is scheduled to occur, and an action.
You form derived classes of the 
 class for each event type. For example, an 
 event can indicate the
arrival of a customer, and a 
 event can indicate that the customer is departing. Each derived class
overrides the 
 function. Typically, the act function of one event schedules additional events. For example, when
one customer departs, another customer can be serviced. The 
 function of the 
 event generates a
random time for the duration of the next customer's service and schedules that customer's departure.
The heart of the simulation is the event loop. This loop pulls the next event from the priority queue of waiting
events. Two events are compared based on their time. The comparison is inverted, so that the element with highest
priority is the one with the lowest scheduled time. Events can be inserted in any order, but are removed in sequence
based on their time. As each event is removed, the “system clock” advances to the event's time, and the virtual 
function of the event is executed:
Typically adds new events
We face a technical issue when defining the event queue. The event queue holds 
 pointers that point to
instances of derived classes. Since pointers already have a  operator defined, we cannot define an 
that compares 
 pointers by their timestamp. Instead, we define a function for this purpose:
The earliest event should have the largest priority
We then tell the priority queue to use this comparison function:
Exercise R14.14. asks you to simulate customers in a bank. Such simulations are important in practice because
ADVANCED TOPIC 14.3 Discrete Event simulations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:57 PM

they give valuable information to business managers. For example, suppose you expect 60 customers per hour,
each of whom needs to see a teller for an average of 5 minutes. Hiring 5 tellers should be enough to service all
customers, but if you run the simulation, you may find that the average customer has to wait in line about 10
minutes. By running simulations, you can determine tradeoffs between unhappy customers and idle tellers.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
ADVANCED TOPIC 14.3 Discrete Event simulations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:57 PM

A heap (or, for greater clarity, max-heap) is a binary tree with two special properties.
1.  A heap is almost complete: all nodes are filled in, except the last level may have some nodes missing toward the right (see Figure 11).
2.  The tree fulfills the heap property: all nodes store values that are at least as large as the values stored in their descendants (see Figure
12).
Figure 11   An Almost Complete Tree
Figure 12   A Heap
It is easy to see that the heap property ensures that the largest element is stored in the root.
A heap is an almost complete tree in which the values of all
nodes are at least as large as those of their descendants.
A heap is superficially similar to a binary search tree, but there are two important differences.
1.  The shape of a heap is very regular. Binary search trees can have arbitrary shapes.
2.  In a heap, the left and right subtrees both store elements that are smaller than the root element. In contrast, in a binary search tree,
smaller elements are stored in the left subtree and larger elements are stored in the right subtree.
Suppose we have a heap and want to insert a new element. Afterwards, the heap property should again be fulfilled. The following algorithm
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 10
2/1/2010 2:57 PM

carries out the insertion (see Figure 13).
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 10
2/1/2010 2:57 PM

Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 10
2/1/2010 2:57 PM

Figure 13   Inserting an Element into a Heap
1.  First, add a vacant slot to the end of the tree.
2.  Next, demote the parent of the empty slot if it is smaller than the element to be inserted. That is, move the parent value into the vacant
slot, and move the vacant slot up. Repeat this demotion as long as the parent of the vacant slot is smaller than the element to be
inserted. (See Figure 13 continued.)
3.  At this point, either the vacant slot is at the root, or the parent of the vacant slot is larger than the element to be inserted. Insert the
element into the vacant slot.
We will not consider an algorithm for removing an arbitrary node from a heap. The only node that we will remove is the root node, which
contains the maximum of all of the values in the heap. Figure 14 shows the algorithm in action.
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 10
2/1/2010 2:57 PM

Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 10
2/1/2010 2:57 PM

Figure 14   Removing the Maximum Value from a Heap
1.  Extract the root node value.
2.  Move the value of the last node of the heap into the root node, and remove the last node. Now the heap property may be violated for
the root node, because one or both of its children may be larger.
3.  Promote the larger child of the root node. (See Figure 14 continued.) Now the root node again fulfills the heap property. Repeat this
process with the demoted child. That is, promote the larger of its children. Continue until the demoted child has no larger children.
The heap property is now fulfilled again. This process is called “fixing the heap”.
Inserting and removing heap elements is very efficient. The reason lies in the balanced shape of a heap. The insertion and removal operations
visit at most h nodes, where h is the height of the tree. A heap of height h contains at least 2h-1 elements, but less than 2h elements. In other
words, if n is the number of elements, then
or
This argument shows that the insertion and removal operations in a heap with n elements take O(log(n)) steps.
Inserting or removing a heap element is an O(log(n))
operation.
Contrast this finding with the situation of binary search trees. When a binary search tree is unbalanced, it can degenerate into a linked list, so
that in the worst case insertion and removal are O(n) operations.
The regular layout of a heap makes it possible to store heap
nodes efficiently in an array.
Heaps have another major advantage. Because of the regular layout of the heap nodes, it is easy to store the node values in an array. First
store the first layer, then the second, and so on (see Figure 15). For convenience, we leave the 0 element of the array empty. Then the child
nodes of the node with index i have index 2 · i and 2 · i + 1 , and the parent node of the node with index i has index . For example, as you can
see in Figure 15, the children of node 4 are nodes 8 and 9, and the parent is node 2.
Figure 15   Storing a Heap in an Array
Storing the heap values in an array may not be intuitive, but it is very efficient. There is no need to allocate individual nodes or to store the
links to the child nodes. Instead, child and parent positions can be determined by very simple computations.
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 10
2/1/2010 2:57 PM

The program at the end of this section contains an implementation of a heap of integers. Using templates, it is easy to extend the class to a
heap of any ordered type. (See 1, Chapter 16 for information about templates.)
ch14/heap.cpp
This class implements a heap.
Constructs an empty heap.
Adds a new element to this heap.
the element to add
Gets the maximum element stored in this heap
the maximum element
Removes the maximum element from this heap.
Returns the number of elements in this heap.
Turns the tree back into a heap, provided only the root
node violates the heap condition.
Returns the index of the left child.
the index of a node in this heap
the index of the left child of the given node
Returns the index of the right child.
the index of a node in this heap
the index of the right child of the given node
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 10
2/1/2010 2:57 PM

Returns the index of the parent.
the index of a node in this heap
the index of the parent of the given node
Returns the value of the left child.
the index of a node in this heap
the value of the left child of the given node
Returns the value of the right child.
the index of a node in this heap
the value of the right child of the given node
Returns the value of the parent.
the index of a node in this heap
the value of the parent of the given node
Add a new leaf
Demote parents that are smaller than the new element
Store the new element into the vacant slot
Remove last element
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
8 of 10
2/1/2010 2:57 PM

Promote children of removed root while they are larger than last
Get larger child
Get left child first
Use right child instead if it is larger
Check if smaller child is larger than root
Promote child
Root is larger than both children
No children
Store root element in vacant slot
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
9 of 10
2/1/2010 2:57 PM

Program Run
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Heaps
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
10 of 10
2/1/2010 2:57 PM

1.  A set is an unordered collection of distinct elements.
2.  Sets don't have duplicates. Adding a duplicate of an element that is already present is ignored.
3.  The standard C++ 
 class stores values in sorted order.
4.  A multiset (or bag) is similar to a set, but elements can occur multiple times.
5.  A binary tree consists of nodes, each of which has at most two child nodes.
6.  All nodes in a binary search tree fulfill the property that the descendants to the left have smaller data values than the
node data value, and the descendants to the right have larger data values.
7.  To insert a value in a binary search tree, recursively insert it into the left or right subtree.
8.  When removing a node with only one child from a binary search tree, the child replaces the node to be removed.
9.  When removing a node with two children from a binary search tree, replace it with the smallest node of the right
subtree.
10.  If a binary search tree is balanced, then inserting an element takes O(log(n)) time.
11.  Tree traversal schemes include preorder traversal, inorder traversal, and postorder traversal.
12.  A map keeps associations between key and value objects.
13.  A multimap can have multiple values associated with the same key.
14.  A priority queue is a collection organized so as to permit fast access to and removal of the largest element.
15.  A heap is an almost complete tree in which the values of all nodes are at least as large as those of their descendants.
16.  Inserting or removing a heap element is an O(log(n)) operation.
17.  The regular layout of a heap makes it possible to store heap nodes efficiently in an array.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Chapter Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:58 PM

Exercise R14.1.    
A school web site keeps a collection of web sites that are blocked at student computers. Should the program that checks for
blocked sites use a vector, list, set, or map for storing the site addresses?
Exercise R14.2.    
A library wants to track which books are checked out to which patrons. Should they use a map or a multimap from books
to patrons?
Exercise R14.3.    
A library wants to track which patrons have checked out which books. Should they use a map or a multimap from patrons
to books?
Exercise R14.4.    
In an emergency, a case record is made for each incoming patient, describing the severity of the case. When doctors become
available, they handle the most severe cases first. Should the case records be stored in a set, a map, or a priority queue?
Exercise R14.5.    
You keep a set of 
 objects for a scientific experiment. (A 
 has x and y coordinates.) Define a suitable
 so that you can form a 
.
Exercise R14.6.    
A 
 can be implemented as a binary tree whose nodes store data of type T. How can you implement a 
Exercise R14.7.    
What is the difference between a binary tree and a binary search tree? Give examples of each.
Exercise R14.8.    
What is the difference between a balanced tree and an unbalanced tree? Give examples of each.
Exercise R14.9.    
The following elements are inserted into a binary search tree. Make a drawing that shows the resulting tree after each
insertion.
Exercise R14.10.    
Insert the elements of Exercise R14.9. in opposite order. Then determine how the 
 function
prints out both the tree from Exercise R14.9. and this tree. Explain how the printouts are related.
Exercise R14.11.    
Consider the following tree. In which order are the nodes printed by the 
 function?
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:58 PM

Exercise R14.12.    
How does a set achieve fast execution for insertions and removals?
Exercise R14.13.    
What properties of a binary tree make it a search tree? What properties make it a balanced tree?
Exercise R14.14.    
How is a map similar to a vector? How is it different?
Exercise R14.15.    
Why is a priority queue not, properly speaking, a queue?
Exercise R14.16.    
Prove that a heap of height h contains at least 2h-1 elements but less than 2h elements.
Exercise R14.17.    
Suppose the heap nodes are stored in an array, starting with index 1. Prove that the child nodes of the heap node with index
i have index 2 · i and 2 · i + 1, and the parent heap node of the node with index i has index .
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Review Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:58 PM

Exercise P14.1.    
Reimplement the 
 class of Exercise P13.14. by using a 
 to store the coefficients.
Exercise P14.2.    
Write functions
that compute the set union and intersection of the sets  and . (Don't name the first function 
—that is a reserved
word in C++.)
Exercise P14.3.    
Implement the sieve of Eratosthenes: a function for computing prime numbers, known to the ancient Greeks. Choose an
integer n. This function will compute all prime numbers up to n. First insert all numbers from 1 to n into a set. Then erase
all multiples of 2 (except 2); that is, 4, 6, 8, 10, 12, .... Erase all multiples of 3, that is, 6, 9, 12, 15, … . Go up to 
. The
remaining numbers are all primes.
Exercise P14.4.    
Write a program that counts how often each word occurs in a text file. Use a 
.
Exercise P14.5.    
Repeat Exercise P14.4., but use a 
.
Exercise P14.6.    
Write a member function of the 
 class
that returns the smallest element of a tree.
Exercise P14.7.    
Change the 
 member function to print the tree as a tree shape. It is easier to print the tree
sideways. Extra credit if you instead print the tree with the root node centered on the top.
Exercise P14.8.    
Implement member functions that use preorder and postorder traversal to print the elements in a binary search tree.
Exercise P14.9.    
Implement a traversal function
for inorder traversal of a binary search tree that carries out an action other than just printing the node data. The action
should be supplied as a derived class of the class
Exercise P14.10.    
Use the 
 function of Exercise P14.9., and a suitable class derived from 
, to compute the sum of all
lengths of the strings stored in a tree.
Exercise P14.11.    
In the 
 class, modify the 
 member function so that a node with two children is replaced by
the largest child of the left subtree.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:58 PM

Exercise P14.12.    
Add a pointer to the parent node to the 
 class. Modify the 
 and 
 functions to properly set those
parent nodes. Then define 
 class that contains a pointer to 
. The tree's 
 member
function returns an iterator that points to the leftmost leaf. The iterator's 
 member function simply returns the data
value of the node to which it points. Its 
 member function needs to find the next element in inorder traversal. If the
current node is the left child of the parent, move to the parent. Otherwise, go to the right child if there is one, or to the
leftmost descendant of the next unvisited parent otherwise.
Exercise P14.13.    
Implement a tree iterator as described in the preceding exercise without modifying the 
 class. Hint: The iterator
needs to keep a stack of parent nodes.
Exercise P14.14.    
This problem illustrates the use of a discrete event simulation, as described in Advanced Topic 14.3. Imagine you are
planning on opening a small hot dog stand. You need to determine how many stools your stand should have. Too few
stools and you will lose customers; too many and your stand will look empty most of the time.
There are two types of events in this simulation. An arrival event signals the arrival of a customer. If seated, the customer
stays a randomly generated amount of time then leaves. A departure event frees the seat the customer was occupying.
Simulate a hotdog stand with three seats. To initialize the simulation a random number of arrival events are scheduled for
the period of one hour. The output shows what time each customer arrives and whether they stay or leave. The following is
the beginning of a typical run:
Exercise P14.15.    
Simulate the processing of customers at a bank with five tellers. Customers arrive on average once per minute, and they
need an average of five minutes to complete a transaction. Customers enter a queue to wait for the next available teller.
Use two kinds of events. An arrival event adds the customer to the next free teller or the queue and schedules the next
arrival event. When adding a customer to a free teller, also schedule a departure event. The departure event removes the
customer from the teller and makes the teller service the next customer in the waiting queue, again scheduling a departure
event.
For greater realism, use an exponential distribution for the time between arrivals and the transaction time. If m is the
desired mean time and r a uniformly distributed random number between 0 and 1, then -m log(r) has an exponential
distribution.
After each event, your program should print the bank layout, showing empty and occupied tellers and the waiting queue,
like this:
if there is no queue, or
if there is one. Simulate customer arrivals for 8 hours. At the end of the simulation, print the total number of customers
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 3
2/1/2010 2:58 PM

served and the average time each customer spent in the bank. (Your 
objects will need to track their arrival time.)
Exercise P14.16.    
In most banks, customers enter a single waiting queue, but most supermarkets have a separate queue for each cashier.
Modify Exercise P14.15. so that each teller has a separate queue. An arriving customer picks the shortest queue. What is
the effect on the average time spent in the bank?
Exercise P14.17.    
Modify the implementation of the 
 class so that the parent and child index positions are computed directly, without
calling helper functions.
Exercise P14.18.    
Modify the implementation of the 
 class so that the 0 element of the array is not wasted.
Exercise P14.19.    
Modify the implementation of the 
 class so that it stores strings, not integers. Test your implementation with the tasks
from the 
 program.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Programming Exercises
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 3
2/1/2010 2:58 PM

1.   Cay Horstmann and Tim Budd. Big C++, 2nd ed., John Wiley & Sons, 2009.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Further Reading
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 1
2/1/2010 2:59 PM

APPENDIX
   
This coding style guide is a simplified version of one that has been used with good success both in industrial practice and for
college courses. It lays down rules that you must follow for your programming assignments.
A style guide is a set of mandatory requirements for layout and formatting. Uniform style makes it easier for you to read code
from your instructor and classmates. You will really appreciate the consistency if you do a team project. It is also easier for
your instructor and your grader to grasp the essence of your programs quickly.
A style guide makes you a more productive programmer because it reduces gratuitous choice. If you don't have to make
choices about trivial matters, you can spend your energy on the solution of real problems.
In these guidelines a number of constructs are plainly outlawed. That doesn't mean that programmers using them are evil or
incompetent. It does mean that the constructs are of marginal utility and can be expressed just as well or even better with other
language constructs.
If you have already programmed in C or C++, you may be initially uncomfortable about giving up some fond habits. However,
it is a sign of professionalism to set aside personal preferences in minor matters and to compromise for the benefit of your
group.
These guidelines are necessarily somewhat long and dull. They also mention features that you may not yet have seen in class.
Here are the most important highlights:
•  Tabs are set every three spaces.
•  Variable and function names are lowercase.
•  Constant names are uppercase. Class names start with an uppercase letter.
•  There are spaces after reserved words and between binary operators.
•  Braces must line up.
•  No magic numbers may be used.
•  Every function must have a comment.
•  At most 30 lines of code may be used per function.
•  No 
, or 
 is allowed.
•  At most two global variables may be used per file.
A note to the instructor: Of course, many programmers and organizations have strong feelings about coding style. If this style
C++ Language Coding Guidelines
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 7
2/1/2010 2:56 PM







APPENDIX
   
Reserved
Word
Description
Reference Location
The Boolean type
Section 3.5
Break out of a loop or switch
Advanced Topic 3.3, 4.1
A label in a 
 statement
Advanced Topic 3.3
The character type
Section 7.3
Definition of a class
Section 9.2
Definition of a constant value, reference,
member function, or pointer
Section 2.2.4, Advanced Topic 5.2,
Advanced Topic 6.3, Section 9.2
The default case of a 
 statement
Advanced Topic 3.3
Return a memory block to the heap
Section 7.4
A loop that is executed at least once
Section 4.3
The double-precision, floating-point type
Section 2.1.2
The alternative clause in an 
 statement
Section 3.1
The false Boolean value
Section 3.5
The single-precision, floating-point type
Advanced Topic 2.1
A loop that is intended to initialize, test, and
update a variable
Section 4.2
The conditional branch statement
Section 3.1
The integer type
Section 2.1
A modifier for the 
 and 
 types that
indicates that the type may have more bytes
Advanced Topic 2.1
A name space for disambiguating names
Section 1.6
Allocate a memory block from the heap
Section 7.4
Features of a class that can only be accessed by
this class and its friends
Section 9.2
Features of a class that can be accessed by all
functions
Section 9.2
Returns a value from a function
Section 5.4
A modifier for the 
 type that indicates that
the type may have fewer bytes
Advanced Topic 2.1
Convert from one type to another
Advanced Topic 2.4
A statement that selects among multiple
branches, depending upon the value of an
expression
Advanced Topic 3.3
Reserved Word Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:57 PM

Reserved
Word
Description
Reference Location
The pointer to the implicit parameter of a
member function
Section 9.8.3
The true value of the Boolean type
Section 3.5
A modifier for the 
 and 
 types that
indicates that values of the type cannot be
negative
Advanced Topic 2.1
Importing a name space
Section 1.6
A member function with dynamic dispatch
Section 10.4
The empty type of a function or pointer
Section 5.5
A loop statement that is controlled by a
condition
Section 4.1
The following reserved words are not covered in this book:
 
 
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Reserved Word Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:57 PM

APPENDIX
   
The operators are listed in groups of decreasing precedence in the table on the next two pages. The horizontal
lines in the table indicate a change in operator precedence. For example,
means
because  has a lower precedence than .
The prefix unary operators and the assignment operators associate right-to-left. All other operators associate
left-to-right. For example,
means
because  associates left-to-right, but
means
because  associates right-to-left.
Operator
Description
Reference
Location
Scope resolution
Section 9.4.1
·
Access member
Section 2.5
Dereference and access
member
Section 9.8
Vector or array subscript
Section 6.1
Function call
Section 5.1
Increment
Section 2.2.2
Decrement
Section 2.2.2
Boolean 
Section 3.6
Bitwise 
Appendix G
 (unary)
Positive
Section 2.3.1
 (unary)
Negative
Section 2.3.1
Operator Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:57 PM

Operator
Description
Reference
Location
 (unary)
Pointer dereferencing
Section 7.1
 (unary)
Address of variable
Section 7.1
Heap allocation
Section 7.4
Heap recycling
Section 7.4
Size of variable or type
Appendix F
(type)
Cast
not covered
Access pointer to member
not covered
Dereference and access pointer
to member
not covered
Multiplication
Section 2.3.1
Division or integer division
Section 2.3.1
Integer remainder
Section 2.3.2
Addition
Section 2.3.1
Subtraction
Section 2.3.1
Output
Section 1.6,
Appendix G
Input
Section 2.2.3,
Appendix G
Less than
Section 4.3
Less than or equal
Section 4.3
Greater than
Section 4.3
Greater than or equal
Section 4.3
Equal
Section 4.3
Not equal
Section 4.3
Bitwise 
Appendix G
∧
Bitwise 
Appendix G
Bitwise 
Appendix G
Boolean 
Section 3.6
Boolean 
Section 3.6
Selection
Advanced Topic 3.4
Assignment
Section 2.2.1
∧
Combined operator and
assignment
Advanced Topic 2.3
,
Sequencing of expressions
not covered
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Operator Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:57 PM

APPENDIX
   
These escape sequences can occur in strings (for example, 
) and characters for example, 
).
Escape Sequence
Description
Newline
Carriage return
Tab
Vertical tab
Backspace
Form feed
Alert
Back slash
Double quote
Single quote
Question mark
Code specified in hexadecimal
Code specified in octal
Ascii Code Table
Dec.
Code
Hex
Code
Character
Dec.
Code
Hex
Code
Character
Dec.
Code
Hex
Code
Character
Dec.
Code
Hex
Code
Cha
0
00
 
32
20
Space
64
40
96
60
1
01
 
33
21
65
41
97
61
2
02
 
34
22
66
42
98
62
3
03
 
35
23
67
43
99
63
4
04
 
36
24
68
44
100
64
5
05
 
37
25
69
45
101
65
6
06
 
38
26
70
46
102
66
7
07
39
27
71
47
103
67
8
08
40
28
72
48
104
68
9
09
41
29
73
49
105
69
10
0A
42
2A
74
4A
106
6A
11
0B
43
2B
75
4B
107
6B
12
0C
44
2C
76
4C
108
6C
Character Codes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 2
2/1/2010 2:57 PM

Dec.
Code
Hex
Code
Character
Dec.
Code
Hex
Code
Character
Dec.
Code
Hex
Code
Character
Dec.
Code
Hex
Code
Cha
13
0D
45
2D
77
4D
109
6D
14
0E
 
46
2E
78
4E
110
6E
15
0F
 
47
2F
79
4F
111
6F
16
10
 
48
30
80
50
112
70
17
11
 
49
31
81
51
113
71
18
12
 
50
32
82
52
114
72
19
13
 
51
33
83
53
115
73
20
14
 
52
34
84
54
116
74
21
15
 
53
35
85
55
117
75
22
16
 
54
36
86
56
118
76
23
17
 
55
37
87
57
119
77
24
18
 
56
38
88
58
120
78
25
19
 
57
39
89
59
121
79
26
1A
 
58
3A
90
5A
122
7A
27
1B
 
59
3B
91
5B
123
7B
28
1C
 
60
3C
92
5C
124
7C
29
1D
 
61
3D
93
5D
125
7D
30
1E
 
62
3E
94
5E
∧
126
7E
31
1F
 
63
3F
95
5F
127
7F
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
Character Codes
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 2
2/1/2010 2:57 PM

APPENDIX
   
•  
Function: Square root, 
•  
Function: Power, xy. If x > 0, y can be any value. If x is 0, y must be > 0.
If x < 0, y must be an integer.
•  
Function: Sine, sin x (x in radians)
•  
Function: Cosine, cos x (x in radians)
•  
Function: Tangent, tan x (x in radians)
C++ Library Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 7
2/1/2010 2:57 PM

•  
Function: Decimal log, log10 (x), x > 0
•  
Function: Absolute value, |x|
•  
Function: Absolute value, |x|
•  
Function: Exits the program with status code n.
•  
Function: Random integer
•  
Function: Sets the seed of the random number generator to n.
•  
Function: Tests whether  is a letter.
•  
Function: Test whether  is a letter or a number.
•  
Function: Tests whether  is a digit.
C++ Library Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 7
2/1/2010 2:57 PM

•  
Function: Tests whether  is white space.
•  
Function: Tests whether  is lowercase.
•  
Function: Tests whether  is uppercase.
•  
Function: Returns the lowercase of .
•  
Function: Returns the uppercase of .
•  
Function: Returns the number of seconds since January 1, 1970, 00:00:00 GMT. If  is not 
, the return value is also
stored in the location to which  points.
•  
Function: Gets the next input line from the input stream 
 and stores it in the string .
Class string
•  
Member function: Returns the length of the string.
C++ Library Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 7
2/1/2010 2:57 PM

•  
Member function: Returns the substring from index  to the end of the string.
•  
Member function: Returns the substring of length  starting at index .
•  
Member function: Returns a 
 array with the characters in this string.
Class istream
•  
Function: True if input has failed.
•  
Function: Gets the next character and places it into .
•  
Function: Puts the last character read back into the stream, to be read again in the next input operation; only one character
can be put back at a time.
•  
Function: Moves the get position to position .
•  
Function: Returns the get position.
Class ostream
C++ Library Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
4 of 7
2/1/2010 2:57 PM

•  
Function: Moves the put position to position .
•  
Function: Returns the put position.
•  
Manipulator: Sets the width of the next field.
•  
Manipulator: Sets the precision of floating-point values to n digits after the decimal point.
•  
Manipulator: Selects fixed floating-point format, with trailing zeroes.
•  
Manipulator: Sets the fill character to the character .
Class ifstream
•  
Function: Opens a file with name  for reading.
Class ofstream
•  
Function: Opens a file with name  for writing.
C++ Library Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
5 of 7
2/1/2010 2:57 PM

Class 
•  
Function: Opens a file with name  for reading and writing.
Class 
•  
Function: Closes the file stream.
Notes:
•  
 is the common base class of 
, 
, and 
.
•  To open a binary file both for input and output, use 
Class 
•  
Constructs a string stream that reads from the string .
Class 
•  
Function: Returns the string that was collected by the string stream.
Notes:
•  Call 
 to construct an 
.
•  Call 
 to get a string object that contains the characters collected by the 
.
Class 
•  
C++ Library Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
6 of 7
2/1/2010 2:57 PM

Function: Returns the number of elements in the container.
•  
Function: Constructs a vector with  elements.
•  
Function: Inserts  after the last element.
•  
Function: Removes (but does not return) the last element.
•  
Function: Accesses the element at index .
•  
Function: Accesses the element at index , checking that the index is in range.
Copyright © 2009 John Wiley & Sons, Inc. All rights reserved.
C++ Library Summary
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
7 of 7
2/1/2010 2:57 PM

APPENDIX
   
Decimal notation represents numbers as powers of 10, for example
There is no particular reason for the choice of 10, except that several historical number systems were derived from people's
counting with their fingers. Other number systems, using a base of 12, 20, or 60, have been used by various cultures
throughout human history. However, computers use a number system with base 2 because it is far easier to build electronic
components that work with two values, which can be represented by a current being either off or on, than it would be to
represent 10 different values of electrical signals. A number written in base 2 is also called a binary number.
For example,
For digits after the “decimal” point, use negative powers of 2.
In general, to convert a binary number into its decimal equivalent, simply evaluate the powers of 2 corresponding to digits with
value 1, and add them up. Table 1 shows the first powers of 2.
Table 1    Powers of Two
Power
Decimal Value
20
1
21
2
22
4
23
8
24
16
25
32
Number Systems
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 6
2/1/2010 2:58 PM

Power
Decimal Value
26
64
27
128
28
256
29
512
210
1,024
211
2,048
212
4,096
213
8,192
214
16,384
215
32,768
216
65,536
To convert a decimal integer into its binary equivalent, keep dividing the integer by 2, keeping track of the remainders. Stop
when the number is 0. Then write the remainders as a binary number, starting with the last one. For example,
Therefore, 100decimal = 1100100decimal.
Conversely, to convert a fractional number less than 1 to its binary format, keep multiplying by 2. If the result is greater than 1,
subtract 1. Stop when the number is 0. Then use the digits before the decimal points as the binary digits of the fractional part,
starting with the first one. For example,
Here the pattern repeats. That is, the binary representation of 0.35 is 0.01 0110 0110 0110 …
To convert any floating-point number into binary, convert the whole part and the fractional part separately.
There are two important properties that characterize integer values in computers. These are the number of bits used in the
representation, and whether the integers are considered to be signed or unsigned.
Number Systems
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
2 of 6
2/1/2010 2:58 PM

Most computers you are likely to encounter use a 32-bit integer. However, the C++ language does not require this, and there
have been machines that used 16-, 20-, 36-, or even 64-bit integers. There are times when it is useful to have integers of
different sizes. The C++ language provides two modifiers that are used to declare such integers. A 
 (or simply a
) is an integer that, on most implementations, has fewer bits than an 
. (The phrase “on most implementations” is
necessary because the language definition only requires that a short integer have no more bits than a standard integer.) On most
platforms that use a 32-bit integer, a short is 16 bits. At the other extreme are long integers. As you might expect, a 
(or simply a 
) contains no fewer bits than a standard integer. At the present time most personal computers still use a
32-bit long, but processors that provide 64-bit longs have started to appear and will likely be more common in the future. A
character (or 
) is sometimes used as a very short (8-bit) integer. The C++ programmer therefore has the following
hierarchy of integer sizes:
Type
Typical Size
8-bit
16-bit
32-bit
32-or 64-bit
The 
 operator can be used to tell how many bits your compiler assigns to each type. This operator takes a type as
argument and returns the number of bytes each type requires. Multiplying the number of bytes by 8 will tell you the number of
bits:
If the only numbers you needed were positive, then the preceding discussion would be everything you needed to know.
However, in most applications it is more useful to allow both positive and negative values, and so a more complicated
encoding is necessary. This characteristic of an integer is declared using the modifiers 
 and 
.
An 
 integer holds only positive values. An 
 that is represented using 16 bits can maintain
the values between 0 and 65,535 (that is, between zero and 216-1). A 32-bit 
 can represent values between 0
and 4,294,967,295. If no modifier is provided, an integer is assumed to be signed.
Allowing both positive and negative values requires changing the representation of an integer value. The details of this
representation are described in the next section. However, an important feature is that allowing both positive and negative
numbers requires setting aside one bit (the so-called sign bit) to indicate whether the number is positive or negative. This
reduces the largest value that can be represented. The following table shows the range of values that can be represented using
signed and unsigned integers of 8, 16, 32, and 64 bits.
Integer Type
Range of Values
8-bit signed
-128 to 127
8-bit unsigned
0 to 255
16-bit signed
-32,768 to 32,767
16-bit unsigned
0 to 65,535
32-bit signed
-2,147,483,648 to 2,147,483,647
32-bit unsigned
0 to 4,294,967,295
Number Systems
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
3 of 6
2/1/2010 2:58 PM




APPENDIX
   
There are four bit operations in C++: the unary negation ( ) and the binary and ( ), or ( ), and exclusive or (∧),
often called xor.
Tables 1 and 2 show the truth tables for the bit operations in C++ . When a bit operation is applied to integer
values, the operation is carried out on corresponding bits.
Table 1    The Unary Negation Operation
0
1
1
0
Table 2    The Binary And, Or, and Xor Operations
∧
0
0
0
0
0
0
1
0
1
1
1
0
0
1
1
1
1
1
1
0
For example, suppose you want to compute 
. First convert both values to binary.
46decimal = 101110binary (actually 00000000000000000000000000101110 as a 32-bit integer), and
13decimal = 1101binary. Now combine corresponding bits:
The answer is 1100binary = 12decimal.
You sometimes see the  operator being used to combine two bit patterns. For example, the symbolic constant
 is the value 1, and the symbolic constant 
 is 2. The binary or combination 
 has both the
bold and the italic bit set:
Don't confuse the  and  bit operators with the 
 and 
 operators. The latter should be thought of as
operating only on 
 values, not on bits of numbers. However, through the accident of history (C++ did not
originally have Boolean values), these operators also work with integer values. To see the difference yourself, try
assigning the value of 
 to an integer variable and printing the result. Then try the same with 
.
Whether they are working with integers or Booleans, another important difference is that the 
 and 
operators evaluate their result using lazy evaluation. This means that if the result can be determined using the left
operand by itself, then the right operand is not even considered.
In addition to the operators that work on individual bits, there are shift operators that take the bit pattern of a
Bit and Shift Operations
http://edugen.wiley.com/edugen/courses/crs2656/horstmann3292/horstma...
1 of 3
2/1/2010 2:58 PM



 APPENDIX 
 
 
    H 
 
A C++ /Java Comparison 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
New Languages 
 
 
Learning to move from one language to another is a fact of life for today's software 
professionals. Whether or not C++ is your first programming language, it will undoubtedly not 
be your last. It is not uncommon for a software professional to be fluent in at least a half dozen 
or more programming languages of various types. Categories of languages include general 
purpose languages (C++ , Java, C#, Smalltalk), scripting languages (Perl, Python), Web-based 
languages (Javascript, PHP, Curl), functional languages (ML, Haskell), AI languages (Common 
Lisp, Prolog), and many others. 
 
Java and C++ are currently the two most commonly used general purpose programming 
languages. For this reason many programmers find it useful to have at least a passing familiarity 
with both languages. Fortunately, Java was inspired by C++ and many features, such as the 
control flow statements if, while, and for, were adopted almost without change. 
 
In this appendix we will describe the most basic differences between the two languages. Further 
information on the Java language can be found in 1. Information on moving to C++ if Java is 
your first programming language can be found in 2. 
 
Data Types and Variables 
 
 
In C++ the number of bits used by an integer is implementation dependent. While many 
compilers use 32-bit integers, there are some machines that use 16-, 20-, 36-, or even 64-bit 
integers. In Java the language specifies that an integer must be exactly 32 bits. 
 
The Boolean type is called boolean in Java, not bool as in C++ . 
 
The Java string type is called String. It is similar to the C++ string type, but note the 
following differences.  
 
•  Java strings cannot be modified (they are implicitly const, in C++ terms). 
 
•  Java strings store 16-bit Unicode characters, not 8-bit ASCII characters. 
 
•  You can concatenate strings with any type of object in Java, while in C++ strings can only 
be combined with strings. 
 
•  To compare strings in Java, use the member functions equals or compareTo. Both take 
an argument string. The function equals returns a Boolean, while compareTo returns an 
integer value that is less than zero if the first string is smaller than the second, zero if they 
are equal, and greater than zero if the first is larger than the second.  
String p = "abc"; 

String q = "pqr"; 
if (p.compareTo(q) < 0) … 
 
•  Many member functions in the Java string class have functionality (substrings, indexing) 
similar to, but names different from their C++ counterparts. 
 
 
Java does not have explicit pointer values or references, although internally pointers are used 
extensively (see the section on Objects, below). 
 
Variables, Constants, and Functions 
 
 
The Java compiler is obligated to check that local variables and data fields are initialized before 
they are used. This eliminates a common error in C++ programs. 
 
It is not possible to create global variables or functions in Java that are not associated with a 
class. That is, the only functions in Java are member functions. Member functions in Java are 
often called methods. 
 
Java does not have the const reserved word. An analogous reserved word, final, means that 
a value can not be reassigned. While not exactly the same (a final value can change its internal 
state, while a const in C++ cannot change in any way), the two are frequently used in the same 
fashion. 
 
Classes 
 
 
Although classes in C++ and Java are similar in intent, there are a number of superficial 
differences between them:  
 
•  In Java inheritance is signaled by the reserved word extends, rather than a colon. 
 
•  In Java the visibility modifiers public, protected, and private are attached to each 
data field and member function independently, rather than dividing the class definition into 
sections. 
 
•  All classes inherit from a base class in Java. If no explicit base class is specified, the class 
Object is used as a base class. Therefore, all classes ultimately inherit from a single base 
class named Object. 
 
•  The member function bodies are placed directly in the class definition, rather than being 
written separately. 
 
•  There is no semicolon at the end of a class. 
 
•  There is no virtual reserved word. All member functions are implicitly virtual (and 
thereby potentially subject to being overridden). 
 
•  There is no field initializer list. Data fields are initialized by an assignment statement in the 
body of a constructor. To pass data values to the constructor for a base class, the reserved 
word super is used. 
 
•  The reserved word super is also used to refer to a base class when a derived class wishes 
to invoke an overridden member function. This replaces the use of qualified names in C++ 
programs. The member function changeSalary in the example below illustrates this use.
 

 
The following is an example Java class definition:  
public class Manager extends Employee 
{ 
   public Manager(String name, int salary, double bp) 
   { 
      super(name, salary); // Invoke constructor for Employee base class 
      bonus_percent = bp; 
      bonus = bp * salary; 
   } 
 
   void changeBonus(double new_bp) 
   { 
      bonus_percent = new_bp; 
      bonus = bonus_percent * salary; 
   } 
 
   void changeSalary(int new_salary) 
   { 
      super.changeSalary(new_salary); // Invoke function from base class 
      bonus = bonus_percent * new_salary; 
   } 
 
   private int bonus; 
   private double bonus_percent; 
} 
 
Interfaces 
 
 
Java supports a concept called an interface. An interface looks superficially like a class, but uses 
the reserved word interface rather than class. An interface cannot include variable data 
fields (although it can include constants—that is, data fields declared using the modifier 
final), and does not provide implementations for member functions. In C++ terms, it is as if 
each member function were a pure virtual. An interface is therefore a description of a set of 
desired behaviors, with no implementation. The following illustrates the syntax:  
/** 
   Interface for collections that can be searched. 
*/ 
interface LookUp 
{ 
   /** 
      @param name the name being examined 
      @return true if the name is part of the collection 
   */ 
   public boolean contains(String name); 
 
   /** 
      @param name the name of the value desired 
      @return object associated with a given name 
   */ 
   public Object find(String name); 
} 
 

A class indicates that it supports the interface with the implements reserved word. It must 
then provide an implementation of each method defined by the interface.  
class SearchableContainer implements LookUp 
{ 
   … 
   public boolean contains(String name) 
   { 
     Implementation here 
   } 
} 
 
Java does not support multiple inheritance of classes. However, it does allow a class to 
implement multiple interfaces. 
 
Objects 
 
 
The most notable difference between Java and C++ is the treatment of objects. In Java object 
variables are treated internally as pointers. The Java literature refers to object variables as 
references, although they are not exactly the same as C++ references. (For example, Java object 
variables can be reassigned, whereas C++ references cannot. Java object variables can be null, 
but C++ references can never be NULL.) This means that all Java objects must be created using 
the new reserved word, as in the following:  
Employee sarah = new Employee("Sarah Smith", 67000); 
 
Parentheses are required even if there are no arguments being passed to the constructor. Note 
carefully that the variable is declared as a simple name, not as a pointer. Java does not have the 
pointer/non-pointer distinction. Even arrays must be created using the new operator. The size is 
not included as part of the declaration, but instead as part of the new operation:  
Employee[] department = new Employee[10]; // Create 10 new Employee values 
The number of elements in an array can be determined using a data field named length, as in 
department.length. Assignment in Java is equivalent to the assignment of pointers in C++ 
. That is, assignment establishes the two values as referring to the same object, instead of making 
a true copy as in C++ :  
Manager fred = new Manager("Fred Smith", 47000, 120); 
Manager james = fred; // Now they refer to the same object. 
james.changeBonus(200); // Now fred's bonus is also changed. 
To make a true copy in Java you must explicitly define a member function that returns a clone. 
 
Funtions 
 
 
In Java every function is associated with a class. There are no global variables, nor ordinary (that 
is, nonmember) functions. To execute a Java program you specify the starting class, and the 
function named main in that class is invoked. The function main does not return a value in 
Java. 
 
Function invocations pass object references by value. There is no equivalent to the C++ pass by 
value or pass by reference. This is illustrated by the following:  
class RewardSystem 

{ 
   // Functions can only be found in classes 
   public void yearEndUpdate(Manager man) 
   { 
      man.changeBonus(0.35); // Update bonus to 35% 
      man = new Manager("Sally Jones", 47000, 23); 
         // Unlike C++ pass by reference, will NOT change the value of the 
         // actual argument. 
   } 
} 
 
RewardSystem man_class = new RewardSystem(); 
Manager fred = new Manager("Fred Smith", 47000, 120); 
man_class.yearEndUpdate(fred); // Will have the effect of changing 
                               // the value fred.bonus 
 
Arrays and Array Lists 
 
 
All Java arrays are allocated on the heap:  
String[] names = new String[100]; 
Note that the [] is placed with the type, not the variable name. 
 
The analog to the C++ vector is the ArrayList. You use the get and set methods, not the 
[] operator, to access the elements:  
ArrayList<String> names; 
names.add("Harry"); // The analog of push_back 
names.add("Lisa"); 
for (int i = 0; i < names.size(); i++) 
{ 
    String name = names.get(i); 
    names.set(i, "***"); 
} 
 
Memory Management 
 
 
In C++ the programmer is explicitly required to manage dynamic memory using the new and 
delete operators. Java includes a garbage collection system as part of its run-time library. The 
garbage collector monitors a running program and automatically recovers memory when it can 
no longer be used. This eliminates many memory leaks that can plague C++ programs. 
 
Exception Handling 
 
 
Exception handling is much more tightly integrated in Java than it is in C++. There are two 
categories of exceptions: checked exceptions (similar to runtime_error in C++ ), and 
unchecked exceptions (similar to logic_error in C++ ). Member functions that potentially 
can throw a checked exception must declare this using the throws reserved word. The compiler 
ensures that an invocation of such a function occurs in the context of a try/catch statement 
that will handle the exception. Values thrown must be objects from a class that is derived from a 
system class named Throwable. There are other small differences in the various forms the 
catch statement; these are described in 2.  

public class Employee 
{ 
   … 
   void initializeFromFile(File f) throws IOException 
   { 
      … 
      if (…) 
         throw new IOException("Cannot Initialize"); 
   } 
} 
 
Employee fred = new Employee(); 
File fin = new File("fred.data"); 
try 
{ 
   fred.initializeFromFile(fin); 
} 
catch (IOException e) 
{ 
   System.out.println("Received I/O Exception " + e); 
} 
catch (Exception e) // Catch any other type of exception 
{ 
   System.out.println("Received other exception " + e); 
} 
 
Standard Library 
 
 
While the Java language is arguably smaller and simpler than C++ , the same cannot be said for 
the standard library. The Java standard library is enormous, covering such features as 
internationalization, networking, mathematics, sound, Web applications and services, databases, 
and much more. Because the library is continually being added to, no reference can be entirely 
comprehensive. Most programmers are familiar with only a tiny fraction of this library. The most 
up-to-date information can be found at Sun's official Java Web site, http://java.sun.com. 
 
Further Reading 
 
 
1.   Cay Horstmann, Big Java, 3rd ed., John Wiley & Sons, Inc., 2008.  
2.   Timothy Budd, C++ for Java Programmers, Addison-Wesley, 1999.  
 

