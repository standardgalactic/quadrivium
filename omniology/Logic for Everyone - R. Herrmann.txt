arXiv:math.GM/0601709 v1   29 Jan 2006
LOGIC FOR EVERYONE
Robert A. Herrmann
1

Previous titled “Logic For Midshipmen”
Mathematics Department
U. S. Naval Academy
572C Holloway Rd.
Annapolis, MD 21402-5002
2

CONTENTS
Chapter 1
Introduction
1.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
Chapter 2
The Propositional Calculus
2.1
Constructing a Language by Computer
. . . . . . . . . . . . . . . . . . . . . . . .
9
2.2
The Propositional Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
2.3
Slight Simpliﬁcation, Size, Common Pairs . . . . . . . . . . . . . . . . . . . . . .
13
2.4
Model Theory — Basic Semantics
. . . . . . . . . . . . . . . . . . . . . . . . .
15
2.5
Valid Formula
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
2.6
Equivalent Formula . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
2.7
The Denial, Normal Form, Logic Circuits
. . . . . . . . . . . . . . . . . . . . . .
26
2.8
The Princeton Project, Valid Consequences
. . . . . . . . . . . . . . . . . . . . .
32
2.9
Valid Consequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
2.10
Satisfaction and Consistency
. . . . . . . . . . . . . . . . . . . . . . . . . . .
38
2.11
Proof Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
2.12
Demonstrations, Deduction from Premises
. . . . . . . . . . . . . . . . . . . . .
45
2.13
The Deduction Theorem
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
2.14
Deducibility Relations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
2.15
The Completeness Theorem
. . . . . . . . . . . . . . . . . . . . . . . . . . .
52
2.16
Consequence Operators
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.17
The Compactness Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
Chapter 3
Predicate Calculus
3.1
First-Order Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
3.2
Free and Bound Variable Occurrences . . . . . . . . . . . . . . . . . . . . . . . .
67
3.3
Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
3.4
Valid Formula in Pd. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
3.5
Valid Consequences and Models
. . . . . . . . . . . . . . . . . . . . . . . . . .
82
3.6
Formal Proof Theory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
3.7
Soundness and Deduction Theorem for Pd′
. . . . . . . . . . . . . . . . . . . . .
87
3.8
Consistency, Negation Completeness, Compactness, Inﬁnitesimals
. . . . . . . . . . .
91
3.9
Ultralogics and Natural Systems
. . . . . . . . . . . . . . . . . . . . . . . . . .
97
Appendix
Chapter 2
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
Chapter 3
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
105
Answers to Some Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
109
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
123
3

4

Chapter 1 - INTRODUCTION
1.1 Introduction.
The discipline known as Mathematical Logic will not speciﬁcally be deﬁned within this text. Instead,
you will study some of the concepts in this signiﬁcant discipline by actually doing mathematical logic. Thus,
you will be able to surmise for yourself what the mathematical logician is attempting to accomplish.
Consider the following three arguments taken from the disciplines of military science, biology, and
set-theory, where the symbols (a), (b), (c), (d), (e) are used only to locate speciﬁc sentences.
(1) (a) If armored vehicles are used, then the battle will be won. (b) If the infantry walks to the
battle ﬁeld, then the enemy is warned of our presence. (c) If the enemy is warned of our presence
and armored vehicles are used, then we sustain many casualties. (d) If the battle is won and we
sustain many casualties, then we will not be able to advance to the next objective. (e) Consequently,
if the infantry walks to the battle ﬁeld and armored vehicles are used, then we will not be able to
advance to the next objective.
(2) (a) If bacteria grow in culture A, then the bacteria growth is normal. (b) If an antibiotic is
added to culture A, then mutations are formed. (c) If mutations are formed and bacteria grow in
culture A, then the growth medium is enriched. (d) If the bacteria growth is normal and the growth
medium is enriched, then there is an increase in the growth rate. (e) Thus, if an antibiotic is added
to culture A and bacteria grow in culture A, then there is an increase in the growth rate.
(3) (a) If b ∈B, then (a, b) ∈A × B. (b) If c ∈C, then s ∈S. (c) If s ∈S and b ∈B, then
a ∈A. (d) If (a, b) ∈A × B and a ∈A, then (a, b, c, s) ∈A × B × C × S. (e) Therefore, if c ∈C and
b ∈B, then (a, b, c, s) ∈A × B × C × S.
With respect to the three cases above, the statements that appear before the words “Consequently,
Thus, Therefore” need not be assumed to be “true in reality.” The actual logical pattern being presented is
not, as yet, relative to the concept of what is “true in reality.” How can we analyze the logic behind each of
these arguments? First, notice that each of the above arguments employs a technical language peculiar to the
speciﬁc subject under discussion. This technical language should not aﬀect the logic of each argument. The
logic is something “pure” in character which should be independent of such phrases as a ∈A. Consequently,
we could substitute abstract symbols – symbols that carry no meaning and have no internal structure – for
each of the phrases such as the one “we will not be able to advance to the next objective.” Let us utilize the
symbols P, Q, R, S, T, H as replacements for these phrases with their technical terms.
Let P = armored vehicles are used, Q = the battle will be won, R = the infantry walks to the battle ﬁeld,
S = the enemy is warned of our presence, H = we sustain many casualties, T= we will not be able to advance
to the next objective. Now the words Consequently, Thus, Therefore are replaced by the symbol ⊢, where the
⊢represents the processes the human mind (brain) goes through to “logically arrive at the statement” that
follows these words.
Mathematics, in its most fundamental form, is based upon human experience and what we do next
is related totally to such an experience. You must intuitively know your left from your right, you must
intuitively know what is means to “move from the left to the right,” you must know what it means to
“substitute” one thing for another, and you must intuitively know one alphabet letter from another although
diﬀerent individuals may write them in slightly diﬀerent forms. Thus P is the same as P, etc. Now each
of the above sentences contains the words If and then. These two words are not used when we analyze the
above three logical arguments they will intuitively be understood. They will be part of the symbol →.
Any time you have a statement such as “If P, then Q” this will be symbolized as P →Q. There is one
other important word in these statements. This word is and. We symbolize this word and by the symbol
∧. What do these three arguments look like when we translate them into these deﬁned symbols? Well, in
the next display, I’ve used the “comma” to separated the sentences and parentheses to remove any possible
misunderstandings that might occur. When the substitutions are made in argument (1) and we write the
sentences (a), (b), (c), (d), (e) from left to right, the logical argument looks like
P →Q, R →S, (S ∧P) →H, (Q ∧H) →T ⊢(R ∧P) →T.
(1)′
5

Now suppose that you use the same symbols P, Q, R, S, H, T for the phrases in the sentence (a), (b), (c),
(d), (e) (taken in the same order from left to right) for arguments (2), (3). Then these next two arguments
would look like
P →Q, R →S, (S ∧P) →H, (Q ∧H) →T ⊢(R ∧P) →T.
(2)′
P →Q, R →S, (S ∧P) →H, (Q ∧H) →T ⊢(R ∧P) →T.
(3)′
Now, from human experience, compare these three patterns (i.e. compare them as if they are geometric
conﬁgurations written left to right). It is obvious, is it not, that they are the “same.” What this means for
us is that the logic behind the three arguments (1), (2) , (3) appears to be the same logic. All we need to
do is to analyze one of the patterns such as (1)′ in order to understand the process more fully. For example,
is the logical argument represented by (1)′ correct?
One of the most important basic questions is how can we mathematically analyze such a logical pattern
when we must use a language for the mathematical discussion as well as some type of logic for the analysis?
Doesn’t this yield a certain type of double think or an obvious paradox? This will certainly be the case if we
don’t proceed very carefully. In 1904, David Hilbert gave the following solution to this problem which we
re-phrase in terms of the modern computer. A part of Hilbert’s method can be put into the following form.
The abstract language involving the symbols P, Q, R, S, T, H, ⊢, ∧, →are part of the computer language
for a “logic computer.” The manner in which these symbols are combined together to form correct logical
arguments can be checked or veriﬁed by a ﬁxed computer program. However, outside of the computer we use
a language to write, discuss and use mathematics to construct, study and analyze the computer programs
before they are entered into various ﬁles. Also, we analyze the actual computer operations and construction
using the same outside language. Further, we don’t speciﬁcally explain the human logic that is used to do
all of this analysis and construction. Of course, the symbols P, Q, R, S, T, H, ⊢, ∧, →are a small part
of the language we use. What we have is two languages. The language the computer understands and the
much more complex and very large language — in this case English — that is employed to analyze and
discuss the computer, its programs, its operations and the like. Thus, we do our mathematical analysis of
the logic computer in what is called a metalanguage (in this case English) and we use the simplest possible
human logic called the metalogic which we don’t formally state. Moreover, we use the simplest and most
convincing mathematical procedures — procedures that we call metamathematics. These procedures are
those that have the largest amount of empirical evidence that they are consistent. In the literature the term
meta is sometimes replaced by the term observer. Using this compartmentizing procedure for the languages,
one compartment the computer language and another compartment a larger metalanguage outside of the
computer, is what prevents the mathematical study of logic from being “circular” or a “double think” in
character. I mention that the metalogic is composed of a set of logical procedures that are so basic in
character that they are universally held as correct. We use simple principles to investigate some highly
complex logical concepts in a step-b-step eﬀective manner.
It’s clear that in order to analyze mathematically human deductive procedures a certain philosophical
stance must be taken. We must believe that the mathematics employed is itself correct logically and, indeed,
that it is powerful enough to analyze all signiﬁcant concepts associated with the discipline known as “Logic.”
The major reason we accept this philosophical stance is that the mathematical methods employed have
applications to thousands of areas completely diﬀerent from one another. If the mathematical methods
utilized are somehow in error, then these errors would have appeared in all of the thousands of other areas
of application. Fortunately, mathematicians attempt, as best as they can, to remove all possible error from
their work since they are aware of the fact that their research ﬁndings will be used by many thousands of
individuals who accept these ﬁnding as absolutely correct logically.
It’s the facts expressed above that leads one to believe that the carefully selected mathematical proce-
dures used by the mathematical logician are as absolutely correct as can be rendered by the human mind.
Relative to the above arguments, is it important that they be logically correct? The argument as stated in
biological terms is an actual experimental scenario conducted at the University of Maryland Medical School,
from 1950 – 51, by Dr. Ernest C. Herrmann, this author’s brother. I actually aided, as a teenager, with the
basic mathematical aspects for this experiment. It was shown that the continued use of an antibiotic not only
produced resistant mutations but the antibiotic was also an enriched growth medium for such mutations.
Their rate of growth increased with continued use of the same antibiotic. This led to a change in medical
6

procedures, at that time, where combinations of antibiotics were used to counter this fact and the saving of
many more lives. But, the successful conclusion of this experiment actually led to a much more signiﬁcant
result some years later when my brother discovered the ﬁrst useful anti-viral agent. The signiﬁcance of this
discovery is obvious and, moreover, with this discovery began the entire scientiﬁc discipline that studies and
produces anti-viral drugs and agents.
From 1979 through 1994, your author worked on one problem and two questions as they were presented
to him by John Wheeler, the Joseph Henry Professor of Theoretical Physics at Princeton University. These
are suppose to be the “greatest problem and questions on the books of physics.” The ﬁrst problem is called
the General Grand Uniﬁcation Problem. This means to develop some sort of theory that will unify, under
a few theoretical properties, all of the scientiﬁc theories for the behavior of all of the Natural systems that
comprise our universe. Then the two other questions are “How did our universe come into being?” and
“Of what is empty space composed?” As research progressed, ﬁndings were announced in various scientiﬁc
journals. The ﬁrst announcement appeared in 1981 in the Abstracts of papers presented before the American
Mathematical Society, 2(6), #83T-26-280, p. 527. Six more announcements were made in this journal, the
last one being in 1986, 7(2),# 86T-85-41, p. 238, entitled “A solution of the grand uniﬁcation problem.”
Other important papers were published discussing the methods and results obtained. One of these was
published in 1983, “Mathematical philosophy and developmental processes,” Nature and System, 5(1/2), pp.
17-36. Another one was the 1988 paper, “Physics is legislated by a cosmogony,” Speculations in Science and
Technology, 11(1), pp. 17-24. There have been other publications using some of the procedures that were
developed to solve this problem and answer the two questions. The last paper, which contained the entire
solution and almost all of the actual mathematics, was presented before the Mathematical Association of
America, on 12 Nov., 1994, at Western Maryland College.
Although there are numerous applications of the methods presented within this text to the sciences, it
is shown in section 3.9 that there exists an elementary ultralogic as well as an ultraword. The properties
associated with these two entities should give you a strong indication as to how the above discussed theoretical
problem has been solved and how the two physical questions have been answered.
7

NOTES
8

Chapter 2 - THE PROPOSITIONAL CALCULUS
2.1 Constructing a Language By Computer.
Suppose that you are given the symbols P, Q, ∧, and left parenthesis (, right parenthesis ). You want to
start with the set L0 = {P, Q} and construct the complete set of diﬀerent (i.e. not geometrically congruent
in the plane) strings of symbols L1 that can be formed by putting the ∧between two of the symbols from the
set L0, with repetitions allowed, and putting the ( on the left and the ) on the right of the construction.
Also you must include the previous set L0as a subset of L1. I hope you see easily that the complete set
formed from these (metalanguage) rules would be
L1 = {P, Q, (P ∧P), (Q ∧Q), (P ∧Q), (Q ∧P)}
(2.1.1)
Now suppose that you start with L1 and follow the same set of rules and construct the complete set of
symbol strings L2. This would give
L2 = {P, Q, (P ∧P), (P ∧Q), (P ∧(P ∧P)), (P ∧(P ∧Q)), (P ∧(Q ∧P)),
(P ∧(Q ∧Q)), (Q ∧P), (Q ∧Q), (Q ∧(P ∧P)), (Q ∧(P ∧Q)), (Q ∧(Q ∧P)),
(Q ∧(Q ∧Q)), ((P ∧P) ∧P), ((P ∧P) ∧Q), ((P ∧P) ∧(P ∧P)), ((P ∧P) ∧(P ∧Q)),
((P ∧P) ∧(Q ∧P)), ((P ∧P) ∧(Q ∧Q)), ((P ∧Q) ∧P), ((P ∧Q) ∧Q),
((P ∧Q) ∧(P ∧P)), ((P ∧Q) ∧(P ∧Q)), ((P ∧Q) ∧(Q ∧P)),
((P ∧Q) ∧(Q ∧Q)), ((Q ∧P) ∧P), ((Q ∧P) ∧Q),
((Q ∧P) ∧(P ∧P)), ((Q ∧P) ∧(P ∧Q)), ((Q ∧P) ∧(Q ∧P)),
((Q ∧P) ∧(Q ∧Q)), ((Q ∧Q) ∧P), ((Q ∧Q) ∧Q),
((Q ∧Q) ∧(P ∧P)), ((Q ∧Q) ∧(P ∧Q)),
((Q ∧Q) ∧(Q ∧P)), ((Q ∧Q) ∧(Q ∧Q))}.
(2.1.2)
Now I did not form the, level two, L2 by guess. I wrote a simple computer program that displayed this
result. If I now follow the same instructions and form level three, L3, I would print out a set that takes four
pages of small print to express. But you have the intuitive idea, the metalanguage rules, as to what you
would do if you had the previous level, say L3, and wanted to ﬁnd the strings of symbols that appear in L4.
But, the computer would have a little diﬃculty in printing out the set of all diﬀerent strings of symbols or
what are called formulas, (these are also called well-deﬁned formula by many authors and, in that case, the
name is abbreviated by the symbol wﬀs). Why? Since there are 2,090,918 diﬀerent formula in L4. Indeed,
the computer could not produce even internally all of the formulas in level nine, L9, since there are more
than 2.56 × 1078 diﬀerent symbol strings in this set. This number is greater than the estimated number of
atoms in the observable universe. But you will soon able to show that (((((((((P ∧Q) ∧(Q ∧Q))))))))) ∈L9
(∈means member of) and this formula is not a member of any other level that comes before L9. You’ll also
be able to show that (((P ∧Q) ∧(P ∧Q)) is not a formula at all. But all that is still to come.
In the next section, we begin a serious study of formula, where we can investigate properties associated
with these symbol strings on any level of construction and strings that contain many more atoms, these are
the symbols in L0, and many more connectives, these are symbols like ∧, →and more to come.
2.2 The Propositional Language.
The are many things done in mathematical logic that are a mathematical formalization of obvious and
intuitive things such as the above construction of new symbol strings from old symbol strings. The intuitive
concept comes ﬁrst and then the formalization comes after this. In many cases, I am going to put
the actual accepted mathematical formalization in the appendix. If you have a background in mathematics,
then you can consult the appendix for the formal mathematical deﬁnition. As I deﬁne things, I will indicate
that the deeper stuﬀappears in the appendix by writing (see appendix).
We need a way to talk about formula in general. That is we need symbols that act like formula variables.
This means that these symbols represent any formula in our formal language, with or without additional
restrictions such as the level Ln in which they are members.
9

Deﬁnition 2.2.1. Throughout this text, the symbols A, B, C, D, E, F (letters at the front of the
alphabet) will denote formula variables.
In all that follows, we use the following interpretation metasymbol, “⌈⌉:” I’ll show you the meaning of
this by example. The symbol will be presented in the following manner.
⌈A⌉: . . . . . . . . . . . . .
There will be stuﬀwritten where the dots . . . . . . . . . . . . . . . are placed. Now what you do is the
substitute for the formula A, in ever place that it appears, the stuﬀthat appears where the . . . . . . . . . .
. . . . are located. For example, suppose that
⌈A⌉: it rained all day, ⌈∧⌉: and
Then for formula A ∧A, the interpretation ⌈A ∧A⌉: would read
it rained all day and it rained all day
You could then adjust this so that it corresponds to the correct English format. This gives
It rained all day and it rained all day.
Although it is not necessary that we use all of the following logical connectives, using them makes it
much easier to deal with ordinary everyday logical arguments.
Deﬁnition 2.2.2. The following is the list of basic logical connectives with their technical names.
(i) ¬ (Negation)
(iv) →(The conditional)
(ii) ∧(Conjunction)
(v) ↔(Biconditional)
(iii) ∨(Disjunction)
REMARK: Many of the symbols in Deﬁnition 2.2.2 carry other names throughout the literature and
even other symbols are used.
To construct a formal language from the above logical connectives, you consider (ii), (iii), (iv), (v) as
binary connectives, where this means that some formula is placed immediately to the left of each of them
and some formula is placed immediately to the right. BUT, the symbol ¬ is special. It is called an unary
connective and formulas are formed as follows: your write down ¬ and place a formula immediately to the
right and only the right of ¬. Hence if A is a formula, then ¬A is also a formula.
Deﬁnition 2.2.3. The construction of the propositional language L (see appendix).
(1) Let P, Q, R, S, P1, Q1, R1, S1, P1, Q2, R2, S2, . . . be an inﬁnite set of starting formula
called the set of atoms.
(2) Now, as our starting level, take any nonempty subset of these atoms, and call it L0.
(3) You construct, in a step-by-step manner, the next level L1. You ﬁrst consider as members
of L1 all the elements of L0. Then for each and every member A in L0 (i.e. A ∈L0) you add (¬A)
to L1. Next you take each and every pair of members A, B from L0 where repetition is allowed
(this means that B could be the same as A), and add the new formulas (A ∧B), (A ∨B), (A →
B), (A ↔B). The result of this construction is the set of formula L1. Notice that in L1 every
formula except for an atom has a left parenthesis ( and a right parenthesis ) attached to it. These
parentheses are called extralogical symbols.
(4) Now repeat the construction using L1 in place of L0 and you get L2.
(5) This construction now continues step-by-step so that for any natural number n you have a
level Ln constructed from the previous level and level Ln contains the previous levels.
(6) Finally, a formula F is a member of the propositional language L if and only if there is some
natural number n ≥0 such that F ∈Ln.
Example 2.2.1 The following are examples of formula and the particular level Li indicated is the ﬁrst
level in which they appear. Remember that ∈means “a member or element of”.
P ∈L0; (¬P) ∈L1; (P ∧(Q →R)) ∈L2; ((P ∧Q) ∧R) ∈L2; (P ∧(Q ∧R)) ∈L2; ((P →Q) ∨(Q →
S)) ∈L2; (P →(Q →(R →S2))) ∈L3.
10

Example 2.2.2 The following are examples of strings of symbols that are NOT in L.
(P); ((P →Q); ¬(P); ()Q; (P →(Q)); (P = (Q →S)).
Unfortunately, some more terms must be deﬁned so that we can communicate successfully. Let A ∈L.
The size(A) is the smallest n ≥0 such that A ∈Ln. Note that if size(A) = n, then A ∈Lm for each level m
such that m ≥n. And, of course, A ̸∈Lk for all k, if any, such that 0 ≤k < n. (̸∈is read “not a member
of”). Please note what symbols are metasymbols and that they are not symbols within the formal language
L.
There does not necessary exist a unique interpretation of the above formula in terms of English language
expressions. There is a very basic interpretation, but there are others that experience indicates are logically
equivalent to the basic interpretations. The symbol IN means the set {0, 1, 2, 3, 4, 5, . . .} of natural numbers
including zero.
Deﬁnition 2.2.4 The basic English language interpretations.
(i) ⌈¬⌉: not, (it is not the case that).
(ii) ⌈∧⌉: and
(iii) ⌈∨⌉: or
(iv) For any A ∈L0, ⌈A⌉: a simple declarative sentence, a sentence which contains no interpreted
logical connectives OR a set of English language symbols that is NOT considered as decomposed
into distinct parts.
(v) For any n ∈IN, A, B ∈Ln; ⌈A ∨B⌉: ⌈A⌉or ⌈B⌉.
(vi) For any n ∈IN, A, B ∈Ln; ⌈A ∧B⌉: ⌈A⌉and ⌈B⌉.
(vii) For any n ∈IN, A, B ∈Ln; ⌈A →B⌉: if ⌈A⌉, then ⌈B⌉.
(viii) For any n ∈IN, A, B ∈Ln; ⌈A ↔B⌉: ⌈A⌉if and only if ⌈B⌉.
(ix) The above interpretations are then continued “down” the levels Ln until they stop at level L0.
Please note that the above is not the only translations that can be applied to these formulas. Indeed,
the electronic hardware known as switching circuits or gates can also be used to interpret these formulas.
This hardware interpretation is what has produced the modern electronic computer.
Unfortunately, when translating from English or conversely the members of L, the above basic inter-
pretations must be greatly expanded. The following is a list for reference purposes of the usual English
constructions that can be properly interpreted by members of L.
(x) For any n ∈IN, A, B ∈Ln; ⌈A ↔B⌉:
(a) ⌈A⌉if ⌈B⌉, and ⌈B⌉if ⌈A⌉.
(g) ⌈A⌉exactly if ⌈B⌉.
(b) If ⌈A⌉, then ⌈B⌉, and conversely.
(h) ⌈A⌉is material equivalent to ⌈B⌉.
(c) ⌈A⌉is (a) necessary and suﬃcient (condition) for ⌈B⌉
(d) ⌈A⌉is equivalent to ⌈B⌉. (sometimes used in this manner)
(e) ⌈A⌉exactly when ⌈B⌉.
(i) ⌈A⌉just in case ⌈B⌉.
(f) If and only if ⌈A⌉, (then) ⌈B⌉.
(xi) For any n ∈IN, A, B ∈Ln; ⌈A →B⌉:
(a) ⌈B⌉if ⌈A⌉.
(h) ⌈A⌉only if ⌈B⌉.
(b) When ⌈A⌉, then ⌈B⌉.
(i) ⌈B⌉when ⌈A⌉.
(c) ⌈A⌉only when ⌈B⌉.
(j) In case ⌈A⌉, ⌈B⌉.
(d) ⌈B⌉in case ⌈A⌉.
(k) ⌈A⌉only in case ⌈B⌉.
(e) ⌈A⌉is a suﬃcient condition for ⌈B⌉.
(f) ⌈B⌉is a necessary condition for ⌈A⌉.
(g) ⌈A⌉materially implies ⌈B⌉.
(l) ⌈A⌉implies ⌈B⌉.
(xii) For any n ∈IN, A, B ∈Ln; ⌈A ∧B⌉:
(a) Both ⌈A⌉and ⌈B⌉.
(e) Not only ⌈A⌉but ⌈B⌉.
(b) ⌈A⌉but ⌈B⌉.
(f) ⌈A⌉while ⌈B⌉.
(c) ⌈A⌉although ⌈B⌉.
(g) ⌈A⌉despite ⌈B⌉.
(d) ⌈A⌉yet ⌈B⌉.
11

(xiii) For any n ∈IN, A, B ∈Ln; ⌈A ∨B⌉:
(a) ⌈A⌉or ⌈B⌉or both.
(d) ⌈A⌉and/or ⌈B⌉
(b) ⌈A⌉unless ⌈B⌉.
(e) Either ⌈A⌉or ⌈B⌉. (usually)
(c) ⌈A⌉except when ⌈B⌉. (usually)
(xiv) For any n ∈IN, A, B ∈Ln; ⌈(A ∨B) ∧(¬(A ∧B))⌉:
(a) ⌈A⌉or ⌈B⌉not both.
(c) ⌈A⌉or else ⌈B⌉. (usually)
(b) ⌈A⌉or ⌈B⌉. (sometimes)
(d) Either ⌈A⌉or ⌈B⌉. (sometimes)
(xv) For any n ∈IN, A, B ∈Ln; ⌈(¬(A ↔B))⌉: ⌈((¬A) ↔B)))⌉:
(a) ⌈A⌉unless ⌈B⌉. (sometimes)
(xvi) For any n ∈IN, A, B ∈Ln; ⌈(A ↔(¬B))⌉:
(a) ⌈A⌉except when ⌈B⌉. (sometimes)
(xvii) For any n ∈IN, A, B ∈Ln; ⌈(¬(A ∨B))⌉:
(a) Neither ⌈A⌉nor ⌈B⌉.
(xviii) For any n ∈IN, A ∈Ln; ⌈(¬A)⌉:
Not ⌈A⌉(or the result of transforming ⌈A⌉to give the intent of “not” such as “⌈A⌉doesn’t hold” or
“⌈A⌉isn’t so.”
EXERCISES 2.2
In what follows assume that P, Q, R, S ∈L0.
1. Let A represent each of the following strings of symbols. Determine if A ∈L or A ̸∈L. State your
conclusions.
(a) A = (P ∨(Q →(¬S))
(f) A =)P) ∨((¬S)))
(b) A = (P ↔(Q ∨S))
(g) A = (P ↔(¬(R ↔S)))
(c) A = (P →(S ∧R))
(h) A = (R ∧(¬(R ∨S)) →P)
(d) A = ((P) →(R ∧S))
(i) A = (P ∧(P ∧P) →Q)
(e) A = (¬P) →(¬(R ∨S))
(j) A = ((P ∧P) →P →P)
2. Each of the following formula A are members of L. Find the size(A) of each.
(a) A = ((P ∨Q) →(S →R))
(c) A = (P ∨(Q ∧(R ∧S)))
(b) A = (((P ∨Q) →R) ↔S)
(d) A = (((P ∨Q) ↔(P ∧Q)) →S)
3. Use the indicated atomic symbol to translate each of the following into a member of L.
(a) Either (P) the port is open or (Q) someone left the shower on.
(b) If (P) it is foggy tonight, then either (Q) the Captain will stay in his cabin or (R) he will call me to
extra duty.
(c) (P) Midshipman Jones will sit, and (Q) wait or (R) Midshipman George will wait.
(d) Either (Q) I will go by bus or (R) (I will go) by airplane.
(e) (P) Midshipman Jones will sit and (Q) wait, or (R) Midshipman George will wait.
(f) Neither (P) Army nor (Q) Navy won the game.
(g) If and only if the (P) sea-cocks are open, (Q) will the ship sink; (and) should the ship sink, then
(R) we will go on the trip and (S) miss the dance.
(h) If I am either (P) tired or (Q) hungry, then (R) I cannot study.
(i) If (P) Midshipman Jones gets up and (Q) goes to class, (R) she will pass the quiz; and if she does
not get up, then she will fail the quiz.
4. Let ⌈P⌉: it is nice; ⌈Q⌉: it is hot; ⌈R⌉: it is cold; ⌈S⌉: it is small. Translate (interpret) the following
formula into acceptable non-ambiguous English sentences.
(a) (P →(¬(Q ∧R)))
(d) ((S →Q) ∨P)
(b) (S ↔P)
(e) (P ↔((Q ∧(¬R)) ∨S))
12

(c) (S ∧(P ∨Q))
(f) ((S →Q) ∨P)
2.3 Slight Simpliﬁcation, Size, Common Pairs and Computers.
Each formula has a unique size n, where n is a natural number, IN, greater than or equal to zero. Now
if size(A) = n, then A ∈Lm for all m ≥n, and A ̸∈Lm for all m < n. For each formula that is not an atom,
there appears a certain number of left “(” and right “)” parentheses. These parentheses occur in what is
called common pairs. Prior to the one small simpliﬁcation we may make to a formula, we’ll learn how to
calculate which parentheses are common pairs. The common pairs are the parentheses that are included in
a speciﬁc construction step for a speciﬁc level Ln. The method we’ll use can be mathematically established;
however, its demonstration is somewhat long and tedious. Thus the “proof” will be omitted. The following
is the common pair rule.
Rule 2.3.1. This is the common pair rule (CPR). Suppose that we are given an expression that is
thought to be a member of L.
(1) Select any left parenthesis “(.” Denote this parenthesis by the number +1.
(2) Now moving towards the right, each time you arrive at another left parenthesis “(” add the number
1 to the previous number.
(3) Now moving towards the right, each time you arrive at a right parenthesis “)” subtract the number
1 from the previous number.
(4) The ﬁrst time you come to a parenthesis that yields a ZERO by the above cumulative alge-
braic summation process, then that particular parenthesis is the companion parenthesis with which the ﬁrst
parenthesis you started with forms a common pair.
The common pair rule will allow us to ﬁnd out what expressions within a formula are also formula. This
rule will also allow us to determine the size of a formula. A formula is written in atomic form if only atoms,
connectives, and parentheses appear in the formula.
Deﬁnition 2.3.1 Non-atomic subformula.
Given an A ∈L (written in atomic form). A subformula is any expression that appears between and
includes a common pair of parentheses.
Note that according to Deﬁnition 2.3.1, the formula A is a subformula. I now state, without proof, the
theorem that allows us to determine the size of a formula.
Theorem 2.3.1 Let A ∈L and A is written in atomic form. If there does not exist a parenthesis in A,
then A ∈L0 and A has size zero. If there exists a left most parenthesis “(” [i.e. no more parentheses appear
on the left in the expression], then beginning with this parenthesis the common pair rule will yield a right
most parenthesis for the common pair. During this common pair procedure, the largest natural number
obtained will be the size of A.
Example 2.3.1. The numbers in the next display are obtained by starting with parenthesis a and show
that the size(A) = 3.
A =
(
(
(
P ∧Q
)
∨R
)
→
(
S ∨P
)
)
a
b
c
d
e
f
g
h
1
2
3
2
1
2
1
0
Although the common pairs are rather obvious, the common pair rule can be used. This gives (c,d), (b,e),
(f,g), and (a,h) as common pairs. Hence, the subformula are A, (P ∧Q), ((P ∧Q) ∨R), (S ∨P) and you
can apply the common pair rule to each of these to ﬁnd their sizes. Of course, the rule is most useful when
the formula are much more complex.
The are various simpliﬁcation processes that allow for the removal of many of the parenthesis. One
might think that logicians like to do this since those that do not know the simpliﬁcations would not have
any knowledge as to what the formula actually looks like. The real reason is to simply write less. These
13

simpliﬁcation rules are relative to a listing of the strengths of the connectives. However, for this beginning
course, such simpliﬁcation rules are not important with one exception.
Deﬁnition 2.3.2 The one simpliﬁcation that may be applied is the removal of the outermost left
parenthesis “(” and the outermost right parenthesis “).” It should be obvious when such parentheses have
been removed. BUT, they must be inserted prior to application of the common pair rule and Theorem 2.3.1.
One of the major applications of the propositional calculus is in the design of the modern electronic
computer. This design is based upon the basic and simplest behavior of the logical network which itself
is based upon the simple idea of switching circuits. Each switching device is used to produce the various
types of “gates.” These gates will not speciﬁcally be identiﬁed but the basic switches will be identiﬁed.
Such switches are conceived of as simple single pole relays. A switch may be normally open when no current
ﬂows through the coil. One the other hand, the switch could be normally closed when no current ﬂows.
When current ﬂows through the relay coil, the switch takes the opposite state. The coil is not shown only
the circuit that is formed or broken when the coil is energized for the P or Q relay. The action is “current
through a coil” and leads to or prevents current ﬂowing through the indicated line.
For what follows the atoms of our propositional calculus represent relays in the normally open position.
Diagrammatically, a normally open relay (switch) is symbolized as follows:
(a) ⌈P⌉:
| P \
Now for each atom P, let ¬P represent a normally closed relay. Diagrammatically, a normally closed relay
is symbolized by:
(b) ⌈¬P⌉:
| ¬P |
Now any set of normally open or closed relays can be wired together in various ways. For the normally
open ones, the following will model the binary connectives →, ↔, ∧, ∨. This gives a non-linguistic model.
In the following, P, Q are atoms and the relays are normally open.
| P
\
(i) ⌈P ∨Q⌉:
|
|
|
| Q
\
|
(ii) ⌈P ∧Q⌉:
| P \
| Q \
| ¬P |
(iii) ⌈P →Q⌉:
|
|
|
| Q
\
|
(iv) In order to model the expression P ↔Q we need two coils. The P coil has a switch at both ends, one
normally open the other normally closed. The Q coil has a switch at both ends, one normally open the other
normally closed. But, the behavior of the two coils is opposite from one another as shown in the following
diagram, where (iii) denotes the previous diagram.
| ¬Q
|
⌈P →Q⌉:
(iii)
|
|
|
| P
\
|
EXERCISES 2.3
1. When a formula is written in atomic form, the (i) atoms, (ii) (not necessary distinct) connectives, and (iii)
the parentheses are displayed. Of the three collections (i), (ii), (iii), ﬁnd the one collection that can be used
to determine immediately by counting the (a) number of common pairs and (b) the number of subformula.
What is it that you count?
2. For each of the following formula, use the indicated letter and list as order pairs, as I have done for
Example 2.3.1 on page 16, the letters that identify the common pairs of parentheses.
14

(A) = ((P →(Q ∨R)) ↔(¬S))
ab
c
de
f
gh
(B) = ((P ∨(Q ∨(S ∨Q))) →(¬(¬R)))
ab
c
d
efg
h i
jkm
(C) = (((¬(P ↔(¬R))) →((¬Q) ↔(R ∨P))) ↔S)
abc d
e
fgh
ij
k
m
nop
q
3. Find the size of each of the formula in problem 3 above.
4. Although it would not be the most eﬃcient, (we will learn how to ﬁnd logically equivalent formula so
that we can make them more eﬃcient), use the basic relay (switching) circuits described in this section (i.e.
combine them together) so that the circuits will model the following formula.
(a) ((P ∨Q) ∧(¬R))
(c) (((¬P) ∧Q) ∨((¬Q) ∧P))
(b) ((P →Q) ∨(Q →P))
(d) ((P ∧Q) ∧(R ∨S))
2.4 Model Theory – Basic Semantics.
Prior to 1921 this section could not have been rigorously written. It was not until that time when
Emil Post convincingly established that the semantics for the language L and the seemingly more complex
formal approach to Logic as practiced in the years prior to 1921 are equivalent. The semantical ideas had
brieﬂy been considered for some years prior to 1921. However, Post was apparently the ﬁrst to investigate
rigorously such concepts. It has been said that much of modern mathematics and various simpliﬁcations
came about since “we are standing on the shoulders of giants.” This is, especially, true when we consider
today’s simpliﬁed semantics for L.
Now the term semantics means that we are going to give a special meaning to each member of L and
supply rules to obtain these “meanings” from the atoms and connectives whenever a formula is written
in atomic form (i.e. only atoms, connectives and parentheses appear). These meanings will “mirror” or
“model” the behavior of the classical concepts of “truth” and “falsity.” HOWEVER, so as not to impart
any philosophical meanings to our semantics until letter, we replace “truth” by the letter T and “falsity” by
the F.
In the applications of the following semantical rules to the real world, it is often better to model the T
by the concept “occurs in reality” and the F by the concept “does not occur in reality.” Further, in many
cases, the words “in reality” many not be justiﬁed.
Deﬁnition 2.4.1 The following is the idea of an assignment. Let A ∈L and assume that A is written
in atomic form. Then there exists some natural number n such that A ∈Ln and size(A) = n. Now there is
in A a ﬁnite list of distinct atoms, say (P1, P2, . . . , Pm) reading left to right. We will assign to each Pi in
the list the symbol T or the symbol F in as many diﬀerent ways as possible. If there are n diﬀerent atoms,
there will be 2n diﬀerent arrangements of such Ts and Fs. These are the values of the assignment. This can
be diagrammed as follows:
(P1, P2, . . . , Pm)
(↕
↕
· · · ↕)
( T , F , . . . , T)
Example 2.4.1 This is the example that shows how to give a standard ﬁxed method to display and
ﬁnd all of the diﬀerent arrangements of the Ts and Fs for, say three atoms, P, Q, R. There would be a
total of 8 diﬀerent arrangements. Please note how I’ve generated the ﬁrst, second and third columns of the
following “assignment” table. This same idea can be used to generate quickly an assignment table for any
ﬁnite number of atoms.
15

P
Q
R
T
T
T
T
T
F
T
F
T
T
F
F
F
T
T
F
T
F
F
F
T
F
F
F
The rows in the above table represent one assignment (these are also called truth-value assignments)
and such an assignment will be denoted by symbols such as a = (a1, a2, a3), where the ai take the value T
or F. In practice, one could re-write these assignments in terms of the numbers 1 and 0 if one wanted to
remove any association with the philosophical concept of “truth” or “falsity.”
For this fundamental discussion, we will assume that the list of atoms in a formula A ∈L is known and
we wish to deﬁne in a appropriate manner the intuitive concept of the truth-value for the formula A for a
speciﬁc assignment a. Hence you are given a = (a1, a2, . . . , an) that corresponds to the atoms (P1, P2, . . . , Pn)
in A and we want a deﬁnition that will allow us to determine inductively a unique “truth-value” from {T, F}
that corresponds to A for the assignment a.
Deﬁnition 2.4.2 The truth-value for a given formula A and a given assignment a is denoted by v(A, a).
The procedure that we’ll use is called a valuation procedure.
Prior to presenting the valuation procedure, let’s make a few observations. If you take a formula with
m distinct atoms, then the assignments a are exactly the same for any formula with m distinct atoms no
matter what they are.
(1) An assignment a only depends upon the number of distinct atoms and not the actual atoms them-
selves.
(2) Any rule that assigns a truth-value T or F to a formula A, where A is not an atom must depend
only upon the connectives contained in the formula.
(3) For any formula with m distinct atoms, changing the names of the m distinct atoms to diﬀerent
atoms that are distinct will not change the assignments.
Now, we have another observation based upon the table of assignments that appears on page 20. This
assignment table is for three distinct atoms. Investigation of just two of the columns yields the following:
(4) For any assignment table for m atoms, any n columns, where 1 ≤n ≤m can be used to obtain
(with possible repetition) all of the assignments that correspond to a set of n atoms.
The actual formal inductively deﬁned valuation procedure is given in the appendix and is based upon
the size of a formula. This formal procedure is not the actual way must mathematicians obtain v(A, a) for a
given A, however. What’s presented next is the usual informal (intuitive) procedure that’s used. It’s called
16

the truth-table procedure and is based upon the ability of the human mind to take a general statement and
to apply that statement in a step-by-step manner to speciﬁc cases. There are ﬁve basic truth-tables.
The A, B are any two formula in L. As indicated above we need only to deﬁne the truth-value for the
ﬁve connectives.
(i)
A | ¬A
T | F
F | T
(ii)
A | B | A ∨B
T | T |
T
T | F |
T
F | T |
T
F | F | F
(iii)
A | B | A ∧B
T | T |
T
T | F |
F
F | T |
F
F | F |
F
(iv)
A | B | A →B
T | T |
T
T | F |
F
F | T |
T
F | F |
T
(v)
A | B | A ↔B
T | T |
T
T | F |
F
F | T |
F
F | F |
T
Observe that the actual truth-value for a connective does not depend upon the symbols A or B but
only upon the values T or F. For this reason the above general truth-tables can be replaced with a simple
collection of statements relating the T and F and the connectives only. This is the quickest way to ﬁnd the
truth-values, simply concentrate upon the connectives and use the following:
(i)
¬F
T ,
¬T
F .
(ii)
T ∨T
T ,
T ∨F
T ,
F ∨T
T ,
F ∨F
F
(iii)
T ∧T
T ,
T ∧F
F ,
F ∧T
F ,
F ∧F
F
(iv)
T →T
T ,
T →F
F ,
F →T
T ,
F →F
T
(v)
T ↔T
T ,
T ↔F
F ,
F ↔T
F ,
F ↔F
T
The procedures will now be applied in a step-by-step manner to ﬁnd the truth-values for a speciﬁc
formula. This will be displayed as a truth-table with the values in the last column. Remember that the
actual truth-table can contain many more atoms than those that appear in a given formula. By using all the
distinct atoms contained in all the formulas, one truth-table can be used to ﬁnd the truth values for more
than one formula.
The construction of a truth-table is best understood by example. In the following example, the numbers
1, 2, 3, 4 for the rows and the letters a, b, c, d, e, f that identify the columns are used here for reference only
and are not used in the actual construction.
17

Example 2.4.2 Truth-values for the formula A = (((¬P) ∨R) →(P ↔R)).
P
R
¬P
(¬P) ∨R
P ↔R
v(A, a)
(1)
T
T
F
T
T
T
(2)
T
F
F
F
F
T
(3)
F
T
T
T
F
F
(4)
F
F
T
T
T
T
a
b
c
d
e
f
Now I’ll go step-by-step through the above process using the general truth-tables on the previous page.
(i) Columns (a) and (b) are written down with their usual patterns.
(ii) Now go to column (a) only to calculate the truth-values in column (c). Note as mentioned previously
there will be repetitions.
(iii) Now calculate (d) for the ∨connective using the truth-values in columns (b) and (c).
(iv) Next calculate (e) for the ↔connective using columns (a) and (b).
(v) Finally, calculate (f), the value we want, for the →connective using columns (d) and (e).
EXERCISES 2.4
1. First, we assign the indicated truth values for the indicated atoms v(P) = T, v(Q) = F, v(R) = F and
v(S) = T. These values will yield one row of a truth-table, one assignment a. For this assignment, ﬁnd the
truth-value for the indicated formula. (Recall that v(A, a) means the unique truth- value for the formula A.)
(a) v((R →(S ∨P)), a)
(d) v((((¬S) ∨Q) →(P ↔S)), a)
(b) v(((P ∨R) ↔(R ∧(¬S))), a)
(e) v((((P ∨(¬Q)) ∨R) →((¬S) ∧S)), a)
(c) v((S ↔(P →((¬P) ∨S))), a)
2. Construct complete truth tables for each of the following formula.
(a) (P →(Q →P))
(c) ((P →Q) ↔(P ∨(¬Q)))
(b) ((P ∨Q) ↔(Q ∨P))
(d) ((Q ∧P) →((Q ∨(¬Q)) →(R ∨Q)))
3. For each of the following determine whether or not the truth-value information given will yield a unique
truth-value for the formula. State your conclusions. If the information is suﬃcient, then give the unique
truth-value for the formula.
(a) (P →Q) →R, v(R) = T
(d) (R →Q) ↔Q, v(R) = T
(b) P ∧(Q →R), v(Q →R) = F
(e) (P →Q) →R, v(Q) = F
(c) (P →Q) →((¬Q) →(¬P))
(f) (P ∨(¬P)) →R, v(R) = F
For (c), v(Q) = T
18

2.5 Valid Formula.
There may be something special about those formula that take the value T for any assignment.
Deﬁnition 2.5.1 (Valid formulas and contradictions). Let A ∈L. If for every assignment a to the atoms
in A, v(A, a) = T, then A is called a valid formula. If to every assignment a to the atoms of A, v(A, a) = F,
then A is called a (semantical) contradiction. If a formula A is valid, we use the notation |= A to indicate
this fact.
If we are given a formula in atomic form, then a simple truth-table construction will determine whether
or not it is a valid formula or a contradiction. Indeed, A is valid if and only if the column under the A in
its truth-table contains only T in each position. A formula A is a contradiction if and only if the column
contains only F in every position. From our deﬁnition, we read the expression |= A “A is a valid formula.”
We read the notation ̸|= A “A is not a valid formula. Although a contradiction is not a valid formula, there
are inﬁnitely many formula that are not valid AND not a contradiction.
Example 2.5.1 Let P, Q ∈L0.
(i)
|= P →P
P
| P →P
T |
T
F |
T
(ii)
|= P →(Q →P)
P | Q |Q →P|P →(Q →P)
T | T |
T
|
T
T | F |
T
|
T
F | T |
F
|
T
F | F |
T
|
T
(iii)
̸|= P →Q
P | Q |P →Q
T | T |
T
T | F |
F
F | T |
T
F | F |
T
(iv)
contradiction P ∧(¬P)
P | ¬P |P ∧(¬P)
T |
F
|
F
F |
T
|
F
We now begin the mathematical study of the validity concept.
Throughout this text, I will “prove” various theorems in a way that is acceptable to the mathematical
community. Since the major purpose for this book is NOT to produce trained mathematical logicians, but,
rather, to give the tools necessary to apply certain results from the discipline to other areas, I, usually, don’t
require a student to learn either these “proofs” or the methods used to obtain the proofs.
Theorem 2.5.1 A formula A ∈L is valid if and only if ¬A is a contradiction.
Proof. First, notice that a is an assignment for A if and only if a is a assignment for ¬A. Assume that
|= A. Then for any a for A, v(A, a) = T. Consequently, from the deﬁnition of v, v(¬A, a) = F. Since a is
any arbitrary assignment, then v(¬A, a) = F for all assignment a.
Conversely, let a be any assignment to the atoms in ¬A. Then a is an assignment to the atoms in A.
Since ¬A is a contradiction, v(¬A, a) = F. From the truth-table (or the formal result in the appendix), it
19

follows that v(A, a) = T. Once again, since a is an arbitrary assignment, this yields that v(A, a) = T for all
assignments and, thus, |= A.
Valid formula are important elements in our investigation of the propositional logic. It’s natural to
ask whether or not the validity of a formula is completely dependent upon its atomic components or its
connectives? To answer this question, we need to introduce the following substitution process.
Deﬁnition 2.5.2 (Atomic substitution process.) Let A ∈L be written in atomic form. Let P1, . . . , Pn
denote the atoms in A. Now let A1, . . . An be ANY (not necessarily distinct) members of L. Deﬁne A∗to be
the result of substituting for each and every appearance of an atom Pi the corresponding formula Ai.
Theorem 2.5.2 Let A ∈L. If |= A, then |= A∗.
Proof. Let a be any assignment to the atoms in A∗. In the step-by-step valuation process there is a level
Lm where the formula A∗ﬁrst appears. In the valuation process, at level Lm each constituent of A∗takes
on the value T or F. Since the truth-value of A∗only depends upon the connectives (they are independent
of the symbols used for the formulas) and the truth-values of the v(Ai, a) are but an assignment b that can
be applied to the original atoms P1, . . . , Pn, it follows that v(A∗, a) = v(A, b) = T. But, a is an arbitrary
assignment for A∗. Hence, |= A∗.
Example 2.5.2 Assume that P, Q ∈L0. Then we know that |= P →(Q →P). Now let A, B ∈L
be any formula. Then |= A →(B →A). In particular, letting A = (P →Q), B = (R →S), where
P, Q, R, S ∈L0, then |= (P →Q) →((R →S) →(P →Q)).
Theorem 2.5.2 yields a simpliﬁcation to the determination of a valid formula written with some connec-
tives displayed. If you show that v(A, c) = T where you have created all of the possible assignments c not to
the atoms of A but only for the displayed components, then |= A. (You think of the components as atoms.)
Now the reason that this non-atomic method can be utilized follows from our previous results. Suppose
that we have a list of components A1, · · · , An and we substitute for each distinct component of A a distinct
atom in place of the components. Then any truth-value we give to the original components, becomes an
assignment a for this newly created formula A′. Observe that using A1, · · · , An it follows that (A′)∗= A.
Now application of theorem 2.5.2 yields if |= A′, then |= A. What this means is that whenever we wish to
establish validity for a formula we may consider it written in component variables and make assignments
only to these variables; if the last column is all Ts, then the original formula is valid.
WARNING: We cannot use the simpliﬁed version to show that a formula is NOT valid. As a counter
example, let A, B ∈L. Then if we assume that A, B behave like atoms and want to show that the composite
formula A →B is not valid and follow that procedure thinking it will show non-validity, we would, indeed,
have an F at one row of the truth-table. But if A = B = P, which could be the case since A, B are
propositional language variables, then we have a contradiction since |= P →P. Hence, the formula can be
considered as written in non-atomic form only if it tests to be valid.
It’s interesting to note the close relation which exists between set-theory and logic. Assume that we
interpret propositional symbols as names for sets which are subsets of an inﬁnite set X. Then interpret
the conjunction as set-theoretic intersection (i.e.
⌈∧⌉:
∩), the disjunction as set-theoretic union (i.e.
⌈∨⌉: ∪), the negation as set-theoretic complementation with respect to X (i.e. ⌈¬⌉: X −or X\), and the
combination of validity with the biconditional to be set-theoretical equality (i.e ⌈|= A ↔B⌉: A = B). Now
the valid formula (P ∧((Q ∨R))) ↔((P ∧Q) ∨(P ∧R)) translates into the correct set-theoretic expression
(P ∩((Q ∪R))) = ((P ∩Q) ∪(P ∩R)). Now in this text we will NOT use the known set-theoretic facts to
establish a valid formula even though some authors do so within the setting of the theory known as a Boolean
algebra. This idea would not be a circular approach since the logic used to determine these set-theoretic
expressions is the metalogic of mathematics.
20

In the next theorem, we give, FOR REFERENCE PURPOSES, an important list of formula each of
which can be establish as valid by the simpliﬁed procedure of using only language variables.
Theorem 2.5.3 Let A, B, C be any members of L. Then the symbol |= can be place before each of
the following formula.
(1) A →(B →A)
(8) B →(A ∨B)
(2) (A →(B →C)) →
(9) (A →C) →((B →C) →
((A →B) →(A →C))
((A ∨B) →C))
(3) (A →B) →
(10) (A →B) →((A →(¬B)) →(¬A))
((A →(B →C)) →(A →C))
(4) A →(B →(A ∧B))
(11) (A →B) →
((B →A) →(A ↔B))
(5) (A ∧B) →A
(12) (¬(¬A)) →A
(6) (A ∧B) →B
(13) (A ↔B) →(A →B)
(7) A →(A ∨B)
(14) (A ↔B) →(B →A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(15) A →A
(17) (A →B) →((B →C) →
(A →C))
(16) (A →(B →C)) ↔
(18) (A →(B →C)) ↔((A ∧B) →C))
(B →(A →C))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(19) (¬A) →(A →B)
(20) ((¬A) →(¬B)) ↔(B →A)
(21) ((¬A) →(¬B)) →(B →A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(22) A ↔A
(23) (A ↔B) ↔(B ↔A)
(24) ((A ↔B) ∧(B ↔C)) →(A ↔C)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(25) ((A ∧B) ∧C) ↔(A ∧(B ∧C))
(30) ((A ∨B) ∨C) ↔(A ∨(B ∨C))
(26) (A ∧B) ↔(B ∧A)
(31) (A ∨B) ↔(B ∨A)
(27) (A ∧(B ∨C)) ↔
(32) (A ∨(B ∧C)) ↔
((A ∧B) ∨(A ∧C))
((A ∨B) ∧(A ∨C))
(28) (A ∧A) ↔A
(33) (A ∨A) ↔A
(29) (A ∧(A ∨B)) ↔A
(34) (A ∨(A ∧B)) ↔A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(35) (¬(¬A)) ↔A
(36) ¬(A ∧(¬A))
(37) A ∨(¬A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(38) (¬(A ∨B)) ↔((¬A) ∧(¬B))
(39) (¬(A ∧B)) ↔((¬A) ∨(¬B))
(40) (¬(A →B)) ↔(A ∧((¬B))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
(41) (A ∨B) ↔(¬((¬A) ∧(¬B)))
(44) (A ∧B) ↔(¬((¬A) ∨(¬B)))
(42) (A →B) ↔(¬(A ∧(¬B)))
(45) (A →B) ↔((¬A) ∨B)
(43) (A ∧B) ↔(¬(A →(¬B)))
(46) (A ∨B) ↔((¬A) →B)
21

(47) (A ↔B) ↔((A →B) ∧(B →A))
EXERCISES 2.5
(1) Use the truth-table method to establish that formula (1), (2), (21), (32), and (47) of theorem 2.4.3 are
valid.
(2) Determine by truth-table methods whether or not the following formula are contradictions.
(a) ((¬A) ∨(¬B)) ↔
(c) (¬(A →B)) ↔((¬A) ∨B)
(¬((¬A) ∨(¬B)))
(b) (¬A) →(A ∨B)
(d) (((A ∨(¬B)) ∧(¬P))) ↔
(((¬A) ∨B) ∨P)
2.6 Equivalent Formula.
As it will be seen in future sections, one major objective is to investigate the classical human deductive
processes and how these relate to the logic operator used in the solution to the General Grand Uniﬁcation
Problem. In order to accomplish this, it has been discovered that humankind seems to believe that certain
logical statements can be substituted completely for other logical statements without eﬀecting the general
“logic” behind an argument. Even though this fact will not be examined completely in this section, we will
begin its investigation.
Throughout mathematics the most basic concept is the relation which is often called equality. In the
foundations of mathematics, there’s a diﬀerence between equality, which means that objects are identically
the same (i.e. they cannot be distinguished one from another by any property for the collection that contains
them), and certain relations which behave like equality but that can be distinguished one from another and
do not allow for substitution of one for another.
Example 2.6.1 When you ﬁrst deﬁned the rational numbers from the integers you were told the strange
fact that 1/2, 2/4, 3/6 are “equal” but they certainly appear to be composed of distinctly diﬀerent symbols
and would not be identical from our logical viewpoint.
We are faced with two basic diﬃculties. In certain areas of mathematical logic, it would be correct
to consider the symbols 1/2, 2/4, 3/6 as names for a single unique object. On the other hand, if we were
studying the symbols themselves, then 1/2, 2/4, 3/6 would not be consider as names for the same object
but, rather, they are distinctly diﬀerent symbols. These diﬀerences need not be deﬁned speciﬁcally but can
remain on the intuitive level for the moment. The are two types of “equality” relations. One type simple
behaves like equality but does not allow for substitution, in general. But then we have another type that
behaves like equality and does allow for substitution with respect to certain properties. This means that
these two objects are identical as far as these properties are concerned. Or, saying it another way, a set of
properties cannot distinguish between two such objects, while another set of properties can distinguish them
one from another.
Recall that a binary relation “on” any set X can be thought of as simply a set of ordered pairs (a, b)
that, from a symbol string viewpoint, has an ordering. The ﬁrst coordinate is the element you meet ﬁrst in
writing this symbol from left to right, in this case the a. The second coordinate is the next element you arrive
at, in this case the b. Also recall that two ordered pairs are identical (you can substitute one for another
throughout your mathematical theory) if their ﬁrst coordinates are identical and their second coordinates
are identical (i.e. can not be distinguished one from another by the deﬁning properties for the set in which
they are contained.) The word “on” means that the set of all ﬁrst coordinates is X and the set of all second
22

coordinates is X. Now there are two ways of symbolizing such a binary relation, either by writing it as a set
of ordered pairs R or by doing the following:
Deﬁnition 2.6.1 (Symbolizing ordered pairs.)
Let R be a nonempty set of ordered pairs.
Then
(a, b) ∈R if and only if a R b. The expression a R b is read “a is R related to b” or similar types of
expressions.
In deﬁnition 2.6.1, the reason the second form is used is that many times it’s simply easier to write a
binary relation’s deﬁning properties when the a R b is used. It’s this form we use to deﬁne a very signiﬁcant
binary relation that gives the concept of behaving like “equality.”
Deﬁnition 2.6.2 (The equivalence relation.) A binary relation ≡on a set X is called an equivalence
relation if for each a, b, c ∈X it follows that
(i) a ≡a (Reﬂexive property).
(ii) If a ≡b, then b ≡a. (Symmetric property).
(iii) If a ≡b and b ≡c, then a ≡c. (Transitive property).
Now when we let X = L, then the only identity or equality we use is the intuitive identity. Recall that
this means that two symbol string are recognized as congruent geometric conﬁgurations or are intuitively
similar strings of symbols. This would yield a trivial equivalence relation. As a set of ordered pairs, an
identity relation is {(a, a) | a ∈X}, which is (i) in deﬁnition 2.6.2. Parts (ii), (iii) also hold for this identity
relation.
For the next theorem, please recall that the validity of a formula A does not depend upon an assignment
a that contains MORE members than the number of atoms contained in A. Such an assignment is used by
restricting the Ts and Fs to those atoms that are in A.
Theorem 2.6.1
Let A, B ∈L and a an arbitrary assignment to the atoms that are in A and B.
(i) Then v(A ↔B, a) = T if and only if v(A, a) = v(B, a).
(ii) |= A ↔B if and only if for any assignment a to the atoms that are in A and B, v(A, a) = v(B, a).
Proof. Let A, B ∈L.
(i) Then let the size(A ↔B) = n ≥1. Then A, B ∈Ln−1. This result now follows from the general
truth-tables on page 22.
(ii) Assume that |= A ↔B and let a be an arbitrary assignment to the atoms that are contained in A
and B. Then v(A ↔B, a) = T if and only if v(A, a) = v(B, a) from part (i). Conversely, assume that a is an
assignment for the atoms in A and B. Then a also determines an assignment for A and B separately. Since,
v(A, a) = v(B, a) then from (i), it follows that v(A ↔B, a) = T. But a is arbitrary, hence, |= A ↔B.
Deﬁnition 2.6.3 (The logical equivalence relation ≡.) Let A, B ∈L. Then deﬁne A ≡B iﬀ|= A ↔B.
Notice that deﬁnition 2.6.3 is easily remembered by simply dropping the |= and replacing ↔with ≡.
Before we proceed to the study of equivalent propositional formulas, I’ll anticipate a question that almost
always arises after the next few theorems. What is so important about equivalent formula? When we study
the actual process of logical deduction, you’ll ﬁnd out that within any classical propositional deduction
a formula A can be substituted for an equivalent formula and this will in no way aﬀect the deductive
conclusions. What it may do is to present a more easily followed logical process. This is exactly what
happens if one truly wants to understand real world logical arguments. For example, take a look at theorem
2.5.3 parts (29) and (34) and notice how logical arguments can be made more complex, unnecessarily, by
23

adding some rather complex statements, statements that include totally worthless additional statements such
as any additional statement B that might be selected simply to confuse the reader.
Theorem 2.6.2 The relation ≡is an equivalence relation deﬁned on L.
Proof. Let A, B, C ∈L. From the list of valid formula that appear in theorem 2.5.3, formula (22)
yields that for each A ∈L, |= A ↔A. Hence, A ≡A.
Now let A, B ∈L and assume that A ≡B. Then for any assignment a, |= A ↔B implies that
v(A, a) = v(B, a) from theorem 2.6.1.
Since the equality means identically the same symbol (the only
equality for our language), it follows that v(B, a) = v(A, a). Consequently, B ≡A.
Now assume that A ≡B, B ≡C. Hence, |= A ↔B, |= B ↔C. Again by application of theorem 2.6.1
and the deﬁnition of |=, it follows that |= A ↔C. Consequently, A ≡C and ≡is an equivalence relation.
We now come to the very important substitution theorem, especially when deduction is concerned. It
shows that substitution is allowed throughout the language L and yields a powerful result.
Deﬁnition 2.6.4 (Substitution of formula). Let C ∈L be any formula and A a formula which is a
composite element in C. Then A is called a subformula. Let CA denote the formula C with the subformula
A speciﬁcally identiﬁed. Then the substitution process states that if you substitute B for A then you obtain
the CB, where you have substituted for the speciﬁc formula A in C the formula B.
Example 2.6.2 Suppose that C = (((¬P) ∨Q) →((P ∨S) ↔S)). Let A = (P ∨S) and consider CA.
Now let B = (S ∧(¬P)). Then CB = (((¬P) ∨Q) →((S ∧(¬P)) ↔S)), where the substituted formula is
identiﬁed by the underline.
Theorem 2.6.3 If A, B, C ∈L and A ≡B, then CA ≡CB.
Proof. Let A ≡B. Then |= A ↔B. Let a be any assignment to the atoms in CA and CB. Then a
may be considered as an assignment for CA, CB, A, B. Let size(CA) = n. In the truth-table calculation
process (or formal process) for v(CA, a) there is a step when we (ﬁrst) calculate v(A, a). Let size(A) = k ≤n.
If size(A) = n, then A = C and CB = B and we have nothing to prove. Assume that k < n. Then the
calculation of v(CA, a) at this speciﬁc level only involves the calculation of v(A, a) and the other components
and other connectives not in A. The same argument for CB shows that calculation for CB at this level uses
the value v(B, a) and any other components and other connectives in C which are all the same as in CA.
However, since A ≡B, theorem 2.6.1 yields v(A, a) = v(B, a). Of course, the truth-values for the other
components in CA that are the same as the other components in CB are equal since these components are
the exact same formula. Consequently, since the computation of the truth-value for CA and CB now continue
from this step and all the other connective are the same from this step on, then CA and CB would have the
same truth-value. Hence v(CA, a) = v(CB, a). But a is arbitrary; hence, |= CA ↔CB. Thus CA ≡CB.
Corollary 2.6.3.1 If |= A ↔B and |= CA, then |= CB.
Proof. From the above theorem |= CA ↔CB, it follows that for any assignment a to the atoms in CA
and CB, v(CA, a) = v(CB, a). However, v(CA, a) = T. Moreover, all of the assignments for the atoms in CA
and CB will yield all of the assignments b for the atoms in CB as previously mentioned. Hence, if b is any
assignment for the atoms in CB, then v(CB, b) = T and the result follows.
[Note: It follows easily that if C, A, B are written in formula variables and, hence, represent a hidden
atomic structure, then Theorem 2.6.3 and its corollary will also hold in this case.]
The next result seems to ﬁt into this section. It’s importance cannot be over-emphasized since it mirrors
our major rule for deduction. For this reason, it’s sometimes called the semantical modus ponens result.
Theorem 2.6.4 If |= A and |= A →B, then |= B.
24

Proof. Suppose that A, B ∈L. Let |= A, |= A →B and a be any assignment to the atoms in A, B.
Then v(A, a) = T = v(A →B, a). Thus v(B, a) = T. Since a is any assignment, then, as used previously,
using the set of all assignments for A, B, we also obtain all of the assignments for B. Hence v(B, b) = T for
any assignment for Bs atoms and the result follows.
EXERCISES 2.6
1. There is a very important property that shows how equivalence relations can carve up a set into important
pieces, where each piece contains only equivalent elements. Let ≡be any equivalence relation deﬁned on the
non-empty set X. This equivalence relation can be used to deﬁne a subset of X. For every x ∈X, this subset
is denoted by [x]. Now to deﬁne this very special and important set. For each x ∈X, let [x] = {y | y ≡x}.
Thus if you look at one of these sets, say [a], and you take any two members, say b, c ∈[a], it follows that
b ≡c. Now see if you can establish by a simple logical argument using the properties (i), (ii), (iii) of deﬁnition
2.6.2 that:
(A) If there is some z ∈X such that z ∈[x] and z ∈[y], then [x] = [y]. (This equality is set equality,
which means that [x] is a subset of [y] and [y] is a subset of [x].)
(B) If x ∈X, then there exists some y ∈X such that x ∈[y].
2. (A) Of course, there are usually many interesting binary relations deﬁned on a non-empty set X. Suppose
that you take any binary relation B deﬁned on X and you emulate the deﬁnition we have used for [x].
Suppose that you let (x) = {y | y B x}. Now what if properties (A) and (B) and the reﬂexive property (i)
of deﬁnition 2.6.2 hold true for this relation. Try and give a simple argument that shows in this case that B
is, indeed, an equivalence relation.
(B) In (A) of this problem, we required that B be reﬂexive. Maybe we can do without this additional
requirement. Try and show that this requirement is necessary by looking at a set that contains two and only
two elements {a, b} and ﬁnd a set of ordered pairs, using one or both of its members, that yields a binary
relation on {a, b} such that (A) and (B) of problem 1 hold but (i) of deﬁnition 2.6.2, the reﬂexive property,
does not hold. If you can ﬁnd one, this is an absolute counter-example that establishes that the reﬂexive
property is necessary.
3. One of the more important properties of ≡is the transitive property (iii). For example, if CA ≡CB and
CB ≡CD, then CA ≡CD. Now this can be applied over and over again a ﬁnite number of times. Notice
what can be done by application of theorem 2.5.3 parts (26) and (31). Suppose that you have a formula C
containing a subformula (A ∨B), where (A ∨B) ≡(B ∨A) or (A ∧B), where (A ∧B) ≡(B ∧A). Letting
H = (A ∨B) and K = (B ∨A), then CH ≡CK. Now recall that, in general, on a set X where an equality is
deﬁned, an operation, say ∆, is commutative if for each x, y ∈X, it follows that x ∆y = y ∆x. Thus for
the operation and the (not equality) equivalence relation ≡the same type of commutative law for ∨holds.
In the following, using if necessary the transitive property, establish that (A), (B), (C), (D) (E) hold by
stating the particular valid formula(s) from theorem 2.5.3 that need to be applied.
(A) Given CD where D = (A ∨(B ∨C)), then CD ≡CE, where E = ((A ∨B) ∨C). This would be the
associative law for ∨. Now establish the associative law for ∧.
(B) Given CH, where H = (A∨B). Show that CH ≡CK where K only contains the ¬ and →connectives.
(C) Given CH, where H = (A∧B). Show that CH ≡CK where K only contains the ¬ and →connectives.
(D) Given CH, where H = (A ↔B). Show that CH ≡CK where K only contains the ¬ and →
connectives.
(E) Given CH, where H = (¬(¬(¬ · · · A · · ·))). (i.e.
the formula has “n” ¬ to its left.)
Show that
CH ≡CK where K only contains one and only one ¬ or no ¬.
4. Using the results from problem (3), and using, if necessary a ﬁnite number of transitive applications,
re-write each of the following formula in terms of an equivalent formula that contains only the ¬ and →
connectives. (The formulas are written in the allowed slightly simpliﬁed form.)
25

(a) (¬(A ∨B)) →(B ∧C)
(c) ((A ∨B) ∨C) ∧D.
(b) A ↔(B ↔C)
(d) ¬((A ∨(¬B)) ∨(¬(¬D)))
5.
In mathematics, it’s the usual practice to try and weaken hypotheses as much as possible and still
establish the same conclusion. Consider corollary 2.6.3.1. I wonder if this can be weakened to the theorem
“if |= A →B and |= CA, then |= CB? Try to ﬁnd an explicit formula such that |= A →B and |= CA, but
̸|= CB. If you can ﬁnd such a formula in L, then this would mean that the hypotheses cannot be weakened
to |= A →B and |= CA.
2.7 The Denial, Full Disjunctive Normal Form, Logic Circuits.
From this point on in this chapter, when we use language symbols such as P, Q, R, S, A, B, C, D, E,
F and the like, it will always be assumed that they are members of L. This will eliminate repeating this over
and over again.
As was done in the exercises at the end of the last section, checking theorem 2.5.3, we see that (A →
B) ≡((¬A) ∨B). Further, (A ↔B) ≡((A ∧B) ∨((¬A) ∧(¬B))). Consequently, for any C, we can take
every subformula that uses connective →and ↔, we can use the substitution process and, hence, express C
in a equivalent form D where in D only the connectives ¬, ∨, and ∧appear. Obviously, if D is so expressed
with at most these three connectives, then ¬C ≡¬D and ¬D is also expressed with at most these three
connectives. Further, by use of the valid formula theorem, any formula with more that one ¬ immediately to
the left (e.g. (¬(¬(¬A)))) is equivalent to either a formula for no ¬ immediately to the left, or at the most
just one ¬ immediately on the left. Since ¬(A ∨B) ≡((¬A) ∧(¬B)) and ¬(A ∧B) ≡((¬A) ∨(¬B)) then,
applying the above equivalences, we can express any formula C in an equivalent form D with the following
properties.
(i) D is expressed entirely in atoms.
(ii) Every connective in D is either ¬, ∨, ∧.
(iii) And, when they appear, only single ¬’s appear immediately to the left of atoms.
Deﬁnition 2.7.1 (The denial.) Suppose that A is in the form D with properties (i), (ii), (iii) above.
Then the denial Ad of A is the formula obtained by
(a) dropping the ¬ that appears before any atom.
(b) Placing a ¬ before any atom that did not have such a connective immediately to the left.
(c) Replacing each ∨with ∧.
(d) Replacing each ∧with ∨.
(e) Adjust the parentheses to make a correct language formula.
Example 2.7.1 Let A = ((¬P) ∨(¬Q)) ∧(R ∧(¬S)). Then Ad = (P ∧Q) ∨((¬R) ∨S). Notice were
the parentheses have been removed and added in this example.
Theorem 2.7.1 Let A be a formula containing only atoms, the connective ¬ appearing only to the
immediate left of atoms, if at all, and any other connectives are ∧and/or ∨. Then ¬A ≡Ad.
Proof. (This is the sort of thing where mathematicians seem to be proving the obvious since we have
demonstrated a way to create the equivalent formula. The proof is a formalization of this process for ANY
formula based upon one of the most empirically consistent processes known to the mathematical community.
The process is called induction on the natural numbers, in this case the unique natural number we call the
size of a formula.)
26

First, we must show the theorem holds true for a formula of size 0. So, let size(A) = 0. Then A = P ∈L0
and is a single atom. Then Ad = ¬A. Further, ¬A = ¬P. We know that for any formula D, D ≡D. Hence,
¬A ≡Ad for this case.
Now (strong) induction proofs are usually done by assuming that the theorem holds for all A such
that size(A) ≤n, where n > 0. Then using this last statement, it is shown that one method will yield the
theorem’s conclusions for size(A) = n + 1. However, this speciﬁc procedure may not work, yet, since there is
not one simple method unless we start at n > 1. Thus let size(A) = 1. Then there are three possible forms.
(i) Let A = ¬P. Then, from theorem 2.5.3, it follows that ¬A = ¬(¬P) ≡P. Now notice that if A = B, then
|= A ↔B. Further, Ad = P implies that ¬A ≡Ad. For the cases where A = P ∧Q or A = P ∨Q, the result
follows from theorem 2.5.3, parts (38), (39).
Now assume that the theorem holds for a formula A of size r such that 1 ≤r ≤n. Let size(A) = n + 1.
Also we make the following observation. Because of the structure of the formula A, A cannot be of the form
¬B where size(B) ≥1. Indeed, if the formula has a ¬ and a ∨or an ∧, then size(A) > 1. Consequently,
there will always be two and only two cases.
Case (a). Let A = B∨C. Consider ¬A = ¬(B∨C). From the above discussion, observe that size(¬B) ≤n.
Hence, by the induction hypothesis, ¬B ≡Bd and, in like manner, ¬C ≡Cd. Theorem 2.5.3, shows that
¬(B ∨C) ≡(¬B) ∧(¬C). Since equal formula are equivalent, then substitution yields, ¬(A ∨C) ≡Bd ∧Cd.
Again, since Ad = Bd ∧Cd, and equal formula are equivalent, substitution yields ¬A ≡Ad.
Case (b). Let A = B ∧C. This follows as in case (a) from theorem 2.5.3. Thus the theorem holds for
size(A) = n + 1. From the induction principle, the theorem holds for any (specially) constructed formula
since every such formula has a unique size which is a natural number.
On page 28, I mentioned how you could take certain valid formula and ﬁnd a correct set-theoretic
formula. The same can be done with the denial of the special form A. If you have any knowledge in this
area, the ¬ is interpreted as set-complementation with respect to the universe. We can get another one of
D’Morgan’s Laws, for complementation using ¬A ≡Ad.
Since any formula is equivalent, by theorem 2.5.3 part (29), to inﬁnitely many diﬀerent formula, it might
seen not to intelligent to ask whether or not a member of L is equivalent to a formula that is unique in some
special way? Even if this is true, is this uniqueness useful? So, the basic problem is to deﬁne the concept of
a unique equivalent form for any give formula.
Well, suppose that A is a contradiction and P is any atom. Then A ≡(P ∧(¬P)). And if B is any
valid formula, then B ≡(P ∨(¬P)). Hence, maybe the concept of a unique equivalent form is not so easily
answered. But, we try anyway.
Let A be a formula that is in atomic form and contains only the atoms P1, . . . , Pn. We show that there
is a formula equivalent to A that uses these are only these atoms and that does have an almost unique form.
The formula we construct is called the full disjunctive normal form and rather than put this into a big
deﬁnition, I’ll slowly described the process by the truth-table procedure.
Let the distinct atoms P1, . . . , Pn be at the top of a truth-table and in the ﬁrst “n” columns. Now
observe that when we calculate the truth-values for a formula A ∧(B ∧C) we have also calculated the
truth-values for the formula (A ∧B) ∧C) since not only are these formula equivalent, but they use the same
formula A, B, C, the exact same number and type of connective, in the exact same places. Indeed, only the
parentheses are in diﬀerent places. For this reason, we often drop the parentheses in this case when we are
calculating the truth value for A ∧(B ∧C). Now for the procedure. Consider any row k, where 1 ≤k ≤2n.
(a) For each T that appears in that row under the atom Pi, write done the symbol Pi.
(b) For each F that appears in that row under the atom Pj, write done the symbol (¬Pj).
27

(c) Continue this process until you have used (once) each truth value that appears in row k making sure
you have written down all these symbols in a single row and have left spaces between them.
(d) If there is more than one symbol, then between each symbol put a ∧and insert the outer most
parentheses.
(e) The result obtained is called the fundamental conjunction.
Example 2.7.2 Suppose that the kth row of our truth table looks like
P1
P2
P3
T
F
F
Then, applying (a), (b), (c), we write down
P1
(¬P2)
(¬P3)
Next we do as we are told in (d). This yields
(P1 ∧(¬P2) ∧(¬P3)).
Now the assignment for the k row is a = (T, F, F). Notice the important fact that v((P1 ∧(¬P2) ∧
(¬P3)), a) = T. What we have done to remove any possibility that the truth-value would be F. But, also it’s
signiﬁcant, that if we took any other distinctly diﬀerent assignment b, then v((P1 ∧(¬P2) ∧(¬P3)), b) = F.
These observed facts about this one example can be generally established.
Theorem 2.7.2 Let k be any row of a truth-table for the distinct set of atoms P1, . . . , Pn. Let a be the
assignment that this row represents. For each ai = T, write down Pi. For each aj = F, write down (¬Pj).
Let A be the formula obtained by placing conjunctions between each pair of formula if there exists more
than one such formula. Then v(A, a) = T, and for any other distinct assignment b, v(A, b) = F.
Proof. See theorems 1.6 and 1.7 on pages 13, 14 of the text “Boolean Algebras and Switching Circuits,”
by Elliott Mendelson, Schaum’s Outline Series, McGraw Hill, 1970.
Now for any formula C composed of atoms P1, . . . , Pm and which is not a contradiction there will be,
at the least, one row assignment a such that v(C, a) = T. We now construct the formula that is equivalent
to C that we has an almost unique form.
Deﬁnition 2.7.1 (Full disjunctive normal form.) Let C not be a contradiction.
(a) Take every row k for which v(C, a) = T.
(b) Construct the fundamental conjunction for each such row.
(c) Write down all such fundamental conjunctions and between each pair, if any, place a ∨.
(d) The result of the construction (a), (b), (c) is called the full disjunctive normal form for C. This
can be denoted by fdnf(C).
Example 2.7.2 Suppose that C = P ↔(Q ∨R). Now consider the truth-table.
28

P
Q
R
C
T
T
T
T
T
T
F
T
T
F
T
T
T
F
F
F
F
T
T
F
F
T
F
F
F
F
T
F
F
F
F
T
Now we construct fundamental conjunctions for rows 1, 2, 3, 8. This yields (P ∧Q ∧R), (P ∧Q ∧
(¬R)), (P ∧(¬Q) ∧R), ((¬P) ∧(¬Q) ∧(¬R)). Notice that I have not included for the ∧the internal
parentheses since they can be placed about any two expressions.
Then putting these together we have
fdnf(C) = (P ∧Q ∧R) ∨(P ∧Q ∧(¬R))∨
(P ∧(¬Q) ∧R) ∨((¬P) ∧(¬Q) ∧(¬R)).
Theorem 2.7.3 Let non-contradiction C ∈L. Then fdnf(C) ≡C.
Proof. See the reference given in the proof of theorem 2.7.2.
The is no example 2.7.3. The fdnf is unique in the following sense.
Theorem 2.7.4. If formula B, C have the same number of atoms which we can always denote by the
same symbols P1, . . . , Pm. If fdnf(B) and fdnf(C) have the same set of fundamental conjunctions except for
a change in order of the individual conjuncts, then fdnf(B) ≡fdnf(C).
Proof. I’m sure you could prove this from our validity theorem, substitution, and the properties of ≡.
Usually, when elementary concepts in logic are investigated, the subject of computers is often of interest.
The reason for this is that, technically, computers perform only a very few basic underlying processes all
related to propositional logic. So, for a moment, let’s look at some of the basic logic circuits, many of which
you can construct. Such circuits are extensions of the (switching) relay circuits where we simply suppress
the actual device the functions in the fashion diagrammed on pages 17, 18. Since any formula A is equivalent
to its fdnf, its the fdnf that’s used as a bases for these elementary logic circuits. An important procedure
within complex logic circuits is simpliﬁcation or minimizing techniques. Simpliﬁcation does not necessarily
mean fewer devices. The term simpliﬁcation includes the concept of something being more easily constructed
and/or less expensive. We will have not interest is such simpliﬁcation processes.
Looking back at pages 17, we have three logic devices. The or-gate ⃝∨, diagram (i); the and-gate ⃝∧,
diagram (ii), and an inverter ⃝¬, which is the combination of the two diagrams above diagram (i). The
inverter behaves as follows: when current goes in one end, it opens and no current leaves the exit wire, the
output. But, when input is no current, then output is current. (We need not use current, of course. Any
two valued physical event can be used.) In the following diagrams the current direction and what is called
29

the logical ﬂow is indicated by the line with an arrow. If there is no ﬂow, then no arrows appear. Now each
gate has at least two inputs and one output in our diagrams except the inverter.
It’s very, very easy to understand the behavior of the or-gates and the and-gates. They have the same
current ﬂow properties as a corresponding truth-table, where T means current ﬂows and F means no current
ﬂows. The basic theorem used for all logic circuits is below.
Theorem 2.7.5 If A ≡B, then any logic circuit that corresponds to A can be substituted for any
logical circuit that corresponds to B.
Proof. Left to you.
Example 2.7.4 Below are diagrams for two logic circuits. For the ﬁrst circuit, note that if no circuit
ﬂows into lines A and B, then there is a current ﬂowing out the C line. In current ﬂows in the A and B line
from left to right, then again current ﬂows out the C line. But if current ﬂows in the A and not in the B,
or in the B and not in the A, then no current ﬂows out the C line. I’ll let you do the “ﬂow” analyze for the
second diagram.
In the ﬁrst diagram, the symbol ցx means that the arrow has been removed from the pathway indicator.
(This is done to minimize the storage space required when processing this monograph.) The diagrams only
show what happens when both A and B have current.
−→−−A −−→−−−−−−−−→⃝∧−−(A ∧B)−−−−−−−−−−−−→
ց
⃝¬
ր
y
րցx
⃝∨−−−−→C−−−−→
ր
ցx

ր
−−→−−B−−−−→⃝¬−−(¬B)−−⃝∧−−((¬A) ∧(¬B))−−−−−−
C = (A ∧B) ∨((¬A) ∧(¬B))
−→−−A−→−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
y
y
⃝∧−−−−−→⃝∨−−−−−−⃝¬←−−−−−⃝∨
x
y
x
−→−−B−→−−−−−−−−−−−−(−−−−−−−−−−−−−−−→

−−−−−−D−−−−−→−−−−−−−−−−−−−−−−−−→
D = (A ∧B) ∨(¬(A ∨B)) and
C ≡D
An important aspect of logic circuits is that they can be so constructed so that they will do binary
arithmetic. Here is an example of binary arithmetic.
0 1
+1 1
1 0 0
The process goes like this. First 1+1 = 1 0. Thus you get a 0 = S with a carry over digit = 1 = C. The carry
over digit is then added to the next column digit 1 and you get 1 0, which is a 0 with a carry over of 1. The
following logic circuit does a part of this arithmetic. If current in A, B indicates 1, no current indicates 0.
This represents the ﬁrst step and yields the basic S and the basic cover number C. (Insert Figure 2 below.)
30

−→−−A−→−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
y
y
⃝∨−−−−−→⃝∧−−−−−−⃝¬←−−−−−⃝∧−−C−−−−−→
x

x
−→−−B−→−−−−−−−−−−−−(−−−−−−−−−−−−−−−→

−−−−−−S−−−−−−−−−−−−−−−−−−−−−−−−−
EXERCISES 2.7
1. Express each of the following formula as an equivalent formula in terms of, at the most, one ¬ on the
left of an atom, and the connectives ∨or ∧.
(a) P ↔(A →(R ∨S))
(d) ((¬P) ↔Q) →R
(b) ((¬P) →Q) ↔R
(e) (S ∨Q) →R
(c) (¬((¬P) ∨(¬Q))) →R
(f) (P ∨(Q ∧S)) →R
2. Write the denial for each of the following formula.
(a) ((¬P) ∨Q) ∧(((¬Q) ∨P) ∧R)
(c) ((¬R) ∨(¬P)) ∧(Q ∧P)
(b) ((P ∨(¬Q)) ∨R)∧
(d) (((Q ∧(¬R)) ∨Q) ∨(¬P)) ∧(Q ∨R)
(((¬P) ∨Q) ∧R)
3. Write each of the following formula in its fdnf, if it has one.
(a) (P ∧(¬Q)) ∨(P ∧R)
(c) (P ∨Q) ↔(¬R)
(b) P →(Q ∨(¬R))
(d) (P →Q) →((Q →R) →(P →R))
4. Using only inverters, or-gates and and-gates, diagram the logic circuits for the following formula. Notice
that you have three inputs.
(a) (A ∨(¬B)) ∨(B ∧(C ∨(¬A)))
(b) (A →B) ∨(¬C)
5. The following two diagrams correspond to an output which is a composite formula in terms of A, B, C.
Write down this formula.
(a)
−→−−A−−−−−−−−−−−−−−−→⃝¬−−−−−−−−−−−−−
y

⃝∨←−−−−−⃝∧−−−−−←−−−−−−−⃝∨
y
x
x
−→−−B−→−−−−−−(−−−−−−−−−−−−−−−−−−−−−→
y
−→−−−C−−−−−→⃝∧−−−−−→−−−−−−−−−−−−−−−−−−→
31

(b)
−→−−A−→−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
y
y
⃝∨−→⃝∧−−−−−−−−−−⃝¬←−−−−−⃝∧
x

x
−→−−B−→−−−−−−−−−−(−−−−−−−−−−−−−−−−−−→

−−−−−−−−−−−−−−−−−−−−−−−−


⃝∨−→⃝∧←−−−−−−−−−⃝¬−−−−−−⃝∧
x
y
x
−→−−C−→−−−−−−−−−−(−−−−−−−−−−−−−−−−−−→
y
−−−−−−−−−−−−−→−−−−−−−−−−−−−−−−−−−−−→
2.8 The Princeton Project, Valid Consequences (in General).
After the methods were discovered that use logical operators to generate a solution to the General
Grand Uniﬁcation Problem, and that give an answer to the questions “How did our universe come into
being?” and “Of what is empty space composed?” I discovered that the last two questions were attacked, in
February — April 1974, by John Wheeler and other members of the Physics and Mathematics Department
at Princeton University. Wheeler and Patton write, “It is diﬃcult to imagine a simpler element with which
the construction of physics might begin than the choice yes–no or true–false or open circuit–closed circuit. .
. . which is isomorphic [same as] a proposition in the propositional calculus of mathematical logic.” [ Patton
and Wheeler, Is Physics Legislated by a Cosmogony, in Quantum Gravity, ed.
Isham, Penrose, Sciama,
Oxford University Press, Oxford (1975), pp. 538–605.] These basic concepts are exactly what we have just
studied.
These individuals, one of the world’s foremost group of scientists, attempted to solve this problem by a
statistical process, but failed to do so. Because they failed, they rejected any similar approach to the problem.
They seemed to be saying that “If we can’t solve these problems, then no one can.” They were wrong in their
rejection of the propositional calculus as a useful aspect for such a solution. But, the solution does not lay
with this two valued truth–falsity model for the propositional logic. The solution lies with the complementary
aspect we’ll study in section 2.11 called proof theory. Certain proof theory concepts correspond to simple
aspects of our truth–falsity model. In particular, we are able to determine by assignment and truth-table
procedures whether or not a logical argument is following basic human reasoning processes (i.e. classical
propositional deduction). However, what you are about to study will not speciﬁcally identify what the brain
is doing, but it will determine whether or not it has done its deduction in terms of the classical processes
must easily comprehend by normal human beings.
Let {A1, . . . , An} be a ﬁnite (possibly empty) set of formula. These formula represent the hypotheses
or premises for a logical argument. For convenience, it has become common place to drop the set-theoretic
notation { and } from this notation. Since these are members of a set, they are all distinct in form. Again from
the concepts of set-theory, these formula are not considered as “ordered” by the ordering of the subscripts.
32

Deﬁnition 2.8.1 (Valid consequence.) A formula B is a valid consequence (or simply a consequence)
of a set of premises A1, . . . , An if for any assignment a to the atoms in each A1, . . . , An AND B such that
v(A1, a) = · · · = v(An, a) = T, then v(B, a) = T. If B is a valid consequence of A1, . . . , An, then this is
denoted by A1, . . . , An |= B.
As usual, if some part of deﬁnition 2.8.1 does not hold, then B is an invalid (not a valid) consequence of
A1, . . . , An. This is denoted by A1, . . . , An ̸|= B. It is important to notice that deﬁnition 2.8.1 is a conditional
statement. This leads to a very interesting result.
Theorem 2.8.1 Let A1, . . . , An be a set of premises and there does not exist an assignment to the
atoms in A1, . . . , An, such that the truth-values v(Ai, a) = T for each i, where 1 ≤i ≤n. Then, for ANY
formula B ∈L, A1, . . . , An |= B.
Proof. In a true conditional statement, if the hypothesis is false, then the conclusion holds.
The conclusion of theorem 2.8.1 is so signiﬁcant that I’ll devote an entire section (2.10) to a more in-
depth discussion. Let’s continue with more facts about the valid consequence concept. We will need two
terms, however, for the work in this section that are also signiﬁcant for section 2.10.
Deﬁnition 2.8.2 (Satisfaction.) If given a set of formula A1, . . . , An (n ≥1), there exists an assignment
a to all the atoms in A1, . . . , An such that v(A1, a) = · · · = v(An, a) = T, then the set of premises are said to
be satisﬁable. The assignment itself is said to satisfy the premises. One the other hand, if such an assignment
does not exist, then the premises are said to be not satisﬁed.
Theorem 2.8.2 (Substitution of equivalence.) If An ≡C and A1, . . . , An |= B, then A1, . . . , An−1, C |=
B. If B ≡C and A1, . . . , An |= B, then A1, . . . , An |= C.
Proof. Left to you.
Are many logical arguments that seem very complex, in reality, a disguised simple deduction?
Conversely, can we take a simple deduction and make it look a little more complex? The following the-
orem is not the last word on this subject and is very closely connected with what we mean when we say
that such and such is a set of premises. When we write the premises A1, . . . , An, don’t we sometime (all the
time?) say “and” when we write the comma “,”? Is this correct?
Theorem 2.8.3 (The Deduction Theorem) Let Γ be any ﬁnite (possible empty) set of formula and
A, B ∈L.
(i) Γ, A |= B if and only if Γ |= A →B.
(ii) Let A1, . . . , Ai, . . . An be a ﬁnite (nonempty) set of formula, where 1 < i ≤n. Then A1, . . . , An |= B
if and only if A1, . . . , Ai |= (Ai+1 →(· · · →(An →B) · · ·)).
(iii) Let A1, . . . , Ai, . . . An be a ﬁnite (nonempty) set of formula, where 1 < i ≤n. Then A1, . . . , An |= B
if and only if (A1 ∧· · · ∧Ai), . . . , An |= B.
(iv) A1, . . . , An |= B if and only if |= (A1 ∧· · · ∧An) →B.
Proof. (i) Assume that Γ, A |= B. Let a be an assignment to the set of atoms in Γ, A, B. If a satisﬁes
Γ, A, then v(A, a) = T. Also from the hypothesis, v(B, a) = T. Hence, v(A →B, a) = T. Now if Γ is not
satisﬁed (whether or not A is), then from theorem 2.8.1, Γ |= A →B. If a satisﬁes Γ and does not satisfy A,
then v(A, a) = F. Thus, v(A →B, a) = T. All the cases have been covered; hence, in general, Γ |= A →B.
Conversely, assume that Γ |= A →B and let a be as previous deﬁned. If a does not satisfy Γ, then a
does not satisfy Γ, A. If a satisﬁes Γ and does not satisfy A, then a does not satisfy Γ, A. Hence, we only
33

need to consider what happens if a satisﬁes Γ, A. Then, in this case, v(A, a) = T. Since v(A →B, a) = T,
then v(B, a) = T. Therefore, Γ, A |= B.
(ii) (By induction on the number m of connectives →placed between the formula on the right of |=.)
(a) The m = 1 case is but part (i). Assume theorem holds for m connectives. Then one more applications
of (i) shows it holds for m + 1 connectives →. Hence, the result holds in general. Similarly the converse
holds.
(iii) (By induction on the m number of connectives ∧placed between A1, . . . , Ai.) Suppose that
A1, A2, . . . , An |= B.
(a) Let m = 1. Suppose that A1, A2, . . . , An |= B. Let a be an assignment to all the atoms in (A1 ∧
A2), . . . , An, B that satisﬁes (A1 ∧A2), . . . , An. Then v(A1 ∧A2, a) = T. Hence, v(A1, a) = v(A2, a) = T.
Then a is an assignment to all the atoms in A1, A2, . . . , An, B. Now v(A1, a) = v(A2, a) = T = · · · = v(An, a).
This implies that v(B, a) = T. Hence, (A1 ∧A2), . . . , An |= B.
(b) Now assume theorem holds for m or less connectives ∧and suppose that i = m + 2. We know that
A1, A2, . . . , Ai, · · · , An |= B. Now from (ii), we know that A1, A2, . . . , Am+1 |= (Am+2 →(· · · (An →B) · · ·))
from (ii). The induction hypothesis yields (A1 ∧A2 ∧. . . ∧Am+1) |= (Am+2 →(· · · (An →B) · · ·)). From
this we have (A1 ∧A2 ∧. . . ∧Am+1), Am+2 |= (Am+3 →(· · · (An →B) · · ·)). Application of (i) and (ii) yields
(A1 ∧· · · ∧Am+2), . . . , An |= B. The general result follows by induction and the converse follows in a similar
manner.
(iv) Obvious from the other results.
When you argue logically for a conclusion, it’s rather obvious that one of your hypotheses is a valid con-
clusion. Further, if you start with a speciﬁc set of hypotheses and obtained a ﬁnite set of logical conclusions.
You then often use these conclusions to argue for other consequences. Surely it should be possible to go
back to your original hypotheses and argue to you ﬁnal conclusions without going through the intermediate
process.
Theorem 2.8.4
(i) A1, . . . , An |= Ai for each i = 1, . . . , n.
(ii) If A1, . . . , An |= Bj, where j = 1, . . . , p, and B1, . . . , Bp |= C, then A1, . . . , An |= C.
Proof. (i) Let a be any assignment that satisﬁes A1, . . . , An. Hence, v(Ai, a) = T, for each i = 1, . . . , n.
Thus A1, . . . , An |= Ai for each i = 1, . . . , n.
(ii) Let a be an assignment to all the atoms in A1, . . . , An, Bi, . . . , Bp, C. Of course, this is also an
assignment for each member of this set. Conversely, any assignment to any of the formula in this set can
be extended to an assignment to all the atoms in this set. Suppose that v(Ai, a) = T, for each i such that
1 ≤i ≤m. Since A1, . . . , An |= Bj, where j = 1, . . . , p, then v(Bj, a) = T, where j = 1, . . . , p. This a
satisﬁes Bj for each j = 1, . . . , p. Hence, from the remainder of the hypothesis, v(C, a) = T and the proof is
complete.
[For those who might be interested. This is not part of the course. First, we know that if A ≡B,
then we can substitute throughout the process |= anywhere A for B or B for A. Because of theorem 2.8.3,
all valid consequences can be written as A |= B, where A is just one formula. (i) Now A |= A, and (ii) if
A |= B, B |= C, then A |= C. Thus |= behaves almost like the partial ordering of the real numbers. If you
substitute ≤for |= you have A ≤A, if A ≤B, B ≤C, then A ≤C. In its present form it does not have
the requirement that (iii) if A ≤B, B ≤A, then A = B. However, notice that if A |= B, B |= A, then
|= A →B, |= B →A. This implies that A ≡B. Hence we could create a language by taking one and only
34

one member of from each equivalence class [A] (see problem 1, Exercise 2.6.) and only used these for logical
deduction. (A very boring way to communicate.) Then (iii) would hold. Hence, in this case, everything
known about a partial ordering should hold for the |= .]
EXERCISE 2.8
1. First, note the discussion at the top of page 57 as to how to use truth-tables to determine if a conse-
quence is valid. Now use the truth-table method to determine whether the following consequences are valid
consequences from the set of premises.
(a) P →Q, (¬P) →Q |= Q.
(b) P →Q, Q →R, P |= R.
(c) (P →Q) →P, ¬P |= R.
(d) (¬P) →(¬Q), P |= Q.
(e) (¬P) →(¬Q), Q |= P.
2.9 Valid Consequences — Model Theory and Beyond.
The most obvious way to show that B is a valid consequence of A1, . . . , An is by the truth-table method.
(i) Simply set up a truth-table for the formulas A1, . . . , An, B.
(ii) Look at every row, where under each Ai there is a T, and if in that row the B is a T, then B is a
valid consequence of A1, . . . , An.
Of course, if A1, . . . , An is not satisﬁable, then it is automatically the case that B is a valid consequence.
BUT, in most cases you would have a very large truth-table. For example, for the arguments of section 1.1,
you would need a truth-table with 26 + 1 = 65 rows and about 8 columns. You might get a research grant,
of some sort, so that you could get the materials for such a truth-table construction. This is the strict model
theory approach. Why? Because the truth-table is a “model” (i. e. not the real thing) for classical human
propositional deduction. When I deduce what I hope is a logical conclusion, I don’t believe I construct a
truth-table in my mind. Maybe some do, but I don’t. So, is there another method that is model theory
viewed in a diﬀerent way that may be a shorter method? The method comes from theorem 2.8.3 part (iv).
NOTATION CHANGE. It seems pointless to keep saying “Let a be an assignment to the atoms
in A. Then v(A, a) = T or F.” Why not do the following: just write v(A, a) = v(A) = T. When we see
v(A) = T or F, we know that there is some assignment to the atoms that makes it so.
Now what theorem 2.8.3 tells us is that all we need to do is to show that |= (A1 ∧· · · ∧An) →B. But, if
one selects an assignment such that v(B) = F, then |= (A1∧· · ·∧An) →B if and only if v((A1∧· · ·∧An)) = F.
We need not look at the case when v(B) = T. (Why not ?) The method is a natural language algorithm.
This means that I use some of the terms that I’ve previously introduced and ordinary English to give a
series of repeatable instructions. Now whether or not this method is shorter than the truth-table method
depends upon how clever you are in a certain selection process. Only experience indicates that it is often
much shorter. The instructions themselves are not short in content. But remember these methods took over
2,000 years to develop.
Special Method 2.9.1 (To show that |= (A1∧· · ·∧An) →B.) In what follows, the symbol ⇒represents
that word forces.
(1) First, let v(B) = F. In the simplest case, this truth-value for B ⇒a ﬁxed truth-value on each of the
atoms of B. Let these atoms have these forced truth-values.
35

Example 2.9.1.1 Let B = P →(Q →R). Then v((P →(Q →R))) = F ⇒v(P) = T ; v(Q) =
T ; v(R) = F and these are the only possibilities.
(2) See if these forced and ﬁxed atom truth-values forces any of the premises to have a ﬁxed truth-value.
(3) If (2) occurs and the value of the premise is F, then the process stops and you have a valid
consequence.
Example 2.9.1.2 Suppose that one of the premises is A = P ∧R. Then for example 2.9.1.1 atomic
values you would have that v(A) = F. You can stop the entire process. B is an valid consequence of the
premises.
(4) If (2) occurs and the truth-value is T for a premise, then simply write it down as its value.
(5) If (4) occurs and there are more premises that are NOT forced to take on a speciﬁc truth value by
the forced atomic truth-values for B, then you can select any of the remaining premises, usually those with
the fewest non-forced atoms (but not always), and set the truth value of the selected premise as T.
Example 2.9.1.3 Suppose that process did not stop at step (3). Let one of the premises be A1 = S ∨R.
Then setting v(A1) = T ⇒v(S) = T.
(6) You now have some premises with forced or selected values of T. Now use the forced atomic values
and begin again with (2) for the remaining process.
(7) If this the simplest part of the process stops, then it will either force a premise to be F and you may
stop and declare the consequence valid or all the premises will be selected or forced to be T and you have
found one assignment that proves that the consequence is invalid.
Example 2.9.1.4 Suppose that you what to answer the question P1 →(P2 →P3), (P3 ∧P4) →
P5, (¬P6) →(P4 ∧(¬P5))
?
|=P1 →(P2 →P6).
(i) Well, let v(P1 →(P2 →P6)) = F. Then v(P1) = v(P2) = T, v(P6) = F. These values do not force
any of the premises to be any ﬁxed value.
(ii) Select the ﬁrst premise and let v(P1 →(P2 →P3)) = T. From (i) ⇒v(P3) = T. The values that
have been forced do not force the remaining premises to take any ﬁxed value.
(iii) Let v((¬P6) →(P4 ∧(¬P5))) = T
⇒v(P4 ∧(¬P5)) = T from (1). Hence v(P4) = T, v(P5) = F.
But these forced atoms ⇒v((P3 ∧P4) →P5) = F.
(iv) Hence, |= holds. Notice that for this example a truth table requires 65 rows.
Example 2.9.1.4 Suppose that you what to answer the question P →R, Q →S, (¬R) ∨(¬S)
?
|=P ∨
(¬Q).
(i) Let v(P ∨(¬Q)) = F, ⇒v(P) = F, v(Q) = T.
(ii) Let v(Q →S) = T, from (i), ⇒v(S) = T.
(iii) Let v((¬R) ∨(¬S)) = T, from (ii), ⇒v(R) = F.
(iv) Now (i) and (iii) ⇒v(P →R) = T.
(v) Since all premises were either selected or forced to be T, then B is an invalid consequence from the
premises.
Is all of this important? Well, suppose that you were given a set of orders by your commanding oﬃcer.
You tried to follow these orders but could not do so. Why can’t they be carried out? You discover, after
a lot of work, that the consequence your commanding oﬃcer claimed was a result of the set of premises he
36

gave is invalid. Next you must prove this fact at a court-martial. Yes, it could be very important. But the
above method need not be as straightforward as the examples indicate.
Special Method 2.9.2 (Diﬃculties with Method 2.9.1.) (Case studies.) This special method, can
brake down and become very complex in character for one basic reason. Either the selection of the (might
be) consequence as an F or the selection of any of the premises as a T need not produce ﬁxed values for the
atoms. Now what do you do? For the case study diﬃculties, its easier to establish INVALID consequences.
(1) Suppose that your assumption that the (may be) consequence B has truth-value F does not yield
unique atomic truth-values. Then you must brake up the problem into all the cases produced by all the
diﬀerent possible truth-values for the atoms in B.
Example 2.9.2.1 Let B = P ↔Q. Then for v(P ↔Q) = F there are the following two cases. (a)
v(P) = F, v(Q) = T. (b) v(P) = T, v(Q) = F.
(2) For premises that are not forced to have speciﬁc truth-values, then your selection of a truth-value
for a (possible) premise A need not yield unique atomic truth-values. This will lead to more case studies.
Indeed, possible case studies within case studies.
(3) During any of the speciﬁc case studies if the truth-values of all possible premises yields T, then you
may stop for you have an invalid consequence.
(4) If during any case study you get one or more of the assume premises to be forced to be F, then this
does NOT indicate that you have a valid consequence. You must get an F for some assumed premise for all
possible case studies before you can state that it is a valid argument.
Example 2.9.2.2 Suppose that you what to answer the question P →R, Q →S, (¬R)∨(¬S)
?
|=P ∧Q.
(i) Let v(P ∧Q) = F. You have three cases. (a) v(P) = F, v(Q) = F. (b) v(P) = T, v(Q) = F. (c)
v(P) = F, v(Q) = T.
Case (a). No assumed premise is forced to be anything. So, select v(Q →S) = T. This yields two
subcases. (a1) v(S) = F, (a2) v(S) = T.
Case (b). Again let v(Q →S) = T. Again we have two subcases. (b1) v(S) = F, (b2) v(S) = T.
Case (c). Again let v(Q →S) = T. Now this ⇒v(S) = T.
(ii) Now we would go back and select another assumed premises such as P →R and set its value to T.
Then assuming cases (a), (a1) see what happens to the atoms in P →R. This might produce more cases
such as (a11) and an (a12). We would have a lot to check if we believed that B might be a valid consequence.
(iii) Notice that we have only one more assumed premises remaining (¬R) ∨(¬S). We can assume that
v(P →R) = T and there are atomic values that will produce this truth-value. Now S does not appear
in this formula hence under condition (b1) v(S) = F. v((¬R) ∨(¬S)) = T. Hence we have found a special
assignment that shows that B is an invalid consequence.
(iv) Lets hope the method doesn’t lead to many case studies since it might be better to use truth-tables.
NOTE ON FORMULA VARIABLES. You do not need to use the atomic form of a formula when a valid
consequence is being determined. What you actually can do is to substitute for every speciﬁc atom in every
place it appears a formula variable symbol, and distinct variables for distinct atoms. If for each variable
formula symbol you substitute a ﬁxed formula in atomic form, then in the valid consequence truth-table
the various levels at which the premises are T is only dependent on the connectives that are in the original
formula prior to substitution if the premise is not a single atom. If it is a single atom, then the atom as a
premise still only depends upon it being give a T value. The same would be true for any formula substituted
throughout the premises and assumed consequence for that atom. Thus, in exercise 1 below formula variable
37

symbols have been used. Simply consider them to behave like atoms. Each time you determine that the
indicated formula is a valid consequence, then you have actually determined the case for inﬁnitely many
formula. But if it is an invalid consequence, then you cannot make such a variable substitution. Such an
“invalid” result only holds for atoms.
EXERCISE 2.9
1. Using the special method 2.9.1 or 2.9.2 (in the formula variable form) to determine whether or not
(a) (¬A) ∨B, C →(¬B) |= A →C.
(b) A →(B →C), (C ∧D) →E, (¬G) →(D ∧(¬E)) |= A →(B →G).
(c) (A ∨B) →(C ∧D), (D ∨E) →G |= A →G.
(d) A →(B ∧C), (¬B) ∨D, (E →(¬G)) →(¬D), B →(A ∨(¬E)) |= B →E.
2. Translate the following natural language arguments into propositional formula using the indicated propo-
sitional symbols and determine by method 2.9.1 or 2.9.2 whether or not the argument is valid or invalid.
(Remember that you do NOT need to know what the terms in a phrase mean to check the validity of an
argument.)
(a) Either I shall go home (H), or stay and study (S). I shall not go home. Therefore I shall stay and
study.
(b) If the set of real numbers is inﬁnite (I), then it has cardinality c (C). If the set of real numbers is
not inﬁnite, then it forms a ﬁnite set (D). Therefore, either the set of real numbers has cardinality c or it
forms a ﬁnite set.
(c) A Midshipman’s wage may sometime increase (S) only if there is inﬂation (I). If there is inﬂation,
then the cost of living will increase (C). Now and then a Midshipman’s wage has increased. Therefore, the
cost of living has increased.
(d) If 2 is a prime number (P), then it is the least prime number (L). If 2 is the least prime number,
then 1 is not a prime number (N). The number 1 is not a prime number. Therefore, 2 is a prime number.
(e) Either the set of real numbers is well-ordered (W) or it contains a well-ordered subset (C). If the
set of real numbers is well-ordered, then every nonempty subset contains a ﬁrst element (R). The natural
numbers form a well-ordered subset of the real numbers (N). Therefore, the real numbers are well-ordered.
(f) If it is cold tomorrow (C), then I’ll wear my heavy coat (I) if the sleeve is mended (M). It will be
cold tomorrow and the sleeve will not be mended. Therefore, I’ll not wear my heavy coat.
(g) If the lottery is ﬁxed (L) or the Colts leave town again (C), then the tourist trade will decline (D)
and the town will suﬀer (S). If the tourist trade decreases, then the police force will be more content (P).
The police force is never content. Therefore, the lottery is ﬁxed.
2.10 Satisfaction and Consistency.
As mentioned previously, the concept of when a set of formula is satisﬁed is of considerable importance.
Suppose that we assume that a set of premises refer to “things” that occur in reality. As you’ll see, in
order for a set of premises to diﬀerentiate between diﬀerent occurrences it must be satisﬁable. We recall the
deﬁnition.
Deﬁnition 2.10.1 (Satisfaction.) A nonempty (ﬁnite) set of premises A1, . . . , An is satisﬁable if there
exists an assignment a to all the atoms that appear in the premises such that v(Ai) = T for each i such that
1 ≤i ≤n.
38

One way to attack the problem of satisfaction is to make a truth-table. If there is a row such that under
every Ai there is a T, then the set of premises is satisﬁable. As we did in the previous section, there is a short
way to do this without such speciﬁc truth-tables. But, for the propositional calculus, why is satisfaction so
important?
Deﬁnition 2.10.2 A set of formula A1, . . . , An is consistent if for each B ∈L, A1, . . . , An ̸|= B ∧(¬B).
A set of premises is inconsistent if there exist some B ∈L such that A1, . . . , An |= B ∧(¬B).
Actually deﬁnition 2.10.2 is technical in character since if we only had this deﬁnition it might never (in
time) be possible to know whether a set of premises is consistent. Also, as yet consistency may not seem
as an important property. Notice that that formula B ∧(¬B) is a contradiction. Thus sometimes a set of
premises that is inconsistent are also said to be
contradictory. Notice that deﬁnition 2.10.2 includes the
possible empty set of premises. This yields the pure validity concept. The next result shows that our pure
validity concept is consistent.
Theorem 2.10.1 If B ∈L, then ̸|= B ∧(¬B).
Proof. Let (for an appropriate assignment a) v(B) = T. Then v(B ∧(¬B)) = F. One the other hand, if
v(B) = F, then v(B ∧(¬B)) = F. Since every assignment to B ∧(¬B) is an assignment to B and conversely,
the result follows.
As mentioned above, it is assumed by many individuals, although it cannot be established, that human
deduction corresponds to a humanly comprehensible “occurred in reality” concept.
I won’t discuss the
philosophical aspects of this somewhat dubious assumption, but even if it’s, at the least, partially true the
concept of consistency is of paramount importance. Theorem 2.10.1 gives a slight indication of what is going
on. Not every formula in our language is a valid formula. The concept of simply consistent is deﬁned by
the statement that a set of premises is simply consistent if not all formula are consequences of the premises.
Obviously, by theorem 2.10.1, there is no diﬀerence between the two concepts for an empty set of premises.
The worst thing that can happen for any nonempty set of premises A1, . . . , An in the scientiﬁc or
technical areas is that A1, . . . , An |= B, where B is ANY member of L. Why? This would mean that all
formula including contradictions are valid consequences. Now if we associate with A1, . . . An |= B, the notion
that if each Ai occurs in reality, then B will occur in reality, then this worst case scenario says “all things
B will occur in reality.” Intuitively, this just doesn’t imply that any theory based upon this set of premises
cannot diﬀerentiate between occurrences, but “true” could not be diﬀerentiated from “false.” But how can
we know when a set of premises has this worst case scenario property?
Theorem 2.10.2 A nonempty set of premises A1, . . . , An is inconsistent if and only if A1, . . . , An |= B
for every B ∈L.
Proof. Let A1, . . . , An be inconsistent and any B ∈L. Then there is some C ∈L such that A1, . . . , An |=
C∧(¬C). Considering any assignment a to the atoms in C and B, then v(C∧(¬C)) = F. Hence, C∧(¬C) |= B.
Application of theorem 2.8.4 (ii) yields A1, . . . , An |= B.
Conversely, simply let the formula in L be C∧(¬C). Then A1, . . . , An |= C∧(¬C) satisﬁes the deﬁnition.
Corollary 2.10.2.1 A nonempty set of premises A1, . . . , An is consistent if and only if there exists some
B ∈L such that A1, . . . , An ̸|= B.
Well, the above deﬁnitions and theorems, although they give us information about the concept of
inconsistency, DO NOT GIVE any actual way to determine whether or not a set of premises is consistent.
The theorems simply say that we need to check valid consequences for inﬁnity many formula. Not an easy
thing to do. For over 2,000 years, there was no way to determine whether or not a set of premises was
consistent except to show that human propositional deduction leads to a speciﬁc contradiction.
39

Theorem 2.10.3 A nonempty set of premises A1, . . . , An is inconsistent if and only if it is not satisﬁable.
Proof. Assume that A1, . . . , An is inconsistent. Thus there is some B ∈L such that A1, . . . , An |=
B ∧(¬B). Hence, |= (A1 ∧· · · ∧An) →(B ∧(¬B)) by the Deduction theorem. But for any assignment to
atoms in Ai and B, v(B ∧(¬B)) = F. Now let A1, . . . , An be satisﬁable. Hence , there is an assigmment v
such that v(Ai) = T, i = 1, . . . , n. Extend this assignment to v′ so that it is an assignment for any diﬀerent
atoms that might appear in B. Thus, v′(A1 ∧· · · ∧An) →(B ∧(¬B)) = F. This contradicts the stated
Deduction theorem. Hence, inconsistency implies not satisﬁable.
Conversely, suppose that A1, . . . , An is not satisﬁable. Then for any B ∈L, A1, . . . , An |= B from the
deﬁnition of satisﬁable (theorem 2.8.1). By theorem 2.10.2, A1, . . . , An is inconsistent.
Corollary 2.10.3.1 A nonempty set ﬁnite of premises is consistent if and only if it is satisﬁable.
Since the concept of satisfaction is dependent upon the concept of valid consequence, the same variable
substitution process (page 59) can be used for the atoms that appear in each premise.
Thus when you
consider the formula variables as behaving like atoms, when inconsistency is determined, you have actually
shown that inﬁnitely many sets of premises are inconsistent. Consistency, however, only holds for atoms
and not for the * type of variable substitution. As an example, the set P →Q, Q is a consistent set, but
P →((¬R) ∧R), (¬R) ∧R is an inconsistent set. Now, it is theorem 2.10.3 and its corollary that gives a
speciﬁc and FINITE method to determine consistency. A (large sometimes) truth-table will do the job. But
we can also use a method similar to the forcing method of the previous section.
Special Method 2.10.1 The idea is to try and to pick out a speciﬁc assignment that will satisfy a set
of premises, or to show that when you select a set of premises to be T, then this ⇒a premise to be F and,
hence, the set would be inconsistent.
(1) First, if the premises are written in formula variables then either substitute atoms for the variables
or, at the least, consider them to be atoms.
(2) Now select a premise, say A1 and let v(A1) = T. If possible select a premise that forces a large
number of atoms to have ﬁxed values. If this is impossible, then case studies may be necessary.
(3) Now select another premise that uses the maximum number of the forced atoms and either show that
this premise has a value T or F. If it has a value F and there are no case studies then the set is inconsistent.
If it is T or you can select it to be T, then the process continues.
(4) If the process continues, then start again with (3). Again if a premise if forced to be F, then the set
is inconsistent. This comes from the fact that the other premises that have thus far been used are FORCED
to be T.
(5) If the process continues until all premises are forced to be T, then what has occurred is that you
have found an assignment that yields that the set is consistent.
(6) If there are case studies, the process is more diﬃcult. A case study is produced when a T value for
a premise has non-ﬁxed truth-values for the atoms. You must get a forced F for each case study for the set
to be inconsistent. If you get all premises to be T for any case study, then the set is consistent.
(7) Better still if you’ll remember what you’re trying to establish, then various short cuts can be used.
For consistency, we are trying to give a metalogic argument that there is an assignment that gives a T for
all premises. Or, for inconsistency, show that under the assumption that some premises are T, then this will
force, in all cases, some other premise to be an F.
Example 2.10.1 Determine whether or not the set of premises (A ∨B) →(C ∧D), (D ∨F) →
G, A ∨(¬G) (written in formula variable form) is consistent. First, re-express this set in terms of atoms.
(P ∨Q) →(R ∧S), (S ∨S1) →S2, P ∨(¬S2).
40

(a) Let v(P ∨(¬S2)) = T. Then there are three cases.
(a1), v(P) = T, v(S2) = F;
(a2), v(P) = T, v(S2) = T ;
(a3), v(P) = F, v(S2) = F.
(b) But, consider the ﬁrst premise. Then v((P ∨Q) →(R ∧S)) = T. Now consider case (a1). Then
v(P ∨Q) = T ⇒v(R ∧S) = T ⇒v(R) = v(S) = T. Still under case (a1), ⇒v((S ∨S1) →S2) = F. But we
must continue for the other cases for this (b) category. Now for (a2), we have that v((S ∨S1) →S2) = T.
Hence, we have found assignments that yield T for all premises and the set is consistent.
Example 2.10.2 Determine whether or not the set of premises A ↔B, B →C, (¬C) ∨D, (¬A) →
D, ¬D. (written in formula variable form) is consistent. First, re-express this set in terms of atoms. P ↔
Q, Q →R, (¬R) ∨S, (¬P) →S, ¬S.
(a) Let v(¬S) = T ⇒S = F.
(b) Let v((¬R) ∨S) = T ⇒v(R) = F.
(c) Let v(Q →R) = T ⇒v(Q) = F.
(d) Let v(P ↔Q) = T ⇒v(P) = F ⇒v((¬P) →S) = F. Thus the set is inconsistent and, hence, we
can substitute the original formula variables back into the set of premises.
If |= is associated with ordinary propositional deduction, then it should also mirror the propositional
metalogic we are using. One of the major metalogical methods we are using is called “proof by contradiction.”
This means that you assume as an additional premise the negation of the conclusion. Then if you can establish
a contradiction of anything, then the given hypotheses can be said to “logically” establish the conclusion.
The next theorem about valid consequence mirrors this notion.
Theorem 2.10.4 For any set of premises, A1, . . . , An |= B if and only if A1, . . . , An, ¬B |= C ∧(¬C)
for some C ∈L.
Proof. Let A1, . . . , An |= B. If A1, . . . , An is inconsistent, then A1, . . . , An |= C ∧(¬C) for all C ∈L.
Adding any other premise such as ¬B does not alter this. So, assume that A1, . . . , An is consistent. Hence,
consider any assignment a to all the atoms such that v(Ai) = T, 1 ≤i ≤n and v(B) = T and such an
assignment exists. Thus for any such assignment v(¬B) = F. Consequently, for any assignment b either
v(Aj) = F for some j such that 1 ≤j ≤n, or all v(Ai) = T and v(¬B) = F. Hence, A1, . . . , An, ¬B is not
satisﬁed. Hence, for some (indeed, any) C ∈L, A1, . . . , An, ¬B |= C ∧(¬C).
Conversely, let A1, . . . , An, ¬B |= C ∧(¬C) for some C ∈L. Then A1, . . . , An, ¬B is inconsistent and
thus given any assignment a such that v(Ai) = T for each i such that 1 ≤i ≤n, then v(¬B) = F. Or, in
this case, v(B) = T. Consequently, A1, . . . , An |= B.
EXERCISES 2.10
1. By the special method 2.10, determine if the indicated set of premises is consistent.
(a) A →(¬(B ∧C)), (D ∨E) →G, G →(¬(H ∨I)), (¬C) ∧E ∧H.
(b) (A ∨B) →(C ∧D), (D ∨E) →G, A ∨(¬G).
(c) (A →B) ∧(C →D), (B →D) ∧((¬C) →A), (E →G) ∧(G →(¬D)), (¬E) →E.
(d) (A →(B ∧C)) ∧(D →(B ∧E)), ((G →(¬A)) ∧H) →I, (H →I) →(G ∧D), ¬((¬C) →E).
41

2.11 Proof Theory – General Concepts.
Actually, we are investigating the propositional logic in a historically reversed order. The concept of
proof theory properly began with Frege’s Begriﬀschrift which appeared in 1879 and was at its extreme with
Principia Mathematica written by Whitehead and Russell from 1910 –1913. Philosophically, proof “theory,”
even though it can become very diﬃcult, seems to the nonmathematician to be somewhat more “pure” in its
foundations since it seems to rely upon a very weak mathematical foundation if, indeed, it does have such
a foundation. However, to the mathematician this could indicate a kind of weakness in the basic tenants
associated with the concept of the formal proof. Notwithstanding these philosophical diﬀerences, basic proof
theory can be investigated without utilizing any strong mathematical procedures. Since we are studying
mathematical logic, we will not restrict our attention to the procedures used by the formal logician but,
rather, we are free to continue to employ our metamathematical concepts.
The concept of formalizing a logical argument goes back to Aristotle. But it again took over 2,000 years
before we could model, in another formal way, the various Aristotle formal logical arguments. Proof theory
ﬁrst requires a natural language algorithm that gives simple rules for writing a formal proof. The rules that
are used can be checked by anyone with enough training to apply the same rules. But, in my opinion, the
most important part of proof theory is the fact that we view the process externally while the philosophical
approach views the process internally. (We study the forest, many philosophers study the trees, so to speak.)
For example, we know that every propositional formula can be replaced by an equivalent formula expressed
only in the connectives ¬ and →. Thus we can simplify our language construction process considerably.
Deﬁnition 2.11.1 (The Formal Language L′.)
(1) You start at step (2) of deﬁnition 2.2.3.
(2) Now you go to steps (3) — (6) of deﬁnition 2.2.3 but only use the ¬ and →connectives.
Notationally, the language levels constructed in deﬁnition 2.11.1 are denoted by L′
n and B ∈L′ if and
only if there is some n ∈IN such that B ∈L′
n. Also don’t forget that level L′
n contains all of the previous
levels. Clearly L′ is a proper subset of L. Also, all the deﬁnitions of size, and methods to determine size,
and simpliﬁcation etc. hold for L′.
Now proof theory does not rely upon any of the concepts of truth—falsity, what will or will not occur
in reality, and the like we modeled previously. All the philosophical problems associated with such concepts
are removed. It is pure, so to speak. But as mention it relies upon a set of rules that tells us in a step-by-step
manner, hopefully understood by all, exactly what formulas we are allowed to write down and exactly what
manipulations we are allowed to perform with these formulas. It’s claimed by some that, at the least, it’s
mirroring some of the procedures the human beings actually employ to obtained a logical conclusion from a
set of premises. Proof theory is concerned with the notion of logical argument. It, of course, is also related
to the metalogical methods the human being uses. We start with the rules for a formula theorem that is
obtained from an empty set of premises. The word “theorem” as used here does not mean the metalanguage
things called “Theorems” in the previous sections. It will mean a specially located formula. We can use
formula variables and connectives to write formula schemata or schema. Each schemata would represent
inﬁnitely many speciﬁc selections from L′. We will simply call these formulas and use the proper letters to
identify them as formula variables.
Deﬁnition 2.11.2 (A formal proof of a theorem.)
(1) A formal proof contains two FINITE COLUMNS, one of formulas Bi, the other column stating the
reason Ri you placed the formula in that step.
B1
R1
42

B2
R2
...
...
...
...
...
...
...
...
Bn
Rn
The formula used represent any members of L′ and each must be obtained in the following manner.
(2) A step i in the formal proof corresponds to a speciﬁc formula Bi. It can be a speciﬁc instance of one
of the following axioms. For any formula A, B, C where as before A, B, C are formula variables (we note
that because of the way we have of writing subformula, the A, B, C can also be considered as expressed in
formula variables), write
P1 :
A →(B →A),
P2 :
(A →(B →C)) →((A →B) →(A →C)),
P3 :
((¬A) →(¬B)) →(B →A).
(3) Formula can only be obtained by one other procedure. It’s called modus ponens and is abbreviated
by the symbol MP. It’s the only way that we can obtain a formula not of the type in (2) and is considered
to be our one rule of logical inference.
Step Bj is obtained if there are two PREVIOUS steps Bi and Bk such that
(i) Bi is of the form A,
(ii) Bk is of the form A →B. Then
(iii) Bj is of the form B
Note that the order of the two needed previous steps Bi and Bk is not speciﬁed. All that’s needed is that
they come previous to Bj.
(4) The last step in the ﬁnite column is called a (formal) theorem and the total column of formulas is
called the (formal) proof of theorem.
(5) If a proof of a theorem E exists, then this is denote by ⊢E.
Since we are using variables, any proof of a theorem is actually a proof for any formula you substitute for
the respective variables (i.e. inﬁnitely many proofs for speciﬁc formula.) In our examples, problems and the
like, I won’t repeat the statement “For any A ∈L′.” The fact that I’m using variable symbols will indicate
this.
Example 2.11.1
Show that ⊢A →A.
Proof.
(1) (A →((A →A) →A)) →((A →(A →A)) →(A →A))
P2
(2) A →((A →A) →A)
P1
(3) (A →(A →A)) →(A →A)
MP(1, 2)
(4) A →(A →A)
P1
(5) A →A
MP(3, 4)
The MP step must include the previous step numbers used for the MP step. Now any individual who
can follow the rules can check that this last formula was obtained correctly. Also, there are many other
43

proofs that lead to the same result. The idea is the same as used to demonstrate a Euclidean geometry
proof, but there is no geometric intuition available. Now at any point in some other proof if you should
need the statement A →A as one of you steps (of course, you can use another symbol for A) then you could
substitute the above ﬁnite proof just before the step is needed and re-number all steps. BUT, rather than
do this all you need to do is to write the symbol ⊢A →A since this indicates that a proof exists. By the
way, there is stored at a university in Holland literally thousand upon thousands of formal proofs. However,
in this course almost all of the formal proofs exhibited will be needed to establish our major results. These
are to show that the formal proof of a formal theorem is equivalent to the modeling concept we call validity.
One of the major results observed by Aristotle was the logical argument he called hypothetical syllogism
or HS. We next use the above procedure to establish this. But it’s a method of introducing a formal proof
and our result is a metatheorem proof.
Theorem 2.11.1 Assume that you have two steps in a possible proof of the form (i) A →B and (j)
B →C. Then you can write down at a larger step number (iii) A →C.
Proof.
(1)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
...
...
(i) A →B
Ri
...
...
(j) B →C
Rj
(j + 1) (B →C) →(A →(B →C))
P1
(j + 2) (A →(B →C)
MP(j, j + 1)
(j + 3) (A →(B →C)) →((A →B) →(A →C))
P2
(j + 4) (A →B) →(A →C)
MP(j + 2, j + 3)
(j + 5) A →C
MP(i, j + 4)
Whenever we use HS, the reason is indicated by the symbol HS(i, j) in the same manner as is done for
MP. IMPORTANT FACT. In the above metatheorem that yields HS, please note that the step (j) can come
before step (i).
Example 2.11.2
⊢(¬(¬A)) →A
(1) (¬(¬A)) →((¬(¬(¬(¬A)))) →(¬(¬A)))
P1
(2) ((¬(¬(¬(¬A)))) →(¬(¬A))) →((¬A) →(¬(¬(¬A))))
....
(3) (¬(¬A)) →((¬A) →(¬(¬(¬A))))
HS(1, 2)
(4) ((¬A) →(¬(¬(¬A)))) →((¬(¬A)) →A)
....
(5) (¬(¬A)) →((¬(¬A)) →A)
HS( , )
(6) ((¬(¬A)) →((¬(¬A)) →A)) →
(((¬(¬A)) →(¬(¬A))) →((¬(¬A) →A)))
P2
(7) ((¬(¬A)) →(¬(¬A))) →((¬(¬A)) →A)
MP( , )
(8) ((¬(¬A)) →(((¬(¬A)) →(¬(¬A))) →(¬(¬A)))) →(((¬(¬A)) →
((¬(¬A)) →(¬(¬A)))) →((¬(¬A)) →(¬(¬A))))
P2
(9) (¬(¬A)) →(((¬(¬A)) →(¬(¬A))) →(¬(¬A)))
....
(10) ((¬(¬A)) →((¬(¬A)) →(¬(¬A)))) →
((¬(¬A)) →(¬(¬A)))
MP( , )
44

(11) (¬(¬A)) →((¬(¬A)) →(¬(¬A)))
....
(12) (¬(¬A)) →(¬(¬A))
....
(13) (¬(¬A)) →A
MP( , )
EXERCISES 2.11
(1) Rewrite the proof of ⊢(¬(¬A)) →A as it appears in example 2.11.2 ﬁlling in the missing reasons. Some
may be examples.
(2) Give formal proofs of the next two theorems. You may use any previously established ⊢, or method. You
must state all your reasons.
(a) ⊢A →(¬(¬A)).
(b) ⊢(¬B) →(B →A).
2.12 Demonstrations, Deductions From Premises.
Given a nonempty set premises Γ (not necessarily ﬁnite), then what is the classical procedure employed
to deduce a formula A from Γ? Actually, we are only allowed to do a little bit more than we are allowed
to do in order to give a proof of a formal theorem. The next deﬁnition gives the one additional rule that
is assumed to be adjoined to deﬁnition 2.11.2 (formal proof of a theorem) in order to demonstrate that a
formula is deducible from a given set of premises.
Deﬁnition 2.12.1 (Deduction from premises.) A formula B ∈L′ is said to be deduced from a set of Γ
or a consequence of Γ, where Γ is a not necessary ﬁnite (but possibly empty) set of premises, if B is the last
step in a FINITE column of steps and reasons as described in deﬁnition 2.11.2 where you are allowed one
additional rule.
(1) You may write down as any step a single instance of a formula as it appears in Γ, where the premises
are written in formula variable form. The reason given is premise.
(2) The ﬁnite column with reasons is called a demonstration.
Observe that whenever we have written a demonstration, because of the use of variables, we have actually
written inﬁnitely many demonstrations. Deduction from a set of premises is what one usually considers when
one uses the terminology “a logical argument.” Now a proof of a theorem is a demonstration from an empty
set of premises. When B is deduced from the set Γ, then this is symbolized by writing Γ ⊢B. The very
straightforward deﬁnition 2.12.1 yields the following simple results.
Theorem 2.12.1 Assume that Γ is any set of formula.
(a) If A ∈Γ, or A is an instance of an axiom, then Γ ⊢A.
(b) If Γ ⊢A and Γ ⊢A →B, then Γ ⊢B.
(c) If ⊢A, then Γ ⊢A.
(d) If Γ is empty and Γ ⊢A, then ⊢A.
(e) If Γ ⊢A and D is any set of formula, then Γ ∪D ⊢A.
(f) If Γ ⊢A, then there exists some ﬁnite subset D of Γ such that D ⊢A.
Proof. (A) Let A ∈Γ. Then one step consisting of the line “(1) A. . . . . . . Premises” is a demonstration
for A. If A is an axiom, then one step from deﬁnition 2.11.2 yields a demonstration.
45

(b) Let B1, . . . , Bm be the steps in a demonstration that A is deducible from Γ. Then Bm = A. Let
C1, . . . , Ck be a demonstration that A →B is deducible from Γ. Now after writing the steps Bm+i = C1, i =
1, 2, . . . , k add the step Ck+1 : B. . . . . . . MP(m, m + k). Then this yields a demonstration that B is
deducible from Γ.
(c) Obvious.
(d) Since Γ is empty, rule (1) of deﬁnition 2.11.2 has no application. Hence, only the rules for a proof
of a formal theorem have been used and this result follows.
(e) We have, possibly, used formulas from Γ to deduce A. We have, possibly, used formulas from Γ ∪D
to deduce A.
(f) Assume that Γ ⊢A. Now let D be the set of all premises that have been utilized as a speciﬁc step
marked “premise” that appears in the demonstration Γ ⊢A. Obviously, we may replace Γ with D and have
not altered the demonstration.
Example 2.12.1 To show that (¬(¬A)) ⊢A.
(1) (¬(¬A))
Premise
(2) (¬(¬A)) →((¬(¬(¬(¬A)))) →(¬(¬A)))
.....
(3) (¬(¬(¬(¬A)))) →(¬(¬A))
MP( , )
(4) ((¬(¬(¬(¬A)))) →(¬(¬A))) →((¬A) →(¬(¬(¬A))))
.....
(5) (¬A) →(¬(¬(¬A)))
MP( , )
(6) ((¬A) →(¬(¬(¬A)))) →((¬(¬A)) →A)
.....
(7) (¬(¬A)) →A
MP( , )
(8) A
MP( , )
Notice that example 2.12.1 and example 2.11.3 show that ⊢(¬(¬A)) →A involve similar formulas.
Moreover, we have not used HS in example 2.12.1. Indeed, if we had actually made the HS substitution into
steps of example 2.11.3, then we would have at the least 21 steps in example 2.11.3. Even though we have
not considered as yet any possibilities that the semantical methods which have previously been employed
might be equivalent in some sense to the pure proof methods of this and section 2.11, it would certainly be of
considerable signiﬁcance if there was some kind of deduction theorem for our proof theory. We can wonder
if it might be possible to substitute for |= in the metatheorem |= (¬(¬A)) →A if and only if (¬(¬A)) |= A
the symbol ⊢? Further, it’s possible to stop at this point and, after a lot of formal work, introduce you to
the actual type of deduction process used to create a universe. But to avoid the formal proofs of the needed
special formal theorems, I’m delaying this introduction until we develop the complete equivalence of valid
formulas and formal theorems. I’ll answer the previous question by establishing one of the most powerful
procedures used to show this equivalence.
EXERCISES 2.12
(1) Rewrite example 2.12.1 ﬁlling in the missing reasons.
(2) Complete the following deductions from the indicated set of premises. Write down the missing steps
and/or reasons.
Show that A →B, B →C ⊢A →C.
(1) (B →C) →(A →(B →C))
P1
(2) B →C
.....
(3)
MP(1, 2)
(4) (A →(B →C)) →((A →B) →(A →C))
.....
(5) (A →B) →(A →C)
.....
46

(6)
Premises
(7) A →C
.....
(b) Use 2(b) of exercise 2.11, to show in THREE steps that (¬A) ⊢A →B.
(c) Use the fact that ⊢(B →A) →((¬A) →(¬B)) and any previous results to show that ¬(A →B) ⊢B →
A.
(1) ¬(A →B)
Premise
(2) ⊢(B →(A →B)) →((¬(A →B)) →(¬B))
Given
(3)
P1
(4)
.....
(5) (¬B)
.....
(6) (¬B) →(B →A)
.....
(7) B →A
.....
2.13 The Deduction Theorem.
The Deduction Theorem is so vital to logic that some mathematicians, such as Tarski, use it as a basic
axiom for diﬀerent logical systems. The following metaproof was ﬁrst presented in 1930 and it has been
simpliﬁed by your present author. This simpliﬁcation allows it to be extended easily to cover other types of
logical systems. What this theorem does is to give you a step by step process to change a formal proof into
another formal proof.
Theorem 2.13.1 (The Deduction Theorem) Let Γ a collection of formula from L′ written in formula
variable form. Assume that formula variables A, B represent arbitrary members of L′. Let Γ ∪{A} be the
set of premises the contains and only contains the members of Γ and A. Then Γ ∪{A} ⊢B if and only if
Γ ⊢A →B.
Proof. For the necessity, assume that Γ ∪{A} ⊢B. Then there exists a ﬁnite A1, . . . , An ∈Γ such that
A1, . . . , An, A ⊢B. (Of course no actual member of A1, . . . , An need to be used.) Assume that every step
has been written with the reasons as either a premise, or an axiom, or MP.
(a) Renumber, say in red, all of the steps that have reasons stated as premises or axioms. Assume that
there are k such steps. Note that there must be at least three steps for MP to be a reason, and then it could
only occur in step 3. We now construct a new demonstration.
Case (m = 1). There is only one case. Let the formula be B1. Hence, B1 = B.
Subcase (1). Let B1 be a premise Aj. Assume that Aj ̸= A. Now keep B1 = Aj in the new
demonstration and insert the two indicated steps (2) (3).
(1) B1 = Aj
premise
(2) Aj →(A →Aj)
P1
(3) A →Aj = A →B
MP
Now notice that the A, in these three steps does not appear as a single formula in a step.
Subcase (2). Assume that B1 = A. Then insert the ﬁve steps that yields ⊢A →A (Example
2.11.1.) into the new demonstration. Now do not place the step B1 = A in the new demonstration. Again
we have as the last step A →A and A does not appear as any step for in this new demonstration.
Subcase (3). Let B1 = C be any axiom. Simply repeat subcases (1) (2) and we have as a last
step A →C and A does not appear in any step.
47

Now we do the remaining by induction. Suppose that you have used m of the original renumbered steps
to thus far construct the new demonstration. Now consider step number Bm+1. Well, just apply the same
subcase procedures that are used under case m = 1. The actual induction hypothesis is vacuously employed
(i.e. not employed). Thus by induction, for any k steps we have found a way to use all non-MP steps of
the original demonstration to construct a new demonstration in such a manner that no step in the new
demonstration has, thus far, only A as its formula. Further, all original non-MP steps Bi are replaced in the
new demonstration by A →Bi. Thus if the last formula Bn in the original demonstration is a non-MP step,
then Bn = B, and the last step in the new demonstration is A →B. We must now use the original MP steps
to continue the new demonstration construction since A might be in the original demonstration an MP step
or the last step of the original demonstration might be an MP step.
After using all of the original non-MP steps, we now renumber, for reference, all the original MP steps.
We now deﬁne by induction on the number m of MP steps a procedure which will complete our proof.
Case (m = 1) We have that there is only one application of MP. Let Bj be this original MP step.
Then two of the original previous steps in the original demonstration, say Bg and Bh, were employed and
Bh = Bg →Bj. We have, however, in the new demonstration used these to construct the formula and we
have not used the original Bj step. Now use the two new steps (i) A →Bg, and (ii) A →(Bg →Bj) and
insert immediately after new step (ii) the following:
(iii) (A →(Bg →Bj)) →((A →Bg) →(A →Bj))
P2
(iv) (A →Bg) →(A →Bj)
MP(ii, iii)
(v) A →Bj
MP(i, iv)
Now do not include the original Bj in the new demonstration just as in case where Bj = A.
Assume the induction hypothesis that we have m of the original MP steps used in the original demon-
stration now altered so that the appear as A →. . ..
Case (m + 1). Consider MP original step Bm+1. Hence, prior steps in the old demonstration, say
Bg, Bh = Bg →Bm+1 are utilized to obtain the Bm+1 formula. However, all the original steps up to
but not including the Bm+1 have been replaced by a new step in our new demonstration in such a manner
they now look like (vi) A →Bg and (viii) A →(Bg →Bm+1) no matter how these step were originally
obtained. (The induction hypothesis is necessary at this point.) Now follow the exact same insertion process
as in the case m = 1. This yields a new step A →Bm+1 constructed from the original Bm+1. Consequently, by
induction, we have deﬁned a procedure by which all the original steps Bk have been used to construct a new
demonstration and if Bn was one of the original formula, then it now appears in the new demonstration as
A →Bn. Further, no step in the new demonstration is the single formula A. This yields a newly constructed
demonstration that A1, . . . , An ⊢A →B.
For the suﬃciency, assume that Γ ⊢A →B. The ﬁnal step is Bk = A →B. Now add the following two
steps. Bk+1 = A (premises), and Bk+1 = B, MP(k, k + 1). This yields Γ ∪{A} ⊢B.
Corollary 2.13.1.1 A1, . . . , An ⊢B if and only if ⊢(A1 →(A2 →· · · (An →B) · · ·)).
Now in the example on the next page, I follow the rules laid out within the proof of the Deduction
Theorem. The formula from the original demonstration used as a step in the new construction are represented
in roman type. Formula from the original demonstration used to obtain the new steps BUT not included
in the new demonstration are in Roman Type, BUT are placed between square brackets [
]. In the case
⊢A →A, I will not include all the steps.
Example 2.13.1
(I) A →B, B →C, A ⊢C.
48

(1) A →B
Premise
(2) B →C
Premise
(3) A
Premise
(4) B
MP(1, 3)
(5) C
MP(2, 4)
We now construct from (I) a new demonstration that
(II) A →B, B →C, ⊢A →C.
(1) A →B
Premise
(2) (A →B) →(A →(A →B))
P1
(3) A →(A →B)
MP(1, 2)
(4) B →C
Premise
(5) (B →C) →(A →(B →C))
P1
(6) A →(B →C)
MP(4, 5)
(7) ⊢A →A
Example 2.11.1
[Bg = A, Bj = B]
(8) (A →(A →B)) →((A →A) →(A →B))
P2
(9) (A →A) →(A →B)
MP(3, 8)
(10) A →B
MP(7, 9)
[Bg = B, Bj = C]
(11) (A →(B →C)) →((A →B) →(A →C))
P2
(12) (A →B) →(A →C)
MP(6, 11)
(13) A →C
MP(10, 12)
I hope this example is suﬃcient. But note that although this gives a demonstration, it need not give
the most eﬃcient demonstration.
EXERCISES 2.13
1. Give a reason why we should NOT use the Deduction theorem as a reason that from A ⊢A, we have
⊢A →A.
2. Complete the following formal proofs of the indicated theorems by application of the Deduction Theorem
in order to insert premises. You will also need to insert, in the usual manner, possible ⊢statements obtained
previously. Please give reasons.
(A) Show that ⊢(B →A) →((¬A) →(¬B))
(1) B →A
Premise and D. Thm.
(2) ⊢(· · · · · ·) →B
Ex. 2.12.1 and D. Thm.
(3) (¬(¬B)) →A
HS( , )
(4)
(5) (¬(¬B)) →(¬(¬A))
.....
(6) ((¬(¬B)) →(· · · · · ·)) →((¬A) →(¬B))
.....
(7) · · · · · · · · ·
.....
(8) · · · · · · · · ·
D. Thm.
(B) Show that ⊢((A →B) →A) →A
(1) (A →B) →A
.....
49

(2) · · · · · · · · ·
D.Thm. and Ex 2.12.2b
(3) (¬A) →A
.....
(4) (¬A) →(¬(¬((¬A) →A)) →(¬A))
....
(5) (¬(¬((¬A) →A)) →(¬A)) →· · ·
P3
(6) (¬A) →(A →· · · ((¬A) →· · · · · ·))
.....
(7) ((¬A) →(A →(¬((¬A) →A)))) →(((¬A) →A) →
((¬A) →(¬((¬A) →A))))
.....
(8) · · · · · · · · ·
MP( , )
(9) · · · · · · · · ·
MP(3, 8)
(10) ((¬A) →(¬(· · · · · ·))) →(((¬A) →· · ·) →· · · · · ·)
P3
(11) · · · · · · · · ·
MP( , )
(12) A
.....
(13) ⊢· · · · · · · · ·
D. Thm.
[3] Use the following demonstration that A →B, A ⊢B and construct, as in example 2.13.1, by use of the
procedures within the metaproof of the Deduction Theorem a formal demonstration that A →B ⊢A →B.
[It’s obvious that this will not give the most eﬃcient demonstration.]
A →B, A ⊢B
(1) A
Premise
(2) A →B
Premise
(3) B
MP(1, 2)
2.14 Deducibility Relations or |= implies ⊢almost.
The Deduction Theorem for formal demonstrations seems to imply that the semantical concept of |=
and the proof-theoretic concept of ⊢are closely related for they share many of the same propositional facts.
In this section, we begin the study which will establish exactly how these two seeming distinct concepts
are related. Keep in mind, however, that |= depends upon the mirroring of the classical truth-falsity, will
occur-won’t occur notion while ⊢is dependent entirely upon the strict formalistic manipulation of formulas.
We are in need of two more formal proofs.
Example 2.14.1 ⊢A →((A →B) →B).
(1) A
Premise
(2) A →B
Premise
(3) B
MP(1, 2)
(4) ⊢A →((A →B) →B)
D. Thm.
Example 2.14.2 ⊢A →((¬B) →(¬(A →B))).
(1) ⊢A →((A →B) →B)
Ex. 2.14.1
(2) ((A →B) →B) →((¬B) →(¬(A →B)))
Exer. 2.13 (A)
(3) A →((¬B) →(¬(A →B)))
HS(1, 2)
The theorem we will need is that of Example 2.14.2. As done previously, the formal proofs or demon-
strations are done in formula variables. They hold for any formula consistently substituted for the variables.
In the semantics sections, most but not all deduction-type concepts such as validity and valid consequences
50

also hold for formula variables. Non-validity was a notion that did not hold in formula variable form. In
what follows, we again assume that we are working in formula variables. Of course, they also hold for atoms
substituted for these variables. We use the notation for formula variables. Let A be a formula written in the
following manner. The formula variables A1, . . . , An and only these formula variables are used to construct
A with the L′ propositional connectives ¬, →. Thus A is written in formula variables. Since L′ ⊂L, the
truth-table concept can be applied to L′. Now let a be an assignment to the atoms that would appear in
each Ai, i = 1, . . . , n when speciﬁc formula are substituted for the formula variables.
Deﬁnition 2.14.1 For each i, we deﬁne a formula A′
i as follows:
(i) if v(Ai) = T, then A′
i = Ai.
(ii) If v(Ai) = F, then A′
i = (¬Ai).
(iii) If v(A) = T, then A′ = A.
(iv) If v(A) = F, then A′ = (¬A).
In the truth-table for A, reading from left to right, you have all the atoms then the formula Ai and
ﬁnally the formula A. Then we calculate the A truth-value from the Ai, with possibly additional columns if
needed.
Deﬁnition 2.14.2 (Deducibility relations.) For each row j of the truth-table, there are truth-values for
each of the Ai and A. These generate the formula A′
i and A′, where the Ai are the formula that comprise A.
(i) The jth Deducibility relation is A′
1, . . . , A′
i ⊢A′.
Theorem 2.14.1. Given A1, . . . , An and A as deﬁned above. Then for any row of the corresponding
truth-table for A generated by the truth-values for A1, . . . , An, we have that A′
1, . . . , A′
n ⊢A′.
Proof. First, assume that each Ai is an atom and A is expressed in atomic form.
This allows for
induction and for all the possible truth-values for non-atomic Ai. We now do an induction proof on the size
of A.
Let size(A) = 0. The A = Ai for some i (possible more than one). As we know A1, . . . An ⊢Ai for any
i, i = 1, . . . , n. Thus the result follows by leaving the original Ai or replacing it with ¬Ai as the case may
be.
Assume the induction hypotheses (in strong form) that the result holds for any formula A of size ≤m
where m > 0. Let size(A) = m + 1.
There are two cases. (i) The formula A = ¬B, or case (ii) A = B →C, where size(B), size(C) ≤m.
Note that by the induction hypothesis if q1, . . . , qk are the atoms in B, then q′
1, . . . , q′
k ⊢B′. But adding
any other ﬁnite set of atoms does not change this statement.
Hence, A′
1, . . . , A′
n ⊢B′. In like manner,
A′
1, . . . , A′
n ⊢C′.
Case (i). Let A = (¬B) Then (a), suppose that v(B) = T. Then B′ = B and v(A) = F. Hence, A′ =
(¬A) = (¬(¬B)). To the demonstration that A′
1, . . . , A′
n ⊢B′ = B adjoin the proof that ⊢B →(¬(¬B)).
Then consider one MP step. This yields the formula (¬(¬B)) = A′. Consequently, A′
1, . . . , A′
n ⊢A′.
Subcase (b). Let v(B) = F. Then v(A) = T yields that A = A′. Hence, A′
1, . . . , A′
n ⊢B′ = (¬B) = A =
A′.
For case (ii), let (a), v(C) = T. Thus v(A) = T and C′ = C, A′ = B →C. Hence, A′
1, . . . , A′
n ⊢C. Now
add the steps ⊢C →(B →C) and MP yields B →C. Consequently, A′
1, . . . , A′
n ⊢B →C = A′.
Now, let (b) v(B) = F. Then v(A) = T, B′ = (¬B), A′ = A = B →C. Then consider A′
1, . . . , A′
n ⊢
B′ = (¬B) and adjoin to this proof the proof of ⊢(¬B) →(B →C). (Exercise 2.12.2b) Then MP yields
A′
1, . . . , A′
n ⊢B →C = A′.
51

Next part (c) requires v(B) = T, v(C) = F. Then v(A) = F, B′ = B, C′ = (¬C), A′ = (¬A) = (¬(B →
C)). Using both demonstrations for A′
1, . . . , A′
n ⊢B′ and for A′
1, . . . , A′
n ⊢C′ and the result of Example
2.14.2 that ⊢B →((¬C) →(¬(B →C))), two applications of MP yields A′
1, . . . , A′
n ⊢(¬(B →C)) = A′. By
induction, the proof is complete for atomic Ai. Note that the * substitution process holds if done throughout
each step of the formal proof. Applying this process, the result holds in general.
Examples 2.14.3 Let A = B →(¬C). Then
B
C
A
T
T
F
T
F
T
F
T
T
F
F
T
Deducibility relations
(a) B, C ⊢(¬(B →(¬C))),
(b) B, (¬C) ⊢B →(¬C),
(c) (¬B), C ⊢B →(¬C),
(d) (¬B), (¬C) ⊢B →(¬C).
EXERCISES 2.14
1. For the following formula, write as in my example all of the possible deducibility relations.
(a) A = (¬B) →(¬C). (b) A = B →C. (c) A = B →(C →B). (d) A = B →(¬(C →D)).
2.15 The Completeness Theorem.
One of our major goals is now at hand. We wish to show that |= and that ⊢mean the same thing. As
I mentioned, I’m presenting only the necessary formal theorems that will establish this fact. We need just
one more. This will be example 2.15.4. We’ll do this in a few small steps.
Example 2.15.1
(¬A) →A, (¬A) ⊢B or ⊢((¬A) →A) →((¬A) →B).
(1) (¬A) →A
Premise
(2) (¬A)
Premise
(3) A
MP(1, 2)
(4) ⊢(¬A) →(A →B)
Exer. 2.11 (2b)
(5) A →B
MP(2, 4)
(6) B
MP(3, 6)
Example 2.15.2
B →C ⊢(¬(¬B)) →C or ⊢(B →C) →((¬(¬B)) →C)
(1) B →C
Premise
(2) (¬(¬B)) →B
Exam. 2.11.3
52

(3) (¬(¬B)) →C
HS(1, 2)
Example 2.15.3
(¬A) →A ⊢A or ⊢((¬A) →A) →A
(1) (¬A) →((A →A) →(¬A))
P1
(2) ((¬(¬(A →A)) →(¬A)) →(¬A)) →(A →(¬(A →A)))
P3
(3) ⊢((A →A) →(¬A)) →(¬(¬(A →A)) →(¬A)))
Exam. 2.15.2
(4) ((A →A) →(¬A)) →(A →(¬(A →A)))
HS(3, 2)
((5) (¬A) →(A →(¬(A →A)))
HS(1, 4)
(6) ⊢((¬A) →A) →((¬A) →(¬(A →A)))
Exam. 2.15.1
(7) (¬A) →A
Premise
(8) (¬A) →(¬(A →A))
MP(6, 7)
(9) ((¬A) →(¬(A →A))) →((A →A) →A)
P3
(10) (A →A) →A
MP(8, 9)
(11) ⊢A →A
Exam. 2.11.1
(12) A
MP(10, 11)
Example 2.15.4
A →B, (¬A) →B ⊢B or ⊢(A →B) →(((¬A) →B) →B)
(1) A →B
Premise
(2) (¬A) →B
Premise
(3) ⊢B →(¬(¬B))
Exer. 2.11. 2(a)
(4) (¬A) →(¬(¬B))
HS(2, 3)
(5) ((¬A) →(¬(¬B))) →((¬B) →A)
P3
(6) (¬B) →A
MP(4, 5)
(7) (¬B) →B
HS(6, 1)
(8) ((¬B) →B) →B
Exam. 2.15.3
(9) B
MP(7, 8
The next two results completely relate |= and ⊢.
Theorem 2.15.1 (Completeness Theorem) If A ∈L′ and |= A (in L), then ⊢A.
Proof. Note that L′ ⊂L. Now assume A ∈L′ and |= A. We use an illustration that shows exactly
how an explicit proof for ⊢A can be constructed. The process is a reduction process and this illustration
can be easily extended to a formally stated reduction processes.
Let P1, P2, P3 be the atoms in A and
T = ⊢(Pi →B) →(((¬Pi) →B) →B). The ordering of the construction process is 0, followed by 1, then
2, then 3 and ﬁnally followed by 4. First, write done the formal steps that lead to each of the following
deducibility relations and then construct, in each case using the Deduction Theorem, the forms 0.
(1) P1, P2, P3 ⊢A D.Thm
⇒
0 ⊢P1 →(P2 →(P3 →A))
(2) P1, P2, ¬P3 ⊢A D.Thm
⇒
0 ⊢P1 →(P2 →((¬P3) →A))
(3) P1, ¬P2, P3 ⊢A D.Thm
⇒
0 ⊢P1 →((¬P2) →(P3 →A))
53

(4) P1, ¬P2, ¬P3 ⊢A D.Thm
⇒
0 ⊢P1 →((¬P2) →((¬P3) →A))
(5) ¬P1, P2, P3 ⊢A D.Thm
⇒
0 ⊢(¬P1) →(P2 →(P3 →A))
(6) ¬P1, P2, ¬P3 ⊢A D.Thm
⇒
0 ⊢(¬P1) →(P2 →((¬P3) →A))
(7) ¬P1, ¬P2, P3 ⊢A D.Thm
⇒
0 ⊢(¬P1) →((¬P2) →(P3 →A))
(8) ¬P1, ¬P2, ¬P3 ⊢A D.Thm
⇒
0 ⊢(¬P1) →((¬P2) →((¬P3) →A))
1 Using (1) (5), insert T , MP, MP (a) ⇒⊢P2 →(P3 →A)
1 Using (2) (6), insert T , MP, MP (b) ⇒⊢P2 →((¬P3) →A))
1 Using (3) (7), insert T , MP, MP (c) ⇒⊢(¬P2) →(P3 →A)
1 Using (4) (8), insert T , MP, MP (d) ⇒⊢(¬P2) →((¬P3) →A))
2 Using (a) (c), insert T , MP, MP (e) ⇒⊢P3 →A
2 Using (b) (d), insert T , MP, MP (f) ⇒⊢(¬P3) →A
3 Using (e) (f), insert T , MP, MP ⇒⊢A
Using this illustration, it follows that if P1, P2, . . . , Pk are the atoms in A and we let P0 = A, then,
using the 2k deducibility relations to obtain the combined steps that yield the statements 0, each of the
steps of the form j ≤k, will reduce the problem, by including additional steps, to one where only the forms
⊢P ′
k−j →(· · · (P ′
k →P0) · · ·) occur. In this case, each P ′
m, j ≤m ≤k, will be either a Pm or a ¬Pm and
reading from left-to-right will be, for each row of a standard truth table, the same forms P ′
k−j, . . . , P ′
k as
constructed by Deﬁnition 2.14.2. After k applications of this process we have a formal proof, without any
need for the insertion of premises, that has the last step P0 = A.
Theorem 2.15.2 (Soundness Theorem) If A ∈L′ and ⊢A, then |= A.
Proof. Note that each instance of the axioms P1, P2, P3 is a valid formula. Also, we have that |= A
and |= A →B, then |= B. Thus at each step in the proof of for ⊢A, we can insert correctly to the left of
the formula the symbol |= . Since the last step in the proof is A, then we can correctly write |= A.
Corollary 2.15.2.1 Let {A1, . . . , An, A} ⊂L′. Then A1, . . . , An ⊢A if and only if A1, . . . , An |= A.
Proof. By repeated application of deduction theorem and theorem 2.8.1 (a).
Due to these last two theorems, we can identify the connectives which we have used in L but not in L′
with equivalent formula from L′. Hence deﬁne A ∨B by (¬A) →B, A ∧B by (¬(A →(¬B))) and A ↔B
by (A →B) ∧(B →A).
There is a slight diﬀerence between the concept for L′ we denote by Γ ⊢A and the concept Γ =
{A1, . . . , An} |= A. The concept Γ ⊢A includes the possibility that Γ is inﬁnite not just ﬁnite. Shortly,
we’ll be able to extend Γ |= A to the possibility that Γ is inﬁnite. Before we do this however, I can, at last,
introduce you to the very ﬁrst basic steps in the generation of a logical operator that mirrors a physical-like
process that will create universes.
2.16 Consequence Operators
In set theory, if you are given a set of anything A, like a set of formula from L′, then another set is
very easily generated. The set is denoted by P(A). This set is the set of all subsets of A. In the ﬁnite
case, suppose that A = {a, b, c}. Letting ∅denote the empty set, then the set of all subsets of A is P(A) =
{∅, A, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}}. Notice that this set has 8 members. Indeed, if any set has n members,
then P(A) has 2n members. Obviously, if A is not ﬁnite, then P(A) is not ﬁnite.
54

Most logical processes, like ⊢, satisfy a very basic set of process axioms. Notice that you can consider
Γ ⊢B as a type of function. First, the entire process that yields a demonstration is done upon subsets of
A. When the subset is ∅, you get a formal theorem. The set of ALL theorems or deductions from a give
Γ is a subset of A. Let ∆denote the set of all the deductions that can be obtained from Γ by our entire
deductive process. Then can we get anything new B ̸∈∆by considering the premises Γ ∪∆? Well, suppose
we can and, of course, B is not a theorem. Then there is a ﬁnite set of formula from either Γ or ∆that is
used in the demonstration. Suppose that from ∆you have D1, . . . , Dm, where we may assume that these
are not theorems and they are used in the proof. But each of these comes from a proof using members from
Γ. So, just substitute for each occurrence of Di its proof. Then you have a proof of B using only members
of Γ. Thus you cannot get any more deductions by adjoining the set of all deductions to the original set of
premises.
So, what have we determined about the ⊢process?
Well, to express what we have learned
mathematically, consider a function C with the domain the set of all premises. But, this is just P(L′).
Then the codomain, the set of all deductions ∆is also a subset of P(L′).
(1) C has as its domain P(L′) and its range is contained in P(L′).
(2) Since a one step demonstration yields a premise, then for each B ∈P(L′), B ⊂C(B).
(3) From the above discussion, for each B ∈P(L′), C(C(B)) = C(B).
(4) Theorem 2.12.1 (f) or our above discussion states that if B ∈C(A) then there exists a ﬁnite subset
D of A such that B ∈C(D).
Any function that satisﬁes, (1), (2), (3), (4) is called a consequence operator. The important thing to
know is that ⊢can be replace by such a consequence operator with additional axioms. For example, (5) for
each A, B, C ∈L′, the set of all P1, the set of all P2, and the set of all P3 form the set C(∅). Then (6) for
each A ∈P(L′), if A, A →B ∈C(A), then B ∈C(A).
What mirrors the physical-like behavior that creates a universe are very special type of consequence
operators, one of which is denoted by
∗S. Operator
∗S is basically determined by a very simple logical
process S.
It’s basis uses our description for ⊢including (6) (our MP). But a diﬀerent set of axioms.
These axioms are actually four very simple theorems from the language L′ with the deﬁnition for ∧. The
completeness theorem tells us that they are theorems in P(L′). Speciﬁcally, they are
(1) (A ∧(B ∧C)) →((A ∧B) ∧C).
(2) ((A ∧B) ∧C) →(A ∧(B ∧C)).
(3) (A ∧B) →A.
(4) (A ∧B) →B.
It turns out that every know propositional deduction used throughout all the physical sciences, if they
are diﬀerent from the one we are studying, have (1) – (4) as theorems.
Consequence operator S, can be generated by the consequence operators Sn, where the only diﬀerence
between S and Sn is that for Sn the MP step is restricted to level L′
n. Although for A ∈P(L′) if A ∈S(A)
there exists some n such that A ∈Sn(A), it is also true that for each n ≥3 Sn(A) ⊂S(A) and Sn(A) ̸= S(A).
When a consequence operator like Sn has this property then S said to be stronger than Sn.
Now I can’t go any further in discussing the very special consequence operator that generates a universe.
Why? Since the language L′ and the deductive process ⊢must be greatly expanded so that it is more
expressive. Indeed, so that we can express almost everything within mathematics with our language. But,
55

after we have done this, then in the very last section of this book, I’ll be able to show the mathematical
existence of, at the least, one of these universe generating consequence operators.
EXERCISE 2.16
In the following, let C be a consequence operator deﬁned on P(L)′. See is you can give an argument that
establishes the following additional consequence properties based, originally, upon the axioms.
1. Let A, B be two sets of premises taken from L′. Suppose that A ⊂B. Show that C(A) ⊂C(B).
2. Recall that A ∪B, the “union” set, is the set of all formula a formula A ∈A ∪B if and only if A ∈A or
A ∈B. Suppose that A ∪B ⊂L′. Show that A ⊂C(B) if and only if C(A) ⊂C(B).
3. Suppose that A ∪B ⊂L′. Show that C(A ∪B) = C(A ∪C(B)) = C(C(A ∪C(B)).
Some other properties of idempotent operators.
We use the consequence operator as our prototype. Recall that an operator C (function, map, etc.) is
idempotent if for each X ∈P(L), C(C(X)) = C(X).
Let S1 = {C(X) | X ∈P(L)}, S2 = {Y | Y = C(Y ) ∈P(L)}.
Theorem 1. The sets S1 = S2.
Proof. Let Y = C(X) ∈S1. Then Y ∈P(L) and Y = C(C(X)) = C(Y ). Thus Y ∈S2.
Conversely, let Y = C(Y ) ∈P(L). Then Y ∈S1. Hence, S1 = S2.
We can ask if C(X1) = C(X2), does this matter? The answer is no since if Y = C(X1) = C(X2) =
C(C(X1)) = C(C(X2)) = C(Y ) ∈S2. There is a signiﬁcant uniﬁcation U for any collection of physical
theories The deﬁnition of U required that we consider the set {Y | X ⊂Y = C1(Y ) = C2(Y )}.
Note the identity map I(X) = X for each X ∈P(L) is idempotent. (Indeed, a consequence operator if
we are considering only these objects.) So, one can inquire as to when a given C has an inverse C←= C−1.
As usual C−1 is an inverse if C−1(C(X)) = I(X).
Theorem 2. The idempotent operator C has an inverse if and only if C = I.
Proof.
Suppose that idempotent C has an inverse C−1. Then for each X ∈P(L), X = I(X) =
(C−1C)(X) = C−1(C(X)) = C−1(C(C(X))) = (C−1C)(C(X)) = I(C(X)) = C(X). Thus, from the deﬁni-
tion of the identity operator, C = I.
Corollary 2.1. The only idempotent operator C that is one-to-one is the identity.
This corollary is an interesting result for consequence operators since all science-community the-
ories are generated by logic-systems which generate corresponding consequence operators.
(You can
ﬁnd the deﬁnition of a logic-system in my published paper “Hyperﬁnite and standard uniﬁcations for
physics theories,” Internat.
J. Math.
Math.
Sci, 28(2)(2001), 17-36 with an archived version at
http://www.arxiv.org/abs/physics/0105012). So, for a the logic system used by any science-community,
there are always two distinct sets of hypotheses X1, X2 such that C(X1) = C(X2).
Another example of idempotent operators are some matrices. Can we apply these notions to functions
that take real or complex numbers and yield real or complex numbers? There is a result that states that
the only non-constant idempotent linear real valued function deﬁned on, at least, [b, d], b, 0, d > 0 and
continuous at c ∈(b, d) is f(x) = x. Can you “prove” this? It also turns out in this case that if you want
this identity form (i.e. f(x) = x), then continuity at some x = c is necessary. In fact under the axiom of
set theory called The Axiom of Choice, there is a function deﬁned on all the reals that has either a rational
56

value or is equal to zero for each x, is, clearly, not constant, is linear, idempotent and not continuous for any
real x. This makes it somewhat diﬃcult to “graph.”
2.17 The Compactness Theorem.
With respect to ⊢, consistency is deﬁned in the same manner as it was done for |=. We will use the
deﬁned connectives ∧, ∨, ↔.
Deﬁnition 2.17.1 (Formal consistency.) A nonempty set of premises Γ is formally consistent if there
does not exist a formula B ∈L′ such that Γ ⊢B ∧(¬B).
For ﬁnite sets of premises Γ the Completeness and Soundness Theorems show that deﬁnition 2.17.1 is
equivalent to consistency for |= . In the case of a set of ﬁnitely many premises, then all of the consistency
results relative to |= can be transferred. But, what do we do when Γ is an inﬁnite set of premises?
Well, we have used the assignment concept for ﬁnitely many premises. We then used the symbolism
v(A, a) for the truth-value for A and the assignment to a ﬁnite set of atoms that includes the atoms in A.
But if you check the proof in the appendix that such assignments exist in general, you’ll ﬁnd out that we
have actually deﬁne a truth-value function on all the formula in L. It was done in such a manner, that it
preserved all of the truth-value properties required for our connectives for L. Obviously, we could reduce the
number of connectives and we would still be able to construct a function v that has a truth-value for each of
the inﬁnitely many atoms and preserves the truth-value requirements for the connectives ¬ and →. What
has been proved in the appendix is summarized in the following rule.
Truth-value Rule. There exist truth-value functions, v, deﬁned for each A ∈L′ such that for each
atom A ∈L′:
(a) v(A) = T or v(A) = F not both.
(b) For any A ∈L′, v(A) = T if and only if v(¬A) = F.
(c) For any A, B ∈L′, v(A →B) = F if and only if v(A) = T and v(B) = F.
(d) A truth-value function v will be called a valuation function and any such function is unique in the
following sense. Suppose f and v are two functions that satisfy (a) and for each P ∈L0 f(P) = v(P). Then
if (b) and (c) hold for both f and v, then f = v.
Because of part (d) of the above rule, there are many diﬀerent valuation functions. Just consider a
diﬀerent truth-value for some of the atoms in L0 and you have a diﬀerent valuation function.
In what
follows, we let E be the set of all valuation functions.
Deﬁnition 2.17.2 (Satisfaction)
(a) Let Γ ⊂L′. If there exists a v ∈E such that for each A ∈Γ, v(A) = T, then Γ is satisﬁable.
(b) A formula B ∈L′ is a valid consequence of Γ if for every v ∈E such that for each A ∈Γ v(A) = T,
then v(B) = T.
It’s obvious that for ﬁnite sets of premises the deﬁnition 2.17.2 is the same as our previous deﬁnition
(except for a simpler language). Thus we use the same symbol |= when deﬁnition 2.17.2 holds. The proofs
of metatheorems for this extended concept of truth-values are slightly diﬀerent than those for the ﬁnite case
of assignments. Indeed, it would probably have been better to have started with this valuation process and
not to have considered the ﬁnite assignment case. But, the reason I did not do this was to give you a lot a
practice with the basic concepts within elementary mathematical logic so as to build up a certain amount
of intuition. In all that follows, all of our formula variables are considered to be formula in L′. I remind
you, that all of our previous results that used assignments hold for this extended concept of |= if the set of
premises is a ﬁnite or empty set.
57

Theorem 2.17.1
(a) |= A if and only if {(¬A)} is not satisﬁable.
(b) A single formula premise {A} is consistent if and only if ̸⊢(¬A).
(c) The Completeness Theorem is equivalent to the statement that “Every consistent formula is satisﬁ-
able.”
(d) The set of premises Γ |= A if and only if Γ ∪{(¬A)} is not satisﬁable.
(e) If the set Γ is formally consistent and C ∈Γ, then Γ ̸⊢(¬C).
Proof. (a), (b), (c) are left as an exercise.
(d) First, let Γ ̸|= A. Then there is a v ∈E such that v(C) = T for each C ∈Γ but v(A) = F. This
v((¬A)) = T. Hence, Γ ∪{(¬A)} is satisﬁable.
For the converse, assume that Γ |= A. Now assume that there exists some v ∈E such that v(C) = T for
each C ∈Γ. Then for each such v v(A) = T. In this case, v((¬A)) = F. Now if no such v exists such that
v(C) = T for each C ∈Γ, then Γ is not satisﬁable. Since these are the only two possible cases for Γ∪{(¬A)},
it follows that Γ ∪{(¬A)} is not satisﬁable.
(e) Assume that Γ is formally consistent, C ∈Γ and Γ ⊢(¬C). This yields that Γ ⊢C. Now to the
demonstration add the step ⊢(¬C) →(C →A). Then two MP steps, yields that Γ ⊢A. Since A is any
formula, simply let A = D ∧(¬D). Hence Γ ⊢D ∧(¬D). This contradicts the consistency of Γ.
The important thing to realize is that to say that Γ is consistent says that no ﬁnite subset of Γ can yield
a contradiction. But if Γ is not itself ﬁnite, then how can we know that no ﬁnite subset of premises will not
yield a contradiction? Are there not just too many ﬁnite subsets to check out? We saw that if Γ is a ﬁnite
set, then all it needs in order to be consistent is for it to be satisﬁable due to the Corollary 2.15.2.1. The
next theorem states that for inﬁnite Γ the converse of what we really need holds. But, just wait, we will be
able to show that certain inﬁnite sets of premises are or are not consistent.
Theorem 2.17.2 The set Γ is formally consistent if and only if Γ is satisﬁable.
Proof. We show that if Γ is consistent, then it is satisﬁable. First, note that we can number every
member of L′. We can number them with the set of natural numbers IN. Let L′ = {Ai | i ∈IN} Now let Γ
be given. We extended this set of premises by the method of induction. (An acceptable method within this
subject.)
(1) Let Γ = Γ0.
(2) If Γ0 ∪{A0} is consistent, then let Γ1 = Γ0 ∪{A0}. If not, let Γ1 = Γ0.
(3) Assume that Γn has been deﬁned for all n ≥0.
(4) We now give the inductive deﬁnition. For n + 1, let Γn+1 = Γn ∪{An} if Γn ∪{An} is consistent.
Otherwise, let Γn+1 = Γn.
It follows by the method of deﬁnition by induction, that the entire set of Γns has been deﬁned for each
n ∈IN and each of these sets contains the original set Γ. We now deﬁne that set Γ as follows: K ∈Γ if and
only if there is some m ∈IN such that K ∈Γm.
We show that Γ is a consistent set. Suppose that Γ is not consistent. Then for some C ∈L′ and ﬁnite
a subset A1, . . . , An of Γ, it follows that A1, . . . , An ⊢C ∧(¬C). However, since Γ ⊂Γ1 ⊂Γ2 ⊂· · · ⊂Γ
etc. and since A1, . . . , An is a ﬁnite set, there is some Γj such that A1, . . . , An is a subset of Γj. But this
produces a contradiction that Γj is inconsistent. Thus Γ is consistent.
58

We now show that it is the “largest” consistent set containing Γ. Let A ∈L′ and assume that Γ ∪{A}
is consistent. If A ∈Γ, then A ∈Γ. If A /∈Γ, then we know that there is some k such that A = Ak. But
Γk ∪{Ak} ⊂Γ ∪{Ak} implies that Γk ∪{Ak} is consistent. But then Ak ∈Γk+1 ⊂Γ. Hence, A ∈Γ. We
need a few additional facts about Γ.
(i) A ∈Γ if and only if Γ ⊢A. (Such a set of formulas is called a deductive system.) First, the process
⊢yields immediately that if A ∈Γ, then Γ ⊢A. Conversely, assume that Γ ⊢A. Then F1 ⊢A for a ﬁnite
subset of Γ. We show that Γ ∪{A} is consistent. Assume not. Then there is some ﬁnite subset F2 of Γ such
that F2 ∪{A} ⊢C ∧(¬C) for some A ∈L′. Thus F1 ∪A2 ⊢C ∧(¬C). But this means that Γ ⊢C ∧(¬C).
This contradiction implies that Γ ∪{A} is consistent. From our previous result, we have that A ∈Γ.
(ii) If B ∈L′, then either B ∈Γ or (¬B) ∈Γ. (When a set of premises has this property they are said
to be a (negation) complete set.) From consistency, not both B and ¬B can be members of Γ
(iii) If B ∈Γ, then A →B ∈Γ for each A ∈L′.
(iv) If A ̸∈Γ, then A →B ∈Γ for each B ∈L′.
(v) If A ∈Γ and B ̸∈Γ, then A →B ̸∈Γ.
(Proofs of (ii) – (v) are left as an exercise.)
We now need to deﬁne an valuation on all of Γ. Simple to do. Let v(A) = T if A ∈Γ and v(B) = F if
B ̸∈Γ. Well, does this satisfy the requirements of a valuation function? First, it is deﬁned on all of L′?
(a) By (ii), if v(A) = T, then A ∈Γ implies that (¬A) ̸∈Γ. Hence, v(¬A) = F.
(b) From (iii) –(v), it follows that v(A →B) = F if and only if v(A) = T and v(B) = F. Thus v is a
valuation function and Γ is satisﬁable. But Γ ⊂Γ implies that Γ is satisﬁable and the proof is complete.
Now to show that if Γ is satisﬁable, then it is consistent. Suppose that Γ is satisﬁable but not consistent.
Hence there exists a ﬁnite F ⊂Γ such that F ⊢C ∧(¬C) for some C ∈L′. But then F |= C ∧(¬C), by
corollary 2.15.2.1 and is not satisﬁable. Hence since F ⊂Γ, then Γ is not satisﬁable. This contradiction
yields this result.
Theorem 2.17.3 The following statement are equivalent.
(i) If Γ |= B, then Γ ⊢B. (Completeness)
(ii) If Γ is consistent, then Γ is satisﬁable.
Proof. Assume that (i) holds and that Γ is consistent. If C ∈Γ, then by theorem 2.17.1 part (e)
Γ ̸⊢(¬C). By the contrapositive if (i), then Γ |= (¬C). But by (d) of theorem 2.17.1, Γ ∪{(¬(¬C))} is
satisﬁable. Let v be the valuation. Then v(A) = T for each A ∈Γ AND v((¬(¬C))) = T . Hence, v(C) = T.
Thus Γ is satisﬁable.
Now assume that (ii) holds and let Γ |= B. Then by theorem 2.17.1 part (d) Γ∪{(¬B)} is not satisﬁable.
Hence Γ ∪{(¬B)} is inconsistent. Consequently, there is some C such that Γ ∪{(¬B)} ⊢C ∧(¬C). By
Corollary 2.15.2.1, C ∧(¬C) ⊢A for any A ∈L′. So, let A = (¬B) →B. So, in the demonstration that
Γ ∪{(¬B)} ⊢C ∧(¬C) ⊢(¬B) →B, one MP step yields B. Thus Γ ⊢B.
From theorem 2.17.3, since (ii) holds, then the extended completeness theorem (i) holds. But it really
seems impossible to show that an inﬁnite Γ is inconsistent unless we by chance give a demonstration that
Γ ⊢C ∧(¬C) or to show that it is consistent by showing that Γ is satisﬁable. For this reason, the next
theorem and others of a similar character are of considerable importance.
59

Theorem 2.17.3 (Compactness) A set of formulas Γ is satisﬁable if and only if every ﬁnite subset of Γ
is satisﬁable.
Proof. Assume that Γ is satisﬁable. Then there is some v ∈E such that v(A) = T for each A ∈Γ. Thus
for any subset F of Γ ﬁnite or otherwise v(B) = T for each B ∈F.
Conversely, assume that Γ is not satisﬁable. Then from theorem 2.17.2, Γ is not consistent. Hence there
is some C ∈L′ and ﬁnite F ⊂Γ such that F ⊢C ∧(¬C). By the soundness theorem, F |= C ∧(¬C). Thus
F is not satisﬁable and the proof is complete.
Corollary 2.17.4.1 A set of premises Γ is consistent if and only if every ﬁnite subset of Γ is consistent.
Example 2.17.1 Generate a set of premises by the following rule. Let A1 = (¬A), A2 = (¬A)∧A, A3 =
(¬A) ∧A ∧A, etc. Then the set Γ = {Ai | i ∈IN} is inconsistent since A2 is not satisﬁable.
Example 2.17.2 Generate a set of premises by the following rule. Let A1 = P, A2 = P ∨P1, A3 =
P ∨P1 ∨P2, . . . , An = P ∨· · · ∨Pn−1. Then the set Γ = {Ai | i ≥1, i ∈IN} is consistent. For consider a
nonempty ﬁnite subset F of Γ. Then there exists a formula Ak ∈F (with maximal subscript) such that if
Ai ∈F, then 1 ≤i ≤k. Let v ∈E be a valuation such that v(P) = T. Obviously such a valuation exists.
The function v also gives truth-values for all other members of F. But all other formula in F contain P and
are composed of a formula B such that Ai = P ∨B, 2 ≤i ≤k. But v(P ∨B) = T independent of the values
v(B). Hence F is satisﬁed and the compactness theorem states that Γ is consistent.
EXERCISES 2.17
1. Prove properties (ii), (iii), (iv), (v) for Γ as they are stated in the proof of theorem 2.17.2.
2. Prove statements (a), (b), (c) as found in theorem 2.17.1.
3. Use the compactness theorem and determine whether or not the following sets of premises are consistent.
(a) Let A ∈L′. Now Γ contains A1 = A →A, A2 = (A →(A →A), A3 = A →(A →(A →A)), etc.
(b) Let A ∈L′. Now Γ contains A1 = A →A, A2 = (¬(A →A)), A3 = A →(¬(A →A)) etc.
(c) Let A1 = P1 ↔P2, A2 = P1 ↔(¬P2), A3 = P2 ↔P3, A4 = P2 ↔(¬P3), etc.
The consistency of the process (1)(2)(3)(4) used in Theorem 2.17.2
We do not need Theorem 2.17.2 if Γ is a non-empty ﬁnite set of premises since then Corollary 2.15.2.1
applies.
However, what follows holds for any set of hypotheses.
Clearly, if the process (1)(2)(3)(4) is
consistent it is not an eﬀective process since there are no rules given to determine, in a step-by-step process,
when a set such as Γ ∪A, where A /∈Γ, is consistent. On the other hand, there are various ways to show
convincingly that the process itself is consistent. This is done by the intuitive method of re-interpretation
and modeling. Two examples are described below. Later it will be shown more formally that such statements
that characterize such processes are consistent if and only if they have a set-theoretic model.
(A) Call any A ∈L′ a “positive formula” if the ¬ symbol does not appear in the formula. Let Γ be a set
of positive formula. Apply the process (1)(2)(3)(4) where we substitute for “consistent” the phrase “a set of
positive formula.” Note that since we started with a set of positive formula, then we can determine whether
the set Γn ∪{An} is a set of positive formula just by checking the one formula An. What has been done in
this example is that the original process (1)(2)(3)(4) has been re-interpreted using a determining requirement
that can actually be done or a requirement that most exist. The fact that an actual determination can be
made in ﬁnite time is not material to the consistency of the process. All that is required is that each formula
be either positive or negative, and not both. This re-interpretation is called a “model” for this process and
60

implies that the original process is consistent relative to our intuitive metalogic. This follows since if the
process is not consistent, then a simple metalogical argument would yield that there is an actual formula in
L′ that is positive and not positive.* All of this is, of course, based upon the acceptance that the processes
that generated L′ are also consistent.
(B) We are using certain simple properties of the natural numbers to study mathematically languages
and logical processes. It is assume that these natural number processes are consistent. Using this assumption,
we have the following model that is relative to the a few natural number properties. Interpret Γ as a set of
even numbers and interpret each member of L′ as a natural number. Substitute for “consistent” the phrase
“is a set of even natural numbers.” Thus, all we need to do is to determine for the basic induction step is
whether Γn ∪{An} is a set of even numbers. Indeed, all that is needed is to show that An can be divided by
2 without remainder, theoretically a ﬁnite process. This gives a model for this induction process relative to
the natural numbers since a natural number is either odd or even, and not both. Hence, we conclude that
the original process is consistent relative to our metalogic.
* Formally, (1) B ∧(¬B) ≡¬(B →B). (2) ⊢(¬(B →B) →((B →B) →Ci)). (3) (B →B) →Ci. (4)
⊢B →B. (5) Ci. Just take C1 = “A is positive” and C2 = “A is not positive.”
61

NOTES
62

Chapter 3 - PREDICATE CALCULUS
3.1 A First-Order Language.
The propositional language studied in Chapter 2 is a fairly expressive formal language. Unfortunately,
we can’t express even the most obvious scientiﬁc or mathematical statements by using only a propositional
language.
Example 3.1.1 Consider the following argument. Every natural number is a real number. Three is a
natural number. Therefore, three is a real number.
The propositional language does not contain the concept of “every.” Nor does it have a method to
go from the idea of “every” to the speciﬁc natural number 3. Without a formal language that mirrors the
informal idea of “every” and the use of the symbol “3” to represent a speciﬁc natural number, we can’t follow
the procedures such as those used in chapter 2 to analyze the logic of this argument. In this ﬁrst section,
we construct such a formal language. Accept for some additional symbols and rules as to how you construct
new formula with these new symbols, the method of construction of language levels is exactly the same as
used for L and L′. So that we can be as expressive as possible, we’ll use the connectives ∨, ∧, and ↔as they
are modeled by the connectives ¬,→. We won’t really need the propositions in our construction. But, by
means of a special technique, propositions can be considered as what we will call predicates with constants
inserted. This will be seen from our basic construction. This construction follows the exact same pattern as
deﬁnition 2.2.3. After the construction, I will add to the English language interpretations of deﬁnition 2.2.4
the additional interpretations for the new symbols.
Deﬁnition 3.1 (The First-Order Language Pd)
(1) A nonempty set of symbols written, at the ﬁrst, with missing pieces (i.e. holes in them). They look
like the following, where the underlined portion means a place were something, yet to be described, will be
inserted.
(a) The 1-place predicates
P(
), Q(
), R(
), S(
), P1(
), P2(
), . . . .
(b) The 2-place predicates
P(
,
), Q(
,
), R(
,
)S(
,
), P1(
,
), P2(
,
), . . . .
(c) The 3-place predicates
P(
,
,
),Q(
,
,
), R(
,
,
), . . . .
(d) And so-forth, continuing, if necessary, through any n-place predicate, a symbol with a “(”
followed by n “holes,” where the underlines appear, followed by a “)”.
(2) An inﬁnite set of variables, V = {x1, x2, x3, . . .}, where we let the symbols x, y, z,w represent any
distinct members of V.
(3) A nonempty set of constants C = {c1, c2, c3, c4, . . .} and other similar notation, where we let a, b, c, d
represent distinct members of C.
(4) We now use the stuﬀin (1), (2), (3) to construct a set of predicates, P, which are the atoms of Pd.
In each of the underlined places in (1), insert either a single variable from V or a single constant from C.
Each time you construct one of these new symbols, it is called a 1, 2, . . ., n-place predicate. The language
Pd will use one or more of these predicates.
(5) The non-atomic formula are constructed from an inﬁnite set of connectives. The u-nary connective
¬ and the previous binary connectives ∨, ∧, →, ↔. You place these in the same positions, level for level,
as in the construction of deﬁnition 2.2.3.
63

(6) Before every member of V , the variables, will be placed immediately to them left the symbol ∀.
Then before every member of V will be placed immediately to the left the symbol ∃. This gives inﬁnitely
many symbols of the form U = {∀x1, ∀x2, ∀x3, ∀x4,. . .} and of the form EX = {∃x1, ∃x2, ∃x3, ∃x4,. . .}
where we use the symbols ∀x, ∀y, ∀x, ∃x, ∃y, ∃z and the like to represent any of these symbols. Each ∀x
is called an universal quantiﬁer, each ∃x is called an existential quantiﬁer.
(7) Now the stuﬀconstructed in (6) is an inﬁnite set of u-nary operators that behavior in the same
manner as does ¬ relative to the method we used to construct our language.
(8) Although in an actual ﬁrst-order language, we usually need only a few predicates and a few universal
or existential quantiﬁers or a few constants, it is easier to simply construct the levels, after the ﬁrst level
that contains all the predicates, in the following manner using parentheses about the outside of every newly
constructed formula each time a formula from level 2 and upward is constructed. Take every formula from
the preceding level and place immediately to the left a universal quantiﬁer, take the same formula from the
previous level and put immediately to the left a existential quantiﬁer, repeat these constructions for all of the
universal and existential quantiﬁers. Important: The formula to the right of the quantiﬁer used for
this construction is called the scope of the quantiﬁer. Now to the same formula from the preceding
level put immediately to left the ¬ in the same manner as was done in deﬁnition2.2.3.
(9) Now following deﬁnition 2.2.3, consider every formula from the previous level and construct the
formula using the binary connectives ∨, ∧, →, ↔making sure you put parentheses about the newly formed
formula. AND after a level is constructed with these connectives we adjoin the previous level to the one just
constructed.
(10) The set of all formula you obtain in this manner is our language Pd.
(11) Any predicate that contains only constants in the various places behaves just like a proposition
in our languages L and L′ and can be considered as forming a propositional language.
What we have
constructed is an extension of these propositional languages.
(12) I point out that there are other both less formal and more formal ways to construct the language
Pd.
This is not really a diﬃcult construction.
Example 3.1.1 (i) The following are predicates. P(x), P(c), P(x, c), Q(x, x), Q(c, c1, z).
(ii) The following are not predicates. P(), P(
), P(P, Q), P)(, Px, Pc.
(iii) The following are members of Pd. (P(c) ↔Q(x)), (∀xP(c)), (∃yP(x)), (∀xP(x, y)), (¬(∀xP(z))),
(∃x(∀x(∃y(∀yP(c, d, w))))), ((∃x(P(x) ↔Q(d)))).
(iv) The following are not formula. P(∃x), (∀P(x)), (∀cP(x)), (∃x(∀y)P(x, y)), ((P(d) ↔Q(x)∃x).
As was done with the language L, we employ certain terminology to discuss various features of Pd. We
employ, whenever possible, the same deﬁnitions. Each element of Pd is called a formula. The ﬁrst level
Pd0 is the set of all the atoms. Any member of Pd which is not an atom is called a composite formula. A
formula expressed entirely in terms of atoms and connectives is called an atomic formula. We let, as usually,
the symbols A, B, C,. . . be formula variables and represent arbitrary members of Pd.
If A ∈Pd, then there is a smallest n such that A ∈Pdn and A /∈Pdk for any k < n. The number n
is the size of A. All the parenthesis rules, the common pair rules hold, where ∀x and ∃x behave like the ¬.
However, the parentheses that form the predicates are never included in these rule processes.
The English language interpretation rules for the predicates and the quantiﬁers take on a well-know
form, while the interpretation is the same for all the other connectives as they appear in 2.1.
For the
following, we utilize the variable predicate forms A(x) and the like. These may be thought of as 1-place
64

predicates for the moment. Since this interpretation is an inductive interpretation, where we interpret only
the immediate symbol, we need not know the exact deﬁnition for A(x) at this time.
(i) ⌈P(
)⌉: ⌉P(
,
)⌉: ⌈P(
,
,
)⌉:
These are usually considered to be simple declarative sentences that relate various noun forms. In order
to demonstrate this, we use the “blank” word notation where the blanks are to be understood by the “–”
symbol and the “blanks” must be ﬁlled in with a variable or a constant. Here is a list of examples that may
be interpreted as 1-place, 2-place, 3-place and 4-place predicates. “– is lazy.” “– is a man.” “– plays –.” “–
is less than –.” “– > –.” “– plays – with –.” “– plus – equal –.” “– + – = –.” “– plays – with – at –.” “– +
– + – = –.”
(ii) The constants C are interpreted as identifying “names” for an element of a domain, a proper name and
the like, where if there is a common or required name such as “0,” “1,” or “sine,” then this common name
is used as a constant.
(iii) ⌈∀xA(x)⌉:
For all x, ⌈A(x)⌉:
For arbitrary x, ⌈A(x)⌉:
For every x, ⌈A(x)⌉.
For each x, ⌈A(x)⌉.
Whatever x is ⌈A(x)⌉.
(Common language)
Everyone is ⌈A(x)⌉.
⌈A(x)⌉always holds.
Each one is ⌈A(x)⌉.
Everything is ⌈A(x)⌉.
(iv) ⌈∃xA(x)⌉:
There exists an x such that ⌈A(x)⌉.
There is an x such that ⌈A(x)⌉.
For suitable x, ⌈A(x)⌉.
There is some x such that ⌈A(x)⌉.
For at least one x, ⌈A(x)⌉.
(Common language)
At least one x ⌈A(x)⌉.
Someone is ⌈A(x)⌉.
Something is ⌈A(x)⌉.
Great care must be taken when considering a negation and quantiﬁcation as is now demonstrated since
a “not” before a quantiﬁer or after a quantiﬁer often yields diﬀerent meanings.
(v) ⌈¬(∀xA(x))⌉:
Not for all x, ⌈A(x)⌉.
⌈A(x)⌉does not hold for all x.
⌈A(x)⌉does not always hold.
Not everything is ⌈A(x)⌉.
(vi) ⌈∀x(¬A(x))⌉:
For all x, not ⌈A(x)⌉.
⌈A(x)⌉always fails.
Everything is not ⌈A(x)⌉.
(vii) ⌈¬(∃xA(x))⌉:
There does not exists an x such that ⌈A(x)⌉.
65

There does not exists any x such that ⌈A(x)⌉.
There exists no x such that ⌈A(x)⌉.
Nothing is ⌈A(x)⌉.
There is no x such that ⌈A(x)⌉.
No one is ⌈A(x)⌉.
There isn’t any x such that ⌈A(x)⌉.
(viii) ⌈∃x(¬A(x))⌉:
For some x, not ⌈A(x)⌉.
Something is not ⌈A(x)⌉.
(All other ∃x with a not just prior to ⌈A(x)⌉.
There are many other possible English language interpretations for the symbols utilized within our
ﬁrst-order language but the ones listed above will suﬃce.
EXERCISES 3.1
NOTE: Outer parenthesis simpliﬁcation may have been applied.
1. Let A represent each of the following strings of symbols. Determine if A ∈Pd or A /∈Pd.
(a) A = (∃x(¬(∀xP(x, y))))
(d) A = (P(c) ∨∃x∀y)Q(x, y))
(b) A = ∀x(P(x) →(∃cP(c, x)))
(e) A = ∃x(∀y(P(x) →Q(x, y)
(c) ∀x(∃y(∀z(P(x)))).
2. Find the size of A.
(a) A = ∃x(∀y(∃zP(x, y, z))).
(b) A = (P(c) →(∃y(¬(∀xP(x, y))))).
(c) A = ∀x(P(x) →((∃yP(x, y)) →(P(c) ∨Q(c))))
(d) A = (P(c) ∨(∃y(Q(x) →P(y)))) →R(x, y, z).
3. Use the indicated predicate symbols, which may appear in previous lettered sections, and any arithmetic
symbols such as
+
for “sum of – and –” or
<
for “– is less than –,” or
=
for “– is equal
to –” and the like and translate the following into symbols from the language Pd. You may need to slightly
re-write the English language statement into one with the same intuitive meaning prior to translation
(a) If the product of ﬁnitely many factors is equal to zero, then at least one of the factors is zero. [Let
P(
) be the predicate “– is the product of ﬁnitely many factors,” Q(
,
) be the predicate “– is a factor
of –.”]
(b) For each real number, there is a larger real number. [Let R(
) be “– is a real number.”]
(c) For every real number x there exists a real number y such that for every real number z, if the sum
of z and 1 is less than y, then the sum of x and 2 is less than 4. [Note that “−+ 1 < −” is a three place
predicate with a constant “1” in the second place.]
(d) All women who are lawyers admire some judge. [Let W(
) be “– is a women,” let L(
) be “– is a
lawyer,” let J(
) be “– is a judge,” and let A(
,
) be “– admires –.”]
(e) There are both lawyers and shysters who admire Judge Jones. [Let S(
) be “– is a shyster,” and
jet j symbolize the name “Jones.”]
(f) If each of two persons is related to a third person, then the ﬁrst person is related to the second
person. [Let R(
,
) be “– is related to –,” and let P(
) be “– is a person.”]
(g) Every bacterium which is alive in this experiment is a mutation. [Let B(
) be “– is a bacterium,
A(
) be “– is alive in this experiment,” and M(
) be “– is a mutation.”]
66

(h) The person responsible for this rumor must be both clever and unprincipled. [Let P(
) be “– is a
person responsible for this rumor,” C(
) be “– is clever,” and U(
) be “– is unprincipled.”]
(i) If the sum of three equal positive numbers is greater than 3 and the sum of the same equal positive
numbers is less than 9, then the number is greater than 1 and less than 3.
(j) For any persons x and y, x is a brother of y if and only if x and y are male, and x is a diﬀerent
person than y, and x and y have the same two parents. [Let (again) P(
) be “– is a person,” B(
,
) be
“– is a brother of – ,” M(
) be “– is a male,” −−̸= −−be “– is a diﬀerent person than –,” Q(
,
) be
“– and – have the same two parents.”]
4. Let P(
) be “– is a prime number,” E(
) be “– is an even number,” O(
) be “– is an odd number,”
D(
,
) be “– divides –.” Translate each of the following formal sentences into English language sentences.
(a) P(7) ∧O(7).
(b) ∀x(D(2, x) →E(x)).
(c) (∃x(E(x)) ∧P(x))) ∧(¬(∃x(E(x) ∧P(x)))) ∧(∃y(x ̸= y)) ∧E(y) ∧P(y).
(d) ∀x(E(x) →(∀y(D(x, y) →E(y)))).
(e) ∀x(O(x) →(∃y(P(y) →D(y, x)))).
3.2. Free and Bound Variable Occurrences.
Prior to the model theory (the semantics) for the language Pd, a further important concept must be
introduced. It’s interesting to note that the next concept dealing with variables took a considerable length
of time to formulate in terms of an easily followed rule. As usual, we are fortunate that much of the diﬃcult
work in mathematical logic has been simpliﬁed so that we may more easily investigate these important
notions. For simplicity, the n-place predicates where all places are ﬁlled with constants will act as if they
are propositions. As will be seen, the presence of any quantiﬁers prior to such predicates will have NO
eﬀect upon their semantical meaning nor will such a case involve any additional nonequivalent formula in
the formal deduction (proof theory) associated with Pd.
Deﬁnition 3.2.1 (Scope of a quantiﬁer.)
Assume that a quantiﬁer is symbolized by Q. Suppose that Q appears in a formula A ∈Pd. Then in
that quantiﬁer appears one and only one variable, say v ∈V. Immediately to the right of the variable v, two
and only two mutually distinct symbols appear.
(1) A left parenthesis. If this is the case, then the subformula from that left parenthesis to its common
pair parenthesis us called the scope of that quantiﬁer.
(2) No parenthesis appears immediately on the right. In this case, the predicate that appears immedi-
ately on the right is called the scope of that quantiﬁer.
In general, to identify quantiﬁers and scopes, the quantiﬁers are counted by the natural numbers from
left to right. In what follows, we place the “quantiﬁer” count as a subscript to the symbols ∀and ∃rather
than as subscripts to the variables. Note: if the same quantiﬁer occurs more than once, then it is counted
more than once. Why? Because it is the location of the quantiﬁer within a formula that is of ﬁrst importance.
Example 3.2.1
(a) Let A = (∀1xP(x)) ∧Q(x). Then the scope of quantiﬁer (1) is the predicate P(x).
(b) Let A = ∃1y(∀2x(P(x, y) →(∀3zQ(x)))). The scope of the quantiﬁer (1) is (∀x(P(x, y) →
(∀zQ(x)))). The scope for the quantiﬁer (2) is (P(x, y) →(∀zQ(z))). The scope for quantiﬁer (3) is Q(x).
67

(c) Let A = ∀1x(∀2y(P(c) →Q(x, y))) ↔(∃3xP(c, d)). Then the scope for quantiﬁer (1) is (∀y(P(c) →
Q(x, y))). The scope for quantiﬁer (2) is (P(c) →Q(x, y)). The scope for quantiﬁer (3) is P(c, d).
(d) Let A = (∀1x((R(x) ∧(∃2xQ(x, y))) →(∃3yP(x, y)))) →Q(x, z). The scope of quantiﬁer (1) is
((R(x) ∧(∃xQ(x, y))) →(∃yP(x, y))). The scope of quantiﬁer (2) is Q(x, y). The scope of quantiﬁer (3) is
P(x, y). Notice that the second occurrence of Q(x, y) is not in the scope of any quantiﬁer.
Once we have the idea of the scope ﬁrmly in our minds, then we can deﬁne the very important notion
of the “free” or “bound” occurrence of variable. We must have the formula in atomic form to know exactly
what variables behave in these two ways. This behavior is relative to their positions within a formula. We
call the position where a variable or constant explicitly appears as an occurrence of that speciﬁc variable or
constant with in a speciﬁc formula.
Deﬁnition 3.2.2 (Bound or free variables)
(1) Every place a constant appears in a formula is called a bound occurrence of the constant.
(2) You determine the free or bound occurrences after the scope for each quantiﬁer has been determined.
You start the determination at level Pd0 and work your way up each level until you reach the level at which
the formula ﬁrst appears in Pd. This is the “size” level.
(3) For level Pd0 every occurrence of a variable is a free occurrence.
(4) For each succeeding level, an occurrence of a variable is a bound occurrence if that variable occurs
in a quantiﬁer or is not previously marked as a bounded occurrence in the scope of the quantiﬁer.
(5) After all bound occurrences have been determined, than any occurrence of a variable that is not
bound is called a free occurrence.
(6) A bound occurrence of a speciﬁc variable is determine by a quantiﬁer in which the variable appears.
This is called the bounding quantiﬁer.
(7) Any variable that has a free occurrence within a formula is said to be free in the formula.
There are various ways to diagram the location of a speciﬁc variable and its bound occurrences. One
method is a line diagram and the other is to use the quantiﬁer number and the same number for each bound
occurrence of the variable. I illustrate both methods. It turns out that for one concept the line diagram is
the better of the two.
Example 3.2.2 This is the example of the line diagram method of showing the location of each bound
variable.
(a) (∀x((P(x) ∧(∃zQ(x, z))) →(∃yM(x, y)))) ∧Q(x).
(b) (∀y((P(y) ∧(∃xQ(x, z))) →(∃zM(y, z)))) ∧Q(z).
(c) (∀x((P(x) ∧(∃xQ(x, z))) →(∃yM(x, y)))) ∧Q(z).
(d) (∀z((P(z) ∧(∃xQ(x, z))) →(∃yM(z, y)))) ∧Q(x).
In these line diagrams, each vertical line segment attached to a line segment identiﬁes the bound occur-
rences for a speciﬁc quantiﬁer. Notice that in (a) the x has a bound occurrence and is free in the formula.
Thus the concepts of free in a formula and bound occurrences are not mutually exclusive. In (b), the z has
a bound occurrence and free in the formula. In (c), z is the only variable free in the formula. In (d), x has
both a bound occurrence and is free in the formula.
68

Example 3.2.3 The use of subscripts to indicate the bound occurrences of a variable AND its bounding
quantiﬁer.
(a) ∀x1((P(x1) ∧(∃z2Q(x1, z2))) →(∃y3M(x1, y3))) ∧Q(x).
(b) ∀y1((P(y1) ∧(∃x2Q(x2, z))) →(∃z3M(y1, z3))) ∧Q(z).
The line diagram or number patterns themselves turn out to be of signiﬁcance.
Deﬁnition 3.2.3 (Congruent Formula) Let A, B ∈Pd and A, B are in atomic form. Assume that
all the bound occurrences of the variable in both A and B have been determined either by the line segment
method or numbering method. If in both A and B all the bound variables and only the bound variables are
erased and the remaining geometric form for A and for B are exactly the same (i.e. congruent), then the
formula are said to be congruent.
The basic reason the concept of congruence is introduced is due to the following theorem. After the
necessary machinery is introduce, it can be established. The ↔that appears in this theorem behaves exactly
as it does in the language L.
Theorem 3.2.1 If A, B ∈Pd and A, B are congruent, then ⊢A ↔B.
Example 3.2.3 In this example, we look at previous formula and determine whether they are congruent.
(a) In example 3.2.2, formula (a) is not congruent to (b) since the variable that occurs free in Q(
) in
(a) is x while the variable that occurs in Q(
) in (b) is z.
(b) Formulas (b) and (c) in example 3.2 are congruent.
Deﬁnition 3.2.4 (Sentences) Let A ∈Pd. Then A is a sentence or is a closed formula if there are NO
variables that are free in the formula A.
For this text, sentences will be the most important formula in Pd. Although one need not restrict
investigations to sentences only, these other investigations are, usually, only of interest to logicians. Indeed,
most elementary text books concentrate upon the sentence concept due to their signiﬁcant applications.
Further, you can always assign the concept of “truth” or “falsity” (occur or won’t occur) to sentences. The
“always assign” in the last sentence does not hold for formula in general.
EXERCISES 3.2
1. List the scope for each of the numbered quantiﬁers.
(a) (∀1x(∃2xQ(x, z))) →(∃3xQ(y, z)).
(b) (∃1x(∀2y(P(c) ∧Q(y)))) →(∀3xR(x)).
(c) (P(c) ∧Q(x)) →(∃1y(Q(y, z) →(∀2xR(x)))).
(d) ∀1z((P(z) ∧(∃2xQ(x, z))) →(∀3z(Q(c) ∨P(z)))).
2. Use the subscript or line segment method to display the variables that are bound by a speciﬁc symbol ∀
or ∃.
(a) (∀z(∃y(P(z, y) ∧(∀zQ(z, x))) →M(z))).
(b) (∀x(∃y(P(x, y) ∧(∀yQ(y, x))) →M(x))).
(c) (∀z(∃x(P(z, x) ∧(∀zQ(z, y))) →M(z))).
(d) (∀y(∃z(P(y, z) ∧(∀zQ(z, x))) →M(y))).
(e) (∀y(∃z(P(z, y) ∧(∀zQ(z, x))) →M(y))).
69

(f) ∃x(∀z(P(x, z) ∨(∀uM(u, y, x)))).
(g) ∃y(∀x(P(z, x) ∨(∀xM(x, u, y)))).
(h) ∃y(∀x(P(y, x) ∨(∀xM(x, y, z)))).
(i) ∃z(∀x(P(z, x) ∨(∀xM(x, y, z)))).
(j) ∃x(∀x(P(z, x) ∨(∀zM(x, y, z)))).
3. For the formula in [2] list as ordered pairs all formula that are congruent.
4. In the following formula, make a list as follows: write down the formula identiﬁer, followed by the word
“free,” followed by a list of the variables that are free in the formula, followed by the word “bound,” followed
by the variables that have bound occurrences. (e.g. (g) Free, z, x, z; Bound x, z.)
(a) (P(x, y, z) ∨(∃x(P(y) →Q(x)))) ∧(∀zR(z)).
(b) (∀xP(x, x, x)) →(Q(z) ∧(∀zR(z))).
(c) (∀x(P(c) ∧Q(x)) →M(x)) ↔P(y).
(d) (∀x(∀y(∀z(P(x) →Q(z))))) ∨Q(z).
(e) (P(c) ∧Q(x)) →((∃xQ(x)) ∧(∃y(Q(y, x) →M(d)))).
(f) ∀x(∃y((P(x) ∧Q(y)) →(P(c) ∧Q(c)))).
5.
(a) Which formula in problem 1 are sentences?
(b) Which formula in problem 2 are sentences?
(c) Which formula in problem 4 are sentences?
3.3 Structures
In the discipline of mathematical logic, we use the simplest and most empirically consistent processes
known to the human mind to study the human experience of communicating by strings of symbols and
logical deduction. Various human abilities are necessary in order to investigate logical communication. One
must be able to recognize that the symbols within the quotation marks “a” and “b” are distinct. Moreover,
one must use various techniques of “ordering” in order to communicate in English and most other languages.
An individual must intuitively know which string of symbols starts a communication and the direction to
follow in order to obtain the next string of symbols. In the English language, this is indicated by describing
the direction as from “left to right” and from “top to bottom.” Without a complete intuitive knowledge of
these “direction concepts” no non-ambiguous English language communication can occur. These exact same
intuitive processes are necessary in the mathematical discourse. Mathematics, in its must fundamental form,
is based upon such human experiences.
In 1936, Tarski introduced a method to produce conceptually the semantical “truth” or “falsity” notion
for a predicate language Pd that mirrors the concepts used for the propositional language L′. The Tarski
ideas are informal in character, are based upon a few aspects of set-theory, but these aspects cannot be
considered as inconsistent, in any manner, since by the above mentioned human abilities and experiences
concrete symbol string examples can be given for these speciﬁc Tarski notions. The only possible diﬃculty
with the Tarski concepts lies in the fact that in order for certain sentences in Pd to exhibit “truth” or “falsity,”
the concept would need to be extended to non-ﬁnite sets. When this happens, some mathematicians take
the view that the method is weaker than the method of the formalistic demonstration. In this case, however,
most mathematicians believe that the Tarski method is not weaker than formal demonstrations since no
inconsistency has occurred in using the most simplistic of the non-ﬁnite concepts. This simplistic non-ﬁnite
70

notion has been used for over 3,000 years. This non-ﬁnite notion is the one associated with the set called
the natural numbers IN.
In this text, the natural numbers, beginning with zero, are considered as the most basic of intuitive
mathematical objects and will not be formally discussed. This Tarski approach can be considerably simpliﬁed
when restricted to the set of all sentences S. It’s this simpliﬁcation that we present next.
We ﬁrst need to recall some of the most basic concepts, concepts that appear even in many high school
mathematics courses. Consider the following set of two alphabet letters A = {a, a, b}. First, the letters are
not assumed to be in anyway diﬀerent simply due to the left to right order in which they have been written
or read. There is an “equality” deﬁned for this set. Any two letters in this set are equal if they are intuitively
the same letter. One sees two “a” symbols in this set. In sets that contain identiﬁable objects such as the two
“a” symbols, it’s an important aspect of set-theory that only one such object should be in the set. Hence,
in general, speciﬁc objects in a set are considered as unique or distinct. On the other hand, variables can be
used to “represent” objects. In this case, it makes sense to write such statements such as “x = y.” Meaning
that both of the variables “x” and “y” represent a unique member of the set under discussion.
In mathematical logic, another reﬁnement is made. The set A need not be composed of just alphabet
symbols.
It might be composed of midshipmen.
In this case, alphabet symbols taken from our list of
constants are used to name the distinct objects in the set. Take an a ∈C. In order to diﬀerentiate between
this name for an object and the object it represents in a set, we use the new symbol a′ to denote the actual
object in the set being named by a.
Only one other elementary set-theory notion is necessary before we can deﬁne the Tarski method. This
is the idea of the ordered pair. This is where, for the intuitive notion, the concept of left to right motion is
used. Take any one member of A. Suppose you take a. Then the symbol (a, a) is an ordered pair. Using
the natural number counting process, starting with 1, the set members between the left parenthesis “(” and
the right parenthesis “)” are numbered. The ﬁrst position, moving left to right, is called the ﬁrst coordinate,
the second position is called the second coordinate. In this example, both coordinates are equal under our
deﬁnition of equality.
We can construct the set of ALL ordered pairs from the members in A. This set is denoted by A2 or
A×A and contains the distinct objects {(a, a), (b, b), (a, b)(b, a)}. What one needs to do is to use the equality
deﬁned for the set A to deﬁne an equality for ordered pairs. This can be done must easily by using a word
description for this “ordered pair equality.” Two ordered pairs are “equal” (which we denote by the symbol
=) if and only if the ﬁrst coordinates are equal AND the second coordinates are equal.
Well, what has been done with two coordinates can also be done with 3, 4, 5, 25, 100, 999 coordinate
positions. Just write down a left “(” a member of A, followed by a comma, a member of A, followed by a
comma, continue the described process, moving left to right, until you have, say 999 coordinates but follow
the last one in your symbol not by a comma but by a right “)”. What this is called is a 999-tuple. The set
of ALL 999-tuples so constructed from the set A is denoted by A999 rather than writing the symbol A 999
times and putting 998 × symbols between them. For any natural number a greater than 1, An denotes the
set of ALL n-tuples that can be constructed from the members of A.
Notice that we have deﬁned equality of order pairs by using the coordinate numbers. To deﬁne equality
for n-tuples, where n is any natural number greater than 1, simply extend the above 2-tuple (ordered pair)
deﬁnition in terms of the position numbers. Thus two n-tuples are “equal” if and only if the ﬁrst coordinates
are equal AND the second coordinates are equal AND . . . . AND the nth coordinates are equal.
The last set theory concept is the simple subset concept. A set B is a subset of the set A if and only
if every object in B is in A, where this statement is symbolized by B ⊂A. The symbols “in A” mean that
you can recognize that the members of B are explicitly members of A by their properties. There is a special
71

set called the empty set (denoted by ∅) that is conceived of as have NO members. From our deﬁnition for
“subset,” the empty set is a subset of any set since the ∅contains no members and, thus, it certainly follows
that all of its members are members of any set. Lastly, a subset R of An, for n > 1, will be called an n-place
relation or an n-ary relation.
Deﬁnition 3.3.1 (Structures) Let Pd be a ﬁrst-order language constructed from a nonempty ﬁnite or
inﬁnite set {P1, P2, . . .} of predicates and an appropriate set C of constants that satisﬁes (iv). For our basic
application, a structure with an interpretation is an object M = ⟨D, {P ′
1, P ′
2, . . .}⟩where
(i) D is a nonempty set called the domain.
(ii) each n-place predicate Pi, where n > 1, corresponds to an n-place relation P ′
i ⊂Dn, and
(iii) the 1-place predicates correspond to speciﬁc subsets of D and
(iv) there is a function I that denotes the correspondence in (ii) and (iii) and that corresponds constants
ci ∈N ⊂C to members c′
i in D, (this function I is a naming function). Constants in N correspond to
one and only one member in D and each member of D corresponds to one and only one member of N. Due
to how axioms are stated, the structure symbol M = ⟨D, {P ′
1, P ′
2, . . .}⟩may include a set of distinguished
elements that correspond to distinguished constants in C. In this case, these constants are considered as
contained in N and correspond under I to ﬁxed members of D. [Only members of C appear in any member
of Pd.]
The rule you use to obtain the correspondences between the language symbols and the set theory objects
is called an interpretation. In general, M = ⟨D, {P ′
1, P ′
2, . . .}⟩is a structure for various interpretations and
includes distinguished elements.
Example 3.3.1 Let our language be constructed from a 1-place predicate P, a 2-place predicate Q
and two constants a, b. For the domain of our structure, let D = {a′, b′, c′}. Now correspond the one place
predicate P to the subset {a′, b′}. Let the 2-place predicate Q correspond to Q′ = {(a′, a′), (a′, b′)}. Finally,
let a correspond to a′ and b correspond to b′. The interpretation I can be symbolized as follows: I behaves
like a simple function. I takes the atomic portions of our language and corresponds then to sets. I(P) =
P ′, I(Q) = Q′, I(a) = a′, I(b) = b′, a, b ∈C.
Since the only members of Pd that will be considered as having a truth-value will be sentences, the
usual deﬁnition for the truth-value for members in Pd can be simpliﬁed. A level by level inductive deﬁnition,
similar to that used for the language L is used to obtain the truth-values for the respective sentences. This
will yield a valuation function v that is dependent upon the structure.
There is one small process that is needed to deﬁne properly this valuation process. It is called the free
substitution operator. We must know the scope of each quantiﬁer and the free variables in the formula that
is the scope.
Deﬁnition 3.3.2 (Free substitution operator) Let the symbol Sx
λ have a language variable as the
superscript and a language variable or language constant as a subscript. For any formula A ∈Pd, Sx
λA]
yields the formula where λ has been substituted for every free occurrence of x in A.
Example 3.3.2 Let A = ∀y(P(x, y) →Q(y, x)).
(i) Sx
y A] = ∀y(P(y, y) →Q(y, y))
(ii) Sx
xA] = ∀y(P(x, y) →Q(y, x)).
(iii) Sx
c A] = ∀y(P(c, y) →Q(y, c)).
Deﬁnition 3.3.3 (Structure Valuation for sentences). Given a structure M, with domain D, for a
language Pd.
72

(i) Suppose that P(
, . . . ,
) ∈Pd0 is an n-place predicate n ≥1, that contains only constants ci ∈N
in each of the places. Then M |= P(c1, . . . , cn) if and only if (c′
1, . . . , c′
n) ∈P ′, where for any ci ∈N,
c′
i = I(ci), and constants that denote special required objects such as “0” or “1” and the like denote ﬁxed
members of D and are ﬁxed members of D throughout the entire valuation process. Note that (c′
1) ∈P ′
means that c′
1 ∈P ′. [Often in this case, such a set constants is said to “satisfy” (with respect to M,)
the predicate(s) or formula.] Since we are only interested in “modeling” sentences, we will actually let the
“naming” subset N of C vary in such a manner such that I(N) varies over the entire set D.
(ii) If (i) does not hold, then M ̸|= P(c1, . . . , cn).
(iii) Suppose that for a level m, the valuation |= or ̸|= has been determined for formula A and B, and
speciﬁc members c′
i of D.
(a) M ̸|= A →B if and only if M |= A and M ̸|= B. In all other cases, M |= A →B.
(b) M |= A ↔B if and only if M |= A and M |= B, or M ̸|= A and M ̸|= B.
(c) M |= A ∨B if and only if M |= A or M |= B.
(d) M |= A ∧B if and only if M |= A and M |= B.
(e) M |= (¬A) if and only if M ̸|= A.
Take note again that any constants that appear in the original predicates have been assigned FIXED
members of D and never change throughout this valuation for a given structure. In what follows, d and d′
are used to denote arbitrary members of N and the corresponding members of D. Steps (f) and (g) below
show how the various constants are obtained that are used for the previous valuations.
(f) For each formula C = ∀xA, M |= ∀xA if and only if for every d′ ∈D it follows that M |= Sx
dA].
Otherwise, M ̸|= ∀xA.
(g) For each formula C = ∃xA, M |= ∃xA if and only if there is some d′ ∈D such that M |= Sx
dA].
Otherwise, M ̸|= ∃xA.
(iv) Note that for 1-place predicate P(x) (f) and (g) say, that M |= ∀xP(x) if and only if for each
d′ ∈D, d′ ∈P ′ and M |= ∃xP(x) if and only if there exists some d′ ∈D, such that d′ ∈P ′.
Please note that, except for the quantiﬁers, the valuation process follows that same pattern as the T s
and Fs follow for the truth-value valuation of the language L. Simply associate the symbol M |= A with
the T and the M ̸|= A with the F. Since every formula that is valuated is a sentence, we use the following
language when M |= A. The structure M is called a model for A in this case. If M ̸|= A, then we say that M
is not a model for A. This yields the same logical pattern as the “occurs” or “does not occur” concept that
can be restated as “as M models” or “as M does not model.” Deﬁnition 3.3.3 is informally applied
in that metalogical arguments are used relative to the informal notions of “there exists” and
“for each” as they apply to members of sets. For involved sentences, this process can be somewhat
diﬃcult.
In the appendix, it is shown that the process described in deﬁnition 3.3.3 is unique for every structure
in the following manner. Once an interpretation I is deﬁned, then all valuations that proceed as described
in deﬁnition 3.3.3 yield the exact same results. Deﬁnition 3.3.3 is very concise. To illustrate what it means,
let D = {a′, 0′}, A = P(x, y) →Q(x) and P ′, Q′ ∈M. It is determine whether M |= P(a, 0), M |=
P(a, a), M |= P(0, a), M |= P(0, 0), M |= Q(a),
M |= Q(0). Now we use these results to determine
whether M |= ∀x(P(x, 0) →Q(x)). This occurs only if M |= P(a, 0) →Q(a), M |= P(0, 0) →Q(0), where
we use the previous determinations.
Example 3.3.3 (a) Let A = (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))). Let the domain D = {a′} be a one
element set. We deﬁne a structure for A = (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))). Consider the 2-place relation
73

P ′ = {(a′, a′)} and the interpretation I(P) = P ′. As you will see later, one might try to show this by simply
assuming that M |= (∀x(∃yP(x, y))). But this method will only be used where M is not a speciﬁc structure.
For this example, we determine whether M |= (∀x(∃yP(x, y))) and whether M |= (∃y(∀xP(x, y))) and use
part (a) of deﬁnition 3.3.3. The valuation process proceeds as follows: ﬁrst we have only the one statement
that M |= P(a, a). Next, given each c′ ∈D, is there some d′ ∈D such that (c′, d′) ∈P ′? Since there
is only one member a′ in D and (a′, a′) ∈P ′, then M |= (∀x(∃yP(x, y))). Now we test the statement
∃y(∀xP(x, y)). Does there exist a c′ ∈D such that M |= Sy
c ∀xP(x, y)] = ∀xP(x, c); which continuing
through the substitution process, does there exists a c′ ∈D such that for all d′ ∈D in (d′, c′) ∈P ′. The
answer is yes, since again there is only one element in D. Thus M |= ∃y(∀xP(x, y)). Hence, part (v) (a) of
deﬁnition 3.3.3 implies that M |= A. Clearly, the more quantiﬁers in a formula the more diﬃcult it may be
to establish that a structure is a model for a sentence.
(b) A slighter weaker approach is often used. The informal theory of natural numbers is used as the
basic mathematical theory for the study of logical procedures. It’s considered to be a consistent theory since
no contradiction has been produced after thousands of years of theorem proving. Thus a structure can be
constructed from the theory of natural numbers. Let D = IN and there is two constants 1, 2 and one 3-placed
relation P ′ deﬁned as follows: (x, y, z) ∈P ′ if and only if x ∈IN, y ∈IN and z ∈IN and x + y = z. Using the
theory of natural numbers, one can very quickly determine whether M |= A for various sentences.
Consider A = ∀xP(c1, c2, x). Then let c1 = 1, c2 = 2. [Note that the subscripts for the constants
are not really natural numbers but are tick marks.] Now consider the requirement that for all a′ ∈IN,
M |= P(1, 2, a). Of course, since (1′, 2′, 5′) /∈P ′, then M ̸|= A. You will see shortly that this would imply
that A is not valid.
(c) Using the idea from (b), the sentence ∃x∀yP(x, y) has M =< IN, ≤> as a model. For there exists a
natural number x = 0 such that 0 ≤y for each natural number y.
Example 3.3.4 The following shows how the instructions for structure valuation can be more formally
applied.
For M = ⟨D, P⟩, let D = {a′, b′}, and P ′ = {(a′, a′), (b′, b′)}. we want to determine whether M |=
(∃y(∀xP(x, y))) →(∀x(∃yP(x, y))), and whether M |= (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))) and also if
M |= ∀x(∃xP(x, x).
First we look at whether M |= (∃y(∀xP(x, y)). This means that ﬁrst we establish that M |=
P(a, a), M ̸|= P(a, b), M |= P(b, b), M ̸|= P(b, a).
For the next stage we must determine whether (a) M |= ∀xP(x, a), (b) M |= ∀xP(x, b). Under the
substitution requirement, for (a) that (i) M |= P(a, a) and (ii) M |= P(b, a). However, M ̸|= P(b, a).
Thus for (a) M ̸|= ∀xP(x, a). In the same manner, it follows that for (b) M ̸|= ∀xP(x, b). Under the
substitution requirement Sy
d]∀xP(x, y) produces the two formula ∀xP(x, a), ∀xP(x, b) and if one or the
other or both satisfy |= then we know the M |= holds. But, from (a) and (b) we know this is not the
case so M ̸|= ∃y(∀xP(x, y)). Now from our understanding of the →connective this implies that M |=
(∃y(∀xP(x, y))) →(∀x(∃yP(x, y))).
Now consider ∀x(∃yP(x, y)). The ﬁrst step looks at ∃yP(a, y) and ∃yP(b, y). In both cases, we have
that M |= ∃yP(a, y) and M |= ∃yP(b, y). Hence, we have that M |= ∀x(∃xP(x, y)). But this now implies
that M ̸|= (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))).
This is how one “thinks” when making and arguing for these valuations and you can actually make the
substitution if D is a ﬁnite set and get a formula in Pd. The ∀can be replaced with a set of ∧symbols,
one for each member of D and the ∃can be replaced with a set of ∨symbols one for each member of D. It
follows easily that M |= ∀x(∃yP(x, y)) if and only if M |= (P(a, a) ∨P(a, b)) ∧(P(b, a) ∨P(b, b)).]
74

What about ∀x(∃xP(x, x))?
The substitution process says that under the valuation process this
∀x(∃xP(x, x)) is the same as ∃xP(x, x). The valuation process is ordered, ﬁrst we do the Sx
dP(x, x). This
gives under the ﬁrst step the formulas P(a, a), P(b, b). The second valuation process does not apply since
there are no free variables in ∃xP(x, x). The “or” idea for ∃yields that M |= ∀x(∃xP(x, x).
We now change the structure to D = {a′, b′}, and P ′ = {(a′, b′), (b′, a′)} and interpret this as same
before.
One arrives at the same conclusions that M ̸|= (∃y(∀xP(x, y)) and that M |= ∀x(∃xP(x, y)).
But, for this structure M ̸|= ∀x(∃xP(x, x)).
Hence, both structure are models for the sentences M |=
(∃y(∀xP(x, y))) →(∀x(∃yP(x, y))), ∀x(∃xP(x, x)). But for these three sentences, the second structure is
only a model for ∃y(∀xP(x, y))) →(∀x(∃yP(x, y))).
Note: A single domain and collection of n-place relations, in general, may have many interpretations.
This follows from considering interpretations that use diﬀerent members of D for the distinguished constants,
if any, and the fact that any number of n-placed predicates can be interpreted as the same n-place relation.
Thus for the above two structures if you have formula with ﬁve two-placed predicates, then you can interprete
them all to be P ′. However, if you are more interested in the logical behavior relative to a ﬁxed structure,
then in this case, such a formula with the ﬁve n-place predicates holds in this structure if and only if the
sentence you get by replacing the ﬁve predicates with one predicate P(x, y) holds in the structure. [If you
have diﬀerent distinguished constants in these predicates they still are diﬀerent in the place where you
changed the predicate symbol name to P.] The obvious reason for this is that the actual valuation does
not depend upon the symbol used to name the n-placed predicate (i.e. the P, Q, P1 etc.) but only on the
function and the relation that interpretes the predicate symbol. For this reason, sometimes you will see the
deﬁnition for an interpretation state that the correspondence between predicate symbols and relations be
one-to-one.
EXERCISES 3.3
1. In each of the following cases, write the formula that is the result of the substitution process.
(a) Sx
a (∃xP(x)) →R(x, y)]
(d) Sx
aSx
b (∃xP(x)) →R(x, y)]]
(b) Sy
x (∃yR(x, y)) ↔(∀xR(x, y))]
(e) Sx
aSy
x(∃yR(x, y)) ↔(∀xR(x, y))]]
(c) Sy
a (∀xP(y, x)) ∧(∃yR(x, y))]
(f) Sx
aSy
b (∀zP(y, x)) ∧(∃yR(x, y))]]
2. Let A ∈Pd. Determine whether the following is ALWAYS true or not. If the statement does not hold for
all formula in Pd, then give an example to justify your claim.
(a) Sx
aSy
b A]] = Sy
b Sx
aA]]
(c) Sx
y Sz
wA]] = Sz
wSx
y A]]
(b) Sx
y A] = Sy
xA]
(d) Sx
xSy
yA]] = A
3. Let D = {a′, b′}, the 1-place relation P ′ = {a′} and the 2-place relation Q′ = {(a′, a′), (a′, b′)}. For each
of the following sentences and interpretation of the constant c, I(c) = a′, determine whether M |= A, where
M = ⟨D, a′, P ′, Q′⟩.
(a) A = (∀x(P(c) ∨Q(x, x))) →(P(c) ∨∀xQ(x, x)).
(b) A = (∀x(P(c) ∨Q(x, x))) →(P(c) ∧∀xQ(x, x)).
(c) A = (∀x(P(c) ∨Q(x, x))) →(P(c) ∧∃xQ(x, x)).
(d) A = (∀x(P(c) ∧Q(x, x))) ↔(P(c) ∧∀xQ(x, x)).
(e) A = (∀x(P(c) ∧Q(c, x))) ↔(P(c) ∧∀xQ(x, x)).
75

3.4 Valid Formula in Pd..
Our basic goal is to replicate the results for Pd, whenever possible, that were obtained for L or L′.
What is needed to obtain, at the least, one ultralogic is a compactness type theorem for Pd.
Since we are restricting the model concept to the set of sentences S contained in Pd, we are in need of
a method to generate the simplest sentence for formula that is not sentence. Always keep in mind that
fact that a structure is deﬁned for all predicates and constants in a speciﬁc language Pd. In
certain cases, it will be necessary to consider special structures with special properties.
Deﬁnition 3.4.1 (Universal closure) For any A ∈Pd, with free variables x1, . . . , xn, (written in sub-
script order the universal closure is denoted by ∀A and ∀A = ∀x1(· · · (∀xnA) · · ·).
Obviously, if there are no free variables in A, then ∀A = A. In any case, ∀A ∈S. This fact will not
be mentioned when we only consider members of S. We will use the same symbol |=, as previously used, to
represent the concept of a “valid” formula in Pd. It will be seen that it’s the same concept as the T and F
concept for L.
Deﬁnition 3.4.2 (Valid formula in Pd.) A formula A ∈Pd is a valid formula (denoted by |= A) if for
every domain D and every structure M with an interpretation I for each constant in A and each n-placed
predicate in A, M |= ∀A.
A formula B is a contradiction if for every domain D and every structure M with an interpretation I
for each constant in A and each n-placed predicates in A, M ̸|= ∀A.
We show that this is an extension of the valid formula concept as deﬁned for L. Further, since every
structure is associated with an interpretaion, this will be denoted by MI.
Theorem 3.4.1 Let A, B, C ∈S. Suppose that |= A; |= A →B. Then |= B.
Proof. Suppose that |= A and |= A →B. Let MI be any structure for Pd. From the hypothesis,
MI |= A and MI |= A →B imply that MI |= B from deﬁnition 3.3.3 (consider the size (A →B) = m)
part (a).
In the metaproofs to be presented below, I will not continually mention the size of a formula for
application of deﬁnition 3.3.3.
Theorem 3.4.2 Let A, B, C ∈S. Then (i) |= A →(B →A), (ii) |= (A →(B →C)) →((A →B) →
(A →C)), (iii) |= ((¬A) →(¬B)) →(B →A).
Proof. (i), (ii), (iii) follow in the same manner as does theorem 3.4.1 by restricting structures to speciﬁc
formulas. Notice that every formula in the conclusions are members of S. We establish (iii).
(iii) Let MI be a structure for Pd. Assume that MI |= (¬A) →(¬B) for otherwise the result would
follow from deﬁnition 3.3.3. Suppose that MI |= ¬A and MI |= ¬B. Hence from deﬁnition 3.3.3, MI ̸|= A
and MI ̸|= B. Consequently, MI |= B →A ⇒MI |= ((¬A) →(¬B)) →(B →A) from deﬁnition 3.3.3.
Suppose that MI ̸|= (¬A). Then MI |= A ⇒MI |= B →A and in this ﬁnal case the result also holds.
Theorem 3.4.3 Let A be any formal theorem in L. Let
∗A be obtained by substituting for each
proposition Pi a member Ai ∈S. Then |= ∗A.
Proof. This follows in the exact same manner as the soundness theorem 2.15.2 for L′ extended to L
along with theorem 3.4.2.
Theorem 3.4.4 Let A ∈L and |= A as deﬁned in L′. Then |= ∗A as deﬁned for Pd.
Proof. This follows from the completeness theorem 2.15.1 for L′ extended to L and theorem 3.4.3.
76

What theorems 3.4.2 and 3.4.4 show is that we have a great many valid formula in Pd. However, is this
where all the valid formula come from or are there many valid formula in Pd that do not come from this
simple substitution process?
Example 3.4.1 Let A = P(x) →(∃xP(x)). Then ∀A = ∀x(P(x) →(∃xP(x))). Let MI denote a
structure for Pd. Suppose that MI ̸|= ∀A. Then there is some d′ ∈D such that MI ̸|= P(d) →∃xP(x).
Thus it most be that MI |= P(d) and MI ̸|= ∃xP(x). But this contradicts deﬁnition 3.3.3 (v) part (g).
Thus |= P(x) →(∃xP(x)). It’s relatively clear, due to the location of the ∀in the universal closure in the
formula, that there is no formula B ∈L′ such that ∗B = ∀A.
There are many very important valid formula in Pd that are not obtained from theorems 3.4.2 and 3.4.4.
To investigate the most important, we use the following variable predicate notation. Let A denote a formula
from Pd. Then there are always three possibilities for an x ∈V. Either x does not appear in A, x appears in
A but is not free in A, or x is free in A. There are certain important formula, at least for the proof theory
portion of this chapter, that are valid and that can be expressed in this general variable predicate language.
Of course, when such metatheorems are established, you need to consider these three possibilities.
With respect to our substitution operator Sx
λ, if A either does not contain the variable x or it has no
free occurrences of x, then Sx
λA] = A. Further it is important to note that the constant d that appears is a
general constant that is relative to a type of extended interpretation where it corresponds to some d′. But it
is not part of the original interpretation. This diﬀerence must be strictly understood.
Deﬁnition 3.4.3 (Free for) Let A ∈Pd. Then a variable v is free for x in A if the formula Sx
v A], at the
least, has free occurrences of v in the same positions as the free occurrences of x.
Example 3.4.2 Notice (i) that x is free for x in any formula A ∈Pd and Sx
xA] = A.
(ii) Further, if x does not occur in A or is not free in A, then any variable y is free for x in A and
Sx
yA] = A for any y ∈V. The only time one gets a diﬀerent (looking) formula that preserves free occurrences
through the use of the substitution operator Sx
λA] is when x is free in A and λ ∈V is free for x and λ ̸= x.
(iii) Let A = ∃yP(y, x). Then y is NOT free for x since Sx
y A] = ∃yP(y, y). You get a non-congruent
formula by this application of the substitution operator.
(iv) But z is free for x since Sx
z A] = ∃yP(y, z).
(v) If A = (∃xP(x, y)) →(∃yQ(x)), then y is NOT free for x since Sx
y A] = (∃xP(x, y) →(∃yQ(y)).
Again z is free for x.
Theorem 3.4.5 For any formula A with variables x1, x2, . . . , xn and only these free variables (where
the subscripts only indicate the number of distinct variables and not their subscripts in the set V), then for
any structure MI, MI |= ∀A if and only if for each c′
1 ∈D and for each c′
2 ∈D and · · · and for each c′
n ∈D,
MI |= Sx1
c1 Sx2
c2 . . . Sxn
cn A] . . .]].
Proof. From the deﬁnition of universal closure and deﬁnition 3.3.3.
Corollary 3.4.5.1 Under the same hypotheses as theorem 3.4.5, MI |= Sxi
ci Sxj
cj . . . Sxk
ck A] . . .]] for any
permutation (i, j, . . . , k) of the subscripts.
Theorem 3.4.6 Let y be free for x in A. Then Sy
dSx
y A]] = Sx
dSy
dA]].
Proof. The major argument to establish must of our validity results is dependent upon a rewording of
the substitution process. If there are any free occurrences of y, then x does not occur free at those places
that y occurs free in A. Substituting d for these speciﬁc free occurrences can be done ﬁrst. Then, each y
obtained by substituting for a free x, due to the fact that y is free for x, can be changed to a d by simply
substituting the d for the free occurrences x. This yields the left hand side of the equation where all free
77

occurrence of xs are changed to ys, any other free occurrence of y remains as it is, and then all the free
occurrences of y are changed to d.
Theorem 3.4.7 Suppose that A ∈Pd and y is free for x in A, then
(i) if x does not occur free in A, then for any structure MI for Pd, MI |= ∀(∀xA) if and only if
MI |= ∀A if and only if MI |= ∀x(∀A).
(ii) If x does not occur free in A, then for any structure MI for Pd, MI |= ∀(∃xA) if and only if
MI |= ∀A if and only if MI |= ∃x(∀A)
(iii) |= (∀xA) →Sx
yA]
(iv) |= Sx
y A] →(∃xA).
Proof. (i) Let MI be a structure for Pd. Suppose that MI |= ∀(∀xA). Since x is not free in A, then
from corollary 3.4.5.1, MI |= (∀x∀A) ⇒MI |= ∀A, since under the substitution process there is no free x
for the substitution.
Conversely, suppose that MI |= ∀A. Since x is not free in A, then again from corollary 3.4.5.1, MI |=
∀A ⇒MI |= ∀(∀xA) for the same reason.
(ii) This follows in the same manner as (i).
(iii) First suppose that x is not free in A. Then Sx
y A] = A. Let MI be a structure Pd and consider
the sentence ∀((∀xA) →A). Suppose that {x1, . . . , xn} are free variables in A. From 3.4.5, we must show
that MI |= Sx1
c1 · · · Sxn
cn ((∀xA) →A), where cj ∈D. However, making the actual substitutions yields that
Sx1
c1 · · · Sxn
cn ((∀xA) →A) = Sx1
c1 · · · Sxn
cn (∀xA)] · · ·] →Sx1
c1 · · · Sxn
cn A] · · ·] = ∀(∀xA) →∀A. We need only
suppose that MI |= ∀(∀xA). Then from (i), MI |= ∀A. But then MI |= ∀A →∀A from our deﬁnition 3.3.3.
Now assume that x is free in A. Note that x is not free in ∀xA, or in Sx
yA]. There are free occurrences
of y in Sx
yA] and there may be free occurrences of y in ∀xA. Any other variables that occur free in ∀xA, or
Sx
yA] are the same variables. Considering the actual substitution process for ∀((∀xA) →Sx
y A]) and using
corollary 3.4.5.1, we can permute all the other substitution processes for the other possible free variables
not y to be done “ﬁrst.” When this is done the positions that the arbitrary ds take yield ∀xC and Sx
y C, where
C contains the various symbols d in the place of the other possible free variables and that correspond to the
d′ ∈D. Consider ∀y((∀xA) →Sx
yC]). The valuation process for each d′ ∈D yields Sy
d((∀xC) →Sx
yC])] =
(∀xSy
dC]) →Sy
dSx
yC]] = (∀x(Sy
dC)) →Sx
dSy
dC]] = (∀xB) →Sx
dB, where B = Sy
dC]. Now simply assume that
MI |= ∀xB. Then for all d′ ∈D, MI |= Sx
dB]. From deﬁnition 3.3.3, d′ ∈D, MI |= (∀xB) →Sx
dB]. Since
d′ ∈D is arbitrary, we have as this point in the valuation MI |= ∀y((∀xA) →Sx
yC]). Multiple applications
of metalogic generalization as the d’s associated with the other free variables vary over D completes the
proof of part (iii) since MI is also arbitrary.
(iv) The same proof from (iii) for the case that x is not free in A holds for this case. Again in the same
manner as in the proof of part (iii), we need only assume that MI is a structure for Pd and for the formula
Sx
yC] →(∃xC), x or y are the only free variables in C and y is free for x. Consider ∀y((Sx
y C] →(∃xC)). Then
for arbitrary c′ ∈D, Sy
c (Sx
y C] →(∃xC)) = Sy
c Sx
y C]] →Sy
c ∃xC] = Sx
c Sy
c C]] →∃x(Sy
c C]) = Sx
c B →∃xB,
where B = Sy
c C]. Now if MI |= ∃xB. Then there exists some d′ ∈D such that MI |= Sx
dB. Hence, letting
c′ = d′, we have MI |= Sx
c B →∃xB. On the other hand, if MI ̸|= ∃xB, then for all d′ ∈D, MI ̸|= Sx
dB.
This implies that MI ̸|= Sx
c B. From deﬁnition 3.3.3, MI |= Sx
c B] →(∃xB). Since c is arbitrary, then
MI |= ∀y((Sx
y C] →(∃xC)). Again by multiple applications of generalization and since MI is an arbitrary
structure, the result follows.
There are many formulas in Pd that are not instances of valid propositional formula that may be of
interest to the pure logician. It’s not the purpose of this text to determine the validity of a member of Pd that
will not be of signiﬁcance in replicating within Pd signiﬁcant propositional metatheorems. However, certain
78

formula in Pd are useful in simplifying ordinary everyday logical arguments. The next two metatheorems
relate to both of these concerns.
Theorem 3.4.8 If x is any variable and B does not contain a free occurrence of x, then
(i) Special process and notation MI |= A.
(ii)
For
any structure MI
for Pd,,
let A
have free variables x1, . . . , xn.
Then MI
|=
¬(∀x1, . . . , (∀xnA) . . .) if and only if MI |= (∃x1, . . . , (∃xn(¬A)) . . .).
(iii) If MI |= B →A, then MI |= B →(∀xA).
(iv) If MI |= A →B, then MI |= (∃xA) →B.
Proof. (i) To determine whether or not MI |= A, where A is not a sentence, we consider whether or not
MI |= ∀A. First, corollary 3.4.5.1 indicates that the order, from left to right, in which we make the required
substitution has no signiﬁcance upon the whether or not MI |= ∀A. Note that after we write the, possibly
empty, sequence of statements “for each d′
1, for each d′
2, · · · , ∈D” the universal closure substitution
operators Sx1
d1 , Sx2
d2 , · · · distribute over all of the fundamental connections ∨, ∧, →, ↔, ¬. [Note
that one must carefully consider the statements “for each d′
1, for each d′
2, · · · , ∈D.”] What happens is that
when we have a variable that is not free in a subformula then the substitution process simply does not apply.
Further if the statements “for each d′
1, for each d′
2, · · · , ∈D” still apply to the entire formula and substitution
operators have not been eliminated, then we can go from basic subformula that contain a universal closure
substitution operators to the left of each subformula back to a universal closure for the entire composite
formula. After making these substitutions, we would have, depending upon the domain D, a large set of
objects that now carry the d’s (or c’s) in various places and that act like sentences. If these sentences satisfy
the requirements of MI |=, then by the metalogical axiom of generalization MI |= holds for the universally
closed formula.
For example, consider the hypotheses of this theorem and the formulas B →A, and B →(∀xA). To
establish the result in (iii), MI |= B →A means MI |= ∀(B →A). Hence, we have the, possibly empty,
sequence of statements for each d1 · · · , d ∈D, MI |= Sx1
d1 · · · Sx
d(B →A) holds. The valuation can be
rewritten as Sx1
d1 · · · Sx
dB →Sx1
d1 · · · Sx
dA ⇒Sx1
d1 · · · B →Sx
d(Sx1
d1 · · · A) = B′ →Sx
dA′. For the valuation
process B′ acts like a sentence and A′ acts like a formula with only one free variable, x. Thus, from our
observation about the metalogical process for quantiﬁcation over the members of D, if by simply consider
B to be a sentence, and A to have, at the most, one free variable x, it can be shown that MI |= B →∀xA,
then we have established, in general, that MI |= B →∀xA.
Thus, this type of argument shows that in many of our following arguments, relative to structures, we
can reduce the valuation process to a minimum number of free variables that are present within a speciﬁc
formula.
From this point on, unless otherwise stated, we will ALWAYS assume that MI means a
structure for Pd and MI |= A means MI |= ∀A
(ii) If we have no free variables in A, then we have nothing to prove. Assume that A has only one free
variable x. Suppose that MI |= (¬(∀xA)). This implies that MI ̸|= ∀xA. This means that there exists some
d′ ∈D such that MI ̸|= Sx
dA]. This implies that there exists some d′ ∈D such that MI |= (¬Sx
dA]) =
Sx
d(¬A)]. Hence MI |= (∃x(¬A)). Now apply induction.
Note: As well be seen in the following proofs, other conclusions hold that are not expressed in (iii) or
(iv). These restricted conclusions are presented since these are basic results even where the universal closure
is not used.
(iii) By the special process, assume that B is a sentence and that A has at the most one free variable
x. Let MI |= B →A. If A has no free variables, then A and B are sentences. The statement that for each
79

d′ ∈D, MI |= B →A and the statement for each d′ ∈D, MI |= B →Sx
dA] = B →A are identical and the
result holds in this case.
Suppose that x is the only free variable in A and B is a sentence. Then MI |= B →A means that, for
each d′ ∈D, MI |= Sx
d(B →A)] = B →Sx
dA]. This is but the valuation process for the formula B →(∀xA).
Hence MI |= B →(∀xA). (Assume MI |= B. Then MI |= Sx
dA] for each d′ ∈D implies MI |= ∀xA.)
(iv) Assume that B is a sentence and that A has, at the most, one free variable x. As was done in (iii),
if x is not free in A, the result follows. Assume that x is free in A and that MI |= A →B. Then this means
that, for each d′ ∈D, MI |= Sx
d(A →B)] = (Sx
dA]) →B. Hence, since D ̸= ∅, that there exists some d′ ∈D,
such that MI |= (Sx
dA]) →B. Consequently, by the special process, MI |= (∃xA) →B. This complete the
proof.
[Note: Parts (iii) and (iv) above do not hold if B contains x as a free variable. For an example, let
P(x) = A = B, D = {a, b}, P ′ = {a}. Assume that MI |= P(x) →P(x). Thus, for a, MI |= Sx
aP(x) →
P(x)] = P(a) →P(a) and, in like manner, MI |= P(b) →P(b). Since MI ̸|= P(b), then MI ̸|= ∀xP(x).
Hence, for the case d = a, we have that MI ̸|= P(a) →∀xP(x) ⇒MI ̸|= ∀(P(x) →∀xP(x)) ⇒MI ̸|=
P(x) →∀xP(x).]
An important aspect of logical communication lies in the ability to re-write expressions that contain
quantiﬁers into logically equivalent forms. The next theorem yields most of the principles for quantiﬁer
manipulation that are found in ordinary communication.
Theorem 3.4.9 For formulas A, B, C the following are all valid formulas, where C does not contain x
as a free variable.
(i) (∃x(∃yA(x, y)) ↔(∃y(∃xA(x, y)).
(ii) (∀x(∀yA(x, y)) ↔(∀y(∀xA(x, y)).
(iii) (¬(∃xA)) ↔(∀x(¬A)).
(iv) (¬(∀xA)) ↔(∃x(¬A)).
(v) (∃x(A ∨B)) ↔((∃xA) ∨((∃xB)).
(vi) (∀x(A ∧B)) ↔((∀xA) ∧(∀xB)).
(vii) (∀x(C ∨B)) ↔(C ∨(∀xB)).
(viii) (∃x(C ∧B)) ↔(C ∧(∃xB)).
Proof. (i) This follows from Theorem 3.4.5 and the fact that the expression “there exists some d′ ∈D
and there exists some c′ ∈D” is metalogically equivalent to “there exists some c′ ∈D and there exists some
d′ ∈D.” Consequently, for arbitrary MI |=, if MI |= (∃x(∃yA(x, y))), then MI |= (∃y(∃xA(x, y))) and
conversely.
(ii) This follows immediately by Corollary 3.4.5.1.
(iii) (Special process.) This follows from the assumption that x is the only possible free variable in A,
the propositional equivalent |= ¬(¬A) ↔A, and theorem 3.4.8 part (ii).
(iv) Same as in (iii).
(v) (Special process.) We may assume that the only possible free variables in A ∨B is the variable
x. Assume that for MI, an arbitrary structure and MI |= (∃x(A ∨B)). Then there exists some d′ ∈D
such that MI |= Sx
d(A ∨B)] = (Sx
dA] ∨Sx
dB]). Note that it does not matter whether the variable x is free
or not in A or B since this still holds whether or not a substitution is made. Hence, there exists some
d′ ∈D such that MI |= Sx
dA] or there exists at the least the same d′ ∈D such that MI |= Sx
dB]. Hence,
MI |= ((∃xA)∨(∃xB)). Now assume that MI ̸|= ∃x(A∨B). Thus, there does not exist any d′ ∈D such that
80

MI |= Sx
d(A ∨B)]. This means there does not exists any d′ ∈D such that MI |= (Sx
dA] ∨Sx
dB]). Therefore,
MI ̸|= ((∃xA) ∨(∃xB)). This result now follows.
(vi) Taking the proof of (v) and change the appropriate words and ∨to ∧this proof follows.
(vii) (Special process.) Assume that C does not have x as a free variable and that B may contain x
as a free variable. Further, it’s assumed that there are no other possible free variables. ∀x(C ∨B) is a
sentence. Let MI be an arbitrary structure. Assume that MI |= ∀x(C ∨B). Then for each d′ ∈D, MI |=
Sx
d(C ∨B)] = C ∨Sx
dB]. Hence, MI |= C or for each d′ ∈D, MI |= Sx
dB]. Hence, MI |= (C ∨(∀xB)). Then
in like manner, since x is not free in C, MI |= (C ∨(∀xB)) ⇒MI |= ∀x(C ∨B). [Note that this argument
fails if C and B both have x as a free variable. Since if MI |= ∀x(C ∨B), then considering any d′ ∈D we
have that MI |= Sx
d(C ∨B)] = Sx
dA] ∨Sx
dB] ⇒MI |= Sx
dC] or MI |= Sx
dB]. But both or these statement
need not hold for a speciﬁc d′ ∈D. Thus we cannot conclude that MI |= ∀xC or MI |= ∀xB. ]
(viii) Left as an exercised.
Obviously, theorems such as 3.4.9 would be very useful if the same type of substitution for valid formula
with the ↔in the middle holds for Pd as it holds in L or L′. You could simply substitute one for the
other in various places. Well, this is the case, just by simple symbolic modiﬁcations of the proofs of the
metatheorems 2.6.1, 2.6.2, 2.6.3, and corollary 2.6.3.1.
We list those results not already present as the
following set of metatheorems for Pd and for reference purposes.
Deﬁnition 3.4.4 (≡for Pd.) Let A, B ∈Pd. Then deﬁne A ≡B if and only if |= A ↔B. [See note
on page 138.]
Theorem 3.4.10 The relation ≡is an equivalence relation.
Proof. See note on page 38.
Theorem 3.4.11 If A, B, C ∈Pd and A ≡B, then CA ≡CB.
Proof. Let |= ∀(A ↔B). It can be shown that this implies |= ∀(CA ↔CB).
Corollary 3.4.11.1 If A, B, C ∈Pd and A ≡B, and |= CA, then |= CB.
With respect to A being congruent to B recall that all the formula have the exact same form, the exact
same free variables in the exact same places, and the bounded variables can take any variable name as long
as the formula retain the same bound occurrence patterns. Hence, structure valuation would yield the same
statement that either |= or ̸|=, holds for A and B. Also see note on page 38
Theorem 3.4.12 Suppose that A, B ∈Pd are congruent. Then A ≡B.
Theorem 3.4.13 Let A ≡B. Then MI |= A if and only if MI |= B.
Proof. From Deﬁnition 3.4.4, if A ≡B, then |= ∀A ↔∀B if and only if MI |= A implies MI |= B and
MI |= B implies MI |= A.
EXERCISES 3.4
1. A formula A is a said to be n-valid, where n is a natural number greater than 0, if for any structure MI,
with the domain containing n and only n elements, MI |= A.
(a) Prove that A = (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))) is 1-valid.
(b) A countermodel MI must be used to show that a formula A is not valid. You must deﬁne a structure
MI such that MI ̸|= A. Show by countermodel that the formula A in (a) is not 2-valid.
2. For each of the following, determine whether the indicated variable λ is free for x in the given formula A.
(a) A = ∀w(P(x) ∨(∀xP(x, y)) ∨P(w, x)); λ = y.
81

(b) A is the same as in (a) but λ = w.
(c) A = (∀x(P(x) ∨(∀yP(x, y)))) ∨P(y, x); λ = x.
(d) A is the same as in (c) and λ = y.
(e) A = (∀x(∃yP(x, y)) →(∃yP(y, y, )); λ = y.
(f) A = (∃zP(x, z)) →(∃zP(y, z)); λ = z.
3. For the formula in question 2, write Sx
λA] whenever, as given in each problem, λ is free for x.
4. Give a metaproof for part (viii) of theorem 3.4.9.
5. Determine whether the formula are valid.
(a) Q(x) →(∀xP(x)).
(d) (∃x(∃yP(x, y))) →(∃xP(x, x)).
(b) (∃xP(x)) →P(x).
(e) (∃xQ(x)) →(∀xQ(x)).
(c) (∀x(P(x) ∧Q(x))) →((∀xP(x)) ∧(∀xQ(x))).
6. A formula A is said to be in prenex normal form if A = Q1x1(Q2x2(· · · (Qnxn(A)) · · ·)), where Qi, 1 ≤
i ≤n is one of the symbols ∀or ∃. The following is a very important procedure. Use the theorems in this
or previous sections relative to the language L or Pd to re-write each of the following formula in a prenex
normal form that is equivalent to the original formula. [Hint. You may need to use the congruency concept
and change variable names. For example, ∀xP(x) →∀xQ(x) ≡∀xP(x) →∀yP(y) ≡∀y(∀xP(x) →Q(y)) ≡
∀y(Q(y) ∨(¬(∀xP(x)))) ≡∀y(Q(y) ∨(∃x(¬P(x)))) ≡∀y(∃x(Q(y) ∨(¬P(x)))).]
(a) (¬(∃xP(x))) ∨(∀xQ(x)).
(b) ((¬(∃xP(x))) ∨(∀xQ(x))) ∧(S(c) →(∀xR(x))).
(c) ¬(((¬(∃xP(x))) ∨(∀xQ(x))) ∧(∀xR(x))).
NOTE
It is not the case that |= ∀(A ↔B) ↔((∀A) ↔(∀B)). Let D = {a′, b′}, P ′ = {a′}, Q′ = {b′}.
Then MI ̸|= ∀x∀y(P(x) ↔Q(y)) since MI ̸|= P(a) ↔Q(a). However, since MI ̸|= P(b) implies that
MI ̸|= ∀xP(x) and MI ̸|= Q(a) implies that MI ̸|= ∀yQ(y), then MI |= (∀xP(x)) ↔(∀yQ(y)).
Using material yet to come, a way to establish Theorems 3.4.10 and 3.4.11 is to use the soundedness
and completeness theorem, the usual reduced language Pd′, and 14.7, 14.9 that appear in J.W. Robbin,
Mathematical Logic a ﬁrst course,W. A. Benjamin, Inc NY (1969) p. 48. I note that these results are
established in Robbin by use of formal axioms and methods that are identical with the ones presented in the
next section. [The fact that the deﬁnition of ≡via the universal closure is an equivalence relation follows
from the fact that for any formula C, ⊢(∀C) →C and ⊢∀(A ↔B) if and only if ⊢A ↔B. Also ⊢∀(A ↔
B) →(∀A) ↔(∀B) implies that if |= ∀(A ↔B), then |= (∀A) ↔(∀B). From ⊢∀(A ↔B) →(CA ↔CB),
if |= ∀(A ↔B), then ⊢(CA ↔CB) implies ⊢∀(CA ↔CB) implies |= ∀(CA ↔CB) implies CA ≡CB. Using
⊢∀(CA ↔CB) →((∀CA) ↔(∀CB)), we have that if A ≡B, and MI |= CA, then MI |= CB. The fact that
for congruent A and B that A ≡B also follows from ⊢A ↔B. ]
3.5 Valid Consequences and Models
As in the case of validity, the (semantical) deﬁnition for the concepts of a valid consequence and
satisfaction are almost identical to those used for the language L.
Deﬁnition 3.5.1 (Valid consequence for Pd.) A sentence B in Pd ( i.e. B ∈S) is a valid consequence
of a set of premises Γ ⊂S, which may be an empty set, if for any MI for Γ∪{B} whenever MI |= A for each
82

A ∈Γ, then MI |= B. This can be most easily remembered by using the following notation. Let Γ ⊂S. Let
MI |= Γ mean that MI |= A for each A ∈Γ. Then B is a valid consequence from Γ if whenever MI |= Γ,
then MI |= B, it being understood that MI is a structure for the set Γ ∪{B}. The notation used for valid
consequence is Γ |= B.
The concept of “satisfaction” also involves models and we could actually do without this additional
term.
Deﬁnition 3.5.2 (Satisfaction for Pd) A Γ ⊂S is satisﬁable if there exists a MI such that MI |= Γ.
Γ is not satisﬁable if no such structure exists.
As in the previous section, all of the results of section 2.8, 2.9 and 2.10 that hold for L also hold for this
concept extended to Pd. The following metatheorem contains processes that are not used in the metaproof
of its corresponding L language metatheorem. The remaining metatheorems follow in a manner very similar
to their counterparts in sections 2.8 — 2.10.
Theorem 3.5.1 (Substitution into valid consequences.) Let An, C, B ∈S.
(i) If An ≡C, and A1, · · · , An, · · · |= B, then A1, . . . , An−1, C, · · · |= B.
(ii) If B ≡C, and A1, · · · , An, · · · |= B, then A1, · · · , An, · · · |= C.
Proof.
(i)
Suppose
that
An
≡
C.
Let
MI
be
a
structure.
The MI
is
deﬁned
for
C, B, A1, . . . , An−1, An, · · · . Suppose that MI |= Ai for 1 ≤i.
Then MI |= B. But MI |= An if and
only if MI |= C. Consequently, if MI |= {A1, . . . , An−1, C, · · ·}, then MI |= B. [Notice that these state-
ments are conditional. If for any structure MI you get for any sentence A in the set of premises that MI ̸|= A
you can simply disregard the structure.]
(ii) Suppose that MI is a structure and that MI is deﬁned for B, C, A1, . . . , An, · · · . If MI |= Ai for
1 ≤i, then MI |= B. But MI |= C. From this the result follows.
Theorem 3.5.2 (Deduction theorem) Let A, B, Ai ∈S for 1 ≤i ≤n.
(i) A |= B if and only if |= A →B.
(ii) A, . . . , An |= B if and only if A1 ∧· · · ∧An |= B.
(iii) A, . . . , An |= B if and only if |= (A1 ∧· · · ∧An) →B.
(iv) A, . . . , An |= B if and only if |= (A1 →· · · →(An →B) · · ·).
As with the language L, consistency is of major importance. It is deﬁned by the model concept. The
metatheorems that follow the next deﬁnition are established the same manner as their counterparts for L.
Deﬁnition 3.5.3 (Consistency) A nonempty set of premises Γ ⊂S is consistent if there does not exist
a B ∈S such that Γ |= B ∧(¬B).
Theorem 3.5.4 If B ∈S, then ̸|= B ∧(¬B).
Theorem 3.5.5 A nonempty ﬁnite set of premises Γ ⊂S is inconsistent if and only if Γ |= B for every
B ∈S. (Based on the proof method for 2.10.3.)
Corollary 3.5.5.1 A nonempty ﬁnite set of premises Γ ⊂S is consistent if and only if there exists some
B ∈S such that Γ ̸|= B.
Corollary 3.5.6.1 A nonempty ﬁnite set of premises Γ ⊂S is consistent if and only if it is satisﬁable.
Even though we seem to have strong results that can be used to determine whether a sentence is a
valid consequence or that such a set is consistent, it turns out that it’s often very diﬃcult to make such
judgments for the language Pd. The reasons for this vary in complexity. One basic reason is that some sets
83

of premises tend to imply that the domain D is not ﬁnite. Further, when we made such determinations for
L, we have a speciﬁcally deﬁnable process that can be followed, the truth-table method. It can actually
be shown, that there is no known method to describe one ﬁxed process that will enable us to determine
whether a sentence is valid or whether a set of premises is consistent. Thus we must rely upon ingenuity
to establish by models these concepts. Even then some mathematicians do not accept such metaproofs as
informally correct since some claim that the model chosen is deﬁned in an unacceptable manner. The next
examples show how we must rely upon the previous deﬁnitions and metatheorems to achieve our goals of
establishing valid consequences or consistency. In some cases, however, no amount of informal argument will
establish the case one way or the other with complete assurance. I point out that these formal sentences are
translations from what ordinary English language sentences.
If you are given a ﬁnite set of premises A1, · · · , An then there are various ways to show that A1, · · · , An |=
B. One method is to use that Deduction Theorem and a general argument that |= A1 ∧· · · ∧An →B; the
propositional method of assuming that for a structure MI in general if ̸|= B, then ̸|= A1 or ̸|= A2. For the
invalid consequence concept, you have two choices, usually. Consider ANY structure MI such that MI ̸|= B
and show that this leads to each MI |= Ai, i = 1, . . . , n. However, to show that A1, · · · , An ̸|= B, it is often
easier to deﬁne a structure MI and show that MI |= Ai, i = 1, . . . , n, but that MI ̸|= B (i.e. the deﬁnition
for valid consequence does not hold.) Note that if there is no MI such that MI ̸|= B, then |= B.
Example 3.5.1. Consider the premises A1 = ∀x(P(x) →(¬Q(x))), A2 = ∀x(W(x) →P(x)), B =
∀x(W(x) →(¬Q(x))). We now (attempt) to determine whether |= A1 ∧A2 →B.
Let MI be any structure. First, let D be any nonempty domain and the P ′, Q′, W ′ be any subsets
of D (not including the possible empty ones). Suppose that MI̸|=∀x(W(x) →(¬Q(x))). Then there exists
some c′ ∈D such that MI̸|=Sx
c (W(x) →(¬Q(x)) = W(c) →(¬Q(c)). From our deﬁnition of what MI ̸|=
means, (*) MI |= W(c) (*) and that MI ̸|= ¬Q(c); which means that MI |= Q(c). This does not force any
of the premises to have a speciﬁc |= or ̸|=. Thus as done for the propositional calculus, let MI |= A2 =
∀x(W(x) →(¬Q(x)). Hence, for all d′ ∈D, we have that MI |= W(d) →P(d). Now c is one of the ds.
Hence, we have that MI |= W(c) →P(c). What does this do to A1? We show that MI ̸|= A1. Assume that
MI |= A1. Hence, for all d′ ∈D, MI |= P(d) →(¬Q(d)). Again this would give MI |= P(c) →(¬Q(c)). We
know that MI ̸|= ¬Q(c). Hence MI ̸|= P(c). Thus MI̸|=W(c). This contradicts the (*) expression. Hence,
MI̸|=A1. Now consider an empty W ′. Then MI |= ∀x(W(x) →(¬Q(x))). Consider Q′ empty and W ′ not
empty. Then MI |= ∀x(W(x) →(¬Q(x))). Hence, B is a valid consequence of A1, A2.
Example 3.5.2. Let A1 = ∃x(P(x) →Q(x)), A2 = ∀x(W(x) →P(x)), B = ∃x(W(x) →(¬Q(x))). Is
B a valid consequence of the premises? Well, we guess, that this might be an invalid consequence. We try
to ﬁnd a structure MI such that MI |= A1, MI |= A2 and MI ̸|= B. Let D = {a′}, P ′ = Q′ = W ′ = D.
There are no constants in the sentences A1, A2 or B. N contains only one constant a which is interpreted
as a′. Clearly, MI |= A1 and MI |= A2. But, MI |= W(a) and MI ̸|= (¬Q(a)). Consequently, MI ̸|= B.
[Note the diﬃculty would be to ﬁrst have a “feeling” that the argument from which these formula are taken
is not logically correct and then construct an acceptable structure that establishes this “feeling.” Not an
easy thing to do, if it can be done at all.]
Example 3.5.3. Let A = ∃y(∀xP(x, y)) and B = ∀x(∃yP(x, y). [In this case, P ′ cannot be the empty
relation, for if this were the case, then MI ̸|= A for an appropriate structure.] We try to show that A |= B
and get nowhere. So, maybe the A ̸|= B. Let’s see if we can obtain a countermodel. Let D = {a′, b′}. Let
P ′ = {(a′, b′), (b′, a′)}. Now extend this construction to a structure MI for Pd. Then for each d′ ∈D there
exists some c′ ∈D such that (c′, d′) ∈P ′, which implies that MI |= A. On the other hand, there does not
exists some d′ ∈D such that for each c′ ∈D, (c′, d′) ∈P ′. Hence, MI ̸|= B for this structure. Thus, B is
not a valid consequence of A. However, it can easily be shown that A is a valid consequence of B.
84

Example 3.5.4.
Determine whether A1 = ∀x(P(x) →(¬Q(x))), A2 = ∀x(W(x) →P(x)) is a
consistent set of premises. This is not very diﬃcult since we notice that if we construct a structure such that
for each d′ ∈D MI ̸|= P(d) and MI ̸|= W(d), then this structure would yield that the set is consistent.
Simply let P ′ and W ′ be the empty set (and extended the construction to all of Pd) and the conditions are
met. Thus the set of premises is consistent.
Example 3.5.5. Add the premise A3 = ∀x(¬P(x)) to the premises A1 and A2 in example 3.5.3. The
same structure yields MI |= A3. Thus this new set of premises is consistent.
Example 3.5.6. Determine whether A1 = ∀x(P(x)∧(¬Q(x)), A2 = ∀x(W(x)∧P(x)) form a consistent
set of premises. Clearly, using only empty sets for the relations will not do the job. Let D = {d′}. Now let
P ′ = W ′ = D and Q′ is the empty set. Then for all d′ ∈D, MI |= P(d), MI |= W(d), MI |= (¬Q(d)).
To show inconsistency, constructing models will not establish anything since we must show things don’t
work for any structure. The argument must be a general argument.
Example 3.5.7. Let A1 = ∃x(¬P(x)), A2 = ∀x(Q(x) →P(x)) and A3 = ∀xQ(x). Let MI be any
structure such that MI |= ∀xQ(x). Then whatever set Q′ ⊂D you select, it must have the property that for
all d′ ∈D, d′ ∈Q′. Hence, Q′ = D. Now if MI |= A2, then for all d′ ∈D, MI |= Q(p) →P(d). Thus for
all d′ ∈D, MI |= P(d) implies that d′ ∈P ′. Thus P ′ = D. It follows that there does not exist a member d′
of the set P ′ such that d′ is not a member of P ′. Thus MI ̸|= A1. Hence, the set of premises is inconsistent.
It might appear that it’s rather easy to show that sets of premises are or are not consistent, or that
sentences are valid consequences of sets of premises. But, there are sets of premises such as the 14 premises
discovered by Raphael Robinson for which it can be shown that there is no known way to construct a model
for these premises without assuming that the model is constructed by means that are either equivalent to
the premises themselves or by means that assume a set of premises from which Robinson’s premises can be
deduced. Such an obvious circular approach would not be accepted as an argument for the consistency of the
Robinson premises. The diﬃculty in determining valid consequences or consistency occurs when nonempty
n-place, n > 1, and nonﬁnite domains are needed to satisfy some of the premises. The only time you are
sure that your model will be accepted by the mathematical community for consistency argument is when
your model uses a ﬁnite domain. Robinson’s system, if it has a model, must have a domain that is nonﬁnite.
Further, the set of natural numbers satisﬁes the Robinson axioms.
Due to the above mentioned diﬃculties, it’s often necessary to consider a weaker form of the consistency
notion – a concept we term relative consistency. If you have empirical evidence that a set of premises Γ is
consistent, then they can be used to obtain additional premises that we know are also consistent. After we
show the equivalence of formal proof theory to model theory, then these premises can be used to construct
models.
Theorem 3.5.7 If a nonempty set of premises Γ is consistent and Γ |= Bi, where each Bi is sentence,
then the combined set of premises Γ ∪{Bi} is consistent.
Proof. From consistency, there is a structure MI such that for each A ∈Γ, MI |= A. But for MI we
also have that MI |= Bi for each i. Consequently, the structure MI yields the requirements for the set of
premises Γ ∪{Bi} to be consistent.
EXERCISES 3.5
1. The following are translations from what we are told are valid English language argument. Use the model
theory approach and determine if, indeed, the sentence B is a valid consequence of the premises.
(a) A1 = ∀x(Q(x) →R(x)), A2 = ∃xQ(x) |= B = ∃xR(x).
85

(b) A1 = ∀x(Q(x) →R(x)), A2 = ∃x(Q(x) ∧Z(x)) |= B = ∃x(R(x) ∧Z(x)).
(c) A1 = ∀x(P(x) →(¬Q(x))), A2 = ∃x(Q(x) ∧R(x)) |= B = ∃x(R(x) ∧(¬Q(x))).
(d) A1 = ∀x(P(x) →Q(x)), A2 = ∃x(Q(x) ∧R(x)) |= B = ∃x(R(x) ∧(¬Q(x))).
3.6 Formal Proof Theory
I hope to make the formal proof theory for this language as simple as possible. Again we will only do
formal proofs or demonstrations that will lead directly to our major conclusions. The language will be
Pd′ ⊂Pd, where no existential quantiﬁers appear. Later we will simply use the abbreviation ∃xA for
the expression ¬(∀x(¬A)). This will allow us to extend all the proof theoretic notions for Pd′ to Pd. Also
recall that the language Pd can actually be considered as constructed with the connectives ∧, ∨, ↔since
these were abbreviations for the equivalent propositional equivalent formula. (i) A ∨B is an abbreviation
for (¬A) →B. (ii) A ∧B is an abbreviation for (¬(A →(¬B))).
(iii) A ↔B is an abbreviation for
(A →B) ∧(B →A). From the semantics, these formula have the same pattern for |= as they have for
truth-values if it is assumed that A, B ∈L (say A, B ∈S.)
Deﬁnition 3.6.1 The language Pd′ is that portion of Pd in which no formula contains an existential
quantiﬁer.
Deﬁnition 3.6.2 (A formal proof of a theorem)
(1) Use the entire process as described in deﬁnition 2.11.2 for the language L′ with the following additions
to the axioms P1, P2, P3 and to the rule modus ponens.
(2) For predicate variables A, B (i.e. metasymbols for any formula) you may write down as any step
the formula
P4 :
∀x(A →B) →(A →(∀xB)) whenever x ∈V AND x is NOT free in A.
P5 :
(∀xA) →Sx
λA] whenever λ ∈V AND λ is free for x OR λ ∈C (the set of constants, if any.)
(3) You add one more rule of inference, the rule called generalization.
G(i). Taking any previous
step Bi, you may write down as a new step with a larger step number the step ∀xBi, for any x ∈V.
(4) If you follow the above directions and the last step in your formal proof is A then we call A a theorem
for Pd′ and denote this (when no confusing will result) by ⊢A.
The additional steps that can be inserted when we construct a formal demonstration from a set of
premises is exactly the same as in deﬁnition 2.12.1.
Deﬁnition 3.6.3 Let Γ be any subset of Pd′. Then a formal demonstration from Γ follows the exact
same rules as in deﬁnition 3.6.2 with the additional rule that we are allowed to insert as a step at any point
in the demonstration a member of Γ. If the last formula in the demonstration is A, then A is a deduction
from Γ and we denote this, when there is no confusion, by the symbol Γ ⊢A.
Of course, a formal proof of a theorem or a demonstration for a formula contains only a ﬁnite number
of steps. Do we already have a large list of formal proofs for formal theorems that can be used within the
proof theory for Pd′?
Theorem 3.6.1 Consider any formal proof in L′ for the L′ theorem A. For each speciﬁc propositional
variable within A, substitute a ﬁxed predicate variable at each occurrence of the propositional variable in A
to obtain the predict formula ˆA. Then for Pd′, we have that ⊢ˆA.
Proof. Simply take each step in the formal proof in L′ that ⊢A and make the same corresponding
consistent variable predicate substitutions. Since each axiom P1, P2, P3 and the MP rule are the same in
Pd′, this will give a formal proof in Pd′ for ⊢ˆA.
86

Theorem 3.6.2 Let Γ ⊂Pd′ and A, B ∈Pd′.
(a) If A ∈Γ or A is an instance of an axiom Pi, 1 ≤i ≤5, then Γ ⊢A.
(b) If Γ ⊢A and ⊢A →B, then Γ ⊢B.
(c) If ⊢A, then Γ ⊢A.
(d) If Γ is empty and Γ ⊢A, then ⊢A.
(e) If Γ ⊢A and D is any set of formula, then Γ ∪D ⊢A.
(f) If Γ ⊢A, then there exists a ﬁnite D ⊂Γ such that D ⊢A.
Proof. The same proof for theorem 2.12.1.
We now give an example of a formula that is a member of Pd′ and is not obtained by the method that
yields ˆA and is a formal theorem.
Example 3.6.1 For any 1-place predicate P(x) ∈Pd′
0, x, y ∈V, ⊢(∀xP(x)) →(∀yP(y)).
(1) (∀xP(x)) →P(y)
P5
(2) ∀y((∀xP(x)) →P(y))
G(1)
(3) ∀y((∀xP(x)) →P(y)) →((∀xP(x)) →(∀yP(y))
P4
(4) (∀xP(x)) →(∀yP(y))
M(1, 3)
It should be noted, that if x is not free in A, then P5 yields (∀xA) →Sx
yA] = (∀xA) →A, for any
λ ∈V ∪C, since the second A has had no changes made. Further, if x is free in A, then P5 yields (∀xA) →A.
Example 3.6.2 (Demonstration)
A →(∀xB) ⊢∀x(A →B)
(1) A →(∀xB)
Premise
(2) (∀xB) →Sx
xB] = (∀xB) →B
P5
(3) A →B
HS(1,2)
(4) ∀x(A →B)
G(3)
The rule that we have given for Generalization is not the only rule of this type that is used throughout
the literature. In particular, some authors deﬁne deduction from a set of premises in a slightly diﬀerent
manner than we have deﬁned it.
The reason for this depends upon how nearly we want the deduction
theorem for Pd′ to mimic the deduction theorem for L′, among other things. Also, note that the statement
that y is free for x, holds when x does not occur in A or does not occur free in A. The following two results
are useful in the sequel.
Theorem 3.6.3 If y is free for x in A ∈Pd′, then ∀xA ⊢∀ySx
y A].
(1) ∀xA
Premise
(2) (∀xA) →Sx
y A]
P5
(3) Sx
yA]
MP(1,2)
(4) ∀ySx
yA]
G(3)
Corollary 3.6.3.1 If y does not appear in A, then ∀ySx
yA] ⊢∀xA.
Proof. This follows since, in this case, y is free for x for y cannot be bound by any quantiﬁer and x is
free for y for Sx
yA. Further, A = Sy
xSx
y A]]. We now apply theorem 3.6.3. Hence, ∀ySx
yA ⊢∀xSy
xSx
yA]] = ∀xA.
87

Theorem 3.6.4 Let {x1, x2, . . . , xn} be any n free variables in A ∈Pd′. Then Γ ⊢A if and only if
Γ ⊢∀x1(∀x2(· · · (∀xnA) · · ·)).
Proof. Let n = 0. The result is clear.
Let n = 1. If Γ ⊢A has x1 as free, then by application of generalization on x1 we have that Γ ⊢∀x1A.
Suppose that result holds for n free variables and suppose that x1, . . . , xn+1 are free variables in A.
Then x1, . . . , xn are free variables in ∀xn+1A. Now if Γ ⊢A, then Γ∀xn+1A by generalization. Hence, from
the induction hypothesis, Γ ⊢∀x1(∀x2(· · · (∀xn+1A) · · ·)). Hence, by induction, for any n free variables in A
the result holds.
The converse follows by a like induction proof through application of P5 and one MP.
Corollary 3.6.3.1 For any A ∈Pd′, Γ ⊢A if and only if Γ ⊢∀A.
Theorem 3.6.5 For any A ∈Pd′, if x ∈V, then Γ ⊢A if and only if Γ ⊢∀xA.
Proof. Let Γ ⊢A. Then one application of generalization yields Γ ⊢∀xA.
Conversely, suppose that Γ ⊢∀xA. Then one application of ∀xA →Sx
xA = ∀xA →A followed by one
MP yields A.
EXERCISES 3.6
1. Complete the following formal demonstrations. Note that whenever P5 is applied, we write A for Sx
xA.
(A) ∀x(A →B), ∀x(¬B) ⊢∀x(¬A).
(1) ∀x(A →B)
. . . . . .
(2) ∀x(¬B)
. . . . . .
(3) . . . . . . . . . . . .
P5
(4) A →B
MP(
,
)
(5) (A →B) →((¬B) →(¬A))
Exer. 2.13, 2A.
(6) . . . . . . . . . . . .
MP(
,
)
(7) (∀x(¬B)) →(¬B)
. . . . . .
(8) ¬B
. . . . . .
(9) ¬A
. . . . . .
(10) . . . . . . . . . . . .
. . . . . .
(B) ∀x(∀yA) ⊢∀y(∀xA)
(1) . . . . . . . . . . . .
. . . . . .
(2) (∀x(∀yA)) →∀yA
P5
(3) . . . . . . . . . . . . . . .
MP(
,
)
(4) . . . . . . . . . . . .
P5
(5) A
MP(3,4)
(6) ∀xA
. . . . . .
(7) ∀y(∀xA)
. . . . . .
(C) A, (∀xA) →C ⊢∀xC
(1) . . . . . . . . . . . .
. . . . . .
(2) ∀xA
. . . . . .
88

(3) . . . . . . . . . . . .
. . . . . .
(4) C
MP(2,3)
(5) ∀xC
. . . . . .
(D) ∀x(A →B), ∀xA ⊢∀xB
(1) . . . . . . . . . . . .
Premise
(2) . . . . . . . . . . . .
Premise
(3) . . . . . . . . . . . .
P5
(4) A →B
MP(
,
)
(5) (∀xA) →A
. . . . . .
(6) A
MP(2,5)
(7) B
. . . . . .
(8) ∀xB
. . . . . .
3.7 Soundness and Deduction Theorem for Pd′.
Although the model theory portions of this text have been restricted to sentences, this restriction is
technically not necessary. Many authors give valuation processes for any member of Pd′. This yields certain
complications that appear only to be of interest to the logician. In the sciences, a theory is determined by
sentences. These are language elements that carry a deﬁnite “will occur” or “won’t occur” content. As far
as relations between proof theory concepts and the model theory concepts, we consider Γ ⊢A, where the
elements need not be sentences. But for our model theory, we, at the least, require that each member of
Γ is a sentence and can always let A be a sentence when Γ |= A is considered. When the notation MI
is employed, it will be assume that MI is a structure for Pd′. Further, unless it is necessary, we will not
mention that our language variable are member of Pd′. Next is an important relation between a model and
a formal demonstration.
Theorem 3.7.1 (Soundness Theorem) Suppose that Γ ⊂S, MI |= Γ, and Γ ⊢A. Then MI |= A
(i.e. MI |= ∀A.)
Proof. In this proof, we use induction on the steps {Bi | i = 1, . . . , n} in a demonstration that Γ ⊢A,
and show that MI |= ∀Bi.
Case (n = 1, 2, 3). Let n = 1. Suppose that B1 is an instance of axioms P1, P2, P3. First, recall
the special process (i) of theorem 3.4.8. Thus, to establish that MI |= Pi, we may consider the language
variables as being sentences. Now simply replicate the proof for theorem 3.4.2.
Suppose that C = ∀xB →Sx
λB] is an instance of axiom P5. Again we need only assume that x is the
only free variable in B. Suppose that λ = y is free for x in B. Then theorem 3.4.7 (iii) yields the result.
Let the substitution in P5 be a constant λ = c. Suppose that MI |= ∀xB. Then for all d′ ∈D, MI |= Sx
dB.
In particular, MI |= Sx
c B. We leave it as an exercise, to show that if C is an instance of axiom P4, then
MI |= C. Finally, suppose that C ∈Γ. Then MI |= Γ means that MI |= C.
Suppose n = 2 and B2 = ∀xB. Then for the case n = 1, B1 = B and MI |= B means that MI |= ∀B.
Hence, MI |= ∀(∀xB).
Suppose that n = 3 and B3 = C is an MP step. Then for the two previous steps, we have that MI |= B
and MI |= B →C. From deﬁnition 3.3.3 and the special process, MI |= C.
Case (n + 1 > 3). Assume the induction hypothesis that the result holds for any proof with n or less
steps. Consider a proof with n + 1 steps. Now let C = Bn+1. If C is an instance of any of the axioms, then
89

the result follows as in the case where n = 1. Suppose that C comes from two previous steps, Bi = B and
Bj = B →C by MP. By induction and the case n = 3 process, we have that MI |= C. Now suppose that
C = ∀xB is an instance of generalization. By induction and the case n = 2 process, we have that MI |= C.
Finally, for the case that C ∈Γ, the result follows as in case n = 1. The complete result follows by induction.
Corollary 3.7.1.1 If ⊢A, then |= A.
Of course, the importance of theorem 3.7.1 lies in desire that whatever is logically produced by the
mind using scientiﬁc logic will also hold “true” for any model for which each of the hypotheses hold “true.”
This is the very basis for the scientiﬁc method assumption that human deductive processes
correspond to natural system behavior. Before we can establish a converse to theorem 3.7.1 and with
it the very important “compactness” theorem, a deduction-type theorem is required. This theorem, however,
will not completely mimic the deduction theorem for the language L′.
Theorem 3.7.2 (Deduction theorem for Pd′.) Let Γ ⊂Pd′, A, B ∈Pd′. If Γ, A ⊢B and the
demonstration for B contains no application of Generalization for a variable free in A, then Γ ⊢A →B.
Proof. We use all the methods described in the metaproof of theorem 2.13.1, the deduction theorem
for L′. Proceed by induction exactly as done in theorem 2.13.1 and replace the axioms P1, P2, P3, P4, R5
with steps that lead to A →C, no new step contains the single formula A. Now if A appears as a step then
this formula as been replaced by a A →A. This leaves the MP and Generalization steps to replace. Now
re-number (i.e. count) these steps with their original ordering as G1, . . . , Gn. We now consider the induction
process on these steps.
Case n = 1. Suppose that G1 is an MP step. Then alter this step to produce other steps as done in the
metaproof of theorem 2.13.1. Now suppose that G1 = ∀yB, where B is from one of the previous original
steps and was not obtained by generalization or MP. However, the original steps have all be replaced by
A →B. Between this new step and the step G1 insert the following three steps.
(1) ∀y(A →B)
Generalization
(2) ∀y(A →B) →(A →(∀yB))
P4
(3) A →∀yB
M(1,2)
[Notice that the insertion of step (2) requires that y not be free in A.]
Now remove the original step
G1 = ∀yB.
Case (n+1) Assume that all the alterations have been made for G1, . . . , Gn steps. If Gn+1 is MP, proceed
in the same manner as in theorem 2.13.1. Suppose that Gn+1 = ∀yB, where B comes from an original step.
However, by induction all of the previous steps Bi, i ≤n have been replaced by A →Bi. Consequently,
using this altered step, proceed as in case n = 1 to obtain the formula A →∀yB that replaces step Gn+1.
By induction, all the original steps have been changed to the form A →B and A does not appear as a step
in our new demonstration. The last step in our old demonstration was B and it now has been changed to
A →B. Hence the theorem has been proved.
Corollary 3.7.2.1 Let {A1 . . . , An} ⊂S and A1 . . . , An ⊢B. Then ⊢(A1 →(A2 →· · · (An →B) · · ·)).
Theorem 3.7.3 Let Γ ⊂Pd′, A, B ∈Pd′. If Γ, ⊢A →B, then Γ, A ⊢B.
Proof. The proof is the same as in theorem 2.13.1.
Corollary 3.7.3.1 If ⊢(A1 →(A2 →· · · (An →B) · · ·)), then A1, . . . , An ⊢B.
Theorem 3.7.4 Let {A1, . . . , An} ⊂S. Then A1, . . . , An ⊢B if and only if ⊢(A1 →(A2 →· · · (An →
B) · · ·)).
90

We now show why the deduction theorem must be stated with the additional restriction.
Example 3.7.1 First, it is obvious that P(x) ⊢∀xP(x). Just do the two step demonstration with the
premise as the ﬁrst step, and generalization in x as the second step. Now to show that ̸⊢P(x) →∀xP(x).
Suppose that we assume that ⊢P(x) →∀xP(x). Consider the follows formal proof.
(1) ⊢P(x) →∀xP(x)
Given
(2) ⊢(B →A) →((¬A) →(¬B))
(A) page 83.
(3) ¬(∀xP(x)) →(¬P(x))
MP(1,2)
(4) ∀x(¬(∀xP(x)) →(¬P(x)))
G(3)
(5) ∀x(¬(∀xP(x)) →(¬P(x))) →(¬(∀xP(x)) →(∀x(¬P(x))))
P4
(6) ¬(∀xP(x)) →(∀x(¬P(x)))
MP(4,5)
Now by the soundness theorem for Pd′ (6) yields |= ¬(∀xP(x)) →(∀x(¬P(x))). Consider the structure
MI where D = {a′, b′}, and P ′ = {a′}. Suppose that MI |= ¬(∀xP(x)). This means that it is not the
case that a′ ∈P ′, or that b′ ∈P ′. Since b′ /∈P ′, then MI |= ¬(∀xP(x)). But MI ̸|= ∀x(¬P(x)) for
this means that for a′ and b′ we must have that a′ /∈P ′ and b′ /∈P ′ which is not the case.
Hence,
̸|= ¬(∀xP(x)) →(∀x(¬P(x))). This contradiction shows that ̸⊢¬(∀xP(x)) →(∀x(¬P(x))). Thus the use of
the unrestricted deduction theorem to go from P(x) ⊢P(x), where we used generalization on x, to obtain
P(x) ⊢∀xP(x), then to ⊢P(x) →∀xP(x) is in error.
EXERCISES 3.7
1. Show that if A ∈Pd′, and A is an instance of axiom P4. Then |= A.
3.8 Consistency, Negation completeness and Compactness.
Almost all of the sciences, engineering and any discipline which must determine whether or not some-
thing “will occur” or “won’t occur,” use ﬁrst-order languages to describe behavior. The material in this
section covers the most important of all of the ﬁrst-order language concepts. The ramiﬁcations of these
investigations, some completed only 2 years ago, cannot be over stated. Many individuals who ﬁrst obtained
the results presented next, became, over night, world famous ﬁgures within the scientiﬁc community due to
the signiﬁcance of their ﬁndings. The conclusions in the next section on applications, can only be rigorously
obtained because of the results we next present.
Deﬁnition 3.8.1 A set of sentences Γ ⊂S is (formally) consistent if there does NOT exist a sentence
B ∈S such that Γ ⊢B and Γ ⊢¬B.
A set of sentences Γ ⊂S is inconsistent if it is not consistent.
A set of sentences Γ ⊂S is (negation) complete if for every B ∈S either Γ ⊢B or Γ ⊢¬B.
Theorem 3.8.1 A set of sentences Γ is inconsistent if and only if for every B ∈Pd′, Γ ⊢B.
Proof. First, suppose that Γ is inconsistent. Then there is some B ∈S such that Γ ⊢B and Γ ⊢¬B.
Hence there are two demonstrations that use ﬁnitely many members of Γ and yield the ﬁnal steps B and
¬B. Put the two demonstrations together, and let B appear as step i and ¬B appear as step Bj. Now, as
the next step, put the formal theorem (from the propositional calculus) ⊢¬B →(B →A) from Exercise
2.11 problem 2b, where A is ANY member of Pd′. Now two MP steps yields the formula A.
Suppose that for any formula C ∈Pd′, it follows that Γ ⊢C. Thus take any sentence B, where ¬B ∈S
also. Then Γ ⊢B and Γ ⊢¬B.
91

What theorem 3.8.1 shows is that if Γ is inconsistent, then there is an actual logical argument that
leads to ANY pre-selected formula. The logical argument is correct. But the argument cannot diﬀerentiate
between the concepts of “will occur” or “won’t occur.” Indeed, any scientiﬁc theory using such an argument
would be worthless as a predictor of behavior. Well, is it possible that our deﬁnition for logical deduction
without premises is the problem or must it be the premises themselves that lead to the serious theorem 3.8.1
consequences?
Theorem 3.8.2 There does not exist a formula B ∈Pd′ such that ⊢B and ⊢¬B.
Proof. Suppose that there exists a formula B such that ⊢B and ⊢¬B. Using the same process as used
in theorem 3.8.1, but only assuming that B ∈Pd′, it follows that for any sentence A ∈Pd′, ⊢A. Hence
⊢∀A. Thus by corollary 3.7.1.1, for any structure MI we have that MI |= ∀A. But the sentence in step (5)
of example 3.7.1, does not have this property. The result follows from this contradiction.
Thus the diﬃculties discussed after theorem 3.8.1 are totally caused by the premises Γ and not caused
by the basic logical processes we use. However, if it’s believed that a set of sentences in consistent, then we
might be able to obtain a larger consistent set.
Theorem 3.8.3 Let Γ ⊂S be a consistent. Suppose that Γ ̸⊢B ∈Pd′. Then Γ, (¬∀B) is consistent.
Proof. Assume that there exists some sentence C such that (a) Γ, (¬∀B) ⊢C and (b) Γ, (¬∀B) ⊢¬C.
Now from the propositional calculus (c) ⊢(¬C →(C →∀B) and, hence, this holds for Pd′. Using both
demonstrations (a) and (b), and inserting them as steps in a demonstration, adjoin the step (¬C) →(C →
∀B). Two MP steps, yield that Γ, ¬∀B ⊢∀B. Since ¬∀B is a sentence, then the deduction theorem yields
Γ ⊢(¬∀B) →∀B. Now adjoin the steps for the ⊢((¬∀B) →∀B) →∀B. One more MP step yields the
contradiction that Γ ⊢∀B ⊢B.
Corollary 3.8.3.1 Suppose that Γ is any set of sentences and B is any sentence. If Γ, ¬B is inconsistent,
then Γ ⊢B. If Γ, B is inconsistent, then Γ ⊢¬B.
Proof. If Γ is inconsistent, then the result follows. If Γ is consistent, then the result follows from the
contrapositive of theorem 3.8.3. The second part follows from ¬(¬B) ⊢B and B ⊢¬(¬B).
Theorem 3.8.4 If consistent Γ ⊂S, then there is a language Pd′′ that contains all of the symbols of
Pd′, but with an additional set of constants and only constants adjoined, and a set of sentences Γ′′ ⊂Pd′′
such that Γ ⊂Γ′′ and Γ′′ is consistent and negation complete.
Proof. See appendix.
We now come to the major concern of this section, an attempt to mimic, as close as possible, the com-
pleteness and consistency results for L′. In 1931, G¨odel, in his doctoral dissertation, convincingly established
his famous “completeness” theorem for Pd′ by showing for the natural number domain that ⊢B if and only
if |= B. Since that time G¨odel’s methods have been highly reﬁned and simpliﬁed. Indeed, totally diﬀerent
methods have achieved his results as simple corollaries and these new methods have allowed for a greater
comprehension of the inner workings of structures and models.
Theorem 3.8.5 If consistent Γ ⊂S, then there exists a structure MI for Pd′ such that Γ ⊢A if and
only if MI |= ∀A. Further, the domain of MI is in one-to-one correspondence with the natural numbers.
Proof. See appendix.
Corollary 3.8.5.1 (G¨odel) Let A ∈Pd′. ⊢A if and only if |= A.
Proof. Let Γ = ∅. Assume that ⊢A. Corollary 3.7.1.1 to the soundness theorem yields |= A.
92

Conversely, assume that ̸⊢A. Then ̸⊢∀A. Thus the set {¬(∀A)} is consistent by theorem 3.8.3. Hence,
from 3.8.5, there exists a structure MI such that MI |= {¬(∀A)}. Consequently, MI ̸|= ∀A. Thus ̸|= A.
Due to corollary 3.8.5.1, the abbreviations we have used that yield quantiﬁers ∃x, and abbreviations for
the connectives ∨, ∧, ↔all have the correct properties with respect to |= as they would under the truth-value
deﬁnitions for L. This allows us to use the more expressive language Pd rather than Pd′.
Theorem 3.8.6*** A nonempty set of sentences Γ ⊂Pd is consistent if and only if Γ has a model.
Proof. Let Γ be consistent. For each A ∈Γ, Γ ⊢A. Theorem 3.8.5 yields that there is a structure MI
such that MI |= A for each A ∈Γ. Hence MI is a model for Γ.
Conversely, assume that MI is a model for Γ and that Γ is inconsistent. Then let B be any sentence.
Then Γ ⊢B and Γ ⊢¬B. Hence the soundness theorem would imply that MI |= B and MI |= ¬B. This
contradicts deﬁnition 3.3.3 part (e).
Theorem 3.8.7 (Extended Completeness) If Γ ⊂Pd is a set of sentences, B is a sentence and Γ |= B,
then Γ ⊢B.
Proof. Let Γ |= B and Γ is not consistent. Then Γ ⊢B. So assume Γ is consistent and that Γ ̸⊢B. Then
from theorem 3.8.3, the set of sentences {Γ, ¬B} is consistent. Thus {Γ, ¬B} has a model MI. Therefore,
MI ̸|= B. But MI |= Γ. Hence MI |= B. This contradiction yields the result.
We now come to one of the most important theorems in model theory.
This theorem would have
remained the only why to obtain useful models if other methods had not been recently devised. It’s this
theorem we’ll use in the next section on applications.
Theorem 3.8.8 (Compactness) A nonempty set of sentences Γ ⊂Pd has a model if and only if every
ﬁnite subset of Γ has a model.
Proof. Assume that Γ has a model MI. Then this is a model for any ﬁnite subset of of Γ. [Note: it’s a
model for an empty set of sentences since it models every member of such a set. (There are none.)]
Conversely, suppose that Γ does not have a model. Then Γ is inconsistent. Hence, taken any sentence
B ∈Pd. Then there are two ﬁnite subsets F1, F2 of Γ such that F1 ⊢B and F2 ⊢¬B. Thus the ﬁnite subset
F = F1 ∪F2 is inconsistent. Hence F has no model. This completes the proof.
Important Piece of History
It was convincingly demonstrated in 1931 by G¨odel that there probably is no formal way to demonstrate
that signiﬁcant mathematical theories are consistent. For example, with respect to set-theory, the only known
method would be to establish a contradiction that is not forced upon set-theory by an actual demonstrable
error on the part of an individual.
All mathematical and scientiﬁc theories can be stated in the ﬁrst-
order language of set-theory. There are approximately 50,000 research papers published each year in the
mathematical sciences. No inconsistencies in modern set-theory itself has ever been demonstrated. The
number theory we have used to establish all of the conclusions that appear in this book is thousands of
years old and again no contradiction has ever been demonstrated. The theory of real numbers is hundreds of
years old and no contradictions in the theory have ever been demonstrated. The speciﬁc axiomatic systems
and logical procedures used to establish all of our results have never been shown to produce a contradiction.
What all this tends to mean is that empirical evidence demonstrates that our basic mathematical theories
and logical processes are consistent. Indeed, this evidence is more convincing than in any other scientiﬁc
discipline. This is one reason why science tends to utilize mathematical models.
Example 3.8.1 Let N be the set of axioms for the natural numbers expressed in a set-theoretic
language. Let Pd be the ﬁrst-order language that corresponds to N. Then the theory of natural numbers
93

is the set of sentences Γ = {B | B ∈S, N ⊢B}. This set Γ is assumed, from evidence, to be consistent.
Hence from theorem 3.8.6 there exists a structure MI such that MI |= Γ. This means from the deﬁnition
of MI |= Γ that there is a set of constants that name each member of the domain of the structure. This
domain is denoted by the symbol IN. There are also n-ary predicate symbols for the basic relations needed
for the axiom system and for many deﬁned relations.
We interpret P(x, y) as the “=” of the natural numbers in IN. Depending upon the structure, this could
be the simple identity binary relation P(x, x). Now we come to the interesting part.
Let our language
constants C be the constants naming all the members c′ of IN and adjoin to C a new constant b not a
member of C. Consider the sentences Φ = {¬P(c, b) | c ∈C} that are members of a ﬁrst-order language Pdb
that is exactly the same as Pd except for adjoining one additional constant b. Now consider the entire set of
sentences Γ∪Φ. What we will do is to show that Γ∪Φ has a model, ∗MI, by application of the compactness
theorem.
Take any ﬁnite set A of members of Γ∪Φ. If each member of A is a member of Γ, then MI is a model for
A. Indeed, if {a1, . . . , an} are all the members of A that are members of Γ, then again MI |= {a1, . . . , an}.
So, assume that {an+1, . . . , am} are the remaining members of A that may not be recognized as members of
Γ. Well, there are only ﬁnitely many diﬀerent constant {cn+1, . . . , cm} that are contained in these remaining
sentences in A. The theory of natural numbers states that given any nonempty ﬁnite set of natural numbers,
there is always another natural number c′ that is not equal to any member of this ﬁnite set. These constants
correspond to a ﬁnite set of natural numbers {c′
n+1, . . . , c′
m} and interpret b to be one of the natural numbers
c′. This process of interpreting, for a domain of the original structure, the one additional
constant as an appropriate domain member is a general procedure that is usually needed
when the compactness theorem is to be used. Thus each of the remaining sentences is modeled by
MI. The compactness theorem states that there is a structure ∗MI such that ∗MI |= Γ ∪Φ. Thus there
is a domain D and various n-place relations that behave exactly like the natural numbers since Γ is the
theory of the natural numbers and ∗MI |= Γ. Indeed, the interpretation I restricted to the original set of
constants yields an exact duplicate of the natural numbers and we denote this duplicate by same symbol
IN. But there exists a member of the domain D of this structure, say b′, such that for each c′ ∈IN, b′ ̸= c′.
But for every original c′ we have that c′ = c′. Therefore, we have a structure that behaves, as described by
Pdb, like the natural numbers, but contains a new member that does not correspond to one of the original
natural numbers. [End of example.]
I give but two exercise problems for this section, each relative to showing that there exists mathematical
structures that behave like well-known mathematical structures but that each contains a signiﬁcant new
member with a signiﬁcant new property.
EXERCISES 3.8
1. Modify the argument given in example 3.8.1 as follows: let L(x, y) correspond to the natural number
binary relation of “less than” (i.e. <). Give an argument that shows that there is a structure ∗MI that
behaves like the natural numbers but in which there exists a member b′ that is “greater than” any of the
original natural numbers. [Note: this solves the “inﬁnite” natural number problem by showing that there
exists a mathematical object that behaves like a natural number but is “greater than” every original natural
number.
2. Let IR denote the set of all real numbers. Let C be a set of constants naming each member of IR.‡ Suppose
that b is a constant not a member of C. Let Γ be the theory of real numbers. Let Q(0, y, x) be the 3-place
‡ The assumption is that the theory of real numbers is a consistent theory and, hence, has a model.
The proofs of Theorems 3.8.4 and 8.8.5 in the appendix, show that such a theory has a model with a
94

predicate that corresponds to the deﬁnable real number 3-place relation 0′ < c′ < d′, where 0′, c′, d′ ∈IR.
Now in the real numbers there is a set of elements G′ such that each member c′ of G′ has the property that
0′ < c′. Let G be the set of constants that correspond to the members of the set G′. Consider the set of
sentences Φ = {Q(0, b, g) | g ∈G} in the language Pdb. Give an argument that shows that there exists a
structure ∗MI such that
∗MI |= Γ ∪Φ. That is there exists a mathematical domain D that behaves like
the real numbers, but D contains a member b′ such that b′ is “greater than zero” but b′ is “less than” every
one of the original positive real numbers. [Note: this is an example of an inﬁnitesimal and solves the three
hundred year old problem of Leibniz, the problem to show the mathematical existence of the inﬁnitesimals.
These are objects that behave like real numbers but are not real numbers since they are greater than zero
but less than any positive real number.]
The method used in this section and the next to obtain these “nonstandard” objects has been greatly
improved over the years. The method presented here relies upon the assumption that the theory of real
numbers and the theory of propositional deduction are consistent theories and, hence, have models. Also
other processes have been employed that , although correct, may need further justiﬁcation.
Since the
middle and late 1960s, algebraic methods have been used to ﬁrst obtain structures associated with ﬁrst-
order statements.
One structure, the standard structure M, would be based upon predicates that are
present within statements about the real numbers or, as explained in the next section, the ﬁrst-order theory
of propositional deduction.
Another structure that can be considered as containing M and termed an
“enlargement,” ∗M, is then constructed. These constructions do require the acceptance of an additional
set-theoretical axiom. To obtain the various nonstandard objects discussed in this and the next section, all
that is needed is to have enough real number or propositional deduction statements hold in the standard
structure.
This will immediately show that the nonstandard objects, the inﬁnitesimals, ultrawords and
ultralogics, mathematically exist within the ∗M.
Due to the signiﬁcance of exercise problem 2 above, the following slightly more general result is estab-
lished here.
The following convention is used. The symbols used to denote constants and predicates will also be
used to denote the members of the domain and relations in a structure MI. Let Γ be the theory of real
numbers IR. This theory includes all of the deﬁned relations and all possible deduced sentences, etc. For
this example, there is a 1-place predicate P(x) that is modeled by the set of all positive real numbers
P = {x | (0 < x) ∧(x ∈IR)}, where 0 corresponds to the zero in IR. The basic predicate to be used here is
Q(0, x, y), where Q will correspond to the relation Q = {(0, x, y) | (0 < |x| < y) ∧(x ∈IR) ∧(y ∈P)}.
The most basic assumption is that Γ is consistent and from Theorem 1 it has a model MI, where IR is
the domain. The facts are that from a viewpoint external to this structure, it can be assumed that all we
need to name every member of IR is a set of constants that can be put into one-to-one relation with the even
natural numbers, our most basic assumed consistent theory. So, let there be such a set of constants C and
consider but one more constant b. Consider the following set of sentences
A = {Q(0, b, a) | a ∈P ⊂C}.
Note that this does not add any new predicates. What we do is to show that the set of sentence Γ ∪A has
a model.
Theorem. There is a structure ∗MI that models Γ ∪A, where the domain ∗IR contains new objects not
in IR and the entire theory Γ holds for ∗IR.
“denumerable” domain (i.e. can be put into a one-to-one correspondence with the natural numbers) and,
hence, for this structure the set of constants used in our language for the real numbers and in deﬁnition 3.1
can be extended so as to name all the members of IR.
95

Proof. We have that Γ has a model MI. Let ﬁnite {A1, . . . An} ⊂A. If {A1, . . . Ai} ⊂Γ, then MI |=
{A1, . . . Ai}. Suppose that {Ai+1, . . . , An} ⊂A, where Ak = Q(0, b, ak), i + 1 ≤k ≤n. Then {aj+1, . . . , an}
contains a minimal member in IR, ak. Now let b correspond to ak/2. Then for this member of IR we have that
MI |= {Ai+1, . . . , An}. Thus, by the Compactness Theorem, there is a structure ∗MI such that ∗MI |= A.
Now there are no new predicates in A. The only thing that can be diﬀerent is the domain ∗IR. Of
course, all relations that model these predicates are now relative to ∗IR. What we are doing is metalogically
investigate the two structures MI and ∗MI from the external world rather than only internal to either of
the structures. By convention, we denote some of the predicates as they are interpreted in ∗MI for ∗IR by
the same letter when there is no confusion as to which domain they apply; otherwise, they will be preceded
by a * (translated by the word “hyper”). As pointed out, each member of the original IR is named by a
constant from C and these same constants name members of ∗IR. We call each such interpreted constant a
standard member of ∗IR. What happens is that there is a object in ∗IR that now is being named by b, and
that we denote by ǫ. This ǫ ̸= a for any standard member of ∗IR. Why? Well, take any standard r ∈∗IR.
Using the theory Γ, if ǫ = r, then we have contradicted that if ǫ < r, then ǫ ̸= r. Thus, this is a new object
that does not correspond to any standard element of ∗IR. Moreover, there are two such objects since Γ holds
for ∗IR, and, hence, −ǫ ∈∗IR and | −ǫ| = |ǫ|. [As indicated the “≤,” “| · |,” and “=” predicates must be
interpreted in ∗MI. This is the last time I’ll mention this fact.]
The objects −ǫ, ǫ are called inﬁnitesimals.
But do they behave like the inﬁnitely small or little
ideal numbers o of Newton? Newton, as well as Leibniz, required the o, on one hand, to behavior like a
non-zero real number but then to behave like a zero. This is why some people rejected the entire idea
of an “ideal” number like o since it contradicts real number behavior. For example, Newton divides the
equation 3pox2 + 3p2o2x + p3o3 −2dqoy −dq2o3 −abpo = 0 by o where o cannot act like a zero, and gets
3px2 + 3p2ox + p3o2 −2dqy −dq2o −abp = 0. But now, he treats o as if it is zero and writes “Also those
terms are inﬁnitely little where o is. Therefore, omitting them there results 3px2 −abp −2dqy = 0.” This is
a direct contradiction as to the behavior of the o and, indeed, one should be able to apply the “omitting”
process to the ﬁrst equation and this would only yield the identity 0 = 0.
First, let µ(0) be the set of all inﬁnitesimals in ∗IR and include standard 0 in this set. To determine that
members of µ(0) have properties diﬀerent from those of the original IR, we must investigate these from the
“meta” viewpoint. The non-Greek lower case letters will always be the constants used to name the standard
members of ∗IR.
(1) Let 0 ̸= λ ∈µ(0). Let non-zero standard r ∈∗IR and arbitrary standard x ∈∗P. Then 0 < |λ| < x/|r|
since x/|r| is as standards member of ∗P. From the theory Γ, we have that 0 < |rλ| < x. Thus rλ ∈µ(0)
since x is an arbitrary standard member of ∗P. [Note: Some would write this as ∗rλ ∈µ(0).]
(2) Using stuﬀfrom (1), let λ, γ ∈µ(0). We have that 0 < |λ| < x and 0 < |γ| < y where both x and
y are arbitrary standard members of ∗P. Hence, from Γ, we have that 0 < |λ + γ| ≤|λ| + |γ| < x + y. But
x + y = z is also an arbitrary standard member ∗P. Thus, λ + γ ∈µ(0). In like manner λγ ∈µ(0).
(3) You can do all the ordinary real number algebra for the members of µ(0) since Γ holds for them.
However, if 0 ̸= λ, then 1/λ ̸∈µ(0), since for arbitrary standard x ∈∗P, x < 1/λ.
(4) For r, let µ(r) = {r + λ | λ ∈µ(0)}. This is can a monad about r. Let r1 ̸= r2. Then µ(r1) is
completely disjoint from µ(r2). Why? Well, suppose not. Then there are two inﬁnitesimals λ, γ such that
λ + r1 = γ + r2 ⇒r1 −r2 = γ −λ ∈µ(0). But r1 −r2 is a standard number and the only standard number
in µ(0) is 0. Thus, r1 = r2; a contradiction.
(5) Hence, every object in ∗IR that behaves like the original real numbers is “surrounded,” so to speak, by
its monad. Because of this uniqueness, we can for every member of µ(r1) ∪µ(r2) ∪· · · ∪µ(rn) ∪· · · = Mfin,
96

where the r vary over all standard ∗IR, deﬁne an operator st with domain Mfin that yields the unique
standard r. Although the notion of the “limit” need never be considered, the st operator mirrors “limit”
algebra and can be applied to the Newton material above.
Let Newton’s o = λ ̸= 0. Consider 3pλx2 + 3p2λ2x + p3λ3 −2dqλy −dq2λ3 −abpλ = 0. Now divide
by λ and get 3px2 + 3p2λx + p3λ2 −2dqy −dq2λ −abp = 0(1/λ) = 0. Using the properties of the st
operator applied to both sides of this equation, 3px2 + 3p2st(λ)x + p3st(λ2) −2dqy −dq2st(λ) −abp =
3px2 + 3p2(0)x + p3(0) −2dqy −dq2(0) −abp = 3px2 −2dqy −abp = 0. Which is the same result as Newton’s
and eliminates any contradiction.
3.9 Ultralogics and Natural Systems.
In 1949 in the Journal of Symbolic Logic, Leon Henkin gave a new proof for our theorem 3.8.5 from
which the compactness theorem follows. Indeed, the proof that appears in the appendix is a modiﬁcation
of Henkin’s proof. I note that the appendix proof most also be modiﬁed if we wish to apply a compactness
theorem to sets like the real numbers, as needed for exercise 3.8 problem 2. These modiﬁcations are rather
simple in character and it’s assumed that whenever the compactness theorem is used that it has been
established for the language being discussed.
What is particularly signiﬁcant about the Henkin method is that it’s hardly possible to reject the
method. Why? Well, as shown in the proof in the appendix the model is constructed by using the language
constants and predicates themselves to construct the structure. What seems to be a very obvious approach
was used 18 years after the ﬁrst G¨odel proof. There is a certain conceptual correspondence between the use
of the language itself and the material discussed in this last section.
All of the metatheorems established throughout this text use a ﬁrst-order metalanguage. These metathe-
orems describe various aspects of any formal ﬁrst-order language. But these metatheorems also apply to
informal languages that can be represented or encoded by a formal language. That is such concepts as the
compactness theorem can be applied to obtained models for various “formalizable” natural languages and the
logical processes used within science, engineering and many other disciplines. In 1963, Abraham Robinson
did just this with the ﬁrst published paper applying a similar device as the compactness theorem to obtain
some new models for the valuation process within formal languages. Your author has extended Robinson’s
work and has applied his model theoretic methods to all natural languages such as English, French, etc. The
method used is the Tarski concept of the consequence operator. Before we apply the compactness theorem
to obtain mathematically an ultralogic and an ultraword, a few very simply communication concepts need
to be discussed.
Deﬁnition 3.9.1 A Natural system is a set or arrangement of physical entities that are so related or
connected as to form an identiﬁable whole. Science speciﬁcally deﬁnes such collections of entities and gives
them identifying names. The universe in which we dwell, our solar system, the Earth, or a virus are Natural
systems.
The appearance of most Natural systems changes with “time.” I’ll not deﬁne the concept of time, there
are various deﬁnitions, and I simply mention that the time concept can be replaced by something else called
a universal event number if the time concept becomes a philosophical problem. One of the most important
aspects of any science that studies the behavior of a Natural system is the communication of the predicted
or observed behavior to other individuals. This communication can come in the form of word-pictures or
other techniques I’ll discuss below. Even if science cannot predict the past or future behavior of an evolving
or developing (i.e. changing in time) Natural system, it’s always assumed that at any instant of time the
appearance can be described.
97

Deﬁnition 3.9.2 A Natural event is the actual and real objective appearance of a Natural system at a
given instant whether or not it’s described in any language or by other techniques.
From a scientiﬁc communication point of view, a description is all that can be scientiﬁcally known
about such a Natural event and the description is substituted for it. Relative to the behavior of a Natural
system, a general scientiﬁc approach is taken and it’s assumed that scientists are interested in various types
of descriptions for Natural system behavior. It’s not diﬃcult to show that all forms of scientiﬁc description
can be reduced to ﬁnitely long strings of symbols.
Modern computer technology is used to produce an
exact string of symbols that will reproduce, with great clarity, any photograph, TV tape, or sound. Today,
information is “digitized.” Relative to a visual instant-by-instant description, television is used. Each small
ﬂuorescent region on a TV screen is given a coded location within a computer program. What electron beam
turns on or oﬀ, the intensity of the beam and the like is encoded in a series of binary digits. The computer
software then decodes this information and the beam sweeps out a glowing picture on a TV tube. At the
next sweep, a diﬀerent decoded series of digits yields a slightly diﬀerent picture. And, after many hundreds
of these sweeps, the human brain coupled with the eye’s persistence of vision yields a faithful mental motion
picture. Record companies digitize music in order to improve upon the reproduction quality. Schematics
for the construction of equipment can be faithfully described in words and phrases if a ﬁne enough map
type grid is used. Thus, the complete computer software expressed in a computer language, the digitized
inputs along with schematics of how to build the equipment to encode and decode digitized information,
taken together, can be considered as an enormous symbol string the exact content of which will be what
you perceive on “the tube,” hear from a CD player, or other such devices.
Much of what science considers to be perception may be replaced by a long exact string of symbols.
All of the methods used by science to communicate descriptions for Natural system behavior will be called
the descriptions.
What all this means is that the actual objective evolution of a Natural system can be replaced by
descriptions for how such a system appears at speciﬁc instances during its evolution.
The actual time
diﬀerences between successive “snap shorts” will depend upon the Natural system being studied, but they
could be minuscule if need be.
Just think of a developing Natural system as an enormous sequence of
Natural events, that have been replaced by an enormous sequence of descriptions. As discussed above these
descriptions can be replaced by ﬁnitely long strings of symbols of one sort of another. This communication
fact is the common feature of all scientiﬁc disciplines.
The basic object used to study the behavior of Natural systems by means of descriptions of such behavior
is the consequence operator described in section 2.16. Actually, consequence operators are used more for
mathematical convenience than any other reason. For the purposes of this elementary exposition, ALL of
the consequence operator results can be re-expressed in the ⊢notation. However, in the next deﬁnition we
indicate how deductive processes such as the propositional process denoted by ⊢determine a consequence
operator.
Deﬁnition 3.9.3 For a propositional language L and a propositional type of deduction from premises
Γ ⊢ℓB, a consequence operator C is deﬁned as follows: For every Γ ⊂L, C(Γ) = {A | A ∈L and Γ ⊢ℓA}.
Thus C(Γ) is the set of all formula “deduced” from Γ by the rules represented by ⊢ℓ.
Now recall the propositional language introduced in section 2.16. It’s constructed from a set of atoms
{P0, P1, . . .} in the usual manner, but only using the connectives ∧and →. Of course, this language LS is a
sublanguage of our basic language L. For formal deductive process, there are four axioms written in language
variables.
(1) (A ∧(B ∧C)) →((A ∧B) ∧C).
98

(2) (A ∧B) ∧C →(A ∧(B ∧C)).
(3) (A ∧B) →A.
(4) (A ∧B) →B.
Notice that these axioms are theorems in L (i.e. valid formula) and, thus, also in LS. The process of
inserting ﬁnitely many premises in a demonstration is retained. The one rule of inference is modus ponens
as before. We denote the deductive process these instructions yield by the usual symbol ⊢. The consequence
operator deﬁned by the process ⊢is denoted by S.
There is actually an inﬁnite collection of deductive processes that can be deﬁned for L and LS. This is
done by restricting the modus ponens rule.
Deﬁnition 3.9.4 Consider all of the same rules as described above for ⊢except we use only the MPn
modus ponens rule. Suppose two previous steps of a demonstration are of the form A →B and A and the
size(A →B) ≤n. Then you can write down at a larger step number the formula A. [This is not the only
way to restrict such an MP process.] This is the only MP type process allowed for the ⊢n deductive process.
The major reason the process ⊢n is introduced is to simply indicate that there exist many diﬀerent
deductive processes that one can investigate. All of the metamathematical methods used to obtain the
results in the previous sections of this text are considered as the most simplistic possible. They are the same
ones used in the theory of natural numbers. Hence, they are considered as consistent. Thus, everything that
has been done has a model. Let L = L′ be the domain. The language contains a set of atoms {P0, P1, . . .}.
Then we have the various 2-place relations between subsets of L′ we have denoted by ⊢n and ⊢. The ﬁrst
coordinate of each of these relations is a subset of L′, the premises, and the second coordinate is a single
formula deduced from the premises. If the set of premises is the empty set, then the second coordinates are
called theorems. To be consistent with our previous notation, we would denote the 2-place relations for a
deductive processes by ⊢′
n and ⊢′ . This would not be the case for the members of L′.
We now come to an important idea relative to the relation ⊢introduced, in 1978, by the author of this
book. The metatheory we have constructed in the past sections of this text, the mathematical theory that
tells us about the behavior of ﬁrst-order languages and various deductive processes, is constructed from a
ﬁrst-order language using the vary deductive processes we have been studying. Indeed, all the proofs can be
written in the exact same way as in the sections on formal deduction, using a diﬀerent list of symbols or even
the same list but, say, in a diﬀerent color. Another method, the one that is actual used for the more reﬁned
and complex discusses of ultralogical and ultraword behavior, is to use another formal theory, ﬁrst-order
set theory, to re-express all of these previous metatheorems. In either case, the compactness theorem for
ﬁrst-order languages and deduction would hold.
There are two methods used to obtain models. If we assume that a mathematical theory is consistent,
then the theory can be used to deﬁne a structure, which from the deﬁnition, would be a model for the theory.
Theory consistency would yield all of the proper requirements for deﬁnition 3.3.3. On the other hand, you
can assume that a structure is given. We assume that the n-place relations and constant named objects are
related by a set of informal axioms that are consistent. Using this structure, we develop new information
about the structure. This information is obtained by ﬁrst-order deduction and is expressed in an informal
ﬁrst-order language. This informal ﬁrst-order language can then be “formalized” by substituting for the
informal constants and relations, formal symbols. This leads to a formal theory for the structure. Both of
these methods yield what is called a standard structure and the formal theory is the standard theory.
For our propositional language L, we have the entire collection T of sentences that are established
informally in chapter 2 about this language relative to various predicates and we translate these informal
statements into a formal ﬁrst-order theory E. One part of our mathematical analysis has been associated with
99

a standard structure. We have used ﬁrst-order logic and a ﬁrst-order language to investigate the propositional
language and logic. Thousands of years of working with this structure has not produced a contradiction. The
structure is composed of a domain D, where D = L = C (the set of constants). There are various n-place
relations used. For example, three simplest are the 2-place relation on this domain ⊢′, the 1-place relation P′
that corresponds to the non-empty set of atoms L0 ⊂L, and x ∈L that corresponds to L(x). The relation
⊢′ is deﬁned as follows: A ⊢′ B, where A, B ∈L′, if and only if A ⊢B. Then P′ is deﬁned as P ∈P′ if
and only if P(P) (i.e. “P is an atom.”) Although it is not necessary, in order to have some “interesting”
results, we assume that there are as many atoms as there are natural numbers. [In this case, it can be shown
that there are also as many members of L as there are natural numbers.] Since E is assumed consistent,
then there is a standard structure MI = ⟨D, L′, ⊢′, P′, . . .⟩that models all of the n-placed predicates and
constants that appear in E, where we again note that for each A ∈L, I(A) = A. The set E is a subset of a
ﬁrst-order language L, where L is constructed from C and all of n-placed predicates use in E.
Theorem 3.9.1 Let b be one new constant added to the constants C. Construct a new ﬁrst-order
language L′ with the set of constants C ∪{b} and all of the n-placed predicates used to construct L. Then
L ⊂L′. Let L0 be the set of atoms in L ⊂C, where we consider them also as constants that name the
atoms, and let x ∈L0 be the interpretation of the 1-place predicate P(x). Consider the set of sentences
Φ = {P(P) ∧b ⊢P | P ∈L0} ⊂L′. Then there exists a model ∗MI for E ∪Φ.
Proof. This is established as in the example and exercises of section 3.8. Consider any non-empty
ﬁnite F ⊂E ∪Φ. Then F = F1 ∪F2, where F1 ⊂E and F2 ⊂Φ. Suppose that F1 ̸= ∅. Then MI |= F1.
Suppose that {A1, . . . , An} = F2, n ≥1. (Note: Ai, 1 ≤i ≤n are all distinct.)
Consider the ﬁnite
set {P1, . . . , Pn} of atoms that appear in A1, . . . , An. (1) If n = 1, then there is only one atom P in this
set, and P ∈D = L. Otherwise, (2) consider the formula formed by putting ∧between each of the Pi as
follows: (P1 ∧(· · · (Pn−1 ∧Pn) and (P1 ∧(· · · (Pn−1 ∧Pn) ∈D = L. In case (1), let b = P; in case (2), let
b = (P1 ∧(· · · (Pn−1 ∧Pn). Then from the theory E, we know that (1) P(P) ∧b ⊢P or (2) P(Pi) ∧b ⊢Pi,
i = 1, . . . , n. Hence, interpreting the b in case (1) as P, and b in case (2) as (P1 ∧(· · · (Pn−1 ∧Pn), then
MI |= F1. Consequently, MI models any ﬁnite subset of E ∪Φ. Hence by the compactness theorem there is
a model ∗MI for E ∪Φ.
Let ∗b now denote that object in the domain of ∗MI that satisﬁes each of the sentences in Φ, where
∗⊢denotes the corresponding binary relation that corresponds to ⊢. Since the formal theory E corresponds
to the informal theory T and
∗MI |= E, then the structure, at the very least, behaves, as described by
the theory of chapter 2, as a propositional logic. But does this new structure have additional properties?
Note that
∗⊢“behaves” like propositional deduction and
∗b “behaves,” thus far in this analysis, simply
like a formula in L. The object ∗b is called an ultraword and ∗⊢is an example of a (very weak) ultralogic.
The reason why it is weak is that we have only related ∗b to the one relation ∗⊢. Hence, not much can be
said about the behavior of ∗b. However, we do know that ∗b does not behave like an atom in ∗MI for the
following statement (3) holds in MI; (3) ¬∃x(P(P1) ∧P(P2) ∧P(x) ∧x ⊢P1 ∧x ⊢P2). Hence, (3) holds
in ∗MI. But the ¬∃varies over the elements that, at the least, correspond to C ∪{b} in its domain and,
hence, this statement applies to the each member of { ∗P1,
∗P2}, the
∗MI interpreted constants P1, P2,
that are members of the ∗P. Hence, whatever objects “behavior” like the atoms in ∗MI, ∗b is not one of
them. If we consider other predicates, then more information and properties will hold in another structure.
Suppose that ⌈C(
)⌉: “
is a consistent member of L.” In Φ, replace P(P) with P(P) ∧C(b) to obtain Φ′.
The same method as above shows that there is a structure ∗MI1 such that ∗MI1 |= E ∪Φ′. The previous
properties for ∗b still hold. Using the sentence ¬∃x(∀y((P(y)∧C(x)) →x ⊢y)), we are led to the conclusion
that ∗b ∗⊢∗P in ∗MI1 for all of the original atoms P ∈L0. But, when a comparison is made, there is at
least one other object that we name d′ that behaves like an “atom” and ∗b ∗̸⊢d′ in ∗MI1.
100

Example 3.9.1 Correspond each atom in L to a description for the behavior of a Natural system at
a speciﬁc moment. Let the ordering of the natural numbers to which each atom corresponds correspond to
an ordering of an event sequence. Using the concepts of Quantum Logic, one can interpret the ultralogic ∗⊢
as a physical-like process that when applied to a single object ∗b yields each original interpreted description
∗P. Using certain types of special constructions that yield ∗MI, one has that ∗P = P. Hence, under these
conditions this ∗b and ∗⊢yield the moment-by-moment event sequence that is the objectively real evolution
of a Natural system. This idea applies to ANY Natural system including the universe in which we dwell
and, thus, gives a describable process that can produce a universe.
Obviously, the approach used to obtain ultrawords and ultralogics as discussed in this section is very
crude in character. There arise numerous questions that one would like to answer. By reﬁning the above
processes, using set-theory, consequence operators and other more complex procedures these questions have
all been answered. I list certain interesting ones with (very) brief answer.
(1) Can this process be reﬁned so that the actual complex behavior expressed by each description is
retained within the model while it’s also being modeled by a proposition atom? (Yes)
(2) Can the ultraword ∗b be analyzed? (Yes, and they can have very interesting internal structures.)
(3) Can you assign a size to ∗b and, if so, how big is it? (Yes, and it is very, very big. It is stuﬀed with
a great deal of information.)
(4) If you take all the ultrawords that generate all of the our Natural systems, does there exist one
ultraword that when
∗⊢is applied to this one ultraword then all the other ultrawords are produced and,
hence, all of the event sequences for all of the Natural systems that comprise our universe are produced?
(Yes. There is a ultimate ultraword w such that when
∗⊢is applied to w all of the other ultrawords are
produced as well as all the consequences produced by these other ultrawords. What this shows is that all
natural event sequences are related by the physical-like process ∗⊢, among others, applied to w. This gives
a solution to the General Grand Uniﬁcation problem.)
(5) Will there always be these ultranatural events no matter how we might alter the natural events?
(Yes)
(6) And many others.
101

APPENDIX
Chapter 2
The major proof and deﬁnition method employed throughout this text is called induction. In the ﬁrst
part of this appendix, we’ll explore this concept which is thousands of years old.
There are two equivalent principles, the weak and the strong. In most cases, the strong method is used.
We use the natural numbers IN = {0, 1, 2, 3, 4, . . .} either in their entirety or starting at some ﬁxed natural
number m. There are two actual properties used. The ﬁrst property is
(1) Any nonempty ﬁnite set of natural numbers contains a maximal member. This is a natural number
that is greater than or equal to every member of the set and is also contained in the ﬁnite set.
(2) The ordering < is a well-ordering. This means that any nonempty set of natural numbers, ﬁnite or
otherwise, contains a ﬁrst element. This means that the set contains a member that is less than or equal
to every other member of the nonempty set. The actual induction property holds for many diﬀerent sets of
natural numbers and you have a choice of any one of these sets. Let m ∈IN. Then we have the set Nm of all
natural numbers greater than or equal to m. That is Nm = {n | n ∈IN, m ≤n}.
Principle 1. (Strong Induction). Suppose that you take any nonempty W ⊂Nm. Then you show that
a statement holds for
(i) m ∈W.
(ii) Now if upon assuming that for a speciﬁc n ∈W, the statement we wish to establish holds for each
p ∈IN, where m ≤p ≤n, you can show that n + 1 ∈W, (this is called the strong induction hypothesis.)
(iii) then you can declare that W = Nm. (We say that the result follows by induction.)
The major method in applying principle 1 is in how we deﬁne the set W. It is deﬁned in terms of the
statement we wish to establish. The set W is deﬁned by some acceptable description, a set of rules, that
gives a method for counting objects. I have used the term “acceptable.” This means a method that is so
clearly stated that almost all individuals having knowledge of the terms used in the description would be
able to count the objects in question and arrive at the same count. Now there is another principle that may
seem to be diﬀerent from principle 1, but it is actually equivalent to it.
Principle 2. (Ordinary (weak) induction.) Suppose that you take any nonempty W ⊂Nm. Then you
show that a statement holds for
(i) m ∈W.
(ii) Now if upon assuming that for a speciﬁc n ∈W, the statement we wish to establish holds n, you
can show that n + 1 ∈W, (this is called the weak induction hypothesis)
(iii) then you can declare that W = Nm. (We say that the result follows by induction.)
The diﬀerence in these two principles is located in part (ii).
What you assume holds seems to be
diﬀerent. In principle 1, we seem to require a stronger assumption than in principle 2. The next result shows
that the two principles are equivalent.
Theorem on the equivalence of the two principles 1 and 2. Relative to the natural numbers
and the subset Nm, principle 1 holds if and only if principle 2 holds.
Proof. We ﬁrst show that principle 2 is equivalent to the fact that the simple ordering < on Nm is a
well-ordering. Assume principle 2 for Nm. Let nonempty W ⊂Nm. Suppose that W does not have a ﬁrst
element with respect to the ordering < . Then W ̸= Nm since m is the ﬁrst element in Nm. Thus m /∈W.
We now deﬁne in terms of the ordering < a relation R where the second coordinate is the set W. We let
x R W if and only if for x ∈IN, x < y for each y ∈W. Let W1 = {x | x ∈Nm, x R W}. From above,
we have since W ⊂Nm, that m ∈W1. Also W1 ∩W = ∅. For if a ∈W1 ∩W, then a < a; a contradiction.
Assume that p ∈W1 and q < p. Since p < n for each n ∈W, then q < n for each n ∈W. Hence q ∈W1.
Hence, the nonempty natural number interval [m, q] = {x | m ≤x ≤q, x ∈IN} ⊂W1. We now show that
102

q + 1 ∈W1. Assume that q + 1 /∈W1. Then there is some y ∈W such that y ≤q + 1 from the deﬁnition of
W1. If y ̸= q + 1, then y ∈[m, q] yields that y /∈W. From this contradiction, we have that y = q + 1 and no
x ≤q < q + 1 is a member of W. Consequently, q + 1 is a ﬁrst element of W; a contradiction. Application
of principle 2 implies that W1 = Nm. Thus yields the contradiction that W = ∅.
Now assume that < is a well-ordering. Let nonempty W ⊂Nm. Assume that m ∈W and if arbitrary
n ∈Nm, then n + 1 ∈W, BUT W ̸= Nm. Consider W1 = Nm −W = {x | x ∈Nm, x /∈W}. From our
assumption, W1 ̸= ∅. By the well-ordering of <, there exists in W1 a ﬁrst element w1. Since m /∈W1, it
follows that m ≤x1 −1 /∈W1. Thus x1 −1 ∈W. From our assumption, x1 −1 + 1 = x1 ∈W. But by
deﬁnition W1 ∩W = ∅. This contradiction yields the result. The fact that <, with respect to the natural
numbers, is a well-ordering is equivalent to principle 2.
Now we show that the well-ordering <, restricted to any Nm, implies principle 1 for Nm. Let nonempty
W ⊂Nm. Assume that W ̸= Nm. Assume that m ∈W and that if x ∈W and m ≤x ≤n, x ∈Nm, then
n + 1 ∈W, but W ̸= Nm. Consider W1 = Nm −W1. By well-ordering, W1 contains a ﬁrst member w1. From
the above assumption, w1 ̸= m. Hence, we can express w1 as w1 = n + 1, for some n ∈IN. Since w1 is a
ﬁrst element, then each x ∈Nm such that m ≤x ≤n, has the property that x ∈W. From our principle 1
assumption, this implies that w1 = n + 1 ∈W. This contradicts the deﬁnition of W1 since W1 ∩W = ∅. The
result follows.
We now complete this proof by showing that principle 1 and principle 2 are equivalent. Given Nm and
assume principle 2. Then Nm is well-ordered by < . From above principle 1 holds.
Now assume principle 1 holds. Let nonempty W ⊂Nm and suppose that m ∈W and if n ∈W, then
n + 1 ∈W. Principle 1 states that if m ∈W, and assuming that for each r ∈IN such that m ≤r ≤n, it can
be established that n + 1 ∈W, then W = Nm. However, we are given that if n ∈W, then n + 1 ∈W and
m ≤n ≤n. So, trivially, there is such an r = n and this yields that n + 1 ∈W. Thus principle 1 implies
that W = Nm.
There are two places that we use these equivalent induction processes. The ﬁrst is called deﬁnition by
induction.
Principle 3 (Deﬁnition by induction) Consider a construction based upon the natural numbers Nm.
(i) Suppose that we describe a process for the case where n = m (i.e. for step m.)
(ii) Suppose that we assume that we have described a process for each n, where n ≥m. (i.e. each step
n.)
(iii) Now use the n notation and describe a ﬁxed set of rules for the construction of the entity for the
n + 1 step. (The induction step.)
Then you have described a process that obtains each step n ∈Nm.
Theorem on principle 3. Principle 3 holds.
Proof. Suppose that you followed the rules in (i), (ii), (iii). Let W ⊂Nm be the set of all natural
numbers great than or equal to m for which the construction has been described. From (i), m ∈W. From
(ii), we may assume that you have constructed step n ∈W. From (iii), you have described step n + 1 from
step n. Thus n + 1 ∈W. Hence by principle 2, W = Nm.
Notice that the concept of what is an acceptable description for a construction by induction depends
upon whether the description is so clear that all individuals will obtain the same constructed object.
Example 1. (Deﬁnition by induction) Let m = 1 and let b be a positive real number.
(1) Deﬁne b0 = 1 and b1 = b each being a real number.
(2) Assume that for arbitrary n ∈N1, bn has been deﬁned and is a real number.
(3) Deﬁne bn+1 = b · (bn), where · means the multiplication of real numbers. (Note since b is a real
number and by assumption bn is a real number, then b · (bn) is a real number.)
(4) Hence, by induction, bn has been deﬁned and is a real number for all n ∈N1 (and separately for
n = 0.)
103

In deﬁnition 2.2.3 that appears below for the language L, we use the concept of deﬁnition by induction to
obtain a deﬁnition for each language level Ln. Although there are numerous examples of proof by induction
within the main part of this text, here is one more example.
Example 2. (Proof by induction) We show that if a natural number n is greater than or equal to 2,
then there exists a prime number p that is a factor of n.
Proof. Let m = 2 and let W ⊂Nm such that each member n ∈W has a prime factor. Since 2 is a
prime factor of itself, then 2 ∈W. Assume that for arbitrary n ∈W and each r ∈N2 such that 2 ≤r ≤n,
we know that r ∈W. Now consider n + 1. If n + 1 has no nontrivial factor b (i.e. not equal to 1 or b) such
that 2 ≤b < n + 1, then n + 1 is a prime number and, hence, contains a prime factor. (Note: any such
nontrivial factor would be less than n + 1.) If n + 1 has a nontrivial factor b, then 2 ≤b < n + 1. Thus for
this case, 2 ≤b ≤n. By the induction hypotheses, b has a prime factor p. Hence p being a prime factor of b
is also a prime factor of n + 1. Thus n + 1 has a prime factor. Consequently, W = Nn by induction.
Deﬁnition 2.2.3. The construction by induction of the propositional language L.
(1) Let A = {P, Q, R, S} ∪(∪{Pi, Qi, Ri, Si | i ∈IN −{0}}. The set A is called a set of atoms.
(2) Let ∅̸= L0 ⊂A.
(3) Suppose that Ln has been deﬁned. Let Ln+1 = {(¬A) | A ∈Ln} ∪{(A∧B) | A, b ∈Ln} ∪{(A∨B) |
A, B ∈Ln} ∪{(A →B) | A, B ∈Ln} ∪{(A ↔B) | A, B ∈Ln} ∪Ln.
(4) Now let L = S{Ln | 0 ̸= n ∈IN}.
(5) Note: We are using set theoretic notation. If one wants to formalize the above intuitive ideas, the
easiest way is to use a set theory with atoms where each member of A is an atom. Then consider various
Ln+1 level n-ary relations, such as the ∧n+1 relation deﬁned on the Ln and for the other logical connectives.
Then all nary ∧n relations have the same properties and the same interpretation. Because, they have the
same properties and interpretation, there is nothing gained by formalizing this construction.
(6) These formulas can also be deﬁned in terms of the class concept, sequences of atoms, trees, closure
concepts and a lot more stuﬀ. Or, just keep them intuitive in character.
The next theorem holds obviously due to the inductive deﬁnition but I present it anyway.
Theorem on uniqueness of size. For any A ∈L there exists a natural number n ∈IN such that
A ∈Ln and if m ∈IN and m < n, then A ̸∈Lm.
Proof. Suppose the A ∈L. Then from the deﬁnition of L there exists some n such that A ∈Ln. Let
K = {k | A ∈Lk}. Then ∅̸= K ⊂IN. Hence, K has a smallest member which by deﬁnition would be the
size.
Theorem of the existence of a ﬁnite set of atoms that are contained in any formula A. Let
A ∈L. Then there exists a ﬁnite set A1 of atoms that contains all the atoms in A.
Proof. We use strong induction.
Let A ∈L. Then there exists a unique n such that size(A) = n.
(1) Let size(A) = 0. Then A ∈L0 and, hence, A is a single atom. The set that contains this single atom
is a ﬁnite set of atoms in A.
(2) Suppose that there exists a ﬁnite set that contains all the atoms for a formula of size r ≤n. Let
size(A) = n+1. Then from the deﬁnition of the levels either (i) A = ¬B, A = B∨C, A = B∧C, A = B →C,
or A = B ↔C, where size of B ≤n and C ≤n. Hence, from the induction hypothesis, there is a ﬁnite set
of atoms A1 that are contained in B, and a ﬁnite set of atoms A2 that are contained in C. Hence, there is a
ﬁnite set that contains the atoms in A. Thus by induction, given any A ∈L, then there exists a ﬁnite set of
atoms that contains all the atoms in A..
Theorem on existence of a unique assignment dependent valuation function. There exists a
function v: L →{T, F} such that
(a) if A ∈L0, then v(A) = F or T not both.
(b) If A = ¬B, then v(A) = F if v(B) = T, or v(A) = T if v(B) = F.
104

(c) If A = B ∨C, then v(A) = F if and only if v(B) = v(C) = F. Otherwise v(A) = T.
(d) If A = B ∧C, then v(A) = T if and only if v(B) = v(C) = T . Otherwise v(A) = F.
(e) If A = B →C, then v(A) = F if and only if v(B) = T, v(C) = F. Otherwise v(A) = T.
(f) If A = B ↔C, then v(A) = T ↔v(B) = v(C). Otherwise v(A) = F.
The function v: L →{T, F} is unique in the sense that if any other function f: L →{T, F} has these
properties and f(A) = v(A) for each A ∈L0 then f(A) = v(A) for each A ∈L.
Proof. (By induction). We show that for every n ∈IN there exists a function vn: Ln →{T, F} that
satisﬁes (a) — (f) above. Let n = 0 and A ∈L0. Then deﬁne v0 by letting v0(A) = T or v0(A) = F
not both. Then v0 is a function. Now the other properties (b) — (f) hold vacuously. Suppose there is a
function vn (n ̸= 0) deﬁned that satisﬁes the properties. Deﬁne vn+1 as follows: vn+1|L(n) = vn. Now for
A ∈Ln+1 −Ln, then A = ¬B, B ∨C, B ∧C, b →C, B ↔C. Thus deﬁne vn+1(A) in accordance with the
requirements of (b), (c), (d), (e), (f) of the above theorem. This gives a function since vn, by the induction
hypothesis, is a function on Ln and B, C ∈Ln are unique members of Ln.
Now to show that for all n ∈IN, if fn: L →{T, F} has the property that if f0 = v0, and (a) — (f) hold
for f, then fn = vn. Suppose n = 0. Since f0 = v0 property holds for n = 0. Now suppose that vn (n ̸= 0) is
unique (hence, (a) — (f) hold for vn) Consider, fn+1: L →{T, F} and (a) — (f) hold for fn+1. Now fn+1|Ln
satisﬁes (a) — (f); hence fn+1|Ln = vn. Now looking at Ln+1 −Ln and the fact that f satisﬁes (b) — (f),
it follows that for each A ∈Ln+1 −Ln, fn+1(A) = vn+1(A). Consequently, this part holds by induction.
Now let v = S{vn | n ∈IN}. v is a function since for every n ≤m, vn ⊂vm. We show the v satisﬁes
(a) — (f). Obviously v satisﬁes (a) since v|L0 = v0. Now if A = ¬B, then there exists n ∈IN such that
B ∈Ln and A ∈Ln+1 from the existence of size of A. Then v(A) = vn+1(A) = T, if vn(B) = F = v(B) or
vn+1(A) = F, if vn(B) = T = v(B). Hence (b) holds. In like manner, it follows that (c) – (f) hold and the
proof is complete.
It’s obvious how to construct the assignment and truth-table concepts from the above theorem. If A
contains a certain set of atoms, then restricting v to this set of atoms gives an assignment a. Conversely, all
assignments are generated by such a restriction. The remaining part of this theorem is but the truth-table
valuation process restricted to all the formula that can be constructed from this set of atoms starting with
the set L0.
Deﬁnition 2.11.1 The inductive deﬁnition for the sublanguage L′ is the exact same as in the case for
2.2.3.
Chapter 3
Important Note: All of the results established prior to theorem 3.8.4 hold for ANY predicate
language.
Deﬁnitions 3.1 and 3.6.1 These are obtained in the exact same manner as is 2.2.2.
Theorem on the existence and uniqueness of the process |= and ̸|= described in 3.3.3 on
Structure Valuation.
Given a structure MI = ⟨D, P n
i
′⟩, where the interpretation I is a one-to-one
correspondence from N ⊂C onto D and every n-place predicate P n
i to an n-place relation Rn
i . There exists
a v: Pd →{|=, ̸|=} such that
(a) for each i ∈IN and n ∈IN −{0}, v(P n
i (c1, . . . , cn) =|= if and only if (c′
1, . . . , c′
n) ∈Rn
i , where for any
ci ∈N, I(ci) = c′
i.
(b) If A →B ∈Pd, then v(A →B) ≠|= if and only if v(A) =|= and v(B) ≠|= . In all other cases,
v(A →B) =|= .
(c) If A ↔B ∈Pd, then v(A ↔B) =|= if and only if v(A) =|= and v(B) =|=, or v(A) ≠|= and
v(B) ≠|= .
(d) v(A ∨B) =|= if and only if v(A) =|= or v(B) =|= .
(e) v(A ∧B) =|= if and only if v(A) =|= and v(B) =|= .
105

(f) v(¬A) =|= if and only if v(A) ≠|= .
In what follows, the constant d is a general constant and corresponds to a general member d′ of the set
D. Any constants that appear in the original predicates have been assigned FIXED members of D by I and
never change their corresponding elements throughout this valuation for a given structure.
(g) For each sentence C = ∀xA ∈Pd, v(∀xA) =|= if and only if for every d′ ∈D it follows that
v(Sx
dA]) =|= . Otherwise, v(∀xA) ≠|= .
(h) For each sentence C = ∃xA ∈Pd, v(∃xA) =|= if and only if there is some d′ ∈D such that
v(Sx
dA]) =|= . Otherwise, v(∃xA) ≠|= .
The function v is unique in the sense that if any other function f: Pd →{|=, ̸|=} such that f = v for
the statements in (a), then f = v, in general.
Proof. The proof is by induction in the language levels m. Let m = 0. Deﬁne v0: Pd0 →{|=, ̸|=} by
condition (a) for all the predicates. Then v0 satisﬁes (b) – (h) vacuously.
Suppose that vm: Pdm →{|=, ̸|=} exists and satisﬁes (a) — (h). Deﬁne vm+1: Pdm+1 →{|≠|=} as
follows: vm+1|Pdm = vm. For F ∈Pdm+1 −Pdm, then F = ¬A, A ∧B, A ∨B, A ↔B, ∀xA, ∃xA, where
A, B ∈Pdm. Now deﬁne for the speciﬁc F listed, the function by the appropriate conditions listed in (b)
— (h). We note that A, B are unique and this deﬁnes a function.
We show that each vm is a unique function f: Pdm →{|=, ̸|=} satisfying (a) — (h) by induction. If f
is another such function, then letting m = 0 condition (a) implies that f = v0. Assume that vm is unique.
Let f: Pdm+1 →{|=, ̸|=} and f satisﬁes (a) — (h). Then f|Pdm = g satisﬁes (a) — (h). Therefore, g = vn.
Now (b) — (h), yields that f = vm+1.
The remainder of this proof follows in the exact same manner as the end of the proof of the Theorem
on existence of a unique assignment dependent valuation function.
NOTE: In the remaining portion of this appendix, it will be assumed that our language contains a
non-empty countable set of constants C.
We need for the proof of theorem 3.8.5 another conclusion. A set of sentences Γ is universal for a
language Pd′ if and only if ∀xB ∈Γ, whenever Sx
dB ∈Γ for all d ∈C.
Theorem 3.8.4 If consistent Γ ⊂S, then there is a language Pd′′ that contains all of the symbols of
Pd′, but with an additional set of constants and only constants adjoined, and a set of sentences Γ′′ ⊂Pd′′
such that Γ ⊂Γ′′ and Γ′′ is consistent, negation complete, and universal.
Proof. First, we extend C by adjoining a new denumerable set of constants {b0, . . .} to C giving a new
language Pd′′. [For other languages, the set of new constants may need to be a “larger” set than this.] This
means that the set of sentences S′ for Pd′′ is denumerable and we can consider them as enumerated into an
inﬁnite sequence S1, S2, . . . and these are all of the members of S′. We now begin an inductive deﬁnition for
an extension of Γn by adjoining a ﬁnite set of sentences from S1, S2, . . . which could mean that only ﬁnitely
many members of {b0, . . .} would appear in an any Γn.
First, for n = 0, let Γ0 = Γ. Suppose that Γn has been deﬁned. We now deﬁne Γn+1.
(a) If Γn ∪{Sn+1} is consistent, then let Γn+1 = Γn ∪{Sn+1}.
(b) If Γn ∪{Sn+1} is inconsistent and Sn+1 is NOT of the form ∀xB, then let Γn+1 = Γ∪{¬Sn+1}.
(c) If Γn∪{Sn+1} is inconsistent and Sn+1 is of the form ∀xB, then let Γn+1 = Γ∪{¬Sn+1, ¬Sx
b B]},
where b is the ﬁrst constant in {b0, . . .} that does not appear in Γn.
We ﬁrst show that for each n the set of sentences Γn is consistent. Obviously, for n = 0, the result
follows from the hypothesis that Γ = Γ0 is consistent. Now assume that Γn is consistent.
(a)’ Suppose that Γn+1 is obtained from case (a). Then Γn+1 is consistent.
(b)’ Suppose that Γn+1 is obtained from case (b). Then Γn ∪{Sn+1} is inconsistent. Hence, from
corollary 3.8.3.1, Γn ⊢¬Sn+1. Now Γn+1 = Γn ∪{¬Sn+1}. Suppose that Γn ∪{¬Sn+1} is inconsistent. Then
corollary 3.8.3.1 yields that Γn ⊢Sn+1. Hence, Γn is inconsistent. This contradiction yields that Γn+1 is
consistent.
106

(c)’ Again Γn ∪{Sn+1} is inconsistent yields that Γn ⊢¬Sn+1. Now also suppose that Γn+1 =
Γ∪{¬Sn+1, ¬Sx
b B]}, where b is the ﬁrst member of new constants that does not appear in Γn and assume that
this is an inconsistent collection of sentences. Then for some C ∈Pd′′ we have that Γn∪{¬Sn+1, ¬Sx
b B]} ⊢C
and Γn ∪{¬Sn+1, ¬Sx
b B]} ⊢¬C. Then by the deduction theorem 3.7.4, Γn ∪{¬Sx
b B]} ⊢(¬Sn+1) →C and
Γn ∪{¬Sx
b B]} ⊢(¬Sn+1) →(¬C). Then by adjoining the proof that Γn ⊢¬Sn+1 and two MP steps we
have that Γn ∪{¬Sx
b B]} is inconsistent. Thus by corollary 3.8.1, Γn ⊢¬Sx
b B]. Now the constant b does not
occur anywhere in Γn. Thus in the last demonstration we may substitute for b some variable y that does not
appear anywhere in the demonstration for each occurrence of b. This yields a demonstration that Γn ⊢Sx
y B.
By Generalization, Γn ⊢∀y(Sx
y B]). By corollary 3.6.3.1, we have that Γn ⊢∀xB = Sn+1. This contradicts
the consistency of Γn. Since this is the last possible case, then Γn+1 is consistent. Thus by induction for all
n, Γn is consistent.
We note that by deﬁnition Γ = Γ0 ⊂Γ1 ⊂· · · ⊂Γn ⊂· · · . We now deﬁne Γ′′ = S{Γn | n ∈IN}. We
need to show that Γ′′ is consistent, negation complete and universal for Pd′′.
(1) Suppose that the set of sentences Γ′′ is inconsistent. Then there is ﬁnite subset F of Γ′′ that is
inconsistent. But, from our remark above, there is some m ∈IN such that F ⊂Γm. This implies that Γm is
inconsistent. From this contradiction, we have that Γ′′. [In fact, its maximally consistent, in that adjoining
any sentence to Γ′′ that is not in Γ′′, we get an inconsistent set of sentences.]
(2) The set Γ′′ is negation complete. Let A be any sentence in Pd′′. Then A is one of the Sn+1, where
n ∈IN. From deﬁnition (a), (b), (c), either Sn+1 ∈Γn+1 or ¬Sn+1 ∈Γn+1. Thus Γ′′ is negation complete.
(3) We now show that Γ′′ is universal.
Let ∀xB be a sentence in Pd′′ such that Sx
c B] ∈Γ′′ for
each c ∈C ∪{b0, . . .}. Suppose that ∀xB /∈Γ′′. We know that ∀xB = Sn+1 for some n ∈IN. By case
(a), Γn ∪{∀xB} is inconsistent, by negation completeness, ¬∀xB ∈Γ′′. Now case (c) applies and Γn+1 =
Γn ∪{¬Sn+1, ¬Sx
b B]} ⊂Γ′′. This implies that ¬Sx
b B] ∈Γ′′. But our assumption was that Sx
c B] ∈Γ′′ for all
constants in Pd′′. Since b is one of these constants, we have a contradiction. Thus ∀xB ∈Γ′′.
Prior to establishing our major theorem 3.8.5, we have the following Lemma and the method to construct
the model we seek. Let the domain of our structure D = C for a speciﬁc Pd′. Let Γ be any non-empty set of
sentences from the language Pd′. For every n-place predicate P n
i in Pd′, we deﬁne the n-place relation Rn
i
by (c1, . . . , cn) ∈Rn
i if and only if P(c1, . . . , cn) ∈Γ. we denote the structure obtained from this deﬁnition
by the notation MI(Γ).
Lemma 3.8 Let Γ be a consistent, negation complete and universal set of sentences from Pd′. Then
for any sentence A ∈Pd′, MI(Γ) |= A if and only if A ∈Γ.
Proof. This is established by induction on the size of a formula.
(a) For n = 0. Let sentence A ∈Pd′
0. The result follows from the deﬁnition of MI(Γ).
(b) Suppose that theorem holds for n. Suppose that A ∈Pd′
n+1. Assume that A = B →C. Then
B, C ∈Pd′
n. We may assume by induction that the lemma holds for B and C. Suppose that A /∈Γ′. From
negation completeness, ¬A ∈Γ. But, in general, ¬(B →C) ⊢B and ¬(B →C) ⊢¬C. Hence, Γ ⊢B and
Γ ⊢¬C. If ¬B ∈Γ, Γ is inconsistent. Then, from negation completeness, it must be that B ∈Γ. For the
same reasons, ¬C ∈Γ and, thus, C /∈Γ. From the induction hypothesis, MI(Γ) |= B and MI(Γ) ̸|= C. Thus
MI(Γ) ̸|= A. Conversely, assume thatMI(Γ) ̸|= A. Then MI(Γ) |= B and MI(Γ) ̸|= C. By the induction
hypothesis, B ∈Γ and C /∈Γ. By negation completeness, ¬C ∈Γ. From, B, ¬C ⊢¬(B →C), we have that
Γ ⊢¬(B →C). Again by negation completeness and consistency, it follows that ¬(B →C) ∈Γ. Hence,
¬A ∈Γ and A /∈Γ.
(c) Let the sentence be A = ∀xB. Suppose that MI(Γ) |= A. Then for each d ∈D, MI(Γ) |= Sx
dB. By
the induction hypothesis, since Sx
dB ∈Pd′
n, then Sx
dB ∈Γ. Since Γ is universal, ∀xB = A ∈Γ. Conversely,
let A ∈Γ. Now, in general, A ⊢Sx
dB implies that Γ ⊢Sx
dB, which implies again by negation completeness
and consistency that Sx
dB ∈Γ for each d ∈D. By the induction hypothesis, we have that MI(Γ) |= Sx
dB for
each d ∈D. From the deﬁnition of |=, we have that MI(Γ) |= A.
This completes the proof.
107

Theorem 3.8.5 If consistent Γ ⊂S, then there exists a structure MI for Γ such that Γ ⊢A if and only
if MI |= ∀A.
Proof. Let the consistent set of sentences Γ ⊂Pd′. Then the language Pd′ can be extended to a language
Pd′′ and the set of sentences Γ extended to a set of sentences Γ′′ such that Γ′′ is consistent, negation complete,
and universal. Assume that Γ ⊢A. Then Γ ⊢∀A. Consequently, Γ′′ ⊢∀A. Thus ∀A ∈Γ′′. Now we use the
structure MI(Γ′′). Then lemma 3.8 states that MI(Γ′′) |= ∀A, where MI(Γ′′) is considered as restricted to
Pd′ since ∀A ∈Pd′.
Now suppose that Γ ̸⊢A. Then by repeated application of P5 and MP, we have that Γ ̸⊢∀A. [See
theorem 3.6.4.] Thus Γ ∪{¬(∀A)} is consistent by theorem 3.8.2. Consequently, ¬(∀A) ∈Γ′′. Therefore,
MI(Γ′′) |= ¬(∀A) implies that MI(Γ′′) ̸|= ∀A. Again, by restriction to the language Pd′, the converse
follows.
108

Answers to Some of the Exercise Problems
Exercise 2.2, Section 2.2
[1] (a) A /∈L. A required “ )” is missing. (b) A ∈L. (c) A ∈L. (d) A /∈L. The error is the symbol (P). (e)
A /∈L. Another parenthesis error. (f) A /∈L. The symbol string “ )P)” is in error. (g) A ∈L. (h) A /∈L.
Parenthesis error. (i) A /∈L. Parenthesis error. (j) A /∈L. Parenthesis error.
[3] (a) (P ∨Q). (b) (P →(Q ∨R)). (c) (P ∧(Q ∨R)). (d) (Q ∨R). (e) ((P ∧Q) ∨R). (f) ¬(P ∨Q). (g)
((P ↔Q) ∧((¬Q) →(R ∧S))). (h) ((P ∨Q) →R). (i) (((P ∧Q) →R) ∧((¬P) →(¬R))).
[4] (a) If it is nice, then it is not the case that it is hot and it is cold.
(b) It is small if and only if it is nice.
(c) It is small, and it is nice or it is hot.
(d) If it is small, then it is hot; or it is mice.
(e) It is nice if and only if; it is hot and it is not cold, or it is small. [It may be diﬃcult to express this
thought nonambiguously in a single sentence unless this “strange” punctuation is used. The “;’ indicates a
degree of separation greater than a comma but less then a period.]
(f) If it is small, then it is hot; or it is nice.
Exercise 2.3, Section 2.3
[1] (a) The number of (not necessarily distinct connectives) = the number of common pairs.
(b) The number of subformula = the number of common pairs.
[2] (No problem, sorry!)
[3] (A) has common pairs (a,h), (b,e), (c,d), (f,g).
(B) has common pairs (a,m), (b,g), (c,f), (d,e), (h,k), (i,j).
(C) has common pairs (a,q), (b,p), (d,g), (e,f), (i,o), (j,k), (m,n), (c,h).
Exercise 2.4, Section 2.4
[1]. First, we the assignment a = (T, F, F, T ) ↔(P, Q, R, S).
(a) v((R →(S ∨P)), a) = (F →(T ∨T )) = (F →T ) = F.
(b) v(((P ∨R) ↔(R ∧(¬S))), a) = ((T ∨F) ↔(F ∧(¬T )) = (T ↔(F ∧F)) = F.
(c) v((S ↔(P →((¬P) ∨S))), a) = (T ↔(T →((¬T ) ∨T )) = (T ↔(T →T )) = (T ↔T ) = T.
(d) v((((¬S) ∨Q) →(P ↔S)), a) = (((¬T ) ∨F) →(T ↔T ) = (FtoT ) = T.
(e) v((((P ∨(¬Q)) ∨R) →((¬S) ∧S)), a) = (((T ∨(¬F)) ∨F) →((¬T ) ∧T ) = (((T ∨T ) ∨F) →F) =
(T →F) = F.
3. (a) (P →Q) →R, v(R) = T ⇒((P →Q) →T ) = T always.
(b) P ∧(Q →R), v(Q →R) = F ⇒(P ∧F) = F always.
(c) (P →Q) →((¬Q) →(¬P)), v(Q) = T ⇒(P →T ) →(F →(¬P)) = T →T = T always.
(d) (R →Q) ↔Q, v(R) = T ⇒(T →Q) ↔Q = T always.
(e) (P →Q) →R, v(Q) = F ⇒(P →F) →R = T or F.
(f) (P ∨(¬P)) →R, v(R) = F ⇒(P ∨(¬P)) →F = T →F = F always.
109

Assignment 4 Section 2.5
[1].
P
Q
R
Q →P
(1)
Q →R
P →(Q →R)
P →R
P →Q
T
T
T
T
T
T
T
T
T
T
T
F
T
T
F
F
F
T
T
F
T
T
T
T
T
T
F
T
F
F
T
T
T
T
F
F
F
T
T
F
T
T
T
T
T
F
T
F
F
T
F
T
T
T
F
F
T
T
T
T
T
T
T
F
F
F
T
T
T
T
T
T
(P →Q) →(P →R)
(2)
¬P
¬Q
(¬P) →(¬Q)
(21)
T
T
F
F
T
T
F
T
F
F
T
T
T
T
F
T
T
T
T
T
F
T
T
T
T
T
T
F
F
T
T
T
T
F
F
T
T
T
T
T
T
T
T
T
T
T
T
T
Now use Theorem 2.5.2, with P = A, Q = B, R = C.
[2] (a) A contradiction. (b) Not a contradiction. (c) A contradiction. (d) Not a contradiction.
Exercise 2.6, Section 2.6
[1] (A) Suppose that we assume that there is some z ∈[x] ∩[y]. Then we have that z ≡x, z ≡y. But
symmetry yields that x ≡z. From the transitive property, we have that x ≡y. Hence x ∈[y]. Now let
u ∈[x]. Then u ≡x ⇒u ≡y. Thus u ∈[y]. Thus [x] ⊂[y]. Since y ≡x, this last argument repeated for y
shows that [y] ⊂[x]. Hence [x] = [y].
(B) Well, just note that for each x ∈X it follows that x ≡x. Hence, from the deﬁnition, x ∈[x].
[2] (A) Since B is a binary relation on X, it is deﬁned for all members of B. We are given that B is reﬂexive.
Thus we need to show that it is transitive and symmetric. So, let xBy. Then x ∈(y). From reﬂexive, we
110

have that x ∈(x). From (A), we have that (x) = (y). Thus y ∈(x). Therefore, yBx. Thus yields that B is
symmetric.
To show that it is transitive, assume that since B in on the entire set X, that x ∈y, y ∈(z). Then from
the reﬂexive property, y ∈(y). Hence y ∈(y) ∪(z). Thus (y) = (z) from (A). Thus xBz. Re-writing this in
relation notation we, have that if xBy and yBz, then xBz. This B is an equivalence relation.
(B) To show that reﬂexive is necessary, consider the binary relation R = {(a, b), (b, a)} on the two
element set {a, b}. Note that is can be re-written as aRb, bRa. Then (b) = {a}, (a) = {b}. Now this relation
satisﬁes (A) vacuously (i.e (A) holds since that hypothesis never holds.) (B) is obvious. But, since neither
(a, a) nor (b, b) are members of R, then R is not an equivalence relation.
[3] (A) Let D = (A ∨(A ∨B)), E = ((A ∨B) ∨C). Now from (3) Theorem 2.5.3, we have that CD ≡CE.
(B) Let D = (A∨B), E = ((¬A) →B). Then from part (46) of Theorem 2.5.3, we have that CD ≡CE.
(C) Let D = (A ∧B), E = (¬(A →(¬B))). The part (43) of Theorem 2.5.3, yields this result.
(D) First, let D = (A ↔B). Let G = (A →B) ∧(B →C). Then from part (47) of Theorem 2.5.3, we
have that CD ≡CG. We can now apply (C) twice, and let E = (¬((A →B) →(¬(B →C)))). This yields
CD ≡DE.
(E) This actually requires a small induction proof starting at n = 0. Let n be the number of ¬ to the
left of A. If n = 0 or n = 1, then the property that there is either none or one such ¬ symbol to the left is
established. Suppose that we have already established this for some n > 1. Now let there be n+1 such symbols
to the left of A and let this formula be denoted by H. First, consider the subformula G such that¬G = H.
Then by the induction hypothesis, there is a formula K such that K contains no ¬ to the left or at the most
one ¬ to the left such that K ≡G. If K has no ¬ to the left, then CH = C¬G ≡C¬K ⇒CH ≡C¬K. Now if
K has one ¬ to the left, then, in like manner, CH ≡C¬(¬K) ≡CK ⇒CH ≡CK, where K has no ¬ symbols.
The result follows by induction.
Exercise 2.7, Section 2.7
[1] (a) P ↔(A →(R ∨S)) ≡((¬P) ∨(A →(R ∨S))) ∧((¬(A →(R ∨S))) ∨P) ≡((¬P) ∨((¬A) ∨(R ∨
S))) ∧((¬((¬A) ∨(R ∨S))) ∨P) ≡((¬P) ∨((¬A) ∨(R ∨S))) ∧(A ∧((¬R) ∧(¬S)) ∨P).
(b) ((¬P) →Q) ↔R ≡(((¬P) →Q) →R) ∧(R →((¬P) →Q)) ≡(¬((¬P)) ∨Q) →R) ∧
((¬R) ∨(¬(¬P) ∨Q)) ≡((P ∨Q) →R) ∧((¬R) ∨(P ∨Q)) ≡((¬(P ∨Q)) ∨R) ∧((¬R) ∨(P ∨Q)) ≡
(((¬P) ∧(¬Q)) ∨R) ∧((¬R) ∨(P ∨Q)).
(c) (¬((¬P) ∨(¬Q))) →R ≡(P ∧Q) →R ≡(¬(P ∧Q)) ∨R ≡((¬P) ∨(¬Q)) ∨R.
(d) ((¬P) ↔Q) →R ≡(¬((¬P) ↔Q)) ∨R ≡(¬(((¬P) →Q) ∧(Q →(¬P))) ∨R ≡((¬(¬(¬P)) ∧
(¬Q)) ∨Q) ∨((¬Q) ∨(¬P))) ∨R ≡(((¬P) ∧(¬Q)) ∨Q) ∨((¬Q) ∨(¬P))) ∨R.
(e) (S ∨Q) →R ≡(¬(S ∨Q)) ∨R ≡((¬S) ∧(¬Q)) ∨R.
(f) (P ∨(Q ∧S)) →R ≡((¬P) ∧((¬Q) ∨(¬S))) ∨R.
[2] (a) ((¬P) ∨Q) ∧(((¬Q) ∨P) ∧R) ⇒Ad = (P ∧(¬Q)) ∨((Q ∧(¬P)) ∨(¬R))
(b) ((P ∨(¬Q)) ∨R) ∧(((¬P) ∨Q) ∧R) ⇒Ad = (((¬P) ∧Q) ∧(¬R)) ∨((P ∧(¬Q)) ∨(¬R)).
(c) ((¬R) ∨(¬P)) ∧(Q ∧P) ⇒Ad = (R ∧P) ∨((¬Q) ∨(¬P))
(d) (((Q ∧(¬R)) ∨Q) ∨(¬P)) ∧(Q ∨R) ⇒Ad = ((((¬Q) ∨R) ∧(¬Q)) ∧P) ∨((¬Q) ∧(¬R)).
[3] (a) (P ∧Q ∧R) ∨(P ∧(¬Q) ∧R) ∨(P ∧(¬B) ∧(¬C)).
(b) (P ∧Q ∧R) ∨(P ∧Q ∧(¬R)) ∨(P ∧(¬Q) ∧(¬R)) ∨((¬P) ∧Q ∧R) ∨((¬P) ∧Q ∧(¬R)) ∨((¬P) ∧
(¬Q) ∧R) ∨((¬P) ∧(¬Q) ∧(¬R)).
(c) (P ∧Q ∧(¬R)) ∨(P ∧(¬Q) ∧(¬R)) ∨((¬P) ∧Q ∧(¬R)) ∨((¬P) ∧(¬Q) ∧R).
(d) (P ∧Q ∧R) ∨(P ∧Q ∧(¬R)) ∨(P ∧(¬Q) ∧R) ∨(P ∧(¬Q) ∧(¬R)) ∨((¬P) ∧Q ∧R) ∨((¬P) ∧
Q ∧(¬R)) ∨((¬P) ∧(¬Q) ∧R) ∨((¬P) ∧(¬Q) ∧(¬R)).
[5] (a) C ∧(A ∨(B ∧((¬A) ∨B))).
(b) (C ∨((A ∨B) ∧(¬(A ∧B)))) ∧(¬(C ∧((A ∨B) ∧(¬(A ∧B))))).
Exercise 2.8, Section 2.8
[1].
(a) P →Q, (¬P) →Q |= Q.
(b) P →Q, Q →R, P |= R.
111

(c) (P →Q) →P, ¬P |= R. (Since premises are not satisﬁed, |= holds.)
(d) (¬P) →(¬Q), P ̸|= Q. (From row three.)
(e) (¬P) →(¬Q), Q |= P.
Exercise 2.9, Section 2.9
[1]. (a) (¬A) ∨B, C →(¬B) |= A →C.
(1) v(A →C) = F ⇒v(A) = T, v(C) = F ⇒v(C →(¬B)) = T. Now (3), if v(B) = T, then
v((¬A) ∨B) = T. Consequently, INVALID. AND the letters represent atoms only.
(b) A →(B →C), (C ∧D) →E, (¬G) →(D ∧(¬E)) |= A →(B →G).
(1) Let v(A →(B →G)) = F ⇒v(A) = T, v(B →G) = F ⇒v(B) = T, v(G) = F. (2) Let
v(A →(B →C)) = T ⇒v(C) = T. (3) Let v((¬G) →(D ∧(¬E))) = T ⇒v(D ∧(¬E)) = F ⇒v(D) =
F, v(E) = T ⇒v((C ∨D) →E) = F. Hence, VALID.
(c) (A ∨B) →(C ∧D), (D ∨E) →G |= A →G.
(1) Let v(A →G) = F ⇒v(G) = F, v(A) = T. (2) Let v((D ∨E) →G) = T ⇒v(D) = v(E) = F ⇒
v((A ∨B) →(C ∧D)) = F. Hence, VALID.
(d) A →(B ∧C), (¬B) ∨D, (E →(¬G)) →(¬D), B →(A ∨(¬E)) |= B →E.
(1) Let v(B →E) = F ⇒v(B) = T, v(E) = F. (2) Let v((¬B) ∨D) = T ⇒v(D) = T ⇒v((E →
(¬G)) →(¬D)) = F. Hence VALID.
[2] (a) The argument is H ∨S, (¬H) |= S. Let v(S) = F. Let v(¬H) = T ⇒v(H) = F ⇒v(H ∨S) = F.
Hence, VALID.
(b) The argument is I →C, (¬I) →D |= C ∨D. (1) Let v(C ∨D) = F ⇒v(C) = c(D) = F. (2) Let
v((¬I) →D) = T ⇒v(I) = T ⇒v(I →C) = F. Hence, VALID.
(c) The argument is S →I, I →C, S |= C. (1) Let v(C) = F. (2) Let v(S) = T. (3) Let v(S →I) =
T ⇒v(I) = T ⇒v(I →C) = F. Hence, VALID.
(d) The argument is P →L, L →N, N |= P. (1) Let v(P) = F ⇒v(P →L) = T. (2) Let
v(N) = T ⇒v(L →N) = T. Hence, INVALID.
(e) The argument is W ∨C, W →R, N |= W. (1) Let v(W) = F ⇒v(W →R) = T. We have only
one more premise remaining. This is NOT forced to be anything. We should be able to ﬁnd values that will
make it T . Let v(C) = T ⇒v(W ∨C) = T. Hence INVALID. [Note this is an over determined argument.
The statement N if removed will still lead to an invalid argument. However, if we add the premises N →W,
then the argument is valid.
(f) The argument is C →(M →I), C ∧(¬M) |= ¬I. (1) Let v(¬I) = F ⇒v(I) = T ⇒v(C →(M →
I)) = T, independent of the values for C, M. Thus for v(C) = T, v(M) = F ⇒v(C ∧(¬M)) = T. Hence,
INVALID.
(g) The argument is (L ∨C) →(D ∧S), D →P, ¬P |= L. (1) Let v(L) = F. (2) Let V (¬P) = T ⇒
v(P) = F. (3) Let v(D →P)) = T ⇒v(D) = F. These values do not force v((L ∨C) →(D ∧S)) to be
anything. This will immediately yield INVALID since by special selection, say v(C) = F, we can always
get a value v((L ∨C) →(D ∧S)) = T.
Exercise 2.10, Section 2.10
[1]. [Note: this is very important stuﬀ. As will be shown in the next section, if a set of premises is inconsistent,
then there will always be a correct logical argument that will lead to any PRESELECTED conclusion.]
(a) A →(¬(B ∧C)), (D ∨E) →G, G →(¬(H ∨I)), (¬C) ∧E ∧H.
(1) Let v(A →(¬(B ∧C))) = T ⇒v(C) = F, v(E) = T, v(H) = T. (2) Let v(G →(¬(H ∨I))) = T ⇒
v(G) = F ⇒v((D ∨E) →G) = F. Hence INCONSISTENT.
(b) (A ∨B) →(C ∧D), (D ∨E) →G, A ∨(¬G).
(1) Let v(A ∨(¬G)) = T ⇒case studies (1i) v(A) = T, v(G) = T, (1ii), v(A) = T, v(G) = F. (1iii)
V (A) = F, v(G) = F. (2) Consider (1i). Then v(G) = T ⇒v(D ∨E) →G) = T, independent of the values
112

for D, E, C. (3) So, select v(C) = T, v(D) = T, then v((A ∨B) →(C ∧D) = T. Thus we have found an
assignment that yields T for each member of the set of premises. Hence, they are CONSISTENT and the
formula symbols represent ATOMS.
(c) (A →B) ∧(C →D), (B →D) ∧((¬C) →A), (E →G) ∧(G →(¬D)), (¬E) →E.
(1) Let v((¬E) →E) = T ⇒V (E) = T. (2) Let v((E →G)∧(G →(¬D))) = T ⇒v(G →(¬D)) = T ⇒
v(G) = T ⇒v(D) = F. (2) Let v((A →B)∧(C →D)) = T ⇒v(A →B) = T, v(C →D) = T ⇒v(C) = F.
(3) Now suppose that v((B →D)∧((¬C) →A)) = T. Then v(B →D) = T, v(((¬C) →A)) = T ⇒v(B) =
F and from (2) →v(A) = F. From v(((¬C) →A)) = T this yields that v(¬C) = F ⇒v(C) = T. But this
contradicts the statement just before (3). Hence, v((B →D) ∧((¬C) →A)) = F in all possible cases and
the set of premises is INCONSISTENT.
(d) (A →(B ∧C)) ∧(D →(B ∧E)), ((G →(¬A)) ∧H) →I, (H →I) →(G ∧D), ¬((¬C) →E).
(1) Let v((A →(B ∧C)) ∧(D →(B ∧E))). = T ⇒v(A →(B ∧C)) = T, v(D →(B ∧E)) = T. (2) Let
v((¬((¬C) →E)) = T ⇒v((¬C) →E) = F ⇒v(E) = F, v(C) = F and from (1) ⇒v(D) = F, v(A) = F.
Also ⇒v(G ∧D) = F. (3) Let v((H →I) →(G ∧D)) = T ⇒v(H →I) = F ⇒v(H) = T, v(I) = F. (4)
Let V (((G →(¬A)) ∧H) →I) = T ⇒v(((G →(¬A)) ∧H)) = F ⇒v(G →(¬A)) = F. But this implies
that v(¬A) = F ⇒v(A) = T which contradicts the result in (2). Thus INCONSISTENT.
Exercise 2.11, Section 2.11
[1] ⊢(¬(¬A)) →A
(1) (¬(¬A)) →((¬(¬(¬(¬A)))) →(¬(¬A)))
. . . . . . . . . . . . . . . . . . . . . . .
P1
(2) ((¬(¬(¬(¬A)))) →(¬(¬A))) →((¬A) →(¬(¬(¬A))))
. . . . . . . . . . . . . . . . .
P3
(3) (¬(¬A)) →((¬A) →(¬(¬(¬A))))
. . . . . . . . . . . . . . . . . . . . . . . . HS(1, 2)
(4) ((¬A) →(¬(¬(¬A)))) →((¬(¬A)) →A)
. . . . . . . . . . . . . . . . . . . . . . .
P3
(5) (¬(¬A)) →((¬(¬A)) →A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . HS(3, 4)
(6) ((¬(¬A)) →((¬(¬A)) →A)) →
(((¬(¬A)) →(¬(¬A))) →((¬(¬A)) →A)) . . . . . . . . . . . . . . . . . . . . . .
P2
(7) ((¬(¬A)) →(¬(¬A))) →((¬(¬A)) →A)
. . . . . . . . . . . . . . . . . . . .
MP(5, 6)
(8) ((¬(¬A)) →(((¬(¬A)) →(¬(¬A))) →(¬(¬A)))) →(((¬(¬A)) →
((¬(¬A)) →(¬(¬A)))) →((¬(¬A)) →(¬(¬A))))
. . . . . . . . . . . . . . . . . . .
P2
(9) (¬(¬A)) →(((¬(¬A)) →(¬(¬A))) →(¬(¬A)))
. . . . . . . . . . . . . . . . . . . .
P1
(10) ((¬(¬A)) →((¬(¬A)) →(¬(¬A)))) →
((¬(¬A)) →(¬(¬A))) . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(8, 9)
(11) (¬(¬A)) →((¬(¬A)) →(¬(¬A))) . . . . . . . . . . . . . . . . . . . . . . . . . .
P1
(12) (¬(¬A)) →(¬(¬A)) . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(10, 11)
(13) (¬(¬A)) →A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(7, 12)
[2] (a) ⊢A →(¬(¬A))
(1) ((¬(¬(¬A))) →(¬A)) →(A →(¬(¬A)))
. . . . . . . . . . . . . . . . . . . . . . .
P3
(2) ⊢(¬(¬(¬A))) →(¬A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . from [1].
(3) A →(¬(¬A))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(1, 2)
(b) ⊢(¬B) →(B →A).
(1) (¬B) →((¬A) →(¬B))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P1
(2) ((¬A) →(¬B)) →(B →A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
P3
(3) (¬B) →(B →A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . HS(1, 2)
Exercise 2.12, Section 2.12
[1] (¬(¬A)) ⊢A.
(1) (¬(¬A))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(2) (¬(¬A)) →((¬(¬(¬(¬A)))) →(¬(¬A)))
. . . . . . . . . . . . . . . . . . . . . . . . .
P1
(3) (¬(¬(¬(¬A)))) →(¬(¬A))
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(1, 2)
113

(4) ((¬(¬(¬(¬A)))) →(¬(¬A))) →((¬A) →(¬(¬(¬A))))
. . . . . . . . . . . . . . . . . . .
P3
(5) (¬A) →(¬(¬(¬A)))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(3, 4)
(6) ((¬A) →(¬(¬(¬A)))) →((¬(¬A)) →A)
. . . . . . . . . . . . . . . . . . . . . . . . .
P3
(7) (¬(¬A)) →A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(5, 6)
(8) A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(1, 7)
[2] (a) A →B, B →C ⊢A →C.
(1) (B →C) →(A →(B →C))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P1
(2) B →C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(3) A →(B →C) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(1, 2)
(4) (A →(B →C)) →((A →B) →(A →C))
. . . . . . . . . . . . . . . . . . . . . . . .
P2
(5) (A →B) →(A →C) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(3, 4)
(6) (A →B)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(7) A →C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(5, 6)
(b) (¬A) ⊢A →B.
(1) ¬A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(2) ⊢(¬A) →(A →B)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Ex. 2.11 (2b)
(3) A →B
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(1, 2)
(c) Given ⊢(B →A) →((¬A) →(¬B)). Show that
¬(A →B) ⊢B →A.
(1) ¬(A →B)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(2) ⊢(B →A(→B)) →((¬(A →B)) →(¬B)) . . . . . . . . . . . . . . . . . . . . . . . Given
(3) (B →(A →B)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P1
(4) (¬(A →B)) →(¬B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(2, 3)
(5) (¬B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(1, 4)
(6) (¬B) →(B →A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Ex. 2.11 (2b)
(7) B →A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(5, 6)
Exercise 2.13, Section 2.13
1. Well, we use the statement that ⊢A →A in the proof of the deduction theorem.
2.
(A) Show that ⊢(B →A) →((¬A) →(¬B))
(1) B →A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise and D. Thm.
(2) ⊢(¬(¬B)) →B
. . . . . . . . . . . . . . . . . . . . . . . . . . .
Ex. 2.12.1 and D. Thm.
(3) (¬(¬B)) →A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . HS(1, 2)
(4) A →(¬(¬A))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ex 2.11: 2a
(5) (¬(¬B)) →(¬(¬A))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . HS(3, 4)
(6) ((¬(¬B)) →(¬A(¬A))) →((¬A) →(¬B))
. . . . . . . . . . . . . . . . . . . . . . . .
P3
(7) (¬A) →(¬B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(5, 6)
(8) ⊢(B →A) →((¬A) →(¬B)) . . . . . . . . . . . . . . . . . . . . . . . . . . . . D. Thm.
(B) Show that ⊢((A →B) →A) →A
(1) (A →B) →A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise D. Thm
(2) ⊢(¬A) →(A →B)
. . . . . . . . . . . . . . . . . . . . . . . . .
D.Thm. and Ex 2.12.2b
(3) (¬A) →A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . HS(1, 2)
(4) (¬A) →(¬(¬((¬A) →A)) →(¬A))
. . . . . . . . . . . . . . . . . . . . . . . . . . .
P1
(5) (¬(¬((¬A) →A)) →(¬A)) →(A →(¬((¬A) →A))
. . . . . . . . . . . . . . . . . . . .
P3
(6) (¬A) →(A →(¬((¬A) →A)))
. . . . . . . . . . . . . . . . . . . . . . . . . . . HS(4, 5)
114

(7) ((¬A) →(A →(¬((¬A) →A)))) →(((¬A) →A) →
((¬A) →(¬((¬A) →A))))
. . . . . . . . . . . . . . . . . . . . . .
P2
(8) ((¬A) →A) →((¬A) →(¬((¬A) →A))) . . . . . . . . . . . . . . . . . . . . . .
MP(6, 7)
(9) (¬A) →(¬((¬A) →A))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(3, 8)
(10) ((¬A) →(¬((¬A) →A))) →(((¬A) →A) →A)
. . . . . . . . . . . . . . . . . . . . .
P3
(11) ((¬A) →A) →A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(9, 10)
(12) A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(3, 11)
(13) ⊢((A →B) →B) →A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D. Thm.
[3]
A →B, A ⊢B
(1) ⊢A →A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Ex. 2.11.1
(2) A →B
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(3) (A →B) →(A →(A →B))
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P1
(4) A →(A →B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(2, 3)
(5) (A →(A →B)) →((A →A) →(A →B))
. . . . . . . . . . . . . . . . . . . . . . . .
P2
(6) (A →A) →(A →B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(4, 5)
(7) A →B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MP(1, 6)
Exercise 2.14, Section 2.14
[1] (a) (i) B, C ⊢(¬B) →(¬C). (ii) B, (¬C) ⊢(¬B) →(¬C). (iii) (¬B), C ⊢¬((¬B) →(¬C)). (iv)
(¬B), (¬C) ⊢(¬B) →(¬C).
(b) (i) B, C ⊢B →C. (ii) B, (¬C) ⊢¬(B →C). (iii) (¬B), C ⊢B →C. (iv) (¬B), (¬C) ⊢B →C.
(c) (i) B, C, D ⊢B →(C →D). (ii) B, C, ¬D ⊢¬(B →(C →D)). (iii) B, ¬C, D ⊢B →(C →D).
(iv) B, ¬C, ¬D ⊢B →(C →D). (v) ¬B, C, D ⊢B →(C →D). (vi) ¬B, C, ¬D ⊢B →(C →D).
(vii)¬B, ¬C, D ⊢B →(C →D).(viii) ¬B, ¬C, ¬D ⊢B →(C →D).
(c) (i) B, C, D ⊢¬(B →(C →D)). (ii) B, C, ¬D ⊢B →(C →D). (iii) B, ¬C, D ⊢¬(B →(C →
D)). (iv) B, ¬C, ¬D ⊢¬(B →(C →D)). (v) ¬B, C, D ⊢B →(C →D). (vi) ¬B, C, ¬D ⊢B →(C →
D). (vii)¬B, ¬C, D ⊢B →(C →D).(viii) ¬B, ¬C, ¬D ⊢B →(C →D).
Exercise 2.16, Section 2.16
Almost all of the interesting stuﬀabout consequence operators involves a much deeper use of set-theory than
used in these questions.
[1] Let A ⊂B. Suppose thatA ∈C(A). Then there is a ﬁnite F ⊂A such that A ∈C(F). But F ⊂B. Thus
A ∈C(B). Therefore, C(A) ⊂C(B).
[2] Let A ⊂C(B). Then C(A) ⊂C(C(B)) = C(B) from [1] and our axioms.
Conversely, suppose that C(A) ⊂C(B). Since A ⊂C(A), then A ⊂C(B).
[3] We know that A∪B ⊂A∪C(B) ⊂C(A)∪C(B) ⇒(a) C(A∪B) ⊂C(A∪C(B)) ⊂C(C(A)∪C(B)). Now
C(A) ⊂C(A ∪B), C(B) ⊂C(A ∪B) ⇒C(A) ∪C(B) ⊂C(C(A ∪B)) = C(A ∪B). Combining this with (a)
implies that C(A ∪B) ⊂C(A ∪C(B)) ⊂C(C(A) ∪C(B)) ⊂C(A ∪B). Hence C(A ∪B) = C(A ∪C(B)) =
C(C(A) ∪C(B)).
Note: This is reasonable. You cannot get more deductions if you consider the premises broken up into
subsets.
Exercise 2.17, Section 2.17
[1] (ii) If B ∈L′, then either B ∈Γ or ¬B ∈Γ not both.
Proof. Assume that B /∈Γ. Then Γ ∪{B} is inconsistent. Thus there is a ﬁnite {A1, . . . , An} ⊂Γ
and A1, . . . , An, B ⊢C ∧(¬C), for some C ∈L′. We know that C ∧(¬C) |= D for any D ∈L′. Thus
115

C ∧(¬C) |= ¬B. Hence, A1, . . . , An, B |= ¬B ⇒A1, . . . , An |= B →(¬B) |= ¬B ⇒A1, . . . , An |= ¬B ⇒
A1, . . . , An ⊢¬B ⇒¬B ∈Γ. Suppose that B, ¬B ∈Γ. Then this contradicts Theorem 2.17.1 (e).
(iii) If B ∈Γ, then A →B ∈Γ for each A ∈L′.
Proof. Let B ∈Γ. The Γ ⊢B. Thus there is a ﬁnite F ⊂Γ such that F ⊢B. Hence F |= B. But
B |= A →B for any A ∈L′. Hence F |= A →B ⇒F ⊢A →B ⇒Γ ⊢A →B ⇒A →B ∈Γ.
(iv) If A /∈Γ, then A →B ∈Γ for each B ∈L′.
Proof. If A /∈Γ, then ¬A ∈Γ from (ii). But for any B ∈L′, ¬A |= A →B ⇒¬A ⊢A →B and since
¬A ∈Γ, Γ ⊢A →B. Hence A →B ∈Γ.
(v) If A ∈Γ and B /∈Γ, then A →B /∈Γ.
Proof. Let A ∈Γ, B /∈Γ. Suppose that A →B ∈Γ. Then Γ ⊢A →B. Since Γ ⊢A, by one MP step
Γ ⊢B ⇒B ∈Γ; a contradiction. The result follows.
[2] (a) |= A iﬀ{¬A} is not satisﬁable.
Proof. Let |= A. Then for each a, v(A, a) = T. Hence for each a, v(¬A, a) = F. Hence {¬A} is not
satisﬁable.
Conversely, let {¬A} not be satisﬁable. Then for each a, v(¬A, a) = F. This for each a, v(A, a) = T.
Thus A is satisﬁable.
(b) {A} is consistent iﬀ̸⊢¬A.
Proof. Let {A} be consistent and ⊢¬A. Hence |= ¬A. Hence for each a, v(¬A, a) = T ⇒v(A, a) = F.
Hence A |= B ∧(¬B) for some B. Thus A ⊢B ∧(¬B). Thus {A} is inconsistent: a contradiction.
Conversely, let ̸⊢¬A. Then ̸|= ¬A. Hence there is some a such that v(¬A, a) = F ⇒v(A, a) = T ⇒
A ̸|= B ∧(¬B) for any B. A ̸⊢B ∧(¬B) for any B implies that {A} is consistent.
(c) The Completeness Theorem is equivalent to the statement that every consistent formula is satisﬁable.
Proof. Assume Completeness Theorem. Now let {A} be consistent. Then from (b) ̸⊢¬A. Hence from
Completeness contrapositive, we have that ̸|= ¬A. Thus there is some a such that v(¬A, a) = F. Hence
v(A, a) = T. Thus {A} is satisﬁable.
Conversely, assume that all consistent formula are satisﬁable. [Note we cannot use the Completeness
Theorem since this is what we want to establish.] Let |= A. Then clearly ¬A is not satisﬁable. Hence,
from the contrapositive of our assumption, {¬A} is inconsistent.
Thus ¬A ⊢anything.
Consequently,
¬A ⊢A ⇒(a) ⊢(¬A) →A. But ⊢(A →A) →(((¬A) →A) →A), by example 2.15.4. But ⊢A →A.
Hence by one MP step we have that ⊢((¬A) →A) →A. Adjoining this formal proof to (a), and we get ⊢A.
This is but the Completeness Theorem.
[3] (a) Let a be any assignment to A. Then since |= A →A. Now this could be established by formal
induction, but more simply, note that if ∅̸= F ⊂Γ, then one member of F contains that largest number of
As, say n ≥2 and the smallest sized subformula is A →A which has truth value T . All other formula, if
any, have A →to the left etc. and, hence, have value T . It appears that Γ is consistent.
(b) {A3} is ﬁnite inconsistent subset of Γ. Hence Γ is inconsistent.
(c) {A1, A2} is a ﬁnite inconsistent sunset of Γ. Hence, Γ is inconsistent.
Exercise 3.1, Section 3.1
[1] (a) A ∈Pd, (b) A /∈Pd, [Note the ∃c.] (c) A /∈Pd, [Note the third (. (d) A /∈Pd, [Note the symbols
∀y).] (e) A /∈Pd, [Note the missing last two parentheses.]
[2] (a) size (A) = 3, (b) size (A) = 4 (c) size (A) = 4, (d) size (A) = 4.
[3] Please note the way I’ve translated these statements into ﬁrst-order predicate form is not a unique
translation. It is, however, in a mathematically standard form. Also note that from this moment on, we will
simply any formula that has a sequence of more than one ∧s or ∨s by not putting parentheses about the inner
subformula. Indeed, the way we write or language tends not to include pauses between such combinations.
[They are all equivalent no matter where we put the parentheses.] Finally notice that when we use the
operators as abbreviations for the predicates we include ( and ) only to avoid confusion. If you make a
complete substitution , it will look like this (x + 1 = y) ≡R(x, 1, y).
116

(a) ∀x((P(x) ∧(x = 0)) →(∃y(Q(y, x) ∧(y > x))))
(b) ∀x(R(x) →(∃y(R(x) ∧(y > x))))
(c) ∀x(∃y(∀z((R(x) ∧R(y) ∧R(z) ∧(z + 1 < y)) →(x + 2 < 4))))
(d) ∀x((W(x) ∧L(x)) →(∃y(J(y) ∧A(x, y))))
(e) ∃x(L(x) ∧S(x) ∧A(x, j))
(f) ∀x(∀y(∀z(((P(x) ∧P(y) ∧P(z) ∧R(x, z) ∧R(y, z)) →R(x, y))))
(g) ∀x(B(x) →M(x))
(h) ∀x(P(x) →(C(x) ∧U(x)))
(i) ∀x(∀y(∀z((x = y) ∧(y = z) ∧(x = z) ∧(x > 0) ∧(y > 0) ∧(z > 0) ∧(x + y + z > 3)∧
(x + y + z < 9)) →((1 < x < 3) ∧(1 < y < 3) ∧(1 < z < 3)))))
(j) ∀x(∀y((P(x) ∧P(y) ∧B(x, y)) ↔(M(x) ∧M(y) ∧(¬(x = y)) ∧Q(x, y))))
[4] [Note: In what follows, you do not need to inquire whether of not the statement holds in order to translate
into symbolic form.]
(a) Seven is a prime number and seven is an odd number.
(b) (Two diﬀerent ways). For each number, if 2 divides the number, then the number is even. [Note:
A metalanguage variable symbol can also be used. For each X, if 2 divides X, then X is even. You can also
write it more concisely as “For each X, if X is a number and 2 divides X, then X is even.” This is the very
important “bounded form.” The X is restricted to a particular set.]
(c) Using the metasymbol method, we have “There exists an X such that X is an even number and X is
a prime number, and there does not exist an X such that X is an even number and X is a prime, and there
exists some Y such that Y is not equal to X and Y is an even number and Y is a prime number.
(d) For each X; if X is an even number, then for each Y, if X divides Y, then Y is an even number.
(e) For each X, if X is an odd number, then there exists a Y such that if Y is a prime number, then Y
divides X.
Exercise 3.2, Section 3.2
[1] (a) (1) scope = ∃xQ(x, z). (2) scope = Q(x, z). (3) scope = Q(y, z).
(b) (1) scope = ∀y(P(c) ∧Q(y)). (2) scope = P(c) ∧Q(y). (3) scope = R(x).
(c) (1) scope = (Q(y, z) →(∀xR(x))). (2) scope = R(x).
(d) (1) scope = (P(z) ∧(∃xQ(x, z))) →(∀z(Q(c) ∨P(z)))). (2) scope = Q(x, z). (3) scope = (Q(c) ∨
P(z))).
[2]
(a) ∀z3(∃y2(P(z3, y2) ∧(∀z1Q(z1, x)) →M(z3))).
(b) ∀x3(∃y2(P(x3, y2) ∧(∀y1Q(y1, x3)) →M(x3))).
(c) ∀z3(∃x2(P(z3, x2) ∧(∀z1Q(z1, y)) →M(z3))).
(d) ∀y3(∃z2(P(y3, z2) ∧(∀z1Q(z1, x)) →M(y3))).
(e) ∀y3(∃z2(P(z2, y3) ∧(∀z1Q(z1, x)) →M(y3))).
(f) ∃x3(∀z2(P(x3, z2) ∨(∀u1M(u1, y, x3)))).
(g) ∃y3(∀x2(P(z, x2) ∨(∀x1M(x1, u, y3)))).
(h) ∃y3(∀x2(P(y3, x2) ∨(∀x1M(x1, y3, z)))).
(i) ∃z3(∀x2(P(z3, x2) ∨(∀x1M(x1, y, z3)))).
(j) ∃x3(∀x2(P(z, x2) ∨(∀z1M(x2, y, z1)))).
[3] (a) ∼= (d); (f) ∼= (i).
[4] (a) Free, x, y, z; Bound x, z.
117

(b) Free, z: Bound x, z.
(c) Free, x, y; Bound x.
(d) Free, z; Bound x, y, z.
(e) Free, x; Bound x, y.
(f) Free, none; Bound x, y.
[5] (a) They are (b), (d). (b) It is (b). (c) It is (f)
Exercise 3.3, Section 3.3
[1] (a) Sx
a (∃xP(x)) →R(x, y)] = (∃xP(x)) →R(a, y). (b) Sy
x (∃yR(x, y)) ↔(∀xR(x, y))] = (∃yR(x, y)) ↔
(∀xR(x, x)). (c) Sy
a
(∀xP(y, x)) ∧(∃yR(x, y))]
=
(∀xP(a, x)) ∧(∃yR(x, y)), (d) Sx
aSx
b (∃xP(x))
→
R(x, y)]] = (∃xP(x)) →R(b, y). (e) Sx
aSy
x(∃yR(x, y)) ↔(∀xR(x, y))]] = (∃yR(x, y)) ↔(∀xR(x, x)). (f)
Sx
aSy
b (∀zP(y, x)) ∧(∃yR(x, y))]] = (∀zP(b, a)) ∧(∃yR(a, y))
[2] (a) always true. (b) NOT true. Consider the example ∀yP(x, y). (c) Always true. An argument is that,
for the left hand side, we ﬁrst substitute for all free occurrences of z, if any, a w. Whether or not the result
gives no free occurrences of w or not will not aﬀect the substitution of x for the free occurrences of y since
these are all distinct variables. The same argument goes for the right hand side. (d) Always true. These are
the “do nothing” operators.
[3] (I have corrected the typo. by inserting the missing ( and ) in each formula.)
(a) A = (∀x(P(c) ∨Q(x, x))) →(P(c) ∨∀xQ(x, x)). We need to determine what the value of (∀x(P(c) ∨
Q(x, x))) is for this structure. Thus we need to determine the “value” of the statement P ′(a′) or Q′(a′, a′)
and P ′(a′) or Q′(b′, b′). Since a′ ∈P ′ then M |= (∀x(P(c) ∨Q(x, x))). For the statement (P(c) ∨∀xQ(x, x)),
the same fact that a′ ∈P ′ yields that M |= (P(c) ∨∀xQ(x, x)). Hence M |= A.
(b) A = (∀x(P(c) ∨Q(x, x))) →(P(c) ∧∀xQ(x, x)). We repeat the above for (∀x(P(c) ∨Q(x, x))) and
get M |= (∀x(P(c)∨Q(x, x))). We now check (P(c)∧∀xQ(x, x)). We know that M |= P(c). But (b′, b′) /∈Q′.
Hence M ̸|= (P(c) ∧∀xQ(x, x)) ⇒M ̸|= A.
(c) A = (∀x(P(c) ∨Q(x, x))) →(P(c) ∧∃xQ(x, x)). Again we know that M |= (∀x(P(c) ∨Q(x, x))).
Also M |= P(c). Further, (a′, a′) ∈Q′. Thus M |= ∃xQ(x, x)) ⇒M |= (P(c) ∧∃xQ(x, x)) ⇒M |= A.
(d) A = (∀x(P(c) ∧Q(x, x))) ↔(P(c) ∧∀xQ(x, x)). First, we know that M |= P(c). But (b′, b′) /∈Q′.
Hence, know that under our interpretation the mathematical statement corresponding to (∀x(P(c)∧Q(x, x)))
is false. Thus M ̸|= (∀x(P(c) ∧Q(x, x))). We now check (P(c) ∧∀xQ(x, x)). Again since (b′, b′) /∈Q′ the
mathematical statement is false. But then this implies that M |= A.
(e) A = (∀x(P(c) ∧Q(c, x))) ↔(P(c) ∧∀xQ(x, x)). Since (a′, a′), (a′, b′) ∈Q′ and a′ ∈P ′ the math-
ematical statement (∀x(P(c) ∧Q(c, x))) holds for this structure. Thus M |= (∀x(P(c) ∧Q(c, x))). But as
shown in (d) M ̸|= (P(c) ∧∀xQ(x, x)). Hence, M ̸|= A.
Exercise 3.4, Section 3.4
[1] (a) Note that it was not necessary to discuss special structures in our deﬁnition for validity unless we
wanted to ﬁnd a countermodel. But in this case we need to also look at certain special structures. In
particular, the case for this problem that P ′ = ∅. But in this case, for any structure MI ̸|= (∀x(∃yP(x, y))).
Thus for this possibility, MI |= (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))).
Now letting D = {a′}, then the only other possibility is that P ′ = {(a′, a′)}. Mathematically, it is
true that there exists an a′ ∈D, for all a′ ∈D we have that (a′, a′) ∈P ′. Hence, in this case, MI |=
∃y(∀xP(x, y))). Consequently, MI |= (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))).
(b) Consider D = {a′, b′}, P ′ = {(a′, a′), (b′, b′)}. Then since (a′, a′), (b′, b′) ∈P ′, it follows that MI |=
(∀x(∃yP(x, y))). However, since (b′, a′), (b′, b′) /∈P ′ the mathematical statement “there exists some d′ ∈D
such that (a′, d′), (b′, d′)” does not hold.
[Notice that the diﬀerence is that in the ﬁrst case the second
coordinate can be any member of D while in the second case it must be a ﬁxed member of D. Therefore,
MI ̸|= (∀x(∃yP(x, y))) →(∃y(∀xP(x, y))) and the formula is not 2-valid. [Hence, not valid in general]
[2]. In what follows I will make the substitution and see what happends in ecah case. (a) A = ∀w(P(x) ∨
(∀xP(x, y)) ∨P(w, x)); λ = y ⇒∀w(P(y) ∨(∀xP(x, y)) ∨P(w, y)). Since y ̸= w then y is free for x in A.
118

(b) A = ∀w(P(x) ∨(∀xP(x, y)) ∨P(w, x)); λ = w ⇒∀w(P(x) ∨(∀xP(x, y)) ∨P(w, w)). Now the variable
has gone from a free occurrence in the underlined part to a bound occurrence. Hence w is not free for x in
this A.
(c) A = (∀x(P(x) ∨(∀yP(x, y)))) ∨P(y, x); λ = x. Yes, any variable is always free for itself.
(d) A = (∀x(P(x) ∨(∀yP(x, y)))) ∨P(y, x); λ = y ⇒(∀x(P(x) ∨(∀yP(x, y)))) ∨P(y, y). Since the only
place that x is free in this formula is in the underlined position, the result of substitution still gives a free
occurrence, this time of y. Hence, in this case, y is free for x in A.
(e) A = (∀x(∃yP(x, y)) →(∃yP(y, y, )); λ = y. Since there are no free occurrences of x in this formula, then
any variable is free for x in this formula.
(f) A = (∃zP(x, z)) →(∃zP(y, z)); λ = z ⇒(∃zP(z, z)) →(∃zP(y, z)). Since at the only position that x
was free, the substitution now makes this position a bound occurrence, then z is not free for x in A.
[3] See the above formula where I have made the substitutions in all cases.
[4] Assume that C does not have x as a free variable and that B may contain x as a free variable. Further, it’s
assumed that there are no other possible free variables. [This comes from, our use of the special process (i).]
∃x(C ∧B) is a sentence. Let MI be an arbitrary structure. Assume that MI |= ∃x(C ∧B). Then there exists
some d′ ∈D, MI |= Sx
d(C ∧B)] = C ∧Sx
dB]. Hence, MI |= C and for some d′ ∈D, MI |= Sx
dB]. Hence,
MI |= (C ∧(∃xB)). Then in like manner, since x is not free in C, MI |= (C ∧(∃xB)) ⇒MI |= ∀x(C ∧B).
[Note I have just copied the metaproof of (vii) and made appropriate changes.]
[5] (a) Q(x) →(∀xP(x)). Of course, we ﬁrst take the universal closure. This gives the sentence ∀(Q(x) →
(∀xP(x))). I have an intuitive feeling, since Q can be anything, that this in invalid. So, we must display
a countermodel. To establish that MI |= Q(x) →(∀xP(x)). We consider Sx
d(Q(x) →(∀xP(x))). Since x
is not free in ∀xP(x), the valuation of Sx
d(Q(x) →(∀xP(x))) is the same as the valuation for (∀xQ(x)) →
(∀xP(x)). Now this makes sense. But this is not even 1-valid. For take D = {a′}, Q′ = D, P ′ = ∅. Then
MI |= (∀xQ(x)) but MI ̸|= (∀xP(x)). Hence MI ̸|= ∀(Q(x) →(∀xP(x))). Thus the formula is INVALID.
(b) (∃xP(x)) →P(x). One again you consider the universal closure and we consider the formula
(∃xP(x)) →(∀xP(x)). Thus also does not seem “logical” in general. [Note that taking an empty rela-
tion will not do it.] But take D = {a′, b′}, P ′ = {a′}. Now it follows that MI |= (∃xP(x)). Since b′ /∈P ′,
then MI ̸|= (∀xP(x)). Thus INVALID.
(c) (∀x(P(x) ∧Q(x))) →((∀xP(x)) ∧(∀xQ(x))). We don’t need to do much work here. Simply consider
Theorem 3.4.9 part (vi). Then let A = P(x), B = Q(x). Since that formula is valid, then if MI is any
structure for (c), and MI |= (∀x(P(x)∧Q(x))), then MI |= ((∀xP(x))∧(∀xQ(x))). Thus formula is VALID.
(d) (∃x(∃yP(x, y))) →(∃xP(x, x)). This seems to be be invalid since mathematically in the for MI |=
(∃x(∃yP(x, y))) we do not need x = y in the mathematical sense. This is that you can have some a′ and some
b′ ̸= a′, which satisfy a binary relation but (a′, a′) and (b′, b′) do not and this is exactly how we construct
a countermodel. Let D = {a′, b′}, P ′ = {(a′, b′)}. Then MI |= (∃x(∃yP(x, y))), but MI ̸|= (∃xP(x, x)).
Hence INVALID
(e) (∃xQ(x)) →(∀xQ(x)). This also seems to be invalid. Well, take D = {a′, b′}, Q′ = {a′}. Then
clearly, MI |= (∃xQ(x)). But since b′ /∈Q′, then MI ̸|= (∀xQ(x)).
[6] [This is a very important process.]
(a) (¬(∃xP(x))) ∨(∀xQ(x)) ≡(¬(∃xP(x))) ∨(∀yQ(y)) ≡(∀x(¬P(x))) ∨(∀yQ(y)) ≡∀y(Q(y) ∨
(∀x(¬P(x))) ≡∀y(∀x(Q(y) ∨P(x))).
(b) ((¬(∃xP(x))) ∨(∀xQ(x))) ∧(S(c) →(∀xR(x))) ≡((∀y(¬P(y))) ∨(∀xQ(x))) ∧(S(c) →(∀xR(x))) ≡
(∀y(∀x(¬P(y) ∨Q(x)))) ∧(S(c) →(∀xR(x))) ≡(∀y(∀x(¬P(y) ∨Q(x)))) ∧(S(c) →(∀zR(z))) ≡
(∀y(∀x(¬P(y) ∨Q(x)))) ∧(S(c) →(∀zR(z))) ≡(∀y(∀x(¬P(y) ∨Q(x)))) ∧(∀z(S(c) →R(z))) ≡
∀y(∀x(∀z((¬P(x)) ∨Q(x)) ∧(S(c) →R(z)))).
(c) ¬(((¬(∃xP(x)))∨(∀xQ(x)))∧(∀xR(x))) ≡¬(∀y(∀x(∀z((¬P(x))∨Q(y))∧R(z)))) = ∃y(∃x(∃z(P(x)∧
(¬Q(y))) ∨(¬R(z)))).
Exercise 3.4, Section 3.5
119

As suggested, I might try the deduction theorem for valid consequence determinations. [1] (a) Consider
A1 = ∀x(Q(x) →R(x)), A2 = ∃xQ(x), B = ∃xR(x).
Suppose that MI is ANY structure, deﬁned for A1, A2, B such that MI ̸|= ∃xR(x). Hence, for
each c′ ∈D, c′ /∈R′. Thus, we have that R′ is the empty set. Hence, under the hypothesis assume that
MI |= ∀x(Q(x) →R(x)). This means that for each c′ ∈D, MI |= Q(c) →R(c). However, we know that
MI ̸|= R(c) for each c′ ∈D. Hence for each c′ ∈D, MI ̸|= ∃xQ(c). Therefore, MI ̸|= Q(x). This implies
that it is a VALID CONSEQUENCE.
Not using the deduction theorem, proceed as follows: suppose that MI is a structure deﬁned for
A1, A2, B. Let MI |= A1, MI |= A2. Then for every c′ ∈D, MI |= Q(c) →R(c). Now since MI |= A2,
then there is some c′
1 ∈D such that MI |= Q(c1) (i.e. Q′ is not empty). Since MI |= Q(c1) →R(c1), then
for this c′
1 we have that MI |= R(c1). Hence MI |= B. Thus it is a VALID CONSEQUENCE.
(b) A1 = ∀x(Q(x) →R(x)), A2 = ∃x(Q(x) ∧Z(x)) |= B = ∃x(R(x) ∧Z(x)). (Without deduction theorem.)
Suppose that there is any structure MI deﬁned for A1, A2, B and MI |= A1, MI |= A2. Hence, for each
c′ ∈D, MI |= Q(c) →R(c) and there exists some c′
1 ∈D such that MI |= Q(c1) ∧Z(c1). Thus c′
1 ∈Q′
and c′
1 ∈Z′. Since c′
1 ∈Q′, then c′
1 ∈R′. Thus using this c′
1 we have that MI |= ∃x(R(x) ∧Z(x)). Hence
MI |= B implies that we have a VALID CONSEQUENCE.
(c) A1 = ∀x(P(x) →(¬Q(x))), A2 = ∃x(Q(x) ∧R(x)) |= B = ∃x(R(x) ∧(¬Q(x))).
We have a feeling that this might be invalid, so we need to construct a countermodel Consider a one
element domain D = {a′}. Let P ′ = ∅, Q′ = R′ = D. Let MI = ⟨D, P ′, Q′, R′⟩. Then MI |= A1, and
MI |= A2. But, since there is no member of c′ ∈D such that MI |= R(c) and MI |= ¬Q(x) (i.e. there is
no member of D that is a member of D and not a member of D), it follows that MI ̸|= B. Hence, argument
if INVALID.
(d) A1 = ∀x(P(x) →Q(x)), A2 = ∃x(Q(x) ∧R(x)) |= B = ∃x(R(x) ∧(¬Q(x))).
Take the same structure as deﬁned in (c). The fact that MI |= A1 is not dependent upon the deﬁnition
of Q′. Hence, the argument is still INVALID.
Exercise 3.6, Section 3.6
(A) ∀x(A →B), ∀x(¬B) ⊢∀x(¬A).
(1) ∀x(A →B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(2) ∀x(¬B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Premise
(3) ∀x(A →B) →(A →B)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P5
(4) A →B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(1,3)
(5) (A →B) →((¬B) →(¬A)) . . . . . . . . . . . . . . . . . . . . . . . . . . Exer. 2.13, 2A.
(6) (¬B) →(¬A) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(4,5)
(7) (∀x(¬B)) →(¬B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P5
(8) ¬B
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(2,7)
(9) ¬A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(6,8)
(10) ∀x(¬A)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G(9)
(B) ∀x(∀yA) ⊢∀y(∀xA)
(1) ∀x(∀yA)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(2) (∀x(∀yA)) →∀yA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P5
(3) ∀yA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(1,2)
(4) (∀yA) →A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P5
(5) A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(3,4)
(6) ∀xA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G(5)
(7) ∀y(∀xA)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G(6)
(C) A, (∀xA) →C ⊢∀xC
120

(1) A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(2) ∀xA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G(1)
(3) (∀xA) →C
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(4) C
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(2,3)
(5) ∀xC
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G(4)
(D) ∀x(A →B), ∀xA ⊢∀xB
(1) ∀x(A →B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(2) ∀xA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Premise
(3) (∀x(A →B)) →(A →B) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P5
(4) A →B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(1,3)
(5) (∀xA) →A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P5
(6) A
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(2,5)
(7) B
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . MP(4,6)
(8) ∀xB
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
G(7)
Exercise 3.7, Section 3.7
1. Using the special process, it may be assumed that A has no free variables and the B has at most one
free variable x. We show that |= (∀x(A →B)) →(A →(∀xB)).
Proof. Let MI be any structure deﬁned for A, B and we only need to suppose that MI ̸|= A →(∀xB).
Consider the case that x is not free in B. Then B is a sentence. Now in this case MI |= ∀x(A →B)
iﬀMI |= A →B. Since MI ̸|= B and MI |= A, it follows that MI ̸|= A →B. Hence MI |= (A →B) →
(A →B).
Now assume that x is free in B. Then we know that for MI |= ∀x(A →B) then MI |= A →Sx
dB for
each c′ ∈D. But, we have from our assumption that MI |= A and there is some c′ ∈D such that MI ̸|= Sx
dB.
Hence MI ̸|= Sx
dB for each c′ ∈D. Thus MI ̸|= ∀x(A →B). Therefore, MI |= (∀x(A →B)) →(A →B).
Exercise 3.8, Section 3.8
1. Modify the argument given in example 3.8.1 as follows: let L(x, y) correspond to the natural number
binary relation of “less than” (i.e. <). Give an argument that shows that there is a structure ∗MI that
behaves like the natural numbers but in which there exists a member b′ that is “greater than” any of the
original natural numbers.
As in that example, let Γ be the theory of natural numbers, described by a given Pd, and each member
of C denotes a member of the domain D for a model MI for Γ, where MI |= models all of the theory
deﬁnable predicts as well. Again we let b be a constant not in the original C and adjoin this the C. Consider
the set of sentences Φ = {L(c, b) | c ∈C}. Now consider the set of sentences Γ ∪Φ and let A be a ﬁnite
subset of Γ∪Φ. If {a1, . . . , an} ⊂A and {a1, . . . , an} ⊂Γ, then MI |= is a model {a1, . . . , an}. Suppose that
{an+1, . . . , am} are the remaining members of A that are not in Γ. Now we investigate the actual members
of Φ. We know from the theory of natural numbers that for any ﬁnite set of natural numbers there is a
natural number b′ greater than any member of that set. Now each member of {an+1, . . . , am} is but the
sentence L(c, b) where c ∈C and b ̸∈C. Thus there are at most ﬁnitely many diﬀerent ci ∈C contained in
the formula in {an+1, . . . , am}. Each of these is interpreted as a name for a natural number. Hence let b be
interpreted as one of the b′ >′ all of the c′
i. Consequently, MI |= A. Thus from the compactness theorem
there is a structure ∗MI that behaves in Pdb like the natural numbers but contains a type of natural number
that is “greater than” all of the original natural numbers.
2. Let IR denote the set of all real numbers. Let C be a set of constants naming each member of IR and
suppose that Pd is the language that describes the real numbers. Suppose that b is a constant not a member
of C. Let Γ be the theory of real numbers. Let Q(0, y, x) be the 3-place predicate that corresponds to the
deﬁnable real number 3-place relation 0′ < c′ < d′, where 0′, c′, d′ ∈IR. Now in the real numbers there is a
set of elements G′ such that each member c′ of G′ has the property that 0′ < c′. Let G be the set of constants
121

that correspond to the members of the set G′. Consider the set of sentences Φ = {Q(0, b, g) | g ∈G} in the
language Pdb. Give an argument that shows that there exists a structure ∗MI such that ∗MI |= Γ∪Φ. That
is there exists a mathematical domain D that behaves like the real numbers, but D contains a member b′
such that b′ is “greater than zero” but b′ is “less than” every one of the original positive real numbers.
Well, simply consider any ﬁnite subset A of Γ∪Φ. Suppose that {a1, . . . , an} ⊂A and that {a1, . . . , an} ⊂
Γ. Let MI |= Γ, where MI |= models all of the theory deﬁnable predicts as well. Then MI |= {a1, . . . , an}.
Now suppose that {an+1, . . . , am} are the remaining members of A that are not in Γ. Now each member of
{an+1, . . . , am} is of the form Q(0, b, g) where g ∈G is interpreted as a real number greater than 0′. Since,
in this case the g represent a ﬁnite set of such real numbers, then one of these real numbers, say g′
1, is the
“smallest one” with respect to <′. Now consider the real number g′
1/2 and let b be interpreted as this real
number. Then MI |= {an+1, . . . , am}. Hence we have that MI |= A. The compactness theorem states that
there is a structure ∗MI that behaves, in Pdb, like the real numbers. And, there exists in the structure a
real like number b′ such that 0′ <′ b′ <′ g′ for all of the original real numbers g′ such that 0′ <′ g′.
Discussion
In what follows prime notation has been charged to *
[1] (Note that we don’t mention the “constant” in the structure notation since we have originally
assigned all members of the domain and some members of the new domain constant names.) In the structure
∗MI = < ∗IN, ∗+, ∗=, ∗<, . . . > all the usual properties that can be expressed in a the appropriate ﬁrst-order
language hold for
∗MI. One extremely useful additional property that one would like
∗MI to possess is
the embedding property. Is there a subset of ∗IN that can be used in every way as the natural numbers
themselves where the * operators restricted to this subset have the same properties as the original natural
numbers? After some eﬀort in model theory, the answer is yes. Thus we can think of the natural numbers IN
as a “substructure” of the ∗MI. The interesting part of all of this is that a simple comparison of properties
can now be made. If there is one natural number
∗b then you can consider the set of all such members
of ∗IN. This set is denoted by IN∞and is called the set of all “inﬁnite natural numbers.” It has a algebra
that behaves as Newton wished for such objects. For example, if λ, β ∈IN∞and nonzero n ∈IN, then
nλ + β ∈IN∞. Further, for any n ∈IN, we have that λ −n ∈IN∞, [can you show this?] where we now
think of IN as the non-negative integers. But ∗IN has a property that no set of natural numbers has and
this property is why the set ∗IN cannot be “graphed” in the usual manner. Every nonempty subset of IN
has a ﬁrst element. This means that if nonempty A ⊂IN, then there is some a ∈A such that a ≤x for all
x ∈A. But the set IN∞does not have a ﬁrst element with respect to ∗<. Suppose that IN∞does have a ﬁrst
element λ1. Then if you establish what has been written above, since the same basic properties for ∗< hold
as they do for <, we have that λ1 −1 ∗<λ1, which contradicts the concept of ﬁrst element with respect to
∗<. Indeed, a recent published paper that I am reviewing, has forgotten this simple fact.
[2] The structure here ∗MI = < ∗IR, ∗+, ∗·, ∗<, · · · > can have MI = < IR, +, ·, <, . . . > embedded into
it in such a manner that MI is a substructure of ∗MI. And, as in [1], this substructure behaves relative to
the all the properties of the ﬁrst-order theory of real numbers just like the real numbers. In this case, we
have that ∗0 = 0 ∗< ∗b ∗< r for each positive real number r ∈IR. Now we consider the entire set of all such
∗b and call this the set of positive inﬁnitesimals µ(+0). Since all the algebra holds one adjoins to this set the
0 and {−ǫ | ǫ ∈µ(+0)} = µ(0). Do these satisfy the theory of the “inﬁnitely small” of Newton? Well, here
are a few properties. First, the normal arithmetic of the real numbers holds for µ(0). This we have that
if ǫ ∈µ(+0), then 1/ǫ ∗> r for any r ∈IR. Also when Newton had an object he called inﬁnitely small and
squared it he claimed that this was “more inﬁnitely small” in character. Well, 0 ∗< ǫ2 ∗< ǫ and they are not
equal. Then Newton claimed that if he took any real number and multiplied it by an inﬁnitely small number
that the result was still inﬁnitely small. One can establish that for each r ∈IR, we have that r ∗· ǫ ∈µ(0).
Indeed, we can establish that if f is any function deﬁned on IR, continuous at r = 0 and f(0) = 0, then all
the properties of f hold for ǫ and when they are applied to ǫ the result is always an inﬁnitesimal. There
is no where in the use of the Calculus that these inﬁnitesimals contradict the intuitive procedures used by
mathematicians through 1824. Their properties also correct the error discovered in 1824 that led to the
introduction of the limit concept.
122

A
and-gate 29.
assignment 15.
atomic formula,
propositional 13.
predicate 64.
ﬁrst-order language 64.
atoms,
propositional 9, 10.
predicate 63.
ﬁrst-order language 63.
B
binary 9,
relation 22.
bound occurrence of the constant
68.
C
closed formula 69.
common pair 15, 13,
rule 13.
complete set 59.
composite formula 64.
congruent formula 69.
connectives 9.
consequence,
of Γ 57.
consequence operator 55.
consistent,
propositional 39.
predicate, ﬁrst-order 91.
constants, insertion of 63, 57.
contradiction,
propositional 39.
predicate, ﬁrst-order 91.
countermodel 76.
D
deduction,
from a set of Γ 45.
deductive processes 98.
deductive system 59.
demonstration 45.
denial 26.
descriptions 98.
domain for a structure 72.
equality 22.
E
equivalence relation 23.
existential quantiﬁer 64.
extralogical symbols 10.
F
formal demonstration,
ﬁrst-order, 86.
formal proof, propositional 42,
43.
formally consistent,
predicate 91.
propositional 57.
formula variables,
predicate 64.
propositional 39.
formulas,
predicate 63.
propositional 9.
free for x in A 77.
free in the formula 68.
free substitution operator 72.
full disjunctive normal form 27.
fundamental conjunction 28.
G
generalization, ﬁrst-order 86.
H
hypotheses, premises 32.
hypothetical syllogism 44.
I
induction 102.
inconsistent,
predicate, ﬁrst-order 91.
propositional 39.
interpretation metasymbol 10.
interpretation, for ﬁrst-order
structure 72.
inverter 29.
L
language levels 9.
logic circuits 29.
logical connectives 10.
logical ﬂow 29.
123

M
meta - 6.
model theory, propositional 35.
modus ponens 43.
model, ﬁrst-order 73.
N
names domain members, ﬁrst-order 94.
Natural event 98.
Natural system 97.
negation complete 91.
normally closed, switch 14.
normally open, switch 14.
not a model 73.
not satisﬁed 33.
O
observer language 6.
or-gate 29.
P
predicates 63,
1-place predicates 63.
2-place predicates 63.
3-place predicates 63.
n-place 63.
premises, hypotheses 32.
prenex normal form 82.
R
relative consistency 85.
S
satisﬁable,
propositional 33, 38, 57
predicate, ﬁrst-order 93.
satisfy = satisﬁable
scope, 64
of that quantiﬁer 67.
semantical modus ponens 24.
semantical 19.
semantics 15.
sentence 69.
set of all sentences 71.
simply consistent, propositional
39.
size of a formula 11, 64.
standard theory 100.
standard model 100.
stronger than for consequence
operators 55.
structure, ﬁrst-order 72.
subformula 24.
substitution process,
propositional 20.
T
theorem, formal,
predicate, ﬁrst-order 86.
propositional 42.
truth-table 15 - 17.
U
ultralogic 100.
ultraword 100.
unary connective 10.
unique equivalent form 27.
universal closure 76.
universal quantiﬁer 64.
universal, formula called 106.
V
valid consequence of Γ,
propositional 57.
valid consequence,
predicate, ﬁrst-order 82.
propositional 33, 57.
valid,
predicate, ﬁrst-order 82.
propositional 19.
valuation procedure, 16.
in general for propositional 57.
variable predicate forms 63, 77
variable substitution,
propositional 40.
variables, predicate 63 - 64.
W
wﬀs = well formed formula 9.
well-ordered 102.
124

