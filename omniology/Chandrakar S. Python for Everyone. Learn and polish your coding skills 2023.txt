

Python
for Everyone
Learn and polish your coding
skills in Python
Saurabh Chandrakar
Dr. Nilesh Bhaskarrao Bahadure
www.bpbonline.com

Copyright © 2023 BPB Online
All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or
transmitted in any form or by any means, without the prior written permission of the
publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the
information presented. However, the information contained in this book is sold without
warranty, either express or implied. Neither the author, nor BPB Online or its dealers and
distributors, will be held liable for any damages caused or alleged to have been caused
directly or indirectly by this book.
BPB Online has endeavored to provide trademark information about all of the companies
and products mentioned in this book by the appropriate use of capitals. However, BPB
Online cannot guarantee the accuracy of this information.
First published: 2023
Published by BPB Online
WeWork
119 Marylebone Road
London NW1 5PU
UK | UAE | INDIA | SINGAPORE
ISBN 978-93-5551-815-6
www.bpbonline.com

Dedicated to
Dedicated to my Parents
Dr Surendra Kumar Chandrakar and
Smt. Bhuneshwari Chandrakar
brother
Shri Pranav Chandrakar
to my wife
Priyanka Chandrakar
and to my lovely son
Yathartha Chandrakar
Saurabh Chandrakar
Dedicated to my Parents
Smt. Kamal B. Bahadure and Late Bhaskarrao M. Bahadure
to my in-laws
Smt. Saroj R. Lokhande and Shri. Ravikant A. Lokhande
and to
my wife Shilpa N. Bahadure and to beautiful daughters
Nishita and Mrunmayee
And to all my beloved students.
Dr. Nilesh Bhaskarrao Bahadure

About the Authors
Saurabh Chandrakar is a Research & Development Engineer (Dy.
Manager) at Bharat Heavy Electricals Limited (BHEL) Hyderabad. He
is the winner of the best executive award on Operations Division by
BHEL Hyderabad. Recently, he has been awarded the prestigious
BHEL Excellence Award under Anusandhan category for Redundant
Composite Monitoring System of Power Transformers project. He has
20 copyrights and 1 patent granted. Additionally, he has 6 patents filed.
Moreover, he has published 3 books in reputed publications such as
BPB New Delhi (Programming Techniques using Python), Scitech
Publications Chennai (Programming Techniques using matlab) and IK
International publishers (Microcontrollers and Embedded System
Design). He has also launched 1 video course on BPB titled “First Time
Play with Basic, Advanced Python concepts and complete guide for
different python certification exams all in one umbrella.”
 
Dr. Nilesh Bhaskarrao Bahadure received the Bachelor of
Engineering degree in Electronics Engineering in 2000, the Master of
Engineering degree in Digital Electronics in 2005, and the Ph.D. degree
in Electronics in 2017 from KIIT Deemed to be University,
Bhubaneswar, India. He is currently an Associate Professor in the
Department of Computer Science and Engineering at Symbiosis
Institute of Technology (SIT), Nagpur, Symbiosis International
(Deemed University) (SIU), Pune, Maharashtra, India. He has more
than 20 years of experience. Dr. Bahadure is a life member of IE(I),
IETE, 
ISTE, 
ISCA, 
SESI, 
ISRS, 
and 
IAENG 
professional
organizations. He has published more than 40 articles in reputed
international journals and conferences, and has 5 books to his credit. He
is the reviewer of many indexed journals such as IEEE Access, IET,
Springer, Elsevier, Wiley and so on. His research interests are in the
areas of Sensor Technology, the Internet of Things, and Biomedical
Image Processing

Acknowledgements
First and foremost, I would like to thank you all for selecting this book. It has
been written with the beginner reader in mind. First of all, I take this
opportunity to greet and thank my mentor"Prof. Nilesh Bahadure Sir" for
motivating me and always communicating his expertise fully on topics
related to Python. I am very thankful of being his protégé. I appreciate his
belief in mee, for always standing behind me, and pushing me to achieve
more. The phrase "Journey of Thousand Miles Begins with a Single Step" is
something he always reminds me of.
My parents, Dr. Surendra Kumar Chandrakar and Smt. Bhuneshwari
Chandrakar, my brother, Shri Pranav Chandrakar, my beloved wife, Mrs.
Priyanka Chandrakar, my adorable son, Yathartha Chandrakar, and all of my
friends have inspired me and given me confidence over the years. Last but
not least, I would like to express my sincere gratitude to the staff at "BPB
Publications Private Limited" for their contributions and insights that made
parts of this book possible.
— Saurabh Chandrakar
It was my privilege to thanks Dr. S. B. Mujumdar, Chancellor of the
Symbiosis International University, Pune and Shri. Vijay Kumar Gupta,
Chairman of Beekay Industries Bhilai and BIT Trust, for his encouragement
and support. I would like to thank my mentors Dr. Arun Kumar Ray, Dean,
School of Electronics Engineering, KIIT Deemed to be University,
Bhubaneswar and Dr. Anupam Shukla, Director, SVNIT Surat. I would like
to thank Dr. Vidya Yeravdekar, Principal Director of Symbiosis Society, and
the Pro Chancellor of Symbiosis International University, Pune, Dr. Rajani
R.Gupte, Vice Chancellor of the Symbiosis International University, Pune,
and Dr.Ketan Kotecha, Dean, Faculty of Engineering, Symbiosis
International University, Pune, and Dr. Mukesh M. Raguwanshi, Director,
SIT Nagpur, for their advice, and encouragement throughout the preparation
of the book.
I would also like to thank Dr. Sanjeev Khandal, HOD, Department of
Aeronautical Engineering, SGU Kolhapur, my well-wisher Dr. Prasenjeet D.

Patil, Associate Professor, MIT ADT University, Pune and my colleagues in
Symbiosis Institute of Technology Nagpur for providing valuable suggestions
and lots of encouragement throughout the project.
I am thankful to Prof. Dr. N. Raju, Sr. Assistant Professor, SASTRA
University, Thanjavur, Tamil Nadu, for his support, assistance during
writing, and for his valuable suggestions.
I would also like to thank Dr. Ravi M. Potdar, Sr. Associate Professor, BIT
Durg, and Dr. Md. Khwaja Mohiddin, Associate Professor, BIT Raipur for
providing valuable suggestions and lots of encouragement throughout the
project. Writing a beautiful, well balanced and acquainted book is not a work
of one or two days or a month; it takes a lot of time and patience, as well as
hours of hard work. Many thanks to my family members, my parents, wife,
children and my well-wishers for their kind support. Without them and their
faith and support, writing this classic book, would have remained just a
dream. I also like to thank my students, who have always been with me, for
relating problems and to finding solutions too. The perfection in any work
does not come in a day. It needs a lot of effort, time and hard work, and
sometimes, proper guidance.
It is my privilege to thank Prof. (Dr.) Ram Dhekekar, Professor, Department
of Electronics & Telecommunication Engineering, SSGMCE Shegaon and
Dr. C. G. Dethe, Director UGC Staff College Nagpur. Last but not the least, I
would like to offer an extra special thanks to the staff at “BPB Publications
Private Limited" for their insight and contribution in polishing this book.
Most significantly, I want to thank Lord Ganesha for all of the work I was
able to put into the book's preparation. I would not be as zealous as I am now
if it weren't for God's amazing creation of the universes.
For since the creation of the world God’s invisible qualities - his eternal
power and divine nature - have been clearly seen, being understood from
what has been made, so that men are without excuse."
— Dr. Nilesh Bhaskarrao Bahadure

Preface
The purpose of this book is to introduce readers with little to no programming
experience to Python and provide them with the foundational knowledge and
skills necessary to begin writing code in the language. By mastering Python,
readers will be able to apply this technology to solve real-world problems and
create useful applications.
The first part of the book covers core python concepts. Then we shall see
some advanced Python concepts along with some data science libraries like
numpy, matplotlib and pandas. Finally, in the later part of the book, we shall
see some powerful observations while writing python code.
This book covers a wide range of topics, from basic syntax and data types to
more advanced concepts along with a little touch of data science. Overall, the
book provides a solid foundation for beginners to start their journey for
getting trained in Python language.
This book is divided into 11 chapters. Each chapter's description is listed as
follows.
Chapter 1: Basic Python Introduction – will cover the basic elements of
writing a Python program where readers can gain an understanding of the
fundamental topics.
Chapter 2: Concept of Strings in Python – will cover strings in detail, as
well as different string methods, usage of command-line arguments, and
string access with some examples.
Chapter 3: Concept of Flow Control Statements in Python – will cover
the concept of conditional, iterative, and transfer statements, with loop
patterns such as star pattern, alphabet pattern, and number pattern, with
examples.
Chapter 4: Concept of Exception Handling in Python – will cover the
concept of multiple ways of using the try-except block, for preventing errors
during runtime. Users will be able to create their exceptions for handling the
errors. Moreover, the user will see different use cases and control flow of
Python exception hierarchy.

Chapter 5: Concept of Regular Expressions in Python – will cover the
declarative mechanism for the representation of a group of strings, according
to a particular pattern called regular expressions, which is quite difficult to
understand, and also perform its usage. Each regex expression is explained in
a very lucid manner with examples.
Chapter 6: Concept of Functions in Python – will cover function types,
and different types of function arguments such as positional arguments,
keyword arguments, default arguments, variable length arguments, and
kwargs. Moreover, concepts on local, global and non-local variable are well
explained with examples, along with Python closures.
Chapter 7: Concept of Data Structures in Python – will cover non-
primitive inbuilt data structures such as list, tuple, set and dictionary, which
are unique on their own. All the data structures definitions, methods, and
different types of comprehensions such as list comprehension, tuple
comprehension, set comprehension, and dictionary comprehension are well
discussed.
Chapter 8: Concept of Packages in Python – will cover the demonstration
of package examples, with different approaches to module usage.
Chapter 9: Numpy Introduction – will cover different examples of
scientific computing and data analysis library, that is, numpy library.
Chapter 10: Data Visualization Introduction – will cover Matplotlib data
visualization library by creating a line plot with examples.
Chapter 11: Pandas Introduction – will cover Pandas Series and Pandas
DataFrame with examples.

Code Bundle and Coloured Images
Please follow the link to download the
Code Bundle and the Coloured Images of the book:
https://rebrand.ly/33uiwxo
The code bundle for the book is also hosted on GitHub at
https://github.com/bpbpublications/Python-for-Everyone. In case there's
an update to the code, it will be updated on the existing GitHub repository.
We have code bundles from our rich catalogue of books and videos available
at https://github.com/bpbpublications. Check them out!
Errata
We take immense pride in our work at BPB Publications and follow best
practices to ensure the accuracy of our content to provide with an indulging
reading experience to our subscribers. Our readers are our mirrors, and we
use their inputs to reflect and improve upon human errors, if any, that may
have occurred during the publishing processes involved. To let us maintain
the quality and help us reach out to any readers who might be having
difficulties due to any unforeseen errors, please write to us at :
errata@bpbonline.com
Your support, suggestions and feedbacks are highly appreciated by the BPB
Publications’ Family.
Did you know that BPB offers eBook versions of every book
published, with PDF and ePub files available? You can upgrade to the
eBook version at www.bpbonline.com and as a print book customer,

you are entitled to a discount on the eBook copy. Get in touch with us
at: business@bpbonline.com for more details.
At www.bpbonline.com, you can also read a collection of free
technical articles, sign up for a range of free newsletters, and receive
exclusive discounts and offers on BPB books and eBooks.

Piracy
If you come across any illegal copies of our works in any form on the
internet, we would be grateful if you would provide us with the
location 
address 
or 
website 
name. 
Please 
contact 
us 
at
business@bpbonline.com with a link to the material.
If you are interested in becoming an author
If there is a topic that you have expertise in, and you are interested in
either 
writing 
or 
contributing 
to 
a 
book, 
please 
visit
www.bpbonline.com. We have worked with thousands of developers
and tech professionals, just like you, to help them share their insights
with the global tech community. You can make a general application,
apply for a specific hot topic that we are recruiting an author for, or
submit your own idea.
Reviews
Please leave a review. Once you have read and used this book, why not
leave a review on the site that you purchased it from? Potential readers
can then see and use your unbiased opinion to make purchase
decisions. We at BPB can understand what you think about our
products, and our authors can see your feedback on their book. Thank
you!
For more information about BPB, please visit www.bpbonline.com.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com


Table of Contents
1. Basic Python Introduction
Introduction
Structure
Objectives
Benefits of Python
Uses of Python
Limitations of Python
Keywords and reserved words
Identifiers
Line joining methods
Implicit line joining method
Using curly braces
Using square brackets
Using parenthesis
Explicit joining method
Example 1
Example 2
Print function
Different styles to use print function
Variables
Importance of mnemonic variable names in Python
Concept of immutability vs fundamental data types
Conclusion
Points to remember
Questions
2. Concept of Strings in Python
Introduction
Structure
Objectives
Reading dynamic input from the keyboard
raw_input()

input()
Using Try Except
Using eval function
Command Line arguments
Python sys.argv
Python getopt module
Exception getopt.GetoptError
Short form options
Long form options
Python argparse module
Python argparse Positional arguments
Python argparse positional arguments default values
Python argparse argument help
Python argparse Data Type
Python argparse optional arguments
Short names for optional arguments with argparse
Python argparse with optional and positional arguments
Python argparse with required
Python argparse dest action
Python argparse append action
Allowing or disallowing abbreviations
Strings
Python multiline strings
Python string access
Using index
Using slice operator
In forward direction
In backward direction
Conclusion
Points to remember
Questions
3. Concept of Flow Control Statements in Python
Introduction
Structure
Objectives
Flow of execution of the program

Selection statements/Conditional statements
if
if-else
if-elif-else
if-elif-else ladder
Iterative statements
for
while
Transfer statements
break
continue
pass
in keyword usage
Loop patterns
Star pattern
Printing stars in pyramid shape
Alphabet pattern
Number pattern
Conclusion
Points to remember
Questions
4. Concept of Exception Handling in Python
Introduction
Structure
Objectives
Errors
Syntax error
Runtime Error
Importance of exception handling
Python exception hierarchy
Customized exception handling
Control flow in try-except
Case-1 - No raising of exception
Case-2 - Exception raised at st3 and corresponding except block is
matched
Case-3 - Exception raised at st3 and corresponding except block is not

matched
Case-4 - Exception raised at st5
Case-5 - Exception raised at st6
Exception information printing to the console
Try with multiple except blocks
Single except block that can handle multiple exceptions
Default except block
Possible combinations of except block
finally except block
Control flow in try-except and finally
Case-1 - No exception is raised
Case-2 - Exception raised at st3 and corresponding except block
is matched
Case-3 - Exception raised at st3 and corresponding except block
is not matched
Case-4 - Exception raised at st5
Case-5 - Exception raised at st6 or st7
Nested try-except finally block
Control flow in Nested try-except finally block
Case-1 - If there is no exception
Case-2 - Exception raised at st3 and corresponding except block
is matched
Case-3 - Exception raised at st3 and corresponding except block
is not matched
Case-4 - Exception raised at st6 and inner except block is
matched
Case-5 - Exception raised at st6 and inner except block is not
matched but outer except block is matched
Case-6 - Exception raised at st6 and both inner and outer except
block is not matched
Case-7 - Exception raised at st7 and the corresponding except
block is matched
Case-8 - Exception raised at st7 and the corresponding except
block is not matched
Case-9 - Exception raised at st8 and the corresponding except
block is matched
Case-10 - Exception raised at st8 and the corresponding except

block is not matched
Case-11 - Exception raised at st9 and the corresponding except
block is matched
Case-12 - Exception raised at st9 and the corresponding except
block is not matched
Case-13 - Exception raised at st10
Case-14 - Exception raised at st11 or st12
Else block with try-except finally block
Conclusion
Points to remember
Questions
5. Concept of Regular Expressions in Python
Introduction
Structure
Objectives
compile()
finditer()
Character classes
Pre-defined character classes
Quantifiers
Functions of re module
match
fullmatch
search
findall
sub
subn
split
escape
Metacharacters
[] (Square brackets)
. (Period)
^ (Caret)
$ (Dollar)
* (Star)
+ (Plus)

? (Question Mark)
{} (Braces)
| (Alternation):
() (Group)
\ (Backslash)
r prefix
Conclusion
Points to remember
Questions
6. Concept of Functions in Python
Introduction
Structure
Objectives
Functions in Python
Function types
Built in functions
User defined functions
Function arguments
Positional arguments
Keyword arguments
Default arguments
Variable length arguments
Keyword variable length arguments (kwargs)
Nested function
Python closures
Function passing as a parameter
Local, global, and non-local variables
Local variables
Global variables
Non-local variables
Recursive function
Python Lambda functions
Nested lambda functions
Passing lambda functions to another function
Conclusion
Points of remember

Questions
7. Concept of Data Structures in Python
Introduction
Structure
Objectives
List data structure
Creating a list
Creating an empty list
Creating a list when elements are known
Creating a list with dynamic input
List creation using list() function
List creation using split() function
Lists versus immutability
Accessing elements of list
By using index
By using index and for loop
By using Index and while loop
By using list slicing
List comprehension
List comprehension with for loop
List comprehension with for loop and if statement
List comprehension with for loop and nested if statement
List comprehension with if else statement and for loop
Nested list comprehension with for loop
Tuple data structure
Tuple creation
An empty tuple creation
Single valued tuple creation
Multiple valued tuple creation
Using tuple() function
Accessing elements of tuple
By using index
By using index and for loop
By using index and while loop
By using tuple slicing
Tuple versus immutability

Tuple comprehension
List versus tuple comparison
Set data structure
Set creation
Set comprehension
Set comprehension with for loop
Set comprehension with for loop and if statement
Set comprehension with for loop and nested if statement
Set comprehension with if else statement and for loop
Dictionary data structure
Creation of an empty dictionary
By using dict() function
By using curly braces only
Creation of a dictionary
Accessing dictionary
Accessing dictionary
Deleting dictionary item
Dictionary comprehension
Dictionary comprehension with for loop
Dictionary comprehension with for loop and if statement
Dictionary comprehension with for loop and nested if statement
Dictionary comprehension with if else statement and for loop
Conclusion
Points of remember
Questions (Long/Short/MCQs)
8. Concept of Packages in Python
Introduction
Structure
Objectives
Packages
Structure for package of games
Using “import” in Packages
Accessing objects like variables, functions, classes, and lists
Using “from import” in Packages
Accessing objects like variables, functions, classes, and lists
Using “from import *” in Packages

Accessing games package using different approaches
Conclusion
Points to remember
Questions
9. Numpy Introduction
Introduction
Structure
Objectives
Similarities between list and numpy array
Differences between list and numpy array
Numpy arrays creation
1-D array creation using list
1-D array creation using tuple
2-D array creation using Nested lists
Array creation with a particular dtype
Object type array creation
1-D array creation with arange() function
Using linspace()
Using zeros()
Using ones()
Using full()
Using eye()
Using diag()
Using empty()
Comparison between zeros and empty
Conclusion
Points to remember
Questions
10. Data Visualization Introduction
Introduction
Structure
Objectives
Python data visualization tools
Line plot creation by passing 2 ndarrays
Adding title, xlabel and ylabel to the line plot

Advanced line plot
linestyle property
color property
default color
Peep in a shortcut way to set color, marker and linestyle
mlc form
clm form
If no color is mentioned, then default color is blue
alpha property
linewidth and markersize property
markerfacecolor property
Customizing the figure size
Plotting multiple lines in a same plot
Conclusion
Points of remember
Questions
11. Pandas Introduction
Introduction
Structure
Objectives
Pandas Series
Pandas Series constructor
Creating Pandas Series by passing a list
Creating Pandas Series by passing a dictionary
Creating Pandas Series by passing a numpy array
Accessing elements in Pandas Series
Pandas Series slicing
Pandas Series filtering
Usage of apply method to Pandas Series
Aggregating of Pandas Series
Pandas DataFrame
Pandas DataFrame constructor
Pandas DataFrame creation
Accessing data in Pandas DataFrame
Data modification in Pandas DataFrame
Data aggregation in Pandas DataFrame

Conclusion
Points to remember
Questions
Index

CHAPTER 1
Basic Python Introduction
Introduction
In the early 1990s, the Python programming language was created by Guido
Van Rossum. Its implementation began in December 1989, in the National
Research Institute, Netherlands. The Python language is even older than the
Java language. The name Python was coined from one of the most popular
British sketch comedy series “Monty Python’s Flying Circus”. The first
Python version 0.9.0 was released in February, 1991. The next Python
version 1.0 was released in January, 1994. Python version 2.0 was released in
the October 2000, and version 3.0 came in December 2008. The latest version
at the moment, is 3.11.2, which was released in February, 2023.
Structure
In this chapter, we will discuss the following topics:
Benefits of Python
Uses of Python
Limitations of Python
Keywords and reserved words
Identifiers
Line joining methods
Print function
Variables
Importance of mnemonic variable names in Python
Concept of Immutability vs Fundamental data types
Objectives

By the end of this chapter, the reader will learn about the Python language
and its benefits, limitations and applications. The rules regarding variables
and identifiers will be thoroughly explained with examples. It is important to
understand different case styles of the print() function, so that the reader
can create various Python applications while using it smartly in their code.
Finally, the immutability concept with respect to fundamental data types will
be elucidated to the reader with examples, for better understanding. Step by
step code explanation is also illustrated while explaining various concepts in
Python, within the chapter.
Benefits of Python
It is important to understand why we need to study Python, as it comprises of
various benefits:
Python is a freeware and an open-source beginner’s language for
newcomers. If anyone is a beginner, Python is the best language to start
with. For Java Commercial, the business organization is Oracle; for
C#.net, the business organization is Microsoft, but for Python, the
business organization is Python Software Foundation. It is a non- profit
organization that has IP rights for Python programming language. The
website is https://www.python.org. Moreover, the source code is open.
Based on our requirement, we can customize the Python requirement
itself. To work with Java applications, we are required to go for Jython,
and for C#.net, we need Iron Python. Similarly, to work with large data
(in Machine Learning, Deep Learning), we require Anaconda Python,
and to work with Ruby Applications, we require Ruby Python.
Python is very simple and easy to understand as it is a high-level
language. Its syntax is also very easy to comprehend. We do not need to
worry for low level activities such as memory management, providing
free space and so on. Internally, Python Virtual Machine (PVM) will
take care.
Python is platform independent. We can run this language on different
hardware platforms such as Linux, Mac, Windows, Raspberry Pi and so
on. You can write the program once and run anywhere: this is the
concept of platform independent nature. PVM is responsible for running
the Python code in different platforms. PVM is platform dependent,

whereas Python is platform independent.
In Python, code can be executed as soon as it is written. Thus, it runs on
an interpreter system. It is not required to compile explicitly.
A programmer can write a program in fewer lines than other
programming languages. Thus, it is a more efficient and concise way of
writing the code.
Python can be used as functional oriented, object oriented or procedure
oriented.
Python has tons of libraries which are used for various implementations
such as NumPy, SciPy, Pandas and so on.
Python is extensible. We can use legacy non Python code in our
application and fill up the performance gap with other language code.
Python is a portable language. The Python application can be migrated
from one platform to another very easily.
Python is embedded. We can use the Python script inside Java or
C#.Net application. The scope of the Python code is improved. Thus,
our application will become scalable.
It is dynamically typed. We do not need to declare type explicitly.
Based on our provided value, the type will be considered automatically,
thus giving more flexibility to the programmer. Refer to the following
code:
a=10
print(type(a))
a='Python'
print(type(a))
a=False
print(type(a))
Output:
<class 'int'>
<class 'str'>
<class 'bool'>
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap01_prog1_dynamictyped.py)
Python language has similarity to the English language and was designed for
readability. The command can be completed with a new line, unlike

semicolons or parenthesis, as opposed to other programming languages. To
define the scope of loop, classes and functions, Python relies heavily on
indentation such as whitespace, unlike other programming languages. which
use curly space for this purpose.
Uses of Python
The Python language is used for:
Back end web development.
To create Artificial Intelligence and scientific computing, Machine
Learning, Deep Learning, Internet of Things and so on.
Desktop Applications, 3D graphics, Graphical User Interface
Applications.
Data Analysis, Network applications such as Client Server, Chatting
and so on.
For connectivity to database systems; it can read, write, delete or update
the data as per need.
It can perform very complex mathematics and can handle big data.
A good Python developer writes effective code for backend components,
testing and debugging programs. A good developer creates applications that
can be integrated with the present ones. Python is used by different
companies such as Google, Facebook, Yahoo, NASA, DropBox, BitTorrent,
Netflix, YouTube and so on. In Python, most of the syntax has been
borrowed from C language and ABC language.
Limitations of Python
Apart from the benefits, Python also has the following limitations:
Python is not suitable for developing mobile applications. This is
because currently, it does not have library support to develop mobile
applications.
Python is not the best choice to develop end to end enterprise
applications such as banking, telecom applications and so on, as there is
no library support.

The performance is low because the execution is happening line by line.
Thus, JIT compiler is added to Python Virtual Machine, so that a group
of lines will be interpreted only once, and each time, the interpreted
code is used directly. The preceding flavor is called PyPy version
(Python for speed).
The popularity of Python in 2023 is record breaking. According to Stack-
Overflow, Python is the most questioned emerging language, and it is far
ahead of competitor languages such as JavaScript, C# and so on. GitHub
grants Python the top slot of being the most popular language.
To install python on the system, go to the website https://www.python.org.
Then go to the Download section to download and install the latest Python
version (3.11.2, as on today). We have installed Python version on Windows
operating system. Keep in mind that we will be doing all our programs in
Windows OS only.
It is better to learn Python version 3 instead of version 2 because as of today,
all the multinational companies who have been using Python 2, have
migrated to Python 3. Python 3.x is developed as a completely independent
language and is not an extension of 2.x version. The backward compatibility
of Python 3.x is not there for Python 2.x, as there is no guarantee that it will
support the same. Moreover, Python 2 may become obsolete in the near
future as the libraries will not be maintained. During the installation, an
important point to be noted is to tick the checkbox Add Python 3.7 to Path
(we have installed Python 3.7.3 version in our case). Otherwise, there are
chances of error once we try to install our own libraries. Install the setup and
you are good to go. Once Python is installed, type cmd and enter the word
Python. You will get a screen as shown in Figure 1.1. In this book, we will
learn about Python 3.x and not Python 2.x:

Figure 1.1: Python version
Once we have installed Python, we also get Integrated Development and
Learning Environment (IDLE) for Python. Here, we can do our coding. It
looks as shown in Figure 1.2:

Figure 1.2: Python 3.7.3 shell
To run the program, follow the given steps:
1. Go to File | New File.
2. Type print('Hello World') in the file and save it into a respective
folder.
3. Click Run | Run Module F5, as shown in Figure 1.3:
Figure 1.3: Python file saved as hello.py
The output Hello World will be printed in the IDLE screen, as shown in
Figure 1.4:

Figure 1.4: Output in Python 3.7.3. shell
You can also look for other IDEs such as PyCharm, Jupiter and so on.
However, we have used Visual Studio Code (VsCode), and integrated
gitbash into VSCode. VSCode is a source code editor for making programs
which are developed by Microsoft. It has support for debugging, syntax
highlighting, code refracting, Intelligent code completion and so on. Before
starting with the basics of Python, let us have a brief overview of how to use
command line in VSCode.
With the help of command line, we can use files/folders, quickly create or
remove them, as well as copy and move the files to/from the folder, among
others. Let us start by typing the following commands in the bash terminal of
VSCode, and thus visualize the output. The commands are typed in bold
letters.
pwd: The pwd command or the Print working directory will display the
current location of the working directory. From the terminal output
shown in Figure 1.5, we can see that the working directory is
E:/python_progs.
Figure 1.5: pwd command
ls: This command will display the list of files and folders in the
terminal. From the terminal output shown in Figure 1.6, we can see the
list of files and directories within the file system:

Figure 1.6: ls command
ls -l: It will display the list of files and folders in the terminal, using a
long listing format. From the terminal output shown in Figure 1.7, we
can see the list of files and directories within the file system, along with
the owner, permissions. Since the list of contents is so long, only a part
of it has been shown.
Figure 1.7: ls -l command
clear: This command will clear the screen terminal. From the terminal
output shown in Figure 1.8, we can see that the screen has been cleared:
Figure 1.8: clear command
cd: It will change the current working directory in the operating
systems. From the terminal output shown in Figure 1.9, we can see that

the directory has been changed to E://democreated:
Figure 1.9: cd command
mkdir: This command is used to create folders in the operating system.
From the terminal output shown in Figure 1.10, we can see that a new
folder namely command folder, has been created:
Figure 1.10: mkdir command
An important point to observe is that if we give space inbetween the folder
name, and the folder name is not present in double inverted commas, then
separate individual folders will be created. In Figure 1.11, we can see that 3
different folders are created from mkdir command practice 2:
Figure 1.11: mkdir without double inverted commas
Now, let us put double inverted comma between the folder name: mkdir
"command practice 2". From Figure 1.12, we can see that a new folder
command practice 2 is created:

Figure 1.12: mkdir with double inverted commas
Let us assume we need to move to a folder command practice 2. Type the
command cd "command practice 2 "/, as shown in Figure 1.13:
Figure 1.13: Moving to a folder
touch: This command is used to set the modification and access times
of files to the current time of day. If the file is not present, then it will
create the file with default permissions. In Figure 1.14, a text file
namely newfile.txt is created:
Figure 1.14: touch (text file)
We can even create a Python file. A new file namely demo.py is created, in
Figure 1.15:

Figure 1.15: touch (python file)
rm: This command is used to remove objects such as file, directories
and so on. In Figure 1.16, let us remove newfile.txt:
Figure 1.16: remove a text file
cd .. : This command is used to move one folder back. in Figure 1.17,
we can see that one folder has been moved back:
Figure 1.17: command to move one folder back
rm -rf: This command is used to remove folders completely. rf stands
for recursive force. In Figure 1.18, we can see that the folder command
practice 2 has been removed completely:
Figure 1.18: rm -rf command

mv: This command is used to rename a file with a new name or move a
file name into a new folder. In Figure 1.19, we can see that the file
name file1.py has been renamed to file.py from the current folder cd
commandfolder/:
Figure 1.19: mv command (rename)
In Figure 1.20, we can see that the file name file.py has been moved to the
current folder mvfolder.
Firstly, we have created a folder named mvfolder. Then, we have moved the
file into that folder using command mv file.py ./mvfolder/
On the current path, we typed ls to see the list of files and folders. We can
see that the file has moved into the mvfolder since only the folder name is
being displayed. We then change the directory into mvfolder. We typed ls to
see the list of files and folders.
Refer to Figure 1.20:

Figure 1.20: mv command (move file into folder)
Let us now assume that we again want to move the file one folder backwards.
In this case, we have to use filename with “..”, as shown in Figure 1.21.
After typing the command mv file.py .., the file file.py has moved to the
folder commandfolder as shown:
Figure 1.21: mv command (move file into one folder backward)
Let us now assume that we want to copy a file into the folder mvfolder. In
Figure 1.22, we can see that the command cp file.py has been copied into
the folder /mvfolder/. We can see that using ls command, the folder
mvfolder contains the file name file.py:

Figure 1.22: cp command
If you want to save the list of commands, type in the bash terminal of
VsCode into a text file, and then use the following command:
history > history_for_print.txt
Here, history is the command and history_for_print.txt is the text
filename as shown in Figure 1.23. The command and the file name is joined
by the ‘>’ symbol. We can see that the list of commands typed has been
saved in the text file name history_for_print.txt.
Figure 1.23: history command
Keywords and reserved words
In any language, whether it may be a general speaking language such as
English, or a programming language such as Python or C, there are some
reserved words to represent some meaning or functionality, and they are
called reserved words or keywords. There are tons of English reserved words,
each with some specific meaning. It is quite impossible to remember those

words. On the other hand, if we look at some programming languages like
Java, only 53 reserved words are present. However, in Python, there are only
35 reserved words.
Thus, if we understand these 35 keywords, we might become an expert on
this language. To know the total keywords in the Python language, type the
following command in VsCode:
import keyword
print(keyword.kwlist)
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap01_prog2_keywords.py)
Save this to a file named as python_keywords.py. All reserved words in
Python contain alphabet symbols. To run the above program, type the
command as:
python python_keywords.py.
You will get the list of keywords as shown:
['False', 'None', 'True',
'and', 'as', 'assert', 'async', 'await', 'break', 'class',
'continue', 'def', 'del', 'elif', 'else', 'except', 'finally',
'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',
'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try',
'while', 'with', 'yield']
We will discuss all the list of keywords as per requirement. However, the
important observation that you may get by looking into the keywords is as
follows:
All the 35 keywords contain only alphabets.
True, False and None are the only 3 keywords which are in Uppercase.
The remaining 32 keywords are in lower case.
An important point to note is that there is no switch or do-while
concepts in Python.
Since Python is dynamically typed, there is no reserved words such as
int, float, Boolean, complex data types and so on.
To check if any word is a keyword or not, type the following command:
print(keyword.iskeyword('yield'))
On running the preceding file, you will get a Boolean value as True,

indicating that the yield word is a keyword. You can continue to check with
other reserved words. The return type of iskeyword is either True or False.
Identifiers
Identifiers are nothing but the user defined names utilized in the programs, to
represent a variable, a function, a class or a module. Identifiers can contain a
letter, digit or underscore. The first letter of the identifier must be a letter or
underscore, and should not start with digit. An example of an identifier is as
follows:
var_1=67: Variable name is an example of an identifier.
_var = 4: The first letter of an identifier can be an underscore.
3sd = 7: Invalid. SyntaxError: invalid syntax.
Special characters are excluded from the identifier.
var@2 = 8: SyntaxError: cannot assign to operator.
The allowed characters in Python are alphabets (either upper or lower case),
digits (from 0 to 9) and the underscore symbol. As the Python language is
case sensitive, identifiers themselves are case sensitive. The variables, for
example, sum and SUM are different. If the identifier starts with underscore,
then it is private. Reserved words are not allowed in identifiers. There is no
length limit for identifiers, but care has to be taken that it is not too lengthy
and must be meaningful enough for even a new person to understand.
Line joining methods
Whenever we are trying to divide input into different physical line, there will
be an error. For example:
print("hello
When we try to write the rest of the words in the next line, the following error
will be displayed:
print("hello
^
SyntaxError: EOL while scanning string literal
This can be overcome by using implicit and explicit line joining method.

Implicit line joining method
In implicit line joining method, the expression is split into multiple lines
using parenthesis, curly lines or square brackets, as discussed.
Using curly braces
Refer to the expression:
days = {'Mon','Tue','Wed',
'Thu','Fri','Sat',
'Sun'}
print(days)
Output
{'Tue', 'Sat', 'Fri', 'Sun', 'Mon', 'Wed', 'Thu'}
Note: You may get different output every time here.
Using square brackets
Refer to the expression:
days = ['Mon','Tue','Wed',
'Thu','Fri','Sat',
'Sun']
print(days)
Output:
['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
Using parenthesis
Refer to the expression:
days = ('Mon','Tue','Wed',
'Thu','Fri','Sat',
'Sun')
print(days)
Output:
('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun')
The preceding examples can also be written with comments and blank lines,
as shown:

We can write comment after the line:
days = {'Mon','Tue','Wed', # Mon - Wed
'Thu','Fri','Sat', # Thu - Sat
'Sun'} # sun
print(days)
Output
{'Tue', 'Thu', 'Fri', 'Sat', 'Sun', 'Mon', 'Wed'}
Blank lines can be inserted:
days = { #Blank
'Mon','Tue','Wed', # Mon - Wed
'Thu','Fri','Sat', # Thu - Sat
'Sun'} # sun
print(days)
Output
{'Sun', 'Tue', 'Thu', 'Sat', 'Wed', 'Mon', 'Fri'}
Note: All the implicit joining method examples are covered in (Program
Name: Chap01_prog3_implicit_joining_method.py)
Explicit joining method
In the explicit line joining method, we are using backward slash to split the
input. The backward slash is used to join the logical lines together in such a
manner that they are declared in a single line. Refer to the following
examples.
Example 1
Refer to the following expression:
print("hello\
welcome beginners")
Output:
hello welcome beginners
Example 2
Instead of writing the logic in one line, we have used backslash and
continued the half logic in another line. This way of writing is very much
allowed, as shown:

x = 12
print(x>10 | \
x<9)
Output:
False
Note: All the explicit joining method examples are covered in (Program
Name: Chap01_prog4_explicit_joining_method.py)
Some points to be taken care in explicit joining method are as follows:
There should not be any comment after the backslash character.
a<10 and b>30 | \ #comment
SyntaxError: unexpected character after line continuation
character
A backslash can continue only with string literals. It cannot work with
other literals.
i=3 \
2
SyntaxError: invalid syntax
Print function
If we want to print something on the screen or to the console, then we will
use the print function. Suppose we want to print the basic statement “Hello
Python Beginners “. Then, use the print statement followed by parenthesis
‘(‘. Use either single quote or double quote inside the bracket. Then type
that statement what we want to print.
Type the following command as shown in VsCode:
print("Hello Python Beginners ")
print('Hello Python Beginners ')
Output:
Hello Python Beginners
Hello Python Beginners
It is important to note that the collection of characters inside single or double
quote is called String. We can use both single or double quotes inside Python.
In some programming languages, we cannot use single quotes to represent a
string. It is possible to use ‘single quotes’ inside “double quotes” or “double
quotes” inside ‘single quotes’, as shown:

print("Hello 'Students' World")
print('Hello "Students" World')
Output:
Hello 'Students' World
Hello "Students" World
In the first print statement print("Hello 'Students' World"), we are using
single quotes inside double quotes. In the next print statement, print('Hello
"Students" World'), we are using double quotes inside single quotes.
However, we cannot use single quotes inside single quotes or double quotes
inside double quotes, as SyntaxError: invalid syntax will come.
Suppose you want to print “I’m here”. Type the following command:
print("I'm here")
Output:
I'm here
Different styles to use print function
There are different styles in which to use the print function, and they are as
follows:
Suppose somebody asks to print a new line using print function. Then
use the following print command:
print()
The print function without any arguments will insert a new line as
shown:
print("I'm here")
print()
print('I am printing after a new line')
Output:
I'm here
I am printing after a new line
In Python, print is always going to be same as println form in Java.
We have already used the print function with string argument in the
previous example.
It is also possible to use escape characters in the print statement such as
\n, \t and so on, as shown:

print('Hello \n Python Beginners')
print('Hello \t Python Beginners')
Output:
Hello
Python Beginners
Hello Python Beginners
It is possible to use the ‘+’ operator inside the print function. ‘+’ means
concatenation, that is, joining 2 strings. Here, both the arguments must
be of string type only, as shown:
print('Hello ' + '! I hope you are enjoying print
function')
Output:
Hello ! I hope you are enjoying print function
Whenever any ‘*’ operator is used, one argument must be of the integer
type and the other argument must be of string type, as shown:
print('Hi '*2)
Output:
Hi Hi
It is called string repetition operator. Here, ‘Hi ’ is printed 2 times.
Sometimes the developer wants to have space in between the arguments
using print statement. The user can easily use concatenation operator
and achieve the result. However, the result can also be achieved without
the use of concatenation operator, as shown:
print('Hello','I am printing space without concatenation
operator')
Output:
Hello I am printing space without concatenation operator
From the output, we can see that there is space between ‘Hello’ and ‘I’.
The 2 arguments are separated by space in between. The default
separator between the arguments is called space.
The print function can have variable number of arguments, as shown:
x,y,z = 3,4,5
print('The values of x,y and z are', x,y,z)
Output:
The values of x,y and z are 3 4 5

Here, we took 3 variables x, y and z. Any number of variables can be
taken here. An important point to observe is that between the variables
output along with the first argument, there is a space as discussed
previously.
Suppose you do not require the space separator and want another
separator such as a comma or colon separator. In that case, use sep
attribute. sep stands for separator. An example is as follows:
x,y,z = 3,4,5
print('The ratio of x,y and z are ', x,y,z,sep = ':')
Output:
The ratio of x,y and z are :3:4:5
Here, we can see that the colon operator replaces space separator.
Moreover, there is a colon operator after the first argument also. Thus,
you can view the output yourself by removing the first argument.
The print function can be used with the end attribute. This is used if we
want the next data in the same line. If there are multiple print statements
and we want the ‘\n’ to be removed with space separator, then we can
use end attribute. The example is as follows:
print('Hello',end=' ')
print('Python',end=' ')
print('Beginners.',end=' ')
print('This',end=' ')
print('is',end=' ')
print('an',end=' ')
print('example',end=' ')
print('of',end=' ')
print('end',end=' ')
print('attribute.',end=' ')
Output:
Hello Python Beginners. This is an example of end
attribute.
Thus, the default attribute of sep attribute is space, and for end attribute,
it is new line character.
We can pass any type of object as an argument in the print statement. It
can pass string, list, tuple, dictionary and so on, as an argument to print
statement. The example is as follows:
li = [1,2,3,4] # list
t1 = (5,6,7,8) # tuple

s1 = {9,10,11,12} # set
#Method-1
print(li,t1,s1)
#Method-2
print(li,end = ' ')
print(t1,end = ' ')
print(s1)
Output:
[1, 2, 3, 4] (5, 6, 7, 8) {9, 10, 11, 12}
[1, 2, 3, 4] (5, 6, 7, 8) {9, 10, 11, 12}
We can use the print function with formatted string. We all have come
across %i, %d, %f and %s. %i and %d is of int type, %f is of float type and
%s is of str type. These types are used in formatted string. The formatted
string is used, followed by space and variable list. The syntax is as
shown:
print("formatted string" %(variable list))
r,s,t = 3,4,5
print('r value is %i'%r) # f1
print('r value is %i and s value is %i' %(r,s)) # f2
Output:
r value is 3
r value is 3 and s value is 4
From f1, in the place of %i, r value is considered. From f2, in the place
of %i at 2 different places, r and s values will be considered. An
important point to note is that the number of variables and the number
of positions must be the same. Otherwise, we will face error. Let us see
another example:
my_name = 'Python'
l1 = [3,4,5,6]
print("Hello %s . The list is as follows %s " %
(my_name,l1))
Output:
Hello Python . The list is as follows [3, 4, 5, 6]
We can use the print function with replacement operator, and we can
use it with curly braces open and close. Let us see an example for a
better understanding:
name = 'Ram'
salary = 100000
age = 22

print("Hello I am {0}. My age is {1} years old and salary
is {2}".format(name,age,salary)) # M-1
print("Hello I am {}. My age is {} years old and salary is
{}".format(name,age,salary)) # M-2
print("Hello I am {x}. My age is {y} years old and salary
is {z}".format(z = salary, x = name, y = age)) # M-3
print(f"Hello I am {name}. My age is {age} years old and
salary is {salary}") # M-4
Output:
Hello I am Ram. My age is 22 years old and salary is 100000
Hello I am Ram. My age is 22 years old and salary is 100000
Hello I am Ram. My age is 22 years old and salary is 100000
Hello I am Ram. My age is 22 years old and salary is 100000
This is one of the examples where you can differentiate how flexible
Python language is. You can reproduce the output in multiple ways. The
elements within a string are concatenated through positional formatting.
In M-1, we can see that the index is written under curly braces. The
values inside the format statement can be integers, characters, floating
points, strings or even variables. We can see that the format function
has string and integer type variable as parameters and are the values we
wish to put into the placeholders.
In M-2, we can see that index is not written into the curly braces. Even
index is not written inside the curly braces. By default, the index will be
considered as 0,1,2 and so on.
In M-3, order of the parameters is not important.
In M-4, F-string is used. F-string is a new string formatting mechanism
known as literal string interpolation which is introduced by PEP 498
(Python Enhancement Proposal 498). Here, the f character precedes the
string literal. To make string interpolation simpler, f-strings were
introduced. The string is prefixed with the letter “f”. The string itself
can be formatted in the same way as str.format(). F-strings are faster
than 2 most common string formatting mechanisms: %formatting and
str.format(). We cannot use backslash in format string directly but
can use it into a variable as a background as shown:
newline = ord('\n')
print(f"Hi: I am {newline}")
Output:
Hi: I am 10

The ord function will accept a string of length 1 as an argument and
return the unicode point representation of the passed argument.
Note: All the print function examples are covered in (Program Name:
Chap01_prog5_print.py)
Variables
There are a lot of containers in our home where we can store our stuff as per
the need. Compare the above analogy to the variable. A variable is nothing
but a name that is assigned by the programmer to the memory location. It is a
reference to some data stored at a specific memory location. There is no
command in Python for declaring a variable. Generally, the data is stored in a
computer’s memory location where each memory will be having some
unique address. Depending on the architecture of the processor, the address is
allocated. So, for a normal programmer, it is very difficult to get to know
what type of memory addressing is used by the processor. For this purpose,
the high-level programming languages have provided that the user can
choose any name of the variable of choice. The interpreter will choose a
particular memory location and assign that particular name to it. For example:
name_var1 = 32
print(name_var1)
Output:
32
If we want to store data 32 into one particular memory location, we can say
name_var1 = 32. The interpreter will choose a random particular memory
location by giving the name as name_var1 and store the data value 32 into it.
The data on a variable is determined by the data type of the variable. It is not
necessary to declare variables with any particular type and the type can be
changed once after set, as shown:
name_var1 = "Python"
print(name_var1)
Output:
Python
The variable name name_var1 was initially of integer type, but now, it is of
string type (as already explained, Python is a dynamically typed language).

The string variables can be declared either using single or double inverted
comma, which we have covered in the Hello World example.
There are some rules for Python variables which we need to take care:
A variable cannot start with a number, as shown:
1name_var1 = 3
Output:
SyntaxError: invalid syntax
A variable name must start with a letter or underscore character, as
shown:
name = 'Python'
_name = 'Python'
There cannot be any special characters in the variable name, as shown:
#@var1 = 3 # --- SyntaxError: invalid syntax
#var@1 = 3 # --- SyntaxError: can't assign to operator
Alpha-numeric characters and variable names are allowed in the
variable name. A variable name can have a number in between, as
shown:
var1er = 7
Python is case-sensitive and so are the variable names. The variable
Name and name both are different, as shown:
Name = 'Python'
name = 'Python'
It is a better practice to separate the words with an underscore in
python. This is called snake case writing, which is used mostly in
Python, as shown:
my_name = "Saurabh"
My_name = "Saurabh"
In snake case writing for the compound word or phrases, the elements
are separated by underscore and there are no spaces. Each element’s
initial letter is either in lowercase or uppercase type.
We can declare multiple variables in a single line, as shown:
my_name1, age = "Python", 38
print("My_name1 is: " + my_name1 + " and Age is: " +
str(age))
Output:

My_name1 is: Python and Age is: 38
Here, the variable my_name1 and age is assigned with values ‘Python’
and 38 in a single line.
In Python, the same value can be assigned to a multiple variable in a
single line, as shown:
r=s=t=1 #--- I1
print(r + s + t)
r=s=t='1' #--- I2
print(r + s + t)
Output:
3
111
From the above example, we can see that 3 variables (r, s and t) are
assigned with the numeric value 1 in I1. The output is simple addition,
that is, value 3. In I2, the same variables are assigned with the string
value ‘1’. Thus, output will be the concatenated value 111.
Note: All the variable examples are covered in (Program Name:
Chap01_prog6_variables.py)
Importance of mnemonic variable names in Python
We humans have a different interpretation just by viewing things. Just think
of the glass of water analogy. Some will say that the glass is half filled with
water. Others will say that half the glass is empty. Thus, it is very much
important to present a clear understanding of the variables to the user who is
a novice to the project. The variables must be defined in such a manner that it
should be self-explanatory. Any third person who was earlier not involved in
the project must be able to understand the logic with the help of variables.
The variable names must reflect the intent, regardless of the data stored in
them. Choosing the variable names wisely leads to “mnemonic variable
names”. The dictionary meaning of word mnemonic means “practice of
aiding the memory”. These mnemonic variable names are important as they
help us remember why we created the variable names in the first space. With
the help of mnemonic variables, programmers have the ability to parse and
understand the code.
Let us see three different examples generating the same output in the end.

Here is the first one:
# M-1
x1 = 12
y1 = 5
z1 = x1*y1
print(z1)
# M-2
eggs = 12
unit_price = 5
total_price = eggs*unit_price
print(total_price)
# M-3
a12345 = 12
b12345 = 5
c12345 = a12345*b12345
print(c12345)
Output:
60
60
60
M1 depicts meaning less variables x1, y1 and z1, whereas M3 depicts the
variables which are too long to read and understand. The variables defined
here are also meaningless. In M2, the programmer has chosen the variable
name to be so meaningful that the humans can understand the intent
regarding the data stored in each variable. The variable “eggs”,
“unit_price” and “total_price” are self-explanatory. The output of M1,
M2 and M3 are the same, but now we are able to differentiate the variable
names.
Let us see another example:
animals = ['monkey','donkey','hyena']
for name in animals:
print(name)
Output:
monkey
donkey
hyena
We can easily say that the name and animals are the user chosen words, for
and in are the reserved words, and print is a function on Python. The text
editors will be able to differentiate the reserved words and the variables

defined by the user. We will discuss about scope of the variables and CGI
Environment variables later.
Note: All the mnemonic variable examples are covered in (Program Name:
Chap01_prog7_mnemonic_variables.py)
Concept of immutability vs fundamental data types
It is important to note that the fundamental data types are immutable, that is,
once an object is created, we cannot perform any changes in that object. If we
are trying to change, then for those changes an object by default is created.
This non changeable behavior is nothing but immutability. Mutable means
changeable and immutable means non-changeable.
Assume that we have created one object and the value is, say, 1. We cannot
change the value. If any person is trying to change the value, say 2, then for
this change, a new object by default will be created. It is important to know
the concept of immutability in Python. Let us understand it diagrammatically.
Refer to the following steps:
1. Suppose z = 1. Everything in Python is an object only. So, z = 1 has a
memory representation as shown in Figure 1.24:
Figure 1.24: Figure depicting integer value 1 assigned to the variable ‘z’
2. Now, say z = 12. We are trying to change the content of z. Internally,
this 1 will be replaced with 12. But that is not at all true. Refer to Figure
1.25:

Figure 1.25: Figure depicting expected delusional internal change of value from 1
to 12 for variable ‘z’
Once we created an integer object, we are not allowed to change the
content. The value will always be final, that is, z = 1 only, as shown in
Figure 1.26. However, we are still trying to change the same.
Figure 1.26: Figure depicting old value retention of variable ‘z’
3. A new object will be created with value 12. Now onwards, z will be
pointing to the new object with value 12 and the object with value 1 will
be eligible for garbage collection. Refer to Figure 1.27:

Figure 1.27: Figure depicting value 1 to variable ‘z’ available for Garbage
Collector
We are not performing any change in the existing object. A new object by
default will be created and z will be pointing to that object. This non-
changeable is the immutability concept. Data types such as int, float, bool,
complex and string objects are immutable.
One might think that if Python keeps on creating new object, memory is
definitely going to be wasted, and performance is going to be down.
However, this is actually an advantage. The Garbage Collector (GC) will
keep the unused or old object, and it will be destroyed automatically by it.
The PVM will not create an object immediately once new object is required.
Python will first check if any object is available with the required content or
not. If any object is available, then that object will be reused. If unavailable,
then the new object will be created.
The major advantage is that performance will be improved and memory
utilization will be saved. Suppose there are 3 reference variables: a, b and c.
Say Python creates an integer object 5 for which a is the reference variable.
Now, b with the value 5 is required to be created. If any object is required to
be created, Python will check if the integer object with value 5 is there or not.
Python will see that an integer object 5 is already created. So, b will be
referring to the same object 5. Similar will be the case with c and many more
variables which will be pointing to the same object. Diagrammatically, it can
be seen in Figure 1.28:

Figure 1.28: Figure depicting multiple variables pointing to the same integer object.
Thus, we can see that multiple reference variables are pointing to the same
object. By using one reference variable, we are in a position to change the
value in the existing object. In this manner, the remaining reference variables
are affected. The immutability concept is required to prevent this. Once an
object is created, we are not allowed to change the content. If we are trying to
change the value, then a new object will be created and the old object will be
automatically destroyed by the GC. Let us see in practical:
a1 = 'python'
a2 = 'python'
a3 = 'python'
a4 = 'python'
#we have created 1 python object and 4 references
print(id(a1))
print(id(a2))
print(id(a3))
print(id(a4))
Output:
1692364449192
1692364449192
1692364449192
1692364449192
From the preceding example, we can see that there is 1 object having 4
references. Each reference is pointing to the same object. The number is the
address of the object ‘python’. This number may change based on OS to OS.
Several references are sharing the same object. If one reference is changing
the content, all the remaining references are not going to be affected. Say a1
is changing the value to ‘python2’. Then, a new object will be created,
pointed by reference a1 only. All the remaining references will be pointing to
the object ‘python’ only, as shown:
a1 = 'python2'
print(id(a1))

Output:
1970217800568
Now, we can see that the address of a1 is different from the previous address,
since it is pointing to a different object.
Thus, we will check if the references are pointing to the same object or not,
as shown:
print(a1 is a2)
print(a2 is a3)
print(a3 is a4)
Output:
False
True
True
The is operator will return True if the references are pointing to the same
object. Otherwise, it will return False.
Here, a1 and a2 both are pointing to different objects. Hence, False is
returned. On the other hand, a2, a3 and a4 are pointing to the same object.
Hence, True is returned in those cases.
Note: All the immutability concept examples are covered in (Program
Name: Chap01_prog8_immutability_concept.py)
Conclusion
In this chapter, we initially went over Python introduction followed by its
benefits, uses and limitations . We saw about 35 keywords, out of which 3 are
in upper case and the remaining 32 are in lower case. Then, we saw about
user-defined names for representing a variable, function, class or a module.
The necessity of implicit and explicit joining methods are well illustrated. We
also saw different styles to use print function. We then got a glimpse of rules
while creating Python variables. The need for mnemonic variable names are
well explained. Lastly, we also understood the concept of immutability with
reference to fundamental data types.
Points to remember
Focus on benefits, limitations and usage of the Python language.

Importance of Python language catering to market requirement for
various applications.
Focus on different commands for creating directories and files,
renaming and movement of Python file names as per need.
Remember the rules to create variables and identifiers while creating
various application programs on Python.
Immutability concept and fundamental data types are to be understood
thoroughly, as the same concept will be used especially while creating
various applications using Python data structures.
Questions
1. Write a short note on Python history.
2. Why is Python more beneficial for beginners than other programming
languages?
3. Explain various Python applications and their limitations.
4. What are the rules to remember while creating variables in a Python
programme?
5. Explain different case styles of print function with Python code.
6. Explain implicit and explicit joining method with Python code.
7. Explain the concept of immutability with an example.
8. What are identifiers ? Explain using Python code.
9. Explain the importance of mnemonic variable names with a Python
code.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 2
Concept of Strings in Python
Introduction
An essential part of any programming language is string. Strings are the
objects which contain sequence of character data. In other words, we can say
that a string is nothing but an array of characters. We will hardly find any
application where strings are not manipulated . One of the most important
concepts in string which we have already discussed in Chapter 1, Basic
Python Introduction, is that strings are immutable. Once created, we cannot
reassign anything to a string. In this chapter, we will learn about reading
dynamic input from the keyboard, command line arguments, string
properties, string methods, string formatting and triple quotes, with hands-on
solved examples and exercises for practice. String literals can be enclosed
within single or double quotes, as we all know by now. String literals can
span multiple lines of text if used inside “”” or ‘’’. Using standard [] syntax,
we can access the characters in a string. Zero based indexing is used in
Python. Python will raise an error if the index is out of bounds for the string.
Let us start from the basic input of the strings.
Structure
In this chapter, we will discuss the following topics:
Reading dynamic input from the keyboard
Command Line arguments
Strings
Python multiline strings
Python string access
Objectives

By the end of this chapter, the reader will know about the input function of
the string where dynamic input from the keyboard can be read in Python
version 3.x. The eval function usage with examples will be elaborated. Most
importantly, we will be looking into 3 approaches of reading Python
command line arguments viz sys.argv, getopt and argparse module.
Moreover, we will investigate the concept of Python multiline strings.
Finally, we will see how to access characters of string using indexing (both
positive and negative) and slice operator, along with examples.
Reading dynamic input from the keyboard
In Python2, there are two versions of input function available, in order to read
dynamic input from the keyboard: raw_input() and input(). Let us see
these input functions one by one.
raw_input()
In this function, the data from the keyboard is always allowed to read in the
form of string format. The input is always taken as string by raw_input
function. Let us see an example:
my_age = raw_input("How old am I ? :")
print(my_age)
If 31 is entered: Entered data is treated as string even without ‘’.
If ‘31’ is entered: Entered data is treated as string including ‘’.
Even if we enter the integer value 31 or the string value ‘31’ from keyboard,
the value will be stored in the my_age variable as string only. When we print
my_age variable with the expression print(my_age), the answer will be string
value ‘31’ or “’31’”. The preceding function is replaced with input()
function in Python version 3.x
input()
In Python v2.x, the input function will treat the received data as string, if it is
included in quotes ‘’” or ‘’ . Otherwise, the data will be treated as number, as
illustrated:
my_age = input("How old am I ? :")
print(my_age)

If 31 is entered: Entered data is treated as number.
If ‘31’ is entered: Entered data is treated as string.
If we enter integer value 31 from the keyboard, the value will be stored in the
my_age variable as integer. When we print my_age variable with the
expression print(my_age), the output is integer value 31.
On the other hand, if we enter string value ‘31’ from the keyboard, then the
value will be stored in the my_age variable as string. When we print my_age
variable with the expression print(my_age), the output is string value ‘31’.
However, in Python version 3.x, the raw_input() function is deprecated. The
raw_input function is replaced with a new input() function. Python will
throw NameError if we are trying to use raw_input function in Python
version 3.x:
my_age = raw_input("How old am I ? :")
print(my_age)
Output:
NameError: name 'raw_input' is not defined
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap02_prog1_rawinput_input.py)
In Python 3, the entered data is always treated as string with or without ‘’, as
shown:
my_age = input("How old am I ? :")
print(my_age)
print(type(my_age))
Output:
How old am I ? :31
31
<class 'str'>
How old am I ? :'31'
'31'
<class 'str'>
From the preceding example, we can see that even if we enter the data with or
without using ‘’from the keyboard, the type of the variable is string only. So,
the input function is used to read data directly in our required format. There is
no requirement to perform type casting. Thus, in Python 3, the behavior of
input function is the same as raw_input function of Python 2, that is, every

input value is treated as str type only. Let us see some more examples to
confirm the str type of input function:
name = input('Enter some value: ')
print(name)
print(type(name))
Output:
Enter some value: 3.0
3.0
<class 'str'>
Enter some value: False
False
<class 'str'>
Enter some value: 10 + 3j
10 + 3j
<class 'str'>
From the preceding 3 examples, even if we enter the float, Boolean or
complex values as input, the data type of the variable name is of string type
only.
We can convert the data entered from the keyboard into required data types
as per need. Now, we will see how to write a Python program which will take
2 numbers as input from the keyboard and print addition, subtraction,
multiplication, division and average.
num1 = input("Enter the first number: ")
num2 = input("Enter the second number: ")
add = int(num1) + int(num2)
subtract = int(num1) - int(num2)
mul = int(num1) * int(num2)
div = int(num1) / int(num2)
avg = (int(num1) + int(num2))/2.0
print(f"Sum of 2 numbers is {add}")
print(f"Subtraction of 2 numbers is {subtract}")
print(f"Multiplication of 2 numbers is {mul}")
print(f"Division of 2 numbers is {div}")
print(f"Average of 2 numbers is {avg}")
Output:
Enter the first number: 3
Enter the second number: 2
Sum of 2 numbers is 5
Subtraction of 2 numbers is 1
Multiplication of 2 numbers is 6
Division of 2 numbers is 1.5
Average of 2 numbers is 2.5

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap02_prog2_input_with_without_try_except.py)
In the preceding example, 2 numbers were asked by the user to input from the
keyboard. The entered data was treated as string, that is, ‘3’ and ‘2’. The
entered string data is converted into integer. Then, the addition, subtraction,
multiplication, division, and average are calculated as per the formula.
However, you might be wondering what will happen if we enter data which
does not look like a number. It can be anything, for example, say, 3a. Then,
Python will throw Value Error, as shown:
ValueError: invalid literal for int() with base 10: '3a'
We can catch the preceding error using try except block.
Using Try Except
Refer to the following code:
try:
num1 = input("Enter the first number: ")
num2 = input("Enter the second number: ")
add = int(num1) + int(num2)
subtract = int(num1) - int(num2)
mul = int(num1) * int(num2)
div = int(num1) / int(num2)
avg = (int(num1) + int(num2))/2.0
print(f"Sum of 2 numbers is {add}")
print(f"Subtraction of 2 numbers is {subtract}")
print(f"Multiplication of 2 numbers is {mul}")
print(f"Division of 2 numbers is {div}")
print(f"Average of 2 numbers is {avg}")
except ValueError:
print("Could not convert data to an integer.")
Output:
Enter the first number: 3a
Enter the second number: 2
Could not convert data to an integer.
Under the try block, we write a block of code to test errors. The except
block will let us handle the errors. We will learn the preceding concepts in
detail, and as such, there is no cause for worry. Just be aware that we can
catch the wrong data input by the user. It is also possible in Python to read
multiple data from the keyboard in a single line. We will deal with this when

we learn concepts such as list comprehension and many more. Python is
magic on its own. There are tons of libraries supporting this language. It
depends on us as to how we utilize it.
Using eval function
The eval function evaluates a specified expression. If the expression is a
valid Python statement, it will be executed. It lets a Python program run
Python code within itself. The string is passed and the Python expression
code is evaluated within the program. The syntax is:
eval(expression, globals, locals)
where,
expression: It is a string which is to be parsed and evaluated as Python
code.
globals: It is optional. A dictionary containing global parameters.
locals: It is also optional. A dictionary containing local parameters.
Let us see some examples for the clear picture.
Refer to the following code:
print(eval("'pyth' + 'on'")) # Exp1
print(eval(" 'python '*2 ")) # Exp2
print(eval('3+5*(6-3) -12')) # Exp3
print(eval('True == False')) # Exp4
print(eval('3**2')) # Exp5
print(eval('2*(2+1)-3')) # Exp6
print(eval('"python".upper()')) # Exp7
print(eval('"PYTHON".lower()')) # Exp8
x= 3
print(eval("x*(x+1)*(x+2)")) # Exp9
In Exp1, we are evaluating the expression 'pyth' + 'on'. We are joining 2
strings. Hence, output is python.
In Exp2, we are multiplicating the Python string 2 times. Hence, output is
python python.
In Exp3, we are evaluating the expression according to order precedence.
3 + 5*(6-3) -12 = 3 + 5 *3 -12
= 3 + 15 -12
Output:

= 6
In Exp4, we are comparing whether the Boolean value True is same as False
or not. Output is False.
In Exp5, the expression 3 **2 = 9.
In Exp6, we are evaluating the expression according to order precedence.
2*(2+1) -3 = 2*3 – 3
= 6 -3
Output:
= 3
In Exp7, we are returning the uppercase string from the given string ‘Python’.
Hence, output is PYTHON.
In Exp8, we are returning the lowercase string from the given string
‘PYTHON’. Hence, output is python.
In Exp9, we are evaluating the expression by substituting the value 3 in the
expression
x*(x+1)*(x+2) = 3*(3+1)*(3+2)
= 3*4* 5
Output:
= 60
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap02_prog3_eval_func.py)
Command Line arguments
A Python program can be executed from an idle environment. If we press on
the Run menu, the program will execute. However, if there is a requirement to
give the input before the start of the script, then we will use the command
line argument. Command line arguments are arguments which are passed at
the time of execution. Command line arguments are supported by almost all
programming languages. There is also a facility for command line options to
set some specific options for the program. The 3 most common options to
read Python command line arguments are discussed as follows.
Python sys.argv

The sys.argv is the list of command line arguments passed to the Python
program. It is a simple way to read command line arguments as String. argv
is not an Array but a list which represents all the items that come via
command input. The counting of the arguments starts at 0 and not by 1. The
following example depicts the usage of command line arguments:
import sys
prog_name = sys.argv[0]
args = sys.argv[1:]
count = len(args)
print(prog_name) # -- Cmd1
print(args) # -- Cmd2
print(count) # -- Cmd3
for x in sys.argv:
print(f"Argument:, {x}") # -- Cmd4
Output:
$ python cmdargs.py hello python
cmdargs.py
['hello', 'python']
2
Argument:, cmdargs.py
Argument:, hello
Argument:, python
Note: The preceding code is covered in (Program Name: cmdargs.py)
From the preceding example, we can see that the first line is import sys.
Within a Python program, the command line arguments are available in argv
present in sys module. The command line arguments are taken in the form of
a list by sys.argv.
sys.argv[0] is always the name of the program as it is invoked.
Sys.argv[1] is the first argument we pass to the program. Even if we type an
integer in the argument list, the arguments always come in the form of a
string. To access the actual command line argument, we are slicing the list.
In Cmd1, the name of the file is cmdargs.py.
In Cmd2, the arguments passed to the program is hello python. Hence,
output is ['hello', 'python'].
In Cmd3, the number of items in the arguments will be displayed. Hence,
output is 2.
In Cmd4, we are reading the argument from the command line one by one.

Hence, first output is the name of the file, followed by the arguments.
There are some important points to remember, when using command line
arguments.
Usually, the separator between the command line arguments is space. If
there is space itself in the command line argument, then it should be
enclosed within quotes only.
import sys
print(sys.argv[1])
Output:
$ python cmdargs.py hello python # -- OU1
hello
$ python cmdargs.py 'hello python'# -- OU2
hello python
$ python cmdargs.py "hello python"# -- OU3
hello python
$ python cmdargs.py 'hello' python# -- OU4
hello
In OU1, we are entering the command line argument without bracket,
that is, hello python only. Hence, output is hello.
In OU2, we are entering the command line argument in single quotes,
that is, 'hello python' only. Hence, output is hello python.
In OU3, we are entering the command line argument in double quotes,
that is, "hello python" only. Hence, output is hello python.
In OU4, we are entering the command line argument 'hello' only in
single quote. Hence, output is hello.
We can convert the command line arguments into corresponding type
by using type casting methods, as shown:
import sys
print(sys.argv[1] + sys.argv[2]) # -- TC1
print(int(sys.argv[1]) + int(sys.argv[2])) # -- TC2
Output:
$ python cmdargs.py 5 6
56
11
In the preceding example, we are passing the string value ‘5’ and ‘6’ as
command line arguments.

In TC1, the output is 56 as the concatenation of 2 different strings are
being performed.
In TC2, the string command line arguments ‘5’ and ‘6’ are being
converted into integer data type. Hence, 5 and 6 will add up to value 11.
Python can throw ValueError and IndexError if we are passing invalid
command line arguments and whenever index is out of range.
ValueError: Refer to the following:
$ python cmdargs.py 'hello' python
hellopython
Traceback (most recent call last):
File "cmdargs.py", line 21, in <module>
print(int(sys.argv[1]) + int(sys.argv[2]))
ValueError: invalid literal for int() with base 10:
'hello'
In the previous example, if we are passing ‘hello’ Python, then we
will get ValueError since it is an invalid literal for base10.
IndexError: Refer to the following:
import sys
print(sys.argv[10])
Output:
$ python cmdargs.py 5 6
Traceback (most recent call last):
File "cmdargs.py", line 25, in <module>
print(sys.argv[10])
IndexError: list index out of range
In the preceding example, we are passing only 2 command line
arguments. Hence, IndexError will be thrown by Python.
Python getopt module
Python getopt module helps us to parse command-line options and
arguments. It is a C-style parser for command line arguments. The getopt
function takes 3 arguments:
getopt.getopt(args, options, [long_options]): Here, args is the
sequence of arguments which is to be parsed, and which usually comes
from sys.argv[1:]. It ignores the program name.

options: This argument is a string of option letters that the script wants
to recognize. If any of the options requires an argument, its letter should
be followed by a colon (:).
[long_options]: This argument is an optional parameter and if used
purposefully, should be long-style option names sequence. The long
style option names in the sequence should not include --prefix and can
be more than a single character such as --noarg or --witharg. Long
options should be followed by an (=) equal sign which requires an
argument.
These methods return values consisting of 2 elements, where the first element
is a list of (option, value) pairs, and the second element that remains after the
option list was stripped, is a list of program arguments.
Each option-value pair returned has the option as its first element, to have
short options or long options. The short options is prefixed with a single
hyphen (-). The long options is prefixed with 2 hyphens. The order of
occurrence in the list is the same in which they were found.
Exception getopt.GetoptError
The preceding module also raises an exception when an unrecognized option
is found in the argument list, or when an option which requires an argument,
is given None.
The exception arguments is a string which is the cause of the error. The error
message and related option is given by msg and opt attributes.
The supported option in the getopt module includes:
-a
-b val
-bval
--noarg
--witharg=val
--witharg val
and many more.

Short form options
Let us now see some short form options:
import getopt
#short form options
print(getopt.getopt(['-a', '-dval', '-e', 'val'], 'ad:e:')) # --
SF1
print(getopt.getopt(['-aval', '-d', '-e', 'val'], 'a:de')) # --
SF2
print(getopt.getopt(['-aval', '-dval', '-e', 'val'], 'a:d:e')) #
-- SF3
Output:
$ python getopteg.py
([('-a', ''), ('-d', 'val'), ('-e', 'val')], [])
([('-a', 'val'), ('-d', ''), ('-e', '')], ['val'])
([('-a', 'val'), ('-d', 'val'), ('-e', '')], ['val'])
Note: The preceding code is covered in (Program Name: getopteg.py)
The preceding example is of short form options. The Python code is saved in
the file as getopeg.py.
In SF1, there are 2 options, -a and -d, with the -d option requiring an
argument. The value should be “ad:”. Hence, the output is a list of option-
value pairs and the positional arguments left after stripping the option list
([('-a', ''), ('-d', 'val'), ('-e', 'val')], []).
In SF2, there are 2 options, -a and -d with the -a option requiring an
argument. The value should be “a:de”. Hence, the final output is ([('-a',
'val'), ('-d', ''), ('-e', '')], ['val']).
In SF3, there are 2 options, -a and -d with both -a and -d option requiring an
argument. The value should be “a:d:e”. Hence, the output is ([('-a',
'val'), ('-d', 'val'), ('-e', '')], ['val']).
Long form options
Let us now see some short form options:
#long form options
print(getopt.getopt([ '--noarg','--witharg', '--
witharg2=another' ],
'',

[ 'noarg', 'witharg', 'witharg2=' ])) #-- LF1
print(getopt.getopt([ '--noarg', 'val','--witharg', 'val', '--
witharg2' ],
'',
[ 'noarg=', 'witharg=', 'witharg2' ])) #-- LF2
print(getopt.getopt([ '--noarg', 'val','--witharg', 'val', '--
witharg2=another' ],
'',
[ 'noarg=', 'witharg=', 'witharg2=' ])) #-- LF3
print(getopt.getopt([ '--noarg', 'val','--witharg', 'val', '--
witharg2','val' ],
'',
[ 'noarg=', 'witharg=', 'witharg2=' ])) #-- LF4
Output:
([('--noarg', ''), ('--witharg', ''), ('--witharg2',
'another')], [])
([('--noarg', 'val'), ('--witharg', 'val'), ('--witharg2',
'another')], [])
([('--noarg', 'val'), ('--witharg', 'val'), ('--witharg2',
'val')], [])
([('--noarg', 'val'), ('--witharg', 'val'), ('--witharg2', '')],
[])
In LF1, there are 2 options: --noarg and --witharg and the sequence should
be [ 'noarg', 'witharg' ]. Hence, output is ([('--noarg', ''), ('--
witharg', ''), ('--witharg2', 'another')], []).
In LF2, there are 2 options: --noarg and --witharg and the sequence should
be [ 'noarg=', 'witharg=' ]. Hence, output is ([('--noarg', 'val'),
('--witharg', 'val'), ('--witharg2', '')], []).
Similarly, in LF3, the output is ([('--noarg', 'val'), ('--witharg',
'val'), ('--witharg2', 'another')], []).
In LF4, the output is ([('--noarg', 'val'), ('--witharg', 'val'), ('-
-witharg2', 'val')], []).
Python argparse module
The most preferred way to parse command line arguments is Python
argparse. Using argparse module, we can parse the parameters which is
passed using the command line to the script. It is easy to write user friendly
command line interfaces, using argparse module. This module automatically
generates usage, and help messages and errors are issued when users give the

program invalid arguments. A new parameter is added with add_argument()
and a parser is created with ArgumentParser. With the help of the preceding
module, we can gracefully handle the presence and absence of parameters.
Refer to the following code:
import argparse
a_parser = argparse.ArgumentParser()
a_parser.parse_args()
Note: The preceding code is covered in (Program Name: argparseeg.py)
The preceding program is saved as argparseeg.py. We will first run the
program with no arguments “python argparseeg.py”. Here, the script
is silent.
The preceding program is now run as python argparseeg.py --help.
The output is:
python argparseeg.py --help
usage: argparseeg.py [-h]
optional arguments:
-h, --help  show this help message and exit
The - –help is the only option which we need to specify as required or
optional with argparse. A nice help message is being given, even
though we did not specify any help arguments in our Python script.
In the last case, an unknown option is used, which is unrecognized
arguments by argparse.
python argparseeg.py [-h]
usage: argparseeg.py [-h]
argparseeg.py: error: unrecognized arguments: [-h]
We can now recognize which arguments are defined in argparse, and which
arguments are optional.
Python argparse Positional arguments
Let us see positional argument in Python argparse:
# positional args
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('Staff_Number')
parser.add_argument('Name')
parser.add_argument('Engineering_Branch')

parser.add_argument('AIR')
parser.add_argument('Age')
args = parser.parse_args()
print(f'My name is {args.Name} and I am {args.Age} years old')
print(f'My Staff Number is {args.Staff_Number} and I had my BE
in {args.Engineering_Branch} branch')
print(f'My All India Rank is {args.AIR} ')
Output:
$ python argparseeg.py 123456 Ramesh ECE 11 31
My name is Ramesh and I am 31 years old
My Staff Number is 123456 and I had my BE in ECE branch
My All India Rank is 11
The preceding example works with positional arguments. We often need an
argument which is mandatorily passed to the script during execution. This
example expects 5 positional arguments namely Staff_Number, Name,
Engineering_Branch, AIR and Age. Using add_arguments, the command line
options will specify the program that is willing to accept. We will be passing
the preceding example with different positional arguments, as specified here.
The output will be displayed as shown in the preceding example.
Python argparse positional arguments default values
Sometimes we want default values of a variable or argument where the
positional argument value will be empty. This can be done by passing default
value for an argument, as shown:
# positional args with default values
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('Staff_Number', nargs='?',default=567382)
parser.add_argument('Name', nargs='?',default='Sohan')
parser.add_argument('Engineering_Branch',
nargs='?',default="EEE")
parser.add_argument('AIR', nargs='?',default=12)
parser.add_argument('Age', nargs='?',default=30)
args = parser.parse_args()
print(f'My name is {args.Name} and I am {args.Age} years old')
print(f'My Staff Number is {args.Staff_Number} and I had my BE
in {args.Engineering_Branch} branch')
print(f'My All India Rank is {args.AIR} ')
Output:

$ python argparseeg.py
My name is Sohan and I am 30 years old
My Staff Number is 567382 and I had my BE in EEE branch
My All India Rank is 12
In the preceding example, the absence of a parameter will be gracefully
managed as default values will be passed. Thus, here we are only running the
preceding program without passing any positional argument value. The nargs
keyword here, associates different number of command line arguments with a
single action. Hence, we will get the default value in output.
Python argparse argument help
Whenever we write a Python program, we know the arguments to pass and
the fate of each argument. However, the user often does not know anything
about our script. So it is very much important for the newbies to know what
arguments to pass, which order it should follow and finally, the importance of
each argument and their usage. This is another attribute of add_argument
function. Refer to the following:
#positional arguments with help
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('Staff_Number',help = "Enter the Staff
Number",default=567382)
parser.add_argument('Name',help = "Enter the
Name",default='Sohan')
parser.add_argument('Engineering_Branch',help = "Enter the Engg.
Branch",default="EEE")
parser.add_argument('AIR',help = "Enter the All India
Rank",default=12)
parser.add_argument('Age',help = "Enter the Age",default=30)
args = parser.parse_args()
print(f'My name is {args.Name} and I am {args.Age} years old')
print(f'My Staff Number is {args.Staff_Number} and I had my BE
in {args. Engineering_Branch} branch')
print(f'My All India Rank is {args.AIR} ')
Output:
$ python argparseeg.py -h
usage: argparseeg.py [-h] Staff_Number Name Engineering_Branch
AIR Age
positional arguments:
Staff_Number        Enter the Staff Number
Name                Enter the Name

Engineering_Branch  Enter the Engg. Branch
AIR                 Enter the All India Rank
Age                 Enter the Age
optional arguments:
-h, --help          show this help message and exit
The preceding program is run with -h for help. The user of the Python
program will need to see what should be passed and in which order.
Moreover, the importance of each positional argument will be known.
Python argparse Data Type
The positional argument is of string data type. Let us see a sample code
snippet:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('num', help="Enter number to multiply by
2.")
args = parser.parse_args()
print(args.num*2)
Output:
$ python argparseeg.py 3
33
In the preceding script, we are multiplying a number with 2. On running the
preceding program with string value ‘3’ as the input, the output will be 33.
This is because the string value ‘3’ is appended with itself as 3 will be treated
as string. So, it is important to intimate Python of the datatype using type
attribute. Refer to the following:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('num', help="Enter number to multiply by
2.", type = int)
args = parser.parse_args()
print(args.num*2)
Output:
$ python argparseeg.py 3
6
Now, argparse will treat this input as an integer. Hence, output will be 6.
Python argparse optional arguments

So far, we saw all the examples with positional arguments. Sometimes we
need an argument which is optional, to be passed to the script. There is no
error if it is not passed. The optional arguments starts with – or – –, while
positional arguments do not. We need to call the .add_argument() method to
call optional arguments and the new argument must start with -. Refer to the
following:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--title', help="Best title name here.")
args = parser.parse_args()
if args.title == 'optional':
print('Hey it is optional argument script')
The preceding example adds one argument having option as --title. We can
define optional parameters in any order with – before the optional parameter
name. If we do not pass any value to an optional argument, then the value as
None will be assigned for the Python program. For optional parameters, the
method for passing default values, data types and help messages, is the same
as that of positional parameters.
Let us first run without any argument. There will be no error, as shown:
$ python argparseeg.py
Now, let us run the program by passing the argument optional:
$ python argparseeg.py optional
usage: argparseeg.py [-h] [--title TITLE]
argparseeg.py: error: unrecognized arguments: optional
We will get unrecognized arguments as error.
Now, we will run the program with --title parameter:
$ python argparseeg.py --title optional
Hey it is optional argument script
Short names for optional arguments with argparse
We are now very much sure what value the user needs to pass optionally.
Often, the descriptive name of the optional parameters in our scripts grows
long. Thus, we can assign a short name to parameters as well. Let us see the
previous example snippet with a short name:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-t', '--title', help="Best title name

here")
args = parser.parse_args()
if args.title == 'optional':
print('Hey it is optional argument script')
An extra parameter is added in the add_argument function and it is finally
being done. Refer to the following:
$ python argparseeg.py -t optional
Hey it is optional argument script
$ python argparseeg.py -h
usage: argparseeg.py [-h] [-t TITLE]
optional arguments:
-h, --help            show this help message and exit
-t TITLE, --title TITLE
Best title name here
Just run the program with -t as short option with argument optional, and we
will get the desired output.
Python argparse with optional and positional
arguments
We can combine the use of optional and positional arguments in our Python
code. Let us see an example:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-t', '--title', help="Best title name
here")
parser.add_argument('name', help = 'The author name is: ')
args = parser.parse_args()
if args.title == 'optional':
print('Hey it is optional argument script')
if args.name == 'ABC':
print('Hey you have successfully identified the author')
On running the script, we have:
$ python argparseeg.py -t optional ABC
Hey it is optional argument script
Hey you have successfully identified the author
Python argparse with required
With the argument option, the argument is made a required one, as shown:

import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--number', required=True)
args = parser.parse_args()
print(f'The number is {args.number}')
The number option must be specified in the preceding example; otherwise it
will give error. Refer to the following:
$ python argparseeg.py --number 6
The number is 6
$ python argparseeg.py
usage: argparseeg.py [-h] --number NUMBER
argparseeg.py: error: the following arguments are required: --
number
Python argparse dest action
With the dest option of the add_argument() function, a name is given to the
argument. It is inferred from the option if not given. Refer to the following:
import argparse
import datetime
# dest gives a different name to a flag
parser = argparse.ArgumentParser()
parser.add_argument('-a', dest='animals', action='store_true',
help="shows animals")
args = parser.parse_args()
# we can refer to the flag
# by a new name
if args.animals:
animals = datetime.datetime.now()
print(f"Now: at zoo {animals}")
In the preceding example, the keyword action is assigned the value
store_true, which means that if the option is specified, then assign the value
“True” to args.animals. The preceding program gives the animal’s name to
the -a argument. Hence, on running the preceding example, the output will
be:
$ python argparseeg.py -a
Now: at zoo 2023-03-05 23:58:13.793971
Python argparse append action
To group repeated options, the append action is required, as shown:

import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-c', '--color', dest='colors',
action='append', help="Different colors")
args = parser.parse_args()
colors = args.colors
for name in colors:
print(f'The color is {name}!')
The preceding program depicts color names with c, or color options which
can be repeated multiple times. The output is:
$ python argparseeg.py -c red -c yellow --color green
The color is red!
The color is yellow!
The color is green!
Allowing or disallowing abbreviations
Consider the Python snippet:
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--number', action='store', type=int,
required=True)
parser.add_argument('--neg', action='store', type=int)
args = parser.parse_args()
print(args.number)
The preceding example will print out the value we specify for the --number
argument. We will be calling the preceding program multiple times, by
specifying a different abbreviation of the number argument at each run. Refer
to the following:
$ python argparseeg.py --number 32
32
$ python argparseeg.py --numbe 32
32
$ python argparseeg.py --numb 32
32
$ python argparseeg.py --num 32
32
$ python argparseeg.py --nu 32
32
In the preceding example, we can see that the optional parameters are being
shortened unless the abbreviation leads to incorrect interpretation. However,
if we will try to run the preceding program with --n 32, the argparse does

not know whether the value is being passed to --number or --neg argument.
Thus, error will be thrown with the message, as shown:
$ python argparseeg.py --n 32
usage: argparseeg.py [-h] --number NUMBER [--neg NEG]
argparseeg.py: error: ambiguous option: --n could match --
number, --neg
Now, if we want the users to force to specify the full name of the options,
then we can disable the feature with the allow_abbrev set to False during the
parser creation, as shown:
import argparse
parser = argparse.ArgumentParser(allow_abbrev=False)
parser.add_argument('--number', action='store', type=int,
required=True)
parser.add_argument('--neg', action='store', type=int)
args = parser.parse_args()
print(args.number)
Now, if we run as shown, then error will be created:
$ python argparseeg.py --nu 32
usage: argparseeg.py [-h] --number NUMBER [--neg NEG]
argparseeg.py: error: the following arguments are required: --
number
The abbreviations are no longer allowed. The preceding error message
depicts that the --number parameter has not been specified because the - -nu
abbreviation has not been recognized. This program can now run using:
$ python argparseeg.py --number 32
32
Strings
Now, we all know how string is being represented. One of the most popular
data types is represented by enclosing characters in quotes. Python treats
strings in single quotes or double quotes. Thus, the sequence of characters
enclosed with single or double quotes is called as string; for example,
‘Python’ or “Python”. Both are string objects. A single character within
single quotes is of character data type value in programming languages such
as C, C++ or Java. However, there is no character data type in Python. It is
treated as string only. A string to a variable is done with the name of a
variable followed by an equal sign and the string.
v1 = 'python'

v2 = "python"
print(type(v1))
print(type(v2))
Output:
<class 'str'>
<class 'str'>
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap02_prog4_strings.py)
From the preceding example, we can see that both the variables are of string
data type only. There is no concept of character data type in Python.
Python multiline strings
In Python, multiline string literals can be defined using triple single or double
line quotes. This is one of the simplest method to let a long string split in
different lines. Just enclose the long string in a pair of double quotes, one at
the start and the other at the end. Refer to the following Python snippet:
s1 = "I am a beginner in python \nI will study the concepts to
be familiar with this language.\nIt is a very user friendly
language"
print("The long string is: \n" + s1)  # -- L1
s2 = """The long string is:
I am a beginner in python
I will study the concepts to be familiar with this language.
It is a very user friendly language"""
print(s2)  # -- L2
Output:
The long string is:
I am a beginner in python
I will study the concepts to be familiar with this language.
It is a very user friendly language
The long string is:
I am a beginner in python
I will study the concepts to be familiar with this language.
It is a very user friendly language
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap02_prog5_multiline_strings.py)

In L1, we have used \n to include the string in next line for better readability.
The string is written inside double quotes. At the end, we have joined to
strings using ‘+’ operator and finally got the output as desired.
In L2, we have defined string inside triple quotes and got the desired result.
So, it totally depends on the user how efficiently we can display the string.
The line breaks are inserted at the same position as defined in the code.
We can also use single quotes inside single quotes and double quotes as
shown:
print('We are using \' single quote')
print("We are using ' single quote")
Output:
We are using ' single quote
We are using ' single quote
We can either use backslash with a single quote or use single quote inside
double quotes of a string, to get the output as required. Whenever we are
using backslash single quote (\’), the single quote is treated as symbol only.
We can also use double quotes inside single quotes and double quotes, as
shown:
print('We are using " double quote')
print("We are using \" double quote")
Output:
We are using " double quote
We are using " double quote
We can either use backslash with a double quote, or by using double quote
inside double quotes of a string literal. We will get the output as required.
Whenever we are using backslash double quote (\”), double quote is treated
as symbol only.
Now, we can use single and double quotes, both, in a string using either
single or double quotes, as shown:
print("This is \' single and \" double quotes ")
print('This is \' single and \" double quotes ')
Output:
This is ' single and " double quotes
This is ' single and " double quotes
Moreover, without using backslash with a single or double quote, we can

print them inside a string literal. Triple quotes are used for either single or
double quotes as a symbol inside string literal.
print('''This is ' single and " double quotes ''')
print("""This is ' single and " double quotes """)
Output:
This is ' single and " double quotes
This is ' single and " double quotes
So, to declare multiline string literals and to use single or double quotes as a
symbol only in our string literal, we can go for triple quotes symbol.
Python string access
Python use square brackets[] to access the elements of the string. The
characters of a string can be accessed using the following ways.
Using index
The index can be using positive or negative. Positive index is from left to
right and negative index is from right to left.
Consider a string variable ‘cricket’, as shown in Table 2.1:
Table 2.1: Positive and Negative indexing display for string value ‘cricket’
The character ‘c’ in cricket can be accessed using 0th index from left to right,
or negative 7th index from right to left. If we need to access the characters of
the string using index, the value should compulsorily be in the range between
0 to 6 or -1 to -7. If the index range is outside this range, we will get error as
IndexError out of range.
Refer to the following:
s1 = 'cricket'
print(s1[0])
print(s1[-7])

print(s1[6])
print(s1[-1])
Output:
c
c
t
t
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap02_prog6_string_access_using_index.py)
This is how you access the elements of a string by using index. As
mentioned, if the value is outside of the mentioned range, we have:
s2 = 'generate'
print(s2[8])
Output:
IndexError: string index out of range
Since the index is out of the range, Python will generate IndexError.
Using slice operator
We can access characters of a string by using slice operator also. The range
of characters is returned using slice syntax. The syntax of slice operator is:
s[startindex:endindex:step]
The start index and end index are specified and separated by a colon operator
to return a part of the index:
startindex: Starting integer from where we consider slicing
(substring).
endindex: Integer from where we terminate the slice (substring), and it
stops at endindex – 1.
step: This is the integer value determining the increment between each
index for slicing.
It is to be noted that if the startindex is not specified, then it will consider
from the beginning of the string. If endindex is not specified, then it will
consider up to end of the string. If the step is not specified, then by default,
the incremented value is 1. The step value can be positive or negative. If

positive, then it should be from left to right, that is, in forward direction. The
step value goes from the begin to end -1. If negative, it should be from right
to left, that is, in the backward direction. The step value goes from begin to
end + 1.
In forward direction
Some important points to note are:
The default value for startindex: 0
The default value for endindex: length of the string
The default value for step: 1
If the end value is 0, the result is always empty
In backward direction
Some important points to note are:
The default value for startindex: -1
The default value for endindex: -(length of the string + 1)
If the end value is -1, the result is always empty.
We can take both positive and negative values for begin and end index
in either forward or backward direction.
Let us see a Python snippet for slicing:
s1= 'Pulchitudrinous'
print(s1[0:6]) # -- SL1
print(s1[0:6:1]) # -- SL2
print(s1[:6]) # -- SL3
print(s1[1:6:2]) # -- SL4
print(s1[6:]) # -- SL5
print(s1[::]) # -- SL6
print(s1[:]) # -- SL7
print(s1[::-1]) # -- SL8
print(s1[::-2]) # -- SL9
print(s1[-1:-13:-2]) # -- SL10
print(s1[1:13:-2]) # -- SL11
print(s1[1:-8:1]) # -- SL12
# print(s1[1:5:0])  #  --- Value Error
print(s1[1:7:-1]) # -- SL13
print(s1[0:-4:-1]) # -- SL14

print(s1[:1:-1]) # -- SL15
Output:
Pulchi
Pulchi
Pulchi
uci
tudrinous
Pulchitudrinous
Pulchitudrinous
suonirdutihcluP
soidthlP
soidth
ulchit
suonirdutihcl
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap02_prog7_string_access_slice.py)
First, we will see the index for the word “Pulchitudrinous” in Table 2.2:
Table 2.2: Positive and negative index display for string value ‘pulchitudrinous’
In SL1, the begin index is 0 and the end index is 6. From 0 to 5, the default
increment is 1. Hence, output is Pulchi, the index of which is as shown in the
following Table 2.3:
Table 2.3: Output for positive indexing for start index as 0 and end index as 6.
In SL2, the startindex is 0 and the endindex is 6. From 0 to 5, there is a step
increment of 1. Hence, output is Pulchi.

In SL3, the begin index and step increment is not mentioned. Hence, the begin
index will be 0 and the characters will go from position 0 to position 5 with a
step increment of 1. Hence, output is Pulchi.
In SL4, the startindex is 1 and the endindex is 6. The characters will go
from position 1 to position 5 with a step increment of 2. Hence, output is uci,
the index of which is as shown in the following Table 2.4:
Table 2.4: Output for positive indexing for start index as 0 and end index as 6
In SL5, the startindex is 6 and the endindex will be till the end of the
string. Hence output is tudrinous, the index of which is as shown in the
following Table 2.5:
Table 2.5: Output for positive indexing for start index as 6 till end of the string with default
step size as 1
In SL6, there is no startindex, endindex and step increment mentioned.
Hence, the characters will start from position 0 till the end of the string, with
a default increment of 1. Hence output is Pulchitudrinous.
In SL7, the story is the same as SL6. So, the output is same.
In SL8, there is no startindex and endindex. But the step increment is 1
from the backward direction, and so, characters will start from index -1 to –
(length of the string + 1) . It is equivalent to s1[-1:-16:-1]. This will print
the string in reverse order. Hence, output is suonirdutihcluP, the index of
which is as shown in the following Table 2.6:
Table 2.6: Output display with reverse string value using negative indexing with step size
of 1.

In SL9, the expression s1[::-2] is equivalent to s1[-1:-16:-2]. Hence,
output is soidthlP, the index of which is as shown in the following Table 2.7:
Table 2.7: Output display with reverse string value using negative indexing with step size
of 1
In SL10, get the characters from position 12 to position 1 starting the count
from the backward direction with a step increment of 2. Hence, output is
soidth, the index of which is as shown in the following Table 2.8:
Table 2.8: Output display with reverse string value using negative indexing with step size
of 1.
In SL11, the startindex is 1 and the endindex is 13 with a step increment of
2 in the backward direction. We cannot get the characters from position 1 to
position 14 in the backward direction. Hence, output is empty.
In Sl12, get the characters from position 1 to position 9 in the forward
direction since step increment is positive (1).
1 to (-8-1) = 1 to -9
Refer to the following Table 2.9:
Table 2.9: Output display with positive indexing with start index as 1 and end index as 6
with step size of 1
Hence, output is ulchit.
In SL13, get the characters from position 1 to position 8 with a step increment
of 1 in the backward direction. Hence, output is empty.
In SL14, get the characters from position 0 to position 3 with a step increment

of 1 in the backward direction. Hence, output is empty.
In SL15, the expression s1[:1:-1] is equivalent to s1[-1:1:-1].
-1 to (1+1) = -1 to 2
Refer to the following Table 2.10:
Table 2.10: Output display with positive indexing with start index as 1 and end index as 6
with step size of 1
Hence, the final output is suonirdutihcl.
Conclusion
In this chapter, we learned first about the input function for reading dynamic
input from the keyboard. Then we came to know that whenever any input is
taken from the keyboard, it is always of string type. The Python expression
code is evaluated using eval function if the expression is a valid Python
statement. We saw 3 most common options to read Python command line
arguments with different ways of parsing the parameters using the command
line to the script or by setting some specific options for the program. We also
saw multiline string literals which can be defined using triple single or
double-line quotes. Finally, we saw positive or negative indexing for
accessing characters of a string in addition of using slice operator.
Points to remember
input() function will treat the received data as string.
For evaluating a specified expression which is a valid Python statement,
eval() function is used.
The list of command line arguments can be passed to a Python program
using sys.argv
There are chances of getting IndexError and ValueError when index is
out of range or when we are passing invalid command line arguments.
To parse command line short form or long form options and arguments,

we can use Python getopt module.
The most preferred way for parsing the parameters which is passed
using the command line to the script, is by using Python argparse
module. Here, a new parameter is added using add_argument() and a
parser can be created using ArgumentParser.
Using either triple single line or double line quotes, Python multiline
string literals can be defined.
The characters of a string can be accessed using either index or by using
slice operator.
Questions
1. In which Python version raw_input() and input() functions are used?
2. Explain the concept of eval function with a Python code.
3. Explain sys.argv command line argument with a Python code. Also,
elucidate the case scenarios of generating ValueError and IndexError
with example.
4. Explain the syntax of Python getopt module. Also, explain the short
form and long form options with an example.
5. Explain Python argparse module with context of positional arguments
with a Python snippet.
6. Explain Python argparse module with context of positional arguments
default values and help argument using a Python snippet.
7. Explain Python argparse module with context of optional and
positional arguments with a Python snippet.
8. Explain Python argparse module with dest and append action using a
Python snippet code.
9. How do you allow or disallow abbreviations using Python argparse
module?
10. Explain the concept of multiline string with an example.
11. Explain Python string accessing using index and slice operator with an
example.

Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 3
Concept of Flow Control Statements in
Python
Introduction
In day-to-day life, we first identify the alternatives and choose between them,
based on the values, beliefs, and preferences. The action of making very
important decisions is called decision-making. Sometimes, the decisions are
in favor of us and sometimes they are not. However, our journey of struggle
continues always and forever. We anticipate conditions during our journey
and make decisions. Then we decide which path to choose, in order to reach
to our target. The same analogy of situations arises in programming, where
we also need to make decisions, and based on the decision, we will execute
the block of code. The direction of flow of execution of the program is
decided by the decision-making statements in programming languages.
Structure
In this chapter, we will cover the following topics:
Flow of execution of the program
Selection statements/conditional statements
Iterative statements
Transfer increments
In keyword usage
Loop patterns
Objectives
By the end of this chapter, the reader will understand about conditional,
iterative and transfer statements, along with the application of ‘in’ keyword in

their Python code snippet. The reader will also understand the flow of control
while executing these statements in their code. Different patterns such as star,
alphabet or number will be displayed using loops and print statement.
Flow of execution of the program
The order in which the code statements are going to be executed at run time,
is decided by the flow control. In Python, the flow control statements are
divided into 3 types:
Selection statements/conditional statements
Iterative statements
Transfer statements
Selection statements/Conditional statements
The selection or conditional statements are if, if-else and if-elif-else.
if
One of the simplest decision-making statement is the if statement. If a
certain condition is met, then a statement or block of statements will be
executed. Otherwise, they will not be executed. The syntax of the preceding
statement is:
if test expression:
statement(s)
The test expression after program evaluation will be either True or False, that
is, Boolean values are accepted. If True, then a block of statements will be
executed, otherwise not. The non-zero values will be interpreted as True. 0
and None will be interpreted as False. The test expression can be used with a
bracket also. To identify a block, Python uses indentation. Let us see an
example:
if test expression:
statement1
statement2
If the test expression is True, then if block will consider only statement1 to
be inside its block. The flowchart of if statement is shown in Figure 3.1:


Figure 3.1: Flowchart of if statement
Let us clear the concept of if statement with the following example:
my_age = int(input("Enter your age: "))
if my_age == 32:
print("I am 32 years old")
print("Good Morning!")
Output:
Scene-1
Enter your age: 32
I am 32 years old
Good Morning!
Scene-2
Enter your age: 33
Good Morning
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.1.py)
In the preceding program, the user will be prompted to enter the age. my_age
== 32 is the test expression. The statement inside if will be executed if the
user enters the age as 32. If the user enters a different age from 32, then the
preceding test expression will be False and the statement of code inside if
statement will be skipped. The print("Good Morning") method falls outside
of the if statement (un-indented). So, it will be executed, regardless of the
test expression to be True or False.
The flow chart of the preceding code is shown in Figure 3.2:


Figure 3.2: Flowchart for if code
In Scene-1, the user has entered the age as 32. So, the print() statement
inside if test expression is executed, followed by the print statement outside
of the if() block.
In Scene-2, the user has entered different age than 32. So, the print()
statement outside of the if() block will be executed.
if-else
In the previous statement, we came to know that if a test expression is True,
then a block of statements is executed. If False, then it would not be
executed. But we can do something else if the test expression is False. When
the test expression is False, the else statement is used with if statement to
execute a block of code. The syntax of the preceding statement is as shown:
if test expression:
Body of if
else:
Body of else
When the test expression is True, body of if will be executed. If False, then
body of else will be executed. To separate the blocks, indentation is used.
The flow chart of if-else statement is shown in Figure 3.3:

Figure 3.3: Flowchart of if-else statement
Refer to the following program:
num = int(input("Enter a number: "))

if num%2 == 0:
print("Even number")
else:
print("Odd number")
Output:
Scene-1
Enter a number: 12
Even number
Scene-2
Enter a number: 13
Odd number
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.2.py)
In the preceding Python snippet code, the user will be prompted to enter the
number to check whether the entered number is even or odd.
In Scene-1, the entered number is 12. The test expression num%2 == 0 is
True, and hence, the body of if will be executed and output “Even number”
will be displayed.
In Scene-2, the entered number is 13. The test expression num%2 == 0 is
False, and hence, the body of else will be executed and output “Odd number”
will be displayed.
The flow chart of the preceding example is shown in Figure 3.4:

Figure 3.4: Flowchart of if-else code
if-elif-else
The word ‘elif’ stands for else if. There are cases where we are allowed to

check multiple expressions. The syntax of if-elif-else statement is:
if test expression:
Body of if
elif test expression
Body of elif
else:
Body of else
From the preceding syntax, we can see that if block will have only one else
block. If the test expression for if is True, then body of if is executed. If the
test expression for if is False, then it will check the test expression of next
elif block and so on. If the test expression of elif block is True, then body
of elif block will be executed. If all the test expressions are False, then body
of else will be executed. Among several if-elif-else block, only one
block will be executed. The flowchart of if-elif-else block is shown in
Figure 3.5:
Figure 3.5: Flowchart of if-elif-else statement

Refer to the following program:
num1 = 9
num2 = -12
num3 = 7
if num1 <num2 and num1 < num3:
print(f"1: The smallest number is {num1}")
elif num2 < num3:
print(f"2: The smallest number is {num2}")
else:
print(f"3: The smallest number is {num3}")
Output:
2: The smallest number is -12
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.3.py)
In the preceding example, we are comparing whether the first number (num1)
is less than num2 and num3. Since the test expression is False, the control goes
to elif block. The number 12 is less than 7. Hence, output is “2: The
smallest number is -12”. The flow chart of the preceding code is shown in
Figure 3.6:

Figure 3.6: Flowchart for if-elif-else code
if-elif-else ladder
A user is allowed to choose between multiple options. These test expressions
will be executed from top to down. The moment one of the if statement
becomes True, the block of statement associated with that if will be
executed. The final else block will be executed if none of the test
expressions are True.
Just observe the following example:
my_age = float(input("Enter the age: "))

if my_age > 0 and my_age < 1.5:
print("The age is of infant")
elif my_age >=1.5 and my_age <12:
print("The age is of children")
elif my_age >=12 and my_age <17:
print("The age is of Teenager")
elif my_age >=17 and my_age <30:
print("The age is of adult")
elif my_age >=30 and my_age <46:
print("Middle aged person")
else:
print("The age is of elder person")
Output:
Scene-1
Enter the age: 1.0
The age is of infant
Scene-2
Enter the age: 6.0
The age is of children
Scene-3
Enter the age: 13.0
The age is of Teenager
Scene-4
Enter the age: 20.0
The age is of adult
Scene-5
Enter the age: 35.0
Middle aged person
Scene-6
Enter the age: 47.0
The age is of elder person
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.4.py)
In the preceding example, the user is prompted to enter the age.
In Scene-1, user has entered the age as 1.0. So, test expression of if is True.
Hence, output “The age is of infant” is displayed.
In Scene-2, user has entered the age as 6.0. So, test expression of first elif is

True. Hence, output “The age is of children” is displayed.
In Scene-3, user has entered the age as 13.0. So, test expression of second
elif is True. Hence, output “The age is of Teenager” is displayed.
In Scene-4, user has entered the age as 20.0. So, test expression of third elif
is True. Hence, output “The age is of adult” is displayed.
In Scene-5, user has entered the age as 35.0. So, test expression of fourth
elif is True. Hence, output “Middle aged person” is displayed.
In Scene-6, user has entered the age as 47.0. So, test expression of else part
is True. Hence, output “The age is of elder person” is displayed.
The Flowchart of the preceding program is shown in Figure 3.7:

Figure 3.7: Flowchart for if-elif-else ladder code
The else part is always optional. It is not compulsory to write else statement
with an if statement. Moreover, there is no switch statement in Python.

Iterative statements
Sometimes a group of statements are executed multiple times or repeatedly.
We then require iterative statements. They are termed as loops. As long as the
condition is True, loop statements will allow us to execute a block of
statements. This loop word will be used many times during the course of
Python program. Without loops, we cannot even think of making a Python
code. There are only 2 loops in Python: for and while loop. There is no
concept of do-while loop in Python.
for
The For loop in Python iterates over a sequence of elements. The sequence
can be either string, list, tuple, set or range. To do some necessary action for
every element present in some sequence, the for loop is used. The syntax of
for loop is:
for val in sequence:
Body of for
Here, val is a variable which takes item value inside the sequence on each
iteration. Using indentation, the body of for loop is separated from the rest of
the code. Until the last item in the sequence is reached, loop is continued. The
flow chart of for loop is shown in Figure 3.8:

Figure 3.8: Flowchart of for loop

Let us see some solved examples of for loop:
for i in range(4):#0 to 3
print(f"I am: {i}")# F1
for i in range(1,5):#1 to 4
print(f"I am: {i}")# F2
Output:
I am: 0
I am: 1
I am: 2
I am: 3
I am: 1
I am: 2
I am: 3
I am: 4
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.5.py)
In F1, the range() method is used to iterate through a sequence of numbers.
range(4) means the numbers will be iterated from 0 to 3. So, first i = 0,
then print() function will be executed. So, “I am: 0” will be displayed. The
loop will continue for i = 1,2 and 3. Hence, the final output to be displayed is:
I am: 0
I am: 1
I am: 2
I am: 3
Similarly in F2, the range(1,5) will iterate from 1 to 4. Hence, final output is:
I am: 1
I am: 2
I am: 3
I am: 4
We shall see one more example to find the sum of first n natural numbers:
num = int(input("Enter the number: "))
total = 0
for i in range(1,num+1):
total += i
print(total)
Output:
Enter the number: 5
15

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.6.py)
In the preceding example, user is prompted to enter the number. The number
entered is 5. Initially total variable value is 0. The range() will iterate from 1
to 5. So, the loop will be iterating 5 times.
1st Iteration
i = 1
total += 1 => total = 0 + 1
total = 1
2nd Iteration
i = 2
total += 2 => total = 1 + 2
total = 3
3rd Iteration
i = 3
total += 3 => total = 3 + 3
total = 6
4th Iteration
i = 4
total += 4 => total = 6 + 4
total = 10
5th Iteration
i = 5
total += 5 => total = 10 + 5
total = 15
So, the sum of first 5 natural numbers is 15.
while
In while loop, a block of code is executed as long as the test expression is
True and the control will come out of the loop if the test expression is False.
At the beginning of the loop, the condition is checked every time. The body
of while loop is determined through indentation and the first un-indented line
marks the end. The syntax of while loop is as follows:
While test expression:
Body of while

Here, test expression is checked first. If found True, then the control enters
into the body of while loop. After one iteration, the control goes again to
evaluate test expression. This is a repetitive process until the test expression
is evaluated to False. The flow chart of while loop is shown in Figure 3.9:

Figure 3.9: Flowchart of while loop

Let us see some examples:
j = 1
while j<=5:
print("Welcome Python Beginners :)")
j += 1
Output:
Welcome Python Beginners :)
Welcome Python Beginners :)
Welcome Python Beginners :)
Welcome Python Beginners :)
Welcome Python Beginners :)
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.7.py)
In the preceding program, test expression will be True if our counter variable
j is less than equal to 5. The most important point to observe is that the value
of counter variable in the body of the while loop has to be incremented.
Here, j is incremented with the value of 1. If failed to do so, it will result in
an infinite loop. The code will be continuously running and has to be
forcefully stop. The result is finally displayed as the string “Welcome Python
Beginners :)” is displayed 5 times. We can see how the control goes during
each iteration.
1st Iteration
Test Expression: True
j = 1
print(" Welcome Python Beginners :) ")
j = 2
2nd Iteration
Test Expression: True
j = 2
print(" Welcome Python Beginners :) ")
j = 3
3rd Iteration
Test Expression: True
j = 3
print(" Welcome Python Beginners :) ")
j = 4
4th Iteration

Test Expression: True
j = 4
print(" Welcome Python Beginners :) ")
j = 5
5th Iteration
Test Expression: True
j = 5
print(" Welcome Python Beginners :) ")
j = 6
After the 5th iteration, test expression is evaluated False and the control goes
to the next statement after while loop, which here, is end of the code.
Note: If you know the number of iterations in advance, then go for ‘for’
loop. If the number of iterations are unknown in advance, then use ‘while’
loop.
Transfer statements
Sometimes, there is a requirement in the code where we need to change the
flow of a normal loop. The control goes to the next statement when the test
expression is False. Say, we want to terminate the current loop iteration or
even the whole loop without checking test expression. Then Python provides
statements break and continues to terminate the loop or skip the rest of the
code.
break
In break statement, the loop is terminated and the program control flows to
the statement immediately after the body of the loop. The preceding
statement can be used with nested loops also. If present, break will terminate
the innermost loop. The syntax of break statement is:
break
The flowchart of break statement is shown in Figure 3.10:


Figure 3.10: Flowchart of break statement
Let us see examples of break statement using for and while loop.
break statement using for loop
Refer to the following example:
for num in range(1,6):
#code inside for loop
if num == 4:
break
#code inside for loop
print(num)
#code outside for loop
print("break statement executed on num = 4»)
Output:
1
2
3
break statement executed on num = 4
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.8.py)
In the preceding Python code, for statement constructs the loop if the
variable num is less than 6. Within the for loop, there is an if statement
which evaluates the test expression that if the variable num is equivalent to
the integer 4, then the loop will break and the control goes out of the loop,
which displays the final print statement. Each iteration of the for loop is
executed until the loop breaks after executing the ‘break’ statement. The flow
of control is as follows:
1st Iteration
num = 1
num Expression: False
print(num)
2nd Iteration
num = 2
num Expression: False
print(num)
3rd Iteration
num = 3

num Expression: False
print(num)
4th Iteration
num = 4
num Expression: True
Control goes out of the body of for loop to the next immediate
statement
print("break statement executed on num=4")
break statement using while loop
Refer to the following example:
num = 0
while num <6:
#code inside while loop
if num == 3:
break
#code inside while loop
print(num)
num += 1
#code outside while loop
print("break statement is executed at num = 3»)
Output:
0
1
2
break statement is executed at num = 3
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.9.py)
In the preceding Python code, num variable is initialized to 0. The while loop
will be True as long as the variable num is less than integer value 6. Within
the while loop, there is an if statement which evaluates the test expression
that if the variable num is equivalent to the integer 3, then the loop will break
and the control goes out of the loop, which displays the final print statement.
The while loop is executed until the loop breaks after executing the break
statement. The flow of control is as follows:
1st Iteration
num = 0
num Expression: False
print(num)

num = 1
2nd Iteration
num = 1
num Expression: False
print(num)
num = 2
3rd Iteration
num = 2
num Expression: False
print(num)
num = 3
4th Iteration
num = 3
num Expression: True
Control goes out of the body of while loop to the next immediate
statement
print("break statement is executed at num=3")
continue
The continue statement gives the user a flexibility to skip the remaining part
of the code for the current iteration only. The loop will not terminate and
goes on with next iteration to complete the rest of the loop. Once the external
condition is triggered, the control goes to the next iteration till the rest of the
loop is completed. After the loop is completed, the control goes to next
statement after the loop. The syntax of continue statement is:
continue
The flowchart of continue statement is as shown in Figure 3.11:


Figure 3.11: Flowchart of continue statement
Let us see an example of continue statement, using for and while loop.
continue statement using for loop
Refer to the following example:
for num in range(1,6):
#code inside for loop
if num == 4:
continue
#code inside for loop
print(num)
#code outside for loop
print("continue statement executed on num = 4»)
Output:
1
2
3
5
continue statement executed on num = 4
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.10.py)
In the preceding example, the break statement is replaced with continue
statement. The rest of the block is not executed if the variable num value is
equivalent to integer 4. The integer values from 1 to 5 will be displayed,
except value 4, that will be followed by the print statement.
The flow of control is as follows:
1st Iteration
num = 1
num Expression: False
print(num)
2nd Iteration
num = 2
num Expression: False
print(num)
3rd Iteration
num = 3
num Expression: False

print(num)
4th Iteration
num = 4
num Expression: True
Control goes to the beginning of for loop for the next iteration
5th Iteration
num = 5
num Expression: False
print(num)
Control goes to the immediate statement after the loop
print("continue statement executed on num=4")
continue statement using while loop
Refer to the following example:
num = 0
while num <6:
#code inside while loop
num += 1
if num == 3:
continue
#code inside while loop
print(num)
#code outside while loop
print("continue statement is executed at num = 3»)
Output:
1
2
4
5
6
continue statement is executed at num = 3
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.11.py)
In the preceding example, when num variable value is equivalent to integer
value 3, the control goes to the starting of the loop for the next iteration. It is
important to note that the num value must be incremented by 1 first, before
checking the test expression of num. This is because if written after the
expression, the expression will be True as num is always an integer value 3
and the code will go to infinite loop. The control flow is as follows:

1st Iteration
num = 1
num Expression: False
print(num)
2nd Iteration
num = 2
num Expression: False
print(num)
3rd Iteration
num = 3
num Expression: True
control goes to starting of the loop for the next iteration
4th Iteration
num = 4
num Expression: False
print(num)
5th Iteration
num = 5
num Expression: False
print(num)
Control goes to the immediate statement after the loop
print("continue statement is executed at num=3")
pass
There is a pass statement used in Python programming. Pass is a null
statement used as a placeholder for future implementation of loops, functions
and so on. It is important to know that the comment statement is ignored by
the interpreter, whereas the pass statement is not ignored. When pass is
executed, Python will do nothing and this is a NO operation. Sometimes, the
loops or functions in a Python code are not implemented at the initial stage,
and are rather executed in the later stage. Thus, the pass statement will be
used to construct a body that does nothing.
Refer to the following program:
num1 = 32
if num1 > 32:
pass
Output:

Python will do nothing and there will be no output.
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.12.py)
in keyword usage
We have used the ‘in’ keyword in Python code quite often. This special
keyword serves 2 purpose in Python. We shall see using the following
examples:
It checks whether value is present in a sequence or not. The sequence
includes list, range, set and so on.
name = "Saurabh"
#I1
if 'z' in name:
print('z is present in the name')
else:
print('z is not present')
#I2
if 'a' in name:
print('a is present in the name')
else:
print('a is not present')
Output:
z is not present
a is present in the name
Note: The preceding code is covered in (Program Name:
Chap03_Example3.13.py)
In I1, we are checking the letter ‘z’ in the string variable name as
‘Saurabh’. Since the letter ‘z’ is not present in the string variable, the
output will be z is not present.
In I2, we are checking the letter ‘a’ in the string variable name as
‘Saurabh’. Since letter ‘a’ is present in the string variable at 2 different
index positions, the output will be a is present in the name.
It is used to iterate through a sequence in a for loop.
games = ['cricket','football','basketball']
for i in games:

print(i)
Output:
cricket
football
basketball
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.14.py)
Loop patterns
In C language, we have studied various pattern programming’s using simple
for loops. The same can be replicated using Python code also. We will be
using nested for loops to handle number of rows and columns. The print
statements will be manipulated to display different number patterns, alphabet
patterns or star patterns.
Star pattern
We will be viewing different star patterns in a simple manner. The basic
program will have 2 for loops. The outer for loop will be for number of
rows, and inner for loop will be for number of columns in the pattern. The
print function will be used for displaying the output and the input function
will be used to get the user input. The range function will be used for
iterating the loop between the starting number, and ends with integer number
which the user inputs. The iteration of inner loop depends on the values of the
outer loop. The new line is added after each row, that is, on each iteration of
the outer for loop, so that the pattern can be displayed as per the need. Let us
see an example.
Printing stars in pyramid shape
Refer to the following example:
my_num = int(input('Enter the number of rows: '))
for a in range(0,my_num):
for b in range(0,my_num-a-1):
print(end = " ")
for c in range(0,a+1):
print('*',end = " ")

print()
Output:
Enter the number of rows: 4
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.15.py)
Refer to the following Table 3.1:
Table 3.1: Table depicting star printing in pyramid shape
The user is first prompted to input the number of rows. Here, the user entered
the row number as 4. So, the first for loop is for rows from a = 0 to a=3, as
shown in Table 3.1. The next for loop, for b in range(0,my_num-a-1),
will print the spaces in each row. The print statement is ended with space
using end = “ “. In Table 3.1, the spaces are marked as (s) to identify the
number of spaces in each row. Last but not the least, the for loop will print
the stars, followed by space in each row. print() function is used to move
the cursor onto the next line. We shall see the display of stars in each
iteration of number of rows.
a=0
3 spaces and one star followed by a space in row = 0.
a=1
2 spaces and 2 stars each followed by a space in row = 1

a=2
1 space and 3 stars each followed by a space in row = 2
a=3
No space and 4 stars each followed by a space in row = 3
Alphabet pattern
The behavior of printing alphabet pattern will be the same as that of using
star pattern. So, without any further delay, let us see the example:
#Method-1
for a in range(0,6):
my_num = 65
for b in range(0,a+1):
my_alpha = chr(my_num)
print(my_alpha,end = " ")
my_num += 1
print()
#Method-2
from string import ascii_uppercase
for i in range(1, 7):
print(" ".join(ascii_uppercase[:i]))
Output:
A
A B
A B C
A B C D
A B C D E

A B C D E F
A
A B
A B C
A B C D
A B C D E
A B C D E F
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap03_Example3.16.py)
In Method-1, we are using an ASCII value of a letter. The ASCII value will
be converted to character, in order to print it on the screen. The number of
rows is 6. First, the ASCII value 65 will be converted to character ‘A’ using
chr function. Then the current ASCII value will be incremented by one, and
the control goes to the next row. Depending on each iteration, the ASCII
value will again start with initial value 65 and will be incremented on each
iteration. The corresponding characters will be displayed based on the ASCII
values. The execution of the program on each iteration is shown as follows.
a=0
my_num = 65
for b in range(0,1)
A
a=1
my_num = 65
for b in range(0,2)
A
A B
a=2
my_num = 65
for b in range(0,3)
A
A B
A B C
a=3
my_num = 65
for b in range(0,4)
A
A B
A B C
A B C D

a=4
my_num = 65
for b in range(0,5)
A
A B
A B C
A B C D
A B C D E
a=5
my_num = 65
for b in range(0,5)
A
A B
A B C
A B C D
A B C D E
A B C D E F
In Method-2, from string, we have imported the ascii_uppercase string.
ascii_uppercase is initialized with value ABCDEFGHIJKLMNOPQRSTUVWXYZ in
string module. A new substring is created and concatenated with empty space
using join method. The output will be same as Method-1.
Number pattern
The behavior of the number pattern is same as that of star pattern. We will be
using the same for loops and range function to display the numbers in some
pattern. Let us view an example:
num = int(input('Enter the number: '))
count = 1
for my_row in range(1,num + 1):
for my_col in range(1,my_row+1):
print(count,end = ' ')
count +=1
print()
Output:
Enter the number: 4
1
2 3
4 5 6
7 8 9 10
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:

Chap03_Example3.17.py)
In the preceding example, the user is prompted to enter the number. The user
has entered the integer value 4. Here, nested for loop is used, in which, the
outer for loop is for the display of rows, and the inner for loop is for the
display of columns. The count value is displayed and incremented by 1 on
each loop iteration. The program execution of the preceding code is shown as
follows.
Enter the number: 4
count = 1
1st iteration
my_row = 1
for my_col in range(1,2):
print(count,end = " ")
count +=1
print()
Output:
1
2nd iteration
my_row = 2
for my_col in range(1,3):
print(count,end = " ")
count +=1
print()
Output:
1
2 3
3rd iteration
my_row = 3
for my_col in range(1,4):
print(count,end = " ")
count +=1
print()
Output:
1
2 3
4 5 6
4th iteration
my_row = 4

for my_col in range(1,5):
print(count,end = " ")
count +=1
print()
Output:
1
2 3
4 5 6
7 8 9 10
Conclusion
In this chapter, we first saw the if statement followed by if-else statement
and finally if-elif-else conditional statements. Then we saw if-elif-
else ladder concept where there is provision for the user to choose between
multiple options. Finally, we saw for and while loop iterative statements for
executing group of statements multiple times. We also saw how to change the
flow of a normal loop using break and continue statements. We also saw the
use case of pass statement for constructing a body that does nothing. The
importance of ‘in’ keyword is well explained. Finally, at the end, we saw star,
alphabet and loop patterns display with well-illustrated code.
In the next chapter, we will discuss about exception handling in Python.
Points to remember
When a certain condition is met using if statement, then a block of
code can be executed.
When a certain condition is not met using if statement, then a certain
block of code can be executed on else statement.
Whenever there is a requirement to check multiple expressions, then we
can use if-elif-else statement.
We can use for loop if there is a requirement to iterate over a sequence
of elements.
We can use while loop if a block of code is executed with the test
expression check.
The loop can be terminated using break statement and the remaining
part of the code can be skipped for the current iteration using continue

statement.
pass statement can be used to construct a body which does nothing.
‘in’ keyword can be used for checking or iterating through a sequence
in a ‘for’ loop.
We can display number, star or alphabet patterns using loops and print
statement.
Questions
1. What are selective statements in Python? Explain with their definition,
syntax, flow chart with an example code.
2. Explain if-elif-else ladder concept with its syntax and a Python
snippet code.
3. Explain for and while iterative statements with its syntax and Python
snippet code.
4. Explain break and continue transfer statements with its syntax and
Python snippet code.
5. Explain the importance of in statement with a Python snippet code.
6. Explain star loop pattern with a Python snippet code.
7. Explain Alphabet pattern with a Python snippet code.
8. Explain number pattern with a Python snippet code.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 4
Concept of Exception Handling in
Python
Introduction
There are many times when the user intentionally or unintentionally enters a
wrong input and our program meets with an error. When the error occurs, an
exception is generated by Python that can be handled, thus avoiding the
program to crash. We will be covering this topic in a much-detailed manner
as the programmer must have the flexibility to use it in their own code.
Structure
In this chapter, we will cover the following topics:
Errors
Importance of exception handling
Python exception handling
Customized exception handling
Control flow in try-except
Exception information printing to the console
Try with multiple except blocks
Single except block that can handle multiple exceptions
Default except block
Possible combinations of except block
Objectives
By the end of this chapter, the reader will have an idea about syntax and
runtime errors. They will be able to gracefully terminate the code using try

and except block, and the importance of finally block will be known for
cleaning up the code. Single except block for handling multiple exceptions
will be learned about, along with the default except block. Different use cases
along with control flow of try-except, try-except finally block and
nested try-except and finally block will be illustrated to the reader with
examples. The importance of else block will be explained at the end.
Errors
There are generally 2 types of error in any programming language: Syntax
and Runtime.
Syntax error
Whenever we write invalid syntax in our Python code, the Python interpreter
will throw syntax error. The program will not run and it is the responsibility
of the programmer to correct the syntax errors. Only if the errors are
corrected, will the program execution start.
Let us see the following program:
if 1 == 1
print("One")
Output:
if 1 == 1
^
SyntaxError: invalid syntax
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.01.py)
In the preceding example, we are missing a simple ‘:’ operator.
Let us see one more example:
print "I am done"
Output:
print "I am done"
^
SyntaxError: Missing parentheses in call to 'print'. Did you
mean print("I am done")?

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.02.py)
There must be ‘()’ parenthesis in print statement. So, again Interpreter will
throw syntax error.
So, it is the responsibility of the programmer to correct these mistakes.
Runtime Error
Often, we write the code without any syntax mistakes. However, at runtime,
while executing the program, there might be chances of entering the wrong
input, memory problem or wrong programming logic. In such cases, runtime
errors or exceptions will occur. The best example that every programmer
know of is the ZeroDivisionError. Just observe the following code:
num1 = int(input("Enter the first number: "))
num2 = int(input("Enter the second number: "))
my_div = num1/num2
print("my_div1 is", my_div)
Output:
Enter the first number: 12
Enter the second number: 0
Traceback (most recent call last):
File "execption_handling.py", line 3, in <module>
my_div = num1/num2
ZeroDivisionError: division by zero
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.03.py)
In the preceding program, there is no syntax error. However, when the user is
prompted to enter the 2 numbers for division, then the second input was
purposefully entered as ‘0’, which was due to an end user input. Hence,
ZeroDivisionError will be thrown by Python Interpreter.
Let us observe the same example with different end user input this time:
Enter the first number: Three
Traceback (most recent call last):
File "execption_handling.py", line 1, in <module>
num1 = int(input("Enter the first number: "))
ValueError: invalid literal for int() with base 10: 'Three'

The user has entered the string ‘Three' which is a string and is invalid literal
for int() with base 10. Hence, ValueError will be thrown by Python
Interpreter.
Thus, if something goes wrong while executing the program at runtime, then
the program will be terminated by these runtime errors.
The concept of exception handling is applicable only for runtime errors and
not for syntax errors.
We must know now what an exception is.
Importance of exception handling
>Suppose we are watching TV and suddenly our stomach gets upset. In such
a scenario, we rush to the toilet and attend nature’s call. This unexpected and
unwanted event which disturbed the normal flow of watching TV is an
exception for us. In our terms, we will call this as ‘NaturesCall’ Exception.
Thus, an unwanted unexpected event which disturbs the normal flow of
program is called an exception. For example, 
ZeroDivisionError,
TypeError, ValueError, FileNotFoundError and so on. To prevent
disruptions, it is highly recommended to handle these exceptions. We need to
properly terminate the program if the exceptions are raised during the
execution of the program. This can be understood like this.
Suppose, we are making a Project Initiation Report and are required to submit
the same to our HOD by 2 p.m. in the afternoon. By 1:30 p.m., we are
modifying the report in our desktop by aligning the data, changing the font,
adding some required inputs and outputs and so on. Suddenly, the power is
gone and there is no power back up. In this scenario, our entire work goes
away in vain since this is an abnormal termination, as well as a non-graceful
one. So, to have a graceful termination, exception handling is required. No
resources should be missing.
Exception handling does not mean repairing. It means to have an alternative
backup for the current problem. Therefore, defining an alternative way to
continue the rest of the program normally, is exception handling. Just look at
the following 2 statements:
S1: You are feeling hungry. You want to eat rice and chapati to satisfy
your hunger.

S2: You am feeling hungry. You want to eat rice and chapati to satisfy
your hunger. If rice and chapati are not cooked, then you will try some
snacks. If snacks are also not available, then you will go for biscuits.
In S2, there are maximum chances of achieving success since there are
multiple ways to satisfy the hunger. However, in S1, if there is no rice and
chapati, then unfortunately, your hunger will not be unsatisfied. So, there has
to be an alternative way to continue rest of the program normally.
In Python, every exception is an object and the corresponding class is
available for every exception type. Python Virtual Machine (PVM) creates
a corresponding exception object whenever an exception occurs. This object
checks for handling code. If available, then it will be executed and rest of the
program code will be executed normally. If not available, then PVM will
terminate the program abnormally and rest of the program code will not be
executed. The corresponding exception information will be displayed to the
console. This abnormal termination can be handled explicitly using try-
except blocks.
Thus, in default exception handling, the program will be terminated
abnormally and will print exception information to the console.
Python exception hierarchy
We need to have a basic idea of Python’s exception hierarchy. We should
have clarity about various exception classes, of which it is a parent class or a
child class. In Python, every exception is an object. There are classes that
correspond to each exception type. Thus, all exception classes in Python are
child classes of BaseException. Every exception class extends BaseClass
directly or indirectly. So, for Python exception hierarchy, BaseException acts
as a root.
The hierarchy is shown in Figure 4.1:

Figure 4.1: Python Exception Hierarchy
From the preceding figure, we can see that ZeroDivisionError is a child of
Arithmetic Error. Arithmetic Error is a child of Exception, and Exception is a
child of BaseException. We will concentrate more on exception and its child
classes as a programmer.
Customized exception handling
It is highly recommended to handle exceptions, as we want graceful
termination of the program. We do not want to miss or block any resources.
We can handle exceptions using 2 keywords try and except. Observe the
following code:
print("St-1")
print(2/0)

print("St-2")
Output:
St-1
Traceback (most recent call last):
File "prog74_debugging.py", line 12, in <module>
print(2/0)
ZeroDivisionError: division by zero
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.04.py)
In the preceding code, we can see that the ZeroDivisionError occurred on
the statement print(2/0). This is one of the risky codes which causes
abnormal/non-graceful termination of the code. This code which raised an
exception must be inside ‘try’ block. While executing the preceding code,
there must be a handling code which must be inside ‘except’ block. If there
is a problem in the try block, then the corresponding except block will be
executed. Refer to the following code:
print("St-1")
try:
print(2/0)
except ZeroDivisionError:
print("Normal Execution")
print("St-2")
Output:
St-1
Normal Execution
St-2
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.05.py)
As we can see, the print(2/0) statement is a risky code which will raise
ZeroDivisionError. The handling code will be executed in such cases.
Hence, the handling code print("Normal Execution") will be executed and
the control goes out of except block and print(“St-2”) will be displayed to
the console. It is a normal/graceful termination which the programmer is
recommended to write in the code.
Thus, the code which may generate exception must be in try block and the

handled code should be in except block.
So, the entire summary of the custom exception is:
try:
risky code
except:
handling code
Control flow in try-except
Here, we must see how the control will be flowing when the exception is
raised or not-raised. Consider the following Python snippet:
try:
st1
st2
st3
st4
except:
st5
st6
Case-1 - No raising of exception
If there will be no exception, then all the statements excluding except block
will be executed. The except block will be executed only when there is
exception will be raised. So, control flow will be from st1 →> st2 →> st3
→> st4 →> st6. Thus, it is a normal/graceful termination.
Case-2 - Exception raised at st3 and corresponding
except block is matched
In the preceding case, the statements from st1 to st4 will be the main flow
and the statement st5 is the handled code flow or alternative flow. If there is
an exception in st3, then the control goes to the alternative flow. After
executing the statement, the control never comes to the main flow. Rest of the
code in the try block will not be executed. Inside try block, only the
execution of the risky code must be taken into consideration, and not normal
code, as there will be no guarantee for the execution of the entire code. Thus,
the length of the code in the try block must be as less as possible. Here, the
control flow will be from st1 →> st2 →> st5 →> st6. Therefore, it is a

normal/graceful termination.
Case-3 - Exception raised at st3 and corresponding
except block is not matched
Here, the exception will be raised in the try block but there will be no match
in the available except block. Since there is no match in the except block,
hence abnormal/non-graceful termination will be there. Therefore, the control
flow will be st1 →> st2 →> Abnormal termination.
Case-4 - Exception raised at st5
Exception can be raised in except block also. Any exception raised outside
try block is an abnormal termination. Hence, the previous case is an
abnormal termination.
Case-5 - Exception raised at st6
Any exception raised outside try block is an abnormal termination. Hence,
the previous case is an abnormal termination also.
Thus, we can conclude that if there are chances of getting an exception
anywhere within the try block, then rest of the try block will not be executed
even though the exception is handled. So, the length of the try block must be
as less as possible and only the risky code must be inside the try block. It is
no surprise to get an exception inside except block in addition to try block.
If the statement is not a part of the try block and the exception is raised, then
it is always an abnormal/ non-graceful termination.
Exception information printing to the console
We can print the exception information to the console based on our usage and
need. Just observe the following code:
try:
print("st1")
print(2/0)
print("st-3")
except Exception as e:
print(f"The type of exception is {type(e)}") # E1
print(f"The type of exception is {e.__class__}") # E2

print(f"The exception class name is {e.__class__.__name__}") #
E3
print(f"The exception description is {e}") # E4
Output:
st1
The type of exception is <class 'ZeroDivisionError'>
The type of exception is <class 'ZeroDivisionError'>
The exception class name is ZeroDivisionError
The exception description is division by zero
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.06.py)
In E1 and E2, we are trying to print the type of exception. ‘e’ is a reference
variable to the exception object.
In E3, the exception class name is displayed to the console. Here, ‘e’ is the
exception object pointing to the corresponding class object and name of that
class.
In E4, the exception description is getting printed to the console.
Try with multiple except blocks
Handling an exception always depends on the type of exception; it is always
unique. For every exception type, we have to take separate except block.
Thus, it is recommended to use the try block with multiple except blocks.
Consider the following example:
try:
num1= int(input(" Enter the first number: "))
num2= int(input(" Enter the second number: "))
total = num1 / num2
print("The division is ", total)
except ValueError:
print("It is a Value error")
except ZeroDivisionError:
print("It is a zero division error")
Output:
Case-1
Enter the first number: 32
Enter the second number: 2
The division is 16.0

Case-2
Enter the first number: 32
Enter the second number: 2a
It is a Value error
Case-3
Enter the first number: 32
Enter the second number: 0
It is a zero division error
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.07.py)
In the preceding example, we will see that the Python Virtual Machine
(PVM) will always move from top to bottom in the except block, until it
matches the except block. The order of except blocks is important if you are
writing code with multiple except blocks.
In Case-1, we prompted the user to enter 2 integer numbers as 32 and 2.
Hence, the output will be 16.
In Case-2, we prompted the user to enter the numbers 32 and 2a. Since, the
value ‘2a’ cannot be converted to integer, PVM will throw ValueError as
wrong input is fed by the user.
In Case-3, we prompted the user to enter the numbers 32 and 0. Since, we
cannot divide a number by 0, PVM will throw ZeroDivisionError, as wrong
input is fed by the user. An important point to observe is that PVM will first
give preference to ValueError except block and then to ZeroDivisionError
except block. Thus, based on the exception raised, the corresponding except
block is going to be executed. The order of the except blocks is important if
we are using try with multiple except blocks.
Single except block that can handle multiple exceptions
Up until now, we have seen the single try block which can handle multiple
except blocks. However, let us now see the single except block, that can
handle multiple exceptions. Each exception inside except block will be
separated by comma. Thus, parenthesis is mandatory for exceptions. The
group of exceptions is internally considered as tuple. If it is single except
block, then parenthesis is not mandatory.

try:
st1
st2
except (Exception1,Exception2,…):
In order to print the exception information, use the syntax:
try:
st1
st2
except (Exception1,Exception2,…) as msg1:
An important point to observe is that msg1 is taken outside of the parenthesis.
If handling code is same for multiple exceptions, instead of taking multiple
except blocks, we should go for single except block. We can give any name
instead of msg1. It totally depends on user perception to write the code. Let
us see an example:
try:
num1= int(input(" Enter the first number: "))
num2= int(input(" Enter the second number: "))
total = num1 / num2
print("The division is ", total)
except (ArithmeticError,ValueError) as msg1:
print(f"The type of exception is {type(msg1)}")
print(f"The exception class name is {msg1.__class__.__name__}")
print("The input is not valid")
Output:
Case-1
Enter the first number: 12
Enter the second number: 2a
The type of exception is <class 'ValueError'>
The exception class name is ValueError
The input is not valid
Case-2
Enter the first number: 12
Enter the second number: 0
The type of exception is <class 'ZeroDivisionError'>
The exception class name is ZeroDivisionError
The input is not valid
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.08.py)
In Case-1, we prompted the user to enter the numbers 12 and 2a. Since ‘2a’ is

an invalid integer number, the exception ValueError will be thrown by PVM.
So, the exception block will be responsible for printing the type of exception,
the exception class name, and the message information.
In Case-2, we prompted the user to enter the numbers 12 and 0. Since, we
cannot divide a number by 0, the exception ZeroDivisionError will be
thrown by PVM. So, the exception block will be again responsible to print
the type of exception, the exception class name, and the message information.
Default except block
We have discussed about multiple except blocks. But what if no except
blocks are matched. In such cases, default except block comes handy. It will
be executed if not even one except block is matched. The default except
block contains just printing exception information to the console. No specific
handling code will be there in the default except block. Default except block
must be the last except block; otherwise, we will get ‘Syntax Error’. The
syntax is shown as follows:
try:
st1
st2
except :
Any type of exception is handled by default except block. Just observer the
following snippet code:
try:
num1= int(input(" Enter the first number: "))
num2= int(input(" Enter the second number: "))
total = num1 / num2
print("The division is ", total)
except ValueError as msg1:
print("The input is not valid")
except:
print("Default except block")
Output:
Case-1
Enter the first number: 10
Enter the second number: 2a
The input is not valid
Case-2
Enter the first number: 3

Enter the second number: 0
Default except block
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.09.py)
In Case-1, the user is prompted to enter 2 numbers. The user entered 10 and
‘2a’. Since, 2a is not an integer, ValueError will be thrown by Python.
In Case-2, the user entered the numbers 10 and 0. Since, it is a
ZeroDivisionError and the except block corresponding to this exception is
not present, the default except block will handle the exception.
Possible combinations of except block
The valid syntaxes for the except block are as follows:
except ValueError:
except (ValueError):
except ValueError as msg1:
except (ValueError) as msg1:
except (ValueError,ZeroDivisionError):
except (ValueError,ZeroDivisionError) as msg1:
except:
The invalid syntaxes for the except block are as follows:
except (ValueError as msg1):
except ValueError,ZeroDivisionError:
except (ValueError,ZeroDivisionError as msg1):
For multiple exceptions, parenthesis is mandatory. For only one exception,
parenthesis is optional. If parenthesis is used, then ‘as’ must be outside of
parenthesis.
finally except block
Till now we have explained the ‘try’ and ‘except’ keywords. Now, we will go
for the ‘finally’ keyword. There are chances of a situation occurring where

once the connection is open for reading database or excel file, it is mandatory
to close the connection. If an error occurs during reading or writing of the
contents, then the connection will be wasted and will not be closed if the
closing connection is written inside try block. In such cases, it is
recommended to use the closing connection inside the finally block. The
closing connection is called the resource deallocation or clean up code. It is
recommended that it is never used inside try block, because there is no
guarantee that every statement inside try block will be executed always.
Moreover, we cannot write the cleanup code inside except block because
unless and until there is an exception, the except block will not be executed.
So, it must be always within the finally block, irrespective of whether the
exception is raised or not, and whether the exception is handled or not. The
finally block purpose is to maintain clean up code. So, the syntax of try-
except-finally block is:
try:
Code generating an exception or risky code
except:
handled/alternative code
finally:
clean up code (Resource deallocation code).
Observe the following possible cases with try-except-finally block:
try:
print("inside try")
num1= int(input(" Enter the first number: "))
num2= int(input(" Enter the second number: "))
total = num1 / num2
print("The division is ", total)
except ValueError:
print("inside except")
finally:
print("inside finally")
Output:
Case-1: If there is no exception
inside try
Enter the first number: 12
Enter the second number: 2
The division is 6.0
inside finally
Case-2: Exception is raised but handled
inside try

Enter the first number: 12
Enter the second number: 2a
inside except
inside finally
Case-3: Exception is raised but not handled
inside try
Enter the first number: 12
Enter the second number: 0
inside finally
Traceback (most recent call last):
File "prog74_debugging.py", line 54, in <module>
total = num1 / num2
ZeroDivisionError: division by zero
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.10.py)
In Case-1, it is a normal execution of the code. In Case-2, the exception is
raised but is handled by the except block. In Case-3, it is an abnormal
termination as the except block does not match the exception. But the
finally block is executed. Even in the case of an abnormal termination,
finally block is executed.
So, in all the 3 cases, we came to know that the finally block is executed.
However, there is one case when the finally block would not be executed.
PVM will exit explicitly by writing the statement os._exit(0). In this case,
PVM will be shut down and finally block would not be executed. Just
observe the following program:
import os
try:
print("inside try")
print("hello there")
os._exit(0)
except ValueError:
print("inside except»)
finally:
print("inside finally")
Output:
inside try
hello there
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:

Chap04_Example4.11.py)
In the previous case, os._exit(0) function is called. PVM will exit
explicitly. The finally block here would not be executed. We have imported
os module. To interact with the operating system, os module is used.
In os._exit(0), 0 means status code and is a normal termination. Non ‘0’
means abnormal termination. The effect will always be the same but this
status code will be used by Python for internal logging or reporting purpose.
We do not need to worry, being a programmer. We can use any value inside
the exit function. The effect will always be same and there will be no
difference in the result of the program. Just see the following code:
import os
try:
print("inside try")
print("hello there")
os._exit(100)
except ValueError:
print("inside except»)
finally:
print("inside finally")
Output:
inside try
hello there
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.12.py)
Control flow in try-except and finally
Now, we will see what different cases for the occurrence of exception inside
either try block or except block or finally block. Just observe the
following demo python snippet code:
try:
st1
st2
st3
st4
except xxx:
st5
finally:

st6
st7
Case-1 - No exception is raised
Since there is no exception, all the statements in the try block will be
executed followed by finally block and the remaining lines of code. The
except block would not be executed. The control flow is as follows:
st1 →> st2 →> st3 →> st4 →> st6 →> st7. Normal termination
Case-2 - Exception raised at st3 and corresponding
except block is matched
Since, an exception is raised at st3 and the corresponding except block is
matched, the control will move to except block, followed by finally block
and the remaining lines of code. It will be a normal termination.
st1 →> st2 →> st5 →> st6 →> st7. Normal termination.
Case-3 - Exception raised at st3 and corresponding
except block is not matched
Since an exception is raised at st3 and the corresponding except block is not
matched, the control will skip the except block and will execute the finally
block only. It will be an abnormal normal termination.
st1 →> st2 →> st6. Abnormal termination.
Case-4 - Exception raised at st5
If any statement is raising an exception which is not a part of try block, then
it is always an abnormal termination. But before abnormal termination,
finally block is going to be executed.
Case-5 - Exception raised at st6 or st7
Any exception raised outside try block is an abnormal termination. Hence,
the previous case is an abnormal termination also.

Nested try-except finally block
We can take try except and finally blocks inside either try or except or
finally blocks. Just observe the following demo Python snippet code:
try:
try:
st1
except:
st2
finally:
st3
except:
try:
st4
except:
st5
finally:
st6
finally:
try:
st7
except:
st8
finally:
st9
In the previous pattern, we have taken nested try except and finally block
inside each try, except and finally blocks. In general, normal risky code is
taken outside outer try block and too much risky code is taken outside inner
try block. If an exception is raised inside inner try block, then the inner
except block is responsible for handling it. If the inner except block is
unable to handle it, then it is the responsibility of the outer except block to
handle. Let us see the following example:
try:
print("inside try block")
try:
num1= int(input(" Enter the first number: "))
num2= int(input(" Enter the second number: "))
total = num1 / num2
print("The division is ", total)
except ValueError:
print("Inside ValueError")
finally:
print("Inside finally block")
except ZeroDivisionError:

print("Outside except block with ZeroDivision Error")
finally:
print("Outside finally block")
Output:
Case-1
inside try block
Enter the first number: 12
Enter the second number: 2
The division is 6.0
Inside finally block
Outside finally block
Case-2
inside try block
Enter the first number: 12
Enter the second number: 2a
Inside ValueError
Inside finally block
Outside finally block
Case-3
inside try block
Enter the first number: 12
Enter the second number: 0
Inside finally block
Outside except block with ZeroDivision Error
Outside finally block
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.13.py)
In Case-1, the user is prompted to enter 2 numbers: 12 and 2. Since the input
numbers are valid, the division is 6. 0 will be displayed, followed by
displaying the message of inner finally block and outer finally block.
In Case-2, the user has entered the numbers 12 and 2a. Since, 2a is an invalid
integer number, ValueError will be thrown by PVM, which will be handled
by the inside except block. So, the message of except block will be
displayed, followed by displaying the message of inner finally block and
outer finally block.
In Case-3, the user has entered the numbers 12 and 0. In this case, since it is
to be divided by 0, ZeroDivisionError will be thrown by PVM, which will
be handled by outside except block. So, first the inside finally block

message will be executed, followed by the message of outside except block
and outer finally block.
An important point to note is that once the control has not entered in the try
block, then the corresponding finally block will not be executed. On
entering the control in the try block, the finally block must be executed
compulsorily.
Control flow in Nested try-except finally block
Now, we shall see the control flow in the nested try-except-finally block.
Just observe the following demo Python snippet code:
try:
st1
st2
st3
try:
st4
st5
st6
except X:
st7
finally:
st8
st9
except Y:
st10
finally:
st11
st12
Case-1 - If there is no exception
If there is no exception, then the except block would not be getting executed.
The control flow is as follows:
st1 →> st2 →> st3 →> st4 →> st5 →> st6 →> st8 →> st9 →> st11 →>
st12. Normal termination
Case-2 - Exception raised at st3 and corresponding
except block is matched
In the previous case, exception is raised at st3, and the except block, which is

‘except Y’, will handle the block as it is matched. Hence, the control flow is
as follows:
st1 →> st2 →> st10 →> st11 →> st12. Normal termination
Case-3 - Exception raised at st3 and corresponding
except block is not matched
In the previous case, exception is raised at st3, and the except block which is
‘except Y’, is not matched. Only the outside finally block is executed.
Since except block is not matched, it is abnormal termination. Hence, the
control flow is as follows:
st1 →> st2 →> st11. Abnormal termination
Case-4 - Exception raised at st6 and inner except block
is matched
In the previous case, exception is raised at st6 and the inner except block,
that is, except X is matched. So, the inside except block will be executed.
Hence, the control flow is as follows:
st1 →> st2 →> st3 →> st4 →> st5 →> st7 →> st8 →> st9 →> st11 →>
st12. Normal termination
Case-5 - Exception raised at st6 and inner except block
is not matched but outer except block is matched
In the previous case, exception raised at st6 matches the outer except block.
It will be a Normal termination and inside finally block will be executed,
and then the control moves to outer except block. The control flow is as
follows:
st1 →> st2 →> st3 →> st4 →> st5 →> st8 →> st10 →> st11 →> st12.
Normal termination
Case-6 - Exception raised at st6 and both inner and
outer except block is not matched
Since both the except blocks are not matched, it will be an abnormal

termination. But both inner and outer finally blocks will be executed.
Hence, the control flow is as follows:
st1 →> st2 →> st3 →> st4 →> st5 →> st8 →> st11. Abnormal termination
Case-7 - Exception raised at st7 and the corresponding
except block is matched
Since, the exception is raised at st7 and the corresponding except block is
matched, that is, ‘except Y’, it is a normal termination. But the exception at
st7 can be raised only if there will be an exception either at st4 or st5 or st6.
The inner finally block is executed. Hence, the control flow is as follows:
st1 →> st2 →> st3 →> st4 (May or may not be) →> st5 (May or may not be)
→> st6 (May or may not be) →> st8 →> st10 →> st11 →> st12. Normal
termination
Case-8 - Exception raised at st7 and the corresponding
except block is not matched
Since, the exception is raised at st7 and the corresponding except block is not
matched, that is, ‘except Y’, it is an abnormal termination. But the exception
at st7 can be raised only if there will be an exception either at st4 or st5 or
st6. The inner finally block is executed. Hence, the control flow is as
follows:
st1 →> st2 →> st3 →> st4 (May or may not be) →> st5 (May or may not be)
→> st6 (May or may not be) →> st8 →> st11. Abnormal termination
Case-9 - Exception raised at st8 and the corresponding
except block is matched
In the previous case, the exception may or may not happen at st4, st5 and st6.
If exception is not raised, then the control can go to st8 from where the outer
except block is matched, that is ‘except Y’. It is a normal termination since
the outer except block is matched. If exception is raised, then the control
goes to st7. So, the control flow is as follows:
st1 →> st2 →> st3 →> st4 (May or may not be) →> st5 (May or may not be)
→> st6 (May or may not be) →> st7(May or may not be) →> st10 →> st11

→> st12. Normal termination.
Case-10 - Exception raised at st8 and the corresponding
except block is not matched
In the previous case, the exception may or may not happen at st4, st5 and st6.
If exception is not raised, then the control can go to st8 from where the outer
except block is matched, that is, ‘except Y’. It is an abnormal termination
since the outer except block is not matched. If exception is raised, then the
control goes to st7. So, the control flow is as follows:
st1 →> st2 →> st3 →> st4 (May or may not be) →> st5 (May or may not be)
→> st6 (May or may not be) →> st7(May or may not be) →> st11.
Abnormal termination.
Case-11 - Exception raised at st9 and the corresponding
except block is matched
In the previous case, exception is raised at st9 and the outer except block is
matched, that is, ‘except Y’, so it is a normal termination. The exception may
or may not happen at st4, st5 and st6. If raised, then inner except block will
be executed and the control goes to st8. So, the control flow is as follows:
st1 →> st2 →> st3 →> st4 (May or may not be) →> st5 (May or may not be)
→> st6 (May or may not be) →> st7(May or may not be) →> st8 →> st10
→> st11 →> st12. Normal termination.
Case-12 - Exception raised at st9 and the corresponding
except block is not matched
In the previous case, exception is raised at st9 and the outer except block is
not matched, that is, ‘except Y’, so it is an abnormal termination. The
exception may or may not happen at st4, st5 and st6. If raised, then inner
except block will be executed and the control goes to st8. So, the control
flow is as follows:
st1 →> st2 →> st3 →> st4 (May or may not be) →> st5 (May or may not be)
→> st6 (May or may not be) →> st7(May or may not be) →> st8 →> st11.
Abnormal termination.

Case-13 - Exception raised at st10
Exception raised at st10 is an abnormal termination but before abnormal
termination, the outer finally block (st-11) is going to be executed.
Case-14 - Exception raised at st11 or st12
If an exception is raised either at st11 or st12, then it is always an abnormal
termination as it is not a part of try block and there is no except block for
the exception handling at these statements.
Else block with try-except finally block
The else block is a python specific concept. else block will be executed
inside try-except-finally block. So, the combination will be try-except-
else-finally block. Within the try block, if there is no exception, then else
block will be going to be executed. Observe the demo Python snippet code:
try:
risky code (code which generates an exception)
except:
handled code/alternative code
(will be executed if exception is raised in try block)
else:
will be executed if there is no exception inside try block
finally:
clean up code or resource deallocation code
(will be executed if exception is raised or not
If exception is handled or not )
An important point to note is that both except and else are not going to
execute simultaneously. If except is going to execute, then else part will not
be executing or vice-versa.
Just observe the following example:
try:
print("inside try")
num1= int(input(" Enter the first number: "))
num2= int(input(" Enter the second number: "))
total = num1 / num2
print("The division is ", total)
except:
print("inside except block")
else:
print("inside else part")

finally:
print("inside finally part")
Output:
Case-1
inside try
Enter the first number: 14
Enter the second number: 2
The division is 7.0
inside else part
inside finally part
Case-2
inside try
Enter the first number: 14
Enter the second number: 2a
inside except block
inside finally part
Case-3
inside try
Enter the first number: 14
Enter the second number: 0
inside except block
inside finally part
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.14.py)
In Case-1, the user is prompted to enter 2 numbers: 14 and 2. Since they are
valid inputs, the output “The division is 7.0” will be displayed to the console.
As there is no exception inside try part, else block will be executed. At last,
the finally block execution will occur.
In Case-2, the user entered 2 numbers: 14 and 2a. Since, ‘2a’ is not a valid
integer, exception will occur in try block. So, except block will be executed.
At last, the finally block execution will occur.
In Case-3, the user entered 2 numbers: 14 and 0. Since, any number divided
by 0 will result in ZeroDivisionError, exception will occur in try block. So,
except block will be executed. At last, the finally block execution will
occur.
We must know that if we are using else block, the except block must
compulsorily be there. Otherwise, PVM will generate syntax error as shown

below:
try:
print("inside try")
num1= int(input(" Enter the first number: "))
num2= int(input(" Enter the second number: "))
total = num1 / num2
print("The division is ", total)
else:
print("inside else part")
finally:
print("inside finally part")
Output:
File "prog74_debugging.py", line 93
else:
^
SyntaxError: invalid syntax
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap04_Example4.15.py)
We can see that else without except block is invalid.
Conclusion
In this chapter, we first initially learned about syntax and runtime error. Then
we learned the importance of exception handling. We learned about handling
exceptions using try and except keywords for graceful termination of the
program. We saw different use cases for the control flow in try-except,
try-except finally block and nested try-except finally block. We also
saw an example of single except block handling multiple exceptions with all
possible combinations of except block. The default and finally except block
is well explained too. Thus, we saw exception handling in this chapter.
In the next chapter, we will learn about the concept of regular expressions in
Python in greater detail.
Points to remember
Syntax error is thrown whenever we write invalid syntax in our code,
whereas Runtime error is thrown on entering the wrong input or wrong
programming logic or memory problem.

Use try and except block for graceful termination of the program.
It is recommended to use the try block with multiple except blocks.
Moreover, a single except block can handle multiple exceptions.
For cleaning up the code, finally block is used.
else block can be used inside try-except and finally block.
The default except block is the last except block where there is no
specific handling code.
Questions
1. Explain syntax and runtime error with a Python snippet code.
2. What is the need of exception handling?
3. Explain with the help of flow chart of Python, exception hierarchy.
4. Explain customized exception handling with an example.
5. Explain the control flow in try-except block with different use cases.
6. Explain try with multiple except blocks with the help of Python
example.
7. Explain default except block with the help of Python snippet code.
8. Explain finally except block with the help of Python snippet code.
9. Define possible combinations of except block.
10. Explain the control flow in try-except and finally block with
different use cases.
11. Explain the control flow in nested try-except and finally block with
different use cases.
12. Explain else block with try-except and finally block.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com


CHAPTER 5
Concept of Regular Expressions in
Python
Introduction
We all know that any mobile number comes with 10 digits. The numbers may
be starting from 9, 8, 7 or even 6. The rest of the 9 digits can be anything.
There is some kind of pattern which is followed by these mobile numbers.
So, we can say that if there is any requirement to represent a group of strings
according to a particular pattern/format, then we can do so with Regular
Expressions. So, it is a declarative mechanism for representation of a group
of strings, according to a particular pattern. As stated, the regular expressions
can be written to represent the mobile numbers, email ids, passwordand so
on. The regular expressions findapplications in the areas of validation of
logic, translators such as assemblers, compilers (lexical analysis) and so on,
as well as areas related to pattern matching, digital circuits, connection, and
connection less communication protocols such as TCP/IP, UDP and many
more. If we want to use regular expressions, Python uses some special
modules known as re module. Several inbuilt functions are contained in this
module, to use regular expression very easily in our applications. A regex
pattern is a character sequence and is a combination of literals and meta-
characters. The literals are the ordinary characters which have no special
meaning and is processedas it is. On the other hand, meta-characters are the
special characters with some meaning. In this chapter, we will be discussing
about the inbuilt functions of regular expressions in details.
Structure
In this chapter, we will cover the following topics:
compile()
finditer()

Character classes
Pre-defined character classes
Quantifiers
Functions of re module
Metacharacters
r prefix
Objectives
By the end of this chapter, the reader will have an idea about various use
cases of regular expression, which will include the concept and syntax of
character classes, allowable pre-defined character classes and metacharacters
depicting its special meaning. We shall also see the concept of quantifiers,
where the number of occurrences to match shall be viewed with various
examples in Python. Different functions of re module will also be explained
with examples. Important functions such as compile(), finditer() and raw
string using ‘r’ or ‘R’ prefix will be neatly explained. By the end of this
chapter, you all will have a better understanding of regex expressions.
compile()
This function will compile pattern into pattern objects, which can perform
various operations such as string substitution performing or searching for
matching of pattern. Refer to the following:
import re
mypattern=re.compile('re')
print(type(mypattern)) # C1
myans=mypattern.findall('regular expressions')
print(myans) # C2
print(mypattern.findall('recursive')) # C3
chk_name = re.compile(r"[^A-Za-zs.]")
myname = input("Kindly, enter the name: ")
while chk_name.search(myname):
print("Kindly enter the name correctly!")
myname = input("Kindly, enter the name: ") # C4
Output:
<class 're.Pattern'>
['re', 're']
['re']

Kindly, enter the name: saurabh123
Kindly enter the name correctly!
Kindly, enter the name: saurabh
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog1_compile.py)
In C1, the type of variable mypattern is <class 're.Pattern'>.
In C2, a list of string re is returned containing all matches where each string
is a single match. Hence, output is ['re', 're'].
In C3, only one match is found. Hence, output is ['re'].
In C4, we are checking if the user input contains only letters, spaces or (no
digits). Any other character is not allowed. We are initially entering the name
as ‘saurabh123’. Since the name entered contains digits, the user id prompter
to enter the name again. On the 2ndattempt, the correct name ‘saurabh’
without any digit was entered.
finditer()
This function will return an iterator object which yields match object for all
non-overlapping matches. The scanning will be done from left to right. If a
match is found, then it will be returned in the order. The following methods
can be called on each match object:
start(): It will return start index of the match.
end(): It will return end+1 index of the match.
group(): It will return the matched string
In the following example, we are trying to find the pattern ‘10’ in the string
‘1000010000100101’. mymatcher is a callable_iterator object. So, we are
using the for loop to get the starting index of the match, ending index of the
match as well as the matched string. Refer to the following program:
import re
mycount = 0
mypattern = re.compile('10')
mymatcher = mypattern.finditer('1000010000100101')
for loop in mymatcher:
mycount += 1
print("starting {}:, ending index {} and group is {} "

.format(loop.start(), loop.end(), loop.group()))
print("The total occurrences of pattern '10' is: ", mycount)
Output:
starting 0:, ending index 2 and group is 10
starting 5:,ending index 7 and group is 10
starting 10:, ending index 12 and group is 10
starting 13:, ending index 15 and group is 10
The total occurrences of pattern 10 is: 4
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog2_finditer.py)
Here, we are searching for only one pattern, which is, ‘10’. Thus, here the
group will always return the matched string which is ‘10’.
We can simplify the code as shown here:
import re
mycount = 0
mymatcher = re.finditer('10','1000010000100101')
for loop in mymatcher:
mycount += 1
print("starting {}:, ending index {} and group is {} "
.format(loop.start(), loop.end(), loop.group()))
print("The total occurrences of pattern '10' is: ", mycount)
Output:
starting 0:, ending index 2 and group is 10
starting 5:, ending index 7 and group is 10
starting 10:, ending index 12 and group is 10
starting 13:, ending index 15 and group is 10
The total occurrences of pattern '10' is: 4
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog3_finditer_code_simplification.py)
Here, we are searching for the pattern ‘10’ in the string ‘1000010000100101’.
The callable_iterator object is looped to get the result.
An important point to note is that we cannot use filename in the
secondargument of finditer function. There is a separate way to find the
pattern in a file, which we will discuss later.
Character classes

If there is a requirement to search a group of characters, then we should go
for character classes. Refer to the following Table 5.1:
S No.
Syntax
Description
1
[xyz]
A match is returned where one of the specified
characters (x, y, or z) is present.
2
[^xyz]
A match is returned for any character except x,
y, and z.
3
[a-z]
A match is returned for any lower case
character alphabetically between a and z.
4
[A-Z]
A match is returned for any upper case
character alphabetically between A and Z.
5
[a-zA-Z]
A match is returned for either upper case or
lower case character alphabetically between a
and z.
6
[0-9]
A match is returned for any digit between 0 and
9.
7
[0-6][0-9]
A match is returned for any 2 digit numbers
from 00 and 69.
8
[aeiou]
A match is returned for any one lower case
vowel.
9
[^aeiou]
A match is returned for character other than a
lowercase vowel.
10
[a-zA-Z0-9]
A match is returned for any alphanumeric
characters.
11
[^a-zA-Z0-9]
A match is returned for special characters (other
than alphanumeric characters).
12
[0123]
A match is returned for any of the digits
between 0 and 3.
Table 5.1: Table depicting match for different character classes
Let us see some examples of different character classes.
import re
mymatcher = re.finditer('[xyz]','djx&AI#82%3U')

for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC1
print("------------------")
mymatcher = re.finditer('[^xyz]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC2
print("------------------")
mymatcher = re.finditer('[a-z]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC3
print("------------------")
mymatcher = re.finditer('[A-Z]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC4
print("------------------")
mymatcher = re.finditer('[a-zA-Z]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC5
print("------------------")
mymatcher = re.finditer('[0-9]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC6
print("------------------")
mymatcher = re.finditer('[0-6][0-9]','djx&AI#82%3U1059')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC7
print("------------------")
mymatcher = re.finditer('[aeiou]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC8
print("------------------")
mymatcher = re.finditer('[^aeiou]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC9
print("------------------")
mymatcher = re.finditer('[a-zA-Z0-9]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC10
print("------------------")
mymatcher = re.finditer('[^a-zA-Z0-9]','djx&AI#82%3U')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # CC11
Code explanation with output:
In CC1, the characters x, y or z are searched for in the string
‘djx&AI#82%3U’ and is looped (since iterators are always iterables) to get
the starting index and the matched items. Hence, output is 2 ….. x

In CC2, any character except x, y and z is searched in the string
‘djx&AI#82%3U’ and is looped to get the starting index and the matched
items. Hence, output is:
0 ….. d
1 ….. j
3 ….. &
4 ….. A
5 ….. I
6 ….. #
7 ….. 8
8 ….. 2
9 ….. %
10 ….. 3
11 ….. U
In CC3, the lowercase characters alphabetically between a and z are searched
in the string ‘djx&AI#82%3U’ and is looped to get the starting index and the
matched items. Hence, output is:
0 ….. d
1 ….. j
2 ….. x
In CC4, the uppercase characters alphabetically between a and z are searched
in the string ‘djx&AI#82%3U’ and is looped to get the starting index and the
matched items. Hence, output is:
4 ….. A
5 ….. I
11 ….. U
In CC5, both the uppercase and lowercase characters alphabetically between a
and z are searched for, in the string ‘djx&AI#82%3U’ and is looped to get the
starting index and the matched items. Hence, output is:
0 ….. d
1 ….. j
2 ….. x
4 ….. A
5 ….. I
11 ….. U
In CC6, any digit between 0 and 9 is searched in the string ‘djx&AI#82%3U’
and is looped to get the starting index and the matched items. Hence, output
is:
7 ….. 8
8 ….. 2

10 ….. 3
In CC7, any two digit number between 00 and 69 is searched in the string
‘djx&AI#82%3U1059’ and is looped to get the starting index and the
matched items. Hence, output is:
12 ….. 10
14 ….. 59
In CC8, the vowels a, e, i, o and u are searched in the string ‘djx&AI#82%3U’
and is looped to get the starting index and the matched items. Hence, output
is None.
In CC9, any character other than vowels are searched in the string
‘djx&AI#82%3U’ and is looped to get the starting index and the matched
items. Hence, output is:
0 ….. d
1 ….. j
2 ….. x
3 ….. &
4 ….. A
5 ….. I
6 ….. #
7 ….. 8
8 ….. 2
9 ….. %
10 ….. 3
11 ….. U
In 
CC10, any alphanumeric character is searched in the string
‘djx&AI#82%3U’ and is looped to get the starting index and the matched
items. Hence, output is:
0 ….. d
1 ….. j
2 ….. x
4 ….. A
5 ….. I
7 ….. 8
8 ….. 2
10 ….. 3
11 ….. U
In CC11, the special characters (other than alphanumeric character) are
searched in the string ‘djx&AI#82%3U’ and is looped to get the starting
index and the matched items. Hence, output is:
3 ….. &

6 ….. #
9 ….. %
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog4_character_classes.py)
Pre-defined character classes
Now, we will be discussing about pre-defined character classes. Table 5.2
shows the allowable Pre-defined Character Classes:
S No.
Character
Description
1
\s
A match is returned where the string contains a
whitespace character.
2
\S
A match is returned where the string contains
any character other than whitespace character.
3
\d
A match is returned where the string contains
digits from 0 to 9.
4
\D
A match is returned where the string contains
any character other than digits.
5
\w
A match is returned where the string contains
any word character (characters from 0-9, a-z, A-
Z, and underscore).
6
\W
A match is returned where the string does not
contain word characters (special characters).
7
\A
A match is returned if the specified characters
are at the beginning of a string.
8
\b
A match is returned if the specified characters
are at the beginning or at the end of a word.
9
\B
A match is returned where the specified
characters are present (not at the beginning or at
the end of a word).
10
\Z
A match is returned if the specified characters
are present at the end of a string.
11
.
A match is returned where the string contains

any character except newline.
Table 5.2: Allowable Pre-defined Character Classes
Let us see some examples:
import re
mymatcher = re.finditer('\s','fx&A I#82%3')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC1
print("------------------")
mymatcher = re.finditer('\S','fx&A I#82%3')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC2
print("------------------")
mymatcher = re.finditer('\d','fx&A I#82%3')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC3
print("------------------")
mymatcher = re.finditer('\D','fx&A I#82%3')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC4
print("------------------")
mymatcher = re.finditer('\w','fx&A I#82%3_')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC5
print("------------------")
mymatcher = re.finditer('\W','fx&A I#82%3_')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC6
print("------------------")
mymatcher = re.finditer('\AThe','The Corona Virus in world')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC7
print("------------------")
mymatcher = re.finditer(r"rld\b",'The Corona Virus in world')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC8
print("------------------")
mymatcher = re.finditer(r'\Bect','A Temporary effect')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC9
print("------------------")
mymatcher = re.finditer('effect\Z','A Temporary effect')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC10
print("------------------")
mymatcher = re.finditer('.','fx&A\nI#82%3')

for loop in mymatcher:
print(loop.start(), '…..', loop.group()) # PC11
Code explanation with output:
In PC1, a whitespace character is searched for in the string ‘‘fx&A I#82%3”
and is looped to get back the starting index and the matched items. Hence,
output is 4 ….. .
In PC2, any character apart from whitespace character is searched in the string
‘‘fx&A I#82%3” and is looped to get back the starting index and the matched
items. Hence, output is:
0 ….. f
1 ….. x
2 ….. &
3 ….. A
5 ….. I
6 ….. #
7 ….. 8
8 ….. 2
9 ….. %
10 ….. 3
In PC3, digits from 0-9 is searched in the string ‘‘fx&A I#82%3” and is
looped to get back the starting index and the matched items. Hence, output is:
7 ….. 8
8 ….. 2
10 ….. 3
In PC4, any character apart from the digits 0-9 is searched in the string
‘‘fx&A I#82%3” and is looped to get back the starting index and the matched
items. Hence, output is:
0 ….. f
1 ….. x
2 ….. &
3 ….. A
4 …..
5 ….. I
6 ….. #
9 ….. %
In PC5, alphanumeric characters including _ (underscore) is searched in the
string ‘‘fx&A I#82%3_” and is looped to get back the starting index and the
matched items. Hence, output is:
0 ….. f
1 ….. x

3 ….. A
5 ….. I
7 ….. 8
8 ….. 2
10 ….. 3
11 ….. _
In PC6, any character apart from alphanumeric characters and underscore is
searched in the string ‘‘fx&A I#82%3_” and is looped to get back the starting
index and the matched items. Hence, output is:
2 ….. &
4 …..
6 ….. #
9 ….. %
In PC7, the specified characters ‘The’ will be checkedat the beginning of the
string “The Corona Virus in the world” and is looped to get back the starting
index and the matched item. Hence, output is:
0 ….. The
In PC8, the specified characters ‘rld’ will be checkedat the beginning or at
the end of the string “The Corona Virus in the world” and is looped to get
back the starting index and the matched item. Hence, output is:
22 ….. rld
In PC9, the specified character ‘ect’ is checked if present but not at the
beginning of the string “A temporary effect” and is looped to get back the
starting index and the matched item. Hence, output is:
15 ….. ect
In PC10, the specified characters ‘effect’ will be checked if it ends in the
string “A temporary effect” and is looped to get back to the starting index and
the matched item. Hence, output is:
12 ….. effect
In PC11, any character except new line is searched in the string
‘‘fx&A\nI#82%3_” and is looped to get back the starting index and the
matched items. Hence, output is:
0 ….. f
1 ….. x
2 ….. &
3 ….. A
5 ….. I
6 ….. #

7 ….. 8
8 ….. 2
9 ….. %
10 ….. 3
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog5_pre_defined_character_classes.py)
Quantifiers
Whenever there is a requirement to specify the number of occurrences to
match, we will be using quantifiers. In other words, it is a mechanism to
define how a character, character set and metacharacter can be repeated in the
pattern. Suppose a regular expression pattern is definedand we specify that a
character should be repeated 4 times. In this scenario, we can either write the
character 4 times or we can use the concept of quantifiers. Refer to the
following Table 5.3:
SNo.
Syntax
Description
1
x
A match is returned for exactly single x.
2
x+
A match is returned for the expression to its left
1 or more times. In other words, it is searching
for at least single x.
3
x*
A match is returned for the expression to its left
0 or more times. In other words, it is searching
for any number of x including zero number of
x’s.
4
x?
A match is returned for the expression to its left
0 or 1 time. In other words, it is searching for at
most one ‘x’, that is, either single x or zero
number of x’s.
5
x{m}
A match is returned for the expression to its left
m times and not less. In other words, exactly m
number of x’s.
6
x{m,n}
A match is returned for the expression to its left
m to n times and not less. In other words,
minimum m number of x’s and maximum n
number of x’s.

7
^x
A match is returned for the expression to its
right at the start of a string. Every such instance
is matched before each \n in the string. In other
words, it checks whether the target string starts
with x or not.
8
x$
A match is returned for the expression to its left
at the start of a string. Every such instance is
matched before each \n in the string. In other
words, it checks whether the target string ends
with x or not.
Table 5.3: Table depicting quantifiers
Let us see some examples of quantifiers:
import re
mymatcher = re.finditer('x','xyxxyxxxyxxxxy')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) #Q1
print("------------------")
mymatcher = re.finditer('x+','xyxxyxxxyxxxxy')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) #Q2
print("------------------")
mymatcher = re.finditer('x*','xyxxyxxxyxxxxy')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) #Q3
print("------------------")
mymatcher = re.finditer('x?','xyxxyxxxyxxxxy')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) #Q4
print("------------------")
mymatcher = re.finditer('x{3}','xyxxyxxxyxxxxy')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) #Q5
print("------------------")
mymatcher = re.finditer('x{3,5}','xyxxyxxxyxxxxy')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) #Q6
print("------------------")
mymatcher = re.finditer('^x','xyxxyxxxyxxxxy')
for loop in mymatcher:
print(loop.start(), '…..', loop.group()) #Q7
print("------------------")
mymatcher = re.finditer('y$','xyxxyxxxyxxxxy')
for loop in mymatcher:

print(loop.start(), '…..', loop.group()) #Q8
Code explanation with output:
In 
Q1, exactly a single character ‘x’ is searched in the string
‘‘xyxxyxxxyxxxxy” and is looped to get back the starting index and the
matched items. Hence, output is:
0 ….. x
2 ….. x
3 ….. x
5 ….. x
6 ….. x
7 ….. x
9 ….. x
10 ….. x
11 ….. x
12 ….. x
In Q2, an occurrence of a character ‘x’ one or more times (at least one x) is
searched in the string ‘‘xyxxyxxxyxxxxy” and is looped to get back the
starting index and the matched items. Hence, output is:
0 ….. x
2 ….. xx
5 ….. xxx
9 ….. xxxx
In Q3, an occurrence for any number of character x’s including 0 number of x
is searched in the string ‘‘xyxxyxxxyxxxxy” and is looped to get back the
starting index and the matched items. Hence, output is:
0 ….. x
1 …..
2 ….. xx
4 …..
5 ….. xxx
8 …..
9 ….. xxxx
13 …..
14 …..
An important point to note is that even though the string is terminated with
character ‘y’ at index position 13, it will also check for index 14 (last index
position +1) which is nothing, that is, 0 number of x. That is why, here the
index position 14 is displayed.
In Q4, an occurrence for, at most, one number of character x is searched in the
string ‘‘xyxxyxxxyxxxxy” and is looped to get back the starting index and

the matched items. Hence, output is:
0 ….. x
1 …..
2 ….. x
3 ….. x
4 …..
5 ….. x
6 ….. x
7 ….. x
8 …..
9 ….. x
10 ….. x
11 ….. x
12 ….. x
13 …..
14 …..
In Q5, exactly three numbers of character x is searched in the string
‘‘xyxxyxxxyxxxxy” and is looped to get back the starting index and the
matched items. Hence, output is:
5 ….. xxx
9 ….. xxx
In Q6, minimum 3 numbers of character x and maximum 5 numbers of x is
searched in the string ‘‘xyxxyxxxyxxxxy” and is looped to get back the
starting index and the matched items. Hence, output is:
5 ….. xxx
9 ….. xxxx
In Q7, a string ‘‘xyxxyxxxyxxxxy” is checked whether it starts with character
x or not, and is looped to get back the starting index and the matched item.
Hence, output is 0 ….. x.
In Q8, a string ‘‘xyxxyxxxyxxxxy” is checked whether it ends with character
y or not, and is looped to get back the starting index and the matched item.
Hence, output is 13 ….. y.
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog6_quantifiers.py)
Functions of re module
We have already discussed compile() and finditer() function. Apart from
the previous two functions, we will be discussing some more important

functions.
match
This function will check for matching of the given pattern only at the
beginning of the target string. A match object is returned if the match is
available. Otherwise, we will get None.
The syntax of re.match() is:
re.match(pattern, string, flags=0)
The first parameter is the pattern whose regular expression is to be matched.
The second parameter is the string where the pattern is to be matched.
The third parameter is optional flags, where we can specify different flags
such as re.IGNORECASE.
Refer to the following code:
import re
mypattern=input("Please write the pattern to check: ")
mymatch=re.match(mypattern,"rstuvwxyz")
if mymatch!= None:
print("We have found match at the beginning of the string")
print("Start Index is :",mymatch.start(), "and End Index is
:",mymatch.end())
else:
print("We have not found match at the beginning of the string")
Output:
Case-1
Please write the pattern to check: rstu
We have found match at the beginning of the string
Start Index is : 0 and End Index is : 4
Case-2
Please write the pattern to check: rstuvwxyz
We have found match at the beginning of the string
Start Index is : 0 and End Index is : 9
Case-3
Please write the pattern to check: qrst
We have not found match at the beginning of the string
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog7_re_match.py)

In Case-1, we have entered the pattern ‘rstu’. It is attempted to match the
previous pattern at the beginning of the target string ‘rstuvwxyz’. It is
matchedand the match object is returnedand the start index (0), and end index
(4), are displayed. Hence, output is displayedas shown above.
In Case-2, we have entered the pattern ‘rstuvwyxyz’. It is attempted to match
the previous pattern at the beginning of the target string ‘rstuvwxyz’. It is
matchedand the match object is returnedand the start index (0), and end index
(9), are displayed. Hence, output is displayedas shown above.
In Case-3, we have entered the pattern ‘qrst’. It is attempted to match the
previous pattern at the beginning of the target string ‘rstuvwxyz’. It is not
matched. Hence, output is displayedas shown above.
An important point to note is that the pattern is matched only at the beginning
of the string and not at the beginning of each line even in MULTILINE
mode.
fullmatch
This function will check for matching of the given pattern to the whole string.
A match object is returned if the match is available. Otherwise, we will get
None.
The syntax of re.fullmatch() is:
re.fullmatch(pattern, string, flags=0)
import re
mypattern=input("Please write the pattern to check: ")
mymatch=re.fullmatch(mypattern,"rstuvwxyz")
if mymatch!= None:
print("We have found match at the whole string")
print("Start Index is :",mymatch.start(), "and End Index is
:",mymatch.end())
else:
print("We have not found match at the whole string")
Output:
Case-1
Please write the pattern to check: rstu
We have not found match at the whole string
Case-2
Please write the pattern to check: rstuvwxyz

We have found match at the whole string
Start Index is : 0 and End Index is : 9
Case-3
Please write the pattern to check: rstuvwxyza
We have not found match at the whole string
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog8_re_fullmatch.py)
In Case-1, we have entered the pattern ‘rstu’. It is attempted to match the
previous pattern at the entire string ‘rstuvwxyz’. It is not matched. Hence,
output is displayedas shown above.
In Case-2, we have entered the pattern ‘rstuvwyxyz’. It is attempted to match
the previous pattern at the entire string ‘rstuvwxyz’. It is matchedand the
match object is returnedand the start index (0) and end index (9) is displayed.
Hence, output is displayedas shown above.
In Case-3, we have entered the pattern ‘rstuvwxyza’. It is attempted to match
the previous pattern at the entire string ‘rstuvwxyz’. It is not matched. Hence,
output is displayedas shown above.
search
This function will check the given pattern in the target string. A match object
is returned if the match is available, representing the first occurrence of the
match. None is returned if no match is found. It is best suited for regular
expression, testing more than data extraction as it stops after the first match.
The syntax of re.search() is
re.search(pattern, string, flags=0)
import re
mypattern=input("Please write the pattern to check: ")
mymatch=re.search(mypattern,"101101110")
if mymatch!= None:
print("We have found match")
print("Start Index is :",mymatch.start(), "and End Index is
:",mymatch.end())
else:
print("We have not found the match")
Output:
Case-1

Please write the pattern to check: 111
We have found match
Start Index is : 5 and End Index is : 8
Case-2
Please write the pattern to check: 1010
We have not found the match
Case-3
Please write the pattern to check: 0110
We have found match
Start Index is : 1 and End Index is : 5
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog9_re_search.py)
In Case-1, we have entered the pattern ‘111’. It attempts to match the first
occurrence of the pattern in the target string ‘101101110’. It is matchedand
the match object is returned, and the start index (5), and end index (8) is
displayed. Hence, output is displayedas shown above.
In Case-2, we have entered the pattern ‘1010’. It is attempted to match the
first occurrence of the pattern in the target string ‘101101110’. It is not
matched. Hence, output is displayedas shown above.
In Case-3, we have entered the pattern ‘0110’. It is attempted to match the
first occurrence of the pattern in the target string ‘101101110’. It is
matchedand the match object is returnedand the start index (1) and end index
(5) are displayed. Hence, output is displayedas shown above.
findall
This function will return a list object containing all the non-overlapping
match pattern. The scanning of the string is done left to right. If match is
found, then it will be returned in the order.
The syntax of re.findall() is:
re.findall(pattern, string, flags=0)
import re
myl1=re.findall("[a-z]","b4j5k67ap0")
print(myl1)
Output:
['b', 'j', 'k', 'a', 'p']

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog10_re_findall.py)
In the previous example, all the lowercase characters occurrences of the
match are returnedas a list object.
sub
This function stands for substitution or replacement. The syntax of re.sub()
is:
re.sub(pattern, repl, string, count=0, flags=0)
A certain regular expression pattern (1st parameter) is searched in the string
mentioned (3rd parameter) and upon finding the match, occurrences are
replaced with the replace variable content (2nd parameter). The count (4th
variable) is then checkedand the number of times this occurred, is
maintained. The original string is returned if the pattern is not found.
Refer to the following example:
import re
mytxt = '123 \n123 gfh'
mypattern = '\s'
myreplace = ''
mystr = re.sub(mypattern, myreplace, mytxt)
print(mystr) # SUB1
print("-------------")
mystr = re.sub(mypattern, myreplace, mytxt,count =1)
print(mystr) # SUB2
print("-------------")
print(re.sub('st', '*#', 'Stay safe, stay healthy', flags =
re.IGNORECASE)) # SUB3
print("-------------")
print(re.sub('st', '*#', 'Stay safe, stay healthy')) # SUB4
print("-------------")
print(re.sub('st', '*#', 'Stay safe, stay healthy', count = 1,
flags = re.IGNORECASE)) # SUB5
print("-------------")
print(re.sub(r'\sAND\s', ' & ', 'The prince and the pauper',
flags = re.IGNORECASE)) # SUB6
Code explanation with Output:
In SUB1, we are trying to match all the whites space characters in the target
string ‘123 \n123 gfh’ and is replaced by an empty string ‘’ when match

found. The count parameter is default 0 and will replace all the matched
occurrences. Hence, output will be 123123gfh.
In SUB2, we are trying to match all the whites space characters in the target
string ‘123 \n123 gfh’, and they are replaced by an empty string ‘’ when
match is found. The count parameter is 1, and so the maximum times that
replacement occurs, is 1. Due to presence of \n, the output after replacement
of whitespace once only is:
123
123 gfh
In SUB3, the regular expression pattern ‘st’ matches the substring at “Stay”
and “stay”. The case has been ignored due to the flag “st”, will match twice
with the string. The “st” will be replaced by “*#” in both the substrings.
Hence, output is *#ay safe, *#ay healthy.
In SUB4, we are considering the case sensitivity “st” in “Stay” which will not
be replaced. Hence, output is Stay safe, *#ay healthy.
In SUB5, the count parameter is 1. So, the maximum time that replacement
can be done is 1. Also, the case is ignored. Hence, output is *#ay safe,
stay healthy.
In SUB6, the letter before the pattern denotes re, \s is for start and end of a
string. AND is replaced by ‘ & ‘. Hence, output is The prince & the
pauper.
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog11_re_sub.py)
subn
This function is like the sub function, except that it returns a tuple of 2
arguments. The first argument is the new string, rather than just the string
after the replacement and the other is the number of substitutions or
replacements done (count value).
Refer to the following example:
import re
mytxt = '123 \n123 gfh'
mypattern = '\s'
myreplace = ''
mystr = re.subn(mypattern, myreplace, mytxt)

print(mystr) # SUBN1
print(type(mystr))
print(mystr[0])
print(mystr[1])
print("-------------")
mystr = re.subn(mypattern, myreplace, mytxt,count =1)
print(mystr) # SUBN2
print("-------------")
print(re.subn('st', '*#', 'Stay safe, stay healthy', flags =
re.IGNORECASE)) # SUBN3
print("-------------")
print(re.subn('st', '*#', 'Stay safe, stay healthy')) # SUBN4
print("-------------")
print(re.subn('st', '*#', 'Stay safe, stay healthy', count = 1,
flags = re.IGNORECASE)) # SUBN5
print("-------------")
print(re.subn('\sAND\s', ' & ', 'The prince and the pauper',
count = 1, flags = re.IGNORECASE)) # SUBN6
Code explanation with Output:
In SUBN1, we are trying to match all the whites space characters in the target
string ‘123 \n123 gfh’, and they are replaced by an empty string ‘’ when
match is found. The count parameter is default 0 and will replace all the
matched occurrences. The 1st parameter will be the new string after
replacement and the 2nd parameter is the total number of substitutions done,
which is 3. Hence, output will be ('123123gfh', 3).
Here, the class is tuple and the 1st and 2nd element is displayedas shown:
<class 'tuple'>
123123gfh
3
In SUBN2, we are trying to match all the whites space characters in the target
string ‘123 \n123 gfh’ and they are replaced by an empty string ‘’ when
match found. The count parameter is 1, so the maximum time replacement
occurs is 1. Hence, output is ('123\n123 gfh', 1).
In SUBN3, the regular expression pattern ‘st’ matches the substring at “Stay”
and “stay”. The case has been ignored due to the flag; “st” will match twice
with the string. The “st” will be replaced by “*#” in both the substrings. The
number of times substitution done is 2. Hence, output is ('*#ay safe, *#ay
healthy', 2).
In SUBN4, we are considering the case sensitivity “st” in “Stay” which will not
be replaced. The number of times substitution is done, is 1. Hence, output is

('Stay safe, *#ay healthy', 1).
In SUBN5, the count parameter is 1. So, the maximum time replacement can be
done is 1. Also, the case is ignored. The number of times substitution done is
1. Hence, output is ('*#ay safe, stay healthy', 1).
In SUBN6, the letter before the pattern denotes re, \s is for start and end of a
string. AND is replaced by ‘& ‘. The number of times substitution done is 1.
Hence, output is ('The prince & the pauper', 1).
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog12_re_subn.py)
split
This function will spilt the mentioned target string according to a particular
pattern. The syntax of re.split() is:
re.split(pattern, string, maxsplit=0, flags=0)
The first parameter is the regular expression pattern.
The second parameter is the target string where the pattern will be searched
for and in which splitting will occur.
The third parameter is the maxsplit. If provided, then almost that many splits
will occur. Otherwise, its default value is 0. Let us assume that the maxsplit
parameter is mentionedas 1. In that case, the string will be splitting once,
resulting in a list of length 2.
The fourth parameter is optional flags, in which we can specify different flags
such as re.IGNORECASE.
Refer to the following example:
import re
mymatch=re.split('\s',"Python is awesome")
print(type(mymatch)) # SP1
print(mymatch) # SP2
for loop in mymatch: # SP3
print(loop)
mytxt = "www.abc.com"
mymatch=re.split('\.',mytxt)
print(mymatch) # SP4
print(re.split('\W+', 'Fruits, fruits, Fruits')) # SP5
print(re.split('\W+', "Fruit's fruits Fruits")) # SP6
print(re.split('\W+', '25th March 2020, at 12:02 PM')) # SP7

print(re.split('\d+', '25th March 2020, at 12:02 PM')) # SP8
Code explanation with Output:
In SP1, the type of mymatch object is <class 'list'>.
In SP2, a list is returned where the string has been split at each white space
character. Hence, output is ['Python', 'is', 'awesome'].
In SP3, we are using the for loop to iterate each element of the list object.
Hence, output is:
Python
is
awesome
In SP4, a list is returned where the string has been split at each ‘.’ character.
Hence, output is:
['www', 'abc', 'com']
In SP5, a list is returned where the string has been split at ‘,’ or ‘ ‘
(whitespace) character. Hence, output is ['Fruits', 'fruits', 'Fruits'].
In SP6, a list is returned where the string has been split at Non-Alphanumeric
Characters. Here, at ‘’’ (apostrophe) and ‘ ‘ (white space). Hence, output is
['Fruit', 's', 'fruits', 'Fruits'].
In SP7, a list is returned where the string has been split at Non-Alphanumeric
Characters at ‘:’, ‘,’ and ‘ ‘ . Hence, output is ['25th', 'March', '2020',
'at', '12', '02', 'PM'].
In SP8, a list is returned where splitting occurs at numeric characters. Here, at
‘25’, ‘2020’, ‘12’ and ‘02’. Hence, output is ['', 'th March ', ', at ',
':', ' PM'].
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog13_re_split.py)
escape
This function will return a string with backslash before every non-
alphanumeric character. It comes handy when there is an arbitrary literal
string which may have regular expression metacharacters in it.
The syntax of re.escape() is:
re.escape(pattern)

Refer to the following example:
import re
print(re.escape("Congratulations to all the team members")) #
ES1
print(re.escape("https://www.webmail.in")) # ES2
print(re.escape("One of the set in regex is [a-z]. I am ^ /n
flatterred")) # ES3
Code explanation with output:
In ES1, a whitespace character is not alphanumeric. So, a backslash character
will be used before every white space. Hence, output is Congratulations\
to\ all\ the\ team\ members.
In ES2, ‘.’ is not alphanumeric. So, a backslash character will be used before
every ‘.’ character. Hence, output is https://www\.webmail\.in.
In ES3, ‘ ‘, caret ‘^’, ‘-’ and ‘[]’ are not alphanumeric. So, a backslash
character will be used before these characters. Hence, output is One\ of\
the\ set\ in\ regex\ is\ \[a\-z\]\.\ I\ am\ \^\ /n\ flattered.
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog14_re_escape.py)
Metacharacters
Metacharacters are characters with a special meaning andare interpreted in a
special way by a RegEx engine. We will be discussing about the
metacharacters one by one.
[] (Square brackets)
A set of characters can be specified that we wish to match. Refer to Table
5.4:
Expression
String
Matched ?
[xyz]
x
1 Match
xz
2 Matches
Hello James
No Match
xyz abc zx
5 Matches

Table 5.4: Table depicting square brackets meta character
In the previous example, [xyz] will match if the target string contains any of
the x, y, or z.
A range of characters can be specified inside square brackets using -, as
follows:
[d-g] is same as [defg]
[0-8] is same as [012345678]
The character set can be inverted using ^ symbol at the start of the
square bracket.
[^xyz] means any character except x, y, or z.
[^0-9] means any non-digit character (any character except digits from
0 to 9)
. (Period)
This metacharacter will match any character except new line (‘\n’). Refer to
Table 5.5:
Expression
String
Matched ?
..
x
No Match
xz
1 Match
xyz
1 Match
wxyz
2 Matches (containing 4
characters)
Table 5.5: Table depicting period meta character
^ (Caret)
This metacharacter will check whether the target string starts with the
provided pattern or not. A match object is returned if the target strings starts
with the provided pattern. Otherwise, it returns None. Refer to Table 5.6:
Expression
String
Matched ?
^x
x
1 Match

xyz
1 Match
yzx
No Match
wxyz
No Match
^xy
xyz
1 Match
xzy
No Match (starts with x but
not followed by y)
Table 5.6: Table depicting caret meta character
$ (Dollar)
This metacharacter will check whether the target string ends with the
provided pattern or not. A match object is returned if the target strings ends
with the provided pattern, otherwise, it returns None. Refer to Table 5.7:
Expression
String
Matched ?
x$
x
1 Match
xyz
No Match
xy$
xyz
No Match
zxy
1 Match
Table 5.7: Table depicting dollar meta character
* (Star)
This metacharacter will match the expression to its left, 0 or more times.
Refer to Table 5.8:
Expression
String
Matched ?
spa*n
spn
1 Match
span
1 Match
spaaan
1 Match
spain
No Match (character a is not followed by character
n)

Table 5.8: Table depicting star meta character
+ (Plus)
This metacharacter will match the expression to its left, 1 or more times.
Refer to Table 5.9:
Expression
String
Matched ?
spa+n
spn
No Match (as no ‘a’ character)
span
1 Match
spaaan
1 Match
spain
No Match (character a is not followed by character
n)
Table 5.9: Table depicting plus meta character
? (Question Mark)
This metacharacter will match the expression to its left, 0 or 1 time. Refer to
Table 5.10:
Expression
String
Matched ?
spa?n
spn
1 Match
span
1 Match
spaaan
No Match (more than one a character)
spain
No Match (character a is not followed by character
n)
Table 5.10: Table depicting question mark meta character
{} (Braces)
This metacharacter {a,b} will match the expression to its left, a to b times and
not less. Refer to Table 5.11:
Expression
String
Matched ?
x{2,3}
xyz abc
No match

vw xxy
1 Match (at xxy)
xxyz wxxxy
2 Matches (at xxyz and wxxxy)
xxyz wxxxxy
2 Matches (at xxyz and wxxxxy)
[0-9]{2,3} (will match at least 2
digits but not more than 3 digits)
xy34abs
1 Match at xy34abs
76 and 765432
2 Matches (at 76 and 765432)
3 and 4
No match
Table 5.11: Table depicting braces meta character
| (Alternation):
This metacharacter vertical bar is used for alteration (or operator). Refer to
Table 5.12:
Expression
String
Matched ?
x|y (a string is matched which contains
either x or y)
wst
No match
xza
1 Match (at xza)
xzaybc
2 Matches (at xzaybc)
Table 5.12: Table depicting alternation meta character
() (Group)
This metacharacter parenthesis is used to group sub-patterns. Refer to Table
5.13:
Expression
String
Matched ?
(x|y|z)ac (a string is matched which
contains either x or y or z followed by ac)
xy ac
No match
xyac
1 Match (at xyac)
xac and zyxac
2 Matches (at xac and
zyxac)
Table 5.13: Table depicting group meta character

\ (Backslash)
The character \ will escape various characters including metacharacters. For
example, \$x will match if a string has $, followed by character x. Here,
interpretation of $ will not be done in a special way. So, just put backslash
and the character will not be treated in a special way. We have already
discussedabout pre-defined character classes using backslash.
r prefix
We have seen the use of r or R prefix before a regular expression, quite often.
It means raw string. For example, \n means new line whereas r'\n' means
there are 2 characters, one backslash followed by character n.
Refer to the following example:
import re
mystr = '\n and \t are escape sequences.'
myres = re.findall(r'[\n\t]', mystr)
print(myres)
Output:
['\n', '\t']
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap05_prog15_r_prefix.py)
Conclusion
In this chapter, we started with 2 important functions: compile() and
finditer() function. Then we saw about different character classes syntax
followed by allowable pre-defined character classes with well-illustrated
Python code. We dig up into the concept of quantifiers and saw different
functions of ‘re’ module. Then we learnedabout different metacharacters’
importance with its applicational usage. Finally, at the end, we saw the use of
‘r’ raw string prefix before a regular expression.
In the next chapter, we shall be learning about functions concept importance
with various examples in detail
Points to remember

compile() function is used for compiling pattern into pattern objects.
finditer() function will return an iterator object which yields a match
object for all non-overlapping matches.
Applicational usage of character andallowable pre-defined character
classes is a must to know for various Python code applicational
requirements.
Whenever there is a need for specifying the number of occurrences to
match, then we shall be using quantifiers.
Observe various examples and concepts of re module functions which
was explained elegantly with a Python snippet code.
Make sure that metacharacters are the characters with a special meaning
and has a special way of interpretation by a RegEx engine.
raw string uses either ‘r’ or ‘R’ prefix before a regular expression.
Questions
1. Name the function which can compile pattern into pattern objects such
as matching pattern or string substitution. Explain with a Python code.
2. Name the function which returns an iterable object which yields match
object for all non-overlapping matches. Explain with a Python code.
3. Explain different syntax of character classes with a Python snippet code.
4. Explain different allowable pre-defined character classes with a Python
snippet code.
5. Explain different syntax of quantifiers with a Python snippet code.
6. Explain the following functions with syntax anda Python snippet code.
a. match()
b. fullmatch()
c. findall()
d. search()
e. sub()
f. subn()
g. split()

h. escape()
7. Explain different metacharacters with a Python snippet code.
8. What is the importance of r-prefix in regular expressions? Explain with
a Python snippet code.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 6
Concept of Functions in Python
Introduction
Sometimes during programming a code, we are required to use the same code
again and again. As per the Don’t Repeat Yourself (DRY) concept, the
same code should not be repeated multiple times during programming.
Nonetheless, sometimes we need to use a block of code multiple times. In
such cases, functions in Python come handy.
Functions play a huge role in our Python code. An important point to note is
that functions must be defined initially before being later called in Python
with proper indentation. Functions in Python are important as a coder,
because DRY concept must be respected, while creating any big project
makes that any 3rd party coder understand its importance.
Structure
In this chapter, we will discuss the following topics:
Functions in Python
Function types
Function arguments
Nested function
Python closures
Function passing as a parameter
Local, global, and non-local variables
Recursive function
Python lambda functions
Objectives

By the end of this chapter, the reader will have an idea about what exactly
function is in Python. They will have a taste of various arguments such as
positional, keyword, default, *args and **kwargs. The concept of local,
global, and non-local variables will be well explained. We shall see how to
bind the data to a function without passing them as parameters called
closures. One function will be defined inside another function using nested
function concept. We shall see recursive function, that is, a function calling
itself. Anonymous functions taking any number of arguments with one
expression will be seen by exploring the concept of lambda functions.
Functions in Python
It is not recommended to write group of statements repeatedly to execute the
program. The group of statements will be defined as a single unit, thus
breaking our program into smaller and modular chunks. We name this group
of statements as functions, which performs a specific task. Code reusability is
possible and repetition is avoided. We will be writing function only once, but
the function will be called multiple times. The basic syntax of function is as
follows:
def func_name(parameters):
""" docstring """
statement(s)
Let us explain the significance of each component in the preceding syntax:
def is a keyword which marks the function header start.
A unique name to identify function which follows the same rule of
writing identifiers in Python.
Parameters (arguments) are optional, through which we pass values to
a function.
A colon operator (:) to mark the end of the function header.
Docstring is optional to give a small description of what the function
does. A documentation string is used to explain in brief about the
function. Generally, docstring is written using triple quotes which can
be extended up to multiple lines. The docstring is also available to us as
__doc__ attribute of the function.
Function body contains one or more valid Python statements. An
important point to note is that the statements must have the same

indentation level (usually 4 spaces).
An optional return statement at the end so that a value can be returned
from the function. This statement will exit from the function and the
control will come back to the place from where it was called. If there is
no return statement itself inside a function, then the function will return
the None object.
An example of a function is as follows:
def myfun_add_two(a,b):
''' adding two numbers functions'''
return a + b # return is optional you can even write print here
only.
print(myfun_add_two(3,4))
print(myfun_add_two.__doc__)
Output:
7
adding two numbers functions
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.1.py)
In the preceding example, we can see that a function my_fun_add_two is
defined using the def keyword. The function has 2 arguments: a and b. A
documentation string about this function is written in triple inverted commas.
Addition of 2 values a and b is returned. The function name my_fun_add_two
is called with the appropriate parameters 3 and 4. At the end, we are
displaying the docstring using __doc__ attribute of the function. The output
after the execution of the preceding code is self-explanatory.
If we will be defining the function name after calling, then the error will be
displayed as the function name is not defined. Refer to the following
program:
print(myfun_add_two(3,4))
print(myfun_add_two.__doc__)
def myfun_add_two(a,b):
''' adding two numbers functions'''
return a + b # return is optional you can even write print here
only.
Output:
print(myfun_add_two(3,4))

NameError: name 'myfun_add_two' is not defined
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.2.py)
The function works as follows in Python:
def func_name():
Function types
There are 2 types of function that Python supports.
Built in functions
The functions that are built into Python and comes along with the software
automatically are called built in functions or pre-defined functions. These
built-in functions can be used in our code according to the requirements, as
shown in the following Table 6.1:
abs()
all()
any()
ascii()
bin()
bool()
bytearray()
bytes()
callable()
chr()
classmethod()
compile()
complex()
delattr()
dict()
dir()
divmod()
enumerate()
eval()
exec()
filter()
float()
format()
frozenset()
getattr()
hasattr()
hash()
help()
hex()
id()
input()
int()
isinstance()
issubclass()
iter()
len()
list()
map()
max()
memoryview()
min()
next()
object()
oct()
open()
ord()
pow()
print()
property()
range()
repr()
reversed()
round()
set()
setattr()
slice()
sorted()
str()
sum()
super()

tuple()
type()
vars()
zip()
_ 
_import 
_
_()
Table 6.1: Built-in functions in Python
User defined functions
The functions which are explicitly defined by the programmer to perform
certain specific task as per need, is termed as user-defined functions. The
user-defined function could be a library function to someone else (Library
functions are written by others and we are using them in the form of library).
With the help of user-defined function, programmer can decompose a large
program into smaller segments for better understanding and debugging.
There can be no repetition of the codes as we can execute such codes by
calling them on function. There can be multiple number of people working on
a single project. So, a large project can be divided by making different
functions. Thus, the advantages of these functions help us to reach to our
business requirement as early as possible.
The syntax to create user-defined functions is as follows:
def functionname(parameters):
''' docstring '''
Code 1
Code 2
return value
So, while creating functions, 2 keywords are used. The first keyword is def
which is mandatory and another keyword is return, which is optional. If we
are not returning any value, then default value is None. Moreover, we can
return multiple values from a function in Python. Just observe the following
example:
def my_mult(num1, num2):
''' The above user defined function will multiply 2 numbers and
return their product'''
return num1 * num2
my_result = my_mult(3,6)
print("The product of 2 numbers 3 and 6 is: ", my_result)
Output:
18
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:

Chap06_Example6.3.py)
The function my_mult() will multiply 2 numbers and return the result. It is
always a better practice to name functions according to the task we perform.
Moreover, we can see that the print() is a built-in function. So, it is a choice
of the programmer to make user-defined functions as per the requirement.
Function arguments
Arguments are input to the function which are passed during function call.
But before discussing about types of arguments, let us see view about formal
and actual arguments.
Formal arguments are the arguments which come into action when we are
defining a function. On the other hand, actual arguments are the arguments
which come into action when we are calling a function.
In the example discussed as follows, num1 and num2 are the formal arguments
and “3,6” are the actual arguments.
def my_add(num1, num2):
''' The above user defined function will add 2 numbers and
return the result'''
return num1 + num2
my_result = my_add(3,6)
print("The addition of 2 numbers 3 and 6 is: ", my_result)
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.4.py)
There are different ways in which a function can be defined, which can take
variable number of arguments. We can also say different types of actual
arguments.
Positional arguments
The arguments passed to the function in correct positional order are called
positional parameters. The ‘nth’ positional arguments always need to be listed
at nth position when the function is called. Whenever the function is called,
the first positional argument will always be listing first, the second positional
argument will be listing second and so on. The arguments number and their
positions in the function definition must be equal to the arguments number

and position in the function call. If we change the order, there are chances
that the result may change.
Refer to the following program:
def my_complex(my_real, my_imag):
my_result = complex(my_real,my_imag)
return my_result
print(my_complex(6,8)) # P1
print(my_complex(8,6)) # P2
print(my_complex(8,6,10)) # P3
Output:
(6+8j)
(8+6j)
TypeError: my_complex() takes 2 positional arguments but 3 were
given
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.5.py)
In P1, the actual arguments 6 and 8 are passed to the function
my_complex(my_real, my_imag). The values 6 will be listed first in my_real
and 8 will be listed second in my_imag. A complex number is created using
the arguments and the result is returned and displayed. So, output will be 6 +
8j.
In P2, the actual arguments 8 and 6 are passed to the function
my_complex(my_real, my_imag). The values 8 will be listed first in my_real
and 6 will be listed second in my_imag. A complex number is created using
the arguments and the result is returned with change of order as compared to
P1. Hence, output will be 8+6j.
In P3, the formal arguments are 2 only but the actual arguments which we are
passing to the function is 3. So, Python will generate TypeError :
my_complex() which takes 2 positional arguments, but 3 were given.
An important point to note is that we can also pass positional arguments to
function using an iterable object such as list, tuple, set and so on, as shown in
the following program:
my_list = [5,3]
print(pow(*my_list)) # F1
my_tuple = (3,4)
print(complex(*my_tuple)) # F2

import math
my_set = {4}
print(math.sqrt(*my_set)) # F3
Output:
125
(3+4j)
2.0
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.6.py)
In F1, the iterable list is preceded by * and power of 2 numbers is calculated.
Hence, output will be 5**3 = 125.
In F2, the iterable tuple is preceded by * and complex number is returned
where the real part will be the first element and the imaginary part is the
second element. Hence, output will be 3 +4j.
In F3, the iterable set is preceded by * and the square root of the element
inside set is being calculated which is 4. Hence, output will be 2.0 as the
return value will be of float type.
Keyword arguments
The arguments passed to the function as name-value pair such that the
keyword arguments can identify the formal arguments by their names is
called keyword arguments. It is important to match the keyword argument’s
name and formal argument’s name. The order of one keyword argument
compared to another keyword argument does not matter. But the number of
arguments must be matched. Refer to the following program:
def my_complex(my_real, my_imag):
my_result = complex(my_real,my_imag)
return my_result
print(my_complex(my_real = 2,my_imag = 8)) # K1
print(my_complex(my_imag = 8, my_real = 2)) # K2
print(my_complex(2,my_imag = 8)) # K3
Output:
(2+8j)
(2+8j)
(2+8j)

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.7.py)
In K1, the keyword arguments my_real is assigned with the value 2 and
my_imag is assigned with the value 8. The formal argument my_real will have
value as 2 and my_imag as value 8. The complex number is created and
returned. So, output will be 2 + 8j.
In K2, the order of keyword argument is different than K1. However, still the
formal argument my_real will have value as 2 and my_imag as value 8. The
complex number is created and returned. So, output will be same as K1
which is 2 + 8j.
In K3, both positional and keyword arguments are used simultaneously.
However, positional arguments are taken first, followed by keyword
arguments. Otherwise, Python will raise an error. Here, the value 2 will be
assigned to my_real, followed by keyword argument my_imag which is 8. The
complex number is created and returned. So, output will be same as K1
which is 2 + 8j.
Refer to the following program:
def my_complex(my_real, my_imag):
my_result = complex(my_real,my_imag)
return my_result
print(my_complex(my_imag = 8, 2))
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.8.py)
In the preceding example, Python will raise SyntaxError: positional
argument follows keyword argument. Hence, never try to make this
mistake.
An important point to note is that we can also pass keyword arguments to
functions using a Python dictionary, as shown in the following program:
my_dict = {'real': 6, 'imag': 8}
print(complex(**my_dict))
Output:
6+8j
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:

Chap06_Example6.9.py)
In the preceding example, my_dict is the name of the dictionary containing
keywords (real,imag) and values (6,8) preceded by ** character. Hence,
output will be 6 + 8j.
Default arguments
Many a times, there may be cases when the default value is mentioned to the
formal argument in the function definition and there is no requirement to
provide actual argument. So, in such cases, the default argument will be used
by the formal argument. The formal argument will use default value if the
actual argument is not provided for the formal argument explicitly while
calling the function. If we provide actual argument, then it will use the
provided value. Refer to the following example:
def my_details(name,age):
print(f'My name is {name} and age is {age} ')
def my_details1(name,age = 31):
print(f'My name is {name} and age is {age} ')
my_details('Mukesh',31) # D1
my_details1(name = 'Mukesh') # D2
my_details1('Ramesh',32) # D3
Output:
My name is Mukesh and age is 31
My name is Mukesh and age is 31
My name is Ramesh and age is 32
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.10.py)
In D1, actual arguments are passed to the function my_details. These are
behaving like positional arguments. Hence, output will be My name is
Mukesh and age is 31.
In D2, the keyword argument name with value as ‘Mukesh’ is passed while
calling the function my_details1. But the second argument is not provided
for the formal argument explicitly. The default value of age will be 31.
Hence, output will be My name is Mukesh and age is 31.
In D3, the first argument ‘Ramesh’ is given and second argument is provided

with value 32 for the formal argument explicitly. Hence, output will be My
name is Ramesh and age is 32.
We should not take non-default arguments after default arguments, as shown:
def my_details2(age = 31, name):
print(f'My name is {name} and age is {age} ')
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.11.py)
In the above example, Python will raise SyntaxError: non-default
argument follows default argument.
Variable length arguments
Many a times while executing big projects, we will not know in advance, the
number of arguments which will be passed into a function. So, in Python,
there is something called the variable length arguments, that can accept any
number of values. An asterisk (*) symbol is used before the parameter name
to denote the preceding argument. Variable number of arguments can be
passed to a function by using special syntax *args. All the values are
represented in the form of a tuple. The number of arguments here will not be
maintained. We may use the for loop to retrieve all the arguments back. The
variable length arguments can be mixed with positional arguments. A non-
keyworded variable length argument list is passed. To current formal
arguments, any number of extra arguments can be tackled (including zero
extra arguments). If we are taking any other arguments after variable length
arguments, then values should be provided as keyword arguments. Refer to
the following program:
def mymul(*my_num):
myresult = my_num[0]*my_num[1]*my_num[2]
return myresult
def mymul2(first, *my_num):
myresult = first*my_num[0]*my_num[1]
return myresult
def mymul3(*my_num):
myresult = 1
for loop in my_num:
myresult *= loop
return myresult

print(mymul(2,3,4)) # V1
print(mymul(2,3,4,5)) # V2
print(mymul2(2,3,4)) # V3
print(mymul2(2,3,4,5)) # V4
print(mymul3(2,3,4,5)) # V5
Output:
24
24
24
24
120
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.12.py)
In V1, we are passing actual arguments 2,3 and 4 to the function mymul. We
are accessing the preceding arguments using index number. So, num[0] will
have value 2, num[1] as 3 and num[2] as 4. Multiplication of the preceding
values are done and the result is returned. The output is 24.
In V2, we are passing actual arguments 2, 3, 4 and 5 to the function mymul.
We are accessing the preceding arguments using index number. So, num[0]
will have value 2, num[1] as 3 and num[2] as 4. We are not accessing the
argument 5 using index number. It is completely the programmer’s choice.
Multiplication of the preceding values are done and the result is returned. The
output is 24.
In V3, we are passing actual arguments 2,3 and 4 to the function mymul2. The
value 2 will be accessed by formal argument first and 3,4 using index
number. Multiplication of the preceding values are done and the result is
returned. The output is 24.
In V4, we are passing actual arguments 2, 3, 4 and 5 to the function mymul2.
We are accessing the preceding arguments by formal argument first and 3,4
using index number using index number. So, formal argument first will have
value 2, num[0] as 3 and num[1] as 4. We are not accessing the argument 5
using index number. Multiplication of the preceding values are done and the
result is returned. The output is 24.
In V5, we are passing actual arguments 2, 3, 4 and 5 to the function mymul3. A
for loop is used to retrieve all the arguments back. Multiplication of the
preceding values are done and the result is returned. The output is 120.

Keyword variable length arguments (kwargs)
The arguments which can accept any number of values provided in the form
of key-value pair is called keyword variable length argument. The variable
length keyword argument dictionary is passed to function by Python using
**kwargs and on which dictionary operation can be performed. The double
asterisk sign ** is used before the parameter name to denote the above
argument. We will be passing the arguments as dictionary and these
arguments will make a dictionary inside function with the name same as
parameter name but excluding **. Both *args and **kwargs make the
function flexible. Refer to the following program:
def func1(**kwargs):
print(kwargs) # F1
print(type(kwargs)) # F2
for my_key,my_value in kwargs.items():
print(f"{my_key}:{my_value}") # F3
def func2(name1,**kwargs):
print(kwargs) # F4
print(name1) # F5
print(type(kwargs)) # F6
for my_key,my_value in kwargs.items():
print(f"{my_key}:{my_value}") # F7
def func3(**kwargs):
for my_key,my_value in kwargs.items():
print(f"{my_key}:{my_value}") # F9
func1(fname = "Saurabh",lname = "chandrakar", phone_number =
9876543210) # F10
func2(1,fname = "Priyanka",lname = "chandrakar", phone_number =
8987676543) # F11
#dictionary unpacking
d1 = dict(name ='Saurabh',age = 31)
func3(**d1) # F12
Output:
{'fname': 'Saurabh', 'lname': 'chandrakar', 'phone_number':
9876543210}
<class 'dict'>
fname:Saurabh
lname:chandrakar
phone_number:9876543210
{'fname': 'Priyanka', 'lname': 'chandrakar', 'phone_number':
8987676543}
1
<class 'dict'>

fname:Priyanka
lname:chandrakar
phone_number:8987676543
name:Saurabh
age:31
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.913py)
From F1 to F3, we have a function func1 with **kwargs as a parameter. The
dictionary with variable length argument F10 is being passed to the func1()
function. The variable length arguments passed and its type is displayed
followed by a for loop inside func1() function working on the data of
passed dictionary and printing the value of dictionary. Hence:
Output of F1 is:
{'fname': 'Saurabh', 'lname': 'chandrakar', 'phone_number':
9876543210}
Output of F2 is <class 'dict'>
Output of F3 is fname:Saurabh
lname:chandrakar
phone_number:9876543210
From F4 to F7, we are illustrating kwargs for variable number of keyword
arguments with one extra argument. We have a function func2 with name1,
and **kwargs as a parameter. The dictionary with variable length argument
F11 is being passed to the func2() function. Inside func2() function, we
have a for loop working on the data of extra argument, passed dictionary and
prints its value.
Hence,
Output of F4 is:
{'fname': 'Priyanka', 'lname': 'chandrakar', 'phone_number':
8987676543}.
Output of F5 is 1
Output of F6 is <class 'dict'>
Output of F7 is fname:Priyanka
lname:chandrakar
phone_number:8987676543
In F12, we have a function func3 with **kwargs as a parameter. The
dictionary with variable length argument F12 is being passed to the func3()
function. We are unpacking the dictionary. So, output will be:

name:Saurabh
age:31
Note: A group of statements is termed as functions.
A group of functions is termed as modules.
A group of modules is termed as package.
A group of package is termed as library.
Nested function
A Nested function or inner function or function nesting is the term used when
we define one function inside another function. We can access the variables
within the enclosing scope by using the inner function. We can create an
inner function to protect it from everything which is happening outside of the
function. This process is called as encapsulation and can be seen in the
following program:
def outside_func():
def inner_func():
print("Inside Inner Function")
print("Inside Outer Function")
inner_func()
outside_func()
Output:
Inside Outer Function
Inside Inner Function
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.14.py)ss
In the preceding example, 
inner_func() has been defined inside
outside_func(), thus making it an inner function. To call inner_func(), we
must first call outside_func(). The outside_func() will then go ahead and
call inner_func() as it has been defined inside it.
An important point to observe is that outside_func() has been called to
execute inner_func(). The inner_func() will never execute if the
outside_func() is not called. Just execute the following code:
def outside_func():
def inner_func():
print("Inside Inner Function")
print("Inside Outer Function")
inner_func()

Nothing will be returned by Python when executed.
We can also pass a parameter to the function:
def outside_func(str1):
def inner_func():
print(str1 + "Inner Function")
print("Inside Outer Function")
inner_func()
outside_func("Hello ")
Output:
Inside Outer Function
Hello Inner Function
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.15.py)
In the preceding example, we were passing a string parameter say “Hello” to
outside_func function. The string variable will be accessed inside
inner_func() as shown in the output.
We can change the variables of the outer function from inside the inner
function, as shown in the following program:
def outer(a):
b = 3
b += a
def inner(c):
b = 6
print(c**b)
print(b)
inner(3)
outer(1)
Output:
4
729
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.16.py)
In the preceding example, outer(1) function is called storing the value of a
as 1. The expression b+=a will yield the value of b as 4 and will depict a
variable defined within the outer() function. print(b) will display the value
of b of the outer function. A new variable ‘b’ is defined within the inner()

function rather than changing the value of ‘b’ of the outer() function.
Finally print(c **b) will provide us the result as 729 (3 **6).
Python closures
If there is a requirement of binding data to a function without passing them as
parameters, then it is called as closures. It will help to invoke function outside
their scope. It is a function object which remembers values in their enclosing
scopes, even if they are absent in memory, which means that we have a
closure when a nested function references a value which is in its enclosing
scope. To create a closure in Python, the following conditions are to be met:
A nested function must be present.
The nested function will refer to a variable defined in the enclosing
function.
The enclosing function should return the nested function.
Just observe the following example:
def outer_func(str1):
var1 = " is awesome"
def nested_func():
print(str1 + var1)
return nested_func
myobj = outer_func('Python')
myobj()
Output:
Python is awesome
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.17.py)
Till now, we have just seen calling the nested function inside the function. In
the preceding example, we have returned the nested function instead of
calling it. We have returned the whole functionality of the nested function
and bind it to a variable instead for further usage. The scope of
nested_func() is only inside outer_func() . But with the help of closures,
we have extended the scope and invoked it from outside its scope. The
Python Virtual Machine (PVM) will detect the dependency of nested
function on outer function, and will make sure that the variables in which the

nested function depends on, is available even if the outer function goes away.
So, the previous example will generate the output as Python is awesome.
The advantage of closures is that since they provide some sort of data hiding,
it helps to reduce the use of global variables. Closures prove to be effective
when we have few functions in our code. But we can go for class if we need
to have many functions.
There is a function which creates another object called factory functions.
The inner functions will help us in defining factory functions, as shown:
def outer(mynum):
def inner(a1):
return mynum ** a1
return inner
obj1 = outer(6)
obj2 = outer(5)
print(obj1(2))
print(obj2(3))
Output:
36
125
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.18.py)
In the preceding Python script, 2 objects are created from inner(a1)
function: obj1 and obj2 which makes inner(a1) a factory function, since it
generates the obj1 and obj2 functions for us, using the parameter we pass it.
Hence, the output displayed here will be (6**2) = 36 and 125 respectively.
Function passing as a parameter
Multiple arguments can be taken by a function. The arguments can be
objects, variables (of same or different data types) or functions. A function
which accepts other functions as arguments are called higher-order functions.
Refer to the following:
def myupper(mystr):
return mystr.upper()
def mylower(mystr):
return mystr.lower()
def world_virus(myfunc):

virus = myfunc("CoronA")
print(virus)
world_virus(myupper) # FF1
world_virus(mylower) # FF2
Output:
CORONA
corona
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.19.py)
In the preceding example, a function world_virus, is created which takes a
function as an argument.
In FF1, we are passing myupper as an argument to world_virus(myfunc)
function. myupper("CoronA") will be function called, which returns the string
value as “CORONA” and will be stored in a variable for displaying the output.
Hence, output will be “CORONA”.
In FF2, we are passing mylower as an argument to world_virus(myfunc)
function. mylower("CoronA") will be function called which returns the string
value as “corona” and will be stored in a variable for displaying the output.
Hence, output will be “corona”.
So, a function can also be passed as argument to another function.
Local, global, and non-local variables
We have unknowingly used local, global, and non-local variables in the past.
But it is the correct time to know what these variables are and how to use
them in our code.
Local variables
The variables which are declared inside a function and is not accessible
outside the function, is called local variables. The value of the local variable
is available only in that function itself and not outside of the function, as the
scope is limited to that function, where it is created. Just observe the
following Python script:
def func1(num2):
num1 = 1

print(num1)
print(num2 + num1)
func1(12)
print(num1)
Output:
1
13
NameError: name 'num1' is not defined
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.20.py)
In the preceding Python script, a local variable num1 is created by declaring a
variable inside the function. The local variable is used inside the function by
displaying it and adding it with the formal argument variable. Whenever we
are displaying the local variable outside its scope,
Python will result in NameError. In the preceding example, num1 is a local
variable for the func1() function and is not accessible outside of it. So,
Python raises NameError: name 'num1' is not defined.
Global variables
Whenever a variable is declared outside of the function, it is called as global
variable. These variables will be available to all the function which are
written after it. The scope of global variable will be the entire program body
written below it. Refer to the following Python script:
g1 = 1 # GL1
def display():
l1 = 2 # GL2
print(l1) # GL3
print(g1) # GL4
display()
print(g1) # GL5
print(l1) # GL6
Output:
2
1
1
NameError: name 'l1' is not defined

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.21.py)
In GL1, the variable g1 is assigned with value 1 and is a global variable.
In GL2, the variable l1 is assigned with value 2 and is a local variable.
In GL3, we are using local variable inside display() function.
In GL4, we are using global variable inside display() function.
In GL5, we are using global variable outside function.
In GL6, we are using local variable outside function and it will show
NameError.
We can access the global variable g1 as it has been defined out of a function.
A new local variable is created in the function’s namespace if another value
is assigned to a globally declared variable inside the function. The value of
the global variable will not be changed.
Refer to the following script:
g1 = 1
def display():
g1 = 2
print(g1)
print("inside",id(g1))
display()
print(g1)
print("outside",id(g1))
Output:
2
inside 140733773341360
1
outside 140733773341328
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.22.py)
In the preceding example, a new variable g1 is created inside the display()
function. We can see from the display of id(g1) inside the function which is
140733773341360. The global variable g outside the function has the id as
140733773341328 . Clearly, the 2 variables are having different ids.
Now, to change the global variable value from within a function, the global

keyword will be used. So, if there is any requirement of accessing the global
variable inside the function, it can be accessed using ‘global’ keyword
followed by variable name. Refer to the following code:
g1 = 1
def display():
global g1
g1 = 2
print(g1)
print("inside",id(g1))
display()
print(g1)
print("outside",id(g1))
Output:
2
inside 140733773341360
2
outside 140733773341360
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.23.py)
From the preceding Python script, we can see that the global variable g1
value has been modified from 1 to 2. Moreover, identity of the global
variable inside the function and outside the function remains same.
An important point to note is that whenever the name of global and local
variable is same, the function by default refers to local variable and ignores
the global variable. It is mandatory to reference the local variable before
assignment. Refer to the following code:
g1 = 1
def display():
g1 = g1 -1
print(g1)
display()
Output:
UnboundLocalError: local variable 'g1' referenced before
assignment
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.24.py)

There is something called globals() function which returns a table of global
variables in the form of dictionary. Using variable name as key, its value can
be accessed and modified. So, the preceding function will give the
programmer flexibility to use a global and local variable with the same name
simultaneously.
Refer to the following script:
num1 = 1
def display():
num1 = 2
print("local variable: ", num1)
num2 = globals()['num1']
print(num2)
num2 = 3
print(num2)
display()
print('global variable: ', num1)
Output:
local variable: 2
1
3
global variable: 1
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.25.py)
Here, we can see that the same variable name num1 is used both locally and
globally. The variable name num1 is used as key to access the global value
and stored in variable num2. So, num2 is assigned with value 1. Then we are
assigning new variable to num2 with value 3. The original global variable
num1 has value 1.
Non-local variables
The non-local variable will be used in nested functions whose local scope is
not defined, which means that the variable can neither be in the local or
global scope. Refer to the following program:
def outer():
a1 = 20
b1 = 40
def inner():
# nonlocal binding

nonlocal a1
a1 = 50 # will update
b1 = 60 # will not update,
# it will be considered as a local variable
inner()
print("a1 : ", a1)
print("b1 : ", b1)
# main code
# calling the function i.e. outer()
outer()
Output:
a1 : 50
b1 : 40
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.26.py)
In the preceding example, a1 and b1 are the variables of the outer() function
and in the inner() function, we are using the variable a1 as a non-local
variable. However, variable b1 is the local variable for inner() function, and
if the value of b1 has changed, then it will be considered a new assigned for
local variable (for inner() ) b1. So, a nonlocal keyword is used to create a
non-local variable. Hence, the output of the preceding Python snippet will be:
a1 : 50
b1 : 40
Recursive function
The process of defining itself is called recursion. So, a function which calls
itself is called recursive function. These recursive functions will reduce the
code length and improve readability. The complex problems can be solved
very easily by breaking down into simpler sub-problems. Sequence
generation is easier than using some nested iteration with recursion. But
recursive calls are inefficient as they take up a lot of memory and time. The
logic in recursion is quite hard to follow through, and hard to debug. The best
example in the real world is when we stand between 2 parallel mirrors facing
each other. Our face would be reflected recursively.
The best example that we have learned from our basic C language is to
calculate the factorial of a number. Refer to the following program:
def factorial(a):

if a == 1:
return 1
else:
return (a * factorial(a-1))
num = 7
print("The factorial of", num, "is", factorial(num))
Output:
The factorial of 7 is 5040
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.27.py)
In the preceding example, factorial is a recursive function which calls itself.
When the preceding function is called with a positive integer, it will
recursively call itself by decreasing the number. The recursive call is
explained as follows:
The recursion will end when the control reaches to the base condition, that is,
when the number reduces to 1.
It is mandatory to have the base condition when we are using recursive

function since it stops the recursion otherwise the function will call itself
infinitely.
Python Lambda functions
Till now, we have declared functions with some name given to it. However,
we can also declare a function without any name. Such type of functions
which are nameless, are called anonymous or lambda functions. Normal
functions are defined using the def keyword, whereas anonymous functions
are defined using lambda keyword. For one-time usage or for instant use, the
anonymous function comes into the picture. A lambda function can take any
number of arguments but can have only one expression. The syntax of
lambda function is as follows:
lambda arguments: expression
Here, lambda is a keyword that defines a lambda expression.
The second parameter arguments is a comma separated list of arguments as
found in the function definition (kindly note the lack of parenthesis).
The third parameter is a single Python expression which cannot be a
complete statement. The expression is returned after evaluation.
The : represents the function beginning. Lambda function returns a function.
There is no need to write return statement. All the type of actual arguments
can be used.
Here, the arguments can be many but the expression must be single. We can
use the lambda expression wherever function objects are required.
Lambda functions are used in built-in functions such as map, filter and
reduce. We will see the examples of each one for better understanding and
evaluation. Refer to the following program:
def add(x,y):
return x + y
print("Normal function: ", add(2,3)) # L1
add2 = lambda a,b: a+b # L2
print("Lambda function: ", add2(2,3))# L3
Output:
Normal function: 5
Lambda function: 5

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.28.py)
Both the normal and lambda functions will yield the same output.
In L1, we are calling the function with arguments 2 and 3 and returning the
output as 5. Hence, output will be Normal function: 5.
In L2, lambda a,b: a + b is the lambda function . We have given the
arguments a and b and the expression a + b gets evaluated and returned. The
preceding function has no name and returns a function object assigned to the
identifier add2.
So, in L3, the output will be Lambda function: 5.
Nested lambda functions
A lambda function written inside another lambda function is called nested
lambda functions. Observe the example shown:
#M-1
def mul1(a1):
return lambda b1:b1*a1
myresult = mul1(3)
print(myresult(7))
#M-2
mul = lambda a = 3: (lambda b: a*b)
myres = mul()
print(myres)
print(myres(7))
Output:
21
<function <lambda>.<locals>.<lambda> at 0x00000238D3128BF8>
21
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.29.py)
In M1, lambda appears inside a function mul1 and the value can be accessed
that the argument a1 has in the function’s scope at the time when we are
calling enclosing function. So, a1 value will be 3 when mul1(3) is being
called. myresult is now a function object and when calling the preceding
function with argument 7, the b1 value will 7. Hence, the output 7*3 = 21 is

returned.
In M2, lambda can access the names in the enclosing lambda. Here, lambda
structure is nested to make a function that makes a function when called. The
preceding approach is quite convoluted and should be avoided. Moreover, the
function object myres is printed which yields output:
<function <lambda>.<locals>.<lambda> at 0x00000238D3128BF8>
The overall output using the preceding approach yields value 21 as M1.
Passing lambda functions to another function
Lambda function can be passed as an argument to another function. Let us
see an example.
def mypow(num):
print(num)
print(num(3))
mypow(lambda a: a**4)
Output:
<function <lambda> at 0x0000027C9D527AE8>
81
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap06_Example6.30.py)
In the preceding example, we are passing the lambda function as an argument
in the function call. So, num is now a function argument which is displayed.
The value 3 is passed as a parameter to variable a. Hence, the output will be
3**4 = 81.
Conclusion
Thus, in the first half of this chapter, we initially witnessed the concept of
functions with its syntax. Then we saw various built-in functions, followed
by an example of user defined functions. We saw important concept of
function arguments which are positional arguments, keyword arguments,
default arguments, *args and **kwargs. Then we defined one function inside
another function which is nested function. We also saw the requirement of
binding data to a function without passing them as parameters, called Python
closures. The usage of local, global, and non-local variables was also

illustrated. The best example of factorial was seen using recursive function.
Finally, we touched on the concept of Python lambda function with various
Python examples.
Points of remember
Functions must be defined initially before being later called in Python
with proper indentation.
Built-in functions are the functions that are already built in Python,
whereas user defined functions are explicitly defined by the
programmer to perform specific task as per need.
Arguments which come into action when we are defining a function are
called formal arguments, whereas arguments which come into action
when we are calling a function is called actual arguments.
Positional arguments are the arguments passed to the function in the
correct positional order. Keyword arguments are the arguments passed
to the function as name-value pair, such that the keyword arguments can
identify the formal arguments by their names. The default value will be
used by the formal argument if the actual argument is not provided for
the formal argument explicitly while calling the function.
We can pass the variable number of arguments to a function by using
special syntax *args. When used as a function parameter, *args gathers
all the function’s unmatched positional arguments into a single tuple.
When a function’s **kwargs parameter is specified, all the function’s
unmatched keyword arguments are collected into a dictionary (where
the parameter name is the key).
We can bind the data to a function without passing them as parameters
called closures.
Variables defined inside a function but not accessible outside the
function, are called local variables. Variables declared outside of the
function are called global variables. When the variable is neither in
local or global scope, then it is called non-local variables.
Normal functions are defined using def keyword, whereas anonymous
functions are defined using lambda keyword.

Questions
1. Explain the concept of functions in Python with its syntax and example.
2. How many built-in functions are there in Python?
3. Explain user defined function with an example.
4. Explain the concept of positional, keyword, default, variable length
arguments and keyword variable length arguments with a Python
snippet code.
5. What are nested functions in Python?
6. What are Python closures? Explain with a Python snippet code.
7. Explain the concept of functions passing as a parameter with a Python
snippet code.
8. Explain the concept of local, global, and non-local variables in Python
with an example.
9. What are recursive functions in Python? Explain with a Python snippet
code.
10. What are Python lambda functions? Explain with a Python snippet code.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 7
Concept of Data Structures in Python
Introduction
A way of organizing and storing data in order such that it can be accessed and
modified efficiently, iscalled data structures. There is always a provision for
data structures in every programming language. We have seen some primitive
data types such as strings, integers, Boolean and float. Now, we will study
some non-primitive inbuilt data structures such as list, tuple, set, dictionary,
files and arrays. Each of these data structures are unique on its own. These
data structures are an indispensable part in programming. Without these data
structures, we cannot think of writing any Python program. Let us see some
of these data structures one by one.
Structure
In thischapter, we will discuss the following topics:
List data structure
Tuple data structure
Set data structure
Dictionary data structure
Objectives
By the end of thischapter, the reader will have an idea about 4 data structures,
viz, list, tuple, set and dictionary creation, as well as the elements accessing
using indexing and slicing except for set, list, set, and dictionary
comprehension using for loops, if/if-else/nested if statement. We shall
also see which data structures are mutable, whose insertion order is
preserved, and whose heterogenous objects are allowed with a Python snippet
code.

List data structure
A list can store different types of elements. It represents a group of elements;
heterogeneous objects are allowed. List is dynamic as the size can be
increased or decreased based on our requirement. We can modify the element
in a list as it is mutable. Here, duplicate objects are allowed. In lists, the
insertion order is preserved by using index. Duplicate elements are
differentiated by using index in list. So, index play a vital role. All the
elements in a list are separated by comma and are placed within square
brackets. So, whenever there is a requirement to represent a group of
individual objects as a single entity where we need to preserve the insertion
order and duplicate objects are allowed, we should go for lists.
Creating a list
The syntax of list object creation is as follows:
listname = [element1, element2, element3, …]
For example: myl1 = [10, 20, -30.1, 'Hello']
The preceding example creates a list object containing positive numbers,
negative numbers, string and so on. We can either create a list object with
integer numbers, float numbers, or string, depending on our need and
requirement.
Creating an empty list
The syntax of empty list creation is as follows:
listname = []
myl1 = []
print(myl1) # L1
print(type(myl1)) #L2
Output:
[]
<class 'list'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.1.py)
In L1, myl1 is an empty list.

In L2, myl1 object is of type list.
Creating a list when elements are known
If we already know the elements in a list, then it can be created as shown:
myl1 = [1,2,3,4,5]
Creating a list with dynamic input
The list elements will be provided from the command prompt, as shown:
mylist = eval(input("Enter the list: "))
print(mylist) # LI1
print(type(mylist)) # LI2
Output:
Enter the list: [1,2,3,4,5]
[1, 2, 3, 4, 5]
<class 'list'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.2.py)
In the preceding example, user is prompted to enter the list:
In LI1, the user entered the list as [1,2,3,4,5]
In LI2, mylist object is of type list.
List creation using list() function
For a given sequence, we can provide either set, string, range, and so on, as
shown here:
mylist = list(range(1,10,2))
print(mylist)# LS1
print(type(mylist))# LS2
Output:
[1, 3, 5, 7, 9]
<class 'list'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.3.py)

Here, the sequence is a range function with values start as 1, stop as 10 and
step as 2. It isconverted into a list object using list(). So, output of LS1 is
[1, 3, 5, 7, 9].
In LS2, mylist object is of type list.
List creation using split() function
In Python, string to list conversion is possible, as shown:
st1 = "Python is awesome"
mylist = st1.split(' ')
print(mylist) # SP1
print(type(mylist))# SP2
Output:
['Python', 'is', 'awesome']
<class 'list'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.4.py)
In SP1, the string isconverted into list object. Hence, output is ['Python',
'is', 'awesome'].
In SP2, mylist object is of type list.
Lists versus immutability
Once we have created a list object, the contentscan be modified. So, list
objects are mutable, as shown:
myl1 = [11,12,13,14]
print(myl1)# MU1
myl1[1] = 20
print(myl1)# MU2
Output:
[11, 12, 13, 14]
[11, 20, 13, 14]
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.5.py)
In MU1, the list elements are displayed as [11, 12, 13, 14].

In MU2, we have modified the element at index/position 1 to 20. Hence, output
after the modification will be [11, 20, 13, 14].
Accessing elements of list
The list elementscan be accessed by using index or by using slicing operator.
By using index
The position number of a list element will be represented by an index. The
index will be written inside square brackets and starts from 0 onwards.
For example: myl1 = [10, 20, -30.1, 'Hello']
Positive indexing
The positive index means from left to right. From the preceding example, the
positive index numbering is as shown in Table 7.1:
list object with index
Element
myl1[0]
10
myl1[1]
20
myl1[2]
-30.1
myl1[3]
Hello
Table 7.1: Positive indexing
Negative indexing
The negative index implies right to left. From the preceding example, the
negative index numbering is as shown Table 7.2:
list object with index
Element
myl1[-4]
10
myl1[-3]
20
myl1[-2]
-30.1
myl1[-1]
Hello
Table 7.2: Negative indexing
Refer to the following program:

myl1 = [10, 20, -30.1, 'Hello']
print(myl1[3])# LI1
print(myl1[-1])# LI2
print(myl1[4])# LI3
Output:
Hello
Hello
IndexError: list index out of range
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.6.py)
In LI1, the element at index/position 3 is Hello.
In L12, the element at index/position -1 is Hello.
In LI3, the index/position 4 is unavailable as there are only 4 elements.
Hence, Python will raise IndexError : list index out of range.
By using index and for loop
The elements of list can be accessed using index and for loop as shown:
myl1 = [10, 20, -30.1, 'Hello']
list_length = len(myl1)
for loop in range(list_length):
print(loop, myl1[loop])
Output:
0 10
1 20
2 -30.1
3 Hello
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.7.py)
In the preceding example, the number of elements in a list is returned and is
iterated using a for loop. The index number along with the element will be
displayed.
Here, we are sequentially accessing each element of the list which iscalled as
traversal. The elements are accessed using for loop by using index.

By using Index and while loop
The elements of list can be accessed using index and while loop as shown:
myl1 = [10, 20, -30.1, 'Hello']
list_length = len(myl1)
count = 0
while count<list_length:
print(count, myl1[count])
count +=1
Output:
0 10
1 20
2 -30.1
3 Hello
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.8.py)
In the preceding example, the number of elements in a list is returned to a
variable list_length. The condition for the while loop will be checked
whether the counter value is less than list_length. If found True, then the
index number along with the element will be displayed. The elements are
accessed using while loop by using index.
By using list slicing
The list elementscan also be accessed using list slicing. The syntax of list
slicing is:
myl1 = listname[start:stop:step]
Here, start indicates the index where slice has to start and has default value
as 0. stop indicates the index where slice has to end and the default value
will be list length. step is the incremental value and has default value as 1.
Refer to the following code:
myl1 = [10, 20, -30.1, 'Hello', 34.1, True]
# displaying list
print("myl1: ", myl1)
# displaying 4 elements from starting
print("myl1[:4]: ", myl1[:4])
# displaying all elements from the index 1
print("myl1[1:]: ", myl1[1:])
# displaying the elements between index 3 to 5

print("myl1[3:5]: ", myl1[3:5])
# displaying the elements between index 1 to 4
print("myl1[1:4]: ", myl1[1:4])
# displaying elements in the reverse order
print("myl1[ : : -1]: ", myl1[ : : -1])
Output:
myl1: [10, 20, -30.1, 'Hello', 34.1, True]
myl1[:4]: [10, 20, -30.1, 'Hello']
myl1[1:]: [20, -30.1, 'Hello', 34.1, True]
myl1[3:5]: ['Hello', 34.1]
myl1[1:4]: [20, -30.1, 'Hello']
myl1[ : : -1]: [True, 34.1, 'Hello', -30.1, 20, 10]
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.9.py)
List comprehension
List comprehension is a method to create a new list from an iterable object
that satisfy a given condition. It starts with [ and ends with ] to ensure that
the result must be a list. A list comprehension must consist of the following
parts:
Output expression
Input sequence
A variable representing a member of input sequence
An optional predicate part
For example: [a**3 for a in range(1,15) if a%2 == 0]
Here,
a**3 is an output expression.
range(1,15) is an input sequence.
a is a variable.
if a%2 == 0 is predicate part.
The syntax of list comprehension is:
list = [expression for item in iterable_object if condition]
There can be 0 or more if statements, and 1 or multiple for loops.

Just observe the following code.
List comprehension with for loop
Refer to the following snippet:
#code without list comprehension
myl1 = []
for loop in range(11):
myl1.append(loop **3)
print(myl1)
#code with list comprehension
lic1 = [loop **3 for loop in range(11)]
print(lic1)
Output:
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.10.py)
In code without list comprehension, an empty list is initially created and cube
of the first 10 numbers is added to the empty list.
In code with list comprehension, the output is same but in only one line, we
have achieved our result. The output expression is loop**3.
The variable is loop, and input expression is range(11).
List comprehension with for loop and if statement
Refer to the following snippet:
#code without list comprehension
myl1 = []
for loop in range(11):
if loop %2 == 0:
myl1.append(loop **3)
print(myl1)
#code with list comprehension
lic1 = [loop **3 for loop in range(11) if loop %2 == 0]
print(lic1)
Output:
[0, 8, 64, 216, 512, 1000]

[0, 8, 64, 216, 512, 1000]
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.11.py)
In code without list comprehension, an empty list is initially created and cube
of the first 10 even numbers is added to the empty list.
In code with list comprehension, the output is same but in only one line we
achieved our result. The output expression is loop**3.
The variable is loop, and an input expression is range(11).
if loop %2 == 0 is a predicate part.
List comprehension with for loop and nested if
statement
Refer to the following snippet:
#code without list comprehension
myl1 = []
for loop in range(21):
if loop %3 == 0:
if loop %4 == 0:
myl1.append(loop **3)
print(myl1)
#code with list comprehension
lic1 = [loop **3 for loop in range(21) if loop %3 == 0 if loop
%4 == 0]
print(lic1)
Output:
[0, 1728]
[0, 1728]
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.12.py)
In code without list comprehension, an empty list is initially created and cube
is found for the element divisible by 12, which is then added to the empty list.
In code with list comprehension, the output is same but in only one line we
achieved our result. The output expression is loop**3, the variable is loop

and an input expression is range(21).
if loop %3 == 0 if loop %4==0 is a predicate part.
List comprehension with if else statement and for loop
The syntax of list comprehension with if else statement and for loop is as
follows:
newlist = [expression if condition else statement for item in
iterable_object]
Refer to the following snippet:
#code without list comprehension
myl1 = []
for loop in range(11):
if loop %2 == 0:
myl1.append(loop **3)
else:
myl1.append(loop**2)
print(myl1)
#code with list comprehension
lic1 = [loop **3 if loop %2 == 0 else loop**2 for loop in
range(11)]
print(lic1)
Output:
[0, 1, 8, 9, 64, 25, 216, 49, 512, 81, 1000]
[0, 1, 8, 9, 64, 25, 216, 49, 512, 81, 1000]
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.13.py)
In code without list comprehension, an empty list is initially created and cube
for even numbers and square for odd numbers of the first 10 numbers is
added to the empty list.
In code with list comprehension, the output is same but in only one line we
achieved our result.
Nested list comprehension with for loop
The syntax of nested list comprehension with for loop is:
listname = [a*b for a in range(4,6) for b in range(3,5)]
Here, [a*b for a in range(4,6) is the outer for loop, and for b in

range(3,5) is the inner for loop.
Refer to the following loop:
#code without list comprehension
myl1 = []
for a in range(4,6):
for b in range(3,5):
myl1.append(a*b)
print(myl1)
#code with list comprehension
lic1 = [a*b for a in range(4,6) for b in range(3,5) ]
print(lic1)
Output:
[12, 16, 15, 20]
[12, 16, 15, 20]
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.14.py)
In code without list comprehension, nested for loops are used to produce an
output. However, in code with list comprehension, the same output is
produced in only one line.
Thus, we can say that comprehension requires lesscode and is faster than for
loop. Moreover, it can be used in places where for loop cannot be used.
Tuple data structure
Since we know about lists now, it is easy to discuss about tuple. Tuple is the
same as list, except that it is immutable. Once we create tuple object, no
changes are being performed on that object. So, we can say that it is a read
only version of list. If our data is fixed and no changes are to be done, then
we should go for tuple. Here, the insertion order is preserved and the
duplicate objectscan being differentiated by using index. So, index has a vital
role to play in tuple. Both positive and negative indexing is supported by
tuple. It occupies less memory ascompared to list. Tuple elements are
represented within parenthesis () and with comma separator. Parentheses are
optional but is recommended to use.
Refer to the following snippet:
t1 = 1,2,3,4
print(t1) # T1

print(type(t1)) # T2
t2 = (1,2,3,4)
print(t2) # T3
print(type(t2)) # T4
Output:
(1, 2, 3, 4)
<class 'tuple'>
(1, 2, 3, 4)
<class 'tuple'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.15.py)
In T1, we have not used parenthesis. The output is (1,2,3,4).
In T2, the type of t1 object is tuple.
In T3, parenthesis is used and output is (1,2,3,4).
In T4, the type of t2 object is tuple.
Tuple creation
A tuple can be created in following ways.
An empty tuple creation
The syntax is:
tuplename()
Refer to the following snippet:
t1 = ()
print(t1) # ET1
print(type(t1)) # ET2
Output:
()
<class 'tuple'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.16.py)
In ET1, the tuple is empty.

In ET2, the type of t1 object is tuple.
Single valued tuple creation
A tuple can be created by writing elements separated by commas inside
parenthesis. For a single valued tuple object creation, parenthesis is optional
but should end with comma.
A special care is taken when writing single value tuple. The value should end
compulsorily with comma. Otherwise, it is not treated as tuple as shown:
i1 = (20)
print(i1) # TI1
print(type(i1)) # TI2
t1 = (20,)
print(t1) # TI3
print(type(t1)) # TI4
Output:
20
<class 'int'>
(20,)
<class 'tuple'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.17.py)
In TI1, the output is 20.
In TI2, the type of i1 object is integer.
In TI3, the output is (20,).
In TI4, the type of t1 object is tuple.
The preceding example depicts the importance of comma when only single
element is present in a tuple.
Multiple valued tuple creation
For multiple valued object creation, parenthesis is optional.
The element can be of same data type or different one, depending on the
need, as shown:
t1 = (1,2,3,4)
t2 = (1,1,1,True, 'python')

print(t1)
print(t2)
print(type(t1))
print(type(t2))
Output:
(1, 2, 3, 4)
(1, 1, 1, True, 'python')
<class 'tuple'>
<class 'tuple'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.18.py)
Using tuple() function
Using tuple() function, an object can be converted into tuple as shown:
l1 = [1,2,3,4]
print(tuple(l1))
print(type(tuple(l1)))
t2 = tuple(range(1,9,2))
print(t2)
print(type(t2))
Output:
(1, 2, 3, 4)
<class 'tuple'>
(1, 3, 5, 7)
<class 'tuple'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.19.py)
Accessing elements of tuple
The tuple elementscan be accessed by using index or by using slicing
operator.
By using index
The position number of a tuple element will be represented by an index. The
index will be written inside parenthesis and starts from 0 onwards.

For example: myt1 = (10, 20, -30.1, 'Hello')
Positive indexing
The positive index means from left to right. From the preceding example, the
positive index numbering is as shown in Table 7.3:
list object with index
element
myt1[0]
10
myt1[1]
20
myt1[2]
-30.1
myt1[3]
Hello
Table 7.3: Positive indexing
Negative indexing
The negative index means from right to left. From the preceding example, the
negative index numbering is as shown in Table 7.4:
list object with index
element
myt1[-4]
10
myt1[-3]
20
myt1[-2]
-30.1
myt1[-1]
Hello
Table 7.4: Negative indexing
Refer to the following snippet:
myt1 = (10, 20, -30.1, 'Hello')
print(myt1[3])# LI1
print(myt1[-1])# LI2
print(myt1[4])# LI3
Output:
Hello
Hello
IndexError: tuple index out of range
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.20.py)

In LI1, the element at index/position 3 is Hello.
In L12, the element at index/position -1 is Hello.
In LI3, the index/position 4 is unavailable as there are only 4 elements.
Hence, Python will raise IndexError : tuple index out of range.
By using index and for loop
The elements of tuple can be accessed using index and for loop as shown:
myt1 = (10, 20, -30.1, 'Hello')
tuple_length = len(myt1)
for loop in range(tuple_length):
print(loop, myt1[loop])
Output:
0 10
1 20
2 -30.1
3 Hello
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.21.py)
In the preceding example, the number of elements in a tuple is returned and is
iterated using a for loop. The index number, along with the element, will be
displayed.
Here, we are sequentially accessing each element of the tuple. The elements
are accessed using the for loop by using index.
By using index and while loop
The elements of tuple can be accessed using index and while loop as shown:
myt1 = [10, 20, -30.1, 'Hello']
tuple_length = len(myt1)
count = 0
while count<tuple_length:
print(count, myt1[count])
count +=1
Output:
0 10
1 20

2 -30.1
3 Hello
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.22.py)
In the preceding example, the number of elements in a tuple is returned to a
variable tuple_length. The condition for while loop will be checked, that
whether the counter value is less than tuple_length. If found True, then the
index number along with the element will be displayed. The elements are
accessed using while loop, by using index.
By using tuple slicing
The tuple elementscan also be accessed using tuple slicing. The syntax of
tuple slicing is:
myt1= tuplename(start:stop:step)
Here, start indicates the index where slice has to start and has default value
as 0. stop indicates the index where slice has to end and the default value
will be list length. step is the incremental value and has default value as 1.
Refer to the following code:
myt1 = (10, 20, -30.1, 'Hello', 34.1, True)
# displaying tuple
print("myt1: ", myt1)
# displaying 4 elements from starting
print("myt1[:4]: ", myt1[:4])
# displaying all elements from the index 1
print("myt1[1:]: ", myt1[1:])
# displaying the elements between index 3 to 5
print("myt1[3:5]: ", myt1[3:5])
# displaying the elements between index 1 to 4
print("myt1[1:4]: ", myt1[1:4])
# displaying elements in the reverse order
print("myt1[ : : -1]: ", myt1[ : : -1])
Output:
myt1: (10, 20, -30.1, 'Hello', 34.1, True)
myt1[:4]: (10, 20, -30.1, 'Hello')
myt1[1:]: (20, -30.1, 'Hello', 34.1, True)
myt1[3:5]: ('Hello', 34.1)
myt1[1:4]: (20, -30.1, 'Hello')
myt1[ : : -1]: (True, 34.1, 'Hello', -30.1, 20, 10)

Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.23.py)
Tuple versus immutability
Once we have created a tuple object, the contentscannot be modified. So,
tuple objects are immutable, as shown:
myt1 = (11,12,13,14)
print(myt1)# MU1
myt1[1] = 20
print(myt1)# MU2
Output:
(11, 12, 13, 14)
TypeError: 'tuple' object does not support item assignment
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.24.py)
In MU1, the tuple elements are displayed as (11, 12, 13, 14).
In MU2, we are trying to modify the element at index/position 1 to 20. Since,
tuple objects are immutable, Python will raise TypeError: 'tuple' object
does not support item assignment.
Tuple comprehension
The tuple comprehension is not supported in Python. We will be getting
generator object instead of tuple object. The generator expression will be
producing one item at a time, as shown:
g1 = (x**2 for x in range(1,7))
print(type(g1))
for loop in g1:
print(loop)
Output:
<class 'generator'>
1
4
9
16
25

36
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.25.py)
List versus tuple comparison
The similarities between list and tuple are as follows:
Insertion order is preserved
Duplicate objects are allowed
Heterogeneous objects are allowed
Slicing and index are supported
The differences between list and tuple can be seen in the following Table 7.5:
SNo.
List
Tuple
1
It is a group of comma separated
values within square brackets.
Square brackets are mandatory.
For example: [1,2,3,4]
It is a group of comma separated
values 
within 
parenthesis.
Parenthesis is optional.
For example: 1,2,3,4
(1,2,3,4)
2
List objects are mutable, that is,
once a list object iscreated, any
changescan be performed in that
object.
Tuple objects are immutable, that
is, once a tuple object iscreated,
the contentscannot be modified.
3
We should use list when the
contents are not fixed and keep on
changing.
We should use tuple when the
contents are fixed and it never
changes.
4
List objectscannot be used as keys
for dictionaries because keys
should 
be 
immutable 
and
hashable.
Tuple objectscan be used as keys
for dictionaries because keys
should 
be 
immutable 
and
hashable.
Table 7.5: Differences between List and Tuple
Set data structure
An unordered collection of items is a set. In set, the order of elements is not

maintained. The elements may not appear in the same order as they are
entered in the set. Insertion order is not preserved but the elementscan be
sorted. In set, duplicates are not allowed. There is no provision of indexing
and slicing for the set. Heterogeneous elements are allowed in set. Once a set
object iscreated, any changescan be performed in that object based on need.
So, set is mutable. A set is represented within curly braces {} and with
comma separation. All the mathematical operations such as union,
intersection, difference and so on, can be applied on set objects.
Refer to the following snippet:
s1 = {1,2,3,4}
print(s1)
print(type(s1))
Output:
{1, 2, 3, 4}
<class ‘set’>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.26.py)
Set creation
For creating a set, all the items must be placed inside curly braces {}
separated by comma. No duplicate elements will be accepted by set.
A set object can be created using set() function. The syntax is:
set(iterable)
The iterable can be any sequence such as list, tuple, dictionary, or range, as
shown:
mys1 = set(range(1,10))
print(mys1) # S1
mys2 = set('python')
print(mys2) # S2
myl1 = [1,2,3,1,4,5]
mys3 = set(myl1)
print(mys3) # S3
myd1 = {'a': 1, 'b':2, 'c':3}
print(set(myd1)) # S4
Output:

{1, 2, 3, 4, 5, 6, 7, 8, 9}
{‘n’, ‘h’, ‘t’, ‘y’, ‘p’, ‘o’}
{1, 2, 3, 4, 5}
{‘b’, ‘c’, ‘a’}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.27.py)
In S1, the numbers from 1 to 9 will be the elements of set. Hence, output will
be {1, 2, 3, 4, 5, 6, 7, 8, 9}.
In S2, a set object will contain unordered elements as {‘n’, ‘h’, ‘t’, ‘y’, ‘p’,
‘o’}. The output may change on next run.
In S3, duplicate elements will be removed and a set object will contain
unordered unique elements as {1,2,3,4,5}.
In S4, dictionary can be created using set but only keys will remain after
conversion as the values are lost. Hence, output will be {'b', 'c', 'a'}
An empty set can be created using set() function, as shown:
mys1 = set()
print(mys1)
print(type(mys1))
Output:
set()
<class 'set'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.28.py)
We cannot write {} only for an empty set. It will be treated as dictionary, as
shown:
d1 = {}
print(d1)
print(type(d1))
Output:
{}
<class 'dict'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:

Chap07_Example7.29.py)
Set comprehension
In set comprehension, a new set iscreated from an iterable object which will
satisfy a given condition. The most important aspect of set comprehension is
that the elements are unique, unordered and cannot contain any duplicate that
returns a set. It usescurly brackets {}.
The syntax is:
new_set = {expression for item in iterable_object if statement}
There can be 0 or multiple if statements, and only 1 or multiple for loop
statements.
Set comprehension with for loop
Observe the following code:
#code without set comprehension
mys1 = set()
for loop in range(11):
mys1.add(loop **3)
print(mys1)
#code with set comprehension
mys2 = {loop **3 for loop in range(11)}
print(mys2)
Output:
{0, 1, 64, 512, 8, 1000, 343, 216, 729, 27, 125}
{0, 1, 64, 512, 8, 1000, 343, 216, 729, 27, 125}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.30.py)
In code without set comprehension, an empty set is initially created and cube
of first 10 numbers is added to the empty set one by one.
In code with set comprehension, the output is same but in only one line we
have achieved our result.
Set comprehension with for loop and if statement
Observe the following code:

#code without set comprehension
mys1 = set()
for loop in range(11):
if loop %2 == 0:
mys1.add(loop **3)
print(mys1)
#code with set comprehension
mys2 = {loop **3 for loop in range(11) if loop %2 == 0}
print(mys2)
Output:
{0, 64, 512, 8, 1000, 216}
{0, 64, 512, 8, 1000, 216}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.31.py)
In code without set comprehension, an empty set is initially created and cube
of first 10 even numbers is added to the empty set.
In code with set comprehension, the output is same but in only one line we
achieved our result.
Set comprehension with for loop and nested if statement
Observe the following code:
#code without set comprehension
mys1 = set()
for loop in range(21):
if loop %3 == 0:
if loop %4 == 0:
mys1.add(loop **3)
print(mys1)
#code with set comprehension
mys2 = {loop **3 for loop in range(21) if loop %3 == 0 if loop
%4 == 0}
print(mys2)
Output:
{0, 1728}
{0, 1728}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.32.py)

In code without set comprehension, an empty set is initially created and cube
is found for the element divisible by 12, which is then added to the empty set.
In code with set comprehension, the output is same but in only one line we
have achieved our result.
Set comprehension with if else statement and for loop
The syntax of set comprehension with if else statement and for loop is as
follows:
new_set = {expression if condition else statement for item in
iterable_object}
Refer to the following snippet:
#code without set comprehension
mys1 = set()
for loop in range(11):
if loop %2 == 0:
mys1.add(loop **3)
else:
mys1.add(loop**2)
print(mys1)
#code with set comprehension
mys2 = {loop **3 if loop %2 == 0 else loop**2 for loop in
range(11)}
print(mys2)
Output:
{0, 1, 64, 512, 8, 9, 1000, 49, 81, 216, 25}
{0, 1, 64, 512, 8, 9, 1000, 49, 81, 216, 25}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.33.py)
In code without set comprehension, an empty set is initially created and cube
for even numbers, and square for odd numbers of first 10 numbers, is added
to the empty set.
In code with set comprehension, the output is same but in only one line we
achieved our result.
Dictionary data structure
The data structures list, tuple and set are used to represent a group of

individual objects as a single entity. If we want to represent a group of
objects as key-value pairs, then we should go for dictionary. The features of
dictionary are as follows:
In dictionary, the duplicate keys are not allowed but the valuescan be
duplicated.
For both key and values, heterogeneous objects are allowed.
Insertion order is not preserved in dictionary.
It is an unordered collection and is mutable, as we can modify its items
without changing its identity.
The slicing and indexing concepts are not applicable in dictionary.
It is represented using curly bracket {}.
Some key rules
Before creating a dictionary, the following points must be take into
consideration while writing keys:
Keys must be unique.
If the same key is mentioned again, then the old key will be overwritten.
Key must be immutable such as an integer, string or tuple.
The list or dictionary cannot be used as keys.
Keys are case-sensitive. Say key name ‘k’ and ‘K’ are different.
Creation of an empty dictionary
An empty dictionary can be created by using 2 ways.
By using dict() function
Refer to the following program:
d1 = dict()
print(d1)
print(type(d1))
Output:
{}
<class 'dict'>

Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.34.py)
By using curly braces only
Refer to the following program:
d1 = {}
print(d1)
print(type(d1))
Output:
{}
<class 'dict'>
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.35.py)
Creation of a dictionary
A dictionary can be created in the form of key-value pairs where keys will
follow the rules as discussed and the valuescan be of any datatype and can be
duplicated. The syntax is:
dict1 = {key1: value1, key2: value2, …}
Refer to the following program:
d1 = {}
d1[1] = 'python'
d1[2] = 'is'
d1[3] = 'awesome'
print(d1) # DI1
d2 = {1: 'python',
2: 'is',
3: 'awesome'}
print(d2) # DI2
Output:
{1: 'python', 2: 'is', 3: 'awesome'}
{1: 'python', 2: 'is', 3: 'awesome'}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.36.py)

In DI1, first an empty dictionary iscreated and then the data entries are added
as d1[key] = value. A key name is referred to, inside square brackets. The
dictionary iscreated using key-value pair and the output is {1: 'python', 2:
'is', 3: 'awesome'}.
In DI2, it is assumed that the data is already known well in advance. So, it
iscreated with key-value pair. Hence, output is {1: 'python', 2: 'is', 3:
'awesome'}.
Refer to the following program:
d2 = {1: 'python',
2: 'is',
3: 'awesome',
3: 'True'}
print(d2)
Output:
{1: 'python', 2: 'is', 3: 'True'}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.37.py)
As we can see, the key value 3 is repeated. So, as per key rule, old key is
overwritten. Hence, the output is {1: 'python', 2: 'is', 3: 'True'}.
Accessing dictionary
The data can be accessed using keys. The value of a dictionary can be
accessed by referring to its key name inside square brackets.
For example: employee_details = {101: 'Ram', 102: 'Shyam', 103:
'Mohan'}
In the following Table 7.6, the values in the Key column are all employee
details:
Key
Value
101
Ram
102
Shyam
103
Mohan
Table 7.6: Employee details

Refer to the following snippet:
employee_details = {101: 'Ram', 102: 'Shyam', 103: 'Mohan'}
print(employee_details[101])
print(employee_details[102])
print(employee_details[103])
print(employee_details[104])
Output:
Ram
Shyam
Mohan
KeyError: 104
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.38.py)
We can see that the data has been accessed using key 101,102 and 103.
However, the specified key 104 was unavailable in the dictionary object. So,
Python raised KeyError.
We can prevent this by using the in operator as shown:
employee_details = {101: 'Ram', 102: 'Shyam', 103: 'Mohan'}
if 104 in employee_details:
print("Present")
else:
print("The key is not present")
Output:
The key is not present
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.39.py)
Another approach is by using get() method. It returns None instead of
KeyError, if the key is not found, as shown:
employee_details = {101: 'Ram', 102: 'Shyam', 103: 'Mohan'}
print(employee_details.get(104))
Output:
None
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.40.py)

In Python 2, there is something called has_key() function, which will check
whether the key is available or not. But it is available in Python 2 version and
has become obsolete in Python 3 version.
Accessing dictionary
The existing value of key can be modified by assigning a new value. If the
key is unavailable, then a new entry will be added to the dictionary having a
specified key-value pair. It may be added at any place in the dictionary as it is
an unordered collection. If key is available, then the old value will be
replaced with a new value as the value gets updated rather than adding a new
item.
Refer to the following program:
d1 = {1:'Sugandh', 2:'Divya', 3:'Mintoo'}
print(d1) # UD1
d1[4] = 'Neeharika'
print("After adding a key value pair")
print(d1) # UD2
print("After modifying the value")
d1[3] = 'Animesh'
print(d1) # UD3
Output:
{1: 'Sugandh', 2: 'Divya', 3: 'Mintoo'}
After adding a key value pair
{1: 'Sugandh', 2: 'Divya', 3: 'Mintoo', 4: 'Neeharika'}
After modifying the value
{1: 'Sugandh', 2: 'Divya', 3: 'Animesh', 4: 'Neeharika'}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.41.py)
In UD1, we are displaying the key-value pairs in the dictionary. The output is
{1: 'Sugandh', 2: 'Divya', 3: 'Mintoo'}.
In UD2, a key value-pair is added to the dictionary object since the key 4 was
unavailable. Hence, output is {1: 'Sugandh', 2: 'Divya', 3: 'Mintoo',
4: 'Neeharika'}.
In UD3, a key 2 is already present. So, the old value ‘Mintoo’ is replaced with
a new value ‘Animesh’. Hence, output is {1: 'Sugandh', 2: 'Divya', 3:
'Animesh', 4: 'Neeharika'}.

Deleting dictionary item
An item of dictionary or an entire dictionary can be deleted using the del
statement.
The syntax for deleting an item is:
del dictionaryname[key]
The syntax for deleting the entire dictionary is:
del dictionaryname
Refer to the following program:
d1 = {1:'Sugandh', 2:'Divya', 3:'Mintoo'}
print(d1) # D1
print("deleting an item from the dictionary…")
del d1[3]
print(d1) # D2
print("deleting an entire dictionary…")
del d1
print(d1) # D3
Output:
{1: 'Sugandh', 2: 'Divya', 3: 'Mintoo'}
deleting an item from the dictionary…
{1: 'Sugandh', 2: 'Divya'}
deleting an entire dictionary…
NameError: name 'd1' is not defined
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.42.py)
In D1, we are displaying the key-value pairs in the dictionary. Hence, output
is {1: 'Sugandh', 2: 'Divya', 3: 'Mintoo'}.
In D2, we are deleting a particular item from the dictionary. Hence, output is
{1: 'Sugandh', 2: 'Divya'}.
In D3, we are deleting the total dictionary itself. Now, we cannot access the
dictionary object d1. Hence, Python will raise NameError: name 'd1' is
not defined.
If the key is not available, then Python will raise KeyError.
Refer to the following program:
d1 = {1:'Sugandh', 2:'Divya', 3:'Mintoo'}
print("deleting a key from the dictionary…")

del d1[3]
print(d1)
print("deleting the same key again…")
del d1[3]
print(d1)
Output:
deleting a key from the dictionary…
{1: 'Sugandh', 2: 'Divya'}
deleting the same key again…
KeyError: 3
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.43.py)
Dictionary comprehension
The syntax is:
dictionary = {key:value for vars in iterable}
Dictionary comprehension with for loop
Let us see an example.
#code without dictionary comprehension
cube_dict = dict()
for mynum in range(1,6):
cube_dict[mynum] = mynum**3
print(cube_dict)
#code with dictionary comprehension
my_cube_dict_comp = {mynum: mynum**3 for mynum in range(1, 6)}
print(my_cube_dict_comp)
Output:
{1: 1, 2: 8, 3: 27, 4: 64, 5: 125}
{1: 1, 2: 8, 3: 27, 4: 64, 5: 125}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.44.py)
In code without dictionary comprehension, a dictionary cube_dict iscreated
with number-cube key/value pair.
In code with dictionary comprehension, a dictionary my_cube_dict_comp

iscreated in a single line.
We can also use dictionary comprehension with dictionary object.
Refer to the following program:
my_old_price = {'eggs': 0.8, 'chocos': 3, 'rice': 1}
dollar_to_indiancurrency = 75
my_new_price = {key: value*dollar_to_indiancurrency for (key,
value) in my_old_price.items()}
print(my_new_price)
Output:
{'eggs': 60.0, 'chocos': 225, 'rice': 75}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.45.py)
In the preceding example, we can see that we have retrieved the items price
in dollars and converted into Indian currency.
Dictionary comprehension with for loop and if
statement
The syntax is:
dictionary = {key:value for vars in iterable if condition}
Refer to the following program:
#code without dictionary comprehension
cube_dict = dict()
for mynum in range(1,6):
if mynum %2 == 0:
cube_dict[mynum] = mynum**3
print(cube_dict)
#code with dictionary comprehension
my_cube_dict_comp = {mynum: mynum**3 for mynum in range(1, 6) if
mynum %2 == 0}
print(my_cube_dict_comp)
Output:
{2: 8, 4: 64}
{2: 8, 4: 64}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.46.py)

We can see that only the items with even values will be added and itscube
will be calculated as value, due to if clause in the dictionary comprehension.
Dictionary comprehension with for loop and nested if
statement
Refer to the following program:
cube_dict = dict()
for mynum in range(1,21):
if mynum %2 == 0:
if mynum %3 == 0:
cube_dict[mynum] = mynum**3
print(cube_dict)
#code with dictionary comprehension
my_cube_dict_comp = {mynum: mynum**3 for mynum in range(1, 21)
if mynum %2 == 0 if mynum %3 == 0}
print(my_cube_dict_comp)
Output:
{6: 216, 12: 1728, 18: 5832}
{6: 216, 12: 1728, 18: 5832}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.47.py)
We can see that only the items with even values, that are further divisible by
3, will be added due to nested if clause in the dictionary comprehension.
Dictionary comprehension with if else statement and for
loop
The syntax is:
dictionary = {key:value if condition else statement for vars in
iterable}
Refer to the following program:
#code without dictionary comprehension
mydict_age = {'Ankt': 31, 'Saurabh': 32, 'Nilesh': 40, 'Mr.
Ben': 50}
cube_dict = dict()
for mynum in mydict_age:
if mydict_age[mynum]>35:

cube_dict[mynum] = 'old'
else:
cube_dict[mynum] = 'young'
print(cube_dict)
#code with dictionary comprehension
new_dict = {key: 'old' if value > 35 else 'young'
for (key, value) in mydict_age.items()}
print(new_dict)
Output:
{'Ankt': 'young', 'Saurabh': 'young', 'Nilesh': 'old', 'Mr.
Ben': 'old'}
{'Ankt': 'young', 'Saurabh': 'young', 'Nilesh': 'old', 'Mr.
Ben': 'old'}
Note: 
The 
preceding 
code 
iscovered 
in 
(Program 
Name:
Chap07_Example7.48.py)
In both the cases, a new dictionary will be created using dictionary
comprehension. The items those having value >35 are old, while others will
have the value of ‘young’.
Despite these advantages, dictionary comprehension must be carefully used
as it consumes more memory, makes the code run slow and decreases the
code readability.
Conclusion
In thischapter, we saw about 4 data structures viz list, tuple, set and
dictionary. We also saw how to create all these data structures, and how to
access these data structures wherever possible (except set). The difference
between list and tuple is well explained. We need to make sure that we use
the list or tuple correctly while creating big projects. List, set and dictionary
comprehension were also touched upon, using the for loop and if/if-
else/nested if statement.
Points of remember
List data structure allows heterogeneous objects. Its size is dynamic.
Element can be modified as it is mutable. Insertion order is preserved
using indexing. Both positive and negative indexing are supported. We
can differentiate duplicate elements using index. Representation: []

Tuple data structure allows heterogeneous objects. Its size is dynamic.
Element cannot be modified as it is immutable. Insertion order is
preserved using indexing. Both positive and negative indexing is
supported. We can differentiate duplicate elements using index.
Representation: ()
Set data structure is an unordered collection of items where order of
elements is not maintained. Heterogeneous elements are allowed.
Duplicates are not allowed. We can sort the elements. No provision of
indexing and slicing. Representation: {}
Whenever there is a requirement to represent group of objects using
key-value pairs, we need to choose dictionary. Here, duplicate keys are
not allowed but duplicate values are allowed. The heterogeneous objects
are allowed for both key and values. Insertion order is not preserved.
Slicing and indexing concepts are not applicable. Representation: {}
Questions (Long/Short/MCQs)
1. Explain different ways of creating a list with Python snippet code.
2. Explain different ways of accessing elements of list with Python snippet
code.
3. What is list comprehension? Explain different approaches of creating a
list using list comprehension with Python snippet code.
4. Explain the different ways of creating a tuple with Python snippet code.
5. Explain the different ways of accessing elements of tuple with Python
snippet code.
6. Explain list and tuple object with respect to immutability.
7. Compare list and tuple differences.
8. Explain different ways of creating a set with Python snippet code.
9. What is set comprehension? Explain different approaches of creating a
set using set comprehension with Python snippet code.
10. Explain different ways of creating a dictionary with Python snippet
code.
11. Explain different ways of accessing elements of dictionary with Python
snippet code.

12. What is dictionary comprehension? Explain different approaches of
creating a dictionary using dictionary comprehension with Python
snippet code.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 8
Concept of Packages in Python
Introduction
In this chapter, we shall discuss about packages. Package is an encapsulation
mechanism to group modules which are related to a single unit. It is a way of
structuring module namespace of Python, by using “dotted module names”.
So, X,Y means that Y is a sub module which is under package name X. It is a
collection of modules and packages. A package can contain subpackages. It is
a folder or directory. Just like modules can handle functions and namespace
in an effective way, Python packages can handle more than one module in a
structured way.
Structure
In this chapter, we will discuss the following topics:
Packages
Structure for package of Games
Using “import” in Packages
Using “from import” in Packages
Using “from import *” in Packages
Accessing Games package using different approaches
Objectives
By the end of this chapter, the reader will know about the main difference
between modules and packages and how to use Python. A package name
‘Games’ folder will be created, which will itself consist of 3 packages namely
Cricket (subpackage: India), Football and Kabaddi package. These packages
will consist of various submodules, which will be explained in this chapter.
We will be viewing different approaches of accessing the structure for

package of Games. In the end of this chapter, the reader will also understand
the approach to import one package module inside another package module.
Packages
The following Figure 8.1 depicts that a package can consist of modules and
packages. Modules in simple terms mean files and packages as folders.
However, every folder must contain a file called __init__.py, ensuring that
folder be treated as a Python package:

Figure 8.1: Package Overview
So, the package should contain a special file called __init__.py. This file
can be empty. It can also be an executable initialization code. Package
statements resolve naming conflicts, the components can be identified
uniquely, and the modularity of the application is improved providing
flexibility benefit in usage.
To create a package in Python, there are 3 basic steps which need to be

followed:
1. The first step is to create a folder and give it a package name, mainly
related to operation.
2. Then put the classes, variables and required functions in it.
3. The __init__.py file is created inside the folder to consider it as a
Python package.
Now, we will discuss a collection of modules and packages that are designed
for the Games.
In Figure 8.2, we have created a package named Games.
This package consists of following items:
Cricket package consisting of modules (othercountrybatsman.py and
othercountrybowler.py), 
package 
India 
(indianbatsman.py,
indianbowler.py and __init__.py) and __init__.py.
Football package consisting of modules (goalkeeper.py 
and
forward.py) and __init__.py.
Kabaddi package consisting of modules (raider.py and defender.py)
and __init__.py.
games.py.
__init__.py.
Refer to the following Figure 8.2:

Figure 8.2: Items under Games package
Structure for package of games
Now, we will see how to access the package.
Using “import” in Packages
The syntax is:
import packName.modName
Here, packName is the name of the package and modName is the module Name.
For example: import Cricket.othercountrybatsman
The Syntax is:
import packName.subPackName.modName

Here, packName is the name of the package, subPackName is package name
insidepack, and Name and modName is the module Name.
For example, import Cricket.India.indianbatsman
Accessing objects like variables, functions, classes, and
lists
The Syntax is:
packName.modName.funcName()
Here, packName is the name of the package, modName is the module Name and
funcName is the function Name.
For 
example:
Cricket.othercountrybatsman.name_othercountrybatsman()
The syntax is:
packName.subPackName.modName.funcName()
Here, packName is the name of the package, subPackName is package name
inside packName, modName is the module Name and funcName is the function
Name.
For example, Cricket.India.indianbatsman.name_indianbatsman()
Using “from import” in Packages
The syntax is:
from packName.modName import funcName,
Here, packName is the name of the package, modName is the module name and
funcName is the function name.
For 
example: 
from 
Cricket.othercountrybatsman 
import
name_othercountrybatsman.
The syntax is:
from packName.subPackName.modName import funcName
Here, packName is the name of the package, subPackName is package name
inside packName, modName is the module name and funcName is the function
name.
For 
example, 
from 
Cricket.India.indianbatsman 
import

name_indianbatsman.
Accessing objects like variables, functions, classes, and
lists
The Syntax is:
funcName()
Here, funcName is the function Name.
For example: name_othercountrybatsman()
The syntax is:
funcName()
Here, funcName is the function Name.
For example, name_indianbatsman()
Using “from import *” in Packages
If packages __init__.py code defines a list named __all__, it would take
into consideration module name list which should be imported when from
Cricket import * is encountered.
__all__ = ['othercountrybatsman',' othercountrybowler']
Now, we have made a folder name Games, under which different packages
(folders) have been made, along with module names, as shown in the Figure
8.3:

Figure 8.3: Games Package
The Cricket package has the modules and packages shown in Figure 8.4:
Figure 8.4: Cricket Package
India is a subpackage in the Cricket package, as shown in Figure 8.5:

Figure 8.5: India Package
The Football package has the following modules and package, as shown in
Figure 8.6:
Figure 8.6: Football Package
The Kabaddi package has the following modules and packages, as shown in
Figure 8.7:
Figure 8.7: Kabaddi Package
Note: The previous package example was compiled and run in the path

E:\python_progs\Games\ folder and the details were captured and presented
here. All the source code present in the code bundle is stored in the
respective folder of this chapter, and a separate Games folder is also present
for your practice. The reference of the program is mentioned against each
code. So, observe the pattern and behavior of the code and practice yourself.
Accessing games package using different approaches
We have made a module named “games.py”. First, we will see how to access
the module name of different packages and subpackages, such as Cricket,
India, Football and so on, using the previous file for cases from 1 to 24. The
code inside different module names and their functions are shown as follows.
Modulename: othercountrybatsman.py (Present in \Games\Cricket)
#Cricket Package --- othercountrybatsman module
def name_othercountrybatsman():
'''Other Country Batsman Names are'''
print("Other Country Batsman Function")
print("Batsman1: Mr. E")
print("Batsman2: Mr. F")
print()
Modulename: othercountrybowler.py (Present in \Games\Cricket)
#Cricket Package --- othercountrybowler module
def name_othercountrybowler():
'''Other Country Bowler Names are'''
print("Other Country Bowler Function")
print("Bowler1: Mr. G")
print("Bowler2: Mr. H")
print()
Modulename: indianbatsman.py (Present in \Games\Cricket\India)
#India subpackage ----- indianbatsmann module
def name_indianbatsman():
'''Indian Batsman Names are'''
print("Indian Batsman Function")
print("Batsman1: Mr. A")
print("Batsman2: Mr. B")
print()
Modulename: indianbowler.py (Present in \Games\Cricket\India)
#India subpackage --- indianbowler module
def name_indianbowler():

'''Indian Bowler Names are'''
print("Indian Bowler Function")
print("Bowler1: Mr. C")
print("Bowler2: Mr. D")
print()
Modulename: goalkeeper.py (Present in \Games\Football)
#Football Package --- goalkeeper module
def name_goalkeeper():
'''Football goalkeeper names are'''
print("GoalKeeper Function")
print("GoalKeeper1: Mr. R")
print("GoalKeeper2: Mr. S")
print()
Modulename: forward.py (Present in \Games\Football)
#Football Package --- forward module
def name_forward():
'''Football forward names are'''
print("Forward Function")
print("Forward1: Mr. T")
print("Forward2: Mr. U")
print()
Modulename: raider.py (Present in \Games\Kabaddi)
#Kabaddi Package --- raider module
def name_raider():
'''Kabaddi raider names are'''
print("Raider Function")
print("Raider1: Mr. W")
print("Raider2: Mr. X")
print()
Modulename: defender.py (Present in \Games\Kabaddi)
#Kabaddi Package --- defender module
def name_defender():
'''Kabaddi defender names are'''
print("Defender Function")
print("Defender1: Mr. Y")
print("Defender2: Mr. Z")
print()
Now, we will be viewing different cases of accessing multiple modules, using
the games.py file. We are writing different types of code, as shown below, in
different case scenarios.

games.py module and accessing othercountrybatsman module using
import only:
#games module
import Cricket.othercountrybatsman
Cricket.othercountrybatsman.name_othercountrybatsman()
Output: On running Python games.py from the console, we have:
Other Country Batsman Function
Batsman1: Mr. E
Batsman2: Mr. F
Note: The preceding code is covered in (Program Name:
Chap8_Example8.1.py)
In the previous code, we are accessing the othercountrybatsman
module of Cricket package from the file. Under this module, we are
accessing the name_othercountrybatsman function. So, output is
displayed as shown above.
games.py module and accessing othercountrybowler module using
import only:
#games module
import Cricket.othercountrybowler
Cricket.othercountrybowler.name_othercountrybowler()
Output: On running Python games.py from the console, we have:
Other Country Bowler Function
Bowler1: Mr. G
Bowler2: Mr. H
Note: The preceding code is covered in (Program Name:
Chap8_Example8.2.py)
In the previous code, we are accessing the othercountrybowler module
of Cricket package from the file. Under this module, we are accessing
the name_othercountrybowler function. So, output is displayed as
shown above.
games.py module and accessing indianbatsman module inside India
package using import only:
#games module
import Cricket.India.indianbatsman
Cricket.India.indianbatsman.name_indianbatsman()

Output: On running Python games.py from the console, we have:
Indian Batsman Function
Batsman1: Mr. A
Batsman2: Mr. B
Note: The preceding code is covered in (Program Name:
Chap8_Example8.3.py)
In the previous code, we are accessing the indianbatsman module
inside India subpackage of Cricket Package from the file. Under this
module, we are accessing the name_indianbatsman function. So,
output is displayed as shown above.
games.py module and accessing indianbowler module inside India
package using import only:
#games module
import Cricket.India.indianbowler
Cricket.India.indianbatsman.name_indianbowler ()
Output: On running Python games.py from the console, we have:
Indian Bowler Function
Bowler1: Mr. C
Bowler2: Mr. D
Note: The preceding code is covered in (Program Name:
Chap8_Example8.4.py)
In the previous code, we are accessing the indianbowler module inside
India subpackage of Cricket Package from the file. Under this
module, we are accessing the name_indianbowler function. So, output
is displayed as shown above.
games.py module and accessing goalkeeper module inside Football
package using import only:
#games module
import Football.goalkeeper
Football.goalkeeper.name_goalkeeper()
Output: On running Python games.py from the console, we have:
GoalKeeper Function
GoalKeeper1: Mr. R
GoalKeeper2: Mr. S

Note: The preceding code is covered in (Program Name:
Chap8_Example8.5.py)
In the previous code, we are accessing the goalkeeper module of
Football Package from the file. Under this module, we are accessing
the name_goalkeeper function. So, output is displayed as shown above.
games.py module and accessing forward module inside Football
package using import only:
#games module
import Football.forward
Football.forward.name_forward()
Output: On running Python games.py from the console:
Forward Function
Forward1: Mr. T
Forward2: Mr. U
Note: The preceding code is covered in (Program Name:
Chap8_Example8.6.py)
In the previous code, we are accessing the forward module of Football
Package from the file. Under this module, we are accessing the
name_forward function. So, output is displayed as shown above.
games.py module and accessing raider module Kabaddi package using
import inside only:
#games module
import Kabaddi.raider
Kabaddi.raider.name_raider()
Output: On running Python games.py from the console, we have:
Raider Function
Raider1: Mr. W
Raider2: Mr. X
Note: The preceding code is covered in (Program Name:
Chap8_Example8.7.py)
In the previous code, we are accessing the raider module of Kabaddi
Package from the file. Under this module, we are accessing the
name_raider function. So, output is displayed as shown above.

games.py module and accessing defender module inside Kabaddi
package using import only:
#games module
import Kabaddi.defender
Kabaddi.defender.name_defender()
Output: On running Python games.py from the console, we have:
Defender Function
Defender1: Mr. Y
Defender2: Mr. Z
Note: The preceding code is covered in (Program Name:
Chap8_Example8.8.py)
In the previous code, we are accessing the defender module of Kabaddi
Package from the file. Under this module, we are accessing the
name_defender function. So, output is displayed as shown above.
However, there is also another approach to access multiple modules of
different packages using 
from 
packname 
import 
modulename
approach.
games.py module and accessing othercountrybatsman module inside
Cricket package using from … import:
#games module
from Cricket import othercountrybatsman
othercountrybatsman.name_othercountrybatsman()
Output: On running Python games.py from the console, we have:
Other Country Batsman Function
Batsman1: Mr. E
Batsman2: Mr. F
Note: The preceding code is covered in (Program Name:
Chap8_Example8.9.py)
games.py module and accessing othercountrybowler module inside
Cricket package using from … import:
#games module
from Cricket import othercountrybowler
othercountrybowler.name_othercountrybowler()
Output: On running Python games.py from the console, we have:
Other Country Bowler Function

Bowler1: Mr. G
Bowler2: Mr. H
Note: The preceding code is covered in (Program Name:
Chap8_Example8.10.py)
games.py module and accessing indianbatsman module inside India
subpackage present in Cricket package using from … import:
#games module
from Cricket.India import indianbatsman
indianbatsman.name_indianbatsman()
Output: On running Python games.py from the console, we have:
Indian Batsman Function
Batsman1: Mr. A
Batsman2: Mr. B
Note: The preceding code is covered in (Program Name:
Chap8_Example8.11.py)
games.py module and accessing indianbowler module inside India
subpackage present in Cricket package using from … import:
#games module
from Cricket.India import indianbowler
indianbowler.name_indianbowler()
Output: On running Python games.py from the console:
Indian Bowler Function
Bowler1: Mr. C
Bowler2: Mr. D
Note: The preceding code is covered in (Program Name:
Chap8_Example8.12.py)
games.py module and accessing goalkeeper module inside Football
package using from … import:
#games module
from Football import goalkeeper
goalkeeper.name_goalkeeper()
Output: On running Python games.py from the console, we have:
GoalKeeper Function
GoalKeeper1: Mr. R
GoalKeeper2: Mr. S

Note: The preceding code is covered in (Program Name:
Chap8_Example8.13.py)
games.py module and accessing forward module inside Football
package using from … import:
#games module
from Football import forward
forward.name_forward()
Output: On running Python games.py from the console, we have:
Forward Function
Forward1: Mr. T
Forward2: Mr. U
Note: The preceding code is covered in (Program Name:
Chap8_Example8.14.py)
games.py module and accessing raider module inside Kabaddi package
using import from … inside:
#games module
from Kabaddi import raider
raider.name_raider()
Output: On running Python games.py from the console, we have:
Raider Function
Raider1: Mr. W
Raider2: Mr. X
Note: The preceding code is covered in (Program Name:
Chap8_Example8.15.py)
games.py module and accessing defender module inside Kabaddi
package using from … import:
#games module
from Kabaddi import defender
defender.name_defender()
Output: On running Python games.py from the console, we have:
Defender Function
Defender1: Mr. Y
Defender2: Mr. Z
Note: The preceding code is covered in (Program Name:

Chap8_Example8.16.py)
There is a third approach to access the objects (here functionnames
only) inside multiple modules of different packages using from
packname.modulename import funcname approach.
games.py module and accessing name_othercountrybatsman function:
#games module
from Cricket.othercountrybatsman import
name_othercountrybatsman
name_othercountrybatsman()
Output: On running Python games.py from the console, we have:
Other Country Batsman Function
Batsman1: Mr. E
Batsman2: Mr. F
Note: The preceding code is covered in (Program Name:
Chap8_Example8.17.py)
games.py module and accessing name_othercountrybowler function:
#games module
from Cricket.othercountrybowler import
name_othercountrybowler
name_othercountrybowler()
Output: On running Python games.py from the console, we have:
Other Country Bowler Function
Bowler1: Mr. G
Bowler2: Mr. H
Note: The preceding code is covered in (Program Name:
Chap8_Example8.18.py)
games.py module and accessing name_indianbatsman function, we
have:
#games module
from Cricket.India.indianbatsman import name_indianbatsman
name_indianbatsman()
Output: On running Python games.py from the console, we have:
Indian Batsman Function
Batsman1: Mr. A
Batsman2: Mr. B

Note: The preceding code is covered in (Program Name:
Chap8_Example8.19.py)
games.py module and accessing name_indianbowler function:
#games module
from Cricket.India.indianbowler import name_indianbowler
name_indianbowler()
Output: On running Python games.py from the console, we have:
Indian Bowler Function
Bowler1: Mr. C
Bowler2: Mr. D
Note: The preceding code is covered in (Program Name:
Chap8_Example8.20.py)
games.py module and accessing name_goalkeeper function:
#games module
from Football.goalkeeper import name_goalkeeper
name_goalkeeper()
Output: On running Python games.py from the console, we have:
GoalKeeper Function
GoalKeeper1: Mr. R
GoalKeeper2: Mr. S
Note: The preceding code is covered in (Program Name:
Chap8_Example8.21.py)
games.py module and accessing name_forward function:
#games module
from Football.forward import name_forward
name_forward()
Output: On running Python games.py from the console, we have:
Forward Function
Forward1: Mr. T
Forward2: Mr. U
Note: The preceding code is covered in (Program Name:
Chap8_Example8.22.py)
games.py module and accessing name_raider function:

#games module
from Kabaddi.raider import name_raider
name_raider()
Output: On running Python games.py from the console, we have:
Raider Function
Raider1: Mr. W
Raider2: Mr. X
Note: The preceding code is covered in (Program Name:
Chap8_Example8.23.py)
games.py module and accessing name_defender function:
#games module
from Kabaddi.defender import name_defender
name_defender()
Output: On running Python games.py from the console, we have:
Defender Function
Defender1: Mr. Y
Defender2: Mr. Z
Note: The preceding code is covered in (Program Name:
Chap8_Example8.24.py)
Now, suppose there is a requirement to import all the modules in a
package. This can be done using the following 2 methods.
Method-1
#games module
from Cricket import othercountrybatsman, othercountrybowler
othercountrybatsman.name_othercountrybatsman()
othercountrybowler.name_othercountrybowler()
Output: On running Python games.py from the console, we have:
Batsman1: Mr. E
Batsman2: Mr. F
Other Country Bowler Function
Bowler1: Mr. G
Bowler2: Mr. H
Note: The preceding code is covered in (Program Name:
Chap8_Example8.25.py)
Method-2

Most of you might be thinking of the following approach:
#games module
from Cricket import *
othercountrybatsman.name_othercountrybatsman()
othercountrybowler.name_othercountrybowler()
Output: On running Python games.py from the console, we have:
Traceback (most recent call last):
File "games.py", line 3, in <module>
othercountrybatsman.name_othercountrybatsman()
NameError: name 'othercountrybatsman' is not defined
Note: The preceding code is covered in (Program Name:
Chap8_Example8.26.py)
In the previous method, we have used * to import the modules. But in
the package, the preceding method is not feasible as we will get the
NameError, as shown. We were using import * in modules. So, we will
be specifying all the above module names which shall be loaded in the
__init__.py file of Cricket package.
Cricket package __init__.py file
# Cricket package ---- __init__ module
__all__ = ['othercountrybatsman','othercountrybowler']
games.py file for loading Cricket package modules:
#games module
from Cricket import *
othercountrybatsman.name_othercountrybatsman()
othercountrybowler.name_othercountrybowler()
Output: On running Python games.py from the console, we have:
Batsman1: Mr. E
Batsman2: Mr. F
Other Country Bowler Function
Bowler1: Mr. G
Bowler2: Mr. H
Note: The preceding code is covered in (Program Name:
Chap8_Example8.27.py)
India subpackage __init__.py file
# Cricket Package --- India subpackage ---- __init__ module
__all__ = ['indianbatsman','indianbowler']

Football package __init__.py file
# Football Package  ---- __init__ module
__all__ = ['goalkeeper','forward']
Kabaddi package __init__.py file
# Kabaddi Package  ---- __init__ module
__all__ = ['raider','defender']
games.py file for loading Cricket package, Indiasubpackage,
Football package and Kabaddi package modules:
#games module
from Cricket import *
from Cricket.India import *
from Football import *
from Kabaddi import *
othercountrybatsman.name_othercountrybatsman()
othercountrybowler.name_othercountrybowler()
indianbatsman.name_indianbatsman()
indianbowler.name_indianbowler()
goalkeeper.name_goalkeeper()
forward.name_forward()
raider.name_raider()
defender.name_defender()
Output: On running Python games.py from the console, we have:
Other Country Batsman Function
Batsman1: Mr. E
Batsman2: Mr. F
Other Country Bowler Function
Bowler1: Mr. G
Bowler2: Mr. H
Indian Batsman Function
Batsman1: Mr. A
Batsman2: Mr. B
Indian Bowler Function
Bowler1: Mr. C
Bowler2: Mr. D
GoalKeeper Function
GoalKeeper1: Mr. R
GoalKeeper2: Mr. S
Forward Function
Forward1: Mr. T
Forward2: Mr. U
Raider Function
Raider1: Mr. W

Raider2: Mr. X
Defender Function
Defender1: Mr. Y
Defender2: Mr. Z
Note: The preceding code is covered in (Program Name:
Chap8_Example8.28.py)
Suppose there is a requirement to use the Football package forward module
inside Kabaddi package defender module. Then the code inside defender.py
file will be:
#Kabaddi Package --- defender module
from Football import forward
def name_defender():
'''Kabaddi defender names are'''
print("Defender Function")
print("Defender1: Mr. Y")
print("Defender2: Mr. Z")
print()
forward.name_forward()
Output:
The output can be seen in the following Figure 8.8:
Figure 8.8: Output
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap8_Example8.29.py)
Using the previous approach on running, we are getting an error
ModuleNotFoundError: No module named 'Football'. We are inside
Kabaddi folder and trying to access the module of Football package.
So, we will go back by one folder and then try to execute the previous file, as
shown in Figure 8.9:

Figure 8.9: File Execution inside Games folder
However, we again received an error as there is no such file or directory. So,
we will be using flags as we must run library module as a script. Just observe
the following highlighted python help in Figure 8.10:
Figure 8.10: Highlighting Python help
Refer to the following snippet:
usage:
C:\Users\SAURABH\AppData\Local\Programs\Python\Python37\python.ex
[option] … [-c cmd | -m mod | file | -] [arg] …
Options and arguments (and corresponding environment variables):
-b  : issue warnings about str(bytes_instance),
str(bytearray_instance) and comparing bytes/bytearray with str.
(-bb: issue errors)
-B  : don't write .pyc files on import; also
PYTHONDONTWRITEBYTECODE=x
-c cmd : program passed in as string (terminates option list)
-d  : debug output from parser; also PYTHONDEBUG=x
-E  : ignore PYTHON* environment variables (such as PYTHONPATH)
-h  : print this help message and exit (also --help)
-i  : inspect interactively after running script; forces a
prompt even if stdin does not appear to be a terminal; also
PYTHONINSPECT=x
-I  : isolate Python from the user's environment (implies -E and
-s)
-m mod : run library module as a script (terminates option list)
-O  : remove assert and __debug__-dependent statements; add
.opt-1 before .pyc extension; also PYTHONOPTIMIZE=x
-OO  : do -O changes and discard docstrings; add .opt-2 before
.pyc extension
-q  : don't print version and copyright messages on interactive
startup
-s  : don't add user site directory to sys.path; also
PYTHONNOUSERSITE
-S  : don't imply 'import site' on initialization

-u  : force the stdout and stderr streams to be unbuffered; this
option has no effect on stdin; also PYTHONUNBUFFERED=x
-v  : verbose (trace import statements); also PYTHONVERBOSE=x
can be supplied multiple times to increase verbosity
-V  : print the Python version number and exit (also --version)
when given twice, print more information about the build
-W arg : warning control; arg is
action:message:category:module:lineno also PYTHONWARNINGS=arg
-x  : skip first line of source, allowing use of non-Unix forms
of #!cmd
-X opt : set implementation-specific option --check-hash-based-
pycs always|default|never: control how Python invalidates hash-
based .pyc files
file  : program read from script file
-  : program read from stdin (default; interactive mode if a
tty)
arg …: arguments passed to program in sys.argv[1:]
Other environment variables:
PYTHONSTARTUP   : file executed on interactive startup (no
default)
PYTHONPATH   : ';'-separated list of directories prefixed to the
default module search path.  The result is sys.path.
PYTHONHOME   : alternate <prefix> directory (or <prefix>;
<exec_prefix>). The default module search path uses
<prefix>\python{major}{minor}.
PYTHONCASEOK    : ignore case in 'import' statements (Windows).
PYTHONIOENCODING  : Encoding[:errors] used for
stdin/stdout/stderr.
PYTHONFAULTHANDLER : dump the Python traceback on fatal errors.
PYTHONHASHSEED  : if this variable is set to 'random', a random
value is used to seed the hashes of str, bytes and datetime
objects.  It can also be set to an integer in the range
[0,4294967295] to get hash values with a predictable seed.
PYTHONMALLOC   : set the Python memory allocators and/or install
debug hooks on Python memory allocators. Use PYTHONMALLOC=debug
to install debug hooks.
PYTHONCOERCECLOCALE : if this variable is set to 0, it disables
the locale    coercion behavior. Use PYTHONCOERCECLOCALE=warn to
request display of locale coercion and locale compatibility
warnings on stderr.
PYTHONBREAKPOINT  : if this variable is set to 0, it disables
the default debugger. It can be set to the callable of your
debugger of choice.
PYTHONDEVMODE   : enable the development mode.
So, we will be using “python -m packageName.moduleName” to run the
module from Games folder, as shown in Figure 8.11:

Figure 8.11: Using “python -m packageName.moduleName”
There is also one more method to get the same output. Just observe the code
inside defender.py file, as shown:
#Kabaddi Package --- defender module
import sys
sys.path.append("E:/python_progs/Games/Football")
import forward
def name_defender():
'''Kabaddi defender names are'''
print("Defender Function")
print("Defender1: Mr. Y")
print("Defender2: Mr. Z")
print()
forward.name_forward()
Output:
The output can be seen in Figure 8.12:
Figure 8.12: Output
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap8_Example8.30.py)
Conclusion
In this chapter, we first saw the meaning of modules and packages. Then we
saw the basic steps to create a package in Python. We created a package,
named Games folder, having 3 different packages as Cricket (subpackage:

India), Football and Kabaddi package. Then we saw how to access multiple
modules of different packages using ‘import', ‘from packname import
modulename’ 
and 
‘from 
packname.modulename 
import 
funcname’
approaches. Then we saw the method to import all the modules in a package.
Finally, in the end, we saw the approach to import one package module inside
another package module.
Points to remember
Package can consist of modules and packages.
Module means files and packages means folders.
__init__.py file is created inside the folder to consider it as a Python
package.
For the syntax, import packName.modName, packName is the name of the
package and modName is the module Name.
For the syntax, from packName.modName import funcName, packName
is the name of the package, modName is the module name and funcName
is the function name.
We can import all the modules in a package using *.
To run the module from the main package folder, use the syntax python
-m packageName.moduleName.
Questions
1. Explain the difference between module and packages in Python.
2. What are the basic steps to create a package in Python?
3. How to access multiple modules of different packages using ‘import'
only?
4. How to access multiple modules of different packages using ‘from
packname import modulename’ approach?
5. How to access multiple modules of different packages using ‘from
packname.modulename import funcname' approach?
6. What are the methods to import all the modules in a package?
7. What is the approach to import one package module inside another

package module?
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 9
Numpy Introduction
Introduction
One of the essential libraries for data science and machine learning is
numpy, which stands for numerical python library. We know that basic
mathematical operations are performed by normal Python. Complex
mathematical operations such as array creation, performing several
operations on arrays, differential calculations, statistical operations, integral
calculus operations are not at all supported by normal Python. So, all these
operations will be performed by numpy. The basic data structure in numpy is
n-dimensional array (ndarray). Numpy is written in the Python and C
language. So, performance is high and due to high speed, it is the best choice
for ML algorithms that has built-in data structures of Python-like list. Data is
stored in array form in numpy. Numpy has an array data structure that we can
use to hold data. Numpy-created arrays are referred to as “nd arrays.”
Structure
In this chapter, we will discuss the following topics:
Similarities between list and numpy array
Differences between list and numpy array
Numpy arrays creation
Objectives
By the end of this chapter, the reader will have an idea about what exactly
numpy array is, and the similarities and dissimilarities between list and
numpy array. We will be also looking into creating nd array creation using
various approaches such as list, tuple data structures along with various
functions with a Python snippet code. So, by the end of this chapter, the
reader will be able to appreciate the concept of numpy arrays by looking into

its properties and ways of creation and its importance for Machine Learning
algorithms.
Similarities between list and numpy array
The similarities between list and numpy array are as follows:
Data storage is possible with both.
Both will preserve the order. The concepts of indexing and slicing are
so applicable.
We can change the content of both, thus making both mutable.
Differences between list and numpy array
The differences between list and numpy array are as follows:
We have to install numpy explicitly whereas list is in-built type of
Python.
Homogeneous elements are present in array whereas list contains
heterogeneous elements.
Vector operations are performed on ndarray whereas we cannot
perform vector operations on list. Refer to the following code snippet:
myl1 = [100,200,300,400]
myl1+2 # we cannot perform vector operations on list
Output:
TypeError: can only concatenate list (not "int") to list
Note: The preceding code is covered in (Program Name:
Chap09_Example9.1.py)
Observe the following code:
import numpy as mynp
mynp1_array = mynp.array([100,200,300,400])
print(mynp1_array+200) # we can perform vector operations
on ndarray
Output:
[300 400 500 600]
Note: The preceding code is covered in (Program Name:

Chap09_Example9.2.py)
Less memory is consumed by ndarray than list, as shown:
import numpy as mynp
import sys
myl1 = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
myndarray =
mynp.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
print('List size is  => ',sys.getsizeof(myl1))
print('ndarray size is a => ',sys.getsizeof(myndarray))
Output:
List size is  =>  224
ndarray size is a =>  184
Note: The preceding code is covered in (Program Name:
Chap09_Example9.3.py)
Arrays are faster compared to list, as shown:
import numpy as mynp
from datetime import datetime
myarr1 = mynp.array([4,5,6])
myarr2 = mynp.array([1,2,3])
#conventional python code
def dot_product(myarr1,myarr2):
myresult = 0
for x,y in zip(myarr1,myarr2):
myresult +=  x*y
return myresult
mybefore = datetime.now()
for loop in range(1000000):
dot_product(myarr1,myarr2)
myafter = datetime.now()
print('Total Time taken by conventional python:',myafter-
mybefore)
#numpy library code
mybefore = datetime.now()
for loop in range(1000000):
mynp.dot(myarr1,myarr2) # numpy
myafter = datetime.now()
print('Total Time taken by Numpy Library:',myafter-
mybefore)
Output:
Total Time taken by conventional python: 0:00:01.650488

Total Time taken by Numpy Library: 0:00:01.345035
Note: The preceding code is covered in (Program Name:
Chap09_Example9.4.py)
Numpy arrays creation
In this section, we shall see how ndarrays are created.
1-D array creation using list
Observe the following code:
# 1-D array creation from list
import numpy as mynp
myl1 = [100,200,300]
print(f'myl1 type is: {type(myl1)}')
myndarray = mynp.array(myl1)
print(f'myndarray type is: → {type(myndarray)}')
print(f"myndarray → {myndarray}")
# nd-array properties
print(f'Array dimensions is: {myndarray.ndim}')
print(f'Data type of elements of array is :  {myndarray.dtype}')
print(f'Array size is : {myndarray.size}')
print(f'Array shape is : {myndarray.shape}')
Output:
myl1 type is: <class 'list'>
myndarray type is: → <class 'numpy.ndarray'>
myndarray → [100 200 300]
Array dimensions is: 1
Data type of elements of array is :  int32
Array size is : 3
Array shape is : (3,)
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.5.py)
1-D array creation using tuple
Observe the following code:
# 1-D array creation from tuple
import numpy as mynp

myt1 = ('Ramesh','Mahesh','Suresh')
print(f'myt1 type is: {type(myt1)}')
myndarray = mynp.array(myt1)
print(f'myndarray type is: → {type(myndarray)}')
print(f"myndarray → {myndarray}")
Output:
myt1 type is: <class 'tuple'>
myndarray type is: → <class 'numpy.ndarray'>
myndarray → ['Ramesh' 'Mahesh' 'Suresh']
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.6.py)
2-D array creation using Nested lists
Observe the following code:
# 2-D array creation from list
import numpy as mynp
myl1 = [[100,200,300],[400,500,600],[700,800,900]]
myndarray = mynp.array(myl1)
print(f'myndarray type is: → {type(myndarray)}')
print(f"myndarray → {myndarray}")
# nd-array properties
print(f'Array dimensions is: {myndarray.ndim}')
print(f'Data type of elements of array is :  {myndarray.dtype}')
print(f'Array size is : {myndarray.size}')
print(f'Array shape is : {myndarray.shape}')
Output:
myndarray type is: → <class 'numpy.ndarray'>
myndarray → [[100 200 300]
[400 500 600]
[700 800 900]]
Array dimensions is: 2
Data type of elements of array is :  int32
Array size is : 9
Array shape is : (3, 3)
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.7.py)

It is important to note that ndarray contains homogeneous elements. Ndarray
upcasting will be performed while creation, if the list contains heterogeneous
elements as shown:
# list containing heterogenous elements
import numpy as mynp
myl1 = [100,200,310.5]
myndarray = mynp.array(myl1) # float upcasting
print(f'myndarray : {myndarray}')
print(f'Elements data type is: {myndarray.dtype}')
Output:
myndarray : [100.  200.  310.5]
Elements data type is: float64
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.8.py)
Array creation with a particular dtype
Observe the following code:
import numpy as mynp
# type int
myndarray = mynp.array([100,200,310.5],dtype=int)
print(myndarray)
# type float
myndarray = mynp.array([100,200,310.5],dtype=float)
print(myndarray)
# type bool: For number and non-empty string → True and for 0
and empty string → False
myndarray = mynp.array([100,200,310.5, 0,
"","Hello"],dtype=bool)
print(myndarray)
# type complex
myndarray = mynp.array([100,200,310.5],dtype=complex)
print(myndarray)
# type str
myndarray = mynp.array([100,200,310.5],dtype=str)
print(myndarray)
Output:
[100 200 310]
[100.  200.  310.5]

[ True  True  True False False  True]
[100. +0.j 200. +0.j 310.5+0.j]
['100' '200' '310.5']
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.9.py)
Object type array creation
The parent of data types such as int, float, bool, complex and str are of object
type. Here, the elements look like heterogeneous but elements data type is of
‘object’ type, as shown:
import numpy as mynp
myndarray = mynp.array([100,'Saurabh',110.5,False,6+8j],
dtype=object)
print(myndarray)
print(f"Elements data type of myndarray is: {myndarray.dtype}")
Output:
[100 'Saurabh' 110.5 False (6+8j)]
Elements data type of myndarray is: object
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.10.py)
1-D array creation with arange() function
1-D array can be created with arange() function, as shown:
import numpy as mynp
myndarray = mynp.arange(9)
print(f'myndarray is: {myndarray}')
print(f'Array dimensions is: {myndarray.ndim}')
print(f'Data type of elements of array is :  {myndarray.dtype}')
print(f'Array size is : {myndarray.size}')
print(f'Array shape is : {myndarray.shape}')
print('-'*50)
myndarray1 = mynp.arange(1,9)
print(f'myndarray is: {myndarray1}')
print(f'Array dimensions is: {myndarray1.ndim}')
print(f'Data type of elements of array is
:  {myndarray1.dtype}')
print(f'Array size is : {myndarray1.size}')
print(f'Array shape is : {myndarray1.shape}')

print('-'*50)
myndarray2 = mynp.arange(1,9,2)
print(f'myndarray is: {myndarray2}')
print(f'Array dimensions is: {myndarray2.ndim}')
print(f'Data type of elements of array is
:  {myndarray2.dtype}')
print(f'Array size is : {myndarray2.size}')
print(f'Array shape is : {myndarray2.shape}')
print('-'*50)
myndarray3 = mynp.arange(1,9,3,dtype=float)
print(f'myndarray is: {myndarray3}')
print(f'Array dimensions is: {myndarray3.ndim}')
print(f'Data type of elements of array is
:  {myndarray3.dtype}')
print(f'Array size is : {myndarray3.size}')
print(f'Array shape is : {myndarray3.shape}')
Output:
myndarray is: [0 1 2 3 4 5 6 7 8]
Array dimensions is: 1
Data type of elements of array is :  int32
Array size is : 9
Array shape is : (9,)
myndarray is: [1 2 3 4 5 6 7 8]
Array dimensions is: 1
Data type of elements of array is :  int32
Array size is : 8
Array shape is : (8,)
myndarray is: [1 3 5 7]
Array dimensions is: 1
Data type of elements of array is :  int32
Array size is : 4
Array shape is : (4,)
myndarray is: [1. 4. 7.]
Array dimensions is: 1
Data type of elements of array is :  float64
Array size is : 3
Array shape is : (3,)
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.11.py)
Using linspace()
This function will return linearly spaced values but in the specified interval.
The syntax is:

linspace(start,
stop,
num = 50,
endpoint = True,
retstep = False,
dtype = None)
where,
start: It is optional whose default value is 0 and depicts start of interval
range.
Stop: It depicts interval range end.
Num: It is optional and depicts samples number to generate.
Endpoint: If endpoint is False, then stop is excluded.
When endpoint is True, spacing calculation: (stop-start)/(num-1)
When endpoint is False, (stop-start)/num
retstep: The spacing between the points is denoted by retstep, whose
default value is False. If True, then value will be returned.
Dtype: It is the output array type.
Let us see some examples:
import numpy as mynp
# evenly spaced values of no. of samples as 50 between 0 and 1
which includes both 0 and 1
print(mynp.linspace(0,1))
print('-'*50)
# 3 evenly spaced values between 0 and 1 and also including both
0 and 1
print(mynp.linspace(0,1,3))
print('-'*50)
# 3 evenly spaced values between 0 and 1 and also including 0
but excluding 1
print(mynp.linspace(0,1,3, endpoint=False))
print('-'*50)
# 3 evenly spaced values between 0 and 1 and also including 0
but excluding 1 and returning spacing
print(mynp.linspace(0,1,3, endpoint=False, retstep=True))
print('-'*50)
# 10 values between 1 to 50 including both 1 and 50 with equally
spacing int type values
print(mynp.linspace(1,50,5, dtype=int, retstep=True))
print('-'*50)
Output:

[0.         0.02040816 0.04081633 0.06122449 0.08163265
0.10204082
0.12244898 0.14285714 0.16326531 0.18367347 0.20408163 0.2244898
0.24489796 0.26530612 0.28571429 0.30612245 0.32653061
0.34693878
0.36734694 0.3877551  0.40816327 0.42857143 0.44897959
0.46938776
0.48979592 0.51020408 0.53061224 0.55102041 0.57142857
0.59183673
0.6122449  0.63265306 0.65306122 0.67346939 0.69387755
0.71428571
0.73469388 0.75510204 0.7755102  0.79591837 0.81632653
0.83673469
0.85714286 0.87755102 0.89795918 0.91836735 0.93877551
0.95918367
0.97959184 1.        ]
[0.  0.5 1. ]
[0.         0.33333333 0.66666667]
(array([0.        , 0.33333333, 0.66666667]),
0.3333333333333333)
(array([ 1, 13, 25, 37, 50]), 12.25)
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.12.py)
Here,
arange(): Based on the step value, elements will be considered in the
specified range.
Linspace(): The specified number of values will be included for the given
range.
Keep in mind that:
0-D array: Single value: Scalar.
1-D array: 0-D arrays collection: Vector
2-D array: 1-D arrays collection: Matrix
3-D array: 2-D arrays collection
(20,): 1-D array containing 20 elements.
(10,2): 2-D array containing 10 rows and 2 columns
(1,2,3): 3-D array containing
1 number of 2-D array

2 number of rows in every 2-D array.
3 number of columns in every 2-D array.
Size: 1*2*3 = 6
Using zeros()
Observe the following code:
import numpy as mynp
# 1-D array with zeros
print(mynp.zeros(5))
print('-'*50)
# 2-D array with zeros
print(mynp.zeros((3,3)))
print('-'*50)
# 3-D array with zeros
print(mynp.zeros((1,2,3)))
print('-'*50)
# 4-D array with zeros
print(mynp.zeros((1,2,3,4)))
print('-'*50)
# 1 no. of 3-D arrays
# 2 no. of every 3-D 2 2-D arrays
# 3 no. of every 2-D array containing 3 rows
# 4 no. of every 2-D array containing 4 columns
Output:
[0. 0. 0. 0. 0.]
[[0. 0. 0.]
[0. 0. 0.]
[0. 0. 0.]]
[[[0. 0. 0.]
[0. 0. 0.]]]
[[[[0. 0. 0. 0.]
[0. 0. 0. 0.]
[0. 0. 0. 0.]]
[[0. 0. 0. 0.]
[0. 0. 0. 0.]
[0. 0. 0. 0.]]]]
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.13.py)

Using ones()
This function is exactly the same as zeros function. A new array of given
shape and data type is returned where the element’s value is set to 1, as
shown:
import numpy as mynp
# 1-D array with ones
print(mynp.ones(5))
print('-'*50)
# 2-D array with ones
print(mynp.ones((5,2), dtype = int))
print('-'*50)
# 3-D array with ones
print(mynp.ones((1,2,3), dtype = int))
print('-'*50)
Output:
[1. 1. 1. 1. 1.]
[[1 1]
[1 1]
[1 1]
[1 1]
[1 1]]
[[[1 1 1]
[1 1 1]]]
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.14.py)
Using full()
The full function of numpy will return a new array of given shape and type,
which is filled with fill_value. Just type the following command:
import numpy as mynp
print(help(mynp.full))
To view the parameters and its functionality, type:
full(shape, fill_value, dtype=None, order='C', *, like=None)
Observe the following code:
import numpy as mynp
# 1-D array
print(mynp.full(shape=8,fill_value=2))
print('-'*50)

# 2-D array
print(mynp.full((2,3),fill_value=2))
print('-'*50)
# 3-D array
print(mynp.full((2,2,3),2)) # fill_value = 2
print('-'*50)
Output:
[2 2 2 2 2 2 2 2]
[[2 2 2]
[2 2 2]]
[[[2 2 2]
[2 2 2]]
[[2 2 2]
[2 2 2]]]
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.15.py)
Using eye()
An identity matrix is generated and a 2-D array is returned with value as 1 on
the diagonal and 0 elsewhere.
Just type the following:
import numpy as mynp
print(help(mynp.eye))
To view the parameters and its functionality, type:
eye(N, M=None, k=0, dtype=<class 'float'>, order='C', *,
like=None)
Here, N = Row number in the output.
M = Column number in the output.
K = Determines which diagonal should have a value filled with 1s. Default
value is 0.
Here, 2-D arrays are always returned. It is not necessary to have the same
number of rows and columns. So, row and column number need not be same.
The value will be same as ‘N’ if ‘M’ value is omitted.
Observe the following code:
import numpy as mynp
# 2-D array with default value k = 0
print(mynp.eye(3,4))

print('-'*50)
# 2-D array with k = 1
print(mynp.eye(4, k=1))
print('-'*50)
# 2-D array with k = 2
print(mynp.eye(4, k=2))
print('-'*50)
# 2-D array with k = -1
print(mynp.eye(4, k=-1))
print('-'*50)
# 2-D array with k = -2
print(mynp.eye(4, k=-2))
print('-'*50)
Output:
[[1. 0. 0. 0.]
[0. 1. 0. 0.]
[0. 0. 1. 0.]]
[[0. 1. 0. 0.]
[0. 0. 1. 0.]
[0. 0. 0. 1.]
[0. 0. 0. 0.]]
[[0. 0. 1. 0.]
[0. 0. 0. 1.]
[0. 0. 0. 0.]
[0. 0. 0. 0.]]
[[0. 0. 0. 0.]
[1. 0. 0. 0.]
[0. 1. 0. 0.]
[0. 0. 1. 0.]]
[[0. 0. 0. 0.]
[0. 0. 0. 0.]
[1. 0. 0. 0.]
[0. 1. 0. 0.]]
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.16.py)
Using diag()
A diagonal array is constructed or a diagonal is extracted using diag()
function. Just type the following command:
import numpy as mynp
print(help(mynp.diag))
To view the parameters and its functionality, type:

diag(v, k=0)
Observe the following code:
import numpy as mynp
# 2-D diagonal elements are extracted
myndarray = mynp.arange(1,17).reshape(4,4)
print(f"2-D Original array is : \n {myndarray}")
print(f"Elements which are present at 0-diagonal :
{mynp.diag(myndarray,k=0)}")
print(f"Elements which are present at 1-diagonal :
{mynp.diag(myndarray,k=1)}")
print(f"Elements which are present at 2-diagonal :
{mynp.diag(myndarray,k=2)}")
print(f"Elements which are present at -1-diagonal :
{mynp.diag(myndarray,k=-1)}")
print(f"Elements which are present at -2-diagonal :
{mynp.diag(myndarray,k=-2)}")
print(f"Elements which are present at 3-diagonal :
{mynp.diag(myndarray,k=3)}")
print(f"Elements which are present at -3-diagonal :
{mynp.diag(myndarray,k=-3)}")
print('-'*50)
# 1-D construct a 2-D array using the provided elements and a
diagonal array;
# the remaining elements are all filled with zeros.
Myndarray1 = mynp.array([100,200,300,400])
print(mynp.diag(myndarray1,k=0))
print('-'*50)
myndarray2 = mynp.array([100,200,300,400])
print(mynp.diag(myndarray2,k=1))
print('-'*50)
myndarray3 = mynp.array([100,200,300,400])
print(mynp.diag(myndarray3,k=-1))
print('-'*50)
Output:
2-D Original array is :
[[ 1  2  3  4]
[ 5  6  7  8]
[ 9 10 11 12]
[13 14 15 16]]
Elements which are present at 0-diagonal : [ 1  6 11 16]
Elements which are present at 1-diagonal : [ 2  7 12]
Elements which are present at 2-diagonal : [3 8]
Elements which are present at -1-diagonal : [ 5 10 15]
Elements which are present at -2-diagonal : [ 9 14]
Elements which are present at 3-diagonal : [4]
Elements which are present at -3-diagonal : [13]

[[100   0   0   0]
[  0 200   0   0]
[  0   0 300   0]
[  0   0   0 400]]
[[  0 100   0   0   0]
[  0   0 200   0   0]
[  0   0   0 300   0]
[  0   0   0   0 400]
[  0   0   0   0   0]]
[[  0   0   0   0   0]
[100   0   0   0   0]
[  0 200   0   0   0]
[  0   0 300   0   0]
[  0   0   0 400   0]]
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.17.py)
Using empty()
A new array of given shape and type is created without initializing entries.
Use the empty() function to generate a dummy array.
Type the following command:
import numpy as mynp
print(help(mynp.empty))
To view the parameters and its functionality, type:
empty(shape, dtype=float, order='C', *, like=None)
Observe the following snippet:
import numpy as mynp
print(mynp.empty((3,3)))
Output:
[[0.00000000e+000 0.00000000e+000 0.00000000e+000]
[0.00000000e+000 0.00000000e+000 2.13436359e-321]
[1.06811015e-306 1.24611470e-306 0.00000000e+000]]
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.18.py)
Comparison between zeros and empty

If we compare zeros and empty:
We should choose zeroes if we simply need an array of zeros().
If we only need an empty array for future use and do not care about
data, we should choose empty().
As compared to zeros array, the empty() array creation takes a very
small amount of time. In other words, if data is not a concern, the
empty() function is preferred over zeros() from a performance
standpoint.
Refer to the following code:
# Performance comparison of zeros() and empty() function of
numpy
import numpy as mynp
from datetime import datetime
mybegin = datetime.now()
myndarray = mynp.zeros((10000,200,300))
myafter = datetime.now()
print('Time taken by zeros function of numpy is:',myafter-
mybegin)
print('-'*50)
myndarray= None
mybegin = datetime.now()
myndarray = mynp.empty((10000,200,300))
myafter = datetime.now()
print('Time taken by empty function of numpy is:',myafter-
mybegin)
Output:
Time taken by zeros function of numpy is: 0:00:00.200177
--------------------------------------------------
Time taken by empty function of numpy is: 0:00:00.010974
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap09_Example9.19.py)
Now, we know how to create ndarray using numpy. There are lot of other
concepts in numpy such as creation of ndarrays with random data, indexing,
slicing, advanced indexing, concept of view versus copy, iterating elements
of ndarray, arithmetic operators, broadcasting, array manipulation functions,
multiple arrays joining into a single array, arrays splitting, elements sorting of
ndarrays, elements insertion into ndarray, elements deletion from ndarray,

matrix class importance in numpy library and so on, that are unfortunately,
out of scope of this book.
Conclusion
In this chapter, we initially saw what numpy array is. Then we discussed
about similarities and dissimilarities between list and numpy array with
examples. We have also seen various approaches to create ndarrays. 1-D
array creation was done using list, and tuple with a Python code. 2-D array
creation was done using nested lists, array creation with a particular dtype, 1-
D array creation with arange function. We also saw various other functions
such as linspace(), zeros(), ones(), full(), eye(), diag(), empty()
functions with their meanings, followed by a Python snippet code. In the next
chapter, we shall see about introduction to data visualization.
Points to remember
Numpy array is written in C and Python language.
Numpy array performance is high and is the best choice for ML
algorithms.
Numpy arrays are faster and consumes less memory as compared to list.
Homogeneous 
elements 
are 
present 
in 
numpy 
array 
where
heterogeneous elements are present in list.
We can perform vector operations on ndarray, whereas the same cannot
be performed on list.
1-D arrays can be created using list, tuple, arange(), linspace(),
zeros(), ones(), full(), eye(), diag() and empty() functions
Questions
1. What is numpy array? Is it the best choice of ML?
2. Explain the similarities between list and numpy array.
3. Explain the dissimilarities between list and numpy array.
4. Explain 1-D array creation using list, tuple with a Python snippet code.
5. Explain 2-D array creation using nested lines with a Python snippet

code.
6. Explain array creation with a particular dtype and with a Python snippet
code.
7. Explain 1-D array creation with arange() function.
8. Explain linspace() function with a Python snippet code.
9. Explain zeros(), ones(), full(), eye(), diag(), empty() functions
with a Python snippet code.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 10
Data Visualization Introduction
Introduction
The representation of data in a graphical or visual format is known as data
visualization. Data visualization aims to increase viewers’ access to,
understanding of, and connection to complicated data sets. Patterns, trends,
and relationships can be easily seen and expressed when data is presented
visually. Charts, graphs, tables, maps, and other types of data visualization
are only a few examples. Each kind of visualization works best with
particular kinds of information or ideas. For instance, scatterplots can be used
to depict the relationship between two variables, and line charts are
frequently used to show patterns over time.
In a variety of disciplines, including business, finance, science, and social
sciences, data visualization is a crucial tool. It lets decision-makers swiftly
grasp and analyze data, which can lead to more informed judgements. Data
visualization is a vital tool for researchers and educators because it can make
complicated ideas understandable to a wide audience.
Structure
In this chapter, we will discuss the following topics:
Python data visualization tools
Line plot creation by passing 2 ndarrays
Adding title, xlabel and ylabel to the line plot
Advanced Line Plot
linestyle property
color property
default color
Peep in a shortcut way to set color, marker and linestyle

alpha property
linewidth and markersize property
markerfacecolor property
Customizing the figure size
Plotting multiple lines in a same plot
Objectives
By the end of this chapter, the reader will know about different python data
visualization tools available for creating plots out of which, we will learn
about the most common matplotlib library. We will investigate creating line
plots by using 2 ndarrays followed by addition of title, xlabel and ylabel to
the code. We can set the marker, color and linestyle property with various
available options. Also, in a shortcut way, we can set these properties using
either mlc or clm form. Finally, we will be able to adjust the transparency
using alpha attribute, followed by changing the width of the line, denoting the
marker size in a plot and setting the face color of markers in plots by using
lw, ms and mfc property.
Python data visualization tools
The most well-liked Python data visualization tools are as follows:
Matplotlib: Matplotlib is a well-liked Python package for making
animated, interactive, and static visualizations. Line charts, scatter plots,
bar charts, histograms, and other visualizations are among the many that
are offered.
Seaborn: Based on Matplotlib, Seaborn is a Python data visualization
package that offers a more advanced interface for producing statistical
visualizations. It offers a variety of sophisticated visualization
techniques, including cluster maps, heatmaps, and violin plots.
Plotly: Plotly is a Python visualization toolkit that offers customizable
and interactive visualizations. Several other chart formats, such as
scatter plots, bar charts, line charts, and more, are supported.
Bokeh: Bokeh is a Python library for building interactive web browser
visualizations. It handles streaming and real-time data and offers a

variety of visualization formats, such as scatter plots, line charts, and
bar charts.
Altair: With just a few lines of code, you can build interactive
visualizations with Altair, a declarative visualization toolkit for Python.
It enables you to effortlessly modify and alter your visualizations and
supports a variety of chart styles, such as scatter plots, bar charts, and
line charts.
We will discuss about matplotlib in this chapter, to give you all a taste of it.
To install matplotlib, type:
pip install matplotlib
We will first use the following statement:
import matplotlib.pyplot as myplt
A group of functions in Python called matplotlib.pyplot offers a high-level
interface for making different visualizations, such as line charts, scatter plots,
bar charts, histograms, and more.
Python code frequently uses the import matplotlib.pyplot as myplt
statement to import the pyplot module from the matplotlib library and alias it
as myplt. This enables calling functions from the pyplot module with shorter
and more convenient names. For example, calling myplt.plot() instead of
matplotlib.pyplot.plot().
So, matplotlib is a library in which pyplot is a module name. With the help
of pyplot module, we can create plots such as plot, bar, pie, hist and scatter
for creating line plot, bar chart, pie chart, histograms, and scatter plot.
Line plot creation by passing 2 ndarrays
Observe the following code:
# Line plot creation by passing 2 ndarrays
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis) #(1,1),(2,8),(3,27)
myplt.show()
Output:
The output is shown in Figure 10.1:

Figure 10.1: Output of line plot creation using 2 ndarrays
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.1.py)
Figure 10.1 is a distinct window on the screen that Matplotlib uses to display
the graphs, serving as the output container for graphics.
To generate this figure object, use the plot() function.
Container for plot | figure
Figure 10.1 object includes multiple plots.
Adding title, xlabel and ylabel to the line plot
We may add a title to the line plot using the myplt.title() function (“Cube
function line plot”).
To get the information related to title, type the following command:
import matplotlib.pyplot as myplt

help(myplt.title)
To study various parameters, type:
title(label, fontdict=None, loc='center', pad=None, **kwargs)
Observe the following code:
# Line plot creation by passing 2 ndarrays with title, xlabel
and ylabel
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis) # line plot is drawn
myplt.title('Cube Function Line Plot') # title is provided to
the line plot
myplt.xlabel('X axis-Value -------') # information is described
about x-axis data
myplt.ylabel('Cube of Y axis-Value -------') # information is
described about y-axis data
myplt.show() # Display the line plot
Output:
The output is shown in Figure 10.2:

Figure 10.2: Output depicting xlabel, ylabel and title to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.2.py)
Advanced line plot
A line drawn on a graph can be distinguished by its color, style, width,
transparency, and so on. They can be customized to meet our requirements.
Data points on the line plot can be highlighted using the marker property.
We must provide a keyword argument for the marker as shown:
myplt.plot(x_axis,y_axis,marker='o')
Here, o stands for circle.

The details against each marker character can be seen in the following Table
10.1:
S No.
Character
Description
1
.
point marker
2
,
pixel marker
3
o
circle marker
4
v
triangle_down marker
5
^
triangle_up marker
6
<
triangle_left marker
7
>
triangle_right marker
8
1
tri_down marker
9
2
tri_up marker
10
3
tri_left marker
11
4
tri_right marker
12
s
square marker
13
p
pentagon marker
14
*
star marker
15
h
hexagon1 marker
16
H
hexagon2 marker
17
+
plus marker
18
x
x marker
19
D
diamond marker
20
d
thin_diamond marker
21
|
vline marker
22
_
hline marker
Table 10.1: Marker description against each character
Observe the following code:
# Line plot creation by passing 2 ndarrays with title, xlabel,
ylabel and marker
import matplotlib.pyplot as myplt

import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,marker='o')
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.3:
Figure 10.3: Output highlighting circle marker to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.3.py)

linestyle property
linestyle property is specified as solid, dotted, dashed. The linestyle
keyword argument is used as:
myplt.plot(x_axis,y_axis,marker='o',linestyle='--')
The details against each linestyle character can be seen in the following Table
10.2:
S No.
Character
Description
1
-
solid line style (default value)
2
--
dashed line style
3
-.
dash-dot line style
4
:
dotted line style
Table 10.2: Linestyle description against each character
Observe the following code:
# Line plot creation by passing 2 ndarrays with title, xlabel,
ylabel, marker and linestyle
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,marker='o',linestyle='-.') # dash-dot
linestyle
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.4:

Figure 10.4: Output highlighting dash dot linestyle to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.4.py)
color property
By utilizing the colour keyword parameter, we can add colors to our plot,
define the color we want for the line plot, and utilize any colour, and even
hexa code.
The details against each color character can be seen in the following Table
10.3:
S No.
Character
Description

1
b
blue
2
g
green
3
r
red
4
c
cyan
5
m
magneto
6
y
yellow
7
k
black
8
w
white
Table 10.3: Color description against each character to the line plot
The color keyword argument is used as:
myplt.plot(x_axis,y_axis,marker='o',linestyle='--',color='g')
Observe the following code:
# Line plot creation by passing 2 ndarrays with title, xlabel,
ylabel, marker, linestyle and color
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,marker='o',linestyle='-.', color='g')
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.5:

Figure 10.5: Output highlighting green color to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.5.py)
default color
The default color will be selected from the style circle if we do not specify a
color. We can write the following statement to get the default color:
myplt.rcParams['axes.prop_cycle'].by_key()
Observe the following code:
# code for checking the default color
import matplotlib.pyplot as myplt
print(myplt.rcParams['axes.prop_cycle'].by_key())

Output:
{'color': ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
'#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22',
'#17becf']}
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.6.py)
The first default color is blue,
The second default color is orange,
The third default color is green,
The fourth default color is red,
Observe the following code:
# Line plot creation by passing 2 ndarrays with default color
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
myplt.plot(x_axis,x_axis) # blue
myplt.plot(x_axis,x_axis*2) # orange
myplt.plot(x_axis,x_axis*4) # green
myplt.plot(x_axis,x_axis*8) # red
myplt.title('Default color Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Display of various calculations-------')
myplt.show()
Output:
The output is shown in Figure 10.6:

Figure 10.6: Output displaying default colors to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.7.py)
Peep in a shortcut way to set color, marker and linestyle
The shortcut notation is specified using either mlc or clm where, m stands for
marker, l stands for linestyle, and c stands for color.
We should utilize the short codes b, g, y, k, c, and so on for color in this
shortcut method.
Red, yellow values are not permitted in shortcut way.

mlc form
Observe the following code:
# mlc form
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,'o:g')# mlc form
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.7:

Figure 10.7: Output displaying line plot using mlc form
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.8.py)
clm form
Observe the following code:
# clm form
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,'g:o')# clm form
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.8:

Figure 10.8: Output displaying line plot using clm form
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.9.py)
If no color is mentioned, then default color is blue
Observe the following code:
# mlc form
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,'o:')# mlc form
myplt.title('Cube Function Line Plot')

myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.9:
Figure 10.9: Output with default color as blue to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.10.py)
alpha property
The graph plot transparency is adjusted using the alpha attribute, which

denotes opaque or transparency of the color. Value is between 0 and 1.
If alpha < 1, the graph plot becomes more transparent.
Observe the following code:
# mlc form with alpha property
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,'o:', alpha = 0.2)# mlc form with alpha
= 0.2
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.10:

Figure 10.10: Output with alpha attribute to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.11.py)
If alpha >1, the graph plot becomes less transparent.
linewidth and markersize property
The linewidth property denotes the thickness/width of the line in a plot by
using lw property.
The markersize property denotes the marker size in a plot by using ms

property.
Observe the following code:
# mlc form with lw and ms
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,'o:g', lw=5, ms = 10)
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.11:

Figure 10.11: Output of mlc form with lw and ms property to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.12.py)
markerfacecolor property
This property will set the face color of markers in plots.
Observe the following code:
# mfc property
import matplotlib.pyplot as myplt
import numpy as mynp
x_axis = mynp.arange(1,11)
y_axis = x_axis**3
myplt.plot(x_axis,y_axis,'o:g', lw=5, ms = 10, mfc='yellow')
myplt.title('Cube Function Line Plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Cube of Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.12:

Figure 10.12: Output with mfc property to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.13.py)
Customizing the figure size
To display all default settings in matplotlib, we can use:
print(myplt.rcParams)
print(myplt.rcParams.get('figure.figsize'))
Observe the following code:
# Getting the default figure size
import matplotlib.pyplot as myplt

print(myplt.rcParams.get('figure.figsize'))
print(myplt.rcParams['figure.figsize'])
Output:
[6.4, 4.8]
[6.4, 4.8]
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.14.py)
We can customize the size of the figure by setting the figsize parameter by
using the myplt.figure() function.
A new figure can be created or an existing figure can be activated by using:
num: num can be either int or str and specifies a unique identifier for the
figure.
figsize: figsize is a tuple that specifies the width and height of the
figure in inches.
Observe the following code:
import matplotlib.pyplot as myplt
import numpy as mynp
myplt.figure(num=1,figsize=(8,4),facecolor='green')
myndarray = mynp.arange(1,6)
myplt.plot(myndarray,myndarray,'o-r')
myplt.show()
Output:
The output is shown in Figure 10.13:

Figure 10.13: Output of customizing the figure size
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.15.py)
Observe the following code:
import matplotlib.pyplot as myplt
import numpy as mynp
myplt.figure(figsize=(4,4),facecolor='green')
myndarray = mynp.arange(1,6)
myplt.plot(myndarray,myndarray,'o-r')
myplt.show()
Output:
The output is shown in Figure 10.14:

Figure 10.14: Output with change of figure size to the line plot
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.16.py)
Plotting multiple lines in a same plot
Observe the following code:
# plotting multiple lines in the same plot
import matplotlib.pyplot as myplt
import numpy as mynp

x_axis = mynp.arange(1,11)
y_axis1 = x_axis
y_axis2 = x_axis**2
y_axis3 = x_axis**3
myplt.plot(x_axis,y_axis1,'o:r')
myplt.plot(x_axis,y_axis2,'o:g')
myplt.plot(x_axis,y_axis3,'o:b')
myplt.title('Plotting multiple lines in the same plot')
myplt.xlabel('X axis-Value -------')
myplt.ylabel('Y axis-Value -------')
myplt.show()
Output:
The output is shown in Figure 10.15:
Figure 10.15: Output lotting multiple lines in the same plot

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap10_Example10.17.py)
There is lot to discuss in the matplotlib but in this book, we have only
provided the taste of line plot using matplotlib.
Conclusion
In this chapter, we initially saw various Python data visualization tools. Then
we created a simple line plot by passing 2 ndarrays. We added code for title,
xlabel and ylabel to the line plot. We investigated different marker, linestyle
and color character while creating line plot. We saw Python code to view
default color. Then we peeped in a shortcut way to set color, marker and
linestyle property using either mlc or clm form with a python code. For
transparency, we saw alpha property and then played by changing the
thickness of the line and marker size in a plot by using linewidth and
markersize property. We set the facecolor of markers in plots by using
markerfacecolor property. We have learned how to customize the figure
size. Finally, we learned about plotting multiple lines in a same plot.
Points of remember
Matplotlib, seaborn, plotly, bokeh and altair are some of the data
visualization tools.
pyplot is a module name in matplotlib library.
To generate the figure object, use plot() function.
Use title() function to add a title to the line plot.
Use xlabel and ylabel function to add label on x and y axis.
Marker property to add marker to the line plot.
We can create plots as solid, dotted and dashed suing linestyle property.
We can add colors to our plot using color property.
The default color will be selected from the style circle if we do not
specify a color.
We can set color, marker and linestyle to our plot using shortcut way as
either mlc or clm form.

Transparency can be adjusted in our plot using alpha attribute
The width of a line and market size in a plot can be denoted by lw and
ms property.
The facecolor of markers in plots can be set by using mfc property.
Questions
1. Explain different types of Python data visualization tools.
2. Write a Python snippet code to create line plots by passing 2 nd arrays.
3. Write a Python snippet code to add title, xlabel and ylabel to the line
plot.
4. What are different types of marker characters available?
5. Explain linestyle and color property with a Python code.
6. Write a python code to get the default color.
7. How to set color, marker and linestyle property in a shortcut way.
Explain with a Python code.
8. Explain alpha, linewidth, markersize and markerfacecolor property
with a Python snippet code.
9. Write a Python code for customizing the figure size.
10. Write a Python code to plot multiple lines in a same plot.
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 11
Pandas Introduction
Introduction
We shall see our last chapter which is on Pandas. Pandas is a robust and
popular Python package for data analysis and manipulation. For working with
structured data, including tabular, time series, and heterogeneous data, it
offers simple-to-use data structures and data analysis capabilities. With
Matplotlib, SciPy, and Scikit-learn among the many additional data analysis
libraries which Pandas is compatible with, it is built on top of NumPy. Series
and DataFrame are the two main data structures in Pandas. Like a column in
a spreadsheet or a SQL table, a “Series” is a one-dimensional named array
that can carry any data type (integers, floats, texts, and so on). A two-
dimensional labelled data structure called a “DataFrame” can carry a variety
of data kinds in its columns of potentially different types.
Data cleansing, merging and joining, reshaping, filtering, sorting, grouping,
and aggregation are just a few of the many data manipulation and analysis
features offered by Pandas. Additionally, it supports complex data analysis
activities including machine learning, statistical modelling, and time series
analysis.
Data science, machine learning, finance, economics, social science, and many
more fields, all use Pandas extensively. Its popularity is a result of its
simplicity, adaptability, and potent capabilities, which make it a crucial tool
for Python data analysis.
We can install pandas by typing the following pip command:
pip install pandas
Let us learn some concepts on Pandas Series and Pandas DataFrame.
Structure
In this chapter, we will discuss the following topics:

Pandas Series
Pandas DataFrame
Objectives
By the end of this chapter, the reader will know about Pandas introduction
and why it is important in data science. We shall see the data structures in
Pandas, which is series and DataFrame. We will be looking into their
constructor, their methods of creation, the elements/data accessing and their
aggregation with a Python snippet code. By the end of the chapter, we will be
able to appreciate the importance of pandas and its application.
Pandas Series
A Pandas Series is a one-dimensional labelled array that may store any sort
of data, including Python objects, floats, strings or integers. We can compare
Pandas Series to a column in the excel sheet. We shall see some of the key
concepts on Pandas Series in Python.
Pandas Series constructor
We can create a Pandas series using the following constructor:
pandas.Series(data=None, index=None, dtype=None, name=None,
copy=False, fastpath=False)
Here,
data: This is the information that will be kept in the Series. It could be a
scalar value, a dictionary, a list, or a NumPy array.
index: This option details the Series’ index labels. It could be a
dictionary, list, array, or range. The Series will be given a default
integer index starting at 0, if no index is given.
dtype: The data type for the values in the Series is specified by this
argument. Pandas will attempt to determine the data type from the input
data, if it is not provided.
name: The Series’ name is specified by this argument.
Copy: With this argument, you can decide whether or not the input data
should be copied.

fastpath: Most users should not use this argument because it is used
for internal optimization only.
Creating Pandas Series by passing a list
Observe the following code:
import pandas as mypd
# creating a Pandas Series from a list
mylist = [1, 2, 3, 4, 5]
mypd_series = mypd.Series(mylist)
print(mypd_series)
Output:
0     1
1    2
2    3
3    4
4    5
dtype: int64
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.1.py)
Creating Pandas Series by passing a dictionary
Observe the following code:
import pandas as mypd
# creating a Pandas Series from a dictionary
mydict = {'key1':1, 'key2':2, 'key3':3, 'key4':4, 'key5':5}
mypd_series = mypd.Series(mydict)
print(mypd_series)
Output:
key1    1
key2    2
key3    3
key4    4
key5    5
dtype: int64
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.2.py)

Creating Pandas Series by passing a numpy array
Observe the following code:
import pandas as mypd
import numpy as mynp
# creating a Pandas Series from a numpy array
myndarray = mynp.array([11,12,13,14,15])
mypd_series = mypd.Series(myndarray)
print(mypd_series)
Output:
0    11
1    12
2    13
3    14
4    15
dtype: int32
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.3.py)
Accessing elements in Pandas Series
The individual elements of a Pandas Series can be accessed using either
index label or by using the element’s integer location, as shown:
import pandas as mypd
# creating a Pandas Series
mylist = [11, 12, 13, 14, 15]
mypd_series = mypd.Series(mylist, index=['r', 's', 't', 'u',
'v'])
print(mypd_series)
# element access using index label
print(mypd_series['u'])
# element access using integer location
print(mypd_series[3])
Output:
r    11
s    12
t    13
u    14
v    15
dtype: int64
14

14
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.4.py)
Pandas Series slicing
A Pandas Series can be sliced using either index labels or integer locations,
as shown:
import pandas as mypd
# creating a Pandas Series
mylist = [11, 12, 13, 14, 15]
mypd_series = mypd.Series(mylist, index=['r', 's', 't', 'u',
'v'])
print(mypd_series)
# slicing the Pandas Series using index labels
print(mypd_series['r':'u'])
# slicing the Pandas Series using integer locations
print(mypd_series[1:])
Output:
r    11
s    12
t    13
u    14
v    15
dtype: int64
r    11
s    12
t    13
u    14
dtype: int64
s    12
t    13
u    14
v    15
dtype: int64
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.5.py)
Pandas Series filtering

A Pandas Series can be filtered using Boolean indexing, as shown:
import pandas as mypd
# creating a Pandas Series
mylist = [11, 12, 13, 14, 15]
mypd_series = mypd.Series(mylist, index=['r', 's', 't', 'u',
'v'])
print(mypd_series)
print('-'*50)
# filtering the Pandas Series using Boolean indexing
my_bool_filter = mypd_series > 3
print(my_bool_filter)
print('-'*50)
my_filtered_mypdseries = mypd_series[my_bool_filter]
print(my_filtered_mypdseries)
Output:
r    11
s    12
t    13
u    14
dtype: int64
--------------------------------------------------
r    True
s    True
t    True
u    True
v    True
dtype: bool
--------------------------------------------------
r    11
s    12
t    13
u    14
v    15
dtype: int64
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.6.py)
Usage of apply method to Pandas Series
A function can be applied to each element of a Pandas Series using the
‘apply’ method as shown:
import pandas as mypd

# creating a Pandas Series
mylist = [11, 12, 13, 14, 15]
mypd_series = mypd.Series(mylist, index=['r', 's', 't', 'u',
'v'])
print(mypd_series)
print('-'*50)
# applying a function to each element of the Pandas Series
def mycube(mynum):
return mynum ** 3
mycube_pdseries = mypd_series.apply(mycube)
print(mycube_pdseries)
Output:
r    11
s    12
t    13
u    14
v    15
dtype: int64
--------------------------------------------------
r    1331
s    1728
t    2197
u    2744
v    3375
dtype: int64
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.7.py)
Aggregating of Pandas Series
A Pandas Series can be aggregated using ‘min’, ‘max’, ‘sum’, ‘mean’ and
‘median’, as shown:
import pandas as mypd
# creating a Pandas Series
mylist = [11, 12, 13, 14, 15]
mypd_series = mypd.Series(mylist, index=['r', 's', 't', 'u',
'v'])
print(mypd_series)
print('-'*50)
# Minimum value calculation of the Series
print(f" Minimum value is: {mypd_series.min()}")
# Maximum value calculation of the Series

print(f" Maximum value is: {mypd_series.max()}")
# Calculating the sum of the Series
print(f" Sum is: {mypd_series.sum()}")
# Calculating the mean of the Series
print(f" Mean is: {mypd_series.mean()}")
# Calculating the median of the Series
print(f" Median is: {mypd_series.median()}")
Output:
r    11
s    12
t    13
u    14
v    15
dtype: int64
--------------------------------------------------
Minimum value is: 11
Maximum value is: 15
Sum is: 65
Mean is: 13.0
Median is: 13.0
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.8.py)
These are only a few of the methods that the user can use to work with the
Pandas Series. There are numerous additional ways to perform operation on
Series, including filling in missing values, sorting, grouping, and more.
Pandas DataFrame
A two-dimensional size-mutable, potentially heterogeneous tabular data
structure with labelled axes (rows and columns) is called a Pandas
DataFrame . Data is aligned in a tabular fashion in rows and columns in a
data frame, which is a two-dimensional data structure. The data, rows, and
columns are the 3 primary components of a Pandas DataFrame. The data
representation is like a SQL table or a spreadsheet. We shall see some of the
key concepts on Pandas DataFrame in Python.
Pandas DataFrame constructor
We can create a Pandas DataFrame by the usage of the following constructor:

pandas.DataFrame(data=None, index=None, columns=None,
dtype=None, copy=False)
Here,
data: The DataFrame’s data are specified using this argument. It might
be a dictionary, a list of dictionaries, a NumPy array, or another
DataFrame, among other data structures. An empty DataFrame is
created if no data is provided.
index: The row labels for the DataFrame are specified using this
argument. It could be a list, an array, or another DataFrame, among
other data structures. A default integer index is created if index is not
specified.
columns: The DataFrame’s column labels are specified using this
option. It could be a list, an array, or another DataFrame, among other
data structures. A default set of column labels is created if columns are
not specified.
dtype: The data type for the columns in the DataFrame is specified
using the dtype option. A dictionary that maps column names to data
types or a single data type, such as int or float, are both acceptable.
copy: To specify whether to copy the data, use the copy parameter. A
new copy of the data is made if copy=True. The original data is used if
copy=False.
Pandas DataFrame creation
Observe the following code:
import pandas as mypd
# creating a DataFrame from a dictionary of lists
mydict = {'myname': ['Alex', 'John', 'Michael', 'Tom'],
'myage': [35, 45, 55, 65],
'mycountry': ['UK', 'USA', 'Australia', 'Finland']}
mypd_dataframe = mypd.DataFrame(mydict)
print(mypd_dataframe)
print('-'*50)
# creating a DataFrame from a list of dictionaries
mylist = [{'myname': 'Alex', 'myage': 35, 'mycountry': 'UK'},
{'myname': 'John', 'myage': 45, 'mycountry': 'USA'},
{'myname': 'Michael', 'myage': 55, 'mycountry': 'Australia'},
{'myname': 'Tom', 'myage': 65, 'mycountry': 'Finland'}]

my_pd_dataframe2 = mypd.DataFrame(mylist)
print(my_pd_dataframe2)
Output:
myname  myage  mycountry
0     Alex     35         UK
1     John     45        USA
2  Michael     55  Australia
3      Tom     65    Finland
--------------------------------------------------
myage  mycountry   myname
0     35         UK     Alex
1     45        USA     John
2     55  Australia  Michael
3     65    Finland      Tom
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.9.py)
Accessing data in Pandas DataFrame
Using indexing and slicing, we can access data in Pandas DataFrame, as
shown:
import pandas as mypd
# creating a DataFrame from a dictionary of lists
mydict = {'myname': ['Alex', 'John', 'Michael', 'Tom'],
'myage': [35, 45, 55, 65],
'mycountry': ['UK', 'USA', 'Australia', 'Finland']}
mypd_dataframe = mypd.DataFrame(mydict)
print(mypd_dataframe)
print('-'*50)
# getting the second row of the DataFrame
print(mypd_dataframe.loc[1])
print('-'*50)
# getting the mycountry column of the DataFrame
print(mypd_dataframe['mycountry'])
print('-'*50)
# getting the subset of the DataFrame
print(mypd_dataframe.loc[0:2, ['myname', 'myage']])
print('-'*50)
Output:
myname  myage  mycountry
0     Alex     35         UK
1     John     45        USA

2  Michael     55  Australia
3      Tom     65    Finland
--------------------------------------------------
myname       John
myage          45
mycountry     USA
Name: 1, dtype: object
--------------------------------------------------
0           UK
1          USA
2    Australia
3      Finland
Name: mycountry, dtype: object
--------------------------------------------------
myname  myage
0     Alex     35
1     John     45
2  Michael     55
--------------------------------------------------
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.10.py)
Data modification in Pandas DataFrame
Using indexing and slicing with various other methods, we can modify the
data in Pandas DataFrame, as shown:
import pandas as mypd
# creating a DataFrame from a dictionary of lists
mydict = {'myname': ['Alex', 'John', 'Michael', 'Tom'],
'myage': [35, 45, 55, 65],
'mycountry': ['UK', 'USA', 'Australia', 'Finland']}
mypd_dataframe = mypd.DataFrame(mydict)
print(mypd_dataframe)
print('-'*50)
# modifying the mycountry of the second row
mypd_dataframe.loc[1, 'mycountry'] = 'Russia'
print(mypd_dataframe)
print('-'*50)
# adding a new column to the DataFrame
mypd_dataframe['Hobby'] = ['Playing Cricket', 'Listening Music',
'Reading Books', 'Cooking']
print(mypd_dataframe)
print('-'*50)

# dropping the Hobby column from the DataFrame
my_df_drop = mypd_dataframe.drop(columns=['Hobby'])
print(my_df_drop)
print('-'*50)
# sorting the DataFrame by myname in descending order
my_df_sort = mypd_dataframe.sort_values(by='myname',
ascending=False)
print(my_df_sort)
print('-'*50)
Output:
myname  myage  mycountry
0     Alex     35         UK
1     John     45        USA
2  Michael     55  Australia
3      Tom     65    Finland
--------------------------------------------------
myname  myage  mycountry
0     Alex     35         UK
1     John     45     Russia
2  Michael     55  Australia
3      Tom     65    Finland
--------------------------------------------------
myname  myage  mycountry            Hobby
0     Alex     35         UK  Playing Cricket
1     John     45     Russia  Listening Music
2  Michael     55  Australia    Reading Books
3      Tom     65    Finland          Cooking
--------------------------------------------------
myname  myage  mycountry
0     Alex     35         UK
1     John     45     Russia
2  Michael     55  Australia
3      Tom     65    Finland
--------------------------------------------------
myname  myage  mycountry            Hobby
3      Tom     65    Finland          Cooking
2  Michael     55  Australia    Reading Books
1     John     45     Russia  Listening Music
0     Alex     35         UK  Playing Cricket
--------------------------------------------------
Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.11.py)

Data aggregation in Pandas DataFrame
Data can be aggregated in a Pandas DataFrame using methods such as count,
sum, mean, median, and so on. Refer to the following:
import pandas as mypd
# creating a DataFrame from a dictionary of lists
mydict = {'myname': ['Alex', 'John', 'Michael', 'Tom'],
'myage': [35, 45, 55, 65],
'mycountry': ['UK', 'USA', 'Australia', 'Finland']}
mypd_dataframe = mypd.DataFrame(mydict)
print(mypd_dataframe)
print('-'*50)
# getting the mean age of the DataFrame
my_mean_age = mypd_dataframe['myage'].mean()
print(my_mean_age)
print('-'*50)
# getting the total number of rows in the DataFrame
my_num_row_count = len(mypd_dataframe.index)
print(my_num_row_count)
print('-'*50)
# grouping the DataFrame by country and getting the mean age for
each group
mygroup = mypd_dataframe.groupby(['mycountry']).mean()
print(mygroup)
print('-'*50)
Output:
myname  myage  mycountry
0     Alex     35         UK
1     John     45        USA
2  Michael     55  Australia
3      Tom     65    Finland
--------------------------------------------------
50.0
--------------------------------------------------
4
--------------------------------------------------
myage
mycountry
Australia     55
Finland       65
UK            35
USA           45
--------------------------------------------------

Note: 
The 
preceding 
code 
is 
covered 
in 
(Program 
Name:
Chap11_Example11.12.py)
We have only discussed about few methods of Pandas DataFrame and there
are many more. You may check them out if interested.
Conclusion
In this chapter, we initially saw the introduction of Pandas package. Then we
saw introduction to Pandas series, its constructor, its creation by passing a
list, dictionary and numpy array. We learned how to access the elements in
Pandas series using slicing, filtering. We used the apply method to each
element of Pandas series, followed by aggregating of Pandas series. Then we
learned about an introduction to Pandas DataFrame, its constructor, the
DataFrame creation, accessing data using indexing and slicing in Pandas
DataFrame, modifying the data in Pandas DataFrame. Finally, we learned
about data aggregation in Pandas DataFrame.
Points to remember
Pandas is a robust and popular Python package for data analysis and
manipulation.
A Pandas series is a 1-D labelled array for storing any sort of data
including Python objects, floats, strings or integers.
A Pandas series can be created by passing a list, dictionary or a numpy
array.
The individual elements of Pandas series can be accessed by using
either index label or by using element’s integer location. It can be
filtered by using Boolean indexing.
A Pandas series can be aggregated using min, max, sum, mean and
median.
A Pandas DataFrame is a 2-D size-mutable, potentially heterogeneous
tabular data structure with labelled axes (rows and columns).
We can access the data in Pandas DataFrame using indexing and
slicing.
The data can be modified in Pandas DataFrame.

Data can be aggregated using methods such as count, sum, mean,
median and so on.
Questions
1. What is Pandas in data science?
2. What is Pandas series? Explain the syntax of Pandas series constructor?
3. How to create Pandas series? Explain with help of Python snippet code.
4. How to access elements in Pandas series?
5. Write a Python snippet code to aggregate Pandas series?
6. What is Pandas DataFrame? Explain the syntax of Pandas DataFrame
constructor?
7. How to create Pandas DataFrame? Explain with help of Python snippet
code.
8. How to access data in Pandas DataFrame?
9. How to modify data in Pandas DataFrame?
10. How data can be aggregated in Pandas DataFrame?
Join our book's Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

Index
A
advanced line plot 318-320
alphabet pattern 104-107
alpha property 329, 330
Altair 315
B
Bokeh 315
break statement 91
examples 92-95
flowchart 92
built-in functions 184
C
cd command 9-11
character classes 147
examples 148-152
clear command 8
closures 199
creating 199-201
color property 322, 323
command line arguments 43
Python argparse module 49
Python getopt module 46
sys.argv 43-46
compile() function 144, 145
continue statement 95
examples 96-99
flowchart 96
control flow, in nested try-except finally block 134-138
cases 135
control flow, in try-except 118
cases 119, 120
control flow, in try-except and finally block

cases 129-131
cp command 13
customized exception handling 116-118
D
data structures
dictionary data structure 244
list data structure 216
set data structure 238
tuple data structure 228, 229
data visualization 313
data visualization tools 314
Altair 315
Bokeh 315
Matplotlib 314
Plotly 315
Seaborn 315
default arguments 190, 191
default color 323-325
default except block 124, 125
dictionary comprehension
with for loop 252, 253
with for loop and if statement 253, 254
with for loop and nested if statement 254
with if else statement and for loop 255
dictionary creation
curly braces, using 245
dict() function, using 245
dictionary data structure 244
dictionary, accessing 247-249
dictionary comprehension 252
dictionary, creating 246, 247
dictionary, deleting 250, 251
empty dictionary, creating 245
key rules 244
dynamic input
reading, from keyboard 36
E
else block
with try-except finally block 138-140

errors 112
runtime error 113, 114
syntax error 112, 113
eval function 41, 42
except block
possible combinations 125, 126
exception handling
customized exception handling 116-118
importance 114, 115
exception hierarchy 115
exception information
printing, to console 120, 121
explicit line joining method
examples 17, 18
F
figure size
customizing 333-335
finally except block 126-129
finditer() function 145-147
flow control statements 74
iterative statements 84, 85
selection or conditional statements 74
transfer statements 91
for loop 85
examples 85-88
flowchart 85
function arguments 186, 187
default arguments 190, 191
keyword arguments 189, 190
keyword variable length arguments (kwargs) 194-196
positional arguments 187, 188
variable length arguments 192, 193
functions 182
built-in functions 184
example 183, 184
passing as parameter 201, 202
user defined functions 185, 186
functions, of re module
escape 173, 174
findall 167
fullmatch 164, 165

match 162-164
search 166, 167
split 171-173
sub 168, 169
subn 169-171
fundamental data types 29
G
games package structure
accessing, with different approaches 266-286
from import, using 263-266
import, using 262
objects, accessing 263, 264
Garbage Collector (GC) 30
global variable 203-207
I
identifiers 15
if-elif-else ladder 81-83
flowchart 84
if-elif-else statement
flowchart 79-81
if-else statement 77
flowchart 77, 78
if statement 74
flowchart 75, 76
immutability 29
with reference to, fundamental data types 29-32
implicit line joining method 16
curly braces, using 16
parenthesis, using 16, 17
square brackets, using 16
in keyword
usage 100, 101
input() function 37-40
Integrated Development and Learning Environment (IDLE) 6
iterative statements 84
for loop 85-88
while loop 88-91

K
keyword arguments 189, 190
keywords 13, 14
keyword variable length arguments (kwargs) 194-196
L
lambda functions
passing, to another function 212
line joining methods 15
explicit line joining method 17
implicit line joining method 16
line plot
advanced line plot 318-320
creating, by passing 2 ndarrays 315, 316
title, adding 317, 318
xlabel, adding 317, 318
ylabel, adding 317, 318
linestyle property 320, 321
linewidth property 330, 331
list array and numpy array
differences 290-292
similarities 290
list comprehension 223
with for loop 224
with for loop and if statement 225
with for loop and nested if statement 225, 226
with if else statement and for loop 226, 227
list data structure 216
empty list, creating 216, 217
list comprehension 223, 224
list, creating 216
list, creating when elements are known 217
list, creating with dynamic input 217
list, creating with list() function 218
list, creating with split() function 218
list elements, accessing 219
list elements, accessing by index 219
list elements, accessing by index and for loop 221
list elements, accessing by index and while loop 221, 222
list elements, accessing by list slicing 222, 223
list elements, accessing by negative index 220

list elements, accessing by positive index 220
lists, versus immutability 219
nested list comprehension, with for loop 227, 228
versus, tuple data structure 237
local variables 202, 203
loop patterns 102
alphabet pattern 104-107
number pattern 107, 108
start pattern 102
ls command 7
ls -l command 8
M
markerfacecolor property 331, 332
markersize property 330, 331
Matplotlib 314
metacharacters 174
alteration (|) 177
backslash (\) 178
braces {} 177
caret (^) 175
dollar ($) 175
group () 178
period (.) 175
plus (+) 176
question mark (?) 177
R prefix 178
square brackets [] 174, 175
star (*) 176
mkdir command 9
mnemonic variable names 27, 28
multiple except blocks
trying with 121, 122
multiple lines
plotting, in same plot 335, 336
mv command 11, 12
N
Nested function 197-199
nested lambda functions 211, 212
nested try-except finally block 131-134

control flow 134
non changeable behavior 29
non-local variable 207, 208
number pattern 107-109
numpy 289
numpy arrays creation
1-D array creation, with arrange() function 297
1-D array creation, with list 292
1-D array creation, with tuple 293
2-D array creation, with nested lists 294, 295
diag() function, using 307-309
empty() function, using 309
eye() function, using 305
full() function, using 304
linspace() function, using 299-301
object type array creation 296
ones() function, using 303
with particular dtype 295, 296
zeros() function, using 301
zeros, versus empty 310, 311
P
packages 260
creating 261
games package structure 262
overview 260
Pandas 339
Pandas DataFrame 349
creating 350, 351
creating, with constructor 350
data, accessing 351-353
data aggregation 356, 357
data modification 353-356
Pandas Series 340
aggregating 348, 349
apply method, using 347
creating, by passing dictionary 342
creating, by passing list 341
creating, by passing numpy array 342
creating, with constructor 340, 341
elements, accessing 343
filtering 345, 346

slicing 344, 345
pass statement 100
Plotly 315
positional arguments 187, 188
pre-defined character classes 153
examples 153-157
print function 18, 19
using styles 19-24
pwd command 7
PyPy version 5
Python 1
benefits 2-4
installation 5, 6
limitations 4, 5
program, running 6, 7
URL 2
usage 4
Python argparse module 49, 50
abbreviations, allowing 59-61
abbreviations, disallowing 59-61
append action 59
argument help 52, 53
data type 54
dest action 58
optional and positional arguments, using 57
optional arguments 55
positional arguments 50, 51
positional arguments default values 51, 52
short names, for optional arguments 56
with required 57, 58
Python exception hierarchy 115, 116
Python getopt module 46
Exception getopt.GetoptError 47
long form options 48, 49
short form options 47, 48
Python lambda functions 210, 211
nested lambda functions 211, 212
passing, to another function 212
Python multiline strings 62-64
Python string access 64
index, using 64, 65
slice operator, using 65, 66
Python sys.argv 43-46

Python Virtual Machine (PVM) 2, 115, 122
Q
quantifiers
examples 159-162
using 158
R
raw_input function 36
recursion 208
recursive function 208, 209
reserved words 13, 14
rm command 11
rm -rf command 11
runtime error 113, 114
S
Seaborn 315
selection or conditional statements
if-elif-else ladder 81-84
if-elif-else statement 79-81
if-else statement 77, 78
if statement 74-76
set comprehension 240
with for loop 241
with for loop and if statement 241, 242
with for loop and nested if statement 242, 243
with if else statement and for loop 243, 244
set data structure 238
set comprehension 240
set creation 239, 240
shortcut notation 325
clm form 327
mlc form 326
output with default color 328
single except block
multiple exceptions, handling with 122-124
slice operator
in backward direction 66-70
in forward direction 66

using 65
Stack-Overflow 5
star patterns 102
stars, printing in pyramid shape 102-104
strings 35, 61
syntax error 112, 113
T
touch command 10
transfer statements
break statement 91-95
continue statement 95-99
pass statement 100
try except block 40, 41
tuple creation 229
empty tuple creation 229, 230
multiple valued tuple creation 231
single valued tuple creation 230
tuple() function, using 231, 232
tuple data structure 228, 229
tuple comprehension 236, 237
tuple creation 229
tuple elements, accessing 232
tuple, versus immutability 236
versus, list data structure 237
tuple elements
accessing, with index 232
accessing, with index and for loop 233, 234
accessing, with index and while loop 234, 235
accessing, with negative index 232, 233
accessing, with positive index 232
accessing, with tuple slicing 235, 236
U
user-defined functions 185, 186
V
variable 24, 25
rules 25, 26
variable length arguments 192, 193

Visual Studio Code (VsCode) 7
W
while loop 88
examples 89-91
flowchart 89

