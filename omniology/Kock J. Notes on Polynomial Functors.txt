Joachim Kock
Notes on Polynomial Functors
Very preliminary version: 2007-05-24 21:36
PLEASE CHECK IF A NEWER VERSION IS AVAILABLE!
http://mat.uab.cat/~kock/cat/polynomial.html

Joachim Kock
Departament de Matemàtiques
Universitat Autònoma de Barcelona
08193 Bellaterra (Barcelona)
SPAIN
e-mail: kock@mat.uab.cat
VERSION 2007-05-24 21:36
Available from http://mat.uab.cat/~kock
This text was written in alpha. It was typeset in LATEX in standard book style, with
mathpazo and fancyheadings. The ﬁgures were coded with the texdraw package,
written by Peter Kabal. The diagrams were set using the diagrams package of Paul
Taylor.

Preface
Warning. Despite the fancy book layout, these notes are in VERY PRELIM-
INARY FORM: many of the sections are very sketchy for the moment, and
on the other hand many proofs and explanations are full of trivial details.
There is a lot of redundancy and bad organisation, and many things that
will be dried up. There are also whole sections that have not been written
yet, and things I want to explain that I don’t understand yet. . .
There may also be ERRORS here and there!
Still work in progress.
THERE WILL BE A PREFACE ONE DAY
Thanks to André Joyal in particular etc. SEE THE INTRODUCTION
FOR MORE SPECIFIC CREDITS.
Also to Michael Batanin, Nicola Gambino, Anders Kock, Juan Climent
Vidal, Martin Hyland, Clemens Berger, Ieke Moerdijk. . .
Feedback is most welcome.
Barcelona, April 2007
JOACHIM KOCK
kock@mat.uab.cat
[Rough draft, version 2007-05-24 21:36]


Contents
Preface
iii
Introduction
1
Preliminaries: natural numbers and ﬁnite sets . . . . . . . . .
3
I
Polynomial functors in one variable
11
1
Basic theory of polynomials in one variable
13
1.1
Deﬁnition
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
1.2
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.3
Other viewpoints . . . . . . . . . . . . . . . . . . . . . . . . .
22
1.4
Basic properties . . . . . . . . . . . . . . . . . . . . . . . . . .
25
1.5
Basic operations on polynomials
. . . . . . . . . . . . . . . .
25
1.6
Differential calculus . . . . . . . . . . . . . . . . . . . . . . . .
29
1.7
Composition of polynomials (substitution)
. . . . . . . . . .
33
2
Categories of polynomial functors in one variable
41
2.1
Polynomial functors and cartesian morphisms
. . . . . . . .
42
Products in Poly . . . . . . . . . . . . . . . . . . . . . . . . . .
48
2.2
General maps between polynomial functors . . . . . . . . . .
48
2.3
Naturality of the operations . . . . . . . . . . . . . . . . . . .
54
2.4
Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.5
Sums, products, and differentiation . . . . . . . . . . . . . . .
54
2.6
Algebra of polynomial functors: categoriﬁcation and Burn-
side rigs
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
[Rough draft, version 2007-05-24 21:36]

vi
CONTENTS
3
Aside: Polynomial functors and negative sets
61
3.1
Negative sets . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
3.2
The geometric series revisited . . . . . . . . . . . . . . . . . .
68
3.3
Moduli of punctured Riemann spheres . . . . . . . . . . . . .
70
4
Algebras
75
4.1
Initial algebras, least ﬁxpoints . . . . . . . . . . . . . . . . . .
75
Functoriality of least ﬁxpoints . . . . . . . . . . . . . . . . . .
78
4.2
Natural numbers, free monoids . . . . . . . . . . . . . . . . .
78
4.3
Tree structures as least ﬁxpoints . . . . . . . . . . . . . . . . .
83
4.4
Induction, well-founded trees . . . . . . . . . . . . . . . . . .
87
4.5
Transﬁnite induction . . . . . . . . . . . . . . . . . . . . . . .
89
4.6
Free-forgetful
. . . . . . . . . . . . . . . . . . . . . . . . . . .
91
5
Polynomial monads and operads
99
5.1
Polynomial monads . . . . . . . . . . . . . . . . . . . . . . . .
99
Cartesian monads . . . . . . . . . . . . . . . . . . . . . . . . .
99
The free monad on a polynomial endofunctor (one variable) 103
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
5.2
Classical deﬁnition of operads . . . . . . . . . . . . . . . . . . 107
5.3
The monoidal category of collections . . . . . . . . . . . . . . 108
5.4
The free operad on a collection
. . . . . . . . . . . . . . . . . 111
5.5
Finitary polynomial functors and collections
. . . . . . . . . 112
Equivalence of monoidal categories
. . . . . . . . . . . . . . 113
5.6
P-operads
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
6
[Polynomial functors in computer science: the theory of contain-
ers???]
119
6.1
Data structures
. . . . . . . . . . . . . . . . . . . . . . . . . . 119
7
[Species. . . ]
123
7.1
Introduction to species and analytical functors . . . . . . . . 123
7.2
Polynomial functors and species
. . . . . . . . . . . . . . . . 123
II
Polynomial functors in many variables
125
8
Polynomials in many variables
127
8.1
Introductory discussion
. . . . . . . . . . . . . . . . . . . . . 127
[Rough draft, version 2007-05-24 21:36]

CONTENTS
vii
8.2
The pullback functor and its adjoints . . . . . . . . . . . . . . 134
8.3
Basic operations on polynomial functors . . . . . . . . . . . . 141
Composition . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
8.4
Basic properties . . . . . . . . . . . . . . . . . . . . . . . . . . 147
8.5
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
8.6
Differential calculus of polynomial functors . . . . . . . . . . 149
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Partial derivatives . . . . . . . . . . . . . . . . . . . . . . . . . 149
Homogeneous functors and Euler’s Lemma . . . . . . . . . . 150
8.7
Linear functors (matrices) . . . . . . . . . . . . . . . . . . . . 154
9
Categories of polynomial functors
159
9.1
The functor category POLY(I, J) of polynomial functors Set/I →
Set/J . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Fixed-variables case . . . . . . . . . . . . . . . . . . . . . . . . 159
Sums and products in POLY(I, J) . . . . . . . . . . . . . . . . 166
Misc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
9.2
Poly(I, J): the cartesian fragment . . . . . . . . . . . . . . . . 167
Sums and products in Poly(I, J)
. . . . . . . . . . . . . . . . 171
9.3
Variable types (in cartesian case)
. . . . . . . . . . . . . . . . 171
Preliminaries towards operads
. . . . . . . . . . . . . . . . . 179
Sums and products in the variable-type categories . . . . . . 181
9.4
Double categories of polynomial functors . . . . . . . . . . . 182
Reminder on double categories . . . . . . . . . . . . . . . . . 182
The double category of polynomial functors and cartesian
2-cells
. . . . . . . . . . . . . . . . . . . . . . . . . . . 182
Composition and the factorisations . . . . . . . . . . . . . . . 185
Epi-mono factorisation in Poly
. . . . . . . . . . . . . . . . . 186
9.5
The non-cartesian case . . . . . . . . . . . . . . . . . . . . . . 188
10 Polynomial functors on collections and operads
189
10.1 The free-operad functor
. . . . . . . . . . . . . . . . . . . . . 189
10.2 Linear differential operators are linear . . . . . . . . . . . . . 191
11 Polynomial monads
195
11.1 The free polynomial monad on a polynomial endofunctor
. 195
11.2 Monads in the double category setting . . . . . . . . . . . . . 199
The free monad adjunction with variable index set . . . . . . 200
[Rough draft, version 2007-05-24 21:36]

viii
Contents
relative . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
12 Coloured operads and generalised operads
205
12.1 Burroni’s multilinear relations . . . . . . . . . . . . . . . . . . 205
12.2 Coloured operads . . . . . . . . . . . . . . . . . . . . . . . . . 208
Polynomial monads and coloured operads
. . . . . . . . . . 209
13 Trees
211
13.1 Trees
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
13.2 From trees to polynomial endofunctors
. . . . . . . . . . . . 215
A category of trees
. . . . . . . . . . . . . . . . . . . . . . . . 218
Examples of trees . . . . . . . . . . . . . . . . . . . . . . . . . 220
13.3 P-trees
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
Subtrees
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
13.4 From trees to polynomial monads
. . . . . . . . . . . . . . . 229
Comparison between the two constructions . . . . . . . . . . 230
Examples of polynomial monads from trees . . . . . . . . . . 232
Factorisation systems in the category of trees . . . . . . . . . 234
From monad maps to tree maps . . . . . . . . . . . . . . . . . 234
Characterisation of the three classes of maps
. . . . . . . . . 238
13.5 Factorisation systems . . . . . . . . . . . . . . . . . . . . . . . 240
13.6 Trees of trees, constellations, and the Baez-Dolan construction241
III
Categorical polynomial functors
247
14 Categorical polynomial functors
249
14.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
Cat is not locally cartesian closed . . . . . . . . . . . . . . . . 250
14.2 Conduché ﬁbrations
. . . . . . . . . . . . . . . . . . . . . . . 252
14.3 Polynomial functors in Cat
. . . . . . . . . . . . . . . . . . . 261
14.4 The family functor
. . . . . . . . . . . . . . . . . . . . . . . . 262
14.5 Polynomial functors in terms on presheaf categories . . . . . 265
14.6 Final functors and discrete ﬁbrations . . . . . . . . . . . . . . 265
15 Generalised species???
267
A
Appendices
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
[Rough draft, version 2007-05-24 21:36]

Introduction
0.0.1 Polynomial functors. A polynomial with natural-number coefﬁcients
is a formal expression of the form
∑
n∈N
anXn
an ∈N,
like for example 4 + X3 + 7 X8. The notions involved—sums, products,
and exponentiation—make sense also in the category of sets. We write
A + B for the disjoint union of two sets A and B, and we write A × B for
their cartesian product. Finally we use the exponential notation XE for the
hom set Hom(E, X).1
Hence we can deﬁne a polynomial functor to be something like
Set
−→
Set
X
7−→
A + B×XN + C×XR
for some ﬁxed sets A, B, C, N, R and a variable set X. A ﬁrst idea would be
to look at sums ∑n∈N An × Xn, but it turns out to be very fruitful to forget
about ﬁniteness and look more generally at expressions like
∑
b∈B
XEb
where (Eb | b ∈B) is a family of sets, indexed by a set B.
1Since this notation is not very common outside category theory, let us explain why
this is in fact a accurate picture of what is going on: if X is a set with 5 elements and
E has 3 elements, then Hom(E, X) has 53 elements, as suggested by the notation XE.
Furthermore, if E = E1 + E1 (the disjoint union of sets E1 and E2), then Hom(E, X) is
naturally isomorphic to Hom(E1, X) × Hom(E2, X). In other words, XE1+E2 = XE1 × XE2.
(We will consistently use the equality sign for natural isomorphisms.)
[Rough draft, version 2007-05-24 21:36]

2
Contents
Now it turns out that many of the things you can do with good old
polynomials make sense also for polynomial functors: of course you can
add them and multiply them, but you can also substitute them into each
other or take derivative, and all these notions behave as expected. For
example there is a Leibniz rule and a chain rule.
REWRITE THIS! All this works also for polynomials in many variables
and for vectors of polynomial functions: given for example three variable
sets X, Y, Z (i.e., a variable object in Set3), then an example of a polynomial
functor is something like
Set3
−→
Set2
(X, Y, Z)
7−→
(A×XM×YN, X + B).
That is, in analogy with polynomial maps Nn →Nm there are functors
Set I →Set J, for some ﬁxed set of variables I and J. We are particularly
interested in the case where I = J, so that we can compose such functors
with themselves.
The interest in polynomial functors can be attributed to the interplay
between the combinatorics of the coefﬁcients and exponents on one side,
and the function analytic aspects on the other side. Just like good old poly-
nomials are functions with the feature that they can be manipulated in
terms of their coefﬁcients and exponents alone—a very concise and man-
ageable amount of data—polynomial functors and the things one wants to
do with them are described in terms of a few sets and set maps.
The notion of polynomial functor goes a long way back; all the ideas
exposed here were known to André Joyal in the early eighties. The inter-
esting details presented here are a transcript of long discussions between
André Joyal and myself over the summer of 2004 in connection with [31].
With his usual generosity he guided me through the theory in a way that
made me feel I was discovering it all by myself. I have felt very privileged
for this opportunity, and by writing it all down I hope to beneﬁt others
as well. For the uninteresting details and for all misconceptions I take the
responsibility myself.
0.0.2 History of polynomial functors? INVESTIGATE ALSO THE NO-
TION OF SHAPELY FUNCTORS OF BARRY JAY. THEY ARE SOMETHING
[Rough draft, version 2007-05-24 21:36]

3
LIKE PULLBACK PRESERVING FUNCTORS WITH A CARTESIAN NAT-
URAL TRANSFORMATION TO M. WELL THIS IS PROBABLY NOT HIS
DEFINITION BECAUSE WE HAVE ALREADY SEEN THAT THE EXIS-
TENCE OF A CARTESIAN NATURAL TRANSFORMATION TO M AL-
READY GUARANTEES IT IS POLYNOMIAL, AND HENCE AUTOMAT-
ICALLY PRESERVES PULLBACKS. . . WELL, LOOK IT UP. . .
Manes and Arbib [36] do polynomial functors and relate their impor-
tance for ﬁxpoint theory and data types and program semantics. They
refer to the Czech school for the origins of the ﬁxpoint formalism. Accord-
ing to Juan Climent Vidal, there are polynomial functors in the works of
the Czech school. . .
The object is Set/N are also called signatures. (This terminology comes
from logic: each object is thought of as an abstract operation, and its image
in N is its arity. The language is the set of all formulae that can be written
with these operations.) Possibly this goes back to Philip Hall in the 1940s.
There is also the notion of compositeur of Lazard (Lois de groupe et
analyseurs, Ann ENS 72 (1955), 299–400). A compositeur is something
very similar to an operad, and an analyseur is a compositeur with some
sort of ﬁltration. . .
Then there is the notion of clone (P. Hall), cf. Cohn’s book Universal
Algebra [16] (p.126 and 132). This is a little bit different than an operad: the
list of operations to graft on top of the bottom operations are all required
to be of the same arity n, and the resulting operation will be of this arity
again: it is namely required to take n inputs, duplicating them and sticking
them into the top operations in the appropriate slots.
Preliminaries: natural numbers and ﬁnite sets
Large parts of mathematics are concerned with reduction of geometry and
topology to algebra, associating to geometrical objects various invariants
that can be used to distinguish and compare the objects, up to some no-
tion of equivalence depending on the context. However, to the man on
the street, often only the reduced layer is visible, and math is conceived
to be about algebraic manipulations with numbers (and occasionally an
unknown X, a variable representing a number) — the conceptual back-
ground for the numbers is often lost.
[Rough draft, version 2007-05-24 21:36]

4
Contents
It is instructive to revert this reduction process and try to look behind
the numbers. Such an investigation can lead to conceptual explanations of
‘facts of life’, and reveal what is natural and what is not. This insight can
guide our treatment of other mathematical problems.
0.0.3 Counting. The simplest invariant is the cardinality of a ﬁnite set:
N
# : FinSet
−→
N
X
7−→
#X
Theorem. Two ﬁnite sets are isomorphic if and only if they have the same cardi-
nality.
Really, this theorem is not much more than a tautology, because you
could rightfully say that it contains only the deﬁning property of the nat-
ural numbers. Baez and Dolan [8] tells the wonderful story about how
shepherds invented the natural numbers as a device for comparing the
size of two herds without having to line up the sheep in an explicit bijec-
tion (especially hard if the two herds you are comparing are the one of
today with the one of yesterday, to see if everybody’s there).
As algebraic geometers we may want to state the result in a slightly
different manner, which is very useful:
Theorem-Deﬁnition. The moduli problem of classifying ﬁnite sets up to iso-
morphism admits a ﬁne moduli space, which we denote by N.
A family of ﬁnite sets is just a set map p : E →B with ﬁnite ﬁbres (then
the ﬁbres Eb : = p−1(b) are the members of the family). The base set B is
not required to be ﬁnite.
To say N is a ﬁne moduli space means that it carries a universal family
u : N′ →N: for any family of ﬁnite sets p : E →B, there is a unique map
κ : B →N (called the classifying map), such that the family p is a pullback
along κ of the universal family:
E
κ′
- N′
B
p
?
κ
- N
u
?
[Rough draft, version 2007-05-24 21:36]

5
(Note that κ′ is not unique, cf.2.1.4!) Now the invariant # is described like
this: to a ﬁnite set S associate the image under the classifying map of the
trivial family S →1.
Let us exhibit a universal family:2 it is just a map of sets u : N′ →N
whose ﬁbre over n is a ﬁnite set with n elements. We set n := {0, 1, . . . , n −
1}. One concrete description of the universal family is this:
N′ = ∑
n∈N
n = {(n, i) ∈N × N | i < n}.
Then N′ →N is simply the projection (n, i) 7→n:
N′
↓
N
0 1 2 3 4
0.0.4 Commutative rigs and distributive categories. In N we have the
arithmetic operations of addition and multiplication, and these satisfy a
list of familiar rules, which amount to saying that (N, +, 0, ×, 1) is a com-
mutative rig — that’s like a commutative ring, but without requiring the
existence of additive inverses.
Looking back, these operations are in fact deﬁned in terms of operations
existing on the level of ﬁnite sets: for example, the natural number a + b
is deﬁned as the cardinality of the disjoint union of A and B, where A is a
set of cardinality a and B is a set of cardinality b. Similarly, multiplication
is deﬁned in terms of the cartesian product of ﬁnite sets. This makes sense
because disjoint union and cartesian product are functorial constructions,
so if you replace A or B by isomorphic sets you get an isomorphic result.
Furthermore, disjoint union and cartesian product of sets are characterised
by universal properties (see for example [8]), which in turn imply that as-
sociativity as well as commutativity hold (up to canonical isomorphism),
and hence explain these laws for the natural numbers. Note also that (up
to canonical isomorphism) the empty set 0 (the initial set) is neutral for
disjoint union, and the singleton set 1 (the terminal set) is neutral for the
cartesian product.
2Perhaps this should not be called a universal family, in view of the non-uniqueness
of κ′. It is a universal family in the sense that it represents the functor which to a given
set B associates the set of isomorphism classes of families of ﬁnite sets of B.
[Rough draft, version 2007-05-24 21:36]

6
Contents
The main theme of this exposition is to lift arithmetics from natural
numbers to ﬁnite sets, and in fact we will use arbitrary sets. To make this
lifted arithmetics look as familiar as possible, we write A + B for the dis-
joint union of sets A and B, and ∑b∈B Eb for the disjoint union of a family
of sets (Eb)b∈B indexed by a (possibly inﬁnite) set B. (And as usual we
write × for the binary cartesian product and ∏for an arbitrary, possibly
inﬁnite, product.)
The construction of the rig N from FinSet has a natural generalisation
which is useful: by deﬁnition, a distributive category is one where ﬁnite
sums and ﬁnite products exist (in particular there is an initial object and a
terminal object) and the distributive law holds, i.e. the natural morphism
A × X + A × Y −→A × (X + Y)
(1)
distr
is an isomorphism. 3 The set of isomorphism classes of D inherits from D
the structure of a commutative rig, and is called the Burnside rig of D. So
we can summarise our ﬁndings so far by saying that
N is the Burnside rig of FinSet.
In 2.6.3 we shall see that the polynomial rig N[X] is the Burnside rig of the
category FinSet[X] of ﬁnite polynomial functors, and in Section 3 we shall
have a short look at the mythical negative sets whose Burnside rig would
be Z.
0.0.5 Exponentiation and distributivity. The categories FinSet and Set
sport an extra operation which is crucial: exponentiation. Given two sets
X and E, we set
XE := HomSet(E, X).
Note that if #X = x and #E = e, then #(XE) = xe, which justiﬁes the
notation. (In fact, it would be more precise to say that exponentiation in N
is deﬁned by this equation.) Note also the natural isomorphisms
XE1+E2 = XE1 × XE2,
(X1 × X2)E = XE
1 × XE
2 ,
which are immediate consequences of the universal properties of disjoint
union and cartesian product, respectively. Here and throughout we use
3We ought to require also that A × ∅≃∅, but I seem to recall that Cocket has shown
that this condition is automatic from the ﬁrst one! – perhaps in [15].
[Rough draft, version 2007-05-24 21:36]

7
the equality sign for natural isomorphisms. This effectively explain these
laws for exponentiation in N.
Exponentiation is right adjoint to multiplication, as expressed by this
Curry bijection (or lambda conversion, or exponential adjointness):
A × E −→X
A −→XE
This fact implies distributivity: the inverse to (1) comes about like this:
A × (X + Y) −→A×X + A×Y
X + Y −→(A×X + A×Y)A
X →(A×X + A×Y)A,
Y →(A×X + A×Y)A
A × X →A×X + A×Y,
A × Y →A×X + A×Y
the sum injections
and hence explains the distributive law in N.
0.0.6 Equations and isomorphisms — bijective proofs. So we can ask
which equations valid in N come from ﬁnite sets? Which can be lifted or
categoriﬁed? This question has a long history in combinatorics: combina-
torists speak of a bijective proof of a combinatorial identity, if each side of
the equation counts something and the equation is proved by establishing
a explicit bijection between the two sets being counted. There are identities
which are known to be true, but for which no bijective proof is known. . .
0.0.7 Categoriﬁcation. The example, and most of this note, are part of a
programme known under the name categoriﬁcation which is this process:
substitute sets by categories in such a way that equations between ele-
ments in the set becomes isomorphisms between objects. As we shall see
it is sometimes necessary more generally to replace equations by equiva-
lences, not just isomorphisms. In any case the goal of this process is to
understand not only whether an equation holds or not, but also why it
holds.
The term categoriﬁcation was introduced by Crane [18] and the pro-
gramme has been advocated much by Baez and Dolan (see for example [8]
[Rough draft, version 2007-05-24 21:36]

8
Contents
for a very readable account, very relevant to the themes of the present ex-
position). Previously Lawvere and Schanuel had used the term objectiﬁ-
cation.
There are many other reasons why this process is fruitful. Generally
speaking it is because sets are much richer than numbers, and can interact
in more interesting ways. Speciﬁcally, there are mappings between sets!
As a particular case, sets have symmetries. For example, a ﬁnite set A of n
elements has a symmetry group, Aut(A) = Sn, which is a very interesting
algebraic object associated to A, much more interesting than associating a
number n! to a given number n. So from this viewpoint, the categoriﬁed
setting gives us all of group theory, whereas in contrast, the reduced set-
ting just gives us the theory of factorials (and their prime factors).
More generally, a set can have structure. In addition to group structure,
it could be an ordering, a vector space structure, a topology and so on.
Furthermore, things you can do with usual constant sets, you can often
do with variable sets too [33], or more generally in a topos. For example,
the theory of polynomial functors is closely related to the Sierpi´nski topos,
cf. Section 2.
Finally, to come back the the concrete question of natural numbers and
ﬁnite sets, you notice that many things you can do with ﬁnite sets, you
might as well do with inﬁnite sets! This was Cantor’s original motivation
for inventing abstract sets, to handle inﬁnite quantities. E.g. for numbers
it is often a problem that an inﬁnite sum ∑∞
i=0 ai is not necessarily a well-
deﬁned number, but an inﬁnite sum of sets, well that’s just another set.
There is some hope that categoriﬁcation can help physics overcome prob-
lems related to ill-deﬁned sums that tend to appear, for example in quan-
tum mechanics, which are currently handled by dubious renormalisation
tricks.
Recently, motivation has come from another side in theoretical physics,
namely from string theory: while point-like particles can be seen as a set of
points, in string theory, the elementary particles are 1-dimensional things,
and they can be described better as arrows in a category. This may look
like a very loose analogy at ﬁrst encounter — to see the depth of this it is
necessary to observe that category theory can be seen as a combinatorial o
algebraic account of topology, i.e. to think of a category as a space and its
arrows as paths in the space.
From these perspectives, the goal is to categorify quantum mechanics!
The ﬁrst steps in categoriﬁed group theory were taken forty years ago,
[Rough draft, version 2007-05-24 21:36]

9
starting perhaps with Eckmann and Hilton [20], with later contributions
by Sinh [44], Joyal and Street [28], Baez and Lauda [9]. Categoriﬁed vec-
tor spaces were introduced by Kapranov and Voevodsky [29], and stud-
ied further by Elgueta [22], who also develops categoriﬁed representation
theory [21], i.e. representations of 2-groups on 2-vector spaces. Recently,
Baez, Schreiber and others have been working out categoriﬁed gauge the-
ory [10].
[Rough draft, version 2007-05-24 21:36]

10
Contents
[Rough draft, version 2007-05-24 21:36]

Part I
Polynomial functors in one
variable
[Rough draft, version 2007-05-24 21:36]


Chapter 1
Basic theory of polynomials in
one variable
Polynomial functors is the categoriﬁcation of polynomial functions of N.
They were invented by André Joyal in the early Eighties, as a preliminary
step towards his ground-breaking theory of species and analytic functors.
The latter, which can be seen as a polynomial functors with symmetries,
became a foundation for power series theory in combinatorics, see [26],
[12]. Possibly, because of the success of analytic functors and species, the
simpler theory of polynomial functors was never written down, and did
not become mainstream.
Many results about polynomial functors are well known in other for-
mulations (see for example the appendix of Leinster’s book [34]). The for-
malism has proved useful in algebraic topology [13], in type theory [37],
[23], in computer science [GIVE REFERENCES] in higher category theory
[31] (and implicitly in [7]).
1.1
Deﬁnition
1.1.1 Polynomials. A polynomial with natural-number coefﬁcients is a
formal expression of the form
∑
n∈N
anXn
an ∈N,
like for example 4 + X3 + 7 X8. The symbol X is a formal variable, a mere
place holder. So formally you could also say that a polynomial is a ﬁnite
[Rough draft, version 2007-05-24 21:36]

14
Basic theory of polynomials in one variable
list of natural numbers (a0, a1, a2, . . . , ak), but the idea is of course that one
can substitute numbers into X, and hence a polynomial deﬁnes a function
N →N. Two polynomials deﬁne the same function if and only if all their
coefﬁcients agree. This functional interpretation immediately explains the
familiar operations of addition and multiplication of polynomials, with
which the set of all polynomials becomes a commutative semi-ring, also
called a rig, denoted by N[X].
From the function viewpoint there is also an obvious operation of sub-
stituting one polynomial into another — this is nothing but composition
of functions — and by repeated use of the distributive law (which holds
in N and therefore in the function rig N[X] too), it is easy to see that the
composite of two polynomial functions is again given by a polynomial.
There is also the operation of differentiation: it is deﬁned in the usual
way by
D : N[X]
−→
N[X]
Xn
7−→
nXn−1,
n > 0
X0
7−→
0
and extending N-linearly. (As functions N →N, differentiation has no
direct analytical interpretation, but of course the polynomials could also
be interpreted as functions of a real variable.) We have the usual Leibniz
rule and chain rule:
D(F · G)
=
DF · G + F · DG
D(F ◦G)
=
(DF ◦G) · DG.
1.1.2 Polynomial functors — overview. The notions involved — sums,
products, and exponentiation — make sense also in the category of sets.
Hence a polynomial functor will be something like
Set
−→
Set
X
7−→
A + B×XN + C×XR
for some ﬁxed sets A, B, C, N, R and a variable set X. Many of the things
you can do with good old polynomials make sense also for polynomial
functors: of course you can add them and multiply them, but you can also
substitute them into each other or take derivative, and all these notions be-
have as expected. For example there is a Leibniz rule and a chain rule. In a
[Rough draft, version 2007-05-24 21:36]

1.1 Deﬁnition
15
precise sense, polynomial functors are the categoriﬁcation of polynomials
with natural-number coefﬁcients.
There is also a notion of polynomial functors in many variables, but it
is better treated with some more categorical machinery, so we postpone it
to later in these notes.
1.1.3 Monomials. The simplest polynomials are the (monic) monomials.
In one variable, these are functions of the form
N
−→
N
x
7−→
xn.
Correspondingly, we can consider sets of the form XE:
By deﬁnition, a monomial functor is a functor
Set
−→
Set
X
7−→
XE
for some ﬁxed set E. In other words, it is just a representable endofunctor
on Set, represented by E. If ϕ : X →Y is a map of sets, it’s image is the
map ϕE : XE →YE taking E →X to E →X →Y.
While a monomial is speciﬁed by a single set, of course a sum of mono-
mials will be speciﬁed by a family of sets.
1.1.4 Polynomials. A polynomial functor (in one variable) is by deﬁnition a
functor Set →Set (isomorphic to one) of the form
X 7→∑
b∈B
XEb
where Eb is a family of sets indexed by some other set B. The value of the
functor on a map of sets ϕ : X →Y is the map
ϕ 7→∑
b∈B
ϕE : ∑
b∈B
XE →∑
b∈B
YE
deﬁned term-wise by taking Eb →X to Eb →X →Y.
We prefer to use the symbol ∑for the coproduct of sets, rather than the
usual symbol ∐, because it looks more polynomial-like. We do not require
the indexing set B to be ﬁnite (so in this sense we are allowing polynomials
[Rough draft, version 2007-05-24 21:36]

16
Basic theory of polynomials in one variable
with inﬁnitely many terms), but sometimes it will be convenient to require
all ﬁbres to be ﬁnite. Such a map will be called (LOCALLY?) ﬁnite. This
means that we only allow ﬁnite exponents.
To give a family of sets (Eb)b∈B amounts to giving a set map
p : E →B,
and then Eb denotes the ﬁbre p−1(b). This is just to write E = ∑b∈B Eb. We
say that the family p : E →B represents the polynomial functor.
So to every set map p : E →B there is associated a polynomial
P : Set
−→
Set
X
7−→
P(X) = ∑
b∈B
XEb.
To give a single set is then just to give a map E →1, showing that a
monomial is just special case of a polynomial.
Conversely, given a polynomial functor (something of the form X 7→
∑b∈B XEb then there is a unique map of sets E := ∑b∈B Eb →B. SHOULD
ANALYSE A LITTLE BIT HOW CANONICAL THIS IS. FOR EXAMPLE,
FOR LINEAR FUNCTORS (CF. BELOW) THERE SEEMS TO BE NOT VERY
MUCH HOLD ON THE SET E. . .
IN FACT WE SHOULD MAKE DISTINCTION, JUST LIKE BETWEEN
POLYNOMIALS AND POLYNOMIAL FUNCTIONS: LET US DISTINGUISH
BETWEEN POLYNOMIAL FUNCTORS (THE FUNCTORS Set →Set)
AND POLYNOMIALS (THE REPRESENTING SET MAPS).
1.1.5 Graphical interpretation. The whole point about the theory of poly-
graphical1
nomial functors is to manipulate P : Set →Set in terms of the represent-
ing map p : E →B. It turns out this is intimately linked with the combi-
natorics of trees. The key to understanding these relations is the graphical
interpretation we now present.
The important property of an element in B is really the corresponding
ﬁbre Eb, so we will build it into the picture: we picture an element b ∈B
by drawing b itself as a dot, and represent the ﬁbre Eb as a set of leaves
coming into the dot:
[Rough draft, version 2007-05-24 21:36]

1.1 Deﬁnition
17
b
We have also drawn an edge coming out of the dot. There is no justiﬁcation
at this point of the exposition for having this edge in the picture, but we
are going to need it crucially later on: when we come to polynomials in
many variables, we will need this root edge to carry a label specifying
which variable we refer to. We think of b as an operation. We think of
the leaves as input slots and we think of the root as the output. This is
another reason why we insist on drawing the root edge — we want every
operation to have an output.
The input slots will eventually be ﬁlled: this happens when we evalu-
ate the polynomial functor on a set, as we shall see shortly.
To specify an element in E is the same thing as specifying a ﬁbre and
then an element in that ﬁbre. I.e., specifying b ∈B together with an ele-
ment in Eb. So we can represent an element in E as
b
∗
where the mark indicates which element in the ﬁbre we chose.
We denote by 0 the empty set. Sometimes we also use 0 and the tradi-
tional ∅. We should stick to some convention.
1.1.6 Constant functors. Consider the family given by the map 0 →B.
The corresponding polynomial functor is
X 7→∑
b∈B
E0 = ∑
b∈B
1 = B,
the constant functor X 7→B. As a special case, the map 0 →0 represents
the constant zero polynomial X 7→0. Another important case is 0 →1,
representing the constant polynomial X 7→1.
This gives us a way of interpreting any set as a constant polynomial
functor, just like we can interpret a natural number as a constant polyno-
mial. Furthermore, this is a homomorphism of rigs Set →Set[X], making
[Rough draft, version 2007-05-24 21:36]

18
Basic theory of polynomials in one variable
Set[X] into a Set-algebra. (In fact, the inclusion has a right adjoint which
returns the constant part of a polynomial. This is a right adjoint both for
the big category of polynomial functors and general morphisms and in the
smaller one with only cartesian morphisms. This is because in Set0[X] of
constant polynomials all morphisms are cartesian. . .
We like to use the symbol X as a place holder, a position for plugging
in any given set. Let us now consider a ﬁxed set S. We picture it as a
bunch of dots, one for each element. We can also interpret S as the constant
polynomial functor X 7→S, it is represented by the map ∅→S. Hence
all the ﬁbres are empty, so all operations of this polynomial functor are
nullary. So when we are picturing the elements of S as dots, we are also
thinking of them as nullary operations. This is standard: we think of static
sets as sets of nullary operations for the corresponding constant functor.
1.1.7 Evaluating polynomial functors. Given a polynomial functor P(X) =
P(X)
∑b∈B XEb, the image set comes with a natural projection to B, since it is a
sum indexed by the elements of B. (This is to say that actually P factors
as Set →Set/B →Set where the last functor is the forgetful functor
that forgets about the map to B.) The ﬁbre over b ∈B is the set of maps
Eb →X. Since we have already chosen b at this point of the description we
have the bouquet b, and giving the map Eb →X amounts to decorating
each leaf with an element of X.
In graphical terms, for a ﬁxed set S, the value set P(S) can be pictured
as the set of bouquets like for B, but where each leaf is decorated by an
element in S:
b
x1 x2 x3 . . .
Note that repetition may occur in such a decoration, so in the picture the
xi are not assumed to be distinct.
In general we distinguish between labelling (which means that the label
are unique) and decorations, where repetition can occur. In other words,
labellings are bijections, decorations are maps.
We have already mentioned that S can be identiﬁed with the constant
polynomial functor with value S. We will soon deﬁne the composition of
[Rough draft, version 2007-05-24 21:36]

1.2 Examples
19
two polynomial functor, and as such the set P(S) will be identiﬁed with
the composite polynomial functor P ◦S, which is constant since the ﬁrst
factor is. The graphical interpretations of these two viewpoints match.
If ϕ : X →Y is a map of sets, it is also easy to grasp the image map
P(ϕ): it is the map from X-decorated bouquets to Y-decorated bouquets,
replacing each decoration x by ϕ(x).
1.1.8 Examples. In particular there is a natural bijection
P(1)
P(1) = ∑
b∈B
1Eb = ∑
b∈B
1 = B.
You can interpret this by saying that the bottom set B is the sum of all the
coefﬁcients.
We will often consider the special set 1 = {blank}. If we feed this set
into P the result is the set of bouquets with each leaf decorated by blank.
The idea is of course that we leave the leaf undecorated, so in conclusion
P(1) = B.
1.2
Examples
MAKE DRAWINGS OF EACH OF THE EXAMPLES!
1.2.1 Notation. For each n ∈N, denote by n the set {0, 1, 2, . . . , n −1}. In
particular 0 is the empty set, and 1 is the singleton set (terminal set).
1.2.2 Constant functors. We saw the map 0 →B represents the constant
polynomial functor X 7→B. More generally, for every polynomial functor
one can look for its constant term (possibly zero).
Given any polynomial functor P(X) = ∑b∈B XEb, we can evaluate at
the empty set and ﬁnd
P(0) = ∑
b∈B
0Eb,
but the set of maps Eb →0 is empty unless Eb is empty, in which case there
is exactly one map. So if we set B0 = {b ∈B | Eb = 0}, we ﬁnd
P(0) = B0,
the constant term of P.
[Rough draft, version 2007-05-24 21:36]

20
Basic theory of polynomials in one variable
In other words,
P(0) = {b ∈B | Eb = 0} = B ∖Im p.
Evaluation-at-∅is right adjoint to the inclusion Set ֒→Poly.
1.2.3 Linear functors. Consider now a family given by a bijection E ∼
→B.
Since every ﬁbre is a singleton set, the polynomial functor is the linear
functor
X 7→∑
b∈B
X1 = B × X.
So in graphical terms, the set B consists entirely of unary operations:
B =
(
. . .
)
There is a particularly important case of this: the polynomial functor
represented by the family 1 →1 is the identity polynomial X 7→X.
Linear functors in one variable are not terribly exciting (cf. linear al-
gebra in one variable), but linear functors in many variables provide an
interesting and useful ‘categoriﬁed matrix algebra’, as we shall see in Sec-
tion 8.7.
1.2.4 Afﬁne functors. Consider a family given by an injection E ֒→B.
affine
There is induced a partition of B into two sets B0 and B1: the subset B0 ⊂
B consists of the elements with empty ﬁbre, and B1 consists of the other
elements (which by injectivity have a singleton ﬁbre). The elements in
B0 are the nullary operations, pictured like
; the elements in B1 are the
unary operations, pictured like
. The functor represented by this family
is an afﬁne functor, i.e. the sum of a constant functor and a linear functor:
X 7→∑
b∈B0
X0 + ∑
b∈B1
X1 = B0 + B1×X.
1.2.5 Bottom set and top set. Let p : E →B represent a polynomial functor
bottom-top
P. The bottom set B can be recovered as B = P(1). In a moment we will
deﬁne the derivative P′ of a polynomial functor P, and see that the top set
E is naturally identiﬁed with P′(1).
[Rough draft, version 2007-05-24 21:36]

1.2 Examples
21
1.2.6 Homogeneous polynomials. By deﬁnition, the degree of a mono-
mial XF is the set F. By deﬁnition, a polynomial is homogeneous of degree F
if the representing map is of form B × F →B. (Or more generally if there
are speciﬁed bijections between all the ﬁbres of E →B. Let F be one such
ﬁbre; since all the other ﬁbres are in canonical bijections with this set, any
ﬁbre will do.) Another way of characterising a homogeneous polynomial
functor in terms of its representing map E →B is to say that it is a pullback
of a trivial map F →1 along B →1.
1.2.7 Fundamental example: the free monoid functor. The free monoid
free-monoid
M(X) on a set X is the set of all ﬁnite words in the alphabet X, including
the empty word. (It is a monoid under concatenation of words.) We also
write M(X) = X∗= ∑n≥0 Xn. The free monoid endofunctor
M : Set
−→
Set
X
7−→
X∗= ∑
n≥0
Xn.
is polynomial: the representing map is the ’universal family’
u : N′ →N
whose ﬁbre over n ∈N is the standard n-element set n = {0, 1, 2, . . . , n −
1}. One way to realise N′ is
N′ = ∑
n∈N
n = {(n, i) ∈N × N | i < n}.
Then N′ →N is simply the projection (n, i) 7→n:
N′
↓
N
0 1 2 3 4
Another way to realise N′ is
N′ := N × N
u
−→
N
(a, b)
7−→
a + b + 1
[Rough draft, version 2007-05-24 21:36]

22
Basic theory of polynomials in one variable
N′
↓
N
0 1 2 3 4
In fact, if we think of N as the set of all ﬁnite sets, then we might also
describe N′ as the set of all pointed ﬁnite sets. This is just like in the theory
of moduli of curves: the universal family is the space of pointed things. . .
In any case, the elements of the set N, interpreted as operations, cf. the
graphical interpretation of 1.1.5, are
0
1
2
3
. . .
Since there is precisely one operation of each arity, we don’t really have
to label the nodes in each bouquet. . .
Note that the polynomial ∑n≥0 Xn is the geometric series, so it is tempt-
ing to write
M(X) =
1
1 −X ,
but of course at this point this can at most be a suggestive notation — it
cannot be taken literally since it involves division and negative sets! How-
ever, in Section 3 we shall introduce negative sets and give some meaning
to the expression.
1.3
Other viewpoints
1.3.1 Two fundamental isomorphisms. We use all the time:
∑
b∈B
X = B × X
∏
e∈E
X = XE
These are quite obvious, but a good explanation is nevertheless wel-
come. I think there was one in Gambino-Hyland [23].
[Rough draft, version 2007-05-24 21:36]

1.3 Other viewpoints
23
1.3.2 ’Power series’. In usual polynomials we like to collect all monomi-
alternative
als of the same type (i.e., the same degree, in the one-variable case) and
put a coefﬁcient in front of it to indicate how many there were of it. For
polynomial functors, strictly speaking there can never be any repetition
among the exponents, because the ﬁbres Eb are all distinct sets. We saw
that homogeneous polynomials have the property that there are canonical
identiﬁcations between the ﬁbres, so in this case we allowed ourselves to
write homogeneous polynomials as B×XF.
In the general case what we can do is to take a cruder approach, con-
tenting ourselves with non-canonical isomorphisms, and simply collect
all terms corresponding to sets of the same cardinality. If we assume that
p : E →B is a ﬁnite map, i.e., each ﬁbre is a ﬁnite set, then we can consider
the classifying map
κ : B
−→
N
(1.1)
b
7−→
|Eb|
(1.2)
sending an element b to the cardinality of the corresponding ﬁbre. Putting
Bn := κ−1(n)
we can write B as a sum like this:
B = ∑
n∈N
Bn
and collect terms with isomorphic exponents:
∑
b∈B
XEb = ∑
n∈N ∑
b∈Bn
XEb ≃∑
n∈N ∑
b∈Bn
Xn = ∑
n∈N
Bn × Xn.
(Note that the sign ≃represents a non-canonical isomorphism.)
This sort of expression,
X 7→∑
n∈N
Bn × Xn
might be called a power series, for obvious reasons. It is speciﬁed com-
pletely by giving a sequence of sets (Bn)n∈N. But it would be unfortunate
terminology if ‘power series’ would be a more ﬁnite notion than ‘polyno-
mial’, as it is the case here! so we’ll refrain from that terminology, and in
any case we are not going to exploit this viewpoint very much.
[Rough draft, version 2007-05-24 21:36]

24
Basic theory of polynomials in one variable
Conversely, given a functor X 7→∑n∈N Bn × Xn, that’s the same thing
as being given the sequence (Bn)n∈N, and that in turn is just to give an
abstract ‘classifying map’ κ : B →N. Then we can construct a polynomial
functor E →B by taking E to be the pullback:
E
- N′
B
?
- N
?
We will come back to these viewpoints in the section on collections and
operads.
1.3.3 More abstract approach. The construction of P : Set →Set from
abstract-preview
a set map p : E →B is really a special case of something more general
and fundamental, and in some sense also easier to understand. And in
any case this is the viewpoint that will lead directly to the many-variable
case—we will come back to this viewpoint in Section 8.
Given a set map p : E →B then there is induced a functor p∗:
Set/B →Set/E which sends an object Y →B to the pullback Y ×B E →E.
(Thinking of this as Set B →Set E then this is just the Yoneda embedding
of p, right?) This functor has adjoints on both sides. The left adjoint p! is
easy to describe: it simply sends W →E to W →E →B. (In the pre-
vious paragraph we implicitly computed κ!.) The right adjoint p∗is the
interesting one just now. It is given by
p∗: Set/E
−→
Set/B
W
7−→∑
b∈B
∏
e∈Eb
We
where We denotes the ﬁbre over e of W →E.
Our polynomial functor X 7→∑b∈B XEb is just a special case of that
formula: we start with an abstract set X, and construct a set over E, namely
W := X × E, the pullback of X along the map s : E →1. Now we apply
p∗to get a set over B, and since the map W →E is now just the ’trivial
ﬁbration’ W = X × E →E, we can simplify the formula above a little bit,
recovering our usual formula:
∑
b∈B
∏
e∈Eb
We = ∑
b∈B
∏
e∈Eb
X = ∑
e∈Eb
XEb.
[Rough draft, version 2007-05-24 21:36]

1.4 Basic properties
25
1.4
Basic properties
PERHAPS WE SHOULD NOT LIST THEM HERE, BUT RATHER SCAT-
TER THEM OVER THE NOTES WHERE THEY ARE NEEDED.
Give only easy arguments here. Refer to 8.4 for fancier and more con-
ceptual proofs in the general case. . .
erve-pullbacks
1.4.1 Lemma. A polynomial functor preserves ﬁbre products (and hence monos)
(And more generally limits over diagrams with a terminal object). See Part II for
such general statements.
Example: the free monoid functor M does preserve monos (since this
takes place degree-wise, so it amounts to the observation that if X ֒→Y
is a mono then XE →YE is also mono (CHECK THIS OUT)). This should
also be the general argument.
We call a set map ﬁnite if it has ﬁnite ﬁbres.
preserve-seq
1.4.2 Lemma. The polynomial functor associated to a ﬁnite map E →B pre-
serves inductive colimits (and ﬁltered colimits).
Is the converse also true? that if P preserves ﬁltered colimits, then it is
represented by a ﬁnite map? Yes, this is classical, and we must absolute
give an account of it here. All this can be found in Leinster’s book [34].
Example: the free-monoid monad M: given a directed union like this
A0 ⊂A1 ⊂A2 ⊂. . . , then M(∪Ai) = ∪M(Ai). The ﬁrst set is the set of
all ﬁnite words in the total alphabet ∪Ai. Now any such word has only a
ﬁnite number of letters so it does belong to Ai for some sufﬁciently big i.
1.5
Basic operations on polynomials
As functors into Set, it is clear how to add and multiply polynomial func-
tors, and also how to compose them (i.e. substitute them into each other).
What we need to do is to exhibit how the result is polynomial again, in
a natural way. In other words, we need to explain how to perform these
operations on the level of the representing families.
One important feature of polynomial functions, and one that makes
algebraic geometry so different from other geometries, is that polynomial
[Rough draft, version 2007-05-24 21:36]

26
Basic theory of polynomials in one variable
functions are small and handy: it is the fact that you can represent and ma-
nipulate polynomials in terms of their coefﬁcients, which is a ﬁnite collec-
tion of numbers. This fact is the reason why parameter spaces and moduli
spaces exist in algebraic geometry — for example, the parameter space P5
of all plane conics is just the space of the possible coefﬁcients of a homo-
geneous quadratic equation in three variables, i.e. the equation for a conic.
The same sort of feature will be the dominant theme on our approach
to polynomial functors: polynomial functors are represented by a few sets
and maps encoding exponents and coefﬁcients, and we want to describe
all operations on polynomial functors in terms of such data.
We now introduce sums and products of polynomials. Soon we shall
describe a category of polynomials functors, and then these sums and
products will be the categorical sum and product.
1.5.1 Addition of polynomials. Given two polynomial functors P and Q,
their sum should be the functor
X 7→P(X) + Q(X).
If P is represented by the family p : E →B and Q by q : F →C, then it is
easy to see that the sum of these two families,
p + q : E + F →B + C,
represents the sum of the functors.
Note that this operation is associative (as much as sum is in Set) and
that the neutral polynomial functor for addition is the zero functor (repre-
sented b the family 0 →0).
1.5.2 Multiplication of polynomials. If P and Q are polynomial functors,
product
their product should be the functor
X 7→P(X) × Q(X).
If P is represented by p : E →B and Q by q : F →C, let us write out what
the product functor does (using distributivity):
P(X) × Q(X) =
 
∑
b∈B
XEb
!
×
 
∑
c∈C
XFc
!
=
∑
(b,c)∈B×C
XEb × XFc =
∑
(b,c)∈B×C
XEb+Fc.
[Rough draft, version 2007-05-24 21:36]

1.5 Basic operations on polynomials
27
So we see that the base set is B × C (this is the indexing set for the expo-
nents), and the total space is
∑
(b,c)∈B×C
Eb + Fc
Now this way of writing the total space, just as a sum of all the ﬁbres,
always works, but often there is a more synthetic way of describing the
set. In this case we ﬁnd this more concise description of the top space and
the map:
(E × C) + (B × F)



p × idC
idB ×q
- B × C
Here is a drawing: if P and Q are represented by families drawn like
this:
E
↓
B
F
↓
C
then the drawing of the family representing the product is this:
E × C
+
C
B
B × F
↓
C
B
B × C
[Rough draft, version 2007-05-24 21:36]

28
Basic theory of polynomials in one variable
Note that the multiplication is associative (to the same extent as the prod-
uct is in Set) and that the neutral polynomial functor is the constant poly-
nomial 1 (represented by the family 0 →1)
We shall shortly introduce the category Set[X] of polynomial functors
— the full subcategory of Fun(Set, Set) consisting of polynomial functors.
In here, the product we have just described in of course the categorical
product (since products are computed pointwise in a functor category).
Later we shall mostly restrict ourselves to the subcategory of cartesian
morphisms between polynomial functors. In here the product we just de-
scribed is not the categorical one (the categorical one does not exist in that
case). . . This is essentially like the difference between the category of sets
and all maps and the category of sets and bijections.
1.5.3 Scalar multiplication. There is an embedding Set ֒→Poly: send a
set Λ to the constant polynomial with value Λ. This is a homomorphism of
rigs. This makes Poly a Set-algebra, just like N[X] is an N-algebra. Write
out the laws for this. And note that in terms of representing sets, the scalar
multiplication law is simply Λ times E →B is equal to Λ × E →Λ × B.
This embedding has a right adjoint, which is evaluation at ∅.
1.5.4 Elementary-school ﬂashback. If all this looks complicated then try
to multiply two good old-fashioned polynomials:
(x + x3)(x8 + 1)
=
x · x8 + x · 1 + x3 · x8 + x3 · 1
=
x1+8 + x1+0 + x3+8 + x3+0
[PERHAPS WE SHOULD INCLUDE A COEFFICIENT “5” JUST FOR THE
SAKE OF ILLUSTRATION, AND TO MAKE IT EASIER TO KEEP TRACK
OF THE TERMS.] This is a sum indexed by the product of the exponent
sets, and for each such indexing pair, the actual exponent is their sum—
just as in the general formula.
Since addition and multiplication are deﬁned in terms of addition and
multiplication in Set, it is immediate that the distributive law holds.
1.5.5 Sneak preview of Leibniz’ rule. In a minute we will introduce the
derivative of a polynomial functor. We have already stated that the top set
of a representing map p : E →B can be recovered as P′(1). Of course we
want the Leibniz rule to hold:
(p × q)′ = (p′ × q) + (p × q′)
[Rough draft, version 2007-05-24 21:36]

1.6 Differential calculus
29
Hence we can guess what the top set for (p × q) should be:
= (p × q)′(1) = p′(1) × q(1) + p(1) × q′(1) = E × C + B × F
This is really sort of backwards reasoning, but often mathematics works
like this: before we settle on a deﬁnition of derivation and products we al-
ready require that Leibniz’ rule should hold, so if we can’t arrange the
deﬁnitions for this to hold true, then we aren’t really interested in the
theory. . .
poly-mono
1.5.6 Example. Suppose p : E →B is any polynomial and m : F →1 is
a monomial. Then in terms of set maps, p × m is the map p + (B × m) :
E + (B × F) →B. In terms of the functor it is X 7→∑
b∈B
XEb+F.
Note that the multiplication is associative (reasonably) and that the
neutral functor is the constant polynomial 1.
1.6
Differential calculus
1.6.1 The derivative of a monomial. Given a monomial P(X) = XE, the
derivative should be something like P′(X) = E × XE−1. Here we need to
give a meaning to the expression E −1: it should mean the set E except
for one element, but which element? Well, there are E elements to choose
from, and by ‘coincidence’ there are also E copies of the monomial, so we
can just remove each element in turn. Hence a good deﬁnition seems to be
P′(X) := ∑
e∈E
XE ∖{e}
Note that the derivative of a monomial is no longer a pure monomial: ei-
ther it has a coefﬁcient, or as we see is better is really a polynomial. As such
it is represented by a family with base E. The ﬁbre over e ∈E is a copy of
E with e removed, so the top set of the family is E × E minus the diagonal,
with the ﬁrst projection as map to E. In conclusion, the derivative of P is
represented by the family
E × E ∖∆→E.
We will denote the derivative of P(X) by DP(X) or P′(X) depending
on what seems most convenient in the context.
[Rough draft, version 2007-05-24 21:36]

30
Basic theory of polynomials in one variable
1.6.2 Example. Among the monomials we have the constant X0 = 1, rep-
resented by the family 0 →1. Working directly with the deﬁnition, we
see that the derivative is the empty sum, i.e. the zero polynomial 0. Work-
ing instead with the representing families, we ﬁnd that the derivative is
represented by 0 × 0 ∖0 →0, again the zero polynomial.
1.6.3 Derivative of a general polynomial. In general, given a polynomial
P(X) = ∑
b∈B
XEb, represented by p : E →B, we should just use linearity
and deﬁne
P′(X) := ∑
b∈B ∑
e∈Eb
XEb ∖{e}
This functor is clearly polynomial. The base set of the representing family
is ∑b∈B Eb = E, and the ﬁbre over e ∈E is Ep(e) × Ep(e) ∖{e}. Joining all
the ﬁbres we ﬁnd that the top set of the representing family is
E ×B E ∖∆,
and again the map to E is just the ﬁrst projection, say.
1.6.4 The mark operator.
There is another operator which is simpler:
mark-operator
namely the one sending P to the polynomial X 7→XP′(X). This is the
full ﬁbre product (no diagonal removed). If P is represented by p : E →B
then XP′(X) is represented by the top map
E ×B E
p′
- E
E
?
p
- B
?
Since this square is a pullback square we conclude in particular that
there is a canonical cartesian morphism from X · P′(X) to P(X).
This
will be important later on. WE HAVEN’T DEFINED CARTESIAN MOR-
PHISM YET!!! SEE 2.1.
1.6.5 Lemma. Leibnitz rule holds for differentiation of polynomial functors: given
P and Q, then
(P × Q)′ = (P′ × Q) + (P × Q′).
[Rough draft, version 2007-05-24 21:36]

1.6 Differential calculus
31
Proof. By additivity, it is enough to check the rule when P and Q are mono-
mials, say represented by the sets p : E →1 and q : F →1, respectively.
By 1.5.2, P × Q is then represented by E + F →1, whose derivative is
(E + F) × (E + F) ∖∆
→
E + F.
You can see it all (including the end of the proof) in this picture:
E
F
↓
E
+
F
Since the target set is a sum, the map also splits into a sum: the summand
over E is
E × E ∖∆+ E × F
→
E
which is precisely the family representing P′ × Q. Similarly the F-summand
of the family is
E × F + F × F ∖∆
→
F
representing P × Q′.
2
1.6.6 Mac Laurin series (Taylor expansion at zero) Develop this idea: we
already know that P(0) is the constant term of P. Similarly, direct compu-
tation shows that P′(0) is the set
P′(0) = {e ∈E | e is alone in its ﬁbre}.
Now if P is an afﬁne functor, P(X) = A + B × X, then we can rewrite this
as
P(X) = P(0) + X · P′(0).
So P(0) = A and P′(0) = B.
Next, P′′(0) is the set of pairs (e1, e2) ∈E × E such that e1 ̸= e2 and
p(e1) = p(e2), and such that there are no other elements in that ﬁbre. In
[Rough draft, version 2007-05-24 21:36]

32
Basic theory of polynomials in one variable
other words the set of pairs of distinct elements in E which constitute a
whole ﬁbre.
More generally, P(n)(0) is the set of ordered n-tuples from E that con-
stitute a whole ﬁbre.
This set has a canonical action of Σn. We denote the quotient set by
P(n)(0)
n!
.
Proposition: Assume all ﬁbres of p : E →B has cardinality n. Then
there exists a (non-canonical) bijection
P(X) ≃P(n)(0)
n!
· Xn.
1.6.7 IDEA TO LOOK AT. Have a look at this deﬁnition of differential
quotient: given f : R →R, deﬁne
R × R ∖∆
d1 f
−→
R
(x, y)
7−→
f(x) −f(y)
x −y
This function extends to the whole of R × R, and its restriction to the di-
agonal, R →R × R →R is equal to f ′.
(Similarly, deﬁne d2 f : R × R × R ∖some diagonals →R, (x, y, z) 7→
d1 f (x,y)−d1 f (y,z)
x−z
or something. . .
[Rough draft, version 2007-05-24 21:36]

1.7 Composition of polynomials (substitution)
33
1.7
Composition of polynomials (substitution)
THIS IS SORT OF BORING TO DO IN DETAIL, UNLESS SOME SIMPLIFI-
CATION SHOWS UP (ONE SUCH SIMPLIFICATION IS THE ABSTRACT
APPROACH OF SECTION 8.
1.7.1 Key example: Q is the constant polynomial functor represented by
some ﬁxed set S. Then all the operations are nullary, and the composition
consists in grafting such dots upon the leaves of the elements of B (the set
of operations of P).
1.7.2 Overview. Given set maps p : E →B and q : F →C, we want to
show that the composite of their polynomial functors
Set
Q
−→Set
P
−→Set
is again a polynomial functor (as our experience with good-old polyno-
mials suggests). (In a more polynomial language we could say that we
substitute Q into P.) Also we’ll not be surprised to see that this is a little
bit complicated—already for good-old polynomials we know that such a
substitution can produce a huge polynomial!
Checking this is just a matter of writing out the formulae, rearrange
the terms using distributivity, and see that it is indeed of the correct form,
represented by some set map U →A. In Section 8 we will do this from an
abstract viewpoint. Here we try to do it by hand.
Now before even trying to expand, we can already say what the base
set A is going to be: indeed we know that
A = (P ◦Q)(1) = P(Q(1)) = P(C).
This is the set ∑b∈B CEb. So it remains to ﬁnd the total space U, and de-
scribe the projection map U →A.
Let us start with a graphical analysis. Recall that an element of B is
pictured as a bouquet:
b
[Rough draft, version 2007-05-24 21:36]

34
Basic theory of polynomials in one variable
The set of leaves symbolises the ﬁbre Eb. Similarly, an element in E is a
bouquet just like this, but with one leaf marked. The map E →B just
forgets this mark.
Now look at the composite P ◦Q. According to the above argument,
the base set of P ◦Q is the set P(C). Its elements are pairs (b, α) where
b ∈B and α : Eb →C. In other words, pick an element in B (i.e. such a
bouquet) and for each leaf pick an element in C. USE THE DESCIPTION
OF EVALUATION OF POLYNOMIAL FUNCTORS, DONE IN 1.1.7
IMPORTANT: C is already a set of operations, so in order to keep the
dynamical aspect, we just graft the elements of C on top of the elements of
B.
So P(C) is described in terms of grafting of bouquets: its elements are
bouquets of bouquets, or two-level trees, if you wish, where the level-1
node (the root node) is in B and the level-2 nodes are in C: the operations
of P ◦Q look like this:
b
c1
c2
c3
The conditions on the individual bouquets are still in force: at level
1: the edges coming into dot b correspond to the elements in Eb, and on
the level 2: for each dot c, the incoming edges are in bijection with Fc.
(Since we are in the one-variable case there is no compatibility conditions
on which bouquets can be grafted onto which leaves. When we come to
the many-variable case, there will some bookkeeping to do.)
When we evaluate on some ﬁxed set X, we get these ﬁgures:
b
c1
c2
c3
x1 x2
x1
∈X
∈C
∈B
(where as an illustration we have let two leaves have the same decorating
element x1 ∈X).
[Rough draft, version 2007-05-24 21:36]

1.7 Composition of polynomials (substitution)
35
Now we want to describe U, and if the tree-picture is going to have any
value we want the ﬁbre over such a tree to be the set of its leaves. So for
a ﬁxed such tree (b, α), what are the leaves? Well, they are the union of all
the leaves of the bouquets c, so it is of the form
∑Fc
So what are we summing over? Obviously we are summing over Eb, so
the end result for the ﬁbre over (b, α) is
∑
e∈Eb
Fα(e)
So the global description of U is:
∑
b∈B ∑
α:Eb→C ∑
e∈Eb
Fα(e)
You can also think: U(b,α) = α∗F = {(e, f) ∈Eb × F | α(e) = q(f)}. So
in summary,
U = {(b, α, e, f) | b ∈B, α : Eb →C, e ∈Eb, f ∈F, α(e) = q(f)}.
Here is a picture:
b
B
p
Eb
E
C
q
F
α
1.7.3 Blank. IMPORTANT: 1 = {blank} is the generic place holder.
1=generic
1.7.4 Sneak preview of the chain rule. Of course we want the chain rule
to hold for composite polynomials:
(p ◦q)′ = (p′ ◦q) × q′.
[Rough draft, version 2007-05-24 21:36]

36
Basic theory of polynomials in one variable
Now according to 1.2.5, the top set of p ◦q is naturally identiﬁed with the
bottom set of (p ◦q)′. Hence we expect to ﬁnd
U = (p ◦q)′(1) = (p′ ◦q)(1) × q′(1) = p′(C) × F.
1.7.5 Comparison with the direct description. So what is P′(C) × F?
P’CxF
P′(C) × F = ∑
e∈E
CEp(e)−e × F = ∑
b∈B ∑
e∈Eb
CEb−e × F.
First of all, let’s explain how this is a set over A = P(C) = ∑b∈B CEb. We
ﬁx b ∈B once and for all, so we need to describe a map
∑
e∈Eb
CEb−e × F −→CEb.
Now to describe this map it is enough to describe it on each component.
So we just need a map CEb−e × F −→CEb for each e. So given a punctured
map α′ : Eb −e →C (not deﬁned on e ∈Eb) together with an f ∈F, how
do we extend to a complete map Eb →C? Well, we only need to deﬁne
the value on e, and the only natural thing to do is to take q(f). So now
we have described the map P′(C) × F →P(C). This is the map U →A
we are looking for. It remains to see that it agrees with the elementary
description given above. To this end, just check out the ﬁbre: over a ﬁxed
b ∈B, α : Eb →C in P(C), the ﬁbre consists of pairs α′ : Eb −e →C and
f ∈F for some e ∈Eb. Such that α extends α′, and such that q(f) = α(e).
Now the set of choices of an e ∈Eb and an extension of α′ to the whole
of Eb, that just the set of maps γ : Eb →C. But there is the compatibility
condition in order to map to α downstairs, namely γ(e) = q(f). But this is
precisely the primitive description we gave ﬁrst.
Now let us start from scratch and compute the composite by direct
calculation. Let us start with two easy cases.
1.7.6 Substitution of monomials Given sets m : E →1 and n : F →1,
which we interpret as monomials m(X) = XE and n(X) = XF, then we
can easily compute the composite m ◦n (ﬁrst apply n, then apply m), so n
is inner and m is outer.
(m ◦n)(X) = m(n(X)) = m(XF) = (XF)E = XF×E
[Rough draft, version 2007-05-24 21:36]

1.7 Composition of polynomials (substitution)
37
So the composite is again a monomial, and it just comes from the set map
m ◦n : F × E →1.
The next case is when instead of the monomial m we have a general
polynomial p : E →B. Now
(p ◦n)(X) = p(n(X)) = p(XF) = ∑
b∈B
(XF)Eb = ∑
b∈B
XF×Eb
So the result is the polynomial corresponding to the set map
F × E →B
(Note that we get some strange orders of the factors. This is due to the
fact that we wrote composition from right to left. . . )
All this is to say that substitution is linear in the outer argument. Of
course this is what we expect from plain-old polynomials, and it is also
what we have experienced in the ﬁrst approach where it was clear that all
arguments are ﬁbre-wise for a ﬁxed b ∈B, which is just another way of
phrasing reduction to the case where p is a monomial.
Of course substitution of polynomials is not linear in the inner argument—
in general (xa + xb)e ̸= xae + xbe. Here we get in clinch with distributivity:
We could now treat the general case, but since in fact we have linearity
in the outer variable it is enough to treat the case of an outer monomial
m : E →1 and an inner polynomial q : F →C:
(m ◦q)(X) = m(q(X)) = m
  ∑
c∈C
XFc =
  ∑
c∈C
XFcE
Now we have to use distributivity to turn this into a polynomial on stan-
dard form. Continuing the computation,
  ∑
c∈C
XFcE = ∑
α∈CE
∏
e∈E
XFα(e)
This is the same as we found initially.
To understand this distributivity argument, let us work out a simple
example of plain old polynomials.
1.7.7 Elementary school ﬂashback. Compute (x3 + x5 + f 7)2. In the inner
polynomial, there are three different exponents, so the indexing set for
[Rough draft, version 2007-05-24 21:36]

38
Basic theory of polynomials in one variable
them is 3 = {0, 1, 2}. Put f0 = 3, f1 = 5, and f2 = 7. So now we can write
the inner polynomial as ∑i∈3 x fi.
Now expand by hand:
(x3 + x5 + x7)2
=
x3x3 + x3x5 + x3x7 +
x5x3 + x5x5 + x5x7 +
x7x3 + x7x5 + x7x7
There are 9 = 32 terms in the sum, one for each pair of elements in 3. Each
term is a product of 2 monomials.
To give a pair of elements in 3 is just to give a map α : 2 →3, and
then the corresponding term in the sum is ∏
i∈2
x fα(i). So altogether we have
computed the expansion as
∑
α∈32
∏
i∈2
x fα(i),
which may look a bit complicated but this is how it is. (Rather, argue the
other way around: if you think this formula is complicated, then just write
out the 9 terms separately and you are as happy as when you computed
the expansion by hand.)
1.7.8 Lemma. The chain rule holds:
(p ◦q)′ = (p′ ◦q) × q′.
PROOF OF THE CHAIN RULE.
1.7.9 Partial composition. Let us brieﬂy describe another operation, where
partial
instead of grafting onto all the leaves we only graft onto one leaf. Recall
that the base set P(C) for the polynomial functor P ◦Q is the set of pairs
(b, α) where b is an element in B and α : Eb →C is a map from the ﬁbre,
i.e., a decoration of the set of leaves. Now in the new simpler case of par-
tial grafting, we don’t need decoration on all leaves of b but only on one of
them. So the base is the set of triples (b, e, α) where b ∈B, and e ∈Eb and
α : {e} →C. Now to give this is just to give e ∈E, and c ∈C. So the base
is merely
C × E.
The picture is simple too:
[Rough draft, version 2007-05-24 21:36]

1.7 Composition of polynomials (substitution)
39
b
c
Now we want to say that the ﬁbre over such a thing is the set
leaves(c) ∪leaves(b) ∖{e}
So this is easy: there are two components: either the leaf is one of the
original leaves of the bouquet c—that’s Fc. Or it is one of the original
leaves of b, but not e. So that’s Eb ∖e. In other words, the polynomial
functor is nothing but
Q × P′.
which spelled out is
F × E + C × (E × E ∖∆)
C × E



q×1E
1C×p′
?
This is the sum of all possible one-substitutions. It is not like the Stash-
eff way of specifying the substitution law in terms of several ﬁxed laws ◦i,
which only makes sense if there is an ordering. Since we cannot indicate
in a global uniform manner a speciﬁed element of each ﬁbre, we need to
sum over them all.
[Rough draft, version 2007-05-24 21:36]

40
Basic theory of polynomials in one variable
[Rough draft, version 2007-05-24 21:36]

Chapter 2
Categories of polynomial functors
in one variable
Sec:morphisms
There are two useful categories of polynomial functors: one is the full sub-
category of Fun(Set, Set) consisting of polynomial functors. That is, all
natural transformations are allowed as morphisms between polynomial
functors. We denote it Set[X]. The other alternative is more restrictive: we
only allow cartesian natural transformations. We denote it Poly.
The ﬁrst has better categorical properties (e.g. products), and it works
as a categoriﬁcation of the usual polynomial rigs. However the general
morphisms are tricky to handle in terms of the representing maps E →B,
and some important constructions do not work so well in this generality.
The cartesian ones behave extremely well in term of representing families,
and they are important in the applications to operads and tree structures.
The main result is that every natural transformation between polyno-
mial functors factors as a representable one followed by a cartesian. This
is to say that the functor
Set[X]
−→
Set
P
7−→
P(1)
is a Grothendieck ﬁbration.
2.0.10 More advanced remark. The general notion of morphism corre-
sponds to allowing ‘repetition and omission’ (which makes sense only in
[Rough draft, version 2007-05-24 21:36]

42
Categories of polynomial functors in one variable
cartesian contexts(?), repetition is like using the diagonal map, and omis-
sion is like projection. . . ) This is like allowing any sort of set map between
the ﬁbres of f and the ﬁbres of g. To restrict to cartesian morphisms is to
allow only bijections between the ﬁbres of f and g. That is: no repetition,
no omission: every element must be used precisely once. . .
We start with the cartesian case.
2.1
Polynomial functors and cartesian morphisms
cartesian
Deﬁnition. If C and D are categories with ﬁbre products, given two func-
tors F, G : C →D, a natural transformation u : F ⇒G is cartesian if for
every arrow X →Y in C , the naturality square
F(X)
- G(X)
F(Y)
?
- G(Y)
?
is cartesian.
If θ : F ⇒G : C →D is a cartesian natural transformation, and if 1 is
a terminal object in C , then the cartesian naturality square
F(X)
F(!)- F(1)
G(X)
θX
?
G(!)
- G(1)
θ1
?
shows that F is determined by its value on 1 and its relation to G. Indeed,
it is a natural isomorphism
F(X) = G(X) ×G(1) F(1).
2.1.1 Notation. Up to now we have often drawn diagrams of polynomial
functors vertically, in order to better visualise the idea of ﬁbre. Now we
shall turn the pictures 90 degrees and picture maps E →B horizontally.
This is more practical, and prepares the way for the multi-variable case. . .
[Rough draft, version 2007-05-24 21:36]

2.1 Polynomial functors and cartesian morphisms
43
cartNatTrans
2.1.2 Proposition. Given two polynomial functors P and Q, represented by p :
E →B and q : F →C respectively. Then the cartesian natural transformation
from Q to P correspond precisely to cartesian squares
E
p - B
F
α
?
q
- C
α
?
Proof. Given a pullback square
E
p - B
F
α
?
q
- C
α
?
we construct canonically a natural cartesian transformation A : P ⇒Q:
we must deﬁne for each set X a map
∑
b∈B
XEb →∑
c∈C
XFc.
Since the square is cartesian, for each b ∈B there is a canonical isomor-
phism Eb ∼
→Fα(e). The inverse of this isomorphism induces an isomor-
phism XEb
∼
→XFα(e).
Since we have such a map for each b ∈B we
have deﬁned the wanted map. To check naturality with respect to a map
ϕ : X →Y, it is enough to check for the c-summand: here it is obvious that
this square commutes and it is even cartesian:
XEb
- XFα(b)
YEb
?
- YFα(b)
?
—the horizontal maps are isomorphisms! In fact it follows readily from
this, that also the general naturality squares are cartesian: when setting all
the sum signs, each ﬁbre for the horizontal maps are locally isomorphisms:
[Rough draft, version 2007-05-24 21:36]

44
Categories of polynomial functors in one variable
for each c ∈C, the inverse image of XFc is ∑b∈α−1(c) XEb. And each Eb is
isomorphic to Fc. Hence, locally at c, the map is just the second projection
from the product α−1(c) × XFc.
A more down-to-earth explanation: to give a cartesian morphism is to
give a map u : B′ →B together with a bijection E′
b′ ∼
→Eu(b′) for each
b′ ∈B′. So it’s about setting up bijections between the exponent sets.
Conversely, given a cartesian natural transformation, we construct a
pullback square. In fact we can do better, as in the next lemma.
2
FtoP
2.1.3 Proposition. If P : Set →Set is a polynomial functor represented by
p : E →B, and F : Set →Set is any functor with a cartesian natural transfor-
mation θ : F ⇒P, then F is also polynomial (i.e. isomorphic to one such), and F
and the morphism to P is represented by
E ×B F(1)
- F(1)
E
?
- B = P(1)
θ1
?
Proof. We claim E ×B F(1) →F(1) is naturally isomorphic to F, and that
the square represents θ. Indeed, we can compute the value of F on X as
F(X) = P(X) ×B F(1) = ∑
b∈B
XEb ×B F(1).
On the other hand, the new polynomial functor we constructed is
X 7→∑
f ∈F(1)
X(E×BF(1)) f = ∑
f ∈F(1)
XEθ1( f)
which is the same.
FINISH THIS PROOF AND CLEAN IT UP.
2
kappa-not-unique
2.1.4 Example. (Cf. Example 1.2.7.) For any ﬁnite map p : E →B, the
classifying map (1.1) extends to a cartesian square
E
- B
N′
?
- N
κ
?
[Rough draft, version 2007-05-24 21:36]

2.1 Polynomial functors and cartesian morphisms
45
and hence a cartesian morphism from P to the free monoid functor M. So
the universal property can be restated by saying that every ﬁnite poly-
nomial functor has a natural transformation to M.
NOTE HOWEVER
that this natural transformation is rarely unique, because although κ is
uniquely deﬁned, the map in the left-hand side of the diagram is not!
2.1.5 Example. Another obvious example of such a pullback square is
E ×B E
- E
E
?
p
- B
?
The two horizontal maps represent polynomial functors and the square
represents a cartesian natural transformation between them. We saw in
1.6.4 that the top functor is X · P′(X).
2.1.6 KEY REMARK. The horizontal composition of two cartesian natural trans-
circcart
formations (between polynomial functors) is again cartesian. This is a conse-
quence of the fact that polynomial functors preserve pullbacks.
2.1.7 Some elementary remarks on set maps and bijections. It is a triv-
iality that if two linearly ordered ﬁnite sets are isomorphic (as linearly
ordered sets) then the isomorphism is unique. An ordering is just a ﬁxed
bijection with some ﬁnite ordinal ord n, so the remark is that the category
FinBij/ ord n is discrete: between any two sets there is at most one bijec-
tion over ord n. Now orders are not the only way of ﬁxing things. For any
set B, the category Bij/B is discrete.
(Note on terminology: discrete means no non-identity arrows Rigid means
that for any two objects there is at most one isomorphism. This is equiva-
lent to saying that each object has a trivial group of automorphisms. For
groupoids, the two notions coincide.)
THE FOLLOWING SEEMS TO BE COMPLETE NON SENSE. I DON’T
KNOW WHAT I EVER MEANT BY THIS: For essentially the same reason,
if we ﬁx a polynomial functor P, then the category Poly/P of polynomial
functors with a cartesian map to P is rigid. In fact we show that it is equiv-
alent to the category Set/B.
[Rough draft, version 2007-05-24 21:36]

46
Categories of polynomial functors in one variable
unique-pullback
2.1.8 Remark. We have seen by example that in a pullback square
F1
- C1
F2
?
- C2
φ
?
there may be many different maps F1 →F2 making the diagram commuta-
tive. But if both F1 →C1 and F2 →C2 have a cartesian morphism to some
ﬁxed E →B, and φ is required to commute with this, then the extension to
F1 →F2 is unique. Indeed, ﬁbrewise over b ∈B the map has to commute
with the bijections (F1 →E)b and (F2 →E)b, hence is unique.
Key observation to put somewhere explicitly:
To say that a square of sets
E′
p′
- B′
E
ψ
?
p
- B
ϕ
?
is cartesian is to say that for each b′ ∈B′, the map ψ restricts to a bijection
between the ﬁbres E′
b′ and Eφ(b′).
Note crucially that giving the cartesian square speciﬁes those bijections.
But just from the maps φ and p we cannot know which bijection: differ-
ent choice of the pullback give different bijections. Choosing a pullback
amounts to choosing some bijections. It is crucial that we choose and ﬁx a
speciﬁc pullback. Different choices of pullback give different bijections.
So ψ is characterised as being ﬁbrewise a bijection. Note that since φ is
not necessarily surjective, it can happen that some ﬁbre of p is ridiculously
large and does not correspond to anything up in E′. The ﬁbres over points
in B not in the image are not part of any bijection.
We shall have a look at the slice categories of Poly.
2.1.9 Proposition. For a ﬁxed polynomial functor P represented by E →B, the
slice category Poly/P is naturally equivalent to Set/B.
[Rough draft, version 2007-05-24 21:36]

2.1 Polynomial functors and cartesian morphisms
47
2.1.10 Remark. If we understand by polynomial functor any functor iso-
morphic to one given by one of those diagrams, then the functor should
be described as Q/P 7→Q1/P1 ∈Set/P1.
Proof. We have the obvious functor Poly/P →Set/B which to a cartesian
square
W
- V
E
?
- B
?
associates the map V →B. This functor is canonically given. In the other
direction we can associate to any map V →B the pullback square
E ×B V
- V
E
?
- B
?
However, for this to make sense we need to choose pullbacks. . . It might
not be strictly functorial but only a pseudo-functor in some suitable 2-
categorical setting. . . Assuming we have this, the universal property of the
pullback ensures that the two functors deﬁne an equivalence of categories.
A better proof would consist in showing that the forgetful functor is
fully faithful. It is obviously surjective, thanks to the pullback construction. . .
2
Remark: in particular, all slices of Poly are toposes. Poly itself is not
since it does not have a terminal object. Later we investigate pullbacks
and products. It seems that Poly has many features in common with the
category of topological spaces and etale maps. [The product of two spaces
X and Y in this category is the space of germs of etale maps from X to Y
(which is canonically isomorphic to the space of germs of etale maps from
Y to X). In particular, the product is the empty space in many cases.]
2.1.11 Derivatives? Given a cartesian morphism p ⇒q, then there is in-
duced a morphism p′ ⇒q′.
I think this is not true for arbitrary morphisms. . . ?
[Rough draft, version 2007-05-24 21:36]

48
Categories of polynomial functors in one variable
Products in Poly
IMPORTANT: Observe that the category Poly of polynomial functors and
cartesian natural transformations does not have products!
IT DOES. THEY ARE A BIT DEGENERATE. THEY ARE DESCRIBED
IN SOME HANDWRITTEN NOTES.
2.2
General maps between polynomial functors
2.2.1 Categories of polynomial functors. Polynomial functors form a cat-
egory denoted Set[X] by taking the arrows to be all natural transformation
between them. We see that Set[X] is a distributive category.
2.2.2 Finite polynomial functors. [CHECK IF THIS IS GOOD TERMINOLOGY. . . ]
Call a polynomial functor ﬁnite if the representing family consists of two
ﬁnite sets; this means that all exponents and coefﬁcients are ﬁnite. Let
FinSet[X] denote the full subcategory of ﬁnite polynomial functors.
In analogy with 0.0.3 we have:
2.2.3 Theorem. The Burnside rig of FinSet[X] is N[X].
The proof follows readily from the alternative description of ﬁnite poly-
nomial given in 1.3.2: every ﬁnite polynomial functor is isomorphic to a
functor of the form
X 7→∑
n∈N
Bn × Xn
with only ﬁnitely many Bn non-empty. Clearly, these ‘normal-form’ poly-
nomials correspond precisely to good-old natural-number polynomials.
But our goal in this subsection is to describe natural transformations of
polynomial functors in terms of their representing families.
2.2.4 Preliminary heuristic discussion. Let P be a polynomial functor rep-
resented by p : E →B, and let Q be represented by q : F →C. The ques-
tion we ask is how to describe the natural transformations P ⇒Q in terms
of the representing maps?
[Rough draft, version 2007-05-24 21:36]

2.2 General maps between polynomial functors
49
A ﬁrst guess might be that natural transformations should correspond
to commutative squares
E
p - B
F
?
q
- C.
?
This is not true however—in general such a square does not induce a nat-
ural transformation P ⇒Q. We saw in 2.1.2 that if the square is a pullback
square then it works: there is induced a natural transformation, but not
every natural transformation arises in this way.
The problem with commutative squares occurs already in the case of
monomials: Given monomials p and q and a commutative square
E
p - 1
F
?
q
- 1
?
there is no way in general to construct a natural map XE →XF from it.
The only natural map goes in the other direction—in fact by the Yoneda
lemma, every natural transformation XE →XF comes from a map F →E.
Let us take note of this observation in a slightly more general setup:
2.2.5 Representable transformations. Given a commutative square
B=B
E
p - B
F
σ
6
q
- B
wwwwww
then there is induced a natural transformation σ : P ⇒Q:
∑
b∈B
XEb →∑
b∈B
XFb
[Rough draft, version 2007-05-24 21:36]

50
Categories of polynomial functors in one variable
which sends the b-summand into the b-summand—i.e. it is a B-map. We’ll
call such transformations representable.
In fact, since all this is over B, we are just talking about two objects
in the category Set/B and the diagram is nothing but an arrow in this
category. The induced natural transformation is just the image of σ under
the Yoneda embedding.
Back to the idea of squares: while general commutative squares do not
induce natural transformations, the situation is much better with pullback
squares, as we have already seen.
2.2.6 Putting together the pieces. Now we have two ways of inducing
natural transformations: the representable ones and the cartesian ones. Of
course we can compose these two types to obtain new natural transforma-
tions. For example we can compose a representable natural transforma-
tion with a cartesian one: We get natural transformations represented by
diagrams of the form
E
p - B
Z
σ
6
- B
wwwww
F
?
q
- C
?
(2.1)
generalmorphism
We could also compose in the opposite order—ﬁrst a cartesian trans-
formation and then a representable one, like this:
E
p - B
W
?
- C
?
F
6
q
- C
wwwww
Now the crucial remark is that this last composite natural transformation
can be realised by a diagram of the ﬁrst type. The argument goes like this:
[Rough draft, version 2007-05-24 21:36]

2.2 General maps between polynomial functors
51
simply consider the pullback Z = F ×C B. Now this set has maps to W and
B, so by the universal property of the pullback E, there is then induced a
unique map σ : Z →E, and we are back to the standard situation. Of
course it remains to check that the natural transformation induced by this
cartesian-representable composite is the same as the one induced by the
original representable-cartesian one. This is routine.
So any composite of cartesian and representable natural transforma-
tions are of the form of diagram 2.1.
Now we are ready to formulate the main result in this section:
2.2.7 Proposition. Every natural transformation between polynomial functors
factors as a representable transformation followed by a cartesian transformation,
and this factorisation is essentially unique.
In other words:
2.2.8 Proposition. Representable natural transformations and cartesian natural
transformations form a factorisation system in the category Set[X].
This operation of changing a cartesian-representable composite into a
representable-cartesian one describes precisely how the factorisation sys-
tem works.
2.2.9 Factoring a polynomial transformation. We will no show how a
general polynomial transformation can be factored. Let there be given a
natural transformation s : P ⇒Q, i.e. a natural family
∑
b∈B
XEb −→∑
c∈C
XFc.
The ﬁrst set is naturally over B and the second is naturally over C, and the
ﬁrst remark is that each summand maps into a summand. This is just to
take the 1-component of the natural transformation: this gives us the map
B →C. The naturality diagram reads
∑
b∈B
XEb
- ∑
c∈C
XFc
B
?
- C.
?
[Rough draft, version 2007-05-24 21:36]

52
Categories of polynomial functors in one variable
which shows that the map splits into summands.
THE FOLLOWING REMARKS REPRESENT A CUMBERSOME BY-HAND ARGU-
MENT:
More precisely, there is a unique map ϕ : B →C such that the b-component of the
left-hand side maps into the ϕ(b)-component of the right-hand side. In other words, this
diagram commutes:
∑
b∈B
XEb
- ∑
c∈C
XFc
B
?
- C.
?
To see this, we immediately reduce to the case B = ∗, so the left-hand side is the mono-
mial XE. Now consider the special case X = E. We have a map
EE →∑
c∈C
EFc
and we get a canonical map σ : Fc →E (for some c ∈C), deﬁned as the image of idE.
That is, σ := sE(idE). This c is the image of ∗, hence deﬁning the map ϕ : ∗→C. Let us
check that the square commutes. Now σ deﬁnes a natural transformation
XE −→∑
c∈C
XFc
by precomposition with σ, and it is straightforward to check that this natural transfor-
mation is precisely s. Indeed, this follows from the naturality square corresponding to a
map e : E →X:
EE
sE- ∑
c∈C
EFc
XE
?
sX
- ∑
c∈C
XFc
?
Sending idE the lower-left way around the square gives sX(e) while sending the upper-
right way around gives e ◦σ. In fact this is all just a slight variation of the usual proof of
the Yoneda lemma.
So now we have
E
- B
F
- C
?
[Rough draft, version 2007-05-24 21:36]

2.2 General maps between polynomial functors
53
In summary, for each b we have a map XEb →XFϕ(b), and altogether a map
∑
b∈B
XEb →∑
b∈B
XFϕ(b).
Here the right-hand side is nothing but the polynomial functor U deﬁned
by the map
Z := F ×C B →B
so we have found a natural transformation P ⇒U, by the Yoneda lemma
(for Set/B), this is represented by some B-map U →E, i.e. a diagram
E
p
- B
Z
6
- B.
wwwwww
On the other hand, there is a cartesian natural transformation U ⇒Q,
deﬁned by the square
Z
- B
F
?
- C
?
Hence we have factored our natural transformation into P ⇒U ⇒Q.
2.2.10 As a Grothendieck ﬁbration. Consider the category of arrows in
Set, denoted Set2. The objects are arrows a : x →y, and the morphisms
are commutative squares
x
- x′
y
a
?
f
- y′
a′
?
Consider the functor Set2 →Set which returns the target of an arrow
(and the bottom arrow of such a diagram). This functor is a Grothendieck
ﬁbration: the cartesian morphisms are precisely the pullback squares. This
[Rough draft, version 2007-05-24 21:36]

54
Categories of polynomial functors in one variable
means that every morphism in Set 2 factors (uniquely) as a vertical mor-
phism followed by a cartesian one. The vertical morphisms are squares
x
- x
y
?======== y′
?
Hence we see a very strong similarity between Set[X] and Set 2. In
fact, Set[X] is obtained from Set2 by reversing the direction of all vertical
arrows.
2.2.11 Theorem. The functor
Set[X]
−→
Set
P
7−→
P(1)
is a Grothendieck ﬁbration.
2.3
Naturality of the operations
2.4
Composition
2.5
Sums, products, and differentiation
Check carefully that the basic operations are functorial.
Differentiation is not functorial with respect to general morphisms.
Only with respect to carefully morphisms.
THERE IS NOTHING TO CHECK, SINCE SUM AND PRODUCT ARE
JUST SUM AND PRODUCT IN THE FUNCTOR CATEGORY.
We do need to check, however, that substitution is functorial.
2.5.1 Naturality of multiplication. Given cartesian morphisms α1 : p1 ⇒
q1 and α2 : p2 ⇒q2, then there is a cartesian morphism
α1 × α2 : p1 × p2 ⇒q1 × q2.
[Rough draft, version 2007-05-24 21:36]

2.5 Sums, products, and differentiation
55
Concretely, given pullback squares
E1
p1
- B1
F1
α1
?
q1
- C1
α1
?
E2
p2
- B2
F2
α2
?
q2
- C2
α2
?
Then we can form the square
E1 × B2 + B1 × E2
⟨p1×B2,B1×p2⟩
- B1 × B2
F1 × C2 + C1 × F2
α1×α2+α1×α2
?
⟨q1×C2,C1×q2⟩
- C1 × C2
α1×α2
?
It is straightforward to check that this square is again a pullback square.
Question to check: given a pair of more general morphisms, is their
product then again a morphism?
Now that we have a distributive category FinSet[X] of polynomial
functors we can ﬁnally investigate to what extent polynomial functors are
a categoriﬁcation of the polynomial rig N[X]. There are two levels of in-
terpretation: a good-old polynomial can be regarded either as a formal
expression, i.e. a certain conﬁguration of coefﬁcients and exponents, or it
can be regarded as a function from N to N. One shows that two poly-
nomials deﬁne the same function if and only if they are the same formal
expression, i.e. their coefﬁcients and exponents agree.
The same is true for polynomial functors:
2.5.2 Theorem. Two polynomial functors are isomorphic as functors if and only
if their representing set maps are isomorphic (i.e we have a commutative square
E′
≃
- E
B′
?
≃
- B
?
(which is of course automatically cartesian)).
[Rough draft, version 2007-05-24 21:36]

56
Categories of polynomial functors in one variable
I think we more or less proved this above.
We need to provide the intrinsic characterisation of polynomial func-
tors: they are wide-pullback preserving functors which also preserve ﬁl-
tered colimits, and perhaps they should also preserve some more limits. . .
2.5.3 OBSERVATION! Differentiation is not functorial with respect to gen-
eral morphisms! It is only functorial with respect to cartesian morphisms.
Indeed, given a general morphism
E
p - B
Z
σ
6
- B
wwwww
F
?
q
- C
?
if there were a natural transformation between the derivatives, it would
involve a map on bases E →F, and there is no way we can get this map.
In contrast, given a cartesian natural transformation
E
p - B
F
?
q
- C
?
we get at ﬁrst a cartesian natural transformation
E ×B E
- E
F ×C F
?
- C
?
which is cartesian since the original square was. Now if we remove the
diagonals, we are just diminishing the cardinality by one in each ﬁbre,
both upstairs and downstairs, so we still have a bijection on ﬁbres. GIVE
A MORE FORMAL ARGUMENT HERE.
[Rough draft, version 2007-05-24 21:36]

2.6 Algebra of polynomial functors: categoriﬁcation and Burnside rigs 57
2.6
Algebra of polynomial functors: categoriﬁca-
tion and Burnside rigs
INVESTIGATE THIS IN MORE DETAIL:
FinSet is a rig category (= distributive category?) and it sits as a full
coreﬂective subcategory in FinSet[X].
This functor is a rig homomor-
phism.
2.6.1 Theorem. FinSet[X] is the free Set-algebra on one generator.
This should mean: ﬁrst we deﬁne what a FinSet-module is: it is a category
C with ﬁnite sums and equipped with an action Set × C →C . Now
deﬁne a FinSet-algebra to be a monoid in the category of FinSet-modules.
The subtlety is that we have two candidates for the free thing: FinSet[X]
and also the rig of formal expressions ∑n∈N bnXn. Depending on the no-
tion of monoid and also depending on the notion of action, we get differ-
ent results: if we take some deﬁnition like formal iterated binary products
of objects in FinSet with object X, then possibly we get the latter version.
However, we should allow products indexed over arbitrary ﬁnite sets, and
this will lead to FinSet[X], it seems. The proof still remains to be worked
out in detail.
Similarly, Set is a rig category and it injects into the rig Set[X].
2.6.2 Theorem. Set[X] is the free Set-algebra on one generator.
Again, to make sense of this, we need to be more speciﬁc about the def-
initions. With the usual notion of monoid in a Set-module, we only get
the ﬁnitary polynomial functors (since the theory of monoids is ﬁnitary?!)
Since Set has all products, not just ﬁnite ones, it is reasonable of course to
stipulate that its algebras should have all products too, in which case we
probably get Set[X] without ﬁniteness conditions.
Now for the categoriﬁcation result. Since we are supposed to categorify
N[X], of course we should restrict attention to polynomial functors deﬁned
in terms of ﬁnite sets. That is, both E and B are ﬁnite. For the sake of stating
the theorem let us call such polynomial functors ﬁnite.
N[X]-Burnside
2.6.3 Theorem. N[X] is the Burnside rig of the category of ﬁnite polynomial
functors.
[Rough draft, version 2007-05-24 21:36]

58
Categories of polynomial functors in one variable
This extends the usual categoriﬁcation of the natural numbers:
FinSet ⊂- FinSet[X]
N
?
⊂
- N[X]
?
Note that by the results above on preservation of all operations under
isomorphisms (and sometimes under more general functors), it is imme-
diate that this categoriﬁcation accounts for sums, products, substitution,
and differentiation.
2.6.4 Experiment. Just as the result that N classiﬁes ﬁnite sets can be stated
more interestingly as a solution to a moduli problem, try to do the same
for polynomial functors. Deﬁne what a family of polynomial functors is,
over a base that can be any set. We should try to encode the ﬁbres of such
families as ﬁnite set maps. In other words, for each element j ∈J in the
base set, we should have a ﬁnite set map Ej →Bj. In other words, this is
to have set maps
E
B
?
J
?
such that for each ﬁxed j ∈J, the sets Ej and Bj are ﬁnite. This in turn
is just to have a J-tuple of polynomial functors. It is also clear what an
isomorphism of such families is: just an isomorphism on each level.
Then ﬁgure out what the universal family should be, the base should
be N[X]. So just describe the ﬁbre over some arbitrary polynomial, say
3X2 + 4. The corresponding Ej →Bj should have a 7-element set as B, and
over three of the points the ﬁbre should be 2, and over four of the points
the ﬁbre should be empty.
We might try to do this in a linear algebra fashion: since N[X] as an
N-module is spanned by N itself (the monomials, 1, X, X2, . . . ), we might
[Rough draft, version 2007-05-24 21:36]

2.6 Algebra of polynomial functors: categoriﬁcation and Burnside rigs 59
try ﬁrst to describe the ﬁbres over these monomials. The ﬁbre over Xk is
just the set map k →1. The ﬁbre over akXk is just the set map ak × k →ak.
Perhaps we can arrive at a nice global description in the style of those
universal families N′ →N. . .
2.6.5 Other things to work out — routine. We have the category of com-
mutative rigs. Now we also have the 2-category of distributive categories:
the arrows are the functors that preserve ﬁnite sums and ﬁnite products.
The 2-cells are natural transformations compatible with that. Just as N is
the initial object in the category of commutative rigs, so FinSet should
be initial in the 2-category of distributive categories.
However, this is
rather 2-initial: it means that for any distributive category D, the hom cat
Distr(FinSet, D) is contractible. In other words, up to equivalence, there
is only one sum-product preserving functor to D. It is perhaps better ﬁrst
to consider a skeleton for FinSet, namely the category of ﬁnite cardinals
(often denoted Φ by me).
[Rough draft, version 2007-05-24 21:36]

60
Categories of polynomial functors in one variable
[Rough draft, version 2007-05-24 21:36]

Chapter 3
Aside: Polynomial functors and
negative sets
Sec:negative
In this section we look at the possibilities for getting some sort of negative
coefﬁcients and exponents for out polynomial functors. The theory of neg-
ative sets is a whole subject on its own, and this is not the place to give the
detail – and I don’t know so much about it. But there are some very funny
calculations to do. . .
3.1
Negative sets
We have seen that N is the Burnside rig of FinSet and that N[X] is the
Burnside rig of FinSet[X]. Can we ﬁnd a distributive category D whose
Burnside rig is Z? This question was posed and studied by Schanuel [43],
to whom is due all the results of this section. The presentation owes a lot
to John Baez [6].
It turns out fairly quickly that there can be no such distributive cate-
gory, so it is necessary to rephrase the question.
3.1.1 Lemma. In any distributive category, if X0 + X1 ≃0 then also X0 ≃
X1 ≃0.
Proof. Given an isomorphism ϕ : X0 + X1 →0, let ϕi be deﬁned by the
[Rough draft, version 2007-05-24 21:36]

62
Aside: Polynomial functors and negative sets
diagram
X0 ⊂
i0 - X0 + X1  i1
⊃X1
0
ϕ
?
ϕ1

ϕ0
-
But in a distributive category, every initial object is strict, in the sense that
any arrow into it is invertible. Hence ϕ0 and ϕ1 are invertible.
2
3.1.2 Corollary. The Burnside rig of a distributive category is never a ring.
(Except if the distributive category is trivial, in which case also its Burnside
rig is trivial, and hence a ring. . . )
Of course that’s a serious blow to the project, but Schanuel [43] ob-
served that we can ask for slightly less. If we can’t ﬁnd a distributive
category with an object X such that X + 1 ≃0, then we might at least be
able to ﬁnd X such that X + 1 ≃0 modulo something.
The following heuristic discussion is borrowed from Baez [6].
3.1.3 Islands and bridges. A ﬁnite set is a bunch of isolated islands,
•
•
•
So what is a negative island? A bridge
is a negative island: if you place
it between two islands you get just one island! According to this principle,
setting two bridges between two islands should give zero islands, which
you could also explain by saying that a lake is a negative island, and a pair
of bridges between two islands is the same as one island with a lake. Now
if you join the two bridges. i.e. ﬁll the lake between them, then you are left
with one island again, so a bridge-between-bridges counts as a negative
bridge, i.e. counts as 1. With this alternating behaviour it begins to look
like the Euler characteristic: set
χ(•) = 1,
χ(
) = −1
and demand compatibility with sums and products.
[Rough draft, version 2007-05-24 21:36]

3.1 Negative sets
63
This version of the Euler characteristic, which is called the Euler mea-
sure, agrees with the ordinary topological Euler characteristic for compact
spaces, deﬁned as ∑∞
i=0 hi(X), but in general is deﬁned using cohomology
with compact support, assuming this sum converges, which is the case for
most nice spaces. One class of spaces where the Euler measure is well-
deﬁned, and not too difﬁcult to treat, are the polyhedral sets:
3.1.4 Polyhedral sets. A polyhedral set is a subset of Rn (for any n) ob-
tained from half-spaces by taking intersections, unions, and complements.
A polyhedral map between polyhedral sets A ⊂Rm and B ⊂Rn is a map
whose graph is a polyhedral set (in Rm+n). This means that the map may
well be discontinuous, but that it is linear on each of ﬁnitely many pieces
that make up the domain A. Here is an example of the graph of a polyhe-
dral map from the open interval to itself
(In fact you observe that this is an invertible polyhedral map.)
Let P denote the category of polyhedral sets and maps. It is easy to
verify that this is a distributive category: the sum is the disjoint union, so
you need some convention of how to embed realise this in some Rk. For
example, given A ⊂Rm and B ⊂Rn, deﬁne A + B ⊂Rm+n+1 to be
A×{0}×{1} ∪{0}×B×{2}
or some other convention. The product is just the cartesian product, as
polyhedral set in Rm+n.
We now restrict attention to the full subcategory P0 of bounded polyhe-
dral sets, i.e. those polyhedral sets that ﬁt into a ball in some Rn.
A pure d-cell is a polyhedral set isomorphic to the product of d copies
of the open unit interval I. The pure 0-cells are just points. It is a fact
that every bounded polyhedral set admits a pure cellularisation, i.e. can
be written as a disjoint union
A =
∞
∑
d=0
adId
[Rough draft, version 2007-05-24 21:36]

64
Aside: Polynomial functors and negative sets
of ad copies of pure d-cells Id.
With • and
we can generate all bounded polyhedral sets. The open
interval I plays a key role, as a model for −1. The crucial observation is
that it satisﬁes the equation
I ≃I + 1 + I,
which is just to say that we can cut the interval into two intervals with a
‘gluing point’ in the middle:
=
+ • +
This relation shows that
is as good a model for −1 as we can hope for:
while 0 =
+ 1 is impossible, at least we have
=
+ • +
,
so we can also say that we have found a −1 module additive cancellation.
3.1.5 The Euler measure. CLEAN UP THE NEXT COUPLE OF PARA-
GRAPH
Intuitively, the Euler measure should work just like the Euler charac-
teristic, except that you should use only open cells. We want it to count Id
as (−1)d, and of course it should be ﬁnitely additive and multiplicative.
The existence of such a measure goes a long way back in history and is
known as the
3.1.6 Hadwiger-Lenz lemma. (Euler and Rota) There exists a function χ :
P0 →Z which is ﬁnitely additive and multiplicative, and with χ(•) = 1, and
χ(I) = −1.
The Euler measure is also called the combinatorial Euler characteristic, and
Baez calls it the Euler-Schanuel characteristic, but in fact the function ﬁts
naturally into geometric measure theory.
The Euler measure can also be characterised in terms of cellularisa-
tions: deﬁne if A = ∑∞
d=0 adId, deﬁne χ(A) = ∑∞
d=0(−1)dad, but then you
have to prove that it is independent of choice of cellularisation, and that
once again is a bit similar to proving that the map from E is injective. . .
The construction of Schanuel, and also Rota, to prove the Hadwiger-
Lenz lemma, uses Euler integration. Note ﬁrst that polyhedral maps have
polyhedral ﬁbres: indeed, the ﬁbre can be seen as a linear section of the
[Rough draft, version 2007-05-24 21:36]

3.1 Negative sets
65
graph, which is polyhedral by deﬁnition of polyhedral map. Next, observe
that a Z-valued polyhedral map must have ﬁnite image.
Now suppose we are given a measure χ, and a polyhedral map f :
A →Z. The Euler integral of f with respect to χ is deﬁned as
Z
A f dχ := ∑
n∈Z
n χ(An),
where An := f −1(n). Now construct the Euler measure inductively: ﬁrst
deﬁne a measure χ1 for all polyhedral sets of dimension −∞, 0 and 1, by
linearity and the initial requirements χ1(
) = −1, and so on. Now let E
be a 2-dimensional polyhedral set, and let p : E →B denote its projection
to the ﬁrst coordinate axis. Then we have a sort of classifying map
κp : B
−→
Z
b
7−→
χ1(Eb).
Check that this map is polyhedral, but at least it has polyhedral ﬁbres. . .
Now deﬁne the second Euler measure as
χ2(E) :=
Z
B κp dχ1.
And check the axioms
PERHAPS WE SHOULD NOT GO INTO THIS HERE, BUT JUST STATE
AS A THEOREM THAT SUCH AN EULER MEASURE EXISTS. . .
3.1.7 Remark. If X is a ﬁnite set of points, then χ(X) = #X.
If X is compact, then the Euler measure coincides with the topological
Euler characteristic. But in general it does not, and in particular the Euler
measure is not a homotopy invariant. The basic example is of course the
open interval which has Euler measure −1, although it is homotopically
equivalent to a point.
Now you can go on an use polyhedral sets and their Euler measure to
do tricks with negative sets, but it is worthwhile to understand how the
theory relates with Burnside rigs and such.
3.1.8 Theorem. (Schanuel and also Rota.) The Burnside rig of P0 is
N[T]/(T+1+T ∼T)
which we denote by E.
[Rough draft, version 2007-05-24 21:36]

66
Aside: Polynomial functors and negative sets
By the above discussion it is clear that there is a surjection of rigs from
E to the Burnside rig of P0: just send T to the class of the open interval.
The difﬁcult part is to show the map is injective. To this end, we need
some algebraic remarks. The idea is that
fails to be a true −1 because
of lack of additive cancellation. . .
3.1.9 Additive cancellation. The rig N has additive cancellation, and so
has Z:
n + x = n + y
⇒
x = y.
Let Rig± denote the full subcategory of rigs having additive cancellation.
The inclusion functor i : Rig± ֒→Rig has a left adjoint a which to any rig
R associates the quotient rig R/∼, where ∼is the congruence deﬁned by
x ∼y ⇔∃r[r + x = r + y]
The counit for the adjunction is (for each rig R) simply the quotient map
R →R/ ∼. Every homomorphism of rigs R →T, where T has additive
cancellation, factors uniquely through the quotient map R →R/ ∼. This
quotient map is called the Euler measure on a rig, and we denote it
χ : R →R/∼
We also talk about the Euler measure on a distributive category, which of
course is just the Euler measure on its Burnside rig. We shall see shortly
that this gives the Euler measure on P0.
Note in any case that this abstract Euler measure generalises cardinal-
ity, because for the distributive category FinSet, the Burnside rig already
has additive cancellation, so a is the identity in this case.
3.1.10 Lemma. The additive-cancellatiﬁcation of E is Z:
a(E) = Z,
and the Euler measure is T 7→−1.
This is easy to see: we already have the relation 2T + 1 = T, and if we
impose additive cancellation this gives T + 1 = 0, so T goes to −1.
Now notice that there is a well-deﬁned notion of degree in E, since the
relation we divide out by equates polynomials of the same degree. This
deﬁnes a homomorphism of rigs to the rig
D := (N ∪{−∞}, max, +)
[Rough draft, version 2007-05-24 21:36]

3.1 Negative sets
67
where addition is max and multiplication is the natural-number sum. (Note
that the degree of a sum of polynomials is the max of their degrees, and
that the degree of a product is the sum of the degrees.) This rig is called
the dimension rig by Schanuel, and in other contexts it is called the tropical
semi-ring.
With a little work one can ﬁnd in fact that:
3.1.11 Lemma. Two elements in E are equal if and only if they have the same
Euler measure and the same degree. In other words,
E →Z × D
in injective.
It is easy to characterise the image of this map: it is nearly surjective, ex-
cept in dimension −∞and 0: for d = −∞necessarily we have χ = 0, and
for d = 0 necessarily we have χ > 0. Otherwise all values are attained.
With these preparations we see that deﬁning a map from the Burnside
rig of P0 to E, is equivalent to deﬁning maps χ : P0 →Z and d : P0 →D.
The ﬁrst is the Euler measure, as deﬁned geometrically, and the second is
the expected geometric notion of dimension: the dimension of a polyhedral
set A is the largest d for which there exists an injective polyhedral map
Id →A, and we set d(∅) = −∞.
Given these two geometrically deﬁned invariants, we have therefore
deﬁned a map from the Burnside of P0 to E, and from the constructions it
is easy to see that it is inverse to the ‘presentation map’ initially given.
So as a corollary of these results we ﬁnd that:
3.1.12 Corollary. Two bounded polyhedral sets are isomorphic if and only if they
have the same dimension and the same Euler measure.
This may look strange at ﬁrst, since the dimension only depends on the
highest dimension component. So for example, a solid square plus a point
is isomorphic to the sum of two squares.
But note that the whole notion of component is sort of out of place,
because there is no continuity involved anywhere.
You might say that the reason the result is true, is that the highest di-
mensional component gives the necessary space to absorb and rearrange
the lower dimensional pieces. For example, starting with a solid square
plus a point, the solid square can split off a half open square
× closed
[Rough draft, version 2007-05-24 21:36]

68
Aside: Polynomial functors and negative sets
interval, and this new piece in turn is isomorphic to a triangle minus a
vertex. And this vertex we had extra from the beginning, so we get a solid
triangle, which in turn is isomorphic to a solid square. . .
3.1.13 Other models. There are other geometric categories for which the
Euler measure is Z-valued. Schanuel outlines also the examples of the
category of semi-algebraic sets, where instead of generating the geometric
objects by afﬁne inequalities, we use polynomial inequalities. This cate-
gory turns out to have E as Burnside rig. In this case there is no need to
restrict to bounded sets, because the open interval is semi-algebraically
isomorphic to the open real half-line (t 7→t−1 −1). Another example is
the category of ﬁnitely subanalytic sets, again with Burnside rig E.
It is also interesting to consider constructible sets: i.e. the boolean clo-
sure of the set of algebraic varieties in Cn. This time the Burnside rig is
big and complicated, and its Euler measure will not seem to be Z-valued.
However, by dividing out with yet another relation, which is roughly to
force the Fubini theorem to hold, one does get E again. This relation says
that if the ﬁbres of a map A →B have the same measure, then the mea-
sure of B is the product of the measure of A with the measure of the ﬁbre.
(Note that this relation holds already for the Euler measure for the three
categories mentioned above.)
I DON’T REALLY UNDERSTAND THIS. PLEASE READ SCHANUEL,
TO SEE IF YOU UNDERSTAND IT BETTER.
3.2
The geometric series revisited
We saw that the universal family of ﬁnite sets parametrises the free monoid
monad M(X) = ∑∞
n=0 Xn, and we suggested to write it as
1
1−X. Now that
we have negative sets at our disposal, let us make a computation to sup-
port this suggestion. Just like the standard ﬁrst-year calculus proof, let us
multiply M with the polynomial functor H(X) = 1 −X, and see if we get
something like 1.
Let us ﬁrst describe the representing family of H: it is the disjoint union
of the trivial family 0 →1 (which represents the constant polynomial func-
tor 1), and the family
→
which represents the polynomial −X (it
has exponent 1 and coefﬁcient
, hence the family has base
and
singleton ﬁbres). Another heuristic argument: evaluate at 1 to get the base
[Rough draft, version 2007-05-24 21:36]

3.2 The geometric series revisited
69
(that’s −1), and evaluate the derivative at 1 to get the top space (that’s also
−1). Putting the two pieces together we see that H is represented by this
family:
?
Now compute M × H by applying the formula for multiplication of
polynomial functors 1.5.2. The base space B of the product M × H is the
product of the bases, so we get
B = N ×
= ∑
i∈N
= R≥0
Now let us compute the top space: according to the product rule, it is
the sum E = E1 + E2 of two components: the ﬁrst is E1 = N′ ×
with
the projection u × id down to N ×
= R≥0 = B. Here is a picture of
that map:
E1
↓
B = R≥0
The top space can be described as E1 = {(x, i) ∈R≥0 × N | i < x},
and then the map to the base B = R≥0 is just the projection. We see that
over the ﬁrst
⊂R≥0, the ﬁbre is empty, over the next such piece it is
singleton, and so on.
Now the other part of the top space is the base of the ﬁrst factor times
the top space of the second. That space is just E2 = N ×
= ∑i∈N
=
R≥0 ∖N, the positive reals minus the integer points. The map to the com-
mon base B = R≥0 is just the inclusion (corresponding to the fact that
the family representing R is just the inclusion of the open interval into the
half-open):
E2
↓
B = R≥0
[Rough draft, version 2007-05-24 21:36]

70
Aside: Polynomial functors and negative sets
So add this piece to the picture from before, to get something like
E1 + E2
↓
B = R≥0
Hence there is a single empty ﬁbre (over 0 ∈R≥0). Over the ﬁrst
the
ﬁbre is singleton, over the next half-open interval the ﬁbre is of cardinality
2, and so on. So altogether the polynomial functor is
(M · H)(X) = 1 + ∑
n>0
Xn
This is not precisely the constant polynomial functor as we might have
hoped for, but it is so modulo
, and that was in fact all we could rea-
sonably hope for.
Hence we have given a sort of bijective proof of an analytical identity,
by showing that two polynomial functors are isomorphic, up to dimen-
sion reduction. Recall that two polyhedral sets are isomorphic if and only
if they have the same dimension and the same Euler measure. We have
shown that the identity holds up to dimension.
3.2.1 Remark. Note that the base set of the universal family is not a ﬁ-
nite set and that it is not a polyhedral set either. Also, the identiﬁcation
we made, N ×
≃R≥0 is not an isomorphism of polyhedral sets, it is
merely a bijection of abstract sets.
3.3
Moduli of punctured Riemann spheres
in this subsection we consider an example which is interesting since it
combines differentiation of polynomial functors with interpretation in terms
of negative sets.
3.3.1 Moduli of punctured Riemann spheres. Let B(n) denote the moduli
space of Riemann spheres with 3 + n labelled punctures, modulo punc-
ture preserving holomorphic isomorphism, and we let r(n) : E(n) →B(n)
denote the universal family. (The standard notation for B(n) in algebraic
[Rough draft, version 2007-05-24 21:36]

3.3 Moduli of punctured Riemann spheres
71
geometry is M0,3+n, where the subscript indicates genus 0.) Given a 3-
punctured Riemann sphere, there is a unique isomorphism with CP1 ∖{0, 1, ∞},
so clearly B(0) = 1, and the total space of the universal family is just
E(0) : = CP1 ∖{0, 1, ∞}. In view of this, we can ﬁx automorphisms once
and for all, and simply take B(n) to be the space of n labelled punctures
in CP1 ∖{0, 1, ∞}, without having to mod out by anything else. Hence
simply
B(1) = E(0) = CP1 ∖{0, 1, ∞},
and the universal family is the ﬁbred product minus the diagonal:
E(1) = B(1) × B(1) ∖∆,
and in general,
E(n) = B(1) × · · · × B(1)
|
{z
}
n+1 factors
∖all diagonals.
An alternative description, which is the one we shall use, is
E(n) = B(n) ×B(n−1) B(n) ∖∆;
here r(n) : E(n) →B(n) is the projection onto the ﬁrst factor.
In summary, we’ve got a tower of maps
· · ·
- B(3)
E(2)
w
r(2)
- B(2)
E(1)
w
r(1)
- B(1)
E(0)
w
r(0)
- B(0)
1
ww
realconf
3.3.2 Remark. In fact, once we have ﬁxed E(0) as CP1 ∖{0, 1, ∞} and only
consider conﬁgurations of labelled punctured in here, without dividing
out any further, we might as well take E(0) to be any other space or set,
and the construction is the same: B(n) becomes the set of conﬁgurations
of labelled punctures in E(0). One interesting case is to take E(0) to be an
open interval in R.
[Rough draft, version 2007-05-24 21:36]

72
Aside: Polynomial functors and negative sets
3.3.3 The polynomial functors corresponding to r(n). Let R(0) denote the
polynomial functor represented by r(0). It is just the monomial
R(0)(X) = XE(0).
Now the easy observation is that all the others are precisely the iterated
derivatives of this one! The description of r(n) as a projection from a ﬁbre
product minus the diagonal is exactly the deﬁnition of derivative. Hence:
DnR(0) = R(n).
3.3.4 Interpretation in terms of negative sets. We only deﬁned the Euler
measure for bounded polyhedral sets. For the unbounded case, you need
also to assign the value −1 to the open real half-line. If X denotes the open
interval as before, and if we let Y denote the open half line, we have the
relation Y ≃X + 1 + Y. Schanuel shows that this extra relation gives the
Burnside rig of P. Now we should only notice that
E(0) = CP1 ∖{0, 1, ∞} has Euler measure −1.
Intuitively, since the CP1 is compact its Euler measure equals is Euler char-
acteristic, which is 2, and removing three points leaves us with Euler mea-
sure −1. More formally, we are talking about the complex plane minus
two points, and it is easy to cut in into pieces: we get 4 pieces of type
R≥0 × R≥0, four pieces of type R≥0, and one piece
. Hence by additiv-
ity,
χ(E(0)) = 4 −4 −1 = −1.
So we can interpret
R(0)(X) = XE(0) = X−1,
and similarly
R(n)(X)
=
Dn R(0)(X)
=
Dn X−1 = −n!(−X)−n−1.
To do the next one by hand, notice that the ﬁbres of r(1) : E(1) →
B(1) are all Riemann spheres with four punctures, temporarily denoted
F, hence of Euler measure χ(F) = −2. Hence
R(1)(X)
=
∑
b∈B(1)
XE(1)
b
≃B(1) × XF
=
−X−2 = D X−1.
[Rough draft, version 2007-05-24 21:36]

3.3 Moduli of punctured Riemann spheres
73
3.3.5 The easier, bounded version. As noticed in 3.3.2, we might redeﬁne
all E(n) and B(n) to refer to conﬁgurations of labelled punctures in the open
interval. The negative-set interpretations are the same since χ(
) = −1,
and in fact it is an simpler model for those derivatives of X−1, because we
can stay in the category of bounded polyhedral sets. The choice of punc-
tured Riemann spheres was chosen mainly because the audience were al-
gebraic geometers. However there are a couple of other reasons for the
choice: one is that CP1 ∖{0, 1, ∞} can also be viewed as C ∖{0, 1}, which
is the generator (the −1) in the category of constructible sets (after quoti-
enting by the Fubini relation)
[Rough draft, version 2007-05-24 21:36]

74
Aside: Polynomial functors and negative sets
[Rough draft, version 2007-05-24 21:36]

Chapter 4
Algebras
4.1
Initial algebras, least ﬁxpoints
4.1.1 P-algebras. Let C be a category and consider an endofunctor P :
C →C . A P-algebra is a pair (A, a) consisting of an object A of C together
with an arrow a : P(A) →A. A morphism of P-algebras from (A, a) to
(B, b) is just an arrow f : A →B such that this square commutes:
P(A)
P( f )- P(B)
A
a
?
f
- B
b
?
This deﬁnes the category P-alg of P-algebras. The P-algebras are also
called Lambek algebras for P.
4.1.2 Remark. Note that there are no axioms imposed on the structure
map a : P(A) →A. Now if P happens to be a monad, there is another no-
tion of algebra, Eilenberg-Moore algebras: in that case the structure map
is required to satisfy the associative and unit axioms, amounting to de-
manding (A, a) to be a right P-module (well, a left module, in the current
[Rough draft, version 2007-05-24 21:36]

76
Algebras
backwards right-to-left notation for composition):
PPA
Pa - PA 
ηA
A
PA
µA
?
a
- A
a
?
=

In other words, in the case where P is a monad, an Eilenberg-Moore alge-
bra is a Lambek algebra satisfying two extra axioms.
When P is a monad, or if it just has a natural transformation µ : PP ⇒
P, then P(A) is automatically a P-algebra: the structure map is µA : PPA →
PA. If P is a monad, then this is also an Eilenberg-Moore algebra.
The following result (due to Lambek [32]) is very very useful, yet very
easy to prove.
4.1.3 Theorem. (Lambek’s ﬁxpoint theorem.) If (I, i) is an initial object of the
category of P-algebras, then i is an isomorphism.
Proof. The argument concerns the P-algebra (P(I), P(i)). Consider the di-
agram
P(I)
P(u)- P(P(I))
P(i)- P(I)
I
i
?
u
- P(I)
P(i)
?
i
- I.
i
?
The right-hand square is obviously commutative, and this shows that i is a
morphism of P-algebras from (P(I), P(i)) to (I, i). In the left-hand square,
u is the unique P-algebra morphism to (P(I), P(i)) from (I, i); hence by
deﬁnition the left-hand square commutes too. Now since (I, i) is initial,
we conclude that i ◦u is the identity arrow of I. On the other hand, u ◦i =
P(i) ◦P(u) = P(i ◦u) = P(idI) = idP(I); hence u is the inverse to i.
2
4.1.4 Least ﬁxpoints. An object X with an isomorphism P(X) ∼
→X is
called a ﬁxpoint, so the theorem says that an initial algebra is a ﬁxpoint, via
the forgetful functor from P-alg to C . In fact it is the least ﬁxpoint in the
[Rough draft, version 2007-05-24 21:36]

4.1 Initial algebras, least ﬁxpoints
77
sense that it does not contain any proper subalgebras. Indeed, if I is an
initial P-algebra, and X ⊂I is a subalgebra (more precisely, we are given a
monomorphic P-algebra homomorphism f : X ֒→I), then since I is initial,
there is a unique P-algebra homomorphism u : I →X, and the composite
map f ◦i must be the identity map on I. So the monomorphism f has a
section and is therefore an isomorphism.
We will be concerned with the case C = Set. Initial algebras do not
always exist, not even in this case. For example, the functor
Set
−→
Set
X
7−→
2X
cannot not have an initial algebra, because in standard set theory it is not
possible to have a bijection between a set and the set of its subsets. Note
however that this functor is not polynomial. The main result of this chap-
ter will be that for polynomial functors P : Set →Set, initial algebras
always exist.
First let us have a look at some examples.
4.1.5 Example. Given a bijection p : E ∼
→B, the corresponding polynomial
functor is P(X) = B × X. Hence a P-algebra is a set X equipped with an
‘action’ B × X →X. A P-algebra homomorphism is a map compatible
with the actions
B × X
B× f- B × A
X
?
f
- Y
?
It is easy to see that ∅is the initial P-algebra in this case.
4.1.6 Example. Generalising the previous example a little bit: for any sur-
jection E →B, the initial algebra for the corresponding polynomial functor
is ∅. Indeed, P(∅) = ∑b∈B ∅Eb, but all the summands are zero, because
there are no empty ﬁbres. Hence ∅is a ﬁxpoint, and it is obviously the
least such.
(In other words, if there are no nullary operations, then ∅is the initial
algebra.)
[Rough draft, version 2007-05-24 21:36]

78
Algebras
4.1.7 Example. Consider now the inclusion p : ∅→B. The corresponding
polynomial functor is the constant functor P(X) = B. A P-algebra is just a
set equipped with a map from B, so the category of P-algebras is just the
coslice category B\Set of objects under B. The initial algebra is B equipped
with the identity map.
Functoriality of least ﬁxpoints
If u : P ⇒Q is natural transformation, there is induced a functor
u∗: Q-alg
−→
P-alg
[QX →X]
7−→
[PX
uX
→QX →X]
Note that this functor is the identity on the underlying sets.
In particular, if WQ denotes a least ﬁxpoint for Q, then u∗WQ is a P-
algebra. If WP is a least ﬁxpoint for P, i.e. an initial P-algebra, then we
have a unique algebra map WP →WQ. This means that the association of
a least ﬁxpoint to a endofunctor is functorial.
(This simple remark simpliﬁes the discussion in Moerdijk-Palmgren [37],
subsections 4.1 and 4.2: they observe that formation of least ﬁxpoint for
polynomial functors is covariant for cartesian squares and contravariant
for certain triangles. But these are precisely the two generating classes
of natural transformations between polynomial functors, so it amounts to
functoriality with respect to natural transformations.)
4.2
Natural numbers, free monoids
4.2.1 Key example: construction of the natural numbers. Let p : E →B
denote the inclusion of a one-element set into a two-element set—this is
the simplest set map not of the two types treated in the previous examples.
Then the corresponding polynomial functor is the free pointed-set monad,
P(X) = {∗} + X.
The initial algebra for this polynomial functor is N, the set of natural numbers.
This is really the key example to understanding what the notion of initial
algebras is about and what it has to do with induction, so we’ll go through
all the details, from various viewpoints.
[Rough draft, version 2007-05-24 21:36]

4.2 Natural numbers, free monoids
79
4.2.2 Peano-Lawvere axiom for the natural numbers (called Dedekind-
Peano axiom by Lawvere, see for example [33]). We continue with the
polynomial functor P(X) = {∗} + X. A P-algebra is a set X equipped
with a set map {∗} + X →X, in other words, a set X with a distinguished
element x0 ∈X and an endomorphism s : X →X. So P-algebras are
diagrams ∗→X →X.
By the deﬁnition, an initial P-algebra is a P-algebra ∗→N
σ→N such
that for any other P-algebra (X, x0, f) there is a unique ϕ : N →X making
this diagram commute:
N
σ - N
∗
-
X
ϕ
?
f
-
-
X
ϕ
?
(4.1)
Peano-Lawvere
This universal property is precisely the Peano-Lawvere axiom for a nat-
ural number object in a topos. Now we do not want to assume any topos
theory—and we like to wallow in details!—so let us explain this in terms
of the usual Peano axioms for the natural numbers:
4.2.3 Peano’s axioms for the natural numbers. The set of natural numbers
can be characterised as a set N with a distinguished element 0 ∈N and a
successor function s : N →N satisfying
(i) 0 is not a successor
(ii) every element x ̸= 0 is a successor
(iii) the successor function is injective.
(iv) If a subset U ⊂N contains 0 and is stable under the successor
function, then U = N.
Note that (i)+(ii)+(iii) amount to saying that the map
{∗} ⊔N
⟨0,s⟩- N
is a bijection. The last axiom is called the induction axiom.
(These axioms can be expressed in a more formal way, and in particular
you can avoid using ‘not-equal-to’, but in our context the above formula-
tion should sufﬁce. . . )
[Rough draft, version 2007-05-24 21:36]

80
Algebras
4.2.4 Historical remark. These axioms are usually called the Peano ax-
ioms. They were introduced by Giuseppe Peano [40] in 1889, but in fact
they were discovered by Richard Dedekind [19] in 1888 who stated them
as a theorem. Peano explicitly acknowledges that he got the idea from
Dedekind. The Peano-Lawvere axiom is the categorical reformulation of
the axioms, as we shall now see.
4.2.5 The Peano axioms are equivalent to the Peano-Lawvere axiom (in
Set). Suppose we are given (N, 0, σ) satisfying Peano’s axioms. We need
to deﬁne a map ϕ : N →X making the diagram (4.1) commute. For the
triangle to commute we need to set ϕ(0) = x0, and for the square we need
ϕ(σ(n)) = f(ϕ(n)).
(in other words, ϕ(n + 1) = f(ϕ(n))). Now Peano’s axioms allow us to use
these two conditions as deﬁnition—it is deﬁnition by induction! Indeed, by
the ﬁrst three axioms there is no contradiction in this deﬁnition, because
every element in N is either 0 or the successor of a unique element, so we
are not deﬁning the value on a given element twice. Now the induction
axiom ensures that this method exhausts N.
Conversely, given (N, 0, σ) with the universal property. That is, it is
initial among all diagrams ∗→X →X. Well, then Lambek’s theorem
tells us that {∗} + N →N is an isomorphism, so this is already Peano’s
ﬁrst three axioms! The remark about the terminology least ﬁxpoint now
expresses the last Peano axiom.
4.2.6 Finding an initial algebra for the above functor. Given any ﬁxpoint,
i.e. a set S with an isomorphism f : {∗} + S ∼
→S. (I.e., a set satisfying the
ﬁrst three axioms of Peano.) Then construct a set which satisﬁes all four
axioms as follows. Deﬁne U to be the intersection of all subsets Y ⊂S
satisfying f(∗) ∈Y and y ∈Y ⇒f(y) ∈Y. Then (U, ∗, f) satisﬁes all
Peano’s axioms.
Perhaps we can describe U as the colimit (non-disjoint union)
0 ∪{ f(0)} ∪{ f(f(0))} ∪. . .
The existence of a set S with S ≃1 + S is called the inﬁnity axiom. The
argument shows that the inﬁnity axiom is equivalent to the existence of N.
[Rough draft, version 2007-05-24 21:36]

4.2 Natural numbers, free monoids
81
4.2.7 Speciﬁc graphical version. CLEAN UP THIS GRAPHICAL EXAM-
PLE. To be speciﬁc, take B = {stop, continue} and map the unique el-
ement of E to continue. MUCH BETTER TO STICK TO THE GRAPHI-
CAL INTERPRETATION THAT WE KNOW AND WHICH WORKS SO
WELL: THE ELEMENT stop IS THE NULLARY DOT, WHEREAS THE
ELEMENT continue IS THE UNARY ONE-DOT OPERATION. THIS GIVES
IMMEDIATELY THE INTERPRETATION WE WANT:
Now picture the empty set as a line. So f(∅) is either stop (the leaf-
less one-dot tree) or continue (unary one-dot tree) followed by stop.
The natural numbers are the union of all these trees, obtained by grafting
on top. In each case there are two possibilities: stop or continue. But
eventually we stop.
These pictures are really pictures of a certain level of repetition of this
endofunctor—here there seems to be four dots, so this element comes
in degree 4. The natural numbers is the colimit (the union) of all these
possibilities. . .
4.2.8 Remark. Given this characterisation of N, one can proceed to show
that N is a monoid, in fact the free monoid on one generator. Now as
such, there is an obvious generalisation to look for, namely the free monoid
generated by any set S.
4.2.9 Constructing the free monoid on a set as an initial algebra. CLEAN
UP HERE!! In order to generate N, the free monoid on one generator 1, as
least ﬁxpoint, we took the polynomial functor represented by the set map
1 →{∗} + 1. To get the free monoid on S, the set map should be
S ֒→{∗} + S
Indeed, then there is one singleton ﬁbre for each element in S, and in ad-
dition to that, one empty ﬁbre. So the polynomial functor is
FS(X) = 1 + S×X.
[Rough draft, version 2007-05-24 21:36]

82
Algebras
4.2.10 Proposition. The set M(S) (the free monoid on S) is a least ﬁxpoint for
the endofunctor X 7→1 + S×X.
Recall ﬁrst the deﬁnition of M: we have M(S) = S∗= 1 + S + S2 +
S3 + · · · = ∐n∈N Sn.
An FS-set consists of an ’action’ S × X →X and a distinguished el-
ement x0 ∈X, and an FS-map is one compatible with these structures.
Now ﬁrst check that the free monoid S∗is indeed an FS-object: the action
is
S × S∗
−→
S∗
(s, x1 · · · xk)
7−→
sx1 · · · xk
and the distinguished element is the empty word 1 ∈S∗
To check that S∗is an initial FS-object is equivalent to showing that the
free monoid on S is characterised by some Peano axiom like this: there is
a bijection THIS ONLY SHOWS IT IS FIXPOINT, NEED TO SHOW IT IS
INITIAL
1 + (S × S∗) ≃S∗
Given an FS-set X there is a unique FS-map S∗→X: it must send
the empty word to x0, and then all other elements are determined by the
successor property. . .
WRITE THIS PROPERLY
4.2.11 Example. Generalising the natural numbers example a little bit,
consider a pointed set B = {∗} + S (for some set S), with the natural aug-
mentation map
1
−→
B
∗
7−→
∗
The polynomial functor is
P(X) = ∑
b∈B
XEb = X1 + ∑
s∈S
X0 = S + X.
So P-algebras are diagrams S →X →X. Using Lambek iteration we see
that the initial algebra is
∑
n≥0
S = N × S
[Rough draft, version 2007-05-24 21:36]

4.3 Tree structures as least ﬁxpoints
83
Clearly there is an isomorphism S + S × N ≃S × N—by distributivity
S + S × N ≃S × (1 + N) and we conclude by our favourite isomorphism
1 + N ≃N. The diagram is
S
−→
S × N
- S × N
s
7−→
(s, 0) 7−→(s, n + 1)
End of the treatment of the natural numbers. Back to the general situa-
tion.
4.3
Tree structures as least ﬁxpoints
initial
The trees we are going to get in this subsection are quite different from
those used elsewhere in the book. They are trees without boundary. Usu-
ally our trees have input leaves and one output edge, which together form
the boundary. In this section they have neither. We will call them dead trees,
since they have no leaves, or static trees since they represent only nullary
operations (i.e. constants).
4.3.1 Method for constructing the initial algebra. Given an endofunctor
P : Set →Set, suppose it preserves monomorphisms and that it preserves
sequential colimits. Note that all polynomial functors preserve monos (as
a consequence of 1.4.1), and if it is deﬁned by a ﬁnite map then it also
preserves sequential colimits (by 1.4.2).
Start with the map i : ∅֒→P(∅). Now take P on that and continue
like this:
P0(∅)
i֒→P1(∅)
P(i)
֒→P2(∅) ֒→. . .
Since P preserves monos, all these maps are monos, so the colimit is just
the union of all these sets. Now this union is the initial algebra: indeed,
there is an isomorphism
P(∪n≥0Pn(∅)) ≃∪n≥0P(Pn(∅)) = ∪n≥0Pn(∅)
This is Peano’s ﬁrst axiom.
For the second we need to argue that no
previous set in the sequence can work. Suppose we have a monomor-
phism X ֒→∪Pn(∅) with P(X) ≃X. Then we can ﬁnd a section: start
with ∅→X, then we get P(∅) →P(X) ≃X, and in the limit we get
∪Pn(∅) →∪Pn(X) ≃X. Check that this is a section. . .
[Rough draft, version 2007-05-24 21:36]

84
Algebras
4.3.2 Preview: general transﬁnite induction. The general case (the state-
ment that every polynomial functor has an initial algebra) goes in the same
way, except that there is no guarantee that the ﬁrst colimit is a ﬁxpoint! But
then continue to apply the functor again and again and take the colimit of
all that. This may once again not be the ﬁxpoint, but then continue. Even-
tually this will stabilise. Doing this properly requires some nontrivial set
theory, which we brieﬂy review in the end of this section.
4.3.3 Planar binary trees. Consider the map E →B:
{left, right}
−→
{stop, continue}
left
7−→
continue
right
7−→
continue
There is one empty ﬁbre and one ﬁbre of cardinality 2. In other words,
one nullary operation and one binary. Hence the polynomial functor is
P(X) = 1 + X2.
We picture the base set B as consisting of these two operations:
We claim the initial algebra (i.e. the least ﬁxpoint) for this polynomial
functor is the set of planar binary trees.
To compute it, start with P(0): by the graphical approach to polyno-
mial functors, this is the set of all ways of decorating the two bouquets by
elements in the empty set. Since there is precisely one nullary operation,
we have P(0) = {
} = 1.
Next, P(1) is just the base set B, by the standard interpretation 1.1.8,
but in this case the singleton 1 is the speciﬁc set {
} consisting of one
nullary operation, so we are better off keeping within the strictly graphical
interpretation: hence P({
}) is the set of all ways of decorating either
of the two bouquets in B by elements in {
}, so the picture of the two
possibilities becomes
We should also describe the map P(0) ֒→P(1): it is of course just the
inclusion of
into P(1) mapping the nullary bouquet into the nullary
[Rough draft, version 2007-05-24 21:36]

4.3 Tree structures as least ﬁxpoints
85
bouquet. Indeed, since the empty set 0 is a subset of P(0), decorating in 0
is a subset of decorating in P(0).
Next, P(B) consists of the nullary operation together with all ways of
decorating the two-leaf bouquet with
or
This gives 5 possibilities al-
together:
Again the inclusion of B1 into B2 is precisely the one that can be seen in
the drawings: i.e. the two ﬁgures in B1 are included in B2 as the same two
ﬁgures. (Which is just a sign that the drawing conventions are good. . . )
In the next step we get the 1 + 52 = 26 binary tree of height at most 4,
and next the 1 + 262 = 677 binary trees of height at most 5. Clearly the
conclusion is that the union of all that is the set of all binary planar trees
(without free input leaves).
So the least ﬁxpoint for this polynomial functor is the set of binary pla-
nar trees. The planarity comes about because the ﬁbre was {left, right}.
This was sort of cheating or smart, in order to take advantage of the ori-
entation of the paper. More abstractly, the ﬁbre could be any two-element
set, for example {red, blue}, and in that case we would have to specify for
each node which input edge is red and which is blue. It is clear, though,
that we could get the same collection of trees. Hence by abuse of concepts
we say that we get the planar binary trees. But in fact it can often be very
helpful not to be bound to using ordered sets as labels. . .
The equation satisﬁed by planar binary trees is
X = 1 + X2
which expresses that a planar binary tree is either the trivial tree, or other-
wise a pair of planar binary trees.
Notice how the possible node shapes are precisely listed in the cograph
of the map E →B. (See Lawvere-Rosebrugh [33] for the notion of co-
graph.)
4.3.4 Planar trees. Start with our favourite map N′ →N, representing the
free monoid endofunctor M,
X 7→∑
n≥0
Xn
[Rough draft, version 2007-05-24 21:36]

86
Algebras
So there is one operation of each arity n, and each is interpreted as a bou-
quet with n inputs. Combining these freely, iterating the operations, we
construct all planar trees (without input leaves). It is easy to see that the
set T of all such planar trees is a ﬁxpoint. This is just to follow the same
construction as we just applied to planar binary trees.
The last observation reveals something I don’t understand: we have an
isomorphism
T ≃∑
n≥0
Tn
expressing the characterisation that a tree is a sequence of trees, possibly
the empty sequence. Now, in functional terms: we have the equation T =
1
1−T which we REWRITE (CAREFUL HERE!) as
T = 1 + T2.
This is weird! it seems to be the same equation as for binary trees! Well it is
true that any planar binary tree is a planar tree, and hence it might be an-
other ﬁxpoint for the same functor. . . one of these is the least one. . . when
rewriting, perhaps we did some assumption. . . one equation is perhaps a
factor in the other. . . )
THERE IS SOME PAPER BY D. KNUTH ABOUT TREES=BNINARY-
TREES??? WHERE DID I SEE THIS MENTIONED?
4.3.5 Variations. A very interesting variation of the previous examples it
to consider, for any polynomial functor P the functor 1 + P. The extra con-
stant should be considered the polynomial functor represented by 0 →1,
so the unique element in 1 is a nullary operation (as always, we consider
ﬁxed sets as sets of nullary operations). Repeating now the colimit con-
struction for 1 + P we get the following least ﬁxpoint: its elements are the
trees built out of the operations in P and the extra nullary operation from
1, and no free leaves are allowed. If we think of the new nullary operation
as a red dot, then we get the same trees as before but with some of the
stopdots coloured red.
More generally, if we ﬁx a set A, as always thought of as a set of nullary
operations, then the least ﬁxpoint for A + P is the set of dead trees with
stopdots either in A or in the set of nullary operations of P.
BE EXPLICIT ABOUT THE TWO EXAMPLES, BINARY TREES AND
GENERAL PLANAR TREES.
[Rough draft, version 2007-05-24 21:36]

4.4 Induction, well-founded trees
87
Continuing with the example of planar binary tree, and the example M
giving all planar trees, we can easily ﬁgure out what the least ﬁxpoints are
for A + B or A + M. Let’s just work with A + M.
4.3.6 Least ﬁxpoint for 1 + M: live trees. Let us compute the least ﬁxpoint
Fix(A+M)
for X 7→A + M(X). This is a key example. The constant polynomial
endofunctor with value A is represented by the map ∅→A, so the set
A is a set of nullary operations. Hence the set of operations of A + M
is the set consisting of the bouquets (one for each natural number) and
then an extra collection of nullary operations, one for each element in A.
Repeating the colimit construction of the least ﬁxpoint, the ﬁrst step gives
us that (A + M)(∅) is the set of coloured dots: there is one neutral colour
(corresponding to the nullary operation in M) and one dot coloured a for
each element a ∈A. You immediately see that the least ﬁxpoint is the set
of dead trees, where each stopdot (nullary node) has a colour.
But in fact, the example A = 1 is the most important.
EXPLAIN
WHY WE WANT TO USE THE SEPCIAL-PURPOSE SINGLETON SET
1 = {blank}.
In a moment we are going to let A vary, to construct a left adjoint to the
forgetful functor P-alg →Set.
4.4
Induction, well-founded trees
The free-monoid examples (and N in particular) illustrate the importance
of least ﬁxpoints. We see that the notion of ﬁxpoint for an algebra is a
generalisation of the ﬁrst three axioms of Peano. Being in addition the least
ﬁxpoint generalises the induction axiom. We shall formalise the analogy
further.
4.4.1 Deﬁnition of wellfounded trees. In the category of sets, they are
just trees with the property that every node is at ﬁnite distance from the
root. . . The tree as a whole can have inﬁnte height.
The signature of a tree (also called branching type) is the set of possible
kinds of nodes the tree can have. For example the kind could be just ’bi-
nary’, or there coul dbe allowed arbitrary ﬁnite number of incoming edges
at each node, or various inﬁnities could be allowed. In other words, a sig-
nature is a certain set of bouquets. And in other words, a signature is just
[Rough draft, version 2007-05-24 21:36]

88
Algebras
a polynomial functor E →B, where B is the set of bouquets, and the ﬁbre
over each b ∈B is the set of incoming edges to that node.
Hence a wellfounded tree of signature B is a tree that can be obtained
by grafting together bouquets from B. The grafting process may be inﬁ-
nite, but each bouquet appears at some ﬁnite stage of the process. . .
In conclusion, the set of wellfounded trees of signature E →B is pre-
cisely a least ﬁxpoint for the polynomial functor E →B. Or equivalently,
as we shall see in the next section: wellfounded trees of signature E →B
are the operations for the free monad on E →B (CHECK THAT THIS IS
CORRECT, OTHERWISE SOMETHING VERY SIMILAR IS TRUE.)
ˇe
4.4.2 Induction and wellfoundedness. One way to think of a P-algebra X
is as a set X equipped with a family of operations
 µb : XEb →X | b ∈B

so in the natural numbers example there was one nullary and one unary
operation.
If the initial algebra for a polynomial functor p : E →B exists it is
denoted W(p), the set of wellfounded trees of signature p. Of course the
set W(p) depends crucially on p, but in the following couple of paragraphs
we hold p ﬁxed and suppress p from the notation, writing W := W(p) for
simplicity. Since W is a P-algebra, for each b ∈B there is an operation
supb : WEb →W
Initiality of W means that for any P-algebra X, there is a unique P-algebra
map W →X. In the ﬁbre-wise description this means that for any P-
algebra (µb : XEb →X | b ∈B) there is a unique map ϕ : W →X such
that the diagrams
XEb
µb
- X
WEb
ϕEb
6
supb
- W
ϕ
6
[Rough draft, version 2007-05-24 21:36]

4.5 Transﬁnite induction
89
commutes for every b ∈B. This is to say that for every t : Eb →W we
have
ϕ(sup
b
(t)) = µb(ϕ ◦t)
This expresses that ϕ is deﬁned by induction: if we already know the val-
ues of ϕ on the image of all t : Eb →W then the equation deﬁnes also ϕ on
supb(t).
By Lambek’s theorem, P(W) →W is an isomorphism. This means that
every w ∈W is the image of a unique WEb →W for unique b ∈B and
unique t : Eb →W. In other words, every w ∈W is of the form supb(t) for
unique b ∈B and t : Eb →W.
This is the generalisation of Peano’s ﬁrst three axioms: for N the state-
ment is that every natural numbers is of the form f(n) for a unique b ∈
{stop, continue} and t : Eb →B—this is just to say that every element is
either 0 or a successor.
As we noted, initiality of W implies that every subalgebra of W must
be W itself. This can be stated like this: if R ⊂W is such that for every
b ∈B and every t : Eb →W, whenever the image of t is inside R then
supb(t)is also in R. Then R = W.
4.5
Transﬁnite induction
THE TRANSFINITE INDUCTION PROOF THAT EVERY POLYNOMIAL
ENDOFUNCTOR HAS AN INITIAL ALGEBRA—look up details in Borceux.
4.5.1 Ordinals. The ordinals can be characterised as the smallest set with
successor function and supremum. This means that every element has a
successor, and that for every small subset there is a supremum—a smallest
element greater than everybody in the subset. What about the order? Is it
assumed or is it a consequence of the two other structures?
In practice, start with the empty subset of Ord. It must have a supre-
mum which we call 0. Now take the successive successors of 0, to get all
ﬁnite ordinals. This is a small set (we will not go into the subtleties of the
technical meaning of the word ‘small’, but let us just promise that count-
able is small) so it has a supremum, which we call ω. Repeat like this, al-
ternating between creating new elements using successor and supremum.
(Note that this will give us two sorts of ordinals: successors and limits).
[Rough draft, version 2007-05-24 21:36]

90
Algebras
0, 1, 2, . . . ω, ω + 1, ω + 2, . . . ω·2, ω·2 + 1. . . ω2, . . . ω3, . . . , ωω, . . . ωωω
Remark: The limit of all those ω
...
ω
is a famous ordinal called ε0. It
is the ﬁrst ordinal number that cannot be constructed from smaller ones
by ﬁnite additions, multiplications, and exponentiations. It is also the ﬁrst
ordinal that satisﬁes the equation x = ωx.
However, the list of ordinals just goes on forever. . .
Every ordinal can be written in a unique way on Cantor normal form,
as a ﬁnite sum of smaller and descreasing ordinals:
α = α1 + α2 + · · · + αn
with α1 ≥· · · ≥αn.
It is a little bit analogous to the obvious fact that every natural number can
be written in base 10, i.e. as a ﬁnite sum of . . . 10000, 1000, 100, 10, 1.
For the ordinals smaller than ε0, the necessary ingredients are just 0, ω,
sum, and exponentiation. We use the equation ω0 = 1. For example here
is a certain ordinal on Cantor normal form
ωωω+ωω+ω+1+1 + ωω+1 + ω + ω + 1 + 1 + 1.
Recalling that 1 = ω0 we see that it is just a ﬁnite sum of omegas, raised
to different exponent, which in turn are smaller ordinals and therefore are
ﬁnite sums of omegas raised to different exponents, and that every expo-
nentiation terminates with 0 as the most deeply nested exponent.
In conclusion, every ordinal smaller than ε0 is represented by a ﬁnite
rooted tree: a dot represents a sum, and its children are the summands. In
particular a dot without children is the empty sum 0. Each edge represents
ω, and the subtree sitting on top of the edge represents its exponent. So
for example the tree • represents the empty sum 0. The tree
represents
the one-term sum ω0 = 1, the tree
represents ωω0 + ω0 = ω + 1.
The example of normal form given above is represented by the tree
[Rough draft, version 2007-05-24 21:36]

4.6 Free-forgetful
91
These are non-planar trees, but when converting a tree into a normal-
form ordinal we have to order the children of each node according to the
order of the subtrees. . .
The ordinal ε0 was used by Gentzen [24] to prove the consistency of
arithmetics. (We know by Gödel’s theorem that one can not prove the
consistency of arithmetics within arithmetics. But by going out to a large
number system Gentzen was able to prove the consistency. His proof uses
induction indexed by ε0. . . somehow indexing all possible expressions of
arithmetics??)
Now being an ordered set, Ord is just a special case of a category,
supremum is just a special case of colimit. Now let C be a cocomplete
category equipped with an endofunctor F : C →C . Then there is a canon-
ical functor Ord →Cat which preserves colimits and sends the successor
function to F.
4.5.2 Finer theory of colimit preservation. We already observed that if
F preserves sequential colimits, then after iterating ω times we stabilise.
More generally let α be an ordinal, then an α-chain in C is a chain indexed
by chains shorter than α. Then there is some sort of notion of preserving
α-colimits, and that will ensure that the iteration stabilises after α.
Now given a polynomial functor, given by a set map p : E →B. If all
ﬁbres are ﬁnite, then P will preserve ω-chains.
If the biggest ﬁbre Eb is of some cardinality w, then there will be a least
ordinal σ dominating w, and then P will preserve σ-sequential colimits.
4.5.3 Theorem. Every polynomial endofunctor has a least ﬁxpoint.
4.6
Free-forgetful
From now on we let P : Set →Set denote a polynomial functor. Most
of the constructions work for more general endofunctors, but then some
conditions should be put here and there. . .
WE SHOULD RESTRICT ATTENTION TO POLYNOMIAL ENDOFUNC-
TORS
The idea is that the least-ﬁxpoint construction assembles into a functor,
and this functorial construction provides us with better and more dynamic
[Rough draft, version 2007-05-24 21:36]

92
Algebras
trees. Namely, with the help of the least-ﬁxpoint construction we get a left
adjoint F to the forgetful functor U : P-alg →C .
This adjoint pair generates a monad T : = U ◦F : Set →Set the free
monad on P. It has a very explicit description in terms of decorating trees,
and we see that it is in fact a polynomial monad! The types for this poly-
nomial monad are the good dynamic trees.
4.6.1 The free P-algebra functor. The forgetful functor U : P-alg →C has
alg-adj
a left adjoint FP, the free P-algebra functor. This is very general—perhaps
there is a concrete description of it. We will rather assume it exists, and
then slowly discover how it goes.
Suppose C has an initial object ∅. Since FP is a left adjoint it preserves
initial objects, so FP(∅) is an initial algebra, and U(FP(∅)) is a least ﬁx-
point. So if we know the left adjoint, we can use it to compute least ﬁx-
points.
Conversely, we will now assume we know how to construct the least
ﬁxpoint. And in fact we do, although we have not yet proved this. If we
assume P preserves sequential colimits (e.g. P is represented by a ﬁnite
map) then the least ﬁxpoint is the object
[
n∈N
Pn(∅).
This is then U(FP(∅)). So if just we make explicit what its algebra struc-
ture is, then we have discovered the value of FP on ∅. The algebra struc-
ture is the natural isomorphism
P(
[
n∈N
Pn(∅)) −→
[
n∈N
Pn(∅)
4.6.2 Example. Recall from 4.3.6 that if P is the free-monoid monad Set →
Set then the least ﬁxpoint is the set of dead trees. In other words, F(∅) =
trees. And also that the least ﬁxpoint for A + M is the set of dead trees
some of whose dot-leaves are decorated with elements in A.
In general, this same descriptions holds, and the graphical interpre-
tation is clear: the least ﬁxpoint is the set of all dead P-trees, or closed
P-trees: these are all the trees that can be built from the bouquets repre-
senting the set of operations B, with the condition that there are no open
[Rough draft, version 2007-05-24 21:36]

4.6 Free-forgetful
93
leaves left. The condition that everything is closed comes from the col-
imit construction: already in the ﬁrst step we only get contribution from
nullary operations, since these are the only ones that can be decorated in
the empty set. So already here we only get closed stuff, and from here on
we only ever use these as decorations.
We now aim at computing FP(A) for any object A. In a minute we shall
see that the underlying set of FP(A) is a least ﬁxpoint for the endofunctor
X 7→A + PX, so we can compute FP(A) as the union
[
n∈N
(A + P)n(∅).
Now we can repeat the graphical description: the constant A is given by
the polynomial functor represented by the map ∅→A, so all the elements
in A must be interpreted as nullary operations. So in the ﬁrst step in the
colimit construction, computing P(A) we get the union of A with the set
of nullary operations of P. And in the end we get the set of all trees formed
by the operations in P together with the operations in A (all nullary), with
the condition that no leaves are left open.
4.6.3 Constant endofunctors. Consider now a constant endofunctor X 7→
A. Then an A-algebra is just an arrow A →X, and an A-algebra map is
just a triangle
A
X
-

Y
-
In other words, the category of A-algebras is naturally identiﬁed with the
coslice category A/C . In this case it is clear what the free A-algebra on
an object X is: it is just A + X, assuming that C has sums. Indeed, let us
check the bijection
HomC (X, U(R)) ≃HomA-alg(A + X, R),
where A →R is an A-algebra and X is an object of C : but to give an
A-map A + X →R is the same as giving just a map X →R.
4.6.4 Translations of P. We ﬁx an endofunctor P : C →C , and study its
translations,
PA := A + P : C
−→
C
X
7−→
A + PX.
[Rough draft, version 2007-05-24 21:36]

94
Algebras
There is a cartesian diagram of forgetful functors
(A+P)-alg
- P-alg
A-alg
?
- C
?
A PA-algebra is an object K with a map A + PK →K. In other words, is a
triple (K, a, s) where K is an object of C , s : P(K) →K gives it P-algebra
structure, and a : A →K gives it A-structure.
4.6.5 Proposition. The object UP(FP(A)) is a least ﬁxpoint for A + P.
Slightly less precisely, we can say that FP(A) is an initial algebra for A + P,
but for this to make sense we must observe that FP(A) has an A-structure
(and a P-structure: the A-structure is simply the unit for the adjunction:
ηA : A →UP(FP(A)). The P-structure is. . .
Proof. The category (A+P)-alg is naturally identiﬁed with the comma cat-
egory A\P-alg which we now proceed to describe, and it is a general fact
that the pair (FP(A), ηA) is an initial object in this comma category.
2
4.6.6 General fact about adjunctions and comma catgeories. Consider an
adjoint pair
E
C
F
6
⊣U
?
with unit η : idC ⇒UF. Fix an object A in C , and consider the coslice
category A\C . The comma category A\E is deﬁned as the pullback
A\E
- E
A\C
?
- C
?
An object of A\E is a pair (E, u) where E is an object of E and u : A →UE
is an arrow in C . An arrow in A\E from (E, u) to (E′, u′) is an arrow
[Rough draft, version 2007-05-24 21:36]

4.6 Free-forgetful
95
ϕ : E →E′ such that
A
UE
Uϕ
-
u

UE′
u′
-
4.6.7 Lemma. (FA, ηA) is an initial algebra in A\E .
Proof. Given any (E, u) in A\E , the maps from (FA, ηA) to (E, u) are maps
v : FA →E such that
A
UFA
Uv
-
ηA

UE
u
-
but this characterises precisely v as the map FA →E correponding to
u : A →UE under the adjunction bijection Hom(FA, E) ↔Hom(A, UE).
2
To ﬁnish the proof of the Proposition, take E = P-alg. It is clear from
the general description of the objects and arrows in A\E that it is naturally
identiﬁed with (A+P)-alg, hence the proposition follows.
4.6.8 When P is a monad. We already observed that when P is a monad,
then P(X) is naturally a P-algebra. In that case there is a natural map of
P-algebras F(X) →A(X) (natural in X). Indeed, by adjunction
HomP-alg(FX, PX) ≃HomC (X, PX),
and in here we have ηX : X →PX.
(You might also try to ﬁnd this map directly by ﬁnding a map ∪(A +
P)n(∅) →P(A). In an case you need the unit.
4.6.9 The functor TP. We now know the value of TP on any set A: it is
the least ﬁxpoint for the functor A + P, and we have described it explicitly
as the set of trees made from the operations in P, together with special
stopdots decorated in A.
Now we vary the set A. We should also indicate what TP does on
arrows: given a set map from ϕ : A →B, the image arrow is simply the
[Rough draft, version 2007-05-24 21:36]

96
Algebras
map that sends a trees with A-stopdots to the same tree with B-stopdots,
replacing a stopdot a ∈A by ϕ(a).
Since we are now varying the decorating set A, we might perhaps
rather think of those variable decorations as empty slots where any set
A can be thrown in. So what is the generic set of trees? Well, that’s just
TP(1), where like in 1.7.3 we think of the label 1 as blank. Since we leave
the input open, we represent it by a dotless line.
Slogan: 1 means blank
So we think of T(1) as the set of trees made out of the operations in P
and one extra operation, which is in fact nullary, but since we are going to
use it for decorations, we prefer to think of it as an open leaf. So there is
no longer any requirement that all leaves are closed. If the original poly-
nomial functor is represented by E →B, denote by B∗: = T(1), the set
of these generic, dynamic trees. Let E∗denote the set of such trees with a
marked input leaf, i.e. one of the 1-stopdots singled out.
The conclusion of this whole discussion is
4.6.10 Theorem. TP itself is a polynomial functor, represented by E∗→B∗.
Indeed, TP applied to a set A is the set of all ways to decorate the
generic trees TP(1) by elements in A. This is the description we found in
the construction of TP, and it is precisely the description of the polynomial
functor E∗→B∗.
This new polynomial functor TP, the free monad on P: in general there
is no map TP →P. These maps are in one-to-one correspondence with
maps B∗→B. To have such a map we need extra structure: in fact if P is
a monad then we do precisely have such a map!
4.6.11 Example. If M : Set →Set is the free-monoid monad. The value
of M on a set X is the set of planar bouquets with leaves decorated in
X. An M-algebra is a set X equipped with a map ∑n∈N Xn →X. The
free M-algebra functor associates to a set X the set of planar trees with
leaves decorated in X. Note that in M(2) there are two different two-leaf
bouquets with leaves decorated in 2: because Eb is a speciﬁed set, and we
study maps Eb →X. . . XXXXXXXXXXXX
????This is precisely the polynomial functor represented by E∗→B∗.
4.6.12 Remark. Important remarks: let U : P-alg →Set denote the forget-
ful functor from the category of Lambek algebras. The category of Lambek
[Rough draft, version 2007-05-24 21:36]

4.6 Free-forgetful
97
algebras is often denoted (P : Set). If this functor has a left adjoint F then
it is monadic. This means that P-alg is equivalent to the Eilenberg-Moore
category Set T, where T : = U ◦F. [11, Ch.9,Prop.1]. Furthermore, in this
case T := U ◦F. is the free monad on P [11, Ch.9,Thm.3].
[Rough draft, version 2007-05-24 21:36]

98
Algebras
[Rough draft, version 2007-05-24 21:36]

Chapter 5
Polynomial monads and operads
5.1
Polynomial monads
Cartesian monads
5.1.1 Monads. If C is a category (for example the category of sets), then
there is a category End(C ) whose objects are the endofunctors C →C ,
and whose arrows are the natural transformations. The composition op-
erator ◦turns End(C ) into a (strict) monoidal category; the unit object is
the identity functor IdC . By deﬁnition, a monad is just a monoid P in the
monoidal category (End(C ), ◦, IdC ). Concretely this means there is given
a natural transformation µ : P ◦P ⇒P, which is an associative composi-
tion law, and it has a unit η : IdC ⇒P.
5.1.2 Cartesian monads. A monad M : C →C is cartesian if it preserves
cartesian products and if M ◦M →M and I →M are cartesian natural
transformations.
5.1.3 Examples. The free-monoid monad is cartesian. The free semi-monoid
monad is cartesian, and the pointed set monad is cartesian. The veriﬁca-
tion of these facts is easy since we know they are polynomial functors: the
explicit graphical description makes is easy to check that µ and η are carte-
sian. in the case of the free-monoid monad: M itself has as operations the
set of bouquets, and M ◦M has as operations the set of two-level trees.
The multiplication law µ just contracts inner edges to produce a bouquet
[Rough draft, version 2007-05-24 21:36]

100
Polynomial monads and operads
from a two-level tree. Since it does not alter the number of input edges
(the ﬁbres), this is a cartesian map. Similar argument for η.
In contrast, the free-commutative-monoid monad is not cartesian. See
Leinster’s book. We are not so interested in this monad anyway since we
know it is not polynomial. . .
5.1.4 Polynomial monads. Let Poly denote the category of polynomial
functors and their cartesian natural transformations. A monoid in here
is called a polynomial monad. In detail, a polynomial monad is a poly-
nomial endofunctor P : Set →Set equipped with a composition law
µ : P ◦P →P with unit η : Id →P, satisfying the usual associativity and
unit conditions. The structure maps µ and η should be cartesian natural
transformations.
The composition law is described graphically as an operation of con-
tracting trees (formal compositions of bouquets) to bouquets. We shall
refer to B as the set of operations. Since we have a unit, we can furthermore
think of E as the set of partial operations, i.e. operations all of whose inputs
except one are fed with a unit. The composition law can be described in
terms of partial operations as a map
B × E →B,
consisting in substituting one operation into one input of another opera-
tion.
The rest of this subsection is devoted to an analysis of the partial-
composition viewpoint.
Note that polynomial functors always preserve cartesian squares (cf. 8.4.1).
5.1.5 The set map description of the composition law. It’s about taking a
height-2 tree and producing from it a bouquet (height-1 tree). To require
the map P ◦P →P to be cartesian means that the ﬁbres match. This means
that this new bouquet must have the same set of leaves as the resulting
height-1 tree. The cartesian condition is that there is a square
P′(B) × E
- E
P(B)
?
- B
?
Here we use the compact differential notation, cf. 1.7.5.
[Rough draft, version 2007-05-24 21:36]

5.1 Polynomial monads
101
5.1.6 Units. The unit morphism is a cartesian morphism from 1 →1 to
E →B. That is, this map singles out an element u in B (a distinguished
operation) and the requirement that the morphism be cartesian means that
the ﬁbre over this element is singleton, so u is represented by a bouquet
with only one leaf. That’s just what it means to have a cartesian morphism
Id →P. Now there is furthermore the unit requirement, namely that
grafting a big collection of units on any bouquet and then contracting is
the same as doing nothing, and that if you graft any bouquet b on top of
the unit bouquet, then you get b again. . .
For this reason we draw the unit operation as a single edge without a
dot.
5.1.7 Partial composition law viewpoint. (The partial viewpoint for op-
erads is advocated by Stasheff.) This viewpoint amounts to grafting only
on one leaf. It is equivalent to the standard substitution because of the ex-
istence of units. We can deﬁne an operation by grafting onto only one leaf
and then graft the unit on the remaining leaves. This deﬁnes an operation
P × P′ →P
cf. the description we made in Number 1.7.9. To say that this is a cartesian
operation (we have to check that cartesian composition law implies carte-
sian partial composition law, but that should be straightforward). That is
to have a cartesian square
E × E + B × (E ×B E) ∖∆)
- E
B × E
?
- B
?
The cartesian condition is that doing this contraction does not change
the set of leaves! The important thing is that the ﬁbre is the set of all leaves
and that this does not change under the composition. This is the cartesian
condition.
b
c
7→
˜b
[Rough draft, version 2007-05-24 21:36]

102
Polynomial monads and operads
The picture (and the cartesian condition) indicates that the bouquet is ob-
tained from the two-level tree by contracting dot c back to dot b. However,
this ˜b cannot be the same as b because it has another ﬁbre.
Here is the unit condition in terms of partial composition law: It’s a
morphism 1 →B such that the induced map E →E × B followed by
composition E × B →B is the projection itself:
E
p
- B
E × B
µ
-
η
-
This is the expression of the requirement that grafting a single u on top on
any bouquet at any leaf gives back the same bouquet.
The other requirement is that the section 1 →B extends to 1 →E (it
does by the cartesian condition since there is only one point in the ﬁbre
over u) and that this is a section to both the map s : E →1 (which is
obvious in the one-variable case) and also, as explained, is a section to
E →B →1. This section induces B →E × B (b 7→1 × b) and this is a
section to µ. That is, B →E × B →B is the identity map on B.
Exercise. Write out what associativity means in this viewpoint. There
are two equations, corresponding to the fact that the top space over B × E
has two components. One is the condition that it doesn’t matter if you ﬁrst
graft on leaf e and then on another leaf f. The second condition is that it
doesn’t matter if you ﬁrst graft g onto a leaf of f, and then graft the result
onto a leaf of e, of if you ﬁrst graft f onto e, and then graft g onto one of
the leaves of f.
The ﬁrst condition should amount to saying that some differential op-
erator P∂2 is symmetric. The second condition is a differential equation
looking something like
P∂(P∂(P)) →P∂(P) = (P∂P)∂P →(P)∂P
I haven’t yet ﬁgured out precisely what it is. . .
[Rough draft, version 2007-05-24 21:36]

5.1 Polynomial monads
103
The free monad on a polynomial endofunctor (one variable)
5.1.8 The free monad on a polynomial endofunctor. The adjunction
P-Set
Set
FP
6
⊣U
?
described in 4.6.1 generates a monad TP := U ◦F : Set →Set. It is the free
monad on P. We already described it: it sends a set X to the set of B-trees
with leaves decorated in X. Hence it is represented by the map E∗→B∗
where B∗is the set of trees whose nodes are elements in B, and E∗is the
set of such B-trees, but with one leaf marked.
The monad structure of T is described explicitly in terms of grafting of
trees. In a partial-composition description, the composition law is
B∗× E∗→B∗
consisting in grafting a tree onto the speciﬁed input leaf of another tree.
The unit is given by 1 →B∗singling out the dotless tree.
A better description: nodes are decorated in B, and the additional
structure of a bijection between the set of input edges of node n with dec-
oration b and the ﬁbre Eb.
Let P denote a polynomial endofunctor given by E →B. We deﬁne a
P-tree to be a tree whose nodes are decorated in B, and with the additional
structure of a bijection for each node n (with decoration b) between the set
of input edges of n and the ﬁbre Eb.
Another description is useful: a B-tree is a tree with node set N, and
node-with-marked-input-edge set N′, together with a diagram
N′
- N
E
?
- B
β
?
Then the β expresses the decorations, and the cartesian square encodes the
bijections. As we saw when constructing them, the P-trees are obtained by
freely grafting elements of B onto the leaves of elements of B, and formally
adding a dotless tree.
[Rough draft, version 2007-05-24 21:36]

104
Polynomial monads and operads
5.1.9 Lemma. The free monad on a polynomial functor is cartesian.
Proof. We must show that µ : P∗◦P∗→P∗and η : Id →P∗are cartesian.
let us start with η since it is the easiest: the map 1 →B∗singles out the
dotless tree. We need to show that the quare
E∗
- B∗
1
6
- 1
6
is cartesian, but this is true because the dotless tree has precisely one leaf.
We will apply the same argument to the composition map: intuitively,
the reason the composition is cartesian is that a two-level tree and the one-
level tree obtained by the composition map has the same number of leaves
(and the same decorations). (Note that this is the same argument as for the
unit, where we observed that both had a singleton ﬁbre).
But let us work through the involved sets: the base set for the compos-
ite polynomial functor is p∗(E × B), which we identiﬁed as the set of trees
whose leaves are decorated by trees. This is the same thing as a tree with
a cross section. (Note that in this interpretation we are implicitly using the
fact that we have units: a cross section might cross a leaf, in which case
we need to interpret the upper part of that leaf as dotless tree, which we
can do because we have formally added the dotless trees. The top set of
P∗◦P∗is the set of trees with a cross section and one leaf marked. The
composition map consists in forgetting the cross section. Clearly this op-
eration does not change the number or decoration of the leaves, so we see
that ﬁbres for q and p are in natural bijection. That’s all.
2
I wanted to understand the cartesian condition also in the partial sub-
stitution viewpoint. . .
5.1.10 Alternative ﬁxpoint construction. There is an alternative descrip-
tion of the free monad, which we brieﬂy mention: I HAVE NOT YET
FIGURED OUT THE RELATIONSHIP BETWEEN THE TWO FIXPOINT
CONSTRUCTIONS. The free monad is a least ﬁxpoint for the functor
Γ := ΓP : Poly
−→
Poly
Q
7−→
Id + P ◦Q.
[Rough draft, version 2007-05-24 21:36]

5.1 Polynomial monads
105
Let ∅denote the constant polynomial functor on the empty set (it is given
by ∅→∅). One can check that Γ preserves monos, hence there is a se-
quence of monos
∅֒→Γ(∅) ֒→Γ2(∅) ֒→. . .
If P is ﬁnitary (i.e., p : E →B is a ﬁnite map — this will always be the case
below) then it preserves such sequential colimits, and the least ﬁxpoint can
be constructed as
P∗=
[
n≥0
Γn(∅).
The equation satisﬁed by P∗,
P∗= Id + P ◦P∗,
expresses the recursive characterisation of trees: a tree is either a dotless
tree or a ﬁnite set of trees.
Examples
5.1.11 Example. The free-monoid monad is not a free monad on anything.
5.1.12 Example. (The pointed-set monad.) The pointed-set monad is the
free monad on the constant polynomial functor X 7→1. The functor X 7→1
is represented by the set map
 


The free monad on this is represented by
∗


,


X 7→1 + X
the pointed-set monad.
[Rough draft, version 2007-05-24 21:36]

106
Polynomial monads and operads
5.1.13 Example. Similarly, for a ﬁxed set S, we can consider the constant
polynomial functor X 7→S. The free monad on this one is
X 7→S + X.
A special case of this situation is the constant polynomial functor X 7→∅.
It generates the identity monad X 7→X.
5.1.14 Example. The free monad on id : Set →Set, is the free N-action
monad X 7→N × X. (Its Eilenberg-Moore algebras are the N-sets, i.e. set
with an N-action.)
5.1.15 Example. Construct the free monad on 2 →1. It is going to be
the monad whose operations are the binary trees. Note that if we don’t
include a nullary operation, then after the ﬁrst iteration we have only the
dotless tree as operation. Then in the next step we get only the binary
bouquet, plus the dotless tree. And then we can graft these onto the binary
bouquet, and in the end we get all binary trees (planar) but not levelled.
If we include a nullary operation, then we also allow stopdots in the
otherwise binary trees. . .
No it seems we don’t get levelled trees. The reason is that in each step
of the iteration, the base bouquet is from the oriinal P. This means in a
sense that every tree is obtained only with one parenthesiation, namely
so-to-speak with all the parentheses near the root,
5.1.16 The free monad on M: planar trees. The really interesting example
to work out is of course when we start with M, the free-monoid monad.
The ﬁrst iteration is about the composite M ◦0. The operations for
this composite endofunctor is the set of ways to decorate bouquets in ∅.
Only the nullary operation survives as operation generated in this way,
and then we add the dotless tree, to account for adding Id. Now we have
a polynomial endofunctor T with two operations: the stopdot and the dot-
less tree.
In next iteration we compute P ◦T: its operations are obtained by dec-
orating bouquets with the dotless tree or the stopdot. We get
. . .
[Rough draft, version 2007-05-24 21:36]

5.2 Classical deﬁnition of operads
107
and then add the dotless tree again.
And so on. It is clear that in the limit we get exactly the trees we ﬁnd
useful in dealing with polynomial functors: they have open leaves. Note
that these are M-trees. This means that there is some repetition of trees
that might look isomorphic in our drawings. But that is only because we
omitted the bijections. Each ﬁbre is rigid. . .
5.2
Classical deﬁnition of operads
A operad (more precisely, a non-symmetric or planar operad) consists of a
sequence of sets (An | n ∈N) equipped with a many-in/one-out compo-
sition law: for each k, n1, . . . , nk (natural numbers) a map
Ak × An1 × · · · × Ank
−→
An1+···+nk
(b; a1, . . . , ak)
7−→
b ◦(a1, . . . , ak)
and a speciﬁed identity operation 1 ∈A1 satisfying associativity and unit
axioms:
ASSOCIATIVITY AXIOM
 b ◦(a1, . . . , ak)
 ◦(a1,1, . . . , a1,m1, a2,1, . . . , a2,m2, . . . , . . . ak,1, . . . , ak,mk) = b ◦
 a1 ◦(a1,1, . . . , a1,m1), . . . , ak
UNIT AXIOM 1 ◦a = a and b ◦(1, . . . , 1) = b.
The elements of An are called n-ary operations.
We picture an element b ∈An as a bouquet with n input leaves (and
label the dot with the name of the element). The composition law then
consists in grafting the sequence of operations (a1, . . . , an) onto the leaves.
Note that these ai form an ordered sequence, so in order to know which
leaf we are grafting each of them onto, we need to require that the drawing
is planar, in contrast to our convention for the bouquets for polynomial
functors.
Then the associativity is much easier to understand:
given a bottom operation b with k leaves, and k operations a1, . . . , ak,
and for each input leaf of each of these another operation ai,j, then it doesn’t
matter whether we ﬁrst graft the ai onto b, and then ﬁnally graft the long
list of ai,j onto the union of all the leaves of the ai, OR if we ﬁrst take each
[Rough draft, version 2007-05-24 21:36]

108
Polynomial monads and operads
ai and ﬁll all its leaves with the operations ai,1, . . . , ai,mi and then graft the
resulting k trees on top of b.
Quite cumbersome and boring. Do we really have to do all this alge-
braic yoga?
A morphism of operads, say from A to B is a graded map that respects
the composition law and unit: in other words, it is a sequence of maps
f = (fn : An →Bn | n ∈N) such that
PRESERVATION OF THE COMPOSITION
f(b ◦(a1, . . . , ak)) = f(b) ◦(f(a1), . . . , f(ak))
AND F(1) = 1.
5.2.1 Partial composition laws. Since we have a unit, we can make sense
of partial composition laws: there are k partial composition laws
Ak × An
−→
Ak−1+n
(b; a)
7−→
b ◦i a
consisting in grafting a onto the ith leaf of b and grafting units onto the
remaining k −1 leaves.
WRITE THE AXIOMS FOR THIS VIEWPOINT
5.3
The monoidal category of collections
By a collection we mean a N-graded set, i.e. a set A equipped with a map to
N. Hence we can write
A = ∑
n∈N
An.
A collection is just like an operad but without the extra structure of the
composition law. So we will still think of the elements of An as n-ary
operations, and we picture them as planar bouquets with n input leaves.
We now construct the substitutional tensor product of collections. It
is highly non-symmetric. Namely given two collections A and B, we de-
ﬁne a set A ⊗B as the set of all ways of sticking operations from A into
operations in B
[Rough draft, version 2007-05-24 21:36]

5.3 The monoidal category of collections
109
AGREE ON A CONVENTION FOR COMPOSITION! SHOULD WE
USE CONVENTIONAL ◦NOTATION? CURRENTLY WE USE LEFT-TO-
RIGHT NOTATION!
Since the inputs of an element in B are ordered, and there are n of them
for some n ∈N, we need a list of n elements from A. Altogether we have
An × Bn
We do this for each n ∈N, so the total set of A ⊗B is
∑
n∈N
An × Bn
Now we need to specify how this set is N-graded, i.e. give it structure
of a collection. The idea is that the degree is the total number of input
leaves. In other words,
deg(a1, . . . , an; b) :=
n
∑
i=1
deg(ai)
So if we want to describe the set A ⊗B degree-wise, the degree-n piece
is given by the formula
∑
d∈N∑
i
Ai1 × Ai2 × · · · × Aid × Bd
the inner sum is over all ordered partitions of the integer n into d parts,
i1 + . . . id = n
This is horrible. Especially when you now have to verify that this ten-
sor product is associative (up to coherent isomorphism).
To see that it is unital is not so bad: the collection 1 →N (which picks
the one-element in N) is a unit. Indeed, this collection has only one opera-
tion, and it is of degree 1, so the ugly sums reduce to a single term.
In the graphical viewpoint this is easy to see: for each b ∈Bn there is
precisely one way to graft the unique operation of 1 onto the leaves of b,
so 1 ⊗B = B. Conversely, if we want to graft all possible operations of A
onto the unique operation of 1, we get A again.
[Rough draft, version 2007-05-24 21:36]

110
Polynomial monads and operads
5.3.1 Proposition. An operad is the same thing as a monoid in (Coll, ⊗, 1).
5.3.2 M-collections. Collections take sequences of elements as input. For
this reason we can formulate the notions in terms of the free-monoid monad,
and it becomes much easier to handle. So the notion of collection is really
M-collection, and later on we shall see how any cartesian monad P (and
polynomial ones in particular) gives rise to a notion of P-collection and
P-operad (generalised operad).
If A and B are collections, the substitutional tensor product is deﬁned
as
M(A) ×N B
The map M(A) →N is simply M(A) →M(1), obtained by taking M on
the unique map to the singleton set. The ﬁbre-product condition simply
says that we take an n-tuple of elements in A when B is of arity n. The unit
is 1 →N, which is precisely η1, the unit for the monad M.
The degree map from M(A) ×N B to N is not just the map via the ﬁbre
condition (that would amount to letting the tensor product always have
the same degree as its second factor). It is deﬁned unsing the monad struc-
ture on M. Namely ﬁrst project onto M(A), then take the map M on the
structure map A →N = M(1); this gives M(A) →M(M(1)) and then
apply the multiplication map µ1, which is nothing but addition in N. This
degree map agrees with the original description of the degree: from the
sequence of elements in A we ﬁrst get a sequence of natural numbers, and
then we add them. (So the degree is the total number of leaves of the
operations listed.)
Now it is easy to check the unit law:
note taht in order to check that M(A) ×N 1 is isomorphic to A, we use
the cartesian condition on N: we have
A
- 1
M(A)
?
- M(1)
?
(So on one side of the unit axiom veriﬁcation, we used only monoid
structure on N, not the general multiplication map of M. On the other side
we used the full η being cartesian.
Now verify the associativity.
All this is just an easy case of Burroni’s construction.
[Rough draft, version 2007-05-24 21:36]

5.4 The free operad on a collection
111
5.3.3 M-operads. The operads we have considered are really M-operads.
They can also be described as collections X/N equipped with an action
M(X) ×N X →X
which must be associative and unital.
5.4
The free operad on a collection
5.4.1 The free-operad monad. The forgetful functor from Opd to Coll
free-operad
has a left adjoint F, which to any collection associates the operad obtained
by freely combining all the operations in all possible ways, and formally
adding a unit (a dotless tree). So the free operad on A is the set T of trees
with each node of degree n decorated by an element in An. The grading of
T is given by the number of leaves.
It is just the general construction of the free monoid on an object in a
monoidal category. . .
Here we just use our ﬁxpoint machinery: we can construct the free
operad on the terminal collection N →N: it is just the set of trees. NO!
BEFORE WE CAN USE FIXPOINT MACHINERY, WE NEED A MONAD,
SO LET’S WAIT WITH THIS CONSTRUCTION UNTIL WE HAVE COM-
PARED OPERADS WITH POLYNOMIAL FUNCTORS OVER M.
The general case, the free operad on A, is about decorating trees at
their nodes, in accordance with their arity. So we are talking commutative
diagrams
nodes
- A
N

-
So the free operad on A has as its set of n-ary operations
F(A)n = ∑
t∈Tn
HomN(nodes(t), A)
OR SOMETHING LIKE THIS where Tn denotes the set of trees with n
input leaves
[Rough draft, version 2007-05-24 21:36]

112
Polynomial monads and operads
We will later come to polynomial functors in many variables. An im-
portant example are polynomial functors in countably many variables:
these are functors Set/N →Set/N, and we shall see that the free-operad
endofunctor on Set/N (which is a monad since it was generated by an
adjunction) is polymomial.
constellations
5.4.2 Example. We have now understood the free-operad monad F : Coll →
Coll. Now we can study its Lambek algebras. So deﬁne a F-collection to
be a collection X/N equipped with a map of collections FX →X. Now it
turns out the forgetful functor F-Coll →Coll has a left adjoint C, the free
F-collection on a collection.
Figure out what it is. We already observed that the free operad on a
collection is the collection of planar trees built from the operations of the
original collection. Figure out that the free F-collection on a collection X is
the set of X-trees with circles! I.e. planar constellations.
Thinking of F(1) as being given by a set of planar bouquets, C(1) is
the set of trees of trees. These are planar constellations. I.e. circles set in
planar trees. Since F is a monad, there is for each collection X a natural
map of collections C(X) →F(X). In particular, for the terminal collection
1: a map associating to a constellation a tree: it is just to erase the circles.
5.5
Finitary polynomial functors and collections
Deﬁnition. A map p : E →B is called ﬁnite if every ﬁbre is ﬁnite. A poly-
nomial functor is called ﬁnitary if represented by a ﬁnite map. Let FinPoly
denote the category of ﬁnitary polynomial functors and cartesian natural
transformations.
For a ﬁnite p : E →B, the classifying map
B
−→
N
b
7−→
|Eb|
gives us already a collection. Clearly this is functorial and gives us a func-
tor FinPoly →Coll.
The classifying map extends (non-canonically) to a map E →N′, which
is a bijection on each ﬁbre. Hence there is a (non-canonical) bijection
E ≃B ×N N′
[Rough draft, version 2007-05-24 21:36]

5.5 Finitary polynomial functors and collections
113
Non-canonical because those ﬁnite sets have automorphisms.
So every polynomial functor admits a cartesian map to the free-monoid
monad M, but this map is not unique so M is NOT a terminal object in
Poly.
If we looked at ordered ﬁnite sets, then this would be canonical. Alternatively, we
should look at groupoids instead of sets. This is how groupoids are used in moduli
theory in algebraic geometry, leading to moduli stacks instead of moduli schemes.
Remark: p itself may happen to be a monad, but in that case I don’t
know if it is always possible to extend the classifying map to a monad
morphism. [In fact it seems that the free-monoid with involution (or is it
anti-involution?) does not admit a cartesian monad map to M. . . ]
Conversely, given a collection B/N we can form the pullback square
N′ ×N B
- B
N′
?
- N
?
where the top row is a polynomial functor. However, these two construc-
tions are not inverse to each other. The problem is equivalent to the one in
the previous remark, that the map from a polynomial functor to M is not
unique.
But we can ﬁx this by keeping the whole pullback square: so we deﬁne
a functor Coll →FinPoly/M. This is well deﬁned by the uniqueness of
pullbacks. This functor is an equivalence.
Furthermore, monads over M will correpond to operads. We will es-
tablish this by proving more generally that FinPoly/M and Coll are equiv-
alent as monoidal categories.
Equivalence of monoidal categories
MENTION CLUBS, AND REFER TO [30]
The functor FinPoly →Coll is not monoidal, because the monoidal
structure in Coll involves an order that we do not have on the polynomial
side. But when we include the data of a cartesian map to M, then we do
get this order, since each ﬁbre is a ﬁnite ordinal. It amounts to choosing an
order in each ﬁbre of E →B.
[Rough draft, version 2007-05-24 21:36]

114
Polynomial monads and operads
Let us look at polynomial functors with a speciﬁed cartesian map to M
(the free-monoid endofunctor, represented by N′ →N). (Note that having
such a map automatically guarantees that P is ﬁnitary.)
The category of polynomial functors with a (cartesian) morphism to
M is monoidal: given P →M and Q →M, their composite P ◦Q has a
canonical map to M using the monad structure on M: namely
P ◦Q →M ◦M
µ→M
The unit is he identity endofunctor with structure map η : Id ⇒M (the
unit for the monad M).
Note that P ◦Q ⇒M ◦M is a cartesian natural transformations: it
is the horizontal composite of two cartesian natural transformations, and
since all the involved functors preserve pullbacks, this is again a cartesian
natural transformation. Cf. 2.1.6.
5.5.1 Proposition. There is an equivalence of monoidal categories between the
category (Poly/M, ◦, id) and the category of collections (Coll, ⊗, 1).
We already established the equivalence of categories. . .
Now use the notion of M-collection to see easily that this equivalence
is monoidal.
Hence the monoids in Poly/M correspond to monoids in Coll and
these are precisely the operads:
Mmonad=operad
5.5.2 Corollary. There is an equivalence of categories
Poly/M ≃Opd.
Note that the terminal object in the ﬁrst category is M (which hap-
pens to be a monad), and it corresponds to the terminal collection N →N
(which happens to be an operad).
Note that a monoid in the monoidal category Poly/M is the same as
an object in the slice category PolyMon/M. This is because of the way the
tensor product was deﬁned.
There is also the forgetful functor Poly/M →Poly. Composing with
the equivalence Coll →Poly/M we get a functor Coll →Poly: it is
simply the map that takes a collection B →N, and returns the polynomial
functor N′ ×N B →B (the pullback of the universal family).
[Rough draft, version 2007-05-24 21:36]

5.6 P-operads
115
MOVE OR DELETE
Compare the polynomial functors of the diagram (cf. 1.3.3):
E
p - B
1
s

1
t
-
N′
?
-
s′

N
? t′
-
Start with a set X (over I = 1). Pull it back to E, then push it forth to B. Now pulling
back directly to E is the same as pulling back via N′. From here, pulling up to E and then
down to B is the same as ﬁrst down to N and then up to B, according to the Chevalley-
Beck condition. (And ﬁnally push down to 1.)
So what this tells us is that the polynomial functor can be described as ﬁrst taking the
free monoid on X, i.e., ∑Xn, and then take the ﬁbre product with B. So the end result is
X 7→∑
n∈N
Bn × Xn
5.5.3 Example. (Example 5.4.2 revisited.) We have the free-operad monad:
it is now the free-monad monad F : Poly/M →Poly/M. Now study the
category of F-algebras: these are polynomial functors Q over M equipped
with a cartesian map F(Q) →Q. Perhaps spell out the details and get to
the constellations.
5.6
P-operads
See Leinster [34] Section 4.2.
Now we will see that every cartesian monad P : Set →Set gives rise
to a notion of P-operad.
THIS GENERAL BURRONI STUFF SHOULD PROBABLY BE MOVED
TO THE MANY-VARIABLE PART OF THE NOTES.
WE SHOULD TRY TO CONDENSE THIS SECTION TO THE MOST
ESSENTIAL. AVOID GENERALITY AT THIS POINT. IT IS ONLY AN AP-
PETISER.
Let P : Set →Set be a polynomial functor, represented by E →B.
The category of polynomial functors over P, denoted Poly/P, is nat-
urally a monoidal category under composition: the composite of X →P
[Rough draft, version 2007-05-24 21:36]

116
Polynomial monads and operads
and Y →P is the composite endofunctor X ◦Y equipped with a map to
P deﬁned by X ◦Y →P ◦P →P (cartesian by 2.1.6). The unit for the
monoidal structure is the identity functor, equipped with structure map
η : Id ⇒P. Note that we need both parts of the monad structure on
P. The monad axioms ensure this monoidal category is associative and
satisﬁes the unit axiom.
(In fact this is completely general: if M is a monoid in a monoidal cat-
egory C , then C /M is again monoidal, using the same construction, and
the forgetful map is strictly monoidal.)
The monad P gives rise to a tensor product on the category of collec-
tions Coll = Set/P(1). Namely, A ⊗B : = P(A) ×P(1) B. The unit is
η1 : 1 →P(1).
Just like above, we ﬁnd:
5.6.1 Proposition. There is an equivalence of monoidal categories
Poly/P
−→
P-Coll
X
7−→
X(1)
The inverse equivalence takes a P-collection A →P(1) and returns the polyno-
mial functor represented by E ×B A.
In fact there is no need to use polymomial monads for this to work:
it works with cartesian monads in general. If doing it in this generality,
we should just notice that if P is polynomial, then all the P-collections
correpond to polynomial functors again. (Recall from 2.1.3 that any func-
tor with a cartesian natural transformation into a polynomial one is again
polynomial. (The proof given there was for the case of Set, but it should
be easy to carry over to the general case.))
Next, since equivalent monoidal categories have equivalent categories
of monoids, we see that polynomial functors over P correspond to P-
operads. This is a very well-known and basic result. The novelty is per-
haps that if P is a polynomial monad, then all P-operads are ’polynomial’.
In particular the free P-operad is the same thing as the free monad over P:
alg/P
P-Opd
Poly/P
6⊣
?
≃Set/P1.
6⊣
?
[Rough draft, version 2007-05-24 21:36]

5.6 P-operads
117
In fact we have an equivalence of categories between P-alg and the cat-
egory of algebras for the free operad on the terminal collection. The free
operad on the terminal collection is just T1 →P1. Its algebras are un-
derstood to be the Eilenberg-Moore algebras for the correponding monad
which is none other than T.
But we know that there is a canonical equivalence of categories (the
Eilenberg-Moore comparison functor)
P-alg
Φ- Set T
Cf. comments earlier in the text, quoting [11, Ch.9].
[Rough draft, version 2007-05-24 21:36]

118
Polynomial monads and operads
[Rough draft, version 2007-05-24 21:36]

Chapter 6
[Polynomial functors in computer
science: the theory of
containers???]
Cf. Dybjer, Abbott, Altenkirch, etc.
Abbott, Categories of containers [1].
Also: Abbott-Altenkirch-Ghani [2] Abbott-Altenkirch-Ghani-McBride [3],
[4]. . .
6.1
Data structures
Copy from Manes-Arbib [36].
6.1.1 Coalgebras. A coalgebra for a polynomial functor P : Set →Set
is just a set X equipped with a map X →P(X). There is the notion of
terminal object in the category of coalgebras, also called largest ﬁxpoint. A
dual construction of that iteration may give a way of constructing terminal
coalgebras, but I haven’t checked under what conditions it works.
We observed for a surjective map p : E →B, the initial algebra is just
∅. Since P(∅) ≃∅, this is a ﬁxpoint in any case, but as you can imagine
it is not the largest one! Such polynomial functors have dull algebras but
interesting coalgebras. Example. Consider the identity map B →B. The
corresponding polynomial functor is X 7→B × X. This particular functor
P(X) = B × X preserves sequential limits and epimorphisms, so in this
[Rough draft, version 2007-05-24 21:36]

120[Polynomial functors in computer science: the theory of containers???]
case we can construct the largest ﬁxpoint in a way dual to the Lambek
iteration.
1 
P(1) 
P(P(1)) 
. . .
which is just the sequence 1 
B 
B2 
. Clearly the limit is BN,
the set of inﬁnite sequences in B. The isomorphism
BN ≃B × BN
is just the exponentiation of the bijection N ≃1 + N.
Algebras and coalgebras for endofunctors Set →Set are important
concepts in theoretical computer science. Algebras are used as an abstrac-
tion of the notion of data types, while coalgebras are an abstraction of
systems or automata. Indeed, we saw that an algebra can be interpreted
as a set with a collection of operations on it—this is about the same thing
as a data type is (e.g., queues and stacks and trees and so on).
6.1.2 Automata. Consider a automaton, like for example a coffee machine.
To describe it we ﬁrst describe its user interface: this consists of an input
alphabet I and an output alphabet O. Think of the input alphabet as the set
of buttons you can press, and the output alphabet as the set of things that
can come out of the machine, i.e. various types of hot drinks, or change.
Now let S denote the set of states of the machine, i.e. how much coffee,
sugar, and milk the machine contains, as well as water temperature, etc.
Now the machine is described by its transition function
I × S →O × S.
It says that if you press one button while the machine is in a certain state,
then something comes out, and the machine enters a new state. By adjunc-
tion, the transition function can also be described as
S →(O × S)I.
In other words, the machine is described as a coalgebra for the polynomial
endofunctor X 7→(O × X)I.
Now the theory of polynomial functors says that these exists a terminal
coalgebra. This amounts to saying there exists a universal coffee machine!
In other words, there exists a coffee machine U (i.e. a set U with a map
[Rough draft, version 2007-05-24 21:36]

6.1 Data structures
121
U →(O × U)I) such that for every other machine S →(O × S)I there
is a map S →U commuting with the structure map. So the universal
machine can do everything any other machine can do! This machine U
will typically be immense, so you might not want to build on for your
math department, but even if you don’t build one, it is of considerable
theoretical interest: namely any other machine S comes with a morphism
to U, which characterises it: this map S →U is called the behaviour of
S, and often you are more interested in the behaviour than in the machine
itself. . .
Initial algebras are particularly important because they allow for def-
inition and proof by induction. (Similarly terminal coalgebras allow for
coinduction. . . ) It seems that in practice, algebras modelling data types
often come from polynomial functors. For coalgebras modelling systems,
it is perhaps less common to be polynomial??
[Rough draft, version 2007-05-24 21:36]

122[Polynomial functors in computer science: the theory of containers???]
[Rough draft, version 2007-05-24 21:36]

Chapter 7
[Species. . . ]
There is scheduled here a long section on species, and comparison be-
tween polynomial functors and species.
7.1
Introduction to species and analytical func-
tors
7.2
Polynomial functors and species
[Rough draft, version 2007-05-24 21:36]

124
[Species. . . ]
[Rough draft, version 2007-05-24 21:36]

Part II
Polynomial functors in many
variables
[Rough draft, version 2007-05-24 21:36]


Chapter 8
Polynomials in many variables
many-variables
8.1
Introductory discussion
The idea is that instead of having just one variable X, we have a bigger set
of variables (Xi)i∈I. For example we might have just two variables X1 and
X2, corresponding to the indexing set I = {1, 2}, and then a polynomial
functor should be something like
Set × Set
−→
Set
(X1, X2)
7−→∑
b∈B
XE1b
1
XE2b
2
.
(It should be polynomial in each variable.) Then for each b ∈B, instead of
giving just one exponent set Eb we need to give two: one exponent for X1
and one for X2. Hence we need two maps, E1 →B and E2 →B, and the
polynomial will be
(X1, X2) 7→∑
b∈B
XE1b
1
XE2b
2
.
This approach is not the most practical though, especially not if we
want to treat more complicated indexing sets than {1, 2}. It is better to
organise the two maps E1 →B and E2 →B into a single map E = E1 +
E2 →B, and to keep track of which elements in E are in E1 and which in
E2 we just specify a map s : E →I, such that the indices on E become an
instance of our general notation for ﬁbres: E1 is the ﬁbre of s over 1, and
E2 is the ﬁbre over 2.
[Rough draft, version 2007-05-24 21:36]

128
Polynomials in many variables
Once we have the map s : E →I, we don’t have to write the variables
separately — we just let s take care of the bookkeeping. We can write now
∑
b∈B
∏
e∈Eb
Xs(e).
This expression makes sense for any indexing set I, and it deﬁnes a functor
Set/I →Set. This is precisely the functor obtained from the diagram
E
p- B
I
s

as follows: starting from a family of variables (Xi | i ∈I), which we
encode as a map X →I, ﬁrst pull it back to E to get X′ = X ×I E →E.
Now push forth along p. This is a ﬁbrewise construction: for each b ∈B
we must take the product of all the ﬁbres of X′
e where e runs over Eb. Now
by deﬁnition of ﬁbre product, the ﬁbre X′
e is just Xs(e). So in conclusion,
X/I 7−→p∗s∗X = ∑
b∈B ∏
e∈Eb
Xs(e).
(Just as a quick check: if I is a singleton set, then there is just one vari-
able X, i.e. X is just a single set. Then Xs(e) = X, and the last product
can be written ∏e∈Eb Xs(e) = XEb. Hence the notion of polynomial functor
considered in Part 1 is just the one-variable case of the notion we are now
developing.)
MERGE THIS WITH THE DISCUSSION BELOW: So just as a good-old
polynomial in many variable is a function NI →N, we now have deﬁned
Set I →Set. Note that Set I ≃Set/I. Given X →I the whole functor
gives p∗s∗X
EQUIVALENCE, NOT ISOMOPRHISM Set I ≃Set/I. From Set/I to
Set I there is a canonical functor, associating to a map X →I the functor
I →Set that sends i to Xi (the ﬁbre over i). To go back we need to assemble
all the sets Xi into a single set with a map to I. This set should of course
be the disjoint union ∐i∈IXi, but this is only well-deﬁned up to unique
isomorphism. . .
[Rough draft, version 2007-05-24 21:36]

8.1 Introductory discussion
129
8.1.1 General polynomial maps. In the good-old case, we can more gen-
erally consider polynomial maps of the form
NI
−→
NJ
(xi)i∈I
7−→
(pj)j∈J
where the result is a vector of polynomials indexed by J, and each of the
entries in the vector is a polynomial function in the variables (Xi)i∈I. Sim-
ilarly, we want the notion of polynomial functor to include functors
Set/I →Set/J
for arbitrary sets I and J:
8.1.2 General polynomial functor. Here comes the general construction.
A diagram of sets and set maps like this
E
p - B
I
s

J
t
-
(8.1)
P
gives rise to a polynomial functor P : Set/I →Set/J deﬁned by
Set/I
s∗- Set/E
p∗- Set/B
t!- Set/J.
Here lowerstar and lowershriek denote, respectively, the right adjoint and
the left adjoint of the pullback functor upperstar. In explicit terms, the
functor is given by
Set/I
−→
Set/J
[ f : X →I]
7−→∑
b∈B ∏
e∈Eb
Xs(e)
where Eb := p−1(b) and Xi := f −1(i), and where the last set is considered
to be over J via t!.
If I and J are singleton sets, we recover the one-variable polynomial
functors of Part 1.
[Rough draft, version 2007-05-24 21:36]

130
Polynomials in many variables
8.1.3 Outlook to locally cartesian closed categories. DO SOMETHING
WITH THIS! In topos theory, the functor p∗is often denoted Πp, because
it is ‘multiply’, and sometimes (inspired by the role these maps play in
logic) it is also denoted ∀p.
The functor t! is often denoted Σt, since it is the sum map, and some-
times it is also denoted ∃t.
In logic, these notions make sense more generally in any Heyting pretopos. . . cf. [37].
Finally let us denote the pullback functor ∆p. It is also called substitu-
tion, since it is about substituting one set of variables into another. . . However,
this terminology will not be used here, because we are going to talk about
substitution of one polynomial into another. . .
In fact all the following basic arguments work in any topos. When the
arguments look very set-theoretical, you just have to insert the disclaimer
that you are expressing things in the internal language of the topos. . .
In fact it works if just the category is locally cartesian closed and has
sums. Recall that a category C is locally cartesian closed if all its slice cat-
egories C /X are cartesian closed. Our favourite category Set is of course
cartesian closed and also locally cartesian closed—see explanation in the
next paragraph. In contrast, Cat is cartesian closed but not locally carte-
sian closed GIVE COUNTER-EXAMPLE
More generally still, consider any category C with pullbacks. Then for
any arrow f : X →Y in C , the pullback functor C /Y →C /X has a
left adjoint f!. And then these two functors satisfy Beck-Chevalley. This
is essentially because the composition of two pullback squares is again a
pullback square. Such a category is said to have dependent products if the
pullback functor has also a right adjoint.
If it has dependent products, then there is also a Beck-Chevalley con-
dition for f∗and f∗, and furthermore one can show that distributivity
holds.
A pretopos E has dependent products if and only if it is locally carte-
sian closed.
8.1.4 Some basic facts about slices and exponents. CONDENSE THIS
PARAGRAPH INTO SOMETHING MORE USEFUL
The fundamental observation is that there is a natural EQUIVALENCE
of categories
Set I ≃Set/I
[Rough draft, version 2007-05-24 21:36]

8.1 Introductory discussion
131
In any case the objects are families of sets (Xi)i∈I. In any case a map from
(Xi)i∈I to (Yi)i∈I is a family of maps (f : Xi →Yi)i∈I.
Now some phenomena are easier to grasp in terms of Set I and other
are more easily understood in terms of Set/I.
An example of a notion that is best understood in Set I is this: given
two objects in Set/I, say E →I and X →I. What is the object XE →I? It
is not just the set of maps E →X over I, because this set does not have a
natural map to I, and hence is not an object of Set/I. In other words, the
hom set HomI(E, X) is not internal hom. It is easier to see what it should
be in the other viewpoint: the two objects are now maps X : I →Set and
E : I →Set. The new object XE should be a functor I →Set. Well, Set I
is just a presheaf category: the internal hom is pointwise. So it means that
for each i ∈I we just consider the maps E(i) →X(i) in Set. In other
words XE is the functor
I
−→
Set
i
7−→
X(i)E(i)
Once we have seen that the exponentiation in Set I ≃Set/I [THIS IS
ONLY AN EQUIVALENCE] should be ﬁbrewise, we can also describe it in
the viewpoint of Set/I: the power set XE in Set/I is given by specifying
that the ﬁbre should be XEi
i . So altogether it is
∑
i∈I
XEi
i
→I
giving for each i ∈I a map Ei →Xi.
With this, we can check that ϕ∗is right adjoint to ϕ∗.
8.1.5 Lemma. Given ϕ : A →B, the functor
ϕ∗: Set/A
−→
Set/B
X/A
7−→∑
b∈B ∏
a∈Ab
Xa
is right adjoint to ϕ∗.
[Rough draft, version 2007-05-24 21:36]

132
Polynomials in many variables
Proof. Given
X
Y
A
?
ϕ
- B
?
the claim is there is a natural bijection
HomA(ϕ∗Y, X) ≃HomB(Y, ϕ∗X).
Indeed, to give an A-map ϕ∗Y →X is to give for each a ∈A a map
(ϕ∗Y)a →Xa. This is just to give Yϕ(a) →Xa. So the left-hand side is
∏
a∈A
X
Yϕ(a)
a
.
Now split the product into parts, one for each ﬁbre:
= ∏
b∈B ∏
a∈Ab
X
Yϕ(a)
a
And then we know ϕ(a) = b, getting
= ∏
b∈B ∏
a∈Ab
XYb
a .
On the other hand, to give a B-map Y →ϕ∗X = ∑
b∈B
∏
a∈Ab
Xa, so it is for
each b ∈B a map Yb →
∏
a∈Ab
Xa. A map into a product is the same as a
product of maps, so this is the same as the left-hand side.
2
Or, which is about the same: give a concise description of the polyno-
mial functor
P(X) = ∑
b∈B
XEb
can be described as the total space of the following object in Set/B, namely
(X×B→B)p:E→B
[Rough draft, version 2007-05-24 21:36]

8.1 Introductory discussion
133
We have just described this object: its ﬁbre over b ∈B is the power set XEb.
That’s all.
Repeat this description: given 1
s←E
p→B, and a set X, we claim that
P(X) can be described as an object of Set/B as
(s∗X)E
Where s∗X = X × E. We just argued that exponentiation in Set/B is
ﬁbrewise. So this object is the set over B whose b-ﬁbre is
(s∗X)Eb
b
but (s∗X)b is just X, so the ﬁbre is XEb and the total space is ∑b∈B XEb.
8.1.6 Example. Notice how familiar the adjointness becomes when B = 1.
This is really all there is to it: suppose we have
X
Y
A
?
ϕ
- 1.
?
The set ϕ∗X is simply the set of sections to X →A. We denote it HomA(A, X).
The adjointness say there is a bijection
HomA(A × Y, X) ↔Hom(Y, HomA(A, X)).
But this is easy: given an A-map γ : A × Y →X we construct
Y
−→
HomA(A, X)
y
7−→
[a 7→γ(a, y)]
and given for each y an A-map σy : A →X, we deﬁne
A × Y
−→
X
(a, y)
7−→
σy(a).
[Rough draft, version 2007-05-24 21:36]

134
Polynomials in many variables
8.2
The pullback functor and its adjoints
8.2.1 Adjunction. Brief reminder—for those of me who is not good at
distinguishing left from right. Given two functors
C
F-

G
D
F is left adjoint to G, written F ⊣G, when there is a natural bijection
D(FX, Y) = C (X, GY). Then for the special case D(FX, FX) = C (X, GFX)
the element on the right corresponding to idFX is the adjunction’s unit
1C ⇒G ◦F. Similarly there is the counit F ◦G ⇒1D.
8.2.2 The pullback functor itself. Given ϕ : A →B and a set Y over B,
pullback-fibre
then
ϕ∗Y = A ×B Y = ∑
a∈A
Yϕ(a).
It is often convenient to describe only the ﬁbres: in this case the ﬁbre over
a ∈A is
(ϕ∗Y)a = Yϕ(a).
8.2.3 Details on lowershriek. Given ϕ : A →B and a set X →A, then
ϕ!(X) is described explicitly as
ϕ!X = X = ∑
b∈B ∑
a∈Ab
Xa.
In other words, as a set nothing happens; it is only a question about how
it is organised into ﬁbres. The ﬁbre over b ∈B is
(ϕ!X)b = ∑
a∈Ab
Xa.
8.2.4 The unit for the adjunction ϕ! ⊣ϕ∗. Start with X over A, lower-
shriek it to B, and pull it back to A again. By the above formulae, the ﬁbre
of ϕ∗ϕ!X over a ∈A is
∑
q∈Aϕ(a)
Xq
The unit for the adjunction is simply the map X →ϕ∗ϕ!X deﬁned by
sending Xa into the summand corresponding to q = a.
[Rough draft, version 2007-05-24 21:36]

8.2 The pullback functor and its adjoints
135
8.2.5 The counit for ϕ! ⊣ϕ∗. Starting with Y over B, pull it back to A to
get the set ϕ∗X, and lowershriek it back to B: this just the same set ϕ∗Y
again, and the counit is the map ϕ∗Y →Y itself.
Observe now that the counit ε : ϕ!ϕ∗⇒id is cartesian: indeed, for a
map X →Y over B, the naturality square is the top square in the diagram
ϕ∗X
- X
ϕ∗Y
?
- Y
?
A
?
ϕ
- B,
?
and the top square is cartesian since the bottom square and the big square
are so.
We can also give a useful ﬁbrewise description: let temporarily X de-
note ϕ∗Y; the ﬁbre over a is Xa = Yϕ(a). The formula for the ﬁbre of ϕ!X
over b is (ϕ!X)b = ∑a∈Ab Xa, So with the deﬁnition of X, this means
(ϕ!X)b = ∑
a∈Ab
Xa = ∑
a∈Ab
Yϕ(a) = ∑
a∈Ab
Yb = Ab × Yb.
8.2.6 Details on the lowerstar. Given ϕ : A →B, and a map X →A. Then
ϕ∗X is the set over B given by
ϕ∗X = ∑
b∈B
∏
a∈Ab
Xa.
The slogan for ϕ∗is: multiply the ﬁbres.
To give an element in ∏a∈Ab Xa is to give for each a ∈Ab an element in
X lying over a itself, so we can also describe the ﬁbre (ϕ∗X)b as the set of
all maps s : Ab →X making this triangle commute:
X
Ab
s
-
⊂A
?
[Rough draft, version 2007-05-24 21:36]

136
Polynomials in many variables
Note that in general there is no canonical map X →ϕ∗X over f. In-
deed, to have such a commutative square would mean that the top map is
really a B-map from ϕ!X →ϕ∗X. (That is how ϕ! is deﬁned.) Now by the
adjunction ϕ∗⊣ϕ∗, to give such a map is the same as giving ϕ∗ϕ!X →X,
and there is no way to get a canonical map like this. There is a map in the
other direction, namely the unit of the adjunction ϕ! ⊣ϕ∗. . .
8.2.7 The unit for the adjunction ϕ∗⊣ϕ∗. Start with Y over B, pull back
to A, to get ∑a∈A Yϕ(a), then push forth again to get
ϕ∗ϕ∗Y = ∑
b∈B
∏
a∈Ab
Yϕ(a) = ∑
b∈B
∏
a∈Ab
Yb = ∑
b∈B
YAb
b .
Let us also put the ﬁbre in a displayed formula:
(ϕ∗ϕ∗Y)b = YAb
b .
The unit for the adjunction ϕ∗⊣ϕ∗is the natural map Y →ϕ∗ϕ∗Y
that sends an element y ∈Yb to the constant map Ab →Yb on y.
8.2.8 The counit for ϕ∗⊣ϕ∗(the evaluation map). Start with X over A;
push forth to B and pull back to A again:
ϕ∗ϕ∗X = A ×B ϕ∗X
Before being explicit with sums and products, we can already describe the
counit ϕ∗ϕ∗X →X: recall that the ﬁbre of ϕ∗X over b consists of maps
s : Ab →X over A. Now our ﬁbre product over B consists of pairs (a, s)
where a ∈Ab and s : Ab →X is in ϕ∗X. Now the counit for the adjunction
is just the evaluation map
εX : A ×B ϕ∗X
−→
X
(a, s)
7−→
s(a).
And here comes the ﬁbrewise description: the ﬁbre of ϕ∗X over b is
∏
a∈Ab
Xa. Hence by 8.2.2 the ﬁbre of ϕ∗ϕ∗X over a is
∏
q∈Aϕ(a)
Xq.
[Rough draft, version 2007-05-24 21:36]

8.2 The pullback functor and its adjoints
137
The counit εX : ϕ∗ϕ∗X →X is described ﬁbrewise as the natural pro-
jection from
∏
q∈Aϕ(a)
Xq onto the distinguished factor Xa corresponding to
q = a.
8.2.9 The Beck-Chevalley condition. Given a pullback square
BC
A
ϕ - B
A
α
?
ϕ
- B
β
?
then the following two instances of the Beck-Chevalley condition hold:
Given Y →B there is a canonical isomorphism
ϕ∗β!Y = α!ϕ∗Y.
(natural in Y →B).
Given X →A there is a canonical isomorphism
β∗ϕ∗X = ϕ∗α∗X
(natural in X →A).
The ﬁrst condition is essentially a consequence of the fact that the com-
position of two pullback squares is again a pullback square. The second
condition follows by adjunction. In fact, the two conditions are equiva-
lent: given the ﬁrst isomorphism of functors ϕ∗◦β! = α! ◦ϕ∗, then take
the right adjoint of each of these functors: the right adjoint of ϕ∗◦β! is
β∗◦ϕ∗and the right adjoint of α! ◦ϕ∗is ϕ∗◦α∗. (And conversely, by
taking left adjoints on the second identity.)
8.2.10 Lemma. Given a diagrams
X
A
?
ϕ
- B
A
α
?
ϕ
- B
β
?
[Rough draft, version 2007-05-24 21:36]

138
Polynomials in many variables
there is a canonical map
β!ϕ∗
- ϕ∗α!.
Proof. Apply α! to the counit ϕ∗ϕ∗X →X to get α!ϕ∗ϕ∗X →α!X. Now
use Beck-Chevalley 8.2.9 to get instead ϕ∗β!ϕ∗X →α!X, which gives the
desired map by adjointness.
2
8.2.11 Distributivity. Starting from maps A
ϕ- B
ψ- C, we can con-
distributivity
struct the following diagram by applying ψ∗to the map ϕ : A →B:
A  ε
ψ∗ψ∗A
ψ- ψ∗A
B
?
ψ
-
ϕ
-
C.
eϕ
?
Here ε is the counit for the adjunction ϕ∗⊣ϕ∗.
Now the distributive law holds for any X →A:
ψ∗ϕ!X = eϕ!ψ∗ε∗X
Distributivity as we know it from elementary school describes how to
transform a product of sums into a sum of products. The abstract distribu-
tivity formula here does just that, as we see if we write out explicitly what
it means. Temporarily, put Y = ϕ!X. The ﬁbre of Y over b ∈B is ∑a∈Ab Xa.
Pushing forth Y to C gives a set with ﬁbre ∏
b∈Bc
Yb, so in this case the ﬁbre is
∏
b∈Bc ∑
a∈Ab
Xa.
Hence the left-hand side of the distributivity statement is
ψ∗ϕ!X = ∑
c∈C ∏
b∈Bc ∑
a∈Ab
Xa.
(8.2)
prod-of-sums
Writing only the ﬁbre over c ∈C, the formula is
 ψ∗ϕ!X

c = ∏b∈Bc ∑a∈Ab Xa.
Now for the other way around the diagram. We will work through
the formula a little backwards, starting with an arbitrary map Z →ψ∗A.
Then eϕ!Z is the set over C with ﬁbre
∑
s∈(ψ∗A)c
Zs
[Rough draft, version 2007-05-24 21:36]

8.2 The pullback functor and its adjoints
139
We are interested in the case where Z = ψ∗W for some W over ψ∗ψ∗A.
So in that case the ﬁbre of ψ∗W over s ∈ψ∗A is
∏
m∈(ψ∗ψ∗A)s
Wm
Substituting this formula into the previous, we ﬁnd this expression for the
ﬁbre over c of eϕ!ψ∗W:
(eϕ!ψ∗W)c = ∑
s∈(ψ∗A)c
∏
m∈(ψ∗ψ∗A)s
Wm.
Here we can simplify the indices in the product a little bit: to give an
element in the pullback ψ∗ψ∗A = B ×C ψ∗A that maps to s ∈ψ∗A, and
knowing that this s maps to c, all we need to specify is the ﬁrst factor in
the ﬁbre product, which of course has to lie in the ﬁbre Bc. So we can write
a little more concisely:
(eϕ!ψ∗W)c = ∑
s∈(ψ∗A)c
∏
b∈Bc
Wm.
Finally, the W we are interested in is ε∗X, whose ﬁbre over m ∈ψ∗ψ∗A
is Xε(m). Now the counit ε is just the evaluation map (b, s) 7→s(b), so we
can write Wm = Xε(m) = Xs(b). So here is the ﬁnal expansion of the right-
hand side of the distributivity statement:
(eϕ!ϕ∗ε∗X)c = ∑
s∈(ψ∗A)c
∏
b∈Bc
Xs(b).
(8.3)
sum-of-prods
All the above were just preliminary manoeuvres to make explicit what
distributivity means. At the same time it made it clear that everything is
ﬁbrewise. So in order to prove that (8.2) is equal to (8.3), we can reduce
to the case where C = 1. In this case there is a simpler description of the
lowerstar: ψ∗A is simply the set of sections to ϕ : A →B, which we denote
ΓB(A).
Now the statement is all about these two maps:
X
γ- A
ϕ- B
[Rough draft, version 2007-05-24 21:36]

140
Polynomials in many variables
and the pushforth to C. Consider it like this:
X
γ
- A
ψ∗X
ψ∗(γ)- ψ∗A
B
ψ
-

-
C

-
The map ψ∗(γ) is just
ΓB(X)
−→
ΓB(A)
σ
7−→
γ ◦σ.
The left-hand side of the distributivity equation is
ψ∗ϕ!X = ∏
b∈B ∑
a∈Ab
Xa = ΓB(X).
We want to describe it in terms of pulling back X along ε and then multi-
plying. In other words, we want to write it as a sum. The sum should be
over all s ∈∏
b∈B
Ab = ΓB(A). Well, there is a natural map ΓB(X) →ΓB(A)
namely σ 7→γ ◦σ. (Check that this map is ψ∗(γ).) So it remains to de-
scribe the ﬁbres of this map. Here is the relevant diagram:
s∗(X)
- X
B
?
s
- A
γ
?
To give a section B →X (over s) is the same as giving B →s∗X. So the
ﬁbre is
ΓB(s∗X) = ∏
b∈B
Xs(b)
In total, we have written
ΓB(X) =
∑
s∈ΓB(A) ∏
b∈B
Xs(b)
This is precisely (8.3), the right-hand side of the distributivity equation.
[Rough draft, version 2007-05-24 21:36]

8.3 Basic operations on polynomial functors
141
8.3
Basic operations on polynomial functors
Composition
Assuming we have an intrinsic characterisation of polynomial functors
then it should follow readily from stability properties of the conditions
in the characterisation that the composite of two polynomial functors is
again polynomial. Such a proof would not support our viewpoint that all
operations on polynomial functors should take place on the representing
sets and maps
8.3.1 Proposition. The composite of two polynomial functors is again polyno-
mial.
Proof. Consider the beautiful diagram
·
Π
- ·
Π - ·
·
Π
-
∆

·
∆

·
Π
-
∆

·
∆

·
Π
-
Σ
-
·
Σ
?
·
∆

·
∆

Σ
-
·
Σ
-
In this diagram the labels just indicate what sort of operation we are per-
forming along the given map, ∆indicating pullback, Σ lowershriek, and Π
lowerstar. Given a set X over the lower left-hand set, dragging X through
the lower six map is to apply two polynomial functors to it. According to
the Beck-Chevalley conditions and distributivity, dragging X through the
top sequence of arrows gives the same result, and doing this is clearly a
polynomial functor. Indeed the three squares are deﬁned by pullback, and
the pentagon is constructed as in the distributivity result.
Alternatively, you can give each map a speciﬁc name and start rewrit-
ing using Beck-Chevalley conditions and distributivity. E.g. suppose the
[Rough draft, version 2007-05-24 21:36]

142
Polynomials in many variables
maps are called
A
p - B
C
q
- D
I
s

J
u

t
-
K
v
-
then the proof starts like this:
v!q∗u∗t!p∗s∗= v!q∗t!u∗p∗s∗
interchanging the order of t and u. And so on, inventing names for the
maps in the big diagram. (You do see it all in the diagram!)
2
8.3.2 Graphical interpretation. The following graphical interpretation is
graphical
very useful. The important aspects of an element b ∈B are: the ﬁbre
Eb = p−1(b) and the element j : = t(b) ∈J. We capture these data by
picturing b as a (non-planar) bouquet (also called a corolla)
b
j
e . . .
Hence each leaf is labelled by an element e ∈Eb, and each element of Eb
occurs exactly once. In virtue of the map s : E →I, each leaf e ∈Eb
acquires furthermore an implicit decoration by an element in I, namely
s(e).
An element in E can be pictured as a bouquet of the same type, but
with one of the leaves marked (this mark chooses the element e ∈Eb,
so this description is merely an expression of the natural identiﬁcation
E = ∐b∈B Eb). Then the map p : E →B consists in forgetting this mark,
and s returns the I-decoration of the marked leaf.
Consider now a set over I, say f : X →I. Then the elements of P(X)
are bouquets as above, but where each leaf is furthermore decorated by
elements in X in a compatible way:
[Rough draft, version 2007-05-24 21:36]

8.3 Basic operations on polynomial functors
143
b
j
e . . .
x . . .
The compatibility condition for the decorations is that leaf e may have
decoration x only if f(x) = s(e). The set of such X-decorated bouquets
is naturally a set over J via t (return the label of the root edge). More
formally, P(X) is the set over B (and hence over J via t) whose ﬁbre over
b ∈B is the set of commutative triangles
X 
Eb
I.
s

f
-
Let us work through the diagram and interpret all the sets in graphical
terms. Suppose the polynomial functors are given by I ←B →B →J and
J ←C →C →K
W
- W
- q∗V = Q(B)
V
-

V

distr.
B
p
-

B

C
q
-
-
C
?
I

P
J

-
Q
K
-
(8.4)
big-comp-diagram
According to the general description, the set V is just B ×J C. This is
the set of pairs of bouquets, one B-bouquet b and one C-bouquet f with a
marked leaf, such that the decoration of the marked leaf of f is the same as
the root decoration of b. In other words, the elements are two-node trees,
the lower node being c and the upper node b, and all edges decorated in J:
[Rough draft, version 2007-05-24 21:36]

144
Polynomials in many variables
c
b
Now push this set forth along q: the set q∗V is described as follows,
cf. the general description of pushing forth: its elements are B-bouquets,
where furthermore each leaf is decorated by an element in T. Indeed, by
the general description, q∗V is a set over C whose ﬁbre over c ∈C is the
set of commutative triangles
B  ϕ
Cc
J.

-
I.e. to each leaf of c we have to choose a B-bouquet with the output type
equal to the input type at the leaf.
In other words, we just have the conﬁgurations of all two-level trees,
with the bottom level being a C-bouquet, and the top levels being B-bouquets.
c
b1
b2
b3
The set W : = q∗q∗V is described in a similar manner: they are just
two-level trees with one of the inner edges marked. Indeed, formally its
elements (in the ﬁbre over c ∈C) are pairs (f, ϕ) where f ∈Cc and ϕ is a
diagram like above, so f just selects an inner edge in the previous ﬁgure:
c
b1
b2
b3
∗
The map from here to V simply forgets about the upper nodes not cor-
responding to the marked inner edge. I.e. prune all non-marked edges.
[Rough draft, version 2007-05-24 21:36]

8.3 Basic operations on polynomial functors
145
Formally, it is the evaluation map, sending a pair (f, ϕ) to the pair (ϕ(f), f),
i.e. we no longer have to select a B-bouquet for every leaf, but only for the
one singled out by f.
Finally we have the pulled back versions of these sets. We denote by
V the pullback of V along p. Clearly this is just the set of two-node trees
(lower node in C and upper in B) with a marked leaf of the upper node.
c
b
∗
Finally W : = p∗W is the same conﬁgurations as in W = q∗q∗V, but
with one leaf marked of the node lying over the marked inner edge. Note
that with this leaf marked, the mark on the inner edge becomes superﬂu-
ous since it is determined uniquely as the inner edge leading to the marked
leaf. So in conclusion, W is the set of two-level trees with one marked leaf.
c
b1
b2
b3
∗
Altogether we just recover the description we arrived at by heuristic ar-
guments, namely that the composite is deﬁned in terms of two-level trees.
In particular, the base set for the composite is seen to be
q∗(B ×J C)
which is also what we knew from some other computation we did earlier.
IN FACT, THE LABELS ARE JUST A COMPLICATION THAT DOES
NOT GIVE MUCH. WE OUGHT TO DO THIS ARGUMENT IN THE ONE-
VARIABLE CASE INSTEAD.
This is not strictly associative, because the involved operations, pull-
back, pushforth, and so on are only well-deﬁned up to unique isomor-
phism. If we chose them as algebraic operations from the beginning then
[Rough draft, version 2007-05-24 21:36]

146
Polynomials in many variables
we get a well-deﬁned composition law, but it will only be associative up
to isomorphism. It is clear that the pentagon equation is satisﬁed because
all the weakness comes from universal properties.
Another proof of coherence: given a triple composition, the associator
will be a natural transformation between two slightly different polyno-
mial functors. However, each of these polynomial functors has a natural
isomorphism to the triple composition of functors, which is strictly as-
sociative, and in fact the associator is deﬁned through these, and since
everything is thus anchored in the strict world of functors, coherence is
automatic.
For the same reason, it is clear that the horizontal composition of natu-
ral transformations between polynomial functors works as expected, and
that it satisﬁes the interchange law with vertical composition. It remains
to develop a concrete description like this: given four polynomial functors
and two natural transformation like
E
p - B
E
p - B
I 
s

F
w
6
- B
wwwwww
t
- J 
s

t
-
F
w
6
- B
wwwwww
t
- K
t
-
F
?
q
-
z
-
B
u
?
t
-
F
?
q
-
z
-
B
u
?
t
-
What does the horizontal composite of the natural transformations look
like?
Of course we can take advantage of the fact that we already know from
Cat that the interchange law holds, so we can treat the representable and
the cartesian case separately.
Now since polynomial functors preserve pullbacks, it follows readily
that the horizontal composite of two cartesian natural transformations is
again cartesian. The diagram for this case could easily be drawn, but we
leave it for the variable-type case in the next section.
However, it is almost never the case that the horizontal composite of
two representable natural transformations is representable.
THE DRAWING OF THE DISTORTED ROOF
[Rough draft, version 2007-05-24 21:36]

8.4 Basic properties
147
8.4
Basic properties
Sec:many:basic
8.4.1 Polynomial functors preserve pullbacks.
Indeed, p∗and s∗are
k-preservation
right adjoints so they preserve all limits. The sum functor t! does not pre-
serve all limits—it does not preserve terminal objects—but it does preserve
pullbacks: indeed, given B →J, and a pullback diagram in Set/B:
X ×S Y
- Y
X
?
- S
?
- B
the pullback property does not refer to B at all, so when we compose with
B →J it continues to be a pullback square.
More remarks: it is clear that the terminal object is not preserved: B →
B is terminal in Set/B but the image B →J is certainly not terminal in
Set/J. Similarly, the cartesian product of two objects in Set/B, is the ﬁbre
product
X ×B Y
- Y
X
?
- B
?
and its image in Set/J is still the ﬁbre product X ×B Y, but this is no longer
the direct product in Set/J, since in general X ×B Y ̸= X ×J Y.
In conclusion, t! preserves all sorts of limits over diagrams with a ter-
minal object. For example, pullbacks, and wide pullback (cones).
Since monos can be characterised in terms of pullbacks, it follows that
polynomial functors preserve monos.
8.5
Examples
Special classes of polynomial functors:
8.5.1 Constant polynomial functors. The constant polynomial functors
Set/I →Set with value Λ are represented by the diagrams I ←∅→Λ.
More generally the constant functors Set/I →Set/J with value Λ/J are
[Rough draft, version 2007-05-24 21:36]

148
Polynomials in many variables
represented by I ←∅→Λ →J. If we furthermore want it to be equal in
each output component, we should take a ﬁxed set Λ and use Λ × J.
This deﬁnes a functor Set/J −→Poly(I, J) sending Λ/J to the con-
stant functor. Check that this one has a right adjoint which is evaluation
at ∅. We can compose this adjunction with the adjunction Set →Set/J
which sends Λ to Λ × J. (The right adjoint is the forgetful functor.) This
gives a functor Set →Poly(I, J) which has as right adjoint evaluation at
the empty set.
8.5.2 Partial identity functors (one for each type). For each i ∈I we
multXi
have the identity functor X/I 7→Xi. It is represented by the diagram
I
i
←−1 →1. The effect of multiplying with this functor which de denote
by Xi is:
Xi · (I ←E →B) = I ←E + B →B
where the new B-summand in the top space maps to i. In other words, to
every ﬁbre there is added an extra element (of type i).
8.5.3 Linear functors. This means that the middle map (the multiplication
part) is a bijection—we can assume it is the identity map. Then we are
talking about diagrams like
A
I
s

J
t
-
The set A is indexed in simultaneously by the two sets I and J, so it is really
a matrix of sets! Now many concepts from linear algebra carry over, but
of course it is more precisely linear algebra over N we are talking about!
Since this is cool anyway, the whole next subsection is dedicated to this. . .
8.5.4 Afﬁne functors.
affine-many
8.5.5 In case of map over I. Suppose we are given a commutative diagram
E
p
- B
I
t

s
-
[Rough draft, version 2007-05-24 21:36]

8.6 Differential calculus of polynomial functors
149
This is a special case of a polynomial functor. In this case, the formula
∑
i∈I ∑
b∈Bi ∏
e∈Eb
Xs(e)
simpliﬁes a little bit: since the triangle commutes we have s(e) = i, so the
expression simpliﬁes to
∑
i∈I ∑
b∈Bi
XEb
i .
Taking for granted the statement that polynomial functors make sense
in any topos, then the functors of this type are those that are one-variable
polynomial functors in the topos Set/I.
8.6
Differential calculus of polynomial functors
Introduction
Partial derivatives
In two variables, given {1, 2} ←E1 + E2 →B, the derivative with respect
to 1 is
{1, 2} ←(E1 ×B E1) ∖∆+ E1 × E2 →E1
where the summand (E1 ×B E1) ∖∆maps to 1 and the summand E1 × E2
maps to 2.
Spell it out:
(X1, X2)
−→∑
e
∏
u∈((E1×BE1)∖∆+E1×E2)e
Xs(u)
=
∑
e
∏
u∈((E1×BE1)∖∆)e
X1
∏
u∈E1×E2)e
X2
=
∑
e∈E1
XE1−{e}
1
XE2
2
If we picture the ﬁbre over b ∈B as a column of white dots (going to
1) and black dots (going to 2), then the new base is E1, and the ﬁbre over
some white dot is the set of possible other dots in the same ﬁbre. This
means it can be another white dot or any black dot in that ﬁbre, and this
explains the shape of the formula.
[Rough draft, version 2007-05-24 21:36]

150
Polynomials in many variables
So in short: the base is E1, and for each e ∈E1 the new ﬁbre is the
complement of e in the old ﬁbre.
8.6.1 Example. Now let us work out ∂1∂2. The result is
E1 ×B E1 ∖∆×B E2 + E1 ×B (E2 ×B E2 ∖∆)
E1 ×B E2
?
(and we should specify that the left-hand summand maps to 1 and the
right-hand summand to 2). The conclusion is that the new base is the set
of pairs (e1, e2), two dots in the same ﬁbre and of different colour, and the
ﬁbre over such pair is the complement of that ﬁbre.
WRITE OUT THE GENERAL FORMULA.
Homogeneous functors and Euler’s Lemma
TIGHTEN UP THE FOLLOWING CHILDISH DISCUSSION
8.6.2 The degree of a homogeneous polynomial. The degree of the good-old monomial
x3y2 is 5, and you compute that by ‘forgetting’ that x and y are distinct variables: con-
sidering them to be the same (say x), the monomial is x3x2 = x3+2 = x5, and hence the
degree is 5.
Similarly a monomial in many variables
E
- 1
I
s

1
-
which is
(Xi)i∈I 7→∏
e∈E
Xs(e)
Considering all the variable to be equal clearly this monomial is of degree E. In a sense
we obtain this result by precomposing the functor with lowershriek along d : I →1 and
then pullback to I . This yields ∏e∈E Xd(s(e)) = ∏e∈E X = XE.
More precisely, we actually started with a set over I then consider it a set over 1, this
means lowershriek it along d: this destroys the difference between the variables. Now
pull it back along ﬁrst d then s.
[Rough draft, version 2007-05-24 21:36]

8.6 Differential calculus of polynomial functors
151
This trick reduces the question to the one-variable case, and again we can deﬁne a
homogeneous polynomial to be one
E
- B
I

J
-
such that E = B × F for some set F.
Deﬁnition. A polynomial functor I ←E →B is homogeneous of degree F if
E = F × B. Here F is a ﬁxed set. More generally, we will say that I ←
E →B is homogeneous of degree F if there is speciﬁed an isomorphism
(as polynomial functors) with one of the form F × B.
Note that the map s : F × B →I in general is different on each copy of
F.
8.6.3 Example. It is evident that every monomial E →1 is homogeneous
(of degree E).
8.6.4 Derivatives of monomials. Note that with the above deﬁnition of
homogeneous, the derivative of a monomial is not naturally homogeneous:
(say in the one-variable case), if E →1 is a monomial, then the derivative
is E × E ∖∆→E. There is no natural way to trivialise this: there is no
canonical way to provide a bijection E × E ∖∆≃(E ∖{e}) × E, as we
remarked already in the deﬁnition of the derivative. In contrast, the dif-
ferential operator XD provides a homogeneous polynomial: XD applied
to E →1 gives E × E →E. And more generally, given a homogeneous
polynomial F × B →B then if we apply XD we get F × F × B →F × B,
which is again homogeneous.
8.6.5 Homogenisation. Don’t know what use of this. . . A homogenisation
of I ←E →B (to degree F) consists in introducing a new variable and a
diagram
I 
E
- B
∩
∩
I + 1 
F × B
- B
w
such that the complement of E in F × B is mapped to the new variable.
[Rough draft, version 2007-05-24 21:36]

152
Polynomials in many variables
Let Λ be a ﬁxed set. We denote by ·Λ the functor
Set/I
−→
Set/I
X/I
7−→
(Λ × X)/I.
It is represented by the linear polynomial I ←Λ × I = Λ × I →I.
8.6.6 Lemma. Let P be a homogeneous polynomial functor of degree F:
I ←F × B →B
and let Λ be any set. Then there is a canonical natural isomorphism ﬁlling the
square
Set/I
Λ·- Set/I
Set
P
?
ΛF·
- Set
P
?
Proof. We should prove this in formal Beck-Chevalley style, but here is a
quick and dirty proof: The upper-right-hand way around gives
X/I 7→(Λ × X)/I
7−→∑
b∈B
∏
e∈(F×B)b
(Λ × X)s(e)
=
∑
b∈B
∏
e∈(F×B)b
(Λ × Xs(e))
=
∑
b∈B
∏
e∈(F×B)b
Λ
∏
e∈(F×B)b
Xs(e)
=
∑
b∈B
ΛF ×
∏
e∈(F×B)b
Xs(e)
=
ΛF × ∑
b∈B
∏
e∈(F×B)b
Xs(e)
which is precisely what the other way around gives. The equality signs
represent canonical isomorphism.
2
8.6.7 The Euler operator. Recall that the operator Xi · ∂i sends I ←E →
B to Ei ×B E →Ei (no diagonal removed). Indeed, we know that ﬁrst
[Rough draft, version 2007-05-24 21:36]

8.6 Differential calculus of polynomial functors
153
the partial derivative gives us Ei ×B Ei ∖Ei ×B E →Ei, and then the Xi-
multiplication consists in adding an i-point in each ﬁbre. This is precisely
to ﬁll in back the diagonal.
Deﬁne the Euler operator to be
Euler := ∑
i∈I
Xi · ∂i
Note that if P is given by I ←E →B then Euler P is given by
I ←E ×B E →B.
In other words, take the derivative as if all the variables were the same. . .
8.6.8 Lemma. (Euler’s lemma) If P : Set/I →Set is homogeneous of degree F
then there is a natural isomorphism
Euler P = F × P
Proof. The classical proof is to write down the homogeneity equation
P(Λ × X) = ΛF × P(X)
and recall that it is natural in Λ. Hence we can take derivative with respect
to Λ. Now we have to invoke the chain rule
DO THAT
and ﬁnally set Λ = 1 to arrive at the promised formula.
The second proof exploits direct manipulation with the representing
diagrams: we already observed that the Euler operator on I ←E →B
gives I ←E ×B E →E. In the special case where the polynomial is homo-
geneous of degree F, this gives F × F × B →F × B. But this is clearly the
same as F × P.
2
Note that Euler’s lemma for good-old polynomials is also a triviality:
by linearity it is enough to prove for monomials: each Xi∂i just has the
effect of placing the exponent of that variable as a coefﬁcient. When sum-
ming all these we get of course the total degree.
8.6.9 Interpretation of variables as constants In order to better under-
stand partial derivation we should investigate how to interpret other vari-
ables as constants.
[Rough draft, version 2007-05-24 21:36]

154
Polynomials in many variables
8.6.10 Example. Given {1, 2} ←E1 + E2 →1, which is just XE1
1 XE2
2 , we
want to think of XE2
2 as a constant B. The new polynomial is
{1} ←E1 × B →B
Indeed,
X1 7→∑
b∈B
XE1 = B × XE1
as we wanted. The new polynomial is a family of polynomials parametrised
by X2. There is really some internal hom adjunction going on that we
should get straight:
Set I1 × Set I2 −→Set
Set I2 −→Poly(Set I1, Set)
8.7
Linear functors (matrices)
Sec:linear
8.7.1 Notation for linear algebra. We are going to develop some rudimen-
tary linear algebra, and let us ﬁx some notation. We want the following:
composition is denoted left-to-right, so that the composite of linear maps
U
A- V
B- W
will be the matrix product AB. Hence in particular, a linear maps does
x 7→x · A. This means that vectors are row vectors.
We want to distinguish upper and lower indices like in physics. Hence
the above products should read
∑
j
Ai
j · Bj
k = Ci
k
and ∑i xiAi
j
If you think this looks strange, try to work out a few matrix multipli-
cations, just to get used to it before starting on the linear functors. . .
An alternative notation would be to move the upper indices down on
the left side. Then matrix multiplication looks like this
iAj · jBk = iCk
[Rough draft, version 2007-05-24 21:36]

8.7 Linear functors (matrices)
155
8.7.2 Linear functors. This means that the middle map (the multiplication
part) is a bijection. For simplicity we assume it is the identity map, so we
are talking about diagrams
A
I
s

J
t
-
The corresponding polynomial functor F is
(Xi | i ∈I) 7→( ∑
a∈Aj
Xs(a) | j ∈J)
which of course we call a linear functor. As usual, let Aj denote the subset
t−1(j) ⊂A. Since there are no exponents involved in linear functor, we
will allow ourselves to use upper indices now: let Ai denote the subset
s−1(i) ⊂A. Let Ai
j denote the intersection Ai ∩Aj. Hence
A = ∑
i,j
Ai
j.
Now, this is just a matrix of sets—the rows of the matrix are indexed by
I, and the columns are indexed by J. Many notions like rows and columns
usually assume that I and J are ﬁnite ordered sets, but in fact many con-
cepts don’t require this assumption.
Now the linear functor is
F : Set/I
−→
Set/J
X
7−→
A × X
(Xi | i ∈I)
7−→
(Yj | j ∈J)
with
Yj = Ai
jXi
WITH THE ABOVE CONVENTION, I THINK THIS SOULD BE X × A
and Xi × Ai
j
So the linear functors Set/I →Set/J are given by the set Set/(I × J).
[Rough draft, version 2007-05-24 21:36]

156
Polynomials in many variables
8.7.3 Composition of linear functors—matrix multiplication. Given lin-
ear functors (and we have to ﬁnd a good convention to make the order
look right in all cases. . . )
I ←A →J ←B →K
clearly the composite linear functor is given by the ﬁbre product A ×J B.
Let us look at the i
k ﬁbre (A ×J B)i
k. It is the sum
∑
j∈J
Ai
j × Bj
k
which says that A ×J B is precisely the matrix product of A and B. Well,
what else would you expect?
In conclusion, the formula for multiplying two matrices is just a pull-
back formula!
The linear functors I ←B →J sit inside Poly(I, J) as a full subcate-
gory.
Note that for between linear functors there is no difference between
general natural transformation and cartesian ones, so Lin(I, J) is also a full
subcategory of POLY(I, J). However, the following result only applies to
Poly(I, J):
namely that the inclusion functor has a right adjoint.
It is the functor
Poly(I, J)
−→
Lin(I, J)
E/B
7−→
E1/B1
which only retains the linear part. I.e. we take the subset B1 ⊂B consisting
of elements whose ﬁbre is singleton and then E1 ≃B1.
Indeed if I ←M →J is a linear functor, and I ←E →B →J is a
general polynomial functor, then to give a cartesian map from M/M into
E/B is the same as giving one into the linear part, because all elements in
M are of arity 1, so have to map to the arity-1 operations in B.
Note that in general there is no cartesian map from E/B to M/M, so
there is certainly not a left adjoint to the inclusion.
Note that the linear-part functor is neither full not faithful: any two
cartesian maps between polynomial functors without linear part are mapped
[Rough draft, version 2007-05-24 21:36]

8.7 Linear functors (matrices)
157
to the identity map of ∅, so linear-part functor is not faithful. It is not full
either, because there are no cartesian maps between the polynomial func-
tors 3/1 and 2/1, yet there is the identity map on the linear part.
THE FOLLOWING DISCUSSION SHOULD BELONG TO THE VARIABLE-
TYPE CASE: HOWEVER: if we restrict to the category of trees (the big one
with three sorts of maps), then we know that a map between trees is com-
pletely determined by its value on edges (these are unary operations), so
this shows in particular that the linear-part functor is faithful when re-
stricted to the subcategory of trees. It is still not full: for the single-dot tree
of arity 2, then the linear part is the functor 3 ←3 →3. This one has 3!
automorphisms whereas the original tree only has 2.
More generally, deﬁne Polyn to be the sub-2-category of Poly consist-
ing of the polynomial functor of degree at most n. This means that the car-
dinality of each ﬁbre of E →B is at most n. (We could deﬁne Aff := Poly1,
the afﬁne functors mentioned in (1.2.4 and) 8.5.4.) Again the inclusion
functor Polyn ֒→Poly has a right adjoint which only takes the subset of B
for which the ﬁbre is at most n.
An important case of this is the n = 0: the category Poly0(1, 1) is natu-
rally identiﬁed with Set, and more generally, Poly0(I, J) is identiﬁed with
Set/J. The right adjoint is evaluation at ∅.
And similarly, for any m ≤n, the inclusion Polym ֒→Polyn has a right
adjoint.
Similarly, we could consider polynomial functors of precisely degree
n, or perhaps even go for those of degree F for a ﬁxed set F.
[Rough draft, version 2007-05-24 21:36]

158
Polynomials in many variables
[Rough draft, version 2007-05-24 21:36]

Chapter 9
Categories of polynomial functors
9.1
The functor category POLY(I, J) of polyno-
mial functors Set/I →Set/J
Fixed-variables case
For the moment we keep two sets I and J ﬁxed. Let POLY(I, J) denote the
full subcategory of Cat(Set/I, Set/J) consisting of the polynomial func-
tors (i.e. those isomorphic to one of the form of our diagrams), and all
natural transformations between them.
9.1.1 Morphisms. We argued in Chapter 2 that in the one-variable case
cartesian squares and backwards triangles give rise to natural transfor-
mations between polynomial functors, and that all natural transforma-
tions arise as composition of a backwards triangle followed by a cartesian
square. The same is true in the many-variable case, and in fact the proofs
will now seem much easier, because we have the more abstract viewpoints
of adjunctions and Beck-Chevalley conditions at our disposal.
[Rough draft, version 2007-05-24 21:36]

160
Categories of polynomial functors
9.1.2 Representable morphisms. Given a diagram
E
p - B
I
s

J
t
-
F
w
6
q
-
z

B
wwwwwwwwww
t
-
then there is induced a natural transformation
t!p∗s∗
η⇒t!p∗w∗w∗s∗= t!q∗z∗
where η : 1 ⇒w∗w∗denotes the unit for the adjointness w∗⊣w∗.
[One might think that conversely every natural transformation between
these polynomial functors would be induced in this way, but this is not
true: for example the polynomial functor 1 ←2 →2 →1 (which sends
X to X + X) has a nontrivial automorphism given by the twist map (inter-
change of factors). This one is not induced by a diagram like the above.
What is true is that every natural transformation for which the terminal-
object component is the identity on B does come like this, cf. the Yoneda
lemma below.]
[Here there is a problem that we want to describe natural transforma-
tions t!p∗s∗
η⇒t!p∗w∗w∗s∗= t!q∗z∗by cancelling away t!. In order to do
this we would like Nat(P, Q) →Nat(t!P, t!Q) to be a bijection or at least a
surjection. This is equivalent to requiring the functor
Fun(Set/I, Set/B)
−→
Fun(Set/I, Set/J)
P
7−→
t!P
to be fully faithful or at least full. This is not the case in general though:
for example if J = 1, then it is not true that given X/B and Y/B then every
arrow X →Y over I is also over B. It is true that t! is faithful, but this
doesn’t help. What really does the job is the fact that all components of the
natural transformation lie over P(1) →Q(1). . . ]
[Rough draft, version 2007-05-24 21:36]

9.1 The functor category POLY(I, J) of polynomial functors
Set/I →Set/J
161
9.1.3 Cartesian morphisms. Given a diagram
E
p - B
I
s

J
t
-
E
u
?
p
-
s

B
k
?
t
-
then there is induced a natural transformation
t!p∗s∗= t!k!p∗u∗s∗B-C
= t!k!k∗p∗s∗⇒t!p∗s∗
where the last step was the counit for the adjunction k! ⊣k∗. Now the
counit for this adjunction is always cartesian (easy fact). Whiskering with
t! and p∗s∗do not alter the cartesianness, because each of these functors
preserve pullbacks (easy: p∗and s∗are right adjoints, so they preserve all
limits. t! preserves wide pullbacks (cones)).
We can now prove the fundamental theorem about polynomial func-
tors:
9.1.4 Theorem. Every natural transformation between polynomial functors fac-
tors uniquely as a representable natural transformation followed by a cartesian
one.
Proof. The statement is: given a diagram
E
p - B
I
s

J
t
-
F
q
-
z

C
m
-
[Rough draft, version 2007-05-24 21:36]

162
Categories of polynomial functors
and a natural transformation t!p∗s∗⇒m!q∗z∗then there exist maps
E
p - B
I 
g
s

F ×C B
w
6
r- B
wwwwww
- J
t
-
F
v
?
q
-
z

C
u
?
m
-
inducing the given natural transformation. The uniqueness statement is
clariﬁed by this: if this diagram exists it is unique up to unique isomor-
phism by the universal property of the pullback.
The key point is that the terminal-object component of the natural trans-
formation gives us a J-map u : B →C. Since all other components lie over
this one, they are all C-maps, so we reduce to the task of describing all nat-
ural transformations u!p∗s∗⇒q∗z∗, and by adjointness these correspond
to the natural transformations
p∗s∗⇒u∗q∗z∗.
Now form the pullback square in the desired diagram, and apply Beck-
Chevalley to it: we have reduced to a natural transformation
p∗s∗⇒r∗v∗z∗= r∗g∗
which by the following Yoneda lemma must be induced by a unique w :
F →E. It is clear from the construction of u and w that the diagram
induces the original natural transformation.
2
9.1.5 Yoneda lemma. Given a diagram
E
I
s

B
p
-
F
q
-
z

[Rough draft, version 2007-05-24 21:36]

9.1 The functor category POLY(I, J) of polynomial functors
Set/I →Set/J
163
the canonical map
HomI,B(F, E)
−→
Nat(p∗s∗, q∗z∗)
w
7−→
[p∗s∗
η⇒p∗w∗w∗s∗= q∗z∗]
is a bijection.
Proof. Since lowerstarring is a ﬁbrewise construction we reduce to the case
B = 1. In this case p∗s∗is just the functor X/I 7→HomI(E/I, X/I), and
the result follows from the usual Yoneda lemma for Set/I.
Some details: p∗s∗X = ∏e∈E(X ×I E)e = ∏e∈E Xs(e) = HomI(E/I, X/I) =
∏i∈I XEi
i .
2
The theorem says that there is a factorisation system on POLY(I, J), but
note that the class of representable morphisms is not saturated in the sense
that it does not contain all isomorphisms: it only contains isomorphisms
P ∼
→Q for which P(1) →Q(1) is the identity map. These are precisely
the vertical arrows for the functor P 7→P(1), and the theorem can be
formulated a little bit more precisely as follows:
9.1.6 Theorem. The functor
POLY(I, J)
−→
Set/J
P
7−→
P(1)
is a Grothendieck ﬁbration. The cartesian arrows are precisely the cartesian natu-
ral transformations.
The importance is not just the ability to factor natural transformations,
but as much the mere fact that every natural transformation can be cap-
tured on the level of the representing sets, so that all computations become
mere manipulations of sets.
Furthermore the following important corollary results: Consider the
category whose object are the diagrams representing polynomial functors.
The arrows are given as the natural transformations of the induced func-
tors. Then by construction, the inclusion is fully faithful, and the essential
image, the category of all functors isomorphic to a polynomial one is an
equivalent category.
Note that even if a given functor is isomorphic to a polynomial one,
then there may be several different isomorphisms. This just amounts to
[Rough draft, version 2007-05-24 21:36]

164
Categories of polynomial functors
saying that some polynomial functors admit automorphisms. For example
1 ←N′ →N →1 has automorphisms which are even vertical for the
ﬁbration, given by permuting the elements of the ﬁbres of N′ →N.
9.1.7 Handling natural transformations. By the Theorem, natural trans-
formations between polynomial functors are diagrams like above. To com-
pose them, one should just compose the corresponding natural transfor-
mations, and then factor the result into representable followed by carte-
sian. This is not an economical way to do it in practice though, because the
starting representable and the ending cartesian factors are already in place.
It is enough to refactor the middle part: refactor cartesian-followed-by-
representable into representable-followed-by-cartesian. This is very easy:
given
E
p
- B
I 
s
s

E
v
?
p
- B
u
?
t
- J
t
-
F
w
6
q
-
z
-
B
wwwwww
t
-
put F = F ×B B. By the pullback property of E, the map w induces a map
w : F →E, and the diagram
E
p
- B
I 
s

F
w
6
- B
wwwwww
t
- J
t
-
F
?
q
-
z
-
B
u
?
t
-
which we claim is the sought factorisation, i.e induces the same natural
transformation as the original diagram. The original natural transforma-
tion was made up of 1 ⇒w∗w∗and u!u∗⇒1. The natural transforma-
tion corresponding to the second diagram is made out of 1 ⇒w∗w∗and
[Rough draft, version 2007-05-24 21:36]

9.1 The functor category POLY(I, J) of polynomial functors
Set/I →Set/J
165
u!u∗⇒1. The fact that these two natural transformations are the same is
roughly a question of compatibility of adjunction along pullback. . . ?
Let’s try to collect it all in a single diagram:
E
B
p
-
F
w
-
q
-
I
s

z

J
t
-
E
v
-
s

B
u
?
t
-
p
-
F
f
-
z

w
-
q
-
The three squares are pullback squares. The original natural transforma-
tion is achieved by passing through E. The new one is obtained by passing
through F. All it amounts to is to observe that the two natural transforma-
tions
v∗⇒w∗w∗v∗
and
v∗⇒v∗w∗w∗
are the same. Indeed, the result is the same:
w∗w∗v∗B-C
= w∗f∗w∗= v∗w∗w∗.
This is to say that the pullback of an adjoint pair (and its adjunction
homomorphisms) is again an adjoint pair. . . The rest of the proof is just to
start with s∗and end with u!t!.
This gives an explicit description of composition of natural transfor-
mations between polynomial functors, but in order for it to be strictly as-
sociative (and strictly unital) we just need to recall that we identify two
diagrams if they only differ in the middle part (this difference is unique,
so there are no coherence problems). Indeed, two different factorisations
of the same natural transformation obviously represent the same natural
transformation. . .
[Rough draft, version 2007-05-24 21:36]

166
Categories of polynomial functors
9.1.8 Note. THIS SHOULD BE MOVED TO THE SECTION ON CATE-
GORICAL POLYNOMIAL FUNCTORS Note that we are pushing forth
along w (and w). In the categorical setting this might require some special
properties of w. For example that it should be a Conduché ﬁbration. But
note that in that case we had already assumed p and q to be Conduché
ﬁbrations, and there should be a rule ensuring that if q = k#p and p and q
are Conduché ﬁbrations, then k is too. This is for example true for discrete
ﬁbrations (as one can see from ﬁnal-discreteﬁbration factorisation).
Sums and products in POLY(I, J)
9.1.9 Sums. The sum of two polynomial functors (with common source
and target) is just obtained by taking sums of B and E:
E1 + E2 - B1 + B2
I

J
-
WRITE OUT THE DETAILS HERE. check that the universal property
is satisﬁed and that the sum inclusions are cartesian.
9.1.10 Products. When we talk about products of polynomial functors
with values in Set J, we are referring of course to products in Set/J. Note
that if X and Y are sets over J then their product in Set/J is just the ﬁbre
product X ×J Y.
The product of two polynomial functors should be just the product of
their values. The product of I ←E →B →J and I ←F →C →J should
be
E ×J C + B ×J F
- B ×J C
I
s
?
J
?
Here s is given by projection onto the E and F factors. (Note that this is
not the product in the smaller category Poly(I, J).)
SOME EXAMPLE
[Rough draft, version 2007-05-24 21:36]

9.2 Poly(I, J): the cartesian fragment
167
Misc
Temporarily let [n] denote the indexing set {1, 2, . . . , n}. Let FinSet[X1, . . . , Xn]
denote the category of polynomial functors Set/[n] →Set represented by
[n] ←E →B with E and B ﬁnite. The Burnside rig of this is N[X1, . . . , Xn].
9.2
Poly(I, J): the cartesian fragment
Let Poly denote the 2-category of all polynomial functors and their carte-
sian natural transformations. It is deﬁned as a sub-2-category of Cat as
follows: The objects are the slice categories Set/I. The arrows from Set/I
to Set/J are the polynomial functors (represented by diagrams I ←E →
B →J), and the 2-cells are the natural transformations between them.
Recall that horizontal composition of cartesian natural transformations
between polynomial functors produces cartesian natural transformations
again, since polynomial functors always preserve pullbacks, cf. 2.1.6.
We have described the representation of the natural transformations in
terms of diagrams. The factorisation system also describes how to com-
pose two natural transformations vertically in terms of these diagrams.
We should now explain how they are composed horizontally.
Note that the arrows are the polynomial functors Set/I →Set/J, not
the diagrams. This meant that we are including functors which are only
isomorphic to ones given by such diagrams. (And also that we are consid-
ering two diagrams the same if they represent the same functor CAN THIS
HAPPEN??? (and then they differ only by some bijections).) Doing it this
way ensures that composition is well-deﬁned and strictly associative. Had
we taken the arrows to be diagrams, then the composition would only be
deﬁned up to unique isomorphisms (since it basically relies on pullback),
and composition would only be deﬁned up to this sort of sloppiness, and
hence it would not be strictly associative. We would get only a bicate-
gory. Even for 2-cells, if we had let the 2-cells be the actual diagrams we
would have some looseness, suggesting that there might even be a weak
3-category around: the vertical composition of 2-cells is not strict, because
it involves a pullback too. (Note however that in this case, one could get
away with deﬁning two 2-cells to be the same if there is a comparison iso-
morphism, and since this is a comparison between two pullbacks there
can be at most one, and hence there is a clique of equivalent 2-cells. . .
[Rough draft, version 2007-05-24 21:36]

168
Categories of polynomial functors
The following long computation is like a ﬁrst step in this direction, showing
how to whisker a 2-cell (just a cartesian one) with a 1-cell. The horizontal com-
position could be deﬁned in terms of this, but then we would have to verify that
the two ways of deﬁning them coincide. Also, we would have to generalise the
argument to more general 2-cells than just the cartesian ones. . .
We will show that composition with a polynomial functor is functorial with
respect to cartesian 2-cells. THIS SHOULD FOLLOW AUTOMATICALLY FROM
GENERAL PRINCIPLES. . . YES, SINCE POLYNOMIAL FUNCTORS PRESERVE
PULLBACKS (1.4.1), HORIZONTAL COMPOSITION OF CARTESIAN NATU-
RAL TRANSFORMATIONS IS AGAIN CARTESIAN (2.1.6).
Hence this long
computation is probably superﬂuous.
However, its ideas are needed for the
double-cat stuff. . .
Given a polynomial functor
E
p - B
I
s

P
J
t
-
then there is induced a map
Poly(H, I)
−→
Poly(H, J)
Q
7−→
P ◦Q
What we’ll show here is that if there is given a cartesian natural transforma-
tion Q ⇒Q′ (given by
F
q - C
H

I
-
F′
?
-

C′
?
-
then there is induced a cartesian transformation P ◦Q ⇒P ◦Q′.
The proof consists in splitting the statement into three pieces, depending on
the three steps of P. It is enough to show that the result is true for these three
functors
Poly(H, I)
s∗- Poly(H, E)
p∗- Poly(H, B)
t!- Poly(H, J)
[Rough draft, version 2007-05-24 21:36]

9.2 Poly(I, J): the cartesian fragment
169
For the ﬁrst case, we are concerned with a diagram
F
q - C
H

I s
-
E
F′
?
-

C′
?
-
To compute the composition of these polynomial functors amounts to performing
four pullbacks. In fact the resulting polynomial functor is just the pullback of the
whole diagram along s:
F ×I E
- C ×I E
H

E
-
F′ ×I E
?
-

C′ ×I E
?
-
It is obvious that this square is again cartesian.
The second part is the hard part. Renaming the objects, we are in this situa-
tion:
F
q - C
H

E
p-
-
B
F′
?
-

C′
?
-
To compute this composition (we look at the top part), we ﬁrst have to take p∗(C).
Now consider the pullback back along p:
p∗p∗(C)
- p∗(C)
E
?
p
- B
?
Now by adjunction we have the canonical evaluation map p∗p∗(C) →C (and we
should check that it commutes with the map down to E). Description of this map:
Now compare with what happens in the bottom part: the same thing. We have
[Rough draft, version 2007-05-24 21:36]

170
Categories of polynomial functors
a map p∗(C) →p∗(C′), and pulling it back we also get p∗p∗(C) →p∗p∗(C′).
This square
p∗p∗(C)
- p∗(C)
p∗p∗(C′)
?
- p∗(C′)
?
is a pullback for the following reason: arrange the squares like this:
p∗p∗C
- p∗C
p∗p∗C′
?
- p∗C′
?
E
?
p
- B.
?
Here the big square and the bottom square are pullbacks by construction. Hence,
the top square is too (A.1).
Next we pullback p∗p∗(C) →C along q and q′. This gives q∗p∗p∗(C) and
q′∗p∗p∗(C′). There is a map between them. Now we have cartesian squares
q∗p∗p∗(C)
- p∗p∗(C)
F
?
- C
?
F′
?
- C′
?
q′∗p∗p∗(C′)
6
- p∗p∗(C′)
6
By some cube argument, we can conclude that the square
q∗p∗p∗(C)
- p∗p∗(C)
q′∗p∗p∗(C′)
?
- p∗p∗(C′)
?
[Rough draft, version 2007-05-24 21:36]

9.3 Variable types (in cartesian case)
171
is also cartesian. This is what we wanted to prove.
(The cube argument is something like: if the left face bottom and front are
cartesian then the top is too. This is just a variation of the previous general result
about pullback squares.)
Finally for t! it is immediate that the cartesian squares are preserved, because
it stays the same.
Note also that all of these three functors preserve monomorphisms. That is,
if the vertical maps in the original pullback square are monos, then the resulting
ones are too.
This is just a question of following the constructions through, and observe
that we are mostly using pullback, and forming pullback preserves monos. At
one point we also used a pushforth, but this is like taking product, and a product
of monos is again a mono.
Sums and products in Poly(I, J)
9.3
Variable types (in cartesian case)
variable-types
It is crucial to be able to compare polynomial functors with different sets of
types. We introduce a notion of map between polynomial functors which
a priori is not a natural transformation of any kind but which turns out
to be the correct notion (at least in the cartesian context). Simply deﬁne a
category Poly whose objects are all the polynomial functors, irrespective
of types, and where the morphisms are diagrams
D 
U
- V
- C
I
?

E
?
- B
?
- J.
?
When the polynomial functors are polynomial monads corresponding
to coloured operads, the notion agrees with the notion of morphism be-
tween coloured operads via base change. In fact the notion of base change
generalises to polynomial functors: given a polynomial functor P repre-
sented by I ←E →B →J and set maps α : I →I and β : J →J, there
is a base changed polynomial functor I ←E →B →J denoted (α, β)∗P
with the property that morphisms into P are in 1–1 correspondence with
[Rough draft, version 2007-05-24 21:36]

172
Categories of polynomial functors
cartesian natural transformations into (α, β)∗P. This is to say that any
map Q →P with ends α and β factors uniquely through (α, β)∗P. All
this amounts to saying that the functor Poly →Set × Set that returns the
endpoints is a Grothendieck ﬁbration.
9.3.1 Graphical explanation. It is easy to explain in graphical terms what
the base change amounts to and why it has a universal property. If I ←
E →B →J is a polynomial functor, then the set of operations B is pictured
as the set of bouquets
PICTURE
where each leaf has a decoration in I and the root has one in J. For
the polynomial functor pulled back along α : I →I and β : J →J, the
set of operations is the same but where each leaf is also decorated with
an element in I (required α-compatible with the decoration in I), and the
root has also a J-decoration (β-compatible with the J-decoration). In other
words, instead of having just the decoration in I and J imposed by the
polynomial functor (i.e. i decorates leaf e if and only if s(e) = i and j
decorates the root edge of b if and only if t(b) = j) we take all decorations
in the α-ﬁbre over s(e) for each leaf e, and the whole β-ﬁbre over t(b) for
the root.
(α, β)∗B = {B −bouquetswitheachlea f decoratedinIsuchthat
I.e. maps Eb →I over I. And also an element x ∈J such that β(x) = t(b)
We call this set B. The map from B →B just forgets the extra deco-
rations. If D ←U →V →C is another polynomial functor with a map
to P in the sense described, it means that each operation in V is mapped
to an operation in B in a way compatible with ﬁbres and decorations. It
is clear that this map factors through B in a unique way compatible with
ﬁbres and decorations.
The new decoration on the root edge is just a question of taking a pull-
back. For the new decoration on the leaves, it amounts to evaluating the
polynomial functor on the family α : I →I (except for the last lower-
shriek). It is intuitively clear that these two operations commute.
Let us now turn to the formal description.
[Rough draft, version 2007-05-24 21:36]

9.3 Variable types (in cartesian case)
173
9.3.2 Base change at codomain. Given
J
I 
s
E
p
- B
t
- J
β
?
the construction is simply
I 
E ×J J
- B ×J J
- J
I
wwwwww

s
E
?
p
- B
?
t
- J
β
?
This deﬁnes the polynomial functor (I, β)∗P and a map to P.
Note that we think of P as a point of Poly lying over (I, J), and that we
are constructing a cartesian lift of the arrow (I, β).
9.3.3 Lemma. These arrows (I, β)∗P are strongly cartesian.
This means that in each diagram, the dashed arrows are unique.
D
j
I =====
-
I
U
6
E ×J J
6
j
-
-
E
s
6
V
?
B ×J J
?
j
-
-
B
p
?
C
?
J
?
j
β
-
-
J
t
?
This is evident from the universal property of the pullback.
[Rough draft, version 2007-05-24 21:36]

174
Categories of polynomial functors
9.3.4 Base change at domain. This is trickier. Given a diagram
I
I
α
?

s
E
p
- B
t
- J
the cartesian lift of (α, J) to I ←E →B →J is:
I 
p∗p∗s∗I
- p∗s∗I
- J
I
wwwwww

s∗I
ε
?
I
α
?

s
E
?
p
- B
?
t
- J
wwwwwwwwwwwwwwww
Note that s∗I is the set of B-bouquets with a marked leaf e and with e
decorated by an element i ∈I such that α(i) = s(e). In contrast, p∗p∗s∗I
is the set of B-bouquets with a marked leaf, but where all leaves has a
compatible I decoration. The counit ε just forgets all the decorations except
at the marked leaf.
9.3.5 Lemma. These arrows (I, β)∗P are strongly cartesian.
This means that in each diagram, the dashed arrows are unique:
D
j
I
α -
-
I
U
6
p∗p∗s∗I
6
j
-
-
E
s
6
V
?
p∗s∗I
?
j
-
-
B
p
?
C
?
J
?
j
=====
-
J
t
?
[Rough draft, version 2007-05-24 21:36]

9.3 Variable types (in cartesian case)
175
To see this, observe ﬁrst that the universal property of the pullback
gives a unique map U →s∗I. Since U = p∗V, this map corresponds
under adjointness p∗⊣p∗to a map V →p∗s∗I, and the pullback of this
map gives us U →p∗p∗s∗I (which continues to s∗I by the counit of the
adjointness, and hence makes it ﬁt into the diagram as required).
D 
U
- V
- C
I
?

p∗p∗s∗I
?
- p∗s∗I
?
- J
?
I
wwwwww

s∗I
ε
?
I
α
?

s
E
?
p
- B
?
t
- J
wwwwwwwwwwwwwwww
This constructs the map. Uniqueness follows because different choices
of U →p∗s∗I correspond to different choices of V →s∗I, but only one is
the pullback ﬁller that started the construction.
More precisely we have this:
9.3.6 Lemma. Given a diagram
U
- V
X
w
?
E
?
p
- B,
?
then the map ϕ : V →p∗X that corresponds to w under the adjointness p∗⊣p∗
is unique to make this diagram commute:
[Rough draft, version 2007-05-24 21:36]

176
Categories of polynomial functors
U
- V
w
z
p∗p∗X
p∗ϕ
?
- p∗X
ϕ
?
X
ε
?
E
?
p
- B,
?
Proof. Suppose a different map ϕ′ could ﬁll the place of ϕ. Then since
the top cartesian square is cartesian over E →B in the sense that both
sides have cartesian squares with E →B, we would have to replace the
pullback arrow p∗ϕ by p∗ϕ′. But by adjointness bijection, if ϕ′ ̸= ϕ then
also ε ◦p∗ϕ′ ̸= ε ◦p∗ϕ = w, so the diagram would not commute in case
we change ϕ.
2
Now it is a general fact that composites of strongly cartesian maps are
again strongly cartesian. Hence, since obviously every map in Set × Set
factors as (1, β) followed by (α, 1) (or vice versa), we see that every map
has a cartesian lift to any target.
Hence we have shown that Poly →Set × Set is a Grothendieck ﬁbra-
tion. Let us be explicit about the general form of a cartesian arrow and the
[Rough draft, version 2007-05-24 21:36]

9.3 Variable types (in cartesian case)
177
general cartesian lift: given a diagram
I
α - I
E
s
6
B
p
?
J
β
- J
t
?
the cartesian lift of (α, β) to P is given by either of the two diagrams:
I 
p∗p∗s∗I ×J J
- p∗s∗I ×J J
- J
I
wwwwww
- p∗p∗s∗I
?
- p∗s∗I
?
- J
β
?
I
α
?

s
E
?
p
- B
?
t
- J
wwwwww
I 
p∗p∗s∗I
- p∗s∗I
- J
I
α
?
s
- E ×J J
?
p
- B ×J J
?
- J
wwwww
I
wwwwww

s
E
a
?
p
- B
b
?
t
- J
β
?
We shall also call it the pullback of P along (α, β).
[Rough draft, version 2007-05-24 21:36]

178
Categories of polynomial functors
There is of course a canonical identiﬁcation of the top rows: This fol-
lows from the general factorisation result. But let us provide the compari-
son explicitly: we need a map (canonical and unique, but since this follows
from the general result, we just care to exhibit the map):
p∗s∗I ∼
→(p∗s∗I) ×J J.
Since we already have a map p∗s∗I →J we just need to exhibit a map
to p∗s∗I (and the two maps should agree down in J). The source of our
map is really b!p∗s∗I. Note that s = s ◦a. Now:
b!p∗s∗I = b!p∗a∗s∗I →p∗a!a∗s∗I →p∗s∗I
The ﬁrst arrow is the following lemma, the second arrow is the counit for
a! ⊣a∗.
9.3.7 Lemma. Given a diagram
X
A
?
ϕ
- B
A
α
?
ϕ
- B
β
?
there is a canonical map
β!ϕ∗X
- ϕ∗α!X.
Proof. Apply α! to the counit ϕ∗ϕ∗X →X to get α!ϕ∗ϕ∗X →α!X. Now
use Beck-Chevalley 8.2.9 to get instead ϕ∗β!ϕ∗X →α!X, which gives the
desired map by adjointness.
2
IS THIS NATURAL TRANSFORMATION CARTESIAN??? PROBABLY
WE DON’T CARE
9.3.8 Example. If we restrict to the category of linear polynomial functors
– these are just spans, then the factorisation reduces to the well-known fact
[Rough draft, version 2007-05-24 21:36]

9.3 Variable types (in cartesian case)
179
that a map of spans
D 
M
- C
I
?

B
?
- J
?
factors uniquely through D ←D ×I B ×J C.
IN FACT THERE IS PROBABLY A LARGE CLASS OF WEAK DOU-
BLE CATEGORIES WITH THIS FEATURES: BEING FIBRED OVER SOME
CATEGORY RELATED TO THE VERTICAL CATEGORY. AND THEN EV-
ERY SQUARE FACTORS (VERTICALLY) AS ’ESSENTIAL’ FOLLOWED
BE CARTESIAN. This should be true for module categories: to give a (f, g)
equivariant module map M →N should be equivalent to giving a module
map M →f∗N∗g, with suitable better notation.
Preliminaries towards operads
We now start our descent towards operad theory, with some easy conse-
quences of the factorisation results.
Fix a polynomial endofunctor P : Set/i →Set/I given by I ←E →
B →I. We consider the category Poly/P of polynomial functors with a
cartesian map to P, like for example
D 
U
- V
- C
I
?

E
?
- B
?
- I.
?
The arrows in Poly/P are maps like
D′ 
U′
- V′
- C′
D
?

U
?
- V
?
- C
?
I
?

E
?
- B
?
- I.
?
[Rough draft, version 2007-05-24 21:36]

180
Categories of polynomial functors
(i.e. compatible with the structure map to P).
Deﬁne a P-graph to be a diagram in Set/I of the form
X/I
P(D/I)

C/I.
-
and let the arrows in the category of P-graphs be diagrams
P(D′) 
X′
- C′
P(D)
?

X
?
- C
?
9.3.9 Proposition. There is an equivalence of categories between these two.
Proof. Given a polynomial functor over P, like
D 
U
- V
- C
I
?

E
?
- B
?
- I.
?
(note that neither U →V nor E →B is an I-map). We associate a P-graph
V
P(D)

C.
-
where the left-hand arrow is the factorisation of the structure map V →B.
(This is an I-map because it is a B-map.)
Conversely, given such a P-graph, we can deﬁne a polynomial functor
over P, by ﬁrst taking the source lift of P to D, and using the map V →
P(D) we are given. Now pull back to deﬁne U:
U
- V
E
?
- B
?
[Rough draft, version 2007-05-24 21:36]

9.3 Variable types (in cartesian case)
181
and note that U sits over I via p∗P(D) of the lift.
Here is a more complete picture:
U
- V
- C
D 
p∗P(D)
?
- P(D)
?
I
?

E
?
- B
?
- I.
?
Note again that none of the middle horizontal maps are I-maps.
It is an easy exercise to see that these constructions are functorial and
that they provide the claimed equivalence of categories.
2
9.3.10 Example. If D = C we call P-graphs for C-coloured P-collections.
If furthermore C = I we simply call them P-collections. In this case the
category of P-collections is equivalent to Set/B. CHECK THIS.
9.3.11 Example. If we restrict to linear functors over the identity functor
Id : Set →Set (given by 1 ←1 →1) the above comparison reduces to a
triviality: since Id is a terminal object in the category of linear polynomial
functors, on the polynomial functor side we then have spans D ←B →C,
and that is also all the Id-graphs amount to.
Sums and products in the variable-type categories
9.3.12 Sums. Let’s try:
I1 ←E1 →B1 →J1
+
I2 ←E2 →B2 →J2
:=
I1 + I2 ←E1 + E2 →B1 + B2 →J1 + J2
[Rough draft, version 2007-05-24 21:36]

182
Categories of polynomial functors
It is easy to see that the sum injections are cartesian. This follows from
the observation that this square is cartesian
E1
- B1
E1 + E2
?
- B1 + B2
?
Universal property: given Q : D ←U →V →C with cartesian maps
from P1 and P2, then there is induced a unique map P1 + P2 ⇒Q.
9.3.13 Products.
9.4
Double categories of polynomial functors
So far we have studied polynomial functors with variable types, but we
have not composed them.
Deﬁne composition via the roof construction. This is just functoriality
of the basic constructions.
Prove the interchange law.
The double categories of polynomial functors generalise module-like
double categories, like the double category of spans.
Reminder on double categories
WRITE THIS SECTION
The double category of polynomial functors and cartesian
2-cells
double
The vertical arrows are just set maps (or more precisely, pullback maps or
lowershriek maps between the corresponding slice categories. The hori-
zontal arrows are polynomial functors. The 2-cells are diagrams
I′ 
E′
- B′
- J′
I
?

E
?
- B
?
- J
?
[Rough draft, version 2007-05-24 21:36]

9.4 Double categories of polynomial functors
183
It is clear how to compose vertically: this is just to compose arrows
and compose such 2-cells vertically, and since the stacking of two pullback
squares is again a pullback square, this gives again a 2-cell.
For horizontal composition, we have already shown how to compose
polynomial functors to get new polynomial functors, and we also know
how to compose cartesian natural transformations horizontally to get a
new cartesian natural transformation.
Now we need to compose more general things, and these are not natu-
ral transformations in any category – at least not apparently.
I′ 
E′
- B′
- J′ 
F′
- C′
- K′
I
?

E
?
- B
?
- J
?

F
?
- C
?
- K
?
What we need to do is to take two parallel big composition diagrams
like (8.4), place them side by side, and ﬁll in maps between their bases,
making a commutative base with cartesian squares in the middles. Now
we must show that the sides of this construction yields new connecting
arrows, and that the roof of the total construction is a pair of cartesian
squares.
It is quite easy to check that the left-hand part of the diagram gives a
cartesian square on the top: it has a cartesian square as basis, and the sides
are all pullbacks. Hence the top is a pullback. For the right-hand part of
the diagram a few less obvious arguments are needed.
Step 1: in the middle of the basis we have
W′
W

B′

F′
-
B


F

-
J′

-
J


-
Front and back squares are pullbacks, so the dashed arrows exists by the
universal property of the front pullback.
[Rough draft, version 2007-05-24 21:36]

184
Categories of polynomial functors
Step 2: take push-forth of W and W′ along q and q′, respectively. We
want to see that there is a natural map from q′∗W to q∗W. This map will
be the crucial top-right edge of the ﬁnal roof.
Let c′ be an element in C′ and let c be its image in C under the map we
were given C′ →C. Now we know that the ﬁbre over c′ of q′∗W′ is the set
of diagrams
W′
F′
c′
s
-
⊂F′
?
Given one such diagram (i.e. an element in the set (q′∗W′)c′) we want to
construct a diagram
W
Fc
-
⊂F
?
i.e. an element in (q∗W)c (There are of course some compatibility condi-
tions to check.) But since the square
F′
- C′
F
?
- C
?
is a pullback we have a bijection F′
c′ ∼
→Fc, so the dashed arrow we want is
the one arising naturally in this diagram:
W′
F′
c′ ⊂
-
-
F′
-
W
?
Fc
wwwwwwwwwww
⊂
-
-
F
?
-
[Rough draft, version 2007-05-24 21:36]

9.4 Double categories of polynomial functors
185
Step 3: now pull back those push-forths. We get the top edges of the
total roof. Since the walls are pullbacks, and the bottom is, then so is the
top. . .
9.4.1 Poly. Let Poly denote the category of polynomial functors (of arbi-
cat:Poly
trary index sets) and the vertical arrows between them.
Composition and the factorisations
We already know that the (horizontal) composite of two cartesian natu-
ral transformations is again such a thing. Hence the class of PRIMITIVE
cells is stable under horizontal composition (this is just the 2-category of
cartesian natural transformations).
We shall see that it is not true that the class of cartesian (base changes)
is stable. We shall exhibit very explicitly what goes wrong and what works
well.
Given a horizontal composite of base-change squares
· 
·
- ·
- · 
·
- ·
- ·
P
Q
·
?
·
- ·
- ·
?
·
- ·
- ·
?
we factor P vertically as source-lift followed by a target-lift, and we factor
Q the other way around:
· 
·
- ·
- · 
·
- ·
- ·
|
|
|
|
·
wwwww

·
- ·
- ·
?
·
- ·
- ·
wwwww
|
|
|
|
·
?
·
- ·
- ·
wwwww

·
- ·
- ·
?
Now we invoke the interchange law: we can compose the diagram by
composing each row of 2-cells horizontally.
The top row of 2-cells is clearly vertical for the Grothendieck ﬁbration
(and it is clear that in general it is not the vertical identity 2-cell). Hence
we see already that the horizontal composite of two base-change squares
is not a base-change square.
Let us show that the horizontal composite of the bottom row of 2-cells
is again a base-change 2-cell:
[Rough draft, version 2007-05-24 21:36]

186
Categories of polynomial functors
9.4.2 Lemma. A target-lift 2-cell horizontally followed by a source-lift 2-cell is
again a base-change cell.
Proof. We take advantage of the interchange law once again (and the fact
that the gluing locus is a vertical identity 1-cell) to insert two vertical iden-
tity 2-cells break the proof into two pieces, each of independent interest.
Namely write the composite
· 
·
- ·
- · 
·
- ·
- ·
|
|
|
|
·
?
·
- ·
- ·
wwwww

·
- ·
- ·
?
as
· 
·
- ·
- · 
·
- ·
- ·
|
|
·
?
·
- ·
- ·
wwwww

·
wwwww
- ·
wwwww
- ·
wwwww
|
|
·
wwwww

·
wwwww
- ·
wwwww
- ·
wwwww

·
- ·
- ·
?
Now the top row horizontal composite is a source-lift and the bottom row
horizontal composite is a target lift, according to the following two lem-
mas.
2
9.4.3 Lemma. A source-lift 2-cell post-whiskered by a 1-cell is again a source-lift
2-cell.
Proof.
2
9.4.4 Lemma. A target-lift 2-cell pre-whiskered by a 1-cell is again a target-lift
2-cell.
Proof.
2
Epi-mono factorisation in Poly
fact-Poly
9.4.5 Lemma. Every arrow in Poly factors uniquely as one where all the compo-
nents are epi followed by one where all the components are mono.
[Rough draft, version 2007-05-24 21:36]

9.4 Double categories of polynomial functors
187
(I don’t know if these are the categorical notions of epi and mono.)
Proof. This is straightforward: given
I′
- E′
- B′
- I′
I′′
?
- E′′
?
- B′′
?
- I′′
?
factor each of the vertical maps into epi-mono:
I′
- E′
- B′
- I′
I
?
?
- E
?
?
- B
?
?
- I
?
?
I′′
?
?
- E′′
?
?
- B′′
?
?
- I′′.
?
?
Here you check easily that the middle squares are again cartesian: in-
deed if you take the pullback in the bottom
P
- B
E′′
?
?
- B′′
?
?
you get a mono (since a pullback of a mono is always a mono). Next by the
universal property of this pullback, there is a map from E′ to P, and hence
the top square is a pullback too. Now in the category of sets it is also
true that the pullback of an epi is an epi, so by uniqueness of epi-mono
factorisation in Set, P = E.
2
[Rough draft, version 2007-05-24 21:36]

188
Categories of polynomial functors
9.5
The non-cartesian case
It is tempting to stipulate that the general double category of polynomial
functors has as maps diagrams
U
- V
I

J
-
E
6
-

B
wwwwww
-
I
?
J
?
E
?
-

B
?
-
In other words, there is still a functor from this big category of polyno-
mial functors and all maps down to Set × Set, and the cartesian arrows
are still the same, the pullbacks we have described. And to give a map into
P is to give a natural transformation into (α, β)∗P. In other words, every
map factors into three parts: ﬁrst a representable natural transformation,
then a cartesian natural transformation (so far everything is ‘vertical’ over
Set × Set), and ﬁnally a base-change arrow (i.e. a cartesian arrow for the
ﬁbration over Set × Set).
Then the vertical-for-the-ﬁbration arrows, i.e. the natural transforma-
tions are stable under composition (that’s horizontal composition of nat-
ural transformations). The cartesian fragment (cartesian natural transfor-
mations and base-change squares) is also closed under horizontal compo-
sition, as shown in the previous sections. It follows from these two state-
ments that the intersection of these two classes of maps, namely the carte-
sian natural transformations, are closed under horizontal composition, as
we already showed directly.
Note however, that neither the class of representable natural transfor-
mations, nor the class of base-change squares is closed under horizontal
composition.
There are things to be checked here. . . Well, just check the statements.
Since currently we do not have much use of this general category, it is
difﬁcult to check that the notion is a good one. . .
I DON’T KNOW HOW TO PROVE THE INTERCHANGE LAW FOR
THIS ONE. . .
[Rough draft, version 2007-05-24 21:36]

Chapter 10
Polynomial functors on
collections and operads
We saw in Part I how one-variable polynomial functors are closely related
to collections and classical operads. In a minute we shall study the relation
between general polynomial functors and generalised operads.
Right here we just apply some polynomial constructions to collections
and operads. In other words, we study polynomial functors Set/N. . .
LOTS OF THINGS TO THROW AWAY. . .
10.1
The free-operad functor
10.1.1 The free-operad functor. The free-operad functor (5.4.1),
Set/N
−→
Set/N
A
7−→
T(A)
was deﬁned in 5.4.1 as generated by the free-forgetful adjunction between
collections and operads. It sends a collection A to the operad freely gener-
ated by it. It is the set of planar trees with nodes decorated in A subject to
a compatibility condition: nodes with n input edges must have decoration
in An.
[Rough draft, version 2007-05-24 21:36]

190
Polynomial functors on collections and operads
Now it is easy to see that it is just the polynomial functor given by
*
























(10.1)
(In this diagram as well as in the following diagrams of the same type, a
symbol

	
is meant to designate the set of all bouquets like this (with
the appropriate decoration), but at the same time the speciﬁc ﬁgures rep-
resenting each set are chosen in such a way that they match under the
structure maps.)
Now that we know it is a polynomial functor T : Set/N →Set/N, we
can look at the category of T-algebras (in the Lambek sense). It consists of
collections X/N equipped with a map of collections T(X) →X.
Let C : Set/N →Talg denote the free T-collection functor. We are
interested in the value of C at the terminal collection N →N which we
denote by 1: it is the least ﬁxpoint for the functor
X 7→N + T(X)
This is the set of all planar constellations cf. 5.4.2
Since T is a monad, there is a map of collections C(1) →T(1).
[Rough draft, version 2007-05-24 21:36]

10.2 Linear differential operators are linear
191
10.2
Linear differential operators are linear
in the sense of polynomial functors
A LOT OF JUNK TO THROW AWAY IN THIS PART
Given a ﬁnite map p : E →B, there is an associated collection B →N
(the classifying map). We have studied the differentiation of p. It is the
ﬁnite map
p′ : E ×B E ∖∆→E
In terms of the polynomial functor it is
X 7→∑
e∈E
XEp(e)−e.
This is a ﬁnite map over E. To ﬁnd the corresponding collection, we need
to describe the degree map (the classifying map) E →N. The ﬁbre over
e ∈E has degree one less than the ﬁbre Ep(e). Hence e has degree n if and
only if p(e) has degree n + 1. So the corresponding collection is just
∑
n≥0
(n + 1)Bn+1 →N
(Of course this is also what we expect to ﬁnd in view of our experience
with good old-fashioned polynomials.)
Now differentiation deﬁnes a functor from FinMap to itself. At least
this is true if we restrict to cartesian squares as arrows in the category. We
should check functoriality more carefully. We claim that there is corre-
spondingly a true morphism of collections:
Set/N →Set/N
(this is a functor).
10.2.1 Proposition. The functor
Set/N
−→
Set/N
∑
n≥0
An
7−→∑
n≥0
(n + 1)An+1
induced by differentiation of ﬁnite maps (polynomial functors) is itself polynomial—
in fact it is linear.
[Rough draft, version 2007-05-24 21:36]

192
Polynomial functors on collections and operads
Note that the ﬁbre over n = 0 is thrown away.
It is the map
N + N′ id- N + N′
N
+1

N
-
Here the right-hand map is the one corresponding to the polynomial
X × M′(X). The left-hand map N + N′ →N is the one sending an element
to one more than expected. Perhaps it is best to realise it in two steps:
N + N′ →N +1
→N
Proof. Start with the collection ∑n≥0 An →N. Pulling back along N +1
→N
gives the collection ∑n≥0 An+1 →N. Now pull back to the set N + N′.
The ﬁbre over an n in the ﬁrst summand is An+1. The ﬁbre over a point
(a < b) in N′, is Ab+1 (and there are b ﬁbres of this type). Finally, take
lowershriek (sum along the canonical map N + N′ →N. For each n in the
target N there are n + 1 elements in the ﬁbre, and all these element has the
same sort of ﬁbre, namely An+1. So altogether, the resulting collection is
∑n≥0(n + 1)An+1.
2
Note that there is another representation of the functor as a ﬁnite map:
N′
id - N′
N

N
−1
-
The minus-one map makes sense in this situation because the map N′ →N
factors through N ∖{0}, from which is minus-one map is well-deﬁned. So
the precise deﬁnition of the map is
N′ →N ∖{0}
−1
−→N
10.2.2 Remark. The second representation is better, I think. Start with the
collection ∑n≥0 An →N. Pull it back to N′: the ﬁbre over a point (i < n)
is just An. Finally sum, by going down to N ∖{0}: the ﬁbre over n ≥1
is now nAn. Finally, go down along the minus-one shifting map: the ﬁbre
over n will be (n + 1)An+1. That’s all.
[Rough draft, version 2007-05-24 21:36]

10.2 Linear differential operators are linear
193
Note that if we compose with the plus-one map, then we undo the last
shift: we get in the end nAn. This is the operator xD. Se below.
10.2.3 Remark. Some related possibilities and their result:
Omitting the plus-one map on the left, we get the operator sending
∑n≥0 An to ∑n≥0(n + 1)An. Indeed, the ﬁbres never change in this con-
struction, only the coefﬁcients.
Using the plus-one map on the left, but using the standard N′ in the
middle (instead of N + N′) the result will be the operator sending ∑n≥0 An
to ∑n≥0 nAn+1. Indeed, in this case the number of ﬁbres of degree n is still
just n. . .
10.2.4 Remark. Note that the pushforth along some map in the middle
will perform multiplication of some sort (i.e. give something like ∏Ve.
So such polynomial functors are of no use to realise derivative-like opera-
tions.
For example, pushforth along N +1
→N with create a constant terms 1 for
the empty ﬁbre! Indeed, there will be an empty product, and hence a term
1. This is true in general: each empty ﬁbre will produce a constant term 1.
10.2.5 Remark. Note that the single operation: pullback along N +1
→N
gives the operator
∑
n≥0
An 7→∑
n≥0
An+1
This would be some sort of divided-power derivation. I don’t know any-
thing about such operators if they have any use.
10.2.6 Example. The poly-map diagram whose last part is lowershrieking
along N +1
→N gives rise to the functor
Set/N
−→
Set/N
∑
n≥0
An
7−→∑
n≥1
An−1
This is the operator multiplication with X.
Now it follows that the operator xD is also polynomial: ﬁrst the deriva-
tive polynomial, then lowershriek along the plus-one map. Note that there
[Rough draft, version 2007-05-24 21:36]

194
Polynomial functors on collections and operads
is now a plus-one map in each end. In fact the plus-one maps out of N + N′
amount just to undo the effect of having an extra summand. In fact, the
operator xD can be described directly, and much more easily by
N′
id - N′
N

N
-
[Rough draft, version 2007-05-24 21:36]

Chapter 11
Polynomial monads
Fix a set I, and consider polynomial monads on Set/I. These are just
monoids in the monoidal category Poly(I).
11.1
The free polynomial monad on a polyno-
mial endofunctor
CONDENSE THIS! SINCE MOST OF THE ARGUMENTS WERE ALREADY
GIVEN IN THE ONE-VARIABLE CASE
11.1.1 Polynomial monads. A polynomial monad is a polynomial endofunc-
tor P : Set/I →Set/I equipped with a composition law µ : P ◦P →P
with unit η : Id →P, satisfying the usual associativity and unit condi-
tions. The structure maps µ and η should be natural transformations, and
in fact we will only(?) be interested in the case where they are cartesian
natural transformations. (These should really be called cartesian polyno-
mial monads, but since we won’t use any other type of polynomial monad
we skip the word ’cartesian’.
The composition law is described graphically as an operation of con-
tracting trees (formal compositions of bouquets) to bouquets. If P is given
by I ←E →B →I, we shall refer to I as the set of types of P, and B as
the set of operations. Since we have a unit, we can furthermore think of
E as the set of partial operations, i.e. operations all of whose inputs except
one are fed with a unit. The composition law can be described in terms of
[Rough draft, version 2007-05-24 21:36]

196
Polynomial monads
partial operations as a map
B ×I E →B,
consisting in substituting one operation into one input of another opera-
tion, provided the types match: t(b) = s(e).
Let P : Set/I →Set/I denote a polynomial functor represented by
I ←E →B →I.
11.1.2 P-algebras. A P-algebra is a set X/I equipped with a morphism
P(X/I) →X/I. Etc.
11.1.3 The free monad on a polynomial endofunctor. Given a polynomial
endofunctor P : Set/I →Set/I, a P-set is a pair (X, a) where X is an object
of Set/I and a : P(X) →X is an arrow in Set/I (not subject to any further
conditions). A P-map from (X, a) to (Y, b) is an arrow f : X →Y giving a
commutative diagram
P(X)
P( f )- P(Y)
X
a
?
f
- Y.
b
?
Let P-Set/I denote the category of P-sets and P-maps. The forgetful func-
tor U : P-Set/I →Set/I has a left adjoint F, the free P-set functor. The
monad T := U ◦F : Set/I →Set/I is the free monad on P. This is a poly-
nomial monad, and its set of operations is the set of P-trees, as we now
explain.
11.1.4 P-trees. Let P denote a polynomial endofunctor given by I ←E →
P-trees
B →I. We deﬁne a P-tree to be a tree whose edges are decorated in I,
whose nodes are decorated in B, and with the additional structure of a
bijection for each node n (with decoration b) between the set of input edges
of n and the ﬁbre Eb, subject to the compatibility condition that such an
edge e ∈Eb has decoration s(e), and the output edge of n has decoration
t(b). Note that the I-decoration of the edges is completely speciﬁed by the
node decoration together with the compatibility requirement, except for
the case of a nodeless tree.
[Rough draft, version 2007-05-24 21:36]

11.1 The free polynomial monad on a polynomial endofunctor
197
Another description is useful (cf. 11.1.4 below): a P-tree is a tree with
edge set A, node set N, and node-with-marked-input-edge set N′, together
with a diagram
A 
N′
- N
- A
I
α
?

E
?
- B
β
?
- I
α
?
Then the vertical maps α and β express the decorations, and the commu-
tativity and the cartesian condition on the middle square express the bijec-
tions and the compatibility condition. The top row is a polynomial functor
associated to a tree, so a P-tree can be seen as a cartesian morphism from
a tree to P in the category Poly of polynomial endofunctors 9.4.1.
The P-trees are obtained by freely grafting elements of B onto the leaves
of elements of B, provided the decorations match (and formally adding a
dotless tree for each i ∈I). More formally, the set of P-trees, which we
denote by B∗, is a least ﬁxpoint for the polynomial endofunctor
Set/I
−→
Set/I
X
7−→
I + P(X);
it is given explicitly as the colimit
B∗=
[
n∈N
(I + P)n(∅).
11.1.5 Explicit description of the free monad on P. A slightly more gen-
eral ﬁxpoint construction characterises the free P-set monad T: if A is an
object of Set/I, then T(A) is a least ﬁxpoint for the endofunctor X 7→
A + P(X). In explicit terms,
T(A) =
[
n∈N
(A + P)n(∅).
It is the set of P-trees with input edges decorated in A. But this is exactly
the characterisation of a polynomial functor with operation set B∗: let E∗
denote the set of P-trees with a marked input leaf, then T : Set/I →Set/I
is the polynomial functor given by
E∗
- B∗
I

I .
-
[Rough draft, version 2007-05-24 21:36]

198
Polynomial monads
The maps are the obvious ones: return the marked leaf, forget the mark,
and return the root edge, respectively. The monad structure of T is de-
scribed explicitly in terms of grafting of trees. In a partial-composition
description, the composition law is
B∗×I E∗→B∗
consisting in grafting a tree onto the speciﬁed input leaf of another tree.
The unit is given by I →B∗associating to i ∈I the dotless tree with edge
decorated by i. (One can readily check that this monad is cartesian.)
The above should amount to the following theorem:
11.1.6 Theorem. The forgetful functor PolyMon(I) →Poly(I) has a left ad-
joint, the free monad functor.
This involves checking this:
11.1.7 Proposition. The free monad on a polynomial functor is cartesian.
Proof. Check if this is not completely general. . . Otherwise, the proof of the
one-variable case carries over almost verbatim.
2
I wanted to understand the cartesian condition also in the partial sub-
stitution viewpoint. . .
11.1.8 Alternative ﬁxpoint construction. There is an alternative descrip-
tion of the free monad, which we brieﬂy mention: I HAVE NOT YET
FIGURED OUT THE RELATIONSHIP BETWEEN THE TWO FIXPOINT
CONSTRUCTIONS. The free monad is a least ﬁxpoint for the functor
Γ := ΓP : Poly(I)
−→
Poly(I)
Q
7−→
Id + P ◦Q.
Let ∅denote the constant polynomial functor on the empty set (it is given
by ∅→∅). One can check that Γ preserves monos, hence there is a se-
quence of monos
∅֒→Γ(∅) ֒→Γ2(∅) ֒→. . .
If P is ﬁnitary (i.e., p : E →B is a ﬁnite map — this will always be the case
below) then it preserves such sequential colimits, and the least ﬁxpoint can
be constructed as
P∗=
[
n≥0
Γn(∅).
[Rough draft, version 2007-05-24 21:36]

11.2 Monads in the double category setting
199
The equation satisﬁed by P∗,
P∗= Id + P ◦P∗,
expresses the recursive characterisation of P-trees: a P-tree is either a dot-
less tree (decorated by an element in I) or a ﬁnite set of P-trees.
Compare this construction with the one in Section 4.3: there we con-
structed an initial algebra for a polynomial endofunctor, i.e. a least ﬁxpoint
for this endofunctor. The result was basically just a set, and typically a set
of dead trees of some sort.
Now we are constructing a new endofunctor, as a ﬁxpoint in Poly. This
endofunctor then has a set of operations, and the elements in this set are
trees, but trees with non-zero arities, live trees!
11.2
Monads in the double category setting
We know what polynomial monads are: they are polynomial endofunctors
M : I ←E →B →I equipped with cartesian natural transformations
IdI ⇒M ⇐M ◦M. So for each I we have a category of polynomial
monads PolyMon(I). The arrows in this category are monad map: these
are cartesian natural transformations M0 ⇒M1. This means that this
diagram commutes:
I
⇒
M0
⇐M0 ◦M0
⇓
⇓
I
wwwwww
⇒
M1
⇐M1 ◦M1
This can also be expressed in a partial-composition-law fashion:
B0 ×I E0
- B0 
I
B1 ×I E1
?
- B1
?

I
wwwwww
We established a free-forgetful adjunction Poly(I)
-

PolyMon(I).
[Rough draft, version 2007-05-24 21:36]

200
Polynomial monads
Now we generalise this to the setting of variable types. Let PolyEnd
denote the category whose objects are polynomial functors I ←E →B →
I and whose morphisms are diagrams
I0 
E0
- B0
- I0
I1
α
?

E1
?
- B1
?
- I1
α
?
Let PolyMon denote the category whose objects are polynomial mon-
ads and whose morphisms are monad maps: these are diagrams like the
previous one required to respect the monad structure. This is most eas-
ily expressed in the partial-composition viewpoint where it amounts to
requiring that these two squares commute:
B0 ×I0 E0
- B0 
I0
B1 ×I1 E1
?
- B1
?

I1
?
We are implicitly referring to the double category Poly. If we restrict
to a ﬁxed I, then we ﬁnd a monoidal category Poly(I), and the monads
are just monoids in here.
Note that monads are not just monoids in the category PolyEnd because the structure
maps in a monad are required to have trivial I-component, i.e. be vertical maps for the
Grothendieck ﬁbration PolyEndo →Set × Set. Perhaps there is ﬁbred monad notion
that we are implicitly using here.
The free monad adjunction with variable index set
Now check that given a morphism in Poly, i.e. a diagram
A 
S′
- S
- A
I
?

E
?
- B
?
- I
?
then the free monad (which we already know is functorial in the ﬁxed-
index-set case) is functorial so that we get a monad map in PolyMon.
Now show that this functor is left adjoint to the forgetful functor.
[Rough draft, version 2007-05-24 21:36]

11.2 Monads in the double category setting
201
11.2.1 Proposition. (Assuming we restrict to ﬁnitary polynomial functors) the
forgetful functor PolyMon →PolyEnd has a left adjoint P 7→P∗, the free-
monad functor. In other words, for each polynomial endofunctor P and each poly-
nomial monad M, there is a natural bijection
PolyEnd(P, M) = PolyMon(P∗, M).
That the bijection is natural in P means that given α : P′ →P then the
diagram
PolyEnd(P, M)
=
PolyMon(P∗, M)
PolyEnd(P′, M)
precomp. α
?
=
PolyMon(P′∗, M)
precomp. Fα
?
commutes.
That the bijection is natural in M means that given monad map β :
M′ →M then the diagram
PolyEnd(P, M)
=
PolyMon(P∗, M)
PolyEnd(P, M′)
postcomp. β
6
=
PolyMon(P∗, M′)
postcomp. Fβ
6
commutes.
NOTE: although Poly(I) whose objects are polynomial endofunctors
whose arrows are diagrams whose ends are endos of I, this category is
monoidal under horizontal composition, but the polynomial monads are
not general monoids in this monoidal category: because, the structure
maps of our monads are required to have identity components on I. This
means for example that the unit map for a monad M must be
I 
E
- 0
- I
I
wwwwww
======== I
?
======== I
?
======== I
wwwwww
and not allow arbitrary endo in the sides of the squares.
On the other hand, the maps BETWEEN monads allow the types to
vary.
[Rough draft, version 2007-05-24 21:36]

202
Polynomial monads
11.2.2 Monads in the category of arrows. There is also this viewpoint:
consider the category of arrows Set2. Its objects are set maps I0 →I1. Its
morphisms are squares. It is a locally cartesian closed category. Consider
polynomial functors in here. We can restrict to those for which p = (p0, p1)
is a cartesian square. Now in this category of polynomial functors we can
look at monads. A monad in here will be a set map I0 →I1
SEE SEPARATE NOTES FEB2007
relative
If now P is a monad, then there is natural monoidal structure on Poly/P:
the tensor product of Q with R is the composite Q ◦R with P structure
given by Q ◦R →P ◦P →P.
WE CHECKED SOMEWHERE THAT COMPOSITION IS COMPATI-
BLE WITH base change!!!
11.2.3 Example.
First of all, deﬁne the category of polynomial monads (with variable
index sets).
In Polynomial functors and opetopes [31] we indicate the existence of such
a category for monads, saying that the arrows are such diagrams that re-
spect composition:
Let PolyMon denote the category of all polynomial monads. The ar-
rows in this category are diagrams
E
- B
I

I
-
E′
?
- B′
α ?
I′
?

I′
?
-
(11.1)
alpha
that respect the monad structure.
This is most easily expressed in the
partial-composition viewpoint where it amounts to requiring that these
[Rough draft, version 2007-05-24 21:36]

11.2 Monads in the double category setting
203
two squares commute:
B ×I E
- B 
I
B′ ×I′ E′
?
- B′
?

I′
?
fact-PM
11.2.4 Lemma. Every arrow in PolyMon factors uniquely as one where all the
components are epi followed by one where all the components are mono.
(I don’t know if these are the categorical notions of epi and mono.)
To show the lemma, use the obvious factorisation, and show that there
is a natural monad structure on the middle object.
11.2.5 Remark. The free monad functor happens to preserve monos. Is
this really true? it is true at least when restricted to the subcategory of tree
plain endos. This is just to say that if φ is a map between tree plain endos
(hence mono), then the same map considered as a monad map on the tree
monads is mono again. . .
One way to look at the problem is that we need to deﬁne ’change of colours’ for polynomial endofunctors. See if we can mimic some
construction from the theory of coloured operads.
We know that monads over I are just monoids in Poly(I) and monads over J are monoids in Poly(J), so to compare, we just need a monoidal
functor in one of the directions. . .
On the other hand, there might be ways of comparing monoids in different categories without necessarily pulling one of them back to the
other category.
The problem is: given I ←E →B →I and a map I →J or J →I, how do we ever produce a polynomial functor between the Js???
[Rough draft, version 2007-05-24 21:36]

204
Polynomial monads
[Rough draft, version 2007-05-24 21:36]

Chapter 12
Coloured operads and generalised
operads
12.1
Burroni’s multilinear relations
ADJUST THIS TO WHAT WE ACUTALLY NEED
12.1.1 Burroni’s multilinear relations. Let C be a category with ﬁbre products, and let
C : C →C be a cartesian monad. Deﬁne a bicategory with the same objects. An arrow
from I to J is a diagram
A
C(I)

J
-
A 2-cell is a diagram
A
C(I)

J
-
B
?
-

The composition of two such diagrams, say the composition of this diagram with
another one
B
C(J)

K
-
[Rough draft, version 2007-05-24 21:36]

206
Coloured operads and generalised operads
is deﬁned by ﬁrst applying C to the ﬁrst arrow, and then taking a pullback and use the
monad structure:
C(A) ×C(J) B
C(A)

B
-
C(C(I))

C(J)

-
K
-
C(I)
?
12.1.2 Lemma. This composition is associative (up to those coherences) if the natural transfor-
mation m : CC →C is cartesian. Perhaps we also need to know that C preserves cartesian
squares. . .
12.1.3 Lemma. The unit arrow is the diagram
I
C(I)
u

I
-
Proof. It is immediate to check that this works as a unit from the left.
To see that it works as unit from the right, we need to assume that C is a cartesian
monad, precisely we need that the naturality square for the unit is cartesian. here is the
diagram for composing with idJ on the right:
A
C(A)

J
-
C(C(I))

C(J)

-
J
-
C(I)
?
The fact that the top square is cartesian is precisely because it is the unit naturality square.
To see that the long composite on the left is equal to the original map A →C(I) is a con-
sequence of the fact that the unit is really a unit for the composition functor M. Precisely
we have this commutative square
CA uA
A
CCI
C f ?

CI CI
f?
CI
mI ?
2
[Rough draft, version 2007-05-24 21:36]

12.1 Burroni’s multilinear relations
207
In other words, if C is a cartesian monad, then this rule gives a bicategory structure.
12.1.4 Example. Let C = Set, and take C = Id. Fix a set S. The the bicategory of
C-endospans is the category of endo-spans. The monoidal category on the object S is
the category of categories with object set S. XXXXXXXXX Categories can be described
as monoids in the category of endospans. Now we do the multi-input version, using
cartesian monads to provide the composition laws.
More precisely to give a category with object set S is the same as giving a monoid in
the monoidal category of endospans on S:
A
S

S
-
then A is the set of arrows, and the two maps are source and target respectively.
Deﬁnition. Given a cartesian monad F : Set →Set. For each set I there is a monoidal
category (the vertex bicategory) of F-spans from I to I. The monoidal operation is ◦. A
F-multicategory on I is by deﬁnition a monoid in this monoidal category. In other words,
it is an endo F-span
A
FI

I
-
An F-operad is an F-multicategory on the object 1 ∈Set.
12.1.5 Classical multicategoriesand classical operads. When F is the free-monoid monad,
then the corresponding notion of multicategory is the classical notion of Lambek.
An arrow a ∈A goes from a sequence of elements (x1, . . . , xn) ∈I∗to a single
element y ∈I. . .
When furthermore I is the singleton set, then we recover the classical notion of op-
erad (nonsymmetric).
12.1.6 Categories and monoids. Let E denote the identity endofunctor Set →Set. An
E-multicategory on a set S is nothing but a plain category with object set S. Indeed, then
an E-span is nothing but a plain span, and the statement reduces to the fact that a monoid
in the monoidal category of endospans is the same thing as a category. An E-operad is
nothing but a monoid.
In conclusion, every cartesian monad F gives rise to a notion of F-operad. If the
monad is the free-monoid monad, then we get the classical notion of operad. This is
because M(1) = N. Then
A
M(1) = N

1
-
[Rough draft, version 2007-05-24 21:36]

208
Coloured operads and generalised operads
is just the collection A →N deﬁning a classical operad.
The whole point was that given a cartesian monad M : E →E, on
a nice category with ﬁnite limits and terminal object 1, then there is a
monoidal category of M-collections: objects are spans in E:
X
M(1)

1
-
Since 1 is terminal, this is just E/M1.
12.1.7 Theorem. (Essentially Leinster [34], Cor. 6.2.4.) There is a natural equiv-
alence of monoidal categories between Poly/M and M −Coll.
Poly/M is the category of polynomial functors in E with a cartesian
map to M. Since M is a monad, this category acquires a tensor product,
see below.
This is the notion of un-coloured operad, even if there are some I in-
volved, e.g. E = Set/I.
C-coloured operads are monoid in the category of M-endospans based
on C instead of the terminal object. These are spans
X
M(C)

C
-
with monoid structure. This is Set/(MC × C) rather than just Set/MC.
12.2
Coloured operads
A coloured operad, also called a multicategory, consists of a pair (P, C) where
C is a set whose elements are called colours, and P is a collection of sets
indexed by (n + 1)-tuples of colours, n ∈N. So for each n and for each
(c1, . . . , cn; c) there is a set
P(c1, . . . , cn; c)
[Rough draft, version 2007-05-24 21:36]

12.2 Coloured operads
209
of operations of input colours (c1, . . . , cn) and output colour c.
These sets together have operad structure, so that you can substitute n
operations into a given n-ary operation provided the colours match. This
composition law is required to be associative and unital. Note that there
is a unit operation for each colour, 1c ∈P(c; c).
More stuff about this. Reference to Moerdijk-Weiss.
12.2.1 Change of colours. If (Q, D) is a coloured operad and α : C →D is
a map of sets, then we can construct a C-coloured operad α∗Q where
α∗Q(c1, . . . , cn; c) := Q(α(c1), . . . , α(cn); α(c)).
Algebras for a coloured operad.
12.2.2 Burroni version. A I-coloured operad is just a monoid in the monoidal
category whose objects are I-based M-endospans:
X
M(I)

I
-
The set X is the total set of operations. The map to M(I) sends each opera-
tion to its list of input colours, and the map to I returns the output colour.
12.2.3 Theorem. A coloured operad is essentially the same thing as a polynomial
monad over M:
I 
X′
- X
- I
1
?

N′
?
- N
?
- 1
?
Here X′ := N′ ×N X is the set of operations with one input marked, and the map
X′ →I returns the colour of that input slot.
We should observe at this point that change-of-colours for coloured
operads corresponds precisely to base change in the theory of polynomial
functors.
Polynomial monads and coloured operads
[Rough draft, version 2007-05-24 21:36]

210
Coloured operads and generalised operads
[Rough draft, version 2007-05-24 21:36]

Chapter 13
Trees
In this chapter we study the close relationship between polynomial endo-
functors and trees. We shall see how a tree gives rise to a polynomial
endofunctor, and in fact we characterise those polynomial endofunctors
that arise in this way. So in the end we can deﬁne trees as a special kind of
polynomial endofunctors.
There are three simple conditions to characterise the trees among the
polynomial endofunctors, which in fact form a very practical deﬁnition
of trees. Next we consider the full subcategory of trees in the category
of polynomial functors: it turns out the maps are precisely the subtree
inclusions.
A more useful category of trees is the Kleisli category of the previous
one w.r.t. the free-monad adjunction. The objects are the free monads on
the trees T from before, and these have a very explicit description in terms
of subtrees.
Now there are two interesting factorisation systems on this bigger cat-
egory of trees: Every morphism of trees (i.e. monad map between the
free monads on trees) factors as boundary-preserving followed by subtree-
inclusion. The latter are the free maps. The former are the generic maps in
the sense of Joyal [27] and Weber [45]. On the other hand we have an epi-
mono factorisation system. Every epi is boundary-preserving and every
free map is mono, so altogether every tree map factors into three parts:
1: epi = unary-dot-deletions
2: generic mono = node reﬁnements
3: free mono = subtree inclusion
[Rough draft, version 2007-05-24 21:36]

212
Trees
It is notoriously difﬁcult to formulate formal proofs for statements about
trees – all too easily the arguments will involve our intuitive understand-
ing of trees, e.g. their geometric realisation. THe deﬁnition of trees in terms
of polynomial functors is quite easy to use, and it is a novelty that these
results about factorisations come about very formally using the language
of polynomial functors. In fact you can prove them without ever having
seen a tree in nature – but of course it is easier to follow by drawing the
trees.
Having these three classes of maps is crucial in the Moerdijk- Weiss
theory of dendroidal sets [38], [39].
All the tree maps considered here are cartesian! There should be a more
general notion of tree maps, which are not bijections on each set of siblings.
Next we come to decorated trees. Trees can be decorated by a poly-
nomial functor P. Such P-trees are precisely the operations for the free
monad on P.
13.1
Trees
13.1.1 Trees. The notion of trees is the one we have already used infor-
mally at several occasions: Our trees are not planar, they have any number
of input edges (called leaves), and have precisely one output edge.
We draw trees with the output at the bottom:
Now we come to the formal deﬁnition of tree. In 14.4.5 we shall give
another description of trees, and see how they naturally form a groupoid.
13.1.2 Graphs. By a graph we understand a pair (T0, T1), where T0 is a set,
and T1 is a set of subsets of T0 of cardinality 2. The elements in T0 are
called vertices, and the elements in T1 edges. An edge {x, y} is said to be
incident to a vertex v if v ∈{x, y}. We say a vertex is of valence n if the set
of incident edges is of cardinality n.
[Rough draft, version 2007-05-24 21:36]

13.1 Trees
213
Say what a map of graphs is, and then what a subgraph is.
Say what a simple path is. Perhaps via maps from a linear graph.
A simple closed path in a graph is a subgraph C ⊂T with the property
that every vertex is incident to precisely two edges. A graph is said to be
simply connected if it does not contain a simple closed path.
The geometric realisation of a graph is the CW-complex with a 0-cell
for each vertex, and for each edge a 1-cell attached at the points corre-
sponding to its two incident vertices. A graph is connected (resp. simply
connected) if and only if its geometric realisation is connected (resp. sim-
ply connected).
13.1.3 Trees. By a ﬁnite rooted tree with boundary we mean a ﬁnite graph
tree-formal
T = (T0, T1), connected and simply connected, equipped with a pointed
subset ∂T of vertices of valence 1. We will not need other kinds of tree than
ﬁnite rooted trees with boundary, and we will simply call them trees.
The basepoint t0 ∈∂T is called the the output vertex, and the remaining
vertices in ∂T are called input vertices. Most of the time we shall not refer
to the boundary vertices at all, and graphically a boundary vertex is just
represented as a loose end of the incident edge. Edges incident to input
vertices are called input edges or leaves, while the unique edge incident to
the output vertex is called the output edge or the root edge.
The set of vertices c(T) : = T0 ∖∂T is called the core of the tree, and
its elements are called nodes or dots; we draw them as dots. A tree may
have zero dots, in which case it is just a single edge (together with two
boundary vertices, which we suppress). We call such a tree a unit tree. For
a tree with at least one dot, the dot incident to the output edge is called
the root dot. Not every vertex of valence 1 needs to be a boundary vertex:
those which are not are called nullary dots.
The standard graphical representation of trees is justiﬁed by geometric
realisation. Note that leaves and root are realised by half-open intervals,
and we keep track of which are which by always drawing the output at
the bottom. By labelling the cells we can recover the abstract tree when
needed, and we shall allow ourselves to mix the two viewpoints, although
we shall frequently omit the labels.
13.1.4 Tree order. If T = (T0, T1, ∂T, t0) is a tree, the set T0 has a natural
poset structure a ≤b, in which the input vertices are minimal elements
[Rough draft, version 2007-05-24 21:36]

214
Trees
and the output vertex is the maximal element. A poset deﬁned by a tree
we call a tree order. We say a is a child of b if a ≤b and {a, b} is an edge.
Since T is simply connected, each edge divides T into two connected
components. One component contains the root vertex. This deﬁnes an
orientation of the edge: we say the end of the edge is the vertex in the
component of the root, and the start of the edge is the other vertex of the
edge. At every vertex (not the root) there is precisely one edge starting.
Indeed, if there were two, each of them would be the ﬁrst step in a path
ending at the root vertex (possibly meeting before), and hence we would
have a simple closed path, contradicting the simple connectedness. Hence
every dot has an out-edge. The other edges incident to the dot are called
input edges. The orientation of the edges assemble together into a partial
order on the set of edges. (and also a partial order on the set of vertices).
Need to see that at every dot of a tree, there is precisely one edge going
out of it. Any number of edges going into it.
13.1.5 Subtrees. A subtree in T is a subgraph S with a tree structure (in the
subtree
sense of 13.1.3) such that each inner vertex of S is also an inner vertex of T,
and the set of input edges of an inner vertex (i.e. a node) in S coincides with
the set of input edges of that node in T. Finally we require compatibility
between the tree orders of S and T (this condition is automatically satisﬁed
whenever S contains an inner vertex). Geometrically, if T is embedded in
the plane, a subtree is a non-empty connected subgraph that can be cut
out by a circle (or simple closed curve) that does not meet the vertices.
The boundary of the subtree is then the intersection with the circle. Here
are two examples:
a
b
⊂
a
b
e
⊃
e
Note that each edge of T deﬁnes a dotless subtree.
13.1.6 Bouquets. A particularly primitive and useful sort of tree are those
with precisely one node: these are the bouquets that we have already used
extensively.
[Rough draft, version 2007-05-24 21:36]

13.2 From trees to polynomial endofunctors
215
Deﬁnition. A bouquet is a tree with precisely one node.
13.1.7 Pointed sets. A bouquet is essentially the same thing as a pointed
set: indeed from a bouquet we form a pointed set which is simply the set
of all devices, inputs and output, and pointed by the output. Conversely,
from a pointed set we form a bouquet by taking the base point as output
and the complement as input.
WARNING: WE WANTED ALL THIS TO WORK IN ANY TOPOS, SO
BE CAREFUL WITH TAKING COMPLEMENT. . .
AND BE EXPLICIT WHAT ‘FINITE’ MEANS. . .
13.2
From trees to polynomial endofunctors
We shall associate to each tree a polynomial endofunctor. We start with
bouquets.
13.2.1 Polynomial functors from bouquets. Given a bouquet
PICTURE
deﬁne a polynomial endofunctor by the diagram
L
p
- 1
A
s

A
t
-
where A is the set of edges in the bouquet, L is the set of input edges, and
1 is the unique node. (So you can also think of L as the set of nodes-with-
a-marked-input-edge.) The maps are the obvious ones: s is the inclusion
of the set of input edges into the set of all edges, and t returns the output
edge.
Clearly
L + 1 ∼
→A.
In fact it is easy to see that this condition characterises the polynomial
endofunctors arising from bouquets: those I ←E →B →I with B = 1
and I = E + 1.
BE EXPLICIT ABOUT THE RESULTING **FUNCTOR**
[Rough draft, version 2007-05-24 21:36]

216
Trees
Now we’ll mimic these simple constructions for general trees – as ex-
pected this is somewhat more complicated.
13.2.2 The ﬁrst construction. Given a tree T, deﬁne a polynomial functor
by the diagram where A is the set of edges in T, N is the set of nodes in
T, and N′ is the set of nodes with a marked input edge. The maps are the
obvious ones: s returns the marked edge of the node, p forgets the mark,
and t returns the output edge of the node.
13.2.3 Characterisation of polynomial endofunctors coming from trees.
Some properties of polynomial functors deﬁned by trees are clear: ﬁrst of
all, all the involved sets are ﬁnite, and second
E + 1 ≃I
since all the edges appear as input edge of some node, except the root edge
which we denote 1. We also observe that s and t are injective: this is just to
say that an edge is an input edge of at most one node and the output edge
of a most one node. What else is necessary to require in order to guarantee
that the polynomial endofunctor comes from a tree?
13.2.4 Theorem. A polynomial endofunctor I
s←E
p→B
t→I is (isomorphic
to) a tree if and only if the following four conditions hold:
(1) all the involved sets are ﬁnite.
(2) t is injective
(3) there is a bijection E + 1 ∼
→I, which restricts to s on E.
Deﬁne a walk-to-the-root function ρ : I →I by 1 7→1 and e 7→t(p(e)) for
e ∈E. For each i ∈I deﬁne the ’deep ﬁbre’
Fi := {x ∈I | ρn(x) = i for some n ∈N}
(4) F1 = I. In other words, the deep ﬁbre of 1 is all of I.
Observe that condition (4) implies that ρ has no ﬁxpoints except for 1,
and more generally there are no periods or ’cycles’.
CHECK THIS OUT: isn’t this walk-to-the-root function exactly the no-
tion of wellfoundedness!?!?
Proof. Let us construct a tree from P. We deﬁne a graph with boundary by
taking the set of nodes to be B and the edge set to be I. The edges i ∈I
[Rough draft, version 2007-05-24 21:36]

13.2 From trees to polynomial endofunctors
217
which are not in the image of ρ are the input edges of the graph in the
sense that they do not start in a vertex. For each other edge i, we let it start
in b if and only if t(b) = i. Precisely one such b exists: it exists because i is
in the image of ρ, and there can be at most one since t is injective. Clearly
every b occurs like this. Now we have decided where each edge starts. Let
us decide where they end: the edge 1 is deﬁned to be the output edge of
the graph, in the sense that it does not end in a vertex. For each other edge
e ̸= 1 (which we think of as e ∈E), we let it end in p(e). Note that the ﬁbre
of p over a vertex b consists precisely in the edges ending in b. Now we
have described how all the edges and vertices are connected, and hence
we have described a ﬁnite graph with boundary.
Let us check that this graph is a tree: we already observed that every
vertex b is the starting point for an edge, namely t(b), so it is enough to
consider the set of edges. Observe now that edge i follows edge e if and
only if e ̸= 1 and ρ(e) = i. Now condition (4) implies that the graph is
connected: every e ̸= 1 has a ‘successor’ distinct from itself, and in a ﬁnite
number of steps comes down to the output edge. There can be no loops
because there is precisely one edge coming out of each vertex, and linear
cycles are excluded by connectedness. So the graph is a tree. It is clear
from the construction that the polynonial functor associated to this tree is
canonically isomomorphic to the one we started with.
More formal proof: deﬁne a directed graph T = (T0, T1) by taking
T1 := I and T0 := I + 1 = B + L + 1 (where L denotes the complement of B
in I, and 1 denotes the root vertex). Deﬁne the startpoint of each edge by
setting
start : I →I + 1
and deﬁne the endpoint as
end : I = E + 1 →I + 1
deﬁned as ρ + 1. Here the 1 on the left denotes the root edge, while the 1
on the right denotes the root vertex.
Observe that start and end are always distinct: for e ∈E we certainly
have ρ(e) ̸= e, and for r the root edge in I, then start(r) = r and end(r) = 1
(the root vertex). We should also check that there are no multiple edges. . .
Connectedness: every edge e has a neighbour ρ(e) or otherwise e is the
root edge. The edge ρ(e) again has a lower neighbour, and so on until we
reach the root, so every edge is connected to the root.
[Rough draft, version 2007-05-24 21:36]

218
Trees
Simple connectedness: deﬁne the height h(x) of a dot x as the minimal
number h such that ρh(t(x)) = 1 (the root edge). Suppose there is a simple
closed path in T. Then there is a ﬁnite number of vertices involved, so
there is a x where h(x) is maximal. But this contradicts the assmption that
x has 2 incident edges: at most one of the edges is an output edge, so at
least one is an input edge, and this edge has another incident vertex in the
loop, hence contradicts the maximality of x.
2
13.2.5 Forests. We should certainly take the opportunity to deﬁne forests:
they are disjoint unions of trees, and we allow of course the empty forest
(whereas we do not allow any such thing as the empty tree).
They are polynomial functors described mostly like trees, except that
the role of 1 is replaced by an arbitrary set R, the set of roots.
QUESTION TO INVESTIGATE: GRAPHS MORE GENERAL THAN
TREES
Example: consider the graph of a clock: it has 12 nodes and 12 edges,
and each node has an output edge and an input edge. This graph violates
the condition N′ = 1 + A.
Given any polynomial endofunctor, can’t we construct a graph!? Per-
haps we need s and t to be injective in order to have a well-deﬁned notion
of edge in this graph. . .
A category of trees
13.2.6 A category of trees. Now we know how to interpret a tree as a
polynomial functor. Now we can deﬁne a map of trees as a morphism
between the associated functors. In other words we take the morphisms
from the category Poly. This category is the vertical category of the double
category of polynomial functors described in 9.4.
Hence a map of trees is a diagram
A0 
N′
0
- N0
- A0
A1
α
?

N′
1
?
- N1
β
?
- A1
α
?
[Rough draft, version 2007-05-24 21:36]

13.2 From trees to polynomial endofunctors
219
mono-cat
13.2.7 Proposition. A cartesian map between polynomial functors associated to
trees is always a monomorphism. These correspond precisely to tree inclusions
(possibly with permutation of siblings).
Proof. By the next lemma, a map of polynomial functors associated to trees
respects the function ρ. In particular it preserves relative height. Now
suppose two edges a and b have the same image under the map of poly-
nomials φ. Then their immediate ancestor also have the same image, and
so on until their nearest common ancestor, which is at equal ρ-distance
from a and b since φ commutes with ρ. So we reduce to the case where
two sibling edges have the same image (namely the two children of the
nearest common ancestor). But this is impossible by the cartesian condi-
tion on φ. Hence we have shown that φ is injective on edges. Since the
map from nodes to their output edge is always injective, it follows that φ
is also injective on nodes. Hence it is injective on all three components.
Hence it is a monomorphism.
It is easy to see that these are precisely the subtree inclusions. Let us
do the details: since φ is compatible with s, p, and t it follows(?) that φ is
a graph map. Since S is a subset of T it is a subgraph. Since φ is cartesian,
the condition on full children is satisﬁed. Hence it is a subtree.
Conversely, given a subtree in the sense of 13.1.5, then it is a tree, and
we get the maps φ and they are inclusions. The commutativity of the
squares should be easy to check, and the middle one is cartesian because
of the full-child condition.
2
13.2.8 Lemma. A map φ : S →T between polynomial functors associated to
trees is compatible with ρ (except possibly at the root of S). In other words, if s is
a child edge of r then φ(s) is a child edge of φ(r).
Note that the root of S has ρ(r) = r. But there is no guarantee that φ(r)
is the root of T, hence φ is not completely compatible with φ.
Proof. The assumption is
t(p(s) = r
Now apply φ and use that it commutes with p and t.
2
A reformulation of the Proposition is:
13.2.9 Corollary. The category of trees and subtree inclusions is a full subcate-
gory in the category of polynomial functors and cartesian maps.
[Rough draft, version 2007-05-24 21:36]

220
Trees
13.2.10 Examples. For each edge e of T there is a subtree inclusion
1 
0
- 0
- 1
I
e
?

E
?
- B
β
?
- I
e
?
The subtree consists of only that edge.
For each dot b in T there is a subtree inclusion
Eb + 1 
Eb
- {b}
- Eb + 1
I
?

E
?
- B
β
?
- I
?
The subtree is the local bouquet at b: the dot itself with all its incident
edges.
Examples of trees
Given a tree A ←N′ →N →A, recall the explicit description of what a
polynomial functor does:
 Xi | i ∈A
 7−→
 Pj | j ∈A

,
where
Pj = ∑
n∈Nj ∏
e∈N′n
Xs(e)
Note that if r is the root edge, then the variable Xr does not occur in the
expression, since there is no node with input edge r. Also, if l is a leaf,
then Pl is the constant empty set, simply because the ﬁbre Nl is empty, and
Pl is indexed over Nl. Suppose a is an edge which is not a leaf, then Pa is
a sumindexed over all the dots whose output edge is a. There is precisely
one such, say d (since we assumed a is not a leaf), so Pa is a monomial. it
is the product, indexed over the ﬁbre N′
d, which is the set of marked input
edges of d, and for each such, the factor is the variable corresponding to
that edge. So in short, Pa is the monomial
Pa =
∏
e input of a
Xe
(13.1)
Pa
[Rough draft, version 2007-05-24 21:36]

13.2 From trees to polynomial endofunctors
221
the product runs over child edges, i.e. edges coming in to the dot where a
starts.
Note that each variable only occurs in at most one output monomial!
since of course and edge is only the child edge of at most one other edge.
As noticed already, the variable corresponding to the root edge does not
occur at all.
In conclusion, the polynomial functor is a vector of monomials (13.1).
13.2.11 Example. Consider the dotless tree. It corresponds to the polyno-
mial functor
∅
- ∅
1

1
-
which in turn is the constant polynomial functor ∅. (This is a one-variable
polynomial functor, since there is only one edge in the tree.)
13.2.12 Example. Consider now the tree
The polynomial functor is
∅
- 1
1

1
-
the constant polynomial 1. This is also a one-variable polynomial. Since
there are no edges sitting over the single edge a, it is the empty monomial
Xa 7→X∅
a = 1.
These two examples exhaust the one-variable trees. From the tree view-
point, this is because they are the only trees with only one edge. From the
viewpoint of the theorem characterising trees, it is because E is forced to
be ∅by condition (2), and B is forced to be 0 or 1 since t has to be injective.
13.2.13 Example. Consider the linear tree with n dots, and whose edges
are decorated 0, 1, . . . , n. Then the corresponding polynomial functor P is
the linear functor in n + 1 variables, Pi = Xi+1 for i ̸= n, and Pn = 0.
13.2.14 Example. Linear trees give linear polynomial functors, but of course
most linear functors do not come from a tree.
[Rough draft, version 2007-05-24 21:36]

222
Trees
13.2.15 Example. Consider now the little tree
a
b
c
We have the polynomial functor in three variables Xa, Xb, Xc with compo-
nents
Pa = XbXc,
Pb = 0,
Pc = 0.
smalltree
13.2.16 Example. It is an interesting exercise to take the polynomial func-
tor associated to a tree and compose it with itself. Roughly this gives a
polynomial functor whose set of operations is the full level-2 subtrees in
the tree – together with the nullary nodes. That is, the only operations
come from those nodes in the tree all of whose children are nodes again
(not leaves). And then the nullary operations.
By this description, the result is a rather primitive polynomial functor
for most small trees. . .
Example:
1
2
3
4
5
6
7
x
y
z
w
Then the operations of the composite polynomial functor is the set of
all ways of decorating the four bouquets
x
1
2 3 4
y
2
5
z
4
6 7
w
5
with other bouquets. Note that every input edge of a bouquet needs a dec-
oration. Hence it is impossible to decorate node x (the leaf 3 can’t have a
decoration), and also node z (since neither 6 nor 7 can be decorated). Node
w can be decorated (by the empty decoration) and y can be decorated in a
unique way, namely by w. (Slogan, take those operations all of whose inputs
can be ﬁlled with other operations.) So in conclusion, the composite polyno-
mial functor has two operations,
[Rough draft, version 2007-05-24 21:36]

13.2 From trees to polynomial endofunctors
223
y
2
5
w
w
5
both nullary.
Of course the set of types is the same as for the original functor: {1, 2, 3, 4, 5, 6, 7}.
We could compute the set Eof partial operations by hand, but the fact that
we keep careful track of arities and draw the operations as bouquets and
trees with clear arity indication means that we can reconstruct the set E
easily: since both operations are nullary, E is the empty set.
We cuold also compute the composite algebraically, thinking in terms
of polynomial functions: we have
P1(X)
=
X2X3X4
P2(X)
=
X5
P3(X)
=
0
P4(X)
=
X6X7
P5(X)
=
1
P6(X)
=
0
P7(X)
=
0
so if we substitute Pi for Xi we get
(P ◦P)1(X)
=
0
(P ◦P)2(X)
=
1
(P ◦P)3(X)
=
0
(P ◦P)4(X)
=
0
(P ◦P)5(X)
=
1
(P ◦P)6(X)
=
0
(P ◦P)7(X)
=
0
which agres with the description obtained in graphical terms: it is constant
since all operations are nullary, and the ones in the table correspond to the
nullary operations.
[Rough draft, version 2007-05-24 21:36]

224
Trees
13.3
P-trees
We shall also use decorated trees. Our trees are decorated by a polynomial
endofunctor:
13.3.1 P-trees. Let P denote a polynomial endofunctor given by I ←E →
treeToP
B →I. We deﬁne a P-tree to be a tree whose edges are decorated in I,
whose nodes are decorated in B, and with the additional structure of a
bijection for each node n (with decoration b) between the set of input edges
of n and the ﬁbre Eb, subject to the compatibility condition that such an
edge e ∈Eb has decoration s(e), and the output edge of n has decoration
t(b). Note that the I-decoration of the edges is completely speciﬁed by the
node decoration together with the compatibility requirement, except for
the case of a nodeless tree.
We have already described the polynomial endofunctor associated to
a tree. Given a tree with edge set A, node set N, and node-with-marked-
input-edge set N′, the associated polynomial endofunctor is A ←N′ →
N →A. Now it is clear that a P-tree is precisely a tree equipped with a
map to P in the category of polynomial endofunctors and their cartesian
maps (cf. 9.3), i.e. a diagram
A 
N′
- N
- A
I
α
?

E
?
- B
β
?
- I
α
?
Then the vertical maps α and β express the decorations, and the commu-
tativity and the cartesian condition on the middle square express the com-
patibility condition.
13.3.2 Remark. It is important to note that P-trees are something genuinely
different from just trees, in the sense that abstract trees are not P-trees for
any P. It is true that every ﬁnite tree admits an M-decoration: the possible
diagrams
A 
N′
- N
- A
I
?

N′
β
?
- N
β
?
- 1
?
[Rough draft, version 2007-05-24 21:36]

13.3 P-trees
225
have to send a node x to its arity n (the number of input edges), and then
there are n! different choices for mapping the ﬁbre to the n-element set n,
the ﬁbre over n. If we think of n as ordered then making a tree into an
M-tree is essentially to give it a planar order, and M-trees are essentially
the same thing as planar trees.
Deﬁne also bouquets decorated in a polynomial endofunctor.
13.3.3 Decorated bouquets. A bouquet decorated in a polynomial endo-
functor I ←E →B →I is a bouquet where the node is decorated with an
element b ∈B and there is speciﬁed a bijection between the input devices
and the ﬁbre Eb. This gives also an implicit decoration of all edges in I:
each leaf e is decorated by s(e) and the output edge is decorated by t(b).
Now we see that a P-decorated bouquet is the same thing as a bouquet
A ←L →1 →A with a cartesian map to P, i.e. a diagram
A 
L
- 1
- A
I
α
?

E
?
- B
β
?
- I.
α
?
Then clearly the map β speciﬁes b, while the cartesian square speciﬁes the
bijection between L and Eb. The maps A →I are completely determined
by the observation that A = L + 1 and the requirement that the two outer
squares commute.
So the set of all P-decorated bouquets is naturally identiﬁed with the
set of all such diagrams
The crucial property of P-trees is that they are rigid in the sense that
they have no automorphisms. The notion of automorphism of a tree is
clear: you need to map nodes to nodes and edges to edges, perserving
the parenthood relations.
So all you can do is to permute isomorphic
siblings. . . So recursively, we can characterise the automorphisms: the dot-
less tree has no auts, and neither do the nullary one-dot tree or the unary
one-dot tree. The the n-leaf bouquet has automorphism group Sn. For
other trees, the automorphisms are the permutations of isomorphic sub-
trees of the root node.
[Rough draft, version 2007-05-24 21:36]

226
Trees
13.3.4 Proposition. Isomorphisms of trees correpond precisely to diagrams
A1 
N′
1
- N1
- A1
A2
?

N′
2
?
- N2
?
- A2.
?
where the vertical maps are isomorphisms.
On the other hand, ismorphisms of P-trees are precisely isomorphisms
in the slice category Poly/P. So they are diagrams like the above, com-
patible with the decoration maps. In other words, you can only permute
siblings if they are isomorphic as trees and with the same decorations.
13.3.5 Proposition. P-trees have no automorphisms.
Basically the reason is that the input edges of a node can not be per-
muted because they are in ﬁxed bijection with some ﬁbre Eb of the deco-
rating endofunctor P.
We should check the details. One might think perhaps that this state-
ment holds more generally for any slice category Poly/P. But this is not
true: if P is the polynomial functor with only one operation, and this oper-
ation is of arity 2 (so it is the one-variable polynomial functor represented
by the map E := {left, right} →{continue}), then we can take another
polynomial functor over it, E × 2 →2. This polynomial functor has an
involution over P, namely the involution of 2. . .
Even simpler: over the identity functor 1 ←1 →1 →1, the polyno-
mial functor 1 ←7 →7 →1 has 7! auts!
This can not happen for trees: an isomorphism of trees can only per-
mute siblings, and this is not possible when the siblings are in bijection
with some ﬁxed ﬁbre Eb. More formally, it is not difﬁcult to see that a
isomorphism diagram must be compatible with the walk-to-the-root func-
tions, and hence it can only permute siblings. . .
Here is an example:
1 2 3 4
5
6
y
z
7
x
[Rough draft, version 2007-05-24 21:36]

13.3 P-trees
227
With the bijections to {left, right} as indicated by the orientation of the
paper. Let’s try to interchange y and z, and their subtrees, so we also
interchange 1 ↔3 and 2 ↔4. But since we interchange y and z we are
forced also to interchange their images under the out-edge map, namely 5
and 6. But this is impossible because they constitute the ﬁbre over x, and
hence they must be in ﬁxed bijection with {left, right}. . .
The proposition should perhaps identify which sorts of polynomial
endofunctors have are automorphism free (perhaps all connected poly-
nomial functors!?) and then just observe that trees are of this kind?
Connectedness is not the correct notion though: consider P to be the
identity functor, represented by the bouquet
. Consider the circular
graph of a clock: there are 12 nodes, and each has an output edge and
an input edge. A rotation of the clock face gives and automorphism over
P of the associated polynomial endofunctor.
Examples
Subtrees
We saw two examples of subtrees: dotless subtrees (one for each edge) and
one-dot subtrees. We shall now show that every subtree is generated by
these.
13.3.6 Pushouts over unit trees – grafting. Given a diagram of tree maps
{e}
l
- T1
T2
r
?
such that l(e) is a leaf in T1 and r(e) is the root edge in T2 Then the pushout
T2 ◦e T1 exists in the category of trees.
Proof. The dotless tree {e} is given by 1 ←∅→∅→1. The two other
trees are given by
I1 ←E1 →B1 →I1
I2 ←E2 →B2 →I2.
[Rough draft, version 2007-05-24 21:36]

228
Trees
It is clear what it means that r(e) is the root. To say that l(e) is a leaf meant
that l(e) is disjoint from B2 in I2.
Let us construct the tree which we claim is the pushout. Deﬁne I : =
I2 +e I1, the amalgamated sum in the category of sets. Put B := B2 + B1 and
E := E2 + E1. This assembles into a polynomial functor with the obvious
maps
E2 + E1
p2+p1
- B2 + B1
I2 + I1
s2+s1

I2 + I1
t2+t1
-
I2 +e I1

I2 +e I1
-
We claim this is a tree. Indeed, since l(e) is not in the image of t1, the right-
hand side composite is still a mono. We also have E2 + E1 + 1 = I2 +e I1,
since the root in I1 gets identiﬁed with an element in I2. Finally, check ρ:
for i ∈I2 in a ﬁnite number of steps we get to r, and from here in another
ﬁnite number of steps down to the root (the root of I1).
Check the universal property. Uniqueness follows readily from the uni-
versal properties of the sums and amalgamated sum in Set. Remains to
check that the unique map is cartesian. . .
2
Deﬁnition. An inner edge of a tree is one that is simultaenously in the im-
age of s and t. In other words, the inner edges are given by the set B ×I E
considered as a subobject of I. These are pairs (b, e) such that t(b) = s(e).
Every inner edge sits in two one-dot subtrees, as a leaf and as a root re-
spectively. Namely as the root of the b-dot tree:
1 
0
- 0
- 1
Eb + 1
?

Eb
?
- {b}
?
- Eb + 1
17→1
?
[Rough draft, version 2007-05-24 21:36]

13.4 From trees to polynomial monads
229
and as the e-leaf of the p(e)-dot tree:
1 
0
- 0
- 1
EP(e) + 1
?

Ep(e)
?
- {p(e)}
?
- EP(e) + 1
17→e
?
13.3.7 Proposition. Every tree is an iterated pushout (indexed by its inner edges)
of its one-dot subtrees.
13.3.8 Proposition. Each inner edge e deﬁnes a two-dot subtree, namely the
pushout over e of the two one-dot subtrees containing e.
13.3.9 Proposition. The set of subtrees in T is generated from the one-dot sub-
trees by iterated pushouts over edges.
We aim at constructing the free monad on T in this way:
13.3.10 Proposition. The free monad on a tree has the same I. Its set of opera-
tions B∗is the set of subtrees in T. The set E∗is the set of subtrees with a marked
leaf. The composition law is given by pushouts over edges.
It follows that a monad map between tree monads must respect pushouts
over edges. It also follows that it is determined by its values on dots. Each
dot is sent to a subtree. These subtrees are glued together according to
the same recipe as the dots in the domain tree are glued together (i.e. one
gluing for each inner edge).
13.4
From trees to polynomial monads
Slogan: monads make the world go ‘round
Now we have a good deﬁnition of what a subtree is. Note that these
are ‘cartesian’ ‘isometric’ inclusions: this means that ‘arity preserving’ and
‘distance preserving’: if some node is in the subtree then all its input edges
are in too. And if an edge is child of another edge, then the same is the case
for their images.
[Rough draft, version 2007-05-24 21:36]

230
Trees
13.4.1 Second construction. Given a tree T, deﬁne a polynomial functor
by the diagram
S′
p - S
A
s

A
t
-
where A is the set of edges in T, S is the set of subtrees in T, and S′ is the
set of subtrees with a marked input edge. The maps are the obvious ones:
s returns the marked edge of the subtree, p forgets the mark, and t returns
the output edge of the subtree.
By subtree we mean a morphism of trees in the sense of ?? for which
the maps on edges and dots are inclusions of set (not just arbitrary monos).
13.4.2 Proposition. The polynomial endofunctor constructed from a tree (via the
subtree construction) is naturally a cartesian monad.
Let us show it is a monad. In a minute we will observe anyway that it
is the free monad on the ﬁrst construction, and we know that free monads
are cartesian.
Comparison between the two constructions
13.4.3 Proposition. The monad associated to a tree is nothing but the free monad
on the plain polynomial endofunctor associated to the tree.
Proof. This looks surprising at ﬁrst, because we are used to see free monads
as big inﬁnite things, where the operations are generated by freely com-
bining the original operations as long as the types match. However, in this
case the set of types is the set of edges, and for each inner edge there is
only one operation having this output type, namely the node sitting just
above the edge. So even freely, each operation can be used only once. . . 2
13.4.4 Comparison between the two constructions. The plain construc-
tion was used to decorate trees with polynomial endofuctors.
Now if the polynomial functor is a monad P and we decorate a tree
with it, then we are really talking about a map of polynomial functors from
the tree plain-endo into the underlying endofunctor of P. By adjunction
this is the same as considering monad maps from the tree monad into P:
[Rough draft, version 2007-05-24 21:36]

13.4 From trees to polynomial monads
231
13.4.5 Corollary. Let T be a tree, and let P be monad represented by I ←E →
B →I. Then there is a bijection between decorations of T by P
A 
N′
- N
- A
I
?

E
?
- B
?
- I
?
and monad maps
A 
S′
- S
- A
I
?

E
?
- B
?
- I
?
13.4.6 Example. As an example of a computation of the free monad on a
polynomial endofunctor, let us compute the free monad on the endofunc-
tor associated to a tree. This is an easy example since it is a ﬁnite compu-
tation. So start with the polynomial endofunctor corresponding to some
small tree, and compute the free monad. Let’s take the tree
1
2
3
4
5
6
7
x
y
z
w
of example 13.2.16. WRITE OUT WHAT P IS
This is our ﬁrst example with non-trivial types. As always, in the ﬁrst
round, where we compute the polynomial functor Id +P ◦0, we pick up
all the nullary operations, and then add an unary operation for each type.
1
2
3
4
5
6
7
w
5
These correspond together to all the one-edge subtrees in the original tree.
In the next step of the iteration, we glue all these trees on top of all the
nodes (the original operations), in all possible ways. In this way we get all
the subtrees with edge-length 2, and again we add formally all the dotless
trees, so altogether we get the subtrees of edge-length at most 2: Then the
operations of the composite polynomial functor is the set of all ways of
decorating the four bouquets
[Rough draft, version 2007-05-24 21:36]

232
Trees
x
1
2 3 4
y
2
5
w
y
2
5
z
4
6 7
w
5
1
2
3
4
5
6
7
Next iteration we get also those with edge-length at most 3, which in
this case is the set of all subtrees in the original tree.
In general, there will be only a ﬁnite number of steps in the iteration; af-
ter that it stabilises. This phenomenon is characteristic for trees: although
the free-monad construction usually goes on inﬁnitely, for trees it stops
after step n where n is the height of the orignal tree.
Examples of polynomial monads from trees
13.4.7 Concrete description. Let us work out concretely what this polyno-
mial functor does. The polynomial functor will have a variable Xi for each
edge i ∈I, and it will also have an output component Pj for each edge
j ∈I. The component Pj will be a sum indexed by all subtrees of T with
root edge j.
 Xi | i ∈I
 7→
 Pj(x) | j ∈I

where each Pj is a sum over all subtrees with root j. For each such subtree
with root j, the corresponding monomial is the product of all the variables
corresponding to the leaves of that subtree. Given one such subtree S, say
with set of leaves L, the corresponding monomial is the product
∏
l∈L
Xl,
the product of all the variables of the leaves of S.
If for example S is the subtree
j
a
c d
b
then
Pj = XaXbXcXd.
[Rough draft, version 2007-05-24 21:36]

13.4 From trees to polynomial monads
233
All this is just the general description of what a polynomial functor
does:
 Xi | i ∈I
 7→
 Pj(x) | j ∈I

with
Pj = ∑
b∈Bj ∏
e∈Eb
Xs(e)
Note that Xs(e) is the variable corresponding to leaf e of b ∈Bj, where s(e)
runs through the leaves of the subtree b (which has root edge j). So the
description follows directly from the general description of polynomial
functor.
13.4.8 Example. Many example, incuding the example linear trees give lin-
ear polynomials. We already saw in an example that the linear tree with
n dots gives rise to the linear (directed) graph (with n + 1 vertices and n
edges. Now if we take the free monad on that one, that corresponds pre-
cisely to taking the free category on this graph it gives us precisely the
category [n] (the categorical n-simplex).
To be explicit, if the linear tree is
a
b
c
0
1
2
3
then the polynmial functor is the linear functor
{0, 1, 2, 3} ←{a, b, c} →{0, 1, 2, 3}
there the two maps are input-edge and output-edge, respectively.
This corresponds to the directed graph 0
a→1
b→2
c→3.
Taking the free monad on this functor gives us a set of operations
{00, 11, 22, 33, 01, 12, 23, 02, 13, 03}
which are precisely the set of all arrows in the categorical 3-simplex [3],
which is the free category on the previous graph.
[Rough draft, version 2007-05-24 21:36]

234
Trees
Factorisation systems in the category of trees
We now deﬁne a category of trees, more general than the one constructed
above, where the only maps are inclusions. We simply deﬁne a morphism
between two trees to be a monad map between the associated tree monads.
Leinster describes a category of trees: it is generated by contracting
inner edges and setting a dot on an edge. More generally you can talk
about contracting a subtree to a single dot, and then the setting-dot maps
are just a special case of this, where a subtree consisting of a single edge is
contracted, i.e. place a new dot on it. These maps can be described in terms
of set maps on the sets of dots in a tree. You can also let the arrows go the
other way – this is what we do here: then instead of a subtree contraction
we have expansion. This can be described in terms of a set map on the
sets of edges: it is an inclusion of edges, where the edges not hit are those
introduced to express the expansion. In the case of single dot, we are now
removing a one-valent dot: hence on the level of edges, we are sending to
edges to the same map, so it is a surjection in this sense.
Let us describe the three types of maps.
13.4.9 Subtree inclusions. DESCRIPTION AND DRAWING.
Observe that these are the inclusions of ‘constant speed’, or ’distance
preserving’.
13.4.10 Dot deletions. DESCRIPTION AND DRAWING. These generate
the epimorphisms, as we shall see.
Note that these maps preserve root and leaves.
13.4.11 Expansions. DESCRIPTION AND DRAWING.
Note that these maps preserve root and leaves.
13.4.12 Lemma. Each of these types of maps is a cartesian map in PM
Comparison with face and degeneracy maps in ∆.
From monad maps to tree maps
Now we aim at showing that maps in PM between tree monads can be
written uniquely as a triple composite, where the ﬁrst is a sequence of dot
[Rough draft, version 2007-05-24 21:36]

13.4 From trees to polynomial monads
235
deletions, the next part is a sequence of expansions, and the last part is a
tree inclusion.
13.4.13 Lemma. Let φ be a monad map between polynomial monads associated
to trees. Then φ perserves ancestor relation. In other words, if an edge a is an
acestor of an edge b, then φ(a) is ancestor of φ(b) (possibly they are the same
edge).
In other words, φ preserves the tree order! (on edges)
Proof. Let T denote the minimal subtree with a as root edge and b as a
leaf. Having b as marked leaf makes T an element in S′. By construction,
s(T) = b and t(p(T)) = a. Now apply φ and use the fact that φ commutes
with each of the strucutre maps. Hence φ(T) has φ(b) as root and φ(b) as
marked leaf.
2
13.4.14 Remark. We should be more formal about the notion of minimal
subtree spanned by two edges in ancestor relation, to avoid relying on
intuition from geometric trees. Let the tree T be given by A ←N′ →N →
A. Suppose we have two edges in T in ancestor relation, so that ρk(e) = r
for some k ∈N. If e = r is the root of T, then the minimal subtree is the
one consisting only of the root. We aim at cosntruction a subset K ⊂N
with k elements, which intuitively is the set of dots in the path from e to r.
Formally, for 0 ≤i < k the edge ρi(e) is not the root, so we can consider it
as an element in N′. The wanted set K is the set
K := {p(ρi(e)) | 0 ≤i < k}.
Now deﬁne K′ : = N′ ×N K (this means we take all the input edges of all
the dots we have), and ﬁnally let the set of edges be K′ + {r}.
13.4.15 Lemma. A monad map between tree monads is completely determined
by its value on the edge set.
To see this, observe that the set of subtrees S in a given tree is stratiﬁed
by the number of dots in the subtree. The 0-stratum is just the set of edges.
The 1-stratum is the set of dots. The plain endo associated to the tree is
precisely the 1-stratum of the monad, and there is a canonical map S1 ⊂S,
inducing a map of polynomial endos: it is nothing but the unit for the
adjunction.
[Rough draft, version 2007-05-24 21:36]

236
Trees
(There is also always a map from A ←A →A →A to A ←S′ →
S →A, which is the unit for the monad, but note that A is not a tree in any
way.)
Observe that by adjunction, a tree monad map is determined by its
value on dots. Note that the image of a dots does not need to be a dot: it
can be a more general subtree.
Let b ∈B be a onedot subtree in T0: it has an output edge t(b) and a set
of input leaves {s(e) | e ∈Eb}. The image of this subtree is a subtree in T1,
and for SOME REASON this subtree has leaves α(s(e)) and root α(t(b)).
There is at most one such subree in T1, namely the one whose edge set is
the union of the edge sets consistin in all the edges between a leaf α(s(e))
and α(t(b)).
13.4.16 Poset structure on the set of subtrees. Let T be a tree, then there
is a natural poset structure on the set Sub(T) of subtrees in T.
13.4.17 Lemma. Let T0 and T1 be trees, and consider a monad map between the
associated free monads:
A0 
Sub′(T0)
- Sub(T0)
- A0
A1
?

Sub′(T1)
?
- Sub(T1)
?
- A1
?
The then map Sub(T0) →Sub(T1) is a poset map.
Proof. To say that U is a subtree in V means that every edge e of U is de-
scendant of the root r in V and ancestor of some leaf of V (or let’s just say
ancestor of some edge q in V. We know that the map preserves ancestor
relation, hence φ(e) is descendant of φ(r) and ancestor of φ(q). The re-
maining edges of φ(U) lie in between, so they also have this property, so
altogether φ(U) is a subtree of φ(V).
FORMALISE THIS!!!
2
Deﬁnition. A monad map between tree monads is called boundary pre-
serving if it takes the maximal subtree to the maximal subtree. Clearly the
composite of two boundary-preserving maps is boundary preserving.
[Rough draft, version 2007-05-24 21:36]

13.4 From trees to polynomial monads
237
13.4.18 Proposition. Every monad map between tree monads φ : FT0 →FT1
factors essentially uniquely as a boundary-preserving map followed by a free map
(i.e. a map of the form Fα : FT0 →FT1).
Proof. Let m ∈Sub(T0) denote the maximal subtree (i.e. the tree T0) itself,
and let φ(m) ∈Sub(T1) denote its image. By deﬁnition this is a subtree in
T1, i.e. φ(m) →T1 is a morphism in the category of trees constructed in ??.
Denote this tree M1, let I1 denote the set of edges in M1, and denote the
inclusion α : M1 →T1. Now we have obvious maps
A0 
Sub′(T0)
- Sub(T0)
- A0
I1
?

Sub′(M1)
?
- Sub(M1)
?
- I1
?
A1
?

Sub′(T1)
?
- Sub(T1)
?
- A1
?
By construction the ﬁrst map is boundary preserving, and the second is
free. It is clear this factorisation is unique: the middle object must be a
subtree in T1 in order for the second factor to be free, and in order for the
ﬁrst factor to be boundary preserving, this subtree must be precisely the
image.
2
Recall from 9.4.5 and 11.2.4 that every map can be factored as one
where all the vertical maps are epis followed by one where all the ver-
tical maps are monos. (I don’t know that these are precisely the epis and
monos of the category — these might b more restrictive classes — but that
it not important here.)
At this point we don’t know that the middle object in this factorisation
is in fact a tree monad, and we haven’t given a concrete characterisation
of which monads are trees. . .
13.4.19 Proposition. Every tree monad map factors uniquely as a sequence of
dot deletions, followed by a a sequence of expansions, followed by a subtree inclu-
sion.
[Rough draft, version 2007-05-24 21:36]

238
Trees
The dot deletions are the epis, while the two other classes together span
the monos. Epi and mono are the same thing as surjection and injection
on the level of edge sets. (CHECK THIS)
We will show this abstractly in the full subcategory of tree monads.
Here is the plan:
We know that every tree monad map factors as an epi followed by a
mono. Epi means that all the vertical maps are epi, mono means that all
the vertical maps are mono.
We need to check that if the involved polynomial functors are monads,
and if the vertical maps are monad maps (WHICH WE STILL NEED TO
FIND A HANDY DESCRIPTION OF), then the factors are again monad
maps
Characterisation of the three classes of maps
13.4.20 Lemma. An epimorphism between tree monads is a composite of dot
deletions.
Proof. Suppose two edges have the same image. By ancestor compatibility,
. . . . . . we conclude that one must be an ancestor of the other and that the
path from one to the other also maps to the same edge. Now the mini-
mal subtree spanned by this path will also have to map to the same edge
(ARGUMENT!), but since valence is preserved, and the image subtree is
a single edge, the whole subtree has valence 1 so it is a linear tree. Hence
the map can be realised as dot deletions.
2
Now consider monos between tree monads. We have the free monos
(every free map is a mono) and the boundary-preserving monos.
Moerdijk and Weiss [38] uses the terminology inner face map and outer
face map: the outer face maps are the free maps. i.e. those that respect the
S1-stratum. This is equivalent to saying that it is F(α) for some plain endo
tree map α. In other words, a subtree inclusion. It amounts to adding more
tree stuff at the boundary i.e. on the outside of the little tree.
By an inner face map, we mean one that sends the maxmial stratum to
the maximal stratum. (These can have different numbers.). In other words,
it sends the maximal subtree (an element in S) to the maximal subtree. In
particular it preserves the root and the set of leaves. So all the change takes
place in the inside of the tree, this is why it is called an inner mono. Show
that they are precisly the expansions.
[Rough draft, version 2007-05-24 21:36]

13.4 From trees to polynomial monads
239
13.4.21 Lemma. The boundary preserving maps are colimits of dot reﬁnements.
By a dot reﬁnement we mean modifying a tree by selecting one node
and then substituting this node by a more complicated tree of the same
arity.
The statemente is: we want to characterise the boundary-preserving
maps between trees. These are by deﬁnition monad maps between the
associated tree monads, but by adjunction they are also the plain maps
from a tree endo to a tree monad – it is determined by its value on the
one-dot subtrees in T0. Now in fact T0 is a gluing of these bouquets along
dotless subtrees. Study the effect of the map on each such one-dot subtree.
The effect is that the image of such a b is a subtree with the same arity
(this is by being the image – in other words we are factoring the inclusion
b ⊂T0 →FT1 as a boundary-preserving one followed by a free map and
studying the boundary-preserving factor.
In any case, the ﬁrst step is to characterise the boundary-preserving
maps out of one-dot trees. These are dot reﬁnements.
Now the claim is that the original map is the gluing of all these maps.
In other words, we glue together all these trees φ(b) according to the same
recipe as the b were glued together to the tree T0.
The main point is that the image subtrees φ(b) are just as disjoint as
the original one-dot trees b: they only have some edges in common and
indeed they are glued together at these edges.
13.4.22 Remark. The category of trees contains the simplex category: these
are just the linear trees. The triple factorisation system is preserved: in ∆
the factorisation system is: epi followed by top-and-bottom preserving
mono, followed by speed-1 mono.
13.4.23 Remark. The factorisation of a mono into an outer mono followed
by an inner mono has uniqueness. One can also always factor into inner
followed by outer, but this factorisation is not unique: if the outer mono ε
is an expansion that takes place away from the subtree we ﬁrst included
(via ι), then that subtree will also be a subtree (with inclusion ι′) in the
expanded tree, so that
ε ◦ι = id ◦ι′.
[Rough draft, version 2007-05-24 21:36]

240
Trees
13.5
Factorisation systems
We already have the epi-mono factorisation in Poly and in PolyMon.
Check that the middle objcet is again a tree monad, so that we also get
a epi-mono factorisation in Tree.
Note that the free monad is polynomial. By general theory, this implies
that the class of free maps (i.e. the subtree inclusions) is the right-hand part
of a factorisation system: the left hand part are the generic morphisms.
Joyal [27], Weber [45]. . .
There is a very explicit description of this factorisation, and in fact con-
structs it from scratch.
First do the case where the source tree S has only one dot.
This dot maps to a subtree of T, say R ⊂T. Clearly there is induced a
map from S to the tree monad on R. And clearly there is also an inclusion
R ⊂T which induces a free map on the associated tree monads. It is ﬁnally
obvious that this triangle commutes, giving the factorisation in this case.
For the general case, exploit the fact that the tree S is a colimit of one-
dot trees over dotless trees. Now glue together all the factorisations of the
maps on these dots. The universal property of the colimit provides the
factorisation.
Combinining the two factorisation systems we get a double factorisa-
tion system: there are three classes of maps: ﬁrst the class of epis (these
are all generic), then the class of generic monos (these are the expansions),
and ﬁnally the class of free maps (these are all monos– they are the subtree
inclusions.
The subcategory of generic tree maps was studied by Leinster, although
his category is the opposite of this one.
The category of generic monos was studied by Kapranov and Ginzburg.
The total category is the dendroidal category of Moerdijk and Weiss [38],
the base category for dendroidal sets. The factorisation system plays an
important role in their theory [39], since the inner Kan condition is phrased
in terms of inner face maps, these are . . . compare with generic face maps.
[Rough draft, version 2007-05-24 21:36]

13.6 Trees of trees, constellations, and the Baez-Dolan construction
241
13.6
Trees of trees, constellations, and the Baez-
Dolan construction
The following is mostly copied from [31].
To a given polynomial monad P : Set/I →Set/I, represented by
I ←E →B →I we shall associate another polynomial monad P+ :
Set/B →Set/B. The construction is originally due to Baez and Dolan [7],
later given an elegant reformulation by Leinster [34]. The version here, for
polynomial functors is from [31]. First we give a formal treatment, then an
explicit graphical version, which also serves to establish that the output of
the ﬁrst version is polynomial.
Throughout this subsection, we ﬁx a polynomial monad P, represented
by
E
- B
I

I.
-
13.6.1 The Baez-Dolan construction for polynomial monads, formal ver-
sion. Denote by PolyMon(I) the category of polynomial monads on Set/I,
BD-formal
i.e. the category of monoids in Poly(I).
Since P is a monad, the slice
category Poly(I)/P has a natural monoidal structure: the composite of
Q →P with R →P is R ◦Q →P ◦P →P and the unit is Id →
P. Let PolyMon(I)/P denote the category of polynomial monads over
P, i.e. monoids in Poly(I)/P. The forgetful functor PolyMon(I)/P →
Poly(I)/P has a left adjoint, the free P-monad functor, hence generating
a monad T : Poly(I)/P →Poly(I)/P. The Baez-Dolan construction con-
sists in reinterpreting this as a monad on Set/B and observing that it is
polynomial, cf. [31].
The key point is that there is a natural equivalence of categories
Poly(I)/P ∼
→Set/B,
(13.2)
club-eq
given by evaluation at the terminal object I →I, which we denote by 1.
Here we should really observe that at ﬁrst we arrive at the slice cate-
gory of Set/I over B/I, but then we reinterpret this as Set/B.
[Rough draft, version 2007-05-24 21:36]

242
Trees
In detail, if Q →P is an object in Poly(I)/P, the associated object in
Set/B is simply Q(1) →P(1) = B. The inverse equivalence basically
takes an object C →B in Set/B to the object in Poly(I)/P given by the
ﬁbre square
E ×B C
- C
I 
E
?
- B
?
- I.
The promised monad, the Baez-Dolan construction on P, denoted P+ :
Set/B →Set/B is simply the monad corresponding to T : Poly(I)/P →
Poly(I)/P under this equivalence. We shall describe this monad explicitly
in a moment and see that it is polynomial.
To compare with Leinster’s version of the Baez-Dolan construction [34],
note that the above equivalence induces a monoidal structure on Set/B
which is the tensor product of P-collections, for which the monoids are the
P-operads, in the sense of [34]. The substitutional tensor product on Set/B
is not the usual one (which we know corresponds to one-variable polyno-
mial functors given just by E →B) but rather some coloured version. Is it
true at all that coloured operads are monoids in some monoidal category?
YES, IN A BURRONI THING
Hence we also get an equivalence of categories between PolyMon(I)/P
and the category of P-operads, and the free P-monad functor on Poly(I)/P
corresponds to the free P-operad functor used in Leinster’s version of
the Baez-Dolan construction. The equivalence (13.2) seems to be due to
Kelly [30], in the more general setting of clubs.
MORE INFO:
13.6.2 The Baez-Dolan construction for a polynomial monad, explicit
graphical version. Starting from our polynomial monad P, we describe
BD
explicitly a new polynomial monad P+, shown afterwards to coincide
with the one constructed above. The idea is to substitute into dots of trees
instead of grafting at the leaves (so notice that this shift is like in a zoom
relation). Speciﬁcally, with B∗the set of P-trees, deﬁne U∗to be the set of
[Rough draft, version 2007-05-24 21:36]

13.6 Trees of trees, constellations, and the Baez-Dolan construction
243
P-trees with one marked node. There is now a polynomial functor
U∗
- B∗
B

P+
B
-
where U∗→B∗is the forgetful map, U∗→B returns the bouquet around
the marked dot, and t : B∗→B comes from the monad structure on P —
it amounts to contracting all dots back to the root dot (or setting a new dot
in the dotless tree). Graphically:
*
























(13.3)
slice1
(In this diagram as well as in the following diagrams of the same type, a
symbol

	
is meant to designate the set of all bouquets like this (with
the appropriate decoration), but at the same time the speciﬁc ﬁgures rep-
resenting each set are chosen in such a way that they match under the
structure maps.)
This polynomial endofunctor P+ is naturally a monad: the substitution
law can be described in terms of a partial composition law
B∗×B U∗→B∗
deﬁned by substituting a P-tree into the marked dot of an element in U∗,
[Rough draft, version 2007-05-24 21:36]

244
Trees
as indicated in this ﬁgure:
F
a
b
c
a
f
b
p
h
c
resulting in
a
b
c
p
h
(13.4)
BD-subst
Of course the substitution makes sense only if the decorations match. This
means that t(F), the ‘total bouquet’ of the tree F, is the same as the local
bouquet of the node f. (The letters in the ﬁgure do not represent the deco-
rations — they are rather unique labels to express the involved bijections.)
The unit is given by the map B →B∗interpreting a bouquet as a tree with
a single dot. (One can check again that this monad is cartesian.)
13.6.3 Comparison between the two versions of the construction. We
wish to compare the two monads T and P+ under the equivalence of
categories Poly(I)/P ∼
→Set/B. The explicit description of P+ allows
us to compute its value on an object C →B of Set/B: the result is the
set of P-trees with each node decorated by an element of C, compati-
bly with the arity map C →B (being a P-tree means in particular that
each node already has a B-decoration; these decorations must match). We
claim that this is the same thing as a Q-tree, where Q is the polynomial
functor corresponding to C →B under the key equivalence, i.e. given by
I ←E ×B C →C →I. Indeed, since the tree is already a P-tree, we already
have I-decorations on edges, as well as bijections for each node between
the input edges and the ﬁbre Eb over the decorating element b ∈B. But if
c ∈C decorates this same node, then the cartesian square speciﬁes a bijec-
tion between the ﬁbre over c and the ﬁbre Eb and hence also with the set
of input edges. So in conclusion, P+ sends C to the set of C-trees. On the
other hand, T sends the corresponding polynomial functor Q to the free
monad on Q, with structure map to P given by the monad structure on P.
[Rough draft, version 2007-05-24 21:36]

13.6 Trees of trees, constellations, and the Baez-Dolan construction
245
Speciﬁcally, T produces from Q the polynmomial monad
- C∗
E∗
?
- B∗
?
E
?
- B
?
where C∗denotes the set of Q-trees, so the two endofunctors agree on
objects. The same argument works for arrows, so the two endofunctors
agree.
To see the monad structures agree, note that the set of operations for
P+ ◦P+ is the set of P-trees with nodes decorated by P-trees in such a way
that the total bouquet of the decorating tree matches the local bouquet of
the node it decorates. The composition law P+ ◦P+ ⇒P+ consists in
substituting each tree into the node it decorates. On the other hand, to
describe the monad T it is enough to look at the base sets, since each top
set is determined as ﬁbre product with E over B. In this optic, T sends B
to B∗, and T ◦T sends B to B∗∗which is the set of P∗-trees, which is the
same as P-trees with nodes decorated by P-trees, and edges decorated in I,
subject to the usual compatibility conditions. Clearly the composition law
T ◦T ⇒T corresponds precisely to the one we described for P+. For both
monads, the unit is described as associating to a bouquet the correponding
one-dot tree.
In conclusion, the two constructions agree, and, in particular, produce
a polynomial functor.
MORE STUFF FROM ZOOM
[Rough draft, version 2007-05-24 21:36]

246
Trees
[Rough draft, version 2007-05-24 21:36]

Part III
Categorical polynomial functors
[Rough draft, version 2007-05-24 21:36]


Chapter 14
Categorical polynomial functors
14.1
Introduction
As we have mentioned at several occasions in Part II, the notion of poly-
nomial functor makes sense quite generally in any category C which is
locally cartesian closed. However, one context where it would be really
nice to have polynomial functors is in Cat, and Cat is not locally cartesian
closed (cf. analysis below). In this chapter we analyse that problem more
closely, and deﬁne some restricted version of polynomial functors.
One reason we would like to have polynomial functors in Cat is that
we are actually wanting polynomial functors in groupoids (alas, the cat-
egory of groupoids has the same defect as Cat in this respect), because
with groupoids we might be able to ﬁnd universal families for some of our
classes of polynomial functors, where previously we had to accept coarse
ones. In example 14.4.1 below we study the family functor. . . FORMULATE
THIS PROPERLY
There are at least two versions of this notion. For sets we have a natural
equivalence of categories
Set I ≃Set/I
For categories this is no longer true, so alone for this reason there will be
two versions. Sticking to the Cat/I viewpoint, we run into the problem
that not for all functors does the pullback functor admit a right adjoint.
Then restrict attention to the functors for which this works—these are the
Conduché ﬁbrations. This is what we do in the ﬁrst part.
The other approach is to restrict the notion of ‘relative categories’ that
[Rough draft, version 2007-05-24 21:36]

250
Categorical polynomial functors
we want to put through a polynomial functor. Instead of allowing any
functor X →I as input, we can restrict attention to discrete ﬁbrations.
This is the same thing as looking at presheaves, so we can now reformulate
everything in terms of presheaf categories
bI
s∗- bE
p∗- bB
t!- bJ
for a diagram
E
p - B
I
s

J
t
-
All this works very smoothly.
After doing this, it is interesting to give up the requirement that the
ﬁbrations be discrete. Let’s look at any ﬁbration. This is like generalising
from presheaves to prestacks. An intermediate level of generality which
is perhaps the most interesting is to look at groupoid ﬁbrations.
In any case this second viewpoint relies on the notions of left Kan
extension, ﬁnal functors (and the factorisation system consisting of ﬁnal
functors and discrete ﬁbrations). There are two formulations of this the-
ory: in terms of presheaves and in terms of discrete ﬁbrations. For presheaves
the adjunctions are straightforward to use. In the discrete-ﬁbration view-
point the pushforth functor is not the usual one because the pushforth of
a discrete ﬁbration is not in general a discrete ﬁbration again. You need to
factor it into ﬁnal followed by discrete. . . This slightly more complicated
pushforth corresponds to the usual pushforth of presheaves.
Abstractly speaking, a category C is locally cartesian closed if all its
slice categories are cartesian closed. If this is true then the pullback has a
right adjoint. ???
The problem with Cat is that not all slices are cartesian closed.
Cat is not locally cartesian closed
Another way of formulating the problem with Cat is to say that there are
functors p : E →B for which the pullback functor
p∗: Cat/B
−→
Cat/E
X
7−→
E ×B X
[Rough draft, version 2007-05-24 21:36]

14.1 Introduction
251
does not have a right adjoint. Clearly this is a serious problem, since the
whole construction of polynomial functors is based on such right adjoints.
Here is an example which in a precise sense is the initial example—
the example that has precisely what it takes to exhibit the problem, and
nothing more than that.
It is not difﬁcult to see that a pullback functor has a right adjoint if and
only if it preserves all colimits. Indeed, any functor that has a right adjoint
preserves all colimits, and the converse is true if just some mild conditions
about generators is satisﬁed. Find an exact formulation and reference of
this. . . BORCEUX??
First we’ll need some simplicial notions and notations.
14.1.1 Notation. Let [n] denote the category freely generated by a string
of n arrows. It is the category corresponding to the totally ordered set
[n] = {0 < 1 < · · · < n}. The full subcategory of Cat consisting of these
categories is ∆.
14.1.2 Example. This is an example of a functor p : E →B such that
triangle
p∗does not preserve colimits, and in particular p∗can not have a right
adjoint. Let E be the category [1], and let B be [2], and let the functor
p : E →B be the functor [1] →[2] which preserves the endpoints:
[1] →[2]
So this is the inclusion of the hypotenuse 0 →2 in the triangle.
0
- 2
1

-
We claim that the corresponding pullback functor,
p∗: Cat/B →Cat/E
does not preserve colimits: we exhibit a concrete pushout square which is
[Rough draft, version 2007-05-24 21:36]

252
Categorical polynomial functors
not preserved:
[1]
- [2]
[0]
6
- [1]
6
(14.1)
Segal-square
These four maps are maps in Cat/B. Now pull back this square to Cat/E.
We get
[0]
- [1]
∅
?
- [0]
?
which is clearly not a pushout, because the pushout of • with • over the
empty set is just the disjoint union of two points, whereas in [1] there is an
arrow between the two points.
14.2
Conduché ﬁbrations
Question: when does the pullback functor p∗: Cat/B →Cat/E have
a right adjoint? The problem in the example we just saw is that there is a
factorisation in the bottom space that cannot be lifted to the top space. The
Conduché condition will preclude this sort of problem:
14.2.1 The Conduché condition. Let p : E →B be a functor. The Conduché
condition states that for every triangle h = g ◦f in B, every lifting of the
hypotenuse h to E extends to a lift of the whole triangle. Furthermore,
this lift is unique in the sense that if there are two such lifts, then there
is a chain of vertical arrows comparing them. In other words, if triangle
h′ = g′ ◦f ′ and h′ = g′′ ◦f ′′ both lie over h = g ◦f, then there is a vertical
arrow i such that f ′′ = i ◦f ′ and g′′ = i ◦g′, or possibly i is not a single
[Rough draft, version 2007-05-24 21:36]

14.2 Conduché ﬁbrations
253
vertical arrow but a zigzag of vertical arrows
·
h′
- ·
·
g′
-
f ′
-
·...
·
·
g′′
-
f ′′
-
Clearly, Example 14.1.2 above does not satisfy the Conduché condition.
Examples of functors that satisfy Conduché condition are ﬁbrations
and opﬁbrations.
14.2.2 Example. A Grothendieck ﬁbration p : E →B is a Conduché ﬁ-
bration. Indeed, given a triangle γ = ψ ◦ϕ in B and a lift to E of the
hypotenuse γ. We need to lift the rest of the triangle. Take the cartesian
lift of ψ to the target of the lift of γ. By the cartesian property, there is then
a unique lift of ϕ to complete the triangle above. So every factorisation
lifts. To see uniqueness, if we are given any other lift of the triangle then
the cartesian property of the ﬁrst one we have ensures that there is a com-
parison. So between any two lifts of the triangle there is a comparison to
the cartesian lift, and hence a zigzag of comparisons.
14.2.3 Theorem. For a functor p : E →B the following are equivalent.
(i) The pullback functor p∗: Cat/B →Cat/E has a right adjoint.
(ii) p∗preserves colimits (i.e. p∗is cocontinuous).
(iii) p satisﬁes the Conduché condition.
This theorem is due to Giraud, who gave a very detailed proof in the
beginning of the sixties. Unfortunately the result was buried deep in the
long and very dry memoir Méthode de la descente [25]. Ten years later the
result was rediscovered by Conduché [17] (unaware that the result was
already in [25]), and today the condition bears his name.
14.2.4 Remark. To say that p∗has a right adjoint is equivalent to saying
that the functor J 7→HomE(p∗J, X) is representable for every X. To prove
[Rough draft, version 2007-05-24 21:36]

254
Categorical polynomial functors
that a functor Catop →Set is representable, there are some tricks, ex-
tracted from Giraud [25]. It is enough to prove that all colimits are pre-
served, and some of them are automatic in our case (I think that coprod-
ucts are preserved, and also coequalisers along a regular epi, or something
of the sort, see [25] Section 2.) Under these condition, it only remains to
see that pushouts like Diagram (14.1) are preserved. Perhaps a theorem
like this can be extracted: for a functor F : Catop →Set preserving certain
colimits, you can check if it preserves all colimits by restricting to the trun-
cated ∆2 = {[0], [1], [2]} and see if this truncated simplicial set is the nerve
of a category. The Segal condition is more or less equivalent to the Con-
duché condition. . . ? NOT SURE IF ANYTHING IS GOING TO COME
OUT OF THIS PARAGRAPH
14.2.5 The Conduché condition in simplicial terms. Let us see what the
Conduché condition has to do with the issue. First let us describe some
subcategories in E. We are interested in what happens above this triangu-
lar subcategory of B
b0
γ
- b2
t
b1
ψ
-
ϕ
-
We see this subcategory t ⊂B as the image of a functor [2] →B, and we
will use the pushout description of the category [2] given in Diagram (14.1)
in Example 14.1.2. This means that b1 is the image of [0], and that the
arrows ϕ and ψ are images of the two copies of [1].
We consider the three ﬁbre categories Eb0, Eb1, and Eb2. For each of
the three arrows we also consider the category of arrows lying over the
arrow (to be described in more detail in a moment), let us describe the
subcategory Eϕ ⊂E of arrows lying over some ϕ : b0 →b1. The objects of
Eϕ are the union Eb0 ∐Eb1. The arrows are those that either lie over ϕ or
lie over the identity arrows of b0 and b1. A more concise description goes
as follows. Note ﬁrst that the set of arrows (or the category of arrows) in B
can be described as the set (or category) of functors I →B, where I = ∆[1]
is the interval category with two objects and a single non-identity arrow.
For an arrow ϕ : b0 →b1 in B we will use the same letter ϕ to denote the
[Rough draft, version 2007-05-24 21:36]

14.2 Conduché ﬁbrations
255
corresponding map I →B. Now Eϕ is simply the pullback
Eϕ
- E
I
?
ϕ
- B
?
Obviously Eϕ contains Eb0 and Eb1 as full subcategories.
In simplicial
terms, this is just the pullback square (here shown for b0):
Eb0
- Eϕ
- E
∆[0]
?
0
- ∆[1]
?
ϕ
- B
?
Finally we consider the category Et whose arrows are those lying over
some arrow in the triangle.
So here is a picture of the seven categories. All the arrows between
them are full inclusions:
Eb0
- Eγ 
Eb2
Et
?
Eϕ
-
-
Eψ


Eb1
-

(The Conduché condition says that the bottom square is a pushout, as we
shall now explain.)
Each of these categories can be described as a pullback
Ei
- E
[i]
?
- B
?
for i = 0, 1, 2. For i = 0 it just says that E0 is the ﬁbre over the object
singled out by [0] →B. For an arrow, . . . and ﬁnally for a triangle.
[Rough draft, version 2007-05-24 21:36]

256
Categorical polynomial functors
Suppose the right adjoint p∗exists. Then p∗preserves all colimits. In
particular it preserves the square (14.1) mapping into B singling out the
triangle t. So we get a pushout diagram
p∗[1]
- p∗[2]
p∗[0]
6
- p∗[1]
6
In other words,
Eϕ
- Et
Eb1
6
- Eψ
6
Claim (WHICH CURRENTLY I DON’T UNDERSTAND WHY IS TRUE)
To say that this is a pushout is equivalent to saying that the natural map
of distributors
Eϕ ⊗Eb1 Eψ →Eγ
is an isomorphism, where γ is the composite ψ ◦ϕ.
This in turn is to say that the Conduché condition holds!
So concerning the claim: by the universal property of the pushout,
there is always a map Eϕ ∐Eb1 Eψ →Et.
Et contains three full subcats: Eϕ and Eψ and Eγ. In fact Et can be
characterised(?) as the smallest one containing these three subcats. So if
we can just show that the pushout does contain Eγ too, then we should
be done. . . But indeed, every arrow in Eγ is a lift of γ so to say that every
arrow in Eγ arises as composite of arrows from Eϕ and Eψ then we are
done, partly. In conclusion, if Et = Eϕ ∐Eψ, then at least it shows that
every arrow over γ can be factored.
14.2.6 Concrete description of p∗X. Here is the description of the cate-
explicit-construction
gory p∗X, which is a category over B. The objects over b ∈B are diagrams
X
Eb
s
-
⊂E
?
[Rough draft, version 2007-05-24 21:36]

14.2 Conduché ﬁbrations
257
(i.e., E-arrows Eb →X). So an object is a pair (b, s), where b ∈B and where
s is as described.
The arrows are diagrams
X
Eϕ
Φ
-
⊂E
?
The source of such a Φ are given by restricting to Eb0 ⊂Eϕ, and the target
is given by restricting to Eb1 ⊂Eϕ.
So we can describe the arrows of p∗X in this more general manner
(without favouring a particular b): the arrows are diagrams
X
[1] ×[0] E
-
s
-
E
?
[1]
?
- B
?
Let us describe composition of arrows in p∗X. Given two composable
arrows (ϕ, Φ) and (ψ, Ψ) lying over our ﬁxed composable pair ψ ◦ϕ = γ
in B. Then we have a diagram
Eϕ
- Et
≃Eϕ ⊔Eb1 Eψ
Eb1
6
- Eψ
6
It is the Conduché condition that guarantees the isomorphism Et ≃Eϕ ⊔Eb1
Eψ. Note that Eγ sits inside Et. . .
Now by the universal property of the pushout, our maps Φ : Eϕ →X
and Ψ : Eψ →X glue to a map on Eϕ ∐Ex1 Eψ = Et (still a E-map). Finally
restrict this map Et →X to Eγ ⊂Et.
Checking associativity of this composition law is straightforward an
unenlightening, and describing the identity arrows is also trivial.
[Rough draft, version 2007-05-24 21:36]

258
Categorical polynomial functors
14.2.7 In terms of distributors. A category D with a functor to I = [1] can
be interpreted as a distributor. Namely, it contains two full subcategories
D0 and D1. (The category D0 is a sieve in D, which means that if an arrow
f→is in D0 then any composition →
f→is in D0 too.) There may be arrows
from an object in D0 to an object in D1, but no arrows in the other direction.
These arrows express a correspondence, which is equivalent to giving
a distributor Dop
0 × D1 →Set. We also call this distributor D.
Recall what is the tensor product of distributors: given D : Aop × B →
Set and E : Bop × C →Set, then we can form D ⊗B E. It is the set of pairs
where f goes from A to B, and g goes from B →C, and we identify f ⊗ug
with f u ⊗g.
The Conduché condition states precisely that for every triangle γ =
ψ ◦ϕ in B, the natural map Eϕ ⊗Eb1 Eψ →Eγ is an isomorphism.
If a category X has a functor to [2], then there are deﬁned three distrib-
utors D01, D12, and D02, which are the pullback of X along the face maps
inclusions [1] ֒→[2]. And then there is a composition law D01 ⊗D1 D12 →
D02. (Under the conditions or always?) To say that the square image of
14.1 is a pushout is equivalent to saying that this natural map is an iso-
morphism.
14.2.8 More advanced proof of the Theorem. This proof identiﬁes the
Conduché maps as generators for the localisation sSet →Cat.
We ﬁx a functor p : E →B. We want to ﬁnd the conditions under
which p∗has a right adjoint.
Let N : Cat →sSet be the nerve functor. Consider the square
Cat/E 
p∗
Cat/B
sSet/NE
N
?

(Np)∗
sSet/NB
N
?
Now the bottom map always has a right adjoint because we are talking
slices of a presheaf category. Now we cannot use N to compare this to fact
to a statement about p∗because N is not cocontinuous. Instead we shall
use the left adjoint to N, the fundamental category functor
τ1 : sSet →Cat
[Rough draft, version 2007-05-24 21:36]

14.2 Conduché ﬁbrations
259
Since this is a left adjoint it is cocontinuous. So now the relevant diagram
is
Cat/E 
p∗
Cat/B
sSet/NE
τ1
6

(Np)∗
sSet/NB
τ1
6
(14.2)
tau-square
Deﬁnition. An arrow in sSet is called a quasi-isomorphism if its image in
Cat under τ1 is an isomorphism.
Now we shall invoke some general theory about localisation of cocom-
plete categories (note that both Cat, sSet, and their slices are cocomplete).
Let F : C →D be a cocontinuous functor between cocomplete cate-
gories. Let Σ denote the class of arrows in C which are sent to isomor-
phisms in D. Then there is a cocomplete category Σ−1C with a cocontin-
uous functor C →Σ−1C such that for every functor that inverts Σ factors
uniquely through Σ−1C .
Recall that for an arrow f : A →B, an object X is (strictly) orthogonal
to f, written f⊥X, if
A
- X
B
f
?
∃!
-
Now let C ′ ⊂C denote the full subcategory whose objects are the X or-
thogonal to all f ∈Σ.
14.2.9 Theorem. (See Borceux, Thm 5.4.8 or something EXACT REFERENCE?)
The category C ′ is a reﬂexive subcategory in C , and the reﬂection r : C →C ′ is
the localisation with respect to Σ.
That is, for every C →D (cocontinuous between cocomplete categories)
which inverts the arrows in Σ, there is a factorisation
C
- D
C ′
∃!
-
-
[Rough draft, version 2007-05-24 21:36]

260
Categorical polynomial functors
So much for the general theory. In our case, τ1 : sSet →Cat is the
localisation and the reﬂector is N. Sigma is the set of map
Ik →[k]
where the simplicial set Ik is the graph consisting of k arrows in a sequence
(but without their composites), while [k] is the simplicial set ∆[k], the k-
simplex, which is a category. Another way of describing Ik is as the co-
product in sSet of intervals. The maps Ik ⊂[k] describe the principal
edges of a simplex.
Claim: (Np)∗preserves quasi-isomorphisms provided the Conduché
condition holds.
If this is the case, both ways around in the diagram (14.2) invert quasi-
isomorphisms.
Now consider the maps
(Np)∗X - N(p∗τ1X)
X
ε
- Nτ1X
NE
Np
-

-
B

-
The map ε is a quasi-isomorphism (check this!). Hence the map (Np)∗X −→
N(p∗τ1X) is an isomorphism. This shows that at least the Diagram (14.2)
commutes up to isomorphism.
It remains to show that p∗preserves colimits. Consider some colimit
(Si)i∈I →S in Cat/B, and consider also the colimit (NSi)i∈I →T in
sSet/NB. Note that this is not the image of the ﬁrst under N, because
N does not preserve colimits. However, taking τ1 on this second colimit
reproduces the ﬁrst. So going the two ways around in Diagram (14.2) we
get some diagram which is a colimit by going the lower way around, and
which is p∗of the original colimit the upper way around. Hence p∗pre-
serves the colimit. End of proof.
14.2.10 Remark. One could ask other questions: for example given any
functor p : E →B ask whether the pseudo-pullback has a right adjoint.
And the notion of right adjoint might be weakened as follows: instead of
requiring a bijection of hom sets,
HomE(p∗Y, X) ≃HomB(Y, p∗X),
[Rough draft, version 2007-05-24 21:36]

14.3 Polynomial functors in Cat
261
see if we cannot deﬁne a condition where instead some hom cats should
be equivalent . . .
14.3
Polynomial functors in Cat
Deﬁnition. A polynomial functor Cat/I →Cat/J is one of the form
Cat/I
s∗- Cat/E
p∗- Cat/B
t!- Cat/J
for a diagram
E
p - B
I
s

J
t
-
where p is a Conduché ﬁbration.
A polynomial functor in one variable is just the special case where I
and J are the terminal category. In other words, it is a functor of the form
Cat
−→
Cat
C
7−→
p∗(C ×B E)
14.3.1 Beck-Chevalley conditions. The Beck-Chevalley conditions hold
for the adjunction p! ⊣p∗, and consequently it holds also for the adjunc-
tion p∗⊣p∗whenever this last functor exists.
The Beck-Chevalley condition ensures that most things can be checked
ﬁbrewise. Some squares to draw:
Cat/Eb
- Cat/E
Cat
6
- Cat/B
6
E
p
- E
Eb
6
- 1
6
[Rough draft, version 2007-05-24 21:36]

262
Categorical polynomial functors
14.3.2 Lemma. The pullback of a Conduché ﬁbration is again a Conduché ﬁbra-
tion.
The trickier point is whether there is a distributivity law.
But this
should be true.
14.3.3 Proposition. The distributive law holds in the same form as in 8.2.11.
The ﬁbrewise argument allows us to reduce to the case C = 1 again.
Then B →1 is a discrete category. Then all the ﬁbre arguments should
work again.
14.3.4 More abstract approach. In fact all this may work in a more abstract
setting. Let C be a category with pullbacks. Deﬁne a notion of proper
map: a map ϕ is proper if pullback along it has a right adjoint and if the
same if true for every pullback of ϕ. Then it should be possible to deduce
Beck-Chevalley and distributivity.
The terminology ‘proper map’ is perhaps not necessary. Perhaps we
should just use the word exponentiable.
One possible way to argue is this: consider the Yoneda embedding
y : C →b
C . In b
C everything works. If we can just show that p∗is sent to
∗. (in analogy with the fact that y preserves exponentiation: it preserves
all those exponentiation that exist. In the same way, it should be true that
y preserves all those lowerstars that happen to exist. . .
one reason this works is that the sum map is just composition. In other
contexts it might be something more complicated, and then it might not
work. Suppose for example we work in the category of discrete ﬁbrations.
Then the left adjoint might involve some factorisation (every functor fac-
tors as a ﬁnal map followed by a discrete ﬁbration), and the lowershriek
would be this last part only. In such cases where the sum map is not pure
composition we might get trouble Another example: sheaves: lowershriek
of a sheaf is not just composition: we need to sheaﬁfy afterwards!
14.4
The family functor
14.4.1 Finite sets and bijections. Let B denote the category of ﬁnite sets
Bij
and bijections, let E denote the category of pointed ﬁnite sets and bijections
[Rough draft, version 2007-05-24 21:36]

14.4 The family functor
263
preserving the basepoint, and denote the forgetful functor
p : E →B.
Given an arrow ϕ : I →J (i.e., a bijection) and a marked point e in J
(i.e., a point in the ﬁbre EJ, then there is a unique way of picking a marked
point in I such that ϕ becomes a mark-preserving map—indeed since ϕ
is a bijection just take the inverse image of e. This shows that arrows in
B have unique lifts to E, which is one characterisation of being a discrete
ﬁbration, and hence a Conduché ﬁbration.
Hence p∗exists and there is deﬁned a polynomial functor
Cat
−→
Cat
C
7→
p∗(C ×B E)
which we shall now describe in detail. The category F(C) := p∗(C ×B E)
will be the category of families in C.
14.4.2 Objects of F(C). According to our description in 14.2.6, the objects
in F(C) lying over an object I ∈B are diagrams like
C ×B E
EI
s
-
⊂E
?
so it is just any set map EI →C. Note that the ﬁbre EI is canonically
identiﬁed with I itself, so the objects of F over I are maps
ι : I →C.
We also think of such a map as a family (Ci)i∈I.
14.4.3 Arrows of F(C). To describe the arrows lying over some bijection
ϕ : I ∼
→J, we ﬁrst describe the full subcategory Eϕ ⊂E. The object set of
Eϕ is the disjoint union of EI and EJ. In other words,
obj(Eϕ) = I ⊔J.
The (non-identity) arrows in Eϕ must lie over ϕ: this means that they are
arrows in E going from an object of EI to an object in EJ. Now the objects
[Rough draft, version 2007-05-24 21:36]

264
Categorical polynomial functors
in EI and EJ are just the elements in I and J, and the arrows from an object
in EI to an object in EJ lying over ϕ is just to give a pair (i, j) ∈I × J such
that ϕ(i) = j. In other words, the set of all the arrows over ϕ are just the
correspondence between the elements in I and J expressed by the bijection
ϕ. (This is to say that for a given ϕ : I →J and given an object in the ﬁbre
over J, there is a unique overlying arrow—this is just the formulation of
E →B being a discrete ﬁbration.)
Now an arrow in F(C) lying over ϕ is a diagram
C ×B E
Eϕ
Φ
-
⊂E
?
which amounts to giving ι : I →C and : J →C and a family of arrows
Φi : ι(i) →(ϕ(i))
14.4.4 The category of families in C. In summary, F(C) is the category of
families of objects in C: The objects are functors ι : I →C where I is a ﬁnite
set, and where an arrow from (I, ι) to (J, ) is a pair (ϕ, Φ) consisting of a
bijection ϕ : I ∼
→J and a family Φ = (Φi)i∈I of arrows Φi : ι(i) →(ϕ(i)).
The category F(C) can also be described as the free symmetric monoidal
category on C . THIS OUGHT TO BE EXPLAINED HERE.
14.4.5 Trees. Now the category of trees T is the least ﬁxpoint for the func-
groupoid-of-trees
tor
Poly(1)
−→
Poly(1)
Q
7−→
Id + P ◦Q
One checks that T is a groupoid.
!!!! F : Cat →(Cat, +, 0) the free-ﬁnite-sums functor, which is left
adjoint to the forgetful functor.!!!!!
Another construction, more like the free algebra construction, without
the need of a category of polynomial functors: let F be an endofunctor
of Cat. An F-category is a category C equipped with a functor F(C ) →
C . The forgetful functor from F-categories to categories has a left adjoint
[Rough draft, version 2007-05-24 21:36]

14.5 Polynomial functors in terms on presheaf categories
265
(provided F is sufﬁciently nice, e.g. it should certainly be enough that it is
a polynomial functor whose product part is given by a discrete ﬁbration).
Let T : Cat →Cat denote the corresponding monad. Then T(1) is the
groupoid of (non-planar) trees.
MANY THINGS TO INVESTIGATE: HOW ABOUT WEAK ENDO-
FUNCTORS? WEAK F-CATEGORIES?
The groupoid of trees is not rigid. I.e. between two trees there can be
many different isomorphisms.
Now if we pass to P-trees for some polynomial endofunctor (monad?)
then we do get a rigid groupoid of P-trees. The decoration involves spec-
iﬁed bijections between the set of children of each node and some ﬁxed
set!
The category of (non-planar) constellations is the least ﬁxpoint for the
functor
Cat/T1
−→
Cat/T1
X
7−→
1 + F(X)
where F denotes the free symmetric operad on a categorical collection X.
MANY QUESTIONS TO ANSWER HERE: I don’t think there is presently
a truly rigorous treatment of ﬁxed point for endo-functors of Cat. If F :
Cat →Cat is an endo-functor, how do we deﬁne F-Cat, the category of
F-objects? A morphism of F-objects should involve an (invertible) 2-cell.
Suppose that two endo-functors F : Cat →Cat and G : Cat →Cat are
connected by a natural transformation a : F →G which is an equivalence
(I mean that the functor aX : F(X) →G(X) is an equivalence of categories
for every X). In this case, can we show that the least ﬁxed point of F is
equivalent to the least ﬁxed point of G?.
14.5
Polynomial functors in terms on presheaf
categories
14.6
Final functors and discrete ﬁbrations
[Rough draft, version 2007-05-24 21:36]

266
Categorical polynomial functors
[Rough draft, version 2007-05-24 21:36]

Chapter 15
Generalised species???
[Rough draft, version 2007-05-24 21:36]


A Appendices
269
A
Appendices
Some pullback formulae.
ck-rightcancel
A.1 Lemma. Given a diagram
·
- ·
·
?
- ·
?
·
?
- ·
?
in which the big square and the bottom square are pullback squares, the top one is
too.
[Rough draft, version 2007-05-24 21:36]

270
Generalised species???
[Rough draft, version 2007-05-24 21:36]

Bibliography
Abbott
[1] MICHAEL
ABBOTT.
Categories
of
Containers.
PhD
the-
sis,
University
of
Leicester,
2003.
Available
from
www.mcs.le.ac.uk/~ma139/docs/thesis.pdf.
t-al:fossacs03
[2] MICHAEL ABBOTT, THORSTEN ALTENKIRCH, and NEIL GHANI. Cat-
egories of Containers. In Proceedings of Foundations of Software Science
and Computation Structures, 2003.
t-et-al:tlca03
[3] MICHAEL ABBOTT, THORSTEN ALTENKIRCH, NEIL GHANI, and
CONOR MCBRIDE. Derivatives of Containers. In Typed Lambda Calculi
and Applications, TLCA, 2003.
et-al:jpartial
[4] MICHAEL ABBOTT, THORSTEN ALTENKIRCH, NEIL GHANI, and
CONOR MCBRIDE. ∂for Data. Fundamentae Informatica 65 (March
2005), 1 – 28. Special Issue on Typed Lambda Calculi and Applica-
tions 2003.
Awodey:Cat
[5] STEVE AWODEY. Category theory, vol. 49 of Oxford Logic Guides. The
Clarendon Press Oxford University Press, New York, 2006.
Baez:counting
[6] JOHN BAEZ.
The mysteries of counting: Euler characteristic ver-
sus homotopy cardinality. Talk given at the Conference in honour
of Ross Street’s sixtieth birthday: Categories in Algebra, Geometry
and Mathematical Physics, Sydney, July 2005. Slides available from
http://math.ucr.edu/home/baez/counting.
aez-Dolan:9702
[7] JOHN C. BAEZ and JAMES DOLAN. Higher-dimensional algebra. III. n-
categories and the algebra of opetopes. Adv. Math. 135 (1998), 145–206.
ArXiv:q-alg/9702014.
[Rough draft, version 2007-05-24 21:36]

272
BIBLIOGRAPHY
z-Dolan:finset-feynman
[8] JOHN C. BAEZ and JAMES DOLAN.
From ﬁnite sets to Feynman
diagrams.
In B. Engquist and W. Schmid, editors, Mathematics
unlimited—2001 and beyond, pp. 29–50. Springer-Verlag, Berlin, 2001.
ArXiv:math.QA/0004133.
Baez-Lauda
[9] JOHN C. BAEZ and AARON D. LAUDA. Higher-dimensional algebra.
V. 2-groups.
Theory Appl. Categ. 12 (2004), 423–491 (electronic).
ArXiv:math.QA/0307200.
Baez-Schreiber:0511
[10] JOHN C. BAEZ and URS SCHREIBER. Higher Gauge Theory. Preprint,
arXiv:math.DG/0511710.
Barr-Wells
[11] MICHAEL BARR and CHARLES WELLS. Toposes, triples and theories.
No. 12. 2005. Corrected reprint of the 1985 original (Grundlehren der
Mathematischen Wissenschaften, 278, Springer-Verlag.
ergeron-Labelle-Leroux
[12] FRANÇOIS BERGERON, GILBERT LABELLE, and PIERRE LEROUX.
Combinatorial species and tree-like structures, vol. 67 of Encyclopedia
of Mathematics and its Applications. Cambridge University Press,
Cambridge, 1998. Translated from the 1994 French original by Mar-
garet Readdy, With a foreword by Gian-Carlo Rota.
sson-Joyal:Dyer-Lashof
[13] TERRENCE BISSON and ANDRÉ JOYAL. The Dyer-Lashof algebra in bor-
dism (extended abstract). C. R. Math. Rep. Acad. Sci. Canada 17 (1995),
135–140.
Borceux1
[14] FRANCIS BORCEUX. Handbook of categorical algebra. 1: Basic category
theory. Cambridge University Press, Cambridge, 1994.
Carboni-Lack-Walters
[15] AURELIO CARBONI, STEPHEN LACK, and ROBERT F. C. WALTERS.
Introduction to extensive and distributive categories. J. Pure Appl. Alge-
bra 84 (1993), 145–158.
Cohn:Universal
[16] P. M. COHN. Universal algebra. Harper & Row Publishers, New York,
1965.
Conduche’
[17] FRANÇOIS CONDUCHÉ. Au sujet de l’existence d’adjoints à droite aux
foncteurs “image réciproque” dans la catégorie des catégories. C. R. Acad.
Sci. Paris Sér. A-B 275 (1972), A891–A894.
[Rough draft, version 2007-05-24 21:36]

BIBLIOGRAPHY
273
tegorification
[18] LOUIS CRANE and DAVID N. YETTER.
Examples of categoriﬁcation.
Cahiers Topologie Géom. Différentielle Catég. 39 (1998), 3–25.
kind:dieZahlen
[19] RICHARD DEDEKIND.
Was sind und was sollen die Zahlen?
Braun-
schweig, 1888.
Eckmann-Hilton
[20] BENO ECKMANN and PETER J. HILTON. Group-like structures in gen-
eral categories I: multiplication and comultiplication.
Math. Ann. 145
(1962), 227–255.
Elgueta:0408
[21] JOSEP ELGUETA. Representation theory of 2-groups on ﬁnite dimensional
2-vector spaces. Preprint, arXiv:math.CT/0408120.
Elgueta:0406
[22] JOSEP ELGUETA. A strict totally coordinatized version of Kapranov and
Voevodsky’s 2-category 2Vect. Preprint, arXiv:math.CT/0406475.
Gambino-Hyland
[23] NICOLA GAMBINO and MARTIN HYLAND. Wellfounded Trees and De-
pendent Polynomial Functors. In S. Berardi, M. Coppo, and F. Damiani,
editors, TYPES 2003, vol. 3085 of Lecture Notes in Computer Science,
pp. 210–225. Springer Verlag, Heidelberg, 2004.
en:consistency
[24] GERHARD GENTZEN. Die Widerspruchfreiheit der reinen Zahlentheorie.
Math. Ann. 112 (1936), 493–565.
Giraud:mem
[25] JEAN GIRAUD. Méthode de la descente. Bull. Soc. Math. France Mém. 2
(1964). Available from http://www.numdam.org.
Joyal:1981
[26] ANDRÉ JOYAL. Une théorie combinatoire des séries formelles. Adv. in
Math. 42 (1981), 1–82.
rs-analytiques
[27] ANDRÉ JOYAL. Foncteurs analytiques et espèces de structures. In Combi-
natoire énumérative (Montreal, Que., 1985/Quebec, Que., 1985), vol. 1234
of Lecture Notes in Math., pp. 126–159. Springer, Berlin, 1986.
braided-tensor
[28] ANDRÉ JOYAL and ROSS STREET. Braided tensor categories. Adv. Math.
102 (1993), 20–78.
Formerly Macquarie Math. Reports No. 850067
(Dec. 1985) and No. 860081 (Nov. 1986).
oevodsky:2cats
[29] MIKHAIL M. KAPRANOV and VLADIMIR A. VOEVODSKY. 2-categories
and Zamolodchikov tetrahedra equations. In Algebraic groups and their gen-
eralizations: quantum and inﬁnite-dimensional methods (University Park,
[Rough draft, version 2007-05-24 21:36]

274
BIBLIOGRAPHY
PA, 1991), vol. 56 of Proc. Sympos. Pure Math., pp. 177–259. Amer.
Math. Soc., Providence, RI, 1994.
Kelly:clubs92
[30] G. MAX KELLY. On clubs and data-type constructors. In Applications
of categories in computer science (Durham, 1991), vol. 177 of London
Math. Soc. Lecture Note Ser., pp. 163–190. Cambridge Univ. Press,
Cambridge, 1992.
zoom
[31] JOACHIM KOCK, ANDRÉ JOYAL, MICHAEL BATANIN, and JEAN-
FRANÇOIS MASCARI. Polynomial functors and opetopes. Preprint, 2004.
Lambek:fixpoint
[32] JOACHIM LAMBEK. A ﬁxpoint theorem for complete categories. Math. Z.
103 (1968), 151–161.
Lawvere-Rosebrugh
[33] F. WILLIAM LAWVERE and ROBERT ROSEBRUGH. Sets for mathematics.
Cambridge University Press, Cambridge, 2003.
Leinster:0305049
[34] TOM LEINSTER. Higher Operads, Higher Categories. London Math. Soc.
Lecture Note Series. Cambridge University Press, Cambridge, 2004.
ArXiv:math.CT/0305049.
MacLane:categories
[35] SAUNDERS MAC LANE. Categories for the working mathematician, sec-
ond edition. No. 5 in Graduate Texts in Mathematics. Springer-Verlag,
New York, 1998.
Manes-Arbib:1986
[36] ERNEST G. MANES and MICHAEL A. ARBIB.
Algebraic approaches
to program semantics. Texts and Monographs in Computer Science.
Springer-Verlag, New York, 1986. AKM Series in Theoretical Com-
puter Science.
k-Palmgren:Wellfounded
[37] IEKE MOERDIJK and ERIK PALMGREN. Wellfounded trees in categories.
Annals of Pure and Applied Logic 104 (2000), 189–218.
Moerdijk-Weiss:0701293
[38] IEKE MOERDIJK and ITTAY WEISS.
Dendroidal sets.
Preprint,
arXiv:math/0701293.
Moerdijk-Weiss:0701295
[39] IEKE MOERDIJK and ITTAY WEISS. On inner Kan complexes in the cate-
gory of dendroidal sets. Preprint, arXiv:math/0701295.
Peano:arithmetic
[40] GIUSEPPE PEANO. Arithmetices principia, nova methodo exposita. Au-
gustae Taurinorum, Ed. Fratres Bocca, 1889 (1889).
[Rough draft, version 2007-05-24 21:36]

BIBLIOGRAPHY
275
Propp:0203
[41] JAMES PROPP.
Euler measure as generalized cardinality.
Preprint,
arXiv:math.CO/0203289.
Propp:0204
[42] JAMES PROPP. Exponentiation and Euler measure. Algebra Universalis
49 (2003), 459–471. ArXiv:math.CO/0204009, Dedicated to the mem-
ory of Gian-Carlo Rota. (math.CO/0204009).
anuel:negative
[43] STEPHEN H. SCHANUEL. Negative sets have Euler characteristic and di-
mension. In Category theory (Como, 1990), no. 1488 in Lecture Notes in
Math., pp. 379–385. Springer, Berlin, 1991.
Sinh
[44] HOANG XUAN SINH. Gr-catégories. PhD thesis, Université Paris VII,
1975.
Weber:TAC13
[45] MARK WEBER.
Generic morphisms, parametric representations and
weakly Cartesian monads. Theory Appl. Categ. 13 (2004), No. 14, 191–
234 (electronic).
lastpage
[Rough draft, version 2007-05-24 21:36]

