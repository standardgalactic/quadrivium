www.allitebooks.com

For your convenience Apress has placed some of the front 
matter material after the index. Please use the Bookmarks 
and Contents at a Glance links to access them. 
www.allitebooks.com

iv 
 
Contents at a Glance 
Contents .............................................................................................................. v 
About the Authors ............................................................................................... x 
About the Technical Reviewer ........................................................................... xi 
Acknowledgments ............................................................................................ xii 
■Chapter 1: Setting the Stage ............................................................................ 1
■Chapter 2: Hello World ................................................................................... 15
■Chapter 3: What Makes a BlackBerry Application? ....................................... 35
■Chapter 4: User Interface Basics ................................................................... 49
■Chapter 5: Beyond the Basics of User Interfaces .......................................... 75
■Chapter 6: Storing and Searching Data ....................................................... 123
■Chapter 7: Hello Out There! Making a Network-Enabled Application .......... 169
■Chapter 8: Where Am I? Using Location-Based Services ............................ 201
■Chapter 9: Getting Your App Out There: Packaging and Publishing ............ 225
■Chapter 10: Next Steps ................................................................................ 249
Index ............................................................................................................... 253
www.allitebooks.com

 
1 
 
 
 
Chapter 
Setting the Stage 
There has never been a better time to develop applications for BlackBerry devices than right 
now. Since Research In Motion (RIM) launched the first models almost a decade ago, the 
BlackBerry smartphone has gone from relative obscurity to near universal visibility—think 
about how commonplace it has become to see people in airports, hotels, offices, or just 
about anywhere stealing a few minutes to check their e-mail or type replies. The BlackBerry 
software development kit (SDK) has been around since the first devices were released and 
has grown to include an extensive collection of examples and documentation, and a mature 
set of APIs and tools that have opened the door for all kinds of great applications, most of 
which only currently exist in someone’s imagination. And with the maturing of the BlackBerry 
community and the introduction of BlackBerry App World, it’s easier than ever to get your 
application noticed and downloaded by users worldwide. 
In this chapter we’ll talk a bit about the basics of BlackBerry development: development 
environment options (there are a couple), other software and information you need, and 
some things to keep in mind. We’ll also walk through the download and setup of the 
development tools and simulators so you’re all set up to start building applications in the 
next chapter.  
What This Book Is 
This book is a guide to help you get started creating your own BlackBerry applications. 
This book is not about writing web applications for BlackBerry devices or about rapid 
application development (RAD) solutions, such as MDS Studio or the BlackBerry plug-in 
for Microsoft Visual Studio. This is about building professional, polished, native 
applications that take full advantage of the BlackBerry platform.  
By the end of this book, you’ll have built several simple BlackBerry applications, learned 
how to run them on the various BlackBerry simulators, and learned how to package and 
deploy them onto real BlackBerry devices. You’ll learn how a BlackBerry application is 
put together, how to create great-looking user interfaces, how to interact with the user 
(using the keyboard and trackball/trackpad or touch screen, depending on the device), 
how to send and receive data over the wireless network, and more. Combined with the 
1 
www.allitebooks.com

CHAPTER 1:  Setting the Stage 
2 
extensive development resources and examples provided by RIM, you’ll be on your way 
to creating the next killer application for this platform. 
What You Need to Know Before You Can Begin 
To be able to follow along, you should have previous programming experience in a 
modern object-oriented language. This book is not an introduction to object-oriented 
programming or even to the Java language. There are many excellent resources and 
tutorials available on the Internet. 
BlackBerry applications are written in Java Micro Edition (Java ME), formerly called 
J2ME. This is a subset of Java Standard Edition (Java SE) that most Java developers 
work with. If you’re familiar with Java SE or Java Enterprise Edition (Java EE), Java ME 
will be very easy to pick up.  
If you’re familiar with another object-oriented language—especially one with a similar 
syntax, such as C#, C++, or even Objective-C—you should similarly have no problem 
picking things up. C# developers in particular should be able to understand Java ME 
code with little or no effort.  
One of the nice things about Java ME and the BlackBerry from the perspective of a 
beginner is that the API is small compared to desktop or server programming 
environments—you can learn a great deal of it fairly quickly. Of course, this is a 
double-edged sword; there will be times when you wish the API provided some 
functionality that bigger environments do, though the BlackBerry API is getting more 
functionality all the time. 
Setting Up Your Development Environment 
Before you can begin writing applications for BlackBerry you’ll need a few things. First, 
you’ll need a computer running Windows 2000 SP1 or later, Windows XP, Windows 
Vista, or Windows 7. Any desktop or laptop produced in the last few years should be 
sufficient, but as with any software development, the more RAM and CPU speed you 
have, the better your experience will be. Because you will be running an integrated 
development environment (IDE) of your choice (you have two options) and the simulator 
where you test your application, we recommend at least 4GB of RAM and a dual-core 
processor so you will be able to compile and run your BlackBerry application swiftly. 
The first stop for all BlackBerry development tools and other resources is the BlackBerry 
Developer Zone, at www.blackberry.com/developers/ (see Figure 1–1). Here, you’ll find 
free downloads, whitepapers, the developer knowledge base, and the BlackBerry 
Developer Forums. As a BlackBerry developer, you should get to know this site very 
well.  
www.allitebooks.com

CHAPTER 1:  Setting the Stage 
3 
 
Figure 1–1. The BlackBerry Developer Zone 
In addition, in order to download any tools from RIM, you have to log in with a 
BlackBerry developer account. So take this time and sign up for yourself.  
RIM does offer higher-level paid Independent Software Vendor (ISV) programs with 
additional support and other benefits, but you can develop and distribute applications 
with the free account. We recommend this to enterprise developers who have support 
Service Level Agreement (SLA) with clients, because if there is a support issue around a 
certain BlackBerry API, your ISV technical representative will then be able to answer 
your inquiries and/or provide workarounds for your problem. For more information, see 
http://partners.blackberry.com/. 
Installing the Development Environment 
There are two BlackBerry development environments produced by RIM: the BlackBerry 
Java Development Environment (JDE) and the BlackBerry JDE Plug-in for Eclipse. Both 
are very functional and have been used by developers to produce professional 
applications. The JDE has been around longer and is a bit more mature, but almost 
everything possible with the JDE can also be accomplished with the Eclipse plug-in. The 
www.allitebooks.com

CHAPTER 1:  Setting the Stage 
4 
Eclipse plug-in leverages the entire Eclipse development platform, which includes a 
world-class source code editor and a lot of third-party plug-ins. Ultimately, the choice is 
a matter of personal preference. Although we have used JDE since the very beginning 
days of BlackBerry development and it has come a long way, the developer-friendly 
features of Eclipse IDE with the new updates to the BlackBerry JDE Plug-in for Eclipse 
make the latter a natural choice for BlackBerry development. For the rest of this book, 
we’ll be focused on using the Eclipse plug-in.  
Before you start development for BlackBerry, you will need to first decide what 
BlackBerry operating system (OS) version your application will support, which then will 
determine what Eclipse JDE plug-in component pack you will need to build your 
application. Each version of the component pack for the Eclipse plug-in corresponds to 
a major version of the BlackBerry OS. BlackBerry does a good job of keeping its OS 
backward compatible, so something developed for OS 5.0 generally will work the same 
on OS 6.0 and higher. However, you may want to use some features that are only 
available on a later OS. A safe minimum is 5.0, which covers majority of the BlackBerry 
devices on the market and is supported by BlackBerry App World. 
Before installing the BlackBerry development tools, you’ll need to install the Java SE 
JDK from www.oracle.com/technetwork/java/index.html. For most developers, 
downloading Java SE JDK v6.0 is a good choice—it will let you develop for BlackBerry 
Device Software version 4.5 and later, which covers majority of BlackBerry smartphones 
on the market. More specific information is available in the Developer Zone at 
http://na.blackberry.com/eng/developers/javaappdev/javadevenv.jsp. 
Installing the BlackBerry Java Plug-In for Eclipse  
To use Eclipse to develop for BlackBerry, you’ll need to download Eclipse IDE. However, 
to make things simple for you, RIM has bundled Eclipse 3.6 (Helios) with the BlackBerry 
JDE Plug-in with BlackBerry SDK 7.0, which is shown in Figure 1–2. You can download 
the BlackBerry Java Plug-in for Eclipse at http://us.blackberry.com/developers/ 
javaappdev/devtools.jsp. 
www.allitebooks.com

CHAPTER 1:  Setting the Stage 
5 
 
Figure 1–2. Eclipse with the BlackBerry JDE plug-in 
Setup is simply a matter of running the setup executable file.  
Using Other JDE Versions with Eclipse 
Other JDE versions are supported within the same environment with downloadable 
component packs. You can install other component packs for Eclipse from within 
Eclipse itself. Open Eclipse IDE and do the following: 
1. Select Help Menu. 
2. From the menu, select the Install New Software menu item. The Install New 
Software screen will appear. 
3. From the Install New Software screen, click the Add button. 
4. Paste http://www.blackberry.com/go/eclipseUpdate/3.6/java into the location 
text box, give it the name “text box,” and click OK (see Figure 1–3). 
5. Select the BlackBerry Java Plug-in item and at least one BlackBerry Component 
Pack item that you want to work (see Figure 1–4). 
6. Then follow the onscreen instruction to finish installation. You will have to restart 
Eclipse IDE in order for the installation to take effect. 
www.allitebooks.com

CHAPTER 1:  Setting the Stage 
6 
 
Figure 1–3. The Eclipse Install New Software screen, where you specify the location of the BlackBerry update site 
 
Figure 1–4. Select the BlackBerry component pack you want to install. 
www.allitebooks.com

CHAPTER 1:  Setting the Stage 
7 
Downloading Additional Simulators 
In addition to the simulators that are available to you in the BlackBerry Java Plug-in for 
Eclipse, RIM provides many simulators that are very useful for testing how your 
application functions with different screen resolutions or input methods. The simulators 
can be downloaded from the Developer Zone, at 
http://na.blackberry.com/eng/developers/resources/simulators.jsp (see Figure 1–5 
for a sample list). 
 
Figure 1–5. The Simulators download page showing some of the many choices 
Installing Desktop Software 
If you want to load your application onto a BlackBerry device directly from your 
computer (i.e., without having to upload to a web server and download to your device 
over the wireless connection), you’ll need to install the BlackBerry Desktop Manager 
(see Figure 1–6), which includes the device drivers for the BlackBerry. You may already 
have this installed, since it comes on a CD with your device. Alternatively, you can 
download it from www.blackberry.com. You’ll also need this to be able to debug your 
application on a device using your USB cable. 
www.allitebooks.com

CHAPTER 1:  Setting the Stage 
8 
 
Figure 1–6. You can use the BlackBerry Desktop Manager to load applications from your computer to your device. 
Getting Code Signing Keys 
For basic applications, you can compile and run on real BlackBerry devices with no 
further involvement from RIM using the free tools. However, if you want to use certain 
features (such as the BlackBerry persistent store, cryptography APIs, and embeddable 
web browser), or if you want to allow your application to do things like automatically 
start, you’ll need code signing keys from RIM. The code signing keys are only required 
to use controlled APIs from an application running on a device; you can run an 
application on the simulator that uses controlled APIs without having to sign it. 
Since the free code signing keys usually only take a day or two to receive, it’s a good 
idea to get them while you’re setting up your development environment—almost every 
BlackBerry application ends up needing to use at least a few controlled APIs.  
You can find more information and register for the code signing keys at 
http://na.blackberry.com/eng/developers/javaappdev/codekeys.jsp. 
The online application form for signing keys is available at 
https://www.blackberry.com/SignedKeys/. 
When filling in the key request form, remember the PIN you choose. You’ll need it to 
install the keys into your JDE. Because it’s sometimes a point of confusion, it’s worth 
pointing out that your signing key PIN is not related to a BlackBerry device PIN in any 
way. 

CHAPTER 1:  Setting the Stage 
9 
Installing Your Code Signing Keys 
Once you’ve applied for your signing keys, you should receive three e-mails from RIM, 
each containing one of the code signing keys. Each gives access to a different part of 
the API, and you should install all three on the same PC. Follow the steps in this section 
for each of the three keys. 
To install your code signing keys in Eclipse with the BlackBerry JDE plug-in, simply 
import the keys by doing the following: 
1. From Eclipse IDE, select Windows from the menu, and then choose Open 
Perspective ➤ Others. 
2. Select the BlackBerry Application Development perspective. 
NOTE: If you do not use the BlackBerry Application development perspective, you will not see the 
BlackBerry menu in the next step. 
3. Then from the menu, select BlackBerry ➤ Sign ➤ Install New Key. 
You’ll be prompted to create a new public/private key pair (see Figure 1–7).  
Figure 1–7. When installing your first key, you’ll be prompted to create a new key pair. 
Click Yes on this dialog, and you’ll be asked for a private key password to protect your 
key file. Remember this password—you’ll be asked for it every time you want to sign 
your application. You’ll then be asked to generate some random data by moving your 
mouse pointer around (see Figure 1–8). A word of warning: This will seem like more fun 
than it should. 

CHAPTER 1:  Setting the Stage 
10 
 
Figure 1–8. Generating random information for your new key pair—whee! 
After this, you’ll be asked to enter the PIN you provided when you applied for your keys 
and the private key password you just entered (see Figure 1–9). Do this and your key will 
be installed and ready to use. 
 
Figure 1–9. Registering a code signing key with the JDE 
For the next two keys, you’ll already have generated your key pair, so you’ll just have to 
enter the PIN and private key password. 

CHAPTER 1:  Setting the Stage 
11 
Once you’ve created your key pair and installed your three keys, the key information is 
stored in three files: 
sigtool.csk 
sigtool.db 
sigtool.set 
The location of these files is <eclipse_directory>\plugins\net.rim.ejde\vmTools\, 
where <eclipse_directory> is where you installed your Eclipse environment (i.e., 
C:\Eclipse\plugins\net.rim.ejde\vmTools\). 
It’s also a very good idea to keep a backup of these files and your original key files if you 
ever have to rebuild your development environment. 
What’s Different About Developing for BlackBerry 
If you’re familiar with developing for modern desktop PCs or servers, there are many 
things you might not think about before starting to develop for BlackBerry. Of course, 
every platform is different, but there are some things to keep in mind when designing 
and implementing an application for BlackBerry. 
Limited CPU and Memory 
Generally, BlackBerry CPU speed and RAM—as with most mobile devices—lag a few 
years behind average PCs. The latest BlackBerry devices are getting faster, so this isn’t 
as much of a constraint as it was a few years ago. There are lots of reasons for these 
limitations, including prolonging battery life and keeping devices small, but in general, 
it’s good to keep in mind that your processor-intensive desktop application algorithm 
may not run as nicely on a BlackBerry device. Ways around this include redesigning 
your application to let the server, if you have one, do some of the heavy lifting. 
Also, because the BlackBerry OS is multitasking, CPU- or RAM-hungry applications 
running in the background can make things difficult for other applications on the device. 
This is another way of saying, “Play nice with other applications on the device!” 
Java As the Native API 
The Java virtual machine (VM) on the BlackBerry is as close to the hardware as you can 
get. You can’t write a non-Java native application for the platform. This means that 
you’re always in a garbage-collected, bytecode-interpreted environment, and you don’t 
have real-time access to the hardware. 

CHAPTER 1:  Setting the Stage 
12 
Limited Screen Real Estate 
The largest BlackBerry device screen, in terms of number of pixels and physical size, is 
the touch-screen Storm. It measures 3.7 inches and has a 480×800-pixel resolution. 
Most devices have a 3-inch or smaller screen.  
User Input 
The BlackBerry Storm lets the user click anywhere on the screen. Other devices don’t 
have a touch screen, so the user is limited to the trackball (or trackpad on some recent 
device models) and keyboard. The trackball is like a set of up, down, left, and right 
cursor keys—not like a mouse. Your user interface must be designed with this in mind. 
Imagine how difficult it would be to navigate around a modern Windows application (like 
Microsoft Office) using just your cursor keys, and you’ll have an idea of what the 
BlackBerry constraints mean. 
Many Different Devices 
A range of BlackBerry devices is currently being sold and used, and their screen 
resolutions range from 240×260 to 480×360. Physical screen sizes change too.  
Some of the devices have a trackball or optical trackpad along with a keyboard, but a 
couple of models have a touch screen instead. Some have full QWERTY keyboards, 
while others have the BlackBerry SureType keyboard, which has one or two letters per 
key. The BlackBerry Storm can present different types of virtual keyboards depending 
on device orientation and user preferences.  
Processor speed and RAM vary from device to device, as does network speed. And 
some hardware features, such as GPS, are not available on all devices.  
You should be aware of these differences and design your application to work with as 
many devices as possible if you want to reach a significant number of BlackBerry users. 
What’s in This Book 
Here’s a brief overview of the remaining chapters in this book. 
Chapter 2 
In this chapter, you’ll learn how to build a simple BlackBerry application using the 
BlackBerry JDE and the JDE Plug-in for Eclipse. We’ll debug the application using the 
simulator and on a real device. 

CHAPTER 1:  Setting the Stage 
13 
Chapter 3 
This chapter will discuss a number of concepts and topics important to BlackBerry 
applications in general, laying down some groundwork to help you understand the rest 
of the chapters. 
Chapter 4 
In this chapter, you’ll start to explore the user interface API in depth by building an 
application that supports multiple screens and a variety of different user interface 
controls. 
Chapter 5 
We’ll modify the application from Chapter 4 by creating and extending a number of user 
interface components, and you’ll learn how to work with the user interface model and 
create a custom look and feel for your applications. 
Chapter 6 
Next, we’ll move beyond the user interface. You’ll learn how to persistently store data on 
the device between invocations of the application or resets of the device. We’ll also 
explore the BlackBerry file system. 
Chapter 7 
This chapter will explore wireless networking by creating an application that interacts 
with a web service on the Internet. 
Chapter 8 
In Chapter 8, we’ll explore the location-based services support on the BlackBerry 
platform by creating an application that gets location information using the GPS 
hardware on a BlackBerry smartphone and interacts with BlackBerry maps to display 
location information. 
Chapter 9 
In this chapter we’ll discuss how to package and distribute your application, both from 
your own website and through other means. We’ll talk in depth about BlackBerry App 
World and how to leverage its features, and then briefly discuss some third-party 
application stores. 

CHAPTER 1:  Setting the Stage 
14 
Chapter 10 
Chapter 10 will provide a few final bits of information and a list of BlackBerry 
development resources that you can use to help answer your future questions. 
Summary 
In this chapter, we skimmed the surface and covered what you need to start with 
BlackBerry development.  
We started out by listing the different development environments you can setup to write 
BlackBerry code (we recommend using BlackBerry Java Plug-in for Eclipse). We then 
covered where to get more simulator for testing your application, as well as how to 
request code signatures that are required to sign your application before you can load 
your app onto a BlackBerry device. 
Finally, we ended this chapter by summarizing rest of the chapters in this book. Let’s get 
started! 

 
15 
 
 
 
Chapter 
Hello World 
In this chapter, you’ll learn about the basics of BlackBerry application development by 
creating a simple Hello World application with the BlackBerry JDE Plug-in for Eclipse. 
The code will be the same regardless of what IDE you use—in fact, throughout the rest 
of this book, we’ll focus on the code, not the development environment—but the details 
about creating the project, adding classes and resource files, and running and 
debugging will be different. Our application is a simple BlackBerry application with a 
single screen that will display “Hello World.” We’ll walk through creating the workspace 
and project, creating and building out the necessary classes, and compiling and running 
on a simulator. Then we’ll add a few extra bits of polish, including a proper application 
name, version information, and an icon. Finally, you’ll see how to build, sign, and run the 
application on an actual device.  
This is a quick-start chapter, so the goal is to gain basic proficiency with the 
development tools and a bit of understanding of the basics of a BlackBerry application 
without going too deep. You’ll probably have a lot of questions throughout this chapter, 
but the best way to proceed is to just go through step by step—things will become 
clearer as we explore details of application development later on. 
There’s a lot to do here, so let’s get going. 
Creating an Application with the BlackBerry JDE 
Plug-In for Eclipse 
If you have worked with Eclipse in the past on a generic Java project, then creating a 
BlackBerry project will be very similar to what you’ve done with other generic Java 
projects.  
We’ll walk through creating the same Hello World application with the JDE Plug-in for 
Eclipse. Along with the walkthrough, we’ll also provide explanations of the code to give 
you a more complete picture.  
If you haven’t installed the JDE Plug-in for Eclipse, refer to Chapter 1 for instructions 
about where to get it and how to install it. 
2 

CHAPTER 2:  Hello World 
16 
Creating the Project 
With Eclipse, workspace creation is implicit, and the JDE plug-in uses the same concept 
of workspace as Eclipse itself does. When you start Eclipse, you’re asked for a 
workspace location, which can be any directory. Select (or create) an appropriate one 
and click OK, as shown in Figure 2–1. 
 
Figure 2–1. Creating a new workspace in Eclipse 
If this is the first time you’ve opened this workspace, you’ll see Eclipse’s new workspace 
Welcome screen (see Figure 2–2). There are useful things here, but for this tutorial, you 
can close the window. 
 
Figure 2–2. The Eclipse new workspace Welcome page 

CHAPTER 2:  Hello World 
17 
To create a new BlackBerry project, click the File menu, and choose New  BlackBerry 
Project. 
In the New BlackBerry Project dialog, as shown in Figure 2–3, name your project 
HelloWorld, and click Finish. Your Eclipse workspace should contain a single project in 
the Package Explorer on the left-hand side. When expanded, you should see the 
following, as shown in Figure 2–4: 
 src folder: Where all our source files will reside 
 res folder: Where all resource files (i.e., images) will reside 
 JRE System Library: The BlackBerry runtime library containing the 
BlackBerry API (by default, it is OS 7) 
 BlackBerry_App_Descriptor.xml file: A file where you can configure 
your application, including the name of the application and the icon 
your application will use 
 
Figure 2–3. The New BlackBerry Project dialog 
www.allitebooks.com

CHAPTER 2:  Hello World 
18 
 
Figure 2–4. A new BlackBerry project in Eclipse with the application descriptor opened 
By default, two classes, MyApp.java and MyScreen.java, will be created for you under 
the mypackage package. For the sake of the tutorial, delete the package so you can start 
from scratch by right-clicking on the mypackage package and selecting Delete. 
Creating the Application Classes 
Creating class files is just as simple as creating a project. When creating new classes, 
it’s a very good idea to put your classes into packages. As you will see, Eclipse has a 
very easy way of letting you specify the package for your class. 
Creating the Main Application Class 
Right-click the HelloWorld project icon in the Package Explorer, and from the pop-up 
menu, select New  Class. In the dialog, type the following values: 
 Package: com.beginningblackberry 
 Name: HelloWorldApp (you can leave off the .java file extension) 
 Superclass: net.rim.device.api.ui.UiApplication  

CHAPTER 2:  Hello World 
19 
NOTE: A handy shortcut throughout Eclipse, both in the New Java Class dialog and in the code 
editor, is to type part of the class name and then press Ctrl+spacebar to get a list of class 
suggestions. For example, to automatically get the class name 
net.rim.device.api.ui.UiApplication in the Superclass field of the New Java Class 
dialog, type UiApp and press Ctrl+spacebar. Eclipse will look for possible completions in the RIM 
API and in any classes you’ve created in your workspace. This also works for other Java 
constructs, such as method names. 
Under “Which method stubs would you like to create?” make sure the first two check 
boxes, for generating a main method and constructors, are checked (the third box can 
be checked or not—there are no abstract methods in UiApplication, so it won’t make a 
difference). Everything else can be left at the default (see Figure 2–5). 
Figure 2–5. Creating the main application class with Eclipse 

CHAPTER 2:  Hello World 
20 
You’ll get the following source code: 
package com.beginningblackberry; 
 
import net.rim.device.api.ui.UiApplication; 
 
public class HelloWorldApp extends UiApplication { 
 
    public HelloWorldApp() { 
        // TODO Auto-generated constructor stub 
    } 
 
    /** 
     * @param args 
     */ 
    public static void main(String[] args) { 
        // TODO Auto-generated method stub 
 
    } 
 
} 
There are even TODO markers where we have to write our logic. We’ll do that, but first, 
let’s understand what is on our screen. 
You just created the main application class’ its job is to do three things:  
 Create an instance of the application 
 Create the main screen and push it onto the display stack 
 Start the event dispatch thread 
This is generally the pattern you’ll follow for all your applications, unless you need to do 
something like automatically start when the BlackBerry device boots. 
Subclassing the UiApplication Class 
All applications that display a user interface (screens, menus, etc.) must subclass 
net.rim.device.api.ui.UiApplication. As we created the HelloWorldApp class, we 
specified the superclass for our main class to be UiApplication.  
Creating the Main Screen Class 
Click New  Class again (or right-click the package in the tree view and select New  
Class, and you won’t have to reenter the package name). Fill in the following values: 
 Package: com.beginningblackberry 
 Name: HelloWorldMainScreen 
 Superclass: net.rim.device.api.ui.container.MainScreen (or type 
MainS, and press Ctrl+spacebar) 

CHAPTER 2:  Hello World 
21 
Leave all other values at their defaults, and click Finish to create the following source 
code: 
package com.beginningblackberry; 
 
import net.rim.device.api.ui.container.MainScreen; 
 
public class HelloWorldMainScreen extends MainScreen { 
 
} 
Filling In the Hello World Classes 
Next, we flip back to HelloWorldApp, our main class. We’ll fill in the constructor of 
HelloWorldApp. This will create the main screen and push it onto the display stack: 
class HelloWorldApp extends UiApplication { 
    HelloWorldApp() {     
        HelloWorldMainScreen mainScreen = new HelloWorldMainScreen(); 
        pushScreen(mainScreen); 
    } 
} 
Finally, we need to complete the main method. This will be familiar to you if you’re a Java 
SE, .NET, or C developer, but it is different from the Java ME/MIDP way of doing things. 
The main method acts as the entry point for our application and always has the same 
signature. You should only have one main method per application. The main method will 
create an instance of our application and start the event dispatcher, which is the 
mechanism that does all the drawing to the screen, and listens for all user interaction for 
our application. 
class HelloWorldApp extends UiApplication { 
   … 
    public static void main(String[] args) { 
        HelloWorldApp app = new HelloWorldApp(); 
        app.enterEventDispatcher(); 
    } 
} 
The enterEventDispatcher method will never return as long as the application is 
running. Essentially, the thread that entered the main application becomes the event 
dispatch thread. We’ll explore this in greater depth later, but for now, just remember that 
the method won’t return during the application’s normal life cycle. 
Coding Up the Main Screen Classes 
At this point, we need to add some GUI components to our main screen class with the 
following code for HelloWorldMainScreen.java: 
public class HelloWorldMainScreen extends MainScreen { 
    public HelloWorldMainScreen() { 
        net.rim.device.api.ui.component.LabelField labelField = new 
net.rim.device.api.ui.component.LabelField("Hello World"); 

CHAPTER 2:  Hello World 
22 
        add(labelField); 
    } 
} 
 
Note that we subclass MainScreen instead of Screen because MainScreen gives us a 
couple of things automatically—namely a basic layout manager (to position our UI 
controls on the screen) and a default menu. Later, we’ll want to handle some of that 
functionality ourselves, but for this application, the default behavior of MainScreen is just 
what we want. 
Basic GUI Fields Explained 
We’ll deal with the user interface more in-depth later, but for now, here’s a brief 
overview of how things work, so you’re not walking totally blindfolded. 
The BlackBerry User Interface API follows a fields/layout managers/screens model: 
fields (UI controls such as buttons and text boxes) are contained within layout 
managers, which arrange and draw the fields in specific positions. The managers 
themselves are contained within other managers, and ultimately a Screen class, which 
represents the visible display on the BlackBerry. If you’ve used Java’s Abstract Window 
Toolkit (AWT), Swing, Windows Forms, or any number of other UI toolkits, these 
concepts will be familiar to you. In fact, if you’re an experienced Swing user, you’ll find 
things very familiar.  
For now, we’ll gloss over some of the details, but basically, a MainScreen instance 
contains a single VerticalFieldManager instance, which arranges all fields that it 
contains, one below the other, in the order that they’re added.  
The BlackBerry API contains a useful variety of fields and managers already. For Hello 
World, we’ll just need one: the LabelField, which displays (as you might expect) a text 
label. If you’re interested in exploring a bit more, you can find most of the built-in fields 
in the net.rim.device.api.ui.component package and the built-in layout managers in 
net.rim.device.api.ui.container. 
Now that the application’s finished, let’s take a look at it in action in the simulator. 
Running the Simulator 
The application is automatically built and deployed when we launch the simulator (in 
fact, with Eclipse, the Java code is compiled whenever you make any change, which 
makes spotting errors easy). Running the simulator involves an extra step or two, 
because you have to create a debug configuration. The advantage of this is that you can 
create multiple device configurations for different simulators and quickly select 
whichever one you need. 
Click the arrow next to the debug icon on the Eclipse toolbar, and select Debug 
Configurations, as shown in Figure 2–6. 

CHAPTER 2:  Hello World 
23 
 
Figure 2–6. The Eclipse Debug Configurations drop-down 
The Debug Configurations dialog (see Figure 2–7) lets you set up different 
configurations, which may be different simulators or actual devices. Each configuration 
can have different debug parameters, and as you develop applications, you’ll likely end 
up with a few different configurations for debugging different OS versions, screen sizes, 
and so on. Feel free to explore these options at any time.  
For now, select the BlackBerry Simulator icon on the left side, and click the New button 
on the toolbar in the dialog window that’s shown in Figure 2–7.  
 
Figure 2–7. Setting up a simulator debug configuration with the Eclipse plug-in 
3

CHAPTER 2:  Hello World 
24 
We will need to specify which BlackBerry project we want the simulator to launch. On 
the Project tab shown in Figure 2–8, check the newly created HelloWorld project. As for 
the rest of the other tabs, keep all the defaults. Then click the Debug button at the 
bottom of the dialog. The simulator will launch with your application deployed. From this 
point on, you can access your debug configuration directly from the Debug drop-down 
menu on the main Eclipse toolbar by clicking the downward-facing arrow next to the 
debug icon. 
 
Figure 2–8. The default values for a new debug configuration 
After you click the Debug button, the simulator will start up. When it is finished, you 
will see your HelloWorld app on the BlackBerry simulator home screen, as shown in 
Figure 2–9. 

CHAPTER 2:  Hello World 
25 
 
Figure 2–9. Launching the HelloWorld app in the simulator 
When the simulator launches, the HelloWorld app will not start up on its own; you will 
need to launch it manually. Using your mouse, click the icon on the screen to launch 
the app. You can use the arrow keys to navigate and highlight the HelloWorld app, and 
press Enter to launch it (this is useful for older, non–touch screen simulators) (see 
Figure 2–10). 
 
Figure 2–10. The HelloWorld app shown in the simulator 
Using Breakpoints and the Debug Perspective 
A breakpoint can be set for a line from the Run menu using Toggle Breakpoint 
(Ctrl+Shift+B). 
A breakpoint will cause your application to pause and open the debug view when that 
line is reached. From that point, you can step through your code line by line to look at 
the values of variables, the call stack, and other information. 
Let’s try this with Hello World now. Open HelloWorldMainScreen.java in the editor and 
move the cursor to the first line in the constructor, as shown in Figure 2–11. 

CHAPTER 2:  Hello World 
26 
 
Figure 2–11. A breakpoint is indicated by the circle to the left of the LabelField initialization. 
Click the Debug button to run the HelloWorld app, and when the application stops at a 
breakpoint, you’ll be prompted to show the Eclipse Debug perspective (see Figure 2–12). 
 
Figure 2–12. The Eclipse Debug perspective, stopped at a breakpoint 
In the top-right panel is a list of variables that are currently in scope. If we step to the 
next line (using F6 or Run  Step Over), labelField will appear in that list; you can then 
inspect and view the value and content of labelField. 

CHAPTER 2:  Hello World 
27 
Using the Profiler 
The JDE plug-in includes several useful profiler and memory views that you can use to 
optimize and analyze your application. While you probably won’t need these for the 
HelloWorld application, they will certainly be handy as the complexity of your 
applications grows. 
While at a debug point, go to the Window menu and click Show View  BlackBerry 
Profiler View (see Figure 2–13). This will open up the Profiler view. At the top right of the 
Profiler View tab, you can click the “reload data” button to see profiler details, as shown 
in Figure 2–14.  
 
Figure 2–13. Getting to the BlackBerry Profiler view 
There are two other views that can further help you profile your application: BlackBerry 
Memory view and BlackBerry Object view, both of which can launched similarly to 
BlackBerry Profiler view. 
www.allitebooks.com

CHAPTER 2:  Hello World 
28 
 
Figure 2–14. BlackBerry Profiler view, showing profiling information 
Building with Different JDE Versions 
Building with different versions of the JDE using the JDE plug-in can accomplished by 
changing your BlackBerry JRE library configuration within the Java build path. By 
default, the JDE plug-in comes with a single version of the JDE; you must download 
others as outlined in Chapter 1.  
To compile your BlackBerry project using another version of the BlackBerry SDK, follow 
these steps: 
1. Highlight your project, click the Project menu item, and select Properties. 
2. Select Java Build Path from the navigation box on the left. 
3. Click the Library tab and remove the current JDE version if it exists. 
4. Click the Add Library button, and the Add Library dialog will appear. 
5. From the Add Library dialog, select JRE System Library, and the JRE Library 
dialog will appear. 

CHAPTER 2:  Hello World 
29 
6. Click the Alternate JRE radio button, and select a BlackBerry JRE from the drop-
down list, as shown Figure 2–15. 
7. Click the Finish button. 
At this point, your BlackBerry project will rebuild. This process is similar to 
switching to building your project with Java 1.5 instead of Java 1.6. 
Figure 2–15. Changing JDE versions in Eclipse 
Packaging and Signing Your Application 
The HelloWorld application is not the most exciting, certainly, but it’s a real, fully 
functional application. It has a menu with a Close menu item (you can open the menu by 
clicking the BlackBerry key); you can start and exit it, and with a tiny bit of work, you’ll 
be able to put it onto a real device. Typically, if you use signature-required APIs during 
the course of your development, you will need to sign the application before installing it 
on a real BlackBerry smartphone.  
The Hello World application is simple enough that you don’t need to sign it to run on a 
device, but it’s a good idea to get used to signing your applications for when you will 
need to do so. If you don’t have your code signing keys yet, you can skip the rest of this 
section.  
To package your project and sign the binary, click the BlackBerry menu item and choose 
Package  Project(s), as shown in Figure 2–16. 

CHAPTER 2:  Hello World 
30 
 
Figure 2–16. Invoke the code signing process so you can load your app onto a real BlackBerry smartphone. 
You can also invoke the signing project separately. To do so, click the BlackBerry menu 
item and choose Sign  Sign with Signature Tool. 
Debugging on a Device 
The JDE plug-in allows you to debug code on a real device. This requires the creation of 
a new debug configuration. From the Debug toolbar menu, select Debug Configurations, 
and create a new BlackBerry device configuration by highlighting that icon and clicking 
the New button, as shown in Figure 2–17. 

CHAPTER 2:  Hello World 
31 
 
Figure 2–17. Setting up on-device debugging using the Eclipse plug-in 
Polishing the Application 
Now that we’ve created and run our first application in the Eclipse , we’ll finish off by 
adding a few bits of polish: the application icon and a slightly friendlier name. 
Setting the Title in the BlackBerry Application Descriptor  
The application title and version are configured through the BlackBerry application 
descriptor file (BlackBerry_App_Descriptor.xml), which is located within your project, as 
shown in Figure 2–18. If you don’t specify an application title, the BlackBerry device will 
use your project name as the title of the application on the home screen. In our case, 
we’ll add a space between Hello and World and an exclamation point to make it more 
exciting, so type Hello World! in the Title field. 

CHAPTER 2:  Hello World 
32 
 
Figure 2–18. The BlackBerry application descriptor file for the HelloWorld project 
Creating an Icon 
A BlackBerry icon should be a PNG image. Because there are different screen 
resolutions, the image size will depend on the devices you want to support, though 
48×48 pixels is reasonable for most devices (many older ones will scale it down). For 
more information about ideal icon sizes for different devices, you can refer to the 
BlackBerry UI Guidelines. The easiest way to find them is to search the BlackBerry 
Developer Zone (see Chapter 1) for “UI Guidelines.” By default, the BlackBerry JDE 
Eclipse plug-in creates a default icon.png file in the /res/img/ folder, and it is 
automatically set for you in the BlackBerry application descriptor. We have prepared 
another more colorful icon available for you to use, which you can download from the 
Apress website. 
To change the icon, simply click the Add button at the bottom left of the BlackBerry 
application descriptor file, and browse to the icon.png file in the /res/img/ folder. You 
can add another icon as a rollover icon to make your icon more dynamic. You can make 
a rollover icon by checking the Rollover box next to the image. 

CHAPTER 2:  Hello World 
33 
Seeing It All in Action 
Go ahead and rerun the simulator again. Our fancy new icon and more user-friendly 
name will be displayed on the home screen, just like in Figure 2–19. 
 
Figure 2–19. The shiny new Hello World! name and icon 
Summary 
Congratulations! You’ve successfully built your first BlackBerry application. You’ve 
learned how to run and debug it in the simulator and how to load and debug it on a real 
BlackBerry device. That’s a good start, but obviously, we haven’t even scratched the 
surface of the rich BlackBerry API, so there’s still a lot to learn. In the next chapter, we’ll 
briefly discuss and consolidate some of the concepts that you have learned here, and 
set the stage for a deeper exploration of the BlackBerry API. 

 
35 
 
 
 
Chapter 
What Makes a BlackBerry 
Application? 
You should now be familiar with the basics of building a BlackBerry application using 
the JDE Plug-in for Eclipse. Before really diving into what the BlackBerry API can do, 
we’ll digress briefly to discuss a few concepts that apply to BlackBerry application 
development. If you’re eager to get coding, you can skip to the next chapter, but we 
recommend you at least skim over this one first, so you know what’s discussed here 
and can refer to it later as necessary. We’ll cover some fundamental things that will be 
used heavily in the next couple of chapters, including the user interface threading model 
and the BlackBerry API Javadocs. We’ll also cover a few things that are useful to know 
in many types of applications, such as application life cycle, foreground and background 
applications, and the different types of BlackBerry projects you can create using the 
development environment. 
Javadocs 
The BlackBerry development environment comes with API documentation in the 
Javadoc format (see Figure 3–1). Javadocs should be familiar to Java developers; 
basically, they form a set of HTML files for each class in the API, detailing all the 
methods and other properties of each class. You’ll find yourself referring to the 
Javadocs frequently, so it’s good to know where to find them. They’re also a great way 
to explore the API and get an idea of what’s possible. 
3 

CHAPTER 3:  What Makes a BlackBerry Application? 
36 
 
Figure 3–1. The BlackBerry API Javadocs 
With the JDE Plug-in for Eclipse, the Javadocs are located on the file system under the 
Eclipse installation directory. For example, the 7.0 component pack is located here: 
eclipse\plugins\net.rim.ejde.componentpack7.0.0_7.0.0.6\components\docs\api\ind
ex.html. 
You can also see the Javadoc for any class or method in the Eclipse editor by 
hovering the mouse pointer over the class or method name for a few seconds, as 
shown in Figure 3–2. 
 
Figure 3–2. Viewing the Javadoc for the MainScreen class in Eclipse by hovering the mouse pointer 

CHAPTER 3:  What Makes a BlackBerry Application? 
37 
The BlackBerry Application Life Cycle 
BlackBerry applications behave very much like ordinary desktop applications. If you’ve 
had experience with C, C++, or Java on the desktop, some of the ideas in the previous 
chapter probably seemed very familiar to you. For example, the main method for a 
BlackBerry application is identical to the main method for a Java SE application (which is 
very similar to C’s).  
While there are exceptions for specific needs, almost all BlackBerry applications will 
follow the same life cycle. In this book, all of our applications will fundamentally look like 
the Hello World application we created in the last chapter. 
Starting the Application 
An application is generally started in one of three ways: 
 The user clicks the application’s icon on the BlackBerry home screen. 
 The application is an automatically starting application and runs when 
the device is turned on or after it reboots. 
 The application is run by another application. 
In all cases, the main method is the first entry point for your application. The BlackBerry 
device will create a process, which will call that method. Whenever the main method 
exits, the process is terminated and your application exits. This means that if you want 
your application to do anything, it needs to happen within the main method. 
The main method takes an array of java.lang.String objects as parameters. For the 
most part, this array is empty, but parameters can be passed in if you define them in the 
project properties or if they’re passed by another process that is starting your 
application. 
Creating the Application 
All BlackBerry applications that want to present a user interface to the user must extend 
UiApplication. You can only create one instance of UiApplication for any application 
process; the BlackBerry runtime will throw an exception if you try to instantiate a second 
one.  
Even applications with no user interface must extend 
net.rim.device.api.system.Application, but those types of applications are outside 
the scope of this book. 
You can always access your application instance using the static method 
UiApplication.getUiApplication(). This actually returns an instance of your application 
class, so from anywhere in Hello World, the following is allowed: 
HelloWorldApp helloWorld = (HelloWorldApp)UiApplication.getUiApplication(); 

CHAPTER 3:  What Makes a BlackBerry Application? 
38 
Invoking the Event Thread 
The event thread is started for you by the BlackBerry operating system, but it doesn’t 
start processing events and drawing the UI until you explicitly tell it to. You do this with 
the UiApplication.enterEventDispatcher() call that you saw in the last chapter. Once 
this method is called, the thread that entered into the main method passes from your 
direct control and takes up the task of listening for user interface input and drawing the 
user interface to the screen. You’ll still get a chance to do work on the thread, but for the 
most part, its activities are scheduled by the BlackBerry operating system. 
enterEventDispatcher won’t return for the entire life cycle of your application, so if 
there’s anything your main thread must do before calling this (for example, some types 
of initialization), you have only one chance. 
Processing Events 
The application responds to keyboard input, trackball and touch screen movements, 
and clicks, as well as other events such as system messages.  
Exiting the Application 
Generally, a BlackBerry application exits when the last screen is removed from the 
display stack (by closing it). You may have noticed the System.exit() method, which will 
exit the application, but we recommend avoiding this, and instead properly cleaning up 
the application on exiting by closing all screens. When the application exits, all 
application state will be cleaned up, and the next time the user clicks the application 
icon, the main method will be called again with a new process. 
Threading and the Event Thread 
The BlackBerry UI API is single threaded. This means that all UI updates and events are 
handled by the same thread—or more precisely, they must be handled while holding the 
event lock, which most of the time is held by the UI thread. It also has a couple of 
implications for BlackBerry applications: other threads can’t directly access the UI 
without explicitly acquiring the event lock (an exception will be thrown if you try), and if 
you perform a time-consuming operation on the event thread, the entire user interface 
will pause while the operation is taking place. 
The message to take away from all this is to get comfortable with using at least one or 
two other threads in your applications.  

CHAPTER 3:  What Makes a BlackBerry Application? 
39 
NOTE: We’re not going to be doing heavy concurrency in this book, so if you understand what a 
thread is and how to create and start one, you’ll be fine. However, if you’re not comfortable with 
the idea of threading at all, or you’ve never used threads in your programming, we recommend 
you take a look at the Java SE threading API and pick a book that specifically explains threading 
and concurrency in Java. One such good book is Java Concurrency in Practice, by Brian Goetz et 
al. (Addison-Wesley, 2006).  
Knowing When Your Application Is on the Event Thread 
You can always tell if your code is being executed by the event thread by calling 
UiApplication.isEventDispatchThread(). Generally though, you shouldn’t need to 
invoke this. A good rule of thumb for determining if you’re on the event thread is this: if 
your code was invoked more or less directly from the run method of a Thread that you 
created, you’re not on the event thread. If the code was invoked by the system in 
response to user input (for example, a menu item or a button click), you’re on the event 
thread. 
Updating the UI from Other Threads 
Of course, many times, you want an event in another thread to be reflected in the UI—
for example, to show the progress of a long network activity like a file download. To do 
that, there are a couple of methods. The first is to use UiApplication.invokeLater or 
UiApplication.invokeAndWait to tell the UI thread to run some code on the event thread 
at the next available opportunity. The second method is to acquire the UI event lock by 
synchronizing on the object returned by UiApplication.getEventLock(). We’ll explore 
the first method by modifying Hello World to start a thread that adds a message to the 
main screen’s Label field every 5 seconds. 
NOTE: Both invokeLater and invokeAndWait do the same thing: they queue an instance of 
java.lang.Runnable to be executed on the event thread. The difference is that 
invokeLater returns immediately, while invokeAndWait doesn’t return until the run method 
of your Runnable has finished executing, and therefore blocks the thread that calls it. 
First, let’s change labelField to be a member variable instead of a variable local to the 
constructor, and add a method to append text to it: 
public class HelloWorldMainScreen extends MainScreen { 
 
    private LabelField labelField; 
 
    public HelloWorldMainScreen() { 
        labelField = new LabelField("Hello World"); 
        add(labelField); 

CHAPTER 3:  What Makes a BlackBerry Application? 
40 
    } 
 
 
    public void appendLabelText(String text) { 
        labelField.setText(labelField.getText() + "\n" + text); 
    } 
} 
Because appendLabelText calls LabelField.setText, the call can only be made from the 
event thread. If you attempt to call this method directly from another thread, an 
exception will be thrown. 
Now, we’ll define the thread class that will actually do the updating. It will loop from 1 to 
10. In each iteration, it will wait 5 seconds and then add some text to the LabelField. 
Create a new class called MainScreenUpdaterThread that extends java.lang.Thread. The 
full source code follows: 
package com.beginningblackberry; 
import net.rim.device.api.ui.UiApplication; 
public class MainScreenUpdaterThread extends Thread { 
    HelloWorldMainScreen mainScreen; 
    public MainScreenUpdaterThread(HelloWorldMainScreen mainScreen) { 
        this.mainScreen = mainScreen; 
    } 
    public void run() { 
        for (int i = 0; i < 10; i++) { 
            try { 
                Thread.sleep(5000); 
            } catch (InterruptedException ex) { 
            } 
            // Queue a new task on the event thread 
            UiApplication.getUiApplication().invokeLater(new Runnable() { 
                public void run() { 
                    mainScreen.appendLabelText("Update"); 
                } 
            }); 
        } 
    } 
} 
To actually update the UI, we’re using an anonymous inner class, which is a class that 
we define at the point where we instantiate it. Our anonymous inner class calls the one 
method that needs to be called on the event thread: appendLabelText (which calls 
LabelField.setText).  
We’ll start our thread in the HelloWorldMainScreen constructor as follows: 
    public HelloWorldMainScreen() { 
        labelField = new LabelField("Hello World"); 

CHAPTER 3:  What Makes a BlackBerry Application? 
41 
        add(labelField); 
 
        MainScreenUpdaterThread thread = new MainScreenUpdaterThread(this); 
        thread.start(); 
    } 
Finally, running this application will produce the output shown in Figure 3–3. 
 
Figure 3–3. A few updates from our thread 
Using the Event Lock 
What about the second method of updating the UI from another thread? With a simple 
modification to MainScreenUpdaterThread we can use that too. Change the run method 
of MainScreenUpdaterThread to the following: 
    public void run() { 
        for (int i = 0; i < 10; i++) { 
            try { 
                Thread.sleep(5000); 
            } catch (InterruptedException ex) { 
 
            } 
            // Ensure we have the event lock 
            synchronized(UiApplication.getEventLock()) { 
                mainScreen.appendLabelText("Update"); 
            } 
        } 
    } 
The application should run exactly the same way as in the previous example. 
This example application is admittedly a bit contrived, but it’s important to understand 
the concept of updating the UI from a different thread, as this concept will be applied 
throughout most BlackBerry applications you create. 

CHAPTER 3:  What Makes a BlackBerry Application? 
42 
Running Background Applications 
While an application, by default, will exit when the last screen is closed, you can override 
this behavior to send an application to the background instead, meaning that the UI will 
not be displayed, but the application will continue to run as the user performs other 
tasks. Running applications in the background is useful in the following situations:  
 You want your application to periodically check for changes on the 
device or for events. For example, the BlackBerry Messages 
application always runs to check for incoming mail.  
 You want to periodically download new information from the network. 
Several weather and stock applications use this approach. 
 You need to maintain a connection to an external server. An instant 
messaging application might need to maintain a connection to the 
messaging server. 
 Your app relies on data obtained through IM’s Push service, and it 
needs to be running in the background in order to listen for and accept 
incoming messages. 
Detecting Backgrounding or Foregrounding 
An application can be sent to the background if a user presses the red phone key or 
explicitly switches tasks. You can detect this background status by overriding the 
UiApplication.deactivate method. Similarly, you can detect your application coming 
back into the foreground by overriding UiApplication.activate. 
Let’s modify HelloWorldApp to display a message when Hello World goes to the 
background or comes to the foreground: 
public class HelloWorldApp extends UiApplication { 
 
    private HelloWorldMainScreen mainScreen; 
 
    public HelloWorldApp() { 
        mainScreen = new HelloWorldMainScreen(); 
        pushScreen(mainScreen); 
    } 
 
    public void deactivate() { 
        mainScreen.appendLabelText("Went to background"); 
    } 
 
    public void activate() { 
        mainScreen.appendLabelText("Came to foreground"); 
    } 
 
    /** 
     * @param args 
     */ 

CHAPTER 3:  What Makes a BlackBerry Application? 
43 
    public static void main(String[] args) { 
        HelloWorldApp app = new HelloWorldApp(); 
        app.enterEventDispatcher(); 
    } 
 
} 
When you run this application, you’ll immediately see a “Came to foreground” message. 
The message is displayed because of the initial activation of the application. Press the 
red button, and then select the icon a few times to send the application back and forth 
from foreground to background. You’ll see something like Figure 3–4. 
 
 
Figure 3–4. Hello World after going between the background and foreground a few times 
Sending Your Application to the Background 
You can send your application to the background using the 
UiApplication.requestBackground() method. To make Hello World go to the 
background rather than exit when the user closes the main screen, let’s override 
Screen.close() in HelloWorldMainScreen: 
public class HelloWorldMainScreen extends MainScreen { 
     //... 
 
    public void close() { 
        UiApplication.getUiApplication().requestBackground(); 
    } 
Also, add the import statement for UiApplication in HelloWorldMainScreen to make the 
class compile:  
import net.rim.device.api.ui.UiApplication; 
Now, pressing the Escape key or selecting Close from Hello World will actually send the 
application to the background. You can test that this produces the same messages as in 
the example shown in Figure 3–4. 

CHAPTER 3:  What Makes a BlackBerry Application? 
44 
Understanding the Types of Projects 
We mentioned this topic earlier, but it deserves a little more discussion now. Using the 
JDE Plug-in for Eclipse, you can create several types of BlackBerry projects. We’ve 
been making applications up to this point, but there are two others that you may end up 
using: libraries and alternate entry points.  
Libraries 
Libraries, like applications, are packaged as .cod files. They’re loaded onto a device in 
the same way. The difference is that they aren’t executed directly by the BlackBerry 
device; they contain code or resources used by one or more other applications. You 
may want to create a library to logically separate your code or reuse code between 
applications. 
Creating a Library 
Creating a library is similar to creating an application. From Eclipse you create a normal 
BlackBerry project. On Eclipse’s Package Explorer and under the newly created project, 
double-click the BlackBerry_App_Descriptor.xml file. You’ll see a screen similar to the 
one shown in Figure 3–5. On this screen, change the application type to Library. 
 
Figure 3–5. Making a BlackBerry application into a library in Eclipse 

CHAPTER 3:  What Makes a BlackBerry Application? 
45 
Using Libraries in Your Application 
Once you have a library, you need to tell your development environment that your 
application depends on it. From Eclipse, you can find the option in the project 
properties; select Project References, as shown in Figure 3–6. 
 
Figure 3–6. Adding a library dependency 
Once you’ve added the library dependency to your project, you can refer to classes in 
that library in the same way as you refer to classes in your application. 
CAUTION: A warning about duplicate classes on the BlackBerry: The BlackBerry class loader 
uses one global namespace. This means that having two classes in two different modules with 
the same fully qualified class name will cause a conflict. For example, having two classes named 
com.beginningblackberry.HelloWorldMainScreen is a problem, but if one is named 
com.somethingelse.HelloWorldMainScreen, that’s OK. Libraries can help you get around 
naming conflicts like this by moving common code into one place, but they can also cause 
problems if you’re not careful and have the same classes included in a library and your 
application. 

CHAPTER 3:  What Makes a BlackBerry Application? 
46 
Creating an Alternate Entry Point 
An alternate entry point is exactly what it sounds like: another way for the user or 
BlackBerry to start your application. An alternate entry point can provide another icon on 
the BlackBerry home screen to start your application. When the other icon is clicked, the 
same main method is called, but with different parameters, allowing you to run your 
application in different modes. Alternate entry points are also commonly used with 
applications that are configured to automatically start when the device powers on or 
reboots, but that may also need to be started by the user or are integrated into other 
applications, such as the Messages or Camera applications, and started using a menu 
item in one of those applications.  
The process for creating an alternate entry point is easy. Using the same HelloWorld app 
we created earlier, double-click the BlackBerry_App_Descriptor.xml file. On the bottom 
of Application Descriptor screen, click the Alternate Entry Points tab. On this tab, click 
the Add button on the Alternate Entry Points section and enter Hello World Alternate at 
the prompt that follows. This will be the name of the app you'll see when you run the 
project in the simulator. Also enter alt as the application argument, which we will 
interrogate later in the program to determine whether our app is instantiated through this 
alternate. You should end up with a screen that looks like Figure 3–7. As a side note, 
notice the “Auto-run on startup” check box on this screen. Its meaning is obvious. If you 
check this box, this app will automatically start when the device starts or after the device 
is reset. But for this exercise, leave this box unchecked, since we only want to show 
how alternate entry works, and how to start this alternate entry by clicking the app’s 
icon on the home screen. 
To see how this fits together, let’s modify the application a little. Remember the alt 
Application argument you entered earlier on the Alternate Entry Points screen? Let’s use 
it in the code. Now, add a new constructor to HelloWorldMainScreen: 
    public HelloWorldMainScreen(boolean isAlternateEntry) { 
        if (isAlternateEntry) { 
            labelField = new LabelField("Goodbye World!"); 
        } 
        else { 
            labelField = new LabelField("Hello World!"); 
        } 
        add(labelField); 
    } 

CHAPTER 3:  What Makes a BlackBerry Application? 
47 
 
Figure 3–7. Creating an alternate entry point for the Hello World application 
Modify the main method and the constructor in HelloWorldApp to look at the parameters 
passed in, and call the alternate constructor if alt is the first one: 
    public static void main(String[] args) { 
        HelloWorldApp app = new HelloWorldApp(args); 
        app.enterEventDispatcher(); 
    } 
 
    public HelloWorldApp(String[] args) { 
        if (args.length > 0 && args[0].equals("alt")) { 
            mainScreen = new HelloWorldMainScreen(true); 
        } 
        else { 
            mainScreen = new HelloWorldMainScreen(false); 
        } 
        pushScreen(mainScreen); 
    } 
In the new HelloWorldApp constructor, we first check the length of args. The BlackBerry 
device will split the argument string that we specified in the project properties for our 
alternate entry point into words based on whitespace, and place each word into a 
separate element of the array. Since we didn’t specify any arguments for the main 
HelloWorld project, args will have a length of 0.  
Now save your project and run it in the simulator. You’ll see a Hello World Alternate 
icon on the home screen. Click it and you’ll see “Goodbye World!” on the screen, as in 
Figure 3–8. 

CHAPTER 3:  What Makes a BlackBerry Application? 
48 
 
Figure 3–8. Running Hello World through an alternate entry point 
MIDP and MIDlet Projects 
Finally, you may have noticed the MIDlet project type in the Eclipse plug-in or the JDE. 
In case you’re not familiar with Java ME programming, a MIDlet is the application type 
for the Java ME Mobile Information Device Profile (MIDP), which is essentially a set of 
classes and capabilities that most Java ME implementations support. Many other types 
of smartphones from companies such as Nokia, Sony Ericsson, and Motorola support 
MIDP. You would use MIDP to build applications that run on all these devices without 
any code changes.  
The BlackBerry fully supports MIDP but also includes a large API that’s not part of 
MIDP. This means that the BlackBerry can run MIDlets, and in fact, MIDlets that are 
specifically built for BlackBerry can access many parts of the non-MIDP API, but they 
don’t have access to the entire BlackBerry API. Specific things that MIDlets do not have 
access to include the BlackBerry UI API and the BlackBerry application life cycle 
controls (such as automatic start). For these reasons, we don’t recommend writing your 
BlackBerry applications as MIDlets, and in fact, we don’t discuss MIDlet-specific topics 
in this book after this section. However, if you have an existing MIDlet originally built for 
another smartphone platform and you need to quickly run it on a device, BlackBerry has 
you covered. 
Summary 
This chapter has been a bit of a grab bag of interesting development topics, and you’ll 
end up using many of them in your own applications. By now, though, you’re probably 
ready to get back to learning more of the BlackBerry API. So take a deep breath, 
because now that you have the basic knowledge to create applications, we’re going to 
speed up a bit, and the lessons for the rest of the BlackBerry API are going to start 
coming fast and furious! 
www.allitebooks.com

 
49 
 
 
 
Chapter 
User Interface Basics 
The Hello World application was great for introducing the BlackBerry development 
environment and the basics of a BlackBerry application, but it was certainly not what 
you'd usually think of a as a fully developed application. It lacked the ability to interact 
with the user, and its user interface was very limited. In the next couple of chapters, 
you'll explore the BlackBerry user interface in much greater detail and build an 
application that really shows off what you can do with the BlackBerry.  
The BlackBerry API includes a rich framework for building user interfaces for your 
applications. This chapter will build on the concepts covered in the last two chapters  
to show you how to use the full range of BlackBerry UI components to build an 
application with a couple of screens and several controls that respond to user input. 
You'll also equip the application with a couple of menu items besides the defaults that 
are provided. And to spice up your UI, you'll also learn to build a screen that displays 
images in a carousel. 
If you’re familiar with Java’s Abstract Window Toolkit (AWT) Swing, Windows Forms, or 
another object-oriented user interface toolkit, you’ll have no problem learning the 
BlackBerry UI API. The key point here is that user interfaces for Java-based BlackBerry 
applications are built in code: there are no configuration files or external metadata to 
worry about. This situation has positive aspects (for example, all UI information is 
centralized in the Java code) and negative aspects (for example, you have no visual 
tools for building your UI). 
Ready? Let’s dive in and start building the application.  
The UI Fun Application 
You want an application that will show off what the BlackBerry UI can do. You'll build 
just such an application over the course of this chapter (and improve it in later chapters), 
but having the end goal in mind before you start will be helpful.  
To show off a few of the available controls and have something with some amount of 
interactivity, you'll construct a simple login screen. When you're done, the main screen 
of your application will look like the one shown in Figure 4–1. 
4 

CHAPTER 4:  User Interface Basics 
50 
Figure 4–1. Your goal application for this chapter 
There’s a plain-text field for the username, a hidden-text password field, a drop-down 
list that lets the user choose a domain, a check box to ask the application to remember 
the password, and a couple of buttons that will log in the user and clear the text fields. 
For good measure, there's an image at the top of the screen, and you'll add a couple of 
menu items, too. 
For this application, there will be no networking; clicking Login will display a simple 
screen that lets you know that the button has been pressed and shows the credentials 
the user has entered. 
The Components of a BlackBerry UI 
All the visible elements on screen in a BlackBerry application are of one of the  
three types: 
 Fields: These are the basic building blocks of the UI. Generally, each 
control, such as a button or text field, corresponds to an instance of a 
field. The Field class draws the control and handles user input. 
 Managers: These arrange fields on the screen. Each field must belong 
to one and only one manager. Each manager is also a field, meaning 
managers can contain other managers, allowing for some pretty 
intricate UI layouts. 

Screens: There’s one active screen per application at any time. 
Screens handle field layout through a delegate manager and provide 
additional functionality like menus. 

CHAPTER 4:  User Interface Basics 
51 
Fields are all derived from net.rim.device.api.ui.Field. There are a lot of useful 
prebuilt fields available in the net.rim.device.api.ui.component package. 
Managers are derived from net.rim.device.api.ui.Manager, which is a subclass of 
net.rim.device.api.ui.Field. Several useful managers are defined in the 
net.rim.device.api.ui.container package. 
Screens all derive from net.rim.device.api.ui.Screen, which is a subclass of Manager, 
and therefore of Field. You’ll also find the default screens in the 
net.rim.device.api.ui.container package. 
NOTE: Though Screen is ultimately descended from Field, you can’t add a Screen to a 
Manager. The hierarchy in this case represents functionality—a Screen does things that a 
Field and Manager do, such as painting itself, handling user input, and managing fields, but it 
is not actually a drop-in replacement for a Field the way a Manager is. 
Right now, or sometime soon, you may want to browse through the Javadocs for the 
packages mentioned in this section. These can give you an idea of what’s possible with 
the BlackBerry and maybe help with some ideas for your own applications. In this 
chapter, all the fields, managers, and screens you’ll use are those provided with the 
JDE. You’ll learn how to make your own in the next chapter. 
Creating the Application 
In Eclipse, create a new BlackBerry Application project called UiFun. You'll create the 
application class and main screen class as before. The main application class will be the 
same as the simple first version you created a couple of chapters ago. You'll use the 
package com.beginningblackberry.uifun and call the application and main screen 
classes UiFunApplication and UiFunMainScreen. You should know enough to create 
these classes now, but for reference the source code follows: 
package com.beginningblackberry.uifun; 
import net.rim.device.api.ui.UiApplication; 
 
public class UiFunApplication extends UiApplication { 
    public UiFunApplication() { 
        UiFunMainScreen mainScreen = new UiFunMainScreen(); 
        pushScreen(mainScreen); 
    } 
 
    public static void main(String[] args) { 
        UiFunApplication app = new UiFunApplication(); 
        app.enterEventDispatcher(); 
    } 
} 
Here’s the source code for the UiFun application class: 
package com.beginningblackberry.uifun; 

CHAPTER 4:  User Interface Basics 
52 
import net.rim.device.api.ui.container.MainScreen; 
 
public class UiFunMainScreen extends MainScreen { 
    public UiFunMainScreen() { 
 
    } 
} 
Adding the Logo Image 
The first field you add will be an instance of 
net.rim.device.api.ui.component.BitmapField to show the image at the top of  
the screen. 
The BlackBerry can use PNG, GIF, or JPEG images, but most applications use PNGs 
because of their reduced size, high quality, and support for transparencies. When 
creating images for use in your application, always consider compressing your image as 
much as possible using your graphics program or a PNG optimizer (several good free 
ones are available), because large images can very quickly increase the size of your 
application. You can download the logo image from the book’s web site at 
www.beginningblackberry.com.  
Adding the Image to the Project 
Add the image file to your Eclipse project under the folder called res at the same level as 
your source folder (see Figure 4–2), copying the image into that folder and from your 
Eclipse workspace by right-clicking your project and clicking Refresh. You can put 
images in whatever folder you want, but for this example use the default resources 
folder named res. 
 
Figure 4–2. This Eclipse workspace with the apress_logo.png image added 
Adding the Image to the Screen 
BitmapField takes a Bitmap object as an argument in its constructor, so you’ll need to 
load the image before constructing the field. You’ll import 

CHAPTER 4:  User Interface Basics 
53 
net.rim.device.api.system.Bitmap and add the following line to UiFunMainScreen’s 
constructor to load the bitmap from the image resource you just added: 
Bitmap logoBitmap = Bitmap.getBitmapResource("apress_logo.png"); 
The path for loading bitmaps, and all other resources, is relative to the location of your 
project's res folder. You put the bitmap in the root of the res folder so you don't have to 
specify the path. 
Finally, you want to center the bitmap horizontally at the top of the screen. MainScreen 
lays out fields vertically top to bottom in the order that they’re added, so the 
BitmapField will automatically appear at the top of the screen. But to horizontally center 
it, you need to specify the Field.FIELD_HCENTER style in its constructor. You've also 
elected to make the BitmapField a member field instead of just declaring it locally in the 
constructor. You’ll follow this pattern for all your fields—making your user interface 
components member fields will become important as you start to handle user input.  
Now, constructing the bitmap field and adding it to the screen is easy. On the 
UiFunMainScreen, simply add the imports to Bitmap, Field, BitmapField and add the 
BitmapField to the UiFunMainScreen constructor to make the complete UiFunMainScreen 
code look like this: 
package com.beginningblackberry.uifun; 
 
import net.rim.device.api.system.Bitmap; 
import net.rim.device.api.ui.Field; 
import net.rim.device.api.ui.component.BitmapField; 
import net.rim.device.api.ui.container.MainScreen; 
 
public class UiFunMainScreen extends MainScreen { 
    BitmapField bitmapField; 
 
    public UiFunMainScreen() { 
        Bitmap logoBitmap = Bitmap.getBitmapResource("apress_logo.png"); 
        bitmapField = new BitmapField(logoBitmap, Field.FIELD_HCENTER); 
        add(bitmapField); 
    } 
} 
And when this code is run, you’ll see the screen shown in Figure 4–3. 

CHAPTER 4:  User Interface Basics 
54 
 
Figure 4–3. The BitmapField centered at the top of the screen 
Field Style Flags 
Almost all fields and managers have a constructor that takes a style parameter. The style 
is a mask of various style flags concatenated with the bitwise or operator (|). These flags 
are defined throughout the API, although most are in Field and Manager, and they can 
influence many different aspects of field appearance, positioning, and behavior. You can 
apply any style to any field, but whether the style has an effect depends on the field and 
sometimes the manager that contains that field. Generally, anything defined within the 
Field class is applicable to any field (including managers); anything defined within the 
Manager class is applicable to any manager, and anything defined within the Screen class 
is applicable to any screen. Flags defined within a specific subclass of field usually only 
apply to that field and any field that subclasses it; examples include the 
ButtonField.CONSUME_CLICK style and the various styles associated with TextField, 
BasicEditField, and their subclasses.  
There are, unfortunately, no guarantees about how a specific style flag will affect 
different fields. Generally, flags work the way you’d expect them to, but remember that 
just setting a particular alignment flag on a field doesn't guarantee that you’ll get exactly 
what you want. For example, some managers ignore the alignment flags, which will 
become clear when you build your own manager later on. The Javadocs provide more 
information for specific fields.  

CHAPTER 4:  User Interface Basics 
55 
Adding a Few More Fields 
Next, you’ll add your screen’s remaining controls: the username and password fields, 
the domain drop-down list, the check box, and the Login and Clear buttons.  
Creating the Username and Password Fields 
You’ll use an EditField for the username and a PasswordEditField (which automatically 
hides characters as they are typed) for the password field. Each of these fields can 
display its own label, specified in the constructor. You don’t need to apply any special 
styles to these fields. 
Add the following import statement to the top of UiFunMainScreen.java, just under the 
other import statements: 
import net.rim.device.api.ui.component.EditField; 
import net.rim.device.api.ui.component.PasswordEditField; 
Then, add the following declarations to the top of the UiFunMainScreen class: 
EditField usernameField; 
PasswordEditField passwordField; 
And add the following lines go in the constructor: 
usernameField = new EditField("Username:", ""); 
passwordField = new PasswordEditField("Password:", ""); 
add(usernameField); 
add(passwordField); 
Creating the Domain Field and Check Box 
The Domain field should be a drop-down list. For the BlackBerry, this is accomplished 
by an instance of net.rim.device.api.ui.component.ChoiceField. You can implement 
the interface directly, but for this application, the net.rim.device.api.ui.component. 
ObjectChoiceField component will do just fine; it allows you to specify an array of 
Objects, which will be used to populate the field (the toString method will be used for 
the display string). If you want a list of numbers, net.rim.device.api.ui.component. 
NumericChoiceField is also often useful.  
You’ll add the imports for both of these fields first. 
import net.rim.device.api.ui.component.CheckboxField; 
import net.rim.device.api.ui.component.ObjectChoiceField; 
Then you add the declaration of the member variables, again at the top of the 
UiFunMainScreen class. 
    ObjectChoiceField domainField; 
    CheckboxField rememberCheckbox; 

CHAPTER 4:  User Interface Basics 
56 
Because you're just using hard-coded values for this application, instantiating your 
ObjectChoiceField is easy. 
domainField = new ObjectChoiceField("Domain:", new String[] {"Home", "Work"}); 
add(domainField); 
And by this point, you can probably figure out how to use 
net.rim.device.api.ui.component.CheckboxField to create a check box on screen; 
there’s nothing special to note about CheckboxField except that you have to specify the 
state of the check box (true for checked or false for unchecked) when you instantiate it, 
like so:  
rememberCheckbox = new CheckboxField("Remember password", false); 
add(rememberCheckbox); 
Creating the Buttons 
To create the Login and Clear buttons that go beneath these text fields, you’ll use—as 
you might expect—the ButtonField class. A warning with ButtonFields: when creating a 
ButtonField, you should always specify the style ButtonField.CONSUME_CLICK. If you 
don’t, the click event will be passed onto the screen, and a menu will open when the 
user clicks the button, though your button will still cause an action to be performed.  
First, you’ll import ButtonField 
import net.rim.device.api.ui.component.ButtonField; 
Next, you add the declarations for your two buttons. 
    ButtonField clearButton; 
    ButtonField loginButton; 
Finally, the following lines go in the UiFunMainScreen constructor. 
clearButton = new ButtonField("Clear", ButtonField.CONSUME_CLICK); 
loginButton = new ButtonField("Login", ButtonField.CONSUME_CLICK); 
add(clearButton); 
add(loginButton); 
If you run the application, you’ll see something similar to Figure 4–4. 

CHAPTER 4:  User Interface Basics 
57 
 
Figure 4–4. The fields for the UiFun application 
You’re pretty close to being done! But you want those two buttons to be beside each 
other instead of one on top of the other.  
Arranging the Buttons Horizontally 
Remember that MainScreen (which UiFunMainScreen is derived from) lays out its fields 
vertically. To put two fields beside each other, you need to place them in an instance of 
net.rim.device.api.ui.container.HorizontalFieldManager and add that manager to 
the screen. You’ll give the HorizontalFieldManager the Field.FIELD_RIGHT style; this 
puts the buttons on the right side of the screen. 
Add the following import: 
import net.rim.device.api.ui.container.HorizontalFieldManager; 
Erase the two add calls for the buttons, and replace them with this: 
HorizontalFieldManager buttonManager = new HorizontalFieldManager(Field.FIELD_RIGHT); 
buttonManager.add(clearButton); 
buttonManager.add(loginButton); 
add(buttonManager); 

CHAPTER 4:  User Interface Basics 
58 
You’ll also add a couple of instances of 
net.rim.device.api.ui.component.SeparatorField, which draws a horizontal line 
across the screen, and of LabelField, which contains your login instructions. The full 
code for the UiFunMainScreen constructor at this point follows (remember to add an 
import statement for SeparatorField and LabelField):  
    public UiFunMainScreen() { 
        Bitmap logoBitmap = Bitmap.getBitmapResource("apress_logo.png"); 
        bitmapField = new BitmapField(logoBitmap, Field.FIELD_HCENTER); 
        add(bitmapField); 
        add(new SeparatorField()); 
        add(new LabelField("Please enter your credentials:")); 
 
        usernameField = new EditField("Username:", ""); 
        passwordField = new PasswordEditField("Password:", ""); 
        add(usernameField); 
        add(passwordField); 
 
        domainField = new ObjectChoiceField("Domain:", new String[] {"Home", "Work"}); 
        add(domainField); 
 
        rememberCheckbox = new CheckboxField("Remember password:", false); 
        add(rememberCheckbox); 
 
        add(new SeparatorField()); 
 
        clearButton = new ButtonField("Clear", ButtonField.CONSUME_CLICK); 
        loginButton = new ButtonField("Login", ButtonField.CONSUME_CLICK); 
 
        HorizontalFieldManager buttonManager =  
          new HorizontalFieldManager(Field.FIELD_RIGHT); 
        buttonManager.add(clearButton); 
        buttonManager.add(loginButton); 
        add(buttonManager); 
} 
Running the application, you’ll see your screen looking the way you intended it, as 
Figure 4–5 illustrates. 

CHAPTER 4:  User Interface Basics 
59 
 
Figure 4–5. The final look for the Login screen 
Handling User Interaction 
Now you have a screen that looks the way you want it to, but it doesn’t do anything 
yet—well, you can move the focus between controls, type in the text fields, and change 
the check box and the choice field, but the application doesn’t really do anything yet. 
Let’s get those buttons to work! 
Handling UI Events 
The BlackBerry API uses an observer pattern to dispatch events. All fields can have a 
listener attached to them, and that listener is notified when a change event happens. 
The exact trigger for a change event varies from field to field. 
In the case of ButtonField, the change event happens when the button is clicked by the 
trackball or a touch on the touch screen, or when the Enter key is pressed while a button 
is highlighted. For CheckboxField, a change event happens when the check box is 
checked or unchecked, and for ChoiceField, an event happens whenever the user 
selects a different choice. 
You attach a listener using the Field.setChangeListener method. Note that the 
BlackBerry provides a unicast event model: there is only ever at most one change 
listener for a field. If you use Field.setChangeListener, you replace whatever listener 
may have been there already, preventing it from receiving events. This makes a lot of 
sense for a mobile platform where resources and application scope are limited, but it 

CHAPTER 4:  User Interface Basics 
60 
may be different from what you’re used to with desktop or server application 
development. 
A listener must implement the FieldChangeListener interface. In this case, you’ll  
make your UiFunMainScreen implement net.rim.device.api.ui.FieldChangeListener  
by changing the class declaration and implementing the listener method in 
UiFunMainScreen. 
public class UiFunMainScreen extends MainScreen implements FieldChangeListener { 
public void fieldChanged(Field field, int context) { 
} 
Remember to add an import for net.rim.device.api.ui.FieldChangeListener to the top 
of the Java file. 
The field parameter is a reference to the field that originated the change, in this case, 
one of your ButtonField instances (once you’ve added them). The context can mean 
different things: when you define your own fields, you can use it to pass along additional 
information about the field change event. For this application, ignore the context
parameter. 
Handling the Clear Button 
You’ll hook up the Clear button first. Add the following line in the constructor, just after 
instantiating the button: 
clearButton.setChangeListener(this); 
Now, when the user clicks on the clear button, you’ll receive an event in 
UiFunMainScreen.fieldChanged. You can test this with a simple dialog by importing the 
net.rim.device.api.ui.component.Dialog class and using the  inform static method of 
the class to display a message: 
public void fieldChanged(Field field, int context) { 
    if (field == clearButton) { 
        Dialog.inform("Clear Button Pressed!"); 
    } 
} 
The Dialog class is a handy way of displaying simple messages to the user. Run the 
application, and click Clear to see that you’re correctly handling and receiving the event 
(see Figure 4–6). 

CHAPTER 4:  User Interface Basics 
61 
 
Figure 4–6. An event from the Clear button 
Of course, what you actually want the Clear button to do is remove all text from your 
fields. Let’s define a method to do this. Add the following to UiFunMainScreen: 
private void clearTextFields() { 
     usernameField.setText(""); 
    passwordField.setText(""); 
} 
And change the fieldChanged method to call your new method, like so: 
public void fieldChanged(Field field, int context) { 
     if (field == clearButton) { 
        clearTextFields(); 
    } 
} 
Now, clicking Clear will erase the text from both fields (see Figure 4–7). 

CHAPTER 4:  User Interface Basics 
62 
 
Figure 4–7. When the fields are populated (as in the image on the left), clicking the Clear button removes the text 
from the fields (as shown in the image on the right). 
Handling the Login Button 
The Login button does two things: checks that both fields have some text in them and 
displays a warning dialog if they don’t. If both have been filled in, it displays a new 
screen informing the user that login was successful.  
Defining a New Screen 
To keep the flow of everything fairly logical, let’s define the login success screen now. It 
will be a simple screen with three label fields, one each to show a successful login, the 
username, and the selected domain. You’ll pass the username and domain in the 
constructor of the screen. The entire code for LoginSuccessScreen is as follows: 
package com.beginningblackberry.uifun; 
 
import net.rim.device.api.ui.component.LabelField; 
import net.rim.device.api.ui.container.MainScreen; 
 
public class LoginSuccessScreen extends MainScreen { 
    public LoginSuccessScreen(String username, String domain) { 
        add(new LabelField("Logged in!")); 
        add(new LabelField("Username: " + username)); 
        add(new LabelField("Domain: " + domain)); 
    } 
} 

CHAPTER 4:  User Interface Basics 
63 
You display the new screen in the same way as you displayed UiFunMainScreen from 
UiFunApplication, but here, you have to get a reference to your UiApplication instance 
first. UiApplication.getUiApplication() will give you that; in fact, it’s a reference to the 
very same instance of UiFunApplication that you created in your main method. The 
code will look something like this: 
LoginSuccessScreen loginSuccessScreen = new LoginSuccessScreen(…) 
UiApplication.getUiApplication().pushScreen(loginSuccessScreen); 
As you did with the Clear button, you’ll define a method to perform the login logic 
described previously. You need the name of the selected domain to pass to the new 
screen; you can get the index of the currently selected item in domainField by calling 
domainField.getSelectedIndex(), and you can get the choice associated with that 
index by calling domainField.getChoice(int). The getChoice method returns an Object. 
However, because all the objects you passed into the constructor for domainField were 
Strings, you can safely cast the result of getChoice back to a String. The full code for 
UiFunMainScreen.login follows: 
    private void login() { 
        if (usernameField.getTextLength() == 0 || passwordField.getTextLength() == 0) { 
            Dialog.alert("You must enter a username and password"); 
        } 
        else { 
            String username = usernameField.getText(); 
            String selectedDomain =  
              (String)domainField.getChoice(domainField.getSelectedIndex()); 
        LoginSuccessScreen loginSuccessScreen =  
                new LoginSuccessScreen(username, selectedDomain); 
            UiApplication.getUiApplication().pushScreen(loginSuccessScreen); 
        } 
    } 
Notice that UiApplication is flagged as error by Eclipse, so add an import statement to 
net.rim.device.api.ui.UiApplication.  
You’ll also have to modify fieldChanged to handle the login button as well. 
    public void fieldChanged(Field field, int context) { 
        if (field == clearButton) { 
            clearTextFields(); 
        } 
        else if (field == loginButton) { 
            login(); 
        } 
    } 
Finally, remember to add the change listener to loginButton in UiFunMainScreen’s 
constructor. 
              loginButton.setChangeListener(this); 
When you run the application now, you’ll see the result shown in Figure 4–8. 

CHAPTER 4:  User Interface Basics 
64 
 
Figure 4–8. Clicking Login without a username a password (left) and with a username and password (right) 
Creating Menus 
Menus are everywhere in a BlackBerry application; in fact, you should try to provide 
menu options for most major functionality, because the menu is easier to access on 
most BlackBerry devices than buttons on the screen. 
The screen handles displaying menus, and menu items contain their own logic for 
performing actions. 
Understanding Menu Items 
Individual items in a menu are instances of net.rim.device.api.ui.MenuItem. This class 
is abstract and implements Runnable (it has a run method that you need to implement). 
The run method is executed on the event thread when the user clicks the menu item, so 
you can safely modify the UI from within the run method.  As mentioned in Chapter 3, 
the UI API is single-threaded. And it is paramount that you don't execute any heavy 
processing or networking in the UI event thread without starting a separate thread or the 
user will find that their BlackBerry is freezing up until your process is done.  
Each menu item has three pieces of information associated with it: text to display, a 
priority, and an ordinal. The priority determines which menu item is initially highlighted 
when the menu is first displayed; the item with the lowest value for priority will be 
highlighted when the menu is first opened. The ordinal determines where the item will 
appear in the menu relative to other menu items. A menu item will appear above menu 
items with higher ordinal values and below menu items with lower ordinal values. Two 

CHAPTER 4:  User Interface Basics 
65 
menu items with the same ordinal will appear in the order they were added to the menu, 
top to bottom. 
Implementing the Login and Clear Menu Items 
You’ll implement two menu items for your application corresponding to the Login and 
Clear actions of UiFunMainScreen. But first, let's add the following imports to 
UiFunMainScreen. 
import net.rim.device.api.ui.Menu; 
import net.rim.device.api.ui.MenuItem; 
import net.rim.device.api.util.StringProvider; 
You’ll create a new class for each menu item and declare these as inner classes within 
UiFunMainScreen—because you’ll only use them here and to give them access to 
UiFunMainScreen’s private login and clearTextFields methods. 
public class UiFunMainScreen extends MainScreen implements FieldChangeListener { 
    class LoginMenuItem extends MenuItem { 
        public LoginMenuItem() { 
            super(new StringProvider("Login"), 20, 10); 
        } 
 
        public void run() { 
            login(); 
        } 
    } 
 
    class ClearMenuItem extends MenuItem { 
        public ClearMenuItem() { 
            super(new StringProvider("Clear"), 10, 20); 
        } 
 
        public void run() { 
            clearTextFields(); 
        } 
    } 
} 
Notice the arrangement of the ordinal and priorities with the menu items. ClearMenuItem 
has a lower ordinal value and higher priority value than LoginMenuItem. Therefore, Clear 
will appear above Login on the menu, but Login will be highlighted by default. This 
arrangement lets you mirror the order of the buttons on screen, but makes the most 
likely user choice the default one, saving your users a bit of time. 
There are a couple of places where you can add menu items. One is in the screen’s 
constructor, by calling getMenu and adding items to the Menu object you get back. The 
other is by overriding makeMenu in your screen class. You’ll do the latter, because 
makeMenu is useful when creating context sensitive menus (menus whose items may 
change depending on the state of the screen). The makeMenu method in UiFunMainScreen 
should look like this: 

CHAPTER 4:  User Interface Basics 
66 
    protected void makeMenu(Menu menu, int instance) { 
        super.makeMenu(menu, instance); 
        menu.add(new LoginMenuItem()); 
        menu.add(new ClearMenuItem()); 
    } 
It’s very important to have the super.makeMenu call here; otherwise, the default menu 
items for the screen will not be added. Specifically, you’d lose the Close item that 
MainScreen automatically adds for you. There are times when you might want to change 
that, but not for this application, so you’ll be sure to make the super.makeMenu call. 
One final tip—you declared the menu items explicitly as classes in this example to 
present things in a clear order, but you’ll usually see menu items declared as 
anonymous inner classes instead. Using an anonymous inner class is more succinct, 
and you generally use each menu item class only once in a given application. So instead 
of using the preceding implementation, you could have omitted the declarations for 
LoginMenuItem and ClearMenuItem and instead done the following in makeMenu: 
    protected void makeMenu(Menu menu, int instance) { 
        super.makeMenu(menu, instance); 
        menu.add(new MenuItem(new StringProvider("Login"), 20, 10) { 
            public void run() { 
                login(); 
            } 
        }); 
        menu.add(new MenuItem(new StringProvider("Clear"), 10, 20) { 
            public void run() { 
                clearTextFields(); 
            } 
        }); 
    } 
In fact, you’ll be using this form throughout the rest of this book.  
Using Reusable Command 
Notice that your login method is both called by clicking loginButton or through Login  
MenuItem. Starting from version 6.0 of the BlackBerry API, RIM introduced a more 
elegant way of providing a reusable Command  CommandHandler classes that you can 
attach to a UI field like ButtonField and MenuItem. Command and CommandHandler 
classes become an action handler for the UI field. Command class can be reused within 
an application or when registered to RemoteCommandRegistrarConnection becomes 
available to other applications.  
You're not going to change the functionality of your app, but to illustrate how to use a 
Command and CommandHandler classes within an application, you'll tweak your code to 
use a common handler for both loginButton and Login  MenuItem. First in 
UiFunMainScreen, add the following import statements: 
import net.rim.device.api.command.Command; 
import net.rim.device.api.command.CommandHandler; 
import net.rim.device.api.command.ReadOnlyCommandMetadata; 

CHAPTER 4:  User Interface Basics 
67 
Next, add the handler inner class, like so: 
    class LoginCommandHandler extends CommandHandler 
    { 
       public void execute(ReadOnlyCommandMetadata metadata, Object context) 
       { 
     
   login(); 
       } 
    } 
Note that the LoginCommandHandler class will be calling the existing login method. So, you 
should expect the same behavior when this handler executes. Now, you need to attach 
this handler to both loginButton and Login  MenuItem. In the UiFunMainScreen 
constructor, right below the code where you instantiate loginButton, add the following: 
        loginButton.setCommand(new Command(loginHandler)); 
The handler is now attached to loginButton but to avoid executing login method twice, 
comment out the code that assigns a listener to loginButton, like so: 
        //loginButton.setChangeListener(this); 
Finally, in the makeMenu  method, comment out the part where you add Login MenuItem 
and add the following new code for adding same Login MenuItem and attaching the 
handler to it: 
         
        /* 
        menu.add(new MenuItem(new StringProvider("Login"), 20, 10) { 
            public void run() { 
                login(); 
            } 
        }); 
        */ 
        MenuItem loginMenu = new MenuItem(new StringProvider("Login"), 20, 10); 
        loginMenu.setCommand(new Command(loginHandler)); 
        menu.add(loginMenu); 
That's it. If you run the app, you should notice the same behavior when you click the 
login button or use the login menu item. 
Supporting Different Menu Instances 
The instance parameter is used to identify which menu you’re supposed to show. 
BlackBerry applications display a few slightly different menus depending on how the 
menu is displayed and the context of the screen and controls. The defined instances 
follow: 

CHAPTER 4:  User Interface Basics 
68 
 Menu.INSTANCE_CONTEXT: The menu is displayed by clicking the 
trackball. Usually, this menu is a subset of only the items available in 
the default menu that are applicable to the currently focused control 
or section of the screen. For example, Close won't show up here. 
The BlackBerry automatically adds a Full Menu item to this menu, 
which causes makeMenu to be called with INSTANCE_DEFAULT as the 
instance parameter.  
 Menu.INSTANCE_CONTEXT_SELECTION: This is the same as 
INSTANCE_CONTEXT, but the menu is displayed while the user has 
some text selected. You can use this to display items that may only 
apply when you can copy text. 
 Menu.INSTANCE_DEFAULT: In this case, menu is displayed by pressing 
the menu key. This menu should contain all the items in the context 
menu, in addition to any items that apply to the application as a 
whole. Close would show up here. 
In your application, you want Login and Clear to show up no matter which control has 
focus, since everything is related to logging in. Effectively, you can ignore the instance 
parameter in makeMenu, as the BlackBerry will automatically take care of putting the 
Close item only in the appropriate menu instance. This is why the makeMenu method is so 
simple. 
With that discussion out of the way, you can now run the application and see your menu 
items, which should look like the ones in Figures 4–9 and 4–10. 
 
Figure 4–9. In the context menu, notice the Login is selected, and the Full Menu item is present. 

CHAPTER 4:  User Interface Basics 
69 
 
Figure 4–10. In the default menu, notice the Login is selected, and many more menu items are present. 
You’ll notice that the instance menu can only show up when the currently focused 
control doesn't consume the click. The ButtonFields have the ButtonField.CONSUME_ 
CLICK style flag set, so the instance menu won’t show up when you click the trackball 
while they’re focused, which is how you’d expect buttons to behave. The CheckboxField 
and ObjectChoiceField also consume the trackball click, so you’ll see the context menu 
only when you click the trackball on one of the text fields. 
Clicking either the Clear or Login menu item will have the same effect as clicking the 
Clear or Login button.  
Displaying Images 
A need common to many applications is allowing users to browse images on the screen. 
The photo carousel is what comes to mind immediately. On the BlackBerry, a photo 
carousel can be easily achieved using the PictureScrollField class. This section will 
describe how to use the PictureScrollField class and how to override some of its 
methods. You'll tweak your UiFun application to display a screen that shows images in a 
carousel format. Remember, that in the UiFun app, you display the LoginSuccessScreen 
after the user enters login credentials and clicks the Login button. For this exercise, 
instead of displaying the LoginSuccessScreen, you'll display an album screen. 
Start by adding images to your project. For this purpose, you'll use three PNG images 
and store them under the res folder of the UiFun project. All the source code (including 
the images used in the apps described in this book) is available from both Apress web 
site and from our web site. You can download the images or you can choose your own. 

CHAPTER 4:  User Interface Basics 
70 
If you choose your own images, just make sure you resize the image to 196 x 327. Name 
it pic1.png, pic2.png, and pic3.png (as shown in Figure 4–11). 
Figure 4–11. Sample images needed for the Album screen 
Next, create the Album screen and on the constructor load the images you added to the 
project. Each image will be an entry to your PictureScrollField. And to construct a 
ScrollEntry, you also supply the label and the tooltip that each image displays. So your 
Album class with its constructor will look like this: 
package com.beginningblackberry.uifun; 
import net.rim.device.api.system.Bitmap; 
import net.rim.device.api.ui.Color; 
import net.rim.device.api.ui.TouchEvent; 
import net.rim.device.api.ui.component.Status; 
import net.rim.device.api.ui.container.MainScreen; 
import net.rim.device.api.ui.extension.component.PictureScrollField; 
import net.rim.device.api.ui.extension.component.PictureScrollField.ScrollEntry; 
public class Album extends MainScreen { 
    public Album () { 
     
Bitmap[] images = new Bitmap[3]; 
        String[] labels = new String[3]; 
        String[] tooltips = new String[3]; 
        ScrollEntry[] entries = new ScrollEntry[3]; 
        for (int i = 0; i < entries.length; i++)  
        {  
 
         
int imgIndex = i+1; 
         
images[i] = Bitmap.getBitmapResource("pic" + imgIndex + ".png"); 
         
labels[i] = "Label for image " + imgIndex; 
            tooltips[i] = "Tooltip for image " + imgIndex; 
            entries[i] = new ScrollEntry(images[i], labels[i],tooltips[i]); 
        } 
    } 
} 
The extra imports you see will be needed as you progress on the Album class. And at this 
point, this screen won't display anything yet since you haven't added the 
PictureScrollField instance. Instead of instantiating PictureScrollField, extend the 
class so that you can override its methods later. Copy the private PictureScroll class 
below inside the Album class, like so: 

CHAPTER 4:  User Interface Basics 
71 
 
private class PictureScroll extends PictureScrollField { 
 
 
private final ScrollEntry[] _entries; 
 
 
PictureScroll(ScrollEntry[] entries) { 
 
 
 
super(196,327); 
 
 
 
_entries = entries; 
 
 
 
this.setData(entries, 0); 
 
 
 
this.setHighlightStyle(HighlightStyle.ILLUMINATE_WITH_SHRINK_LENS); 
 
 
 
this.setHighlightBorderColor(Color.BLUE); 
 
 
 
this.setLabelsVisible(true); 
 
 
} 
 
} 
 
The PictureScroll class constructor accepts an array of ScrollEntry field and uses it to 
set its data. You customized its behavior by illuminating or highlighting briefly the center 
image as the user scrolls from image to image. You also tell it to display a label 
underneath the picture. Lastly for this Album class, in the bottom of the constructor, use 
the following line of code to instantiate and add to the screen PictureScroll. 
        add(new PictureScroll(entries));         
The Album class is now ready to display a carousel. But before you run the app, you 
need to replace the portion of the code of the login method in the UiFunMainScreen. 
Under the else statement, comment out the code that instantiate and display the 
LoginSuccessScreen and replace it with Album. That portion of the code should read like 
this: 
//        LoginSuccessScreen loginSuccessScreen =  
//                new LoginSuccessScreen(username, selectedDomain); 
//            UiApplication.getUiApplication().pushScreen(loginSuccessScreen); 
            UiApplication.getUiApplication().pushScreen(new Album()); 
Now you can save and run UiFun in the simulator. If you are using the images from the 
code download, your screen will be similar to Figure 4–12. 

CHAPTER 4:  User Interface Basics 
72 
 
Figure 4–12. Displaying images using the PictureScrollField 
What if you want to do something when a user clicks or touches on the image? 
Remember that your own PictureScroll class is an extension of PictureScrollField. 
So, in theory, you can override methods inside the class. For implementing a listener on 
the click or touch event of the field, all you need to do is override the touchEvent method 
like this:  
 
 
 
protected boolean touchEvent(TouchEvent message) { 
 
 
    if(message.getEvent() == TouchEvent.CLICK) 
 
 
    { 
 
 
        if(this.isFocus()) 
 
 
        { 
 
 
            Status.show("You selected item " + 
_entries[this.getCurrentImageIndex()].getLabel()); 
 
 
            return true;             
 
 
        }                   
 
 
    } 
 
 
 
    return super.touchEvent(message);   
 
 
} 
This code checks for an actual touch or click. It also makes sure that the field is in focus 
and displays a message. Of course, you can write elaborate code of what to do here but 
this illustrates how you would go about catching a click or touch event. If you run the 
app again with the code above and click on one of the image, you'll see a message 
displayed like the one shown in Figure 4–13. 

CHAPTER 4:  User Interface Basics 
73 
 
Figure 4–13. Displaying a message when an image is clicked 
One last point before we wrap up this section. At times, images can differ in sizes and 
will look weird in the carousel. In that case, you may need to resize your images. The 
Bitmap class has the scaleInto method for that purpose and you'll need to code 
something like: 
     
Bitmap resizedBitmap = new Bitmap(300,350); 
       originalBitmap.scaleInto(resizedBitmap,Bitmap.FILTER_BILINEAR); 
This code will resize originalBitmap to 300 x 350 and store it into resizedBitmap 
variable. 
Summary 
Congratulations, you’ve created your first multiscreen, interactive BlackBerry 
application! Although the application was simple, we covered a lot of ground in this 
chapter. You should now understand how to construct a BlackBerry UI using screens, 
managers, and fields and how to support user interaction through controls and menus.  
The concepts that we covered are basically the same as those you’ll use to construct 
UIs of any complexity in Java-based BlackBerry applications, and they are 
fundamentally important to any BlackBerry developer. So, if there was anything you 
didn’t understand fully, go back and review that section. Moving on from this chapter 
with a gap in your understanding will slow you down as we get into creating more 
advanced applications in later chapters. Also, the fields we used in this chapter only 
touch the tip of net.rim.device.api.ui package iceberg. We can't cover all of the 
classes available, so spend some time exploring the API documentation. You'll find 
other classes that might be appropriate for your application. For instance, you could use 

CHAPTER 4:  User Interface Basics 
74 
BrowserField for displaying a web page, a GLField for writing an OpenGL application, or 
a MapField to display a map. 
Using just what you’ve learned so far, you can construct some fairly complex 
applications, although they’d be a bit limited in usefulness without networking or 
persistent storage. We’ll tackle both of those topics in later chapters, but before that, the 
next chapter will go even deeper into the API and create some custom fields, managers, 
and screens to really remove any limits and let you create almost any user interface you 
can design and imagine. 

 
75 
 
 
 
Chapter 
Beyond the Basics of User 
Interfaces 
The previous chapter introduced the major concepts that you’ll need to build a 
BlackBerry user interface. Armed with what you learned, you can create a wide range  
of very functional applications. In this chapter, you’ll take a deeper dive into the 
BlackBerry API and learn how to really control all aspects of the look and feel of your 
application’s UI. 
The topics in this chapter will get a bit more advanced, but you can handle it if you’ve 
followed through up to this point. We’ll be up front, though: you’ve already learned 
enough to put together a user interface that could support a lot of different applications, 
so if you want to skip this chapter for now and go on to learn about networking, 
persistence, and other services before spending time on your UI, then go ahead. Later 
topics don’t depend on this chapter, so skipping it for now won’t do any harm. We 
highly recommend that you do come back here before finally publishing your 
application, as the topics we’ll cover here will go a long way toward improving the 
appearance and overall user experience of your application. 
In this chapter, you’ll take the UI Fun application you built in the last chapter as a 
starting point and modify a lot of the components that make up its user interface. You’ll 
focus a bit on some aspects of the API that we glossed over earlier (yes, we know we 
did) and explore fonts, colors, and more; this will give you a feel for what can be done. 
Of course, as with all things in this book, you should just look at this as the beginning. 
When you’re done here, you’ll have the tools and knowledge to implement almost any 
user interface that you can imagine and design. 
Enhancing the UI Fun Application 
You're using the UI Fun application from Chapter 4. If you didn’t go through that entire 
chapter and build the application, we recommend you do so before continuing—to 
make sure you’ve got the solid hold on the UI fundamentals that you’ll need in this 
5 

CHAPTER 5:  Beyond the Basics of User Interfaces 
76 
chapter. If you believe you’re comfortable enough but didn’t go all the way through, you 
can download the complete source code for the Chapter 4 version of UI Fun from this 
book’s web site.  
The UI Fun application at this point should look like the one shown in Figure 5–1. 
 
Figure 5–1. The UI Fun application from Chapter 4 
When you’re done, your application will look more like the one shown in Figure 5–2. 
 
Figure 5–2. The updated interface for the UI Fun application 

CHAPTER 5:  Beyond the Basics of User Interfaces 
77 
Working with Fonts 
The first and easiest thing to do is to change the font used in the UI components. The 
BlackBerry platform includes pretty good font support and makes it almost trivial to 
change the font used for a component or an entire screen. 
Font support is provided through the net.rim.device.api.ui.Font and FontFamily 
classes. Through these, you can create fonts using any of the fonts installed on your 
device (quite a collection for all recent BlackBerry devices).  
There are two ways to get a font. One is to obtain a specific font family (what might be 
called a typeface in different systems) and get a specific font from it. The other is to 
derive a font from another font you already have. 
To get font from a font family, you must have an instance of that font family; this just 
involves the FontFamily.forName method. You can use any of the names of the families 
on your device;  you can see these on the device by going to the device’s options 
screen and selecting Screen/Keyboard (see Figure 5–3). This also gives you a nice real-
time preview of different font families, styles, and sizes. 
 
Figure 5–3. A selection of the font families available on a BlackBerry device 
To demonstrate BlackBerry font support, you’ll explicitly set a new font for UiFun. 
Starting with the code as at the end of Chapter 4, add the following imports to the top  
of UiFunMainScreen.java: 
import net.rim.device.api.ui.Font; 
import net.rim.device.api.ui.FontFamily; 
import net.rim.device.api.ui.Ui; 

CHAPTER 5:  Beyond the Basics of User Interfaces 
78 
The Ui class will be used in a minute; you’ve just added the import statement here to 
save time. You’ll use the BB Alpha Serif family, available on all devices, to more closely 
match the lettering in your logo image. Add the following to the UiFunMainScreen 
constructor: 
        try { 
                    FontFamily alphaSerifFamily = FontFamily.forName("BBAlpha Serif"); 
            } catch (ClassNotFoundException e) { 
            } 
This method won’t ever actually throw a ClassNotFoundException, though it’s a checked 
exception so the Java language requires you to add some code to handle it. If you 
specify a name for a font family that isn’t available, the BlackBerry will still return a 
default. 
There are a few choices for font style (the standard bold, italic, underlined, and so on), 
defined as constants in the Font class. You can also specify font sizes in a few different 
ways; the main ones to be concerned with are points and pixels. The size unit is 
specified using one of the constants from the net.rim.device.api.ui.Ui class. 
For your application, you’ll use a 9-point plain (not bold, italic, or underlined) version of 
BB Alpha Serif, like so: 
Font appFont = alphaSerifFamily.getFont(Font.PLAIN, 9, Ui.UNITS_pt); 
NOTE: Font sizes should generally be specified as points instead of pixels, because BlackBerry 
devices vary a great deal in screen resolution and physical size, or in other words, in dots per 
inch (DPI). A 10-pixel font may be acceptable on a BlackBerry Curve but will look tiny on the 
higher resolution screen of a BlackBerry Bold. Using points makes the fonts appear roughly the 
same physical size on these different devices. 
Changing the screen’s font is straightforward. 
            setFont(appFont); 
All the font code, added to UiFunMainScreen’s constructor, looks like this: 
    public UiFunMainScreen() { 
        try { 
            FontFamily alphaSansFamily = FontFamily.forName("BBAlpha Serif"); 
            Font appFont = alphaSansFamily.getFont(Font.PLAIN, 9, Ui.UNITS_pt); 
            setFont(appFont); 
        } catch (ClassNotFoundException e) { 
        } 
        // ... 
    } 
Each screen, manager, and field can have a different font, but setting the font for a 
container (screen or manager) will generally have the effect of setting the font for 
everything contained within it, unless you specify a different font for some of the 
components using their setFont methods. All this means is that you don’t have to do 

CHAPTER 5:  Beyond the Basics of User Interfaces 
79 
anything else, and you’ve now specified a different font for all the controls in your 
application. Run UiFun, and you’ll see the new font in effect (see Figure 5–4). 
 
Figure 5–4. All elements, including text typed into the edit fields, are now using the new the BB Alpha  
Serif font. 
Drawing to the Screen Using the Graphics Context 
The basic interface for displaying anything to the BlackBerry device’s screen is the 
net.rim.device.api.ui.Graphics class. It’s used under the hood by pretty much all 
elements of the BlackBerry user interface, and it gives you the tools to do anything 
you’ve seen in any BlackBerry application’s user interface. If you’re going to be doing 
any kind of user interface work with BlackBerry applications, you should get very familiar 
with the Graphics class. 
Each instance of Graphics is associated either with a Bitmap object or with a display 
(basically, a BlackBerry device’s physical screen). For this book, we’ll only focus on a 
Graphics object associated with a display. 
Using the Paint Method 
All fields (and managers and screens) get access to the Graphics object associated with 
the current display through the paint method. This method is called whenever the 
BlackBerry device determines that the section of the display containing the Field needs 
repainting. An important thing to bear in mind is that the same instance of the Graphics 
class is used by all managers and fields on a screen, and this instance is passed by the 
screen through its managers to the fields. This may seem a minor point, but it’s 

CHAPTER 5:  Beyond the Basics of User Interfaces 
80 
important to keep in mind as it’ll help in determining exactly why your application is 
drawing to the screen in a certain way. For example, setting the color on the Graphics 
object will affect the color of components drawn after it, unless they explicitly set their 
own colors. 
Because it’s so important to understand how the UI is displayed by the BlackBerry platform, 
we’ll take time for a brief discussion here before getting to more concrete examples. 
Understanding How the BlackBerry Screen Is Drawn 
At a high level, things happen in two stages. First comes the layout stage, where layout
and sublayout methods are called and all the fields are positioned and sized on the 
screen. Second is the paint stage, where paint methods are called and the fields 
actually draw to the display.  
Laying Out the Screen 
Layout involves positioning and sizing all the managers and controls on the screen. It 
starts with the screen itself and works down through all the nested managers and fields 
as follows: 
1. The screen’s sublayout(int width, int height) method is called. The width and 
height parameters will be the width and height in pixels of the device’s display. 
2. The sublayout method of the screen’s delegate manager is called. You’ll learn 
more about the delegate manager when you learn to build your own screen class, 
but briefly, it’s the component that actually contains and lays out all the fields and 
managers on the screen, and it's the only component directly controlled by the 
Screen itself. Often, the delegate manager will take up the entire screen, but there 
are instances, such as in a dialog with a border, where this may not be the case. 
So the width and height parameters passed to the delegate manager’s sublayout
method will be less than or equal to the width and height parameters passed to 
the screen’s sublayout method. 
3. The delegate manager iterates through all the fields and managers it contains and 
lays out each of them; that is, it positions them within itself, tells them how much 
space is potentially available, and asks them what size they’ll be on screen. This 
has the effect of calling sublayout (for a manager) or layout (for a field). The width 
and height available to each of the fields and managers will vary depending on 
how the delegate manager lays out its fields. In many cases, they may be greater 
than the height and width of the delegate manager itself; this means that the 
delegate manager is a scrolling manager and will only draw a subset of its fields at 
any time. 
4. Each manager lays out its managers, fields, and so on. 
5. Each field lays out itself out; a field may take up less than the space available. 
z

CHAPTER 5:  Beyond the Basics of User Interfaces 
81 
Painting to the Screen 
The painting stage is where pixels are actually drawn to the screen. In the same 
sequence as the layout stage, the screen, managers, and fields are all asked to paint 
themselves. 
1. The screen’s paint method is called, with a graphics context that represents the 
current display. 
2. The screen may do some painting itself (drawing its background, for example) and 
then asks its delegate manager to paint itself, which has the effect of calling the 
delegate manager’s paint method with the same Graphics object. If the delegate 
manager is smaller than the screen, the screen will set a clipping region on the 
Graphics object to the size and position of the delegate. This prevents the 
delegate from drawing outside its size (set during layout) and frees the delegate 
from worrying about what its absolute position on screen is (which, in fact, it 
generally doesn’t know). 
3. The delegate manager again may do some painting itself, and then asks each of 
its subfields and managers to paint themselves, setting appropriate clipping 
regions for each of its fields. 
4. Each manager paints itself and asks its managers and fields to paint themselves. 
5. Each field paints itself. 
Another important thing to keep in mind is that layout happens rarely—generally when a 
screen is constructed or when fields are added or removed—while paint happens 
frequently. This means that you should be very concerned about the speed of your paint 
methods; slow paint methods will slow down your user interface and negatively affect 
your application’s user experience. 
You should remember, in a nutshell, that 
 Layout happens once (or rarely), and in this step fields size themselves 
and are positioned. 
 Paint happens often, and in this step, fields draw their contents to the 
display. 
Now that we’ve covered the framework, it’s time to fill in the details by actually 
implementing some custom fields, managers, and screens. Along the way, you’ll use a 
lot of the methods in the Graphics class and explore them as you encounter them. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
82 
Creating Custom Fields 
You’ll create a couple of custom fields: first a simple, static, noninteractive one to 
introduce the concepts and then a more complicated one that deals with user 
interaction, focus, and events. 
Adding a Custom Label Field 
You’ll start by replacing the Please Enter Your Credentials field with one built from 
scratch that will use different foreground and background colors and contain a small 
image. It’s a simple field to make but will illustrate the basic concepts well. 
Creating the Basic Field Class 
Create a new class under the com.beginningblackberry.uifun package called 
CustomLabelField that subclasses net.rim.device.api.ui.Field. Here’s the basic 
outline, with placeholders for the two abstract methods that you’re required to 
implement for any field: 
package com.beginningblackberry.uifun; 
 
import net.rim.device.api.ui.Field; 
import net.rim.device.api.ui.Graphics; 
import net.rim.device.api.system.Bitmap; 
import net.rim.device.api.ui.DrawStyle; 
 
public class CustomLabelField extends Field { 
 
    protected void layout(int width, int height) { 
    } 
 
    protected void paint(Graphics graphics) { 
    } 
} 
Bitmap and DrawStyle will be used by the field a bit later; you just added the import 
statements now for convenience. 
Creating a Constructor 
You’ll now add a constructor and a few member variables to contain the label text and 
foreground and background colors (you’ll add the image shortly): 
    private String label; 
    private int foregroundColor; 
    private int backgroundColor; 
 
    public CustomLabelField(String label, int foregroundColor, 
            int backgroundColor, long style) { 
        super(style); 

CHAPTER 5:  Beyond the Basics of User Interfaces 
83 
        this.label = label; 
        this.foregroundColor = foregroundColor; 
        this.backgroundColor = backgroundColor; 
        } 
NOTE: Colors on the BlackBerry are represented by ints. You can use one of the constants in 
the net.rim.device.api.ui.Color class to select a desired color, or specify a color in 
hexadecimal RRGGBB format (the same as in HTML), such as 0xFF0000 for red or 0x0000FF for 
blue. 
The BlackBerry actually uses a 16-bit color model, with 5 bits for red, 6 for green, and 5 
for blue. It’ll automatically select the closest color to whichever one you specify, but it 
may not appear exactly as on screen, and the apparent color can vary from device to 
device depending on screen characteristics. So be sure to test out your color choices on 
a range of real devices. 
One final thing to notice in the constructor: there's a style parameter so the user of this 
field can set styles. It’s a good idea when creating fields to provide at least one 
constructor where style flags can be set. 
Adding the Layout Method 
You’ll do something very simple for the layout method. Since you want your label field 
to span the width of the screen, you’ll just use the passed-in width parameter as your 
field width. Remember the width parameter tells how much space is available to your 
field. You’ll base the height on the height of the Field’s font. 
    protected void layout(int width, int height) { 
        setExtent(width, getFont().getHeight()); 
    } 
Although it’s a simple method, there’s an important principle illustrated here: because 
there are a wide range of BlackBerry models, and default fonts and screen resolutions 
vary quite a bit, you should avoid specifying absolute sizes wherever possible. Instead, 
you should specify everything relative to the widths and heights available at runtime, 
including the widths and heights of the fonts being used. This will help a great deal in 
getting your application to run on a different model of BlackBerry. By doing things this 
way, you could go back and select a different font for your screen, and you wouldn’t 
have to change this layout method. 
After calling setExtent, the getWidth and getHeight methods in your field will return the 
values you set; this is how the manager containing this field will now how to lay out the 
field in relation to all the other fields it manages and how it will know how much space to 
give the field to paint.  

CHAPTER 5:  Beyond the Basics of User Interfaces 
84 
Adding the Paint Method 
To draw text to the display, just use the following: 
    protected void paint(Graphics graphics) { 
        graphics.drawText(label, 0, 0); 
    } 
You don’t have to worry about setting a specific font. The Graphics object will have its 
font set to the field’s current font, meaning that the font that you set earlier in 
UiFunMainScreen is already the current font for this graphics object. Now, let’s set the 
foreground and background colors. Make sure to clear the field to the background color 
before you draw the text. 
    protected void paint(Graphics graphics) { 
        graphics.setBackgroundColor(backgroundColor); 
        graphics.clear(); 
        graphics.setColor(foregroundColor); 
        graphics.drawText(label, 0, 0); 
    } 
And that’s almost everything you need to do; in fact, at this point, you can try out the 
label field in the application.  
Trying Out the Label Field 
In The UiFunMainScreen, add an import to net.rim.device.api.ui.Color and in the 
constructor, replace this line 
    add(new LabelField("Please enter your credentials:")); 
with this one 
        add(new CustomLabelField 
          ("Please enter your credentials:", Color.WHITE, 0x999966, 0)); 
And the application will have a label with a different foreground and background 
(0x999966 is kind of a dark tan color), as shown in Figure 5–5. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
85 
 
Figure 5–5. Using your custom label 
Adding an Image 
Now you’ll add the ability to display an image to the left of the text. You’ll create another 
constructor with a Bitmap parameter, and if this is specified, the Bitmap will be drawn at 
the left edge of the field, and the text will be shifted over to accommodate it. Let’s start 
with the additional member variable and the alternate constructor. 
public class CustomLabelField extends Field { 
    private Bitmap image; 
    private String label; 
    private int foregroundColor; 
    private int backgroundColor; 
 
    public CustomLabelField(String label, int foregroundColor, 
            int backgroundColor, Bitmap image, long style) { 
        super(style); 
        this.label = label; 
        this.foregroundColor = foregroundColor; 
        this.backgroundColor = backgroundColor; 
        this.image = image; 
    } 
You’ll make a small change to the layout method to handle the case where the image is 
taller than the font. 
    protected void layout(int width, int height) { 
        if (image != null) { 
            setExtent(width, Math.max(image.getHeight(), getFont().getHeight())); 
        } 
        else { 

CHAPTER 5:  Beyond the Basics of User Interfaces 
86 
            setExtent(width, getFont().getHeight()); 
        } 
    } 
And you’ll need to make another small change to the paint method. If you were given a 
bitmap, you’ll draw it and set the x parameter to drawText to the right of the bitmap. 
You’re also doing something else here: if the bitmap is taller than the font, you want the 
text centered vertically. Similarly, if the font is taller, you want the bitmap centered 
vertically. The algorithm in both cases is the same. 
position = (Field height – item height) / 2 
This is a good one to keep at hand; you’ll end up using it often in your user interfaces (or 
the equivalent for horizontal centering).  
The new paint method looks like this: 
    protected void paint(Graphics graphics) { 
        graphics.setBackgroundColor(backgroundColor); 
        graphics.clear(); 
        graphics.setColor(foregroundColor); 
        if (image != null) { 
            int textY = (getHeight() - getFont().getHeight()) / 2; 
            int imageY = (getHeight() - image.getHeight()) / 2; 
            graphics.drawBitmap(0, imageY, image.getWidth(), image.getHeight(), 
                    image, 0, 0); 
            graphics.drawText(label, image.getWidth(), textY); 
        } 
        else { 
            graphics.drawText(label, 0, 0); 
        } 
    } 
Graphics.drawBitmap is another good method to know. Its parameters let you draw part 
of a bitmap or a full bitmap, and it automatically takes into account image transparency, 
as you’ll see when you put this new field to use with a partially transparent image. 
Trying the New CustomLabelField 
You’ll change UiFunMainScreen’s constructor again to use CustomLabelField’s new 
constructor. You’ll have to add a line to load the bitmap first, and add that bitmap to  
the project as before. You can get the image we’re using here from this book’s web site. 
The new lines for the constructor follow: 
        Bitmap loginImage = Bitmap.getBitmapResource("res/login_arrow.png"); 
        add(new CustomLabelField 
          ("Please enter your credentials:", Color.WHITE, 0x999966, loginImage, 0)); 
And running the application, you’ll see the image and text together, as illustrated in 
Figure 5–6. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
87 
 
Figure 5–6. The label showing your image 
Tying Up Some Loose Ends 
The field works now. In the end, when you’re building a field for your application, all that 
matters is that it works where you want it to work. You’ll fill in a couple of details here, 
though, to make the CustomLabelField truly complete and to illustrate a few additional 
concepts. 
First, there are two methods which you should override but don’t absolutely have to: 
getPreferredWidth and getPreferredHeight. These are used by some layout managers 
to help with determining field layout before a given field has had a chance to lay itself 
out. They let the manager know how much space the field needs ideally. There’s no 
guarantee the manager will give the field that much space or even call the methods, but 
they’re easy to implement for your field, so for completeness, you’ll implement them. 
Note that getPreferredHeight is just the same algorithm you used in layout. 
    public int getPreferredHeight() { 
        if (image != null) { 
            return Math.max(getFont().getHeight(), image.getHeight()); 
        } 
        else { 
            return getFont().getHeight(); 
        } 
    } 
The getPreferredWidth method is a bit trickier. Since you don’t know the width 
available, you’ll have to come up with a sensible value; in this case, you’ll use the total 
width of the text in the field’s font, plus the width of the image (if any). 

CHAPTER 5:  Beyond the Basics of User Interfaces 
88 
    public int getPreferredWidth() { 
        int width = getFont().getAdvance(label); 
        if (image != null) { 
            width += image.getWidth(); 
        } 
        return width; 
    } 
The Font.getAdvance method just tells you the width, in pixels, needed to render the 
given string in that font.  
Let's take another look at layout. Two parameters were passed in, but you ignored the 
height parameter. What if the available height is less than the height needed for the font 
or image? It turns out the BlackBerry API will let you set a height that’s bigger than the 
available height but will clip the field when it’s drawn. Basically the paint method would 
think it had more space than it actually did, which would definitely lead to some drawing 
bugs. Given your field and application, it’s unlikely you’ll ever actually run into problems 
with the available height, but it does come into play with other fields, so let’s modify the 
layout method to respect the height parameter. You can also take this opportunity to 
eliminate some code replication. Since getPreferredHeight uses exactly the same 
algorithm as layout, just call getPreferredHeight, and if the height passed to layout is 
less than that, cap the size at the smaller height. 
    protected void layout(int width, int height) { 
        setExtent(width, Math.min(height, getPreferredHeight())); 
    } 
Finally, what if the text is wider than the available width? This isn’t unlikely; with a 
slightly larger font, wider image, or narrower screen, you could run out of room easily. 
Right now, the text will just cut off wherever the screen ends, even in the middle of a 
letter. Without getting into anything fancy, like text wrapping, you can use another 
version of Graphics.drawText that allows you to specify the width available for the text 
and set a flag to draw an ellipsis (. . .) at the end of your text if it exceeds the given 
space. 
    protected void paint(Graphics graphics) { 
        graphics.setBackgroundColor(backgroundColor); 
        graphics.clear(); 
        graphics.setColor(foregroundColor); 
        if (image != null) { 
            int textY = (getHeight() - getFont().getHeight()) / 2; 
            int imageY = (getHeight() - image.getHeight()) / 2; 
            graphics.drawBitmap(0, imageY, image.getWidth(), image.getHeight(), 
                    image, 0, 0); 
            graphics.drawText(label, image.getWidth(), textY, DrawStyle.ELLIPSIS, 
                    getWidth()-image.getWidth()); 
        } 
        else { 
            graphics.drawText(label, 0, 0, DrawStyle.ELLIPSIS, getWidth()); 
        } 
    } 
Now, if the label is too long, at least it’ll look a bit better (see Figure 5–7). 
www.allitebooks.com

CHAPTER 5:  Beyond the Basics of User Interfaces 
89 
 
Figure 5–7. The CustomLabelField demonstrating the ellipsis 
Finally, let’s revisit the layout method briefly. You made the field always take up the 
entire width available to it. What if you didn’t want that behavior? How would the 
application using the field specify its behavior? Take a look at the field style flags 
available in the Field class. There’s one called USE_ALL_WIDTH. Let’s alter layout so that 
the label field only uses the full with of the screen if this flag is specified. The change is 
simple. 
    protected void layout(int width, int height) { 
        if ((getStyle() & Field.USE_ALL_WIDTH) == Field.USE_ALL_WIDTH) { 
            setExtent(width, Math.min(height, getPreferredHeight())); 
        } 
        else { 
            setExtent(getPreferredWidth(), getPreferredHeight()); 
        } 
    } 
Again, you can use getPreferredWidth, because it already provides the width of the 
image (if any) plus the text. 
Finally, to make sure the label on the login screen still spans the entire width, you’ll 
make a slight change to UiFunMainScreen’s constructor, to pass in Field.USE_ALL_WIDTH 
as the style flag. 
          add(new CustomLabelField 
            ("Please enter your credentials:", Color.WHITE, 0x999966, loginImage, 
Field.USE_ALL_WIDTH)); 
Congratulations, you’ve created your first custom field! You can take the appearance as 
far as you want (exploring the Graphics class may give you some ideas), but you 

CHAPTER 5:  Beyond the Basics of User Interfaces 
90 
understand the basics of building a field, except for one crucial piece: how to interact 
with the user. To illustrate that, you’ll replace your application’s buttons with something 
a bit different and learn how to create fields that a user can interact with. 
Creating a Custom Button Field 
To create your new buttons, you’ll again start from scratch. Because you just worked 
through the basics of drawing a field, let's focus only on areas that are different when 
creating an interactive field. 
Laying Out the Interface 
Let's start with the parts that you already know—the layout and paint methods. In this 
case, you want a size that’s a bit bigger than the text, because you’re going to draw a 
background for the button that extends beyond the text by a few pixels. 
You also want to leave one pixel of blank space around the outside of the button, so the 
two buttons appear well spaced when they’re next to each other on the screen. Figure 
5–8 illustrates the horizontal sizing of the button relative to the text; the vertical layout is 
similar. 
Figure 5–8. The horizontal dimensions of the custom button field 
So, for the layout method, just add 8 pixels (4 on each side) to the font advance for the 
button’s text, and add 8 pixels to the font height to get the field’s size. Create a new 
class called CustomButtonField; the initial code should look like the following: 
package com.beginningblackberry.uifun; 
import net.rim.device.api.ui.Color; 
import net.rim.device.api.ui.Field; 
import net.rim.device.api.ui.Graphics; 
import net.rim.device.api.ui.Keypad; 
public class CustomButtonField extends Field { 
    private String label; 
    private int backgroundColor; 
    private int foregroundColor; 

CHAPTER 5:  Beyond the Basics of User Interfaces 
91 
    public CustomButtonField(String label, int foregroundColor, 
            int backgroundColor, long style) { 
        super(style); 
        this.label = label; 
        this.foregroundColor = foregroundColor; 
        this.backgroundColor = backgroundColor; 
    } 
 
    public int getPreferredHeight() { 
        return getFont().getHeight() + 8; 
    } 
 
    public int getPreferredWidth() { 
        return getFont().getAdvance(label) + 8; 
    } 
 
    protected void layout(int width, int height) { 
        setExtent 
          (Math.min(width, getPreferredWidth()), Math.min(height, 
getPreferredHeight())); 
    } 
} 
Painting the Buttons 
Instead of clearing the whole field to the background color, you’ll just draw a rounded 
rectangle of the given background color, and draw the text on top of that. You’ll have to 
come back to paint when you make this field focusable, but for now, to get something 
on screen, the paint method looks like this: 
    protected void paint(Graphics graphics) { 
        graphics.setColor(backgroundColor); 
        graphics.fillRoundRect(1, 1, getWidth()-2, getHeight()-2, 12, 12); 
        graphics.setColor(foregroundColor); 
        graphics.drawText(label, 4, 4); 
    } 
Taking a Look 
Replace the ButtonFields in UiFunMainScreen with CustomButtonFields, and you’ll see 
how the buttons look so far. In UiFunMainScreen’s constructor, change the class for the 
button declarations from ButtonField to CustomButtonField. 
    CustomButtonField clearButton; 
    CustomButtonField loginButton; 
Then, in UiFunMainScreen’s constructor replace the following lines 
        clearButton = new ButtonField("Clear", ButtonField.CONSUME_CLICK); 
        clearButton.setChangeListener(this); 
        loginButton = new ButtonField("Login", ButtonField.CONSUME_CLICK); 
        loginButton.setChangeListener(this); 
with these lines 

CHAPTER 5:  Beyond the Basics of User Interfaces 
92 
        clearButton = new CustomButtonField("Clear", Color.WHITE, Color.LIGHTGRAY, 0); 
        clearButton.setChangeListener(this); 
        loginButton = new CustomButtonField("Login", Color.WHITE, Color.LIGHTGRAY, 0); 
        loginButton.setChangeListener(this); 
Running the application, you’ll see, as you should expect by now, your buttons drawn to 
the screen as illustrated in Figure 5–9. 
 
Figure 5–9. Two buttons, rounded rectangles with text—no surprises 
If you try to use the application now, however, you’ll notice a big difference; you can no 
longer select the buttons! 
Making the Button Focusable 
Because most BlackBerry devices use a trackball as their navigation method, the 
concept of focus is very important. The field with focus is the one that receives events 
from the user interface and has the first chance to respond to them. (Even the 
BlackBerry Torch preserves the notion of focus, though having focus is not as critical. 
When you lightly tap the screen on top of a field, it receives focus.) 
To make the button focusable, you’ll just override isFocusable in CustomButtonField to 
return true. 
    public boolean isFocusable() { 
        return true; 
    } 

CHAPTER 5:  Beyond the Basics of User Interfaces 
93 
Now, you’ll be able to move the focus down to the buttons, but the visual representation 
shown in Figure 5–10 is not what you want. 
 
Figure 5–10. Custom button fields with the default focus drawing behavior 
Drawing the Focus 
The default focus behavior for the BlackBerry is to invert pixels that are in the 
background color. This look is fine for many types of fields, but for your button field, you 
want to change the button to a color that the user specifies at instantiation time. 
First, add a couple of member variables, so you can specify the color of the focused 
button’s text and background. 
    private int focusedForegroundColor; 
    private int focusedBackgroundColor; 
 
    public CustomButtonField(String label, int foregroundColor, 
            int backgroundColor, int focusedForegroundColor, 
            int focusedBackgroundColor, long style) { 
        super(style); 
        this.label = label; 
        this.foregroundColor = foregroundColor; 
        this.backgroundColor = backgroundColor; 
        this.focusedForegroundColor = focusedForegroundColor; 
        this.focusedBackgroundColor = focusedBackgroundColor; 
    } 

CHAPTER 5:  Beyond the Basics of User Interfaces 
94 
Now, disable the default focus behavior so that blue rectangle isn’t drawn. To do this, 
just override drawFocus and have it do nothing. 
    protected void drawFocus(Graphics graphics, boolean on) { 
    } 
Field has a method called isFocus that lets you determine if the field is in focus while 
you’re painting. You’ll make use of this in your paint method to draw the button in 
different colors when it’s in focus. To illustrate a little bit more about drawing using the 
Graphics object, you’re also going to add a shine effect to your focused button by 
drawing a semitransparent white rounded rectangle on top of the button background. 
    protected void paint(Graphics graphics) { 
        if (isFocus()) { 
            graphics.setColor(focusedBackgroundColor); 
            graphics.fillRoundRect(1, 1, getWidth()-2, getHeight()-2, 12, 12); 
            graphics.setColor(Color.WHITE); 
            graphics.setGlobalAlpha(100); 
            graphics.fillRoundRect(3, 3, getWidth()-6, getHeight()/2, 12, 12); 
            graphics.setGlobalAlpha(255); 
            graphics.setColor(focusedForegroundColor); 
            graphics.drawText(label, 4, 4); 
        } 
        else { 
            graphics.setColor(backgroundColor); 
            graphics.fillRoundRect(1, 1, getWidth()-2, getHeight()-2, 12, 12); 
            graphics.setColor(foregroundColor); 
            graphics.drawText(label, 4, 4); 
        } 
    } 
Transparency is specified through the setGlobalAlpha method on the Graphics object. It 
takes an int that can range from 0 for fully transparent to 255 for fully opaque and 
affects all subsequent drawing operations with that Graphics object, so be sure to reset 
the alpha value to 255 before the end of your paint method, or you may see some 
strange effects in your application. 
Finally, you need to have the button repaint when its focus state changes. This doesn't 
happen automatically, so you need to override onFocus and onUnfocus to explicitly 
invalidate the field. Be sure to call the superclass versions of these methods to maintain 
the focus behavior. 
    protected void onFocus(int direction) { 
        super.onFocus(direction); 
        invalidate(); 
    } 
 
    protected void onUnfocus() { 
        super.onUnfocus(); 
        invalidate(); 
    } 
Changing the button initialization in UiFunMainScreen’s constructor, you’ll specify a 
green and yellow color scheme for your buttons if they have focus. 
        clearButton = new CustomButtonField 

CHAPTER 5:  Beyond the Basics of User Interfaces 
95 
          ("Clear", Color.WHITE, Color.LIGHTGRAY, Color.YELLOW, Color.GREEN, 0); 
        clearButton.setChangeListener(this); 
        loginButton = new CustomButtonField 
          ("Login", Color.WHITE, Color.LIGHTGRAY, Color.YELLOW, Color.GREEN, 0); 
        loginButton.setChangeListener(this); 
Now everything will look a lot better (see Figure 5–11). 
 
Figure 5–11. Custom focus appearance 
So now you have buttons that look as you want them to when focused, but when you 
click them, nothing happens. The final piece to put in place is to have each trackball or 
touch screen click fire a field-changed event. 
Handling Events 
Fortunately, the API makes event handling very easy. All you have to do is override 
navigationClick and call fieldChangeNotify. The API takes care of handling the listener 
and calling its fieldChanged method. 
    protected boolean navigationClick(int status, int time) { 
        fieldChangeNotify(0); 
        return true; 
    } 
The status parameter is unimportant for your purposes, but comparing it against values 
defined in net.rim.device.api.system.KeypadListener would let you determine if the 
Alt, Shift, or other keys were being pressed while the user clicked your field. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
96 
Returning true from this method lets the framework know that you handled this event, 
so no one else should respond to it. 
Finally, the BlackBerry ButtonField also fires an event when the user presses the Enter 
key while the field has focus. You’ll implement that behavior by overriding keyChar. 
    protected boolean keyChar(char character, int status, int time) { 
        if (character == Keypad.KEY_ENTER) { 
            fieldChangeNotify(0); 
            return true; 
        } 
        return super.keyChar(character, status, time); 
    } 
The Enter key is the only one this field should handle, so you fire a field changed event 
and return true if that’s the case. Otherwise, you call the superclass’s method that will 
allow other interested components to handle this keypress if they want. Trying it out, 
you’ll get the same results as with the BlackBerry ButtonField class, as shown in 
Figure 5–12. 
 
Figure 5–12. The fully functional CustomButtonField 
Now you’ve got a fully customized button field that acts like a built-in ButtonField.  

CHAPTER 5:  Beyond the Basics of User Interfaces 
97 
A Review of Custom Fields 
You can extend the concepts here to make your buttons include images, have different 
fonts, or anything else your application requires. The same concepts will also let you 
create many different types of fields. 
Remember, when implementing a field from scratch, you should be concerned with 
these methods: 
 paint 
 layout 
And when creating an interactive field, you should override at least these methods as 
well: 
 isFocusable 
 onFocus 
 onUnfocus 
 drawFocus 
 navigationClick 
 keyChar 
Creating Custom Managers 
Now, turn your attention to the username, password, and domain fields. You want the 
labels to line up to the right. To do that, you’ll have to make two changes. The first is 
easy—you’ll stop using the built-in labels of the EditFields and ObjectChoiceField and 
replace them with LabelFields. You’ll use HorizontalFieldManagers as you do for the 
buttons to keep the labels and edit fields on the same line. The new code for the rest of 
UiFunMainScreen constructor, starting from the instantiation of userNameField, is as 
follows: 
        usernameField = new EditField("", ""); 
        LabelField usernameLabel = new LabelField("Username:", Field.FIELD_RIGHT); 
        HorizontalFieldManager usernameManager = new HorizontalFieldManager(); 
        usernameManager.add(usernameLabel); 
        usernameManager.add(usernameField); 
        passwordField = new PasswordEditField("", ""); 
        LabelField passwordLabel = new LabelField("Password:", Field.FIELD_RIGHT); 
 
        HorizontalFieldManager passwordManager = new HorizontalFieldManager(); 
        passwordManager.add(passwordLabel); 
        passwordManager.add(passwordField); 
        domainField = new ObjectChoiceField("", new String[] {"Home", "Work"}); 
        LabelField domainLabel = new LabelField("Domain:", Field.FIELD_RIGHT); 
        HorizontalFieldManager domainManager = new HorizontalFieldManager(); 
        domainManager.add(domainLabel); 
        domainManager.add(domainField); 

CHAPTER 5:  Beyond the Basics of User Interfaces 
98 
add(usernameManager); 
        add(passwordManager); 
        add(domainManager); 
You’ve given the labels the Field.FIELD_RIGHT style, which will be important later but 
doesn’t affect the appearance because of the way the horizontal field managers 
function in this configuration. The appearance of the application is the same as before, 
but the horizontal field managers are outlined to clarify the discussion that will follow 
(see Figure 5–13). 
 
Figure 5–13. Separate labels and fields in horizontal field managers 
One quick way to get the labels and fields to line up the way you want them is to create 
two vertical field managers, one for the labels and one for the fields. You can rely on the 
fact that the fields and labels are the same height to make them line up vertically. The 
two vertical field managers go inside one horizontal field manager, which is added to the 
screen. We’re not going to pursue this, but for illustrative purposes Figure 5–14 shows 
how the screen looks, again with the managers outlined. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
99 
 
Figure 5–14. Using vertical field managers to line up the components 
That looks pretty good. So what’s the problem? You’re relying on the fact that the label 
fields are the same height as the other fields. This is not guaranteed—a fact we can 
illustrate by typing in a long username, as shown in Figure 5–15. 
 
Figure 5–15. Knocking the fields out of alignment 

CHAPTER 5:  Beyond the Basics of User Interfaces 
100 
What you really want is a grid of labels and fields. You’ll do this by creating a grid field 
manager. 
Creating a Manager 
Managers are, in many ways, simpler to implement than fields. You’re only required to 
implement one method, sublayout, and unless you’re doing something really complex, 
the basic net.rim.device.api.ui.Manager paint method will still work and draw your 
fields wherever you positioned them.  
Managers do have to be concerned with things like moving the focus from field to field, 
but if you’re clever enough about things, you won’t have to worry about handling that 
yourself either. The functionality that net.rim.device.api.ui.Manager provides will be 
enough. 
Understanding GridFieldManager  
GridFieldManager under the package net.rim.device.api.ui.container is a field that 
you can use if you need a table or grid control in your screen. This field is an extension 
of the Manager class. To illustrate how easy it is to create your own custom field layout 
using the Manager class, you'll create your own GridFieldManager. Your 
GridFieldManager will let the user specify a number of grid columns when it’s 
instantiated. The number of rows will vary depending on the number of fields added. 
For a horizontal or vertical manager, it’s clear where fields are positioned, either left to 
right or top to bottom in the order they’re added (ignore insert for now). For a grid 
manager, it’s not as clear which way you should add them. Should they be added left to 
right, then top to bottom, or the other way around? Let's just choose to go left to right 
and then top to bottom, as shown in Figure 5–16.  
Figure 5–16. This is the field layout for the grid manager; the numbers represent the order the fields are added to 
the manager. 
Implementing the Basic Framework 
You’ll subclass directly from net.rim.device.api.ui.Manager and build the Manager from 
scratch. The only thing you’ll need to keep track of is the number of columns. The 
Manager class already maintains the list of fields for you. 
package com.beginningblackberry.uifun; 
import net.rim.device.api.ui.Field; 
import net.rim.device.api.ui.Manager; 
public class GridFieldManager extends Manager { 
    private int numColumns; 

CHAPTER 5:  Beyond the Basics of User Interfaces 
101 
    public GridFieldManager(int numColumns, long style) { 
        super(style); 
        this.numColumns = numColumns; 
    } 
 
    protected void sublayout(int width, int height) { 
    } 
} 
Implementing the Sublayout Method 
All the magic in a manager happens in the sublayout method. It’s similar to a field’s 
layout method, down to the requirement that you call setExtent within the method to 
set the manager’s size (and in fact, behind the scenes, the manager’s layout method 
calls sublayout). Remember, a manager is ultimately a type of field. 
The other requirement in a manager’s sublayout method is that you position and size all 
the fields contained by the manager. This is done through the layoutChild and 
setPositionChild methods. The layoutChild method will result more or less directly in a 
call to the child field’s layout method, meaning that before you call layoutChild the 
child field will return 0 from getWidth and getHeight.  
Here’s where you have to think about exactly how you’ll determine how wide each 
column should be. In this case, you’re using the manager in a limited fashion, and you 
control how it’s used. Therefore, you can make some assumptions about the types of 
fields that will be contained; specifically, you can ensure that fields will in general all be 
able to fit in a row across the screen. When designing general-purpose managers, many 
of these design decisions can quickly become very complex; it’s usually good practice 
to keep in mind where you’re going to be using your manager and design to that, rather 
than attempting to design for the general case right away. 
You’ll also assume that you don’t have to worry about having enough vertical space for 
the manager. In fact, if you end up in a constrained vertical space, the manager will just 
be cut off at the bottom, and it’s not certain that you could really do much better than 
that. 
So your manager’s sublayout method will do the following: 
1. Go through the fields in the first (leftmost) column and call layoutChild on each 
one to get an accurate width and height. 
2. Determine the width of the first column from the maximum width of all the fields. 
3. Subtract that width from the total available, and continue to the fields in each 
column in turn, left to right. 
4. Set the position for all fields in the first row based on the column widths. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
102 
5. Set the position for all fields in the second row based on the column widths and 
the maximum height of all the fields in the first row, and continue top to bottom 
for all the rows. 
6. Set the extent of the field based on the total width of all columns and the total 
height of all rows. 
Clear? Here’s how all the code looks: 
    protected void sublayout(int width, int height) { 
        int[] columnWidths = new int[numColumns]; 
        int availableWidth = width; 
        int availableHeight = height; 
 
        // For each column size all the fields and get the maximum width 
        for(int column = 0; column < numColumns; column++) { 
            for 
            (int fieldIndex = column; fieldIndex < getFieldCount(); fieldIndex += 
numColumns){ 
                Field field = getField(fieldIndex); 
                layoutChild(field, availableWidth, availableHeight); 
                if (field.getWidth() > columnWidths[column]) { 
                    columnWidths[column] = field.getWidth(); 
                } 
 
            } 
 
            availableWidth -= columnWidths[column]; 
        } 
 
        int currentRow = 0; 
        int currentRowHeight = 0; 
        int rowYOffset = 0; 
 
        // Set the position of each field 
        for(int fieldIndex = 0; fieldIndex < getFieldCount(); fieldIndex++) { 
            Field field = getField(fieldIndex); 
            if (fieldIndex % numColumns == 0) { 
                setPositionChild(field, 0, rowYOffset); 
            } 
            else { 
                setPositionChild 
                  (field, columnWidths[(fieldIndex % numColumns) - 1], rowYOffset); 
            } 
 
            if (field.getHeight() > currentRowHeight) { 
                currentRowHeight = field.getHeight(); 
            } 
 
            if (fieldIndex % numColumns == numColumns - 1) { 
                currentRow ++; 
                rowYOffset += currentRowHeight; 
                currentRowHeight = 0; 
            } 
        } 
 
        int totalWidth = 0; 
        for(int i = 0; i < numColumns; i++) { 

CHAPTER 5:  Beyond the Basics of User Interfaces 
103 
            totalWidth += columnWidths[i]; 
        } 
        setExtent(totalWidth, rowYOffset + currentRowHeight); 
    } 
There’s a lot to this method, so let’s walk through it. The first for loop iterates through 
all the fields in the manager, one column at a time, and calls layoutChild on each one to 
set its size. 
for(int column = 0; column < numColumns; column++) { 
  for(int fieldIndex = column; fieldIndex < getFieldCount(); fieldIndex += numColumns) { 
If you have a two-column grid with six fields, you go through the fields in this order 
(starting with 0): 
Column 0: 
   0 
   2 
   4 
Column 1: 
   1 
   3 
   5 
For each column, you lay out all the fields in whatever width you have available, and 
then take the maximum width as the column width. You subtract that width from the 
total remaining width to get the available width for the next columns. 
Once you’ve determined the column widths, the next for loop again goes through all the 
fields in the manager to position them on screen using setPositionChild. 
for(int fieldIndex = 0; fieldIndex < getFieldCount(); fieldIndex++) { 
            Field field = getField(fieldIndex); 
            if (fieldIndex % numColumns == 0) { 
                setPositionChild(field, 0, rowYOffset); 
            } 
            else { 
                setPositionChild 
                  (field, columnWidths[(fieldIndex % numColumns) - 1], rowYOffset); 
            } 
You have the column widths already so you know where they should be positioned 
horizontally. As you lay out each row, keep track of the field with the largest height in 
that row, and use that as the row height. 
            if (field.getHeight() > currentRowHeight) { 
                currentRowHeight = field.getHeight(); 
            } 
When you’re at the last field of a row (where the index is one less than a multiple of the 
number of columns), you shift the vertical position for the next row downward, and start 
over again. 
            if (fieldIndex % numColumns == numColumns - 1) { 
                currentRow ++; 
                rowYOffset += currentRowHeight; 
                currentRowHeight = 0; 
            } 

CHAPTER 5:  Beyond the Basics of User Interfaces 
104 
Finally, you set the size for the manager by adding up all the column widths and taking 
the total of all the row heights. 
        int totalWidth = 0; 
        for(int i = 0; i < numColumns; i++) { 
            totalWidth += columnWidths[i]; 
        } 
        setExtent(totalWidth, rowYOffset + currentRowHeight); 
Seeing the Grid Field Manager in Action 
OK, now let’s see how the grid looks. You’ll modify UiFunMainScreen’s constructor again 
to use the grid field manager to hold the separate labels and edit fields. 
        usernameField = new EditField("", ""); 
        LabelField usernameLabel = new LabelField("Username:", Field.FIELD_RIGHT); 
        passwordField = new PasswordEditField("", ""); 
        LabelField passwordLabel = new LabelField("Password:", Field.FIELD_RIGHT); 
 
        domainField = new ObjectChoiceField("", new String[] {"Home", "Work"}); 
        LabelField domainLabel = new LabelField("Domain:", Field.FIELD_RIGHT); 
 
        GridFieldManager gridFieldManager = new GridFieldManager(2, 0); 
        gridFieldManager.add(usernameLabel); 
        gridFieldManager.add(usernameField); 
        gridFieldManager.add(passwordLabel); 
        gridFieldManager.add(passwordField); 
        gridFieldManager.add(domainLabel); 
        gridFieldManager.add(domainField); 
 
        add(gridFieldManager); 
Remember, because you’ve instantiated a two-column grid, the labels will all appear in 
the left column and the edit fields on the right.  
Start the simulator, and you should see something like Figure 5–17. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
105 
 
Figure 5–17. Using the first version of the grid field manager 
You’re doing better already. The username can wrap, and all the labels stay aligned with 
the field. Incidentally, if you’re paying attention, you might realize that when the text in 
the username field wraps, it causes the screen’s layout method to be run again. This 
behavior is fine and expected: layout happens infrequently, but it does happen. 
Aligning the Labels 
There’s one problem, though. While the edit fields are aligned properly, the labels are 
still aligned to the left, rather than the right, despite the fact that you gave them the 
Field.FIELD_RIGHT styles. Remember earlier that we mentioned that styles were 
dependent on the field and the manager? The GridFieldManager has to explicitly 
support the FIELD_RIGHT style to get the alignment to work the way you expect it to. The 
change is simple. If the field has the FIELD_RIGHT style set, you just need to shift it to the 
right by the width of the column minus the width of the field. In sublayout, replace the 
following lines 
            if (fieldIndex % numColumns == 0) { 
                setPositionChild(field, 0, rowYOffset); 
            } 
            else { 
                setPositionChild 
                  (field, columnWidths[(fieldIndex % numColumns) - 1], rowYOffset); 
            } 
with these 

CHAPTER 5:  Beyond the Basics of User Interfaces 
106 
            int fieldOffset = 0; 
            if ((field.getStyle() & Field.FIELD_RIGHT) == Field.FIELD_RIGHT) { 
                fieldOffset = columnWidths[fieldIndex % numColumns] - field.getWidth(); 
            } 
            if (fieldIndex % numColumns == 0) { 
                setPositionChild(field, 0 + fieldOffset, rowYOffset); 
            } 
            else { 
                setPositionChild 
                  (field, columnWidths[(fieldIndex % numColumns) - 1] + fieldOffset, 
rowYOffset); 
            } 
Now, the manager positions all of the label fields correctly (see Figure 5–18). 
 
Figure 5–18. The labels are aligned on the right. Notice that wrapping is supported for the password  
field, too. 
If you wanted to support Field.FIELD_HCENTER, the change would be similar. We’ll leave 
that as an exercise for you. 
Focus Movement 
If you play with this application, you’ll notice that the focus moves as you’d expect it to: 
when the cursor is in the username field, scrolling down or right will move the cursor to 
the password field and then to the domain drop-down. This is because of the default 
focus movement behavior, which is to use the order the fields are added to the manager 

CHAPTER 5:  Beyond the Basics of User Interfaces 
107 
as the focus order and to move to later fields in the focus order when the trackball is 
moved right or down and to earlier fields when the trackball is moved left or up.  
This behavior wouldn’t work if you had more than one column of focusable fields in your 
manager. Imagine you have two columns of focusable fields. Figures 5–19 through 5–22 
illustrate the focus movement problems. The numbers represent the order in which the 
fields are added to the grid field manager. 
 
Figure 5–19. The grid field manager with six fields. Fields  2, 3, 5, and 6 are focusable. 
 
Figure 5–20. Field 2 has focus initially. 
 
Figure 5–21. A rightward trackball movement correctly moves the focus from field 2 to field 3. 
 
Figure 5–22. A downward trackball movement moves the focus from field 3 to field 5, which is not the behavior 
you expect. 
This problem exists because the default focus-moving algorithm doesn’t take into 
account field position on the screen, only field order within the manager. So moving right 
and down are considered to be the same action. You can fix this by overriding 
navigationMovement in the manager, but the discussion about how to do so is beyond 
the scope of this book. The source code available on the book’s web site includes a 
sample implementation for moving focus in a grid field. 
Tidying Up the Login Success Screen 
Now that you’ve got a few components, let’s revisit LoginSuccessScreen. First, let's add 
the following import statements: 
import net.rim.device.api.ui.component.SeparatorField; 
import net.rim.device.api.ui.Color; 
import net.rim.device.api.ui.Field; 
import net.rim.device.api.ui.Font; 
import net.rim.device.api.ui.FontFamily; 
import net.rim.device.api.ui.Ui; 
1
2
5
6
3
4
1
2
3
6
5
4
1
3
2
6
5
4
1
2
3
6
5
4

CHAPTER 5:  Beyond the Basics of User Interfaces 
108 
With some simple modifications to the constructor to use your CustomLabelField and 
GridFieldManager, you can make the screen look a little better. 
    public LoginSuccessScreen(String username, String domain) { 
        try { 
            FontFamily alphaSansFamily = FontFamily.forName("BBAlpha Serif"); 
            Font appFont = alphaSansFamily.getFont(Font.PLAIN, 9, Ui.UNITS_pt); 
            setFont(appFont); 
        } catch (ClassNotFoundException e) { 
        } 
 
        add(new CustomLabelField("Logged In!", Color.WHITE, 0x999966, 
Field.USE_ALL_WIDTH)); 
        add(new SeparatorField()); 
        GridFieldManager gridFieldManager = new GridFieldManager(2, 0); 
        gridFieldManager.add 
          (new CustomLabelField("Username:", Color.BLACK, Color.WHITE, 
Field.FIELD_RIGHT)); 
        gridFieldManager.add 
          (new CustomLabelField(username, Color.BLACK, Color.LIGHTGRAY, 
Field.USE_ALL_WIDTH)); 
        gridFieldManager.add 
          (new CustomLabelField("Domain:", Color.BLACK, Color.WHITE, 
Field.FIELD_RIGHT)); 
        gridFieldManager.add 
          (new CustomLabelField(domain, Color.BLACK, Color.LIGHTGRAY, 
Field.USE_ALL_WIDTH)); 
        add(gridFieldManager); 
    } 
Here, you’ve moved the username and domain labels and values into a grid, similar to 
the main screen. Notice that you’ve given the right column labels the 
Field.USE_ALL_WIDTH value, which, in combination with the sublayout method of the grid 
field manager, will make them use the entire screen width except for the space taken by 
the first column. Go back and see if you can figure out why, and try to figure out what 
would happen if you applied Field.USE_ALL_WIDTH to the labels for the first column. 
One last thing before you run the app: in the UiFunMainScreen.login method, reenable 
LoginSuccessScreen by uncommenting the lines that instantiates loginSuccessScreen 
and push the loginSuccessScreen instead of new Album. This portion of the code should 
look like this: 
        LoginSuccessScreen loginSuccessScreen =  
                new LoginSuccessScreen(username, selectedDomain); 
            UiApplication.getUiApplication().pushScreen(loginSuccessScreen); 
Now, run the app, enter the username and password, and click Login. You'll see a 
screen that look something like Figure 5–23. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
109 
 
Figure 5–23. The redone login success screen 
You should now be familiar with how to make fields and managers. That leaves one 
more piece of the visual BlackBerry user interface to cover: screens. 
Creating a Custom Screen 
You’re actually using three screens in your UI Fun application already. Two are obvious: 
UiFunMainScreen and the login success screen. The third is the dialog that appears when 
you try to log in without entering a username and password (see Figure 5–24). 
 
Figure 5–24. The login dialog is a screen, too. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
110 
A screen on the BlackBerry doesn’t have to take up the entire display; other screens can 
be visible below it. All screens, however, do take over the user input. That is, any 
keypresses, trackball presses, or touch screen taps only go to whatever screen is 
currently active and on top of the display stack. The active screen is also the one that 
controls the menu. 
All screens are derived from net.rim.device.api.ui.Screen. Let's create a custom 
dialog to replace the default one, if for no other reason than you want to use your own 
colors and font and replace the OK button with a custom button field. 
Name the new screen CustomDialog (you should be seeing a pattern in the names by 
now) and directly subclass Screen. There is a PopupScreen class in 
net.rim.device.api.ui.container, but it adds some things that you don’t want, like a 
border. The basic code looks like this: 
package com.beginningblackberry.uifun; 
import net.rim.device.api.ui.Screen; 
import net.rim.device.api.ui.container.VerticalFieldManager; 
public class CustomDialog extends Screen { 
    public CustomDialog(String message) { 
        super(new VerticalFieldManager()); 
    } 
    protected void sublayout(int width, int height) { 
    } 
} 
Right away, you should notice two things. First, you’re required to implement sublayout; 
this will actually be much easier than with a manager. Second, you’re required to pass a 
Manager to Screen’s constructor. This is the delegate manager. 
Delegate Managers 
A screen doesn’t directly lay out any of its fields. Instead, it delegates that to a manager 
that’s specified when the screen is instantiated. All the manager methods on the screen 
(add, delete, insert, etc.) actually end up invoking the same methods on the delegate 
manager. The only component the screen handles directly is the delegate manager. This 
separation of manager and screen makes it easy to change the internal layout of any 
screen. This also means that a screen must have a delegate manager at all times, so it 
must be specified at instantiation time and can never be changed. The delegate 
manager can be any valid Manager class, as there are no extra requirements above what 
a regular Manager does. 
Implementing the Screen’s Sublayout Method 
As discussed, the screen’s sublayout method needs to worry about only the delegate 
manager. This is accessible through the getDelegate method. There are a couple of 
special methods in Screen that allow you to lay out the delegate manager and position it. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
111 
These methods work the same as the methods to set field position and size in any other 
manager. In addition to this, the sublayout method needs to set the extent of the screen 
(just as with any field) and set the position of the screen on the display. The width and 
height parameters passed into the sublayout method of a screen will always be the 
width and height of the device’s display (on a device with a rotatable display, like the 
BlackBerry Torch, these will represent the current orientation of the screen).  
Note that setPosition sets the position of the screen relative to the device’s display; 
that is, setPosition(10, 10) will position the screen 10 pixels from the top-left corner of 
the display. setPositionDelegate sets the position of the delegate manager relative to 
the screen’s position. 
You’re going to give the delegate manager slightly less room than is available to ensure 
the screen’s contents don’t take up the entire screen and to leave room to draw a 
border around the screen. When you’ve determined the size of the delegate, you set the 
actual size of the screen accordingly. 
  protected void sublayout(int width, int height) { 
    layoutDelegate(width - 80, height - 80); 
    setPositionDelegate(10, 10); 
    setExtent(width - 60, Math.min(height - 60, getDelegate().getHeight() + 20)); 
    setPosition(30, (height - getHeight())/2 - 30); 
  } 
You’re leaving 30 pixels to the left and right of the screen and a minimum of 30 to the 
top and bottom, though if the delegate is small, you’ll have more space. You’re also 
leaving a 10-pixel border on all sides between the edges of the screen and the edges of 
the delegate manager for space to draw the border. 
Let’s add a LabelField to the constructor and make a change in UiFunMainScreen to see 
this in action. First, add an import statement in the CustomDialog class for 
net.rim.device.api.ui.component.LabelField and then edit CustomDialog’s 
constructor. 
    public CustomDialog(String message) { 
        super(new VerticalFieldManager(), Screen.DEFAULT_CLOSE); 
        add(new LabelField(message)); 
    } 
The add method here actually delegates to the VerticalFieldManager constructed on the 
preceding line. Also, you’ve added the Screen.DEFAULT_CLOSE style so that pressing the 
escape button will close this screen. 
In UiFunMainScreen, modify the login method by replacing the line that shows the dialog 
            Dialog.alert("You must enter a username and password"); 
with the following line to instantiate and show the custom dialog 
            UiApplication.getUiApplication().pushModalScreen 
              (new CustomDialog("You must enter a username and password")); 
Now, run the application, and click the Login button (or menu item). You’ll see a basic 
screen like the one in Figure 5–25. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
112 
 
Figure 5–25. Basic custom dialog 
Right now, there’s not much too it—just a white square with the LabelField on it, but it 
is a screen. Try typing, and you’ll notice that the rest of the application doesn’t respond. 
The custom dialog is intercepting all the keypresses. Pressing the escape key will 
dismiss the dialog. 
Adding a Few Fields 
You’ll modify the constructor to add an OK button and a separator field to fill out the 
dialog. You’ll also set the font while you’re at it. The following is the new constructor: 
    public CustomDialog(String message) { 
        super(new VerticalFieldManager(), Screen.DEFAULT_CLOSE); 
        try { 
            FontFamily alphaSansFamily = FontFamily.forName("BBAlpha Serif"); 
            Font appFont = alphaSansFamily.getFont(Font.PLAIN, 9, Ui.UNITS_pt); 
            setFont(appFont); 
        } catch (ClassNotFoundException e) { 
        } 
 
        add(new LabelField(message)); 
 
        add(new SeparatorField()); 
 
        okButton = new CustomButtonField 
        ("OK", Color.WHITE, Color.LIGHTGRAY, Color.YELLOW, Color.GREEN, 
Field.FIELD_HCENTER); 
        okButton.setChangeListener(this); 
        add(okButton); 
    } 

CHAPTER 5:  Beyond the Basics of User Interfaces 
113 
You’re using the same color scheme for the OK button as with the buttons on 
UiFunMainScreen. You’ll also have to make CustomDialog implement 
FieldChangeListener and provide an appropriate fieldChanged method. 
 
public class CustomDialog extends Screen implements FieldChangeListener { 
    private CustomButtonField okButton; 
 
    //... 
 
    public void fieldChanged(Field field, int context) { 
        if (field == okButton) { 
            close(); 
        } 
    } 
Painting the Background 
Just to illustrate the concept, you’ll draw a simple background consisting of a rounded 
rectangle in the tan color outlined in black. The paintBackground method is the place to 
do this; you won’t interfere with painting of the fields, which is already handled just fine 
by the Screen class. 
    protected void paintBackground(Graphics graphics) { 
        graphics.setColor(0x999966); 
        graphics.fillRoundRect(0, 0, getWidth(), getHeight(), 12, 12); 
        graphics.setColor(Color.BLACK); 
        graphics.drawRoundRect(0, 0, getWidth(), getHeight(), 12, 12); 
    } 
Resolve the compilation error by importing net.rim.device.api.ui.Graphics. Now, run 
the application again and take a look at the completed dialog (see  
Figure 5–26). 

CHAPTER 5:  Beyond the Basics of User Interfaces 
114 
 
Figure 5–26. The completed custom dialog 
The border between the outside edge of the screen and the delegate manager is now 
apparent by looking at the label and separator fields. Clicking OK will close the dialog, 
as you’d expect. 
Adding the Final Touches  
You’re almost there. All that’s left is to change the color of the background behind the 
logo image and make a couple of minor tweaks to alignment. We’ve left this section until 
almost the end of this chapter, because there’s not a lot new here; you’re just applying 
concepts that you already know. 
Adding a Header Background 
You want to put a black background behind the header image and align the image to the 
left. The second change is easy; simply change the style Field.FIELD_HCENTER to 
Field.FIELD_LEFT (or leave it out entirely, as FIELD_LEFT is the default). 
To make the image sit on a different color background, you’ll put the BitmapField inside 
another manager and let that manager draw the background color. You’ll use a 
HorizontalFieldManager. This first part should be familiar to you by now. Change the 
following lines in the UiFunMainScreen constructor: 
        Bitmap logoBitmap = Bitmap.getBitmapResource("res/apress_logo.png"); 
        bitmapField = new BitmapField(logoBitmap, Field.FIELD_LEFT); 

CHAPTER 5:  Beyond the Basics of User Interfaces 
115 
        HorizontalFieldManager hfmLabel = new 
HorizontalFieldManager(Field.USE_ALL_WIDTH); 
        hfmLabel.add(bitmapField); 
        add(hfmLabel); 
The background is still white, but you’ve set the stage to change it. Now, there are two 
ways you can go about providing a black background. We’ll cover both methods briefly. 
Subclassing HorizontalFieldManager  
There’s a simple Java construct called an anonymous inner class that lets you define a 
class at the same time as you instantiate it, if you need only one instance of the new 
class, as you do here. Replace the new HorizontalFieldManager line with the following 
lines: 
        HorizontalFieldManager hfmLabel = new 
HorizontalFieldManager(Field.USE_ALL_WIDTH) { 
            protected void paint(Graphics graphics) { 
                graphics.setBackgroundColor(Color.BLACK); 
                graphics.clear(); 
                super.paint(graphics); 
            } 
        }; 
Again, resolve the compilation error by importing Graphics. This code redefines the 
paint method only for this instance of HorizontalFieldManager. The new paint method 
is simple. It just clears the entire background of the manager to black and then calls 
super.paint to draw the rest of the manager as before.  
Using Background and BackgroundFactory  
Subclassing HorizontalFieldManager to override the paint method and draw your own 
background is well and good but there's a better way. You can use borders and 
backgrounds classes, which can be used to modify the appearance of UI components. 
The border and background classes can be found in the net.rim.device.api.ui.decor 
package. You’re interested in BackgroundFactory and Background, so import the two 
classes. The code is pretty self-explanatory—you create a solid black background, and 
attach it to your HorizontalFieldManager. 
        HorizontalFieldManager hfmLabel = new 
HorizontalFieldManager(Field.USE_ALL_WIDTH); 
        Background blackBackground = 
BackgroundFactory.createSolidBackground(Color.BLACK); 
        hfmLabel.setBackground(blackBackground); 
Both the subclass method and the background method produce the same result, which 
is shown in Figure 5–27. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
116 
 
Figure 5–27. A black background for your image 
Making Minor Tweaks 
Just to complete the look you wanted, you’ll do a couple of small things. First, you want 
the labels to be indented from the left side a bit—you’ll accomplish that just by adding a 
few spaces to the beginning of the Username label—since everything is in a grid layout, 
the other fields will still line up with the right side of the label. 
LabelField usernameLabel = new LabelField("   Username:", Field.FIELD_RIGHT); 
The code above will do just fine because your needs are a bit simple. However, if you 
use this approach on many fields with different fonts, you will not achieve the same 
indentation you want on all of the fields. The best approach if you are using RIM API 
version 6.0 and above is to use either setMargin or setPadding methods. 
Implementation of these methods is relegated to the field manager.  
You can use setMargin if you want a number of pixels of empty area added outside the 
field. Or you can use setPadding if you want a number of pixels of empty area within the 
field itself. In this case, setMargin is appropriate. 
Going back to the code, your main screen is exactly as you wanted to see it, as 
illustrated in Figure 5–28. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
117 
 
Figure 5–28. The finished UI Fun main screen 
Working with Touch Screen Models 
In most of the work we’ve done so far, we’ve mentioned the trackpad many times, as 
most BlackBerry devices are trackpad devices after all. But what about the BlackBerry 
Torch with its touch screen? 
The good news is that, if you construct your components the way we’ve done here, 
everything will work as you’d expect on a touch screen device. The BlackBerry 
operating system maps touch events to appropriate focus or navigation click events on 
your screens and fields, so as long as you’re working at the level of those methods, you 
don’t have to do any extra work to be compatible with the touch screen input method. 
Your code won’t have to change. 
The other feature of the Torch is that you can use it in vertical and horizontal orientation. 
The good news is that, since you’ve used relative positioning everywhere, your 
application will look good automatically on the Torch in both vertical and horizontal 
orientation (see Figures 5–29 and 5–30). 

CHAPTER 5:  Beyond the Basics of User Interfaces 
118 
 
Figure 5–29. UI Fun running on the BlackBerry Torch simulator in vertical orientation 
 
Figure 5–30. UI Fun running on the BlackBerry Torch simulator in a horizontal orientation 

CHAPTER 5:  Beyond the Basics of User Interfaces 
119 
When the device is rotated, the sublayout and layout methods will automatically be 
called, and it’ll have a chance to adjust the screen layout to the new width and height. 
The virtual keyboard will also automatically be displayed whenever the focus is on a text 
edit field.  
Creating Basic Animation 
We’re going to spend a little bit of time on a topic that can really make your user 
interface shine: animation. This topic is more advanced. Though an app looks fine 
without animation, having  screen transitions and other effects will make it look fancy 
and help it stand out among the competition, plus it's fun doing animations. And going 
through the exercise in this section will teach you a bit more about how the BlackBerry 
UI API works, so we recommend you at least read through it. 
In your application, when you click the Login button, the login screen instantly appears; 
it doesn’t fade in, slide in, or anything like that. You’ll modify UiFun so that when the user 
logs in (clicks the Login button after typing a username and password), the login 
success screen slides up from the bottom of the display. 
The basic idea for user interface animation is to pick an aspect of the user interface to 
animate (size, position, transparency) and a time for the animation to take place (for 
example, 300 milliseconds for a screen to slide onto the display). Then, in each update 
of the user interface, check if the animation time has elapsed: if not, update the user 
interface aspect according to how much time has passed, and queue up another UI 
update. Using time-based animation like this means that the animation will run as 
smoothly as possible across different device models and under different conditions and 
will always take the same amount of time to complete. 
Setting the Vertical Offset 
To get the animation started, add a new variable to LoginSuccessScreen called 
verticalOffset. 
    private int verticalOffset; 
You’ll update this variable during the animation, decrementing it from the display height 
to zero. You’ll also add another variable and a constant final variable to keep track of 
how much time has passed in your animation and how long the animation should be. In 
this case, let's use 300 milliseconds, as generally somewhere between 200 and 300 
milliseconds gives a decent user experience. 
    private final static long animationTime = 300; 
    private long animationStart = 0; 
The animation logic all occurs within sublayout. It’ll only run the animation code if 
verticalOffset is greater than zero; that is, only if the screen is not all the way onto the 
display. 

CHAPTER 5:  Beyond the Basics of User Interfaces 
120 
If verticalOffset is greater than zero, it’ll check the current time against the 
animationStart time. Based on the ratio of the elapsed time to the total time for the 
animation, it’ll set a new value for verticalOffset. 
Finally, after updating the screen’s position, it’ll queue another update layout if 
verticalOffset is still not zero by calling UiApplication.invokeLater. 
Animating the Layout 
Add import statements for Display and UiApplication. The code for sublayout follows: 
    protected void sublayout(int width, int height) { 
        super.sublayout(width, height); 
        if (verticalOffset > 0) { 
            if (animationStart == 0) { 
                // start the animation 
                animationStart = System.currentTimeMillis(); 
            } 
            else { 
                long timeElapsed = System.currentTimeMillis() - animationStart; 
                if (timeElapsed >= animationTime) { 
                    verticalOffset = 0; 
                } 
                else { 
                    float percentDone = (float)timeElapsed / (float)animationTime; 
                    verticalOffset =  
                      Display.getHeight() - (int)(percentDone * Display.getHeight()); 
                } 
            } 
        } 
        setPosition(0, verticalOffset); 
        if (verticalOffset > 0) { 
            UiApplication.getUiApplication().invokeLater(new Runnable() { 
                public void run() { 
                    updateLayout(); 
                } 
            }); 
        } 
    } 
Notice that there’s an initial case where animationStart is zero. This case represents the 
first frame of the animation, so just leave verticalOffset where it is. 
Speaking of verticalOffset, you’ll initialize it in the LoginScreen constructor to the 
height of the display. 
        verticalOffset = Display.getHeight(); 
        new Thread(this).start(); 
You also need to make LoginSucessScreen implement the Runnable interface , so you 
can run the screen on a Thread. Your declaration should read like the following: 
    public class LoginSuccessScreen extends MainScreen implements Runnable { 

CHAPTER 5:  Beyond the Basics of User Interfaces 
121 
By implementing the Runnable interface, you're required to implement the run method. 
Since you don't plan on doing extra processing, simply declare the run method inside 
LoginSucessScreen. 
 
 
public void run() { 
 
 
} 
And that’s it. Now, the login success screen will smoothly scroll up from the bottom of 
the screen (see Figure 5–31). 
 
Figure 5–31. The login success screen sliding in 
All animation follows the same basic pattern, and it can get much more complex. With 
the same basic technique you can implement motion, fading, and more. 
Now, if you are not doing complicated animations but simply want to implement screen-
to-screen transition effects, you can revert the code to the state before you added 
animation. In UiFunMainScreen class, import net.rim.device.api.ui.TransitionContext 
and net.rim.device.api.ui.UiEngineInstance, and change the login method to this: 
    private void login() { 
        if (usernameField.getTextLength() == 0 ||  
 
 
passwordField.getTextLength() == 0) { 
         
UiApplication.getUiApplication().pushModalScreen 
            (new CustomDialog("You must enter a username and password")); 
        } 
        else { 
            String username = usernameField.getText(); 
            String selectedDomain =   
           (String)domainField.getChoice(domainField.getSelectedIndex()); 
             
            LoginSuccessScreen loginSuccessScreen =  

CHAPTER 5:  Beyond the Basics of User Interfaces 
122 
 
                new LoginSuccessScreen (username, selectedDomain); 
 
             
 
     TransitionContext transition = new  
 
     TransitionContext(TransitionContext.TRANSITION_SLIDE); 
 
            transition.setIntAttribute(TransitionContext.ATTR_DURATION, 
  
 
500); 
     transition.setIntAttribute(TransitionContext.ATTR_DIRECTION,  
 
TransitionContext.DIRECTION_UP); 
 
     transition.setIntAttribute(TransitionContext.ATTR_STYLE,  
 
 
TransitionContext.STYLE_PUSH); 
 
         
 
     UiEngineInstance engine = Ui.getUiEngineInstance(); 
     engine.setTransition(null, loginSuccessScreen,      
     UiEngineInstance.TRIGGER_PUSH, transition); 
     UiApplication.getUiApplication().pushScreen(  
 
loginSuccessScreen); 
   
        } 
    } 
This alternate way of using the TransitionContext class within the Login method is 
concise and easy to understand. It will do the same trick for the sliding screen you did 
earlier. And the best part is you can easily change the style of the transition and the 
direction with a simple selection of TransitionContext constants. 
Summary 
Congratulations! This chapter covered a lot of ground, and by working through it, you’ve 
learned enough about the BlackBerry UI to create all kinds of great-looking applications. 
In this chapter, you modified your UI Fun application from last chapter by creating a new 
label field that allowed you to display an image alongside the label plus a different 
background and foreground color. You also created a replacement button field that let 
you specify colors for both focused and unfocused states and gave a slightly different 
look than the default ButtonField. Then, you created a new layout manager that let you 
align your labels and edit fields in the way you wanted and a new dialog to replace the 
default BlackBerry OK dialog. After that, you made some tweaks to the application’s 
color and alignment and, finally, added a simple animation effect to the login success 
screen. 
Individually, all these changes were small, but together, they represent the starting point 
for creating most of the great user interfaces you see on modern BlackBerry 
applications. 
Now, you’ve gone pretty much as far as you will with the BlackBerry user interface in 
this book. The next chapter will look at an entirely new topic that’ll help you produce 
much more capable applications: storing data on the device. 

 
123 
 
 
 
Chapter 
Storing and Searching 
Data 
You now know enough about the BlackBerry user interface to create some pretty 
impressive-looking applications. So far, however, we’ve mostly focused on the basics of 
application life cycle and user interface. The applications that we’ve created haven’t 
saved any data to any form of persistent storage; each time they’re run, it’s as if they’re 
running for the first time. 
In the real world, most applications need to persist data. Even the simplest of 
applications typically has a user option or two that need to be stored when the 
application is shut down or the device is reset. 
A number of different mechanisms exist on the BlackBerry for persisting data. Some 
applications use more than one method depending on what is persisted, whereas other 
applications choose one or another and use that. We’ll list and describe the different 
persistence methods, explain times when you might want to use each one, and then 
build a couple of applications to explore the more common and useful methods in 
depth. 
Toward the end of the chapter, we’ll also cover integrating applications with 
BlackBerry’s Unified Search. With Unified Search integration, your application can 
publish its data where it can be searched and accessed right from the BlackBerry home 
screen.  
Storing Data on the BlackBerry 
The BlackBerry, like most smartphones, uses flash memory to store persistent data 
between application and device resets. BlackBerry devices have internal flash memory, 
and most models also support external SD cards. Some types of persistence work with 
the internal memory only, while some work with both internal flash memory and any SD 
card that’s attached to the device. 
6 

CHAPTER 6:  Storing and Searching Data 
124 
Choices for Persistence 
The BlackBerry offers several ways to store persistent data on the device: 
 MIDP’s Record Management System (RMS)  
 BlackBerry Persistent Store 
 JSR 75 FileConnection support 
 SQLite 
Because this book is designed to help you develop for the widest range of 
BlackBerry devices, we’ll only briefly touch on SQLite, which is only available on 
devices with OS 5.0 or later.  
RMS  
RMS is supported by BlackBerry mostly as part of supporting the MIDP standard. It’s a 
simple, non-relational database format that enables the application to store arrays of 
bytes. There’s minimal support for sharing data between applications, and application 
data is attached to the application—that is, when the application is removed from the 
device, application data is also removed. Generally, there’s no reason to use RMS 
unless you’re supporting legacy code or developing a MIDlet instead of a BlackBerry 
CLDC application, which, as we discussed in Chapter 3, is not usually an ideal choice 
for BlackBerry development. You can find information about RMS in many places on the 
Web, and in the BlackBerry Javadocs. All the relevant classes are located in the 
javax.microedition.rms package. RMS stores can be written only to the internal flash 
memory of the device. 
Persistent Store 
The BlackBerry Persistent Store provides similar features to RMS; however, it offers an 
easier way to store a wider range of objects and the capability to directly store instances 
of classes that you define in your applications. It also optionally offers compression and 
security with little extra work from the application, so it is the method you should use for 
most of your data storage functionality in a majority of BlackBerry applications. The 
Persistent Store classes, PersistentStore and PersistentObject, are located in 
net.rim.device.api.system (PersistentContent provides compression and encryption). 
Finally, persistent stores can be written only to the device’s internal flash memory. 
Runtime Store 
The Runtime Store is similar to the Persistent Store, but doesn’t persist across device 
resets. It’s mostly useful as a mechanism for applications to share information. 

CHAPTER 6:  Storing and Searching Data 
125 
JSR 75 FileConnection 
The FileConnection APIs are part of Java Specification Request (JSR) 75, published and 
maintained by the Java Community Process. The other part of JSR 75 includes Personal 
Information Management (PIM) APIs, which are also supported by the BlackBerry, but 
they are outside the scope of this chapter. 
The FileConnection APIs allow you to access the BlackBerry file system—both the 
device’s internal memory and any SD card that is currently plugged into the device. The 
file system is where the BlackBerry stores pictures, media, files that are downloaded 
through the browser, and any attachments saved from e-mail, and it is generally 
accessible by all BlackBerry applications on the device. It’s a good place to store large 
files, such as pictures or documents, especially if the user might want to access them in 
some other way, such as through the BlackBerry Desktop Manager. 
SQLite 
SQLite is a full SQL database implementation. It’s powerful and useful for storing 
structured data. 
The BlackBerry SQLite implementation enables you to create and access databases 
stored on the device’s internal memory and external SD cards. 
Your choices for persistence cover a wide enough range of functionality to meet almost 
any application’s need. Because the Persistent Store and the FileConnection and SQLite 
APIs are the most commonly used and cover the persistence needs of almost all 
applications, we’ll focus on those throughout the remainder of this chapter. We’ll also 
build a couple of applications to explore how the APIs function. 
BlackBerry Persistent Store 
The Persistent Store enables you to save objects to the device’s flash memory. Because 
it doesn’t support saving to the SD card, it’s not a good idea to use it to store 
documents or anything else that can use large amounts of storage space. Most modern 
devices have at least 500MB of flash memory onboard, and typically, a significant 
percentage of that is free even after taking into account space used by the OS, e-mail, 
and other data. This means you don’t have to knock yourself out trying to save space 
while writing typical application data like user settings; however, if you need to manage 
many high-resolution photos, audio, or video files, the FileConnection API is probably a 
better choice, and is covered later in this chapter. 
There are only two classes you really need to be familiar with to use the Persistent Store: 
net.rim.device.api.system.PersistentStore and 
net.rim.device.aip.system.PersistentObject. 

CHAPTER 6:  Storing and Searching Data 
126 
Persistent Store Keys 
The Persistent Store manages a list of keys (long values) and objects (instances of 
PersistentObject). The list of keys is global across all applications on the device. 
Unfortunately, you don’t know ahead of time which keys are in use by other 
applications; but, in practice, the keyspace is so large that conflicts never occur. 
Fortunately, the JDE Plug-in for Eclipse offers a convenient shortcut for generating a 
long value for use as a key. Simply type some text into the editor, select it, and right-
click. A menu item called Convert String to Long (see Figure 6–1) will appear. Select the 
menu item and a new long value will be generated based on a hash of the selected text.  
 
Figure 6–1. Creating a long value for a Persistent Store key with the Eclipse plug-in 
Persistent Objects 
Using the PersistentStore.getPersistentObject method returns an instance of 
PersistentObject, even if the key hasn’t ever been used before. This is important. You 
always get back a PersistentObject, but the content of that object might be null. This 
either means that nothing was saved with that key or it was deleted. 
        PersistentObject persistentObject = 
PersistentStore.getPersistentObject(0x2a5c4229e4666089L); 
The contents of the PersistentObject are accessed through the getContents method. 
Again, this method might return null: 
        // contents may be null 
        Object contents = persistentObject.getContents(); 
To set or replace the contents of the PersistentObject, use the setContents method: 
        Hashtable hashtable = new Hashtable(); 
        persistentObject.setContents(hashtable); 
Setting the contents, however, does not mean the object has been persisted. For that, 
you need to call the commit method: 
                              persistentObject.commit(); 
One final note: The PersistentObject maintains a reference to its contents. To change 
the data in the PersistentObject, modify that instance and call 

CHAPTER 6:  Storing and Searching Data 
127 
persistentObject.commit; there’s no need to call setContents again, unless you want 
an entirely different object to be associated with the given persistent key: 
        // This will persist MyKey and New Value 
        // no need to call persistentObject.setContents 
        hashtable.put("MyKey", "New Value"); 
        persistentObject.commit(); 
What Can You Persist? 
The Persistent Store can directly persist only objects, not primitive types. You can’t 
directly persist an int, for example, but you can wrap the int in an Integer object and 
persist that: 
        persistentObject.setContents(new Integer(1234)); 
Generally, any object that you pass into setContents must implement the 
net.rim.device.api.util.Persistable interface. This interface contains no methods; 
it’s just a marker for the BlackBerry OS. A lot of the built-in classes on the BlackBerry 
implement this interface. See the Javadocs for Persistable for a list. 
In addition to these, a few of the basic Java classes are also allowed, even though they 
don’t explicitly implement Persistable. These additional allowed persistable classes are 
java.lang.Boolean 
java.lang.Byte 
java.lang.Character 
java.lang.Integer 
java.lang.Long 
java.lang.Object 
java.lang.Short 
java.lang.String 
java.util.Vector 
java.util.Hashtable 
Arrays of primitive types are also implicitly persistable, as are arrays of other persistable 
types. So, you can persist byte[], char[], int[],String[], Vector[], and so on.  
Note that persistence saves the entire object, including all objects it references. This 
means that if your object references other objects, those objects must be persistable, 
too. In the previous example, we could persist the hashtable after we added a new 
key/value pair because the key and value were both strings, and String is persistable. 
However, the following would not be allowed: 
public class MyClass { 
    int someValue; 
} 
... 
        hashtable.put("AnotherKey", new MyClass()); 
        // The next line will throw an exception 
        // because MyClass isn't persistable 
        persistentObject.commit(); 

CHAPTER 6:  Storing and Searching Data 
128 
But if MyClass implements Persistable, everything will work: 
public class MyClass implements Persistable { 
    int someValue; 
} 
... 
        hashtable.put("AnotherKey", new MyClass()); 
        // This will work now 
        persistentObject.commit(); 
Enough of the theory; let’s put this knowledge to work. 
The Persistable Application 
Create a new BlackBerry application project called Persistable. The main screen will 
have a few controls on it, so we can demonstrate persistence of different data types. To 
save time, we’ll give the code for both classes. Here’s the code for 
PersistenceApplication.java: 
package com.beginningblackberry.persistence; 
 
import net.rim.device.api.ui.UiApplication; 
 
public class PersistenceApplication extends UiApplication { 
    public PersistenceApplication() { 
        PersistenceScreen screen = new PersistenceScreen(); 
        pushScreen(screen); 
    } 
 
    public static void main(String[] args) { 
        PersistenceApplication application = new PersistenceApplication(); 
        application.enterEventDispatcher(); 
    } 
 
} 
And here’s the code for PersistenceScreen.java: 
package com.beginningblackberry.persistence; 
 
import java.io.IOException; 
import java.util.Hashtable; 
 
import net.rim.device.api.system.PersistentObject; 
import net.rim.device.api.system.PersistentStore; 
import net.rim.device.api.ui.component.CheckboxField; 
import net.rim.device.api.ui.component.DateField; 
import net.rim.device.api.ui.component.EditField; 
import net.rim.device.api.ui.component.NumericChoiceField; 
import net.rim.device.api.ui.container.MainScreen; 
public class PersistenceScreen extends MainScreen { 
    EditField editField; 

CHAPTER 6:  Storing and Searching Data 
129 
    public PersistenceScreen() { 
        editField = new EditField("Persistent Data:", ""); 
        add(editField); 
    } 
 
} 
We intentionally kept this simple. The application will save data when you exit and load 
that data into the appropriate UI components when you start the application.  
Note that we added a bunch of imports to PersistenceScreen here to save time later on. 
The Persistent Object 
We need to have the persistent object available to load and save data. We’ll make it an 
instance variable of PersistenceScreen: 
public class PersistenceScreen extends MainScreen { 
    PersistentObject persistentObject; 
Now let’s define the key. Right under the PersistentObject declaration, type 
com.beginningblackberry.persistence.PersistenceScreen, and then highlight it, right-
click, and select Convert String to Long. 
public class PersistenceScreen extends MainScreen { 
    PersistentObject persistentObject; 
    0x1fd93a8a8a0a857bL 
You should get the same long value as above if you started with the same string (don’t 
worry if you didn’t; it’s not important for this exercise. As long as you have some value, 
the application will still work). 
Finally, add the following to make it a static final long variable: 
public class PersistenceScreen extends MainScreen { 
    PersistentObject persistentObject; 
    static final long KEY = 0x9df9f961bc6d6baL; 
Now add the following line to the constructor to initialize the object: 
                           persistentObject = PersistentStore.getPersistentObject(KEY); 
Loading the Data 
Loading is easy in this case. We’ll store a string directly into the contents of the 
PersistentObject, so we’ll check to see whether a string was set, and if so, update the 
edit field by adding this code at the end of the constructor: 
                           if (persistentObject.getContents() != null) { 
                                     
editField.setText((String)persistentObject.getContents()); 
                           } 

CHAPTER 6:  Storing and Searching Data 
130 
The Save Method 
We’ll start by saving the data. This introduces another new UI concept: the screen’s 
save method. Every screen on the BlackBerry keeps track of whether its controls have 
been modified since it was displayed. If they have, it displays a Save/Discard/Cancel 
prompt to the user. If the user chooses Save, the save method is called. By overriding 
that method, you can save your data when the screen is closed. 
Add the following code to PersistenceScreen: 
              public void save() throws IOException { 
                           persistentObject.setContents(editField.getText()); 
                           persistentObject.commit(); 
              } 
That’s all you have to do! Now go ahead and run the application. The first time, you’ll 
see that the edit field is empty, as shown in Figure 6–2. 
         
Figure 6–2. Persistence application before entering any data 
Now enter some text into the edit field and press the Escape key to exit the application. 
The Save prompt will be displayed, as shown in Figure 6–3. 

CHAPTER 6:  Storing and Searching Data 
131 
     
Figure 6–3. The Save prompt 
Select Save, and the application will exit. Now when you restart the application, the text 
will display in the edit field just as you entered it (see Figure 6–4). 
     
Figure 6–4. We’ve successfully saved and loaded data! 

CHAPTER 6:  Storing and Searching Data 
132 
More Advanced Persistence 
The initial example was just to give you an idea of how easy persistence can be. We’ll 
now modify the application to do something that might be a little more applicable in a 
real-world application. 
The Persistent Store’s use of long values for keys and the method of wrapping each 
stored object in a PersistentObject make it easy to store individual objects, but what if 
(as in most applications) you need to store a lot of different pieces of data? You can use 
a different long key for each one, but that rapidly gets unmanageable. The solution is to 
store a java.util.Hashtable in the PersistentObject, and then store each piece of data 
within that hashtable. A Hashtable stores a set of key/value pairs, and as long as all the 
keys and all the values are persistable objects, you can persist the hashtable itself. 
Modifying the UI 
To give us some more data to store, we’ll add a few fields to the PersistenceScreen. 
Add the following to the top of the PersistenceScreen class: 
              CheckboxField checkboxField; 
              NumericChoiceField numericChoiceField; 
              DateField dateField; 
And add the following lines to the constructor: 
                            checkboxField = new CheckboxField("Boolean data", false); 
                            numericChoiceField = new NumericChoiceField("Numeric data:", 
1, 10, 1); 
                            dateField = new DateField("Date:", 
System.currentTimeMillis(), DateField.DATE); 
 
                            add(checkboxField); 
                            add(numericChoiceField); 
                            add(dateField); 
NumericChoiceField basically acts the same as the ObjectChoiceField you saw earlier, 
but contains only integer values and has a couple of methods to make getting and 
setting the values as ints easy. DateField naturally enough displays a date and time as 
represented in Java as a long value. 
Using a Hashtable 
We’re going to make the persistent object use a Hashtable to store its contents, instead 
of storing a String. Add a declaration for the Hashtable to the top of PersistenceScreen: 
public class PersistenceScreen extends MainScreen { 
    Hashtable persistentHashtable; 
The idea in the constructor is to create the Hashtable if this is the first time using the 
Persistent Store, and to load it if not. Change the initialization code for the 
PersistentObject to the following: 

CHAPTER 6:  Storing and Searching Data 
133 
        persistentObject = PersistentStore.getPersistentObject(KEY); 
        if (persistentObject.getContents() == null) { 
 
            persistentHashtable = new Hashtable(); 
            persistentObject.setContents(persistentHashtable); 
        } 
        else { 
            persistentHashtable = (Hashtable)persistentObject.getContents(); 
        } 
Loading and Saving the Data 
With the hashtable initialized, remove the previous code for setting the text of the 
editField, and then add the following lines to the end of the PersistenceScreen 
constructor to load the data: 
        if (persistentHashtable.containsKey("EditData")) { 
            editField.setText((String)persistentHashtable.get("EditData")); 
        } 
        if (persistentHashtable.containsKey("BoolData")) { 
            Boolean booleanObject = (Boolean)persistentHashtable.get("BoolData"); 
            checkboxField.setChecked(booleanObject.booleanValue()); 
        } 
        if (persistentHashtable.containsKey("IntData")) { 
            Integer intObject = (Integer)persistentHashtable.get("IntData"); 
            numericChoiceField.setSelectedValue(intObject.intValue()); 
        } 
        if (persistentHashtable.containsKey("Date")) { 
            Long longObject = (Long)persistentHashtable.get("Date"); 
            dateField.setDate(longObject.longValue()); 
        } 
The pattern is the same for all primitive data types. Wrap them in the appropriate 
associated data class and put that into the hashtable. 
The save method is simpler because we don’t have to do all the checking: 
    public void save() throws IOException { 
        persistentHashtable.put("EditData", editField.getText()); 
        persistentHashtable.put("BoolData", new Boolean(checkboxField.getChecked())); 
        persistentHashtable.put("IntData", new     
Integer(numericChoiceField.getSelectedValue())); 
        persistentHashtable.put("Date", new Long(dateField.getDate())); 
        persistentObject.commit(); 
    } 
Notice we removed the setContents method from save. The PersistentObject maintains 
a reference to the Hashtable throughout the life cycle of the screen, so all we need to do 
is call commit and it will write the latest versions of all referenced data to persistent 
storage. 

CHAPTER 6:  Storing and Searching Data 
134 
Clearing the Old Persistent Data from the Simulator 
There’s one last thing we need to do before running the application. Because we’re 
using the same Persistent Store key as before, and because we’ve already persisted a 
String using that key, the first time we try to read the contents of the PersistentObject 
and cast to a Hashtable, we’ll get an exception because the content is a String. We 
need to clear the simulator’s persistent data before running the application again.  
From the JDE Plug-in for Eclipse, you erase the simulator’s file system by selecting the 
BlackBerry menu and choosing Clean Simulator  Remove Files from the File System 
(see Figure 6–5). If you are using a pre-7.0 version of the JDE plug-in, Clean Simulator is 
the only option available to select. 
 
Figure 6–5. You need to erase the file system to erase the old contents of the Persistent Store. 
You might wonder about how we’d deal with this situation on a real device. This does 
happen, and we’ll touch on that shortly, but right now, let’s look at the new application 
in action (see Figure 6–6). The usage is the same, but now we’re storing a bunch of 
different pieces of data. 

CHAPTER 6:  Storing and Searching Data 
135 
 
Figure 6–6. Storing and loading a bunch of data 
Clearing Persistent Data from a Device 
On a BlackBerry device, persistent data is somewhat independent of the application. 
What does that mean? It has to do with what types of classes you persist. If you persist 
only classes that are defined in the BlackBerry API, your data by default will stay behind 
when your application is deleted from the device. Other applications can still access it, 
and if you reload your application onto the device, your data will still be there. 
If you want your data to be removed when your application is removed, the easiest 
method is to store classes that are defined in your application. In our application, this is 
easy to accomplish. We’ll define a new class called CustomHashtable that extends 
Hashtable. Remember, we have to be sure to make it implement Persistable because 
any class that we want to persist must directly implement Persistable; it doesn’t matter 
if it extends a persistable class. Create the class in a new file called 
CustomHashtable.java, containing the following code: 
package com.beginningblackberry.persistence; 
 
import java.util.Hashtable; 
 
import net.rim.device.api.util.Persistable; 
 
public class CustomHashtable extends Hashtable implements Persistable { 
 
} 

CHAPTER 6:  Storing and Searching Data 
136 
We don’t need to add anything more to this class. Just replace all the references to 
Hashtable in PersistableScreen with references to CustomHashtable, and everything will 
work as before, except that when the application is removed from the device, the data 
will not stay behind. 
The FileConnection API 
The JSR 75 FileConnection API gives your application the capability to read and write to 
the BlackBerry file system—both the internal flash memory and any memory card 
attached to your device. It also enables you to read data that other applications have 
written to the file system. This is especially useful for retrieving pictures, video, and other 
media that might be on your device. 
In the following sections, we’ll create a simple application to browse for photos from the 
device’s memory (internal or memory card) and display them on the screen. 
Basic Application Framework 
You should be used to creating applications by now; create a new a new BlackBerry 
application called FileConnection. Start with an application class and main screen 
class. The initial classes are as follows. 
Here’s FileConnectionApplication.java: 
package com.beginningblackberryfileconnection; 
 
import net.rim.device.api.ui.UiApplication; 
 
public class FileConnectionApplication extends UiApplication { 
 
    public FileConnectionApplication() { 
        FileConnectionScreen screen = new FileConnectionScreen(); 
        pushScreen(screen); 
    } 
 
    public static void main(String[] args) { 
        FileConnectionApplication app = new FileConnectionApplication(); 
        app.enterEventDispatcher(); 
    } 
 
} 
Here’s FileConnectionScreen.java: 
package com.beginningblackberry.fileconnection; 
 
import net.rim.device.api.ui.MenuItem; 
import net.rim.device.api.ui.component.Menu; 
import net.rim.device.api.ui.component.ObjectListField; 
import net.rim.device.api.ui.container.MainScreen; 
import net.rim.device.api.util.StringProvider; 
 
public class FileConnectionScreen extends MainScreen { 

CHAPTER 6:  Storing and Searching Data 
137 
    private ObjectListField fileList; 
    private String currentPath = "file:///"; 
 
    public FileConnectionScreen() { 
        setTitle("FileConnection"); 
 
        fileList = new ObjectListField(); 
 
        fileList.set(new String[] {"store/", "SDCard/"}); 
 
        add(fileList); 
    } 
 
    protected void makeMenu(Menu menu, int instance) { 
        super.makeMenu(menu, instance); 
        menu.add(new MenuItem(new StringProvider("Select"), 10, 10) { 
            public void run() { 
                loadFile(); 
            } 
        }); 
    } 
 
    private void loadFile()  { 
    } 
 
} 
We’re introducing another new UI component here: the ObjectListField. This displays a 
vertical list of strings on the screen. We’ll use it to show the contents of the directories 
as we browse.  
We’ve populated our object list field with two initial entries: store/ and SDCard/. These 
are the root directories for the internal device memory and the memory card, 
respectively, and are the same on every BlackBerry device. We use them as a starting 
point for browsing. 
There’s also a String that contains the current path. When opening a FileConnection, 
you need the full path; we’ll use this variable to keep track of it. 
Finally, we’ve added a single menu item in the makeMenu method using an anonymous 
inner class, as discussed in Chapter 4. We’ve also created a loadFile method that will 
contain all the FileConnection logic. 
For now, the application looks like Figure 6–7, with the default two items in the 
ObjectListField and the single custom menu item. 

CHAPTER 6:  Storing and Searching Data 
138 
     
Figure 6–7. The FileConnection application main screen containing the two default directory entries 
Opening a File Connection 
Classes related to the FileConnection API are found in the javax.microedition.io.file 
package. For this application, we’ll mostly work with the FileConnection interface.  
FileConnection is a pretty rich interface. It enables you to create and delete files, list the 
contents of a directory, and read and write file contents and attributes. 
You obtain a FileConnection using the javax.microedition.io.Connector class. The 
Connector class is also used to initiate network connections, among other things, so 
we’ll be using it again in the future. All of its methods take a string parameter, which is a 
URL representing a resource. Connector URLs conform to the standard URL definition 
from RFC 2396, with a scheme portion (such as http:) that represents the type of 
resource being requested. 
The BlackBerry Javadocs thoroughly explain the details of the many different connection 
types; we’ll explore some of them in Chapter 7 when we discuss networking. For now, 
just be concerned with opening file resources. 
File connection URLs start with file://. 
For example, to open the store directory representing the device’s internal memory, 
you’d use the following code. Note the extra / at the beginning of the URL. 

CHAPTER 6:  Storing and Searching Data 
139 
        try { 
            FileConnection storeDirectory = 
(FileConnection)Connector.open("file:///store/"); 
        } catch (IOException e) { 
        } 
As long as the URL represents a path that could be valid, no exception is thrown. This 
enables you to create a file by first opening a connection to a URL representing the file 
you want to create, and then calling FileConnection.create. For BlackBerry, a URL is 
valid if all directories specified in the URL exist, with the exception of the last one only if 
the path returns a file. For example, if the home directory exists under the store directory, 
and is empty (containing no subdirectories or files), then the following URL is allowed: 
file://store/home/testfile.txt 
And so is the following: 
file://store/home/newdir/ 
But the following URL will cause an exception to be thrown, because newdir doesn’t 
exist: 
file://store/home/newdir/test.txt 
Listing the Directory Contents 
The first thing we’ll implement is listing files and subdirectories in a directory. Whenever 
you click the Select menu item, if the currently highlighted item in the object list field is a 
directory, we’ll replace the items in the list field with the contents of that directory. 
When the user clicks Select, we’ll construct a path to that directory by simply 
concatenating the current path with the path of that directory; all directory entries end 
with a / character, so we don’t have to worry about adding that. 
The FileConnection.isDirectory method tells you if the file connection points to a 
directory. If it does, the list method retrieves an Enumeration of Strings, which are the 
path names of the files and directories contained within the directory. Because 
ObjectListField requires an Object array, we’ll add the strings from the enumeration 
one by one to a Vector, and get the array from that Vector when we’re done. Here’s the 
code for loadFile: 
    private void loadFile() { 
        currentPath += fileList.get(fileList, fileList.getSelectedIndex()); 
        try { 
            FileConnection fileConnection = (FileConnection)Connector.open(currentPath); 
            if (fileConnection.isDirectory()) { 
                Enumeration directoryEnumerator = fileConnection.list(); 
                Vector contentVector = new Vector(); 
                while(directoryEnumerator.hasMoreElements()) { 
 
                    contentVector.addElement(directoryEnumerator.nextElement()); 
                } 
                String[] directoryContents = new String[contentVector.size()]; 
                contentVector.copyInto(directoryContents); 

CHAPTER 6:  Storing and Searching Data 
140 
                fileList.set(directoryContents); 
            } 
        } catch (IOException ex) { 
        } 
    } 
On Eclipse, you’ll see that some of the fields are underlined red because we haven’t 
added the import statement for those fields. For all underlined fields, you can automate 
the adding of the import statement by hovering the mouse pointer over the field and 
selecting Import from the pop-up that appears. Once you get all the import statements 
added, run the application. By default, the device on the simulator doesn’t have an SD 
card; however, you can easily simulate having an SD card by mounting any Windows 
folder. To mount a folder and simulate an SD card, on the simulator, select Simulate and 
then select Change SD Card from the drop-down menu. A Change SD Card screen will 
appear, as shown in Figure 6–8.  
Figure 6–8. A Change SD Card screen 
On this screen, use the Add Directory button (at the top left) to select and add a folder to 
the list. Once you have a folder, highlight it and click the Mount Selected button (second 
to the right at the top) to use this folder to simulate the device’s SD card. 
Once you have a simulated SD card mounted, you can click the app, and you should be 
able to navigate through the device’s file system, including the SD card, by selecting 
directories and clicking the Select menu item (see Figure 6–9). 

CHAPTER 6:  Storing and Searching Data 
141 
 
Figure 6–9. To browse through SD card file structure, click  SDCard and then click Select/, click BlackBerry/, and 
then click Select. 
Viewing Pictures 
Now we’ll add the code to loadFile to actually view pictures. We will create a new 
screen containing a single BitmapField to view our picture; whenever we highlight a 
picture in the file list and click Select, we’ll create a new instance of this screen and 
push it onto the stack. 
The Image Display Screen 
Make a new file called ImageDisplayScreen.java in your project. The code for 
ImageDisplayScreen is simple: 
package com.beginningblackberry.fileconnection; 
 
import net.rim.device.api.system.EncodedImage; 
import net.rim.device.api.ui.component.BitmapField; 
import net.rim.device.api.ui.container.MainScreen; 
 
public class ImageDisplayScreen extends MainScreen { 
    public ImageDisplayScreen(EncodedImage image) { 
        BitmapField bitmapField = new BitmapField(); 
        bitmapField.setImage(image); 
        add(bitmapField); 
    } 
} 
This uses an EncodedImage instead of a Bitmap because that’s the way we’ll load the 
image from the file system. EncodedImage has a few features that Bitmap doesn’t, 
including scaling, support for multiple frames, and support for more file types. 

CHAPTER 6:  Storing and Searching Data 
142 
Loading Images from the File System 
For any FileConnection, you can retrieve an InputStream. This enables you to read 
bytes from the file.  
The only checking that we’re doing is that the path ends in a known file extension. For 
the purposes of this exercise, you don’t need to worry about error handling, but if this 
were a production application, we’d add more cases of error handling. The following 
code should be added to loadFile, right after the if statement: 
        else if (currentPath.endsWith(".jpg") || currentPath.endsWith(".png")) { 
            InputStream inputStream = fileConnection.openInputStream(); 
            byte[] imageBytes = new byte[(int)fileConnection.fileSize()]; 
            inputStream.read(imageBytes); 
            inputStream.close(); 
            EncodedImage eimg = EncodedImage.createEncodedImage(imageBytes, 0, 
imageBytes.length); 
 
            UiApplication.getUiApplication().pushScreen(new ImageDisplayScreen(eimg)); 
 
 
 
        } 
And don’t forget to add the import statement for InputStream, EncodedImage, and 
UiApplication.  
Getting Images into the Simulator 
Before you run the application, you need a few pictures on the simulator’s file system to 
use for testing. You can get these by running the camera application on your simulator. 
If you have a webcam attached to or built into your PC, you might get to snap an actual 
picture. Otherwise, you are presented with a dialog box to choose an image to represent 
the picture the camera takes. In either case, take a picture or two and start the 
FileConnection application again.  
Unless you explicitly saved your picture to a different location, navigate to 
SDCard/BlackBerry/pictures, and you should see the image listed, as shown in 
Figure 6–10. 

CHAPTER 6:  Storing and Searching Data 
143 
     
Figure 6–10. A list of images in the pictures directory 
If you click one of those images, you should see something like Figure 6–11. 
 
Figure 6–11. The image? 

CHAPTER 6:  Storing and Searching Data 
144 
You might get a clearer image if you select a lower-resolution picture from the dialog 
box, but if you take a higher-resolution picture using the camera on a real device, what 
you’ll see is the extreme upper-left corner of that photo. 
The BlackBerry’s LCD screen is generally a lot lower resolution than its camera, so to 
display the full image, you need to scale it. This is another reason we used EncodedImage 
instead of Bitmap; it has better built-in image-scaling support.   
Scaling the Image 
Though not directly relevant to persistent storage, scaling the image will make the 
application complete, and it is useful to know how to do it. 
We’ll do the image scaling within ImageDisplayScreen’s constructor. We’ll present the 
code first and discuss it after. But first, add the following import statements into 
ImageDisplayScreen: 
import net.rim.device.api.math.Fixed32; 
import net.rim.device.api.system.Display; 
The new constructor for ImageDisplayScreen is 
    public ImageDisplayScreen(EncodedImage image) { 
        int displayWidth = Fixed32.toFP(Display.getWidth()); 
        int imageWidth = Fixed32.toFP(image.getWidth()); 
        int scalingFactor = Fixed32.div(imageWidth, displayWidth); 
        EncodedImage scaledImage = image.scaleImage32(scalingFactor, scalingFactor); 
        BitmapField bitmapField = new BitmapField(); 
        bitmapField.setImage(scaledImage); 
        add(bitmapField); 
    } 
NOTE: EncodedImage uses 32-bit fixed-point decimal numbers as its scale factors. The 
BlackBerry provides support for numbers in this format in the 
net.rim.device.api.math.Fixed32 class. Fixed32 enables you to store a decimal 
number in a 32-bit int; 16 bits are used for the integer portion and 16 bits are used for the 
decimal portion. Addition and subtraction operations on Fixed32 numbers are faster than those 
on floats or doubles, so they can be a good choice for these types of decimal arithmetic. 
When using Fixed32 numbers, remember to convert back and forth from regular ints; that’s 
what the toFP method does. You also must use Fixed32 methods for multiplying and dividing 
Fixed32-format numbers. Using the * and / operators produces nonsensical results, but you can 
use the standard Java + and – operators for addition and subtraction. 
For EncodedImage, a scaling factor of between 0 and 1 means scale up; a scaling factor 
of greater than 1 means scale down. We can get the correct scaling factor for our image 
by dividing the image’s width by the BlackBerry display’s width. To be completely 
precise, we could check the image and display height, too, but I’ll leave that as an 

CHAPTER 6:  Storing and Searching Data 
145 
exercise for you. When you run the FileConnection application and select the same 
image now, you’ll get a much better picture (see Figure 6–12). 
     
Figure 6–12. The correctly scaled image 
This is as far as we’ll go with reading files from the file system. There are, of course, 
areas where the application can be improved, but at this point, you should have a good 
understanding of how to read files and directories using the FileConnection API. You 
can also try to run this application on a real device, and you should be able to view 
photos that were taken by the device’s camera. 
Now let’s explore the other half of the FileConnection API: creating and writing to files 
on the file system. 
Writing to the File System 
We’ll extend the FileConnection application to enable writing to the file system. We can 
leverage the same directory-browsing code and add functionality that enables us to 
make a copy of an existing image in the same directory. 
The functionality will be as follows: when a file (not a directory) is highlighted, a Copy 
menu item will become available. When you click this menu item, you’ll be prompted for 
a name for the new file, and if that file name doesn’t exist, the selected file will be copied 
into a new file with the specified name. 

CHAPTER 6:  Storing and Searching Data 
146 
A Dynamic Menu Item 
First, we’ll add the new menu item to let us copy the currently selected file. Before we 
add the menu item, let’s put in place the method that we’ll call to do the work of copying 
the file. Add this to FileConnectionScreen: 
              private void copyFile() { 
} 
Now we want the Copy menu item to show up only when a file is selected. We know 
which entries in the object list field are files because the directories all end with the / 
character. Because we’re constructing the menu in the makeMenu method, which is called 
every time the menu key is pressed, we can easily check at that time if the currently 
selected item ends in /, and add the Copy menu item only if it does not. Add the 
following code to the FileConnectionScreen’s makeMenu method: 
        String selectedItem = (String)fileList.get(fileList, 
fileList.getSelectedIndex()); 
        if (!selectedItem.endsWith("/")) { 
            menu.add(new MenuItem(new StringProvider("Copy"), 10, 10) { 
                public void run() { 
                    copyFile(); 
                } 
            }); 
        } 
If you run the application now and browse around, you’ll see that the Copy menu item 
shows up only when a file is highlighted (see Figure 6–13). 
7
     
Figure 6–13. The Copy menu item shows up only when a file is selected. 

CHAPTER 6:  Storing and Searching Data 
147 
The File Name Screen 
When we copy a file, we’ll pop up a dialog asking for a name for the new copy. This 
requires us to create a new screen with an edit field for the name. We’ll subclass 
net.rim.device.api.container.PopupScreen to get a dialog rather than a full screen. 
Note that the constructor for PopupScreen asks for the delegate manager, just as the 
constructor for Screen does. We’ll just use a VerticalFieldManager. We’ll also add a 
ButtonField so there’s some way to dismiss the screen (remember to set the 
ButtonField.CONSUME_CLICK style).  
Finally, we’ll provide a method in the screen class to retrieve the name of the file from 
the edit field. The FileNameScreen class looks like this: 
package com.beginningblackberry.fileconnection; 
 
import net.rim.device.api.ui.Field; 
import net.rim.device.api.ui.FieldChangeListener; 
import net.rim.device.api.ui.component.ButtonField; 
import net.rim.device.api.ui.component.EditField; 
import net.rim.device.api.ui.container.PopupScreen; 
import net.rim.device.api.ui.container.VerticalFieldManager; 
 
public class FileNameScreen extends PopupScreen implements FieldChangeListener { 
    private EditField fileNameField; 
    private ButtonField okButton; 
    public FileNameScreen() { 
        super(new VerticalFieldManager()); 
 
        fileNameField = new EditField("New Filename:", ""); 
        add(fileNameField); 
        okButton = new ButtonField("OK", ButtonField.CONSUME_CLICK | 
Field.FIELD_HCENTER); 
        okButton.setChangeListener(this); 
        add(okButton); 
    } 
 
    public String getFilename() { 
        return fileNameField.getText(); 
    } 
 
    public void fieldChanged(Field field, int context) { 
        if (field == okButton) { 
            close(); 
        } 
    } 
} 

CHAPTER 6:  Storing and Searching Data 
148 
Copying the File 
To display the file name screen, we’ll use UiApplication.pushModalScreen instead of 
pushScreen. This just means that the method won’t return until the file name screen is 
closed; this is the functionality we want in this case because we can’t copy the file until 
we’ve entered a file name and clicked OK. 
        FileNameScreen screen = new FileNameScreen(); 
        UiApplication.getUiApplication().pushModalScreen(screen); 
        String newFilename = screen.getFilename(); 
After getting the file name, we’ll open a connection to the full URL for that file name and 
use FileConnection.exists to check if there’s already a file there. If so, we’ll display a 
dialog and exit the method: 
                    FileConnection newFileConnection = 
(FileConnection)Connector.open(currentPath + newFilename); 
            if (newFileConnection.exists()) { 
                Dialog.alert("The file '" + newFilename + "' already exists!"); 
                newFileConnection.close(); 
                return; 
            } 
If the file doesn’t exist, we’ll call FileConnection.create to create it. Then we’ll open an 
OutputStream to the new file: 
                                          newFileConnection.create(); 
                                          OutputStream newFileOutputStream = 
newFileConnection.openOutputStream(); 
From this point on, the code is the same as when loading an image, except that instead 
of constructing an image with the byte array, we’re writing it to the OutputStream that 
represents the newly created file. Here’s copyFile in its entirety (don’t forget to include 
the import statements on Dialog and OutputStream): 
    private void copyFile() { 
        // Prompt for the new file name 
        FileNameScreen screen = new FileNameScreen(); 
        UiApplication.getUiApplication().pushModalScreen(screen); 
        String newFilename = screen.getFilename(); 
 
        try { 
            FileConnection newFileConnection = 
(FileConnection)Connector.open(currentPath + newFilename); 
            if (newFileConnection.exists()) { 
                Dialog.alert("The file '" + newFilename + "' already exists!"); 
                newFileConnection.close(); 
                return; 
            } 
 
            // The file doesn't exist, so we'll create it 
            newFileConnection.create(); 
            OutputStream newFileOutputStream = newFileConnection.openOutputStream(); 
 
            // Open the old file 
www.allitebooks.com

CHAPTER 6:  Storing and Searching Data 
149 
            currentPath += fileList.get(fileList, fileList.getSelectedIndex()); 
            FileConnection fileConnection = (FileConnection)Connector.open(currentPath); 
            InputStream inputStream = fileConnection.openInputStream(); 
 
 
            // Copy the contents of the old file into the new one 
            byte[] fileContents = new byte[(int)fileConnection.fileSize()]; 
            inputStream.read(fileContents); 
            newFileOutputStream.write(fileContents, 0, fileContents.length); 
            inputStream.close(); 
            newFileOutputStream.close(); 
            Dialog.inform("Successfully copied the file!"); 
        } catch (IOException ex) { 
 
        } 
    } 
Now run the application to try it out. Browse to the SDCard/BlackBerry/pictures folder 
and copy one of the files there. Figure 6–14 shows the Filename dialog. 
 
Figure 6–14. Entering the new file name (be sure to include the correct extension) 
Because our application doesn’t dynamically reload the directory, we have to exit and 
browse back to the pictures directory to see our new file (see Figure 6–15). 

CHAPTER 6:  Storing and Searching Data 
150 
Figure 6–15. The new file 
You can select and view this file just as you could the original. 
Using SQLite 
SQLite is an open source database; it’s packaged in the BlackBerry primarily to make 
the browser support the database requirement for HTML 5. But BlackBerry developers 
have been clamoring for database-like storage, and with SQLite’s availability on the 
device, it’s a no-brainer for RIM to extend the JDK to expose some API classes for 
SQLite. The specifications on the SQL syntax used by SQLite can be found in 
www.sqlite.org. 
In this section, we’ll use SQLite classes to build a simple application that stores and 
retrieves information from a SQLite database. What you’ll learn from the exercise will be 
enough to get your feet wet and use the same techniques in your apps. But before we 
build the app, the succeeding subsections will give you an idea about the basic 
operation and syntax of SQLite databases.  
Creating a Database and a Table 
In true “lite” fashion, you can quickly create a SQLite database by using this code: 
Database db = DatabaseFactory.openOrCreate(uri); 

CHAPTER 6:  Storing and Searching Data 
151 
The uri parameter is a URI referencing the database file. If the file pointed to by the URI 
is nonexistent, this statement will create the database at the file location specified. 
Watch out for a URI that describes a nonexistent directory. The statement will not create 
a directory tree and instead will throw an exception. So make sure you create the 
directory tree for the location of your database file. Once you have a database instance, 
you can issue a createStatement to create a table like this:  
Statement st = db.createStatement("CREATE TABLE 'People' ('Name' TEXT)" ); 
On your Statement instance, a follow up call to the prepare and execute methods will do 
the actual creation of the table. 
Inserting Records 
If you are familiar with the Statement class of the java.sql package, inserting, updating, 
and deleting records from a table will be second nature to you. With RIM’s SQLite API, 
the syntax is similar; to insert a record, you’ll use the same Statement class from the 
net.rim.device.api.database package: 
Statement st =db.createStatement("INSERT INTO People(Name) VALUES (?)"); 
st.bind(1, "Dante"); 
st.execute(); 
Querying Tables 
You’ve probably guessed by now that you’ll use the same Statement class for queries. 
But in addition to Statement, you’ll need Cursor to fetch the records: 
Statement st = db.createStatement("SELECT Name FROM People"); 
st.prepare(); 
Cursor c = st.getCursor(); 
To step through your records within a cursor one row at a time, use the following code:  
Row r = c.getRow(); 
Finally, you need to get the field values from the Row instance. Use the appropriate data 
type getters with the ordinal position of the field, as described on your SELECT statement:  
String name = r.getString(0); 
SQLite Sample Application 
With the knowledge of SQLite API classes you have gained from the previous sections, 
we’ll now create a simple application to demonstrate how we tie together all those 
classes. We’ll store a list of people’s first names with their ages in a Person table and 
have it listed on a screen. 

CHAPTER 6:  Storing and Searching Data 
152 
Start with creating a BlackBerry project in Eclipse, and name it DatabaseManager. Just 
like the previous applications we built, we need a class that extends UiApplication, and 
the class should look like the following: 
package com.beginningblackberry.database; 
 
import net.rim.device.api.ui.UiApplication; 
 
public class DatabaseApplication extends UiApplication 
{ 
    public static void main(String[] args) 
    { 
        DatabaseApplication theApp = new DatabaseApplication();        
        theApp.enterEventDispatcher(); 
    } 
 
    public DatabaseApplication() 
    {         
        pushScreen(new DatabaseScreen()); 
    }     
} 
DatabaseApplication is the entry point of our new app, and displays DatabaseScreen, 
which we are about to write. Our DatabaseScreen will have buttons as the trigger points 
for adding records, refreshing the screen, and deleting records, so it needs to implement 
FieldChangeListener: 
public final class DatabaseScreen extends MainScreen implements FieldChangeListener 
{ 
} 
Add the following declarations for our three buttons, a list field to display the records, 
and the database we’re about to create: 
    private ButtonField addButton = new ButtonField("Add Records", 
ButtonField.CONSUME_CLICK | Field.FIELD_HCENTER); 
    private ButtonField displayButton = new ButtonField("Refresh List", 
ButtonField.CONSUME_CLICK | Field.FIELD_HCENTER); 
    private ButtonField deleteButton = new ButtonField("Delete Records", 
ButtonField.CONSUME_CLICK | Field.FIELD_HCENTER); 
    private ObjectListField recordList = new ObjectListField(); 
    private Database db; 
 
 
Assembling the screen fields on our constructor, we’ll use a HorizontalFieldManager to 
line up the buttons on the top of the screen and have the list field below them: 
    public DatabaseScreen() 
    {         
        LabelField title = new LabelField("Database Example", 
                 LabelField.ELLIPSIS |  
                 LabelField.USE_ALL_WIDTH); 
         
 
 
setTitle(title); 

CHAPTER 6:  Storing and Searching Data 
153 
 
 
HorizontalFieldManager hfm = new HorizontalFieldManager(); 
        addButton.setChangeListener(this); 
 
 
displayButton.setChangeListener(this); 
 
 
deleteButton.setChangeListener(this); 
        hfm.add(addButton); 
        hfm.add(displayButton); 
        hfm.add(deleteButton); 
         
        add(hfm); 
        add(recordList); 
         
    } 
 
Now that we’ve added the fieldChanged method to make this class implement 
FieldChangedChangeListener and the necessary import statements as well, we should 
be able to run this app on the simulator: 
    public void fieldChanged(Field field, int context) { 
    }     
 
Your screen will look like the one shown in Figure 6–16. 
 
Figure 6–16. Empty database screen  

CHAPTER 6:  Storing and Searching Data 
154 
This screen has no meat on it yet; we need to add some code to make the buttons work. 
First, let’s have a function that creates our database in the documents folder on the SD 
card, and name the file Person.db: 
    private boolean openOrCreateDatabase() { 
 
 
try { 
 
 
 
URI myURI = 
URI.create("/SDCard/BlackBerry/documents/Person.db");  
 
 
 
db = DatabaseFactory.openOrCreate(myURI); 
 
 
} catch (Exception e) { 
 
 
 
return false; 
 
 
} 
     
return true; 
    } 
Our next step is to create a function for creating a People table within our Person 
database: 
    private void createDatabaseSchema() { 
        Statement st = null; 
 
 
try { 
 
 
 
st = db.createStatement( "CREATE TABLE 'People' ( " + 
 
 
 
                    "'Name' TEXT, " + 
 
 
 
                    "'Age' INTEGER )" ); 
 
 
 
st.prepare(); 
 
 
 
st.execute(); 
 
 
} catch ( Exception e ) {          
 
 
 
e.printStackTrace(); 
 
 
} finally { 
 
 
 
try { 
 
 
 
 
st.close(); 
 
 
 
} catch (DatabaseException e) { 
 
 
 
} 
 
 
} 
    } 
With the database and table created, the next step is to add records. Instead of writing 
code for each record we want to insert, we are using a Hashtable to hold names and 
ages, and making a single loop on the contents of the Hashtable to insert one record at 
a time. This approach will make our example here easier to read since we don’t have to 
repeat writing the code for inserting each record: 
    private void insertTableData() { 
        Statement st = null; 
        try { 
         
st = db.createStatement("INSERT INTO People(Name,Age) VALUES (?,?)"); 
            st.prepare(); 
 
            Hashtable ht = new Hashtable(5); 
            ht.put("Joe", new Integer(6)); 
            ht.put("Mike",  new Integer(7)); 
            ht.put("Marie",  new Integer(12)); 
            ht.put("Dennis",  new Integer(14)); 
            ht.put("Richard",  new Integer(12)); 

CHAPTER 6:  Storing and Searching Data 
155 
            Enumeration names = ht.keys(); 
            Enumeration ages  = ht.elements(); 
 
            while (names.hasMoreElements()) { 
               String strName = (String)names.nextElement(); 
               Integer iAge   = (Integer)ages.nextElement(); 
               st.bind(1,strName); 
               st.bind(2,iAge.intValue()); 
               st.execute(); 
               st.reset(); 
            } 
        } catch ( Exception e ) {          
            e.printStackTrace(); 
 
 
} finally { 
 
 
 
try { 
 
 
 
 
st.close(); 
 
 
 
} catch (DatabaseException e) { 
 
 
 
} 
        }     
 
    } 
Now, with the records added, let’s have a readTableData function to read our table and 
display it on the recordList: 
    private boolean readTableData() { 
     
if (db==null) { 
     
 
return false; 
     
} 
 
     
clearList(); 
     
 
     
Statement st = null; 
     
 
        try { 
            st = db.createStatement("SELECT Name,Age FROM People order by Name desc"); 
            st.prepare(); 
            Cursor c = st.getCursor(); 
 
            if (c==null) { 
             
return false; 
            } 
             
            Row r; 
            int i = 0; 
            while(c.next()) { 
                r = c.getRow(); 
                i++; 
 
 
 
 
recordList.insert(0, r.getString(0) + " - " + 
r.getInteger(1) + " years old"); 
            } 
            if (i==0) { 
             
return false; 
            } 
 
        } catch ( Exception e ) {          
            e.printStackTrace(); 

CHAPTER 6:  Storing and Searching Data 
156 
 
 
} finally { 
 
 
 
try { 
 
 
 
 
st.close(); 
 
 
 
} catch (DatabaseException e) { 
 
 
 
} 
        } 
 
 
return true; 
    } 
To make this example complete, add the deleteTableData function to clear our table 
and the clearList function below to empty our list field: 
    private boolean deleteTableData() { 
     
boolean result = false; 
     
if (db==null) { 
            Dialog.alert("no database opened"); 
     
 
return result; 
     
} 
     
 
     
Statement st = null; 
        try { 
            st = db.createStatement("DELETE FROM People"); 
            st.prepare(); 
            st.execute("DELETE FROM People"); 
            result = true; 
        } catch ( Exception e ) {          
            e.printStackTrace(); 
        } 
        return result; 
    } 
    private void clearList() { 
 
 
for (int i=recordList.getSize()-1;i>=0;i--) { 
     
 
recordList.delete(i); 
 
 
} 
    } 
With all our database-related functions created, we’re now ready to tie all of this into our 
buttons. Now, let’s change the fieldChanged method to interrogate which button is 
clicked and call the appropriate function: 
    
    public void fieldChanged(Field field, int context) { 
        if (field == displayButton) { 
         
readTableData(); 
        } else if (field == addButton) { 
         
insertTableData();         
 
         
readTableData(); 
        } else if (field == deleteButton) { 
         
if (deleteTableData()) { 
         
 
clearList(); 
         
} 
        } 
    }     
     

CHAPTER 6:  Storing and Searching Data 
157 
Finally, in the bottom of our constructor, add the following code to make sure the 
database- and-table schema is created: 
 
 
if (openOrCreateDatabase()) { 
 
 
 
createDatabaseSchema(); 
 
 
}     
Run the application in the simulator. When the simulator is up, don’t forget to mount an 
SD card before you click the app’s icon. Once the SD card is mounted, click the app, and 
then click the Add Records button. You will see a screen that looks like Figure 6–17. 
     
Figure 6–17. Database screen after adding records 
With the data stored in the database, it will be persisted in the Person.db file. The next 
time you run the app, you can click Refresh List, and you should see the same data. 
This exercise is simple, yet it demonstrates the power of using SQLite. You should be 
able to use the same code techniques for your future applications. 
Integrating Your App with Unified Search 
The search facility that you see right from the home screen of a BlackBerry smartphone 
is referred to as Unified Search, and it is a convenient way for users to find information 
from built-in application data such as contacts and media files, as well as information 
from the Internet using popular search engines like Google. But that’s not all—starting 
with BlackBerry API 6.0, RIM has made Unified Search available for developers to easily 
integrate their app data. Version 7.0 of the API has been expanded and includes 

CHAPTER 6:  Storing and Searching Data 
158 
adapters to easily make your classes publish information to Unified Search. In this 
section, we’ll explore version 7.0 of this API, and we’ll write a basic app that exposes 
information with Unified Search. 
To illustrate how all this works, imagine we are building an enterprise app that has 
customer information. We will be exposing customer names and addresses on the 
Unified Search, and the search criteria will use customer names and addresses. When a 
user enters a word in Unified Search that begins either customer’s name or address 
stored in our app, our app will appear as one of the search providers giving out search 
results within the Unified Search results. Our goal is to make our app show up in the 
search results, as in Figure 6–18. 
 
Figure 6–18. Our UnifiedSearch application providing search results 
The steps to make an app integrate with Unified Search are quite simple: 
1. Extend the abstract class SearchableDataObject object and override its methods 
for exposing data from your own entity class. 
2. Create an instance of EntityBasedSearchableProvider and supply the search 
fields on this object. 
3. Register your instance of EntityBasedSearchableProvider. 
4. Store an array of SeachableDataObject into your instance of 
EntityBasedSearchableProvider. 

CHAPTER 6:  Storing and Searching Data 
159 
To begin with, create a BlackBerry application in Eclipse and name it UnifiedSearch. 
With the newly created UnifiedSearch app, add two icons in the src/res/img folder. One 
will be used as the app icon and the other will represent the company location. Name 
them app_logo.png and location.png, respectively. We will be using the Apress logo as 
app_logo.png in this example. 
As with any BlackBerry application, we need the starting class that extends 
UiApplication. Let’s call it UnifiedSearchApp; following is a snippet of code for this 
class: 
package com.beginningblackberry.unifiedsearch; 
 
import net.rim.device.api.ui.UiApplication; 
import net.rim.device.api.ui.component.Dialog; 
 
public class UnifiedSearchApp extends UiApplication 
{ 
    public static void main(String[] args) 
    { 
        UnifiedSearchApp theApp = new UnifiedSearchApp();        
        theApp.enterEventDispatcher(); 
    } 
     
    public UnifiedSearchApp() 
    {         
        try { 
 
 
 
pushScreen(new PublisherScreen(new Publisher())); 
 
 
} catch (final Exception e) { 
            UiApplication.getUiApplication().invokeLater(new Runnable() 
            { 
                public void run() 
                { 
                    Dialog.alert(e.getMessage()); 
                    System.exit(0);             
                }  
            });  
 
 
} 
    } 
     
    public static void displayMessage(final String message) 
    { 
        UiApplication.getUiApplication().invokeLater(new Runnable() 
        { 
            public void run() 
            { 
                Dialog.alert(message); 
            }  
        }); 
    } 
} 
Our UnifiedSearchApp class will not compile at this point since we’re missing the 
PublisherScreen and Publisher classes. But before we write the two, let’s follow the 
steps outlined in the beginning of this section. We need to define an entity class. In this 

CHAPTER 6:  Storing and Searching Data 
160 
case, we are exposing a customer’s name and address, so let’s create the Customer
class: 
package com.beginningblackberry.unifiedsearch; 
public class Customer  
{ 
    private String _name; 
    private String _data;         
     
    public Customer(String name, String data) { 
        _name = name; 
        _data = data;         
    } 
    public String toString()  { 
        StringBuffer buffer = new StringBuffer(); 
        buffer.append(getName()).append(", ").append(getData()); 
        return buffer.toString(); 
    } 
     
    public String getName() { 
        return _name; 
    }   
    public String getData() { 
        return _data; 
    }       
} 
There’s nothing fancy with the Customer class. In a real enterprise application, this class 
would have more than name and location data, but this should suit our purposes here. 
To finish off step 1, let’s create a class that extends SearchableDataObject and name it 
SearchableCustomer: 
public class SearchableCustomer extends SearchableDataObject 
{   
} 
In this class, type in the following declaration: 
    public static final String FIELD_NAME = "Name"; 
    public static final String FIELD_DATA = "Data";     
    private Customer _dataObject; 
    private EntityBasedSearchableProvider _searchableProvider; 
    private SearchFieldCriteriaList _searchFieldCriteriaList; 
    private Image _icon; 
    private UiAction _action; 
Mouse over to all underlined fields and select Import until your class compiles cleanly. 
Starting from the top, the two constants here are our criteria fields. The Customer
instance will be the source of our data. The last four variables are all required by the 

CHAPTER 6:  Storing and Searching Data 
161 
framework and need to be returned by overriding the methods of the abstract 
SearchableDataObject.  
Type in the following code snippet to override the methods of SearchableDataObject: 
    public Object getData() 
    { 
        return _dataObject; 
    } 
 
    public SearchFieldCriteriaList getSearchCriteria() 
    { 
        return _searchFieldCriteriaList; 
    } 
 
    public Searchable getSearchable() 
    { 
        return _searchableProvider; 
    } 
 
    public String getSummary() 
    { 
        return _dataObject.getData(); 
    } 
 
    public String getTitle() 
    { 
        return _dataObject.getName(); 
    } 
 
    public Image getIcon() 
    { 
        return _icon; 
    }     
 
    public UiAction getUiActions(Object contextObject, UiAction[] uiActions) 
    { 
        return _action; 
    } 
As you can see, these are all accessor methods, and they merely return the class 
variables we defined. Moving to the constructor of the SearchableCustomer class, we 
need it to accept a Customer object and EntityBasedSearchableProvider object. Our 
constructor will look like this: 
    public SearchableCustomer(Customer dataObject, EntityBasedSearchableProvider 
searchableProvider) 
    { 
        _dataObject = dataObject; 
        _searchableProvider = searchableProvider; 
        _searchFieldCriteriaList = new SearchFieldCriteriaList(); 
 
        Bitmap img = Bitmap.getBitmapResource("location.png"); 
 
        if(img != null) { 
            _icon = ImageFactory.createImage(img); 

CHAPTER 6:  Storing and Searching Data 
162 
        } else { 
            _icon = searchableProvider.getIcon(); 
        } 
        initializeCriteriaFields(); 
    } 
We are simply initializing class variables here from the constructor parameters. We are 
also using location.png to represent the results. Bear in mind that the results screen is 
already provided for us by the Unified Search framework. We’re only supplying the 
results, icon, title, and description. In our case, the title is the customer name and the 
description is the location data. Also add the following function to initialize our 
searchFieldCriteriaList variable: 
private void initializeCriteriaFields() { 
 
        SearchField[] fields = _searchableProvider.getSupportedSearchFields(); 
 
        for(int i = 0; i < fields.length; i++) 
        { 
            String delimiter = " "; 
            String[] searchPhrase = null; 
                         
            if(fields[i].getName().equals(FIELD_NAME)) {                
                searchPhrase = new String[] {_dataObject.getName()};                 
            } else if(fields[i].getName().equals(FIELD_DATA)) {                 
                searchPhrase = new String[] {_dataObject.getData()};                 
            } 
             
            // Add criteria to list 
            SearchFieldCriteria searchFieldCriteria = new SearchFieldCriteria(fields[i], 
searchPhrase, true, delimiter); 
            _searchFieldCriteriaList.addCriteria(searchFieldCriteria);               
        } 
    } 
Before we wrap up this SearchableCustomer class, notice that we haven’t initialized the 
UiAction variable. UiAction is a callback mechanism, so we can provide action relevant 
to the information the user selected on the search results screen. This action could be 
displaying a screen that shows more details. For illustration purposes, let’s display a 
message. Add this inner class to SearchableCustomer: 
    private class LocationAction extends UiAction 
    { 
        protected void runAction() { 
         
Status.show("Do stuff here"); 
        } 
    } 
To finish our SearchableCustomer class, add this code to the bottom of the constructor: 
        _action = new LocationAction(); 
We just finished the first important step. The next steps will require us to create an 
instance of EntityBasedSearchableProvider. To make these tasks a bit easier to follow, 

CHAPTER 6:  Storing and Searching Data 
163 
let’s break things down into two pieces. We’ll create a Publisher class that 
encapsulates the instance of EntityBasedSearchableProvider and PublisherScreen 
class which is our screen for this app and the entry point for the user to publish data. 
Go ahead and create Publisher class and enter the following declarations: 
    private EntityBasedSearchableProvider _searchableProvider; 
    private UiApplication _uiApplication; 
In the class constructor, enter the following: 
    public Publisher() throws Exception 
    { 
        _searchableProvider = new EntityBasedSearchableProvider();         
         
        SearchField[] searchFields = new SearchField[] {new 
SearchField(SearchableCustomer.FIELD_NAME), new 
SearchField(SearchableCustomer.FIELD_DATA)}; 
         
        _searchableProvider.setSupportedSearchFields(searchFields); 
 
        Bitmap bitmap = Bitmap.getBitmapResource("app_logo.png"); 
 
        if(bitmap != null) { 
            Image img = ImageFactory.createImage(bitmap); 
            _searchableProvider.setIcon(img); 
        } 
             
        _searchableProvider.setName("Unified Search");     
         
        if(!_searchableProvider.register().isValid()) { 
            throw new Exception("Failed to register with the Unified Search Framework"); 
        } 
 
        _uiApplication = UiApplication.getUiApplication(); 
    } 
There are a couple of things we’re doing inside this constructor. First, we instantiate our 
EntityBasedSearchableProvider and supply the instance with the search criteria fields, 
and the name and icon of our app. Second and most importantly, we register our 
instance of EntityBasedSearchableProvider to the Unified Search framework by calling 
the register method. And lastly, we initialize a pointer of our UiApplication. This last 
part is needed to provide a listener to EntityBasedSearchableProvider and give 
feedback to users when searchable data gets added, updated, or deleted on your 
provider instance. The hook to provide user feedback is to implement 
AppContentListener. And the fastest way is to implement user feedback on our existing 
code is to make our Publisher class implement AppContentListener, and then enter the 
following code: 
    public void onInsertComplete(final int insertCount) 
    {  
        _uiApplication.invokeLater(new Runnable() { 
            public void run() { 
                // Inform user of successful insert 

CHAPTER 6:  Storing and Searching Data 
164 
                StringBuffer buffer = new StringBuffer("Inserted "); 
                buffer.append(insertCount); 
                buffer.append(" data objects. Try the search word \"acme\"!"); 
                Status.show(buffer.toString(), 2000); 
            } 
        }); 
    } 
 
    public void onUpdateComplete(int updCount) {} 
    public void onDeleteComplete(int delCount) {} 
The three methods are implementations of AppContentListener. We only implemented 
the onInsertComplete method here for illustration purposes—to display a message of 
how many records were inserted. 
Finally, for this Publisher class, let’s add a public method to insert and publish our 
SearchableCustomer data: 
    public void insertData(Vector dataVector) 
    { 
        SearchableCustomer[] dataEntities; 
         
        synchronized(dataVector) 
        { 
            // Build a UnifiedSearchDemoEntity array out of the given data objects 
            int size = dataVector.size(); 
            dataEntities = new SearchableCustomer[size]; 
 
            for(int i = size - 1; i >= 0; --i) 
            { 
                Customer object = (Customer)dataVector.elementAt(i); 
                dataEntities[i] = new SearchableCustomer(object, _searchableProvider); 
            } 
        } 
         
        _searchableProvider.addSearchableData(dataEntities, this); 
    } 
We are going to call this method inside the Publisher screen, which is the last step in 
this process. 
Our last class to create is the PublisherScreen. This will be a simple screen that has a 
ButtonField for letting the user create and publish the data, and also an 
ObjectListField to display the data that’s published. Enter the code snippet below for 
this class: 
import java.util.*; 
import net.rim.device.api.ui.*; 
import net.rim.device.api.ui.component.*; 
import net.rim.device.api.ui.container.*; 
 
public class PublisherScreen extends MainScreen implements FieldChangeListener 
{     
    private ObjectListField _listField;     

CHAPTER 6:  Storing and Searching Data 
165 
    private ButtonField _publishButton; 
    private Vector _dataObjects;     
    private Publisher _publisher;    
       
    public PublisherScreen(Publisher publisher) {       
        super(NO_VERTICAL_SCROLL); 
                
        _publisher = publisher; 
        _dataObjects = new Vector();            
         
        setTitle("Unified Search");         
         
        _listField = new ObjectListField();                 
         
        _publishButton = new ButtonField("Add and Publish Data", 
ButtonField.CONSUME_CLICK);                 
        _publishButton.setChangeListener(this);        
         
        VerticalFieldManager vfm = new VerticalFieldManager(VERTICAL_SCROLL);                
        vfm.add(_publishButton); 
        vfm.add(new SeparatorField()); 
        vfm.add(_listField); 
         
        add(vfm);         
    }  
     
    protected boolean onSavePrompt() {         
        if(_dataObjects.size() == 0) { 
            return true; 
        }         
         
        return super.onSavePrompt();  
    }    
     
    public void save() { 
     
if (_dataObjects.size()==0) { 
            _dataObjects.addElement(new Customer("ABC Corp", "111 One St, New York, 
NY")); 
            _dataObjects.addElement(new Customer("ACME LTD", "1 Acme St, Acme City")); 
             
            Object[] elementArray = new Object[_dataObjects.size()]; 
            _dataObjects.copyInto(elementArray); 
            _listField.set(elementArray);        
 
            _publisher.insertData(_dataObjects);       
     
} 
         
        setDirty(false);             
    }   
 
    public void fieldChanged(Field field, int context) {         
        if (field == _publishButton) { 
         
save(); 
        }                
    } 
} 

CHAPTER 6:  Storing and Searching Data 
166 
Now save your project and run it on the simulator. You’ll get a screen like the one shown 
on the left in Figure 6–19. When you click the Add and Publish Data button, the pop-up 
message on the right will appear after the data is published and becomes searchable.  
 
Figure 6–19. Publishing searchable data to Unified Search 
At this point, you can invoke Unified Search in the home screen. Search for acme and 
see the app in action. When searching, the app icon should display with the number of 
hits, just like in Figure 6–18. If you click the UnifiedSearch app icon, detailed information 
about the search result provided from the SearchableCustomer class will be displayed, 
as shown on the left in Figure 6–20. Clicking an item on the list will call our app with the 
UiAction we provided in the SearchableCustomer class, and in this case we’re having it 
display a message, as shown on the right in Figure 6–20. 

CHAPTER 6:  Storing and Searching Data 
167 
 
Figure 6–20. Displaying search result information (left) and providing a callback display (right) 
With this simple example, we’ve illustrated how easy it is to integrate an app with Unified 
Search. Of course, more code might be needed depending on how extensively you want 
the information presented on the screen—but the steps needed are the same. 
Summary 
You should now have a good understanding of how to use persistence on the 
BlackBerry; at least you’ve seen a couple of the most used and most useful methods. 
We built an application that saved and loaded a few different types of data using the 
BlackBerry Persistent Store, and we created and saved our own persistent class. We 
also created an application that used the FileConnection API to browse the BlackBerry 
file system and view an image stored in it, and then we extended the application to 
enable us to write a copy of that image back to the file system. We also created an 
application that makes use of SQLite database if you prefer to use a cleaner, database-
like coding experience when dealing with your application data. Using these 
mechanisms, your potential universe of BlackBerry applications has suddenly expanded. 
You can now create applications that save data between invocations, and there are 
many commercial applications that don’t require any more knowledge of BlackBerry 
programming than you already have. To top it off, you now have the ability to make your 
application provide search results within the Unified Search framework, a seamless user 
experience making your app appear fully integrated to the BlackBerry platform. 
Congratulate yourself for getting this far, and get ready. We’re about to expand the 
reach of your BlackBerry applications even further—literally—because in the next 
chapter, you’ll learn how to create applications that can send and receive data over a 
wireless network. 

 
169 
 
 
 
Chapter 
Hello Out There! Making a 
Network-Enabled 
Application 
The BlackBerry was built to communicate. Sending and receiving e-mail, browsing the 
Web, and often even downloading applications to your device requires access to the 
wireless data network. Naturally, many of the most compelling BlackBerry applications 
also heavily feature networking as a core part of their functionalities. 
Fortunately, the BlackBerry API offers a range of choices for getting your application to 
communicate with servers, other systems on the Internet (including corporate networks), 
and other short range communication devices (like Bluetooth and NFC). For the most 
part, you don’t have to worry about different device or wireless network characteristics; 
the BlackBerry platform abstracts that detail so you can concentrate on application-
specific details. 
This chapter will discuss the BlackBerry data networking functionality, the different 
methods that a BlackBerry can use to connect, and when and how you might want to 
use them. You’ll then develop a couple of applications to explore making HTTP and TCP 
socket connections to interact with a web application on the Internet. 
Different Ways to Connect 
The BlackBerry offers a number of different methods of making network connections. 
These include the BlackBerry Enterprise Server/BlackBerry Mobile Data System 
(BES/MDS), direct Transmission Control Procotol/Internet Protocol (TCP/IP), BlackBerry 
Internet Service (BIS), Wi-Fi, Wireless Access Protocol (WAP) 1.0, and WAP 2.0. (See 
Figure 7–1.) They each have certain advantages and disadvantages, and depending on 
the configuration of your device and environment, some of the methods might not be 
available. Generally, you can make all supported types of network connections: HTTP 
7 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
170 
connections and TCP and UDP sockets over any of these connection methods. I’ll cover 
the different network connection methods and briefly cover short-range communication. 
 
Figure 7–1. Some of the different ways a BlackBerry device can make wireless connections. 
BES/MDS 
The BES allows BlackBerry devices to make network connections securely to servers 
inside a corporate network. This is accomplished through the MDS component of the 
BES, so connections made this way are sometimes referred to as BES/MDS 
connections. Connections made by the BlackBerry device using the MDS are actually 
proxied by the MDS; that is, the MDS makes connections on behalf of the BlackBerry 
device, and data is transferred to and from the device over the same secure channel that 
corporate BlackBerry e-mail uses.  
Obviously, the BES/MDS connection method is available only to devices that have been 
activated on a BES. The advantage to using the BES/MDS is that because the MDS 
makes connections, it can resolve any servers that can be reached from the server 
running the BES, meaning the servers behind the corporate firewall are reachable. The 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
171 
disadvantage is that if there are any restrictions on connections going from the BES to 
servers outside the network, those restrictions affect BlackBerry connections made 
through the BES, too. 
Note that by default, the browser on devices attached to a BES uses the MDS to make 
connections, meaning you can use the browser to access internal web servers. In fact, 
this is a good way to tell if your device uses the MDS to make connections; if the title of 
your browser application is called “BlackBerry Browser,” then your device uses the MDS 
to make connections. 
Direct TCP/IP 
Just like most other Smartphones, BlackBerry devices can also make direct TCP/IP 
connections using the wireless carrier’s infrastructure without going through any 
BlackBerry-specific service. This method works with most devices, although it can be 
disabled by a BES administrator for devices connected to a BES.  
The advantages are that this method is available on almost all BlackBerry devices. 
Occasionally, configuration problems with the Access Point Name (APN) used in direct 
TCP/IP connections (see the note) can cause problems with TCP/IP connections. Also, 
though it’s becoming rarer, some BlackBerry wireless plans don’t include direct TCP/IP 
access. 
NOTE: The BlackBerry device uses the APN to make direct TCP/IP connections. The APN varies 
from carrier to carrier, and usually it’s preconfigured on the device by the carrier; however, in 
some cases the configuration may have been lost. You can access APN configuration from the 
device options by selecting Advanced Options ➤ TCP/IP. Some carriers require a username and 
password along with the APN. A search on the Internet will usually provide a list of settings for 
the major wireless carriers. 
You can also specify the APN, username, and password if necessary when making your 
connection. This is tricky to manage with so many configurations and is outside the scope of this 
book; for more information, see the BlackBerry JavaDocs for 
javax.microedition.io.Connector. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
172 
BIS 
BIS provides much of the same functionality for individual BlackBerry users as the BES 
does for corporate users, without the same level of security. If you use a BlackBerry 
device that’s not connected to a BES, you’re already using the BIS to send and receive 
your e-mail. The BIS is also able to proxy connections in the same way as the BES/MDS 
does. Because the BIS can access servers only on the Internet, it doesn’t provide the 
access to a corporate network that using the BES/MDS does. The main advantage to 
using a BIS connection over a direct TCP/IP connection is that some BlackBerry 
wireless plans don’t include direct TCP/IP access, but almost all include BIS access as 
it’s required for non-BES e-mail. To enable your application to make connections 
through the BIS, you must be part of the BlackBerry Alliance Program and receive 
approval for your application to use the BIS. For that reason, I won’t cover BIS 
connections in this book, but the basic mechanism is similar to the other connection 
types. 
Wi-Fi 
Many BlackBerry devices include Wi-Fi networking (802.11 B/G/N and sometimes A). 
This allows your device to connect to a network via a Wi-Fi router. You generally must 
set up access for specific Wi-Fi routers. This is up to the device user, not the application 
developer. Assuming the device has been connected to a Wi-Fi router, however, your 
application can make network connections over Wi-Fi. The advantages are better speed, 
lower latency, and the fact that no carrier data charges are incurred. The disadvantage is 
that Wi-Fi coverage is not as widespread as wireless network coverage for most users, 
so you should support at least one other connection method. 
In the case of applications using a BES/MDS or BIS connection, the device can be 
configured to automatically use an appropriate Wi-Fi hotspot where available to connect 
to the BES or BIS. This requires no additional effort on the part of the application; it’s 
handled automatically by the BlackBerry platform. You can, however, also make a direct 
Wi-Fi connection explicitly from the application. 
WAP 2.0 
WAP 2.0 connects through the wireless carrier’s WAP gateway. Similar to direct TCP/IP 
connections, WAP 2.0 doesn’t use any BlackBerry specific infrastructure. The wireless 
plan associated with the BlackBerry device must also support WAP 2.0 access. 
Fortunately, this is the case with almost all devices sold. The big advantage of WAP 2.0 
over direct TCP/IP is that no APN configuration is necessary, meaning that devices are 
more likely to be able to connect without needing any additional configuration. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
173 
WAP 1.0 
Unlike all the other connection methods mentioned, WAP 1.0 doesn’t support the full 
range of connection types. Specifically, security is limited. Though WAP 1.0 is supported 
by all BlackBerry devices, its limitations mean that unless you have a specific reason, 
you should use the other connection methods instead. 
Short-Range Communication 
While short-range communication doesn't allow your application to connect to a 
network directly, it does allow direct connection to short-range enabled devices that 
potentially connect you to other networks. While it is out of scope for this book to cover 
short-range communication in detail, it does exist. 
Bluetooth 
The BlackBerry API (net.rim.device.api.bluetooth) allows you to make connections to 
other Bluetooth enabled devices.  
Near Field Communication (NFC) 
New BlackBerry Smartphones have a NFC receiver and transmitter built in them so that 
your application can interact with NFC-enabled devices. With the NFC API 
(net.rim.device.api.io.nfc), it allows your application to read and write tags that are 
formatted to the NDEF (NFC Data Exchange Format) technical specification.  
Recommendation 
By default, the BlackBerry uses the BES/MDS as the connection method for devices 
activated on a BES, and it uses the TCP/IP connection method for other devices. For 
devices activated on a BES, this is reasonable behavior because the BES connection is 
at least as secure as a direct TCP/IP connection. For devices not activated on a BES, a 
good method is to attempt to use WAP 2.0 first because a given device is more likely to 
be configured to use WAP 2.0 correctly and fall back to direct TCP/IP if necessary (I’ll 
cover how to do that later in this chapter). If you’re using BES/MDS, you can rely on the 
automatic Wi-Fi fallback behavior. If you’re using direct TCP/IP, you might want to 
provide some Wi-Fi functionality, depending on how heavily your application uses the 
network. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
174 
Service Book 
The BlackBerry service book is a configuration storage system that the device uses to 
maintain information about various aspects of its configuration. The service book 
contains records that govern everything from optional applications that are installed or 
visible to e-mail account configuration. The service book records are also used to 
maintain information about the different connection methods available to a given device. 
You can see the service book on a BlackBerry device (or the BlackBerry simulator) by 
opening device Options and then clicking Advanced Options and Service Book (see 
Figure 7–2). 
 
Figure 7–2. Some typical service book records on a BlackBerry device 
Each record contains two identifiers, a CID and a UID. The UID uniquely identifies the 
record on the device, and the CID gives information about what type of record it is. For 
example, on a device with more than an associated e-mail address, there are many 
service records with a CID of CMIME, but each will have a different UID. 
The service book is important for networked applications because most of the 
connection methods have an associated record, and this can be a quick way to check to 
see if your device has been provisioned correctly for a given connection type. The one 
exception is direct TCP/IP, which doesn’t have an associated service record. 
Configuration information for direct TCP/IP connections is specified in the TCP/IP 
options screen, as discussed previously. 
There are many different types of service book records. It can be interesting to look 
through them and see what’s available; you shouldn’t try to change or delete anything 
unless you know what you’re doing. For the purposes of this chapter, you’ll explore only 
the specific service records that you need. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
175 
The MIDP Connection Framework 
The BlackBerry uses the same connection framework as defined in the MIDP standard, 
with some extra functionality specific to the BlackBerry platform.  
Connector 
All connections are initiated using the javax.microedition.io.Connector class. You 
briefly used this class in Chapter 6 to open a connection to the file system. The same 
class is used for HTTP, HTTPS, socket, and many other connection types. 
For example, to open an HTTP connection to retrieve a web page, use the following: 
HttpConnection connection = (HttpConnection)Connector.open( http://www.apress.com/ ); 
Note that this just retrieves the primary content of the page. To get images and other 
resources, you’d have to request them specifically. 
Connections 
All the Connector.open methods return a subclass of the 
javax.microedition.io.Connection interface. The specific type depends on the scheme 
of the URL passed in (the http:// portion). There’s a fairly hefty hierarchy of connection 
types, but for most purposes you’ll directly use only a few, as shown in Table 7–1. 
Table 7–1. Common Network Connection Types and Features  
Connection Type 
Connection Class 
URL Scheme 
HTTP 
HttpConnection 
http:// 
HTTPS (secure HTTP over TLS) 
HttpsConnection 
https:// 
TCP/IP socket 
SocketConnection 
socket:// 
SSL or TLS secure socket 
SecureConnection 
ssl:// or tls:// 
All of the previous network connection types allow a similar format for the URL: 
scheme://host:port/path[optional parameters] 
For example: 
                     HttpConnection connection = 
(HttpConnection)Connector.open("http://www.apress.com:80/book/catalog"); 
 
SocketConnection socket = SocketConnection)Connector.open("socket://www.apress.com:80"); 
You used FileConnection in the previous chapter, which, as you saw, uses the file:// 
scheme. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
176 
HTTP Basics 
Because you’ll explore HTTP networking first, here's a quick review of the basics of the 
protocol. If you’re familiar with HTTP, you can probably safely skip this section, but let's 
briefly cover the basics of how the protocol works before continuing to ensure all the 
terms are fresh in your mind. 
HTTP is the fundamental protocol of the World Wide Web. It’s a connectionless request-
response protocol, meaning there is no concept of a persistent connection between a 
series of requests. 
Request and Response 
An HTTP request is a message sent from the client (in this case, the BlackBerry device) 
to the server. The server sends back a response. The request and response might 
contain some content called the body. In addition, the response always contains a 
numeric response code, which lets you know if the request was successful, if it failed, or 
if more action is needed. It gives more detailed information about what exactly 
happened (e.g. the cause of failure). 
Methods 
HTTP supports several request methods, which help the server know how to handle the 
request. The most important HTTP methods for your purposes are: 
 GET: Used to retrieve a resource (such as a web page or image) from a 
URL 
 POST: Used to send data to a server (such as the content of a form) 
based on a URL 
In fact, the BlackBerry supports only the GET, POST, and HEAD methods; it doesn’t  
support custom methods. For most applications, this is sufficient, but it is something to 
keep in mind. 
Headers 
Finally, in addition to the main content of the request and response (the body), HTTP 
allows additional data to be sent in the form of headers. They can be sent with the 
request to the server and the response from the server, and they can contain arbitrary 
text data. There are many standard headers, and the connection API contains methods 
for easily accessing some of the most common ones. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
177 
The Test Web Application 
I created a simple web application to let you easily explore performing HTTP POSTs and 
GETs from the BlackBerry (See Figure 7–3). You can access this application using your 
browser at http://beginningblackberry.appspot.com. 
 
Figure 7–3. The Test Web Application 
It consists of a single HTML page containing a PNG image and a text box. When you 
enter text into the box and click Go! it displays the words you typed in reverse order, 
one per line with an HTML line break tag between them (see Figure7–4 and Figure 7–5). 
 
Figure 7–4. Typing text into the web application 
 
Figure 7–5. The resulting output from the previous figure 
The Networking Application 
Create a new BlackBerry application project called Networking. Create the application 
and main screen classes in the com.beginningblackberry.networking package as 
follows: 
NetworkingApplication.java: 
package com.beginningblackberry.networking; 
 
import net.rim.device.api.ui.UiApplication; 
 
public class NetworkingApplication extends UiApplication { 
 
    public NetworkingApplication() { 
        NetworkingMainScreen scr = new NetworkingMainScreen(); 
        pushScreen(scr); 
    } 
 
    public static void main(String[] args) { 
        NetworkingApplication application = new NetworkingApplication(); 
        application.enterEventDispatcher(); 
    } 
} 
NetworkingMainScreen.java: 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
178 
package com.beginningblackberry.networking; 
 
import net.rim.device.api.ui.container.MainScreen; 
 
public class NetworkingMainScreen extends MainScreen { 
    public NetworkingMainScreen() { 
    } 
} 
Some Controls 
The first functionality you’ll build is the capability to get images and web page text from 
the Web. You’ll add a few controls here. First, an edit field to enter the URL, and then a 
couple of fields to display resources that the application fetches: a BitmapField and 
another new control called RichTextField. Make the following changes to 
NetworkingMainScreen.java: 
    import net.rim.device.api.ui.component.BitmapField; 
import net.rim.device.api.ui.component.EditField; 
import net.rim.device.api.ui.component.LabelField; 
import net.rim.device.api.ui.component.RichTextField; 
import net.rim.device.api.ui.component.SeparatorField; 
    private EditField urlField; 
    private BitmapField imageOutputField; 
    private RichTextField textOutputField; 
 
    public NetworkingMainScreen() { 
        setTitle("Networking"); 
        urlField = new EditField("URL:", ""); 
        textOutputField = new RichTextField(); 
        imageOutputField = new BitmapField(); 
 
        add(urlField); 
        add(new SeparatorField()); 
        add(new LabelField("Image retrieved:")); 
        add(imageOutputField); 
        add(new SeparatorField()); 
        add(new LabelField("Text retrieved:")); 
        add(textOutputField); 
    } 
RichTextField is a powerful control. It enables you to display a lot of text on multiple 
lines with built-in line wrapping and different styles for different parts of the text. For this 
application, you’ll take advantage of the multiline and line wrapping capabilities of 
RichTextField to display the text result of the network requests. You need to add a 
separate LabelField because RichTextField has no support for a built-in label. 
Next, add a menu item and skeleton method to initiate the HTTP request to 
NetworkingMainScreen. 
    private void getURL() { 
    } 
 
    protected void makeMenu(Menu menu, int instance) { 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
179 
        super.makeMenu(menu, instance); 
        menu.add(new MenuItem("Get", 10, 10) { 
            public void run() { 
                getURL(); 
            } 
        }); 
    } 
Making an HTTP Connection 
Now let’s get to the details of how to make the request. First, note one critical issue. 
Remember back in the early part of the book when we discussed the event thread? That 
information is important now. When networking on the BlackBerry, always remember the 
following: 
Never perform a network operation on the event thread. 
Earlier, I said that it’s a bad idea to do anything that can take a lot of time on the event 
thread because that would have the effect of freezing the user interface, making the user 
think the application had hung or crashed. In the case of networking, the situation is 
worse. Depending on the device and configuration, the API often throws an exception if 
you try to initiate a network connection from the event thread. 
The HttpRequestDispatcher Class 
You need to create a separate thread for the HTTP request. Do this by creating a new 
class that extends java.lang.Thread. Call the class HttpRequestDispatcher. 
public class HttpRequestDispatcher extends Thread { 
    private String url; 
    private String method; // GET or POST 
    private NetworkingMainScreen screen; 
 
    public HttpRequestDispatcher(String url, String method, NetworkingMainScreen screen) 
{ 
        this.url = url; 
        this.method = method; 
        this.screen = screen; 
    } 
 
    public void run() { 
 
    } 
} 
Notice you’re passing in an instance of the main screen. This is to give you a way to 
update the screen when a request succeeds or fails. You’ll need to add a couple of 
methods to let you send these notifications. Add the following method skeletons to 
NetworkingMainScreen (you’ll fill them in later): 
public class NetworkingMainScreen extends MainScreen { 
              // ... 
              public void requestSucceeded(byte[] result, String contentType) { 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
180 
 
              } 
 
              public void requestFailed(String message) { 
 
              } 
If you wanted to make your HttpRequestDispatcher more general purpose, you’d define 
an interface containing the previous methods for NetworkingMainScreen to implement. 
Because you’re just illustrating basic concepts here, you’ve elected to use 
NetworkingMainScreen directly and eliminate the extra Java file that an interface would 
require. 
The Run Method  
You will perform only GET requests at first. There will be an extra line or two for POST 
requests. All the work is done in the run method. 
import java.io.ByteArrayOutputStream; 
import java.io.IOException; 
import java.io.InputStream; 
import javax.microedition.io.Connector; 
import javax.microedition.io.HttpConnection;     
public void run() { 
        try { 
               HttpConnection connection = (HttpConnection)Connector.open(url); 
               connection.setRequestMethod(method); 
 
               int responseCode = connection.getResponseCode(); 
               if (responseCode != HttpConnection.HTTP_OK) { 
                   screen.requestFailed("Unexpected response code: " + responseCode); 
                   connection.close(); 
                   return; 
               } 
 
               String contentType = connection.getHeaderField("Content-type"); 
               ByteArrayOutputStream baos = new ByteArrayOutputStream(); 
 
               InputStream responseData = connection.openInputStream(); 
               byte[] buffer = new byte[10000]; 
               int bytesRead = responseData.read(buffer); 
               while(bytesRead > 0) { 
                    baos.write(buffer, 0, bytesRead); 
                    bytesRead = responseData.read(buffer); 
               } 
               baos.close(); 
               connection.close(); 
 
               screen.requestSucceeded(baos.toByteArray(), contentType); 
        } catch (IOException ex) { 
               screen.requestFailed(ex.toString()); 
        } 
    } 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
181 
The first couple of lines set up the connection parameters. 
               HttpConnection connection = (HttpConnection)Connector.open(url); 
               connection.setRequestMethod(method); 
As mentioned previously, you get an HttpConnection back from Connector.open only if 
the URL starts with http://. Be sure to type that into the text field when using the 
application!  
At this point in the run method, network activity has not occurred yet. The connection is 
still in the setup state. HttpConnection doesn’t actually start a connection until you ask 
for some data that it needs to request from the server. This is useful to remember 
because there’s often a noticeable delay in initiating a network connection, and in this 
case, it’ll happen when the next line is called. 
               int responseCode = connection.getResponseCode(); 
The response code is just the standard HTTP response code value: 200 if the request 
succeeded and some other value if it didn’t (it’s slightly more complicated, but for your 
purposes, that’s fine). Test the response code and if it’s not 200 
(HttpConnection.HTTP_OK), notify the main screen and stop. 
               if (responseCode != HttpConnection.HTTP_OK) { 
                    screen.requestFailed("Unexpected response code: " + responseCode); 
                    connection.close(); 
                    return; 
               } 
Next, retrieve the value of the Content-type response header. Getting a header is 
another method that would initiate the connection if you hadn’t already called 
getResponseCode. 
              String contentType = connection.getHeaderField("Content-type"); 
Finally, open the connection’s input stream and read the data into a buffer. You use a 
ByteArrayOutputStream as a convenient way to buffer the bytes from the input stream. 
     ByteArrayOutputStream baos = new ByteArrayOutputStream(); 
               InputStream responseData = connection.openInputStream(); 
               byte[] buffer = new byte[10000]; 
               int bytesRead = responseData.read(buffer); 
               while(bytesRead > 0) { 
                   baos.write(buffer, 0, bytesRead); 
                   bytesRead = responseData.read(buffer); 
               } 
               baos.close(); 
               connection.close(); 
Finally, you pass the data along with the content type back to the main screen to deal 
with  
the following: 
screen.requestSucceeded(baos.toByteArray(), contentType); 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
182 
Initiating the Connection 
The getURL method requires only a couple of lines to initiate the connection. 
    private void getURL() { 
        HttpRequestDispatcher dispatcher = new HttpRequestDispatcher(urlField.getText(), 
"GET", this); 
        dispatcher.start(); 
               } 
Displaying the Response Failed Notification 
Let’s start modifying NetworkingMainScreen to handle the results of the HTTP request. 
First, you’ll have requestFailed display a dialog box when called. Remember, this 
method is being called from a different thread than the event thread, so you can’t 
directly call Dialog.alert. Instead, you’ll use UiApplication.invokeLater to let the 
event thread display the dialog at the next available opportunity. 
    public void requestFailed(final String message) { 
           UiApplication.getUiApplication().invokeLater(new Runnable() { 
                   public void run() { 
                           Dialog.alert("Request failed.  Reason: " + message); 
                   } 
           }); 
    } 
NOTE: If you’re paying close attention you’ll notice one change to the method signature: the 
message parameter is final. This is necessary because you use it inside an anonymous inner 
class (the Runnable that you create). “Final” just means that you’re not allowed to do 
something like this in the body of the requestFailed method: 
                          message = ""; // ERROR – will not work! 
Testing It  
You’re now at a stage where you can see a network connection happen: by typing in a 
URL to a page that doesn’t exist, you’ll get a failed notification and see a dialog. Before 
you run the application in the simulator, there’s an additional topic you need to know: 
the MDS simulator. 
The MDS Simulator 
By default, the BlackBerry makes connections using the BES/MDS method. To let you 
test this, the Eclipse plug-in include an MDS simulator. This needs to be running to 
make MDS-enabled connections from your simulator. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
183 
Fortunately, running the MDS simulator is easy. In the JDE plug-in for Eclipse, open your 
debug configuration, and on the Simulator tab, ensure "Launch Mobile Data System 
Connection Service (MDS-CS) with simulator" is enabled, as shown in Figure 7–6. 
 
 
Figure 7–6. Enabling the MDS simulator from the Eclipse plug-in 
Running the Application 
Start your debug session. Along with the simulator, you’ll see a command prompt 
window open running the MDS (see Figure 7–7). 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
184 
 
Figure 7–7. The MDS simulator running 
Let’s test the requestFailed method by making a request for a page that doesn’t exist. 
Start the application, type http://beginningblackberry.appspot.com/nopage.html in the 
URL field, and then open the menu and click Get, as shown in Figure 7–8. 
 
Figure 7–8. Type a URL to a nonexistent page, and then click Get. 
After a momentary delay, you should see a dialog informing you that the request failed 
with a response code of 404, which is HTTP speak for “not found” (see Figure 7–9). 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
185 
 
Figure 7–9. URL not found 
Believe it or not, this is a good result. The 404 error is sent by the server, meaning 
you’ve successfully made a network connection! Next, you’ll fill in the details to handle a 
request for a resource that actually exists. 
Handling Successful Requests 
You’ll do the following things in the requestSucceeded method: 
 Check the contentType. 
 If the content type is an image (image/png, image/jpeg, image/gif), 
decode the image and display it. 
 If the content type is text (text/plain, text/html, or text/anything), 
display the text in the RichTextField. 
 Otherwise, display an error message. 
The code for this is actually simple. Again, this method is called from outside the event 
thread so you have to be sure to get the event lock before you manipulate the UI. 
    public void requestSucceeded(byte[] result, String contentType) { 
            if (contentType.equals("image/png") || 
                            contentType.equals("image/jpeg") || 
                            contentType.equals("image/gif")) { 
              Bitmap bitmap = Bitmap.createBitmapFromBytes(result, 0, result.length, 1); 
              synchronized (UiApplication.getEventLock()) { 
                    imageOutputField.setBitmap(bitmap); 
                                       } 
                                        
              } 
              else if (contentType.startsWith("text/")) { 
                       String strResult = new String(result); 
                       synchronized (UiApplication.getEventLock()) { 
                              textOutputField.setText(strResult); 
                       } 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
186 
              } 
              else { 
                       synchronized (UiApplication.getEventLock()) { 
                              Dialog.alert("Unknown content type: " + contentType); 
                       } 
              } 
    } 
Everything is straightforward. The only thing to note is that you used three separate 
synchronized blocks instead of making the entire method synchronized. Generally, this 
is a good UI programming principle. You minimize the amount of work done in the 
synchronized blocks so you can minimize the impact to the user experience. In this 
case, it probably wouldn’t be noticeable, but if you encoded or scaling scaled a very 
large image or large amount of text, putting all that into the synchronized block would 
lock up the event thread for longer. 
Try It  
Now, run the application again. First, try the URL for the main test web application: 
http://beginningblackberry.appspot.com. Enter the URL, and in the menu, click Get. 
You should see a lot of HTML in the text area, such as what you see in Figure 7–10. 
 
Figure 7–10. Retrieving the HTML of the test web application 
When you opened an HttpConnection to http://beginningblackberry.appspot.com, the 
server sent back “text/html” as the content type, so the method interpreted the data as 
a string and put the text into the RichTextField. Now let’s verify that the code for 
retrieving an image works, too. Because you can see the URL to the apress_logo image 
in the HTML—img/apress_logo.png—you just need to add that to the end of the URL to 
get http://beginningblackberry.appspot.com/img/apress_logo.png. Then, select Get 
again, and you’ll see a result like that in Figure 7–11. 
x

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
187 
 
Figure 7–11. Retrieving the logo from the web application 
In this case, the server sent back image/png as the content type, so the code interpreted 
the data from the input stream as the bytes for an image and successfully decoded and 
displayed it. 
Two-Way Interaction: Sending Data via HTTP POST 
You’ll complete your exploration of HTTP using the BlackBerry by sending some data to 
the web application using an HTTP POST. Remember that the web application takes a 
series of words separated by spaces and returns the same list of words in reverse order 
but separated by new lines and HTML break (br) tags. 
How an HTML Form Works 
You might already know this, but let’s review how a POST from an HTML form in a 
browser works. You will duplicate this functionality in the Networking application. 
The web application contains this HTML: 
<form action="/" method="POST"><br />  
        <input type="text" name="content"></input> 
        <input type="submit" value="Go!"/>  
</form> 
This defines a form that the browser uses to send data to the web application. 
Specifically, the first line says to send the data via HTTP POST to the URL “/,” which is 
just the base URL of the web application.  
The input type= submit  defines the Go button as the button that invokes the POST.  
Finally, the input type= text  line defines the text box and gives it the name content. 
The web application expects the body of the POST request to contain something like 
the following: 
        content=ONE+TWO+THREE 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
188 
The + characters are a way of encoding spaces in the input. You have to do this, too. In 
addition, the content type header in the request to the server should be application/x-
www-form-urlencoded to indicate that the content is encoded in this way. 
Modifying HttpRequestDispatcher 
Most of the code to perform a POST is the same as to perform a GET, so you’ll just modify 
the run method of HttpRequestDispatcher to handle both. First, you need a way to pass 
the POST body to HttpRequestDispatcher. Create a new member variable called postData 
and a new constructor so you can initialize it. 
        private byte[] postData; 
 
        public HttpRequestDispatcher(String url, String method, 
                          NetworkingMainScreen screen, byte[] postData) { 
                 this.url = url; 
                 this.method = method; 
                 this.screen = screen; 
                 this.postData = postData; 
        } 
Next, you need to check if you have post data to send before initiating the connection. If 
you do, you’ll set the content-type header by using 
HttpConnection.setRequestProperty, and then open an output stream for the 
connection and write the data. Modify the run method by adding the following lines: 
                 if (method.equals("POST") && postData != null) { 
                           connection.setRequestProperty("Content-type", "application/x-
www-form-urlencoded"); 
                           OutputStream requestOutput = connection.openOutputStream(); 
                           requestOutput.write(postData); 
                           requestOutput.close(); 
                 } 
Everything else should stay the same. You’ll handle the response the same way by 
calling requestSucceeded in NetworkingMainScreen. 
Modifying NetworkingMainScreen 
You need two things in your screen: an edit field to enter the post data and a way to 
invoke the Post request (a menu item and method). 
Add the edit field first. Declare a new EditField called postDataField. 
        private EditField postDataField; 
Then, initialize it and position it right below the URL field. 
                 add(urlField); 
                 add(new SeparatorField()); 
                               
                 postDataField = new EditField("Post data:", ""); 
                 add(postDataField); 
                 add(new SeparatorField()); 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
189 
                               
                 add(new LabelField("Image retrieved:")); 
                 add(imageOutputField); 
Next, define the postURL method. It does the same thing as the getURL method with the 
additional functionality of taking the text from the post data edit field and encoding it for 
the body of the post. You’ll use the class 
net.rim.blackberry.api.browser.URLEncodedPostData to do the actual encoding and 
formatting of the data for the request body. 
        private void postURL() { 
                 String postString = postDataField.getText(); 
                 URLEncodedPostData encodedData = new URLEncodedPostData(null, false); 
                 encodedData.append("content", postString); 
                 HttpRequestDispatcher dispatcher = new HttpRequestDispatcher(urlField 
                                  .getText(), "POST", this, encodedData.getBytes()); 
                 dispatcher.start(); 
        } 
If postDataField contains the text “A B C”, the byte[] output from encodedData will be 
“content=A+B+C . 
Adding the menu item is exactly the same as the Get menu item. Add the following lines 
to makeMenu: 
                 menu.add(new MenuItem("Post", 10, 10) { 
                        public void run() { 
                                 postURL(); 
                        } 
                 }); 
You’re done. You don’t need to make modifications to requestSucceeded because you 
want the same functionality, which is to display the text. 
Let’s try it out. Enter http://beginningblackberry.appspot.com in the URL field and 
ONE TWO THREE FOUR FIVE in the Post data field, and then click Post from the menu. 
You should see the words, one per line, in the output, as shown in Figure 7–12. 
 
 
Figure 7–12. The result of posting ONE TWO THREE FOUR FIVE 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
190 
Making Secure HTTP (HTTPS) Connections 
To make a connection to a secure HTTP server, replace http:// with https://  
in the Connector.open method. Fortunately, the web application also supports  
HTTPS connections, so simply substitute https:// into the URL to make 
https://beginningblackberry.appspot.com, and then click Get. The result will look  the 
same as the non-secure HTTP connection (see Figure 7–13). 
 
 
Figure 7–13. Retrieving the web application over HTTPS 
Performing the POST works in a similar way. You haven’t had to change the  
connection-handling code because Connector.open returns an HttpsConnection  
instead of HttpConnection, and HttpsConnection derives from HttpConnection. You can, 
however, detect this and display some information about the connection (in this case, 
the issuer of the TLS certificate). Add the following lines to the run method of 
HttpRequestDispatcher right after getting the response code: 
                if (connection instanceof HttpsConnection) { 
                         HttpsConnection secureConnection = (HttpsConnection)connection; 
                         final String issuer = 
secureConnection.getSecurityInfo().getServerCertificate().getIssuer(); 
                         UiApplication.getUiApplication().invokeLater(new Runnable() { 
                                  public void run() { 
                                           Dialog.inform("Secure Connection, certificate 
issued by: " + issuer); 
                                  } 
                         });                                    
                } 
Now, if you enter the https:// URL, you’ll get a dialog with some info, as shown in  
Figure 7–14. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
191 
 
 
Figure 7–14. Information about the security of the connection 
NOTE: Something to be aware of with HTTPS connections—and this applies to secure socket 
(TLS and SSL) connections, too—is that things are simple only when the certificate provided by 
the server is known to the BlackBerry, or, in the case of a BES/MDS connection, known to the 
BES. In the case of an unknown certificate such as a self-signed certificate, a prompt is 
displayed to the user asking them to verify the connection. If the connection is a BES/MDS 
connection, this prompt is displayed only if certificate verification is done on the device by adding 
the EndToEndRequired=true parameter to the end of the URL to force certificate verification 
to happen on the device. Otherwise, the connection just fails. If you stick with certificates from 
known certification authorities, you shouldn’t have to worry about any of this. 
Summary: HTTP Networking 
You’ve learned the basics of HTTP networking, and you created an application that 
performed both an HTTP GET and HTTP POST. The application performed the requests in 
a separate thread, which is necessary for all BlackBerry networking. You decoded the 
responses by first looking at the Content-type header to determine what the server was 
sending back, and then decoding either an image or text data. You also encoded your 
POST request body and set the Content-type header for the request appropriately. 
Finally, you performed an HTTPS connection simply by switching the scheme of the 
URL and, via the HttpsConnection interface, got some information about the connection. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
192 
Connection Method: Using Direct TCP/IP Instead of 
BES/MDS 
Now, let’s take a few minutes to see how to force a connection to make a direct TCP/IP 
connection to the server instead of using the BES/MDS. The Networking application 
currently uses the device’s default connection method. As mentioned earlier, if you run 
the application on a device that’s not activated on a BES, the requests will already go 
over direct TCP/IP. However, if you run on a device connected to a BES, the POST and 
GET requests are done through the BES. To force them to go directly, you just have to 
add a BlackBerry-specific parameter to the end of the URL when you call 
Connector.open. The parameter you want is ;deviceside=true, so the URL for the web 
application becomes 
Error! Hyperlink reference not valid. 
Modify the run method of HttpRequestDispatcher to add this automatically. 
   HttpConnection connection = (HttpConnection)Connector.open(url + ";deviceside=true"); 
You can actually test this on the simulator because it respects this parameter, too. If you 
specify deviceside=true, the simulator won’t connect through the MDS simulator. So, 
uncheck the appropriate Launch Mobile Data System check box, ensure the MDS 
command window isn’t open (if it is, just close it), and then run the application again. 
You’ll be able to make connections without the MDS simulator running! 
Making a Connection Using WAP 2.0 
I mentioned that WAP 2.0 was a better choice than direct TCP/IP because of 
configuration issues. It’s a little more difficult to use, as it requires an extra parameter at 
the end of the URL that includes the UID of the service record for the WAP 2.0 protocol. 
You’ll start by creating a method in HttpRequestDispatcher to find this service book.   
The WAP 2.0 service book record has a CID of WPTCP, but this CID is used for a few 
other connection methods, so the recommended algorithm for finding the correct  
record is to look for a record with a CID of WPTCP and a UID that doesn’t contain WIFI 
or MMS. 
First, add the following imports to the top of the file to get access to the service book-
related classes: 
import net.rim.device.api.servicebook.ServiceBook; 
import net.rim.device.api.servicebook.ServiceRecord; 
The code for the method follows: 
    private ServiceRecord getWAP2ServiceRecord() { 
        ServiceBook sb = ServiceBook.getSB(); 
        ServiceRecord[] records = sb.getRecords(); 
 
        for(int i = 0; i < records.length; i++) { 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
193 
            String cid = records[i].getCid().toLowerCase(); 
            String uid = records[i].getUid().toLowerCase(); 
            if (cid.indexOf("wptcp") != -1 &&  
                    uid.indexOf("wifi") == -1 &&  
                    uid.indexOf("mms") == -1) { 
                return records[i]; 
            } 
        } 
        return null; 
    } 
If a matching service record isn’t found, WAP 2.0 isn’t configured on the device, and the 
method will return null. In that case, default back to a direct TCP/IP connection. 
Otherwise, add the parameter ConnectionUID=<UID of the record> to indicate that you 
want to connect using WAP 2.0. Modify the code in the run method of 
HttpRequestDispatcher as follows: 
       ServiceRecord record = getWAP2ServiceRecord(); 
        String connectionParameters = ";deviceside=true"; 
        if (record != null) { 
          connectionParameters += ";ConnectionUID=" + record.getUid(); 
        } 
        HttpConnection connection = (HttpConnection)Connector.open(url + 
connectionParameters); 
Making a Connection Using BIS 
What about using the BIS connection method described at the beginning of this 
chapter? Officially, applications are approved to use BIS to connect on a case-by-case 
basis, but you have to be a member of the BlackBerry Alliance Program to get access. 
Generally, the BlackBerry Alliance Program is good to get involved with as an 
independent software vendor for BlackBerry. More information about the Alliance 
Program is available at http://na.blackberry.com/eng/partners/alliance.jsp 
Unofficially, to make a BIS connection, you can modify the HttpRequestDispatcher as 
follows: 
connectionParameters = “;deviceside=false;ConnectionType=mds-public"; 
HttpConnection connection = (HttpConnection)Connector.open(url + 
connectionParameters); 
As you can see, the connection parameter that you have to append is 
;deviceside=false;ConnectionType=mds-public;.  
When using BIS connection, if Wi-Fi is present, BIS connection will choose Wi-Fi, as BIS 
chooses the least costly route to connect. Note that there is no way to programmatically 
specify BIS-Wi-Fi.  

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
194 
Making a Wi-Fi Connection 
Connecting via Wi-Fi is easy if the device has been configured to use a Wi-Fi  
access point. Remember, if your application is used on a device that’s activated on a 
BES, and you’re using the BES/MDS or default connection method, your connection is 
made over Wi-Fi as per the device configuration. 
To explicitly force a direct Wi-Fi connection, append the parameter ;interface=wifi to 
the end of the connection string. For example, modify the connector call to be 
        HttpConnection connection = (HttpConnection)Connector.open(url + 
";interface=wifi"); 
Note that this bypasses any other wireless network connection method, so if the device 
is not within range of an appropriate Wi-Fi access point, the connection will fail. 
Determining Network Availability 
We’ve covered how to make  network connections through various methods, but how 
do you determine which ones you can use? There are a couple of classes in the 
BlackBerry API that provide an easy way to do this.   
Using CoverageInfo 
The net.rim.device.api.system.CoverageInfo class enables you to determine which 
connection methods are currently available to the BlackBerry device. It looks at the 
device’s radio, current network coverage, and service book, and it provides information 
about what types of network connections are possible.   
The API for this class has changed somewhat between OS 4.2 and OS 4.5. I’ll cover the 
OS 4.5 version. 
The main method to determine coverage is the getCoverageStatus method. The no-
parameter form of this method returns a bitmask of the different connection methods 
available over all physical network types (usually mobile network and Wi-Fi, but also 
Bluetooth and USB connections to the computer if applicable). For example, if we called 
the method in an area with full network coverage on a device that’s activated on a BES 
and with a wireless service plan that allows direct TCP/IP access, we’d expect 
getCoverageStatus to return COVERAGE_MDS | COVERAGE_DIRECT | COVERAGE_BIS_B 
Note that the different COVERAGE values can each indicate several types of available 
connection methods. 
 COVERAGE_MDS means you can make connections using the BES/MDS 
connection method. 
 COVERAGE_DIRECT means you can make connections using direct 
TCP/IP or WAP. 
 COVERAGE_BIS_B means you can make connections using BIS. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
195 
Using WLANInfo 
The net.rim.device.api.system.WLANInfo class, available in OS 4.3 and later, lets you 
determine if you can make a direct Wi-Fi connection. 
Usage of the class is easy. If the getWLANState method returns 
WLANInfo.WLAN_STATE_CONNECTED, then the device’s Wi-Fi is turned on and connected to 
a wireless access point, and you can make direct Wi-Fi connections. 
Putting It All Together 
Modify your run method one last time to use CoverageInfo and WLANInfo to determine 
which connection methods are available and connect in our preferred order. For your 
application, you’ll look for available connection methods in the following order: 
 Wi-Fi 
 WAP 2.0 
 BES/MDS 
 Direct TCP/IP 
I’ve left out BIS because it’s only available to approved applications, and I left out WAP 
1.0 because it’s generally not recommended. 
Before you proceed with the code, remember to add the imports for WLANInfo and 
CoverageInfo to the top of HttpRequestDispatcher.java. 
import net.rim.device.api.system.CoverageInfo; 
import net.rim.device.api.system.WLANInfo; 
The new connection code for HttpRequestDispatcher’s run method to attempt 
connections in the given order follows: 
        String connectionParameters = ""; 
        if (WLANInfo.getWLANState() == WLANInfo.WLAN_STATE_CONNECTED) { 
            // Connected to a Wi-Fi access point 
            connectionParameters = ";interface=wifi"; 
        } else { 
           int coverageStatus = CoverageInfo.getCoverageStatus(); 
           ServiceRecord record = getWAP2ServiceRecord(); 
           if (record != null 
                  && (coverageStatus & CoverageInfo.COVERAGE_DIRECT) ==  
                  CoverageInfo.COVERAGE_DIRECT) { 
              // Have network coverage and a WAP 2.0 service book record 
              connectionParameters = ";deviceside=true;ConnectionUID=" 
                  + record.getUid(); 
        } else if ((coverageStatus & CoverageInfo.COVERAGE_MDS) ==  
              CoverageInfo.COVERAGE_MDS) { 
           // Have an MDS service book and network coverage 
           connectionParameters = ";deviceside=false"; 
        } else if ((coverageStatus & CoverageInfo.COVERAGE_DIRECT) ==  
              CoverageInfo.COVERAGE_DIRECT) { 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
196 
           // Have network coverage but no WAP 2.0 service book record 
           connectionParameters = ";deviceside=true"; 
        } 
The previous code will work with BlackBerry OS 4.5.0 and higher. This is because of the 
use of CoverageInfo.COVERAGE_DIRECT, which replaced CoverageInfo.COVERAGE_CARRIER 
from JDE 4.5 and above. You can, however, make the code compile in all versions of the 
JDE 4.3 and higher by replacing CoverageInfo.COVERAGE_DIRECT with its constant value 
of 1, which is the same value that is used for CoverageInfo.COVERAGE_CARRIER in earlier 
JDE versions.   
Notice that you have to check the service book to know if you should attempt a WAP 2.0 
connection because CoverageInfo tells you only that the device has network coverage 
to the carrier, but CoverageInfo by itself can tell you if the device is able to connect via 
BES/MDS. It’s able to check both the network coverage and service book status. 
If you have a BlackBerry device that is Wi-Fi capable, try running it with different 
combinations of Wi-Fi and mobile network settings, such as turning either Wi-Fi or the 
mobile network on or off. You should be able to connect in a variety of configurations. 
TCP Socket Connections 
Some applications require a lower level of network access than HTTP provides. For 
example, connecting to a streaming media server, FTP server, or any other non-web 
server requires a lower level of network access than HTTP provides. In these cases, you 
can open a TCP socket in much the same way as an HTTP connection by substituting 
socket:// for http:// - or ssl:// or tls:// for a secure connection. 
A Simple Socket Application 
Let's make some simple modifications to the Networking application to perform an 
HTTP GET using a socket connection instead of the HTTP connection functionality. 
Because the mechanics are so similar to HTTP connections, and this is a simple (and 
somewhat contrived) example, I’ll go fairly quickly. 
Create a new class to perform socket connections. This is analogous to 
HttpRequestDispatcher but uses SocketConnection instead. I’ll present the code and 
then discuss it. 
package com.beginningblackberry.networking; 
 
import java.io.ByteArrayOutputStream; 
import java.io.IOException; 
import java.io.InputStream; 
import java.io.OutputStream; 
 
import javax.microedition.io.Connector; 
import javax.microedition.io.SocketConnection; 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
197 
public class SocketConnector extends Thread { 
        private String host; 
        private NetworkingMainScreen screen; 
 
 
        public SocketConnector(String host, NetworkingMainScreen screen) { 
                this.host = host; 
                this.screen = screen; 
        } 
 
        public void run() { 
                 try { 
                          SocketConnection connection = 
(SocketConnection)Connector.open("socket://" + host + ":80"); 
                          OutputStream out = connection.openOutputStream(); 
                          InputStream in = connection.openInputStream(); 
                          String request = "GET / HTTP/1.1\r\n" + 
                          "Host:" + host + "\r\n" + 
                          "\r\n" + 
                          "\r\n"; 
                          out.write(request.getBytes()); 
                          out.flush(); 
                          ByteArrayOutputStream baos = new ByteArrayOutputStream(); 
 
                          int firstByte = in.read(); 
                          if (firstByte >= 0) { 
                                     baos.write((byte)firstByte); 
                                     int bytesAvailable = in.available(); 
                                     while(bytesAvailable > 0) { 
                                              byte[] buffer = new byte[bytesAvailable]; 
                                              in.read(buffer); 
                                              baos.write(buffer); 
                                              bytesAvailable = in.available(); 
                                     } 
                          } 
                          baos.close(); 
                          connection.close(); 
 
                          screen.requestSucceeded(baos.toByteArray(), "text/plain"); 
                  } catch (IOException ex) { 
                           screen.requestFailed(ex.getMessage()); 
                  } 
        } 
 
} 
Along with the screen parameter to let you write output, you’re passing in a host. You 
use this to open the socket connection to port 80, the usual web server port, and to 
construct the HTTP request because a Host header is required by the HTTP protocol. 
NOTE: that you should always specify a port number when opening a socket connection. HTTP 
connections default to port 80, and HTTPS to port 443, but there’s no concept of a “default” port 
for a socket connection. 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
198 
The HTTP request is constructed according to the HTTP protocol specification. You 
write only the Host header, as it’s the only required one. 
The first step in reading the response from the socket is this line: 
                          int firstByte = in.read(); 
This lets you wait for the server to write the first byte of the response back to the socket. 
Remember, at the socket level, there’s no built-in concept of request-response. The 
server can theoretically write back at any point or wait any length of time before writing 
data, so you have to wait and check that the first value you get is not –1, which indicates 
the server has closed the connection. 
You then read only as long as bytes are available. In this case, you know the behavior of 
the server—that it’ll write the entire response as one chunk. In other cases, 
InputStream.available() tells you only the number of bytes currently available to be 
read back. More bytes might be available after you’ve finished reading the initial number 
returned by available. 
Adding Socket Support to the Main Screen 
To give access to the TCP socket functionality from the main screen, you’ll have the 
URL field double as a hostname field, so no changes are required to the onscreen 
controls, just an additional menu item. 
Add the following lines to makeMenu: 
                  menu.add(new MenuItem("Socket Get", 10, 10) { 
                         public void run() { 
                                    socketGet(); 
                         } 
                  }); 
Add the following method to NetworkingMainScreen: 
     private void socketGet() { 
              SocketConnector connector = new SocketConnector(urlField.getText(), this); 
              connector.start(); 
     } 
Summary 
This chapter threw open the doors of the BlackBerry handheld and built an application 
that could talk to the world. I discussed the various networking options available to 
BlackBerry devices and the connection framework that makes them all available. 
You started by building an application that used the HTTP connection framework to talk 
to a web application by retrieving HTML and images and sending data back to the 
application. You then saw how it was easy to extend this to a secure connection using 
HTTPS. Finally, you briefly explored TCP sockets by retrieving the web application’s 

CHAPTER 7:  Hello Out There! Making a Network-Enabled Application 
199 
main page over a TCP socket connection without going through the BlackBerry 
platform’s HTTP layer. 
The examples here have all been fairly simple, but if you worked through them and 
understood them, you have the knowledge to create most kinds of network-ready 
BlackBerry applications. 
At this point, you’ve seen enough of the BlackBerry API to create a wide range of useful 
applications. The next chapter deals with something less general but still extremely 
valuable for a growing number of application types—location-based services. You also 
learn how to package and distribute your applications. So take a deep breath; you’re 
almost done! 

 
201 
 
 
 
Chapter 
Where Am I? Using 
Location-Based Services 
The BlackBerry API includes functionality to determine where in the world your device is 
and information such as the speed of the device. This information is obtained using the 
Global Positioning System (GPS) hardware that’s built in to many current devices, or it is 
obtained optionally from an external Bluetooth GPS receiver. 
In addition, the BlackBerry device includes a mapping application called BlackBerry 
Maps, with an API that applications can call to show a map opened to any location in 
the world, routes from location to location, and points of interest on a map.   
In OS 4.5 and higher, you can embed a map in your application’s user interface as a 
control, giving you more power over how you use BlackBerry Maps. 
Location-based services can help you create compelling applications for BlackBerry, but 
you must be aware of the limitations in device and OS support for various types of 
functionality. 
In this chapter, we’ll build an application that lets you explore all aspects of location-
based services. We’ll start by simply retrieving the device’s location using the GPS 
functionality, and then move on to explore BlackBerry Maps. You’ll learn how to launch 
the application from your application, and then mark your device’s position (or any 
coordinates) on a map. Finally, we’ll discuss embedding a map control in your 
application’s user interface. 
GPS Support on BlackBerry Devices 
All the new BlackBerry devices that are sold come with built-in GPS. However, if you 
need to support some of the older devices, just remember that the legacy device you 
support needs to be running OS 4.0.2 or higher. In addition, since OS 4.2, the 
BlackBerry Location API supports an external GPS receiver via Bluetooth. We will be 
focused on using the built-in internal GPS to retrieve location information. 
8 

CHAPTER 8:  Where Am I? Using Location-Based Services 
202 
Getting Location Information 
As a BlackBerry developer, you have different options to retrieve longitude and latitude 
coordinates (aka location information): through the GPS, cell tower, BlackBerry 
geolocation, and geocoding (and reverse geocoding). 

GPS: What is great about using GPS to retrieve location is accuracy; 
however, it generally takes some time before the GPS can fix on the 
current device location.  

Cell tower and BlackBerry geolocation: The location retrieved with 
these methods is less accurate, because the location information is 
based on either cell tower information or the WLAN access point that 
the BlackBerry is connected to. The benefit is the rapidity with which 
the location information is retrieved (usually within seconds). 

Geocoding and reverse geocoding: With a given a street address, 
geocoding can retrieve location information. Of course, this implies 
that at the time of the request, street information is readily available. 
Reverse geocoding is retrieving street address information given 
existing location coordinates.   
With the first two options listed above, there are two ways of implementing. One way is 
to use the Java Specification Request (JSR) 179 packages, which are purely J2ME. The 
second way is to use the BlackBerry extensions to JSR 179, which are more specific to 
BlackBerry devices. We recommend using BlackBerry extensions to JSR 179, but there 
are a couple reasons to use JSR 179 instead of the BlackBerry extensions to JSR 179:  

Portability: If you use JSR 179, your location code can be used on 
BlackBerry and other J2ME-enabled devices. 

Legacy BlackBerry OS support: If you need to support a BlackBerry 
OS below OS 5.0, then JSR 179 is the way to go, as the BlackBerry 
extensions to JSR 179 are only available on OS 5.0 or higher. 
Getting Location Information Using JSR 179 APIs 
and the BlackBerry Extensions to JSR 179 
Generally, no matter which API you use (JSR 179 or the BlackBerry extensions to 
JSR 179), you normally would have to do the following: 
1.
Specify a GPS mode. 
2.
Retrieve a location provider. 
3.
Get location information (coordinates) from the location provider. 

CHAPTER 8:  Where Am I? Using Location-Based Services 
203 
The JSR 179 package is part of the standard J2ME Location API, which provides 
location information, such as latitude, longitude, altitude, speed, and course (direction). 
This package is located in javax.microedition.location.  
The BlackBerry extensions to JSR 179 package provides similar information to JSR 179, 
and is located in net.rim.device.api.gps. 
To get started, let’s look at the different GPS modes that are available for us. 
GPS Modes 
You can use GPS in four main modes: Cell Site, Assisted GPS, Unassisted GPS, and 
BlackBerry Geolocation (available only in the BlackBerry extensions to JSR 179). All are 
supported by any device that supports GPS (or has an external GPS receiver), though 
Assisted GPS can only be used where the wireless network supports it and requires 
PDE (Position Determining Entity) server support. These modes are discussed in the 
following sections. 
Cell Site 
Cell Site mode determines the location of the device solely based on cell tower locations 
and signal strengths. This provides only the location, not speed or other route 
information. The accuracy is generally poor. Unlike the real GPS methods, it is almost 
instantaneous. 
BlackBerry Geolocation Modes 
Like Cell Site mode, BlackBerry Geolocation provides approximate device location 
information almost instantaneously. Unlike Cell Site mode, it works for all networks 
types. Also, it is typically more accurate than Cell Site, and it provides three different 
modes: 
 WLAN mode: Uses Wi-Fi access points to derive location information 
 Cell Site mode: Uses cell towers to gather location information 
 Optimal mode: Uses both WLAN and Cell Site modes to gather 
location information. 
While BlackBerry Geolocation sounds great (and is), the caveat is that it works only on 
devices running OS 5.0 or higher, and WLAN and Optimal modes are available only on 
OS 6.0 or higher. In other words, if you need to support legacy BlackBerry OSs, then 
you can’t rely solely on BlackBerry Geolocation. 

CHAPTER 8:  Where Am I? Using Location-Based Services 
204 
Assisted GPS 
Assisted GPS uses GPS hardware and assistance from the wireless network to do 
things such as locate the GPS satellites to speed up the satellite acquisition and location 
process. Generally, this provides high accuracy, and although it is slower than cell-site 
location, it is faster than Unassisted GPS location. For CDMA devices, Assisted GPS 
mode requires help from PDE server.   
Unassisted GPS 
Unassisted GPS uses only the GPS hardware for location. This provides a high degree 
of accuracy, but it might take two minutes or longer to acquire satellite signals and 
determine the device’s location. Of course, it works whether there is wireless network 
coverage available to the device or not.  
Specifying a GPS Mode Using JSR 179 
GPS modes are specified using the javax.microedition.location.Criteria class, 
which enables you to specify the requirements for the location provider.  
Using Cell-Site Location 
With these criteria, accuracy is not required, cost is allowed, and preferred power 
consumption is low: 
Criteria criteria = new Criteria(); 
criteria.setHorizontalAccuracy(Criteria.NO_REQUIREMENT); 
criteria.setVerticalAccuracy(Criteria.NO_REQUIREMENT); 
criteria.setCostAllowed(true); 
criteria.setPreferredPowerConsumption(Criteria.POWER_USAGE_LOW); 
Using Assisted GPS Location 
With these criteria, accuracy is not required, cost is allowed, and preferred power 
consumption is medium: 
Criteria criteria = new Criteria(); 
criteria.setHorizontalAccuracy(Criteria.NO_REQUIREMENT); 
criteria.setVerticalAccuracy(Criteria.NO_REQUIREMENT); 
criteria.setCostAllowed(true); 
criteria.setPreferredPowerConsumption(Criteria.POWER_USAGE_MEDIUM); 
Using Only Unassisted Mode 
Unassisted GPS is used for the first and all subsequent location retrievals. Accuracy is 
50 meters, cost is not allowed, and power consumption is high or at no requirement: 

CHAPTER 8:  Where Am I? Using Location-Based Services 
205 
Criteria criteria = new Criteria(); 
criteria.setHorizontalAccuracy(50); 
criteria.setVerticalAccuracy(50); 
criteria.setCostAllowed(false); 
criteria.setPreferredPowerConsumption(Criteria.POWER_USAGE_HIGH); 
Using Assisted and Unassisted Modes 
With these criteria, the initial location is retrieved using Assisted GPS; subsequent 
locations are fully unassisted. Accuracy is 50 meters, cost is allowed, and preferred 
power consumption is high: 
Criteria criteria = new Criteria(); 
criteria.setHorizontalAccuracy(50); 
criteria.setVerticalAccuracy(50); 
criteria.setCostAllowed(true); 
criteria.setPreferredPowerConsumption(Criteria.POWER_USAGE_HIGH); 
After you have constructed a javax.microedition.location.Criteria object, you can 
pass it to the location provider object’s 
javax.microedition.location.LocationProvider’s getInstance method: 
LocationProvider provider = LocationProvider.getInstance(criteria); 
At this point, you can retrieve a Location object from the provider: 
Location location = provider.getLocation(-1); 
 
Finally, from the Location object, you can retrieve a QualifiedCoordinates object, which 
contains the device’s current location: 
QualifiedCoordinates qualifiedCoordinates = 
location.getQualifiedCoordinates(); 
double longitude = qualifiedCoordinates.getLongitude(), 
double latitude = qualifiedCoordinates.getLatitude(); 
Note that the longitude and latitude that you get will be as accurate as the GPS method 
that you set in the criteria. 
Specifying a GPS Mode Using the BlackBerry Extensions to 
JSR 179 
The BlackBerry extensions to JSR 179 are much easier to use, and we recommend 
using them if your application does not need to support legacy devices. 
To specify a GPS mode, you would simply construct a BlackBerryCriteria object with a 
mode constant from either the LocationInfo class or the GPSInfo class. 
Table 8–1 illustrates different modes and the associated mode constants that you can 
use. For example, if you want to use Cell Site mode, you would do the following to 
construct your criteria:  

CHAPTER 8:  Where Am I? Using Location-Based Services 
206 
BlackBerryCriteria bbCriteria = new 
BlackBerryCriteria(LocationInfo.GEOLOCATION_MODE_CELL); 
That’s it! Compared to JSR 179, this is a much simpler way to get the criteria that you 
need, isn’t it?  
But we are not done just yet; we now have to get a location provider: 
BlackBerryLocationProvider bbProvider = (BlackBerryLocationProvider) 
LocationProvider.getInstance(bbCriteria); 
At this point, you can retrieve a BlackBerryLocation object from the provider: 
BlackBerryLocation bbLocation = 
(BlackBerryLocation)bbProvider.getLocation(10); 
 
Finally, from the BlackBerryLocation object, you can retrieve a QualifiedCoordinates 
object, which contains device’s current location: 
QualifiedCoordinates qualifiedCoordinates = 
bbLocation.getQualifiedCoordinates(); 
double longitude = qualifiedCoordinates.getLongitude(), 
double latitude = qualifiedCoordinates.getLatitude(); 
Again, note that the longitude and latitude values that you get will be as accurate as the 
GPS method you set in the criteria.  
Table 8–1. Different GPS Modes in the BlackBerry Extensions to JSR 179 
GPS Mode 
Supported On 
Mode Constant  
PDE 
Required 
Fix 
Frequency 
Standalone GPS 
CDMA/GSM/iDEN 
GPSInfo.GPS_MODE_AUTONOMOUS 
No 
Single/multiple 
Assisted 
GSM/iDEN 
GPSInfo.GPS_MODE_ASSIST 
Yes 
Single/multiple 
Geolocation 
optimal 
CDMA/GSM/iDEN 
LocationInfo.GEOLOCATION_MODE 
No 
Single/multiple 
Geolocation cell 
CDMA/GSM/iDEN 
LocationInfo.GEOLOCATION_MODE_CELL 
No 
Single/multiple 
Geolocation WLAN 
CDMA/GSM/iDEN 
LocationInfo.GEOLOCATION_MODE_WLAN 
No 
Single/multiple 
MS-assisted 
CDMA 
GPSInfo.GPS_MODE_CDMA_MS_ASSIST 
Yes 
Single 
MS-based 
CDMA 
GPSInfo.GPS_MODE_CDMA_MS_BASED 
Yes 
Multiple 
Data optimal 
CDMA 
GPSInfo.GPS_MODE_CDMA_DATA _OPTIMAL  
Yes 
Single/multiple 
Speed optimal 
CDMA 
GPSInfo.GPS_MODE_CDMA_SPEED_OPTIMAL  
Yes 
Multiple 
Accuracy optimal 
CDMA 
GPSInfo.GPS_MODE_CDMA_ACCURACY_OPTIMAL  Yes 
Single 

CHAPTER 8:  Where Am I? Using Location-Based Services 
207 
The Location Application 
Now let’s put all this knowledge to use and create an application that uses the Location 
API. We will illustrate using JSR 179 packages, but as discussed in the last section, the 
BlackBerryCriteria object can be used instead of the Criteria object. Likewise, 
BlackBerryLocationProvider can be used instead of LocationProvider.  
As you should expect by now, you’ll start by creating a new BlackBerry CLDC 
application. Call it Location. Create a main application class and a main screen class 
called LocationApp and LocationMainScreen, respectively; both are in the 
com.beginningblackberry.location package. You’ll add a few fields to 
LocationMainScreen, a menu item to update the location, and a skeleton update 
method. The initial versions of the classes are as follows: 
package com.beginningblackberry.location; 
 
import net.rim.device.api.ui.UiApplication; 
 
public class LocationApp extends UiApplication { 
 
public LocationApp() { 
 
 
LocationMainScreen screen = new LocationMainScreen(); 
 
 
pushScreen(screen); 
 
} 
 
 
 
public static void main(String[] args) { 
 
 
LocationApp app = new LocationApp(); 
 
 
app.enterEventDispatcher(); 
 
} 
} 
Here’s LocationMainScreen.java: 
package com.beginningblackberry.location; 
 
import net.rim.device.api.ui.MenuItem; 
import net.rim.device.api.ui.component.LabelField; 
import net.rim.device.api.ui.component.Menu; 
import net.rim.device.api.ui.UiApplication; 
import net.rim.device.api.ui.component.RichTextField; 
import net.rim.device.api.ui.container.HorizontalFieldManager; 
import net.rim.device.api.ui.container.MainScreen; 
 
 
public class LocationMainScreen extends MainScreen { 
 
 
private LabelField latitudeLabel; 
 
private LabelField longitudeLabel; 
 
private RichTextField messageField; 
 
 
public LocationMainScreen() { 
 
 
HorizontalFieldManager latManager = new HorizontalFieldManager(); 
 
 
latManager.add(new LabelField("Latitude:")); 

CHAPTER 8:  Where Am I? Using Location-Based Services 
208 
 
 
latitudeLabel = new LabelField(""); 
 
 
latManager.add(latitudeLabel); 
 
 
 
 
 
add(latManager); 
 
 
 
 
 
HorizontalFieldManager longManager = new HorizontalFieldManager(); 
 
 
longManager.add(new LabelField("Longitude:")); 
 
 
longitudeLabel = new LabelField(""); 
 
 
longManager.add(longitudeLabel); 
 
 
 
 
 
add(longManager); 
 
 
 
 
 
messageField = new RichTextField(); 
 
 
add(messageField); 
 
} 
 
 
 
 
private void update() { 
 
} 
 
 
 
protected void makeMenu(Menu menu, int instance) { 
 
 
super.makeMenu(menu, instance); 
 
 
menu.add(new MenuItem("Update", 10, 10) { 
 
 
 
public void run() { 
 
 
 
 
update(); 
 
 
 
} 
 
 
}); 
 
} 
 
 
 
 
} 
Using the Location API is another one of those things; like networking, it must be done 
outside the UI thread. The reason should be clear: getting a fix on GPS satellites can 
take some time, so the UI thread shouldn’t be locked up. 
Follow a similar pattern to the networking example and create a new class to handle the 
details of working with the Location API. First, add a couple of methods to 
LocationMainScreen to enable the new class to display results to the screen. Add the 
following to LocationMainScreen: 
 
public void setLocation(double longitude, double latitude) { 
 
 
synchronized(UiApplication.getEventLock()) { 
 
 
 
longitudeLabel.setText(Double.toString(longitude)); 
 
 
 
latitudeLabel.setText(Double.toString(latitude)); 
 
 
} 
 
} 
 
 
 
public void setMessage(String message) { 
 
 
synchronized (UiApplication.getEventLock()) { 
 
 
 
messageField.setText(message); 
 
 
 
 
 
 
} 
 
} 

CHAPTER 8:  Where Am I? Using Location-Based Services 
209 
Location coordinates, as you might have guessed, are returned as double values 
representing the degrees of longitude and latitude. The message area gives you a free-
form spot to print some other interesting information, such as the location method that 
was actually used and the accuracy of the results. 
Create a class called LocationHandler that extends Thread. It will contain an instance of 
LocationMainScreen so it can update the UI: 
package com.beginningblackberry.location; 
 
public class LocationHandler extends Thread { 
 
private LocationMainScreen screen; 
 
 
 
public LocationHandler(LocationMainScreen screen) { 
 
 
this.screen = screen; 
 
} 
 
 
 
public void run() { 
 
} 
 
} 
It’s time to start using the Location API. Add the following import statements to the top 
of LocationHandler.java: 
import javax.microedition.location.Criteria; 
import javax.microedition.location.Location; 
import javax.microedition.location.LocationException; 
import javax.microedition.location.LocationProvider; 
import javax.microedition.location.QualifiedCoordinates; 
Now you fill in the run method. Basically, you fill in the criteria as described earlier (use 
the Assisted GPS/Unassisted GPS hybrid) and get an instance of LocationProvider, 
which you can then use to obtain an actual location. The code is fairly self-explanatory; 
we present it here and then discuss it: 
public void run() { 
 
Criteria criteria = new Criteria(); 
 
criteria.setVerticalAccuracy(50); 
 
criteria.setHorizontalAccuracy(50); 
 
criteria.setCostAllowed(true); 
 
criteria.setPreferredPowerConsumption( 
 
 Criteria.POWER_USAGE_HIGH); 
 
 
 
 
try { 
 
 
 
screen.setMessage("Getting location..."); 
 
 
 
LocationProvider provider = 
 LocationProvider.getInstance(criteria); 
 
 
Location location = provider.getLocation(-1);  
 
 
 
 
 
QualifiedCoordinates qualifiedCoordinates =  
 
 
 location.getQualifiedCoordinates(); 
 
 
 
 
 
 
screen.setLocation(qualifiedCoordinates.getLongitude(), 
 
 
 qualifiedCoordinates.getLatitude()); 

CHAPTER 8:  Where Am I? Using Location-Based Services 
210 
 
 
String message = "Successfully got location, method:"; 
 
 
int method = location.getLocationMethod(); 
 
 
if ((method & Location.MTA_ASSISTED) ==  
 
 
 Location.MTA_ASSISTED) { 
 
 
 
message += " Assisted GPS"; 
 
 
} 
 
 
if ((method & Location.MTA_UNASSISTED) == 
 
 
 Location.MTA_UNASSISTED) { 
 
 
 
message += " Unassisted GPS"; 
 
 
} 
 
 
if ((method & Location.MTE_CELLID) ==  
 
 
 Location.MTE_CELLID) { 
 
 
 
message += " Cell Site"; 
 
 
} 
 
 
 
 
 
 
message += "\nHorizontal (Longitude) Accuracy: "; 
 
 
 
 
 
 
message += qualifiedCoordinates.getHorizontalAccuracy(); 
 
 
 
 
 
 
message += "\nVertical (Latitude) Accuracy: "; 
 
 
 
 
 
 
message += qualifiedCoordinates.getVerticalAccuracy(); 
 
 
screen.setMessage(message); 
 
} catch (LocationException e) { 
 
 
screen.setMessage("LocationException: " +  
 
 
 e.getMessage()); 
 
} catch (InterruptedException e) { 
 
 
screen.setMessage("InterruptedException: " + 
 
 
 e.getMessage()); 
 
} 
} 
The location method is determined by the criteria that you have specified. In this case, 
you’d expect it to be Assisted GPS based on the discussion earlier.  
We’ve specified -1 as the parameter to LocationProvider.getLocation. This is the 
timeout parameter in milliseconds. -1 means you use the default for that provider. 
The location you receive is qualified; that is, there’s some degree of error associated 
with it, represented by the accuracy values in the QualifiedCoordinates class. GPS 
coordinates will always be qualified. The unqualified Coordinates class is used mainly to 
specify coordinates that you want plotted on a map. 
Finally, don’t forget to fill out the update method in LocationMainScreen: 
 
private void update() { 
 
 
LocationHandler handler = new LocationHandler(this); 
 
 
handler.start(); 
 
} 
Now start the simulator or load onto your device and give it a try (see Figure 8–1). 

CHAPTER 8:  Where Am I? Using Location-Based Services 
211 
NOTE: If you’re running on the simulator, you can simulate a GPS location by choosing Simulate 
from the GPS Location menu. Click Update, and you should see your current latitude and 
longitude. 
 
Figure 8–1. Getting the device’s location using Assisted GPS 
Feel free to substitute some of the other criteria values from location modes described 
previously to see how they affect things. You should notice that Cell Site mode is much 
quicker than the GPS modes, but generally isn’t nearly as accurate. In many 
applications, a good approach is to get a rough idea of the user’s location using Cell 
Site mode, and then refine it using GPS if and when it’s available. 
Getting Periodic Location Updates Using LocationListener 
The JSR 179 package provides a method to receive regular updates of the device’s 
location using the LocationListener interface. If you have used the BlackBerry 
extensions to JSR 179 package to set GPS modes, you can still use the 
LocationListener interface. You specify an interval at which you’ll receive notifications 
and a maximum age parameter to indicate how recent the location results must be. 
Setting a maximum age enables the device to reuse previous location information from 
the GPS provider. Establishing a GPS location uses processor power and battery life 
(and potentially network data), so you should specify the maximum age to be as large as 
possible to help the user’s device run efficiently. 
You will add support for periodic updates to your application.  
Because you want essentially the same functionality for an automatic location update as 
for a manual location update, you need LocationHandler to act as the LocationListener 
and move some code around. 
First, add an import statement for LocationListener and change the signature of 
LocationHandler to implement the interface. Also add a boolean flag to indicate whether 
you want to register for periodic location updates, and add a constructor to initialize the 
flag. So you can see your coordinates update, add one more thing: a Vector to store a 
list of the coordinates, which will allow you to display the distance between location 
updates: 
1

CHAPTER 8:  Where Am I? Using Location-Based Services 
212 
import java.util.Vector; 
import javax.microedition.location.LocationListener; 
//... 
public class LocationHandler extends Thread implements LocationListener { 
private LocationMainScreen screen; 
private boolean periodicUpdates; 
private Vector coordinateHistory = new Vector(); 
 
 
public LocationHandler(LocationMainScreen screen, boolean update) { 
 
this.screen = screen; 
 
this.periodicUpdates = update; 
} 
LocationListener includes two methods: providerStateChanged, which is invoked 
whenever the availability of the provider specified by the location criteria changes (for 
example, if GPS coverage is lost), and locationUpdated, which gives us the actual 
location updates. For this application you’ll provide an empty implementation for 
providerStateChanged, though in a real-world application you’d generally want to take 
some action: 
public void providerStateChanged(LocationProvider provider, int newState) { 
// Do nothing for our application 
 
} 
The implementation of locationUpdated is taken directly from the run method of 
LocationHandler. Add a timestamp to the message so you can see the location being 
updated in the application. Also check to see if there were previous coordinates (if the 
history isn’t empty) and display the distance between the current set and the last set of 
coordinates. First, add the following imports to LocationHandler.java to bring in the 
date/time and coordinate-handling classes: 
import net.rim.device.api.i18n.SimpleDateFormat; 
import java.util.Date; 
import javax.microedition.location.Coordinates; 
The locationUpdated method follows: 
public void locationUpdated(LocationProvider provider, Location location) { 
 
 
QualifiedCoordinates qualifiedCoordinates = 
location.getQualifiedCoordinates(); 
 
 
 
 
 
screen.setLocation(qualifiedCoordinates.getLongitude(), 
qualifiedCoordinates.getLatitude()); 
String message = "Successfully got location at "; 
SimpleDateFormat simpleDateFormat = new SimpleDateFormat("HH:mm:ss"); 
message += simpleDateFormat.format(new Date(location.getTimestamp())); 
if (coordinateHistory.size() > 0) { 
 
 
 
Coordinates lastCoordinates = 
(Coordinates)coordinateHistory.lastElement(); 
message += "\nDistance from last update:" + 
lastCoordinates.distance(qualifiedCoordinates); 

CHAPTER 8:  Where Am I? Using Location-Based Services 
213 
 
 
} 
 
 
 
 
 
coordinateHistory.addElement(qualifiedCoordinates); 
 
 
 
message += "\nMethod:"; 
 
 
int method = location.getLocationMethod(); 
 
 
if ((method & Location.MTA_ASSISTED) == Location.MTA_ASSISTED) { 
 
 
 
message += " Assisted GPS"; 
 
 
} 
 
 
if ((method & Location.MTA_UNASSISTED) == Location.MTA_UNASSISTED) { 
 
 
 
message += " Unassisted GPS"; 
 
 
} 
 
 
if ((method & Location.MTE_CELLID) == Location.MTE_CELLID) { 
 
 
 
message += " Cell Site"; 
 
 
} 
 
 
 
 
 
message += "\nHorizontal (Longitude) Accuracy: "; 
 
 
 
 
 
message += qualifiedCoordinates.getHorizontalAccuracy(); 
 
 
 
 
 
message += "\nVertical (Latitude) Accuracy: "; 
 
 
 
 
 
message += qualifiedCoordinates.getVerticalAccuracy(); 
 
 
 
screen.setMessage(message); 
 
 
 
 
} 
Coordinates have a handy built-in method that can calculate distance in meters between 
two geographical locations. You use that here. The interval is ten seconds. Usually, the 
first acquisition of GPS satellites takes longer than that, but after that’s done, 
subsequent updates can happen quickly. 
NOTE: net.rim.device.api.i18n.SimpleDateFormat is an easy way to format date/time 
values into strings. The output format is specified using a format string, where different letters 
specify different components of the date/time to display. For example, if you have a Date object 
representing August 12, 2007, 9:57 p.m., you can get the following representations: 
EEEE, MMMM dd yyyy at HH:mm:ss would give Sunday, August 12, 2007 at 21:57 
hh:mm:ss a would give 9:57 PM 
yyyy-MM-dd would give 2007-08–12 
A full explanation of all the format characters is available in the Javadocs for 
SimpleDateFormat. 

CHAPTER 8:  Where Am I? Using Location-Based Services 
214 
The run method will change to optionally add the listener and to remove the code that 
updates the UI in favor of calling locationUpdated. Replace the current try/catch block 
in LocationHandler.run() with the following: 
 
 
try { 
 
 
 
screen.setMessage("Getting location..."); 
 
 
 
LocationProvider provider = 
LocationProvider.getInstance(criteria); 
 
 
 
Location location = provider.getLocation(-1); 
 
 
 
 
 
 
 
 
 
locationUpdated(provider, location); 
 
 
 
if (periodicUpdates) { 
 
 
 
 
provider.setLocationListener(this, 30, -1, -1); 
 
 
 
} 
 
 
} catch (LocationException e) { 
 
 
 
screen.setMessage("LocationException occurred getting location: 
" + e.getMessage()); 
 
 
} catch (InterruptedException e) { 
 
 
 
screen.setMessage("InterruptedException occurred getting 
location: " + e.getMessage()); 
 
 
} 
You have set the location provider for an update every 30 seconds. 
Finally, change the update method in LocationMainScreen to call the new constructor: 
 
private void update() { 
 
 
LocationHandler handler = new LocationHandler(this, true); 
 
 
handler.start(); 
 
} 
Start the application, select Update, and leave the application running. You’ll see the 
location updated every 30 seconds. If you’re running on a real device, walk around a bit 
to see your location being tracked (see Figure 8–2). 
 
Figure 8–2. Device location after a periodic update 
Using Geocoding and Reverse Geocoding 
In the BlackBerry API, RIM has added net.rim.device.api.lbs.maps.server packages 
to allow you to employ geocoding, which lets you get location coordinates from an 
address, or reverse geocoding, which lets you get an address from a set of coordinates.  

CHAPTER 8:  Where Am I? Using Location-Based Services 
215 
RIM has provided synchronous and asynchronous ways to perform geocoding and 
reverse geocoding. The synchronous way is straightforward, as illustrated below.  
With the asynchronous way, you have to implement the ServerExchangeCallback 
interface. 
Geocoding: Getting Coordinates from an Address  
The first step in performing geocoding is to specify an address for the location of 
interest. The second step is to provide the specified address to the Geocoder object. For 
the first step, you have two options to specify an address: structured or unstructured.  
Providing an Address 
The structured way to do this is to use the MapLocation object, as follows: 
MapLocation addressLoc = new MapLocation(); 
addressLoc.addData(MapLocation.LBS_LOCATION_STREET_ADDRESS_KEY, "116th street 
"); 
addressLoc.addData(MapLocation.LBS_LOCATION_CITY_KEY, "new york"); 
addressLoc.addData(MapLocation.LBS_LOCATION_REGION_KEY, "ny"); 
addressLoc.addData(MapLocation.LBS_LOCATION_COUNTRY_KEY, "united states");  
addressLoc.addData(MapLocation.LBS_LOCATION_POSTAL_CODE_KEY, "10027"); 
The unstructured way is to use a simple Java String object, like so: 
String addressString = "116th Street New York, NY 10027"; 
Sending Geocoding Requests 
Before we can send a geocoding request, we need to give it a map region, which is 
characterized by a MapDimension object. Here is an example how we would request 
geocoding synchronously: 
MapPoint startPoint = new MapPoint(43.4815, -80.5407);  
MapDimensions mapArea = new MapDimensions(startPoint, 480, 360, 5, 0); 
MapLocation addressLoc = new MapLocation(); 
addressLoc.addData(MapLocation.LBS_LOCATION_STREET_ADDRESS_KEY, "116th 
street"); 
addressLoc.addData(MapLocation.LBS_LOCATION_CITY_KEY, "new york"); 
addressLoc.addData(MapLocation.LBS_LOCATION_REGION_KEY, "ny"); 
addressLoc.addData(MapLocation.LBS_LOCATION_COUNTRY_KEY, "united states");  
addressLoc.addData(MapLocation.LBS_LOCATION_POSTAL_CODE_KEY, "10027"); 
GeocodeExchange geocodeObj = Geocoder.getInstance().geocode(null, addressLoc, 
mapArea, 0); 
 // mapVector is a Vector of returned possible results 
Vector mapVector = geocodeObj.getResults(); 

CHAPTER 8:  Where Am I? Using Location-Based Services 
216 
for (int i = 0; i < mapVector.size(); i++) { 
MapLocation returnedLocation = (MapLocation)mapVector.elementAt(i); 
// Do something with location 
} 
Note the line Geocoder.getInstance().geocode(null, addressLoc, mapArea, 0), where 
the first parameter is null. The first parameter is typed ServerExchangeCallback, which is 
required if you need to perform an asynchronous request. In the example, a null 
parameter indicates a synchronous request (blocking call). 
Using BlackBerry Maps 
We’ve covered basic GPS location functionality. Now let’s see how you can use 
BlackBerry Maps to display location in a more visual way. 
BlackBerry Maps is included on devices running OS 4.2 and later, so it is available to 
most users. The API to interact with BlackBerry Maps is also available on any device 
that has BlackBerry Maps installed. 
Prior to OS 4.5 an application could use BlackBerry Maps in a number of ways, 
including the following: 
 Opening BlackBerry Maps and displaying the default map view (the 
last map that the BlackBerry user viewed) 
 Opening BlackBerry Maps and displaying a custom map view (latitude, 
longitude, and zoom level) 
 Opening BlackBerry Maps and displaying a specific location (latitude, 
longitude, and zoom level) with a labeled marker 
 Opening BlackBerry Maps and displaying multiple locations (multiple 
labeled markers on the same map) 
 Opening BlackBerry Maps to display a route between locations on a 
map 
With OS 4.5 and later, the API provides the capability to embed a map control into the 
UI of a BlackBerry application. 
The Invoke API 
The net.rim.blackberry.api.invoke package contains classes that let an application 
interact with some of the BlackBerry system applications, such as e-mail, phone, and 
BlackBerry Maps.  
Interaction is managed through the invokeApplication method of the Invoke class. This 
method takes two arguments: a flag indicating which application is to be invoked and an 
instance of an ApplicationArguments subclass specific to that application. 

CHAPTER 8:  Where Am I? Using Location-Based Services 
217 
To launch BlackBerry Maps, you use something like the following: 
 
 
MapsArguments args = new MapsArguments(); 
 
 
Invoke.invokeApplication(Invoke.APP_TYPE_MAPS, args); 
Launching the Default BlackBerry Maps View 
The preceding code will in fact launch the BlackBerry Maps application with the default 
(last used) view opened. Let’s add a new menu item and method to LocationMainScreen 
to do just that. Add the following imports to the top of LocationMainScreen.java: 
import net.rim.blackberry.api.invoke.Invoke; 
import net.rim.blackberry.api.invoke.MapsArguments; 
Then make the following changes to LocationMainScreen to add a menu item and a map 
method containing the previous code: 
 
private void map() { 
 
 
MapsArguments args = new MapsArguments(); 
 
 
Invoke.invokeApplication(Invoke.APP_TYPE_MAPS, args); 
 
} 
 
 
protected void makeMenu(Menu menu, int instance) { 
 
 
super.makeMenu(menu, instance); 
 
 
menu.add(new MenuItem("Update", 10, 10) { 
 
 
 
public void run() { 
 
 
 
 
update(); 
 
 
 
} 
 
 
}); 
 
 
menu.add(new MenuItem("Map", 10, 10) { 
 
 
 
public void run() { 
 
 
 
 
map(); 
 
 
 
} 
 
 
}); 
 
} 
Run the application and click Map to see the default BlackBerry Maps view pop up (see 
Figure 8–3). 

CHAPTER 8:  Where Am I? Using Location-Based Services 
218 
 
Figure 8–3. Invoking the default BlackBerry Maps view 
This actually runs the Maps application and pushes the screen on top of the application. 
When you close Maps, you end up back at the Location application’s main screen. 
Location Documents 
BlackBerry Maps defines an XML document format that you can use to specify view 
information, location markers, and route information while invoking BlackBerry Maps.  
The basic format of a document showing one or more locations is the following: 
<lbs> 
<location y='latitude' x='longitude' label='Location_Label' description='Description'/> 
<location y='latitude' x='longitude' label='Location_Label' description='Description'/> 
<location y='latitude' x='longitude' label='Location_Label' description='Description'/> 
....</lbs> 
Each of the latitude and longitude values is an integer; you can multiply the decimal 
latitude and longitude by 100,000 to get the integer value. 
Modify the Location application to take the list of coordinates in LocationHandler’s 
history and map them when you select Map from the menu. 

CHAPTER 8:  Where Am I? Using Location-Based Services 
219 
First, you need a way to get the list of coordinates. Add the following method to 
LocationHandler: 
 
public Coordinates[] getCoordinateHistory() { 
 
 
Coordinates[] coordinates = new Coordinates[coordinateHistory.size()]; 
 
 
coordinateHistory.copyInto(coordinates); 
 
 
return coordinates; 
 
} 
LocationMainScreen needs to have access to the location handler you invoke in the 
update method. You make it into a member variable by adding the following declaration 
to the top of the class: 
 
private LocationHandler locationHandler = new LocationHandler(this, true); 
Then modify LocationHandler’s update method to refer to this variable: 
 
private void update() { 
 
 
locationHandler.start(); 
 
} 
Next, you modify the map method to construct a map XML document using coordinates 
from LocationHandler. Remember that the x and y values for the locations are integers 
that you get by multiplying the decimal latitude and longitude by 100,000: 
 
private void map() { 
 
 
String document = "<lbs>"; 
 
 
javax.microedition.location.Coordinates[] coordinates = 
locationHandler.getCoordinateHistory(); 
 
 
for (int i = 0; i < coordinates.length; i++) { 
 
 
 
document += "<location x='" 
 
 
 
 
+ (int) (coordinates[i].getLongitude() * 100000) + "' 
y='" 
 
 
 
 
+ (int) (coordinates[i].getLatitude() * 100000) 
 
 
 
 
+ "' label='Location " + i 
 
 
 
 
+ "' description='Marker for history coordinate " + i 
 
 
 
 
+ "'/>"; 
 
 
} 
 
 
document += "</lbs>"; 
 
 
MapsArguments args = new 
MapsArguments(MapsArguments.ARG_LOCATION_DOCUMENT, document); 
 
 
Invoke.invokeApplication(Invoke.APP_TYPE_MAPS, args); 
 
} 
One final thing before you try this: Increase the time interval for location notifications to a 
couple of minutes or else you’ll have a huge number of points located close together on 
the map. Change the appropriate line in LocationHandler.run to something like the 
following: 
 
 
 
if (periodicUpdates) { 
 
 
 
 
// Update every 3 minutes 
 
 
 
 
provider.setLocationListener(this, 180, -1, 10); 
 
 
 
} 
Now, if you’re up for it, load this onto your device, click Update, and then go outside 
and walk around for a bit. Then click Map and you should see all your points displayed 

CHAPTER 8:  Where Am I? Using Location-Based Services 
220 
in BlackBerry Maps. The map view is automatically sized to display all of the points you 
give it (see Figure 8–4). 
 
Figure 8–4. Displaying a few locations in BlackBerry Maps 
Displaying a Custom Map View 
In addition to letting BlackBerry Maps automatically position and zoom the view, you 
can specify a view in terms of a latitude, longitude, and zoom level.  
To create a custom map view, you create an instance of 
net.rim.blackberry.api.maps.MapView with a latitude, longitude, and zoom. The zoom 
level ranges from 0 (zoomed all the way in) to MapView.MAX_ZOOM (zoomed all the way 
out). The view will be centered on the given latitude and longitude. 
Let’s add this functionality to our Location program. You’ll first add a menu item to open 
a view zoomed in to 0 on the coordinate that was last updated. 
Add the following import to the top of LocationMainScreen: 
import net.rim.blackberry.api.maps.MapView; 
Create a method called customView in LocationMainScreen; the code follows: 
 
private void customView() { 
 
 
Coordinates[] coordinates = locationHandler.getCoordinateHistory(); 
 
 
if (coordinates.length > 0) { 
 
 
 
MapView view = new MapView(); 
 
 
 
Coordinates lastCoordinates = coordinates[coordinates.length - 1]; 
 
 
 
view.setLatitude((int)(lastCoordinates.getLatitude() * 100000)); 
 
 
 
view.setLongitude((int)(lastCoordinates.getLongitude() * 
100000)); 
 
 
 
view.setZoom(0); 

CHAPTER 8:  Where Am I? Using Location-Based Services 
221 
 
 
 
 
 
 
 
MapsArguments args = new MapsArguments(view); 
 
 
 
Invoke.invokeApplication(Invoke.APP_TYPE_MAPS, args); 
 
 
} 
 
} 
MapView expects latitude and longitude in the same format as the location XML 
documents—an integer that is the latitude or longitude from the GPS location multiplied 
by 100,000. We use another constructor for MapsArguments, which takes an instance of 
MapView and invokes the BlackBerry Maps application the same way. Finally, modify 
makeMenu to add a new menu item to invoke the customView method: 
menu.add(new MenuItem("Custom View", 10, 10) { 
public void run() { 
 
 
customView(); 
 
} 
}); 
Now try it out and you should see a zoomed-in view of your last location (see Figure 8–5). 
 
Figure 8–5. BlackBerry Maps zoomed all the way in to our last location 
MapField: Embedding BlackBerry Maps in Your UI 
From OS 4.5 and above, the BlackBerry platform provides the capability to embed a 
BlackBerry Maps view into your application’s user interface. 
You will add a map field to the user interface and have it update whenever a new 
location update happens. Because this works only with JDE v4.5 and higher, be sure 
that you’re running an appropriate version of the JDE or that you’ve set your Eclipse 
workspace to use JDE v4.5 or higher. 

CHAPTER 8:  Where Am I? Using Location-Based Services 
222 
The MapField lets you set a map position, but it doesn’t support adding location markers 
to a map. So, you need to center the map on the new longitude and latitude and zoom 
in to maximum (level 0).  
Add the following import to the top of LocationMainScreen.java: 
import net.rim.device.api.lbs.MapField; 
Add a new member variable for the MapField at the top of LocationMainScreen: 
private MapField mapField; 
In the constructor, initialize MapField. MapField enables you to set a preferred width and 
height using the setPreferredSize method. If you don’t use this, the MapField’s 
preferred size will be the size of the display, so just choose 200100 and center it 
horizontally. Make the following modifications to the bottom of LocationMainField’s 
constructor to place the MapField just above the RichTextField: 
mapField = new MapField(MapField.FIELD_HCENTER); 
mapField.setPreferredSize(200, 150); 
add(mapField); 
messageField = new RichTextField(); 
add(messageField); 
 
Finally, modify LocationMainScreen.setLocation to set the MapField’s location and 
zoom level whenever you get a location update. Remember, you have to multiply the 
latitude and longitude by 100,000: 
public void setLocation(double longitude, double latitude) { 
 
 
synchronized(UiApplication.getEventLock()) { 
 
 
 
longitudeLabel.setText(Double.toString(longitude)); 
 
 
 
latitudeLabel.setText(Double.toString(latitude)); 
 
 
 
mapField.moveTo((int)(latitude * 100000), (int)(longitude * 
100000)); 
 
 
mapField.setZoom(0); 
 
} 
} 
Now run the application. Before the first location update, you’ll see a map field with 
diagonal lines, indicating that it’s set to an invalid location (see Figure 8–6). Click the 
Update menu item, and when the location comes through, the map field should be 
centered on that location (see Figure 8–7). 
Figure 8–6. Embedded map field before location update 

CHAPTER 8:  Where Am I? Using Location-Based Services 
223 
 
Figure 8–7. Embedded map field after setting a location 
Unlike BlackBerry Maps, the MapField doesn’t support location makers. You can 
replicate this functionality (and do a lot more) by subclassing MapField and overriding 
the paint method. The convertWorldToField and convertFieldToWorld methods let you 
convert between latitude/longitude and pixels onscreen. 
Summary 
This chapter covered the basics of location-based services on the BlackBerry. You built 
an application that retrieved the current location from the device’s GPS receiver, and 
then extended the application to receive automatic periodic location updates. Then you 
explored the BlackBerry Maps API, enabling you to plot the location updates on a map. 
Finally, you looked at the MapField, which enabled you to embed a map control into the 
application’s user interface. 
There’s more functionality available from location-based services on the BlackBerry, 
such as BlackBerry Maps, which can map locations based on street addresses and 
determine routes between two locations. We encourage you to take a look at the 
Javadocs and developer guides and explore more. 
You now have the basic knowledge to make your application location-aware, opening 
up all kinds of new possibilities. At this point, we’ve explored as much of the BlackBerry 
API as we’re going to in this book. In the next and final chapter, we’ll talk about how to 
package and distribute your application to users. 

 
225 
 
 
 
Chapter 
Getting Your App Out 
There: Packaging and 
Publishing 
Now you know the basics of using the BlackBerry API to develop applications. This 
chapter is going to be a bit different. The best application is only successful if people 
actually use it, and to do that, they have to be able to find it and install it onto their 
BlackBerry devices. Of course, I’ve talked about signing your application and loading it 
onto a device using the command-line javaloader utility, but that was only to allow you 
to continue to explore BlackBerry development.  
Until recently there have been a few main ways of installing an application onto the 
BlackBerry: 
 Over the air: The app is downloaded using the BlackBerry browser 
from a web site on the Internet or your intranet. 
 Desktop: The app is downloaded to the user’s computer and, using 
the BlackBerry Desktop Manager, is loaded via a USB cable onto their 
device. 
 BlackBerry Enterprise Server (BES) push: In corporate environments, 
the BES administrator remotely installs an application onto the devices 
of some users. 
Recently, a new way of installing apps debuted and is fast becoming the preferred 
method for distributing BlackBerry applications: BlackBerry App World. 
In this chapter, we’ll talk about both over-the-air and desktop installation, what you need 
to do to enable your app to be distributed in those ways, and what to look out for. 
Installation via BES push requires configuration by the BES administrator and a lot of 
knowledge about BES administration, and so is outside the scope of this book. 
9 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
226 
We’ll also talk about BlackBerry App World—how to set up an account, how to submit 
and manage an application, and what licensing options are available and how they affect 
your application’s design. In addition, we’ll explore some of the App World API that’s 
available to allow your application to interact with App World in very useful ways. 
We’ll also briefly explore a couple of other leading third-party sites for selling and 
distributing your application. 
Setting Application Properties 
We touched on this in Chapter 2 by setting the title of the project, but when you’re 
deploying an application to end users, you generally want to at least have a title and 
version (and probably vendor and description). Using the Eclipse plug-in, you can 
access properties by right-clicking the project name, selecting Properties, and then 
clicking BlackBerry Project Properties (Figure 9–1).  
 
Figure 9–1. Setting application properties in Eclipse 
These properties will be visible to users installing your application over the air or via the 
Desktop Manager, so it is important to fill them in with something that makes sense. 
Over-the-Air Installation 
The BlackBerry browser can be used to install a BlackBerry application from any web 
site that’s accessible from the BlackBerry. For the most part, this means anywhere on 
the Internet or the corporate intranet if the device is activated on a BES, which is a 
BlackBerry device management tool for corporate IT Administers. This is called over-
the-air (OTA) installation. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
227 
Sibling COD Files 
In general, BlackBerry applications are compiled into COD files (with the extension .cod). 
When a compiled application contains more than 64KB of code or static data (including, 
among other things, resource files and static string data), the BlackBerry compiler 
breaks the COD file up into two or more COD files, naming them in increasing numerical 
order. For example, if we add a bunch of images to our UiFun application, the COD files 
would be named as follows: 
UiFun.cod 
UiFun-1.cod 
UiFun-2.cod 
UiFun-3.cod 
... 
The compiler then takes these COD files, which are known as sibling COD files, and 
adds them all to a ZIP archive, which is then named the same thing as the first COD file: 
UiFun.cod.  
The point of all this is that if a user is trying to download a COD file OTA containing 
sibling COD files and isn’t connecting through the BES/MDS, the application will fail to 
install. 
So, what we have to do in this case is unzip the main COD file and deploy all the sibling 
COD files to the web server instead. The steps for our example would be as follows: 
1. Rename UiFun.cod to UiFun.zip. 
2. Using a ZIP file program or the built-in Windows support for ZIP files, unzip the 
COD files. 
3. Deploy the unzipped COD files to the web server—not the original ZIP file. 
Note that if step 2 fails with a message that the ZIP archive is invalid, then you don’t 
have sibling COD files and can safely deploy the single COD file to the web server. 
With the JDE Plug-in for Eclipse, all compiled files are within the /deliverable folder. 
The /deliverable folder is divided into a Standard/ folder and a Web/ folder. If you are 
distributing your application OTA, then you can take the JAD file (see below) and COD 
files generated from Web/ folder. Note that the above three steps aren’t necessary in this 
case, as these are done for you by the JDE Plug-in for Eclipse. 
If you are distributing your application via the Desktop Manager or BlackBerry BES, you 
can get the ALX file and COD file from Standard/. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
228 
The JAD File 
OTA installation requires a descriptor file called a Java application descriptor (JAD) file, 
which is a structured text file with the extension .jad. 
As mentioned above, the JDE Plug-in for Eclipse generates JAD files automatically with 
your build. The JAD file will be named the same thing as your base COD file name, but 
with a .jad extension. 
Since a JAD file is just a text file, you can use any text editor to change the contents.  
Here’s an example UiFun.jad file: 
Manifest-Version: 1.0 
MIDlet-Version: 1.0.1 
MIDlet-Jar-Size: 395389 
RIM-COD-URL-3: UiFun-3.cod 
RIM-COD-SHA1-3: ff fb 53 97 7d 45 55 46 4b 0b 62 b5 8c 64 22 72 89 12 0f 4f 
RIM-COD-URL-2: UiFun-2.cod 
MicroEdition-Configuration: CLDC-1.1 
MIDlet-Jar-URL: UiFun.jar 
RIM-COD-Module-Dependencies: net_rim_cldc 
RIM-COD-SHA1-2: a3 43 1d c9 fa b3 dc 74 af 9c 96 ea 8a 30 55 84 dd 0d 39 8e 
RIM-COD-URL-1: UiFun-1.cod 
RIM-COD-SHA1-1: 04 02 d3 d0 ef a3 1a 88 b5 bd a5 c1 9d b6 23 d6 9d 52 00 37 
RIM-COD-Size-3: 29240 
RIM-COD-Size-2: 56696 
RIM-MIDlet-Flags-1: 0 
RIM-COD-Size-1: 54096 
RIM-COD-Module-Name: UiFun 
MIDlet-Name: UiFun 
RIM-COD-Size: 60208 
RIM-COD-Creation-Time: 1250882363 
MIDlet-1: UI Fun Application,, 
RIM-COD-URL: UiFun.cod 
MIDlet-Description: The Beginning BlackBerry UI Fun Application 
RIM-COD-SHA1: b4 6b f1 d5 91 88 4a 8e e5 6a 40 8a 7b 12 5d 93 d1 20 bb 44 
MicroEdition-Profile: MIDP-2.0 
MIDlet-Vendor: Anthony Rizk 
You can safely change a few of these values in the file—including MIDlet-Vendor and 
MIDlet-Description—but generally it’s better to let the development tools take care of 
it. Later we’ll see another way of generating JAD files, using Apache Ant. 
Content Types (MIME Types) 
Before being able to download an application OTA from a web server, the web server 
needs to send the correct content types, or MIME types, along with the JAD and COD 
files. Table 9–1 describes these types. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
229 
Table 9–1. MIME Types 
File Type 
MIME Type 
JAD 
text/vnd.sun.j2me.app-descriptor 
COD 
application/vnd.rim.cod 
How you set these types varies depending on your web server—consult your server 
administrator or hosting provider for more information. 
Uploading Your Application 
The last step to complete the setup of your OTA download is to upload your JAD file and 
your COD files to your web server. Make sure that your JAD file and COD files are all 
accessible at the same level of the web server. For example, if your JAD file is available 
at http://www.mycompany.com/UiFun.jad, the COD files should be available at 
http://www.mycompany.com/UiFun.cod, and so on. Users will only have to worry about 
the location of the JAD file, but the BlackBerry will need to access all the COD files as 
well. 
Downloading the Application 
Once all of these things are taken care of, you just have to open your BlackBerry 
browser and enter the URL to the .jad file into the web address field, and you will be 
shown a page that lets you download the application to your device (Figure 9–2).  
 
Figure 9–2. OTA download. Notice the application properties we set earlier. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
230 
Desktop Installation 
BlackBerry applications can be installed from a computer to a device using a USB cable 
and the BlackBerry Desktop Manager. For large applications, desktop installation may 
save wireless data costs, and downloading an application is a lot faster over a 
broadband Internet connection than a 2.5G network connection. There may also be 
cases where wireless data access is not available on a BlackBerry device—if a user 
hasn’t subscribed to a data plan or an IT policy forbids certain types of network access 
from the BlackBerry device. Generally, though, desktop installation is more complex and 
involves more steps than OTA installation, making it more difficult for users.  
Unlike OTA installation, you don’t have to worry about sibling CODs with desktop 
installation.  
The ALX File 
Desktop installation requires a different type of descriptor file than OTA installation. For 
desktop installation, the file is XML based and has the extension .alx.  
Here’s an example ALX file for UiFun: 
<loader version="1.0"> 
    <application id="UiFun"> 
        <name > 
            UI Fun Application 
        </name> 
        <description > 
            The Beginning BlackBerry UI Fun Application 
        </description> 
        <version > 
            1.0.1 
        </version> 
        <vendor > 
RK 
        </vendor> 
        <copyright > 
            Copyright (c) 2011 RK 
        </copyright> 
        <fileset Java="1.39"> 
            <directory > 
                 
            </directory> 
            <files > 
                UiFun.cod 
            </files> 
        </fileset> 
    </application> 
</loader> 
The ALX file format allows you to support more complex installation scenarios, such as 
different COD files for different devices. This is outside the scope of this book, but 
documentation is available in the BlackBerry Developer Zone. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
231 
When you compile your project in Eclipse, a deliverables folder is automatically 
generated. The files for both OTA and desktop deployment are generated. For desktop 
files, look in the Standard folder within the deliverables folder (see Figure 9–3). 
 
Figure 9–3. ALX file autogenerated for you, shown in Eclipse IDE 
Distributing an application for desktop installation is easy—just give the ALX and COD 
files to the user.  
The process of installing is a bit more complex: 
1. Connect the device to the computer using a USB cable. 
2. If it’s not already running, start the BlackBerry Desktop Manager. 
3. Select the Application Loader. 
4. Click Add/Remove Applications. 
5. Click Browse, and find the ALX file for your application. 
6. Make sure the check box next to your application is checked (Figure 9–4), and 
click Next and complete the wizard. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
232 
 
Figure 9–4. Loading UiFun onto a device using the Application Loader from the Desktop Manager 
BlackBerry App World 
In April 2009, BlackBerry launched BlackBerry App World—an on-device and web-
based BlackBerry application store (Figure 9–5). App World is already the best way to 
distribute almost all BlackBerry applications. It offers a way for users to find 
applications, install them, and purchase them. Fortunately for developers, App World 
also takes away a lot of the headaches of deploying applications, making it easy to 
manage updates, deploy multiple versions for different devices and OS versions, and 
accept payment. 
 
Figure 9–5. BlackBerry App World 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
233 
Getting an App World Account 
The first step in deploying your application on App World is signing up for an account.  
Signing Up 
If you’re ready with the prerequisites, sign up for App World, and go to the App World 
Vendor Portal at https://appworld.blackberry.com/isvportal/ (Figure 9–6). 
Figure 9–6. The BlackBerry App World Vendor Portal 
Click the Get Started button, and follow the steps. You’ll be asked to create one 
account when you sign up, but you can create more (if you want to let more than one 
person manage your applications) once your account has been activated. 
If all goes well, you’ll receive an e-mail shortly after, either asking you for more 
information or informing you that you’re now able to submit applications to App World. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
234 
Distributing Your Application on App World 
App World applications are all managed through the Vendor Portal. Before we walk 
through an application submission, let’s talk a bit about pricing and licensing. 
Licensing Options 
Applications on App World can be one of the following three types: 
 Free 
 Paid 
 Try & Buy 
Free applications are just that—free. The user pays nothing to download and use the 
application. 
Paid applications require the user to pay a price that you set before downloading the 
application to their device. 
Try & Buy applications allow the user to download the application free, but the user can 
pay to get a license key that either unlocks additional functionality or prevents the 
application from expiring (the actual functionality is up to you—App World just manages 
selling and distributing the license keys). 
Paid and Try & Buy applications can be set up to use four different types of license 
models: 
 Static 
 Single Key 
 Key Pool 
 Dynamic Key 
With the Static model, a license key is not required—when the user purchases the app, 
they download the unlocked version. For Try & Buy, this means you’ll upload both a trial 
version and a full version of your application. This means you don’t have to worry about 
a license key algorithm, but users must download another copy of your application when 
they buy. 
With the Single Key model, there is one license key for all copies of the application. 
When the user pays, they receive this license key, which they can use to unlock the 
application. It’s simple, but with one license key, anyone who gets the key can unlock 
your application. 
With the Key Pool model, you provide a list of up to 2,000 license keys to App World, 
and these are handed out one at a time to each user who purchases the application. The 
advantage of this over the Single Key model is that you can track users by license keys, 
so if a key is being passed around, you may be able to deactivate or otherwise deal with 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
235 
it. To use the Key Pool model, you need to produce a text file, with one license key per 
line, to upload to App World along with your application. 
With the Dynamic Key model, the App World server contacts your web server when a 
user has purchased the application and a new key is needed. Your server can then 
generate the key based on information about the application and the user’s PIN or e-
mail address. This lets you produce a key for each user, so there’s much less danger of 
anyone else being able to unlock the application, but it requires more work on your 
part—hosting a server capable of responding to license key requests. 
There is actually another way to collect money from your user, and that is through in-
app purchase, which is covered toward the end of this chapter.   
Implementing License Keys 
What should a license key actually do? The simple answer is, “It’s up to the application.” 
That is, your license key just makes a trial application into a full application. What “trial” 
means is up to you. 
For example, you may develop an application that does one the following: 
 Stops working after 30 days unless a license key is purchased 
 Enables only certain functionality until a license key is purchased 
 Disables some functionality after two weeks unless a license key is 
purchased 
 Works only for a certain time period (for example, five minutes) or for a 
certain amount of data 
License Keys for Try & Buy Apps 
When a user purchases a Try & Buy application, they’ll be shown a dialog box with their 
license key in the App World client. They’ll be able to copy this key to the device 
clipboard, and you should provide a way for them to enter the key into your application 
to unlock it. Something as simple as an EditField will work. App World also 
automatically injects the license key into your application after it has been installed. See 
the “App World API” section later in this chapter for more information about how to 
retrieve this key from your application. 
License Keys for Paid Apps 
If a user has to pay for a Paid application before downloading it, why would you want to 
provide a license key? Well, it’s still useful for tracking purposes, and as we’ll see later, 
App World will inject the downloaded application with the license key in a way that lets 
your application retrieve it later. If you choose a nonstatic license model for your 
application, the user will see a dialog box with your license key after they’ve purchased 
and downloaded your application. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
236 
Pricing 
Applications for sale on App World—both Paid and Try & Buy—can be priced in the 
following pricing tiers (all amounts are in US dollars but will be converted to the 
appropriate currency for the App World user): 
 From $2.99 to $19.99 in $1 increments (i.e., $2.99, $3.99, etc.) 
 From $19.99 to $99.99 in $10 increments ($19.99, $29.99, etc.) 
 From $99.99 to $599.99 in $50 increments ($99.99, $149.99, etc.) 
 From $599.99 to $999.99 in $100 increments ($599.99, $699.99, etc.) 
App World takes 30 percent of the purchase price, giving 70 percent to the developer—
not a bad deal for not having to deal with payment headaches, distribution, and so on. 
The Submission Process 
This section is a bit different from the other walkthroughs earlier in the book. Because 
we’re dealing with a real, online submission process (with money involved), you 
shouldn’t follow each step literally using the same app name. Rather, look at this as a 
step-by-step guide and insert your own application information where appropriate when 
you’re ready to submit your BlackBerry application to App World. 
The submission process will time out if you sit at any step without doing anything for ten 
minutes, so you may want to read through this section before submitting to make sure 
you have all the information prepared beforehand.  
Listing Your Application 
Log into your App World account through the Vendor Portal, click Manage Applications, and 
then click the Add Application button. There are seven steps to the submission process. 
Step 1: Product Details 
You need to provide the following: 
 Product name: This is the name of your application (ideally you have 
that by now). 
 SKU: This is the unique ID for your app within App World. 
 The category and subcategory your application should belong to: 
These should reflect your application accurately, because a lot of 
users will discover your app by browsing through categories looking 
for an application for some specific purpose. 
 License type: The license type and license key information if required, 
as we discussed earlier, unless your application is free. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
237 
Step 2: Description 
You need to provide short and long descriptions. The short description appears in 
search results and product listings, so the text should be no longer than 50 characters. 
The long description appears in the product details, and can be a maximum of 4000 
bytes. You must at least have an English-language description. You may provide 
descriptions for a number of other languages as well. If you do not submit a localized 
description, your application description will default to the English description. 
Step 3: Product Screenshots 
You’ll need to provide a few things: 
 Product icon: This is a 480×480-pixel PNG image. This image is your 
application’s icon; it will appear, scaled way down, next to the 
application name in the App World category list (Figure 9–7). It will also 
be used as the archive icon if your users decide to archive your app to 
their SD card. This means that making this image different from your 
application icon will confuse your users. It also means you should 
avoid any very fine detail that might be lost when the image is scaled 
down. 
 
Figure 9–7. Browsing the top free apps. The icons are scaled-down versions of the 480×480-pixel PNG. 
 Product feature image: It never hurts to be prepared. If selected to 
appear in the App World Feature area (aka App World Carousel), the 
image you upload here will be used to showcase your app to 
BlackBerry users.  
 Product screenshots: You can take screenshots of your application 
and load them here. You can have a maximum of 50 screenshots, 
each no bigger than 640640 pixels.  

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
238 
Step 4: Distribution 
You can choose to have your application available on some or all wireless carriers and in 
some or all countries. If you have exclusive agreements with some carriers or other 
reasons to restrict distribution of your application, this section makes that easy to 
manage. 
Step 5: Product Summary 
In this step, you review what you have entered. Click the Save button when you are 
happy with what you have entered. 
At this point, you will be taken back to the Management Product page. Your product will 
be created in App World with “Draft” as the status.  
Step 6: Uploading Binary Files 
This is another area where App World saves you a lot of distribution headaches. The 
Releases section allows you to define each of the releases of your application that you 
want to make available on App World. When first submitting your application, you will 
probably have only a single release—for example, 1.0—but later you can add more 
releases. App World will automatically distribute the latest release of your application 
and notify your users of it. 
With the file bundles (essentially different bundles of file to support different BlackBerry 
OS), you can provide different versions of your application for different device types, OS 
versions, or both, and App World will ensure that the correct version is installed on the 
correct device. 
Don’t worry about extracting sibling CODs—App World will take care of that for you. 
You don’t need to provide a JAD file or anything other than the COD files for your 
application. 
If you want to automate the release process more, App World lets you import all the 
information for a release from a ZIP file. This is handy if you want your build system to 
take care of updating the list of supported devices and OS versions for each build. 
From the Manage Products section of the BlackBerry App World site, under you newly 
added application, click on the Plus sign in the Releases column, then follow below: 
1. Export Control: The questions listed on screen are to determine whether your 
application is bound by any export restrictions due to the use of cryptography. 
Many applications are—all we can say is to answer truthfully here.  
2. Digital Rights: This is another question that you should answer truthfully. If your 
product contains third-party content, you need to check this check box. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
239 
3. User-Generated Safeguards: If you allow users to generate content, App World 
will want to know if there is a way for your application to flag or block 
inappropriate content. 
4. Release Details: This is where you can upload a specific version of your 
application binary (COD) file. It is also where you can set the version number and 
the release notes for the specific release. For details on making different versions 
available, see the accompanying sidebar, “Different Versions for Different OS 
Versions and Device Models.”  
DIFFERENT VERSIONS FOR DIFFERENT OS VERSIONS AND DEVICE MODELS 
There are cases where you may want to have several versions of your application available, such as if you 
want to leverage some OS 7–specific features to take full advantage of the NFC API, but still want a version 
that supports older devices with OS 4.5 and later. This is easy to handle through App World using file 
bundles. We’ll use a couple of examples to illustrate how this can work. 
The first example uses a version for OS 7 devices and a version for OS 4.5 devices: 
1. Create a bundle called OS 4.5. 
2. Select Smartphone for your platform. 
3. Set the minimum OS to 4.5.  
4. Check Supports All Devices. 
5. Upload your OS 4.5 COD file. 
6. Create another bundle called OS 7. 
7. Select Smartphone for your platform. 
8. Check Supports All Devices. 
9. Set the minimum OS to 7.0. 
10. Upload your OS 7.0 COD file. 
App World will direct devices with OS 7.0 and later to the OS 7 bundle version and will direct other devices 
to the OS 4.5 bundle version. 
The second example uses a specific version just for Pearl models (for example, if your application needs a 
custom build for a small-screen device and another version for all other devices). Follow steps 1 through 4 
from the previous example to create an OS 4.5 version, and then perform the following steps: 
1. Create a bundle called Pearl. 
2. Select Smartphone for your platform. 
3. Set the minimum OS to 4.5.0. 
4. Uncheck Supports All Devices, and move all the 81xx and 82xx devices to the 
Supported box. 
5. Upload the Pearl COD file. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
240 
This is how you can use the bundle distribution system in App World to provide specific builds of your 
applications for specific device models or OS versions. 
5. Release Summary: Before saving the release, you can review the information that 
you provided.  
Step 7: Submit App for Approval 
The last step is to actually submit your application information and binary you provided 
in the above steps for approval. Your app will generally be approved in 8 to 10 business 
days and ready to distribute or sell to every BlackBerry device with App World installed. 
App World API 
App World also supports some API calls that let you integrate your application with App 
World in some useful ways. To help you get the most out of publishing on App World, 
we’ll explore a couple of these features now. 
Getting App World Properties for Your Application 
App World embeds a number of properties in applications that are downloaded and 
purchased through App World; these properties include the license key (if a license 
model other than static was used), the App World application name as specified in the 
Vendor Portal, the e-mail of the application purchaser, and others. Through the 
BlackBerry API, your application has access to these properties, so, for example, you 
can easily display license information to the user or pass license key information to your 
server as a way of tracking unique users. 
The following code snippet will read a property set by App World from an application on 
the BlackBerry device: 
    private String loadProperty(String appName, String propertyName) { 
         
CodeModuleGroup group =  
CodeModuleGroupManager.load(appName); 
if (group!=null) { 
return group.getProperty(propertyName); 
        } 
        return null; 
    } 
The appName parameter should be the same as the name you specified for your 
application in the App World Vendor Portal. The propertyName parameter can be one of 
the following string values: 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
241 
 RIM_APP_WORLD_ID: The numeric ID of the App World application. This 
is useful if you want to launch the App World client to your specific 
application details screen, such as when an update is available or a 
trial has expired and you want to make it easy for your user to 
purchase your application. 
 RIM_APP_WORLD_UPDATE_AVAIL: 	” if an updated version is available 
on App World, 	” otherwise. You may want to check this property 
periodically and have your application display a message to the user 
when an update is available. 
 RIM_APP_WORLD_LICENSE_KEY: The license key (if any) associated with a 
Paid application or a Try & Buy application after the user has 
purchased the application and received a license key. 
 RIM_APP_WORLD_NAME: The name of the application as specified in the 
App World Vendor Portal. 
 RIM_APP_WORLD_EMAIL: A hash of the e-mail address of the purchaser. 
 RIM_APP_WORLD_PIN: The hexadecimal value of the device PIN this 
application was downloaded onto. 
 RIM_APP_WORLD_VERSON: The application version as specified in the App 
World Vendor Portal. 
So, for example, to load the license key for an application named My Application that 
was purchased through App World, you would call the loadProperty method as follows: 
            String myAppLicenseKey = loadProperty("My Application", 
"RIM_APP_WORLD_LICENSE_KEY"); 
In-App Purchase  
Once you have finished and submitted your application, we want to mention another 
way of getting users to buy it. Typically, in-app purchase works well with the 
“Freemium” model, in which you give out your application for free with all of the 
features, and after a period of time, certain paid-only functions (aka premium features) 
are turned off. In-app purchase is a great tool in getting users to upgrade to the 
premium features, because they can buy right from your application, and there are fewer 
navigation steps for the users, which means more sales for you! 
While a description of implementing in-app purchase from end to end is out of scope of 
this book, in this section we will go through the basics of setting up your application on 
App World for in-app purchase, as well as setting up the Eclipse development 
environment. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
242 
Setting Up In-App Purchase on App World 
In-app purchase allows users to buy virtual goods right from your application. Some 
examples of virtual goods are licenses to your software, virtual wallpaper, and even 
songs. The first step in selling virtual goods from your application is to set up the virtual 
goods within App World. 
After you have set up and submitted your application as shown above, you can follow 
these steps to set up your virtual goods. 
1. Log into the Vendor Portal.  
2. Click Manage Products. 
3. In the Goods column for your application, click the + sign. This will open up an 
Add a Virtual Goods page. 
4. Enter a name for your virtual good and a SKU number. 
5. Select a license type. There are two choices: 
a. Non-Consumable: This type of virtual good can only be purchased 
once. App World will prevent users from buying more than once.  
b. Consumable: This type of virtual good can be purchased once or 
more. App World does not prevent users from buying more than 
once. 
6. Select a price for your virtual good. 
7. Select a license model (static, single key, pool, or dynamic).  
8. Enter a short description and a long description. As mentioned previously, short 
descriptions show up in searches and lists, and long descriptions show up on the 
product details page. 
9. Click Save. You can either add more goods or move on to submit your virtual 
good for approval by the App World staff. 
10. When you are ready, click Submit Goods for Approval.  
NOTE: We recommend that you finish coding your application for in-app purchase before 
submitting it for approval. 
1

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
243 
Setting Up Eclipse for In-App Purchase 
Before implementing in-app purchase in your application, we will first go through setting 
up Eclipse IDE so your project can reference the BlackBerry Payment Service API. 
Follow these steps to get started: 
1.
Download the  BlackBerry Payment Service API from the BlackBerry web site, at 
http://us.blackberry.com/developers/platform/paymentservice.jsp. The 
downloaded ZIP file will contain a JAR file that you will need to reference from 
your project. Unzip the paymentapi.jar file to a location where you can reference 
it later. 
2.
Open up your Eclipse workspace, and with your project highlighted click Project 
 Properties. 
3.
Click Java Build Path on the left panel, and then select the Libraries tab. 
4.
Click Add External JARs, and point to the location that contains the 
paymentapi.jar file. 
5.
Click the Order and Export tab, and check the box next to paymentapi.jar. 
6.
Click OK to save your changes. 
Calling the In-App Purchase API 
Now that Eclipse is set up, we will go through just how easily you can incorporate in-app 
payment into your application. We will start with constructing a 
PurchaseArgumentsBuilder object with information about your virtual goods: 
import net.rimlib.blackberry.api.payment.DigitalGoodNotFoundException; 
import net.rimlib.blackberry.api.payment.IllegalApplicationException; 
import net.rimlib.blackberry.api.payment.PaymentEngine; 
import net.rimlib.blackberry.api.payment.PaymentException; 
import net.rimlib.blackberry.api.payment.PaymentServerException; 
import net.rimlib.blackberry.api.payment.Purchase; 
import net.rimlib.blackberry.api.payment.PurchaseArgumentsBuilder; 
import net.rimlib.blackberry.api.payment.UserCancelException; 
PurchaseArgumentsBuilder myVirtualGood = new PurchaseArgumentsBuilder(); 
myVirtualGood.withDigitalGoodSku( "songid123" ); 
myVirtualGood.withDigitalGoodName( "Let us sing about BB Dev" ); 
myVirtualGood.withPurchasingAppName( "Sounds of Developers" ); 
myVirtualGood.withMetadata ( "Nerdy Sound Tracks" ); 
Next, what we need is to construct a PaymentEngine object and pass the 
PurchaseArgumentsBuilder object to it, which will return a valid (not null) Purchase 
object. 
PaymentEngine payEngine = PaymentEngine.getInstance(); 
payEngine.setConnectionMode(PaymentEngine.CONNECTION_MODE_LOCAL); 
// commented out for local testing 
payEngine.setConnectionMode(PaymentEngine.CONNECTION_MODE_NETWORK); 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
244 
if (payEngine!= null) 
{ 
try  
{ 
Purchase purchase = (Purchase) payEngine.purchase(myVirtualGood.build()); 
if(purchase!=null){ 
Dialog.inform(“Payment Submitted Successfully”); 
} 
}catch (DigitalGoodNotFoundException dgnf){ 
Dialog.alert(dgnf.getMessage()); 
}catch (IllegalApplicationException iae)  
{ 
Dialog.alert(iae.getMessage()); 
} 
catch (PaymentServerException pse){ 
Dialog.alert(pse.getMessage()); 
} 
catch (UserCancelException e) { 
Dialog.alert(e.getMessage()); 
} 
catch (PaymentException pe)  
{ 
Dialog.alert(pe.getMessage()); 
} 
} 
There are a couple things to note. For local testing, make sure you set the 
PaymentEngine connection mode to CONNECTION_MODE_LOCAL, so that any purchase from 
the testing environment does not make a connection to the App World servers. Make 
sure to set the connection mode to CONNECTION_MODE_NETWORK before going live. Also, if 
the Purchase object returned by PaymentEngine is not null, that means the purchase 
request went through fine. 
Other Application Stores 
App World is certainly getting most of the press these days, but one of the great things 
about BlackBerry is that it’s an open platform—as we’ve seen, you can post your app on 
your own web site, and there are several other application resellers that you can use 
besides BlackBerry App World. We’ll discuss one of the leading ones, MobiHand, in 
depth, including what it offers and how you can publish your application through it.  
MobiHand 
MobiHand sells applications for most mobile devices, including BlackBerry. It also 
operates branded application stores for many other leading BlackBerry-related sites, 
such as BlackBerryCool (www.blackberrycool.com), BerryReview (www.berryreview.com), 
BBGeeks (www.bbgeeks.com), CrackBerry (www.crackberry.com), and others. All of this 
means that MobiHand has a large audience and can help get your application noticed 
by more users. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
245 
MobiHand also produces an on-device app store client, called App Store for BlackBerry, 
which operates in a similar way to BlackBerry App World—though it’s not quite as 
elegant. It allows users to search and browse applications, descriptions, and reviews 
and ratings, and it opens the mobile version of the MobiHand (or affiliate) web site for 
download and purchase of the application through the BlackBerry browser. 
Signing Up for a MobiHand Account 
You can sign up for a MobiHand account at 
http://corporate.mobihand.com/sda_dev.asp. 
You’ll need much the same information as for an App World account, including your 
company’s name, address, and other relevant information. A MobiHand developer 
account is free, and you should be approved within about 24 hours. 
MobiHand sells applications for devices other than BlackBerry, so if you plan to sell for 
other platforms, indicate that in your submission. Obviously that is outside the scope of 
this book! 
Submitting and Managing Applications 
The developer portal for MobiHand and all its associated stores is located at 
www.mobireach.com. When your account is activated, log into the portal, and select 
Products  BlackBerry from the navigation bar to go to a list of your BlackBerry 
products (Figure 9–8). 
 
Figure 9–8. The MobiHand developer portal showing BlackBerry applications 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
246 
Rather than walk through a whole application submission, we’ll just discuss the options 
you have. 
Product Types 
There are three general types of product listings: 
 Standard: Just a normal application listing. 
 Master: A listing containing only pricing and application description 
information but no application—this is the method to handle 
applications with different builds for different device and OS versions. 
Master products are never directly listed on MobiHand. 
 Slave: A listing containing information specific to a build of an 
application. The application must be associated with a master, so you 
need to create the master beforehand. These are listed on MobiHand 
with a name that’s a combination of the master name and the slave 
differentiator. If your master is named My Application, specify your 
slave differentiator as something like “for Storm” to have the product 
listing “My Application for Storm” listed on MobiHand. 
Pricing 
You can set any price you want for your application. Leave the price field blank for free 
applications. Prices are specified in US dollars and automatically converted to the other 
supported currencies, but you can override these conversion amounts. 
You can also set a promotional price with an expiry date to enable you to have limited-
time sales on your applications. 
Product Features 
MobiHand will automatically determine which devices your application supports based 
on what you choose (you can manually change supported devices later). Even if you 
plan to manually change things later, it’s a good idea to be as accurate as possible here 
so that when new devices are added they’ll be handled correctly with minimal 
intervention on your part. 
Activation 
MobiHand supports several registration models, including free, paid, and a number of 
licensing models. 

CHAPTER 9:  Getting Your App Out There: Packaging and Publishing 
247 
Additional Selling and Pricing Features 
MobiHand provides some powerful tools to help support different sales strategies, 
including bundling applications together for one price, cross-selling (discounting later 
application purchases if a customer has purchased one application), and coupons.  
Other Sites 
Two other sites that you may want to look at as additional places to distribute and sell 
your applications are Handango (www.handango.com) and Handmark (www.handmark.com). 
Both—like MobiHand—sell software for a range of mobile devices, not just BlackBerry, 
and both may help you get your application into the hands of more users. 
Summary 
In this chapter, we’ve finished our introduction to the world of BlackBerry development 
by learning how to get an application distributed and loaded onto users’ BlackBerry 
devices. 
We looked at the basics of distributing an application on your own—including OTA 
downloading and loading via the BlackBerry Desktop Manager. Then we looked at 
BlackBerry App World, which lets you easily distribute your application and provides a 
way for users to pay for it. We explored the App World APIs that let you integrate your 
BlackBerry application with App World’s functionality in a number of useful ways. 
Finally, we discussed third-party application stores, including MobiHand and others. 
We’re now very nearly done. You now know enough to get started building the next 
world-beating BlackBerry application. The next and final chapter will point you to a few 
additional resources that you may find useful as you continue to explore and build your 
knowledge of BlackBerry application development. 

 
249 
 
 
                      Chapter 
Next Steps 
You’ve come quite a way since starting out on your journey. You may have started with 
little or no knowledge of how to develop BlackBerry applications, but by this point you 
should be familiar with the basics of developing user interfaces and creating 
applications that use—among other things—persistent storage, wireless networking, 
and location-based services.  
At this point, you’re more than ready to start building the application of your dreams, but 
of course there’s always more to know. The BlackBerry platform has been around for a 
while and has changed quite a bit in that time. It continues to evolve today—like the rest 
of the mobile world—at a faster pace than ever. BlackBerry App World is the first of 
many great additions to the platform.  
Mobile application development is still in its infancy, and BlackBerry is going to be 
around and growing with the mobile industry for a long time. So, part of your job as a 
BlackBerry developer is to stay on top of everything that happens by learning and 
evaluating new platform capabilities and seeing if the new features can make your 
applications even better. 
Keeping Current 
The main source for up-to-date information about BlackBerry is the first one mentioned 
in this book, the BlackBerry Developer Zone at www.blackberry.com/developers. Along 
with being the source for all your BlackBerry application development tools, the 
Resources section contains a lot of useful information and should be among the first 
places you turn to get a question answered 
(www.blackberry.com/developers/resources). Among other things, the knowledge base, 
developer documentation (including development guidelines, white papers, and online 
versions of the Javadocs), tutorials, and videos are all very useful. 
10 

CHAPTER 10:  Next Steps 
250 
Forums 
Several useful developer forums exist. The first one to check is the official BlackBerry 
Support Community Forms—specifically the Developer Forums at 
www.blackberry.com/developers/forum. There are multiple forums on this link, all related 
to BlackBerry app development. Some are very active. You'll see a Java Development 
forum on this link, and if you can’t find an answer there, posting a question will usually at 
least put you in touch with someone who’s had the same problem. 
In addition to the official forums, a couple of third parties host fairly active developer 
forums, including BlackBerryForums at www.blackberryforums.com/developer-forum/ 
and CrackBerry.com at http://forums.crackberry.com/app-developers-f9/. 
BlackBerry Conferences 
Every year, Research In Motion holds a BlackBerry Developers Conference in San 
Francisco, California in late October or early November. It's worth attending in order to 
learn about BlackBerry programming—and the BlackBerry platform in its entirety. It's 
also where RIM unveils new products and services or announces major updates to the 
BlackBerry API. You can find more information at www.blackberrydevcon.com. 
RIM also hosts BlackBerry World every year in Orlando, Florida and typically in early 
May. The conference is mostly attended by representatives of big companies that use 
BlackBerry Enterprise Server and it's a great place to network if you have a compelling 
application, especially one for enterprise users. Find more information at 
www.blackberryworld.com. 
OpenGL on the BlackBerry 
If you are interested in developing games using OpenGL or you have an existing 
application built using OpenGL from other platforms and want to port to BlackBerry, 
check out RIM's guide at http://docs.blackberry.com/en/developers/deliverables/ 
17967/OpenGL_1236721_11.jsp. 
Newsletters, Blogs, and Other Resources 
All developers should subscribe to the BlackBerry Developer newsletter. It’s free and 
delivers a new issue monthly; go to www.blackberry.com/DeveloperUpdates/. 
There are a few useful blogs, too. RIM recently launched its own BlackBerry Developer’s 
Blog at www.blackberry.com/developers/blog. It gives you the inside scoop from 
developers at RIM about a variety of development topics. The Inside BlackBerry blog 
can also be useful for general happenings with BlackBerry; see 
http://blogs.blackberry.com. Finally, Anthony Ritz maintains a blog called Thinking 
BlackBerry at www.thinkingblackberry.com/. 

CHAPTER 10:  Next Steps 
251 
The official web sites for this book offer the source code for all of the examples, errata, 
and other recent information. You can visit the Apress site (the publisher of this book) at 
www.apress.com/9781430230151. Or, you can visit our web site at 
www.beginningblackberry.com. If you can’t find an answer to your question, contact us 
through our web site, and we’ll do our best to help solve your problem! 
Farewell 
That’s all! Thanks for reading to the end, and best of luck with all your BlackBerry 
development in the future! 

 
253 
Index 
■ Special Characters 
and Numerics
16-bit color model, 83 
■ A 
Abstract Window Toolkit (AWT), 49 
Access Point Name (APN), 171 
accounts 
App World application store, 233 
MobiHand application store, signing 
up for account, 245 
activation, MobiHand application store, 
246 
ActiveX Layout (ALX) files, 230–231 
Add Directory button, 140 
Add Library button, 28 
Add Records button, 157 
addresses, getting coordinates from, 
215–216 
providing address, 215 
sending geocoding requests,  
215–216 
Album class, 70–71 
Album screen, 70 
alternate entry points, 46–47 
Alternate Entry Points screen, 46 
Alternate JRE radio button, 29 
ALX (ActiveX Layout) files, 230–231 
animation, 119–122 
of layout, 120 
setting vertical offset, 119–120 
animationStart, 119–120 
APIs (Application Programming 
Interfaces) 
App World application store,  
240–241 
In-app Purchase, calling, 243–244 
Invoke, 216–217 
JSR 75 FileConnection, 125 
JVM as native, 11 
APN (Access Point Name), 171 
App World application store, 232–244 
API, 240–241 
distributing application on, 234–235 
getting account, 233 
implementing license keys, 235 
in-app purchase, 241–244 
calling API, 243–244 
setting up, 242 
pricing, 236 
submission process, 236–240 
description, 237 
distribution, 238 
listing application, 236 
product details, 236 
product screenshots, 237 
product summary, 238 
submitting app for approval, 240 
uploading binary files, 238–240 
App World properties, getting for 
application, 240–241 
AppContentListener, 163–164 
appendLabelText, 40–42 
application classes, 18–20 
application descriptors, setting titles in, 31 
Application Programming Interfaces. 
See APIs 
application stores 
App World, 232–244 
API, 240–241 

Index 
254 
distributing application on,  
234–235 
getting account, 233 
implementing license keys, 235 
in-app purchase, 241–244 
pricing, 236 
submission process, 236–240 
Handango, 247 
Handmark, 247 
MobiHand, 244–247 
activation, 246 
pricing, 246 
products, 246 
selling and pricing features, 247 
signing up for account, 245 
submitting and managing 
applications, 245–246 
ApplicationArguments class, 216 
applications, 35–48 
background, 42–43 
downloading, 229 
framework of, 136–138 
getting App World properties for, 
240–241 
integrating with Unified Search 
facility, 157–167 
Javadoc format, 35–36 
life cycle of, 37–38 
listing, with App World application 
store, 236 
packaging and signing, 29–30 
setting properties of, 226 
submitting for approval 
to App World application store, 
240 
to Mobihand application store, 
245–246 
threading and event thread, 38–41 
types of, 44–48 
UiFun, enhancing, 75–76 
uploading, 229 
app_logo.png, 159, 163 
Assisted GPS mode, 204–205 
Assisted mode, 206 
Auto-generated method, 20 
AWT (Abstract Window Toolkit), 49 
■ B 
background applications, running,  
42–43 
BackgroundFactory class, header 
background and, 115 
backgrounding, or foregrounding,  
42–43 
backgrounds 
of header, 114–115 
of screen, painting, 113–114 
BES (BlackBerry Enterprise Server), 225 
BES/MDS (BlackBerry Enterprise 
Server/Mobile Data Service) 
connections, 170–171, 192–194 
binary files, uploading, 238–240 
BIS (BlackBerry Internet Service), 169, 
172, 193 
Bitmap class, 73 
Bitmap object, 52, 79 
Bitmap parameter, 85 
BitmapField, 114, 141, 144, 178 
BlackBerry Alliance Program, 172, 193 
BlackBerry App World Vendor Portal, 
233 
BlackBerry Application Development, 9 
BlackBerry class, 45 
BlackBerry Desktop Manager, 225, 
230–231, 247 
BlackBerry Developer Forums, 2 
BlackBerry Developer Zone, 32, 249 
BlackBerry Enterprise Server (BES), 225 
BlackBerry Enterprise Server/Mobile 
Data Service (BES/MDS) 
connections, 170–171, 192–194 
BlackBerry extensions to JSR 179 APIs 
JSR 179 APIs and, getting location 
information using, 202–206 
specifying GPS modes using,  
205–206 
BlackBerry file, 125, 136, 167 
BlackBerry Geolocation mode, 203 
BlackBerry Internet Service (BIS), 169, 
172, 193 
BlackBerry JDE Plug-In for Eclipse 
platform, building Hello World 
application with, 15–30 

Index 
255 
application classes, 18 
breakpoints and Debug perspective, 
25–26 
building with different JDE versions, 
28–29 
debugging on device, 30 
filling in Hello World classes, 21 
GUI fields, 22 
main screen classes, 20–22 
packaging and signing application, 
29–30 
profiler, 27 
running simulator, 22–25 
BlackBerry Maps, 216–223 
embedding in UI with MapField 
class, 221–223 
Invoke API, 216–217 
location documents, 218–220 
views 
displaying custom map, 220–221 
launching default, 217–218 
BlackBerry Project Properties, 226 
BlackBerry Simulator icon, 23 
BlackBerry-specific parameter, 192 
BlackBerry UI Guidelines, 32 
BlackBerry_App_Descriptor.xml file, 17, 
44, 46 
BlackBerryCriteria object, 205, 207 
BlackBerryLocation object, 206 
BlackBerryLocationProvider, 206–207 
blogs, 250–251 
Bluetooth technology, 173 
br (break) tags, 187 
breakpoints, and Debug perspective, 
25–26 
button fields, 90–96 
drawing focus, 93–95 
handling events, 95–96 
laying out interface, 90–91 
making focusable, 92–93 
painting, 91 
viewing, 91–92 
ButtonField class, 54, 56, 58, 60, 66, 
91, 96, 147, 152, 165 
ButtonField.CONSUME_CLICK style, 
54, 56, 58, 147, 152, 165 
ButtonFields, 56, 69 
buttons, 56–59 
ByteArrayOutputStream, 180–181,  
196–197 
■ C 
Cell Site mode, 203–205, 211 
Central Processing Units (CPUs), and 
memory, 11 
Change SD Card option, 140 
check boxes, Domain field and, 55–56 
CheckboxField, 55–56, 58–59, 69 
ChoiceField, 55, 59 
ClassNotFoundException, 78, 108, 112 
Clean Simulator option, 134 
Clear button, 60–61 
Clear menu item, Login menu item and, 
implementing, 65–69 
clearList function, 155–156 
ClearMenuItem, 65–66 
COD (Code and Data) files, 227 
code signing keys 
getting, 8 
installing, 9–11 
Color class, 83 
com.beginningblackberry.location 
package, 207 
Command class, reusable, 66–67 
CommandHandler class, 66–67 
commit method, 133 
component packs, JDEs for Eclipse 
platform, 5 
com.somethingelse.HelloWorldMain 
Screen, 45 
conferences, 250 
connection codes, new, 195–196 
Connection interface, 175 
connections 
file, opening, 138–139 
HTTP, 179 
initiating, 182 
secure, 190 
Connector class, 138, 175 
Connector.open method, 175, 180–181, 
190, 192–194, 197 

Index 
256 
constructors, label field, 82–83 
Consumable type, 242 
Content-type header, 191 
content types, 228–229 
contentType, 179–181, 185–186 
controls, Networking application, 178 
Coordinates class, 210 
coordinates, getting from address,  
215–216 
copying files, 148–150 
COVERAGE_BIS_B, 194 
COVERAGE_DIRECT, 194–195 
CoverageInfo class, 194–196 
CoverageInfo.COVERAGE_CARRIER, 
196 
CoverageInfo.COVERAGE_DIRECT, 196 
COVERAGE_MDS, 194–195 
CPUs (Central Processing Units), and 
memory, 11 
createStatement, 151, 154–156 
Criteria class, 204 
Criteria object, 205, 207 
CustomButtonField class, 90–96,  
112–113 
CustomDialog class, 110–113, 121 
Customer class, 160–161, 164 
CustomHashtable class, 135–136 
CustomLabelField class, 82, 84–87, 89, 
108 
customView method, 220–221 
■ D 
Data optimal mode, 206 
DatabaseApplication, 152 
DatabaseManager, 152 
DatabaseScreen, 152 
Date object, 213 
DateField, 128, 132 
Debug button, 24, 26 
Debug Configurations dialog, 23 
Debug perspective, breakpoints and, 
25–26 
debugging, on device, 30 
delegate managers, 80–81, 110–111, 
114 
deleteTableData function, 156 
deliverable folder, 227 
deliverables folder, 231 
descriptions, on App World application 
store, 237 
descriptors, application, 31 
desktop installation, 230–231 
desktop software, installation of, 7–8 
developing, for BlackBerry devices,  
11–12 
development environments, setting up, 
2–11 
code signing keys, 8–11 
downloading additional simulators, 7 
installation, 3–4, 7–8 
devices 
clearing persistent data from,  
135–136 
connection recommendations for, 
173 
touch screen models, 117–119 
Dialog class, 60 
Dialog.alert, 148, 156 
Digital Rights, 238 
direct TCP/IP connections, instead of 
BES/MDS, 192–194 
using BIS, 193 
using WAP 2.0, 192–193 
Wi-Fi, 194 
directories, listing contents of, 139–140 
display screens, 141 
distributing 
with App World application store, 
238 
applications, on App World 
application store, 234–235 
documents folder, 154 
documents, location, 218–220 
Domain field, and check box, 55–56 
domainField, 55–56, 58, 63 
downloading applications, 229 
drawFocus, 94, 97 
drawing, to screen using Graphics 
class, 79–81 
how screen is drawn, 80–81 
paint method, 79–80 

Index 
257 
Dynamic Key model, 235 
dynamic menu items, 146 
■ E 
Eclipse platform 
JDEs for 
BlackBerry Java Plug-In, 4 
component packs, 5 
setting up for in-app purchase, 243 
Eclipse plug-in, 3–4 
EditField, 178, 188 
EditFields, 97 
EncodedImage, 141–142, 144 
EndToEndRequired=true parameter, 
191 
enterEventDispatcher, 38, 43, 47 
enterEventDispatcher method, 21 
EntityBasedSearchableProvider, 158, 
160–163 
entry points, alternate, 46–47 
event lock, 41 
event threads 
invoking, 38 
threading and, 38–41 
knowing when application is on 
event thread, 39 
updating UI from other threads, 
39–41 
Export Control, 238 
■ F 
Field class, 50, 54, 82, 89 
fieldChanged method, 60–61, 63, 147, 
153, 156, 165 
FieldChangedChangeListener, 153 
FieldChangeListener, 147, 152, 164 
FieldChangeListener interface, 60 
Field.FIELD_HCENTER style, 53, 58, 
106, 112, 114 
Field.FIELD_LEFT style, 114 
Field.FIELD_RIGHT style, 57–58, 97–98, 
104–106, 108, 116 
FIELD_RIGHT style, 105 
fields, 55–59, 82–97 
adding to screens, 112–113 
buttons, 56–57, 90–96 
arranging horizontally, 57–59 
drawing focus, 93–95 
handling events, 95–96 
laying out interface, 90–91 
making focusable, 92–93 
painting, 91 
viewing, 91–92 
Domain, and check box, 55–56 
label, 82–90 
constructor, 82–83 
CustomLabelField class, 86–87 
displaying images, 85–86 
Field class, 82 
layout method, 83 
overriding getPreferredWidth and 
getPreferredHeight methods, 
87–90 
paint method, 84 
style flags, 54 
username and password, 55 
Fields type, 50 
Field.setChangeListener method, 59 
file connections, opening, 138–139 
file name screen, 147 
file systems 
loading images from, 142 
writing to, 145–150 
copying file, 148–150 
dynamic menu item, 146 
file name screen, 147 
FileConnection API, 136–145 
application framework, 136–138 
images 
display screen, 141 
getting into simulator, 142–144 
loading from file system, 142 
scaling, 144–145 
JSR 75, 125 
listing directory contents, 139–140 
opening file connection, 138–139 
viewing pictures, 141 
FileConnection interface, 138 
FileConnection.isDirectory method, 139 

Index 
258 
FileConnectionScreen class, 136–137, 
146 
FileNameScreen class, 147 
files, copying, 148–150 
final variable, 119 
Fixed32 methods, 144 
focus 
drawing, 93–95 
enabling for button fields, 92–93 
movement of, 106–107 
Font class, 78 
FontFamily class, 77 
FontFamily.forName method, 77 
Font.getAdvance method, 88 
fonts, 77–79 
foregrounding, backgrounding or,  
42–43 
forms, HTML, 187–188 
forums, 250 
■ G 
Geocoder object, 215 
geocoding 
and reverse geocoding, 214–216 
sending requests, 215–216 
geolocation, 202 
Geolocation cell mode, 206 
Geolocation optimal mode, 206 
Geolocation WLAN mode, 206 
GET method, 176 
getChoice method, 63 
getCoverageStatus method, 194–195 
getHeight method, 83, 85, 87–88, 94, 
101–102, 111, 113, 120 
getInstance method, 205–206, 209, 
214–216 
getMenu method, 65 
getPreferredHeight method, 87–90 
getPreferredWidth method, 87–90 
getResponseCode, 180–181 
getUiApplication( ) method, 37, 40, 43 
getWidth method, 83, 86, 88, 91, 94, 
101–102, 106, 113 
getWLANState class, 195 
Global Positioning System. See GPS 
GPS (Global Positioning System),  
203–204 
Assisted GPS, 204 
BlackBerry Geolocation, 203 
Cell Site, 203 
specifying 
using BlackBerry extensions to 
JSR 179, 205–206 
using JSR 179, 204–205 
support for, 201 
Unassisted GPS, 204 
GPS method, 203, 205–206 
GPSInfo class, 205 
Graphical User Interface (GUI) fields, 22 
Graphics class, drawing to screen 
using, 79–81 
how screen is drawn, 80–81 
paint method, 79–80 
Graphics object, 79–81, 84, 94 
Graphics.drawText, 88 
grid field, 104–105 
GridFieldManager, 100–101, 104–105, 
108 
GUI (Graphical User Interface) fields, 22 
■ H 
Handango application store, 247 
Handmark application store, 247 
Hashtable, 126, 132–136, 154 
HEAD method, 176 
header background, 114–115 
headers, 176 
height parameters, setting, 87–90 
Hello World application, 15–33 
with BlackBerry JDE Plug-In for 
Eclipse platform, 15–30 
application classes, 18 
breakpoints and Debug 
perspective, 25–26 
building with different JDE 
versions, 28–29 
debugging on device, 30 
filling in Hello World classes, 21 
GUI fields, 22 
main screen classes, 20–22 

Index 
259 
packaging and signing 
application, 29–30 
profiler, 27 
running simulator, 22–25 
displaying changes to, 33 
icon for, 31–32 
setting title in application descriptor, 
31 
Hello World classes, filling in, 21 
HelloWorldApp class, 18, 20–21, 37, 
42–43, 47 
HelloWorldMainScreen, 39–40, 42–43, 
45–47 
home directory, 139 
HorizontalFieldManager class, 57–58, 
97, 114–115, 152–153 
HTML (Hypertext Markup Language), 
35, 187–188 
HTTP (Hypertext Transfer Protocol) 
basics of, 176 
headers, 176 
methods, 176 
request and response, 176 
connection, 179 
sending data via POST method, 
187–191 
HTML forms, 187–188 
HTTP networking, 191 
making secure connections, 190 
modifying 
HttpRequestDispatcher class, 
188 
modifying NetworkingMainScreen 
class, 188–189 
HttpConnection, 175, 180–181, 186, 
188, 190, 192–194 
HttpRequestDispatcher class, 179–182 
displaying response failed 
notification, 182 
initiating connection, 182 
modifying, 188 
run method, 180–181 
Hypertext Markup Language (HTML), 
35, 187–188 
Hypertext Transfer Protocol. See HTTP 
■ I 
icon.png file, 32 
icons, for Hello World application,  
31–32 
IDE (integrated development 
environment), 2 
ImageDisplayScreen, 141–142, 144 
images 
display screen, 141 
displaying, 69–74, 85–86 
getting into simulator, 142–144 
loading from file system, 142 
scaling, 144–145 
in-app purchases, 241–244 
calling API, 243–244 
setting up, 242–243 
indenting, labels, 116 
Independent Software Vendor (ISV), 3 
input, user, 12 
InputStream class, 142, 149 
InputStream.available( ) method, 198 
Install New Software screen, 5–6 
installation, 225–247 
application stores 
App World, 232–244 
Handango, 247 
Handmark, 247 
MobiHand, 244–247 
desktop, 230–231 
over-air, 226–229 
applications, 229 
content types, 228–229 
JAD file, 228 
MIME types, 228–229 
sibling COD files, 227 
setting application properties, 226 
Integer object, 127 
integrated development environment 
(IDE), 2 
interfaces, laying out for button field, 
90–91 
Invoke API, 216–217 
Invoke class, 216 
invokeAndWait, 39 
invokeApplication method, 216–217, 
219, 221 

Index 
260 
invokeLater, 39–40 
isEventDispatchThread( ) method, 39 
isFocus method, 94 
isFocusable, 92, 97 
ISV (Independent Software Vendor), 3 
■ J 
JAD (Java Application Descriptor) files, 
228 
JAR file, 243 
Java Application Descriptor (JAD) files, 
228 
Java Build Path, 28 
Java class, 127 
Java Development Environments. See 
JDEs 
Java EE (Java Enterprise Edition), 2 
Java file, 60, 180 
Java plug-ins, BlackBerry, 4 
Java SE (Java Standard Edition), 2 
Java Specification Requests. See JSR 
Java Standard Edition (Java SE), 2 
Java Virtual Machine (JVM), as native 
API, 11 
Javadoc format, 35–36 
java.lang.Runnable, 39 
java.lang.Thread, 40 
javaloader utility, 225 
java.sql package, 151 
java.util.Hashtable, 127–128, 132, 135 
javax.microedition.io.Connector class, 
171, 175, 180, 196 
javax.microedition.location, 203–205, 
209, 212, 219 
javax.microedition.rms package, 124 
JDEs (Java Development Environments) 
building Hello World application with 
different, 28–29 
for Eclipse platform, 4–5 
JRE System Library, 17, 28 
JSR (Java Specification Request) 179 
APIs 
and BlackBerry extensions to JSR 
179, getting location 
information using, 202–206 
specifying GPS modes using,  
204–205 
Assisted GPS mode, 204–205 
Cell Site mode, 204 
Unassisted GPS mode, 204 
JSR (Java Specification Request) 75 
FileConnection API (Application 
Programming Interface), 125 
JVM (Java Virtual Machine), as native 
API, 11 
■ K 
Key Pool model, 234 
key/value pairs, 132 
keys 
code signing 
getting, 8 
installing, 9–11 
Persistent Store, 126 
keyspace, 126 
■ L 
label fields, 82–90 
constructor, 82–83 
CustomLabelField class, 86–87 
displaying images, 85–86 
Field class, 82 
layout method, 83 
overriding getPreferredWidth and 
getPreferredHeight methods, 
87–90 
paint method, 84 
LabelField, 21–22, 26, 40–41, 84, 97, 
104, 112, 116 
labels 
aligning, 105–106 
altering layout of, 87–90 
indenting, 116 
setting height parameter, 87–90 
specifying text width, 87–90 
Launch Mobile Data System check box, 
192 
layout method, 83, 85, 88–90, 101, 105 
layout stage, 80–81 

Index 
261 
layoutChild method, 101–103 
layouts, animation of, 120 
libraries, 44–45 
Library tab, 28 
license keys, App World application 
store, 235 
licensing options, App World 
application store, 234–235 
life cycles, of applications, 37–38 
exiting, 38 
invoking event thread, 38 
processing events, 38 
starting, 37 
listing applications, with App World 
application store, 236 
loadFile method, 137, 139, 141–142 
Location application, 207–214 
location-based services, 201–223 
BlackBerry Maps, 216–223 
embedding in UI with MapField 
class, 221–223 
Invoke API, 216–217 
location documents, 218–220 
views, 217–221 
geocoding and reverse geocoding, 
214–216 
getting location information, 202–
206 
GPS support, 201 
Location application, 207–214 
location documents, 218–220 
Location object, 205 
location updates, getting using 
LocationListener interface,  
211–214 
LocationApp class, 207 
LocationHandler class, 209–212, 214, 
218–219 
LocationInfo class, 205 
LocationListener, 211–212 
LocationListener interface, getting 
location updates using,  
211–214 
LocationMainScreen, 207–210, 212, 
214, 217, 219–220, 222 
location.png, 159, 161–162 
LocationProvider, 205–207, 209–210, 
212, 214 
locationUpdated method, 212, 214 
Login button, 62–64 
Login menu item, and Clear menu item, 
65–69 
Login MenuItem, 66–67 
Login method, 122 
loginButton, 56–58, 63, 66–67 
LoginCommandHandler class, 67 
LoginMenuItem, 65–66 
LoginSuccessScreen class, 62–63, 69, 
71, 107–109, 119–122 
LoginSucessScreen, 120–121 
logo images, 52–54 
adding to project, 52 
adding to screen, 52–54 
field style flags, 54 
■ M 
main method, 19, 21, 37–38, 46–47 
main screens, adding TCP socket 
connection support to, 198–199 
MainScreen class, 52–53, 57, 60, 62, 
65–66, 70 
MainScreenUpdaterThread class, 40–41 
makeMenu method, 65–68, 137, 146 
Manager class, 54, 100, 110 
managers, 97–109 
aligning labels, 105–106 
focus movement, 106–107 
grid field, 104–105 
GridFieldManager field, 100 
implementing framework of, 100 
implementing sublayout method, 
101–104 
LoginSuccessScreen class, 107–109 
Managers type, 50 
MapDimension object, 215 
MapField class, embedding Blackberry 
Maps in UI with, 221–223 
MapLocation object, 215 
maps, displaying custom, 220–221 
MapsArguments, 217, 219, 221 
MapView, 220–221 

Index 
262 
MDS command, 192 
MDS (Mobile Data System) simulators, 
182–183 
memory, CPU and, 11 
menu items, dynamic, 146 
Menu object, 65 
Menu.INSTANCE_CONTEXT, 68 
Menu.INSTANCE_CONTEXT_SELECTI
ON, 68 
Menu.INSTANCE_DEFAULT, 68 
menus, items, 64–69 
MIDlet projects, MIDP and, 48 
MIDP (Mobile Information Device 
Profile), 175–177 
Connection interface, 175 
Connector class, 175 
HTTP basics, 176 
and MIDlet projects, 48 
Test Web application, 177 
MIME (Multi-purpose Internet Mail 
Extensions) types, 228–229 
MobiHand application store, 244–247 
activation, 246 
pricing, 246 
products, 246 
selling and pricing features, 247 
signing up for account, 245 
submitting and managing 
applications, 245–246 
Mobile Data System (MDS) simulators, 
182–183 
Mobile Information Device Profile. See 
MIDP 
MS-assisted mode, 206 
MS-based mode, 206 
Multi-purpose Internet Mail Extensions 
(MIME) types, 228–229 
MyApp.java class, 18 
mypackage package, 18 
MyScreen.java class, 18 
■ N 
navigationClick, 95, 97 
Near Field Communication (NFC), 173 
net.rim.blackberry.api.browser.URLEnc
odedPostData, 189 
net.rim.blackberry.api.maps.MapView, 
220 
net.rim.device.api.container.Popup 
Screen, 147 
net.rim.device.api.database, 151 
net.rim.device.api.gps, 203 
net.rim.device.api.lbs.maps.server 
packages, 214 
net.rim.device.api.math.Fixed32 class, 
144 
net.rim.device.api.system.Application, 
37 
net.rim.device.api.system.KeypadListen
er, 95 
net.rim.device.api.ui.component, 51–53, 
55–56, 58, 60, 62, 70 
net.rim.device.api.ui.container, 100, 110 
net.rim.device.api.ui.decor, 115 
net.rim.device.api.ui.Field, 51, 53, 82, 
90, 100, 107 
net.rim.device.api.ui.FieldChangeListen
er, 60 
net.rim.device.api.ui.Font, 77, 107 
net.rim.device.api.ui.Graphics, 79, 82, 
90, 113 
net.rim.device.api.ui.Manager, 100 
net.rim.device.api.ui.MenuItem, 64–65 
net.rim.device.api.ui.Screen, 51, 110 
net.rim.device.api.ui.UiApplication 
class, 18–20, 51, 63 
net.rim.device.api.util.Persistable 
interface, 127 
network-enabled applications, 169–199 
determining network availability, 
194–196 
CoverageInfo class, 194 
new connection code, 195–196 
WLANInfo class, 195 
direct TCP/IP connection instead of 
BES/MDS, 192–194 
using BIS, 193 
using WAP 2.0, 192–193 
Wi-Fi, 194 
MIDP connection framework,  
175–177 
Connection interface, 175 

Index 
263 
Connector class, 175 
HTTP basics, 176 
Test Web application, 177 
Networking application, 177–191 
controls, 178 
HTTP connection, 179 
HttpRequestDispatcher class, 
179–182 
sending data via HTTP POST 
method, 187–191 
testing, 182–187 
service book, 174 
TCP socket connections, 196–199 
adding support for to main 
screen, 198–199 
simple application using,  
196–198 
ways to connect, 169–173 
BES/MDS, 170–171 
BIS, 172 
direct TCP/IP, 171 
recommendations for devices, 
173 
short-range communication, 173 
WAP 1.0, 173 
WAP 2.0, 172 
Wi-Fi networking, 172 
Networking application, 177–191 
controls, 178 
HTTP connection, 179 
HttpRequestDispatcher class,  
179–182 
displaying response failed 
notification, 182 
initiating connection, 182 
run method, 180–181 
sending data via HTTP POST 
method, 187–191 
HTML forms, 187–188 
HTTP networking, 191 
making secure connections, 190 
modifying 
HttpRequestDispatcher class, 
188 
modifying NetworkingMainScreen 
class, 188–189 
testing, 182–187 
handling successful requests, 
185–186 
MDS simulator, 182–183 
networking, HTTP, 191 
NetworkingMainScreen class, 177–180, 
188–189, 197–198 
NetworkingMainScreen.java, 177–178 
New BlackBerry Project dialog, 17 
New Java Class dialog, 19 
newsletters, 250–251 
NFC (Near Field Communication), 173 
Non-Consumable type, 242 
notifications, response failed, 182 
NumericChoiceField, 55, 128, 132 
■ O 
Object array, 139 
ObjectChoiceField component, 55–56, 
58, 69, 97, 104, 132 
ObjectListField, 136–137, 139, 152, 
164–165 
offsets, vertical, 119–120 
onFocus, 94, 97 
onUnfocus, 94, 97 
OpenGL, resources for, 250 
operating system (OS), 4 
Optimal mode, 203 
ordinal, 64–65 
OS (operating system), 4 
OTA (over-the-air), 225–226 
OutputStream, 148 
over-air installation, 226–229 
applications, 229 
content types, 228–229 
JAD file, 228 
MIME types, 228–229 
sibling COD files, 227 
over-the-air (OTA), 225–226 
■ P 
packaging, applications, 29–30 
paid apps, license keys for, 235 

Index 
264 
paint method, 79–80, 84, 86, 88, 91, 94, 
100, 115 
paint stage, 80 
paintBackground method, 113 
painting 
button fields, 91 
to screen, 81 
screen background, 113–114 
password fields, username field and, 55 
paymentapi.jar file, 243 
PDE (Position Determining Entity), 203 
People table, 154 
Persistable application, 128–131 
loading data, 129 
persistent object, 129 
save method, 130–131 
Persistable interface, 127 
persistable objects, 127–128 
PersistenceApplication.java, 128 
PersistenceScreen class, 128–130, 
132–133 
persistent objects, 129 
Persistent Store, 124–125, 136 
clearing persistent data 
from device, 135–136 
from simulator, 134 
Hashtable structure, 132 
keys, 126 
loading and saving data, 133 
modifying UI, 132 
Persistable application, 128–131 
loading data, 129 
persistent object, 129 
save method, 130–131 
persistable objects, 127–128 
PersistentObject object, 126–127 
PersistentObject class, 124–126,  
128–129, 132–134 
PersistentObject object, 126–127 
persistentObject.commit method,  
126–128, 130, 133 
PersistentStore class, 124–126,  
128–129, 133 
PersistentStore.getPersistentObject 
method, 126 
persisting data, 123–167 
choices for, 124–125 
JSR 75 FileConnection API, 125 
Persistent Store, 124 
RMS, 124 
Runtime Store, 124 
SQLite database, 125 
FileConnection API, 136–145 
application framework, 136–138 
images, 141–145 
listing directory contents,  
139–140 
opening file connection, 138–139 
viewing pictures, 141 
integrating app with Unified Search 
facility, 157–167 
Persistent Store, 125–136 
clearing persistent data, 134–136 
Hashtable structure, 132 
keys, 126 
loading and saving data, 133 
modifying UI, 132 
Persistable application, 128–131 
persistable objects, 127–128 
PersistentObject object, 126–127 
with SQLite database, 150–157 
creating database and table, 
150–151 
inserting records, 151 
querying tables, 151 
sample application, 151–157 
storing, 123 
writing to file system, 145–150 
copying file, 148–150 
dynamic menu item, 146 
file name screen, 147 
Person database, 154 
Person table, 151 
Personal Information Management 
(PIM), 125 
Person.db file, 154, 157 
pictures, viewing, 141 
PictureScroll class, 70–72 
PictureScrollField class, 69–73 
PIM (Personal Information 
Management), 125 
PNG optimizer, 52 

Index 
265 
PopupScreen class, 110, 147 
Position Determining Entity (PDE), 203 
POST method, 176, 187–191 
postData variable, 188 
postDataField, 188–189 
pricing 
App World application store, 236 
MobiHand application store,  
246–247 
priority, 64–65 
Product feature image, 237 
Product icon, 237 
Product screenshots, 237 
products 
details of, on App World application 
store, 236 
MobiHand application store, 246 
screenshots of, on App World 
application store, 237 
summary of, on App World 
application store, 238 
profilers, 27 
projects, adding logo images to, 52 
propertyName parameter, 240 
providerStateChanged method, 212 
Publish Data button, 166 
Publisher class, 159, 163–164 
PublisherScreen class, 159, 163–165 
PurchaseArgumentsBuilder, 243 
purchases, in-app, 241–244 
calling API, 243–244 
setting up, 242 
pushScreen, 128, 136, 142, 148, 152, 
159 
■Q 
QualifiedCoordinates class, 205–206, 
210 
QWERTY keyboards, 12 
■R 
RAD (rapid application development), 1 
readTableData function, 155–156 
Record Management System (RMS), 
124 
recordList, 152–153, 155–156 
records, inserting into SQLite database, 
151 
Release Details, 239 
RemoteCommandRegistrarConnection, 
66 
requestBackground( ) method, 43 
requestFailed, 180–182, 184, 197 
requests 
geocoding, sending, 215–216 
handling successful, 185–186 
and responses, 176 
requestSucceeded method, 179–181, 
185, 188–189, 197 
res folder, 17 
res/img/ folder, 32 
resources, 249–251 
blogs, 250–251 
conferences, 250 
forums, 250 
newsletters, 250–251 
for OpenGL, 250 
response code, 176, 180–181, 184, 190 
response failed notifications, displaying, 
182 
responses, requests and, 176 
reusable Command class, 66–67 
reverse geocoding, 214–216 
RichTextField, 178, 185–186 
RIM_APP_WORLD_EMAIL, 241 
RIM_APP_WORLD_ID, 241 
RIM_APP_WORLD_LICENSE_KEY, 241 
RIM_APP_WORLD_NAME, 241 
RIM_APP_WORLD_PIN, 241 
RIM_APP_WORLD_UPDATE_AVAIL, 
241 
RIM_APP_WORLD_VERSON, 241 
Ritz, Anthony, 250 
RMS (Record Management System), 
124 
run( ) method, 180–181, 208–209, 214, 
217, 221 
Runnable interface, 120–121 
Runtime Store, 124 

Index 
266 
■ S 
Save/Discard/Cancel prompt, 130 
save method, 130–131 
scale down, 144 
scaleInto method, 73 
scaling, images, 144–145 
Screen class, 22, 54, 113 
screen classes, main, 20–22 
Screen/Keyboard option, 77 
Screen.close( ) method, 43 
Screen.DEFAULT_CLOSE style,  
111–112 
screens, 109–114 
adding fields to, 112–113 
adding logo images to, 52–54 
defining new, 62–64 
delegate managers, 110 
display, 141 
drawing to using Graphics class,  
79–81 
how screen is drawn, 80–81 
paint method, 79–80 
file name, 147 
implementing sublayout method of, 
110–112 
limited real estate, 12 
main, adding TCP socket connection 
support to, 198–199 
painting background, 113–114 
touch, 117–119 
Screens type, 50 
screenshots, of products, 237 
ScrollEntry, 70–71 
SD card, 123, 125, 140–141, 154, 157 
SDCard/BlackBerry/pictures folder, 149 
SDK (software development kit), 1 
SeachableDataObject, 158 
SearchableCustomer class, 160–164, 
166 
SearchableDataObject class, 158,  
160–161 
searchFieldCriteriaList variable,  
160–162 
secure connections, 190 
selling features, of MobiHand 
application store for, 247 
ServerExchangeCallback, 215–216 
service book, 174 
Service Level Agreement (SLA), 3 
setContents, 126–127, 130, 133 
setFont method, 78, 108, 112 
setGlobalAlpha method, 94 
setMargin method, 116 
setPadding method, 116 
setPosition, 111, 120 
setPositionChild, 101–103, 105–106 
setPositionDelegate, 111 
setPreferredSize method, 222 
short-range communication, 173 
sibling COD files, 227 
signing, applications, packaging and, 
29–30 
sigtool.csk file, 11 
sigtool.db file, 11 
sigtool.set file, 11 
SimpleDateFormat, 212–213 
simulators 
clearing persistent data from, 134 
downloading additional, 7 
getting images into, 142–144 
MDS, 182–183 
running, 22–25 
Single Key model, 234 
SLA (Service Level Agreement), 3 
SocketConnection, 175, 196–197 
software development kit (SDK), 1 
software, installation of, 7–8 
SQL database, 125 
SQLite database, 150, 167 
overview, 125 
persisting data with, 150–157 
creating database and table, 
150–151 
inserting records, 151 
querying tables, 151 
sample application, 151–157 
src folder, 17 
Standalone GPS mode, 206 
Standard folder, 231 
Statement class, 151 
Static model, 234 
storing data, 123 

Index 
267 
String object, 37, 215 
string parameter, 138 
style flags, field, 54 
sublayout method 
implementing, 101–104 
of screen, implementing, 110–112 
submission process, App World 
application store, 236–240 
description, 237 
distribution, 238 
listing application, 236 
product details, 236 
product screenshots, 237 
product summary, 238 
submitting app for approval, 240 
uploading binary files, 238–240 
Superclass, 18–20 
super.paint method, 115 
System.exit( ) method, 38 
■ T 
tables 
creating SQLite database and, 150–
151 
querying, 151 
TCP (Transmission Control Protocol) 
connections, 196–199 
adding support for to main screen, 
198–199 
direct, 171, 192–194 
simple application using, 196–198 
Test Web application, 177 
testing, Networking application,  
182–187 
handling successful requests,  
185–186 
MDS simulator, 182–183 
text widths, specifying, 87–90 
threads 
event, 38–41 
invoking, 38 
knowing when application is on, 
39 
threading and, 39–41 
updating UI from other threads, 
39–41 
updating UI from, 39–41 
titles, setting in application descriptor, 
31 
TLS certificate, 190 
TODO markers, 20 
toFP method, 144 
toString method, 55 
touch screen models, 117–119 
touchEvent method, 72 
TransitionContext class, 122 
Transmission Control Protocol 
connections. See TCP 
try & buy apps, license keys for, 235 
■ U 
Ui class, 78 
UI control, 22 
UiAction variable, 160–162, 166 
UiApp type, 19 
UiApplication.activate, 42 
UiApplication.deactivate method, 42 
UiApplication.getEventLock( ) method, 
39 
UiApplication.invokeAndWait, 39 
UiApplication.invokeLater, 182 
UiApplication.pushModalScreen, 148 
UiFun application, 49–51, 57, 69, 75–77, 
79, 119 
UiFunApplication class, 51, 63 
UiFun.cod file, 227–230 
UiFunMainScreen class, 51–52, 55,  
57–58, 61, 63, 66–67, 121 
UiFunMainScreen constructor, 77–78, 
86, 89, 94, 104, 108, 111, 114, 
121 
UiFunMainScreen.login method, 108 
UIs (User Interfaces) 
animation, 119–122 
of layout, 120 
setting vertical offset, 119–120 
components of, 50–59 
fields, 55–59 
logo image, 52–54 

Index 
268 
UiFun application, 51 
customizing 
fields, 82–97 
label, 87–90 
managers, 97–109 
screens, 109–114 
displaying images, 69–74 
drawing to screen using Graphics 
class, 79–81 
how screen is drawn, 80–81 
paint method, 79–80 
embedding Blackberry Maps in with 
MapField class, 221–223 
fonts, 77–79 
handling user interaction, 59–64 
Clear button, 60–61 
Login button, 62–64 
UI events, 59–60 
header background, 114–115 
and BackgroundFactory class, 
115 
subclassing 
HorizontalFieldManager class, 
115 
indenting labels, 116 
menus, 64–69 
Persistent Store, modifying, 132 
touch screen models, 117–119 
UiFun application, 49–50, 75–76 
updating from other threads, 39–41 
Unassisted GPS mode, 204 
Unified Search facility, integrating 
applications with, 157–167 
UnifiedSearch, 158–159, 166 
UnifiedSearchApp class, 159 
uploading 
applications, 229 
binary files, to App World application 
store, 238–240 
USE_ALL_WIDTH, 89, 108, 115 
User-Generated Safeguards, 239 
user input, 12 
user interaction, handling, 59–64 
Clear button, 60–61 
Login button, 62–64 
UI events, 59–60 
User Interfaces. See UIs 
username fields, and password field, 55 
userNameField, 97 
■ V 
vertical offsets, setting, 119–120 
VerticalFieldManager, 22, 110–112 
verticalOffset, 119–120 
views 
displaying custom map, 220–221 
launching default, 217–218 
virtual machine (VM), 11 
VM (virtual machine), 11 
■ W 
WAP (Wireless Application Protocol) 
1.0, 173 
WAP (Wireless Application Protocol) 
2.0, 172, 192–193 
Wi-Fi connections, direct TCP/IP 
connection using, 194 
Wi-Fi networking, 172 
width parameter, 83 
Wireless Application Protocol (WAP) 
1.0, 173 
Wireless Application Protocol (WAP) 
2.0, 172, 192–193 
WLAN mode, 203 
WLANInfo class, 195 
WLANInfo.WLAN_STATE_CONNECTED
, 195 
workspaces, 15–17, 19 
■ X, Y 
x parameter, 86 
■ Z 
ZIP file, 227, 238, 243 

 
 
 
i 
Beginning BlackBerry 7 
Development 
 
 
 
 
 
 
■ ■ ■ 
Robert Kao 
Dante Sarigumba 
With Anthony Rizk and Kevin Michaluk 
 

Beginning Blackberry 7 Development 
Copyright © 2011 by Robert Kao and Dante Sarigumba, with Anthony Rizk and Kevin Michaluk 
All rights reserved. No part of this work may be reproduced or transmitted in any form or by any 
means, electronic or mechanical, including photocopying, recording, or by any information 
storage or retrieval system, without the prior written permission of the copyright owner and the 
publisher. 
ISBN-13 (pbk): 978-1-4302-3015-1 
ISBN-13 (electronic): 978-1-4302-3016-8 
Trademarked names, logos, and images may appear in this book. Rather than use a trademark 
symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, 
and images only in an editorial fashion and to the benefit of the trademark owner, with no 
intention of infringement of the trademark. 
The use in this publication of trade names, trademarks, service marks, and similar terms, even if 
they are not identified as such, is not to be taken as an expression of opinion as to whether or not 
they are subject to proprietary rights. 
President and Publisher: Paul Manning 
Lead Editors: Steve Anglin and Tom Welsh 
Technical Reviewer: Bill Foust 
Editorial Board: Steve Anglin, Mark Beckner, Ewan Buckingham, Gary Cornell, Jonathan 
Gennick, Jonathan Hassell, Michelle Lowman, James Markham, Matthew Moodie, Jeff 
Olson, Jeffrey Pepper, Frank Pohlmann, Douglas Pundick, Ben Renow-Clarke, Dominic 
Shakeshaft, Matt Wade, Tom Welsh 
Coordinating Editor: Kelly Moritz  
Copy Editors: Damon Larson and Mary Behr 
Compositor: MacPS, LLC 
Indexer: BIM Indexing & Proofreading Services 
Artist: SPi Global 
Cover Designer: Anna Ishchenko 
Distributed to the book trade worldwide by Springer Science+Business Media, LLC., 233 Spring 
Street, 6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax (201) 348-4505, e-mail 
orders-ny@springer-sbm.com, or visit www.springeronline.com.  
For information on translations, please e-mail rights@apress.com, or visit www.apress.com.  
Apress and friends of ED books may be purchased in bulk for academic, corporate, or 
promotional use. eBook versions and licenses are also available for most titles. For more 
information, reference our Special Bulk Sales–eBook Licensing web page at 
www.apress.com/bulk-sales. 
The information in this book is distributed on an “as is” basis, without warranty. Although every 
precaution has been taken in the preparation of this work, neither the author(s) nor Apress shall 
have any liability to any person or entity with respect to any loss or damage caused or alleged to 
be caused directly or indirectly by the information contained in this work.  
The source code for this book is available to readers at www.apress.com. 

I want to thank my mother and father, and the rest of the Kao family for all that 
they have done for me. I also want to thank my wife, Marie-Claude, for her 
support and understanding during the development of this book. In addition, I 
want to thank my kids, Jade and Logan, for giving me quiet time during the 
development of this book. Lastly, I want to thank Manon and the rest of the 
Gamelin family for their unrelenting support. 
—Robert Kao 
 
As always, this book is for Yosma, Dean, and Drew: my greatest treasures. Thank 
you for your thoughts, understanding, and support. 
—Dante Sarigumba 

v 
 
Contents 
Contents at a Glance .......................................................................................... iv
About the Authors ............................................................................................... x
About the Technical Reviewer ........................................................................... xi
Acknowledgments ............................................................................................ xii
 
■Chapter 1: Setting the Stage ............................................................................ 1
What This Book Is ................................................................................................................................................... 1
What You Need to Know Before You Can Begin ...................................................................................................... 2
Setting Up Your Development Environment ............................................................................................................ 2
Installing the Development Environment ........................................................................................................... 3
Getting Code Signing Keys ................................................................................................................................. 8
What’s Different About Developing for BlackBerry ............................................................................................... 11
Limited CPU and Memory ................................................................................................................................ 11
Java As the Native API ..................................................................................................................................... 11
Limited Screen Real Estate .............................................................................................................................. 12
User Input ........................................................................................................................................................ 12
Many Different Devices .................................................................................................................................... 12
What’s in This Book .............................................................................................................................................. 12
Chapter 2 ......................................................................................................................................................... 12
Chapter 3 ......................................................................................................................................................... 13
Chapter 4 ......................................................................................................................................................... 13
Chapter 5 ......................................................................................................................................................... 13
Chapter 6 ......................................................................................................................................................... 13
Chapter 7 ......................................................................................................................................................... 13
Chapter 8 ......................................................................................................................................................... 13
Chapter 9 ......................................................................................................................................................... 13
Chapter 10 ....................................................................................................................................................... 14
Summary .............................................................................................................................................................. 14
■Chapter 2: Hello World ................................................................................... 15
Creating an Application with the BlackBerry JDE Plug-In for Eclipse ................................................................... 15
Creating the Project ......................................................................................................................................... 16
Creating the Application Classes ..................................................................................................................... 18
Basic GUI Fields Explained ............................................................................................................................... 22

■ CONTENTS 
 
 
vi 
Running the Simulator ..................................................................................................................................... 22
Building with Different JDE Versions ............................................................................................................... 28
Packaging and Signing Your Application ......................................................................................................... 29
Debugging on a Device .................................................................................................................................... 30
Polishing the Application ...................................................................................................................................... 31
Setting the Title in the BlackBerry Application Descriptor ............................................................................... 31
Creating an Icon ............................................................................................................................................... 32
Seeing It All in Action ............................................................................................................................................ 33
Summary .............................................................................................................................................................. 33
■Chapter 3: What Makes a BlackBerry Application? ....................................... 35
Javadocs ............................................................................................................................................................... 35
The BlackBerry Application Life Cycle .................................................................................................................. 37
Starting the Application ................................................................................................................................... 37
Creating the Application .................................................................................................................................. 37
Invoking the Event Thread ............................................................................................................................... 38
Processing Events ............................................................................................................................................ 38
Exiting the Application ..................................................................................................................................... 38
Threading and the Event Thread ........................................................................................................................... 38
Knowing When Your Application Is on the Event Thread ................................................................................. 39
Updating the UI from Other Threads ................................................................................................................ 39
Running Background Applications ........................................................................................................................ 42
Detecting Backgrounding or Foregrounding .................................................................................................... 42
Sending Your Application to the Background .................................................................................................. 43
Understanding the Types of Projects .................................................................................................................... 44
Libraries ........................................................................................................................................................... 44
Creating an Alternate Entry Point ..................................................................................................................... 46
MIDP and MIDlet Projects ................................................................................................................................ 48
Summary .............................................................................................................................................................. 48
■Chapter 4: User Interface Basics ................................................................... 49
The UI Fun Application .......................................................................................................................................... 49
The Components of a BlackBerry UI ..................................................................................................................... 50
Creating the Application .................................................................................................................................. 51
Adding the Logo Image .................................................................................................................................... 52
Adding a Few More Fields ............................................................................................................................... 55
Handling User Interaction ..................................................................................................................................... 59
Handling UI Events ........................................................................................................................................... 59
Handling the Clear Button ................................................................................................................................ 60
Handling the Login Button ............................................................................................................................... 62
Creating Menus ..................................................................................................................................................... 64
Understanding Menu Items .............................................................................................................................. 64
Implementing the Login and Clear Menu Items ............................................................................................... 65
Displaying Images ................................................................................................................................................. 69
Summary .............................................................................................................................................................. 73
■Chapter 5: Beyond the Basics of User Interfaces .......................................... 75
Enhancing the UI Fun Application ......................................................................................................................... 75
Working with Fonts ............................................................................................................................................... 77
Drawing to the Screen Using the Graphics Context .............................................................................................. 79

■ CONTENTS 
 
 
vii 
Using the Paint Method .................................................................................................................................... 79
Understanding How the BlackBerry Screen Is Drawn ...................................................................................... 80
Creating Custom Fields ......................................................................................................................................... 82
Adding a Custom Label Field ........................................................................................................................... 82
Creating a Custom Button Field ....................................................................................................................... 90
A Review of Custom Fields .............................................................................................................................. 97
Creating Custom Managers .................................................................................................................................. 97
Creating a Manager ....................................................................................................................................... 100
Tidying Up the Login Success Screen ............................................................................................................ 107
Creating a Custom Screen .................................................................................................................................. 109
Delegate Managers ........................................................................................................................................ 110
Implementing the Screen’s Sublayout Method .............................................................................................. 110
Adding a Few Fields ....................................................................................................................................... 112
Painting the Background ................................................................................................................................ 113
Adding the Final Touches .................................................................................................................................... 114
Adding a Header Background ........................................................................................................................ 114
Making Minor Tweaks .................................................................................................................................... 116
Working with Touch Screen Models ................................................................................................................... 117
Creating Basic Animation .................................................................................................................................... 119
Setting the Vertical Offset .............................................................................................................................. 119
Animating the Layout ..................................................................................................................................... 120
Summary ............................................................................................................................................................ 122
■Chapter 6: Storing and Searching Data ....................................................... 123
Storing Data on the BlackBerry ........................................................................................................................... 123
Choices for Persistence ...................................................................................................................................... 124
RMS ............................................................................................................................................................... 124
Persistent Store ............................................................................................................................................. 124
Runtime Store ................................................................................................................................................ 124
JSR 75 FileConnection ................................................................................................................................... 125
SQLite ............................................................................................................................................................ 125
BlackBerry Persistent Store ................................................................................................................................ 125
Persistent Store Keys ..................................................................................................................................... 126
Persistent Objects .......................................................................................................................................... 126
What Can You Persist? ................................................................................................................................... 127
The Persistable Application ........................................................................................................................... 128
More Advanced Persistence .......................................................................................................................... 132
Clearing Persistent Data from a Device ......................................................................................................... 135
The FileConnection API ....................................................................................................................................... 136
Basic Application Framework ........................................................................................................................ 136
Opening a File Connection ............................................................................................................................. 138
Listing the Directory Contents ....................................................................................................................... 139
Viewing Pictures ............................................................................................................................................ 141
The Image Display Screen ............................................................................................................................. 141
Loading Images from the File System ........................................................................................................... 142
Getting Images into the Simulator ................................................................................................................. 142
Scaling the Image .......................................................................................................................................... 144
Writing to the File System ................................................................................................................................... 145
A Dynamic Menu Item .................................................................................................................................... 146

■ CONTENTS 
viii 
The File Name Screen . .................................................................................................................................... 147
Copying the File ............................................................................................................................................... 148
Using SQLite .......................................................................................................................................................... 150
Creating a Database and a Table . ................................................................................................................... 150
Inserting Records ............................................................................................................................................. 151
Querying Tables ............................................................................................................................................... 151
SQLite Sample Application . ............................................................................................................................. 151
Integrating Your App with Unified Search ............................................................................................................ 157
Summary .............................................................................................................................................................. 167
■Chapter 7: Hello Out There! Making a Network-Enabled Application .......... 169
Different Ways to Connect . .................................................................................................................................. 169
BES/MDS .......................................................................................................................................................... 170
Direct TCP/IP .................................................................................................................................................... 171
BIS .................................................................................................................................................................... 172
Wi-Fi ................................................................................................................................................................ 172
WAP 2.0 ........................................................................................................................................................... 172
WAP 1.0 ........................................................................................................................................................... 173
Short-Range Communication . ......................................................................................................................... 173
Recommendation ............................................................................................................................................. 173
Service Book ......................................................................................................................................................... 174
The MIDP Connection Framework . ....................................................................................................................... 175
Connector ......................................................................................................................................................... 175
Connections ..................................................................................................................................................... 175
HTTP Basics ..................................................................................................................................................... 176
The Test Web Application . .............................................................................................................................. 177
The Networking Application . ................................................................................................................................ 177
Some Controls .................................................................................................................................................. 178
Making an HTTP Connection . .......................................................................................................................... 179
The HttpRequestDispatcher Class ................................................................................................................... 179
Testing It .......................................................................................................................................................... 182
Two-Way Interaction: Sending Data via HTTP POST ....................................................................................... 187
Connection Method: Using Direct TCP/IP Instead of BES/MDS ............................................................................ 192
Making a Connection Using WAP 2.0 .............................................................................................................. 192
Making a Connection Using BIS . ..................................................................................................................... 193
Making a Wi-Fi Connection . ............................................................................................................................ 194
Determining Network Availability . ....................................................................................................................... 194
Using CoverageInfo .......................................................................................................................................... 194
Using WLANInfo ............................................................................................................................................... 195
Putting It All Together . .................................................................................................................................... 195
TCP Socket Connections . ..................................................................................................................................... 196
Summary .............................................................................................................................................................. 198
■Chapter 8: Where Am I? Using Location-Based Services ............................ 201
GPS Support on BlackBerry Devices .................................................................................................................... 201
Getting Location Information . .............................................................................................................................. 202
Getting Location Information Using JSR 179 APIs and the BlackBerry Extensions to JSR 179 .......................... 202
GPS Modes ....................................................................................................................................................... 203
Specifying a GPS Mode Using JSR 179 ........................................................................................................... 204

■ CONTENTS 
 
 
ix 
Specifying a GPS Mode Using the BlackBerry Extensions to JSR 179 ........................................................... 205
The Location Application ..................................................................................................................................... 207
Getting Periodic Location Updates Using LocationListener ........................................................................... 211
Using Geocoding and Reverse Geocoding .......................................................................................................... 214
Geocoding: Getting Coordinates from an Address ......................................................................................... 215
Using BlackBerry Maps ....................................................................................................................................... 216
The Invoke API ............................................................................................................................................... 216
Launching the Default BlackBerry Maps View ............................................................................................... 217
Location Documents ...................................................................................................................................... 218
Displaying a Custom Map View ...................................................................................................................... 220
MapField: Embedding BlackBerry Maps in Your UI ........................................................................................ 221
Summary ............................................................................................................................................................ 223
■Chapter 9: Getting Your App Out There: Packaging and Publishing ............ 225
Setting Application Properties ............................................................................................................................ 226
Over-the-Air Installation ..................................................................................................................................... 226
Sibling COD Files ............................................................................................................................................ 227
The JAD File ................................................................................................................................................... 228
Content Types (MIME Types) .......................................................................................................................... 228
Uploading Your Application ............................................................................................................................ 229
Downloading the Application ......................................................................................................................... 229
Desktop Installation ............................................................................................................................................ 230
The ALX File ................................................................................................................................................... 230
BlackBerry App World ......................................................................................................................................... 232
Getting an App World Account ....................................................................................................................... 233
Distributing Your Application on App World ................................................................................................... 234
Implementing License Keys ........................................................................................................................... 235
Pricing ............................................................................................................................................................ 236
The Submission Process ................................................................................................................................ 236
App World API ................................................................................................................................................ 240
In-App Purchase ............................................................................................................................................ 241
Other Application Stores ..................................................................................................................................... 244
MobiHand ....................................................................................................................................................... 244
Other Sites ..................................................................................................................................................... 247
Summary ............................................................................................................................................................ 247
■Chapter 10: Next Steps ................................................................................ 249
Keeping Current .................................................................................................................................................. 249
Forums ........................................................................................................................................................... 250
BlackBerry Conferences ................................................................................................................................ 250
OpenGL on the BlackBerry ............................................................................................................................. 250
Newsletters, Blogs, and Other Resources ..................................................................................................... 250 
Farewell ......................................................................................................................................................... 251
Index ............................................................................................................... 253 
 

x 
 
About the Authors 
Robert Kao is one well-rounded, experienced mobile architect and 
professional. His ability to translate his technical knowledge and communicate 
with users of all types led him to cowrite BlackBerry For Dummies (For 
Dummies, 2011). He started out as a BlackBerry developer for various financial 
firms in New York City. Robert is the founder and current CEO of SmrtGuard, a 
mobile security start-up. A graduate of Columbia University with a computer 
engineering degree, he currently lives in South Brunswick, New Jersey. 
 
 
 
Dante Sarigumba is a veteran software developer and coauthor of several 
BlackBerry-related For Dummies books. He has been developing mobile 
applications since 2003, starting with a BlackBerry application. His mobile 
applications are used by major investment banks and hedge funds in New York 
City. Dante lives in South Brunswick, New Jersey, with mobile developer 
Rosemarie and their two children, Dean and Drew. 

xi 
 
About the Technical Reviewer 
Bill Foust is an established professional in the mobile industry with over 10 years of experience. 
Bill has been involved with BlackBerry devices from their humble beginnings as a ‘pager’ style-
messaging device. Over the years, he has been a consultant, author, blogger and podcaster on 
BlackBerry and the wireless industry in general. 
Bill is currently working on developing mobile applications for BlackBerry and other mobile 
platforms for Sprint-Nextel corporation in Kansas City. 
 

xii 
 
Acknowledgments 
Collectively, we want to thank Steve Anglin for giving us the opportunity to work on this title. 
Thanks to Kelly Moritz, Tom Welsh, and the other members of the Apress team for making us 
look good. And to Bill Foust, our technical reviewer, who painstakingly followed and corrected 
our code, and provided ideas to make the code better. Finally, thanks to Kevin Michaluk (aka 
CrackBerry Kevin) for always keeping on the lookout and giving us new information and 
opportunities. 
 
—Robert and Dante 
 

