Аппликативный компьютинг: попытки установить природу
вычислений⋆
Вольфенгаген В.Э.
Аннотация На ранних стадиях программирование представляло собой вид искусства, когда программист писал
программу для решения определенной задачи и сопровождал ее более или менее подробно составленной докумен-
тацией, то теперь создана мощная индустрия программирования с сопутствующей ей инженерией программиро-
вания. В настоящее время в исследованиях по программированию или в сфере компьютерных наук, как правило,
поддерживаются работы, в которых вносится некоторое небольшое улучшение в решение уже хорошо известной
проблемы. Вместе с тем из виду упускаются действительно важные и фундаментальные исследования, ведущие к
поиску новых концепций вычислений на компьютере и недостаточное внимание уделяется накоплению знаний в
области программирования.
В настоящей работе основное внимание уделено вычислениям с объектами, удельный вес и роль которых в данной
области все более возрастает, превращаясь в доминирующую тенденцию.
Об авторе. Вольфенгаген В. Э., д.т.н., профессор (vew@jmsuice.msk.ru). Заведующий
кафедрой перспективных компьютерных исследований и информационных технологий
(ПКИ и ИТ) в Институте «ЮрИнфоР-МГУ». Область его научных интересов состав-
ляют компьютерные науки и информационные технологии, включая аппликативные вы-
числительные системы, λ-исчисление, комбинаторную логику, системы типов. Проекты
РФФИ 93-01-00943-а (ЛАМБДА), 96-01-01923-а (КООАМ), 05-01-00736-а.
1
Аппликативный компьютинг
Для компьютинга центральным вопросом является установление того, что и как может быть эф-
фективно автоматизировано. Это нередко связывают в применением компьютеров, осуществля-
ющих те или иные вычисления. Термин “вычисление” предполагает, что речь пойдет об исполь-
зовании чисел, об оперировании числами, получении числовых результатов.
В случае же аппликативных систем примен ´им термин “компьютинг”, поскольку в них сре-
ди исходных понятий нет чисел. Для них самое общее толкование компьютинга, по-видимому,
все еще работает, хотя в этом и нет абсолютной уверенности. Выражаясь более точно, с появ-
лением аппликативных систем вопрос о границах представления о компьютинге требует нового
изучения. Как оказывается, причин тому имеется несколько.
Если все же соглашаемся говорить о вычислениях, то нужно отдавать себе отчет в том, что
аппликативное вычисление не похоже на обычное. Оно выполняется на переплетении цепочек
возможных путей вычислений, которые представляют собой связи конвертируемости, отража-
ющие трансформации объектов. При этом одни объекты могут редуцироваться к другим, либо
подвергаться экспансии до других объектов.
Рассматриваемые объекты не похожи на те сущности, которыми оперируют в объектно-
ориентированном подходе (см. [4]). В процессе конверсии участвует пара объектов, первый из
которых играет роль редекса, а второй – контракта. Процесс конверсии является двунаправ-
ленным, представляя собой редукцию в одном направлении и экспансию в другом. Таким об-
разом, пара объектов ‘редекс-контракт’ участвует в процессе ‘редукции-экспансии’, обеспечи-
вающем взаимные переходы между редексами и соответствующими им контрактами. Комплек-
сирование редекс-контракт подчиняется законам аппликативных вычислений.
Объекты, участвующие в вычислении, не обязательно находятся в нормальной форме. Они
могут иметь вид редекса, который может быть заменен на соответствующий контракт, т.е. участ-
вовать в процессе редукции. В то же время каждый контракт может быть заменен на его редекс,
⋆Настоящая работа поддержана Российским Фондом Фундаментальных Исследований, проект 06-07-99005-с

2
Вольфенгаген В.Э., Аппликативный компьютинг: попытки установить природу вычислений
участвуя в процессе экспансии. Представлением для этих объектов может быть сам двунаправ-
ленный процесс редукции-экспансии, причем равновесие этого процесса при необходимости мо-
жет быть смещено в ту или иную сторону. Таким образом, для этих объектов, участвующих в про-
цессе конверсии, имеются представления сущностями об-систем, а последние обладают необ-
ходимыми математическим свойствами.
Шаг “вычисления” состоит в следующем. Выбирается пара объектов, один из которых опре-
деляется как соответствующий виртуальной функции, порожденной процессом конверсии, а вто-
рой – как соответствующий виртуальному аргументу, который также порожден конвертировани-
ем. Затем первый объект апплицируется, или применяется к другому. Результат апплицирования
рассматривается как представляющий значение, полученное на шаге вычисления. В результате
этого процесса возникают пары объектов, первым в которых является ‘аппликация’, а вторым –
‘результат апплицирования’, то есть это пары аппликация-означивание.
Цепочки конверсий, в которых участвуют компонентные объекты, сплетаются. Вычисления,
в общем случае, могут оказаться бесконечными и никогда не завершаться. В этом случае ответ
на вопрос о получении значения оказывается непростым.
В этой общей ситуации лучшим терминологическим решением будет говорить об ‘апплици-
ровании’ вместо ‘вычисления’, а когда речь заходит о результате апплицирования, то есть о ‘зна-
чении вычисления’, то здесь можно воспользоваться термином ‘означивание’. Пара ‘апплициро-
вание-означивание’ точнее отражает суть процессов, происходящих в аппликативных системах.
2
Осуществление аппликативного компьютинга
Обсуждение осуществления компьютинга можно вести двояких образом. Во-первых, можно
исходить от обычного компьютера, основанного на арифметике, а тогда отправным пунктом яв-
ляется система вычислений, в которой можно реализовать погружение аппликативной вычисли-
тельной системы. Во-вторых, располагая системой аппликативного компьютинга, в ней можно
сформировать погруженную, или встроенную числовую систему, скажем, арифметику, для кото-
рой напрямую и подходит термин ‘вычисление’.
Обычные системы вычислений Многие из этих систем вычислений уже осуществлены, а их
возможности в большей или меньшей степени освоены на практике, другие находятся в ста-
дии разработки. Для них характерно то, что они находятся в процессе постоянных доработок и
усовершенствований, в погоне за дополнительными возможностями. В ряде систем возникает
переизбыток возможностей, освоить которые на практике за разумный период времени не пред-
ставляется возможным.
В результате обычные системы вычислений и соответствующие им языки программирования
постоянно разрастаются в объеме, но их выразительные возможности при этом не изменяются.
В их основе лежат модели не только далекие от совершенства, но содержащие изъяны, а попыт-
ки их преодоления дают нагромождение деталей, усложняя восприятие вычислительных идей,
затрудняя реализацию и снижая ее эффективность. Наиболее распространенный стиль вычис-
лений состоит в обработке одного слова в данный момент, разворачивание последовательности
моментов приводит к последовательной обработке “слово за словом”. Семантика таких вычис-
лений опирается на переходы состояний, что приводит к разделению вычисляемых конструкций
на два класса: выражения и команды, или операторы. Это само по себе не дает возможности
развивать мощные приемы комбинирования имеющихся “вычислительных блоков” для форми-
рования из них более крупных новых блоков. Кроме того, обычные системы вычислений осно-
вываются на достаточно сложной и запутанной математической основе, которой не только недо-
стает концептуальной ясности (см. J. Backus, [1]), но и относительно которой никак не возникает
согласия в среде специалистов. Их разногласия выражаются в многочисленных публикациях

Сборник научно-популярных статей – победителей конкурса РФФИ 2006 года. Выпуск 10. – Под ред. чл.-корр. РАН В. И. Конова. – М.: Октопус·Природа, 2007. – с. 445-459.
3
в виде статей, написанных специальным языком, доступным немногим посвященным, а это со
стороны пользователей не добавляет доверия к предлагаемым новым сериям математических и
технических ухищрений.
Системы аппликативного компьютинга Некоторые из аппликативных систем осуществлены,
но не в полном объеме. При их разработке и применении накоплен известный опыт, но он явно
недостаточен, а принципиальные для аппликативных вычислений механизмы так и не удалось
реализовать в полной мере и без урезаний и излишних упрощающих ограничений.
Аппликативный компьютинг предполагают комбинационное построение вычисления как от-
носительно самостоятельного ‘блока’, пользуясь уже имеющимися ‘блоками’ вычислений. Тра-
диционно в состав аппликативных вычислительных систем, или, сокращенно, АВС, включа-
ют системы исчислений объектов, основанные на комбинаторной логике и ламбда-исчислении.
Единственное, что существенно разрабатывается в этих системах – это представление об объ-
екте. В комбинаторной логике единственный метаоператор – аппликация, или, по иной тер-
минологии, приложение одного объекта к другому. В ламбда-исчислении два метаоператора –
аппликация и функциональная абстракция, позволяющая связывать одну переменную в од-
ном объекте.
Возникающие в этих системах объекты ведут себя как функциональные сущности, имеющие
следующие особенности:
число аргументных мест, или арность объекта заранее не фиксируется, но проявляет себя по-
степенно, во взаимодействиях с другими объектами;
при конструировании составного объекта один из исходных объектов – функция, – применя-
ется к другому объекту – аргументу, – причем в других контекстах они могут поменяться
ролями, то есть функции и аргументы рассматриваются как объекты на равных правах;
разрешается самоприменимость функций, то есть объект может применяться сам к себе.
Вычислительные системы с таким наиболее общими и наименее ограничительными свойствами
оказываются в центре внимания современного сообщества computer science. Именно они в на-
стоящее время обеспечивают необходимые метатеоретические средства, позволяя исследовать
свойства целевых прикладных теорий, дают основу построения семантических средств языков
программирования и обеспечивают средства построения моделей данных/метаданных в инфор-
мационных системах.
Аппликативные системы программирования Представление об аппликативной вычислитель-
ной системе поддерживается аппликативными системами программирования, которые образуют
алгебры программ. В них переменные замещаются ‘программами’, а операции комбинируют одни
программы с другими. В этой алгебре решаются уравнения, в которых неизвестными являются
программы, а сам процесс решения конструктивно ведет к ‘синтезу’ требуемой программы как
вычисления с заданными свойствами – ‘комбинаторными характеристиками’. Комбинаторные,
или комбинационные формы оказываются простыми по своей структуре и вместе с тем облада-
ют высокими выразительными возможностями. Теорема о комбинаторной полноте и некоторые
другие фундаментальные теоремы, характеризующие законы аппликативных вычислений, зада-
ют детали поведения и условия выполнения и завершения для целых классов программ. Семан-
тика аппликативных вычислений слабо связана с состояниями, на относительно большой объем
вычислений приходится небольшое число ‘изменений состояний’, что характеризует их как не
фон Нейманновские вычисления.

4
Вольфенгаген В.Э., Аппликативный компьютинг: попытки установить природу вычислений
3
Об-системы
В ходе производимого вычисления “аппликативный вычислитель” оперируется цепочками воз-
можных конверсий, меняя местами элементарные “частицы” вычислений – обы. Обы существу-
ют не сами по себе, но наделены специальной структурой, образуя индуктивный класс. Таким
образом, обы имеют разную сложность. Построение их индуктивного класса начинается с ниж-
него уровня, на котором находятся элементарные, или атомарные обы – константы и перемен-
ные. Из них посредством применения правил образования строятся более сложные агрегации,
которые тоже являются обами, но не элементарными.
Бестиповые вычисления Вычислительная среда комбинаторной логики (см. [10]) является вы-
соко симметричной в том смысле, что если взять два оба M и N, то можно говорить о резуль-
тате вычисления, когда M применяется, или апплицируется к N, что записывается посредством
(M N). В этой записи M играет роль левого объекта, а N – правого. Такой об (M N) бинарен
по своей природе, по построению, а индуктивные классы обов могут быть топологически пред-
ставлены бинарными деревьями. В этом вычислении первый об M считается функцией, которая
применяется к N как к аргументу и, применительно к образам обычной математики, речь идет
о формировании значения M “в точке” N. Но если в классической математике поменять ме-
стами M и N, то конструкция ‘N от M’ в понимании ‘значение N в точке M’ лишена смысла.
В аппликативной же системе такое вычисление не только не запрещается, но и имеет вполне
определенный смысл, поскольку с вычислительной точки зрения обы абсолютно одинаковы.
На рис. 1 представлены вычислительные характеристики комбинаторов S и K. Если их за-
Рис. 1. Характеристики комбинаторов S и K.
писать эквационально, с применением равенства, то получится
Sabc = ac(bc),
Kab = a.
На рис. 2 показан процесс “выращивания” дерева вычислений для оператора композиции.
Композиция двух функций a и b определяется равенством
a ◦b(c) = a(b(c)),
что в аппликативной записи превращается в конверсию
a(b(c)) ≡a(bc) = Babc.
В исходной об-системе нет комбинатора B с такими свойствами. Но, как оказывается, такой
комбинатор можно получить. Процесс генерации состоит в следующем.
Построим дерево вычислений, ассоциированное с композицией (дерево 1). Результирующее
дерево вычислений показано в позиции 7. Если бы оно существовало в об-системе, то переход к

Сборник научно-популярных статей – победителей конкурса РФФИ 2006 года. Выпуск 10. – Под ред. чл.-корр. РАН В. И. Конова. – М.: Октопус·Природа, 2007. – с. 445-459.
5
Рис. 2. Характеристика комбинатора композиции B и выращивание дерева вычислений для B,
пользуясь деревьями для комбинаторов S и K. { Пояснение. Переход от композиции a◦b (дерево 1) к представ-
ляющему комбинатору B (дерево 7) получается при обходе против часовой стрелки. Для этого потребуется шесть шагов, если
имеются только деревья вычислений для S и K. }
нему можно выполнить против часовой стрелки. Посмотрим, можно ли сформировать виртуаль-
ную композицию, указав соответствующее дерево вычислений, которое строится комбинирова-
нием уже известных деревьев вычислений. Это дерево можно вырастить поэтапно, переходя от
дерева к дереву по часовой стрелке. Переход 1-2 представляет собой просто применение опре-
деления композиции. Переход 2-3 соответствует конверсии
a(bc) = Kac(bc),
он – осуществим в соответствии с вычислительной, или комбинаторной характеристикой ком-
бинатора K. Переход 3-4 соответствует конверсии
Kac(bc) = S(Ka)bc.
Аналогично, переходы 4-5 и 5-6 соответствуют конверсиям
S(Ka)bc = KSa(Ka)bc,
KSa(Ka)bc = S(KS)Kabc.
Но об S(KS)Kabc, расположенный последним в цепочке из виртуальных обов, соответствует
дереву вычислений с “каноническим” последовательным расположением обов a, b и c вдоль вет-
вей (показаны на рисунке одинарной линий). Вместе с тем виртуальный об S(KS)K оказался
в “вершине” кроны дерева вычислений, формируя его “ствол” (показан на рисунке двойной ли-
ний). Другими словами, этот виртуальный об имеет в точности те вычислительные характеристи-
ки, которые требуется от оба B, представляющего композицию (дерево 7). Это завершает обход
контура конверсий по часовой стрелке: путь от оба a(bc) к обу S(KS)K найден.
Таким методом можно строить деревья вычислений и для многих других математических объ-
ектов, предъявляя для них подходящие виртуальные обы и соответствующие их свойствам дере-
вья вычислений.
Т ´иповые вычисления Но в аппликативных системах с типами все не так просто: свойства обов
описываются функцией приписывания типа, которая определяет их возможности как процессов
преобразования. Отметим, что обы являются чистыми процессами преобразования, для кото-
рых не ставится вопрос о существовании области определения и области значения. Эти области

6
Вольфенгаген В.Э., Аппликативный компьютинг: попытки установить природу вычислений
могут быть пустыми, тогда индивиды в них “не обитают”. Со временем индивид может начать
свое существование в одной из областей, находится там в течение определенного периода вре-
мени, а потом исчезнуть, прекратив свое существование. Но это не более, чем удобная словес-
ная интерпретация, попытка привнести смысл в высоко абстрактные вычисления. С позиций же
аппликативной вычислительной системы речь идет просто о применениях одних обов к другим,
а если так проще думать, то области определения и значения можно также идентифицировать
обами.
Все это в точности и означает, что обы являются обитателями функциональных пространств,
образованных системами высших порядков. Например, наиболее вероятно, что на роль функции
в апллицировании одного оба к другому будет взят об из более “высокого” функционального
пространства, чем об, претендующий на роль аргумента.
Пара обов характеризуется метаоператором аппликации (· ·), который с чисто абстрактных
синтаксических позиций эту пару обов преобразует в новый об. Тогда, если два оба меняются
местами, то результирующий об интерпретируется иначе, теперь роль функции отводится второ-
му обу – тому, который в начале играл роль аргумента, – а роль аргумента отводится первому
обу – тому, который в начале играл роль функции. Фактически, при этом все характеристики
обов в об-системе остаются прежними, если обы рассматривать по отдельности. Однако по-
сле перестановки они с другими обами будут взаимодействовать иначе. Отметим, что это новое
взаимодействие проявит себя как встроенная, или погруженная система типов.
Пары обов имеют тот смысл, что первый играет роль функции, а второй выступает в роли ар-
гумента. Интерпретируемая пара имеет смысл, если вычислитель сможет установить ее значе-
ние, будь то действительное, возможное или виртуальное. Для интерпретируемости важно, что-
бы первый об имел более высокий потенциальный тип, чем второй. Изменение потенциального
типа одного из обов может привести к нарушению интерпретируемости и выводимому несоот-
ветствию логическим законам.
Согласно имеющимся на сегодня теория типов не все обы типизируемы. В аппроксимаци-
онных решетках, дающих вычислительную модель бестипового ламбда-исчисления [7], есть и
другая возможность: рассматривать бесконечные типы. При этом справедливым оказывается
изоморфизм между специально построенным представлением типа и отображением этого типа
в самого себя. Тогда с вычислительной точки зрения оправдывается самоприменимость: объ-
ект можно апплицировать к самому себе, что с точки зрения обычной математики недопустимо
и лишено смысла. Сам метод работает в топологических пространствах и позволяет отыскивать
неподвижные точки отображений, что дает практически реализуемую и приемлемую среду для
организации циклических вычислений. Обы в аппликативной вычислительной системе рассмат-
риваются как отображения и, как оказывается, для всякого оба можно отыскать неподвижную
точку: для этого есть систематический способ. Он достаточно прост, сводится к упаковыванию в
пару парадоксального комбинатора Y (см. [9], [10]) и оба, а результат такой упаковки и рассмат-
ривается как абстрактное представление неподвижной точки этого оба, который интерпретиру-
ется как отображение.
Таким образом, обы при перестановке могут привести к несогласованию некоторых из си-
стем типов, но этого может и не произойти. Для того, чтобы рассогласование не происходило,
применяют правила образования и правила преобразования обов, к которых учитываются схе-
мы типов. Удовлетворительными с этой точки зрения вычислительными свойствами обладают
аппроксимационные решетки. Обы в этих топологических структурах при интерпретации прояв-
ляют полезные логические свойства, что немаловажно для семантических применений. В част-
ности, при этом для об-системы строится модель вычислений, обладающая полнотой и непро-
тиворечивостью.

Сборник научно-популярных статей – победителей конкурса РФФИ 2006 года. Выпуск 10. – Под ред. чл.-корр. РАН В. И. Конова. – М.: Октопус·Природа, 2007. – с. 445-459.
7
4
Обы в системе типов
Пары обов, упакованные метаоператором аппликации, существуют в виртуальном мире значе-
ний функций. Особая роль при этом отводится тождественным преобразованиям – единичным
обам. Дело в том, что с вычислительной точки зрения их можно отождествить с преобразуемыми
обами. Тогда обы проявляют заложенную в них вычислительную способность к композирова-
нию, то есть к участию в метаоперации композиции, имеющей обычный математический смысл.
Процессор списков В системе обов имеются специальные исходные обы-комбинаторы, поль-
зуясь которыми можно производить новые обы, в том числе и комбинаторы. Среди комбинато-
ров существует производный об-комбинатор, называемый комбинатором пары. При упаковы-
вании комбинатора пары вместе с двумя обами возникает виртуальный об, проявляющий мате-
матические свойства упорядоченной пары. В этой системе также существует производный об-
комбинатор, называемый композитором. При упаковывании композитора вместе с двумя обами
возникает виртуальный об, проявляющий математические свойства композиции функций. Упо-
рядоченная пара – это пример конечной последовательности длины два. Конечные последова-
тельности большей длины формируются композицией частичной упакованных упорядоченных
пар, когда комбинатор пары упакован только с первым обом, а “подстановочное место” для вто-
рого оба – свободно и ожидает прихода какого-либо оба для своего заполнения. Эти виртуаль-
ные объекты, проявляющие свойства конечных последовательностей, можно оснастить семей-
ством виртуальных обов, проявляющих математические свойства проекций над конечными по-
следовательностями. Такое комбинирование обов порождает виртуальную вычислительную си-
стему, которая реально существует в программировании – это система обработки списков List
Processor, или, сокращенно, Lisp. Этот процессор списков был реализован Дж. Маккарти (J.
McCarthy, [5]) в 1960 г., исходя из несколько иных посылок и представлений. Но вскоре воз-
можности этого процессора стали осознаваться именно в связи с природой аппликативных вы-
числений. Вместе с тем на практике полных выразительных возможностей об-системы по раз-
ным причинам достигнуть так и не удалось. Однако имевшаяся система программирования Lisp
получила дальнейшее развитие и приобрела большую популярность в области искусственного
интеллекта именно как “ассемблер знаний”.
Об-система по отношению к этой частной, индивидной вычислительной системе ведет себя
как концепт-система, способная порождать семейства виртуальных вычислительных систем с
разными выразительными возможностями. Конечно, обы виртуальной индивидной системы мо-
гут взаимодействовать по законам аппликативных вычислений и с произвольными обами, что
придает ей свойство расширяемости.
Комбинаторная арифметика Попытки строить виртуальные системы предпринимались и до
этого, в том числе для анализа математических понятий. Примером может служить комбина-
торная арифметика и система нумералов А. Черча. Действительно, в об-системах – будь то
комбинаторная логика или λ-исчисление, – среди первичных сущностей нет чисел. Это заме-
чательная особенность об-систем сразу привлекает внимание, поскольку в математике имен-
но число относится к первичным фундаментальным понятиям, а из арифметики, по сути, стро-
ится вся математика. Удалось установить производные обы-комбинаторы, которые ведут себя
как цифры – целые числа, нумералы. Это виртуальные объекты, или, как их еще называют в
формализмах, комбинаторные представления нумералов. Разработаны и семейства виртуаль-
ных объектов, представляющих арифметические операторы над нумералами (см. анализ про-
блематики и библ. в [10]). Исследование представлялось и представляется в настоящее время
настолько привлекательным, что был построен производный об-комбинатор рекурсии и для вир-
туальной системы рекурсивных вычислений проверена справедливость теоремы С. Клини о том,

8
Вольфенгаген В.Э., Аппликативный компьютинг: попытки установить природу вычислений
что всякая частично рекурсивная функция может быть (в слабом смысле) представлена обом-
комбинатором.
Виртуальная система обов, представляющая рекурсивные вычисления сама по себе может
рассматриваться как концептуальная основа процессора списков.
Логика высказываний Среди исходных сущностей об-системы нет не только чисел, но нет ни
представления об истине или лжи, ни условных конструкций или иных логических связок. Дру-
гими словами, об-система может оказаться пригодной и для построения виртуальных систем,
представляющих логику. В аппликативной вычислительной системе есть только обы и их прило-
жения, позволяющие упаковывать одни обы вместе с другими в ожидании, когда будет порожден
нужный вычислительный контекст и они проявят свои вычислительные свойства. А это значит,
что логические рассуждения можно свести к прямому вычислению.
Это сразу было проверено для логики высказываний (см. [10], с. 169) и ожидаемые вычисли-
тельные свойства подтвердились. Были установлены виртуальные обы, которые, соответственно
являлись представлениями истины и лжи в логики высказываний, которые удалось согласовать
с представлениями для условной конструкции, отрицания и конъюнкции. Все эти представле-
ния обладали относительно логики высказываний точно таким же поведением, как и “обычные”
сущности, которые они представляли. Это вновь заставило задуматься о природе истины и лжи,
а также высказываний и рассуждений в терминах высказываний. Действительно, об-системы
подчиняются законам аппликативных вычислений, которые на первый взгляд не имеют ничего
общего с обычно логикой или арифметикой. Вместе с тем, комбинируя обы определенным обра-
зом, удается получить такие упаковывания обов, совместное поведение которых удовлетворяет
законам логики или арифметики.
Если взять комбинатор K с характеристикой Kxy = x и комбинатор (KI) с характеристикой
KIxy = y, то они являются подходящими представлениями для истины T (true) и лжи F (false)
соответственно в следующем смысле.
Истинностные значения и условные выражения. Сами объекты T и F рассматриваются
как метапеременные, то есть их можно замещать подходящими замкнутыми выражениями,
конвертируемыми соответственно к T и F.
Если b – терм, принимающий значение true или false, то условное выражение
if b then m else n
имеет тот смысл, что
if true then m else n →m,
if false then m else n →n.
В этом случае для обозначения отношения редукции использован символ ‘→’.
Выполняя погружение условной конструкции в λ-исчисление или комбинаторную логику, по-
ложим
BMN,
где B, M, N – соответственно представления b, m, n. Таким образом,
TMN →M,
FMN →N,
а если воспользоваться конструкцией упорядоченной пары
[x, y] ≡λr.rxy ≡Dxy,

Сборник научно-популярных статей – победителей конкурса РФФИ 2006 года. Выпуск 10. – Под ред. чл.-корр. РАН В. И. Конова. – М.: Октопус·Природа, 2007. – с. 445-459.
9
то предыдущие выражения переписываются как
[M, N]T ≡(DMN)T →M,
[M, N]F ≡(DMN)F →N.
Логические связки При построения условных конструкций в программировании, как извест-
но, разрешается применение логических связок, среди которых остановимся на NOT, которую
будем обозначать через ¬, и AND, которую обозначим через &. Положим по определению:
¬ ≡λb.λx.λy.byx,
& ≡λb.λv.λx.λy.b(vxy)y.
Непосредственными вычислениями, пользуясь правилами λ-исчисления, можно убедиться, что
представления таблиц истинности для этих связок корректны:
¬F →T,
¬T →F,
и
&FF →F,
&FT →F,
&TF →F,
&TT →T.
Можно заметить, что & дает “короткозамкнутое” вычисление в том смысле, что
&Fa →F
даже если объект a не имеет нормальной формы.
5
Натуральные числа
Отметим, что при построении λ-исчисления среди исходных объектов числа и/или арифмети-
ческие операции не были использованы вовсе. Это означает, что среди замкнутых термов λ-
исчисления можно попытаться отыскать такие из них, которые являются подходящими пред-
ставлениями натуральных чисел.
Нумералы в системе λ-конверсии Для образов натуральных чисел выберем замкнутые тер-
мы, называемые нумералами Черча:
Z0 ≡λf.λx.x
≡λf.λx.f 0x,
Z1 ≡λf.λx.fx
≡λf.λx.f 1x,
Z2 ≡λf.λx.f(fx)
≡λf.λx.f 2x,
. . .
. . . ,
Zi ≡λf.λx. f(f . . . (f
|
{z
}
i раз
x) . . .) ≡λf.λx.f ix,
. . .
. . . .
Для того, чтобы нумералы Zi образовали натуральный ряд, требуется добавить операцию ‘сле-
дования за’, или прибавления единицы, обозначаемую через σ:
σ ≡λn.λf.λx.f(nfx).

10
Вольфенгаген В.Э., Аппликативный компьютинг: попытки установить природу вычислений
Действительно,
σZ0 →λf.λx.f(Z0fx) →λf.λx.fx
≡Z1,
σZ1 →λf.λx.f(Z1fx) →λf.λx.f(fx) ≡Z2,
. . .
. . .
. . . ,
σZi →λf.λx.f(Zifx) →λf.λx.f(f ix) ≡Zi+1,
. . .
. . .
. . . .
то есть σZi = Zi+1, и функция σ на нумералах Черча определяет функцию прибавления единицы.
Нумералы в системе комбинаторов Приступим к определению представления числа сред-
ствами комбинаторов. Для любых термов X, Y будем использовать сокращение
XnY ≡



X(X(. . . (X
|
{z
}
n
Y ) . . .)) для n > 0;
X0Y ≡Y
для n = 0.
Определение [нумералы]. Каждому натуральному числу n поставим в соответствие терм
Zn ≡(SB)n(KI).
Эти термы назовем нумералами.
Пример. Таким образом,
Z0 = KI,
Z1 = SB(KI),
Z2 = SB((SB)(KI)),
. . . ,
Zn = SB((SB)n(KI)),
. . .
Имеются и другие последовательности, которые можно использовать вместо Zn, но принятое
определение имеет то техническое преимущество, что
(Zn)
ZnFX ▷F nX
для любых F и X (сравните с нумералами Черча [2]).
Тест нуля Для работы с последовательностью нужно ввести распознающую функцию, или пре-
дикат isZero проверки нумерала на свойство быть нулем:
isZero ≡λn.λx.λy.n(λz.y)x.
Действительно,
isZero Z0 →λx.λy.Z0(λz.y)x
→λx.λy.x
≡T,
isZero Zi+1 →λx.λy.Zi+1(λz.y)x
= λx.λy.σZi(λz.y)x
→λx.λy.(λz.y)(Zi(λz.y)x)
→λx.λy.y
≡F.

Сборник научно-популярных статей – победителей конкурса РФФИ 2006 года. Выпуск 10. – Под ред. чл.-корр. РАН В. И. Конова. – М.: Октопус·Природа, 2007. – с. 445-459.
11
Построение арифметики Пользуясь этими представлениями и добавив к ним оператор непо-
движной точки Y , действительно можно выразить произвольную вычислимую на натуральных
числах функцию. Отложим это для последующего рассмотрения, а вместо этого введем пред-
ставления для арифметических операторов сложения ⊕и умножения ⊗:
⊕≡λm.λn.λf.λx.mf(nfx),
⊗≡λm.λn.λf.m(nf).
Пример. Рассмотрим выполнение сложения двух нумералов Z2 и Z3:
⊕Z2 Z3 →λf.λx.Z2f(Z3fx)
→λf.λx.Z2f(f 3x)
→λf.λx.f 2(f 3x)
≡λf.λx.f 2 (f(f(fx)))
≡λf.λx.f(f (f(f(fx))) )
≡λf.λx.f 5x
≡Z5,
что совпадает с интуитивно ожидаемым результатом.
Пример. Рассмотрим выполнение умножения двух нумералов Z2 и Z3:
⊗Z2 Z3 →λf.Z2(Z3f)
→λf.λx.(Z3f)2x
→λf.λx.Z3f(Z3fx)
≡λf.λx.Z3f(f 3x)
≡λf.λx.f 3(f 3x)
≡λf.λx.f 3 (f(f(fx)))
≡λf.λx.f(f(f (f(f(fx))) ))
≡λf.λx.f 6x
≡Z6,
что совпадает с интуитивно ожидаемым результатом.
Вопросы эффективности реализации этой арифметики нуждается в дополнительном изуче-
нии. Кроме того, как оказывается, ряд представлений для рассмотренных сущностей имеет слу-
чайные свойства, которые не дают закономерности. В частности,
Z0 ≡F.
Другой пример дается вариантом представления для функции прибавления единицы:
σ′ ≡λn.λf.λx.nf(fx),
что приводит для σ и σ′ к различным результатам, когда эти функции применяются к объектам,
не являющимся нумералами.
Отметим, что в этом варианте программирования в λ-исчислении требуется нормально-порядковая
редукция. В частности, для условных выражений требуется, чтобы Tab редуцировалось к a, даже
если b не имеет нормальной формы. Кроме того, как оказалось, выражение нужно редуцировать
к нормальной форме, но не обязательно к каноническому виду, чтобы установить результирую-
щий нумерал или истинностное значение (см. примеры 5, 5).
Более того, нумерал Z1 имеет две нормальные формы: λf.λx.fx и λf.f, которые связаны
отношением η-редукции:
λf.λx.fx ≡λf.(λx.fx) →η λf.f,
поскольку λx.fx →η f.
Таким образом, вычисления с нумералами Черча основаны на βη-редукции, то есть на выра-
жениях, которые не содержат ни β-, ни η-редексов.

12
Вольфенгаген В.Э., Аппликативный компьютинг: попытки установить природу вычислений
6
Композиционные структуры обов
Композиции обов и возникающие при этом структуры вызывают повышенный интерес в одной
специальной системе обов. В этой системе для произвольного оба A требуется выполнением
равенства
A = A ◦A,
которое характеризует A как домен, а для обов f, A, B – равенства
f = B ◦f ◦A,
которое характеризует f как отображение, функциональную сущность.
Далее потребуется развить достаточно специальное представление. Функцию h из A в T за-
писываем посредством h : A →B. Рассмотрим функции “транзакций” g, g′ и функции “клони-
рования” f, f ′, для которых
g : T →T ′,
g′ : T ′ →T ′′
и
f : A →B,
f ′ : B →C.
Их будем рассматривать совместно с функциями h : A →T, h : B →T ′ и h′′ : C →T ′′. Пове-
дение этих отображений представлено на рис. 3. Особенность этой композиционной структуры
Рис. 3. Пример g, g′-транзактированной, f, f ′-клонированной структуры обов.
можно пояснить следующим образом. Пусть B характеризует “настоящее”, тогда A – это воз-
можное “будущее”, а C – “прошлое”. “Разворачивание” событий происходит вдоль эвольвент
f, f ′’. Обращаем внимание, что события разворачиваются именно от C к B и от B к A. Пусть
также об T под воздействием “транзакции” g превращается в об T ′, а об T ′ под воздействием g′
– в об T ′′.
Прошлое характеризуется обом
T ′′ ◦h′′ ◦C,
а возможное будущее соответствует обу
T ′′ ◦g′ ◦g ◦h ◦f ′ ◦f ◦A.
Таким образом, под воздействием эвольвент f, f ′ и транзакций g, g′ об h′′ из прошлого C транс-
формируется в виртуальный об g′ ◦g ◦h ◦f ′ ◦f из будущего A. Сходные представления были
развиты Д. Скоттом (D. Scott, [8]) применительно к функторным конструкциями доменов.

Сборник научно-популярных статей – победителей конкурса РФФИ 2006 года. Выпуск 10. – Под ред. чл.-корр. РАН В. И. Конова. – М.: Октопус·Природа, 2007. – с. 445-459.
13
7
Системы аппликативного программирования
К настоящему времени аппликативные вычислительные системы начинают рассматриваться как
основа для проектирования компьютеров, систем квантового компьютинга и квантовых язы-
ков программирования (см., например, P. Selinger and B. Valiron, [6]). До сих пор этого не про-
изошло из-за массового распространения компьютеров с фон Нейманновской архитектурой и
сложившейся индустрией производства для них программного обеспечения. Аппликативная си-
стема вычислений, в отличие от фон Нейманновской, является высоко симметричной и концеп-
туально ясной, имеющей хорошо обоснованное математическое представление.
Вместе с тем препятствие для их реализацией на нынешнем массово распространенном и
внедренным в сознание технологическом уровне наталкивается на две трудности – в об-системе
нет “памяти” и изначально отсутствует чувствительность к “предыстории вычислений”, – а это
краеугольные камни нынешнего фон Нейманновского компьютинга. Другая причина – в боль-
шинстве аппликативных систем используются ламбда-абстракции, апплицирование которых к
объектам приводит к необходимости использовать правило подстановки в наиболее общем и
наименее ограниченном виде, как принцип неограниченного свертывания. Такая мощная воз-
можность вычислений, дающая неограниченные выразительные возможности, все еще не реали-
зована из-за нынешней концепции компьютера и компьютинга, а также из-за инерции мышления
большинства специалистов, прекрасно образованных в области традиционного компьютинга, но
не обладающих должной подготовкой и развитой интуицией в аппликативном компьютинге и вы-
числениях в об-системах.
При реализации аппликативной системы, прежде всего, пытаются оснастить ее памятью и
повысить ее эффективность для организации вычислений на фон Нейманновских компьютерах.
Все это привело к непрекращающимся попыткам рассматривать аппликативную систему как
‘встроенную систему’, но встраивание, или погружение ведется в б ´ольшую, объемлющую систе-
му фон Нейманновского типа. Примером такого рода могут служить реализации Lisp-систем, в
которые изначально заложена идея именно аппликативных вычислений в об-системе. Однако
Lisp-система обычно рассматривается как подмножество расширенной среды, которая осна-
щена возможностями взаимодействия с вычислительными системами – будь то аппаратное или
программное обеспечение, – фон Неймана. В результате возникает сложная и громоздкая систе-
ма, утратившая свою математическую лаконичность и которую весьма сложно осмыслить раз-
работчику компьютеров нового типа.
Список литературы
1.
Backus J. Can programming be liberated from the von Neumann style?: a functional style and its algebra of programs.
– Commun. ACM, Vol. 21, №8, 1978. – pp. 613–641.
DOI http://doi.acm.org/10.1145/10.1145/359576.359579.
Русский перевод: Бэкус Дж. Можно ли освободить программирование от стиля фон Неймана? Функциональный
стиль и соответствующая алгебра программ. – Пер. с англ. Мартынюка В. В. – В кн.: Лекции лауреатов премии
Тьюринга за первые двадцать лет 1966-1985. – Под ред. Р. Эшенхерста. – М.: Мир, 1993. – с. 84-158. 2
2.
Church A. The calculi of lambda conversion. – Prinston University Press, Prinston, 1941. 5
3.
Curry H. B. Functionality in combinatory logic. – Proc. National Academy of Sciences of the USA, Vol. 20, 1934. – pp. 584–
590.
4.
Date C. J., Darwen H. Foundation for future database systems. The Third Manifesto. A detailed study of the impact of
type theory on the relational model of data, including a comprehensive model of type inheritance. – Addison-Wesley
Publishing Co, 2-nd edition, 2000.
Русский перевод: Дейт К., Дарвен Х. Основы будущих систем баз данных. Третий манифест. Детальное исследова-
ние влияния теории типов на реляционную модель данных, включая полную модель наследования типов. – Пер. с
англ. Кузнецова С. Д. и Кузнецовой Т. А. Под ред. Кузнецова С. Д. – 2-е издание, М.: Янус-К, 2004. – 656 с.
См. также: Darwen H., Date C. J. The Third Manifesto. – 2002. http://www.thethirdmanifesto.com/ 1
5.
McCarthy J. Recursive functions of symbolic expressions and their computation by machine, Part I. – Commun. ACM, Vol.
3, №4, 1960. – pp. 184–195.
DOI http://doi.acm.org/10.1145/367177.367199 4

14
Вольфенгаген В.Э., Аппликативный компьютинг: попытки установить природу вычислений
6.
Selinger P. and Valiron B. A lambda calculus for quantum computation with classical control. – Mathematical Structures
in Computer Science, 16(3), 2006. – pp. 527-552. 7
7.
Scott D. S. The lattice of ﬂow diagrams. – Lecture Notes in Mathematics, 188, Symposium on Semantics of Algorithmic
Languages. – Berlin, Heidelberg, New York: Springer-Verlag, 1971, pp. 311-372. 3
8.
Scott D. S. Relating theories of the lambda calculus. – Hindley J., Seldin J. (eds.) To H.B.Curry: Essays on combinatory
logic, lambda calculus and formalism.- N.Y.& L.: Academic Press, 1980, pp. 403-450. 6
9.
Вольфенгаген В. Э. Комбинаторная логика в программировании. Вычисления с объектами в примерах и задачах.
– М.: МИФИ, 1994. – 204 с.; 2-е изд., М.: АО ≪Центр ЮрИнфоР≫, 2003. – 336 с. 3
10. Вольфенгаген В.Э. Методы и средства вычислений с объектами. Аппликативные вычислительные системы. – М.:
JurInfoR Ltd., АО «Центр ЮрИнфоР», 2004. – xvi+789 с. 3, 3, 4, 4

