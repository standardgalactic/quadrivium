
Cover

Programming for
Problem-solving with C
Formulating algorithms for complex
problems
Dr. Kamaldeep
www.bpbonline.com

Copyright © 2024 BPB Online
All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or
transmitted in any form or by any means, without the prior written permission of the publisher,
except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the information
presented. However, the information contained in this book is sold without warranty, either express
or implied. Neither the author, nor BPB Online or its dealers and distributors, will be held liable for
any damages caused or alleged to have been caused directly or indirectly by this book.
BPB Online has endeavored to provide trademark information about all of the companies and
products mentioned in this book by the appropriate use of capitals. However, BPB Online cannot
guarantee the accuracy of this information.
First published: 2024
Published by BPB Online
WeWork
119 Marylebone Road
London NW1 5PU
UK | UAE | INDIA | SINGAPORE
ISBN 978-93-55517-357
www.bpbonline.com

Dedicated to
My beloved wife
Dr. Deepika
&
My daughter Kavya

About the Author
 Dr. Kamaldeep is currently serving as an Assistant Professor in the
Department of Computer Science and Engineering at the University
Institute of Engineering and Technology, Maharshi Dayanand University,
located in Rohtak, Haryana, India. With a dedicated tenure that began in
2012, he has accumulated experience in teaching and research. Significant
milestones mark his academic journey. He earned his B.Tech in 2009, an
M.Tech in 2011, and a Ph.D. in Computer Science and Engineering in 2017
from Maharshi Dayanand University. In his 12 years of teaching and
research career, he has actively engaged with undergraduate (UG) and
postgraduate (PG) students. He is proficient in guiding M.Tech and Ph.D.
candidates and has demonstrated his commitment to academic mentorship
by successfully guiding over 50 B.Tech and M.Tech students in their
dissertations and projects. Three PhD students successfully submitted their
thesis under his guidance. His research interests include Image
Steganography, Information Security, Neural Networks, and Machine
Learning. Dr. Kamaldeep’s scholarly output is substantial, with an
authorship of over 50 articles published in reputable journals and
conferences. These contributions are recognized by reputed databases such
as Scopus, Web of Science, and SCI, showcasing the impact and relevance
of his research in the academic community. Beyond his research
endeavours, Dr. Kamaldeep has actively participated in knowledge
dissemination. He has delivered expert talks and served as a session chair
in national and international conferences, further solidifying his presence
and influence in the academic discourse. Dr. Kamaldeep actively
participates in national and international conferences, contributing valuable
insights to proceedings and book chapters. His dedication is evident in his
membership in various international societies, solidifying his standing in
the global research community.

About the Reviewer
Rahul Rishi is a Computer Science & Engineering Professor at the
University Institute of Engineering & Technology, Maharshi Dayanand
University, Rohtak. His qualifications include a B.Tech (Computer
Science), M.Tech (Computer Science & Engineering), and Ph.D. in
Computer Science. He also possesses qualifications of Master of Business
Administration, LLB, and Masters in Intellectual Property Law. He has a
total teaching experience of more than 25 years. His research interests
include temporal and spatial databases, uncertainty management through
probabilistic databases, and intelligent transportation systems. He has over
150 papers to credit in various International/National Journals and
Conferences. Fifteen students have successfully completed their doctoral
studies, leading to a PhD in Computer Science and Engineering under his
guidance. He has also completed Consultancy projects from Industry and
published one patent. He is also connected with various Universities of
India in different capacities.

Acknowledgement
I extend my profound gratitude to my parents, whose unwavering support
and encouragement have been the cornerstone of this book’s creation. A
special acknowledgement goes to my beloved wife, Dr. Deepika, and my
daughter, Kavya, for their patience and understanding throughout this
writing journey.
I would also like to express my sincere appreciation for my dear friends,
Dr. Ravi Saini and Dr. SS Gill. Discussions with them have added depth
and perspective to the content of this book.
I am indebted to my students, Sachin Allwadhi, Abhinav Dahiya, Mona,
Varun, and Yashasvi, whose insightful feedback enhanced the quality of my
work.
I extend profound gratitude to the teachers who have played a pivotal role
in shaping my educational journey. Their dedication, knowledge, and
guidance have been instrumental in laying the foundation for my
understanding of this book’s subject matter. I am indebted to their wisdom
and tireless efforts in fostering a love for learning within me.
I would like to express sincere appreciation to Maharshi Dayanand
University for providing me with the invaluable platform and state-of-the-
art infrastructure that facilitated the creation of this book. The academic
environment and resources offered by the university have played a crucial
role in shaping my scholarly pursuits.
Heartfelt thanks to BPB Publications for their expert guidance, instrumental
in bringing this endeavour to fruition. The extensive process of refining this
book was enriched by the collaborative efforts of reviewers, technical
experts.
Lastly, sincere thanks to the readers whose interest and support have
transformed this project into a reality. Your encouragement has been truly
invaluable.

Preface
Welcome to Programming for Problem-Solving, a comprehensive guide
designed to equip you with the essential skills and knowledge needed to
excel in the world of computer programming. This book is a carefully
curated journey through the foundational concepts of computer science and
problem-solving, with a specific focus on the C programming language.
Starting with an exploration of the computer’s hardware and software
components, we progress through chapters dedicated to problem-solving
techniques, the fundamentals of C, operators, decision-making statements,
loops, arrays, strings, functions, recursion, structures, unions, searching,
sorting, pointers, and the intricacies of console input-output functions. As
we delve into advanced topics such as preprocessing, file handling, and the
critical understanding of time and space complexity, each chapter is
designed to build upon the previous, providing a structured and
comprehensive approach to programming. Whether you are a novice
seeking a solid foundation or an experienced programmer aiming to refine
your problem-solving skills, this book offers clear explanations, practical
examples, and hands-on exercises to enhance your programming prowess.
Happy coding!
Chapter 1: The Computer – Covers the basic building units of computers.
It also includes the classification of computers, computer characteristics,
advantages of the computer, limitations of the computer, and applications of
the computer. In the end, the conclusion of the chapter, Points to Remember
and the important questions are provided
Chapter 2: The CPU and the Memory – Describes the CPU and its
components, the memory, and its types. It also focuses on how the
instructions are fetched from the memory and executed by the CPU. The
memory hierarchy and memory measurement are also discussed in it.

Chapter 3: The Computer Software – Tells about computer software and
its classification on various parameters. It also gives a basic introduction to
the operating system and its classifications on different parameters like the
execution of the program, number of users, and interface. It also gives the
basics of malicious programs.
Chapter 4: The Number System – Provides information about the
different types of number systems like decimal, binary, octal, and
hexadecimal. It also focuses on the conversion of one number system into
another. Various operations on binary numbers like Addition, Subtraction,
Multiplication, Division, One’s complement, 2’s complement, and Negation
are given. Some other popular binary codes like ASCII, BCD, EBCDIC,
Excess-3, and Gray codes are also discussed.
Chapter 5: Problem-solving Techniques – Focuses on the approach
towards problem-solving and different techniques of problem-solving like
pseudo-code, algorithms, and flowcharts. It also tells about different
computer languages like high level, low level, and assembly level and their
language translation tools like the compiler, interpreter, and assembler. It
tells the procedure to convert the algorithm into a program.
Chapter 6: Fundamentals of C – Gives the introduction and history of C
language. It also focuses on the building blocks of C language, like
character sets and the tokens, i.e. keywords, variables, constants, etc. It also
tells about the fundamental components of the C program and the method
of execution of it. The basic data types and type conversion are also
discussed here.
Chapter 7: Operators and Expressions – Discusses the operators and
expressions used in C language. These operators are classified on the basis
of the number of opcodes, i.e., unary, binary, and ternary operators. Other
operators are arithmetic, increment, decrement, relational, logical, bitwise,
shift, assignment, comma, sizeof(), conditional, and address operators are
also discussed in the chapter.
Chapter 8: Decision-making Statements – Enables the user to write the
decision-making statements in their programs. It also discusses their types,
i.e. conditional and unconditional. It includes statements like if, if else, else
if, and switch under conditional. Also, the statements like goto, break, and
continue are given in unconditional statements.

Chapter 9: Loop – Provides the details of loops and their types, which are
for, while and do while.
Chapter 10: Array – Provides the details of the array, its types, properties,
and applications.
Chapter 11: String – Shows the working with the string and the inbuilt
string functions used in the processing of the string like strlen(), strcat(),
strcmp(), strcpy(), strrev(), strupr(), strlwr(), strncmp(), strncat() and
strncpy(). It also discusses the built-in functions to handle characters.
Chapter 12: Function – Talks about the method of writing the function,
the need, the types of functions, and its method of calling by value and
reference. It also tells the concept of storage classes.
Chapter 13: Recursion – Talks about recursion and the various examples
that are solved by it, like finding factorials, the Fibonacci series, the
Ackerman function, etc. The sorting through recursion, like quick sort and
merge sort, is also given here.
Chapter 14: Structure and Union – This chapter provides two special
user-defined data types, i.e. structure and union. It also illustrates the use of
a pointer in accessing the content of the structure.
Chapter 15: Searching and Sorting – This chapter gives the basic idea of
searching and sorting. Two popular techniques, i.e., linear and interval
searching, are discussed. The sorting techniques like bubble, insertion, and
selection are also given.
Chapter 16: Pointers – This chapter introduces the pointer and its
application in various fields of programming like in the creation of self-
referential structures, for example, the link list
Chapter 17: The Console Input-output Functions – This chapter shows
the inbuilt input-output function of the console. There are two types of input
and output functions: formatted and unformatted. The formatted functions
mainly include printf() and scanf() functions, and the unformatted ones
include functions like getch(), putch(), getchar(), putchar() and getche(),
etc.
Chapter 18: Preprocessor – This chapter explains the preprocessor
directives in detail. It includes various types of preprocessing directives like

file inclusion directives, macro expansion directives, conditional directives,
and miscellaneous directives.
Chapter 19: File Handling in C – This chapter enables the readers to deal
with files, which include various operations on the file, starting from
creating the file, reading the content of the file, updating the content, etc,
with the help of inbuilt file functions provided in C language. Also, it
elucidates the concept of dynamic memory allocation with the help of
various functions like malloc(), calloc() realloc() and free().
Chapter 20: Time and Space Complexity – This chapter introduces the
concept of space and time complexity, which are used to measure the
performance of the algorithms. It also discusses asymptotic notations like
Big-Oh, Big Omega, and Theta. Various examples are also provided for the
calculation of time complexity for different program statements like loops,
conditional, etc.

Code Bundle and Coloured Images
Please follow the link to download the
Code Bundle and the Coloured Images of the book:
https://rebrand.ly/jv46hmw
The code bundle for the book is also hosted on GitHub at
https://github.com/bpbpublications/Programming-for-Problem-
Solving-with-C. In case there's an update to the code, it will be updated on
the existing GitHub repository.
We have code bundles from our rich catalogue of books and videos
available at https://github.com/bpbpublications. Check them out!
Errata
We take immense pride in our work at BPB Publications and follow best
practices to ensure the accuracy of our content to provide with an indulging
reading experience to our subscribers. Our readers are our mirrors, and we
use their inputs to reflect and improve upon human errors, if any, that may
have occurred during the publishing processes involved. To let us maintain
the quality and help us reach out to any readers who might be having
difficulties due to any unforeseen errors, please write to us at :
errata@bpbonline.com
Your support, suggestions and feedbacks are highly appreciated by the BPB
Publications’ Family.
Did you know that BPB offers eBook versions of every book published, with PDF and ePub files
available? You can upgrade to the eBook version at www.bpbonline.com and as a print book
customer, you are entitled to a discount on the eBook copy. Get in touch with us at :
business@bpbonline.com for more details.

At www.bpbonline.com, you can also read a collection of free technical articles, sign up for a
range of free newsletters, and receive exclusive discounts and offers on BPB books and eBooks.
Piracy
If you come across any illegal copies of our works in any form on the internet, we would be
grateful if you would provide us with the location address or website name. Please contact us at
business@bpbonline.com with a link to the material.
If you are interested in becoming an author
If there is a topic that you have expertise in, and you are interested in either writing or
contributing to a book, please visit www.bpbonline.com. We have worked with thousands of
developers and tech professionals, just like you, to help them share their insights with the global
tech community. You can make a general application, apply for a specific hot topic that we are
recruiting an author for, or submit your own idea.
Reviews
Please leave a review. Once you have read and used this book, why not leave a review on the site
that you purchased it from? Potential readers can then see and use your unbiased opinion to make
purchase decisions. We at BPB can understand what you think about our products, and our
authors can see your feedback on their book. Thank you!
For more information about BPB, please visit www.bpbonline.com.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

Table of Contents
1. 1. The Computer
1. Introduction
2. Structure
3. Objectives
4. The computer
5. Block diagram of functional units/components of the computer
1. Input unit
2. Output unit
3. Processing unit
4. Memory unit
6. Data and information
7. Classification of computers
1. Classification based on time or historical development
1. Zero-generation computers (up to 1945)
2. First generation computers (1946–1956)
3. Second generation computers (1956–1963)
4. Third Generation Computer (1964–1971)
5. Fourth-generation computers (1971–1989)

6. Fifth-generation computers (1989 till present)
2. Classification based on the purpose
1. General purpose computers
2. Special purpose computers
3. Classification based on the technology used
1. Analog computers
2. Digital computers
3. Hybrid computers
4. Classification based on the number of users
8. Computer characteristics
9. Advantages of the computer
10. Limitations of computer
11. Applications of computer
12. Conclusion
13. Points to remember
14. Important questions
2. 2. The CPU and the Memory
1. Introduction
2. Structure
3. Objectives

4. The CPU
5. Components of the CPU
1. ALU
2. CU
3. Registers
6. The instruction on CPU: Working of CPU
1. Steps performed for the execution of single instruction
7. The CPU speed
1. The clock speed
2. The total number of processor cores
3. Cache memory
8. The memory unit
1. Primary memory
1. RAM
2. ROM
2. Secondary memory
1. Serial accessed memory: Magnetic tape
2. Semi-random accessed memory
9. Memory hierarchy
10. Measuring the memory

11. Solved examples based on the inter-conversion of memory units
12. Conclusion
13. Points to remember
14. Important questions
3. 3. The Computer Software
1. Introduction
2. Structure
3. Objectives
4. Computer software
5. Examples of system software
6. Classifications of software dependent on proprietary rights
7. Operating system
1. UNIX OS structure
8. The operating system as a resource manager
9. Classification of the operating system
1. Based on the user interface
2. Based on the number of users
3. Based on the execution of the program
1. Sequentially execution of the program or serial
processing
2. Batch processing operating system

3. Multiprogramming operating system
4. Multitasking OS through time-sharing
5. Multithreading operating system
6. Multiprocessing operating system
7. Distributed operating system
8. Network operating system
9. Real-time operating system
4. Language translator
5. The malware
10. Conclusion
11. Points to remember
12. Important questions
4. 4. The Number System
1. Introduction
2. Structure
3. Objectives
4. Number system
1. Binary number system
2. Decimal number system
3. Octal number system

4. Hexadecimal number system
5. Conversions from the decimal system to another
1. Decimal to binary
2. Decimal to octal
3. Decimal to hexadecimal
6. Conversions from another number system to decimal
1. Binary to decimal
2. Octal to decimal
3. Hexadecimal to decimal
7. Number system conversions, excluding decimal
8. Fractional numbers
1. Binary fractional numbers into decimal
2. Octal fractional numbers into decimals
3. Hexadecimal fractional numbers into decimal
4. Decimal fraction number to binary
5. Decimal fraction number to octal
6. Decimal fraction number to hexadecimal
9. Direct conversion methods
1. Binary to decimal
2. Decimal to binary

3. Binary to octal
4. Binary to hexadecimal
10. Operations on binary numbers
1. Addition
2. Subtraction
3. Multiplication
4. Division
5. One’s complement
6. Two’s complement
7. Subtraction using two’s complement
8. Negative binary number or signed number representation
11. Other popular codes
1. ASCII
2. BCD
3. EBCDIC
4. Excess-3
5. Gray code
12. Conclusion
13. Points to remember
14. Important questions

5. 5. Problem-solving Techniques
1. Introduction
2. Structure
3. Objectives
4. Problem-solving
1. Steps for logical and numerical problem-solving
1. Solving a logical problem
2. Solving a numerical problem
5. Problem-solving techniques
1. Algorithm
1. Characteristics of an algorithm
2. Flowcharts
3. Pseudocodes
6. Programming language
7. Language translator
1. Functions of the compiler
2. Functions of assembler
8. Compiling and executing process
9. Syntax and logical errors in the compilation
10. Files generated in the C program lifecycle

11. Conclusion
12. Points to remember
13. Important questions
6. 6. Fundamentals of C
1. Introduction
2. Structure
3. Objectives
4. Introduction to C
5. History of C language
6. Why C?
7. Learning of C
8. C characters or symbols set
1. Whitespace characters or escape sequences
2. Format specifiers
9. Tokens in C
1. Classification of tokens in C
2. Keywords
3. Variables
4. Constant
1. Integer constant

2. Real constant
3. Character constant
4. String constant
5. Identifiers
6. Operators
7. Special symbols
10. The general structure of the C program
11. First C program
1. Description of the preceding program
1. Comments
2. printf() and scanf() functions
12. How to compile and run the C program?
13. Header files
14. Data types
1. Primary data types
1. Character
2. Integer
3. Real data type
4. Double data type
5. Void

2. Derived data types
15. Data type modifiers
16. Type conversion or type casting
17. Variable declaration versus definition
18. Conclusion
19. Points to remember
20. Important questions
7. 7. Operators and Expressions
1. Introduction
2. Structure
3. Objectives
4. Operators and expressions
5. Operators based on operand count
6. Operators based on operation type
1. Arithmetic operators
2. Increment and decrement operators
3. Relational operators
4. Logical operators
5. Bitwise operators
6. Shift operators

7. Comma operator
8. The sizeof( ) operator
9. Assignment operators
10. Conditional operator
11. Address operator
7. Precedence and associativity of operators in C
8. Conclusion
9. Points to remember
10. Important questions
8. 8. Decision-making Statements
1. Introduction
2. Structure
3. Objectives
4. Decision-making statements
5. Types of decision-making statements
1. Conditional decision-making statements
2. Unconditional decision-making statements
6. Roots of a quadratic equation
7. Solved programs for practice on decision-making
8. Conclusion

9. Points to remember
10. Important questions
9. 9. Loop
1. Introduction
2. Structure
3. Objectives
4. Loop
5. Types of loop
1. for loop
2. while loop
3. do-while loop
4. Nested loop
5. The infinite loop
6. Programs on loops for practice
7. Conclusion
8. Points to remember
9. Important questions
10. 10. Array
1. Introduction
2. Structure

3. Objectives
4. Array
5. Declaration of array
6. Initialization of array
1. Method 1: Direct assignment of the element
1. Accessing the elements of the array
2. Method 2: Initialization of the array at a time
3. Method 3: Initialization of array using a loop
7. Finding the address of the array element
8. Types of the array
1. One or single-dimensional array
2. Multi-dimensional array
1. 2D array
2. 3D array
9. Properties of array
10. The advantage of using an array
11. Solved programs for practice based on the array
12. Conclusion
13. Points to remember
14. Important questions

11. 11. String
1. Introduction
2. Structure
3. Objectives
4. String
5. Declaration and initialization of string
1. Method 1: Character-by-character method
2. Method 2: Direct method
3. Method 3: Initialization by index
6. Limitation of scanf function
7. Standard inbuilt string functions
1. strlen()
2. strcat()
3. strcmp()
4. strcpy()
5. strrev()
6. strupr()
7. strlwr()
8. strncat()
9. strncpy()

10. strncmp()
8. 2D string
9. The ctype.h header file
10. Solved programs for practice based on string
11. Conclusion
12. Points to remember
13. Important questions
12. 12. Function
1. Introduction
2. Structure
3. Objectives
4. Function
5. Need of the function
6. Types of function
7. Types of parameters
8. Types of function based on function parameters
1. Call by value
1. Introduction to pointers
2. Call by reference
9. Calling convention

10. Passing arrays to functions
11. Storage classes in C
12. Solved programs for practice based on function
13. Conclusion
14. Points to remember
15. Important questions
13. 13. Recursion
1. Introduction
2. Structure
3. Objectives
4. Recursion
5. Finding the factorial of a number
6. Fibonacci series
7. Ackermann function
8. Merge sort
1. Algorithm for merge sort
9. Quick sort
1. Algorithm for quick sort
10. Conclusion
11. Points to remember

12. Important questions
14. 14. Structure and Union
1. Introduction
2. Structure
3. Objectives
4. Defining a structure
5. Accessing the structure element
6. Initialization of the structure
7. An array of structures
8. Structure with pointer
1. Declaration of the structure pointer
2. Initialization of the structure pointer
3. Access structure member using a pointer:
9. Union
10. Nested structure
11. Passing structure in a function
12. Conclusion
13. Points to remember
14. Important questions
15. 15. Searching and Sorting

1. Introduction
2. Structure
3. Objectives
4. Searching
5. Linear searching
1. Algorithm for linear search
6. Binary search
1. Algorithm for binary search
7. Sorting algorithms
1. Bubble sort
1. Algorithm
2. Selection sort
1. Algorithm
3. Insertion sort
1. Algorithm
8. Conclusion
9. Points to remember
10. Important questions
16. 16. Pointers
1. Introduction

2. Structure
3. Objectives
4. Pointer
5. Initialization of pointer
1. Accessing the value
6. Operations on pointers
7. Pointer to a pointer
8. NULL pointer
9. Generic pointer
10. Pointer to an array
11. Array of pointers
12. Self-referential structure
13. Linked list
14. Conclusion
15. Points to remember
16. Important questions
17. 17. The Console Input-output Functions
1. Introduction
2. Structure
3. Objectives

4. The console input–output functions
5. printf()
6. scanf()
1. Limitations of scanf()
7. getch(), getche(), and putch()
8. getchar() and putchar()
9. fgetchar() and fputchar()
10. gets() and puts()
11. Use of fflush(stdin)
12. Conclusion
13. Points to remember
14. Important questions
18. 18. Preprocessor
1. Introduction
2. Structure
3. Objectives
4. Preprocessor
5. Preprocessor directives
1. File inclusion directives
2. Macro expansion directives

1. The difference between macro and function
3. Conditional directives
1. #ifdef and #endif
2. #if and #endif
4. Undefined directives
1. #undef
6. Conclusion
7. Points to remember
8. Important questions
19. 19. File Handling in C
1. Introduction
2. Structure
3. Objectives
4. File
5. Need of the file
6. Types of files
7. Operations on file through the inbuilt functions
1. Opening a file
2. Reading a file
3. Closing a file

4. Deleting a file
8. Memory allocation
1. malloc()
2. calloc()
3. free()
4. realloc()
9. Conclusion
10. Points to remember
11. Important questions
20. 20. Time and Space Complexity
1. Introduction
2. Structure
3. Objectives
4. Algorithm
5. Algorithm analysis
1. Why algorithm analysis?
6. Asymptotic notation
1. Big-Oh
1. How to choose the value of C and k?
2. Omega

3. Theta
7. Why Big-oh?
8. Measuring the time complexity
9. Measuring the space complexity
10. Relationship between the Big-Oh asymptotic notations
11. Time complexity
12. Space complexity
13. Conclusion
14. Points to remember
15. Important questions
21. Index

CHAPTER 1
The Computer
Introduction
This chapter explores the fundamental aspects of computers. Understanding
computers’ core components and concepts is essential in the digital age. This
chapter will explore the building blocks of a computer, the distinctions
among various computer types, and the key characteristics that make
computers indispensable in our lives. We will delve into the advantages and
limitations of these electronic marvels’ diverse applications and summarize
the chapter’s key points and important questions for further exploration. Let
us embark on this enlightening journey into the world of computers.
Structure
In this chapter, we will be discussing the following topics:
Block diagram of functional units/components of the computer
Data and information
Classification of computers
Classification based on time generation or historical development
Classification based on the purpose
Classification based on the technology used

Classification based on the number of users
Computer characteristics
Automatic
Speed
Accuracy
Versatile
Diligence
Zero IQ
Memory
Economical
Advantages of the computer
Limitations of computer
Applications of computer
Conclusion
Points to remember
Important questions
Objectives
This chapter aims to provide a comprehensive understanding of computers
and their integral components. We will explore data, computer
classifications, and essential characteristics, along with the advantages and
limitations of these machines. Additionally, we will examine their diverse
applications, culminating in a conclusion and offering key takeaways and
important questions for a deeper grasp of the subject matter.
The computer
The term computer was derived from the word compute. A computer is an
electronic device that takes data and a set of instructions as input from the

user, processes the data, and produces information as output. This complete
cycle is known as the input–-process–output cycle, as shown in Figure 1.1:
Figure 1.1: Input process output cycle
The instructions are the commands to the computer given by the user to
perform the task. The set of instructions is known as the program. The set of
programs is known as the software. The electronic device is known as
hardware. Hence, a computer is a collection of hardware and software.
Figure 1.2 shows the computer components:
Figure 1.2: Computer components
Block diagram of functional units/components of the computer
Generally, the computer consists of four functional units which are
interconnected to each other to form a computer. These units are given as
follows:
Input unit
Output unit
Processing unit
Storage/memory unit
All the preceding units are connected with each other via the system buses
(wires). There are three main buses: the data bus, the control bus, and the

instruction bus. The data bus is responsible for carrying data from one unit to
another; the control bus carries the control signals generated by the CU, and
the instruction bus carries the instructions (commands). The block diagram
of the computer with its functional units is given in Figure 1.3:
Figure 1.3: Block diagram of a computer with its functional unit
Input unit
The input unit gets the data or program from the user or other media
(device). An input unit is responsible for reading the input. The input unit
functions are done by various devices known as input devices, such as:
Keyboard
Mouse
Joysticks
Touch Screen
Scanner

The input unit generally performs three main functions, which are as
follows:
It accepts input from users in a human-readable form that is in the
English language.
It converts the human-readable form into a computer-readable format
(binary language).
It supplies the converted data to the computer system for further
processing.
Output unit
The output unit accepts the processed result from the computer and makes it
available to the end user. The output unit function is performed by some
devices, which are known as output devices, such as:
Monitor
Printer
Speaker
Plotter, and so on
The output unit generally performs three main functions, which are as
follows:
It accepts the processed results from the computer in computer-
readable form (Binary data is a form of signal).
It converts the computer-readable form into human-readable form
(English, Hindi, audio, video, and so on).
It supplies the converted result to end users.
The output devices are broadly categorized into two types, shown in Figure
1.4:

Figure 1.4: Output devices category
Generates output as soft copy: These devices generate an electronic
version of the output. For example, a monitor generates an image on
the screen, the speaker generates the sound signals, a file is stored on a
hard disk, and so on.
Generates output as hard copy: These devices generate a physical
version of the output. For example, a printer generates the content of a
file on a page (printout), a plotter plots a high-definition drawing on a
paper sheet, and so on.
Processing unit
The process of performing operations on the data as per the command given
by the user is called processing. The central processing unit (CPU) works as
a processing unit in a computer. It performs the calculations and data
processing operations on the data entered by the input device. It is also
termed the brain as the computer. The major components of the CPU are as
follows:
Arithmetic and logical unit (ALU)
Control unit (CU)
Set of registers
The arithmetic and logic units are responsible for performing arithmetic and
logic functions. The arithmetic functions are addition, subtraction,
multiplication, division, and so on. The logical functions are AND, OR, NOT,
and so on.

The control unit acts as the central nervous system of the computer. It
generates control signals that manage and control all computer components.
The registers are the quickly accusable memory within the CPU. It consists
of a small amount of fast memory. The size of the registers is measured by
the number of bits it can hold, for example, 8-bit register, 16-bit register, 32-
bit register, 64-bit register, and so on. It can be defined as a small memory
within the CPU.
Memory unit
The function of the memory unit is to store the data and instruction/program.
The CPU accesses the data and program from memory and works on it
(processes it). If any intermediate result is generated, it gets stored in
memory, and the final result is also stored in memory.
The memory is divided into cells. Each cell has an address. The CPU
accesses the memory by generating the address of the cell. The working of
memory with the CPU is shown in Figure 1.5:
Figure 1.5: The connections between memory and processor
Computer memory is of two types, which are as follows:
Primary memory/main memory
Secondary memory/auxiliary memory/external memory
Primary memory is temporary storage, and it is also known as working
memory. The CPU directly accesses this memory. It stores all the current
temporary data/instructions while the computer runs. Examples of primary

memory are Random access memory (RAM) and Read-only memory
(ROM).
The secondary memory is not directly connected to the CPU. First, the
primary memory is accessed by the CPU; that is why it is called primary
memory. Second, the secondary memory is accessed. Secondary memory is
non-volatile. Non-volatile memory means that the memory retains data when
the power is switched off. It stores the data permanently. Generally, it is used
in backing (permanent storage) the data so that it can be used in the future.
Secondary memory is slower than primary memory; the data stored in the
main memory is accessed in a nanosecond, and the data from the secondary
memory can be accessed in a millisecond. Examples of secondary memory
are hard disk (HDD), pen drive, compact disk (CD), digital versatile disk
(DVD), and solid-state drive (SSD). Figure 1.6 shows the connectivity of
primary and secondary memory with the CPU:
Figure 1.6: Connectivity of primary and secondary memory with CPU
Data and information
The word data is derived from the word datum, which is singular. Data
consists of raw facts and figures given to the computer as input. The
computer processes the data and converts it into information. Hence, the
information is defined as the processed data. For example, the students’
marks are data; when they are processed, they become the result, which is
information. Another example is that students’ names in a class may be
treated as data when processed and arranged in alphabetical order; it
becomes information. Refer to the following Figure 1.7 for the relation
between data and information:

Figure 1.7: Relation between data and information
Data are composed of numbers, alphabet, and symbols. For example, the
following are the symbols used in making the data.
1, 2, 3..................
A, B, C...............
a, b, c .................
+, -, @ .................
The whole purpose of converting data into information is to get useful
information used to make decisions. It is very difficult to make a decision
based on data. We can differentiate data and information as shown in Table
1.1:
Data
Information
Data is the raw facts and figures composed of symbols like
numbers and the alphabet.
It is processed from the data.
It is unorganized.
It is organized in nature.
It cannot be used directly in decision-making. It has to be
processed first in the form of information.
It can be used directly in
decision-making.
It needs some processing to make decisions.
It does not need any processing
to make decisions.
It is the input to the computer.
It is the output of the computer.
For example, each student’s test score is data.
For example, the average score of
a class is information.
Table 1.1: Difference between data and information
Classification of computers
The computers can be classified on different parameters such as time,
purpose, number of users, the technology used, size, and capacity. The
classifications of computers are given as follows:
Classification based on time, generation, or historical development

Classification based on the purpose
Classification based on the technology used
Classification based on the number of users
Classification based on size and capacity
Classification based on time or historical development
The generations of computers are based on the timeline period. It started
from the time when computers were developed or created. Every generation
has a timeline of 10–20 years and has different technologies used for the
development of computers, except zero generation. There exist six
generations. The classifications of computers in generations are given as
follows:
0th generations computers(the black age or mechanical computers )
1st generations computers(starting of digital computers)
2nd generations computers
3rd generations computers
4th generations computers
5th generations computers
Refer to Figure 1.8 given as follows:
Figure 1.8: Computer generations on the timeline

Zero-generation computers (up to 1945)
They were mechanical computers. All computers or other instruments used
for calculating at that time are placed in this category. Examples of the 0th
generation of computers are Abacus, Napier Bones, Slide Rule, Masculine,
Difference Engine, Analytical Engine, and so on.
Advantages:
They were the fastest-calculating machines of their time.
Disadvantages:
They were limited applications and were used for a specific purpose.
They were hard to operate.
They were purely mechanical devices.
Today, they have been obsolete/no or limited use.
First generation computers (1946–1956)
Vacuum tubes: This generation was the start of the era of digital computers.
They used many vacuum tubes for calculating. They required large space for
installation generally, a room or more than it. They used punch cards for
taking inputs and magnetic drums for storing data, and they were
programmed with low-level language, that is, binary, which is composed of
0 and 1.
Example: Electronic Numerical Integrator and Calculator (ENIAC),
Universal Automatic Computer (UNIVAC), and Electronic Discrete
Variable Automatic Computer (EDVAC) were the first-generation
computers.
Advantages:
They were the fastest machines of their time.
Faster than zero-generation computers.
Disadvantages:
They were bulky in size, hard to operate, highly unreliable, and
difficult to operate.

They generate a lot of heat and hence require a lot of cooling
instruments.
They consume a lot of power.
Second generation computers (1956–1963)
They used transistors for their computing. They were fast and small-sized
computers compared to the previous generation. They used magnetic tapes
and disks for secondary storage. They used punch cards for taking input
generated as printouts. They were programmed with symbolic or Assembly
language, which was composed of special symbols such as SUM, MUL, LOAD,
and so on. Examples: HONEYWELL, IBM-7030, CDC1604, and UNIVAC
LARC were second-generation computers.
Advantages
They were the fastest machines of their time.
The size was less as compared to the first-generation computer.
The speed and fault tolerant capacity was high.
They consume less energy and generate less heat than the first
generation.
Programmed with assembly language.
Disadvantages
They used transistors, which had to be manufactured manually, so the
cost of manufacturing was huge and very expensive.
Third Generation Computer (1964–1971)
They used IC for their computing. One IC is capable of performing the task
of many transistors and vacuum tubes. They were silicon chips that
drastically increased the speed and efficiency of computers. ICs were
smaller, less expensive, faster, and more reliable than transistors. They used
IC with Small Scale Integration (SSI), Medium Scale Integration (MSI),
and Large Scale Integration (LSI). The LSI, MSI, and LSI chip may
contain up to ten, hundred, and thousand electronic components,
respectively.

They used a magnetic core for primary memory and a magnetic disk for
secondary memory. They used a keyboard and mouse for taking input and
monitors for producing output. Examples: IBM 360/370, PDP-8, and PDP-
11 CDC 6600 were third generations computers.
Advantages:
They were the fastest machines of their time.
They were smaller, more reliable, cheaper, and consumed less power.
They had large primary and secondary memory.
Disadvantages:
They got heated very fast, so they needed AC to maintain the
temperature.
Very highly sophisticated technology is required to manufacture the
IC.
Fourth-generation computers (1971–1989)
In 1971, Intel developed its first microprocessor, that is, 4004, consisting of
all the components of the CPU, that is, ALU CU registers, on a single chip.
The microprocessors were the beginner components of the fourth-generation
computers. The microprocessor uses VLSI or ULSI technology. The VLSI
chip may contain up to ten thousand electronic components like transistors
on it.
At that time, memory was very fast. Semiconductor memory and Hard disk
were used for primary and secondary memory. Many new operating systems,
such as WINDOWS, UNIX, and MS-DOS, were developed. They were
programmed with high-level languages such as C, C++, and so on. They
used a keyboard and mouse to input and a monitor to produce output.
Examples: IBM PC, CRAY-1, CRAY-2, and so on are the fourth-generation
computers.
Advantages:
Fastest M/C at their time.
Small, affordable, reliable, low cost, and easy to use than its previous
generators.

Consumed less power and generated less heat.
Large primary and secondary memory.
Disadvantages:
They were not intelligent computers.
Fifth-generation computers (1989 till present)
IC with Ultra Large-Scale Integration (ULSI) technology, human is trying
to develop intelligent computers. The work is still ongoing, and this concept
is known as AI. Some examples of AI are voice reorganization, face
reorganization, machine learning, and so on. High-speed computers such as
supercomputers convert the AI concept into reality. These computers use
ultra-high-speed chips ULSI. The ULSI chips may contain ten thousand to
one million electronic components.
The AI is trying to make a computer that can think like a human or better
than them. But currently, no computers exist that can mimic a human
completely.
Advantages:
Again, they are the fastest machines.
They use the concept of AI.
Smaller, affordable, reusable, low cost, and easy to use than its
previous generators.
Large primary and secondary memories.
Disadvantages:
They are not fully intelligent.
Classification based on the purpose
Based on purpose, computers can be classified into two categories, which
are as follows:
General purpose computers
Spaced purpose computers

General purpose computers
These computers can be used for all kinds of needs of the users. These are
versatile computers capable of processing versatile tasks. Personal
computers (PCs) come under this category. Some of the general tasks are
playing games, listening to music, surfing the internet, typing letters,
designing documents, and so on.
Special purpose computers
They are also known as dedicated computers. The computers are meant for
processing some special tasks of the users. They are designed to perform
some special tasks and cannot perform other tasks. They are not versatile in
nature. For example, ATMs, Traffic light control systems, and weather
forecasting simulators are special-purpose computers that perform a specific
task.
Classification based on the technology used
Based on the technology used, computers are classified into three categories,
which are as follows:
Analog computers
Digital computers
Hybrid computers
The technology-based classification can be given in the following diagram in
Figure 1.9:

Figure 1.9: Technology-based classification of computers
Analog computers
These are special-purpose computers. These computers are used to measure
analog signals. Figure 1.10 shows the relation of the analog signal with time.
The analog signal changes with respect to time, such as current, voltage,
speed, and so on.
Figure 1.10: Analog signal
So, the computers that measure these signals are known as analog
computers. For example, speed is measured by a computer known as
Speedometer; Ammeter measures the Current; a Voltmeter measures voltage;
pressure is measured by a Barometer, and so on.
Digital computers

These are the general-purpose computers. Digital computers are used to
process digital (discrete) signals, that is, 0 and 1. Although the user enters
the data in decimal or characters or some symbols, it is converted into digital
form. Examples of digital computers are PCs, Laptops, and so on. Refer to
Figure 1.11 for the digital signal:
Figure 1.11: Digital signal
Hybrid computers
They are a combination of digital and analog computers. They process both
analog and digital signals. They use analog-to-digital and digital-to-analog
converters. Examples of hybrid computers are ATM machines, money
counting machines, ultrasound machines, petrol and diesel measuring
machines at petrol pumps, and so on.
Furthermore, digital computers are categorized into the following four types:
Micro-computers: They use a microprocessor (a chip containing all
components of the CPU) as their CPU. These computers are single
users, small in size, have low memory, and perform simple tasks.
Examples are PCs and laptops.
Mini-computers: Mini-computers are faster and more powerful than
micro-computers. These computers are designed to handle single users
as well as multi-user. However, the number of users is limited. These
computers are middle-range computers and more costly than Micro-
computers. These computers have more memory than Micro-
computers and perform complex tasks. Example: PC and Laptops.
Mainframes: Mainframes are more powerful than mini-computers.
Generally, they are used as a server. These multi-user computers have
more processing power and memory than mini-computers. They are

used in large organizations such as universities, banks, railway and
airline companies where a large number of users access their databases
frequently. Examples: Servers, IBM S/390, Amdahl 58, and so on.
Supercomputers: These computers are the fastest, most powerful, and
most expensive among all computers. Supercomputer process a large
amount of data and is used to solve scientific problems where fast
computation is required. Examples: Irtysh and Mihir are the fastest
supercomputers in India. They are used in the field of climate
monitoring 
and 
weather 
forecasting. 
Other 
examples 
of
supercomputers are Frontera, Tanhe-2, and Summit, and so on.
Classification based on the number of users
Based on the number of users interacting with the computer at the same
time, the computers are classified into two categories, which are as follows:
Single-user machines: In these computers, one user can interact with
the computer at a time and perform their tasks. Examples are laptops,
desktops, palmtops, smartphones, and so on.
Multi-user computers: They are capable of executing/handling the
tasks of many users at a time simultaneously. Examples are servers,
mainframes, and supercomputers.
Computer characteristics
Today, modern computers have the following characteristics:
Automatic: Computers are automatic in nature in the sense that they
can perform a task without any user intervention. The users just need
to assign the task to the computer, after which it automatically finishes
the task according to the program’s instructions stored in it and
produces the final result.
Speed: The computer is a very fast computing machine. It can perform
millions of operations per second. The speed of the computer can be
measured in terms of Millions of Instructions Per Second (MIPS),
Floating Point Operations Per Second (FLOPS), Cycle Per
Instruction (CPI), Instruction Per Second (IPS), and so on.

Accuracy: The computers provide 100% correct results. Provided that
the correct data and programs are input into it. It works on the
principle of garbage in garbage out (GIGO), which means if you
provide garbage (wrong data or program) to the computer, you will
receive garbage (wrong result). It is clear from the GIGO principle
that the output produced by the computer totally depends upon the
input data and program.
Versatile: The role of computers in the current era is multi-
dimensional (versatile). It can perform multiple tastes, for example, in
calculation, entertainment, business, gaming, training, and simulation.
So, it is a versatile machine.
Diligence: It can perform the same task repeatedly without getting
tired of it with the same degree of accuracy and reliability as the first
one. So, unlike a human, it never gets tired, lacks concentration, and is
free from emotion.
Zero IQ: The IQ of a computer is zero because it cannot perform any
task itself and has no decision-matching capacity. However, humans
are trying to make computers intelligent with the help of artificial
intelligence concepts.
Memory: The computer can hold data without losing it for several
years in secondary memory. The stored data can be retrieved and used
whenever required. It does not lose data until it is asked to do so. The
same data can be accessed after several years as accurately as on the
day when it was fed into the memory.
Economical: Computers can give more benefits than their cost if used
properly in terms of saving time, money, and energy. For example, if
we want to send a mail or document by ordinary mail, it will take
more time than an e-mail that sends it instantly.
Figure 1.12 shows the characteristics of a computer:

Figure 1.12: Characteristics of computer
Advantages of the computer
Let us discuss some of the advantages of computers as follows:
It can perform complex calculations very fast.
It can store useful information for a long time.
It performs the task itself, that is, automation, by providing data and a
program.
It can provide information to the user.
It can perform repetitive work very fast.
It helps to sort, organize, and search for a large amount of information.
It saves a lot of time by doing tasks quickly compared to humans.
It increases connectivity, that is, through the internet, telephone,
mobile, and so on.
Limitations of computer
The following are the limitations of computers:
A computer does not have common sense as it has zero IQ. It cannot
make decisions itself.

The computer cannot correct the wrong program.
The computer is dependent on human programs.
Data and information security is a major issue related to computers.
The unauthorized access of information for some illicit purpose.
Virus and hacking attacks may steal or damage your information
without your intimation.
Long sitting on the computer may generate health issues such as eye
weakness, back pain, and so on.
It increases cybercrime.
Applications of computer
A computer is a versatile device. It can perform multi-dimensional tasks. In
the present era, the computer is a necessity for everyone. Initially, computers
were developed for a specific purpose, that is, for large and complex
calculations. But nowadays, it has become a general-purpose machine. Some
of the applications of computers are shown in Figure 1.13:
Figure 1.13: Application of computer
Word processing: One of the major applications of computers is word
processing. It creates, organizes, reads, and writes Word documents.
Some word processing software are MS Office, PDF reader, and so on.

Communication: In today’s world, the computer is used to transmit
our data very fast with the help of the internet. Some of the modes of
communication are e-mail, social networking, video calling, and so
on.
Entertainment: Today, the computer is not limited to calculation. It is
also used for entertainment purposes. Some examples are computer
games, watching movies, and listening to songs, and so on.
Education: Today, the computer is a necessity for a teacher as well as
for the student. The computer helps the students in the classroom
(smart classes) and outside the class to grab the concept efficiently.
Some of the applications of computers in education are online
libraries, e-books, education websites, e-learning, video lectures, video
demonstrations, and so on.
Science and technologies: The computer is very helpful for
performing scientific calculations with speed and accuracy. It is used
for scientific experiments, collecting and analyzing data, and so on.
The computer is also used in a simulation for training and testing.
Banking: The computer is the backbone of the banking system as the
world is moving towards a cashless society. A person can perform all
kinds of transactions without going physically to the bank through E-
banking anytime and anywhere. Your money always remains with you
round the clock.
E-commerce: E-commerce is also known as electronic commerce. It
is the process of buying and selling products through the internet
(online). A buyer can buy products online without going to market
physically, and a seller can sell his product without opening a
shop/market. The funds are transferred with the help of E-Banking,
that is, online banking/credit card/debit card, and so on.
Online reservation: Today, we can book or buy our e-ticket online for
buses, rails, and airplanes for travel. For example, IRCTC is a
platform for buying e-tickets for the Indian railway.
Weather forecasting: The huge amount of data received from
satellites or data for weather forecasting, such as images, temperature,

pressure, and so on, are processed by the computer, and the accurate
result is given, which is used for weather forecasting.
Research: For conducting research, the computer is the mandatory
device. It is used for all research activities such as problem
identification, review of literature, sample collection, research design,
analysis of data, and conducting of experiments.
Automation industries: A robot is a computer-controlled machine
that is used to perform tasks automatically in extreme conditions, such
as in high temperature and high-pressure conditions, without human
interference.
Conclusion
This chapter elucidates the basic component of computers, which includes
the fundamental components of the computer like the input unit, output unit,
memory units, and the CPU. It also focuses on the working of computers and
their units, computer applications, and limitations. It also focuses on the
detailed classification of the computer-based on time, historical
development, purpose, the technology used, and the number of users.
Various characteristics of the computer, such as speed, versatility,
automaticity, and diligence, are also discussed in it.
The upcoming chapter describes the CPU and its components, the memory,
and its types. It also focuses on how the instructions are fetched from the
memory and executed by the CPU. The memory hierarchy measuring the
memory is also discussed in it.
Points to remember
A computer is an electronic device that takes data and commands
(instruction) as input from the user, processes the data, and produces
information as output.
The computer follows the input–process–output cycle.
Computer units are connected via system buses (wires). There are
three main buses: the data bus, the control bus, and the instruction bus.

CPU is known as the brain of the computer.
The control unit acts as the central nervous system of the computer.
The registers are the quickly accusable memory within the CPU.
Primary memory stores all the current temporary data/instructions
while the computer runs.
Secondary memory is used in backing (permanent storage) the data so
that it can be used in the future.
Data is the raw facts and figures composed of symbols like numbers
and the alphabet. It is unorganized in nature.
Information is processed from the data.
Zero-generation computers were mechanical computers.
First-generation computers used many vacuum tubes for calculating
Second-generation computers used transistors for their computing.
Third-generation computers used IC for their computing.
Analog computers are used to measure analog signals.
Digital computers are used to process digital signals, that is, 0 and 1.
Hybrid computers are a combination of digital and analog computers.
Microcomputers use microprocessors (a chip containing all
components of the CPU) as their CPU.
Mini-computers are faster and more powerful than micro-computers.
Mainframes are more powerful than mini-computers.
Supercomputers are the fastest, most powerful, and most expensive
among all computers.
In single-user computers, one user can interact with the computer at a
time.
Multi-user computers are capable of executing/handling the tasks of
many users at a time simultaneously.

The speed of the computer can be measured in terms of MIPS,
FLOPS, CPI, IPS, and so on.
The computers provide 100% correct results. Provided that the correct
data and programs are input into it.
Computers are versatile. That is why they can perform multi-
dimensional tasks.
The IQ of a computer is zero.
Computers follow the principle of GIGO.
Important questions
1. What is a computer? Explain its components. Give its application
worldwide
2. Differentiate between data and information. Which one is beneficial?
3. Differentiate between primary memory and secondary memory.
4. What is a Bus? Explain its types.
5. What are various computing devices used in different generations?
Explain.
6. What is IC? Give its different types.
7. Explain the generations of the computer. Compare the generations
with each other. Which one is better and why?
8. Classify the computers based on their historical development,
purpose, the technology used, number of users, and size.
9. Discuss the difference between microcomputers and mini-computers.
10. Compare the supercomputer and mainframe computers. Also, write
their application areas.
11. Write the various characteristics of a computer.
12. What is the GIGO concept? Explain it.

CHAPTER 2The CPU and the Memory
Introduction
This chapter will delve into the heart of computer systems—the Central
Processing Unit (CPU) and its pivotal role in executing instructions. We
will uncover the intricate workings of the CPU, the steps it takes to execute
a single instruction, and the importance of CPU speed. Additionally, we
will explore memory units, from the swift primary memory to the
capacious secondary memory, and how they form the foundation of a
computer’s memory hierarchy.
Structure
In this chapter, we will be discussing the following topics:
Central processing unit
The instruction on CPU: working of CPU
Steps performed for the execution of single instruction
The CPU speed
The memory unit
Primary memory
Secondary memory
Memory hierarchy
Measuring the memory
Objectives
The objective of this chapter is to provide a comprehensive understanding
of fundamental computer hardware components and their interplay. Readers
will gain insights into the Central Processing Unit (CPU) and its instruction
execution process, grasp the significance of CPU speed, explore various
memory units, comprehend memory hierarchy, and learn how to measure
and manage computer memory effectively.
The CPU

The process of operating on the data as per the command given by the user
is called processing. The Central Processing Unit (CPU) works as a
processing unit in a computer. It performs the calculations and data
processing operations on the data entered by the input device. It is also
termed as the brain of the computer.
Components of the CPU
The major components of the CPU are as follows:
Arithmetic and logical unit (ALU)
Control unit (CU)
Set of registers
ALU
The arithmetic and logic unit is responsible for both arithmetic and logic
functions. The arithmetic functions are addition, subtraction,
multiplications, divisions, and so on, and the logical operations are AND,
OR, NOT, and so on.
CU
The control unit serves as the computer’s nervous system. It generates
control signals that manage and control all computer components. For
example, to add two numbers, it performs the following operation:
Fetches (retrieves) the numbers to be added from memory.
Fetches the instruction from memory (the instruction is addition in this
case).
Decodes the instruction.
Asks the ALU to operate as per the instruction.
Stores the final result in memory.
Registers
The registers are the small-sized, quickly accessible memory within the
CPU. It consists of a small amount of fast memory. The size of the registers

is measured by the number of bits it can hold, for example, 8-bit register,
16-bit register, 32-bit register, 64-bit register, and so on. A computer with a
large register can process more information and vice versa. Registers can
be grouped into two groups, which are as follows:
General Purpose Registers (GPR): GPR can hold data and addresses.
A data register can hold data, and an address register can hold an
address. A GPR is a register that can hold both.
Special Purpose Register (SPR): SPR is the register meant for some
special purpose. Generally, they hold the state of the program. Some
of SPR are as follows:
Program Counter (PC) Register: The address of the next
instruction to be executed is stored in the PC.
Memory Address Registers (MAR): This register stores the
address of the memory region from which data is retrieved or
stored.
Memory Data Register (MDR): It works as a buffer between
memory and CPU.
Accumulator (AC): It interacts with ALU and stores input/output
results.
Instruction Register (IR): It holds the current instruction being
executed.
The instruction on CPU: Working of CPU
A computer’s primary function is to run a program (set of instructions). The
format of the instruction is shown in Figure 2.1. According to Von
Neumann’s architecture of computer or stored program concept, the data
and instructions (program) are kept in memory. The CPU must conduct the
following two steps in order to process an instruction:
In the fetch cycle, the CPU reads (fetches) an instruction from
memory.
The instruction is executed by the processor in the execution cycle.
An instruction consists of two parts, which are as follows:
Opcode: Operation Code

Operands
Figure 2.1: An instruction formats
The Opcode specifies what is to be done, such as addition, multiplication,
division, and so on. It stands for Operation Code. The operands specify the
data/address on which the Opcode will be applied. Consider the following
arithmetic expression:
a = b + c
Here, a, b, and c are operands, and +, = are the Opcodes. An instruction is
executed by the processor with the help of an instruction cycle or a
machine cycle. A machine cycle is composed of the following two cycles.
It is represented by Figure 2.2:
Fetch cycle
Execute cycle
Machine cycle = Fetch cycle + Execute cycle
Figure 2.2: A machine cycle
First, the CPU fetches the instruction and the data from the memory;
second, it executes and produces the result. The basic model for an
instruction/machine cycle is given in Figure 2.3:
Figure 2.3: The basic instruction cycle
Fetch cycle: The following steps are required to fetch (read) the instruction
from memory. Figure 2.4 represents the fetch cycle:

1. The address of the next instruction is loaded (address) from PC to
MAR.
2. MAR places the addresses on address buses.
3. The control unit sends a read signal to the memory.
4. Memory places the data in the Memory Data Register (MDR).
5. The program counter (PC) is incremented by 1.
6. The instruction is transferred to IR.
Figure 2.4: The instruction fetch cycle
Execution cycle: The execution cycle is responsible for the execution of the
instruction by the ALU. It contains the following steps:
1. Transfers the operand of IR to MAR.
2. The data is fetched into ALU from the memory location pointed out
by MAR.
3. The operation specified by the decoder is performed on the data in
ALU.
The CPU repeats the instruction fetch-decode-execution cycle until the halt
instruction of the program is executed. The execution cycle is represented
in Figure 2.5:
Figure 2.5: The execution cycle
Steps performed for the execution of single instruction

When the CPU executes an instruction, it has to follow a series of steps,
which are given in Figure 2.6. Let us take the instruction of the addition of
two numbers. Here, the instruction is ADD, and the data are 50 and 60. The
CPU fetches and executes one instruction with every tick of the clock. If
the CPU completes one machine cycle in one second, it is termed one hertz.
The following steps are performed for the execution of one instruction.
1. Fetch instructions and data from the main memory.
2. Decode instruction.
3. Execute instruction, that is, ADD.
4. Store the result in the main memory.
Figure 2.6: Machine cycle
The CPU speed
The speed of the CPU is measured in terms of IPS, which stands for
“instructions per second.” This indicates how many instructions are
finished in one second. There are primarily three things that influence how
quickly a CPU can finish executing instructions: clock speed, the number
of cores employed, and cache memory.
The clock speed
The clock speed refers to the rate at which the CPU can execute
instructions. It is measured in Hz (Hertz). A clock governs CPU operation.
The CPU retrieves and carries out one instruction with each tick of the
clock. Cycles per second are the unit of measurement for the speed of the
clock, and one hertz is equal to one cycle per second. When a CPU has a
greater clock speed, it can process instructions at a faster rate. Processor
running at 3.6 GHz executes 3.6 billion cycles per second. The speed of the
older processors was measured in megahertz millions of cycles per second).
The total number of processor cores

The CPU is comprised of an element known as the core. A CPU typically
consists of a single-core processor. Most contemporary central processing
units feature two, four, or even more cores. For instance, a dual-core CPU
contains two cores, whereas a quad-core CPU contains four cores. A
single-core processor can only fetch and carry out one instruction at a time,
whereas a dual-core processor can fetch and carry out two instructions at a
time. A CPU with four cores can execute even more instructions in the
same amount of time than a processor with only two cores.
Cache memory
A cache is a short-sized memory that operates at a very fast speed and is
located on the CPU. It contains the data and instructions that are used again
and again. The larger the cache is, the faster the frequently used
instructions and data may be transferred into the processor and utilized.
This is because more space is dedicated to storing them in the cache.
The memory unit
Memory units are responsible for not only storing data but also instructions
or programs. The data and the program are both retrieved from memory by
the central processing unit (CPU), which then performs operations on them
(processes them). If there are any intermediate results produced, these will
also be preserved in memory. The final result that is generated by the CPU
is saved in the memory. Figure 2.7 illustrates the connection between
memory and the processor.
Figure 2.7: The connection between memory and processor
Computer memory is of two types, which are as follows:
Primary/main/working memory
Secondary/auxiliary memory/external memory
Primary memory

Primary memory is temporary storage, also known as working memory or
main memory. This memory is directly (primarily) accessed by the CPU,
which is why it is known as primary memory. It stores all the current
temporary data/instructions while the computer runs.
Primary memory is further categorized into the following three parts:
RAM
ROM
Cache memory
Generally, RAM is considered primary memory. It is volatile (the data is
erased when the computer is switched off) in nature. The secondary
memory is not directly connected to the CPU. It is also called auxiliary
memory or tertiary memory.
RAM
RAM is an abbreviation for random access memory. It stores data as well
as instructions before the execution by the CPU and the result after
execution by the CPU. It is known as random access because the stored
content can be directly accessed from any location randomly or in any
order. The data which is currently used by the CPU is placed in it. It holds
data or instruction temporarily as it is said to be volatile in nature (erased
data when the power goes off or turned off). It needs a constant power
supply to retain data. In order to run data or a program in a computer, it
must load first in RAM. If the memory (RAM) is too low, it might be
unable to hold all the necessary data or programs that the CPU needs.
When this happens, the CPU has to access the required data from the
secondary memory, which is very slow and leads to slowing down the
computer. So, to solve this problem, you only need to increase the size of
the RAM in a computer. There are the following two types of RAM:
Static RAM (SRAM): The major components used for storing data in
SRAM are transistors. SRAM chips are used as cache memory in the
computer. SRAM is faster than DRAM. SRAM is more costly than
DRAM. SRAM occupies more space than DRAM. Hence, the data
density is low in SRAM compared to DRAM. Generates more heat as

compared to DRAM. Leaking of charge does not happen in SRAM;
hence, refreshing is unnecessary, as in DRAM.
Dynamic RAM (DRAM): The major components used for storing data
in DRAM are capacitors. As the capacitor leaks charge over time, it
needs charging repeatedly; this concept is known as refreshing. So,
refreshing is required in DRAM. The refreshing makes the DRAM
slower than SRAM. DRAM is used as the RAM in the computer.
DRAM is cheaper than SRAM. The data caring density is more than
SRAM. Hence, it occupies less space. Generally, less heat is generated
as compared to SRAM.
ROM
ROM stands for read only memory and comes under primary memory. It is
a non-volatile memory as it retains the data when the power goes off or is
turned off. It does not require a continuous power supply to keep the data.
It is a permanent memory. ROM stores fixed start-up instructions used for
the booting process (to start the computer when power is turned on). ROM
is only readable and cannot be written or erased by the computer user. It is
written only once. The manufacturer of the computer stores the start-up
instructions in ROM. The computers contain a small amount of ROM that
stores programs such as the basic input–output system (BIOS), which is
used to boot up the computer when it is turned on. In the booting process,
the operating system gets copied from secondary memory to primary
memory.
Initially, ROM was read-only memories. So, in order to update the program
stored in them, the ROM chips had to be removed and replaced by other
updated ROMs containing the newer programs. But today, ROM chips are
not only read-only. They can be erased or updated as erasable ROMs are
available. The ROM chips are of the following types.
Programmable Read-Only Memory (PROM): It is also known as a
one-time programmable ROM. PROM is written/programmed with a
special device known as a PROM programmer. In PROM, the data is
programmed at once and cannot be updated or deleted. The working of
PROM is similar to CD-ROM, where data is written in CD-ROM by a
CD-writer. The recorded data can be read multiple times but written

only once. Therefore, programming a PROM is also called burning,
just like burning a CD-R. It is commonly used in PCs to start up
programs and BIOS settings. These programs are known as firmware.
Erasable PROM (EPROM): It can be erased and re-
programmed/rewritten. The chip of EPROM can be erased by placing
it in ultraviolet light, typically for ten or more minutes, and again can
be written with a process of burning that requires high voltage.
EPROM is more useful than PROM. It can be compared with CD-RW,
which is a reusable memory. EPROM is widely used in personal
computers. EPROM is also used to store data in scientific instruments.
It is also known as Ultraviolet EPROM (UV-EPROM).
Electrically Erasable PROM (EEPROM): It can be erased and
rewritten with the help of electricity. The process of writing an
EEPROM is known as flashing*. E2PROM also represents it. It is also
a form of non-volatile memory.
*Flash memory is a type of EEPROM in which the data is erased
under the control of software. It is the most flexible memory under
ROM because the data can be easily erased and written. It is used in
memory cards, pen drives, MP3 players, internal memory of
smartphones, digital cameras, and so on.
Secondary memory
The secondary memory is a permanent memory that holds the data and
programs that are not currently used. It provides long-term storage. It holds
the data or program that may be used in the future. It is used for storing
data and the program for backup purposes. It holds the data even when the
computer is switched off, so it is non-volatile.
The secondary memory is not directly connected to the CPU. First, the
primary memory is accessed by the CPU; that is why it is called primary
memory. Second, the secondary memory is accessed if data is not found in
the primary memory. Secondary memory is slower than primary memory,
that is, the data stored in the main memory is accessed in a nanosecond, and
the data from the secondary memory can be accessed in a millisecond.
Secondary memory can be categorized in two ways.

Secondary memory is further categorized into the following types:
Serial accessed memory—Magnetic tape.
Semi random memory—Hard disk, optical disk, and magnetic disk.
Some secondary memory devices are offline devices—those on which data
is recorded and physically removed or disconnected from the computer, for
example, CD, DVD, Magnetic tape, and so on. The online memory cannot
be physically removed or disconnected from the computer, for example,
RAM, ROM, and so on. The broad classification of computer memory can
be given in Figure 2.8:
Figure 2.8: Memory classifications
Figure 2.9 shows the connection between different memories and
processors:
Figure 2.9: Connection between different memories and processor
Serial accessed memory: Magnetic tape
It provides serial access to data from memory; for example, if we have to
access the Nth data location, then we have to traverse all previous N–1
locations first. Magnetic tape is a good example of serial-accessed memory.
The magnetic tape is made from a plastic reel (tape) covered with a
magnetic material layer (magnetic oxide). Magnetic tapes are available in
the form of cassettes, reels, and cartridges.
Magnetic tape storage capacity = data recording density * tape length
The quantity of data that may be stored on a particular length of tape is
referred to as the data recording density. It is expressed in bpi (bit per inch).
A magnetic tape drive reads and writes data on magnetic tapes. It is made
up of a read/write head and an erase head. The pre-recorded data is erased

by the erase head and recorded/written by the write/read head. Figure 2.10
shows the block diagram of magnetic tape:
Figure 2.10: Magnetic tape
Semi-random accessed memory
It follows both sequential access and a random-access method to access the
data. The magnetic (hard disk, floppy disk) and optical (CD and DVD) are
semi-random accessed memory. A disk is divided into tracks and sectors.
The concentric circles are known as tracks. The pie-shaped areas separated
by the line are known as sectors. The data are stored on the surface in
tracks and sectors. Figure 2.11 shows the tracks and sectors on the disk:
Figure 2.11: Tracks and sectors on the disk
Magnetic disk: A magnetic disk consists of a circular platter (plate) of
plastic/aluminum coated with magnetic material (iron oxides). It uses
a magnetization process to write, rewrite, and access data. A magnetic
disk is divided into tracks and sectors. The write-read head is used to
read/write the process of a magnetic disk. The movement of the
write/read head is used to access different sectors. Hence, it is a semi-
random-access process. The magnetic disk rotates along the axis
(spindle) to the read/write process. Figure 2.12 shows the disk with the
read/write head:
Figure 2.12: Disk with read/write head
Hard and floppy disks are examples of magnetic disks, and their working
mechanism is almost similar.
Hard disk: A hard disk is a set of magnetic disks/platters grouped on a
rotating spindle. The disks are covered with magnetic material. A two-

layer disk is coated on both sides, and two read/write heads are
required to read and write data on both surfaces. The disk is divided
into tracks and sectors. The tracks are concentric circles, as shown in
Figure 2.12. These concentric circles are divided into a number of
sectors (The pie-shaped area on the disk).
The hard disk consists of many magnetic disks mounted on a spindle.
The read/write head is required on all the surfaces of a disk. All the
heads are attached to a single access arm, so they cannot move
independently. The parts of the hard disk are shown in Figure 2.13:
Figure 2.13: Hard disk internal structure
Each platter (disk) has the same number of tracks; all of these are the
same distance from the spindle to form a cylinder. A cylinder simply
consists of one track from each surface, where different platters’ tracks
are accessed simultaneously by different heads.
Optical disk: The optical disks use a beam of laser light to read and
write the data on the flat circular disk coated with a special material
(often aluminum). Writing the data on the disk is known as the
burning of the disk because the laser light burns the material coated on
the disk while writing the data on the disk.
The data is stored in the form of land (binary one or on (due to
reflection)) and pits (binary zero or off (lack of reflection)) on the
surface of the disk formed by the laser beam. Figure 2.14 gives the
optical disk surface with lands and pits.
Figure 2.14: CD (optical disk surface)
Also, the optical disk is divided into tracks and sectors. CD and DVD are
the two most popular forms of optical disks.

Memory hierarchy
In this modern computer, the arrangement of memory with the CPU is
known as memory hierarchy. These memories are organized in a hierarchy
around the CPU to enhance performance and reduce the cost of the
computer. So, in the memory hierarchy, the memory is placed on different
levels in the computer. The higher level (near CPU) memory is fast and
costly, and the storage capacity is low. Whereas at the lower level (far too
CPU), the memory is slow and cheap, and the storage capacity is very high.
The higher-level memory includes CPU registers, cache memory, main
memory, and so on, whereas the lower-level memory includes secondary
memory, that is, magnetic disk, optical disk, magnetic tape, and so on.
The memory hierarchy is given in Figure 2.15. When we look from top to
bottom in the memory pyramid, the speed and cost of memory decrease;
that is, 1 GB of main memory is costlier than 1 GB of secondary memory.
The access time of the cache is less than the main memory, whereas the size
is increased; that is, the size of the cache is less than the size of the main
memory.
Figure 2.15: Memory pyramid: memory hierarchies
The flip flops or latch is responsible for holding 1 bit of data, either 1 or 0.
Flip flops are the key component for making CPU register. CPU Registers
are located inside the CPU and, therefore, directly accessed by the CPU.
The CPU register stores a word of data (8, 16, 32, 64-bit, and so on).
Cache memory is located between ultra-fast registers and main memory. It
holds the frequently used data that are used by the CPU again and again. It
is made up of SRAM chips. Holding repeatedly required data avoids
accessing slower memory (DRAM—main memory) by the CPU, which
enhances the computer’s performance as SRAM chips are faster than
DRAM chips. The cache memory is generally divided into levels:
L1 cache: Present on the CPU chip (Internal cache).

L2 cache: Built outside the CPU, on the motherboard, the size is
greater than L1.
L3 cache: Extra cache, not normally used, built outside of the CPU on
the motherboard. L3 is larger than the L1 and L2 cache but faster than
the main memory.
The sizes of cache memory are generally in KB and MB. The connection of
memories with the CPU is given in Figure 2.16 (address, data, and control
buses).
Figure 2.16: Connection of memories with CPU
Main memory: It can hold data in GB (Giga Byte). The modern
computer has 4GB, 8 GB, and 16 GB of RAM. The main memory
(RAM) is also present inside the computer and cannot be separated
from it. It is present on the motherboard.
Secondary memory: It can hold data in TB (Tera Byte). The modern
compiler has 1TB, 2 TB, and 4 TB storage. It can be internal (online)
or external (offline). It is treated as infinite memory because it can be
added to the computer when required.
Measuring the memory
The smallest unit for measuring memory is a bit. One bit means 0 or 1. The
combination of four words is known as the nibble, and the combination of
eight words is a byte. The following Table 2.1 contains the detail of
memory units.
Name
Description In base 2
In base 10 Symbol
1 Bit (Binary Digit) 0 or 1
0 or 1
–
Bit

Name
Description In base 2
In base 10 Symbol
1 Nibble
4 bits
22 Bits
–
Nibble
1 Byte
8 bits
23 Bits
–
B
1 Kilobyte
1,024 Byte 210 Bytes 103 Bytes KB
1 Megabyte
1,024 KB
220 Bytes 106 Bytes MB
1 Gigabyte
1,024 MB
230 Bytes 109 Bytes GB
1 Terabyte
1,024 GB
240 Bytes 1012 Bytes TB
1 Petabyte
1,024 TB
250 Bytes 1015 Bytes PB
1 Exabyte
1,024 PB
260 Bytes 1018 Bytes EB
1 Zettabyte
1,024 EB
270 Bytes 1021 Bytes ZB
1 Yottabyte
1,024 ZB
280 Bytes 1024 Bytes YB
1 Brontobyte
1,024 YB
290 Bytes 1027 Bytes BB

Name
Description In base 2
In base 10 Symbol
1 Geopbyte
1,024 BB
2100 Bytes 1030 Bytes GeB
Table 2.1: Description of memory units and their relationship
A computer uses words to store information. A word, like a byte, is a
defined number of bits that are processed at the same time. The size of the
word varies from computer to computer. Like 8-bit, 16-bit, and so on.
Solved examples based on the inter-conversion of memory units
1. How many bytes are in 8MB?
Explanation: (8)* (1024)*(1024) bytes
8,388,608 bytes.
2. How many bits are in 1 gigabyte:
Explanation: (1,024) × (1,024) × (1,024) × 8 bits
3. How many bits are in 8 GB?
1. 8*210 B
2. 8*230 B
3. 8* 220 B
4. 8*240 B
Answer: b
4. A 20 GB is equal to
1. 20*1,024 MB
2. 20*1,024 KB
3. 20*1,024 TB
4. 20*1,024 bytes

Answer: a
5. Which of the following represents one billion characters?
1. 1 TB
2. 1 KB
3. 1 MB
4. 1 GB
Answer: d
Explanation: 1 GB=109 byte = one billion bytes where one byte is
equivalent to one character
6. If one GB equals 230 bytes of data storage, then 1,024 TB
equals............. bits of data storage.
1. 260
2. 253
3. 250
4. 240
Answer: b
Explanation: 1,024 terabytes = 210*240 *23 Bits=253 bits
7. If you have a storage device of 16 GB, then how many 32 kilobytes of
files can you fit in that device?
Explanation: Storage device =16 GB
File size = 32 KB
Number of file can be fit =16 GB/32 KB =(24*230)/(25*210)=219 files
8. 22,000 KB is about how many MB?
22,000 KB = 22 MB

9. Which of the following is equivalent to 8 GB?
1. 223
2. 233
3. 230
4. 228
Answer: b
Explanation: 8GB = 23*230 Bytes=233 Bytes
10. One person has 1,700 MB of data, and another person B has 1,500 MB
of data. Will a pen drive size 4 GB of size hold the data of persons A
and B together?
Answer: 1,700 MB+1,500 MB = 3,200 MB = approximately 3.2GB.
So, the pen drive of size 4 GB can hold the data.
11. How many 3 MB images fit on a 30 GB pen drive?
Explanation: Convert both in one unit, say in MB
30 GB=30*1,024*MB
(30*1,024*MB)/3MB=10*1,024=10,240 images
12. Rank from largest to smallest
1. 512M bytes
2. 8 K bytes
3. One billion bytes
4. 1 TB
Answer: 1TB > one billion bytes > 512M bytes > 8K bytes
Explanation: Convert all into the same unit, that is, bytes:
1. 512M bytes= 29*220 bytes= 229 bytes
2. 8 K bytes= 23*210= 213 bytes

3. One billion bytes=230 bytes
4. 1TB=240 bytes
Conclusion
This chapter comprehensively overviews a computer system’s CPU and
memory unit. We explored the inner workings of the CPU, including its
instructions and the step-by-step execution of a single instruction.
Understanding how the CPU operates is crucial for comprehending the
overall functioning of a computer system. We also discussed the concept of
CPU speed, highlighting its significance in determining the efficiency and
performance of a computer. We examined the primary and secondary
memory units, which play vital roles in storing and retrieving data.
Additionally, we explored the concept of the memory hierarchy, which
involves organizing memory in different levels based on its speed, size, and
capacity. Finally, we explored methods for measuring memory, allowing us
to quantify and analyze the storage capacity of computer systems. This
chapter provided a solid foundation for understanding the core components
of a computer system and their interactions, paving the way for further
exploration in subsequent chapters.
The upcoming chapter will discuss computer software and its classification
on various parameters. It will also give a basic introduction to the operating
system and its classifications on different parameters such as the execution
of the program, number of users, and interface. Additionally, we will
explore the concept of malicious programs.
Points to remember
The CPU processes input device data. It is the computer’s brain.
The ALU performs arithmetic and logic operations. 
The CU acts as the computer’s central nervous system, generating
control signals to manage and control all components.
Registers are fast, accessible memory within the CPU, holding a small
amount of data measured by the number of bits it can store.
The PC register stores the next instruction’s address.

The MAR holds the address of data or instructions that need to be
accessed from or written to the main memory.
The MDR works as a buffer between memory and CPU.
The accumulator interacts with ALU and stores its input/output
results.
The current instruction being executed is stored in the IR.
Machine cycle = Fetch cycle + Execute cycle.
The clock speed refers to the CPU’s instruction execution rate,
measured in Hz (hertz). A dual-core processor contains two cores
(processing elements).
A cache is fast and located between the CPU and the main memory.
L1 is placed on the CPU. The L2 and L3 are placed outside the CPU.
Primary memory is fast and volatile memory and is directly accessed
by the CPU.
The major components used for storing data in SRAM are transistors.
The major components used for storing data in DRAM are capacitors.
ROM is an acronym for read-only memory.
PROM is an acronym for programmable read-only memory.
EPROM is an acronym for erasable programmable read-only memory.
EEPROM stands for electrically erasable PROM and is commonly
used in flash memory, memory cards, pen drives, smartphones, digital
cameras, and more.
The secondary memory is permanent.
The magnetic disk consists of a circular platter (plate) coated with
magnetic material.
A hard disk is a set of magnetic disks grouped on a rotating spindle.
Optical disks use a laser beam to read and write data on a flat, circular
disk coated with a light-sensitive material, typically aluminum.
Memory arrangement with the CPU to enhance performance and
reduce cost is known as memory hierarchy.
The flip flops or latch is responsible for holding 1 bit of data, either 1
or 0.
The smallest unit for measuring memory is a bit.
Important questions
1. What is a microprocessor? Write its components.

2. What is the purpose of providing registers in a CPU? Discuss various
registers which are usually provided in a microprocessor.
3. What is clock speed? What are its units of measure?
4. What are single, dual, and quad processors?
5. Describe the instruction cycle. Also, focus on fetching and executing
the cycle.
6. Write the parts of instruction formats.
7. What exactly do you mean by computer memory? Distinguish
between primary and secondary memory.
8. What is memory hierarchy? Why is it created?
9. What is BIOS? Which kind of memory is preferred in it, and why?
10. What is RAM? Differentiate between static RAM and dynamic RAM.
11. How does the CPU access a memory cell? Explain with fetch and
execute cycle.
12. Explain the working of a magnetic disk.
13. How is data stored on optical storage devices?
14. What is a flash memory drive? Write its application.
15. Briefly discuss the importance of cache memory.
16. What is ROM? Explain its types.
17. Discuss the different types of optical storage devices.
18. How would you calculate the size of magnetic tape?
Join our book’s Discord space

Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 3
The Computer Software
Introduction
This chapter explores computer software and operating systems, the
foundation of modern computing. It covers software classifications and the
operating system’s role as a resource manager. The diverse types of
operating systems, language translators for programming languages, and the
threat of malware are also discussed. By understanding these topics, readers
will gain insights to navigate the digital landscape more effectively.
Structure
In this chapter, we will cover the following topics:
Computer software
Examples of system software
Classifications of software depending on the proprietary rights
The operating system
The operating system as a resource manager
Classification of operating system
The language translator
The malware

Objectives
This chapter aims to provide a comprehensive understanding of computer
software and operating systems. It covers system software examples,
classifications, and the critical role of the operating system as a resource
manager. Additionally, it addresses the threat of malware and its potential
risks to computer systems.
Computer software
Software is a group of computer programs that instruct the computer what to
do, when to do it, and how to do the task. A program is a group of computer
instructions or commands written in a programming language such as C,
C++, Java, and so on.
The software is broadly classified into two groups:
Application software: Application software is designed to solve a
particular problem or task. It takes the user task and gets it
programmed by the hardware with the help of system software.
Examples of application software are MS Office, WordPad, notepad,
calculator, Web browsers, and so on. Each of them is designed to
perform a specific task.
System software: System software is designed to work as an interface
between application software and hardware. It provides a platform to
run application software. It manages and controls all the resources of
the computer, such as CPU, memory, input-output devices, and so on.
System software includes device drivers, compilers, interpreters,
linkers and loaders, computer BIOS, and operating systems such as
Windows, Linux, UNIX, and so on. Figure 3.1 shows the relationship
between application and system software:

Figure 3.1: Relationship between application and system software
Examples of system software
Some examples of system software are device drivers, compilers,
interpreters, linkers, loaders, computer BIOS, and operating systems such as
Windows, Linux, UNIX, and so on:
BIOS: The basic input–output system allows the computer to run and
control hardware that is either connected to it or built into it. It is
stored in the ROM chip. It is also known as firmware. These are small
programs that are responsible for starting the computer (booting) and
performing the Power-On Self-Test (POST). In the POST test, the
computer checks all the connected devices.
Device drive: The device drive works as a translator between the
connected hardware device and the computer. It controls a particular
device for which it is meant. The device drivers are built into the
operating system for many types of devices. For example, a mouse,
keyboard, and so on. When we attach the device to the computer, the
operating system starts searching for its drives, installing them, and
using them. These kinds of devices are called plug-and-play. For
other types of devices, we have to manually install the drives, such as
printers, scanners, and so on.

Utility software: It is designed to help analyze, monitor, configure,
and optimize the setting of the computer. This software may be used
by application software. Some of the utility software are given as
follows:
Disk defragmenters
Antiviruses
Backup software
Disk cleaner
Disk practitioners
Disk compression
Firmware: They are embedded in hardware. It is also known as the
software for hardware. They are kept in non-volatile memory devices
such as ROM, EPROM, or flash memory. Firmware examples include
bootstrap loaders, BIOS commands, and so on.
Classifications of software dependent on proprietary rights
The following are the various classifications of the software dependent upon
proprietary rights. Let us look at them:
Open-source software: It allows the user to copy, modify, use, or
delete the software code without any permission from the developer.
Examples of some open-source software are Linux, Firefox, and Open
Office.
Closed source software: It does not allow the user to copy, modify,
use, or delete the software code (source code) without the permission
of the developer. It is also known as proprietary software. Examples:
MS Windows, UNIX, Internet Explorer, Opera, and Safari.
Freeware: They are available free to all users, but their source code is
not available for modification. Example: Skype and Adobe Acrobat
Reader. Most software developers market freeware as freemium or
shareware to encourage users to buy a more capable or full version.

Fermium: Fermium is free software, but money (premium) is paid for
extra, more capable features.
Shareware: It is initially available for free, and users are encouraged
to share its copy for a limited period of time. After that, the user is
required to pay for continued use. Some of the sharewares are as
follows:
Adware: They are advertisement-supported software. They
advertise to users, display, and generate revenue from it.
Demoware: The software that is used to demonstrate a product
feature but has limitations. It will either expire at a set time or have
limited functionality.
Trialware: It can be run for a limited period of time before it
expires. For example, a 30-day trial of the software expires in 30
days. After that, you have to purchase the full version.
Donationware: It is fully operational software for the users and
requests optional donations be paid to the programmer or any third-
party beneficiary. It is a type of freeware.
Crippleware: The software whose functioning has been crippled or
limited with the sole purpose of encouraging or requesting the user
to buy it. It damages the documents by inserting a logo or a
watermark. This software may not be fully functional, but it allows
the user to understand how it works.
Operating system
It is a system software that works as an interface between hardware and the
user and allows other application software to run. It also works as a resource
manager because it manages a computer’s resources, such as CPU, memory,
files, input-output devices, and so on. Operating System (OS) examples
include Linux, UNIX, Windows, Android, and others. Figure 3.2 shows the
position of the operating system in the computer:

Figure 3.2: Operating system’s position in the computer
UNIX OS structure
It is a layered structure. The structure of the operating system consists of a
kernel and shell:
Kernel: It is the most important component of the operating system.
Generally, the kernel is the in-charge of memory management, process
management, CPU management, and so on. It takes the command
from the shell and tells the hardware what to perform.
Shell: It accepts the command from the user and sends it to the kernel.
It is an interface between the kernel and users. The diagrammatical
representation of operating system components is given in Figure 3.3,
which shows the UNIX OS components:

Figure 3.3: UNIX OS components
The operating system as a resource manager
The operating system manages all the hardware resources such as CPU,
memory, input–output devices, and so on, and software resources such as
programs, files, processes, and so on. That is why it is called a resource
manager. How the operating system manages the resources is discussed as
follows:
Processor or CPU management: The operating system is responsible
for the following CPU management activities:
It keeps track of the states of the processor, whether free or not
It allocates and de-allocates jobs to the CPU
It decides which job should use the processor and the time for it
Memory management: The operating system is in charge of the
following memory management activities:
Allocation and de-allocation of memory
Keeps track of free and used spaces

File management: The operating system is in charge of the following
file management activities:
Creation and deletion of files
Protection of the file
Setting the permissions to a file, that is, read-write and execute
Process management: The operating system is in charge of the
following process management activities:
Creation, deletion, suspension, and resumption of the process
Handling process synchronization and deadlock.
Input-output devices management: The operating system is
responsible for the following input-output device management
activities:
When the computer system starts up, the operating system
identifies and recognizes all connected I/O devices.
It keeps the user uninformed about the internal workings of the
input and output devices.
The operating system communicates with the device with the help
of the device driver, which is a software module that acts as an
intermediator, translating high-level operating system commands
into device-specific commands.
The operating system allocates and de-allocates the task to input–
output devices.
Classification of the operating system
The classification of operating systems can be done based on various
criteria, including the user interface, the number of users they support, their
functions, the purpose they serve, how they execute programs, and the
environment in which they operate. Here are some common classifications:
Based on the user interface

Based on the interface by which the user interacts with the computer, it has
been classified into two categories:
Character user interface or command user interface (CUI) (non-
interactive): In this type of operating system, the user interacts with
the computer with the keyboard by typing different commands to
perform some tasks or operations. Today, most computers are GUI,
not CUI. An example of a CUI operating system is MS-DOS.
Graphical user interface (GUI) (interactive): In this type of
operating system, the user interacts with the computer using graphics
that include icons, a navigation bar, images, and so on. The mouse can
be used to click or interact with these graphical symbols. GUI uses
both a mouse and a keyboard for performing operations. It is very easy
to use as compared to CUI. Examples of GUI operating systems are
Windows and Android.
Based on the number of users
Based on the number of users, the operating system has the following
categories:
Single-user operating system: Only one user can interact with the
computer simultaneously.
Multi-Users operating system: In this operating system, more than
one user can interact simultaneously through multiple terminals or the
network.
Based on the execution of the program
It executes the programs sequentially. The operating system in a single-user
environment or a basic batch-processing system executes programs
sequentially, with each job finished before the next one begins. A
multiprogramming environment allows multiple programs or processes to
run concurrently. Multiprogram execution is used in modern operating
systems such as Windows, macOS, and Linux to effectively manage
numerous tasks. On the basis of the way of program execution, the operating
system has the categories discussed in the following sections.

Sequentially execution of the program or serial processing
This operating system executes one program or task at a time. After
completion of one program, it takes another. It sequentially executes the
program, one after another, and one at a time. It executes the program in a
First In, First Out (FIFO) manner. A program that enters first, the computer
executes first, and a program that enters later will be executed later.
Punch cards were used mainly for this kind of operating system. All jobs
were prepared and stored on the card first, and they were given to machines
one by one.
For example, let us have four programs that are P1, P2, P3, and P4. P1 and
P3 are of the same type, and P2 and P4 are of another type. Let the burst
time (maximum time allowed on CPU) for each process be 2 seconds, and 2
seconds are required to load the environment for the execution. For instance,
for the C program, we have to load the C environment, and for the JAVA
program, we need to load the JAVA environment.
Suppose they are given to the system in a P1, P2, P3, and P4 sequence. The
total time required to complete all the processes will be 16 seconds, as
shown in Figure 3.4. Let us have two resources: CPU and input–output
device:
Figure 3.4: Gantt chart for sequentially execution system
Batch processing operating system
A batch is a collection of similar programs. In the batch processing system,
different batches are created and processed sequentially.

Data and programs (environment) that need to be processed are clubbed as a
batch and executed together. MS-DOS is a batch operating system. In this,
jobs P1, P2, P3, and P4 are divided into two batches, that is, P1, P3 in batch
1 and P2, P4 in batch 2. These two batches are executed sequentially. The
total time of completion for all the processes will be 12 seconds, as shown in
Figure 3.5:
Figure 3.5: Gantt chart for batch execution system
Multiprogramming operating system
In the case of serial and batch processing, the main problem is when a
program goes for input–output devices, and the CPU remains in an idle state.
In multiprogramming, multiple programs are kept in memory. Figure 3.6
shows the memory view for multiprogramming. When one program leaves
(swap-out) the CPU and goes for the input–output device, the other program
is loaded (swap-in) from memory, assigned to the CPU, and so on. A single
CPU is used in multiprogramming.

Figure 3.6: Memory view for multiprogramming
In serial execution, when P1 goes for input–output, the CPU remains in an
idle state. Only after the completion of P1, the P2 is loaded on the CPU. The
total time of completion for all the processes, for the preceding example, in
sequential execution will be 12 seconds, which is shown in Figure 3.7:
Figure 3.7: Gantt chart for serial or sequentially execution
In multiprogramming, when P1 goes for input-output, P2 is loaded on the
CPU, and when P2 goes for input-output, P3 is loaded on the CPU, and so
on. The total time of completion for all the processes, for the preceding
example, in multiprogramming execution will be 10 seconds, as shown in
Figure 3.8:
Figure 3.8: Gantt chart for multiprogramming execution
CPU never remains in an idle state. Multiprogramming aims to keep the
resources like the CPU and the input–output device busy as much as
possible, resulting in maximum utilization of the resources. MS Windows
and Apple’s Mac operating systems are multiprogramming.
Multiprogramming uses the concept of context switching, which is storing
and saving the state of one process and loading another. So, it is the

switching from one process to another process.
Multitasking OS through time-sharing
The multitasking operating system is a logical extension of
multiprogramming. It uses both multiprogramming and time-sharing
concepts. As the name suggests, multiple tasks or programs are executed at a
time. For example, listening to music while typing on WordPad and surfing
the internet.
In time sharing on a single CPU operating system, a time quantum or slice (a
maximum time) is allocated to each process for which a process is executed
on the CPU, say four nanoseconds (ns).
After executing four ns, the process leaves the CPU, and another process
occupies it. This cycle keeps running until all the processes that are being
executed expire their time slice.
The switching among the processes is so fast that it creates an illusion for the
users, who think they are working on the stand-alone system and have their
own dedicated computer. Figure 3.9 shows multitasking on a single CPU:
Figure 3.9: Multitasking on a single CPU
When the last job finishes its time slice, there will be the turn of the first job
again. This cycle continues until all the processes finish their execution time.
This is known as round-robin execution.
Let us have three processes, P1, P2, and P3, the burst time of P1 = 2 ns, P2 =
4 ns, and P3 = 6 ns. And the time slice is two ns. In the first cycle, P1, P2,
and P3 are executed. In the second cycle, P2 and P3 are executed as P1 has
been completed. This cycle keeps repeating until all the processes are
complete. The Gantt chart representation is given in Figure 3.10:

Figure 3.10: Gantt chart for multitasking execution
Multitasking = Multiprogramming + Time Sharing
Multitasking uses the concept of context switching, which means swapping
out the process from the CPU when its burst time (maximum allotted time)
expires and swapping in the next process.
Multithreading operating system
A single process can have multiple independent sub-processes running
concurrently. These sub-processes are known as threads. The threads may
be treated as the child processes that share the resources of the parent
process but run independently. Figure 3.11 shows the working of the
multithreading operating system:

Figure 3.11: The multithreading
For example, when we access the internet through Web browsers, the Web
browsers work in a multithreading fashion. It creates multiple threads as per
the requirement of the user; that is, one thread displays the content, the other
takes the input from the keyboard, another sends the data to the server,
receives data from the server, and so on.
A Web browser is process P1, which may contain multiple threads such as
T1, T2, T3, T4, and so on. Multithreading is similar to multitasking in that it
allows several threads to be processed at the same time rather than several
processes.
Multiprocessing operating system
All the previously-mentioned types of operating systems are assumed to be
used with a single CPU. A multiprocessing operating system means the
computer has two or more CPUs. In a multiprocessing system, if the
complex program is divided into subprograms, then these subprograms are
executed concurrently by multiple processors in parallel.
Assume that the processes P1, P2, P3, and P4 await execution. If it is a dual-
core CPU (two processors), two sub-processes can be executed concurrently,
and the system will be twice as fast as a single-core CPU (one processor).
A quad-core CPU (four processors) allows four tasks to run in parallel,
making the system four times faster than a unicore processor.
Multiprocessors can be categorized into two types:
Symmetrical multiprocessing system: In this system, all the
processors are essentially identical and perform identical functions.
They share a common memory and operating system, which is also
known as a tightly coupled system. Figure 3.12 shows the
symmetrical multiprocessing system:

Figure 3.12: Symmetrical multiprocessing system
Asymmetrical multiprocessing system: In this system, all processors
are not identical and perform different tasks. A supervisor or master
CPU assigns the job to the slave CPUs. The master CPU is the most
powerful CPU among the slave CPUs. Figure 3.13 shows the
asymmetrical multiprocessing system:
Figure 3.13: Asymmetrical multiprocessing system
Distributed operating system
In a distributed system, the data is stored and processed at multiple places or
locations connected through the network. All the computers connected
through the network have the same operating system. Distributed operating
system (DOS) aims to better the management of hardware resources. With a
network operating system, the operating system on each computer may be
different, but in a distributed system, it is the same. Some examples of DOS
are Solaris, Micros, and Mach. Figure 3.14 shows the distributed operating
system:
Figure 3.14: The distributed operating system

Network operating system
This system connects the computers at different locations through the
network. All the computers connected to the network can have their own
operating system. Unlike the distributed operating system, the operating
system may be the same or different. Network operating system (NOS)
aims to remotely service multiple clients. Examples of NOS are Windows
NT, Novell, UNIX, and so on.
NOS are used in heterogeneous computers and are known as loosely
coupled systems. On the other hand, DOS are tightly coupled systems
usually used in homogenous computers or multiprocessors.
In a DOS, computers can communicate with one another via shared memory
or messages. However, the NOS uses file transfers to facilitate
communication between computers.
In contrast to the DOS, which handles resources such as memory, CPU, and
so on globally, the network operating system takes care of them on each
computer. Figure 3.15 shows the network operating system:
Figure 3.15: The network operating system
Real-time operating system
A real-time system is a time-bound system that has time constraints for the
completion of the processes in the system. The operating system must finish
the process within a given time constraint. Otherwise, the system will crash.
This operating system is intended for real-time applications. A computer
simulates all time occurrences at the same rate as in real life.
Real-time software, for example, would display objects moving across the
computer screen at the same speed as they would actually move in real life.

Generally, Real-Time Operating Systems (RTOS) are of two types:
1. Hard real-time operating systems: In a hard real-time operating
system, all the processes must be completed within their specified
time constraints or limit; otherwise, the system will crash. For
example, if a user expected the output on the 5th second, the system
must process and produce the result on the 5th second, not on the 6th
or 4th second. In a hard real-time system, meeting a time deadline is
mandatory. If it is not met, the system’s performance will fail, and the
usefulness of the result will be zero after its deadline. Examples of
hard real-time operating systems are missile launching systems,
gaming, nuclear systems, aviation industries, defense, robotics, and so
on.
2. Soft real-time operating system: In a soft real-time operating
system, even if the system fails to meet the deadline, the system is not
considered to have failed. The final result is not worthless. The value
of the result is not treated as zero even if the deadline has passed. For
instance, if some bits are lost during audio-video streaming, it will not
be a significant concern, but if too many are lost, the quality will
suffer.
Language translator
Language translators or processors translate or convert a program written in
one language into another. For example, high-level language (HLL) to low-
level language (LLL). Figure 3.16 shows the working of the language
translator:
Figure 3.16: Language translator
A program written in a programming language is known as source code;
when it is translated into machine language, it becomes object code. A
language translator converts the source code into object code.

There are generally three types of language translators, which are as follows:
1. Compiler: It is a program that converts HLL into LLL. It takes a
complete HLL program as input, converts it into a low-level
language, and notifies the errors, if any.
2. Interpreter: It converts an HLL program into an LLL line by line;
one statement at a time is translated and executed immediately.
3. Assembler: An assembler is a program that translates an assembly
language program into a machine or LLL.
Besides the previously-mentioned programs, the following programs also
support writing and executing the program:
Editor: An editor is a program that provides a platform to write,
modify, and edit the source code or text.
Linker: In the object file, the linker searches and appends all libraries
needed for making a file executable. It merges two or more files into
one file, for example, the object code from the compiler and other
library files, into one executable file.
Loader: It takes the executable code from the linker, loads it into the
main memory, and prepares it for the computer to run. It allocates the
memory space to the program in the main memory.
The malware
The word malware is derived from two words: malicious and software. It is
malicious software. It is designed to damage and destroy computers and
computer systems. It is not legitimate software. Some examples of malware
are viruses, worms, Trojan viruses, spyware, adware, ransomware, and so
on. The basic concept behind different malware is given as follows:
Virus: A virus is bad software that is added to a file or document.
Once the virus is downloaded, it stays quiet until the file is opened and
used. It can make copies of itself. It uses the computer’s resources like
RAM, HDD, and processor.
Worms: Worms are pieces of bad software that copy themselves
quickly and spread to every device on the network. Worms do not

need a host file to spread as viruses do.
Trojan horse virus: Trojan viruses are hidden in programs that are
meant to help. Once downloaded, the Trojan virus can access sensitive
data and edit, block, or erase it. Unlike most viruses and worms,
Trojan viruses are not made to copy themselves.
Spyware: Spyware is bad software that runs in the background and
sends information to a remote user. People often use spyware to steal
personal or financial information like passwords and so on.
Ransomware: Ransomware is bad software that gets into a computer
system, finds sensitive information, encrypts it so the user cannot
access it, and then asks for money to get the data back. When the
attacker pays the amount, the data can be accessed again.
Naggware: It can also be called begware or annoyware. It reminds the
user that he or she needs to buy the software license.
Logic bomb: Malicious software that erupts or activates when a
certain logical condition is met is called a logic bomb, such as any
click by the mouse, any strike on the keyboard, and so on.
Time bomb: A time bomb is a type of logic bomb that erupts or
activates at a specific time or day.
Scareware: It is also called fraudware. Scareware is a type of
malware that uses social engineering to make users feel scared like
they are in danger, so they will buy unwanted software.
Conclusion
The third chapter discusses computer software and how it can be categorized
based on several different criteria. In addition to this, it offers a fundamental
introduction to the operating system as well as its classifications based on
several factors, such as the execution of the program, the number of users,
and the interface. It also explains the fundamentals of malicious programs
and various types of them. After reading the chapter, the user will know
various translator tools.

The upcoming chapter will provide information about the different types of
number systems, like decimal, binary, octal, and hexadecimal. It also focuses
on the conversion of one number system into another. Other well-known
binary codes such as ASCII, BCD, EBCDIC, Excess-3, and Gray codes will
also be covered.
Points to remember
Software is a group of computer programs that instructs the computer
what to do, when, and how to do it.
Application software is designed to solve a particular problem or task.
System software is designed to work as an interface between
application software and hardware.
The operating system is also known as a resource manager.
The device drive works as a translator between the hardware device
and the computer.
BIOS provides functionality to operate and control the hardware
connected to it or built into the computer.
Utility Software is designed to help analyze, monitor, configure, and
optimize the setting of the computer.
Firmware is embedded in hardware. It is also known as the software
for hardware.
Open-source software allows the users to make changes in source
code, whereas closed-source software does not.
The operating system is an interface between hardware and the user.
In the sequential execution of a program or serial processing, one
program is executed at a time.
A batch is a collection of similar programs or jobs. In the batch
processing system, different batches are processed sequentially.
Multiprogramming uses the concept of context switching, which is
storing or saving the state of one process and loading another

process’s state.
The multitasking operating system is a logical extension of
multiprogramming.
A single process can have multiple independent subprograms running
concurrently. These subprograms are known as threads.
Multithreading is a technique akin to multitasking that allows for the
execution of numerous threads simultaneously.
A multiprocessing operating system means the computer has two or
more CPUs.
In a distributed system, the data is stored and processed at multiple
places, which are connected through the network.
In the network operating system, the computers at different locations
are connected through the network.
Real-time operating systems must finish the process in a given time
constraint; otherwise, the system will crash.
Language translators or processors translate one language into another.
Important questions
1. Differentiate between computer hardware and software.
2. What is software? Write its types.
3. What is an operating system? Give its example.
4. Explain the role of the operating system. Why is it called a resource
manager?
5. Give some examples of computer software.
6. Differentiate between source code and object code.
7. Differentiate between compilers and interpreters.
8. What is application software? Give examples.
9. What is BIOS?

10. Can you explain what utility software is? Is it required software for
users to install?
11. Write a short note on the different operating systems.
12. Write the differences between the application and system software.
13. What is malware? Explain its types.
14. What is a language translator? Write a short note on the following:
a. Compiler
b. Interpreter
c. Assembler
d. Loader
e. Linker
15. Differentiate between network operating systems and distributed
operating systems.
16. What is a multitasking operating system?
17. Differentiate 
between 
multiprogramming, 
multitasking, 
and
multiprogramming operating systems.
18. What do you understand by batch processing operating system?
19. Differentiate between CUI and GUI.
20. Write the difference between open-source and closed-source software.
21. What is the difference between viruses, worms, and trojan viruses?
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com


CHAPTER 4The Number System
Introduction
In this chapter, we will delve into the fascinating world of number systems, focusing on the binary
system and its conversions to and from other systems. We will explore various operations on binary
numbers, as well as some widely used binary codes in computer science and digital communication.
Understanding these concepts is crucial for anyone interested in computer programming, digital
electronics, and data representation. Let us embark on this enlightening journey into the realm of
number systems and binary operations.
Structure
This chapter covers the following topics:
Number system
Conversions from the decimal system to another
Conversions from another number system to decimal
Direct conversions from one to another number system except for decimal
Fractional numbers
Direct conversion methods
Operations on binary numbers
Other popular binary codes
Objectives
The objective of the chapter is to focus on the binary number system and its inter-conversion in
another number system. The chapter teaches readers how to use decimal, binary, and other number
systems. Readers will also learn binary arithmetic to efficiently work with binary data. The chapter
introduces common binary codes for various uses. By the end of this chapter, readers should have a
strong foundation in understanding and manipulating number systems, especially binary, and be
able to apply this knowledge in practical scenarios.
Number system
It is a method of representing numbers with the help of a set of symbols and rules. Every number
system is identified with the help of its base or radix, which is the total symbol used in the number
system. For example, in a binary number system, the base is 2, and the base is 10 in decimal.
The following syntax represents it:
(N)B where N is the number, and B is the base.
For example,
(89)10 is a decimal number
(0101)2 is a binary number

(34)8 is an octal number
There are two types of number systems:
1. Positional or weighted number system
2. Non-positional or non-weighted number system
Each symbol in a positional number system stands for a different value. The positions show how
much each symbol is worth; that is, if we interchange the symbols, then there is an effect on the net
value of the number. For example, 123 is different from 321. Every position of the symbol in the
number represents a different weight. For the number 123 in decimal, 3 represents a unit place, its
weight is 1, 2 referents a ten place and its weight is 10, and 1 represents a hundred place, and its
weight is 100. Some examples of positional number systems are decimal, binary, and so on.
In a number system that does not use positions, each symbol has the same value. The symbols are
the same no matter where they are in the number; that is, if we interchange the symbols, then there
is no effect on the net value of the number. For example, III is the same as III. The tally marks are a
non-positional number system. Some other examples are gray code and excess-3 code.
Binary number system
Only 0 and 1 are used in it. Each digit is known as a bit. Some examples are as follows:
(100)2
(101)2
(1101)2
Decimal number system
It uses ten digits symbols with a base of 10. The symbols used are 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9.
Some examples are as follows:
(123)10
(890)10
(809)10
Octal number system
It used eight symbols. It has base 8. The symbols used are 0, 1, 2, 3, 4, 5, 6, and 7. Some examples
are as follows:
(23)8
(50)8

(234)8
Hexadecimal number system
It has sixteen symbols. So, it uses base 16. The symbols are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E,
and F, with A equal to 10, B to 11, C to 12, D to 13, E to 14, and F to 15. Some examples are as
follows:
(2C3)16
(AAB)16
(2DF)16
Number system
Symbol used
Base No. of symbols Examples
Binary number system
0 and 1
2
2
(0101)2
Decimal number system 0, 1, 2, ……..9 10
10
(89)10
Octal number system
0, 1, 2, ……..7 8
8
(23)8
Hexadecimal
number system
0, 1, 2, ……..9
A, B, C, D, E, F
16
16
(2C3)16
Table 4.1: The number system
Refer to the following Table 4.2:
Decimal
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Binary
0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
Octal
0
1
2
3
4
5
6
7
10
11
12
13
14
15
16
17
Hexadecimal 0
1
2
3
4
5
6
7
8
9
A
B
C
D
E
F
Table 4.2: Decimal number and its equivalent

Conversions from the decimal system to another
The decimal number system is the most popular number system for calculation among humans. This
section focuses on the conversion of decimals to other numbers, like binary, octal, and hexadecimal
number systems, by the following subsections.
Decimal to binary
To change from decimal to binary, you need to follow the given steps:
1. Divide the number by 2 and put the remainder aside.
2. Keep doing this until the number can no longer be divided by two anymore.
3. Write down the remainder starting from the last remainder to the first remainder.
Example 1: Find the binary equivalent of 10.
(10)2 = (?)10
Base Number Remainder
2
10
0 First
2
5
1
2
2
0
2
1
1 Last
0
(10)10 = (1010)2
Example 2: Find the binary equivalent of 225.
(225)10 = (?)2
Base Number Remainder
2
225
1

2
112
0
2
56
0
2
28
0
2
14
0
2
7
1
2
3
1
2
1
1
0
(225)2 = (11100001)10
Decimal to octal
To change from decimal to binary, you need to follow the given steps:
1. Divide the number by 8 and put the remainder aside.
2. Keep doing this until the number can no longer be divided by eight anymore.
3. Write down the remainder starting from the last remainder to the first remainder.
Example 3: Find the octal equivalent of 15.
(15)10 = (?)8
Base Number Remainder
8
15
7
8
1
1
0

(15)10 = (17)8
Example 4: Find the octal equivalent of 112.
(112)10 = (?)8
Base Number Remainder
8
112
0
8
14
6
8
1
1
0
(112)10 = (160)8
Decimal to hexadecimal
To change from decimal to hexadecimal, you need to follow the given steps:
1. Divide the number by 16 and put the remainder aside.
2. Keep doing this until the number can no longer be divided by 16 anymore.
3. Write down the remainder starting from the last remainder to the first remainder.
Example 5: Find the hexadecimal equivalent of 112.
(112)10 = (?)16
Base Number Remainder
16
112
0
16
7
7
0
(112)10 = (70)16

Example 6: Find the hexadecimal equivalent of 250.
(250)10 = (?)16
Base Number Remainder
16
250
10
16
15
15
0
(250)10= (FA)16
where F = 15 and A = 10 in hexadecimal
Conversions from another number system to decimal
This section focuses on the conversion of other number systems, such as binary, octal, and
hexadecimal number systems, into decimal. The following sub-sections will show the conversion
one by one.
Binary to decimal
To turn a binary into a decimal, you need to do the following:
1. Multiply each digit by two.
2. Apply incremental power, starting from zero, from right to left.
3. Add the result to get a decimal number.
Example 7: Find the decimal equivalent of (1111)2
(1111)2 = (?)10
1 * 23 + 1 * 22 + 1 * 21 + 1 * 20
8 + 4 + 2 + 1
15
Hence, (1111)2 = (15)10
Example 8: Find the decimal equivalent of (1010)2
(1010)2 = (?)10

1 * 23 + 0 * 22 + 1 * 21 + 0 * 20
8 + 0 + 2 + 0
10
Hence, (1010)2 = (10)10
Octal to decimal
The following steps need to be followed for conversion:
1. Multiply each digit by eight
2. Apply an incremental power, starting from zero, from right to left
3. Add numbers together to get a decimal number.
Example 9: Find the decimal equivalent of (17)8
(17)8 = (?)10
1 * 81 + 7 * 80
8 + 7
15
Hence, (17)8 = (15)10
Example 10: Find the decimal equivalent of (160)8
(160)8 = (?)10
1 * 82 + 6 * 81 + 0 * 80
64 + 48 + 0
112
Hence, (160)8 = (112)10
Hexadecimal to decimal
The given steps need to be followed for conversion:
1. Multiply each digit by sixteen.
2. Apply incremental power, starting from zero, from right to left.
3. Add the result to get a decimal number.
Example 11: Find the decimal equivalent of (70)16

(70)16 = (?)10
7 * 161 + 0 * 160
112 + 0
112
Hence, (70)16 = (112)10
Example 12: Find the decimal equivalent of (FA)16
(FA)16 = (?)10
F * 161 + A * 160
15 * 161 + 10 * 160
240 + 10
250
Hence, (FA)16 = (250)10
Number system conversions, excluding decimal
To convert any number system, except decimal, for example, binary into octal, octal into
hexadecimal, and binary to hexadecimal and vice versa, follow the steps as follows:
1. First, the number should be converted into decimal.
2. After that, the decimal number should be converted into the required number system.
Example 13 illustrates these steps:
Example 13: Convert the binary number (1111)2 into an octal number.
1. First, the number is converted into decimal, that is (1111)2 = (?)10
(1111)2 = (?)8
1 * 23 + 1 * 22 + 1 * 21 + 1 * 20
8 + 4 + 2 + 1
15
Hence, (1111)2 = (15)10
2. Now, convert (15)10 into octal, that is (15)10 = (?)8

(15)10 = (?)8
Base Number Remainder
8
15
7
8
1
1
0
(15)10 = (17)8
Hence, (1111)2 = (15)10 = (17)8
Example 14: Convert the octal number (256)8 into a binary number.
1. First, the number is converted into decimal, that is (256)8 = (?)10
2 * 82 + 5 * 81 + 8 * 80
128 + 40 + 8
174
Hence, (256)8 = (174)10
2. Now, convert (174)10 into a binary number, that is, (174)10 = (?)2
(174)10 = (?)2
Base Number Remainder
2
174
0
2
87
1
2
43
1
2
21
1

2
10
0
2
5
1
2
2
0
2
1
1
0
(174)10 = (10101110)2
Hence, (256)8 = (174)10 = (10101110)2
Example 15: Convert the octal number (350)8 into hexadecimal.
1. First, the number is converted into decimal, that is (350)8 = (?)10
3 * 82 + 5 * 81 + 0 * 80
192 + 40 + 0
232
(350)8 = (232)10
2. Now, convert (232)10 into hexadecimal, that is (232)10 = (?)16
Base Number Remainder
16
232
8
16
14
14
0
(232)10 = (E8)16 where E=14
Hence, (350)8 = (232)10 = (E8)16

Fractional numbers
A binary fractional number consists of two parts: the number before the decimal and the number
after the decimal, for example, 1110.101. 1110 is a whole number before the decimal, and 101 is a
fractional part after the decimal (dot).
Binary fractional numbers into decimal
To convert binary fractional numbers into decimals, follow the steps given as follows:
1. Change the whole part of the binary number to its equivalent decimal, as usual.
2. Use the following steps to convert a binarynumber’s fractional part to its decimal equivalent:
1. Divide each digit by 2.
2. Apply an incremental power, starting from 1 to the denominator, that is, 2-1, from left to
right.
3. Add the result to get the fractional part number.
3. Add both the whole and fractional parts of the decimal number.
Example 16: Convert (10101.1101)2 into decimal.
1. Transform the whole part of the binary number to its equivalent in decimal as usual.
The number before fraction (whole number) = 10101
1 * 24 + 0 * 23 + 1 * 22 + 0 * 21+ 1 * 20
16 + 0 + 4 +0 + 1
21
2. Transform the fractional part of a binary number into its decimal.
The number after fraction (Fraction part) =1101
1 * 2-1 + 1 * 2-2 + 0 * 2-3 + 1 * 2-4
1 * 1/2 + 1 * 1/4 + 0 * 1/8 + 1 * 1/16
1 * .5 + 1 * .25 + 0 * .125 + 1 * .0625
.5 + .25 + 0+ .0625
.8125
3. Add both the whole number and the fractional part of the decimal number.
21 + .8125
(21.8125)10

So, (10101.1101)2 = (21.8125)10
Octal fractional numbers into decimals
Use the same procedure used to convert binary fractional numbers into decimals by replacing base
value 2 with base value 8.
Hexadecimal fractional numbers into decimal
Use the same procedure used to convert binary fractional numbers into decimals by replacing base
value 2 with base value 16.
Example 17: Convert (1110.10)2 into decimal.
1 * 23 + 1 * 22 + 1 * 21 + 0 * 20 + 1 * 2-1 + 0 * 2-2
8 + 4 + 2 + 0 + 1/2 + 0
14 + .5
14.5
Hence, (1110.10)2 = (14.5)10
Decimal fraction number to binary
A decimal fractional number consists of two parts, for example, 45.25. Here, 45 is a whole number
before the decimal point, and 0.25 is a fractional part after the decimal point (dot).
The given steps must be followed to convert a fraction number into a decimal:
1. Convert the whole part of decimal to binary equivalent as usual(see decimal to binary
conversion).
2. Follow the given steps to change the fractional part of the binary number to its decimal
equivalent:
1. Multiply it by two.
2. Collect the whole part of the result, that is, the digit before the dot.
3. Write the digit from top to bottom (see the example).
3. Add the binary number’s whole and fractional parts to get the final result.
Example 18: Convert (45.25)10 into a binary number.
1. Convert the whole part of decimal to binary as usual (see decimal to binary conversion). The
number before fraction (whole number) = 45
Base Number Remainder
2
45
1

2
22
0
2
11
1
2
5
1
2
2
0
2
1
1
0
(45)10 = (101101)2
2. Convert the fractional part to the binary equivalent. The number after fraction (fraction part) =
.25.
Whole part Fractional part
.2 5
*2
0
.5 0
*2
1
.0 0
(.25)10 = (.01)2
3. Add both whole number and fractional part
(101101)2 + (.01)2
Hence, (101101.01)2
Decimal fraction number to octal
Follow the same steps for the octal as in the previous section.

Example 19: Convert (550.20)10 into an octal number.
1. Convert the whole part of decimal to octal equivalent as usual (see decimal to octal
conversion). The number before fraction (whole number) = 550.
Base Number Remainder
8
550
6
8
68
4
8
8
0
8
1
1
0
(550)10 = (1,046)8
2. Convert the fractional part to the binary equivalent. The number after fraction (Fraction part) =
.20
Whole part Fractional part
.2 0
*8
1
.6 0
*8
4
.8 0
*8
6
.4 0
*8

3
.2 0
(.20)10 = (.1463)8
3. Add both the whole number and the fractional part.
(1046)8 + (.1463)8
Hence, (1046.1463)8 up to four decimals
Example 20: Convert (1,046.1463)8 into a decimal number.
1 * 83 + 0 * 82 + 4 * 81 + 6 * 80 + 1 * 8-1 + 4 * 8-2 + 6 * 8-3 + 3 * 8-4
512 + 0 + 32 + 6 + 1/8 + 4/64 + 6/512 + 3/4096
550 + .1250 + .0625 + .01171 + .0007
550 + .1999….
(550.1999)2
So, (1046.1463)8 = (550.1999)10 up to four decimal points.
Decimal fraction number to hexadecimal
Example 21: Convert (2015.48)10 into a hexadecimal number.
1. The number before fraction (whole number) = 2015
Base Number Remainder
16
2015
15
16
125
13
16
7
7
0
(2015)10 = (7DF)16
2. Convert the fractional part to the binary equivalent

The number after fraction (fraction part) = .48
Whole part Fractional part
.4 8
*1 6
7
.6 8
*1 6
A
.8 8
*1 6
E
.0 8
*1 6
1
.2 8
*1 6
4
.4 8
(.48)10 = (.7AE1)16 up to 4 decimal points
3. Add both whole number and fractional part:
(7DF)16 + (.7AE1)16
Hence, (7DF.7AE1)16
Direct conversion methods
This section elucidates the direct conversion method in detail.
Binary to decimal
As binary is a weighted number system, each digit has a weight associated with it. Starting from
right to left, the weight of the first symbol is 1, the weight of the second is 2, the weight of the third

is 4, and so on. Write and sum all the weights of one in a binary number and ignore the 0. Refer to
Example 22.
Example 22: Convert (1010)2 into decimal.
Position 4th 3rd 2nd 1st
Weight 8 4 2 1
Binary number 1 0 1 0
Sum all the weights of one = 8 + 2 = (10)10 = (1010)2
Example 23: Convert 1101010 into decimal.
Position 7th 6th 5th 4th 3rd 2nd 1st
Weight 64 32 16 8 4 2 1
Binary number 1 1 0 1 0 1 0
Sum all the weights of one = 64 + 32 + 8 + 2 =106
Hence (1101010)2 = (106)10
Decimal to binary
It is merely a reverse method from binary to decimal. Bifurcate the decimal number into different
weights as per binary position. For example, 14 can be divided into 8 plus 4 plus 2. Write one under
each divided weight and 0 under the remaining. Add all the weight. The result will be required a
decimal number.
Example 24: Convert (50)10 into decimal.
The number 50 is divided into 32 + 16 + 2. Write 1 under each divided weight and 0 under the
remaining weight
Position 6th 5th 4th 3rd 2nd 1st
Weight 32 16 8 4 2 1
Binary number 1 1 0 0 1 0
So, (50)10 = (110010)10
Example 25: Convert (234)10 into binary.
The number 234 is divided into 128 + 64 + 32 + 8 + 2. Write 1 under each divided weight and 0
under the remaining weight.

Position 8th 7th 6th 5th 4th 3rd 2nd 1st
Weight 128 64 32 16 8 4 2 1
Binary number 1 1 1 0 1 0 1 0
So, (234)10 = (11101010)2
Binary to octal
To convert binary from octal, follow the given steps:
1. Break the binary number into groups of three bits, going from right to left. In the end, balance
the number of digits by adding an appropriate number of zeroes so that it becomes a group of
three bits.
2. Write the decimal equivalent of each pair.
Example 26: Convert (101010010101)2 into octal.
From right to left, split the number into three groups, which are as follows:
Divided Groups: 101 010 010 101
Equivalent decimal: 5 2 2 5
So, (101010010101)2 = (5225)8
Example 27: Convert (1011011101)2 into octal.
Divided Groups: 001 011 011 101
Equivalent decimal: 1 3 3 5
So, (1011011101)2 = (1335)8
Binary to hexadecimal
To convert from binary to hexadecimal, follow the given steps:
1. Break the binary number into four groups of bits, going from right to left. In the end, balance
the number of digits by adding the appropriate number of zeroes so that it becomes a group of
four bits.
2. Write the decimal equivalent of each pair.
Example 28: Convert (101010010101)2 into hexadecimal.
From right to left, split the number into groups of four bits, which is as follows:
Divided groups: 1010 1001 0101

Equivalent decimal: 10 9 5
So, (101010010101)2 = (A95)16 where A=10
Example 29: Convert (1011011101)2 into hexadecimal.
Divided groups: 0010 1101 1101
Equivalent decimal: 2 13 13
So, (1011011101)2 = (2DD)16
Operations on binary numbers
Operations on binary numbers involve performing various mathematical calculations using binary
notation. The primary operations on binary numbers are addition, subtraction, multiplication, and
division. Some of the operations on binary numbers are given as follows:
Addition
Adding binary numbers is the same as adding decimal numbers. In binary numbers, only two digits
are dealt while ten digits are considered in decimal numbers.
The following are some of the rules for adding binary numbers:
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 1 and a carry 0 to the next digit(more significant bit)
1 + 1 + 1 = 1 and a carry 1 to the next digit (more significant bit)
1 + 1 + 1 + 1 = 0 and a carry 10 (2 in decimal) to the next digit (more significant bit)
Example 30: Add 1001 to 1100
1 → carry
1 0 0 1
+1 1 0 0
----------------------------------------------
1 0 1 0 1
----------------------------------------------
Example 31: Add 1111 to 0110
1 1 1 → carry
1 1 1 1

+0 1 1 0
----------------------------------------------
1 0 1 0 1
----------------------------------------------
Example 32: Add 101, 111 and 101
1 0 1 1 → carry
1 1 0
1 1 1
+1 0 1
----------------------------------------------
1 0 0 1 0
----------------------------------------------
Subtraction
The following are some of the rules for subtracting binary numbers:
0 – 0 = 0
1 – 0 = 1
1 – 1 = 0
0 – 1 = 1 and borrow 1 from the next digit (more significant bit). After taking borrow, the 0
becomes 10, equivalent to 2 in decimal. When 1 is subtracted from 10, the result would be 1.
We can also write 2 in place of 10 in borrow.
Example 33: Subtract 1100 from 1111
1 1 1 1
–1 1 0 0
-------------------------------
0 0 1 1
-------------------------------
Example 34: Subtract 0111 from 1110
1 0 10 10 → Borrow
1 1 1 0

–0 1 1 1
-------------------------------
0 1 1 1
-------------------------------
Multiplication
It is the same as in decimal numbers. Following are the rules for binary subtraction.
The following are some of the rules for the multiplication of binary numbers:
0 * 0 = 0
1 * 0 = 0
0 * 1 = 0
1 * 1 = 1
Example 35: Multiply 1110 to 11
1 1 1 0
* 1 1
------------------------------------------
1 1 1 0
+ 1 1 1 0 *
------------------------------------------
1 0 1 0 1 0
------------------------------------------
Division
The binary division is also performed as the division in decimal numbers by the long division
method. The result is subtracted from the dividend after multiplying the divisor by the quotient.
Consider the following example to understand better.
Example 36: Divide 1010 by 10
Example 37: Divide 110110 by 111
One’s complement

In this operation, each 0 is converted into 1, and each 1 is converted into 0. The following example
shows the one’s complement.
Example 38: Find one’s complement of 1 1 1 0 0. Convert 0 into 1 and 1 into 0, as shown in Figure
4.1
Figure 4.1: One’s complement
Two’s complement
Follow the following steps to figure out what the two’s complement is.
1. Convert the number into binary equivalent.
2. Take one’s complement.
3. Add 1 to the result.
Example 39: Find the two’s complement of 10101.
One’s complement of 10101 = 01010
Add 1 to the result = 01010 +1 = 01011
01011 is the 2’s complement of 10101
Subtraction using two’s complement
To help you understand the idea, let us look at an example:
Example 40: Calculate 1111 − 1011 using two’s complement.
Here, the minuend is 1111, and the subtrahend = 1011
Find one’s complement of subtrahend, which is = 0100
Find two’s complement of subtrahend, which is = 0100 + 1 = 0101
Add the minuend and the two’s complement
1 → carry
1 1 1 1
+ 0 1 0 1
-----------------------------------------
=1 0 1 0 0
-----------------------------------------

Discard the carry 1. The result will be 0100
Negative binary number or signed number representation
The following are the three widely used approaches for representing a binary negative number. The
negation of a number is the process of converting a positive number into its negative number.
Sign-and-magnitude: If the number is positive, the MSB is set to 0; otherwise, it is set to 1. The
first bit of an 8-bit integer shows the number’s sign, whereas the next seven bits show the
number’s magnitude. For example, +20 is represented in binary as 00001010, and –20 is
represented as 10001010.
One’s complement: The negative number is likewise represented by one’s complement. In the
8-bit binary encoding, +20 is represented as 00001010, and –20 is represented as 11110101,
which is the complement of 00001010.
Two’s complement: It also can represent a negative number. For example, +20 is represented in
binary as 00001010 in an 8-bit format. Its one’s complement is 11110101. Its 2’s complement
is 11110101+1=11110110, which in 2’s complement representation of -20.
Other popular codes
Several popular binary codes are used in various applications such as ASCII, BCD, EBCDIC,
Excess-3, and gray. These are explained in the following sections:
ASCII
American Standard Code for Information Exchange is what ASCII stands for. It was made by the
American National Standards Institute (ANSI). It is represented by 7 bits. It can define 128
characters because it is a seven-bit code, that is, 27=128. For example, the letter a has an ASCII
value of 97, and in binary, it is 1100001. Similarly, the letter A has an ASCII value of 65, and in
binary, it is 1000001. It is widely used in computers to represent text files in the computer.
BCD
BCD stands for Binary Coded Decimal. In this coding, each decimal digit is represented by a four-
bit binary number. For example, 23 is represented by 0010 0011, and 5 is represented by 0101.
There are two variants of BCD they are packed BCD and unpacked BCD. Packed BCD uses 4 bits,
while unpacked uses 8 bits to represent a number. In unpacked, the 23 is represented by 00000010
00000011, and 5 is represented by 00000101.
EBCDIC
EBCDIC implies extended binary coded decimal interchange code. It has more characters and
symbols than the ASCII code. It has 8-bit code and hence represents 28 characters (256).
Excess-3
It is a 4-bit number. Each binary equivalent is added with 3 or 0011(in binary). For example, the
zero is represented by 0011 because the binary equivalent of 0 is 0000, and in Exess-3, we add 0011
in it, so the number would be 0000+0011=0011.

Gray code
A single-distance code is another name for it because the bit pattern for two numbers that come
after each other only differs by one bit. The gray code for the number 22 is 11101, the gray code for
23 is 11100, and the gray code for 24 is 10100. These codes only differ by one-bit position from
their consecutive code. It comes under non-positional or non-weighted code. To calculate the gray
code of a number, first, it is converted into binary, and then the given steps are followed:
1. Write down the given binary code.
2. Keep the MSB (Most Significant Bit) or the leftmost bit as it is. As shown in the following
figure
3. Add the MSB to the next bit to get the gray bit. Discard the carry if any
4. Now, take the second MSB and add it to the next bit. Discard the carry, if any. Repeat until the
last bit reached(LSB or Most Significant Bit)
Example 41: Find the gray code of the number 23.
Binary equivalent of 23 = 10111. Look at the Figure 4.2:
Figure 4.2: Binary to gray conversion
So, the gray code of 23 is 11100
Conclusion
This chapter discusses different aspects of writing numbers, such as decimal, binary, octal, and
hexadecimal. It also looks at how to change numbers from one number system to another. There are
different ways to work with binary numbers, such as by adding, subtracting, multiplying, dividing,
taking the one’s complement, taking the two’s complement, or doing the opposite, which is called
negation. We also talk about ASCII, BCD, EBCDIC, Excess-3, and Gray codes, which are also
popular binary codes.
In the upcoming chapter, we will focus on how to solve problems and the various methods to do so,
such as pseudo-codes, algorithms, and flowcharts.
Points to remember
A number system is a method of representing numbers with the help of a set of symbols and
rules.
Each symbol in a positional number system stands for a different value. Binary and decimal are
positional number systems.
The non-positional number system doesn’t use positions; each symbol has the same value.
Only 0 and 1 are used in the binary number system.
The decimal number system uses ten symbols from 0 to 9.
The octal number system uses eight symbols.
The hexadecimal number system uses sixteen symbols.
A binary fractional number consists of two parts: the number before and after the decimal.
One’s complement is obtained by converting each 0 to 1 and each 1 to 0.

Signed numbers can be represented by sign-and-magnitude, one’s complement, and two’s
complement.
ASCII Stands for American Standard Code for Information Interchange. It is a 7-bit code.
ASCII can define 128 characters because it has 7 bits, 27=128.
In Binary Coded Decimal (BCD) coding, each decimal digit is represented by a four-bit binary
number. For example, 23 is represented by 0010 0011.
EBCDIC implies Extended Binary Coded Decimal Interchange Code. It has more characters
than ASCII.
EBCDIC has an 8-bit code and hence represents 28 characters (256).
Excess-3 is a 4-bit number. Each binary equivalent is added with 3 or 0011(in binary).
Gray code is a single-distance code. For example, the gray code of 23 is 11100, and the gray
code of 24 is 10100. Only one bit is different in these codes.
Important questions
1. What is binary language? Why is it preferred for computers?
2. What are weighted and non-weighted numbers? Explain in detail.
3. Describe how to convert a number of any base to decimal.
4. Explain how to change numbers from any of the three bases (2, 8, and 16) systems to the
decimal system by giving examples.
5. How can you subtract two numbers only by adding them together? Give an example to show
what you mean.
6. Give an example of how to transform a binary to a decimal number.
7. How do signed numbers look in binary form?
8. Write the difference between BCD representations that are packed and unpacked.
9. Justify the binary subtraction and subtraction with two’s complements yields the same results.
10. Perform the following operations:
1. 1111+1101
2. 1111–1101
3. 1010*10
4. 1110/11
11. What is the gray code for the number 25?
12. What kinds of numbers does the binary number system represent? Briefly describe.
13. How many characters does the ASCII character set have? And why?
14. What are the rules for subtracting and addition of two binary numbers?
Join our book’s Discord space

Join the book’s Discord Workspace for Latest updates, Offers, Tech happenings around the world,
New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 5Problem-solving Techniques
Introduction
In this chapter, we will study the fundamental aspects of solving problems
in the context of computer programming. We will explore various problem-
solving techniques and understand the role of programming languages in
expressing our solutions. Furthermore, we will learn about language
translators or processors that facilitate the conversion of human-readable
code into machine-executable instructions. In addition, we will explore the
process of compiling and executing programs and gain insights into dealing
with syntax and logical errors during compilation. By the end of this
chapter, you will have a solid foundation to begin your programming
journey and confidently tackle various challenges.
Structure
In this chapter, we will cover the following topics:
Problem-solving approach
Problem-solving techniques
Programming languages
Language translators or processors
Compiling and executing process
Syntax and logical errors in the compilation
Different files generated while writing, compiling, and executing a C
program
Objectives
The chapter’s objective is to provide an understanding of problem-solving
and programming concepts. It covers problem-solving approaches and
techniques, programming languages, language translators, compiling and
executing processes, handling syntax and logical errors, and the files
generated in writing, compiling, and executing C programs. The purpose is

to equip readers with the skills to approach programming challenges
confidently and write efficient, error-free C programs.
Problem-solving
Problem-solving is the process of figuring out what needs to be done to
solve a problem. It starts with describing the problem and ends with finding
the best way to fix it. Before a solution can be found, the problem must be
correctly identified and then turned into clear, executable steps that
everyone understands. Different operators are used in these steps to obtain
the required solution.
Steps for logical and numerical problem-solving
Logical and numerical problem solving involves the following main steps
to solve any problem:
1. Analyze the problem: It is the process of understanding the problem.
To understand the problem better, you should know what the inputs
are and what will be their possible outputs. It simply means knowing
the requirements to solve a problem and its possible solution. Also, the
feasibility of the problem is checked to see whether the problem can
be solved with the existing technology or not.
2. Divide the complex problem into a small, simple task: If a problem is
complex and big, then first divide it into different modules. Solve the
individual modules and club them for the final solution. (It is an
optional step.)
3. Devise a plan to solve the problem: In this step, a plan is devised to
solve the problem. It includes writing the problem into pseudocode,
flowchart, or in the form of an algorithm. The pseudocode, flowcharts,
and algorithm represent your step-by-step strategy for resolving the
issue. This step gives logic to solve the problem.
4. Carry out the plan: It converts the algorithm or pseudocode into a
program (actual code) by using a suitable programming language such
as C, C++, Python, and so on. Feed the program into the computer.
The computer generates the result as output based on the program and
data. This output can be used to make good decisions.

5. Backtracking: Once you get the result as output, you can go back and
make some changes in the program or the plan for further
improvement in the result. You may think to solve the problem
differently to generate a better result. This step is sometimes also
known as the testing and debugging phase.
Solving a logical problem
Let us solve a classical logical problem: the water jug problem. Suppose
you are asked to measure 4 liters of water with the help of two jugs having
a capacity of 3 and 5 liters. The following steps are to be followed:
1. Analyze the problem: First, you will verify whether the necessary
ingredients, like water source, jugs, and so on, are available, which
will act as input. Second, the output is 4 liters of water.
2. Divide the complex problem into a small, simple task: It is a simple
problem, so there is no need to divide it into further sub-problems. (It
is an optional step.)
3. Devise the plan: The following pseudocode (steps) represents the plan
in simple language. These are the steps to achieve the problem’s
solution.
1. Fill the 5-liter jug to the top.
2. Pour the water from the 5-liter jug into the 3-liter jug, leaving 2
liters in the 5-liter jug.
3. Empty the 3-liter jug.
4. Pour the remaining 2 liters of water from the 5-liter jug into the
3-liter jug.
5. Fill the 5-liter jug to the top again.
6. Carefully pour water from the 5-liter jug into the 3-liter jug until
the 3-liter jug is full. It will leave exactly 4 liters of water in the
5-liter jug.
4. Carry out the plan: It converts the algorithm or pseudocode into a
program (actual code) using a suitable programming language such as
C, C++, Python, and so on. Feed the program into the computer, and
you will get the desired output.
5. Backtracking: Let us say that after a few steps, you find that the water
distribution is not leading to the expected result of 4 liters in the 5-liter

jug. Instead of giving up, you backtrack to the previous step where
you had other choices to make (for example, which jug to fill, when to
pour, and so on). You then try a different choice to see if it leads to the
desired outcome.
Solving a numerical problem
Let us take the numerical example of adding two numbers and follow the
preceding steps to solve it so that the concept may be easily
understandable:
1. Analyze the problem: Here, we have to take three variables: two for
input and one for holding output. Let the numbers A and B be the
input and C as output variables. So, we can write it as follows:
Input number: Integer A and B
Output number: Integer C
2. Divide the complex problem: It is already a simple problem, so it is
unnecessary to divide it into small modules.
3. Devise the plan: The pseudocode represents the plan in simple
language. A pseudocode to add two numbers, A and B, to a third
number, C, is given as follows:
1. Start
2. Input: Integer A and B
3. Output: Integer C
4. C=A+B
5. Print C
6. End
4. Carry out the plan: Now, this pseudocode can be converted into the
programming language. The following code represents it in C
language:
#include<stdio.h>
int main()
{
int A, B, Sum = 0;

printf("Enter two numbers A and B : \n");
scanf("%d%d", &A, &B);
Sum = A + B;
printf("Sum of A and B is: %d", Sum);
return 0;
}
5. Backtracking: Once you get the result as output, you can try an
alternate method for solving it. If the output is not in order, revisit the
plan and the code for any possibility of error or other modification to
get the correct output.
Problem-solving techniques
Algorithms, pseudocode, and flowcharts are essential techniques or tools
for solving a problem using the computer. Furthermore, these are converted
into actual computer programs using programming languages such as C,
C++, and so on.
Algorithm
A plan for how to solve a problem step by step without computer hardware
and software is called an algorithm. Then, using a programming language
such as C, C++, and so on, these steps are written down in the form of a
program. This is how a program is made. In other words, an algorithm is a
plan for a computer program.
Characteristics of an algorithm
Finiteness: After a certain number of steps, an algorithm must always
end.
Unambiguous or clear: Each of its steps and their inputs and outputs
should be easy to understand and should only lead to one meaning.
Input: It must have a clear way of providing input.

Output: The algorithm must make it clear what the result will be.
Effectiveness: Every step must be essential.
Language independent: It can be written in any programming
language
Some simple examples of algorithms are given as follows:
An algorithm to add two numbers, A and B, to a third number, C:
1. START
2. Declare three integers A, B, and C
3. Input the value of A and B
4. Add values of A and B
5. Store output of Step 4 to C
6. Print C
7. STOP
An algorithm to find the greater of two numbers:
1. START
2. Declare two integers A, B
3. Input the value of A and B
4. If A > B, then print “A is greater”
5. Else if print “B is greater”
6. Else print “The numbers are equal”
7. STOP

An algorithm to find whether a number is even or odd:
1. START
2. Declare an integer A
3. Input the value of A
4. If A % 2 = = 0, then “print the number is EVEN”
5. Else “Print the number is ODD”
6. STOP
An algorithm to SWAP two numbers:
1. START
2. Declare three integers A, B, and T
3. Input the value of A and B
4. Set T = A
5. Set A = B
6. Set B = T
7. Print A, B
8. STOP
Flowcharts
A flowchart is a diagram that shows the steps to solve a problem like an
algorithm. It is used to show how the algorithm works. It is like a graphical
representation of the algorithm. In other words, it is another technique of
representation of the problem like an algorithm but in the form of a
diagram or picture. It uses different symbols that are linked together to

show how information and control flow. The following are some basic
symbols that are used in a flowchart:
Start: This is the starting symbol, represented by an oval shape.
End: This is the ending symbol, represented by an oval shape.
Arrows: Arrows connect the symbols in the flowchart and show the
program’s flow of control.
Processing: It is represented by a rectangle. It is used to show the
processing step.
Input: This is used to accept the input and is represented by the
parallelogram symbol.
Output: This is used to display the input and is represented by the
parallelogram symbol.
Decision-making/conditional: A diamond-shaped symbol is used in
decision-making statements. It is always connected by two arrows,
which are labeled Yes and No. Depending on the condition of the
diamond, only one arrow generates an output at a time.
Connectors: A circle is used to represent it. It is used in complex and
big flowcharts that occupy multiple pages. This symbol is used to
connect multi-paged flowcharts. It also contains a labeled circle. Table
5.1 shows the symbols used in flowcharts:
Symbols Description
Name
The flow of control
Arrows
Processing
Rectangle
Start and End
Ovals
Input and Output
Rectangle
Decision-making or Conditional Diamond

Connectors
Circle
Table 5.1: The symbols used in flowcharts
A flowchart to add two numbers, A and B, in a third number, C, is shown in
Figure 5.1 for proper illustrations of the previously-said symbols:
Figure 5.1: Flowcharts of the addition of two numbers
Another flowchart to find the greater of two numbers is shown in Figure
5.2:
Figure 5.2: Flowchart of greater of two numbers
A flowchart to find whether a number is even or odd is given in Figure 5.3:
Figure 5.3 Flowchart to find whether a number is even or odd
A flowchart to swap two numbers is given in Figure 5.4:
Figure 5.4: Flowchart to swap two numbers
Pseudocodes
A flowchart, algorithm, and pseudocodes are used to write the steps to
solve a particular problem. It is a brief form of the algorithm. It removes
the unnecessary English from the algorithm. A pseudocode is an informal
way of writing a program in structured English. It focuses on the logic of

the algorithm and does not go into the detail of the language syntax. It can
be directly converted into a program using a programming language.
However, it is not a computer program. It only represents the program’s
algorithm in a language like English and mathematical notations. They are
commonly used in textbooks and research papers for demonstrating an
algorithm. Some examples of pseudocode are given as follows:
A pseudocode to add two numbers, A and B, in a third number, C:
1. START
2. INPUT: Integer A and B
3. C=A+B
4. Print C
5. END
A pseudocode to find the greater of two numbers:
1. START
2. INPUT: Integer A and B
3. IF A > B, THEN print 'A is greater.'
4. ELSE IF print, 'B is greater
5. ELSE print 'The numbers are equal
6. END
A pseudocode to find whether a number is even or odd:
1. START
2. INPUT: Integer A

3. IF A % 2 = = 0 THEN 'print the number is EVEN'
4. ELSE' Print the number is ODD.'
5. END
A pseudocode to swap two numbers:
1. START
2. INPUT: Integer A and B
3. T = A
4. A = B
5. B =T
6. PRINT A, B
7. END
The difference between flowchart, algorithm, and pseudocode is given in
Table 5.2:
Algorithm
Flowchart
Pseudocode
It is a plan for
how to solve a
problem step by
step.
A flowchart is a pictorial
representation of an algorithm
or steps for solving a problem.
It is an informal way
of writing the program.
It is complex to
understand.
It is easy to understand.
It is hard to understand
as compared to the
algorithm.

Text is used to
write the
algorithm.
Different shapes are used to
draw flowcharts.
Text and mathematical
symbols are used to
write the algorithm.
Easy to debug.
Hard to debug.
It is hard to debug as
compared to the
algorithm.
Table 5.2: Difference between algorithm, flowchart, and pseudocode
Programming language
To instruct the computer to do a task, a language is required that is known
as a programming language. It is used to communicate with the computer
by writing a computer program (set of instructions/commands/statements).
There are three types of programming languages, which are given as
follows:
1. Machine Level or Low-Level Language (LLL): This language has
only two symbols, 0 and 1 (binary numbers). All the data and
instructions (the program) should be written in binary code. The
computer can directly understand the code written in this language, as
the computer can only understand binary language. It is also known as
machine language. It does not require a translator (compiler,
interpreter) to convert it to another form, as it is directly
understandable by the computer. It is very close to the computer as the
computer only understands 0 or 1. Every computer has a separate
machine language, so it is machine-dependent and not portable. It is
hard to write a program in this language, and it is even harder to find
bugs (to remove the error) in it.
1. A hypothetical program to add two numbers in binary. The
following program consists of only three commands written in
binary:
01010111 11010101

11010101 10101011
10101010 10101011
2. Generally, the machine-level programs are written in octal or
hexadecimal notations.
2. High-level language (HLL): It simplifies programming by using a
natural language like English to write the program. It is easy to learn
as it uses natural language. Computers can not directly understand the
code written in this language as the computer can only understand
binary language. So, a translator is required to convert the HLL into
LLL, such as compiler, interpreter, and so on. It is very close to
humans because a human can easily understand it. It is machine-
independent and portable, so its program can be executed on any
computer. It is easy to write a program in this language, and it is very
easy to debug (to remove the errors). Examples of HLL are C, C++,
JAVA, FORTRAN, PYTHON, PROLOG, and so on. The following
program shows a program in HLL that is in C language. Example: A
program in C to add two numbers is given as follows:
#include<stdio.h>
int main()
{
int A, B, Sum = 0;
printf("Enter two numbers A and B : \n");
scanf("%d%d", &A, &B);
Sum = A + B;
printf("Sum of A and B is: %d", Sum);
return 0;
}

3. Assembly language: It uses symbols to write a program. These
symbols are called mnemonics, which are easy to remember, such as
ADD, SUB, MUL, and DIV. These mnemonics are written in English.
It is also called middle-level language because it uses both natural
language and symbols. It has the characteristics of HLL and LLL. The
computer does not directly understand them. The program written in
assembly language needs a translator, which is known as an assembler,
to convert it from assembly language to LLL. All the instructions
written in assembly language vary from machine to machine, so they
are machine-dependent; that is, the program written on the computer
will not execute on a different computer. It is very close to the
computer as it is machine-dependent. It is easy to write a program in
this language, and it is very easy to debug (to remove the error) as
compared to LLL and hard as compared to HLL.
Example: A program in assembly language to add two numbers. The
following program consists of three statements:
LOAD A
ADD B
STORE C
In C language, it can be written as follows:
C=A+B;
Language translator
Language translators or processors translate or convert programs written in
one language into another, such as HLL to LLL. A program written in a
programming language is known as source code; when it is translated into
machine language, it becomes object code. The simple mechanism of the
language processor is shown in Figure 5.5:

Figure 5.5: The language translator
There are generally three types of language translators, which are given in
the following subsections:
Compiler: It is a program that changes HLL into LLL. It takes a full
HLL program as input and turns it into LLL. Source code is a
program written in an HLL. When it is turned into LLL, it becomes
object code. So, the compiler turns the source code into something
called object code. Once the object code has been found, it is run to
get the result. This translation is known as compilation. The working
of the compiler is shown in Figure 5.6:
Figure 5.6: The compiler
Functions of the compiler
The main task is to convert HLL to LLL. Find the error in the source code
as per the syntax (grammar) of the language. Display the errors so that the
programmer can remove them. Allocates space to a program in the main
memory. Produces the object code.
Interpreter: It converts an HLL program into an LLL program line by
line; that is, one statement at a time is translated and executed
immediately. The program statements are directly translated line by
line into a machine language without generating any object code. In
contrast to a compiler, an interpreter is a simple program that takes
less space in the memory. It is time-consuming to interpret a program
as compared to compilation because, in an interpreter, each statement
must be translated individually. Thus, a compilation process takes less
time than an interpreted one. The working of the interpreter is shown
in Figure 5.7:
Figure 5.7: The interpreter

Assembler: Software that turns an assembly language program into a
machine or low-level language is called an assembler. The program
written in assembly language is known as source code, and the
assembler’s output is known as object code. After getting the object
code, it is executed to get the result. See Figure 5.8:
Figure 5.8: The assembler
Functions of assembler
The main task is to convert the assembly to LLL.
Find the error in the source code as per the syntax (grammar) of the
language.
Display the errors so that the programmer can remove them.
Allocate space to a program in the main memory.
Produces the object code.
Besides the previously mentioned programs, the following programs also
support writing and executing the program:
Editor: An editor is a program that provides a platform to write,
modify, and edit the source code or text. This text editor has its own
commands used to write, modify, and edit the source code or text.
Linker: It creates an executable file with the .exe extension by
combining the object files generated by the compiler or assembler and
additional bits of code. The linker searches and appends all libraries
required to make a file executable in the object file. It merges two or
more files into one file, for example, the object code of our program
and the object code of library functions, into one executable file.
Loader: It is a program that loads the executable code from the linker,
places it in the main memory, and prepares it for computer execution.
It assigns memory space to the program in the main memory.
Nowadays, all the previously-said tools are clubbed together into one
software package, which is known as the Integrated Development

Environment (IDE) software. Some examples of IDE are Turbo C,
CodeBlocks, Visual Studio, Microsoft Visual C++, Eclipse, and so on.
Compiling and executing process
There are many steps involved in the translation of a C program (source
code) into an executable file, which are discussed as follows:
1. Write a program in the editor, which is a source code with a .c
extension.
2. The source code is fed to the compiler, and the compiler generates an
object code with a .o extension. If some error (syntax error) occurs,
the programmer again opens the source code in the editor, finds the
error, removes them, and compiles them again.
3. By the linker, the object code is linked with some additional files like
library files and other pieces of code necessary for a program in
execution. A binary executable file is generated by the linker with a
.exe extension. If there is any error in linking, say the linker is not able
to link the files to the object code, then it is known as a linking error.
4. This executable file is loaded into the main memory by the loader.
5. After that, the program is executed, and the output, in the form of a
result, is generated. If some error occurs (run time error), the
programmer again opens the source code in the editor, finds the error,
and removes it.
Figure 5.9 shows the complete compilation process as follows:
Figure 5.9: Compiling and executing process
Syntax and logical errors in the compilation
Every language has a set of rules for writing statements. They are known as
the grammar of the language. C also has the grammar to write its program.
It has the following two types:

1. Syntax error: A syntax error occurs if a programmer violates the rule
of grammar in writing the statements. It is associated with the
grammar (the rules of writing the statement syntax) of the statement.
For example, missing a semicolon at the end of the statement, using
undeclared variables in the program, writing misspelled keywords, and
so on. The compiler identifies it at compile time. Examine the
following program:
#include<stdio.h>
void main()
{
int a=2,b=3,c;
c = a + b // semi colon missing: syntax error
printf("Sum is %d",c);
getch();
}
2. Logical or semantic (meaning) error: It occurs when the logic of the
program is wrong. It is associated with the meaning of the statement.
For example, if a programmer places a minus sign in place of a plus
sign. It is not identified at compile time. It is identified at run time
when a program generates wrong results.
Some of the logical errors are shown as follows:
A + B = C;
A = B / 0;
Examine the following program:
#include<stdio.h>

void main()
{
int a = 6, b = 3, c;
c = a + b / 2; //wrong logic parenthesis missing: semantic error
printf("Average of two number is = %d", c);
getch();
}
Files generated in the C program lifecycle
Different files are generated while writing, compiling, and executing a C
program. Some of the important files are listed as follows:
Source code: When we write a program, it has to be saved using the .c
extension. The process of saving a program generates a file. For
example, a file with the name sum.c extension is created and saved.
This file is known as the source code.
Object code: The source code is fed to the compiler, and the compiler
generates another file known as an object code. It has .o extension
such as sum.o extension. The input to the compiler is source code, and
the compiler’s output is object code.
Executable code: By the linker, the object code is linked with some
additional files like library files and other pieces of code necessary for
a program in execution. The linker generates a binary executable file
with a .exe extension known as executable code. For example, the
object code sum.o is converted into sum.exe.
After successful execution, all three files are stored in the C working
directory. The complete process is shown in Figure 5.9.
Conclusion

This chapter focuses on the method taken for problem-solving as well as
the many approaches used in problem-solving, such as flowcharts,
algorithms, and pseudocode. In addition to this, it discusses the several
levels of computer languages, such as high level, low level, and assembly
level, as well as the tools used to translate between these levels, such as the
compiler, interpreter, and assembler. It also explains the process that will be
used to turn the algorithm into a program.
Thus, the upcoming chapter will discuss the introduction and the history of
the C programming language. This is because all the program solution
strategies need to be turned into the computer program. In addition to this,
we will discuss the core components of the C program and the method for
executing the program.
Points to remember
Problem-solving is the process of figuring out what needs to be done
to solve a problem.
Steps in problem-solving for logical and numerical problems are
analyze the problem, divide the complex problem into a small, simple
task, devise the plan to solve the problem, carry out the plan, and
backtrack.
The three main tools for problem-solving are algorithms, flowcharts,
and pseudo codes.
The algorithm is a plan for how to solve a problem step by step
without computer hardware and software.
A flowchart is a diagram that shows the steps to solve a problem like
an algorithm.
A pseudocode is an informal way of writing a program in structured
English. It focuses on the logic of the algorithm and does not go into
the detail of the language syntax.
To instruct the computer to do a task, a language is required that is
known as a programming language.
LLL has only two symbols, 0 and 1.
HLL uses a natural language like English to write the program.
Assembly language uses symbols to write a program. These symbols
are called mnemonics, which are easy to remember, such as ADD,

SUB, MUL, and DIV.
Language translators or processors translate or convert a program
written in one language into another, such as HLL to LLL.
The compiler is a program that changes HLL into LLL. It takes a full
HLL program as input and turns it into LLL.
The interpreter converts an HLL program into an LLL line-by-line.
An assembler is software that turns an assembly language program
into a machine or LLL.
An editor is a program that provides a platform to write, modify, and
edit the source code or text.
The linker searches and appends all libraries required to make a file
executable in the object file.
A loader is a program that loads the executable code from the linker,
places it in the main memory, and prepares it for computer execution.
A syntax error occurs if a programmer violates the grammar rule in
writing the statements.
Logical or semantic errors occur when the logic (meaning) of the
program is wrong.
When we write a program, it has to be saved using the .c extension.
The process of saving a program generates a source code file.
The source code is fed to the compiler, and the compiler generates
another file known as an object code.
The linker generates a binary executable file with a .exe extension
known as executable code by linking the essential files to the object
code.
Important questions
1. What do you mean by problem-solving? Write different techniques for
it with their advantages and disadvantages.
2. Write different steps used in problem-solving for logical and
numerical problems.
3. Write different steps used for solving a real-life problem. Explain
them by taking a suitable example.

4. Write an algorithm, flowchart, and pseudo codes for the largest of
three number problems.
5. Write an algorithm, flowchart, and pseudo codes for finding the root
of a quadratic equation problem.
6. What is a computer programming language? Explain its different types
with their advantages and limitations.
7. What do you mean by language translators or processors? Explain its
different types.
8. Write and discuss the compiling and executing process
9. Differentiate syntax and logical errors
10. Differentiate between compiler and interpreter.
11. Explain different files generated while writing, compiling, and
executing a C program.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 6
Fundamentals of C
Introduction
This chapter comprehensively introduces the C programming language, covering its key attributes and
essential components. This chapter explores the origin and evolution of C by highlighting its enduring
relevance. The chapter delves into the language’s character set, tokens, and general structure, providing
the groundwork for practical learning. It guides you through creating and running your initial C
program while explaining the significance of header files and addressing data types, modifiers, and
type conversion. This chapter establishes a strong foundation for your C programming journey,
enabling you to effectively leverage the language’s capabilities.
Structure
This chapter covers the following topics:
Introduction of C
History of C language
Why C?
Learning of C
C characters or symbols set
Tokens in C
The general structure of the C program
First C program
How to compile and run the C program?
Header files
Data types
Data type modifiers
Type conversion or type casting
Variable declaration vs definition
Objectives

This chapter aims to comprehensively introduce the C programming language, covering its history,
significance, and practical application. It uses a structured approach to explore C’s character set, token
usage, and program structure. It provides hands-on experience with creating and running C programs,
explains header files, delves into data types and modifiers, and demystifies type conversion. The
chapter also clarifies the distinction between variable declaration and definition, building a strong
foundation for readers to confidently engage with C’s fundamental concepts and applications.
Introduction to C
A language is a process of communication with each other, for example, Hindi and English. To
communicate with computers, we need a special language known as a programming language. C is a
computer programming language. It is used to write a computer program that communicates with the
computer. The C was created to write the UNIX operating system. Dennis Ritchie created it in 1972 at
the American Telephone and Telegraph (AT&T) Bell Laboratory in the United States. It was named
C because it was the successor to the B language.
History of C language
The point-wise overview of the historical development of the C programming language is given as
follows:
ALGOL stands for Algorithmic Language. It is the mother of all current programming languages.
The International Group first introduced it in 1960.
Martin Richard created a Basic Combined Programming Language (BCPL) in 1967. 
Ken Thompson created the “B” programming language in 1970.
Dennis Ritchie created the C programming language in 1972. It was named C because it was the
successor to the B language. Several characteristics of preceding languages, such as B and
BCPL, are inherited in C.
The C programming language gained popularity after the release of the book The C
Programming Language by Brian Kerningham and Dennis Ritchie in 1978; because of it, C was
commonly referred to as K&R C.
The American National Standards Institute (ANSI) group standardized the C language in
1989, known as ANSI C, to ensure it remained standard.
It was approved by the International Standard Organization (ISO) committee in 1990. C89 or
C90 (ANSI/ISO C) is the name given to this version.
In 1999, several capabilities of JAVA and C++ were introduced to C, and the ISO approved it as
C99.
The chronological order of the development of the C language is given in Figure 6.1:
Figure 6.1: C Development timeline

Why C?
Several compelling reasons why learning the C programming language forms an essential foundation
for anyone aspiring to become a proficient programmer or delve into the world of software
development are given as follows:
Learning other high-level languages directly without learning C is not easy. Many languages
such as C++, Java, and Python have derived their syntax from C. So, it is treated as their base
language.
It is simple to learn since it writes its programs in English, a commonly used and easy-to-
understand language.
The programs you write in C are compiled and executed much faster than in other languages.
This is because it does not record garbage values, array index bound checking, run-time type
checking, exception handling, and other additional processing overheads. Also, it is a compiler-
based language as it uses a compiler to execute its program, and the compiler is faster than the
interpreter.
C language combines the advantages of both low-level and high-level languages. It is speedy,
like low-level languages that work closely with hardware, and user-friendly (easy to write code),
like in high-level languages.
It is portable as its programs can easily be transferred to other computers. It is hardware-
independent in nature.
Microcontrollers are run by embedded programs written in C. Robots, computers, and
automation all use these microcontrollers. It closely interacts with the hardware.
Due to its speed, many operating systems and system programs are written in C, like UNIX.
Also, it is used in developing games owing to its good speed.
Learning of C
There is a similarity between learning the C language and the English language. When we learn
English, we first learn symbols or the alphabet and then combine the alphabet to form the word.
Furthermore, the collection of the words makes a sentence, and then a collection of the sentences
makes a paragraph by following grammar rules. Similarly, in C, first, we learn the symbols, and then
these symbols make the tokens (variable, constant, keywords, and so on.). Furthermore, these tokens
make the instructions, statements, or commands, and these statements are clubbed together to make a
program. Figure 6.2 shows the C-leaning steps:

Figure 6.2: C learning steps
C characters or symbols set
It is the set of alphabets, digits, and special symbols used to write a valid C program. If any other
characters apart from these characters are written in a program, the compiler will generate the error.
The C character set comprises the following items:
26 English alphabet(small letters): a to z
26 English alphabet(capital letters): A to Z
10 Numeric characters: 0 to 9
31 Special characters: # % ^ & * ( ) - _ = + ~ ‘ “ : ; ? / | \ { } [ ] , . < > $ @ !
The symbols and the names of these 31 special characters are given in Table 6.1:
Symbol
Name
Symbol
Name
Symbol
Name
~
Tilde
=
Equal to
;
Semi-colon
%
Per cent sign
&
Ampersand
]
Right bracket
|
Vertical bar
$
Dollar sign
!
Exclamation mark
@
At the rate symbol
/
Slash
,
Comma
+
Plus sign
(
Left parenthesis
{
Left brace
<
Less than
*
Asterisk
?
Question mark
>
Greater than
\
Backslash
.
Dot or Period operator
_
Underscore
)
Right parenthesis
}
Right brace
-
Minus sign
′
Apostrophe
#
Number sign
^
Caret
:
Colon
[
Left bracket
“
Quotation mark
Table 6.1: C characters and their names

Whitespace characters or escape sequences
Some characters are combined to form some special characters, known as whitespace
characters/execution character sets/escape sequences. They are made up of two characters but are
treated as a single character. They cannot be printed, so they do not display on the monitor. They are
generally used with printf. It comprises a backslash (\) followed by a letter or a combination of digits.
Table 6.2 shows some of the most-used escape sequences:
Symbol
Name
Use
\b
Blank space
Moves the cursor to the previous position
\t
Horizontal tab
Inserts a horizontal tab
\v
Vertical tab
Inserts a vertical tab
\r
Carriage return
Moves at the beginning of the line
\f
Form feed
Moves the initial position of the next page
\n
New line
Moves at the next line
\\
Backslash
Present backslash
\'
Single quote
Displays apostrophe
\"
Double quote
Displays double quotes
\?
Question mark
Present question mark
\0
Null
Used as a NULL character in a string
\a
Alarm (bell)
Generate beep sound
Table 6.2: Whitespace characters
Format specifiers
Format specifiers specify the data type and format of the variables used in formatted input and output
statements like printf and scanf to specify how data is displayed or read.
The most commonly used format specifiers in C are shown in Table 6.3:
Symbol
Use
%d
Displays an integer value
%f
Displays a floating-point value
%c
Displays a character
%s
Displays a string
%p
Displays a memory address
%x
Displays hexadecimal values
%o
Displays octal values
Table 6.3: Format specifiers
These are preceded by a per cent sign (%) followed by optional flags that change the output format. For
example, the %d format specifier can be modified by using the following flags:

%5d: Displays the integer value in a field of width five characters
%-5d: Displays the integer value in a field of width five characters, left-justified
A detailed discussion will be provided in Chapter 17: The Console Input–Output Functions.
Tokens in C
In C, tokens are the smallest individual elements. In the English language, for example, we cannot
construct a sentence without using words. Similarly, we cannot write a C statement without using
tokens. Tokens are the same as the words in English. As a result, we can say that tokens in C are the
building blocks for creating a C program.
Classification of tokens in C
Tokens have the following categories:
Keywords
Variables
Constants
Identifiers
Operators
Special symbols
Let us discuss these categories in detail in the following sections.
Keywords
C keywords are reserved words with specific meanings and functionality within the C programming
language. C has 32 keywords. These keywords cannot be used as a variable, function, or other
identifier name in a C program. They are part of the language’s syntax and are used to define the
structure and behavior of the program. Figure 6.3 is a list of 32 keywords in the C:
Figure 6.3: List of 32 keywords in the C
The brief use of the keywords is given as follows:
auto: It is used to declare variables with a local scope within a block of code.
break: It ends a loop or switch statement and moves control to the statement that follows the loop
or switch.
case: It is used in a switch statement to specify a particular condition or value to match.
char: It is used to define the character data type.

const: It is used to declare a variable as a constant.
continue: It is used to skip to the next loop iteration.
default: It is used in a switch statement as a default condition when none of the other cases
matches.
do: It is used with the while to create a loop called a do-while loop.
double: It is used to define floating-point data types with double precision.
else: It is used to specify an alternative block of code to be executed if the condition of an if
statement is false.
enum: It is used to define a set of named integer constants.
extern: It is used to declare a variable defined in a separate file.
float: It is used to define floating-point data types with single precision.
for: It is used to specify a loop that executes a block of code a specified number of times.
goto: It is used to transfer control to a labeled statement in the program.
if: It is used to specify a conditional statement that executes a block of code if a certain
condition is true.
int: It is used to define integer data types.
long: It defines integer data types with an extended range.
register: It is used to declare a variable as a register variable, storing it in the CPU register for
faster access.
return: It is used to return a value from a function.
short: It defines integer data types with a smaller range than int.
signed: It is used to define signed integer data types.
sizeof: It tells the size of a variable or data type in bytes.
static: It has a local scope and retains its value between function calls.
struct: It defines a structure data type that contains multiple variables of different data types.
switch: This keyword is used to specify a multi-way decision statement based on the value of an
expression.
typedef: It defines a new name for an existing data type.
union: It holds different data types that share the same memory space.
unsigned: It is used to define unsigned integer data types.
void: It indicates that a function does not return a value when used before the function name.
volatile: It indicates that a variable can be modified by an external source and should not be
optimized by the compiler.
while: It is a loop that executes a block of code a specified number of times.
Variables

The computer memory is divided into cells (memory locations). Each cell has an address. A variable is
the name of a memory location that can hold a value of a certain data type. Variables are declared using
a specific syntax, including the variable’s name, data type, and, optionally, an initial value.
The following is the syntax for declaring a variable in C:
data_type variable_name;
For example,
int X=20; 
// variable declaration and initialized with 20
The preceding declaration creates a memory with the name X, and let us assume the memory address is
1010. Its value can be changed, and it can be reused many times. Figure 6.4 shows the block diagram
of the memory holding a value of 20 at an address 1010. The memory location’s name is X, which is the
variable name.
Figure 6.4: The memory holding a variable 20 at address 1010 having name X
The rules for declaring a variable’s name in C are as follows:
A variable name can contain alphabets, digits, and underscores.
Variable names can only begin with the alphabet and an underscore. It cannot start with a digit.
There can be no whitespace and special characters such as @, !, #, %, and so on within the
variable name except the underscore.
A variable name cannot be taken from the keyword list, such as int, float, and so on.
The language specification does not explicitly define the length of a variable name. However,
most C compilers impose a practical limit on the length of variable names, typically 31 to 63
characters.
It is generally a good practice to use meaningful and concise variable names that describe the purpose
of the variable in the program rather than using excessively long names. This can also help avoid
common programming errors such as typos or misspellings in variable names.
Some valid and invalid examples of the variable name are given in Table 6.4:
Variable name
Whether valid or not
A
Valid
Simple interest
Invalid because there is a blank space between two words
Simple_ interest
Valid
2one
Invalid because it is started from the digit
simple@interest
Invalid because no symbol is allowed except an underscore
_kamal
Valid
Simpe123
Valid

Table 6.4: C valid and invalid variable names
Constant
The value of constant remains fixed throughout the execution of the program until we change it in the
program. It is a value assigned to the variable; for example, int a=10 or float b=12.5. Here, 10 and
12.5 are the integer and float constant, respectively. It is also known as C literal. The constant is the
following types, which are shown in Figure 6.5:
Figure 6.5: Types of constants
Integer constant
It can accept only positive or negative integer values. It cannot accept real or decimal values. The
integer constant ranges from –32768 to +32767 (for a 16-bit compiler). Table 6.5 shows examples of
some valid and invalid integers:
Integer constant
Whether valid or not
10
Valid
9.5
Invalid because it contains a decimal
-9
Valid
565656
Invalid because range exceeds
Table 6.5: Valid and invalid integer constants
Real constant
It contains decimal (real) or floating numbers. These numbers are made up of two parts: before the
decimal and after the decimal part, for example, 58.4. It can be either positive or negative. These are
some examples of valid and invalid real constants are given in Table 6.6:
Real constant
Whether valid or not
10.5
Valid
9,5
Invalid because it contains a comma
-9.5
Valid
565 656
Invalid because space is not allowed
Table 6.6: Valid and invalid real constants
Character constant
A character constant is a single character (symbol) wrapped by two single inverted commas (‘’). Table
6.7 exhibits the examples of valid and invalid character constants:
Character constant
Whether valid or not
'a'
Valid

'97'
Valid
'A'
Valid
'='
Valid
A
Invalid because a single inverted comma is missing
Table 6.7: Valid and invalid character constants
String constant
It is a group of characters. The string is a collection of characters surrounded by double quotes. Table
6.8 exhibits the examples of valid and invalid string constants:
Character constant
Whether valid or not
“KD”
Valid
“Hello”
Valid
“A”
Valid
Table 6.8: Valid and invalid string constants
Note: “A” and ‘A’ are different
Identifiers
Identifiers are user-defined words. It is a name given to the memory location. These words are used in
C to name variables, functions, arrays, structures, and so on. The rules for constructing identifiers in C
are given as follows:
An identifier name can contain alphabets, digits, and underscores.
Identifier names can only begin with the alphabet and an underscore. It cannot begin with a digit.
There can be no whitespace and special characters such as @, !, #, %, and so on within the variable
name except the underscore.
Identifiers’ names must not contain reserved words or keywords such as int, float, and so on.
Identifier names are case-sensitive because C differentiates between upper- and lower-case
letters.
Because only 31 characters are significant, the identifier names should not exceed 31. The
language specification does not explicitly define the length of an identifier name. However, most
C compilers impose a practical limit on the length of identifier names, typically 31 to 63
characters.
Identifiers should be expressed in a meaningful, brief, and easy-to-understand style.
Operators
Operators are symbols that perform operations on operands. For example, in the expression a=b+c, a,b,
and c are the operands, and = and + are the operators. The following are the types of operators:
Arithmetic (+, -, *, /)
Relational (<, >, <=, >=, ==, !=)

Logical (&&, ||, !)
Assignment (=, +=, -=)
Special symbols
Special symbols separate different parts of a program or provide structure. Examples of special
symbols include the following:
Braces ({ })
Parentheses (( ))
Semi-colons (;)
Commas (,), and so on.
The general structure of the C program
The following lines of code show the general structure of the C program. A C program generally
consists of header files, comments, datatypes, functions, input statements, processing statements, and
output statements. The general syntax of a simple C program is given as follows:
/* …………Comments………………*/
#include <header file1>
#include <header file2>    
void main()
{    
  Declaration of variables;
  Input statements;
  Processing statements;
  Output statements;    
}  
A detailed description of the components of the preceding syntax is given in the next topic.
First C program
To write the first C program, open any C editor and write the following code:
// Program 6.1 prints Hello C
#include <stdio.h>
void main()
{    
  printf("Hello C");    
}  

Output:
Hello C
Description of the preceding program
The program includes the standard input-output library <stdio.h>. Within the main() function, the
printf function is called with the argument Hello C enclosed in double quotes. This program prints the
string Hello C to the console.
Note:
Each program must have a single main() function. It is treated as the starting point of the program. The main() does
not return value, so void is used before it.
Each statement is terminated by a semi-colon (;). It is a statement finisher.
The opening of the braces ({) denotes the start of the main function, while the closure of the braces (}) shows the end.
Before the main(), header files are included.
Because C is case-sensitive, all statements are written in small letters. It distinguishes between upper-case and lower-case
letters.
printf(): It prints data to the console (output screen).
Comments
Comments are used to add human-readable text to the program (source code) without affecting the
program’s behavior. Comments are ignored by the compiler and are not executed as part of the
program. It is of the following two types:
1. Single-line comments: It starts with two forward slashes // and continues to the end of the line.
It is applied when we have to make a single line as a comment. For example:
// A single-line comment
2. Multi-line comments: It starts with a forward slash and an asterisk /* and ends with an asterisk
and a forward slash */. It is applied when making multiple lines or a paragraph as the comment.
It is also known as a paragraph comment. For example:
/* A multi-line comments
It is also known as block comment */
Comments explain the purpose of the code. They can also temporarily disable a block of code during
development or debugging.
printf() and scanf() functions
printf and scanf are the two most commonly used functions in C. They are explained as follows:
printf: It is used to print on the output screen. Whatever is written in double quotes in the printf
function will be printed as it is. Considering the following code:
printf("HELLO C");
Its output will be HELLO C. Consider the following statement:
printf(format_string, argument_list);

The format_string is the format specifiers list. The argument_list lists one or more values that
correspond to the format specifiers in the format_string.
The following is an example of using printf to print the value of an integer variable:
int a = 42;
printf("The value of a is %d", a);
The output will be: The value of a is 42. The %d is the format_string, and a is the argument_list.
3. scanf: It is used to read input from the keyboard. The basic syntax is as follows:
scanf(format_string, argument_list);
The format_string is the format specifiers list. The argument_list lists one or more variables
that correspond to the format specifiers in the format_string.
Take the following example:
int num;
scanf("%d", &num);
It asks the user to enter an integer. The & operator passes the address of the variable to scanf.
A detailed study of the console input and output function and other related terms will be done in the
coming chapters.
How to compile and run the C program?
The following are the two methods for compiling and running the C program:
Using the menu: To compile the C program, go to the compile menu and then the compile sub-
menu. Then, select the run sub-menu from the run menu to run the C program.
Using a shortcut: To compile the program in Turbo C, press Alt + f9, and to run it, by pressing
Ctrl + f9. F2 is used to save the program with the .C extension, and Alt + Enter is used for full-
screen mode.
Header files
They are placed at the beginning of the program. These files contain the definition of pre-defined
functions, data types, constants, and so on. The header files with the extension .h are added to the
program using the #include preprocessing directive. For example, #include<stdio.h>.
There are two types of header files:
1. Built-in header files: These files are already available in C. They are also known as standard
header files. We need to include them in our program. Some of the standard header files are
given as follows:
#include<stdio.h>: It stands for standard input and output header files. It contains functions
such as scanf() and printf().
#include<conio.h>: It stands for console input output header file. It contains the functions
such as clrscr()and getch().

#include<string.h>: It includes string manipulation functions such as strlen(), strcmp(),
strcpy(), and so on.
#include<math.h>: It includes many mathematical operations such as sqrt(), pow(), and so
on.
#include<stdlib.h>: It stands for standard library header files. It includes some
miscellaneous functions such as malloc(), calloc(), realloc(), free(), abs(), exit(), and so
on.
User-defined header file: It is created by the user as per his requirement and can be imported
into the program whenever required. The following steps are required to create a user-defined
header file:
1. Write your own C function, save that file with the .h extension, and run it. For example:
// Creates user-defined function.
void add ()
{
  int a,b,c;
  printf("Enter two numbers\n");
  scanf("%d%d",&a,&b);
  c=a+b;
  printf("The sum is =%d",c);
}
2. Create a main program to include the previously-created header file into the program by
writing #include "name_of_header_file" and run it. For example:
// Program 6.2 calls the above created user-defined header file
#include<stdio.h>
#include "sum.h" 
//Including user-defined header file
void main()
{
  add(); 
//add() is being called from sum.h //header file
}
Data types
It tells about the type of data that is used in the program. Every variable in the program has an
associated data type. To handle data types, for example, integer, real, character, and so on, C supports a
rich set of data types. These can be classified into two categories, which are shown in Figure 6.6:

Figure 6.6: Types of data types
Primary data types
These are also known as basic or built-in data types. Its type is shown in Figure 6.7:
Figure 6.7: Types of primary data type
The primary data type is further categorized into five sub-parts, which are as follows.
Character
It is used to store characters. It holds a single character. For example, a, b, c, A, B, C, and so on. The
following are its key features:
Its declaration is made with the char keyword.
It takes one byte of memory to store the character.
It can store 28 (256) different values.
Its format specifier is %c.
For example, it is declared and defined as follows:
char ch;
ch='A'
Program 6.3 will elaborate on it in more detail.
// Program 6.3 prints a character
#include<stdio.h>

void main()
{
    char ch;
    ch='A';
    printf("%c",ch);
}
Output:
A
It declares a character variable named ch and initializes it to 'A'. When the program is run, it will
output the character 'A' to the console.
The character data type has further two types:
1. Signed character data type
It can hold both positive and negative values.
Its declaration is made with an unsigned char keyword.
It takes one byte of memory to store the character.
It can store 28 different values (–128 to +127).
Its format specifier is %c.
2. Unsigned character data type
It can hold only positive values.
Its declaration is made with an unsigned char keyword.
It takes one byte of memory to store the character.
It can store 28 different values (0 to 255).
Its format specifier is %c.
Integer
It is used to store integer data. It stores whole numbers (positive, negative, or zero), for example, 2, 5, –
5, and so on. The following are its key features:
Its declaration is made with the int keyword.
It takes two bytes of memory to store.
It can store 216 different values.
Its format specifier is %d.
The integer data type has two further types:
Signed integer data type
It can hold both positive and negative values of the integer.

Its declaration is made with a signed int keyword.
It takes two bytes of memory to store.
It can store 216 different values (–32,768 to +32,767).
Its format specifier is %d.
Unsigned integer data type
It can hold only positive values.
Its declaration is made with an unsigned int keyword.
It takes two bytes of memory to store.
It can store 216 different values (0 to 65,535).
Its format specifier is %u.
Furthermore, these data types can be modified using the data type modifiers, that is, long and short.
Short-signed integer data type
It can hold both positive and negative values.
Its declaration is made with a short signed int keyword.
It takes two bytes of memory to store.
It can store 216 different values (–32768 to +32767).
Its format specifier is %d.
Long-signed integer data type
It can hold bigger data than a signed integer, having the data both positive and negative.
Its declaration is made with an unsigned long int keyword.
It takes four bytes of memory to store.
It can store 232 different values (–2147483648 to +2147483647).
Its format specifier is %ld.
Short-unsigned integer data type
It can hold only positive values.
Its declaration is made with a short unsigned int keyword.
It takes two bytes of memory to store.
It can store 216 different values (0 to 65535).
Its format specifier is %u.
Long-unsigned integer data type
It can hold only positive values bigger than the unsigned integer data type.
Its declaration is made with a long unsigned int keyword.
It takes four bytes of memory to store.
It can store 232 different values (0 to 4294967295).

Its format specifier is %lu.
Note: The size of the integers depends on the word size of a machine, like 16-bit or 32-bit. The
preceding description is for the 16-bit word size machine. For 32-bit word size, the size of the
integer gets doubled, that is, 4 bytes. The word is the number of bits that can be processed at
once by the processor, and it is usually 32 bits and 64 bits on modern systems. Assuming a 16-bit
word size, the memory space required for an integer would be one word or two bytes.
Real data type
It is also called float data type. It is used to store decimal numbers, both positive and negative, with
six digits of precision, for example, 25.210000. The following are its key features:
Its declaration is made with an unsigned float keyword.
It takes four bytes of memory to store the real number.
It can store a range from 3.4e–38 to 3.4e+38.
Its format specifier is %f.
These range values are approximate because they depend on the specific implementation and hardware.
The range can vary slightly from one system to another.
Double data type
It is also used to store real numbers. It is also used to store the decimal or real bigger than floating
numbers, both positive and negative. The following are its key features:
Its declaration is made with a double keyword.
It takes eight bytes of memory to store.
It can store a range from 1.7e–308 to 1.7e+308.
Its format specifier is %lf.
These range values are approximate because they depend on the specific implementation and hardware.
The range can vary slightly from one system to another.
Void
The word void means nothing. It tells the return type of the function. For example, void main () means
the main does not return any value. It can also be passed in the function to specify no arguments. It is
also used to create a generic pointer. The following are its key features.
Its declaration is made with a void keyword.
A void is used to indicate the absence of a value or a datatype.
It indicates the function does not return any value.
It is used to create a generic pointer that can point to any datatype.
Derived data types
They are derived or made from the primary data types. They are also known as the secondary data
type. The following are the types of derived data type:

Arrays: It is a collection of similar data types; for example, the student name is a collection of
characters. The class roll numbers are the collection of integers.
String: It is a collection of characters terminated with a null character (“\0”). For example, a
person’s name is a string.
Structures: It is a collection of dissimilar data types. It may contain the data types such as an
integer, character, float, double, and so on. Structures are used to keep a record. For example, the
student’s record may contain the student’s name, roll number, class, and so on.
Union: It is a collection of dissimilar data types like structure.
Pointers: It holds the address of the variable.
Enum: It allows you to define a set of named constants. Each constant in the enum is assigned an
integer value, starting with 0 by default. For example, in the enum color{Red, Green, Blue},
Red is initialized with 0, Green with 1, and Blue 2, where emum is a keyword. You can also assign
different integer values to the constants if you wish. The following program illustrates the
concept of the enum:
// Program 6.4 illustrates the enum
enum color{Red, Green, Blue};
 int main()
{
    enum color C;
    C = Green;
    printf("%d",C);
    return 0;
}
The output of the program is 1.
Array, structure, union, and so on are sometimes also known as user-defined data types because
programmers use basic data types to create them. A detailed description of these datatypes is given in
subsequent chapters.
An alternative way of declaring a variable of a user-defined data type is to use the typedef keyword. It
defines a new name for an existing data type. For example:
// Program 6.5 illustrates typedef
#include <stdio.h>
typedef unsigned int uint;
int main() 
{
    uint x = 42;

    printf("x = %u\n", x);
    return 0;
}
Output: 42
In this program, the typedef has been used to define a new type uint, which is equivalent to unsigned
int. Then, a variable x of type uint has been assigned by 42. Finally, we use printf to print out the
value of x.
The output of the program is as follows:
x = 42
Data type modifiers
Modifiers are the keywords placed before the data type to modify (either increase or decrease) the
amount of storage space allocated to a variable. They are used to specify additional properties such as
the range of values that can be stored, the precision of the data, or how the data is stored in memory.
Figure 6.8 shows the datatypes modifiers used in C.
Figure 6.8: Data types modifiers
The following describes the main data type modifiers used in C
Long: It is used to increase the capacity of the current data type. It can be applied to int or double
data types. Integers, for example, take up two bytes of memory. When we use long with an
integer variable, it takes up four bytes of memory. For example:
long int a;  
short: It occupies two bytes of memory space in every operating system. It is generally used
with the int data type. For example:
short int a; 
unsigned: It can be used to accept positive data types only. For example:
unsigned int a =50; 
 
// right
unsigned int a =-50; 
 
// wrong

signed: This keyword accepts negative and positive values, which is the default property of any
data type. For example:
int a=50; 
 
 
// right
int a=-50; 
 
// right
signed int a=50; 
 
// right
signed int a=-50;  
// right
Type conversion or type casting
It is a process of converting one data type to another. Either it can be converted by the programmer
manually (Explicit type conversion), or it can be converted by the compiler (implicit type conversion)
itself. They are discussed as follows:
Implicit type conversion: It is done internally or implicitly by the compiler. The expression can
have two or more data types. When the small data type is converted into a large data type, it is
called promotion, and when a large is converted into a small, it is known as a demotion of the
data type. Refer to Figure 6.9:
Figure 6.9: Type conversion
In the following example, the integer a is a type promoted internally into a float value:
int a=20;
float b;
b=a;  
//Implicit promoted conversion
// Program 6.6 shows implicit type conversion (promotion)
#include<stdio.h>
main()
{

   int i=20;
   float a;
   a=i;  
 
//Implicit conversion
   printf("After type conversion:%f\n",a);
}
Output:
After type conversion:20.000000
Let us examine the following code. In the following example, the integer b is a type demoted
internally into an integer value:
int a;
float b=10;
a=b;  
 
//Implicit demoted conversion
// Program 6.7 shows implicit type conversion (Demotion)
#include<stdio.h>
main( )
{
    int a;
    float b=10;
    a=b;  
 
//Implicit demoted conversion
    printf("After type conversion:%d\n",a);
}
Output:
After type conversion:10
Explicit type conversion: It is done by the user by placing the required data type into
parenthesis. It is also known as typecasting. For example, the integer a is typecasted into a float
value in the following example:
int a=50,b=7;
float c;
c=(float)a/b;
// Program 6.8 shows explicit type conversion

#include<stdio.h>
main()
{
   int a=50,b=7;
   float c;
   c=(float)a/b; //Explicit conversion
   printf("After type conversion:%f\n",c);
}
Output:
After type conversion:7.142857
Variable declaration versus definition
Variable declaration: This is a statement that specifies the data type and name of a variable that will
be used in the program. The declaration typically takes place at the beginning of a program.
For example,
int x;  // variable declaration
float y; 
// variable declaration
x and y are declared as integer and float-type variables, respectively. This means that the program
knows the existence of these variables but does not allocate memory space for them yet.
Variable definition: A variable definition is a statement that assigns a value to a variable and reserves
memory space for it. The definition can occur anywhere in the program, typically following the
declaration.
For example,
int x = 10;  
 
// variable definition
float y = 3.14;  
// variable definition
x and y are defined as integer and float-type variables, respectively. This means the program reserves
memory space for these variables and assigns them initial values.
Conclusion
This chapter gives the introduction and history of C language. It also focuses on the building blocks of
C language, such as character sets and tokens, that is, keywords, variables, constants, and so on. It also
tells about the fundamental components of the C program and the method of execution. The basic data
types and type conversion are also discussed here.
The upcoming chapter will discuss the operators and expressions used in C language. Some operators
are arithmetic, increment, decrement, relational, logical, bitwise, shift, assignment, comma, sizeof(),
conditional, and address operators are also discussed in the chapter.

Points to remember
Dennis Ritchie created the C programming language in 1972 to write the UNIX operating
system.
C was named C because it was the successor to the B language.
Learning the C language is similar to learning the English language.
The character set includes the set of alphabet, digits, or special symbols used to write a valid C
program.
Format specifiers specify the data type and format of the variables being used in formatted input
and output statements. These are preceded by a per cent sign (%).
Tokens are the smallest individual elements of the program.
Keywords are reserved words. The C programming language has 32 reserved keywords.
A variable is the name of the memory cell. It is used to store data.
Constant value remains fixed throughout the execution of the program.
Identifiers are user-defined words. These words are used in C to name variables, functions,
arrays, structures, and so on.
Comments are used to add human-readable text to the source code without affecting the
program’s behavior.
Header files are placed at the start of the program. These files contain the definition of pre-
defined standard library functions, data types, constants, and so on.
Data types tell about the type of data that is used in the program.
The integer stores whole numbers (positive, negative, or zero).
A signed integer can store 216 different values (–32,768 to +32,767)
An unsigned integer can store 0 to 65,535 values.
The float stores positive and negative decimal numbers.
The void tells the return type of the function.
Derived data types are made from the primary data types
Modifiers are the keywords placed before the data type to modify (either increase or decrease)
the value of a variable.
Type conversion is a process of conversion of one data type to another.
A variable declaration does not reserve memory for a variable, whereas a variable definition
reserves it.
A variable definition is a statement that assigns a value to a variable and reserves memory space
for it. The definition can take place anywhere in the program.
Important questions
1. Learning English is similar to learning C. Justify it.
2. Explain the timeline of C development.

3. Why is C language given preference in the world of the programmer?
4. Write the basic components of a C program with its syntax.
5. What is the character set in C? Can we use another character other than the C character set?
Justify.
6. Explain the uses of format specifiers and escape sequences.
7. What are tokens? Explain its different types.
8. What are the keywords? Can we use the keyword name as the name of the variables?
9. What is the difference between variable and constant?
10. What are identifiers? Why are these used in C?
11. Explain the use of a comment in the program. Discuss its types.
12. What are the header files? Why are they included in the program? Explain its different types.
13. How would you create your own header file? Write the process of including it in the program.
14. What are data types? Why are they used? Give its types.
15. Why are modifiers used in the program?
16. What is type conversion? Write the process of promotion and demotion in it. Also, discuss the
types of type casting by using a suitable example.
17. Differentiate between variable declaration and variable definition.
18. Differentiate between implicit and explicit typecasting by taking a suitable example.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech happenings around the world, New
Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 7
Operators and Expressions
Introduction
The essence of programming lies in operators and expressions, forming the
foundation of data manipulation and operations in any language. Operators
are essential for crafting efficient code and are categorized by operand count
and operation type. Understanding their precedence and associativity in C is
key to expression evaluation. This chapter will explore these vital concepts,
empowering you to write precise and robust programs.
Structure
In this chapter, we will cover the following topics:
Operators and expressions
Types of operators depending upon the number of operands
Types of operators depending upon the operation it performs
Precedence and associativity of operators in C
Objectives
This chapter aims to provide a comprehensive understanding of operators
and expressions in C. We will cover different types of operators based on
operands and operations performed and explore the crucial concepts of

operator precedence and associativity. This knowledge will empower you to
create efficient and precise code while effectively leveraging the capabilities
of C’s operators and expressions.
Operators and expressions
Expression: It is defined as the combination of opcode (operator code) and
operand; for example, consider the following expression:
A = B + C
The letters A, B, and C are called operands, and the symbols = and + are
known as the operators (operation code). An expression with arithmetic
operators is known as an arithmetic expression. If it holds a relational
operator, then it is known as a relational expression, and so on.
Operators: The symbols that are used to carry out the operations on the
operands, for example, +, -, =, and so on, are known as operators.
Operands: An operand may be a variable or a constant on which the
operation is performed, such as A, B, 5, 8.3, and so on.
Operators based on operand count
Depending upon the number of operands, the operator has three types.
Figure 7.1 illustrates its types:
Figure 7.1: Types of operators
Let us discuss these types in detail:
Unary operator: It takes a single operand to generate a new value. For
example, -a, a++, &a, ~a, and so on. The unary operands with their symbols

and names are given in Figure 7.2:
Figure 7.2: Unary operators
Binary operator: It takes two operands to generate a new value.
Some of the binary operands are given in Figure 7.3:

Figure 7.3: Binary operators
Ternary operator: It takes three operands to generate a new value.
The conditional operator works as the ternary operator. It is
represented by two symbols. They are (?) and (:). Its syntax is given
as follows:
Condition1 ? Expression2 : Expression3 
For example,
int a=4, b=7, c=9, x;
x = (a < b)? b: c;
If the condition (a<b) is satisfied, the value b will be allocated to the variable
x; otherwise, the variable x will be assigned the value c. As a result, the
answer to the previous expression will be 7 when x is evaluated.
Operators based on operation type
Depending on the type of operation it performs, the operators are shown in
Figure 7.4:

Figure 7.4: Types of operators
Let us discuss these types in detail.
Arithmetic operators
The operators perform arithmetic operations. Figure 7.5 shows the
arithmetic operators and their use with an example: Let us consider two
variables be A=7 and B=2, then:
Figure 7.5: Arithmetic operators
// Program 7.1 illustrates arithmetic operators
#include <stdio.h>

void main()
{
    int a = 7,b = 2;
    printf("The sum of a and b = %d \n", a+b);
    printf("The difference between a and b = %d 
\n", a-b);
    printf("The product of a and b = %d \n", a*b);
    printf("The division of a and b  = %d \n", 
a/b);
    printf("a mode b = %d \n", a%b);
}
Output:
The sum of a and b = 9
The difference between a and b = 5
The product of a and b = 14
The division of a and b  = 3
a mode b = 1
Increment and decrement operators
The value of a variable goes up by one with the increment operator, and it
goes down by one with the decrement operator. Assume variable A holds 7.
Figure 7.6 shows the increment and decrement operators as follows:

Figure 7.6: Increment and decrement operators
It has the following two variants:
Post increment: The value is incremented after assigning the value to
the variable. It is used as a++.
Pre increment: The value is incremented by one before assigning the
value to the variable. It is used as ++a.
Similarly, pre-decrement and post-decrement operators are there, which are
written like --a and a-- respectively:
// Program 7.2 for illustration increment and decrement operators
#include <stdio.h>
int main()
{
    int a = 7, b = 8, c = 9, d = 10;
    printf("++a gives = %d \n", ++a);
    printf("c++ gives = %d \n", c++);
    printf("--b gives = %d \n", --b);
    printf("d-- gives = %d \n", d--);
    printf("c gives = %d \n", c);
    printf("d gives = %d \n", d);
    return 0;
}
Output:
++a gives = 8
c++ gives = 9
--b gives = 7

d-- gives = 10
c gives = 10
d gives = 9
Relational operators
It determines the relation between two operands. It is generally used in
conditional statements and loops. If the relation is true, it returns one;
otherwise, zero. Let the two integers be A=7 and B =2; Figure 7.7 shows their
value after applying the relation operator:
Figure 7.7: Relational operators
// Program 7.3 to illustrate relational operators
#include <stdio.h>
void main()
{
    int a = 7, b = 2;
    printf("%The a == b returns %d\n", a == b);
    printf("a != b returns %d\n", a != b);
    printf("a > b returns %d\n", a > b);

    printf("a < b returns %d\n", a < b);
    printf("a < b returns %d\n", a >= b);
    printf("a <= b returns %d\n", a <= b);
}
Output:
The a == b returns 0
a != b returns 1
a > b returns 1
a < b returns 0
a < b returns 1
a <= b returns 0
// Program 7.4 to illustrate relational operators
#include <stdio.h>
main()
{
    int a = 7;
    int b = 2;
    if( a == b )
            printf("a and b are equal");
    if( a != b )
            printf("\n a and b are not equal");
    if( a > b )
            printf("\n a is greater than b");

    if( a < b )
            printf("\n a is less than b");
    if( a <= b )
            printf("\n a is less or equal to b");
    if( a >= b )
            printf("\n a is greater than or equal 
to  b", a,b);
}
Output:
 a and b are not equal
 a is greater than b
 a is greater than or equal to  b
Logical operators
These operators are used in decision-making statements. An expression
returns either one or zero, depending on whether the expression evaluates to
true or false. Let variables A =5, B=10, and C=3. The description of the logical
operators is given in Figure 7.8:
Figure 7.8: Logical operators
The truth tables of logical operators are given in Figure 7.8:

Figure 7.9: Logical operator’s truth table
The zero is considered false, and one is considered as true.
// Program 7.5 to illustrate logical operators
#include <stdio.h>
void main()
{
  int k=0, a,b,c;
  printf("Enter three numbers:\n");
  scanf("%d%d%d",&a,&b,&c);
  k=((c>a) && (c>b));
  printf("k=%d\n", k);
  k=((c>a) || (c>b));
  printf("k=%d\n",k);
  k=!a;
  printf("k=%d\n",k);
  k=!b;
  printf("k=%d\n",k);

}
Output:
Enter three numbers:
10
15
20
k=1
k=1
k=0
k=0
Bitwise operators
It acts on bits of the operands. The operator names and their descriptions
with examples are shown in Figure 7.10:
Figure 7.10: Bitwise operators
The truth table for the bitwise operator is shown in Figure 7.11:

Figure 7.11: The truth table of the bitwise operation
To discuss the bitwise operators in more detail, let A = 10 and B = 20 in the
8-bit representation of binary. They are represented as follows:
A = 0000 1010 in binary
B = 0001 0100 in binary
-----------------------
A & B= 0000 0000
-----------------------
0000 0000 is equal to 0 in decimal
// Program 7.6 to illustrate bitwise AND operator
#include <stdio.h>
void main()
{
    int a=10,b=20;
    printf("The value of a & b = %d\n",a&b);
}
Output:

The value of a & b = 0
Let us try the same example for the bitwise OR operator:
A = 0000 1010 in binary
B = 0001 0100 in binary
-------------------------
A|B= 0001 1110
-------------------------
0001 1110 is equal to 30 in decimal
// Program 7.7 to illustrate bitwise OR operator
#include <stdio.h>
void main()
{
    int a=10,b=20;
    printf("The value of a | b = %d\n",a|b);
}
Output:
The value of a | b = 30
The same example for bitwise XOR is shown as follows:
A = 0000 1010 in binary
B = 0001 0100 in binary
-------------------------
A^B= 0001 1110
-------------------------
0001 1110 is equal to 30 in decimal
// Program 7.8 to illustrate bitwise XOR(exclusive OR) operator

#include <stdio.h>
void main()
{
    int a=10,b=20;
    printf("The value of a ^ b = %d\n",a^b);
}
Output:
The value of a ^ b = 30
For the bitwise, NOT operator, consider the following:
A = 0000 1010 in binary
-------------------------
~A= 1111 0101
-------------------------
1111 0101 is equal to 245 in decimal.
// Program 7.9 for bitwise NOT operator
#include <stdio.h>
void main()
{
    int a=10,b=20;
    printf("The value of ~a = %d\n",~a);
    printf("The value of ~b = %d\n",~b);
}
Output:
The value of ~a = -11

The value of ~b = -21
1111 0101 is equal to 245 in decimal, but the output is –11. Let us
understand it.
In 2’s complement representation, the value of 1111 0101 is –11. The 2’s
complement of a number represents its negative number. It is calculated by
taking the 1’s complement of the number and adding one to it. The 1’s
complement of 1111 0101 is 00001010; when we add one to it, it becomes
(00001010 + 1) = equal to 11, which is a –11 in 2’s complement (refer to
negative number representation in 2’s complement method).
So, from what has been previously said, we can say that the bitwise
complement of any integer x is - (x + 1).
Similarly,
B = 0001 0100 in binary
-------------------------
~B= 1110 1011
-------------------------
1110 1011 is equivalent to 235 in decimal. Its 1’s complement is 0001 0100.
Add one to it to find the 2’s complement, which is (0001 0100 + 1), equal to
–(21) in the 2’s complement representation.
Shift operators
These operators shift the bits left or right. There are two types of shift
operators, which are given as follows:
Bitwise left shift operator: It is represented by << symbol. For
example, A<< 2. It shifts all the bits to the left by two positions and
appends two zeros at the right. To understand it in a better way,
consider the following:
Let A = 10. The binary value of A = 0000 1010.
A<< 2 = 0010 1000, which is equal to 40 in decimal
Bitwise right shift operator: It is represented by >> symbol. For
example, A >> 2. It shifts all the bits to the right by two positions and

appends two zeros at the left. Consider:
Let A = 10. The binary value of A = 0000 1010.
A>> 2 = 0000 0010, which is equal to 2 in decimal
// Program 7.10 for bitwise left shift
#include <stdio.h>
void main()
{
    int A=10, B=20;
    printf("The value of A after the left shift by 
2 = %d\n",A<<2);
    printf("The value of B after the right shift by 
2 = %d\n",B>>2);
}
Output:
The value of A after the left shift by 2 = 40
The value of B after the right shift by 2 = 5
Comma operator
It is used in two senses. First, as an operator and second, as a separator:
As an operator: It begins by determining the value of the first
operand, discards the result, and then evaluates the value of the second
operand and returns it. Consider the following statements:
int a = 10, b = 20, x = 0;
x = (a++, b = a + b);
First, it evaluates a++. Second, b = a + b and returns its value, that is,
31.

As a separator: It separates two or more similar things such as a
variable name, parameters in a function call, and so on. For example:
int a, b, c=2, d;                 //as a 
separator
void sum(x, y);                 //as a 
separator
// Program 7.11 to illustrate using the comma operator
#include <stdio.h>
void main()
{
    int a = 10,b = 20,x = 0;        //as a 
separator
    x =(a++, b = a + b);        //as  an operator
    printf("The value of x=%d",x);
}
Output:
The value of x=31
The sizeof( ) operator
It gives back the operand size in bytes. Look at the following case:
int a;
float b;
sizeof(a)     //Returns 4
sizeof(int)     //Returns 4
sizeof(float)     //Returns 8

sizeof(b)     //Returns 8
Note: The preceding size is for 32-bit word size.
// Program 7.12 to illustrate sizeof() operator
#include <stdio.h>
void main()
{
    int a;
    float b;
    double c;
    char d;
    printf("char=%d B\n",sizeof(d));
    printf("char=%d B\n",sizeof(char));
    printf("int=%d B\n",sizeof(a));
    printf("int=%d B\n",sizeof(int));
    printf("float=%d B\n",sizeof(b));
    printf("float=%d B\n",sizeof(float));
    printf("double=%d B\n",sizeof(c));
    printf("double=%d B\n",sizeof(double));
}
Output:
char=1 B
char=1 B

int=4 B
int=4 B
float=4 B
float=4 B
double=8 B
double=8 B
Assignment operators
An assignment operator is used to allocate a value to a variable. For this, the
equal sign is used. The expression A = B means that A is allocated the value
of B. It is solved in the right-to-left fashion, which means the right operand
value is assigned to the left operand.
There are many operators which can be clubbed with assignment operators.
These are given in Figure 7.12:
Figure 7.12: Assignment operators
// Program 7.13 to illustrate assignment operators

#include <stdio.h>
void main()
{
    int a=5, b = 10, c=15, d=20;
    a = d;      // Assignment
    printf("a = %d\n", a);
    b += c;     // Add and assignment
    printf("b = %d\n", b);
    b -= c;     // Subtract and assignment
    printf("b = %d\n", b);
    b /= c;     // Divide and assignment
    printf("b = %d\n", b);
    b *= c;     // Multiply and assignment
    printf("b = %d\n", b);
    b %= c;     // Mode and assignment
    printf("b = %d\n", b);
    a <<= 2;    //a = a << 2;
    printf("a = %d\n", a);
    a >>= 2;     //a = a >> 2;
    printf("a = %d\n", a);
    a &= 2;       //a = a & 2;
    printf("a = %d\n", a);
    a ^= 2;      //a = a ^ 2;

    printf("a = %d\n", a);
    a|= 2;      //a = a | 2
    printf("a = %d\n", a);
}
Output:
a = 20
b = 25
b = 10
b = 0
b = 0
b = 0
a = 80
a = 20
a = 0
a = 2
a = 2
Conditional operator
It takes three operands. That is why it is known as the ternary operator. It
uses ? and : symbols. Its syntax is given as follows:
Condition1 ? Expression2 : Expression3
For example, consider the following statements:
int a=10, b=20, c=30, x;
x = (a < b) ? b : c;

If (a < b) is true? The value is b; otherwise, value c will be assigned to x.
// Program 7.14 for the conditional operator
#include <stdio.h>
void main()
{
    int a=5, b=10, c=15, x;
    x = (a < b)? b: c;    // conditional operator
    printf("The value of x=%d",x);
}
Output:
The value of x=10
Address operator
It uses an ampersand (&) symbol. It returns the address of the operand.
// Program 7.15 to print the address of a variable using the address 
operator
#include <stdio.h>
void main()
{
    int x=10;
    printf("The value of x=%d\n",x);
    printf("The address of x=%d",&x);  // address 
value may change from one computer to other
}
Output:

The value of x=10
The address of x=6422044
Precedence and associativity of operators in C
Precedence: The precedence of an operator specifies which operator will be
evaluated first and which one will be evaluated after it. In the expression 5 +
2 * 4, the * is evaluated first, and + is evaluated second because the *
operator has higher precedence than the + operator, so 2 * 4 is evaluated
first. Then the result is added to 5.
Associativity: Associativity refers to the direction in which operators are
evaluated when they have the same precedence. For example, in the
expression 5 - 2 + 3, the subtraction and addition operators have the same
precedence. As both have left-to-right associativity (see Figure 7.13), the 5 –
2 is evaluated first, and then the result is added to 3.
The precedence and associativity of C operators are given as follows, where
(L to R) stands for left-to-right and (R to L) stands for right-to-left, see
Figure 7.13:

Figure 7.13: Precedence and associativity of C operators
Let us look at some examples:
Examples 1: Evaluate X where X is an integer:
X = 10 + 20 * 2 / 1 
10 + 40 / 1
10 + 40
50
Example 2: Evaluate X:
X = (10 + 20) * 2 / 1 

(30) * 2
60
Example 3: Evaluate X:
X = 3 * 5 % (7 / 2) 
3 * 5 % (3)
15 % 3
0
Example 4: Evaluate X:
Let a = 3, b = 7
X = ++a * 5 % (b++ / 2) 
4 * 5 % (7 / 2) 
4 * 5 % (3)
20 % 3
2
Example 5: Evaluate X:
Let a = 3, b = 7, c = 4
X = a < b && a < c
1 && 1
1
Example 6: Evaluate X:
Let a = 3, b = 7, c = 4
X = a < b || a < c && ++a
1 || 1 && 4 
1 && 4

1
Example 7: Evaluate X:
Let a = 3, b = 7, c = 4
X = a +=b += c 
a = a + (b = b + c) note: a += b and  a = a + b is 
same
3 + (7 + 4)  
14
// Program 7.16 to solve the expressions
#include <stdio.h>
void main()
{
    int x = 0, a = 3, b = 7, c = 4;
    x=(10+20*2/1);
    printf("(10+20*2/1)=%d\n",x);
    x=(10 + 20)*2/1;
    printf("(10 + 20)*2/1=%d\n",x);
    x=3*5%(7/2);
    printf("3*5%(7/2)=%d\n",x);
    x=++a*5%(b++/2);
    printf("++a*5%(b++/2)=%d\n",x);
    a=3;
    x=a<b&&a<c;

    printf("a<b&&a<c=%d\n", x);
    x=a<b||a<c&&++a;
    printf("a<b||a<c&&++a=%d\n", x);
    a=3;
    b=7;
    c=4;
    x=a+=b+=c;
    printf("a+=b+=c=%d\n",x);
}
Output:
(10+20*2/1)=50
(10 + 20)*2/1=60
3*5(7/2)=0
++a*5(b++/2)=2
a<b&&a<c=1
a<b||a<c&&++a=1
a+=b+=c=14
Conclusion
Operators and expressions are fundamental concepts in programming
languages. Operators are symbols that indicate an operation to be performed
on one or more operands. Operators can be classified based on the number of
operands, such as unary, binary, and ternary operators. Operators can also be
classified based on the type of operation they perform, such as arithmetic
operators (perform basic arithmetic operations), increment and decrement
operators (increment or decrement the value of an operand), relational

operators (compare two operands), logical operators (perform logical
operations), bitwise (operate on individual bits of an operand), shift
operators (shift the bits of an operand), assignment operators (assign a value
to an operand), comma operators (separate multiple expressions), sizeof()
(return the size of an operand in bytes), conditional operators (evaluate a
condition and return one of two possible values), and address operators
(return the memory address of an operand). Understanding the operators’
different types and functionalities is crucial for writing efficient and effective
codes.
Points to remember
Expression is the combination of opcode (operator code) and operand.
Operators are utilized in carrying out operations on the operands. For
example: +, –, =, and so on are the operators.
Operands may be a variable or a constant on which the operation is
performed, such as A, B, 5, 8.3, and so on, are the operands.
To produce a new value, the unary operator only needs one operand.
For example, -a, a++, &a, ~a, and so on.
The binary operator creates a new value by combining the results of
two previous calculations, such as a+b, a*b, and so on.
To produce a new value, the ternary operator requires three operands.
Arithmetic operators perform arithmetic operations, addition,
modulus, multiplication, and so on.
The increment operator increases the value of the variable by one.
The decrement operator decreases the value of the variable by one.
In post-increment, the value is incremented after assigning the value to
the variable.
In pre-increment, the value is incremented by one before assigning the
value to the variable.
The relation between two operands can be determined by using
relation operators. It returns one if the relation is true; otherwise, it

returns zero.
The decision-making statement returns 1 if it is true; otherwise, it
returns zero.
The bitwise operator operates directly on bits and carries out the
operation in a bit-by-bit fashion.
The bitwise left shift operator is represented by << symbol. For
example, A<< 2. It shifts all the bits left by two positions and appends
two zeros at the right.
The bitwise right shift operator is represented by the >> symbol. For
example, A >> 2. It shifts all the bits right by two positions and
appends two zeros at the left.
A comma operator separates two or more similar things, such as
variable names and parameters, in a function call.
The sizeof() gives back the operand size in bytes.
An assignment operator allocates the value of one variable to another.
It is solved right to the left, which means the right value is assigned to
the left.
The address operator tells the address of the operand.
The operator’s precedence means which operator will be evaluated
first and which is next.
Associativity refers to the direction in which operators are evaluated
when they have the same precedence.
Important questions
1. What do you understand by an expression? Explain it by taking a
suitable example.
2. How would you classify the operator based on the number of
operands? Discuss in detail.
3. How would you classify the operator based on the operation it
performs?

4. What do you understand by the arithmetic operator? Discuss the
symbols used by the arithmetic operator with its description.
5. Differentiate between bitwise operators and logical operators by
taking suitable examples.
6. Explain the variants of increment and decrement operators.
7. What do you understand by the associativity and the precedence of an
operator?
8. How would you solve the operator having the same precedence?
9. Explain the bitwise NOT operator by taking a suitable example.
10. Does C follow the BODMAS rule? Justify your answer.
11. Explain the conditional operator by taking a suitable example.
12. Differentiate between = and == operators.
13. What are relational operators? Discuss in detail.
14. What are logical operators? Give the symbols used in it with their
description.
15. Discuss the use of a comma(,) as an operator and as a separator.

CHAPTER 8Decision-making Statements
Introduction
This chapter introduces decision-making statements and essential tools in
programming for making intelligent choices based on conditions. The
various types of decision-making statements will enable you to control
program flow effectively. The practice exercises given will reinforce your
understanding, empowering you to create responsive and dynamic
programs.
Structure
In this chapter, we will cover the following topics:
Decision-making statements
Types of decision-making statements
Program for practice on decision-making statements
Objectives
The chapter aims to teach decision-making statements, covering various
types, and providing practice programs to enhance your ability to control
program logic and handle diverse scenarios.
Decision-making statements
C program is executed line by line in a sequential manner; that is, the
second line is executed after the first line, the third line after the second
line, and so on. Sometimes, we need to skip some statements. For such
cases, we use decision-making statements. Figure 8.1 shows the flow chart
without conditional.
Figure 8.1: Flow chart of sequential execution of the program without the
conditional statement

Figure 8.2 shows the flow chart of a conditional statement:
Figure 8.2: Flow chart with the conditional statement
Types of decision-making statements
Decision-making statements are fundamental to controlling the flow of a
program based on specific conditions. There are primarily two types of
decision-making statements: conditional and unconditional. These
statements are explained as follows.
Conditional decision-making statements
They transfer the program’s control from one part to another part of your
program, depending upon the condition mentioned. It includes the
following statements:
if statement: It uses an if keyword and a conditional expression within
parenthesis. The if block (within braces) may contain one or many
statements. If we use one statement in the block, there is no need to
write braces. The following is the syntax of if:
if(expression)
{
Statements inside if block;
}
Statements after if block;
The statements within the if block will be executed if the expression
produces a true value. If the expression produces a false value, the
following statements the if block will be executed. Figure 8.3 shows the
flow chart of the if statement:

Figure 8.3: Flow chart of if statement
//Program 8.1 illustrates if statement
#include <stdio.h>
int main()
{
int a = 10;
int b = 20;
if (a > b)
{
printf("a > b\n");
}
printf("b > a\n");
return 0;
}
Output:
b > a
Note: The expression might be a condition, a general expression, or any
number. Except for zero, all other values are considered true. And zero is
considered false. For example, consider program 8.2.
//Program 8.2 illustration of if statement

#include <stdio.h>
void main()
{
if(5)
printf("SUNDAY\n");
if(1 + 2)
printf("MONDAY\n");
if(3.5)
printf("WEDNESDAY\n");
if(0)
printf("NO OUTPUT");
}
Output:
SUNDAY
MONDAY
WEDNESDAY
if-else statement: If the expression is true, the if block executes;
otherwise, the else block executes. The syntax of a simple if-else
statement is given as follows:
if(expression)
{

Statements inside if block;
}
else
{
Statements inside else block;
}
Statements outside if-else block;
Figure 8.4 shows the flow chart of the if-else statement:
Figure 8.4: Flow chart of if-else statement
//Program 8.3 illustrates the if-else statement
#include <stdio.h>
int main()
{
int a = 10;
int b = 20;
if (a > b)
printf("a > b\n");
else
printf("b > a\n");

return 0;
}
Output:
b > a
Nested if-else statement: When one or more if-else statements are
placed within another if block or else block, it becomes nested if-else.
The syntax of a nested if-else statement is given as follows:
if(expression_1)
{
if(expression_2)
{
Statements inside internal if block;
}
else
{
Statements inside internal else block;
}
}
else
{
Statements inside outer else block;

}
Statements outside nested if-else block;
For the preceding syntax, if the first condition (expression_1) is not
met, the program will execute the statements within the outer else
block. However, if the condition is true, the program will move on to
evaluate the next condition (expression_2). If expression_2 is true, the
program will execute the statements within the inner if block. If
expression_2 is false, the program will execute the statements within
the inner else block. A visual representation of this flow can be seen in
Figure 8.5:
Figure 8.5: Flow chart of nested if statement
// Program 8.4 illustrates nested if-else
#include <stdio.h>
int main()
{
int num1 = 10;
int num2 = 20;
if(num1 == 10)
{
printf("num1 is equal to 10\n");
if(num2 == 20)
printf("num2 is equal to 20\n");

else
printf("num2 is not equal to 20\n");
}
else
printf("num1 is not equal to 10\n");
return 0;
}
Output:
num1 is equal to 10
num2 is equal to 20
if-else-if ladder: It is used when choosing one from many alternatives.
The general form of the if-else-if ladder is as follows:
if(expression_1)
{
Statements within block 1;
}
else if(expression_2)
{
Statements within block 2;
}
else if(expression_N )

{
Statements within block N;
}
else
{
Statements within else block;
}
Statement after if-else-if
The if-else-if ladder evaluates the expressions from the top down,
starting with expression_1. If expression_1 is true, its corresponding
statement is executed. Otherwise, the next else-if condition is checked,
and the process continues until a true expression is found. If all
expressions are false, the else statement is executed. The flowcharts in
Figure 8.6 illustrate this process:
Figure 8.6: Flowcharts of the if-else-if ladder up to three levels
//Program 8.5 shows the use of the if-else-if ladder
#include <stdio.h>
void main()
{
int num;
printf("Enter a number:");

scanf("%d", &num);
if(num == 1)
printf("SUNDAY");
else if(num == 2)
printf("MONDAY");
else if(num == 3)
printf("TUESDAY");
else if(num == 4)
printf("WEDNESDAY");
else if(num == 5)
printf("THURSDAY");
else if(num == 6)
printf("FRIDAY");
else if(num == 7)
printf("SATURDAY");
else
printf("INVALID DAY");
}
Output:
Enter a number:4

WEDNESDAY
if-else-if ladders can quickly become complex and difficult to read
when dealing with many conditions. The code can become hard to
understand, maintain, and debug when the number of conditions
grows. To overcome the limitations of if-else-if ladders, we use the
switch statement.
switch statement: It is also used to choose one option from many
options, like in the if-else-if ladder. It uses two keywords: switch and
case. The syntax of the switch case statement is given as follows:
switch (expression)
{
case constant1:
statements of case_1
break;
case constant2:
statements of case_1
break;
.
.
.
case constantN:
statements of case_N
break;

default:
statements of case_N
}
Statements outside switch
The switch statement first evaluates an expression and returns a value.
This value is compared to each case’s values. If a match is found, the
corresponding block of statements is executed. If no match is found,
the default block is executed (if it is provided). The case labels must
end with a colon, and only integer and character constants are allowed
in the case. The float constants are not permitted. Refer to Figure 8.7
for the flow chart representation of the switch statement:
Figure 8.7: Flowcharts of the switch statement
//Program 8.6 shows the use of a switch
#include <stdio.h>
void main()
{
int a;
printf("Enter a number:\n");
scanf("%d", &a);
switch(a)
{
case 1:

printf("The day is Sunday");
break;
case 2:
printf("The day is Monday");
break;
case 3:
printf("The day is Tuesday");
break;
case 4:
printf("The day is Wednesday");
break;
case 5:
printf("The day is Thursday");
break;
case 6:
printf("The day is Friday");
break;
case 7:
printf("The day is Saturday");
break;

default:
printf("INVALID DAY");
break;
}
}
Output:
Enter a number:
5
The day is Thursday
The break is used to exit from the case block. If it is not used, all the
cases written after a matching case will be executed, known as the
fall-through effect. For example,
//Program 8.7 shows the fall-through effect in a switch
#include <stdio.h>
void main()
{
int num;
printf("Enter a number:\n");
scanf("%d", &num);
switch(num)
{

case 1:
printf("The no. is 1\n");
case 2:
printf("The no. is 2\n");
case 3:
printf("The no. is 3\n");
case 4:
printf("The no. is 4\n");
case 5:
printf("The no. is 5\n");
default:
printf("The no. is not matched\n");
}
}
Output:
Enter a number:
1
The no. is 1
The no. is 2
The no. is 3

The no. is 4
The no. is 5
The no. is not matched
Unconditional decision-making statements
They allow you to transfer the program’s control to another part of your
program without evaluating conditions. These statements are also known as
jumping statements. It includes the following statements:
break statement: The break statement transfers the program’s control
outside the block from where it was written. It uses the break
keyword. Typically, the purpose of the break is to transfer program
control outside of the loop in which it is being written. The following
syntax illustrates the working of it:
When the break statement is encountered, the statements written after
it will not be executed, the program’s control goes outside the block or
loop, and the statements after the loop block will be executed.
// Program 8.8 shows the use of break statement in for loop
#include <stdio.h>
int main()
{
int i;
for (i = 0; i < 100; i++)
{
printf("%d ", i);

if (i == 10)
break;
}
printf("\nThe value of i outside the loop block = %d\n", i);
return 0;
}
Output:
0 1 2 3 4 5 6 7 8 9 10
The value of i outside the loop block = 10
continue statement: It uses the continue keyword. It is opposite to the
break statement. Generally, it is used in a loop block. It transfers the
program’s control at the starting point of the loop from where it has
been written. Look at the following code for working on the continue
statement.
When the continue statement is encountered, the statements written
after it will not be executed, and the control goes at the starting point
of the block or loop.
//program 8.9 shows the continue statement for the loop
#include<stdio.h>
void main()
{
int i=1;

for(i=1;i<=5;i++)
{
if(i==3)
continue;
printf("%d \n",i);
}
}
Output:
1
2
4
5
goto statement: It allows the programmer to unconditionally jump to a
different part of the program, bypassing any intermediate code. It
transfers control to a label with the same function. Depending upon
the label, it can transfer the program’s control in the forward or
backward direction. The label is an identifier. It ends with a colon. It is
also used to come out from many nested blocks.
However, it is generally considered a bad practice and can make code
harder to read and debug, so it should be used sparingly. The syntax of
the goto statement is shown as follows:
//control is transferred in the forward direction
-------------------------

Statements before goto;
//control is transferred in the backward direction
//Program 8.10 shows the use of goto as a loop
#include <stdio.h>
int main()
{
int i = 1;
L1: //label
printf("%d ", i);
i++;
if (i <= 10)
goto L1;
return 0;
}
Output:
1 2 3 4 5 6 7 8 9 10
Roots of a quadratic equation
A quadratic equation is a second-degree polynomial equation in a single
variable, usually written in the standard form:

ax2 + bx + c = 0
where a, b, and c are real numbers and a!=0. To find the root, first, we have
to find the discriminant D.
D= b2 – 4ac
Based on the value of D, we have three cases:
1. The roots are real and different if the D is greater than 0.
2. If the D equals 0, the roots are real and equal.
3. The roots are complex and different if the D is less than 0.
1. If D > 0, then
Root 1 = -b + sqrt (D)/(2*a)
Root 2 = -b - sqrt(D)/(2*a)
2. Otherwise, if D = 0, then
Root1 = Root2 = -b/2a
3. Otherwise, if D < 0, then print roots are imaginary
realPart = -b / (2 * a);
imgPart = sqrt(fabs(D)) / (2 * a); //fabs is floating-point absolute
Root1= realPart + imgPart
Root2= realPart + imgPart
The following program finds the roots of a quadratic equation:
#include <stdio.h>
#include <math.h>
int main()

{
double a, b, c; // Declare variables for coefficients
double realPart, imgPart, root, root1, root2;
printf("Enter the coefficients (a, b, c): ");
scanf("%lf %lf %lf", &a, &b, &c);
// Calculate D
double D = b * b - 4 * a * c;
// Check the value of the D
if (D > 0)
{
// Two distinct real roots
root1 = (-b + sqrt(D)) / (2 * a);
root2 = (-b - sqrt(D)) / (2 * a);
printf("Roots are real and distinct: %.2f and %.2f\n", root1, root2);
}
else if (D == 0)
{
// One real repeated root
root = -b / (2 * a);
printf("Root is real and repeated: %.2f\n", root);

}
else
{
// Complex roots
realPart = -b / (2 * a);
imgPart = sqrt(fabs(D)) / (2 * a); //fabs is floating-point absolute
printf("Roots are complex conjugates: %f + %fi and %f - %fi\n", realPart,
imgPart, realPart, imgPart);
}
return 0;
}
Output:
Enter the coefficients (a, b, c): 2 2 1
Roots are complex conjugates: -0.500000 + 0.500000i and -0.500000 -
0.500000i
Solved programs for practice on decision-making
To solidify your understanding of decision-making statements, we will now
delve into practical exercises that demonstrate how these statements can be
applied in real-world scenarios. These exercises will sharpen your decision-
making skills, enabling you to craft more dynamic and responsive code.
//Program 8.11 to check whether the number is even or odd
#include<stdio.h>

int main()
{
int a,r;
printf("Enter any number to check even or odd: ");
scanf("%d",&a);
r=(a%2);
if(r==0)
printf("The entered number is even: %d",a);
else
printf("The entered number is odd");
return 0;
}
Output:
Enter any number to check even or odd: 54
The entered number is even: 54
// Program 8.12 to check greater of two numbers
#include<stdio.h>
int main()
{
int a,b;

printf("Enter the first number:");
scanf("%d",&a);
printf("\nEnter the second number:");
scanf("%d",&b);
if(a>b)
printf("\nThe greater number is:%d",a);
else
printf("\nThe greater number is:%d",b);
return 0;
}
Output:
Enter the first number:54
Enter the second number:52
The greater number is:54
// Program 8.13 to check whether a number is divisible by another number
or not
#include<stdio.h>
int main()
{
int a,b;
printf("Enter the first number: ");

scanf("%d",&a);
printf("Enter the second number: ");
scanf("%d",&b);
if(a%b==0)
printf("a is divisible by b");
else
printf("a is not divisible by b");
return 0;
}
Output:
Enter the first number: 10
Enter the second number: 2
a is divisible by b
// Program 8.14 to check the largest of three numbers
#include<stdio.h>
int main()
{
int a,b,c;
printf("Enter three numbers:");
scanf("%d %d %d",&a,&b,&c);

if(a>b && a>c)
printf(" a is greatest: %d",a);
else if(b>a && b>c)
printf("b is greatest: %d",b);
else
printf("c is greatest: %d",c);
return 0;
}
Output:
Enter three numbers:45
85
55
b is greatest: 85
 
//Program 8.15 to check whether a character is a vowel or not
#include<stdio.h>
#include<conio.h>
int main()
{
char ch;

printf("Enter any character: ");
scanf("%c",&ch);
if(ch=='a'|| ch=='e' || ch=='i' || ch=='o' || ch=='u'
|| ch=='A' ||ch=='E' ||ch=='I' ||ch=='O' ||ch=='U')
printf("\n %c is a vowel",ch);
else
printf("\n %c is a consonent",ch);
return 0;
}
Output:
Enter any character: A
A is a vowel
// Program 8.16 checks whether a character is a vowel or not using the
switch
#include<stdio.h>
int main()
{
char ch;
print("Enter any character: ");
scanf("%c",&ch);
switch(ch)

{
case 'a':
case 'A':
printf("\n %c is vowel",ch);
break;
case 'E':
case 'e':
printf("\n %c is vowel",ch);
break;
case 'I':
case 'i':
printf("\n %c is vowel",ch);
break;
case 'o':
case 'O':
printf("\n %c is vowel",ch);
break;
case 'U':
case 'u':
printf("\n %c is vowel",ch);

break;
default: printf("%c is not a vowel",ch);
}
return 0;
}
Output:
Enter any character: U
U is vowel
// program 8.17 whether the year is a leap year or not
#include<stdio.h>
int main()
{
int y;
printf("Enter the year: ");
if(y%4==0)
printf("The year is a leap year");
else
printf("The year is a non-leap year");
return 0;
}

Output:
Enter the year: 2004
The year is a leap year
// program 8.18 to check if the number is positive, negative or zero
#include<stdio.h>
int main()
{
int a;
printf("Enter any number: ");
scanf("%d",&a);
if(a==0)
printf("You have entered zero");
else if(a>0)
printf("You have entered a positive number");
else
printf("You have entered a negative number");
return 0;
}
Output:
Enter any number: -50

You have entered a negative number
// Program 8.19 to find roots of the quadratic equation
#include<stdio.h>
#include<math.h>
int main(){
float a,b,c;
float D,deno;
float root1,root2;
printf("Enter the value of a,b,c :");
scanf("%f%f%f",&a,&b,&c);
printf("The quadratic eq. is: %fx^2 + %fx + %fc = 0",a,b,c);
D=(b*b) - (4*a*c);
deno = 2*a;
if(D>0)
{
printf("\nREAL ROOTS");
root1= ((-b + sqrt(D))/deno);
root2= ((-b - sqrt(D))/deno);
printf("\nROOT1 = %f \t ROOT2 = %f",root1,root2);
}

else if(D==0)
{
printf("\nEQUAL ROOTS");
root1= -b/deno;
printf("\nROOT1 = %f \t ROOT2 = %f",root1,root1);
}
else
{
printf("\nIMAGINARY ROOTS");
}
return 0;
}
Output:
Enter the value of a,b,c :1
2
1
The quadratic eq. is: 1.000000x^2 + 2.000000x + 1.000000c = 0
EQUAL ROOTS
ROOT1 = -1.000000 ROOT2 = -1.000000
// Program 8.20 to check whether a person can vote or not

#include<stdio.h>
void main()
{
int age;
char ch;
printf("Enter 'Y' if Indian otherwise 'N': ");
scanf("%c",&ch);
printf("Enter your age: ");
scanf("%d",&age);
if (age>=18 && ch=='Y')
{
printf("You are eligible for voting");
}
else
{
printf("You are not eligible for voting");
}
}
Output:
Enter 'Y' if Indian otherwise 'N': Y

Enter your age: 24
You are eligible for voting
Conclusion
This chapter provides the opportunity for the students to write the decision-
making statements in their programs. In addition to this, it investigates the
types of statements used in decision-making, such as conditional and
unconditional statements. The conditional statements contain statements
such as if, if else, else if, and switch. In addition, statements such as
continue, break, and goto are included in the category of unconditional
statements.
The intricacies of for loops and the two forms of loops, known as while and
do-while, are presented in the upcoming chapter.
Points to remember
The decision-making statements are used to skip some code lines and
transfer the program control from one part of a program to another.
Depending upon the condition, conditional decision-making
statements transfer the program’s control to another part of your
program.
Unconditional decision-making statements allow you to transfer the
program’s control to another part of your program without evaluating
any conditions.
If the expression is true, the if block executes; otherwise, the else
block executes.
The if-else-if ladder is used when we have to choose one from many
alternatives.
The if-else-if ladders can quickly become complex and difficult to
read when dealing with many conditions. The code can become hard
to understand, maintain, and debug when the number of conditions
grows.
To overcome the limitations of if-else-if ladders, we use the switch
statement.

The switch statement chooses one option from many options by
matching the expression with different cases.
The break statement transfers the program’s control outside the block
from where it was written.
Loops use the continue statement. It transfers control at the loop’s
commencement.
The goto statement allows the programmer to unconditionally jump to
a different part of the program, bypassing any intermediate code.
Important questions
1. Why do we use decision-making statements in the program? Why is it
important?
2. Why do we use decision-making statements in programming, and how
do they differ from each other?
3. How does an if statement work in programming, and what is its
syntax?
4. When would you use an if-else statement instead of an if statement,
and how would you write one?
5. Where do we use switch statements? Explain it by giving its syntax.
6. Give the purpose of writing break and continue statements. Also, write
its main differences.
7. What is the fall-through effect in the switch statement? Explain by
giving a suitable example.
8. What is an if-else-if ladder, and how does it differ from other types of
decision-making statements?
9. What is the limitation of the if-else-if ladder? How would you
overcome it?
10. What is a goto statement, and why is it generally discouraged in
modern programming languages?

11. Can you give an example of a programming problem that could be
solved using a decision-making statement and explain how you would
use one to solve it?

CHAPTER 9Loop
Introduction
This chapter is dedicated to the fascinating world of loops in computer
programming. Loops are essential tools for automating repetitive tasks,
making our programs more efficient and powerful. In the following
sections, we will explore various types of loops, such as the for loop, while
loop, and do-while loop, each with its unique applications. We will also
delve into nested loops, uncover the mysteries of infinite loops, and provide
practical programs to reinforce your understanding.
Structure
In this chapter, we will be discussing:
Types of loop
for loop
while loop
do-while loop
Nested loop
The infinite loop
Programs on loops for practice
Objectives
The objective of this chapter is to provide a comprehensive understanding
of loop structures in computer programming. Readers will explore different
types of loops, including for, while, and do-while loops, grasp the concept
of nested loops, and learn how to prevent infinite loops. Practical programs
will be provided to enhance hands-on experience and proficiency in using
loops for various computational tasks.
Loop

If we want to print a name a hundred times, we have to write hundreds of
printf statements. The other solution is to place a single printf statement in
the loop, and the loop will do the rest. It repeats the statements until the
condition is true. Figure 9.1 shows the working of the loop.
Figure 9.1: Flow chart of loop statements
Types of loop
There are three types of loops in the C. They are as follows:
1. for
2. while
3. do-while
for loop
It will keep repeating a statement or set of statements written inside its
block until the given condition is true. It uses a for keyword. It is also
known as the determinate or definite loop because the programmer is fully
aware, in advance, of the exact number of times that the loop will be
repeated. Figure 9.2 shows its flow chart:
Figure 9.2: Flow chart of for loop
The syntax of the for loop is as follows:
for (initialization; condition; increment/decrement)
{
//Statements inside for loop block;

}
Statements after for loop
The following is a brief description:
The loop starts with the for keyword, followed by a set of parentheses
that contain three expressions separated by semicolons.
The first expression, initialization, is typically used to initialize a loop
control variable. It is executed only once at the beginning of the loop.
The second expression, condition, is a Boolean expression evaluated
at the beginning of each iteration. For a true condition, the loop
continues; otherwise, it will be terminated.
The third expression, increment/decrement, is executed at the end of
each iteration. This expression is usually used to update the loop
variable.
The code inside the curly braces (loop block) is executed till the
condition holds the true value. Writing the curly braces for one
statement is not necessary.
Once the loop has executed the code for the specified number of times
as given in the condition statement, it gets terminated.
After the loop’s termination, the statement after the loop block will be
executed.
// Program 9.1 prints Hello ten times using for loop
#include <stdio.h>
int main()
{
int i;
for (i=1;i<=10;i++)
{
printf("Hello ");

}
return 0;
}
Output:
Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello
In this example, the loop initializes the variable i to 1 and then checks the
condition that is i<=10. The statements in the loop block are run as long as
this condition is true. After each iteration, the loop variable i is incremented
by 1. The loop terminates once i is no longer less than or equal to 10.
Because the loop executes 10 times, the output Hello on the monitor screen
will be printed ten times in a row.
// Program 9.2 prints numbers from 1 to 10 using for loop
#include <stdio.h>
int main()
{
int i;
for (i = 1; i < 11; ++i)
printf("%d ", i);
}
Output:
1 2 3 4 5 6 7 8 9 10
while loop

It is also used to repeat a statement or set of statements written in the loop
block, that is, within curly braces (loop block). A while keyword is used to
write its code. The statement or the set of statements written inside a while
loop block repeats itself until the condition is false.
It is also called entry-controlled, top-checking, or pre-test loop because the
condition is placed and checked at the first line of the loop’s entry. If this
condition is false, the statement enclosed in the loop braces is never
executed. It is used when the number of iterations is not known in advance.
Figure 9.3 shows the flow chart of the while loop:
Figure 9.3: Flow chart of while loop.
Its syntax is:
initialization;
while(condition)
{
// Statement or set of statements inside while loop
increment/ decrement;
}
// Program 9.3 prints numbers from 1 to 10 using a while loop
#include <stdio.h>
int main()
{
int i = 1;

while (i <= 10)
{
printf("%d ", i);
++i;
}
return 0;
}
Output:
1 2 3 4 5 6 7 8 9 10
do-while loop
It is also used to repeat a statement or set of statements written in the loop
block within curly braces until the condition is false. The do and while
keywords are used to write its code.
It is also called an exit-controlled loop or bottom-checking loop because
the condition is placed and checked at the last line or at the exit of the loop.
Even if this condition is false, the statement enclosed in the do braces is
executed at least once.
After the closing braces of do, the condition is written in parentheses with a
while keyword and terminated by a semicolon, as shown in the following
syntax. Refer to Figure 9.4:
Figure 9.4: Flow chart of the do-while loop
Its syntax is

initialization;
do
{
//statement or set of statements inside do block;
increment/ decrement;
} while (condition);
// Program 9.4 prints numbers from 1 to 10 using a do-while loop
#include <stdio.h>
int main ()
{
int a = 1;
do
{
printf("%d ",a);
a = a + 1;
}while(a<=10 );
return 0;
}
Output:
1 2 3 4 5 6 7 8 9 10

Nested loop
C allows the user to put one loop inside another, known as the nesting of
the loop. Nested loops are often used to iterate over two-dimensional data
like a matrix. Figure 9.5 shows the flowchart of the nested loop:
Figure 9.5: Flowchart of the nested loop
The nested for-loop syntax is shown as follows:
for()
{
for()
{
Statements inside inner for loop;
}
Statements inside outer for loop;
}
The outer loop will be executed first of all, and then the inner loop will be
executed the desired number of times, as mentioned in the condition in the
inner loop.
The nesting of the while loop is shown as follows:
while()
{
while()

{
Statements inside inner while loop;
}
Statements inside outer while loop;
}
The nesting of the do-while loop is shown as follows:
do
{
Statements inside the outer do-while loop;
do
{
Statements inside the inner do-while loop;
}while();
}while();
The syntax for a nested for loop with a while loop is as follows:
for ()
{
while ()
{
Statements inside inner while loop;

}
Statements inside outer for loop
}
Let us consider the following code:
for (int i = 0; i < 3; i++)
{
for (int j = 0; j < 2; j++)
{
printf("%d, %d ", i, j);
}
}
The first time, i is set to 0 in the outer loop. The condition i<3 is checked,
which is a true condition. The control enters into the outer loop block.
Again, the internal for loop is initialized with j=0, and the condition is
checked for an internal loop that is j < 2. Again, it is a true condition, and
the loop enters the internal for loop. The statement inside the inner loop,
printf("%d,%d ", i, j);, will print 0,0 on the console. Then, the inner loop
increments j to 1 and checks if j is less than 2. Because j is less than 2, the
inner loop will execute again, printing 0,1 on the console.
After the inner loop finishes its second iteration, the outer loop will
continue executing.
The outer loop will then increment i to 1, and the inner loop will start
executing again. This time, the statement inside the inner loop will print 1,0
and 1,1 on the monitor screen. The same thing will happen when i is 2, and

the statement inside the inner loop will print 2,0 and 2,1 on the monitor
screen. The final output of the preceding code will be as follows:
0,0 0,1 1,0 1,1 2,0 2,1
// Program 9.5 illustrates the nested for loop.
#include <stdio.h>
void main()
{
int i,j;
for (int i = 0; i < 3; i++)
{
for (int j = 0; j < 2; j++)
{
printf("%d,%d ", i, j);
}
}
}
Output:
0,0 0,1 1,0 1,1 2,0 2,1
The infinite loop
A loop that never stops running is called an infinite loop. Its condition
always remains true. A program with an infinite loop may stop working,

crash, or use too much memory or CPU. Look at the following code for an
infinite while loop.
while (1)
{
// Statements that execute indefinitely
}
In this case, the condition for the while loop is always true (1 is always true
in C), so the loop will never stop. Refer to Figure 9.6:
Figure 9.6: Flowchart of infinite loop
To get out of an infinite loop, you can use the break statement and a
conditional statement that checks for a certain condition and exits the loop
when it is met. Consider the following codes:
while (1)
{
// statement that executes indefinitely
if (condition)
{
break; // exit the loop when the condition is met
}
}
// Program 9.6 shows the implementation of the infinite loop

#include <stdio.h>
int main()
{
int count = 0;
while (1)
{
printf("Count = %d\n", count);
count++;
}
return 0;
}
Output:
Infinite counting from zero
// Program 9.7 for breaking the infinite loop
#include <stdio.h>
int main()
{
int count = 0;
while (1)
{

printf("Count = %d\n", count);
count++;
if(count>1000)
break;
}
return 0;
}
Output:
The above will print the value of the count from 0 to 1000
Programs on loops for practice
// Program 9.8 for getting the table of a given number
#include <stdio.h>
int main()
{
int n,i;
printf("Enter any integer: ");
scanf("%d",&n);
for (i = 1; i <= 10; ++i)
{
printf("%d * %d = %d \n", n,i,n * i);

}
return 0;
}
Output:
Enter any integer: 5
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50
// Program 9.9 to check the greatest among ten given number
#include <stdio.h>
int main()
{
int i=1, large= -32768,num;

while(i<=10)
{
printf("Enter the %d number: ",i);
scanf("%d",&num);
large= num>large?num:large;
i++;
}
printf("The largest of the ten numbers entered is %d",large);
return 0;
}
Output:
Enter the 1 number: 42
Enter the 2 number: 52
Enter the 3 number: 62
Enter the 4 number: 85
Enter the 5 number: 75
Enter the 6 number: 95
Enter the 7 number: 61
Enter the 8 number: 53
Enter the 9 number: 94

Enter the 10 number: 81
The largest of the ten numbers entered is 95
// program 9.10 to draw the following pattern
****
****
****
****
#include <stdio.h>
int main()
{
int i,j;
for(i=1;i<=4;i++)
{
printf("\n");
for(j=1;j<=4;j++)
{
printf("*");
}
}
return 0;

}
// Program 9.11 to print the following pattern
1
12
123
1234
12345
#include <stdio.h>
int main()
{
int i,j;
for(i=1;i<=5;i++)
{
printf("\n");
for(j=1;j<=i;j++)
{
printf("%d",j);
}
}
return 0;

}
// Program 9.12 to print the following pattern
1
23
456
78910
#include <stdio.h>
int main()
{
int i,j,count=1;
for(i=1;i<=4;i++)
{
printf("\n");
for(j=1;j<=i;j++)
{
printf("%d",count++);
}
}
return 0;
}

//Program 9.13 to print the following pattern
ABCDEFG
ABCDEF
ABCDE
ABCD
ABC
AB
A
#include<stdio.h>
void main()
{
int i,j,c=64;
for(i=1;i<=7;i++)
{
printf("\n");
c=64;
for(j=7;j>=i;j--)
{
c++;
printf("%c",c);

}
}
}
// Program 9.14 to find whether a number is prime or not
#include <stdio.h>
int main()
{
int flag=0,i,num;
printf("\n enter any number: ");
scanf("%d",&num);
for(i=2;i<=num/2;i++)
{
if(num%i==0)
{
flag = 1;
break;
}
}
if (flag == 1)
printf("%d is a composite number",num);

else
printf("%d is a prime number",num);
return 0;
}
Output:
Enter any number:31
31 is a prime number
// Program 9.15 to find the factorial of a given number
#include<stdio.h>
int main()
{
int fact =1,num;
printf("Enter the number: ");
scanf("%d",&num);
if(num==0)
fact= 1;
else
{
for(int i=1;i<=num;i++)
fact = fact*i;

}
printf("Factorial of %d is: %d",num,fact);
return 0;
}
Output:
Enter the number: 5
Factorial of 5 is: 120
// Program 9.16 to find whether the given number is Armstrong or not
#include<stdio.h>
#include<math.h>
int main()
{
int num,digits=0,rem=0,sum=0,i,n,x;
printf("Enter any number: ");
scanf("%d",&num);
n=num;
x=num;
while(n>0)
{
digits=digits+1;

n=n/10;
}
for(i=1;i<=digits;i++)
{
rem=num%10;
sum=sum+pow(rem,digits);
num=num/10;
}
if(sum==x)
printf("The number is an Armstrong number");
else
printf("The number is not an Armstrong number");
return 0;
}
Output:
Enter any number: 371
The number is an Armstrong number
// Program 9.17 to sum the series 1/1 + 2/2^2 + 3/3^2 ......... n/n^2
#include<stdio.h>
#include<math.h>

int main()
{
int n;
float a,i,sum=0.0;
printf("Enter the value of n: ");
scanf("%d",&n);
for(i=1;i<=n;i++)
{
a=pow(i,i);
sum=sum + a/i;
}
printf("The sum of series the is = %f",sum);
return 0;
}
Output:
Enter the value of n: 6
The sum of the series is = 8477.000000
// Program 9.18 to sum the series 1/1 + 1/2 + ....... + 1/n
#include<stdio.h>
int main()

{
int n;
float total=0.0,c,i;
printf("Enter the value of n: ");
scanf("%d",&n);
for(i=1;i<=n;i++)
{
c=1/i;
total=total+c;
}
printf("The sum of the series is: %f",total);
return 0;
}
Output:
Enter the value of n: 10
The sum of the series is: 2.928968
// Program 9.19 for printing AP series
#include<stdio.h>
int main()
{

int a,n,d,i,x;
printf("Enter the first term of the series: ");
scanf("%d",&a);
printf("Enter the common difference of the series: ");
scanf("%d",&d);
printf("Enter the number of terms to be taken out: ");
scanf("%d",&n);
for(i=1;i<=n;i++)
{
printf("%d\t",a);
x=(d);
a=(a+x);
}
}
Output:
Enter the first term of the series: 1
Enter the common difference of the series: 7
Enter the number of terms to be taken out: 10
1 8 15 22 29 36 43 50 57 64
 

// Program 9.20 for printing GP series
#include<stdio.h>
int main()
{
int a,n,d,i,x;
printf("Enter the first term of the series: ");
scanf("%d",&a);
printf("Enter the common ratio of the series: ");
scanf("%d",&d);
printf("Enter the number of terms to be taken out: ");
scanf("%d",&n);
for(i=1;i<=n;i++)
{
printf("\t%d",a);
x=(d);
a=(a*d);
}
}
Output:
Enter the first term of the series: 1

Enter the common ratio of the series: 2
Enter the number of terms to be taken out: 5
1 2 4 8 16
Conclusion
This chapter explores the loop statements that are essential in
programming, allowing a block of code to be executed repeatedly based on
a certain condition or until a specific number of iterations are completed.
The three distinct loops are the for, while, and do-while. The for loop is
used when the total number of iterations is known in advance. In contrast,
the while loop is used in scenarios where the total number of iterations is
unknown. The do-while loop is similar to the while loop but executes the
block of code at least once before checking the condition, and the nested
loop is used when one loop is placed inside another loop. The choice of
loop statement depends on the specific problem and the programmer’s
preference. The next chapter will provide the details of the array, its types,
properties, and applications.
Points to remember
The loop executes a statement or combination of statements several
times until the specified condition is met.
The for loop is also called the determinate or definite loop because the
programmer knows, in advance, exactly how many times the loop will
repeat.
The while is also called entry controlled, top-checking, or pre-test loop
because the condition is placed and checked at the first line of the
loop’s entry.
The while loop should be used when the total number of iterations
cannot be known in advance.
Even if this condition is false, the statement enclosed in the do braces
is executed at least once in the do-while loop.
C allows the user to put one loop inside another, known as the nesting
of the loop.

An infinite loop in C is a loop that keeps executing indefinitely
without ever stopping.
Important questions
1. What are iterative statements, and why are they important in
programming?
2. Explain the working of a for loop by taking a suitable example.
3. What is the syntax for a while loop?
4. How do you use a do-while loop?
5. Can you give an example of a nested loop in C?
6. What is the purpose of loop control variables in C?
7. What is the key distinction between a while, a do-while, and a for
loop?
8. What do you understand about the entry-controlled and exit-controlled
loops? Explain by taking a suitable example.
9. How do you break out of a loop or skip certain iterations based on a
condition?
10. What is an infinite loop in C, and how do you avoid it?
11. Make an infinite loop using while, for, and do-while.
12. How can you use infinite loops in a controlled manner?
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com


CHAPTER 10Array
Introduction
This chapter is dedicated to the powerful and versatile concept of arrays in
computer programming. Arrays are essential data structures that efficiently
store and manipulate multiple values. In the following sections, we will
explore how to declare, initialize, and work with arrays, highlighting their
advantages and applications through practical programming examples. Let
us dive into the world of arrays.
Structure
In this chapter, we will be discussing:
Declaration of array
Initialization of array
Finding the address of the array element
Types of the array
Properties of array
Advantages of using the array
Programs for practice based on the array
Objectives
The objective of this chapter is to demystify the concept of arrays in
computer programming. Readers will learn how to declare and initialize
arrays, understand how to find the address of array elements, and explore
different types and properties of arrays. The chapter also highlights the
advantages of using arrays and provides practical programs to reinforce
comprehension and application of array-based solutions.
Array
It is the combination of the same data types stored at continuous memory
locations. It is made of primary data types such as int, float, and so on; that

is why it is known as a derived data type. An array of integer data is known
as an integer array; with the float data type, it becomes a float array.
For example, to store a student’s grades in five subjects, instead of taking
five different variables for each subject mark, we can use an array to put the
marks in a single unit at a series of memory locations. So, using an array,
we can store many values of the same type under one name.
Declaration of array
Declaring an array involves placing the data type, array name, and its size
inside a bracket, followed by a semicolon. Its general form is as follows:
data_type array_name[array_size];
Here,
array_size indicates the array size, which is the limit of values it may
hold.
array_name provides information regarding the name of the array.
data_type tells the data type of value that will be stored in the array,
such as integers, floating point numbers, and so on.
Let us see the example of declaring the array by the following statement:
int num[5];
It will hold five integer values at five continuous spaces in the memory.
Refer to the following Figure 10.1 for clarification:
Figure 10.1: Array of five elements in the memory
In the preceding figure:
The num is the array’s name, and its size remains fixed.
The address of the first member in the array is 1000, also known as the
base address.

The address of the last element in the array is 1016, and the array
length is five.
All the values in the array are of integer types.
The number in the square brackets is called indexes, indices, or subscripts.
C array indices start from 0. So, for an array having N elements, the indices
of the last element are N–1. In the preceding example, the first element will
be placed in num[0], called the lower bound; the second number will be
placed in num[1], and so on. The last element is stored in num[4], which is
known as the upper bound.
Initialization of array
The following three methods can generally initialize the array.
Method 1: Direct assignment of the element
In this method, the elements are stored directly using the index of the array.
See the following statements:
num[0]=30; //initialization of array[0]
num[1]=40;
num[2]=50;
num[3]=60;
num[4]=80;
By writing the preceding line of code, the array num can be imagined in
Figure 10.2:
Figure 10.2: Memory picture after initialization of array num[5]
Here,

The first position’s name is num[0] and holds a value of 30.
The last position’s name is num[4] and holds the value of 80.
The total space allocated by the array num is 20 bytes, as an integer
occupies four bytes of space in the memory (in a 32-bit compiler).
Accessing the elements of the array
The subscript accesses the element of the array. For illustration’s sake, let
us say we wish to access the first value of the preceding array; it is fetched
by num[0] and so on.
// Program 10.1 shows the declaration, initialization and accessing the array
#include<stdio.h>
int main()
{
int i=0;
int num[5]; //declaration of array
num[0]=30; //initialization of first element of array
num[1]=40;
num[2]=50;
num[3]=65;
num[4]=80;
printf("%d\n",num[0]);
printf("%d\n",num[1]);
printf("%d\n",num[2]);

printf("%d\n",num[3]);
printf("%d\n",num[4]);
return 0;
}
Output:
30
40
50
65
80
Method 2: Initialization of the array at a time
The array can also be filled during declaration by writing the following
general code:
data_type array_name[array_size]={list of element};
For instance,
int num [5]={30,40,50,60,80};
The previous statement will allocate five spaces in the memory, which is
shown in Figure 10.3:
Figure 10.3: Memory picture after initialization of array num[5]

The first element, num[0], is initialized by a value of 30, num[1] by 40, and
so on.
// Program 10.2 to enter and display the elements in the array.
#include<stdio.h>
int main()
{
int i=0;
int num [5]={30,40,50,60,80};
printf("%d\n",num[0]);
printf("%d\n",num[1]);
printf("%d\n",num[2]);
printf("%d\n",num[3]);
printf("%d\n",num[4]);
return 0;
}
Output:
30
40
50
60
80

An array can also be initialized without mentioning its size of it. For
example:
int num []={30,40,50,60,80};
At this point, the compiler allocates sufficient space to accommodate all
array elements. If the array has fewer elements than its size, the empty slots
will be filled with a garbage value. For example, look at the following
statement:
int num [5]={30,40,50};
Refer to Figure 10.4:
Figure 10.4: Initialization without mentioning the size
Method 3: Initialization of array using a loop
The array can also be initialized or filled using a loop. Generally, a for loop
and a scanf statement within it are used to fill the array element. Similarly,
putting a printf statement in the loop will print the array element. Examine
the following code:
// Inputting five values to the array
for (i=0; i<5; i++)
scanf("%d\n",&num[i]);
// Displaying five elements
for (i=0; i<5; i++)
printf("%d\n",num[i]);
// Program 10.3 to enter and display the elements in the array using for loop

#include<stdio.h>
int main()
{
int i,num[5];
printf("Enter the values in the array:");
for (i=0; i<5; i++)
scanf("\n%d",&num[i]);
printf("The values are:");
for (i=0; i<5; i++)
printf("\n%d",num[i]);
return 0;
}
Output:
Enter the values in the array:10
15
20
22
25
The values are:
10

15
20
22
25
Finding the address of the array element
As the array elements are stored in the consecutive position, their address
will also be in a sequential fashion. You may determine its addresses by
using the address operator. We can print the address of each element using
a for loop by starting from the first index to the last index. The following
code will output the addresses of the array’s entries:
// Program 10.4 prints the address of the array
#include<stdio.h>
int main()
{
int i=0;
int num[5]={30,40,50,60,70};
printf("The array elements are stored in the following address
sequentially:");
for(i=0;i<5;i++)
printf("\nAddress of %d element is %d ",i,&num[i]);}
return 0;
}

Output:
The array elements are stored on the following address sequentially:
Address of 0 element is 6422016
Address of 1 element is 6422020
Address of 2 element is 6422024
Address of 3 element is 6422028
Address of 4 element is 6422032
The integer takes four bytes (in a 32-bit compiler) for storage. In the
preceding array, we have taken five elements in the array. All the addresses
are continuous to each other and have a common difference of four.
The address of the kth element of the array can be determined by applying
the following formula:
Address of the kth element = base address + element size * index of the kth
element
The address of the 4th element from the preceding formula is calculated as
follows:
Address of the 4th element=6422016 + 4 * 4
=6422032
Types of the array
The array can be classified in the following two ways based on dimensions.
One or single-dimensional array
A single-dimensional array stores a row of values. It stores data in linear
forms, like a list. The 1D array uses only one index value. Till now, we

have used only a 1D array. Its declaration and initialization have been
discussed as follows:
The following line of code makes the declaration of the 1D array:
int num [5];
The following line of code does the initialization of the 1-D array.
int num[5]={30,40,50,60,80};
The preceding code will occupy the space in the memory, as shown in
Figure 10.5:
Figure 10.5: 1-D array num
Multi-dimensional array
It contains more than one dimension, such as two, three, and so on. It uses
more than one index. The most popular multi-dimensional array is 2D.
2D array
We use 2D arrays to create mathematical matrixes. It has two indices: one
for a row and the other for a column. Declaration and initialization of an
array a in 2D can be made by following the line of code:
int a[2][2] = {{10,20},
{30,40}};
Or
int a[2][2] = {{10,20},{30,40}};
The following line of code can also do initialization of the 2-D array:

a[0][0] = 10; // Initializing array
a[0][1] = 20;
a[1][0] = 30;
a[1][1] = 40;
The preceding code will create a 2D array in the memory, which can be
imagined in Figure 10.6:
Figure 10.6: 2D array
It can also be initialized with the help of a for loop containing a scanf
statement, as shown as follows:
for (i=0; i<3; i++)
{
for (j=0; j<2; j++)
scanf("%d\n",&num[i][j]);
}
The preceding code will input the data in a 3*2 matrix.
//Program 10.5 to print the elements of a 2D array
#include<stdio.h>
int main()
{
int a[2][2] = {{10,20},

{30,40}};
int i,j;
for (i=0;i<2;i++)
{
for (j=0;j<2;j++)
printf("Value of array [%d][%d] : %d\n",i,j,a[i][j]);
}
}
Output
Value of array [0][0] is 10
Value of array [0][1] is 20
Value of array [1][0] is 30
Value of array [1][1] is 40
3D array
A three-dimensional (3D) array is an array of arrays. It uses three indexes:
first for the number of layers, second for the rows, and third for the
columns. It represents the data in a cube-like structure. The following line
can declare it:
Data_type array_name[size1][size2][size3];
For instance, if we want to declare a 3D array with the dimensions 2*2*2,
we can use the following statement:
int a[2][2][2];

The preceding statement will create an array of two layers containing two
rows and two columns. The first layer will be accessed using index 0, and
the second layer will be accessed using index 1. The three indices access
each element in the array. For example, (0.1.0) will access the element from
the 0th layer, 1st row, and 0th column.
The following way can be used to insert the element. This code will create
two layers of 2*2 size:
int a[2][2][2]={{
{1,2},
{3,4}},
{
{5,6},
{7,8}}
};
Or
int a[2][2][2]={{{1,2},{3,4}},{{5,6},{7,8}}};
The preceding code creates a cube-like structure in the memory, shown in
Figures 10.7 and 10.8:
Figure 10.7: 3D array in memory with two layers
Similarly, we can increase the number of layers by increasing the value in
the array’s first index, as shown in the following code. We have created
three layers by writing the three in the array’s first index.
int a[3][2][2]={{

{1,2},
{3,4}},
{
{5,6},
{7,8}}
{
{9,10},
{11,12}}
};
For the visualization of the previous code, refer to Figure 10.8:
Figure 10.8: 3D array with three layers
// Program 10.6 to enter and print the elements of the 3D array
#include<stdio.h>
int main()
{
int a[2][2][2]={{
{1,2},
{3,4}},
{

{5,6},
{7,8}}
};
printf("The first element of layer 1= %d",a[0][0][0]);
printf("\nThe first element of layer 2= %d",a[1][0][0]);
return 0;
}
Output:
The first element of layer 1= 1
The first element of layer 2= 5
Properties of array
Some properties of the array are as follows:
Arrays are of fixed size, given at the time of their declaration. Once it
is created, its size cannot be changed.
Each array element has the same data type and takes up the same
amount of space in memory.
The array items are saved in the memory at sequential addresses.
With the help of the base address and the data element size, we can
access the array elements randomly.
C arrays are zero-indexed, meaning the array’s base address has a zero
index.
An array can be multi-dimensional, meaning it can have multiple
indexes.
The advantage of using an array
There are many advantages of using the array. Some are as follows:

Efficient and fast memory usage: The continuous memory allocation
allows fast and efficient memory access.
Ease of operations: Only a few lines of code are needed for array
operations such as sorting, searching, and so on.
Random access: It can be accessed randomly, meaning that the
elements can be accessed by supplying the address or index of any
element.
Code optimization: As the array elements are stored in continuous
memory places, fewer lines of code are needed to read and store the
data in the array.
Solved programs for practice based on the array
The following are some solved programs for practice based on the array:
// Program 10.7 to accept and display 10 numbers in 1-D array
#include<stdio.h>
int main()
{
int a[10];
for(int i=0;i<10;i++)
{
printf("Enter the number at %d position : ",i);
scanf("%d",&a[i]);
}
printf("\nThe values are:");
for(int i=0;i<10;i++)

{
printf("\nNumber at %d position is: %d",i,a[i]);
}
return 0;
}
//Output:
Enter the number at 0 position : 1
Enter the number at 1 position : 2
Enter the number at 2 position : 3
Enter the number at 3 position : 4
Enter the number at 4 position : 5
Enter the number at 5 position : 6
Enter the number at 6 position : 7
Enter the number at 7 position : 8
Enter the number at 8 position : 9
Enter the number at 9 position : 10
The values are:
Number at 0 position is: 1
Number at 1 position is: 2
Number at 2 position is: 3

Number at 3 position is: 4
Number at 4 position is: 5
Number at 5 position is: 6
Number at 6 position is: 7
Number at 7 position is: 8
Number at 8 position is: 9
Number at 9 position is: 10
// Program 10.8 to enter and display 2-D array.
#include<stdio.h>
int main()
{
int a[2][2];
for(int i=0;i<2;i++)
{
for(int j=0;j<2;j++)
{
printf("Enter the %d%d value: ",j,i);
scanf("%d",&a[i][j]);
}
}

printf("\nThe 2x2 matrix is:");
for(int x=0;x<2;x++)
{
printf("\n");
for(int y=0;y<2;y++)
{
printf("%d\t",a[x][y]);
}
}
return 0;
}
Output:
Enter the 00 value: 5
Enter the 10 value: 9
Enter the 01 value: 8
Enter the 11 value: 3
The 2x2 matrix is:
5 9
8 3
// Program 10.9 to add to 2x2 matrix.

#include<stdio.h>
int main()
{
int a[2][2],b[2][2],c[2][2];
printf("Enter the first 2x2 matrix: \n");
for(int i=0;i<2;i++)
{
for(int j=0;j<2;j++)
{
printf("Enter the %d%d value: ",i,j);
scanf("%d",&a[i][j]);
}
}
printf("\nThe second 2x2 matrix: \n");
for(int u=0;u<2;u++)
{
for(int v=0;v<2;v++)
{
printf("Enter the %d%d value: ",u,v);
scanf("%d",&b[u][v]);

}
}
printf("\nAddition of these two matrix is: \n");
for(int n=0;n<2;n++)
{
for(int m=0;m<2;m++)
{
c[n][m]=a[n][m]+b[n][m];
printf("%d\t",c[n][m]);
}
printf("\n");
}
return 0;
}
Output:
Enter the first 2x2 matrix:
Enter the 00 value: 1
Enter the 01 value: 2
Enter the 10 value: 3
Enter the 11 value: 4

The second 2x2 matrix:
Enter the 00 value: 4
Enter the 01 value: 3
Enter the 10 value: 2
Enter the 11 value: 1
Addition of these two matrix is:
5 5
5 5
// Program to 10.10 find the largest among the ten numbers.
#include<stdio.h>
int main()
{
int n,a[10];
for(int i=0;i<10;i++)
{
printf("Enter the number at %d position : ",i);
scanf("%d",&a[i]);
}
int j,large=0;
for(j=0;j<10;j++)

{
if(a[j]>large)
large=a[j];
}
printf("The largest among the given inputs is: %d",large);
return 0;
}
//Output:
Enter the number at 0 position : 10
Enter the number at 1 position : 52
Enter the number at 2 position : 63
Enter the number at 3 position : 84
Enter the number at 4 position : 95
Enter the number at 5 position : 62
Enter the number at 6 position : 75
Enter the number at 7 position : 62
Enter the number at 8 position : 30
Enter the number at 9 position : 75
The largest among the given inputs is: 95
 

// Program 10.11 to sum the ten elements of an array.
#include<stdio.h>
int main()
{
int a[10];
for(int i=0;i<10;i++)
{
printf("Enter the number at %d position : ",i);
scanf("%d",&a[i]);
}
int sum=0;
for(int j=0;j<10;j++)
{
sum=sum+a[j];
}
printf("The sum of all the inputs is: %d",sum);
return 0;
}
Output:
Enter the number at 0 position : 10

Enter the number at 1 position : 20
Enter the number at 2 position : 30
Enter the number at 3 position : 40
Enter the number at 4 position : 50
Enter the number at 5 position : 60
Enter the number at 6 position : 70
Enter the number at 7 position : 80
Enter the number at 8 position : 90
Enter the number at 9 position : 100
The sum of all the inputs is: 550
 
// Program 10.12 to search an element and its positions in the 1D array.
#include<stdio.h>
int main()
{
int a[10],x;
for(int j=0;j<10;j++)
{
printf("Enter the %dth number: ",j);
scanf("%d",&a[j]);

}
printf("Enter the element to check in array: ");
scanf("%d",&x);
for(int i=0;i<10;i++)
{
if(x==a[i])
printf("\nFound at %d position of the array",i);
}
return 0;
}
Output:
Enter the 0th number: 2
Enter the 1th number: 5
Enter the 2th number: 9
Enter the 3th number: 5
Enter the 4th number: 8
Enter the 5th number: 7
Enter the 6th number: 4
Enter the 7th number: 5
Enter the 8th number: 6

Enter the 9th number: 1
Enter the element to check in array: 5
Found at 1 position of the array
Found at 3 position of the array
Found at 7 position of the array
// Program 10.13 to find the transpose of a 2*2 matraix
#include<stdio.h>
int main()
{
int a[2][2],t[2][2];
for(int i=0;i<2;i++)
{
for(int j=0;j<2;j++)
{
printf("Enter the %d%d value: ",j,i);
scanf("%d",&a[i][j]);
}
}
printf("The 2x2 matrix is:");
for(int x=0;x<2;x++)

{
printf("\n");
for(int y=0;y<2;y++)
{
printf("%d\t",a[x][y]);
}
}
printf("\nThe transpose is:");
for(int x=0;x<2;x++)
{
printf("\n");
for(int y=0;y<2;y++)
{
t[x][y]=a[y][x];
printf("%d\t",t[x][y]);
}
}
return 0;
}
Output:

Enter the 00 value: 1
Enter the 10 value: 2
Enter the 01 value: 3
Enter the 11 value: 4
The 2x2 matrix is:
1 2
3 4
The transpose is:
1 3
2 4
// Program 10.14 to multiply two matrixes
#include<stdio.h>
int main()
{
int a[10][10],b[10][10],c[10][10],i,j,row1,col1,row2,col2,d;
printf("Enter the size of row and column of 1st matrix: ");
scanf("%d %d",&row1,&col1);
printf("Enter the size of row and column of 2nd matrix: ");
scanf("%d %d",&row2,&col2);
if(col1==row2)

{
for(i=0;i<row1;i++)
{
for(j=0;j<col1;j++)
{
printf("Enter the value of a[%d][%d] element in 1st matrix: ",i+1,j+1);
scanf("%d",&a[i][j]);
}
}
printf("\n");
for(i=0;i<row2;i++)
{
for(j=0;j<col2;j++)
{
printf("Enter the value of b[%d][%d] element in 2nd matrix: ",i+1,j+1);
scanf("%d",&b[i][j]);
}
}
for(i=0;i<row1;i++)
{

for(j=0;j<col2;j++)
{
c[i][j]=0;
for(d=0;d<col2;d++)
{
c[i][j]=c[i][j]+(a[i][d]*b[d][j]);
}
}
}
printf("The resultant matrix is:");
for(i=0;i<row1;i++)
{
printf("\n");
for(j=0;j<col2;j++)
{
printf("%d\t",c[i][j]);
}
}
}
else

{
printf("Multiplication of these matrix is not possible.");
}
}
Output:
Enter the size of row and column of 1st matrix: 3
3
Enter the size of row and column of 2nd matrix: 3
3
Enter the value of a[1][1] element in 1st matrix: 1
Enter the value of a[1][2] element in 1st matrix: 2
Enter the value of a[1][3] element in 1st matrix: 1
Enter the value of a[2][1] element in 1st matrix: 5
Enter the value of a[2][2] element in 1st matrix: 4
Enter the value of a[2][3] element in 1st matrix: 2
Enter the value of a[3][1] element in 1st matrix: 1
Enter the value of a[3][2] element in 1st matrix: 3
Enter the value of a[3][3] element in 1st matrix: 0
Enter the value of b[1][1] element in 2nd matrix: 0
Enter the value of b[1][2] element in 2nd matrix: 5

Enter the value of b[1][3] element in 2nd matrix: 0
Enter the value of b[2][1] element in 2nd matrix: 1
Enter the value of b[2][2] element in 2nd matrix: 2
Enter the value of b[2][3] element in 2nd matrix: 4
Enter the value of b[3][1] element in 2nd matrix: 0
Enter the value of b[3][2] element in 2nd matrix: 2
Enter the value of b[3][3] element in 2nd matrix: 1
The resultant matrix is:
2 11 9
4 37 18
3 11 12
// Program 10.15 to sort 1D array by bubble sorting
#include <stdio.h>
int main()
{
int a[100],n,i,j,temp;
printf("Enter the number of elements\n");
scanf("%d",&n);
printf("Enter %d elements\n", n);
for (i=0;i<n;i++)

scanf("%d",&a[i]);
for (i=0;i<n-1;i++)
{
for (j=0;j<n-i-1;j++)
{
if (a[j] > a[j+1])
{
temp=a[j];
a[j]=a[j+1];
a[j+1]=temp;
}
}
}
printf("The sorted 1D array in ascending order is:\n");
for (i=0;i<n;i++)
printf("%d\n", a[i]);
return 0;
}
Output:
Enter the number of elements

5
Enter 5 elements
52
63
42
84
65
The sorted 1D array in ascending order is:
42
52
63
65
84
//program 10.16 for the largest and smallest element in the array.
#include <stdio.h>
int main()
{
int a[100],n,i,j,temp;
printf("Enter number of elements:");
scanf("%d",&n);

printf("Enter %d elements:\n", n);
for (i=0;i<n;i++)
scanf("%d",&a[i]);
for (i=0;i<n-1;i++)
{
for (j=0;j<n-i-1;j++)
{
if (a[j] > a[j+1])
{
temp=a[j];
a[j]=a[j+1];
a[j+1]=temp;
}
}
}
printf("The largest element in the array is: %d",a[n-1]);
printf("\nThe second largest element in the array is: %d",a[n-2]);
printf("\nThe smallest element in the array is: %d",a[0]);
printf("\nThe second smallest element in the array is: %d",a[1]);
return 0;

}
Output:
Enter the number of elements: 10
Enter 10 elements:
20
62
54
63
85
95
74
84
65
55
The largest element in the array is: 95
The second largest element in the array is: 85
The smallest element in the array is: 20
The second smallest element in the array is: 54
Conclusion
This chapter details the array that can be used to store and manage several
values of the same data type under the umbrella of a single variable name.

It is possible to declare and initialize the array with a particular data type,
name, and size. Its elements can be accessed by using the memory
addresses operator. One-dimensional and multi-dimensional arrays are
available, and they can have features such as random access and continuous
memory allocation. An array allows the efficient storing and retrieval of
data, the simple manipulation, and the swift processing of data.
The upcoming chapter will discuss a special type of array known as the
string and the different types of operations on it.
Points to remember
The array is the combination of the same data types stored at
continuous memory locations.
An array of integer data is known as an integer array; with the float
data type, it becomes a float array.
The number in the square brackets in the array declaration is called
indexes, indices, or subscripts.
C array indices start from 0. So, for an array having N elements, the
indices of the last element are N-1.
In an array with N elements, the first index is 0, and the last is N-1.
The array’s first index is the lower bound, and the last element is the
upper bound.
The total space allocated by an array is equal to the size of the array
multiplied by the number of elements in the array.
The address of the kth element of the array can be determined by
applying the following formula.
Address of the kth element of the = base address + element size
(index of the kth element)
A single-dimensional array stores a row of values in linear forms, like
a list. The 1D array uses only one index value.
The multi-dimensional array contains more than one dimension, such
as two, three, and so on. It uses more than one index.
2D arrays are used to create mathematical matrixes. It has two indices:
one for a row and the other for a column.
A three-dimensional (3D) array is an array of arrays. It has three
indices.

Each array element has the same data type and takes up the same
amount of space in memory.
The array’s items are saved in the memory at sequential addresses.
C arrays are zero-indexed, meaning the array’s base address has a zero
index.
The continuous memory allocation allows fast and efficient memory
access.
Array elements can be accessed randomly, meaning that the elements
can be accessed by supplying the address or index of any element.
Since the array’s elements are stored in continuous memory places, a
few lines of code are needed to read and store the data in the array.
Important questions
1. What is meant by the term “array”?
2. How do you declare an array? Write an explanation of its syntax.
3. What steps are involved in the initialization of an array? Give an
illustration to explain your point.
4. How can individual elements in an array be accessed?
5. What are some ways to determine the length of an array?
6. Can you explain what a two-dimensional array is? How would you
declare it, and what would the initialization look like?
7. How would you access its elements if you had a two-dimensional
array?
8. Can you explain what a multi-dimensional array is? How would you
declare it, and what would the initialization look like?
9. How do you access individual elements within a multi-dimensional
array? Explain by using a relevant case.
10. How do you find the address of a particular element in an array?

11. Can you describe the benefits of utilizing an array?
12. Write and explain the array’s characteristics.
13. Write the difference between 2D and 3D arrays by analyzing their
respective syntaxes.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 11
String
Introduction
This chapter focuses on the basics of string. Throughout this chapter, we will
explore the declaration and initialization of strings, uncover the limitations
of the scanf() function, and learn about standard inbuilt string functions
such as strlen(), strcat(), and more. We will also tackle 2D strings, the
ctype.h header file, and provide practical programs to reinforce your string
manipulation skills.
Structure
In this chapter, we will be discussing the following topics:
Declaration and initialization of string
Limitation of scanf function
Standard inbuilt string functions
strlen()
strcat()
strcmp()
strcpy()
strrev()

strupr()
strlwr()
strncat()
strncpy()
strncmp()
2D string
The ctype.h header file
Program for practice on string
Objectives
The objective of this chapter is to equip readers with a comprehensive
understanding of string manipulation in programming. By exploring string
declaration, initialization, and limitations of input functions, readers will
gain proficiency in using essential inbuilt string functions. Additionally, we
will cover 2D strings, the ctype.h header file, and provide practical
programs to enhance skills in text processing.
String
A string is a collection of characters ending with a null ('\0') character. The
'\0' is a null character because its ASCII value is 0, whereas the ASCII
value of zero is 48. So, we must take one extra space in a string to store the
null character. Refer to Figure 11.1 for more clarification. For string, the %s
is used as a format specifier.
A string that is not ended by a null is not a string. It will be a simple
character array. So, a character array is just a collection of characters.
Declaration and initialization of string
The string is generally declared and initialized by the following three
methods.

Method 1: Character-by-character method
Look at the following line:
char A[]={'K', 'A', 'M', 'A', 'L', '\0'};
The preceding statement declares a string named A and initializes it with
'K', 'A', 'M', 'A', 'L', and the null character '\0'. The '\0' represents the
end of a string. The memory view of given string A is shown in Figure 11.1,
where 1000 to 1005 are the addresses and A[0] to A[5] are the string indices:
Figure 11.1: The memory view of the string
The total space occupied in the memory for the preceding code is six bytes
as the space occupied by a character is one byte:
// Program 11.1 Elaborates the first method 1 of initialization and 
declaration
#include<stdio.h>
void main()
{
  char A[]={'K', 'A', 'M', 'A', 'L', '\0'};
  printf("%s", A);
}
Output:
KAMAL
Method 2: Direct method

In this method, C inserts the null character automatically. So, you need not
write ‘\0’ at the end of the string. Consider the following statement:
char A[]={"KAMAL"};
// Program 11.2 Elaborates method 2 of initialization and 
declaration
#include<stdio.h>
void main()
{
    char A[] = "KAMAL";
    printf("%s", A);
}
Output:
KAMAL
Method 3: Initialization by index
In this approach, assigning values to the string elements is done one-by-one
by explicitly specifying the index of each element.
Look at the following line:
char A[6];
char A[0] = 'K';
char A[1] = 'A';
char A[2] = 'M';
char A[3] = 'A';
char A[4] = 'L';
char A[5] = '\0';

This code declares a string A, which can hold six characters, including null.
Then, it assigns the values 'K', 'A', 'M', 'A', 'L', and '\0' (null character)
to the elements of the string.
Limitation of scanf function
The scanf() function cannot deal with string because it does not accept the
string after white space. Look at the following example:
// Program 11.3 shows the limitation of the scanf() function
#include<stdio.h>
void main()
{
  char A[20];
  printf("Enter the string:\n");
  scanf("%s",A);
  printf("The string is:\n");
  printf("%s",A);
}
Output:
Enter the string:
Hello friends
The string is:
Hello
To overcome the limitations of the scanf() function, C has two more
functions, which are as follows:
1. gets(): It is used to get (enter) a string from the keyboard followed
by the Enter key.

2. puts(): It is used to put (display) a string on the monitor screen.
The stdio.h header file is where you will find the definitions for these
functions:
// Program 11.4 Elaborates using gets and puts functions
#include<stdio.h>
void main()
{
  char A[5];
  printf("Enter the string:\n");
  gets(A);
  printf("The string is:\n");
  puts(A);
}
Output:
Enter the string:
Hello Friends
The string is:
Hello Friends
Standard inbuilt string functions
There are large numbers of string functions. The string.h header file
contains the definitions for these functions. So, before using them, we must
include string.h in the program. The standard inbuilt functions and their
description are as follows:
strlen(): Measures the length of the string.

strcat(): Combines or concatenates two strings.
strcmp(): Compares two strings.
strcpy(): Copy one string into another.
strrev(): Reverses the string.
strupr(): Converts the string into the upper one.
strlwr(): Converts the string into the lowercase string.
strncat(): Appends a number of characters from one string to the end
of another.
strncpy(): Copies a specific number of characters from one string to
another.
strncmp(): Compares the first n characters of two strings.
Let us go over them now.
strlen()
It measures the length of the string, including white space. It returns the
length in an integer value. It does not count the null character. The syntax of
the strlen() function is as follows:
i=strlen(A);
Here, A is a string, and i is the integer value. Consider the following string
shown in Figure 11.2. The strlen(A) will return 10, which is the length of
the string.
Figure 11.2: The string A in memory
// Program 11.5 shows the working of the strlen() function
#include<stdio.h> 

#include<string.h> 
void main()
{
  char A[10];
  int i;
  printf("Enter the string:\n");
  gets(A);
  i=strlen(A);
  printf("The length of the string is %d", i);
}
Output:
Enter the string:
Kamaldeep
The length of the string is 9   
strcat()
It combines or concatenates two strings. It accepts two strings and
concatenates the second string to the first. So, the first-string size should be
able to hold the data of the second string. Let the strings A and B before
concatenation in Figure 11.3:

Figure 11.3: The strings A and B before concatenation
After concatenation by strcat(A, B), the string A will look like as Figure
11.4:
Figure 11.4: String A after concatenation
// Program 11.6 to concatenate two strings
#include<stdio.h>
#include<string.h>
void main()
{
  char A[20];
  char B[10];
  int i;
  printf("Enter the 1st string:\n");
  gets(A);
  printf("Enter the 2nd string:\n");
  gets(B);
  strcat(A,B); // Concatenates B in A
  printf("The concatenated string is :\n");
  puts(A);
}
Output:

Enter the 1st string:
Kamal
Enter the 2nd string:
deep
The concatenated string is:
Kamaldeep
strcmp()
It compares two strings. The function compares each corresponding
character in the two strings until a null character is reached or until a
difference is found. Look at the following statement:
i=strcmp(A,B);
Here, i is an integer, and A and B are two strings.
If both are equal, it returns zero, as shown in Figure 11.5.
If A is greater than B, strcmp returns a positive integer value, as shown
in Figure 11.6.
If B is greater, strcmp returns a negative integer value, as shown in Figure
11.7.
The comparison is performed by subtracting the ASCII value of the
corresponding characters in A and B. The comparison proceeds to the next
character if the resulting difference is zero. If the difference is non-zero, the
function returns the difference as its result. Some compilers return 1, 0, –1
for positive, equal and negative differences, respectively. Generally, So, it
returns the difference of the first non-matching character.
Refer to Figure 11.5:

Figure 11.5: No difference between ASCII values of the strings
Refer to Figure 11.6:
Figure 11.6: Positive differences between first non-matching characters
Refer to Figure 11.7:

Figure 11.7: Negative differences between first non-matching characters
// Program 11.7 compares two strings
#include<stdio.h>
#include<string.h>
void main()
{
  char A[10];
  char B[10];
  int i;
  printf("Enter the 1st string:\n");
  gets(A);
  printf("Enter the 2nd string:\n");
  gets(B);
  i=strcmp(A,B);
  if(i==0)

    printf("Strings are equal");
  else
    printf("Strings are not equal.\n");
  printf("The difference between the first non-
matching character is %d",i);
}
Output:
Enter the 1st string:
hello
Enter the 2nd string:
hillo
Strings are not equal.
The difference between the first non-matching 
character is -4
strcpy()
It is used to copy one string into another. It takes two arguments: one is the
source string, and the other is the destination string. If the destination string
is not empty, this function will overwrite the existing characters with the
source string. Suppose we have a string A in memory, as shown in Figure
11.8:
Figure 11.8: The string A in the memory

For example, consider the following:
strcpy(B,A); 
In the preceding line, string A is copied into string B. The size of string B
should be big enough to hold string A. Figure 11.9 shows string B after
copying string A into it.
Figure 11.9: The string B in the memory
// Program 11.8 Copies one string into another
#include<stdio.h>
#include<string.h>
void main()
{
  char A[10];
  char B[10];
  int i;
  printf("Enter the string in A:\n");
  gets(A);
  strcpy(B,A); // A is copied in B
  printf("The string B is:\n");
  puts(B);
}

Output:
Enter the string in A:
Kamaldeep
The string B is:
Kamaldeep
strrev()
It is used to reverse the string. It takes one string as input. Let A be the string
we want to reverse, as shown in Figure 11.10. We can apply the strrev()
function as follows:
strrev(A);
It will reverse string A and put the content again in string A, as shown in
Figure 11.10:
Figure 11.10: String A before applying the strrev() function
Refer to Figure 11.11:
Figure 11.11: String A after applying the strrev() function
// Program 11.9 Reverses a string 
#include<stdio.h>
#include<string.h>

void main()
{
  char A[10];
  printf("Enter the string in A:\n");
  gets(A);
  strrev(A); // A is copied in B
  printf("The reversed string is:\n");
  puts(A);
}
Output:
Enter the string in A:
Hello
The reversed string is:
olleH
strupr()
It converts the string into the uppercase. If the string is already in uppercase,
it keeps it unchanged. It takes one string as input. Consider string A in Figure
11.12. After applying strupr(A), the string A looks like as shown in Figure
11.13:
Figure 11.12: String A before applying the strupr() function

Refer to Figure 11.13:
Figure 11.13: String A after applying the strupr() function
// Program 11.10 changes the string into uppercase 
#include<stdio.h>
#include<string.h>
void main()
{
  char A[10];
  printf("Enter the string in A:\n");
  gets(A);
  strupr(A);
  printf("The upper-case string is:\n");
  puts(A);
}
Output:
Enter the string in A:
hello
The upper-case string is:
HELLO

strlwr()
It converts the string into lowercase. If the string is already in lowercase, it
keeps it unchanged. It takes one string as input. Let us have a string A, as
shown in Figure 11.14. After applying strlwr(A):
Figure 11.14: String A before applying the strlwr function
If we apply strlwr(A), the output is shown in Figure 11.15:
Figure 11.15: String A after applying the strlwr function
// Program 10.11 converts the string into lowercase
#include<stdio.h>
#include<string.h>
void main()
{
  char A[10];
  printf("Enter the string in A:\n");
  gets(A);
  strlwr(A);
  printf("The lower-case string is:\n");

  puts(A);
}
Output:
Enter the string in A:
HELLO
The lowercase string is:
hello
strncat()
It appends n number of characters from one string to the end of another. n is
an integer. Concatenation stops when n numbers of characters are
concatenated.
It can be written like strncat(A,B,n).
It takes three arguments (A,B,n), destination string, source string, and the
number of characters to be appended, respectively, as shown in Program
11.12:
// Program 11.12 concatenates two strings 
#include<stdio.h>
#include<string.h>
void main()
{
  char A[20];
  char B[10];
  int i;
  printf("Enter the 1st string:\n");
  gets(A);

  printf("Enter the 2nd string:\n");
  gets(B);
  strncat(A,B,3);        //Concatenate 3 characters 
of B at the end of A
  printf("The concatenated string is :\n");
  puts(A);
}
Output:
Enter the 1st string:
Hello
Enter the 2nd string:
Friends!
The concatenated string is:
HelloFri
strncpy()
It copies n numbers of characters from one string to another. It also takes
three arguments. For example, strncpy(B,A,3); will copy the first three
characters of A in B. Program 11.13 elaborates on the working if strncpy()
function:
// Program 11.13 copies three characters of one string into another 
string
#include<stdio.h>
#include<string.h>
void main()
{

  char A[10];
  char B[10];
  int i;
  printf("Enter the 1st string:\n");
  gets(A);
  strncpy(B,A,3); // Copy first 3 characters of A 
in B
  printf("The first three characters of B are:\n");
  puts(B);
}
Output:
Enter the 1st string:
HELLO
The first three characters of B are:
HEL
strncmp()
It compares the first n numbers of characters from one string to another. If
they are the same, it returns 0. It takes three arguments. Program 11.14
shows the working of the strncmp function:
// Program 11.14 compares the first two characters 
of two strings #include<stdio.h>
#include<string.h>
void main()
{

  char A[10];
  char B[10];
  int i;
  printf("Enter the 1st string:\n");
  gets(A);
  printf("Enter the 2nd string:\n");
  gets(B);
  i=strncmp(A,B, 2); // compare first 2 characters 
of A and B
  printf("The difference is %d :",i);
}
Output:
Enter the 1st string:
HAY
Enter the 2nd string:
HAPPY
The difference is: 0
2D string
We can also create a two-dimensional string like the 2D matrix. It uses two
indices, one for rows and one for columns. Look at the following code:
char name [4][6]={    "JOHN",
                      "SAM",
                      "KAMAL",

                      "DEEP"
                };
The preceding code declares a two-dimensional string named name with
dimensions four rows and six columns and initializes it with four strings, and
all are terminated by the null character as shown in Figure 11.16:
Figure 11.16: 2D string in the memory
// Program 11.15 demonstrate 2D string 
#include <stdio.h>
int main() {
   char names[4][10] = {
                        "JOHN",
                        "SAM",
                        "KAMAL",
                        "DEEP"
                        };
   for(int i = 0; i < 4; i++)
    {

      printf("Name %d: %s\n", i+1, names[i]);
    }
   return 0;
}
Output:
Name 1: JOHN
Name 2: SAM
Name 3: KAMAL
Name 4: DEEP
The ctype.h header file
This header file includes built-in functions to handle characters. These
functions take inputs of integer type. If we pass characters rather than an
integer, they are typecast into their corresponding ASCII integers, and the
resulting numbers are passed as arguments. Some of the functions are as
follows:
int isalpha() function is used to determine whether or not the
character being provided is alphabetic.
int isdigit() function is used to determine whether or not the given
character represents a decimal digit.
int isalnum() function determines whether the character provided is
alphanumeric.
int islower() function determines if the character being checked is a
lowercase letter.
int isupper() function determines if the character being checked is
an uppercase letter.
int isspace() function determines whether the supplied character is a
white space.

int iscatri() function determines whether the character supplied is a
control character.
int isprint() function determines whether the character supplied is
printable.
int ispunct() function is used to determine whether or not the
character being checked is a punctuation mark.
int tolower() converts all capital characters to lowercase letters.
int toupper() is used to change lowercase characters into uppercase
letters.
Note: All the functions, except tolower() and toupper(), take an integer
as an argument and return non-zero (true) if the argument satisfies the
condition and zero if not. If tolower() receives non-uppercase
alphabetic parameters. The function returns the supplied character.
The toupper() function returns the same letter if the arguments are not
a lowercase alphabet.
// Program 11.16 counts the number of alphabet and digits in a 
string
#include <stdio.h>
#include <ctype.h>
int main()
{
     char a[]= "Kamaldeep123";
     int alpha = 0, digit = 0;
     for (int i = 0; a[i] != '\0'; i++)
        {
        if (isalpha(a[i]))

            alpha++;
        if (isdigit(a[i]))
            digit++;
        }
    printf("The number of alphabets is:%d",alpha);
    printf("\nThe number of digits are :%d",digit);
}
Output:
The number of alphabets is: 9:
The number of digits is: 3
// Program 11.17 Illustrates of isalnum() function 
#include <stdio.h>
#include <ctype.h>
void main ()
{
   int a = 'd';
   int b = '2';
   int c = '$';
   if( isalnum(a) )
    printf("This is alphanumeric\n");
   else
    printf("This is not alphanumeric\n" );
    if( isalnum(b) )

    printf("This is alphanumeric\n" );
    else
    printf("This is not alphanumeric\n" );
    if( isalnum(c) )
    printf("This is alphanumeric\n" );
    else
    printf("This is not alphanumeric\n" );
}
Output:
This is alphanumeric
This is alphanumeric
This is not alphanumeric
// Program 11.18 Illustrates of tolower and toupper functions 
#include <stdio.h>
#include <ctype.h>
int main()
{
    char a,b,c;
    a = 'K';
    b = 'k';
    c = '+';
    printf("tolower(%c) = %c\n", a, tolower(a));
    printf("toupper(%c) = %c\n", b, toupper(b));

    printf("tolower(%c) = %c\n", c, tolower(c));
}
Output:
tolower(K) = k
toupper(k) = K
tolower(+) = +
Solved programs for practice based on string
The following are the solved programs for practice based on string:
// Program 11.19 finds the length of the string 
#include <stdio.h>
int main() {
    char str[100];
    int length = 0;
    printf("Enter a string: ");
    gets(str);
    // Counting the characters in the string
    while (str[length] != '\0') {
        length++;
    }
    printf("The length of the string is %d\n", 
length);
    return 0;
}

Output:
Enter a string: Hello World!
The length of the string is 12
// Program 11.20 copies one string to another without using an 
inbuilt function
#include <stdio.h>
#include <string.h>
int main() {
    char A[100], B[100];
    int i = 0;
    printf("Enter a string: ");
    gets(A);
    while (A[i] != '\0') 
    {
        B[i] = A[i];
        i++;
    }
    B[i] = '\0';
    printf("Source string: %s\n", A);
    printf("Destination string: %s\n", B);
    return 0;
}
Output:

Enter a string: Hello World!
Source string: Hello World!
Destination string: Hello World!
// Program 11.21 reverses a string without using an inbuilt function
#include <stdio.h>
#include <string.h>
int main()
{
    char string[100], temp;
    int i = 0, j = 0;
    printf("Enter a string: ");
    gets(string);
    j = strlen(string) - 1;
    while (i < j)
        {
        temp=string[i];
        string[i]=string[j];
        string[j]=temp;
        i++;
        j--;
        }
    printf("Reversed string: %s\n", string);
    return 0;

}
Output:
Enter a string: Hello KD!
Reversed string: !DK olleH
// Program 11.22 concatenates two strings without the strcat 
function
#include <stdio.h>
#include <string.h>
int main()
{
    char A[100], B[100];
    int i = 0, j = 0;
    printf("Enter the first string: ");
    scanf("%s", A);
    printf("Enter the second string: ");
    scanf("%s", B);
    i = strlen(A);
    while (B[j] != '\0')
    {
        A[i] = B[j];
        i++;
        j++;
    }

    A[i] = '\0';
    printf("Concatenated string: %s\n", A);
    return 0;
}
Output:
Enter the first string: HELLO
Enter the second string: UIET!
Concatenated string: HELLOUIET!
// Program 11.23 finds whether a string is a palindrome or not// 
Program 11. 23 finds whether a string is a palindrome or not
#include <stdio.h>
#include <string.h>
int main() 
{
    char string[100];
    int i = 0, j = 0, palindrome = 1;
    printf("Enter a string: ");
    scanf("%s", string);
    j = strlen(string) - 1;
    while (i < j) 
    {
        if (string[i] != string[j]) {
            palindrome = 0;

            break;
        }
        i++;
        j--;
    }
    if (palindrome) 
        
        printf("%s is a palindrome.\n", string);
    else 
        printf("%s is not a palindrome.\n", 
string);
    return 0;
}
Output:
Enter a string: ABCBA
ABCBA is a palindrome.
// Program 11.24 converts an uppercase string into lowercase
#include <stdio.h>
#include <ctype.h>
int main()
{
    char input_string[100], output_string[100];
    int i;

    printf("Enter a string: ");
    scanf("%s", input_string);
    for (i = 0; input_string[i] != '\0'; i++)
    {
        output_string[i] = 
tolower(input_string[i]);
    }
    output_string[i] = '\0';
    printf("The string in lowercase is: %s\n", 
output_string);
    return 0;
}
Output:
Enter a string: HELLO
The string in lowercase is: hello
// Program 11.25 to covert uppercase into lowercase without the 
tolower function
#include <stdio.h>
#include <string.h>
int main() {
    char string[100];
    int i;
    printf("Enter a string: ");
    gets(string);

    for (i = 0; string[i] != '\0'; i++)
    {
        if (string[i] >= 'A' && string[i] <= 'Z')
            string[i] = string[i] + 32;
    }
    printf("The converted string is: %s\n", 
string);
    return 0;
}
Output:
Enter a string: HELLO
The converted string is: hello
Conclusion
This chapter discusses the string, a sequence of characters ending with the
null character that can be declared using the char data type and initialized by
enclosing the string values in double quotes. The scanf() function can be
used to read strings, but it has some problems, such as not accepting the
string after a white space. This limitation is removed by the gets() function.
C also has several built-in string functions that can be used to manipulate
strings. These include strlen(), strcat(), strcmp(), strcpy(), strrev(),
strupr(), strlwr(), strncmp(), strncat(), and strncpy(). A 2D string is a
collection of strings.
The ctype.h header file incorporates several built-in function methods that
can be used for character handling and manipulation. These functions consist
of things such as isalpha(), isdigit(), and toupper(), among others. You
can use one of these approaches to identify whether or not a character is a
letter or a digit or to convert a character, accordingly, to all capital letters.

In the upcoming chapter, we will go through the process of writing
functions, why they are necessary, the different types of functions, and the
two different ways of calling functions: by value and by reference.
Additionally, the idea of storage classes will be discussed in detail.
Points to remember
A string is a collection of characters ending with a null character.
The '\0' is a null character because its ASCII value is 0.
A string that is not ended by a null is not a string. It will be a simple
character array.
The scanf function cannot deal with string because it does not accept
the string after white space.
gets() is used to get (enter) a string from the keyboard, followed by
the enter key.
puts() is used to put (display) a string on the monitor screen.
strlen() measures the length of the string, including white space.
strcmp() compares two strings.
strcpy() is used to copy one string into another.
strrev() is used to reverse the string. It takes one string as input.
strupr() converts the lowercase string into the uppercase.
strlwr() converts the uppercase string into lowercase.
strncat() appends n number of characters from one string to the end
of another.
strncpy() copies n numbers of characters from one string to another.
strncmp() compares the first n numbers of characters from one string
to another.
The 2D string has two indices, one for rows and one for columns. It is
a string of strings.

The ctype.h header file incorporates several built-in functions that can
be used for character handling and manipulation, such as isalpha(),
isdigit(), toupper(), and so on.
Important questions
1. What is a string? Write its declaration and initialization process using
a suitable example.
2. How is a string stored in the memory?
3. What is the difference between a character array and a string?
4. What is the null character, and what is the use of it?
5. How will you accept and print a string?
6. Explain various inbuilt functions in string.h.
7. Explain various inbuilt functions in ctype.h.
8. Explain the strcmp() function in detail.
9. How do you compare two strings in C?
10. How do you find the length of a string in C?
11. How would you copy one string into another without using strcpy
function?
12. What is the 2D string? How would you create it in C?
13. How do you read the input string from the user in C?
14. How do you concatenate two strings in C?
15. How do you convert a string to lowercase in C?
16. How do you extract a substring from a string in C?
17. How do you reverse a string in C?
18. What is the limitation of the scanf function when dealing with string?
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:

https://discord.bpbonline.com

CHAPTER 12
Function
Introduction
This chapter is dedicated to the fundamental building blocks of
programming, functions. In the world of coding, functions are essential tools
that enhance organization, reusability, and efficiency. Throughout this
chapter, we will explore the significance of functions, the various types of
functions, parameters, and calling conventions. We will also delve into the
art of passing arrays to functions and the role of storage classes in C.
Structure
In this chapter, we will be discussing the following topics:
Need of the function
Types of function
Types of parameters
Types of function based on function parameters
Calling convention
Passing an array to function
Storage classes in C

Objectives
The objective of this chapter is to provide a comprehensive understanding of
functions in programming. The reader will explore the importance and types
of functions, different parameter categories, and calling conventions. This
chapter also delves into passing arrays to functions and the significance of
storage classes in C, equipping readers with essential skills for effective
software development.
Function
A program can be divided into different independent sub-programs or
modules known as functions. The function performs a specific task, and its
working is completely insulated from other functions. It is also known as a
method, sub-routine, or procedure.
Figure 12.1 shows how the main() function calls another function fun().
Here, the main() function is the calling function, and fun() is the called
function.
Figure 12.1: The main() calling fun()
When one function calls another, control of the program is handed over to
the function being called. A called function is responsible for carrying out a

specific task, and once it reaches the closing brace, it passes control back to
the calling function.
Need of the function
The need of the functions in any program can be divided into the following:
Modularity: Functions divide a large problem into small sub-
problems. These small sub-problems can be easily solved using the
functions.
Reusability: Once a function has been written, it can be reused
repeatedly by simply calling it in a program. So, the function increases
reusability.
Easiness: Users can access built-in functions without bothering with
the internal coding of these functions.
Types of function
The user can create their own function or use the existing function. The
following are two types of functions.
Built-in or pre-defined functions: The header files in C provide
numerous built-in functions that can be called in the program on their
requirement. For example, printf(), scanf(), strcat(), and so on.
Before calling them in the program, we must include the header file
defining the function.
User-defined functions: It is created by the user as per his
requirement. The user decides the function’s name at his convenience.
The following parts are required to create these functions:
Function declaration or prototyping: Without actually providing
the function’s implementation, it tells the compiler about the
function’s return type, function’s name, and parameters list. It is
written at the top of the program after the header file. A semicolon
is mandatory at the end of the declaration. We can avoid the
function prototyping if the called function definition is given before

the calling function. The general form of function prototyping is as
follows:
return_type function_name(parameter list);
Function definition: It consists of a header and a function body. A
function header comprises a return type, name, and formal
parameters, if any, listed within parentheses. The function
prototype ends with a semicolon, although the function definition
header does not; this is the only difference between these two. The
following is the description of the parts of the function definition.
Return type: A function can send a value back to the calling
function, known as the return type. A function that returns
nothing uses void before its name.
Function name: It is the name of the function.
Parameters: It is a piece of information that travels from the
calling to the called function. It works as the input of a function.
If a function has no parameter, a void may be used in the
parenthesis, or the parenthesis may be left blank.
Function body: These are the statements within the braces and
tell what the function does.
Function definition allocates the space in the memory for the
function. The syntax is as follows:
return_type function_name(parameter list) // 
Function header
{
   // body of the function
}
Function calling: Whenever a function is needed in the main
program, it may be called. The function’s name and parameters are
required to call a function in a program. When a function is called,

the control is transferred from the calling to the called function. A
semicolon terminates a function call. Its syntax is as follows:
function_name(parameter list);
The preceding syntax can be written in actual code as follows:
sum(x, y);
The sum is the function’s name, and x and y are the integer
parameters in the parenthesis.
// Program 12.1 prints HELLO using the function
#include<stdio.h>
void print (void);     // Function declaration or 
prototype
void main()
{
   print( );        // Function calling
}
void print()        //Function definition
{
    printf("HELLO");
}
Output:
HELLO
// Program 12.2 Adds two numbers using functions when no argument 
passing
#include<stdio.h>

void sum(void);     // Function declaration or 
prototype
void main()
{
   sum();        // Function calling
}
void sum(void)         //Function definition
{
    int a,b,c;
    a=10;
    b=20;
    c=a+b;
    printf("Sum=%d",c);
}
Output:
Sum=30
// Program 12.3 Adds two numbers using functions with argument 
passing
#include<stdio.h>
void sum(int, int);     // Function declaration
void main()
{
    int a,b;
    a=10;

    b=20;
    sum(a,b);        // Function calling
}
void sum(int x, int y)     //Function definition
{
    int c;
    c = x+y;
    printf("Sum=%d",c);
}
Output:
Sum=30
// Program 12.4 Adds two nos. using argument passing, and returns 
result to main
#include<stdio.h>
int sum(int, int); // Function declaration
void main()
{
    int a,b, d;
    a=10;
    b=20;
    d = sum(a,b);// Function calling
    printf("Sum=%d",d);
}

int sum(int x, int y) //Function definition
{
    int c;
    c = x+y;
    return c;
}
Output:
Sum=30
Types of parameters
There are two types of parameters.
Actual parameters: These parameters are passed in a function call.
There is no need to specify the data type in actual parameters. They
are also known as an argument. Look at the following function call:
Sum = add(3,5);  
Here, 3 and 5 are the actual parameters.
Formal parameters: These are passed in the function definition. We
have to use the datatype with each formal parameter.
int Sum(int a, int b)  // function header
In this function definition, int a and 4 are the formal parameters.
Types of function based on function parameters
There are two different methods of calling the function based on parameters.
Let us go over them one by one.
Call by value

This technique will copy the values of the actual parameters into formal
parameters. Any alterations made within the formal parameter will not affect
the actual parameters. All the previous examples use the concept of call by
value. Refer to Figure 12.2:
Figure 12.2: Copy of a and b are passed in x and y
Program 12.5 shows the code for swapping two numbers using call by value:
// Program 12.5 Swaps two numbers using call by value. 
#include<stdio.h>
void swap(int x, int y);
void main()
{
    int a = 10, b = 20;
    swap(a,b);         // Actual parameters
    printf("The values in main function are a = %d 
b = %d\n",a,b);
    }
void swap(int x, int y) //copies of a and b in x 
and y 
{

    int t;
    t = x;
    x = y;
    y = t;
    printf ("The values after swapping x = %d y = 
%d\n", x, y);
}
Output:
The values after swapping  x = 20 y = 10
The values in the main function are a = 10 b = 20
Note: Any modification in x and y in the called function does not alter
the value of a and b in the calling function.
Introduction to pointers
A pointer, a special type of variable, is used to hold the address of the other
variable. For an integer variable a, the pointer p is declared as under.
int a=10;     
int *p;         // declaration a pointer p 
p = &a;          //Assigns the address of a to 
pointer p
The preceding lines of code create a scenario in the memory, shown in
Figure 12.3:

Figure 12.3: Pointer *p holding the address of variable a
Program 12.6 shows the code for printing a variable and its address using a
pointer:
// Program 12.6 Prints a variable, and its address using a pointer
#include <stdio.h>
void main()
{
   int a=10;
   int *p;
   p = &a;
   printf("value at a = %d\n", *p); // Pointer p 
accessing the value of a
   printf("Address of a = %d\n", &a);
   printf("Value of a = %d\n", a);
}
Output:
value at a = 10
Address of a = 6422036
Value of a = 10

Call by reference
In this method, the addresses of the variables are passed in actual
parameters. Pointers are used in formal parameters to hold the address of
actual parameters. The addresses are used to access the actual parameters
inside the function definition. It indicates that modifications made to the
formal parameter affect the actual parameters. So, the operations performed
on formal parameters will appear on actual parameters. The concept of call
by reference is shown in Figure 12.4:
Figure 12.4: Addresses of a and b are passed in *x and *y
Program 12.7 shows the code for swapping two numbers using call by
reference:
// Program 12.7 Swaps of two numbers using call by reference
#include<stdio.h>
void swap(int*, int*);
void main()
{
    int a = 10, b = 20;
    swap(&a, &b); // Addresses are being passed
    printf("The values of a and b in the main are: 
%d, %d\n", a, b);

}
void swap(int *x, int *y)
{
    int t;
     t = *x;
    *x = *y;
    *y = t;
    printf("Values after swapping:%d, %d\n",*x,*y);
}
Output:
Values after swapping: 20. 10
The values of a and b in the main are: 20, 10
Calling convention
The calling convention tells the order in which the parameters are passed to
the function and in which the function considers these parameters. Function
in C allows the right-to-left calling convention. Consider the following
statements:
int a=10;
printf("%d %d %d %d",a,--a,a++,--a);
It seems the preceding line will generate the output 10 9 9 9; Surprisingly, it
produces 9 9 9 9.
As we know, in a function, values are solved in the right to left order, which
means expression --a (pre-decrement) is solved first, generating a value 9.
Similarly, following the same order, the expression a++ prints the value 9.
This value is incremented by one as it is a post-increment operator. Now, the

value of “a” in the memory is 10. The 10 is decremented by one by --a, and
then 9 is printed. Finally, the 9 is printed as it is. So the output is 9 9 9 9.
Passing arrays to functions
By default, arrays are passed in the functions using the call-by-reference
mode. It means the address of the array (base address) is passed in the
calling function. Any modifications to the array within the called function
will also affect the original array in calling the function.
The following are two common approaches:
Passing an array as a pointer: This method passes the array’s name
into the actual parameter, which works as the array’s base address. The
pointer is used in formal parameters to hold the array’s base address,
passed in the actual parameter:
// Program 12.8 prints an array using passing an array using a 
pointer
#include <stdio.h>
void a(int *p, int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d ", p[i]);
    }
    printf("\n");
}
int main()
{

    int A[] = {1, 2, 3, 4, 5};
    int size = sizeof(A) / sizeof(A[0]);
    a(A, size);
    return 0;
}
Output:
1 2 3 4 5
The array A’s base address and size are passed to the print function in
the previous program. The array is accessed inside the function using
pointer p[i]. The statement print(A, size) is equivalent to
print(&A[0], size).
Passing an array with an explicit size: The array’s name is passed in
the actual parameter. In formal parameters, the array’s name with its
data type and a [] is passed as an argument to pass an entire array to a
function. The [] indicates the dimension of the array; that is, if a
single [] is used, it means a one-dimensional array is being passed. If
two [][] are used, then a two-dimensional array is being passed, and
so on. When a 2D array is passed in the function, the column size must
be given. It is because C requires the size of the column to be known
at compile time to calculate the correct memory addresses for the
elements of the array.
// Program 12.9 shows passing an array with an explicit size
#include <stdio.h>
void print(int a[] , int size)
{
    for (int i = 0; i < size; i++)
    {

        printf("%d ", a[i]);
    }
    printf("\n");
}
int main()
{
    int A[] = {1, 2, 3, 4, 5};
    int size = sizeof(A) / sizeof(A[0]);
    print(A, size);
    return 0;
} 
Output:
1 2 3 4 5
In the preceding program, we pass the array A directly to the print
function. Inside the function, the array is treated as if it were declared
as int a[], and again, we can access its elements using a[i].
Note: The function does not receive a copy of the entire array but a
pointer to its beginning address. The following programs also focus on
1D and a 2D array passing to function.
Program 12.19 shows the code calculates the sum of A elements by passing
it to a function:
// Program 12.10 calculates the sum of A elements by passing it to a 
function
#include <stdio.h>

int sum(int A[]);
int main()
{
    int result, A [] = {10,20,30,40,50};
    result = sum(A);     // passing a 1D array A in 
function sum
    printf("Result = %d", result);
    return 0;
}
int sum(int A[])
{
    int total = 0;
    for (int i = 0; i < 5; i++)
    total = total + A [i];
    return total;
}
Output:
Result = 150
// Program 12.11 passes a two-dimensional array in a function
#include <stdio.h>
void display(int A[][2]);
int main()
{

    int A[2][2],i,j;
    printf("Enter four elements:\n");
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 2; j++)
        {
            scanf("%d", &A[i][j]);
        }
    }
    display(A);         // passing a 2D array A in 
function sum
    return 0;
}
void display(int A[][2])
{
    int i,j;
    printf("Displaying\n");
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 2; j++)
        {
           printf("%d\t", A[i][j]);
        }

         printf("\n");
    }
}
Output:
Enter four elements:
1
2
3
4
Displaying
1    2
3    4
Storage classes in C
It determines where the variable is stored, how long it will exist in the
memory, where the value will be available in the program, and its initial
value.
When we declare a variable, that variable is assigned a storage class, which
determines the following characteristics of the variable.
Memory location: It tells about the variable’s place of storage, such
as RAM or CPU registers.
Default value: It tells about the initial value of the variable if it is not
initialized.
Lifetime/existence: It tells how long that variable will exist in
memory.
Scope/visibility: It specifies where the variable’s value can be
accessed in the program. For example, within a block where it has

been defined, the entire program, and so on.
The types of storage classes are as follows:
Automatic: It uses auto keywords in the declaration of the variable.
By default, every local variable is automatic in C. It can be declared as
follows:
auto int a;
The preceding line is the same as int a. The automatic variable has
the following characteristics:
Memory: It resides in the RAM.
Default value: The variable is initialized by a random value, that
is, garbage value.
Lifetime: When you leave the block where an automatic variable
was created, the memory given to it is freed up.
Scope: The scope is limited to the block where they are defined.
Program 12.12 shows an auto variable code:
// Program 12.12 shows an auto variable
#include <stdio.h>
void main()
{
    auto int a;
    printf("%d",a);
}
Output:
Any garbage values
Static: It uses static keywords. It is declared as follows:

static int a;
The static variable has the following characteristics:
Memory: It resides in the RAM.
Default value: It initializes itself by zero.
Lifetime: It keeps its value until the end of the main program, and
it also holds its value between multiple function calls.
Scope: Only the function or the block in which the variables are
defined can view the values of those variables.
Program 12.13 shows a static variable code:
// Program 12.13 shows a static variable
#include <stdio.h>
void main()
{
    static int a;
    printf("%d",a);
}
Output:
0
Register: It uses the register keyword. It holds memory in CPU
registers. So, their access time is faster than the automatic variables.
We can declare very few register variables as the CPU register size is
small. For example, it is declared like the following:
register int a;
The register variable has the following characteristics:
Memory: It resides in the CPU register.

Default value: Any random value.
Lifetime: Upon leaving the block, any memory allocated to
register variables is released for use by other program parts.
Scope: The scope is limited to the block where they are defined.
Program 12.14 shows an register variable code:
// Program 12.14 shows a register variable
#include <stdio.h>
void main()
{
    register int a;
    printf("%d",a);
}
Output:
Any garbage values
External or global: It uses the extern keyword. These variables are
defined outside the function. For example:
extern int a;
It is the declaration of extern variable a. It means a has been defined
somewhere else in another file. The external variable has the
following characteristics:
Memory: It resides in the RAM.
Default value: It is initialized to zero by default.
Lifetime: It exists throughout the execution of the program.
Scope: They are available throughout every part of the program,
making their availability global.

Program 12.15 shows an extern variable code:
// Program 12.15 shows an extern variable
//FILE1.C
#include <stdio.h>
#include"FILE2.c"
extern int a;
int main()
{
    printf("Value of a in first file = %d",a);
    return 0;
}
Output:
Value of a in first file = 1020
//FILE2.C
int a = 1020;
In preceding code, two C files have been created, which are FILE1.C and
FILE2.C, respectively. FILE1.C declared an external variable by extern int a
and prints it. The value of a is given in another file that is FILE2.C.
Solved programs for practice based on function
The following are the solved programs for practice based on function:
// Program 12.16 adds two numbers using function
#include<stdio.h>
#include<conio.h>

int sum(int a,int b);
int main()
{
    int num1,num2,total=0;
    printf("Enter the numbers to be added: ");
    scanf("%d%d",&num1,&num2);
    total=sum(num1,num2);
    printf("Total = %d",total);
    return 0;
}
int sum(int a,int b)
{
    int result;
    result = (a+b);
    return result;
}
Output:
Enter the numbers to be added: 45
55
Total = 100
// Program 12.17 to find the biggest of three integers using 
function
#include<stdio.h>

int greater(int a,int b,int c);
int main()
{
    int num1,num2,num3,large;
    printf("Enter the numbers: ");
    scanf("%d%d%d",&num1,&num2,&num3);
    large=greater(num1,num2,num3);
    printf("Largest number=%d",large);
    return 0;
}
int greater(int a,int b,int c)
{
    if(a>b&&a>c)
    return a;
    if(b>a&&b>c)
    return b;
    else
    return c;
}
Output:
Enter the numbers: 85
44
62

Largest number=85
// Program 12.18 finds the area of a circle.
#include<stdio.h>
float area(void);
int main()
{
  float a;
  a=area();
  printf("Area of the circle =%f",a);
  return 0;
}
float area()
{
  float radius;
  printf("Enter the radius of the circle: ");
  scanf("%f",&radius);
  return (3.14*radius*radius);
}
Output:
Enter the radius of the circle: 5
Area of the circle =78.500000
// Program 12.19 prints the table of a given number using function
#include <stdio.h>

int table(void);
int main()
{
    table();
}
int table()
{
  int n, i;
  printf("Enter any integer: ");
  scanf("%d",&n);
  for (i = 1; i <= 10; ++i)
  {
    printf("%d * %d = %d \n", n,i,n * i);
  }
  return 0;
}
Output:
Enter any integer: 2
2 * 1 = 2 
2 * 2 = 4 
2 * 3 = 6 
2 * 4 = 8 
2 * 5 = 10 

2 * 6 = 12 
2 * 7 = 14 
2 * 8 = 16 
2 * 9 = 18 
2 * 10 = 20
// Program 12.20 sums the digits of a given number.
#include<stdio.h>
int sum(int num);
int main()
{
    int num,b;
    printf("Enter any number: ");
    scanf("%d",&num);
    b=sum(num);
    printf("The sum of digits of the number is 
%d",b);
}
int sum(int num)
{
    int a,sum=0;
    while(num!=0)
    {
        a=num%10;

        sum=sum+a;
        num=num/10;
    }
    return sum;
}
Output:
Enter any number: 521
The sum of the digits of the number is 8
// Program 12.21 prints the Fibonacci series using function.
#include<stdio.h>
 int fibonacci();
void main()
{
  fibonacci();
} 
int fibonacci()
{
    int t1=0,t2=1,n,i,nxt_term=0,a;
    printf("Enter the value of n to get the 
Fibonacci series: ");
    scanf("%d",&n);
    printf("The series up to %d is: ",n);
    if(n==0)

      printf("Enter the number greater than zero");
    else if(n==1)
    {
     a=0;
     printf("%d",a); 
    }
    else
    {
      for(i=0;i<n;i++)
       {
       printf("%d\t",t1);
       nxt_term=t1+t2;
       t1=t2;
       t2=nxt_term;
       }
    }
    return 0;
}
Output:
Enter the value of n to get the Fibonacci series: 
10
The series up to 10 is: 0       1       1       2    
3       5       8       13      21      34

// Program 12.22 prints the largest among ten numbers by passing the 
array in the function.
#include<stdio.h>
int large(int arr[]);
int main()
{
    int arr[10],i,largest;
    for(i=0;i<10;i++)
    {
        printf("Enter the %d value in the array: 
",i+1);
        scanf("%d",&arr[i]);
    }
    largest=large(arr);
    printf("The largest number in the array is: 
%d",largest);
}
int large(int arr[])
{
    int i, j, temp;
    for (i=0;i<10-1;i++)
  {
    for (j=0;j<10-i-1;j++)
    {

      if (arr[j] > arr[j+1]) 
      {
        temp=arr[j];
        arr[j]=arr[j+1];
        arr[j+1]=temp;
      }
    }
  }
  return arr[10-1];
}
Output:
Enter the 1 value in the array: 10
Enter the 2 value in the array: 20
Enter the 3 value in the array: 30
Enter the 4 value in the array: 440
Enter the 5 value in the array: 50
Enter the 6 value in the array: 60
Enter the 7 value in the array: 0
Enter the 8 value in the array: 80
Enter the 9 value in the array: 90
Enter the 10 value in the array: 100
The largest number in the array is: 440
// Program 12.23 merges two arrays using a function.

#include<stdio.h>
void read_arr1(int arr1[],int n);
void read_arr2(int arr2[],int m);
int merged_arr3(int arr3[],int n,int m,int 
arr1[],int arr2[]);
int main()
{
    int n,m,arr3[4],c,i,arr1[100],arr2[100];
    printf("Enter the size of the first array: ");
    scanf("%d",&n);
    read_arr1(arr1,n);
    printf("\nEnter the size of the second array: 
");
    scanf("%d",&m);
    read_arr2(arr2,m);
    merged_arr3(arr3,n,m,arr1,arr2);
    return 0;
}
void read_arr1(int arr1[],int n)
{
    int i;
    for(i=0;i<n;i++)
    {

        printf("Enter the %d value in 1st array: 
",i+1);
        scanf("%d",&arr1[i]);
    }
}
void read_arr2(int arr2[],int m)
{
   int i;
    for(i=0;i<m;i++)
    {
        printf("Enter the %d value in 2nd array: 
",i+1);
        scanf("%d",&arr2[i]);
    } 
}
int merged_arr3(int arr3[],int n,int m,int 
arr1[],int arr2[])
{
    int i,j=0,c=n+m;
    for(i=0;i<n;i++)
    {
        arr3[i]=arr1[i];
        j++;
    }

    for(i=0;i<m;i++)
    {
        arr3[j]=arr2[i];
        j++;
    } 
    printf("The meged array is:: ");
    for(i=0;i<c;i++)
    {
    printf("\n");
    printf("%d",arr3[i]);  
    }
}
Output:
Enter the size of the first array: 5
Enter the 1 value in 1st array: 1
Enter the 2 value in 1st array: 2
Enter the 3 value in 1st array: 3
Enter the 4 value in 1st array: 4
Enter the 5 value in 1st array: 5
Enter the size of the second array: 5
Enter the 1 value in 2nd array: 6
Enter the 2 value in 2nd array: 7

Enter the 3 value in 2nd array: 8
Enter the 4 value in 2nd array: 9
Enter the 5 value in 2nd array: 10
The merged array is: 
1
2
3
4
5
6
7
8
9
10
// Program 12.24 converts binary to a decimal using a function.
#include<stdio.h>
#include<math.h>
int binary_to_deci(int binary);
int main()
{
    int binary,c;
    printf("Enter any binary number: ");
    scanf("%d",&binary);

    c=binary_to_deci(binary);
    printf("The decimal equivalent is %d",c);
}
int binary_to_deci(int binary)
{
    int i=0,decimal=0,a=0,b=0;
    while(binary!=0)
    {
        a=binary%10;
        b=pow(2,i);
        decimal=decimal+(a*b);
        binary=binary/10;
        i++;
    }
    return decimal;
}
Output:
Enter any binary number: 10101
The decimal equivalent is 21
// Program 12.25 converts decimals into binary using functions.
#include<stdio.h>
#include<math.h>
int deci_to_bin(int deci);

int main()
{
    int deci,b;
    printf("Enter any decimal number: ");
    scanf("%d",&deci);
    b=deci_to_bin(deci);
    printf("Entered number in binary form is 
%d",b);
}
int deci_to_bin(int deci)
{
    int i=0,binary=0,remainder=0;
    while(deci!=0)
    {
        remainder=deci%2;
        binary=binary+(remainder*pow(10,i));
        deci=deci/2;
        i++;
    }
    return binary;
}
Output:
Enter any decimal number: 7

The entered number in binary form is 111
// Program 12.26 converts decimals into octal using a function.
#include<stdio.h>
#include<math.h>
int deci_to_octal(int deci);
int main()
{
    int b,deci;
    printf("Enter any decimal number: ");
    scanf("%d",&deci);
    b=deci_to_octal(deci);
    printf("Entered number in octal form: %d",b);
}
int deci_to_octal(int deci)
{
    int octal=0,remainder=0,i=0;
    while(deci!=0)
    {
        remainder=deci%8;
        octal=octal+remainder*pow(10,i);
        deci=deci/8;
        i++;
    }

    return octal;
}
Output:
Enter any decimal number: 18
Entered number in octal form: 22
// Program 12.27 to convert octal into decimal using function.
#include<stdio.h>
#include<math.h>
int octal_to_deci(int octal);
int main()
{
    int octal,c;
    printf("Enter any octal number: ");
    scanf("%d",&octal);
    c=octal_to_deci(octal);
    printf("The decimal equivalent is: %d",c);
}
int octal_to_deci(int octal)
{
    int i=0,decimal=0,a=0,b=0;
    while(octal!=0)
    {
        a=octal%10;

        b=pow(8,i);
        decimal=decimal+(a*b);
        octal=octal/10;
        i++;
    }
    return decimal;
}
Output:
Enter any octal number: 22
The decimal equivalent is: 18
// Program 12.28 updates an array of elements using a function
#include <stdio.h>
void update(int arr[], int length)
{
    arr[0] = 100;
    arr[1] = 200;
}
int main()
{
    int A[] = {1, 2, 3};
    update(A,3); //passing the base address and the 
length of the array
    printf("%d %d %d\n", A[0], A[1], A[2]);

    return 0;
}
Output:
100 200 3
// Program 12.29 increments all array elements by one using function
#include <stdio.h>
void inc(int *p, int size);
int main()
{
    int A[] = {1, 2, 3, 4, 5};
    int size = sizeof(A) / sizeof(A[0]);
    printf("Before incrementing: ");
    for (int i = 0; i < size; i++)
    {
        printf("%d ", A[i]);
    }
    printf("\n");
    inc(A, size); //passing the array and its size
    printf("After incrementing: ");
    for (int i = 0; i < size; i++)
    {
        printf("%d ", A[i]);
    }

    printf("\n");
    return 0;
}
void inc(int *p, int size)
{
    for (int i = 0; i < size; i++)
    {
        p[i]++;
    }
}
Output:
Before incrementing: 1 2 3 4 5
After incrementing: 2 3 4 5 6
Conclusion
This chapter discusses the method of writing the function. When it comes to
the reusability of code and modularity of programs, functions play an
essential role. The user and the program can define their functions, often
built-in or pre-defined. Call by value and call by reference are the two
methods of passing the parameters in the function. The calling convention
determines the order in which parameters are passed and the direction in
which they are passed. In C, arrays can be used as arguments in functions.
The scope and lifetime of a variable are determined by a variable’s storage
class in C, which can be used to optimize the efficiency of a program.
The upcoming chapter will discuss the more advanced concept of the
function, which is known as the recursion. Various problems will be solved
using the recursion.

Points to remember
A program can be divided into different independent sub-programs or
modules known as functions.
Functions are also known as methods, sub-routines, or procedures.
The function provides the facility of modularity, reusability, and
easiness.
Built-in functions are defined in the C header files. They can be
directly called into the program.
The user creates user-defined functions as per his requirement. The
user decides its name at his convenience.
Function prototyping statements tell the compiler in advance that the
program will use that function.
The function definition provides the implementation of the function. It
consists of the actual code of the function’s working.
The function prototype ends with a semicolon, whereas the function
(header) does not; this is the only distinction between these two.
The sort of value a function can return to its caller is called its return
type.
An argument is a piece of information that travels from the calling
function to the called function.
Actual parameters are passed in a function call. They are also known
as an argument.
Formal parameters are passed in the function definition.
With the call-by-value method, the values of the actual parameters will
be copied into the formal parameters’ values.
The pointer is a special variable that holds the variable’s address.
In call-by-reference, the addresses of the variables are passed in actual
parameters.

Storage class determines where the variable is stored, how long it will
exist in memory, where the value will be available in the program, and
its initial value.
Automatic storage uses auto keywords in the declaration of the
variable. By default, every local variable is automatic in C.
Static storage class uses static keywords. The static variable gets
initialized by zero by default.
The register storage class uses the register keyword. The register
variable holds memory in CPU registers.
External storage uses the extern keyword. Its value is accessible all
over the program.
Important questions
1. What is a function? Explain different types of functions.
2. Explain the need for the functions.
3. Differentiate between built-in and user-defined functions?
4. Explain various parts of the user-defined function.
5. What are the different types of parameters?
6. What are the differences between call by value and call by reference?
7. What is the calling convention in C, and how does it determine the
order and direction of parameter passing?
8. How can arrays be passed as arguments to functions?
9. What are the storage classes in C, and how do they affect the scope
and lifetime of a variable?
10. What is the calling convention in C, and how does it determine the
order and direction of parameter passing?
11. How can arrays be passed as arguments to functions?
12. What are the storage classes in C, and how do they affect the scope
and lifetime of a variable?

Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 13
Recursion
Introduction
This chapter is dedicated to the concept of recursion in computer science.
Recursion is a powerful problem-solving technique where a function calls
itself, and it forms the basis for our discussions here. We will explore how to
use recursion to find factorials, generate the Fibonacci series, and tackle the
intriguing Ackermann function. Additionally, we will delve into the
principles of Merge Sort and Quick Sort, showcasing how recursion plays a
pivotal role in these sorting algorithms.
Structure
In this chapter, we will be discussing the following topics:
Recursion
Finding the factorial of a number using recursion
Fibonacci series by recursion
Ackermann function by recursion
Merge sort
Quick sort

Objectives
The objective of this chapter is to provide a comprehensive understanding of
recursion in computer science. Readers will learn the principles of recursion
and its practical applications through examples such as calculating
factorials, generating the Fibonacci series, and solving the Ackermann
function recursively. Additionally, we will explore the implementation of
recursion in sorting algorithms such as Merge Sort and Quick Sort,
equipping readers with valuable problem-solving skills.
Recursion
A recursive function calls itself repetitively; such function calls are known
as recursive calls, and the process of calling is known as recursion. Every
recursion function consists of two parts, which are as follows:
Stopping condition or base case: It is used to stop the recursion
process. So, it works as the terminator of the recursion process.
Recursive call: It calls the function repeatedly until the stopping
condition is reached.
Let us analyze the following program:
//Program 13.1 Exhibits the recursion process
#include <stdio.h>
int display (int);
void main()
{
    int n,a;
    printf("Enter the number n:");
    scanf("%d",&n);
    display(n);

}
int display(int n)
{
    if(n == 0)             // Stopping condition
        return 0; 
    else
    {
        printf("%d ",n);
        return display(n-1);     // Recursive call
    }
}
Output:
Enter the number n: 10
10 9 8 7 6 5 4 3 2 1
In the preceding program, the function display() calls itself again and again
until the stopping condition is met, where if(n == 0) is a stopping condition
and display(n-1) is a recursive call.
Finding the factorial of a number
The factorial of a number is obtained by multiplying all the positive integers
from 1 up to that number. It is denoted by the number followed by an
exclamation mark (!). The n! is calculated as follows:
n! = n * (n-1)!
And
0! = 1

The 5! is calculated as follows:
5! = 5 * 4 * 3 * 2 * 1 
Since 0! = 1
Therefore, the factorial of 5 is 120.
To understand the recursion better, let us take an example of finding n!
Where n! = n * (n – 1)! Let us find the factorial of 4, i.e., 4!
n!=n*(n–1)!   , where n = 4
4!=4*(3)!    , where 3! = 3 * 2!
Therefore,
4!=4*3*2!     , where 2! = 2 * 1!
So, 4!=4*3*2*1!, we know that 1! or 0! = 1.
Hence,
4! = 4 * 3 * 2 * 1
=24
// program 13.2 finds the factorial of a number using recursion
#include <stdio.h>
int factorial (int);
int main()
{
    int n,a;
    printf("Enter the number n:");
    scanf("%d",&n);
    a = factorial(n);
    printf("The factorial of n = %d",a);

}
int factorial(int n)
{
    if (n==0)                      // Base case
        return 1;
    else
        return n*factorial(n-1);  // Recursive case
}
Output:
Enter the number n: 4
The factorial of n = 24
To understand the expression 4 * factorial(3) in the preceding program,
let us break it step by step as follows:
1. The function factorial(3) is called.
2. Inside the factorial function:
a. The base case is not met since n is not zero (n = 3).
b. The recursive case is executed, and the function calls itself with
n - 1, which is 2.
3. Inside the second call to factorial:
a. Again, the base case is not met (n = 2).
b. The function makes another recursive call to factorial with n -
1, which is 1.
4. Inside the third call to factorial:
a. The base case is not met (n = 1).

b. The function makes another recursive call to factorial with n -
1, which is 0.
5. Inside the fourth call to factorial:
a. This time, the base case is met (n = 0).
b. The function returns 1 since the factorial of 0 is defined as 1.
6. Going back to the third call to factorial:
a. The result of the fourth call is received as 1.
b. The function multiplies the current n (which is 1) by the result,
giving 1 * 1 = 1.
c. The result of this computation is returned to its previous
recursive call.
7. Going back to the second call to factorial:
a. The result of the third call is received as 1.
b. The function multiplies the current n (which is 2) by the result,
giving 2 * 1 = 2.
c. The result of this computation is returned to its previous
recursive call.
8. Going back to the initial call factorial(3):
a. The result of the second call is received as 2.
b. The function multiplies the current n (which is 3) by the result,
giving 3 * 2 = 6.
c. The result of this computation is returned to its previous
recursive call.
Finally, the expression 4 * factorial(3) evaluates to 4 * 6, which gives
the final result as 24. The diagrammatical representation of the preceding

steps for the statement return n * factorial(n-1) for n=4 is shown in Figure
13.1:
Figure 13.1: Flowchart to calculate the factorial of 4 using recursion
Fibonacci series
In the Fibonacci series, each term is the sum of the two terms that came
before it. It starts with 0, followed by 1. It is denoted by T(n).
For example:
0, 1, 1, 2, 3, 5, 8,...
The recursive equation of the Fibonacci series is as follows:
T(n) = T(n-1) + T(n-2), for n >= 2 
T(n) = n, for n < 2 for all positive integers(the 
base condition)
T(0) and T(1) are the first and second terms of the series. T(n) is the nth term
of the series
T(0) = 0
T(1) = 1

So, T(2) = T(1) + T(0) = 1 + 0 = 1
T(3) = T(2) + T(1) = 1 + 1 = 2
T(4) = T(3) + T(2) = 2 + 1 = 3
T(5) = T(4) + T(3) = 3 + 2 = 5
and so on.
The Fibonacci series is recursive, where each term depends on the previous
two terms.
For example, to calculate the 6th term (T(6)), you would use the following
steps:
   T(6) = T(5) + T(4)
= (T(4) + T(3)) + (T(3) + T(2))
= ((T(3) + T(2)) + (T(2) + T(1))) + ((T(2) + T(1)) 
+ (T(1) + T(0)))
= ((T(3) + T(2)) + (T(2) + 1)) + ((T(2) + 1) + (1 
+0))           Since T0 = 0 and T1 = 1.
= (((T(2) + T(1)) + (T(1) + T(0))) + ((T(1) + T(0)) 
+ 1)) + (((T(1) + T(0)) + 1) + (1 +0))
=((((T(1) + T(0)) +1) + (1 + 0) + ((1 + 0) + 1)) + 
(((1 + 0) + 1) + (1 +0))
=((((1 + 0) +1) + (1 + 0) + ((1 + 0) + 1)) + (((1 + 
0) + 1) + (1 +0))
= 8
So, T(6) = 8.
You can generalize this recursive function to calculate the Fibonacci
sequence for any term if you provide the base cases for T(0) and T(1).
// Program 13.3 generate the Fibonacci series

#include <stdio.h>
int fib(int n)
{
   if(n == 0)
      return 0;
   else if(n == 1)
      return 1;
   else
      return (fib(n-1)+fib(n-2));
}
void main()
{
   int n;
   int i;
   printf("Enter Number:\n");
   scanf("%d",&n);
   printf("The elements are:\n");
   for(i = 0;i<n;i++)
   {
   printf("%d ",fib(i));
   }
}
Output:

Enter Number:
5
The elements are:
0 1 1 2 3
Ackermann function
German mathematician Wilhelm Ackermann developed the Ackermann
function in 1928. It is a recursive mathematical function. It grows rapidly as
its input increases. It takes two inputs (m and n), both are non-negative
integers. Even for small values of m and n, the function can produce
extremely large values. Let A(m,n) be an Ackermann function. It can be
given as follows:
Where m and n are two non-negative integers:
Let us solve A(1,1). Here m=1 and n=1
A(1,1) = A(0,A(1,0)) ……… (1)     as m>0 and n>0
In order to find A(1,1), first we have to find A(1,0)
A(1,0) = A(0,1)……………………………(2)     as m>0 and n=0
A(0,1)=1+1=2                 as m=0 
Now, put the value of A(0,1) in equation (2)
Hence, A(1,0)=2
Now, put the value of A(1,0) in equation (1)
Hence, A(1,1) = A(0,2)……………………………(3)

A(0,2)=2+1=3                 as m=0
Now put the value of A(0,2) in equation (3). So,
A (1, 1) = 3
// Program 13.4 shows the Ackermann function implementation
#include <stdio.h>
int ack(int m, int n)
{
    if (m == 0)
        return n+1;
    else if((m > 0) && (n == 0))
        return ack(m-1, 1);
    else if((m > 0) && (n > 0))
        return ack(m-1, ack(m, n-1));
       
}
void main()
{
    int A,m,n;
    printf("Enter the value of m and n:\n");
    scanf("%d%d",&m,&n);
    A = ack(m,n);
    printf("The value of Ackermann Function is:%d", 
A);

}
Output:
Enter the value of m and n:
1
1
The value of the Ackermann Function is: 3
Merge sort
It splits the array recursively into smaller arrays until the array size is one. It
sorts them individually and then merges them back together to produce a
sorted array, as shown in Figures 13.2 and 13.3, respectively. So, it follows
the divide-and-conquer approach.
Figure 13.2: Division of array in merge sort
Refer to Figure 13.3:
Figure 13.3: Merging of the array by sorting the sub-arrays
The following is an explanation of how merge sort works using recursion:
Divide: The first step is to divide the array into two sub-arrays by finding
the array’s middle index (Mid) as follows:
Mid(m)=(L+R)/2: Here, L is the starting index, and R is the last index of the
array.
Recursively sort: After dividing the array, we recursively apply the merge
sort algorithm to the two sub-arrays. This step continues until we reach sub-
arrays of size 1, which is already considered sorted. Look at Figure 13.2.
Merge: Once the two sub-arrays are sorted, we merge them back together to
obtain a single sorted array. The merging process involves comparing

elements from the two sub-arrays and selecting the smaller (or larger)
element to place in the final sorted array. This step is repeated until all
elements from both sorted sub-arrays are merged to form a single sorted
array. See Figure 13.3.
Algorithm for merge sort
1. Start.
2. Declare the array A[], L, and R where L is the index of the first
element, and R is the index of the last element of the array A[].
3. if (R>L)
4. {
a. Calculate mid by M=(L+R)/2, which divides the array into two
halves.
b. Call mergesort(A,L,M)for left half.
c. Call mergesort(A,M+1,R)for right half.
5. Call merge(A,L,M,R)to recursively combine the two halves in a sorted
manner so that only one sorted array is left.
6. }
7. Stop
//Program 13.5 show the merge sorting
#include <stdio.h>
#include <stdlib.h>
// Merges two sub-arrays of A[] i.e.A[l..m] and 
A[m+1..r]
void merge(int A[], int l, int m, int r)
{
    int i, j, k;

    int a1 = m - l + 1;
    int a2 = r - m;
    // Create temp array
    int L[a1], R[a2];
    // Copy data to temp array
    // L[] and R[]
    for (i = 0; i < a1; i++)
        L[i] = A[l + i];
    for (j = 0; j < a2; j++)
        R[j] = A[m + 1 + j];
    // Merge the temp array back into A[l..r]
    i = 0;  // Initial index of first sub-array
    j = 0;  // Initial index of second sub-array
    k = l;  // Initial index of merged sub-array
while (i < a1 && j < a2)
    {
        if (L[i] <= R[j])
        {
            A[k] = L[i];
            i++;
        }
        else
        {

            A[k] = R[j];
            j++;
        }
        k++;
    }
    // Copy the remaining elements L[]
    while (i < a1)
        {
        A[k] = L[i];
        i++;
        k++;
        }
    // Copy the remaining elements of R[]
    while (j < a2)
    {
        A[k] = R[j];
        j++;
        k++;
    }
}
// l is for the left index, and r is the right 
index of the sub-array of the array
void mergesort(int A[], int l, int r)

{
    if (l < r)
    {
        int m = l + (r - l) / 2;
        mergesort(A, l, m);     // for first half
        mergesort(A, m + 1, r); // for second half
        merge(A, l, m, r);
    }
}
//function to print an array
void print(int A[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", A[i]);
    printf("\n");
}
int main()
{
    int A[] = {20,10,50,60,30,40,80,70};
    int size = sizeof(A)/sizeof(A[0]);
    printf("Unsorted array: ");
    print(A, size);

    mergesort(A, 0, size - 1);
    printf("Sorted array: ");
    print(A, size);
    return 0;
}
Output:
Unsorted array: 20 10 50 60 30 40 80 70
Sorted array: 10 20 30 40 50 60 70 80
Quick sort
It picks an element to be the pivot (the first element) and then splits the
array into two parts based on that pivot. The pivot element divides the array
into two sub-arrays, that is, left and right arrays, in such a way that the
elements on the left array are smaller than the value of the pivot element,
and the elements in the right array are larger than the pivot. It is also a
“divide and conquer” algorithm like merge sort.
Let us consider the example shown in Figure 13.4:
Figure 13.4: Array A before sorting
Some important steps of Pass 1 in quick sort are as follows:
Pass 1
1. In the preceding figure, pivot=30, i and j are the two pointers. The i
moves RHS (i++) and stops when it finds the element greater than
the pivot. And j moves LHS (j--) until it gets the element lesser
than the pivot.
2. If i<j, swap both the elements pointed by i and j.
3. If i>j, swap the pivot and the element pointed by j.

4. After the preceding steps are done, the array is split into two parts,
and the pivot finds its appropriate place. That is, all the elements on
LHS are lesser than the pivot, and all the elements on RHS are larger
than the pivot, as shown in Figure 13.11.
After this, the same steps will be applied to the sub-array left to pivot and
the sub-array right to pivot. The preceding steps can be written by the
following pseudo-code.
while(i<j)
        {
            while(A[i]<= A[pivot]&& i<last)         
// Condition 1
           //last is the last element of the array 
                i++;
            while(A[j]> A[pivot])             // 
Condition 2
                j--;
            if(i<j)            
                {        //Swapping of ith and jth 
element
                    temp= A[i];
                    A[i]= A[j];
                    A[j]=temp;
                }
        }
        temp= A[pivot];  //Swapping of j and pivot
        A[pivot]= A[j];

        A[j]=temp;
Let us try to solve the example shown in Figure 13.5 step by step using the
preceding pseudo-code:
Figure 13.5: Array A before sorting
Refer to Table 13.1:
Initial values
Test Condition
Action
Value of variables
i=0
j=4
A[i]=30
A[j]=20
A[pivot]=30
1. 30<=30 && 0<4
2. 20>30
As condition 1 is true, and condition 2 is false
i++
i=1
j=4
pivot=30
Table 13.1: The initial values of the variable, the action taken, and the final
values based on test conditions
After the preceding step, the array looks like in Figure 13.6:
Figure 13.6: Array after the first step
Refer to Table 13.2:
Initial values
Test condition
Action
Value of
variables
i=1
j=4
A[i]=50
A[j]=20
A[pivot]=30
1. 50<=30 &&
1<4
2. 20>30
As both the
conditions are false
Swapping of ith and jth
element of A
as(i<j)
i=1
j=4
pivot=30
Table 13.2: The initial values of the variable, the action taken, and the final
values based on test conditions
After the preceding step, the array looks like in Figure 13.7:

Figure 13.7: Array after the second step
Refer to Table 13.3:
Initial values
Test condition
Action
Value of variables
i=1
j=4
A[i]=20
A[j]=50
A[pivot]=30
1. 20<=30 && 1<4
2. 50>30
 
As both the conditions are true
i++
j--
i=2
j=3
pivot=30
Table 13.3: The initial values of the variable, the action taken, and the final
values based on test conditions
After the preceding step, the array looks like Figure 13.8:
Figure 13.8: Array after the third step
Refer to Table 13.4:
Initial values
Test condition
Action
Value of variables
i=2
j=3
A[i]=10
A[j]=40
A[pivot]=30
1. 10<=30 && 2<4
2. 40>30
As both the conditions are true
i++
j--
i=3
j=2
pivot=30
Table 13.4: The initial values of the variable, the action taken, and the final
values based on test conditions
After the preceding step, the array looks like in Figure 13.9:
Figure 13.9: Array after the fourth step
Refer to Table 13.5:

Initial values
Test condition
Action
Value of
variables
i=3
j=2
A[i]=40
A[j]=10
A[pivot]=30
1. 40<=30 && 
3<4
2. 10>30
 
As both the
conditions are false
Swap A[Pivot] with the jth 
element of A
as(i>j)
i=3
j=2
pivot=10
Table 13.5: The initial values of the variable, the action taken, and the final
values based on test conditions
After the preceding step, the array looks like Figure 13.10:
Figure 13.10: Array after the fifth step
Figure 13.10 is logically divided into two halves, as shown in Figure 13.11:
Figure 13.11: Pivot to its desired place
Algorithm for quick sort
1. Start.
2. Declare the array A[]and last, which is the last element of the array
A.
3. Quicksort(A,0,last)
4. {
5. Bring the pivot to its position such that the left of the pivot is smaller,
and the right of the pivot is larger than the pivot.
6. Quicksort the left portion, that is, Quicksort(A,0,j-1).
7. Quicksort the right portion, that is, Quicksort(A,j+1,last).
8. }

// Program 13.6 shows the working of the quick sort
#include <stdio.h>
void Quicksort(int A[50],int first,int last)
{
    int i,j,pivot,temp;
    if(first<last)
    {
        pivot=first;
        i=first;
        j=last;
        while(i<j)
        {
            while(A[i]<=A[pivot]&& i<last)
                i++;
            while(A[j]>A[pivot])
                j--;
            if(i<j)                 
            {        //Swapping of ith and jth 
elements
                temp=A[i];
                A[i]=A[j];
                A[j]=temp;
            }

        }
        temp=A[pivot];      //Swapping of jth 
element and pivot
        A[pivot]=A[j];
        A[j]=temp;
        Quicksort(A,0,j-1); // recursively sort 
left smaller sub array
        Quicksort(A,j+1,last);    // recursively 
sort right smaller sub array
    }
}
void main()
{
    int A[50];
    int n,i;
    printf("Enter the size of an array:\n");
    scanf("%d",&n);
    printf("Enter Elements:\n");
    for (i = 0; i < n; i++)
        scanf("%d", &A[i]);
    printf("The unsorted array is: \n");
    for (i = 0; i < n; i++)
        printf("%d\t", A[i]);
    Quicksort(A,0,n-1);

    printf("\nThe sorted array is: \n");
    for (i = 0; i < n; i++)
        printf("%d \t", A[i]);
}
Output:
Enter the size of an array:
5
Enter Elements:
30
50
10
40
20
The unsorted array is:
30      50      10      40      20
The sorted array is:
10      20      30      40      50
Conclusion
This chapter discusses the important concept of programming known as
recursion. A recursion function is a function that solves problems by
breaking them down into smaller subproblems through self-calls. In this
chapter, various problems are solved using recursion, such as finding the
factorial of a number, Fibonacci series, Ackerman function, merge sort, and
quick sort. The factorial of a number is found by multiplying all positive
integers up to that number. The Fibonacci series is a sequence where each

number is the sum of the two preceding ones. The Ackermann function is a
mathematical function used to illustrate computational complexity. Merge
sort is a sorting algorithm that divides the array, sorts sub-arrays recursively,
and then merges them. Quick sort is another sorting algorithm that selects a
pivot, partitions elements, and recursively sorts sub-arrays.
The upcoming chapter provides two special user-defined data types, which
are structure and union. It also illustrates the use of a pointer in accessing
the content of the structure.
Points to remember
A recursive function calls itself repetitively; such function calls are
known as recursive calls. This process is known as recursion.
The stopping condition or base case is used to stop the recursion
process. So, it works as the terminator of the recursion process.
The factorial of a number is obtained by multiplying all the positive
integers from 1 up to that number.
In the Fibonacci series, each term is the sum of the two terms that
came before it. It starts with 0, followed by 1.
German 
mathematician 
Wilhelm 
Ackermann 
developed 
the
Ackermann function in 1928. It is a recursive mathematical function.
Ackermann’s function takes two inputs (m and n), both are non-
negative integers.
The merge splits the array recursively into smaller arrays until the
array size is one. It sorts them individually and then merges them back
together to produce a sorted array.
The quick sort picks an element to be the pivot (the first element) and
then splits the array into two parts based on that pivot.
The pivot element divides the array into two sub-arrays, that is, left
and right arrays, in such a way that the elements on the left array are
smaller than the value of the pivot element, and the elements in the
right array are larger than the pivot.

The merge and quick sort algorithms are divide and conquer
algorithms like merge sort.
Important questions
1. What is recursion, and how does it work?
2. What is the base case in a recursive function, and why is it important?
3. What is the difference between recursion and iteration?
4. How can you prevent infinite recursion in a recursive function?
5. Explain the concept of a recursive stack and how it relates to
recursive function calls.
6. Write a recursive function to calculate the factorial of a number.
7. How would you implement a recursive function to compute the nth
Fibonacci number?
8. Describe the advantages and disadvantages of using recursion in
programming.
9. Write a recursive function to calculate the sum of all elements in an
array.
10. How can you convert a recursive function into an iterative one?
11. Explain Ackermen’s function in detail by taking a suitable example.
12. Write a program to calculate the output of the Ackerman function
13. Explain the Fibonacci series and write the program to generate a
Fibonacci series up to a given number.
14. Explain merge sort using recursion.
15. Explain quick sort by taking a suitable example.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com


CHAPTER 14Structure and Union
Introduction
This chapter will teach us how to define structures, access their elements,
and initialize them. We will also explore the concept of arrays of structures,
working with structure pointers, unions, nested structures, and passing
structures as function parameters. This knowledge will empower you to
handle complex data structures effectively in your programs.
Structure
In this chapter, we will be discussing the following topics:
Defining a structure
Accessing the structure element
Initialization of the structure
An array of structures
Structure with pointer
Union
Nested structure
Passing structure in a function
Objectives
This chapter aims to provide a comprehensive understanding of structured
data in programming. The reader will learn how to define and work with
structures, access and initialize their elements, and explore advanced
concepts such as arrays of structures, structure pointers, unions, and nested
structures. Additionally, we will cover how to pass structures as function
parameters, equipping readers with the skills to manage and manipulate
complex data structures in their programs effectively.
Defining a structure

The structure is a collection of dissimilar or heterogeneous data types, such
as integer, character, float, and so on. For instance, a student’s record may
contain the student’s name, roll number, class, section, and so on. Here, the
student’s record acts as a structure.
A struct keyword is used in defining the structure. Every structure should
have a name which is used to identify the structure. The structure block
contains entities with different data types known as members. At the end of
the structure block, structure variables are placed. These variables are
known as objects. A separate space is reserved for each object in the
memory. The total space occupied by the structure is equal to the sum of all
the spaces occupied by its objects. A semi-colon (:) terminates the
structure. The syntax for defining a structure is shown as follows:
struct structure_name // Structure declaration
{
datatype member_name_1;
datatype member_name_2;
....................
datatype member_name_N;
} List of objects; // Structure definition or object declartion
The declaration of structure tells about the structure name and its member
names without allocating any memory space for them. Once the structure is
declared, the objects of the structure are created, which allocates the
memory for its members. The memory view of the structure having two
objects, Object_1 and Object_2, for the preceding syntax is shown in
Figure 14.1:
Figure 14.1: Structure representation in memory

Let us create a structure for two students, S1 and S2, which contains the
following information:
Student name
Student class
Student section
Student roll no
The following code stores the information of two students, S1 and S2:
struct student // Structure declaration
{
char Name[10];
char Class[10];
char Section[10];
int Roll;
} S1, S2; // Structure definition or object declartion
Figure 14.2 shows the scenario created by the preceding code:
Figure 14.2: Details of two students in memory
The objects S1 and S2 can also be created by the following method:
struct student
{
char Name[10];
char Class[10];

char Section[10];
int Roll;
};
struct student S1,S2; // objects declaration
Accessing the structure element
A structure member variable is accessed through the object name followed
by a dot operator and the member name. The syntax for accessing a
member of a structure is given as shown:
object_name.member_name;
For example, consider the following example to access the members of the
preceding-created structure:
S1.Name // Accesses the name of S1 student
S1.Class
S2.Section // Accesses the section of S2 student
S2.Roll
Initialization of the structure
A structure can be initialized by assigning the values to its members. The
value is assigned with the help of a structured object. If the structure is not
initialized, the integer and float member are initialized with zero, and the
character is initialized with \0 by default. The following methods can be
used to initialize the structure.
Method 1: At the time of object declaration, as shown in the following
codes:
struct structure_name

{
datatype member_name_1;
datatype member_name_2;
....................
datatype member_name_N;
} obj1={val_1, val_2,……val_N}; // Initialization at the time of declaration
Method 2: Initialization after structure declaration as shown in the
following codes:
struct structure_name
{
datatype member_name_1;
datatype member_name_2;
....................
datatype member_name_N;
};
struct structure_name obj={val_1, val_2,……val_N}; //Initialization after
structure declaration
The following code initializes the object S1 and S2 by method 1:
struct student
{
char Name[10];

char Class[10];
char Section[10];
int Roll;
} S1={"KAMAL","B.Tech","Mechanical",1},
S2={"Ajay", "B.Tech","Mechanical",2};
 
// Program 14.1 shows the initialization of the structure variable using
method 1
#include <stdio.h>
#include <string.h>
struct student
{
char Name[10];
char Class[10];
char Section[10];
int Roll;
}S1={"KAMAL","B.Tech","Mechanical",1},
S2={"Ajay","B.Tech","Mechanical",2};
int main()
{
/* print Student 1 information */

printf( "Student Name: %s\n", S1.Name);
printf( "Student Class: %s\n", S1.Class);
printf( "Student Section: %s\n", S1.Section);
printf( "Student Roll Number: %d\n", S1.Roll);
/* print Student 2 information */
printf( "Student Name: %s\n", S2.Name);
printf( "Student Class: %s\n", S2.Class);
printf( "Student Section: %s\n", S2.Section);
printf( "Student Roll Number: %d\n", S2.Roll);
return 0;
}
Output:
Student Name: KAMAL
Student Class: B.Tech
Student Section: Mechanical
Student Roll Number: 1
Student Name: Ajay
Student Class: B.Tech
Student Section: Mechanical
Student Roll Number: 2

The following code initializes the object S1 and S2 by method 2, that is,
after the structure declaration:
struct student
{
char Name[10];
char Class[10];
char Section[10];
int Roll;
};
struct student S1={"KAMAL", "B.Tech","Mechanical",1};
struct student S2={"Ajay", "B.Tech","Mechanical",2};
//Program 14.2 shows the initialization of structure using method 2
#include <stdio.h>
#include <string.h>
struct student
{
char Name[10];
char Class[10];
char Section[10];
int Roll;
};

struct student S1={"KAMAL", "B.Tech","Mechanical",1},S2=
{"Ajay","B.Tech","Mechanical",2};
int main( )
{
/* print Student 1 information */
printf( "Student Name: %s\n", S1.Name);
printf( "Student Class: %s\n", S1.Class);
printf( "Student Section: %s\n", S1.Section);
printf( "Student Roll Number: %d\n", S1.Roll);
/* print Student 2 information */
printf( "Student Name: %s\n", S2.Name);
printf( "Student Class: %s\n", S2.Class);
printf( "Student Section: %s\n", S2.Section);
printf( "Student Roll Number: %d\n", S2.Roll);
return 0;
}
Output:
Student Name: KAMAL
Student Class: B.Tech
Student Section: Mechanical
Student Roll Number: 1

Student Name: Ajay
Student Class: B.Tech
Student Section: Mechanical
Student Roll Number: 2
We can also initialize the object of the structure using a string function
strcpy, as shown in the following program:
//Program 14.3 shows the initialization by strcpy function
#include <stdio.h>
#include <string.h>
struct student
{
char Name[10];
char Class[10];
char Section[10];
int Roll;
};
struct student S1,S2;
int main( )
{
/* Student 1 detail */
strcpy( S1.Name, "KAMAL");

strcpy( S1.Class, "B.Tech");
strcpy( S1.Section, "Mechanical");
S1.Roll = 1;
/* Student 2 detail */
strcpy( S2.Name, "Ajay");
strcpy( S2.Class, "B.Tech");
strcpy( S2.Section, "Computer");
S2.Roll = 2;
/* print Student 1 information */
printf( "Student Name: %s\n", S1.Name);
printf( "Student Class: %s\n", S1.Class);
printf( "Student Section: %s\n", S1.Section);
printf( "Student Roll Number : %d\n", S1.Roll);
/* print Student 2 information */
printf( "Student Name: %s\n", S2.Name);
printf( "Student Class: %s\n", S2.Class);
printf( "Student Section: %s\n", S2.Section);
printf( "Student Roll Number: %d\n", S2.Roll);
return 0;
}

Output:
Student Name: KAMAL
Student Class: B.Tech
Student Section: Mechanical
Student Roll Number: 1
Student Name: Ajay
Student Class: B.Tech
Student Section: Computer
Student Roll Number: 2
An array of structures
If we have to enter the details of, say, 100 students, then 100 objects need
to be created. The other option is to use an array of objects having 100
elements in it. Hence, an array of structures is simply the collection of the
structure objects. The general syntax for declaring an array of structures is
given as follows:
struct structure_name
{
Datatype member_name 1;
Datatype member_name 2;
......................
Datatype member_name n;
} obj[size]; // Array of structure

The following syntax is also equivalent to the preceding code:
struct structure_name
{
Datatype member_name 1;
Datatype member_name 2;
......................
Datatype member_name n;
};
struct structure_name obj[size]; // Array of structure
The following program shows an array of structures by entering student’s
detail:
//Program 14.4 shows an array of structures by entering student's detail.
#include<stdio.h>
struct student
{
int roll;
char name[10];
}s[10]; // Array of objects
void main()
{
int i;

printf("Enter the records of 10 students");
for(i=0;i<10;i++)
{
printf("\nEnter Roll Number:");
scanf("%d",&s[i].roll);
printf("Enter Name:");
scanf("%s",&s[i].name);
}
printf("\nStudent Information List:");
for(i=0;i<10;i++)
{
printf("\nRoll Number:%d, Name: %s",s[i].roll,s[i].name);
}
}
Output:
Enter the records of 10 students
Enter Roll Number:1
Enter Name: Kamal
Similarly, ask for the remaining nine other records and print them.
Structure with pointer

Similar to a pointer containing another variable’s address, the structure
pointer points to the address of the memory block where the structure is
stored. The structure pointer allows to access and manipulate the members
of a structure.
Declaration of the structure pointer
The asterisk (*) symbol is used in the pointer declaration before the
pointer’s name. The following syntax is used in the declaration of the
structure pointer:
struct structure_name
{
//structure members
}object1;
struct structure_name *ptr; // declaring a structure pointer
Here, ptr is the structure pointer.
Initialization of the structure pointer
After the declaration of the structure pointer, we need to initialize it. The
ampersand (&) operator is used to provide the address of the object to the
structure pointer, as shown:
ptr = &structure_variable;
For example,
ptr = &object1; // ptr holds the address of object object1
Access structure member using a pointer:
The structure pointer can access structure members in one of two ways:

Using arrow (->) operator.
Using asterisk (*) or indirection operator and dot (.) operator.
The following program shows the use of the arrow (->) operator or for
dealing with structure members:
//Program 14.5 Uses arrow (->) operator or for dealing with structure
members
#include <stdio.h>
struct Student
{
char name[30];
int age;
char gender[30];
}std1,std2;
// Variables of the structure with pointers
struct Student *ptr1, *ptr2;
int main()
{
ptr1 = &std1; // ptr1 holds the address of std1
ptr2 = &std2; // ptr2 holds the address of std2
printf (" \n First Student: \n");
printf (" Enter the name of the Student: ");

scanf (" %s", &ptr1->name);
printf (" Enter the age of the Student: ");
scanf (" %d", &ptr1->age);
printf (" Enter the gender of the Student: ");
scanf (" %s", &ptr1->gender);
printf (" \n Second Student: \n");
printf (" Enter the name of the Student: ");
scanf (" %s", &ptr2->name);
printf (" Enter the age of the Student: ");
scanf (" %d", &ptr2->age);
printf (" Enter the gender of the Student: ");
scanf (" %s", &ptr2->gender);
printf ("\n Display the details of the Student using the structure Pointer");
printf ("\n Details of the Student \n");
printf(" Name: %s\n", ptr1->name);
printf(" Age: %d\n", ptr1->age);
printf(" Gender: %s\n", ptr1->gender);
printf ("\n Details of the Student \n");
printf(" Name: %s\n", ptr2->name);
printf(" Age: %d\n", ptr2->age);

printf(" Gender: %s\n", ptr2->gender);
return 0;
}
Output:
First Student:
Enter the name of the Student: Kamal
Enter the age of the Student: 30
Enter the gender of the Student: Male
Second Student:
Enter the name of the Student: John
Enter the age of the Student: 25
Enter the gender of the Student: Male
Display the details of the student using the structure Pointer
Details of the Student
Name: Kamal
Age: 30
Gender: Male
Details of the Student
Name: John
Age: 25

Gender: Male
The following program shows the use of (*) asterisk or indirection operator
and dot (.) operator:
//Program 14.6 Uses (*) asterisk or indirection operator and dot (.) operator
#include <stdio.h>
struct Student
{
char name[30];
int age;
char gender[30];
};
//Define the variables of the structure with pointers
struct Student std1, std2, *ptr1, *ptr2;
int main()
{
// store the address of the std1 and std2 structure variable
ptr1 = &std1;
ptr2 = &std2;
printf (" \n First Student: \n");
printf (" Enter the name of the Student: ");
scanf (" %s", &ptr1->name);

printf (" Enter the age of the Student: ");
scanf (" %d", &ptr1->age);
printf (" Enter the gender of the Student: ");
scanf (" %s", &ptr1->gender);
printf (" \n Second Student: \n");
printf (" Enter the name of the Student: ");
scanf (" %s", &ptr2->name);
printf (" Enter the age of the Student: ");
scanf (" %d", &ptr2->age);
printf (" Enter the gender of the Student: ");
scanf (" %s", &ptr2->gender);
printf ("\n Display the Details of the Student using the structure pointer");
printf ("\n Details of the Student \n");
printf("Name: %s\n", (*ptr1).name);
printf("Age: %d\n", (*ptr1).age);
printf("Gender: %s\n", (*ptr1).gender);
printf ("\n Details of the Student \n");
printf("Name: %s\n", (*ptr2).name);
printf("Age: %d\n", (*ptr2).age);
printf("Gender: %s\n", (*ptr2).gender);

return 0;
}
Output:
First Student:
Enter the name of the Student: Kamal
Enter the age of the Student: 30
Enter the gender of the Student: Male
Second Student:
Enter the name of the Student: John
Enter the age of the Student: 25
Enter the gender of the Student: Male
Display the Details of the Student using the structure pointer
Details of the Student
Name: Kamal
Age: 30
Gender: Male
Details of the Student
Name: John
Age: 25
Gender: Male

Union
It is also a collection of dissimilar or heterogeneous data types like
structures. It can hold different data types such as integer, character, float,
and so on.
Most of the characteristics of the union are the same as the structure except
the space occupied in the memory. The union occupies less space as
compared to the structure. The structure occupies space for all its members
separately, whereas the union members use the size occupied by its largest
data members one by one. So, the union’s size is equal to the size of its
largest data type, whereas the total space occupied by the structure is the
sum of the sizes of its data members. The union uses the union keyword.
Check the following code for union declaration and definition.
union student //union declaration
{
char Name[10];
char Class[10];
char Section[10];
int Roll;
} S1, S2; //union definition
Here, S1 and S2 are the objects of the union student, and name, class,
section, and Roll are the union members.
It should be noted that the space occupied by the structure is not always
equal to the sum of the size of its members. It is because the compiler adds
the padding to avoid alignment issues. Paddings are the additional bytes
added by the compilers.
// Program 14.7 shows the size occupied by the union

#include <stdio.h>
int main()
{
union A
{
int x; // sizeof(int) = 4
double z; // sizeof(double) = 8
short int y;// sizeof(short int) = 2
};
printf("Size of union: %ld", sizeof(union A));
return 0;
}
Output:
Size of union: 8
Union members use the space occupied by its largest data members one by
one. In Program 14.7, the largest data member is double. Hence, it occupied
8 bytes of space in the memory. Figure 14.3 shows the space occupied by
the union in Program 14.7:
Figure 14.3: Space occupied by union
// Program 14.8 Shows the number of bytes occupied by the structure in
memory

#include <stdio.h>
int main()
{
struct A
{
int x; // size of int is = 4
double z; // size of double = 8
short int y; // size of short int = 2
};
printf("Size of struct: %ld", sizeof(struct A));
return 0;
}
Output:
Size of struct: 24
The size of a structure in C is determined by the sum of the sizes of its
individual members, considering any padding added by the compiler for
alignment purposes. In this case, the structure A contains an integer x (size
4), a double z (size 8), and a short integer y (size 2).
The compiler may add padding between members to ensure proper
alignment. In most architectures, double values need to be aligned on 8-
byte boundaries. Therefore, after the integer x (4 bytes), there will be 4
bytes of padding to align the double z properly. Then, the double z follows
(8 bytes), and the short integer y follows immediately (2 bytes).

So the total size of the structure A is 4 + 4 (padding) + 8 + 2 = 18 bytes.
However, due to memory alignment requirements, the actual size of the
structure will be rounded up to the nearest multiple of the largest member
size, which is 8 bytes (the size of the double). Hence, the structure’s size
will be 24 bytes, as shown in Figure 14.4:
Figure 14.4: Memory space occupied by the Program 14.8
// Program 14.9 shows the concept of padding in the structure
#include <stdio.h>
int main()
{
struct A
{
double z; // sizeof(double) = 8
int x; // sizeof(int) = 4
short int y; // sizeof(short int) = 2
};
printf("Size of struct: %ld", sizeof(struct A));
return 0;
}
Output:
Size of struct: 16

The memory occupied by Program 14.9 is shown in Figure 14.5:
Figure 14.5: Memory space occupied by the program 14.9
Nested structure
A nested structure refers to the concept of defining a structure within
another structure. It allows to creation of a hierarchical or nested structure
where one structure is a member of another. See the following program,
which accepts the person’s date of birth. The date of birth further includes
the day, month, and year:
// Program 14.10 accepts the date of birth using the nested structure
#include <stdio.h>
struct Date {
int day;
int month;
int year;
};
struct Person
{
char name[50];
struct Date dob; // Nested structure
};
int main()

{
struct Person person;
printf("Enter name: ");
scanf("%s", person.name);
printf("Enter the date of birth (DD MM YYYY):");
scanf("%d%d%d",&person.dob.day,&person.dob.month,
&person.dob.year);
printf("\nPersonal Details:\n");
printf("Name: %s\n", person.name);
printf("Date of Birth: %02d-%02d-%04d\n", person.dob.day,
person.dob.month, person.dob.year);
return 0;
}
Output:
Enter name: KAMALDEEP
Enter the date of birth (DD MM YYYY):05 07 1987
Personal Details:
Name: KAMALDEEP
Date of Birth: 5-7-1987
In the preceding program, we have two structures: Date and Person. The
Date structure represents a date with three integer members: day, month,

and year. The Person structure contains a character array name to store the
person’s name and a nested data structure dob to store the date of birth.
In the main() function, we create an object of the Person structure called
person. The first scanf() accepts the name and stores it in person.name. The
second scanf() asks to enter the date of birth and store it in person.dob.day,
person.dob.month, and person.dob.year. Finally, printf() displays the
entered information.
Passing structure in a function
To pass a structure as a function argument, you can use either call-by-value
or call-by-reference. The Program 14.11 shows both approaches:
// Program 14.11 shows the concept of passing structure using call-by-value
and call-by-reference
#include <stdio.h>
struct Point
{
int x;
int y;
};
void fun1(struct Point p) // Pass-by-value
{
printf("Co-ordinates in fun1: (%d, %d)\n", p.x, p.y);
p.x = 100; // Modifying the local copy doesn't affect the original structure
}

void fun2(struct Point* p) // Pass-by-reference (using pointers)
{
printf("Co-ordinates in fun2: (%d, %d)\n", p->x, p->y);
p->x = 100; // Modifying the pointed structure affects the original structure
}
int main()
{
struct Point P = {10, 20};
fun1(P);
printf("Modified values after pass-by-value: (%d, %d)\n", P.x, P.y);
fun2(&P);
printf("Modified values after pass-by-reference: (%d, %d)\n", P.x, P.y);
return 0;
}
Output:
Co-ordinates in fun1: (10, 20)
Modified values after call-by-value: (10, 20)
Co-ordinates in fun2: (10, 20)
Modified values after call-by-reference: (100, 20)
In the fun1, the struct Point argument is passed by value. A copy of the
structure is made, and any modifications made to it inside the function do

not affect the original structure in the main function.
In the fun2, the struct Point* argument is a pointer to the structure. Using
pointers, we can pass the address of the structure and modify its contents
directly. Any changes made to the pointed structure inside the function will
affect the original structure in the main function.
As you can see, call-by-value creates a local copy of the structure, whereas
call-by-reference allows you to modify the original structure. Choose the
appropriate method based on your requirements.
Conclusion
This chapter elaborates on structure and union, which are important
concepts in C programming for organizing and manipulating data. The
structure allows us to create custom data types that can hold multiple
variables of different types, providing a convenient way to represent real-
world entities. We can access structure members using the dot operator and
initialize structure using curly braces. Arrays of structure enable us to store
and process multiple related data elements efficiently. Pointers can be used
to access and modify structure members dynamically. On the contrary,
union enables us to store different data types in the same memory location,
conserving memory space. The nested structure allows us to create a
hierarchical data structure by including one structure within another.
Understanding these concepts is crucial for effective programming in C, as
they provide powerful data organization and manipulation tools.
The upcoming chapter will give the basic idea of searching and sorting.
Two popular techniques, linear and interval searching, will be discussed in
detail. The sorting techniques such as bubble, insertion, and selection sort
will also be discussed.
Points to remember
Both union and structure allow the grouping of multiple variables of
different data types into a single entity.
A structure is a user-defined data type containing variables of different
data types, known as members.

In a structure, each member has its own allocated memory space.
The members of a structure can be accessed using the dot operator (.).
The structure is commonly used to represent complex data structures
such as records, objects, or data packets.
A union is also a user-defined data type that can hold variables of
different data types, but all members share the same memory space.
Unlike structure, where each member has its own memory space, a
union allows only one member to be active at a time.
Changing the value of one member in a union will overwrite the
values of other members.
Union saves memory when different types of data need to be stored in
the same location.
Union is often used in low-level programming and when memory
efficiency is crucial.
The size of a union is determined by the largest member it contains.
The structure can be nested within other structures or unions, creating
complex hierarchical data structures.
Structure and union can be used with arrays, pointers, and other
advanced language features.
The structure can assign default values to its members, whereas unions
cannot.
The structure is commonly used for organizing related data, whereas
the union is used for scenarios where multiple data types share the
same memory space.
The members of a structure can have different sizes, whereas the
members of a union must fit within the union’s size.
Structure and union provide powerful tools for data organization,
manipulation, and memory management in programming languages.
Important questions
1. What is the difference between structure and union?
2. How do you declare a structure?
3. What is the purpose of using structure?
4. How do you access members of a structure?

5. Can a structure contain another structure as a member? If so, how?
6. What is the size of a structure in C? How is it calculated?
7. What are the advantages of using unions?
8. How do you declare and define the union?
9. Can a union contain members of different data types? Explain.
10. How do you access members of a union in C?
11. What is the size of a union in C? How is it determined?
12. What is the difference between structure and union with respect to
memory allocation?
13. How do you initialize a structure or union in C?
14. What are the limitations or restrictions of using union in C?
15. Can you give an example of a real-world scenario where structure and
union are used in C programming?
16. Explain the nested structure by taking a suitable example.

CHAPTER 15
Searching and Sorting
Introduction
This chapter is dedicated to the fundamentals of search and sorting algorithms.
These algorithms are the bedrock of computer science and play a vital role in
data processing. In the following sections, we will explore linear and binary
search techniques for finding elements efficiently. Additionally, we will delve
into sorting algorithms, including bubble sort, selection sort, and insertion sort,
which are crucial for organizing data effectively. These foundational concepts
are essential for any programmer to master.
Structure
In this chapter, we will be discussing the following topics:
Linear searching
Binary search
Sorting algorithms
Bubble sort
Selection sort
Insertion sort
Objectives

This chapter aims to provide a comprehensive understanding of key search and
sorting algorithms. Readers will learn the principles of linear and binary search,
enabling efficient data retrieval. Additionally, we will explore essential sorting
algorithms such as bubble sort, selection sort, and insertion sort, equipping
readers with valuable tools for organizing and processing data effectively in their
programming endeavors.
Searching
Searching is the process of finding the required element from an array or a list.
There are the following two types of searches:
Sequential search: It is a simple search method that searches in the array
of elements from the beginning to the end to find a specific key element
(the item to be found). It compares the key element in the list until a match
is found or the end of the array is reached. Linear search is an example of
a sequential search.
Interval search: It is designed to find key elements in the already sorted
data structures. It is much better than sequential search because it divides
the search space (list or array where the item is being searched) in half by
comparing the key element with the middle elements of the sorted array.
Based on the comparison, it reduces the search space to the lower and upper half
and continues the process until the key element is found or the search space is
empty. A binary search is a good example of an interval search.
Linear searching
Linear searching is the simplest searching technique. In this technique, the key
item is searched one by one with every other item in the array, starting from the
first place (index) to the last place (index), until the key item is found. This
procedure is also applicable to unsorted data. Linear search is also known as
sequential search.
In Figure 15.1, key item 23 is compared with the first indexed item, then the
second indexed item, and so on, until it matches the required item.

Figure 15.1: The linear searching
Algorithm for linear search
The following is the algorithm for linear search:
1. Start from the beginning of the list.
2. Compare the key item with the current item.
3. If the current item is equal to the key item, print ITEM FOUND and return the
current element’s index.
4. If the match is not found and the list has more items, then move to the
next item in the list and repeat Steps 2–4.
5. If the end of the list is reached without finding a match, print ITEM NOT
FOUND.
// Program 15.1 shows the implementation of the linear search
#include <stdio.h>
void main(void)
{
    int A[100] = { 10, 20, 30, 50, 40, 60, 70, 
80,90,100 };
    int key;
    int i, found=0;
    int n = 10;
    printf("Enter the Element to be searched\n");
    scanf("%d",&key);
    for (i = 0; i < = n; i++)

    {
        if (A[i] == key)
        {
        printf("Element is present at index %d", i);
        found=1;
        break;
        }
    }
    if(!found)
    {
     printf("Element is not present in the Array");
    }
}
Output:
Enter the element to be searched
30
Element is present at index 2
Binary search
It uses a sorted list of items for searching. It finds the middle element of the list
by repeatedly dividing the list or array into two halves: the upper and lower half.
If the middle element is equal to the key item, stop searching; otherwise, check
if the value of the item being searched (key) is less than that of the item in the
middle element; then the item will be on the lower half. Otherwise, the item will
be in the upper half, and the remaining half will be discarded. Furthermore, the
same steps are applied to the lower and upper half until the value is found or the
array is empty. Figure 15.2 shows the process of binary search.
Let us search the key item 30 in an array, as shown in Figure 15.2:

Figure 15.2: The procedure of searching in binary search
Algorithm for binary search
The following is the algorithm for binary search:
1. Initialize all variables: High=n-1, Low=0, found=0, n=size of the array.
2. While (Low<=High), repeat Steps 3–7.
3. Mid= (Low+High)/2.
4. Compare the element to be searched with the Mid.
5. If it matches with the Mid element, we return the Mid index, found =1, and
terminate the search.
6. Else if it is less than the mid element, then search it in the left half and
High=Mid-1.
7. Else if it is greater than the mid element, then search it in the right half
and Low=Mid+1.
8. If found=0, Print "Element is not in the array".
// Program 15.2 shows the implementation of binary search
#include <stdio.h>
void main()

{
    int A[] = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 
100};
    int i, mid, key, found=0;
    int n =10;
    int low=0;
    int high= n-1;
    printf("Enter the Element to be searched\n");
    scanf("%d",&key);
    while(low<=high)
    {
        mid=(low+high)/2;
        if(key==A[mid])
        {
        printf("Element is present at index %d", mid);
        found=1;
        break;
        }
        else if(key<A[mid])
        high=mid-1;
        else if (key>A[mid])
        low=mid+1;
    }     
     if(!found)

    {
     printf("Element is not present in the Array");
    }
}
Output:
Enter the element to be searched
100
Element is present at index 9
Sorting algorithms
The sorting algorithm arranges the elements either in ascending or descending
order. There are many algorithms for sorting; some of them are given as follows.
Bubble sort
It compares the element to its adjacent element at a time. If they are not in the
right order, it swaps them to make them in the right order. The largest element
bubbled up step by step. After completing one round, the largest element is
bubbled up (moved) to the end of the array. In the second round, the second
largest element moves its position, and so on. This cycle repeats until all the
elements reach their desired place. In every pass, place one element in its correct
position.
Algorithm
1. Take A[100], n, i, j, and temp;
2. Enter the number of elements in n.
3. Enter elements:
for (i = 0 ; i < n - 1; i++)
{
  for (j = 0 ; j < n - 1 - i; j++)
  {

    if(A[j] > A[j+1])
      swap A[j] and A[j+1] using temp 
  }
}
display A[i]
Look at the following example to sort A[50,20,10,30,40]. Let the variable i
represent the pass cycle, and j is the index of the array.
Pass 1
50    20    10    30    40            
20    50    10    30    40    i=0    j=0     
if(A[j]>A[j+1]) 
                                      swap A[j] and 
A[j+1]
20    10    50    30    40    i=0    j=1
20    10    30    50    40    i=0    j=2
20    10    30    40    50    i=0    j=3
The largest element, 50, has reached its final position.
Pass 2
20    10    30    40    50
10    20    30    40    50    i=1    j=0
10    20    30    40    50    i=1    j=1
10    20    30    40    50    i=1    j=2
The second largest element, 40, has reached its final position.
Pass 3
10    20    30    40    50
10    20    30    40    50    i=2    j=0

10    20    30    40    50    i=2    j=1
The third largest element, 30, has reached its final position.
Pass 3
10    20    30    40    50
10    20    30    40    50    i=3    j=0
The fourth largest element, 20, has reached its final position, and the final sorted
array is as follows:
10    20    30    40    50 
// Program 15.3 for bubble sort
#include <stdio.h>
void main()
{
  int A[100], n, i, j, temp;
  printf("Enter number of elements\n");
  scanf("%d", &n);
  printf("Enter %d integers\n", n);
  for (i = 0; i < n; i++)
    scanf("%d", &A[i]);
  for (i = 0 ; i < n - 1; i++)
  {
    for (j = 0 ; j < n - 1 - i; j++)
    {
      if (A[j] > A[j+1])
      {
        temp   = A[j];

        A[j]   = A[j+1];
        A[j+1] = temp;
      }
    }
  }
  printf("Sorted list in ascending order:\n");
  for (i = 0; i < n; i++)
     printf("%d\n", A[i]);
}
Output:
Enter the number of elements
5
Enter 5 integers
50
20
10
30
40
Sorted list in ascending order:
10
20
30
40
50

Selection sort
This sorting algorithm finds the minimum element in the array and swaps if
required (if the element is not in its correct location).
First, it selects the first element of the array, compares it with its adjacent
element, finds the minimum of two, assigns the min variable with the index of
the minimum element, and continues this process until the end of the array.
Finally, the selection sort will swap the first element of the array with the
element at the min index. After the first pass in the n-sized array, we get the
minimum element at index zero, and the remaining array n-1 elements are still
unsorted. Again, it finds the minimum element in the remaining unsorted array.
If it is found, swapping will be done again. After this pass, two elements get
sorted as the sorted array, and the n-2 elements are still unsorted. This process
keeps repeating until the entire array gets sorted.
Algorithm
1. Take a[100], n, i, j, min, temp;
2. Enter the number of elements in n
3. Enter elements:
for (i = 0 ; i < n - 1; i++)
{
  min=i;
    for (j = i+1 ; j < n; j++)
    {
      if (a[j] < a[min])
      {
         min=j;
      }
    }
    Swap a[i] and a[min] using temp;
  }

4. Display the sorted array.
// Program 15.4 shows the working of the selection sort
#include <stdio.h>
void main()
{
  int A[100], n, i, j, min, temp;
  printf("Enter the number of elements\n");
  scanf("%d", &n);
  printf("Enter %d integers\n", n);
  for (i = 0; i < n; i++)
    scanf("%d", &A[i]);
  for (i = 0 ; i < n - 1; i++)
  {
      min=i;
    for (j = i+1 ; j < n; j++)
    {
      if (A[j] < A[min])
        {
          min=j;
        }
    }
        if(i!=min)
        {
        temp   = A[i];

        A[i]   = A[min];
        A[min] = temp;
        }
    }
  printf("Sorted list in ascending order:\n");
  for (i = 0; i < n; i++)
     printf("%d\n", A[i]);
}
Output:
Enter the number of elements
5
Enter 5 integers
50
20
10
30
40
Sorted list in ascending order:
10
20
30
40
50
Let us take an example to sort the following elements:

50    20    10    30    40
Let the variable i represent the pass cycle, and j is the index of the array.
Pass 1
A[] = 50    20    10    30    40
50    20    10    30    40    i=0    j=1     min=1
50    20    10    30    40    i=0    j=2    min=2
50    20    10    30    40    i=0    j=3     min=2
50    20    10    30    40    i=0    j=4     min=2
10    20    50    30    40    min=2, swap A[min] and 
A[i]
After Pass 1, the 10 has reached its position.
Pass 2
10    20    50    30    40
10    20    50    30    40    i=1    j=2    min=1
10    20    50    30    40    i=1    j=3    min=1
10    20    50    30    40    i=1    j=4    min=1 no 
need of swapping as i==min
After Pass 2, the 10 and 20 have reached their positions.
Pass 3
10    20    50    30    40
10    20    50    30    40    i=2    j=3    min=3
10    20    50    30    40    i=2    j=4    min=3
10    20    30    50    40     min=3, swap A[min] and A[i]
After Pass 3, the 10, 30, and 20 have reached their positions.
Pass 4
10    20    30    50    40    i=3    j=4 min=3

10    20    30    40    50    min=4 swap A[min] and A[i]
10    20    30    40    50 sorted array
After Pass 4, all the elements have reached their positions.
Insertion sort
This algorithm inserts the element at its appropriate location. The algorithm
virtually divides the entire array into two parts: sorted and unsorted subarrays. It
picks the element from an unsorted array and inserts it at the appropriate place in
the sorted array.
The following steps are used for insertion sort to arrange an array A of size n in
ascending order:
1. Start checking from the array’s first to the last element.
2. The current element, temp, is compared to its antecedent.
3. If the temp is smaller, insert the temp before it and slide the bigger element
up to create space.
Algorithm
1. Take A[100], n, i, j, min, temp;
2. Enter the number of elements in n:
for (i = 1 ; i < n ; i++)
{
  temp=a[i];
  j=i-1;
  while(j>=0 && a[j]>temp)
  {
    A[j+1]=A[j];   // shifting the element right
    j=j-1;
  }
  A[j+1]=temp; // insert the element at right place

}
3. Display the sorted array.
Let us sort the following array using the insertion sort:
A[] = 50    20    10    30    40    temp=20
Pass 1
50    20    10    30    40     Since 20<50, 20 will 
be inserted before 50. Now, the array is 20    50    10    30    40 
The first two elements have been sorted, and the remaining are unsorted. So, the
array is logically divided into two subarrays; one is sorted, and the other is
unsorted.
Pass 2
20    50    10    30    40    Since 10<50, 10 will be inserted before 50, and 
50 is shifted right. 
20    10    50    30    40    Since 10<20, 10 will be inserted before 20, and 
20 is shifted right.
Now, the first three items have been sorted, and the remaining are unsorted. The
list is
10    20    50    30    40     
Pass 3
10    20    50    30    40    Since 30<50, 30 will be inserted before 50 and 
50 is shifted right. 
10    20    30    50    40    Since 30>20, no further swapping is required.
Now, the first four items have been sorted, and the remaining are unsorted. The
list after this step is as follows:
10    20    30    50    40     
Pass 4
10    20    30    50    40     Since 40<50, 40 will be inserted before 50 and 
50 is shifted right. Since 40>30, no further swapping is required.
Now, all the items have been sorted. The final list is as follows:

10    20    30    40    50
// Program 15.5 shows the implementation of the insertions sort
#include <stdio.h>
void main()
{
  int A[100], n, i, j, temp;
  printf("Enter the number of elements:\n");
  scanf("%d", &n);
  printf("Enter %d integers\n", n);
  for (i = 0; i < n; i++)
    scanf("%d", &A[i]);
  for (i = 0 ; i < n ; i++)
  {
      temp=A[i];
      j=i-1;
      while(j>=0 && A[j]>temp)
      {
          A[j+1]=A[j];
          j=j-1;
      }
    A[j+1]=temp;
  }
  printf("Sorted list in ascending order:\n");
  for (i = 0; i < n; i++)

     printf("%d\n", A[i]);
}
Output:
Enter the number of elements
5
Enter 5 integers
50
20
10
30
40
Sorted list in ascending order:
10
20
30
40
50
Conclusion
This chapter explored various searching and sorting algorithms. Sequential
search involves scanning through a list linearly, whereas interval search narrows
down the search space based on intervals. On the contrary, binary search
efficiently operates on sorted data by continually dividing the search space.
When it comes to sorting, bubble sort compares adjacent elements and swaps
them, whereas selection sort selects the smallest element iteratively. Insertion
sort builds a sorted portion by inserting elements from the unsorted portion.
Each algorithm has its advantages and limitations, and understanding their

characteristics will help in selecting the most appropriate one for specific
scenarios.
The upcoming chapter will explore the pointer and its application in various
fields of programming, like in the creation of self-referential structures, for
example, linked lists.
Points to remember
Searching is the process of finding the required element from an array or a
list.
The linear search searches in the array of elements from the beginning to
the end in order to find a specific key element (the item to be found).
Linear search is also applicable to unsorted data.
Interval search techniques are designed to find key elements in the already
sorted data structures.
In the bubble sort, the largest element is bubbled up (moved) to the end of
the array in one pass. In the second round, the second largest element
moves to its second last position, and so on.
The insertion sort algorithm inserts the element at its appropriate location.
The selection sort algorithm finds the minimum element in the array and
swaps if required (if the element is not in its correct location).
The binary search finds the middle element of the list by repeatedly
dividing the array into two halves, the upper and lower half.
Important questions
1. What is the basic concept of sequential search?
2. How does interval search differ from sequential search in terms of
efficiency?
3. Explain binary search by taking a suitable example.
4. What are the key steps involved in performing a binary search?
5. How does bubble sort work? Explain its algorithm by taking a suitable
example.
6. How does a selection sort differ from a bubble sort in terms of working?

7. Can sequential search be applied to both sorted and unsorted data?
8. What are the key requirements for binary search to work correctly?
9. Explain insertion sort by taking a suitable example with its algorithm.
10. Explain selection sort by taking a suitable example with its algorithm.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech happenings
around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 16Pointers
Introduction
This chapter is dedicated to the dynamic and essential concept of pointers
in programming. Pointers serve as a bridge to access and manipulate
memory directly, providing powerful capabilities to a programmer. In the
following sections, we will explore pointer initialization, operations, and
advanced topics such as pointer-to-pointer, NULL pointers, generic
pointers, arrays of pointers, and self-referential structures, all culminating
in the fascinating world of linked lists.
Structure
In this chapter, we will be discussing the following topics:
Initialization of pointer
Accessing the value
Operations on pointers
Pointer to a pointer
NULL pointer
Generic pointer
Pointer to an array
Array of pointers
Self-referential structure
Linked list
Objectives
The objective of this chapter is to provide a comprehensive understanding
of pointers in programming. Readers will learn how to initialize and
operate on pointers, explore advanced concepts such as pointer-to-pointer
and self-referential structures, and understand their applications in data
structures such as linked lists. This knowledge equips readers with essential
skills for effective memory management and dynamic data structures in
programming.

Pointer
The address of a variable can be stored in a specific kind of variable known
as a pointer.
Its declaration is similar to the declaration of a variable except for an
asterisk symbol (*) before the variable name. The following syntax can
declare the pointer:
datatype *ptr_name;
For example,
int *p;
The p is the pointer’s name and is proceeded by * (asterisk operator). The
pointer p will hold the address of the integer data type.
According to the data type of the variable, the pointer can be created as
follows:
int *p1;
double *p2;
float *p3;
The pointer p1 will hold the address of the integer, p2 will hold the address
of the double, and p3 will hold the address of the float data type.
Initialization of pointer
The pointer is initialized with the help of the address operator (&) followed
by the variable name. Look at the following syntax:
Ptr_name = &variable_name
For example,

P = &a;
Here, the address of a is assigned to the P pointer using &. The main
memory is divided into cells. Each cell has a name, value, and address, as
shown in Figure 16.1:
Figure 16.1: The memory allocation for variables and pointer
Here, the cell with the name a has address 1010 contains 20. The cell
having name b and address 1020 contains 30. Pointer P contains a’s
address.
Accessing the value
The value can be accessed using the asterisk symbol (*), also known as the
indirection operator, the value at the address, or the pointer operator.
Consider the following line of code:
int a=20;
int *P;
P = &a;
printf("%d",P); // Output: 1010, the address of a
printf("%d",*P); // Output: 20
printf("%d",*(&a)); // Output: 20, the value at address
// Program 16.1 prints the variable and its address using a pointer
#include <stdio.h>
void main()
{

int A; // Variable declaration
int *p; // Pointer declaration
A = 10; // Assigning value
p = &A; // Assigning address of A to p
printf("Assessing the value of A using pointer = %d\n", *p);
printf("Address of A = %d\n", A);
printf("Value of A = %d\n", A);
printf("The value at address = %d",*(&A));
}
Output:
Assessing the value of A using pointer = 10
Address of A = 10
Value of A = 10
The value at address = 10
Operations on pointers
The following arithmetic operations can be performed on the pointers:
Increment operation
Decrement operation
Addition of integer to the pointer
Subtraction of an integer from the pointer
Comparison using relational operators
Subtraction of two pointers

Notes:
A pointer cannot be multiplied by a constant.
Two pointer variables cannot be added.
Check the following program for more clarification:
// Program 16.2 elaborates different operations on the variable using a
pointer.
#include <stdio.h>
void main()
{
int A, B, C = 0;
int *p , *p1, *p2 ;
A = 10;
B = 20;
C = 30;
p = &A;
p1 = &B;
p2 = &C;
printf("Accessing the value of A using pointer = %d\n",*p);
printf("Address of A = %d\n",&A);
printf("Address at p = %d\n",p);

printf("Address of pointer p = %d\n", &p);
printf("Increment in variable A using pointer = %d\n",++(*p));
printf("Decrement in variable A using pointer = %d\n",--(*p));
printf("Adding integers using pointer = %d\n", *p1 + *p2);
printf("Subtracting integers using pointer = %d\n", *p2 - *p1);
printf("Multiplying integers using pointer = %d\n", *p2 * *p1);
printf("Dividing integers using pointer = %d\n", *p2 / *p1);
if (*p2 > *p1)
printf("A is greater than B");
else
printf("A is lesser than B");
}
Output:
Accessing the value of A using pointer = 10
Address of A = 6422028
Address at p = 6422028
Address of pointer p = 6422008
Increment in variable A using pointer = 11
Decrement in variable A using pointer = 10
Adding integers using pointer = 50

Subtracting integers using pointer = 10
Multiplying integers using pointer = 600
Dividing integers using pointer = 1
A is greater than B
// Program 16.3 elaborates on different operations on pointers
#include <stdio.h>
void main()
{
int A, B, C = 0;
int *p , *p1, *p2;
A = 10;
B = 20;
C = 30;
p = &A;
p1 = &B;
p2 = &C;
printf("Accessing the value of A using pointer=%d\n",*p);
printf("Address of A=%d\n",&A);
printf("Address at p=%d\n",p);
printf("Address of pointer p = %d\n",&p);

printf("Increment in pointer = %d\n",++p);
printf("Decrement in pointer = %d\n",--p);
printf("Accessing the value of B using pointer=%d\n",*p1);
printf("Address of B=%d\n",&B);
printf("Adding integers in pointer=%d\n",p1+5); /* Move pointer five
elements forward from the current position where one element is of four
bytes*/
printf("Subtracting integers in pointer=%d\n",p1-10); /* Move pointer ten
elements backward where one element is of four bytes */
printf("Subtracting operation on pointers=%d\n",p2-p1);
// printf("Multiplying is invalid=%d\n",p2*p1);
// printf("Dividing is invalid=%d\n",p2/p1);
// printf("Adding is invalid=%d\n",p1+p2);
if (p2>p1)
printf("A is greater than B");
else
printf("A is lesser than B");
}
Output:
Accessing the value of A using pointer=10
Address of A=6422028

Address at p=6422028
Address of pointer p = 6422008
Increment in pointer = 6422032
Decrement in pointer = 6422028
Accessing the value of B using pointer=20
Address of B=6422024
Adding integers in pointer=6422044
Subtracting integers in pointer=6421984
Subtracting operation on pointers=-1
A is lesser than B
Pointer to a pointer
It is also possible that a pointer is holding the address of another pointer, as
shown in Figure 16.2. So, a pointer to a pointer is a special type of pointer
containing another pointer’s memory address. It is also known as a double-
pointer or a pointer-to-pointer. The ** (double asterisk) operator is used in
its declaration. Look at the following example:
int a = 10;
int *P1 = &a;
int **P2 = &P1;
The preceding lines of code declare a variable a and a pointer P1 that holds
the address of a. The P2 is a pointer to a pointer that holds the address of
the pointer P1.

Figure 16.2: Pointer to a pointer
// Program 16.4 shows the pointer to a pointer
#include <stdio.h>
int main()
{
int A = 10;
int *P1 = &A; // Pointer to an integer
int **P2 = &P1; // Pointer to a pointer to an integer
printf("Value of A: %d\n", A); // Accessing A
printf("Value of *P1: %d\n", *P1); // Accessing A through P1
printf("Value of **P2: %d\n", **P2); // Accessing A through P2
return 0;
}
Output:
Value of A: 10
Value of *P1: 10
Value of **P2: 10
NULL pointer
It does not point to any valid address. The NULL is a pre-defined constant
in several header files, such as stdio.h, string.h, and so on. Generally, the

value of NULL is equal to 0. Hence, a pointer holding the NULL is known
as a NULL pointer. Some of the uses of the NULL pointer are as follows:
It is used to initialize a pointer variable when the pointer does not
point to a valid memory address.
It performs error handling in dynamic memory allocation, string, file
handling, and so on.
It is passed as a function argument and returned from a function when
we do not want to pass the actual memory address.
In terminating linked lists, NULL pointers are frequently used to
indicate the end of linked lists or other data structures.
Declaration and initialization of the NULL pointer is as follows:
int *p = NULL;
Generic pointer
A generic pointer is typically referred to as a void pointer. It is a special
type of pointer that can point to data of any type, which means it can store
the address of a variable that can hold any kind of data type. Its datatype is
void. It is often used when you need to work with data of unknown or
varying types. It is declared as follows:
void *p;
It can be typecasted to any data type. For example, the following statement
typecasts generic pointer p into an integer type. Now, it can hold the
address of the integer data type. Similarly, it can be typecasted into other
data types such as float, double, char, and so on.
*(int*)p // pointer p is being typecasted as an integer pointer
//Program 16.5 shows the use of the generic pointer
#include <stdio.h>
void main()

{
int a = 10;
float b = 20.5;
void *p; // Generic pointer
p = &a;
printf("The value of a using generic pointer=%d\n",*(int *)p);
p = &b;
printf("The value of a using generic pointer=%f",*(float *)p);
}
Output:
The value of a using generic pointer=10
The value of a using generic pointer=20.500000
// Program 16.6 prints the integer value of the NULL pointer using a
generic pointer
#include <stdio.h>
int main()
{
int *ptr = NULL;
printf("Pointer value: %d\n", (void *)ptr);
return 0;
}

Output:
Pointer value:0
Pointer to an array
A pointer to an array is a variable that holds the address of an array’s base
(first) element. When we declare an array, it occupies the consecutive space
in memory. 1000 is the base address of an array shown in Figure 16.3:
Figure 16.3: Memory occupancy by the array
Consider the following code:
int *p;
p = &a[0]; //pointer to an array
or
p = &a // Allocates the address of a to p
Figure 16.4 shows the pointer to an array:
Figure 16.4: Pointer to an array
Similarly, the pointer to the 2D array can be declared as follows:
datatype (*ptr)[columns];
In this context, datatype refers to the data type of the array elements,
whereas columns indicate the number of columns included in the 2D array.
Look at the following code:
int A[3][4]={ // 2D array

{1, 2, 3, 4},
{5, 6, 7, 8},
{9, 10, 11, 12}
};
int (*P)[4] //2D pointer declaration
P=A; // 2D pointer initialization
// Access elements using the pointer
printf("%d\n", *(*(P + 1) + 2)); // Output: 7
Note that when accessing elements through the pointer, we use the
dereference operator * twice to access the value of a specific element. For
example, *(*(ptr + 1) + 2) accesses the value at the second row, the third
column of the 2D array.
// Program 16.7 prints an array using a pointer
#include <stdio.h>
void main()
{
int a[] = {10,20 ,30, 40, 50};
int *p;
p = &a;
int i;
for(i = 0; i < 5; i++)

{
printf("The element on a[%d] is = %d\n",i, *p);
printf("The address of a[%d] element is = %d\n",i, p);
p++;
}
}
Output:
The element on a[0] is = 10
The address of a[0] element is = 6422016
The element on a[1] is = 20
The address of a[1] element is = 6422020
The element on a[2] is = 30
The address of a[2] element is = 6422024
The element on a[3] is = 40
The address of a[3] element is = 6422028
The element on a[4] is = 50
The address of a[4] element is = 6422032
Note: In the preceding program, when we perform p++, the value of p is
incremented by four because an integer consumes four bytes in the
memory. So, the value of the next variable is stored at the next four bytes.
In the case of float, it becomes eight bytes.

Array of pointers
It is an array that consists of pointers. These pointers hold addresses of
other elements like a variable, array, and so on. Suppose we create an array
of pointers holding three integer pointers; then, its declaration would look
like as shown in Figure 16.5:
int *P[3]; // array p of 3 integer pointer.
Figure 16.5: The array of pointers having three integer pointers
The array of pointers is initialized by providing the addresses of other
integer data types. Let us take an array of integer Num, which has three
elements.
int Num[3] = {1, 2, 3};
We can initialize the array of pointers by the elements of array Num like
the following:
P[0] = & Num[0];
P[1] = & Num[1];
P[2] = & Num[2];
It can also be initialized using a loop. Like the following:
for(int i=0;i<3;i++)
{
ptr[i] = &Num[i];
}
After initialization, it looks like as shown in Figure 16.6:

Figure 16.6: Array of pointers
// Program 16.8 enters ten elements in an array and prints them using an
array of pointers
#include <stdio.h>
void main()
{
int Num[10]; // integer array declaration
int *ptr[10]; // integer array of pointer declaration
printf("Enter ten numbers:");
for(int i=0;i<10;i++)
scanf("%d", &Num[i]);
for(int i=0;i<10;i++)
ptr[i]=&Num[i]; //initialization of array of pointer
printf("The values are:" );
for(int i=0;i<10;i++)
printf("%d ", *ptr[i]); // printing the values of Num array
}
Output:
Enter ten numbers:1 2 3 4 5 6 7 8 9 10
The values are: 1 2 3 4 5 6 7 8 9 10

Self-referential structure
A self-referential structure, also known as a recursive structure, is a
structure that contains a member that is a pointer to the same type of
structure. This allows the structure to reference itself and create complex,
hierarchical data structures.
The self-referential structure creates other important data structures, such as
linked lists, stacks, trees, graphs, and so on. The pointer member allows
linking an unspecified number of such structures.
The following syntax creates a self-referential structure having a name list
containing the data and address (pointer) members. This self-referential
structure is termed as a node. In the following code, the list is a node:
struct list
{
int data; \\ Data member
struct list *next; \\ Pointer member
};
The description of the node’s elements is given as follows:
data: This is an integer variable representing the data stored in the
node. It can hold any value of integer type.
next: This is a pointer member of type struct list*. It stores the next
node’s address. It connects the nodes in the list and makes a chain.
To help us understand and think about self-referential structures, as shown
in Figure 16.7:
Figure 16.7: A node

The following syntax will create three nodes, a, b, and c, and initialize them
by 10, 20, and 30, respectively.
struct list
{
int data;
struct list *next;
};
struct list a, b, c;
a.data = 10;
b.data = 20;
c.data = 30;
a.next = b.next = c.next = NULL;
Figure 16.8 is the visualization of the preceding code:
Figure 16.8: Three nodes having data and pointer
To link one node to another, the address of the next node is provided to the
pointer of the current node. Look at the following two statements:
a.next = &b;
b.next = &c;
Here, the node b’s address is assigned to a node’s pointer, and the node c’s
address is assigned to the pointer of the previous node b. Figure 16.9 is the
visualization of the preceding code:

Figure 16.9: Three linked nodes.
// Program 16.9 prints the element of the linked list
#include <stdio.h>
struct list
{
int data;
struct list *next;
};
int main()
{
struct list a, b, c; // Creation of three nodes
a.data = 10; // Assigns 10 to node 1
b.data = 20; // Assigns 20 to node 2
c.data = 30; // Assigns 30 to node 3
a.next = &b; // Assigns the address of node b to a
b.next = &c; // Assigns the address of node c to b
c.next = NULL; // Assigns the NULL to node c
// declare and initialization of the pointer current by the address of a
struct list *current = &a;

while (current != NULL)
{
printf("%d\t", current->data);
current = current->next; // Assigned the address of next node
}
return 0;
}
Output:
10 20 30
Now, we can use the links to retrieve data from successive elements.
a.next->data //Has a value of 20
The preceding statement will access the data of the second node using the
object and the pointer of node one. A node may hold more than one data
member. Look at Figure 16.10:
Figure 16.10: Three nodes having two data fields and one address field
each
// Program 16.10 creates three nodes having two data fields and one address
field #include <stdio.h>
struct node
{
int data1, data2;

struct node *next;
};
int main()
{
struct node ob1; // Node1
// Initialization
ob1.next = NULL;
ob1.data1 = 10;
ob1.data2 = 20;
struct node ob2; // Node2
// Initialization
ob2.next = NULL;
ob2.data1 = 30;
ob2.data2 = 40;
struct node ob3; // Node3
// Initialization
ob3.next = NULL;
ob3.data1 = 50;
ob3.data2 = 60;
// linking ob1 and ob2

ob1.next = &ob2;
// linking ob2 and ob3
ob2.next = &ob3;
// Accessing data members of ob2 using ob1
printf(" 1st element of node 1:%d", ob1.next->data1);
printf("\n 2nd element of node 1:%d", ob1.next->data2);
// Accessing data members of ob3 using ob2
printf("\n 1st element of node 2:%d", ob2.next->data1);
printf("\n 2nd element of node 2:%d", ob2.next->data2);
return 0;
}
Output:
1st element of node 1:30
2nd element of node 1:40
1st element of node 2:50
2nd element of node 2:60
Linked list
A linked list is a type of structure comprising a series of nodes, each of
which holds a piece of data and a reference (or pointer) to the next node in
the list. It is called a linked list because these pointers link the nodes, as
shown in Figure 16.11:

Figure 16.11: A three-noded linked list
The last node in the list has a pointer that points to NULL, indicating the
end of the list, and the starting node has a pointer named Head. The
following code is an example of a linked list:
struct Node
{
int data;
struct Node* next;
};
The struct Node defines the structure of each node in the linked list. It
contains two members: data to store the data element and next to store a
pointer to the next node.
To create a linked list, you would typically define a pointer to the first
node, often called the Head of the list. Look at the following statement:
struct Node *Head = NULL;
The Head pointer is initially set to NULL, indicating an empty list.
To add nodes to the linked list, you would dynamically allocate memory for
each node using the malloc function, assign the data value, and update the
next pointer to link the nodes together. A detailed description of the
malloc() function will be provided in Chapter 19: File Handling in C, under
the section Dynamic memory allocation.
// Program 16.11 creates a 3-node linked list, enters the value, and prints
them.
#include <stdio.h>

#include <stdlib.h>
struct Node
{
int data;
struct Node* next;
};
int main()
{
struct Node* head = NULL;
// Create the first node by allocating memory to it by malloc function
struct Node* node1 = (struct Node*)malloc(sizeof(struct Node));
node1->data = 10;
node1->next = NULL;
head = node1;
// Create the second node by allocating memory to it by malloc function
struct Node* node2 = (struct Node*)malloc(sizeof(struct Node));
node2->data = 20;
node2->next = NULL;
node1->next = node2;
// Create the third node by allocating memory to it by malloc function

struct Node* node3 = (struct Node*)malloc(sizeof(struct Node));
node3->data = 30;
node3->next = NULL;
node2->next = node3;
// Traverse and print the linked list
struct Node* current = head;
while (current != NULL)
{
printf("%d ", current->data);
current = current->next;
}
return 0;
}
Output:
10 20 30
// Program 16.12 inputs n numbers in the linked list and prints the same.
#include <stdio.h>
#include <stdlib.h>
struct Node
{

int data;
struct Node* next;
};
int main()
{
struct Node* head = NULL;
int n, value;
printf("Enter the number of elements: ");
scanf("%d", &n);
printf("Enter the elements:\n");
for (int i = 0; i < n; i++)
{
scanf("%d", &value);
struct Node* newNode = malloc(sizeof(struct Node));
newNode->data = value;
newNode->next = head;
head = newNode;
}
printf("Linked List: ");
while (head != NULL)

{
printf("%d ", head->data);
head = head->next;
}
printf("\n");
return 0;
}
Output:
Enter the number of elements: 5
Enter the elements:
1 2 3 4 5
Linked List: 5 4 3 2 1
Conclusion
This chapter discussed pointers that are used for efficient memory
manipulation and implementation of complex data structures. It covered
various aspects, including declaration, initialization, and accessing values
through dereferencing. Operations like arithmetic and addressing using
pointers were discussed, along with the concept of a pointer to a pointer for
multiple indirection levels. It also talked about how important NULL
pointers are and how flexible generic pointers are. It looked at how pointers
work with arrays, including arrays of pointers, and how they work in
structures that refer to themselves, like linked lists. Understanding and
using pointers in C is crucial for memory management and advanced
programming.

The upcoming chapter will focus on the inbuilt input-output function of the
console. The two types of input and output functions, formatted and
unformatted, will be discussed in detail.
Points to remember
Pointers are variables that store memory addresses as their values.
Pointers allow direct access to memory locations, enabling efficient
memory manipulation.
Pointers are declared using an asterisk (*) before the variable name,
such as int *ptr.
Initialization of a pointer involves assigning the address of a variable
using the address-of operator (&), like ptr = &variable.
Dereferencing a pointer is done using the asterisk (*) operator,
allowing access to the value stored at the memory address pointed to
by the pointer.
Pointers can pass data by reference to functions, allowing
modifications to the original variable.
Dynamic memory allocation in C uses pointers and functions such as
malloc() and free().
Pointer arithmetic allows incrementing or decrementing pointers and
performing arithmetic operations on them.
Pointers can be used to access arrays, where the pointer holds the base
address of the array.
Pointers to pointers (double pointers) are used for multiple levels of
indirection, allowing the manipulation of pointers themselves.
A NULL pointer is a special pointer value that points to no memory
location.
A generic pointer is able to store the address of a variable that can
store any kind of datatype. It is declared as void *p.
Pointers can be used to implement data structures such as linked lists,
trees, and graphs.
Important questions
1. What is a pointer?
2. How do you declare a pointer variable?

3. How do you initialize a pointer variable?
4. What is the difference between a pointer and a variable?
5. How do you access the value pointed to by a pointer?
6. What is the dereferencing operator?
7. How do you assign a value to the memory location pointed to by a
pointer?
8. How do you find the memory address of a variable?
9. What is the significance of the NULL pointer?
10. Explain the generic pointer.
11. What is the difference between a NULL pointer and an uninitialized
pointer?
12. What is the relationship between arrays and pointers?
13. What is the concept of pointer arithmetic?
14. What is a void pointer in C, and how is it different from other pointer
types?
15. What are the potential risks and pitfalls associated with using
pointers?
16. What do you understand by self-referential structures? Explain by
taking a suitable example.
17. How can you use pointers to implement data structures like linked
lists?
Join our book’s Discord space

Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 17
The Console Input-output
Functions
Introduction
This chapter dives into the world of input and output functions in C
programming. These functions are the cornerstone of communication
between your program and the user, making them indispensable. In the
upcoming sections, we will explore how to use printf() and scanf() for
formatted input and output, along with other functions such as getch(),
getchar(), and puts(). We will also discuss techniques like fflush(stdin)
for effective I/O handling, empowering you to create interactive and
responsive C programs.
Structure
In this chapter, we will be discussing the following topics:
printf()
scanf()
getch(), getche(), and putch()
getchar() and putchar()
fgetchar() and fputchar()

gets() and puts()
Use of fflush(stdin)
Objectives
This chapter aims to provide a comprehensive understanding of input and
output functions in C programming. Readers will learn how to use printf()
and scanf() for formatted input and output, along with other essential
functions such as getch(), getchar(), puts(), and techniques like
fflush(stdin) to handle input and output effectively. This knowledge equips
readers with the skills to create interactive and user-friendly C programs.
The console input–output functions
The output statements display data on the screen or write the data to a printer
or file, whereas the input functions read the data from the keyboard or the
file. The monitor screen and the keyboard are collectively known as the
console. This chapter will discuss only the console input-output (I/O)
functions. The file I/O functions will be discussed in Chapter 19: File
Handling in C.
C language provides many built-in console functions. All these built-in
functions are specified in header files. Before using the functions, we must
include the concerned header files in the program. For example, the
printf() and scanf() functions are defined in stdio.h. So, we must include
it in the program when we use these functions.
The input and output functions are categorized into two categories, as shown
in Figure 17.1.
Formatted I/O functions
Unformatted I/O functions

Figure 17.1: Formatted and unformatted input–output functions
Formatted output function: The output functions control the
appearance and arrangement of data, making it easier to work with and
understand. For example, printf() is a formatted output function. It
displays output to the standard output (console) or a file. It uses format
specifiers to specify the data type and format of the output.
Formatted input function: Formatted input functions read data from
the user in a specific format. The scanf() is a formatted input
function. It is used to read input from the standard input (keyboard). It
uses format specifiers to specify the data type and format of the input.
Unformatted output functions: Unformatted output functions are
used to write data to the screen as it is. It does not require any
formatting. For example, these functions cannot insert space, newline,
tab, and so on between output variables. Functions such as putch(),
putchar(), and puts() are unformatted output functions.
Unformatted input functions: They read the data as it is without any
formatting. Some commonly used unformatted input functions in C
include getch(), getche(), getchar(), and gets().
printf()

The printf() function is used for formatted output. It is part of the standard
input/output library (stdio.h) and is used to display formatted data on the
output console. The name printf stands for print formatted. The following
statement shows its syntax:
printf("format_string", list_of_variables);
The format_string contains the following items:
Character or string that is printed as they are.
Format specifiers that begin with % symbol: See Chapter 6:
Fundamental of C for more details.
Escape sequence that begins with \ symbol, for example, \n and \t:
See Chapter 6: Fundamental of C for more details.
Format specifiers are preceded by the % character and define the data type
and formatting options for the corresponding argument. Some commonly
used format specifiers include %d, %u, %f, and so on.
Formatting options can be added to the format specifiers to control the
appearance and arrangement of the output. Some commonly used formatting
options include the following:
Width: Specifies the minimum field width for the output. For
example, %5d will allocate at least five fields for the integer.
Precision: Tells about the number of digits after the decimal point for
floating-point numbers. For example, %.2f will display the number
with two decimal places.
Flags: Provide additional formatting options such as adding, leading
zeros, and justification. For example, %04d will add the integer with
leading zeros.
The following program illustrated printf() with different format specifiers
and formatting options:
//Program 17.1 illustrates printf() with different format specifiers 
and formatting options
#include <stdio.h>

int main() 
{
    int num = 10;
    float pi = 3.14159;
    char letter = 'A';
    char name[] = "John";
    printf("Number: %d\n", num);        // Output: 
Number: 10
    printf("Pi: %.5f\n", pi);           // Output: 
Pi: 3. 14159
    printf("Letter: %c\n", letter);     // Output: 
Letter: A
    printf("Name: %s\n", name);         // Output: 
Name: John
    return 0;
}
Output:
Number: 10
Pi: 3.14159
Letter: A
Name: John
// Program 17.2  demonstrates the  printf() to print the output with 
the desired number of spaces
#include<stdio.h>
int main()

{
int   a=8;
printf("%d\n", a);  // prints the value of a.
printf("%10d\n", a);// consumes 10 spaces and right 
justified
printf("%-5d", a);  // consume 5 space and left 
justified
printf("%d", a);    // prints the value of a
return 0;
}
Output:
8
         8
8    8
The following program demonstrates printf() to print the output with the
desired number of spaces for float value:
// Program 17.3 demonstrates the printf() to print the output with 
the desired number of spaces for float values
#include<stdio.h>
int main()
{
float   a=8.5430;
printf("%f\n", a);  // prints the value of a.
printf("%10.2f", a); //Consumes ten spaces, two for 
the digit after decimal and right justified

return 0;
}
Output:
8.543000
      8.54
The following program demonstrates the printf() print of the output with
the desired number of spaces for float value:
// Program 17.4 demonstrates the printf() print of the output with 
the desired number of spaces for float values
#include<stdio.h>
int main()
{
float   a=8.543;
printf("%f\n", a);
printf("%10.2f\n",a); //right justified
printf("%-10.2f",a); //left justified
return 0;
}
Output:
8.543000
      8.54
8.54
scanf()

The scanf() function takes input from a keyboard. The parenthesis contains
the list of format specifiers enclosed in double quotes ("") and the list of
variables, which are preceded by the ampersand operator (&) and separated
by a comma. The name scanf stands for scan formatted. The following
statement shows the syntax of the scanf() function:
scanf("format_string", 
list_of_addresses_of_variables);
The format_string contains the following items:
The format specifiers begin with the % symbol.
The escape sequences begin with the \ symbol.
For example:
// use to enter a variable of integer data type
int a;
scanf("%d", &a);  
// use to enter two variables of integer and float 
data type, respectively
int a;
float b;
scanf("%d %f", &a, &b); 
The addresses of the variable are provided to the scanf() function using the
address operator (&). Because the values from the keyboard go to these
addresses, a newline, a blank space, or a Tab must be used to insert the
values from the keyboard.
Limitations of scanf()
The scanf() function has some limitations also, which are as follows:
Difficulty in handling whitespace: By default, scanf() uses
whitespace (spaces, tabs, and newlines) to input values. This can make
it challenging to read input that includes whitespace characters.

Buffer overflows: scanf() does not perform bounds checking when
reading strings with the %s format specifier. If the user enters a string
longer than the size of the destination buffer, it can result in a buffer
overflow, leading to undefined behavior.
Limited error handling: The scanf() function does not provide
robust error handling capabilities. If the user enters unexpected input,
it does not match the specified format specifiers.
Uses enter key to digest values: scanf() needs an enter key after
entering all the values.
getch(), getche(), and putch()
Let us now discuss these functions in detail:
getch(): It is used to input a single character without pressing the
Enter key. It is defined in conio.h header file. It is important to note
that getch() is not part of the standard C library and may not be
available on all compilers.
putch(): It is used to print a single character. It is generally used with
getch().
The following program enters and prints a character using getch() and
putch():
// Program 17.5 enters and prints a character using getch() and 
putch()
#include <stdio.h>
#include <conio.h> // For Windows systems
int main() 
{
    char ch;
    printf("Press any key to continue...");

    ch = getch();
    printf("\nYou pressed: %c\n", ch);
    return 0;
}
Output:
Press any key to continue...
You pressed: A
getche(): It is used to input a single character without pressing the
Enter key. Its e at the end represents an echo. It echoes (displays) the
character which has been entered using it.
The following program enters and prints a character using getche()
and putch():
// Program 17.6 enters and prints a character using getche() 
and putch()
#include<stdio.h>
#include<conio.h>
void main()
{
  char ch;
  printf("Enter a character:\n");
  ch=getche();
  printf("\nThe character is:\n");
  putch(ch);
}

Output:
Enter a character:
A
The character is:
A
getchar() and putchar()
Let us now discuss these functions in detail:
getchar(): It inputs a single character by pressing an Enter key at the
end. It echoes the character which has been entered using it.
putchar(): It is used to print a single character. It is used against
getchar().
The following program enters and prints a character using getchar() and
putchar():
// Program 17.7 enters and prints a character using getchar() and 
putchar()
#include<stdio.h>
#include<conio.h>
void main()
{
  char ch;
  printf("Enter a character:\n");
  ch=getchar();
  printf("The character is:\n");
  putchar(ch);

}
Output:
Enter a character:
A
The character is:
A
fgetchar() and fputchar()
Let us now discuss these functions in detail:
fgetchar(): It is used to input a single character by pressing an enter
key at the end. It is similar to getche() but requires an Enter key. It
echoes the character which has been entered using it. The difference
between getchar() and fgetchar() is that getchar() is a macro, and
fgetchar() is a function.
fputchar(): It is used to print a single character. It is used against
fgetchar().
The following program enters and prints a character using fgetchar() and
fputchar():
// Program 17.8 enters and prints a character using fgetchar() and 
fputchar()
#include<stdio.h>
#include<conio.h>
void main()
{
  char ch;
  printf("Enter a character:\n");

  ch=fgetchar();
  printf("The character is:\n");
  fputchar(ch);
}
Output:
Enter a character:
A
The character is:
A
The following program prints characters using putch(), putchar(), and
fputchar():
// Program 17.9 prints character using  putch(),putchar(), 
fputchar().
#include<stdio.h>
#include<conio.h>
void main()
{
  putch('A');
  putchar('B');
  fputchar('C');
}
Output:
The characters are:
ABC

gets() and puts()
Let us now discuss these functions in detail:
gets(): It accepts a string. It also accepts a white space between the
strings, whereas the scanf() cannot accept the white spaces between
strings. It is present in the string.h header file.
puts(): It prints a string on the screen. It is used with gets().
The following program accepts and prints string using gets() and puts():
//Program 17.10 accepts and prints string using gets() and puts()
#include<stdio.h>
#include<string.h>
void main()
{
  char A[10];
  printf("Enter a string:\n");
  gets(A);
  printf("The string is:\n");
  puts(A);
}
Output:
Enter a string:
kamal deep
The string is:
kamal deep 
The following program accepts and prints string using scanf() and printf():

//Program 17.11 accepts and prints string using scanf() and printf()
#include<stdio.h>
#include<string.h>
void main()
{
  char A[10];
  printf("Enter a string:\n");
  scanf("%s",A);
  printf("The string is:\n");
  printf("%s",A);;
}
Output:
Enter a string:
Kamal Deep
The string is:
Kamal
Note: In the output, the string after the space is not considered by the
scanf().
Use of fflush(stdin)
When we enter the values from the keyboard, it goes into the stdin buffer,
which is temporary storage. The scanf() picks the value from the buffer and
assigns it to the variable, as shown in Figure 17.2. Look at Program 17.12:
// Program 17.12 to print an integer and a character

#include<stdio.h>
void main()
{
  char A;
  int B;
  printf("Enter an integer\n");
  scanf("%d",&B);
  printf("Enter a character:\n");
  scanf("%c",&A);
  printf("The values are:%d,%c",B,A);
}
Output:
Enter an integer
10
Enter a character:
The values are:10
The previous Program 17.12 does not accept the character’s value after the
integer value because when we enter the integer and hit the Enter key, the
integer and the ASCII value of the Enter key go to the stdin buffer. The
scanf function assigns the 10 to B and the ASCII value to A, as shown in
Figure 17.2:

Figure 17.2: The stdin buffer and scanf()
So, to clear the stdin and remove the \n from the buffer, we use
fflush(stdin) after printing the integer, as shown in Program 17.13 and
Figure 17.3:
Figure: 17.3: The stdin buffer after using fflush(stdin)
// Program 17.13 to print an integer and a character using 
fflush(stdin)
#include<stdio.h>
void main()
{
  char A;

  int B;
  printf("Enter an integer\n");
  scanf("%d",&B);
  fflush(stdin);
  printf("Enter a character:\n");
  scanf("%c",&A);
  printf("The values are:%d,%c",B,A);
}
Output:
Enter an integer
10
Enter a character:
A
The values are10,A
Conclusion
This chapter covers console input-output functions, including formatted I/O
functions such as printf() and scanf(). These functions provide control
over input and output formatting. However, scanf() has limitations, such as
difficulty in handling incorrect input and the need for precise formatting.
Additionally, basic functions such as getch(), getche(), putch(), getchar(),
putchar(), fgetchar(), and fputchar() allow for simple character-based
console operations. Understanding and using these functions enables
programmers to create efficient and user-friendly console-based applications
The upcoming chapter will explain the preprocessor directives in detail. It
includes various types of preprocessing directives such as file inclusion
directives, macro expansion directives, conditional directives, and various
directives.

Points to remember
Console input–output functions are essential for interacting with the
user through the console.
Formatted I/O functions, such as printf() and scanf(), allow precise
control over input and output formatting.
Unformatted I/O functions provide basic console input and output
operations.
printf() is used to display formatted output, allowing for a structured
and visually appealing presentation of data.
printf() supports various formatting options, including specifying
field width, precision, and alignment.
scanf() is used for formatted input, allowing the program to extract
data from user input.
scanf() can be used to read different data types, such as integers,
floats, characters, and strings.
scanf() can encounter issues when the user provides unexpected or
invalid input, leading to incorrect program behavior.
scanf() has limitations, including difficulty in handling whitespace,
buffer overflows, limited error handling, and using the enter key to
digest values.
getch(), getche(), and putch() are functions for reading individual
characters from the keyboard and displaying characters on the screen.
getchar() reads a single character from the keyboard, whereas
putchar() displays a character on the screen.
fgetchar() reads characters from a file for console input, whereas
fputchar() displays characters on the screen from a file.
getchar() and putchar() are commonly used for simple character-
based console operations.

getch() reads a character from the keyboard without displaying it,
which is useful for password input.
getche() reads a character from the keyboard and displays it, which is
useful for immediate feedback to the user.
putch() displays a character on the screen.
fgetchar() and fputchar() provide similar functionality to getchar()
and putchar() but operate on file input and output streams.
Important questions
1. What is the main console input-output functions in programming
languages?
2. How do formatted I/O functions differ from unformatted I/O
functions?
3. What is the purpose of the printf() function?
4. How does the scanf() function handle user input?
5. What are some limitations and challenges associated with using
scanf()?
6. What are the differences between getch(), getche(), and getchar()
functions?
7. How can getchar() and putchar() functions be used for console
input–output?
8. What is the role of fgetchar() and fputchar() in console operations?
9. How can printf() be used to format and display data?
10. What are some common formatting options available in printf()?
11. How does scanf() interpret and process different data types?
12. What are the alternatives to scanf() for more robust input handling?
13. How can getch() be used to read individual characters from the
keyboard?
14. In what scenarios would getche() be preferred over getch()?

15. How can putch() be used to display characters on the screen? Explain
by taking an example.
16. What is the purpose of getchar() in console-based applications?
17. How does putch() differ from putchar() in terms of functionality?
18. How can fgetchar() be used to read characters from a file for console
input?
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 18Preprocessor
Introduction
This chapter will delve into the critical role of preprocessor directives in C
programming. The following sections will explore various preprocessor
directives, including file inclusion, macro expansion, conditional, and
undefined.
Structure
In this chapter, we will be discussing the following topics:
Preprocessor directives
File inclusion directives
Macro expansion directives
Conditional directives
Undefined directives
Objectives
The objective of this chapter is to provide a comprehensive understanding
of preprocessor directives in C programming. Readers will learn how to use
file inclusion, macro expansion, conditional compilation, and undefined
directives.
Preprocessor
As the name suggests, the preprocessor is a program that processes our
source code before compilation. It begins with the hash (#) symbol.
Preprocessor directives
Preprocessor directives are the preprocessor commands. They begin with
the hash (#) symbol. No semicolon is placed at the end of the preprocessor
declaration.

Figure 18.1 shows the working of the preprocessor. The editor writes the
source code. Before the source code is passed to the compiler, the
preprocessor first checks for any directives. If it is present in the program,
it will be processed, and the result in the form of the expended source file is
passed to the compiler. This expanded source code passes to the compiler,
and the compiler generates the object code:
Figure 18.1: The preprocessor working
There are the following types of directives:
File inclusion directives
Macro expansion directives
Conditional directives
Undefined directives
File inclusion directives
This directive includes a file, for example, a header file in the source code.
It uses #include before the file name to be included. Its syntax is given as
follows:
#include<filename>
For example,
#include<stdio.h>
It includes a stdio.h header file in the program. It searches a filename into a
standard list of system directories. The name of the file must be written in
an angular bracket.
Macro expansion directives
The #define is used to write the macro in the program. The name of the
macro must be written in capital letters. Before understanding the concept
of macro, analyze the following program.

//Program 18.1 finds the area of a circle using macro
#include<stdio.h>
#define PI 3.141592
void main()
{
float area, r;
printf("Enter the value of radius:");
scanf("%f",&r);
area=PI*r*r;
printf("The area of a circle is:%f",area);
}
Output:
Enter the value of radius: 3
The area of a circle is 28.274328
In the preceding program, PI is the macro name (macro template), and the
value 3.141592 is the macro expansion. When the preprocessor encounters
#define in a program, it searches for all the macro templates in the entire
program and replaces (substitutes) them with macro expansion.
So, a macro defines a symbolic name. The macro name gets substituted by
the macro expansion before the actual compilation of the code begins; for
example, the statement area=PI*r*r becomes area=3.141592 *r*r after the
replacement.

We can also pass the variable to the macro like a function. Analyze the
following program:
//Program 18.2 passes the variables to the macro
#include<stdio.h>
#define AREA(x) (3.141592*x*x)
void main()
{
float r, a;
printf("Enter the value of radius:");
scanf("%f",&r);
a=AREA(r);
printf("The area of a circle is:%f", a);
}
Output:
Enter the value of radius: 3
The area of a circle is: 28.274328
Note: No blank space between AREA and (x)
The macro expansion, that is, (3.141592*x*x), must be enclosed with
parenthesis.
The difference between macro and function

Table 18.1 shows the difference between the macro and the function:
Macro
Function
Its expansion occurs during the
preprocessing phase. It is a
preprocessor directive entity.
Functions are compiled entities.
The compiler time errors are not
detected as they are processed before
passing to the compiler.
It checks compile-time errors.
Macros can lead to code duplication
because the macro name gets
substituted with its value at every
occurrence, potentially increasing the
size of the compiled code.
Functions promote code reusability.
They can be defined once and
called multiple times from different
parts of the program. This reduces
code duplication.
Macros do not perform type-checking
since they are purely textual
substitutions; that is, arguments in
macros are not evaluated for their
types.
Functions perform type-checking.
The types of arguments passed to a
function are checked against the
function’s parameter types.
In some cases, the execution time is
less than the function.
Execution time is more in function.
The macro name is replaced with the
macro value before the compilation.
A transfer of control from calling to
called function takes place.

It is useful when small code is used
many times.
It is useful when large code is to be
used several times.
Macros do not have a return value.
Functions can have a return type.
Table 18.1: Macro versus function
Conditional directives
Conditional directives includes or excludes certain sections of code based
on specific conditions defined during the preprocessing stage. The two
main conditional directives are as follows:
#ifdef and #endif
#if and #elif
#ifdef and #endif
#ifdef and #endif are preprocessor directives that are used to conditionally
include or exclude sections of code based on the existence of a specific
preprocessor macro or symbol in the program. Its syntax is as follows:
#define macro_name
void main()
{
#ifdef macro_name
Statement 1;
Statement 2;
…………………………….
Statement N;

#endif
}
If the macro_name is defined in the program, the block of code will be
executed; otherwise, it will be skipped. The #endif marks the end of the
block. Have a look at the following program.
// Program 18.3 implements the #ifdef and #endif
#include<stdio.h>
#define macro1
void main()
{
#ifdef macro1
printf( "HEY!\n" );
#endif
#ifdef macro2
printf( "Hello!\n" );
#endif
}
Output:
HEY!
Note: macro2 is not defined in the program, so it is skipped.
#if and #endif

The #if and #endif directives include or exclude certain sections of code
during the compilation process based on specific conditions.
#if provides a condition that is evaluated by the compiler. If the condition is
true (non-zero), the code following #if is included for compilation. If the
condition is false, that code is skipped. The #endif directive marks the end
of the conditional block. It works in the same way as the else if ladder.
Look at the following program for more clarification:
// Program 18.4 illustrates the use of #if and #endif
#include<stdio.h>
#define NUM 1
void main()
{
#if NUM < 1
printf( "Hello 1!\n" );
#elif NUM < 2
printf( "Hello 2!\n" );
#else
printf( "Hello 3!\n" );
#endif
}
Output:
Hello 2!

Undefined directives
It is used to remove the definition of a previously defined macro. For
example, #undef is an undefined directive.
#undef
The #undef directive is used to undefine or remove the definition of a
previously defined macro. Read the following code:
#define PI 3.14159
//code that uses PI
#undef PI
// PI macro is now undefined
//code that no longer uses PI
The #define directive defines the macro PI and assigns it the value 3.14159.
The code follows #define PI 3.14159 will use it. The #undef directive is
used to remove the PI macro. This means that any code after the #undef PI
directive can no longer use the PI macro:
// Program 18.5 illustrates the use of #undef directive
#include <stdio.h>
#define PI 3.14159
int main()
{
//code that uses PI
double radius = 5.0;

double circumference= 2*PI*radius;
printf("The circumference of a circle=%f\n",circumference);
#undef PI
// PI macro is now undefined
//code that no longer uses PI
//double area = PI*radius*radius; the statement will not work here
//printf("The area of a square=%.2f.\n",area);
return 0;
}
Output:
The circumference of a circle=31.42
In the preceding program, the #undef directive is used to remove the PI
macro. Any code following the #undef PI directive can no longer use the PI
macro.
Conclusion
This chapter gives the details of preprocessing. The preprocessor provides
directives allowing file inclusion, macro expansion, conditional
compilation, and macro undefinition. The #include directive includes files,
enabling modular code organization. Macro defined using #define offers
textual substitution, whereas #undef removes macro definitions.
Conditional directives such as #ifdef, #endif, #if, and #elif control code
inclusion based on conditions.
The upcoming chapter enables the readers to deal with files, including
various operations on the file. Moreover, it elucidates the concept of

dynamic memory allocation with the help of various functions such as
malloc(), calloc(), realloc(), and free().
Points to remember
The preprocessor in C is a tool that performs various manipulations on
the source code before compilation.
Preprocessor directives are instructions to the preprocessor, specified
by the # symbol at the beginning of a line.
File inclusion directives (#include) are used to include the contents of
other files into the current source file.
Macro expansion directives, such as #define, allow defining macros
for textual substitution.
Macro expansion can be done using object-like macros (#define) or
function-like macros (#define with arguments).
Conditional directives, such as #ifdef, #endif, #if, and #elif, control
the compilation of code sections based on conditions.
Undefined directives (#undef) remove the definition of a previously
defined macro.
The #include directive commonly includes standard library headers or
user-defined header files.
#ifdef checks if a macro is defined and includes the following code
block if true, whereas #endif marks the end of the block.
The #if directive evaluates a constant expression and includes the
following block if the expression is true.
The #elif directive is used in conjunction with #if to specify additional
conditions like else if ladder.
Macros are expanded by the preprocessor, whereas functions are
compiled and executed during runtime.
Macros do not perform type-checking, which can lead to unexpected
behavior if not used carefully.
Functions provide modularity, code reusability, and type safety
compared to macros.
Important questions
1. What is the purpose of the preprocessor?

2. How are preprocessor directives identified in the source code?
3. What is the role of the file inclusion directive (#include)?
4. How does the #define directive facilitate macro expansion?
5. What are conditional directives? Explain by taking a suitable example.
6. How do #ifdef and #endif directives work together for conditional
compilation?
7. What is the purpose of the #if directive? How can you specify
additional conditions using the #elif directive?
8. What is the significance of the #undef directive?
9. How are header files typically included using the #include directive?
10. What are some common uses for macros?
11. What is the difference between macro expansion and function
execution?
12. What are the potential risks of using macros without careful
consideration?
13. How do functions provide advantages over macros?
14. How can preprocessor directives affect the size of the source code?
15. What are some best practices when using preprocessor directives?
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com


CHAPTER 19
File Handling in C
Introduction
This chapter explores the world of file handling and memory allocation in C
programming. Files are essential for data storage and retrieval, and
understanding how to manipulate them is a fundamental skill. In the
following sections, we will discuss the significance of files, types of files,
and operations performed using inbuilt functions. Additionally, we will
delve into dynamic memory allocation techniques using the functions such
as malloc(), calloc(), free(), and realloc(), which are crucial for
efficient memory management in your programs.
Structure
In this chapter, we will be discussing the following topics:
File
Need of the file
Types of file
Operations on file through the inbuilt functions
Opening a file
Reading a file

Closing a file
Deleting a file
Memory allocation
malloc()
calloc()
free()
realloc()
Objectives
This chapter aims to provide a comprehensive understanding of file
handling and memory allocation in programming. Readers will learn the
importance of files, different file types, and how to perform operations on
files using inbuilt functions. Additionally, the chapter covers memory
allocation techniques using the functions such as malloc(), calloc(),
free(), and realloc(), equipping readers with essential skills for effective
data management and memory optimization in their programs.
File
A collection of related data stored in a secondary storage device, such as a
hard disk, is known as a file. File handling is a fundamental concept used to
store and retrieve information from a file on external storage.
File handling in C involves creating, opening, reading, writing, and closing
files. The file-handling operations in C are facilitated through a file pointer
and a set of functions provided by the standard library.
Need of the file
The program’s output is usually received on the monitor screen. Sometimes,
displaying the data on the monitor screen is not enough. The data displayed
may be very large, and the screen size is limited. Because the memory
(RAM) is volatile, it is unsuitable for storing data permanently. The file
overcomes these limitations. A file can be used to store the data

permanently that may be used in the future. The file is stored in the
secondary memory like a non-volatile hard disk. We can access the stored
file whenever it is required.
Types of files
Generally, C processes the following two types of files which are as
follows:
Text files: Text files contain human-readable text data. Characters in
the file are represented using the ASCII encoding. Text files are
typically created and edited using text editors. The text files are
processed using functions such as fopen(), fprintf(), fscanf(),
fgets(), and fputs().
Binary files: Binary files store data in a binary format, which means
they can contain any type of data, including non-textual data such as
images, audio, video, and so on. Binary files are used when the exact
representation of data is of utmost importance. The binary files are
processed using functions such as fread(), fwrite(), and fseek().
Operations on file through the inbuilt functions
With the inbuilt function in the stdio.h header file, we can do the following
things with the file.
Creation of a file: To operate on a file, we have to create it first. A
file is created by fopen() function.
Opening a file: A file can also be opened using fopen() function,
similar to file creation. Opening a file allows one to read or modify
its contents.
Reading a file: The file data can be read using functions such as
fscanf() or fgets(). These functions retrieve data from the file and
store it in variables for further processing.
Writing a file: The data can be written in a file using functions like
fprintf() or fputs().

Closing a file: After we finish working with a file, it is essential to
close it using the fclose(). This step ensures that all system
resources occupied by the file are freed.
Deleting a file: The remove() is used to delete the file.
Opening a file
A file is created by the fopen(). It takes two arguments: one is the filename
(including the path) to be created and the mode in which the file should be
opened (for example, w for write mode, r for read, a for append, w+ for
writing, reading, and modifying, r+ for read, write and modify the existing
file, and a+ for reading, adding new content at the end, and so on).
See the following example:
FILE *fp;
fp=fopen("sum.c", "r");
The sum.c file will be opened in reading mode (r) and set a pointer fp that
points to the first character of the file. It is declared by FILE *fp. The
pointer fp is of type pointer to FILE. If the file does not open for any
reason, such as the file being corrupted, disk unavailability, and so on, the
fp returns NULL.
The working of the fopen() is given by the following steps:
1. It looks for the file you want to open.
2. It retrieves the file from the disk and puts it into a temporary memory
called a buffer in RAM.
3. It assigns the address of the first character to the file pointer, as
shown in Figure 19.1.
4. If it is impossible to open the file, the pointer will return a NULL.
Reading a file
The fgetc() is used to read a character from the current position using the
pointer used in fopen(). See the following example

ch = fgetc(fp);
It reads the character in variable ch, and the pointer fp is incremented by
one. If the pointer returns an EOF, it means no more character is left to read.
An EOF, which is a macro, is defined in stdio.h header file. The EOF
character is placed at the end of the file, representing the end.
Look at Figure 19.1, which contains a disk having two files, Abc.txt and
sum.c. A buffer in RAM holds all the characters of Abc.txt and terminates
with an EOF character. A character pointer fp is pointing to the first
character.
Refer to Figure 19.1:
Figure 19.1: File on secondary memory
Closing a file
After finishing all the tasks, the file must be closed to free the resources
occupied by the file. The following example is given to close the file:
fclose(fp);  
It closes a file having a pointer fp.
Deleting a file
The remove() function deletes the file specified in its parameter. This
function can be found in the stdio.h file. Look at Program 19.7 for its

work. Consider the following statement:
int d = remove("abc.c");
where abc.c is the file name we want to delete. If the deletion succeeds, it
returns zero; otherwise, it is a non-zero value.
// Program 19.1 opens a file in read mode and displays its content 
on the output screen
#include<stdio.h>
void main()
{
  FILE *fp;
  char ch;
  fp=fopen("sum.c","r");
  while(1)
  {
    ch=fgetc(fp);
    if(ch==EOF)
      break ;
    printf("%c",ch);
  }
  fclose (fp) ;
}
Output:
The content of the file sum.c gets printed if it exists. 

To see the result, make a sum.c file in the current working directory (folder),
add some text, and then run the program. The program will display the text
of the file on the screen
// Program 19.2 copies the content of one file into another
#include <stdio.h>
#include <stdlib.h>        //for exit(0) function
void main()
{
    FILE *fp1,*fp2;
    char c;
    // Open one file for reading
    fp1=fopen("source.c","r");
    if(fp1==NULL)
    {
        printf("Cannot open file");
        exit(0);
    }
    fp2=fopen("target.c", "w"); // creates if not 
exists
    if(fp2==NULL)
    {
        printf("Cannot open file");
        exit(0);
    }

    // Read contents from the file
        while (1)
    {
        c = fgetc(fp1); // read one character from 
source file
        if(c==EOF)      // check end of the file
            break;
        else
            fputc(c,fp2);// write one character at 
destination file
    }
    fclose(fp1);
    fclose(fp2);
  }
Output:
The content of the file sum.c is copied into the target.c by 
creating it
The content of the file sum.c is copied into the target.c by creating it.
// Program 19.3 counts the number of characters, white spaces, 
tabs, and new lines or numbers of lines
#include <stdio.h>
#include <stdlib.h>
int main()
{

    FILE *fp;
    char c;
    int 
characterCount=0,spaceCount=0,lineCount=0,tabCount
=0;
    fp=fopen("source.c", "r");
    if(fp==NULL)
        {
        printf("Cannot open file");
        exit(0);
        }
    while((c=fgetc(fp))!=EOF)
        {
        characterCount++;
        if (c == ' ')
            spaceCount++;
        if (c == '\n')
            lineCount++;
        if (c == '\t')
            tabCount++;
        }
    fclose(fp);
}

Output:
The number of Characters:6
The number of Blank Spaces:0
The number of Lines:1
The number of Tabs:0
// Program 19.4 creates a file 'abc.c' and enters the text into a 
file using fprintf()
#include <stdio.h>
main()
{
   FILE *fp;
   fp = fopen("abc.c", "w+");
   fprintf(fp,"HELLO");
   fclose(fp);
}
Output:
The program creates a file abc.c and prints HELLO 
in it.
// Program 19.5 creates a file 'abc.c' and enters the text into a 
file using fputs()
#include <stdio.h>
main()
{
   FILE *fp;

   fp = fopen("abc.c", "w+");
   fputs("HELLO", fp);
   fclose(fp);
}
// Program 19.6 creates a file 'abc.txt' and enters the text into a 
file
#include<stdio.h>
void main()
{
    FILE *fp;
    char name[20];
    int age;
    float salary;
    /* open for writing */
    fp = fopen("abc.txt", "w");
    if (fp == NULL)
    {
        printf("File does not exist.\n");
        return;
    }
    printf("Enter the name:\n");
    scanf("%s", name);
    fprintf(fp, "Name:%s\n", name);

    printf("Enter the age:\n");
    scanf("%d", &age);
    fprintf(fp, "Age:%d\n", age);
    printf("Enter the salary:\n");
    scanf("%f", &salary);
    fprintf(fp, "Salary:%f\n", salary);
    fclose(fp);
}
Output:
Enter the name:
KAMAL
Enter the age:
30
Enter the salary:
10000
The program creates a file abc.c and writes the 
above details in abc.c.
// Program 19.7 deletes a file 'abc.txt'. 
#include<stdio.h>
void main()
{
   int d = remove("abc.c");
   if (d==0)

      printf("The file is deleted successfully");
   else
      printf("The file is not deleted");
}
Memory allocation
Memory allocation is the process of reserving the memory for a program to
store variables, constants, structures, and so on.
The two methods of memory allocation in C are as follows:
Static memory allocation refers to the allocation of memory for
variables during compile-time or program startup. Once the memory
is allocated, it cannot be increased. For example, the array uses a
static memory allocation technique. We have to tell the compiler, in
advance, about the requirement of the memory. The following
statement allocates ten consecutive integer type spaces statically in an
array a.
int a[10];
Dynamic memory allocation refers to the allocation of memory for
variables at runtime. Dynamic memory allocation generally uses four
inbuilt functions, which are present in stdlib.h. They are malloc(),
calloec(), realloc(), and free().
malloc()
The malloc stands for memory allocation. It allocates memory at run
time(dynamically). The memory allocated by malloc() contains garbage
values. So, it is the duty of the programmer to initialize it. If malloc() fails
to allocate memory, it returns NULL. Generally, it is written as follows:
cast_type* ptr;
ptr = (cast_type*) malloc(n * sizeof(data_type));

Where:
ptr is a pointer of cast_type data type.
malloc() is a function name.
n is the number of memory blocks of data_type type.
sizeof() is the size of the operator to calculate the size of data_type
and returns the size in bytes.
It accepts one argument in the form n * sizeof(data_type), which is
the total space to be allocated. The user gives the value of n at run
time. The value of n is multiplied by the size datatype.
For example:
int* ptr;
ptr = (int*) malloc(10 * sizeof(int));
This statement dynamically allocates the space equal to the size of 10
integers. On successful execution of the statement, the address of the first
location is assigned to the ptr pointer. If it is unable to allocate memory,
the ptr is assigned by a NULL pointer.
// Program 19.8 calculates the sum of n numbers entered by the user 
using the malloc function
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int *ptr;
    int n, i, sum = 0;
    printf("Enter the number of elements: ");
    scanf("%d", &n);

    ptr = (int*) malloc(n * sizeof(int));
    if(ptr == NULL)  // if memory cannot be 
allocated
    {
        printf("Error! Memory not allocated.");
        exit(0);
    }
    printf("Enter elements: ");
    for(i = 0; i < n; i++)
    {
        scanf("%d", &ptr[i]);
        sum = sum + *(ptr + i);
    }
    printf("Sum = %d", sum);
    free(ptr); // free the space allocated by 
malloc()
    return 0;
}
Output:
Enter the number of elements: 5
Enter elements: 1
3
5

7
9
Sum = 25
calloc()
The calloc stands for contiguous allocation. It also allocates memory at run
time (dynamically). By default, it initializes allocated memory to zero. If it
fails to allocate memory, it returns NULL. Generally, it is written as follows:
cast_type* ptr;
ptr = (cast_type*) calloc(n, sizeof(data_type));
Where:
ptr is a pointer of cast_type.
malloc() is a function name.
n is the number of memory blocks of data_type type.
sizeof() is the size of the operator to calculate the size of data_type.
It accepts two parameters: n and sizeof(data_type).
For example:
int* ptr;
ptr = (int*) calloc(10, sizeof(int));
This statement dynamically allocates the space equal to the size of 10
integers. On successful execution of the statement, the address of the first
location is assigned to the ptr pointer. If it is unable to allocate memory, the
ptr is assigned by a NULL pointer.
// Program 19.9 calculates the sum of n numbers entered by the user
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int *ptr;     
    int n, i, sum = 0;
    printf("Enter the number of elements: ");
    scanf("%d", &n);
    ptr = (int*) calloc(n , sizeof(int));
    if(ptr == NULL)  // if memory cannot be 
allocated
    {
        printf("Error! memory not allocated.");
        exit(0);
    }
    printf("Enter elements: ");
    for(i = 0; i < n; i++)
    {
        scanf("%d", &ptr[i]);
        sum = sum + ptr[i];
    }
    printf("Sum = %d", sum);
    free(ptr); // free the space allocated by 
calloc()
    return 0;

}
Output:
Enter the number of elements: 5
Enter elements: 1
2
3
4
5
Sum = 15
free()
The system itself frees the space allocated by static memory allocation, but
in the case of dynamically allocated memory, it has to be free by the user.
So, the free() function is used to free the space occupied dynamically. Its
syntax is as follows:
free(ptr);
ptr is a pointer used in malloc() and calloc().
realloc()
The realloc stands for re-allocation. The realloc() function resizes or
reallocates dynamically allocated memory blocks. It allows us to increase or
decrease the previously allocated space. It takes two arguments: a pointer
and the new size in bytes that you want to allocate. It accepts two
parameters, as shown in syntax. The general syntax is given as follows:
ptr = realloc(ptr, n * sizeof(data_type));
Where:
ptr is a pointer used in malloc() or calloc().
realloc() is a function name.

n is the number of memory blocks of type data_type.
sizeof() is the size of the operator to calculate the size of data_type.
For example:
int *ptr;
ptr = realloc(ptr, n * sizeof(int));
// Program 19.10 calculates the sum of n numbers entered by the 
user
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int n, n1, i, *ptr, sum=0;
    printf("Enter number of elements: ");
    scanf("%d",&n);
    ptr = (int*) calloc(n,sizeof(int));
    if(ptr==NULL)  // if memory cannot be 
allocated
    {
        printf("Error! memory not allocated.");
        exit(0);
    }
    printf("Enter elements: ");
    for(i=0;i<n;i++)
    {

        scanf("%d",&ptr[i]);
        sum = sum +ptr[i];
    }
    printf("Sum = %d",sum);
    printf("\nEnter the new size: ");
    scanf("%d",&n1);
    //Reallocating the memory
    ptr = realloc(ptr,n1*sizeof(int));
    printf("Enter some more elements: ");
    for(i = 0;i<n1;i++)
    {
        scanf("%d",&ptr[i]);
        sum = sum+ptr[i];
    }
    printf("Sum=%d",sum);
    free(ptr); // deallocating
    return 0;
}
Output:
Enter the number of elements:4
Enter elements:1
2
3

4
Sum=10
Enter the new size:5
Enter some more elements:1
2
3
4
5
Sum=25
Conclusion
This chapter explored file handling in C, covering text and binary files and
the inbuilt functions for operations such as opening, closing, reading, and
writing files. It also discussed memory allocation techniques, including
static and dynamic allocation. Dynamic allocation was further explained
through functions such as malloc(), calloc(), free(), and realloc().
The next chapter will introduce the concept of space and time complexity to
measure the performance of the algorithms. It also discusses asymptotic
notations such as Big-Oh, Big Omega, and Theta.
Points to remember
A collection of related data stored in a secondary storage device, such
as a hard disk, is known as a file.
Text files contain human-readable text data, whereas binary files store
data in a binary format.
Static memory allocation allocates space at compile-time.
Dynamic memory allocation allocates space during runtime.

The malloc() is used to allocate space dynamically. By default, it
initializes allocated memory to a garbage value. If it fails to allocate
memory, it returns NULL.
The calloc() is used to allocate space dynamically. By default, it
initializes allocated memory to zero. If it fails to allocate memory, it
returns NULL.
The malloc stands for memory allocation, The calloc stands for
contiguous allocation, and the realloc stands for re-allocation.
The free() function is used to free the space occupied dynamically.
The realloc() function resizes or reallocates allocated memory
blocks dynamically by increasing or decreasing their size.
Important questions
1. What is a file? Why is it needed?
2. How can you differentiate between text files and binary files?
3. How to open a file in C using the fopen() function? Explain.
4. What is the purpose of the fclose() function?
5. Explain different operations on file using inbuilt functions.
6. What is static allocation in memory management? How is it
performed in C?
7. Explain the dynamic allocation of memory in C.
8. What is the purpose of the malloc() function?
9. How does the calloc() function differ from malloc()?
10. What does the free() function do in memory management?
11. How can you resize or reallocate memory blocks using realloc()?
12. Explain the benefits of using buffers in file-handling operations.

CHAPTER 20
Time and Space Complexity
Introduction
This chapter delves into the fundamental concepts of algorithm analysis and
asymptotic notation. In the world of computer science, understanding how
algorithms perform in terms of time and space is paramount. We will explore
essential notations such as Big-Oh, Omega, and Theta, highlighting their
significance. By the end of this chapter, you will be equipped to measure the
time and space complexity of algorithms and comprehend the interplay
between these asymptotic notations, paving the way for efficient algorithm
design and evaluation.
Structure
In this chapter, we will be discussing the following topics:
Algorithm analysis
Asymptotic notation
Big-Oh
Omega
Theta
Why Big-Oh?

Measuring the time complexity
Measuring the space complexity
Relationship between the Big-Oh asymptotic notations
Time complexity
Space complexity
Objectives
This chapter aims to provide a comprehensive understanding of algorithm
analysis and asymptotic notation. Readers will learn how to assess algorithm
efficiency using Big-Oh, Omega, and Theta notations and the importance of
these notations. This chapter also covers measuring time and space
complexity, the relationship between asymptotic notations, and how to
analyze algorithm performance. This knowledge equips readers with
essential skills for designing and evaluating efficient algorithms.
Algorithm
An algorithm is a series of steps to complete a particular task or solve a
particular problem. Algorithms are used in various fields, including
computer science, mathematics, engineering, and everyday problem-solving.
In computer science, algorithms are particularly important for writing
computer programs.
It is a systematic approach to problem-solving, providing a clear and
unambiguous sequence of operations that, when followed, leads to the
desired outcome.
A better algorithm has the following characteristics:
Well-defined steps: An algorithm must have precisely defined and
unambiguous steps that are clear and understandable steps.
Finiteness: An algorithm must end after a finite time.
Input: An algorithm receives input.
Output: An algorithm produces an output.

Deterministic: It should produce the same output for the same input
every time it is executed.
Effectiveness: It should solve the problem. Every step should have
some purpose.
Feasibility: Implementing the algorithm using available resources
such as time, memory, and computational power should be possible.
Correctness: It should produce the correct output for all valid inputs.
Optimality: It should achieve the best possible solution in terms of
time and memory usage. An optimized algorithm is more efficient
than an unoptimized one. So, the optimized algorithm is always
preferred over unoptimized.
Algorithm analysis
It is a study that tells an algorithm’s efficiency. The efficiency is calculated
in terms of the time and space the algorithm takes to solve a particular
problem. The technical terms for analyzing the time and space taken by an
algorithm are time and space complexity, respectively.
Why algorithm analysis?
Let us analyze the following two programs, which calculate the sum of n
numbers. The question is: which one is better?
//Program 20.1 calculates the sum of two numbers using a loop
#include<stdio.h>
void main()
{
  double sum, n,i;
  printf("Enter the value of n:");
  scanf("%lf",&n);
  sum=0;

  for(i=0;i<n;i++)
  {
    sum=sum+i;
  }
printf("The sum is:%lf",sum);
}
Output:
Enter the value of n:10000000000
The sum is:49999999990067864000.000000
//Program 20.2 calculates the sum of two numbers using a formula
#include<stdio.h>
void main()
{
  double sum, n,i;
  printf("Enter the value of n:");
  scanf("%lf",&n);
  sum=0;
  sum=(n*(n-1))/2;;
  printf("The sum is:%lf",sum);
}
Output:
Enter the value of n: 10000000000
The sum is: 49999999994999996000.000000

When we execute these programs, the first program takes more time than the
second. So, the second program is more efficient. There should be some
mechanism to measure the program’s efficiency and select the better one.
The following are the key points that tell why there is a need for algorithm
analysis:
Algorithm selection: Algorithm analysis helps in choosing the most
appropriate algorithm for a problem before implementing it as a
program.
Performance prediction: Through algorithm analysis, we can
estimate an algorithm’s running time and memory usage before
actually implementing it.
Efficiency evaluation: Algorithm analysis tells the effectiveness of
different algorithms in the form of time and space complexity.
Design improvement: Algorithm analysis enables us to identify areas
for improvement in the design and implementation of an algorithm.
Scaling behavior: Algorithm analysis helps understand algorithms’
performance as the input size grows. This knowledge is crucial for
handling large-scale problems efficiently.
Research and innovation: Algorithm analysis is fundamental in
computer science research and innovation. It provides a basis for
developing new algorithms, improving existing ones, and advancing
the theoretical understanding of algorithmic efficiency.
The method for expressing an algorithm’s time and space complexity is
known as asymptotic notation.
Asymptotic notation
It is a representation that tells how the performance of an algorithm changes
as the input size gets larger without the execution of the program. Using
asymptotic notations, we can measure an algorithm’s best, average, and
worst cases, described as follows:
The best-case scenario describes the shortest possible time an
algorithm can take to execute for a given input size. It is also known

as the lower bound.
The worst-case scenario represents the maximum time an algorithm
can take to execute for a given input size. It is also known as the upper
bound.
The average case describes the exact time an algorithm will take to
run for a given input size. It is also known as tight bound.
Generally, three notations are used in asymptotic: Big-Oh, Omega, and
Theta.
Big-Oh
It represents the maximum time an algorithm can take to execute for a given
input size. It is used to represent the worst case. It is represented by O,
pronounced as Big-Oh. The time complexity of O(n) signifies that an
algorithm’s running time grows in a linear manner with the input size but not
faster than that.
Let n is the input to an algorithm. T is the time taken to solve the problem. If
f(n) is an input function, and C is a constant, then g(n) relates to f(n) by
equation (1). The time and space taken by the algorithm are always positive,
so f(n) and g(n) are always positive. The value of the constant C is affected
by variables such as CPU speed, memory size, programming language, and
so on. Refer to Figure 20.1:

Figure 20.1: Relationship between f(n) and g(n)in Big-Oh
Figure 20.1 depicts that after a certain value of k, C, the g(n) will always be
greater than f(n).
f(n) = O g(n) 
    Eq.(1) 
Equation (1) may be read asf of n is Big–oh of g of n. It can also be
written by Equation (2) by inserting a constant C:
f(n)<=C.g(n)        Eq.(2)
Equation (2) holds true for every n, where n>=k
such that
C > 0,
n >= k,
k >= 0
Here, C and k are the two positive constants in which the value of C is always
greater than 0(Zero), that is, C > 0, and the value of k may or may not be

larger than 0, that is, k >= 0.
Example 1: Find k and C for the function f(n) = n+10 and g(n) = n.
As f(n) = O g(n)
Also, f(n) <= C.g(n)
Put the value of the function.
So, (n+10)<=C.n Eq. (1)
To satisfy this equation, let us choose
C = 1 and n = k = 0 and put these values in preceding Equation (1), then
0+10 <= 1*0
10<=0, this condition is not satisfied.
Let us choose C = 2, n = k = 10 then equation (1) become as follows:
20<=20
So for C = 2 and k >= 10, the function g(n) will always be greater than
f(n), as shown in Figure 20.1, and the function f(n) in terms of Big-oh is
represented as follows:
(n+10) = O(n)
Example 2: Represent f(n) = 3n2 + n + 10 and g(n) = n2 in big-oh
As we know, f(n) <= C.g(n) Eq. (1)
(3n2 + n + 10) <= C.(n2)
Now to satisfy preceding equation, consider C = 5, n = k = 2, and put in
preceding Equation (1)
12+2+10 <= 5*4 
24<=20,
Condition is not satisfied. So, consider for C = 5, now take n = 3 = k = 3.
By putting the values in Equation (1). we get the following:
40<=45, 

So for C = 5 and n > = 3
(3n2 + n + 10) <= C.(n2) or we can say:
(3n2 + n + 10) = O(n2) 
How to choose the value of C and k?
Replace all the terms within the expression with the highest degree term
(dominating term); the expression 3n2 + n + 10 can be written as 3n2 + n2 +
n2. Sum up all the terms which will result 5n2. The coefficient of this term is
5. So, take the value of C as 5. Now the expression (3n2 + n + 10) =
O(n2)can be written as (3n2 + n + 10) <= 5.(n2) as per definition of Big-
Oh.
For n=1, the expression becomes as follows:
(3.12 + 1 + 10) <= 5.(12)
14 <= 5, which is not true
For n=2
(3.22 + 1 + 10) <= 5.(22)
23 <= 20, which is not true
For n=3
(3.32 + 1 + 10) <= 5.(32)
38 <= 45, which is true
From n=3 onwards, the value of f(n) will always be less than equal to
C.g(n), so choose this as the value of k=5.
Omega
It represents the algorithm’s lower time (minimum or at least) limit to solve
a problem. It represents the best case. It describes the shortest possible time
an algorithm can take to execute for a given input size. It is represented by
omega (Ω). Refer to Figure 20.2:

Figure 20.2: Relationship between f(n) and g(n)in Omega
Figure 20.2 depicts that after a certain value of k, C, the g(n) will always be
less than f(n). It can be expressed by Equations (1) and (2).
f(n) = Ω g(n)        Eq.(1)
f(n)> = C.g(n)    Eq.(2)
Equation 2 holds true for every n, where n>=k
such that
C > 0
n >= k
k >= 0
Example 3: Express the function f(n)= 3n2 + n in omega.
We need to find the g(n). Choose g(n) = n2 because it is the dominating
term in f(n)= 3n2 + n. As per the definition of omega:
f(n) >= C.(n2) put C=3
3n2 + n >= 3n2  Eq.1

n >= 3n2 - 3n2
n >= 0
Check by putting n=2
3.22 + 2 >= 3.22
14 >= 12
So for all the values of n >= 0 and C = 3, the condition 3n2 + n >= 3n2
holds true, so we can choose the value of k as equal to n. The function in
terms of omega is written as follows:
f(3n2 + n)= Ω g(n2)
Theta
It represents the exact time the algorithm takes to solve a problem. It is used
to represent the average case. It tells us about the exact rate at which the
algorithm will run as the input size grows. It is represented by theta (Θ).
Refer to Figure 20.3:

Figure 20.3: Relationship between f(n) and g(n)in Theta
Figure 20.3 depicts that after a certain value of k, C. The f(n) will always lie
between C2.g(n) and C1.g(n). It is expressed by equation (1).
Θ.g(n) <= f(n) <= Θ.g(n)         Eq.(1)
For C1 and C2, it can also be written as follows:
C1.g(n) <= f(n) <= C2.g(n) 
for all n >= k.
Example 4: Express the f(n)= 3n2 + n in theta
To represent f(n) = 3n2 + n in theta notation, we need to find two constant
values, C1, C2, and k, such that:
C1 * g(n) <= f(n) <= C2 * g(n) for all n >= k,
where g(n) represents a simpler function.
Let us analyze the function f(n) = 3n2+ n.
Lower bound:
We need to find a function g(n) such that C1 * g(n) <= f(n) for all n >= k.
Choosing g(n) = n2 should work. So, we have the following:
C1 * n2 <= 3n2 + n.
Simplifying, we get the following:
C1 <= 3 + 1/n.
As n moves toward infinity, 1/n approaches 0(zero), so we can ignore it.
Thus, we can choose C1 = 3.
Upper bound:
We need to find g(n) such that f(n) <= C2 * g(n) for all n >= k. Choosing
g(n) = n2 should work. So, we have the following:
3n2 + n <= C2 * n2.
Simplifying, we get the following:
3 + 1/n <= C2.

As n moves towards infinity, 1/n approaches 0, so we can ignore it. Thus,
we can choose C2 = 4.
Therefore, we have found C1 = 3 and C2 = 4, and we can choose k = 1.
Hence, express f(n) = 3n2 + n in Θ (theta) notation as follows:
f(n) = Θ(n2) 
Let us check by putting n=2 in C1 * g(n) <= f(n) <= C2 * g(n)
3.22 <= 3.22+2 <= 4.22
12 <= 14 <= 16,
Which is a true condition.
Why Big-oh?
Big-Oh notation is commonly preferred over other asymptotic notations
because of the following reasons:
Simplicity: Big-Oh notation provides a simple way to describe an
algorithm’s upper bound or worst-case behavior. It explains how the
algorithm’s performance scales with the input size, allowing for easy
comparison and analysis.
Emphasis on the upper bound: It emphasizes the upper bound. It
assures that the algorithm will not perform worse than a certain rate,
allowing us to make informed decisions about its scalability and
resource requirements.
Standardization: Computer science has adopted Big-Oh notation as a
standard notation. It is widely used and understood, making it simpler
for researchers, developers, and students to compare the efficiency of
different algorithms.
Measuring the time complexity
Time complexity measures the algorithm’s growth rate of time based
on input size. For instance, in Big-oh time complexity, O(n) indicates that an
algorithm’s execution time changes linearly with the size of the input n. The

execution time will nearly double as the input size does. Common time
complexity classifications include the following:
O(1): Constant time complexity: Despite the input size, the
algorithm completes in a consistent time. Accessing an array element
by an index is an example.
O(log n): Logarithmic time complexity. The input size has a
logarithmic effect on the time, for example, in binary search.
O(n): Linear time complexity. The running time grows linearly with
the input size. For example, iterating through an array to find a
specific element.
O(n log n): Log-linear time complexity. The running time grows
linearly multiplied by the logarithm of the input size. For example,
efficient sorting algorithms like merge sort and quicksort.
O(n2): Quadratic time complexity. The running time grows
quadratically with the input size. For example, nested loops iterate
over a 2D array.
O(2n): Exponential time complexity. The running time grows
exponentially with the input size. For example, generating all subsets
of a set.
It is important to note that time complexity analysis estimates how an
algorithm’s performance scales with the input size but does not give
information about the actual running time in seconds.
Measuring the space complexity
Similar to time complexity, space complexity is also expressed using Big-oh
notation. It helps in understanding how the memory usage of an algorithm
grows as the input size increases. Common space complexity classifications
include the following:
O(1): Constant space complexity: The algorithm uses a fixed
memory despite the input size. For example, swapping variables.
O(n): Linear space complexity: The memory usage grows linearly
with the input size. For example, creating an array to store the input

elements.
O(n2): Quadratic space complexity: The memory usage grows
quadratically with the input size. For example, creating a 2D matrix.
O(2n): Exponential space complexity: The memory usage grows
exponentially with the input size. For example, generating all subsets
of a set.
Space complexity analysis is particularly important when dealing with large
inputs or limited memory environments, such as embedded systems or
mobile devices.
Relationship between the Big-Oh asymptotic notations
If an algorithm takes constant time, then it does not depend upon the length
of the input n, whereas the linear time linearly depends upon the input. For
example, if we increase the amount of n, the time will increase accordingly.
The relationship between the asymptotic notations is as follows:
O(1) < O(log n) O(n) < O(n log n) < O(n2) < O(n3)
Refer to Table 20.1:
n
O(1)
O(log n)
O(n)
O(n log n)
O(n2)
O(n3)
1
1
0
1
0
1
1
2
1
1
2
2
4
8
3
1
1.58
3
4.78
9
27
4
1
2
4
8
16
64
5
1
2.32
5
11.6
25
125
6
1
2.58
6
15.48
36
216
Table 20.1: Comparison of Big-Oh for different input values (n)
For a graphical representation of the preceding table, refer to Figure 20.4:

Figure 20.4: The relationship between the space taken by code and the input size
Example 5: Calculate the big-oh of the following function f(n) = n(n-
1)/2
     = (n2 – n)/2
= ½(n2) – ½(n) (As ½ is a constant coefficient, so it can be discarded).
= (n2 – n)
In this expression, n2 is a dominating term as compared to n. So, remove n
and the preceding expression in the big-oh form represented as follows:
= O(n2) 
Example 6: Calculate the big-oh of the following function. Also, find C
and k
f(n) = 4 n3 + 6n2 + 3
In this expression, 4n3 is a dominating term as compared to 6n2+3. So remove
term 6n2+3, and the preceding expression can be represented as follows:

= 4n3
As 4 is a constant coefficient, it can be discarded, and the expression in big-
oh form can be represented as follows:
= O(n3)
  4n3 + 6n2 + 3 = O(n3)
Replace all the terms on LHS with the dominating terms (n3) we get the
following:
4n3 + 6n3 + n3 = O(n3)
11n3 = O(n3)
The coefficient of the LHS term is 11, so choose C=11. So, the expression
becomes as follows:
4n3 + 6n2 + 3 <= 11(n3)
Let us choose the value of k:
Put n=1
4.13 + 6.12 + 3 <= 11(13)
13<=11, it is a false condition.
Put n=2
4.23 + 6.22 + 3 <= 11(23)
59 <= 88
So choose k as 2.
For all values of n>=2 and C=11, the C.g(n) will always be greater than f(n).
Example 7: Determine the time complexity of the following statement
for(j=1; j<=n; j++)
printf("Hello");

Here, the time taken to execute the printf("Hello") statement is constant,
that is, C. Refer to Table 20.2:
Loop variable (j) value
Inner statement execution time
j = 1
C
j = 2
C
.
.
.
.
j <= n
C
Table 20.2: The value of j for each iteration and time taken for Example 7
Loop variable (j) will execute up to n times, and it takes a constant time C to
execute the printf statement every time. So from this, we can say the
amount of time to execute for loop:
Time = Number of times loop is executed * time to execute
statement/statements in it
     = n * C
     = C.n 
In Big-Oh notation, we can discard this constant C, so the preceding
expression in Big-Oh form can be represented as follows:
 = O(n)
Note: In the preceding, for every increment in loop variable j, the loop
executes n/1 times, that is, n. Now, if it increments/decrements by 2,
that is, j = j+2 or j=j-2, the loop executes up to n/2 times. Generally, if
it increments/decrements by k, that is, j = j+k or j = j-k, the loop
executes up to n/k times. But ultimately, as Big-Oh form discards
constants term. So, it gives O(n) complexity.
Example 8: Determine the time complexity of the following statement:
for(j=n; j>1; j = j-10)

printf("Hello");
Refer to Table 20.3:
Loop variable (j) value
Inner statement execution time
     j = n
C
     j = n-10
C
     j = n-20
C
     .
.
     .
.
     j > 1
C
Table 20.3: The value of j for each iteration and its execution time for
Example 8
So, the stopping condition of this loop comes when j = 1.
n, n-10, n-20, …………………,1 
From the preceding note, we can say that
n / 10 = P, where P represents the number of iterations. So, the stopping
condition arrives when the expression:
n – p*10 = 1, 
p = (n-1)/10.
In Big-Oh notation, we can discard constants 1 and 10, so the preceding
expression in Big-Oh form can be represented as follows:
 
  = O(n)
Example 9: Determine the time complexity of the following statement:
for(j=1; j<n; j = j*2)
printf("Hello");
Refer to Table 20.4:

Loop variable (j) value
Inner statement execution time
j = 1
C
j = 2
C
j = 4
C
.
.
.
.
j < n
C
Table 20.4: The value of j for each iteration and its execution time for
Example 9
This loop executes for 20, 21, 22, 23, 24 .......... and stops when 2p =
n. So, let us find out the value of p, which gives the number of times this
loop executes.
2p = n. To obtain the p’s value, perform a log operation on both sides.
p.log22 = log2n, as we know log22 is 1. So this expression becomes:
p = log2n
In short, the preceding program loop executes up to log2n times, and in Big-
Oh notation, time complexity can be represented as follows:
  = O(log n) 
The logarithmic base can be discarded when represented in Big-Oh form.
Note: For the programs in which the loop variable, that is, the j value,
multiplies/divides by some factor, say q, then it gives a performance in
terms of the logarithm (that is, log).
Example 10: Determine the time complexity of the following statement:
for(j=n; j>1; j = j/10)
printf("Hello");

Refer to Table 20.5:
Loop variable (j) value
Inner statement execution time
j = n
C
j = n/10
C
j = n/102
C
.
.
.
.
j > 1
C
Table 20.5: The value of j for each iteration and its execution time in
Example 10
This loop executes for j = n, n/10, n/102, n/103…… and stops when n/10p
= 1, to obtain the value of p in
n = 10p
Perform log operation on both sides with base 10, as log1010 = 1. So the
preceding expression becomes:
log10n = p.log1010,
log10n = p,
In short, the preceding program loop executes up to log10 n times, and in
Big-Oh notation, time complexity can be represented as follows:
= O(log n)
The logarithmic base can be discarded when represented in Big-Oh form.
Example 11: Determine the time complexity of the following statement:
for(x=1; x<n; x = x++)
for(y=1; y<n; y=j+2)
printf("Hello");
Refer to Table 20.6:
Outer Loop
Number of times y executes for each value
Inner loop statement execution

variable 
(x)
value
of x
time
x = 1
n / 2
n / 2 * C
x = 2
n / 2
n / 2 * C
.
.
.
.
.
.
x < n
n / 2
n / 2 * C
Table 20.6: The value of x and execution time in Example 11
So, for each iteration of x, the inner statement executes up to n/2 times, and
the time for each statement taken is C. Therefore, the total time taken is as
follows:
n/2*C + n/2*C + ………… + n/2*C, upto n times. 
Time complexity = n * n/2 * C
 
 
 
    = ½ *C (n2), discard constant term, ½ *C to represent in 
big-oh
                               = O(n2)
Example 12: Determine the time complexity of the following statement
for(x=1; x<n; x = x*2)
for(y=1; y<n; y = y*2)
printf("Hello");
Refer to Table 20.7:
Outer Loop
variable 
x
value
Number of times y executes for each value
of x
Inner loop statement execution
time
x = 1
log n
log n * C
x = 2
log n
log n * C

x = 4
log n
log n * C
.
.
.
.
.
.
x < n
log n
log n * C
Table 20.7: The value of x and execution time in Example 12
So, each iteration of x inner statement executes up to log n times, and the
time for each statement is C. Therefore, the total time taken is as follows:
log n *C + log n *C ……………………………+ log n *C, upto log n times.
Time complexity = log n * (log n *C)
 
 
             =   log n.log n, discard constant C and 
logarithmic base to represent in big-oh
 
 
= O (log n.log n)
The space complexity of the given statement is constant, or O(1), because it
does not require any additional space that scales with the input size (n). The
only space used is for the loop variables (x and y), which require constant
memory regardless of the input size. The printf statement also does not
contribute to the space complexity because it only prints a fixed string
("Hello") and does not require additional memory allocation.
Example 13: Determine the time complexity of the following statement:
x = 1;
    while(x<=n)
    {
        printf("Hello");
        x = x+10;
        x = x-15;
        x = x+10;
    }

Here, the overall value of loop variable x = 5. So this loop will execute up to
n/5 times. Therefore, the total time to execute this loop
Time complexity = C * n/5
 
 
 
 = C/5 * (n), discard constant term, C/5 to 
represent in Big-Oh
 
 
 
 = O(n)
Example 14: Determine the time complexity of the following statement:
for(x=1; x<n; x++)
for(y=1; y<n; y = y*2)
printf("Hello");
Refer to Table 20.8:
Outer loop
variable 
(x)
value
Number of times y executes for each value
of x
Inner loop statement execution
time
x = 1
log n
log n * C
x = 2
log n
log n * C
.
.
.
.
.
.
x < n
log n
log n * C
Table 20.8: The value of x and execution time in Example 14
So, each iteration of x inner statement executes up to log n times, and the
time for each statement is C. Therefore, the total time taken is as follows:
log n *C + log n *C + ……………………+ log n *C, upto n times. 
Time complexity = n * (log n *C)
 
 
     =  n.log n, discard constant C and logarithmic base to 
represent in Big-Oh.

 
         = O (n.log n)
Example 15: Determine the time complexity of the following statement:
for(x=1; x<n; x++)
for(y=1; y<n; y = y++)
printf("Hello"); 
Refer to Table 20.9:
Outer Loop
Variable(x)
value
Number of times y executes for each
value of x
Inner loop statement execution
time
x = 1
n
n * C
x = 2
n
n * C
.
.
.
.
.
.
x < n
n
n * C
Table 20.9: Execution time in Example 15
So, each iteration of x inner statement executes up to n times, and the time
for each statement is C. Therefore, the total time taken is as follows:
n*C +  n*C + ……………………………+ n*C, upto n times. 
Time complexity = n * (n*C)
 
 
 
   =  n * n, discard constant C and represent in big-oh.
 
 
 
  = O (n2)
Example 16: Determine the time and space complexity of the following
statement:
fct(k)
    if k == 0

        return 1
    else
        return k * fct(k - 1)
Time complexity
At each recursive call, the function performs a constant amount of work
(multiplication and subtraction). The number of calls is equal to the value of
the input number k, as k’s value is decreasing by one here. Therefore, the
time complexity can be expressed as O(k).
For example, if we call fct(4), the function will make a total of four
recursive calls: fct(3), fct(2), fct(1), and finally, fct(0). Each call
performs a constant amount of work, resulting in a linear time complexity.
Space complexity
Every recursive call adds a new frame(space) to the stack. The space
required for each frame is constant. The maximum depth of the call stack in
this factorial function is equal to the value of k. For example, if we call
fct(4), the maximum recursion depth is 4. Therefore, the space complexity
can be expressed as O(k).
Conclusion
This chapter covers the characteristics of a better algorithm and the analysis
methods used to measure its efficiency. A good algorithm should yield
correct results and demonstrate efficiency by completing tasks in a
reasonable time with minimal resource usage. Algorithm analysis involves
evaluating the time and space complexity. Time complexity measures how
the running time grows with input size, whereas space complexity measures
the required memory. Asymptotic notation, including Big O, Omega, and
Theta, describes the growth rate of algorithms with respect to the input size.
Measuring time complexity involves the relationship between time and the
input size, and measuring space complexity considers memory usage.
Understanding these concepts helps in designing and evaluating algorithms
effectively.

Points to remember
Algorithm analysis is a study that tells an algorithm’s efficiency. The
efficiency is calculated in terms of the time and space used by the
algorithm.
Space complexity measures how much memory an algorithm needs
for a given input size.
Time complexity measures how much time the algorithm uses for a
given input size.
Asymptotic notation is a representation that tells how the performance
of an algorithm changes as the input size gets larger without the
execution of the program.
Big-Oh represents the maximum time an algorithm can take to execute
for a given input size. It is represented by O, pronounced as Big-Oh.
Omega represents the algorithm’s lower time limit to solve a problem.
It describes the shortest possible time an algorithm can take to execute
for a given input size. It is represented by omega (Ω).
Theta represents the exact time the algorithm takes to solve a problem.
It tells us about the exact rate at which the algorithm will run as the
input size grows. It is represented by theta (Θ).
Big-Oh notation is commonly preferred over other asymptotic
notations because of its Simplicity, Emphasis on the upper bound, and
standardization.
Important questions
1. What is an algorithm? Explain by taking a suitable example.
2. What are the key characteristics of a better algorithm?
3. Explain algorithm analysis. Why is there a need for algorithm
analysis?
4. How can algorithm analysis help in evaluating the efficiency of an
algorithm?

5. What is the asymptotic notation, and how does it describe the growth
rate of algorithms?
6. Explain the concept of Big-Oh notation and its role in analyzing
algorithmic time complexity.
7. What does Omega notation signify in terms of algorithmic time
complexity?
8. How does Theta notation provide a tight bound?
9. How would we choose the value of C and k
10. Why do we prefer using Big-Oh?
11. What is the importance of measuring time complexity in algorithm
analysis? Common time complexity classifications.
12. What is the significance of measuring space complexity in algorithm
analysis? Common space complexity classifications.
13. Explain the concept of worst-case time complexity and its
implications in algorithm analysis.
14. What is the difference between worst and best-case time complexity?
15. How can algorithm analysis and understanding of asymptotic notation
help in choosing the most suitable algorithm for a given problem?
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the Authors:
https://discord.bpbonline.com

Index
Symbols
2D string 254, 255d
A
Ackermann function 305, 306
address operator 157
algorithm 95, 424
characteristics 95, 424
algorithm analysis 425
performing 425, 426
algorithms
examples 95, 96
American Telephone and Telegraph (AT&T) 112
analog computers 13
annoyware 58
another number system to decimal conversion
binary to decimal 69, 70
hexadecimal to decimal 70, 71
octal to decimal 70

applications of computers
automation industries 18
banking 18
communication 17, 18
e-commerce 18
education 18
entertainment 18
online reservation 18
research 18
science and technologies 18
weather forecasting 18
word processing 17
application software 44
Arithmetic and logical unit (ALU) 5
arithmetic expression 142
arithmetic operators 144
array 211, 212
advantage 223
declaration 212, 213
element address, finding 217, 218

multi-dimensional array 219
passing to functions 276-278
properties 223
single-dimensional array 218
solved programs for practice 223-236
array initialization
at time 215, 216
direct assignment of element 213, 214
elements, accessing 214
loop, using 216
ASCII 85
assembler 102, 104
functions 104, 105
assembly language 102, 103
assignment operators 155
asymptotic notation 426, 427
Big-Oh 427-429
omega 429, 430
theta 431, 432
B

batch 50
batch processing operating system 50
BCD 86
begware 58
Big-Oh notation 427
characteristics 432
relationship 434-441
binary codes
ASCII 85
BCD 86
EBCDIC 86
Excess-3 86
gray code 86, 87
binary files 409
binary number operations
addition 80, 81
division 83
multiplication 82
negative binary number or signed number representation 85
one’s complement 84

subtraction 81, 82
subtraction, with two’s complement 84, 85
two’s complement 84
binary number system 65
binary operator 143
binary search 346
algorithm 346, 347
bitwise operators 149-152
bottom-checking loop 194
bubble sort 348
algorithm 348-350
burning 29
C
C 111, 112
characters or symbols set 115
data type modifiers 134
data types 128
features 113, 114
format specifiers 116, 117
history 112, 113

learning 114
storage classes 279-282
tokens 117
type conversion or type casting 135
variable declaration 137
variable definition 137
whitespace characters/execution character sets/escape sequences 115, 116
calling convention 276
Central Processing Unit (CPU) 21, 22
arithmetic and logic unit (ALU) 22
control unit (CU) 22
execution cycle 23-25
fetch cycle 23
machine cycle 24
registers 23
steps, for single instruction execution 26
working 23- 25
C keywords 117-119
classification based on number of users
multi-user machines 15

single-user machines 15
classification based on purpose 12
general purpose computers 12
special purpose computers 12
classification based on time or historical development 8, 9
fifth-generation computers (1989 till present) 12
first generation computers (1946–1956) 9, 10
fourth-generation computers (1971–1989) 11
second generation computers (1956–1963) 10
third generation computer (1964–1971) 10, 11
zero-generation computers (up to 1945) 9
classifications of computers 8
classification based on time or historical development 8, 9
classifications, of software dependent on proprietary rights 45
closed source software 46
freemium 46
freeware 46
open-source software 46
sharewares 46
command user interface (CUI) 49

comma operator
as operator 153
as separator 153
compilation 103
logical or semantic (meaning) error 107
syntax error 106
compilation process 106
compiler 103
assembler 104
functions 104
interpreter 104
computer 2
advantages 16
applications 17
characteristics 15, 16
components 3
functional units 3
input process output cycle 3
limitations 17
computer software 43, 44

application software 44
system software 44
conditional decision-making statements
if-else-if ladder 170, 172
if-else statement 167
if statement 165
nested if-else statement 168
switch statement 172-175
conditional directives 401
#endif 402
#if and #endif 402
#ifdef and #endif 401
conditional operator 156
console input-output functions 382
fflush(stdin) 391, 392
fgetchar() function 389
formatted input function 383
formatted output function 383
fputchar() function 389
getchar() function 388

getche() function 387
getch() function 387
gets() function 390, 391
printf() function 383-385
putchar() function 388
putch() function 387
puts() function 390, 391
scanf() function 386
unformatted input functions 383
unformatted output functions 383
constant 121
character constant 122
integer constant 121
real constant 121
string constant 122
Control unit (CU) 5
C operators
precedence and associativity 158-160
C program
comments 125

compiling 126
description 124
general structure 123, 124
header files 126, 127
printf() function 125, 126
running 126
scanf() function 126
C program lifecycle
files 107
CPU speed 26
cache memory 27
clock speed 26
total number of processor cores 27
ctype.h header file 256
Cycle Per Instruction (CPI) 15
D
data
versus information 7, 8
data type modifiers, C
long 134

short 135
signed 135
unsigned 135
data types, C 128
derived data types 133, 134
primary data types 128
decimal number system 65
decimal system to another system conversion
decimal to binary 66, 67
decimal to hexadecimal 68, 69
decimal to octal 67, 68
decision-making statements 164
conditional decision-making statements 165,-175
solved programs 180-187
unconditional decision-making statements 176-178
declaration and initialization, of string
character-by-character method 240, 241
direct method 241
initialization by index 242
dedicated computers 12

demotion 135
derived data type 133, 134
digital computer 14
digital computers
mainframes 14
micro-computers 14
mini-computers 14
supercomputers 14, 15
direct conversion methods 78
binary to decimal 78
binary to hexadecimal 80
binary to octal 79
decimal to binary 78, 79
distributed operating system (DOS) 55
double-pointer 365
do-while loop 194
E
EBCDIC 86
editor 105
Electrically Erasable PROM (EEPROM) 29

Erasable PROM (EPROM) 29
Excess-3 86
exit-controlled loop 194
expression 142
F
factorial of a number
finding 301-303
fflush(stdin)
using 391, 392
fgetchar() function 389
Fibonacci series 304
fifth-generation computers 12
file 408
binary files 409
need of 408
text files 409
file inclusion directives 399
file operations, through inbuilt functions 409
file, closing 411
file, deleting 411-413

file, opening 409, 410
file, reading 410
files generated, in C program lifecycle
executable code 108
object code 107
source code 107
first generation computers 9, 10
flash memory 29
float data type 132
Floating Point Operations Per Second (FLOPS) 15
flowchart 96-99
symbols 97
for loop 191, 192
fourth-generation computers 11
fputchar() function 389
fractional numbers 73
binary fractional numbers into decimal 73-75
binary fractional numbers into octal 76, 77
decimal fraction number to binary 74
decimal fraction number to hexadecimal 77

hexadecimal fractional numbers into decimal 74
octal fractional numbers into decimals 74
fraudware 58
freemium 46
freeware 46
function 267, 268
arrays, passing to 276,-278
need of 268
pre-defined functions 269
solved programs for practice 283-295
types 269
user-defined functions 269
versus, macro 400, 401
functional units, computer 3
input unit 4
memory unit 6, 7
output unit 4, 5
processing unit 5, 6
function based on function parameters 272
call by reference 274, 275

call by value 273
G
garbage in garbage out (GIGO) 15
general purpose computers 12
generic pointer 366
getchar() function 388
getche() function 387
getch() function 387
gets() function 390
graphical user interface (GUI) 49
gray code 86, 87
H
header files, C program 126
built-in header files 127
user-defined header file 127
hexadecimal number system 65
high-level language (HLL) 102
hybrid computers 14
I
identifiers, in C 122, 123

increment and decrement operators 145
infinite loop 199, 200
insertion sort 353, 354
algorithm 354-356
Instruction Per Second (IPS) 15
interpreter 104
interval search 344
J
jumping statements 176
L
language translator 56, 57, 103
assembler 57
compiler 57, 103
interpreter 57
Large Scale Integration (LSI) 11
linear search 344
algorithm 345
linked list 375
linker 105
linking error 105

loader 105
logical and numerical problem-solving 92, 93
logical problem, solving 93
numerical problem, solving 94, 95
logical error 107
logical operators 148
logic bomb 58
loops 190
do-while loop 194, 195
for loop 191, 192
infinite loop 199, 200
nested loop 196-198
programs for practice 200-209
types 191
while loop 193
loosely coupled systems 55
M
machine language 101
Machine Level or Low-Level Language (LLL) 101
macro

versus, function 400, 401
macro expansion directives 399, 400
malware
logic bomb 58
Naggware 58
ransomware 58
scareware 58
spyware 58
time bomb 58
Trojan viruses 58
virus 57
worms 58
Medium Scale Integration (MSI) 10
memory
main memory 35
measuring 35, 36
secondary memory 35
memory allocation 416
calloc() 418
dynamic memory 416

free() 419
malloc() 416, 417
realloc() 420
static memory 416
memory hierarchy 34, 35
memory units 27
primary memory 28
secondary memory 30
solved examples based on inter-conversion 36-38
merge sort 307, 308
algorithm 308
middle-level language 102
Millions of Instructions Per Second (MIPS) 15
multi-dimensional array 219
2D array 219, 220
3D array 220-222
multiprocessing operating system 54
asymmetrical multiprocessing system 54
symmetrical multiprocessing system 54
multiprogramming operating system 51, 52

distributed operating system 55
multitasking OS through time-sharing 52, 53
multithreading operating system 53, 54
networking operating system 55
real-time operating system 56
multitasking OS through time-sharing 52, 53
multithreading operating system 53, 54
N
Naggware 58
nested loop 196-198
nested structure 338, 339
network operating system (NOS) 55
NULL pointer 366
number system 63, 64
binary number system 65
decimal number system 65
hexadecimal number system 65
octal number system 65
number system conversions 71-73
O

octal number system 65
omega 429
one-dimensional array 218
operands 142
Operating System (OS) 46
as resource manager 48
Operating System (OS) classification 49
based on execution of program 49
based on number of users 49
based on user interface 49
language translator 56, 57
malware 57
operating system (OS) classification, based on program execution
batch processing operating system 50
multiprogramming operating system 51, 52
sequentially execution of program or serial processing 50
operators 142
associativity 157
precedence 157
operators based on operand count 142

binary operator 143
ternary operator 143
unary operator 142
operators based on operation type 144, 148
address operator 157
arithmetic operators 144
assignment operators 155
bitwise operators 149-152
comma operator 153
conditional operator 156
increment and decrement operators 145
logical operators 152
relation operator 146
shift operators 152
sizeof( ) operator 154
operators, in C 123
P
parameters
actual parameters 272
formal parameters 272

pointer 274, 360
array of pointers 369, 370
generic pointer 366
initialization 360, 361
NULL pointer 366
operations 362, 365
value, accessing 361
pointer to an array 367, 368
pointer-to-pointer 365
Power-On Self-Test (POST) 45
preprocessor 398
preprocessor directives 398
conditional directives 401, 402
file inclusion directives 399
macro expansion directives 399, 400
undefined directives 403, 404
primary data types 128
characters 129, 130
double data type 132
integer data 130, 131

real data type 132
void 132
primary memory 28
RAM 28
ROM 29
printf() function 383-385
problem-solving 92
logical and numerical problem-solving 92
problem-solving techniques 95
algorithm 95
flowcharts 96-99
pseudocodes 100, 101
process
compiling 105
executing 105
Programmable Read-Only Memory (PROM) 29
programming language 101, 112
assembly language 102
high-level language (HLL) 102
Machine Level or Low-Level Language (LLL) 101

promotion 135
pseudocodes 100, 101
putchar() function 388
putch() function 387
puts() function 390
Q
quadratic equation 179
roots 179
quick sort 311-315
algorithm 315-317
R
RAM 28
dynamic RAM (DRAM) 28
static RAM (SRAM) 28
ransomware 58
real-time operating system 56
hard real-time operating system 56
soft real-time operating system 56
recursion 299, 300
registers, CPU

accumulator (AC) 23
General Purpose Registers (GPR) 23
Instruction Register (IR) 23
Memory Address Registers (MAR) 23
Memory Data Register (MDR) 23
Program Counter (PC) Register 23
Special Purpose Register (SPR) 23
relational expression 142
relation operators 146
ROM chips 29
EEPROM 29
EPROM 29
PROM 29
S
scanf() function 386
limitations 242, 243, 386, 387
scareware 58
searches
binary search 346
interval search 344

linear search 344
sequential search 344
searching 344
secondary data type 133
secondary memory 30
semi-random accessed memory 31-33
serial accessed memory 31
second-generation computers 10
selection sort 350, 351
algorithm 351-353
self-referential structure 371-373
semi-random accessed memory 31
hard disk 32, 33
magnetic disk 32
optical disks 33
sequential search 344
serial accessed memory
magnetic tape 31
sharewares
adware 46

crippleware 46
demoware 46
donationware 46
trialware 46
shift operators 152
single-dimensional array 218
sizeof( ) operator 154
Small Scale Integration (SSI) 10
sorting algorithm 348
bubble sort 348
insertion sort 353, 354
selection sort 350, 351
space complexity 442
measuring 433
special purpose computers 12
special symbols, in C 123
spyware 58
standard inbuilt string functions 243
strcat() function 245
strcmp() function 246, 247

strcpy() function 248
strlen() function 244
strlwr() function 251
strncat() function 252
strncmp() function 254
strncpy() function 253
strrev() function 249
strupr() function 250
storage classes, C 279, 280
automatic 280
external or global 282
register 281
static 280, 281
string 240
declaration 240
initialization 240
solved programs for practice 258-263
structure 321, 322
array of structures 329, 330
defining 322-324

initialization 325, 328
passing, in function 339, 340
structure member
accessing 324
structure pointer 331
declaration 331
initialization 331
members, accessing 331-333
syntax error 106
system software 44
BIOS 45
device drive 45
examples 45
firmware 45
utility software 45
T
technology-based classification 13
analog computers 13
digital computers 14
hybrid computers 14

ternary operator 143, 156
text files 409
theta 431
third generation computer 10
threads 53
three-dimensional (3D) array 220-222
tightly coupled system 54
time bomb 58
time complexity 442
measuring 433
tokens, C 117
classification 117
constant 121
identifiers 122, 123
keywords 117-119
operators 123
special symbols 123
variables 119, 120
Trojan virus 58
two-dimensional (2D) array 219, 220

typecasting 136
type conversion or type casting
explicit type conversion 136
implicit type conversion 135, 136
U
Ultra Large-Scale Integration (ULSI) technology 12
Ultraviolet EPROM (UV-EPROM) 29
unary operator 142
unconditional decision-making statements
break statement 176
continue statement 177
goto statement 177, 178
undefined directives 403
#undef 403, 404
union 335-338
UNIX OS structure 47
kernel 47
shell 47
user-defined functions
function calling 270

function declaration or prototyping 269
function definition 269
V
variables 119, 120
virus 57
W
Web browser 54
while loop 193
worms 58
Z
zero-generation computers 9

