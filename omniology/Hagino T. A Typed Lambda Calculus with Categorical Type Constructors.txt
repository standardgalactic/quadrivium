A Typed Lambda Calculus
with
Categorical Type Constructors
Tatsuya Hagino
LFCS, Department of Computer Science, University of Edinburgh
James Clerk Maxwell Building, Kingâ€™s Buildings, Mayï¬eld Road
Edinburgh EH9 3JZ, United Kingdom.
Abstract
A typed lambda calculus with categorical type constructors is introduced. It has a uniform
category theoretic mechanism to declare new types.
Its type structure includes categorical
objects like products and coproducts as well as recursive types like natural numbers and lists.
It also allows duals of recursive types, i.e. lazy types, like inï¬nite lists.
It has generalized
iterators for recursive types and duals of iterators for lazy types. We will give reduction rules
for this simply typed lambda calculus and show that they are strongly normalizing even though
it has inï¬nite things like inï¬nite lists.
1
Introduction
The type structure of a simply typed lambda calculus is generally constructed from some base types
using the arrow type constructor Ïƒ â†’Ï„. Since a pure lambda calculus is nothing but about lambda
abstraction and application of lambda terms, the arrow type is more important than base types.
However, if we do not have any base types, the type structure is empty and there is no point in
discussing such a typed lambda calculus because there are no typed lambda terms. Therefore, we
need some base types when developing a theory of a simply typed lambda calculus, but the choice
of base types may vary from one calculus to another: some choose the type of natural numbers as
the only base type or others, like [11], choose the type of ordinals as well. We have to be careful
about choosing base types because a bad choice may ruin the whole calculus, e.g. lose the strong
normalization property.
A typed lambda calculus can be regarded as a model of typed functional programming languages,
so obviously the richer the type structure is, the closer to real programming languages the calculus
is. Some programming languages now have quite powerful mechanisms of creating new types from
existing ones, and we would naturally like to see those mechanisms in typed lambda calculi as well.
From a category theoretic point of view, the arrow type constructor is just one of the functors which
can be deï¬ned by adjunctions. There is no reason why we should not have other functors in typed
lambda calculi. In [4], the author introduced a category theoretic datatype declaration mechanism,
by which we can deï¬ne categorical objects like products and coproducts, ordinary datatypes in most
of programming languages like natural numbers and lists, those datatypes which can be deï¬ned
by solving recursive datatype equations, and lazy datatypes like inï¬nite lists. All these datatypes

are declared uniformly by means of generalized adjunctions. In this paper, we give a simply typed
lambda calculus which incorporates this uniform categorical datatype declaration mechanism. This
lambda calculus no longer needs base types. We can introduce almost all the datatypes we need
in ordinary programming languages by this mechanism. Furthermore, the calculus is still strongly
normalizing even though it has inï¬nite lists and others.
In section 2, we introduce our (simply) typed lambda calculus: its type structure, its terms, its
typing system and its reduction rules. In section 3, we see some types we can deï¬ne in our typed
lambda calculus, and, in section 4, we compare our typed lambda calculus with other typed lambda
calculi. Finally, in section 5 we see the connection between our lambda calculus and the functional
programming language ML.
2
A Typed Lambda Calculus with Categorical Type Con-
structions
2.1
Types
The type structure Type of an ordinary simply typed lambda calculus can be given in general by the
following two rules:
Ïƒ âˆˆBaseType
Ïƒ âˆˆType
Ïƒ âˆˆType
Ï„ âˆˆType
Ïƒ â†’Ï„ âˆˆType
where BaseType is the set of base types available to this typed lambda calculus. This lambda calculus
has only one way of constructing types, i.e. Ïƒ â†’Ï„ is the only type constructor. We can enrich the
type structure by introducing new type constructors.
For example, if we want the product and
coproduct type constructors, we may add the following two rules:
Ïƒ âˆˆType
Ï„ âˆˆType
Ïƒ Ã— Ï„ âˆˆType
Ïƒ âˆˆType
Ï„ âˆˆType
Ïƒ + Ï„ âˆˆType
Of course, we have to introduce new terms which belong to these new types and new reduction rules
concerning the new terms. Although this approach is ï¬‚exible to have any kind of type constructors,
every time we introduce a new type constructor, we get a new typed lambda calculus and we have
to prove all the properties of this calculus from the very beginning.
One way of getting out of this problem is to have a mechanism to introduce new type constructors.
In domain theory, we can deï¬ne domains by solving recursive domain equations and in some pro-
gramming languages, e.g. ML [5], we can deï¬ne datatypes (or datatype constructors as polymorphic
types) in a similar manner by giving recursive datatype equations. Therefore, it is natural to intro-
duce recursive types to a typed lambda calculus. The type structure of such a lambda calculus may
be given by the following rules:
Ï âˆˆTVar
Ï âˆˆÎ“
Î“ âŠ¢Ï âˆˆType
Î“ âŠ¢Ïƒ âˆˆType
Î“ âŠ¢Ï„ âˆˆType
Î“ âŠ¢Ïƒ â†’Ï„ âˆˆType
Ï âˆˆTVar
Î“ âˆª{ Ï } âŠ¢Ïƒ âˆˆType
Î“ âŠ¢ÂµÏ.Ïƒ âˆˆType
where TVar is a set of type variables and Î“ is an environment under which types are checked to be
well-formed. The type introduced by ÂµÏ.Ïƒ should have terms corresponding recursively to that of

Ïƒ[ÂµÏ.Ïƒ/Ï], where Ïƒ[Ï„/Ï] denotes the type obtained by replacing the type variable Ï in Ïƒ by a type Ï„.
In this way, we can get rid of some basic types. For example, the type for natural numbers can now
be deï¬ned as
nat â‰¡ÂµÏ.1 + Ï
where 1 is the type of one element and + is the coproduct type constructor. This is like in domain
theory where the domain N of natural numbers is the least ï¬xed point of N âˆ¼= 1 + N. Similarly
we can deï¬ne most of ordinary datatypes in todayâ€™s programming languages in this way. However,
there are still some problems about this approach. Firstly, we need to select some base types, like
1, and some type constructors, like + and Ã—, to start with. Secondly, the reduction rules for this
calculus may not be normalizing. Of course, it depends on the choice of terms and reduction rules in
the calculus, but we would like to have a ï¬xed point operator or something which enables us to write
terms for addition, multiplication and so on. If we have a ï¬xed point operator, reductions may not
terminate. In case of an ordinary simply typed lambda calculus with the type of natural numbers, it
has iterators (often denoted by J) which allows us to deï¬ne these terms by primitive recursion and
because we only use primitive recursion the reductions always terminate, but we still do not know
what is the general operator for primitive recursion for ÂµÏ.Ïƒ.
From a category theoretic point of view, the types deï¬ned by ÂµÏ.Ïƒ exactly correspond to initial T-
algebras. Initial T-algebras cannot deï¬ne the coproduct type constructor, but, as the author showed
in [4], their extension, initial and ï¬nal F, G-dialgebras, can deï¬ne the coproduct type constructor as
well as the product one.
Deï¬nition 2.1: Let C and D be categories and both F and G be functors from C to D. We deï¬ne
the category of F, G-dialgebras as
1. its objects are pairs âŸ¨A, fâŸ©where A is a C object and f is a D morphism of F(A) â†’G(A), and
2. its morphisms h: âŸ¨A, fâŸ©â†’âŸ¨B, gâŸ©are C morphisms h: A â†’B such that the following diagram
commutes.
F(A)
f
G(A)
-
F(h)
Â¥
Â¨Â§?
G(h)
?
?
F(B)
g
-G(B)
It is easy to show that it is a category; let us write DAlg(F, G) for it. []
It is also easy to see that the deï¬nition of F, G-dialgebra is an extension of the deï¬nition of T-
algebras as well as that of T-coalgebras: DAlg(T, I) is the category of T-algebras and DAlg(I, T)
is the category of T-coalgebras.
The extension is a very simple one, yet its symmetry and dividing the source category from the target
one give us greater freedom. With T-algebras, we need the coproduct functor to deï¬ne the domain
of natural numbers, but with F, G-dialgebra we do not. Let C be any category and D be its product
category C Ã— C. We deï¬ne the functors F and G as
F(A) â‰¡âŸ¨1, AâŸ©
and
G(A) â‰¡âŸ¨A, AâŸ©.
Let âŸ¨nat, âŸ¨zero, succâŸ©âŸ©be the initial F, G-dialgebra.
The unique DAlg(F, G) morphism h from

âŸ¨nat, âŸ¨zero, succâŸ©âŸ©to a DAlg(F, G) object âŸ¨A, âŸ¨f, gâŸ©âŸ©makes the following diagram commute.
âŸ¨nat, âŸ¨zero, succâŸ©âŸ©
h
âŸ¨A, âŸ¨f, gâŸ©âŸ©
âŸ¨1, natâŸ©
âŸ¨I, hâŸ©
âŸ¨1, AâŸ©
âŸ¨zero, succâŸ©
Â¥
Â¨Â§?
âŸ¨f, gâŸ©
âŸ¨nat, natâŸ©
âŸ¨h, hâŸ©
âŸ¨A, AâŸ©
-
-
?
?
?
If we redraw the diagram, we get a more familiar diagram of deï¬ning â€˜natâ€™ as the natural number
object.
1
zero
nat
succ
nat
f
Â¥
Â¨Â§?
h
Â¥
Â¨Â§?
h
A
A
g
-
-
@
@
@
@
@
@
@
@
R
-
?
?
We can also demonstrate that left adjoint functors can be expressed by initial F, G-dialgebras and
right adjoint functors can be expressed by ï¬nal F, G-dialgebras. Let us, as an example, deï¬ne the
product of two C objects A and B. Remember that the product functor is the right adjoint of the
diagonal functor. We set the functors F and G from C to C Ã— C as
F(C) â‰¡âŸ¨C, CâŸ©
and
G(C) â‰¡âŸ¨A, BâŸ©.
Let âŸ¨A Ã— B, âŸ¨Ï€1, Ï€2âŸ©âŸ©be the ï¬nal F, G-dialgebra. Then, from the deï¬nition, the unique DAlg(F, G)
morphism h from a DAlg(F, G) object âŸ¨C, âŸ¨f, gâŸ©âŸ©to âŸ¨A Ã— B, âŸ¨Ï€1, Ï€2âŸ©âŸ©should commute the following
diagram.
âŸ¨C, âŸ¨f, gâŸ©âŸ©
h
âŸ¨A Ã— B, âŸ¨Ï€1, Ï€2âŸ©âŸ©
âŸ¨C, CâŸ©
âŸ¨h, hâŸ©
âŸ¨A Ã— B, A Ã— BâŸ©
âŸ¨f, gâŸ©
Â¥
Â¨Â§?
âŸ¨Ï€1, Ï€2âŸ©
âŸ¨A, BâŸ©
âŸ¨I, IâŸ©
âŸ¨A, BâŸ©
-
-
?
?
?
We can redraw the diagram to get an ordinary diagram for products.
A
A Ã— B
B
Ï€1
Ï€2
Â¥
Â¨Â§?
Â¥
Â¨Â§?
f
g
h
C

-
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
Âª
@
@
@
@
@
@
@
@
R
?

As we extended T-algebras to F, G-dialgebras, we can extend ÂµÏ.Ïƒ into something more powerful: we
use not only least ï¬xed points but also greatest ï¬xed points which correspond to ï¬nal T-coalgebras;
we allow a sequence of types instead of a single type when we take ï¬xed points. The type structure
of our lambda calculus is:
Deï¬nition 2.2: Let TVar be a set of type variables. We use Ï, Î½, . . . for the meta-variables of TVar.
The set Type of types is deï¬ned by the following rules:
Ï âˆˆTVar
Ï âˆˆÎ“
Î“ âŠ¢Ï âˆˆType
Î“ âŠ¢Ïƒ âˆˆType
Î“ âŠ¢Ï„ âˆˆType
Î“ âŠ¢Ïƒ â†’Ï„ âˆˆType
Î“ âˆª{ Ï } âŠ¢Ïƒi âˆˆType
Pos(Ï, Ïƒi)
(i = 1, . . . , n)
Î“ âŠ¢ÂµÏ.(Ïƒ1, . . . , Ïƒn) âˆˆType
Î“ âˆª{ Ï } âŠ¢Ïƒi âˆˆType
Pos(Ï, Ïƒi)
(i = 1, . . . , n)
Î“ âŠ¢ÂµÏ.(Ïƒ1, . . . , Ïƒn) âˆˆType
where Pos(Ï, Ïƒ) is the predicate which is true when Ï occurs only positively in Ïƒ. Pos can be deï¬ned
as follows together with the predicate Neg(Ï, Ïƒ) for negative occurrences of Ï in Ïƒ:
Pos(Ï, Ï)
Pos(Ï, Î½)
Neg(Ï, Î½)
Neg(Ï, Ïƒ)
Pos(Ï, Ï„)
Pos(Ï, Ïƒ â†’Ï„)
Pos(Ï, Ïƒ)
Neg(Ï, Ï„)
Neg(Ï, Ïƒ â†’Ï„)
Pos(Ï, Ïƒi)
(i = 1, . . . , n)
Pos(Ï, ÂµÎ½.(Ïƒ1, . . . , Ïƒn))
Neg(Ï, Ïƒi)
(i = 1, . . . , n)
Neg(Ï, ÂµÎ½.(Ïƒ1, . . . , Ïƒn))
Pos(Ï, Ïƒi)
(i = 1, . . . , n)
Pos(Ï, ÂµÎ½.(Ïƒ1, . . . , Ïƒn))
Neg(Ï, Ïƒi)
(i = 1, . . . , n)
Neg(Ï, ÂµÎ½.(Ïƒ1, . . . , Ïƒn))
We use Ïƒ, Ï„, . . . for the meta-variables of Type. []
The type ÂµÏ.(Ïƒ1, . . . , Ïƒn) corresponds to the initial F, G-dialgebra where F and G are functors from
C to C Ã— Â· Â· Â· Ã— C such that
F(A) â‰¡âŸ¨F1(A), . . . , Fn(A)âŸ©
and
G(A) â‰¡âŸ¨A, . . . , AâŸ©
where F1, . . . , Fn are functors corresponding to Ïƒ1, . . . , Ïƒn. On the other hand, ÂµÏ.(Ïƒ1, . . . , Ïƒn) corre-
sponds to the ï¬nal G, F-dialgebra for the same F and G as above.
Note that we restricted type variables to occur only positively in ÂµÏ.(Ïƒ1, . . . , Ïƒn) and ÂµÏ.(Ïƒ1, . . . , Ïƒn).
Therefore, we can have neither ÂµÏ.(Ï â†’Ïƒ) nor ÂµÏ.(Ï â†’Ï), but we can have ÂµÏ.((Ï â†’Ïƒ) â†’Ï) if we
want. Note also that we do not have any base types. We will show that various types we can deï¬ne
in this lambda calculus in section 3.
2.2
Terms and Their Types
Terms of our lambda calculus are deï¬ned as follows:

Deï¬nition 2.3: We have an enumerable set Var of variables and a set of terms is given by the
following BNF expression.
L : : = x | Î»xÏƒ.L | L1L2 | CÂµÏ.(Ïƒ1,...,Ïƒn),i | JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ |
DÂµÏ.(Ïƒ1,...,Ïƒn),i | PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ | Ïƒ[L/Ï]
where C, J, D and P are constants and we use x, y, z, . . . for meta-variables for variables and
L, M, N, . . . for meta-variables for terms. We may omit type subscripts or superscripts (e.g. ÂµÏ.(Ïƒ1, . . . , Ïƒn)
of CÂµÏ.(Ïƒ1,...,Ïƒn),i) if they are obvious. []
CÂµÏ.(Ïƒ1,...,Ïƒn),i and JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ are associated with ÂµÏ.(Ïƒ1, . . . , Ïƒn). Remember that ÂµÏ.(Ïƒ1, . . . , Ïƒn) is
the initial F, G-dialgebra where F and G are
F(A) â‰¡âŸ¨Ïƒ1[A/Ï], . . . , Ïƒn[A/Ï]âŸ©
and
G(A) â‰¡âŸ¨A, . . . , AâŸ©.
CÂµÏ.(Ïƒ1,...,Ïƒn),i (i = 1, . . . , n) are morphisms such that
âŸ¨ÂµÏ.(Ïƒ1, . . . , Ïƒn), âŸ¨CÂµÏ.(Ïƒ1,...,Ïƒn),1, . . . , CÂµÏ.(Ïƒ1,...,Ïƒn),nâŸ©âŸ©
is the initial F, G-dialgebra. Therefore, the type of CÂµÏ.(Ïƒ1,...,Ïƒn),i is
CÂµÏ.(Ïƒ1,...,Ïƒn),i : Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï] â†’ÂµÏ.(Ïƒ1, . . . , Ïƒn).
Given a term M of type Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï], CÂµÏ.(Ïƒ1,...,Ïƒn),iM constructs a term of ÂµÏ.(Ïƒ1, . . . , Ïƒn).
CÂµÏ.(Ïƒ1,...,Ïƒn),i are constructors. In addition, JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ is the mediating morphism such that for any
morphisms M1, . . . , Mn of type Ïƒ1[Ï„/Ï] â†’Ï„, . . . , Ïƒn[Ï„/Ï] â†’Ï„, respectively, JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn
gives a unique morphism from ÂµÏ.(Ïƒ1, . . . , Ïƒn) to Ï„ such that the following digrams (i = 1, . . . , n)
commute.
Ïƒi[Ï„/Ï]
Ïƒi[JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn/Ï]
Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]
Mi
CÂµÏ.(Ïƒ1,...,Ïƒn),i
Â¥
Â¨Â§?
Ï„
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn
ÂµÏ.(Ïƒ1, . . . , Ïƒn)
-
-
?
?
Therefore, the type of JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ is
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ : (Ïƒ1[Ï„/Ï] â†’Ï„) â†’Â· Â· Â· â†’(Ïƒn[Ï„/Ï] â†’Ï„) â†’ÂµÏ.(Ïƒ1, . . . , Ïƒn) â†’Ï„.
As is well-known, JÂµÏ.(Ïƒ1,...,Ïƒn) can be used to deï¬ne primitive recursive functions.
Dually, DÂµÏ.(Ïƒ1,...,Ïƒn),i and PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ are associated with the type ÂµÏ.(Ïƒ1, . . . , Ïƒn).
âŸ¨ÂµÏ.(Ïƒ1, . . . , Ïƒn), âŸ¨DÂµÏ.(Ïƒ1,...,Ïƒn),1, . . . , DÂµÏ.(Ïƒ1,...,Ïƒn),nâŸ©âŸ©
gives the ï¬nal G, F-dialgebra and PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ is its mediating morphism. Given a term M of type
ÂµÏ.(Ïƒ1, . . . , Ïƒn), it can be decomposed into a term DÂµÏ.(Ïƒ1,...,Ïƒn),iM of type Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï] and
PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn can be used to construct a term of type ÂµÏ.(Ïƒ1, . . . , Ïƒn) from a term of type
Ï„.
For a type Ïƒ with a free type variable Ï, a term Ïƒ[M/Ï] denotes the result of applying the functor
corresponding to Ïƒ to a term M.

Deï¬nition 2.4: Types of terms in our lambda calculus is given by the following rules:
x âˆˆVar
x : Ïƒ âˆˆÎ“
Î“ âŠ¢x : Ïƒ
Î“ âˆª{ x : Ïƒ } âŠ¢M : Ï„
Î“ âŠ¢Î»xÏƒ.M : Ïƒ â†’Ï„
Î“ âŠ¢M : Ïƒ â†’Ï„
Î“ âŠ¢N : Ïƒ
Î“ âŠ¢MN : Ï„
Î“ âŠ¢CÂµÏ.(Ïƒ1,...,Ïƒn),i : Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï] â†’ÂµÏ.(Ïƒ1, . . . , Ïƒn)
Î“ âŠ¢JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ : (Ïƒ1[Ï„/Ï] â†’Ï„) â†’. . . â†’(Ïƒn[Ï„/Ï] â†’Ï„)
â†’ÂµÏ.(Ïƒ1, . . . , Ïƒn) â†’Ï„
Î“ âŠ¢DÂµÏ.(Ïƒ1,...,Ïƒn),i : ÂµÏ.(Ïƒ1, . . . , Ïƒn) â†’Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]
Î“ âŠ¢PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ : (Ï„ â†’Ïƒ1[Ï„/Ï]) â†’. . . â†’(Ï„ â†’Ïƒn[Ï„/Ï])
â†’Ï„ â†’ÂµÏ.(Ïƒ1, . . . , Ïƒn)
Pos(Ï, Ïƒ)
Î“ âŠ¢M : Ï„ â†’Ï„ â€²
Î“ âŠ¢Ïƒ[M/Ï] : Ïƒ[Ï„/Ï] â†’Ïƒ[Ï„ â€²/Ï]
Neg(Ï, Ïƒ)
Î“ âŠ¢M : Ï„ â†’Ï„ â€²
Î“ âŠ¢Ïƒ[M/Ï] : Ïƒ[Ï„ â€²/Ï] â†’Ïƒ[Ï„/Ï]
[]
2.3
Reduction rules
Let us consider the reduction rules for our typed lambda calculus. In the following we do not handle
Î± conversions explicitly. We regard terms which can be transformed each other by Î± conversions
are essentially the same. We assume that the necessary renaming of variables when substituting a
variable by a term is done implicitly.
We have the Î² and Î· reduction rules from ordinary lambda calculi.
(Î»xÏƒ.M)N â‡’M[N/x]
Î»xÏƒ.Mx â‡’M
where x needs to be free in M for the Î· reductions.
Since ÂµÏ.(Ïƒ1, . . . , Ïƒn) corresponds to the initial F, G-dialgebra for
F(A) â‰¡âŸ¨Ïƒ1[A/Ï], . . . , Ïƒn[A/Ï]âŸ©
and
G(A) â‰¡âŸ¨A, . . . , AâŸ©,
for any type Ï„ and any terms Mi : Ïƒ[Ï„/Ï] â†’Ï„ (i = 1, . . . , n) there exists a unique morphism N
which make the following diagrams (i = 1, . . . , n) commute.
Ïƒi[Ï„/Ï]
Ïƒi[N/Ï]
Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]
Mi
CÂµÏ.(Ïƒ1,...,Ïƒn),i
Â¥
Â¨Â§?
Ï„
N
ÂµÏ.(Ïƒ1, . . . , Ïƒn)
-
-
?
?
N is given by the iterator as JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn. From the commutativity, we have the following
equality.
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn(CÂµÏ.(Ïƒ1,...,Ïƒn),iL) = Mi(Ïƒ[JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn/Ï]L)

where L is a term of type Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]. Reducing the number of constructors is a good
strategy for normalizing terms, so we have a reduction rule of rewriting the left-hand side by the
right-hand side.
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn(CÂµÏ.(Ïƒ1,...,Ïƒn),iL) â‡’Mi(Ïƒ[JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn/Ï]L)
When Ï„ is ÂµÏ.(Ïƒ1, . . . , Ïƒn) and Mi is CÂµÏ.(Ïƒ1,...,Ïƒn),i, the commutative diagram is
Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]
Ïƒi[N/Ï]
Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]
CÂµÏ.(Ïƒ1,...,Ïƒn),i
CÂµÏ.(Ïƒ1,...,Ïƒn),i
Â¥
Â¨Â§?
ÂµÏ.(Ïƒ1, . . . , Ïƒn)
N
ÂµÏ.(Ïƒ1, . . . , Ïƒn)
-
-
?
?
N should be the identity morphism, so we have the following reduction rule.
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„CÂµÏ.(Ïƒ1,...,Ïƒn),1 . . . CÂµÏ.(Ïƒ1,...,Ïƒn),n â‡’Î»xÂµÏ.(Ïƒ1,...,Ïƒn).x
The two reduction rules cannot exactly characterize ÂµÏ.(Ïƒ1, . . . , Ïƒn) to be the initial F, G-dialgebra
since the uniqueness condition is essentially a conditional equation, but as far as its computational
aspect is concerned they seems to be enough.
Dually, for ÂµÏ.(Ïƒ1, . . . , Ïƒn), we have the following two reduction rules:
DÂµÏ.(Ïƒ1,...,Ïƒn),i(PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . MnL) â‡’Ïƒi[PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn/Ï](MiL)
and
PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„DÂµÏ.(Ïƒ1,...,Ïƒn),1 . . . DÂµÏ.(Ïƒ1,...,Ïƒn),n â‡’Î»xÂµÏ.(Ïƒ1,...,Ïƒn).x.
Finally, we have some reduction rules for functors Ïƒ[M/Ï]. Like the product functor f Ã— g can be
expressed by âŸ¨f â—¦Ï€1, g â—¦Ï€2âŸ©, we transform Ïƒ[M/Ï] into terms containing J, C, P and D. In the
following rules, let M be a term of type Ï„ â†’Ï„ â€².
Ï[M/Ï] â‡’M
Î½[M/Ï] â‡’Î»xÏƒ.x
(where Ï Ì¸â‰¡Î½)
(Ïƒ â†’Ïƒâ€²)[M/Ï] â‡’Î»xÏƒ[Ï„/Ï]â†’Ïƒâ€²[Ï„/Ï].Î»yÏƒ[Ï„ â€²/rho].Ïƒâ€²[M/Ï](x (Ïƒ[M/Ï] y))
ÂµÎ½.(Ïƒ1, . . . , Ïƒn)[M/Ï] â‡’JÂµÎ½.(Ïƒ1[Ï„/Ï],...),ÂµÎ½.(Ïƒ1[Ï„ â€²/Ï],...)M1 . . . Mn
(where Mi is Î»xÏƒi[Ï„/Ï][ÂµÎ½.(Ïƒ1[Ï„ â€²/Ï],...)/Î½].CÂµÎ½.(Ïƒ1[Ï„/Ï],...),i(Ïƒi[ÂµÎ½.(Ïƒ1[Ï„ â€²/Ï], . . .)/Î½][M/Ï] x))
ÂµÎ½.(Ïƒ1, . . . , Ïƒn)[M/Ï] â‡’PÂµÎ½.(Ïƒ1[Ï„ â€²/Ï],...),ÂµÎ½.(Ïƒ1[Ï„/Ï],...)M1 . . . Mn
(where Mi is Î»xÂµÎ½.(Ïƒ1[Ï„/Ï],...).Ïƒi[ÂµÎ½.(Ïƒ1[Ï„/Ï], . . .)/Î½][M/Ï](DÂµÎ½.(Ïƒ1[Ï„/Ï],...),ix))
We have some obvious propositions.
Proposition 2.5: For a term L of type Ïƒ, if there is a reduction L
âˆ—â‡’M, M also has the type Ïƒ,
where
âˆ—â‡’is the transitive version of â‡’. []
Proposition 2.6: If Ï does not occur in Ïƒ, then Ïƒ[M/Ï]
âˆ—â‡’Î»xÏƒ.x for any term M. []

This means that constant functors always give identities.
Proposition 2.7: For any type Ïƒ with a free variable Ï, Ïƒ[Î»xÏ„.x/Ï]
âˆ—â‡’Î»yÏƒ[Ï„/Ï].y. []
This means that identities are always mapped to identities by Ïƒ, which is one of the conditions for
Ïƒ being a functor.
Now, we have two important theorems about our reduction system: strong normalization and Church-
Rosser. Because we only use primitive recursions, any term can be reduced to a normal term which
cannot be reduced any more. In fact, any reduction leads to a normal term.
Theorem 2.8: (Strong Normalization Theorem) The reduction is strongly normalizing, that
is, there is no inï¬nite reduction sequence L1 â‡’L2 â‡’L3 â‡’Â· Â· Â· â‡’Ln â‡’Â· Â· Â· . []
Furthermore, any reduction leads to a unique normal term.
Theorem 2.9: (Church-Rosser Theorem) The reduction is Church-Rosser, that is, if L
âˆ—â‡’M
and L
âˆ—â‡’N, there exists a term K such that M
âˆ—â‡’K and N
âˆ—â‡’K. []
Because we have the strong normalization theorem, the Church-Rosser theorem follows from the
following lemma (see [6] proposition 13.1).
Lemma 2.10: If L â‡’M and L â‡’N, there exists a term K such that M
âˆ—â‡’K and N
âˆ—â‡’K.
Proof: All we have to do is to check any overlapping of two reduction rules. For example,
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn(CÂµÏ.(Ïƒ1,...,Ïƒn),iL) â‡’Mi(Ïƒ[JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . Mn/Ï]L)
and
JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„CÂµÏ.(Ïƒ1,...,Ïƒn),1 . . . CÂµÏ.(Ïƒ1,...,Ïƒn),n â‡’Î»xÂµÏ.(Ïƒ1,...,Ïƒn).x
overlap, that is, there a term to which both rules can be applied, but we can easily show that two
resulting terms can be reduced to the same term.
JC1 . . . Cn(CiL)
Ci(Ïƒi[JC1 . . . Cn/Ï]L)
(Î»x.x)(CiL)
CiL
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
@
@
@
@
@
@
@
@
@
@
@
@
Â¡
Â¡
Â¡
Â¡
Â¡
Â¡
âˆ—
âˆ—
Ci(Ïƒi[JC1 . . . Cn/Ï]L)
âˆ—â‡’CiL follows from JC1 . . . Cn â‡’Î»x.x and proposition 2.7. We can check all
the other overlappings similarly. []
The strong normalization theorem follows intuitively from the fact that we use only primitive recur-
sion. In the reduction of JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ we reduce the number of constructors CÂµÏ.(Ïƒ1,...,Ïƒn),i, whereas
in the reduction of PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ we reduce the number of destructors DÂµÏ.(Ïƒ1,...,Ïƒn),i. Therefore, there
is no way we can continue reducing any terms. Formally, we prove the normalization theorem by
Taitâ€™s computability method [6, 12]. First, we deï¬ne the notion of computable terms by induction on
types.
Deï¬nition 2.11: (Computability)

1. M : Ïƒ â†’Ï„ is computable if MN : Ï„ is computable for any computable term N : Ïƒ
2. M : ÂµÏ.(Ïƒ1, . . . , Ïƒn) is computable if M is strongly normalizing and M
âˆ—â‡’CÂµÏ.(Ïƒ1,...,Ïƒn),iL such
that L : Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï] is computable.
3. M : ÂµÏ.(Ïƒ1, . . . , Ïƒn) is computable if M is strongly normalizing and
M
âˆ—â‡’PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„N1 . . . NnL
such that for any i
DÂµÏ.(Ïƒ1,...,Ïƒn),i(PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„N1 . . . NnL) : Ïƒi[ÂµÏ.(Ïƒ1, . . . , Ïƒn)/Ï]
is computable. []
Note that the deï¬nition is inductive in another sense as well. The deï¬nition of computable terms of
ÂµÏ.(Ïƒ1, . . . , Ïƒn) depends on itself. We take the least ï¬xed point of this self recursive deï¬nition, i.e.
starting with the empty set of computable terms, we increase the set by applying the deï¬nition.
âˆ…âŠ†S1 âŠ†S2 âŠ†Â· Â· Â· âŠ†Sn âŠ†Sn+1 âŠ†Â· Â· Â·
where Sn+1 is obtained by applying the deï¬nition to Sn. Since the deï¬nition is monotonic, there is a
least ï¬xed point. This process also provides the measure function over the computable terms which
assigns for each computable term M an ordinal Î± where SÎ± is the ï¬rst set which contains M. On the
other hand, we take the greatest ï¬xed point for the deï¬nition of computable terms of ÂµÏ.(Ïƒ1, . . . , Ïƒn).
It is easy to see that
Lemma 2.12: If M is computable, M is strongly normalizing. []
Therefore, all we have to prove is that any typed term is computable. This is proved by structural
induction. One of the lemmas we need is the following.
Lemma 2.13: JÂµÏ.(Ïƒ1,...,Ïƒn),Ï„M1 . . . MnN is computable if M1, . . . , Mn and N are computable
Proof: N is a computable term of ÂµÏ.(Ïƒ1, . . . , Ïƒn). We prove the lemma by induction on the ordinal
associated with N. Because N is computable, N
âˆ—â‡’CiL. Therefore, any reduction sequence of
JM1 . . . MnN should be
JM1 . . . MnN
âˆ—â‡’JM â€²
1 . . . M â€²
n(CiL) â‡’M â€²
i(Ïƒi[JM â€²
1 . . . M â€²
n/Ï]L).
Because the functor Ïƒi only applies JM â€²
1 . . . M â€²
n to a term of ÂµÏ.(Ïƒ1, . . . , Ïƒn) in L whose ordinal is
smaller than that of N (formally, we have to prove this), from induction hypothesis Ïƒi[JM â€²
1 . . . M â€²
n/Ï]L
is computable and M â€²
i(Ïƒi[JM â€²
1 . . . M â€²
n/Ï]L) is computable as well. Therefore, JM1 . . . MnN is com-
putable. []
We have the similar lemmas for PÂµÏ.(Ïƒ1,...,Ïƒn),Ï„ and Î»xÏƒ.M. From these lemmas,
Lemma 2.14: Any typed term is computable. []
Hence, we have proved the strong normalization theorem.
Although we have the strong normalization theorem and the Church-Rosser theorem and, therefore,
the equality of two terms is decidable, this does not mean that the equality of two computable (or
more weakly, primitive recursive) functions is decidable. The equality of lambda terms are deï¬ned by
â€œtwo lambda terms reduce to the same lambda termâ€, but the reduction rules do not capture all the
equality of computable (or primitive recursive) functions. Remember that we deï¬ned ÂµÏ.(Ïƒ1, . . . , Ïƒn)

to be the initial F, G-dialgebra and we put the commutativity of diagrams, but we did not put the
uniqueness, or we could not put it. Therefore, the equality derived from the reduction is weaker. In
other words, if we regard the reduction rules as the operational semantics of our lambda calculus
and the initial and ï¬nal F, G-dialgebras as the denotational semantics, the denotational semantics is
not fully abstract.
3
Examples
In this section, we show some types which we can deï¬ne in our lambda calculus.
Example 3.1: The type corresponding to the initial object is deï¬ned by âˆ…â‰¡ÂµÏ.(). There are
no constructors and Jâˆ…,Ïƒ : âˆ…â†’Ïƒ gives the unique morphism from âˆ…to any type Ïƒ. Dually, the
type corresponding to the terminal object is deï¬ned by 1 â‰¡ÂµÏ.(). There are no destructors and
P1,Ïƒ : Ïƒ â†’1 gives the unique morphism from Ïƒ to 1. There is an element in 1. In fact, there is only
one element in 1 in some sense. Let us write âˆ—for P1,1â†’1Î»x1.x which is an element of 1. Actually,
we can use any element of 1. The choice does not aï¬€ect the computation. []
Example 3.2: The product of two types, Ïƒ and Ï„ can be deï¬ned as Ïƒ Ã— Ï„ â‰¡ÂµÏ.(Ïƒ, Ï„). We have two
projections.
Ï€1 â‰¡DÏƒÃ—Ï„,1
: Ïƒ Ã— Ï„ â†’Ïƒ
Ï€2 â‰¡DÏƒÃ—Ï„,2
: Ïƒ Ã— Ï„ â†’Ï„
If M is a term of type Ïƒ and N is a term of type Ï„, we can deï¬ne a term âŸ¨M, NâŸ©of type Ïƒ Ã— Ï„.
âŸ¨M, NâŸ©â‰¡PÏƒÃ—Ï„(Î»x1.M)(Î»x1.N)âˆ—
: Ïƒ Ã— Ï„
We have the following reduction.
Ï€1âŸ¨M, NâŸ©â‰¡DÏƒÃ—Ï„,1(PÏƒÃ—Ï„,1(Î»x.M)(Î»x.N)âˆ—) â‡’(Î»x.x)((Î»x.M)âˆ—)
âˆ—â‡’M
Similarly, we can show that Ï€2âŸ¨M, NâŸ©
âˆ—â‡’N. However, we do not have
âŸ¨Ï€1M, Ï€2MâŸ©
âˆ—â‡’M
because we did not code the uniqueness condition in our reduction rules. We could have coded
products specially, but then, we lose the generality of our lambda calculus. []
Example 3.3: Dually, the coproduct of Ïƒ and Ï„ is deï¬ned as Ïƒ + Ï„ â‰¡ÂµÏ.(Ïƒ, Ï„). Two injections are
deï¬ned as follows.
Î¹1 â‰¡CÏƒ+Ï„,1
: Ïƒ â†’Ïƒ + Ï„
Î¹2 â‰¡CÏƒ+Ï„,2
: Ï„ â†’Ïƒ + Ï„
JÏƒ+Ï„,Î½ satisï¬es the following reductions.
JÏƒ+Ï„,Î½MN(Î¹1L) â‰¡JÏƒ+Ï„,Î½MN(CÏƒ+Ï„,1L) â‡’M((Î»x.x)L) â‡’ML
JÏƒ+Ï„,Î½MN(Î¹2L)
âˆ—â‡’NL
[]
Example 3.4: Let us deï¬ne the natural numbers in our lambda calculus. The type is deï¬ned by
Ï‰ â‰¡ÂµÏ.(1, Ï).
This deï¬nition is closely connected to the deï¬nition in domain theory where the domain of natural
numbers is deï¬ned as the least ï¬xed point of N âˆ¼= 1 + N. Our Âµ is the least ï¬xed point operator.

The only diï¬€erence is that we use a sequence (1, Ï) instead of coproduct 1 + Ï. Our approach is in
this way connected to algebraic speciï¬cation methods where the type of natural numbers is deï¬ned
as the initial algebra of one constant and one operator. The elements are generated by zero and the
successor function which are deï¬ned in our lambda calculus as follows:
0 â‰¡CÏ‰,1âˆ—
: Ï‰
succ â‰¡CÏ‰,2
: Ï‰ â†’Ï‰
JÏ‰,Ïƒ gives us almost the ordinary iterator but its type is
JÏ‰,Ïƒ
: (1 â†’Ïƒ) â†’(Ïƒ â†’Ïƒ) â†’Ï‰ â†’Ïƒ.
We can deï¬ne the ordinary one by this JÏ‰,Ïƒ as follows.
ËœJÏƒ â‰¡Î»x.Î»y.Î»n.JÏ‰,Ïƒ(Î»z.x)yn
: Ïƒ â†’(Ïƒ â†’Ïƒ) â†’Ï‰ â†’Ïƒ
It satisï¬es the usual reductions:
ËœJÏƒMN0
âˆ—â‡’JÏ‰,Ïƒ(Î»z.M)N(CÏ‰,1âˆ—) â‡’(Î»z.M)((Î»x.x)âˆ—)
âˆ—â‡’M
and
ËœJÏƒMN(succL)
âˆ—â‡’JÏ‰,Ïƒ(Î»z.M)N(CÏ‰,2L) â‡’b(JÏ‰,Ïƒ(Î»z.M)NL) â‰ˆN( ËœJÏƒMNL)
where â‰ˆis the equivalence relation generated by
âˆ—â‡’.
Using ËœJÏƒ, we can deï¬ne all the primitive
recursive functions. For example, the addition function can be deï¬ne as
add â‰¡Î»n.Î»m. ËœJÏ‰m succ n
: Ï‰ â†’Ï‰ â†’Ï‰.
We can demonstrate, for example, add(succ zero)(succ zero)
âˆ—â‡’succ(succ zero). []
Example 3.5: As [11] and [13], we can deï¬ne the type for ordinals by â„¦â‰¡ÂµÏ.(1, Ï‰ â†’Ï). We only
check whether our deï¬nition of the iterator coincides with the ordinary one.
â„¦â‰¡ÂµÏ.(1, Ï‰ â†’Ï)
0â„¦â‰¡Câ„¦,1âˆ—
: â„¦
sup â‰¡Câ„¦,2
: (Ï‰ â†’â„¦) â†’Ï‰
Jâ„¦,Ïƒ
: (1 â†’Ïƒ) â†’((Ï‰ â†’Ïƒ) â†’Ïƒ) â†’â„¦â†’Ïƒ
Jâ„¦,Ïƒ(Î»x.M)N0â„¦â‡’(Î»x.a)((Î»x.x)âˆ—)
âˆ—â‡’M
Jâ„¦,Ïƒ(Î»x.M)N(sup L) â‡’N((Ï‰ â†’Ï)[Jâ„¦,Ïƒ(Î»x.M)N/Ï]L)
â‡’N((Î»y.Î»z.Jâ„¦,Ïƒ(Î»x.M)N(yz))L) â‡’b(Î»z.Jâ„¦,Ïƒ(Î»x.M)N(Lz))
[]
Example 3.6: Finally, the type for ï¬nite lists can be deï¬ned by LÏƒ â‰¡ÂµÏ.(1, Ïƒ Ã— Ï) with
nil â‰¡CLÏƒ,1âˆ—
: LÏƒ
cons â‰¡CLÏƒ,2
: Ïƒ Ã— LÏƒ â†’LÏƒ
JLÏƒ,Ï„
: (1 â†’Ï„) â†’(Ïƒ Ã— Ï„ â†’Ï„) â†’LÏƒ â†’Ï„
whereas the type for inï¬nite lists can be deï¬ned by IÏƒ â‰¡ÂµÏ.(Ïƒ, Ï) with
head â‰¡DIÏƒ,1
: IÏƒ â†’Ïƒ
tail â‰¡DIÏƒ,2
: IÏƒ â†’IÏƒ
PIÏƒ,Ï„
: (Ï„ â†’Ïƒ) â†’(Ï„ â†’Ï„) â†’Ï„ â†’IÏƒ
head(PIÏƒ,Ï„MNL)
âˆ—â‡’ML
tail(PIÏƒ,Ï„MNL)
âˆ—â‡’PIÏƒ,Ï„MN(NL).

The type for inï¬nite lists is quite exciting to play with. The following lambda term gives us the
inï¬nite sequence of zeros
inf â‰¡PIÏ‰,Ï‰(Î»xÏ‰.x)(Î»xÏ‰.x)zero,
whereas the following gives us the inï¬nite increasing sequence 0, 1, 2, 3, . . ..
inc â‰¡PIÏ‰,Ï‰(Î»xÏ‰.x)succ zero
We can merge two inï¬nite sequences by choosing elements alternatively by the following function.
comb â‰¡PIÏƒ,IÏƒÃ—IÏƒ(head â—¦Ï€1)(PIÏƒÃ—IÏƒ,IÏƒÃ—IÏƒÏ€2(tail â—¦Ï€1))
where M â—¦N is Î»x.(M(Nx)). We can demonstrate, for example, that
head(tail(tail(tail(comb inf inc))))
âˆ—â‡’succ(succ zero)
[]
We could give many other examples: boolean, trees, automata, co-natural numbers, . . . .
4
Comparison with Other Lambda Calculi
While writing this paper, the author was communicated to [8, 9] where recursive types are introduced
into ï¬rst-order and second-order typed lambda calculi. They use least ï¬xed points and greatest ï¬xed
points as we do, but their recursion combinator R has a diï¬€erent type from ours.
M : (Ï â†’Ï„) â†’Ïƒ â†’Ï„
RÏƒ,Ï„(M[ÂµÏ.Ïƒ/Ï]) : ÂµÏ.Ïƒ â†’Ï„
The author cannot give a clear connection between our iterator and theirs. In addition, they take
ï¬xed points over a single type expression and, therefore, they need some basic type constructors like
1 and +, whereas in our lambda calculus there are no basic type constructors.
Although we discarded the coproduct and product type constructors from basic type constructors, we
still have one basic type constructor, namely the arrow type constructor Ïƒ â†’Ï„. Since typed lambda
calculi are all about arrow types, it seems impossible to start calculi without it, but from a category
theoretic point of view, the arrow type constructor can be deï¬ned as the right adjoint functor of the
product type constructor so it might possible to start calculi without the arrow type constructor. In
[4], the author showed that the arrow typed constructor can be deï¬ned by F, G-dialgebras, but how
it can be deï¬ned in lambda calculi still has to be investigated.
The second order lambda calculus can be started without basic type constructors and it has been
shown that recursive types which can be deï¬ned by least ï¬xed points of type expressions can be
deï¬ned in the calculus. The coding of recursive types is a generalization of the coding of Church
numerals in untyped lambda calculus. The author does not know whether it is possible to code up
greatest ï¬xed points as well.
5
New ML?
We might say that ML is based on a simply typed lambda calculus as we might say that LISP is
based on the untyped lambda calculus. The type structure of ML depends on the version of ML we
are talking about. If we are talking about the original ML developed with LCF [3], it has some base
types, product, disjoint sum, integer, etc. , and has ability to introduce new types via recursively
deï¬ned type equations. For example, the data type for binary trees whose leaves are integers is
deï¬ned as

absrectype btree = int + (btree # btree)
with leaf n = absbtree(inl n)
and node(t1,t2) = absbtree(inr(t1,t2))
and isleaf t = isl(repbtree t)
and leafvalue t = outl(repbtree t)
and left t = fst(outr(repbtree t))
and right t = snd(outr(repbtree t));;
Here, we need the coproduct type constructor â€˜+â€™ as a primitive. We cannot do without it, whereas
â€˜intâ€™ can be deï¬ned in terms of others primitives (ML has it as a primitive type just because of
eï¬ƒciency).
At the next evolution of ML which yielded the current Standard ML [5], we discovered that the
coproduct type constructor is no longer needed as a primitive.
Standard ML has a â€˜datatypeâ€™
declaration mechanism by which the coproduct type constructor can be deï¬ned as follows:
datatype â€™a + â€™b = inl of â€™a | inr of â€™b;
A datatype declaration lists the constructors of the deï¬ning type. An element of â€˜â€™a + â€™bâ€™ can be
obtained by either applying â€˜inlâ€™ to an element of â€˜â€™aâ€™ or applying â€˜inrâ€™ to an element of â€˜â€™bâ€™. Data
type declarations exactly correspond to our ÂµÏ.(Ïƒ1, . . . , Ïƒn).
datatype â€™a + â€™b =
inl of â€™a | inr of â€™b â‡â‡’Ïƒ + Ï„ â‰¡ÂµÏ.(Ïƒ, Ï„)
inl
â‡â‡’
CÏƒ+Ï„,1
inr
â‡â‡’
CÏƒ+Ï„,2
We can deï¬ne the data type for binary trees in Standard ML as follows.
datatype btree = leaf of int | node of btree * btree;
The symbol â€˜|â€™ is just like â€˜+â€™, but we shifted from the object level of the language to the syntax
level. Note that we no longer need the separate deï¬nition of â€˜leafâ€™ or â€˜nodeâ€™. We can deï¬ne the
other functions using case statements.
exception btree;
fun isleaf t = case t of
leaf _ => true
| node _ => false;
fun leafvalue t = case t of
leaf n => n
| node _ => raise btree;
fun left t = case t of
leaf _ => raise btree
| node(t1,t2) => t1;
fun right t = case t of
leaf _ => raise btree
| node(t1,t2) => t2;

We get rid of the coproduct type constructor from the primitives, but Standard ML still needs the
product type constructor.
From a category theoretic point of view, we can sense asymmetry in
the type structure of Standard ML. Let us remember that our lambda calculus needs neither the
coproduct type constructor nor the product type constructor as a primitive. We should be able to
introduce the symmetry of our lambda calculus into ML. Let us imagine the next stage of the ML
evolution and deï¬ne Symmetric ML.
Primitives
Declaration Mechanism
ML
->, unit, #, +
abstype
Standard ML
->, unit, *
datatype
Symmetric ML
->
datatype, codatatype
CPL in [4]
left object, right object
ML Evolution
Remember that datatype declarations correspond to ÂµÏ.(Ïƒ1, . . . , Ïƒn). We list constructors for types.
In order to get rid of the product type constructor from primitives, we should have a declaration
mechanism which corresponds to ÂµÏ.(Ïƒ1, . . . , Ïƒn). Its syntax is
codatatype TypeParam TypeId =
Id is TypeExp & ... & Id is TypeExp;
A codatatype declaration introduces a type by listing its destructors. The product type constructor
can now be deï¬ned as follows:
codatatype â€™a * â€™b = fst is â€™a & snd is â€™b;
where â€˜fst : â€™a * â€™b -> â€™aâ€™ gives the projection function to the ï¬rst component and â€˜snd : â€™a * â€™b ->
gives the projection function to the second component. If the declaration is recursive, we do not
take the initial ï¬xed point of the type equation but the ï¬nal ï¬xed point. This is ï¬rstly because of
symmetry and secondly because the initial ï¬xed points are often trivial. Because of this, we can
deï¬ne inï¬nite objects by codatatype declarations. For example, the following declaration gives us
the data type for inï¬nite lists.
codatatype â€™a inflist = head is â€™a & tail is â€™a inflist;
If we took the initial ï¬xed point, we would get the empty data type.
The deï¬nition is exactly
corresponds to IÏƒ â‰¡ÂµÏ.(Ïƒ, Ï).
Obviously we have destructors for co-data types because we declare them, but how can we construct
data for co-data types? We had case statements for data types, so we have â€˜mergeâ€™ statements as
dual. Its syntax is
merge Destructor <= Exp & ... & Destructor <= Exp
For example, the function â€˜pairâ€™ which makes a pair of given two elements can be deï¬ned as follows.
fun pair(x,y) = merge fst <= x & snd <= y;
As a more complicated example, we might deï¬ne a function which combines two inï¬nite lists together.
fun comb(l1,l2) = merge head <= head l1

& tail <= comb(l2,tail l1);
As we use pattern matching to declare functions over data types, we can also use it to declare
functions over co-data types. For example, an alternative deï¬nition of â€˜combâ€™ may be
fun head comb(l1,_) = head l1
& tail comb(l1,l2) = comb(l2,tail l1);
Conclusions
We have introduced a simply typed lambda calculus with categorical type constructors and demon-
strated that we can deï¬ne various types which had been deï¬ned as primitives before. Therefore, our
normalization theorem covers the normalization theorems for other simply typed lambda calculi: a
typed lambda calculus with natural numbers, a typed lambda calculus with ordinals, and so on.
The lambda calculus we presented in this paper is a direct derivation of authorâ€™s work on a Categorical
Programming language [4] where a functional programming language CPL has been introduced. CPL
is a categorical-combinator-style programming language which has a uniform categorical datatype
declaration mechanism. CPL is more general than the lambda calculus we presented here in a sense
that CPL does not need â†’to be a primitive type constructor. It can deï¬ne it as the right adjoint of
the product functor. It seems that the diï¬€erence comes out from the fact that the category theory
distinguish morphisms from elements of exponential types, whereas lambda calculi not. In lambda
calculi (or functional programming languages based on lambda calculi), functions are always treated
as closures.
An experimental version of CPL has been implemented. Whether the codatatype declaration mech-
anism will be adopted to ML or not remains to be seen, but the author believes that it is an elegant
answer to lazy types in ML.
The connection between initial ï¬xed points and ï¬nal ï¬xed points is quite interesting to investigate.
For example, the type of natural numbers as the initial ï¬xed point of N âˆ¼= 1 + N is associated with
primitive recursion, whereas the type of natural number as the ï¬nal ï¬xed point of the same equation
(we call it co-natural number object) is associated with general recursion.
Neither the lambda calculus we deï¬ned here nor CPL has not yet been mixed with dependent types.
This has to be investigated in the future.
Acknowledgements
The author would like to thank Furio Honsell who led me to the world of lambda calculi from the
world of category theory.
References
[1] Arbib, M. A. and Manes, E. G.: The Greatest Fixed Points Approach to Data Types. In proceed-
ings of Third Workshop Meeting on Categorical and Algebraic Methods in Computer Science and
System Theory, Dortmund, West Germany, 1980.

[2] Curien, P-L.: Categorical Combinators, Sequential Algorithms and Functional Programming. Re-
search Notes in Theoretical Computer Science, Pitman, 1986.
[3] Gordon, M. J., Milner, A. J. and Wordsworth, C. P.: Edinburgh LCF. Lecture Notes in Computer
Science, Volume 78, 1979.
[4] Hagino, T.: Category Theoretic Approach to Data Types. Ph. D. thesis, University of Edinburgh,
1987.
[5] Harper, R., MacQueen, D. and Milner, R.: Standard ML. LFCS Report Series, ECS-LFSC-86-2.
Department of Computer Science, University of Edinburgh, 1986.
[6] Lambek, J. and Scott, P. J.: Introduction on Higher-Order Categorical Logic. Cambridge Studies
in Advanced Mathematics, Volume 7, 1986.
[7] Lehmann, D. and Smyth, M.: Algebraic Speciï¬cation of Data Types â€“ A Synthetic Approach â€“.
Mathematical System Theory, Volume 14, pp. 97â€“139, 1981.
[8] Mendler N. P.: First- and Second-Order Lambda Calculi with Recursive Types. Technical Report
TR 86-764, Department of Computer Science, Cornell University, 1986.
[9] Mendler N. P.: Recursive Types and Type Constraints in Second-Order Lambda Calculus. 1986.
[10] Smyth, M. B. and Plotkin, G. D.: The Category-Theoretic Solution of Recursive Domain Equa-
tions. SIAM Journal of Computing, Volume 11, 1982.
[11] Stenlund, S.: Combinators, Î»-Terms and Proof Theory. D. Reidel, Dordrecht, 1972.
[12] Tait, W.: Intentional Interpretation of Functionals of Finite Type I. Journal of Symbolic Logic,
32, pp. 198â€“212, 1967.
[13] Troelstra, A. S.: Mathematical Investigation of Intuitionistic Arithmetic and Analysis. Lecture
Notes in Mathematics, Volume 344, Springer-Verlag, 1973.

