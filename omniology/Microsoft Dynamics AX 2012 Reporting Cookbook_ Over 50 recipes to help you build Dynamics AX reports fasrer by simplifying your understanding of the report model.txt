www.allitebooks.com

Microsoft Dynamics 
AX 2012 Reporting 
Cookbook
Over 50 recipes to help you build Dynamics AX 
reports faster by simplifying your understanding 
of the report model
Kamalakannan Elangovan
   BIRMINGHAM - MUMBAI
www.allitebooks.com

Microsoft Dynamics AX 2012 Reporting 
Cookbook
Copyright © 2013 Packt Publishing
All rights reserved. No part of this book may be reproduced, stored in a retrieval system, 
or transmitted in any form or by any means, without the prior written permission of the 
publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the 
information presented. However, the information contained in this book is sold without 
warranty, either express or implied. Neither the author, nor Packt Publishing, and its 
dealers and distributors will be held liable for any damages caused or alleged to be 
caused directly or indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the 
companies and products mentioned in this book by the appropriate use of capitals. 
However, Packt Publishing cannot guarantee the accuracy of this information.
First published: September 2013
Production Reference: 1170913
Published by Packt Publishing Ltd.
Livery Place
35 Livery Street
Birmingham B3 2PB, UK.
ISBN 978-1-84968-772-0
www.packtpub.com
Cover Image by Prashant Timappa Shetty (sparkling.spectrum.123@gmail.com)
www.allitebooks.com

www.allitebooks.com

About the Author
Kamalakannan Elangovan has over eight years of development experience in 
Dynamics AX. He shares a passion for product development and has pioneered multiple 
ISV solutions on Dynamics AX. In the past he worked with Innovites to create the first 
multidimensional ISV solution for cable industries called "Innovites for cable". Building the 
solution from scratch, he has gained great insights into building, selling, and promoting the 
product among customers and partners in the Microsoft Ecosystem. You can learn more 
about him at http://about.me/casperkamal.
He is enthusiastic about sharing his learning with the community which led him to create 
one of the first few blogs for AX in 2006. It is currently available at http://kamalblogs.
wordpress.com. He is active through twitter and the community, popularly by his 
pseudonym Casperkamal.
First of all, I would like to thank my wife Sangeetha and my little daughter 
Anu for their considerable support during the long hours I have put behind 
this book. I also want to apologize for the time I have stolen from them to 
invest in this book.

Thanks to Dhangar Naveen who has spent considerable hours working 
along with me in making the examples involved in each recipe.

Special thanks to the wonderful team at Packt who have patiently guided 
and supported me in making this book a reality.

Also, a big thanks to the readers of my blog, my fellow bloggers, and the 
Dynamics AX community who have directly and indirectly inspired me in 
this work.

This book is dedicated to Dick De Jong, who selflessly mentored and trained 
me in the art of software development.
www.allitebooks.com

About the Reviewers
Deepak Agarwal [B.Tech, MBA] is a Technical Consultant and has been working 
professionally on Dynamics AX since 2011. He is a team member of the very first AX project 
in the Manufacturing Domain. Though his strengths are rooted in X++ development, he is 
a highly regarded developer and has solid knowledge of technical aspects of Dynamics AX 
and X++ reporting.
Deepak blogs on Dynamics AX on his blog http://theaxapta.blogspot.in/.
A big thanks to my dear sister Khushbu Agarwal for her support and 
understanding of my long hours spent on this work.
Emad Mokhtar Habib is a passionate and an enthusiastic software developer, loves to 
learn new technologies, and is always seeking for the better to be the best. He has worked 
with many Microsoft partners. He is builds software to improve and help businesses. He runs 
a professional and technical blog, EmadMokhtar.com, and shares his thoughts and readings 
on Twitter and LinkedIn. He is working for Arabesque Group now and as a freelance Web 
Developer.
I want to thank my lovely wife who helped me in reviewing this book and 
always took care of me and my environment. I also want to thank my family 
and friends for motivating me and always pushing me to do my best.
www.allitebooks.com

Umesh Pandit is a Techno Functional Consultant with KPIT Cummins Infosystems Ltd. 
He has done Masters of Computer Applications with first division, having specialization in 
ERP from Ideal Institute of Technology, Ghaziabad.
He has worked with the top IT giants, such as Google India and Cap Gemini India. He has 
a deep understanding of ERP systems, such as Microsoft Dynamics AX. He has worked with 
different versions of Axapta, such as AX 3.0, AX 4.0, AX 5.0 (AX 2009), and AX 6.0 (AX 2012). 
He has a vast knowledge of Microsoft Technologies, such as SQL, CRM, TFS, Office, Windows 
Server 2008, Windows Server 2003, Office 365, Microsoft Dynamics NAV, SSRS, SSAS, VSS, 
and VCS.
I would like to thank my friend Pramila, who encouraged me in this passion.
Nasheet Ahmed Siddiqui has studied Computer Science at the University of Karachi, 
Pakistan. He has over seven years of consulting experience, playing a variety of roles, including 
Software Engineer, Senior Software Engineer, Team lead, and Technical Consultant in Dynamics 
AX and Microsoft technologies.
He started working in 2006 for e-Creatorz, where he was developing and managing 
web applications. He started his Dynamics AX career with MazikGlobal (a subsidiary of 
Tyler Technology Ltd, U.S.A and Microsoft Corporation). He was the core developer in the 
development of the Dynamics AX 2012 and AX 2012 R2 features for Microsoft. He was 
directly involved with the Microsoft team to build the features for the AX 2012 and AX 2012 
R2. Since 2012, he has been working for Othaim Markets, where he is responsible for the 
customizations, development, and implementation of new verticals (Property Management 
System and Maintenance Management System).
He has a solid knowledge of and skills in technical aspects of Dynamics AX 2009 and 2012. He 
is also working as a freelance Dynamics AX Technical Consultant. He has provided development 
services to many organizations in Pakistan, Saudi Arabia, and Canada. He is also a Microsoft 
Certified Professional (MCP) for Dynamics AX Development and MorphX Solution Development.
He lives in Riyadh, KSA with his family. He is always happy to share useful AX development 
tricks on his blog (nasheet.wordpress.com). He can be contacted via LinkedIn at 
http://sa.linkedin.com/in/nasheet.
www.allitebooks.com

Saptha Wanniarachchi is a certified and experienced IT professional from Sri Lanka 
with quite extensive professional experience, in particular with Microsoft Dynamics-based 
Business Solutions. She is currently employed with SML, Sri Lanka, an international global 
branding and packaging company. She takes particular pride in her ability in infrastructure 
design and implementations for Microsoft Dynamics AX/NAV ERP Systems, system 
automation, and CRM solutions.
She has worked on the book:
f
f
Microsoft Dynamics AX 2012 Security How-To
www.allitebooks.com

www.allitebooks.com

Table of Contents
Preface	
1
Chapter 1: Understanding and Creating Simple SSRS Reports	
5
Introduction	
5
Reporting overview	
6
Using a query as a datasource in a report	
6
Creating an auto design from a dataset	
11
Grouping in reports	
14
Adding ranges to the report	
15
Deploying the report	
17
Creating a menu item for the report	
19
Chapter 2: Enhancing Your Report – Visualization and Interaction	
23
Introduction	
24
Creating multiple data regions and charts in reports	
24
Creating a chart data region	
27
Creating a new layout template	
29
Expressions in layouts	
32
Aggregation in reports	
35
Adding an image in auto design	
36
Formatting reports	
38
Adding unbounded parameters in reports	
39
Adding filters to data regions	
42
Adding a document map navigation to reports	
44
Adding a drill up/drill down navigation to reports	
45
Chapter 3: A Report Programming Model	
47
Introduction	
48
Opening a report through a controller	
48
Modifying the report query in the controller	
52
www.allitebooks.com

ii
Table of Contents
Adding ranges from unbound parameters to the query	
53
Modifying the UI by caller	
60
Turning off the report dialog	
62
Setting up security for reports	
62
Calling multiple reports from a controller	
63
Debugging a report model	
65
Adding data methods in business logic	
66
Adding a URL drill-through action in reports	
68
Debugging business logic	
70
Unit testing business logic	
70
Chapter 4: Report Programming Model – RDP	
73
Introduction	
73
Creating a simple RDP report	
74
Testing the RDP	
80
Creating a simple precision design	
81
Creating an advanced RDP report	
85
Creating a group view report	
92
Adding headers and displaying company images	
98
Using an existing temp table in RDP	
100
Preprocessing reports	
104
Chapter 5: Integrating External Datasources	
107
Introduction	
107
Adding a datasource through business logic	
108
Using an XML feed as a datasource	
112
Building a parameter lookup using business logic	
115
Building a report through an external datasource	
120
Adding a parameter for an external datasource query	
124
Creating a customer summary OLAP report	
125
Adding a parameter lookup for OLAP	
129
Designing an OLAP table report with SQL Report Builder	
136
Designing a map subreport with SQL Report Builder	
145
Creating a subreport in auto design	
154
Creating a subreport in precision design	
157
Chapter 6: Beyond Tabular Reports	
161
Introduction	
161
Creating a matrix report	
162
Creating a multicolumn matrix report	
168
Creating a column chart report 	
172
Creating a line chart	
176

iii
Table of Contents
Gauges in reports	
182
List and rectangle controls in reports	
186
Adding reports to the role centre	
191
Chapter 7: Upgrading and Analyzing Reports	
195
Introduction	
195
Upgrading a report from the previous version	
196
Analyzing and modifying an existing report	
201
Implementing validation in reports	
205
Surrogate fields in reports	
208
Grouping and ordering controls in a report dialog	
213
RDP with multiple temporary tables	
220
Multi-value lookup	
222
Inventory dimensions in reports	
226
Financial dimensions in reports	
229
Financial dimensions in RDP reports	
232
Chapter 8: Troubleshooting and Other Advanced Recipes	
241
Introduction	
242
Assessing report performance and usage	
242
Handling long running reports in AX	
246
Troubleshooting reports in AX	
252
Auto e-mail and Save as file tasks in reports	
260
Handling events post report completion	
262
Generating and displaying barcodes in reports	
264
Hiding controls by context	
274
Using AXEnumProvider as the dataset for parameters in reports	
276
Adding a new report design to print management	
278
Deploying language-specific reports to speed up execution time	
280
Making your reports function better	
281
Appendix: Introduction to SSRS	
283
Introduction	
283
Why SSRS?	
283
Reporting architecture	
284
Dynamics AX reporting extensions	
285
AX 2009 versus AX 2012	
287
Understanding AX reports	
288
Installation and configuration checklist	
291
Index	
293


Preface
Reporting capabilities are the turn-key decision makers for choosing an ERP system. They 
cater from the low-level shop floor users to the board room members giving them the right 
insight into their business. That is one of the many reasons why report customizations 
dominate at customer implementations. Strengthening your reporting capabilities as a 
Developer not just makes you but also the users of your report confident than ever.
Microsoft Dynamics AX 2012 is a phenomenal release that took AX to a different breadth 
and depth. The SSRS has brought in huge thrust to the leap forward. This book has been 
written to help you understand and acquire the skills necessary to be good at Reporting 
based on SSRS.
What this book covers
Chapter 1, Understanding and Creating Simple SSRS Reports, walks you through creating 
a basic report that introduces you to several basic features of Dynamics AX reports.
Chapter 2, Enhancing Your Report – Visualization and Interaction, focuses on further 
controlling and improving your report through parameters, data regions, expressions, 
new report and style templates.
Chapter 3, A Report Programming Model, helps you in understanding the programmatic 
model of the reporting framework inside AX and introduces you to programmatically 
modifying report UI and validations.
Chapter 4, Report Programming Model – RDP, delves into creating advanced reports 
using the new report data contract framework. It also details how to design reports 
through Precision Design.
Chapter 5, Integrating External Datasources, showcases how reports can be extended 
beyond AX to include other data sources, such as Cubes, XML Cloud Service, or through 
the integrations framework.

Preface
2
Chapter 6, Beyond Tabular Reports, dives in to using the other types of report formats, such 
as chart and matrix reports. It further details the use of other interesting controls, such as 
gauges, lists, and rectangles with clearly drafted examples.
Chapter 7, Upgrading and Analyzing Reports, shows you the approach to adopt when moving 
reports from MorphX-based reports to SSRS and discusses several repeated customization 
patterns in reports.
Chapter 8, Troubleshooting and Other Advanced Recipes, is a collection of assorted topics 
that can be applied to your SSRS reports, such as deploying through your code, using Enum 
provider and localization of reports. This chapter also introduces you to the log viewer through 
which you can analyze and identify report usage, report logs, and more.
Appendix, Introduction to SSRS, will help you run through the basic architecture of AX SSRS, 
followed by a brief introduction to different reporting components and the comparative 
advantage over the legacy reporting system from the previous releases of Dynamics AX.
What you need for this book
To practice the content in this book, you need the following software:
f
f
Microsoft Dynamics AX 2012
f
f
SQL Server Reporting Services
f
f
SQL Server Analysis Services
f
f
Microsoft Visual Studio 2010
Alternatively, you can use the Virtual Image available for Microsoft Dynamics AX 2012/AX 
2012 R2 through Microsoft Learning Download Center.
Who this book is for
This book aims at IT administrators looking to get their hands on to develop their own reports 
for their internal demands and for X++ developers who want to deepen their understanding of 
SSRS reports.
This book requires some basic knowledge of Microsoft Dynamics AX 2012, X++, and MorphX. 
Some examples are based on C# and .NET. However, they are not must to read this book.
Conventions
In this book, you will find a number of styles of text that distinguish between different kinds 
of information. Here are some examples of these styles, and an explanation of their meaning.


Preface
4
Customer support
Now that you are the proud owner of a Packt book, we have a number of things to help you to 
get the most from your purchase.
Downloading the example code
You can download the example code files for all Packt books you have purchased from your 
account at http://www.packtpub.com. If you purchased this book elsewhere, you can 
visit http://www.packtpub.com/support and register to have the files e-mailed directly 
to you.
Errata
Although we have taken every care to ensure the accuracy of our content, mistakes do happen. 
If you find a mistake in one of our books—maybe a mistake in the text or the code—we would be 
grateful if you would report this to us. By doing so, you can save other readers from frustration 
and help us improve subsequent versions of this book. If you find any errata, please report them 
by visiting http://www.packtpub.com/submit-errata, selecting your book, clicking on 
the errata submission form link, and entering the details of your errata. Once your errata are 
verified, your submission will be accepted and the errata will be uploaded on our website, or 
added to any list of existing errata, under the Errata section of that title. Any existing errata 
can be viewed by selecting your title from http://www.packtpub.com/support.
Piracy
Piracy of copyright material on the Internet is an ongoing problem across all media. At Packt, 
we take the protection of our copyright and licenses very seriously. If you come across any 
illegal copies of our works, in any form, on the Internet, please provide us with the location 
address or website name immediately so that we can pursue a remedy.
Please contact us at copyright@packtpub.com with a link to the suspected pirated material.
We appreciate your help in protecting our authors, and our ability to bring you valuable content.
Questions
You can contact us at questions@packtpub.com if you are having a problem with any 
aspect of the book, and we will do our best to address it.



Chapter 1
7
7.	
Go to the Fields node under the InventTable datasource and set the Dynamic 
property to Yes. This will automatically add all the fields in the InventTable to the 
query. Now set the property back to No. This is an easy way to add fields to the 
query node, alternatively, the property can be kept No and the fields can be 
dragged-and-dropped from the actual table.
8.	 Drop all fields except Item, ItemType, and Namealias. This optimizes the query 
and consequently the fetch time:
9.	 Save the query.
10.	 Open Visual Studio.
11.	 Navigate to File | New | Project.
12.	In the new project dialog, click on Microsoft Dynamics AX and then Report Model.
www.allitebooks.com

Understanding and Creating Simple SSRS Reports
8
13.	Set the name as PKTReleasedProducts:
14.	 Now right-click on the project and click on Add PKTRelasedProducts to AOT.
15.	On the reporting model, right-click, select Add and choose Report.
16.	 Rename the report as PKTReleasedProductsReport.
17.	 Go to the Datasets node and right-click on Add Dataset:

Chapter 1
9
18.	Name the dataset as Products.
19.	Right-click on the dataset and open the properties.
20.	Click on the ellipsis (…) button in the query. 
21.	 This opens a dialog with all queries in AOT:

Understanding and Creating Simple SSRS Reports
10
22.	Select the query that was created for the report PKTReleasedProducts and click 
on Next:
23.	Select All Fields, since we dropped all the unwanted fields during the creation 
of the query.
24.	 Go to the All Display Methods node and select the inventUnitId, itemGroupId, 
and itemName methods and click on OK.
25.	This will generate the fields list for the dataset. This completes the addition of 
the dataset to the report.


Understanding and Creating Simple SSRS Reports
12
How to do it...
You can create an auto design from a dataset, as follows:
1.	 Right-click on the Designs node, select Add and then Auto Design. This creates a 
new auto design and name it as Released Products.
2.	 On the Properties node, set the property layout to ReportLayoutStyleTemplate.
3.	 Set the title property to Released Products:
4.	 Right-click on the new Released Product auto design node, navigate to Add | Table:




Understanding and Creating Simple SSRS Reports
16
3.	 In the Visual Studio project right-click on Datasets and click on Refresh.
4.	 The parameter Products_DynamicParameter collectively represents any 
parameters that will be added dynamically through the ranges. This parameter 
must be set to True to make additional ranges available during runtime. This 
adds a Select button to the report dialog, which the user can use to specify 
additional ranges other than what is added:
5.	 Right-click on the auto design ReleasedProducts and select Preview. The preview 
should display the range that was added in the query.
How it works...
The report dialog uses the query service UI builder to translate the ranges and to expose 
additional ranges through the query.

www.allitebooks.com



Understanding and Creating Simple SSRS Reports
20
2.	 Open the menu item to run the report. A dialog is shown, the range Search Name 
added in the query appears followed by a Select button. The Select button is similar 
to the MorphX reports option where the user can specify additional conditions. To 
disable the select option go to the Dynamic Filter property in the dataset and 
set it to false.



2
Enhancing Your Report 
– Visualization and 
Interaction
We will look into the following recipes in this chapter:
f
f
Creating multiple data regions and charts in reports
f
f
Creating a chart data region
f
f
Creating a new layout template
f
f
Expressions in layouts
f
f
Aggregation in reports
f
f
Adding an image in auto design
f
f
Formatting reports
f
f
Adding unbound parameters in reports
f
f
Adding filters to data regions
f
f
Adding a document map navigation to reports
f
f
Adding a drill up/drill down navigation to reports


Chapter 2
25
2.	 Open Visual Studio and create a new Report Model Project named 
PktCustTransReport and create a dataset that refers to the 
PktCustTransList query.
3.	 When selecting the fields in the query window, select all the fields and the 
name data method from CustTable.
How to do it…
Multiple data regions can be created as follows:
1.	 Drag the CustTrans dataset to the auto design node. This will create a Table 
design layout.
2.	 The grouping ability of the data regions helps in presenting the data effectively, 
by ordering and organizing them.

Enhancing Your Report – Visualization and Interaction
26
3.	 Drag the CustGroup field to the Group on node and then drag the AccountNum 
field to the Group on node from the dataset.
4.	 Expand the Group on node and navigate to the Row property and drag the field's 
Currency, Party_Name to the AccountNum group node.
5.	 Grouping helps in rendering the data in a summarized view. The order of the 
grouping property determines the order in which they are summarized. In this 
case, the grouping is done by the customer group followed by the customer:
6.	 Preview the report and see how multiple groupings look in action:


Enhancing Your Report – Visualization and Interaction
28
4.	 Set the following properties for the AmountMST control:
Property
Value
Caption
=SUM(Fields!AmountMST.Value)
Expression
=SUM(Fields!AmountMST.Value)
Point Label
="Group =" + Fields!CustGroup.Value
5.	 From the dataset select the CustGroup field and drop it in the Series node under 
the chart:
6.	 Start the preview, and the preview will show the chart followed by the table 
(The order is based on the position of data regions under the auto design.):


Enhancing Your Report – Visualization and Interaction
30
4.	 There is no inheritance concept among templates, each template is independent 
and must define the entire formatting.
5.	 Double-click on the template to open the editor and rename it as 
PktTableStyleFancyTemplate.
6.	 In the current report design, there are two levels of groupings defined, CustGroup 
followed by AccountNum.
7.	
To set the fonts for both the levels, the GroupLevel1Style and GroupLevel2Style 
nodes must be modified.
8.	 Expand GroupLevel1Style and double-click on the FieldCaptionStyle node to open 
the following form (Alternatively open the property window):

Chapter 2
31
9.	 Set the following properties for both the nodes:
Property
Value
Font | Family
Verdana
Font | Size
8 pt
Borders and Fill | Style
Dashed
10.	 Repeat the same procedure for FieldValueStyle node and set the properties except 
for the last one which is not needed.
11.	 The template is set for the groupings. The next step is to set the template for the 
detailed rows.
12.	Navigate to the DetailRowStyle | FieldCaptionStyle and set the following properties:
Property
Value
Font | Family
Verdana
Font | Size
8 pt


Chapter 2
33
How to do it…
Expressions can be implemented in the report, as follows:
1.	 On the template, select the node DetailRowStyle | FieldValueStyle.
2.	 For the Background Color property, choose the Expression list:
3.	 The expression window opens.
4.	 Type the following expression in the expression window:
=iif(RowNumber(Nothing)mod 3, "#e0e0e0", "#ffe0c0")
5.	 Save the template and go back to the PktCustTransList report for a preview.
6.	 The report should now appear with a different color on every third line when previewed.




www.allitebooks.com



Enhancing Your Report – Visualization and Interaction
40
How it works…
Parameters are the means to get user inputs into reports. The parameters for an SSRS report 
can be found under the parameters node in the report.
There are two kinds of parameters here:
System parameters
These are parameters that start with AX_ and are defined by the 
system for internal purposes, but can be made visible to the user 
based on the requirement, except for the AX_UserContext 
parameter.
User-defined 
parameters
Parameters that are defined in the dataset and any other parameters 
that are added are referred as user-defined parameters.
System parameter
System parameters are hidden by default and have a default value, which is defined through 
the expression. For example, the AX_CompanyName parameter has the following expression 
filled in by default:
=Microsoft.Dynamics.Framework.Reports.
  BuiltInMethods.GetUserCompany(Parameters!AX_UserContext.Value)
The system parameters consist of the following:
Parameter
Function
User Modification
AX_CompanyName
Indicates the company from which 
data is to be fetched.
Allowed
AX_RenderingCulture
Language in which the report is 
rendered, for example, English.
Allowed
AX_ReportContext
Indicates if the report is running on 
EP or client.
Allowed
AX_UserContext
User who runs the report.
Not Recommended
AX_PartitionKey
Defines the active partition for the 
report.
Not Allowed
User-defined parameters
Further there are two types under user-defined parameters, the bounded and unbounded 
parameter.
Bounded Parameters
Parameters that are connected to a dataset are identified as bounded parameters. If a dataset 
is linked to a query, then the parameters are automatically created from the fields that are 
added to the Ranges node in the AOT query.



Chapter 2
43
5.	 The data region displays only the data for which the expression evaluates to 1.
6.	 Now that the report is finally over, select preview and activate the parameters tab. 
The parameters that were added are visible along with the standard parameters. 
Verify the parameters through the report preview.
7.	
The report is now ready to be deployed. The deployed report dialog should appear 
as shown:
8.	 The deployed report will show up as seen here in the image.




3
A Report 
Programming Model
We will look at the following 12 recipes in this chapter:
f
f
Opening a report through a controller
f
f
Modifying the report query in the controller
f
f
Adding ranges from unbound parameters to the query
f
f
Modifying the UI by caller
f
f
Turning off the report dialog
f
f
Setting up security for reports
f
f
Calling multiple reports from a controller
f
f
Debugging a report model
f
f
Adding data methods in business logic
f
f
Adding a URL drill-through action in reports
f
f
Debugging business logic
f
f
Unit testing business logic


Chapter 3
49
4.	 Go to the Parameters node in the report and add the following unbound parameters:
Name
Type
Property "Nullable"
FromDate
DateTime
True
ToDate
DateTime
True
ShowApproved
Boolean
True
5.	 Build and deploy the report to AX.
6.	 Create a class PktRdlCustTransController that extends the 
SRSReportRunController class.
7.	
Add a new main method as shown:
public static void main(Args args)
{
  PktRdlCustTransController srs;  
  
  srs = new PktRdlCustTransController ();
  srs.parmReportName(ssrsReportStr(PktRdlCustTransList, 
    CustTransList));
  srs.parmArgs(args);
  srs.startOperation();
}
8.	 The new controller class is now capable of running the report. Press F5 to test run 
the report.
How it works...
Though we have added only a few lines of code to identify our report, the whole process flows 
without obstructions. This is orchestrated by the SSRSReportRunController class that 
is extended by the controller created in this recipe. The detailed description should help you 
understand the report programming model.

A Report Programming Model
50
Report programming model
The report programming model in AX 2012 adopts mainly the MVC pattern to be able to 
decouple the user interface and business logic. An MVP pattern, in simple terms, improves 
abstraction and creates clarity on responsibilities; consequently, it brings down the growing 
complexity caused by mashing up the logic that drives the user interface and the business 
logic. The Runbase framework in AX 2009 is an example of how business logic and UI are 
put together in the patterns adopted by legacy systems.
The MVC pattern, when applied to a reporting framework, would distribute the responsibilities 
as specified here:
f
f
View: This represents the visualization of the report.
f
f
Model: This represents the data that is generated by processing the parameters.
f
f
Controller: This represents the parameters and UI builders that will be used to 
generate the report.
Model
A model for the SSRS report can be an AOT query, Report data provider (RDP), 
or business logic.
AOT query are queries modeled using the MorphX IDE, while RDPs are classes that extend 
SRSReportDataProvider. An RDP model is used where complex business logic is involved 
in computing the data to be rendered. The data is modeled from different sources before 
being sent to the report.

Chapter 3
51
Controller
The controller implementation in a report is through a group of classes that are bound under 
the report controller.
f
f
Report controller: This is the main controller that binds different contract classes and 
controls the execution of the report starting from parsing the report RDL, binding the 
contracts and UI builder classes to the report, rendering the UI, invoking the report 
viewer, and post-processing actions after the report is rendered. It is implemented 
by the base class SSRSReportRunController and can be extended to apply 
report-specific controls.
The report controller uses different contract class, each aimed at different purposes. 
All contracts involved in a report are referenced through the report data contract.
f
f
Report data contract: Implemented by SRSReportDataContract, this is the class 
that holds the different contracts used in a report. Each contract has its designated 
access method, such as ParmQueryContract and ParmRDLContract, in the 
report data contract class. Here is a list of contracts present in a report data contract:
Name
Purpose
RDLDataContract
SRSReportRDLDataContract
Contract provider that holds all the 
parameters related to the report, 
including the system parameters, 
such as company, report context, 
and user context
RDPDataContract
Contract provider for an RDP class. 
Holds the parameters related to the 
RDP class
Query Contract
Manages parameters for a query, 
including the dynamic filters and 
static ranges
PrintingContract
SRSPrintDestinationSettings
Provider manages the print settings, 
such as destination and format
f
f
Report UI builder: This is another controller class that is responsible 
for building the UI, based on the related contracts. Implemented 
by SRSReportDataContractUIBuilder, this class extends the 
SysOperationAutomaticUIBuilder and can be modified for report-specific 
implementation, overridden to handle UI events, such as validate, and modified.
View
The report model, or the design is the representation of the View and it is designed through 
the Visual Studio extension for Dynamics AX. Designing a report model was discussed in the 
previous chapters.



A Report Programming Model
54
How to do it...
1.	 The first step is to create a contract and a UI builder class and bind them together. 
(Assuming you have created the parameters as discussed in the first recipe, Opening 
a report through a controller.)
2.	 Add a UIBuilder class that extends SRSReportDatacontractUIBuilder:
class PktRdlCustTransListUIBuilder extends 
  SrsReportDataContractUIBuilder
{
}
3.	 Add a contract class that extends SRSReportRdlDataContract:
[
  SrsReportNameAttribute(ssrsReportStr(PktRdlCustTransList, 
    CustTransList)),
  
    SysOperationContractProcessingAttribute
    (classstr(PktRdlCus
    TransListUIBuilder), 
    SysOperationDataContractProcessingMode::
    CreateSeparateUIBuilderForEachContract)
]
class PktRdlCustTransListRdlContract extends 
  SrsReportRdlDataContract
{
  TransDate   fromDate;
  TransDate   toDate;
  #define.FromDate('FromDate')
  #define.ToDate('ToDate')
}
4.	 The next step is to show these values in the UI. If the report is previewed in 
Visual Studio, the FromDate and ToDate parameters appear as shown in 
the following screenshot. This may not be a convenient way for the end user 
to specify the date ranges.

Chapter 3
55
5.	 To add the date fields to the report dialog, add the following method and call it 
from the overridden method PktRdlCustTransListUIBuilder\build.
class PktRdlCustTransListUIBuilder extends 
  SrsReportDataContractUIBuilder
{
  DialogField dialogFromDate;
  DialogField dialogToDate;
  
  //identifier text for retrieving the value 
  //from the parameter map in RDL data contract
  //The names must match the name provided in the report
  model
  #define.FromDate('FromDate')
  #define.ToDate('ToDate')
  #define.ShowApproved('ShowApproved')
}
private void addDateFields()
{
  dialog                          dialogLocal;
  PktRdlCustTransListRdlContract  transContract;
  dialogLocal    = this.dialog();
  transContract  = 
  this.getRdlContractInfo().dataContractObject() 
  as PktRdlCustTransListRdlContract;
  
  dialogFromDate  = dialogLocal.
  addFieldValue(
  extendedTypeStr(FromDate),
  //set the value from the contract. 
  //is equivalent of unPack and initialzie in ax 2009
  DatetimeUtil::date(transContract.getValue(#FromDate)),
  "@SYS5209");

A Report Programming Model
56
  dialogToDate  = dialogLocal.
  addFieldValue(
  extendedTypeStr(ToDate), 
  DatetimeUtil::date(transContract.getValue(#ToDate)), 
  "@SYS14656");
}
public void build()
{
  super(); 
  this.addDateFields();
}
6.	 Run the report to see the result as shown in the following screenshot:
7.	
The report image shows four controls. This is the result of the framework adding two 
controls for the type Datetime and two controls being added by the extended class 
for type Date. To make only the controls added by the child class visible, comment 
the super in the build method. This turns out to be a disadvantage, as for every 
other control, such as the showApproved present in the report, a dialog field must 
be added explicitly in the same way as the FromDate and ToDate are added.

Chapter 3
57
8.	 After the controls are added, these values must be saved in the contract to be set 
in the query. Override the getFromDialog method in the UI builder class and write 
the code shown. This will save the value to the contract.
public void getFromDialog()
{
  PktRdlCustTransListRdlContract  transContract;
  transContract  = 
    this.getRdlContractInfo().dataContractObject() 
    as PktRdlCustTransListRdlContract;
  
  transContract.setValue(#FromDate, 
  DateTimeUtil::newDateTime(dialogFromDate.value(), 0));
  transContract.setValue(#ToDate, 
  DateTimeUtil::newDateTime(dialogToDate.value(), 0));
}
9.	 This completes adding the fields of type Date to the UI, storing, and showing back 
the values from the data contract.
10.	 The values from the dialog should be set in the query to make it complete. 
This must be done after the user clicks on OK on the report dialog. The 
preRunModifyContract method on the controller is invoked after the 
user clicks on OK, so this method will be appropriate to use in this case.
11.	 Override this method with the code here:
protected void preRunModifyContract()
{
  #define.parameterFromDate('FromDate')
  #define.parameterToDate('ToDate')

A Report Programming Model
58
  SrsReportRdlDataContract    contract   =                  
  this.parmReportContract().parmRdlContract();
  Date  fromDate            = 
    contract.getParameter(#parameterFromDate).
    getValueTyped();
  date  toDate              = 
    contract.getParameter(#parameterToDate).
    getValueTyped();
  Query query               = this.getFirstQuery();
  
  // Modify the query contract based on fromDate & toDate.
  SrsReportHelper::addFromAndToDateRangeToQuery(query,
  fromDate,
  toDate,
  tableNum(CustTrans),
  fieldNum(CustTrans, TransDate));
}
12.	The last part is to ensure that the value of FromDate is less than ToDate. 
Any validations on the contract values can be placed in the contract class; 
override the method PktRdlCustTransListRdlContract\Validate 
with the following code:
public boolean validate()
{
  boolean isValid = super();
  fromDate = this.getValue(#FromDate);
  toDate = this.getValue(#ToDate);
  
  if(fromDate && toDate)
  {
    if(fromDate > toDate)
    {
      isValid = checkFailed("@SYS120590");
    }
  }
  
  return isValid;
}

Chapter 3
59
How it works…
The two report parameters, FromDate and ToDate, that are added to the report directly 
are accessed through the controller. Since the report model only supports DateTime and not 
Date, the report dialog when previewed, shows a control of type DateTime. The Datetime 
field type in the UI may not be convenient way to enter inputs and the date value alone is 
required in this case. This can be done by adding custom controls of type date to the UI. 
Through blocking the super call, the controls are prevented from being added to the report 
dialog. Alternative date controls are added through the code and are bound to the report 
parameters. The values from these overridden controls are then added to the query. This way, 
we understand how we can create an unbound control and override the type of control that is 
rendered to the UI.
The classes created in this recipe are decorated with attributes. The attributes attached to 
the contract class create the necessary binding. The UI and the controller are bound by 
SysOperationContractProcessingAttribute, while the contract associated with 
a report is determined by SRSReportNameAttribute. As seen in the image in step 6, 
a control of DateTime type is shown. To be able to do this, it is important to understand 
the parameters, contracts, and how they are stored.
RDP versus RDL data contract
This chapter will largely use RDL (Report Definition Language) contract for controlling the 
report parameters. In this section, the major contract types are discussed to create clarity 
in understanding. Contracts are used to share the input values between the controller, UI 
builder, and the report at runtime. As described in the first recipe, there are many contracts 
for a recipe. The RDL and RDP contracts are very important, since they carry the user inputs. 
The RDP and RDL are compared here to give a detailed understanding. RDP contracts are 
discussed in detail in Chapter 4, Report Programming Model – RDP.
RDL data contract
RDP data contract
Holds system parameters and report model 
parameters
Holds contract specific parameters
Parameters are accessed by their identifier name,
for example, Contract.get("FromDate"), 
Contract.set("FromDate")
Parameters are accessed by the 
corresponding parm method,
for example, Contract.
ParmFromdate
Contracts are stored in Maps
Stored in corresponding variable
Weakly typed
Strongly typed
Used in all reports
Only used for RDP based reports


Chapter 3
61
  this.dataContractObject().getValue(#ShowApproved),  
  "Include Approved");
  //if super is not blocked then get the dialog field using 
  this syntax 
  // dialogApproved  =
  this.bindInfo().getDialogField(this.dataContractObject(),          
  //#ShowApproved);
  
  transController = this.controller() as 
    PktRdlCustTransController;
  
  if (transController.parmArgs())
  {
    tableId = transController.parmArgs().record().TableId;
    if (tableNum(CustTable) == tableId)
    {
      dialogApproved.visible(false);
    }
  }
}
2.	 As learned in the recipe Adding ranges from unbound parameters to the query, the 
methods getDialogField in the UI builder (PktRdlCustTransUIBuilder) and 
preRunModifyContract in the controller classes must be modified to retrieve the 
value and to set the value in the query correspondingly.
3.	 Save and compile the classes and now run the report. When the report is invoked 
from the CustTable form, the report dialog will display the flag Show approved.
How it works…
The visibility of controls can be easily switched as shown here, helping in creating a dynamic 
and context-specific report dialog. If you wish a report parameter to be completely hidden, 
it is recommended to use the visible property in Visual Studio.



A Report Programming Model
64
  controller.startOperation();
  
}
2.	 When the controller is connected to more than one report, the permission setup for 
the menu item differs. It involves creating a security permission object and linking it 
to the report controller.
3.	 Go to AOT | Security | Code Permissions. Right-click on Code Permissions and 
select New Code Permission.
4.	 Create a new permission object PktCustTransReport and expand to the node 
Associated Objects, select Reports and add the reports that are used in the controller.
5.	 Create an action menu Item and set the properties as shown in the following table:
Property
Value
Object Type
Class
Object
PktRDLCustTransController
LinkedPermissionType
CodePermission
LinkedPermissionObject
PktRDLCustTransList
How it works...
The code permission object PktCustTransReport, bundles all the reports and helps the 
menu item determine the security rights that must be assigned to a role that will use this 
report bundle. Use the main method in the controller class to select the appropriate report 
based on context.



Chapter 3
67
5.	 The [DataMethod] attribute indicates that this is a data method. The default return 
type is string but this method can return any .NET supported types.
6.	 Rewrite the logic to convert the voucher number to upper case.
[DataMethod(), PermissionSet(SecurityAction.Assert, Name = 
  "FullTrust")]
public static string changeCase(string value)
{
  return value.ToUpper();
}
7.	
Compile the code and it is ready to be used. Verify to see the report model showing 
the new parameters as subnodes.
8.	 To use the business logic that was created previously, expand the Data node in the 
Auto Design and add a new field.
9.	 Go to the property expression, open the expression dialog, and key in the following 
code line:
=changeCase(Fields!Voucher.Value)
10.	 This way, the expression is tied to the data method added.
11.	 Run the report and notice the new field showing the voucher number in upper case.
How it works…
Data methods on the report model provide the ability to manipulate and modify the report 
date. They can be used for:
f
f
Implementing expressions
f
f
Returning a DataTable that can be used as a dataset
f
f
Building URLs for the drill through action connecting to a SubReport or a URL


Chapter 3
69
9.	 Add this code to generate the URL for opening the Voucher Transactions from the 
voucher column in the report and build the solution:
[DataMethod(), PermissionSet(SecurityAction.Assert, Name = 
  "FullTrust")]
public static string DrillVoucher(string    reportContext, 
string    VoucherNum, 
DateTime  ADate, 
String    CompanyValue)
{
  return DrillThroughCommonHelper
  .ToLedgerTransVoucherForm(reportContext, 
  VoucherNum, 
  ADate, 
  CompanyValue);
}
10.	 Move to the report model and right-click on the field Voucher. Navigate to Add | 
URL Drill Through Action and give it a name, such as URLDrillAction.
11.	 On the new node, the Properties node, select the expression and enter the 
following code:
=drillVoucher(!Parameters.AX_ReportContext.Value, 
  !Fields.CustTrans.VoucherNum.value,
  !Fields.CustTrans.TrandDate.value,
  !Parameters.AX_CompanyName.Value);
12.	Rebuild the solution and deploy the report to see the drill-through in action.
How it works...
A typical URL, to open a currency form, appears like 
menuitemdisplay://currency/+47+%5B1:USD%5D. This URL is processed by 
the SysHelp::processStandardLink() method to open the appropriate forms 
and highlight the selection.
AX automatically adds drill-through action to fields with foreign-key relations, such as 
customer and vendor. In the case of specific fields, such as Voucher Number, where 
finding the record involves more than one field or is different, a drill-through action 
needs to be added. AX has built-in classes that have helper classes that can handle 
the majority of the drill-through actions.


Chapter 3
71
2.	 A Create Unit Tests dialog will prompt with the DrillVoucher method selected by 
default. If additional methods are present, check them and click on OK.
3.	 This will create a Unit Test project and a specific implementation to invoke the 
DrillVoucher method like this:
[TestMethod()]
public void DrillVoucherTest()
{
  string reportContext = 
    "?RunOnClient=1&PrintMediumType=Screen"
  string VoucherNum = "ARPM000004";
  DateTime ADate = new DateTime(200, 02, 28);
  string CompanyValue = "USSI"; 
  //intialize if you want use assert
  //string expected;
  string actual;
  actual = CustTransList.DrillVoucher(reportContext, 
  VoucherNum, 
  ADate, 
  CompanyValue);
  //intial approach would be test using 
  //Ax Class SysHelp::ProcessStandardLink

A Report Programming Model
72
  //Once the link is verified it can be added to the
  expected.
  //Assert.AreEqual(expected, actual);
}
4.	 Place the debugger anywhere in the method. On the tool bar, navigate to Test | 
Debug | All Tests in Solution. This will activate the debugger.
5.	 The business logic tested in the previous recipe is a drill-through URL; copy the 
returned URL from the Unit Test and run the following job in AX to see if it opens 
the right form and highlights the selection:
static void JobTestURL(Args _args)
{
  //Add the URL fetched through the unit test results
  SysHelp::processStandardLink
    ('menuitemdisplay://ledgertransvoucher/+3123+%5B63
    :ARPM000004%5D%5B2:02/28/2011%2000:00:
    00%5D%5B64:USSI%5D', null);
}
How it works...
The unit testing framework comes as part of Visual Studio and helps in testing code units. 
Most of the process is automated here and requires minimal efforts to get it working, such 
as passing the input parameters and validating the output parameters. This also helps in 
achieving better coverage of the logic, since some logic never gets tested during the functional 
testing. This Unit Test can be maintained or discarded after this testing; but prefer to discard 
it as it can always be regenerated if necessary, unless you have huge prerequisites that are 
difficult to recreate, such as inserting records.



Chapter 4
75
[
  DataMemberAttribute('Interest'),
  SysOperationLabelAttribute(literalStr("Interest")),
  SysOperationHelpTextAttribute(literalStr("Rate of 
    Interest")),
  SysOperationDisplayOrderAttribute('1')
]
public Amount parmInterest(Amount _interest = interest)
{
  interest = _interest;
  
  return interest;
}
[
  DataMemberAttribute('Year'),
  SysOperationLabelAttribute(literalStr("Period")),
  SysOperationHelpTextAttribute(literalStr("Number of 
    years")),
  SysOperationDisplayOrderAttribute('0')
]
public Yr parmYear(Yr _year = Yr)
{
  yr = _year;
  
  return yr;
}
5.	 The attribute DataContractAttribute at the class declaration indicates that 
this is a contract. If the contract requires a UI builder, that must also be defined 
in the class declaration.
6.	 Each parm method has the attribute DataMemberAttribute indicating that it is a 
contract member. This helps in having methods internal to the contract class, which 
don't have a decorator and are not accessible by other components, say the controller.
7.	
The remaining attributes in the contract methods, as seen in the previous code, 
are used for setting UI-specific values.
Attribute Name
Description
SysOperationLabelAttribute
Override the EDT label for the parm 
method
SysOperationHelptextAttribute
Override the Help text for the EDT parm 
method
SysOperationDisplayOrderAttribute
Order of the control in the report Dialog

Report Programming Model – RDP
76
8.	 The contract class is used by the UI builder for constructing the report dialog 
automatically, unlike in AX 2009, where the dialog field must be added for each 
field that is exposed to the user.
9.	 The next part involves creation of the RDP class. Create the RDP class using the code 
here. The SRSReportParameterAttribute decorator in the class declaration 
binds the contract and the controller.
[
  SRSReportParameterAttribute(classStr
    (PktInterestCalcContract))
]
class PktInterestCalcDp extends SRSReportDataProviderBase
{
  PktInterestCalcTmp interestCalcTmp;
}
10.	 The ProcessReport method is decorated with the SysEntryPoint attribute 
to be invoked from the services framework. The temporary table must be filled 
in this method.
[SysEntryPointAttribute(false)]
public void processReport()
{
  PktInterestCalcContract contract;
  
  Amount amount, total, oldTotal;
  Amount interestRate, interest;
  percent interestPct;
  yr     yr, yrCount = 1;
  
  
  contract = this.parmDataContract() as 
    PktInterestCalcContract;
  
  amount      = contract.parmAmount();
  interestPct = contract.parmInterest();
  yr          = contract.parmYear();
  
  interestRate = interestPct / 100;
  oldTotal     = amount;
  
  while (yrCount <= yr)
  {
    interest = (oldTotal*interestRate);
    total    = oldTotal +  interest;

Chapter 4
77
    this.insertInTmp(yrCount, oldTotal, interest, Total);
    oldTotal = total;
    yrCount++;
  }
}
private void insertInTmp(
Yr          _yr,
Amount      _amount,
Amount      _interest,
Total       _total)
{
  interestCalcTmp.clear();
  interestCalcTmp.Year = _yr;
  interestCalcTmp.Interest = _interest;
  interestCalcTmp.Amount   = _amount;
  interestCalcTmp.Total    = _total;
  interestCalcTmp.insert();
}
11.	 Any method that is decorated with SRSReportDataSetAttribute will be used to 
identify the temporary tables returned by RDP. There can be more than one method 
with this attribute, but in this case there is only one table.
[
    SRSReportDataSetAttribute(tableStr(PktInterestCalcTmp))
]
public PktInterestCalcTmp getInterestCalcTmp()
{
    select interestCalcTmp;
    return interestCalcTmp;
}
12.	This completes the designing of the RDP class. The next recipe will use this RDP 
class to create a simple precision design-based report.
How it works…
The RDP framework enables us to consolidate all data required across a report into a 
temporary table and then use that as a datasource to create the report. In this recipe 
an RDP class is created as a datasource; this will be used in the subsequent recipe to 
construct a report. The section below will give you understanding of how the whole RDP 
framework plugs in to AX-SSRS.
www.allitebooks.com

Report Programming Model – RDP
78
Report Data Provider (RDP)
The concept of RDP is very simple. A temporary table that has all the necessary fields 
involved in reporting is filled using a query or business logic. This temporary table is used 
as a data source and the report is rendered. RDP constitutes of the following components:
RDP Class
RDP
Contract
Query
contract
Contract specific
UI builder
RDP class
The major component in an RDP class is the report data provider class. Any class that extends 
SRSReportDataProviderbase/SRSReportDataProviderPreprocess can act as an 
RDP. An RDP receives its inputs optionally through a contract or a query and implements the 
logic involved in filling the temporary table. The reporting services invoke the data provider 
through the query services framework to fetch the data.
RDP data contract
The RDP data contract is the contract class that holds all the parameters specific to 
an RDP class. The data contract is also used by the report UI builder to render the form 
controls for user inputs. A contract can use its own UI builder, which is bound through 
SysOperationContractProcessingAttribute. A data contract can include or 
extend other contracts, for example, SalesFormLetterconfirmcontract and 
InventDimviewcontract.
UI builder
Similar to an RDL contract, an RDP contract can also bind itself to an UI builder. If a report 
has both RDL and RDP contracts and each is bound to a UI builder, then the system invokes 
both in sequence. A report dialog is built by several UI builder classes, such as Query, 
PrintDestination, and the contract UI builders. These classes are responsible for adding 
the dialog fields, validations, grouping, and handling form control events.




Report Programming Model – RDP
82
3.	 Select the RDP class created and click on Next to add the fields. Expand the 
dataset to see the fields from the temporary table and the parameters listed 
from the data contract.
4.	 To start with the precision design, right-click on the Design node and select 
Precision Design.
5.	 After selecting the Precision Design node, set the following properties:
Property
Value
Name
InterestReport
Style Template
TableStyleTemplate
6.	 Right-click on Precision Design and select Edit Using Designer.... This opens 
the designer. The left part of the designer holds the report data, which lists all 
the fields available for use in the report design. Right-click on the design area 
and select Insert | Table.

Chapter 4
83
7.	
Drag the fields from the RDP table and drop them in the table.



Report Programming Model – RDP
86
[DataMemberAttribute('Batch')]
public InventBatchId parmBatchId(InventBatchId _batchId = 
  batchId)
{
  batchId = _batchId;
  
  return batchId;
}
[DataMemberAttribute('ProdDate')]
public InventBatchProdDate parmProdDate(InventBatchProdDate
  _prodDate = prodDate)
{
  prodDate = _prodDate;
  
  return prodDate;
}
3.	 The next step is to fill the data in the temporary table. A select statement (DML 
(Data Manipulation Language)) can be used to fetch the data, but using a query 
would mean that the report ranges (parameters) can be extended later. So design 
a query PktInventBatch as seen in the following screenshot:

Chapter 4
87
4.	 RDP must be created with a binding to the contract. The query created can also be 
bound to be exposed in the report dialog.
[
  //bind query - shows in the report dialog
  SRSReportQueryAttribute(queryStr(PktInventBatch)),
  //bind the contract
  SRSReportParameterAttribute(classStr
    (PktInventBatchTransCotract))
]
class PktInventBatchTransDP extends
  SRSReportDataProviderBase
{
  PktInventBatchTransTmp tmpBatchTrans;
}
5.	 The processReport method must be designed to receive the parameters from 
the contract and set them on the query. This query must be executed further to 
insert the data in the tables.
6.	 The processReport method, as seen here, will get the RDP query and set the 
range from the contract for the batch ID and the production date. This is followed 
by the execution of the query to insert the records in the temporary table.
[
SysEntryPointAttribute(false)
]
public void processReport()
{
  Query                   query;
  QueryRun                queryRun;
  QueryBuildRange         batchRange, dateRange;
  QueryBuildDataSource    qbds;
  
  InventBatch             inventBatch;
  InventTrans             inventTrans;
  InventTransOrigin       transOrigin;
  
  InventDimViewContract       viewContract;
  
  batchContract = this.parmDataContract() as 
    PktInventBatchTransContract;
  
  query = this.parmQuery();
  qbds = query.dataSourceTable(tableNum(InventBatch));

Report Programming Model – RDP
88
  //set the range
  batchRange = SysQuery::findOrCreateRange(qbds, 
    fieldNum(InventBatch,
  InventBatchId));
  
  batchRange.value(batchContract.parmBatchId());
  
  if (batchContract.parmProdDate())
  {
  dateRange = SysQuery::findOrCreateRange(qbds, 
    fieldNum(InventBatch,
  ProdDate));
  dateRange.value(SysQuery::value
    (batchContract.parmProdDate()));
  }
  
  queryRun = new queryRun(query);
  
  while (queryRun.next())
  {
    if (queryRun.changed(tablenum(InventBatch)))
    {
      inventBatch = queryRun.get(tableNum(InventBatch));
    }
    
    if (queryRun.changed(tablenum(InventTransOrigin)))
    {
      transOrigin = 
        queryRun.get(tableNum(InventTransOrigin));
    }
    
    inventTrans = queryRun.get(tableNum(InventTrans));
    
    this.insertTmpTable(inventBatch, transOrigin,
      inventTrans);
  }
  
}
7.	
This method, insertTmpTable, is invoked from the process report to simply insert 
the records in to the temporary table.
private void insertTmpTable(
InventBatch         _inventBatch,
InventTransOrigin   _transOrigin,

Chapter 4
89
InventTrans         _inventTrans,
InventDim           _inventDim
)
{
  tmpBatchTrans.clear();
  tmpBatchTrans.ItemId                = 
    _inventTrans.ItemId;
  tmpBatchTrans.InventBatchId         = 
    _inventBatch.inventBatchId;
  
  
  tmpBatchTrans.ReferenceId           = 
    _transOrigin.ReferenceId;
  tmpBatchTrans.ReferenceCategory     = 
    _transOrigin.ReferenceCategory;
  
  tmpBatchTrans.StatusIssue           = 
    _inventTrans.StatusIssue;
  tmpBatchTrans.StatusReceipt         = 
    _inventTrans.StatusReceipt;
  tmpBatchTrans.DatePhysical          = 
    _inventTrans.DatePhysical;
  tmpBatchTrans.Qty                   =   _inventTrans.Qty;
  tmpBatchTrans.CostAmountPhysical    = 
    _inventTrans.CostAmountPhysical;
  
  tmpBatchTrans.insert();
}
8.	 This method is used by the reporting extension to retrieve the data.
[
  SRSReportDataSetAttribute(tableStr
    (PktInventBatchTransTmp))
]
public PktInventBatchTransTmp getinventOnhandTmp()
{
  select  tmpBatchTrans;
  return  tmpBatchTrans;
}
9.	 All the artifacts to enable the RDP are complete.
10.	There is one UI-related change that needs to be incorporated; that is, when 
a manufacturing date is chosen, the batch displayed must be from the same 
date. This change requires a UI builder that must be bound to the contract. 
The approach is to override the postRun method in the UI builder and build 
a local lookup method for the batch ID field.

Report Programming Model – RDP
90
11.	 The UI builder PktInventBatchTransUIBuilder must be designed as shown here:
class PktInventBatchTransUIBuilder extends 
SysOperationAutomaticUIBuilder
{
  DialogField batchDialog, dateDialog;
}
public void build()
{
  
  super();
  
  batchDialog = this.bindInfo().getDialogField(
  this.dataContractObject(),
  methodStr(PktInventBatchTransContract, parmBatchId));
  
  dateDialog = this.bindInfo().getDialogField(
  this.dataContractObject(),
  methodStr(PktInventBatchTransContract, parmProdDate));
}
public void postRun()
{
  super();
  
  //setup the event routing
  batchDialog.registerOverrideMethod(
  methodStr(FormStringControl, lookup),
  methodStr(PktInventBatchTransUIBuilder, batchLookup),
  this);
}
public void batchLookup(FormStringControl _control)
{
  Query                query;
  SysTableLookup       sysTableLookup;
  QueryBuildDataSource qbds;
  
  sysTableLookup = 
    SysTableLookup::newParameters(tableNum(InventBatch), 
    _control);
  sysTableLookup.addLookupfield(fieldNum(InventBatch, 
    InventBatchId));

Chapter 4
91
  query = new Query();
  qbds = query.addDataSource(tableNum(InventBatch));
  //if no date is specified show all batch
  if (datedialog.value())
  {
  qbds.addRange(fieldNum(InventBatch, 
    prodDate)).value(queryValue(datedialog.value()));
  }
  
  sysTableLookup.parmQuery(query);
  sysTableLookup.performFormLookup();
}
12.	Decorate the class declaration of the contractor class to bind the UI builder.
[
  DataContractAttribute,
  SysOperationContractProcessingAttribute(classStr
    (PktInventBatchTransUIBuilder),
  SysOperationDataContractProcessingMode::
    CreateUIBuilderForRootContractOnly)
]
class PktInventBatchTransContract
{
  InventDimViewContract       inventDimViewContract;
  InventBatchProdDate         prodDate;
  InventBatchId               batchId;
}
13.	This completes the design of the RDP.
14.	 Now test the RDP.
15.	As performed on the last recipe, write a test job and validate the RDP.
16.	 This completes all coding-related modifications for the report. The next recipe will 
model a report using this RDP.
How it works…
The RDP class designed here uses a query to iterate through the data and insert it into the 
temporary table. The query is bound to the report through the query attribute in the class 
declaration of the RDP. However, if the business logic doesn't demand a lot of dynamic 
behavior, prefer to use DML (select statements) to fetch the information. This can speed 
up the report process.


Chapter 4
93
7.	
Navigate to Add Group | Parent Group... and on the prompted dialog select 
InventBatchId. This sets the grouping based on the selected field.

Report Programming Model – RDP
94
8.	 A new column, InventBatchId, is added to the design. Preview the report.
9.	 This view takes up one column for the batch, reducing the space for details. A better 
idea would be displaying the batch at the top. Also, the labels for the detail lines are 
missing. In the steps to follow, let us work this out.
10.	 Select the header for the InventBatchId column, right-click and choose Delete 
Columns. On the delete dialog, choose the option Delete columns only. This 
option will retain the grouping but delete only the fields.
11.	 On the table row, select the row and right-click on it. Navigate to Insert Row | 
Outside. The group preceding this will add a new row. Add two rows; one will be 
for the labels and the other for the group header displaying the batch.
12.	To create labels on the row immediately preceding the data fields, double-click on the 
cell, right-click and select Create Placeholder. A property window for the cell opens. 
Click on the 
 icon next to the value field and enter the expression Labels!@
sys13647. Repeat this for each column header. (Identify the label ID from the label 
editor in the rich client before entering it.)

Chapter 4
95
13.	Of the two rows inserted, the one at the top will be used to display the group header. 
Select the first cell and enter the label for InventBatchId in the same manner as 
explained previously. On the topmost row, the first cell is used for the expression label 
for the batch. Select all the remaining cells and right-click and select Merge Cells. 
In the merged cell, click on the  icon and select the field Invent Batch.
14.	 This will display a batch at the top, followed by the transaction with labels. You can 
collectively change the font, color, and size of each cell by selecting all of them. The 
sample discussed here uses Segoe UI font, 8pt for values and grey color background 
for the header cells. The precision design gives the comfort of setting up the 
properties collectively by multi-selection.
15.	 Set the property Can Shrink in the cells to true. This will allow automatic report sizing.
16.	 To add totals to each group on the Grouping node at the bottom, select Group1 
and click on the small arrow at the end. Navigate to Add Totals | After. This will 
insert a new row at the bottom and add the two sum fields for Quantity and 
CostAmountPhysical. Delete the Quantity, since we don't need it and 
instead, modify the expression to set the label as Total. This will print the label 
after each group.

Report Programming Model – RDP
96
17.	 To add the grand total, insert a row outside the group present at the bottom. Right-
click on the cell beneath the group total and select expression. In the expression 
window, enter the expression Sum(Fields!CostAmountPhysical.Value) and 
similarly, set the label expression as Grand Total.
18.	The following screenshot shows how the final report should appear:



Chapter 4
99
2.	 Adding the company image starts with defining a query. Create a query 
PktComanyImage and add the table CompanyImage. Come back to your Visual 
Studio report and add the query as datasource. Set the Dynamic Filter 
property to false. Save the report and open the designer.
3.	 In the designer, the new datasource will appear in the report data view. On the 
page header, create a new field of the type image. On the prompting window, select 
the imagesource as database and point the value field to the image field from the 
companyImage DataSource and set the MIME type, based on the image you have 
added. Resize the image and place it before the company name. Save and preview 
it to see the image.
4.	 Deploy the report and create a menu item to see the report working.
How it works…
The company image query that was created for this report can be reused for other reports that 
require a company image to be printed. If there are images that are specific to this report, then 
the field can be directly added to the temporary table field used by the RDP. You can also use 
embedded images in precision designs as seen in the Chapter 2, Enhancing Your Report – 
Visualization and Interaction.
Precision design allows copying of controls from one report/report design to another report/
report design. So copy the header fields if the same alignment is required in other reports.
Debugging RDP
The most preferable mode to debug an RDP report would be the test job discussed in the 
recipe Testing the RDP, However, if you prefer to debug it, on the processReport method 
of your RDP class, type the keyword breakpoint. Open the debugger even before opening or 
previewing the report by running the axdebug.exe file in the client installation. Once the 
execution reaches the debugging point, the debugger will be activated.
See Also
f
f
The Adding an image in auto design recipe in Chapter 2, Enhancing Your 
Report – Visualization and Interaction.


Chapter 4
101
2.	 The user enters the values in the Amount:, Interest:, and Years: input boxes and 
clicks on Calc. The simulation is shown in the form. When the user clicks on the Print 
button, the temporary table must be passed to the RDP and rendered in the report.
3.	 The first step begins with creating a contract. Since the temporary table already 
exists, this step can be surpassed. There is no further input from the user to be 
received. So our contract class needs no parm methods except the one for holding 
RecID from DataSource. So the SRSTmpTableMarshallerContract contract 
can be directly used as the contract for RDP. (In situations where you have your own 
contract class, the SRSTmpTableMarshallerContract contract must be used 
as a nested data contract. See Inventory Dimension in Reports recipe in Chapter 7, 
Upgrading and Analyzing Reports.)
4.	 The RDP for a pre-populated temp table is much simpler. The only logic to be 
performed is to retrieve the data from the DataStore. The processReport 
method of the RDP appears as here:
[SysEntryPointAttribute]
public void processReport()
{
  SrsReportRunPermission  permission;
  
  SrsTmpTblMarshallerContract contract = 
    this.parmDataContract() as SrsTmpTblMarshallerContract;
  breakpoint;
  
  tmpTableDataRecId   = contract.parmTmpTableDataRecId();
  permission          = new SrsReportRunPermission();
    permission.assert();
  
  //Temp Table Object that was returned from 
    SRSTmpTblMarshaller
  tmpCalc = 
    SRSTmpTblMarshaller::GetTmpTbl(tmpTableDataRecId);
  //drop the temp table from data store since it is copied 
  //to the local buffer
  SRSTmpTblMarshaller::deleteTmpTblData(tmpTableDataRecId);
  CodeAccessPermission::revertAssert();
}
Bind the contract class SRSTmpTableMarshallerContract in the class 
declaration and create a data return method as in the previous RDP classes.

Report Programming Model – RDP
102
5.	 The controller class owns the responsibility of storing the temp table. Create a 
controller class and override the prerunModifyContract method with the 
following code:
public void preRunModifyContract()
{
  RecId recid;
  PktInterestCalcTmp tmp;
  
  SrsTmpTblMarshallerContract contract;
  
  new SRSReportRunPermission().assert();
  
  tmp.setTmpData(this.parmArgs().record());
  
  //store the data in data store and retrive the recid        
  recid =
    SRSTmpTblMarshaller::sendTmpTblToDataProvider(tmp);
  CodeAccessPermission::revertAssert();
  
  //set the recid in contract to be used in RDP
  contract = this.parmReportContract().parmRdpContract() as 
    SrsTmpTblMarshallerContract;
  contract.parmTmpTableDataRecId(recid);
}
6.	 In the main method, switch off the dialog since no user input is needed.
public static void main(Args args)
{
  PktMarshallCalcController control;
  
  
  control = new PktMarshallCalcController();
  control.parmArgs(args);
  control.parmReportName('PktMarshallCalc.InterestReport');
  control.parmShowDialog(false);
  control.startOperation();
}
7.	
All the code artifacts are ready. Design the report to look similar to the one in the 
first recipe of this chapter. The final part is to hook the controller to the clicked 
event in the button. Override the print button and call the controller.



Chapter 4
105
How it works…
The AX reporting framework delays the invocation of the reporting framework until the 
data is processed. After the data is processed and inserted, the reporting framework is 
invoked, preventing the time-outs. The hindrance here is that the RDP uses a temporary 
table. Converting this to persistent introduces a different sort of problem with two different 
instances of the report potentially inserting conflicting of data.
AX reporting framework solves this problem by making the table persistent and introducing 
a scope field called TransactionId. The TransactionId field allows the reporting 
framework to identify the records created for the session. In the case of preprocessed reports, 
the data is inserted in the table and the details of the preprocessing are stored in the table 
SRSReportPreProcessDetail. The recid of the record is passed as preprocessid to 
the report framework and the data is fetched using this scope from the table.
Clean up
The data in these tables are cleaned up after the report runs automatically.
See also
f
f
The Handling long running reports in AX recipe in Chapter 8, Troubleshooting and 
Other Advanced Recipes.




Chapter 5
109
        dt.Rows.Add("Australia", "USD", "AUD", 1, 1.03);
        dt.Rows.Add("Asia", "USD", "SGD", 1, 1.26);
        dt.Rows.Add("Europe", "USD", "EUR", 1,0.77);
        dt.Rows.Add("Middle East", "USD", "AED", 1, 3.67);
        return dt;
    }
6.	 Save and build the solution. This will refresh the data method in the report model.
7.	
Open the report model, select the Datasets node and create a new dataset. On the 
new dataset property set the Data Source Type to Business logic:

Integrating External Datasources
110
8.	 Now click the ellipsis (…) button on the Query property and select the business logic 
that was just created. Click on the exclamation mark on the left corner to validate 
data retrieval. This action will add the fields from the data table and the parameters 
of the method (if any will be added as parameters):
9.	 Drag the dataset to the report design. Apply templates, align the controls, and specify 
labels for rendering.

Chapter 5
111
10.	 Save and preview the report:
11.	 The report can now be deployed and put to use.
How it works…
Any data method that returns a datatype of System.data can be added as a dataset to 
the report. The data table filled in the data method is used by SSRS to identify fields of the 
table. If there are parameters for the data method, then they are added as parameters for 
the dataset. The program logic creates a data table instance and adds columns with the 
datatype followed by inserting rows in the table. The row details are hardcoded in the table 
in this recipe.
See also
f
f
The Expressions in layouts recipe in Chapter 2, Enhancing Your Report – 
Visualization and Interaction
f
f
The Adding data methods in business logic recipe in Chapter 3, A Report 
Programming Model


Chapter 5
113
        foreach (var obj in q){
            dt.Rows.Add(obj.cat,
                        obj.title.Substring(0, 2),
                        obj.title.Substring(4, 3),
                        obj.desc);
        }
        return dt;
        
    }
4.	 Before adding this as a datasource, it is important to ensure that this method works 
well, since any runtime issues might prevent it from using this data method as a 
datasource.
5.	 Create a unit test method (see the Unit testing business logic recipe in Chapter 3, 
A Report Programming Model) and run the test to ensure execution at runtime.
6.	 Add the data method as a datasource followed by adding it to the report design;



Integrating External Datasources
116
        var q = from c in xdoc.Descendants("item")
                where (c.Element("category").Value == category ||
                        string.IsNullOrEmpty(category))
                select new
                {
                    title = c.Element("title").Value,
                    pubDate = c.Element("pubDate").Value,
                    desc = c.Element("description").Value,
                    cat = c.Element("category").Value
                };
        foreach (var obj in q)
        {
            dt.Rows.Add(obj.cat,
                        obj.title.Substring(0, 2),
                        obj.title.Substring(4, 3),
                        obj.desc);
        }
        return dt;
    }
3.	 Rebuild the solution.
4.	 The next step is to build a lookup for this parameter. Create a new data method and 
place the business logic as shown here:
public static DataTable CategoryData()
    {
        DataTable dt;
        dt = new DataTable();
        dt.Columns.Add("Category", typeof(string));
        XDocument xdoc = XDocument.Load("http://themoneyconverter.
com/rss-feed/USD/rss.xml");
        XNamespace space = xdoc.Root.GetDefaultNamespace();
        IEnumerable<string> q = xdoc.Descendants("item").
Descendants("category").Select(pn => pn.Value).Distinct().
ToList();

Chapter 5
117
        foreach (string category in q)
        {
            dt.Rows.Add(category);
        }
        return dt;
    }
5.	 Rebuild the solution. Add both the business logic as datasets. The parameter that 
was added in the data method ExchangeRateDataFilter should now be seen in 
the parameter node of the dataset and the report parameter:

Integrating External Datasources
118
6.	 On the report parameter node Parameters, select the parameter ExchRateFilter_
Category and on the property Values, click on the button. A dialog box opens up. 
Fill the dialog box with the values shown here. This hooks up the category dataset 
to the lookup:
7.	
Preview the report after setting the templates, fonts, labels, and alignments. 
On the preview pane you should notice that the category shows the geographical 
classification:




Integrating External Datasources
122
9.	 Click on the exclamation button 
 to validate the query:
10.	 Click on OK to see the fields added to the new dataset.
11.	 Now drag it onto the auto design node. Set the template and appropriate labels to 
present the report.




Integrating External Datasources
126
3.	 The query editor lists all the available cubes and their dimensions and measures. 
As you execute the query, the results can be viewed at the bottom:
4.	 Create a new reporting project in Visual Studio and add a report 
PKTCustgroupSalesSummary.
5.	 Add a dataset and set the property Data Source Type as DynamicsAxOLAP.
6.	 Now copy the MDXquery from the management studio and paste it in the report query 
editor that is opened by clicking the ellipsis (…) button in the Query property:

Chapter 5
127
7.	
Click on the exclamation button 
 to validate the query. This should display the 
data in the data editor window at the bottom. Click on OK to add the dataset:
8.	 Add a precision design node CustGroupSummary and double-click to open 
the designer.

Integrating External Datasources
128
9.	 Insert a new design and add the following fields:
10.	 Add a Parent Group field on Row Groups:
11.	 Select Transaction_date_Quarter_Quarter_MEMB in the group by option dialog.
12.	Preview the report after adding labels and setting the fonts:


Integrating External Datasources
130
{([Measures].[Accounts receivable amount - transaction 
currency])})
on rows   
FROM [Accounts Receivable Cube]  
WHERE( STRTOMEMBER(@EndDate), strtomember("[Company].[Company].&[" 
+ @Company + "]")) 
2.	 Clicking on OK in the query editor will prompt for the values. Fill in a valid value 
to proceed; for example, [Transaction date - fiscal calendar].
[Year].&[USPI]&[2012] , USPI:
3.	 This adds the parameter to the dataset and report. Any error in the MDX query will 
fail to add it as a datasource, so double-check it with the MDX query editor and make 
sure the right parameter values are entered. Entering wrong parameter values also 
stops adding the query to the dataset.
4.	 The two parameters @EndDate and @Company are now added to the parameters node:

Chapter 5
131
5.	 The next step involves creating the lookup for these parameters. Use the following 
MDX queries to create a report dataset to look up the company:
WITH 
MEMBER [Measures].[ParameterCaption] AS '[Company].[Company].
CURRENTMEMBER.MEMBER_CAPTION'  
MEMBER [Measures].[ParameterValue] AS '[Company].[Company].
CURRENTMEMBER.UNIQUENAME'  
MEMBER [Measures].[ParameterLevel] AS '[Company].[Company].
CURRENTMEMBER.LEVEL.ORDINAL'  
MEMBER [Measures].[Key] AS '[Company].[Company].CURRENTMEMBER.
PROPERTIES("Key")'  
SELECT {[Measures].[ParameterCaption], [Measures].
[ParameterValue], [Measures].[ParameterLevel],[Measures].[Key]} 

Integrating External Datasources
132
ON COLUMNS ,
Except( [Company].[Company].ALLMEMBERS,{[Company].[Company].
[Unknown],[Company].[Company].[All]})  
ON ROWS 
FROM  [Accounts Receivable Cube]
6.	 On the report parameters node for the parameter CustGroupTrans_Company, 
set the following values for the parameter dialog box that opens by clicking on 
the values property button. This links the dataset Company to this parameter 
for lookup purposes:

Chapter 5
133
7.	
To set a default value for the company parameter modify the property Default value 
to the expression =Parameters!AX_CompanyName.Value.
8.	 For the parameter EndDate, create a dataset by using the following query:
WITH
MEMBER [Measures].[ParameterCaption] AS '[Transaction date - 
fiscal calendar].[Year].CURRENTMEMBER.MEMBER_CAPTION' 
MEMBER [Measures].[ParameterValue] AS '[Transaction date - fiscal 
calendar].[Year].CURRENTMEMBER.UNIQUENAME'  
MEMBER [Measures].[ParameterLevel] AS '[Transaction date - fiscal 
calendar].[Year].CURRENTMEMBER.LEVEL.ORDINAL' 
MEMBER [Measures].[Key] AS  '[Company].[Company].CURRENTMEMBER.
Properties("Key")'  
SELECT 
{
    [Measures].[ParameterCaption], [Measures].[ParameterValue], 
[Measures].[ParameterLevel]
} 
ON COLUMNS,     
{ 
    [Transaction date - fiscal calendar].[Year].[All],
    FILTER
    ( 
        [Transaction date - fiscal calendar].[Year].MEMBERS, 
        INSTR( [Transaction date - fiscal calendar].[Year].
CURRENTMEMBER.UNIQUENAME,"&[" + [Measures].[Key] + "]"  ) > 0
        AND 
        INSTR( [Transaction date - fiscal calendar].[Year].
CURRENTMEMBER.UNIQUENAME,"&[1900]") = 0
    )
 } ON ROWS
FROM [Accounts receivable cube] 
WHERE STRTOMEMBER("[Company].[Company].&[" + @Company + "]")
9.	 This dataset used to look up the year for the parameter EndDate has another 
parameter company as seen in the MDX query. On the dataset for this MDX query 
expand the Parameters node, select the company parameter, and then set the 
property Report parameter to CustGroupTrans_Company parameter. This way 
the company parameter is attached to the value set for the company parameter in 
CustGroupTrans resulting in showing the years applicable for the selected company.

Integrating External Datasources
134
10.	 Bind the dataset to the parameter EndDate by modifying the values property as 
shown here to show up as lookup:



Chapter 5
137
2.	 This opens up the Report Builder editor. In the wizard that shows up, select 
Table or Matrix Wizard and click on Next:
www.allitebooks.com

Integrating External Datasources
138
3.	 The next tab is where the dataset must be defined. Select Create a dataset and click 
on Next. The following tab is to choose the source of the report data. Click on New:
4.	 In the next screen for the Data Source property give a name such as AxOLAP and 
set Select connection type to Microsoft SQL Server Analysis Service and 
click on Build:

Chapter 5
139
5.	 On Connection Properties type the name of the server and choose the database. 
Click on OK to return back and press the Next button in the wizard:

Integrating External Datasources
140
6.	 The wizard displays the query designer. Since we will use the Account receivable 
cube, use the datasource selector to select the cube:
7.	
On the top dimensions row set the values as seen in the following screenshot by 
using the lookups in the columns:

Chapter 5
141
8.	 After completing this, on the empty space drag Customer group name, Customer 
name, and State from Customer Dimension from the left pane. Similarly, traverse to 
the Dimension Transaction Date node and drag the Transaction date.Year-Quarter-
Month-Date to the empty space:

Integrating External Datasources
142
9.	 The next step is to go to Measures at the top in the left pane, expand Customer 
transactions and drag Accounts receivable amount currency to the columns. 
The query automatically executes and shows the data returned in the screen:
10.	 Click on Next and from the available fields' drag-and-drop the fields as shown here:

Chapter 5
143
11.	 Click on Next; the layout designer provides options to select Total and Subtotal:
12.	In the subsequent screen select the theme and click on Finish to see the fully-
designed report in the editor:

Integrating External Datasources
144
13.	Click on Run to see the report preview:
14.	 To save the report, publish this to Report Server. From the menu navigate to the 
File | Save As option and choose the location in the Report Server, preferably 
the DynamicsAX folder. Once saved, the report can be accessed through the 
reporting services.
How it works…
The SQL Report Builder also doubles as an easier way to verify a cube query before creating 
it using SSRS. The Report Builder can also be used against the OLTP database but the label 
transformations and security might not be put to action, so care must be taken in using it.


Integrating External Datasources
146
3.	 In the wizard, choose USA by State Exploded and click on Next:

Chapter 5
147
4.	 Let us use the same dataset that was added; so set the option to choose the already 
added datasource and click on Next:

Integrating External Datasources
148
5.	 The next step is to relate the spatial data and the analytical data, in the following tab 
choose Spatial data which identifies a geographical location. Select STUSPS in the 
Match field and pick up the State field from the dataset fields:

Chapter 5
149
6.	 On the next tab choose a theme, preferably Generic, and choose the amount field 
sum for visualization, and then set the color rule to your preferred choice. Click on 
Finish to complete the wizard:

Integrating External Datasources
150
7.	
The map in inserted in the report. Before we make it a subreport it is necessary 
to drop all the extra add-ons on the map such as Title and Scale. So select each 
of them and uncheck the Show option:
8.	 In the map area right-click and select Viewport Properties. On the properties set the 
fill and border color to none and border size to 0 pt. The map should appear plain 
as shown here. Resize it to a smaller size so that it can be inserted as a subreport:

Chapter 5
151

Integrating External Datasources
152
9.	 Now on the tabular design select the Sum field as seen here and insert a row Inside 
group – Below:
10.	 Read just the table design by stretching the columns and rows to build some space 
for the map. Cut the map and paste in the new column. This automatically makes 
the map a subreport:

Chapter 5
153
11.	 Run the report:


Chapter 5
155
8.	 In the Parameters node create a new parameter called CustGroup of type String:
9.	 In the Designs node expand the node Filters, create a new filter, and set the 
following properties:
Property
Value
Name
GroupFilter
Expression
=Parameters!CustGroup.Value
Operator
Equals
Value
=Fields!CustGroup.Value
10.	 Save and preview the report.

Integrating External Datasources
156
11.	 Open the report PktCustGroup, on the Designs node expand the Data node and 
right-click on the field CustGroup and navigate to Add | Report Drill Through Action.
12.	 This will add a new node ReportDrillThroughAction; open the properties of the node 
and click on the button on the property ReportDesign. This will list all the reports in 
the same project. Expand PktCustReport, select the Designs node and click on OK:
13.	All the parameters including CustGroup that was created in PktCustReport will be 
added as subnodes. Navigate to each subreport and set it to the system parameter 
of the current report in the value field except for the parameter CustGroup:


Integrating External Datasources
158
2.	 Open the precision design software and navigate to the field for customer group. 
Select the field, and then right-click and choose Textbox Properties:
3.	 On the Properties dialog box, select the Action tab, and then choose Go to Report 
under the Enable as a hyperlink pane:

Chapter 5
159
4.	 In the field Specify a report manually, fill the values with PktCustReport.CustList 
since no lookup is available in auto design.
5.	 Click on the Add button to add parameters. On the Name field, type the parameter 
name used in PktCustReport and on the Value field use the 
 expression button 
and select the appropriate values from the report PktCustgroupSalesSummary.
6.	 Rebuild the project.
7.	
Deploy and preview the report.





Beyond Tabular Reports
164
private void insertTmpTable(SalesLine _salesLine)
{
    Qty                 qty;
    date                shipDate;
    InventItemGroupItem groupItem;
    qty             = _salesLine.QtyOrdered;
    shipDate        = _salesLine.ShippingDateConfirmed;
    groupItem       = InventItemGroupItem::findByItemIdLegalEnti
ty(
                                            _salesLine.ItemId,
                                            _salesLine.
DataAreaId);
    salesHistoryTmp.clear();
    salesHistoryTmp.ItemId          = _salesLine.ItemId;
    salesHistoryTmp.ItemGroupId     = groupItem.ItemGroupId;
    salesHistoryTmp.Price           = _salesLine.salesPrice;
    salesHistoryTmp.Amount          = _salesLine.SalesPrice * Qty;
    salesHistoryTmp.Qty             = qty;
    salesHistoryTmp.Year            = year(shipDate);
    salesHistoryTmp.MonthOfYearId   = mthOfYr(shipDate);
    salesHistoryTmp.Days            = dayOfMth(shipDate);
    salesHistoryTmp.insert();
}
[
SysEntryPointAttribute(false)
]
public void processReport()
{
    Query       query;
    QueryRun    queryRun;
    SalesLine   salesLine;
    InventItemGroupItem itemGroup;
    query = this.parmQuery();
    queryRun = new queryRun(query);
    while (queryRun.next())
    {
        salesLine = queryRun.get(tableNum(salesLine));
        this.insertTmpTable(salesLine);
    }
}

Chapter 6
165
Creating a matrix report
1.	 Create a report in Visual Studio named PktMatrixReport and add the RDP 
provider as a dataset.
2.	 Set the Dynamic filter property to false.
3.	 Create a new precision design and name it matrixDesign, and then double-click 
to open up the editor.
4.	 Right-click and insert a new matrix data region:

Beyond Tabular Reports
166
5.	 Use the field selector to set the fields as shown in the following screenshot. 
Choosing Qty in the data section will automatically add the Sum function to it:
6.	 To add the total quantity for each row, on the Row Groups option at the bottom, 
click on the small arrow and then navigate to Add Totals | After.
7.	
To add the total quantity for each column, on the Column Groups option at the 
bottom, click on the small arrow and then navigate to Add Totals | After.
8.	 There are three total boxes in the design. Each represent the row total, column 
total, and the grand total. Grand total tallies the sum of rows and sum of columns.
9.	 As you can see in the following screenshot that the grand total block in the title 
row is colored and the font is also set to bold. This will give a better appearance 
for the matrix:



Chapter 6
169
3.	 From the Report Data toolbar drag the control Price to Column Group next to Qty. 
A vertical blue bar appears and it must face the Qty column as seen here:
4.	 The price field, by default, gets placed in as a Sum operation. Change it to Average 
by right-clicking on the cell and choosing Expression. In the expression field modify 
the sum and set it to average.
5.	 Since price can have decimal values it is important to set the decimal ranges; 
otherwise, it ends up in an improper formatting. Right-click on price control and 
choose Textbox properties.

Beyond Tabular Reports
170
6.	 On Textbox properties set the Formatting to Number and ensure Decimal places 
is set to 2:
7.	
If you are extending the previous recipe drop the column totals before doing this; 
otherwise, directly move to the column group at the bottom and click on the arrow 
button and then navigate to Add Totals | After. This will add the totals for the 
quantity and price fields.
8.	 The report design appears as shown here. Save the report and preview it.

Chapter 6
171
9.	 The first screenshot shows preview with limited data (the Load dataset fully option 
is not activated):


Chapter 6
173
How to do it…
1.	 Since the RDP class can return a large number of item groups, it is ideal to limit it to 
two item groups to test this recipe. This will make it faster and easier to work through 
this recipe.
2.	  Modify processreport in the RDP to add ranges for the item group in the query.
3.	 In Visual Studio create a new report PktColumnChartReport and link the RDP 
class to it. Remember to set the Dynamic filter property in the dataset to false.
4.	 Create a new precision design and name it ChartDesign.
5.	 Open the editor, right-click and then navigate to Insert | Chart. In the prompting dialog 
window that shows the different chart types available, choose the Column chart:

Beyond Tabular Reports
174
6.	 Resize the chart to a required size and double-click on the chart area. This will 
show additional square boxes around the chart image for category, series, and 
data as seen in the following screenshot. Drag the following fields to the specified 
region accordingly:
Field
Drop area
Year
Category
ItemGroupId
Series
Qty
Data
7.	
As fields are dropped in the chart area you can see the report changing at design 
time. Though this may not reflect the exact data, it will give you a feeling of how it 
looks at runtime.
8.	 Modify the chart title and the axis title. Save the report design.



Chapter 6
177
6.	 The axis may not show all the labels for the category axis. To make sure that it 
shows all the months as labels right-click on an axis and open the Axis properties 
form. In the property form on the Axis options tab under Set axis scale and style, 
set the interval to 1. This will ensure that all the labels are visible.

Beyond Tabular Reports
178
7.	
Right-click on the Legend option and choose Legend properties. On the General 
tab under the Legend position choose from the circular radio buttons the position 
of the legend:

Chapter 6
179
8.	 To disable the quantity axis right-click on any axis, uncheck Show Value Axis, 
and then the design should be similar in style to the screenshot here:




Chapter 6
183
4.	 Stretch the box to allow resizing the Gauge control; notice that the Gauge control 
increases as the box expands. Stretch it to a visible limit.
5.	 Double-click on the gauge control and on the Drop data fields here box that appears 
over the gauge, drop the field Price by dragging it from report data. By default this 
value might appear as Sum(Qty), convert it to Avg(price):

Beyond Tabular Reports
184
6.	 Right-click on the Gauge control and select Pointer Properties. In the Properties 
form on the Pointer options tab, click on the expression button in the Value field 
and convert sum to avg in the expression editor.
7.	
The Gauge control, by default, shows red on the max value but in the case of 
average price the higher the value, the better it is. To modify, select the range 
in red color, and then right-click and open Range properties. In the Range 
properties, set secondary color to Green from the default color:
8.	 To add a new range, right-click inside the Gauge control and select Add Range. 
A new range gets added to the lower corner:

Chapter 6
185
9.	 Select the range and open Range Properties by right-clicking on the new range. 
In the Range properties form set Start range at scale value and End range at 
scale value to 1 and 20 respectively and also change the fill color to Red. Any 
number of ranges can be added in a similar way with different scale values.
10.	 The final design appears as seen here:
11.	 Save and preview the report.


Chapter 6
187
4.	 In Group Properties add a new grouping by ItemGroupId:
5.	 Stretch the list data region to fit the entire report. From the toolbox drag the textbox 
control and set the field to ItemGroupId. Also, enter the text title as Summary 
Sheet before ItemGroupId as seen in the following screenshot:
6.	 Increase the font size, set the alignment to center and the back color using the 
text toolbar.

Beyond Tabular Reports
188
7.	
From the toolbox again drag a rectangle control to the list box. Inside the rectangle 
control add quantity and price sum. Also, add labels, header text, and back color. 
The rectangle should reflect the total quantity and the amount for the item group:
8.	 Stretch the list box to increase the height and below the total insert a radial gauge. 
On the pointer properties, set the field to Avg(Price). Add a textbox that provides 
a title for the Gauge control as Average Price:

Chapter 6
189
9.	 In the rest of the available area in the list we will create two charts. One is a 
bar chart that indicates the quantity sold across items and the other will be 
a line chart that indicates the price graph across the items.
10.	 To insert a chart, choose the Barchart option and then drop ItemId to the 
categories and Quantity to the Data. Delete the axis titles and legends to 
make space for the graph.
11.	 Similarly, insert a line chart and add ItemId to the categories and Price to the 
Data. Give it a title after removing the axis titles and the legend.



Beyond Tabular Reports
192
4.	 A screen listing all the categories and web parts appears. Select Microsoft Dynamics 
AX from the category and Report from the Web Part. Click on Add:
5.	 This adds the web part; this web part must be configured. Select the drop-down menu 
in the upper-right corner and then select Edit Web Part:

Chapter 6
193
6.	 A report bar appears on one end of the web page. From this bar select the report, 
in this case the column chart. The list highlights the reports based on the report 
menu item label. Select the report and set the properties, such as parameter and 
layout. Click on OK:




Chapter 7
197
2.	 For RDP:
1.	 The next step is to identify the data that is needed for the report, and create 
one or more temporary table based on the business logic. For example, 
SalesConfirm and ProjInvoice are reports that use more than one 
temporary table.
2.	 After the temporary table is created, create the RDP class and move the 
business logic placed inside the fetch method into the RDP. Also to be 
moved are any computed columns that are implemented as display methods 
in AX 2009. The display value is mapped to the field in the temporary table 
and is filled by the RDP.
3.	 When creating the RDP, you will identify the parameters that are necessary, 
and create a contract class with the list of parameters.
Mapping the design
Once the datasource decision is complete, the next step is to work on the design part. As AX 
2009 has auto design and generated design, AX 2012 has auto design and precision design. 
The generated design is what maps as precision design in AX 2012, but before simply moving 
all the generated design to precision design, consider rethinking the strategy. Sometimes, it is 
possible that what was achieved through generated design in AX 2009 could be achieved with 
the help of auto design and RDP in AX 2012. Take in to account the following points as you do 
your design mapping:
1.	 Choice of control: SSRS reports have a wider choice of presentation methods such 
as charts, matrix, and list. So, consider if you can use an alternate way to display 
your data.
2.	 Segregate display methods: Display methods must be carefully redesigned. In AX 
2009, it was a common practice to write a display method for even fetching a value 
using a foreign key. Such methods can be eliminated in AX 2012. Here are a few 
suggestions for the commonly found display methods:

Upgrading and Analyzing Reports
198


Find methods: If a query is the report datasource, it allows you to add 
display methods present in the table as datasource fields. So, directly 
choose the display method when choosing the fields in the query 
selection window in the report designer.


Simple computations: There can be conditional computations such as If 
(PriceDiscTable.Value) then Total = Total + Value. For 
such conditional computations, try to use expressions. If the expressions 
are proving difficult, use the business logic in the report design to create a 
method, which can be referenced from the expressions. Refer to the Data 
methods in business logic recipe in Chapter 3, A Report Programming Model.


Upgrading and Analyzing Reports
200
Developing the controller
If your report also uses RunbaseReport, then proceed with the following steps:
1.	 Multiple design/reports: If the RunbaseReport class chooses the report or design 
at runtime, a controller must be created in AX 2012. The controller class can be used 
to choose the report at runtime.
2.	 If the ranges in the query are modified based on the caller in the RunbaseReport 
class or in the report, use the controller class in AX 2012.
Handling UI events
UI events can be handled as follows:
1.	 Adding dialog fields: Simple dialog will be constructed by the framework, using the 
contract parameters. If any dialog modifications are required, create a UI controller 
class.
2.	 Reacting to the dialog field changes: Any changes such as lookup modification or 
dependency fields must be implemented in the UI controller class.
3.	 Validations: Any validations must be placed in the contract class.
4.	 Align the report dialog controls: Use SysOperationAttribute to order the 
controls in a contract class. For more complex restructuring, use the Visual Studio 
parameter nodes to create groups.
See also
f
f
The Calling multiple reports from a controller recipe in Chapter 3, A Report 
Programming Models
f
f
The Adding ranges from unbound parameters to the query recipe in Chapter 3, 
A Report Programming Models
f
f
The Modifying the report query in the controller recipe in Chapter 3, A Report 
Programming Models
f
f
Adding data methods in business logic recipe in Chapter 3, A Report 
Programming Models
f
f
The Grouping and ordering controls in a report dialog


Upgrading and Analyzing Reports
202


Knowing the report name but not sure which report layout is used: 
Say from the previous step you identify the controller but are still 
not sure which layout is used, since there are many layouts being 
referenced, then use this approach. Place the debugger at \Forms\
SrsReportViewer\Methods\init and when the debugger hits this 
point, choose Classes\SrsReportRunController from the stack 
trace and look for the reportname variable under this in the watch 
window. This will clearly indicate the report name and design. This will 
also help you identify the controller.


Searching for an example: If you are looking for an example report 
to learn about a certain type of report, download the Excel sheet 
from http://www.microsoft.com/download/en/details.
aspx?id=27877. This contains the complete list of reports with 
different details based on their usage, design, and so on. This can 
help you choose the report that might serve you as a good example.


Upgrading and Analyzing Reports
204
9.	 Modifying your report: There are different approaches that can be adopted in 
modifying a report design and the choice depends on the level of requirements. 
Here are a few approaches that you can adopt:
1.	 Modify the design: Use this approach when the number of changes are 
minimal and are not country/context specific. If too many changes are 
made, it becomes cumbersome to handle changes when the standard 
report is modified in later releases. This is the simplest of all that are 
discussed and similarly can be adopted only for minor changes.
2.	 Create a new design: Here, the standard design is duplicated and the 
design is altered. Use this approach when the report is heavily modified 
or you are implementing it for a specific country but the RDP contract and 
UI builder can still be shared. The choice of the design at runtime can be 
made through the controller class.
3.	 Create a new report: A completely new report is designed and used instead 
of the existing report. Adopt this approach when the RDP logic used by the 
standard report or the UI classes cannot be shared and the report also goes 
for deeper changes. The reports, however, can share the temp table and 
contract if possible.
10.	 Merging changes: Modifying a standard report throws up new challenges such as 
manageability in the longer run, since each cumulative update release from Microsoft 
can bring in more changes to the report design. As of now, there are no efficient tools 
inside AX for merging report changes. There are no references from Microsoft but 
there are a few blogs that discuss widely about the usage of external code-compare 
tools to do the merge. Though it is not a standard approach it can work. Please visit 
http://www.k3technical.com/using-code-compare-to-merge-ssrs-
reports-in-dynamics-ax-2012/ to understand how you could merge changes 
between different layers.
How it works...
The steps discussed in the recipe, help you in identifying all the components involved in a 
typical reporting project. Create a separate project and add the elements to it; this will make 
it easier to perform the required changes. Also apply the design guidelines to see how you 
can accommodate the changes.


Upgrading and Analyzing Reports
206
2.	 Sometimes, the validations go beyond verifying mandatory; in that case, the validate 
operation must be implemented in the contract. As we have learned from the previous 
chapters, there are two kinds of contracts and in the next steps, let us see how to 
implement the validations in each of the contracts.
3.	 To implement the validation in an RDP contract, the contract must implement the 
SysOperationValidatable interface. Once this interface is implemented, the 
validate method is automatically triggered by the framework.
4.	 After implementing the interface, write the validate method. This validate 
method can be used to place all your validations. Here is an example of how the 
validation might look like:
class PktInventBatchTransContract implements
  SysOperationValidatable
{
}
public boolean validate()
{
  boolean isValid;
  if (this.parmProdDate() > today())
  {
    error("Production date must be in the past.");
    isValidate = false;
  }
}
5.	 In case of an RDL contract, the approach differs. There is no need to extend 
the interface since the RDL base class SSRReportRdlDatacontract already 
implements it. Override the validate method from the base class and write 
your validation, as follows:
[
    SrsReportNameAttribute(ssrsReportStr(PktRdlCustTransList,
  CustTransList)),
    SysOperationContractProcessingAttribute(classstr(PktRdlCust
  TransListUIBuilder))
]
class PktRdlCustTransListRdlContract extends
  SrsReportRdlDataContract
{
  Date fromDate, ToDate;
  #define.FromDate('FromDate')

Chapter 7
207
  #define.ToDate('ToDate')
}
public boolean validate()
{
  boolean isValid = super();
  fromDate = this.getValue(#FromDate);
  toDate = this.getValue(#ToDate);
  if(fromDate && toDate)
  {
    if(fromDate > toDate)
    {
      isValid = checkFailed("@SYS120590");
    }
  }
   return isValid;
}
How it works...
Implementing validations in a report is summarized as follows:
f
f
RDP contract validation: The RDP contract validation is invoked by verifying if the 
contract class is implementing the interface. The framework triggers a validate call, 
automatically after the user input. This is because the RDP contract doesn't extend 
any class unlike the RDL contract.
f
f
RDL contract validation: The RDL contract has a base class 
SRSReportRDLDataContract and it is used for all reports. The base class carries 
the framework-level validations for the reports. To implement a custom validation for 
a specific report, extend this class and decorate it with the attributes to indicate the 
report for which it should work. Since the RDL contract stores and retrieves values 
based on their names, the first lines in the validate method are to retrieve the 
values followed by the validation logic. Remember not to prevent the super method 
as it contains the validations.



Upgrading and Analyzing Reports
210
3.	 Now deploy and run the report in AX. When the report opens up, the range is seen 
as Recid. This may not be a convenient way for the user to make the selection. 
This approach can be used when the report needs to show only the relation and 
no selection is needed.
4.	 For reports that use the selection field from the parent table, adopt the approach 
where the parent table is added as a child datasource. Drop all the fields, leaving only 
the relevant field that needs to appear in the selection dialog and in the report. In this 
case, the student master is added to the child datasource and the student id is 
added to the range. The rest of the report remains the same. So when a report dialog 
is shown, the user is able to see the students list instead of recid.
Surrogate keys in RDP
Surrogate keys can be implemented in RDP, as follows:
1.	 In an RDP report, the temporary table that is created can be used to directly store 
the replacement values. In this example report, the temporary table for student's 
marks will have the student id field instead of ref RecId.
2.	 Create an RDP for this temporary table. The process report method must be a simple 
query that fills this temporary table as follows:
[SysEntryPointAttribute(false)]
public void processReport()
{
  Query                   query;
  QueryRun                queryRun;
  QueryBuildRange         studIdRange;
  QueryBuildDataSource    qbds;
  PktStudentMarks          studMarks;
  PktStudentMarksContract  studContract;

Chapter 7
211
  studContract = this.parmDataContract() as
  PktStudentMarksContract;
  query = new query();
  qbds = query.addDataSource(tableNum(PktStudentMarks));
  //set the range
  studIdRange = SysQuery::findOrCreateRange(qbds,
    fieldNum(PktStudentMarks,    RefRecId));
    studIdRange.value(int642str(studContract.parmStudIdSFK()));
  queryRun = new queryRun(query);
  while (queryRun.next())
  {
    studMarks = queryRun.get(tableNum(PktStudentMarks));
    this.insertTmpTable(studMarks);
  }
}
3.	 The contract has the surrogate key as the parm method, since the StudentMarks 
don't have other values:
[
  DataMemberAttribute('StudentId'),
  SysOperationLabelAttribute(literalStr("Student")),
  SysOperationHelpTextAttribute(literalStr("Student
  Details")),
  SysOperationDisplayOrderAttribute('1')
]
public StudISurrogateKey parmStudIdSFK(StudISurrogateKey
  _idSFK = idSFK)
{
  idSFK = _idSFK;
  return idSFK;
}
4.	 Create a report in Visual Studio, and add the RDP created as a datasource. Preview 
and deploy the report to AX.



Upgrading and Analyzing Reports
214
How to do it...
This section will discuss how to perform grouping control at the model level, that is, in the 
VS editor, followed by how to implement it in the UI builder and at contract level.
Grouping in the report model
This applies to the RDP and query-based reports:
1.	 In the Visual Studio report, expand the parameters node. Right-click and navigate 
to Add | Parameter Group. Specify the Date Range label in the caption property. 
Drag the FromDate and ToDate controls into the report.
2.	 Similarly add another group called Options and specify the label.
3.	 Create another parameter group, drag both the groups inside this new group and 
modify the layout direction to Horizontal. This will align all the components inside 
a group in the horizontal direction while the default mode is vertical:



Chapter 7
217
4.	 Now when the report is opened, the report dialog has a new group with a 
checkbox at the top. The checkbox can be used to enable and disable the 
controls under this group.
Grouping in the contract
The grouping mechanism described here applies only to RDP-based reports.
1.	 In the RDP contract for the PktInventBatchTrans report, modify the class 
declaration to add two new groups. This will add groups to the report dialog:
[
  DataContractAttribute,
  SysOperationContractProcessingAttribute
    (classStr(PktInventBatchTransUIBuilder),
      SysOperationDataContractProcessingMode::
        CreateUIBuilderForRootContractOnly),
          SysOperationGroupAttribute('BatchGroup',
            "Batch",'1'),SysOperationGroupAttribute
              ('DateGroup', "Date", '2')
]
class PktInventBatchTransContract implements

Upgrading and Analyzing Reports
218
  SysOperationValidatable
{
  InventDimViewContract       inventDimViewContract;
  InventBatchProdDate         prodDate;
  InventBatchId               batchId;
  boolean                     dummyValue;
}
2.	 Modify the BatchId and ProdDate parm methods to include the new attributes:
[
  DataMemberAttribute('Batch'),
    SysOperationGroupMemberAttribute('BatchGroup'),
      SysOperationDisplayOrderAttribute('1')
]
public InventBatchId parmBatchId(InventBatchId _batchId =
   batchId)
{
  batchId = _batchId;
  return batchId;
}
[
  DataMemberAttribute('ProdDate'),
    SysOperationGroupMemberAttribute('DateGroup'),
      SysOperationDisplayOrderAttribute('1')
]
public InventBatchProdDate parmProdDate(InventBatchProdDate
  _prodDate = prodDate)
{
  prodDate = _prodDate;
  return prodDate;
}
3.	 Include a new dummy parm attribute to verify the display order:
[
  DataMemberAttribute('Verifydisporder'),
    SysOperationGroupMemberAttribute('DateGroup'),
      SysOperationDisplayOrderAttribute('2'),
        SysOperationLabelAttribute("Dummy Value")
]



Chapter 7
221
3.	 Open Visual Studio, create a report and on the new dataset, select RDP. Click on the 
Query node and select the RDP just created. There will be two datasets that will be  
returned by the RDP, one for each temporary table; add the Student dataset to 
the report:
4.	 Similarly, add another dataset and use the RDP. Follow the similar process to choose 
the second temporary table, Student Marks.
5.	 The two datasets are not related in AX and are independent of each other. In this 
example, we create two multiple data regions where one lists Students and the 
other lists Student Marks.
6.	 Drag the datasets to create two different data regions and then run it to see the 
data being rendered.
How it works...
The standard reports such as SalesInvoice and SalesConfirm adopt the same approach. 
In these cases, there is a header table that stores all the header-related information such as 
company address, email, and VATnum that is common across all reports while the other stores 
the line-level information. RDP can return any number of temporary tables and not just two.


Chapter 7
223
public void multiBatchLookup()
{
  Query       query;
  QueryBuildData qbds;
  TableId     multiSelectTableNum = tableNum(InventBatch);
  container   selectedFields      = [multiSelectTableNum,
    fieldName2id(multiSelectTableNum, fieldStr(InventBatch,
      InventBatchId))];
  query = new Query();
  qbds = query.addData(tableNum(InventBatch));
  qbds.addSelectionField(fieldNum(InventBatch,
    InventBatchId));
  qbds.addSelectionField(fieldNum(InventBatch, ItemId));
  SysLookupMultiSelectCtrl::constructWithQuery
    (this.dialog().dialogForm().formRun(),
      multiBatchDialog.control(), query, false,
        selectedFields);
}
public void postRun()
{
  //super();
  this.multiBatchLookup();
}
3.	 We have so far added the list control and enabled a multi-value lookup, the next step 
is to use it in the RDP class. To do this, modify the RDP class in the process report 
method, where the list values are enumerated and added to the query range:
[
  SysEntryPointAttribute(false)
]
public void processReport()
{
  Query                   query;
  QueryRun                queryRun;
  QueryBuildRange         batchRange, dateRange;
  QueryBuildDataSource    qbds;

Upgrading and Analyzing Reports
224
  InventBatch             inventBatch;
  InventTrans             inventTrans;
  InventDim               inventDim;
  InventTransOrigin       transOrigin;
  InventDimViewContract       viewContract;
  PktInventBatchTransContract batchContract;
  List                    batchList;
  ListEnumerator          listEnumerator;
  batchContract = this.parmDataContract() as
    PktInventBatchTransContract;
  viewContract  =
    batchContract.parmInventDimViewContract();
  query = this.parmQuery();
  qbds = query.dataSourceTable(tableNum(InventBatch));
  if (batchContract.parmProdDate())
  {
    dateRange = SysQuery::findOrCreateRange(qbds,
      fieldNum(InventBatch, ProdDate));
    dateRange.value(SysQuery::value(
      batchContract.parmProdDate()));
  }
  batchList = batchContract.parmMultiBatch();
  listEnumerator = batchList.getEnumerator();
  //copy the range from the list to the
  //to the query
  while (listEnumerator.moveNext())
  {
    dateRange = qbds.addRange(fieldNum(InventBatch,
      InventBatchId));
    dateRange.value(SysQuery::value(
      listEnumerator.current()));
  }
  info(query.dataSourceNo(1).toString());
  queryRun = new queryRun(query);

Chapter 7
225
  while (queryRun.next())
  {
    if (queryRun.changed(tablenum(InventBatch)))
    {
      inventBatch = queryRun.get(tableNum(InventBatch));
    }
    if (queryRun.changed(tablenum(InventTransOrigin)))
    {
      transOrigin =
        queryRun.get(tableNum(InventTransOrigin));
    }
    inventTrans = queryRun.get(tableNum(InventTrans));
    inventDim   = queryRun.get(tableNum(inventDim));
    this.insertTmpTable(inventBatch, transOrigin,
      inventTrans, inventDim);
}
}
4.	 Open the Visual Studio project for the report, expand the dataset and refresh 
the dataset by right-clicking and selecting Refresh. This will add the new contract 
parameter to the report. Optionally, set the values such as AllowBlank and Nullable.
5.	 Run the report and see that the report dialog shows multiple values:


Chapter 7
227
3.	 Modify the process report method to fetch the inventory dimension, using inventrans 
and fill the temporary table. The code changes are that simple and completed with 
this step.
4.	 Open the corresponding Visual Studio report, expand the Refresh dataset. The new 
fields will be added to the dataset and the parameters will also show the Boolean 
dimensions flag for each dimension.
5.	 Open the precision design and modify the design to include the dimensions from the 
dataset. The next step is to enable these dimensions based on their corresponding 
parameter.
6.	 On the Row Group and Column Group window at the bottom-right corner, click on the 
dropdown and select the Advanced Mode option. This will make the static control 
visible in the column group:

Upgrading and Analyzing Reports
228
7.	
Each static control represents one column in the active row. Identify the column 
count where the inventory dimensions start, and traverse to the corresponding static 
control column. On the left, the Properties window will show the property for each 
control. Once the static control is selected, choose the hidden property from the 
Properties window. Open the expression editor and enter the following expression:
"=Not(Parameters!InventBatchTrans_ViewConfigId.Value)"
8.	 Build and deploy the report. The report dialog will show all the inventory dimension 
parameters and choosing the parameter should print it in the report:


Upgrading and Analyzing Reports
230
6.	 To add a filter based on this dimension, implement the following steps:
1.	 Create a new parameter under the parameters node of string type.
2.	 Click on the ellipsis button on the Values property.
3.	 This shows the value window. Here select the From Dataset radio button, 
followed by setting the following field values:
Property
Value
Dataset
LedgerDimension
Value Field
Department
Label Field
Department
7.	
Step 6 will help the user to choose the value that he wants to filter. This filter value 
must be passed on to the query so that the data is filtered. The easiest way to do 
this is to create a filter, in the table data region.
8.	 In the filters node in auto design, right-click on the Filters node and click on the 
Add Filter option. In the new filter set the following properties:
Property
Value
Expression
=Fields!Department.Value
Name
DepartmentFilter
Operator
Equals
Value
=Parameters!DepartmentParameter.Value
9.	 The filter region restricts the data that shown in the auto design. So when the report 
is previewed, the report shows only the dimension selected by the user:



Chapter 7
233
  DimensionValue  toDimensionValue;
}
[
  DataMemberAttribute('Account'),
  SysOperationLabelAttribute(literalStr("@SYS182387")),
  SysOperationDisplayOrderAttribute('1')
]
public MainAccountNum parmAccount(
  MainAccountNum _account = account)
{
  account = _account;
  return account;
}
[
  DataMemberAttribute('DimensionAttribute'),
  SysOperationLabelAttribute(literalStr("@SYS24410")),
  SysOperationDisplayOrderAttribute('5')
]
public Name parmDimensionAttribute(
  Name _dimensionAttribute = dimensionAttribute)
{
  dimensionAttribute = _dimensionAttribute;
  return dimensionAttribute;
}
[
  DataMemberAttribute('FromDimensionValue'),
  SysOperationLabelAttribute(literalStr("@SYS105870")),
  SysOperationDisplayOrderAttribute('2')
]
public DimensionValue parmFromDimensionValue(
  DimensionValue _fromDimensionValue = fromDimensionValue)
{
  fromDimensionValue = _fromDimensionValue;
  return fromDimensionValue;
}
[
  DataMemberAttribute('ToDimensionValue'),
  SysOperationLabelAttribute(literalStr("@SYS103530")),
  SysOperationDisplayOrderAttribute('6')
]
public DimensionValue parmToDimensionValue(
  DimensionValue _toDimensionValue = toDimensionValue)
{
  toDimensionValue = _toDimensionValue;
  return toDimensionValue;
}

Upgrading and Analyzing Reports
234
3.	 The UI builder for the financial dimension plays a crucial role, since that is where the 
dimension and dimension range must be set by the user. The standard comes to 
our rescue by offering a whole set of logic that can be reused. This ranges from the 
lookup method to the validate logic. To harness this, the UI builder class must extend 
the LedgerAccountReportUIBuilder class. The UI builder implementation logic 
can be as follows:
class PktGeneralJournalReportUIBuilder extends
  LedgerAccountReportUIBuilder
{
  DialogField dialogFieldAccountName;
  Name        dimensionAttribute;
  #define.Columns(2)
  #define.DialogFieldLength(30)
}
public void build()
{
  FormBuildGroupControl   formBuildGroupControl;
  super();
  formBuildGroupControl = this.dialog().curFormGroup();
  formBUildGroupControl.columns(#Columns);
}
public void dimensionAttributeLookup(FormStringControl
  _dimensionAttributeDialogControl)
{
  super(_dimensionAttributeDialogControl);
}
public boolean dimensionAttributeModify(FormStringControl
  _dimensionAttributeDialogControl)
{
  if (dimensionAttribute != dialogFieldAttribute.value())
  {
    /*If modified "Dimension Attribute" is different with
      previous,set the "From Dimension" and "To Dimension"
        as null*/
    dialogFieldFromDimension.value('');
    dialogFieldToDimension.value('');

Chapter 7
235
    dimensionAttribute = dialogFieldAttribute.value();
  }
  return true;
}
public boolean dimensionAttributeValidate(FormStringControl
  _dimensionAttribute)
{
  boolean ret;
  ret = super(_dimensionAttribute);
  return ret;
}
public void dimensionValueLookup(FormStringControl
  _dimensionValueControl)
{
  super(_dimensionValueControl);
}
public boolean dimensionValueValidate(FormStringControl
  _dimensionValue)
{
  boolean ret;
  ret = super(_dimensionValue);
  return ret;
}
protected void modifyOverrideMethod()
{
  this.overrideDialogFieldLookup(dialogFieldAttribute,
    methodStr(PktGeneralJournalReportUIBuilder,
      dimensionAttributeLookup));
  this.overrideDialogFieldLookup(dialogFieldFromDimension,
    methodStr(PktGeneralJournalReportUIBuilder,
      dimensionValuelookup));
  this.overrideDialogFieldLookup(dialogFieldToDimension,
    methodStr(PktGeneralJournalReportUIBuilder,
      dimensionValuelookup));

Upgrading and Analyzing Reports
236
  this.overrideDialogFieldMethod(dialogFieldAttribute,
    methodStr(FormStringControl, Modified),
      methodStr(PktGeneralJournalReportUIBuilder,
        dimensionAttributeModify));
  this.overrideDialogFieldMethod(dialogFieldAttribute,
    methodStr(FormStringControl, Validate),
      methodStr(PktGeneralJournalReportUIBuilder,
        dimensionAttributeValidate));
  this.overrideDialogFieldMethod(dialogFieldFromDimension,
    methodStr(FormStringControl, Validate),
      methodStr(PktGeneralJournalReportUIBuilder,
        dimensionValueValidate));
  this.overrideDialogFieldMethod(dialogFieldToDimension,
    methodStr(FormStringControl, Validate),
      methodStr(PktGeneralJournalReportUIBuilder,
        dimensionValueValidate));
}
public void postBuild()
{
  SysOperationUIBindInfo binfo = this.bindInfo();
  Object                 contract =
    this.dataContractObject();
  dialogFieldAttribute        =
    binfo.getDialogField(contract,
      methodStr(PktGeneralJournalReportContract,
        parmDimensionAttribute));
  dialogFieldFromDimension    =
    binfo.getDialogField(contract,
      methodStr(PktGeneralJournalReportContract,
        parmFromDimensionValue));
  dialogFieldToDimension      =
    binfo.getDialogField(contract,
      methodStr(PktGeneralJournalReportContract,
        parmToDimensionValue));
  dialogFieldAccount          =
    binfo.getDialogField(contract,
      methodStr(PktGeneralJournalReportContract,
        parmAccount));
  super();
  dialogFieldAccount.displayLength(#DialogFieldLength);
}

Chapter 7
237
4.	 The next step is to get the RDP class. Create a new RDP class and add the 
following code:
[
  SRSReportParameterAttribute(
    classStr(PktGeneralJournalReportContract))
]
class PktGeneralJournalReportDP extends
  SRSReportDataProviderBase
{
  PksGeneralJournalEntryReportTmp reportTmp;
}
[
  SRSReportDataSetAttribute(
    tableStr(PksGeneralJournalEntryReportTmp))
]
public PksGeneralJournalEntryReportTmp getJournalTmp()
{
  select  reportTmp;
  return  reportTmp;
}
private void insertinTmp(
  GeneralJournalAccountEntry          accountEntry,
  GeneralJournalEntry                 journalEntry,
  DimensionAttributeLevelValueView    restrictView,
  DimensionAttributeLevelValueView    accountValue)
{
    ;
  reportTmp.initValue();
  reportTmp.AccountNum = accountValue.DisplayValue;
  reportTmp.Quantity   = accountEntry.Quantity;
  reportTmp.AccountingCurrencyAmount =
    accountEntry.AccountingCurrencyAmount;
  reportTmp.Text      = accountEntry.Text;
  reportTmp.IsCredit  = accountEntry.IsCredit;
  reportTmp.JournalNumber = journalEntry.JournalNumber;
  reportTmp.DocumentNumber = journalEntry.DocumentNumber;
  reportTmp.DocumentDate = journalEntry.DocumentDate;
  reportTmp.Dimension    = restrictView.DisplayValue;
  reportTmp.insert();
}

Upgrading and Analyzing Reports
238
[
  SysEntryPointAttribute(false)
]
public void processReport()
{
  GeneralJournalAccountEntry      accountEntry;
  GeneralJournalEntry             journalEntry;
  DimensionAttributeLevelValueView valueView, restrictView;
  DimensionAttributeLevelValueView accountValue;
  DimensionAttribute      dimensionAttributeTable;
  PktGeneralJournalReportContract contract;
  Name            dimensionAttribute;
  MainAccountNum  account;
  DimensionValue  fromDimensionValue;
  DimensionValue  toDimensionValue;
  contract = this.parmDataContract();
  dimensionAttribute = contract.parmDimensionAttribute();
  dimensionAttributeTable =
    DimensionAttribute::findByLocalizedName(
      dimensionAttribute, false,
        SystemParameters::find().SystemLanguageId);
  fromDimensionValue = contract.parmFromDimensionValue();
  toDimensionValue   = contract.parmToDimensionValue();
  account            = contract.parmAccount();
  delete_from reportTmp;
  ttsBegin;
  while select DisplayValue from accountValue
    where  accountValue.DisplayValue == account
    join AccountingCurrencyAmount, Text, quantity from
      accountEntry
    where accountEntry.LedgerDimension ==
      accountValue.ValueCombinationRecId
      join journalNumber, DocumentDate, DocumentNumber from

Chapter 7
239
      journalEntry
       where journalEntry.RecId ==
      accountEntry.GeneralJournalEntry
       join restrictView
       where restrictView.ValueCombinationRecId ==
        accountEntry.LedgerDimension
       &&    restrictView.DimensionAttribute    ==
         dimensionAttributeTable.RecId
       &&    restrictView.DisplayValue          >=
         fromDimensionValue
       &&    restrictView.DisplayValue          <=
         toDimensionValue
  {
    this.insertinTmp(accountEntry, journalEntry,
      restrictView, accountValue);
  }
  ttsCommit;
}
5.	 The process report method is designed to find all general journal entries for a specific 
account number in a specified range. A DML is used to retrieve this data.
6.	 Once the coding changes are complete, create a new report in Visual Studio and link 
the RDP report that was just created.
7.	
Create a precision design with a table control as shown in the following image. 
Choose the fields. For the dimension attribute field in the precision design, enter 
=Parameters!JournalData_DimensionAttribute.Value so that the label 
printed will be based on the dimension selected. The image indicates how the report 
design would look like:


8
Troubleshooting 
and Other Advanced 
Recipes
This chapter will cover the following recipes:
f
f
Assessing report performance and usage
f
f
Handling long running reports in AX
f
f
Troubleshooting reports in AX
f
f
Auto e-mail and Save as file tasks in reports
f
f
Handling events post report completion
f
f
Generating and displaying barcodes in reports
f
f
Hiding controls by context
f
f
Using AXEnumProvider as dataset for parameters in reports
f
f
Adding a new report design to print management
f
f
Deploying language-specific reports to speed up execution time
f
f
Making your reports function better


Chapter 8
243
3.	 On the Execution Log Reports field choose Reports Execution summary. This gives 
a detailed insight into overall report performance. Click on Show Filters and apply a 
date range among the different kinds of ranges available.

Troubleshooting and Other Advanced Recipes
244
4.	 These reports reveal the time for data retrieval, report processing, and report 
rendering for reports in the selected filter criteria:
5.	 The Catalog view offers other reports, such as Reports by User and Reports 
by Month as seen here. These offer more beneficial parameters that help in 
fine-tuning the report performance and usage:



Chapter 8
247
    /* Using the query from the contract, count up to the error 
limit + 1 since anything over the error limit will return the same 
error*/
    container   validateResult;
    Query       query = this.getFirstQuery();
    int         rowCount = queryRun::getQueryRowCount(query, 
#ErrorLimit + 1);
    if (rowCount > #ErrorLimit)
    {
        validateResult = [SrsReportPreRunState::Error];
    }
    else if (rowCount > #WarningLimit)
    {
        validateResult = [SrsReportPreRunState::Warning];
    }
    else
    {
        validateResult = super();
    }
    return validateResult;
}
f
f
Implement preprocess: If during design or at later point you identify that the delay 
in the report data is caused because of the data insertion into the temporary table 
in the processReport method, then enable preprocessing.
f
f
SSRS uses WCF to connect to AOS for data access. This connection has a threshold 
limit and it might fail if a report takes a longer time to execute. The report server 
execution waits for RDP to process the data and return. In the event where the RDP 
takes a longer time to execute, the reporting service might fail. Preprocessing is a 
strategy to beat through this issue. To understand how to enable preprocessing for 
reports read the Preprocessing reports recipe from Chapter 4, Report Programming 
Model – RDP.

Troubleshooting and Other Advanced Recipes
248
Configuration-based resolution
Report execution time must be always kept minimum by applying the design time principles 
and best practices discussed in the previous section. The configuration-based methods must 
be adopted to make sure the overall reporting experience is smooth.
f
f
Data extension-based timeout: This timeout occurs when there is a delay for the 
reporting services to fetch the data from Dynamics AX. It is to be understood that the 
AX-specific data extension uses the WCF based query service to access the data. So 
any data-related timeout has to be configured by fine-tuning the WCF timeout. WCF has 
two ends, the client and the server, so the timeout has to be adjusted at both ends.
Server-side WCF timeout:
1.	 Locate the AX32Serv.exe.config file located at \Program Files\
Microsoft Dynamics AX\ <version>\Server\Microsoft 
DynamicsAX\Bin.
2.	 Open the file for editing (Notepad/Visual Studio) and identify the element 
QueryServiceBinding.
3.	 Increase the sendTimeout property. The default value is set to 10 and can 
be changed to a longer time as needed. The range must be decided based 
on your longest running report.
4.	 Save the changes.
Client-side WCF timeout:
1.	 Open the Run window and type AXclicfg to open the client configuration.
2.	 Create a new client configuration and give it a name.
3.	 In the Connection tab, click on the Configure Services button. A message 
is displayed as seen here. Click on OK to continue.

Chapter 8
249
4.	 In the Configuration window that opens up, select the Bindings node from 
the tree node and identify the sibling QueryServiceEndPoint(netTcpBinding).

Troubleshooting and Other Advanced Recipes
250
5.	 On the adjacent Bindings tab, find the property SendTimeOut, and then 
increase it from the default value of 10 to the desired amount:
6.	 Similarly, on the MaxReceivedMessageSize property increase the message 
size from the default value to the desired value. The max value is the int64 
limit since this is an int64 field.
7.	
Click on Apply, and then OK.
f
f
Report execution timeout: This setting decides how long the report attempts to 
keep the execution going before it stops the execution through a timeout. The time 
specified here ideally must be the time taken by the longest report in the application. 
This can be defined for the all reports or a specific report.
Specify for all reports:
1.	 Open the Report Manager available at the URL; for example, 
http://[SSSRSServerName]:80/Reports.
2.	 Click on Site Settings to open the Properties page.

Chapter 8
251
3.	 In the Properties page under Report Timeout specify the number of seconds.
4.	 Click on Apply to save the changes.
Specify for a specific report:
1.	 To specify for a specific report, select the report, click on the drop-down 
arrow, and then click on Manage. On the Properties page, set the Report 
Timeout that will apply to that specific report.
f
f
User-session timeout: Though this has nothing to do with performance, this governs 
the total time a user is allowed to have his or her session open untouched. This value 
must be greater than the Report Processing timeout.
1.	 Create a file timeout.rss with the script shown here and save it to the drive:
Public Sub Main()
    Dim props() as [Property]
    props = new [Property] () { new [Property](), new 
    [Property]() }
    
    props(0).Name = "SessionTimeout"
    props(0).Value = timeout
    
    props(1).Name = "SessionAccessTimeout"
    props(1).Value = timeout
    
    rs.SetSystemProperties(props)
End Sub


Chapter 8
253
Deployment-related issues
These are issues concerning deploying reports from AX or Visual Studio and getting them 
updated in AX.
Unable to deploy
1.	 Verify SSRS configuration: The first step to ensure when you face a deployment is 
configuration. Ensure the configuration specified in System Administration | Setup | 
Business Intelligence | Reporting Services | Reporting servers is accessible and 
valid. Try opening the SSRS reporting services manager through the browser.
2.	 Rebuild versus project: Open the Visual Studio project along with the reference 
assemblies, if any, and rebuild the project.
3.	 File lock errors: On receiving file lock errors restart the report server.
Unable to refresh
1.	 Restore report: Open the SSRS report node and navigate to your report. 
Right-click and select Restore.
2.	 Refresh cache: Since caching is enabled, there might be cache-related issues. 
Go to Tools | Caches | Refresh Elements.
3.	 Redeploy: Delete the report from the reporting service manager and redeploy 
the report:


Chapter 8
255
2.	 Dynamic parameters: In case of dynamic parameters, verify the range in the 
query node and if there is any initialization done in the controller. Ranges for 
dynamic parameters come from the range node in a query.
3.	 Issues with label/grouping: Grouping can be implemented at various levels in 
a report and it varies based on the report. Make sure to verify the places in the 
following list to identify and resolve issues related to grouping:


For query-based reports, visit VS project/UI builder


For RDP-based reports, visit Contract/VS project/UI builder
4.	 Initialization and validation issues: Check the contract/controller classes for issues 
related to initialization and validation.
5.	 Formatting issues: Use color coding to understand the spacing between controls. 
This will give the knowledge of the control that is taking up the space, based on which 
you can modify the parameters to fine-tune the spacing, and then later remove the 
color coding.

Troubleshooting and Other Advanced Recipes
256
6.	 Localization issues:
1.	 Use Visual Studio preview to quickly switch between languages and verify the 
report rendering in different languages:
2.	 Enum translation issues: Each enum field in a query or contract when added 
to the dataset results in two different fields. One holds the label and the other 
holds the system name; always use the Enum.Label field in report rendering. 
In the screenshot seen here, you can see two fields being rendered for the 
field TransType. The name type can be used in programming references 
while the label can be used for rendering purposes:





Chapter 8
261
Sending the report through an e-mail
To send the file through an e-mail the procedure is not much different except the need to pass 
an e-mail contract:
public static void mailReport(Args _args)
{
    SrsReportRunController controller = new 
PktRdlCustTransListController();
    SRSPrintDestinationSettings printSettings;
    SrsReportEMailDataContract emailContract;
    // set report name
    controller.parmReportName(ssrsReportStr(PktRdlCustTransList, 
CustTransList));
    // create email contract
    emailContract = new SrsReportEMailDataContract();
    // fill in the email contract details
    emailContract.parmAttachmentFileFormat(SRSReportFileFormat::PDF);
    emailContract.parmSubject("Customer Transactions");
    emailContract.parmTo("admin@contoso.com");
        
    printSettings = controller.parmReportContract().
parmPrintSettings();
    
    printSettings.printMediumType(SRSPrintMediumType::Email);
    printSettings.parmEMailContract(emailContract);
    printSettings.fileFormat(SRSReportFileFormat::PDF);
    // suppress the parameter dialog
    controller.parmShowDialog(false);
    
    controller.startOperation();
}
How it works…
The printer setting is a contract similar to the RDL and RDP contracts. The printer setting can 
be modified inside the controller if it requires manipulation. This must be performed in the 
preRunModifyContract method in the controller. If the report is required to be opened 
through a code, then all that is needed is to invoke the code that is given in this recipe and 
keeping the printer setting-related changes is optional.


Chapter 8
263
    {
        // Get the report's query
        query = _sender.getFirstQuery();
        // Mark all the records as printed
        queryRun = new QueryRun(query);
        
        ttsbegin;
        while(queryRun.next())
        {
            batchNum = queryRun.get(tableNum(InventBatch)).
(fieldNum(InventBatch, inventBatchId));
            update_recordset batchStatus
                setting Printed       = NoYes::Yes,
                        PrintDateTime = executionInfo.
parmExecutionDateTime();
                where batchStatus.inventBatchId == batchNum;
        }
        ttscommit;
    }
}
3.	 The next step is to hook the event to the delegate. This can be done anywhere before 
the preRunModifyContract event but the standard recommendation is to write it 
inside the preRunModifyContract method.
protected void preRunModifyContract()
{
    this.renderingCompleted += eventhandler(PktInventBatchTransCon
troller::renderingComplete);
}
4.	 When the report execution is completed, the method will be invoked and the records 
fetched through the query will be updated.
How it works…
Since SSRS report execution is asynchronous as it connects to the AOS via the WCF service, 
the rendering complete will be the best approach to hook events post the report complete. 
Though the method attached to the delegate here is a static method instance, methods 
can also be used. The arguments controller gives complete access to the report that was 
executed. The SRSRenderingCompletedEventArgs class has access to the object 
SRSReportExecutionInfo. The execution info carries several information pertaining to 
the report that was just executed, such as number of pages, if print was successful, layout, 
execution time, and many more.


Chapter 8
265
3.	 Create a Contract class as shown here. The barcode setup field in the Contract 
class is used to choose the format of barcode, such as Code39/EAN:
[
    DataContractAttribute,
    SysOperationGroupAttribute('BatchGroup', "Batch", '1')
]
class PktInventBatchBarCodeContract
{
    InventBatchId           batchId;
    BarcodeSetupId          barcodeSetupId;
    FontSize                batchFontSize;
    FontName                barcodeFontName;
}
[DataMemberAttribute('Batch'),
SysOperationGroupMemberAttribute('BatchGroup'),
SysOperationDisplayOrderAttribute('1')]
public InventBatchId parmBatchId(InventBatchId _batchId = batchId)
{
    batchId = _batchId;
    return batchId;
}
[
    DataMemberAttribute('BarcodeSetupId'),
    SysOperationGroupMemberAttribute('BatchGroup'),
    SysOperationHelpTextAttribute(literalStr("@SYS102646")),
    SysOperationDisplayOrderAttribute('2')
]
public BarcodeSetupId parmBarcodeSetupId(BarcodeSetupId _
barcodeSetupId = barcodeSetupId)
{
    barcodeSetupId  =    _barcodeSetupId;
    
    return barcodeSetupId;
}
[
    DataMemberAttribute('BarcodeFontName'),
    SysOperationGroupMemberAttribute('BatchGroup'),
    SysOperationDisplayOrderAttribute('3')
]

Troubleshooting and Other Advanced Recipes
266
public FontName parmBarcodeFontName(FontName _barcodeFontName = 
barcodeFontName)
{
    barcodeFontName     =   _barcodeFontName;
    
    return barcodeFontName;
}
4.	 Create an RDP class using the code here. The RDP class will apply the selected 
barcode setup chosen by the user in the report dialog box to encode the batch 
number to the barcode;
[
    //bind query - shows in the report dialog
    SRSReportQueryAttribute(queryStr(PktinventBatchBarCode)),
    //bind the contract
    SRSReportParameterAttribute(classStr(PktInventBatchBarCodeCont
ract))
]
class PktInventBatchBarCodeDp Extends SRSReportDataProviderBase
{
    BarcodeSetupId  barcodeSetupId;
    FontName        barcodeFontName;
    FontSize        barcodeFontSize;
    PktInventBarCodeTmp  barCodeTmp;
}
[SysEntryPointAttribute(false)]
public void processReport()
{
    QueryRun                        queryRun;
    PktInventBatchBarCodeContract   contract;
    BarcodeSetup                    barcodeSetup;
    Barcode                         barcode;
    QueryBuildRange                 batchRange;
    breakpoint;
    contract = this.parmDataContract() as 
PktInventBatchBarCodeContract;
    barcodeSetup    = BarcodeSetup::find(contract.
parmBarcodeSetupId());

Chapter 8
267
    barcode         = barcodeSetup.barcode();
    contract.parmBarcodeFontName(barcodeSetup.fontName);
    
    batchRange  =   this.parmQuery().dataSourceTable(tableNum(Inve
ntBatch)).addRange(fieldNum(InventBatch,InventBatchId));
    batchRange.value(contract.parmBatchId());    
    queryRun = new QueryRun(this.parmQuery());
    while (queryRun.next())
    {
        this.insertBarCodeTmpTable(queryRun.
get(tableNum(InventBatch)) as InventBatch, barcodeSetup, barcode);
    }
}
protected void insertBarCodeTmpTable(
          InventBatch     _inventBatch
        , BarcodeSetup    _barcodeSetup,
          Barcode         _barcode)
{
    int                     currentInfologLine;
    SysInfologEnumerator    infoEnumerator;
    // encode barcodes
    barCodeTmp.clear();
    if(_barcodeSetup)
    {
        currentInfologLine = infologLine();
        if (_barcodeSetup.validateBarcode(_inventBatch.
inventBatchId))
        {
            _barcode.string(true, _inventBatch.inventBatchId);
            if (_barcodeSetup.FontName)
            {
                barCodeTmp.Barcode = _barcode.barcodeStr();
            }
            barCodeTmp.BarcodeHR        = _barcode.barcodeStrHR();

Troubleshooting and Other Advanced Recipes
268
            barCodeTmp.InventBatchId    = _inventBatch.
inventBatchId;
            barCodeTmp.insert();
        }
        else
        {
            infoEnumerator = SysInfologEnumerator::newData(infol
og.copy(currentInfologLine + 1, infologLine()));
            return;
        }
    }
}
[SRSReportDataSetAttribute(tableStr(PktInventBarCodeTmp))]
public PktInventBarCodeTmp getBarCodeTmp()
{
    select  barCodeTmp; 
    return  barCodeTmp;
}
5.	 Create a Controller class as shown here. The Controller class will find the barcode 
setup and set the FontName and Fontsize accordingly. This makes it possible to 
dynamically change the barcode type at runtime:
public class PktInventBatchBarCodeController extends 
SrsReportRunController
{
}
public static void main(Args _args)
{
    PktInventBatchBarCodeController controller = new 
PktInventBatchBarCodeController();
    controller.parmReportName(ssrsReportStr(PktInventBatchBarCode, 
InventBatchBarCode));
    controller.parmArgs(_args);
    controller.startOperation();
}
public void preRunModifyContract()
{
    BarcodeSetup                     barcodeSetup;
    PktInventBatchBarCodeContract    contract = 
this.parmReportContract().parmRdpContract() as 
PktInventBatchBarCodeContract;

Chapter 8
269
    barcodeSetup = BarcodeSetup::find(contract.
parmBarcodeSetupId());
    if (barcodeSetup)
    {
        contract.parmBarcodeFontName(barcodeSetup.FontName);
        contract.parmBatchFontSize(barcodeSetup.FontSize);
    }
    else
    {
        contract.parmBarcodeFontName('');
        contract.parmBatchFontSize(0);
    }
}
public void prePromptModifyContract()
{
    BarcodeSetup                    barcodeSetup;
    PktInventBatchBarCodeContract    contract;
    Query                           query;
    InventBatch                     inventBatch;
    QueryBuildDataSource            queryBuildDataSource;
    QueryBuildRange                 qbrInventBatchId;
    contract = this.parmReportContract().parmRdpContract() as 
PktInventBatchBarCodeContract;
    if (!contract.parmBarcodeSetupId())
    {
        select firstonly barcodeSetup
            where barcodeSetup.BarcodeType == BarcodeType::Code39;
        if (barcodeSetup)
        {
            contract.parmBarcodeSetupId(barcodeSetup.
BarcodeSetupId);
        }
    }
    query                   = this.getFirstQuery();
    queryBuildDataSource    = SysQuery::findOrCreateDataSource(que
ry, tableNum(inventBatch));

Troubleshooting and Other Advanced Recipes
270
    if (this.parmArgs()
     && this.parmArgs().record() is InventBatch
     && this.parmArgs().record().isFormDataSource())
    {
        inventBatch = this.parmArgs().record() as InventBatch;
        qbrInventBatchId     = SysQuery::findOrCreateRange(queryBu
ildDataSource, fieldNum(InventBatch, InventBatchId));
        qbrInventBatchId.value(queryValue(inventBatch.
inventBatchId));
    }
}
6.	 Create a report and attach the RDP class as datasource.
7.	
Create a new precision design and add a table control.
8.	 In the table control, delete all the columns except the first column and select 
the InventBatchId field in the first column.
9.	 Insert three columns at the bottom and select the field barcode, BarcodeHR, 
and barcode sequentially.
10.	 Select the text boxes for the field barcode. On the font toolbar modify the font 
to BC C39 3 to 1 HD Wide, set the size to 48pt, and set the alignment to center. 
This is a static way of specifying the barcode setup:
11.	 Select the last barcode box at the bottom, and on the Properties window set the 
WritingMode property to vertical. This will print the barcode in the vertical direction.

Chapter 8
271
12.	Select the barcode and on the Properties window for font family set the following 
expression; this will make the font dynamic so that it can be chosen at runtime:
=iif(IsNothing(Parameters!BarcodeFontName.Value),"Tahoma", 
Parameters!BarcodeFontName.Value)
13.	Resize the barcode textbox to fit the barcode when printed.

Troubleshooting and Other Advanced Recipes
272
14.	 Run the report  and choose the  barcode setup in the report dialog.
15.	The report output shows the barcode that is horizontally and vertically aligned.

Chapter 8
273
How it works…
Dynamics AX has inbuilt classes that support encoding for most types of barcodes and more 
can be added easily by extending the Barcode class.
The report here flexibly allows the user to choose the encoding mechanism at runtime. The 
report picks up the available barcode from Organization administration | Setup | Barcode.
 


Chapter 8
275
4.	 On the Design node, navigate to the control that must be toggled based on the flag. 
In the Property window set the visible property through an expression to point to the 
newly added parameter:
=Not(!Parameter.HiddenParm.Value)
5.	 The next step is to set this flag from the controller based on the context. To do this, 
navigate to the Controller class and on the preRunModifyContract method 
access contract and set the value as shown here:
class PktRdlCustTransListController extends SrsReportRunController
{
}
protected void preRunModifyContract()
{
    #ISOCountryRegionCodes
    SrsReportRdlDataContract    contract   =
                                    this.parmReportContract().
parmRdlContract();
    if(SysCountryRegionCode::isLegalEntityInCountryRegion([#iso
IN]))
    {
        contract.setValue("HiddenParm", true);
    }


Chapter 8
277
3.	 In the Application explorer, navigate to DataDictionary | Tables | (Select the table 
that has the enumerator) | Fields | (Select the Enum field) and identify the Enum that 
it uses. Type the value in the Query property in the dataset:
4.	 This will add a dataset with fields Name, Value, and Label:


Chapter 8
279
3.	 If it is required to make this the default report in print management, then in the class 
PrintMgmtDocType modify the getDefaultReportFormat method to replace 
the report name for the document type. If the report layout is country specific then 
apply the appropriate condition:
if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                return ssrsReportStr(SalesInvoice, Report_Custom);
            }
4.	 Navigate to Accounts Receivable | Setup | Forms | Forms Setup. Click on the Print 
Management button.
5.	 In Print Management navigate to the Customer Invoice record and click on the drop-
down list to see the Report Format field that was added:



Troubleshooting and Other Advanced Recipes
282
9.	 Limit display methods from the query node: Though you are allowed to choose 
display methods using the query datasource, always limit the number of methods 
and consider each is really needed in the report. When there are a lot of display 
methods or a performance delay is noticed, create a view. This can bring a 
significant difference to the performance of the report.
10.	 Use query ranges: Strive to place select conditions as much possible as ranges on 
the query rather than using the Filter option in the report design or by adding if 
conditions in the RDP.
11.	 Use set-based processing RDP: Evaluate if the RDP requires a query to collect the 
user inputs. If not, try to use set-based operations, such as insert_recordset 
and update_recordset operations to bulk-process records to the temporary 
table used in the RDP as these operations are exponentially faster.
12.	Resize images: The AOS service has a limit of 1 GB for streaming data to the 
reporting service. When using reports that contain images and bulk number of 
transactions, this can cause choking or slowing down. Avoid using the .bmp file 
format and use compressed image formats, such as JPG or PNG instead.







Appendix
289
Datasets
A dataset contains the details of the data source and the means to retrieve the data through it. 
The dataset is shared across multiple designs in the report. A dataset represents flattened data, 
and hierarchical relations are not represented. Here is a list of data sources and fetch options 
currently supported:
Data Source
Option
Dynamics AX
f
f
AOT queries
f
f
Report data provider AX classes
f
f
Data methods in reporting project
SQL
f
f
TSQL query
f
f
Stored procedure
f
f
Dynamics AX OLAP
OLAP
f
f
MDX query
The data fetched from Dynamics AX honors the security-related to roles for both metadata 
and data; for example, a field that is hidden and a setup to show only the records created 
by the user running the report. The other cases of SQL and OLAP security must be employed 
at the database level.
Design
There are two different designs that are supported.
Auto design
A design is automatically generated based on the report data. The placement and the layout 
of controls are decided by the system with limited options for the user. It is simple and easy 
to create.
Precision design
A design is to be done by the developer through the SQL report designer. It helps in designing 
a to-the-scale design but is time consuming.

Introduction to SSRS
290
Apart from this, a report model contains several elements; here is a quick overview of different 
components in a model with a brief description.
Element
Icon
Description
Data 
method
This contains code to retrieve and process data 
for a report. The code for a data method is written 
in C# or Visual Basic, depending on which project 
template is used.
Data region
This is an area in a report that displays data. 
Data can be displayed in table, list, matrix, 
or chart formats.
Parameter
This lets you parameterize data for a report.
Filter
This is used to filter or restrict the data that is 
displayed in a report.
Grouping
This lets you organize data that displays in a 
report by grouping fields.
Sorting
This lets you control the order in which data is 
displayed in a report.
Image
Any image that is utilized by the report is defined 
here.
Layout 
template
This specifies the styles that are applied to the 
header, footer, and body of a report. One layout 
template can be applied to many reports.
Style 
template
This defines the template for a data region and 
can be applied to more than one data region. 
Templates are data region dependent, that is, 
a certain template is applicable only to a certain 
data region.



Index
A
Advanced Mode option  227
advanced RDP report
creating  85-91
aggregation
implementing, in reports  35, 36
AllowBlank property  205
analysis report  191
AOT query  50
auto design
creating, from dataset  11-14
images, adding in  36, 37
subreport, creating  154-157
auto e-mails
saving, in reports  260
AX
deployment options  17
long running reports, handling in  246
reports, troubleshooting  252
AX 2009
versus AX 2012  287
AX 2012
versus AX 2009  287
AXEnumProvider
using, in reports  276-278
AX reports
about  288
artifacts  288
AX SSRS  41
B
barcodes
displaying, in reports  264-274
generating, in reports  264-274
bounded parameters  40
build method  60
business logic
about  70
data methods  66-68
datasource, adding  108-111
used, for parameter lookup build  115-119
C
chart data region
about  27
creating  27, 29
chart reports
in auto design  180, 181
charts
adding, to report  27
Client side WCF timeout  248
column chart report
about  172
creating  172-175
company images
report, building with  98, 99
concepts, RDP
RDP class  78
RDP data contract  78
UI builder  78
configuration-based resolution  248-252
configurations, Dynamics AX  291
consolidation report  191
context
controls, hiding by  274-276
controller
about  48
multiple reports, calling from  63, 64
report, opening through  48, 49

294
report query, modifying  52
controller class  260
controller issues  259
controls
hiding, by context  274-276
control visibility issue  257
customer summary OLAP report
about  125
creating  125-129
D
data extension based timeout  248
data method
versus expressions  68
data methods, business logic  66-68
Data Processing Extensions (DPE)  286
data regions
about  24
adding, to report  27
chart data regions  29
creating, steps  25, 26
filters, adding  42, 43, 44
list data regions  29
matrix data regions  29
table data regions  29
data related issues
handling  258
dataset
auto design, creating  11-14
dataset, report model  289
datasource
adding, through business logic  108-111
spin-off recipes  114
XML feed, using as  112-114
deployment related issues
about  253
reports, unable to deploy  253
reports, unable to refresh  253, 254
design-based resolution  246, 247
designs, report model
about  289
auto design  289
precision design  289
DLL (dynamic-link library)  70
DML (Data Manipulation Language)  86
document map navigation
adding, to report  44, 45
drill down navigation
adding, to report  45, 46
drill up navigation
adding, to report  45, 46
Dynamic Filter property  17
dynamic filters  42
dynamic parameter issue  255
Dynamics AX
reporting extensions  285
Dynamics AX 2012
reporting overview  6
E
e-mail
reports, sending through  261
enum translation issue  256
events post reporting completion
handling  262, 263
existing report
analyzing  201-204
modifying  201-204
expressions
about  32
implementing, in reports  33, 34
URL, for info  34
versus data method  68
expressions related issue  257
Extended Data Types (EDTs)   196
external datasource
report, building through  120-123
external datasource query
parameter, adding  124
External Data Sources  41
F
file
reports, saving to  260
filters
adding, to data regions  42-44
financial dimension
in RDP reports  232-240
in query reports  229-231
formatting issue  255

295
G
gauges
about  182
in reports  182-185
group headers  257
grouping
in reports  14, 15
grouping issue  255
group view report
creating  92-97
H
headers
report, building with  98, 99
I
IIF() function  34
image
adding, in auto design  36, 37
initialization issue  255
inventory dimension
in report  226-228
nested data contract  229
L
label issue  255
Language Integrated Natural 
Query (LINQ)   114
language-specific reports
deploying, to speedup execution 
time  280, 281
layout template
about  29
creating  29-32
LedgerAccountReportUIBuilder class  234
legacy reporting system
about  161
drawbacks  283
line chart
about  176
creating  176-180
list control
in reports  186-190
localization issue  256
log viewer
using  258
long running reports
configuration-based resolution  248-252
design-based resolution  246, 247
factors, modifying  246, 247
handling, in AX  246
timeout, setting  248-252
M
main query  135
map subreport
designing, with SQL Report Builder  145-154
matrix report
about  162
creating  165-167
design  162, 163
menu item
creating, for report  19-22
Morphx IDE  50
multicolumn matrix report
about  168
creating  168-172
multiple reports
calling, from controller  63, 64
multiple temporary table
RDP  220, 221
multi-value lookup
selecting  222-225
N
native mode
versus SharePoint integrated mode  291
nested data contract  229
O
OLAP
about  41
parameter lookup, adding  129-135
OLAP table report
designing, SQL Report Builder used  136-144

296
P
parameter issue  254
parameter lookup
adding, for OLAP  129-135
building, business logic used  115-119
parameters
adding, for external datasource query  124
system parameters  40
user-defined parameters  40
parm method  264
precision designs
about  81
creating  81-84
subreport, creating  157-160
prePromptModifyContract method  53
preRunModifyContract method  261
print management
new report design, adding to  278-280
ProcessReport method  76
Q
query
about  41
using as data source in report  6-11
query-based report
data, handling  258
query parameters  41
Query property   110
query reports
financial dimension   229-231
R
ranges
adding, from unbound parameters 
to query  53-59
adding in reports  15, 16
RDB-based report
data, handling  259
RDL  59, 284, 285
RDL contract validation  207
RDL data contract
versus RDP data  59, 60
RDP
about  41, 73, 78
debugging  99
existing temp table, using  100-103
multiple temporary table  220, 221
selecting, for report  79
testing  80
RDP class  78
RDP contract validation  207
RDP data
versus RDL data contract  59, 60
RDP data contract  78
RDP report
creating  74-77
financial dimension  232-240
rectangle control
about  186
in reports  186-190
rendering related issues
handling  254-258
report
about  5, 24
adding, to role center  191-194
aggregating  35, 36
auto e-mails, saving  260
AXEnumProvider, using in  276-278
barcodes, displaying  264-274
barcodes, generating  264-274
building, with company images  98, 99
building, with headers  98, 99
charts, adding  27
data region, adding  27
deploying  17, 18
designing  281, 282
document map navigation, adding  44, 45
drill down navigation, adding  45, 46
drill up navigation, adding  45, 46
expressions, implementing  33, 34
financial dimension  229
formatting  38
grouping  14, 15
improving  281, 282
inventory dimension  226-228
menu item, creating  19-22
opening, through controller  48, 49
preprocessing  104, 105
query, using as data source  6
ranges, adding  15-17
RDP, selecting for  79

297
saving, to file  260
security, setting up for  62, 63
sending, through e-mail  261
surrogate fields  208, 209
troubleshooting, in AX  252
unbounded parameters, adding  39, 40
upgrading, from previous version  196
URL drill through action, adding  68, 69
validation, implementing  205-207
report controller  51
report database  284
report data contract  51
Report data provider. See  RDP
Report Definition Extensions (RDE)  286
Report Definition Language. See  RDL
report design
adding, to print management  278-280
report dialog
controls, grouping  213, 219
controls, grouping in RDP-based 
reports  217-219
controls, grouping in report model  214, 215
controls, grouping in UI builder  215-217
controls, ordering  213, 219
turning off  62
report execution timeout  250
reporting architecture
about  284
report database  284
Report Manager  284
report server  284
reporting extensions, Dynamics AX
about  285
Data Processing Extensions (DPE)  286
Report Definition Extensions (RDE)  286
reporting project  288
reporting services configuration 
manager  291
Report Manager  284
report model
about  48, 288
classes, adding  65
dataset  289
debugging  65
designs  289
modifying  65
report performance
assessing  242-245
report programming model
about  50
controller  51
model  50
view  51
report query
modifying, in controller  52
report server  284
reports, troubleshooting
controller issues  259
data related issues  258
deployment related issues  253
rendering related issues  254-258
report UI builder  51
report upgradation, from previous version
AX 2009 datasets  199
AX 2012 datasets  199
controller, developing  200
datasource, defining  196
design, mapping  197-199
fields, mapping  196, 197
parameters, mapping  196, 197
UI events, handling  200
report usage
assessing  242-245
role centre
reports, adding to  191-194
S
security
setting up, for reports  62, 63
select option  20
sendTimeout property  248
SharePoint integrated mode
versus native mode  291
SQL Report Builder
used, for map subreport designing  145-154
used, for OLAP table report 
designing  136-144
working  144
SQL Server Reporting Services (SSRS)
about  73
need for  283
SSRS configuration
verifying  253

298
SSRS report
creating, steps  24, 25
SSRS report log viewer
URL, for downloading  242
subreport
creating, in auto design  154-157
creating, in precision design  157-160
surrogate fields
in reports  208, 209
surrogate keys , in query-based 
reports  209-212
surrogate keys , in RDP  210-212
Syncfusion® Metrostudio  36
system parameters  40
T
temp table
using, in RDP  100-103
U
UI
modifying, by caller  60, 61
unbounded parameters
about  41
adding, in reports  39, 40
unit testing business logic  70-72
URL drill through action
about  68
adding, in reports  68, 69
user-defined parameters
about  40
bounded parameters  40
unbounded parameters  41
user session timeout  251
V
validate method  206
validation
implementing, in reports  205-207
validation issue  255
W
WCF  104
X
XML feed
using, as datasource  112-114

Thank you for buying 
Microsoft Dynamics AX 2012 Reporting Cookbook
About Packt Publishing
Packt, pronounced 'packed', published its first book "Mastering phpMyAdmin for Effective MySQL 
Management" in April 2004 and subsequently continued to specialize in publishing highly focused 
books on specific technologies and solutions.  
Our books and publications share the experiences of your fellow IT professionals in adapting and 
customizing today's systems, applications, and frameworks. Our solution-based books give you the 
knowledge and power to customize the software and technologies you're using to get the job done. 
Packt books are more specific and less general than the IT books you have seen in the past. Our 
unique business model allows us to bring you more focused information, giving you more of what 
you need to know, and less of what you don't.
Packt is a modern, yet unique publishing company, which focuses on producing quality, 
cutting-edge books for communities of developers, administrators, and newbies alike. 
For more information, please visit our website: www.PacktPub.com.
About Packt Enterprise
In 2010, Packt launched two new brands, Packt Enterprise and Packt Open Source, in order 
to continue its focus on specialization. This book is part of the Packt Enterprise brand, home 
to books published on enterprise software – software created by major vendors, including (but 
not limited to) IBM, Microsoft and Oracle, often for use in other corporations. Its titles will offer 
information relevant to a range of users of this software, including administrators, developers, 
architects, and end users.
Writing for Packt
We welcome all inquiries from people who are interested in authoring. Book proposals should be 
sent to author@packtpub.com. If your book idea is still at an early stage and you would like to 
discuss it first before writing a formal book proposal, contact us; one of our commissioning editors 
will get in touch with you. 
We're not just looking for published authors; if you have strong technical skills but no writing 
experience, our experienced editors can help you develop a writing career, or simply get some 
additional reward for your expertise.

Implementing Microsoft 
Dynamics AX 2012 with 
Sure Step 2012
ISBN: 978-1-849687-04-1             Paperback: 234 pages
Get to grips with AX 2012 and learn a whole host of tips 
and tricks to ensure project success
1.	
Get the confidence to implement AX 2012 projects 
effectively using the Sure Step 2012 Methodology
2.	
Packed with practical real-world examples as 
well as helpful diagrams and images that make 
learning easier for you
3.	
Dive deep into AX 2012 to learn key technical 
concepts to implement and manage a project
Microsoft Dynamics AX 2012 
Services
ISBN: 978-1-849687-54-6            Paperback: 196 pages
Effectively use services with Dynamics AX 2012 and 
create your own services
1.	
Learn about the Dynamics AX 2012 service 
architecture
2.	
Create your own services using wizards or 
X++ code
3.	
Consume existing web services and services 
you’ve created yourself
Please check www.PacktPub.com for information on our titles

Developing SSRS Reports 
for Dynamics AX
ISBN: 978-1-782177-74-6             Paperback: 128 pages
A step-by-step guide to Microsoft Dynamics AX 2012 
report development using real-world scenarios
1.	
Build reports using AOT queries, report data 
provider classes, or an external data source
2.	
Learn how to deploy reports and manage 
SSRS reports in AOT, as well as customize 
standard reports
3.	
Discover best practices for Dynamics AX 2012 
reporting and learn common SSRS expressions, 
classes, and methods
Microsoft Dynamics GP 2013 
Financial Management
ISBN: 978-1-782171-30-0            Paperback: 110 pages
Unleash the power of financial management 
with tips, techniques, and solutions for Microsoft 
Dynamics GP 2013
1.	
Discover how to improve financial management 
in Microsoft Dynamics GP 2013
2.	
Learn the key financial management modules 
in Microsoft Dynamics GP 2013
3.	
Improve your abilities with Microsoft Dynamics 
GP 2013 to gain a better understanding and 
control of your business

Please check www.PacktPub.com for information on our titles

