

Go
Lang in Depth
Guide to program
microservices, networking,
database and APIs using Go
Lang
Bhagvan Kommadi

www.bpbonline.com

First Edition 2025
Copyright © BPB Publications, India
ISBN: 978-93-65894-806
All Rights Reserved. No part of this publication may be reproduced, distributed
or transmitted in any form or by any means or stored in a database or retrieval
system, without the prior written permission of the publisher with the exception
to the program listings which may be entered, stored and executed in a
computer system, but they can not be reproduced by the means of publication,
photocopy, recording, or by any electronic and mechanical means.
LIMITS OF LIABILITY AND DISCLAIMER OF WARRANTY
The information contained in this book is true to correct and the best of author’s
and publisher’s knowledge. The author has made every effort to ensure the
accuracy of these publications, but publisher cannot be held responsible for any
loss or damage arising from any information in this book.
All trademarks referred to in the book are acknowledged as properties of their
respective owners but BPB Publications cannot guarantee the accuracy of this
information.
www.bpbonline.com

Dedicated to
My dad who passed away during this book
writing and
My mom my strength and support system

About the Author
Bhagvan Kommadi has around 21 years of experience and
is currently working as a chief information officer. He is
responsible for creating and managing the company's IT
strategy, operations, and resources. He is responsible for
the alignment of the company’s goals and objectives with IT
strategy and operations. He ensures that the IT performance
operates at high productivity and delivers high business
value to the customers and employees. He establishes
policies and the best practices in the company, using the
right IT governance to meet compliance requirements. He is
responsible for ensuring IT infrastructure’s data quality,
integrity, and security standards.
He has a Master’s in Industrial Systems Engineering from
the Georgia Institute of Technology (1997) and a Bachelor’s
in Aerospace Engineering from the Indian Institute of
Technology, Madras (1993). He is an individual member of
Oracle JCP. He has published papers on IEEE, JIMR, Johr
Online, and the Association of Data Scientists (ADaSci)
on the latest technologies. He is a TEDx Speaker and has
presented at EuroPython, Pycon, ClueCon Weekly, World RPA
Conference, and Avios conferences. He has written Packt
Publishing - Hands-On Data Structures and Algorithms with
Go and Paytech book on The Payment Technology Handbook
for Investors, Entrepreneurs, and FinTech Visionaries He has
worked extensively in FinTech Space in various verticals
such as banking, financial services, and insurance.

Bhagvan has worked for Fortune 500 companies, including
JPMC, Fidelity, Oracle, Siebel, Citi, American Express, ING,
ENBD, Pacific Corp, and Kaiser Permanente. He has provided
technology and business process reengineering consulting
guidance and implemented various new-generation
platforms for business enablement.
Bhagvan founded Quantica Computacao, the first quantum
computing startup in India. Markets and Markets has
positioned Quantica Computacao in the ‘Emerging
Companies’ section of Quantum Computing quadrants. The
company's focus is on developing quantum cryptographic
tools that will be able to provide quantum-proof data
security, which will help banking institutions protect their
transactions.
He contributes to open-source projects, blogs, and the latest
technology stacks such as Go, Python, Django, Node.js and
Java, Mysql, Postgres, Mongo, and Cassandra. He has
reviewed the Manning book Machine Learning with
TensorFlow. He has written Data Structures and Algorithms
with Golang (Packt) and Quantum Computing Solutions
(Apress). He has presented at IEEE, Avios, Astricon, Devcon,
and PyCon on topics such as Adaptive Learning and AI
Coder.

About the Reviewer
Mahima Singla is a passionate Principal Software Design
Engineer with extensive professional experience and
passion for designing and implementing robust, scalable
software solutions in the domain of Cloud Assessment,
Cloud Governance, Cloud Cost Optimization, Application
fitment for cloud, Cloud Operating Models, cutting-edge
technologies, particularly in the realms of Cloud computing,
AWS, and Kubernetes in Go language.
She is currently working in Precisely Software and is part of
the Studio Administrator Cloud project and Customer
Onboarding project. She has played a pivotal role in
architecting and developing solutions that harness the full
potential of cloud platforms. She has proficiency in AWS,
including services like AWS services EC2, S3, and Lambda,
has allowed her to create resilient and scalable applications
that align with business objectives.
Additionally, proficiency in Kubernetes reflects the
commitment to staying at the forefront of container
orchestration. She has successfully implemented and
managed containerized workloads, ensuring efficiently
managed containerized workloads, efficient resource
utilization, and high availability for applications.
Throughout her career, she has not only focused on
technical excellence but also on driving innovation and
fostering collaborative environments. As a Principal Software
Engineer, she takes pride in leading teams to deliver high-
quality solutions that meet and exceed client expectations.

She is dedicated to staying abreast of industry trends and
leveraging the latest technologies has allowed her to
contribute meaningfully to the success of the projects she
undertakes. She is quite excited about the continuous
evolution of software engineering and is always eager to
take on new challenges that push the boundaries of what is
possible in the world of cloud-native development.

Acknowledgement
Embarking on the journey of writing Go Lang in Depth has
been wonderful, and I am deeply grateful to the BPB team,
who have played a crucial role in bringing this book to
fruition. This endeavor would not have been possible
without the unwavering support, guidance, and expertise
generously provided by my parents and kids.
To my parents and kids, thank you for your unwavering
support. In the middle of this book journey, my father
passed away. I dedicate this book to his support and
guidance during this book journey. I want to express deep
appreciation to my mom, whose encouragement and
understanding have been a constant source of strength
throughout this writing journey. Firstly, my heartfelt thanks
go to the Go Lang community, whose dedication to the
framework has shaped this book. Special gratitude is
extended to the technical reviewers whose meticulous
reviews and insightful feedback enhanced the book. Their
dedication and expertise have been invaluable in refining
the content and ensuring its accuracy.
To all those at the BPB Publications house who have
contributed in various capacities, your collective efforts
have enriched this endeavor. I appreciate the collaborative
spirit that has fueled the creation of Go Lang in Depth.
Finally, to the readers, thank you for choosing this book as
your source of knowledge. May it be a valuable companion
on your journey to learning Go Lang in Depth.

Preface
Understanding the basics of digital systems and technology
is important in today's rapidly evolving world. This book, Go
Lang in Depth, covers the essential concepts that form the
backbone of digital systems.
In the fast-evolving landscape of Go Lang development,
understanding the development of apps using Go Lang is
very important for aspiring developers. There are many
open-source, popular frameworks in Go Lang. New open-
source frameworks have embraced Go Lang as the language
for their tech stack.
This book comprises 17 chapters, each a complete module
in itself, serving as your comprehensive guide to learning Go
Lang in Depth. It covers a wide array of topics, ranging from
the fundamentals to advanced techniques. Whether you're a
seasoned developer looking to expand your skills or a
newcomer eager to dive into Go Lang development, this
book has something for everyone.
Through practical examples, comprehensive explanations,
and a structured approach, this book aims to equip readers
with a solid understanding of Go Lang programming and
software engineering. Whether you are a novice or an
experienced learner, I hope this book will serve as a
valuable resource in your journey of exploring the
foundations of digital systems and technology.
Chapter 1: Go Fundamentals - In this chapter, readers
will be presented with fundamentals in Go language. The

topics like data types, variables, constants, operators, and
Go programming will be discussed.
Chapter 2: Advanced Features of Go - In this chapter,
readers will be presented with advanced features like error
handling, interfaces, typecasting, concurrency, and Mutex.
These topics will be discussed with coding examples.
Chapter 3: Go Console Applications - In this chapter,
readers will be presented with techniques to build console-
based applications. Applications will have the capability to
read input and write output. The input and the output can
be of different formats like CSV, properties, XML, and JSON.
Console applications can talk to a database, and these apps
will be built in Go. Data structures in Go will be discussed.
Chapter 4: Building Rest API - In this chapter, readers
will learn about different algorithms which can be
implemented in Go. They will also know how to develop
REST API to access data from different data sources. The
REST API can read and write data to data sources like
relational databases, no sql databases, and message
queues. REST API clients can be web applications and
mobile applications
Chapter 5: Go Web Apps - In this chapter, readers will be
presented with examples and solutions to build web
applications using Gin and Beego. Web applications will
consume REST API and communicate to databases through
the API. These web applications will be built to be scalable
and performable.
Chapter 6: RPC Apps with gRPC - In this chapter, the
reader can build RPC apps using Go. These apps are built
using Google gRPC. Readers will know about Protocol
Buffers. gRPC clients will be developed to talk to the gRPC
server. Unit tests will be written to test the clients and
server code.

Chapter 7: Go Real Life Applications - CRM- In this
chapter, readers will learn how to build a real-life application
of customer relationship management. CRM application will
be a web application that will have the capability to
maintain customer data and run campaigns for segments or
a list of customers by geography or vertical.
Chapter 8: Go Concurrent Apps- In this chapter, readers
will learn how to build concurrent applications using Go.
Readers will know how to use goroutines, channels, and
concurrency using Go. The reader will understand the
principles of concurrency and parallelism.
Chapter 9: Go Dependency Injection and SOLID - In
this Chapter, the Reader will understand dependency
injection using the Go Language. The reader will also
understand SOLID principles, which include dependency
inversion. The reader will also learn different types of
dependency injection, such as constructor, property, and
method.
Chapter 10: Containerization and Docker - In this
chapter, the reader will understand containers and Docker.
The reader will be able to develop services that can be
containerized using Docker. Docker images can be created
and posted on the Docker Hub for different Go services.
Chapter 11: Go Microservices - In this chapter, the
reader will understand the principles of microservices
architecture vs. monolithic architecture. The reader will be
able to create an architecture using Microservices and
deploy these services on the containers.
Chapter 12: Adding Security and IAM - In this chapter,
readers will learn how to build security services like
authentication, authorization, encryption, and identity
management. Readers will learn about Cross-Site Request
Forgery (CSRF) prevention middleware. Readers can

understand the security principles to build scalable and
secure web applications.
Chapter 13: Go Design Patterns–Part 1 - In this chapter,
readers can understand different design patterns like
Creational and Structural Design patterns. Code samples will
be provided for the Gang of Four Design patterns. Readers
will understand object-oriented design principles using Go
Chapter 14: Go Design Patterns–Part 2 - In this chapter,
readers can understand different design patterns, like
Behavioral Design patterns. And Object-oriented Design
Patterns. Code samples will be provided for the Gang of Four
Design patterns and Object-oriented Design Patterns.
Readers will understand object-oriented design principles
using Go.
Chapter 15: Go Performance Tuning Patterns - In this
chapter, the reader will learn how to develop responsive and
performant Go applications. Different performance tuning
and optimization patterns are presented with code samples,
and the reader will understand these techniques while
building web applications.
Chapter 16: Web Web App Blueprints - In this chapter,
readers will be presented with web app blueprint
applications. Readers will understand the design and
architecture principles to build scalable web applications.
The blueprint solutions will have tips and techniques to build
responsive web applications that are performant.
Chapter 17: Go Mobile Applications Blueprints - In this
chapter, readers will be presented with mobile app blueprint
applications. Readers will understand the design and
architecture principles to build scalable mobile applications.
The blueprint solutions will have tips and techniques for
building performant mobile applications.

Code Bundle and Coloured
Images
Please follow the link to download the
Code Bundle and the Coloured Images of the book:
https://rebrand.ly/220b81
The code bundle for the book is also hosted on GitHub at
https://github.com/bpbpublications/Go-Lang-in-
Depth. In case there’s an update to the code, it will be
updated on the existing GitHub repository.
We have code bundles from our rich catalogue of books and
videos available at https://github.com/bpbpublications.
Check them out!
Errata
We take immense pride in our work at BPB Publications and
follow best practices to ensure the accuracy of our content
to provide with an indulging reading experience to our
subscribers. Our readers are our mirrors, and we use their
inputs to reflect and improve upon human errors, if any, that
may have occurred during the publishing processes
involved. To let us maintain the quality and help us reach
out to any readers who might be having difficulties due to
any unforeseen errors, please write to us at :
errata@bpbonline.com
Your support, suggestions and feedbacks are highly
appreciated by the BPB Publications’ Family.

Did you know that BPB offers eBook versions of every book published, with
PDF and ePub files available? You can upgrade to the eBook version at
www.bpbonline.com and as a print book customer, you are entitled to a
discount on the eBook copy. Get in touch with us at :
business@bpbonline.com for more details.
At www.bpbonline.com, you can also read a collection of free technical
articles, sign up for a range of free newsletters, and receive exclusive
discounts and offers on BPB books and eBooks.
Piracy
If you come across any illegal copies of our works in any form on the internet,
we would be grateful if you would provide us with the location address or
website name. Please contact us at business@bpbonline.com with a link to
the material.
If you are interested in becoming an author
If there is a topic that you have expertise in, and you are interested in either
writing or contributing to a book, please visit www.bpbonline.com. We have
worked with thousands of developers and tech professionals, just like you, to
help them share their insights with the global tech community. You can make
a general application, apply for a specific hot topic that we are recruiting an
author for, or submit your own idea.
Reviews
Please leave a review. Once you have read and used this book, why not leave
a review on the site that you purchased it from? Potential readers can then
see and use your unbiased opinion to make purchase decisions. We at BPB
can understand what you think about our products, and our authors can see
your feedback on their book. Thank you!
For more information about BPB, please visit www.bpbonline.com.
Join our book’s Discord space
Join the book’s Discord Workspace for Latest updates,
Offers, Tech happenings around the world, New Release and
Sessions with the Authors:
https://discord.bpbonline.com


Table of Contents
1. Go Fundamentals
Introduction
Structure
Objectives
Basic programming in Go
Data types
Basic types
Composite types
Reference types
Interface types
Variables
Constants
Operators
Conditional statements
if condition statement
Switch statement
Strings and arrays
Strings
Arrays
Maps
Pointers and structures
Pointers
Structures

Recover, defer, and panic
Conclusion
Points to remember
2. Advanced Features of Go
Introduction
Structure
Objectives
Error handling
Interfaces
Empty interface
Type assertion
Type switch
Zero value of interface
Type casting
Concurrency
Mutex
Conclusion
Points to remember
3. Go Console Applications
Introduction
Structure
Objectives
Console-based app in Go language
Different input and output formats
Text format
JSON
XML

Database interaction
Data structures
Conclusion
Points to remember
4. Building REST API
Introduction
Structure
Objectives
Algorithms
Bubble sort
REST API in Go
REST API interacting with relational database
REST API interacting with No SQL database
REST API interacting with message queues
Go best practices
Conclusion
Points to remember
5. Go Web Apps
Introduction
Structure
Objectives
Developing web app in Go
Getting database connection
Retrieving employee from the given database Id
Retrieving all employees from the database
Adding employee to the database
Updating the employee in the database

Deleting the employee from the database
Developing web app using Gin and REST API
Developing Web App using Beego
Conclusion
Points to remember
6. RPC Apps with gRPC
Introduction
Structure
Objectives
RPC apps in Go Lang
Protocol buffers
gRPC clients
gRPC server
Conclusion
Points to remember
7. Go Real Life Applications—CRM
Introduction
Structure
Objectives
CRM application in Go
REST API
Unit testing the REST API
Web app
Conclusion
8. Go Concurrent Apps
Introduction

Structure
Objectives
Concurrency and parallelism principles
Goroutines
Channels
Channel types
Channel patterns
Concurrent apps in Go
Conclusion
9. Go Dependency Injection and SOLID
Introduction
Structure
Objectives
SOLID principles
Single responsibility principle
Open/Closed principle
Liskov Substitution Principle
Interface Segregation principle
Dependency Inversion Principle
Dependency injection
Dependency injection types
Creating structs and interfaces
Manual dependency injection
Constructor injection
Setter/method injection
Dependency injection frameworks
Google’s Wire
Facebook’s inject

Uber’s dig
Dingo
Choosing the right framework suitable for you
Conclusion
10. Containerization and Docker
Introduction
Structure
Objectives
Containers
Docker
Docker Registry
Docker Compose
Docker networks
Go Services
Dockerized Go Services
Conclusion
11. Go Microservices
Introduction
Structure
Objectives
Monolithic architecture
Microservices architecture
Microservices in Go
Containerized Go microservices
Conclusion
12. Adding Security and IAM

Introduction
Structure
Objectives
Basic security services
Advanced security services
Security principles
Securable web applications
Public key infrastructure
SSL/TLS certificates
Code signing
Application code signing
SSH keys
Trust exchange
Real-life examples
Securing REST API
Unit testing the REST API
Create Customer
Get Customers
Update Customer
Delete Customer
Get Customers after Delete
Conclusion
13. Go Design Patterns—Part 1
Introduction
Structure
Objectives
Creational design patterns
Abstract factory pattern

Builder pattern
Factory method pattern
Prototype pattern
Singleton pattern
Structural design patterns
Adapter pattern
Bridge pattern
Composite pattern
Decorator pattern
Façade pattern
Conclusion
14. Go Design Patterns—Part 2
Introduction
Structure
Objectives
Behavioral design patterns
Chain of responsibility pattern
Command pattern
Interpreter pattern
Iterator pattern
Mediator pattern
Memento pattern
Observer pattern
State pattern
Strategy pattern
Template method pattern
Visitor pattern
Object-oriented design patterns
GRASP patterns

Conclusion
15. Go Performance Tuning Patterns
Introduction
Structure
Objectives
Go apps performance tuning
Go apps code profiling
Go web apps challenges
Recursion
Dynamic memory allocation
HTTP request and response
Other challenges
Go web apps performance tuning
Go performance patterns
Concurrency handling
CPU intensive tasks
Web traffic handling
Go scalability patterns
Conclusion
16. Go Web App Blueprints
Introduction
Structure
Objectives
Web app in Go recipes
Building scalable and responsive web app
Tools and techniques
Go Lang web app challenges

Web app design principles
Web app architecture principles
Conclusion
17. Go Mobile Applications Blueprints
Introduction
Structure
Objectives
Challenges in building mobile apps
Go Lang for mobile apps
Mobile app in Go recipes
Building scalable and responsive mobile app
Mobile app design principles
Mobile app architecture principles
Clean architecture
Hexagonal architecture
Conclusion
Index

CHAPTER 1
Go Fundamentals
Introduction
In this chapter, readers will be presented with fundamentals
in the Go language. The topics like data types, variables,
constants, operators, and Go programming will be discussed.
Each topic will have code samples and details about how to
use the Go language constructs.
Structure
The chapter covers the following topics:
Basic programming in Go
Data types
Variables
Constants
Operators
Conditional statements
Strings and arrays
Maps

Pointers and structures
Recover, defer, and panic
Objectives
By the end of this chapter, you will be able to understand
how to use basic programming constructs in Go language.
You can look at the examples and learn how to use different
data types, structures, variables, constants, operators,
pointers, strings, and maps in which scenario.
Basic programming in Go
Go language was created by Google in 2007. It was created
by Robert Griesemer, Rob Pike, and Ken Thompson. Go Lang
syntax looks like C language syntax. Go language has
features related to type safety, dynamic types like
constructs, garbage collection, and advanced data types.
This language has a library that has API to develop complex
applications. Developers can create software that can run on
multi-core and networked computers. Concurrency can be
handled very simply in the Go language. Concurrency can be
handled very simply in the Go language using channels and
goroutines.
When you compile the code in Go, machine code is
generated. Yet, it has features like run time reflection and
garbage collection. Go language has static types that can be
compiled. Many think that it has dynamic types and is an
interpreted language.
You can start creating a Go language-based file with a .go
extension. Different text editors support the Go language.
Let us start with the first program in Go Lang:
package main
import "fmt"

func main() {
fmt.Println("My first program in Go Lang")
}
To compile and run the Go language program, you can
download it from https://go.dev/dl/. Based on the operating
system you are using, you can download the appropriate
executable. The Go Lang compilation process is shown in the
following figure:
Figure 1.1: Go Lang compilation process
Go Lang compiler, which is downloaded based on the
operating system, creates the machine code that is
executed. To compile and execute the code, the following
commands are used.
You can verify the installation by running the following
command:
go version
The output will be based on the version that you install. It
will be as below:
bhagvanarch@Bhagvans-MacBook-Air code % go version
go version go1.22.1 darwin/arm64

bhagvanarch@Bhagvans-MacBook-Air code %
After verifying the installation, you can compile and run the
first_program.go. The command is shown as follows:
go run first_program.go
The output will be as follows:
(base) apples-MacBook-Air:code bhagvan.kommadi$ go 
run first_program.go 
My first program in Go Lang
(base) apples-MacBook-Air:code bhagvan.kommadi$
You can refer to the Go user manual available online
(https://go.dev/doc/). It will be visible as shown in the
following figure:
Figure 1.2: Go language user manual
You can check the tools used by the Go Lang developers at:

https://pkg.go.dev/golang.org/x/tools. These tools help
in formatting the code, auto-completion while developing,
documentation of the code, debugging, refactoring, securing
the IP, and gathering metrics coverage related to unit
testing.
Some of these tools are shown in the following figure:
Figure 1.3: Go Lang tools
Java and Python have similar equivalents in their toolkit. Java
Doc, Sonar Cube, Checkstyle, Junit5, Mockito, PMD,
SpotBugs, and others are equivalent tools in the Java toolkit.
Data types

In Go language, data types are categorized as below:
Basic types
Composite types
Reference types
Interface types
Basic types
In the Go language, the basic types are numbers, strings,
and Boolean types:
The number data type can be divided into three
different data types:
Integers
Floating point
Complex
String type has Unicode characters in sequence.
Boolean types are true or false types.
Let us start by looking at how data types are used in Go
Lang:
package main
import "fmt"
type numVar int
type strVar string
type boolVar bool
func main() {
var intVar numVar = 98
var phraseVar strVar = "checking string"
var falseVar boolVar = false

fmt.Printf("%v\n", intVar)
fmt.Printf("%T\n", intVar)
fmt.Printf("%v\n", phraseVar)
fmt.Printf("%T\n", phraseVar)
fmt.Printf("%v\n", falseVar)
fmt.Printf("%T\n", falseVar)
}
First, you need to save the above code in data_types.go
file. You can now compile and run the data_types.go. The
command is shown as follows:
go run data_types.go
The output will be as shown as follows:
(base) apples-MacBook-Air:code bhagvan.kommadi$ go 
run data_types.go 
98
main.numVar
checking string
main.strVar
false
main.boolVar
(base) apples-MacBook-Air:code bhagvan.kommadi$
The output shows the format of different types printed in
verbose (%v) and type (%T) formats.
Note: Go language is statically typed. Static Type variable is defined
only once and the data is stored in the variable of a specific type. There
are other languages like Java, Haskell, C, C++, C#, and Scala that are
statically typed.

Composite types
Now, let us look at the composite types in the Go language.
Arrays and structs are composite types. Arrays consist of the
same typed variables, while structs have different typed
variables. Arrays are groups of the same type of elements in
sequence.
Let us look at how Arrays are used in Go Lang:
package main
import "fmt"
func main() {
var arr [4]string
arr[0] = "My"
arr[1] = "Name"
arr[2] = "Is"
arr[3] = "Tom"
fmt.Println(arr[0], arr[1], arr[2])
fmt.Println(arr[3])
fibonacci_numbers := [10]int{0, 1, 1, 2, 3, 
5, 8, 13, 21, 34}    //marker1  
fmt.Println(fibonacci_numbers)
}
marker1 -> An array of integers, which are Fibonacci
numbers, are defined.
First, you need to save the above code in array_type.go.
You can now compile and run the array_type.go. The
command is shown as follows:

go run array_type.go
The output will be as follows:
Figure 1.4: ArrayType example execution output
In the above example, an array of string type and integer
types are declared and initialized. Now let us look at Slices
that can expand in size or pick a subset of elements in an
array:
package main
import "fmt"
func main() {
fibonacci_numbers := [10]int{0, 1, 1, 2, 3, 
5, 8, 13, 21, 34}
fmt.Println(fibonacci_numbers)
var subset_fib []int
subset_fib = fibonacci_numbers[2:6]
fmt.Println(subset_fib)
}
First, you need to save the above code in slice_type.go.
You can now compile and run the slice_type.go. The
command is as follows:

Figure 1.5: Slice_Type example execution output
The output shows the slice defined without a specified size
and initialized to a subset of an array. An array has a
specified size. A slice can be dynamic and handle different
types. A slice is represented as []T, where T is a type.
Reference types
In the Go language, there are container types that can be
used to have data groups or sets. The first-class citizens are
slice, array, and map. Pointers and channels are second-class
citizens. Containers hold the values of the elements which
belong to the same types. In a map, the element will have a
key and a value. Maps need less memory compared to slices
and arrays. The array, slice, and map are represented as
[X]Y, []Y, and map[Z]Y notations, respectively. In the
notation, X is a non-negative integer, which is the count of
the elements in the container, and Y is the arbitrary type,
which is the type of the element in the container. Z is
another arbitrary type, which is the type of the key in the
map. A channel is used as a container of element values for
the execution of the go routines. Pointers represent the
memory address of the element value.
Container types like slice, map, channel, pointers, and
function types are reference types. Reference type stands for
a value type, which is a pointer. Map and channel types use
pointers to represent the internal structure. Slice is a
composite type—Struct. It has length and capacity, which
are integer types and pointers to the elements. Functions
and methods are pointers that stand for functions and
methods.

Now, let us look at slices and how references can be used for
slices:
package main
import (
        "fmt"
        "reflect"
)
func changeSlice(slice []int) {
        reflect.ValueOf(&slice).Elem().SetLen(5)
        reflect.ValueOf(&slice).Elem().SetCap(5)
        fmt.Println("slice3>", len(slice), 
cap(slice))
}
func main() {
        slice := make([]int, 2, 8)
        fmt.Println("slice1>", len(slice), 
cap(slice))
        changeSlice(slice)
        fmt.Println("slice2>", len(slice), 
cap(slice))
}
First, you need to save the above code in the
reference_types.go file. Now you can now compile and run
the reference_types.go. The command is shown as follows:
go run reference_types.go
The output will be as follows:

Figure 1.6: Reference_Types example execution output
The output shows how the references help in referencing
other values when passed as a pointer. This applies to map,
pointer, channel, and interface types.
Interface types
In the Go language, the interface is an abstract type that
consists of method signatures. You cannot have instances of
the interface. You can create an interface with the type
(keyword) interface name interface (keyword). More than
one interface can be implemented by a data type.
Now, let us look at an example of interfaces:
package main
import "fmt"
type vehicle interface {
getSpeed() float64
getDistanceTravelled() float64
}
type car struct {
brand              string
manufacturing_year int
}
func (Car car) getSpeed() float64 {
return 120

}
func (Car car) getDistanceTravelled() float64 {
return 4000
}
func main() {
var veh vehicle
veh = car{"Toyota Tercel", 1997}
fmt.Println("Speed of the Vehicle :", 
veh.getSpeed())
fmt.Println("Distance Travelled by the 
Vehicle:", veh.getDistanceTravelled())
}
First, you need to save the above code in
instance_type.go. You can now compile and run the
instance_type.go. The command is shown as follows:
Figure 1.7: Interface_Type example execution output
The output shows how the interface abstracts out the
method implementation. All methods need to be
implemented by the struct. Vehicle is an interface, and the
car is a structure. When a car is instantiated, it returns a
vehicle.
Variables

In the Go language, variables can be instantiated with an
initializer. An initializer can be an expression that is
evaluated at execution time. It can be declared in a method,
for loop, or a class. The variable scope can be local if it is
declared inside a method or a code block. The scope will be
global when it is declared outside a method or a code block.
Now let us look at an example of interfaces:
package main
import "fmt"
func main() {
var var1 int = 55
var var2 float32 = 4.5
fmt.Printf("var1 value is : %d\n",
var1)
fmt.Printf("var2 value is : %f\n",
var2)
}
First, you need to save the above code in a variable.go file.
You can now compile and run the variable.go. The
command is shown as follows:
Figure 1.8: Variable example execution output
The output shows how the variables of different types, like
integer and float, are declared and instantiated.

Constants
In the Go language, constants are defined and initialized
once. The value cannot be changed after that. Constant
types can be integer, float, character, and string type.
Now, let us look at an example for interfaces:
package main
import "fmt"
const JVAL = 5.87
func main() {
const PRO = "Bike has wheels"
fmt.Println("Cycle", PRO)
fmt.Println("JValue is", JVAL)
const RIGHT = true
fmt.Println("Checking Boolean", RIGHT)
}
First, you need to save the above code in constant.go file.
You can now compile and run the constant.go. The
command is as follows:
go run constant.go
The output will be as follows:
Figure 1.9: Constant example execution output

The output shows how constants are declared for different
types like float, string, and Boolean.
Operators
In Go language, operators are arithmetic, relational, logical,
bitwise, assignment, and miscellaneous:
Arithmetic 
operators 
are 
related 
to 
addition,
subtraction, multiplication, division, and Modulus
mathematical operations.
Relational operators are equal to, not equal to, greater
than, less than, greater than equal to, and less than
equal to comparisons.
Logical operators are AND, OR, and NOT operations.
Bitwise operators are bitwise AND, bitwise OR, bitwise
XOR, left shift, right shift, and AND NOT operators.
Assignment operators are simple assignment, add
assignment, subtract assignment, multiply assignment,
division assignment, modulus assignment, Bitwise AND
assignment, Bitwise Exclusive OR, Bitwise inclusive
OR, Left shift AND assignment operator, and Right
shift AND assignment.
Now, let us look at an example for each of the above
operators.
package main
import "fmt"
func main() {
var1 := 46
var2 := 87
//Arithmetic Operators
// Addition Operator

output1 := var1 + var2
fmt.Printf("Result of var1 + var2 = %d", 
output1)
// Subtraction Operator
output2 := var1 - var2
fmt.Printf("\nResult of var1 - var2 = %d", 
output2)
// Multiplication Operator
output3 := var1 * var2
fmt.Printf("\nResult of var1 * var2 = %d", 
output3)
// Division Operator
output4 := var1 / var2
fmt.Printf("\nResult of var1 / var2 = %d", 
output4)
// Modulus Operator
output5 := var1 % var2
fmt.Printf("\nResult of var1 %% var2 = %d", 
output5)
//Relational Operators
// ‘=='(Equal To Operator)
output11 := var1 == var2
fmt.Println(output11)
// ‘!='(Not Equal To Operator)
output12 := var1 != var2
fmt.Println(output12)
// ‘<‘(Less Than Operator)

output13 := var1 < var2
fmt.Println(output13)
// ‘>'(Greater Than Operator)
output14 := var1 > var2
fmt.Println(output14)
// ‘>='(Greater Than Equal To Operator)
output15 := var1 >= var2
fmt.Println(output15)
// ‘<='(Less Than Equal To Operator)
output16 := var1 <= var2
fmt.Println(output16)
//Logical Operators
if var1 != var2 && var1 <= var2 {
fmt.Println("True")
}
if var1 != var2 || var1 <= var2 {
fmt.Println("True")
}
if !(var1 == var2) {
fmt.Println("True")
}
//Bitwise Operators
// & (bitwise AND Operator)
output21 := var1 & var2
fmt.Printf("Result of var1 & var2 = %d", 
output21)

// | (bitwise OR Operator)
output22 := var1 | var2
fmt.Printf("\nResult of var1 | var2 = %d", 
output22)
// ^ (bitwise XOR Operator)
output23 := var1 ^ var2
fmt.Printf("\nResult of var1 ^ var2 = %d", 
output23)
// << (left shift Operator)
output24 := var1 << 1
fmt.Printf("\nResult of var1 << 1 = %d", 
output24)
// >> (right shift Operator)
output25 := var1 >> 1
fmt.Printf("\nResult of var1 >> 1 = %d", 
output25)
// &^ (AND NOT Operator)
output26 := var1 &^ var2
fmt.Printf("\nResult of var1 &^ var2 = %d", 
output26)
//Assignment Operators
// “="(Simple Assignment Operator)
var1 = var2
fmt.Println(var1)
// “+="(Add Assignment Operator)
var1 += var2
fmt.Println(var1)

//“-="(Subtract Assignment Operator)
var1 -= var2
fmt.Println(var1)
// “*="(Multiply Assignment Operator)
var1 *= var2
fmt.Println(var1)
// “/="(Division Assignment Operator)
var1 /= var2
fmt.Println(var1)
// “%="(Modulus Assignment Operator)
var1 %= var2
fmt.Println(var1)
}
First, you need to save the above code in operators.go file.
You can now compile and run the operators.go. The
command is as follows:
    go run operators.go
The output will be as follows:

Figure 1.10: Operators example execution output
The output shows how operators are used in Go Lang related
to arithmetic, relational, assignment, bitwise, and bitwise
assignment operations.
Conditional statements
In Go language, control flow is managed by conditional
statements like If, If..else, If…else if…else, and switch…case
statements. Let us look at the If statement first.
if condition statement

if statement
The if statement has a code section invoked based on a
condition. The syntax is if condition { }.
Now, let us look at an example of an if statement:
package main
import (
"fmt"
)
func main() {
var str = "Adobe"
boolA := true
if boolA {
fmt.Println(str)
}
}
First, you need to save the above code in if_statement.go.
You can now compile and run the if_statement.go. The
command is as follows:
    go run if_statement.go
The output will be as follows:
(base) apples-MacBook-Air:code bhagvan.kommadi$ go 
run if_example.go 
Adobe
(base) apples-MacBook-Air:code bhagvan.kommadi$
The output shows the code section, which prints Adobe if the
condition is that boolA is true.
if .. else statement

The if… else statement has code sections that are invoked
based on true and false conditions. The syntax is if
condition { } else {}.
Now, let us look at an example for the if..else statement.
package main
import (
"fmt"
)
func main() {
var str = "Adobe"
var defaultStr = "Google"
boolA := false
if boolA {
fmt.Println(str)
} else {
fmt.Println(defaultStr)
}
}
First, you need to save the above code in
if_else_statement.go file. You can now compile and run
the if_else_statement.go. The command is shown as
follows:
    go run if_else_statement.go
The output will be as follows:

Figure 1.11: If…Else example, execution output
The output shows the code section, which prints Google if
the condition is that boolA is false.
if .. else if ..else statement
If… else if .. else statement has multiple code sections which
are invoked based on true conditions and one for false
conditions. The syntax is if condition { } else if {}
else if {}…else {}.
Now let us look at an example for if..else if..else statement:
package main
import (
"fmt"
)
func main() {
var str = "Adobe"
var str1 = "Twitter"
var str2 = "Amazon"
var defaultStr = "Google"
boolA := false
boolB := true
boolC := true
if boolA {
fmt.Println(str)
} else if boolB {
fmt.Println(str1)
} else if boolC {
fmt.Println(str2)

} else {
fmt.Println(defaultStr)
}
}
First, you need to save the above code in
if_else_if_elese_example.go. You can now compile and
run the if_else_if_else_example.go. The command is
shown as follows:
    go run if_else_example.go
The output will be as follows:
Figure 1.12: Variable example execution output
The output shows how the code section which prints Twitter
as the first if else condition code section gets invoked.
Switch statement
The switch statement has multiple code sections in which
one of them is invoked. The syntax is switch variable {
case values: … case:value… default: }.
Now, let us look at an example of a switch statement:
package main
import (
"fmt"
"time"
)
func main() {

timeNow := time.Now()
var day int = timeNow.Day()
switch day {
case 6, 11, 17:
fmt.Println("Buy Groceries")
case 5, 16, 27:
fmt.Println("Play Golf")
case 3:
fmt.Println("Go to Church")
default:
fmt.Println("Read a magazine")
}
}
First, you need to save the above code in the
switch_example.go file. You can now compile and run the
switch_example.go. The command is shown as follows:
    go run switch_example.go
The output will be as follows:
Figure 1.13: Switch example execution output
The output shows how the code section that prints the Buy
Groceries since the day the code was executed is 6th.
Strings and arrays

In this section, we will look at strings and arrays in the Go
language. Let us first look at strings.
Strings
In the Go language, the string is a set of different-width
characters. A string has characters that represent a single or
multiple bytes. Strings are encoded by UTF-8 type. The string
is a slice of bytes that can be read by the user. A string is
defined using double quotes “".
Now let us look at an example for strings:
package main
import "fmt"
func main() {
hello_string := "Hello World"
var string_var string
string_var = "initialized later"
fmt.Println("intiallizedString: ", 
hello_string)
fmt.Println("declared and initialized 
later: ", string_var)
var strings [5]string
strings[0] = "George"
strings[1] = "John"
strings[2] = "Tom"
strings[3] = "Vivan"
strings[4] = "Marlin"
fmt.Println("array of strings: ", strings)
}

First, you need to save the above code in the
strings_example.go file. You can now compile and run the
strings_example.go. The command is shown as follows:
    go run strings_example.go
The output will be as follows:
Figure 1.14: Strings example execution output
The output shows how strings are initialized, declared, and
the creation of the string arrays.
Arrays
We discussed array types early in the chapter. Now, let us
take a deep dive. In the Go language, the array is a set
consisting of similar elements that can be stored in the
memory. Slices have the flexibility of having the capability of
expanding. Arrays start from index 0, and the last element’s
index will be n-1, where n is the number of elements.
Now, let us look at an example of arrays:
package main
import "fmt"
func main() {
string_array := [5]string{"Tom", "George", 
"John", "Jim", "Bill"}
fmt.Println("Elements of string array:")
for i := 0; i < 4; i++ {

fmt.Println(string_array[i])
}
}
First, you need to save the above code in the
array_example.go file. You can now compile and run the
array_example.go. The command is shown as follows:
    go run array_example.go
The output will be as follows:
Figure 1.15: Array example execution output
The output shows how arrays are created, initialized, and the
accessing of elements.
Maps
In the Go language, the map is a data structure that has keys
and values. It consists of pairs of keys and values. Maps help
in retrieving the values based on the keys quickly. Map
provides operations for getting, updating, and deleting the
values.
Now let us look at an example for maps:
package main
import "fmt"
func main() {
var integer_keymap map[int]int

if integer_keymap == nil {
fmt.Println("It is not 
initialized")
} else {
fmt.Println("It is initialized")
}
string_keymap := map[int]string{
9:  "Bat",
23: "Ball",
14: "Cap",
19: "Pad",
4:  "Shoe",
}
fmt.Println("String keymap: ", 
string_keymap)
}
First, you need to save the above code in the
maps_example.go file. You can now compile and run the
maps_example.go. The command is shown as follows:
    go run maps_example.go
The output will be as follows:
Figure 1.16: Maps example execution output

The output shows how maps are declared and initialized with
values having integer and string keys.
Pointers and structures
In this section, we are going to look at how pointers and
structures are used in the Go language. Let us look at
pointers first.
Pointers
A pointer represents a variable, which stands for the memory
address of a variable. The memory address is persisted using
variables in the Go language. The format of a memory
address typically starts with 0x. An example of a memory
address is 0xCCAAF. Pointers are also used to get access to
the persisted data by using the memory address. Variables
have names and are easy to access and persist data.
Now, let us look at an example of pointers:
package main
import "fmt"
func main() {
hexa_var1 := 0xCC
hexa_var2 := 0x8F
fmt.Printf("variable type of hexa_var1 is 
%T\n", hexa_var1)
fmt.Printf("hexa_var1's value in 
hexadecimal is %X\n", hexa_var1)
fmt.Printf("hexa_var1's value in decimal is 
%v\n", hexa_var1)
fmt.Printf("variable type of hexa_var2 is 
%T\n", hexa_var2)

fmt.Printf("hexa_var2's value in 
hexadecimal is %X\n", hexa_var2)
fmt.Printf("hexa_var2's value in decimal is 
%v\n", hexa_var2)
} 
First, you need to save the above code in the
pointers_example.go file. You can now compile and run the
pointers_example.go. The command is shown as follows:
    go run pointers_example.go
The output will be as follows:
Figure 1.17: Pointers example execution output
The output shows how pointers are used and printed in
hexadecimal and decimal format.
Structures
A structure in the Go language has a set of properties which
are of different types. This user-defined type is similar to the
class in the OOP paradigm. In the Go language, inheritance is
not possible with structure. The composition can be modeled
using structure.
We can have a structure defined for the customer. It can be a
user-defined type, as follows:
type Customer struct {

Name    string
ID      string
city    string
Pincode int
}
Now, let us look at an example of customer struct:
package main
import "fmt"
type Customer struct {
Name    string
ID      string
city    string
Pincode int
}
func main() {
var customer Customer
fmt.Println(customer)
customer1 := Customer{"Andy Griffith", 
"CUST2341", "Atlanta", 30033}
fmt.Println("Customer1: ", customer1)
customer2 := Customer{Name: "Bill Smith", 
ID: "CUST6532", city: "Boston", Pincode: 102108}
fmt.Println("Customer2: ", customer2)
customer3 := Customer{Name: "Thomas Hardy"}
fmt.Println("customer3: ", customer3)
}

First, you need to save the above code in the
structures_example.go file. You can now compile and run
the structures_example.go. The command is shown as
follows:
    go run structures_example.go
The output will be as follows:
Figure 1.18: Structures example execution output
The output shows how structures are defined with initializers
and specifying the fields and values.
Recover, defer, and panic
In the Go language, the string is a set of different-width
characters.
Recover/Defer/Panic is similar to the Try/Catch block in other
languages. In the Go language, Recover /Defer/Panic helps in
handling errors. When a Go routine throws an error, panic
and Recover can help in managing the control of the
program.
Now let us look at an example of Recover/Defer/Panic:
package main
import "fmt"
func callPanic() {
if a := recover(); a != nil {
fmt.Println("RECOVER", a)

}
}
func enterInput(lady *string, resort *string) {
callPanic()                #marker2  
defer callPanic()
if lady == nil {
panic("Error: Lady name cannot be 
nil")
}
if resort == nil {
panic("Error: Resort name cannot be 
nil")
}
fmt.Printf("Lady Name: %s \n Resort: %s\n", 
*lady, *resort)
fmt.Printf("enterInput completed")
}
func main() {
Name_lady := "Annie"
enterInput(&Name_lady, nil)
fmt.Printf("main function completed")
}
First, you need to save the above code in the
recover_example.go file. You can now compile and run the
recover_example.go. The command is shown as follows:
    go run recover_example.go
The output will be as follows:

Figure 1.19: Recover example execution output
The output shows how panic and recovery help in handling
errors in the Go routine. The recovery function helps prevent
errors from panicking. It works in the same Go routine where
the error is panicked. The recover function is always called
the defer function.
Conclusion
In this chapter we have covered basic programming
constructs like Data types, variables, constants and
operators, conditional statements, strings and arrays, maps,
pointers, and structures, and recover, defer, and panic.
Examples were presented to demonstrate the use of the
constructs in Go language. In the next chapter, readers will
be presented with topics like error handling, interfaces,
typecasting, concurrency, and mutex.
In the next chapter, readers will be able to handle
concurrency and build concurrent applications. They will

know about handling errors and printing messages, which
are user-friendly when errors occur.
Points to remember
Data types in the Go language are basic, composite,
reference, and interface types.
Variables in the Go language can be declared of any
data type to store the data.
Constants can be defined in the Go language.
Mathematical operators can be represented using Go
language operators.
Conditional statements in the Go language are If, If.
Else, and Switch statements.
Strings can be defined as variables and initialized in Go
language.
Arrays in Go language are of fixed size. Slices can be
expanded.
Maps can have keys and values in Go languages.
Pointers represent the memory location of the data
stored.
Structures are user-defined data types that have
properties.
Recover/Defer/Panic are used to handle errors that can
occur at runtime or application-specific contexts.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and
Sessions with the Authors:
https://discord.bpbonline.com


CHAPTER 2
Advanced Features of Go
Introduction
In this chapter, we delve into the advanced features of the
Go language. We will explore various topics, including error
handling, interfaces, typecasting, concurrency, and mutex.
Each concept will be accompanied by practical code samples
and in-depth explanations. Deep dive into types and
interfaces will be done to cover various aspects. After Go
fundamentals in Chapter 1, this chapter is a jumpstart into
advanced topics.
The following figure illustrates advanced features of Go
language:

Figure 2.1: Go Lang advanced features
Structure
The chapter covers the following topics:
Error handling
Interfaces
Type casting
Concurrency
Mutex
Objectives
At the end of this chapter, you will be able to understand
how to use advanced features of the Go language. You can
look at the examples and learn how to handle error handling
in different scenarios. You will also learn about interfaces,
type casting, concurrency, and mutex in the Go language.
The following integrated development environments
(IDEs) can be used:
VS Code

GoLand
Vim
Komodo
GoSimple
Go Native
The following figure shows the features of an IDE:
Figure 2.2: IDE features
IDE provides different features like debuggers, runtime
compilation and modification, source control management,
developer workspace management, plugins, and different
language support. The latest tools and plugins are provided
to enhance the capabilities of IDE to deploy on the cloud
environments.
Error handling

In the Go language, errors are handled differently from other
languages. Errors are like data types and are returned by a
method in the Go language. There are no try/catch/finally
blocks, as observed in Java and other languages. No stack
traces can be printed using errors in the Go language.
The following figure illustrates the error-handling process in
the Go language:
Figure 2.3: Error handling
Error interface has a method error() and it returns a string.
We will learn more about interfaces later. You can define an
error by implementing the error function, which returns an
error string.
You can define it using the errors package and the fmt
package. Let us look at the first example using the errors
package using the following code snippet:
package main
import (
"errors"
"fmt"

)
var errorFraction = errors.New("Zero in the 
denominator")
func createFraction(intvar1, intvar2 int) (int, 
error) {
if intvar2 == 0 {
return 0, errorFraction
}
return intvar1 / intvar2, nil
}
func main() {
intvar1, intvar2 := 14, 0
output, error := createFraction(intvar1, 
intvar2)
if error != nil {
switch {
case errors.Is(error, 
errorFraction):
fmt.Println("Fraction with 
Zero Denominator")
default:
fmt.Printf("error in 
creating a fraction: %s\n", error)
}
return
}
fmt.Printf("%d / %d = %d\n", intvar1, 
intvar2, output)

}
To compile and run the preceding Go language program,
please ensure that you have the latest Go Lang executable.
You can download it at https://golang.org/dl/. Based on
the operating system that you use, you can download the
appropriate executable.
You can verify the installation by running the following
command:
go version
The output will be based on the version that you install, as
shown here:
bhagvanarch@Bhagvans-MacBook-Air code % go version
go version go1.22.1 darwin/arm64
bhagvanarch@Bhagvans-MacBook-Air code %
After verifying the installation, you can compile and run the
error_examples.go. using the following command:
go run error_examples.go
The output is shown here:
Figure 2.4: Error example execution output
Note: In most of the software projects, error handling is considered as
a significant best practice. Developers write proper code to make the
software more reliable.
Now, let us look at the second way of handling errors.
Execute the following command similar to the previous
example:
package main

import "fmt"
func createFraction(intvar1, intvar2 int) (int, 
error) {
if intvar2 == 0 {
return 0, fmt.Errorf("A fraction 
cannot have a denominator as zero and '%d' as 
numerator", intvar2)
}
return intvar1 / intvar2, nil
}
func main() {
intvar1, intvar2 := 14, 0
output, error := createFraction(intvar1, 
intvar2)
fmt.Printf("Error is %s and Output is 
%d\n", error.Error(), output)
}
You can compile and run the error_fmt_example.go. The
command is shown here:
go run error_fmt_example.go
The output is shown here:
Figure 2.5: Error FMT example execution output
You can also define the chain of function calls in the error
message that can be printed as output. This is similar to
stack traces in languages like Java and Python.

Interfaces
We have learned about interfaces in Chapter 1, Go
Fundamentals, let us do a quick recap through the following
figure:
Figure 2.6: Examples of interfaces
In the Go language, the interface is an abstract type
that consists of method signatures.
You cannot have instances of the interface.
You can create an interface by specifying the type
(keyword) and interface name interface (keyword).
More than one interface can be implemented by a data
type.
Interface embedding is supported by the Go language. The
composition of user-defined types is interface embedding.
This is different from go:embed directive. Go:embed is used to
embed in application binary the folders and files.
Now, let us look at an example of interface embeddings:
package main
import “fmt"

type embeddedStruct struct {
varSName string
}
func (eStruct embeddedStruct) display() string {
return fmt.Sprintf(“embedded Struct=%s", 
eStruct.varSName)
}
type Composite struct {
embeddedStruct
varName string
}
func main() {
composite := Composite{
embeddedStruct: embeddedStruct{
varSName: “embedded User 
Defned Type",
},
varName: “Composite With Embedded 
Struct",
}
fmt.Printf(“composite={struct Name: %s, 
composite Name: %s}\n", composite.varSName, 
composite.varName)          // Marker 1  
fmt.Println(“Struct name:", 
composite.embeddedStruct.varSName)
    fmt.Println(“display:", composite.display())    
//Market 2  
type displayer interface {

display() string
}
var vDisplayer displayer = composite
fmt.Println(“displayer:", 
vDisplayer.display())
}
Marker1 -> Composite will have the access to
embeddedStruct fields also
Marker2 -> Composite will have access to embeddedStruct’s
methods also
You can now compile and run the instance_embeddings.go.
The command is shown here:
go run instance_embeddings.go
The output is shown here:
Figure 2.7: Interface embeddings execution output
The following figure illustrates interface embedding:

Figure 2.8: Interface embedding
The output shows how the interface embeddings are used for
composite access and the behavior methods. Interface
embedding of the displayer helps in making composite as a
displayer. An interface in Go can be thought of as a
combination of a type and its value. The type represents the
actual interface, and the value holds the data associated
with it. For instance, a Displayer interface has a method
called display.
When we use interface embedding, a struct called
EmbeddedStruct can be considered a Displayer as well.
EmbeddedStruct has a field named varSName and
implements the display method from the Displayer interface.
Empty interface
An empty interface is an interface with no methods. All types
can implement an empty interface.
Let us look at an example of an Empty interface using the
following code:

package main
import (
"fmt"
)
func identifyInterfaceType(interf interface{}) {
fmt.Printf("Type of this interface is = %T, 
value of the interface is = %v\n", interf, interf)
}
func main() {
varStr := "John Smith has come"
identifyInterfaceType(varStr)
varInt := 94
identifyInterfaceType(varInt)
varCustomer := struct {
name string
}{
name: "Thomas Smith",
}
identifyInterfaceType(varCustomer)
}
You can now compile and run the
empty_interface_example.go. The command is shown as
follows:
go run empty_interface_example.go
The output is as follows:

Figure 2.9: Empty interface example execution output
Type assertion
Type assertion helps in deriving the interface type value.
interface.(X) gives the value of the concrete Type X for an
interface.
Let us look at the example of type assertion using the
following code:
package main
import (
"fmt"
)
func assert(interf interface{}) {
varS := interf.(string)
fmt.Println(varS)
}
func main() {
var varInterface interface{} = "checking 
interface"
assert(varInterface)
}
You can now compile and run the
interface_assert_example.go. The command is shown as
below:

go run interface_assert_example.go
The output will be as follows:
Figure 2.10: Interface assert example execution output
If you try sending any other type, a panic message is
displayed. To rectify this error message, you can rewrite the
method assert, as given in the following code snippet:
func assert(interf interface{}) {
varS, flag := interf.(string)
fmt.Println(varS,flag)
}
If you send int instead of a string, flag will be false and
the value will be 0.
Type switch
In Go, you can use a Type switch to check the type of an
interface using a list of case statements. Each case
statement checks against a specific type, similar to a regular
switch case with specified types.
To perform a Type switch, you use the i.(type) syntax in
the switch statement, where i is the interface variable you
want to check. This allows you to handle different types
differently based on the actual type stored in the interface.
Let us look at the example of a Type switch using the
following code:
package main
import (

"fmt"
)
func identifyType(varInter interface{}) {
switch varInter.(type) {
case string:
fmt.Printf("The type is a string 
and the value is %s\n", varInter.(string))
case int:
fmt.Printf("The type is int and the 
value is %d\n", varInter.(int))
default:
fmt.Printf("Ths is not known 
type\n")
}
}
func main() {
identifyType("This is a type check")
identifyType(93)
identifyType(231.44)
}
You can now compile and run the type_switch_example.go.
The command is shown as below:
zo run type_switch_example.go
The output will be as follows:

Figure 2.11: Switch example execution output
Zero value of interface
Nil is the zero value of an interface. Value and concrete type
of a Nil interface is Nil.
Let us look at the example of a Nil interface using the
following code:
package main
import "fmt"
type Displayer interface {
display()
}
func main() {
var varDisplay Displayer
if varDisplay == nil {
fmt.Printf("varDispaly is nil. It 
is of type %T  and value is %v\n", varDisplay, 
varDisplay)
}
}
You can now compile and run the
zero_value_interface_example.go. The command is
shown as follows:
go run zero_value_interface_example.go

The output will be as follows:
Figure 2.12: Zero value interface example execution output
If you invoke a method on the nil interface, panic message
Invalid memory address or Nil pointer dereference is
displayed:
Let us look at the example of a nil interface where a method
is invoked using the following code:
package main
type Displayer interface {
display()
}
func main() {
var varDisplay Displayer
varDisplay.display()
}
You can now compile and run the
nil_method_interface_example.go. The command is
shown as follows:
go run nil_method_interface_example.go
The output will be as follows:

Figure 2.13: Nil method interface example execution output
Type casting
In the Go language, types are not converted implicitly.
Variable data types can be the same, but explicit casting or
conversion is necessary in Go Lang. The term type
conversion is used in Go Lang for type casting. To convert a
value varData to a type X, you need to use X(varData).
Now, let us look at an example of type conversion using the
following code:
package main
import "fmt"
func getAverage(varArray [3]int) float32 {
total := 0
for i := 0; i < len(varArray); i++ {
total = total + varArray[i]
}
return float32(total) / 
float32(len(varArray))
}
func main() {
var varArray [3]int
varArray = [3]int{2, 3, 4}
var average float32
average = getAverage(varArray)
fmt.Printf("Average = %f\n", average)
}

You can now compile and run the typecasting_example.go.
The command is as follows:
go run typecasting_example.go
The output will be as follows:
Figure 2.14: TypeCasting example execution output
The output shows how the types of variables can be
converted using type conversion in Go Lang.
Concurrency
In the Go language, concurrency is achieved through
goroutines and channels, enabling the division of complex
problems into smaller tasks that can be run concurrently. The
code structure remains consistent for each smaller chunk,
simplifying parallel execution. Go routines serve as
lightweight threads, while channels facilitate safe
communication and data sharing between concurrent
processes, ensuring efficiency and scalability in Go
programs.
The following figure illustrates parallelism:

Figure 2.15: Parallel tasks
Let us look at goroutines first and see how they are used for
concurrency. In Go Lang, the go routine gets executed with a
thread owned by it. Go routines are functions.
Concurrency and parallelism are two distinct concepts in
computing. Concurrency involves executing multiple tasks in
overlapping time periods, where tasks can start and end
independently. While they may appear to run
simultaneously, they are scheduled to progress efficiently.
On the other hand, parallelism entails executing tasks truly
simultaneously using multiple processors or cores. Single-
threaded tasks, in contrast, execute sequentially, one after
another, similar to code statements.
Concurrency Background: Hoare came up with CSP in 1978, and
Dijkstra with guarded commands in 1975. There was a need for
modeling the real world which has independently running tasks and
objects behaving. Single threaded tasks were not helpful to model the
complex world behavior.
The following figure illustrates concurrency:

Figure 2.16: Concurrent Tasks
Now, let us look at an example of goroutines using the
following code:
package main
import (
"fmt"
"time"
)
func execute(message string) {
for i := 1; i <= 5; i++ {
time.Sleep(50 * time.Millisecond)
fmt.Println(message, ": ", i)
}
}
func main() {
fmt.Println("Go concurrency example")
go execute("Go routine 1")

go execute("Go routine 2")
go execute("Go routine 3")
time.Sleep(time.Second)
fmt.Println("Example completed")
}
You can now compile and run the concurrency_example.go.
The command is shown here:
go run concurrency_example.go
The output will be as follows:
Figure 2.17: Error example execution output
The output shows how the go routines are concurrently
executed.
Now let us look at channels, and consider the following
points:
Channels provide the capability or a feature for
goroutines to share information with another go

routine.
The channel can send the data to another channel.
Channels are bi-directional.
The channel can be created by using the chan
keyword.
Now let us look at an example for channels using the
following code:
package main
import "fmt"
func shareToChannel(varChannel chan int) {
for i := 0; i < 7; i++ {
varChannel <- i
}
close(varChannel)
}
func main() {
varintChannel := make(chan int)
go shareToChannel(varintChannel)
for i := 0; i < 7; i++ {
fmt.Println(<-varintChannel)
}
}
You can now compile and run the
concurrent_channels_example.go. The command is shown
as follows:
go run concurrent_channels_example.go
The output will be as shown here:

Figure 2.18: Error example execution output
The output shows how the channels are concurrently
executed.
What are the other languages supporting concurrency: There
are many other languages supporting concurrency. Some of
them are mentioned below:
Erlang
Occam
Alef
Limbo
Concurrent ML
Java
Mutex
In the Go language, executing a Go routine is achieved using
a mutex. Go routines will have an important code part to be
executed. Mutex is used to avoid race conditions. In Go Lang,
Mutex is in the Sync package. Mutex has two methods as
follows:
Lock
UnLock
The following figure shows the two methods of mutex:

Figure 2.19: Methods used in mutex
What is a mutex?: Mutex helps in sharing an object or resource to
multiple threads. Different threads can share a file. Andrea Steinbach
and Angelika Schofer came up with mutex in their master’s research
thesis. They were studying at Rheinishce Friedrich-Wilhelms
University.
Now let us look at an example of using mutex, as shown in
the following code:
package main
import (
"fmt"
"sync"
)
var GEncounter = 0
func executor(waitGroup *sync.WaitGroup) {
GEncounter = GEncounter + 1
waitGroup.Done()
}
func main() {
var varWaitGroup sync.WaitGroup

for i := 0; i < 1000; i++ {
varWaitGroup.Add(1)
go executor(&varWaitGroup)
}
varWaitGroup.Wait()
fmt.Println("Value of encounter", 
GEncounter)
}
You can now compile and run the mutex_example.go. The
command is shown as follows:
go run mutex_example.go
The output will be as follows:
Figure 2.20: Mutex example execution output
The output shows how mutex is used in Go Lang.
What is next in concurrency programming: We will discuss
concurrency patterns and building concurrent applications.
Concurrent patterns are as follows:
Generator
Channels for handling service
Multiplexing
Fan-in
Restoring sequencing
Select

Fan-in using select
Timeout using select
Quit channel
Receive on quit channel
Daisy chain
Conclusion
In this chapter, we have covered advanced topics like error
handling, interfaces, typecasting, concurrency, and mutex.
Examples were presented to demonstrate the use of the
constructs in the Go language. Interfaces were discussed in
detail, and examples were shown for the empty interface,
zero value of interface, type assertion, and type switch.
In the next chapter, we will cover topics such as basic
programming concepts in Go, data types, variables,
constants and operators, conditional statements, recover,
defer and panic, and strings. We will also look at data
structures like arrays, maps, pointers, and structures.
Points to remember
Error handling in Go Lang is done by using errors and
fmt package.
Interface embeddings help in modeling composite
access and in the creation of the behavior methods.
Type casting is necessary in the Go language. It needs
to be done explicitly.
Concurrency in Go Lang can be handled using channels
and Go routines.

CHAPTER 3
Go Console Applications
Introduction
In this chapter, readers will be presented with advanced
features in the Go language. The topics like error handling,
interfaces, typecasting, concurrency, and mutex will be
discussed. Each topic will have code samples and details
about how to use the Go language constructs. The following
figure illustrates the language’s components:

Figure 3.1: Go Lang console apps
Structure
The chapter covers the following topics:
Console-based app in Go language
Different input and output formats
Database interaction
Data structures
Objectives
At the end of this chapter, you will be able to understand
how to build console applications using the Go language. You
can look at the examples and learn how to handle different
input and output formats in different scenarios. You will also
learn about database interaction and data structures in the
Go language.
Console-based app in Go language
In Go language, you can have a console-based app that
takes the user input from the terminal and presents the
output based on the input value. Users are presented with a
menu that consists of different outputs expected by the user.
The menu will have a value associated with the expected
output.
You can also have flags in the command line execution of the
code. Flags can be different parameters and users can give a
flag and values to get the variations in the output of the
code. The flag package provides capabilities to get the input
values from the console.

Figure 3.2: Console app in Go language
Console-based apps are expected to have a menu to guide
the user on what kind of outputs can be expected. Let us
look at the example of a console-based app in the Go
language:
package main
import (
"bufio"
"fmt"
"os"
)
type Customer struct {
id        int
name      string
address   string
contactno string
}
var customers []Customer

func authenticate() bool {
var userid, password string
fmt.Print("Enter Your userid: ")
fmt.Scan(&userid)
fmt.Print("Enter Your password: ")
fmt.Scan(&password)
if userid == "guest" && password == "guest" 
{
fmt.Println("You are 
authenticated")
return true
} else {
fmt.Println("Your input is wrong. 
Please enter again")
return false
}
}
func showCommandMenu() {
fmt.Println("1. Display Customers")
fmt.Println("2. Display Customer by ID")
fmt.Println("3. Enter Customer 
Information")
fmt.Println("4. Update Customer 
Information")
fmt.Println("5. Delete Customer")
fmt.Println("0. Exit")
fmt.Print("Enter the menu choice id: ")

}
Now, let us look at CommandMenu method:
func CommandMenu() {
var choice int
showCommandMenu()
for {
fmt.Scan(&choice)
if choice == 0 {
fmt.Println("You entered 0 
for Exiting the Program")
break
} else {
switch choice {
case 1:
displayCustomerList(customers)
fmt.Println("Input 
'Enter' to go back to command menu....")
bufio.NewReader(os.Stdin).ReadBytes('\n')
showCommandMenu()
case 2:
var customerId int
fmt.Println()
fmt.Print("Input 
Customer ID :")

fmt.Scan(&customerId)
fmt.Println("\nDisplaying  Customer with ID ", 
customerId)
displayCustomerById(customerId, customers)
fmt.Println("Input 
'Enter' to back to command menu....")
bufio.NewReader(os.Stdin).ReadBytes('\n')
showCommandMenu()
case 3:
fmt.Println("Add a 
new Customer")
addNewCustomer(&customers)
fmt.Println()
fmt.Println("Input 
'Enter' to back to menu....")
bufio.NewReader(os.Stdin).ReadBytes('\n')
showCommandMenu()
case 4:
var customerId int
fmt.Print("Input 
Customer Id: ")
fmt.Scan(&customerId)

updateCustomerById(customerId, &customers)
fmt.Println()
fmt.Println("Imput 
'Enter' to back to menu....")
bufio.NewReader(os.Stdin).ReadBytes('\n')
showCommandMenu()
case 5:
var customerId int
fmt.Println()
fmt.Print("Input 
Customer Id: ")
fmt.Scan(&customerId)
deleteCustomerById(customerId, &customers)
fmt.Println()
fmt.Println("input 
'Enter' to back to menu....")
bufio.NewReader(os.Stdin).ReadBytes('\n')
showCommandMenu()
default:
fmt.Println("Input 
your choice again!")
showCommandMenu()
}

}
}
}
Next, we will look at displayCustomerList method:
func displayCustomerList(customers []Customer) {
for _, customer := range customers {
fmt.Println("ID :", customer.id)
fmt.Println("Name
:", 
customer.name)
fmt.Println("Address
:", 
customer.address)
fmt.Println("Contact No :", 
customer.contactno)
fmt.Println()
}
}
The following is the code for the displayCustomerById
method:
func displayCustomerById(id int, Customers 
[]Customer) {
for _, customer := range Customers {
if customer.id == id {
fmt.Println("ID :", 
customer.id)
fmt.Println("Name
:", 
customer.name)
fmt.Println("Address
:", 
customer.address)

fmt.Println("Contact No :", 
customer.contactno)
fmt.Println()
}
}
}
Let us look at the addNewCustomer method:
func addNewCustomer(customers *[]Customer) {
var customerId int
consoleReader := bufio.NewReader(os.Stdin)
fmt.Println()
fmt.Print("Enter Customer Id : ")
fmt.Scan(&customerId)
fmt.Print("Enter Customer Name : ")
name, _ := consoleReader.ReadString('\n')
fmt.Print("Enter Customer Address : ")
address, _ := 
consoleReader.ReadString('\n')
fmt.Print("Enter Customer Contact No : ")
contactno, _ := 
consoleReader.ReadString('\n')
Customer_ := Customer{customerId, name, 
address, contactno}
*customers = append(*customers, Customer_)
}
The following is the code for the updateCustomerById
method:

func updateCustomerById(id int, customers *
[]Customer) {
var newContactno string
fmt.Println()
fmt.Print("Enter the New Contact No of the 
Customer: ")
fmt.Scan(&newContactno)
for i, customer := range *customers {
if customer.id == id {
(*customers)[i] = 
Customer{id, customer.name, customer.address, 
newContactno}
}
}
}
We will look at the deleteCustomerById method:
func deleteCustomerById(id int, customers *
[]Customer) {
for i, customer := range *customers {
if customer.id == id {
*customers = 
append((*customers)[:i], (*customers)[i+1:]...)
}
}
}
func CRMConsoleApp() {
for !authenticate() {

authenticate()
break
}
customers = append(customers, Customer{id: 
1, name: "John Smith", address: "California", 
contactno: "231456"})
customers = append(customers, Customer{id: 
2, name: "Brad Smith", address: "Boston", 
contactno: "43212344"})
CommandMenu()
}
func main() {
CRMConsoleApp()
}
To compile and run the above Go language program, please
ensure that you have the latest go lang executable. You can
download it at https://golang.org/dl/. Based on the
operating system that you use, you can download the
appropriate executable.
You can verify the installation by running the below
command:
go version
The output will be based on the version that you install. It
will be as follows:
bhagvanarch@Bhagvans-MacBook-Air code % go version
go version go1.22.1 darwin/arm64
bhagvanarch@Bhagvans-MacBook-Air code %
After verifying the installation, you can compile and run the
error_example.go. The command is as follows:

go run error_example.go
The output will be as follows:
(base) apples-MacBook-Air:code bhagvan.kommadi$ go 
run customerapp_cmdline.go 
Enter Your userid: guest
Enter Your password: guest
You are authenticated
1. Display Customers
2. Display Customer by ID
3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 1
ID
: 1
Name
: John Smith
Address : California
Contact No
: 231456
ID
: 2
Name
: Brad Smith
Address : Boston
Contact No
: 43212344
Input 'Enter' to go back to command menu....
2
1. Display Customers
2. Display Customer by ID

3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 2
Input Customer ID :1
Displaying  Customer with ID  1
ID
: 1
Name
: John Smith
Address : California
Contact No
: 231456
Input 'Enter' to back to command menu....
1. Display Customers
2. Display Customer by ID
3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 3
Add a new Customer
Enter Customer Id : 3
Enter Customer Name : George Clooney
Enter Customer Address : Los Angeles
Enter Customer Contact No : 234123
Input 'Enter' to back to menu....

1. Display Customers
2. Display Customer by ID
3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 4
Input Customer Id: 2
Enter the New Contact No of the Customer: 4454223
Imput 'Enter' to back to menu....
1. Display Customers
2. Display Customer by ID
3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 1
ID
: 1
Name
: John Smith
Address : California
Contact No
: 231456
ID
: 2
Name
: Brad Smith
Address : Boston
Contact No
: 4454223

ID
: 3
Name
: George Clooney
Address : Los Angeles
Contact No
: 234123
Input 'Enter' to go back to command menu....
1. Display Customers
2. Display Customer by ID
3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 5
Input Customer Id: 3
input 'Enter' to back to menu....
1. Display Customers
2. Display Customer by ID
3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 1
ID
: 1
Name
: John Smith
Address : California
Contact No
: 231456

ID
: 2
Name
: Brad Smith
Address : Boston
Contact No
: 4454223
Input 'Enter' to go back to command menu....
1. Display Customers
2. Display Customer by ID
3. Enter Customer Information
4. Update Customer Information
5. Delete Customer
0. Exit
Enter the menu choice id: 0
You entered 0 for Exiting the Program
(base) apples-MacBook-Air:code bhagvan.kommadi$
Note: In most software projects, console-based applications are built
first to manually test the software and get a feel of the application first
cut. Software engines that are used for mathematical and commercial
purposes use the console-based approach to load different scenarios
quickly and see the outputs.
Different input and output formats
Let us take a deep dive. Interface embedding is supported by
the Go language. The composition of user-defined types is
interface embedding. This is different from go:embed
directive. go:embed is used to embed in application binary
the folders and files. The different input and output formats
are explained in the following figure:

Figure 3.3: Input and output formats
Now, let us look at an example of handling different input
formats.
Text format
First, let us look at text file handling:
package main
import (
"fmt"
"log"
"os"
)
func WriteTextFile(path string) {
fmt.Println("Writing a Text Format file in 
Go lang")
text_file, error := os.Create(path)
if error != nil {
log.Fatalf("could not create a text 
file: %s", error)
}
defer text_file.Close()

length, error := 
text_file.WriteString("This is to test writing a 
text formatted file" +
" Code demonstrates writing and 
reading a text file" +
" Go lang.")
if error != nil {
log.Fatalf("could not create a text 
file: %s", error)
}
fmt.Println("Text File Name is %s", 
text_file.Name())
fmt.Println("Text File Length is %d bytes", 
length)
}
func FindTextFile(textFile string) {
fmt.Println("Reading a text format  in Go 
lang")
text_data, error := os.ReadFile(textFile)
if error != nil {
log.Panicf("cannot reading test 
from file: %s", error)
}
fmt.Println("Text File Name: %s", textFile)
fmt.Println("Text DataSize: %d bytes", 
len(text_data))
fmt.Println("Text Data: %s", 
string(text_data))

}
func main() {
path := "input_test_format.txt"
WriteTextFile(path)
FindTextFile(path)
}
You can now compile and run the
reading_writing_text_format.go. The command is shown
as follows:
go run reading_writing_text_format.go
The output will be as follows:
Figure 3.4: Reading Writing Text Format Execution output
The output shows how text-formatted files can be read and
written using Go Lang.
JSON
You can use Unmarshal method on json package to read
json data format. The Marshal method on json package can
be used to write json data formatted file.
Now let us look at the json format file handling:
package main
import (
"encoding/json"

"fmt"
"os"
)
type Customer struct {
Id      int
Name    string
Address string
Company string
}
func main() {
customer := Customer{}
customer.Id = 7832
customer.Name = "George Smith"
customer.Address = "California"
customer.Company = "Dell"
customerData, _ := json.Marshal(customer)
fmt.Println(string(customerData))
customer1 := Customer{783, "Thomas Smith", 
"Boston", "AMD"}
jsonData, _ := json.Marshal(customer1)
fmt.Println(string(jsonData))
custData1 := []byte(`{"Id":354,"Name":"John 
Smith","Addresss":"Denver","Company":"Jockey"}`)
var customer2 Customer
json.Unmarshal(custData1, &customer2)
fmt.Println(customer2)

var customer4 Customer
json.Unmarshal(customerData, &customer4)
fmt.Println(customer4)
customer5 := Customer{
Id:      8934,
Name:    "Kerry Donner",
Address: "Charlotte",
Company: "Best Buy",
}
json_file, _ := 
json.MarshalIndent(customer5, "", " ")
_ = os.WriteFile("customer.json", 
json_file, 0644)
}
You can now compile and run the
reading_writing_json_format.go. The command is shown
as follows:
go run reading_writing_json_format.go
The output will be as follows:
Figure 3.5: Reading Writing JSON Format Execution output
The output shows how the json formatted files can be read
using Go Lang.

XML
You can use UnMarshal() method on xml to read xml bytes
to a string. Marshal() method on xml package can be used
to write an XML file.
Now let us look at an example for reading and writing XML
files.
package main
import (
"encoding/xml"
"fmt"
"io"
"os"
)
type Customers struct {
XMLName xml.Name `xml:"customers"`
Customers []Customer `xml:"customer"`
}
type Customer struct {
XMLName xml.Name `xml:"customer"`
//Type    string   `xml:"type,attr"`
Address string  `xml:"address"`
Name    string  `xml:"name"`
Company Company `xml:"company"`
}
type Company struct {
XMLName  xml.Name `xml:"company"`

Category string   `xml:"category,attr"`
Name     string   `xml:"name"`
Location string   `xml:"location"`
}
type XMLUtil struct {
}
func NewXMLUtil() *XMLUtil {
return &XMLUtil{}
}
func (xmlUtil *XMLUtil) readXML(path string) {
xmlFormatFile, error := 
os.Open("customers.xml")
if error != nil {
fmt.Println(error)
}
fmt.Println("customers.xml exists and 
opened")
defer xmlFormatFile.Close()
xmlBytes, _ := io.ReadAll(xmlFormatFile)
var customers Customers
xml.Unmarshal(xmlBytes, &customers)
fmt.Println(customers)
for i := 0; i < len(customers.Customers); 
i++ {
fmt.Println("Customer Name is " + 
customers.Customers[i].Name)

fmt.Println("Customer Address is " 
+ customers.Customers[i].Address)
fmt.Println("Customer's Company  " 
+ customers.Customers[i].Company.Name)
fmt.Println("Customer's Company 
Category is " + 
customers.Customers[i].Company.Category)
}
}
func (xmlUtil *XMLUtil) writeXML(path string) {
customer := Customer{
Name:    "Jack Donner",
Address: "Chicago",
Company: Company{
Name:     "Marigold",
Location: "Denver",
Category: "Silver"},
}
file, _ := xml.MarshalIndent(customer, "", 
" ")
_ = os.WriteFile(path, file, 0644)
}
func main() {
var xmlUtil *XMLUtil
xmlUtil = NewXMLUtil()
xmlUtil.readXML("customers.xml")
xmlUtil.writeXML("customer.xml")

}
You can now compile and run the xml_util.go. The
command is shown as follows:
go run xml_util.go
The output will be as follows:
Figure 3.6: XML Util execution output
The output shows how the xml files can be read and written
using Go language.
Database interaction
In Go language, you can use packages or external libraries to
reuse code. Database sqlite3 can be connected to the Go
Lang program using the matte/go-sqlite3 package or
library. In this example, we are going to use Go modules. The
following figure explains the database-driven applications:

Figure 3.7: Database driven applications
First, let us look at the code for sqlite3 database
interaction:
package main
import (
"database/sql"
"fmt"
"log"
_ "github.com/mattn/go-sqlite3"
)
type DBUtil struct {
}
func NewDBUtil() *DBUtil {
return &DBUtil{}
}

func (dbUtil *DBUtil) readDB(path string) {
database, error := sql.Open(path, 
":memory:")
if error != nil {
log.Fatal(error)
}
defer database.Close()
var version_number string
error = database.QueryRow("SELECT 
SQLITE_VERSION()").Scan(&version_number)
if error != nil {
log.Fatal(error)
}
fmt.Println(version_number)
}
func main() {
var dbUtil *DBUtil
dbUtil = NewDBUtil()
dbUtil.readDB("sqlite3")
}
You can now compile and run the main.go. The command to
create a module golang-db is shown as follows:
    go mod init golang-db
    go mod tidy
Then, the module is built using the following command:
Go build

The output will be as follows:
Figure 3.8: Reading Writing Text Format Execution output
The output shows the database version of sqlite3 being
used. sqlite3 database is used, and it is very popular for
beginners who are learning goland with databases. sqlite3
is a standalone database application. Many applications
include this database in their products.
Data structures
In the Go language, we have seen basic data structures with
examples. Basic data structures are array, map, slice, and
struct. These are covered in the first chapter. We will have
advanced data structures like linked lists, sets, trees, and
stacks in the upcoming chapters. The following figure
illustrates some of these structures:

Figure 3.9: Data structures
First, let us look at the linked list. A list is a data structure in
which every element points to the next element. This is
called SinglyLinkedList. A doubly linked list element will
have previous and next element pointers.
Now let us look at an example of using mutex:
package main
import (
"fmt"
)
type Node struct {
property int
nextNode *Node
}
type SinglyLinkedList struct {
headNode *Node
}
func (singlyLinkedList *SinglyLinkedList) 
AddToTheRoot(property int) {
var node = &Node{}
node.property = property
node.nextNode = nil
if singlyLinkedList.headNode != nil {
node.nextNode = 
singlyLinkedList.headNode
}
singlyLinkedList.headNode = node

}
func (singlyLinkedList *SinglyLinkedList) 
CreateNode(property int) *Node {
var node *Node
var nodeWith *Node
for node = singlyLinkedList.headNode; node 
!= nil; node = node.nextNode {
if node.property == property {
nodeWith = node
break
}
}
return nodeWith
}
func (singlyLinkedList *SinglyLinkedList) 
AddAfterThisElement(nodeProperty int, property int) 
{
var node = &Node{}
node.property = property
node.nextNode = nil
var nodeWith *Node
nodeWith = 
singlyLinkedList.CreateNode(nodeProperty)
if nodeWith != nil {
node.nextNode = nodeWith.nextNode
nodeWith.nextNode = node
}

}
func (singlyLinkedList *SinglyLinkedList) 
GetLastNode() *Node {
var node *Node
var lastNode *Node
for node = singlyLinkedList.headNode; node 
!= nil; node = node.nextNode {
if node.nextNode == nil {
lastNode = node
}
}
return lastNode
}
func (singlyLinkedList *SinglyLinkedList) 
AddToLastNode(property int) {
var node = &Node{}
node.property = property
node.nextNode = nil
var lastNode *Node
lastNode = singlyLinkedList.GetLastNode()
if lastNode != nil {
lastNode.nextNode = node
}
}
func (singlyLinkedList *SinglyLinkedList) 
ListIterator() {
var node *Node

for node = singlyLinkedList.headNode; node 
!= nil; node = node.nextNode {
fmt.Println(node.property)
}
}
func main() {
var singlyLinkedList SinglyLinkedList
singlyLinkedList = SinglyLinkedList{}
singlyLinkedList.AddToTheRoot(1)
singlyLinkedList.AddToTheRoot(2)
singlyLinkedList.AddToLastNode(4)
singlyLinkedList.AddAfterThisElement(1, 6)
singlyLinkedList.ListIterator()
}
You can now compile and run the
singly_linked_list_example.go. The command is:
    go run singly_linked_list_example.go
The output will be as follows:
Figure 3.10: Reading Writing Text Format Execution output
The output shows how you can have a SinglyLinkedList in
Go Lang.

Conclusion
In this chapter, we have covered topics related to Go console
applications, like handling different input and output formats
and interacting with databases and data structures.
Examples were presented to demonstrate where console
applications can be used and how to build them using Go
Lang.
In the next chapter, we will look into algorithms, Rest API in
Go, Rest API interacting with a relational database, Rest API
interacting with No SQL database, Rest API interacting with
message queues, and Go Best Practices.
Points to remember
Command line applications can be built by having
menu 
driven 
commands 
and 
each 
command
implemented as a function in Go Lang.
You can handle text, json, and xml input and output
formats 
using 
io/ioutil, 
encoding/ 
xml, 
and
encoding/json packages.
Developers can interact with databases, and they can
build Go modules.
Simple data structures like arrays, structs, and maps
were presented in Chapter 1.
The coming chapters will handle advanced data
structures like lists, trees, and stacks. A single linked
list can be used to model a data structure with
elements pointing to the next element.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and
Sessions with the Authors:

https://discord.bpbonline.com

CHAPTER 4
Building REST API
Introduction
In this chapter, you will learn about different algorithms that can
be implemented in Go. They will also know how to develop REST
API to access data from different data sources. The REST API can
read and write data to data sources like relational databases,
NoSQL databases, and message queues. REST API clients can be
web applications and mobile applications.
We will be looking at how REST API can be developed by the Go
Lang developers.

Figure 4.1: Go Lang REST API
Figure 4.1 shows the topics which we are going to cover in the
chapter.
Structure
The chapter covers the following topics:
Algorithms
REST API in Go
REST API interacting with relational database
REST API interacting with No SQL database
REST API interacting with message queues
Go best practices
Objectives
By the end of this chapter, the reader will learn how to build REST
API using Go Lang. You can look at the examples and learn how to
develop REST API from various data sources like relational
databases, No SQL databases, and RabbitMQ message queues.
You will also learn about tips, design patterns, and Best Practices
in the Go language.
Algorithms
In the Go language, you can write algorithms to solve complex
tasks. For example, Sorting can be done in different ways. One of
the famous algorithms is bubble sort.
Bubble sort
Let us look at the example for a bubble sorting util class in Go
Lang:
package main
import (
"fmt"

)
type BubbleSortUtil struct {
}
func NewBubbleSortUtil() *BubbleSortUtil {
return &BubbleSortUtil{}
}
func (bubbleSortUtil *BubbleSortUtil) sort(integers 
[11]int) {
var num int
num = 11
var isSwapped bool
isSwapped = true
for isSwapped {
isSwapped = false
var i int
for i = 1; i < num; i++ {
if integers[i-1] > integers[i] 
{
var temp = integers[i]
integers[i] = 
integers[i-1]
integers[i-1] = temp
isSwapped = true
}
}
}
fmt.Println(integers)
}

func main() {
var integers [11]int = [11]int{31, 13, 12, 4, 
18, 16, 7, 2, 3, 0, 10}
var bubbleSortUtil *BubbleSortUtil
bubbleSortUtil = NewBubbleSortUtil()
fmt.Println("Bubble Sort Util sorting the 
numbers")
bubbleSortUtil.sort(integers)
}
To compile and run the above code, you need to have the latest
go lang executable. You can download the go lang executable at
https://golang.org/dl/. Based on the OS that you have, you can
select the appropriate executable.
You can verify the Go Lang compiler by running the following
command:
go version
The output will be based on the operating system and version
that you install as shown as follows:
bhagvanarch@Bhagvans-MacBook-Air code % go version
go version go1.22.1 darwin/arm64
bhagvanarch@Bhagvans-MacBook-Air code %
Now, you can compile and run the bubble_sort_util.go. The
command is shown as follows:
go run bubble_sort_util.go
The output will be as follows:
Figure 4.2: Bubble sort util execution output

Note: In most of the software programs, algorithms are used for sorting,
finding, searching, and storing data in an effective way. Data structures are
used appropriately to read the data and execute the algorithms in an
efficient way.
REST API in Go
Let us take a deep dive in implementing REST API in Go Lang. You
can use Fiber to design and develop REST API in Go Lang. Fiber is
a REST API based open-source framework. It was built along on
the lines of Express.js with Fasthttp.
Now let us look at the REST API code:
package main
import (
"log"
"github.com/gofiber/fiber/v2"
"github.com/gofiber/fiber/v2/middleware/cors"
)
func main() {
RESTapi := fiber.New()
RESTapi.Use(cors.New())
customers := RESTapi.Group("/customers")
customers.Get("/", func(context *fiber.Ctx) 
error {
return context.SendString("Customers 
are being loaded")
})
log.Fatal(RESTapi.Listen(":5000"))
}
You can now compile using creating a module customers_api.
The command is shown as follows:
go mod init customers_api

go mod tidy
go build
./customers_api
The output will be as follow:
Figure 4.3: go mod init output
The output shows how text formatted file can be read and written
using Go Lang. You can access in any browser using this link:
http://127.0.0.1:5000/customers.
Figure 4.4: Loading the customers
Now, let us look at the REST API interacting with relational
database.

REST API interacting with relational database
In Go, you can build REST API which interact with relational
databases for getting and storing data. You can also use the Gin
REST framework. It is based on an HTTP Router, which provides
features like routing and form validation. You can use GORM to
persist data to the relational database.
Let us first look at the code structure, modules, and files in this
project:
Figure 4.5: Project structure
We are looking at REST API interacting with the Relational
database in this folder db code. It has controllers and model
modules. There is an entry file main.go, which invokes the code in
controllers and model modules. The folder models have the
database interaction code. The folder controllers have the routing
code in Go Lang.
First, let us look at how to create an object model in Go Lang
based on a relational database model. In the models package, we
create an employee object, which is mapped by GORM to a
relational database table. The object fields are mapped to
relational database column types:
models.go
package models
import (

"gorm.io/driver/sqlite"
"gorm.io/gorm"
)
type Employee struct {
ID         uint   `json:"id" 
gorm:"primary_key"`
Name       string `json:"name"`
Department string `json:"department"`
}
var DB *gorm.DB
func ConnectDatabase() {
database, error := 
gorm.Open(sqlite.Open("customers.db"), &gorm.Config{})
if error != nil {
panic("Failed to connect to database!")
}
error = database.AutoMigrate(&Employee{})
if error!= nil {
return
}
DB = database
}
In the controllers package, different routes are handled to
query to update the database:
controllers.go
package controllers
import (
"net/http"

"github.com/gin-gonic/gin"
"github.com/rahmanfadhil/gin-bookstore/models"
)
type CreateEmployeeInput struct {
Name       string `json:"name" 
binding:"required"`
Department string `json:"department" 
binding:"required"`
}
type UpdateEmployeeInput struct {
Name       string `json:"name"`
Department string `json:"department"`
}
func FindEmployees(context *gin.Context) {
var employees []models.Employee
models.DB.Find(&employees)
context.JSON(http.StatusOK, gin.H{"data": 
employees})
}
In the above code, you can see the code for finding the
employees from the database and the list of the employees from
the relational database. Let us look at CreateEmployee method:
func CreateEmployee(context *gin.Context) {
var input CreateEmployeeInput
if err := context.ShouldBindJSON(&input); err 
!= nil {
context.JSON(http.StatusBadRequest, 
gin.H{"error": err.Error()})
return
}

employee := models.Employee{Name: input.Name, 
Department: input.Department}
models.DB.Create(&employee)
context.JSON(http.StatusOK, gin.H{"data": 
employee})
}
In the above code, you can see the code for creating employees
from the input. The input formation is bound to the input using
the context. Now, let us look at FindEmployee method:
func FindEmployee(context *gin.Context) {
var employee models.Employee
if err := models.DB.Where("id = ?", 
context.Param("id")).First(&employee).Error; err != nil 
{
context.JSON(http.StatusBadRequest, 
gin.H{"error": "Record not found!"})
return
}
context.JSON(http.StatusOK, gin.H{"data": 
employee})
}
In the above code, you can see the code for finding the employee
from the database given the id. The id is obtained from the
context parameters. Now, let us look at the updateEmployee
method:
func UpdateEmployee(context *gin.Context) {
var employee models.Employee
if err:= models.DB.Where("id = ?", 
context.Param("id")).First(&employee).Error; err != nil 
{
context.JSON(http.StatusBadRequest, 
gin.H{"error": "Record not found!"})

return
}
var input UpdateEmployeeInput
if err:= context.ShouldBindJSON(&input); err != 
nil {
context.JSON(http.StatusBadRequest, 
gin.H{"error": err.Error()})
return
}
models.DB.Model(&employee).Updates(input)
context.JSON(http.StatusOK, gin.H{"data": 
employee})
}
In the above code, you can see the code for updating the
employee in the database given the employee object. The
employee object is bound to the input from the context. Let us
look at DeleteEmployee method:
func DeleteEmployee(context *gin.Context) {
var employee models.Employee
if err:= models.DB.Where("id = ?", 
context.Param("id")).First(&employee).Error; err != nil 
{
context.JSON(http.StatusBadRequest, 
gin.H{"error": "Record not found!"})
return
}
models.DB.Delete(&employee)
context.JSON(http.StatusOK, gin.H{"data": 
true})
}

In the above code, you can see the code for deleting the
employee from the database. The employee record is first
searched on id, which is retrieved as a parameter from the
context. After finding the employee record, it is deleted.
In the main.go, different Gin routes are mapped to controller
functions defined in Go Lang:
main.go
package main
import (
"github.com/gin-gonic/gin"
"REST_api_relational_db/controllers"
"REST_api_relational_db/models"
)
func main() {
gin_instance := gin.Default()
models.ConnectDatabase()
gin_instance.GET("/employees", 
controllers.FindEmployees)
gin_instance.POST("/employees", 
controllers.CreateEmployee)
gin_instance.GET("/employees/:id", 
controllers.FindEmployee)
gin_instance.PATCH("/employees/:id", 
controllers.UpdateEmployee)
gin_instance.DELETE("/employees/:id", 
controllers.DeleteEmployee)
err:= gin_instance.Run()
if err!= nil {
return
}

}
You can now compile and run the main.go. The command to
create a module REST_api_relational_db is:
   go mod init REST_api_relational_db
    go mod tidy
Then, the module is built using the following command:
go build
The output will be as follows:
Figure 4.6: How you can use postman to check the routes
First, let us look at the endpoint/employees. Post call is invoked
using the postman:
Checking /employees/ end point/route post call.

Figure 4.7: /employees endpoint Post response
Now, let us look at the delete call on the /employees
endpoint/route. Delete call is invoked using the postman. The
output is attached below for the response:
Checking /employees/1  - DELETE
Figure 4.8: /employees endpoint delete response
Patch call for the endpoint/employees is invoked using the
postman. The output is as follows for the response:
Checking PATCH /employees/2 endpoint/route/

Figure 4.9: /employees/ Patch response
GET Call for the endpoint/employees is invoked using the
postman. The output is as follows for the response.
Checking /employees/ endpoint/route GET call.
Figure 4.10: /emeployees endpoint GET response
REST API interacting with No SQL database

In the Go language, we have seen interaction with relational
databases. Now, let us see the interaction with No SQL database
like MongoDB. To start with, we need a MongoDB driver Go
language based. We will be using the go.mongodb.org/mongo-
driver/mongo package:
1. First, let us look at creating REST API and routes. main.go
will have the routes set through package routes.
2. Then, look at the code for REST API using Fiber and
MongoDB.
main.go
package main
import (
"github.com/gofiber/fiber/v2"
"REST_api_nosql_db/routes"
)
func main() {
app := fiber.New()
routes.SupplierRoute(app)
app.Listen(":6000")
}
3. Now, let us look at the routes, supplierRoute has
Create/Get/Edit/Delete/GetAll supplier routes configured
through Post/Get/Delete methods. Below are the listed
routes:
Get    /supplier/:supplierid         Get Supplier
Post  /supplier/:supplierid           
CreateSupplier
Put      /supplier/:supplierid         
EditSupplier
Delete  /supplier/:supplierid        
DeleteSupplier
Get      /suppliers                            
GetAllSuppliers
routes.go
package routes
import (
"github.com/gofiber/fiber/v2"
"REST_api_nosql_db/controllers"

)
func SupplierRoute(app *fiber.App) {
app.Post("/supplier", 
controllers.CreateSupplier)
app.Get("/supplier/:supplierId", 
controllers.GetSupplier)
app.Put("/supplier/:supplierId", 
controllers.EditSupplier)
app.Delete("/supplier/:supplierId", 
controllers.DeleteSupplier)
app.Get("/suppliers", 
controllers.GetAllSuppliers)
}
4. The controller has the routes mapped to methods that talk
to MongoDB. Methods are used to query and update the
Mongo database:
controllers.go
package controllers
import (
"context"
"net/http"
"REST_api_nosql_db/configs"
"REST_api_nosql_db/models"
"REST_api_nosql_db/responses"
"time"
"github.com/go-playground/validator/v10"
"github.com/gofiber/fiber/v2"
"go.mongodb.org/mongo-driver/bson"
"go.mongodb.org/mongo-
driver/bson/primitive"
"go.mongodb.org/mongo-driver/mongo"
)
var supplierCollection *mongo.Collection = 
configs.GetCollection(configs.DB, "suppliers")
var validate = validator.New()
func CreateSupplier(c *fiber.Ctx) error {
ctx, cancel := 
context.WithTimeout(context.Background(), 

10*time.Second)
var supplier models.Supplier
defer cancel()
if err := c.BodyParser(&supplier); err != 
nil {
return 
c.Status(http.StatusBadRequest).JSON(responses.Sup
plierResponse{Status: http.StatusBadRequest, 
Message: "error", Data: &fiber.Map{"data": 
err.Error()}})
}
if validationErr := 
validate.Struct(&supplier); validationErr != nil {
return 
c.Status(http.StatusBadRequest).JSON(responses.Sup
plierResponse{Status: http.StatusBadRequest, 
Message: "error", Data: &fiber.Map{"data": 
validationErr.Error()}})
}
newSupplier := models.Supplier{
Id:      primitive.NewObjectID(),
Name:    supplier.Name,
Address: supplier.Address,
Mobile:  supplier.Mobile,
}
result, err := 
supplierCollection.InsertOne(ctx, newSupplier)
if err != nil {
return 
c.Status(http.StatusInternalServerError).JSON(resp
onses.SupplierResponse{Status: 
http.StatusInternalServerError, Message: "error", 
Data: &fiber.Map{"data": err.Error()}})
}
return 
c.Status(http.StatusCreated).JSON(responses.Suppli
erResponse{Status: http.StatusCreated, Message: 
"success", Data: &fiber.Map{"data": result}})
}

GetSupplier—Mongo database call:
func GetSupplier(c *fiber.Ctx) error {
ctx, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
supplierId := c.Params("supplierId")
var supplier models.Supplier
defer cancel()
objId, _ := 
primitive.ObjectIDFromHex(supplierId)
err := supplierCollection.FindOne(ctx, 
bson.M{"id": objId}).Decode(&supplier)
if err != nil {
return 
c.Status(http.StatusInternalServerError).JSON(r
esponses.SupplierResponse{Status: 
http.StatusInternalServerError, Message: 
"error", Data: &fiber.Map{"data": 
err.Error()}})
}
return 
c.Status(http.StatusOK).JSON(responses.Supplier
Response{Status: http.StatusOK, Message: 
"success", Data: &fiber.Map{"data": supplier}})
}
EditSupplier—Mongo database call:
func EditSupplier(c *fiber.Ctx) error {
ctx, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
supplierId := c.Params("supplierId")
var supplier models.Supplier
defer cancel()
objId, _ := 
primitive.ObjectIDFromHex(supplierId)
if err := c.BodyParser(&supplier); err 
!= nil {

return 
c.Status(http.StatusBadRequest).JSON(responses.
SupplierResponse{Status: http.StatusBadRequest, 
Message: "error", Data: &fiber.Map{"data": 
err.Error()}})
}
if validationErr := 
validate.Struct(&supplier); validationErr != 
nil {
return 
c.Status(http.StatusBadRequest).JSON(responses.
SupplierResponse{Status: http.StatusBadRequest, 
Message: "error", Data: &fiber.Map{"data": 
validationErr.Error()}})
}
update := bson.M{"name": supplier.Name, 
"address": supplier.Address, "mobile": 
supplier.Mobile}
result, err := 
supplierCollection.UpdateOne(ctx, bson.M{"id": 
objId}, bson.M{"$set": update})
if err != nil {
return 
c.Status(http.StatusInternalServerError).JSON(r
esponses.SupplierResponse{Status: 
http.StatusInternalServerError, Message: 
"error", Data: &fiber.Map{"data": 
err.Error()}})
}
var updatedSupplier models.Supplier
if result.MatchedCount == 1 {
err := 
supplierCollection.FindOne(ctx, bson.M{"id": 
objId}).Decode(&updatedSupplier)
if err != nil {
return 
c.Status(http.StatusInternalServerError).JSON(r
esponses.SupplierResponse{Status: 
http.StatusInternalServerError, Message: 

"error", Data: &fiber.Map{"data": 
err.Error()}})
}
}
return 
c.Status(http.StatusOK).JSON(responses.Supplier
Response{Status: http.StatusOK, Message: 
"success", Data: &fiber.Map{"data": 
updatedSupplier}})
}
DeleteSupplier—Mongo database call:
func DeleteSupplier(c *fiber.Ctx) error {
ctx, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
supplierId := c.Params("supplierId")
defer cancel()
objId, _ := 
primitive.ObjectIDFromHex(supplierId)
result, err := 
supplierCollection.DeleteOne(ctx, bson.M{"id": 
objId})
if err != nil {
return 
c.Status(http.StatusInternalServerError).JSON(r
esponses.SupplierResponse{Status: 
http.StatusInternalServerError, Message: 
"error", Data: &fiber.Map{"data": 
err.Error()}})
}
if result.DeletedCount < 1 {
return 
c.Status(http.StatusNotFound).JSON(
responses.SupplierResponse{Status: 
http.StatusNotFound, Message: "error", Data: 
&fiber.Map{"data": "This SupplierID not 
found!"}},

)
}
return c.Status(http.StatusOK).JSON(
responses.SupplierResponse{Status: 
http.StatusOK, Message: "success", Data: 
&fiber.Map{"data": "Supplier  deleted!"}},
)
}
GetAllSuppliers—Mongo database call:
func GetAllSuppliers(c *fiber.Ctx) error {
ctx, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
var suppliers []models.Supplier
defer cancel()
results, err := 
supplierCollection.Find(ctx, bson.M{})
if err != nil {
return 
c.Status(http.StatusInternalServerError).JSON(r
esponses.SupplierResponse{Status: 
http.StatusInternalServerError, Message: 
"error", Data: &fiber.Map{"data": 
err.Error()}})
}
defer results.Close(ctx)
for results.Next(ctx) {
var singleSupplier 
models.Supplier
if err = 
results.Decode(&singleSupplier); err != nil {
return 
c.Status(http.StatusInternalServerError).JSON(r
esponses.SupplierResponse{Status: 
http.StatusInternalServerError, Message: 
"error", Data: &fiber.Map{"data": 
err.Error()}})

}
suppliers = append(suppliers, 
singleSupplier)
}
return c.Status(http.StatusOK).JSON(
responses.SupplierResponse{Status: 
http.StatusOK, Message: "success", Data: 
&fiber.Map{"data": suppliers}},
)
}
5. Models have the Supplier struct information. Supplier has
Id, Name, Address, and Mobile:
models.go
package models
import "go.mongodb.org/mongo-
driver/bson/primitive"
type Supplier struct {
Id      primitive.ObjectID 
`json:"id,omitempty"`
Name    string             
`json:"name,omitempty" validate:"required"`
Address string             
`json:"address,omitempty" validate:"required"`
Mobile  string             
`json:"mobile,omitempty" validate:"required"`
}
6. Setup.go has the configuration for MongoDB client initiation
and getting collection method, which retrieves the data from
the No SQL database:
Setup.go
package configs
import (
“context"
“fmt"
“go.mongodb.org/mongo-driver/mongo"
“go.mongodb.org/mongo-
driver/mongo/options"

“log"
“time"
)
func ConnectDB() *mongo.Client {
client, err := 
mongo.NewClient(options.Client().ApplyURI(EnvMongo
URI()))
fmt.Println(“client")
if err != nil {
log.Fatal(err)
}
ctx, _ := 
context.WithTimeout(context.Background(), 
10*time.Second)
err = client.Connect(ctx)
if err != nil {
log.Fatal(err)
}
err = client.Ping(ctx, nil)
if err != nil {
log.Fatal(err)
}
fmt.Println(“Connected to MongoDB")
return client
}
var DB *mongo.Client = ConnectDB()
func GetCollection(client *mongo.Client, 
collectionName string) *mongo.Collection {
collection := 
client.Database(“golangAPI").Collection(collection
Name)
return collection
}
7. Env.go has the environment information, which will be
loaded from .env (hidden file).
env.go
package configs
import (

"fmt"
"github.com/joho/godotenv"
"log"
"os"
)
func EnvMongoURI() string {
fmt.Println("Getting from Env")
err := godotenv.Load()
if err != nil {
log.Fatal(".env file could not be 
loaded")
}
return os.Getenv("MONGOURI")
}
.env will have the Mongo URI address to be 
connected. This MongoDB datasource is configured 
on atlas Mongo Cloud database. 
https://cloud.mongodb.com/
.env
MONGOURI=mongodb+srv://Cluster72877:RX1mZlt9bUZB@c
luster72877.rx6yjqr.mongodb.net/?
ssl=true&retryWrites=true
8. You can now compile and run the main.go. The command to
create a module REST_api_nosql_db is:
go mod init REST_api_nosql_db
go mod tidy
9. Then, the module is built using the following command:
go build
The output will be as follows:
Figure 4.11: go build execution and running the executable output
The output shows how the REST API server is initialized. The
following are the screenshots for the different routes:

Checking server with GET Route for the server healthcheck.
GET method call is invoked on the Server URL in the
postman. The output response is as follows:
Figure 4.12: Server health check
Now, let us see the Create Supplier route.
Post method on endpoint /supplier to create Supplier. This
call is executed on the postman. The output of the response
is as follows:

Figure 4.13: Create Supplier—POST method call
Delete Supplier method—Delete Route
Delete method on endpoint/supplier to delete Supplier. This
call is executed on the postman. The output of the response
is shown as follows:
Figure 4.14: Delete Supplier—Delete Method
UpdateSupplier—Put Method

Put method on endpoint /supplier to update Supplier. This
call is executed on the postman. The output of the response
is shown as follows:
Figure 4.15: Update Supplier—Put Method
REST API interacting with message queues
In this section, we will look at how to develop a REST API that can
interact with message queues. We will use Gin and Rabbit MQ.
To start with, let us look at the code project structure:

Figure 4.16: Project structure
The code project has three high-level modules—consumer,
producer, and rabbit-mq. The consumer module has sub modules
—environment, handlers, and utils. The producer module has
config, controllers, environment, middlewares, models, routers,

and utils modules. The rabbit-mq module has the configuration
for rabbitmq:
1. Let us look at the code for developing REST API using Gin
and RabbitMQ:
main.go
package main
import (
"fmt"
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"REST_api_mq/producer/config"
"REST_api_mq/producer/utils"
)
func init() {
mode := utils.GetEnvVar("GIN_MODE")
gin.SetMode(mode)
}
func main() {
appGin := config.CreateApp()
addrGin := utils.GetEnvVar("GIN_ADDR")
portGin := utils.GetEnvVar("GIN_PORT")
log.Info().Msgf("App is up at 
http//:%s:%s", addrGin, portGin)
if error := 
appGin.Run(fmt.Sprintf("%s:%s", addrGn, portGin)); 
error != nil {
log.Fatal().Err(error).Msg("Http 
Server setup failed")
}
}
2. Now, let us look at the createApp to see how the routes are
set through routers:
Creating_app.go
package config
import (
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"REST_api_mq/producer/middlewares"

"REST_api_mq/producer/routers"
)
func CreateApp() *gin.Engine {
log.Info().Msg("service starting")
app := gin.New()
app.Use(gin.Recovery())
app.SetTrustedProxies(nil)
log.Info().Msg(" cors, request id, request 
logging middleware added")
app.Use(middlewares.CORSMiddleware(), 
middlewares.RequestID(), 
middlewares.RequestLogger())
log.Info().Msg("routers setup")
routers.SetupRouters(app)
return app
}
3. The Routers package has the routes mapped to methods
that talk to the message queue:
Get   /ping     controllers.ping
Post /publish/example controllers.Example
setup.go
package routers
import (
"github.com/gin-gonic/gin"
"REST_api_mq/producer/controllers"
)
func CreateRouters(engine *gin.Engine) {
version1 := engine.Group("/v1")
{
version1.GET("/ping", 
controllers.Ping)
version1.POST("/publish/example", 
controllers.Example)
}
}
4. The 
controllers 
package 
has 
the 
message 
publisher
configured to publish messages to a message queue.
controllers.go

package controllers
import (
"net/http"
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"REST_api_mq/producer/environment"
"REST_api_mq/producer/models"
"REST_api_mq/producer/utils"
)
func Example(context *gin.Context) {
var msg models.Message
request_id := context.GetString("x-
request-id")
if binderr := 
context.ShouldBindJSON(&msg); binderr != nil {
log.Error().Err(binderr).Str("request_id", 
request_id).
Msg("Error occurred while 
binding request data")
context.JSON(http.StatusUnprocessableEntity, 
gin.H{
"message": 
binderr.Error(),
})
return
}
connectionString := 
utils.GetEnvVar("RMQ_URL")
producer := utils.MessagePublisher{
environment.EXAMPLE_QUEUE,
connectionString,
}
producer.PublishMessage("text/plain", 
[]byte(msg.Message))
context.JSON(http.StatusOK, gin.H{
"response": "Message received from 
REST API",

})
}
5. MessagePublisher is a struct defined in the utils package. It
has a method to publish messages to a queue defined in the
environment:
Publisher.go
package utils
import (
"github.com/rs/zerolog/log"
"github.com/streadway/amqp"
)
type MessagePublisher struct {
Queue            string
ConnectionString string
}
func (x MessagePublisher) OnError(err error, msg 
string) {
if err != nil {
log.Err(err).Msgf("Publishing 
message error '%s' queue. Error message: %s", 
publisher.Queue, msg)
}
}
func (publisher MessagePublisher) 
PublishMessage(contentType string, body []byte) {
conn, error := 
amqp.Dial(publisher.ConnectionString)
publisher.OnError(error, "RabbitMQ not 
connected")
defer conn.Close()
channel, err := conn.Channel()
publisher.OnError(err, "Channel not 
opened")
defer channel.Close()
q, error := channel.QueueDeclare(
publisher.Queue,
false,
false,

false,
false,
nil,
)
publisher.OnError(error, "Queue Not 
declared")
error = channel.Publish(
"",
q.Name,
false,
false,
amqp.Publishing{
ContentType: contentType,
Body:        body,
})
publisher.OnError(error, "message not 
published")
}
6. Now, let us look at the consumer package:
main.go
package main
import (
"REST_api_mq/consumer/environment"
"REST_api_mq/consumer/handlers"
"REST_api_mq/consumer/utils"
)
func main() {
connectionString := 
utils.GetEnvVar("RMQ_URL")
messageQueue := utils.MessageConsumer{
enviornment.EXAMPLE_QUEUE,
connectionString,
handlers.HandleMessaage,
}
forever := make(chan bool)
go messageQueue.Consume()
<-forever
}

7. MessageConsumer is created from the utils package:
Message_consumer.go
package utils
import (
"github.com/rs/zerolog/log"
"github.com/streadway/amqp"
)
type MessageConsumer struct {
Queue            string
ConnectionString string
MsgHandler       func(queue string, msg 
amqp.Delivery, err error)
}
func (consumer MessageConsumer) OnError(errors 
error, msg string) {
if errors != nil {
consumer.MsgHandler(consumer.Queue, 
amqp.Delivery{}, errors)
}
}
func (consumer MessageConsumer) Consume() {
conn, err := 
amqp.Dial(consumer.ConnectionString)
consumer.OnError(err, "Failed to connect 
to RabbitMQ")
defer conn.Close()
channel, err := conn.Channel()
consumer.OnError(err, "Failed to open a 
channel")
defer channel.Close()
q, err := channel.QueueDeclare(
consumer.Queue,
false,
false,
false,
false,
nil,
)

consumer.OnError(err, "Failed to declare a 
queue")
msgs, err := channel.Consume(
q.Name,
"",
true,
false,
false,
false,
nil,
)
consumer.OnError(err, "Failed to register 
a consumer")
forever := make(chan bool)
go func() {
for delivery := range msgs {
consumer.MsgHandler(consumer.Queue, delivery, nil)
}
}()
log.Info().Msgf("Started listening- 
messages from '%s' queue", consumer.Queue)
<-forever
}
8. The environment package has the constants defined for the
environment file, directory, and message queue:
constants.go
package environment
const ENV_FILE = ".env"
const ENV_FILE_DIRECTORY = "."
const EXAMPLE_QUEUE = "message_queue"
9. .env will Rabbit message queue configuration URL and Log
level:
.env
LOG_LEVEL = debug
RMQ_URL = amqp://guest:guest@localhost:5000/
10. You can now compile and run the rabbitmq, producer, and
consumer services in the docker. Docker yaml is in the code

project folder as docker-compose.yaml:
The docker-compose.yaml file is attached below:
version: '3.6'
networks:
  rabbitmq-example:
    driver: bridge
services:
  rabbitmq:
    image: 'rabbitmq:3-management'
    networks:
      - rabbitmq-example
    volumes:
      - ./rabbit-
mq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    ports:
      - "8080:15672"
    healthcheck:
      test: [ "CMD", "rabbitmqctl", "status"]
      interval: 5s
      timeout: 15s
      retries: 5
  producer:
    build: ./producer
    ports:
      - "5050:5050" 
    networks:
      - rabbitmq-example
    depends_on:
      - rabbitmq
    environment: 
      GIN_MODE: "release"
      GIN_HTTPS: "false"
      GIN_ADDR: "0.0.0.0"
      GIN_PORT: "5050"
      LOG_LEVEL: "debug"
      RMQ_URL: "amqp://guest:guest@rabbitmq:5673/"
  consumer:
    build: ./consumer

    networks:
      - rabbitmq-example
    depends_on:
      - rabbitmq
    RESTart: on-failure
    environment: 
      LOG_LEVEL: "debug"
      RMQ_URL: "amqp://guest:guest@rabbitmq:5673/"
The yaml file has three services configured—rabbitmq,
producer, and consumer. Dependencies are configured at
each service level. The consumer service depends on
rabbitmq service. Similarly producer service depends on
rabbitmq service.
The command to run the docker is:
docker-compose up
The output will be as follows:

Figure 4.17: How the REST API server is initialized
The following are the screenshots for the different routes:
The /publish endpoint is invoked using the POST method in
the postman. The output of the response is as follows:

Figure 4.18: Publish endpoint—Post method
In the above screenshot, REST API with the POST method is used
to send the message to the producer configured to listen to the
message queue. The consumer consumes the message and sends
the response back.
Go best practices
These are some of the Go Lang best practices:
Always mention the datatype of the variables which you are
creating.
Do not have an import or variable which you are not going
to use.
Always follow coding conventions and guidelines.
Errors always need to be handled.
Reuse code by having a utils package.
A switch can be used for handling different cases.
Always organize the code into packages, structs, and
functions.
Go modules can be used to build components and modules.
Go proxy can be used to have availability and immutability.

You can use the channel with a timeout interval.
You can use context instead of channel.
Always login with the line number.
You can use panic, defer, and recover to handle complex
errors.
Conclusion
In this chapter, we have covered topics related to building REST
API using Go Lang. Examples were presented to demonstrate how
REST API can interact with relational databases, No SQL
databases, and message queues using Go Lang.
In the next chapter, the readers will be presented with examples
and solutions to build web applications using Gin and Beego. Web
applications will consume REST API and communicate to
databases through the API. These web applications will be built to
be scalable and performable.
Points to remember
REST API can be built using Go Lang using Fiber and Gin
packages.
Relational databases can be queried using object-relational
mapping tools like GORM, and GORM has drivers for
SQLite.
REST API interacting with No SQL databases can be
developed using Fiber and MongoDB. The Mongo driver
package can be used for querying the Mongo database in
the Go language.
REST API interacting with message queues can be
developed using Rabbit MQ and Fiber.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers, Tech
happenings around the world, New Release and Sessions with the
Authors:

https://discord.bpbonline.com

CHAPTER 5
Go Web Apps
Introduction
In this chapter, the readers will be presented with examples and
solutions to build web applications using Gin and Beego. Web
applications will consume REST API and communicate to databases
through the API. These web applications will be built to be scalable and
performable.
Let us see the technologies that help build a Go web application:
Figure 5.1: Technologies—Go Web Apps
Structure

The chapter covers the following topics:
Web app in Go
Web app using Gin
Web app using Beego
Web app and REST API in Go
Objectives
By the end of this chapter, you will be able to build web applications in
the Go language. You can use different frameworks like Gin and Beego.
Readers will be presented with examples of building web applications
with REST API in the Go language.
Developing web app in Go
In Go language, you can have web applications built using html,
net/http package, and web forms. We are building here an employee
management system. The application will have the capability to
create, update, select, and delete customers. In this example, we will
use MySQL and Go MySQL driver package—go-sql-driver/mysql.
Web-based applications can have forms using webforms. .tmpl files
are used as the view, and routes are managed in Golang files. .tmpl
files are loaded using the text/template package. Let us look at the
examples for a web application in Go:
employee_mgmt.go
package main
import (
"fmt"
"log"
"net/http"
"text/template"
)
var template_html = 
template.Must(template.ParseGlob("templates/*"))
func Home(writer http.ResponseWriter, request 
*http.Request) {

var employees []Employee
employees = GetEmployees()
log.Println(employees)
template_html.ExecuteTemplate(writer, "Home", 
employees)
}
func Create(writer http.ResponseWriter, request 
*http.Request) {
template_html.ExecuteTemplate(writer, "Create", 
nil)
}
func Insert(writer http.ResponseWriter, request 
*http.Request) {
var employee Employee
employee.EmployeeName = 
request.FormValue("name")
employee.SSN = request.FormValue("ssn")
employee.Designation = 
request.FormValue("designation")
employee.Department = 
request.FormValue("department")
InsertEmployee(employee)
var employees []Employee
employees = GetEmployees()
template_html.ExecuteTemplate(writer, "Home", 
employees)
}
func Alter(writer http.ResponseWriter, request 
*http.Request) {
var employee Employee
var employeeId int
var employeeIdStr string

employeeIdStr = request.FormValue("id")
fmt.Sscanf(employeeIdStr, "%d", &employeeId)
employee.EmployeeId = employeeId
employee.EmployeeName = 
request.FormValue("name")
employee.SSN = request.FormValue("ssn")
employee.Designation = 
request.FormValue("designation")
employee.Department = 
request.FormValue("department")
UpdateEmployee(employee)
var employees []Employee
employees = GetEmployees()
template_html.ExecuteTemplate(writer, "Home", 
employees)
}
func Update(writer http.ResponseWriter, request 
*http.Request) {
var employeeId int
var employeeIdStr string
employeeIdStr = request.FormValue("id")
fmt.Sscanf(employeeIdStr, "%d", &employeeId)
var employee Employee
employee = GetEmployeeById(employeeId)
template_html.ExecuteTemplate(writer, "Update", 
employee)
}
func Delete(writer http.ResponseWriter, request 
*http.Request) {
var employeeId int
var employeeIdStr string
employeeIdStr = request.FormValue("id")

fmt.Sscanf(employeeIdStr, "%d", &employeeId)
var employee Employee
employee = GetEmployeeById(employeeId)
DeleteEmployee(employee)
var employees []Employee
employees = GetEmployees()
template_html.ExecuteTemplate(writer, "Home", 
employees)
}
func View(writer http.ResponseWriter, request 
*http.Request) {
var employeeId int
var employeeIdStr string
employeeIdStr = request.FormValue("id")
fmt.Sscanf(employeeIdStr, "%d", &employeeId)
var employee Employee
employee = GetEmployeeById(employeeId)
fmt.Println(employee)
var employees []Employee
employees = []Employee{employee}
template_html.ExecuteTemplate(writer, "View", 
employees)
}
func main() {
log.Println("Server started on: 
http://localhost:8000")
http.HandleFunc("/", Home)
http.HandleFunc("/alter", Alter)
http.HandleFunc("/create", Create)
http.HandleFunc("/update", Update)
http.HandleFunc("/view", View)

http.HandleFunc(“/insert", Insert)
http.HandleFunc(“/delete", Delete)
http.ListenAndServe(":8000", nil)
}
To compile and run the above golang program, ensure that you have
the latest golang executable. You can download it from
https://golang.org/dl/. Based on the operating system you use, you
can download the appropriate executable.
You can verify the installation by running the following command:
go version
The following is the directory structure of the Go web app based on
web forms. Let us look at the. Directory structure and the files in the
directory:
Figure 5.2: Go web app directory structure
Now, let us look at the backend code for updating the MySQL
database. The input comes from the webforms, which are submitted
through forms. The form actions are mapped to different database
operations. You can see the database querying and updating the
following code:
emp_mgmt_database_operations.go
Getting database connection

To get the database connection, follow this code:
type Employee struct {
EmployeeId   int
EmployeeName string
SSN          string
Designation  string
Department   string
}
func GetConnection() (database *sql.DB) {
databaseDriver := "mysql"
databaseUser := "newuser"
databasePass := "newuser"
databaseName := "empMgmt"
database, error := sql.Open(databaseDriver, 
databaseUser+":"+databasePass+"@/"+databaseName)
if error != nil {
panic(error.Error())
}
return database
}
Retrieving employee from the given database Id
Follow this code to retrieve the employee from the given database Id:
func GetEmployeeById(employeeId int) Employee {
var database *sql.DB
database = GetConnection()
var error error
var rows *sql.Rows
rows, error = database.Query("SELECT * FROM 
Employee WHERE EmployeeId=?", employeeId)
if error != nil {

panic(error.Error())
}
var employee Employee
employee = Employee{}
for rows.Next() {
var employeeId int
var employeeName string
var SSN string
var Designation string
var Department string
error = rows.Scan(&employeeId, 
&employeeName, &SSN, &Designation, &Department)
if error != nil {
panic(error.Error())
}
employee.EmployeeId = employeeId
employee.EmployeeName = employeeName
employee.SSN = SSN
employee.Designation = Designation
employee.Department = Department
}
defer database.Close()
return employee
}
Retrieving all employees from the database
This is how you can retrieve all employees from the database:
func GetEmployees() []Employee {
var database *sql.DB
database = GetConnection()

var error error
var rows *sql.Rows
rows, error = database.Query("SELECT * FROM 
Employee ORDER BY Employeeid DESC")
if error != nil {
panic(error.Error())
}
var employee Employee
employee = Employee{}
var employees []Employee
employees = []Employee{}
for rows.Next() {
var employeeId int
var employeeName string
var ssn string
var designation string
var department string
error = rows.Scan(&employeeId, 
&employeeName, &ssn, &designation, &department)
if error != nil {
panic(error.Error())
}
employee.EmployeeId = employeeId
employee.EmployeeName = employeeName
employee.SSN = ssn
employee.Designation = designation
employee.Department = department
employees = append(employees, employee)
}
defer database.Close()

return employees
}
Adding employee to the database
You can add employee to the database by following this code:
func InsertEmployee(employee Employee) {
var database *sql.DB
database = GetConnection()
var error error
var insert *sql.Stmt
insert, error = database.Prepare("INSERT INTO 
EMPLOYEE(EmployeeName,SSN,Designation,Department) 
VALUES(?,?,?,?)")
if error != nil {
panic(error.Error())
}
insert.Exec(employee.EmployeeName, employee.SSN, 
employee.Designation, employee.Department)
defer database.Close()
}
Updating the employee in the database
To update the employee in the database, follow this code:
func UpdateEmployee(employee Employee) {
var database *sql.DB
database = GetConnection()
var error error
var update *sql.Stmt
update, error = database.Prepare("UPDATE EMPLOYEE 
SET EmployeeName=?, SSN=?,DESIGNATION=?,DEPARTMENT=? WHERE 
EmployeeId=?")
if error != nil {

panic(error.Error())
}
update.Exec(employee.EmployeeName, employee.SSN, 
employee.Designation, employee.Department, 
employee.EmployeeId)
defer database.Close()
}
Deleting the employee from the database
You can delete the employee from the database by following this code:
func DeleteEmployee(employee Employee) {
var database *sql.DB
database = GetConnection()
var error error
var delete *sql.Stmt
delete, error = database.Prepare("DELETE FROM 
Employee WHERE Employeeid=?")
if error != nil {
panic(error.Error())
}
delete.Exec(employee.EmployeeId)
defer database.Close()
}
The output will be based on the version that you install. It will be as
below:
bhagvanarch@Bhagvans-MacBook-Air code % go version
go version go1.22.1 darwin/arm64
bhagvanarch@Bhagvans-MacBook-Air code %
To execute the code above, we need a database like MySQL. You need
to set up a database on MySQL. It can be downloaded from
https://dev.mysql.com/downloads/mysql/ based on the operating
system. After installing, you can start the MySQL service.

1. Database user newuser needs to be created with newuser
password.
2. You can import the below SQL after creating a database by name
empMgmt:
CREATE DATABASE `empMgmt` /*!40100 DEFAULT CHARACTER 
SET utf8mb4 COLLATE utf8mb4_general_ci */;
CREATE TABLE `EMPLOYEE` (
  `EMPLOYEEID` int(11) NOT NULL AUTO_INCREMENT,
  `EMPLOYEENAME` varchar(45) DEFAULT NULL,
  `SSN` varchar(45) DEFAULT NULL,
  `DESIGNATION` varchar(45) DEFAULT NULL,
  `DEPARTMENT` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`EMPLOYEEID`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT 
CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
3. After the database is setup, you can add your style sheets and
titles in .tmpl files. Let us first look at Home.tmpl:
{{ define "Home" }}
  {{ template "Header" }}
    {{ template "Menu"  }}
    <h2> Employees </h2>
    <table border="1">
      <thead>
      <tr>
        <td>Employee ID</td>
        <td>Employee Name</td>
        <td>SSN</td>
<td>Designation</td>
<td>Department</td>
        <td>View</td>
        <td>Update</td>
        <td>Delete</td>
      </tr>
       </thead>
       <tbody>
    {{ range . }}
      <tr>

        <td>{{ .EmployeeId }}</td>
        <td> {{ .EmployeeName }} </td>
        <td>{{ .SSN }} </td>
<td>{{ .Designation }} </td>
<td>{{ .Department }} </td>
        <td><a href="/view?id={{ .EmployeeId }} 
">View</a></td>
        <td><a href="/update?id={{ .EmployeeId }} 
">Update</a></td>
        <td><a href="/delete?id={{ .EmployeeId }} " 
onclick="return confirm('Are you sure you want to 
delete ?');">Delete</a><td>
      </tr>
    {{ end }}
       </tbody>
    </table>
  {{ template "Footer" }}
{{ end }}
4. After verifying the installation of the Go compiler, you can
compile and run the code using the following commands:
go mod init webforms
go mod tidy
The output will be as follows:
Figure 5.3: Go web app start output
5. You can access the web application at http://localhost:8000/.
The following figure shows the landing page:

Figure 5.4: Landing page for Employee Management
6. You can access the create employee form by clicking on the link
above named—create employee as shown in the following figure:
Figure 5.5: Create Employee web form
7. The above-created form is based on the Create.tmpl. The create
template file is shown as follows:
Create.tmpl
{{ define "Create" }}
  {{ template "Header" }}
    {{ template "Menu"  }}
<br>
    <h1>Create Employee</h1>
  <br>
  <br>
  <form method="post" action="/insert">

    Employee Name: <input type="text" name="name" 
placeholder="name" autofocus/>
    <br>
    <br>
    SSN: <input type="text" name="ssn" 
placeholder="ssn"/>
    <br>
    <br>
    Designation: <input type="text" name="designation" 
placeholder="designation"/>
    <br>
    <br>
    Department: <input type="text" name="department" 
placeholder="department"/>
    <br>
    <br>
    <input type="submit" value="Create Employee"/>
   </form>
{{ template "Footer" }}
{{ end }}
After the creation of employees, you can see the output on the
home screen as follows:
Figure 5.6: List of Employees Table
8. The above view form is based on Home.tmpl. You can update the
employee’s name, ssn, designation, or department by clicking
on the update link as shown in the following figure:

Figure 5.7: Update Employee Form
9. The Update form shown above is based on Update.tmpl. The
update template file is shown as follows:
Update.tmpl
{{ define "Update" }}
  {{ template "Header" }}
    {{ template “Menu"  }}
<br>
<h1>Update Employee</h1>
    <br>
    <br>
  <form method="post" action="/alter">
    <input type="hidden" name="id" value="{{ 
.EmployeeId }}" />
    Employee Name: <input type="text" name="name" 
placeholder="name" value="{{ .EmployeeName }}" 
autofocus>
    <br>
    <br>
    SSN: <input type="text" name="ssn" value="{{ .SSN 
}}" placeholder="ssn"/>
    <br>
    <br>
    <br>
    <br>
    Designation: <input type="text" name="designation" 
value="{{ .Designation }}" placeholder="designation"/>

    <br>
    <br>
    Department: <input type="text" name="department" 
value="{{ .Department }}" placeholder="department"/>
    <br>
    <br>
    <input type="submit" value="Update Employee"/>
   </form>
{{ template "Footer" }}
{{ end }}
10. You can delete the employee’s record by clicking on the delete
link from the home screen, as shown in the following figure:
Figure 5.8: Delete Employee—Confirm dialog
11. You can see the updated list of employee records in the following
figure:
Figure 5.9: Updated list of employees
Note: In most software projects, web-based applications are popular. Now-a-
days progressive web applications are being built to have web and mobile

web applications. These web applications talk to the backend relational
database like MySQL.
Developing web app using Gin and REST API
In this section, we will look at building web applications using the Gin
web framework. REST API can be developed using Gin and Vue.js,
which can be consumed and bound to REST services built on Gin.
1. First, let us look at the REST API routes:
Action
Http
method
URL route
Description
GetEvent
GET
/api/events/:index
Retrieving an event
AddEventToList
POST
/api/events/
Adding an Event to
the list
GetEventList
GET
/api/events
Retrieving the list of
events
Table 5.1: API routes
Now, let us look at the code to implement various REST API
routes:
main.go
package main
import (
"github.com/gin-contrib/static"
"github.com/gin-gonic/gin"
"net/http"
"strconv"
)
var gevents []string
func Events(c *gin.Context) {
c.JSON(http.StatusOK, gin.H{"list": gevents})
}
func GetEventList(c *gin.Context) {
errormessage := "Index out of range"
indexstring := c.Param("index")
if index, err := strconv.Atoi(indexstring); err 
== nil && index < len(gevents) {
c.JSON(http.StatusOK, gin.H{"item": 
gevents[index]})
} else {

if err != nil {
errormessage = "Number 
expected: " + indexstring
}
c.JSON(http.StatusBadRequest, 
gin.H{“error": errormessage})
}
}
func AddEventToList(c *gin.Context) {
item := c.PostForm("item")
gevents = append(gevents, item)
c.String(http.StatusCreated, 
c.FullPath()+"/"+strconv.Itoa(len(gevents)-1))
}
func main() {
gevents = append(gevents, "Go For a Walk : 8 
A.M.")
r := gin.Default()
r.Use(static.Serve("/", 
static.LocalFile("./eventsmgr/dist", false)))
r.GET("/api/events", Events)
r.GET("/api/events/:index", GetEventList)
r.POST("/api/events", AddEventToList)
r.Run()
}
2. In the following figure, you can see the directory structure for the
web application based on Gin:

Figure 5.10: Web App Directory structure
Now, let us look at the Vue.js consuming the REST API:
Action
Http
Method
URL Route
React
Method
Description
GetEvent
GET
/api/events/:index
Retrieving
an event
AddEventToList
POST
/api/events/
sendItem()
Sending an
event to
the list
GetEventList
GET
/api/events
getList()
Retrieving
the list of
events.
Table 5.2: URL routes mapped to actions
Let us look at the template which renders the web form. The code
to be used for the form is:
App.vue
<template>
    <div id="app">
        <h1>Event List</h1>
        <div id="widget-container"></div>
        <form @submit.prevent="sendItem()">
            <input
                type="text"
                size="50"

                v-model="geventitem"
                placeholder="Enter new item"
            />
            <input type="submit" value="Submit" />
        </form>
        <ul>
            <li v-for="item in geventlist" v-
bind:key="item">{{ item }}</li>
        </ul>
        <div>{{ message }}</div>
    </div>
</template>
<script>
import axios from "axios";
const appData = {
    geventlist: ["Evening Party : 6 p.m."],
    token: "",
    message: "",
};
export default {
    name: "App",
    data() {
        return appData;
    },
    methods: {
        getList: getList,
        sendItem: sendItem,
    },
    mounted: function () {
        getList();
    },
};
function getList() {
    axios.get("/api/events").then((res) => {
        appData.geventlist = res.data.list;
    });
}
async function sendItem() {
    const params = new URLSearchParams();
    params.append("item", this.geventitem);
    await axios
        .post("/api/events", params)

        .then(function () {
            getList();
        })
        .catch(function (error) {
            appData.geventlist = [error.message];
        });
}
</script>
<style>
#app {
    font-family: Avenir, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-align: center;
    color: #2c3e50;
    margin-top: 60px;
}
</style>
3. Now, let us look at the JavaScript code which renders the Vue.js
app:
main.js
import Vue from 'vue'
import App from './App.vue'
Vue.config.productionTip = false
new Vue({
  render: h => h(App),
}).$mount('#app')
4. index.html is the html page for displaying the app. main.js is
the JavaScript file which creates the html for the application
based Vue.js.
index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" 
content="IE=edge">

    <meta name="viewport" content="width=device-
width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.title %>
</title>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but <%= 
htmlWebpackPlugin.options.title %> doesn't work 
properly without JavaScript enabled. Please enable it 
to continue.</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
5. You can now compile and run the Vue.js application. The
package.json has the required modules to be installed. It is
shown below:
{
  "name": "eventsmgr",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
  "dependencies": {
    "@okta/okta-auth-js": "^4.0.3",
    "@okta/okta-signin-widget": "^4.5.2",
    "@okta/okta-vue": "^2.1.1",
    "axios": "^0.21.0",
    "core-js": "^3.6.5",
    "vue": "^2.6.11"
  },

  "devDependencies": {
    "@vue/cli-plugin-babel": "~4.5.0",
    "@vue/cli-plugin-eslint": "~4.5.0",
    "@vue/cli-service": "~4.5.0",
    "babel-eslint": "^10.1.0",
    "eslint": "^6.7.2",
    "eslint-plugin-vue": "^6.2.2",
    "vue-template-compiler": "^2.6.11"
  },
  "_id": "todo-vue@0.1.0",
  "readme": "ERROR: No README data found!"
}
6. The commands are shown below:
cd eventsmgr
npm clean-install
npm install
npm run build
cd..
go run main.go
The output will be as follows:

Figure 5.11: Vue.js web app start output
In the node_modules, you can see the list of modules installed.

Figure 5.12: Node_modules
The following screenshots show how the application renders, and how
the users can interact with the application.
You can access the Vue.js app at http://localhost:8080/

Figure 5.13: Event Creation Web Form
Adding an Event to the Event List through the Vue.js app is
displayed as follows:
Figure 5.14: Updated Event List
Viewing the updated Event List is shown as follows:
Figure 5.15: Updated Event List after adding two events
Viewing All Events after the addition of events is shown as
follows:

Figure 5.16: Updated Event List after adding 3 events
Developing Web App using Beego
In Go, you can use Beego web framework to develop web applications.
Beego is an opensource framework that has application tools, ORM
framework, and other packages. ORM framework helps in cutting down
the ordeal of developing the relational schema and mapping it to
object classes and names of the attributes. Beego is used to build
REST APIs, which can be integrated with opensource JavaScript
frontend frameworks. We can build Beego web application using the
Beego and SQLite database. Beego framework helps in developing
web apps at affordable cost.
1. First, let us look at the code for Beego web application:
main.go
package main
import (
“github.com/astaxie/beego"
“github.com/astaxie/beego/orm"
_ "github.com/mattn/go-sqlite3"
models "go_web_app_beego/models"
_ "go_web_app_beego/routers"
)
func init() {
orm.RegisterDriver("sqlite", orm.DRSqlite)
orm.RegisterDataBase("default", "sqlite3", 
"database/products.db")
orm.RegisterModel(new(models.Product))
}
func main() {
beego.Run()
}
The following screenshot shows the Beego Web app directory
structure:

Figure 5.17: Web App Directory structure
The above file main.go has the code for initialization of ORM and
registration of the model. The Beego framework is started in the
main method.
2. Now, let us look at the file Models.go.
Models.go
package models
type Product struct {
Id       int    `form:"-"`
Name     string `form:"name,text,name:" 
valid:"MinSize(5);MaxSize(20)"`
Category string 
`form:"category,text,category:"`
Image    string `form:"image,text,image:"`
}
func (a *Product) TableName() string {
return "products"
}
Models.go has the code for tableName definition and the object
class specification.
3. Further, let us look at the database script to create a table in the
SQLite database:

Database
CREATE TABLE "products" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
    "name" varchar(200) NOT NULL,
    "category" varchar(100),
    "image" varchar(400) DEFAULT NULL,
    "notes" text,
    UNIQUE (name)
);
4. The following code has routers configured that map to the Beego
web application controller and its methods:
Routes.go
package routers
import (
"github.com/astaxie/beego"
"go_web_app_beego/controllers"
)
func init() {
beego.Router("/", 
&controllers.MainController{})
beego.Router("/webapp/:id([0-9]+)", 
&controllers.MainController{}, "get:BeegoWebApp")
beego.Router("/manage/add", 
&controllers.ManageController{}, "get,post:Add")
beego.Router("/manage/view", 
&controllers.ManageController{}, "get:View")
beego.Router("/manage/home", 
&controllers.ManageController{}, "*:Home")
beego.Router("/manage/delete/:id([0-9]+)", 
&controllers.ManageController{}, "*:Delete")
beego.Router("/manage/update/:id([0-9]+)", 
&controllers.ManageController{}, "*:Update")
}
The following table shows the routes/paths mentioned in
Routers.go:
Action
Controller
Method
Http
Method
URL Route
Retrieve
get,post:Add
GET
/manage/add
Get
get:View
GET
/manage/view

Get All
Home
GET
/manage/home
Delete
Delete
DELETE
/manage/delete/:id([0-9]+
Update
Update
PUT
"/manage/update/:id([0-
9]+
Table 5.3: Actions mapped to URL routes
5. Now, let us look at the file manage.go.
manage.go
manage.go has various sections related to different pages. Let us
start with the Homepage:
Home Page
package controllers
import (
"fmt"
"github.com/astaxie/beego"
"github.com/astaxie/beego/orm"
"github.com/astaxie/beego/validation"
"go_web_app_beego/models"
"strconv"
)
type ManageController struct {
beego.Controller
}
func (manage *ManageController) Home() {
manage.Layout = "basic-layout.tpl"
manage.LayoutSections = make(map[string]string)
manage.LayoutSections["Header"] = "header.tpl"
manage.LayoutSections["Footer"] = "footer.tpl"
manage.TplName = "manage/home.tpl"
}
Now, let us see the Delete Page section in manage.go:
Delete Page
func (manage *ManageController) Delete() {
manage.Layout = "basic-layout.tpl"
manage.LayoutSections = make(map[string]string)
manage.LayoutSections["Header"] = "header.tpl"
manage.LayoutSections["Footer"] = "footer.tpl"
manage.TplName = "manage/home.tpl"
productId, _ := 
strconv.Atoi(manage.Ctx.Input.Param(":id"))

ormGorm := orm.NewOrm()
ormGorm.Using("default")
product := models.Product{}
if exist := 
ormGorm.QueryTable(product.TableName()).Filter("Id", 
productId).Exist(); exist {
if num, err := 
ormGorm.Delete(&models.Product{Id: productId}); err == 
nil {
beego.Info("Record Deleted. ", 
num)
} else {
beego.Error("Record couldn't be 
deleted. Reason: ", err)
}
} else {
beego.Info("Record Doesn't exist.")
}
}
Now, let us see the Update Page Controller section in manage.go:
Update Web Page – Controller
func (manage *ManageController) Update() {
ormGorm := orm.NewOrm()
ormGorm.Using("default")
flash := beego.NewFlash()
if productId, err := 
strconv.Atoi(manage.Ctx.Input.Param(":id")); err == nil 
{
product := models.Product{Id: 
productId}
if ormGorm.Read(&product) == nil {
product.Category = "Retail"
product.Image = "Bag.jpg"
if num, err := 
ormGorm.Update(&product); err == nil {
flash.Notice("Record 
Was Updated.")
flash.Store(&manage.Controller)
beego.Info("Record Was 
Updated. ", num)

}
} else {
flash.Notice("Record Was NOT 
Updated.")
flash.Store(&manage.Controller)
beego.Error("Couldn't find 
product matching id: ", productId)
}
} else {
flash.Notice("Record Was NOT Updated.")
flash.Store(&manage.Controller)
beego.Error("Couldn't convert id from a 
string to a number. ", err)
}
manage.Redirect("/manage/view", 302)
}
Now, let us see the View Web Page Controller section in
manage.go:
View Web Page - Controller
func (manage *ManageController) View() {
manage.Layout = "basic-layout.tpl"
manage.LayoutSections = make(map[string]string)
manage.LayoutSections["Header"] = "header.tpl"
manage.LayoutSections["Footer"] = "footer.tpl"
manage.TplName = "manage/view.tpl"
flash := 
beego.ReadFromRequest(&manage.Controller)
if ok := flash.Data["error"]; ok != "" {
manage.Data["errors"] = ok
}
if ok := flash.Data["notice"]; ok != "" {
manage.Data["notices"] = ok
}
ormGorm := orm.NewOrm()
ormGorm.Using("default")
var products []*models.Product
num, err := 
ormGorm.QueryTable("products").All(&products)
if err != orm.ErrNoRows && num > 0 {
manage.Data["records"] = products
}

}
Now, let us see the Add Page Controller section in manage.go:
Add Web page - Controller
func (manage *ManageController) Add() {
manage.Data["Form"] = &models.Product{}
manage.Layout = "basic-layout.tpl"
manage.LayoutSections = make(map[string]string)
manage.LayoutSections["Header"] = "header.tpl"
manage.LayoutSections["Footer"] = "footer.tpl"
manage.TplName = "manage/add.tpl"
flash := 
beego.ReadFromRequest(&manage.Controller)
if ok := flash.Data["error"]; ok != "" {
manage.Data["flash"] = ok
}
ormGorm := orm.NewOrm()
ormGorm.Using("default")
product := models.Product{}
if err := manage.ParseForm(&product); err != 
nil {
beego.Error("Couldn't parse the form. 
Reason: ", err)
} else {
manage.Data["Products"] = product
valid := validation.Validation{}
isValid, _ := valid.Valid(product)
if manage.Ctx.Input.Method() == "POST" 
{
if !isValid {
manage.Data["Errors"] = 
valid.ErrorsMap
beego.Error("Form 
didn't validate.")
} else {
searchProduct := 
models.Product{Name: product.Name}
beego.Debug("Product 
name supplied:", product.Name)
err = 
ormGorm.Read(&searchProduct)

beego.Debug("Err:", 
err)
flash := 
beego.NewFlash()
if err == orm.ErrNoRows 
|| err == orm.ErrMissPK {
beego.Debug("No 
product found matching details supplied. Attempting to 
insert product: ", product)
id, error := 
ormGorm.Insert(&product)
if error == nil 
{
msg := 
fmt.Sprintf("Product inserted with id:", id)
beego.Debug(msg)
flash.Notice(msg)
flash.Store(&manage.Controller)
} else {
msg := 
fmt.Sprintf("Couldn't insert new product. Reason: ", 
err)
beego.Debug(msg)
flash.Error(msg)
flash.Store(&manage.Controller)
}
} else {
beego.Debug("Product found matching details supplied. 
Cannot insert")
}
}
}
}
}

6. Now, let us look at the Home.tpl web page.
Home.tpl
<div class="container">
  <div class="row">
    <div class="hero-text">
     <h1>Portal Home</h1>
     <p class="lead">This portal is used for managing 
products</p>
   </div>
 </div>
</div>
</div>
You can create this template in HTML in the folder managed
below views. HTML template has the forms and the details of the
table required for rendering in html. It is shown in the following
figure:

Figure 5.18: Location of HTML templates
7. You can now compile and run the main.go. The command to
create a module go_web_app_beego is:
    go mod init go_web_app_beego
    go mod tidy
8. Then, the module is built using this command:
go build

9. The output will be as follows:
Figure 5.19: Beego Web App Build and Starting output
10. You can access the Beego web app at http://localhost:8080/.
The following figure shows the landing page for adding a product:
Figure 5.20: Add A Product Web Form
a. The Products List page is shown as follows:

Figure 5.21: List of Products Web Page
b. The Product Details page is shown in the following figure:
Figure 5.22: Product Details Web Form

c. The Products List page shows the added products in the
previous steps, as shown in the following figure:
Figure 5.23: Updated List of Products Web Page
Conclusion
In this chapter, we have covered topics related to Go Web Applications
using Web Forms, Gin, and Beego. Examples were presented to
demonstrate where web applications can be built using REST API using
Vue.js, WebForms, and Beego Framework.
In the next chapter, we will learn how to build RPC apps using Go.
These apps are built using Google gRPC. We will also learn about
protocol buffers. Further, gRPC clients will be developed to talk to the
gRPC server. Also, Unit tests will be written to test the clients and
server code.
Points to remember
Web applications can be built using Go, web forms, and
database-specific packages in Go.
REST API can be developed using Gin. ORM-based backend can
be developed using GORM. Web applications can be built by
having Vue.js views talking to REST API using Gin.
Beego Framework has capabilities to have REST APIs, ORM, and
developing web application framework.

CHAPTER 6
RPC Apps with gRPC
Introduction
In this chapter, the readers will learn how to build RPC apps using
Go. These apps are built using Google gRPC. Readers will know
about Protocol Buffers. gRPC clients will be developed to talk to
the gRPC server. Unit tests will be written to test the clients and
server code:
Figure 6.1: Go RPC Apps – Different End Points

Structure
This chapter covers the following topics:
RPC apps in Go Lang
Protocol buffers
gRPC clients
gRPC server
Objectives
By the end of this chapter, you can build command line and REST
API-based apps using gRPC with the help of examples.
RPC apps in Go Lang
In the Go language, gRPC is a popular Google framework for
processing remote procedure calls. It can help in connecting
distributed services and has been adopted by Netflix, IBM, Cisco,
and others. These are some features of gRPC:
This framework has the capability to handle load balancing,
health 
monitoring, 
authentication 
and 
tracing 
using
plugins.
You can create a gRPC service using protocol buffers and a
binary serialization library. gRPC provides tools to generate
clients and server stubs for different technology stacks.
It can provide authentication using HTTP/2-based transport
plugins. HTTP/2 brings significant enhancements to web
communication by allowing multiplexing and improving
resource utilization. Multiplexing lets multiple requests and
responses be sent simultaneously over a single connection,
avoiding the head-of-line blocking issue in HTTP/1.1. This
results in faster page load times and more efficient use of
network resources. Additionally, HTTP/2 supports header
compression, reducing overhead and making data transfer
more efficient. These features collectively enhance the

browsing experience by making interactions smoother and
more responsive, leading to better overall performance.
Many products are built using gRPC as its messages are 1.5
times smaller in size than JSON messages. Reduced
bandwidth and fast processing speed is the reason gRPC is
popular.
gRPC supports Java, Python, Ruby, and Go Technology
stacks.
Processing speeds come down with gRPC API compared to
JSON API for messaging and communication.
You can access the gRPC repo at
https://github.com/grpc/grpc-go. Let us look at the
helloworld server code in the examples/helloworld folder.
Have a look at the server code:
main.go
package main
import (
"context" "flag" "fmt" "log" “net" 
"google.golang.org/grpc"hgrpc "hellogrpc/hellogrpc"
)
var (
port = flag.Int("port", 50051, "The server 
port")
)
type server struct {
hgrpc.UnimplementedGreeterServer
}
func (s *server) SayHello(ctx context.Context, in 
*hgrpc.HelloRequest) (*hgrpc.HelloReply, error) {
log.Printf("Received: %v", in.GetName())
return &hgrpc.HelloReply{Message: "Hello " + 
in.GetName()}, nil
}

func main() {
flag.Parse()
lis, err := 
net.Listen("tcp", fmt.Sprintf(":%d", *port))
if err != nil {
log.Fatalf("failed to listen: %v", err)}
s := grpc.NewServer()
hgrpc.RegisterGreeterServer(s, &server{})
log.Printf("server listening at %v", lis.Addr())
if err := s.Serve(lis); err != nil 
log.Fatalf("failed to serve: %v", err)
}}
Now, let us look at the client implementation:
main.go
package main
import ( "context" "flag" "log" “time" 
"google.golang.org/grpc" 
"google.golang.org/grpc/credentials/insecure" pb 
"helloworld/helloworld"
)
const ( defaultName = "world"
)
var (
addr = flag.String("addr", "localhost:50051", 
"the address to connect to"
name = 
flag.String("name", defaultName, "Name to greet")
)
func main() {
flag.Parse()
conn, err := 
grpc.Dial(*addr, 
grpc.WithTransportCredentials(insecure.NewCredentials(
)))
if err != nil {
log.Fatalf("did not connect: %v", err)
}
defer conn.Close()

c := hgrpc.NewGreeterClient(conn)
ctx, cancel := 
context.WithTimeout(context.Background(), time.Second)
defer cancel()
r, err := c.SayHello(ctx, 
&hgrpc.HelloRequest{Name: *name})
if err != nil {
log.Fatalf("could not greet: %v", err)
}
log.Printf("Greeting: %s", r.GetMessage())
}
The helloworld proto code is in the helloworld folder. We will
go through protocol buffers. in the next chapter. To compile and
run the above Go language program, ensure that you have the
latest Golang executable.
1. You can download it from https://golang.org/dl/. Based on
the operating system you use, you can download the
appropriate executable.
2. You can verify the installation by running the following
command:
go version
3. After verifying the installation of the Go compiler, you can
compile and run the using the below commands. The
commands are shown as follows:
go mod init helloworld
go mod tidy
4. The output will be as shown in the following figure from the
server side:

Figure 6.2: helloworld program output
5. Let us look at the client side and how the gRPC calls are
made. This is the output:
(base) apples-MacBook-Air:helloworld 
bhagvan.kommadi$ go run greetgRPC_client/main.go
2023/05/14 18:03:26 Greeting: Hello world
Note: Remote procedure calls-based software was very popular in the
80s. IDL and CORBA successfully handled RPC messages across the
distributed nodes in a wide area network. gRPC is different from RPC
in architectural style and function calls. Started by Google in 2015, it
has become popular in the last 5 years.
Protocol buffers
In this section, we will look at Protobuf, equivalent to IDL for
gRPC. Protobuf consists of function contracts and is a protofile
where data is persisted. Implementing gRPC with Protobuf
involves several steps:
1. First, define your service in a .proto file detailing the
methods and messages that will be used.
2. Compile the .proto file using the Protocol Buffers compiler
(protoc), which will generate client and server code in your
chosen programming language.
3. Implement the server by writing the service logic to handle
incoming requests. After that, create the client to send
requests to the server.

4. Establish a connection between the client and server and
test to ensure communication is working as expected. This
setup provides efficient and scalable communication
between services.
Let us do this in code. As a first step, a service can be defined in
.proto file. Then for the second step, server and client code can
be created by using the protobuf compilation tool. gRPC API can
be used to create a go gRPC client and server.
We are going to build gRPC based server and clients to handle
product catalog and updates. Products will be initialized by the
server into the catalog saved products. Add Product & Search
Product requests will be sent using productspec messages. The
product will have attributes name, image, and category name.
catalog.proto
syntax = "proto3";
option go_package = "gobook/grpc/catalog";
option java_multiple_files = true;
option java_package = "go.book.catalog";
option java_outer_classname = "CatalogProto";
package catalog;
service Catalog {
  rpc GetProduct(ProductSpec) returns (Product) {}
  rpc ProductList(Category) returns (stream Product) 
{}
  rpc RecordProduct(stream ProductSpec) returns 
(Product) {}
  rpc ProductChat(stream ProductSpecNote) returns 
(stream ProductSpecNote) {}
}
message Product {
  string name = 1;

  string image = 2;
}
message Category {
   string name = 1;
}
message ProductSpec {
   string name = 1;
}
message ProductSpecNote {
 Category cat = 1;
 ProductSpec spec = 2;
}
In the service, proto messages are defined with their properties
and field order numbers.
Now, let us look at the commands to generate protobuffers code
using protoc-gen-go. The output will be as shown in the
following figure:
Figure 6.3: Install command output
The protoc tool generates the serializers for Product and other
message types in the catalog as follows:
catalog.pb.go
// Code Snippet generated by protoc-gen-go. DO NOT 
EDIT.

type Product struct {
state         protoimpl.MessageState
sizeCache     
protoimpl.SizeCache
unknownFields 
protoimpl.UnknownFields
Name    string 
`protobuf:"bytes,1,opt,name=name,proto3" 
json:"name,omitempty"`
Image   string 
`protobuf:"bytes,2,opt,name=image,proto3" 
json:"image,omitempty"` Catname string 
`protobuf:"bytes,3,opt,name=catname,proto3" 
json:"catname,omitempty"`
}
func (x *Product) Reset() {
*x = Product{}
if 
protoimpl.UnsafeEnabled {
mi := &file_catalog_catalog_proto_msgTypes[0]
ms := 
protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
ms.StoreMessageInfo(mi)}}
func (x *Product) String() string {
return protoimpl.X.MessageStringOf(x)
}
func (*Product) ProtoMessage() {}
func (x *Product) ProtoReflect() protoreflect.Message 
{
mi := &file_catalog_catalog_proto_msgTypes[0]
if protoimpl.UnsafeEnabled && x != nil {
ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
if ms.LoadMessageInfo() == nil {
ms.StoreMessageInfo(mi) }
return ms
}
return mi.MessageOf(x)
}

// Deprecated: Use Product.ProtoReflect.Descriptor 
instead.
func (*Product) Descriptor() ([]byte, []int) {
return file_catalog_catalog_proto_rawDescGZIP(), 
[]int{0}
}
func (x *Product) GetName() string {------}
func (x *Product) GetImage() string { -------}
func (x *Product) GetCatname() string { ------}
Now let us look at Category struct code and methods:
Category struct and methods
type Category struct {
state         protoimpl.MessageState
sizeCache     protoimpl.SizeCache
unknownFields protoimpl.UnknownFields
Name string `protobuf:"bytes,1,opt,name=name,proto3" 
json:"name,omitempty"`
}
func (x *Category) Reset() {
-----
}
func (x *Category) String() string {
-------
}
func (*Category) ProtoMessage() {}
func (x *Category) ProtoReflect() protoreflect.Message 
{
----

}
return mi.MessageOf(x)
}
func (*Category) Descriptor() ([]byte, []int) {
-------
}
func (x *Category) GetName() string {
--------
}
ProductSpec struct and methods
type ProductSpec struct {
state         protoimpl.MessageState
sizeCache     protoimpl.SizeCache
unknownFields protoimpl.UnknownFields
Name string `protobuf:"bytes,1,opt,name=name,proto3" 
json:"name,omitempty"`
}
func (x *ProductSpec) Reset() {
-------------------
}
func (x *ProductSpec) String() string {
-------------------
}
func (*ProductSpec) ProtoMessage() {}
func (x *ProductSpec) ProtoReflect() 
protoreflect.Message {
--------------
}

func (*ProductSpec) Descriptor() ([]byte, []int) {
------------
}
func (x *ProductSpec) GetName() string {
--------
}
Now, let us look at ProductSpecNote struct code and methods:
ProductSpecNote struct and methods
type ProductSpecNote struct {
state         protoimpl.MessageState
sizeCache     protoimpl.SizeCache
unknownFields protoimpl.UnknownFields
Cat  *Category    
`protobuf:"bytes,1,opt,name=cat,proto3" 
json:"cat,omitempty"`
Spec *ProductSpec 
`protobuf:"bytes,2,opt,name=spec,proto3" 
json:"spec,omitempty"`
}
func (x *ProductSpecNote) Reset() {
-----------
}
func (x *ProductSpecNote) String() string {
--------
}
func (*ProductSpecNote) ProtoMessage() {}
func (x *ProductSpecNote) ProtoReflect() 
protoreflect.Message {
-----

}
func (*ProductSpecNote) Descriptor() ([]byte, []int) {
------
}
func (x *ProductSpecNote) GetCat() *Category {
----
}
func (x *ProductSpecNote) GetSpec() *ProductSpec {
------
}
Proto messages are defined with the properties and accessors to
the properties. Product, Category, ProductSpec, and
ProductSpecNote messages are implemented with the properties
and accessors; serializers are defined for these message objects.
Now, let us look at the client and server stubs. The protoc tool
generates the client and server stubs code as follows:
catalog_grpc.pb.go
// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
package catalog
import (
context "context"
grpc "google.golang.org/grpc"
codes "google.golang.org/grpc/codes"
status "google.golang.org/grpc/status"
)
const _ = grpc.SupportPackageIsVersion7
type CatalogClient interface {
GetProduct(ctx context.Context, in *ProductSpec, opts 
...grpc.CallOption) (*Product, error)

ProductList(ctx context.Context, in *Category, opts 
...grpc.CallOption) (Catalog_ProductListClient, error)
RecordProduct(ctx context.Context, opts 
...grpc.CallOption) (Catalog_RecordProductClient, 
error)
ProductChat(ctx context.Context, opts 
...grpc.CallOption) (Catalog_ProductChatClient, error)
}
type catalogClient struct {
cc grpc.ClientConnInterface
}
func NewCatalogClient(cc grpc.ClientConnInterface) 
CatalogClient {
return &catalogClient{cc}
}
func (c *catalogClient) GetProduct(ctx 
context.Context, in *ProductSpec, opts 
...grpc.CallOption) (*Product, error) {
out := new(Product)
err := c.cc.Invoke(ctx, "/catalog.Catalog/GetProduct", 
in, out, opts...)
if err != nil {
return nil, err
}
return out, nil
}
func (c *catalogClient) ProductList(ctx 
context.Context, in *Category, opts 
...grpc.CallOption) (Catalog_ProductListClient, error) 
{

stream, err := c.cc.NewStream(ctx, 
&Catalog_ServiceDesc.Streams[0], 
"/catalog.Catalog/ProductList", opts...)
if err != nil {
return nil, err
}
x := &catalogProductListClient{stream}
if err := x.ClientStream.SendMsg(in); err != nil {
return nil, err
}
if err := x.ClientStream.CloseSend(); err != nil {
return nil, err
}
return x, nil
}
type Catalog_ProductListClient interface {
Recv() (*Product, error)
grpc.ClientStream
}
type catalogProductListClient struct {
grpc.ClientStream
}
//Interface methods implemented
……..
type Catalog_RecordProductClient interface {
Send(*ProductSpec) error
CloseAndRecv() (*Product, error)
grpc.ClientStream

}
type catalogRecordProductClient struct {
grpc.ClientStream
}
//Interface methods implemented
……..
type Catalog_ProductChatClient interface {
Send(*ProductSpecNote) error
Recv() (*ProductSpecNote, error)
grpc.ClientStream
}
type catalogProductChatClient struct {
grpc.ClientStream
}
//Interface methods implemented
……..
type CatalogServer interface {
GetProduct(context.Context, *ProductSpec) (*Product, 
error)
ProductList(*Category, Catalog_ProductListServer) 
error
RecordProduct(Catalog_RecordProductServer) error
ProductChat(Catalog_ProductChatServer) error
mustEmbedUnimplementedCatalogServer()
}
//Interface methods implemented
……..
type UnsafeCatalogServer interface {

mustEmbedUnimplementedCatalogServer()
}
func RegisterCatalogServer(s grpc.ServiceRegistrar, 
srv CatalogServer) {
s.RegisterService(&Catalog_ServiceDesc, srv)
}
//Interface methods implemented
……..
type Catalog_ProductListServer interface {
Send(*Product) error
grpc.ServerStream
}
type catalogProductListServer struct {
grpc.ServerStream
}
//Interface methods implemented
……..
type Catalog_RecordProductServer interface {
SendAndClose(*Product) error
Recv() (*ProductSpec, error)
grpc.ServerStream
}
type catalogRecordProductServer struct {
grpc.ServerStream
}
//Interface methods implemented
……..
type Catalog_ProductChatServer interface {

Send(*ProductSpecNote) error
Recv() (*ProductSpecNote, error)
grpc.ServerStream
}
type catalogProductChatServer struct {
grpc.ServerStream
}
//Interface methods implemented
……..
gRPC clients
gRPC clients exchange protobuf (protocol buffer-based)
messages with the gRPC servers. They are based on Google
protocol for serialization and deserialization. Client libraries can
be generated using the protoc tool. Memory schema is loaded
by the gRPC services based on the Proto file configuration
(catalog.proto). In memory schema, messages can be
serialized and deserialized based on the binary messages.
Streaming messages can be handled by gRPC Server and clients.
The direction of streaming can be in inward and outward
directions. Catalog client has RecordProduct and ProductChat
methods which talk to the gRPC server.
1. First, let us look at the code for gRPC clients:
client.go
func printProduct(client cat.CatalogClient, point 
*cat.ProductSpec) {
log.Printf("Getting feature for product (%d, %d)", 
point.Name)
ctx, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
defer cancel()
product, error := client.GetProduct(ctx, point)

if error != nil {
log.Fatalf("client.GetProduct failed: %v", err)
}
log.Println("Client: Received from server - " + 
"product name " + product.Name + " ,Image " + 
product.Image)
}
Now, 
let 
us 
look 
at 
the 
PrintProducts 
method
implementation:
PrintProducts method
func printProducts(client cat.CatalogClient, rect 
*cat.Category) {
log.Printf("Client: Looking for products on the 
server within %v", rect)
ctx, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
defer cancel()
stream, err := client.ProductList(ctx, rect)
if err != nil {
log.Fatalf("client.ProductList failed: %v", err)
}
for {
product, error := stream.Recv()
if error == io.EOF {
break
}
if error != nil {
log.Fatalf("client.ProductList failed: %v", err)
}
log.Printf("Product: name: %q, product:(%v)", 
product.GetName(),
product.GetImage())
}
}
Now, 
let 
us 
look 
at 
the 
implementation 
of 
the
RecordProduct method:

RecordProduct method
func RecordProduct(client cat.CatalogClient) {
timeInNanos := time.Now().UnixNano()
newSource := rand.NewSource(timeInNanos)
ran := rand.New(newSource)
ranInt := ran.Int31n(100)
pointCount := int(ranInt) + 2
var points []*cat.Product
for i := 0; i < pointCount; i++ {
points = append(points, randomProduct(r))
}
log.Printf("client: catalog has %d products 
created.", len(points))
context, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
defer cancel()
stream, error := client.RecordProduct(context)
if error != nil {
log.Fatalf("client.RecordProduct failed: %v", 
error)
}
for _, pointer := range points {
log.Printf("client sending product" + 
pointer.Name)
if error := stream.Send(&cat.ProductSpec{Name: 
pointer.Name}); error != nil {
log.Fatalf("client.RecordProduct: stream.Send(%v) 
failed: %v", pointer, error)
}
}
reply, error := stream.CloseAndRecv()
if error != nil {
log.Fatalf("client.RecordPoduct failed: %v", err)
}
log.Printf("Produuct summary: %v", reply)
}
Now, let us look at ProductChat method implementation:

ProductChat method
func ProductChat(client cat.CatalogClient) {
notes := []*cat.ProductSpecNote{
{Cat: &cat.Category{Name: "Athletics"},
Spec: &cat.ProductSpec{Name: "pump"}},
}
context, cancel := 
context.WithTimeout(context.Background(), 
10*time.Second)
defer cancel()
stream, error := client.ProductChat(context)
if error != nil {
log.Fatalf("client.RouteChat failed: %v", err)
}
waitch := make(chan struct{})
go func() {
for {
in, error := stream.Recv()
if error == io.EOF {
close(waitch)
return
}
if error != nil {
log.Fatalf("client.ProductChat failed: %v", err)
}
log.Printf("Client Got message %s at product(%d)", 
in.Cat.Name, in.Spec.Name)
}
}()
for _, noter := range notes {
if error := stream.Send(noter); error != nil {
log.Fatalf("client.ProductChat: stream.Send(%v) 
failed: %v", noter, error)
}
}
stream.CloseSend()
<-waitch
}

Now, let us look at randomProduct method implementation:
randomProduct method
func randomProduct(r *rand.Rand) *cat.Product {
name := "Product" + strconv.Itoa(r.Intn(180))
img := name + ".jpg"
categ := "General"
return &cat.Product{Name: name, Image: img, 
Catname: categ}
}
Now, let us look at the main method implementation:
main method
func main() {
flag.Parse()
var opts []grpc.DialOption
opts = append(opts, 
grpc.WithTransportCredentials(insecure.NewCredenti
als()))
conn, error := grpc.Dial(*serverAddr, opts...)
if error != nil {
log.Fatalf("fail to dial: %v", error)
}
defer conn.Close()
client := cat.NewCatalogClient(conn)
printProduct(client, &cat.ProductSpec{Name: 
"cycle"})
printProduct(client, &cat.ProductSpec{Name: 
"pump"})
printProducts(client, &cat.Category{Name: 
"Electronics"})
RecordProduct(client)
ProductChat(client)
}
2. Random products are created with their spec and sent as
requests to add the product to the catalog. CatalogClient
is created first and passed on to the interface methods.
The command to create a module proto is:

//inside proto directory
    go mod init golang-db
    go mod tidy
3. Then, the module is built using the command:
go build
4. We need a server to connect to from the client. Let us see
how to build the gRPC server before executing the client.
gRPC server
The gRPC server is implemented using the stubs created in
catalog.grpc.pb.go. The service methods are implemented in
the server.
server.go
type catalogServer struct {
cat.UnimplementedCatalogServer
savedProducts []*cat.Product 
mu               sync.Mutex 
productSpecNotes map[string][]*cat.ProductSpecNote
}
func (s *catalogServer) GetProduct(ctx 
context.Context, point *cat.ProductSpec) 
(*cat.Product, error) {
for _, feature := range s.savedProducts {
if feature.Name == point.Name {
return feature, nil
}
}
return &cat.Product{Name: point.Name, Image: 
point.Name + ".jpg"}, nil
}
func (s *catalogServer) ProductList(rect 
*cat.Category, stream cat.Catalog_ProductListServer) 
error {

for _, feature := range s.savedProducts {
if feature.Catname == rect.Name {
if error := stream.Send(feature); error != nil {
return err
}
}
}
return nil
}
func (s *catalogServer) RecordProduct(stream 
cat.Catalog_RecordProductServer) error {
var pointCount, featureCount int32
for {
point, 
err := stream.Recv()
if err == io.EOF {
return stream.SendAndClose(&cat.Product{
Name:    "Completed",
Image:   ".jpg",
Catname: "Messages",
})
}
if error != nil {
return error
}
pointCount++
for _, features := range s.savedProducts {
log.Printf("server: recorded " + point.Name)
if features.Name == point.Name featureCount++
}
}
}
}
Now, let us look at the ProductChat method implementation:
Product Chat method
func (s *catalogServer) ProductChat(stream 
cat.Catalog_ProductChatServer) error {
for {
in, error := stream.Recv()
if error == 
io.EOF {
return nil
}
if error != 
nil {

return error
}
keyin := serializeProductSpec(in)
s.mu.Lock()
s.productSpecNotes[keyin] = 
append(s.productSpecNotes[keyin], in)
rn := make([]*cat.ProductSpecNote, 
len(s.productSpecNotes[keyin]))
copy(rn, s.productSpecNotes[keyin])
s.mu.Unlock()
for _, note := range rn {
if error := stream.Send(note); err != nil {
return error
}
}
}
}
Now, let us look at the loadProductSpec method
implementation:
loadProductSpecs method
func (s *catalogServer) loadProductSpecs(filePath 
string) {
var data []byte
if filePath != "" {
var err error
data, err = os.ReadFile(filePath)
if error != nil {
log.Fatalf("Failed to load default features: %v", 
error)
}
} else {
data = exampleData
}

s.savedProducts = make([]*cat.Product, 0)
if err := json.Unmarshal(data, &s.savedProducts); 
error != nil {
log.Fatalf("Failed to load default features: %v", 
error)
}
}
Now, let us look at the implementation of the
serializeProductSpec method:
serializeProductSpec method
func serializeProductSpec(point *cat.ProductSpecNote) 
string {
return fmt.Sprintf("%d", point.Spec.Name)
}
func serialize(point *cat.Product) string {
return fmt.Sprintf("%d %d", point.Name, point.Image)
}
Now, let us look at the newServer method implementation:
newServer method
func newServer() *catalogServer {
s := &catalogServer{productSpecNotes: make(map[string]
[]*cat.ProductSpecNote)}
s.loadProductSpecs(*jsonDBFile)
return s
}
Now, let us look at the main method implementation:
Main method
func main() {
flag.Parse()

lis, err := net.Listen("tcp", 
fmt.Sprintf("localhost:%d", *port))
if err != nil {
log.Fatalf("failed to listen: %v", err)
}
var opts []grpc.ServerOption
grpcInstServer := grpc.NewServer(opts...)
cat.RegisterCatalogServer(grpcInstServer, newServer())
grpcInstServer.Serve(lis)
}
The example data is initialized below:
var exampleData = []byte(`[{"name": "cycle", "image" : 
"cycle.jpg", "catname" : "Athletics"}, {"name": 
"pump", "image" : "pump.jpg","catname" : "Athletics"},  
{"name": "Product3", "image" : 
"product3.jpg","catname" : "Electronics"}]`)
The CatalogServer is instantiated and registered with the gRPC
registry as a Catalog server. When the new server is instantiated,
the products are loaded into the catalog with their category.
gRPC catalog server has implementations for getProduct,
ProductList, RecordProduct, and Product Chat methods. It also
has the loadProductSpec method to load the catalog products.
Recording of the product requests to add to the catalog happens
through the Record Product. ProductChat streams the
information requested.
You can now compile and run the gRPCclient.go. and
gRPCserver.go. Let us start with the server with the command
as follows:
go run gRPCserver/gRPCserver.go
The output will be as follows:

Figure 6.4: Server output
In the output, you can see the recording of the product requests.
These requests come from the client. After the server is
launched, you can run the client.
You can now compile and run the client.go. The command is as
shown below:
go run server/client.go
The output will be as shown in the following figure:
Figure 6.5: Client output
The output shows the productSpec requests sent from the client
to the server. The message of finishing the stream requests and
lookup for a product is shown in the output from the client side.
Conclusion
In this chapter, we have covered topics related to gRPC
applications, protocol buffers, clients, and servers. Examples

were presented to demonstrate how gRPC servers and clients
can be built using Go Lang.
In the next chapter, the readers will know how to build a real-life
CRM application. CRM application will be a web application that
will have the capability to maintain customer data and run
campaigns for segments or a list of customers by geography or
vertical.
Points to remember
Here are some points to remember from this chapter:
Remote procedure call-based applications can be built
using gRPC frameworks.
Go language can be used to build Remote procedures and
call-based applications.
Protocol buffers are used to generate messages, and
server-side and client-side stubs to be used by the gRPC
server and client.
gRPC services are defined in .proto file.
gRPC services are implemented in gRPC clients and servers
after generating stubs using the protocol tool.
gRPC server listens to clients sending requests, and the
server processes the remote procedure calls to reply back
with a response.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and Sessions
with the Authors:
https://discord.bpbonline.com

CHAPTER 7
Go Real Life Applications—
CRM
Introduction
In this chapter, the reader will learn how to build a real-life
application for customer relationship management
(CRM). CRM application will be a web application that will
have the capability to maintain customer data and run
campaigns for segments or a list of customers by geography
or vertical. Now, let us look at what is covered in CRM
application:

Figure 7.1: CRM Application components
Structure
The chapter covers the following topics:
CRM application in Go
Unit Testing the REST API
Objectives
By the end of this chapter, we will build a customer
relationship management application using the Go language.
The Beego framework will be used to build the REST API and
web application. The readers will be presented with
examples of unit testing Rest API in the Go language.
CRM application in Go
We will be building a CRM application using Go. This
application will consist of the following modules:

Customer management
Lead generation
Customer segmentation
Loyalty management
Merchant management
Campaign management
CRM application consists of creating customers and
managing customer data. Campaigns will be created and
targeted for publishing to the customers. The leads are
gathered as a list of customers or segments of customers.
Customer segments are created by attributes like age,
gender, salary range, or geography. When the customer likes
a product and buys the product, a transaction is logged in
the back office of a retail store or an e-commerce company.
The transactions are processed to check if the lead has been
realized and turned into revenue. This process helps in
assessing the lead conversion. Transactions can also be
checked for aberration to identify the customer’s behavior.
The other important feature is the loyalty points, which have
different levels like gold, silver, and bronze levels. The
customer buys the products, and loyalty points are stored in
the system to track the customer's progress. Offers are
targeted based on loyalty to improve the customer's
purchasing rate. The discounted offers are shared based on
where the customer is in terms of the loyalty points.
Companies bombastically frequently announce loyal
customers and convert leads from the CRM portal.
Let us start creating the REST API for this system.
REST API
Beego framework excels in the Go ecosystem due to its rich
feature set and ease of use. It combines the power of a

robust MVC architecture with tools for rapid development,
like built-in ORM, powerful caching mechanisms, and RESTful
support, reducing boilerplate code and speeding up the
development process. Moreover, Beego's automatic routing
and strong community support make it a favorite for building
scalable web applications. Its performance optimization and
flexibility in integrating with other Go libraries set it apart
from many other frameworks.
We will be using the Beego web framework to develop the
CRM web application and REST API. Beego framework is an
open-source framework that has application tools, an object
relationship mapping framework, and other packages. ORM
framework helps cut down the ordeal of developing the CRM
relational schema and mapping it to object classes and
names of the attributes. Beego is used to build CRM REST
APIs, which can be integrated with open-source JavaScript
frontend frameworks. We can build CRM Beego web
applications using the Beego and SQLite database. Beego
framework helps in developing web apps at an affordable
cost.
First, let us look at the code for the Beego REST API. The
code is as follows:
main.go
package main
import (
"fmt"
"github.com/gorilla/handlers"
"go_beego_rest_api/pkg/db"
handler "go_beego_rest_api/pkg/handlers"
"log"
"net/http"

"github.com/gorilla/mux"
)
func main() {
r := mux.NewRouter()
DB := db.InitializeDB()
r.HandleFunc("/customers", 
handler.GetCustomers(DB)).Methods("GET")
r.HandleFunc("/create", 
handler.CreateCustomer(DB)).Methods("POST")
r.HandleFunc("/update", 
handler.UpdateCustomer(DB)).Methods("PUT")
r.HandleFunc("/delete", 
handler.DeleteCustomer(DB)).Methods("DELETE")
fmt.Println("Server at 8080")
log.Fatal(http.ListenAndServe(":8080", 
handlers.CORS()(r)))
}
The following figure shows the Beego Web app directory
structure:
Figure 7.2: Code structure

The above main.go has the code for initializing the ORM and
registering the model. Beego is started in the main method.
Now, let us look at the database code:
db.go
package db
import (
"fmt"
"github.com/jinzhu/gorm"
_ 
"github.com/jinzhu/gorm/dialects/postgres"
)
func InitializeDB() *gorm.DB {
db, err := gorm.Open("postgres", 
"user=newuser password=newuser dbname=crm 
sslmode=disable")
if err != nil {
fmt.Println(err)
} else {
fmt.Println("DB connected!")
}
return db
}
Handler.go has the code for the tableName definition and the
object class specification. Now, let us look at the handler
code:
handler.go
package handler
import (

"encoding/json"
"fmt"
"net/http"
"github.com/jinzhu/gorm"
)
type CustomerBody struct {
Name string `json"name"`
}
type Customer struct {
Id      int    `json:"id"`
Name    string `json:"name"`
Mobile  string `json:"mobile"`
Address string `json:"address"`
}
func GetCustomers(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var customers []Customer
_ = 
db.Table("customer").Select("id, 
name,mobile,address").Scan(&customers)
json.NewEncoder(w).Encode(customers)
}
}

func CreateCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var RequestBody CustomerBody
json.NewDecoder(r.Body).Decode(&RequestBody)
_ = 
db.Table("customer").Create(&RequestBody)
fmt.Println("Created Customer")
json.NewEncoder(w).Encode(RequestBody)
}
}
func UpdateCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var PutBody Customer
json.NewDecoder(r.Body).Decode(&PutBody)
_ = 
db.Table("customer").Where("id=?", 
PutBody.Id).Update("name", 
PutBody.Name).Scan(&PutBody)
fmt.Printf("Updated Customer with 
id %d\n", PutBody.Id)

json.NewEncoder(w).Encode(PutBody)
}
}
func DeleteCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var DeleteBody Customer
json.NewDecoder(r.Body).Decode(&DeleteBody)
_ = 
db.Table("customer").Delete(&DeleteBody)
fmt.Printf("Deleted Customer with 
id %d\n", DeleteBody.Id)
json.NewEncoder(w).Encode(DeleteBody)
}
}
Now, let us look at the database script to create a table in
the Postgres CRM database. You can use the following
commands to create a Postgres database CRM and users:
psql -h localhost -d postgres
----
ALTER USER postgres PASSWORD 'postgres';
CREATE USER newuser with PASSWORD 'newuser' 
CREATEDB;
select * from users;

\du
\l
\q
-----
createdb crm
psql -h localhost -d postgres
\c crm
CREATE TABLE "customer" (
    "id"  SERIAL,
    "name" varchar(200) NOT NULL,
    "mobile" varchar(100),
    "address" varchar(400) DEFAULT NULL,
    "notes" text,
    UNIQUE (name)
);
\dt
\du
alter role newuser superuser;
create user newuser with password 'newuser';
grant all privileges on database crm to newuser;
alter role newuser superuser;
Database
CREATE TABLE "customer" (
    "id" serial,
    "name" varchar(200) NOT NULL,

    "mobile" varchar(100),
    "address" varchar(400) DEFAULT NULL,
    "notes" text,
    UNIQUE (name)
);
create user newuser with password 'newuser';
grant all privileges on database crm to newuser;
Now, let us look at the routes configured in index.go.
The following table shows the routes/paths mentioned in the
index.go:
Action
Controller
method
Http
method
URL route
Description
Create
Add
POST
/create
Create a New
Customer
Read
getAll
GET
/customers
Retrieve list of
customers
Delete
Delete
DELETE
/delete
Delete a
Customer
Update
Update
PUT
/update
Update a
Customer
Table 7.1: HTTP Methods—REST API methods
You can run the beego REST API server by using the following
commands:
go mod init go_beego_rest_api
go mod tidy
The output of the rest of the API server execution is shown as
follows:

Figure 7.3: REST API Server execution output
Unit testing the REST API
In this section, we will investigate how Postman is used for
unit testing the REST API. You can perform the unit testing of
the API using postman. Now, let us look at the Create
Customer API.
Create Customer
Figure 7.4: Create Customer API call
Postman can be used to test the REST API. In Figure 7.3, the
customer is created with a post-method-based REST API call.

Now, let us look at the Get Customers API.
Get Customers
Figure 7.5: Get Customers API Call
Figure 7.5 shows all customers by retrieving the results from
a GET method REST API call. Now, let us look at the Update
Customer REST API code.
Update Customer

Figure 7.6: Update Customer API call
Figure 7.6 shows how Postman is used for updating the
customer. PUT method-based REST API is used to update the
customer in the CRM portal. Now, let us look at the Delete
Customer API code.
Delete Customer

Figure 7.7: Delete REST API call
DELETE Method-based REST API is called using Postman for
deleting a customer, as shown in Figure 7.7. Now, let us look
at the Get Customers After Delete API call.
Get Customers After Delete
Figure 7.8: GET Customers REST API call after delete
Figure 7.8 shows the list of customers after update and
delete operations.
Web app
Now, let us look at the web application. The web application
is built using the React framework.
You can build it using these steps:
1. Create an index.html
2. Create an index.js

3. Create an example.js
4. Create a home.jsx page
5. Create a AddCustomer.jsx page
6. Create an AddCustomer.css
7. Create a Logout page.
First, let us look at the index.html webpage
implementation:
Index.html—Webpage
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-
width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#000000">
  <link rel="manifest" 
href="%PUBLIC_URL%/manifest.json">
  <link rel="shortcut icon" 
href="%PUBLIC_URL%/favicon.ico">
  <title>CRM Portal</title>
</head>
<body>
  <div id="root"></div>
</body>
</html>
Now, let us look at index.js. This JavaScript file renders the
application by loading the root element defined in

example.js:
index.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './example';
ReactDOM.render(
<App />,
document.getElementById('root')
);
example.js
import React from "react";
import {
  BrowserRouter as Router,
  Switch,
  Route,
  Link
} from "react-router-dom";
import AddCustomer from './AddCustomer';
import Logout from './Logout';
import Home from './Home';
export default function BasicExample() {
  return (
    <Router>
      <div>
        <ul>

          <li>
            <Link to="/home">Home</Link>
          </li>
          <li>
            <Link to="/addCustomer">Add 
Customer</Link>
          </li>
          <li>
            <Link to="/logout">Logout</Link>
          </li>
        </ul>
        <hr />
        {}
        <Switch>
          <Route exact path="/home">
            <Home />
          </Route>
          <Route path="/addCustomer">
            <AddCustomer />
          </Route>
          <Route path="/logout">
            <Logout />
          </Route>
        </Switch>
      </div>
    </Router>

  );
}
In the above file, different routes are defined for Home,
AddCustomer, and Logout. Now, let us look at the Home page:
Home.jsx
import { Link } from "react-router-dom";
import React from "react";
class Home extends React.Component {  
    constructor(props) {
    super(props);
    this.state = {
      jokes: []
    };
    this.serverRequest = 
this.serverRequest.bind(this);
  }
  serverRequest() {
  
  
  
fetch('http://localhost:8080/customers').then(respo
nse => {
        return response.json();
      }).then(json => {
  console.log("json",json)
          this.setState({ jokes: json});
      });
  }
  componentDidMount() {

    this.serverRequest();
  }
  render() {
    return (
      <div className="container">
        <br />        
        <h2>CRM</h2>
<br />
        <p>List of Customers</p>
        <div className="row">
          <div className="container">
  <table border="1">
       <tr>
   <th>Name</th><th> Mobile</th> 
<th>Address</th>
    </tr>
            {this.state.jokes.map((item, index) => 
(
<tr border="1">
<td border="1">
{item.name} </td>
<td border="1">
{item.mobile}</td>
<td border="1"> 
{item.address}</td>
</tr>
                          ))}

<br />
</table>
          </div>
<a href="/add">Add New 
Customer</a>
        </div>
      </div>
    );
  }
}
export default Home;
The AddCustomer page has the form to create a customer.
This page talks about the REST API for the creation of a
customer:
AddCustomer.jsx  
import { useState } from "react";
import React from "react"
import "./AddCustomer.css";
function AddCustomer() {  
  const [name, setName] = useState("");
  const [mobile, setMobile] = useState("");
  const [address, setAddress] = useState("");
  const [message, setMessage] = useState("");
    let handleSubmit = async (e) => {
    e.preventDefault();
    try {

      let res = await 
fetch("http://localhost:8080/create", {
        method: "POST",
        body: JSON.stringify({
          name: name,
          mobile: mobile,
          address: address
        }),
      });
      let resJson = await res.json();
      if (res.status === 200) {
        setName("");
        setAddress("");
        setMessage("User created successfully");
      } else {
        setMessage("Some error occured");
      }
    } catch (err) {
      console.log(err);
    }
  };
    return (
      <div className="container">
        <br /> 
        <div className="row">
          <div className="container">

  <form onSubmit={handleSubmit}>
        <div class="form-group">
          <label for="name">Customer name</label>
          <input value={name}
          placeholder="Name"
          onChange={(e) => setName(e.target.value)} 
class="form-control" tabindex="1" />
        </div>
                <div class="form-group">
          <label for="mobile">Customer Mobile：
</label>
          <input value={mobile}
          placeholder="Mobile"
          onChange={(e) => 
setMobile(e.target.value)} class="form-control" 
tabindex="2" />
        </div>
                <div class="form-group">
          <label for="address">Address：</label>
          <input value={address}
          placeholder="Address"
          onChange={(e) => 
setAddress(e.target.value)} class="form-control" 
tabindex="3" />
        </div>
                <button>Add Customer</button>

        <div className="message">{message ? <p>
{message}</p> : null}</div>
      </form>
      </div>
            </div>
            </div>
    );
} 
export default AddCustomer;
The addCustomer page has the CSS defined as
AddCustomer.css:
AddCustomer.css
.AddCustomer {
  display: flex;
  justify-content: center;
  margin-top: 5rem;
}
input {
  display: block;
  width: 20rem;
  height: 2rem;
  padding: 0.5rem;
  font-size: 1.1em;
  font-weight: 500;
  margin-bottom: 2rem;
}

button {
  border: none;
  padding: 1rem;
  width: 21.2rem;
  font-size: 1.2em;
  border-radius: 0.2rem;
  cursor: pointer;
}
button:hover {
  background-color: #c5c5c5;
}
.message {
  font-size: 1.2em;
  text-align: center;
  color: #36a936;
}
Logout.jsx
import React from "react"; 
class Logout extends React.Component {
  constructor(props) {
    super(props);
    this.logout = this.logout.bind(this);
  }
    logout() {
    localStorage.removeItem("id_token");

    localStorage.removeItem("access_token");
    localStorage.removeItem("profile");
    //location.reload();
  }
    render() {
    return (
    <div>
      <h1>Logout</h1>  
        <span className="pull-right">
          <a onClick={this.logout}>Log out</a>
        </span>
    </div>
  );
 }
};
  export default Logout;
You can now compile and run the react application with the
following command:
    npm install
    npm start
You can access the react web app at
http://localhost:3000/.
The following figure shows the web application:

Figure 7.9: Customers List
Figure 7.9 shows the screenshot of all customers loaded by
the REST API for the command get all customers. Now, let us
look at the AddNewCustomer page:

Figure 7.10: Add New Customer page
Figure 7.10 shows the form for adding new customers to the
CRM portal. Now let us look at the output for the customer’s
list call:

Figure 7.11: List of Customers page
After adding a new customer, the user can return to the CRM
portal and see the list of customers. Now, let us look at the
message shown at the bottom of the page:

Figure 7.12: User message at the bottom of the page
After the customer is created, a message on the page shows
the successful result of creating a user. This message helps
the user be cognizant of the result because of the action
submitted.
Conclusion
In this chapter, we have covered topics related to building
CRM applications using Go Lang. CRM application is built
using Beego Rest API and React framework. CRM application
is built using Beego framework-based REST API interacting
with SQLite database. REST API can be developed using
Beego framework. Beego Framework has the capabilities of
REST APIs, ORM, and developing web application
frameworks. Postman can be used for unit testing the REST

API to create, update, delete, and get all customers. The web
application can be built using the React framework with html
pages interacting with Beego framework-based REST API.
In the next chapter, readers will learn how to build
concurrent applications using Go. The readers will know how
to use Go routines, channels, and concurrency using Go. The
reader will understand concurrency and parallelism
principles.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and
Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 8
Go Concurrent Apps
Introduction
In this chapter, readers will learn how to build concurrent
applications using Go, as well as how to use go routines,
channels, and concurrency. They will also understand the
principles of concurrency and parallelism. Now, let us look at
the Go Lang principles and concurrent apps:

Figure 8.1: Go concurrent apps
Structure
The chapter covers the following topics:
Concurrency and parallelism principles
Goroutines
Channels
Concurrent apps in Go
Objectives
By the end of the chapter, the reader will learn to build
concurrent applications in the Go language. They will also be
presented with various examples showing the go routines
and how to implement concurrency. The reader will learn
concurrency and parallelism principles and real-life examples
where concurrency is important. The reader will see the

difference between concurrency and parallelism. We will see
some examples in Go and implementations of concurrency
principles.
Concurrency and parallelism principles
Recapping from the second chapter, Concurrency differs
from parallelism in that concurrent tasks need to end at the
same time and start at the same time. On the other hand,
single-threaded tasks get executed one by one, like code
statements. Now, let us look at concurrency in real life,
where multiple tasks are concurrent in nature:
Figure 8.2: Concurrent tasks
Let us first look at a layman’s example. On the road, there
will be vehicles going on parallel roads in different directions.
If there are two lanes on the road, you can have vehicles
concurrently move in the same direction on multiple lanes.
Figure 8.3 illustrates the same:

Figure 8.3: Layman example
In your daily life, you can see the above happening on the
road while traveling. The same applies to multilane airports
or train stations with multiple platforms, as explained in the
following figure:
Figure 8.4: Daily life example—Concurrency
Like the road and lanes example, there are instances where
concurrency and parallelism principles are applied.
Concurrent apps have tasks executed simultaneously. These

tasks can be related to app loading, app rendering, and
media rendering and loading.
In the Go language, concurrency features are available out of
the box. First, let us look at concurrency vs. parallelism. Now,
let us look at an example where parallel tasks are executed
instantly and see the difference between concurrency and
parallelism:
Figure 8.5: Parallelism vs. concurrency
You can see this happening in the browser when you click on
the website and download an executable simultaneously.
Rendering, downloading, asynchronous processing of
requests, rendering asynchronous responses, and loading of
the browser panels happen simultaneously. This is a good
example of concurrent applications. Parallelism can be
observed in big data problems where batches of 1 k are
analyzed in a dataset of 1 gigabyte. Multiple threads are
spanned to work on 1k each, and the overall computation
time comes down as they are parallelized.

Now, let us look at a company where employees are working
on their specific departmental tasks (Figure 8.6):
Figure 8.6: Concurrency in a company
In an organization, concurrent operations can occur in
various departments, such as marketing, sales, logistics,
accounting, finance, and HR. Employees create many
documents, and printouts are taken from the printers
available. Concurrent tasks of creating documents and
parallelly generating printouts happen. Each employee
focuses on a documenting task and stops before taking a
printout. The employee can work on another document while
printing the document. All these activities happen
simultaneously.
After looking at different concurrency and parallelism
principles, you can understand how we can simulate the
same using Golang go routines. We will talk about go
routines in detail in the next section. While building an

application, you need to start looking at the concurrent and
parallel tasks that can be performed by the user. An
application can be concurrent and not parallel. It can be
parallel and not concurrent. Big data application is a good
example. An application can be neither parallel nor
concurrent in nature. The workflow-based application is
where tasks are executed in sequence, and there is a wait
time for task completion. There can be applications that can
be both concurrent and parallel. Now, let us look at the
assessment matrix where parallelism and concurrency are
relevant:
Figure 8.7: Assessment matrix of parallelization vs. concurrency
Note: Concurrent tasks can be in progress, whereas parallelized tasks
can be executed simultaneously. Concurrency can utilize parallelism
principles to ensure multiple tasks progress simultaneously.
Parallelism is not the only motive for concurrency. Overall processing
time comes down as multiple cores are used for processing during
concurrent task execution. Go Lang has built-in features for
concurrency.

Goroutines
Let us recap from Chapter 2, Advanced Features of Go, about
Goroutines: In Go Lang, the go routine gets executed with a
thread owned by it. Go routines are functions.
Now, let us look at how Goroutines are executed on a
computer. A computer has CPUs and processors associated
with the CPU. An operating system like Unix, Linux, MacOS,
and Windows can spawn processes and execute threads
within the process. Now, let us look at the real-life examples
for Goroutines:
Figure 8.8: Goroutines
A processor manages different threads in a process allocated
to the core. Go routines are associated with threads in an
operation system. Now, let us look at the queuing of
Goroutines when we have multiple cores and CPUs in a
computer. Now, let us look at the example and structure of
the Global run queue and local run queue:

Figure 8.9: Global run queue and local run queue
Operating systems have a scheduler for assigning the
process and threads to a core. CPU1 will manage threads in a
process. The scheduler in Go Lang manages the global
Execution queue of go routines. Go Lang scheduler picks the
o routine to a Local Run queue of an operating system
thread. This scheduler is based on a cooperative model and
is not preemptive. In the cooperative model, threads can
yield explicit execution. This helps in allocating the other go
routine for execution. During the allocation, the context gets
switched across the go routines. This is where the case
scheduler plays an important role. Go Lang Runtime decides
the priority of go routine execution. Runtime takes care of
methods such as invocation, garbage collection, network
communication, channel operations, blocking, and other
events. Context switching happens only in the event of a
change of go routine to be executed.
The following figure shows how the Go Lang Program
interacts with Runtime and OS kernel:

Figure 8.10: Go Binary—Runtime and kernel interaction
Let us see the steps involved in Runtime and kernel
interaction.
1. OS Kernel manages the sys calls and creation of the
threads.
2. Runtime manages the creation of the go routines,
channel communication, and memory allocation.
3. In the group’s scenario, the go routines group can wait
till the other group of go routines is executed.
4. The sync package is used to do a sleep before the shift
of allocation of go routine’s group.
Now, let us look at the sample code for an anonymous go
routine:
anonymous_go_routine.go
package main
import (
"fmt"

"time"
)
func main() {
fmt.Println("Starting the main function")
go func() {
fmt.Println("Calling the anonymous 
function")
}()
time.Sleep(1 * time.Second)
fmt.Println("Leaving the main Function")
}
After verifying the installation of the Go compiler, you can
compile and run it using the following commands. The
commands are as follows:
go run anonymous_go_routine.go
The output will be as follows:
Figure 8.11: Output for anonymous go_routine execution
As shown in the code above, the anonymous function does
not have a name. In the program above, you can see the
start of the main function, anonymous function invocation,
and exiting of the main function. Now, let us look at an
example of a go routine.
go_routine_exampe.go

package main
import (
"fmt"
"time"
)
func show(message string) {
for i := 0; i < 7; i++ {
time.Sleep(1 * time.Second)
fmt.Println(message)
}
}
func main() {
go show("go routine")
show("running a method")
}
In the code above, a go routine named show is defined to
show the message. In the main method, the example code
shows the difference between the execution of the goroutine
and just the method.
You can compile and run it using the following commands.
The commands are as follows:
go run go_routine_example.go
The output will be as follows:

Figure 8.12: Output for go_routine example execution
In the above code, you can see the difference and sequence
of execution of the go routine and just the method in Go
Lang.
Channels
Let us recap what we learned in Chapter 2, Advanced
Features of Go, about Channels: Channels provide the
capability or a feature for go routines to share information
with another go routine. The channel can send the data to
another channel. Channels are bidirectional. Channels can be
created by using chan keyword.
Figure 8.13: Channels

In Figure 8.13, you can see how the channel is used for
Routine communication. Concurrent Goroutines can
communicate using channels for the exchange of messages
and data. Channel Operator <- is used in the code for
different channel operations. In a web application,
Goroutines can help improve performance by designing and
developing concurrent tasks as Goroutines.
Figure 8.14: Channel—Send and receive messages
Go routines exchange data and information using channels.
Channel blocks and waits to receive and transmit the data to
the destination go routine. Channel data is typically shared
by iterating in a loop over the data.
Now, let us look at an example where go routines help
improve performance and efficiency. In the case of big data
solutions, jobs or tasks are created through data creation,
processing, querying, persistence, and storage of
information. These different tasks communicate through
channels as batches of data are processed through this
pipeline. Now, let us look at the data engineering process
and the different steps in the process:

Figure 8.15: Data engineering
Big data solutions involve handling data tasks like receiving
data and sending data from the source to the destination.
The challenge is in handling terabytes of data like
transactions, logs, metrics, and batch job updates. Most of
the database driven solutions have steps for staging,
cleansing, processing, and analysis of the data.
Communication is the key to these solutions between the
source and the destination. Where the data is getting
processed and which step in the process is very important
for solutions in an enterprise. Business activity monitoring
and analytics solutions focus on identifying the activities
related to business data and presenting the status of the
pipeline execution.
In enterprises, the challenge is managing the cost vs
efficiency for big data solutions. Most of the time, developers
choose small programs and scripts to handle different steps
in the process. Go lang is used not just for big data solutions
but also for small programs. Data pipelines can be written in
Go Lang programs. Each pipeline has input and output data,
and different steps in the process can be data pipelines. The

concurrency model helps break big data into manageable
chunks and handle data using data pipelines.
An example of using go routines and channels is a Go-lang-
based program for processing customers’ transactions to
update loyalty points for different customers. The loyalty
program has gold, silver, and bronze levels. Each program
has several points to be achieved. Go routines and channels
are used to process the data in batches.
Error handling and exception management are easy in Go
Lang since the transactions that are problematic can moved
into a separate file. At the end of the execution, you can
identify the transactions that are analyzed and others that
are causing errors.
Now, let us start coding a channel. You can look at the
channel example as follows:
channel_example.go
package main
import "fmt"
func main() {
var channel chan int
fmt.Println(" channel's Value: ", channel)
fmt.Printf("channel's Type: %T ", channel)
channel1 := make(chan int)
fmt.Println("\n channel1's Value: ", 
channel1)
fmt.Printf("channel1's Type: %T ", 
channel1)
}
The sample code above shows the creation of a channel, and
its value and type are printed.

You can now compile and run the channel_example.go using
the following command:
        go run channel_example.go
The output will be as follows:
(base) apples-MacBook-Air:src bhagvan.kommadi$ go 
run channel_example.go 
 channel's Value:  <nil>
channel's Type: chan int 
 channel1's Value:  0xc00005a060
channel1's Type: chan int (base) apples-MacBook-
Air:src bhagvan.kommadi$
Now, we will move to the next example. We will look at the
code for channel messaging, including the send and receive
methods:
channel_example.go
package main
import "fmt"
func exfunc(channel chan int) {
fmt.Println(123 + <-channel)
}
func main() {
fmt.Println("Main method has started")
channel := make(chan int)
go exfunc(channel)
channel <- 23
fmt.Println("Main method has ended")
}

In the above example, channel messaging and
sending/receiving messages from the channel-to-go routine
are shown.
You can now compile and run the channel_messaging.go
using the following command:
        go run channel_messaging.go
The output will be as follows:
Figure 8.16: Output for channel_messaging.go execution
Now, let us look at the code for channel messaging; send
and receive methods. We will look at channel_closing.go:
channel_closing.go
package main
import "fmt"
func newfunc(channel chan string) {
for v := 0; v < 4; v++ {
channel <- "running the channel"
}
close(channel)
}
func main() {
channel := make(chan string)
go newfunc(channel)
for {

result, message := <-channel
if message == false {
fmt.Println("Closing the 
channel ", message)
break
}
fmt.Println("Opening the channel ", 
result, message)
}
}
In the example above, you can see the channel closing
operation.
You can now compile and run the channel_closing.go using
the following command:
        go run channel_closing.go
The output will be as follows:
Figure 8.17: Channel closing execution output
Channel types
Channel types can be in multiple directions or only in a
single direction. Channel T stands for multiple directions or
bidirectional channel type. In two directions, channels can
transmit and receive messages. chan <-T stands for send

direction channel type. Only sending the messages is
possible. <-chan T stands for receive direction channel type.
The other types of channels are described in the following
table:
Method
Nil
channel
type
Non-nil
channel type
Closed
channel
type
Not-closed
channel type
Close
panic
succeed to
close
panic
succeed to
close
Send
value
block for
ever
block or
succeed to
send
panic
block or
succeed to
send
Receive
value
block for
ever
block or
succeed to
receive
never block
block or
succeed to
receive
Table 8.1: Channel types
The different channel types shown above are as follows:
Nil channel type
Non-nil channel type
Closed channel type
Not-closed channel type
Channel patterns
Now, let us look at different patterns in implementing
channels. Now, let us look at the broadcast pattern example:

Figure 8.18: BroadCast pattern—Channel implementation
Channels are used to send a single message to different
recipients using a broadcast pattern.
A single input channel receives messages from a sender to
broadcast to more than one output channel. More than one
recipient receives the same message from the output
channels. The broadcast pattern helps ensure the concurrent
sending of messages to different recipients.
Now, let us look at the Fan In Pattern in Go Lang as
illustrated in the following figure:

Figure 8.19: Fan In Pattern in Go Lang
A Fan In Pattern is used to combine different channels into
one output channel. The idea is to gather the concurrent
tasks’ data into one channel. This helps one consumer to
process messages in a combined form.
Now, let us look at the Fan Out Pattern related to channels.
The following figure shows the Fan Out Pattern, where data
coming from a single input channel from various senders is
routed to different recipients on different output channels.

Figure 8.20: Fan Out Pattern in Go Lang
The Fan Out Pattern helps share messages across more than
one recipient. A single function in Go Lang can have an array
of output channels as parameters. This function can return
an input channel, which is the multiplexer. The multiplexer
helps share data and distribute messages to more than one
output channel.
Concurrent apps in Go
Concurrency principles and mechanisms are applied in
console, desktop, and web applications. Go routines and
channels ensure that computation happens concurrently.
When the go routines and channels are used, the
application's performance increases. Performance tools and
profilers improve the application's response. Browser
applications are analyzed using developer tools to capture
performance times.
Now, let us look at building a concurrency application. Web
Links can be loaded to analyze the metadata of the website.

We can create the RSS feed for the website, looking at
various topics and content covered. RSS feeds can be
updated frequently based on the website updates. This
application can be built using Go Lang concurrency
principles.
You can have web links configured based on your
preferences and the topics selected. Web links can be
scanned to generate RSS feeds topic-wise. The application
will have the capability to add or remove the web links from
the topics. New topics can be added for the application with
web links.
RSS feeds can be loaded into the application based on the
topic. Feeds can be stored in a NoSQL database. This
application can be on the cloud serving as a software as a
servic e.
Users can register using social authentication,
google/msn/yahoo/twitter. Users can create a profile and
preferences. Feeds can be stored in the NoSQL database and
can be categorized with topics. They can be tagged with
keywords and made searchable for quick access. Cache
mechanisms can be used to improve the retrieval time of the
master data or user preferences and interests.
Another way to speed up performance is to load user-specific
feeds for a category selected in memory. The user can
browse them quickly. Scalability is an issue for this pattern to
be implemented. Concurrent users can browse the feeds
quickly based on the category selection. Multiple categories
and feeds specific to that category can be loaded in memory.
User profiles can be modified, and demographics are stored
in the NoSQL database. This helps recommend feeds for
users. Users can access correlated feeds read by other users.
Feed tags can be selected, and users can add new tags to
the existing tagged feeds.

Figure 8.19 shows the relationship between user profiles and
the demographics of the users in the system. Typical
demographics of the user gathered are as follows:
Age
Gender
Interests
Preferences
Job/Profession
Designation
Figure 8.21: User profile
A recommendation system can be built as an add-on to the
system to provide new feeds and tags for users. Users will be
eager to come back to the application because new content
will be ready to be processed as recommendations. This can
be like AdSense, where the context of the user can be used
based on the reader’s browsing history of the feeds.

The user satisfaction is dependent on the user profile and
other factors mentioned in the following list:
User profile
Content
Context
Interests
Figure 8.22: Reader satisfaction triangle
Figure 8.20 shows the triangular forces driving user
satisfaction based on user profile, context, and content. The
recommended feeds are evaluated for performance based on
the following factors:
Click through rate
Stay time
Upvotes
Comments
Reposts

Figure 8.23: Recommendation system metrics
Figure 8.21 shows the important metrics to measure the
performance and efficiency of the recommendation system.
The content provided to the user can be in any of the
following formats:
Textual information
Images/posters
Video
A web link
Document
This content can have multiple labels. Different labels for the
user content are shown in the following figure:

Figure 8.24: User label analysis
As shown in Figure 8.22, user interest-specific labels can be
as follows:
Category
Topic
Keyword
Source
Community
Vertical
The user profile-specific labels can be as follows:
Gender
Age
Location
Preferences
Interests
Favorites
Bookmarks
The user behavior-specific labels can be as follows:

Browsing time
Reading time
Staying time
Click through analysis
Label generation can be done by using the following
methods:
Noise-canceling by filtering the content
Penalizing the trends on feeds
Using time decaying and browsing history
Using global bias and click rate
Likes/dislikes/unsubscribes
Now, let us start building this application. The first step is to
look at accessing the links concurrently. Now, let us look at
the concurrency app code:
concurrency_app.go
package main
import (
"fmt"
"net/http"
)
func main() {
channel := make(chan string)
links := []string{
"https://www.golangbot.com",
"https://www.golang.org",
"https://www.changelog.com/gotime",

"http://qvault.io/",
"https://golang.ch/",
"https://gosamples.dev/",
"https://golangcode.com",
"https://appliedgo.net",
}
for _, link := range links {
go accessLink(link, channel)
}
for message := range channel {
fmt.Println(message)
}
}
func accessLink(link string, channel chan string) {
if _, error := http.Get(link); error != nil 
{
channel <- link + " is not 
accessible"
} else {
channel <- link + " is accessible."
}
}
You can now compile and run the concurrency_app.go using
the following command:
        go run concurrency_app.go
The output will be as follows:

Figure 8.25: User label analysis
Conclusion
In this chapter, we have covered topics related to
concurrency and parallelism. Examples were presented to
demonstrate how channels and go routines can be used in
real life.
Concurrency is the superset of parallelism. In real life,
concurrency is observed in various scenarios. Go routines
can process data by having a function executed by the
thread. Channels are used for communication between
multiple go routines. Channel types can be single-directional
or multiple-directional. Channel patterns are broadcast Fan In
and Fan Out Patterns.
In the next chapter, the reader will understand dependency
injection using the Go language. The reader will also
understand SOLID principles, which include dependency
inversion. The reader will know different types of
dependency injection, such as constructor, property, and
method.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and
Sessions with the Authors:

https://discord.bpbonline.com

CHAPTER 9
Go Dependency Injection
and SOLID
Introduction
In this chapter, the reader will understand dependency
injection using the Go language. The reader will also
understand SOLID principles, which include dependency
inversion. The readers will learn about different types of
dependency injection, such as constructor, property, and
method. Now, let us look at the Solid principles:

Figure 9.1: SOLID Principles
Structure
The chapter covers the following topics:
SOLID principles
Dependency injection
Dependency injection types
Objectives
In this chapter, we are going to look at design principles like
SOLID, dependency inversion, dependency injection, and
dependency injection types. These principles focus on
dependency injection, module dependencies, component
dependencies, and decoupling of the components from the
component using wiring.
SOLID principles

SOLID principles were created by Robert C. Martin. They are
design tenets for creating and developing software. These
tenets help in making the software extensible, scalable, and
enhance-able.
The SOLID principles are listed as follows:
Single Responsibility Principle (SRP)
Open/Closed Principle (OCP)
Liskov Substitution Principle (LSP)
Interface Segregation Principle (ISP)
Dependency Inversion Principle (DIP)
Now, let us look at the different principles which are part of
SOLID principles:
Figure 9.2: SOLID principles
Let us start by looking at the SRP first.
Single responsibility principle
A class should have one, and only one, reason to change.
–Robert C Martin

A class or module needs to have a single responsibility. This
helps in making the software modular. New enhancements
can be added to the software easily. Defects can be
analyzed, and root causes can be detected easily.
In life, we pay for online services and for ordering food and
groceries. Every time we pay online using Google Pay or any
other payment service, we send the order information and
account information to process the order payments. Based
on the SRP, a payment service needs to be responsible for
processing the payments and sharing a response that the
payment has been processed with the transaction
information. The invoice service will process the invoices and
share the invoice link with you. The order management
service will process the orders after communicating the
success of payment to the vendor.
As the payment service matures, new enhancements are
required to process the payment asynchronously or when the
connectivity is available. Based on the success, the order is
processed. As SRP states, this feature can be added to the
payment service very easily. Based on the success of the
payment, invoice, and order services receive the payment
success event to process the workflow.
Customer service maintains the customer information. We
can have customer loyalty service and customer address
service to handle loyalty programs and addresses of the
customer. Typically, loyalty programs will consist of different
levels like Platinum, Gold, Silver, and Bronze. These levels
are defined at different ranges of points. Loyalty points are
gathered by the customer during ordering groceries and
other items. Offers are targeted at different loyalty
membership levels to attract customers to leap from one
membership level to another.
Customer address service manages the address of the
customer. This service has contact information like mobile,

email, and landline contacts. This helps in sending marketing
offers and targeting campaigns to the customer.
First, let us look at the code for SRP. We will start with a
LandVehicle struct, which implements the interface
Vehicle. The code is as follows:
       srp_principle.go
package main
import "fmt"
type Vehicle interface {
drive()
}
type LandVehicle struct {
Vehicle
name string
}
func (dr *LandVehicle) init() {
dr.checkBattery()
dr.checkEngine()
}
func (dr *LandVehicle) drive() {
fmt.Printf(">>> driving Car[%s] ... \n", 
dr.name)
dr.init()
dr.start()
dr.monitorHealth()
}
func (dr *LandVehicle) checkBattery() {

fmt.Println(" checking battery's status ... 
")
}
func (dr *LandVehicle) checkEngine() {
fmt.Println(" checking engine's status ... 
")
}
func (dr *LandVehicle) start() {
fmt.Println("starting now ... ")
}
func (dr *LandVehicle) monitorHealth() {
fmt.Println("[ everything is ok ... ")
}
func main() {
dr := &LandVehicle{name: "Car"}
dr.drive()
}
You can now compile and run the srp_example.go, using the
following command:
          go run srp_example.go
The output will be as follows:

Figure 9.3: SRP example output
In this example, the LandVehicle has a single responsibility
of handling the driving part.
Open/Closed principle
A software artifact should be open for extension but closed
for modifications.
Software is built in such a way that it is open for extending
functionality and is closed for modifying the existing
functionality. Adding new behaviors to the software can be
done easily, and new features can be added to the software.
This principle helps in making the software agile and
enhanceable with much effort. Using object-oriented
abstraction and interfaces, it is easy to follow these
principles while designing and developing the software.
In the above example of payment service, there are new
payment methods coming up in the market, such as EMI, Buy
Now, Pay Later, and others. Old methods continue to exist,
like credit cards, debit cards, net banking, bill pay, wallets,
and others. Payment service needs to have the capability to
add a new payment method. This can be achieved by having
a Payment Method type as an interface and pass the
interface-typed instance for payment processing function in
Payment Service.
Similarly, the Customer Loyalty service needs to have the
capability to transfer or accept loyalty points from partner
programs. This service needs to have a Loyalty Point Typed
interface as the parameter for addPoints function.
Recap from Chapter 1, we had an example for interface
types:
In Go language, interface is an abstract type that consists of
method signatures. You cannot have instances of the
interface. You can create an interface with type (keyword)

interface name interface (keyword). More than one interface
can be implemented by a data type.
Vehicle is an interface, and car is a struct. When car is
instantiated, it returns a vehicle.
Modifying the example with another struct, we will
demonstrate the OCP. Now, let us look at the code for
ocp_principle.go:
ocp_principle.go
package main
import "fmt"
type vehicle interface {
getSpeed() float64
getDistanceTravelled() float64
}
type Car struct {
brand              string
manufacturing_year int
}
func (Car car) getSpeed() float64 {
return 120
}
func (Car car) getDistanceTravelled() float64 {
return 4000
}
type Truck struct {
brand              string
manufacturing_year int

      size               string
}
func (Truck truck) getSpeed() float64 {
return 160
}
func (Truck truck) getDistanceTravelled() float64 {
return 40000
}
func main() {
var veh vehicle
veh = car{"Toyota Tercel", 1997}
fmt.Println("Speed of the Vehicle :", 
veh.getSpeed())
fmt.Println("Distance Travelled by the 
Vehicle:", veh.getDistanceTravelled())
}
You can now compile and run the instance_type.go. The
command is as follows:
go run instance_type.go
The output will be as follows:
Figure 9.4: Interface type example output
The output shows how the interface abstracts out the
method implementation. Vehicle is an interface, and car is a

struct. When car is instantiated, it returns a vehicle.
Liskov Substitution Principle
As Liskov states, what is wanted here is something like the
following substitution property: If for each object o1 of type
S, there is an object o2 of type T such that for all programs P
defined in terms of T, the behavior of P is unchanged when
o1 is substituted for o2 then S is a subtype of T.
In the software, we have structs, which are interfaces or
classes that can be substituted for other equivalent types. In
the payment service example, the payment method type
interface will help in substituting different struct that
implement this interface.
Modifying the previous example with an enhanced interface
of the vehicle, we will demonstrate the Liskov Substitution
Principle. Now, let us look at the code of the file
lsp_principle.go:
lsp_principle.go
package main
import "fmt"
type vehicle interface {
getSpeed() float64
getDistanceTravelled() float64
start()
}
type car struct {
brand              string
manufacturing_year int
}

func (Car car) getSpeed() float64 {
return 120
}
func (Car car) getDistanceTravelled() float64 {
return 4000
}
func (Car car) start() {
fmt.Printf(">>> starting the [%s] car ... 
\n", Car.brand)
}
type truck struct {
brand              string
manufacturing_year int
}
func (Truck truck) getSpeed() float64 {
return 180
}
func (Truck truck) getDistanceTravelled() float64 {
return 40000
}
func (Truck truck) start() {
fmt.Printf(">>> starting the [%s] Truck ... 
\n", Truck.brand)
}
func getVehicles() []vehicle {
return []vehicle{&car{}, &truck{}}

}
func main() {
var veh vehicle
veh = car{"Toyota Tercel", 1997}
fmt.Println("Car's Speed of the Vehicle :", 
veh.getSpeed())
fmt.Println("Car's Distance Travelled by 
the Vehicle:", veh.getDistanceTravelled())
veh = truck{"Land Rover", 2001}
fmt.Println("Truck's Speed of the Vehicle 
:", veh.getSpeed())
fmt.Println("Truck's Distance Travelled by 
the Vehicle:", veh.getDistanceTravelled())
for _, vehicle := range getVehicles() {
vehicle.start()
}
}
You can now compile and run the lsp_principle.go.
The command is as follows:
go run lsp_principle.go
The output will be as follows:

Figure 9.5: LSP principle example output
The output shows how the interface abstracts out the
method implementation of starting a vehicle, whether it is a
truck or a car. In this case, vehicle is an interface, and car
and truck are structs implementing the interface. You can
have get vehicles, that can handle both car and truck.
Interface Segregation principle
Software clients need not rely on interfaces. Typically,
interfaces are designed with minimal functionality, which
helps reduce the dependencies between the modules.
In the previous example, we add one more interface to group
land vehicles. Let us see this in the following code:
isp_principle.go
type vehicle interface {
getSpeed() float64
getDistanceTravelled() float64
start()
}
type group interface {
addToTheGroup()
}

type car struct {
brand              string
manufacturing_year int
}
type truck struct {
brand              string
manufacturing_year int
}
func main() {
var veh vehicle
veh = car{"Toyota Tercel", 1997}
fmt.Println("Car's Speed of the Vehicle :", 
veh.getSpeed())
fmt.Println("Car's Distance Travelled by 
the Vehicle:", veh.getDistanceTravelled())
var truck1 truck
truck1 = truck{"Land Rover", 2001}
fmt.Println("Truck's Speed of the Vehicle 
:", truck1.getSpeed())
fmt.Println("Truck's Distance Travelled by 
the Vehicle:", truck1.getDistanceTravelled())
var truck2 truck
truck2 = truck{"Hyundai Trunk", 2011}
fmt.Println("Truck's Speed of the Vehicle 
:", truck2.getSpeed())
fmt.Println("Truck's Distance Travelled by 
the Vehicle:", truck2.getDistanceTravelled())

truck2.addToTheGroup(truck1)
}
You can now compile and run the isp_principle.go. The
command is as follows:
      go run isp_principle.go
The output will be as follows:
Figure 9.6: ISP principle example output
The output shows how the interface abstracts out the
method implementation of adding a vehicle to the group.
Vehicle and group are interfaces and truck is a struct.
Creating a group of cars is achieved by having a new
interface implemented. The vehicle interface provides the
functionality of speeding and maintaining the distance
traveled in the odometer.3.
Dependency Inversion Principle
Top layer software modules need not have to rely on bottom
layer modules. Top and bottom layers need to rely on
software interfaces and abstractions. Detailed features are
abstracted out by having abstract classes. This helps in
making the software modular and decoupled. The less
decoupled the software, it helps in enhancing and testing the
features quickly.

Now, let us look at the previous example. In the vehicle, we
need an engine to be added. A new car can be created with
an engine for a specific brand. Let us look at the code now:
dip_principle.go
package main
import "fmt"
type vehicle interface {
getSpeed() float64
getDistanceTravelled() float64
start()
}
type Engine struct {
engineType string
}
type car struct {
brand              string
manufacturing_year int
engine             *Engine
}
func NewCar(brand string, year int, engine *Engine) 
*car {
return &car{
brand:              brand,
manufacturing_year: year,
engine:             engine,
}

}
func (Car car) getSpeed() float64 {
return 120
}
func (Car car) getDistanceTravelled() float64 {
return 4000
}
func (Car car) start() {
fmt.Printf(">>> starting the [%s] car ... 
\n", Car.brand)
}
func main() {
var veh vehicle
var engine = &Engine{engineType: "V3"}
veh = NewCar("Toyota Tercel", 1997, engine)
fmt.Println("Car's Speed of the Vehicle :", 
veh.getSpeed())
fmt.Println("Car's Distance Travelled by 
the Vehicle:", veh.getDistanceTravelled())
veh.start()
} 
You can now compile and run the dip_principle.go. The
command is as follows:
      go run dip_principle.go
The output will be as follows:

Figure 9.7: DIP example output
The output shows how an engine is added to create a car.
Vehicle is an interface and car and engine are structs. When
car is instantiated, brand and engine are passed in the
constructor of the car
Dependency injection
Design principles and patterns are followed by the architects
and lead to building software. Better reusability and
improvement in productivity are observed when design
patterns and principles are applied during software
engineering. Dependency injection is a design pattern
applicable in many tech stacks.
Let us start off by looking at how a computer is assembled
for the order. Most of the customers have in mind the
computer hardware requirements like ram memory, CPU
frequency, and disk space. They are also interested in having
accessories that go with the computer, like a keyboard,
mouse, monitor, and power backup. Many vendors work on
these requirements to assemble the computer based on
these requirements.
While assembling the hardware, vendors are aware of the
motherboards and dependent components that go with
them.
Based on the above example, we can extend the principles
of dependency injection and build software. Some of the
motherboards are loosely coupled and work with
components of different brands and interfaces. Similarly,

software can be built loosely coupled. The components in the
software scenario need to have services and interfaces that
are easily pluggable to other services or containers. There
are many popular containers in Go Lang, like Wire, Inject,
Dig, Dingo, and goioc/di. These containers help in designing
and building components that are easily pluggable into the
containers.
Let us first look at an example of dependency injection
through a constructor. In this case, there is no container. A
media storage system will have services to store media like
video, audio, and images.
di_constructor_example.go
package main
import "fmt"
type Video struct {
content   []byte
storage   VideoStorage
publisher string
}
func NewVideo(ps VideoStorage, publisher string) 
*Video {
return &Video{storage: ps, publisher: 
publisher}
}
func (video *Video) Load(content string) {
video.content = video.storage.Load(content)
}
func (video *Video) Save(title string) {
video.storage.Save(title, video.content)

}
type VideoStorage interface {
Load(string) []byte
Save(string, []byte)
}
type MediaStorage struct {
video []byte
}
func NewMediaStorage() *MediaStorage {
return &MediaStorage{
video: []byte{},
}
}
func (mStore *MediaStorage) Save(name string, 
contents []byte) {
mStore.video = contents
}
func (mStore *MediaStorage) Load(name string) 
[]byte {
return mStore.video
}
func (mStore *MediaStorage) Type() string {
return "MediaStorage"
}
func main() {
storage := NewMediaStorage()

video := NewVideo(storage, "STAR MUSIC")
video.Load("Cricket Match NZ vs AUS 1987. 
Cricket match happened in Perth and Australia won 
the match")
video.Save("Cricket Match NZ vs AUS 1987 ")
fmt.Printf("video : %s \n", 
video.publisher)
}
You can now compile and run the
di_constructor_example.go. The command to execute the
code is as follows:
    go run di_constructor_example.go
The output will be as follows:
Figure 9.8: DI Constructor example output
In the above example, we have video storage service with
Media Storage and Video Storage interfaces. Video is a
struct. The constructor of the video takes the media storage
interface typed instance. Video struct implements video
storage for saving and loading the video information.
Dependency injection types
The dependency injection method helps in ensuring the
dependencies are loaded and the software is enhanceable
and scalable. The dependent components can be replaced
with any component having the same interface or features.
In the Go Lang tech stack, dependency injection can be done
through structs and interfaces, constructors, setters,

methods, and manual injection. Go Lang dependency
injection has evolved, and many frameworks like Wire, Inject,
Dig, Dingo, good/di, and others support dependency
injection. These frameworks have different features, and
appropriate frameworks can be selected based on user
support, popularity, scalability, usability, and performance.
Using these containers, you can build software that can be
maintained very easily, and new features can be added
within time to market.
There are different types of dependency injection. They are
based on structs/interfaces, constructors, setters, properties,
and manual injection types, as shown in the following figure:
Figure 9.9: Dependency injection types

First, let us look at different injection methods.
Creating structs and interfaces
A class or an object is called in another class for a specific
feature; then, these two classes are dependent on each
other. While creating the class through the constructor, a
new class can be instantiated and passed as a parameter.
This makes these two classes coupled and changing a class
to another class becomes tough. Structs and interfaces come
to the rescue. Structs can be used for creating objects and
interfaces can be used for describing the object behavior.
If two classes have the same interface defined for a feature,
you can interchange them in the parent class easily. In Go
Lang, we use structs to implement the interfaces. Objects
are instantiated and passed on as parameters to the parent
class functions or methods.
Manual dependency injection
Manually creating the dependencies and plugging in the
right one in a class is another option. In this case, it looks
simple and nice, but the coupling becomes higher, and
managing the software becomes tough.
Constructor injection
Dependency injection through the constructor is another
option. This helps in making the injection unmodifiable.
Dependencies can be instantiated and kept ready for
plugging into the right class constructor. You can see the
example as follows:
func main() {
storage := NewMediaStorage()
video := NewVideo(storage, "STAR MUSIC")
}

Setter/method injection
Setter injection is another injection type where the required
dependency can be set on a method. This is better in terms
of the coupling factor. Service classes will have different
functions based on the behaviors to be exposed. The client
invokes the service for a specific function. Service needs to
have the dependent component initialized. Now, let us look
at the client implementation:
func (video *Video) setVideoStorage(vStorage 
VideoStorage) {
   
video.storage = vStorage
}
func main() {
storage := NewMediaStorage()
video := NewVideo(storage, "STAR MUSIC")
vStorage := new(VideoStorage)
video.setVideoStorage(vStorage)
}
Now, let us look at the dependency injection frameworks in
Go Lang.
Dependency injection frameworks
There are many dependency injection frameworks. In Go
Lang, Wire, inject, Dig, Dingo, and goioc/di are the popular DI
frameworks. These frameworks help in creating software that
is loosely coupled and agile in nature.
Google’s Wire
Most of the time, real-life software has many dependencies.
A dependency graph or tree can be created to identify the
level of the dependencies and the root. Changing the

dependent components in complex software is challenging
because of the complex build process and compilation. Build
tools need to have the capability to identify the set of
dependent components and build the packages. Cleaning the
old builds and restarting new builds is a required feature for
build management tools.
Google’s Wire is a popular dependency injection tool that can
easily handle dependency tree management. The framework
initializes these dependencies in the parent classes. Wire has
two important aspects: providers and injectors. Providers are
Go language functions that process the parameters to return
values.
func NewMediaStorage() *MediaStorage {
return &MediaStorage{
video: []byte{},
}
}
The above code shows the provider for Media Storage.
Facebook’s inject
Facebook’s inject framework uses an injection method based
on reflection. Go Lang reflection package is used for
reflecting the required types and constructors to create
dependent objects in the dependency tree. Inject has struct
tags, and these have three different types like inject."",
inject."private", and inject."dev logger".
Uber’s dig
Uber’s dig uses the reflection method for dependency
injection. It has features to build a dependency tree and
bootstrap the required objects during startup. It can handle
singletons in the dependencies. The function parameters

need to implement an interface. Dig has support for methods
of property injection.
Dingo
Dingo is a similar dependency framework to Guice. Struct
tags can be used in this framework. Dependency injection
can also be supported through the request injection type.
Choosing the right framework suitable for you
There are various factors that help identify an appropriate
framework for your software product. The different factors
are listed as follows (Figure 9.4):
Usability
Scalability
Performance
Popularity
User support
Commercial/opensource
Cost
Future-proofed

Figure 9.10: Dependency injection framework selection factors
Conclusion
In this chapter, we have covered topics related to SOLID
principles and dependency injection. Different dependency
injection types were covered, and frameworks supporting
dependency injection were discussed.
The SOLID principles covered in this chapter are Single
Responsibility, Open/Closed, Liskov Substitution, Interface
Segregation, and Dependency Inversion Principles.
Dependency injection can be used to inject dependencies
into the software. Dependencies can be managed in the
software with different types of dependency injection.
Dependency injection can be done through structs and
interfaces, manual, constructor-based, setter, and property-
based injection types. We have covered developers’ popular
dependency injection frameworks like Wire, Inject, Dig,
Dingo, and others.

In the next chapter, the reader will understand containers
and Docker. The reader will be able to develop services that
can be containerized using Docker. Docker Images can be
created and posted on the docker Hub for different Go
services.

CHAPTER 10
Containerization and
Docker
Introduction
In this chapter, readers will understand containers and
Docker. The reader will be able to develop services that can
be containerized using Docker. They will also learn how
Docker images for different Go services can be created and
posted on the Docker Hub. Now, let us look at the
containerization using Docker is done with different
components:

Figure 10.1: Containerization and Docker
Structure
The chapter covers the following topics:
Containers
Docker
Go Services
Dockerized Go Services
Objectives
By the end of this chapter, the user will learn how to
examine containers, Docker, Go Services, and Dockerized Go
Services. The readers will be presented with basic examples
using Docker as a container and advanced examples using
Docker Compose. We will look into containerization concepts

and building Go Services. The readers will understand how
Go Services are dockerized into containers.
Containers
There are many containers like Docker and Kubernetes
evolving in the market. Enterprises are adopting
containerization for easy deployment of microservices on the
cloud and on-premises. Virtual machines were the first in this
market space. Developers had issues as VMs were non-
performant, and the overall time for initialization was high.
Containers, on the other hand, were performant as they can
be based on the required operating system with all
dependent libraries and packages. They were consuming the
resources optimally.
Docker is one of the containers used for microservices based
application packaging and deploying the required
dependencies. Docker can be based on Linux, MacOS,
Windows, and third-party operating systems. In Linux, you
can have different flavors like Ubuntu, CentOs, RedHat, and
other vendor operating systems. The next level of packaging
is at the application or tech stack-specific containers like
tomcat, jetty, and spring-boot micro-containers. The
advantage of docker-like containers is that you can deploy
them and test them as a single unit. The image instance can
be deployed in the required operating system on the cloud or
on-premises.
Containers can have a tech stack containing the tech stack
deployed on the operating system. The tech stack can be a
web application, REST API talking to a Message queue, or a
web server. Now, let us look at the Tech Stack, which is
containerized in the docker:

Figure 10.2: Tech Stack in a container
Containers provide capabilities to scale, perform, agile,
control, isolate, and be portable across different operating
systems. Let us take an example where an enterprise wants
to build a web application to enable selling online. This e-
commerce application can be built on a Go language
framework like Beego. It can expose REST API and React web
applications can access the REST API. These APIs are
deployed on the Beego web framework. We can use Linux
Ubuntu as the operating system. The image can have Go
language binaries and compiler setup. Beego framework can
be installed on the image.
Once the web application with web pages on React and
integration is done with REST API through JavaScript, the
web application can be deployed on the image and tested by
the QA engineers. The image can be uploaded to the docker
hub, which is the registry. On the cloud, you can access this
image for deployment and execute the application. There is
a huge cut down in cost, time, and effort for testing,
deployment, and project execution. Now, let us look at the
Go Lang Tech Stack dockerized in a Linux container:

Figure 10.3: Go Lang Tech Stack—Linux
We can have performance testing on the product
environment with higher-end RAM like 32 GB and have 4 VMs
running the web application. 4 VMs can each have 8 GB of
memory. On any cloud, this can be achieved without actual
web app deployment. Docker container helps manage
memory allocation very easily with a Docker cluster
environment. Docker container virtualizes the operating
system and provides capabilities to manage CPU, memory,
disk space, network, and IO.
Now, let us first create an image in a container. We will be
using Docker as the container. You need to register on
hub.docker.com and download the Docker software. You have
to first create a Dockerfile. Now, let us look at the Dockerfile:
Dockerfile
FROM busybox
CMD echo "Your first image on container is created"
You need to run these commands to build the image.
docker build -t bhagvanarch/docker-container-image 
.

docker run bhagvanarch/docker-container-image
The output of the above commands, when executed, is as
follows:
Figure 10.4: Docker container image execution output
As shown in the example, input for the docker process is the
Docker file. The Docker file has the steps and tasks defined
for creating an image.
Containers are used not only for microservices-based
applications but also for domain-driven design pattern-based
apps. Container orchestration can be done by having
multistage builds and multiple processes initialized by the
container. It goes without saying that a single monolithic
application can be deployed in a container.
Docker
Docker is a popular container that is used for enterprise app
deployment on the cloud and on-premises. Most of the time,
developers and deployment engineers argue about where it
was working vs. where it is not currently working. Developers
try their best in these arguments to show their environment
is working fine. Deployment engineers strongly protest,
saying that it is not working on the prod environment,

though the operating system and database are the same.
This is where Docker comes to the rescue. All the steps and
tasks performed by the developer are captured in the
Dockerfile. This Dockerfile is used as the input for the Docker
executable for the deployment engineers to deploy in the
production environment. Complex environments, which have
many steps and tasks to perform, can be simplified by
having a Dockerfile. Dockerfile typically has environmental
variables, different Go Lang compiler versions, build process
tasks, mounting of directories, and copying tasks.
Docker was created by a company called Dotcloud. Dotcloud
Inc. became Docker Inc. Docker was written in the Go
language. Docker became popular after its creation in 2013
as a DevOps tool. Docker was implemented as the
deployment tool for deploying enterprise apps on the cloud.
Docker is installed on the developer’s desktop as a host,
daemon, client, and hub repository. Docker client and server
communicate through a client-server architecture.
Now, let us first create an image in a docker container where
we can write Go Lang programs. We will be using the
golang:1.8 version and the Docker as the container. You can
first create a Dockerfile using the following code:
Dockerfile
FROM golang:1.8
WORKDIR .
COPY *.go .
RUN go build -o first_go .
CMD ./first_go
You need to run these commands to build the image locally:
docker build -t first_go_image -f Dockerfile .
docker run -it first_go_image bash

The output of the above commands, when executed, is as
follows:
first_go_image
Figure 10.5: First Docker image execution output
Now, let us look at the Docker Registry.
Docker Registry
Docker Registry is used to store the Docker images. The
images can be stored in repos. These repos can be public or
private. Developers can download the images for

development. QA engineers can do the same for testing.
Docker Hub is a Docker Registry that is public.
Each cloud provider, such as AWS, Azure, Google Cloud, and
others, provides a container registry. Different companies
can have private container registries.
Now, let us create the image on the docker hub (registry)
where we can write Go Lang programs. We will be using the
golang:1.8 version and the Docker as the container. You can
first create a Dockerfile. Now, let us look at the Dockerfile:
Dockerfile
FROM golang:1.8
WORKDIR .
COPY *.go .
RUN go build -o first_go .
CMD ./first_go
You need to run the following commands to build the image
on the docker hub:
docker build -t bhagvanarch/first_go_image -f 
Dockerfile .
docker run -it bhagvanarch/first_go_image bash
The output of the above commands, when executed, is as
follows:
Bhagvanarch/first_go_image

Figure 10.6: First Docker Image execution output
Docker Compose
Docker Compose is used to build images of multiple
containers. Multi-stage builds and multiple processes
involving different containers can help in creating and
packaging multiple container applications. In the example
above, where we were creating an enterprise web
application based on Beego Web framework and React, we
can use Docker Compose for multiple containers having
database MySQL, Beego-based REST API, and React web
application. These containers are configured in the YAML file.
Docker-compose can run in the background if you use the -d
flag. Now, let us look at the React.js web app built using Gin
REST API as the backend:

Figure 10.7: React.js web app—Gin Rest API
Now, let us create the image using docker-compose, where
we can write the Go Lang programs. We will be using the
golang:1.8 version and the Docker as the container. You can
first create a Dockerfile. Now, let us look at the Dockerfile:
Dockerfile
FROM golang:1.8
WORKDIR .
COPY *.go .
RUN go build -o first_go .
CMD ./first_go
Now, let us create the docker-compose.yml:
docker-compose.yml
version: '2'
services:
  first-docker-compose-go:
    build: .
    environment:
      - TEST_ENV=test
You need to run these commands to build the image on the
Docker Hub:

docker-compose up
    docker-compose run first-docker-compose-go bash
The output of the above commands, when executed, is as
follows:
first_docker_compose_go_image
Figure 10.8: First Docker Compose image execution output
Docker networks
You can create a container and build images in any operating
system using docker or docker-compose. When you can
execute an image, you can see there is an IP address for
each image running on your computer. You can have a
docker network setup and have docker images assigned to
the network images. Docker network types are default, user-
defined, and overlay docker network.
You can specify the network parameter while creating a
container. The default network created will be a container on
a bridge network. Containers can talk to each other using IP
addresses. You can have multiple containers running on one

host. The bridge network has one host. If you want to have
multiple Docker hosts, you can use the network parameter
and assign a host value. The host network stack will have
multiple host details when you create them. Containers that
are part of the host network can talk to the host network
interfaces. You can have no network assigned if you pass the
value none to the network parameter. The container will not
have any IP address assigned.
Go Services
You can build microservices with the Go language. Moving
away from the monolithic approach of building apps,
microservices architecture is known for building the
application ground up with micro-services. Microservices can
talk to each other in different protocols like HTTP, AMQP,
HTTPS, and web sockets. Every microservice can be
deployed and executed as a separate process. Every
microservice will have its own data model, business logic,
rules, and data storage mechanism. The backend database
can be NoSQL or a relational database. Microservices
architecture is getting popular because of its benefits, which
are related to manageability, scalability, performance, and
time-to-market delivery.
Let us now discuss building REST API (Microservice) with MQ.
We built this Go Lang microservice in Chapter 4, Building
REST API. In this context of building a Go Service Docker, let
us relook at how to develop a REST API that can interact with
message queues. We are going to use Gin and Rabbit MQ.
Let us look at the code for developing the REST API using Gin
and RabbitMQ.
main.go
package main
import (

"fmt"
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"rest_api_mq/producer/config"
"rest_api_mq/producer/utils"
)
func init() {
mode := utils.GetEnvVar("GIN_MODE")
gin.SetMode(mode)
}
func main() {
appGin := config.CreateApp()
addrGin := utils.GetEnvVar("GIN_ADDR")
portGin := utils.GetEnvVar("GIN_PORT")
log.Info().Msgf("App is up at 
http//:%s:%s", addrGin, portGin)
if error := appGin.Run(fmt.Sprintf("%s:%s", 
addrGn, portGin)); error != nil {
log.Fatal().Err(error).Msg("Http 
Server setup failed")
}
}
Now, let us look at the createApp to see how the routes are
set up through routers:
Creating_app.go
package config
import (

"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"rest_api_mq/producer/middlewares"
"rest_api_mq/producer/routers"
)
func CreateApp() *gin.Engine {
log.Info().Msg("service starting")
app := gin.New()
app.Use(gin.Recovery())
app.SetTrustedProxies(nil)
log.Info().Msg(" cors, request id, request 
logging middleware added")
app.Use(middlewares.CORSMiddleware(), 
middlewares.RequestID(), 
middlewares.RequestLogger())
log.Info().Msg("routers setup")
routers.SetupRouters(app)
return app
}
The Routers package has the routes mapped to methods that
talk to the message queue. Now, let us look at the setup.go
code:
Get   /ping     controllers.ping
Post /publish/example controllers.Example
setup.go
package routers
import (

"github.com/gin-gonic/gin"
"rest_api_mq/producer/controllers"
)
func CreateRouters(engine *gin.Engine) {
version1 := engine.Group("/v1")
{
version1.GET("/ping", 
controllers.Ping)
version1.POST("/publish/example", 
controllers.Example)
}
}
The controllers package has the message publisher
configured to publish messages to a message queue.
controllers.go
package controllers
import (
"net/http"
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"rest_api_mq/producer/environment"
"rest_api_mq/producer/models"
"rest_api_mq/producer/utils"
)
func Example(context *gin.Context) {
var msg models.Message

request_id := context.GetString("x-request-
id")
if binderr := context.ShouldBindJSON(&msg); 
binderr != nil {
log.Error().Err(binderr).Str("request_id", 
request_id).
Msg("Error occurred while 
binding request data")
context.JSON(http.StatusUnprocessableEntity, gin.H{
"message": binderr.Error(),
})
return
}
connectionString := 
utils.GetEnvVar("RMQ_URL")
producer := utils.MessagePublisher{
environment.EXAMPLE_QUEUE,
connectionString,
}
producer.PublishMessage("text/plain", 
[]byte(msg.Message))
context.JSON(http.StatusOK, gin.H{
"response": "Message received from 
Rest API",
})
}

MessagePublisher is a struct defined in the utils package.
It has a method to publish messages to a queue defined in
the environment. Now, let us look at the Publisher.go code:
Publisher.go
package utils
import (
"github.com/rs/zerolog/log"
"github.com/streadway/amqp"
)
type MessagePublisher struct {
Queue            string
ConnectionString string
}
func (x MessagePublisher) OnError(err error, msg 
string) {
if err != nil {
log.Err(err).Msgf("Publishing 
message error '%s' queue. Error message: %s", 
publisher.Queue, msg)
}
}
func (publisher MessagePublisher) 
PublishMessage(contentType string, body []byte) {
conn, error := 
amqp.Dial(publisher.ConnectionString)
publisher.OnError(error, "RabbitMQ not 
connected")
defer conn.Close()

channel, err := conn.Channel()
publisher.OnError(err, "Channel not 
opened")
defer channel.Close()
q, error := channel.QueueDeclare(
publisher.Queue,
false,
false,
false,
false,
nil,
)
publisher.OnError(error, "Queue Not 
declared")
error = channel.Publish(
"",
q.Name,
false,
false,
amqp.Publishing{
ContentType: contentType,
Body:        body,
})
publisher.OnError(error, "message not 
published")
}

Now, let us look at the consumer package and the
implementation of main.go in code:
main.go
package main
import (
"rest_api_mq/consumer/environment"
"rest_api_mq/consumer/handlers"
"rest_api_mq/consumer/utils"
)
func main() {
connectionString := 
utils.GetEnvVar("RMQ_URL")
messageQueue := utils.MessageConsumer{
enviornment.EXAMPLE_QUEUE,
connectionString,
handlers.HandleMessaage,
}
forever := make(chan bool)
go messageQueue.Consume()
<-forever
}
MessageConsumer is created from the utils package. Now,
let us look at the Message_consumer.go code:
Message_consumer.go
package utils
import (

"github.com/rs/zerolog/log"
"github.com/streadway/amqp"
)
type MessageConsumer struct {
Queue            string
ConnectionString string
MsgHandler       func(queue string, msg 
amqp.Delivery, err error)
}
func (consumer MessageConsumer) OnError(errors 
error, msg string) {
if errors != nil {
consumer.MsgHandler(consumer.Queue, 
amqp.Delivery{}, errors)
}
}
func (consumer MessageConsumer) Consume() {
conn, err := 
amqp.Dial(consumer.ConnectionString)
consumer.OnError(err, "Failed to connect to 
RabbitMQ")
defer conn.Close()
channel, err := conn.Channel()
consumer.OnError(err, "Failed to open a 
channel")
defer channel.Close()
q, err := channel.QueueDeclare(

consumer.Queue,
false,
false,
false,
false,
nil,
)
consumer.OnError(err, "Failed to declare a 
queue")
msgs, err := channel.Consume(
q.Name,
"",
true,
false,
false,
false,
nil,
)
consumer.OnError(err, "Failed to register a 
consumer")
forever := make(chan bool)
go func() {
for delivery := range msgs {
consumer.MsgHandler(consumer.Queue, delivery, nil)
}

}()
log.Info().Msgf("Started listening- 
messages from '%s' queue", consumer.Queue)
<-forever
}
The environment package has the constants defined for the
environment file, directory, and message queue. Now, let us
look at the constants.go code:
constants.go
package environment
const ENV_FILE = ".env"
const ENV_FILE_DIRECTORY = "."
const EXAMPLE_QUEUE = "message_queue"
.env will Rabbit message queue configuration URL 
and Log level.
.env
LOG_LEVEL = debug
RMQ_URL = amqp://guest:guest@localhost:5000/
Each microservice shown above is an independent
deployable unit that can be tested and loosely coupled.
Microservice can consist of small services built and used in
the framework for different features. A small team can build
microservices architecture-based applications very easily
and quickly. Agile process and microservices go together well
in making the development of features meet the time to
market. Polyglot microservices architecture style embraces
tech stacks like Java, Python, Lang, PHP, and .NET.
Microservice architecture provides benefits such as good
readability of the code, components decentralization,

continuous integration, test automation, continuous
deployment, and domain-driven design.
Dockerized Go Services
Now, let us look at how Docker can help the deployment of
the Go Lang microservices more effectively. In the following
example, we will look at how to develop REST API
(Dockerized microservice), which can interact with message
queues. We are going to use Gin and RabbitMQ.
The Environment package has the constants defined for the
Environment file, directory, and message queue. Now, let
us look at the constants.go code:
constants.go
package environment
const ENV_FILE = ".env"
const ENV_FILE_DIRECTORY = "."
const EXAMPLE_QUEUE = "message_queue"
.env will Rabbit message queue configuration URL 
and Log level.
.env
LOG_LEVEL = debug
RMQ_URL = amqp://guest:guest@localhost:5000/
docker-compose.yaml
networks:
  rabbitmq-example:
    driver: bridge
services:
  rabbitmq:

    image: 'rabbitmq:3-management'
    networks:
      - rabbitmq-example
    volumes:
      - ./rabbit-
mq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    ports:
      - "8080:15672"
    healthcheck:
      test: [ "CMD", "rabbitmqctl", "status"]
      interval: 5s
      timeout: 15s
      retries: 5
  producer:
    build: ./producer
    ports:
      - "5050:5050" 
    networks:
      - rabbitmq-example
    depends_on:
      - rabbitmq
    environment: 
      GIN_MODE: "release"
      GIN_HTTPS: "false"
      GIN_ADDR: "0.0.0.0"
      GIN_PORT: "5050"

      LOG_LEVEL: "debug"
      RMQ_URL: "amqp://guest:guest@rabbitmq:5673/"
  consumer:
    build: ./consumer
    networks:
      - rabbitmq-example
    depends_on:
      - rabbitmq
    restart: on-failure
    environment: 
      LOG_LEVEL: "debug"
      RMQ_URL: "amqp://guest:guest@rabbitmq:5673/"
You can now compile and run the rabbitmq, producer, and
consumer services in the docker. The command to run the
docker is as follows:
     docker-compose up
The output will be as follows:

Figure 10.9: MQ Docker Compose image execution output
In the above example, we have used docker-compose to
build a Go Lang microservice based on MQ.
Conclusion
In this chapter, we have covered topics related to containers,
Docker, Docker Registry, Docker Compose, Docker networks,
Go Lang microservices, and Dockerized Go Lang
microservices.
Containers like Docker and Kubernetes are used to build and
deploy software packages. Docker has components like
registry and networks to have multiple client-host models.
Docker Compose helps build multiple stages and services.
The Go Lang tech stack can be used to build microservices.
Dockerized Go Services can be built using docker-compose
and multiple Go Lang Services.

In the next chapter, the reader will understand the principles
of microservices architecture compared to monolithic
architecture. The reader will then be able to create an
architecture using Microservices and deploy these services
on containers.

CHAPTER 11
Go Microservices
Introduction
In this chapter, the readers will understand the microservices
architecture versus the monolithic architecture principles.
The reader will be able to create an architecture using
microservices and deploy these services on the containers.
Now, let us look at the Go Lang microservices architecture
styles and containerization:

Figure 11.1: Go Lang microservices
Structure
The chapter covers the following topics:
Monolithic architecture
Microservices architecture
Microservices in Go
Containerized Go microservices
Objectives
In this chapter, we are going to discuss Go Lang-based
microservices. The monolithic architecture style is presented
first, followed by the microservices Architectural style. We
will look into creating Go Lang-based microservices.
Containers can be used to containerize the Go microservices
for easy deployment on the cloud.

Before microservices, the architectural style was monolithic
architecture style. In monolithic architecture, layered
architectural patterns are used to separate presentation,
business logic, middleware, and persistence layers.
Microservices architecture style focuses on building services
for applications and developing the application for a set of
services first. The tech stack can be different in the
microservices, but protocols like REST help in integrating
from the front end with back microservices.
Go Lang tech stack can be used to build microservices. Let
us first look at monolithic architecture.
Monolithic architecture
In monolithic architecture, the choice of tech stack and data
store is very important to start with. Once the choice is
made, different layers are built using the frameworks
available in the tech stack. The user interface will be in the
presentation layer. Business rules will be in the business
logic layer. The middleware and persistence layers operate
with the database and other data sources. The database can
be relational or NoSQL-based.
Different layers are deployed on different nodes, and they
interact on the secured network.
Scaling can be done for each layer based on the type of the
application. The monolithic application can be deployed
using DevOps tools. Managing changes and deploying is
important. DevOps Research and Assessment metrics can
help in measuring the rate of change and deployment. The
metrics are as follows:
Deployment Frequency (DF)
Mean Lead Time for Change (MLT)
Mean Time to Recover (MTTR)

Change Failure Rate (CFR)
Reliability
These metrics help measure velocity, stability, and
operational performance. They help in measuring the
software development velocity. They are used for making key
decisions to come up with new process initiatives and
changes to the existing team members. They are used to
create teams that are cross-functional and small in size. A
set of new requirements or changes in functionality are
developed and deployed using the DevOps toolkit.
These metrics help determine the performance of the team
members. Deployment frequency measures the number of
releases deployed on the live environment. The mean lead
time for changes is calculated using the cycle time from the
development to the deployment on the live environment.
The mean time to recovery is measured using the time for
getting the live environment from shut down after the crash
to up-and-running mode. The change failure rate is the count
of the occurrences of the live environment going down
because of deployments of new requirement-related code.
Reliability helps in gauging the application performance,
scalability, latency, failover, and availability.
In the case of a CRM application, it consists of creating
customers and managing customer data. Campaigns will be
created and targeted for publishing to the customers. The
leads are gathered as a list of customers or segments of
customers. Customer segments are created by attributes like
age, gender, salary range, or geography. When the customer
likes the product and buys the product, a transaction is
logged in the back office of a retail store or an e-commerce
company. The transactions are processed to check if the lead
has been realized and turned into revenue. This process
helps assess lead conversion. Transactions can also be

checked for aberration to identify the behavior of the
customer.
The other important feature is the loyalty points, which have
different levels like gold, silver, and bronze levels. Customer
buys the products and loyalty points are stored in the system
to track the progress of the customer. Offers are targeted
based on loyalty to improve the purchasing rate of the
customer. The discounted offers are shared based on where
the customer is in terms of the loyalty points. Companies
frequently announce loyal customers and convert leads from
the CRM portal.
The application consists of use cases, business logic,
business rules, and persistent data. The architecture can be
monolithic, which is a layered architecture. The layers can be
presentation, business rules, middleware, and persistence
layers. Middleware can integrate with external applications
using synchronous and asynchronous mechanisms.
You can also have monolithic applications with different
presentation-related components, business logic, rules
components, and persistent components. All are built and
bundled into a single monolithic app. In the Java tech stack,
this app can be a web archive or enterprise archive. You can
have a cluster of servers with a load balancer to balance the
load across the cluster nodes.
These monolithic applications are deployed on servers. The
servers will have an operating system, and the system-
related services will be running. They are as follows:
Memory management
Process scheduling
Device drivers
File I/O
Process management

Process monitoring
The monolithic architecture was popular as it minimizes the
communication overhead across the system processes by
running a single deployable package in a process. A single
deployable package helps in simplifying the overall design of
the application. The problems are related to security and
stability. Maintenance and customization are other issues of
monolithic applications. Monolithic architecture does not
provide the flexibility for upgrades and changes. The
components in the package are tightly coupled. It will run in
a single process, and memory will be shared across the
components. The development of new requirements and
enhancements will be tough. The reliability of the monolithic
app is low, as a single service error might put down the
whole process.
Now, let us look at microservice architecture.
Microservices architecture
You want to build an application that has functional
requirements. How do you start designing and architecting
using microservices patterns? The services are identified by
the architects and leads involved in the high-level design.
These services can be of different tech stacks, but they have
designed interfaces/APIs/protocols to process and respond
with the required information. The clients can be from a
mobile app, web app, desktop app, or another application’s
API invoking these services. Microservices architecture
consists of patterns from different methodologies like
domain-driven design, polyglot-based services, persistence
mechanisms, and continuous delivery.
Microservices architecture is based on single-responsibility
principles. The single responsibility principle was created by
Robert C. Martin. According to this principle, group the items
that get modified for the same cause and isolate the items

that get modified for different causes. Microservices
architecture uses these principles to identify the functionality
of a microservice. Microservices can talk to each other and
address the functional requirements.
Microservices architecture is popular because the
microservices can be built by different programmers and in
different tech stacks. They can talk to each other using the
same protocols as REST/SOAP/etc. These microservices can
be deployed on different servers. Unlike monolithic
architecture, microservices would not fail with a single error
in a microservice.
You can start working on microservices architecture by
identifying similar business requirements and grouping them
into logical modules first. After identifying logical modules,
the next step is to find a microservice that can serve the
business functions. The microservice needs to give a
business value to the target user. To give an example of an
e-commerce application, we can start with a catalog service,
inventory service, order creation service, order delivery
service, user creation service, user profile service,
recommendation service, and user product review service. A
team can be created for each service and can be built based
on the skills available to the team members. The services
developed should have the capability to communicate with
selected and specified protocols like HTTP, REST, SOAP, and
others.
Data stores can be relational if there is a structure in the
data. No SQL database can be used if there is no structure in
the data. The deployment can be done by any DevOps tool,
which is based on continuous integration and
continuous development (CI/CD). Microservices
architecture helps decentralize an enterprise. The
microservices can communicate using a message queue
enterprise service bus or an orchestration engine. The
services communicate through messages, and messages are

routed to different endpoints of the services. Deployment
can happen on the cloud instances or in different virtual
machines on the in-house servers. Containers also play an
important role in packaging microservices with the tech
stack required for deployment. Swagger documentation,
postman collection, or a wiki page can help in documenting
the microservices. API gateway pattern can be used to
provide an entry point for service clients on mobile, web,
desktop, and other APIs. Microservice discovery and security
are important architectural aspects in an enterprise.
Providing resiliency is an important architectural aspect of
microservices-based enterprise applications. The bulkhead
pattern helps in separating the application aspects into
different groups and provides failover if one of the groups
fails. Circuit breaker pattern is also used to manage failures.
In this pattern implementation, thresholds/limits are set to
ensure that the failure is detected and all further service
requests are responded to with an error. The timeouts are
also configured for multiple retries. For logging, a
centralization approach is used, and tools like Elasticsearch,
Kibana, Logstash, and logging daemon are part of the
solution. Log and statistics aggregation is another pattern
used for the centralization of logging. Now, let us look at the
microservices-based app tech stack:

Figure 11.2: Microservices context
Now, let us look at building a microservices architecture-
based application and services. We are revisiting the
application we discussed in the previous chapter. In that
application, web links can be loaded to analyze the website's
metadata. We can create an RSS feed for the website,
looking at various topics and content covered. RSS feeds can
be updated frequently based on website updates. This
application can be built using the Microservices architecture
style.
You can have web links configured based on your
preferences and the topics selected. Web links can be
scanned to generate RSS feeds topic-wise. The application
will have the capability to add or remove the web links from
the topics. New topics can be added for the application with
web links. RSS feeds can be loaded into the application
based on the topic. Feeds can be stored in a NoSQL database
using a REST-based persistence service for feeds. This
application can be on the cloud serving as a software as a
service.
Users can register using social authentication REST service,
which authenticates with Google/MSN/yahoo/Twitter. Users

can create a profile and preferences with new REST services
for profiles and preferences for users. Feeds can be stored in
the NoSQL database and can be categorized by topic using
the categorization REST service. They can be tagged with
keywords and made searchable for quick access. Cache
service provides the mechanisms that can be used to
improve the retrieval time of the master data or user
preferences and interests.
Another way to speed up the performance is by having in-
memory user-specific feeds for a category selected loaded.
Users can browse them quickly. Scalability is easier as each
of the services we discussed can be deployed on different
servers. Concurrent users can browse the feeds quickly
based on the category selection. In memory, multiple
categories and feeds specific to that category can be loaded.
User profiles can be modified, and demographics are stored
in the NoSQL database using the user profile microservice.
The recommendation REST service helps recommend feeds
for users. Users can access correlated feeds read by other
users. Tags can be selected for feeds, and users can add new
tags to the existing tagged feeds.
Typical demographics of the user gathered are age, gender,
interests, preferences, job/profession, designation, and
others. A recommendation system can be built as a separate
microservice that can be added to the system to provide new
feeds and tags for users. Users will be eager to come back to
the application because new content will be ready to be
processed as recommendations. This can be like AdSense,
where the context of the user can be used based on the
reader’s browsing history of the feeds.
User satisfaction is dependent on the user profile, and other
factors are user profile, content, context, interests, etc. The
recommended feeds are evaluated for performance based on
factors such as click-through rate, stay time, upvotes,

comments, and reposts. Content provided to the user can be
textual information, images/posters, videos, web links, and
documents. This content can have multiple labels. The user-
specific labels can be a category, topic, keyword, source,
community, or vertical labels. User profile-specific labels
include gender, age, location, preferences, interests,
favorites, and bookmarks. User behavior-specific labels can
be browsing time, reading time, staying time, and click-
through analysis. Label generation can be done by using
methods like noise canceling by filtering the content,
penalizing the trends on feeds, using time decaying and
browsing history, using global bias and click rate, and
likes/dislikes/unsubscribes.
In the example above, we have identified the following
microservices:
User Social Authentication Service
User Profile Service
User Preferences Service
User Recommendation Service
Feeds Storage Service
User Registration Service
Microservices in Go
Now, let us revisit the CRM application built on microservices
architecture. We used the Beego web framework to develop
the CRM web application and REST API. Beego framework is
an open-source framework that has application tools, an
object relationship mapping framework, and other packages.
ORM framework brings down the ordeal of developing the
CRM relational schema and mapping it to object classes and
names of the attributes. Beego is used to build CRM
microservices, which are REST APIs. The microservices are

integrated with open-source JavaScript frontend frameworks.
The CRM Beego web application was built using the Beego
microservices and SQLite database. Beego framework helps
develop web apps at an affordable cost.
First, let us look at the code for Go Lang microservices built
using Beego REST API:
main.go
package main
import (
"fmt"
"github.com/gorilla/handlers"
"go_beego_REST_api/pkg/db"
handler "go_beego_REST_api/pkg/handlers"
"log"
"net/http"
"github.com/gorilla/mux"
)
func main() {
r := mux.NewRouter()
DB := db.InitializeDB()
r.HandleFunc("/customers", 
handler.GetCustomers(DB)).Methods("GET")
r.HandleFunc("/create", 
handler.CreateCustomer(DB)).Methods("POST")
r.HandleFunc("/update", 
handler.UpdateCustomer(DB)).Methods("PUT")
r.HandleFunc("/delete", 
handler.DeleteCustomer(DB)).Methods("DELETE")

fmt.Println("Server at 8080")
log.Fatal(http.ListenAndServe(":8080", 
handlers.CORS()(r)))
}
The following figure shows the Beego web app directory
structure:
Figure 11.3: Microservices-based application code artifacts
The above main.go has the code for initializing the ORM and
registering the model. Beego is started in the main method.
This microservice is integrated with the web application.
The following is the code for back-end ORM database calls
for microservice endpoints.
db.go
package db
import (
"fmt"
"github.com/jinzhu/gorm"
_ 
"github.com/jinzhu/gorm/dialects/postgres"
)

func InitializeDB() *gorm.DB {
db, err := gorm.Open("postgres", 
"user=newuser password=newuser dbname=crm 
sslmode=disable")
if err != nil {
fmt.Println(err)
} else {
fmt.Println("DB connected!")
}
return db
}
Handler.go has the code for tableName definition and the
object class specification. Now, let us look at the handler.go
code:
handler.go
package handler
import (
"encoding/json"
"fmt"
"net/http"
"github.com/jinzhu/gorm"
)
type CustomerBody struct {
Name string `json"name"`
}
type Customer struct {
Id      int    `json:"id"`

Name    string `json:"name"`
Mobile  string `json:"mobile"`
Address string `json:"address"`
}
func GetCustomers(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var customers []Customer
_ = 
db.Table("customer").Select("id, 
name,mobile,address").Scan(&customers)
json.NewEncoder(w).Encode(customers)
}
}
func CreateCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var RequestBody CustomerBody
json.NewDecoder(r.Body).Decode(&RequestBody)
_ = 
db.Table("customer").Create(&RequestBody)
fmt.Println("Created Customer")

json.NewEncoder(w).Encode(RequestBody)
}
}
func UpdateCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var PutBody Customer
json.NewDecoder(r.Body).Decode(&PutBody)
_ = 
db.Table("customer").Where("id=?", 
PutBody.Id).Update("name", 
PutBody.Name).Scan(&PutBody)
fmt.Printf("Updated Customer with 
id %d\n", PutBody.Id)
json.NewEncoder(w).Encode(PutBody)
}
}
func DeleteCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var DeleteBody Customer
json.NewDecoder(r.Body).Decode(&DeleteBody)

_ = 
db.Table("customer").Delete(&DeleteBody)
fmt.Printf("Deleted Customer with 
id %d\n", DeleteBody.Id)
json.NewEncoder(w).Encode(DeleteBody)
}
}
Now, let us look at the database script to create a table in
the Postgres CRM database. You can use the following
commands to create a Postgres database CRM and users:
psql -h localhost -d postgres
----
ALTER USER postgres PASSWORD 'postgres';
CREATE USER newuser with PASSWORD 'newuser' 
CREATEDB;
select * from users;
\du
\l
\q
-----
createdb crm
psql -h localhost -d postgres
\c crm
CREATE TABLE "customer" (
    "id"  SERIAL,
    "name" varchar(200) NOT NULL,

    "mobile" varchar(100),
    "address" varchar(400) DEFAULT NULL,
    "notes" text,
    UNIQUE (name)
);
\dt
\du
alter role newuser superuser;
create user newuser with password 'newuser';
grant all privileges on database crm to newuser;
alter role newuser superuser;
Now, let us look at the Database SQL for creation of the
schema:
Database
CREATE TABLE "customer" (
    "id" serial,
    "name" varchar(200) NOT NULL,
    "mobile" varchar(100),
    "address" varchar(400) DEFAULT NULL,
    "notes" text,
    UNIQUE (name)
);
create user newuser with password 'newuser';
grant all privileges on database crm to newuser;
Now, let us look at the routes configured in index.go for the
microservice.

The following table shows the routes/paths mentioned in the
index.go. These paths are for customer management
microservices.
Action
Controller
method
Http
method
URL route
Description
Create
Add
POST
/create
Create a new
customer
Read
getAll
GET
/customers
Retrieve list of
customers
Delete
Delete
DELETE
/delete
Delete a
customer
Update
Update
PUT
/update
Update a
customer
Table 11.1: Routes and Paths Mapping
You can run the Beego REST API server by using the following
commands:
go mod init go_beego_REST_api
go mod tidy
The output of the REST API server execution is as follows:
Figure 11.4: Output of the REST API server execution
Now, let us look at another example where a microservice
communicates with a message Queue. We have seen this
example in the previous chapter. Let us revisit this in the
microservices context. We built this Go Lang microservice in
Chapter 4, Building REST API. In this context of building Go
Service docker, let us relook at how to develop REST API,
which can interact with message queues. We are going to

use Gin and RabbitMQ. Now, let us look at the Gin REST API
interacting with web applications and the database:
Figure 11.5: Go Lang microservices based on Gin REST API
Now, let us look at the code for developing Microservices
based on REST API using Gin and RabbitMQ:
main.go
package main
import (
"fmt"
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"REST_api_mq/producer/config"
"REST_api_mq/producer/utils"
)

func init() {
mode := utils.GetEnvVar("GIN_MODE")
gin.SetMode(mode)
}
func main() {
appGin := config.CreateApp()
addrGin := utils.GetEnvVar("GIN_ADDR")
portGin := utils.GetEnvVar("GIN_PORT")
log.Info().Msgf("App is up at 
http//:%s:%s", addrGin, portGin)
if error := appGin.Run(fmt.Sprintf("%s:%s", 
addrGn, portGin)); error != nil {
log.Fatal().Err(error).Msg("Http 
Server setup failed")
}
}
Now, let us look at the createApp to see how the routes are
set up through routers:
Creating_app.go
package config
import (
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"REST_api_mq/producer/middlewares"
"REST_api_mq/producer/routers"
)
func CreateApp() *gin.Engine {

log.Info().Msg("service starting")
app := gin.New()
app.Use(gin.Recovery())
app.SetTrustedProxies(nil)
log.Info().Msg(" cors, request id, request 
logging middleware added")
app.Use(middlewares.CORSMiddleware(), 
middlewares.RequestID(), 
middlewares.RequestLogger())
log.Info().Msg("routers setup")
routers.SetupRouters(app)
return app
}
The router package has the routes mapped to methods that
talk to the message queue:
Get   /ping     controllers.ping
Post /publish/example controllers.Example
Now, let us look at the setup.go code.
setup.go
package routers
import (
"github.com/gin-gonic/gin"
"REST_api_mq/producer/controllers"
)
func CreateRouters(engine *gin.Engine) {
version1 := engine.Group("/v1")
{

version1.GET("/ping", 
controllers.Ping)
version1.POST("/publish/example", 
controllers.Example)
}
}
The controllers package has the message publisher
configured to publish messages to a message queue. Now,
let us look at the controllers.go code:
controllers.go
package controllers
import (
"net/http"
"github.com/gin-gonic/gin"
"github.com/rs/zerolog/log"
"REST_api_mq/producer/environment"
"REST_api_mq/producer/models"
"REST_api_mq/producer/utils"
func Example(context *gin.Context) {
var msg models.Message
request_id := context.GetString("x-request-
id")
if binderr := context.ShouldBindJSON(&msg); 
binderr != nil {
log.Error().Err(binderr).Str("request_id", 
request_id).

Msg("Error occurred while 
binding request data")
context.JSON(http.StatusUnprocessableEntity, gin.H{
"message": binderr.Error(),
})
return
}
connectionString := 
utils.GetEnvVar("RMQ_URL")
producer := utils.MessagePublisher{
environment.EXAMPLE_QUEUE,
connectionString,
}
producer.PublishMessage("text/plain", 
[]byte(msg.Message))
context.JSON(http.StatusOK, gin.H{
"response": "Message received from 
REST API",
})
}
MessagePublisher is a struct defined in the utils package.
Its method publishes messages to a queue defined in the
environment. Now, let us look at the publisher.go code:
Publisher.go
package utils
import (
"github.com/rs/zerolog/log"

"github.com/streadway/amqp"
)
type MessagePublisher struct {
Queue            string
ConnectionString string
}
func (x MessagePublisher) OnError(err error, msg 
string) {
if err != nil {
log.Err(err).Msgf("Publishing 
message error '%s' queue. Error message: %s", 
publisher.Queue, msg)
}
}
func (publisher MessagePublisher) 
PublishMessage(contentType string, body []byte) {
conn, error := 
amqp.Dial(publisher.ConnectionString)
publisher.OnError(error, "RabbitMQ not 
connected")
defer conn.Close()
channel, err := conn.Channel()
publisher.OnError(err, "Channel not 
opened")
defer channel.Close()
q, error := channel.QueueDeclare(
publisher.Queue,
false,

false,
false,
false,
nil,
)
publisher.OnError(error, "Queue Not 
declared")
error = channel.Publish(
"",
q.Name,
false,
false,
amqp.Publishing{
ContentType: contentType,
Body:        body,
})
publisher.OnError(error, "message not 
published")
}
Now, let us look at the consumer package:
main.go
package main
import (
"REST_api_mq/consumer/environment"
"REST_api_mq/consumer/handlers"
"REST_api_mq/consumer/utils"

)
func main() {
connectionString := 
utils.GetEnvVar("RMQ_URL")
messageQueue := utils.MessageConsumer{
enviornment.EXAMPLE_QUEUE,
connectionString,
handlers.HandleMessaage,
}
forever := make(chan bool)
go messageQueue.Consume()
<-forever
}
MessageConsumer is created from the utils package:
Message_consumer.go
package utils
import (
"github.com/rs/zerolog/log"
"github.com/streadway/amqp"
)
type MessageConsumer struct {
Queue            string
ConnectionString string
MsgHandler       func(queue string, msg 
amqp.Delivery, err error)
}

func (consumer MessageConsumer) OnError(errors 
error, msg string) {
if errors != nil {
consumer.MsgHandler(consumer.Queue, 
amqp.Delivery{}, errors)
}
}
func (consumer MessageConsumer) Consume() {
conn, err := 
amqp.Dial(consumer.ConnectionString)
consumer.OnError(err, "Failed to connect to 
RabbitMQ")
defer conn.Close()
channel, err := conn.Channel()
consumer.OnError(err, "Failed to open a 
channel")
defer channel.Close()
q, err := channel.QueueDeclare(
consumer.Queue,
false,
false,
false,
false,
nil,
)
consumer.OnError(err, "Failed to declare a 
queue")

msgs, err := channel.Consume(
q.Name,
"",
true,
false,
false,
false,
nil,
)
consumer.OnError(err, "Failed to register a 
consumer")
forever := make(chan bool)
go func() {
for delivery := range msgs {
consumer.MsgHandler(consumer.Queue, delivery, nil)
}
}()
log.Info().Msgf("Started listening- 
messages from '%s' queue", consumer.Queue)
<-forever
}
The environment package has the constants defined for the
Environment file, directory, and message queue. Now, let us
look at the constants.go code:
constants.go
package environment

const ENV_FILE = ".env"
const ENV_FILE_DIRECTORY = "."
const EXAMPLE_QUEUE = "message_queue"
.env has the Rabbit message queue configuration URL and
Log level. Now, let us look at the environment file:
.env
LOG_LEVEL = debug
RMQ_URL = amqp://guest:guest@localhost:5000/
Each microservice shown above is an independent
deployable unit that can be tested and loosely coupled.
Microservice can consist of small services built and used in
the framework for different features. A small team can build
microservices architecture-based applications very easily
and quickly. Agile process and microservices go together well
in making the development of features meet the time to
market. Polyglot microservices architecture style embraces
different tech stacks like Java, Python, Go Lang, PHP, and
.NET.
Microservice architecture provides benefits such as code
readability, component decentralization, continuous
integration, test automation, continuous deployment, and
domain-driven design.
Containerized Go microservices
Containers help in packaging microservices and make them
portable. The isolation of the microservices can be done by
using containers like Docker and Kubernetes. Microservices
that are modular can be deployed on different containers
and scaled separately based on the load requirements for
each microservice. Containers help in making microservices
more agile, flexible, and scalable. They can be enhanced and
maintained easily for upgrades and new requirements. There

are issues with containers that are related to authorization,
authentication, monitoring, and data consistency of the
microservices. Containers can be orchestrated using
Kubernetes or Docker Swarm, which provide features such as
service monitoring, load balancing, service discovery, and
service management. Container-based microservices can
talk to each other using messaging/event-driven
architecture/API gateways/service discovery patterns. Data
consistency can be achieved in container-based
microservices by using patterns like event sourcing, eventual
consistency, database per microservice, and distributed
transactions. Security in containers can be improved using
secure containers, role-based access controls, data
encryption, and network security. Now, let us look at the
containerized microservices and their features:
Figure 11.6: Containerized microservices
Kubernetes is a popular container for cluster pod capability. A
Kubernetes pod wraps the container instances. A pod with an

IP address can talk to other pods in the Kubernetes cluster.
Microservices-based architecture can be implemented using
a pod that has an app container, message broker, and proxy
sidecar container to talk to the other microservices. A
microservices container is different from a web container or
an application server container. Container-based
microservices perform well in maintaining the CPU/Disk/IO
utilization for the load requirements.
We looked at the containerized Go REST API. Let us revisit
this example in the context of microservices. Docker is used
for the deployment of the Go Lang microservices. In the
following example, we will look at how to develop REST API
(dockerized microservice), which can interact with message
queues. We are going to use Gin and RabbitMQ.
The environment package has the constants defined for the
Environment file, directory, and message queue. Now, let
us look at the constants.go code:
constants.go
package environment
const ENV_FILE = ".env"
const ENV_FILE_DIRECTORY = "."
const EXAMPLE_QUEUE = "message_queue"
.env will Rabbit message queue configuration URL 
and Log level.
.env
LOG_LEVEL = debug
RMQ_URL = amqp://guest:guest@localhost:5000/
Now, let us look at the docker-compose.yaml file:
docker-compose.yaml
networks:

  rabbitmq-example:
    driver: bridge
services:
  rabbitmq:
    image: 'rabbitmq:3-management'
    networks:
      - rabbitmq-example
    volumes:
      - ./rabbit-
mq/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    ports:
      - "8080:15672"
    healthcheck:
      test: [ "CMD", "rabbitmqctl", "status"]
      interval: 5s
      timeout: 15s
      retries: 5
  producer:
    build: ./producer
    ports:
      - "5050:5050" 
    networks:
      - rabbitmq-example
    depends_on:
      - rabbitmq
    environment: 

      GIN_MODE: "release"
      GIN_HTTPS: "false"
      GIN_ADDR: "0.0.0.0"
      GIN_PORT: "5050"
      LOG_LEVEL: "debug"
      RMQ_URL: "amqp://guest:guest@rabbitmq:5673/"
  consumer:
    build: ./consumer
    networks:
      - rabbitmq-example
    depends_on:
      - rabbitmq
    RESTart: on-failure
    environment: 
      LOG_LEVEL: "debug"
      RMQ_URL: "amqp://guest:guest@rabbitmq:5673/"
You can now compile and run the rabbitmq, producer, and
consumer services in the docker. The command to run the
Docker is as follows:
     docker-compose up
The output will be as follows:

Figure 11.7: Output of Docker Compose Up command
In the above example, we have used docker-compose to
build a Go Lang microservice based on MQ.
Conclusion
In this chapter, we have covered topics related to monolithic
architecture, Microservices architecture, Go Lang-based
microservices, and containerized Go Lang microservices.
Monolithic applications are architected by creating a package
of components that can be deployable on a server in a single
process. Microservices architecture helps in building
distributed microservices deployed on different servers and
can communicate using REST/HTTP/SOAP/Messaging. Go
Lang frameworks Beego, Gin, and others can be used to
build microservices-based applications. Docker and
Kubernetes can be used to package the Go Lang
microservices.

In the next chapter, the readers will learn how to build
security services like authentication, authorization,
encryption, and identity management. The readers will know
about Cross-Site Request Forgery (CSRF) prevention
middleware. The readers can understand the security
principles to build scalable and secure web applications.

CHAPTER 12
Adding Security and IAM
Introduction
In this chapter, the reader will understand basic security
services, advanced security services, security principles, and
secure web applications. The reader will understand how to
add security and identity access management to the
microservices architecture.
Figure 12.1: Microservices security

As shown in the figure above, microservices architecture-
based web applications are built using advanced and basic
security services. All security services are based on the
fundamental security principles.
Structure
The chapter covers the following topics:
Basic security services
Advanced security services
Security principles
Securable web applications
Securing REST API
Objectives
In this chapter, readers will understand how to build basic
and advanced security services. They will also know how to
prevent Cross-Site Request Forgery (CSRF), Denial of
Service (DDOS), and other security attacks. Readers can
also understand the security principles to build scalable,
failproof, resilient, distributed, and secure microservices-
based apps.
Basic security services
To recap, microservices are a group of similar requirements-
based implementations to services. Each service can be
deployed as a package that is independent. Monolithic
applications are not modular but can be deployed as a single
package. Any change impacts the redeployment of the whole
package. The challenges are related to the security of the
independent modules which are deployed as microservices.
The security issues are related to the open loopholes in

security implementation or third-party packages used to
secure the services. Each microservice needs to be protected
by using security controls. Security is important in how the
microservices communicate with each other.
Basic security services like authentication and authorization
need to be implemented first as separate services, which are
the first entry point for any client request. Access control
checks need to be implemented by capturing the details of
who can invoke a particular service. Role-based access
control and attribute-based access controls are popular
security patterns implemented for protecting the
microservices.
Banks, financial services, and insurance companies rely
heavily on information technology in their operations, and as
a result, there is a massive number of users of cryptography
to help guarantee the authenticity, integrity, and
confidentiality of the information ecosystem. Now, let us look
at the user identity management features:
Figure 12.2: User identity management features
Role-based access control is popular in enterprises. User
privileges for different applications need to be managed with
the roles they play in that line of business. Different access

management tools are being adopted and developed by the
enterprise to manage the enterprise's role-based user
privileges. Users' authorization and authentication are based
on the roles that they play in the enterprise and the
particular line of business that the user belongs to. Now, let
us look at the RBAC and the layers in the model:
Figure 12.3: RBAC: Different layers in the model
RBAC-based security models provide various features like
Authentication, Privilege Management, Entitlement
Management, Policy Management, Secrets management,
and identity management. This system can provide
capabilities for self-service, self-registration, and managing
direct entitlements to different applications in the enterprise.

Figure 12.4: RBAC based system features
As shown above, the RBAC system features help in
implementing the security for the microservices over the
above basic security requirements like authentication and
authorization.
Intra-organizational communications sent within the
corporate network or between data centers for information
transfer, backup, and disaster recovery need to be
protected. Typically, these systems are implemented as
hardware or software AES encryption and are vulnerable in
the respect that they use a public key system of key
distribution. Interbank financial messaging across the SWIFT
network is used to transfer payment orders, allowing for
standardized, encrypted transactions between different
banks around the world.

SWIFT operates a public key infrastructure to sign and
encrypt messages sent over SWIFTNet digitally. Crucially,
these messages are based on digital signatures and
encryption algorithms.
Credit card information is protected according to the
Payment Card Industry Data Security Standard
(PCIDSS). Cardholder data is typically encrypted for
transmission, for example, at a point of sale prior to
transmission to the bank. This encryption utilizes symmetric
key cryptography. However, the keys are exchanged using
public key cryptosystems.
Stored data such as tapes and hard disks are encrypted by
organizations for secure offsite archiving. These solutions are
typically based on hardware AES encryption. Online banking
relies upon the TLS protocol to secure web traffic, and server
authentication happens using X.509 certificates, RSA public
keys, and session key establishment.
Now, let us look at advanced security services.
Advanced security services
We have seen microservices communicating through HTTP,
HTTPS, REST, SOAP, and messaging protocols. In the
application architecture based on microservices,
microservices are integrated to work together for high-level
business use. Every microservice can be executed in a
separate container and in its own specific process. To
operate this specific application, we need system admin,
database admin, cloud-specific admin, and API gateway
manager access through IT systems.
We have seen basic security services like authentication and
authorization based on user credentials and roles. Securing
the credentials and having a password policy for expiry and
complexity are important in authentication services. User

lock policy based on retries and ensuring request rate limits
are configured with thresholds to avoid Denial of Service
attacks on the services. For authentication, two factor
authentication can be implemented to improve secure
access by having password and OTP as the methods.
Authentication services need to have a password reset policy
and notification mechanism. SSL-based security mechanisms
can be implemented, and the communication will be based
on HTTPS. Managing the SSL certificates is an important
application management and monitoring administration
procedure.
Microservices are secured by having API keys with expiry and
Access policies like whitelisting IP addresses, secure secret
keys, and private VPN based access. Security testing of the
services is done to prevent SQL injection, cross-site
scripting/forgery, sensitive data loss, failed authentication,
failed authorization, and failed access control. Penetration
security testing helps in avoiding data loss issues and
improves the environment’s integrity. DevSecOps is
important to ensure security while adding new requirements
and deploying new microservices or modifying existing
microservices.
Microservices communication needs to be secured with SSL,
TLS and mTLS protocols. The data over the wire needs to be
protected to avoid tampering of the information and sniffing
of the network packets. Security is important in packaging
the microservices in the container like Docker, Vagrant, and
Kubernetes. The container images need to be monitored and
updated to avoid loopholes related to security.
Application monitoring and management tools like Grafana,
Prometheus, New Relic, Data Dog, and others help in
identifying the loopholes from a security perspective. An
operational plan to react to a problem needs to be in place. A
team needs to focus on root cause analysis of the issue and
identify if it is a security or functionality-related issue. If it is

a security issue, the problem needs to be simplified to
ensure smooth and regular operations. Postmortem of the
issue needs to be conducted to identify the root cause of the
problem and to avoid the same in the future. A security
database needs to be created, and it needs to be updated
regularly for DevSecOps to execute the security checks.
Since microservices can be distributed, security needs to be
addressed at each microservice level, and the deployed
environment needs to be protected. API gateway pattern is
implemented to ensure a single entry point to check the
requests for API Key/credentials/vulnerability issues.
Gateway can be used for enforcing usage policies like
metering, subscription models, and role-based access.
Now, let us look at the security principles that are important
for microservices.
Security principles
Basic security principles like policy-based access, system
integrity, DevSecOps, and shift-left approach are applicable
to microservices architecture. As we discussed,
microservices are independent by design and can be
deployed in a distributed environment. Apps that are
microservice-based architecture have a higher attack surface
and a higher number of services that need to be secured.
The shift-left approach helps in securing microservices
architecture-based applications. Security testing and
performance testing need to be very early in the software
development life cycle. DevSecOps Tools help secure the
code while the microservices are developed, built, and
deployed. The development team and operations work
together in unit testing the software and deploying it after
checking for security issues. Static analysis and dynamic
analysis methods are used for security testing. Static
analysis tools help identify the loopholes in the software and

the dependent packages. Dynamic analysis involves
simulation of the security threat-based attack. Security
testing helps in securing the microservices that operate on
the important information that is sensitive. Information
security best practices are used to protect sensitive data like
credit cards, identity information, bank accounts, etc.;
authentication services and authorization services are
evolving with new methods like multi-factor authentication
and fine-grained access control for authorization.
Different standards have evolved for microservices
architecture, such as SAML, WS-Fed, OpenID, OAuth, OAuth2,
and multi-factor authentication. Declarative authorization
helps define detailed access control for microservices. API
gateways will be the first point of entry for all the services.
Zero trust network defines the services to be requested with
minimum privileges to start with for a client request. All
admin and super user accounts need to be avoided for client
requests. Secrets need to be managed with a secured secret
manager. Secure resources need to be separated from the
zones of authentication and authorization services.
Securable web applications
To secure web applications that are based on microservices-
based architecture, we need to follow the prescribed best
practices for security.
Let us first look at the classic public key infrastructure.
Public key infrastructure
This is used for managing digital certificates. Public key
infrastructure (PKI) provides public and private keys.
Public keys are tough to protect against misuse. PKI
infrastructure in an enterprise needs to protect the private
key and ensure the public keys are available and accessible.
A PKI system consists of a registration authority, a

certification authority, certification management, and private
key management.
One key concern in PKI is How do you ensure that the person
who has the public key belongs to your enterprise.
There is always a threat of man in the middle, such as
sniffing attacks, phishing, and others, which can break the
PKI infrastructure and operations. Certification authorities,
public key certificate management, and registration
authorities need to send updates regularly to ensure identity
is managed in the digital world. Outdated requests or
requests with outdated tokens can be rejected for
authorization and authentication. New quantum algorithms
can help in securing the tokens as it is tough to break the
crypto algorithms. Now, let us look at the different types of
Digital Certificates:
Figure 12.5: Digital Certificates and different types

Digital Certificates can be of different types: Class 1, Class 2,
Class 3, and Class 4. Class 1 is based on the email address of
the requesting user. Class 2 requires more information about
the requested user. Class 3 is issued after user identity is
verified. Class 4 certificates are used by enterprises and
companies. The specifications are as follows:
Class 1: These can be obtained by only providing the
email address.
Class 2: These need more personal information.
Class 3: This first checks the identity of the person
making a request.
Class 
4: 
They 
are 
used 
by 
organizations 
and
governments.
PKI provides various features which are useful for enterprises
and companies. Now, let us look at the use cases of PKI:
Figure 12.6: PKI use cases
PKI infrastructure and operations help in providing data
encryption, access rights management, network security

management, digital signing of software, Wi-Fi access
management, and enterprise device identity management.
SSL/TLS certificates
Today, the gaps in SSL/TLS certificates are in network
visibility, automation of Trust Services, and limited use of
Agile best practices. Digital certificates can be deployed as
X.509 certificates that enable the use of popular encryption
algorithms.
SSL/TLS certification authorities provide certification
management and the issuance of new certificates over
expiry. These certificates provide Secure Sockets Layer
security to protect data in transit over the internet. Browsers
are protected using SSL protocol for websites, and users can
safely send private and business data. Transport Layer
Security and Secure Sockets Layer security are important in
the enterprise security tech stack. The secured handshake
ensures the network passage of the data to be transmitted
from source to destination.
Code signing
Code signing is deploying digital signatures to software
applications and hardware-based design firmware. In this
process, cryptographic algorithms are used to develop High-
Assurance seals to help authenticate the software and
hardware. This will help prevent code hacking by making
sure only the code owner and authorized users can sign into
their code development repositories.
There are several improvements that need to be made in the
software engineering and development process, audit and
quality assurance, and control in terms of compliance.
Cryptographic algorithms can support RSA, ECDSA, LMS, and
XMSS hash-based signatures, AES encryption, HMAC-KDF,
CMAC, RSAES-OAEP, and PKCS #11 key wrapping.

Code signing is about having a secure pair of keys to sign a
code package. The certification authority needs to identify
the key used for signing and verify the identity of the
software package provider. Enterprises use code signing to
protect themselves from trojan attacks, operating system
attacks, and others. Users can abort the installation upon
finding a non-verifiable code package before installation.
Now, let us look at the code verification mechanism details:
Figure 12.7: Code verification mechanism
Code signing happens with a private key, as the key cannot
be modified or tampered with. The signature block of code
signature consists of a digest and code signing certificate
and has a function. Code package authentication happens
when the package is downloaded to the computer. The
secure digest is decrypted, and a hash function is used to

derive the developer’s digest. The digest is verified with the
decrypted data and authenticated as safe.
Application code signing
Code signing is the process of applying digital to application
software or to hardware-based device hardware. This method
creates a high assurance seal through cryptographic
algorithms that can be deployed to authenticate whether the
application software created by a trusted provider has not
been tampered with.
Currently, traditional application code signings use RSA or
ECDSA-based key pairs to sign and verify the software. There
is a good scope to start using quantum-resistant application
code signing that uses algorithms that are programmed to
be resistant to quantum computer-based attacks. This can
help secure applications and devices from future attacks.
Application developers use code signing to attach a unique
digital signature to either the software or the hardware
device. This approach ensures the authenticity and integrity
of the operating system, software applications, and hardware
devices, which verify a trusted digital signature to
authenticate and authorize the source of the code and
confirm if the code has not been altered. Now, let us look at
how code signing works:

Figure 12.8: How code signing works
Enterprises are looking for code signing and authentication
software. They are also adopting new hardware security
modules and the latest encryption tools. Quantum
algorithms need to be used to ensure that these techniques
are quantum-safe.
SSH keys
Key issues in SSH key management are access control, key
spread, key rotation, and maintaining communication
secrecy. What will be required is a Key Exchange (KEX)
Algorithm within SSH to help with quantum safety. This will
help protect long-term secrets, sensitive customer data, and
other network protocols like IPsec. In this case, the

responsibility of establishing a secure channel will be based
on Key Exchange. Now, let us look at how SSH keys are used
for user authentication to get server access:
Figure 12.9: SSH keys user authentication for server access
In a cloud-based enterprise, you will come across SSH keys
for different cloud providers’ access. Different tools and
packages are used to provide access and secure
transmission of data from enterprise systems to the cloud.
SSH protocol was invented by Tatu Ylonen in 1995. He
developed it to tackle a sniffing attack on the university
network. SSH keys are based on the RSA 2048-bit encryption
model. The length of the password will be 617 if it is based
on SSH keys. SSH key is a pair of keys that has private and
public keys.
In addition to the cryptographic inventory, it is
recommended that an inventory of application cryptography
threats in the enterprise and a playbook for handling these
threats be built. Now, let us look at the different types of
threats:
Application data over-collection threat: Hidden and
unwarranted collection of personal data needs to be
identified, 
tracked, 
recorded, 
and 
aligned 
with

applicable data and privacy laws. Compliance checks
need to be done regularly to ensure this data is
updated to avoid this threat.
Application linkage threat: Several customer-facing
apps 
hold 
a 
variety 
of 
data, 
thereby 
creating
unwarranted data results by different systems. This
can lead to the linkage of personal data through data
mapping and correlation. Data security systems need
to be in place to avoid linked personal data being
stolen on the cloud or on-premises.
Identification threat: Identity user creation leads to
the association of confidential, sensitive, and personal
data in the form of name, address, gender, and physical
signatures (voice, face). The associated personal data
with 
biometrics 
and 
demographics 
need 
to 
be
protected using monitoring software and auditing the
data access.
Application lifecycle transitions leakage: Leakage
of user personal information from devices in a certain
stage of their application access lifecycle when the
devices are not under owner (user) control. Agents
need to be installed in the devices to monitor user
behavior. User behavior analytics helps prevent data
leakage and predict leakage when it is going to
happen.
Privacy-violating interactions and presentation
leakage: The presentation of user data through
various channels, like voice and video screens, could be
placed in the public domain. This could lead to the
disclosure of user-sensitive information without any
safeguards in place. Sensitive data needs to be
protected.
Localization data leakage: Un-intended leakage of a
user’s location by Global Positioning System (GPS)

coordinates, IP addresses, latency, or cell phone
location. The user’s location can be used for analyzing
and 
recommending 
the 
enterprise 
products 
and
services available at the location. User location needs
to be subscribed by the services with the user’s
permission.
Behavioral 
leakage: 
Unauthorized 
tracking 
and
recording of user’s behavior in a certain time and
place. In the case of default user monitoring,
compliance violations need to be flagged and escalated
for changing the defaults.
Tracking attack: An attacker can trace and record a
person’s movement through time and space (based on
localization 
or 
behavioral 
leakages 
and 
user
identification). An abnormal tracing or recording of a
user’s location needs to be alerted, and an attack can
be prevented before the user’s privacy is violated.
Profiling attack: It is possible for a fraudster to create
duplicate profiles to analyze information about users
and infer their inteRESTs by mapping their profiles and
data. Sniffing of data through the network and
phishing attacks try to use the profile to imitate the
user or a company. Different software is available to
prevent sniffing and phishing attacks.
Inventory attack: An attacker can fire up selective
query requests to the database and analyze the related
responses to determine inteRESTing patterns of users
in the form of unauthorized detection of health issues,
intellectual property, and industrial espionage. Any
leakage of information that is flagged as an IP issue
needs to be escalated and monitored by the enterprise
legal department.
Identity-theft attack: A hacker can steal user identity
(credentials) and misuse their financial and business

services, damaging a given user’s reputation. User
identity needs to be protected by having user identity
governance and identity management solutions in the
enterprise.
Trust exchange
Trust exchange helps provide authentication mechanisms-
based platforms for all systems in an enterprise. This
platform creates a network of players in the enterprise and
the capability to create sub-networks within the network.
Trust can be generated through digital certificates across
applications by unifying process tasks for the issuance, re-
issuance, installation, configuration, and renewal of public
TLS/SSL, verified mark, code signing, document signing, and
user and S/MIME certificates all in one central place.
Digital certificates can be of different types: Class 1, Class 2,
Class 3, and Class 4. Class 1 is based on the email address of
the requesting user. Class 2 requires more information from
the requested user. Class 3 is issued after user identity is
verified. Class 4 certificates are used by enterprises and
companies. Now, let us look at the unification of digital
certification process tasks:

Figure 12.10: Digital certificates unification of process tasks
The renewal of the digital certificates depends on various
certification steps, as shown in the following figure:
Figure 12.11: Digital certificates unification of process tasks
Code signing is the process of deploying digital signatures to
software applications and hardware-based design firmware.
In this process, cryptographic algorithms are used to develop
high-assurance seals to help authenticate the software and
hardware. This will help prevent code hacking by making
sure only the code owner and authorized users can sign in to
their code development repositories.
Digital certificates are based on the basic certificate chain of
trust model. Certificate chaining builds trust between the
end, intermediate, and root entities. Now, let us look at the
chain of trust with digital certificates:
Figure 12.12: Digital certificates certificate chain of trust
The advanced model of the certificate chain of trust is to
have a root trust store. The root certificate trust store can
issue group certificates and manage private key-based

certificates. Trust models based on certificate chains are of
three types: hierarchical, web of trust, and bridge certificate
authority architecture. Now let us look at the different trust
models:
Figure 12.13: Trust models
Let us consider a hypothetical scenario for the example.
Alice and Bob are friends living in different places. They work
in different companies and want to exchange information.
Alice and Bob's information exchange is based on trust. Trust
exchange, when applied with different mechanisms, as
shown in Figure 12.14, helps secure information exchange
between Alice and Bob:

Figure 12.14: Trust exchange-based information sharing
Now, let us look at the digital certificate account profile
management. The first step is to set up digital certificate
account profile management. Now, let us look at the profile
menus:
Figure 12.15: My Profile
Through the Profile Settings page, we can perform the
following Profile management actions:

User personal information (Name, Role, Contact, Job
Title, etc.)
Account information (username, password, email, and
security question)
API keys
Account language preference
Now, let us look at the profile management features:
Figure 12.16: Profile Management
Digital certificate orchestration management will help set up
the unified management for the following processes:
Ordering of user certificate
Re-issuance of user certificate

Renewal of user certificate
Cancel pending user certificate orders
Cancel pending user certificate reissues
User certificate revocation process
Resending email validation for client certificate email
Resending the create user certificate email
Turning on user certificate renewal notifications
Configuration of the user certificate approval process
Generation of the user certificate
Configuration of Email Security Plus Personal ID
Certificate
Figure 12.17: Digital certificate orchestration management

Digital certificate orchestration management goes through
the process steps as shown in Figure 12.17. Now, let us look
at the SAML certificate orchestration management.
Security assertion markup language (SAML) certificate
orchestration management will help connect the identity
provider (IdP) with CertCentral so that non-CertCentral
account users can use their single sign-on (SSO)
credentials to order a client certificate. A SAML admin
certificate Orchestration Management will help set up the
unified management for the following processes:
SAML certificate workflow for requests with pre-
requirement details
SAML certificate requests service workflow
SAML request for a certificate workflow
Configuration of SAML certificate requests
Turning off SAML certificate requests
RESToration of access to SAML certificate requests
accounts
Request process for a user certificate
Generation of user certificate
Downloading a copy of your user certificate
Submission of a request to revoke a user certificate
Resending the create user certificate email
Allow access to SAML settings

Figure 12.18: SAML admin certificate orchestration management
SAML admin certificate orchestration is based on the steps
shown in Figure 12.18. Now, let us look at the Trust
Certificate Lifecycle Management.
Setting up the Trust Certificate Lifecycle Management is
based on the following points:
Setup of agent: Installation of Trust Certificate
software on Server/Cloud for Certificate Automation
Management.
Setup of business unit: Organisational units will be
defined. This will help in segment definition and
allocation of certificate issuance and management.
Setup of Trust Certificate: A Trust Certificate will
enhance Digital Trust for authentication, validation,
and encryption of digital resources.
Setup 
of 
Trust 
Certificate 
Profile: 
A 
set 
of
predefined Certificate Template options on rules for
Format and issuance of a particular type of certificate.

Setup of Certificate Template: These are required
for foundational records, which help as a starting point
for creation of Trust certificate Profiles
Trust Certificate Connector: End-to-end complete
Trust Lifecycle Management for external accounts,
applications, and certificate authorities connected to
user account
DNS integration: Trust-based integrated application
used for validation checks of DNS-based domain
Trust Certificate Enrolment: Certificate requests by
a 
user 
based 
on 
Trust 
Certificate 
Life 
Cycle
Management
Trust Certificate Integration: Unified Integration
across all external software, devices, and connectors
that are accessible and continuously validated
Issuing Trust Certificate: Unified management is
needed 
for 
the 
root 
or 
intermediate 
certificate
authority to issue end-entity certificates. This will help
manage certificates from a variety of issuing CAs.
Lifecycle management: Tracking public and private
certificates through enrolment, issuance, expiration,
and renewal, as well as revocation and reissuance.
Seat 
and 
License 
Management: 
License
management 
across 
On-Prem 
and 
cloud-based
infrastructure
Sensor: Trust Certificate will be installed on enterprise
networks to discover and automate the management of
certificates on network appliances and cloud services.
Sensor connection: A physical network appliance or
cloud service that connects to a sensor for the purpose
of trust certificate lifecycle management. Additionally,
any application (for example, a DNS integration) that

connects to the sensor facilitates the automation of
lifecycle events.
Figure 12.19: Trust Certificate Lifecycle Management
Figure 12.19 shows the different steps in the Trust Certificate
Lifecycle Management workflow.
Real-life examples
Trust exchange is used in social enterprises and community
groups. Trust exchange provides the following features to the
social enterprises:
Tracking of product specifications
Artifact management
Supplier assessments and scoring
Regulation and compliance requirements
Collaboration between enterprise and suppliers

Monitoring and management of systems
Artifact template management
Realtime notifications about products and services
Realtime tracking of orders and delivery
Granular entitlements for supplier users
Organization model and roles management
Message and alert management
Supplier performance management
Another real-life example where trust exchange can play an
important role is the real estate management system. Trust
exchange features which impact the users are listed as
follows:
Real estate application management
Real estate document management
Visibility and tracking of applications
Task management
Real-time collaboration between real estate sellers and
buyers
Digital certificate management
Application alerts management
Event reporting
Bulk SMS and Email campaigns
Buyers and owners of KYC
Secured message delivery
Another real-world example is in the healthcare domain.
Trust exchange plays an important role by providing the
features listed for healthcare centers listed as follows:

Doctors, 
patients, 
staff, 
and 
nurses 
identity
management
Emergency alerts for patients and staff
Information security and trust management
Health center user authentication and authorization
Search 
capability 
for 
retrieving 
documents 
and
artifacts
Maintain compliance standards for data security and
storage
Multiple-factor authentication for web, mobile, and
desktop applications
Secured tracking and monitoring of intruders
Intrusion detection and prevention system capabilities
User identity governance and data governance
Securing REST API
We are revisiting the CRM microservices example from
Chapter 7, Go Real Life Applications—CRM. In this section,
we are going to enhance it with authorization and
authentication of the REST API. Now, let us look at the
main.go code:
main.go
package main
import (
"fmt"
"go_beego_REST_api/pkg/db"
handler "go_beego_REST_api/pkg/handlers"
"log"

"net/http"
"github.com/gorilla/mux"
)
func main() {
r := mux.NewRouter()
DB := db.InitializeDB()
r.HandleFunc("/customers", 
handler.GetCustomers(DB)).Methods("GET")
r.HandleFunc("/create", 
handler.CreateCustomer(DB)).Methods("POST")
r.HandleFunc("/update", 
handler.UpdateCustomer(DB)).Methods("PUT")
r.HandleFunc("/delete", 
handler.DeleteCustomer(DB)).Methods("DELETE")
fmt.Println("Server at 9090")
server := http.Server{
Addr:    ":9090",
Handler: handler.SecureHandler(r),
}
log.Fatal(server.ListenAndServe())
}
The following figure shows the Beego web app directory
structure:

Figure 12.20: REST API example
The above main.go has the code for initializing the ORM and
registering the model. Beego is started in the main method.
Now, let us look at the db.go code:
db.go
package db
import (
"fmt"
"github.com/jinzhu/gorm"
_ 
"github.com/jinzhu/gorm/dialects/postgres"
)
func InitializeDB() *gorm.DB {
db, err := gorm.Open("postgres", 
"user=newuser password=newuser dbname=crm 
sslmode=disable")
if err != nil {
fmt.Println(err)
} else {
fmt.Println("DB connected!")

}
return db
}
handler.go has the code for tableName definition and the
object class specification:
handler.go
type CustomerBody struct {
Name string `json"name"`
}
type Customer struct {
Id      int    `json:"id"`
Name    string `json:"name"`
Mobile  string `json:"mobile"`
Address string `json:"address"`
}
GetCustomers method
func GetCustomers(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var customers []Customer
_ = 
db.Table("customer").Select("id, 
name,mobile,address").Scan(&customers)
json.NewEncoder(w).Encode(customers)

}
}
CreateCustomer method
func CreateCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var RequestBody CustomerBody
json.NewDecoder(r.Body).Decode(&RequestBody)
_ = 
db.Table("customer").Create(&RequestBody)
fmt.Println("Created Customer")
json.NewEncoder(w).Encode(RequestBody)
}
}
UpdateCustomer method
func UpdateCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var PutBody Customer
json.NewDecoder(r.Body).Decode(&PutBody)

_ = 
db.Table("customer").Where("id=?", 
PutBody.Id).Update("name", 
PutBody.Name).Scan(&PutBody)
fmt.Printf("Updated Customer with 
id %d\n", PutBody.Id)
json.NewEncoder(w).Encode(PutBody)
}
}
DeleteCustomer method
func DeleteCustomer(db *gorm.DB) http.HandlerFunc {
return func(w http.ResponseWriter, r 
*http.Request) {
w.Header().Set("Content-Type", 
"application/json")
var DeleteBody Customer
json.NewDecoder(r.Body).Decode(&DeleteBody)
_ = 
db.Table("customer").Delete(&DeleteBody)
fmt.Printf("Deleted Customer with 
id %d\n", DeleteBody.Id)
json.NewEncoder(w).Encode(DeleteBody)
}
}
SecureHandler method
func SecureHandler(hthandler http.Handler) 
http.HandlerFunc {

return func(rwriter http.ResponseWriter, rq 
*http.Request) {
error := godotenv.Load(".env")
if error != nil {
log.Fatalf("Error loading 
environment variables file")
}
user, pass, ok := rq.BasicAuth()
if ok {
userid := 
sha256.Sum256([]byte(os.Getenv("USER_ID")))
password := 
sha256.Sum256([]byte(os.Getenv("PASSWORD")))
userIdHash := 
sha256.Sum256([]byte(user))
passwordHash := 
sha256.Sum256([]byte(pass))
validUserName := 
subtle.ConstantTimeCompare(userIdHash[:], 
userid[:]) == 1
validPassword := 
subtle.ConstantTimeCompare(passwordHash[:], 
password[:]) == 1
if validPassword && 
validUserName {
hthandler.ServeHTTP(rwriter, rq)
return
}

}
http.Error(rwriter, "No/Invalid 
Credentials", http.StatusUnauthorized)
}
}
Now, let us look at the database script to create a table in
postgres crm database. You can use the following
commands to create a postgres database CRM and users:
psql -h localhost -d postgres
----
ALTER USER postgres PASSWORD 'postgres';
CREATE USER newuser with PASSWORD 'newuser' 
CREATEDB;
select * from users;
\du
\l
\q
-----
createdb crm
psql -h localhost -d postgres
\c crm
CREATE TABLE "customer" (
    "id"  SERIAL,
    "name" varchar(200) NOT NULL,
    "mobile" varchar(100),
    "address" varchar(400) DEFAULT NULL,
    "notes" text,

    UNIQUE (name)
);
\dt
\du
alter role newuser superuser;
create user newuser with password 'newuser';
grant all privileges on database crm to newuser;
alter role newuser superuser;
Now, let us look at the database sql for the creation of the
schema:
Database
CREATE TABLE "customer" (
    "id" serial,
    "name" varchar(200) NOT NULL,
    "mobile" varchar(100),
    "address" varchar(400) DEFAULT NULL,
    "notes" text,
    UNIQUE (name)
);
create user newuser with password 'newuser';
grant all privileges on database crm to newuser;
Now, let us look at the routes configured in index.go.
The following table shows the routes/paths mentioned in the
index.go:
Action
Controller
method
Http
method
URL route
Description

Create
Add
POST
/create
Create a New
Customer
Read
getAll
GET
/customers
Retrieve list of
customers
Delete
Delete
DELETE
/delete
Delete a
Customer
Update
Update
PUT
/update
Update a
Customer
Table 12.1: Routes and Paths in index.go
You can run the Beego REST API server by using the following
commands:
go mod init go_beego_REST_api
go mod tidy
go build
The output of the REST API server execution is as follows:
Figure 12.21: go_beego_rest_api output
Unit testing the REST API
In this section, we will investigate how postman is used for
unit testing of the REST API. You can test the API unit using
Postman. The Postman collection can be imported using the
JSON provided in the code.
Create Customer

Now let us look at the create customer REST API.
Figure 12.22: Create Customer API
Postman can be used to test the REST API. In Figure 12.22,
the customer is created with a post-method-based REST API
call.
Get Customers
Now, let us look at the Get Customers REST API and the
output when the API is invoked:

Figure 12.23: Get Customers API
Now, let us look at creating another customer and the output
when the API is invoked:

Figure 12.24: Create Customer API Result
Now, let us look at the list of customers created and the
output when the API is invoked:

Figure 12.25: Get Customers after the creation of a customer
Figure 12.25 shows all customers retrieving the results from
a GET method REST API call.
Update Customer
Now, let us look at updating the existing customer and the
output when the API is invoked.

Figure 12.26: Update Customer API
Now, let us look at updating another customer after setting
the authorization info and the output when the API is
invoked.
Figure 12.27: Update Customer Result

Figure 12.27 shows how postman is used for updating the
customer. PUT method-based REST API is used for updating
the customer in the CRM portal. Now, let us look at the list of
the customers and the output when the API is invoked:
Figure 12.28: Get Customers after Update Customer
Delete Customer
Now, let us look at deleting a customer and the output when
the API is invoked:

Figure 12.29: Delete Customer API
Now, let us look at deleting the customer after setting the
authorization info and the output when the API is invoked.
Figure 12.30: Delete Customer Result

DELETE Method-based REST API is called using Postman for
deleting a customer, as shown in Figure 12.29.
Get Customers after Delete
Now let us look at the list of customers after deleting a
customer and the output when the API is invoked:
Figure 12.31: Get Customers after Delete Customer
Figure 12.31 shows the list of customers after update and
delete operations.
Conclusion
In this chapter, we have covered topics related to basic and
advanced security services. We looked at security principles
for protecting microservices.
We looked at basic and advanced security services to secure
the microservices. Different security mechanisms and
principles were discussed relevant to microservices security.

You learned about methods to secure web applications built
on microservices-based architecture. We discussed an
example to secure the REST API-based microservices.
In the next chapter, readers will understand different design
patterns, such as creational, structural, and behavioral
patterns. Code samples will be provided for the Gang of Four
Design patterns. The readers will also understand object-
oriented design principles using Go.

CHAPTER 13
Go Design Patterns—Part1
Introduction
In this chapter, we look at design patterns like creational,
structural, and behavioral design patterns based on Gang of
Four (GOF) design patterns. Code samples are presented for
the GOF design patterns. The readers will understand object-
oriented design principles using the Go language by learning
GRASP principles. Let us look at the Go Design Patterns
related to creation and structure of objects:
Figure 13.1: Design Patterns in Go Lang
Structure
The chapter covers the following topics:

Creational design patterns
Structural design patterns
Objectives
In this chapter, we are going to look at design patterns in Go
Lang. Design patterns help resolve issues with solutions that
make the design easy and the applications can scale. The
term GOF patterns is related to a book written by four
different authors. This book was written in 1994 and was
titled Design Patterns: Elements of Reusable Object-Oriented
Software. Go Lang solutions can be built using these design
patterns.
Creational design patterns
You can use creational design patterns to design class
creators and object instantiations. These patterns help in
instantiating objects agnostic of the class to which the object
belongs. The creational design patterns are as follows:
Abstract factory
Builder
Factory method
Prototype
Singleton
Let us first look at abstract factory patterns.
Abstract factory pattern
You can use the abstract factory pattern to create a group of
objects with commonalities. An interface is defined for
instantiating the group of objects agnostic of the class to
which the object belongs. Let us look at an example of
creating truck objects. Truck has an interface with

NumOfTyres and GetModelName methods. Let us look at the
truck interface:
package main
import (
"fmt"
)
const (
CivilType = 1
)
const (
RuggedModel   = 1
StandardModel = 2
)
type Truck interface {
NumOfTyres() int
GetModelName() string
}
TruckFactory is an interface to create truck objects. You can
have CivilTruckFactory, which implements the Truck
Factory interface:
type TruckFactory interface {
Create(t int) (Truck, error)
}
type CivilTruckFactory struct{}
type RuggedModelType struct{}
func (f *RuggedModelType) NumOfTyres() int {

return 6
}
func (f *RuggedModelType) GetModelName() string {
return "Rugged"
}
type StandardModelType struct {
}
func (f *StandardModelType) NumOfTyres() int {
return 6
}
func (f *StandardModelType) GetModelName() string {
return "Standard"
}
func (i *CivilTruckFactory) Create(t int) (Truck, 
error) {
switch t {
case RuggedModel:
return new(RuggedModelType), nil
case StandardModel:
return new(StandardModelType), nil
}
return nil, fmt.Errorf("There are no trucks 
of type %d\n", t)
}
func CreateAbstractFactory(c int) (TruckFactory, 
error) {

switch c {
case CivilType:
return new(CivilTruckFactory), nil
default:
return nil, fmt.Errorf("There is no 
factory with id %d\n", c)
}
}
func main() {
civilT, _ := 
CreateAbstractFactory(CivilType)
truckM, _ := civilT.Create(StandardModel)
truck, ok := truckM.(Truck)
if !ok {
fmt.Errorf("Invalid model")
}
fmt.Printf("%v Truck has %d tyres\n", 
truck.GetModelName(), truck.NumOfTyres())
}
CreateAbstractFacotry method takes the type of the truck
and returns the Truck Factory class.
You can now compile and run the abstract_factory.go.
The command is as follows:
go run abstract_factory.go
The output will be as follows:

Figure 13.2: Abstract Factory example code output
Now, let us look at the builder pattern.
Builder pattern
You can use the builder pattern to create a composite object
that has multiple objects. Let us look at an example: a truck
with multiple tires and an engine with a capacity for driving.
Let us look at the Truck struct code:
package main
import (
"fmt"
"strconv"
)
type Truck struct {
Tyres    int
Capacity int
}
type TruckBuildProcess interface {
SetTyreNumber() TruckBuildProcess
SetCapacity() TruckBuildProcess
GetVehicle() Truck
}
type TruckShopFloor struct {
tbuilder TruckBuildProcess

}
func (f *TruckShopFloor) SetBuilder(tb 
TruckBuildProcess) {
f.tbuilder = tb
}
func (f *TruckShopFloor) Construct() {
f.tbuilder.SetCapacity().SetTyreNumber()
}
TruckBuilder is used to set the tyres and the 
engine capacity.
type TruckBuilder struct {
t Truck
}
func (c *TruckBuilder) SetTyreNumber() 
TruckBuildProcess {
c.t.Tyres = 6
return c
}
func (c *TruckBuilder) SetCapacity() 
TruckBuildProcess {
c.t.Capacity = 4
return c
}
func (c *TruckBuilder) GetVehicle() Truck {
return c.t
}
func (c *TruckBuilder) Build() Truck {

return c.t
}
func main() {
shopFloor := TruckShopFloor{}
truckBuilder := &TruckBuilder{}
shopFloor.SetBuilder(truckBuilder)
shopFloor.Construct()
truck := truckBuilder.Build()
if truck.Tyres != 6 {
fmt.Errorf("It is wrong that : " + 
strconv.Itoa(truck.Tyres) + " tyres found")
} else {
fmt.Printf("Truck has " + 
strconv.Itoa(truck.Tyres) + "  tyres\n")
}
}
TruckBuilder is used on the shop floor to create a truck
with multiple tires and an engine with the capacity to drive.
You can now compile and run the builder_example.go. The
command is as follows:
go run builder_example.go
The output will be as follows:
Figure 13.3: Builder example code output

Now, let us look at the factory method pattern.
Factory method pattern
You can use the factory method pattern to create objects
that are agnostic to the class that they belong to. An
interface is created for object creation. Let us look at an
example where we can create trucks of different types, such
as rugged and standard models. Let us look at the factory
method pattern example code:
package main
import (
"fmt"
)
const (
RuggedModel   = 1
StandardModel = 2
)
type Truck interface {
NumOfTyres() int
GetModelName() string
}
Truck interface has NumOfTyres and GetModelName 
methods.
func GetTruck(truck int) (Truck, error) {
switch truck {
case RuggedModel:
return new(RuggedModelType), nil
case StandardModel:

return new(StandardModelType), nil
default:
return nil, fmt.Errorf("Not a Known 
Truck Model")
}
return nil, fmt.Errorf("Not implemented 
yet")
}
type RuggedModelType struct{}
func (f *RuggedModelType) NumOfTyres() int {
return 6
}
func (f *RuggedModelType) GetModelName() string {
return "Rugged"
}
type StandardModelType struct {
}
func (f *StandardModelType) NumOfTyres() int {
return 6
}
func (f *StandardModelType) GetModelName() string {
return "Standard"
}
func main() {
truck, err := GetTruck(RuggedModel)
if err != nil {

fmt.Errorf("This model does not 
exist")
}
fmt.Printf("%v Truck has %d tyres\n", 
truck.GetModelName(), truck.NumOfTyres())
}
GetTruck method takes the model type and creates the
truck of different types.
You can now compile and run the factory_example.go. The
command is as follows:
go run factory_example.go
The output will be as follows:
Figure 13.4: Factory example code Output
Now, let us look at the prototype pattern.
Prototype pattern
You can use the prototype pattern to clone objects. This
pattern is useful for creating multiple cloned objects, like a
pool of objects. Let us look at an example of cloning flight
objects.
FlightCloner is the interface that has the GetClone
method, which takes the number of objects to be cloned. Let
us look at FlightCloner interface code:
package main

import (
"fmt"
)
type FlightCloner interface {
GetClone(s int) (ItemInfoGetter, error)
}
const (
Boeing     = 1
Bombardier = 2
Embraer    = 3
)
func GetFlightsCloner() FlightCloner {
return new(FlightsCache)
}
The GetFlightsCloner method returns the FlightCloner.
FlightsCache struct has a method GetClone of flight type.
Flight can be of multiple types like Boeing, Bombardier, and
Embraer. Let us look at the FlightsCache Struct code:
type FlightsCache struct{}
func (s *FlightsCache) GetClone(flight int) 
(ItemInfoGetter, error) {
switch flight {
case Boeing:
newItem := *flightPrototype
return &newItem, nil
}

return nil, fmt.Errorf("Not implemented 
yet")
}
type ItemInfoGetter interface {
GetInfo() string
}
type FlightEngine byte
type Flight struct {
Price  float32
Model  string
Engine FlightEngine
}
func (s *Flight) GetInfo() string {
return "" + s.Model
}
var flightPrototype *Flight = &Flight{
Price:  15.00,
Model:  "777",
Engine: Boeing,
}
func (i *Flight) GetPrice() float32 {
return i.Price
}
func main() {
flightCache := GetFlightsCloner()
if flightCache == nil {

fmt.Errorf("The current cache is 
not valid")
}
firstFlight, err := 
flightCache.GetClone(Boeing)
fmt.Printf("Flight cloned is of Model type 
: %s\n", firstFlight.GetInfo())
if err != nil {
fmt.Println(err)
}
if firstFlight == flightPrototype {
fmt.Errorf("firstitem cannot be 
equal to the white prototype")
}
}
You can now compile and run the prototype_example.go.
The command is as follows:
go run prototype_example.go
The output will be as follows:
Figure 13.5: Prototype example code output
Now, let us look at the singleton pattern.
Singleton pattern

You can use the singleton pattern to have a single instance
of an object. This single instance is accessible at the global
level. It can also be used in a pool with a specified number of
objects. Let us look at the singleton pattern in the code:
package main
import (
"fmt"
"sync"
)
var singlock = &sync.Mutex{}
type singleton struct {
}
var singletonInstance *singleton
func getSingleton() *singleton {
if singletonInstance == nil {
singlock.Lock()
defer singlock.Unlock()
if singletonInstance == nil {
fmt.Println("Creating 
singleton first time")
singletonInstance = 
&singleton{}
} else {
fmt.Println("Singleton 
instance is already created.")
}
} else {

fmt.Println("Single instance 
already created.")
}
return singletonInstance
}
func main() {
for i := 0; i < 30; i++ {
go getSingleton()
}
fmt.Scanln()
}
getSingleton method returns the singleton instance. The
multiple calls will return the single instance after first time
creation.
You can now compile and run the singleton_example.go.
The command is as follows:
go run singleton_example.go
The output will be as follows:

Figure 13.6: Prototype example code output
Now, let us look at the structural design patterns.
Structural design patterns

Developers use structural design patterns to create objects
that belong to large, structured classes. The structural
design patterns are as follows:
Adapter
Bridge
Composite
Decorator
Façade
Let us first look at the adapter design pattern.
Adapter pattern
You can use the adapter pattern when you have different
interfaces, and there is a plan to integrate them to create an
object. The other scenario is when you want to change the
current interface to a prescribed specification.
Let us look at the example of multiple databases and a
single client interface to interact with and query them. The
database interface has the GetDatabaseInfo method, which
gives the name of the current database connected. Let us
look at the MySQL struct code:
package main
import "fmt"
type MySQL struct{}
func (mysql *MySQL) GetDBInfo() {
fmt.Println("MySQL DB")
}
type MySQLAdapter struct {
mysqlServer *MySQL
}

func (mysql *MySQLAdapter) GetDatabaseInfo() {
fmt.Println("MySQL adapter gets DB Info")
mysql.mysqlServer.GetDBInfo()
}
The MySQL database above has implemented the database
interface. Now, let us look at the PostGres database, which
implements the database interface:
type PostGres struct {
}
func (pg *PostGres) GetDatabaseInfo() {
fmt.Println("PostGres")
}
DBClient implements the Database Interface. 
type DBClient struct {
}
func (client *DBClient) GetDatabaseInfo(db 
Database) {
fmt.Println("Client  gets Database Info 
from the specific DB")
db.GetDatabaseInfo()
}
type Database interface {
GetDatabaseInfo()
}
func main() {
client := &DBClient{}
pg := &PostGres{}

client.GetDatabaseInfo(pg)
mysqlServer := &MySQL{}
mysqlAdapter := &MySQLAdapter{
mysqlServer: mysqlServer,
}
client.GetDatabaseInfo(mysqlAdapter)
}
DBClient is instantiated, and multiple databases are created
for the client to query.
You can now compile and run the adapter_example.go. The
command is as follows:
go run adapter_example.go
The output will be as follows:
Figure 13.7: Adapter example code output
Now, let us look at the bridge design pattern.
Bridge pattern
You can use a bridge design pattern to segregate the
interface of an object from the actual implementation. The
goal is to have a loose coupling between the implementation
and the abstraction. Let us look at an example where a SQL

compiler is implemented for Postgres. SQLCompiler is an
interface that executes SQL. Each database might have
different constructs and support for special query syntax.
SQLCompiler is implemented by the PGSQLCompiler. Let us
look at the SQLCompiler interface and PGSQLCompiler struct
implementation in code:
package main
import "fmt"
type SQLCompiler interface {
ExecuteSQL(string)
}
type PGSQLCompiler struct {
}
func (pgc *PGSQLCompiler) ExecuteSQL(sql string) {
fmt.Println("PostGres executing sql- ", 
sql)
}
type PostGres struct {
sqlCompiler SQLCompiler
}
func (pg *PostGres) GetDatabaseInfo() {
fmt.Println("PostGres")
}
func (pg *PostGres) SetSQLCompiler(sql SQLCompiler) 
{
fmt.Println("PostGres setting SQLCompiler")
pg.sqlCompiler = sql
}

func (pg *PostGres) ExecuteSQL(sql string) {
fmt.Println("PostGres executing sql")
pg.sqlCompiler.ExecuteSQL(sql)
}
type Database interface {
GetDatabaseInfo()
SetSQLCompiler(SQLCompiler)
ExecuteSQL(string)
}
func main() {
pg := &PostGres{}
pgsql := &PGSQLCompiler{}
pg.SetSQLCompiler(pgsql)
sql := "Select * FROM Customer"
pg.ExecuteSQL(sql)
}
PostGres database is instantiated, and PGSQLCompiler is
created to set on the PostGres database. You can now
compile and run the bridge_example.go. The command is
as follows:
go run bridge_example.go
The output will be as follows:

Figure 13.8: Bridge example code output
Now, let us look at the composite design pattern.
Composite pattern
Developers use composite patterns to create a class that has
a complicated structure. A car has multiple wheels, an
engine, and other parts. We look at an example where the
composite class is created with different classes for Wheel
and Engine. Let us look at the Car struct code:
package main
import "fmt"
type Car struct {
wheels []Wheel
name   string
engine string
}
func (car *Car) AddWheel(wheel Wheel) {
car.wheels = append(car.wheels, wheel)
fmt.Print("adding :")
wheel.GetType()
}
func (car *Car) GetModel() {
fmt.Println("The Car model is", car.name)

}
type Wheel interface {
GetType()
}
type CarWheel struct {
wheelType string
}
func (wheel *CarWheel) GetType() {
fmt.Println("The wheel type is", 
wheel.wheelType)
}
func main() {
car := new(Car)
car.name = "Toyota Tercel"
wheel1 := &CarWheel{wheelType: "Good year"}
car.AddWheel(wheel1)
wheel2 := &CarWheel{wheelType: "Good year"}
car.AddWheel(wheel2)
wheel3 := &CarWheel{wheelType: "Good year"}
car.AddWheel(wheel3)
wheel4 := &CarWheel{wheelType: "Good year"}
car.AddWheel(wheel4)
car.GetModel()
fmt.Println("The number of wheels in the 
car are :", len(car.wheels))
}

First, wheel objects are created, and then the Car is created
with a model name and engine name. Wheels are added to
the Car to create a Car object.
You can now compile and run the composite_example.go.
The command is as follows:
go run composite_example.go
The output will be as follows:
Figure 13.9: Composite example code output
Now, let us see the decorator pattern.
Decorator pattern
The decorator pattern is used to add functionality to an
object belonging to a class that does not have that
functionality. The class interface will not be modified because
of the decorator pattern. Let us look at an example where
IPhoto is an interface that uses the method of getting a title.
Painting implements the interface IPhoto. We want to add
a YellowFrame to the Painting. YellowFrame struct is
created with the photo object, which implements the IPhoto
interface:

package main
import "fmt"
type IPhoto interface {
getTitle() string
}
type Painting struct {
title string
}
func (paint *Painting) getTitle() string {
return paint.title
}
type YellowFrame struct {
photo IPhoto
}
func (yframe *YellowFrame) getTitle() string {
return yframe.photo.getTitle()
}
func main() {
painting := new(Painting)
painting.title = "Mona Lisa"
yframe := &YellowFrame{photo: painting}
fmt.Println("The tile of the yellowFramed 
painting is ", yframe.getTitle())
}
Painting is created, and the title is set on the painting.
YellowFrame object is created with a painting object that

implements the IPhoto interface.
You can now compile and run the decorator_example.go.
The command is as follows:
go run decorator_example.go
The output will be as follows:
Figure 13.10: Decorator example code output
Now, let us look at the façade design pattern.
Façade pattern
Developers can use the Façade design pattern to design an
interface that consists of multiple interface methods. Let us
now look at the Employee Façade, which has the instances of
Employee, Address, and Profile. These objects are created
using the Façade. They are persisted, modified, and deleted
through this Employee Business Façade. Let us look at the
EmployeeFacade struct code:
type EmployeeFacade struct {
employee *Employee
address  *Address
profile  *Profile
}
func newEmployeeFacade(empName string, line1 
string, line2 string, ssn string) *EmployeeFacade {

fmt.Println("Creating the employee Facade 
components")
employeeFacade := &EmployeeFacade{
employee: newEmployee(empName),
address:  newAddress(line1, line2),
profile:  newProfile(ssn),
}
fmt.Println("Employee Facade created")
return employeeFacade
}
func (empFacade *EmployeeFacade) saveEmployeeBO() {
empFacade.employee.saveEmployee()
empFacade.address.saveAddress()
empFacade.profile.saveProfile()
}
Now, let us look at the Employee struct code.
Employee Struct
type Employee struct {
name string
}
func newEmployee(empName string) *Employee {
return &Employee{
name: empName,
}
}
func (emp *Employee) saveEmployee() {

fmt.Println("Persisting the employee in the 
datastore")
}
Let us look at the Address struct code:
Address Struct
type Address struct {
line1 string
line2 string
}
func newAddress(line1 string, line2 string) 
*Address {
return &Address{
line1: line1,
line2: line2,
}
}
func (address *Address) saveAddress() {
fmt.Println("Persisting the address in the 
datastore")
}
Let us look at the Profile struct code:
Profile Struct
type Profile struct {
ssn string
}
func newProfile(ssn string) *Profile {

return &Profile{ssn: ssn}
}
func (profile *Profile) saveProfile() {
fmt.Println("Persisting theprofile in the 
datastore")
}
func main() {
empFacade := newEmployeeFacade("Jay Smith", 
"200 South Blvd", "Boston, MA 01234", "23211111")
empFacade.saveEmployeeBO()
}
Employee, Address, and Profile objects are created
through the EmployeeFacade and persisted in the datastore
through the EmployeeFacade.
You can now compile and run the facade_example.go. The
command is as follows:
go run facade_example.go
The output will be as follows:
Figure 13.11: Facade example code output

Conclusion
In this chapter, we have covered topics related to the Gang
of Four Design Patterns and Object-oriented Design Patterns.
We have also looked at Creational and Structural Design
Patterns with examples and where they can be applied.
In the next chapter, the behavioral design patterns will be
discussed in detail with context and examples. Object-
oriented design principles and GRASP patterns were also
presented in detail.

CHAPTER 14
Go Design Patterns—Part 2
Introduction
In this chapter, we look at design patterns like creational,
structural, and behavioral design patterns based on Gang of
Four (GOF) design patterns. Code samples are presented for
the GOF design patterns. The readers will understand object-
oriented design principles using the Go language by learning
GRASP principles. Let us look at behavioral and object-
oriented design patterns in Go:
Figure 14.1: Design patterns in Go Lang
Structure
The chapter covers the following topics

Behavioral design patterns
Object-oriented design patterns
Objectives
In this chapter, we are going to look at design patterns in Go
Lang. Design patterns help resolve issues with solutions that
make the design easy and the applications can scale. The
term GOF patterns is related to a book written by four
different authors. This book was written in 1994 and was
titled Design Patterns: Elements of Reusable Object-Oriented
Software. Go Lang solutions can be built using these design
patterns.
Now, let us look at behavioral design patterns.
Behavioral design patterns
Developers use behavioral design patterns to create objects
of classes that perform tasks. The behavioral design patterns
are as follows:
Chain of responsibility
Command
Interpreter
Iterator
Mediator
Memento
Observer
State
Strategy
Template method
Visitor

First, let us look at the chain of responsibility design pattern.
Chain of responsibility pattern
You can use the chain of responsibility design pattern to
create a chain of objects to pass messages, and each object
processes the request. Let us look at an example where
sections in the shopping store are modeled. The customer
goes through different sections. A section is an interface that
has the process and goto methods. Let us look at the
Customer struct code:
package main
import "fmt"
type Customer struct {
name              string
parkingCompleted  bool
securityCompleted bool
trialCompleted    bool
paymentCompleted  bool
welcomeCompleted  bool
}
type PaymentCounter struct {
next Section
}
func (c *PaymentCounter) process(customer 
*Customer) {
if customer.paymentCompleted {
fmt.Println("Customer has paid the 
bill")

}
fmt.Println("PaymentCounter getting money 
from customer")
}
func (pc *PaymentCounter) goTo(next Section) {
pc.next = next
}
type Section interface {
process(*Customer)
goTo(Section)
}
type SectionBase struct {
nextSection Section
}
The customer goes through the welcome, parking, trial, and
payment sections to complete the shopping journey. Let us
look at the Trial struct code:
type Trial struct {
next Section
}
func (tr *Trial) process(customer *Customer) {
if customer.trialCompleted {
fmt.Println("Customer has completed 
the trial")
tr.next.process(customer)
return
}

fmt.Println("Trial performed by the 
customer")
customer.trialCompleted = true
tr.next.process(customer)
}
func (tr *Trial) goTo(next Section) {
tr.next = next
}
type Security struct {
next Section
}
func (sec *Security) process(customer *Customer) {
if customer.securityCompleted {
fmt.Println("Customer has completed 
the parking")
sec.next.process(customer)
return
}
fmt.Println("Security check performed to 
the customer")
customer.securityCompleted = true
sec.next.process(customer)
}
func (sec *Security) goTo(next Section) {
sec.next = next
}

Let us look at the Parking struct code:
Parking struct
type Parking struct {
next Section
}
func (pr *Parking) process(customer *Customer) {
if customer.parkingCompleted {
fmt.Println("Customer has completed 
the parking")
pr.next.process(customer)
return
}
fmt.Println("Parking completed by the 
customer")
customer.parkingCompleted = true
pr.next.process(customer)
}
func (pr *Parking) goTo(next Section) {
pr.next = next
}
Let us look at the Welcome struct code:
Welcome struct
type Welcome struct {
next Section
}
func (wel *Welcome) process(customer *Customer) {

if customer.welcomeCompleted {
fmt.Println("Customer was 
welcomed")
wel.next.process(customer)
return
}
fmt.Println("Customer is getting welcomed")
customer.welcomeCompleted = true
wel.next.process(customer)
}
func (wel *Welcome) goTo(next Section) {
wel.next = next
}
func main() {
pc := &PaymentCounter{}
trial := &Trial{}
trial.goTo(pc)
security := &Security{}
security.goTo(trial)
parking := &Parking{}
parking.goTo(security)
customer := &Customer{name: "John Smith"}
welcome := &Welcome{}
welcome.goTo(parking)
welcome.process(customer)
}

A chain of sections is created to process customers who
come into the shopping store. The customer goes through
different sections, and each section processes the
customer's request for parking, security check, product trial,
and payments.
You can now compile and run the
chain_of_responsibility_example.go. The command is as
follows:
               go run chain_of_responsibility 
_example.go
The output will be as follows:
Figure 14.2: Chain of responsibility pattern example code output
Now, let us look at the command design pattern.
Command pattern
Developers can use the command design pattern to model
operations that need to be processed. The goal is to have a
loose coupling between the operation and the actual
implementation. Let us look at the implementation of this
pattern in the case of the mobile phone. The command
interface has a process method. Multiple keys on the phone
exist like On, Off, Dial, and the characters/numbers. Each key
is a command to be executed on the mobile phone. The how

part depends on the mobile phone vendor. Command pattern
helps in decoupling the process part from the mobile phone
interface. Let us look at the command interface and
MobilePhone struct implementation in code:
package main
import "fmt"
type Command interface {
process()
}
type MobilePhone struct {
isOn bool
}
func (p *MobilePhone) switchOn() {
p.isOn = true
fmt.Println("The mobile is on")
}
func (p *MobilePhone) switchOff() {
p.isOn = false
fmt.Println("The mobile is off")
}
func (p *MobilePhone) dial() {
if p.isOn {
fmt.Println("The mobile is dialing 
the number")
}
}

The phone interface has methods such as switchOn,
switchOff, and dial. Let us look at the Phone interface and
Key struct implementation in the code:
type Phone interface {
switchOn()
switchOff()
dial()
}
type Key struct {
command Command
}
func (b *Key) press() {
b.command.process()
}
type SwitchOnCommand struct {
phone Phone
}
func (sw *SwitchOnCommand) process() {
sw.phone.switchOn()
}
type SwitchOffCommand struct {
phone Phone
}
func (sw *SwitchOffCommand) process() {
sw.phone.switchOff()
}

type DialCommand struct {
phone  Phone
number string
}
func (dial *DialCommand) process() {
dial.phone.dial()
}
func main() {
mobile := &MobilePhone{}
onCommand := &SwitchOnCommand{
phone: mobile,
}
offCommand := &SwitchOffCommand{
phone: mobile,
}
dialCommand := &DialCommand{
phone:  mobile,
number: "321191911",
}
onKey := &Key{
command: onCommand,
}
onKey.press()
dialKey := &Key{
command: dialCommand,

}
dialKey.press()
offKey := &Key{
command: offCommand,
}
offKey.press()
}
The MobilePhone object is created, and commands with
keys are created for the mobile phone interface. Each key is
pressed, and the commands get executed to respond to the
key.
You can now compile and run the command_example.go. The
command is as follows:
               go run command_example.go
The output will be as follows:
Figure 14.3: Command pattern example code output
Interpreter pattern
You can use the interpreter design pattern to have a class to
interpret a language.

Let us look at an example where the lexer struct has
methods getNumTokens, process, and the other methods to
analyze the sentences. Let us look at the lexer struct
implementation in code:
package main
import (
"errors"
"fmt"
"strconv"
"strings"
)
type lexer struct {
sentence string
}
func (i *lexer) getNumTokens() []string {
return strings.Split(i.sentence, " ")
}
func (i *lexer) process() int {
sum := 0
tokens := i.getNumTokens()
for k, item := range tokens {
if item == "*" {
fmt.Println(i.getNumTokens())
a, _ := 
strconv.Atoi(string(tokens[k-1]))

b, _ := 
strconv.Atoi(string(tokens[k+1]))
return a * b
}
if item != "+" {
number, _ := 
strconv.Atoi(item)
sum += number
}
}
return sum
}
func keyedStrMap() map[string]string {
var m map[string]string
m = make(map[string]string)
m["+"] = "plus"
return m
}
func (i *lexer) has(s string) bool {
m := keyedStrMap()
if _, ok := m[s]; ok {
return true
}
return false
}
func (i *lexer) checkNormal(s string) error {

if s == "normal" {
return errors.New("non va")
}
i.sentence = s
return nil
}
func (i *lexer) getCountWords() int {
s := i.getNumTokens()
return len(s)
}
Lexer has methods to count the number of words in the
sentences and process the sentence for natural language
grammar. Let us look at the code of how lexer is
instantiated and is used for natural language processing:
func main() {
sentence := "This is a sentence"
lex := lexer{}
lex.checkNormal(sentence)
fmt.Println("No of words in a sentence", 
lex.getCountWords())
if lex.getCountWords() != 2 {
fmt.Println("sentence has more than 
2 words")
}
sentence = "6 * 8"
lex.checkNormal(sentence)
val := lex.process()

fmt.Println("Product of 6 and 8 is", val)
if val != 48 {
fmt.Println([]string{
"Multiplication between 6 
and 8",
"shouldnt be",
strconv.Itoa(val),
})
}
}
In the above example, multiplication is expressed as in
English as the product of two numbers. This expression is
processed by the lexer to give the product.
You can now compile and run the intrepreter_example.go.
The command is as follows:
               go run intrepreter _example.go
The output will be as follows:
Figure 14.4: Interpreter pattern example code output
Now, let us look at the iterator design pattern.

Iterator pattern
You can use the iterator design pattern to process a group of
objects in order. This can be done agnostic of the class to
which the object belongs. Let us see an example of an
Iterator interface created to traverse the group of objects
in order. Let us look at the iterator interface and collection
interface code:
package main
import "fmt"
type Iterator interface {
hasNext() bool
getNext() *Customer
}
type Collection interface {
newIterator() Iterator
}
Customer struct and CustomerCollection are defined.
CustomerCollection has newIterator method to create an
Iterator. Let us look at Customer struct and
CustomerCollection struct in code:
type Customer struct {
name string
ssn  string
}
type CustomerCollection struct {
customers []*Customer
}

func (cc *CustomerCollection) newIterator() 
Iterator {
return &CustomerIterator{
customers: cc.customers,
}
}
type CustomerIterator struct {
index     int
customers []*Customer
}
func (ci *CustomerIterator) hasNext() bool {
if ci.index < len(ci.customers) {
return true
}
return false
}
func (ci *CustomerIterator) getNext() *Customer {
if ci.hasNext() {
customer := ci.customers[ci.index]
ci.index++
return customer
}
return nil
}
CustomerIterator has methods to traverse an array of
Customers, as follows:

func main() {
customer1 := &Customer{
name: "Andy Gerberg",
ssn:  "321324234",
}
customer2 := &Customer{
name: "Bill Lalelle",
ssn:  "3213223538",
}
customerCollection := &CustomerCollection{
customers: []*Customer{customer1, 
customer2},
}
citerator := 
customerCollection.newIterator()
for citerator.hasNext() {
customer := citerator.getNext()
fmt.Println("Customer is ", 
customer.name)
}
}
Customer objects are created to form a
customerCollection. CustomerCollection has the method
newIterator to create an iterator. The iterator has methods
hasNext, and getNext.
You can now compile and run the interator_example.go.
The command is as follows:
               go run iterator_example.go

The output will be as follows:
Figure 14.5: Iterator pattern example code output
Now, let us look at the mediator design pattern.
Mediator pattern
You can use the mediator design pattern to have loose
coupling between the mediator object and the objects that
interact and communicate with the mediator.
Let us see an example where the mediator interface has
methods canLand and notifyAboutTakeOff:
package main
import "fmt"
type Mediator interface {
canLand(Plane) bool
notifyAboutTakeOff()
}
type Plane interface {
land()
takeOff()
allowLanding()
}

The plane interface has the methods land, takeOff, and
allowLanding. Let us look at AirTrafficController struct
in code:
type AirTrafficController struct {
isRunwayFree bool
planeQueue   []Plane
}
func newAirTrafficController() 
*AirTrafficController {
return &AirTrafficController{
isRunwayFree: true,
}
}
func (s *AirTrafficController) canLand(t Plane) 
bool {
if s.isRunwayFree {
s.isRunwayFree = false
return true
}
s.planeQueue = append(s.planeQueue, t)
return false
}
func (s *AirTrafficController) notifyAboutTakeOff() 
{
if !s.isRunwayFree {
s.isRunwayFree = true
}

if len(s.planeQueue) > 0 {
firstPlaneInQueue := 
s.planeQueue[0]
s.planeQueue = s.planeQueue[1:]
firstPlaneInQueue.allowLanding()
}
}
AirTrafficController struct implements the mediator
pattern and has the planeQueue. Let us look at the
PassengerPlane struct code:
type PassengerPlane struct {
mediator Mediator
}
func (g *PassengerPlane) land() {
if !g.mediator.canLand(g) {
fmt.Println("PassengerPlane: 
Landing stopped, waiting")
return
}
fmt.Println("PassengerPlane: Landed")
}
func (g *PassengerPlane) takeOff() {
fmt.Println("PassengerPlane: Leaving")
g.mediator.notifyAboutTakeOff()
}
func (g *PassengerPlane) allowLanding() {

fmt.Println("PassengerPlane: Landing 
permitted, Landing")
g.land()
}
PassengerPlane has the mediator object, and messages
were notified to the mediator object to process. Let us look
at how AirTrafficController is instantiated and used:
func main() {
airTrafficController := 
newAirTrafficController()
passengerPlane1 := &PassengerPlane{
mediator: airTrafficController,
}
passengerPlane2 := &PassengerPlane{
mediator: airTrafficController,
}
passengerPlane1.land()
passengerPlane2.land()
passengerPlane1.takeOff()
}
You can now compile and run the mediator_example.go.
The command is as follows:
               go run mediator_example.go
The output will be as follows:

Figure 14.6: Mediator pattern example code output
Now, let us look at the memento design pattern.
Memento pattern
Developers can use the memento design pattern to persist
and retrieve an object's state. The following memento
example has the state information as the struct property:
package main
import "fmt"
type Memento struct {
state string
}
func (m *Memento) retrieveState() string {
return m.state
}
type AssociateManager struct {
mementoArray []*Memento
}
func (c *AssociateManager) append(m *Memento) {

c.mementoArray = append(c.mementoArray, m)
}
func (c *AssociateManager) find(index int) *Memento 
{
return c.mementoArray[index]
}
type Manager struct {
state string
}
func (e *Manager) newMemento() *Memento {
return &Memento{state: e.state}
}
func (e *Manager) retrieveMemento(m *Memento) {
e.state = m.retrieveState()
}
func (e *Manager) update(state string) {
e.state = state
}
func (e *Manager) retrieveState() string {
return e.state
}
Manager and AssociateManager objects are created. The
application's state is passed on from the branch manager to
the assocManager. The state is retrieved from the
AssociateManager through a memento pattern. Let us look
at how AssociateManager is instantiated and used:
func main() {

assocManager := &AssociateManager{
mementoArray: make([]*Memento, 0),
}
branchManager := &Manager{
state: "state1",
}
fmt.Println("Manager Current State is", 
branchManager.retrieveState())
assocManager.append(branchManager.newMemento())
branchManager.update("state2")
fmt.Println("Manager Current State is", 
branchManager.retrieveState())
assocManager.append(branchManager.newMemento())
branchManager.update("state3")
fmt.Println("Manager Current State is", 
branchManager.retrieveState())
assocManager.append(branchManager.newMemento())
branchManager.retrieveMemento(assocManager.find(1))
fmt.Println("Restored to State is", 
branchManager.retrieveState())
branchManager.retrieveMemento(assocManager.find(0))
}

The above example shows how an account application is
processed in a bank from the branch manager to the
associate manager. The branch manager can retrieve the
application's state from the associate manager.
You can now compile and run the memento_example.go. The
command is as follows:
               go run memento_example.go
The output will be as follows:
Figure 14.7: Memento pattern example code output
Now, let us look at the observer design pattern.
Observer pattern
You can use the observer design pattern to design a class to
observe the objects of the other class and how the object’s
state changes. Let us look at an example where Observer
and Subject interfaces are defined:
package main
import "fmt"
type Observer interface {
refresh(string)
retrieveIdentifier() string

}
type Subject interface {
addObserver(observer Observer)
removeObserver(observer Observer)
updateAll()
}
Student type is defined with ObserverList as a property.
Student struct implements the Subject interface. Let us
look at the Student struct in code:
type Student struct {
observerList []Observer
name         string
allocated    bool
}
func newStudent(name string) *Student {
return &Student{
name: name,
}
}
func (s *Student) updateAvailability() {
fmt.Println("Teacher is not allocated to 
Student", s.name)
s.allocated = true
s.updateAll()
}
func (s *Student) addObserver(o Observer) {

s.observerList = append(s.observerList, o)
}
func (s *Student) removeObserver(o Observer) {
s.observerList = 
removeFromlist(s.observerList, o)
}
func (s *Student) updateAll() {
for _, observer := range s.observerList {
observer.refresh(s.name)
}
}
func removeFromlist(observerList []Observer, 
observerToRemove Observer) []Observer {
observerListLength := len(observerList)
for i, observer := range observerList {
if 
observerToRemove.retrieveIdentifier() == 
observer.retrieveIdentifier() {
observerList[observerListLength-1], observerList[i] 
= observerList[i], observerList[observerListLength-
1]
return 
observerList[:observerListLength-1]
}
}
return observerList
}

Teacher struct implements the Observer interface. Let us
look at the Teacher struct in code:
type Teacher struct {
id string
}
func (t *Teacher) refresh(itemName string) {
fmt.Println("Sending email to teacher", 
t.id)
}
func (t *Teacher) retrieveIdentifier() string {
return t.id
}
func main() {
student := newStudent("Nick Jordan")
teacher1 := &Teacher{id: 
"teacher1@gmail.com"}
teacher2 := &Teacher{id: 
"teacher2@gmail.com"}
student.addObserver(teacher1)
student.addObserver(teacher2)
student.updateAvailability()
}
The Student and Teacher objects are created. Teachers are
added to the students as observers. The student can notify
and update his availability by sending an email.
You can now compile and run the observer_example.go.
The command is as follows:
               go run observer_example.go

The output will be as follows:
Figure 14.8: Observer pattern example code output
Now, let us look at the state design pattern.
State pattern
You can use a state design pattern to create an object and
modify the object’s state. This pattern helps in changing the
object’s behavior. The following code shows the State
interface, which has requestMoney, insertMoney, and
dispenseMoney methods. ATM struct has multiple states and
money as the property:
package main
import "fmt"
type State interface {
requestMoney(int)
insertMoney(int)
dispenseMoney(int)
}
type ATM struct {
hasMoney       State
noMoney        State

MoneyRequested State
presentState State
money int
}
func newATM(money int) *ATM {
atm := &ATM{
money: money,
}
hasMoneyState := &HasMoneyState{
atm: atm,
}
moneyRequestedState := 
&RequestedMoneyState{
atm: atm,
}
noMoneyState := &NoMoneyState{
atm: atm,
}
atm.setState(hasMoneyState)
atm.MoneyRequested = moneyRequestedState
atm.hasMoney = hasMoneyState
atm.noMoney = noMoneyState
return atm
}
ATM implements the State interface by having methods
requestMoney, insertMoney, and dispenseMoney. Let us

look at the ATM implementation of the state interface in
code:
func (atm *ATM) requestMoney(money int) {
atm.presentState.requestMoney(money)
}
func (atm *ATM) insertMoney(money int) {
atm.presentState.insertMoney(money)
}
func (atm *ATM) dispenseMoney(money int) {
atm.presentState.dispenseMoney(money)
}
func (atm *ATM) setState(s State) {
atm.presentState = s
}
func (atm *ATM) incrementMoney(money int) {
fmt.Println("Adding money", money)
atm.money = atm.money + money
if atm.money > 0 {
atm.setState(atm.hasMoney)
}
}
func (atm *ATM) decrementMoney(money int) {
fmt.Println("Decreasing money", money)
if money <= atm.money {
atm.money = atm.money - money
if atm.money == 0 {

atm.setState(atm.noMoney)
}
} else {
fmt.Println("Not enough money to 
decrement")
}
}
HasMoneyState, NoMoneyState, and RequestedMoneyState
structs are defined in the following code. Each of these
structs implements a State interface:
type HasMoneyState struct {
atm *ATM
}
func (i *HasMoneyState) requestMoney(money int) {
if money <= i.atm.money {
fmt.Println("Money in ATM", 
i.atm.money)
} else {
fmt.Println("Not Enough money in 
ATM", i.atm.money)
}
}
func (i *HasMoneyState) dispenseMoney(money int) {
fmt.Println("Money dispense in progress", 
money)
i.atm.decrementMoney(money)
}

func (i *HasMoneyState) insertMoney(money int) {
fmt.Println("Money is there- not added", 
i.atm.money)
}
type NoMoneyState struct {
atm *ATM
}
func (i *NoMoneyState) requestMoney(money int) {
if money <= i.atm.money {
fmt.Println("Money in ATM")
} else {
fmt.Println("Not Enough money in 
ATM")
}
}
func (i *NoMoneyState) dispenseMoney(money int) {
fmt.Println("No money")
}
func (i *NoMoneyState) insertMoney(money int) {
fmt.Println("Money is added now", money)
i.atm.incrementMoney(money)
}
type RequestedMoneyState struct {
atm *ATM
}

func (i *RequestedMoneyState) requestMoney(money 
int) {
fmt.Println("Money requested", money)
}
func (i *RequestedMoneyState) dispenseMoney(money 
int) {
fmt.Println("dispense will start soon")
}
func (i *RequestedMoneyState) insertMoney(money 
int) {
fmt.Println("Money is requested and it 
cannot be added")
}
ATM is created with the newATM method by specifying the
initial money as ten units. Let us look at how ATM is
instantiated and used:
func main() {
atm := newATM(10)
atm.requestMoney(10)
atm.dispenseMoney(10)
atm.insertMoney(500)
}
In the above example, a request for ten units of money is
sent. ATM dispenses ten units of money. 500 units of money
are inserted in the ATM.
You can now compile and run the state_example.go. The
command is as follows:
               go run state_example.go

The output will be as follows:
Figure 14.9: State pattern example code output
Now, let us look at the strategy design pattern.
Strategy pattern
You can use the strategy design pattern to create a group of
techniques, approaches, and methods and implement any of
them when required. Let us see an example where the
DeductionStrategy interface is defined with getDeduction
methods. Product struct has deductionstrategy as the
property. Let us look at DeductionStrategy interface in the
code:
package main
import "fmt"
type DeductionStrategy interface {
getDeduction(int) int
}
type Product struct {
name              string
deductionStrategy DeductionStrategy

cost              int
}
func (prod *Product) getCost() {
prod.cost = prod.cost - 
prod.deductionStrategy.getDeduction(prod.cost)
fmt.Println("Cost of the Product after 
deduction", prod.cost)
}
FixedDeduction and PropDeduction strategies are created
with fixed cost deduction and proportionate deduction,
respectively. Let us look at FixedDeduction struct in code:
type FixedDeduction struct {
}
func (deduction *FixedDeduction) getDeduction(cost 
int) int {
return 10
}
type PropDeduction struct {
}
func (deduction *PropDeduction) getDeduction(cost 
int) int {
return int(10 * cost / 100)
}
func main() {
fixedDeduction := &FixedDeduction{}
propDeduction := &PropDeduction{}
product1 := &Product{name: "IPad", 
deductionStrategy: propDeduction, cost: 30000}

product1.getCost()
product2 := &Product{name: "Diary", 
deductionStrategy: fixedDeduction, cost: 30}
product2.getCost()
}
FixedDeduction and PropDeduction objects are created.
Product object is created with name and proportionate and
fixed deduction. In both cases, getCost method returns the
calculated cost after deduction.
You can now compile and run the strategy_example.go.
The command is as follow:
               go run strategy_example.go
The output will be as follows:
bhagvanarch@Bhagvans-MacBook-Air Behavioural Design 
Patterns % go run strategy_example.go
Cost of the Product after deduction 27000
Cost of the Product after deduction 20
bhagvanarch@Bhagvans-MacBook-Air Behavioural Design 
Patterns %
Now, let us look at the template method design pattern.
Template method pattern
You can use the template design pattern to create a class to
define the technique. Subclasses of the template class can
have different implementations. The ContentManager
interface has a getContent method. The document
implements the interface. Let us look at the ContentManger
interface in the code:
package main
import (

"fmt"
"strings"
)
type ContentManager interface {
getContent() string
}
type Document struct {
content string
}
func (doc *Document) getContent() string {
return doc.content
}
The template interface has methods intro, desc, and
placeholder:
type Template interface {
intro() string
desc() string
placeHolder(ContentManager) string
}
FixedTemplate and DynamicTemplate implement the
Template interface, but they implement different methods,
such as intro, desc, and placeholder:
type FixedTemplate struct{}
func (t *FixedTemplate) intro() string {
return "This is the introduction section"
}

func (t *FixedTemplate) desc() string {
return "This is the description section"
}
func (t *FixedTemplate) placeholder(cm 
ContentManager) string {
return strings.Join(
[]string{
t.intro(),
t.desc(),
cm.getContent(),
},
" ",
)
}
type DynamicTemplate struct {
intro_text string
desc_text  string
}
func (a *DynamicTemplate) intro() string {
return a.intro_text
}
func (a *DynamicTemplate) desc() string {
return a.desc_text
}
func (a *DynamicTemplate) placeholder(cm 
ContentManager) string {

return strings.Join(
[]string{
a.intro(),
a.desc(),
cm.getContent(),
},
" ",
)
}
func main() {
doc := &Document{content: "This is a 
detailed section"}
fixed := &FixedTemplate{}
document := fixed.placeholder(doc)
fmt.Println("Fixed Template based document 
is", document)
dynamic := &DynamicTemplate{intro_text: 
"Dynamic introduction", desc_text: "Dynamic 
Description"}
dynamic_text := dynamic.placeholder(doc)
fmt.Println("Dynamic Template based 
document is", dynamic_text)
}
In the example above, a document is created with different
templates, namely, fixed and dynamic. The document object
has the initial text, which is passed on to the template to
change the document to the specified template.

You can now compile and run the template_example.go.
The command is as follows:
               go run template_example.go
The output will be as follows:
Figure 14.10: Template pattern example code output
Now, let us look at the visitor design pattern.
Visitor pattern
Developers use the visitor pattern to segregate the
technique from the object by defining a new object from a
class that defines the technique. This also helps to
incorporate multiple techniques for the same object through
visitors. Let us look at the following example where the
Vistior interface is defined with getTruckVelocity and get
CarVelocity methods:
package main
import (
"fmt"
)
type Visitor interface {
getTruckVelocity(*Truck) int
getCarVelocity(*Car) int

}
Truck and Car structs are defined with the acceptVisitor
method:
type Truck struct {
highestSpeed int
}
func (t *Truck) acceptVisitor(v Visitor) {
fmt.Println("Velocity of the truck is", 
v.getTruckVelocity(t))
}
func (t *Truck) getVehicleType() string {
return "Truck"
}
func (t *Truck) getTruckVelociy() int {
return t.highestSpeed
}
type Car struct {
highestSpeed int
}
func (c *Car) acceptVisitor(v Visitor) {
fmt.Println("Velocity of the Car is:", 
v.getCarVelocity(c))
}
func (c *Car) getVehicleType() string {
return "Car"
}

VehicleVelocity is the visitor class that uses truck and car
velocity methods:
type VehicleVelocity struct {
}
func (v *VehicleVelocity) getTruckVelocity(t 
*Truck) int {
return t.highestSpeed
}
func (v *VehicleVelocity) getCarVelocity(c *Car) 
int {
return c.highestSpeed
}
func main() {
truck := &Truck{highestSpeed: 160}
car := &Car{highestSpeed: 120}
velocity := &VehicleVelocity{}
truck.acceptVisitor(velocity)
car.acceptVisitor(velocity)
}
In the example above, VehicleVelocity visitor separates
the speed calculation like an odometer in a truck and car.
You can now compile and run the visitor_example.go. The
command is as follows:
               go run visitor_example.go
The output will be as follows:

Figure 14.11: Visitor pattern example code output
Now, let us look at the object-oriented design patterns.
Object-oriented design patterns
While developing software, different methodologies like OOD,
DDD and other methodologies are used. Object-oriented
design (OOD) focuses on the classes, their responsibilities,
and the collaboration between the classes. General
Responsibility Assignment Software Patterns (GRASP)
are the principles that help in Object-oriented design.
GRASP patterns are based on the following principles:
Creation of objects
Information expertise
Low coupling
High cohesion
Controller
Polymorphism
Abstraction
Pure fabrication
Now, let us look at these principles in detail.
GRASP patterns

GRASP principles are used in object-oriented design
methodology. These principles help design systems that are
flexible, adaptable, resilient, fail-proof, maintainable, and
extensible. Future requirements can be easily added to the
software's upcoming releases. The principles are as follows:
Creator: This principle concerns the class that creates
objects. The creator class needs to be decoupled from
the objects of the classes that are created. The creator
class can be an aggregate or a composite. This
principle helps determine which class takes the
responsibility of object creation.
Information expertise: This principle emphasizes the
importance of the class having information related to
the task to be processed. The goal is to have
cohesiveness and lessen dependencies in the classes.
The class needs to be responsible for a single task and
have all the information related to the task.
Low coupling: This principle is based on low coupling
between the classes. Classes need to have fewer
interconnections. The goal is to have a modular and
flexible design. This makes the software easy to
maintain. Change requests can be handled easily, and
new 
features 
can 
be 
added 
easily, 
improving
reusability.
High cohesion: The high cohesion principle states
that the class design needs to factor in encapsulation
and a single responsibility for a class. This will help
improve reuse and handle changes in the future. Each
class needs to have a well-defined purpose and focus.
Controller: Developers use the controller principle to
model classes mediating between the UI and the
business logic layer. These controller classes help in
processing the client requests from the UI to invoke
business layer classes and respond to the user

interface with a response. This helps in decoupling the
different aspects of the design. The controller class is
responsible for system operations encapsulation.
Polymorphism: The polymorphism principle is an
object-oriented design methodology principle. Multiple
classes can have a single interface. The goal is to have
a design that is adaptable and extensible. This
principle helps reduce coupling and improve reuse.
Because of the polymorphism principles, subclasses
can be easily referred to as the superclass.
Abstraction: The Single Layer of Abstraction
(SLAP) principle encourages abstraction in the design
and a layered design to handle presentation, business,
external interface integration, data storage, and data
persistence features.
Pure fabrication: The pure fabrication principle is
used to create classes that are not related to the
context. These classes are helper classes and help
decouple the functionality from the domain objects.
They also help improve cohesion and reduce coupling
with external systems. Some of the helper classes can
be related to input and output handling, data format
transformation, and data persistence.
Conclusion
In this chapter, we have covered topics related to Gang of
Four design patterns and object-oriented design patterns.
Behavioral design patterns were discussed in detail with
context and examples. Object-oriented design principles and
GRASP patterns were presented in detail.
In the next chapter, the reader will know how to develop Go
applications that are responsive and performant. Different
performance tuning and optimization patterns are presented

with code samples to the reader. The readers will understand
the performance tuning and optimization techniques while
building web applications.

CHAPTER 15
Go Performance Tuning
Patterns
Introduction
In this chapter, the readers will learn how to develop Go
applications that are responsive and performant. Different
performance tuning and optimization patterns are presented
with code samples to the readers. The readers will
understand the performance tuning and optimization
techniques while building the web applications. Let us look at
the aspects of Go Lange performance tuning:

Figure 15.1: Go Lang performance tuning patterns
Structure
The chapter covers the following topics:
Go apps performance tuning
Go apps code profiling
Go web apps challenges
Go web apps performance tuning
Go performance patterns
Go scalability patterns
Objectives
In this chapter, we are going to discuss Go Lang performance
tuning patterns. We are going to discuss the challenges and
issues while developing and deploying the web applications
based on Go Lang. We will look into performance tuning and
profiling the Go Lang-based web applications. Different

performance patterns and scalability patterns are discussed
in this chapter.
Go apps performance tuning
Performance tuning in Go (Golang) focuses on optimizing
code for efficiency, memory management, and execution
speed. One of the most important aspects is effective
memory management. In Go, memory is automatically
managed by the garbage collector, but excessive allocations
or improper resource management can lead to performance
degradation. To minimize the memory issues, developers can
use smaller struct sizes, pass large structs by pointer instead
of value, and avoid memory leaks by properly closing
resources like goroutines and file handlers. Reusing objects
through pooling, specifically with sync.Pool, helps reduce
the load on the garbage collector by reusing memory instead
of repeatedly allocating and deallocating the memory.
Another critical area for performance tuning is minimizing
the overhead of garbage collection. Go’s garbage collector
works efficiently for many use cases, but its frequency can
be adjusted using the GOGC environment variable. By tuning
this variable, developers can control the balance between
memory usage and garbage collection frequency. Reducing
heap allocations by reusing objects and limiting pointer use
can also reduce the garbage collector's workload. Escape
analysis is another tool provided by Go, allowing developers
to see where variables escape to the heap and optimize
memory allocation patterns accordingly.
Optimizing the use of goroutines and channels is essential
for high-performance concurrency in Go. While goroutines
are lightweight, they still consume memory and can add
unnecessary overhead if overused or improperly managed.
Developers should ensure that goroutines do not leak by
making sure they exit properly and are not left waiting on

channels or locks indefinitely. Channels should also be
efficiently managed, with appropriate buffer sizes to avoid
bottlenecks. In scenarios where lock contention arises, using
Go's synchronization primitives like sync.Mutex or atomic
operations (sync/atomic) can prevent performance
degradation by reducing the waiting time for shared
resources.
When dealing with I/O operations, performance can be
improved by using buffered I/O, which reduces the number of
system calls and enhances throughput. For tasks involving
big data or frequent I/O, processing in a concurrent manner
using goroutines can help prevent blocking and improve
response times. Along with this, developers should profile
their applications regularly using Go’s built-in tools like
pprof and trace to identify bottlenecks, whether they are in
CPU usage, memory consumption, or goroutine scheduling.
Choosing the right data structures and algorithms is another
way to achieve performance gains. Go’s standard library
provides efficient data structures like slices and maps, but
selecting the most suitable one based on usage patterns can
drastically affect performance. Efficient slicing and reusing
existing slices where possible helps reduce memory
allocations. Moreover, avoiding unnecessary copying of data,
especially when handling large collections, prevents
additional performance hits. In cases where large datasets
are involved, streaming data in chunks rather than loading it
all into memory can help prevent excessive memory
consumption.
Finally, compiler optimizations and Go’s scheduling can be
tuned for performance. The GOMAXPROCS setting, which
determines the number of CPU threads that the Go runtime
can use, should be adjusted based on the number of
available CPU cores to make full use of system resources.
Inlining small functions, which Go’s compiler can do
automatically, reduces the overhead of function calls, while

minimizing the use of reflection, which is slow and costly at
runtime, can help keep the program running efficiently. By
continuously applying these optimization techniques and
regularly profiling the application, developers can ensure
that their Go programs are performant and resource-
efficient.
Go apps code profiling
Code profiling in Go (Go Lang) is a significant technique for
recognizing execution bottlenecks and optimizing asset
utilization. Go gives built-in tools that permit designers, to a
degree, different viewpoints of their applications, such as
CPU utilization, memory allotments, and the behavior of
goroutines. Profiling is basic when an application encounters
execution debasement or versatility issues, as it makes a
difference in pinpointing wasteful aspects that may not be
self-evident from the code alone.
The Go pprof bundle is one of the most effective profiling
apparatuses accessible in the dialect. It empowers engineers
to collect point by point runtime information around CPU and
memory utilization. CPU profiling, for the occasion, tracks the
time that went through on each work, making a difference in
distinguishing parts of the program that devour the most
computational assets. Engineers can utilize CPU profiling to
confine pointlessly moderate or computationally costly
capacities. This data permits them to center their
optimization endeavors on the regions that will give the most
noteworthy execution improvements.

Figure 15.2: Go Lang performance tuning tools
Memory profiling is another key highlight of Go's pprof tool,
giving bits of knowledge into how memory is designated and
utilized over time. It makes a difference in recognizing
memory spills, which happen when memory is distributed
but never discharged, driving to intemperate memory
utilization and possibly slamming the application. Memory
profiles, moreover, uncover designs of over-the-top pile
allotments, which can put weight on the waste collector. By
distinguishing where these assignments are happening,
designers can refactor code to reuse memory more
successfully, decrease rubbish collection overhead, and
make strides in general memory efficiency.
In expansion to prof, Go moreover offers goroutine profiling,
which tracks the behavior and lifecycle of goroutines. Since
goroutines are lightweight strings that empower
concurrency, overseeing them proficiently is fundamental for
ideal execution. Profiling goroutines makes a difference.

Engineers recognize goroutine spills, where unused
goroutines stay in memory or cases, whereas well numerous
goroutines are produced, leading to asset disputes.
Understanding goroutine behavior through profiling permits
for way better concurrency administration, guaranteeing that
the application makes the most proficient utilization of
framework assets without presenting superfluous overhead.
Another instrument worth specifying is Go’s execution tracer,
which gives granular data around program execution,
counting planning occasions, blocking on framework calls,
and goroutine lifecycle occasions. The following yield can
help analyze issues such as intemperate blocking or
destitute utilization of CPU centers. By analyzing this,
designers can fine-tune viewpoints like goroutine planning or
alter the number of strings through the GOMAXPROCS
setting, which controls how numerous CPU centers Go can
utilize concurrently.
To perform profiling in Go, designers regularly use the
net/http/pprof bundle for web-based profiling or utilize the
runtime/pprof bundle for command-line profiling. Once the
profiling information is collected, it can be analyzed utilizing
the go tool pprof command. This instrument creates
reports and visualizations such as fire charts, call charts, and
beat records, making a difference in engineers deciphering
the information and finding issue ranges in their code.
Regular profiling amid the improvement cycle is fundamental
for keeping up ideal execution, particularly as applications
develop and handle more information or activity. By
persistently checking CPU, memory, and goroutine
utilization, designers can capture and settle wasteful aspects
sometime recently that have become major issues,
guaranteeing their Go applications stay versatile and
proficient over time.

Go web apps challenges
Web applications are accessible by desktop and mobile
browsers. The web apps need to be responsive, and users
need to have a good user experience while navigating the
web application. Web applications are developed using best
practices that focus on performance and scalability. They are
unit-tested, and performance testing is done using Go
performance testing frameworks. Performance-critical issues
are found during performance testing. Performance metrics
are gathered for every use case, web pages, and for different
users. The performance test cases cover the scenario where
a total number of users and concurrent users are logged in.
Users need to have quicker web page responses when a total
number of users have logged in and concurrent users are
logged in while accessing the application.
System sizing is done first, and the capacity plan is created
with servers and resources required for the deployment of
the web application. Developers follow the coding best
practices to ensure the code is performant and web pages
are responsive. During code review and performance testing,
the memory issues and concurrency problems are identified.
These issues are resolved to avoid deadlocks and
synchronization problems in the future. The dependencies for
developing web applications are identified, and the latest
versions are used to ensure the problems with older versions
do not exist in the developed web application.
While deploying the web application, multiple servers are
deployed using a load balancer. A load balancer helps send
the traffic and balance the load across the server nodes.
Static web content is separated from the dynamic content.
Static web content is served using web caching servers.
Dynamic web applications are developed using the right web
application framework, which provides scalability and
responsiveness. Web applications need to factor in the

capability of searching the content through search engines.
Web apps need to be designed for network bandwidth
limitations. Based on the users’ network bandwidth, the
pages need to be designed to consume low data from the
backend services.
Go Lang-based web stacks are popular as Go Lang is being
adopted by the developer community. Go Lang was created
by Ken Thompson, Rob Pike, and Robert Griesemer. Go Lang
is the same as C language. Developers like Go Lang over C
as the Go Lang programs are memory-safe, and concurrency
can be implemented easily. There are challenges with Go
Lang in the areas of database services, such as handling
images, managing plugins, balancing load, handling traffic,
managing lesser bandwidth networks for service calls, and
connecting to the network.
Making database calls can be done by having indexes on the
database tables. Complex queries can be analyzed and
improved for performance. The recursive Go Lang method
can create a stack overflow error. Dynamic allocation of
memory to handle big data in memory can cause memory
and performance issues.
Recursion
Let us look at the following code for a recursive program in
Go Lang:
package main
import (
"fmt"
"time"
)
func get_factorial(x int) int {
if x == 0 {

return 1
} else {
return x * get_factorial(x-1)
}
}
func main() {
start_time := time.Now()
factorial := get_factorial(10)
fmt.Println("Factorial of 10 is", 
factorial)
elapsed_time := time.Since(start_time)
fmt.Println("Time Taken", elapsed_time)
}
You can now compile and run the recursive_example.go.
The command is as follows:
go run recursive_example.go
The output will be as follows:
Figure 15.3: Recursive example code execution output
In the above example, the factorial of a number is calculated
using recursion. The above example is coded in Go Lang.
Dynamic memory allocation

Now, let us look at the dynamic allocation of memory in Go
Lang:
package main
import (
"fmt"
"runtime"
"time"
)
func dynamicAllocMemory(n int) {
intArray := make([]int, n)
if intArray == nil {
fmt.Println("Unable to create an 
Arrray of Size", n)
}
}
func getMemoryStats(memstat runtime.MemStats) {
runtime.ReadMemStats(&memstat)
fmt.Println("memstats.Alloc:", 
memstat.Alloc)
fmt.Println("memstats.TotalAlloc:", 
memstat.TotalAlloc)
fmt.Println("memstats.HeapAlloc:", 
memstat.HeapAlloc)
fmt.Println("memstats.NumGC:", 
memstat.NumGC, "\n")
}
func main() {

start_time := time.Now()
var memStat runtime.MemStats
getMemoryStats(memStat)
dynamicAllocMemory(100000000)
elapsed_time := time.Since(start_time)
fmt.Println("Time Taken", elapsed_time)
getMemoryStats(memStat)
}
You can now compile and run the
dynamic_memory_allocation.go. The command is as
follows:
go run dynamic_memory_allocation.go
The output will be as follows:

Figure 15.4: Dynamic memory allocation example code execution output
In the above example, the memory is allocated dynamically
by creating an integer array. The above example is coded in
Go Lang.
HTTP request and response
Let us look at the following code for HTTP request and
response handling in Go Lang:
package main
import (
"fmt"
"net/http"
"runtime"

"time"
)
func invokeHttpCall(url string) {
response, err := http.Get(url)
if err != nil {
return
}
fmt.Println("response body", response)
defer response.Body.Close()
}
func getMemoryStats(memstat runtime.MemStats) {
runtime.ReadMemStats(&memstat)
fmt.Println("memstats.Alloc:", 
memstat.Alloc)
fmt.Println("memstats.TotalAlloc:", 
memstat.TotalAlloc)
fmt.Println("memstats.HeapAlloc:", 
memstat.HeapAlloc)
fmt.Println("memstats.NumGC:", 
memstat.NumGC, "\n")
}
func main() {
start_time := time.Now()
var memStat runtime.MemStats
getMemoryStats(memStat)
url := "http://www.amazon.com"
invokeHttpCall(url)

elapsed_time := time.Since(start_time)
fmt.Println("Time Taken", elapsed_time)
getMemoryStats(memStat)
}
You can now compile and run the http_invocation.go. The
command is as follows:
go run http_invocation.go
The output will be as follows:

Figure 15.5: HTTP invocation example code execution output
In the above example, the HTTP request to access a web
page is shown. The above example is coded in Go Lang.
Other challenges
The other challenges in Go Lang-based web applications are
performance issues with unnecessary code, large images,
plugins, and outdated front-end (PHP/JS frameworks)

versions. Unnecessary code can be removed during code
reviews. Images can be compressed, and a content delivery
network can be deployed for image serving. Managing plugin
problems is done by choosing the right plugin and the
version required. Similarly, the front-end user interface
framework needs to be updated regularly to keep up with the
latest versions.
While deploying a web application on a testing environment
before the production environment, performance monitoring
tools must be used to capture the performance metrics and
response times. The environment can be a production
environment replica to ensure the environment capacity
matches the system sizing requirements.
Now, let us look at tuning the performance of the Go Lang
web applications.
Go web apps performance tuning
The key issues observed during performance testing are
related to network connections/DNS, web page loading, code
quality, web traffic handling, and the front-end user interface
frameworks. Many performance testing tools are available
for gathering performance metrics and web page response
times. These tools gather performance metrics, which are as
follows:
Web page response time
System throughput
Request failed—Error rate
Number of concurrent users

Figure 15.6: Go Lang web App Performance Metrics
Performance testing tools that are popular for Go Lang-based
web applications are:
Apache JMeter
Vegeta
Gatling
There are many ways to tune the Go Lang-based web
application performance. Web app performance goals and
requirements need to be identified. These include total
users, concurrent users, web page response times, and
functional metrics like a number of products, categories,
merchants, and others. The system sizing includes these
factors, and the performance testing environment will be the
same as the production environment. During performance
testing, the following system factors are measured:
CPU usage

Memory usage
IO usage
Number of requests
To improve the Go Lang-based web application performance,
caching is used to improve the response time and reduce the
number of calls to the database. Channels and go routines
are used to manage the concurrent requests from different
clients. The database call performance can be improved by
using the ORM Go Lang packages. Performance testing
needs to be done as the functionality gets added to the
system and deployed on production.
Performance and Security are very important aspects of web
applications. Data security is the goal of the security testing.
Risks are related to SQL, scripting, and the deployment
environment resources used. Attacks like SQL injection and
Cross-site scripting need to be avoided by using DevSecOps
tools and executing them early in the software lifecycle. The
best practices suggested are having password policies,
regular software updates, plugin updates, and using best
practices to improve code quality, performance, and security.
Authentication, authorization, encryption, and decryption
strategies are important in the security architecture.
Creating a scalable architecture is important for web
applications. The system can scale as the number of users,
products, categories, centers, sales offices, and production
offices increases. The traffic and load requirements need to
be captured for the next four years to ensure the
architecture can scale after four years. Architecture can be
scalable if the system consists of modules and different
services within the module are scalable and performant.
Deploying the system on the cloud can help the architecture
to have elasticity and load-balancing features of the cloud
environment. Scaling can be done horizontally by having
more servers to handle traffic and load. Vertically, the

architecture can be scaled by having more resources within
the current servers. Monitoring and management of the
application are very important while scaling the application.
The system will be updated with new functionality, and
updates need to be deployed without affecting the system's
performance. Software updates related to plugins,
dependent packages, and environment resources are
important to ensure to close the existing security loopholes.
Web application design needs to factor in that the user
interface needs to be responsive, and the web page needs to
be rendered on mobile phones, tablets, mobile browsers, and
web browsers. The web page rendering needs to factor in
different screen layouts and width/height. The testing
approach needs to handle multiple browsers on different
device types. The application design needs to have a backup
plan to handle old devices and browser versions. To improve
the web application performance, the developer needs to
work on reducing the page response time, web server
response time, and the user experience (UX) of the web
application. Performance best practices need to be
implemented in the code by removing unnecessary code, file
compression, and content separation. content delivery
network (CDN) and caching help in improving web
application performance. Asynchronous loading is another
best practice in improving the performance of the web app.
Content can be loaded by using techniques like lazy loading,
image compression, and minification.
Go performance patterns
Let us now examine the Go performance patterns. First, we
will profile the concurrency handling code.
Concurrency handling

In web applications, different processes need to be executed
concurrently. Ensuring they are performant and profiling the
code is important. The pprof package, which is part of Go
Lang tools, is used to collect CPU and memory metrics. Go
routines and channels-based code can be profiled using the
same tool. Let us look at pprof usage in code:
package main
import (
"fmt"
"net/http"
_ "net/http/pprof"
"time"
)
func executeConcurrentMethod() {
fmt.Println("Executing the concurrent 
method")
}
func main() {
go func() {
http.ListenAndServe("localhost:6060", nil)
}()
start_time := time.Now()
go executeConcurrentMethod()
elapsed_time := time.Since(start_time)
fmt.Println("Time Taken", elapsed_time)
            time.Sleep(30 * time.Second)
}

You can now compile and run the concurrency_example.go.
The command is as follows:
go run concurrency_example.go
The output will be as follows:
Figure 15.7: HTTP invocation example using pprof code execution output
CPU intensive tasks
Now, we will look into CPU task-intensive code in Go Lang.
Let us look at CPU-intensive task example code:

package main
import (
"fmt"
"time"
)
func executeTask(itr int) int {
output := 0
for cit := 1; cit <= itr; cit++ {
output += cit
}
return output
}
func main() {
cstart_time_taken := time.Now()
coutput := executeTask(1000000)
celapsed_time_taken := 
time.Since(cstart_time_tkaen)
fmt.Println("Time Taken", 
celapsed_time_taken)
fmt.Printf("Output is: %d\n", coutput)
}
}
You can now compile and run the cpu_task_example.go.
The command is as follows:
go run cpu_task_example.go
The output will be as follows:

Figure 15.8: CPU task example using pprof code execution output
Web traffic handling
Now, we will look into handling web traffic in Go Lang. The
Go language is strongly typed and close to C in terms of
efficiency. Web traffic can be balanced using load-balancing
strategies like round robin, weighted round robin, least
connections, and IP hash techniques. Balancing traffic using
round-robin involves sending the requests and balancing
them across the web servers. Weighted round-robin factors
in the weights assigned to the web server nodes and their
sizes related to memory, disk space, and CPUs. Least
connections strategies help in sending the request by finding
the current connections used by the server resource. IP hash
strategy helps in mapping the server nodes based on the IP
addresses. Let us look at the WebAppTrafficHandler struct
code:
package main
import (
"fmt"
)
type WebAppTrafficHandler struct {
web_resources []string
index         int
}

func NewWebAppTrafficHandler(webresources []string) 
*WebAppTrafficHandler {
return &WebAppTrafficHandler{
web_resources: webresources,
index:         0,
}
}
func (wth *WebAppTrafficHandler) 
GetNextWebServerResource() string {
web_resource := 
wth.web_resources[wth.index]
wth.index = (wth.index + 1) % 
len(wth.web_resources)
return web_resource
}
func main() {
web_resources := []string{"Resource1", 
"Resource2", "Resource3"}
trafficHandler := 
NewWebAppTrafficHandler(web_resources)
for i := 0; i < 10; i++ {
selectedResource := 
trafficHandler.GetNextWebServerResource()
fmt.Println("Request served by:", 
selectedResource)
}
}

You can now compile and run the traffic_handling.go.
The command is as follows:
go run traffic_handling.go
The output will be as follows:
Figure 15.9: Traffic handling example using pprof code execution output
Now, let us look at Go scalability and patterns implemented
in practice.
Go scalability patterns
Go web applications need to have the capability to scale
based on the functional requirements. There are different
ways of scaling, such as horizontal and vertical scaling. The
other strategies are stateless design, caching mechanism,
optimizing databases, microservices, and autoscaling (Figure
15.7).

Figure 15.10: Go Lang scalability patterns
A sample code for autoscaling is provided. You need access
to the AWS cloud and credentials. Let us look at the
autoscaling implementation in the code:
package main
import (
"fmt"
"github.com/aws/aws-sdk-go/aws"
"github.com/aws/aws-sdk-go/aws/session"
"github.com/aws/aws-sdk-
go/service/autoscaling"
)
func main() {

web_session := 
session.Must(session.NewSession(&aws.Config{
Region: aws.String("us-west-2"),
}))
web_service := autoscaling.New(web_session)
_, err := 
web_service.CreateAutoScalingGroup(&autoscaling.Cre
ateAutoScalingGroupInput{
AutoScalingGroupName: 
aws.String("my-asg"),
LaunchTemplate: 
&autoscaling.LaunchTemplateSpecification{
LaunchTemplateName: 
aws.String("my-launch-template"),
},
MinSize:         aws.Int64(1),
MaxSize:         aws.Int64(10),
DesiredCapacity: aws.Int64(1),
})
if err != nil {
fmt.Println("Error creating the web 
Auto Scaling group:", err)
return
}
_, err = 
web_service.PutScalingPolicy(&autoscaling.PutScalin
gPolicyInput{

AutoScalingGroupName: 
aws.String("my-asg"),
PolicyName:           
aws.String("my-scaling-policy"),
PolicyType:           
aws.String("TargetTrackingScaling"),
TargetTrackingConfiguration: 
&autoscaling.TargetTrackingConfiguration{
PredefinedMetricSpecification: 
&autoscaling.PredefinedMetricSpecification{
PredefinedMetricType: 
aws.String("ASGAverageCPUUtilization"),
},
TargetValue: 
aws.Float64(70.0),
},
})
if err != nil {
fmt.Println("Error setting up 
scaling policy:", err)
return
}
fmt.Println("Web server Auto Scaling group 
created and scaling policy set up successfully.")
}
Conclusion

In this chapter, we have covered topics related to Go Web
Application challenges, Go Web Apps Performance Tuning,
Patterns, and Go Lang Web Apps Scalability.
We looked at recursion, dynamic memory allocation, web
request and response handling, and other challenges in the
Go language. Different techniques and approaches were
presented for improving web application’s performance.
Performance patterns were presented with examples related
to concurrency handling, CPU-intensive tasks, and web traffic
handling. We looked at Go Scalability strategies like
horizontal and vertical scaling. The other strategies like
stateless design, caching, autoscaling, and microservices.
Go’s design philosophy prioritizes simplicity, speed, and
efficiency, which leads to high-performing applications that
scale well. From handling concurrent requests in web servers
to managing complex cloud infrastructure, Go’s performance
features make it a preferred language in modern software
engineering. Its low memory footprint, fast execution, and
efficient concurrency model allow developers to build
applications that are both resource-efficient and capable of
handling demanding workloads. In an era where speed and
scalability are key, Go stands out as a language that meets
these needs without sacrificing developer productivity.
In the next chapter, the readers will be presented with web
app blueprint applications. Readers will understand the
design and architecture principles to build scalable web
applications. The blueprint solutions will have the tips and
techniques to build responsive web applications that are
performant.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and
Sessions with the Authors:

https://discord.bpbonline.com

CHAPTER 16
Go Web App Blueprints
Introduction
In this chapter, the readers will be presented with web app
blueprint applications. The readers will understand the
design and architecture principles to build scalable web
applications. The blueprint solutions will have the tips and
techniques to build responsive web applications that are
performant. Let us look at Go web application recipes,
architecture, and design principles to build scalable and
responsive web applications:

Figure 16.1: Go web app blueprints
Structure
The chapter covers the following topics:
Web app in Go recipes
Building scalable and responsive web app
Web app design principles
Web app architecture principles
Objectives
In this chapter, we are going to discuss Go recipes for
building web applications. You will be able to build scalable
and responsive web applications. Web application
architecture and design principles will be presented. You will
know the best practices and blueprints to get started on
building web applications using the Go tech stack. You can
ensure the web application built will be performant and meet
the non-functional requirements of the application.

Creating web applications using the Go programming
language has become increasingly popular due to its
efficiency, simplicity, and robust performance. Go, often
referred to as Go Lang, is a statically typed, compiled
language designed by Google. It is particularly well-suited for
building scalable and high-performance web applications.
The Go language offers a variety of frameworks and tools
that streamline the development process, making it easier
for developers to create well-structured and maintainable
web applications.
One of the key advantages of using Go for web development
is its powerful standard library, which includes a built-in
HTTP server. This allows developers to quickly set up web
servers without the need for external dependencies.
Additionally, Go's concurrency model, based on goroutines
and channels, enables efficient handling of multiple requests
simultaneously, making it ideal for high-traffic web
applications. The language's simplicity and readability also
contribute to faster development cycles and easier code
maintenance.
Blueprints for Go-based web applications typically follow a
Model-View-Controller (MVC) architecture, which helps in
organizing the codebase into distinct layers. The model layer
handles the data and business logic, the view layer manages
the user interface, and the controller layer processes
incoming requests and returns responses. This separation of
concerns ensures that the application is modular and easier
to manage. Frameworks like Gin, Echo, and Fiber provide
additional features and utilities that enhance the
development experience, such as routing, middleware
support, and template rendering.
Another significant aspect of Go web app blueprints is the
emphasis on performance and scalability. Go's efficient
memory management and garbage collection, combined
with its ability to compile to native machine code, result in

applications that are both fast and resource-efficient. This
makes Go an excellent choice for building microservices and
other distributed systems where performance is critical.
Moreover, Go's strong typing and static analysis tools help
catch errors early in the development process, leading to
more reliable and secure applications.
In addition to the technical benefits, Go's growing ecosystem
and active community provide ample resources for
developers. Numerous libraries and packages are available
to extend the functionality of Go web applications, from
database connectors and authentication modules to real-
time communication tools and API clients. The community
also offers extensive documentation, tutorials, and forums
where developers can seek advice and share knowledge.
This collaborative environment fosters continuous learning
and improvement, making Go a vibrant and supportive
platform for web development.
Overall, Go language-based web app blueprints offer a
comprehensive and efficient approach to building modern
web applications. With its powerful standard library, strong
concurrency model, and supportive community, Go provides
developers with the tools they need to create high-
performance, scalable, and maintainable web applications.
Whether you are building a simple website or a complex
distributed system, Go's simplicity and robustness make it an
excellent choice for web development.
Web app in Go recipes
Go lang-based web stacks are popular as the developer
community is adopting Go Lang. Go Lang was created by Ken
Thompson, Rob Pike, and Robert Griesemer in 2009 in the
Google company. Golang.org was the website from where the
language was named. Go Lang is the same as C language
without any drawbacks of C language. Developers like Go

Lang over C as the Go Lang programs are memory-safe, and
concurrency can be implemented easily in data engineering,
artificial intelligence, data processing, networking, and
backend apps. Go Lang has garbage collection and static
typing features. Let us look at different web frameworks
based on the Go tech stack:
Figure 16.2: Go web app frameworks
To build web applications, Go Lang is simple and easy to use.
There are various frameworks that help in building web
pages and backend services. Go language packages are
available for encryption, file handling, networking, and
content serving. The Go language web app can be developed
on one of the operating systems and deployed on other
operating systems easily with recompilation. This makes the
web app portable and easy to deploy on multiple clouds.
There are many web app frameworks that developers can
use. They are as follows:
Gin
Beego
Kit
Echo
FastHttp

Martini
To recap from Chapter 4, Building Rest API, the following
snippet is about the Gin framework:
In Go language, you can build REST API, which interacts with
relational databases to get and store data. You can use the
Gin REST framework. It is based on an HTTP Router, which
provides features like routing and form validation. You can
use GORM to store data in the relational database.
First, let us look at how to create an object model in Go Lang
based on a relational database model. In the models
package, we create an Employee Object, which is mapped by
GORM to a relational database table. The object fields are
mapped to relational database column types.
Regarding Beego, the following is the summary from Chapter
5, Go Web Apps:
In the Go language, you can use the Beego web framework
to develop web applications. Beego framework is an open-
source framework that has application tools, an object
relationship mapping framework, and other packages. ORM
framework helps in cutting down the ordeal of developing
the relational schema and mapping it to object classes and
names of the attributes. Beego is used to build REST APIs,
which can be integrated with open-source JavaScript
frontend frameworks. We can build a Beego web application
using the Beego and SQLite database. Beego framework
helps develop web apps at an affordable cost.
Kit is another framework that provides the capability to build
web applications interacting with databases and
microservices. The services can be interoperable, and non-
technical users can easily create web applications. For a
developer, it is tedious as every step is through the web
pages to create an application.

You can use Echo, which provides features for HTTP request
handling, building microservices based on REST protocol,
and securing the web application with SSL. We looked in
Chapter 4, Building REST API, Fiber framework, which is
based on Fast Http:
You can use Fiber to design and develop REST API in Go
Lang. Fiber is a REST API-based open-source framework. It
was built along the lines of Express.js with Fast HTTP.
Fast HTTP is better than the basic http/net package. Fast
Http is better in performance because of worker pool versus
memory allocation for different go routines in the http/net
package. It is not compatible with HTTP/2 and the Beego web
app framework. It can handle 100000 transactions per
second and 1 million network connections.
Martini can be used to build Go Lang web applications and
REST API-based services. It can also integrate with third-
party services. Martini is well documented and adopted by
many developers.
Let us look at how to build a scalable and responsive web
application.
Building scalable and responsive web app
Go Lang is statically typed, and the types are checked while
compiling. Defects can be identified during the coding and
unit testing phase. Code can be developed for reuse and
bug-free. Go language is popular for developing concurrent
web apps. It is the same as C, C++, and other modern
languages. Many open-source projects are being developed
in Go Lang.
Go Lang provides a unit testing framework. Its applications
easily handle Exceptions and errors. It has JSON handling
features. Go applications are performant and scalable. For
scalability, Go Lang-based microservices can be created and

deployed on the cloud. Web pages developed in Go Lang
web frameworks can be integrated with microservices.
Building scalable and responsive web applications using Go
Lang (Golang) has become a compelling choice for
developers due to its simplicity, efficiency, and robust
performance. Go Lang's inherent design principles and
powerful features enable the creation of web applications
that can handle significant traffic while maintaining high
responsiveness and reliability.
At the heart of Go Lang's appeal is its simplicity and
readability. Go's concise syntax promotes clean and
maintainable code, reducing the cognitive load on
developers and making collaboration more effective. Unlike
languages that suffer from feature bloat, Go Lang's
minimalist approach ensures that developers focus on
building functional, efficient applications without
unnecessary complexity. The language's comprehensive
standard library includes packages tailored for web
development, such as net/http for handling HTTP requests
and html/template for generating dynamic HTML content.
Leveraging these built-in capabilities allows developers to
build robust web applications with minimal external
dependencies, fostering a more cohesive development
experience.
Concurrency is a key strength of Go Lang, setting it apart
from many other programming languages. Goroutines,
lightweight threads managed by the Go runtime, enable the
efficient handling of multiple concurrent tasks. This
capability is crucial for building responsive web applications
that need to manage numerous simultaneous user requests,
background tasks, and real-time updates. By utilizing Go's
concurrency model, developers can ensure their applications
remain performant even under heavy loads, providing a
seamless user experience. Channels facilitate

communication between goroutines, further enhancing the
efficiency and reliability of concurrent processes.
Modularity is another fundamental principle in developing
web applications with Go Lang. Organizing code into well-
defined, reusable packages promotes better code
management, scalability, and maintainability. Each package
should adhere to the Single Responsibility Principle
(SRP), ensuring that each module has a specific role within
the application. This modular approach simplifies testing and
debugging, as individual components can be developed and
tested in isolation. Dependency injection further decouples
components, enhancing flexibility and enabling more
effective unit testing. With a modular design, developers can
efficiently implement continuous integration and deployment
practices, streamlining the development pipeline and
facilitating easier updates and feature integration.
Security is paramount in web development, and Go Lang
provides several features to build secure applications.
Implementing robust authentication and authorization
mechanisms ensures that only authorized users can access
sensitive resources. Secure data transmission can be
achieved using TLS/SSL, protecting data from eavesdropping
and tampering. The standard library offers tools to mitigate
common security vulnerabilities, such as SQL injection and
cross-site scripting (XSS). By adhering to security best
practices, regularly updating dependencies, and conducting
security audits, developers can safeguard their applications
against potential threats and build trust with their users.
RESTful API design principles are integral to Go Lang-based
web app architecture. Designing APIs that follow REST
principles—such as using meaningful HTTP verbs, stateless
communication, and resource-based URLs—ensures that the
application remains intuitive and easy to use. Proper
documentation and versioning of APIs facilitate integration
with other systems and allow for the smooth evolution of the

application over time. By adhering to RESTful design
principles, developers can create interoperable and scalable
web applications that meet modern standards.
Go Lang's tooling ecosystem enhances the development
process, providing tools like go fmt for code formatting, go
vet for static analysis, and go test for unit testing to
maintain code quality and consistency. The Go module
system simplifies dependency management, making it easier
to manage and update external libraries. Leveraging these
tools ensures that the codebase remains clean, efficient, and
maintainable. Continuous integration and continuous
deployment (CI/CD) pipelines further enhance the
development workflow, enabling automated testing and
deployment for faster and more reliable releases.
Building scalable and responsive web applications with Go
Lang involves leveraging its simplicity, concurrency,
modularity, security, and adherence to RESTful design
principles. By following these principles and utilizing Go's
powerful features and tools, developers can create robust,
high-performance web applications that meet the demands
of modern users. Whether developing a small project or a
large-scale enterprise application, Go Lang's architecture
principles provide a comprehensive framework for achieving
excellence in web development. Its simplicity, combined with
powerful concurrency and an extensive standard library,
makes Go Lang an invaluable tool for building sophisticated
web applications that are both efficient and easy to
maintain. By embracing these principles, developers can
ensure long-term success and adaptability in the ever-
evolving landscape of web development.
Tools and techniques
Go routines can be created and scaled easily to handle
concurrency. To handle concurrent web requests, web
servers, and applications can create go routines to handle

concurrent jobs and parallelize the requests to give the
response. You can use containers like Docker or Kubernetes
to make deployment easy in cloud environments. Monitoring
and managing the web application can be done with tools
like Prometheus/Nagios/Grafana/Graphite and other
commercial tools like New Relic, Datadog, etc. Go lang
memory management and garbage collection are better
compared to other language-based tech stacks. Go Lang-
based tech stacks help meet the time to market by adding
new features and changing product features. Code Quality
can be checked using the GoLint Tool. Gofmt tool helps in
formatting the code for constants, strings, data inputs, and
variable values. Godoc can be run as a server that hosts the
documentation. Package management can be done in the Go
lang-based tech stack. There are code generators, code
analyzers, and open-source tools to automate the code
development. CI/CD tools like Gitlab CI and Jenkins can be
used for the deployment of the GoLang web application. Go
Test can be used to execute unit tests and gather testing
metrics. You can use GoVet to find defects in the code. Go
lang-based tech stack has features for data encryption and
decryption. The web application can be deployed with SSL.
Let us look at the deployment environments:
Figure 16.3: Deployment environments

The artifacts, excluding code and configuration files that are
not stored in the software configuration management tool or
code repository, are as follows:
Different environment-specific database settings
Different environment-specific cache server settings
Different 
environment-specific 
server 
and 
service
credentials
Different environment-specific API end-point URLs and
payment gateway URLs
Runtime 
and 
deployment 
time 
configuration
parameters for different environments
Go Lang web app challenges
Building web applications with Go Lang presents a unique set
of challenges that developers must navigate to ensure
successful project outcomes. While Go Lang offers simplicity,
performance, and a robust standard library, these
advantages come with their own hurdles that require careful
consideration and skillful management.
One of the primary challenges in developing Go Lang-based
web apps is its relatively steep learning curve for developers
new to the language. Go's minimalist syntax and unique
approach to error handling can be difficult to grasp for those
accustomed to more verbose languages. Additionally, Go
Lang's strict typing and lack of generics can make code
implementation more cumbersome, leading to increased
development time as developers adapt to its paradigms.
However, the trade-off is that once mastered, Go Lang's
simplicity and clarity can lead to more maintainable and
efficient codebases.
Concurrency, while a standout feature of Go Lang, also poses
significant challenges. Efficiently managing goroutines and

channels to handle concurrent tasks requires a deep
understanding of Go's concurrency model. Improper use of
these features can lead to issues such as race conditions,
deadlocks, and resource contention, which can be difficult to
debug and resolve. Ensuring thread safety and proper
synchronization in a concurrent environment demands
careful planning and testing, which can extend development
timelines.
Modularity in Go Lang is another area where developers may
encounter difficulties. While Go promotes a modular code
structure, organizing large codebases into well-defined
packages can be challenging. Ensuring that each package
adheres to the Single Responsibility Principle (SRP) and
managing dependencies effectively requires meticulous
design and foresight. Additionally, Go's approach to package
management and the absence of a formal package
versioning system in its early days have historically posed
challenges for developers, though the introduction of Go
modules has alleviated some of these issues.
Security concerns are paramount in web application
development, and Go Lang developers must navigate
various challenges to ensure robust security. Implementing
secure authentication and authorization mechanisms,
protecting data in transit with TLS/SSL, and mitigating
common vulnerabilities such as SQL injection and cross-site
scripting (XSS) requires a thorough understanding of
security best practices. Additionally, Go's relatively young
ecosystem means that developers may have to rely on
community-contributed libraries for certain security
functionalities, which can vary in quality and support.
API design is another critical challenge when building web
applications with Go Lang. Adhering to RESTful principles
and ensuring that APIs are intuitive, well-documented, and
versioned properly requires careful planning and execution.
Developers must balance the need for a clean and consistent

API design with the flexibility to adapt to changing
requirements and integrate with other systems. This can be
particularly challenging in large-scale applications where
multiple teams may be involved in API development.
The tooling ecosystem in Go Lang, while powerful, also
presents challenges. While tools, like go fmt, go vet, and go
test, are invaluable for maintaining code quality and
consistency, setting up and integrating these tools into a
streamlined development workflow can be complex.
Continuous integration and continuous deployment
(CI/CD) pipelines require careful configuration to ensure
automated testing and deployment processes run smoothly.
Developers must also stay up-to-date with the evolving
ecosystem and best practices to leverage these tools
effectively.
Building web applications with Go Lang involves navigating a
range of challenges, from mastering the language's unique
syntax and concurrency model to ensuring modularity,
security, and effective API design. While these challenges
can be daunting, they also present opportunities for
developers to deepen their skills and build robust, high-
performance web applications. By understanding and
addressing these challenges, developers can harness the full
potential of Go Lang to create scalable, maintainable, and
secure web applications that meet the demands of modern
users. Whether working on small projects or large-scale
enterprise applications, the journey of building Go Lang-
based web apps is both rewarding and enriching, providing
valuable insights and experiences along the way.
Now, let us look at design principles for designing web
applications.
Web app design principles

Designing a web application is a difficult task, especially
when you want to build a product that has multiple features
and different types of users. The product to be built needs to
be a market fit in terms of competing with other products in
the same space.
The key design principle is to have loose coupling in the
application design. The side effects are expected when the
application is not loosely coupled. Any change in the existing
product feature or application scaling in terms of geography
or adding new products/categories/catalogs becomes tough
to implement. Once the product is developed and deployed,
it is not possible to change the design.
Creating web applications with Go Lang requires a thoughtful
approach to architecture, focusing on efficiency, scalability,
and maintainability. Go Lang's architecture principles revolve
around its simplicity, concurrency capabilities, and strong
type system, making it an excellent choice for developing
modern web applications.
One of the fundamental principles of Go Lang-based web app
architecture is its emphasis on simplicity and readability. Go
Lang's syntax is designed to be clean and straightforward,
reducing the cognitive load on developers. This simplicity
extends to the language's standard library, which provides
powerful tools for web development without the need for
additional dependencies. The net/http package, for
instance, offers a robust foundation for building web servers
and handling HTTP requests. By leveraging Go's built-in
capabilities, developers can create efficient and
maintainable web applications with minimal overhead.
Go Lang's web app architecture principles emphasize
simplicity, concurrency, modularity, security, and adherence
to RESTful design. By following these principles, developers
can create scalable, maintainable, and high-performance
web applications that meet the demands of modern users.

Go Lang's powerful features and robust tooling ecosystem
provide a solid foundation for building sophisticated web
applications, ensuring long-term success and adaptability.
Whether you are developing a small project or a large-scale
enterprise application, Go Lang's architecture principles offer
a comprehensive framework for achieving excellence in web
development:
Figure 16.4: SOLID principles
Let us revisit the SOLID principles covered in Chapter 9, Go
Dependency Injection and SOLID:
SOLID principles were created by Robert C. Martin. They are
design tenets for creating and developing software. These
tenets help in making the software extensible, scalable, and
enhance-able.
The SOLID principles are as follows:
Single Responsibility Principle (SRP): A class or
module needs to have a single responsibility. This helps
in making the software modular. New enhancements
can be added to the software easily. Defects can be
analyzed, and root causes can be detected easily.

Open/Closed Principle (OCP): Software is designed
and coded so that it is open for extending functionality.
The 
code 
is 
closed 
for 
modifying 
the 
existing
functionality. By adding to the code, new behaviors in
the software can be done easily, and new features can
be added to the software.
Liskov Substitution Principle (LSP): What is wanted
here is something like the following substitution
property: If for each object obj1 of type S, there is an
object obj2 of type T such that for all programs P
defined in terms of T, the behavior of P is unchanged
when obj1 is substituted for obj2 then S is a subtype of
T.
Interface Segregation Principle (ISP): Software
Clients need not be relying on interfaces. Typically,
interfaces are designed with minimal functionality. This
helps in cutting down the dependencies between the
modules.
Dependency Inversion Principle (DIP): Top-layer
software modules need not have to rely on bottom-
layer modules. The top and bottom layers need to rely
on software interfaces and abstractions. Detailed
features are abstracted out by having abstract classes.
This helps in making the software modular and
decoupled. The less decoupled the software, the more
it helps in enhancing and testing the features quickly.
The above SOLID principles are considered while designing
the web application for a given functional requirement.
Before getting into system functional requirements, the
common infrastructural components need to be designed,
and their requirements need to be identified. They are as
follows:
Message and information logging

System error/Exception handling
External services and interface integration
Data persistence
System data access
System data transfer
Discovery/Naming and looking up of services
Concurrent jobs
System transaction management
Product internationalization
User authentication and authorization
To design the functional requirements of the system, the
microservices approach helps in decoupling the functional
modules from each other and identifying the services to be
grouped in a module. The goal is to avoid a monolithic
application that has all modules and services bundled in a
single package. Each microservice or module of services
needs to be capable of deploying and communicating with
other microservices.
During the requirements analysis, business entities, business
processes, and events are determined and grouped into a
logical functional module. A module will have an orchestral
service that can communicate with a microservice. You can
have a rules engine microservice that captures the functional
business rules. These rules will span business entities.
The web application will have a user interface that will be
based on a JavaScript/TypeScript framework like React,
Angular, Vue.js, and others. The key requirements which
need to be addressed in this layer are as follows:
User navigation
Process workflow

User input validation rules
Handling complex user interface interaction
Data validation framework
System default values
User friendly error messages mapped to system error
messages. 
User personalization
User/App state management
User session tracking
Responsive design
Mobile/Desktop/Web page requirements
Now, let us look at the principles of web app architecture.
Web app architecture principles
Creating web applications with Go Lang requires a thoughtful
approach to architecture, focusing on efficiency, scalability,
and maintainability. Go Lang's architecture principles revolve
around its simplicity, concurrency capabilities, and strong
type system, making it an excellent choice for developing
modern web applications.
Go Lang's web app architecture principles emphasize
simplicity, concurrency, modularity, security, and adherence
to RESTful design. By following these principles, developers
can create scalable, maintainable, and high-performance
web applications that meet the demands of modern users.
Go Lang's powerful features and robust tooling ecosystem
provide a solid foundation for building sophisticated web
applications, ensuring long-term success and adaptability.
Whether you are developing a small project or a large-scale
enterprise application, Go Lang's architecture principles offer

a comprehensive framework for achieving excellence in web
development.
The focus of the web app architecture principles is on the
following:
Code/component reusability
System portability
Web application scalability
Web app usability
Component extensibility
While architecting the web application, you need to gather
the system sizing requirements. They are as follows:
Number of concurrent users
Transactions per second (request rate)
Total number of users in the system
Maximum/minimum data size for transfer
Response time for the web page
After gathering the system sizing requirements, the
hardware required on the cloud/on-premises is decided for
the web server, database, and storage repository. The other
candidates for the system sizing are:
App server
Middleware server
LDAP/AD server
The system deployment specifications are determined now,
and the external services to be integrated need to be
identified. From the security and performance point of view,
network communication protocol, network bandwidth,
militarized zones, demilitarized zones, firewall, intrusion

detection system, API gateways, and Serverless components
are identified in the system deployment specification.
First, let us look at how to create a Go web application
project. The project directory will have the following
packages:
cmd
pkg
internal
vendor
api
web
configs
init
scripts
build
deployment
test
The cmd package will have the entry point of the web app
main.go pkg package has the external services and
components. The internal package will have the
dependencies and the internal code for the developed
services. The vendor package will have the web app
dependencies. The api package has the REST services,
swagger spec, schema, and interfaces. The web package has
the web pages, content, and style sheets. The Configs
package has the configuration files for the external and
internal services. The Init package has the
start/stop/bootstrapping environment and the configurations.
The scripts package has the build/install/analysis/operations-
related scripts. The build package has the scripts and the

configurations for creating a build. The deployment package
has the environment and the configuration details. The test
package has the unit tests and the functional tests.
Now, let us look at the different architecture methodologies.
First, let us look at the clean architecture methodology.
Clean architecture is an architectural methodology where the
focus is on having an independent presentation layer and
frameworks that are independent of business rules, services,
and middleware layer. Robert C. Martin created the clean
architecture methodology. This methodology helps in
creating an architecture that is independent of the database
that is used. The system built needs to be unit tests, and a
unit test framework needs to be created for the functional
and infrastructural services and components.
Figure 16.5: Clean architecture, four circles

In Figure 16.5, the colors signify the enterprise-level and
app-level business rules. Let us look at the specifications:
Figure 16.6: Clean architecture, four circles color schemes
Clean architecture can be visualized as four concentric
circles. The outer circle has the web, user interface (UI),
external interfaces, database, and devices like mobile and
tablets. The second circle has the controllers, gateways, and
presenters. The third circle has the use cases, and the center
circle has entities.
From the user interface, the user invokes the steps in a use
case. Then, the interactor of the use case sends the input to
the controller. The controller processes the request input and
sends the response, which is shared with the user from the
output port of the use case. The key part of the clean
architecture is the entities. They represent the business logic
and rules. They are minimally impacted by external requests
or API calls. They are independent of the other circles.
The entities are tied up with input validation, and the error
messages are to be displayed to the user. Use cases rely on
entities, and any change in the entities comes from the use
case. Let us take a simple example: The user as an entity.
Use cases like registration, login, logout, and others impact
the user entity, which has the attributes like username,
password, email, and others.

The interface adapters layer has data converters that
transform the data from one format to another. The format at
the external interface might be different from the one used
in web applications. There will be API, services, request
handlers, response formats, input validators, and
middleware. The database can be relational or No-SQL,
based on the structure of the data. The data used can be
structured, semi-structured, and unstructured data.
Unstructured data needs to be stored in a No-SQL database.
Now, let us look at the hexagonal architecture, as shown in
the following figure:
Figure 16.7: Hexagonal architecture
Hexagonal architecture helps in identifying the concerns and
dependencies in the web application. It also helps in
decoupling the concerns by having multiple layers. Each
layer will have a responsibility. There will be boundaries at
the intersection of the layers. Ports are like interfaces that
get data from external interfaces. Data can come from
external interfaces and be stored in a data source. Adapters

implement the interfaces (ports) by creating an
implementation. They help in transforming data and
processing the data requests to give a response from the
data source. Domain is the core of hexagonal architecture,
which includes business logic and rules. There are driving
and driven sides, which are the input and output of the web
application. Let us look at the hexagonal architecture, which
is layered:
Figure 16.8: Hexagonal architecture, layered architecture
Let us look at an e-commerce application that allows
customers, orders, and purchases to be made online through
a web and mobile application.
Let us first look at the project structure of the e-commerce
web application:
cmd/
main.go
internal/
application/

customer.go
purchase.go
domain/
customer.go
purchase.go
ports/
customer_port.go
purchase_port.go
web/
handlers/
customer_handler.go
purchase_handler.go
cmd package: This package has the main.go. It is the
entry 
point 
that 
integrates 
and 
injects 
the
dependencies.
internal/application package: This package has
customer and purchase use cases and related entities
in the domain package
internal/domain package: This package has the
entities that have the business rules and the logic.
internal/ports package: This package has customer
management and purchase handling services.
web/handlers package: This package has the request
handlers for requests related to customer and purchase
use cases.
Use cases can be registration, login, and logout for the
customer. Purchase-related use cases can be order creation,
product selection, adding an address to the order, and

paying for the order. Order status is a use case related to the
customer.
Let us look at the code for customer_port.go as follows:
package ports
import "context"
import "web-app/internal/domain"
type CustomerRepository interface {
SaveCustomer(ctx context.Context, customer 
*domain.Customer) error
GetCustomerByID(ctx context.Context, 
customerID string) (*domain.Customer, error)
}
type CustomerUseCase interface {
RegisterCustomer(ctx context.Context, name, 
email string) error
GetCustomerByID(ctx context.Context, 
customerID string) (*domain.Customer, error)
}
Now, let us look at one of the adapters, customer.go:
package application
import "context"
import "webapp/internal/domain"
import "webapp/internal/ports"
type CustomerUseCase struct {
customerRepository ports.CustomerRepository
}

func NewCustomerUseCase(customerRepo 
ports.CustomerRepository) *CustomerUseCase {
return &CustomerUseCase{customerRepository: 
customerRepo}
}
func (customerUC *CustomerUseCase) 
RegisterCustomer(ctx context.Context, name, email 
string) error {
}
func (customerUC *CustomerUseCase) 
GetCustomerByID(ctx context.Context, customerID 
string) (*domain.Customer, error) {
}
Now, let us look at how the dependencies are injected in the
entrypoint. The server is started in main.go:
package main
import (
"context"
"net/http"
"your-app/internal/application"
"your-app/internal/ports"
"your-app/web/handlers"
)
func main() {
customerRepo := initialize_customerRepo()
customerUseCase := 
application.NewCustomerUseCase(customerRepo)

http.HandleFunc("/customers/register", 
handlers.NewCustomerHandler(customerUseCase).Regist
erCustomer)
http.HandleFunc("/customers/{customerID}", 
handlers.NewCustomerHandler(customerUseCase).GetCus
tomerByID)
start_http_web_server()
}
Now, let us look at the web request handlers—
customer_handler.go:
package handlers
import (
"net/http"
"webapp/internal/application"
)
type CustomerHandler struct {
customerUseCase application.CustomerUseCase
}
func NewCustomerHandler(customerUseCase 
application.CustomerUseCase) *CustomerHandler {
return &CustomerHandler{customerUseCase: 
customerUseCase}
}
func (handler *CustomerHandler) 
RegisterCustomer(writer http.ResponseWriter, 
request *http.Request) {
}

func (handler *CustomerHandler) 
GetCustomerByID(writer http.ResponseWriter, request 
*http.Request) {
}
Hexagonal architecture has the following advantages:
Easily testable
Scalable
Change tolerance
Unit testing can be done easily as the business rules and
logic are separated from the external services. The system
can be maintained and functional updates can be done
without impacting the other components. The system
consists of different modules, and scaling can be done by
deploying different components in a distributed network. As
in any architecture methodology, trade-offs need to be made
between complexity and performance.
Conclusion
In this chapter, we have covered topics related to web apps
in Go recipes, building scalable and responsive web
applications, web app design principles, and web App
architecture principles. We looked at different Go recipes
while building web applications. Different techniques and
approaches were presented for building scalable and
responsive web applications. We learnt the web application
design principles like loose coupling and solid principles. We
looked at go web app architecture principles and
methodologies like clean architecture and hexagonal
architecture.
In the next chapter, the readers will be presented with
mobile app blueprint applications. They will understand the
design and architecture principles to build scalable mobile

applications. The blueprint solutions will include tips and
techniques for building performant mobile applications.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and
Sessions with the Authors:
https://discord.bpbonline.com

CHAPTER 17
Go Mobile Applications
Blueprints
Introduction
In this chapter, the readers will be presented with the mobile
app blueprint applications. The readers will understand the
design and architecture principles to build scalable mobile
applications. The blueprint solutions will have the tips and
techniques to build mobile applications that are performant.
Let us look at Mobile App Go Recipes, architecture, and
design principles to build a scalable and responsive mobile
app:
Figure 17.1: Go Mobile App blueprints

Structure
The chapter covers the following topics:
Challenges in Building Mobile Apps
Go Lang for mobile apps
Mobile App in Go Recipes
Building scalable and responsive mobile app
Mobile app design principles
Mobile app architecture principles
Objectives
Go language-based frameworks are popular in web and
mobile applications. Mobile apps are being developed as
native, hybrid, and mobile web applications. In this chapter,
we are going to discuss Go recipes for building mobile
applications. You will be able to build scalable and responsive
mobile applications. Mobile application architecture and
mobile design principles will be presented.
Challenges in building mobile apps
The challenges are as follows:
Device fragmentation: Developers face an ongoing
battle with device fragmentation. There are countless
devices on the market, each with its own screen size,
resolution, operating system version, and hardware
capabilities. Ensuring an app runs smoothly across this
vast spectrum can be daunting.
An app like Spotify needs to function seamlessly on
high-end devices like the latest iPhone as well as on
older, less powerful Android devices. This means

extensive testing and optimization to cater to a wide
audience.
Failing to address device fragmentation can lead to
poor user experience, negative reviews, and app
abandonment. 
Developers 
must 
adopt 
responsive
design and thorough testing to mitigate this.
Security concerns: With increasing data breaches
and cyber-attacks, security is a significant challenge.
Ensuring secure data storage, robust authentication,
and regular updates is crucial to protect user
information.
Banking apps, such as those from HDFC or ICICI,
require top-notch security features to protect sensitive
financial data. Implementing end-to-end encryption and
multi-factor authentication are just some measures
taken to ensure user safety.
A single security breach can erode user trust and
damage an app’s reputation. Vigilance in security
practices 
is 
non-negotiable 
to 
maintain 
user
confidence.
User experience (UX): Creating an intuitive and
engaging UX is vital. Users have high expectations and
little tolerance for apps that are hard to navigate or
slow 
to 
respond. 
Striking 
a 
balance 
between
functionality and simplicity is an ongoing challenge.
The success of apps like Airbnb lies in their seamless
UX design. They offer a straightforward booking
process, user-friendly interfaces, and quick load times.
This 
ease 
of 
use 
drives 
user 
satisfaction 
and
engagement.
Poor UX can lead to high uninstall rates and low user
engagement. Continuous UX research, prototyping,

and user testing are essential to keep the app relevant
and user-friendly.
Performance optimization: Performance issues such
as slow load times, crashes, and excessive battery
consumption can be detrimental. Users expect apps to
be fast and reliable, irrespective of their device or
network conditions.
Apps 
like 
PUBG 
Mobile 
need 
to 
deliver 
high-
performance 
gaming 
experiences. 
This 
involves
optimizing graphics, minimizing latency, and reducing
battery drain, all while ensuring smooth gameplay on
various devices. Failure to optimize performance can
lead to user frustration and high churn rates.
Continuous performance monitoring and optimization
are key to user retention.
Market competition: The app market is fiercely
competitive, with millions of apps vying for users’
attention. Standing out requires a unique value
proposition and effective marketing strategies.
TikTok’s success can be attributed to its innovative
features and aggressive marketing. Continuous feature
updates and trends keep users engaged and attract
new 
ones. 
Without 
differentiation 
and 
strong
marketing, even well-developed apps can struggle.
Developers 
need 
to 
focus 
on 
innovation, 
user
engagement, and strategic marketing to thrive.
Building a successful mobile app is a complex journey,
filled 
with 
numerous 
challenges. 
From 
device
fragmentation and security concerns to UX design and
performance optimization, each aspect requires careful
attention and continuous iteration. By addressing these
challenges head-on, developers can create compelling
and resilient apps that resonate with users and stand
out in a crowded market.

Go Lang for mobile apps
Go Lang was created by Google. It is an opensource
language and popular for concurrency and performance. Go
Lang apps can handle concurrent requests and can scale as
a web app or mobile app. These applications interact with
the backend, which can be REST API or any other API.
Let us look at an e-commerce system that has an online web
app and a mobile application. These applications help the
customer to order products from a catalog on the e-
commerce system. Vendors update their products and stock
after delivering and checking the inventory. Vendors have
the web and mobile applications to update the system. Since
the orders can come from different users and locations, the
system needs to be able to handle the load of concurrent
requests. Go language-based tech stack provides the
capability to scale the system to add more products from
different categories and geographic locations. This system
needs to integrate with order delivery and logistics systems.
The ordering system needs to be integrated with the
payment gateway, and payments need to be processed from
the customers and channeled to the vendor accounts. The
system provides a chat tool for the customers to interact
with the digital assistant/chatbot and the human personnel
for queries.
Many companies have started using Go Lang to build
enterprise mobile and web applications. Go Lang is
becoming popular in retail, telecom, insurance, and finance
domains. These apps are based on the Go Lang tech stack,
which makes them scalable and secure. These applications
have failover, reliability, efficiency, and auto-recovery
features. The system will have customer support and
assistance to answer customer queries and issues. Go Lang
can utilize multi-core, multi-task handling, and scaling to
create multiple modules. Developers can learn the language

quickly and use it to build enterprise web and mobile
applications.
Creating mobile applications using Go (Golang) involves
leveraging its robust and efficient nature to build high-
performance apps. Go is particularly well-suited for backend
development, but it can also be used for mobile applications
through various strategies. One approach is to write all-Go
native mobile applications, which allows developers to utilize
Go's concurrency model and performance benefits directly
on mobile platforms. This method ensures that the
application is both fast and efficient, taking full advantage of
Go's capabilities.
Another strategy is to create SDK applications by generating
bindings from a Go package and invoking them from Java on
Android or Objective-C on iOS. This approach allows
developers to write core logic in Go and then integrate it
with the native mobile code. This method is particularly
useful for developers who want to maintain a single
codebase for the core functionality while still leveraging the
native features and UI components of each platform.
Using tools like Go Blueprint can significantly streamline the
process of setting up Go projects. Go Blueprint provides a
standardized project structure, making it easier to manage
and scale applications. It supports various frameworks such
as Gin, Fiber, and Echo and offers features like database
integration, CI/CD workflows, and more. This tool helps
developers focus on writing application logic rather than
worrying about the initial setup and configuration.
Overall, Go's simplicity, performance, and concurrency
model make it an excellent choice for mobile application
development. Whether you are building a fully native app or
integrating Go with existing mobile frameworks, the
language offers a powerful and efficient way to develop high-
quality mobile applications.

Now, let us look at how to build a mobile app in Go Lang. We
will look at different recipes.
Mobile app in Go recipes
Go language is becoming popular for web and mobile
applications in different enterprises. Mobile applications are
user-friendly and perform well compared to web applications.
Web applications will have the front end on the server. A web
server serves the content for the web application. The
backend for mobile and web will be REST (representational
state transfer) API. REST is based on HTTP protocols. HTTP
methods that are used in REST are GET, PUT, POST, and
DELETE. Go Lang is popular because it is closer to C/C++
and can communicate well with C-shared packages. Go
mobile helps generate a package that the mobile
applications can use. This package is generated using cgo
tool. This package helps in talking to C code. First, you need
to write a main function which does not have any calls. This
go file can be converted into a shared package. This package
has a .h file and a .so file. Exported methods are in the .h
file. Gomobile has options to have the target as iOS and
Android. Go mobile has issues like limited data types and no
support for BitCode. Let us look at the commands for
building the app as iOS or Android:
     gomobile bind --target=ios 
   gomobile bind --target=android
Gomobile generates a .aar/jar for Android and 
.Framework for iOS
The backend code from the Android or iOS app built by the
mobile tool will interact with REST API. The REST API can be
used in any tech stack based on the Go language or any
other language. This backend REST API will interact with the
database and other data sources to retrieve and update the

data. This architecture style is termed as stateless
architecture, as most of the data is retrieved and updated
using the requests and responses. No data is stored in the
session. You can have master data stored in the caching
service. This helps in the mobile app response time. The
application can be scaled easily with the stateless
architecture.
To recap from Chapter 4, Building Rest API, the following
snippet is about the Gin framework:
In Go language, you can build REST API, which interacts with
relational databases to get and store data. You can use the
Gin REST framework. It is based on an HTTP Router, which
provides features like routing and form validation. You can
use GORM to store data in the relational database.
First, let us look at how to create an object model in Go Lang
based on a relational database model. In the models
package, we create an employee object, which is mapped by
GORM to a relational database table. The object fields are
mapped to relational database column types.
Regarding Beego, the following is the summary from Chapter
5, Go Web Apps:
In the Go language, you can use the Beego web framework
to develop web applications. Beego framework is an open-
source framework that has application tools, an ORM
framework, and other packages. ORM framework helps cut
down the ordeal of developing the relational schema and
mapping it to object classes and names of the attributes.
Beego is used to build REST APIs, which can be integrated
with open-source JavaScript frontend frameworks. We can
build a Beego web application using the Beego and SQLite
database. Beego framework helps develop web apps at an
affordable cost.

Kit is another framework that provides the capability to build
web applications interacting with databases and
microservices. The services can be interoperable, and non-
technical users can easily create web applications. For a
developer, it is tedious as every step is through the web
pages to create an application.
You can use Echo, which provides features for Http request
handling, building microservices based on REST protocol,
and securing the web application with SSL. We looked in
Chapter 4, Building REST API, Fiber framework based on Fast
HTTP.
You can use Fiber to design and develop REST APIs in Go
Lang. Fiber is an open-source REST API framework built on
the principles of Express.js with Fast HTTP.
Fast HTTP is better than the basic http/net package. Fast
HTTP performs better because of worker pool versus memory
allocation for different go routines in the http/net package.
It is not compatible with HTTP/2 and the Beego web app
framework. It can handle 100000 transactions per second
and 1 million network connections.
Martini can be used to build Go Lang web applications and
REST API-based services. It can also integrate with third-
party services. Martini is well documented and adopted by
many developers.
Let us look at how to build a scalable and responsive web
application.
Building scalable and responsive mobile app
Go language is popular as it can be used for mobile app tech
stack. These mobile apps are scalable and responsive.
Mobile apps can be rendered on different types of devices.
The devices can be based on the Windows/Android/IOS
operating system. Native mobile applications can be

developed using Android, Objective C, and Go Mobile. You
can have native apps that cross the platform using Flutter
and React Native. Mobile web apps can be built using React,
Angular, and Vue.js frameworks. Hybrid mobile applications
based on Android/IOS-friendly native browsers and
HTML/JS/CSS are also popular.
Mobile application requirements and architecture are
different from web applications. Mobile apps can run on
smartphones and tablets. The apps should be quick in
response and user-friendly. The development environment
(android/ios/mobile web) can debug and execute the mobile
app on the emulator/simulator/embedded browser/desktop
browser. The other important requirements are related to
security and compliance. In each domain, you have
regulations, laws, and policies to follow. For example, to
handle payments in an e-commerce app, security, and data
standards are important. Developers need to have skills and
knowledge to understand compliance requirements other
than standard mobile app tech stacks (android/ios/mobile
web). Having the prototypes done before the development
and getting user opinions about the journeys is very
important. This helps to cut down the iterations of the
development required to get the mobile app live. Let us look
at the mobile app tech stack:

Figure 17.2: Go Mobile App Architecture
Mobile app architecture consists of a mobile presentation
layer, service layer, database layer, and external API layers.
Having a good mobile app architecture defined early helps in
scaling the mobile app and having a good responsive and
performant app. Mobile architecture needs to support
communication with different services and APIs required for
the app to be responsive and performing. Mobile apps can
have features related to notifications, SMS, REST API
support, and local storage. You need to be able to add new
features/requirements in the defined architecture.
Architecture needs to be scalable to handle new groups of
users, business lines, geography, products, and functions.
The goal is to have elastic capability to handle growing app
users.
Creating scalable and responsive mobile apps using Go Lang
involves leveraging its unique attributes to maximize
performance and maintainability. At the heart of Go Lang is
its powerful concurrency model, which utilizes goroutines to
handle numerous tasks simultaneously. This is crucial for

mobile applications that need to be responsive and efficient,
particularly when dealing with real-time updates or
background processes.
Modularity is another key principle. By structuring your code
into reusable packages, you maintain a clean separation of
concerns, making the app easier to scale and maintain. This
modular approach allows for easier debugging and testing
and facilitates the integration of new features without
disrupting the existing functionality. Adopting clean
architecture principles, such as separating domain logic from
the UI and infrastructure, enhances the app's robustness and
flexibility.
Furthermore, Go Lang's cross-compilation capabilities
simplify the process of deploying applications across
different platforms. This feature ensures that developers can
write code once and run it anywhere, reducing the effort
required to support multiple operating systems. This
consistency in the build process enhances reliability and
speeds up time-to-market.
Building scalable and responsive mobile apps with Go Lang
involves leveraging its concurrency model, embracing
modularity, and utilizing cross-compilation. These principles
ensure that your mobile applications are not only efficient
and scalable but also easier to maintain and enhance. By
following these design principles, developers can create
robust and performant mobile applications that meet the
demands of modern users.
To make the architecture scalable, you need to perform the
following tasks before the start of development:
Types of devices to be supported
Current network latency problems in the geographical
areas of implementation

Current 
network 
connectivity 
issues 
in 
the
geographical areas of implementation
Techniques to avoid latency issues
Techniques to avoid network connectivity
User 
interface 
response 
times 
and 
navigation
capabilities on the devices
Techniques to support push notifications
Creating a development team with the required skills
Reusable components identification in the design and
architecture modules
Sustainability requirements
Future functional features in the roadmap
Mobile app security requirements like authentication
and authorization
Development plan and time frame identification
Testing plan and time frame identification
Device requirements are very important for the development
and testing of a mobile app. You need to identify the
following requirements early on:
Resolution requirements
Screen sizes to be supported
Memory requirements of the app
Memory of the devices to be supported
CPU of the devices to be supported
Storage of the devices to be supported
Now, let us look at design principles for designing web
applications.

Mobile app design principles
Designing a mobile app involves looking at various factors
like user experience and user journeys. The mobile app
needs to be designed to be user-friendly and needs to
support cross-platforms and different devices. The mobile
app must support different types of networks and associated
bandwidth and connectivity conditions. The geographies
where the mobile app will be used may have
high/medium/low bandwidth networks.
The design needs to be a factor where the app is going to be
used, like Tier1/Tier2/Tier3/… cities and towns. The
infrastructure capabilities of the geographies need to be
considered during the design. For example, a video call can
switch to an audio or chat call based on the varying
bandwidth conditions. The user can switch, or the call can be
switched to different modes automatically, and the user will
be notified. The computation and processing capabilities of
the device need to be considered if any computation and
time-consuming task needs to be performed on the device.
Most of the time, time-consuming tasks are performed on
the server-based services, and the service calls are invoked
by the mobile app.
Designing user experience involves having capabilities for
the user to navigate across the mobile app pages. Menus
need to be present for the user to navigate across the
pages/screens. The notifications and the alerts need to be
made in real-time. The design needs to handle events and
respond to user actions in real-time. For example, in a
trading app, getting the latest quote is important for the user
to put the buy/sell order. Mobile apps need to have
personalized menus and features. The color schemes, fonts,
icons, and typography need to conform with the cultural
standards and the accessibility requirements.

Mobile app needs to have an easy-to-use interface and follow
the minimal UI design methodology. This will help gain more
users as they like the app's ease and friendly user
experience. Across the application, themes need to be
maintained. Messaging and responding to the user with
notifications, alerts, and modal screens help the user to
navigate and complete the user journeys. Icons, pictures,
and help messages show the user the direction to go next to
execute the process.
There might be accessibility requirements such as support
for the following:
Visually impaired users
Hearing impaired users
Mobility impaired users
Color blind users
The design of the mobile app needs to provide images with
alternative text, navigation by keyboard, and videos with
captions. The design also needs to support labels for
buttons, breadcrumbs, progress indicators, sound-based
alerts, voice support, and help for navigation.
Mobile app design needs to support the following gestures:
Pinches
Swipes
Taps
Zoom in
Zoom out
When designing mobile applications with Go Lang,
developers are afforded a unique set of principles that
elevate the overall development process. At the core of Go
Lang's appeal is its simplicity and clarity, which translate into

fewer errors and more maintainable code. This language
encourages a clean and readable code structure that is
crucial for effective collaboration and long-term project
viability.
Concurrency is another standout feature of Go Lang, pivotal
for mobile apps that demand high responsiveness and
performance. Goroutines enable lightweight thread
management, allowing multiple processes to run
simultaneously without compromising efficiency. This makes
Go Lang particularly suited for mobile applications that must
handle numerous tasks concurrently, such as real-time
updates and background processing.
Modularity in Go Lang is essential for building scalable
mobile applications. By organizing code into reusable and
independent packages, developers can maintain a clear
separation of concerns. This not only simplifies debugging
and testing but also fosters an environment where updates
and new features can be integrated seamlessly. Coupling this
with clean architecture principles, such as segregating
domain logic from UI elements, further enhances the app’s
robustness and flexibility.
Cross-compilation is another powerful feature of Go Lang,
simplifying the process of deploying applications across
various platforms. This capability ensures that developers
can write code once and run it anywhere, minimizing the
effort required to support multiple operating systems. This
consistency in the build process enhances reliability and
accelerates time-to-market.
In conclusion, Go Lang’s simplicity, powerful concurrency
model, modularity, and cross-compilation capabilities make it
an excellent choice for mobile app development. These
principles ensure that mobile applications are not only
efficient and scalable but also easier to maintain and
enhance, paving the way for future growth and innovation.

By embracing these design principles, developers can create
robust and performant mobile applications that meet the
demands of modern users.
Now, let us look at the design principles. We will start with
user interface design principles.
The following are the UI design principles:
Create user interface prototypes to get user opinions
early
Always keep in mind the user navigation, states, auto
layout, and variables while designing
Split the complex process into multiple tasks
Each screen needs to have a specific task and goal
assigned
Do not try to abstract the key information to the user
No screen can take more than three taps/clicks on the
touchscreen (3 click rule)
Persist the screen data as the user enters the
information
The app needs to be accessible and work on different
devices
The text needs to be formal and help the user navigate
Colors, text, and tips need to be user-friendly
Readers might be interacting with users’ fast (F
pattern) eye movements for text-dense pages.
Readers might use linear and focused (Z pattern) eye
movements for rich screens.
Users need to type minimal information to perform the
task 
(dropdowns/combo 
boxes/clickable
options/autocomplete/prefill)

Now, let us look at the design principles that need to be
followed while designing the presentation, service, data
access, and external API integration layers.
Let us revisit the SOLID principles covered in Chapter 9, Go
Dependency Injection and SOLID. Robert C. Martin created
the SOLID principles, which are design tenets for creating
and developing software. These principles help make
software extensible, scalable, and enhanceable.
The SOLID principles are as follows:
Single Responsibility Principle (SRP)
Open/Closed Principle (OCP)
Liskov Substitution Principle (LSP)
Interface Segregation Principle (ISP)
Dependency Inversion Principle (DIP)
Now, let us look at the principles of mobile app architecture.
Mobile app architecture principles
Go Lang is becoming popular for its scalability and many
applications are nowadays being written in this language.
The term The Language of the Cloud is associated with Go.
You can use Go to build mobile, desktop, console, and web
applications. The architecture specific to Mobile applications
is based on patterns.
Crafting mobile applications with Go Lang requires a keen
understanding of its architectural principles to maximize
efficiency and maintainability. Central to this approach is
leveraging Go's simplicity and concurrency capabilities. With
goroutines and channels, Go Lang excels in handling multiple
tasks concurrently, a vital feature for creating responsive
and fast mobile applications.

Another critical aspect is the modularity of the code. By
structuring the application into modular packages,
developers can enhance both maintainability and scalability.
This modular approach not only keeps the codebase
organized but also facilitates easier updates and debugging.
Coupling this with clean architecture principles further
refines the structure. Clean architecture, with its emphasis
on separating domain logic from the UI and infrastructure,
ensures that the core functionality of the app remains
unaffected by changes in the external components.
Cross-compilation is another significant advantage of Go
Lang. This feature allows developers to build applications
across different platforms with ease, ensuring consistency
and reliability. The ability to compile code for various
operating systems and architectures without major
modifications streamlines the development process and
accelerates deployment cycles.
In summary, adopting Go Lang for mobile app development
involves a blend of simplicity, concurrency, modularity, and
cross-compilation. These principles collectively contribute to
building robust, efficient, and scalable mobile applications
that are easier to maintain and enhance over time.
For a mobile app, the following are the important decisions
related to architecture:
Can we add more requirements easily?
Can more users be added to the system?
Is the system easily testable?
Can the system handle a high concurrent number of
users?
What is the target date for the system's completion?
What is the cost of building the system?
Can we buy a mobile app that has the same features?

Will the user’s mobile device be in a Tier1/Tier2/Tier 3
network bandwidth place?
Are there known network outages in the area where
this mobile app is used?
Is there a latency expected because of connectivity and
network issues?
How frequently do we need to change the app and the
tech stack?
Can the system's architecture handle multiple OS,
namely Android/IOS/Windows/Mobile web?
Is the mobile app maintainable, and can it be
supported for issue resolution?
Do we need to gather analytics regarding who is trying
to download/install/use?
Does the system require monitoring, and does it need
to be efficient?
Can we have reusable code and components in the
design and the architecture?
Do we need a regression testing suite and an
automated testing suite for the mobile app and
backend?
Do we need to secure the mobile app?
Do we need to consider data security at rest, in transit,
and in motion?
Do 
we 
need 
to 
consider 
the 
device's
storage/memory/computing power?
Do 
we 
need 
to 
integrate 
with 
mobile 
device
management systems?
Does the app need to be responsive and have good
performance on all devices?

Do we need a content delivery network to speed up the
static content delivery?
Do we need to use the app's energy consumption and
data usage?
Do we need to make the system modular and apply
design patterns and abstraction?
Do we need logging, auditing, fault management,
failover, and self-healing in the system?
Do we need two-factor/multi-factor authentication and
authorization requirements?
Do we need to have locational intelligence, device
types, and mapping API in the architecture?
User experience is another area where we need to consider
the app's users, use cases, devices used by the business
personnel/consumers, B2B/B2C/C2C apps, offline usage, and
network connectivity. Regarding the app development, you
need to look at the cost, competent people, ownership, and
infrastructure cost. User experience needs to consider
factors like look and feel, user interaction, stability,
performance, navigation, and color schemes/themes.
Recapping from Chapter 16, Go Web Application Blueprints,
different architecture methodologies for developing mobile
apps. The mobile app will have a mobile user interface, and
the backend-based on rest services.
Now, let us look at the different architecture methodologies.
First, let us look at the clean architecture methodology.
Clean architecture
Clean architecture is about structuring your mobile app in a
way that makes it maintainable, scalable, and testable. Let
us break it down.
The key concepts are as follows:

Separation of concerns: This is about dividing your
app into distinct sections, each handling a single piece
of functionality. The goal is to ensure that changes in
one part do not affect others, making maintenance
easier.
Dependency rule: High-level modules should not
depend on low-level modules. Both should depend on
abstractions. This principle ensures that core business
logic is not dependent on the details of implementation,
like database or UI.
Entities: These are your business objects that
encapsulate the core rules of your application. They
should be free of frameworks and dependencies,
making them easy to test and adapt.
Use cases: These define the application-specific
business rules. They encapsulate and implement all the
use cases of the system. They orchestrate the flow of
data to and from the entities.
Interface adapters: These convert data from the
format most convenient for entities and use cases to
the format most convenient for whatever database or
UI framework you are using. They isolate the business
logic from changes in the presentation or database
frameworks.
Frameworks and drivers: The outermost layer,
containing frameworks and tools like UI, databases,
and other external services. This layer can be easily
swapped out without affecting the core of the
application.
Let us now look at an example. Imagine you are building a
To-Do list app:
Entities: These could be classes like Task and User.
They contain core properties and methods, like

Task.complete() or User.addTask(task).
Use 
cases: 
These 
would 
be 
the 
actions 
your
application performs, like adding a task, completing a
task, or fetching a user’s tasks. They might be methods
like 
AddTaskUseCase.execute() 
or
CompleteTaskUseCase.execute().
Interface adapters: If your use case interacts with a
database to fetch or store tasks, the adapter will
handle the translation of data formats.
Frameworks and drivers: Here, you have your UI
code that shows the tasks in a list, perhaps a database
like SQLite that stores tasks, and networking code if
you are syncing tasks across devices.
Let us look at the challenges in this architectural style:
Maintainability: With clean architecture, your code is
modular and organized, making it easier to locate and
fix bugs. Each layer operates independently, so making
changes to one does not ripple through the entire
application.
Testability: Clean architecture makes unit testing
straightforward. Because business rules are separated
from UI and other frameworks, you can test the core
logic without needing the UI or database.
Scalability: As your application grows, you can add
new features by adding new use cases or entities
without refactoring existing code significantly.
Flexibility: Need to swap out the database? With clean
architecture, this is less of a hassle. Since your
business logic does not directly depend on external
frameworks, you can replace or upgrade parts of your
system with minimal disruption.

Collaboration: Different teams can work on different
layers without stepping on each other’s toes. For
example, the UI team can work on the presentation
layer while the backend team works on the business
logic.
Clean architecture is a powerful approach to building mobile
applications, giving you a robust framework to manage
complexity and adapt to change. This way, your app not only
works well today but is also built to handle the demands of
the future.
Now, let us look at the hexagonal architecture.
Hexagonal architecture
Absolutely, hexagonal architecture—often referred to as
ports and adapters architecture—is a fascinating approach to
structuring a mobile application. Here is a fresh take on it:
The key concepts are as follows:
Core domain logic: At the heart of hexagonal
architecture is your application’s core domain logic.
This 
is 
where 
your 
business 
rules 
and 
core
functionalities reside. It is completely agnostic to any
external systems, ensuring that changes to external
systems do not affect your core logic.
Ports: These are the entry points to your core domain.
They define the interfaces that other systems must use
to interact with your application. Think of ports as the
sockets where adapters plug in.
Adapters: These are the implementations of the ports.
They allow various external systems to communicate
with your core domain logic. Adapters handle things
like database access, UI interactions, and third-party
services.

Separation of concerns: Hexagonal architecture
emphasizes keeping your business logic separate from
the details of how it is delivered and stored. This makes
your application easier to test and modify over time.
Isolation of frameworks: By isolating your core logic
from 
frameworks 
and 
libraries, 
you 
reduce
dependencies and increase flexibility. Your core logic
should be completely unaware of any frameworks.
Let us now look at an example. Imagine you are building an
e-commerce mobile app:
Core domain logic: Classes like Order, Customer, and
Product. 
Methods 
here 
include 
actions 
like
Order.addProduct(product) 
or
Customer.placeOrder(order).
Ports: 
Interfaces 
like 
OrderService 
and
CustomerRepository. These interfaces define how
external systems will interact with the core domain.
Adapters: Implementations of the interfaces. For
instance, 
DatabaseOrderRepository, 
which
implements CustomerRepository to interact with a
database, or RESTOrderService, which handles HTTP
requests.
The potential implications are as follows:
Testability: By decoupling your business logic from
external systems, you can easily test your core logic
without needing to set up a database or an external
service. You can mock the ports and test the core logic
in isolation.
Maintainability: Changes in one part of the system
(for example, switching from one database to another)
do not impact the core domain logic. You only need to
change the adapter.

Flexibility: If you need to add a new way to interact
with your system (for example, adding a new API
endpoint), you can do so by creating a new adapter
without changing the core domain logic.
Scalability: As your application grows, you can
manage complexity by keeping a clear separation
between different parts of the system. This makes it
easier to add new features and maintain existing ones.
Resilience: If an external system fails, the core
domain remains unaffected. Adapters can handle
retries, fallbacks, and other resilience strategies
without polluting the core logic.
In essence, hexagonal architecture empowers you to build
applications that are robust, scalable, and adaptable to
change. It offers a clear separation of concerns, making your
mobile app easier to test, maintain, and evolve. This
approach ensures that your app is well-prepared to meet
future demands while remaining resilient in the face of
changes and challenges.
There are architectural patterns to build mobile applications.
Those are listed as follows:
Model View Controller (MVC)
Model View Presenter (MVP)
Model-View-ViewModel (MVVM)
View Interactor Presenter Entity Router (VIPER)
Let us look at the MVC architecture pattern in a layered
architecture diagram:

Figure 17.3: MVC architecture pattern
MVC architecture for a mobile app will have an
Android/IOS/Mobile web view layer. The controller will be the
API gateway and orchestrator of the REST API Services. The
model layer can be an ORM framework. If you want to use
MVP, the model view remains the same as the MVC pattern.
The presenter in the mobile app case will be an
Android/iOS/web client that manages the data retrieval and
rendering. The difference here is that View focuses on
rendering, and the presenter manages the app’s state by
calling the REST API. The presenter manages the data
updates and pushes it to the View using the model layer—
REST API talking to the database. In MVVM, the view model is
the additional part with a clear separation of the UI data
model and the interface to be rendered. User controls on the
form or a table will be rendered using the UI model.
VIPER architecture will have a mobile user interface as a
view layer, and a presenter layer similar to the MVP pattern,
and an interactor will be the data handler for the view layer.
The router manages the navigation of the user and presents
a smooth user experience. The interactor will be sending
requests and receiving responses from the entity, which can
be REST API talking to the data sources.

Conclusion
In this chapter, we have covered topics related to mobile
apps in Go recipes, building scalable and responsive mobile
applications, mobile app design principles, and mobile app
architecture principles. We looked at different Go recipes
while building mobile native/hybrid/mobile web applications.
Different techniques and approaches were presented for
building scalable and responsive mobile native/hybrid/mobile
web applications. We learned the native/hybrid/mobile web
application design principles like loose coupling and solid
principles. We looked at Go native/hybrid/mobile web app
architecture principles and methodologies like clean
architecture and hexagonal architecture. We also looked at
different architectural patterns like MVC, MVP, MVVM, and
VIPER.
Join our book’s Discord space
Join the book's Discord Workspace for Latest updates, Offers,
Tech happenings around the world, New Release and
Sessions with the Authors:
https://discord.bpbonline.com

Index
A
Arrays 21, 22
B
Beego 131
Beego, configuring 141
Beego REST API 169
Beego REST API, optimizing 169-174
Beego Web App, developing 131-140
Behavioral Design, pattern
Chain Responsibility 322-326
Command 326-328
Interpreter 329-331
Iterator 332-334
Mediator 334-336
Memento 336-338
Observer 338-340
State 341-344
Strategy 345, 346
Template Method 346-348
Visitor 349-351
Bubble Sort 76-78
C
CatalogServer 165
Channels 197
Channels, challenges 199
Channels, optimizing 198-201
Channels, patterns 202-204
Channels, types 202
Clean Architecture 386, 387
Clean Architecture, challenges
collaboration 407
flexibility 407
maintainability 406
scalability 407
testability 406

Clean Architecture, concepts
concerns, separation 406
entities 406
frameworks, drivers 406
interface, adapters 406
rule, dependency 406
use cases 406
Clean Architecture, points 404, 405
Concurrency 42-45
Concurrency, aspects 46
Concurrency, patterns 48
Concurrency, points 45
Concurrency, repository 379
Concurrency, tools 379
console-based app 50-56
Containerize Microservices 265
Containers 230
Containers, capabilities 231
Containers, visualizing 231, 232
Creational Design 302
Creational Design, patterns
Abstract Factory 302-304
Builder 304-306
Factory Method 306-308
Prototype 308-310
Singleton 310, 311
CRM 168
CRM, modules 168
Cross-Compilation 402
D
Database Interaction 67-69
Data Structures 69-73
demographics 204
demographics, factors 205
demographics, formats 206
demographics, types 204
Dependency Injection 222-224
Dependency Injection, dependency 224, 225
Dependency Injection, factors 228
Dependency Injection, frameworks
Dingo 227
Facebook's Inject 227
Google's Wire 227
Uber's Dig 227

Dependency Injection, method
constructor 226
manual 226
setter 226
struct/interfaces 225
Dependency Inversion Principle (DIP) 221, 222
DevSecOps 273
Digital Certificates, steps 281, 282
Digital Certificates, types 275
Docker 232
Docker, architecture 233, 234
Docker Compose 235, 236
Docker, history 233
Dockerize Microservice 244
Dockerize Microservice, integrating 244-246
Docker Network, configuring 237
Docker Registry 234, 235
E
Echo 376
EmbeddedStruct 36
Error Handling 31-33
F
Fast HTTP 377
Fiber 78
FlightCloner 308
G
Go Lang 2-4
Go Lang, applications 363
Go Lang, best practices 107, 108
Go Lang, challenges
Dynamic Memory, allocating 359, 360
HTTP Request, response 360-362
Recursion 358, 359
Go Lang Code, profiling 355-357
Go Lang, constants 11, 12
Go Lang Data, types
basic type 4, 5
composite 6, 7
interface 9, 10
reference 8, 9
Go Lang, factors 364

Go Lang, formats
JSON 62-64
Text 60-62
XML 64-66
Go Lang, history 2, 375
Go Lang Mobile, apps 395, 396
Go Lang, operations
database, connecting 113
database, deleting 117
database Id, retrieving 114
employee database, adding 116
employee database, updating 116
employees, retrieving 115
Go Lang, operators 12-16
Go Lang, performance 354, 355
Go Lang, pointers 23, 24
Go Lang, statements
if condition 16-18
switch 19
Go Lang, structures 24, 25
Go Lang, variables 10, 11
Go Performance Patterns, aspects
concurrency, handling 365
CPU Intensive, tasks 366, 367
web traffic, handling 367-369
Goroutines 194
Go Services 237
Go Services With REST API, utilizing 238-243
GRASP Patterns, principles
abstraction 352
controller 352
creator 351
high, cohesion 352
information, expertise 351
low, coupling 351
Polymorphism 352
pure, fabrication 352
gRPC 144
gRPC Clients, optimizing 156-161
gRPC, configuring 145
gRPC, features 144
gRPC Server 161-164
H
healthcare domain, features 288

Hexagonal Architecture 387, 388
Hexagonal Architecture, advantages 391
Hexagonal Architecture, implications
flexibility 408
maintainability 408
resilience 408
scalability 408
testability 408
Hexagonal Architecture, key concepts
adapters 407
concerns, separation 407
core domain, logic 407
framework, isolation 407
ports 407
I
Interface Segregation Principle (ISP) 219, 220
Interfaces Embedding 34-36
Interfaces Embedding, methods
Empty Interface 36, 37
Nil Interface 39-41
Type Assertion 37, 38
Type Switch 38, 39
IPhoto 317
K
kernel interaction, preventing 196, 197
kernel interaction, steps 195
Kit 376
Kubernetes 266
Kubernetes, preventing 266-268
L
lexer 330
Liskov Substitution Principle (LSP) 217-219
M
map 22, 23
Marshal() 64
Martini 377
MessagePublisher 240
Microservice 244, 253
Microservices Architecture 250
Microservices Architecture, resources 253

Microservices Architecture, visualizing 250-253
Microservices With REST API, integrating 253-261
mobile apps, architecture 400
mobile apps, challenges
device, fragmentation 394
market, competition 395
performance, optimizing 395
security, concerns 394
User Experience (UX) 395
mobile apps, features 400
mobile apps, gestures 402
mobile apps, optimizing 398-400
mobile apps, patterns 408
mobile apps, principles 401
Modularity 378
Monolithic Architecture 248
Monolithic Architecture, features 249
Monolithic Architecture, metrics 248
Monolithic Architecture, optimizing 249
Monolithic Architecture, services 250
Mutex 46
Mutex, methods 46
Mutex, uses 47
MVC Architecture 409
MySQL Service, steps 117-122
O
Object-Oriented Design (OOD) 351
Open/Closed Principle (OCP) 215-217
P
Parallelism/Concurrency, difference 193
Parallelism/Concurrency, principles 190-192
performance metrics, tools 363
PKI, key concern 275
Postman 174
Postman, operations
API, invoking 299, 300
create 294
deleting 298, 299
getting 294-296
updating 296, 297
Postman, preventing 175-177
Profile Management, features 283
Profile Management, setting up 283

Protobuf 147
Protobuf, optimizing 148-152
Protobuf, steps 147
Public Key Infrastructure (PKI) 275, 276
R
RBAC, features 271, 272
Recover/Defer/Panic 25-27
REST API 78-80
REST API, routes 96, 97
REST API, securing 288-292
REST API With MQ, interacting 98-106
REST API With NoSQL, interacting 88-95
REST API With RD, interacting 80-87
REST Web App, developing 123-129
REST Web App, interacting 130, 131
Role-Based Access Control (RBAC) 270, 271
S
SAML, process 284, 285
Security Assertion Markup Language (SAML) 284
Security, principles 274
Security, web applications
Application Code, signing 277, 278
code, signing 276, 277
Public Key Infrastructure (PKI) 275
SSH Key 278, 279
SSL/TLS, certificates 276
Trust, exchanging 280, 281
Single Responsibility Principle (SRP) 213-215
SOLID 212
SOLID, components 383
SOLID, layers 383, 384
SOLID, principles
Dependency Inversion Principle (DIP) 221
Interface Segregation Principle (ISP) 219
Liskov Substitution Principle (LSP) 217
Open/Closed Principle (OCP) 215
Single Responsibility Principle (SRP) 213-215
SQLCompiler 314
sqlite3 69
SSH Key 278, 279
SSH Key, threats
Application Data 279
Application Lifecycle, transitions 279

Application Linkage 279
attack, profiling 280
attack, tracking 280
behavioral, leakage 280
Identification 279
identity-theft, attack 280
inventory, attack 280
Localization Data, leakage 280
privacy, interacting 280
Strings 20, 21
Structural Design, pattern
Adapter 312, 313
Bridge 314, 315
Composite 315, 316
Decorator 317, 318
Facade 318-320
SWIFT 272
T
TCLM, features 287
TCLM, impact 287
TCLM, points
agent, setup 285
business unit, setup 285
certificate, integrating 286
certificate, issuing 286
Certificate Template, setup 285
DNS, integrating 286
License, managing 286
Lifecycle, managing 286
Profile, setup 285
sensor 286
sensor, connection 286
Trust Certificate, connector 286
Trust Certificate, enrolment 286
Trust Certificate, setup 285
TruckFactory 303
Trust Certificate Lifecycle Management (TCLM) 285
Type Casting 41, 42
U
UI Design, principles 402, 403
unified management, process 283, 284
UnMarshal() 64

W
web app 177
web app, architectures 384
web app, aspects 385
web app, implementing 178-187
web app, package 385
web app, principles 381, 382
web app, steps 177

