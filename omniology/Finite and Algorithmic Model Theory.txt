
LONDON MATHEMATICAL SOCIETY LECTURE NOTE SERIES
Managing Editor: Professor M. Reid, Mathematics Institute,
University of Warwick, Coventry CV4 7AL, United Kingdom
The titles below are available from booksellers, or from Cambridge University Press at
www.cambridge.org/mathematics
280
Characters and automorphism groups of compact Riemann surfaces,
T. BREUER
281
Explicit birational geometry of 3-folds,
A. CORTI & M. REID (eds)
282
Auslander–Buchweitz approximations of equivariant modules,
M. HASHIMOTO
283
Nonlinear elasticity,
Y.B. FU & R.W. OGDEN (eds)
284
Foundations of computational mathematics,
R. DEVORE, A. ISERLES & E. S ¨ULI (eds)
285
Rational points on curves over ﬁnite ﬁelds,
H. NIEDERREITER & C. XING
286
Clifford algebras and spinors (2nd Edition),
P. LOUNESTO
287
Topics on Riemann surfaces and Fuchsian groups,
E. BUJALANCE, A.F. COSTA & E. MART´INEZ
(eds)
288
Surveys in combinatorics, 2001,
J.W.P. HIRSCHFELD (ed)
289
Aspects of Sobolev-type inequalities,
L. SALOFF-COSTE
290
Quantum groups and Lie theory,
A. PRESSLEY (ed)
291
Tits buildings and the model theory of groups,
K. TENT (ed)
292
A quantum groups primer,
S. MAJID
293
Second order partial differential equations in Hilbert spaces,
G. DA PRATO & J. ZABCZYK
294
Introduction to operator space theory,
G. PISIER
295
Geometry and integrability,
L. MASON & Y. NUTKU (eds)
296
Lectures on invariant theory,
I. DOLGACHEV
297
The homotopy category of simply connected 4-manifolds,
H.-J. BAUES
298
Higher operads, higher categories,
T. LEINSTER (ed)
299
Kleinian groups and hyperbolic 3-manifolds,
Y. KOMORI, V. MARKOVIC & C. SERIES (eds)
300
Introduction to M¨obius differential geometry,
U. HERTRICH-JEROMIN
301
Stable modules and the D(2)-problem,
F.E.A. JOHNSON
302
Discrete and continuous nonlinear Schr¨odinger systems,
M.J. ABLOWITZ, B. PRINARI & A.D.
TRUBATCH
303
Number theory and algebraic geometry,
M. REID & A. SKOROBOGATOV (eds)
304
Groups St Andrews 2001 in Oxford I,
C.M. CAMPBELL, E.F. ROBERTSON & G.C. SMITH (eds)
305
Groups St Andrews 2001 in Oxford II,
C.M. CAMPBELL, E.F. ROBERTSON & G.C. SMITH (eds)
306
Geometric mechanics and symmetry,
J. MONTALDI & T. RATIU (eds)
307
Surveys in combinatorics 2003,
C.D. WENSLEY (ed.)
308
Topology, geometry and quantum ﬁeld theory,
U.L. TILLMANN (ed)
309
Corings and comodules,
T. BRZEZINSKI & R. WISBAUER
310
Topics in dynamics and ergodic theory,
S. BEZUGLYI & S. KOLYADA (eds)
311
Groups: topological, combinatorial and arithmetic aspects,
T.W. M ¨ULLER (ed)
312
Foundations of computational mathematics, Minneapolis 2002,
F. CUCKER et al (eds)
313
Transcendental aspects of algebraic cycles,
S. M ¨ULLER-STACH & C. PETERS (eds)
314
Spectral generalizations of line graphs,
D. CVETKOVI ´C, P. ROWLINSON & S. SIMI ´C
315
Structured ring spectra,
A. BAKER & B. RICHTER (eds)
316
Linear logic in computer science,
T. EHRHARD, P. RUET, J.-Y. GIRARD & P. SCOTT (eds)
317
Advances in elliptic curve cryptography,
I.F. BLAKE, G. SEROUSSI & N.P. SMART (eds)
318
Perturbation of the boundary in boundary-value problems of partial differential equations,
D. HENRY
319
Double afﬁne Hecke algebras,
I. CHEREDNIK
320
L-functions and Galois representations,
D. BURNS, K. BUZZARD & J. NEKOV ´A ˇR (eds)
321
Surveys in modern mathematics,
V. PRASOLOV & Y. ILYASHENKO (eds)
322
Recent perspectives in random matrix theory and number theory,
F. MEZZADRI & N.C. SNAITH (eds)
323
Poisson geometry, deformation quantisation and group representations,
S. GUTT et al (eds)
324
Singularities and computer algebra,
C. LOSSEN & G. PFISTER (eds)
325
Lectures on the Ricci ﬂow,
P. TOPPING
326
Modular representations of ﬁnite groups of Lie type,
J.E. HUMPHREYS
327
Surveys in combinatorics 2005,
B.S. WEBB (ed)
328
Fundamentals of hyperbolic manifolds,
R. CANARY, D. EPSTEIN & A. MARDEN (eds)
329
Spaces of Kleinian groups,
Y. MINSKY, M. SAKUMA & C. SERIES (eds)
330
Noncommutative localization in algebra and topology,
A. RANICKI (ed)
331
Foundations of computational mathematics, Santander 2005,
L.M PARDO, A. PINKUS, E. S ¨ULI &
M.J. TODD (eds)
332
Handbook of tilting theory,
L. ANGELERI H ¨UGEL, D. HAPPEL & H. KRAUSE (eds)

333
Synthetic differential geometry (2nd Edition),
A. KOCK
334
The Navier–Stokes equations,
N. RILEY & P. DRAZIN
335
Lectures on the combinatorics of free probability,
A. NICA & R. SPEICHER
336
Integral closure of ideals, rings, and modules,
I. SWANSON & C. HUNEKE
337
Methods in Banach space theory,
J.M.F. CASTILLO & W.B. JOHNSON (eds)
338
Surveys in geometry and number theory,
N. YOUNG (ed)
339
Groups St Andrews 2005 I,
C.M. CAMPBELL, M.R. QUICK, E.F. ROBERTSON & G.C. SMITH (eds)
340
Groups St Andrews 2005 II,
C.M. CAMPBELL, M.R. QUICK, E.F. ROBERTSON & G.C. SMITH
(eds)
341
Ranks of elliptic curves and random matrix theory,
J.B. CONREY, D.W. FARMER, F. MEZZADRI &
N.C. SNAITH (eds)
342
Elliptic cohomology,
H.R. MILLER & D.C. RAVENEL (eds)
343
Algebraic cycles and motives I,
J. NAGEL & C. PETERS (eds)
344
Algebraic cycles and motives II,
J. NAGEL & C. PETERS (eds)
345
Algebraic and analytic geometry,
A. NEEMAN
346
Surveys in combinatorics 2007,
A. HILTON & J. TALBOT (eds)
347
Surveys in contemporary mathematics,
N. YOUNG & Y. CHOI (eds)
348
Transcendental dynamics and complex analysis,
P.J. RIPPON & G.M. STALLARD (eds)
349
Model theory with applications to algebra and analysis I,
Z. CHATZIDAKIS, D. MACPHERSON,
A. PILLAY & A. WILKIE (eds)
350
Model theory with applications to algebra and analysis II,
Z. CHATZIDAKIS, D. MACPHERSON,
A. PILLAY & A. WILKIE (eds)
351
Finite von Neumann algebras and masas,
A.M. SINCLAIR & R.R. SMITH
352
Number theory and polynomials,
J. MCKEE & C. SMYTH (eds)
353
Trends in stochastic analysis,
J. BLATH, P. M ¨ORTERS & M. SCHEUTZOW (eds)
354
Groups and analysis,
K. TENT (ed)
355
Non-equilibrium statistical mechanics and turbulence,
J. CARDY, G. FALKOVICH & K. GAWEDZKI
356
Elliptic curves and big Galois representations,
D. DELBOURGO
357
Algebraic theory of differential equations,
M.A.H. MACCALLUM & A.V. MIKHAILOV (eds)
358
Geometric and cohomological methods in group theory,
M.R. BRIDSON, P.H. KROPHOLLER &
I.J. LEARY (eds)
359
Moduli spaces and vector bundles,
L. BRAMBILA-PAZ, S.B. BRADLOW, O. GARC´IA-PRADA &
S. RAMANAN (eds)
360
Zariski geometries,
B. ZILBER
361
Words: Notes on verbal width in groups,
D. SEGAL
362
Differential tensor algebras and their module categories,
R. BAUTISTA, L. SALMER ´ON &
R. ZUAZUA
363
Foundations of computational mathematics, Hong Kong 2008,
F. CUCKER, A. PINKUS &
M.J. TODD (eds)
364
Partial differential equations and ﬂuid mechanics,
J.C. ROBINSON & J.L. RODRIGO (eds)
365
Surveys in combinatorics 2009,
S. HUCZYNSKA, J.D. MITCHELL & C.M. RONEY-DOUGAL (eds)
366
Highly oscillatory problems,
B. ENGQUIST, A. FOKAS, E. HAIRER & A. ISERLES (eds)
367
Random matrices: High dimensional phenomena,
G. BLOWER
368
Geometry of Riemann surfaces,
F.P. GARDINER, G. GONZ ´ALEZ-DIEZ & C. KOUROUNIOTIS (eds)
369
Epidemics and rumours in complex networks,
M. DRAIEF & L. MASSOULI´E
370
Theory of p-adic distributions,
S. ALBEVERIO, A.YU. KHRENNIKOV & V.M. SHELKOVICH
371
Conformal fractals,
F. PRZYTYCKI & M. URBA ´NSKI
372
Moonshine: The ﬁrst quarter century and beyond,
J. LEPOWSKY, J. MCKAY & M.P. TUITE (eds)
373
Smoothness, regularity and complete intersection,
J. MAJADAS & A. G. RODICIO
374
Geometric analysis of hyperbolic differential equations: An introduction,
S. ALINHAC
375
Triangulated categories,
T. HOLM, P. JØRGENSEN & R. ROUQUIER (eds)
376
Permutation patterns,
S. LINTON, N. RUˇSKUC & V. VATTER (eds)
377
An introduction to Galois cohomology and its applications,
G. BERHUY
378
Probability and mathematical genetics,
N.H. BINGHAM & C.M. GOLDIE (eds)
379
Finite and algorithmic model theory,
J. ESPARZA, C. MICHAUX & C. STEINHORN (eds)
380
Real and complex singularities,
M. MANOEL, M.C. ROMERO FUSTER & C.T.C WALL (eds)
381
Symmetries and integrability of difference equations,
D. LEVI, P. OLVER, Z. THOMOVA &
P. WINTERNITZ (eds)
382
Forcing with random variables and proof complexity,
J. KRAJ´I ˇCEK
383
Motivic integration and its interactions with model theory and non-Archimedean geometry I,
R. CLUCKERS, J. NICAISE & J. SEBAG (eds)
384
Motivic integration and its interactions with model theory and non-Archimedean geometry II,
R. CLUCKERS, J. NICAISE & J. SEBAG (eds)
385
Entropy of hidden Markov processes and connections to dynamical systems,
B. MARCUS,
K. PETERSEN & T. WEISSMAN (eds)

London Mathematical Society Lecture Notes series: 379
Finite and Algorithmic Model Theory
Edited by
JAVIER ESPARZA
Technische Universit¨at M¨unchen, Germany
CHRISTIAN MICHAUX
Universit´e de Mons, Belgium
CHARLES STEINHORN
Vassar College, New York, USA

cambridge university press
Cambridge, New York, Melbourne, Madrid, Cape Town,
Singapore, S˜ao Paulo, Delhi, Tokyo, Mexico City
Cambridge University Press
The Edinburgh Building, Cambridge CB2 8RU, UK
Published in the United States of America by Cambridge University Press, New York
www.cambridge.org
Information on this title: www.cambridge.org/9780521718202
C⃝Cambridge University Press 2011
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.
First published 2011
Printed in the United Kingdom at the University Press, Cambridge
A catalogue record for this publication is available from the British Library
Library of Congress Cataloguing in Publication data
Finite and algorithmic model theory / edited by Javier Esparza, Christian Michaux,
Charles Steinhorn.
p.
cm. – (London Mathematical Society lecture note series ; 379)
Includes index.
ISBN 978-0-521-71820-2 (pbk.)
1. Finite model theory.
2. Computer science – Mathematics.
I. Esparza, Javier.
II. Michaux, Christian.
III. Steinhorn, Charles.
IV. Title. V. Series.
QA9.7.F565
2011
511.3′4 – dc22
2010048062
ISBN 978-0-521-71820-2 Paperback
Cambridge University Press has no responsibility for the persistence or
accuracy of URLs for external or third-party internet websites referred to
in this publication, and does not guarantee that any content on such
websites is, or will remain, accurate or appropriate.

Contents
Preface
page vii
Javier Esparza, Christian Michaux and Charles Steinhorn
1
Automata-based presentations of inﬁnite structures
1
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
2
Logical aspects of spatial databases
77
Bart Kuijpers and Jan Van den Bussche
3
Some connections between ﬁnite and inﬁnite model theory
109
Vera Koponen
4
Deﬁnability in classes of ﬁnite structures
140
Dugald Macpherson and Charles Steinhorn
5
Algorithmic meta-theorems
177
Stephan Kreutzer
6
Model theoretic methods for fragments of FO and special
classes of (ﬁnite) structures
271
Martin Otto
v


Preface
This volume is based on the satellite workshop on Finite and Algorithmic Model
Theory that took place at the University of Durham, January 9–13, 2006, to
inaugurate the scientiﬁc program Logic and Algorithms held at the Isaac Newton
Institute for Mathematical Sciences during the ﬁrst six months of 2006. The
goal of the workshop was to explore the emerging and potential connections
between ﬁnite and inﬁnite model theory, and their applications to theoretical
computer science. The primarily tutorial format introduced researchers and
graduate students to a number of fundamental topics. The excellent quality
of the tutorials suggested to the program organizers, Anuj Dawar and Moshe
Vardi, that a volume based on the workshop presentations could serve as a
valuable and lasting reference. They proposed this to the workshop scientiﬁc
committee; this volume is the outcome.
The Logic and Algorithms program focused on the connection between
two chief concerns of theoretical computer science: (i) how to ensure and
verify the correctness of computing systems; and (ii) how to measure the
resources required for computations and ensure their efﬁciency. The two areas
historically have interacted little with each other, partly because of the divergent
mathematical techniques they have employed. More recently, areas of research
in which model-theoretic methods play a central role have reached across both
sides of this divide. Results and techniques that have been developed have
found applications to ﬁelds such as database theory, complexity theory, and
veriﬁcation.
Some brief historical remarks help situate the context for this volume. The
study of the model-theoretic properties of ﬁnite structures emerged initially as
a branch of classical model theory, with its focus primarily on ﬁrst-order logic.
Beginning in the late 1980s, however, research concerning logics on ﬁnite struc-
tures diverged sharply from work in classical model theory. Classical model
theory, with its emphasis on inﬁnite structures, had made dramatic advances
vii

viii
Preface
both theoretically and in applications to other areas of mathematics. Work on
ﬁnite structures focused on connections with discrete complexity theory and
veriﬁcation. Indeed, the connections between ﬁnite model theory, descriptive
complexity theory, parameterized complexity, and state machine veriﬁcation
are now so strong that boundaries between them are hard to distinguish.
The methods employed in these two facets of model theory also grew apart
during this period. Probabilistic techniques and machine simulations have
played a prominent role in the study of ﬁnite structures, and stand in con-
trast to the geometric, algebraic, and analytic methods that pervade classical
(inﬁnite) model theory. Although both classical and ﬁnite model theory deal
with restricted classes of structures, the conditions by which such classes are
delimited also have been quite different. Finite model theory and veriﬁcation
typically concentrate on classes linked to particular computing formalisms, or
to which decomposition methods from ﬁnite graph theory can be applied. In
contrast, inﬁnitary model theory usually places restrictions on combinatorial
or geometric properties of the deﬁnable sets of a structure.
Yet, there are recent indications of a re-convergence of classical model
theory and logical aspects of computer science. This has resulted both from the
interest of computer scientists in new computing and speciﬁcation models
that make use of inﬁnitary structures, and from the development of powerful
model-theoretic techniques that provide insight into ﬁnite structures. If there is
an overarching theme, it is how various “tameness” hypotheses used to delimit
classes of structures and logics have deeply impacted the study of those aspects
of theoretical computer science in which model-theory naturally comes into
play. The chapters that comprise this volume survey many of the common
themes that have emerged and gained attention, and point to the signiﬁcant
potential for wider interaction.
The chapter of B´ar´any, Gr¨adel, and Rubin, Automata-based presentations of
inﬁnite structures develops what the authors call algorithmic model theory. The
authors direct their attention to the “tame” class of automatic structures, that is
structures that have a presentation in a precise sense by automata operating on
ﬁnite or inﬁnite words or trees. The goal of this work, to extend algorithmic and
logical methods from ﬁnite structures to ﬁnitely presented inﬁnite structures,
has been a focal point for research in computer science, combinatorics, and
mathematical logic. This point of view allows structures to be viewed alternately
from both a ﬁnite and inﬁnite model theoretic perspective. The theory that
has emerged makes use of techniques both from classical model theory and
theoretical computer science, and has found appealing applications to several
areas, including database theory, complexity theory and veriﬁcation.

Preface
ix
Classical model theory by and large concentrates on the analysis of the
ﬁrst-order deﬁnable sets over a structure, that is, those sets of n-tuples of the
universe whose deﬁnition is given by a ﬁrst-order formula. This analysis has
predominantly taken two forms. The ﬁrst is based on the “structural complex-
ity” of the formula, e.g., the number of alternations of blocks of existential and
universal quantiﬁers appearing in its prenex normal form. This theme is best
illustrated by quantiﬁer elimination, in which deﬁnable sets over a structure
are shown to have quantiﬁer-free deﬁnitions. The second involves assigning a
dimension (with a corresponding notion of independence) to the deﬁnable sets
that is combinatorially, algebraically, or geometrically motivated. Stability the-
ory, with its combinatorial/algebraic account of dimension and independence,
is perhaps the most widely known and longest-studied exemplar, its develop-
ment traceable to Morley’s seminal work in the 1960’s and to Shelah’s deep
and extensive work in the 1970’s. More recently, o-minimality, and in partic-
ular its focus on o-minimal expansions of the ordered ﬁeld of real numbers,
provides another important class of examples. The imposition of “tameness”
assumptions in classical model theory such as stability and o-minimality –
often veriﬁed in examples by quantiﬁer elimination – make the analysis of the
structures satisfying these hypotheses not only tractable but also amenable to
applications in mathematics outside of logic.
Tarski’s quantiﬁer-elimination for real-closed ﬁelds which thereby (effec-
tively) equates the ﬁrst-order deﬁnable sets over the ﬁeld of real numbers
with the semialgebraic sets, has long proved a fertile ground for framing and
addressing computational issues. Kuijpers and Van den Bussche, in their chap-
ter, Logical aspects of spatial databases, model spatial data via semialgebraic
subsets of n-dimensional Euclidean space, and investigate the expressive power
of several logic-based languages to query these databases. They ﬁrst charac-
terize the topological properties of planar spatial databases that are ﬁrst-order
expressible over the usual language for the ordered ﬁeld of real numbers –
of interest from the point of view of geographical information systems, for
example – in terms of the query language “cone logic”. The second half of
their chapter deals with query languages that extend ﬁrst-order logic over the
real ﬁeld by some form of recursion, including spatial Datalog, and ﬁrst-order
logic extended with a while loop or with a transitive closure operator.
Koponen, in her chapter, Some connections between ﬁnite and inﬁnite model
theory, discusses how stability theoretic considerations, as well as other proper-
ties and techniques from classical model theory such as smooth approximation,
can be imported successfully into the study of ﬁnite structures by restricting to
bounded variable logic, that is, ﬁrst-order logic under the restriction that there is

x
Preface
a ﬁxed value k such that only formulas in which no more than k variables occur.
In particular, Koponen investigates when a theory in bounded variable logic
with an inﬁnite model has arbitrarily large ﬁnite models and isolates conditions
for effectively determining least upper bounds for the size of the smallest such
ﬁnite model.
The chapter of Macpherson and Steinhorn, Deﬁnability in classes of ﬁnite
structures, contains two distinct threads that draw their motivation from clas-
sical model theory. The ﬁrst, inspired by the model theory of ﬁnite and
pseudoﬁnite ﬁelds, concerns asymptotic classes of ﬁnite structures. These are
non-elementary classes of ﬁnite structures whose ﬁrst-order deﬁnable sets
asymptotically satisfy cardinality constraints that permit the assignation of
a dimension and measure, and have an intimate connection in classical model
theory to so-called simple theories. The second theme concerns so-called robust
classes of ﬁnite structures, whose origin lies in attempting to “ﬁnitize” classical
model-theoretic tameness conditions, such as o-minimality, that are provably
excluded in asymptotic classes. Robust classes consist of directed systems of
ﬁnite structures in which the truth value of a formula requires “looking ahead”
into a larger structure in the system.
For the model theory of ﬁnite structures that has been developed with great
success within theoretical computer science, “tameness” assumptions do not
apply only to isolate classes of structures that are well-behaved with respect to
a preferred logic, such as ﬁrst-order logic. Research has prospered by striking
a balance between appropriate logics or fragments thereof and classes of ﬁnite
structures: that is, tame logics matched with tame classes. This theme appears
already in Koponen’s chapter, with its emphasis on bounded variable logic
combined with classical tameness assumptions, and strongly emerges in the
chapters of Otto and Kreutzer. As these chapters furthermore show, this point
of view can furnish signiﬁcant computational insights.
Kreutzer’s chapter, Algorithmic meta-theorems, discusses how constraining
both classes of (ﬁnite) structures and logics yields a wealth of algorithmic
results. An algorithmic meta-theorem has the form that every computational
problem that can be expressed in some logic can be solved efﬁciently on every
class of structures that satisfy certain constraints. This is usually accomplished
by showing that the model-checking problem for formulas in some logic –
typically ﬁrst-order or monadic second-order – is what is called ﬁxed-parameter
tractable for a class of structures, typically based on graphs with well-behaved
tree decompositions. This point of view goes back to well-known work of
Courcelle and his collaborators.
Otto takes as the focus of his chapter the application of game-oriented meth-
ods and explicit model constructions in the analysis of fragments of ﬁrst-order

Preface
xi
logic restricted to well-behaved (non-elementary) classes of structures, particu-
larly ﬁnite structures. Whereas the model-theoretic compactness theorem plays
an essential role in the classical setting, paradigmatically in proving expres-
sive completeness results such as the Łos-Tarski theorem characterizing those
formulas preserved under extensions as the existential formulas, its failure for
restricted classes of structures, e.g., classes of ﬁnite structures, motivates the
introduction of the methods and techniques that Otto places at the center of
the chapter. The chapter also surveys how by restricting to classes of ﬁnite
structures deﬁned by tree-width and locality considerations, expressive com-
pleteness results that fail for the class of ﬁnite structures can be regained.
The workshop organizer was Professor Iain Stewart (Durham). The mem-
bers of the Scientiﬁc Committee for the workshop included : Michael Benedikt
(Oxford), Javier Esparza (Munich), Bradd Hart (McMaster), Christian Michaux
(Mons-Hainaut), Charles Steinhorn (Vassar), and Katrin Tent (M¨unster). Finan-
cial support from the Newton Institute and EPSRC is gratefully acknowledged.
We also wish to express our appreciation to the staff at Cambridge Univer-
sity Press, in particular Clare Dennison, our maths/computer science editor,
and Sabine Koch, our production editor, for their remarkable thoughtfulness,
patience, and efﬁciency throughout the process of bringing this volume into
print.
Javier Esparza
Christian Michaux
Charles Steinhorn


1
Automata-based presentations of
inﬁnite structures
vince b ´ar ´any1, erich gr ¨adel2 and sasha rubin3
1.1 Finite presentations of inﬁnite structures
The model theory of ﬁnite structures is intimately connected to various ﬁelds
in computer science, including complexity theory, databases, and veriﬁcation.
In particular, there is a close relationship between complexity classes and
the expressive power of logical languages, as witnessed by the fundamental
theorems of descriptive complexity theory, such as Fagin’s Theorem and the
Immerman-Vardi Theorem (see [78, Chapter 3] for a survey).
However, for many applications, the strict limitation to ﬁnite structures
has turned out to be too restrictive, and there have been considerable efforts to
extend the relevant logical and algorithmic methodologies from ﬁnite structures
to suitable classes of inﬁnite ones. In particular this is the case for databases
and veriﬁcation where inﬁnite structures are of crucial importance [130]. Algo-
rithmic model theory aims to extend in a systematic fashion the approach and
methods of ﬁnite model theory, and its interactions with computer science,
from ﬁnite structures to ﬁnitely-presentable inﬁnite ones.
There are many possibilities to present inﬁnite structures in a ﬁnite manner. A
classical approach in model theory concerns the class of computable structures;
these are countable structures, on the domain of natural numbers, say, with a
ﬁnite collection of computable functions and relations. Such structures can be
ﬁnitely presented by a collection of algorithms, and they have been intensively
1 Oxford University Computing Laboratory
Wolfson Building, Parks Road, Oxford OX1 3QD, United Kingdom
vbarany@logic.rwth-aachen.de
2 Mathematical Foundations of Computer Science
RWTH Aachen, D-52056 Aachen, Germany
graedel@logic.rwth-aachen.de
3 Department of Mathematics and Applied Mathematics
University of Cape Town, Private Bag, Rondebosch 7701, South Africa
srubin@math.cornell.edu
1

2
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
studied in model theory since the 1960s. However, from the point of view of
algorithmic model theory the class of computable structures is problematic.
Indeed, one of the central issues in algorithmic model theory is the effective
evaluation of logical formulae, from a suitable logic such as ﬁrst-order logic
(FO), monadic second-order logic (MSO), or a ﬁxed point logic like LFP
or the modal µ-calculus. But on computable structures, only the quantiﬁer-
free formulae generally admit effective evaluation, and already the existential
fragment of ﬁrst-order logic is undecidable, for instance on the computable
structure (N, +, · ).
This leads us to the central requirement that for a suitable logic L (depending
on the intended application) the model-checking problem for the class C of
ﬁnitely presented structures should be algorithmically solvable. At the very
least, this means that the L-theory of individual structures in C should be
decidable. But for most applications somewhat more is required:
Effective semantics: There should be an algorithm that, given a ﬁnite pre-
sentation of a structure A ∈C and a formula ψ(¯x) ∈L, expands the given
presentation to include the relation ψA deﬁned by ψ on A.
This also implies that the class C should be closed under some basic oper-
ations (such as logical interpretations). Thus we should be careful to restrict
the model of computation. Typically, this means using some model of ﬁnite
automata or a very restricted form of rewriting.
In general, the ﬁnite means for presenting inﬁnite structures may involve
different approaches: logical interpretations; ﬁnite axiomatisations; rewriting
of terms, trees, or graphs; equational speciﬁcations; the use of synchronous or
asynchronous automata, etc. The various possibilities can be classiﬁed along
the following lines:
Internal: a set of ﬁnite or inﬁnite words or trees/terms is used to represent
the domain of (an isomorphic copy of) the structure. Finite automata/
rewriting-rules compute the domain and atomic relations (eg. preﬁx-
recognisable graphs, automatic structures).
Algebraic: a structure is represented as the least solution of a ﬁnite set
of recursive equations in an appropriately chosen algebra of ﬁnite and
countable structures (eg. VR-equational structures).
Logical: structures are described by interpreting them, using a ﬁnite col-
lection of formulae, in a ﬁxed structure (eg. tree-interpretable structures).
A different approach consists in (recursively) axiomatising the isomor-
phism class of the structure to be represented.
Transformational: structures are deﬁned by sequences of prescribed trans-
formations, such as graph-unraveling, or Muchnik’s iterations applied

Automata-based presentations of inﬁnite structures
3
to certain ﬁxed initial structures (which are already known to have a
decidable theory). Transformations can also be transductions, logical
interpretations, etc. [23]
The last two approaches overlap somewhat. Also, the algebraic approach can
be viewed generatively: convert the equational system into an appropriate
deterministic grammar generating the solution of the original equations [44].
The grammar is thus the ﬁnite presentation of the graph. One may also say
that internal presentations and generating grammars provide descriptions of
the local structure from which the whole arises, as opposed to descriptions
based on global symmetries typical of algebraic speciﬁcations.
Prerequisites and notation
We assume rudimentary knowledge of ﬁnite automata on ﬁnite and inﬁnite
words and trees, their languages and their correspondence to monadic second-
order logic (MSO) [133, 79]. Undeﬁned notions from logic and algebra (con-
gruence on structures, deﬁnability, isomorphism) can be found in any standard
textbook. We mainly consider the following logics L: ﬁrst-order (FO), monadic
second order (MSO), and weak monadic second-order (wMSO) which has
the same syntax as MSO, but the intended interpretation of the set variables
is that they range over ﬁnite subsets of the domain of the structure under
consideration.
We mention the following to ﬁx notation: inﬁnite words are called ω-words
and inﬁnite trees are called ω-trees (to distinguish them from ﬁnite ones);
relations computable by automata will be called regular; the domain of a
structure B is usually written B and its relations are written RB. An MSO-
formula φ(X1, . . . , Xj, x1, . . . , xk) interpreted in B deﬁnes the set φB :=
{(B1, . . . , Bj, b1, . . . , bk) | Bi ⊂B, bi ∈B, B |= φ(B1, . . . , Bj, b1, . . . , bk)}.
A wMSO-formula is similar except that the Bi range over ﬁnite subsets of B.
The full binary tree T2 is deﬁned as the structure

{0, 1}∗, suc0, suc1

where the successor relation suci consists of all pairs (x, xi). Tree automata
operate on -labelled trees T : {0, 1}∗→. Such a tree is identiﬁed with the
structure

{0, 1}∗, suc0, suc1, {T −1(σ)}σ∈

.
Rabin proved the decidability of the MSO-theory of T2 and the following
fundamental correspondence between MSO and tree automata (see [132] for
an overview):

4
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
For every monadic second-order formula ϕ(X) in the signature of T2 there is a
tree automaton A (and vice versa) such that
L(A) = {TX | T2 |= ϕ(X)}
(1.1)
where TX denotes the tree with labels for each Xi.
Similar deﬁnitions and results hold for r-ary trees, in which case the domain
is [r]∗where [r] := {0, . . . , r −1}, and ﬁnite trees.
In section 1.2.2 and elsewhere we do not distinguish between a term and
its natural representation as a tree. Thus we may speak of inﬁnite terms. We
consider countable, vertex- and edge-labelled graphs possibly having distin-
guished vertices (called sources), and no parallel edges of the same label. A
graph is deterministic if each of its vertices is the source of at most one edge
of each edge label.
Interpretations
Interpretations allow one to deﬁne an isomorphic copy of one structure in
another. Fix a logic L. A d-dimensional L-interpretation I of structure
B = (B; (RB
i )i) in structure A, denoted B ≤I
L A, consists of the following
L-formulas in the signature of A,
– a domain formula (x),
– a relation formula Ri(x1, . . . , xri) for each relation symbol Ri, and
– an equality formula ϵ(x1, x2),
where each A
Ri is a relation on A, each of the tuples xi, x contain the same
number of variables, d, and ϵA is a congruence on the structure (A, (A
Ri)i),
so that B is isomorphic to
(A, (A
Ri)i) / ϵA .
If L is FO then the free x are FO and we speak of a FO interpretation. If
L is MSO (wMSO) but the free variables are FO, then we speak of a (weak)
monadic second-order interpretation.
We associate with I a transformation of formulas ψ →ψI. For illustration
we deﬁne it in the ﬁrst-order case: the variable xi is replaced by the d-tuple
yi, (ψ ∨φ)I by ψI ∨φI, (¬ψ)I by ¬ψI, (∃xiψ)I by ∃yi(yi) ∧ψI, and
(xi = xj)I is replaced by ϵ(yi, yj). Thus one can translate L formulas from
the signature of B into the signature of A.
Proposition 1.1.1
If B ≤I
L A, say the isomorphism is f , then for every
formula ψ(x1, . . . , xk) in the signature of B and all k-tuples b of elements of

Automata-based presentations of inﬁnite structures
5
B it holds that
B |= ψ(b1, . . . , bk) ⇐⇒A |= ψI(f (b1), . . . , f (bk))
In particular, if A has decidable L-theory, then so does B.
Set interpretations
When L is MSO (wMSO) and the free variables are MSO (wMSO) the interpre-
tation is called a (ﬁnite) set interpretation. In this last case, we use the notation
B ≤I
set A or B ≤I
fset A. We will only consider (ﬁnite) set interpretations of
dimension 1.
If ﬁniteness of sets is MSO-deﬁnable in some structure A (as for linear
orders or for ﬁnitely branching trees) then every structure B having a ﬁnite-set
interpretation in A can also be set interpreted in A.
Example 1.1.2
An interpretation (N, +) ≤I
fset (N, 0, suc) based on the binary
representation is given by I = (ϕ(X), ϕ+(X, Y, Z), ϕ=(X, Y)) with ϕ(X)
always true, ϕ= the identity, and ϕ+(X, Y, Z) is
∃C ∀n [(Zn ↔Xn ⊕Yn ⊕Cn) ∧(C(sucn) ↔µ(Xn, Yn, Cn)) ∧¬C0]
where C stands for carry, ⊕is exclusive or, and µ(x0, x1, x2) is the majority
function, in this case deﬁnable as 
i̸=j xi ∧xj.
To every (ﬁnite) subset interpretation I we associate, as usual, a transforma-
tion of formulas ψ →ψI, in this case mapping ﬁrst-order formulas to (weak)
monadic second-order formulas.
Proposition 1.1.3
Let B ≤I
(f)set A be a (ﬁnite) subset interpretation with iso-
morphism f . Then to every ﬁrst-order formula ψ(x1, . . . , xk) in the signature
of B one can effectively associate a (weak) monadic second-order formula
ψI(X1, . . . , Xk) in the signature of A such that for all k-tuples b of elements
of B it holds that
B |= ψ(b1, . . . , bk) ⇐⇒A |= ψI(f (b1), . . . , f (bk)).
Consequently, if the (weak) monadic-second order theory of A is decidable
then so is the ﬁrst-order theory of B.
For more on subset interpretations we refer to [23].

6
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
PDS
HR
PR = VR
= T−AutStr
VRS
S−AutStr
GSO
FO[R]
MSO
GTRS
RGTRS = VRA
Rational
FO
ML
Figure 1.1 Relationship of graph classes and logical decidability boundaries.
1.2 A hierarchy of ﬁnitely presentable structures
This section provides an overview of some of the prominent classes of graphs
and their various ﬁnite presentations.
These developments are the product of over two decades of research in
diverse ﬁelds. We begin our exposition with the seminal work of Muller and
Schupp on context-free graphs, we mention preﬁx-recognisable structures, sur-
vey hyperedge-replacement and vertex-replacement grammars and their cor-
responding algebraic frameworks leading up to equational graphs in algebras
with asynchronous or synchronous product operation. These latter structures
are better known in the literature by their automatic presentations, and constitute
the topic of the rest of this survey.
As a unifying approach we discuss how graphs belonging to individual
classes can be characterised as least ﬁxed-point solutions of ﬁnite systems of
equations in a corresponding algebra of graphs. We illustrate on examples how
to go from graph grammars through equational presentations and interpretations
to internal presentations and vice versa.
We brieﬂy summarise key results on Caucal’s pushdown hierarchy and
more recent developments on simply-typed recursion schemes and collapsible
pushdown automata.
Figure 1.1 provides a summary of some of the graph classes discussed in
this section together with the boundaries of decidability for relevant logics.

Automata-based presentations of inﬁnite structures
7
Rational graphs and automatic graphs featured on this diagram are described
in detail in Section 1.3.
1.2.1 From context-free graphs to preﬁx-recognisable structures
Context-free graphs were introduced in the seminal papers [110, 111, 112]
of Muller and Schupp. There are several equivalent deﬁnitions. The objects
of study are countable directed edge-labelled, ﬁnitely branching graphs. An
end is a maximal connected4 component of the induced subgraph obtained
by removing, for some n, the n-neighbourhood of a ﬁxed vertex v0. A vertex
of an end is on the boundary if it is connected to a vertex in the removed
neighbourhood. Two ends are end-isomorphic if there is a graph isomor-
phism (preserving labels as well) between them that is also a bijection of
their boundaries. A graph is context-free if it is connected and has only
ﬁnitely many ends up to end-isomorphism. This notion is independent of the v0
chosen.
A graph is context-free if and only if it is isomorphic to the connected
component of the conﬁguration graph of a pushdown automaton (without ϵ-
transitions) induced by the set of conﬁgurations that are reachable from the
initial conﬁguration [112].
A context-free group is a ﬁnitely generated group G such that, for some
set S of semigroup generators of G, the set of words w ∈S∗representing the
identity element of G forms a context-free language. This is independent of the
choice of S. Moreover, a group is context-free if and only if its Cayley graph
for some (and hence all) sets S of semigroup generators is a context-free graph.
Finally, a ﬁnitely generated group is context-free if and only if it is virtually
free, that is, if it has a free subgroup of ﬁnite index [111].5
Muller and Schupp have further shown that context-free graphs have a decid-
able MSO-theory. Indeed, every context-free graph can be MSO-interpreted in
the full binary tree.
Example 1.2.1
Consider the group G given by the ﬁnite presentation
⟨a, b, c | ab, cc, acac, bcbc ⟩. The Cayley graph 
(G, S) of G with respect
4 connectedness is taken with respect to the underlying undirected graph.
5 Originally [111] proved this under the assumption of accessibility, a notion related to group
decompositions introduced by Wall who conjectured that all ﬁnitely generated groups would
have this property. Muller and Schupp conjectured every context-free group to be accessible,
but it was not until Dunwoody [64] proved that all ﬁnitely presentable groups are accessible
that this auxiliary condition could be dropped from the characterisation of [111]. Unfortunately,
many sources forget to note this fact. Later Dunwoody also gave a counterexample refuting
Wall’s conjecture.

8
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
to the set of semigroup generators S = {a, b, c} is depicted below.
a
 •
b

c

a
 •
b

c

a
 1
b

c

a
 •
b

c

a
 •
b

c

a

...
b

...
b
 •
b


a

•
b


a

•
b


a

•
b


a

•
b


a

a

Notice that 
(G, S) has two ends, for any n-neighbourhood of the identity
with n > 1. These are
a
 •
b

c

a
 •
b

c

and
•
c

a
 •
b

c

a

...
b

...
b
 •
b


a

•
b


a

•
a

•
b
 •

b

a

•

b

a

a

A word w ∈{a, b, c}∗represents the identity of G if, and only if, w has an
even number of c’s and the number of a’s equals the number of b’s. We present
a pushdown automaton A which recognises this set of words and, moreover,
has a conﬁguration graph that is isomorphic to 
(G, S). The states of A are
Q = {1, c} with q0 = 1 as the initial state, the stack alphabet is 
 = {a, b}, the
input alphabet is {a, b, c} and A has the following transitions:
internal:
1 θ
c→
c θ
internal:
c θ
c→
1 θ
push:
q σθ
σ→
q σσθ
for q = 1, c and σ = a, b
push:
q ⊥
σ→
q σ⊥
for q = 1, c and σ = a, b
pop:
q σθ
σ→
q θ
for q = 1, c and {σ, ¯σ} = {a, b}
Here θ is the stack content written with its top element on the left and always
ending in the special symbol ⊥marking the bottom of the stack.
In every deterministic edge-labelled connected graph and for any ordering
of the edge labels one obtains a spanning tree by taking the shortest path
with the lexicographically least labeling leading to each node from a ﬁxed
source. Take such a spanning tree T for the example graph 
(G, S) with root
1G. Observe that T is regular, having only ﬁnitely many subtrees (ends) up
to isomorphism. The ordering a < b < c induces the spanning tree depicted
below. The Cayley graph 
(G, S) is MSO-interpretable in this regular spanning
tree by deﬁning the missing edges using the relators from the presentation of the

Automata-based presentations of inﬁnite structures
9
group.
•
b

c

•
b

c

1
b

c

a
 •
c

a
 •
c

a

...
...
•
•
•
•
•
In particular 
(G, S) is MSO-interpretable in the full binary tree, and hence
has decidable MSO.
A mild generalisation of pushdown transitions, preﬁx-rewriting rules, take
the form uz →vz where u and v are ﬁxed words and z is a variable ranging
over words. As in the previous example, pushdown transitions are naturally
perceived as preﬁx-rewriting rules affecting the state and the top stack symbols.
Conversely, Caucal [40] has shown that connected components of conﬁguration
graphs of preﬁx-rewriting systems given by ﬁnitely many preﬁx-rewriting rules
are effectively isomorphic to connected components of pushdown graphs. Later,
Caucal introduced preﬁx-recognisable graphs as a generalisation of context-
free graphs and showed that these are MSO-interpretable in the full binary tree
and hence have a decidable MSO-theory [42].
Deﬁnition 1.2.2 (Preﬁx-recognisable relations)
Let  be a ﬁnite alphabet.
The set PR() of preﬁx-recognisable relations over ∗is the smallest set of
relations such that
– every regular language L ⊆∗is a preﬁx-recognisable unary relation;
– if R, S ∈PR (arities r and s) and L is regular then L · (R × S) =
{(uv1, . . . , uvr, uw1, . . . , uws) | u ∈L, v ∈R, w ∈S} ∈PR;
– if R ∈PR of arity m > 1 and {i1, . . . , im} = {1, . . . , m},
then R(i) = {(ui1, . . . , uim) | (u1, . . . , um) ∈R} ∈PR;
– if R, S ∈PR are of the same arity, then R ∪S ∈PR.
Example 1.2.3
Consider the lexicographic ordering <lex on an ordered alpha-
bet . It is preﬁx-recognisable being the union of
∗· ({ε} × +)
and
∗· (a∗× b∗)
for all a < b ∈.
Following [22] we say that a structure A = (A, {Ri}i) is preﬁx-recogniz-
able if A is a regular set of words over some ﬁnite alphabet  and each of
the relations Ri is in PR(). Preﬁx-recognisable structures can be character-
ized in terms of interpretations. On the basis of tree automata, it is relatively
straightforward to show that the preﬁx-recognisable structures coincide with
the structures that are MSO-interpretable in the binary tree T2 [97, 42, 22]. This

10
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
result has been strengthened by Colcombet [51] to ﬁrst-order interpretability in
the expanded structure (T2, ≺) (note that the preﬁx relation ≺is MSO-deﬁnable
but not FO deﬁnable in T2). Colcombet proved that MSO-interpretations and
FO-interpretations in (T2, ≺) have the same power, which gives a new char-
acterisation of preﬁx-recognisable structures. We summarize these results as
follows.
Theorem 1.2.4
For every structure A, the following are equivalent.
(1) A is isomorphic to a preﬁx-recognisable structure;
(2) A is MSO-interpretable in the full binary tree T2;
(3) A is FO-interpretable in (T2, ≺).
In particular, every preﬁx-recognisable structure has a decidable MSO-theory.
Below we discuss further characterisations of preﬁx-recognisable structures
in terms of vertex-replacement grammars, or as least solutions of VR-equational
systems.
1.2.2 Graph grammars and graph algebras
In this section we consider vertex- and edge-labelled graphs. In formal lan-
guage theory grammars generate sets of ﬁnite words. Similarly, context-free
graph grammars produce sets of ﬁnite graphs – start from an initial nonterminal
and rewrite nonterminal vertices and edges according to the derivation rules.
Just as for languages, the set of valid derivation trees, or parse trees, forms a
regular set of trees labelled by derivation rules of the graph grammar. Con-
versely, consider a collection  of graph operations – such as disjoint union,
recolourings, etc. – as primitives. Every closed -term t evaluates to a ﬁnite
graph [[t]], and similarly every -term t(x) evaluates to a ﬁnite graph [[t(x)]]
with non-terminal (hyper)-edges and/or vertices. Formally, evaluation is the
unique homomorphism from the initial algebra of -terms to the -algebra of
ﬁnite graphs with non-terminals. Each regular tree language L of closed terms
thus represents a family of ﬁnite graphs {[[t]] | t ∈L}. For a concise treatment
of graph grammars and ﬁnite graphs we refer to the surveys [69, 59] and the
book [53].
Our focus here is on individual countable graphs generated by deterministic
grammars via ‘complete rewriting’. A suitable framework for formalising com-
plete rewriting, in the context of term rewriting, is convergence in complete
partial orders (cpo’s). Since no classical order- or metric-theoretic notion of
limit seems to exist for graphs, we use the more general categorical notion of

Automata-based presentations of inﬁnite structures
11
colimit [11]. We outline this framework in which an inﬁnite term (over the graph
operations ) yields a countable graph; details may be found in [55, 11, 53].
In the category G of graphs and their homomorphisms every diagram of the
form
G0
f0
−→G1
f1
−→G2
f2
−→· · ·
fn−1
−→Gn
fn
−→Gn+1
fn+1
−→· · ·
has a colimit G, i.e. a kind of least common extension G of the Gns with homo-
morphisms gn : Gn →G such that gn = gn+1fn for all n.6 We assume that the
graph operations in  determine endofunctors of G that are cocontinuous i.e.
colimit preserving.
On the other side, take the cpo of ﬁnite and inﬁnite terms over the signature
 ∪{⊥}, with the empty term ⊥and the extension ordering s ⊑t. We may
turn it into a category T with each relation s ⊑t inducing a unique arrow
s →t. Moreover, in this category, colimits (of diagrams as above) exist and
an inﬁnite term t is the colimit of approximations t0 →t1 →· · · (think that
ti is the restriction of t to the ﬁrst i levels). The evaluation mapping [[·]] has
a unique cocontinuous extension, also denoted [[·]], mapping inﬁnite terms to
colimits of graphs.
This completes the basic description. Now consider a grammar G whose
derivation rules ⟨Xi →ti(X)⟩can be expressed by -terms. These terms deter-
mine cocontinuous endofunctors in the category of terms T. By the Knaster-
Tarski theorem the functors have a least ﬁxed-point G, which by Kleene’s
Theorem is attained as the colimit of the chain ⟨γ n(∅)⟩n with the natural homo-
morphisms. The graph generated by the grammar from the corresponding
non-terminal Xi is deﬁned to be the component Gi of the colimit G.
Equivalently, given the system of equations EG = ⟨Xi = ti(X)⟩one can con-
struct a syntactic (uninterpreted) solution of EG by ‘unraveling’ these equations
from the initial non-terminal X0 of the grammar. This results in a possibly
inﬁnite regular term tG, which is precisely the least ﬁxed-point solution for X0
in T. By cocontinuity of the evaluation mapping [[tG]] is isomorphic to the
least ﬁxed-point solution of EG in G, that is to the graph generated by G.
In what follows we focus on different sets of graph operations  (namely,
HR, VR and some extensions). It has been observed that for suitable choices
of operations, most notably avoiding products, the evaluation mapping can
be realised as a monadic second-order interpretation or transduction [11, 60].
Consequently every interpretation [[t]] ≤I
MSO t naturally translates to an internal
6 There are examples of ascending chains G0
f0
→G1
f1
→· · · and G0
g0
→G1
g1
→· · · with identical
graphs but different embeddings yielding different colimits, whence there is no apparent
canonical way of deﬁning a limit knowing only that each Gn is embeddable into Gn+1.

12
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
presentation of [[t]] using tree automata. Moreover, for a regular term t the
MSO-theory of [[t]] is decidable by Rabin’s Theorem.
Finally we mention that all this smoothly extends to solutions of inﬁnite
sets of equations [33]. Although unraveling might not result in a regular solu-
tion term, as long as it has a decidable MSO-theory so does the solution
graph.
Equational graphs and hyperedge-replacement grammars
Hyperedge-replacement (HR) grammars are a very natural generalisation of
context-free grammars from formal language theory. Every HR-grammar
deﬁnes a ‘language’ of ﬁnite graphs just as context-free grammars deﬁne lan-
guages of ﬁnite words. The class of graph languages deﬁned by HR-grammars
possesses many structural properties akin to those well-known for context-free
languages. The interested reader is referred to the monograph [80].
An HR-grammar is given as a ﬁnite collection of rules that allow the replace-
ment of any hyperedge of a hypergraph bearing a non-terminal label by the
right hand side of a matching rule, which is a given ﬁnite hypergraph with
a number of distinguished vertices equal to the arity of the hyperedge to be
replaced. A copy of the right-hand side of a matching rule is then glued to the
original hypergraph precisely at these distinguished vertices and correspond-
ing end vertices of the hyperedge being replaced. Derivation begins with a
distinguished non-terminal.
As outlined at the start of section 1.2.2, each deterministic HR-grammar
determines a unique countable graph constructed from the initial graph by
complete rewriting in the course of which every non-terminal hyperedge is
eventually replaced by the right-hand side of the unique matching rule. A
countable graph is HR-equational, or simply equational, if it is generated
by a deterministic HR grammar [55]. The class of equational graphs will be
denoted by HR. Equational graphs constitute a proper extension of the class of
context-free graphs [41].
Proposition 1.2.5
A connected graph is context-free if, and only if, it is
equational and of ﬁnite degree.
Example 1.2.6
To generate the context-free graph of Example 1.2.1 with a
deterministic HR grammar we take as our initial graph the 1-neighbourhood of
the root node (labelled with 1 above) and attach to it non-terminal hyperedges
labelled with X and with Y, respectively, whose vertices enumerate the bound-
aries of either ends. Similarly, the 1-neighbourhood of the boundary of each
end, that is the vertices of the corresponding non-terminal hyperedge, consti-
tutes the right-hand side of the matching rule. Again, non-terminal hyperedges

Automata-based presentations of inﬁnite structures
13
are attached to mark the new boundary. The initial graph and the rule for the
non-terminal X obtained this way are pictured below.
•
a

Y




1
b

c

a
 •
b

X




•

1•
X
=⇒



	
2•
1•
c

a
 •
b
	
X




2•
b
 •

a
	
Notice how the linearity of the generated graph is reﬂected in the linearity
of the replacement rules each having only a single non-terminal hyperedge on
the right. In the next example a non-linear rule is used to generate a tree, which
is not context-free.
Example 1.2.7
The complete bipartite graph K1,ω and the full ω-branching
tree Tω (in the signature of graphs) are not context-free, but can be generated
by the following rules from the initial graph •
X
•.
•1
K1,ω
=⇒
•1
•
•0
X



•0
X

 

•1
Tω
=⇒
•1
X

   •
•0
X



•0

X

   •
The HR-algebra of ﬁnite and countable graphs corresponding to hyperedge-
replacement grammars is a many-sorted algebra deﬁned as follows. For each
n there is a separate sort Gn of graphs with n sources. These are distinguished
vertices, though not necessarily distinct, named v1, . . . , vn. There are constants
of each sort Gn: these are hypergraphs having at most one hyperedge, exactly n
vertices, each vertex a distinct source. The HR-algebra is built on the following
operations: disjoint union ⊕, renaming of sources renamec→c′, and fusion of
sources fuse≈according to an equivalence ≈on source names. By convention
⊕is understood to automatically shift the source names of its second argument
by the maximum of the source names used in the ﬁrst to avoid naming conﬂict.
Also fuse assigns the least source name of a class to each fused node while
dropping the others.
It is intuitively clear how a hyperedge-replacement step can be expressed
using disjoint union with the right-hand side of the rule followed by a fusion
and renaming of sources. Formally, one transforms an HR-grammar G into a
system of ﬁnitely many equations Xi = ti(X) where variables play the role
of non-terminals of the grammar and the terms ti are chosen such that, when
variables are interpreted as individual hyperedges, [[ti(X)]] is the right hand
side of the matching rule for a hyperedge labelled Xi.

14
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Example 1.2.8
The equation corresponding to the single rule of the HR
grammar of Example 1.2.7 generating Tω is
X = rename0→0,1→1( fuse{0,2},{1,4}(
0• →
1• ⊕X ⊕X ) ) .
Note that the source names of the ﬁrst and second occurrences of X are shifted
by 2 and by 4, respectively, while forming their disjoint union. Thus, after
fusion we obtain precisely the right hand side of the HR-rule generating Tω,
however, with additional source names. The renaming operation in this term
has the effect of forgetting the source names 2 and above. So the least solution
of this equation is indeed Tω with its root labelled 0 and one of its children
with 1.
The generating power of HR-grammars is limited by the fact that edges can
only be ‘created’ via fusion of sources (after having taken the disjoint union of
two graphs). Because there are only a ﬁxed number of source names available
in a ﬁnite HR-equational system there is a bound on the size of complete
bipartite subgraphs Kn,n that can be created [12], cf. Theorem 1.2.12. The
inﬁnite bipartite graph Kω,ω is thus an example of a preﬁx-recognisable graph
which is not HR-equational.
It is a key observation that in case of HR-terms the evaluation mapping
t →[[t]] is expressible as an MSO-interpretation. In fact, since edges cannot
be created by any of the HR operations, the vertex-edge-adjacency graph of
[[t]] is MSO-interpretable in the tree representation of t, whether t is ﬁnite or
inﬁnite.
Theorem 1.2.9
For a countable graph G the following are equivalent.
(1) G is generated by a deterministic HR grammar;
(2) G is HR-equational, i.e. the evaluation of a regular HR-term, i.e. the least
solution of a ﬁnite system of HR-equations;
(3) The two-sorted incidence graph ˆG of G is monadic second-order inter-
pretable in the full binary tree, i.e. ˆG ≤MSO T2.
For a detailed presentation of these and other algebraic frameworks and their
connections to the generative approach based on graph grammars we advise
consulting [55, 12, 21]. In [54] Courcelle considered an extension of monadic
second-order logic, denoted CMSO2, in which one can quantify over sets of
edges as well as over sets of vertices and, additionally, make use of modulo
counting quantiﬁers. Notice that the last item of the previous theorem implies
that the CMSO2-theory of equational graphs is interpretable in S2S and is thus

Automata-based presentations of inﬁnite structures
15
decidable. Further, Courcelle proved that CMSO2 is able to axiomatise each
and every equational graph up to isomorphism.
Theorem 1.2.10
Each HR-equational graph is axiomatisable in CMSO2.
Consequently the isomorphism problem of equational graphs is decidable.
S´enizergues considered HR-equational graphs of ﬁnite out-degree and
proved that they are, up to isomorphism, identical with the ε-closures of con-
ﬁguration graphs of normalised7 pushdown automata restricted to the set of
reachable conﬁgurations. Further, he proved that bisimulation equivalence of
HR-equational graphs of ﬁnite out-degree is decidable [128]. This last result
is an improvement on the decidability of bisimulation equivalence for deter-
ministic context-free processes, which is a consequence of the celebrated result
of S´enizergues establishing decidability of the DPDA language equivalence
problem.
Vertex-replacement grammars
Vertex replacement systems are a ﬁnite collection of graph rewriting rules that
allow one to substitute given ﬁnite graphs in place of single vertices while
keeping all the connections. This form of graph rewriting emerged as the most
robust and manageable from among a host of different notions within a very
general framework [55, 69, 59, 58]. The corresponding VR-algebra of graphs is
built on the following operations: constant graphs of a single c-coloured vertex
a•, disjoint union ⊕, recolouring of vertices recolc→c′ and introduction of
a-coloured edges edgec
a→d from every c-coloured vertex to every d-coloured
vertex.
The evaluation of VR-terms, whether ﬁnite or inﬁnite, is realisable as a
monadic second-order interpretation. More precisely, as VR-equational graphs
are interpretations of regular terms obtained by unfolding a ﬁnite system of VR
equations, they can be MSO-interpreted in a regular tree, hence also in the full
binary tree T2, and thus are preﬁx-recognisable. These and other characterisa-
tions, together with our previous discussion of preﬁx-recognisable structures
are summarised in the next theorem.
Theorem 1.2.11
For a countable graph G the following are equivalent.
(1) G is isomorphic to a preﬁx-recognisable structure;
(2) G is generated by a deterministic VR grammar;
7 Here a PDA is said to be normalised, if in addition to being in a familiar normal-form its
ε-transitions may not push anything on the stack. Hence the ﬁniteness bound on the out-degree
of conﬁgurations. For precise deﬁnitions see [128].

16
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
(3) G is VR-equational, i.e. the evaluation of a regular VR-term, i.e. the least
solution of a ﬁnite system of equations of the form Xi = ti(X) with ﬁnite
VR-terms ti(X);
(4) G ≤MSO T2;
(5) G = h−1(T2)|C, i.e. the vertices of G are obtained by restricting the nodes
of T2 to a regular set C, and its edges are obtained by taking the inverse
of a rational substitution h to T2;
(6) G is isomorphic to the ϵ-closure of the conﬁguration graph of a pushdown
automaton.
Further, the HR-equational graphs can be characterised as the class of VR-
equational graphs of ﬁnite tree width [11].
Theorem 1.2.12
VR-equational graphs of ﬁnite tree width are HR-
equational.
Example 1.2.13
The complete bipartite graph Kω,ω is a prominent example
of a VR-equational graph that is not HR-equational. A VR grammar and the
corresponding system of VR equations generating Kω,ω are given below.
X•
⇒
A•←→
A•
A•
⇒
•
A•
X = edgea↔b( A ⊕recola→b( A ) )
A =
a• ⊕A
The expressive power of this formalism (for describing families of ﬁnite
graphs) is not increased by extending the VR operations by graph transforma-
tions that are deﬁnable using quantiﬁer-free formulas (of which recolc→c′ and
edgec
a→d are particular examples), nor by the fusion operations fusec identify-
ing all nodes bearing a certain colour c [60]. Care has to be taken when deﬁning
countable graphs as evaluations of inﬁnite terms, for it is unclear how to deal
with inﬁnite terms built with non-monotonic operations. Nonetheless, inﬁnite
terms built with operations deﬁnable by positive quantiﬁer-free formulas can
be evaluated unambiguously [11].
In this setting Theorem 1.2.11 can be generalised to inﬁnite systems of
equations (whose unfoldings are typically non-regular terms) using inﬁnite
deterministic automata [33], leading us to the following families of transition
graphs.
1.2.3 Higher-order data structures
Tree-constructible graphs and Caucal’s pushdown hierarchy
Courcelle introduced MSO-compatible transductions in the investigation of
structures with decidable monadic theories. Let C and C′ be classes of structures

Automata-based presentations of inﬁnite structures
17
on signatures σ and σ ′, respectively. Following [57] we say that a functional
transduction T : C →C′ is MSO-compatible if there is an algorithm mapping
each monadic formula ϕ of signature σ ′ to a monadic formula ϕT in the
signature σ such that
A |= ϕT
⇐⇒
T (A) |= ϕ .
MSO-interpretations are the most natural examples of MSO-compatible
transductions. Slightly more generally, the MSO-deﬁnable transductions of
Courcelle are MSO-compatible. Recall that these are given by a k-copying
operation (for some k) followed by an MSO-interpretation and in particular the
resulting structure may have k times the cardinality of the original one.
The more difﬁcult result that the unfolding operation, mapping graphs (G, v)
to trees T(G,v), is also MSO-compatible appeared in [61] (see also [57] for an
exposition and a treatment of the simpler case of deterministic graphs). We
note that this result also follows from Muchnik’s Theorem [126, 138, 17] and
that it generalises Rabin’s theorem.
A rich class of graphs, each with decidable monadic theory, can now be
constructed. Caucal [43] proposed the hierarchies of graphs and trees obtained
by alternately applying unfoldings and MSO-interpretations starting with ﬁnite
graphs:
Deﬁnition 1.2.14
Graphs0 = {ﬁnite edge- and vertex-labelled graphs}
Treesn+1 = {TG,v | (G, v) ∈Graphsn}
Graphsn+1 = {I(T) | T ∈Treesn+1, I is an MSO interpretation}
By the results above, we have
Theorem 1.2.15
For every n ∈N every graph G from Graphsn has a decid-
able MSO-theory.
Fratani [72, 73] provided an alternative proof of the above theorem, among
a host of other results on higher-order pushdown graphs, using a different kind
of MSO-compatible operation. Indeed, she established that if a homomorphism
of words maps the branches of a tree T to those of T ′ surjectively while also
preserving the node-labeling then deﬁnability and decidability results for MSO
over T ′ can be transferred to T .
The Caucal hierarchy is very robust. Various weakenings and strengthenings
of the deﬁnition yield exactly the same classes [37]. In fact, in place of MSO-
interpretations, Caucal originally used inverse rational mappings in the style of
item (5) of Theorem 1.2.11. Recently Colcombet [51] proved that every graph

18
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
of Graphsn+1 can in fact be obtained via a ﬁrst-order interpretation in some
tree belonging to Treesn+1. The next theorem provides internal presentations
of graphs of each level as a generalisation of Theorem 1.2.11 item (6) thereby
justifying the name pushdown hierarchy.
Theorem 1.2.16 ([37])
For every n a graph G is in Graphsn if, and only if,
it is isomorphic to the ϵ-closure of the conﬁguration graph of a higher-order
pushdown automaton at level n.
The strictness of the hierarchy was also shown in [37]. The level-zero graphs
are the ﬁnite graphs, trees at level one are the regular trees, and as we have seen
in Theorem 1.2.11 the level-one graphs are the preﬁx-recognisable ones. The
deterministic level-two trees are known as algebraic trees. From the second
level onwards we have no clear structural understanding of the kind of graphs
that inhabit the individual levels. We recommend [134] for an exposition.
Term-trees deﬁned by recursion schemes
Caucal also gave a kind of algebraic characterisation of term-trees at level n as
ﬁxed points of safe higher-order recursion schemes.
Theorem 1.2.17 ([43])
For every n, the class of term-trees Treesn coincides
with that of term-trees generated by safe higher-order recursion schemes of
level at most n.
The notion of higher-order schemes is a classical one [62, 56]. Safety is a
technical restriction (implicit in [62]) ensuring that no renaming of variables (α-
conversion) is needed during the generative substitutive reduction (β-reduction)
process constructing the solution-term [1, 117]. Safe schemes are intimately
related to the pushdown hierarchy. This connection is well explained in [1]
showing that while on the one hand order-n schemes can deﬁne the behaviour
and hence (the unfolding of) the conﬁguration graphs of level-n deterministic
pushdown automata, on the other hand, deterministic pushdown automata of
level n can evaluate safe order-n schemes. Safety is hereto essential.
In order to evaluate arbitrary schemes [81] introduced higher-order collapsi-
ble pushdown automata (CPDA), a kind of generalisation of panic automata
[92], and gave in essence the following characterisation in the spirit of
Theorem 1.2.16.
Theorem 1.2.18
The term-trees deﬁned by order-n recursion schemes are
up to isomorphism identical with the unfoldings of ϵ-closures of conﬁguration
graphs of level-n collapsible higher-order pushdown automata.

Automata-based presentations of inﬁnite structures
19
As shown in [117, 81], it is not necessary to assume safety for establishing
decidability of the MSO-theories of term-trees that are solutions of higher-order
schemes.
Theorem 1.2.19
The MSO-theory of a term-tree deﬁned by an arbitrary
higher-order recursion scheme is decidable.
Consequently, conﬁguration graphs of higher-order collapsible pushdown
automata can be model-checked against modal µ-calculus formulas. However,
there is a second-order CPDA whose conﬁguration graph interprets the inﬁnite
grid and whose MSO-theory is thus undecidable [81]. This shows that higher-
order CPDA conﬁguration graphs constitute a proper extension of Caucal’s
pushdown hierarchy.
1.2.4 Introducing products
There is a connection between the internal presentations of graphs seen so
far and the graph operations used in the corresponding equational framework.
Pushdown stacks are naturally represented as strings. The set of strings over
some alphabet can in turn be modelled as an algebra of terms built with unary
functions, one for each letter of the alphabet. Strings thus correspond to terms
and letters to unary functions. In functional programming terminology the
abstract data type of, say, binary strings has the recursive type deﬁnition
T = ⊥⊕0(T ) ⊕1(T )
(1.2)
Here the letters 0 and 1 are seen as type constructors and the empty string ⊥
is a constant type constructor. The set of ﬁnite strings is the least ﬁxed-point
solution of this equation.
Automata operating on terms of type T can be viewed as functions mapping
terms to states. Moreover these functions are deﬁned according to structural
recursion. Analogously, recursion schemes (ﬁx-point equations) in an algebra
of graph operations transform automata-based internal presentations of a graph
into equational speciﬁcations. We can use the recursion scheme associated to
the type deﬁnition (1.2) to deﬁne any PR-graph by a VR equation extending
the type deﬁnition. For instance, the graph of the lexicographic order from
Example 1.2.3 satisﬁes the following equation
L = edge0→1,ε→0,ε→1(•ε ⊕recol0,1,ε→0(L) ⊕recol0,1,ε→1(L)).
We brieﬂy explain how to go from automata presenting a PR-graph to a VR-
equation. For a language V ⊂{0, 1}∗recognised by an automaton with tran-
sition table  ⊂Q ×  × Q and ﬁnal states F the following VR-equation

20
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
colours each word w ∈{0, 1}∗by those states q such that the automaton start-
ing from q accepts w. (N.B. in accordance with (1.2) the simulation proceeds
right-to-left.)
X = •F ⊕recol{q′→q:(q,0,q′)}(X) ⊕recol{q′→q:(q,1,q′)}(X)
In general, every PR-graph 
i Ui · (Vi × Wi) is the recolouring of a graph
satisfying a VR-equation of the form
X = ϑ(ϑε(•) ⊕ϑ0(X) ⊕ϑ1(X)) .
(1.3)
Here, the states of the automata recognising Vi or Wi are encoded as vertex
colours (just as above) and ϑε colours • by the ﬁnal states of the Vi’s and Wi’s.
Edge colours are used to represent states of automata for each Ui. For every
v ∈Vi and w ∈Wi, and z accepted by the automaton for Ui from state q there
is a q-coloured edge (zv, zw). To this end, ϑ0 and ϑ1 recolour the vertices and
edges, and ϑ adds an edge between all x ∈Vi and y ∈Wi coloured by the ﬁnal
states of Ui.
In passing we mention that higher-order stacks can also be represented as
strings: either as well-bracketed sequences of stack symbols, or as strings of
stack operations yielding the particular stack conﬁguration. The former comes
at the cost of losing regularity of the domain and has no apparent algebraic
counterpart. The latter gives rise to a unary algebra of higher-order stacks
that is not, except for level 1 pushdown stacks, freely generated by the stack
operations. Thus there is no unique term representing a general stack. The
work of Fratani, Carayol and others [72, 73, 33, 32] has shown that both of
these deﬁciencies can be turned into features.
We now turn to graphs internally presented by ﬁnite trees. A type deﬁnition
for {0, 1}-labelled binary branching trees is
T = ⊥⊕0(T ⊗T ) ⊕1(T ⊗T )
(1.4)
where ⊗denotes direct product. Later we will compare this with another
type deﬁnition (1.6). Colcombet observed that this schema can be used to
deﬁne graphs with internal presentations involving tree automata operating on
ﬁnite trees. He proposed extensions of the VR-algebraic framework by the
asynchronous product ⊗A [48] and by the synchronous product ⊗S [50, 49]
which we shall denote here by VRA and VRS, respectively.
Deﬁnition 1.2.20
(Synchronous and asynchronous product) The products are
deﬁned for vertex and edge-coloured graphs G and H as follows. In the syn-
chronous product there is a d-coloured edge from (g, h) to (g′, h′) if, and only if,

Automata-based presentations of inﬁnite structures
21
both (g, g′) and (h, h′) are connected by a d-edge in G and H, respectively. The
edge relation Ed of the asynchronous product G ⊗A H is deﬁned as the union of
{((g, h), (g′, h)) | EG
d (g, g′), h ∈H} and {((g, h), (g, h′)) | EH
d (h, h′), g ∈G}.
The deﬁnition of vertex colours requires a little care. In both cases a vertex
(g, h) of the product has colour δ(c, c′) whenever g has colour c and h has
colour c′. Here the function δ : C2 →C is a parameter of the product opera-
tion. However, it is really only relevant that δ acts as a pairing function on some
sufﬁciently large subsets of the colours. For instance, Colcombet identiﬁes C
with {0, 1, . . . , N −1} and deﬁnes δ as addition modulo N [48].
As before, VRA-equational and VRS-equational graphs are deﬁned as least
ﬁxed-point solutions of a ﬁnite system of equations in the respective algebra.
Both product operations are cocontinuous with respect to graph embeddings.
Therefore the evaluation mapping of both VRA and VRS terms uniquely
extends from ﬁnite terms to inﬁnite terms. Hence, just as for HR- and VR-
equational graphs, the solution of a system of VRA or VRS equations is the
evaluation of the regular term obtained by unraveling the system of equations.
Example 1.2.21
The inﬁnite two-dimensional grid (N × N, Up, Right) is
easily constructed as the asynchronous product of the VR-equational, even
context-free, graphs (N, Up) and (N, Right):
G = ⊗A(Nu, Nr)
Nu = edgea
Up
→b
a• ⊕recola→b,b→c(Nu)

Nr = edgea
Right
→b
a• ⊕recola→b,b→c(Nr)

The unfolding of this system of equations is, schematically, an inﬁnite term
consisting of two periodic branches joined at the root. Elements of the grid G,
by deﬁnition of asynchronous product, are represented as pairs of nodes of this
term-tree with one node on either branch, corresponding to the respective co-
ordinates. The example of the grid, whose MSO theory is undecidable, shows
that the evaluation mapping of VRA terms (also of VRS terms) can not be
realised by an MSO-interpretation.
For any VRA or VRS-term t, vertices of [[t]] can be identiﬁed with maximal
subsets of nodes of t belonging to sub-terms joined by a product operator. It is
thus easily expressible in MSO whether a set X of nodes (ﬁnite or inﬁnite8) is
actually well-formed in this sense, i.e. whether it represents an element of [[t]].
8 In least ﬁxed-point semantics only ﬁnite sets are considered, whereas in greatest ﬁxed-point
semantics both ﬁnite and inﬁnite sets can represent elements of the solution, provided that there
is an inﬁnite nesting of product operators in t.

22
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
VR with asynchronous product and ground term rewriting
Ground term rewrite systems (GTRSs) are a natural generalisation of preﬁx-
rewriting to trees. They are term rewrite systems given by rewriting rules
in which no variables occur. Tree automata are a special case of GTRSs
(see [52]).
Example 1.2.22
The rewrite rule a →f (a) conﬁned to terms of the form
d(f n(a), f m(a)) is a GTRS whose conﬁguration graph is isomorphic to the
inﬁnite square grid.
We have noted that preﬁx-recognisable graphs are identical to ε-closures of
pushdown graphs. This correspondence is achieved by generalising the simple
preﬁx-rewriting rules of pushdown systems of the form v →w where v and w
are strings to replacement rules V →W for given regular languages V, W. The
latter rule allows one to rewrite any preﬁx v ∈V of a given string by any word
from W. Regular Ground Term Rewrite Systems (RGTRS) generalise GTRS in
the exact same manner: simple ground rewrite rules s →t with ground terms
s, t are replaced by ‘rule schemes’ S →T with regular sets of terms on both
left and right-hand side.
L¨oding [99, 100] and Colcombet [48] studied transition graphs of GTRSs
and RGTRSs from a model-checking point of view. In L¨oding’s work vertices
of the transition graph are those terms reachable from an initial term, whereas
Colcombet considers all terms of a given type as vertices.
The VR-equations deﬁning PR graphs (1.3) easily generalise to VRA-
equations deﬁning graphs of RGTRSs using the recursion scheme (1.4):
X = ϑ(ϑε(•) ⊕ϑ0(X ⊗A X) ⊕ϑ1(X ⊗A X))
(1.5)
For each rule Si →Ti of the RGTRS we simulate (frontier to root) tree automata
recognising Si and Ti. Vertices of X represent terms, so we call these vertex-
terms. A vertex-term is coloured by those states q occurring at the root of the
term after being processed by the automata. The simulation is initialised as
follows: ϑε labels • by initial states, and ϑ adds edges between all vertex-terms
coloured by accepting states of automata for Si and Ti. Updates occur in ϑjs
according to the transition rules, similarly to (1.3). To this end assume that two
vertex-terms v′, v′′ are coloured by states q′ and q′′ respectively. After taking
the product the paired vertex-term j(v′, v′′) is initialised with colour (q′, q′′)
(cf. Def. 1.2.20). This pair is then recoloured to q by ϑj whenever (q, j, q′, q′′)
is a transition.
Notice how naturally the asynchronous product captures closure of RGTR
rewriting under contexts: if there was an edge between v and v′ then there is

Automata-based presentations of inﬁnite structures
23
an edge between j(v, v′′) and j(v′, v′′), and, symmetrically, between j(v′′, v)
and j(v′′, v′). One obtains along these lines the following generalisations of
Theorem 1.2.11 (cf. examples 1.2.22 and 1.2.21).
Theorem 1.2.23 (Colcombet [48])
(i) A countable graph is VRA-equational if, and only if, it is (after removal
of certain colours) isomorphic to an RGTRS graph9.
(ii) Each VRA-equational graph is ﬁnite-subset interpretable in a regular
term-tree, hence also in the full binary tree.
Theorem 1.2.12 also extends to VRA-equational graphs [48, 100].
Theorem 1.2.24
VRA-equational graphs of ﬁnite tree-width are HR-
equational.
An immediate consequence of Theorem 1.2.23 is that the FO-theory of every
VRA-equational structure is decidable via interpretation in S2S. In fact, for any
VRA-equational graph G = (V, {Ea}a) the subset interpretation, hence also
ﬁrst-order decidability, extends to G with additional reachability predicates
RC = {(v, w) | w can be reached from v using edges of colours from C } for
arbitrary subsets C of edge colours [48].
Theorem 1.2.25
VRA-equational graphs have a decidable ﬁrst-order theory
with reachability.
This result cannot be improved much further. Examples of [139] show
that ‘regular reachability’, i.e. the problem whether there exists a path in a
given VRA-equational graph between two given nodes and such that the label-
ing of the path belongs to a given regular language over the set of colours,
is undecidable. In [100] L¨oding identiﬁed a maximal fragment of CTL that
is decidable on every GTRS graph (with vertices restricted to terms reach-
able from an initial one) that can express, besides reachability, recurring
reachability.
VR with synchronous product and tree-automatic structures
We have remarked that in the subset interpretation of VRA terms the subsets
are used in a special form. Indeed, in the evaluating interpretation they merely
serve the purpose of outlining the shape of a ﬁnite term. General ﬁnite-subset
interpretations are more powerful and are capable of expressing the evaluation
of VRS terms. In fact, these two formalism are equally expressive.
9 Here RGTRS graphs are taken in the sense of [48] as being restricted to the set of terms of a
given type.

24
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
This is best explained by tree-automatic presentations. These are internal
presentations of VRS-structures which will be formally introduced in the next
section. For now it sufﬁces to use the characterisation (Theorem 1.3.18) that
tree-automatic graphs are those that are wMSO-interpretable in a regular tree
(reﬂected in the equivalence of (1) and (2) below).
Theorem 1.2.26 (Colcombet [50])
For every countable graph G the following are equivalent
(1) G is isomorphic to a tree-automatic graph.
(2) G is interpretable in a regular tree (wlog. the full binary tree) via a ﬁnite-
subset interpretation.
(3) G is the restriction of a VRS-equational vertex-labelled graph G′ to its
set of vertices of a given colour;
We have noted that the evaluation mapping of VRS-terms can be naturally
deﬁned as a ﬁnite subset interpretation – this justiﬁes (3) →(2). Continu-
ing our discussion of translations from automata-based internal presentations
into equational speciﬁcations using graph products we illustrate the remaining
translation (2) →(3) from ﬁnite-tree automatic to VRS-equational presenta-
tions on graphs as we did for PR and RGTRS. That is, we build the terms
of the presentation from the bottom up while also simulating the automata
constituting the tree-automatic presentation by VRS-operations.
Start with a graph (V, E) that is deﬁnable via ﬁnite-subset interpretation in
the full binary tree. By the fundamental correspondence that wMSO-deﬁnable
relations in a regular tree are exactly those that are recognised by tree automata
operating on ﬁnite trees, we see that V may be taken to be a regular set of ﬁnite
-labelled binary trees, and E is recognised by an automaton A accepting pairs
of such trees.
The tree automaton A has transition rules (here we read them from left-to-
right, i.e in top-down fashion, but that is a matter of choice and the simulation
will actually proceed from bottom up) of the form
r : (q, ⟨a, b⟩, q0, q1)
with a, b ∈{0, 1, □}
where the symbol □is necessary for padding either component of a pair of
trees so that they have the same shape. It indicates the fact that no node is
deﬁned in the current position, i.e. that the automaton ﬁnds itself below a leaf
of the respective tree (while still reading the other). We may assume that the
transition rules enforce a proper usage of the padding symbols.
We introduce edge relations Eq and Er for each state q and each rule r
of the automaton. The simulation of transitions of the synchronous automaton

Automata-based presentations of inﬁnite structures
25
on pairs of labelled trees necessitates a more sophisticated recursion scheme
associated to the following type deﬁnition of {0, 1}-labelled binary branching
trees.
T = ⊥⊕({0, 1} ⊗T ⊗T )
(1.6)
There is a natural identiﬁcation of terms of this type and of those of the more
natural type deﬁnition (1.4). As far as unary predicates are concerned the
current type deﬁnition does not provide any advantage. However, compared
with (1.4) the current type deﬁnition has a more powerful associated recursion
scheme allowing for deﬁning non-trivial binary relations between terms with
different root labels. This will allow us to specify tree-automatic graphs via
VRS-equations of the following form analogous to (1.6)
X = ϑ

•⊥⊕(ϑ0 ⊗S ϑ1(X) ⊗S ϑ2(X))

(1.7)
Here too, as in (1.3) and in (1.5) the ϑ’s are VR-expressions facilitat-
ing the simulation of the automaton. The expression ϑ0 speciﬁes the graph
with vertex set {0, 1} and having an r-labelled edge from a to b for each
rule r such that r = (·, ⟨a, b⟩, ·, ·) and with VR operations (here equiva-
lently expressed as positive quantiﬁer-free deﬁnable operations) responsible for
updating the edge relations to simulate the transitions of A. This is done in two
phases.
– First, in preparation, state-labelled edges are used to ‘enable’ compati-
ble rule-labelled edges in either copy of the graph: for each rule r =
(·, ⟨·, ·⟩, q1, q2) and i ∈{1, 2} the expression ϑi adds an Er-edge from x
to y for every Eqi-edge from x to y in the graph.
– Then, after the synchronous product of rule-labelled edges has been taken,
edges labelled by rules are renamed to their resulting states: ϑ adds for each
state q an Eq-edge from x to y for every Er-edge from x to y such that
r = (q, ⟨·, ·⟩, ·, ·). In addition, ϑ deals with the case when either x or y is the
singleton tree ⊥. For this we may assume that all necessary information is
coded in vertex labels implemented as reﬂexive edges and maintained along
with the rest of the edge labels as explained here.
Finally, to obtain the graph G′ as required in item (3) of Theorem 1.2.26 we also
use vertex colours to keep track of the states of the tree automaton recognising
V . The generalisation of this construction to arbitrary relational structures is
straightforward.

26
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
1.3 Automatic Structures
1.3.1 Fundamentals
This section concerns structures with internal presentations consisting of
automata operating synchronously on their inputs. The starting point of this
investigation is the robust nature of ﬁnite automata. In particular, synchronous
automata are effectively closed under certain operations that can be viewed in
logical terms, i.e. Boolean operations, projection, cylindriﬁcation and permu-
tation of arguments. Thus a structure whose domain and atomic operations are
computable by such automata has decidable ﬁrst-order theory (Deﬁnition 1.3.2
and Theorem 1.3.4).
Example 1.3.1
(i) The domain and relations of the following structure are
regular.
S = (∗, {suca}a∈, ≺prefix, el)
where ∗is the set of ﬁnite words over alphabet , the binary relation
suca is the successor relation (x, xa) for x ∈∗, the binary relation
≺prefix is the preﬁx relation and the binary relation el is the equal-length
relation.
(ii) The following structure can be coded (eg. in base k least signiﬁcant digit
ﬁrst) so that the domain and atomic operations are regular.
Nk = (N, +, |k)
where + is the usual addition on natural numbers and x |k y holds precisely
when x is a power of k and x divides y.
Actually the link between synchronous automata and logic goes both ways.
It was ﬁrst expressed in terms of weak monadic second-order logic: a set of
tuples (A1, . . . , An) of ﬁnite sets of natural numbers is weak monadic second-
order deﬁnable in (N, S) if and only if the corresponding n-ary relation of
characteristic strings (a subset of ({0, 1}∗)n) is synchronous rational. This was
proved by [27] and [68], and is implicit in [135].
A ﬁrst-order characterisation was provided by [65]: a relation R ⊂(∗)n is
synchronous rational if and only if R is ﬁrst-order deﬁnable in S for || ≥2.
Similarly, the B¨uchi-Bruy`ere Theorem states that a relation R ⊂Nn (coded in
base k ≥2 least signiﬁcant digit ﬁrst) is synchronous rational if and only if it is
ﬁrst-order deﬁnable in Nk (proofs of which can be found in [104] and [137]).
These results were generalised to full MSO on the line (N, S) and weak
MSO and full MSO on the tree ({0, 1}∗, suc0, suc1) and form the basis of the

Automata-based presentations of inﬁnite structures
27
logical characterisation of automatic structures (Section 1.3.4). However, we
start with the more common internal deﬁnition.
Recall that the four basic types of automata operate on ﬁnite or inﬁnite
words or trees. So, let □be one of word, ω-word, tree, ω-tree.
We consider a structure B = (B, {Ri}) comprising relations Ri over the
domain dom(B) = B. Thus constants and operations are implicitly replaced
by their graphs.
Deﬁnition 1.3.2 (Automatic presentation)
A □-automatic presentation of B
consists of a tuple d = (A, A≈, {Ai}) of ﬁnite synchronous □-automata and a
naming function f : L(A) →B such that
– Each L(Ai) is a relation on the set L(A).
– L(A≈) is a congruence relation on the structure (L(A), {L(Ai)}i).
– The quotient structure is isomorphic to B via f .
Moreover, the quotient structure is called an automatic copy of B. We say that
the presentation is injective whenever f is, in which case A≈can be omitted.
Deﬁnition 1.3.3 (Automatic structure10)
A structure B is □-automatic if it
has an □-automatic presentation. If B is □-automatic for some □then B is
simply called automatic. The classes of automatic structures are respectively
denoted by S-AutStr, ωS-AutStr, T-AutStr and ωT-AutStr.
The following theorem motivates the study of automatic structures and so
may be called the Fundamental Theorem of automatic structures/presentations.
Theorem 1.3.4 (Deﬁnability)
There is an algorithm that given a □-automatic
presentation (d, f ) of a structure A and a FO-formula ϕ(x) in the signature
of A deﬁning a k-ary relation R over A, effectively constructs a synchronous
□-automaton recognising f −1(R).
Immediate corollaries are
(i) Decidability: The FO-theory of every automatic structure is decidable.
(ii) Interpretations: The class of □-automatic structures is closed under FO-
interpretations.
We point out that the Fundamental Theorem implies that every relation
ﬁrst-order deﬁnable from □-regular relations is itself □-regular.
Remark 1.3.5
One may allow ﬁnitely many parameters ϕ(a, x) under the fol-
lowing conditions. For ﬁnite-word and ﬁnite-tree presentations any parameters
10 Some authors write automatically presentable.

28
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
can be used. However, for ω-tree (and ω-word) presentations a parameter a can
be used if f −1(a) contains a regular ω-tree (ultimately periodic ω-word).
Consequently □-automatic structures (on a given signature) are closed
with respect to operations such as disjoint union, ordered sum and direct
product – each a special case of generalised products treated in [20, 23].
However AutStr and ωS-AutStr are not closed under weak direct-power.
For instance, (N, +) is in S-AutStr but its weak direct-power is isomor-
phic to (N, ×), which is not in S-AutStr (see [20]). On the other hand, it is
straightforward to see that T-AutStr and ωT-AutStr are closed under weak
direct-power.
1.3.2 Examples
Obviously every ﬁnite structure is automatic. Here are a some examples of
structures with automatic presentations.
Example 1.3.6 (Ordinals)
(i) (ω, <) ∈S-AutStr: The simplest auto-
matic copy is the unary one: (0∗, {(0k, 0l) | k < l}).
(ii) Every ordinal below ωω is in S-AutStr: An automatic copy of ωk
is ((0∗1)k, <lex) where <lex denotes the lexicographic order11 which is
clearly regular. In this presentation the naming function is
0nk−11 . . . 0n01 →nk−1ωk−1 + · · · + n1ω1 + n0.
(iii) Every ordinal below ωωω is in T-AutStr: recall that the ordinal ωα has
a representation as the set of functions f : α →ω with f equal to 0 in all
but ﬁnitely many places. These functions are ordered as follows: f < g if
the largest β with f (β) ̸= g(β) has that f (β) < g(β). Then for ﬁxed k, a
function f : ωk →ω is coded by the tree Tf with domain a ﬁnite subset
of 0∗1∗2∗· · · k∗so that for every β, expressed in Cantor-normal-form as
ωk−1c0 + ωk−2c1 · · · + ω0ck−1, 0 ≤ci < ω, we have Tf (0c01c1 · · · (k −
1)ck−1kf (β)) = 1.
Example 1.3.7 (Orderings)
(i) (Q, <) ∈S-AutStr: The countable linear
order ({0, 1}∗1, <lex) is dense without endpoints.
(ii) (R, <) ∈ωS-AutStr.
11 Given an ordering on the symbols of the alphabet a word u is lexicographically smaller than w
if either u is a proper preﬁx of w or if in the ﬁrst position where u and w differ there is a
smaller symbol in u than in w.

Automata-based presentations of inﬁnite structures
29
Example 1.3.8 (Groups)
(i) Every
ﬁnitely-generated
group
with
an
Abelian group of ﬁnite index is in S-AutStr. And these are the only
ﬁnitely generated word-automatic groups [116].
(ii) The direct sum of countably many copies of Z/mZ is in S-AutStr.
(iii) The subgroup Z[1/k] of rationals of the form {zk−i | z ∈Z, i ∈N} for
ﬁxed k ∈N is in S-AutStr.
(iv) The Pr¨ufer p-group Z(p∞) = Z[1/p]/Z (prime p) is in S-AutStr
[114].
(v) Real addition (R, +) is in ωS-AutStr.
However, the additive group of the rationals (Q, +) is not automatic [136].
In fact, Tsankov shows that no torsion free Abelian group that is p-divisible
for inﬁnitely many primes p is automatic.
Example 1.3.9 (Arithmetics)
(i) (N, +) is in S-AutStr: For every natural
k > 1, the base k least-signiﬁcant-digit-ﬁrst presentation of naturals (with
or without leading zeros) constitutes a naming function of an automatic
presentation. A ﬁnite automaton can perform the schoolbook addition
method while keeping track of the carry in its state. Such a presentation is
injective when leading zeros are suppressed.
(ii) (N, ·) is in T-AutStr: The presentation is based on the unique factorisa-
tion of every natural number n into prime powers 2n23n3 · · · pnp. Each nk
is written, say in binary notation, on a single branch of a tree with domain
0∗1∗. Multiplication is reduced to the addition of corresponding expo-
nents. This construction can naturally be generalised to give tree-automatic
presentations of weak direct powers of word-automatic structures
[20, 25].
Example 1.3.10 (Equivalence relations)
The following have ﬁnite-word auto-
matic presentations.
(i) There is one class of size n for every n ∈N.
(ii) There are d(n) classes of size n ∈N where d(n) is the number of divisors
of n. (This is the direct product of the previous equivalence relation with
itself).
Example 1.3.11 (Free algebras)
(i) The free algebra with n unary opera-
tions and at most ω many constants is in S-AutStr.
(ii) The free monoid generated by a single constant is in S-AutStr. How-
ever, no non-unary free or even free-associative algebra on two or more
constants is in S-AutStr.

30
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
(iii) The free algebra generated by countably many constants and any ﬁnite
number of operations is in T-AutStr.12 For instance suppose there
is one binary operation F. The domain of the presentation consists of
all {F, c, ⊥}-labelled binary trees. The operation (representing F) takes
trees S and T as input and returns the tree with domain the preﬁx-closure
of (dom(S) ∪dom(T )){0, 1} and taking the following values: the root
position is labelled F; position α0 is labelled by the label of S at position
α; position α1 by the label of T at position α (if either of these latter
positions does not exist, the label is ⊥). It is not known whether ﬁnitely
generated (non-unary) term algebras are in T-AutStr.
Example 1.3.12 (Boolean Algebras)
The signature we work in consists of
the symbols for boolean operations ∩, ∪, ·c and constants ⊥, ⊤.
(i) Every ﬁnite power of the algebra of ﬁnite and co-ﬁnite subsets of N is in
S-AutStr.
(ii) The countable atomless Boolean algebra is in T-AutStr: It is isomorphic
to the algebra of sets consisting of the clopen sets in Cantor space. Each
clopen set has a natural representation as a ﬁnite tree.
(iii) The algebra of all subsets of N is in ωS-AutStr.
(iv) The algebra of all subsets of N factored by the congruence of having
ﬁnite symmetric difference is in ωS-AutStr. It is unknown whether
this structure can be injectively presented in ωS-AutStr.
(v) The interval algebra of the real interval [0, 1) is in ωT-AutStr.
(vi) The algebra of all subsets of {0, 1}∗with a distinguished set F consisting
of those X ⊂{0, 1}∗such that for every path π ∈{0, 1}ω only ﬁnitely
many preﬁxes of π are in X.
Example 1.3.13 (Graphs)
(i) The inﬁnite upright grid is in S-AutStr:
Here the structure is (N × N, Up, Right) with the functions Right :
(n, m) →(n + 1, m) and Up : (n, m) →(n, m + 1). It can be automati-
cally presented on the domain a∗b∗with relations
R =
a
a
∗b
a
b
b
∗□
b

and U deﬁned by a similar regular expression.
(ii) The transition graphs of pushdown automata are in S-AutStr:13 Given
a pushdown automaton A with states Q, stack alphabet 
, input alphabet
12 Communicated by Damian Niwinski.
13 For visibly pushdown automata the same representation of conﬁgurations also allows for the
trace equivalence relation to be recognised by a ﬁnite automaton. In [10] this presentation was
utilised to obtain a decidability result.

Automata-based presentations of inﬁnite structures
31
 and transition relation  we can construct an automatic presentation of
the transition graph of its conﬁgurations as follows. We take Q
∗to be the
domain of the presentation in which qγ represents the conﬁguration of
state q and stack γ ∈
∗. For each a ∈ there is an a-transition from qγ
to q′γ ′ if, and only if, γ = zα, γ ′ = wα and (q, z, q′, w) ∈ for some
z ∈
 and w ∈
∗. Since  is ﬁnite, this relation is obviously regular for
each a. Notice that in these presentations the transition relations are not
only regular but in fact deﬁned by preﬁx-rewriting rules (cf. Section 1.2.1
on context-free graphs).
(iii) The transition graphs of Turing machines are in S-AutStr [87]. We
can give an automatic presentation of each TM M similar to those of
pushdown automata. Conﬁgurations are encoded as strings αqβ ∈
∗Q
∗
where α and β are the tape contents to the left, respectively, to the right
of the head of M, and q is the current state. Observe that, as opposed
to presentations of pushdown graphs, the state is now positioned not
at the left of the string but at the location of the head. Consequently,
rewriting is not conﬁned to preﬁxes, but rather occurs around the state
symbol: transitions are of the form αuqwβ →αu′q′w′β for adequate
u, w, u′, w′ and q, q′ as determined by the transition function of M. The
fact that TM graphs are presentable using inﬁx rewriting has the profound
consequence that reachability questions in inﬁx-rewriting systems are
generally undecidable, as opposed to graphs of preﬁx-rewriting systems,
whose monadic second-order theory is decidable (cf. Theorem 1.2.4).
Example 1.3.14 (Automata-theoretic structures)
The following structures
turn out to be universal for their respective classes (see Theorem 1.3.17).
(i) Let
S = (∗, {suca}a∈, ≺prefix, el)
and
Sω
 = (≤ω, {suca}a∈, ≺prefix, el)
be the structures deﬁned on ﬁnite, respectively on ﬁnite and ω-words,
comprising the successor relations suca = {(w, wa) | w ∈∗}; the preﬁx
relation u ≺prefix w (where u is ﬁnite and w is ﬁnite or inﬁnite); and
the equal-length relation: u el w if, and only if, |u| = |w|. Clearly S ∈
S-AutStr and Sω
 ∈ωS-AutStr. Note that if  is unary, then S
reduces to (N, +1, <, =).

32
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
(ii) The structure T ∈T-AutStr has domain consisting of all ﬁnite binary
-labelled trees and has operations
(⪯ext, ≡dom, (sucd
a)d∈{l,r},a∈, (ϵa)a∈)
where T ⪯ext S if dom(T ) ⊂dom(S) and S(α) = T (α) for α ∈dom(T );
T ≡dom S if dom(T ) = dom(S); sucd
a(T ) = S if S is formed from T by
extending its leaves in direction d and labeling each new such node by a;
and ϵa is the tree with a single node labelled a.
Similarly the structure T ω
 ∈ωT-AutStr has domain consisting of
all ﬁnite and inﬁnite trees and operations
(⪯ext, ≡dom, (sucd
a)d∈{l,r},a∈, (ϵa)a∈).
that are restricted to ﬁnite trees, except that T ⪯ext S is deﬁned as above
but allows S to be an inﬁnite tree.
1.3.3 Injectivity
Recall that an automatic presentation is injective if the naming function is
injective. The problem of injectivity is this:
Does every □-automatic structure have an injective □-automatic presentation?
An injective presentation has the advantage that it is easier to express certain
cardinality-properties of sets of elements (Theorem 1.4.6). We consider the four
cases.
Finite words
From a ﬁnite-word automatic presentation of A one deﬁnes an injective pre-
sentation of A by restricting to a regular set D of unique representatives. These
can be chosen using a regular well-ordering of the set of all ﬁnite words. For
instance, deﬁne D ⊂L(A) to be the length-lexicographically least words from
each L(A≈) equivalence class.
Finite trees
Except in the ﬁnite word case, there is no regular well ordering of the set
of all ﬁnite trees [39]. However one can still convert a ﬁnite-tree automatic
presentation into an injective one [47]. The idea is to associate with each tree t
a new tree ˆt of the following form: the domain is the intersection of the preﬁx-
closures of the domains of all trees that are L(A≈)-equivalent to t; a node is
labelled σ if t had label σ in that position; a leaf x is additionally labelled by

Automata-based presentations of inﬁnite structures
33
those states q from which the automaton A≈accepts the pair consisting of the
subtree of t rooted at x and the tree with empty domain.14 Using transitivity
and symmetry of L(A≈), if ˆt = ˆs then t is L(A≈)-equivalent to s. Moreover
each equivalence class is associated with ﬁnitely many new trees, and so a
representative may be chosen using any ﬁxed regular linear ordering of the set
of all ﬁnite trees.
ω-words
There is a structure in ωS-AutStr that does not have an injective ω-word
automatic presentation [82]. The proof actually shows that the structure has no
injective presentation in which the domain and atomic relations are Borel.
However, every countable structure in ωS-AutStr does have an injective
ω-word automatic presentation [85] (and consequently is also in S-AutStr).
This follows from the more general result that every ω-word regular equivalence
relation with countable index has a regular set of representatives [85].
ω-trees
It has not yet been settled whether injective presentations sufﬁce, even for the
countable structures.
1.3.4 Alternative characterisations
Automatic structures were deﬁned internally. We now present equivalent char-
acterisations: logical (FO and MSO) and equational.
First-order characterisations
In order to capture regularity in the binary representation of N using ﬁrst-order
logic B¨uchi suggested the expansion (N, +, {2n | n ∈N}) of Presburger arith-
metic, which is, however, insufﬁcient (see [26]). Boffa and Bruy`ere considered
expressively complete expansions of (N, +) by relations of the form x |k y
(deﬁned to hold precisely when x is a power of k and x divides y).
Theorem 1.3.15 (B¨uchi-Bruy`ere, cf. [26])
A relation R ⊆Nr is regular in
the least-signiﬁcant-digit-ﬁrst base k presentation of N if, and only if, R is
ﬁrst-order deﬁnable in the structure Nk = (N, +, |k).
Closer to automata, the structures S on words (see example 1.3.14) allow
one to deﬁne every regular relation on alphabet .
14 The construction given in [47] is slightly more general and allows one to effectively factor
ﬁnite-subset interpretations in any tree.

34
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Theorem 1.3.16 ([65])
Let  be a ﬁnite, non-unary alphabet. A relation over
∗is regular if, and only if, it is ﬁrst-order deﬁnable in S.
The proofs of these theorems are by now standard. From left to write one
writes a formula φA(x) that expresses the existence of a successful run in
automaton A on input x. For the other direction the atomic operations of the
structures are regular forms the base case for structural induction on the formula.
Both theorems transfer to automatic structures by replacing deﬁnability with
interpretability [24, 25].
Theorem 1.3.17 (First-order characterisation of S-AutStr)
The following
conditions are equivalent.
– A ∈S-AutStr.
– A is ﬁrst-order interpretable in S (for some/all  with || ≥2).
– A is ﬁrst-order interpretable in Nk (for some/all k ≥2).
These structures have been called universal or complete (with respect to
FO-interpretations) for the class of ﬁnite-word automatic structures. There are
similar universal structures for the other classes of automatic structures. These
are the structures Sω
, T and T ω
 from Example 1.3.14 [20, 14].
Finite set interpretations
The four notions of automatic presentation have straightforward reformulations
in terms of subset interpretations either in the line 1 = (N, suc) or in the tree
2 = ({0, 1}∗, suc0, suc1).
Theorem 1.3.18 (Automatic presentations as subset interpretations)
There
are effective transformations establishing the following equivalences.
(i) A ∈S-AutStr if, and only if, A ≤fset 1
(ii) A ∈ωS-AutStr if, and only if, A ≤set 1
(iii) A ∈T-AutStr if, and only if, A ≤fset 2
(iv) A ∈ωT-AutStr if, and only if, A ≤set 2
Equivalently, one may formulate universality with respect to FO interpre-
tations. Following [47] we deﬁne the (ﬁnite) subset envelope P(f )(A) of a
structure A by adjoining to A its (ﬁnite) subsets as new elements ordered by
set inclusion.
Deﬁnition 1.3.19
Given A = (A, {Ri}) write P(A) for the set of all subsets of
A. The subset envelope P(A) is the structure with domain P(A) and relations
R′
i := {({a1}, . . . , {an}) | (a1, . . . , an) ∈Ri} and the subset relation ⊆deﬁned

Automata-based presentations of inﬁnite structures
35
on P(A). The ﬁnite-subset envelope Pf (A) is the substructure of P(A) whose
domain is the set of ﬁnite subsets of A.
It is immediately clear that
B ≤(f)set A ⇐⇒B ≤FO P(f )(A)
In particular, this yields natural universal structures, with respect to FO-
interpretations, for each of the four classes of automatic structures.
Corollary 1.3.20
(i) Pf (1) is universal for S-AutStr.
(ii) P(1) is universal for ωS-AutStr.
(iii) Pf (2) is universal for T-AutStr.
(iv) P(2) is universal for ωT-AutStr.
VRS-Equational structures
Recall that the VRS-algebra of graphs extends the VR-algebra with the syn-
chronous product operation and that VRS-equational systems deﬁne exactly
the ﬁnite-tree automatic graphs (see Section 1.2.4 and Theorem 1.2.26).
A ﬁnite VRS-equational system whose unfolding is a linear VRS-term
speciﬁes a structure in S-AutStr. This happens if in the deﬁning equations
one of the arguments of each occurrence of ⊕and of ⊗S is a ﬁnite graph (and so
these act like unary operations). Conversely, for word-automatic presentations
Equation (1.7) reduces to the following form:
X = ϑ

•⊥⊕( ϑ0 ⊗ϑ1(X) )

(1.8)
This scheme matches the following type deﬁnition obtained by restricting (1.6)
to words:
T = ⊥⊕( {0, 1} ⊗T )
(1.9)
This recursive deﬁnition of the set of words has the same advantage over (1.2)
as (1.6) has over (1.4) when it comes to deﬁning binary relations over words via
structural induction, e.g. via ﬁnite automata. Over words we have the following
special case of Theorem 1.2.26.
Theorem 1.3.21 (Colcombet [50])
For every countable structure A the following are equivalent
(1) A is isomorphic to a word-automatic graph.
(2) A is the restriction of some B to its elements of a certain colour, where
B can be speciﬁed by a VR-equation Z = π(X), where π simply forgets
some of the structure of X, together with a VRS-equation for X of the
form (1.8);
(3) A is ﬁnite-subset interpretable in (N, suc).

36
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
The equivalence of the ﬁrst and the third item is a direct consequence of the
classical correspondence of automata on words and monadic second-order logic
of one successor and was already stated in Theorem 1.3.18. Nonetheless, this
can also be inferred from the fact that the solution term obtained by unfolding
(1.8) is (essentially) a periodic linear VRS-term that evaluates, via a ﬁnite-
subset interpretation, to the word-automatic structure speciﬁed by equation
(1.8).
More generally, let VRS−denote the extension of VR with unary opera-
tions X →G0 ⊗S X where G0 is any ﬁnite graph. Moreover let us call a chain
interpretation a subset interpretation in a tree where each of the subsets repre-
senting an element is linearly ordered by the ancestor relation of the tree. It is
not hard to see that solutions of ﬁnite systems of VRS−-equations are ﬁnite-
chain interpretable in a regular tree and that these in turn are word automatic
[50].
1.3.5 Rational graphs
If we allow the more general asynchronous automata in the deﬁnition of an
automatic presentation of a graph we get the notion of a rational graph. Thus
vertices are labelled with ﬁnite words of a rational language over some ﬁnite
alphabet , and the edge relations are required to be rational subsets of ∗×
∗.
With no aim for completeness we list below some results on rational graphs
(asynchronous) in comparison with automatic graphs (synchronous). For a
comprehensive treatment the reader is referred to [105].
The class of rational graphs strictly includes that of ﬁnite-word automatic
graphs. In their seminal paper [87] Khoussainov and Nerode also introduced
asynchronous automatic structures. As an example they gave an asynchronous
automatic presentation of ωω, which is not in S-AutStr (see Theorem 1.4.12).
Asynchronous automatic presentations of Cayley-graphs of ﬁnitely generated
groups have also been considered as generalisations of ‘automatic groups’ [31].
The price of increasing expressiveness is a loss of tractability: in general,
rational graphs do not have a decidable ﬁrst-order theory. This renders rational
graphs useless for representing data, let alone programs. However, in the context
of formal language theory rational graphs seem to ﬁll a gap. Considering
rational graphs as inﬁnite automata, i.e. as acceptors of languages, Morvan
and Stirling have shown that they trace exactly the context-sensitive languages
[108, 107] (see also [34] for a simpliﬁed approach). Rispal and others [123,
107, 34] have subsequently observed that this holds true for automatic graphs
as well.

Automata-based presentations of inﬁnite structures
37
Although ﬁrst-order queries on rational graphs are in general intractable
there are some interesting decidable subclasses.
Morvan observed that by a result of Eilenberg and Sch¨utzenberger, graphs
deﬁned by rational relations over a commutative monoid have a decidable ﬁrst-
order theory. In particular, over the unary alphabet the monoid structure is
isomorphic to (N, +) whence the unary rational graphs are those ﬁrst-order
deﬁnable in (N, +) [105]. Similarly, rational graphs over (N, +)d are those
having a d-dimensional ﬁrst-order interpretation in (N, +).
Carayol and Morvan showed that on rational graphs that also happen to be
trees (this is an undecidable property) ﬁrst-order logic is decidable [36, 106].
The decision method is based on locality of FO as formulated by Gaifman and
uses a compositional technique. The authors also exhibit a rational graph that
is a ﬁnitely branching tree but is not ﬁnite-word automatic.
1.3.6 Generalisations
Automata with oracles
Consider an expansion O
i of i := ([i]∗, suc0, . . . , suci−1) by a unary pred-
icate O ⊂[i]∗. Every MSO formula (with free MSO variables) of the expanded
structure corresponds to a tree automaton with oracle O. An automaton with
oracle is one that, while in position u ∈[i]∗, can decide on its next state using
the additional information of whether or not u ∈O. Thus for automata working
on inﬁnite words/trees the oracle O is simply read as part of the input. In the
case of automata working on ﬁnite words/trees, the entire oracle is scanned, and
so the acceptance condition should be taken appropriately (eg. Muller/Rabin).
Call a set O decidable if MSO(O
i ) is decidable, and weakly decidable if
wMSO(O
i ) is decidable. Early work on decidable oracles used the contraction
method to show that certain oracles on the line, such as {n! | n ∈N}, are
decidable [67]. This was extended to the effectively proﬁnitely ultimately peri-
odic words [38], which it turns out capture all the decidable unary predicates
on the line [119, 120]. Nonetheless, it is still of interest to produce explicit
examples of decidable oracles, see for instance [38, 74, 75, 7].
Deﬁnition 1.3.22
If in the deﬁnition of automatic presentation (1.3.2) we
replace □-automata with □-automata with oracle O, we get a notion of □-
automatic presentation with oracle O. A structure is called automatic with
oracle if it has a □-automatic presentation with some oracle.
Example 1.3.23
The group of rationals (Q, +) has recently been shown to
have no word-automatic presentation [136]. However it is ﬁnite-word automatic
with oracle #2#3#4 · · · . This is based on the idea, independently found by Frank

38
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Stephan and Joe Miller and reported in [114], that there is a presentation of
([0, 1) ∩Q, +) by ﬁnite words in which + is regular, but the domain is not:
every rational in [0, 1) can be expressed as 	n
i=2
ai
i! for a unique sequence of
natural numbers ai satisfying 0 ≤ai < i. The presentation codes this rational
as #a2#a3#a4 · · · where ai is written in decimal notation (and hence has length
less than the length of i written in decimal notation). Addition is performed
with the least signiﬁcant digit ﬁrst, based on the fact that
ai + bi + c
i!
=
1
(i −1)! + ai + bi + c −i
i!
where c ∈{0, 1} is the carry in.
We immediately have that a structure is (ﬁnite-)word/tree automatic with
oracle O if and only if it is (ﬁnite) set interpretable in O
1 /O
2 . Hence we have
the following generalisation of the Fundamental Theorem and its corollaries
(1.3.4).
Theorem 1.3.24
(i) Deﬁnability: Say (d, f ) is a □-automatic presentation
with oracle O of a structure A and ϕ(x) is a FO-formula in the signature
of A deﬁning a k-ary relation R over A. Then the relation f −1(R) is
recognised by an □-automaton with oracle O.
(ii) Interpretations: The class of □-automatic structures with oracle O is
closed under FO-interpretations.
(iii) Decidability: The previous statements can be made effective under the
following conditions.
1 For □∈{word, tree} we require that wMSO(O
i ) be decidable.
2 For □∈{ω-word, ω-tree} we require that MSO(O
i ) be
decidable.
In particular, under these conditions, every A that is □-automatic with
oracle O has decidable FO-theory.
Of course O
i can be viewed as a coloured tree. As in Corollary 1.3.20 we
have universal structures with respect to FO-deﬁnability. For instance P(O
2 )
is universal for ωT-AutStr with oracle O. The following result concerns
ﬁnite-set interpretations in arbitrary trees.
Theorem 1.3.25 ([47])
To every ﬁnite set interpretation I one can effectively
associate a wMSO interpretation J such that for every tree t and structure A
if Pf (A) ∼= I(t) then A ∼= J (t).
This can be used to show that certain structures, such as the random graph,
are not ﬁnite-tree automatic in the presence of any oracle [47].

Automata-based presentations of inﬁnite structures
39
1.3.7 Subclasses
In this section we restrict the complexity of the regular domains in automatic
presentations to yield some of the more robust subclasses of S-AutStr and
T-AutStr.
Polynomial domain
The most natural restriction is to consider presentations where the words and
trees take labels from a unary alphabet || = 1. Word-automatic presentations
over a unary alphabet were introduced and studied by Blumensath [20] and
Rubin [89, 124].
The density of a language L ⊂∗is the function n →|L ∩n|.
Deﬁnition 1.3.26
A structure is unary automatic if it has an injective word-
automatic presentation in which the domain consists of words from a unary
alphabet. A structure is p-automatic if it has an injective word-automatic pre-
sentation in which the domain has polynomial density. Let 1-AutStr and
P-AutStr denote these respective classes of structures.
Regular sets of polynomial density were characterised by Szilard et al. [131]
as being a ﬁnite union of the form
D =

i<N
ui,1v∗
i,1ui,2 . . . ui,niv∗
i,niui,ni+1
(1.10)
where the degree of the polynomial of the density function is equal to the max-
imum of the ni’s. In [6] it was demonstrated that every ﬁnite-word-automatic
presentation over a domain as in (1.10) can be transformed into an equivalent
one (cf. Section 1.4.4) over a domain that is a regular subset of
a∗
1a∗
2 . . . a∗
n
where n is equal to the maximum of the ni’s. In particular, word-automatic
presentations over a domain of linear density are unary automatic. This trans-
formation yields a kind of normal-form of word-automatic presentations over
a polynomially growing domain.
Theorem 1.3.27 ([6])
A structure A has an automatic presentation over a
domain of density O(nd) if, and only if, it has a d-dimensional interpretation
in M := (N, <, {≡(mod m)}m>1) if, and only if, it is ﬁnite-subset interpretable in
1 := (N, suc) with subsets of size at most d.
Corollary 1.3.28 ([113],[20])
A structure A is unary automatic if, and only
if, it is ﬁrst-order deﬁnable in M if, and only if, it is MSO-interpretable in 1.

40
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Unary automatic structures form a very restricted subclass of VR-equational
structures and have a decidable MSO-theory. Using pumping arguments one
can show that Presburger arithmetic (N, +) has no p-automatic presentation
[20, 121]. On the other hand, the inﬁnite grid is p-automatic but not unary
automatic. Thus we have
1-AutStr ⊊P-AutStr ⊊S-AutStr .
The expansion of M with the successor function suc and a constant for
0 admits quantiﬁer elimination. Hence, every p-automatic structure can be
interpreted in (N, 0, suc, <, {≡(mod m)}m>1) using quantiﬁer-free formulas.
Every p-automatic structure inherits the Pspace upper-bound on the com-
plexity of its ﬁrst-order theory from M. This is as low as possible since FO
model-checking is Pspace-hard for any structure with at least two elements.
Adding even the simplest form of iteration to FO leads to undecidability. For
every k-counter machine it is straightforward to construct a p-automatic pre-
sentation of its conﬁguration graph where each conﬁguration (q, n1, . . . , nk) is
represented by the word qcn1
1 · · · cnk
k . It follows that the ﬁrst-order theory with
reachability FO[R] of a p-automatic structure is undecidable in general. In
comparison, while unary automatic structures have a decidable MSO-theory,
the FO(DTC) theory of (N, succ) interprets full ﬁrst-order arithmetic and is
therefore highly undecidable [20].
Observe, that graphs having rational presentation over a ﬁnitely gener-
ated commutative monoid (cf. Section 1.3.5) can be seen as analogues of
p-automatic graphs. Indeed, every monoid element is represented by some
word gr1
1 gr2
2 . . . grn
n over the generators.
Finite-rank tree-automatic presentations
The analogue of p-automatic to tree-automatic structures is restricting to pre-
sentations involving trees of bounded rank. Intuitively the rank of a tree cor-
responds to its branching degree (which can be measured in terms of the
Cantor-Bendixson rank).
Recall a -labelled n-ary tree T is a function from a preﬁx-closed subset
of [n]∗to . We say that T has rank k if its domain has polynomial density of
degree at most k.
A ﬁnite-tree automatic presentation is called of rank k if for some regular
language D of polynomial density of degree at most k the domain of every tree
in the presentation is a subset of D. Collectively we speak of bounded-rank
tree-automatic presentations. The class of structures with rank k presentations
is denoted k-T-AutStr.
Example 1.3.29
The ordinal ωωk has a rank k + 1 tree-automatic presentation.

Automata-based presentations of inﬁnite structures
41
ωS-AutStr
countable
ωT-AutStr
injωS-AutStr
countable
injωT-AutStr
countable
S-AutStr
inj
T-AutStr
inj
Figure 1.2 Relationship of classes of automatic structures
Let Tk denote the structure corresponding to the unlabelled k-ary tree with
domain 0∗1∗· · · (k −1)∗. Note that Tk is wMSO-interpretable in the ordinal ωk
(in the signature of order), and vice-versa.
Proposition 1.3.30
The following are equivalent.
– A is in k-T-AutStr,
– A is ﬁnite-set interpretable in Tk (or equivalently in the ordinal ωk),
– A is the solution of a ﬁnite system of VRS-equations whose unfolding is a
term-tree of rank k.
The hierarchy is strict:
S-AutStr = 1-T-AutStr ⊊2-T-AutStr ⊊· · · ⊊T-AutStr.
Indeed, if k+1-T-AutStr = k-T-AutStr for some k then the ﬁnite-
subset envelope Pf (ωk+1) would be ﬁnite-set interpretable in ωk. But by The-
orem 1.3.25 then ωk+1 is wMSO interpretable in ωk, which is known not to be
possible [98, Lemma 4.5].15
1.3.8 Comparison of classes
Since words are special cases of trees, and ﬁnite ones special cases of inﬁ-
nite ones, one immediately sees the inclusions indicated by the arrows in
the ﬁgure. All the arrows except for the dotted one are known to be strict
inclusions. We now discuss the separating examples as well as the double
lines indicating equality of the classes when restricted to countable struc-
tures. Since ωS-AutStr and ωT-AutStr contain uncountable structures
while S-AutStr and T-AutStr do not, we split our discussion along these
lines.
15 We thank Łukasz Kaiser for discussions on the notions of this section and Alex Rabinovich for
providing the latter reference.

42
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Countable structures
The structure (N, ×) separates T-AutStr from S-AutStr (see [20], or [88]
for an alternative proof).
Every injective ωS-AutStr presentation of a countable structure can be
effectively transformed into a S-AutStr presentation. This is because a count-
able ω-regular set X ⊆{0, 1}ω only contains ultimately periodic words, and
moreover there is a bound on the size of the periods (which can be computed
from an automaton for X). Similar facts hold for countable regular sets of
inﬁnite trees [115].
The next theorem generalises this in the word case:
Theorem 1.3.31 ([85])
(i) The countable structures in ωS-AutStr are
precisely those in S-AutStr.
(ii) Given a (not necessarily injective) automatic presentation of some A ∈
ωS-AutStr it is decidable whether A is countable or not, and if it is, an
automatic presentation of A over ﬁnite words can be constructed.
On the other hand, we do not know whether every countable structure in
ωT-AutStr is in T-AutStr.
Uncountable structures
The only known non-trivial methods dealing with uncountable structures appear
in [82]:
(i) The algebra (P({0, 1}∗), ∩, ∪, ·c, F) from example 1.3.12(vi) is an
uncountable structure separating ωT-AutStr from ωS-AutStr.
(ii) Recall Example 1.3.12(iv) consisting of the algebra of subsets of N (call it
A) quotiented by having ﬁnite symmetric difference (call it ≈). Construct
a variant structure as the disjoint union of A and A/≈, with a unary
predicate U identifying the elements of A and a binary relation R relating
a ∈A to its representative in A/≈. This uncountable structure separates
ωS-AutStr from injωS-AutStr.
1.4 More on word-automatic presentations
1.4.1 Beyond ﬁrst-order logic
The Fundamental Theorem can be strengthened to include order-invariant deﬁn-
able formulas as well as certain additional quantiﬁers.

Automata-based presentations of inﬁnite structures
43
Generalised quantiﬁers
We brieﬂy recall the deﬁnition of generalised quantiﬁers as introduced by
Lindstr¨om.
Deﬁnition 1.4.1
Fix a ﬁnite signature τ = (Ri)i≤k, where Ri has associated
arity ri. A quantiﬁer Q is a class of τ-structures closed under isomorphism. Let
σ be another signature. Given σ-formulas i(xi, z) with |xi| = ri (i ≤k), the
syntax Qx1, . . . , xn(1, . . . , k) has the following meaning on a σ-structure
A:
(A, a) |= Qx1, . . . , xk(1, . . . , k) iff (A; A
1 (·, a), . . . , A
k (·, a)) ∈Q,
where A(·, a) is the relation deﬁned in A by  with parameters a. The arity
of a quantiﬁer is the maximum of the ris. A quantiﬁer is n-ary if its arity is at
most n.
The extension of ﬁrst-order logic by a collection Q of generalised quantiﬁers
will be denoted FO[Q].
Examples 1.4.2
(i) The unary quantiﬁer {(A; X) | ∅̸= X ⊂A} is ‘there
exists’.
(ii) The unary quantiﬁer ‘there exist inﬁnitely many’, written ∃∞, is the
class of structures (A; X) where X is an inﬁnite subset of A.
(iii) The unary modulo quantiﬁer ‘there are k modulo m many’ (here 0 ≤
k < m), written ∃(k,m), is the class of structures (A; X) where X contains
k modulo m many elements. Write ∃mod for the collection of modulo
quantiﬁers.
(iv) The unary H¨artig quantiﬁer is the class of structures (A; P, Q) where
P, Q ⊂A and |P | = |Q|.
(v) Every set C ⊂(N ∪{∞})n induces the unary cardinality quantiﬁer QC =
{(A; P1, . . . , Pn) | (|P1|, . . . , |Pn|) ∈C}. In fact, a given unary quantiﬁer
over signature (Ri)i≤k is identical to some cardinality quantiﬁers with
n = 2k.
(vi) The binary reachability quantiﬁer is the class of structures of the form
(A; E, {cs}, {cf }) where E ⊂A2, cs, cf ∈A, and there is a path in the
directed graph (A; E) from cs to cf .
(vii) The k-ary Ramsey quantiﬁer ∃k-ram is the class of structures (A; E), E ⊂
Ak, for which there is an inﬁnite X ⊂A such that for all pairwise distinct
x1, . . . , xk ∈X, E(x1, . . . , xk).
The following general deﬁnition will allow us to compare the expressive
strength of quantiﬁers.

44
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Deﬁnition 1.4.3
Let Q be a quantiﬁer, Q a collection of quantiﬁers, and τ the
signature of Q. Say that Q is deﬁnable in Q if there is a sentence θ over the
signature τ in the logic FO[Q] with Q = {A | A |= θ}.
For instance, a structure (A; X) satisﬁes ∃(0,2)z X(z) ∨∃(1,2)z X(z) if and
only if X is ﬁnite. Hence ∃∞is deﬁnable in {∃(0,2), ∃(1,2)}.
Of course the generalised quantiﬁers that interest us most are the ones, like
∀and ∃, that preserve regularity.
Deﬁnition
1.4.4
Fix
class
C
as
one
of
S-AutStr,
T-AutStr,
ωS-AutStr, or T-AutStr. Let Q be a quantiﬁer with signature τ = (Ri)i≤k,
where Ri has associated arity ri. Say that quantiﬁer Q preserves regularity for
the class C if for every n ∈N, and every automatic presentation µ of a structure
A ∈C, every formula
Qx1, . . . , xk(A
1 (x1, z), . . . , A
k (xk, z))
deﬁnes a relation R in A with µ−1(R) regular (here z = (z1, . . . , zn) and the
i are ﬁrst-order A-formulas).
Say that Q preserves regularity effectively if an automaton for µ−1(R)
can effectively be constructed from the automata of the presentation and the
formulas i.
Since not every structure is injectively presentable, we may restrict this
deﬁnition to the class C of injectively presentable structures from ωS-AutStr
(or ωT-AutStr). For this, replace ‘automatic presentation’ with ‘injective
automatic presentation’ in the above deﬁnition.
Example 1.4.5
The reachability quantiﬁer is not regularity preserving (for
any of the classes). For otherwise, by Example 1.3.13, the set of starting
conﬁgurations that drive a given Turing Machine to a halting state would be
regular, and hence computable.
The ﬁrst steps have been taken in exploring those quantiﬁers that preserve
regularity.
Theorem 1.4.6
Let C be any of the following classes of structures
inj-ωT-AutStr, ωS-AutStr, T-AutStr, S-AutStr.
(i) The following unary quantiﬁers preserve regularity effectively for C: ∃∞,
∃mod, ∃≤ℵ0, ∃>ℵ0 [20, 90, 94, 85, 9].
(ii) Every unary quantiﬁer that preserves regularity for the class S-AutStr
is already deﬁnable from ∃mod, ∃∞[125].

Automata-based presentations of inﬁnite structures
45
The second item also implies that every unary quantiﬁer that preserves
regularity for the class inj-ωS-AutStr is already deﬁnable from ∃mod, ∃∞,
∃≤ℵ0, ∃>ℵ0. This is because for an ω-regular relation R(x, z) the cardinality
of the set R(−, c) (for any ﬁxed parameter c) is ﬁnite, countable or has size
continuum [94].
Theorem 1.4.7 (see [125])
Each k-ary Ramsey quantiﬁer preserves regularity
effectively for the class S-AutStr.
Kuske and Lohrey observed that the proof of this theorem can be generalised
to quantiﬁers of the form ‘there exists an inﬁnite set X satisfying θ’, where θ is
a property of sets closed under taking subsets. They use this to show that certain
problems, while 1
1-complete for recursive graphs, are decidable on automatic
graphs [96].
Order-invariance
Deﬁnition 1.4.8
Fix a signature τ and a new symbol ≤. A formula φ(x) in the
signature τ ∪{≤} is called order invariant on a τ-structure A if for all tuples
a from A and all linear orders ≤1 and ≤2 on A, we have that (A, ≤1) |= φ(a)
if and only if (A, ≤2) |= φ(a). The relation deﬁned by the order invariant φ in
A is the set of tuples a from A such that (A, ≤) |= φ(a) for some (and hence
all) linear orders ≤on A.
The Fundamental Theorem can be extended on injective presentations to
include order-invariant formulas in those cases where there is a regular linear
ordering of the set f −1(A). On ﬁnite-words, ﬁnite-trees and ω-words there
are regular linear orderings. However, we do not know if there is a regular
linear ordering on the set of all ω-trees. On the other hand, certain separating
examples from ﬁnite model theory are adaptable to the automatic world.
Proposition 1.4.9 ([5])
There exists a structure B ∈S-AutStr and an
order-invariant deﬁnable relation S∗in B that is not deﬁnable in B using any
extension of FO with only unary quantiﬁers.
1.4.2 Complexity of some problems
First-order theories
By Theorem 1.3.4 query-evaluation and model-checking for ﬁrst-order formu-
las are effective on automatic structures. However, the complexity of these
problems is in general non-elementary, i.e. it exceeds any ﬁxed number of iter-
ations of the exponential function. For instance the ﬁrst-order theories of the

46
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Structure-Complexitya 
Expression-Complexity
Model-Checking
0
Logspace-complete
Alogtime-complete
0 + func
Nlogspace
in quadratic time16
and Ptime-complete
1
Ptime17
Pspace-complete
(ExpTime-c. for T-AutStr)
2 
Pspace-complete17 
ExpSpace-complete
(2ExpTime-c. for T-AutStr)
Query-Evaluation
0
Logspace
Pspace
1
Pspace
Expspace
Figure 1.3 Complexity of fragments of FO on automatic structures
a Structure complexity is measured in terms of the size of the largest deterministic
automaton in the input presentation.
universal structures Nk and S[k] (k ≥2) have non-elementary complexity [77]
(cf. also the remark after Example 1.4.39).
There are various sensible ways of measuring model-checking complexity.
First, one may ﬁx a formula and ask how the complexity depends on the
input structure. This measure is called structure complexity. On the other hand,
expression complexity is deﬁned relative to a ﬁxed structure in terms of the
length of the formula. Finally, one can look at the combined complexity where
both parts may vary.
In [25] Blumensath and Gr¨adel studied the expression and structure com-
plexity of model-checking and query evaluation for quantiﬁer-free and exis-
tential ﬁrst-order formulas both in a relational signature and allowing terms in
quantiﬁer-free formulas. Their results are complemented by those of Kuske and
Lohrey [95] on the expression complexity of 1 (existential) and 2 formulas
of a relational signature over arbitrary word- and tree-automatic structures.
Figure 1.3 provides a summary.
On certain subclasses of automatic structures there is better complexity. In
section 1.3.7 above we have mentioned that the ﬁrst-order theory of each
structure allowing a word-automatic presentation of polynomial density is
16 This is a generalisation of the quadratic solution of the word problem in automatic groups [31]
(see Section 1.4.5).
17 Model checking with a ﬁxed 1 formula reduces to a membership or non-emptiness test for an
NFA. For ﬁxed 2 formulas the problem is polynomially equivalent to the universality
problem of NFAs, and thus Pspace-complete. (We thank Anthony To for pointing out the error
in [25].)

Automata-based presentations of inﬁnite structures
47
decidable in Pspace. Kuske and Lohrey [101, 95] studied automatic struc-
tures whose Gaifman graphs are of bounded degree. Relying on locality of
ﬁrst-order logic they have identiﬁed the expression complexity of FO model
checking on word-automatic and tree-automatic structures of bounded degree
to be 2ExpSpace-complete and 3ExpTime-complete, respectively. The com-
bined complexity remains 2ExpSpace for word-automatic presentations and
is in 4ExpTime for tree-automatic presentations. For ﬁner results we refer
to [95].
Beyond ﬁrst-order
A fundamental problem in veriﬁcation is deciding reachability: whether there is
a path between speciﬁed source and target nodes. Since the conﬁguration space
of an arbitrary Turing machine is ﬁnite-word automatic, the halting problem
can be reduced to the reachability problem on the conﬁguration graph of a
universal Turing-machine. Similar reductions show the undecidability, over
(ﬁnite-word) automatic structures, of connectivity, isomorphism, bisimulation
and hamiltonicity [25, 96].
On the other hand there are natural classes of automatic structures for
which these problems become decidable (see Figure 1.1). For instance, VRA-
equational graphs have a decidable FO-theory with reachability and are
ﬁnite-tree automatic. Reachability and connectivity in locally-ﬁnite unary-
automatic graphs are in fact decidable in Ptime. Bisimulation equiva-
lence of HR-equational graphs of ﬁnite out-degree is decidable [128] (see
section 1.2.2).
Finally we mention some cases where full MSO is decidable. Preﬁx recog-
nisable structures (which include the unary automatic structures) are ﬁnite-
word automatic. A structure of the form (N, <, C1, . . . , Ck) is called a colour-
ing of the line. Every known ﬁnite-word automatic colouring of the line, and
this includes every morphic sequence, has decidable MSO-theory (cf. The-
orem 1.4.38 and see [7]). Furthermore, every word-automatic equivalence
relation has a decidable MSO-theory. This follows from the above and the
observation (Proposition 1.4.40) that if there are only ﬁnitely many inﬁnite
classes then the equivalence relation is FO-deﬁnable in some word-automatic
colouring of the line [7].
Isomorphism problem
A measure of the complexity of a class of structures is the isomorphism problem,
namely the problem of deciding, given two □-automatic presentations d and
d′, whether or not the structures they present are isomorphic.

48
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
The characterisations of the ﬁnite-word automatic Boolean algebras and
ordinals [88, 63] imply that the isomorphism problem for each of these classes
is decidable. Also, as noted, the isomorphism problem for equational graphs is
decidable 1.2.10.
Conﬁguration spaces of Turing machines are locally ﬁnite and the com-
plexity of the isomorphism problem for locally-ﬁnite directed graphs in
S-AutStr is 0
3-complete [124]. However, by massaging the conﬁguration
spaces we get that the isomorphism problem for automatic graphs is as hard
as possible: 1
1-complete. This is done by reducing the isomorphism prob-
lem for computable structures, known to be 1
1-complete, to that of automatic
structures.
Theorem 1.4.10 ([124])
The complexity of the isomorphism problem for each
of the following classes of S-AutStr structures is 1
1-complete: (i) undirected
graphs, (ii) directed graphs, (iii) successor trees, and (iv) lattices of height 4.
Problem 1.4.11
What is the exact complexity of the isomorphism problem
for the following classes:18
(i) Automatic equivalence structures (easily seen to be 0
1).
(ii) Automatic linear orders.
Traces
Inﬁnite edge-labelled graphs, when viewed as inﬁnite automata, can accept non-
regular languages. Naturally, context-free graphs accept precisely the context-
free languages. Though preﬁx-recognisable graphs form a structurally much
richer class they have the same language accepting power as context-free
graphs (cf. Theorem 1.2.11 items (1) and (6)). Graphs in the Caucal hier-
archy have the same accepting power as higher-order pushdown automata
(see Theorem 1.2.16) tracing languages on the corresponding levels of the OI-
hierarchy of [62]. The traces of GTRS-graphs form a language class in between
the context-free and context-sensitive classes of the Chomsky hierarchy [99].
Rational graphs accept precisely the context-sensitive languages [108]. All
context-sensitive languages can in fact be accepted by word-automatic graphs
[123], cf. also [35] for a more accessible proof and ﬁner analysis. Meyer proved
that the traces of tree-automatic graphs are those languages recognisable in
Etime, i.e. in 2O(n) time [103].
18 While this work has been in print, Kuske, Liu and Lohrey have greatly contributed to settling
these and related questions. We refer to their forthcoming paper.

Automata-based presentations of inﬁnite structures
49
1.4.3 Non-automaticity via pumping and counting
It is usually quite simple to show that a structure has an automatic presentation
(if indeed it does have one!). On the other hand, there are only a handful of ele-
mentary techniques for showing that a structure has no automatic presentation.
Most rely on the pumping lemma of automata theory.
Sometimes we can provide a full characterisation of classes of automatic
structures. The ﬁrst non-trivial characterisation was for the word-automatic
ordinals (in the signature of order).
Theorem 1.4.12 (Delhomm´e [63])
(i) An ordinal α is in S-AutStr if, and only if, α < ωω.
(ii) An ordinal α is in T-AutStr if, and only if, α < ωωω.
A relation R is (n + m) locally ﬁnite if for every (x1, . . . , xn) there are only
ﬁnitely many (y1, . . . , ym) such that R(x, y) holds. Obviously, every functional
relation f (x) = y is locally ﬁnite. Other examples of locally ﬁnite relations are
equal-length el, length comparison |y| < |x|, and the preﬁx relation y ≺prefix
x. Note that local ﬁniteness depends on the partitioning of the variables, e.g.
x ≺prefix y is not locally ﬁnite.
A simple pumping argument gives the following important tool.
Proposition 1.4.13 (Elgot and Mezei [66])
Let R ⊆(∗)n+m be a regular
and locally ﬁnite relation. Then there is a constant k such that for all x, y
satisfying R, maxj|yj| ≤maxi|xi| + k. In particular, if f is a regular function
then there is a constant k such that for every x in its domain we have |f (x)| ≤
maxi|xi| + k.
Growth of generations
Consider a structure A with functions F = {f1, . . . , fs} and a sequence E =
{e0, e1, e2, . . .} of elements of A. The generations of E with respect to F are
deﬁned recursively as follows.
G0
F(E)
= {e0}
Gn+1
F (E) = Gn
F(E)  {en+1}
 {f (a) | f ∈F , ai ∈Gn
F(E) for each i ≤|a|}
We are interested in how fast |Gn
F(E)| grows as a function of n.
Example 1.4.14
(i) Free semigroup on m generators: here F = {·} and E =
{e1, . . . , em}. For m ≥2, since Gm
F(E) ⊃E, the set Gm+n
F
(E) includes all
strings over E of length at most 2n; thus the cardinality of Gm+n
F
(E) is at
least a double exponential in n.

50
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
(ii) If p : D × D →D is injective then for F = {p} and E = {e1, e2} (distinct
elements of D) |Gn
F(E)| is at least a double exponential.
We now iterate Proposition 1.4.13.
Proposition 1.4.15 ([87], [20, 25])
Let A ∈S-AutStr and consider an
injective presentation d with naming function f . Let F be a ﬁnite set of functions
FO-deﬁnable in A and E = {e0, e1, . . .} a deﬁnable set of elements ordered
according to length in d, i.e. |f −1(e0)| ≤|f −1(e1)| ≤· · · . Then there is a
constant k such that for every n and for every a ∈Gn
F |f −1(a)| ≤kn. In
particular, |Gn
F| = 2O(n).
In other words, the number of elements that can be generated using functions
is at most a single exponential in the number of iterations. Continuing the
previous examples, neither the free semigroup nor any bijection f : D × D →
D (also called a pairing function) is word-automatic. It is trickier to apply the
proposition to show that Skolem arithmetic (N, ×) is not word-automatic (see
[20, 25]). It is nevertheless tree-automatic, cf. Example 1.3.9.
The application of propositions 1.4.13 and 1.4.15 has been pushed to their
limits:
Proposition 1.4.16
(i) If a group (G, ·) is word-automatic then every
ﬁnitely generated subgroup is virtually Abelian (has an Abelian subgroup
of ﬁnite index). In particular, a ﬁnitely generated group is in S-AutStr
if, and only if, it is virtually Abelian [116, 114].
(ii) A Boolean Algebra (in the signature (∪, ∩, ·c, ⊥, ⊤)) is in S-AutStr if,
and only if, it is ﬁnite or a ﬁnite power of the Boolean Algebra of ﬁnite or
co-ﬁnite subsets of N [88]. In particular, the countable atomless Boolean
Algebra is not in S-AutStr.
(iii) There is no inﬁnite integral domain in S-AutStr [88].
(iv) No word-automatic structure (D, R) has a subset N ⊂D such that (N, R)
is isomorphic to (N, ·), cf. [114].
The proof of the ﬁrst item starts with the observation that every ﬁnitely-
generated group G ∈S-AutStr has polynomial density - that is, for every
ﬁnite set A = {a1, . . . , ak} the function
γ (n) = |{

i<n
cσi
i | ∀i < n : ci ∈A, σi ∈{1, −1}}|
is bounded by a polynomial (this exploits associativity of the group operation).
The rest of the proof uses powerful theorems of Gromov and Ershov (see [114]
for a survey of word-automatic groups).

Automata-based presentations of inﬁnite structures
51
Number of deﬁnable subsets
Various countable random structures, such as the random graph, do not have
word- or tree-automatic presentations [88, 63]. The approach to proving these
facts has a model-theoretic ﬂavour: for a purported automatic presentation, it
involves counting the number of deﬁnable subsets of elements represented by
words of bounded length.
Consider the usual deﬁnition of a set deﬁned by ϕ with parameter b that
remains ﬁxed:
ϕ(−, b)A = {a ∈A | A |= ϕ(a, b)} .
A ﬁnite set X ⊂A is fully shattered by ϕ if the cardinality of the family
{ϕ(−, b)A ∩X | b ∈A}
is as large as possible, namely 2|X|. For instance, Benedikt et al. [16] observe
that in S[2] each of the sets {0, 00, . . . , 0n} can be fully shattered by the formula
ϕ(x, b) = ∃z(suc1z ≺prefix b ∧el(z, x)).
By contrast, in every automatic presentation with naming function f and
domain D ⊆∗, the image under f of each D≤n := D ∩≤n can only be
linearly shattered by deﬁnable families.
Proposition 1.4.17 ([88, 63])
In every automatic presentation of a structure
A with naming function f and for every formula ϕ:
|{ϕ(−, b)A ∩f (D≤n) | b ∈A}| = O(|f (D≤n)|) .
As an application recall that the random graph is characterised by the prop-
erty that for every partition of a ﬁnite set X of vertices into sets U and V , there
is a vertex b connected to all elements of U and to no element of V . In other
words, every ﬁnite set X of vertices is fully shattered by the edge relation as
the parameter b is varied. So by Proposition 1.4.17 the random graph has no
word-automatic presentation. Similar reasoning yields the following.
Proposition 1.4.18 ([88, 63])
The following are not in S-AutStr: the ran-
dom graph, the random partial order, the random Kn-free graph.
Using Theorem 1.3.25 one can established non-automaticity of the random
graph in a far more general sense.
Theorem 1.4.19 ([47])
Neither the random graph nor the the free monoid on
two generators is ﬁnite-tree automatic with any oracle.
In fact neither is ω-word automatic with any oracle, as witnessed by the
following theorem which follows from the proof of Theorem 1.3.31.

52
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Theorem 1.4.20
If a countable structure is ω-word automatic with oracle,
then it is also ﬁnite-word automatic with (the same) oracle.
1.4.4 Comparing presentations
When we think of an automatic structure we frequently have a particular
automatic presentation in mind. Some structures have canonical presenta-
tions. For instance, (a∗, <len) is arguably the canonical presentation of (N, <)
and ({0, 1}∗, suc0, suc1, ≺prefix, el) is the canonical presentation of itself.
Some well-known structures have natural presentations, none of which can
be indisputably called canonical. The base k ∈N (k > 1) presentations of
(N, +) can be considered equally natural; but then what about the Fibonacci
numeration system? The ﬁeld of regular numeration systems, though using a
somewhat different terminology, investigates automatic presentations of (N, +)
and ω-word automatic presentations of (R, +). Finally, there are pathological
presentations that are used to pin down the relationship between deﬁnability in
a structure and regularity in its presentations [90].
How are we to compare different automatic presentations of the same struc-
ture? What are the crucial aspects of a presentation that distinguish it from
others?
Canonical representations of context-free graphs were investigated by
S´enizergues. In [127] a p-structure for a graph G is a PDA A (having no
ϵ-transitions) together with an isomorphism between the conﬁguration graph
of A and G. Furthermore, a p-structure for G is P-canonical if the distance
in G between a vertex v and the root is equal to the stack height of the con-
ﬁguration representing v (cf. [112]’s notion of a canonical automaton for a
context-free graph; and [41, 44]). For a ﬁxed graph G S´enizergues considers
two p-structures equivalent if there is a rational isomorphism between them,
and shows that every equivalence class of p-structures contains a P-canonical
one [127].
An example from the theory of numeration systems is provided by the
celebrated result of Cobham and Semenov. Recall that naturals p and q are
called multiplicatively independent if they have no common power (ie. pk ̸= ql
for all k, l ≥1) and multiplicatively dependent otherwise.
Theorem 1.4.21 (Cobham-Semenov19, cf. [26, 19, 109])
The following dichotomy holds for p, q ≥2.
19 Cobham proved it for sets; Semenov later extended it to arbitrary relations.

Automata-based presentations of inﬁnite structures
53
(i) If p and q are multiplicatively dependent then a relation R ⊆Nr is regular
when coded in base p iff it is regular when coded in base q.
(ii) If p and q are multiplicatively independent then a relation R ⊆Nr is
regular in both base p and base q iff R is FO-deﬁnable in (N, +).
The meaning of (i) is that, for instance, bases 2l and 2k are expressively
equivalent. There is a very simple coding translating numerals between these
bases, which bijectively maps blocks of k digits in the ﬁrst system to blocks
of l digits in the second system. Every pair of multiplicatively dependent
numeration systems are linked by similar translations.
According to (ii) the base 2k presentation is as different as it can be from,
say, the base 3 presentation. This point is further stressed by the following
result of B´es based on the work of Michaux and Villemaire.
Theorem 1.4.22 ([18])
Let p and q be multiplicatively independent, and
R ⊆Nr regular when coded in base q, but not ﬁrst-order deﬁnable in (N, +).
Then the ﬁrst-order theory of (N, +, |p, R) is undecidable.
On a similar note we introduce the following general notions.
Deﬁnition 1.4.23 (Subsumption and equivalence)
Consider two □-automatic presentations of some structure A with naming
functions f and g, respectively. We say that f subsumes g (g ≼f ) if for
every relation R over the domain of A, if g−1(R) is □-regular then f −1(R) is
□-regular. If both f ≼g and g ≼f then we say that the two presentations are
equivalent and write f ∼g. Moreover, we say that a □-automatic presentation
of A is prime if it is subsumed by all other □-automatic presentations of A.
Word-automatic presentations
The deﬁnition of equivalence of automatic presentations is modelled on case
(i) of Theorem 1.4.21. In [5] it has been shown that two ﬁnite-word auto-
matic presentations are equivalent if and only if the transduction translating
names of elements from one presentation to the other is computable by a semi-
synchronous transducer: a two-tape ﬁnite automaton processing its ﬁrst tape
in blocks of k letters and its second tape in blocks of l letters for some ﬁxed
positive k and l. (Note that, except in trivial cases, k/l is uniquely determined
[5].)
Theorem 1.4.24 ([5])
Two ﬁnite-word automatic presentations of some
A ∈S-AutStr with naming functions fi : Di →A, i ∈{1, 2}, are equiva-
lent if, and only if, the transduction T = {(x, y) ∈D1 × D2 | f1(x) = f2(y)}

54
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
translating names of elements from one presentation to the other is semi-
synchronous rational.
Corollary 1.4.25
Let f1 and f2 be naming functions of equivalent automatic
presentations of A. Then there is a constant C such that for every n-ary relation
R over dom(A) and for every automaton A1 recognising f −1
1 (R) there is an
automaton A2 of size |A2| ≤Cn · |A1| recognising f −1
2 (R), and vice versa.
Let U be one of the universal ﬁnite-word automatic structures S (for || >
1), Pf (1), or (N, +, |k) (for k > 1). Using semi-synchronous translations one
can establish the following.
Theorem 1.4.26 ([5, 6])
The universal structure U has only a single word-
automatic presentation up to equivalence.
The assertion of the theorem can be reformulated as follows.
Corollary 1.4.27
For a relation R, the expansion (U, R) is in S-AutStr if,
and only if, R is FO-deﬁnable in U.
The prime presentation of a structure, if one exists, is unique up to equiva-
lence, hence may as well be called canonical. The unary presentation of (N, <)
is a prime word-automatic presentation. It is, however, not a prime presentation
of (N, suc), which allows, for every m > 1 a word-automatic presentation in
which divisibility by m is not regular [90]. It can be inferred that (N, suc) has
no prime presentation.
Recall Theorem 1.3.27 stating that each word-automatic presentation, of
structure A, over a domain of polynomial density of degree d directly cor-
responds to a d-dimensional interpretation of A in the structure M = (N, <,
{≡(mod m)}m>1), and hence also in (N, +). So every p-automatic structure has
inﬁnitely many pairwise incomparable word-automatic presentations ‘inher-
ited’ from (N, +), namely, based on different numeration systems.
In fact, M allows a non-trivial 2-dimensional interpretation in itself. Simply
consider the lexicographic ordering of all pairs (n1, n2) such that n1 ≥n2 as
an interpretation of (N, <) and observe that moduli of positions within the
lexicographic ordering of tuples can be expressed in terms of moduli of their
components. Thus, by composing interpretations, every p-automatic presen-
tation of M is properly subsumed by other p-automatic presentations with
domains of asymptotically greater polynomial densities. This carries over to
all p-automatic structures.
In contrast, from results of [5, 8] it follows that g ≼f implies g ∼f for
any two word-automatic presentations of a given structure, provided that either

Automata-based presentations of inﬁnite structures
55
both f and g have domains of exponential density, or both have a domain of
polynomial density of the same degree.
Therefore, the height of the partial order of word-automatic presentations of
A under subsumption and modulo equivalence is ω if A is p-automatic and 1 if A
is not p-automatic. It is not known whether the width of the subsumption order
modulo equivalence is always one or inﬁnite for word-automatic structures that
are not p-automatic.
Tree-automatic presentations
Colcombet and L¨oding [47] investigated the power of ﬁnite-subset interpre-
tations applied to arbitrary trees. In our terminology these are tree-automatic
presentations with arbitrary oracles.
In the tree-automatic model the analogue of Theorem 1.4.26 does not hold.
A tree-automatic presentation of Pf (2) incomparable with the natural one can
be forged simply by ‘folding each tree in half about the vertical axis’, i.e. taking
the mirror image of the subtree below the right child of the root and smoothly
combing it together with the untouched left half, e.g. as in Example 1.3.11(iii).
Despite this, the fact concerning primality of the natural presentation of the
universal structure holds in an even stronger sense.
Proposition 1.4.28 ([47, Lemma 5.6])
The natural tree-automatic presenta-
tion with oracle O and with the identity naming function of the ﬁnite-subset
envelope Pf (TO) of the oracle tree TO is a prime presentation with respect to
tree-automatic presentations with arbitrary oracle.
In particular, ‘the’ word-automatic presentation of Pf (1) and the natu-
ral tree-automatic presentation of Pf (2) are both prime even among tree-
automatic presentations with arbitrary oracles. This is complemented by the
following result of [47].
Theorem 1.4.29
All tree-automatic presentations of Pf (1) are equivalent.
Therefore, the same holds true for all of the universal structures from The-
orem 1.4.26.
1.4.5 Other notions of automaticity
Speciﬁc automatic presentations have been employed in other mathematical
ﬁelds: computational group theory [31], symbolic dynamics [13], numeration
systems (of integers or reals) [76], and inﬁnite sequences represented in natural
numeration systems [2, 26, 4]. In this section we survey natural presentations

56
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
k
1
Figure 1.4 k-fellow traveler property.
of certain structures that have mostly been considered independently of the
general theory of automatic structures.
Automatic groups
Thurston (1986) motivated by work of Cannon on hyperbolic groups introduced
the notion of automatic groups. A ﬁnitely generated group G is automatic in
this sense if for some set of semigroup generators S and associated canonical
homomorphism f : S∗→G
(i) there is a regular language W ⊂S∗so that f restricted to W is surjective,
(ii) for every s a generator from S or the group identity, the following binary
relation over W is regular:
{(u, v) | f (u) = f (v)s} .
This is in fact an algebraic notion: it does not depend on the particular choice
of generators. From the automata presenting the group one can extract a ﬁnite
presentation of the group, and a quadratic-time algorithm deciding the word
problem.
Proposition 1.4.30 (k-fellow traveler property)
A group G with semigroup
generators S = {s1, . . . , sr} is automatic if, and only if, there exists a regular
set W ⊆S∗and k ∈N such that f |W is surjective and W satisﬁes the k-fellow
traveler property:
∀u, v ∈W with d(u, v) ≤1 ∀i ≤max{|u|, |v|} : d(u1 . . . ui, v1 . . . vi) ≤k
where d(u, v) denotes the length of the shortest path between u and v in the
Cayley graph of G with generators S.
Virtually Abelian groups and Gromov’s word hyperbolic groups constitute
important examples of automatic groups in this sense. Major results of this
programme are presented in [31] (see also the introductions by Farb [71] and
by Choffrut [46]).

Automata-based presentations of inﬁnite structures
57
More recently, this notion has been extended to semigroups [29, 30, 84, 28]
and monoids [83, 129, 102].
Let us compare the following three notions: (i) groups whose multiplication
function admits a word-automatic presentation, (ii) ﬁnitely generated automatic
groups, and (iii) ﬁnitely generated groups with a Cayley graph admitting a word-
automatic presentation. It is known [116] that a ﬁnitely generated group allows
a word-automatic presentation of type (i) iff it is virtually Abelian. All virtually
Abelian ﬁnitely generated groups are automatic in the sense of this subsection.
Hence (i) implies (ii) for ﬁnitely generated groups. Furthermore, by deﬁnition,
the Cayley graph of every automatic group has a word-automatic presentation.
Hence (ii) implies (iii), but the converse fails. As S´enizergues has pointed out
the Heisenberg group is not automatic even though its Cayley graph has an
automatic presentation. For further reading we recommend the survey by Nies
[114].
Generalised numeration systems
The theory of generalised numeration systems [76] is concerned with repre-
sentations of N and R in various bases and using different (possibly negative)
digits. In general, the basis U0 < U1 < U2 < . . . of the system does not have to
be the sequence of powers of a natural. One considers bases satisfying appro-
priate linear recursions, or alternatively powers of a base β which is the greatest
root of a polynomial of a certain type. The study of generalised numeration
systems goes back to R´enyi who in 1957 introduced β-expansions.
Without going into the particulars of this very rich ﬁeld we point out that a
number may have more than one representation in a given numeration system.
Thus from a practical perspective one is interested in normalised numerals
obtained via the greedy algorithm. Normalised numerals are ordered according
to <llex (length and then lexicographically, most signiﬁcant digit ﬁrst). A regular
set of (normalised) numerals N ⊆[d]∗over the set of digits 0, . . . , d −1 is
simply an automatic copy of (N, <) of the form (N, <llex).
A fundamental question in this context asks under which circumstances
addition can be computed by a synchronous ﬁnite automaton. When this is the
case one speaks of a regular numeration system. On this matter we refer to [76]
and the references therein.
Example 1.4.31
The Fibonacci numeration system is a prominent example
of a regular numeration system. It has the Fibonacci numbers 1, 2, 3, 5, 8, . . .
as its basis, and the binary digit set. The normalised numerals delivered by the
greedy algorithm are ε, 1, 10, 100, 101, 1000, 1001, 1010, 10000, 10001, . . .
in the length-lexicographic ordering. They are the binary strings avoiding 11 as

58
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
a factor since greedy normalisation prefers 100 to 11. Naturally, 10n represents
the nth Fibonacci number.
More generally we ask how can one classify the word-automatic presen-
tations of (N, +)? Or those of (N, <)? Below we survey known classes of
automatic presentations of expansions of (N, <) by unary predicates, i.e. inﬁ-
nite sequences.
Automatic sequences
The theory of automatic sequences [2] studies ω-words representable in more-
or-less standard numeration systems. Presentations of primary concern are
those of base k ∈N, or of base −k, and possibly involving negative digits.
Deﬁnition 1.4.32
A sequence s : N → is k-automatic if for every a ∈
the set Na of numerals in the standard base k numeration system representing
all positions n such that s(n) = a constitutes a regular language.
These k-automatic sequences have been characterised in both algebraic and
logical terms. In order to formulate another characterisation some notions are
required. A morphism ϕ : 
∗→∗is said to be k-uniform if |ϕ(a)| = k for
each a ∈
. Codings are 1-uniform morphisms. A morphism ϕ : 
∗→
∗is
prolongable on some a ∈
 if a is the ﬁrst symbol of ϕ(a). In this case the
sequence (ϕn(a))n∈N converges to either a ﬁnite or inﬁnite word, which is a
ﬁxed point of ϕ, denoted ϕω(a).
Theorem 1.4.33 ([26, 2])
For any sequence s : N → the following are
equivalent:
(1) s is k-automatic;
(2) the k-kernel of s: {(snkm+r)n | r, m ∈N, r < km} is ﬁnite;
(3) the sets s−1(a) are FO-deﬁnable in (N, +, |k) for each a ∈;
(4) s = σ(τ ω(a)) for some k-uniform morphism τ on some 
∗and a coding
σ : 
 →;
(5) (assuming k is a prime and  ⊆{0, . . . , k −1}): the formal power series
S(x) = 	
n snxn ∈Fk[[x]] is algebraic over Fk[x].
For example, consider the morphism τ : 0 →01, 1 →10. Its ﬁxed point
τ ω(0) is the Thue-Morse sequence t = 01101001100101101001 . . .. This is a
truly remarkable sequence bearing a number of characterisations and combi-
natorial properties [3]. For instance, its nth digit is 1 if, and only if, the binary
numeral of n contains an odd number of 1’s. The 2-kernel of t is {t, t}, where
t is obtained from t by ﬂipping every bit.

Automata-based presentations of inﬁnite structures
59
Morphic words
One obtains a deﬁnition of morphic words by relaxing characterisation (4) of
the above theorem. Morphic words thus constitute a generalisation of auto-
matic sequences. They and their relatives have been extensively studied in the
context of formal language theory, Lindenmayer systems and combinatorics on
words.
Deﬁnition 1.4.34
Morphic words are those of the form σ(τ ω(a)) for arbitrary
homomorphism τ prolongable on a and arbitrary homomorphism σ : 
∗→∗
extended to ω-words in the obvious way.
Example 1.4.35
Consider τ : a →ab, b →ccb, c →c and σ : a, b →
1, c →0 both homomorphically extended to {a, b, c}∗. The ﬁxed point of
τ starting with a is the word abccbccccbc6b . . ., and its image under σ,
11001041061081 . . ., is the characteristic sequence of the set of squares. In
general, for every strictly positive N-rational sequence (sk) the characteristic
sequence of the set {	n
k=0 sk | n ∈N} is morphic [38]. This result also follows
from Proposition 1.4.37.
While k-automatic sequences allow automatic presentations over the set of
standard base k numerals, the above example suggests that morphic words
may need generalised numeration systems. Indeed, every morphic word is
automatically presentable in the following sense.
Consider a ﬁnite ordered alphabet 
 = {a1 < a2 < . . . < ar}. In the induced
length-lexicographic order, denoted <llex, words over 
 are ordered according
to their length ﬁrst, while words of the same length are ordered lexicograph-
ically. Thus (D, <llex) provides an automatic presentation of (N, <) for every
inﬁnite regular language D over 
. Base k as well as so called generalised
numeration systems are special cases of this scheme. The following notion thus
generalises Deﬁnition 1.4.32.
Deﬁnition 1.4.36
We say that an ω-word w : N → is length-lexico-
graphically presentable if there is an automatic presentation (D, <llex) of (N, <)
with naming function f : D →N such that the sets f −1(w−1(a)) are regular
for each a ∈.
It is not hard to see that an ω-word is length-lexicographically presentable if
and only if it is morphic. There is a perfectly natural correspondence between
the morphisms generating a word and the automaton recognising the set of
‘numerals’, which, when length-lexicographically ordered, give an automatic
presentation of the morphic word.

60
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
Proposition 1.4.37 ([122])
An ω-word w is length-lexicographically pre-
sentable if, and only if, w is morphic.
We illustrate the transformation from one formalism to the other on the char-
acteristic sequence of squares from Example 1.4.35. Recall that it is generated
by the following morphism τ and ﬁnal substitution σ
τ :
a →ab
b →ccb
c →c
σ :
a →1
b →1
c →0
The idea is to interpret symbols {a, b, c, 0, 1} as states. Without loss of gener-
ality, the alphabets of the ranges of σ and τ are disjoint. The alphabet 
 of the
automatic presentation consists of digits ranging from 0 to |τ| + |σ| −1, where
|τ| is the maximum of |τ(x)| with x ∈{a, b, c} and |σ| is deﬁned similarly.
Letters of the alphabet, ordered as usual, are used to index positions within the
right-hand side of a τ-rule, or, when larger, positions inside the right-hand side
of a substitution via σ.
 a
0

1

3

b
2

0,1 
3

c
0

3

1
0
The domain D of the presentation is recognised by the above automaton with
both 1 and 0 as ﬁnal states. With only 1 as a terminal state, the automaton recog-
nises the numerals representing a square relative to the length-lexicographic
enumeration of D. Starting with a deterministic automaton this transformation
can be reversed producing a morphism τ representing the transition function
linearised according to the ordering on the alphabet and with σ identiﬁed by
the terminal states.
The MSO-theory of the structure (N, <, (w−1(a))a) for morphic w is decid-
able [38]. Moreover, the class of morphic words is closed under MSO-deﬁnable
recolourings, i.e. under deterministic generalised sequential mappings [118].
These results are generalised by the following one, which can be seen as an
extension of the Fundamental Theorem 1.3.4.
Theorem 1.4.38 ([7])
Let d = (D, <llex, P) be a length-lexicographic pre-
sentation of a morphic word w and let ϕ(x) be an MSO[<, P]-formula having
only ﬁrst-order variables free. Then there is an automaton A, computable from
d and ϕ and such that (d, A) is a word-automatic presentation of w expanded
by the relation deﬁned by ϕ.

Automata-based presentations of inﬁnite structures
61
Caucal has shown that morphic sequences can be constructed as graphs
on the second level of the pushdown hierarchy (cf. Deﬁnition 1.2.14) [43].
However, there are automatically presentable ω-words on higher levels as well.
Higher-order morphic words
Higher-order morphic words were introduced in [4, 7]. Morphic words of
order k can be deﬁned either in the style of Deﬁnition 1.4.34 based on a notion
of ‘morphisms of order-k stacks’ or similar rules, or as in Deﬁnition 1.4.36
as those having an automatic presentation using the ‘k-fold nested length-
lexicographic order’ induced by an ordered alphabet. Theorem 1.4.38 extends
to these automatic presentations of higher-order morphic words. The classes of
order k morphic words form an inﬁnite hierarchy, and are constructible on the
2k-th level of the pushdown hierarchy [7].
Example 1.4.39
As an example we mention the Champernowne word (cf.
Example 1.3.23) obtained by concatenating decimal numerals in their usual
order:
C = 1234567891011121314 . . .
It is on the second level of this hierarchy (and on the fourth level of the
pushdown hierarchy). Consider the level 2 morphism  given by the following
intuitive production rules
Sx →SxAτ1(x) . . . Aτ9(x)
Ax →Aτ0(x)Aτ1(x) . . . Aτ9(x)
where each τi is a (level 1) morphism of words in the usual sense mapping each
digit d ∈{0, . . . , 9} to d and # to i#. Applying  repeatedly to the initial level
2 stack S# yields the following converging sequence
S# →S#A1#A2# . . . A9#
→S#A1#A2# . . . A9#A10# . . . A19# · · · · · · A90# . . . A99#
→· · ·
Hence C can be speciﬁed as C = σ(ω(S#)) with the morphism σ erasing all
#’s while preserving the other (level 1) symbols.
To give a word-automatic presentation we take the domain D to be comprised
of all words of the form d1m1d2m2 . . . dsms with d1d2 . . . ds a conventional dec-
imal numeral and m1m2 . . . ms = oixos−i−1 a marker indexing the ith digit of
this numeral. Elements of the domain are ordered using the length-lexicographic
ordering in a nested fashion: comparing numerals (i.e. odd positions) ﬁrst, and
then according to the position of the marker x.

62
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
The Champernowne word contains every ﬁnite word over {0, 1, . . . , 9} as a
factor. The satisﬁability problem of ﬁrst-order logic on ﬁnite words, known to
be non-elementary [79], is thus expressible in the FO theory of the Champer-
nowne word, which is therefore also non-elementary. For the same reason the
Champernowne word is not morphic. Every morphic word is MSO-deﬁnable
in the Champernowne word, and every word-automatic equivalence structure
having only ﬁnitely many inﬁnite equivalence classes is interpretable in a
second-order morphic word [7].
Proposition 1.4.40
Consider A = (A, E) with E an equivalence relation
having, for each n > 0, f (n) ∈N many equivalence classes of size n, and no
inﬁnite classes. Then A ∈S-AutStr if, and only if, there is a second-order
morphic word w = 0m010m110m21 . . . such that f (n) = |{i | mi = n}|.
It remains open whether the decidability and deﬁnability results for MSO
hold for all word-automatic inﬁnite sequences. We are intrigued whether the
isomorphism problem of automatic ω-words, or more broadly for automatic
scattered linear orders, is decidable. Already for morphic words this is a noto-
rious long-standing open problem.
1.5 Automatic Model Theory
We may reformulate the original problem – we seek a class of ﬁnitely-
presentable structures C that has an interesting model theory and lies somewhere
between the ﬁnite structures (ﬁnite model theory) and all structures (classical
model theory).
The richest and oldest class consists of the computable structures – these
are structures whose domain and atomic relations are computable by Turing
machines [70]. In computable model theory, a common theme is to take classical
results from mathematics and model theory and to see to what extent they can
be made effective. Here are two illustrative observations:
(i) A computable (consistent) ﬁrst-order theory has a computable model.
Indeed, Henkin’s construction can be seen as an algorithm computing the
domain and atomic relations.
(ii) Every two computable presentations of the rational ordering (Q, <) are
computably isomorphic. Again, the standard back-and-forth argument can
be seen as an algorithm building the isomorphism.
The program of feasible mathematics in the 1980’s included the development
of polynomial-time model theory [45]. However, every relational computable

Automata-based presentations of inﬁnite structures
63
structure is isomorphic (in fact computably isomorphic) to a polynomial-time
structure. Automatic structures can be seen as a further restriction of this class,
and in fact this is the motivation in [87]. In this section we discuss some aspects
of the model theory of automatic structures, a subject still in its infancy.
We split our discussion along two lines: model theory of the class
S-AutStr, and model theory of the particular universal structure S[2] (cf.
Theorem 1.3.17).
1.5.1 Model theory restricted to the class of
word-automatic structures
Blumensath shows that, as expected, certain notions of model theory fail when
restricted to the class of automatic structures.
Proposition 1.5.1
(i) It is undecidable whether an FO-formula has a word-
automatic model.
(ii) The following properties fail on the class of word automatic structures:
compactness, Beth, Interpolation, and Łos-Tarski.
The proofs are based on the observation that there is a FO formula which has
automatic models of every ﬁnite cardinality but no inﬁnite automatic models.
L¨owenheim-Skolem
An automatic version of the Downward L¨owenheim-Skolem Theorem would
say that every uncountable ω-automatic structure has a countable elementary
substructure that is also ω-automatic. Unfortunately this is false since there is
a ﬁrst-order theory with an ω-automatic model but no countable ω-automatic
model. Indeed, consider the ﬁrst-order theory of atomless Boolean Algebras.
Kuske and Lohrey [94] have observed that it has an uncountable ω-automatic
model (namely the algebra from Example 1.3.12.iv). However, Khoussainov
et al. [88] show that the countable atomless Boolean algebra is not automatic
and so, by Theorem 1.4.20, not ω-automatic either.
Here is the closest we can get to an automatic Downward L¨owenheim-
Skolem Theorem for ω-automatic structures.
Proposition 1.5.2 ([85])
Let (D, ≈, {Ri}i≤ω) be an omega-automatic presen-
tation of A and let Aup be its restriction to the ultimately periodic words of D.
Then Aup is a countable elementary substructure of A.
Proof. Relying on the Tarski-Vaught criterion for elementary substructures
we only need to show that for all ﬁrst-order formulas ϕ(x, y) and elements

64
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
b of Aup
A |= ∃yϕ(b, y)
⇒
Aup |= ∃yϕ(b, y) .
By Theorem 1.3.4 ϕ(x, y) deﬁnes an omega-regular relation and, similarly,
since the parameters b are all ultimately periodic the set deﬁned by ϕ(b, y) is
omega-regular. Therefore, if it is non-empty, then it also contains an ultimately
periodic word, which is precisely what we needed.
◁
An identical proposition, also independently noted by Khoussainov and
Nies, holds for A ∈ωT-AutStr with regular trees in place of ultimately
periodic words.
Consider the natural, say, binary ω-automatic presentation of (R, +). Its
restriction to the set of elements represented by ultimately periodic ω-words
is isomorphic to the additive group of the rationals (Q, +). Tsankov [136] has
shown that there is no automatic divisible torsion-free Abelian group (DTAG).
Hence the theory of DTAGs is another example of a ﬁrst-order theory having
an uncountable ω-automatic model but no countable (ω-)automatic models.
Automatic theorems
K ˝onig’s Lemma
K ˝onig’s Lemma says that an inﬁnite ﬁnitely-branching tree has an inﬁnite path.
We split our discussion of automatic analogues along two lines, depending on
whether the signature is that of partial order (T, ⪯) or successor (T, S).
Theorem 1.5.3 ([91])
If T = (T, ⪯) is an automatic copy of an inﬁnite
ﬁnitely-branching tree, then T has a regular inﬁnite path. That is, there exists
a regular set P ⊆T where P is an inﬁnite path of T .
Proof. Deﬁne a set P as those elements x such that ∃∞w[x ≺w] and for which
every y ≺x satisﬁes that
∀z, z′ ∈S(y)[z ⪯x ⇒z ≤llex z′].
Then P is the length-lexicographically least inﬁnite path of T (in the ordering
induced by the ﬁnite strings presenting the tree).
◁
However, using the 2-Ramsey quantiﬁer we can do more.
Theorem 1.5.4 ([91])
If T = (T, ⪯) is an automatic copy of a tree with
countably many inﬁnite paths, then every inﬁnite path is regular.
Proof. Denote by E(T ) ⊆T the set of elements of a tree T that are on inﬁnite
paths. It is deﬁnable in T using the 2-Ramsey quantiﬁer, so Theorem 1.4.7
gives that E(T ) is regular. Then every isolated path of T is regular, since it is

Automata-based presentations of inﬁnite structures
65
deﬁnable as {x ∈E(T ) | p ⪯x} ∪{x ∈E(T ) | x ≺p}, for suitable p ∈E(T ).
Replace T by its derivative d(T ), which is also automatically presentable. Since
the CB-rank of T is ﬁnite [91] and dCB(T )(T ) is the empty tree, every inﬁnite
path is deﬁned in this way.
◁
However, automatic successor trees behave more like computable trees:
Theorem 1.5.5 ([96])
The problem of deciding, given automata presenting a
successor tree (T, S), whether or not it has an inﬁnite path, is 1
1-complete.
The proof consists of a reduction from the problem of whether a non-
deterministic Turing machine visits a designated state inﬁnitely often.
We compare with the computable case.20 Fix the computable presentation
of the full binary tree as consisting of the ﬁnite binary sequences with the
immediate successor relation (so in fact the preﬁx relation is also computable).
To stress this presentation, we refer to the tree as 2ω. Similarly ﬁx a natural
computable presentation ωω of the ω-branching tree. A computable subtree of
either of these trees is a computable preﬁx-closed subset.
(i) There is an inﬁnite computable subtree of 2ω with no computable inﬁnite
path.
(ii) There is a computable subtree of ωω with exactly one inﬁnite path, and
this path is not computable.
(iii) The set of indices of computable subtrees of the binary tree 2ω with at
least one inﬁnite path is 0
2-complete.
(iv) The set of indices of computable subtrees of ωω with at least one inﬁnite
path 1
1-complete.
Cantor’s Theorems
One of Cantor’s theorems says that every countable linear ordering embeds in
the rational ordering Q. The standard proof is easily seen to be effective given
a computable presentation of (Q, <).
There are potentially a variety of automatic versions. The following propo-
sition is the best known.
Proposition 1.5.6
[93] Every automatic copy M of a linear order can be
embedded into some automatic copy of Q by a function f : M →Q with the
following properties:
(i) The function f is continuous with respect to the order topology.
(ii) The graph of f is regular.
20 Thanks to Frank Stephan for discussions concerning this case.

66
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
It is not known whether there is a single automatic copy of Q that embeds,
in the sense above, all automatic copies of all automatically presentable linear
orders M.
Cantor also proved that Q is homogeneous: For every two tuples x1 < · · · <
xm and y1 < · · · < ym there is an automorphism f : Q →Q with f (xi) = yi
for i ≤m. Again there might be a number of automatic variations. Call an
automatic copy of Q automatically homogeneous if for every two tuples there
is an automorphism as above that is also regular.
Proposition 1.5.7
[93] There is an automatic copy of Q that is automati-
cally homogeneous. There is an automatic copy of Q that is not automatically
homogeneous.
Scott ranks
Every countable structure A has a sentence of the inﬁnitary logic Lω1,ω (it
allows, in addition to FO, countable disjuncts but still only ﬁnitely many free
variables) that characterises A up to isomorphism. The Scott rank of A is the
minimal quantiﬁer rank amongst all such sentences.
Theorem 1.5.8 ([86])
For every computable ordinal there is an automatic
structure of Scott Rank at least α.
The idea is to massage the conﬁguration space of Turing machines presenting
a computable structure (having Scott Rank α) to get an automatic structure of
similar rank.
1.5.2 On the universal word-automatic structure
We conclude by highlighting some model-theoretic properties of the universal
structure S[2].
(i) S[2] has inﬁnite VC-dimension [15]. That is, there is a formula φ(x, z) that
deﬁnes a family of sets of the form φ(−, z)S[2] as one varies the parameter
z, and this family fully shatters arbitrarily large ﬁnite sets.
(ii) S[2] admits quantiﬁer elimination (QE) in the expansion of all deﬁnable
unary predicates and binary functions. In fact, no expansion with deﬁnable
unary functions (and arbitrary predicates) admits QE [15].
Blumensath [20, p. 67] raised the question of whether there are non-standard
models of the theory of the universal structure S[2] in S-AutStr. Here we
sketch an argument resting on Theorem 1.4.26 that shows that there are no

Automata-based presentations of inﬁnite structures
67
word-automatic non-standard models. This result was obtained in discussions
with Bakhadyr Khoussainov.
Theorem 1.5.9
S[2] is the only word-automatic model of its theory.
Proof. Assume, for a contradiction, an automatic presentation of a non-
standard elementary extension of S[2]. By ‘component’ we mean a maximal
set of elements connected by successor relations. Every elementary extension
of S[2] consists of the standard component isomorphic to S[2] (containing the
root), and any number of non-standard components, that are, as unlabelled
graphs, all isomorphic to one-another. The non-standard components are
distinguished by the inﬁnite sequences of 0-1 successors ascending towards
the root.
(0) The set of representatives of elements of each component is regular.
Indeed, the equivalence relation of belonging to the same component is
FO + ∃∞-deﬁnable in the model (by saying that there is a common ancestor
having ﬁnite distance from both elements), hence regular in the representation.
(1) There is a non-standard element below every standard node.
This follows from the fact that the formula
∀x, x′, y : el(x, x′) ∧x ≺y →∃y′ : el(y, y′) ∧x′ ≺y′
being true in S[2] must also hold in every non-standard model.
Combining observation (0) and Theorem 1.4.26 we may assume that the
presentation restricted to the standard component is the natural one having
the identity as naming function. The binary ω-sequence naturally associated
with an inﬁnite branch of the standard component provides a representation of
the set of nodes along that branch consistent with the assumed presentation
of the model. Denote by  the set of paths with a non-standard element below
them.
(2) The set  is ω-regular.
Indeed, a B¨uchi-automaton is built to guess a ﬁnite word representing a non-
standard element and to check, using the automata of the assumed presentation,
that it is a descendant of all ﬁnite preﬁxes of the input path. Given that our
model is countable, hence so is , we have the following consequence of
claim (2).

68
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
(3) Every path in  is ultimately periodic with a period of bounded length.
To close the circle, consider for each n ∈N the sentence
∀x∃y |y| > |x| ∧0n1⪯prefix y ∧(∀z ≺prefix y)[end1(z) →z0n1 ⪯prefix y]
where end1(z) is shorthand for saying that the last letter of z is 1. This sentence
expresses that for every length |x| there is a longer word y with as many initial
preﬁxes in (0n1)∗as possible. In particular this sentence holds for non-standard
elements x. Consequently,
(4) for every n ∈N there is an inﬁnite branch of the standard component with
label (0n1)ω and having non-standard elements below it.
This contradicts observation (3).
◁
Therefore, by Theorem 1.4.20, there are no countable ω-word automatic
non-standard models either. Furthermore, using Theorem 1.4.29 in place of
Theorem 1.4.26 in the argument shows there are no non-standard ﬁnite-tree
automatic models of S[2]. To prove that there are no uncountable ω-word
automatic non-standard models of S[2] one tightens (4) and exploits that all
automatic presentations of non-standard components are equivalent.

References
[1] K. Aehlig, J. G. de Miranda, and C.-H. L. Ong. Safety is not a restriction at level
2 for string languages. In FoSSaCS, pages 490–504, 2005.
[2] J.-P. Allouche and J. Shallit. Automatic Sequences, Theory, Applications, Gener-
alizations. Cambridge University Press, 2003.
[3] J.-P. Allouche and J. O. Shallit. The Ubiquitous Prouhet-Thue-Morse Sequence.
In C. Ding, T. Helleseth, and H. Niederreiter, editors, Sequences and
Their Applications: Proceedings of SETA ’98, pages 1–16. Springer-Verlag,
1999.
[4] V. B´ar´any. A hierarchy of automatic ω-words having a decidable MSO theory.
Journ´ees Montoises ’06, Rennes, 2006.
[5] V. B´ar´any. Invariants of automatic presentations and semi-synchronous transduc-
tions. In STACS ’06, volume 3884 of LNCS, pages 289–300, 2006.
[6] V. B´ar´any. Automatic Presentations of Inﬁnite Structures. Phd thesis, RWTH
Aachen University, 2007.
[7] V. B´ar´any. A hierarchy of automatic ω-words having a decidable MSO
theory. R.A.I.R.O. Theoretical Informatics and Applications, 42:417–450,
2008.
[8] V. B´ar´any. Semi-synchronous transductions. Acta Informatica, 46(1):29–42,
2009.
[9] V. B´ar´any, Ł. Kaiser, and A. Rabinovich. Eliminating cardinality quantiﬁers from
MLO. Manuscript, 2007.
[10] V. B´ar´any, Ch. L¨oding, and O. Serre. Regularity problems for visibly pushdown
languages. In STACS ’06, volume 3884 of LNCS, pages 420–431, 2006.
[11] K. Barthelmann. On equational simple graphs. Tech. Rep. 9, Universit¨at Mainz,
Institute f¨ur Informatik, 1997.
[12] K. Barthelmann. When can an equational simple graph be generated by hyperedge
replacement? In MFCS, pages 543–552, 1998.
[13] M.-P. B´eal and D. Perrin. Symbolic Dynamics and Finite Automata. In A. Salo-
maa and G. Rosenberg, editors, Handbook of Formal Languages, Vol. 2, pages
463–503. Springer Verlag, 1997.
[14] M. Benedikt and L. Libkin. Tree extension algebras: logics, automata, and query
languages. In Proceedings of the 17th Annual IEEE Symposium on Logic in
Computer Science (LICS), pages 203–212, 2002.
69

70
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
[15] M. Benedikt, L. Libkin, Th. Schwentick, and L. Segouﬁn. A model-theoretic
approach to regular string relations. In Joseph Halpern, editor, LICS 2001,
pages 431–440. IEEE Computer Society, June 2001.
[16] M. Benedikt, L. Libkin, Th. Schwentick, and L. Segouﬁn. Deﬁnable relations
and ﬁrst-order query languages over strings. J. ACM, 50(5):694–751, 2003.
[17] D. Berwanger and A. Blumensath. The monadic theory of tree-like structures.
In E. Gr¨adel, W. Thomas, and T. Wilke, editors, Automata, Logics, and Inﬁnite
Games, number 2500 in LNCS, chapter 16, pages 285–301. Springer Verlag,
2002.
[18] A. B`es. Undecidable extensions of B¨uchi arithmetic and Cobham-Sem¨enov the-
orem. Journal of Symbolic Logic, 62(4):1280–1296, 1997.
[19] A. B`es. An Extension of the Cobham-Sem¨enov Theorem. J. of Symb. Logic,
65(1):201–211, 2000.
[20] A. Blumensath. Automatic Structures. Diploma thesis, RWTH-Aachen, 1999.
[21] A. Blumensath. Preﬁx-Recognisable Graphs and Monadic Second-Order Logic.
Technical report AIB-2001-06, RWTH Aachen, 2001.
[22] A. Blumensath. Axiomatising Tree-interpretable Structures. In STACS, volume
2285 of LNCS, pages 596–607. Springer-Verlag, 2002.
[23] A. Blumensath, Th. Colcombet, and Ch. L¨oding. Logical theories and compatible
operations. In J. Flum, E. Gr¨adel, and T. Wilke, editors, Logic and Automata:
History and Perspectives, Texts in Logic and Games, pages 73–106. Amsterdam
University Press, 2007.
[24] A. Blumensath and E. Gr¨adel. Automatic structures. In LICS 2000, pages 51–62.
IEEE Computer Society, 2000.
[25] A. Blumensath and E. Gr¨adel. Finite presentations of inﬁnite structures: Automata
and interpretations. Theory of Comp. Sys., 37:641–674, 2004.
[26] V. Bruy`ere, G. Hansel, Ch. Michaux, and R. Villemaire. Logic and p-recognizable
sets of integers. Bull. Belg. Math. Soc., 1:191–238, 1994.
[27] J. R. B¨uchi. Weak second-order arithmetic and ﬁnite automata. Zeit. Math. Logih
Grund. Math., 6:66–92, 1960.
[28] A. J. Cain, E. F. Robertson, and N. Ruskuc. Subsemigroups of groups: presenta-
tions, malcev presentations, and automatic structures. Journal of Group Theory,
9(3):397–426, 2006.
[29] C. M. Campbell, E. F. Robertson, N. Ruskuc, and R. M. Thomas. Automatic
semigroups. Theor. Comput. Sci., 250(1–2):365–391, (2001).
[30] C. M. Campbell, E. F. Robertson, N. Ruskuc, and R. M. Thomas. Automatic
completely-simple semigroups. Acta Math. Hungar., 96:201–215, 2002.
[31] J.W. Cannon, D.B.A. Epstein, D.F. Holt, S.V.F. Levy, M.S. Paterson, and W.P.
Thurston. Word processing in groups. Jones and Barlett Publ., Boston, MA,
1992.
[32] A. Carayol. Regular sets of higher-order pushdown stacks. In Proceedings of
Mathematical Foundations of Computer Science (MFCS 2005), volume 3618 of
LNCS, pages 168–179, 2005.
[33] A. Carayol and Th. Colcombet. On equivalent representations of inﬁnite struc-
tures. In ICALP, volume 2719 of LNCS, pages 599–610. Springer, 2003.
[34] A. Carayol and A. Meyer. Linearly bounded inﬁnite graphs. In MFCS, volume
3618 of Lecture Notes in Computer Science, pages 180–191. Springer, 2005.

Automata-based presentations of inﬁnite structures
71
[35] A. Carayol and A. Meyer. Context-Sensitive Languages, Rational Graphs and
Determinism. Logical Methods in Computer Science, 2(2), 2006.
[36] A. Carayol and C. Morvan. On rational trees. In Z. ´Esik, editor, CSL 06, volume
4207 of LNCS, pages 225–239, 2006.
[37] A. Carayol and S. W¨ohrle. The Caucal hierarchy of inﬁnite graphs in terms of
logic and higher-order pushdown automata. In FSTTCS, volume 2914 of LNCS,
pages 112–123. Springer, 2003.
[38] O. Carton and W. Thomas. The monadic theory of morphic inﬁnite words and
generalizations. Information and Computation, 176(1):51–65, 2002.
[39] A. Caryol and Ch. L¨oding. MSO on the Inﬁnite Binary Tree: Choice and Order.
In CSL, volume 4646 of LNCS, pages 161–176, 2007.
[40] D. Caucal. Monadic theory of term rewritings. In LICS, pages 266–273. IEEE
Computer Society, 1992.
[41] D. Caucal. On the regular structure of preﬁx rewriting. Theor. Comput. Sci.,
106(1):61–86, 1992.
[42] D. Caucal. On inﬁnite transition graphs having a decidable monadic theory. In
ICALP’96, volume 1099 of LNCS, pages 194–205, 1996.
[43] D. Caucal. On inﬁnite terms having a decidable monadic theory. In MFCS, pages
165–176, 2002.
[44] D. Caucal. Deterministic graph grammars. In J. Flum, E. Gr¨adel, and T. Wilke,
editors, Logic and Automata: History and Perspectives, Texts in Logic and
Games, pages 169–250. Amsterdam University Press, 2007.
[45] D. Cenzer and J. B. Remmel. Complexity-theoretic model theory and algebra. In
Handbook of Recursive Mathematics, Vol. 1, volume 138 of Studies in Logic and
the Foundations of Mathematics, pages 381–513. North-Holland, Amsterdam,
1998.
[46] Ch. Choffrut. A short introduction to automatic group theory, 2002.
[47] T. Colcombet and C. L¨oding. Transforming structures by set interpretations.
Logical Methods in Computer Science, 3(2), 2007.
[48] Th. Colcombet. On families of graphs having a decidable ﬁrst order theory with
reachability. In ICALP, volume 2380 of LNCS, pages 98–109. Springer, 2002.
[49] Th. Colcombet. Equational presentations of tree-automatic structures. In Work-
shop on Automata, Structures and Logic, Auckland, NZ, 2004.
[50] Th. Colcombet. Propri´et´es et repr´esentation de structures inﬁnies. Th`ese de
doctorat, Universit´e Rennes I, 2004.
[51] Th. Colcombet. A combinatorial theorem for trees. In ICALP, volume 4596 of
LNCS, pages 901–912. Springer, 2007.
[52] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and
M. Tommasi. Tree Automata Techniques and Applications. In preparation, draft
available online at http://www.grappa.univ-lille3.fr/tata/.
[53] B. Courcelle. Graph algebras and monadic second-order logic. Cambridge Uni-
versity Press, in writing...
[54] B. Courcelle. The deﬁnability of equational graphs in monadic second-order
logic. In ICALP, volume 372 of LNCS, pages 207–221. Springer, 1989.
[55] B. Courcelle. Graph rewriting: An algebraic and logic approach. In J. van
Leeuwen, editor, Handbook of Theoretical Computer Science, Volume B: Formal
Models and Sematics, pages 193–242. Elsevier and MIT Press, 1990.

72
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
[56] B. Courcelle. Recursive applicative program schemes. In J. v.d. Leeuwen, editor,
Handbook of Theoretical Computer Science, Vol. B, pages 459–492. Elsevier and
MIT Press, 1990.
[57] B. Courcelle. The monadic second-order logic of graphs ix: Machines and their
behaviours. Theoretical Computer Science, 151(1):125–162, 1995.
[58] B. Courcelle. Finite model theory, universal algebra and graph grammars. In LFCS
’97, Proceedings of the 4th International Symposium on Logical Foundations of
Computer Science, pages 53–55, London, UK, 1997. Springer-Verlag.
[59] B. Courcelle. The Expression of Graph Properties and Graph Transformations
in Monadic Second-Order Logic. In G. Rozenberg, editor, Handbook of graph
grammars and computing by graph transformations, vol. 1: Foundations, pages
313–400. World Scientiﬁc, New-Jersey, London, 1997.
[60] B. Courcelle and J. A. Makowsky. Fusion in Relational Structures and the Veri-
ﬁcation of Monadic Second-Order Properties. Mathematical Structures in Com-
puter Science, 12(2):203–235, 2002.
[61] B. Courcelle and I. Walukiewicz. Monadic second-order logic, graph coverings
and unfoldings of transition systems. Annals of Pure and Applied Logic, 92:35–
62, 1998.
[62] W. Damm. The IO- and OI hierarchies. Theoretical Computer Science, 20(2):95–
208, 1982.
[63] C. Delhomm´e. Automaticit´e des ordinaux et des graphes homog`enes. Comptes
Rendus Mathematique, 339(1):5–10, 2004.
[64] M. J. Dunwoody. The accessibility of ﬁnitely presented groups. Inventiones Math-
ematicae, 81(3):449–457, 1985.
[65] S. Eilenberg, C. C. Elgot, and J.C. Shepherdson. Sets recognised by n–tape
automata. Journal of Algebra, 13(4):447–464, 1969.
[66] C. C. Elgot and J. E. Mezei. On relations deﬁned by generalized ﬁnite automata.
IBM J. Research and Development, 9:47–68, 1965.
[67] C. C. Elgot and M. O. Rabin. Decidability and undecidability of extensions of
second (ﬁrst) order theory of (generalized) successor. Journal of Symbolic Logic,
31(2):169–181, 1966.
[68] C. C. Elgot. Decision problems of ﬁnite automata design and related arithmetics.
Trans. Amer. Math. Soc., 98:21–51, 1961.
[69] J. Engelfriet. Context-free graph grammars. In Handbook of formal languages,
vol. III, pages 125–213. Springer-Verlag New York, Inc., New York, NY, USA,
1997.
[70] Y. L. Ershov, S. S. Goncharov, A. Nerode, and J. B. Remmel, editors. Hand-
book of Recursive Mathematics, Vol. 1, volume 138 of Studies in Logic and the
Foundations of Mathematics. North-Holland, Amsterdam, 1998.
[71] B. Farb. Automatic Groups: A Guided Tour. L’Enseignment Math., 38:291–313,
1992.
[72] S. Fratani. Automates `a Piles de Piles ... de Piles. Th`ese de doctorat, Universit´e
Bordeaux 1, 2005.
[73] S. Fratani. Regular sets over tree structures. Rapport Interne 1358-05, LaBRI,
Universit´e Paris 7, 2005.
[74] S. Fratani. The theory of successor extended by several predicates. Journ´ees
Montoises ’06, Rennes, 2006.

Automata-based presentations of inﬁnite structures
73
[75] S. Fratani and G. S´enizergues. Iterated pushdown automata and sequences of
rational numbers. Ann. Pure Appl. Logic, 141(3):363–411, 2006.
[76] Ch. Frougny. Numeration systems. In M. Lothaire, editor, Algebraic Combina-
torics on Words. Cambridge University Press, 2002.
[77] E. Gr¨adel. Simple interpretations among complicated theories. Information Pro-
cessing Letters, 35:235–238, 1990.
[78] E. Gr¨adel, P. G. Kolaitis, L. Libkin, M. Marx, J. Spencer, M. Vardi, Y. Venema,
and S. Weinstein. Finite Model Theory and Its Applications. Springer-Verlag,
2007.
[79] E. Gr¨adel, W. Thomas, and T. Wilke, editors. Automata, Logics, and Inﬁnite
Games, volume 2500 of LNCS. Springer-Verlag, 2002.
[80] A. Habel. Hyperedge Replacement: Grammars and Languages, volume 643 of
Lecture Notes in Computer Science. Springer, 1992.
[81] M. Hague, A. S. Murawski, C.-H. L. Ong, and O. Serre. Collapsible pushdown
automata and recursion schemes. In LICS’08. IEEE Computer Society, 2008.
[82] G. Hjorth, B. Khoussainov, A. Montalb´an, and A. Nies. From automatic structures
to Borel structures. In 23rd Symposium on Logic in Computer Science (LICS),
2008.
[83] M. Hoffmann, D. Kuske, F. Otto, and R. M. Thomas. Some relatives of automatic
and hyperbolic groups, 2002.
[84] M. Hoffmann and R. M. Thomas. Notions of automaticity in semigroups. Semi-
group Forum, 66:337–367 (2003).
[85] Ł. Kaiser, S. Rubin, and V. B´ar´any. Cardinality and counting quantiﬁers on
ω-automatic structures. In STACS ’08, volume 08001 of Dagstuhl Seminar Pro-
ceedings, pages 385–396. Internationales Begegnungs- und Forschungszentrum
fuer Informatik (IBFI), Schloss Dagstuhl, Germany, 2008.
[86] B. Khoussainov and M. Minnes. Model theoretic complexity of automatic struc-
tures. Annals of Pure and Applied Logic, To appear, 2008.
[87] B. Khoussainov and A. Nerode. Automatic presentations of structures. In LCC
’94, volume 960 of LNCS, pages 367–392. Springer-Verlag, 1995.
[88] B. Khoussainov, A. Nies, S. Rubin, and F. Stephan. Automatic structures: Rich-
ness and limitations. In LICS’04, pages 44–53, 2004.
[89] B. Khoussainov and S. Rubin. Graphs with automatic presentations over a unary
alphabet. Journal of Automata, Languages and Combinatorics, 6(4):467–480,
2001.
[90] B. Khoussainov, S. Rubin, and F. Stephan. Deﬁnability and regularity in automatic
structures. In STACS ’04, volume 2996 of LNCS, pages 440–451, 2004.
[91] B. Khoussainov, S. Rubin, and F. Stephan. Automatic linear orders and trees.
ACM Transactions on Computational Logic, 6(4):675–700, 2005.
[92] T. Knapik, D. Niwinski, and P. Urzyczyn. Higher-order pushdown trees are easy.
In FoSSaCS’02, volume 2303 of LNCS, pages 205–222, 2002.
[93] D. Kuske. Is Cantor’s theorem automatic? In LPAR, volume 2850 of LNCS, pages
332–345. Springer, 2003.
[94] D. Kuske and M. Lohrey. First-order and counting theories of ω-automatic struc-
tures. In FoSSaCS, pages 322–336, 2006.
[95] D. Kuske and M. Lohrey. Automatic structures of bounded degree revisited.
arXiv:0810.4998, 2008.

74
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
[96] D. Kuske and M. Lohrey. Hamiltonicity of automatic graphs. In FIP TCS 2008,
2008.
[97] H. Lauchli and Ch. Savioz. Monadic Second Order Deﬁnable Relations on the
Binary Tree. J. of Symbolic Logic, 52(1):219–226, 1987.
[98] S. Lifsches and S. Shelah. Uniformization and skolem functions in the class of
trees. Journal of Symbolic Logic, 63:103–127, 1998.
[99] Ch. L¨oding. Inﬁnite Graphs Generated by Tree Rewriting. Doctoral thesis, RWTH
Aachen, 2003.
[100] Christof L¨oding. Reachability problems on regular ground tree rewriting graphs.
Theor. Comp. Sys., 39(2):347–383, 2006.
[101] M. Lohrey. Automatic structures of bounded degree. In LPAR, volume 2850 of
LNCS, pages 346–360. Springer, 2003.
[102] M. Lohrey. Decidability and complexity in automatic monoids. In Developments
in Language Theory, pages 308–320, 2004.
[103] A. Meyer. Traces of term-automatic graphs. R.A.I.R.O. Theoretical Informatics
and Applications, 42, 2008.
[104] C. Michaux and F. Point. Les ensembles k-reconnaissables sont d´eﬁnissables
dans ⟨N, +, Vk⟩. C. R. Acad. Sci. Paris S´er. I Math., 303(19):939–942, 1986.
[105] Ch. Morvan. Les graphes rationnels. Th`ese de doctorat, Universit´e de Rennes 1,
Novembre 2001.
[106] Ch. Morvan. Classes of rational graphs. Journ´ees Montoises ’06, Rennes, 2006.
[107] Ch. Morvan and Ch. Rispal. Families of automata characterizing context-sensitive
languages. Acta Informatica, 41(4-5):293–314, 2005.
[108] Ch. Morvan and C. Stirling. Rational graphs trace context-sensitive languages. In
A. Pultr and J. Sgall, editors, MFCS 01, volume 2136 of LNCS, pages 548–559,
2001.
[109] A. A. Muchnik. The deﬁnable criterion for deﬁnability in Presburger arithmetic
and its applications. Theor. Comput. Sci., 290(3):1433–1444, 2003.
[110] D. E. Muller and P. E. Schupp. Context-free languages, groups, the theory of
ends, second-order logic, tiling problems, cellular automata, and vector addition
systems. Bull. Amer. Math. Soc., 4(3):331–334, 1981.
[111] D. E. Muller and P. E. Schupp. Groups, the theory of ends, and context-free
languages. J. Comput. Syst. Sci., 26(3):295–310, 1983.
[112] D. E. Muller and P. E. Schupp. The theory of ends, pushdown automata, and
second-order logic. Theor. Comput. Sci., 37:51–75, 1985.
[113] A. A. Nabebin. Expressibility in a restricted second-order arithmetic. Siberian
Mathematical Journal, 18(4):588–593, 1977.
[114] A. Nies. Describing groups. Bulletin of Symbolic Logic, 13(3):305–339,
2007.
[115] D. Niwi´nski. On the cardinality of sets of inﬁnite trees recognizable by ﬁnite
automata. In Proceedings of the 16th International Symposium on Mathemati-
cal Foundations of Computer Science, MFCS’91, volume 520, pages 367–376.
Springer, 1991.
[116] G. P. Oliver and R. M. Thomas. Finitely generated groups with automatic pre-
sentations. In STACS 2005, volume 3404 of LNCS, pages 693–704. Springer,
2005.

Automata-based presentations of inﬁnite structures
75
[117] C.-H. L. Ong. On model-checking trees generated by higher-order recursion
schemes. In LICS, pages 81–90. IEEE Computer Society, 2006.
[118] J.-J. Pansiot. On various classes of inﬁnite words obtained by iterated mappings.
In Automata on Inﬁnite Words, pages 188–197, 1984.
[119] A. Rabinovich. On decidability of monadic logic of order over the naturals
extended by monadic predicates. Unpublished note, 2005.
[120] A. Rabinovich and W. Thomas. Decidable theories of the ordering of natural
numbers with unary predicates. Submitted, 2006.
[121] M. Rigo. Numeration systems on a regular language: Arithmetic operations,
recognizability and formal power series. Theoretical Computer Science, 269:469,
2001.
[122] M. Rigo and A. Maes. More on generalized automatic sequences. J. of Automata,
Languages and Combinatorics, 7(3):351–376, 2002.
[123] Ch. Rispal. The synchronized graphs trace the context-sensistive languages. Elec-
tronic Notes in Theor. Comp. Sci., 68(6), 2002.
[124] S. Rubin. Automatic Structures. Phd thesis, University of Auckland, NZ,
2004.
[125] S. Rubin. Automata presenting structures: A survey of the ﬁnite-string case.
Bulletin of Symbolic Logic, 14(2):169–209, 2008.
[126] A. L. Semenov. Decidability of monadic theories. In Mathematical Foundations of
Computer Science, Prague, 1984, volume 176 of LNCS, page 162?175. Springer,
Berlin, 1984.
[127] G. S´enizergues. Semi-groups acting on context-free graphs. In ICALP ’96: Pro-
ceedings of the 23rd International Colloquium on Automata, Languages and
Programming, pages 206–218, London, UK, 1996. Springer-Verlag.
[128] G. S´enizergues. The bisimulation problem for equational graphs of ﬁnite out-
degree. SIAM J. Comput., 34(5):1025–1106, 2005.
[129] P. V. Silva and B. Steinberg. A geometric characterization of automatic monoids.
The Quarterly Journal of Mathematics, 55:333–356, 2004.
[130] J. Su and S. Grumbach. Finitely representable databases (extended abstract. In
In Proc. 13th ACM Symp. on Principles of Database Systems, 1994.
[131] A. Szilard, Sh. Yu, K. Zhang, and J. Shallit. Characterizing regular languages
with polynomial densities. In MFCS, pages 494–503, 1992.
[132] W. Thomas. Automata on inﬁnite objects. In J. van Leeuwen, editor, Handbook
of Theoretical Computer Science, Volume B: Formal Models and Sematics, pages
133–192. Elsevier and MIT Press, 1990.
[133] W. Thomas. Languages, automata, and logic. In G. Rozenberg and A. Salomaa,
editors, Handbook of Formal Languages, volume III, pages 389–455. Springer,
New York, 1997.
[134] W. Thomas. Constructing Inﬁnite Graphs with a Decidable MSO-Theory. In
MFCS, volume 2747 of LNCS, pages 113–124, 2003.
[135] B. A. Trahtenbrot. Finite automata and the logic of one-place predicates. Russian.
Siberian Mathematical Journal, 3:103–131, 1962. English translation: American
Mathematical Society Translations, Series 2, 59 (1966), 23–55.
[136] T. Tsankov. The additive group of the rationals is not automatic. manuscript,
2009.

76
Vince B´ar´any, Erich Gr¨adel and Sasha Rubin
[137] R. Villemaire. The theory of ⟨N, +, Vk, Vl⟩is undecidable. Theoretical Computer
Science, 106:337–349, 1992.
[138] I. Walukiewicz. Monadic second-order logic on tree-like structures. Theoretical
Computer Science, 275:311–346, 2002.
[139] S. W¨ohrle and W. Thomas. Model checking synchronized products of inﬁnite
transition systems. In LICS ’04, pages 2–11, Washington, DC, USA, 2004. IEEE
Computer Society.

2
Logical aspects of spatial databases
bart kuijpersa and jan van den busscheb
2.1 Introduction
In this chapter, we consider spatial databases that are modeled as semi-algebraic
sets and we present some logic-based languages to query them. We discuss
various properties of these query languages, mainly concerning their expressive
power.
The basic query language in this context is ﬁrst-order logic over the real
numbers extended with predicates to address the spatial database relations
(Section 2.2). We discuss geometric properties that are expressible in this logic
(Section 2.3) and then focus on ﬁrst-order expressible topological properties of
2-dimensional spatial datasets. A property is called topological if it is invariant
under homeomorphisms of the ambient space. We give a characterization of
topological elementary equivalence and present a point-based language, called
cone logic that captures exactly the topological queries expressible in ﬁrst-order
logic over the reals (Section 2.4 and 2.7). Next, we present another point-based
language that captures the ﬁrst-order queries that are invariant under afﬁnities
(Section 2.6).
The second half of this chapter is devoted to extensions of ﬁrst-order logic
over the reals with some form of recursion. We brieﬂy discuss two such
extensions: spatial Datalog and ﬁrst-order logic extended with a while-loop
(Section 2.8). We discuss in more detail extensions of ﬁrst-order logic with
different types of transitive-closure operators, with or without stop-conditions
(Section 2.9) and investigate their expressive power (Section 2.10). The eval-
uation of queries expressed in transitive-closure logic with or without stop
conditions may be non-terminating. In general, termination is an undecidable
a Hasselt University, bart.kuijpers@uhasselt.be
b Hasselt University, jan.vandenbussche@uhasselt.be
77

78
Bart Kuijpers and Jan Van den Bussche
property, but we give examples of classes of transitive-closure queries where
termination is decidable (Section 2.11).
2.2 Spatial data and ﬁrst-order logic
In most general terms, a spatial dataset is any set S ⊂Rn for some n. Equiv-
alently, we can view such a set as an n-ary relation S over R (using Cartesian
coordinates). Viewing R as a structure ¯R = (R, 0, 1, +, ·, <) over the language
of ordered ﬁelds, we can then use ﬁrst-order logic to express properties of spatial
datasets.
For example, the sentence
∃a∃b∀x∀y(S(x, y) →y = a · x + b)
expresses that S ⊂R2 lies on a straight line.
Since the structure on R in this paper remains the same, we abbreviate
( ¯R, S) |= φ as S |= φ.
2.3 Capturing ﬁrst-order geometric properties
According to Felix Klein’s Erlangen Programm, a geometric theory can be
characterized by the group of transformations that preserve the fundamental
geometric properties of the theory. Some examples:
geometry
group of transformations
Euclidean
similarity
afﬁne
afﬁnity
topology
continuous
Fix such a group G of transformations of Rn, and consider some property
φ of datasets in Rn. We naturally deﬁne φ to be G-geometric if it is invariant
under G, or formally:
∀S ∀g ∈G : S |= φ ⇔g(S) |= φ
Let us see some examples:
r “S lies on a circle” is Euclidean, but not afﬁne.
r “S lies on a straight line” is afﬁne, but not topological.
r “S has dimension two” is topological.

Logical aspects of spatial databases
79
A general question, for any ﬁxed G, is: What are the G-geometric properties
expressible in ﬁrst-order logic? Can we enumerate or characterise them in some
effective way?
This can easily be done when G is ﬁrst-order parameterisable. By this we
mean that there exists an injection p : G →Rℓfor some ℓsuch that the set
{(p(g), ¯x, ¯y) | g ∈G and ¯y = g(¯x)}
is ﬁrst-order deﬁnable in ¯R.
For example, the afﬁnities in R2 are ﬁrst-order parameterised. Indeed, each
afﬁnity g corresponds to some 6-tuple p(g) = (a, b, c, d, e, f ) with

a
b
c
d
 ̸= 0
and we have (y1, y2) = g(x1, x2) iff
y1
y2

=
a
b
c
d

·
x1
x2

+
e
f

so that is all ﬁrst-order deﬁnable.
The following theorem (Gyssens et al., 1999) provides an effective char-
acterisation of the G-geometric ﬁrst-order properties, in case G is ﬁrst-order
parameterisable (by the injection p):
Theorem 2.1
A property  of sets S ⊆Rn, for some ﬁxed n, is ﬁrst-order
expressible and G-geometric if and only if (S) can be expressed by a ﬁrst-
order sentence of the form
φ ∧∀p(g) ∈p(G)[φ(S) ↔φ(g(S))]
with φ an arbitrary sentence over ( ¯R, S).
Note that the ﬁrst-order parameterisability of G guarantees that the special
form of sentence in the above theorem is indeed a ﬁrst-order sentence.
2.4 First-order topological properties of plain sets
When doing topology, we are only interested in properties that are invariant
under “continuous transformations”. More precisely, in this paper we deﬁne a
property of sets in Rn to be topological if it is invariant under all isotopies of Rn.
Clearly, the isotopies are not ﬁrst-order parameterisable, so the easy tech-
nique from the previous section does not apply.

80
Bart Kuijpers and Jan Van den Bussche
Figure 2.1 This set in the plane is closed, and is semi-algebraic, being deﬁned
by the real formula x2/25 + y2/16 = 1 ∨x2 + 4x + y2 −2y ⩽−4 ∨x2 −4x +
y2 −2y ⩽−4 ∨(x2 + y2 −2y = 8 ∧y ⩽−1).
We are still able to capture the ﬁrst-order topological properties, provided
we restrict our setting to the following:
1. We work in R2 only, i.e., sets in the real plane.
2. We consider only semi-algebraic sets: sets that are themselves deﬁnable in
R.
3. Moreover, we consider only closed sets (in the standard topological sense).
Let us call such sets “plain”. Figure 2.1 shows an example of a plain set
(Bochnak et al., 1998).
Let us see some examples of topological properties of plain sets, expressible
in ﬁrst-order logic:
r “The dimension is 0 (or 1, or 2)”.
r “There is a point where three lines intersect”.
r “There is a point where two 2-dimensional regions touch”.
We remark that the expressibility of the third property is not obvious and
uses the local conical structure of semi-algebraic sets (see later).
The following topological properties of plain sets are not expressible in
ﬁrst-order logic:
r “There is a point where an even number of lines intersect”.
r “The number of points where two 2-dimensional regions touch is even”.
r “The set is topologically connected”.
The inexpressibility of the third property above follows from Theorem 2.3
below, but was ﬁrst established in (Grumbach and Su, 1997).
So, the question is, what are the ﬁrst-order expressible topological properties
of plain sets? In order to formulate our answer to this question, we use the notion
of a cone (Coste, 1982).

Logical aspects of spatial databases
81
R
R
L
L
L
Figure 2.2 The cone of the central point of the ﬁgure is (LLRLR).
Around any point on the boundary of any plain set, we always see a circular
list of lines (L’s) and regions (R’s): this list is called the cone of the point. An
illustration is given in Figure 2.2.
In any plain set, there may be inﬁnitely many boundary points with cone
(LL) (these are the points that lie on a line), or with cone (R) (these are the
points on the boundary of a region). With the exception of these, however,
there are only ﬁnitely many boundary points; this is because semi-algebraic
sets have a very simple topology (Bochnak et al., 1998). In particular, there are
only ﬁnitely many points with a cone different from (LL) and (R); these points
are called the singular points of the set. It can be argued (Benedikt et al., 2006)
that, without loss of generality, we can focus on the singular points, and we
will do so from now on.
We are now ready to introduce a propositional logic, called Cone Logic or
CL for short, designed to express properties of plain sets.
r Atomic formulas are of the form
|e| ⩾n
with n some natural number and e a star-free regular expression over  =
{L, R}.
The meaning of such a formula is that there are at least n singular points
whose cone satisﬁes e. (For background on star-free regular expressions and
their connection to ﬁrst-order deﬁnability on strings, see (McNaughton and
Papert, 1971) and (Thomas, 1997).)
r A CL-sentence is a boolean combination of atomic formulas.
Let us see some examples of properties expressed by CL formulas:
r “The dimension is 0”:
|L∗| = 0 ∧|R∗| = 0

82
Bart Kuijpers and Jan Van den Bussche
r “There is a point where three lines intersect”:
|LLLLLL| ⩾1.
r “There is a point where two regions touch”:
|RR| ⩾1
We can now state the following theorem (Benedikt et al., 2006):
Theorem 2.2
The ﬁrst-order topological properties of plain sets are precisely
those expressible in CL.
This theorem can be proven in six steps:
1. Characterize when plain sets A and B are topologically elementary equiv-
alent in terms of cones;
2. Deﬁne ﬂower datasets as a normal form with respect to topological elemen-
tary equivalence;
3. Apply collapse theorems over ﬁnite structures over the reals;
4. Encode the topological content of ﬂower datasets by abstract ﬁnite struc-
tures, called codes;
5. Translate topological sentences about spatial datasets into sentences about
codes;
6. Establish invariance arguments over codes.
Let us go into these six steps in some more detail. For the full proof, we
refer to the paper (Benedikt et al., 2006).
Topological elementary equivalence
For plain sets A and B, write A ≡B
if A and B are indistinguishable by topological ﬁrst-order sentences.
We have the following theorem (Kuijpers et al., 2000), which plays a crucial
role in the proof of Theorem 2.2:
Theorem 2.3
A ≡B if and only if A and B have precisely the same cones,
with the same multiplicities.
An illustration of this theorem is given in Figure 2.3.
For the full proof of this theorem we refer to the paper (Kuijpers et al., 2000),
but we give an idea of the proof here. The proof is based on a transformation
of plain sets into a normal form called ﬂower normal form. An illustration of
this transformation is given in Figure 2.4.
This transformation proceeds by the use of transformation rules, such as the
“cut and paste” rule illustrated in Figure 2.5 for a 2-dimensional strip. This
rule allows us to cut a 2-dimensional strip in two pieces, of which one has a

Logical aspects of spatial databases
83
≡
Figure 2.3 These two plain sets are topologically elementary equivalent, accord-
ing to Theorem 2.3.
hole. The inverse transformation allows us to paste two strips together. There
is also a stronger cut-and-paste rule that does not leave a hole as a side effect.
For details we refer to (Kuijpers et al., 2000).
For both datasets at the top of Figure 2.4, ﬁrst, the (strong) strip-cut trans-
formation is used on the full strips near all the singular points of these sets. As
a result these singular points have disconnected full petals. There are also some
isolated 2-dimensional regions that result from the cutting.
One can show that the application of a transformation rule is indistinguish-
able by topological ﬁrst-order sentences, using a reduction to ﬁrst-order inex-
pressibility of queries on ﬁnite structures over the reals.
Finite structures over the reals
These are structures of the form ( ¯R,
R1, . . . , Rk) with Ri ﬁnite relations. An example of a query to such struc-
tures is Majority: given ﬁnite unary relations R1 and R2, is #R1 ⩾#R2?
Let us illustrate the above-mentioned reduction for the cut-and-paste trans-
formation. This reduction is done by writing a ﬁrst-order formula ψ(x, y) such
that for each ﬁnite structure D = ( ¯R, R1, R2):
r ψ(D) is homeomorphic to the left-hand side of the cut-and-paste transfor-
mation if #R1 ⩾#R2 in D;
r ψ(D) is homeomorphic to the right-hand side of the cut-and-paste transfor-
mation if #R1 < #R2 in D.
We do not give this formula ψ, but illustrate it in Figure 2.6. This reduction
idea is due to (Grumbach and Su, 1997).
As a consequence, if the cut-and-paste transformation were distinguish-
able by a topological ﬁrst-order sentence, then the Majority query would be
ﬁrst-order expressible on ﬁnite structure over the reals. We can show the latter

84
Bart Kuijpers and Jan Van den Bussche
Figure 2.4 Two plain sets transformed into one and the same ﬂower dataset.

Figure 2.5 Cut and paste transformations: any local part of a spatial dataset that
looks like a strip can be cut, with a hole in one of the pieces as a side effect, resulting
in a topologically elementarily equivalent dataset. The converse transformation is
also possible.
R1 = {a1, a2, a3, a4}, R2 = {b1, b2, b3, b4}:
a4
a1
b1
b2 b3
b4
a2
a3
R1 = {a1, a2, a3, a4}, R2 = {b1, b2, b3, b4, b5}:
b5
a1
b1
b2 b3
b4
a2
a3
a4
Figure 2.6 Reducing Majority to distinguishing the cut-and-paste transformation:
the set R1 is placed on the y-axis and the set R2 on the x-axis. In the rectangles
of the irregular raster thus formed, all diagonals from bottom left to top right are
drawn with thickness. Some auxiliary lines (in darker shade) are added outside the
raster. The ﬁgure thus obtained can be deﬁned from R1 and R2 by a ﬁrst-order
formula.

86
Bart Kuijpers and Jan Van den Bussche
Figure 2.7 A single ﬂower and a paired ﬂower.
to be false, however, using the so-called collapse theorems from “Embedded
Finite Model Theory” (E. Gr¨adel, 2007, Chapter 5).
Theorem 2.4 (Natural–active collapse)
Every ﬁrst-order query on ﬁnite struc-
tures over the reals is already expressible by a sentence in which all quantiﬁers
are relativised to the ﬁnite relations.
Theorem 2.5 (Generic collapse)
Every ﬁrst-order query on ﬁnite structures
over the reals, expressible in the language (0, 1, +, ·, <, R1, . . . , Rk), that is
order-generic (that is, invariant under all monotone permutations of R) is
already expressible by a sentence in the language (<, R1, . . . , Rk).
So, order-generic ﬁrst-order sentences view ﬁnite structures over the reals
just as abstract, ordered, ﬁnite structures. Note that the reduction ψ from above
is order-generic. And the Majority query on abstract, ordered, ﬁnite structures
is indeed not ﬁrst-order expressible, as can be shown using standard arguments
from ﬁnite model theory (Ebbinghaus and Flum, 1999; Libkin, 2004).
Flower datasets
Using the transformation rules, we can transform any plain
dataset into a normal form (as far as topological ﬁrst-order properties are
concerned). This normal form is that of a disjoint union of single or paired
ﬂowers. A single ﬂower has a single singular point, around which there are
one-dimensional or two-dimensional “petals” (the one-dimensional petals can
loop over other petals). In a paired ﬂower, two single ﬂowers are paired by an
even number of lines that can cross over. An illustration is in Figure 2.7.
A ﬂower dataset can be represented by an abstract ﬁnite structure called a
code: this is a disjoint union of single or paired cycles. A single cycle is a word
structure over the alphabet {L, R} equipped with a planar matching. In a paired
cycle, there are two words, and there is again a planar matching now on all the
L’s, so the matching can again cross over. An illustration is in Figure 2.8.
Translation argument
By a translation argument, we can now reduce the
proof of Theorem 2.2 to an invariance question about ﬁrst-order logic over

Logical aspects of spatial databases
87
<
L
L
L
L
L
L
L
L
R
R
<
<
<
<
<
<
<
<
<
L
L
L
L
L
L
L
L
R
R
<
<
<
<
<
<
<
<
<
L
L
L
L
R <
<
<
Figure 2.8 Cycle codings of the ﬂowers of Figure 2.7.
codes. This translation argument is based on the following (Benedikt et al.,
2006):
Lemma 2.6 (Drawing Lemma)
We can write an FO-formula δ(x, y) such that
for any code C embedded in the reals, δ(C) is a ﬂower dataset that is a drawing
of C.
The presence of the planar matching in codes was obviously meant to
facilitate such a drawing lemma.
The lemma allows us to translate a topological sentence φ about ﬂower
datasets into a sentence ψ := φ ◦δ about codes, called an implementation of
φ. Using the collapse theorems, we may assume that ψ sees only an ordered
version of the abstract code. This ordering < is not the ≺of the word structures,
but without loss of generality, we can actually assume that < does agree with
≺, so all < does is shufﬂe the separate cycles in some order. Note, however,
that ψ is invariant under the way this shufﬂing is done!
Now such <-invariant ﬁrst-order sentences on ordered codes can be seen
to be already expressible by plain ﬁrst-order sentences on codes. So, we are
closing in on our goal, as ﬁrst-order logic on codes comes already quite close to
Cone Logic. The “only” difference is that codes still contain a planar matching,
which Cone Logic lacks. Crucially, however, a rather technical argument shows
that ψ is also invariant under the particular choice of planar matching in
a code. We are thus faced with one ﬁnal hurdle, which is removed by the
following.
Planar-matching-invariant FO on word structures
Our general result con-
cerning word structures over a ﬁnite alphabet , additionally equipped with a
planar matching G, is the following:
Lemma 2.7 (Main Invariance Lemma)
G-invariant ﬁrst-order logic collapses
to plain ﬁrst-order logic on the class of word structures with a planar matching.

88
Bart Kuijpers and Jan Van den Bussche
a
a
a
a
b
c
b
c
a
c
b
b’
a’
c’
a’
a
Figure 2.9 Chain matching represented as a word with alternating markers.
a
a
a
a
b
c
b
c
a
b
c
b
c
a
a
a
Figure 2.10 Parenthetical matching represented as a folded word.
The lemma is formulated for standard word structures, but can be adapted
to cycles and cycle pairs.
The proof of the lemma focuses on two particular kinds of planar matchings:
chain matchings and parenthetical matchings. A chain matching, as illustrated
in Figure 2.9, can be simulated by relabeling every other position in the word
with a marked letter (using a second alphabet ′ with marked letters). A paren-
thetical matching, as illustrated in Figure 2.10, can be simulated by “folding”
the word, moving to the alphabet 2.
We can now translate ﬁrst-order logic over words with chain matchings
to ﬁrst-order logic over words with alternating markers; and we can likewise
translate ﬁrst-order logic over words with parenthetical matchings to ﬁrst-order
logic over folded words. Both translations imply that set W of words accepted
by a planar-matching-invariant sentence is surely regular, and can have only
very limited kind of counters in the sense of (McNaughton and Papert, 1971).
A ﬁnal, complicated, argument then shows that W = W ′ ∩()∗with W ′ a
counter-free regular language; since counter-free regular languages are ﬁrst-
order axiomatisable, the Lemma is proved.
2.5 Conclusion on ﬁrst-order topological properties
A corollary of Theorem 2.2 is what can be considered a topological version,
for (typically inﬁnite) real datasets, of the earlier-mentioned collapse theorems
for ﬁnite structures over the reals:
Corollary 1 (Topological Collapse)
Every topological ﬁrst-order property of
plain sets S is already expressible by a sentence using only < and S.
This corollary follows because Cone Logic can already be expressed in
ﬁrst-order logic over ( ¯R, S) using only < and S.

Logical aspects of spatial databases
89
=
−
=
−
Figure 2.11 Every set is a boolean combination of closed sets.
A natural open problem is to go beyond plain sets. What about non-closed
sets? We can always decompose a set in Rn in n + 1 closed sets, as illustrated
in Figure 2.11. Hence, the more general question is, what about the ﬁrst-order
topological properties of ensembles of plain sets, as opposed to single plain
sets? Grohe and Segouﬁn have shown that the situation there is considerably
more complex (Grohe and Segouﬁn, 2002). In particular, just looking at cones
is not enough anymore, and certain global properties such as “inside” and
“outside” are expressible.
Another very natural open question is to move to higher dimensions: cap-
turing the ﬁrst-order topological properties of semi-algebraic sets in R3.
And, what about non-semi-algebraic sets? Consider, for example, the prop-
erty “every point in the set has cone (LL)” (i.e., the dataset consists of a number
of disjoint curves either closed or going to inﬁnity). This is ﬁrst-order express-
ible, and it is topological over semi-algebraic sets, but it is not topological
over all sets (semi-algebraic sets have a very tame topology). Can one also
ﬁnd an example of a topological property that is ﬁrst-order expressible over
semi-algebraic sets, but not over all sets?
Last but not least, an obvious question is how much of our results can be gen-
eralized from semi-algebraic sets to deﬁnable sets in O-minimal structures (van
den Dries, 1998).
2.6 Point-based logics for geometric queries
First-order logic over ¯R is clearly a coordinate-based logic. Cone Logic, on
the other hand, is a point-based logic, as it deals directly with the (singular)
points in a dataset. Can we ﬁnd point-based logics for other kinds of geometric

90
Bart Kuijpers and Jan Van den Bussche
5
o
a
b
a+b
1
2
3
4
6
b
e1
a
b.a
o
−a
e2
1
2
b’
−b’
3
4
5
Figure 2.12 Geometric constructions of addition and multiplication: for addition,
we construct straight lines in the indicated order. The construction for multiplica-
tion also involves ﬁnding the mirror image of a point with respect to o, which is
indicated by circles, but can be accomplished using a parallelogram construction.
queries? The answer is afﬁrmative, thanks to an observation made by Tarski
(Schwabh¨auser et al., 1983) to the effect that the geometric constructions of
addition and multiplication are ﬁrst-order expressible using a single ternary
predicate β (“betweenness”) on points. These constructions are illustrated in
Figure 2.12.
Let us see how we can use this to obtain a point-based logic for the ﬁrst-order
afﬁne queries. In this logic, we view a dataset S ⊂R2 as a unary relation over

Logical aspects of spatial databases
91
the structure (R2, β), and we use ordinary ﬁrst-order logic over the universe R2,
with ternary β (betweenness) and unary S as the only predicates (as always,
β is ﬁxed and belongs to the background, while S is variable and represents
the input to the query). Note how this setup differs from the coordinate-based
approach, where we view S as a binary relation over (R, 0, 1, +, ·, <). Let us
denote the point-based logic by FO(β), and let us denote the coordinate-based
logic by FO( ¯R). Both are ﬁrst-order logics.
It now turns out that we can simulate FO( ¯R) by FO(β) in the following
sense. Call a triple (o, e1, e2) of non-collinear points, a basis. Then for each
FO( ¯R)-sentence φ there exists an FO(β)-formula ψ(o, e1, e2) such that for
every dataset S and for every basis (o, e1, e2):
S |= ψ(o, e1, e2)
⇔
α(S) |= φ
where α is the unique afﬁnity that maps (o, e1, e2) to ((0, 0), (1, 0), (0, 1)).
As a corollary, we obtain (Gyssens et al., 1999):
Theorem 2.8
For each FO( ¯R)-sentence φ expressing an afﬁne geometric
query there exists an equivalent FO(β)-sentence ψ (and vice versa).
Adding the 4-ary equidistance predicate, we can likewise capture the ﬁrst-
order Euclidean queries (Gyssens et al., 1999).
2.7 Plane graphs
To conclude this survey we must mention a very nice result from (Segouﬁn
and Vianu, 2000). The topology of a semi-algebraic set in the plane can be
represented by a ﬁnite data structure called a plane graph. (A plane graph is
a data structure representing a planar graph embedding.) This is illustrated in
Figure 2.13.
We have (Segouﬁn and Vianu, 2000):
Theorem 2.9
Every topological ﬁrst-order sentence about semi-algebraic
sets in the plane, using only < and S, can be translated to a ﬁrst-order sentence
about the corresponding plane graphs.
By topological collapse (see Section 2.5), we know that (for a single plain
set at least) the restriction in the above statement that 0, 1, + and · cannot be
used, is harmless.

92
Bart Kuijpers and Jan Van den Bussche
Figure 2.13 Plane graph data structure representing the topology of a semi-
algebraic set.
2.8 Spatial datalog and ﬁrst-order logic extended
with a while-loop
Topological connectivity is a property that is important in many applications, in
particular in geographical information systems (GIS) (Worboys and Duckham,
2004). As we remarked in Section 2.4, topological connectivity is not express-
ible in ﬁrst-order logic, and several more expressive extensions of ﬁrst-order
logic over the reals have been proposed that do allow the expression of topolog-
ical connectivity of spatial datasets. In this section, we brieﬂy discuss two such
extensions: spatial Datalog and ﬁrst-order logic extended with a while-loop. In
the next section, we will discuss in more detail extensions of ﬁrst-order logic
with different types of transitive-closure operators.
Spatial Datalog
Essentially, the query language spatial Datalog is Dat-
alog extended with polynomial inequalities in the body of rules, with the
understanding that: the underlying domain is R; the only extended database
predicate is S (the input spatial dataset); and relations can be inﬁnite
(to represent spatial datasets as binary relations, and auxiliary relations)
(Kuijpers et al., 1996).
The following spatial Datalog program expresses linear-path connectivity
of a two-dimensional spatial dataset. In the relation Obstr(x, y, x′, y′) cou-
ples of points of S are stored that cannot be connected by a straight line
segment that is entirely in S. Couples of points that are not obstructed are
collected in the Path relation (see Figure 2.14) and next the transitive closure

Logical aspects of spatial databases
93
Figure 2.14 Linear path connectivity of a spatial dataset in the plane.
of Path is computed. Only if all pairs of points in S end up in Path, S is
connected.
Obstr(x, y, x′, y′)
←−
¬S(¯x, ¯y), S(x, y), S(x′, y′),
¯x = a1t + b1,
¯y = a2t + b2, 0 ⩽t, t ⩽1,
b1 = x, b2 = y,
a1 + b1 = x′,
a2 + b2 = y′
Path(x, y, x′, y′)
←−
¬Obstr(x, y, x′, y′)
Path(x, y, x′, y′)
←−
Path(x, y, x′′, y′′),
Path(x′′, y′′, x′, y′)
Disconnected
←−
S(x, y), S(x′, y′),
¬Path(x, y, x′, y′)
Connected
←−
¬Disconnected.
To show that this spatial Datalog program correctly tests topological con-
nectivity on a class C of spatial datasets, we have to show that for any set S
in C, that two points in S are in the same connected component of S if and
only if they can be connected by a piecewise linear curve lying entirely in S
(soundness); and that the number of line segments needed to connect any such
pair of points in S is bounded (termination). Termination guarantees that the
transitive closure will terminate. Soundness then establishes the correctness of
the test for connectivity performed by the program after the transitive closure
is completed.
We have the following result (Kuijpers et al., 1996).

94
Bart Kuijpers and Jan Van den Bussche
Theorem 2.10
The above spatial Datalog program correctly tests connectivity
of semi-linear spatial datasets (i.e., spatial datasets that can be described using
addition only).
In fact, this program correctly tests topological connectivity for a wider class
of spatial datasets, called border-visible (Kuijpers et al., 1996). The program
does not work for arbitrary semi-algebraic ﬁgures in R2, however. For example,
when the input set is the area between the parabola given by y = x2 and
y = 2x2, then soundness is satisﬁed for all points except the origin. Even when
the origin is left out, termination is violated since there is no uniform bound
on the number of line segments needed to connect two points. The closer one
point gets to the origin, the more segments are needed.
First-order logic extended with a while-loop
Another extension is ﬁrst-
order logic with a while-loop. Basically, in this language ﬁrst-order deﬁnable
relations can be created using the input spatial dataset and previously created
relations. Also, a while-loop with a ﬁrst-order expressible stop-condition is
allowed. These two constructs are illustrated in the following program to test
linear-path connectivity.
Seg := {(x, y, x′, y′) | ∀λ(0 ⩽λ ⩽1 ∧∀u∀v((u, v) = λ(x, y) + (1 −
λ)(x′, y′) →S(u, v)))};
Path1 := Seg;
Path2 := {(x, y, x′, y′) | ∃u∃v(Path1(x, y, u, v) ∧Seg(u, v, x′, y′))};
while Path1 ̸= Path2
do
Path1 := Path2;
Path2 := {(x, y, x′, y′) | ∃u∃v(Path1(x, y, u, v)∧Seg(u, v, x′, y′))};
od
Rout := {() | ∀x∀y∀x′∀y′((S(x, y) ∧S(x′, y′)) ↔Path2(x, y, x′x, y′)))};
In the Seg relation, couples of points are collected that can be connected by
a line segment that is completely in S. Next, in the while-loop, the transitive
closure of this relation is computed and the output relation Rout reﬂects whether
all pairs of points of S are in this transitive closure.
This example shows that topological connectivity of linear spatial datasets
can be expressed in this language, but in fact we have the following more
powerful result (Gyssens et al., 1999).
Theorem 2.11
First-order logic extended with a while-loop is a computa-
tionally complete language on spatial (semi-algebraic) datasets.

Logical aspects of spatial databases
95
By a computationally complete query language we mean that every map-
ping from dataset to dataset, that is effectively computable by an algorithm
(working on representations of datasets by deﬁning formulas), is expressible
by a program in the language.
2.9 First-order logic extended with
transitive-closure operators
In the previous section, we have seen that, at least for linear datasets, the ability
to express the transitive closure (TC) sufﬁces to express connectivity. In this
section, we describe the extension of ﬁrst-order logic with various transitive-
closure operators more extensively.
We cannot add TC with its standard mathematical semantics, indeed
TC({(x, y) | y = 2x}) is not a semi-algebraic set. We look at the TC-operator
as a programming construct with a purely operational semantics and therefore
TC({(x, y) | y = 2x}) is regarded as a non-terminating computation.
Transitive-closure logic
More precisely, ﬁrst-order logic over the reals is
extended with expressions of the form
[TC⃗x;⃗y ψ(⃗x, ⃗y)](⃗s, ⃗t)
where ⃗x, ⃗y are k-tuples of real variables bound by the TC-operator and ⃗s and
⃗t are k-tuples of variables serving as the parameters of the TC-formula. The
evaluation on a input dataset A is then obtained as follows. We set X1 :=
ψ(A), and Xi+1 := Xi ∪{(⃗x, ⃗y) ∈R2k | (∃⃗z) (Xi(⃗x, ⃗z) ∧X1(⃗z, ⃗y))}, and stop
the computation as soon as Xi+1 = Xi. The semantics of [TC⃗x;⃗y ψ(⃗x, ⃗y)](⃗s, ⃗t)
is then deﬁned as the 2k-ary relation Xi(⃗s, ⃗t).
For example, [TCx;y S(x, y)](s, t) evaluated on A = {(x, y) | y = 2x}
gives X1 = {(s, t) | t = 2s}; X2 = X1 ∪{(s, t) | t = 4s} = {(s, t) | t = 2s ∨
t = 4s}; X3 = X2 ∪{(s, t) | t = 8s} = {(s, t) | t = 2s ∨t = 4s ∨t = 8s}; . . .
which is a non-terminating computation (illustrated in Figure 2.15).
On the other hand, the connectivity of linear spatial datasets in the plane can
be expressed by the formula
∀⃗x∀⃗y(S(⃗x) ∧S(⃗y) →[TC⃗r,⃗s(Seg(⃗r, ⃗s)](⃗x, ⃗y))
with Seg = {(⃗r, ⃗s) | (∃λ)(0 ⩽λ ⩽1 ∧(∀⃗t)((⃗t = λ · ⃗r + (1 −λ) · ⃗s) →S(⃗t)))}.
On linear sets this expression gives rise to a terminating computation. The

96
Bart Kuijpers and Jan Van den Bussche
Figure 2.15 A non-terminating transitive-closure computation.
number of iterations is bounded by the number of triangles needed to triangu-
late the input (or the number of line segments in a piecewise linear line).
Transitive-closure logic with stop conditions
A variant of the above
transitive-closure logic is ﬁrst-order logic with expressions of the form
[TC⃗x;⃗y ψ(⃗x, ⃗y) | σ](⃗s, ⃗t)
where additionally σ is an ﬁrst-order deﬁnable stop condition. The evaluation
of this expression on input database A is again the computation of X1, X2,
X3, . . . as above but with the additional stop condition (A, Xi+1) |= σ. Remark
that we do not allow parameters inside TC-expressions, i.e., ⃗s and ⃗t are the only
free variables of the entire TC-subformula.
For example, if [TCx;y S(x, y) | X(1, 8)](s, t) is evaluated on A =
{(x, y) | y = 2x}, then X1 = {(s, t) | t = 2s}; X2 = X1 ∪{(s, t) | t = 4s} =
{(s, t) | t = 2s ∨t = 4s}; X3 = X2 ∪{(s, t) | t = 8s} = {(s, t) | t = 2s ∨t =
4s ∨t = 8s}; and the computation terminates because (1, 8) ∈X3.
The above two languages were introduced in (Geerts and Kuijpers, 2005).
K-transitive-closure logic
Another variant of transitive-closure logic was
proposed in (Kreutzer, 2001) and we call it K-transitive-closure logic. In
K-transitive-closure logic the transitive-closure operator may be applied to
parameterized sets and the evaluation of a transitive-closure expression may be
controlled by the termination of particular paths in its computation rather than
by the termination of the transitive closure of the complete set.
More formally, it is ﬁrst-order logic over the reals extended with expressions
of the form
[TC⃗x;⃗y ψ(⃗x, ⃗y, ⃗u)](⃗s, ⃗t),

Logical aspects of spatial databases
97
where ⃗u is an ℓ-tuple, thus allowing a parameter inside the TC-formula. The
evaluation on an input dataset A is obtained in stages as follows. First, we
set X1 := ψ(A) ∧
i∈I(si = xi); and then continue Xi+1 := Xi ∪{(⃗x, ⃗y, ⃗u) ∈
R2k+ℓ| (∃⃗z) (Xi(⃗x, ⃗z, ⃗u) ∧ψ(⃗z, ⃗y, ⃗u))}; and we stop the computation as soon
as Xi = Xi+1. The semantics of [TC⃗x;⃗y ψ(⃗x, ⃗y, ⃗u)](⃗s, ⃗t), is then deﬁned to be
Xi. An example follows in Section 2.11.
We remark that the initial transitive-closure logic is a subset of K-transitive-
closure logic.
2.10 Expressiveness properties of transitive-closure logics
The results in this section can be found in (Geerts and Kuijpers, 2000; Geerts
et al., 2006). For the transitive-closure logic with stop condition we have the
following expressiveness result.
Theorem 2.12
All computable queries on linear spatial datasets, deﬁnable
by linear polynomials with coefﬁcients in Z, are expressible in the transitive-
closure logic with stop conditions.
The previous result even holds when we disallow the use of multiplication
in the query expression.
The proof of Theorem 2.12 can be sketched as follows. Let Q be a com-
putable query on linear spatial datasets. Then we will write Q as a composi-
tion Q5 ◦Q4 ◦Q3 ◦Q2 ◦Q1 of ﬁve queries that are expressible in transitive-
closure logic with stop conditions. To start with, Q1 produces on input a spatial
dataset S in Rn a triangulation of S. Since S can described by linear polynomials
with coefﬁcients in Z, these corner points of the triangulation will be rational
numbers. This encoding (and the corresponding decoding Q5) can actually be
done in ﬁrst-order logic over the reals.
The queries Q2 and Q4 are the encoding/decoding of ﬁnite relations over
the rational numbers into single natural numbers. Finally Q3 is the query that
simulates Q on the natural number encodings of spatial datasets. The existence
of a formula for Q3 is guaranteed by the following powerful lemma.
Lemma 2.13
For every partial computable function f : Nk →N there exists
a formula ϕf (y) in transitive-closure logic with stop conditions over the schema
S = {S(k)}, such that for any database D over S with SD = {(n1, ..., nk)}, we
have that ϕf (D) is deﬁned if and only if f (n1, . . . , nk) is deﬁned, and in this
case ϕf (D) = {f (n1, . . . , nk)}.

98
Bart Kuijpers and Jan Van den Bussche
This can be shown by simulating the run of a non-deterministic p-counter
machine Mf = (Q, δ, q0, qf ) which computes f .
We remark that the above theorem is limited to linear spatial datasets; it is
not known whether a ﬁnite encoding of an arbitrary semi-algebraic set can be
expressed in transitive-closure logic with stop conditions. But for queries on
arbitrary spatial datasets we have completeness if we restrict our attention to
topological properties.
Theorem 2.14
All computable Boolean topological queries on arbitrary
spatial datasets in Rn are expressible in transitive-closure logic with stop
conditions.
This theorem can be proven by showing that we can approximate a spatial
dataset by a Z-linear spatial database that is toplogically equivalent to it in
transitive-closure logic with stop conditions and by using the ﬁrst expresiveness
(Theorem 2.12) result.
To be more precise about the approximation, we now describe how a rational
ε-approximation of a spatial dataset can be expressed in transitive-closure logic
with stop conditions. The task here is, given a spatial dataset S and a real number
ε > 0, to ﬁnd a Z-linear spatial dataset that is homeomorphic to S (topological
condition) and that ε-approximates S (metric condition).
It is not difﬁcult to show that ε-approximations cannot be expressed in ﬁrst-
order logic over the reals (Geerts and Kuijpers, 2000). We now sketch, for
the case of R2, how a rational ε-approximation of a spatial dataset S can be
expressed in transitive-closure logic with stop conditions.
First, we ﬁnd all points where the boundary of S is not smooth and border
points with a vertical tangent line. For these points, we compute their local cone
radius (conicity around points was discussed in Section 2.4) and within these
radii we locally rectify the database. This is all expressible in ﬁrst-order logic
over the reals (Geerts and Kuijpers, 1999; Geerts et al., 2006) and illustrated in
Figure 2.16.
Next, we consider the border of S outside the cone radii determined in the
ﬁrst step. What remains of the border are simple curves. We then compute the
maximal cone radius r of all points on these curves in ﬁrst-order logic. Let Step
be the relation of pairs of points (p, q) on these curves such that d(p, q) = r.
In transitive-closure logic, we can compute TC(Step) and the termination of
this computation is guaranteed. Once this is done, we walk over these curves
starting from the endpoints and locally rectify them. This is illustrated in
Figure 2.17. We can also do this when the curves are bordering curves of the
interior.

Logical aspects of spatial databases
99
Figure 2.16 Local rectiﬁcation around non-smooth border points and points with
a vertical tangent line.
Figure 2.17 Rectiﬁcation of the border away from non-smooth border points.
Finally, we glue the result of the ﬁrst step onto the result of the second
step. The ﬁnal result is a Z-linear database homeomorphic to the original semi-
algebraic set (illustrated in Figure 2.18).
In dimensions higher than 2, the description of rational ε-approximation in
ﬁrst-order logic with transitive closure with stop condition technically more
complicated. It follows a recursive procedure on the dimension and boxes are
used instead of spheres to describe the cones of points.
We end this section with a corollary of Theorem 2.14 that concerns con-
nectivity, a property that is important in applications such as geographical
information systems.
Corollary 2
Topological connectivity of (even non-linear!) spatial datasets
is expressible in transitive-closure logic with stop conditions.

100
Bart Kuijpers and Jan Van den Bussche
Figure 2.18 Glueing the result of the two steps together.
y = 2x
y = 1
y = 0
0
1
2
Figure 2.19 A second example of a non-terminating evaluation of transitive
closure.
2.11 Deciding termination of transitive-closure
logic expressions
The results in this section can be found in (Geerts and Kuijpers, 2005).
From the deﬁnition in Section 2.8, it is clear that the evaluation of queries
expressed in transitive-closure logic with or without stop conditions may be
non-terminating.
Some examples
As we have seen before, when we evaluate the tran-
sitive closure, that is, the expression [TCx;y S(x, y)](s, t), on the spatial
dataset A = {(x, y) | y = 2x}, we get a growing number of lines (which
is illustrated in Figure 2.15). In other words, this is a non-terminating
computation.
Even if we modify the function y = 2x, as shown by the thick line in
Figure 2.19, that is, even if we bound its image, the computation of the transitive
closure remains non-terminating (as illustrated in Figure 2.19).

Logical aspects of spatial databases
101
y = x
y =
y = 0
0
1
1
4
3
4
1
4
Figure 2.20 An example of a terminating evaluation of transitive closure.
But there are function graphs on which the computation of the transitive
closure terminates. The function shown by the thick line in Figure 2.20, is
an example. Here we have a terminating computation because X4 = X5 =
X6 = · · · (illustrated by the thinner lines in Figure 2.20).
Obviously, adding stop-conditions may make non-terminating computations
terminating, as is illustrated by the example we gave earlier: if we apply the
query expressed by [TCx;y S(x, y) | X(1, 8)](s, t) to the dataset A = {(x, y) |
y = 2x} given in Figure 2.15, the computation terminates because, (1, 8) ∈X3.
Also, when [TCx;y S(x, y) | ∃x∃yX(x, y) ∧y = 1 ∧10x < 1](s, t) is ap-
plied to the function graph given in Figure 2.19, we get a terminating compu-
tation because the fourth set we compute satisﬁes the stop condition, that is,
∃x∃yX4(x, y) ∧y = 1 ∧10x < 1.
Obviously, K-transitive closure logic also has the problem of non-
terminating evaluations, since it contains transitive-closure logic. We give
an example of a terminating evaluation. Consider the evaluation of
[TCx;y S(x, y)]( 1
4, t) on the graph of the function given in Figure 2.19. This
gives X1 = {( 1
4, 1
2)}, X2 = {( 1
4, 1
2), ( 1
2, 1)} and X3 = X2.
Deciding termination and undecidability results
We can ask whether there
is a procedure to decide, for given an expression ϕ in some transitive-closure
logic and a dataset A whether ϕ has terminating evaluation on A?
It is fairly easy to obtain the following undecidability results (Geerts and
Kuijpers, 2005).
Theorem 2.15
It is undecidable whether a given formula in transitive-closure
logic, that uses transitive closure on relations of at most arity 4, terminates on
a given input database.

102
Bart Kuijpers and Jan Van den Bussche
The proof of this fact is by reduction of undecidability of nilpotency of
a piecewise afﬁne function f : R2 →R2 to this problem (Blondel et al.,
2001a,b). A function f : Rn →Rn is called nilpotent if there is a k ⩾1 such
that for all ⃗x ∈Rn: f k(⃗x) = ⃗0.
The following is an immediate consequence.
Corollary 3
It is undecidable whether a given formula in K-transitive-closure
logic, that uses transitive closure on relations of at most arity 4, terminates on
a given input database.
The following theorem can be proven using the undecidability of Hilbert’s
10th problem.
Theorem 2.16
It is undecidable whether a given formula in transitive-closure
logic with stop conditions, that uses transitive closure on at most binary rela-
tions, terminates on a given input database.
These results are complete for the languages all three types of transitive-
closure logics that we have considered, apart from the cases of (K-)transitive-
closure restricted to work on binary relations.
We have the following open problem: Is it decidable whether a given formula
in K-transitive-closure logic restricted to binary relations terminates on a given
input database? This problem is related to an open problem in dynamical
systems theory, namely the point-to-ﬁxed-point problem which asks whehther
for a given algebraic number x0 and a given piecewise afﬁne function f :
R →R, the sequence x0, f (x0), f 2(x0), f 3(x0), . . . reaches a ﬁxed point? This
decision problem is open, even for piecewise f consisting of just two line
segments.
We have a second open problem: Is it decidable whether a given formula
in transitive-closure logic restricted to binary relations terminates on a given
input database? In this case, this problem is related to deciding nilpotency of
functions f : Rn →Rn. That is, deciding termination of
[TC⃗x;⃗y S(⃗x, ⃗y)](⃗s, ⃗t)
applied to graph(f ) adds up to deciding nilpotency of f . But nilpotency of (pos-
sibly discontinuous) functions f : Rn →Rn is not known to be undecidable
for n = 1, whereas it is for n > 1.
Terminating functions
We say that a set A ⊆R2 has terminating transitive
closure if the formula [TCx;y S(x, y)](s, t) terminates on input A and we call
a function f : R →R terminating if graph(f ) has a terminating transitive
closure.

Logical aspects of spatial databases
103
The function of Figure 2.15 is not terminating, but the one of Figure 2.20 is.
We have the following, for what follows, important result.
Theorem 2.17
There is a procedure that on input a continuous semi-algebraic
function f : R →R decides whether it is terminating. Furthermore, this deci-
sion procedure is expressible in ﬁrst-order logic over the reals.
To get to this result, we need some terminology and lemmas. Let f : R →R
be a continuous function. We call x ∈R is a periodic point of f if f d(x) = x
for some d ⩾1 and the smallest such d is the period of x. Let Per(f ) denote
the set of periodic points of f .
We have the following properties.
Lemma 2.18
If f is continuous and terminating, then Per(f ) = f k(R) (for
some k) is non-empty, closed and connected. Furthermore, Per(f ) = {x ∈R |
f 2(x) = x}.
A result by Sharkovski˘ı’s from 1964 implies that if f is continuous and
terminating, then only periods 1, 2, 4, . . . , 2d can appear for some integer value
d ⩾1. The last part of the lemma is more speciﬁc.
So, we can conclude the following.
Corollary 4
If f is continuous and terminating, then f can only have periodic
points with periods 1 and 2.
We give the following crucial lemma without proof (see (Geerts and Kui-
jpers, 2005) for details).
Lemma 2.19
There is an ﬁrst-order sentence that expresses whether a con-
tinuous semi-algebraic function f : R →R is nilpotent.
We remark that the proof of the correctness of the ﬁrst-order sentence of
Lemma 2.19, given in (Geerts and Kuijpers, 2005), relies on the Bolzano-
Weierstrass theorem and therefore does not generalize to arbitrary real closed
ﬁelds.
Using the above results, we obtain the following procedure to decide termi-
nation of a function f : R →R.
In the following algorithm, ˜f is obtained from f by contracting the part of
f that consists of of points of period 1 or 2, to one point. This is illustrated in
Figure 2.21.

104
Bart Kuijpers and Jan Van den Bussche
graph(f)
graph(f)
a
a
a
a
b
b
Figure 2.21 The contraction ˜f of a function f .
Algorithm terminate(input f ):
Step 1. Compute the sets C1 = {x | f (x) = x} and C2 = {x | f 2(x) = x}. If
C2 is a closed and connected subset of R and if C1 is a point with C2 \ C1
around it or if C2 \ C1 is empty, then continue with Step 2, else answer no.
Step 2. If C2 is R, answer yes, else compute the function ˜f and decide whether
˜f is nilpotent and return the answer.
We remark that f k(R) = C1 ∪C2 if and only if ˜f k(R) = {0}.
We now illustrate the working of the algorithm terminate.
First, consider the a non-terminating function of Figure 2.19. Here, we have
C1 = {(0, 0), (1, 1)} and C2 = ∅and the algorithm answers no since C1 ∪C2
is disconnected.
Next, consider the terminating function of Figure 2.20. Here we have C1 =
{(0, 0)} and C2 = ∅, and thus C1 ∪C2 is closed and connected and since ˜f = f
is nilpotent the algorithm answers yes.
Small extensions of ﬁrst-order logic with transitive closure
The above
decidability result concerning termination of functions inspires the following
extension of ﬁrst-order logic with transitive closure restricted to be applied to
the graphs of continuous functions Rk →Rk. More precisely, let ψ(⃗x, ⃗y) be a
formula in transitive-closure logic (with or without stop condition). Consider
the sentence
γψ = γ 1
ψ ∧γ 2
ψ,
where γ 1
ψ expresses that ψ(⃗x, ⃗y) deﬁnes the graph of a function from Rk to Rk
and γ 2
ψ expresses that ψ(⃗x, ⃗y) deﬁnes a continuous function graph. We note
that γ 1
ψ and γ 2
ψ are ﬁrst-order related to γ .
Then it is easy to see that ψ(⃗x, ⃗y) terminates on input A if and only if γψ
terminates on A.

Logical aspects of spatial databases
105
Now, we deﬁne CF-transitive-closure logic, an extension of ﬁrst-order logic
with a transitive-closure operator that is restricted to graphs of continuous
functions Rk →Rk.
More formally, CF-transitive-closure logic is the fragment of transitive-
closure logic (respectively with stop condition) where expressions of the form
[TC⃗x;⃗y ψ(⃗x, ⃗y) ∧γψ](⃗s, ⃗t)
(respectively [TC⃗x;⃗y ψ(⃗x, ⃗y) ∧γψ | σ](⃗s, ⃗t)) are allowed, with γψ a sentence
that expresses that ψ(⃗x, ⃗y) deﬁnes the graph of a continuous function Rk →Rk.
From earlier undecidability results we immediately get
Corollary 5
It is undecidable whether a given formula in CF-transitive-
closure logic with stop condition, where the transitive closure is restricted to
work on binary relations, terminates on a given input database.
Without stop conditions, we have decidability, however.
Theorem 2.20
It is decidable whether a given formula in CF-transitive-
closure logic (without stop conditions), restricted to binary relations, terminates
on a given input database. Moreover, this decision procedure is expressible in
this language.
So, for every formula [TCx;y ψ(x, y)](s, t) in CF-transitive-closure logic
(without stop conditions), restricted to binary relations, there is a a formula τψ
in the same language that expresses that the formula terminates on a given input
database (also τψ depends on the input!). We call τψ the termination guard of
the formula [TCx;y ψ(x, y)](s, t).
Now, we can deﬁne GCF-transitive-closure logic, the guarded fragment
of CF-transitive-closure logic (without stop conditions), restricted to binary
relations, in which only transitive-closure expressions of the form
[TCx;y ψ(x, y) ∧τψ](s, t)
are allowed.
By deﬁnition, we now have that in GCF-transitive-closure logic every query
terminates on all possible input datasets and all terminating queries of CF-
transitive-closure logic are expressible in GCF-transitive-closure logic.
We end this section, with an expressibility result concerning these last two
languages.
Theorem 2.21
GCF-transitive-closure logic is more expressive than ﬁrst-
order logic on ﬁnite spatial datasets.

106
Bart Kuijpers and Jan Van den Bussche
For the last part of the theorem, we remark that the query Qint on 1-
dimensional datasets S that expresses “Is S a singleton that contains a natural
number?” is expressible in GCF-transitive-closure logic but not in ﬁrst-order
logic.
2.12 Some concluding remarks on transitive-closure logics
One of the motivations to study these different transitive-closure logics, is to
compare their expressive power and to establish which languages are compu-
tationally complete on linear or arbitrary (semi-algebraic) datasets.
It is not clear whether transitive-closure logic with stop conditions is more
expressive than transitive-closure logic without stop conditions. In particular,
it is not clear whether transitive-closure logic without stop conditions is also
computationally complete on linear spatial datasets.
We also remark that for CF-transitive-closure logic without stop condition,
termination is decidable and for CF-transitive-closure logic with stop condition
termination is not decidable. This does not separate these languages, however
(because equivalence is undecidable).
We also remark that many results on semi-algebraic functions also hold for
arbitrary real closed ﬁelds. But termination of continuous semi-algebraic func-
tions f : R →R for arbitrary real closed ﬁelds R is not ﬁrst-order expressible
(for R the proof relies on Bolzano-Weierstrass).

Bibliography
M. Benedikt, B. Kuijpers, C. L¨oding, J. Van den Bussche, T. Wilke. A charac-
terization of ﬁrst-order topological properties of planar spatial data. Journal
of the ACM, 53(2):273–305, 2006.
V.D. Blondel, O. Bournez, P. Koiran, C.H. Papadimitriou, J.N. Tsitsiklis. Decid-
ing stability and mortality of piecewise afﬁne dynamical systems. Theoretical
Computer Science, 255(1-2):687–696, 2001.
V.D. Blondel, O. Bournez, P. Koiran, J.N. Tsitsiklis. The stability of saturated
linear dynamical systems is undecidable. Journal of Computer and System
Sciences, 62(3):442–462, 2001.
J. Bochnak, M. Coste, M.-F. Roy. Real Algebraic Geometry. Springer, 1998.
M. Coste. Ensembles semi-alg´ebriques. In G´eometrie alg´ebrique r´eelle et
formes quadratiques, Lectures Notes in Mathematics vol. 959, Springer,
1982.
H.-D. Ebbinghaus, J. Flum. Finite Model Theory, second edition. Springer,
1999.
F. Geerts, B. Kuijpers. Expressing topological connectivity of spatial databases.
Proceedings of 7th International Workshop on Database Programming Lan-
guages (DBPL’99), Lecture Notes in Computer Science 1949, 221-235,
Springer-Verlag, 2000.
F. Geerts, B. Kuijpers. Linear approximation of planar spatial databases using
transitive-closure logic. Proceedings of the 19th Symposium on Principles of
Database Systems (PODS’00) 126-135, ACM Press, 2000.
F. Geerts, B. Kuijpers. On the Decidability of Termination of Query Eval-
uation in Transitive-Closure Logics for Polynomial Constraint Databases.
Theoretical Computer Science, Vol. 336, Nr. 1, 125-151, 2005.
F. Geerts, B. Kuijpers, J. Van den Bussche. Linearization and completeness
results for terminating transitive closure queries on spatial databases. SIAM
Journal on Computing, Volume 35, Issue 6, 1386-1439, 2006.
107

108
Bart Kuijpers and Jan Van den Bussche
E. Gr¨adel et al. Finite Model Theory and Its Applications. Springer, 2007.
M. Grohe, L. Segouﬁn. On ﬁrst-order topological queries. ACM Transactions
on Computational Logic, 3(3):336–358, 2002.
S. Grumbach, J. Su. Queries with arithmetical constraints. Theoretical Com-
puter Science, 173(1):151–181, 1997.
M. Gyssens, J. Van den Bussche, D. Van Gucht. Complete geometric query
languages. Journal of Computer and System Sciences, 58(1):54–68, 1999.
S. Kreutzer. Operational semantics for ﬁxed-point logics on constraint
databases. Proceedings of the 8th International Conference on Logic for
Programming, Artiﬁcial Intelligence, and Reasoning (LPAR’01), Lecture
Notes in Computer Science 2250, 470–484. Springer-Verlag, 2001.
B. Kuijpers, J. Paredaens, J. Van den Bussche. On topological elementary equiv-
alence of closed semi-algebraic sets in the real plane. Journal of Symbolic
Logic, 65(4):1530–1555, 2000.
B. Kuijpers, J. Paredaens, M. Smits, J. Van den Bussche. Termination properties
of spatial Datalog programs Proceedings of “Logic in Databases” (LID’96),
Lecture Notes in Computer Science 1154, 101-116, 1996.
L. Libkin. Elements of Finite Model Theory. Springer, 2004.
R. McNaughton, S. Papert. Counter-Free Automata. MIT Press, 1971.
J. Paredaens, J. Van den Bussche, D. Van Gucht. First-order queries on ﬁnite
structures over the reals. SIAM Journal on Computing, 27(6):1747–1763,
1998.
L. Segouﬁn, V. Vianu. Querying spatial databases via topological invariants.
Journal of Computer and System Sciences, 61(2):270–301, 2000.
W. Schwabh¨auser, W. Szmielew, A. Tarski. Metamathematische Methoden in
der Geometrie. Springer-Verlag, 1983.
W. Thomas. Languages, automata, and logic. In G. Rozenberg and A. Salomaa,
editors, Handbook of Formal Language Theory, volume 3. Springer, 1997.
L. van den Dries,
Tame Topology and O-minimal Structures,
Cambridge
University Press, Cambridge, UK, 1998.
M.F. Worboys, M. Duckham, GIS: A Computing Perspective, Second Edition,
CRC Press, 2004.

3
Some connections between ﬁnite and
inﬁnite model theory
vera koponena
3.1 Introduction
Most of the work in model theory has, so far, considered inﬁnite structures and
the methods and results that have been worked out in this context cannot usually
be transferred to the study of ﬁnite structures in an obvious way. In addition,
some basic results from inﬁnite model theory fail within the context of ﬁnite
models. The theory about ﬁnite structures has largely developed in connection
with theoretical computer science, in particular complexity theory [12]. The
question arises whether these two “worlds”, the study of inﬁnite structures and
the study of ﬁnite structures, can be woven together in some way and enrich
each other. In particular, one may ask if it is possible to adapt notions and
methods which have played an important role in inﬁnite model theory to the
context of ﬁnite structures, and in this way get a better understanding of fairly
large and sufﬁciently well-behaved classes of ﬁnite structures.
If we are to study structures in relation to some formal language, then the
question arises which one to choose. Most of inﬁnite model theory considers
ﬁrst-order logic. Within ﬁnite model theory various restrictions and extensions
of ﬁrst-order logic have been considered, since ﬁrst-order logic may be con-
sidered as being both too strong and too weak (in different senses) for the
study of ﬁnite structures. A reasonable candidate for studying ﬁnite structures,
with a viewpoint from inﬁnite model theory, is the language Ln, ﬁrst-order
logic L restricted to formulas in which at most n variables occur, whether
free or bound. Theories consisting of only Ln-formulas, even those which are
“complete” within Ln, may have both ﬁnite and inﬁnite models, or only ﬁnite
models, or only inﬁnite models. The language Ln has the nice properties of
being closed under subformulas, quantiﬁcation and negation. Also, there is a
a Uppsala Universitet, vera.koponen@math.uu.se
109

110
Vera Koponen
pebble game which distinguishes whether two structures satisfy exactly the
same Ln-sentences or not ([23] and implicitly in [29]).
The notion of a type plays an important role in inﬁnite model theory. In ﬁnite
model theory the notion of an Ln-type, i.e. a type restricted to Ln-formulas,
has been used; the number of different Ln-types of an Ln-theory can be seen as
a measure of the complexity of the theory. Dawar observed [5] that for every
Ln-theory T with ﬁnite models there is an upper bound, depending only on
the number of Ln-types (in n free variables) of T , of the size of the smallest
model of T . Later Grohe proved that this upper bound is not recursive [17]. The
language Ln has also been considered in the context of (only) inﬁnite models in
the work of Hedman [19] where complete theories (within full ﬁrst-order logic)
which are axiomatizable by Ln-sentences are studied. For a general overview
about interactions (and differences) between ﬁnite and inﬁnite model theory,
see [30]. For a survey about the use of ﬁnite variable logics in ﬁnite model
theory, see [16].
Within inﬁnite model theory the area of stability theory has had great inﬂu-
ence. It studies quite a large class of “manageable” (inﬁnite) structures and
their complete ﬁrst-order theories. Work in the direction of developing the
basics of a similar theory for ﬁnite structures was ﬁrst carried out by Hytti-
nen [21]. Then, from a different viewpoint, the author developed some results,
inspired by stability theory, aimed at understanding when an Ln-theory with
inﬁnite models must also have arbitrarily large ﬁnite models [9, 8]. Further
developments in this direction were made by Baldwin and Lessmann [2] and
by Hyttinen [22]. For an overview, with a historical perspective, of ﬁnite and
inﬁnite model theory and recent interactions between them, see [1].
Another approach to understanding certain ﬁnite and countably inﬁnite
structures culminates with the work about smoothly approximable structures
in [3]. This line of research started with Lachlan’s work on stable ﬁnitely
homogeneous structures (surveyed in [27]) and Zilber’s work on uncountably
categorical structures [33]. It continued with joint work by Cherlin, Harrington
and Lachlan on ω-categorical ω-stable structures [4] and then with the work of
Kantor, Liebeck and Macpherson [24], to reach its current state in [3]. Smoothly
approximable structures are inﬁnite but can be approximated by “nicely embed-
ded” ﬁnite structures which, intuitively speaking, are quite “homogeneous” or
“regular”. The theory of smoothly approximable structures can also be seen as
a study of ﬁnite structures with few types.
More recently, a direction of research initiated by Macpherson and Stein-
horn [28] and continued by Elwes [13, 14] and Ryten studies classes of ﬁnite
structures in which deﬁnable sets have a uniform asymptotic behaviour, as the
cardinalities of the universes increase. The complete theory T of a non-principal
ultraproduct of such a class of ﬁnite structures (called an ‘asymptotic class’) is

Some connections between ﬁnite and inﬁnite model theory
111
simple with ﬁnite SU-rank and there is a notion of measure on the deﬁnable
subsets of models of T , but T is not necessarily smoothly approximable. See
[15] for a survey of the topic.
In this article an overview is given of a line of research which considers Ln-
theories with inﬁnite models and tries to isolate conditions for when these have
arbitrarily large ﬁnite models and when least upper bounds for the smallest
model is recursive in terms of the number of Ln-types in n free variables.
Although some results are stated within a more general context, considering
some arbitrary fraction of ﬁrst-order logic which is closed under subformulas,
and some results could be stated in a somewhat more general way, we mostly
stick to the language Ln for the sake of simplicity. Moreover, when working with
Ln we usually consider an Ln-theory T such that T is ﬁnitely axiomatizable
in Ln and complete (within Ln) in the sense that for every ϕ ∈Ln, T |= ϕ or
T |= ¬ϕ. The motivation is that we like to ﬁnd conditions for T which imply
that T has a ﬁnite model, and facts 3.2.6 and 3.2.7 below imply the following:
if T is an Ln-theory and no complete Ln-theory T ′ ⊇T exists such that T ′ is
ﬁnitely axiomatizable, then T has no ﬁnite model.
The basic idea is to isolate conditions for a ﬁnitely axiomatizable complete
Ln-theory T which guarantee the existence of a model M of T which is
smoothly approximable, since such an M has the property that every sentence
which is true in M is true in arbitrarily large ﬁnite substructures of M. Moreover,
in this situation the theory of smoothly approximable structures implies that a
recursive upper bound, in terms of the number of Ln-types in n free variables, of
the smallest model exists (in contrary to the general situation, as proved in [17]).
Sections 1 – 7 of this article try to unify, as much as possible, the approaches
of [9], [8] and [2]. Hyttinen’s paper [22] on canonical ﬁnite diagrams and
quantiﬁer elimination is highly recommended since it develops, in a more
general context, part of the theory and several of the results. Here I have
chosen to expose the subject via a more “down-to-earth”-approach focused on
Ln-theories, although some generality is lost.
Sections 3.6 and 3.7 discuss inﬁnite structures which have the ﬁnite model
property but which are not necessarily smoothly approximable (the random
bipartite graph is an example [24]). This may be useful for understanding other
classes of Ln-theories than those treated in earlier sections. The last section
contains a list of questions and problems.
3.2 Preliminaries
3.2.1 Finite variable logic
In this section we introduce the language Ln, the subset of L containing all
formulas in which at most n distinct variables occur.

112
Vera Koponen
Deﬁnition 3.2.1
(i) Let V = {v1, v2, v3, . . .} be the set of variables which are
used in formulas of L.
(ii) By x, y, z, ¯x, ¯y, ¯z, sometimes with indices, we denote variables and ﬁnite
sequences of variables. Similarly, a, b, c, ¯a, ¯b, ¯c denote elements and ﬁnite
sequences of elements from structures. When writing ¯a ∈A we mean that every
element of the sequence ¯a belongs to A. If, in addition, we like to stress that ¯a
has length n, then we may write ¯a ∈An.
(iii) L always denotes the set of all ﬁrst-order formulas over some vocabulary
(or signature). We always assume that L is countable.
(iv) If a formula in L is denoted by ϕ(¯x) then we mean that every free variable
in that formula belongs to the sequence ¯x.
(v) For any n < ω, Ln denotes the set of all formulas ϕ(¯x) ∈L such that at
most n distinct variables occur in ϕ(¯x) (whether bound or free). We allow ¯x to
contain “dummy variables” (not occuring in the formula denoted by ϕ(¯x)). For
example, the formula v1 = v2 ∨v2 = v3 may be denoted by ϕ(v1, v2, v3, v4)
and consequently ϕ(v1, v2, v3, v4) ∈L3, because only three variables actually
occur in the formula ϕ(v1, v2, v3, v4).
(vi) An Ln-theory is a set of sentences from Ln.
(vii) An Ln-theory T is called a complete Ln-theory if for every sentence
ϕ ∈Ln, T |= ϕ or T |= ¬ϕ. Of course, a ‘complete Ln-theory’ need not be
complete with respect to L.
(viii) If M is an L-structure let
T hLn(M) =

ϕ ∈Ln : ϕ is a sentence and M |= ϕ

.
So T hLn(M) is always a complete Ln-theory.
Remark 3.2.2
We have not ﬁxed n special variables to be used in formulas
of Ln, but we only say that at most n distinct variables may occur in a formula
of Ln. For instance, a formula of Ln may contain variables among v1, . . . , vn
or variables among vn+1, . . . , v2n. For example, both v1 = v2 ∨v2 = v3 and
v2 = v3 ∨v3 = v4 belong to L3.
We are interested in ﬁnding conditions under which an Ln-theory with inﬁnite
models also has (arbitrarily large) ﬁnite models. So we ﬁrst give some easy
examples showing that Ln-theories may have only inﬁnite models, only ﬁnite
models or both inﬁnite and ﬁnite models
Examples 3.2.3
(a) Let M = (N, S), where S is the successor function (or
relation). Then T hL3(M) has no ﬁnite model.
(b) If M = (Q, <) then T hL3(M) has no ﬁnite model.
(c) Let M be a ﬁnite graph such that v1, . . . , vm lists all vertices of M and there

Some connections between ﬁnite and inﬁnite model theory
113
is an edge between vi and vj if and only if j = i + 1 or i = j + 1. Then every
model of T hL3(M) is isomorphic to M.
(d) Let M be an inﬁnite tree such that for some m < ω, no path in M has length
m. Then T hLn(M) has arbitrarily large ﬁnite models, for any n.
(e) Let K be a ﬁnite ﬁeld. Let T be a set of sentences which expresses the
axioms of a K-vector space. With scalar multiplication and vector addition
represented by function symbols we may assume that T is an L3-theory. With
scalar multiplication and vector addition represented by relation symbols we
may assume that T is an L7-theory. T has arbitrarily large ﬁnite models and
hence inﬁnite models.
3.2.2 Types
The notion of a ‘type’ plays an important role in model theory. Here we will
in particular be interested in certain types which are restricted to formulas of
some sublanguage of the ﬁrst-order language L. We ﬁrst give some deﬁnitions
with associated notation and then state a few well-known results concerning
types.
Deﬁnition 3.2.4
(i) Let  ⊆L, let M be an L-structure and let A ⊆M.
(ii) Deﬁne
T h(M, A) =

ϕ(¯a) : ϕ(¯x) ∈, ¯a ∈A, M |= ϕ(¯a)

,
and let T h(M) = T h(M, ∅). So T h(M) is the set of sentences in  that
are true in M.
(iii) For a sequence of variables ¯x we deﬁne
 ¯x(A) =

ϕ(¯x, ¯a) : ϕ(¯x, ¯y) ∈, ¯a ∈A

,
and ¯x = ¯x(∅).
(iv) A -type over A (with respect to T h(M, A)) in the free variables ¯x is a
set p(¯x) ⊆¯x(A) such that p(¯x) ∪T h(M, A) is consistent.
(v) A -type p(¯x) over A is called a complete -type over A if whenever
ϕ(¯x, ¯a) ∈¯x(A) then ϕ(¯x, ¯a) ∈p(¯x) or ¬ϕ(¯x, ¯a) ∈p(¯x).
(vi) S
m(A, M) is the set of all complete -types over A (with respect to
T h(M, A)) in the free variables v1, . . . , vm. If  = L then we may omit it.
(vii) We write Sn
m(A, M) instead of SLn
m (A, M).
(viii) For a complete Ln-theory T we deﬁne Sn
m(T ) = Sn
m(∅, M), where M is
any model of T (so T hLn(M, ∅) = T ). By Lemma 1.2 in [9] this deﬁnition
does not depend on the choice of the model M of T .
Below are a few facts about Ln-types.

114
Vera Koponen
Fact 3.2.5
For any complete Ln-theory T , Sn
n(T ) is ﬁnite if and only if there are
only ﬁnitely manyLn-formulas inthefreevariables v1, . . . , vn up to equivalence
modulo T .
The previous fact is a consequence of the “Stone duality theorem for boolean
algebras” [20], but it can also be derived in a straightforward way from the
deﬁnitions.
The next fact can be extracted from the proof of a similar result in [6], and
it is also mentioned in [29] (in Exercise 4).
Fact 3.2.6
(Dawar, Lindell, Weinstein; Poizat) Suppose that the vocabulary
of L is ﬁnite and contains no function symbols. If T is a complete Ln-theory
and Sn
n(T ) is ﬁnite then there is ϕ ∈Ln that axiomatizes T (i.e. ϕ |= T and
T |= ϕ). Moreover, we can choose ϕ so that its quantiﬁer rank is at most
|Sn
n(T )| + n.
The next fact is easy to prove, but a proof can also be found in [9].
Fact 3.2.7
(i) If a complete Ln-theory T has a ﬁnite model M then |Sn
n(T )| ≤
|M|n.
(ii) If T is a complete Ln-theory and Sn
n(T ) is inﬁnite then T has no ﬁnite
model.
Using Fact 3.2.7, when looking for ﬁnite models of a complete Ln-theory T
we can rule out the case when Sn
n(T ) is inﬁnite.
3.2.3 Closure maps
Deﬁnition 3.2.8
Let M be an L-structure.
(i) We call a function cl : P(M) →P(M) a closure map (or closure function) if
whenever A ⊆B ⊆M then A ⊆cl(A), cl(cl(A)) = cl(A) and cl(A) ⊆cl(B).
(ii) If cl(A) = A then we say that A is closed. A sequence is closed if the set
of elements occurring in the sequence is closed.
A few examples of closure maps are given below:
Examples 3.2.9
(a) If cl(A) = A for every A ⊆M then cl is a closure map;
we say that such a closure map is trivial.
(b) If, for every A ⊆M, cl(A) is the substructure of M which is generated by
A, then cl is a closure map.
(c) If, for every A ⊆M, cl(A) is the algebraic closure of A, in the model
theoretic sense, then cl is a closure map. See [20] for a deﬁnition of ‘algebraic
closure’ in the model theoretic sense.

Some connections between ﬁnite and inﬁnite model theory
115
(d) If M is an algebraically closed ﬁeld and cl(A) is the algebraic closure of A,
in the sense of ﬁeld theory, then cl is a closure map.
(e) If M is a vector space and cl(A) is the linear span of A, then cl is a closure
map.
3.3 Amalgamation classes
In order to prove that arbitrarily large ﬁnite models of a ﬁnitely axiomatizable
theory T exist we prove that a particularly nice model M of T exists. This
M will have the property that every sentence which is true in M is true in a
ﬁnite substructure of it. Such an M exists if there is an “amalgamation class”
of models of T and all models in the amalgamation class are “stable”. The
deﬁnition of an amalgamation class is given in this section (Deﬁnition 3.3.5)
and the notion of ‘stability’ is treated in Section 3.4.
Deﬁnition 3.3.1
Let  ⊆L and let M and N be L-structures.
(i) If ai ∈M, bi ∈N, for i < λ, then we write
(M, (ai : i < λ)) ≡ (N, (bi : i < λ))
if for every m < ω, every ϕ(x1, . . . xm) ∈ and every {i1, . . . , im} ⊆λ,
M |= ϕ(ai1, . . . , aim) if and only if N |= ϕ(bi1, . . . , bim).
(ii) A function f : A →N, where A ⊆M, is called a -elementary embedding
if for every ϕ(¯x) ∈ and ¯a ∈A with |¯a| = |¯x|, we have
M |= ϕ(¯a)
if and only if
N |= ϕ(f (¯a)).
(iii) If M is a substructure of N and for every ϕ(¯x) ∈ and every ¯a ∈M
with |¯a| = |¯x|, M |= ϕ(¯a) if and only if N |= ϕ(¯a), then we say that M is a
-elementary substructure of N and that N is a -elementary extension of M,
denoted M ≼ N. As usual we may write ≼instead of ≼L.
In the next section we will use the following result which is proved in the same
way as the well-known Tarski-Vaught test [20]; for the proof we only need to
observe that Ln is closed under subformulas.
Fact 3.3.2
(Tarski-Vaught test for Ln) Suppose that n is greater than the arity
of every function symbol in the vocabulary of L and let M be an L-structure.
For any subset N of M, we have N ≼Ln M if and only if for every ϕ(y, ¯x) ∈Ln
and every ¯a ∈N (with |¯a| = |¯x|), if M |= ∃yϕ(y, ¯a) then there is b ∈N such
that M |= ϕ(b, ¯a).

116
Vera Koponen
Assumption 3.3.3
For the rest of this section we assume the following:
(1)  ⊆L and  is closed under subformulas.
(2) T ⊆ is a set of sentences.
(3) For every M |= T a closure map clM is ﬁxed such that if M, N |= T ,
ai ∈M, bi ∈N, for i < λ, and
(M, (ai : i < λ)) ≡ (N, (bi : i < λ))
then {ai : i < λ} is closed (with respect to clM) if and only if {bi : i < λ}
is closed (with respect to clN). Because of this assumption we can, for
simplicity of notation, omit the subscript ‘M’ in clM in the situations
where we deal with a closure map.
(4) cl is uniformly locally ﬁnite with respect to T ; that is, for every m < ω
there is m′ < ω such that if M |= T , A ⊆M and |A| ≤m, then |cl(A)| ≤
m′.
Remark 3.3.4
Natural examples of  which are closed under subformulas
are  = Ln and
 = {ϕ ∈L : the quantiﬁer rank of ϕ is at most n}.
See [20] for a deﬁnition of quantiﬁer rank.
Deﬁnition 3.3.5
A non-empty class A of L-structures is called a -
amalgamation class for T if:
(1) Every structure in A is a model of T .
(2) A is closed under isomorphism.
(3) A is closed under -elementary substructures, i.e. if N ∈A and M ≼ N
then M ∈A.
(4) Whenever M1, M2 ∈A and ¯a ∈M1, ¯b ∈M2 are closed sequences of the
same length and
(M1, ¯a) ≡ (M2, ¯b),
then there are N ∈A and a -elementary embedding f : M2 →N such
that M1 ≼ N and f (¯b) = ¯a.
Remark 3.3.6
If there is a -amalgamation class for T then there is, by the
downward L¨owenheim-Skolem theorem, an amalgamation class for T such
that all structures in it are countable.
Examples 3.3.7
(a) Let n ≥4, let M be a tree such that for some m < ω no
path in M has length m and let T = T hLn(M). Moreover, for every M |= T

Some connections between ﬁnite and inﬁnite model theory
117
and every A ⊆M let cl(A) = A. Then the class of all models of T is an Ln-
amalgamation class for T .
(b) Let n ≥3, let K be a ﬁnite ﬁeld and let T ⊆L3 formalize the axioms of
K-vector spaces in a language where scalar multiplication and vector addition
are represented by function symbols. For every M |= T and every A ⊆M let
cl(A) be the substructure which is generated by A. Then the class of all models
of T is an Ln-amalgamation class for T . If we had deﬁned cl as in (a) then T
would not have had any Ln-amalgamation class. This fact is a consequence of
results in Section 3.4 and is discussed immediately after Theorem 3.4.7.
Deﬁnition 3.3.8
Suppose that A is a -amalgamation class for T .
(i) We say that p ⊆ is a closed (, A)-type if there are M ∈A and a closed
ﬁnite sequence ¯a ∈M such that
p = {ϕ(¯x) ∈ : M |= ϕ(¯a)}.
(ii) We say that an L-structure M is (, ω, A)-saturated for closed sets if
whenever ¯b ∈N ∈A, ¯a ∈M ∩N, ¯a and ¯b¯a are closed ﬁnite sequences
and
(M, ¯a) ≡ (N, ¯a),
then there exists ¯c ∈M such that (M, ¯a ¯c) ≡ (N, ¯a ¯b), and hence, by
Assumption 3.3.3 (3), ¯c¯a is closed.
Lemma 3.3.9
If A is a -amalgamation class for T such that the set of all
closed (, A)-types is countable, then there exists a countable L-structure M,
such that
(i) M |= T
(ii) M is (, ω, A)-saturated, and
(iii) for every ﬁnite ¯a ∈M there exists N ∈A such that ¯a ∈N and (M, ¯a) ≡
(N, ¯a).
Proof. By Remark 3.3.6 we may assume that A is a -amalgamation class for
T which consists only of countable structures.
Then we use the idea in the proof of Fra¨ıss´e’s theorem (see [20] for instance)
to construct Mi ∈A, for i < ω, such that
• Mi ≼ Mi+1, for all i < ω, and
•
for any i < ω, ¯a ∈Mi and N ∈A, if ¯a, ¯b ∈N, ¯a and ¯a ¯b are closed and
(Mi, ¯a) ≡ (N, ¯a), then there exists j ≥i and ¯c ∈Mj such that (Mj, ¯a ¯c) ≡
(N, ¯a ¯b).

118
Vera Koponen
Let π : ω3 →ω be a bijection such that π(i, j, k) ≥i, j, k for all i, j, k and
let pk, k < ω, be an enumeration of all closed (, A)-types. Let M0 ∈A be
arbitrary. Now suppose that Mi is deﬁned for all i < ℓ+ 1, Mi ≼ Mi+1 for
all i < ℓand that ¯aj
i , j < ω, is an enumeration of all closed ﬁnite sequences
of elements from Mi, for i < ℓ+ 1. Suppose that ℓ= π(i, j, k). If there exists
N ∈A and ¯b ∈N such that ¯aj
i ∈N, ¯aj
i ¯b is closed, pk = {ϕ(¯x, ¯y) ∈ : N |=
ϕ(¯aj
i , ¯b)} and (Mi, ¯aj
i ) ≡ (N, ¯aj
i ), then (Mℓ, ¯aj
i ) ≡ (N, ¯aj
i ) so, by condi-
tion (4) in the deﬁnition of a -amalgamation class, there are Mℓ+1 ∈A and
¯c ∈Mℓ+1 such that Mℓ≼ Mℓ+1 and (Mℓ+1, ¯aj
i ¯c) ≡ (N, ¯aj
i ¯b). Otherwise let
Mℓ+1 = Mℓ.
Let M = 
i<ω Mi. Since  is closed under subformulas it follows from
Lemma 3.3.11 below that Mi ≼ M, for all i < ω, and from this we get (i).
Conditions (ii) and (iii) follows from the construction of M.
□
Deﬁnition 3.3.10
If M is a model as in Lemma 3.3.9 then we call M a limit
of A.
Lemma 3.3.11
Suppose that  is closed under subformulas and that Mi ≼
Mi+1 for i < κ. If M = 
i<κ Mi then Mi ≼ M for every i < κ.
Proof. By induction on the complexity of formulas in .
□
See [20] for a deﬁnition of an unnested formula.
Lemma 3.3.12
Suppose that every unnested atomic formula of L is equivalent,
modulo T , to a formula in . Let A be a -amalgamation class for T and
suppose that M and N are limits of A. Then for all closed ﬁnite sequences
¯a ∈M and ¯b ∈N with |¯a| = |¯b|,
if
(M, ¯a) ≡ (N, ¯b)
then
(M, ¯a) ≡L (N, ¯b),
and in fact there is an isomorphism from M onto N which sends ¯a to ¯b.
Proofsketch. Using properties (ii) and (iii) of Lemma 3.3.9 one carries out a
back and forth argument which shows that there is an isomorphism from M to
N which sends ¯a to ¯b.
□
Corollary 3.3.13
Suppose that every unnested atomic formula of L is equiv-
alent, modulo T , to a formula in . Then a limit of a -amalgamation class A
for T is unique up to isomorphism.
Note that if, for example,  = Ln, n ≥2, every relation symbol has arity at
most n and every function symbol has arity less than n, then every unnested

Some connections between ﬁnite and inﬁnite model theory
119
atomic L-formula belongs , so the condition about  in Lemma 3.3.12 and
in Corollary 3.3.13 is satisﬁed.
Deﬁnition 3.3.14
An L-structure M is -determined if for any closed ﬁnite
sequences ¯a, ¯b ∈M,
if
(M, ¯a) ≡ (M, ¯b)
then
(M, ¯a) ≡L (M, ¯b).
Hence, if  and T satisﬁes the assumptions of Lemma 3.3.12 and A is a -
amalgamation class for T , then a limit of A exists, is unique up to isomorphism
and is -determined. We also have a partial converse. To state it we need the
following deﬁnition:
Deﬁnition 3.3.15
An L-structure M is ω-homogeneous if for all ﬁnite
sequences ¯a, ¯b ∈M such that (M, ¯a) ≡L (M, ¯b) and for every c ∈M there
is d ∈M such that (M, ¯ac) ≡L (M, ¯bd).
Lemma 3.3.16
If M a model of T which is -determined and either ﬁnite,
or inﬁnite and ω-homogeneous, then there is a -amalgamation class for T .
Proofsketch. Take as the -amalgamation class all N which are isomorphic to
some countable N′ ≼ M.
□
We say that an inﬁnite L-structure M is ω-categorical if T hL(M) is ω-
categorical.
Remark 3.3.17
A basic fact is that every ω-categorical structure is ω-
homogeneous. Also, a complete theory is ω-categorical if and only if for every
model M of the theory and every n < ω, SL
n (∅, M) is ﬁnite and there are only
ﬁnitely many formulas with at most n free variables, up to equivalence modulo
the theory. (This is the well-known “Ryll-Nardzewski theorem” [20]).
For the next proposition, recall that ¯x = {ϕ(¯x) : ϕ(¯x) ∈}. By combining
the previous lemmas we get the following.
Proposition 3.3.18
Suppose that every unnested atomic formula in L is equiv-
alent to a formula in  and that for any ¯x, ¯x is ﬁnite up to equivalence modulo
T . Then the following are equivalent:
(i) There exists a -amalgamation class for T .
(ii) There exists M |= T which is -determined, and if M is inﬁnite, then M
is ω-categorical (because, by Assumption 3.3.3 (4), cl is uniformly locally
ﬁnite on M).

120
Vera Koponen
3.4 Stability
Now we will consider ‘stability’ and see how imposing a stability condition on
an Ln-theory T makes the limit M of every amalgamation class for T ω-stable.
This together with the ω-categoricity of M ensures that there are arbitrarily
large ﬁnite substructures of M which are models of T .
Assumption 3.4.1
In this section we assume the following:
(1) For every theory T that we speak about there is a closure map cl on the
models of T which is uniformly locally ﬁnite with respect to T . (See
Assumption 3.3.3 (4).)
(2) If T is an Ln-theory, M, N |= T , ai ∈M, bi ∈N, for i < λ and
(M, (ai : i < λ)) ≡Ln (N, (bi : i < λ))
then {ai : i < λ} is closed if and only if {bi : i < λ} is closed.
Deﬁnition 3.4.2
(i) Suppose that A is an Ln-amalgamation class (for T ). We say that A
is stable in Ln if for every ϕ(¯x, ¯y) ∈Ln there exists kϕ < ω such that
there does not exist M ∈A and ¯ai, ¯bi ∈M, for i < kϕ, satisfying M |=
ϕ(¯ai, ¯bj) ⇐⇒i ≤j.
(ii) We adopt the convention that every ﬁnite structure is stable.
(iii) An inﬁnite L-structure M is stable if for every ϕ(¯x, ¯y) ∈L, there exists
kϕ < ω such that there do not exist ¯ai, ¯bi ∈M, for i < kϕ, satisfying
M |= ϕ(¯ai, ¯bj) ⇐⇒i ≤j.
(iv) A formula ϕ(¯x, ¯y) is unstable with respect to a theory T if there exist
M |= T and ¯ai, ¯bi ∈M, i < ω, such that M |= ϕ(¯ai, ¯bj) ⇐⇒i ≤j;
otherwise ϕ(¯x, ¯y) is stable with respect to T .
Proposition 3.4.3
Suppose that n is greater than the arity of every function
symbol in the vocabulary of L and that n is at least as great as the arity of
every relation symbol in the vocabulary of L. If T is a complete Ln-theory such
that Sn
n(T ) is ﬁnite then the following are equivalent:
(i) There is a stable Ln-amalgamation class for T .
(ii) T has a stable model which is Ln-determined (and hence ω-categorical if
it is inﬁnite).
Proofsketch. By Fact 3.2.5, the assumption that Sn
n(T ) is ﬁnite implies that there
are only ﬁnitely many Ln-formulas up to equivalence modulo T and hence

Some connections between ﬁnite and inﬁnite model theory
121
for any sequence of variables ¯x (of any ﬁnite length) Ln
¯x is ﬁnite up to equiva-
lence modulo T .
Hence Proposition 3.3.18 gives all except the statement about stability. But
one direction of this follows from the fact that
• in (ii) we take the model of T to be the limit of a stable Ln-amalgamation
class for T , and
• if the formulas ϕi(¯x, ¯y), i = 1, . . . , m, are stable with respect to a complete
L-theory, then every boolean combination of the ϕi’s is stable with respect to
the same complete L-theory. (This can be proved directly by using Ramsey’s
theorem, but it also follows from the basic work on stable formulas by Shelah
[31].)
And conversely, given a model M satisfying the conditions in (ii), a stable
Ln-amalgamation class is obtained by taking all Ln-elementary substructures
of M (and structures isomorphic to these) as in Lemma 3.3.16.
□
Deﬁnition 3.4.4
An L-structure M is ω-stable if whenever M′ ≡L M, A ⊆
M′ and |A| ≤ω then |SL
1 (A, M)| ≤ω.
A basic fact from stability theory is that if M is ω-stable then M is stable. The
next lemma, which shows that under certain circumstances the converse also
holds, will be essential here.
Lemma 3.4.5
Suppose that M is an inﬁnite L-structure such that cl(A) = A
for every A ⊆M and Sn
n(∅, M) is ﬁnite. If M is stable and Ln-determined then
M is ω-stable.
Proofsketch. Under the premises of the lemma it follows that any L-formula
is equivalent, modulo T hL(M), to a boolean combination of Ln-formulas and
there are only ﬁnitely many Ln-formulas up to equivalence modulo T hLn(M).
Thus for every complete L-type p(¯x) over a set A, p(¯x) is determined by
p(¯x) ∩Ln(A). Now the lemma follows from the fact that if 0 < m < ℵ0 then
(ℵ0)m = ℵ0 and from Shelah’s “unstable formula theorem” ([31], Theorem
II.2.2), which tells us that if ϕ(v1, ¯y) is stable and A ⊆M is countable then
S{ϕ(v1, ¯y)}
1
(A) is countable.
□
Suppose that n is greater than the arity of every function symbol in the vocab-
ulary of L and greater than or equal to the arity of every relation symbol in
the vocabulary of L. From Proposition 3.4.3 and Lemma 3.4.5 it follows that
if T is a complete Ln-theory such that Sn
n(T ) is ﬁnite and there is a stable
Ln-amalgamation class for T , then T has a model which is ω-stable and, if it
is inﬁnite, ω-categorical.

122
Vera Koponen
Next we state the crucial result which will give us ﬁnite models for every
complete Ln-theory T such that Sn
n(T ) is ﬁnite and there is a stable Ln-
amalgamation class for T .
Theorem 3.4.6
(Cherlin, Harrington, Lachlan [4]) If M is ω-categorical and
ω-stable, M |= ϕ and A is a ﬁnite subset of M, then there exists a ﬁnite
substructure N ⊆M such that N |= ϕ and A ⊆N.
Recall that, by Fact 3.2.6, if T is a complete Ln-theory such that Sn
n(T ) is ﬁnite
then T is axiomatized by an Ln-sentence. Thus, applying Theorem 3.4.6 and
previous results we get:
Theorem 3.4.7
Suppose that n is greater than the arity of every function
symbol in the vocabulary of L and greater or equal to the arity of every
relation symbol in the vocabulary of L. If T is a complete Ln-theory such that
Sn
n(T ) is ﬁnite then the following hold:
(i) If M is a model of T which is ω-categorical and ω-stable, then for any
ﬁnite A ⊂M there is a ﬁnite N ≼Ln M such that A ⊆N, and consequently
N |= T .
(ii) Suppose that for every M |= T and A ⊆M, cl(A) = A. If there is a stable
Ln-amalgamation class A for T such that A contains at least one inﬁnite
structure then T has arbitrarily large ﬁnite models.
Observe the assumption in part (ii) of the above theorem that the closure
operation is trivial. We now turn to the case when ‘cl’ is not trivial (i.e. for
some A, cl(A) ̸= A). An example of such a situation is if M is an inﬁnite
vector space over a ﬁnite ﬁeld and T = T hLn(M), for sufﬁciently large n. Then
there cannot exist a trivial closure operation cl and a stable Ln-amalgamation
class for T , with respect to this closure operation, which contains an inﬁnite
structure. The reason is that it would imply the existence of an inﬁnite vector
space, over the same ﬁeld, which is Ln-determined and this is impossible. For
in every inﬁnite model of T we can choose m greater than n and on the one
hand a linearly independent sequence ¯a = (a1, . . . , am) and on the other hand
a sequence ¯b = (b1, . . . , bm) such that ¯b is not linearly independent but every
proper subtuple of ¯b is linearly independent. With this choice, ¯a and ¯b have the
same Ln-type but not the same L-type, so the structure is not Ln-determined.
Motivated by this example we would like to ﬁnd some amalgamation prop-
erty for complete Ln-theories T which holds also for the example of vector
spaces and which implies the existence of an ω-categorical and ω-stable model
of T , so that we are in position to apply Theorem 3.4.6.

Some connections between ﬁnite and inﬁnite model theory
123
Deﬁnition 3.4.8
Let T be an Ln-theory. T has the strong Ln-amalgamation
property over countable models if, whenever
M0 |= T , M0 ≼Ln Mi, where Mi is countable for i = 1, 2, ¯a1 ∈M1, ¯a2 ∈M2
are ﬁnite sequences and (M1, cl(¯a1)M0) ≡Ln (M2, cl(¯a2)M0)
then
there are M and Ln-elementary embeddings fi : Mi →M, i = 1, 2, such
that f1(¯a1) = f2(¯a2) and fi is the identity on M0 for i = 1, 2.
Remark 3.4.9
Suppose that M is a vector space over a ﬁnite ﬁeld and T =
T hLn(M), for n larger than the number of elements in the ﬁeld. Using the
elementary theory of vector spaces it is now easy to verify that T has the strong
Ln-amalgamation property over countable models. Also one can easily verify
that if cl is taken to be linear closure then there is a stable Ln-amalgamation
class for T with respect to this closure operation.
Theorem 3.4.10
(Baldwin, Lessmann [2]) Suppose that T is a complete Ln-
theory such that Sn
n(T ) is ﬁnite and T has the strong Ln-amalgamation property
over countable models.
(i) If M |= T and M is stable and Ln-determined then M is ω-stable.
(ii) If there is a stable Ln-amalgamation class A for T such that A contains
at least one inﬁnite structure then T has arbitrarily large ﬁnite models;
these can be taken as Ln-elementary substructures of the limit of A.
Proofsketch. (ii) follows from (i) and earlier results. Concerning (i): The
assumptions that Sn
n(T ) is ﬁnite, M is stable and Ln-determined (so M is
ω-categorical) imply, via Shelah’s “unstable formula theorem” [31], that for
any countable A ⊆M′ ≡L M, SLn
1 (A, M′) is countable. The useful conse-
quence of the strong Ln-amalgamation property over countable models is that
if N ≼N′ |= T , where N is countable, and ¯a, ¯b ∈N′ are ﬁnite sequences then
(N′, cl(¯a)N) ≡Ln (N′, cl(¯b)N)
implies
(N ′, cl(¯aN)) ≡Ln (N′, cl(¯bN)).
This property together with the assumption that M is Ln-determined (which
by the ω-categoricity of M implies that any N ≡L M is Ln-determined) shows
that M is ω-stable, by a counting types argument.
□

124
Vera Koponen
3.5 Recursive bounds
In this section we derive results about recursive upper bounds of the size of the
least model of Ln-theories.
We will use the theory of smoothly approximable structures which is pre-
sented in detail in [3]. Every structure which is ω-categorical and ω-stable is
smoothly approximable which essentially follows from [4], but also see [24].
One of several equivalent ways of deﬁning ‘smoothly approximable’ is the
following:
Deﬁnition 3.5.1
An L-structure M is smoothly approximable if M is ω-
categorical and if every L-sentence which is true in M is true in a ﬁnite
substructure N ⊆M such that
(1)
for every θ(¯x) ∈L there is χ(¯x) ∈L such that
{¯a ∈N : M |= θ(¯a)} = {¯a ∈N : N |= χ(¯a)}, and
(2)
for all ¯a, ¯b ∈N of the same ﬁnite length
(N, ¯a) ≡L (N, ¯b) ⇐⇒(M, ¯a) ≡L (M, ¯b).
We derive our results from the following theorem which does not directly speak
about smoothly approximable structures.
Theorem 3.5.2
(Cherlin, Hrushovski [3]) We can effectively decide for a
given sentence and k < ω if that sentence has a ﬁnite model M such that
|SL
4 (∅, M)| = k.
For our purposes we now deﬁne a recursive function f : ω2 →ω as follows:
Let f(n, k) = k if n < 2 or k = 0.
Now suppose that n ≥2 and k ≥1.
• Let ϕ1, . . . , ϕm be an enumeration of all sentences (up to equivalence)
of quantiﬁer rank at most k + n in a language Lk such that for every
1 ≤i ≤n the vocabulary of Lk contains exactly k constant symbols and
exactly k i-ary relation symbols, but no function symbols, and we assume
that ‘=’ is one of the binary relation symbols.
• For 1 ≤i ≤m, let Li be the language built up from the constant symbols
and the relation symbols that occur in ϕi and the identity symbol ‘=’ (but
no other symbols from the vocabulary of Lk). Then use Theorem 3.5.2 to
decide if ϕi has a ﬁnite model Mi such that |SLi
4 (∅, Mi)| ≤k;
• if such a model of ϕi exists then search until we ﬁnd such Mi and let
ℓi = |Mi|; otherwise let ℓi = 0.
• Then let f(n, k) = max{ℓ1, . . . , ℓm}.

Some connections between ﬁnite and inﬁnite model theory
125
If we had allowed function symbols in the language Lk appearing in the def-
inition of f, then there would have been inﬁnitely many formulas of rank at
most n ≤k + n (even quantiﬁer free formulas) that are non-equivalent. When
computing f we depend on the fact that (with the stated deﬁnition) there are
only ﬁnitely many non-equivalent Lk-formulas with quantiﬁer rank at most
k + n.
Deﬁnition 3.5.3
Let T be a complete Ln-theory. As in the previous sections
we associate a uniformly locally ﬁnite closure operation cl with models of T .
We now deﬁne a function cl∗: ω →ω as follows:
cl∗(n) = max{|cl(A)| : A ⊆M |= T, |A| ≤n}.
Corollary 3.5.4
Let T be a complete Ln-theory such that Sn
n(T ) is ﬁnite and
let cl be the closure operation associated with models of T . Also assume that
n ≥cl∗(4) and that the vocabulary of L contains no function symbols and that
the arity of every relation symbol is at most n. If M |= T , where M is smoothly
approximable and |Sn
cl∗(4)(∅, M)| = |Scl∗(4)(∅, M)|, then ϕ has a ﬁnite model of
cardinality at most f(n, |Sn
n(∅, M)|) (where Sn
n(∅, M) = Sn
n(T )).
Proof. Suppose that T , L, n and M satisﬁes the premises of the corollary. By
renaming symbols if necessary we may assume, without loss of generality, that
L ⊆Lk where Lk is the language that occurs in the deﬁnition of f, with k =
|Sn
n(T )|. By Fact 3.2.6, T is axiomatized by an Ln-sentence with quantiﬁer rank
at most |Sn
n(T )| + n = k + n. Since M is smoothly approximable it follows that
M has a ﬁnite substructure N such that N |= T and |S4(∅, N)| ≤|S4(∅, M)|.
From the assumptions that n ≥cl∗(4) and |Sn
cl∗(4)(∅, M)| = |Scl∗(4)(∅, M)| it
follows that
|S4(∅, N)| ≤|S4(∅, M)| ≤|Scl∗(4)(∅, M)| = |Sn
cl∗(4)(∅, M)| ≤|Sn
n(∅, M)| = k.
By the deﬁnition of f, there is a model of T with cardinality at most
f(n, |Sn
n(∅, M)|).
□
Corollary 3.5.5
Let n ≥4 and let L be a language with ﬁnite vocabulary
which contains no function symbols and in which all relation symbols have
arity at most n. If T is a complete Ln-theory such that
• Sn
n(T ) is ﬁnite,
• n ≥cl∗(4),
• for every M |= T and every A ⊆M, cl(A) = A, or T has the strong Ln-
amalgamation property over countable models, and
• there is a stable Ln-amalgamation class for T (with respect to cl),
then T has a model of cardinality at most f(n, |Sn
n(T )|).

126
Vera Koponen
Proof. Suppose that T satisﬁes the above conditions. First note that (by
Fact 3.2.6) T is axiomatized by an Ln-sentence with quantiﬁer rank ≤
|Sn
n(T )| + n. By results in the previous section, T has an ω-categorical and ω-
stable (hence smoothly approximable) model M which is Ln-determined (with
respect to the given closure operator). Then |Sn
cl∗(4)(∅, M)| = |Scl∗(4)(∅, M)|, so
by Corollary 3.5.4, T has a model N with cardinality at most f(n, |Sn
n(∅, M)|) =
f(n, |Sn
n(T )|).
□
Remark 3.5.6
Grohe [17] has shown that if n ≥3 then there does not exist a
recursive function fn : ω →ω such that for every complete Ln-theory T with
ﬁnite models,
min{|M| : M |= T } ≤fn(|Sn
n(T )|).
Except for the results presented here, an existence result about recursive upper
bounds has also been obtained by Dawar in [5]. The hypothesis of Dawar’s
result is that the class C of ﬁnite structures considered (where C could be
the class of all ﬁnite models of an Ln-theory, for example) has the ‘weak n-
Ehrenfeucht-Mostowski property’. Roughly speaking, this property says that
every sufﬁciently long “Ln-indiscernible” sequence in a structure in C can both
be extended in some Ln-elementary extension which belongs to C and reduced
(as long as it does not become too short) in some Ln-elementary substructure
that belongs to C.
The question arises: How general can a class, T , of complete Ln-theories
with ﬁnite models be if we require that there exists a recursive function f such
that min{|M| : M |= T } ≤f (|Sn
n(T )|) for all T ∈T ? Another problem is to
determine such a function f more precisely (polynomial, exponential, etc.),
perhaps starting with some smaller class of theories over which we have more
control.
3.6 Simple, possibly not smoothly approximable structures
This paper has focused on obtaining ﬁnite models for a complete Ln-theory
T by showing that T has an inﬁnite model M which has the ﬁnite submodel
property, by which we mean that every sentence which is true in M is true
in a ﬁnite substructure of M. As stated in Theorem 3.4.6, every ω-categorical
ω-stable structure has the ﬁnite submodel property. The same holds for the
more inclusive class of smoothly approximable structures which also contains
unstable examples (see [3]).

Some connections between ﬁnite and inﬁnite model theory
127
There are natural examples of structures which have the ﬁnite submodel
property but are not smoothly approximable, such as the random (bipartite)
graph Grg [24]. Grg can be deﬁned as the Fra¨ıss´e limit of the class of all ﬁnite
graphs, or alternatively one can give an explicit axiomatization of the complete
theory of Grg; see for instance [12, 20] for more about the random graph. (The
random bipartite graph is obtained similarly by considering the class of all ﬁnite
graphs expanded with an equivalence relation with exactly two classes subject to
the condition that edges may only occur between elements in different classes.)
The random (bipartite) graph has the following model theoretical properties:
it is ω-categorical with elimination of quantiﬁers, (super)simple (but unstable)
with SU-rank 1 and has trivial forking; see for instance [20] and [32] for
these model theoretic and stability/simplicity theoretic notions. The fact that
Grg has SU-rank 1 implies that the algebraic closure operation ‘acl’ forms a
pregeometry on Grg (see [20]).
Before continuing we note that there is a line of research [28, 13, 14, 15], not
discussed here, which studies the connection between classes of ﬁnite structures
in which deﬁnable sets have uniform behaviour, asymptotically, and (inﬁnite)
simple structures with ﬁnite SU-rank and with a measure on the deﬁnable
subsets, but which are not necessarily smoothly approximable. A question not
answered here is whether the approach in this article has anything in common
with the work about ‘asymptotic classes’ and ‘measurable structures’ (the
random graph ﬁts within both frameworks).
Work in two different directions has been carried out by the author to prove
the ﬁnite submodel property for classes of structures which contain the ran-
dom (bipartite) graph. One direction of research [10] studies ω-categorical
structures on which the algebraic closure operation forms a pregeometry. The
other direction of research [11, 26] studies structures which are ω-categorical,
simple with ﬁnite SU-rank and have trivial forking. In both directions a proba-
bilistic argument is involved in proving the ﬁnite submodel property. In order
to carry out this argument we need to assume that deﬁnable relations are
“sufﬁciently independent” from each other in senses that are made precise in
[10] and [26]. It seems that without any assumption about “sufﬁcient inde-
pendence” we are in a difﬁcult situation with respect to proving or disproving
the ﬁnite submodel property. We say more about this in the last paragraph of
Section 3.7.
The notion of “sufﬁcient independence” which is considered in [26] is called
the ‘n-embedding of types property’ (for a natural number n ≥2), with respect
to certain kinds of “generators”. Before stating the main result of [26] we
introduce some notation from stability/simplicity theory and explain, roughly,
the involved notions. We assume familiarity with imaginary elements (see [20]

128
Vera Koponen
or [32] for example). By A⌣|
C B we mean that A is independent from B over C
(see for example [32] for a deﬁnition of ‘independence’). The negation of A⌣|
C B
is denoted by A⌣|⧸
C B. A complete ﬁrst-order theory T has trivial dependence
(or trivial forking) if whenever A, B1, B2, C are subsets of Meq where M |= T
and A⌣|⧸
C (B1 ∪B2), then A⌣|⧸
C Bi for i = 1 or i = 2.
Here is a rough description of the n-embedding of types property (with
respect to all/simple generators). Suppose that T is a complete ﬁrst-order theory
which is simple (see [32] for a deﬁnition of ‘simple’) and assume that M |= T .
As usual, Meq denotes the extension of M by imaginary elements and ‘algebraic
closure’ is taken in the structure Meq (see [20] for a deﬁnition of algebraic
closure). We identify every natural number n with the set {0, . . . , n −1} and
let P(n) be the set of all subsets of n and P−(n) = P(n) −{n}. Suppose that
A0
i and B0
i , for i ∈n, are subsets of Meq and that, for every w ∈P−(n), Aw is
the algebraic closure of 
i∈w A0
i and Bw is the algebraic closure of 
i∈w B0
i .
Also assume that
r for all w, w′ ∈P−(n), Aw ⌣|
Aw∩w′Aw′ and Bw ⌣|
Bw∩w′Bw′, and
r for every w ∈P−(n) there is an elementary map (see [20]) fw from Aw onto
Bw such that fw(A0
i ) = B0
i for every i ∈w, and if w ⊆w′ then fw′ extends
fw↾
i∈w A0
i .
The n-embedding of types property says (omitting some details) that if
¯a = (a1, . . . , ar) is a sequence of elements from Meq which does not con-
tain any element from the algebraic closure of 
w∈P−(n) Aw, then there are
¯b = (b1, . . . , br) in Meq (we can assume that M is sufﬁciently saturated) and,
for w ∈P−(n), elementary maps gw : Aw ∪{a1, . . . , ar} →Bw ∪{b1, . . . , br}
such that gw↾
i∈w A0
i = fw↾
i∈w A0
i and if w ⊆w′ then gw′ extends gw↾

i∈w A0
i .
The phrase ‘with respect to all/simple generators’ when stating the condition
‘n-embedding of types property with respect to all/simple generators’ in the
next theorem refers to the conditions (if any) that we impose on the sets A0
i ,
B0
i , for i ∈n. In [26] the sets A0
i , B0
i , i ∈n, are called the “generators” of
the sets Am, Bm, m ∈P−(n). Every stable theory (see [20, 31, 32] for the
notion ‘stable’) has the n-embedding of types property with respect to simple
generators for every 1 < n < ω [26]. The complete theory of the random graph
[20] has the n-embedding of types property with respect to all generators for
every 1 < n < ω [26].
Theorem 3.6.1
[26] Suppose that there is m < ω such that every function
symbol of the language of M has arity at most m. If T h(M) is ω-categorical,

Some connections between ﬁnite and inﬁnite model theory
129
simple with ﬁnite SU-rank, has trivial dependence and, for every 1 < k < ω,
has the k-embedding of types property with respect to all generators, then M
has the ﬁnite submodel property. If the SU-rank of T h(M) is 1, then the phrase
‘with respect to all generators’ can be replaced by the phrase ‘with respect to
simple generators’, a weaker hypothesis.
It follows from Lemma 3.6.3, below, that Theorem 3.6.1 holds also if we replace
‘trivial dependence’ with ‘n-degenerate dependence for some n < ω’, where
n-degenerate dependence is deﬁned as follows.
Deﬁnition 3.6.2
Let T be a complete simple (L-) theory. We say that T
has n-degenerate dependence if the following holds: Whenever M |= T and
A, B, C ⊆M and A⌣|⧸
C B then there is B′ ⊆B such that |B′| ≤n and A⌣|⧸
C B′.
Observe that trivial dependence implies 1-degenerate dependence.
Lemma 3.6.3
Suppose that T is ω-categorical, simple with ﬁnite SU-rank and
with n-degenerate dependence for some n < ω. Then T has trivial dependence.
Proof sketch. Suppose that T satisﬁes the premises of the lemma. By Corollary
4.7 in [18] and Lemma 3.22 in [7], it is sufﬁcient to show that every type
with SU-rank 1 is trivial, i.e. if D is the set of realizations of the type, in Meq
where M is a sufﬁciently saturated model of T , then the restriction to D of
the algebraic closure operator forms a trivial pregeometry. For a contradiction,
suppose that there is a nontrivial type of SU-rank 1. By Corollary 3.17 in [7]
there is a deﬁnable subset of Meq on which the algebraic closure is a projective
geometry over a ﬁnite ﬁeld. Now a contradiction can be derived in the same
way as in the last two paragraphs of the proof of Proposition 8.7 in [8].
□
Now we can derive a corollary which applies to Ln-theories and amalgamation
classes. Suppose that  is a subset of L and T is a set of sentences from 
such that  is closed under subformulas, every unnested atomic formula of L
is equivalent, modulo T , to a formula in , and for every ¯x,  ¯x is ﬁnite up to
equivalence modulo T . Also suppose that A is a -amalgamation class for T .
Note that the assumptions about  hold if  = Ln and n is greater than the
arity of every symbol in the vocabulary. Then the assumptions of Lemma 3.3.9
and of Corollary 3.3.13 are satisﬁed, so by these results a unique limit of A
exists. By Lemma 3.3.12 and Proposition 3.3.18 the limit of A is ﬁnite or
ω-categorical.
Corollary 3.6.4
Assume that there is m < ω such that every function symbol
has arity at most m. Let T be a set of sentences from  ⊆L where  is closed

130
Vera Koponen
under subformulas. Suppose that, for every ¯x, ¯x is ﬁnite up to equivalence
modulo T and that every unnested atomic formula is equivalent to a formula in
, modulo T . Moreover, suppose that T has a -amalgamation class A with
a limit M such that M is simple with ﬁnite SU-rank and has both n-degenerate
forking for some n < ω and the k-embedding of types property with respect to
all generators for every 1 < k < ω. Then T has arbitrarily large ﬁnite models
(which can be taken as substructures of M).
The following example illustrates the notions and assumptions of the previous
corollary.
Example 3.6.5
Let the vocabulary of the language L be {=, E} where
E is a binary relation symbol. Let χ be the sentence ∀x1, x2

¬E(x1, x1) ∧
(E(x1, x2) →E(x2, x1))

. For every n ≥2 and every w ⊆{1, . . . , n −1} let
θn
w(x1, . . . , xn) be the formula

i∈w
E(xi, xn) ∧

i /∈w
¬E(xi, xn)
and let ϕn
w be the sentence
∀x1, . . . , xn−1
 
i̸=j
xi ̸= xj →∃xnθn
w(x1, . . . , xn)

.
Then let ϕn be the conjunction of χ and every ϕn
w as w ranges over subsets of
{1, . . . , n −1}, so ϕn ∈Ln. Also, every model of ϕn is an undirected graph, or
just ‘graph’ for brevity.
Fix an arbitrary natural number n ≥2. Recall that, by Deﬁnition 3.3.1,
M ≡Ln N means that M and N are Ln-elementarily equivalent, i.e. satisfy
exactly the same Ln-sentences, From the n-pebble game characterization of
Ln-elementary equivalence [23, 29] it follows that if M and N are models
of ϕn, then Duplicator (or “player II” or “∃”) has a winning strategy in the
n-pebble game on M and N in ω rounds, and therefore M ≡Ln N. It follows
that T n = {ϕn} is a complete Ln-theory (in the sense of Deﬁnition 3.2.1 (vii)).
Inﬁnite models of ϕn exist since for every sequence a1, . . . , an−1 from a
graph and every w ⊆{1, . . . , n −1} we can add a new element b to the graph
and extend the interpretetation of E so that E(ai, b) holds if and only if i ∈w.
By repeating this process systematically in ω steps (if we start with a ﬁnite
structure) we can make sure that the union of the graphs created in the process
is a model of ϕn. In fact, by reasoning similarly as has been outlined, we can
show the following.
(I) For every graph G (ﬁnite or inﬁnite) there is a graph M |= ϕn such that G
is a substructure of M.

Some connections between ﬁnite and inﬁnite model theory
131
From the n-pebble game characterization of ‘M ≡Ln N’ we can also derive the
the following.
(II) If M and N are models of ϕn, m < ω, a1, . . . , am ∈M are dif-
ferent elements and b1, . . . , bm ∈N
are different elements, then
(M, a1, . . . , am) ≡Ln (N, b1, . . . , bm) if and only if for all i, j ∈
{1, . . . , m}, M |= E(ai, aj) ⇐⇒N |= E(bi, bj).
Consequently, if M, N |= ϕn then every embedding f : M →N is an Ln-
elementary embedding. In particular, if M, N |= ϕn then M ≼Ln N if and only
if M is a substructure of N.
For every M |= ϕn and every A ⊆M, deﬁne cl(A) = A, so every subset of
every model of ϕn is closed. Let A be the class of all models of T n = {ϕn}. From
the deﬁnition of A it immediately follows that (1)–(3) in the deﬁnition of an Ln-
amalgamation class for T n (Deﬁnition 3.3.5) are satisﬁed. We verify that also
(4) in the same deﬁnition holds. Suppose that M1, M2 ∈A, a1, . . . , am ∈M1,
b1, . . . , bm ∈M2 and that
(M1, a1, . . . , am) ≡Ln (M2, b1, . . . , bm).
To simplify the argument, without loss of generality, we may assume that
ai = bi for i = 1, . . . , m, and that M1 ∩M2 = {a1, . . . , am}. By (I), the graph
M1 ∪M1 (where M1 ∪M2 |= E(a, b) ⇐⇒M1 |= E(a, b) or M2 |= E(a, b)) is
a substructure of some model N of T n = {ϕn}. Since M1, M2 |= ϕn, it follows
from (II) that Mi ≼Ln N for i = 1, 2. Hence A is an Ln-amalgamation class
for T n.
By Lemma 3.3.9 and Corollary 3.3.13, A has a unique limit M which is
countable (by the deﬁnition of limit). By Lemma 3.3.12, M is Ln-determined
which together with (II) implies that
(III) if m < ω, a1, . . . , am ∈M are different elements and b1, . . . , bm ∈M
are different elements, then (M, a1, . . . , am) ≡L (M, b1, . . . , bm) if and
only if for all i, j ∈{1, . . . , m}, M |= E(ai, aj) ⇐⇒M |= E(bi, bj).
Hence T hL(M) has elimination of quantiﬁers and is ω-categorical. Since M is
the limit of A, conditions (ii) and (iii) in Lemma 3.3.9 are satisﬁed. This together
with (I) implies that for every m < ω, every choice of distinct a1, . . . , am ∈M
and every w ⊆{1, . . . , m}, there is b ∈M such that M |= E(ai, b) ⇐⇒i ∈w.
Hence M |= ϕm for every 1 < m < ω. This implies that M is the random graph
[12, 20]. It is well-known that T hL(M) is simple with SU-rank 1 and has trivial
dependence [32]. In [26] it is shown that T hL(M) has the k-embedding of types
property with respect to all generators, for every 1 < k < ω. Note that since
M |= ϕm for every 1 < m < ω, we can, for every m < ω, ﬁnd ai, bi ∈M for

132
Vera Koponen
i < m such that M |= E(ai, bj) if and only if i ≤j. Hence M and A are not
stable in Ln.
Corollary 3.6.4 implies that T n = {ϕn} has arbitrarily large ﬁnite models
(all of which are isomorphic to substructures of M). This is nothing new, since
the proof of the so-called 0-1 law for the random graph shows that, for every
1 < n < ω, the number of graphs with universe m = {0, . . . , m −1} which
satisfy T n divided by the number of all graphs with universe m approaches 1 as
m →∞[12, 20]. At the core of the proof is a probabilistic argument (“What is
the probability that ϕn holds in a graph with universe m?”). The method in this
example of showing that ϕn has arbitrarily large ﬁnite models does not avoid
the main idea, the probabilistic argument, in the proof of the 0-1 law. On the
contrary, our approach has utilized this idea in a more general setting, but this
is not evident in this paper since we don’t discuss the proof of Theorem 3.6.1
or of Theorem 3.7.7, on which the former theorem relies.
Remark 3.6.6
It would be nice if we could specify some properties of com-
plete Ln-theories (without speaking about limits of amalgamation classes)
which, if they hold for such a theory, would allow us to derive the exis-
tence of a structure M as in Theorem 3.6.1. However, while the notion of
stability straightforwardly transfers from the context of complete L-theories
to complete Ln-theories (in Section 3.4) the notions ‘n-degenerate forking’,
‘SU-rank’ and ‘n-embedding of types property’ involve the stability/simplicity
theoretic notion of forking (or (in)dependence) and the author does not cur-
rently see a straightforward, or “natural”, way of deﬁning forking with respect
to a complete Ln-theory (which, according to our deﬁnition, need not be com-
plete in the usual sense). The notion of simplicity may, on the other hand,
be straightforwardly transferred to the context of complete Ln-theories by
saying that a complete Ln-theory is simple if no Ln-formula has the tree prop-
erty (see [32]) in any model of the theory. However, the question remains
whether simplicity, deﬁned in this way, has any interesting consequences for
Ln-theories.
3.7 Structures on which algebraic closure forms a
pregeometry
In this section we give a brief overview of the main results in [10], about
the ﬁnite submodel property, which are stated as Theorems 3.7.6 and 3.7.7
below. Theorem 3.7.7 is used to prove the main result in [26] (stated as Theo-
rem 3.6.1 in this survey). We will assume throughout this section that M is an

Some connections between ﬁnite and inﬁnite model theory
133
ω-categorical L-structure such that the algebraic closure in M, denoted aclM,
forms a pregeometry on M; see for instance [10] or [20] for a deﬁnition of a
pregeometry. A consequence of M being ω-categorical is that for every ﬁnite
A ⊆M, aclM(A) is ﬁnite. Moreover, in this context every subset A ⊆M has a
dimension deﬁned by
dimM(A) = inf{|B| : B ⊆A and A ⊆aclM(B)}.
A type is called algebraic if it has only ﬁnitely many realizations.
Deﬁnition 3.7.1
Let 0 < k < ω. We say that M is polynomially k-saturated if
there is a polynomial P(x) such that for every n0 < ω there is a natural number
n ≥n0 and a ﬁnite substructure N ⊆M such that:
(1) n ≤|N| ≤P(n).
(2) N is algebraically closed (in M).
(3) Whenever A ⊆N, dimM(A) < k and q(x) ∈SL
1 (A, M) is non-algebraic,
then there are distinct b1, . . . , bn ∈N such that M |= q(bi) (i.e. bi realizes
q in M) for each 1 ≤i ≤n.
Examples of structures on which the algebraic closure forms a pregeometry and
which are polynomially k-saturated for every 0 < k < ω include the “inﬁnite
empty structure” (having only the relation ’=’), the random (bipartite) graph,
inﬁnite vector spaces, projective spaces and afﬁne spaces over any ﬁnite ﬁeld
[10]. Another example is obtained by “independently” expanding a vector space
(for instance) with the random graph [10].
We also have the following result from [10] which relates polynomial k-
saturation to the ﬁnite submodel property.
Lemma 3.7.2
If M is polynomially k-saturated for every 0 < k < ω, then M
has the ﬁnite submodel property.
Assumption 3.7.3
From now on L is a ﬁrst-order language such that L’s
vocabulary is included in L’s vocabulary, so L ⊆L. We suppose that aclM
coincides with aclM↾L (i.e. aclM(A) = aclM↾L(A) for every A ⊆M). Moreover,
we assume that both M and M↾L have elimination of quantiﬁers, where M↾
L denotes the reduct of M to L. If these conditions are not fulﬁlled in the
beginning, then we can just add new relation symbols to L and L so that
the resulting expansions satisfy these conditions and all previous assumptions
about M.
Before going to the next deﬁnition we note that if aclM and aclM↾L coincide and
¯a, ¯b ∈M satisfy exactly the same L-formulas, then ¯a is algebraically closed if
and only if ¯b is.

134
Vera Koponen
Deﬁnition 3.7.4
We say that M satisﬁes the k-independence hypothesis over
L if the following holds:
Whenever A and B are algebraically closed substructures of M and
(1) dimM(B) ≤k,
(2) dimM(A) < k,
(3) f : A↾L →B↾L is an L-embedding (i.e. it preserves all atomic L-
formulas and negations of atomic L-formulas), and
(4) if A′ ⊂A (proper inclusion) is an algebraically closed substructure then
the restriction f : A′ →B is an L-embedding,
thenthereareanalgebraicallyclosedsubstructure C ⊆M andanL-ismorphism
g : B↾L →C↾L such that
(5) gf : A →C is an L-embedding, and
(6) for every algebraically closed substructure B′ ⊆B such that f (A) ̸⊆B′,
g : B′ →C is an L-embedding.
The deﬁnition of the k-independence hypothesis given above looks a
bit different from the deﬁnition of it given in [10], but the two ways
of deﬁning the k-independence hypothesis are equivalent under Assump-
tion 3.7.3. Below follow some examples which illustrate the k-independence
hypothesis.
Examples 3.7.5
(a) The random graph: Let the vocabulary of L be {=} and
let the vocabulary of L be {=, E} where E is a binary relation symbol. Let
M be the random graph in the language L where E is interpreted as the edge
relation. Then M and M↾L have elimination of quantiﬁers and aclM(A) = A
and dimM(A) = |A| for any A ⊆M. Since any ﬁnite graph embeds into M
it follows that M satisﬁes the k-independence hypothesis over L for every
k < ω. With the notation of the deﬁnition, the case when dimM(A) = 2 is
the most interesting. The reason is that M has elimination of quantiﬁers in
a language with only binary relations symbols and that dimension coincides
with cardinality.
(b) The random structure: Let L be as in (a) and let the vocabulary of L be
{=, R1, . . . , Rm} where Ri are relation symbols of any arity. Let M be the
random structure in the language L, i.e. M is the Fra¨ıss´e limit of the class
of all ﬁnite L-structures. For the same reasons as in (a), M satisﬁes the k-
independence hypothesis over L for every k < ω. However the veriﬁcation
becomes a little bit more interesting for A of dimension > 2 if L contains
relation symbols of arity greater than 2.

Some connections between ﬁnite and inﬁnite model theory
135
(c) A vector space expanded with the bipartite random graph: Let K be the
class of all ﬁnite structures
N = (V, P, E, +, f0, f1, 0) such that:
1. V , the universe of N, is a vector space over the ﬁeld F = {0, 1}.
2. P is a unary relation.
3. E is a binary relation symbol interpreted as an irreﬂexive and symmetric
relation.
4. + is a binary function symbol interpreted as vector addition and the constant
symbol 0 is interpreted as the zero vector.
5. fi(v) = i · v, for i = 0, 1 and any v ∈V (so fi represents scalar multiplica-
tion by i).
6. N |= ∀xy

E(x, y) →
 
P(x) ∧¬P(y)

∨

¬P(x) ∧P(y)
  
.
7. N |= P(0).
It is easy to verify that K is nonempty and has the hereditary property, the joint
embedding property and the amalgamation property and is uniformly locally
ﬁnite (see [20]). Hence the Fra¨ıss´e limit of K, which we call M, exists and
is ω-categorical with elimination of quantiﬁers. Since the reduct of M to the
language with vocabulary {=, P, E} is the random bipartite graph, M is not
smoothly approximable [3].
Let L ⊆L be the sublanguage which contains all symbols of L except
P and E. Then M↾L is a vector space over a ﬁnite ﬁeld, so M↾L has
elimination of quantiﬁers. It is not hard to see, using quantiﬁer elimination
of M and the fact that any structure in K can be embedded into M (since
M is the Fraiss´e limit of K), that aclM(A) is linear span of A. Hence aclM
and aclM↾L coincide. Again using the fact that M is the Fraiss´e limit of K it
follows that M satisﬁes the k-independence hypothesis over L, for every k < ω.
(d) The random pyramid-free (3)-hypergraph: As shown in [10], the random
pyramid-free (3)-hypergraph does not satisfy the 4-independence hypothesis
over the language L with vocabulary {=} (as opposed to the case of the random
graph).
Having Assumption 3.7.3 in mind, we now state the two main results of [10].
Theorem 3.7.6
Suppose that M↾L is polynomially k-saturated and that M
satisﬁes the k-independence hypothesis over L. If ϕ ∈L is an unnested sen-
tence, in which at most k distinct variables occur, and M |= ϕ, then ϕ has
arbitrarily large ﬁnite models.
Note that Theorem 3.7.6 only speaks about arbitrarily large ﬁnite models, but
does not claim that these can be taken as substructures of M.

136
Vera Koponen
Theorem 3.7.7
Suppose that, for every 0 < k < ω, M↾L is polynomially k-
saturated and that M satisﬁes the k-independence hypothesis over L. Then M
is polynomially k-saturated, for every 0 < k < ω, and thus M has the ﬁnite
submodel property.
We say that M has trivial (also called degenerate) algebraic closure if for every
A ⊆M, aclM(A) = 
a∈A aclM(a). Examples of (ω-categorical) M which are
simple with SU-rank 1 and trivial algebraic closure include the random (bipar-
tite) graph, the random structure and the random pyramid-free (3)-hypergraph.
The following is a consequence of the ﬁrst theorem:
Corollary 3.7.8
Suppose that M is simple with SU-rank 1 and has trivial
algebraic closure. If ϕ ∈L3 is unnested and M |= ϕ then ϕ has arbitrarily
large ﬁnite models.
The assumption that M satisﬁes the k-independence hypothesis (over L) in the
previous two theorems is used in the probabilistic argument at the core of the
proofs. It generalizes the argument used when showing that the random graph
(or random structure) satisﬁes a 0-1 law with the uniform probability measure.
The proofs of Theorems 3.7.6 and 3.7.7 do not however lead to 0-1 laws in
general, with the uniform probability measure.
It seems that without assuming any kind of independence we get into a
difﬁcult situation with respect to proving or disproving the ﬁnite submodel
property, as witnessed by the complete theory of the random pyramid-free
(3)-hypergraph (example (d) above). It is ω-categorical with elimination of
quantiﬁers, simple with SU-rank 1, has trivial dependence and trivial alge-
braic closure. However, for all k ≥4, it does not satisfy the k-independence
hypothesis over (the only proper sublanguage) L with vocabulary {=} [10].
It has neither the n-embedding of types property for any n ≥4, nor the
n-amalgamation property for any n ≥4 [25, 26]. It is an open problem
whether or not the random pyramid-free (3)-hypergraph has the ﬁnite submodel
property.
3.8 Questions and problems
In connection with the approach expounded in this paper one may of course
ask many questions, some of which are stated below.
(1) Can we ﬁnd “natural” amalgamation properties and stability/simplicity
theoretic properties for Ln-theories T (or other fragments of ﬁrst-order logic)
which imply the existence of an inﬁnite model M of T with the ﬁnite model

Some connections between ﬁnite and inﬁnite model theory
137
property (i.e. every sentence which is true in M is true in a ﬁnite model), for
other classes of theories T than those that ﬁt into the framework presented here
(in sections 1–3)?
(2) In particular, can we ﬁnd “natural” amalgamation properties and sta-
bility/simplicity theoretic properties for “simple” Ln-theories T (without a
stable amalgamation class) which guarantee that T has a model such as M in
Theorem 3.6.1?
(3) Can stronger upper bounds than recursive (exponential, polynomial etc.)
on the size of the smallest model be obtained for some interesting classes of
theories?
(4) Are there other approaches, than the one presented here, towards under-
standing when (arbitrarily large) ﬁnite models exist and when a recursive (or
better) upper bound of the smallest model exists, in terms of the number of
Ln-types, for instance?
(5) Can one derive the conclusions of Theorem 3.6.1 from a weaker assump-
tion than that forking is trivial?
(6) Can the approach in Section 9, about structures on which algebraic
closure forms a pregeometry, be helpful for understanding Ln-theories (or, say,
theories in a language with a ﬁnite bound on the quantiﬁer rank)?
(7) The random graph ﬁts within the framework presented in sections 3.6
and 3.7 as well as within the framework of ‘asymptotic classes’ and ‘measurable
structures’ [28, 13, 14, 15]. Do the two approaches have anything in common?
If ‘yes’, can both approaches together enrich our knowledge about relationships
between inﬁnite structures and classes of ﬁnite structures.
(8) Does the random pyramid-free (3)-hypergraph (Example 3.7.5 (d)) have
the ﬁnite submodel property?

References
[1] J. Baldwin, Finite and inﬁnite model theory - a historical perspective, Logic Journal
of the IGPL, Vol. 8 (2000) 605-628.
[2] J. Baldwin, O. Lessmann, Amalgamation properties and ﬁnite models in Ln-
theories, Archive for Mathematical Logic, Vol. 41 (2002) 155–167.
[3] G. Cherlin, E. Hrushovski, Finite structures with few types, Annals of Mathematics
Studies 152, Princeton University Press 2003.
[4] G. Cherlin, L. Harrington, A. H. Lachlan, ℵ0-categorical, ℵ0-stable structures,
Annals of Pure and Applied Logic, 28 (1985) 103–135.
[5] A. Dawar, Types and indiscernibles in ﬁnite models, in Logic Colloquium ’95,
Lecture Notes in Logic, Vol. 11, Springer.
[6] A. Dawar, S. Lindell, S. Weinstein, Inﬁnitary logic and inductive deﬁnability over
ﬁnite structures, Information and Computation, Vol. 119 (1995) 160–175.
[7] T. De Piro, B. Kim, The geometry of 1-based minal types, Transactions of the
Americal Mathematical Society, Vol. 355 (2003) 4241–4263.
[8] M. Djordjevi´c, Stability theory in ﬁnite variable logic, Ph.D. thesis, Uppsala Uni-
versity 2000.
[9] M. Djordjevi´c, Finite variable logic, stability and ﬁnite models, The Journal of
Symbolic Logic, Vol. 66 (2001) 837–858.
[10] M. Djordjevi´c, The ﬁnite submodel property and ω-categorical expansions of
pregeometries, Annals of Pure and Applied Logic Vol. 139 (2006) 201–229.
[11] M. Djordjevi´c, Finite satisﬁability and ℵ0-categorical structures with trivial depen-
dence, The Journal of Symbolic Logic, Vol. 71 (2006) 810–830.
[12] H-D. Ebbinghaus, J. Flum, Finite Model Theory, Second Edition, Springer Verlag,
1999.
[13] R. Elwes, Dimension and measure in ﬁnite ﬁrst order structures, PhD thesis,
University of Leeds, 2005.
[14] R. Elwes, Asymptotic classes of ﬁnite structures, The Journal of Symbolic Logic,
Vol. 72 (2007) 418–438.
[15] R. Elwes, H.D. Macpherson, A survey of asymptotic classes and measurable
structures, in Model theory and applications to algebra and analysis. Eds. Z.
Chatzidakis, H.D. Macpherson, A. Pillay, A.J. Wilkie, Cambridge University Press,
to appear.
138

Some connections between ﬁnite and inﬁnite model theory
139
[16] M. Grohe, Finite variable logic in descriptive complexity theory, The Bulletin of
Symbolic Logic, Vol. 4 (1998) 345–398.
[17] M. Grohe, Large ﬁnite structures with few Lk-types, Information and Computation,
Vol. 179 (2002) 250–278.
[18] B. Hart, B. Kim, A. Pillay, Coordinatisation and canonical bases in simple theories,
The Journal of Symbolic Logic, Vol. 65 (2000) 293–309.
[19] S. Hedman, Finitary axiomatizations of strongly minimal theories, Ph.D. thesis,
University of Illinois at Chicago, 1999.
[20] W. Hodges, Model theory, Cambridge University Press 1993.
[21] T. Hyttinen, On stability in ﬁnite models, Archive for Mathematical Logic, Vol.
39 (2000) 89–102.
[22] T. Hyttinen, Canonical ﬁnite diagrams and quantiﬁer elimination, Mathmatical
Logic Quarterly, Vol. 48 (2002) 533–554.
[23] N. Immerman, Upper and lower for ﬁrst order expressibility, Journal och Computer
and Systems Sciences, Vol. 25 (1982) 76–98.
[24] W. M. Kantor, M. W. Liebeck, H. D. Macpherson, ℵ0-categorical structures
smoothly approximated by ﬁnite substructures, Proceedings of the London Math-
ematical Society, Vol. 59 (1989) 439–463.
[25] B. Kim, A.S. Kolesnikov, A. Tsuboi, Generalized amalgamation and n-simplicity,
Annals of Pure and Applied Logic, Vol. 155 (2008) 97–114.
[26] V. Koponen, Independence and the ﬁnite submodel property, Annals of Pure and
Applied Logic, Vol. 158 (2009) 58–79.
[27] A. H. Lachlan, Stable ﬁnitely homogeneous structures: a survey, in B. T. Hart, A.
H. Lachlan, M. A. Valeriote, editors, Algebraic model theory, Kluwer Academic
Publishers (1997) 145–159.
[28] H.D. Macpherson, C. Steinhorn, One-dimensional asymptotic classes of ﬁnite
structures, Transactions of the American Mathematical Society, Vol. 360 (2008)
411–448.
[29] B. Poizat, Deux ou trois choses que je sais de Ln, The Journal of Symbolic Logic,
Vol. 47 (1982) 641–658.
[30] E. Rosen, Some aspects of model theory and ﬁnite structures, The Bulletin of
Symbolic Logic, Vol. 8 (2002) 380–403.
[31] S. Shelah, Classiﬁcation Theory, North–Holland 1990.
[32] F. O. Wagner, Simple theories, Kluwer Academic Publishers 2000.
[33] B. Zilber, Uncountably categorical structures, AMS translations of mathematical
monographs 117 (1993).

4
Deﬁnability in classes of ﬁnite structures
dugald macphersona and charles steinhornb
4.1 Introduction
This paper provides an overview of recent work by the authors and others on
two topics in the model theory of ﬁnite structures. The point of view here
differs from that usually associated with the term ‘ﬁnite model theory’, as
presented for example in [21] or [46], in which the emphasis and motivation
come primarily from computer science. Instead, the inspiration for this work has
its origins in contemporary (inﬁnite) model theoretic themes such as dimension,
independence, and various measures of the complexity of deﬁnable sets. Each
of the topics deals with classes of ﬁnite structures for ﬁrst-order logic that are
isolatedbyconditions that aredrawnfrom thesemodel-theoreticconsiderations.
Moreover, in both cases, connections exist to areas in inﬁnite model theory such
as stability and simplicity theory, and o-minimality. This survey is intended for
both mathematical logicians and computer scientists whose work focuses on
logical aspects of the subject.
The ﬁrst theme concerns asymptotic classes of ﬁnite structures. This subject
has its origins in the model theory of ﬁnite ﬁelds, via the work of Chatzidakis,
van den Dries and Macintyre [13] (see Theorem 4.2.1) and the earlier model
theory of ﬁnite ﬁelds developed by Ax [4], and ultimately rests on the Lang-
Weil bounds for the number of points in a ﬁnite ﬁeld of an irreducible variety
deﬁned over that ﬁeld. Given a ﬁrst-order formula ϕ in the language of rings, the
analysis in [13] provides estimates for the cardinality of the set deﬁned by this
formula in all ﬁnite ﬁelds in terms of two parameters, dimension and measure.
Denoting the universe of a ﬁnite ﬁeld by F, the cardinality estimate has the
a School of Mathematics, University of Leeds,Leeds LS2 9JT England
h.d.macpherson@leeds.ac.uk
b Vassar College, Poughkeepsie, New York 12604, USA steinhorn@vassar.edu; partially
supported by U.S. National Science Foundation Grant DMS-0070743.
140

Deﬁnability in classes of ﬁnite structures
141
form µ|F|k, where k represents the dimension and µ the measure of the size of
the set deﬁned by ϕ. Asymptotic classes are, roughly speaking, classes of ﬁnite
structures with a strong uniformity condition on the cardinality of deﬁnable
sets that mirrors precisely that for ﬁnite ﬁelds (see [22], [25], or [48]). Indeed,
ﬁnite ﬁelds, as developed in [13], provides a key example, but there are many
others. Ryten [52] has shown that certain difference ﬁelds, and hence any family
of ﬁnite simple groups of ﬁxed Lie rank, ﬁt into this framework, and Elwes
[23] has established that every smoothly approximable structure admits a class
of (ﬁnite) envelopes which forms an asymptotic class that witnesses smooth
approximability. The uniformity properties of asymptotic classes feed through
to ultraproducts of the members of any such class: they are supersimple of ﬁnite
rank, with an additional ingredient, still rather mysterious, called measure.
The second topic, robust classes of ﬁnite structures, has its origins in an
attempt to bring an appropriate version of o-minimality to classes of ﬁnite
structures. Obstacles quickly present themselves: for example, no class of
ﬁnite totally ordered structures can be an asymptotic class – see [25] or [48].
In fact, every o-minimal structure elementarily equivalent to an ultraproduct of
totally ordered ﬁnite structures must be discretely ordered, and thus carry very
limited structure [51]. A robust class is a directed system of ﬁnite structures with
embeddings, such that any formula, interpreted in a structure in the class that is
sufﬁciently large relative to the parameters appearing in the formula, assumes
a constant truth value. In this setting, a non-trivial notion of o-minimality may
be deﬁned. For example, the group (Q, +, <), with + interpreted as a ternary
relation, is the direct limit of an o-minimal robust class of ﬁnite structures. The
initial theory of robust classes has been developed by the authors, and in the
Ph.D. thesis of Macpherson’s student, R. Marshall [49]. It is our hope is that
connections eventually will emerge between the two topics of this survey and
current concerns of ﬁnite model theory. This seems particularly possible for
robust classes; here Ehrenfeucht-Fra¨ıss´e games intervene, locality can play a
role, and there are very natural, if still rudimentary, notions of complexity.
The organization of this paper is as follows. Asymptotic classes are intro-
duced in Section 4.2, and examples are the focus of Sections 4.3, 4.4 and 4.6.
Smoothly approximable structures, which provide important examples for both
asymptotic classes and robust classes, are given a brief overview in Section 4.4.
Section 4.5 links asymptotic classes with contemporary inﬁnite model the-
ory, in particular simple theories, and introduces the notion of a measurable
structure. Asymptotic classes of groups, with connections to simple theories,
are treated in Section 4.6. Robust classes are introduced in Section 4.7 and
Section 4.8 is devoted to examples. In the ﬁnal section of the paper, Section 4.9,
an ‘o-minimal’ robust approximation of the ordered group of rational numbers

142
Dugald Macpherson and Charles Steinhorn
is presented. Notation throughout is standard; any uncommon terminology or
notation is deﬁned where it arises.
4.2 Asymptotic classes
The starting point here is the following theorem of Chatzidakis, van den Dries,
and Macintyre. One considers, uniformly across ﬁnite ﬁelds, families of deﬁn-
able sets determined by formulas ϕ(¯x, ¯y), where the ¯y are parameter-variables.
Theorem 4.2.1 ([13])
Let ϕ(¯x, ¯y) be a formula in the language Lrings =
(+, ×, −, 0, 1) for rings, with ¯x = (x1, . . . , xn) and ¯y = (y1, . . . , ym). Then
there is a positive constant C, and a ﬁnite set D of pairs (d, µ) with d ∈
{0, . . . , n} and µ a non-negative rational number, such that for each ﬁnite ﬁeld
Fq and ¯a ∈Fm
q ,
|ϕ(Fn
q, ¯a)| −µqd ≤Cqd−(1/2)
(∗)
for some (d, µ) ∈D.
Furthermore, for each (d, µ) ∈D, there is a formula ϕ(d,µ)(¯x) which deﬁnes
in each ﬁnite ﬁeld Fq the set of tuples ¯a such that (∗) holds.
Each such pair (d, µ) may be understood as providing a ﬁnite combinatorial
version of the dimension d and measure µ of those deﬁnable sets to which the
pair corresponds. For formulas which deﬁne absolutely irreducible varieties –
without the µ – this is the result of Lang-Weil [45]. A ‘near model complete-
ness’ result of Kiefe [40], coming rapidly out of Ax’s work [4], asserts that
every formula ϕ(¯x) is equivalent, uniformly across ﬁnite ﬁelds, to a boolean
combination of formulas ∃yg(¯x, y) = 0 where g( ¯X, Y) ∈Z[ ¯X, Y]. This sug-
gests why the above theorem should hold: one can reduce deﬁnable sets to sets
built from ﬁnite-to-one projections of varieties. The details are intricate.
Theorem 4.2.1 suggests that one might consider arbitrary classes of ﬁnite
structures satisfying asymptotic uniformities in the spirit of the theorem. Note
that there are possible natural weakenings of the conditions. First, one could
weaken the error term Cqd−(1/2). There also is perhaps no reason to require
µ to be rational. Additionally, and most importantly, the class of ﬁnite ﬁelds
is in a sense 1-dimensional: any formula uniformly picking out an arbitrarily
large subset of the ﬁeld (in afﬁne 1-space) picks out a positive fraction of the
ﬁeld. Thus, for example, Theorem 4.2.1 answers a question of Felgner (that
in fact inspired the paper), showing that Fq is not uniformly deﬁnable in Fq2.
One could easily consider the universe F of a structure to be N-dimensional
if all deﬁnable subsets of F are roughly of size µ|F|d/N for d ∈{0, 1, . . . , N}

Deﬁnability in classes of ﬁnite structures
143
and µ a constant. These considerations lead to the following deﬁnition of
Elwes [22] of an N-dimensional asymptotic class of ﬁnite structures. For the
initially considered concept, 1-dimensional asymptotic classes, see [48]. A
more extensive survey of asymptotic classes than provided here, with more
emphasis on the inﬁnite limits, may be found in [25].
Deﬁnition 4.2.2 (Elwes, [23])
Let N ∈N, and let C be a class of ﬁnite L-
structures, where L is a ﬁnite language. Then we say that C is an N-dimensional
asymptotic class if the following hold.
(i) For every L-formula ϕ(¯x, ¯y) where l(¯x) = n and l( ¯y) = m, there is a
ﬁnite set of pairs D ⊆({0, . . . , Nn} × R>0) ∪{(0, 0)} and for each (d, µ) ∈D
a collection (d,µ) of pairs of the form (M, ¯a) where M ∈C and ¯a ∈Mm, so
that {(d,µ) : (d, µ) ∈D} is a partition of {(M, ¯a) : M ∈C, ¯a ∈Mm}, and
|ϕ(Mn, ¯a)| −µ|M|
d
N  = o(|M|
d
N )
as |M| −→∞and (M, ¯a) ∈(d,µ).
(ii) Each (d,µ) is ∅-deﬁnable, that is to say {¯a ∈Mm : (M, ¯a) ∈(d,µ)} is
uniformly ∅-deﬁnable across C.
We may write Dϕ for D in the deﬁnition above, and call {(d,µ) : (d, µ) ∈D}
a (deﬁnable) asymptotic partition. We deﬁne h(ϕ(Mn, ¯a)) to be the pair
(Dim(ϕ(Mn, ¯a)), Meas(ϕ(Mn, ¯a))),
which equals (d, µ) if (M, ¯a) ∈(d,µ), except that if d = µ = 0 we work with
the convention that Dim(ϕ(Mn, ¯a)) = −1.
The o-notation in (i) here means that for every ε > 0 there is Q ∈N such
that for all M ∈C with |M| > Q and all ¯a ∈Mm, where (M, ¯a) ∈d,µ, we
have
|ϕ(Mn, ¯a)| −µ|M|
d
N  < ε|M|
d
N .
We call C a weak asymptotic class if C satisﬁes the asymptotic criterion (i)
for all ϕ, but the (d,µ) are not assumed to be deﬁnable. We do not discuss
the intermediary condition that the (d,µ) are deﬁnable but not necessarily
∅-deﬁnable.
It is clear that clause (i) is preserved by reducts; that is, by the process of
restricting the class of structures to the reducts in a sublanguage. In fact, by
Lemma 3.7 of Elwes [22], it is preserved by parameter-interpretations which
are uniform in the sense that the interpreting formulas range through a ﬁnite set.
However, clause (ii) may by lost under interpretations, though it is preserved
under parameter-free bi-interpretations ([22], Lemma 3.7).

144
Dugald Macpherson and Charles Steinhorn
In inﬁnite model theory, the deﬁnition of o-minimality (see e.g., [20]) places
a restriction on the deﬁnable sets in one variable: a totally ordered structure is
o-minimal if every deﬁnable set is a ﬁnite union of open intervals and points.
The Cell Decomposition Theorem in this context yields topological and logical
ﬁniteness properties for n-variable deﬁnable sets. By the following theorem,
which might be viewed as a combinatorial cell decomposition theorem, the
story is essentially the same for asymptotic classes, though we have chosen
here to have the deﬁnition focus on the n-variable condition. The proof makes
heavy use of clause (ii).
Theorem 4.2.3 (Lemma 2.1.2 of [23]; Theorem 2.1 of [48])
Suppose that C is
a class of ﬁnite structures which satisﬁes Deﬁnition 4.2.2 (clauses (i) and (ii))
for n = 1, i.e. for deﬁnable sets in one variable. Then C is an N-dimensional
asymptotic class.
Its proof, an induction on n, is analogous to that of the Cell Decomposi-
tion Theorem for o-minimal structures, with asymptotic calculations replacing
topological arguments. For a deﬁnable subset X of Mn+1 let π : Mn+1 →M
denote projection to the ﬁrst coordinate. Then apply the deﬁnition to π(X) and
the inductive hypothesis to the ﬁbers Xa for a ∈π(X). Note for every pair
(d, µ) that {a ∈M : h(Xa) = (d, µ)} is an ∅-deﬁnable subset of M, by clause
(ii), so itself has a speciﬁed dimension and measure.
The next section provides many examples of asymptotic classes. As a
paradigmatic non-example – see Remark 4.5.2 (d) – observe that the collection
of all ﬁnite total orders is not an asymptotic class: if ϕ(x, y) is the formula
x < y, then as a ranges through a ﬁnite totally ordered structure M, ϕ(M, a)
is a subset of M of arbitrary size.
4.3 Examples of asymptotic classes
The most interesting of the examples below are associated with ﬁnite ﬁelds.
We see it as an area of signiﬁcant interest to ﬁnd new classes of examples with
no connection to ﬁnite ﬁelds.
Example 4.3.1
The class of all ﬁnite ﬁelds forms a 1-dimensional asymptotic
class, by the main theorem of [13].
Example 4.3.2
A difference ﬁeld is a pair (F, σ) where F is a ﬁeld and
σ is an automorphism of F. Fix a prime p, and positive integers m, n with
m ≥1, n > 1, and (m, n) = 1. Let C(m,n,p) be the collection of difference ﬁelds
(Fpkn+m, Frobk) where k > 0 and Frob denotes the Frobenius automorphism

Deﬁnability in classes of ﬁnite structures
145
x →xp; so m, n, p are ﬁxed in the class, but k is varying. Then, by Theo-
rem 3.5.8 of [52], C(m,n,p) is a 1-dimensional asymptotic class. Note that the
ﬁxed ﬁeld of σ : x →xpk on Fpkn+m is Fpt where t = (k, m), so has bounded
size. Ryten’s result rests upon the main results of Hrushovski [37]: the asymp-
totic results for difference varieties, and the identiﬁcation of the ultraproduct
theory of (¯Fp, x →xpk) with the theory ACFAp, the model companion of
the theory of characteristic p difference ﬁelds; here ¯Fp denotes the algebraic
closure of Fp.
Example 4.3.3
By further results of Ryten [52, Chapter 5], every family
of ﬁnite simple groups of ﬁxed Lie type is an asymptotic class. The Lie type
here in particular determines the Lie rank, that is the number of nodes of the
associated Dynkin diagram (or orbits on nodes under the corresponding graph
automorphism, in the case of twisted groups). For example, the groups PSL3(q),
with q varying, form a family of ﬁnite simple groups of ﬁxed Lie type and Lie
rank 2, corresponding to the Dynkin diagram with two nodes joined by a single
edge, so form an asymptotic class. The groups PSU3(q), which are subgroups
of PSL3(q2), also form an asymptotic class. Here we view the alternating group
Altn as having Lie rank n, and these do not form an asymptotic class as n grows
with the size of the group; indeed, the model theory of the ﬁnite alternating
groups, like the model theory of groups PSLn(q) for ﬁxed q and increasing n,
seems to be completely wild. For undecidability of the theory of all ﬁnite
symmetric groups, or for various families of n × n matrix groups with
unbounded n over a ﬁxed ﬁeld, see [27], or [12, Section 6.3] for a survey.
Also, see [2] for a treatment of non-standard alternating groups as objects in
Peano Arithmetic. For separate reasons, the (simple) cyclic groups of prime
order also form an asymptotic class – see Example 4.3.5 below.
Most of the families of ﬁnite simple groups are uniformly parameter bi-
interpretable (even bi-deﬁnable), in a natural sense, with ﬁnite ﬁelds (see
Chapter 4 of [52]). Using results of Elwes and Ryten, it follows that the
property of being an asymptotic class transfers from the ﬁelds to the groups,
though care is needed with clause (ii) in Deﬁnition 4.2.2, due to the role of
parameters in the interpretations.
For example, for any ﬁxed n the groups PSLn(q) and PSUn(q) are both
(uniformly in q) bi-interpretable with the ﬁeld Fq; details can be found in
Chapter 5 of [52]. The uniform interpretation of the PSLn(q) in Fq is almost
immediate from the deﬁnition of PSLn(q). More generally, for a given family
of Chevalley groups of Lie type L, such as the family of symplectic groups
PSp2m(q), we can uniformly in Fq interpret the Lie algebra L(Fq), hence the
general linear group GL(L(Fq)), and inside this the family of root subgroups

146
Dugald Macpherson and Charles Steinhorn
which generate Sp2m(q). Since the symplectic group is a product of a bounded
number, dependent only on m, of these root subgroups, it is itself uniformly
interpretable in Fq, and hence so is PSp2m(q). In the other direction, to construct
the ﬁeld Fq inside PSLn(q), the additive structure is given by a root group. The
multiplicative structure of the ﬁeld arises from a torus – which is conjugate to
the image in PSLn(q) of an appropriate diagonal subgroup of SLn(q) – acting
on the root group. See also [59] and [42].
For the families of Suzuki and Ree twisted simple groups, the situation is
rather more complicated. The construction involves an automorphism of the
Dynkin diagram which does not preserve lengths of roots. As a result, these
groups are uniformly parameter bi-interpretable not with pure ﬁelds, but with
difference ﬁelds. The class of Suzuki groups 2B2(22k+1) is uniformly parameter
bi-interpretable with the clas C(1,2,2), as is the class of Ree groups 2F4(22k+1).
The Ree groups 2G2(32k+1) are uniformly parameter bi-interpretable with the
members of C(1,2,3). In these cases we apply Example 4.3.2 above.
Example 4.3.4
The families of simple groups of Lie type all arise as automor-
phism groups of Tits buildings. The building blocks for these are the so-called
‘rank 2 residues’, which are generalized polygons. Here, a generalized polygon
is an incidence structure of points and lines such that the associated bipartite
incidence graph – which has the points and lines as vertices with incidence
for adjacency – has diameter n and girth 2n. A generalized n-gon is said to
be thin if it is an ordinary n-gon, and is thick if every point (respectively line)
is incident with at least three lines (respectively points). A thick generalized
3-gon is just a projective plane. The generalized polygons involved in ﬁnite sim-
ple groups satisfy an additional symmetry condition, the ‘Moufang’ property.
Moufang generalized polygons have been classiﬁed by Tits and Weiss [61].
In particular, there are seven families of ﬁnite Moufang generalized polygons,
each such polygon associated with its corresponding ‘little projective group.’
Dello Stritto [19] shows that each of these seven families forms an asymptotic
class by proving that the polygons are uniformly parameter bi-interpretable
with their corresponding little projective groups, as each corresponding class
of groups forms an asymptotic class, by Example 4.3.3 above.
Example 4.3.5
By [48, Theorem 3.14], the collection of all ﬁnite cyclic
groups is a 1-dimensional asymptotic class. This is hardly surprising, as the
multiplicative groups of ﬁnite ﬁelds are cyclic. In general, the result follows
from Szmielew’s Theorem (see for example [31, Theorem A.2.2]), which says
that in every abelian group every formula ϕ(x, ¯y) is equivalent to a boolean
combination of formulas of the form pm|t(x, ¯y) or t(x, ¯y) = 0, where p is

Deﬁnability in classes of ﬁnite structures
147
prime, t is a term, and pm|t(x, ¯y) abbreviates (∃z) pmz = t(x, ¯y). By the Com-
pactness Theorem, there is a ﬁnite family of such boolean combinations, one of
which will be equivalent to ϕ in each abelian group. The argument then reduces
to examining a conjunction of such conditions and their negations. Observe,
by Theorem 4.2.3, that it sufﬁces to consider formulas ϕ(x, ¯y), i.e., families of
deﬁnable sets in one variable x.
Example 4.3.6
Recall that the random graph is the unique countably inﬁnite
graph that satisﬁes, for each n > 0, the following sentence σn, where Rxy
denotes that vertices x and y are adjacent:
∀x1 . . . xn, ∀y1, . . . yn


1≤i,j≤n
xi ̸= yj
→∃z

n

1=1
Rzxi ∧z ̸= xi ∧
n

i=1
¬Rzyi ∧z ̸= yi

.
The Paley graph Pq , where q is a prime power with q ≡1 (mod 4), has
vertex set Fq and edge relation given by x, y ∈Fq are adjacent if and only
if x −y is a square in Fq. The collection C of all Paley graphs forms a 1-
dimensional asymptotic class – see [48, Example 3.4]. The essential point here
is due to Bollob´as and Thomason [9] (see also [10, Ch. XIII.2]). If U and W are
disjoint sets of vertices in the Paley graph Pq with |U ∪W| = m, and v(U, W)
is the number of vertices of Pq not in U ∪W joined to each vertex of U and
none of W, then
|v(U, W) −2−mq| ≤1
2(m −2 + 2−m+1)q
1
2 + m/2.
It follows that every non-principal ultraproduct satisﬁes each σn, so is elemen-
tarily equivalent to the random graph. As the latter has quantiﬁer elimination,
to check that C is an asymptotic class it sufﬁces to consider quantiﬁer-free
formulas, which are handled by the above asymptotic estimates.
Thus the Paley graphs form a class of ﬁnite graphs whose theory approxi-
mates the random graph and witness that the random graph has the ﬁnite model
property, that is, every sentence true of the random graph, and in particular the
above axioms σn for n ≥1, has a ﬁnite model and in fact hold in almost all
ﬁnite graphs.
If one works instead with primes congruent to 3 mod 4, then −1 is a non-
square, so the relation R deﬁned above is antisymmetric, and one obtains a 1-
dimensional asymptotic class of Paley tournaments, whose theory approximates
the random tournament. Here a tournament is a directed graph such that any

148
Dugald Macpherson and Charles Steinhorn
two vertices are connected by an arc. The analogue of the result of Bollob´as
and Thomason can be found in [29].
It would be interesting to ﬁnd other asymptotic classes of graphs approxi-
mating the random graph, e.g. not corresponding to edge probability 1/2. Work
of Sz¨onyi [57] may be relevant here.
Example 4.3.7
The random graph has, for each k > 2, an arity k analogue,
the countable universal homogeneous k-uniform hypergraph. Here, a k-uniform
hypergraph is just a set equipped with a collection of k-element subsets, the
hyperedges. Like the random graph, its theory is axiomatized by ‘extension
axioms’, which hold with probability tending to one in ﬁnite k-uniform hyper-
graphs. There is no na¨ıve arity k analogue of the Paley graphs, but Beyarslan [7]
has shown that the random k-uniform hypergraph is interpretable in a pseud-
oﬁnite ﬁeld, that is, an inﬁnite model of the theory of ﬁnite ﬁelds. Hence,
there is a family of ﬁnite k-uniform hypergraphs, uniformly interpretable in
ﬁnite ﬁelds, with an ultraproduct elementarily equivalent to the random k-
uniform hypergraph. This certainly yields a weak asymptotic class of ﬁnite
k-uniform hypergraphs whose theory approximates the random one. So far as
we know, it has not been checked whether it is an asymptotic class, i.e., satisﬁes
Deﬁnition 4.2.2(ii).
Example 4.3.8
Recall that a theory T is strongly minimal if, in all models of
T , every deﬁnable subset of the domain is ﬁnite or coﬁnite. Suppose that C is a
class of ﬁnite structures such that every non-principal ultraproduct is strongly
minimal. It follows rather easily, by Theorem 4.2.3, that C is a 1-dimensional
asymptotic class – see Example 3.9 of [48]. In particular, for every positive
integer d > 2, the collection of all ﬁnite vertex transitive graphs of valency d is
a 1-dimensional asymptotic class. Indeed, an ultraproduct is a vertex transitive
graph of valency d, and all such are well-known to be strongly minimal; see
for example [8], Lemma 2.2.11.
Example 4.3.9
Lastly, let M be a smoothly approximable structure – see
Section 4.4 directly following this example for a fuller discussion of smooth
approximability. Then M is a union of a chain of ﬁnite so-called ‘envelopes’. It
was shown by Elwes [22] that these envelopes can be chosen to form an asymp-
totic class. This rests on the asymptotic information on the sizes of deﬁnable
sets in [18, Proposition 5.2.2]. In particular, suppose that M is unidimensional,
that is, up to non-orthogonality has a unique family of deﬁnable Lie geometries.
Then the asymptotic bounds are much tighter than in Deﬁnition 4.2.2. Namely,
one ﬁnds that if the class C is N-dimensional, E ∈C, and D is a d-dimensional
deﬁnable subset of measure µ of E, then for some ﬁxed constant C depending

Deﬁnability in classes of ﬁnite structures
149
just on M, it follows that
|D| −µ|E|
d
N  < C|E|
d
N −1
N .
In the non-unidimensional case, the asymptotic behavior is not so clear –
consider for example a countably inﬁnite structure consisting of the disjoint
union of two ℵ0-dimensional vector spaces, one over F2 and the other over F3.
It is not clear how to approximate these by a class of ﬁnite substructures so that
a conclusion like that in Theorem 4.2.1 holds. This is the reason for the weaker
error term, in the form o(|M|
d
N ), in Deﬁnition 4.2.2. Smoothly approximable
structures are relevant also to robust classes, and we discuss them further in the
next section.
4.4 Smoothly approximable structures
The notion of smooth approximation appears to be due originally to Lachlan;
it plays a role already in [15] and [16]. The ﬁrst systematic investigation of
smooth approximation is [39], and a deep theory was developed by Cherlin
and Hrushovski in the monograph [18]. There also are two excellent survey
accounts, [35] and [17].
A ﬁnite substructure N of a structure M is a k-homogeneous substructure
of M if all ∅-deﬁnable relations on M induce ∅-deﬁnable relations on N, and
for every pair ¯a, ¯b of k-tuples from N, they have the same type in N if and only
if they have the same type in M. An ℵ0-categorical structure M is smoothly
approximated if it is the union of a chain (Mi : i ∈N) of ﬁnite substructures,
where for each i, Mi is an |Mi|-homogeneous substructure of M.
As a very basic example, let M be an ℵ0-dimensional vector space over
the ﬁnite ﬁeld Fp, and let the Mi for i ∈N form a sequence of ﬁnite sub-
spaces with Mi ≤Mi+1 and with 
i∈N Mi = M. These structures are parsed
in the language of Fp-modules, that is the language for M as a group under
addition, and a unary function symbol for multiplication by each element of
Fp. The point here is that if Dim(Mi) = ni then we have a natural sequence
of embeddings GLn0(p) ≤GLn1(p) ≤GLn2(p) ≤· · · , and the union of this
sequence of groups has the same orbits on n-tuples from M as Aut(M), which is
GLℵ0(p).
For a slightly more complicated example, suppose that M is endowed with
a symplectic form, that is, a non-degenerate bilinear form β : M × M →Fp
such that β(v, v) = 0 for all v ∈M, and let the Mi form a sequence of ﬁnite
(even dimensional) subspaces with union M, on each of which β induces a
non-degenerate form. Here, β can be given by a family of binary relations,

150
Dugald Macpherson and Charles Steinhorn
one for each element of Fp. The fact that each Mi is an |Mi|-homogeneous
substructure of M is a consequence of Witt’s Lemma – see for example
Section 20 of [3].
These two smoothly approximable structures are both examples of Lie
geometries (see [39] or [18]), about which we say more below. The ﬁrst is
totally categorical, even strongly minimal. The second is not stable (it has
the independence property; see, e.g., [31]) but is supersimple of rank 1 (see
Remark 4.5.2(c) for more about simple theories). We remark that the random
graph is not smoothly approximable, even though it is also supersimple of
rank 1, ℵ0-categorical, and arises in a natural way as a union of a chain of Paley
graphs (see Example 4.8.3).
Let M be smoothly approximable. As M is ℵ0-categorical, the Ryll-
Nardzewski Theorem yields a function g : N →N such that for each k ∈N,
the automorphism group of M, Aut(M), has at most g(k) orbits on Mk. It fol-
lows that if (Mi : i ∈ω) is a sequence of ﬁnite substructures witnessing smooth
approximability, then Aut(Mi) has at most g(k) orbits on Mk
i , for each i, k ∈ω.
This is a very strong condition on a family of arbitrarily large ﬁnite permutation
groups. In fact, a posteriori, the condition holds for all k if one just knows the
condition for k ≤4. Using ﬁnite permutation group theory – the classiﬁcation
of ﬁnite simple groups, the O’Nan-Scott Theorem, and Aschbacher’s struc-
ture theory for subgroups of classical groups – the authors in [39] were able
to classify all smoothly approximable structures with primitive automorphism
groups, that is, automorphism groups which preserve no proper non-trivial
equivalence relation. In particular, certain building blocks, the Lie geometries,
were identiﬁed. These include pure sets, examples like those described in the
preceding paragraphs (possibly with orthogonal or unitary bilinear forms), and
their projective and afﬁne versions. There is also the ‘self-dual geometry’,
which is really a pair of inﬁnite dimensional vector spaces V, V ′ over a ﬁnite
ﬁeld Fq equipped with a non-degenerate bilinear map V × V ′ →Fq, and the
‘quadratic geometry’. The somewhat more mysterious latter is essentially the
collection of all quadratic forms associated with a given symplectic form on an
ℵ0-dimensional vector space over a ﬁnite ﬁeld of characteristic 2.
A very beautiful structure theory of smoothly approximable structures is
developed in [18]. We provide a brief overview.
As shown in [15], every ℵ0-categorical ω-stable structure – in particular
every totally categorical structure, and every stable structure homogeneous over
a ﬁnite relational language – is smoothly approximable. This is already quite
a deep result, and includes rather complicated structures built, by a sequence
of ﬁnite and afﬁne covers, from pure sets and projective or afﬁne spaces over
ﬁnite ﬁelds. See for example [15], [1] and [32].

Deﬁnability in classes of ﬁnite structures
151
Smoothly approximable structures which are not ω-stable are all unstable.
Indeed, any stable ω-categorical structure which is not ω-stable interprets a
pseudoplane [43], and by [18, Corollary 5.5.5] a pseudoplane cannot be inter-
preted in any smoothly approximable stucture. However, all smoothly approx-
imable structures have a simple theory–see Remark 4.5.2(c) for basic facts
about simple theories, and [62] for a general source – and in fact they are
supersimple of ﬁnite rank (see Remark 4.5.2). Indeed, some crucial ideas in
simplicity theory, such as the Independence Theorem, ﬁrst appeared in [18]
(see e.g. Section 5.1 and Proposition 8.4.3 of [18]). They are 1-based (see
Section 4.5 for the deﬁnition; that they are 1-based may be found in [18]), and
thus in particular, no inﬁnite ﬁeld is deﬁnable. Although ﬁnite ﬁelds play a key
role in any family of ﬁnite approximating structures, any ﬁeld involved remains
ﬁxed throughout the family.
All groups deﬁnable in a smoothly approximable structure are ﬁnite-by-
abelian-by-ﬁnite (see [18]). As noted in Section 4.6 (see Proposition 4.6.2 ff.),
extraspecial p-groups of exponent p are smoothly approximable and ﬁnite-by-
abelian, but not abelian-by-ﬁnite.
Cherlin and Hrushovski deﬁne the notion of a Lie coordinatizable structure.
This is a structure bi-interpretable with a Lie coordinatized structure, which is,
roughly speaking, one coordinatized by a tree of ﬁnite height of Lie geometries.
A key fact proved in [18] is that the Lie coordinatizable structures are exactly
the smoothly approximable structures. Arguments by induction on the height
of the coordinatizing tree thus are often used.
Smoothly approximable structures also are quasi-ﬁnitely axiomatizable.
This means that the theory is axiomatized by a single sentence together with
a schema of axioms saying that each ‘non-orthogonality class’ of Lie geome-
tries (again, see [18]) is inﬁnite dimensional. In particular, if the smoothly
approximable structure is unidimensional, that is, any two interpretable Lie
geometries are non-orthogonal, then the theory is axiomatized by a single sen-
tence together with, for each n, a sentence saying that the structure has size at
least n. This generalizes an earlier result of Hrushovski [32], itself extending
work of Ahlbrandt and Ziegler [1], that all totally categorical structures are
quasi-ﬁnitely axiomatized in this last sense.
Built into Lie coordinatizability is a theory of the envelopes – that is,
the ﬁnite approximating substructures – of smoothly approximable struc-
tures. There are precise results in [18] on the cardinalities of deﬁnable sets
in envelopes, given by certain polynomials. This is exploited in [22] to
show the envelopes can be chosen to form an asymptotic class, so yields
Example 4.3.9 above. It also suggests that there may be interesting strength-
enings of the notion of asymptotic class, where one considers classes of ﬁnite

152
Dugald Macpherson and Charles Steinhorn
structures in which the sizes of deﬁnable sets, with respect to a ﬁxed formula
ϕ(¯x, ¯y), are given not by asymptotic conditions, but by one of ﬁnitely many
polynomials. So far as we know, this has not been explored. In addition, Lach-
lan’s theory [44] of ‘shrinking and stretching’, developed for the class of ﬁnite
structures homogeneous over a ﬁxed ﬁnite relational language, holds in the
smoothly approximable context too.
It also follows from the theory that, over a ﬁxed ﬁnite language L, if C is
a class of ﬁnite structures for which there is some k such that Aut(M) has at
most k orbits on M4 for all M ∈C, then there is g : N →N such that for all
M ∈C and all k ∈N, Aut(M) has at most g(k) orbits on Mk. See for example
Theorem 6 of [18].
Smooth approximability is not preserved by reducts, due to problems with
the quadratic geometries mentioned above – see the example due to Evans in
[18, p. 149]. Yet the class of reducts, namely the weakly Lie coordinatizable
structures, also is fairly well understood. In particular, the class of weakly Lie
coordinatizable structures is characterized by the conjunction of nine model-
theoretic properties (Theorem 7 in [18]), among which are ℵ0-categoricity,
pseudoﬁniteness (or the ﬁnite model property), ﬁniteness of a certain rank,
the Independence Theorem, and some more technical conditions. Intriguingly,
whereas the bulk of the structure theory of [18] rests ultimately on the classiﬁca-
tion of ﬁnite simple groups, this last result does not, even though it characterizes
a class of structures intimately connected to ﬁnite simple groups.
4.5 Asymptotic classes and their ultraproducts
We have already seen that investigations of asymptotic classes can be assisted
by working with ultraproducts. This is already explicit in [13] on ﬁnite ﬁelds.
Indeed, recall that a pseudoﬁnite ﬁeld is an inﬁnite model of the theory of ﬁnite
ﬁelds. Equivalently, by Ax [4] it is a ﬁeld F which is perfect, quasiﬁnite (has
a unique extension of degree n for each n > 1), and is pseudo-algebraically
closed (PAC) (that is, every absolutely irreducible variety deﬁned over F has
an F-rational point). It is shown in [13] that, by Theorem 4.2.1, if F is a
pseudoﬁnite ﬁeld then it is possible to associate with each deﬁnable subset D
of each power F t a pair (d, µ), where d is a nonnegative integer and µ ∈Q>0,
such that d is the algebraic-geometric dimension of the Zariski closure of D,
and the pairs (d, µ) satisfy certain counting conditions. This led the authors in
[48] to introduce the following notion of measurable structure. The deﬁnition
below, taken from [25], is slightly different from Deﬁnition 5.1 of [48], but
equivalent.

Deﬁnability in classes of ﬁnite structures
153
Deﬁnition 4.5.1
An inﬁnite L-structure M is measurable if there is a function
h : Def(M) →N × R ∪{(0, 0)} (we write
h(X) = (Dim(X), Meas(X)) = (Dim, Meas)(X))
such that the following hold.
1. For each L-formula ϕ(¯x, ¯y) there is a ﬁnite set D ⊂N × R>0 ∪{(0, 0)}, so
that for all ¯a ∈Mm we have h(ϕ(Mn, ¯a)) ∈D.
2. If ϕ(Mn, ¯a) is ﬁnite then h(ϕ(Mn, ¯a)) = (0, |ϕ(Mn, ¯a)|).
3. For every L-formula ϕ(¯x, ¯y) and all (d, µ) ∈Dϕ, the set {¯a ∈Mm :
h(ϕ(Mn, ¯a)) = (d, µ)} is ∅-deﬁnable.
4. (Fubini) Let X, Y ∈Def(M) and f : X →Y be a deﬁnable surjection.
Then there are r ∈N and (d1, µ1), . . . , (dr, µr) ∈(N × R>0) ∪{(0, 0)} so
that if Yi := { ¯y ∈Y : h(f −1( ¯y)) = (di, µi)}, then Y = Y1 ∪. . . ∪Yr is a
partition of Y into non-empty disjoint deﬁnable sets. Let h(Yi) = (ei, νi)
for i ∈{1, . . . , r}. Also let c := Max{d1 + e1, . . . , dr + er}, and suppose
(without loss) that this maximum is attained by d1 + e1, . . . , ds + es. Then
h(X) = (c, µ1ν1 + · · · + µsνs).
If X ∈Def(M) and h(X) = (d, µ), we call d the dimension of X and µ the
measure of X, and h the measuring function.
We do not emphasize measurable structures in this paper. For more infor-
mation, see [48] or [25]. We do note the following observations.
Remark 4.5.2
a. If M is measurable and N ≡M then N is measurable; hence
one may speak of a measurable theory.
b. If C is an N-dimensional asymptotic class, then every non-principal
ultraproduct of C is measurable – essentially, the pairs (d, µ) transfer through
to the ultraproduct.
c. Shelah introduced in [55] the concept of a simple theory (see also [41]).
Simplicity is a generalization of stability in which model-theoretic non-forking
still provides a good notion of independence. Indeed, it satisﬁes all the main
properties of non-forking in stable theories except stationarity, which controls
the number of non-forking extensions of a complete type. Stationarity (i.e.,
the Finite Equivalence Relation Theorem) is replaced by the ‘Independence
Theorem’ in simple theories. The analogue of a superstable theory in stability is,
in the context of simplicity, the notion of a supersimple theory. In a supersimple
theory every deﬁnable set has an ordinal-valued ‘D-rank’; in fact, there are
several notions of rank on a deﬁnable set in a supersimple theory – D-rank,
SU-rank, and S1-rank – all of which coincide if any of them is ﬁnite. It is shown
in [25, Corollary 3.4] – but was noted earlier by Ryten – that if M is measurable

154
Dugald Macpherson and Charles Steinhorn
then it is supersimple, and for any deﬁnable set X in M, the D-rank of X is at
most its dimension and hence is ﬁnite.
d. It follows from (b) and (c) that an ultraproduct of an asymptotic class
cannot have the strict order property: there cannot be a deﬁnable partial order
(even on a power of the structure) with an inﬁnite chain. This generalizes the
observation made at the end of Section 4.2 that the collection of ﬁnite linear
orders does not form an asymptotic class.
e. There are measurable structures that are not elementarily equivalent to any
ultraproduct of an asymptotic class. Vector spaces over an inﬁnite ﬁeld, in the
language of modules over the ﬁeld, provide one example. A more interesting
example of Elwes [22, Section 3.4] consists of a structure with two different
pseudoﬁnite ﬁeld structures (in disjoint languages) of different prime charac-
teristics. It arises by taking the ﬁxed point set of a generic automorphism of the
‘Hrushovski fusion’ [37] of two different algebraically closed ﬁelds in distinct
positive characteristics. Such a structure cannot be an ultraproduct of ﬁnite
structures, since no positive integer can be a power of two distinct primes.
We next discuss how some stability-theoretic notions interact with asymp-
totic classes. The following result enables us to detect in the 1-dimensional
case, just from asymptotic information, whether or not every ultraproduct of
an asymptotic class is stable.
Proposition 4.5.3 ([48])
Let C be a 1-dimensional asymptotic class. Then
some ultraproduct of C is unstable if and only if there is a formula ϕ(x, ¯y), and
for each k ∈N some M ∈C and ¯a1, . . . , ¯ak ∈Mℓ( ¯y) with
(a) |ϕ(M, ¯ai)| ≥k for each i = 1, . . . , k
(b) |ϕ(M, ¯ai)△ϕ(M, ¯aj)| ≥k for all distinct i, j ∈{1, . . . , k}.
Of the examples of asymptotic classes considered in Section 4.3, only the
following have all ultraproducts stable: the class of ﬁnite cyclic groups; the
asymptotic classes of Example 4.3.8 with all ultraproducts strongly minimal;
in Example 4.3.9, if M is a smoothly approximable structure which is ω-
categorical and ω-stable (or in particular, which is totally categorical), then
every asymptotic class consisting of its envelopes.
We now recall the construction, from a complete theory T , of T eq. For each
n > 0, and each ∅-deﬁnable equivalence relation E on n-tuples, one adjoins a
new sort interpreted, for M |= T , by Mn/E and a function taking each n-tuple to
its corresponding E-equivalence class in the new sort. There is a corresponding
language Leq, and all models M of T have corresponding expansions Meq in
the language Leq with theory T eq.

Deﬁnability in classes of ﬁnite structures
155
Recall also that if A is a subset of a structure M, then b ∈M is algebraic
over A if there is a ﬁnite A-deﬁnable subset of M containing b. The alge-
braic closure of A, namely the set of elements algebraic over A, is denoted
acl(A).
A supersimple theory T is said to be 1-based if, for every M |= T and all
subsets A and B of Meq, we have that A and B are independent, in the sense of
non-forking, over acleq(A) ∩acleq(B). Using the main theorem of [33] Elwes
[22] derived the result below, which a fortiori gives structural restrictions on
asymptotic classes all of whose ultraproducts are stable. Note that there is an
error in [22] stemming from a misunderstanding of [33] – an invalid use of
compactness in [22, Lemma 6.4]. A valid argument in its place has been given
by Kestner and Pillay (personal communication).
Theorem 4.5.4
Every measurable stable theory is 1-based.
As a very special case, note that an algebraically closed ﬁeld cannot be
measurable. To illustrate, for the complex ﬁeld C, the map x →x2 is a sur-
jection C \ {0} →C \ {0} which is 2-to-1, contrary to Deﬁnition 4.5.1(iv). In
fact, there is evidence that measurable ﬁelds must be pseudoﬁnite. Scanlon
has shown that every inﬁnite measurable ﬁeld is quasiﬁnite, and easily, every
measurable ﬁeld is perfect – see [48, Theorems 5.18 and 6.1], and also [54].
It is not known if the PAC pseudo-algebraically closed property (see the ﬁrst
paragraph in this section) holds for all measurable ﬁelds; this would yield
pseudoﬁniteness.
If M is a 1-dimensional measurable structure – e.g., an ultraproduct of a 1-
dimensional asymptotic class – then the algebraic closure operator deﬁnes a pre-
geometry on subsets of M (as it is supersimple of rank 1). In particular it satis-
ﬁes the exchange property: if b ∈acl(A ∪{c}) \ acl(A), then c ∈acl(A ∪{b}).
The exchange property can be formalized fairly concretely for 1-dimensional
asymptotic classes. The deﬁnitions can be ﬁnitized, and the formula making c
algebraic over A ∪{b} can be identiﬁed up to ﬁnitely many possibilities over the
given data. Indeed, suppose that C is a 1-dimensional asymptotic class, ϕ(x, ¯y)
is a formula, and D is the corresponding subset of {0, 1} × R>0 of dimension-
measure pairs as provided in Deﬁnition 4.2.2(i). Let E := {µ : (1, µ) ∈D}
and for µ ∈E let ϕµ( ¯y) be a formula deﬁning (1,µ) as in Deﬁnition 4.2.2(ii).
If M ∈C, A ⊂M, and b ∈M, we say b is in the ϕ-closure of A, written
b ∈clϕ(A), if there is some ¯a from A such that M |= ϕ(b, ¯a) and M ̸|= ϕµ(¯a)
for each µ ∈E. For a set of formulas , we say that b is in the -closure of
A, written b ∈cl(A), if b ∈clϕ(A) for some ϕ ∈. We have:

156
Dugald Macpherson and Charles Steinhorn
Proposition 4.5.5
[48, Proposition 4.4] Let C be a 1-dimensional asymptotic
class, M ∈C, and A ⊂M. There are ﬁnite sets (ϕ) and 
(ϕ) of formulas
(depending on ϕ) such that for a, b ∈M with a ∈clϕ(Ab) \ cl(ϕ)(A), if M is
‘large enough’ relative to A and ϕ, then b ∈cl
(ϕ)(Aa).
The notion of a 1-based theory is related to the trichotomy conjecture of
Zilber. One version of this conjecture, now known to be false, asserts that if M is
a strongly minimal structure, then: either M is disintegrated, that is, acl(A) =
(acl(a) : a ∈A) for every A ⊂M; or M is locally modular, equivalently,
1-based; or M interprets an inﬁnite ﬁeld. Counterexamples to this conjecture
were found by Hrushovski [34], but the conjecture has remained extremely
inﬂuential, and versions hold in key contexts. Furthermore, disintegrated and
locally modular strongly minimal sets now are fairly well understood.
It makes sense to investigate the conjecture for 1-dimensional asymptotic
classes. The following result, Proposition 4.5 of [48], gives a clear notion of
a ‘disintegrated 1-dimensional asymptotic class’, identiﬁed by the asymptotic
condition (iii).
Proposition 4.5.6
Let C be a 1-dimensional asymptotic class. Then the fol-
lowing are equivalent.
(i) for every formula ϕ(x, ¯y), there is a formula ψ(x, ¯z) and some K ∈N
such that if M ∈C with |M| > K and A ⊂M, then clϕ(A) ⊂
a∈A(clψ({a});
(ii) in every inﬁnite ultraproduct M of members of C, if A ⊂M then acl(A) =

a∈A(acl({a});
(iii) for every ϕ(x, ¯y) there is some Kϕ ∈N such that for all M ∈C with
|M| > Kϕ, if A ⊂M then | clϕ(A)| ≤Kϕ|A|.
It would be of interest to investigate the Zilber trichotomy further for asymp-
totic classes. Certainly, by one of the main results of [18], all smoothly approx-
imable structures are 1-based. This includes in particular the Lie geometries.
We have no idea if, in a 1-dimensional asymptotic class that is not 1-based –
that is, ultraproducts of which are not 1-based, and so by Theorem 4.5.4 are
unstable – arbitrarily large ﬁnite ﬁelds must be uniformly interpretable. It would
be intriguing to investigate this already for classes of structures interpretable
in ﬁnite ﬁelds, or even for reducts of ﬁnite ﬁelds.
4.6 Asymptotic classes of groups
As mentioned in Example 4.3.3, the work of Ryten on difference ﬁelds yields
the following theorem; we emphasize again that the bound on Lie rank is
essential.

Deﬁnability in classes of ﬁnite structures
157
Theorem 4.6.1 (Ryten)
If C is any family of ﬁnite simple groups of ﬁxed Lie
type, then C is an asymptotic class.
The structure of asymptotic classes of groups is an attractive area of study.
For groups in which deﬁnability is governed by deﬁnability in ﬁnite ﬁelds,
or by deﬁnable subgroups of cartesian powers (as in one-based groups), one
expects good control of deﬁnability. It is not clear whether ‘asymptotic class’
is the optimal model theoretic assumption on a family of ﬁnite groups; often
the same conclusions can be drawn just assuming that all ultraproducts have
supersimple ﬁnite rank theory. This is developed in [24].
In developing a structure theory one wants, as far as possible, not to assume
the classiﬁcation of ﬁnite simple groups (CFSG). It would be wonderful to
recover parts of the classiﬁcation just from model theoretic hypotheses. As one
step in this direction, Hrushovski has shown that any family of ﬁnite simple
groups uniformly deﬁnable in ﬁnite ﬁelds is a family of (possibly twisted) Lie
type [36, Theorem 9.2], and the same holds for groups uniformly deﬁnable in
a family of the difference ﬁelds C(m,n,p) (see [37, Theorem 1.8] – the proof is
unpublished). In the same spirit, Theorem 7.5.6 of [18] identiﬁes, by model-
theoretic hypotheses, a class of structures closely associated with ﬁnite simple
groups.
As mentioned in Example 4.3.5, the class of ﬁnite cyclic groups is a 1-
dimensional asymptotic class. It should be feasible to describe all asymptotic
classes of abelian groups. At higher levels of complexity – but within the class
of soluble groups – very little is known, though one expects unipotent and Borel
subgroups of ﬁnite Chevalley groups of ﬁxed Lie type to fall into asymptotic
classes. We also mention the following ([48, Proposition 3.11]). A p-group
is extraspecial if G′ = Z(G) = (G) ∼= Cp. In particular, extraspecial groups
are nilpotent of class 2.
Proposition 4.6.2
If p is an odd prime, then the class of ﬁnite extraspecial
groups of exponent p is a 1-dimensional asymptotic class.
In fact, ﬁnite extraspecial groups of odd exponent p are envelopes of a
smoothly approximable structure, the unique countably inﬁnite extraspecial
group of exponent p. This group has cyclic center, and the quotient by the
center is an elementary abelian p-group, equipped with an alternating bilinear
form given by the commutator map to the center. Its theory is supersimple but
unstable.
The remaining results in this section dealing with families of ﬁnite groups are
obtained under weaker hypotheses than that of being an ‘asymptotic class’ –
see our remarks following Theorem 4.6.1. We say that a family C of ﬁnite

158
Dugald Macpherson and Charles Steinhorn
structures is supersimple of ﬁnite rank (respectively, supersimple of rank n) if
all non-principal ultraproducts have these properties. The results below are all
analogues of theorems about groups of ﬁnite Morley rank. Typically, the proofs
use ultraproducts, and facts about measurable groups, or, more generally, groups
with a supersimple ﬁnite rank theory. In some cases – Propositions 4.6.3(i),
4.6.5, 4.6.6, 4.6.8 – the results really belong in some such setting, and there is
no use of ﬁniteness or pseudoﬁniteness.
Proposition 4.6.3
(i) [48, Theorem 3.12] Let C be a supersimple rank 1 family
of ﬁnite groups. Then there is d ∈N such that each group G ∈C has normal
subgroups H and N, where |G : N| ≤d, |H| ≤d, H ≤Z(N), and N/H is
abelian.
(ii) [24] Let C be a supersimple rank 2 family of ﬁnite groups. Then there
is d ∈N such that all groups in C have a normal subgroup of index at most d
which is soluble of derived length at most 4.
Neither result requires CFSG. Part (ii) was proved by Elwes and Ryten in
[26] under the extra assumption that C is a (2-dimensional) asymptotic class,
using CFSG. The bound 4 on the derived length is probably not optimal; it
should perhaps be 2, arising from the class of 1-dimensional afﬁne groups
AGL1(Fq).
One key ingredient in the proof is the body of results on so-called BFC
groups: that is, groups with a ﬁnite bound d on the size of all conjugacy
classes. If G is such a group with bound d on the size of conjugacy classes,
then there is a bound B(d) ∈N such that |G′| ≤B(d); see Wiegold [63], for
example, where B(d) = d
1
2 d4(log2 d)3 is obtained. Another element is a theorem
of Schlichting, strengthened by Bergman and Lenstra [6]. It asserts that if G is
a group and F is a family of subgroups of G which is (setwise) invariant under
a group K of automorphisms of G such that for some d and every F1, F2 ∈F
we have |F1 : F1 ∩F2| ≤d, then for some d′ dependent only on d, there is a
K-invariant subgroup N of G so that |F : F ∩N| ≤d′ and |N : F ∩N| ≤d′
for all F ∈F.
To establish further results, one often needs a version for supersimple the-
ories of the Zilber Indecomposability Theorem, applied to ultraproducts. The
version below follows from [62, Theorem 5.5.4].
Theorem 4.6.4
Let G be a group deﬁnable in a supersimple structure of ﬁnite
rank, and let {Xi : i ∈I} be a collection of deﬁnable subsets of G. Then there
exists a deﬁnable subgroup H of G such that:
(i) H ≤X±1
i1 . . . X±1
im for some i1, . . . , im ∈I;
(ii) Xi/H is ﬁnite for each i ∈I.

Deﬁnability in classes of ﬁnite structures
159
Moreover, if the collection {Xi : i ∈I} is invariant under the group K of
deﬁnable automorphisms of G, then H can be chosen to be K-invariant.
Consequences of Theorem 4.6.4 include the next results. If C is a family of
groups, we say that the subsets X of members G of C are uniformly deﬁnable
if just ﬁnitely many formulas ϕ(x, ¯y) are required to deﬁne the sets X as G
ranges through C.
Proposition 4.6.5
(from [36, Corollary 7.4]) If C is a supersimple ﬁnite rank
family of ﬁnite groups with no uniformly deﬁnable proper non-trivial normal
subgroups, then all but ﬁnitely many of the groups in C are simple.
Proposition 4.6.6
(from [36, Corollary 7.1]) If C is a supersimple ﬁnite
rank family of ﬁnite groups, then the derived subgroups of members of C are
uniformly deﬁnable.
Recall that the soluble radical R(G) of a ﬁnite group G is its largest soluble
normal subgroup.
Proposition 4.6.7
[24, Theorem 1.1] If C is a supersimple ﬁnite rank family of
ﬁnite groups, then the soluble radicals R(G) of the groups G ∈C are uniformly
deﬁnable.
Proposition 4.6.7 has further structural consequences. For a group G we
denote its socle, the direct product of its minimal normal subgroups, by Soc(G).
It follows fairly easily from Proposition 4.6.7 that if C is a supersimple ﬁnite
rank class, then the groups Soc(G/R(G)) are uniformly interpretable in G as
G ranges through C, and are a direct product of a bounded number of ﬁnite
simple groups of bounded Lie rank.
There are also the beginnings of a model theory for families of ﬁnite per-
mutation groups. We view a permutation group model-theoretically as a pair
(X, G), with a deﬁnable group structure on G and a deﬁnable action of G on
X. By the Orbit-Stabilizer Theorem, if G is transitive on X, we may parse
(X, G) as a pair (G, H), where H is a subgroup of G, the stabilizer of some
x ∈X.
Recall that a permutation group (X, G) is primitive if there is no proper
non-trivial G-invariant equivalence relation – that is, G-congruence – on X,
equivalently, if all point stabilizers Gx for x ∈X are maximal subgroups of
G. We say that the family C of ﬁnite permutation groups (X, G) is deﬁnably
primitive if, for each non-principal ultraproduct (X∗, G∗), there is no deﬁnable
proper non-trivial G∗-congruence on X∗.

160
Dugald Macpherson and Charles Steinhorn
Proposition 4.6.8
[[26]] If C is a supersimple ﬁnite rank class of deﬁnably
primitive ﬁnite permutation groups, then all but ﬁnitely many of the permutation
groups in C are primitive.
Theorem 4.6.9 ([24])
Let C be a supersimple ﬁnite rank family of ﬁnite prim-
itive permutation groups, and suppose that for every ultraproduct (X∗, G∗),
rk(X∗) = 1. Then one of the following holds for ultraproducts (X∗, G∗).
(i) rk(G∗) = 1, G∗acts regularly on X∗, and G∗is elementary abelian or
torsion-free divisible abelian.
(ii) rk(G∗) = 2, and there is an interpretable pseudoﬁnite ﬁeld F such that
G ≤AGL1(F) (the one-dimensional afﬁne group (F, +).(F, ×)) in the natural
action on F.
(iii) rk(G∗) = 3, there is an interpretable pseudoﬁnite ﬁeld F, and
PSL2(F) ≤G ≤P
L2(F) in the natural action on the projective line PG1(F).
In [47] a structure theory is given for families of ﬁnite permutation groups
all of whose non-principal ultraproducts are primitive. We do not give details
here. One feature concerns families of primitive permutation groups (X, G)
such that Soc(G) is a non-abelian simple group of ﬁxed Lie rank. Except in
very speciﬁc cases (essentially where the point stabilizers are bounded, or are
‘subﬁeld subgroups’ associated with subﬁelds for which the ﬁeld extension
degree is unbounded) families of this type have primitive ultraproducts. The
proof uses much of the above work of Elwes and Ryten, Theorem 4.6.4, and
also knowledge of maximal subgroups of ﬁnite simple groups. In particular,
we have the following result. It generalizes [38, Proposition 8.1], which is over
prime ﬁelds, but unlike the latter, it makes heavy use of the classiﬁcation of
ﬁnite simple groups.
Theorem 4.6.10 ([47])
Let Chev be a ﬁxed Lie type (possibly twisted) of
ﬁnite simple groups, and d a positive integer. Let C be a family of pairs (G, H)
where G = Chev(q) and H is a maximal subgroup of G, and suppose that if
H = Chev(q0) then the degree [Fq : Fq0] ≤d. Then the groups H are uniformly
deﬁnable in the groups G, and C is an asymptotic class.
4.7 Robust classes
Robust classes consist of chains of ﬁnite structures in which the truth value of
every formula, with parameters from some structure in the chain, eventually
stabilizes when the formula is interpreted in a sufﬁciently larger structure. That
is, one must “look ahead” in the chain to determine satisfaction of a formula

Deﬁnability in classes of ﬁnite structures
161
with parameters in some structure in the chain. This framework has provided
a setting in which to investigate notions of stability and o-minimality, as well
as some provisional versions of complexity of such a chain. In addition to
investigating these topics, the interest has mainly been in ﬁnding examples.
We begin with the deﬁnition of a robust class, and some initial observations,
working over an arbitrary – and, unless otherwise speciﬁed, ﬁnite – ﬁrst-
order language L. Examples are discussed in the next section, and a robust
approximation to the ordered additive group of rational numbers is established
in Section 4.9.
Deﬁnition 4.7.1
A sequence C = (Mi : i ∈N) of ﬁnite L-structures forms a
chain of structures if Mi ⊆Mi+1 (as a substructure) for each i ∈N. A chain
C is said to be robust if for each n ∈N and L-formula ϕ(x1, . . . , xn) there is a
function f = fϕ : N →N such that for each i ∈N and a1, . . . , an ∈Mi, and
for every j ≥f (i), we have
Mf (i) |= ϕ(¯a) if and only if Mj |= ϕ(¯a).
If C is robust and ¯a and Mi are as above, we write C |=ev ϕ(¯a) if Mj |= ϕ(¯a)
for all sufﬁciently large j.
Remark 4.7.2
(a) In what follows, we always assume that fϕ grows as slowly
as possible subject to witnessing robustness. Thus, fϕ is uniquely determined
by C.
(b) There is a natural generalization of Deﬁnition 4.7.1, where we replace
the chain C by a directed system of ﬁnite structures, equipped with speciﬁed
embeddings. This is our original context, but as nothing has yet been done with
the greater generality, we here use the more concrete version in Deﬁnition 4.7.1.
Initial results on robust classes have been obtained over the last few years
by the authors (ﬁrst published here) and in the Ph.D. thesis of the ﬁrst author’s
student, Richard Marshall [49]. The study of robust classes is still in its early
stages and thus not yet fully systematic. For example, one could envisage
a theory of ‘asymptotic robust classes’, in which the asymptotic estimates
described in Deﬁnition 4.2.2 are required to hold only when a formula is
interpreted in a sufﬁciently larger structure, but this has not been considered.
Observe that Deﬁnition 4.7.1 applies in particular to sentences. Thus, if
C = (Mi : i ∈N) is a robust class, then for every L-sentence σ, precisely one
of σ or ¬σ holds in coﬁnitely many Mi. If C is an arbitrary chain of ﬁnite
structures, we deﬁne the asymptotic theory T as
C
to be the collection of L-
sentences true in coﬁnitely many Mi ∈C. If C is robust then this is a complete
theory. Let M be the (countable) direct limit structure of the chain C. The limit

162
Dugald Macpherson and Charles Steinhorn
theory T lim
C
of C is deﬁned to be Th(M). In general, even assuming robustness,
we do not expect T as
C = T lim
C
(see Propositions 4.7.4 and 4.8.2, and the comment
following 4.8.2).
Recall that a ﬁrst-order structure M is locally ﬁnite if every ﬁnite subset of
M is contained in a ﬁnite substructure of M. Given a countably inﬁnite locally
ﬁnite structure M, it is natural to ask if it is possible to construct a robust
chain with direct limit M. The next result demonstrates that we must reﬁne
this initial question to investigate conditions under which we can obtain an
explicitly described robust chain. This question can take several forms, a theme
that we explore throughout the rest of this paper. If a chain of ﬁnite structures
C′ is a subsequence of a chain C, we call it a coarsening of C. Obviously, any
coarsening of a robust chain is robust.
Proposition 4.7.3
[49, Theorem 2.4.5]
(i) Let C = (Mi : i ∈N) be a chain of ﬁnite L-structures. Then there is a
coarsening of C which is robust.
(ii) Every countably inﬁnite locally ﬁnite structure is the direct limit of a
robust chain.
Proof. (i) One systematically, for each structure in the chain and choice of
parameters in the structure, replaces the sequence of larger structures by an
inﬁnite subsequence in which the formula takes an eventually constant truth
value.
(ii) Immediate from (i).
□
Recall that a theory T is near model complete if every formula is equivalent
modulo T to a boolean combination of existential formulas. Many familiar
theories are near model complete; in particular, every model complete theory is
near model complete. The theory of pseudoﬁnite ﬁelds is near model complete
by [40] (see also [14, Section 3]), and so is any complete theory of abelian
groups, or, more generally, of modules. Several ‘Hrushovski constructions’
have near model complete but not model complete theories; see for example
Baldwin and Shelah [5].
Proposition 4.7.4
Let C = (Mi : i ∈N) be a chain of ﬁnite structures.
(i) If T as
C is near model complete then C is robust.
(ii) If T as
C is ∀∃-axiomatized then T lim
C
|= T as
C .
(iii) If T as
C is ∀∃-axiomatized and complete, then T lim
C
= T as
C .
Proof. (i) Let M be the direct limit of C. For every tuple ¯a from M and
existential formula ϕ(¯x), we have that M |= ϕ(¯a) if and only if Mi |= ϕ(¯a) for
sufﬁciently large i ∈N. For every formula ψ(¯x) there is, modulo T as
C , a formula

Deﬁnability in classes of ﬁnite structures
163
θ(¯x), which is a boolean combination of existential formulas, and a sentence
σ ∈T as
C , such that σ |= (∀¯x) ψ(¯x) ↔θ(¯x). As there is some N ∈N such that
Mi |= σ for all i ≥N, it follows for sufﬁciently large i that Mi |= ψ(¯x) if and
only if M |= θ(¯x). Hence C is robust.
(ii) Each of the ∀∃-axioms of T as
C holds in sufﬁciently large Mi, thus hold in
the union M, and hence so do their consequences.
(iii) This is immediate from (ii).
□
Recall that a theory T has the ﬁnite submodel property if for every M |= T
and σ ∈T , there is a ﬁnite substructure of M satisfying σ. An extension of the
arguments above yields the following.
Proposition 4.7.5
[49, Theorem 2.4.13] Let L be a ﬁnite language and let
T be a complete L-theory that is near model complete, ∀∃-axiomatized, and
has the ﬁnite submodel property. Then there is a robust chain C such that
T as
C = T lim
C
= T .
One of the original aims behind the introduction of robust classes is to
develop a framework in which a (countable) stable or o-minimal structure might
be approximated by a chain of ﬁnite structures that reﬂects these properties. To
this end, we propose the following analogues of stability and o-minimality.
Deﬁnition 4.7.6
Let C = (Mi : i ∈N) be a robust chain of L-structures with
limit M.
(i) The L-formula ϕ(x1, . . . , xm, y1, . . . , yn) is unstable in C if for all t ∈N
there are ¯a1, . . . ¯at ∈Mm and ¯b1, . . . , ¯bt ∈Mn such that for all i, j ≤t we have
C |=ev ϕ(¯ai, ¯bj) ⇔i ≤j.
(ii) The chain C is unstable if and only if some formula is unstable in C.
(iii) The chain C is strongly minimal if for every formula ϕ(x, y1, . . . , yn)
there is nϕ ∈N such that for all ¯a ∈Mn either |{x ∈M : C |=ev ϕ(x, ¯a)}| ≤nϕ,
or |{x ∈M : C |=ev ¬ϕ(x, ¯a)}| ≤nϕ.
(iv) Assume that L contains a binary relation < that totally orders M. Then C
is said to be o-minimal if for every formula ϕ(x, y1, . . . , yn) there is an nϕ ∈N
such that for all ¯a ∈Mn we have {x ∈M : C |=ev ϕ(x, ¯a)} is the union of at
most nϕ singletons and open intervals of (M, <).
Proposition 4.7.7
Let C = (Mi : i ∈N) be a robust chain with limit M.
(i) [49, 4.2.12] For a formula ϕ(¯x, ¯y), if ϕ is unstable in C then ϕ is unstable
in T as
C .
(ii) If T as
C is near model complete, then:

164
Dugald Macpherson and Charles Steinhorn
(a) [49, 4.2.4] a formula ϕ is stable in C if ϕ is stable in T lim
C ;
(b) C is strongly minimal if T lim
C
is strongly minimal;
(c) if M is totally ordered by <, then C is o-minimal if M is o-minimal.
(iii) If T lim
C
is near model complete, then the converses to (ii)(a)–(c) hold.
Proof. (i) If ϕ is unstable, then for all t the following sentence holds eventually
in C, and hence belongs to T as
C :
∃¯x1, . . . ¯xt∃¯y1 . . . ¯yt[

i<j
ϕ(¯xi, ¯yj) ∧

i≥j
¬ϕ(¯xi, ¯yj)].
(ii) In each case, this follows from the observation that every formula is
equivalent, in sufﬁciently large members of C, to a boolean combination of
existential formulas, and the latter holds eventually in C if and only if it holds
in M. (It is important to note that we do not claim that C |=ev ϕ ⇔M |= ϕ for
every formula ϕ; indeed, this already may fail for sentences.)
(iii) The argument is similar to that for (ii).
□
The beginnings of a stability theory for robust chains are explored by Mar-
shall in [49, Chapter 4]. For example, a version of Shelah’s ϕ-rank (for a
formula ψ) is deﬁned, and it is shown that for a robust class C, some formula
ϕ(¯x, ¯y) is unstable in C if and only if the ϕ-rank of ¯x = ¯x is inﬁnite in this
sense. An interesting feature here is that the inﬁnitary arguments of Shelah
[55, II.2] seem to be unavailable, and the combinatorial result of [30] is used
instead. Marshall shows [49, 4.5.19] that if C is a strongly minimal robust class
with T as
C model complete, then C is stable, but this has not been proved without
the model completeness assumption. An initial theory of Morley rank is also
developed. Versions of the independence property and the strict order property
for robust classes are deﬁned, and each implies that C is unstable. Conversely,
under the assumption that T as
C is near model complete and ∀∃-axiomatized,
Marshall proves that C has either the independence property or the strict order
property.
The “look ahead” aspect of satisfaction in a robust chain suggests the intro-
duction of various notions of complexity. Partly adapting [49, Deﬁnition 6.2.1],
we make the following provisional deﬁnitions.
Deﬁnition 4.7.8
Let C = (Mi : i ∈N) be a robust chain.
a. We say C has chain complexity 0 if for every formula ϕ(¯x) there is nϕ such
that fϕ(i) ≤Max{i, nϕ}. The chain C has linear (respectively, polynomial)
chain complexity, if, for each formula ϕ, the function fϕ is bounded above
by a linear (respectively, polynomial) function.

Deﬁnability in classes of ﬁnite structures
165
b. We say that C has linear (respectively, polynomial, exponential) model
growth if the function i →|Mi| is bounded above by a linear (respectively,
polynomial, exponential) function.
c. The chain C has polynomial satisfaction complexity if for every formula
ϕ(¯x) there are constants C > 0 and d ∈N so that |Mfϕ(i)| ≤C|Mi|d for all
for all Mi ∈C.
Note that chain complexity and satisfaction complexity can be deﬁned for
each formula separately. Observe also that Proposition 4.7.3 suggests that chain
complexity and model growth play off against each other. Chain complexity
and model growth have been explored in [49]; satisfaction complexity is newer
and not yet well-explored. Note also that chain complexity 0 implies even linear
satisfaction complexity. Satisfaction complexity can be reﬁned by specifying
how the constants C and d depend on ϕ; for example one could demand that C
be a recursive or even polynomial function of ϕ or |ϕ|.
As a corollary to Proposition 4.7.5, we have
Corollary 4.7.9
[49, 6.2.3] Let T be a complete theory with quantiﬁer elim-
ination and the ﬁnite submodel property. Then there is a robust chain C with
T as
C = T lim
C
= T , and every such chain has chain complexity 0.
Proof. The ﬁrst assertion is just Proposition 4.7.5. For the second, let C = (Mi :
i ∈N) be such a chain. For every formula ϕ(¯x) there is a quantiﬁer-free formula
ψ(¯x) such that T contains the sentence σ :≡(∀¯x) ϕ(¯x) ↔ψ(¯x). Choose nϕ
least such that Mi |= σ for all i ≥nϕ. Since for all i > j ≥nϕ and ¯a in Mj
we have Mj |= ψ(¯a) ⇔Mi |= ψ(¯a), it follows that Mj |= ϕ(¯a) ⇔Mi |=
ϕ(¯a).
□
As an extension of 4.7.9, we give a syntactic characterization of robust
classes of chain complexity 0. If L ⊂L+ are languages and C = (Mi : i ∈N)
is a chain of ﬁnite L-structures, we say that C+ = (M+
i : i ∈N) is an L+-
expansion of C if each M+
i is an L+ expansion of Mi and C+ is a chain, that is,
M+
i is an L+-substructure of M+
i+1 for each i ∈N.
Proposition 4.7.10
Let C = (Mi : i ∈ω) be a chain of ﬁnite L-structures.
The following are equivalent.
(i) C is robust with chain complexity 0.
(ii) There is a language L+ ⊃L and an expansion C+ of C to L+ such that
T as
C+ is model-complete.
Proof. (ii) ⇒(i). Suppose that C and C+ are as in (ii). Let ϕ(¯x) be an L-
formula. Then there are formulas ∃¯y ψ(¯x, ¯y) and ∀¯z χ(¯x, ¯z), where ψ and
χ are quantiﬁer-free L+-formulas, such that T as
C+ contains both (∀¯x) ϕ(¯x) ↔

166
Dugald Macpherson and Charles Steinhorn
∃¯yψ(¯x, ¯y) and (∀¯x) ϕ(¯x) ↔∀¯zχ(¯x, ¯z). Hence there is nϕ ∈N such that each
of these sentences holds in M+
i for i ≥nϕ. Let j > i ≥nϕ and ¯a ∈Ml(¯x)
i
. If
Mi |= ϕ(¯a), then there is ¯b ∈Ml( ¯y)
i
such that Mi |= ψ(¯a, ¯b), and thus, as ψ is
quantiﬁer-free, M+
j |= ψ(¯a, ¯b). Hence Mj |= ϕ(¯a). If Mi |= ¬ϕ(¯a) we argue
similarly, using χ.
(i) ⇒(ii). We ‘Morleyize’, uniformly. That is, we expand L to L+ by
introducing, for each L-formula ϕ(¯x), a relation symbol Rϕ(¯x), and let
T + := T as
C ∪{(∀¯x) ϕ(¯x) ↔Rϕ(¯x) : ϕ an L-formula}.
Then it follows from robustness of C that T + is a complete L+-theory.
We expand C to L+ as follows. For each new relation symbol Rϕ, let
nϕ be chosen least so that for all j > i ≥nϕ and ¯a ∈Ml(¯x)
i
, we have that
Mi |= ϕ(¯a) if and only if Mj |= ϕ(¯a); such an nϕ exists as C is robust with
chain complexity 0. For i ≥nϕ, interpret Rϕ in Mi by ϕ and for i < nϕ inter-
pret Rϕ as the relation induced by the interpretation of Rϕ in Mnϕ. Then
C+ is a chain of L+-structures, and its asymptotic theory contains T +, so is
model-complete.
□
4.8 Examples of robust classes
We present several examples of robust classes here and in the next section. The
emphasis here is two-fold: to provide examples that illustrate the properties
introduced in Section 4.7, and to produce classes with various properties that
have prescribed limit structures.
Proposition 4.8.1
Let M be a smoothly approximable structure, approximated
by a chain C = (Mi : i ∈ω) of ﬁnite substructures, where Mi is an |Mi|-
homogeneous subtructure of M. Then
(i) C is robust with chain complexity 0.
(ii) The chain C approximating M can be chosen to have exponential model
growth.
Proof. (i) We may suppose that Th(M) admits quantiﬁer elimination by adding
a new relation symbol for each formula. Now Th(M) is model complete, and
every sentence in Th(M) holds in Mi for all sufﬁciently large i. Since every
expansion of M by ﬁnitely many constants also is smoothly approximable, the
same holds for formulas, that is, C is robust. By Corollary 4.7.9, C has chain
complexity 0.
(ii) The fact that C can be chosen to have exponential model growth follows
from [18, 5.2.2].
□
Example 4.8.2
Let L be the language of rings, and in this language let
C = (Mi : i ∈N) be any chain of ﬁnite ﬁelds of characteristic p with union ¯Fp,

Deﬁnability in classes of ﬁnite structures
167
the algebraic closure of Fp. The theory T as
C includes the theory of pseudoﬁnite
ﬁelds, so is near model complete. By Propositions 4.7.4 and 4.7.7 it follows
that C is a strongly minimal robust chain (and is stable).
Note here that T as
C ̸= T lim
C , as T as
C has the independence property and is thus
unstable. The point essentially is that formulas – or sentences – which are
boolean combinations of existential formulas hold in the direct limit of C if and
only if they hold eventually in C, but this is not true for arbitrary sentences, in
particular the axioms of the theory of pseudoﬁnite ﬁelds.
Example 4.8.3
Let p ≡1 (mod 4) be prime and Mi be the ﬁeld Fp2i for
i ∈N. Let Pi be the Paley graph on Mi (see Example 4.3.6 for the deﬁnition),
and put C := (Pi : i ∈N). Then T as
C is the theory of the random graph, so has
quantiﬁer elimination and the ﬁnite submodel property. Thus, C is robust of
chain complexity 0, with the random graph as its direct limit.
By probabilistic arguments, it is possible to realize the random graph, or its
arity k analogue, as the direct limit of a chain complexity 0 robust chain (Mi :
i ∈N), with model growth given by the identity function – i.e., |Mi| = i for all
i. Indeed, by [60, Theorem 3.2], if 
k denotes the universal homogeneous k-
uniform hypergraph, then we may write 
k as the union of a chain (Mi : i ∈N)
of ﬁnite substructures such that |Mi| = i for each i, and for every sentence σ,
if 
k |= σ then Mi |= σ for all but ﬁnitely many i. This sufﬁces, by quantiﬁer
elimination.
Example 4.8.4
[49, Section 3.5] Using the invariants for the elementary
theories of Boolean algebras (in the language (∨, ∧, −, 0, 1)), due to Tarski
[58], as described in [11, p.288], it can be shown that the theory of pseudoﬁnite
Boolean algebras is complete and near model complete, although not model
complete. Hence, any chain (Mi : i ∈N) of ﬁnite Boolean algebras is robust
by 4.7.4. We may obtain the countable atomless Boolean algebra as a direct
limit by choosing the embeddings Mi →Mi+1 carefully, for example, putting
Mi+1 := Mi × Mi for each i, with the diagonal embedding Mi →Mi+1 given
by a →(a, a).
Example 4.8.5
[49, Section 3.4.1] The analysis of theories of abelian groups
based on the Szmielew invariants yields that any complete theory of abelian
groups is near model complete (see e.g., [31, p.663]). Hence, if C is a chain of
ﬁnite abelian groups such that T as
C is complete, then C is robust. Since theories
of abelian groups are stable, it follows from Proposition 4.7.7 that in this case
C is stable.
Example 4.8.6
[49, Section 3.2] The theory of pseudoﬁnite total orders is
complete and near model complete. This can be proved, for example, by an

168
Dugald Macpherson and Charles Steinhorn
Ehrenfeucht-Fra¨ıss´e game argument. It follows that any inﬁnite chain of ﬁnite
total orders is robust.
It is easy to build such a chain so that it is o-minimal and has direct limit
(Q, <). Let Mn be the natural total order on {1, 2, . . . , 2n + 1}, and embed Mn
into Mn+1 via the map i →2i. The model growth of C is clearly linear.
Of course, any other countable total order can be realized as the direct limit
of a robust chain by Proposition 4.7.3, and (N, <) and (Z, <) each is the direct
limit of an o-minimal robust chain, by Lemma 4.7.7.
We conclude this section with an example which is closer in spirit to
ﬁnite model theory, in that it uses Gaifman’s Locality Theorem and locality
arguments.
Example 4.8.7
Let L be a ﬁnite relational language, and let M be a countably
inﬁnite L-structure of ﬁnite valency, in the sense that every a ∈M lies in just
ﬁnitely many tuples satisfying relations of L. Suppose in addition that the
automorphism group of M, Aut(M), is transitive on M. Thus, there is d ∈N
such that all elements of M have valency d in the sense above. This assumption
is for convenience, and can surely be weakened. At any rate, Cayley graphs of
ﬁnitely generated groups provide a rich source of examples.
There is a natural notion of distance in M: for a, b ∈M, we write d(a, b) = r
if r is least such that there is a sequence a = a0, a1, . . . , ar = b such that each
pair ai, ai+1 lie in a tuple satisfying a relation in M. We further suppose that
M is connected, in the sense that d(a, b) is ﬁnite for all a, b ∈M. Lastly, for
each n ∈N and a ∈M, let Sn(a) be {x ∈M : d(a, x) ≤n} with the L-structure
induced from M.
Fix a ∈M. We recursively construct ﬁnite substructures Mn of M as follows.
Let M1 := S1(a). If Mn has been deﬁned, let Mn+1 be the union of Mn ∪Sn+1(a)
and a disjoint isomorphic copy of Mn that is not connected to Mn ∪Sn+1(a).
Note that each Mn has at least n connected components. Let C := (Mn : n > 0).
Then the direct limit of C is isomorphic to M.
We claim that T as
C is complete and near model complete. From this it follows
by Proposition 4.7.4 that C is robust.
We use the presentation of Gaifman’s Locality Theorem from [21, Sec-
tion 2.5]. For an L-structure N and ¯a = (a1, . . . , an) from N, let Sk(¯a) :=
Sk(a1) ∪. . . ∪Sk(an). We ﬁrst recall that for every L-formula ϕ(¯x) and k ∈N
one can associate a formula ϕSk(¯x), called a local formula, such that for every
L-structure N and ¯a in N,
N |= ϕSk(¯x)(¯a) if and only if Sk(¯a) |= ϕ(¯a).

Deﬁnability in classes of ﬁnite structures
169
A basic local sentence has the form
∃x1 . . . ∃xn

1≤i<j≤n
d(xi, xj) > 2r ∧ϕSr(xi)(xi).
Gaifman’s Theorem asserts that every ﬁrst-order L-sentence is logically equiv-
alent to a boolean combination of basic local sentences.
Since Mn+1 includes some connected components whose union Un is iso-
morphic to Mn, it is clear that if σ is a basic local sentence and Mn |= σ, then
Mn+1 |= σ; the witnesses for the existential quantiﬁers of σ in Mn have copies
in Un that witness σ in Mn+1. Thus, every basic local sentence is eventually
true or eventually false in C. The completeness of T as
C follows.
It remains to verify near model completeness. An extension of Gaifman’s
Theorem (see [28]) asserts that every formula ϕ(¯x) is logically equivalent to
a boolean combination of local formulas and basic local sentences. A local
formula ϕSr(¯x) is a boolean combination of formulas which describe possible
atomic diagrams of Sr(¯x). Since there is a ﬁxed upper bound on valency in
substructures of M, the formula ϕSr(¯x) can itself be assumed to be a boolean
combination of existential formulas. This yields near model completeness.
Note that if M has valency d, then it can be checked that |Mn+1| ≤(d +
2)|Mn| for all n. It follows that |Mn| ≤(d + 2)n for each n. In particular, C
has exponential model growth. We have not attempted to minimize growth and
chain complexity for a chain with limit M.
4.9 A robust approximation of (Q, <, +)
Our aim is to show that an o-minimal robust class can support some algebraic
structure, despite the discreteness of ﬁnite total orders, and thus approximate
an inﬁnite o-minimal structure on which at least one algebraic operation is
deﬁned. The goal here is to construct an o-minimal robust class whose direct
limit is (Q, <, +). The dense ordering can easily be constructed by dovetailing
embeddings as in Example 4.8.6; the difﬁculty lies in incorporating the group
operation. Since ordered groups are torsion-free, hence not locally ﬁnite, the
group operation must be given by a ternary relation symbol.
Theorem 4.9.1
Let L = {<, 0, −, R}, where −is a unary function, and R
is a ternary relation. Then there is an o-minimal robust class C such that T as
C
is near model complete, and T lim
C
is the theory of divisible ordered abelian
groups, with the addition function parsed as a ternary relation R.

170
Dugald Macpherson and Charles Steinhorn
Proof. For each n > 0, let Hn be the L-structure on {−n, −n + 1, . . . , 0,
. . . , n}, with 0, <, −interpreted naturally, and such that R(x, y, z) holds for
x, y, z ∈Hn if and only if x + y = z. Let H = {Hn : n > 0}.
A sequence (ak)k>0 of natural numbers is called legal if
a. (∀k > 0) 0 ≤ak < k
b. (∀k > 0)(∃ℓ> k)(∀r ≤k) ℓ≡ar
(mod r).
It is not difﬁcult to show that legal sequences exist. For example, one may argue
by induction employing the fact (see, e.g., [50, Section 2.3, Exercise 23]) that
for arbitrary integers m1, . . . , mr the system
x ≡a1
(mod m1), . . . , x ≡ar
(mod mr)
has a solution if and only if ai ≡aj (mod (mi, mj)) for all 1 ≤i < j ≤r.
Note also that the constant sequence (0)k>0 is legal. Let S be the set of all legal
sequences.
Let S = (ak)k>0 ∈S. From S, we can obtain a sequence (nk)k>0 such that
nk+1 ≫nk2 that further satisﬁes the condition that
(∀r) (∃ℓ) (∀k ≥ℓ) (∀s ≤r) nk ≡as
(mod s).
Let CS := {Hnk : k > 0}. To make CS into a chain, we must deﬁne how Hnk is
embedded into Hnk+1 for all k. To this end, let (dk)k>0 be a sequence of integers
so that 2 ≤dk ≤nk for all k and in which every m ≥2 appears inﬁnitely often.
Then we embed Hnk into Hnk+1 via the mapping i →dki. The intent of this is
to ensure that the direct limit structure of CS is isomorphic to (Q, <, +), with
x + y = z parsed as the relation R(x, y, z). Finally, let T as
S be the asymptotic
theory of CS, and T lim
S
be the limit theory. Observe that if S, S′ are distinct legal
sequences, then T as
S ̸= T as
S′ .
We shall prove that each theory T as
S is near model complete. It follows by
Proposition 4.7.4 that CS is robust and, as CS is totally ordered, that T as
S
is
complete. Lastly, we prove that CS is o-minimal.
For each M ∈CS, we deﬁne the span of M, span(M), and the hull of
M, hull(M). In fact, span(M) is isomorphic to (Z, <, R, 0), and hull(M) is
isomorphic to (Q, <, R, 0) – that is, the divisible hull of (Z, <, R, 0) – with R
interpreted as the graph of the group operation. In this proof, however, we shall
view span(M) and hull(M) as many sorted structures, with inﬁnitely many sorts,
to ensure that the span and hull of every model of T as
S (and its substructures) is
well-deﬁned.
First, 0 ∈span(M) and each positive element of span(M) has, for some
r > 0, a representative of the form (x1, . . . , xr), where x1, . . . , xr ∈M>0.
For intuition, the reader may interpret (x1, . . . , xr) as the sum x1 + · · · + xr.
Recursively on r + s, we deﬁne (x1, . . . , xr)E(y1, . . . , ys) as the symmetric

Deﬁnability in classes of ﬁnite structures
171
closure of the relation deﬁned to hold if xr ≥ys and (x1, . . . , xr−1, xr −
ys)E(y1, . . . , ys−1). For each x1, . . . , xr ∈M>0 as above, span(M) also con-
tains an element −(x1, . . . , xr) with representative (−x1, . . . , −xr). Addition
is deﬁned on E-classes by putting
(x1, . . . , xr)/E + (y1, . . . , ys)/E = (x1, . . . , xr, y1, . . . , ys)/E
and
−(x1, . . . , xr)/E + −(y1, . . . , ys)/E = −(x1, . . . , xr, y1, . . . , ys)/E.
Lastly,
if
x1, . . . , xr > 0
and
y1, . . . , ys < 0,
then
(x1, . . . , xr)/E +
(y1, . . . , ys)/E = (z1, . . . , zt)/E,
where
z1, . . . , zt > 0,
if
and
only
if
(x1, . . . , xr)/E = (−y1, . . . , −ys)/E + (z1, . . . , zt)/E.
It is convenient to extend the deﬁnitions to sequences (x1, . . . , xr) where
some xi are positive and some negative. First, for all permutations π ∈
Sym(r) we deﬁne (x1, . . . , xr)E(xπ(1), . . . , xπ(r)). Then if x1, . . . , xr > 0 and
xr+1, . . . , xs < 0, deﬁne (x1, . . . , xs)E(y1, . . . , yt), where yi > 0 for all i, to
hold if (x1, . . . , xr)/E = −(xr+1, . . . , xs)/E + (y1, . . . , yt)/E.
The group span(M) is an ordered group, with the ordering deﬁned
sortwise by (x1, . . . , xr)/E > 0 if and only if there are y1, . . . , ys > 0
with (x1, . . . , xr)E(y1, . . . , ys). It is now easily checked that span(M) is
a Z-group. The key point is that for every n > 1 and x1, . . . , xr > 0,
there are i ∈{0, . . . , n −1} and y1, . . . , yr′ > 0 such that n(y1, . . . , yr′) =
(x1, . . . , xr−1, xr −i). Also M clearly is convex in span(M).
Now we deﬁne hull(M) to be the divisible hull of span(M). Since the above
deﬁnitions are uniform across CS, they carry across to models M of T as
S : that
is, we may talk of span(M) and hull(M), deﬁned as above. As the deﬁnitions
are quantiﬁer-free, they apply also to substructures.
Model-theoretically, we remark that this construction may be understood as
analogous to that of the algebraic closure of a ﬁeld F: each ﬁnite extension
of F is interpretable in F, but the full algebraic closure lives on the union of
inﬁnitely many sorts of F eq.
The key element in the proof of the theorem is the following assertion.
Claim 4.9.2
Let M, N |= T as
S , and suppose that M, N have a common L-
substructure A. Then M ≡A N if and only if M ∩hull(A) ∼=A N ∩hull(A).
Proof. The left-to-right direction is immediate, since elements of hull(A) are
quantiﬁer-free deﬁnable over A.
For the right-to-left direction, we assume that M ∩hull(A) = N ∩hull(A)
and that M and N are saturated of the same cardinality > |A|. We build an
isomorphism ϕ : M →N that extends ϕ0 := idA. We further suppose that ϕ0
is extended to idhull(A).

172
Dugald Macpherson and Charles Steinhorn
The construction of the isomorphism proceeds through a series of steps.
Step 1 Let 1M := min{x ∈M : x > 0} and 1N := min{x ∈N : x > 0}.
Deﬁne ϕ(1M) = 1N. Then extend ϕ to hull(A ∪{1M}).
Step 2 Deﬁne ϕ(max(M)) = max(N), and extend ϕ to hull(A ∪{max(M)}).
In Step 1, we must check for all x ∈hull(A ∪1M) that x ∈M if and only
if ϕ(x) ∈N; likewise, in Step 2, with max(M) in place of 1M. This is done
carefully in the last paragraph of the argument in Step 3 below, so we omit the
details in this case. Note that it is needed here that max(M) and max(N) satisfy
the same congruence conditions, which holds as M, N |= T as
S .
Once Steps 1 and 2 have been completed, we may suppose that initially
1M = 1N ∈hull(A), which we denote by 1 in what follows, and that max(M) =
max(N) ∈hull(A). The remaining task is the following:
Step 3 We must extend ϕ to x ∈M \ dom(ϕ).
Put C := {y ∈hull(A) : y < x} and D := {y ∈hull(A) : x < y}. We ﬁrst
assert that for each z ∈C there is some az ∈span(A) with z ≤az < x.
Indeed, using the fact that for every n and every w ∈span(M), among the
elements w, w + 1, . . . , w + (n −1) there is an element that is divisible by
n, it is easy to see that if the assertion were false then we must have
z < x < z + 1. With z = z′/q, where z′ ∈span(A), q ∈Z \ {0}, it follows that
z′ < qx < z′ + q. Then z′, z′ + q ∈span(A) ⊆dom(ϕ), whence, as span(M)
is a Z-group, qx ∈dom(ϕ). It follows that x ∈dom(ϕ), a contradiction. A
similar argument shows that for each z ∈D there is some bz ∈span(A) with
x < bz ≤z.
Now let C′ := {az : z ∈C} and D′ := {bz : z ∈D}. So C′ < x < D′, and
C′, D′ ⊂span(A) ∩M. The preceding paragraph shows that C′ has no greatest
element and D′ no least element. By saturation of N we see that there is some
y ∈N such that C′ < y < D′ and x ≡y (mod k) for each positive integer k.
We put ϕ(x) = y, and extend ϕ to hull(A ∪{x}).
A typical element of hull(A ∪{x}) has the form
1
q (e1 + · · · + er + nx),
where q ∈Z and q ̸= 0, n is a positive integer, and e1, . . . , er ∈A (not neces-
sarily distinct). It remains to check that 1
q (e1 + · · · + er + nx) ∈M if and only
if
1
q (e1 + · · · + er + ny) ∈N. Observe ﬁrst that both e1 + · · · + er + nx ∈
span(M) and e1 + · · · + er + ny ∈span(N), and that e1 + · · · + er + nx >
max(M) if and only if e1 + · · · + er + ny > max(N). Thus, it sufﬁces to see
that e1 + · · · + er + nx ≡0 (mod q) in M if and only if e1 + · · · + er + ny ≡
0 (mod q) in N. This holds since x and y satisfy the same congruences. With
this, the proof of the claim is complete.
□

Deﬁnability in classes of ﬁnite structures
173
We now ﬁnish the proof of the theorem. First, we assert that T as
S is near model
complete. By Claim 4.9.2, it follows for all ¯a ∈M |= T as
S and substructures A of
M that tp(¯a/A) is determined by the collection of formulas which describe the
quantiﬁer-free type of ¯a over hull(A). Such formulas are boolean combinations
of existential formulas over A. From this and Proposition 4.7.4, it follows that
CS is robust. As CS is totally ordered, we also see that T as
S is complete.
It remains only to check that CS is o-minimal. Let G := lim CS, with x + y =
z parsed as R(x, y, z). It is evident that G is isomorphic to (Q, <, +), and hence
is o-minimal. The o-minimality of CS then follows immediately from the near
model completeness of T as
S and Proposition 4.7.7 .
□
Remark 4.9.3
By varying the embeddings, we may ﬁnd, for any S ∈S other
robust classes C′ with the same asymptotic theory T as
S
but different limits
theories. For example, we may realize the inﬁnite cyclic group Z as lim C′, by
putting C′ = C, equipped with the identity embeddings.
We expect that a variation of this argument should allow us to construct
(Q, +) as the limit of a strongly minimal robust class. It is an open problem to
construct an o-minimal robust chain whose limit is a real closed ﬁeld.

References
[1] G. Ahlbrandt, M. Ziegler, ‘Quasiﬁnitely axiomatizable totally categorical theories’,
Ann. Pure Appl. Logic 30 (1986), 63–82.
[2] J. Allsup, R. W. Kaye, ‘Normal subgroups of non-standard symmetric and alter-
nating groups’, Arch. Math. Logic 46 (2007), 107–121.
[3] M. Aschbacher, Finite Group Theory, 2nd Ed., Cambridge University Press, Cam-
bridge, 2000.
[4] J. Ax, ‘The elementary theory of ﬁnite ﬁelds’, Ann. Math. 88 (1968), 239–271.
[5] J.T. Baldwin, S. Shelah, ‘Randomness and semigenericity’, Trans. Amer. Math.
Soc. 349 (1997), 1359–1376.
[6] G. Bergman, H.W. Lenstra, ‘Subgroups close to normal subgroups’, J. Algebra
127 (1989), 80–97.
[7] O. Beyarslan, ‘Random Hypergraphs in Pseudoﬁnite Fields’, J. Inst. Math. Jussieu
9 (2010), 29–47.
[8] T. Blossier, ‘Ensembles minimaux localement modulaires’, Ph.D. thesis, Univer-
sit´e Paris VII, 2001.
[9] B. Bollob´as, A. Thomason, ‘Graphs which contain all small graphs’, Europ. J.
Comb. 2 (1981), 13–15.
[10] B. Bollob´as, Random Graphs, Academic Press, New York, 1985.
[11] S. Koppelberg, Handbook of Boolean Algebras Vol. 1 (Eds. J.D. Monk, R. Bonnet),
North-Holland, 1989.
[12] E.I. Bunina, A.V. Mikhalev, ‘Elementary properties of linear groups and related
problems’, J. Math. Sci. 123 (2004), 3921–3985.
[13] Z. Chatzidakis, L. van den Dries, A.J. Macintyre, ‘Deﬁnable sets over ﬁnite ﬁelds’,
J. Reine Angew. Math. 427 (1992), 107–135.
[14] Z. Chatzidakis, ‘Model theory of ﬁnite and pseudo-ﬁnite ﬁelds’, Ann. Pure Apl.
Logic 88 (1997), 95–108.
[15] G. Cherlin, L. Harrington, and A.H. Lachlan,‘ℵ0-categorical, ℵ0-stable structures’,
Ann. Pure Appl. Logic 28 (1985), 103–135
[16] G. Cherlin, A.H. Lachlan, ‘Stable ﬁnitely homogeneous structures’, Trans. Amer.
Math. Soc. 296 (1986), 815–850.
[17] G. Cherlin, ‘Large ﬁnite structures with few types’, in Algebraic model theory
(Eds. B. Hart, A.H. Lachlan, M. Valeriote), NATO ASI Series C, vol. 496, Kluwer,
Dordrecht, 1997, pp. 53–105.
174

Deﬁnability in classes of ﬁnite structures
175
[18] G. Cherlin, E. Hrushovski, Finite structures with few types, Annals of Mathematics
Studies No. 152, Princeton University Press, Princeton, 2003.
[19] P. Dello Stritto, ‘Asymptotic classes of ﬁnite Moufang polygons’, preprint.
[20] L. van den Dries, Tame topology and o-minimal structures, London Math. Soc
Lecture Notes 248, Cambridge University Press, 1998.
[21] H-D. Ebbinghaus, J. Flum, Finite model theory, Springer, 1999.
[22] R. Elwes, ‘Asymptotic classes of ﬁnite structures’, J. Symb. Logic 72 (2007),
418–438.
[23] R. Elwes, Dimension and measure in ﬁnite ﬁrst order structures, Ph.D. thesis,
University of Leeds, 2005.
[24] R. Elwes, E. Jaligot, H.D. Macpherson, M. Ryten, ‘Groups in supersimple and
pseudoﬁnite theories’, preprint.
[25] R. Elwes, H.D. Macpherson, ‘A survey of asymptotic classes and measurable
structures’, in Model theory with Aplications to Algebr and Analysis, vol. 2 (Eds.
Z. Chatzidakis, H.D. Macpherson, A. Pillay, A.J. Wilkie), London Math. Soc.
Lecture Notes no. 350, 2008, pp. 125–159.
[26] R. Elwes, M. Ryten, ‘Measurable groups of low dimension’, Math. Logic Quarterly
54 (2008), 374–386.
[27] Y.L. Ershov, ‘Undecidability of theories of symmetric and ﬁnite simple groups’,
Dokl. Akad. Nauk SSSR 158 (1964), 777–779.
[28] H. Gaifman, ‘On local and non-local properties’, Proceedings of the Herbrand
Symposium, Logic Colloquium ’81 (Ed. J. Stern), Studies in Logic and the Foun-
dation of Mathematics, vol. 107. Amsterdam: North Holland, 1982, 105–135.
[29] R. L. Graham, J. H. Spencer, ‘A constructive solution to a tournament problem’,
Canad. Math. Bull. 14 (1971), 45–48.
[30] W. Hodges, ‘Encoding orders and trees in binary relations’, Mathematika 28
(1981), 67–71.
[31] W. Hodges, Model Theory, Cambridge University Press, Cambridge, 1993.
[32] E. Hrushovski, ‘Totally categorical structures’, Trans. Amer. Math. Soc. 313
(1989), 131–159.
[33] E. Hrushovski, ‘Unimodular minimal structures’, J. London Math. Soc. (2) 46
(1992), 385–396.
[34] E. Hrushovski, ‘A new strongly minimal set’, Ann. Pure Appl. Logic 62 (1993),
147–166.
[35] E. Hrushovski, ‘Finite structures with few types’, in Finite and inﬁnite combina-
torics in sets and logic (Eds. N.W. Sauer, R.E. Woodrow, B. Sands), NATO ASI
Series C vol. 411, Kluwer, Dordrecht, 1993, pp. 175–187.
[36] E. Hrushovski, ‘Pseudoﬁnite ﬁelds and related structures’, in Model theory and
applications (Eds. L. B´elair, Z. Chatzidakis, P. D’Aquino, D. Marker, M. Otero,
F. Point, A. Wilkie), Quaderni di Matematica, vol. 11, Caserta, 2005, 151–212.
[37] E. Hrushovski, ‘The ﬁrst order theory of the Frobenius’, preprint, available at
http://front.math.ucdavis.edu/math.LO/0406514.
[38] E. Hrushovski, A. Pillay, ‘Deﬁnable subgroups of algebraic groups over ﬁnite
ﬁelds’, J. Reine Angew. Math. 462 (1995), 69–91.
[39] W.M. Kantor, M.W. Liebeck, H.D. Macpherson, ‘ℵ0-categorical structures
smoothly approximated by ﬁnite substructures’, Proc. London Math. Soc. (3)
59 (1989), 439–463.

176
Dugald Macpherson and Charles Steinhorn
[40] C. Kiefe, ‘Sets deﬁnable over ﬁnite ﬁelds: their zeta functions’, Trans. Amer. Math.
Soc. 223 (1976), 45–59.
[41] B. Kim, A. Pillay, ‘Simple theories’, Ann. Pure Appl. Logic 88 (1997), 149–164.
[42] L. Kramer, G. R¨ohrle, K. Tent, ‘Deﬁning k in G(k)’, J. Alg. 216 (1999), 77–85.
[43] A.H. Lachlan, ‘Two conjectures regarding the stability of ω-categorical theories’,
Fund. Math. 81 (1974), 133–145.
[44] A.H. Lachlan, ‘On countable stable structures which are homogeneous for a ﬁnite
relational language’, Israel J. Math. 49 (1984), 69–153.
[45] S. Lang, A. Weil, ‘Number of points of varieties in ﬁnite ﬁelds’, Am. J. Math. 76
(1954), 819–827.
[46] L. Libkin, Elements of Finite Model Theory, Springer, Heidelberg, 2004.
[47] M.W. Liebeck, H.D. Macpherson, K. Tent, ‘Primitive permutation groups of
bounded orbital diameter’, Proc. London Math. Soc. (3) 100 (2010), 216–248.
[48] H.D. Macpherson, C. Steinhorn, ‘One-dimensional asymptotic classes of ﬁnite
structures’, Trans. Amer. Math.Soc. 360 (2008), 411–448.
[49] R. Marshall, Robust classes of ﬁnite structures, Ph.D thesis, University of Leeds,
2008.
[50] I. Niven, H. Zuckerman, H. Montgomery, An Introduction to the Theory of Numbers
( Fifth Edition), John Wiley & Sons, 1991.
[51] A. Pillay and C. Steinhorn, ‘On discrete o-minimal structures’, J. Pure and Applied
Logic 34 (1987), 275–289.
[52] M. Ryten, Results around asymptotic and measurable groups, Ph.D. thesis, Uni-
versity of Leeds, 2007.
[53] M. Ryten, I. Tomaˇsi´c, ‘ACFA and measurability’, Selecta Math. (New series) 11
(2005), 523–537.
[54] T. Scanlon, ‘Fields admitting nontrivial strong ordered Euler characteristics are
quasiﬁnite’, unpublished manuscript, available at http://math.berkeley.edu/ scan-
lon/papers/papers.html.
[55] S. Shelah, ‘Simple unstable theories’, Ann. Pure Appl. Logic 19 (1980), 177–203.
[56] W. Szmielew, ‘Elementary properties of abelian groups’, Fund. Math. 41 (1955),
203–271.
[57] T. Sz¨onyi, ‘Some applications of algebraic curves in ﬁnite geometry and com-
binatorics’, in Surveys in Combinatorics (Ed. R. Bailey), London Math. Society
Lecture Notes 241, Cambridge University Press, Cambridge, 1997, pps. 197–236.
[58] A. Tarski, ‘Arithmetical classes and types of boolean algebras’, Bull. of the A.M.S.
55 (1949), 63.
[59] S. Thomas, Classiﬁcation theory of simple locally ﬁnite groups, Ph.D. thesis,
University of London, 1983.
[60] S. Thomas, ‘Reducts of random hypergraphs’, Ann. Pure Appl. Logic 80 (1996),
165–193.
[61] J. Tits, R. M. Weiss, Moufang polygons, Springer, 2002.
[62] F.O. Wagner, Simple theories, Kluwer, Dordrecht, 2000.
[63] J. Wiegold, ‘Groups with boundedly many ﬁnite classes of conjugate elements’,
Proc. Royal Soc. A 238 (1956), 389–401.

5
Algorithmic meta-theorems
stephan kreutzera
Abstract
Algorithmic meta-theorems are general algorithmic results applying to
a whole range of problems, rather than just to a single problem alone.
They often have a logical and a structural component, that is they are
results of the form: every computational problem that can be formalised
in a given logic L can be solved efﬁciently on every class C of structures
satisfying certain conditions.
This paper gives a survey of algorithmic meta-theorems obtained in
recent years and the methods used to prove them. As many meta-theorems
use results from graph minor theory, we give a brief introduction to the
theory developed by Robertson and Seymour for their proof of the graph
minor theorem and state the main algorithmic consequences of this theory
as far as they are needed in the theory of algorithmic meta-theorems.
5.1 Introduction
Algorithmic meta-theorems are general algorithmic results applying to a whole
range of problems, rather than just to a single problem alone. In this paper
we will concentrate on meta-theorems that have a logical and a structural
component, that is on results of the form: every computational problem that
can be formalised in a given logic L can be solved efﬁciently on every class C
of structures satisfying certain conditions.
The ﬁrst such theorem is Courcelle’s well-known result [13] stating that
every problem deﬁnable in monadic second-order logic can be solved efﬁciently
a Oxford University Computing Laboratory, University of Oxford, Oxford, OX1 3QD, UK
stephan.kreutzer@comlab.ox.ac.uk
177

178
Stephan Kreutzer
on any class of graphs of bounded tree-width1. Another example is a much more
recent result stating that every ﬁrst-order deﬁnable optimisation problem admits
a polynomial-time approximation scheme on any class C of graphs excluding
at least one minor (see [22]).
Algorithmic meta-theorems lie somewhere between computational logic and
algorithmorcomplexitytheoryandinsomesenseformabridgebetweenthetwo
areas. In algorithm theory, an active research area is to ﬁnd efﬁcient solutions
to otherwise intractable problems by restricting the class of admissible inputs.
For instance, while the dominating set problem is NP-complete in general, it
can be solved in polynomial time on any class of graphs of bounded tree-width.
In this line of research, algorithmic meta-theorems provide a simple and easy
way to show that a certain problem is tractable on a given class of structures.
Formalising a problem in MSO yields a formal proof for its tractability on
classes of structures of bounded tree-width, avoiding the task of working out
the details of a solution using dynamic programming – something that is not
always trivial to do but often enough solved by hand-wavy arguments such as
“using standard techniques from dynamic programming . . .”.
Another distinguishing feature of logic based algorithmic meta-theorems
is the observation that for a wide range of problems, such as covering or
colouring problems, their precise mathematical formulation can often directly
be translated into monadic second-order logic. Hence, ideally, instead of hav-
ing to design an explicit algorithm for solving a problem on bounded tree-
width graphs, one can read off tractability results directly from the problem
description.
Finally, algorithmic meta-theorems yield tractability results for a whole class
of problems providing valuable insight into how far certain algorithmic tech-
niques range. On the other hand, in their negative form of intractability results,
they also exhibit some limits to applications of certain algorithmic techniques.
In logic, one of the core tasks is the evaluation of logical formulas in
structures – a task underlying problems in a wide variety of areas in computer
science from database theory, artiﬁcial intelligence to veriﬁcation and ﬁnite
model theory.
Among the important logics studied in this context is ﬁrst-order logic and
its various fragments, such as its existential conjunctive fragment known as
conjunctive queries in database theory. Whereas ﬁrst-order model-checking is
Pspace-complete in general, even on input structures with only two elements,
it becomes polynomial time for every ﬁxed formula. So what can we possibly
1 The deﬁnition of tree-width and the other graph parameters and logics mentioned in the
introduction will be presented formally in the following sections.

Algorithmic meta-theorems
179
gain from restricting the class of admissible structures, if the problem is hard
as soon as we have two elements and becomes easy if we ﬁx the formula? Not
much, if the distinction is only between taking the formula as full part of the
input or keeping it ﬁxed.
A ﬁner analysis of ﬁrst-order model-checking can be obtained by studying
the problem in the framework of parameterized complexity (see [36, 46, 69]).
The idea is to isolate the dependence of the running time on a certain part of
the input, called the parameter, from the dependence on the rest. We will treat
parameterized complexity formally in Section 5.2.4. The parameterized ﬁrst-
order evaluation problem is the problem, given a structure A and a sentence ϕ ∈
FO, to decide whether A |= ϕ. The parameter is |ϕ|, the length of the formula. It
is called ﬁxed parameter tractable (FPT) if it can be solved in time f (|ϕ|) · |A|c,
for some ﬁxed constant c and a computable function f : N →N. While ﬁrst-
order model-checking is unlikely to be ﬁxed-parameter tractable in general
(unless unexpected results in parameterized complexity happen), Courcelle’s
theorem shows that even the much more expressive monadic second-order logic
becomes FPT on graph classes of bounded tree-width. Hence, algorithmic meta-
theorems give us a much better insight into the structure of model-checking
problems taking structural information into account.
Inthis paper wewill giveanoverview of algorithmicmeta-theorems obtained
so far and present the main methods used in their proofs. As mentioned before,
these theorems usually have a logical and a structural component. As for
the logic, we will primarily consider ﬁrst-order and monadic second-order
logic (see Section 5.2). As for the structural component, most meta-theorems
have been proved relative to some structure classes based on graph theory, in
particular on graph minor theory, such as classes of graphs of bounded tree-
width, planar graphs, or H-minor free graphs. We will therefore present the
relevant parts of graph structure theory needed for the proofs of the theorems
presented here.
The paper is organised as follows. In Section 5.2, we present basic notation
used throughout the paper. In Section 5.2.3 we present the relevant logics and
give a brief overview of their model-checking problem. Section 5.2.4 contains
an introduction to parameterized complexity. In Section 5.3, we introduce the
notion of the tree-width of a graph and establish some fundamental proper-
ties. We then state and prove theorems by Seese and Courcelle establishing
tractability results for monadic second-order logic on graph classes of bounded
tree-width. In Section 5.4 we present an extension of tree-width called clique-
width and a more recent, broadly equivalent notion called rank-width. Again
we will see that monadic second-order model checking and satisﬁability is
tractable on graph classes of bounded clique-width. Section 5.5 contains a brief

180
Stephan Kreutzer
introduction to the theory of graph minors to the extent needed in later sections
of the paper. The results presented in this section are then used in Section 5.7
to obtain tractability results on graph classes excluding a minor. In Section 5.7,
we also consider the concept of localisation of graph invariants and use it to
obtain further tractability results for ﬁrst-order model checking. But before,
in Section 5.6, we use the results obtained in Section 5.5 to show limits to
MSO-tractability. Finally, we conclude the paper in Section 5.9.
Remark
An excellent survey covering similar topics to this paper has recently
been written by Martin Grohe as a contribution to a book celebrating Wolfgang
Thomas’ 60th birthday [53]. While the two papers share a common core of
results, they present the material in different ways and with a different focus.
5.2 Preliminaries
In this section we introduce basic concepts from logic and graph theory and ﬁx
the notation used throughout the paper. The reader may safely skip this section
and come back to it whenever notation is unclear.
5.2.1 Sets
By N := {0, 1, 2, . . . } we denote the set of non-negative integers and by Z the
set of integers. For k ∈N we write [k] for the set [k] := {0, . . . , k −1}. For a
[k]
set M and k ∈N we denote by [M]k and [M]≤k the set of all subsets of M of
[M]k,
[M]≤k size k and size ≤k, respectively, and similarly for [M]<k.
5.2.2 Graphs
A graph G is a pair consisting of a set V (G) of vertices and a set E(G) ⊆
V (G)
[V (G)]2 of edges. All graphs in this paper are ﬁnite, simple, i.e. no multiple
E(G)
edges, undirected and loop-free. We will sometimes write G := (V, E) for a
graph G with vertex set V and edge set E. We denote the class of all (ﬁnite)
graphs by Graph.
Graph
An edge e := {u, v} is incident to its end vertices u and v and u, v
incident,
adjacent are adjacent. If G is a graph then |G| := |V (G)| is its order and ||G|| :=
|G|, ||G|| max{|V (G)|, |E(G)|} its size.
For graphs H, G we deﬁne the disjoint union G ˙∪H as the graph obtained as
the union of H and an isomorphic copy G′ of G such that V (G′) ∩V (H) = ∅.

Algorithmic meta-theorems
181
Subgraphs. A graph H is a subgraph of G, written as H ⊆G, if V (H) ⊆H ⊆G
V (G) and E(H) ⊆E(G) ∩[V (H)]2. If E(H) = E(G) ∩[V (H)]2 we call H
an induced subgraph.
Let G be a graph and U ⊆V (G). The subgraph G[U] induced by U in G is G[U]
the graph with vertex set U and edge set E(G) ∩[U]2.
For a set U ⊆V (G), we write G −U for the graph induced by V (G) \ U. G −U
Similarly, if X ⊆E(G) we write G −X for the graph (V (G), E(G) \ X). G −X
Finally, if U := {v} ⊆V (G) or X := {e} ⊆E(G), we simplify notation and G −
v,
G −e
write G −v and G −e.
Degree and neighbourhood. Let G be a graph and v ∈V (G). The neigh-
bourhood NG(v) of v in G is deﬁned as NG(v) := {u ∈V (G) : {u, v} ∈E(G)}.
The distance dG(u, v) between two vertices u, v ∈V (G) is the length of the NG(v)
shortest path from u to v or ∞if there is no such path. For every v ∈V (G) and
r ∈N we deﬁne the r-neighbourhood of v in G as the set
NG
r (v) := {w ∈V (G) : dG(v, w) ≤r}.
of vertices of distance at most r from v. For a set W ⊆V (G) we deﬁne
NG
r (W) := 
v∈W NG
r (v). We omit the index ·G whenever G is clear from the
context.
The degree of v is deﬁned as dG(v) := |NG(v)|. We will drop the index dG(v)
G whenever G is clear from the context. Finally, (G) := max{d(v) : v ∈V }
denotes the maximal degree, or just degree, of G and δ(G) := min{d(v) : v ∈(G)
V } the minimal degree.
δ(G)
Paths and walks. A walk P in G is a sequence x1, e1, . . . , xn, en, xn+1
such that ei := {xi, xi+1} ∈E(G) and xi ∈V (G). The length of P is n, i.e. the
number of edges. A path is a walk without duplicate vertices, i.e. vi ̸= vj
whenever i ̸= j. We ﬁnd it convenient to consider paths as subgraphs and
hence use V (P ) and E(P ) to refer to its set of vertices and edges, resp. An
X−Y-path, for X, Y ⊆V (G), is a path with ﬁrst vertex in X and last vertex
in Y. If X := {s} and Y := {t} are singletons, we simply write s−t-path.
A graph is connected if it is non-empty and between any two vertices s and
t there is an s−t-path. A connected component of a graph G is a maximal
connected subgraph of G.
Special graphs. For n, m ≥1 we write Kn for the complete graph on n Kn
vertices and Kn,m for the complete bipartite graph with one partition of order n Kn,m
and one of order m. Furthermore, if X is a set then K[X] denotes the complete K[X]
graph with vertex set X.
For n, m ≥1, the n × m-grid Gn×m is the graph with vertex set {(i, j) : 1 ≤Gn×m
i ≤n, 1 ≤j ≤m} and edge set {

(i, j), (i′, j ′)

: |i −i′| + |j −j′| = 1}. For

182
Stephan Kreutzer
•
•
•
•
•
•
•
•
•
•
•
•
Figure 5.1 A 3 × 4-grid
i ≥1, the subgraph induced by {(i, j) : 1 ≤j ≤m} is called the ith row of
Gn×m and for j ≥1 the subgraph induced by {(i, j) : 1 ≤i ≤n} is called the
jth column. See Figure 5.1 for a 3 × 4-grid.
Trees. A tree T is a connected acyclic graph. Often we will work with
rooted trees T with a distinguished vertex r, the root of T . A leaf in T is a
vertex of degree 1, all other vertices are called inner vertices. A tree is sub-
cubic, if all vertices have degree at most 3. It is cubic if every vertex has degree
3 or 1.
A directed tree is a rooted tree where all edges are directed away from
the root. A binary tree is a directed tree where every vertex has at most two
outgoing edges. In directed graphs, we view edges as tuples (u, v), where u is
the tail and v is the head of the edge, rather than sets {u, v}.
Coloured graphs. Let  be an alphabet. A -labelled tree is a pair (T, λ),
where T is a tree and λ : V (T ) → is a labelling function. Often,  will be a
set C of colours and then we call C-labelled trees C-coloured, or just coloured.
A -tree is a -labelled tree.
5.2.3 Logic
I assume familiarity with basic notions from mathematical logic. See e.g.
[38, 57] for an introduction to mathematical logic.
A signature σ := {R1, . . . , Rk, c1, . . . , cq} is a ﬁnite set of relation sym-
signature
bols Ri and constant symbols ci. To each relation symbol R ∈σ we assign
an arity ar(R). A σ-structure A is a tuple A :=

V (A), R1(A), . . . , Rk(A),
ar(R)
c1(A), . . . , cq(A)

consisting of a set V (A), the universe, for each Ri ∈σ
of arity ar(Ri) := r a set Ri(A) ⊆V (A)r and for each ci ∈σ a constant
ci(A) ∈V (A). We will usually use letters A, B, ... for structures. Their uni-
verse is denoted as V (A) and for each R ∈σ we write R(A) for the relation R
in the structure A and similarly for constant symbols c ∈σ.
Tuples of elements are denoted by a := a1, . . . ak. We will frequently write
a
a without stating its length explicitly, which will then be understood or not

Algorithmic meta-theorems
183
relevant. Abusing notation, we will treat tuples sometimes as sets and write
a ∈a, with the obvious meaning, and also a ⊆b to denote that every element
in a also occurs in b.
Two σ-structures A, B are isomorphic, denoted A ∼= B, if there is a bijection A ∼= B
π : V (A) →V (B) such that
r for all relation symbols R ∈σ of arity r := ar(R) and all a ∈V (A)r, a ∈
R(A) if, and only if, (π(a1), . . . , π(ar)) ∈R(B) and
r for all constant symbols c ∈σ, c(B) = π(c(A)).
Let σ be a signature. We assume a countably inﬁnite set of ﬁrst-order
variables x, y, . . . and second-order variables X, Y, . . . . A σ-term is a ﬁrst-
order variable or a constant symbol c ∈σ. The class of formulas of ﬁrst-order
logic over σ, denoted FO[σ], is inductively deﬁned as follows. If R ∈σ and x
is a tuple of σ-terms of length ar(R), then Rx ∈FO[σ] and if t and s are terms
then t = s ∈FO[σ]. Further, if ϕ, ψ ∈FO[σ], then so are (ϕ ∧ψ), (ϕ ∨ψ)
and ¬ϕ. Finally, if ϕ ∈FO[σ] and x is a ﬁrst-order variable, then ∃xϕ ∈FO[σ]
and ∀xϕ ∈FO[σ].
The class of formulas of monadic second-order logic over σ, denoted
MSO[σ], is deﬁned by the rules for ﬁrst-order logic with the following addi-
tional rules: if X is a second-order variable and ϕ ∈MSO[σ ˙∪{X}], then ∃Xϕ ∈
MSO[σ] and ∀Xϕ ∈MSO[σ]. Finally, we deﬁne FO := 
σ signature FO[σ] and
likewise for MSO.
First-order variables range over elements of σ-structures and monadic
second-order variables X range over sets of elements. Formulas ϕ ∈FO[σ]
are interpreted in σ-structures A in the obvious way, where atoms Rx denote
containment in the relation R(A), = denotes equality of elements, ∨, ∧, ¬
denote disjunction, conjunction and negation and ∃xϕ is true in A if there is
an element a ∈V (A) such that ϕ is true in A if x is interpreted by a. Analo-
gously, ∀xϕ is true in A if ϕ is true in A for all interpretations of x by elements
a ∈V (A).
For MSO[σ]-formulas, ∃Xϕ is true in A if there is a set U ⊆V (A) such that
ϕ is true if X is interpreted by U and analogously for ∀Xϕ.
The set of free variables of a formula is deﬁned in the usual way. We will
write ϕ(x) to indicate that the variables in x occur free in ϕ. Formulas without
free variables are called sentences. If ϕ is a sentence we write A |= ϕ if ϕ is A |= ϕ
true in A. If ϕ(x) has free variables x and a is a tuple of the same length as
x, we write A |= ϕ(a) or (A, a) |= ϕ if ϕ is true in A where the free variables A |= ϕ(a)
(A, a) |= ϕ
x are interpreted by the elements in a in the obvious way. We will sometimes
consider formulas ϕ(X) with a free second-order variable X. The notation
extends naturally to free second-order variables.

184
Stephan Kreutzer
We will use obvious abbreviations in formulas, such as →(implication), x ̸=
y instead of ¬x = y and k
i=1 ϕi and k
i=1 ϕi for disjunctions and conjunctions
over a range of formulas.
Example 5.2.1 1. An independent set, or stable set, in a graph G is a
independent
set
set X ⊆V (G) such that {u, v} ̸∈E for all u, v ∈X. The ﬁrst-order
sentence
ϕk := ∃x1 . . . ∃xk

1≤i<j≤k

xi ̸= xj ∧¬Exixj

is true in a graph G (considered as an {E}-structure in the obvious way) if,
and only if, G contains an independent set of size k.
2. A dominating set in a graph G is a set X ⊆V (G) such that for all
dominating
set
v ∈V (G), either v ∈X or there is a u ∈X such that {v, u} ∈E(G). The
formula
ϕ(X) := ∀x

Xx ∨∃z(Exz ∧Xz)

states that X is a dominating set. Precisely, a set U ⊆V (G) is a dominating
set in G if, and only if, (G, U) |= ϕ.
To say that a graph contains a dominating set of size k we can use the
formula ∃x1 . . . ∃xk∀y k
i=1

y = xi ∨Exiy

.
⊣
Note the difference between the formulas deﬁning an independent set and
a dominating set: whereas an independent set of size k can be deﬁned by
a formula using existential quantiﬁers only, i.e. without alternation between
existential and universal quantiﬁers, the formula deﬁning a dominating set of
size k contains one alternation of quantiﬁers. This indicates that the independent
set problem might be simpler than the dominating set problem, a realisation
that is reﬂected in the parameterized complexity of the problem as discussed
later (see Proposition 5.2.10).
Example 5.2.2 1. Consider the following MSO-formula
ϕ := ∀X

∃xXx ∧∀x∀y(Xx ∧Exy →Xy)

→∀xXx

.
The formula says of a graph G that all sets X ⊆V (G) which are non-empty
(∃xXx) and have the property that whenever v ∈X and {v, u} ∈E(G) then
also u ∈X, already contain the entire vertex set of G.
Clearly, G |= ϕ if, and only if, G is connected, as the vertex set of any
connected component satisﬁes

∃xXx ∧∀x∀y(Xx ∧Exy →Xy)

.

Algorithmic meta-theorems
185
2. A 3-colouring of a graph G is a function f : V (G) →{1, 2, 3} such that
f (u) ̸= f (v) for all {u, v} ∈E(G). The formula
ϕ := ∃C1∃C2∃C3

∀x
3
i=1
Cix

∧∀x∀y

Exy →
3
i=1
¬(Cix ∧Ciy)

is true in a graph G if, and only if, G is 3-colourable.
⊣
With any logic L, we can naturally associate the following decision problem,
called the model-checking problem of L.
MC(L)
Input:
Structure A and sentence ϕ ∈L.
Problem:
Decide A |= ϕ.
Much of this paper will be devoted to studying the complexity of model-
checking problems on various classes of graphs, primarily in the parameterized
setting introduced in the next section.
Another natural problem associated with any logic is its satisﬁabilityproblem satisﬁability
deﬁned as the problem to decide for a given sentence ϕ ∈L whether it has a
model. We will study this problem relative to a given class C of structures. This
is equivalent to asking whether the L-theory of C, i.e. the class of all formulas
ϕ ∈L which are true in every structure A ∈C, is decidable.
The quantiﬁer rank of a formula ϕ, denoted qr(ϕ), is the maximal number quantiﬁer rank
qr(ϕ)
of quantiﬁers in ϕ nested inside each other. If ϕ ∈MSO, we count ﬁrst- and
second-order quantiﬁers. For instance, the formula in Example 5.2.2 (1) has
quantiﬁer rank 3.
Let A be a structure and v1, . . . , vk be elements in V (A). For q ≥0, the ﬁrst-
order q-type tpFO
q
(A, v) of v is the class of all FO-formulas ϕ(x) of quantiﬁer-
ﬁrst-order
type
tpFO
q
(A, v)
rank ≤q such that A |= ϕ(v). Monadic second-order types tpMSO
q
(A, v) are tpMSO
q
(A, v)
deﬁned analogously.
By deﬁnition, types are inﬁnite. However, it is well known that there are only
ﬁnitely many FO or MSO-formulas of quantiﬁer rank ≤q which are pairwise
not equivalent. Furthermore, we can effectively normalise formulas in such a
way that equivalent formulas are normalised syntactically to the same formula.
Hence, we can represent types by their ﬁnite set of normalised formulas.
This has a number of algorithmic applications. For instance, it is decidable
if two types are the same and whether a formula ϕ is contained in a type
: we simply normalise ϕ to a formula ψ and check whether ψ ∈. Note,
however, that it is undecidable whether a set of normalised formulas is a type:

186
Stephan Kreutzer
by deﬁnition, types are satisﬁable and satisﬁability of ﬁrst-order formulas is
undecidable.
The following lemma, which essentially goes back to Feferman and Vaught
will be used frequently later on. We refer the reader to [53] or [64] for a proof.
Lemma 5.2.3 Let tp be either tpMSO or tpFO and let H, G be graphs such
that V (H) ∩V (G) = {v}. Let u ∈V (H) and w ∈V (G).
For all q ≥0, tpq(G ∪H, vuw) is uniquely determined by tpq(G, vw) and
tpq(H, uv) and this is effective, i.e. there is an algorithm that computes tpq(G ∪
H, vuw) given tpq(G, vw) and tpq(H, uv).
Suppose G = H1 ∪H2 can be decomposed into subgraphs H1, H2 such that
V (H1 ∩H2) = v. The importance of the lemma is that it allows us to infer the
truth of a formula in G from the q-type of v in H1 and H2, where q := qr(ϕ).
Hence, if G is decomposable in this way, we can reduce the question G |= ϕ
to the question on smaller graphs H1, H2. This will be of importance when we
study graph-decompositions such as tree-decompositions and similar concepts
in Section 5.3 and 5.4.
MSO-Interpretations
Let C be a class of σ-structures and D be a class of τ-structures. Suppose
we know already that MSO-model-checking is tractable on C and we want to
show that it is tractable on D also. Here is one way of doing this: ﬁnd a way
to “encode” a given graph G ∈D in a graph G′ ∈C and also to “rewrite”
the formula ϕ ∈MSO[τ] into a new formula ϕ′ ∈MSO[σ] so that G |= ϕ if,
and only if, G′ |= ϕ′. Then tractability of MSO-model checking on D follows
immediately from tractability on C – provided the encoding is efﬁcient.
MSO-interpretations help us in doing just this: they provide a way to rewrite
the formula ϕ speaking about D to a formula ϕ′ speaking about C and also give
us a translation of graphs “in the other direction”, namely a way to translate
a graph G′ ∈C to a graph G := 
(G′) ∈D so that G′ |= ϕ′ if, and only if,
G |= ϕ. Hence, to reduce the model checking problem for MSO on D to the
problem on C, we have to ﬁnd an interpretation 
 to translate the formulas from
D to C and an encoding of graphs G ∈D to graphs G′ ∈C so that 
(G′) ∼= G.
Figure 5.2 demonstrates the way interpretations are used as reductions.
We will ﬁrst deﬁne the notion of interpretations formally and then demon-
strate the concept by giving an example.
Deﬁnition 5.2.4 Let σ := {E, P1, . . . , Pk} and τ := {E} be signatures, where
E is a binary relation symbol and the Pi are unary. A (one-dimensional)

Algorithmic meta-theorems
187
Class D
Class C
G
G
ϕ ∈MSO[τ
(
Γ
]
ϕ) ∈MSO[σ]
Γ(G ) ∼=
G
G
algorithmic encoding
interpretation
interpretation
Figure 5.2 Using interpretations as reductions between problems
MSO interpretation from σ-structures to τ-structures is a triple 
 := MSO-
interpretation
(ϕuniv, ϕvalid, ϕE) of MSO[σ]-formulas.
For every σ-structure T with T |= ϕvalid we deﬁne a graph (i.e. τ-structure)
G := 
(T ) as the graph with vertex set V (G) := {u ∈V (T ) : T |= ϕuniv(v)}
and edge set
E(G) := {{u, v} ∈V (G) : T |= ϕE(u, v)}.
If C is a class of σ-structures we deﬁne 
(C) := {
(T ) : T ∈C, T |= ϕvalid}.
Every interpretation naturally deﬁnes a mapping from MSO[τ]-formulas ϕ
to MSO[σ]-formulas ϕ∗:= 
(ϕ). Here, ϕ∗is obtained from ϕ by recursively
replacing
r ﬁrst-order quantiﬁers ∃xϕ and ∀xϕ by ∃x(ϕuniv(x) ∧ϕ∗) and ∀x(ϕuniv(x)
→ϕ∗) respectively,
r second-order quantiﬁers ∃Xϕ and ∀Xϕ by ∃X

∀y(Xy →ϕuniv(y)) ∧ϕ∗
and ∀X

∀y(Xy →ϕuniv(y)) →ϕ∗
respectively and
r atoms E(x, y) by ϕE(x, y).
The following lemma is easily proved (see [57]).
Lemma 5.2.5 (interpretation lemma) Let 
 be an MSO-interpretation from
σ-structures to τ-structures. Then for all MSO[τ]-formulas and all σ-structures
G |= ϕvalid
G |= 
(ϕ)
⇐⇒

(G) |= ϕ.
Note that here we are using a restricted form of interpretations. In particular, we
only allow one free variable in the formula ϕuniv(x) deﬁning the universe of the
resulting graph. A consequence of this is that in any such an interpretation 
,
we always have |
(G)| ≤|G|. In general interpretations, ϕuniv(x) can have any

188
Stephan Kreutzer
number of free variables, so that the universe of the resulting structure consists
of tuples of elements and hence can be much (polynomially) larger than the
original structure. For our purposes, one-dimensional interpretations are enough
and we will therefore not consider more complex forms of interpretations as
discussed in e.g. [57].
Initially we studied interpretations to reduce complexity results from one
class C of graphs to another class D. This is done as follows. Let 
 be inter-
pretation from C in D, i.e. 
 is a set of formulas speaking about graphs in C so
that for all G ∈C, 
(G) ∈D.
We ﬁrst design an algorithm that encodes a given graph G ∈D in a graph
G′ ∈C so that 
(G′) ∼= G. Now, given G ∈D and ϕ ∈MSO as input, we
translate G to a graph G′ ∈C and use the interpretation 
 to obtain ϕ′ ∈MSO[σ]
such that G′ |= ϕ′ if, and only if, G |= ϕ. Then we can check – using the model-
checking algorithm for C – whether G′ |= ϕ′.
Example 5.2.6 Let C be the class of ﬁnite paths and D be the class of ﬁnite
cycles. Then 
(C) = D for the following interpretation 
 := (ϕuniv, ϕvalid, ϕE):
ϕuniv(x) = ϕvalid := true and
ϕE(x, y) := Exy ∨¬∃z1∃z2

z1 ̸= z2 ∧

(Exz1 ∧Exz2) ∨(Eyz1 ∧Eyz2)

The formula is true for a pair x, y if there is an edge between x and y or if
neither x nor y have two different neighbours. Hence, if P ∈C is a path then
G := 
(P) is the cycle obtained from P by connecting the two endpoints.
Now, if we know that MSO-model-checking is tractable on C then we can infer
tractability on D is follows. Given C ∈D and ϕ ∈MSO, delete an arbitrary
edge from C to obtain a path P ∈C and construct ϕ′ := 
(ϕ). Obviously,

(P) ∼= C and hence P |= ϕ′, if and only if, C |= ϕ.
⊣
5.2.4 Complexity
We assume familiarity with basic principles of algorithm design and analysis,
in particular Big-O notation, as can be found in any standard textbook on algo-
rithms, e.g. [11]. Also, we assume familiarity with basic complexity classes
such as Ptime, NP and Pspace and standard concepts from complexity theory
such as polynomial-time reductions as can be found in any text book on com-
plexity theory, e.g. [72]. By reductions we will generally mean polynomial-time
many-one reductions, unless explicitly stated otherwise.
The following examples introduce some of the problems we will be consid-
ering throughout the paper.

Algorithmic meta-theorems
189
Example 5.2.7 1. Recall from Example 5.2.1 that an independent set in an independent
set
graph G is a set X ⊆V (G) such that {u, v} ̸∈E for all u, v ∈X. The
independent set problem is deﬁned as
Independent Set
Input:
A graph G and k ∈N.
Problem:
Decide if G contains an independent set of size k.
2. Recall from Example 5.2.1 that dominating set in a graph G is a set X ⊆dominating
set
V (G) such that for all v ∈V (G), either v ∈X or there is a u ∈X such that
{v, u} ∈E(G). The dominating set problem is deﬁned as
Dominating Set
Input:
A graph G and k ∈N.
Problem:
Decide if G contains a dominating set of size k.
3. A k-colouring of a graph G is a function f : V (G) →{1, . . . , k} such that
f (u) ̸= f (v) for all {u, v} ∈E(G). Of particular interest for this paper is
the problem to decide if a graph can be coloured by three colours.
3-Colouring
Input:
A graph G.
Problem:
Decide if G has a 3-colouring.
⊣
It is well known that all three problems in the previous example are NP-
complete. Furthermore, we have already seen that the dominating set problem
can be reduced to ﬁrst-order model-checking MC(FO). Hence, the latter is NP-
hard as well. However, as the following lemma shows, MC(FO) is (presumably)
even much harder than Dominating Set.
Lemma 5.2.8 (Vardi [88]) MC(FO) and MC(MSO) are Pspace-complete.
Proof (sketch). It is easily seen that MC(MSO), and hence MC(FO) is in
Pspace: given A and ϕ ∈MSO, simply try all possible interpretations for the
variables quantiﬁed in ϕ. This requires only polynomial space.
Hardness of MC(FO) follows easily from the fact that QBF, the problem to
decide whether a quantiﬁed Boolean formula is satisﬁable, is Pspace-complete.
Given a QBF-formula ϕ := Q1X1 . . . QkXkψ, where ψ is a formula in proposi-
tional logic over the variables X1 . . . Xk and Qi ∈{∃, ∀}, we compute the ﬁrst-
order formula ϕ′ := ∃t∃f (t ̸= f ∧Q1x1 . . . Qkxkψ′), where ψ′ is obtained
from ψ by replacing each positive literal Xi by xi = t and each negative literal

190
Stephan Kreutzer
¬Xi by xi = f . Here, the variables t, f represent the truth values true and
false. Clearly, for every structure A with at least two elements, A |= ϕ′ if, and
only if, ϕ is satisﬁable.
□
An immediate consequence of the proof is that MC(FO) is hard even for
very simple structures: they only need to contain at least two elements. An
area of computer science where evaluation problems for logical systems have
intensively been studied is database theory, where ﬁrst-order logic is the logical
foundation of the query language SQL. A common assumption in database
theory is that the size of the query is relatively small compared to the size of the
database. Hence, giving the same weight to the database and the query may not
truthfully reﬂect the complexity of query evaluation. It has therefore become
standard to distinguish between three ways of measuring the complexity of
logical systems:
r combined complexity: given a structure A and a formula ϕ as input, what is
the complexity of deciding A |= ϕ measured in the size of the structure and
the size of the formula?
r data complexity: ﬁx a formula ϕ. Given a structure A as input, what is the
complexity of deciding A |= ϕ measured in the size of the structure only?
r expression complexity: ﬁx a structure A. Given a formula ϕ as input, what is
the complexity of deciding A |= ϕ measured in the size of the formula only?
As seen in Lemma 5.2.8, the combined complexity of ﬁrst-order logic is
Pspace-complete. Furthermore, the proof shows that even the expression com-
plexity is Pspace-complete, as long as we ﬁx a structure with at least two
elements. On the other hand, it is easily seen that for a ﬁxed formula ϕ, check-
ing whether A |= ϕ can be done in time |A|O(|ϕ|). Hence, the data complexity
of ﬁrst-order logic is in Ptime.
Besides full ﬁrst-order logic, various fragments of FO have been studied
in database theory and ﬁnite model theory. For instance, the combined com-
plexity of the existential conjunctive fragment of ﬁrst-order logic – known as
conjunctive queries in database theory – is NP-complete. And if we consider
the bounded variable fragment of ﬁrst-order logic, the combined complexity is
Ptime [89].
Much of this paper is devoted to studying model-checking problems for a
logic L on restricted classes C of structures or graphs, i.e. to study the problem
MC(L, C)
Input:
A ∈C and ϕ ∈L.
Problem:
Decide A |= ϕ.

Algorithmic meta-theorems
191
In Example 5.2.2, we have already seen that 3-colourability is deﬁnable by
a ﬁxed sentence ϕ ∈MSO. As the problem is NP-complete, this shows that the
data-complexity of MSO is NP-hard. In fact, it is complete for the polynomial
time hierarchy. There are, however, interesting classes of graphs on which the
data-complexity of MSO is Ptime. One example is the class of trees, another
are classes of graphs of bounded tree-width.
For ﬁrst-order logic there is not much to classify in terms of input classes
C, as the combined complexity is Pspace-complete as soon as we have at
least one structure of size ≥2 in C and the data complexity is always Ptime.
Hence, the classiﬁcation into expression and data complexity is too coarse for
an interesting theory. However, polynomial time data complexity is somewhat
unsatisfactory, as it does not tell us much about the degree of the polyno-
mials. All it says is that for every ﬁxed formula ϕ, deciding A |= ϕ is in
polynomial time. But the running time of the algorithms depends exponentially
on |ϕ| – and this is unacceptably high even for moderate formulas. Hence,
the distinction between data and expression complexity is only of limited
value for classifying tractable and intractable instances of the model checking
problem.
A framework that allows for a much ﬁner classiﬁcation of model-checking
problems is parameterized complexity, see [36, 46, 69]. A parameterized prob-
lem is a pair (P, χ), where P is a decision problem and χ is a polynomial
time computable function that associates with every instance w of P a positive
integer, called the parameter. Throughout this paper, we are mainly interested
in parameterized model-checking problems. For a given logic L and a class C
of structures we deﬁne2
MC(L, C)
Input:
Given A ∈C and ϕ ∈L.
Parameter:
|ϕ|.
Problem:
Decide A |= ϕ.
A parameterized problem is ﬁxed-parameter tractable, or in the complexity
class FPT, if there is an algorithm that correctly decides whether an instance w FPT
is in P in time
f (χ(w)) · |w|O(1),
for some computable function f : N →N. An algorithm with such a running
time is called an fpt algorithm. Sometimes we want to make the exponent fpt
algorithm
2 We abuse notation here and also refer to the parameterized problem as MC(L, C). As we will
not consider the classical problem anymore, there is no danger of confusion.

192
Stephan Kreutzer
of the polynomial explicit and speak of linear fpt algorithm, if the algorithm
achieves a running time of f (χ(w)) · |w|, and similarly for quadratic and
cubic fpt algorithms. We will sometimes relax the deﬁnition of parameterized
problems slightly by considering problems (P, χ) where the function χ is no
longer polynomial time computable, but is itself ﬁxed-parameter tractable. For
instance, this will be the case for problems where the parameter is the tree-
width of a graph (see Section 5.3.1), a graph parameter that is computable by
a linear fpt-algorithm but not in polynomial time (unless Ptime = NP). Every-
thing we need from parameterized complexity theory in this paper generalises
to this parametrization also. See [46, Chapter 11.4] for a discussion of this
issue.
In the parameterized world, FPT plays a similar role to Ptime in classical
complexity – a measure of tractability. Hence, much work has gone into classi-
fying problems into those which are ﬁxed-parameter tractable and those which
are not, i.e. those that can be solved by algorithms with a running time such as
O(2k2n2) and those which require something like O(nk), where k is the param-
eter. Running times of the form O(nk) yield the parameterized complexity class
XP, deﬁned as the class of parameterized problems that can be solved in time
XP
O(nf (k)), for some computable function f : N →N.
In terms of model-checking problems, a model-checking problem MC(L,
C) is in XP if, and only if, the data complexity of L on C is Ptime. Obviously,
FPT ⊆XP and this inclusion is strict, as can be proved using the time hierarchy
theorem. If FPT is the parameterized analogue of Ptime then XP can be seen as
the analogue of Exptime. And again, similar to classical complexity, there are
hierarchies of complexity classes in between FPT and XP. For our purpose, the
most important class is called W[1], which is the ﬁrst level of the W-hierarchy
W[1]
W-hierarchy formed by classes W[i], for all i ≥1. We refrain from giving the precise
deﬁnition of W[1] and the W-hierarchy and refer the reader to the monograph
[46]. For our purposes, it sufﬁces to know that FPT, XP and the W[i]-classes
form the following hierarchy
FPT ⊆W[1] ⊆W[2] ⊆· · · ⊆XP.
In some sense, W[1] plays a similar role in parameterized complexity as NP
in classical complexity, in that it is generally believed that FPT ̸= W[1] (as
far as these beliefs go) and proving that a problem is W[1]-hard establishes
that it is unlikely to be ﬁxed-parameter tractable, i.e. efﬁciently solvable in
the parameterized sense. The notion of reductions used here is fpt-reduction.
Again, we refer to [46].
We close the section by stating the parameterized complexity of some prob-
lems considered in this paper.

Algorithmic meta-theorems
193
Deﬁnition 5.2.9 1. The p-Dominating Set problem is the problem, given a
graph G and k ∈N, to decide whether G contains a dominating set of size
k. The parameter is k.
2. The p-Independent Set problem is the problem, given a graph G and
k ∈N, to decide whether G contains an independent set of size k. The
parameter is k.
3. The p-Clique problem is the problem, given a graph G and k ∈N, to
decide whether G contains a clique of size k. The parameter is k.
In the sequel, we will usually drop the preﬁx p−and simply speak about the
Dominating Set problem. It will always be clear from the context whether
we are referring to the parameterized or the classical problem.
Lemma 5.2.10 (Downey, Fellows [34, 35]) 1. p-Dominating Set is W[2]-
complete (see [34]).
2. p-Independent Set is W[1]-complete (see [35]).
3. p-Clique is W[1]-complete (see [35]).
We have already seen that dominating and independent sets of size k can
uniformly be formalised in ﬁrst-order logic. Hence MC(FO) is W[2]-hard as
well. In fact, it is complete for the parameterized complexity class AW[∗],
which contains all levels of the W-hierarchy and is itself contained in XP.
Finally, as 3-colourability is expressible in MSO, MSO model-checking is not
in XP unless NP = Ptime.
5.3 Monadic Second-Order Logic on Tree-Like Structures
It is a well-known fact, based on the close relation between monadic second-
order logic and ﬁnite tree- and word-automata (see e.g. [9, 31, 85, 86, 10, 46,
63]), that model-checking and satisﬁability for very expressive logics such as
MSO becomes tractable on the class of ﬁnite trees. At the core of these results
is the observation that the validity of an MSO sentence at the root of a tree
can be inferred from the label of the root and the MSO-types realised by its
successors. There are various ways in which this idea can be turned into a
proof or algorithm: we can use effective versions of Feferman-Vaught style
theorems (see e.g. [64]) or we can convert formulas into suitable tree-automata
and let them run on the trees. The aim of the following sections is to extend
the results for MSO and FO from trees to more general classes of graphs. The
aforementioned composition methods will in most cases provide the key to
obtaining these stronger results.

194
Stephan Kreutzer
In this section we generalise the results for MSO model-checking and satis-
ﬁability from trees to graphs that are no longer trees but still tree-like enough
so that model-checking and satisﬁability testing for such graphs can be reduced
to the case of trees.
5.3.1 Tree-Width
The precise notion for “tree-likeness” we use is the concept of tree-width. We
ﬁrst introduce tree-decompositions, establish some closure properties and then
comment on algorithmic problems in relation to tree-width.
Tree-Decompositions
Deﬁnition 5.3.1 A tree-decomposition of a graph G is a pair T :=
tree-
decomposition (T, (Bt)t∈V (T )) consisting of a tree T and a family (Bt)t∈V (T ) of sets Bt ⊆V (G)
such that
1. for all v ∈V (G) the set
B−1(v)
B−1(v) := {t ∈V (T ) : v ∈Bt}
is non-empty and connected in T and
2. for every edge e ∈E(G) there is a t ∈V (T ) with e ⊆Bt.
The width w(T ) of T is w(T ) := {|Bt| −1 : t ∈V (T )} and the tree-width of
tree-width,
w(T ) G is deﬁned as the minimal width of any of its tree-decompositions.
We refer to the sets Bt of a tree-decomposition as bags. For any edge
bags
e := {s, t} ∈E(T ) we call Bs ∩Bt the cut at or along the edge e. (The reason
cut
for this will become clear later. See Lemma 5.3.13.)
Example 5.3.2 Consider the graph in Figure 5.3 a). A tree-decomposition of
this graph is shown in Figure 5.3 b).
⊣
Example 5.3.3 Trees have tree-width 1. Given a tree T , the tree-decomposition
has a node t for each edge e ∈E(T ) labelled by Bt := e and suitable edges
connecting the nodes.
⊣
Example 5.3.4 The class of series-parallel graphs (G, s, t) with source s and
series-
parallel sink t is inductively deﬁned as follows.
1. Every edge {s, t} is series-parallel.
2. If (G1, s1, t1) and (G2, s2, t2) are series parallel with V (G1) ∩V (G2) = ∅,
then so are the following graphs:

Algorithmic meta-theorems
195
1
2
3
4
5
6
7
8
9
10
11
1,3,11
1,3,6,11
1,3,4,11
1,6,9,11
1,2,3,4
3,4,7,11
1,5,6,9
6,9,10,11
4,7,8,11
a) Graph G
b) Tree-decomposition of G of width 3.
Figure 5.3 Graph and tree-decomposition from Example 5.3.2
a) the graph (G, s, t) obtained from G1 ∪G2 by identifying t1 and s2 and
setting s = s1 and t = t2 (serial composition).
b) the graph (G, s, t) obtained from G1 ∪G2 by identifying s1 and s2 and
also t1 and t2 and setting s = s1 and t = t2 (parallel composition).
The class of series-parallel graphs has tree-width 2. Following the induc-
tive deﬁnition of series-parallel graphs one can easily show that every such
graph (G, s, t) has a tree-decomposition of width 2 containing a node labelled
by {s, t}. This is trivial for edges. For parallel and serial composition the
tree-decompositions of the individual parts can be glued together at the node
labelled by the respective source and sink nodes.
⊣
The ﬁnal example shows that grids have very high tree-width. Grids play
a special role in relation to tree-width. As we will see later, every graph of
sufﬁciently high tree-width contains a large grid minor. Hence, in this sense,
grids are the least complex graphs of high tree-width.
Lemma 5.3.5 For all n > 1, the n × n-grid Gn,n has tree-width n.
In the remainder of this section we will present some basic properties of
tree-decompositions and tree-width.
Closure Properties and Connectivity.
It is easily seen that tree-width is
preserved under taking subgraphs. For, if (T, (Bt)t∈V (T )) is a tree-decomposition
of width w of a graph G, then (T, (Bt ∩V (H))t∈V (T )) is a tree-decomposition of
H of width at most w. Further, if G and H are disjoint graphs, we can combine

196
Stephan Kreutzer
tree-decompositions for G and H to a tree-decomposition of the disjoint union
G ˙∪H by adding one edge connecting the two decompositions.
Lemma 5.3.6 Let G be a graph. If H ⊆G, then tw(H) ≤tw(G).
Further, if C1, . . . , Ck are the components of G, then
tw(G) = max{tw(Ci) : 1 ≤i ≤k}.
To state the next results, we need further notation. Let G be a graph and
(T, (Bt)t∈V (T )) be a tree-decomposition of G.
1. If H ⊆G we deﬁne B−1(H) := {t ∈V (T ) : Bt ∩V (H) ̸= ∅}.
B−1(H)
2. Conversely, for U ⊆T we deﬁne B(U) := 
t∈V (U) Bt.
B(U)
Occasionally, we will abuse notation and use B, B−1 for sets instead of sub-
graphs. The next lemma is easily proved by induction on |H| using the fact that
for each vertex v ∈V (G) the set B−1(v) is connected in any tree-decomposition
T of G and that edges {u, v} ∈E(G) are covered by some bag Bt for t ∈V (T ).
Hence, B−1(u) ∪B−1(v) is connected in T for all {u, v} ∈E(H).
Lemma 5.3.7 Let G be a graph and T := (T, (Bt)t∈V (T )) be a tree-
decomposition of G. If H ⊆G is connected, then so is B−1(H) in T .
Small tree-decompositions.
A priori, by duplicating nodes, tree-decomposi-
tions of a graph can be arbitrarily large (in terms of the number of nodes in the
underlying tree). However, this is not very useful and we can always avoid this
from happening. We will now consider tree-decompositions which are small
and derive various useful properties from this.
Deﬁnition 5.3.8 A tree-decomposition (T, (Bt)t∈V (T )) is small, if Bt ̸⊆Bu for
small tree-
decompositions all u, t ∈V (T ) with t ̸= u.
The next lemma shows that we can easily convert every tree-decomposition
to a small one in linear time.
Lemma 5.3.9 Let G be a graph and T := (T, (Bt)t∈V (T )) a tree-decomposition
of G.
Then there is a small tree-decomposition T ′ :=

T ′, (B′
t)t∈V (T ′))

of G of the
same width and with V (T ′) ⊆V (T ) and B′
t = Bt for all t ∈V (T ′).
Proof. Suppose Bs ⊆Bt for some s ̸= t. Let s = t1 . . . tn = t be the nodes of
the path from s to t in T . Then Bs ⊆Bt2, by deﬁnition of tree-decompositions.

Algorithmic meta-theorems
197
But then, (T ′, (Bt)t∈V (T ′)) with V (T ′) := V (T ) \ {s} and
E(T ′) :=

E(T ) \ {{v, s} : {v, s} ∈E(T )}

∪
{{v, t2} : {v, s} ∈E(T ) and v ̸= t2}.
is a tree-decomposition of G with V (T )′ ⊂V (T ). We repeat this until T is
small.
□
A consequence of this is the following result, which implies that in measuring
the running time of algorithms on graphs whose tree-width is bounded by a
constant k, it is sufﬁcient to consider the order of the graphs rather than their
size.
Lemma 5.3.10 Every (non-empty) graph of tree-width at most k contains a
vertex of degree at most k.
Proof. Let G be a graph and let T := (T, (Bt)t∈V (T )) be a small tree-decomposi-
tion of G of width k := tw(G). If |T | = 1, then |G| ≤k + 1 and there is nothing
to show. Otherwise let t be a leaf of T and s be its neighbour in T . As T is
small, Bt ̸⊆Bs and hence there is a vertex v ∈Bt \ Bs. By deﬁnition of tree-
decompositions, v must have all its neighbours in Bt and hence has degree at
most k.
□
Corollary 5.3.11 Every graph G of tree-width tw(G) ≤k has at most k ·
|V (G)| edges, i.e., for k > 0, ||G|| ≤k · |G|.
Separators.
We close this section with a characterisation of graphs of small
tree-width in terms of separators. This separation property allows for the
aforementioned applications of automata theory or Feferman-Vaught style
theorems.
Deﬁnition 5.3.12 Let G be a graph.
(i) Let X, Y ⊆V (G). A set S ⊆V (G) separates X and Y, or is a separator
for X and Y, if every path containing a vertex of Y and a vertex of Z separator
also contains a vertex of S. In other words, X and Y are disconnected
in G −S.
(ii) A separator of G is a set S ⊆V (G), so that G −S has more than one
component, i.e. there are sets X, Y ⊆V (G) such that S separates X
and Y and X \ S ̸= ∅and Y \ S ̸= ∅.
Lemma 5.3.13 Let (T, (Bt)t∈V (T )) be a small tree-decomposition of a
graph G.

198
Stephan Kreutzer
(i) If e := {s, t} ∈E(T ) and T1, T2 are the components of T −e, then
Bt ∩Bs separates B(T1) and B(T2).
(ii) If t ∈V (T ) is an inner vertex and T1, . . . , Tk are the components of
T −t then Bt separates B(Ti) and B(Tj), for all i ̸= j.
Proof. Let e := {s, t} ∈E(T ) and let T1, T2 be the components of T −e. As
T is small, X := B(T1) \ B(T2) ̸= ∅and Y := B(T2) \ B(T1) ̸= ∅. Suppose
there was an X −Y-path P in G not using any vertex from Bt ∩Bs. By
Lemma 5.3.7, B−1(P) is connected and hence there is a path in T from T1 to
T2 not using the edge e (as V (P) ∩Bt ∩Bs = ∅), in contradiction to T being
a tree.
Part (ii) can be proved analogously.
□
Recall from the preliminaries that for an edge e := {s, t} ∈E(T ) we refer to
the set Bs ∩Bt as the cut at the edge e. The previous lemma gives justiﬁcation
to this terminology, as the cut at an edge separates the graph. A simple con-
sequence of this lemma is the following observation, that will be useful later
on.
Corollary 5.3.14 Let G be a graph and T := (T, (Bt)t∈V (T )) be a tree-
decomposition of G. If X ⊆V (G) is the vertex set of a complete subgraph
of G, then there is a t ∈V (T ) such that X ⊆Bt.
Proof. By Lemma 5.3.9, there is a small tree-decomposition T ′ := (T ′,
(B′
t)t∈V (T ′)) such that V (T ′) ⊆V (T ) and B′
t = Bt for all t ∈V (T ′). Hence,
w.l.o.g. we may assume that T is small.
By Lemma 5.3.13, every cut at an edge e ∈E(T ) is a separator of the graph
G. Hence, as G[X] is complete, if e ∈E(T ) and T1, T2 are the two components
of T −e, then either X ⊆B(T1) or X ⊆B(T2) but not both. We orient every
edge e ∈E(T ) so that it points towards the component of T −e containing
all of X. As T is acyclic, there is a node t ∈V (T ) with no outgoing edge. By
construction, X ⊆Bt.
□
Corollary 5.3.15 tw(Kk) = k −1 for all k ≥1.
Algorithms and Complexity
The notion of tree-width has been introduced by Robertson and Seymour as
part of their proof of the graph minor theorem. Even before that, the notion
of partial k-trees, broadly equivalent to tree-width, had been studied in the
algorithms community. The relevance of tree-width for algorithm design stems
from the fact that the tree-structure inherent in tree-decompositions can be used
to design bottom-up algorithms on graphs of small tree-width to solve problems

Algorithmic meta-theorems
199
efﬁciently which in general are NP-hard. A key step in designing these algo-
rithms is to compute a tree-decomposition of the input graph. Unfortunately,
Arnborg, Corneil, and Proskurowski showed that deciding the tree-width of a
graph is NP-complete itself.
Theorem 5.3.16 (Arnborg, Corneil, Proskurowski [3]) The following problem
is NP-complete.
Tree-Width
Input:
Graph G, k ∈N.
Problem:
tw(G) = k?
However, the problem becomes tractable if the tree-width is not a part of the
input, i.e. if we are given a constant upper bound on the tree-width of graphs
we are dealing with.
A class C of graphs has bounded tree-width, if there is a k ∈N such that bounded
tree-width
tw(G) ≤k for all G ∈C. In [6] Bodlaender proved that for any class of graphs
of bounded tree-width tree-decompositions of minimal width can be computed
in linear time.
Theorem 5.3.17 (Bodlaender [6]) There is an algorithm which, given a graph
G as input, constructs a tree-decomposition of G of width k := tw(G) in time
2O(k3) · |G|.
The algorithm by Bodlaender is primarily of theoretical interest. We will
see later that many NP-complete problems can be solved efﬁciently on graph
classes of bounded tree-width. For these algorithms to work in linear time,
it is essential to compute tree-decompositions in linear time as well. From a
practical point of view, however, the cubic dependence on the tree-width in the
exponent and the complexity of the algorithm itself poses a serious problem.
But there are other simpler algorithms with quadratic or cubic running time in
the order of the graph but only linear exponential dependence on the tree-width
which are practically feasible for small values of k.
5.3.2 Tree-Width and Structures
So far we have only considered graphs and their tree-decompositions. We
will do so for most of the remainder, but at least want to comment on tree-
decompositions of general structures. We ﬁrst present the general deﬁnition of
tree-decompositions of structures and then give an alternative characterisation
in terms of the Gaifman- or comparability graph.

200
Stephan Kreutzer
Deﬁnition 5.3.18 Let σ be a signature. A tree-decomposition of a σ-structure
A is a pair T := (T, (Bt)t∈V (T )), where T is a tree and Bt ⊆V (A) for all
t ∈V (T ), so that
(i) for all a ∈V (A) the set B−1 := {t ∈V (T ) : a ∈Bt} is non-empty and
connected in T and
(ii) for every R ∈σ and all (a1, . . . , aar(R)) ∈R(A)ar(R) there is a t ∈V (T )
such that {a1, . . . , aar(R)} ⊆Bt.
The width w(T ) is deﬁned as max{|Bt| −1 : t ∈V (T )} and the tree-width of
A is the minimal width of any of its tree-decompositions.
The idea is the same as for graphs. We want the tree-decomposition to
contain all elements of the structure and at the same time we want each tuple in
a relation to be covered by a bag of the decomposition. It is easily seen that the
tree-decompositions of a structure coincide with the tree-decompositions of its
Gaifman graph, deﬁned as follows.
Deﬁnition 5.3.19 (Gaifman-graph) Let σ be a signature. The Gaifman-graph
of a σ-structure A is deﬁned as the graph G(A) with vertex set V (A) and an
G(A)
edge between a, b ∈V (A) if, and only if, there is an R ∈σ and a ∈R(A) with
a, b ∈a.
The following observation is easily seen.
Proposition 5.3.20 A structure has the same tree-decompositions as its
Gaifman-graph.
So far we have treated the notion of graphs informally as mathematical
structures. As a preparation to the next section, we consider two different ways
of modelling graphs by logical structures. The obvious way is to model a graph
G as a structure A over the signature σGraph := {E}, where V (A) := V (G)
σGraph
and E(A) := {(a, b) ∈V (A) × V (A) : {a, b} ∈E(G)}. We write A(G) for this
A(G)
encoding of a graph as a structure and refer to it as the standard encoding.
Alternatively, we can model the incidence graph of a graph G deﬁned as
incidence
graph the graph GInc with vertex set V (G) ∪E(G) and edges E(GInc) := {(v, e) :
v ∈V (G), e ∈E(G), v ∈e}. The incidence graph gives rise to the following
encoding of a graph as a structure, which we refer to as the incidence encoding.
Deﬁnition 5.3.21 Let G := (V, E) be a graph. Let σinc := {PV , PE, I), where
PV , PE are unary predicates and I is a binary predicate. The incidence structure
AI(G) is deﬁned as the σinc-structure A := AI(G) where V (A) := V ∪E,

Algorithmic meta-theorems
201
PE(A) := E, PV (A) := V and
I(A) := {(v, e) : v ∈V, e ∈E, v ∈e}.
The proof of the following lemma is straightforward but may be a good
exercise.
Theorem 5.3.22 tw(G) = tw(AI(G)) for all graphs G.
It may seem to be a mere technicality how we encode a graph as a structure.
However, the precise encoding has a signiﬁcant impact on the expressive power
of logics on graphs. For instance, the following MSO[σinc]-formula deﬁnes that
a graph contains a Hamilton-cycle using the incidence encoding, a property
that is not deﬁnable in MSO on the standard encoding (see e.g. [37, Corollary
6.3.5]).
∃U ⊆PE∀v“v has degree 2 in G[U]” ∧ϕconn(U),
where ϕconn is a formula saying that the subgraph G[U] induced by U is
connected. Clearly, it is MSO-deﬁnable that a vertex v is incident to exactly two
edges in U, i.e. has degree 2 in G[U]. The formula says that there is a set U
of edges so that G[U] is connected and that every vertex in G[U] has degree
2. But this means that U is a simple cycle P in G. Further, as all vertices of G
occur in P, this cycle must be Hamiltonian.
Hence, MSO is more expressive over incidence graphs than over the standard
encoding of graphs. It is clear that MSO interpreted over incidence graphs is
the same as considering the extension of MSO by quantiﬁcation over sets of
edges (rather than just sets of vertices) on the standard encoding. This logic is
sometimes referred to as MSO2 in the literature. A more general framework are MSO2
guarded logics, that allow quantiﬁcation only over tuples that occur together in
some relation in the structure. On graphs, guarded second-order logic (GSO)
is just MSO2. As we will not be dealing with general structures in the rest of GSO
this survey, we refrain from introducing guarded logics formally and refer to
[2, 51] and references therein instead.
5.3.3 Coding Tree-Decompositions in Trees
The aim of the following sections is to show that model-checking and satisﬁa-
bility testing for monadic second-order logic becomes tractable when restricted
to graph classes of small tree-width. The proof of these results relies on a reduc-
tion from graph classes of bounded tree-width to classes of ﬁnite labelled trees.
As a ﬁrst step towards this we show how graphs of tree-width bounded by some
constant k can be encoded in k-labelled ﬁnite trees for a suitable alphabet k

202
Stephan Kreutzer
depending on k. We will also show that the class of graphs of tree-width k, for
some k ∈N, is MSO-interpretable in the class of k-labelled trees.
A tree-decomposition (T, (Bt)t∈V (T )) of a graph G is already a tree and we
will take T as the underlying tree of the encoding. Thus, all we have to do is
to deﬁne the labelling. Note that we cannot simply take the bags Bt as labels,
as we need to work with a ﬁnite alphabet and there is no a priori bound on the
number of vertices in the bags. Hence we have to encode the vertices in the
bags using a ﬁnite number of labels. To simplify the presentation we will be
using tree-decompositions of a special form.
Deﬁnition 5.3.23 A leaf-decomposition of a graph G is a tree-decomposition
leaf-
decompositionT := (T, (Bt)t∈V (T )) of G such that all leaves of V (T ) contain exactly one
vertex and every v ∈V (G) is contained in exactly one leaf of T .
In other words, in leaf-decompositions there is a bijection ρ between the
set of leaves of the decomposition and the set of vertices of the graph and the
bag Bt of a leaf t contains exactly its image ρ(t). It is easily seen that any
tree-decomposition can be converted into a leaf-decomposition of the same
width.
Lemma 5.3.24 For every tree-decomposition T of a graph G there is a leaf-
decomposition T ′ of G of the same width and this can be computed in linear
time, given T .
To deﬁne the alphabet k, we will work with a slightly different form of
tree-decompositions where the bags are no longer sets but ordered tuples of
vertices. It will also be useful to require that all these tuples have the same
length and that the tree underlying a tree-decomposition is a binary directed
tree.3
Deﬁnition 5.3.25 An ordered tree-decomposition of width k of a graph G is
a pair (T, (bt)t∈V (T )), where T is a directed binary tree and bt ∈V (G)k, so
that (T, (Bt)t∈V (T )) is a tree-decomposition of G, with Bt := {b0, . . . , bk} for
bt := b0, . . . , bk.
An ordered leaf-decomposition is the ordered version of a leaf-decom-
position.
Example 5.3.26 Consider again the graph from Example 5.3.2. The following
shows an ordered leaf-decomposition obtained from the tree-decomposition in
3 Note that, strictly speaking, to apply the results on MSO on ﬁnite trees we have to work with
trees where an ordering on the children of a node is imposed. Clearly we can change all
deﬁnitions here to work with such trees. But as this would make the notation even more
complicated, we refrain from doing so.

Algorithmic meta-theorems
203
Example 5.3.2 by ﬁrst adding the necessary leaves containing just one vertex
and then converting every bag into an ordered tuple of length 4.
(1,3,11,1)
(1,1,1,1)
(11,11,11,11)
)
4
,
4
,
4
,
4
(
)
1
1
,
4
,
3
,
1
(
)
1
1
,
6
,
3
,
1
(
(1,6,9,11)
(3,4,7,11)
(1,2,3,4)
(1,5,6,9)
(6,9,10,11)
(4,7,8,11) (2,2,2,2) (3,3,3,3)
(5,5,5,5) (6,6,6,6) (9,9,9,9) (10,10,10,10)
(7,7,7,7) (8,8,8,8)
The graph G together with this leaf-decomposition induces the following
3-labelled tree:
t1
t2
t3
t4
t5
t6
t7
t8
t9
t10
t11
t12
t13
t14
t15
t16
t14
t15
t16
t16
where, for instance, λ(t4) :=

eq(t4), overlap(t4), edge(t4)

, with
r eq(t4) := ∅,
r overlap(t4) := {(0, 0), (0, 3), (1, 1), (3, 2)}, and
r edge(t4) := {(0, 1), (1, 2), (1, 3), (2, 3)} ∪{(1, 0), (2, 1), (3, 1), (3, 2)}.
eq(t4) := ∅, as all positions of bt4 correspond to different vertices in G. On the
other hand, eq(t15) := {(i, j) : i, j ∈{0, . . . , 3}}, as all entries of b15 refer to
the same vertex 5.
⊣

204
Stephan Kreutzer
It is easily seen that every tree-decomposition of width k can be converted in
linear time to an ordered tree-decomposition of width k. Combining this with
Bodlaender’s algorithm (Theorem 5.3.17) and Lemma 5.3.24 above yields the
following lemma.
Lemma 5.3.27 There is an algorithm that, given a graph G of tree-width
≤k, constructs an ordered leaf-decomposition of G of width tw(G) in time
2O(k3) · |G|.
Now let G be a graph and L := (T ′, (bt)t∈V (T ′)) be an ordered leaf-
decomposition of G of width k. We code L in a labelled tree T := (T, λ),
so that L and G can be reconstructed from T , and this reconstruction can even
be done by MSO formulas.
The tree T underlying T is the tree T ′ of L. To deﬁne the alphabet and the
labels of the nodes let t ∈V (T ) and let bt := b0, . . . , bk.
We set
λ(t)
λ(t) := (eq(t), overlap(t), edge(t))
where eq(t), overlap(t), edge(t) are deﬁned as follows:
r eq(t) := {(i, j) : 0 ≤i, j ≤k and bi = bj}.
eq(t)
r If t is the root of T , then overlap(t) := ∅. Otherwise let p be the predecessor
of t in T and let bp := a0, . . . , ak. We set
overlap(t)
overlap(t) := {(i, j) : 0 ≤i, j ≤k and bi = aj}.
r Finally, edge(t) := {(i, j) : 0 ≤i, j ≤k and {bi, bj} ∈E(G)}.
edge(t)
For every ﬁxed k, the labels come from the ﬁnite alphabet
k
k := 2{0,...,k}2 × 2{0,...,k}2 × 2{0,...,k}2.
We write T (G, L) for the labelled tree encoding a leaf-decomposition L of a
T (G, L)
graph G. Note that the signature depends on the arity k of the ordered leaf-
decomposition L, i.e. on the bound on the tree-width of the class of graphs we
are working with.
The individual parts of the labelling have the following meaning. Recall that
we require all tuples bt to be of the same length k + 1 and therefore they may
contain duplicate entries. eq(t) identiﬁes those entries in a tuple relating to the
same vertex of the graph G. The label overlap(t) takes care of the same vertex
appearing in tuples of neighbouring nodes of the tree. As we are working with
directed trees, every node other than the root has a unique predecessor. Hence
we can record in the overlap-label of the child which vertices in its bag occur

Algorithmic meta-theorems
205
at which positions of its predecessor. Finally, edge encodes the edge relation
of G. As every edge is covered by a bag of the tree-decomposition, it sufﬁces
to record for each node t ∈V (T ) the edges between elements of its bag bt.
The labels eq(t), overlap(t) and edge(t) satisfy some obvious consistency
criteria, e.g. eq(t) is an equivalence relation for every t, eq(t) is consistent
with edge(t) in the sense that if two positions i, i′ refer to the same vertex,
i.e. (i, i′) ∈eq(t) and (i, j) ∈edge(t) then also (i′, j) ∈edge(t), and likewise
for eq(t) and overlap(t). We refrain from giving all necessary details. Note,
though, that any k-labelled ﬁnite tree that satisﬁes these consistency criteria
does encode a graph of tree-width at most k. Furthermore, the criteria as outlined
above are easily seen to be deﬁnable in MSO, in fact even in ﬁrst-order logic.
Again we refrain from giving the exact formula as its deﬁnition is long and
technical but absolutely straightforward. Let ϕcons be the MSO-sentence true in ϕcons
a k-labelled tree if, and only if, it satisﬁes the consistency criteria, i.e. encodes
a tree-decomposition of a graph of tree-width at most k.
Of course, to talk about formulas deﬁning properties of k-labelled trees
we ﬁrst need to agree on how k-labelled trees are encoded as structures. For
k ∈N we deﬁne the signature
σk
σk := {E} ∪{eqi,j, edgei,j, overlapi,j : 0 ≤i, j ≤k},
where eqi,j, overlapi,j, and edgei,j are unary relation symbols. The intended
meaning of eqi,j is that in a σk-structure A an element t is contained in eqi,j(A)
if (i, j) ∈eq(t) in the corresponding tree. Likewise for overlapi,j and edgei,j.
σk-structures, then, encode k-labelled trees in the natural way. In the sequel,
we will not distinguish notationally between a k-labelled tree T and the
corresponding σk-structure AT . In particular, we will write T |= ϕ, for an
MSO-formula ϕ, instead of AT |= ϕ.
Clearly, the information encoded in the k-labelling is sufﬁcient to recon-
struct the graph G from a tree T (G, L), for some ordered leaf-decomposition
of G of width k. Note that different leaf-decompositions of G may yield non-
isomorphic trees. Hence, the encoding of a graph in a k-labelled tree is not
unique but depends on the decomposition chosen. For our purpose this does
not pose any problem, though.
The next step is to deﬁne an MSO-interpretation

 := (ϕuniv(x), ϕvalid, ϕE(x, y))

of the class Tk of graphs of tree-width at most k in the class Tk of k-labelled
ﬁnite trees. To state the interpretation formally, we need to deﬁne the three
formulas ϕuniv(x), ϕvalid, and ϕE(x, y). Recall that in a leaf-decomposition L
there is a bijection between the leaves of T and the vertices of the graph that is

206
Stephan Kreutzer
being decomposed. Hence, we can take ϕuniv(x) to be the formula
ϕuniv(x) := ∀y¬Exy
saying that x is a leaf in T .
Let G be a graph and L := (T, (bt)t∈V (T )) be an ordered leaf-decomposition
of G of width k. Suppose we are given two leaves tu, tv of L containing u and v
respectively and we want to decide whether there is an edge between u and v.
Clearly, if e := {u, v} ∈E(G), then e must be covered by some bag, i.e. there
are a node t in L with bag bt := b0 . . . bk and i ̸= j such that bi = u and bj = v
and (i, j) ∈edge(t) in the tree T := T (G, L). Further, u occurs in every bag
on the path from t to tu and likewise for v. Hence, to deﬁne ϕE(x, y), where
x, y are interpreted by leaves, we have to check whether there is such a node t
and paths from x and y to t as before. For this, we need an auxiliary formula
which we deﬁne next.
Recall that each position i in a bag bt corresponds to a vertex in G. Hence,
we can associate vertices with pairs (t, i). In general, a vertex can occur at
different positions i and different nodes t ∈V (T ). We can, however, identify
any vertex v with the set
Xv := {(t, i) : t ∈V (T ) and v occurs at position i in bt}.
Xv
We call Xv the equivalence set of v. If t ∈V (T ) and 0 ≤i ≤k, we deﬁne the
equivalence set of (t, i) as the equivalence set of bi, where bt := b0, . . . , bk.
Clearly, this identiﬁcation of vertices with sets of pairs and the concept of
equivalent sets extends to the labelled tree T := T (G, L), as T and L share
the same underlying tree.
To deﬁne sets Xv in MSO, we represent Xv by a tuple X := (X0, . . . , Xk)
of sets Xi ⊆V (T ), such that for all 0 ≤i ≤k and all t ∈V (T ), t ∈Xi if, and
only if, (t, i) ∈Xv.
We are going to describe an MSO-formula ψ(X0, . . . , Xk) that is satisﬁed by
a tuple X if, and only if, X is the equivalence set of a pair (t, i), or equivalently
of a vertex v ∈V (G). To simplify notation, we will say that a tuple X contains
a pair (t, i) if t ∈Xi. Consider the formulas
ψeq(X0, . . . , Xk) :=

i
∀t ∈Xi
 
j̸=i
eqi,j(t) →t ∈Xj

and
ψoverlap(X0, . . . , Xk) := ∀s∀t

i,j

E(s, t) ∧t ∈Xi ∧overlapi,j(t)

→s ∈Xj.

Algorithmic meta-theorems
207
ψeq(X) says of a tuple X that X is closed under the eq-labels and ψoverlap(X) says
the same of the overlap-labels. Now let ψ(X) := ψeq ∧ψoverlap. ψ is satisﬁed
by a tuple X if whenever X contains at a pair (t, i), then it contains the complete
equivalence set of (t, i). Now, consider the formula
ϕvertex
ϕvertex(X0, . . . , Xk) := ψ(X) ∧X ̸= ∅∧∀X
′ ̸= ∅

X
′ ⊊X →¬ψ(X
′)

where “X ̸= ∅” deﬁnes that at least one Xi is non-empty and “X
′ ⊊X” is an
abbreviation for a formula saying that X′
i ⊆Xi, for all i, and for at least one i
the inclusion is strict.
ϕvertex(X) is true for a tuple if X is non-empty, closed under eq and overlap,
but no proper non-empty subset of X is. Hence, X is the equivalence set of a
single vertex v ∈V (G). The deﬁnition of ϕvertex(X) is the main technical part
of the MSO-interpretation 
 := (ϕuniv(x), ϕvalid, ϕE(x, y)).
We have already deﬁned ϕuniv(x) := ∀y¬Exy. For ϕvalid, recall from above
the formula ϕcons true in a k-labelled tree T if, and only if, T encodes a
tree-decomposition of a graph G of tree-width at most k. To deﬁne ϕvalid we
need a formula that not only requires T to encode a tree-decomposition of G
but a leaf-decomposition.
To force the encoded tree-decomposition to be a leaf-decomposition, we
further require the following two conditions.
1. For all leaves t ∈V (T ) and all i ̸= j, (i, j) ∈eq(t).
2. For all t ∈V (T ) and all 0 ≤i ≤k the equivalence set of (t, i) contains
exactly one leaf.
Both conditions can easily be deﬁned by MSO-formulas ϕ1 and ϕ2, respectively,
where in the deﬁnition of ϕ2 we use the formula ϕvertex deﬁned above.
Hence, the formula
ϕvalid := ϕcons ∧ϕ1 ∧ϕ2
ϕvalid
is true in a k-labelled tree T (or the corresponding σk-structure) if, and only
if, T encodes a leaf-decomposition of width k.
Finally, we deﬁne the formula ϕE(x, y) saying that there is an edge between
x and y in the graph G encoded by a k-labelled tree T := (T, λ). Note that
there is an edge in G between x and y if, and only if, there is a node t ∈V (T )
and 0 ≤i ̸= j ≤k such that (i, j) ∈edge(t) and x is the unique leaf in the
equivalence set of (t, i) and y is the unique leaf in the equivalence set of (t, j).
This is formalised by
ϕE(x, y) := ∃t

i̸=j
edgei,j(t) ∧∃X∃Yϕvertex(X) ∧ϕvertex(Y) ∧
X1(x) ∧Y1(y) ∧Xi(t) ∧Yj(t)

.

208
Stephan Kreutzer
This completes the deﬁnition of 
. Now, the proof of the following lemma
is immediate.
Lemma 5.3.28 Let G be a graph of tree-width ≤k and L be a leaf-
decomposition of G of width k. Let T := T (G, L) be the tree-encoding of
L and G. Then G ∼= 
(T ).
Further, by the interpretation lemma, for all MSO-formulas ϕ and all k-
trees T |= ϕvalid,
T |= 
(ϕ)
⇐⇒

(T ) |= ϕ.
5.3.4 Courcelle’s Theorem
In this section and the next we consider computational problems for monadic
second-order logic on graph classes of small tree-width. The algorithmic theory
of MSO on graph classes of small tree-width has, essentially independently,
been developed by Courcelle, Seese and various co-authors. We ﬁrst consider
the model-checking problem for MSO and present Courcelle’s theorem. We
then state a similar theorem by Arnborg, Lagergreen and Seese concerning the
evaluation problem of MSO. In the next section, we consider the satisﬁability
problem and prove Seese’s theorem.
Theorem 5.3.29 (Courcelle [13]) The problem
MC(MSO, tw)
Input:
Graph G, ϕ ∈MSO
Parameter:
|ϕ| + tw(G)
Problem:
G |= ϕ?
is ﬁxed parameter tractable and can be solved in time f (|ϕ|) + 2p(tw(G)) · |G|,
for a polynomial p and a computable function f : N →N.
That is, the model-checking problem for a ﬁxed formula ϕ ∈MSO can be
solved in linear time on any class of graphs of bounded tree-width.
Proof. Let C be a class of bounded tree-width and let k be an upper bound for
the tree-width of C. Let ϕ ∈MSO be given.
On input G ∈C we ﬁrst compute an ordered leaf-decomposition L of G of
width k. From this, we compute the tree T := T (G, L). We then check whether
T |= 
(ϕ), where 
 is the MSO-interpretation of the previous section.
Correctness of the algorithm follows from Lemma 5.3.28. The time bounds
follow from Lemma 5.3.24 and the fact that MSO model-checking is in linear

Algorithmic meta-theorems
209
time (for a ﬁxed formula) on the class of trees (see e.g. [63, Chapter 7] or [46,
Chapter 10]).
□
We will see a different proof of this theorem using logical types later when
we prove Lemma 5.7.12. The result immediately implies that parametrized
problems such as the independence set or dominating set problem or problems
such as 3-colourability and Hamiltonicity are solvable in linear time on classes
of graphs of bounded tree-width.
Without proof we state the following extension of Courcelle’s theorem which
essentially follows from [4]. The proof uses the same methods as described
above and the corresponding result for trees.
Theorem 5.3.30 (Arnborg, Lagergreen, Seese [4]) The problem
Input:
Graph G, ϕ(X) ∈MSO, k ∈N.
Parameter:
|ϕ| + tw(G).
Problem:
Determine whether there is a set S ⊆V (G) such that
G |= ϕ(S) and |S| ≤k and compute one if it exists.
is ﬁxed-parameter tractable and can be solved by an algorithm with running
time f (|ϕ|) + 2p(tw(G)) · |G|, for a polynomial p and a computable function
f : N →N.
Recall that by the results discussed in Section 5.3.2 the previous results also
hold for MSO on incidence graphs, i.e. MSO2 where quantiﬁcation over sets of
edges is allowed also.
Corollary 5.3.31 The results in Theorem 5.3.29 and 5.3.30 extend to MSO2.
5.3.5 Seese’s Theorem
We close this section with another application of the interpretation deﬁned in
Section 5.3.3. Recall that MSO2 has set quantiﬁcation over sets of vertices as
well as sets of edges and corresponds to MSO interpreted over the incidence
encoding of graphs.
Theorem 5.3.32 (Seese [81]) Let k ∈N be ﬁxed. The MSO2-theory of the class
of graphs of tree-width at most k is decidable.
Proof. Let 
 := (ϕuniv, ϕvalid, ϕE) be the interpretation deﬁned in Section 5.3.3.
On input ϕ we ﬁrst construct the formula ϕ∗:= 
(ϕ). Using the decidability
of the MSO-theory of ﬁnite labelled trees, we then test whether there is a
k-labelled tree T such that T |= ϕvalid ∧ϕ∗.

210
Stephan Kreutzer
If there is such a tree T , then, as T |= ϕvalid, there is a graph G of tree-width
at most k encoded by T which satisﬁes ϕ. Otherwise, ϕ is not satisﬁable by
any graph of tree-width at most k.
□
Again without proof, we remark that the following variant of Seese’s theorem
is also true.
Theorem 5.3.33 (Adler, Grohe, Kreutzer [1]) For every k it is decidable whe-
ther a given MSO-formula is satisﬁed by a graph of tree-width exactly k.
We remark that there is a kind of converse to Seese’s theorem which we will
prove in Section 5.6 below.
Theorem 5.3.34 (Seese [81]) If C is a class of graphs with a decidable MSO2-
theory, then C has bounded tree-width.
The proof of this theorem relies on a result proved by Robertson and Sey-
mour as part of their proof of the graph minor theorem. We will present the
graph theory needed for this in Section 5.5 and a proof of Theorem 5.3.34 in
Section 5.6.
5.4 From Trees to Cliques
In the previous section we considered graphs that are sufﬁciently tree-like so
that efﬁcient model-checking algorithms for monadic second-order logic can be
devised following the tree-structure of the decomposition. On a technical level
these results rely on Feferman-Vaught style results allowing to infer the truth
of an MSO sentence in a graph from the MSO types of the smaller subgraphs
it can be decomposed into. In this section we will see a different property of
graphs that also allows for efﬁcient MSO model-checking. It is not based on
the idea of decomposing the graph into smaller parts of lower complexity, but
instead it is based on the idea of the graphs being uniform in some way, i.e. not
having too many types of its vertices.
As a ﬁrst example let us consider the class {Kn : n ∈N} of cliques. Obvi-
ously, these graphs have as many edges as possible and cannot be decomposed in
any meaningful way into parts of lower complexity. However, model-checking
for ﬁrst-order logic or monadic second-order logic is simple, as all vertices look
the same. In a way, a clique is no more complex than a set: the edges do not
impose any meaningful structure on the graph. This intuition is generalised by
the notion of clique-width of a graph. It was originally deﬁned in terms of graph
grammars by Courcelle, Engelfriet and Rozenberg [17]. Independently, Wanke

Algorithmic meta-theorems
211
introduced k-NLC graphs, a notion that is equivalent to Courcelle et al.’s deﬁ-
nition up to a factor of 2. The term clique-width was introduced in [19]. Clique-
decompositions (or k-expressions as they are called) are useful for the design
of algorithms, as they again provide a tree-structure along which algorithms
can work. However, until recently algorithms using clique-decompositions had
to be given the decomposition as input, as no ﬁxed-parameter algorithms were
known to compute the decomposition.
In 2006, Oum and Seymour [71] introduced the notion of rank-width and
corresponding rank-decompositions, a notion that is broadly equivalent to
clique-width in the sense that for every class of graphs, one is bounded if,
and only if, the other is bounded. Rank-decompositions can be computed by
fpt-algorithms parametrized by the width and from a rank-decomposition a
clique-decomposition can be generated. In this way, the requirement of algo-
rithms being given the decomposition as input has been removed. But rank-
decompositions are also in many other ways the more elegant notion.
We ﬁrst recall the deﬁnition of clique-width in Section 5.4.1. In Section 5.4.2,
we then introduce general rank-decompositions of submodular functions, of
which the rank-width of a graph is a special case. As a side effect, we also obtain
the notion of branch-width, which is another elegant characterisation of tree-
width. Model-checking algorithms for MSO on graph classes of bounded rank-
width are presented in Section 5.4.3, where we also consider the satisﬁability
problem for MSO and a conjecture by Seese.
5.4.1 Clique-Width
Deﬁnition 5.4.1 (k-expression) Let k ∈N be ﬁxed. The set of k-expressions
is inductively deﬁned as follows:
k-expression
(i) i is a k-expression for all i ∈[k].
(ii) If i ̸= j ∈[k] and ϕ is a k-expression, then so are edgei−j(ϕ) and
renamei→j(ϕ).
(iii) If ϕ1, ϕ2 are k-expressions, then so is (ϕ1 ⊕ϕ2).
A k-expression ϕ generates a graph G(ϕ) coloured by colours from [k] as
follows: The k-expression i generates a graph with one vertex coloured by the i
colour i and no edges.
The expression edgei−j is used to add edges. If ϕ is a k-expression generat- edgei−j
ing the coloured graph G := G(ϕ) then edgei−j(ϕ) deﬁnes the graph H with
V (H) := V (G) and
E(H) := E(G) ∪

{u, v} : u has colour i and v has colour j

.

212
Stephan Kreutzer
1
2
3
4
5
6
7
8
9
10
11
Figure 5.4 Graph from Example 5.3.2
Hence, edgei−j(ϕ) adds edges between all vertices with colour i and all vertices
with colour j.
The operation renamei→j(ϕ) recolours the graph. Given the graph G gener-
renamei→j(ϕ)
ated by ϕ, the k-expression renamei→j(ϕ) generates the graph obtained from
G by giving all vertices which have colour i in G the colour j in H. All other
vertices keep their colour.
Finally, if ϕ1, ϕ2 are k-expressions generating coloured graphs G1, G2
respectively, then (ϕ1 ⊕ϕ2) deﬁnes the disjoint union of G1 and G2.
We illustrate the deﬁnition by an example.
Example 5.4.2 Consider again the graph from Example 5.3.2 depicted in Fig-
ure 5.3. For convenience, the graph is repeated below. We will show how this
graph can be obtained by a 6-expression.
Consider the expression ϕ0 in Figure 5.5, which generates the graph in
Figure 5.6 a). The labels in the graph represent the colours. Here we use
obvious abbreviations such as edgei−j,s−t to create edges between i and j as
well as edges between s and t in one step.
The vertices generated so far correspond to the vertices 5, 6, 9, 10 of the
graph in Figure 5.4. Note that we have already created all edges incident
to vertex 9. Hence, in the construction of the rest of the graph, the vertex
9 (having colour 2) does not have to be considered any more. We will use
the colour 0 to mark vertices that will not be considered in further steps of
the k-expression. Let ϕ1 := rename2→0(ϕ0) be the 6-expression that gener-
ates the graph in Figure 5.6 a), but where the vertex with colour 2 now has
colour 0.
The next step is to generate the vertex 11 of the graph. This is done by the
expression ϕ2 := rename5→0

edge1−5,1−4

1 ⊕ϕ1

. We proceed by adding the

Algorithmic meta-theorems
213
edge 2 −3
4 −5
2 −4
⊕
edge2−5
edge3−4
⊕
⊕
2
5
3
4
Figure 5.5 The 6-expression ϕ0 generating the graph in Fig. 5.6 a)
3
4
2
5
2
5
0
0
0
0
1
0
1
1
0
0
1
1
0
0
0
a) G(ϕ1)
b) G(ϕ3)
c) G(ϕ5)
Figure 5.6 Graphs generated by the 6-expressions in Example 5.4.2
vertices 1 and 3 and the appropriate edges. Let
ϕ3 := rename3→0,4→0edge2−3,4−5,1−5

ϕ2 ⊕

edge2−5(2 ⊕5)

This generates the graph depicted in Figure 5.6 b). The next step is to add the
vertices 7 and 8. Let
ϕ4 := rename1→0edge1−3,1−4,3−5

ϕ3 ⊕edge3−4(3 ⊕4)

Finally, we add the vertex 2 and rename the colour of the vertex 2 to 0,
i.e. essentially remove the colour, and rename all other colours to 1.
ϕ5 := rename2→0,5→1,3→1,4→1edge1−2,1−5(1 ⊕ϕ4)
This generates the graph in Figure 5.6 c).
Finally, we add the vertex 4 and edges to all other vertices marked by the
colour 1.
The complete expression generating the graph is therefore edge1−2(2 ⊕ϕ5).
⊣

214
Stephan Kreutzer
It is easily seen that every ﬁnite graph can be generated by a k-expression for
some k ∈N. Just choose a colour for each vertex and add edges accordingly.
Lemma 5.4.3 Every ﬁnite graph can be generated4 by a k-expression for some
k ∈N.
Hence, the following concepts are well deﬁned.
Deﬁnition 5.4.4 The clique-width cw(G) of a graph G is deﬁned as the least
clique-width
k ∈N such that G can be generated by a k-expression. A class C of graphs has
bounded clique-width if there is a k ∈N such that cw(G) ≤k for all G ∈C.
We give a few more examples.
Example 5.4.5 1. The class of cliques has clique-width 2. (Clique-width 2, as
the edgei,j operator requires i ̸= j to avoid self-loops).
2. The class of all trees has clique-width 3. By induction on the height of the
trees we show that for each tree T there is a 3-expression generating this
tree so that the root is coloured by the colour 1 and all other nodes are
coloured by 0. This is trivial for trees of height 0. Suppose T is a tree of
height n + 1 with root r and successors v1, . . . , vk of r. For 1 ≤i ≤k let
ϕi be a 3-expression generating the subtree of T rooted at vi. Then T is
generated by the expression
rename2→1rename1→0edge2−1(2 ⊕ϕ1 ⊕· · · ⊕ϕk).
3. It can be shown that the clique-width of the (n × n)-grid is (n). (This
follows, for instance, from Theorem 5.4.7 below).
⊣
The next theorem due to Wanke and also Courcelle and Olariu relates clique-
width to tree-width.
Theorem 5.4.6 ([91, 19]) Every graph of tree-width at most k has clique-width
at most 2k+1 + 1.
As the examples above show, there is no hope to bound the tree-width of
a graph in terms of its clique-width. Hence, clique-width is more general than
tree-width in the sense that more graph classes have bounded clique-width
than bounded tree-width. Gurski and Wanke [55] established the following
relation between clique-width and tree-width in terms of complete bipartite
subgraphs.
4 By “generating” we always mean up to isomorphism. That is, a graph G is generated by an
expression ϕ if ϕ deﬁnes a graph isomorphic to G.

Algorithmic meta-theorems
215
Theorem 5.4.7 (Gurski, Wanke [55]) Let G be a graph of clique-width5 k such
that for some n > 1 the complete bipartite graph Kn,n is not a subgraph of G.
Then tw(G) ≤3k(n −1) −1.
Another interesting relation between clique-width and tree-width follows
from a connection, due to Oum [70], between the branch-width of a graph
and the rank-width of its incidence graph which we will present at the end of
Section 5.4.2.
As seen in the previous section, the notion of tree-width is preserved by tak-
ing subgraphs, induced subgraphs, minors, and other transformations. Clique-
width is less robust. It is easily seen that clique-width is preserved under
taking induced subgraphs. But it is not preserved under taking arbitrary sub-
graphs and hence not preserved under taking minors. For instance, cliques have
clique-width 2 but every graph is a subgraph of a clique and we know that there
are graphs of arbitrarily high clique-width.
Proposition 5.4.8
(i) If G is a graph and H is an induced subgraph of G,
then cw(H) ≤cw(G).
(ii) Clique-width is not preserved under taking subgraphs and hence not
preserved under taking minors. That is, there are graphs G and H ⊆G
with cw(H) > cw(G) and the difference can be arbitrarily large.
We close this section with a negative result concerning the complexity of
deciding clique-width and related measures. Gurski and Wanke showed that
deciding the NLC-width of a graph is NP-complete. For clique-width, this was
shown by Fellows, Rosamond, Rotics and Szeider.
Theorem 5.4.9 1. Given a graph G and an integer k, the problem to decide
whether G has NLC-width at most k is NP-complete (see [56]).
2. Given a graph G and an integer k, the problem to decide whether G has
clique-width at most k is NP-complete (see [42]).
However, as we will see in the next section, there are FPT-algorithms, para-
metrized by the clique-width, to compute an approximate clique-decomposition
of a given graph.
Finally, we mention a result by Espelage, Gurski and Wanke [41], that the
clique-width of a graph can be computed in linear time on graph classes of
bounded tree-width.
5 In [91] Wanke introduced the notion of k-node label controlled graphs (k-NLC). They are
deﬁned by similar operations as in k-expressions and for every graph G we have
cw(G) ≤nlc(G) ≤2 · cw(G), where nlc(G) denotes the NLC-width. The result in [55] is
actually stated and proved in terms of NLC-width.

216
Stephan Kreutzer
5.4.2 Rank-Width
In this section we consider an alternative characterisation of graph classes
of bounded clique-width – the rank-width of a graph. Rank-width is a spe-
cial case of abstract branch-decompositions of connectivity functions which
we present ﬁrst. Another special case of this abstract notion is the branch-
width of graphs, a notion that is equivalent up to a small constant factor to
tree-width.
Branch-Decompositions of Connectivity Functions
Let M be a ﬁnite non-empty set and f : 2M →R be a function. A branch-
decomposition of the pair (M, f ) is a pair (T, β) consisting of a binary tree
abstract
branch-
decomposition
T and a bijection β : L(T ) →M from the set L(T ) of leaves of T to M. We
inductively deﬁne a map β∗: V (T ) →2M by setting
β∗(t) :=

{β(t)}
if t is a leaf
β∗(t1) ∪β∗(t2)
if t is an inner node with successors t1 ∪t2.
The width of (T, β) is deﬁned as max{f (β∗(t)) : t ∈V (T )} and the branch-
width of (M, f ) is deﬁned as the minimal width of any of its branch-
abstract
branch-width
decompositions. If M is empty, we deﬁne the branch-width of M to be f (∅).
Note that in this case, (M, f ) does not have a branch-decomposition, as a tree,
being connected, cannot be empty.
Of particular interest are branch-decompositions of connectivity functions f
which are integer valued, symmetric and submodular. A function f : 2M →R
is symmetric if f (A) = f (M \ A) for all A ⊆M and it is submodular if f (A) +
symmetric
submodular f (B) ≥f (A ∩B) + f (A ∪B) for all A, B ⊆M. Submodular and symmetric
connectivity functions are algorithmically particularly well-behaved. Note that
if f is symmetric we can take the tree T of a branch-decomposition of (M, f )
to be undirected and cubic (i.e. every vertex has degree 1 or 3). We will
occasionally do so, for instance in Figure 5.7 below.
In [71], Oum and Seymour showed that optimal branch-decompositions
of submodular, symmetric, and integer valued connectivity functions can be
approximated up to a factor 3 by an fpt-algorithm. Before we can state the result
we need to deﬁne how the input to such an algorithm is represented. Let M
be a class of pairs (M, f ), where f : 2M →N is symmetric and submodular.
M is a tractable class of connectivity functions if there is a representation of
tractable class
the pairs (M, f ) ∈M such that, given the representation of a pair (M, f ), the
underlying set M and the values f (A) can be computed in polynomial time for
all A ⊆M.

Algorithmic meta-theorems
217
4
1
6
3
2
5
a
c
b
d
e
f
{1, 4}
{3, 5}
{1, 5}
{3, 2}
{2, 1}
{6, 4}
{3, 6}
(a) Graph G
(b) Branch-decomposition of G of width 2.
Figure 5.7 Branch-decomposition of width 2
We are primarily interested in certain connectivity functions naturally
associated with graphs and in this case the graph itself will be the
representation.
Theorem 5.4.10 (Oum, Seymour [71]) Let M be a tractable class of connec-
tivity functions. Then there is an fpt-algorithm that, on input (the represen-
tation of) (M, f ) and a parameter k, computes a branch-decomposition of
(M, f ) of width at most 3k provided that the branch-width of (M, f ) is at
most k. If the branch-width of (M, f ) is greater than k, then the algorithm
may halt without output or still compute a branch-decomposition of (M, f ) of
width ≤3k.
As a ﬁrst example of abstract branch-decompositions we consider the
branch-width of graphs.
Branch-Width of Graphs
Let G be a graph. The boundary ∂F of a set F ⊆E(G) is deﬁned as the set of boundary, ∂F
vertices incident to an edge in F and also an edge in E(G) \ F.
We deﬁne a function bG : 2E(G) →N by bG(F) := |∂F| for all F ⊆E(G).
The function bG is symmetric and submodular. A branch-decomposition of G branch-
decomposition
is a branch-decomposition of (E(G), bG) and the branch-width bw(G) of G is branch-
width
deﬁned as the branch-width of (E(G), bG).
Example 5.4.11 Figure 5.7 shows a graph and its branch-decomposition of
width 2. For example, β∗(d) =

{1, 5}, {3, 5}

and ∂β∗(d) = {1, 3}, as the
vertex 5 has no edge to a vertex other than 1, 3. Similarly, ∂β∗(b) = ∂β∗(e) =
∂β∗(e) = {1, 3} and ∂β∗(f ) = {3, 4}.
⊣
Example 5.4.12 (Robertson, Seymour [75]) 1. For every n ≥3, the n-clique
Kn has branch-width 2
3 · n.
2. For all n ≥2, the n × n-grid has branch-width n.

218
Stephan Kreutzer
3. A graph has branch-width 0 if, and only if, it has maximal degree at most 1.
4. Trees and cycles have branch-width at most 2.
⊣
As the following theorem shows, the branch-width of a graph is equivalent
to its tree-width up to a small constant factor.
Theorem 5.4.13 (Robertson, Seymour [75]) For all graphs G
bw(G)
≤
tw(G) + 1
≤
max{2, 3
2 bw(G)}.
Proof. To show bw(G) ≤tw(G) + 1, let T := (T, (Bt)t∈V (T )) be a tree-
decomposition of G of width k := tw(G), such that T is a binary tree and
every edge of G is covered by exactly one leaf of T . Clearly, given a tree-
decomposition of G we can easily ﬁnd one of the same width with this addi-
tional property. We deﬁne a branch-decomposition B := (T ′, β) of G as fol-
lows: T ′ = T and for a leaf t ∈L(T ) of T we set β(t) := e, where e is the
(unique) edge covered by Bt. We deﬁne β∗: V (T ) →2E(G) as before. It is
easily seen that for all t ∈V (T ), ∂β∗(t) ⊆Bt and hence the width of B is at
most k + 1.
Conversely, let B := (T, β) be a branch-decomposition of G of width bw(G).
For each t ∈V (T ) we deﬁne Bt ⊆V (G) as follows. If t is a leaf of T deﬁne
Bt := β(t). Now let t be an inner node with children t1, t2. For i = 1, 2
let Fi := β∗(ti) and let F3 :=

E(G) \ β∗(t)

=

E(G) \ (F1 ∪F2)

. We deﬁne
Bt := ∂F1 ∪∂F2 ∪∂F3.
By construction, |Fi| ≤bw(G). We claim that for all v ∈V (G), if v occurs
in some ∂Fi then it also occurs in ∂Fj for some j ̸= i. For, if v ∈∂Fi
then there must be edges e ∈Fi and e′ ∈E(G) \ Fi with v ∈e and v ∈e′.
Hence, e′ ∈Fj for some j ̸= i and therefore v ∈∂Fj. If follows that |Bt| ≤
max{2, 3
2 bw(G)}.
Now let T := (T, (Bt)t∈V (T )). It is easily veriﬁed that T is indeed a tree-
decomposition of G.6 Hence, we obtain a tree-decomposition of G of width
≤max{2, 3
2 bw(G)} −1.
□
In principle one can use the general algorithm from Theorem 5.4.10 to
compute approximate branch-decompositions of graphs. However, as for the
case of tree-width, better algorithms are known.
Theorem 5.4.14 (Bodlaender, Thilikos [7]) There is an algorithm that, given
a graph G and k ∈N, computes a branch-decomposition of G of width at
6 At least if G has no isolated vertices. If it does, add a bag for each isolated vertex.

Algorithmic meta-theorems
219
most k, if it exists, in time f (k) · |G|, for some computable function f : N
→N.
Clique- and Rank-Width
We now turn back to the original goal of giving a different characterisation of
clique-width of a graph in terms of its rank-width. Recall that the branch-width
of a graph is based on a decomposition of its edge set. For rank-width we
decompose its vertex set.
Let G be a graph. For U, W ⊆V (G) we deﬁne a |U| × |W|-matrix
MG(U, W) with entries mu,w for u ∈U and w ∈W, where
MG(U, W)
mu,w :=

1
if {u, w} ∈E(G)
0
otherwise.
Note that MG(V (G), V (G)) is the adjacency matrix of G. For all U, W ⊆V (G)
let rk

MG(U, W)

be its row rank when viewed as a matrix over GF(2). This rk

MG(U, W)

induces the following connectivity function rG : 2V (G) →N deﬁned as
rG(U) := rk

MG(U, V (G) \ U)

for U ⊆V (G). Obviously, rG is symmetric, as the row and column rank of the
matrix coincide. It is left as an exercise to show that it is also submodular.
Deﬁnition 5.4.15 A rank-decomposition
of a graph G is a branch-
decomposition of the pair (V (G), rG). The rank-width of G, in terms rw(G), is rank-width,
rw(G)
the minimal width of any of its rank-decompositions.
Example 5.4.16 Consider again the graph G from Example 5.3.2 depicted in
Figure 5.3. The following is a rank-decomposition of G of width 3.
•
b
a
d
c
•
•
•
•
•
9
10
5
6
1
3
7
8
11
4
2

220
Stephan Kreutzer
The relevant matrices determining the width of the decomposition are the
matrices Ma, . . . , Md at the nodes a, . . . , d.
Mc := MG

{5, 6, 9, 10}, {1, 2, 3, 4, 7, 8, 11}

=


1
0
0
0
0
0
0
0
0
1
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
1


Md := MG

{7, 8, 11}, {1, 2, 3, 4, 5, 6, 9, 10}

=


0 0 1 1 0 0 0 0
0 0 0 1 0 0 0 0
0 0 1 0 0 1 0 1


Ma := MG

{1, 3, 5, 6, 9, 10}, {2, 4, 7, 8, 11}

=


1
0
0
0
0
1
1
1
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1


Mb := MG

{2, 4, 7, 8, 11}, {1, 3, 5, 6, 9, 10}

=


1
1
0
0
0
0
0
1
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
1
0
1
0
1


Obviously, rk(Ma) = rk(Mb) = rk(Mc) = 3 and this is the maximal rank occur-
ring in the decomposition. Hence, the decomposition has width 3.
⊣
It is not too hard to see that the rank-width of a graph can be bounded in
terms of its branch-width and hence its tree-width. The following theorem due
to Oum gives an exact bound.
Theorem 5.4.17 (Oum [70]) rw(G) ≤max{1, bw(G)} for all graphs G.
It is easily seen that the rank of width a complete graph is 1 (all entries in
all matrices are 1). Hence, there can be an arbitrarily large difference between
the rank-width and the branch-width of a graph. On the other hand, Oum
[70] proved that if I(Kn) denotes the incidence graph of the n-clique Kn,
then for all n ≥3 with n = 0, 1 mod 3 we have rw(I(Kn)) = bw(I(Kn)) =
⌈2
3 · n⌉.
Another example of graphs of high tree- and high rank-width are n × n-
grids, whose rank-width has been shown by Jel´ınek [58] to be n.
An fpt-algorithm for computing rank-decompositions follows from
Theorem 5.4.10 but more efﬁcient algorithms are known.

Algorithmic meta-theorems
221
Theorem 5.4.18 (Hlineny, Oum [40]) Thereisanalgorithmthat, givenagraph
G and k ∈N, computes a rank-decomposition of G of width at most k, provided
rw(G) ≤k, in time f (k) · |G|3, for some computable function f : N →N.
Oum and Seymour [71] established the following connection between rank-
width and clique-width:
rw(G) ≤cw(G) ≤2rw(G)+1 −1.
In particular, a class of graphs has bounded clique-width if, and only if, it has
bounded rank-width (see [71]). Together with Theorem 5.4.18 this yields a
parameterized algorithm for computing approximate clique-decompositions of
graphs.
We have already seen that clique-width and tree-width and hence branch-
width of graphs can differ arbitrarily and this clearly extends to rank-width.
However, Oum [70] established the following relation between the branch-
width of a graph and the rank-width of the incidence graph.
bw(G) −1 ≤rw(I(G)) ≤bw(G)
5.4.3 Monadic Second-Order Logic and Bounded Clique-Width
In this section we aim at extending Courcelle’s and Seese’s theorems from
tree-width to clique-width. As in Section 5.3, we will do so by a reduction to
MSO model-checking and satisﬁability on trees. In particular, we show next
that for each k the class of graphs of clique-width k can be interpreted in the
class of coloured trees for a suitable set of colours depending on k. The idea is
simple: the class of graphs of clique-width k is the class of graphs generated
by k-expressions whose syntax trees will be the class of trees we are looking
for. Hence, let
k := {0, . . . , k −1, ⊕, edgei,j, renamei→j : 0 ≤i ̸= j < k}
be the symbols used in k-expressions and let Tk be the class of all k-labelled
directed trees. Obviously, not every k-labelled tree is the syntax tree of a
k-expression. However, every k-labelled directed tree such that the symbol ⊕
occurs precisely at the nodes with two successors, no node has more than two
successors and the leaves are precisely the nodes labelled by a symbol from
{0, . . . , k −1} are syntax trees of k-expressions. These conditions are easily
expressed by an MSO-sentence ϕvalid. Hence, for all T ∈Tk, T |= ϕvalid if,
and only if, T is the syntax tree of a k-expression. The formula ϕvalid is one
part of an interpretation 
k :=

ϕuniv, ϕvalid, ϕE(x, y)

from k-labelled trees
to graphs of clique-width at most k.

222
Stephan Kreutzer
The formula ϕuniv(x) deﬁning the universe of a graph generated by a k-
expression coded in a tree T is trivial: ϕuniv(x) just deﬁnes the set of leaves.
Finally, we have to deﬁne the formula ϕE(x, y) such that for all T ∈T
with T |= ϕvalid and all leaves u, v ∈V (T ) we have T |= ϕE(u, v) if, and only
if, there is an edge between u and v in the graph G generated by T . Note that
such an edge exists if, and only if, there is a common ancestor t of u and v in T
labelled by edgei−j, for some 0 ≤i ̸= j < k, so that at the node t, one of u, v
has colour i and the other the colour j. To check this, we only need to look at the
unique path from t to u (and v respectively) and keep track of how the colour of
u (resp. v) changes along this path. This can easily be formalised in MSO by a
formula ϕE(x, y) as required. Hence, the triple 
k := (ϕuniv(x), ϕvalid, ϕE(x, y))
is an interpretation from σk-structures to graphs, where σk := {E} ∪k is the
signature of k-labelled trees.
The interpretation is the key to tractability results for MSO model-checking
and satisﬁability. We consider model-checking ﬁrst and prove the following
extension of Courcelle’s theorem. It was ﬁrst proved by Courcelle in terms of
certain graph grammars (see [12, 14]) and then by Courcelle, Makowski and
Rotics for graph classes of bounded clique-width.
Theorem 5.4.19 (Courcelle, Makowski, Rotics [18]) Let C be a class of graphs
of bounded clique-width. Then the model-checking problem for MSO on C is
ﬁxed-parameter tractable.
Proof. Let ϕ ∈MSO be ﬁxed and let k be an upper bound for the clique-width of
the graphs in C. Given a graph G we ﬁrst compute a k-expression ϑ generating
G. This can be done in polynomial time (see Section 5.4.2). Let T be the
k-labelled syntax tree of ϑ. We can now test whether T |= 
k(ϕ).
□
We now consider the satisﬁability problem for monadic second-order logic.
Theorem 5.4.20 For every k, the MSO-theory of the class CWk of graphs of
clique-width at most k is decidable.
Proof. Let ϕ ∈MSO[{E}] be given. By the interpretation lemma, ϕ is valid in
CWk if, and only if, 
k(ϕ) ∈MSO[σk] is valid in the class {T ∈T : T |= ϕvalid}
if, and only if, 
k(ϕ) ∧ϕvalid is valid in the class of ﬁnite k-trees. The latter is
well known to be decidable [31, 85].
□
Seese conjectured a kind of converse to the theorem, the famous Seese
conjecture [81].

Algorithmic meta-theorems
223
Conjecture 5.4.21 (Seese’s conjecture) Every class C of structures with
decidable MSO1-theory has bounded clique-width.
This conjecture can be rephrased in terms of MSO-interpretations using the
following result due to Engelfriet and V. van Oostrom and also Courcelle and
Engelfriet.
Lemma 5.4.22 ([39, 16]) A class of graphs has bounded clique-width if, and
only if, it is interpretable in the class of coloured trees for some suitable set of
colours.
Note that these papers use so-called MSO-transductions instead of interpreta-
tions. An MSO-transduction is essentially the same as an interpretation except
that the formulas are allowed to have free second-order variables, the param-
eters. A graph is then interpretable in a tree if there is an interpretation of
the parameters by sets of tree-nodes satisfying the formulas in the MSO-
transduction. Hence, the parameters play exactly the same role as the colours of
the trees we use here. As the colours/parameters in our context are the symbols
of k-expressions, we prefer to have them as labels of the syntax trees rather
than as free variables in the interpretation.
Using the previous lemma we can rephrase Seese’s conjecture as follows:
Conjecture 5.4.23 (Seese’s conjecture) Every class C of structures with
decidable MSO1-theory is MSO-interpretable in the class of coloured trees
for some set of colours.
In [20], Courcelle and Oum prove the following weakening of the conjecture.
Let C2MSO be the extension of MSO by atoms Even(X), where X is a monadic
second-order variable, stating that the interpretation of X has even cardinality.
Hence, C2MSO extends MSO by counting modulo 2.
Theorem 5.4.24 (Courcelle, Oum [20]) Every class of graphs with a decidable
C2MSO theory has bounded clique-width, i.e. is interpretable in a class of
coloured trees.
Note that the theorem is weaker than Seese’s conjecture as there are less classes
of graphs whose C2MSO theory is decidable than there are classes of graphs
with a decidable MSO-theory.
5.4.4 MSO Model-Checking Beyond Tree- and Clique-Width
In the previous section we showed that the model-checking problem for
monadic second-order logic is ﬁxed-parameter tractable on classes of graphs

224
Stephan Kreutzer
with bounded tree- or clique-width. There is not much hope for extending
these results to other or larger classes of graphs such as planar graphs or
graphs of bounded degree. This follows immediately from the following the-
orem by Garey, Johnson and Stockmeyer and the fact that 3-colourability is
MSO-deﬁnable.
Theorem 5.4.25 (Garey, Johnson, Stockmeyer [49]) 3-colourability
is
NP-
complete on the class of planar graphs of degree at most 4.
We will see much stronger intractability results for MSO2 in Section 5.8
below. However, ﬁrst-order logic is tractable on many more classes of graphs.
For instance, Seese [82] showed that ﬁrst-order logic admits linear time model-
checking (for a ﬁxed formula) on any class of graphs of bounded degree. The
same complexity bound was later obtained by Frick and Grohe [47] for planar
graphs and classes of graphs of bounded local tree-width, a notion that properly
extends both planarity and bounded degree (see below).
The most general results in this respect are ﬁxed-parameter algorithms for
ﬁrst-order model-checking on H-minor free graphs and an extension thereof,
called locally excluded minors. These results make heavy use of concepts and
results developed by Robertson and Seymour in their celebrated proof of the
graph minor theorem. In the next section, we will therefore give a brief overview
of the relevant concepts of the graph minor theory used in the proofs. One such
theorem, the excluded grid theorem, will be used later to prove the converse
of Seese’s theorem mentioned above. This will be the topic of Section 5.6. We
return to ﬁrst-order model-checking in Section 5.7.
5.5 Graph Minors
In this section we present relevant terminology and results from graph minor
theory used later in the paper. Most of the results were developed in Robertson
and Seymour’s celebrated proof of the graph minor theorem (Theorem 5.5.2
below) presented in a series [76] of 23 papers, with additions and improvements
by other authors.
5.5.1 Minors and Minor Ideals
Let G be a graph and e := {v, w} ∈E(G) be an edge. The graph G/e obtained
G/e
from G by contracting the edge e is the graph obtained from G by removing e,
contraction
identifying its two endpoints, and possibly removing parallel edges. Formally,

Algorithmic meta-theorems
225
Figure 5.8 Contracting an edge
G/e is deﬁned by
V (G/e) := V (G) \ {v, w} ∪{xe},
where xe is a new vertex, and
E(G/e) :=

E(G) \

{u, u′} : {u, u′} ∩e ̸= ∅

∪

{u, xe} : u ∈V (G/e) and{u, v} ∈E(G) or {u, w} ∈E(G)

.
Figure 5.8 illustrates edge contraction.
A graph H is a minor of a graph G if H can be obtained from G by deleting minor
vertices and edges and contracting edges. We write H ≼G to denote that H is
isomorphic to a minor of G.
An alternative deﬁnition of minors is in terms of minor maps. A minor map
from H to G is a function µ that associates with every vertex v ∈V (H) a
connected subgraph µ(v) ⊆G and with every edge e ∈E(H) an edge µ(e) ∈
E(G) such that
r if u, v ∈V (H) and u ̸= v then µ(v) and µ(u) are vertex disjoint and
r if e := {u, v} ∈E(H) then µ(e) := {u′, v′} for some u′ ∈V (µ(u)) and v′ ∈
V (µ(v)).
The subgraph Gµ ⊆G with
V (Gµ) :=

 
V (µ(v)) : v ∈V (H)

and
E(Gµ) :=

 
E(µ(v)) : v ∈V (H)} ∪{µ(e) : e ∈E(H)

is called a model or image of H in G. In graph theory literature, the term model model, image
is commonly used. We prefer the name image here to avoid confusion with
logical models. Figure 5.9 illustrates an image of K5 in a graph G.
It is easily seen that we can always choose an image of H in G so that each
vertex is represented by a tree in G.

226
Stephan Kreutzer
Figure 5.9 Image of K5 in a graph G
Let G, H be graphs. G is a subdivision of H if H can be obtained from G
subdivision
by replacing some edges in G by paths which are pairwise internally vertex
disjoint, i.e. H can be constructed from G by repeatedly subdividing edges.
If a subgraph of G is isomorphic to a subdivision of H, then H is called a
topological minor of G. Now suppose H ≼G and H has maximal degree 3.
topological
minor Let µ be a minor map from H into G so that the image of all vertices of H
are trees in G. Then each of these trees has at most 3 leaves and hence at most
one vertex of degree more than two. It follows that every graph H of maximal
degree ≤3 that is a minor of G also is a topological minor of G.
Lemma 5.5.1 Let H, G be graphs. If (H) ≤3 and H ≼G, then H is a
topological minor of G.
If H ̸≼G, we say that H is a forbidden minor of G, or that G excludes
H. For any graph H let Excl(H) := {G : H ̸≼G} be the class of graphs not
Excl(H)
containing H as a minor. Analogously, if H is a set of graphs, then Excl(H) :=
Excl(H)  
Excl(H) : H ∈H} is the class of graphs not containing any member of H
as a minor.
A class C of graphs is a minor ideal if for all G ∈C and H ≼G also H ∈C.
minor ideal
It is proper if it is not the class of all graphs.
proper
minor ideal
A class C is characterised by a class F of graphs if C = Excl(F). Note
that any minor ideal C can be characterised by a class of excluded minors,
e.g. C = Excl(Graphs \ C). As the main result of their fundamental work on
graph minors, Robertson and Seymour proved that any minor ideal can in fact
be characterised by a ﬁnite set of forbidden minors.
Theorem 5.5.2 (Robertson, Seymour [80]) For every minor ideal C there is a
ﬁnite set F of graphs such that C = Excl(F).
There are many natural examples of minor ideals.

Algorithmic meta-theorems
227
r Every cycle can be contracted to a triangle. Hence, Excl(K3) is the class of
acyclic graphs.
r Kuratowski’s theorem [61] (or rather a variant established by Wagner [90])
implies that planar graphs are characterised by excluding K3,3 and K5.
r Series-parallel graphs and outerplanar graphs exclude K4. It can be shown
that Excl(K4) is the class of subgraphs of series-parallel graphs and the
class of outerplanar graphs is characterised by Excl(K4, K2,3). (See e.g. [30,
Exercises 7.32 and 4.20].)
r The class of graphs not having k vertex disjoint cycles, for any ﬁxed k ∈N.
For k ∈N let Tk be the graph consisting of k disjoint copies of a triangle.
Clearly, every graph containing k vertex disjoint cycles contains Tk as a
minor. Conversely, every graph containing Tk as a minor also contains k
vertex disjoint cycles. Hence the class Ck of graphs not having k disjoint
cycles is characterised by Tk.
It is easily seen that for each k ∈N the class Tk of graphs of tree-width at
most k and the class Bk of graphs of branch-width at most k are minor ideals
and so is the class of graphs of genus at most k. Finally, let us mention another
famous example of a minor ideal: the class of knotlessly embeddable graphs.
On the other hand, the class of graphs of clique-width at most k is not minor
closed and hence not a minor ideal. Also, the class of graphs of crossing number
k ≥1 is not minor closed.
Robertson and Seymour also proved that for any ﬁxed graph H, testing
if a graph G contains H as a minor can be done in cubic time (we will say
more about this later in this section). Hence, combining this minor test with
Theorem 5.5.2 implies that every minor-ideal can be decided in cubic time.
Corollary 5.5.3 Every minor ideal can be decided in cubic time.
The various concepts and results developed in the course of the proof of
Theorem 5.5.2 have sparked of a rich algorithmic theory of graphs based on
structural restrictions of instances. We have already hinted at the algorithmic
theory of graphs of bounded tree-width. However, the algorithmic applications
of the graph minor theory developed by Robertson and Seymour extend far
beyond tree-like graphs. In the following two sections we present some of the
results and methods with implications for algorithms and model-checking on
graphs.
However, the following can only give a glimpse into the deep results under-
lying the proof of the graph minor theorem – we will not even be able to state
the relevant results in full detail let alone attempt to prove them. While we are
trying to give an intuitive account of the results and proof methods, we will

228
Stephan Kreutzer
necessarily have to be brief and the presentation may not always reﬂect the
actual proofs.
5.5.2 Disjoint Paths and the Trinity Lemma
Let us try to prove Theorem 5.5.2. Clearly, the statement of the theorem is
equivalent to the statement that in every inﬁnite class of ﬁnite graphs one graph
is a minor of another. Let C := {H, G1, G2, . . . } be an inﬁnite class of ﬁnite
graphs. If H is a minor of some Gi, then the claim is trivially satisﬁed by H.
Hence, the only interesting case is when no Gi ∈C contains H as a minor. For
this reason, much of the theory developed by Robertson and Seymour deals
with graphs not containing another ﬁxed graph H as a minor. We refer to such
graphs as H-minor free. Clearly, if G is H-minor free, then G also excludes a
H-minor free
clique Kk as a minor, for instance taking k := |V (H)|. Let us ﬁx k for the rest
of the section.
The key to studying the structure of Kk-minor free graphs is the following
theorem, proved by Robertson and Seymour in [74]. Recall from Section 5.2
that Gk×k denotes the k × k-grid.
Theorem 5.5.4 (Excluded Grid Theorem [74]) There is a computable func-
tion f : N →N such that every graph of tree-width at least f (k) contains Gk×k
as a minor.
We refer to [30] for a proof of this theorem. As every planar graph is a minor
of a suitably large grid, the theorem implies – is equivalent, in fact – to the
following statement.
Corollary 5.5.5 For all H, the class Excl(H) of H-minor free graphs has
bounded tree-width if, and only if, H is planar.
The function f in the original proof of Theorem 5.5.4 was huge. In [73],
Robertson, Seymour and Thomas signiﬁcantly improved the bounds on f to
202k5. However, no matching lower bounds have been established and it is
conjectured that the actual bound may be as small as polynomial in k. For
planar graphs G a much better bound can be obtained.
Theorem 5.5.6 (Robertson, Seymour, Thomas [73]) Every planar graph with
no k × k-grid minor has tree-width ≤6k −5.
For branch-width a slightly tighter bound has been established: every planar
graph of branch-width at least 4k −3 contains a k × k-grid minor (see [73]).
Whereas it is still open whether optimal tree-decompositions of planar graphs
can be computed in polynomial time, in [84] Seymour and Thomas proved

Algorithmic meta-theorems
229
Figure 5.10 Elementary walls of height 1–4
that optimal branch-decompositions of planar graphs can be computed in time
O(n4). This has later been improved to O(n3) by Gu and Tamaki [54]. It should
be noted that these algorithms do not contain any large hidden constants and
perform reasonably well in practise. Optimal branch-decompositions of planar
graphs with up to 50.000 edges have been computed by actual implementations
of the algorithms (see e.g. [5]).
To give an application of the grid-theorem on planar graphs, we note that it
implies an 2O(
√
k) · nc algorithm, for some c ∈N, for deciding whether a planar
graph has a path of length k. For this, use an O(n3) algorithm for testing whether
a given planar graph G has branch-width at most 4
√
k −3. If so, then one can
compute a suitable branch-decomposition and use dynamic programming to
decide whether a path of length k exists. Otherwise, the planar grid theorem
tells us that the graph contains a
√
k ×
√
k grid as a minor and hence a path
of length at least k following the grid structure. A similar algorithmic idea has
found numerous applications, for instance on H-minor free graphs, in the form
of bidimensionality theory. See e.g. [25, 32, 27, 33, 24, 26, 28] and references
therein.
For the rest of this section we will work with a somewhat simpler structure
than grids, called walls.
wall
An elementary wall is a graph as displayed in Figure 5.10. A wall of height
h is a subdivision of an elementary wall of height h. See Figure 5.11 for a
wall of height 4. The induced cycles of a wall, i.e. the cycles of length 6 in an
elementary wall or their subdivisions in general walls, are called the bricks of brick
the wall. We assign coordinates (i, j) = (row, col) to the bricks of a wall. The
brick in the lower left corner is assigned (1, 1), its neighbour to the right (1, 2),
the brick just above it (2, 1) and so on. The central brick of H is the brick with central brick

230
Stephan Kreutzer
Figure 5.11 A wall of height 4
coordinates (⌈h/2⌉, ⌈h/2⌉). A central vertex of a wall is a vertex contained in
central
vertex the central brick but not in its neighbours to the left or right.
The outermost (non-induced) cycle of a wall W is called its perimeter.
perimeter
Clearly, every large grid contains a large wall as a subgraph and conversely
every large wall contains a large grid as a minor. The main advantage of working
with walls rather than grids is that if G contains an elementary wall as a minor
then, by Lemma 5.5.1, it contains a wall of the same height as a subgraph.
Let us come back to the analysis of the structure of graphs. Let t be a bound
on the tree-width we want to consider. If G has tree-width at most t, then it is
sufﬁciently tree-like and its structure is well understood. So suppose G has large
tree-width. By the Excluded Grid Theorem 5.5.4, we know that G contains a
large wall W as a subgraph. We can use W as a drawing board on which we
draw the rest of the graph G. Clearly, as G is not required to be planar, this
“drawing” will not necessarily be plane, i.e. edges may cross. In particular,
edges or paths may span over different bricks of the wall. This is called a
“crossing”. More formally, a crossing consists of two pairwise vertex-disjoint
paths with endpoints v1, v3 and v2, v4 such that v1, v2, v3, v4 occur clockwise
in this order on some cycle of the grid. Figure 5.12 illustrates the concept of
crossings.
Crossings are important for our purpose. For, if G contains many crossings
which, in addition, are sufﬁciently far apart from each other on the wall used to
draw G, then we can use the crossings to ﬁnd a large clique minor of the graph.
To see this, take a large clique and draw it “ﬂat” on the wall W. Necessarily
(unless your clique has less than ﬁve vertices) some of the edges in the clique
will cross each other. However, if the wall W is large enough and there are
sufﬁciently many crossings far apart from each other, then we can replace the
edges of the clique by disjoint paths in G so that edges that cross are replaced

Algorithmic meta-theorems
231
Figure 5.12 Crossings in a graph
Figure 5.13 A K5-minor in a wall with one crossing
by disjoint paths that cross each other using a “crossing” in the drawing of G.
The following Figure 5.13 illustrates this with K5 and one crossing. The grey
areas are (essentially) the parts that are being contracted for each vertex in the
clique.
Hence, if W is large enough and there are many crossings pairwise far apart
in W, then G contains a large clique minor. So, how does a graph G drawn on
a large wall look like if it does not contain a large clique minor?
As explained before, all but a small number of crossings must be grouped
together in a bounded number of small parts of the wall. These regions with
many crossings are called vortices. Further, there can be some vertices which vortex
are very well connected to the rest of the graph, i.e. a set X of vertices that have
edges to arbitrary vertices in the graph, where edges can be replaced by paths
of arbitrary length. The vertices in X are called apices (see Figure 5.14).
apex

232
Stephan Kreutzer
Figure 5.14 Vortices and apices in a graph drawn on a wall
However, any such well-connected vertex in X can be used as a crossing
and hence, if G excludes Kk, there are either at most |X| <
k
2

such elements,
or their connections to the wall are concentrated on a small part of the wall W
(and hence they are part of the vortices) so that the crossings cannot be used to
route the edges of a Kk-minor. In this case, we will ﬁnd a subwall of W which
is still “large” and is connected only to a subset of X of size <
k
2

. Hence, we
can continue the discussion with the subwall W ′ where we do not have vortices
and only a bounded number of apices.
Besides the apices, there can be other parts of the graph with direct connec-
tions to the interior of the wall,7 which do not induce any further crossings.
We call these extensions. Essentially, an extension is a subgraph D of G that
is connected to the wall only within a brick and only with at most 3 vertices.
This is important as with three vertices the extensions cannot induce further
crossings in the wall.
Furthermore, we can assume that the tree-width of any such extension is
bounded, as otherwise we could forget about the rest of the graph and do the
same analysis within the extension, either producing a large clique minor or a
large wall with vortices, apices and extensions. Note, though, that the apices
may have connections to the extensions. See Figure 5.15 for an illustration.
7 There may also be parts of the graph connected to the wall only through its perimeter. These
parts are not relevant here but we come back to this in the next section.

Algorithmic meta-theorems
233
Figure 5.15 Apices, extensions and connections within the subwall W ′
The discussion so far presents the main ideas in the proof of the next lemma,
one of the important results in the Graph Minor Series. To state it precisely, we
need some further notation.
For a subgraph D of a graph G, we let ∂GD be the set of all vertices of D
that are incident with an edge in E(G) \ E(D). In the following, let W be a
wall of height at least 2 in a graph G and let P be the perimeter of W, i.e. the
boundary cycle of W. Let K′ be the unique connected component of G \ P
that contains W \ P. The graph K = K′ ∪P is called the compass of W in G.
A layout of K (with respect to the wall W in G) is a family (C, D1, . . . , Dm)
of connected subgraphs of K such that:
1. K = C ∪D1 ∪. . . ∪Dm,
2. W ⊆C and there is no separation (X, Y) of C of order ≤3 with V (W) ⊆X
and Y \ X ̸= ∅,
3. ∂GDi ⊆V (C) for all i ∈{1, . . . , m},
4. |∂GDi| ≤3 for all i ∈{1, . . . , m},
5. ∂GDi ̸= ∂GDj for all i ̸= j ∈{1, . . . , m}.
We let C be the graph obtained from C by adding new vertices d1, . . . , dm
and, for 1 ≤i ≤m, edges between di to the vertices in ∂GDi and edges between
all vertices in ∂GDi. Hence, for each i ∈{1, . . . , m}, the vertex di together with

234
Stephan Kreutzer
the (at most 3) vertices in ∂GDi form a clique. We call C the core of the layout
and D1, . . . , Dm its extensions. The layout (C, D1, . . . , Dm) is ﬂat if its core
C is planar. Note that this implies that the core has an embedding in the plane
that extends the “standard planar embedding” of the wall W (as shown in
Figure 5.10), because the wall W has a unique embedding into the sphere. We
call the wall W ﬂat (in G) if the compass of W has a ﬂat layout.
The following lemma, which we refer to as the trinity lemma, is (essentially)
Lemma 9.8 of [78]. Concerning the uniformity, see the remarks at the end of
[78] (on page 109).
Lemma 5.5.7 (Trinity Lemma [78]) There are computable functions f, g :
N2 →N and an algorithm A that, given a graph G and non-negative integers
k, h, computes either
1. a tree-decomposition of G of width f (k, h),
2. a Kk-minor of G, or
3. a subset X ⊆V (G) with |X| <
k
2

, a wall W of height h in G \ X, and a
ﬂat layout (C, D1, . . . , Dm) of the compass of W in G \ X such that the
tree-width of each of the extensions D1, . . . , Dm is at most f (k, h).
Furthermore, the running time of the algorithm is bounded by g(k, h) · |V (G)|2.
Using the trinity lemma, we can now sketch the proof of the following
theorem due to Robertson and Seymour [78].
Theorem 5.5.8 (Robertson, Seymour [78]) The following problem is ﬁxed-pa-
rameter tractable with a cubic fpt algorithm.
p-Disjoint-Paths
Input:
Graph G, s1, . . . , sk, t1, . . . , tk ∈V (G).
Parameter:
k.
Problem:
Are there k vertex disjoint paths connecting si
and ti, 1 ≤i ≤k?
The idea of the algorithm is as follows. Apply the trinity lemma on G for
suitable values of k and h. If G has tree-width ≤f (k, h), then the disjoint paths
problem can be solved by standard techniques using dynamic programming (or
by formalising the problem in MSO and using Courcelle’s theorem). Otherwise,
if G contains a large clique minor (say at least K3k), then we can do the
following. To simplify the presentation, let us assume that G actually contains
the 3k-clique as a subgraph. If there are 2k vertex disjoint paths connecting
{s1, . . . , sk, t1, . . . , tk} to the clique, then these paths together with the edges
of the clique yield the k vertex-disjoint paths connecting si, ti as desired.

Algorithmic meta-theorems
235
Otherwise, by Menger’s theorem, there is a separator X ⊆V (G) of size at
most 2k separating the clique and (part of) the {si, ti : 1 ≤i ≤k}. But now,
the problem can be reduced to a constant number of disjoint paths problems
on smaller subgraphs, trying to connect si, ti with all possible combinations of
elements in the separator.
If G does not contain the clique as a subgraph but as a minor, then the
argument becomes considerably more complicated, but can still be done.
Hence, the case where G contains a large enough clique minor can be solved
efﬁciently.
Finally, consider the third case of the trinity lemma, where G contains a large
wall W and we are given a ﬂat layout of W, its extensions and the apices. This
is the tricky bit. However, one can show that if W is large enough, then it must
contain a subwall W ′, which is still large, does not contain any of the si’s or
ti’s and is “homogeneous” with respect to the apices. Informally, homogeneous
means that every type of a small part of the wall with respect to the apices
is realised sufﬁciently often all over the subwall W ′. In [78], Robertson and
Seymour show how such a homogeneous subwall can be constructed efﬁciently.
To simplify the presentation, assume that W ′ has actually no direct connection
to the apices (other than those using vertices of W \ W ′). Now suppose there
are k vertex-disjoint paths connecting si and ti, 1 ≤i ≤k. Some of these paths
may use parts of W ′. As none of the endpoints si, ti is in W ′, the paths merely
cross W ′, although they may do so in a rather irregular and complicated way.
However, it can be shown that if W ′ is homogeneous and large enough, then
any such set of paths can be rerouted so as to avoid a central vertex v of the
wall (recall from above that the central vertices are those in the middle of the
wall). This implies, that k vertex-disjoint paths connecting si, ti exist in G if,
and only if, such paths exist in G −v. Hence, we can remove the central vertex
v and start the whole procedure again on the smaller graph.
It seems intuitively obvious that on a very large wall, everything that can
be routed through the wall can be routed without using the central vertex. A
formal proof of this is extremely complicated and uses a major part of the deep
structure theory developed in the graph minor series.
As mentioned above, the solution to the disjoint paths problem was given by
Robertson and Seymour in [78]. In fact, they solve the following more general
problem. A rooted graph (G, v1, . . . , vk) is a graph G together with vertices
vi ∈V (G). A rooted graph (H, t1, . . . , tk) is a minor of (G, v1, . . . , vk), if there
is a minor map µ from H to G such that vi ∈µ(ti) for all 1 ≤i ≤k.
Theorem 5.5.9 (Robertson, Seymour [78]) The following problem is ﬁxed-pa-
rameter tractable with a cubic fpt algorithm.

236
Stephan Kreutzer
p-Rooted-Minor
Input:
Rooted graphs (G, v1, . . . , vk), (H, t1, . . . , tk).
Parameter:
k.
Problem:
Is (H, t1, . . . , tk) a minor of (G, v1, . . . , vk)?
Clearly, this implies Theorem 5.5.8 and also Corollary 5.5.3. This is a
truly remarkable consequence of the proof of the graph minor theorem. Note,
however, that the statement is purely existential. For every minor ideal there is
a ﬁnite set of excluded minors and for each member H of the set we can decide
in cubic time, whether a graph G contains H as a minor. The theory does not
yield an algorithm to compute a set of excluded minors and hence it only states
the existence of a polynomial time membership test but not an actual algorithm.
We come back to this in Section 5.5.4 where we consider ways in which to
overcome this non-constructive element in the theory.
5.5.3 The Structure of H-Minor Free Graphs
The proof of the graph minor theorem relies on a structure theory for graphs
G excluding a ﬁxed graph H as a minor. We have already seen some of the
results developed in the proof. In this section we focus on describing the
structure of graphs in terms of simple building blocks into which they can be
decomposed.
The key to the decomposition theorem we are going to describe is once again
the grid theorem, or in this case the trinity lemma as described in the previous
section. Clearly, as G excludes a ﬁxed graph H as a minor, it is obvious that,
if we choose the values for k and h correctly, of the three cases of the trinity
lemma, the second is impossible: if G excludes H it cannot contain a large
clique minor. Further, if G has small tree-width, then it can be decomposed
into subgraphs of constant size. Hence, we primarily have to deal with the third
case, where G has large tree-width but does not contain a large clique minor.
Recall our exploration of the trinity lemma in the previous section. Let us
assume that G is highly connected. If not, we ﬁrst decompose it into parts that
are highly connected. We will come back to this later.
As G has high tree-width it must contain a large wall as a subdivision. This
wall may contain “crossings”, in particular there may be a bounded number
of apices and vortices. As explained before, apart from the vortices and the
apices, the rest of the graph, the extensions, must ﬁt nicely into the planar
structure of the wall, i.e. they ﬁt into the individual bricks. So far, however, we
only have discussed the interior of the wall. There may be more to the graph,

Algorithmic meta-theorems
237
which is connected to the wall only through the perimeter. These connections
cannot be too wild, though, as otherwise we would again ﬁnd a large clique
minor.
We can now subdivide the exterior cycle of the wall into a bounded number
of regions and glue some of them together. In this way we obtain a graph that
can be embedded into a surface of bounded genus: any such surface can be
obtained from a convex polygon in the plane by gluing some edges together.
Hence, after removing a bounded number of apices and vortices we obtain a
graph that can be embedded into a surface of bounded genus. We say that G has
almost bounded genus. Recall that we assumed that G is highly connected. If it
is not, then we can decompose it into pieces with this property. This realisation
is the main structural theorem in Robertson and Seymour’s proof of the graph
minor theorem: if C is a class of graphs excluding a ﬁxed minor H, then
every graph G ∈C can be decomposed into graphs that have almost bounded
genus.
We still have to make precise what we mean by “decomposing a graph”.
Intuitively, we recursively ﬁnd a small separator in the graph and split the graph
along the separator until the remaining graph is highly connected, and hence no
such separators can be found. However, by doing so some information is lost.
Let G be a graph and X be a small separator. We want to decompose the graph
into subgraphs each containing X and a component of G −X. Clearly, in a
graph obtained from X and a component C of G \ X, we lose the connections
between elements of X through the other components of G \ X. In particular,
elements of X which are far apart in X ∪C can be close together in other
components and hence in G. This loss of information in the decomposition
process needs to be avoided. A rather drastic approach, which we take here, is
to add all possible edges between elements of the separator X, i.e. to turn X
into a clique.
Let T := (T, (Bt)t∈V (T )) be a tree-decomposition of a graph G and let t ∈
V (T ) be a node with neighbours t1, . . . , tk. The torso [Bt] of the bag Bt is torso, [Bt]
deﬁned as G[Bt] ∪k
i=1 K

Bti

, where K

Bti

is the complete graph on the
vertex set Bti. The tree-decomposition T of G is over a class C of graphs if the tree-
decompo-
sition over C
torsi of all bags in T belong to C.
Example 5.5.10 Figure 5.5.10 shows a tree-decomposition of a graph over
the class of triangles. Part b) shows the tree-decomposition and Part c) the
corresponding torsi.
A graph G is called decomposable over a class C if it has a tree-
decomposition over C. For every class C we denote the class of graphs

238
Stephan Kreutzer
4
1
6
3
2
5
1
3
2
4
1
3
1
3
5
4
6
3
1
3
2
4
1
3
1
3
5
4
6
3
a) Graph G
b) Tree-Decom. of G
c) Torsi of the bags
Figure 5.16 Tree-Decomposition over the class of triangles
decomposable over C by D(C). It is not hard to see that if C is minor closed
D(C)
then so is D(C).
Example 5.5.11 Let Ck+1 be the class of graphs of order at most k + 1 and let
Tk be the class of graphs of tree-width at most k. Then Tk = D(Ck+1).
⊣
Robertson and Seymour’s structure theorem for classes of graphs excluding
a minor can now be reformulated as follows.
Theorem 5.5.12 (Robertson, Seymour [79]) For every minor ideal D there is
a class C of graphs of almost bounded genus such that D ⊆D(C).
We will not make the notion of “almost bounded genus” precise here and
instead refer to [79] or to [30, Chapter 12] which contains a more elaborate
introduction to the theory. For the applications we have in mind, we do not have
to work with almost bounded genus graphs, vortices and apices directly but
can use a simpler version of the structure theorem. This relies on the following
lemma, proved by Grohe in [52].
The local tree-width is the function ltw : Graphs × N →N deﬁned as
local
tree-width
ltw(G, r) := max

tw

G

Nr(v)

: v ∈V (G)

,
where Nr(v) is the r neighbourhood of v, i.e. the set of vertices of distance
at most r from v. That is, the local tree-width of a graph assigns to every
radius r ∈N the maximal tree-width of an r-neighbourhood in the graph G.
See Section 5.7.3 for more on local tree-width.

Algorithmic meta-theorems
239
Lemma 5.5.13 (Grohe [52]) Let S be a surface. Then the class of all minors
of graphs almost embeddable into S has linear local tree-width.
For all λ, µ ≥1 deﬁne
L(λ) := {G : ltw(H, r) ≤λ · r for all H ≼G}
and
L(λ, µ) := {G : there is X ⊆V (G), |X| ≤µ s.th. G \ X ∈L(λ)}.
Then, the previous lemma implies the following simpler structure theorem that
will be used in later sections.
Theorem 5.5.14 For every minor ideal D there exist λ, µ ≥1 such that D ⊆
D(L(λ, µ)).
Furthermore, Grohe proves the existence of an algorithm for computing the
decompositions over L(λ, µ), based on the following lemma.
Lemma 5.5.15 (Grohe [52]) Let C be a minor closed class of graphs. Then
there is a polynomial-time algorithm that, given a graph G, either computes a
tree-decomposition of G over C or rejects G, if no such decomposition exists.
Taking C to be L(λ, µ), the lemma implies the existence of an algorithm for
computing tree-decompositions over L(λ, µ). However, the algorithm outlined
in [52] uses non-constructive elements of the graph minor theory and hence,
while proving the existence of an algorithm, does not actually state one.
In [29], Demaine, Hajiaghayi and Kawarabayashi proved that the decompo-
sitions as guaranteed by Theorem 5.5.12 can be computed in polynomial time
for every ﬁxed class of graphs excluding at least one minor H.
Theorem 5.5.16 (Demaine, Hajiaghayi, Kawarabayashi [29]) For every ﬁxed
H, there is a polynomial-time algorithm for computing the decompositions of
H-minor free graphs as stated in Theorem 5.5.12.
From this, for each ﬁxed H, a polynomial time algorithm which computes
a tree-decomposition of an H-minor free graph G over L(λ, µ), for suitable
values of λ, µ, can easily be derived.
One may wonder why we only considered classes L(λ) of linear local tree-
width instead of classes of graphs where the local tree-width is bounded by
a polynomial p(r) or even worse. In [24], Demaine and Hajiaghayi showed
that minor closed classes of bounded local tree-width always have linear local
tree-width. Hence, there is no need to consider non-linear local tree-width here,
as all classes L(λ) are minor-closed.

240
Stephan Kreutzer
5.5.4 Computing Excluded Minor Characterisations
Recall from Section 5.5.1 that every minor ideal can be characterised by a ﬁnite
set of excluded minors (Theorem 5.5.2) and that for each ﬁxed H it is decidable
in cubic time whether a graph G contains H as a minor (Theorem 5.5.9). As
a consequence we obtain Corollary 5.5.3 stating that every minor ideal can
be decided in cubic time. Note that the result contains a non-constructive
element as it does not give a way to compute the excluded minors for a minor
ideal. For instance, while we know that the class of knotlessly embeddable
graphs can be decided in cubic time, no algorithm for doing so is actually
known.
This naturally raises the question whether this non-constructive element can
be removed from the proof, i.e. whether characterisations of minor ideals in
terms of their excluded minors can be computed. Clearly, to state this precisely,
we have to specify how we want to represent a minor ideal as an input to an
algorithms and also what exactly we want to understand by a characterisation
of a minor ideal in terms of excluded minors.
Let C be a minor ideal. A graph H is an obstruction for C if H is an
obstruction
excluded minor of C but for all H ′ ≼H with H ′ ̸= H we have H ′ ∈C. Hence,
obstructions are minimal excluded minors. We denote the set of obstruc-
tions of C by O(C). It is easily seen that for all minor ideals C, O(C) is
O(C)
unique up to isomorphism and it is ﬁnite by the Graph Minor Theorem. We
will therefore take O(C) as the characterisation of minor ideals we want to
compute.
This leaves us with the question how to specify a minor ideal as an input
for algorithms. A natural choice is to provide a Turing-machine deciding the
ideal and use this as input. However, Fellows and Langston [44] observed that
there is no algorithm which, given a Turing-machine deciding a minor ideal C,
computes the set O(C). Later, Courcelle, Fellows and Langston [15] showed
that there is no algorithm which, given an MSO-sentence deﬁning a minor ideal
C, computes O(C).
On the other hand, it is known that obstructions can be computed for a
number of natural minor ideals. For instance, for all k ≥1 the obstructions
can be computed for the class Tk of all graphs of tree-width ≤k (see [62]),
for the class Bk of all graphs of branch-width ≤k (see [50]) and for the class
Gk of graphs of genus ≤k (this follows from [83] or a combination of [87]
and [43]).
Fellows and Langston were the ﬁrst to study algorithmic issues related to
the graph minor theorem and ways to overcome its non-constructiveness. In
[43], they propose a general method for computing obstruction sets based

Algorithmic meta-theorems
241
on a generalisation of the Myhill-Nerode theorem of formal language theory
to “graph languages”. Adler, Courcelle, Grohe and Kreutzer8 present a similar
method for computing obstruction sets based on deﬁnability in monadic second-
order logic (see [1]). We will give a brief presentation of this method and
illustrate it by an example. For all minor ideals C and D, their union C ∪D
is minor closed and hence a minor ideal. We will show below that the set of
obstructions for C ∪D can be computed from O(C) and O(D).9 The proof of
this result also contains a nice application of the Trinity Lemma 5.5.7.
We ﬁrst establish some lemmas which are all easily proved using well-
known results from automata theory and the connection between monadic
second-order logic on trees and tree-automata (see e.g. [86, 10]).
Lemma 5.5.17 There is an algorithm which, given a formulaϕ ∈MSOdeﬁning
a minor ideal C, computes a formula ψ ∈MSO deﬁning O(C).
Proof. A graph H is an obstruction for C if H ̸∈C but H −v ∈C, H −e ∈C
and H/e ∈C for all v ∈V (H) and e ∈E(H). Given the formula ϕ deﬁning C,
this can be easily be formalised in MSO.
□
The next lemma is based on a pumping lemma for tree-automata (see [10]).
Lemma 5.5.18 There is an algorithm which, given a formula ϕ ∈MSO so that
the class Mod(ϕ) := {H : H |= ϕ} is ﬁnite (up to isomorphism) and a k ∈N
such that tw(H) ≤k for all H ∈Mod(ϕ), computes Mod(ϕ).
Proof (sketch). Suppose ϕ has only ﬁnitely many models each of tree-
width ≤k. As we are given k explicitly, we can use the interpretation deﬁned
in Section 5.3.3 to encode the models of ϕ as coloured trees over a suitable
alphabet and reduce the problem of computing the models of ϕ to the problem
of computing the corresponding tree-encodings. An upper bound for the size
of these models can then be derived from a version of the pumping lemma of
formal language theory for classes of trees deﬁnable by tree-automata. From
this bound on the size, the actual models of ϕ can easily be computed.
□
The previous lemmas together with the Graph Minor Theorem immediatly
imply the following corollary which is the basis of the method for computing
obstruction sets proposed in [1].
8 The proof presented here follows a suggestion by Bruno Courcelle simplifying the original
proof of the result in [1].
9 Note that the analogous problem for C ∩D is trivial.

242
Stephan Kreutzer
Corollary 5.5.19 There is an algorithm which, given a formula ϕ ∈MSO deﬁn-
ing a minor ideal C and a k ∈N such that tw(H) ≤k for all H ∈O(C),
computes the set O(C).
As an application of the result we show that the obstructions for the union
C ∪D of minor ideals C, D can be computed from the sets O(C) and O(D). For
this, we have to show that C ∪D is MSO-deﬁnable and to establish an upper
bound on the tree-width of its obstructions.
It is easily seen that for any ﬁxed graph H there is an MSO-formula ϕH
which is true in a graph G if, and only if, H ≼G. This follows immediately
from the deﬁnition of minors in terms of minor maps and images as presented
in Section 5.5.1. To deﬁne C ∪D in MSO note that G ∈C ∪D if, and only if,
G either excludes a minor from O(C) or a minor from O(D). As we have seen,
this is MSO-deﬁnable and a corresponding formula can easily be computed. It
remains to establish a bound on the tree-width of the obstructions.
Lemma 5.5.20 Let C and D be minor ideals and let U := C ∪D. There is an
algorithm which, given O(C) and O(D) as input, computes a number k ∈N
such that tw(H) ≤k for all H ∈O(U).
Proof (sketch). Suppose G ∈O(U). Hence, G ̸∈U but G −v ∈U for all
v ∈V (G). It follows that there are H ∈O(C) and I ∈O(D) such that H ≼G
and I ≼G. Let k := max{|H|, |I|} + 1 and choose h “large enough”, where
the meaning of large enough will become clear later.
By the Trinity Lemma 5.5.7, either a) tw(G) ≤f (k, h) for some com-
putable function f , or b) Kk ≼G or c) there is a subset X ⊆V (G) with
|X| <
k
2

, a wall W of height h in G \ X, and a ﬂat layout of the compass of W
in G \ X.
Suppose c) applies. It follows from a result by Robertson and Seymour in
[78] that if h is chosen large enough then there is a vertex v in the wall W (the
middle vertex) such that G −v still contains H and I as minors, contradicting
the minimality of the obstruction G. Hence, case c) is impossible. The idea to
choose the middle vertex is same as in the proof of Theorem 5.5.8 described in
Section 5.5.2.
For b), if G contains a Kk minor then there is a strict subgraph G′ ⊊G
containing a Kk−1 minor. Hence, by the choice of k, G′ contains H and I
as minors, contradicting the minimality of G. Thus, case b) is impossible as
well.
Finally, in a) the tree width of G is bounded by a computable function in h
and k and we have found a uniform upper bound for the tree-width of G which
concludes the proof.
□

Algorithmic meta-theorems
243
Corollary 5.5.21 ([1]) For all minor ideals C, D the set O(C ∪D) is com-
putable from the sets O(C) and O(D).
Using a similar approach it was shown in [1] that obstructions can be
computed for other natural minor ideals. In particular, if C is a minor ideal
whose obstructions are known, then the obstructions can be computed for the
class Capex of apex graphs over C, deﬁned as
Capex := {G : there is v ∈V (G) such that G −v ∈C}.
However, there remain interesting open problems.
Open Problem 5.5.22 1. Is there an algorithm which, given λ ≥0, computes
the obstructions O(L(λ))? See Section 5.5.3 for a deﬁnition of L(λ) and
L(λ, µ). Note that, by using the computability of O(Capex) from O(C), the
set O(L(λ, µ)) can be computed from O(L(λ)), for all µ ≥0.
2. If C is a minor ideal whose obstructions are given, can we compute the
obstructions of the class D(C) of graphs tree-decomposable over C?
A solution for both open problems would be particularly interesting as every
minor ideal is a subclass of a class D(L(λ, µ)) for some λ, µ ≥0.
5.6 Monadic Second-Order Logic Revisited
Recall from Section 5.3.5 that for each k, the MSO2-theory of the class Tk of
graphs of tree-width at most k is decidable. The aim of this section is to prove
a kind of converse, also due to Seese.
Theorem 5.6.1 (Seese [81]) If C is a class of graphs with decidable MSO2-
theory, then C has bounded tree-width.
The proof of the theorem crucially relies on the excluded grid theorem
(Theorem 5.5.4) and the fact that the MSO-theory of grids is undecidable. The
latter can easily be established using tiling systems or by a direct encoding of
the run of Turing-machines using MSO-formulas (see e.g. [8]).
Suppose C has a decidable MSO2-theory but unbounded tree-width. Then,
by the excluded grid theorem, for all n ≥1, there is a graph Gn ∈C containing
Gn×n as a minor. The key to the theorem is to show that grid minors can be
deﬁned in MSO2. Hence, the (undecidable) MSO-theory of grids can be reduced
to the MSO-theory of C contradicting the assumption that the latter is decidable.

244
Stephan Kreutzer
We start by showing how walls can be formalised in MSO2. The exten-
sion to grids follows easily. Let G be a graph and consider an MSO2-formula
formalising the following.
1. There are two sets H and V of edges, each of which induces a set of pairwise
vertex disjoint paths (which we will think of as horizontal and vertical paths
in a wall).
2. For all P ∈H and Q ∈V, P ∩Q is a subpath of both, P and Q. Further,
V (P ∩Q) ∩V (H) = ∅for all H ∈(V ∪H) \ {P, Q}.
3. There is a path L ∈V such that the intersection of L with each Q ∈H
contains an endpoint of Q (L is the left-most vertical path in the wall).
Once we have L, we can give the horizontal paths P ∈H a direction,
where we say that p ∈V (P) is to the left of p′ ∈V (P), if the subpath of P
containing p′ and a vertex in L also contains p.
4. There is a path T ∈H such that the intersection of T with each P ∈V
contains an endpoint of P (T is the top-most horizontal path in the wall).
As with horizontal paths, we can now use T to give the vertical paths P ∈V
a direction and say that p ∈V (P) is above p′ ∈V (P).
5. For each path P ∈V except L there is a path P ′ ∈V (the path immediately to
the left of P) such that for all Q ∈H: if p ∈V (P ∩Q) and p′ ∈V (P ′ ∩Q)
are vertices in the intersection of Q and P, P ′, then p′ is to the left of p in
Q and there is no S ∈H such that any s ∈V (S ∩Q) lies in the subpath of
Q between p and p′.
6. The analogue condition for horizontal paths.
Clearly, the various conditions are MSO2-deﬁnable. Now, if V and H satisfy
the conditions above, then they generate a wall in G and conversely, the disjoint
horizontal and vertical paths in a wall satisfy the conditions. Finally, it is easily
seen that the class of grids can be deﬁned in the class of walls and hence grid
minors are MSO2-deﬁnable in graphs.
Note that here we crucially use the fact the we are working with MSO2-
formulas and hence can quantify over the edge sets of disjoint paths. In MSO1
we could only try to quantify over the vertex set of disjoint paths. However,
if there are sufﬁciently many edges between these vertices, there is no way
we can give the paths an orientation, e.g. deﬁne paths being to the left of
others. And clearly, we cannot expect clique-minors to be deﬁnable in MSO1
as, by Theorem 5.4.20, the MSO1-theory of graph classes of bounded clique-
width is decidable and hence there are classes with decidable MSO1-theory but
unbounded tree-width.

Algorithmic meta-theorems
245
5.7 First-Order Model-Checking
In Section 5.3.4 and 5.4.3 we showed that the model-checking problem for
variants of monadic second-order logic is solvable in linear time for any ﬁxed
formula on classes of graphs of bounded tree- or clique-width. As we have
argued in Section 5.4.4 and will explore further in Section 5.8 below, there is
not much hope for extending these results to other or larger classes of graphs.
However, ﬁrst-order logic is tractable on much larger classes of graphs and in
this section we will present tractability results for ﬁrst-order logic on several
special classes of graphs. The important property of ﬁrst-order logic that makes
these results possible is locality.
The section is structured as follows. In Section 5.7.1 we introduce the
concept of locality and present Gaifman’s theorem. In Section 5.7.2 we apply
locality to obtain ﬁxed-parameter algorithms for ﬁrst-order model-checking on
graph classes of bounded degree. The algorithms developed in this section can
be applied in a much more general context using the concept of localisation of
graph invariants. This will be formally deﬁned in Section 5.7.3. In Section 5.7.4
we present ﬁxed-parameter algorithms for ﬁrst-order model-checking on H-
minor free graphs.
5.7.1 Locality of First-Order Logic
Let G be a graph. Recall that the distance dG(u, v) between two vertices
u, v ∈V (G) is the length of the shortest path from u to v or ∞if there is no such
path. Further, for every v ∈V (G) and r ∈N we deﬁne the r-neighbourhood
of v in G as the set
NG
r (v) := {w ∈V (G) : dG(v, w) ≤r}
of vertices of distance at most r from v. For a set W ⊆V (G) we set NG
r (W) :=

v∈W NG
r (v). We omit the index ·G whenever G is clear from the context.
If σ is a signature and A is a σ-structure, we deﬁne the distance dA(a, b)
and the r-neighbourhood N A
r (a) in terms of the Gaifman-graph G(A) of
A,10 i.e. NA
r (a) is the set of elements of distance at most r from a in the
Gaifman-graph.
It is easily seen that for any ﬁxed r ∈N “distance at most r” is ﬁrst-order
deﬁnable, that is, for every r ∈N there is a formula dist≤r(x, y) such that for
10 See Section 5.2 for a deﬁnition of Gaifman-graphs.

246
Stephan Kreutzer
all structures A and all u, v ∈V (A)
A |= dist≤r(u, v)
iff
dA(u, v) ≤r.
Similarly, there are formulas dist>r(x, y) and dist<r(x, y) deﬁning distance >
r and < r respectively. To improve readability we will write dist(x, y) ≤r
instead of dist≤r(x, y) and likewise for the other formulas.
A ﬁrst-order formula ϕ(x) is r-local if for every structure A and all a ∈V (A)
A |= ϕ(a)
iff
A

NA
r (a)

|= ϕ,
where A

NA
r (a)

denotes the substructure of A induced by NA
r (a). Hence,
truth of an r-local formula at an element a in a structure only depends on its
r-neighbourhood. A formula ϕ(x) is local if it is r-local for some r ∈N.
A basic local sentence is a ﬁrst-order sentence of the form
∃x1 . . . ∃xk


1≤i<j≤k
dist(xi, xj) > 2r ∧
k
i=1
ϑ(xi)

where ϑ(x) is local. In 1981, Gaifman showed that every ﬁrst-order sentence
is equivalent to a Boolean combination of basic local sentences.
Theorem 5.7.1 (Gaifman [48]) Every ﬁrst-order sentence is equivalent to a
Boolean combination of basic local sentences. Furthermore, there is an algo-
rithm that, given a ﬁrst-order formula as input, computes an equivalent Boolean
combination of basic local sentences.
A ﬁrst-order formula is in Gaifman Normal Form (GNF), if it is a Boolean
combination of basic local sentences. Gaifman’s original proof is by an explicit
translation of ﬁrst-order formulas into formulas in GNF. A proof sketch along
this lines can also be found in the survey paper [53]. A different, model-
theoretical proof can be found in [37, Section 2.5].
The translation of formulas into Gaifman normal form is effective. How-
ever, it has recently been shown [23] that this translation may involve a non-
elementary blow-up in the size of the sentence.
Theorem 5.7.2 (Dawar, Grohe, Kreutzer, Schweikardt [23]) Let σ := {E} be
the signature of graphs. For every h ≥1 there is an FO[σ]-sentence ϕh of
size O(h4) such that every FO[σ]-sentence in Gaifman normal form that is
equivalent to ϕh on the class of ﬁnite trees has size at least tower(h), where
tower(h) denotes a tower of 2s of height h.
From a practical point of view, this renders algorithms using Gaifman’s
theorem useless, no matter what their theoretical complexity might be.

Algorithmic meta-theorems
247
Example 5.7.3 Recall that a dominating set X in a graph G is a set X ⊆V (G)
such that for all v ∈V (G), v ∈X or there is a u ∈X and {u, v} ∈E(G). For
k ∈N, the formula
ϕk := ∃x1 . . . ∃xk∀y
 
1≤i≤k

xi = y ∨Eyxi

is true in a graph G if, and only if, G has a dominating set of size at most k.
To convert this into an equivalent sentence in Gaifman normal form, we
ﬁrst observe that no connected graph of diameter at least 3k + 1 can have a
dominating set of size at most k. Here, the diameter of a graph is the maximum
of the distance between any two vertices.
Hence, on connected graphs, the formula ϕk above is equivalent to the
conjunction of the basic local sentence
ψ := ¬∃x1∃x2dist(x1, x2) > 3k + 1,
saying that the diameter of G is greater than 3k + 1, and the basic local
sentence ∃xχ(x), where χ(x) is the 3k + 1-local formula
∃y1 ∈N3k+1(x) . . . ∃yk ∈N3k+1(x)∀z ∈N3k+1(x)

1≤i≤k

yi = z ∨Ezyi

.
Note that this formula correctly deﬁnes the existence of a dominating set of
size k only in connected graphs, as in graphs with more than one component
there may exist a dominating set of size k even though there are vertices x1, x2
of distance greater than 3k + 1. Adapting the formula to this case requires a
little more effort.
⊣
5.7.2 First-Order Logic on Graphs of Bounded Degree
As a ﬁrst application of the use of Gaifman’s locality theorem for algorithmic
meta theorems we consider graph classes of bounded degree.
Deﬁnition 5.7.4 A class C of graphs has bounded degree if there is a d ∈N
such that (G) ≤d for all G ∈C.
In 1996, Seese [82] showed that model-checking for a ﬁxed ﬁrst-order
sentence can be done in linear time on graph classes of bounded degree.
Theorem 5.7.5 (Seese [82]) For any class C of graphs of bounded degree and
any ﬁxed ﬁrst-order sentence it can be decided in linear time whether G |= ϕ
for a graph G ∈C. In other words, ﬁrst-order model-checking on C is ﬁxed-
parameter tractable by a linear fpt algorithm.

248
Stephan Kreutzer
Figure 5.17 Algorithm to ﬁnd k vertices of pairwise distance > 2r
Proof. The proof method we use here is essentially the method used by Frick
and Grohe to show a similar result for planar graphs.
Let ϕ and G ∈C be given. We ﬁrst convert ϕ into Gaifman normal form,
i.e. into a Boolean combination of basic local sentences. As Boolean combina-
tions are easy to deal with, we only need to consider basic local sentences of
the form
ψ := ∃x1 . . . ∃xk


1≤i<j≤k
dist(xi, xj) > 2r ∧
k
i=1
ϑ(xi)

where ϑ(x) is r-local for some r ∈N.
To check whether ψ is true in G we proceed in two steps. First, we test for
all v ∈V (G) if G

NG
r (v)

|= ϑ. As G has degree bounded by some constant
d, the size of NG
r (v) is constant and hence this can be decided in constant time.
Colour all vertices v red for which G

NG
r (v)

|= ϑ and let Q be the set of red
vertices. Now, G |= ψ if Q contains k vertices of pairwise distance > 2r.
In the second step we search for k such vertices. For this, we use the greedy
algorithm shown in Figure 5.17. The algorithm proceeds as follows. In lines
2–6 of the algorithm, we try to choose k red vertices of pairwise distance > 2r
greedily. If we succeed, i.e. if the set L contains k elements, then we are done
and accept G. Otherwise, we know that L contains fewer than k vertices which
are all red and of pairwise distance > 2r and also that any other red vertex is
within distance ≤2r of an element of L (otherwise we could add the vertex
to L). Hence, all red vertices of G are contained in the 2r-neighbourhood
N := N2r[L] of L. Again, N is of constant size and hence we can check in

Algorithmic meta-theorems
249
constant time whether N contains k red vertices of pairwise distance > 2r. This
is done in line 12 by testing whether the graph induced by the neighbourhood
satisﬁes the ﬁrst-order formula stating that there are k distinct red vertices of
pairwise distance > 2r.
□
The previous theorem gives a simple example how locality can be used to
obtain efﬁcient model-checking algorithms for ﬁrst-order logic. As it turns out,
a similar scheme can be employed in many cases.
Theorem 5.7.6 Let C be a class of graphs such that the following problem is
ﬁxed-parameter tractable:
Input:
ϕ ∈FO, graph G ∈C, v1, . . . , vk ∈V (G) and r ∈N.
Parameter:
r + k + |ϕ|.
Problem:
Decide G

N G
r (v1, . . . , vk)

|= ϕ.
Then model-checking for ﬁrst-order logic is ﬁxed-parameter tractable on C.
Proof. We proceed as in the proof of Theorem 5.7.5. By Gaifman’s theorem,
we may assume that ϕ is a basic local sentence
∃x1 . . . ∃xk
 
i̸=j
dist(xi, xj) > 2r ∧

i
ϑ(xi)

,
where ϑ(x) is an r-local formula for some r ∈N.
In the ﬁrst step, we compute the set Q of vertices v ∈V (G) such that
G

Nr(v)

|= ϑ(v). By assumption, for each v ∈V (G) this can be done in time
f (r + 1 + |ϑ|) · |G|O(1), for some computable function f : N →N, and hence
the total running time is f (r + 1 + |ϑ|) · |G|O(1).
In the second step we aim to ﬁnd k vertices in Q whose distance is
pairwise > 2r. Using the algorithm of Figure 5.17 this can be done in time
f (2r · k + O(k)) · |G|O(1). Hence, the total running time is f (2r · k + O(k)) ·
|G|O(1).
□
While this theorem may appear somewhat artiﬁcial, we will see a number
of interesting applications of it by considering localisations of graph invariants
such as tree-width or rank-width.
5.7.3 Localisation of Graph Invariants
Let Graph denote the class of all ﬁnite graphs.

250
Stephan Kreutzer
Deﬁnition 5.7.7 A graph invariant is a function f : Graph →N. For every
graph invariant f we deﬁne its localisation locf : Graph × N →N as
locf (G, r)
locf (G, r) := max

f

G

Nr(v)

: v ∈V (G)

.
A class C of graphs has bounded local f , if there is a computable11 function
h : N →N such that locf (G, r) ≤h(r) for all G ∈C and r ∈N.
That is, to compute locf (G, r) we compute the r-neighbourhoods N :=
Nr(v) of all vertices v ∈V (G) and for each such N the value f (N). locf (G, r)
is then the maximum of these values. In particular, if the problem: given G and
k, where k is the parameter, to decide whether f (G) ≤k is ﬁxed-parameter
tractable, then so is the problem: given G, r, k, where r + k is the parameter,
to decide if locf (G, r) ≤k.
Example 5.7.8 Of particular interest is the localisation of tree-width, called
local tree-width (see also the discussion at the end of Section 5.5.3). There
are a number of interesting examples for graph classes with bounded local
tree-width.
1. Every graph class of bounded tree-width also has bounded local tree-width
(bounded by a constant).
2. The class of planar graphs has bounded local tree-width. More precisely,
Robertson and Seymour [77] showed that every planar graph of radius r
has tree-width ≤3r + 1.
3. Any class of graphs of bounded degree. This is easily seen as the r-neigh-
bourhoods of graphs of degree at most d contain < dr+1 vertices.
⊣
Similar to local tree-width we can deﬁne local rank-width or clique-width,
where we take f : Graph →N to be the function assigning to each graph its
rank- or clique-width.
Another interesting example is the localisation of the following graph invari-
ant. Let mec : Graph →N (minimal excluded clique) be the function assigning
mec(G)
to each graph G the minimal order of a clique that is not a minor of G, i.e.
mec(G) := min{k : Kk ̸≼G}.
Graph classes with locally bounded mec are called graph classes with locally
excluded minors and have been studied by Dawar, Grohe and Kreutzer in [21].
Clearly, every graph class C with an excluded minor H also locally excludes
11 As we are asking for h to be computable, we should call this effectively bounded local f . But
this would make the notation even more clumsy and we therefore refrain from mentioning
effectiveness in the sequel.

Algorithmic meta-theorems
251
H, i.e. has bounded local mec. The converse fails, though, as is witnessed by
the following class of graphs. For k ∈N let Sk be the graph obtained from Kk
by replacing all edges by internally vertex disjoint paths of length k. Now take
C := {Sk : k ∈N}. Obviously, the minor closure of C is the class of all graphs,
i.e. C does not exclude a minor. However, it locally excludes minors, as every
k-neighbourhood of graphs G ∈C excludes Kk. Hence, f : Graph × N →N
deﬁned as f (G, r) := r dominates the local mec of C.
Note, that C has bounded local tree-width and hence also provides an exam-
ple separating proper minor ideals and graph classes of bounded local tree-
width. It is easily seen that every class of graphs of bounded local tree-width
also locally excludes minors. The converse fails again, as not even every minor
ideal has bounded local tree-width. This is witnessed by the class of apex graphs
deﬁned as
Capex := {G : there is v ∈V (G) such that G −v is planar}.
In particular, this class contains all grids with one additional vertex adjacent
to every vertex in the grid. Hence, Capex has unbounded local tree-width but
clearly excludes K6.
Lemma 5.7.9 The concept of locally excluded minors strictly generalises both
excluded minors and bounded local tree-width. That is, every class of graphs
that excludes a minor or has bounded local tree-width, also locally excludes
minors. The converse fails in both cases.
The aim of this section is to prove the following theorem.
Theorem 5.7.10 Let f be a graph invariant such that the following is ﬁxed-
parameter tractable.
MC(FO, f )
Input:
Graph G and ϕ ∈FO.
Parameter:
f (G) + |ϕ|.
Problem:
Decide whether G |= ϕ.
Then for every class C of locally bounded f , the problem MC(FO, C) is ﬁxed-
parameter tractable.
Proof. Let g : N →N be a bound for locf (G, ·) for all G ∈C. We ﬁrst suppose
that f is induced subgraph monotone, i.e. f (H) ≤f (G) for all H, G such
that H is an induced subgraph of G, and further has the property that if
G1, G2 are vertex disjoint graphs, then f (G1 ∪G2) ≤max{f (Gi) : i = 1, 2}.

252
Stephan Kreutzer
Note that graph invariants such as tree-width, branch-width, clique-width and
rank-width all have these properties.
Then the result follows from Theorem 5.7.6 as follows. Given ϕ ∈FO, G ∈
C, v1, . . . , vk ∈V (G) and r ∈N, we ﬁrst compute H := G

NG
r (v1, . . . , vk)

in polynomial time. Clearly, every component of H has radius at most k · r
and hence f (H) ≤locf (G, k · r) ≤g(k · r). The assumptions of this lemma
then imply that the assumptions of Theorem 5.7.6 are satisﬁed and thus we can
decide H |= ϕ by fpt-algorithms.
If f does not have the properties above, we can no longer apply
Theorem 5.7.6 directly. Instead, we have to repeat its proof. We leave the
details to the reader.
□
Corollary 5.7.11 First-order model-checking is ﬁxed-parameter tractable on
graph classes of
r bounded local tree-width
r bounded local rank- or clique-width.
In the next section we will show that ﬁrst-order model-checking is ﬁxed-
parameter tractable on graph classes excluding at least one minor. We will later
consider localisation in this context and show an analogous result for graph
classes locally excluding a minor.
5.7.4 First-Order Logic on H-Minor Free Graphs
The aim of this section is to show that ﬁrst-order model-checking is ﬁxed-
parameter tractable on every class C of graphs excluding at least one minor
H. If we take |ϕ| as the parameter, this was ﬁrst shown by Flum and Grohe
[45] in 2001. That is, for every ﬁxed H, the problem is tractable under the
parametrization |ϕ|. However, the exponential of the polynomials occurring in
the running time analysis can depend on H. As it turns out, this parametrization
is not strong enough to apply our method of localisation to the problem. In
[21], therefore, Dawar, Grohe and Kreutzer consider the problem under the
parametrization |ϕ| + |H| and show ﬁxed-parameter tractability for this case.
Let us ﬁrst consider the case where H is ﬁxed and |ϕ| is the parameter.
In the light of the previous sections, the proof of the theorem seems rather
straightforward: given G ∈C, Theorem 5.5.14 tells us that there are λ, µ ≥1
such that G has a tree-decomposition over L(λ, µ), i.e. a tree-decomposition
such that the torsi of its bags have bounded local tree-width after removal of a
few elements, and Theorem 5.5.16 tells us how to compute the decomposition
in polynomial time. Furthermore, we already know how to deal with graphs in

Algorithmic meta-theorems
253
L(λ) of bounded local tree-width and extending this to graphs in L(λ, µ) poses
no real problem. And indeed, this is the general idea to show that FO model-
checking is FPT on H-minor free graphs, although formally implementing
the idea requires some care and additional lemmas. To make this precise it is
convenient to introduce further notation.
A graph G is the clique sum of graphs G1 and G2, denoted G = G1 ⊕G2, clique sum, ⊕
if G1 ∩G2 is a complete graph and G is obtained from G1 ∪G2 by possibly
deleting some edges from E(G1 ∩G2). Formally, V (G) = V (G1) ∪V (G2),
G1 ∩G2 is a clique and there is a (possibly empty) set X ⊆E(G1 ∩G2) such
that E(G) = E(G1 ∪G2) −X. We write G = G1 ⊕v G2 to indicate that G is ⊕v
the clique-sum of G1 and G2 and that V (G1 ∩G2) = v.
Recall that a tree-decomposition of a graph G is over a class C of graphs
if the torsi [Bt] of all its bags belong to C, where the torso of a bag Bt is
obtained from G[Bt] by turning the intersections of Bt with neighbouring bags
Bs into cliques. Hence, the graph G is obtained as the clique-sum of its bags,
an observation that we will use in the following proofs.
We begin by proving an extension of Courcelle’s theorem, this time not by
a reduction to trees but by computing MSO-types directly. Recall the deﬁnition
of MSO and FO q-types and the Feferman-Vaught theorem from Section 5.2.3.
Lemma 5.7.12 Let tpq be one of tpFO
q
and tpMSO
q
. The following problem is
ﬁxed-parameter tractable: given
r a labelled graph G of tree-width ≤k,
r tuples vi ∈V (G)ri, 0 ≤i ≤m for some m, such that G

vi

is a clique, and
r q-types 1, . . . , m,
compute tpq(G, v0) for all graphs G′ = G ⊕v1 H1 ⊕v2 · · · ⊕vm Hm such that
tpq(Hi, vi) = i. The parameter is q + k.
Proof. Given G, we ﬁrst compute an ordered tree-decomposition (T , (bt)t∈V (T ))
of G of width at most k (see Deﬁnition 5.3.25). Note that, as the vi induce cliques
in G, for each i there is at least one ti such that vi ⊆bti. Hence, we can assume
that for each 0 ≤i ≤m there is a leaf t ∈V (T ) such that vi = bt and that no
other leaf contains a vertex from any of the vi for 1 ≤i ≤m.
For each t ∈V (T ), let Tt be the subtree of T rooted at t and let Bt be
the set Bt := 
s∈V (Tt) bs. Beginning from the leaves we inductively compute
tpq(G

Bt

, btv0) for each node t ∈V (T ). Here, the notation tpq(G

Bt

, btv0)
indicates that in G

Bt

we compute the type of bt and all vertices of v0 contained
in Bt. For leaves t with bt = vi, for some 1 ≤i ≤m, we can infer the type
tpq(G

bt

, btv0) from i. For other leaves we can compute their types directly,

254
Stephan Kreutzer
as they only contain at most k + 1 elements. For inner nodes t with children
t1, t2 we apply Lemma 5.2.3.
□
As the previous lemma applies to MSO-types, Courcelle’s theorem is clearly
a special case of it. Hence, the proof here provides an alternative way of
establishing Courcelle’s theorem. While the two approaches may seem to be
somewhat different, the underlying principle is the same. Recall that in our
original proof of Courcelle’s theorem, we encoded graphs G of tree-width ≤k
in labelled trees T and then rewrote the formula ϕ on G to a new formula ϕ′
on T such that G |= ϕ if, and only, if T |= ϕ′. On the tree-encoding, we then
applied results from automata theory which establish that MSO model-checking
is ﬁxed-parameter tractable on trees. More speciﬁcally, the MSO-formula ϕ′ is
translated into an automaton Aϕ which accepts T if, and only if, T |= ϕ′.
Although it is not usually proved this way, essentially the automaton has a state
for each possible q-type and its transition relation combines types similar to
what is done in Lemma 5.2.3.
But back to ﬁrst-order model-checking on graph classes excluding a minor.
Essentially the previous lemma allows us to deal with tree-decompositions over
graphs of bounded tree-width, which clearly is not enough for our purposes.
Lemma 5.7.13 Let tpq denote tpFO
q
. The following problem is ﬁxed-parameter
tractable for all λ, µ: given
r a labelled graph G ∈L(λ, µ),
r tuples vi ∈V (G)ri, 0 ≤i ≤m for some m, such that G

vi

is a clique, and
r q-types 1, . . . , m,
compute tpq(G, v0) for all graphs G′ = G ⊕v1 H1 ⊕v2 · · · ⊕vm Hm such that
tpq(Hi, vi) = i. The parameter is q.
Proof. The proof is by induction on µ. For µ = 0, we adapt the proof of
Theorem 5.7.6 using Lemma 5.7.12 locally. Now let µ > 0 and let G ∈L(λ, µ),
vi, i be an instance of the problem. By deﬁnition, G contains a vertex v ∈
V (G) such that G \ v ∈L(λ, µ −1). Note that for all λ′, µ′, L(λ′, µ′) is a
minor ideal and hence has a cubic time membership test by Corollary 5.5.3.
Thus, in time O(|G|4) we can ﬁnd such a vertex v. Let G2 be the coloured
graph obtained from G by introducing a new colour C by which we label
all neighbours of v and then eliminating v from G. By construction, G2 ∈
L(λ, µ −1). Furthermore, it is an easy exercise to translate ﬁrst-order formulas
ϕ over G to formulas ϕ′ over G2 such that G |= ϕ if, and only if, G2 |= ϕ′.
Hence, the q-type of G′ = G ⊕v1 H1 ⊕v2 · · · ⊕vm Hm can be recovered from

Algorithmic meta-theorems
255
the q-type of G′
2 = G2 ⊕v1 H1 ⊕v2 · · · ⊕vm Hm, and the latter is computable
by the induction hypothesis.
□
The previous two lemmas are the main ingredients for the proof of the
following theorem.
Theorem 5.7.14 (Flum, Grohe [45]) Let C be a class of graphs excluding at
least one minor. Then the following problem is ﬁxed-parameter tractable.
MC(FO, C)
Input:
G ∈C, ϕ ∈FO.
Parameter:
|ϕ|.
Problem:
Decide G |= ϕ.
Proof. Let G and ϕ be given and let q be the quantiﬁer-rank of ϕ. Using The-
orem 5.5.16, we ﬁrst compute a tree-decomposition (T, γ ) of G over L(λ, µ),
for some λ, µ. We view T as a directed tree with root r.
For each t ∈V (T ), t ̸= r, with parent s ∈V (T ), let vt := Bt ∩Bs. Recall
that in the torsi of Bt and Bs, vt induces a clique. For the root r we deﬁne vr as
the empty tuple. Furthermore, for each t ∈V (T ) let Tt be the subtree of T rooted
at t and let Bt := 
s∈V (Tt) Bs. Finally, for t ∈V (T ) let Gt := G

Bt

∪K[vt].
Note that for all t ∈V (T ), vt ≤k, where k := λ + µ, as vt induces a clique in
the torso [Bt] of Bt. As [Bt] ∈L(λ, µ) and graphs in L(λ, µ) cannot contain
a clique of order > λ + µ we obtain |vt| ≤k. Hence, as λ, µ only depend on
the excluded minor of C and therefore are ﬁxed, we obtain a ﬁxed upper bound
for the size of vt, t ∈V (T ).
To decide G |= ϕ, we aim at computing the type tpq(G, vr). We can then
simply check whether ϕ ∈tpq(G, vr). Towards this aim, starting at the leaves
and proceeding bottom-up, we apply Lemma 5.7.13 at each node to compute
the type tpq(Gt, vt).
□
The previous theorem shows that for every ﬁxed graph H, ﬁrst-order model-
checking is ﬁxed-parameter tractable, with parameter |ϕ|, on every class of
graphs excluding H. However, the algorithm as described above is not ﬁxed-
parameter tractable in the parameter |H| + |ϕ| as we use a non-constructive
approach in Lemma 5.7.13 and also the algorithm described in [29] seems to
use the minor H in an inappropriate way for parameterized complexity.
We therefore turn to a different parametrization of the problem, where we
take the parameter to be |ϕ| + |H|. This problem was studied by Dawar, Grohe
and Kreutzer in [21]. The approach taken there is similar to the method outlined
above. However, instead of using tree-decompositions over L(λ, µ), [21] uses
a slightly weaker form of decompositions, called weak decompositions over

256
Stephan Kreutzer
L(λ, µ). The main result in [21] is that for every H, every graph excluding H has
a weak decomposition over some L(λ, µ) (which is relatively straightforward to
show) and that these decompositions can be computed by an fpt-algorithm with
parameter H (which requires considerably more work). Once this is shown, the
proof method outlined above can be adapted to weak decompositions yielding
the following result.
Theorem 5.7.15 (Dawar, Grohe, Kreutzer [21]) The
following
problem
is
ﬁxed-parameter tractable.
p-MC(FO)
Input:
G, H such that H ̸≼G, ϕ ∈FO.
Parameter:
|ϕ| + |H|.
Problem:
Decide G |= ϕ.
An immediate consequence of the theorem is the following. Recall from
Section 5.7.3 the deﬁnition of the minimum excluded clique number mec(G) of
a graph G and of locally excluded minors. For any function f : N →N let Cf
be the class of graphs G such that mec(G) ≤f (|G|).
Corollary 5.7.16 There is an unbounded function f : N →N such that
MC(FO, Cf ) is ﬁxed-parameter tractable.
Another consequence of the theorem is that it allows us to apply the frame-
work of localisation as developed in Section 5.7.3 to obtain the following
result.
Corollary 5.7.17 Let C be a class of graphs locally excluding a minor. Then
the problem
MC(FO, C)
Input:
G ∈C, ϕ ∈FO.
Parameter:
|ϕ|.
Problem:
Decide G |= ϕ.
is ﬁxed-parameter tractable.
The previous result has a number of algorithmic applications.
Corollary 5.7.18 1. The following problem is ﬁxed-parameter tractable.

Algorithmic meta-theorems
257
p-Dominating Set
Input:
Given graphs G, H such that H ̸≼G and k ∈N.
Parameter:
k + |H|.
Problem:
Decide whether G contains a dominating set of
size ≤k.
Analogous results hold for all other ﬁrst-order deﬁnable parameterized
problems, such as Independent Set and Clique and also for problems
such as deciding for a ﬁxed graph G′ whether G′ has a homomorphism into
G, or G′ is an (induced) subgraph of G, where here the parameter can be
taken to be |H| + |G′|.
2. Let C be a class of graphs locally excluding a minor. Then problem such
as Dominating Set, Independent Set etc. are ﬁxed-parameter tractable
on C. Furthermore, the problem, given graphs H and G such that G ∈C,
to decide whether H is homomorphic to G or H is an (induced) subgraph
of G can be decided by fpt algorithms with parameter |H|.
5.8 Characterising Logical Complexity
under Structural Restrictions
The results presented in the previous sections have focussed primarily on meth-
ods to establish tractability results of logics on special classes of structures.
The aim was to exhibit more and more general classes of structures on which
ﬁrst-order or monadic second-order model-checking becomes tractable. As we
have seen in Section 5.2.4, ﬁrst-order model checking is not ﬁxed-parameter
tractable in general (unless FPT = AW[∗]) and hence somewhere there must
be a tractability border for the model-checking problem of these logics. Pre-
vious research has mostly approached this border from below by establishing
tractability results. Quite as important is to establish intractability results, i.e.
to approach this tractability border from above. This has so far been studied
much less in the literature and the aim of this section is to survey some of the
results that have been obtained in this direction.
5.8.1 Classifying Logical Tractability with Respect to
Structural Restrictions
In the previous sections we have seen various examples for classes of graphs or
structures on which model-checking for ﬁrst- or monadic second-order logic

258
Stephan Kreutzer
becomes tractable. The picture described there (and illustrated in Figure 5.18
below) is as yet far from being complete and in particular it is not known
whether any of the tractability results are actually strict. Surprisingly, not even
for Courcelle’s celebrated theorem it is known whether it can be extended to
classes of unbounded tree width.
We therefore propose a research program which aims at providing a reﬁned
analysis of the complexity of logical formula evaluation with respect to speciﬁc
classes of structures. More precisely, for the most commonly used logics we
aim at identifying a property that precisely captures tractability of the logic in
the sense that the logic is tractable on a class of structures if, and only if, the
class has this particular property.
Such a classiﬁcation would give completely new insights into the complexity
of the logics and would provide researchers designing new query or speciﬁca-
tion languages based on these logics with valuable information for designing
languages tailored towards their speciﬁc application areas.
It may not always be possible to ﬁnd such a property that excactly charac-
terises tractability of a logic within all classes of structures and possibly we will
need to further restrict the admissible classes of structures, such as to classes
closed under substructures. For instance, for ﬁrst-order logic we conjecture that
model-checking of FO on a class of structures closed under substructures is
tractable if, and only if, the class is nowhere dense (see below).
There are two different, and somewhat complementary aspects to the results
we envisage. The ﬁrst aspect are tractability results as we have presented them
in the previous sections. The other aspect are intractability results where we
show that evaluation of formulas is hard whenever a class of structures does
not have a particular property. In this context, this aspect has virtually not
been studied in the literature before. We will present some recent and new
intractability results in the following subsections.
5.8.2 Limits to Monadic Second-Order Model-Checking
Recall Courcelle’s theorem (see Theorem 5.3.29 and Corollary 5.3.31) which
states that MSO2-model checking is ﬁxed-parameter tractable on every class
of structures of bounded tree-width. We will see in this section that in this
generality, Courcelle’s theorem can not be extended much beyond bounded
tree-width.
The following result by Garey, Johnson and Stockmeyer and the fact that
3-colourability is MSO-deﬁnable immediately imply that MSO-model checking
is not ﬁxed-parameter tractable on the class of planar graphs.

Algorithmic meta-theorems
259
Theorem 5.8.1 (Garey, Johnson, Stockmeyer [49]) 3-colourability is NP-com-
plete on the class of planar graphs of degree at most 4.
However, the class of planar graphs is a very speciﬁc class and this result
does not rule out that Courcelle’s theorem could possibly be extended to classes
of unbounded but slowly growing tree-width. To show intractability results for
MSO2-model checking on classes of graphs of unbounded tree-width we ﬁrst
need to classify the degree of “unboundedness”.
Deﬁnition 5.8.2 Let f : N →N be a non-decreasing function. A class C of
graphs has f -bounded tree width if tw(G) ≤f (|G|) for all G ∈C.
Hence, Courcelle’s theorem applies to f -bounded classes of graphs for
constant functions f . We will particularly be interested in classes of graphs
whose tree width grows logarithmically in the size of the graphs and aim at
proving that if the tree width C is not bounded logarithmically then MSO2 model-
checking is not tractable on C. A ﬁrst step towards this direction appeared in
[59, 60] where such a result was proved for classes of coloured graphs which
we deﬁne next.
Let  := {B1, . . . , Bk, C1, . . . , Cl} be a set of colours, where the Bi are
colours of edges and the Ci are colours of vertices. A -coloured graph, or
simply -graph, is an undirected graph G where edges may be coloured by
B1, . . . , Bk and vertices may be coloured by C1, . . . , Ck. We do not require
any additional conditions such as edges having endpoints coloured in different
ways, i.e. we do not require the colouring to be proper in the graph theoretical
sense. To obtain logical structures, we let σ := {E, B1, . . . , Bk, C1, . . . , Cl}
be the signature containing binary relations E, B1, . . . , Bk for edges and their
colours and unary relations C1, . . . , Cl for vertex colours.
Deﬁnition 5.8.3 A class C of -graphs is said to be closed under -colourings
if whenever G ∈C and G′ is obtained from G by recolouring, i.e. the underlying
un-colored graphs are isomorphic, then G′ ∈C.
A class C of σ-structures is closed under colourings if there is a class
C′ of (uncoloured) graphs such that C is the class of all σ-structures whose
Gaifman-graphs are in C′.
We aim at showing that if C is a class of graphs closed under colourings
whose tree width is not bounded by a log-function then MSO2-model checking
is ﬁxed-parameter intractable on C. The proof of this result relies on a reduction
from an NP-complete problem to MC(MSO2, C) and for this to work it is not
enough for the tree-width of C not to be bounded by a log-function f : N →N,

260
Stephan Kreutzer
we must also be able to compute witnesses for this large tree-width efﬁciently.
This leads to the following deﬁnition of effectively unbounded tree-width.
Deﬁnition 5.8.4 The tree-width of a class C of graphs is effectively unbounded
by a function f : N →N if there is a polynomial p(x) such that for all n
1. there is a graph G ∈C of tree-width between n and p(n) whose tree-width
is not bounded by f (|G|) and
2. given n, Gn can be constructed in time 2nε, for some ε < 1.
The tree-width of C is effectively unbounded poly-logarithmically if it is effec-
tively unbounded by logc n, for all c.
We will particularly be interested in classes effectively unbounded by a
function f (n) := logc n for some small constant c. For such a function the
second condition just says that we can compute witnesses for the high tree-
width of C in time polynomial in their size, which is what we need for the
reduction of an NP-complete problem to work. The ﬁrst condition says that
there are enough witnesses for the large tree-width of C so that there are actually
enough graphs to reduce the problem to. The following result was proved in
[60] (see also [59]).
Theorem 5.8.5 Let  be a non-empty set of colours including at least one
edge and two vertex colours. Let C be any class of 
-coloured graphs closed
under colourings.
1. If the tree-width of C is effectively unbounded poly-logarithmically then
MC(MSO, C) is not in XP, and hence in particular not ﬁxed-parameter
tractable, unless all problems in NP (in fact, all problems in the polynomial-
time hierarchy) can be solved in sub-exponential time.
2. If the tree-width of C is effectively unbounded by log48 n then MC(MSO, C)
is not in XP unless Sat can be solved in sub-exponential time.
The theorem together with Courcelle’s theorem has the following corollary,
as in the classes Cf colours can easily be replaced by suitable gadgets. Note,
however, that the corollary also has a much simpler direct proof.
Corollary 5.8.6 For any non-decreasing function f : N →N let
Cf := {G : tw(G) ≤f (|G|)}.
1. If f (n) > log48 n for all n greater than some n0 ∈N, then MC(MSO2,
Cf ) ̸∈XP unless SAT can be solved in sub-exponential time.
2. If f is constant, then MC(MSO2, Cf ) ∈FPT.

Algorithmic meta-theorems
261
Theorem 5.8.5 gives a classiﬁcation of tractability of MSO2 on classes of
coloured graphs. The restriction to coloured graphs is somewhat artiﬁcial as
coloured graphs do not naturally occur very often. It does show, however, that
Courcelle’s theorem cannot be extended in full generality beyond logarithmic
tree-width.
A much more natural result would be if closure under colours could be
replaced by closure under subgraphs. I believe this is possible but it will require
much more involved algorithmic techniques.
5.8.3 Limits to First-Order Model-Checking
In this section we will summarise some intractability results for ﬁrst-order
logic. As before, ideally we would like to completely classify the classes C of
structures into those where MC(FO, C) is FPT and where it is not. However,
with the graph structure properties studied so far, it is unlikely that we can
fully explore tractability for ﬁrst-order model-checking as FO-model-checking
is preserved under interpretations whereas properties such as excluding a minor
or bounded tree-width are not.
Lemma 5.8.7 If C is a class of graphs such that MC(FO, C) is ﬁxed-parameter
tractable and D is a class of graphs ﬁrst-order interpretable in C as described
in Section 5.2.3, then ﬁrst-order model-checking is ﬁxed-parameter tractable
on D.
Corollary 5.8.8 If
MC(FO, C) is ﬁxed-parameter tractable then so is
MC(FO, D) for the class D := {G := (V, V 2 \ E) : (V, E) ∈C} of graphs
whose complements are in C.
Hence, if there is a graph property that precisely describes when FO model-
checking is tractable, it has to be closed under edge-complementation or more
generally under ﬁrst-order interpretations. Note that the analogous result does
not hold for MSO2, as in general MSO2 formulas on a graph cannot be rewritten
to work on the complement graph instead.
In addition to studying further classes of graphs obtained from graph invari-
ants it may therefore be beneﬁcial to consider constructions that allow us to
construct new classes C of graphs with tractable model-checking from other,
known classes of graphs. For instance, one could try to generalise the construc-
tions using tree-decompositions over classes of graphs. It is easily seen that
if C is a class of graphs for which the appropriate version of Lemma 5.7.13
holds, then ﬁrst-order model-checking is also tractable on the class of graphs
that can efﬁciently be tree-decomposed over C. We refrain from giving a formal

262
Stephan Kreutzer
deﬁnition of this as, so far, its only application seems to be Theorem 5.7.14.
Tree-decompositions are a special case where Feferman-Vaught style theorems
can be applied. It may be worthwhile to consider further constructions that
allow us to deﬁne new tractable model-checking intances from the classes we
already know.
The previous lemma also has interesting consequences in its negative form,
that is, it can be used to show intractability results as demonstrated in the next
lemma.
Lemma 5.8.9 For k ∈N let ADk be the class of graphs of maximum average
degree at most k, where the maximum average degree of a graph G is the max-
imum of the average degrees of all subgraphs of G. For k ≥4, MC(FO, ADk)
is AW[∗]-hard, i.e. ﬁxed-parameter intractable.
Proof. Recall from Section 5.2.4 that MC(FO, Graph), the model-check-
ing problem for FO on the class of all ﬁnite graphs, is AW[∗]-complete.
Further, FO model-checking on the class of all graphs G can easily be
reduced to FO model-checking on the class of incidence graphs I(G). As
incidence graphs have maximum average degree at most 4, the result follows
immediately.
□
Hence, graph classes of bounded maximum average degree provide a ﬁrst
non-trivial upper bound for parameterized tractability of FO model-checking.
Towards another graph property that may yield ﬁxed-parameter algorithms
for ﬁrst-order logic, consider again the proof of the previous lemma. Essentially,
given a graph G we subdivide every edge once to obtain the incidence graph.
For ﬁrst-order logic, this does not pose much of a problem as we can easily
rewrite the formula to deal with the subdivision. Similarly, if we replace every
edge by a path of length k, i.e. subdivide a bounded number of times, then again
we obtain small maximum average degree but we can easily rewrite ﬁrst-order
formulas to deal with these paths of ﬁxed length.
Note that this essentially means that we replace every vertex by a graph
of ﬁxed radius, e.g. in the case of k = 3 we replace every vertex by a star.
Hence, if we are interested in paramaterized tractability, then we should
require our graphs to have bounded maximum average degree even after
we contract neighbourhoods of a ﬁxed radius. This idea is formalised in the
notion of bounded expansion introduced by Neˇsetˇril and Ossona de Mendez in
[65, 66, 67].
An even more general concept of graphs is the concept of graph classes
which are nowhere dense, introduced by Neˇsetˇril and Ossona de Mendez in
[68].

Algorithmic meta-theorems
263
We say that H is a minor at depth r of G (and write H ≼r G) if H is a
minor of G and this is witnessed by a minor map µ of H into G so that every
vertex v ∈V (H) is mapped to a subgraph µ(v) ⊆G which induces a graph of
radius at most r. That is, for each v ∈V (H), there is a w ∈V (µ(v)) such that
µ(v) ⊆N µ(v)
r
(w).
Deﬁnition 5.8.10 ([68]) A class of graphs C is said to be nowhere dense if for
every r ≥0 there is a graph Hr such that Hr ̸≼r G for all G ∈C.
Conversely, if a class C of graphs is not nowhere dense then there is a
radius r such that every graph H is a depth r minor of some graph GH ∈C.
If, furthermore, C is closed under taking subgraphs, then the depth-d image
IH of H in GH is itself a graph in C. Note that the size of IH is polynomially
bounded in H (for ﬁxed r). Classes which are not nowhere dense are called
somewhere dense in [68]. Let us call a class effectively somewhere dense if,
given a graph H, a depth-d image IH ∈C of H in a graph GH ∈C can be
computed in polynomial time.
As the following theorem shows, in terms of sparse classes of graphs,
nowhere dense classes are the natural border for tractability of ﬁrst-order logic.
Theorem 5.8.11 If C is effectively somewhere dense and closed under taking
subgraphs, then MC(FO, C) is not ﬁxed-parameter tractable unless FPT =
AW[∗].
The proof relies on the fact that we can interpret the class of all graphs in
any effectively somewhere dense class of graphs which is closed under sub-
graphs, as every graph occurs as a depth d minor of a member of C and
the depth-d image of this is itself a graph in C. Sub-divisions of a ﬁxed
length can be deﬁned in ﬁrst-order logic and hence model checking for ﬁrst-
order logic on the class of all graphs can be reduced to FO-model-checking
on any effectively somewhere dense class of graphs which is closed under
subgraphs.
Furthermore, it seems likely that on every nowhere dense class of graphs,
ﬁrst-order model checking is ﬁxed-parameter tractable.
Conjecture 5.8.12 If C is nowhere dense then MC(FO, C) ∈FPT.
If this conjecture could be proved then on subgraph closed classes of graphs,
the property of being nowhere dense would exactly characterise the tractable
cases.

264
Stephan Kreutzer
bd. tree−width
trees
eff. somew. dense
bd. degree
H−Minor Free
bd. local tree−w.
bd. local rank−w.
loc. excl. minors 
slow grow ex min
Apex Minor Free
bd. clique−width
planar
nowhere dense
Courcelle [13]
Dawar, Grohe,
Kreutzer [21]
Dawar, Grohe,
Kreutzer [21]
K. 09
Flum, Grohe [45]
Frick, Grohe [47]
closure under FO interpretations
closure under MSO interpretations
FO
MSO
Courcelle [12]
Frick, Grohe [47]
Seese [82]
intractable classes
tractable classes
closure under FO interpretations
Grohe [53]
Neˇsetˇril,
de Mendez [68]
Figure 5.18 Summary of results
5.9 Conclusion
This paper gives an overview of algorithmic meta-theorems developed in recent
years. See Figure 5.18 for a diagrammatic summary of the results presented in
this paper.
As we have seen, ﬁrst-order model-checking is ﬁxed-parameter tractable
on a wide range of graph classes deﬁned by standard graph invariants such as
tree-width or excluded minors. By localising these invariants we obtained even
further tractable classes. However, we are still very far from a clear picture
of where ﬁrst-order model-checking is tractable and where it is not. Further

Algorithmic meta-theorems
265
research, in particular into intractability results is needed before we can hope
for a clean and smooth theory.
Acknowledgements
I want to take this opportunity to express my gratitude towards Martin Grohe
for the long discussions we had on graph minors and for his advise, patience
and inspiration during the time I worked with him at the Humboldt University
in Berlin.
Many thanks to Javier Esparza for proofreading this manuscript and for his
patience as an editor. Special thanks for proofreading this manuscript go to
Martin Grohe, Paul Hunter, Michael Kreikenbaum, Andras Salamon and Mark
Weyer.

References
[1] I. Adler, M. Grohe, and S. Kreutzer. Computing excluded minors. In Proc. of
the 19th ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 641–650,
2008.
[2] H. Andr´eka, J. van Benthem, and I. N´emeti. Modal languages and bounded frag-
ments of predicate logic. Journal of Philosophical Logic, 27:217–274, 1998.
[3] S. Arnborg, D. Corneil, and A. Proskurowski. Complexity of ﬁnding embeddings
in a k-tree. SIAM Journal on Algebraic Discrete Methods, 8:277–284, 1987.
[4] S. Arnborg, J. Lagergren, and D. Seese. Easy problems for tree-decomposable
graphs. Journal of Algorithms, 12(2):308–340, 1991.
[5] Z. Bian and Q.-P. Gu. Computing branch decomposition of large planar graphs.
In Experimental Algorithms, volume 5038 of Lecture Notes in Computer Science,
pages 87–100. Springer, 2008.
[6] H. Bodlaender. A linear-time algorithm for ﬁnding tree-decompositions of small
tree-width. SIAM Journal on Computing, 25:1305–1317, 1996.
[7] H. Bodlaender and D. M. Thilikos. Constructive linear time algorithms for branch-
width. In Proc. of the 24th Int. Col. on Automata, Languages and Programming
(ICALP), volume 1256 of Lecture Notes in Computer Science (LNCS), pages
627–637. Springer, 1997.
[8] E. B¨orger, E. Gr¨adel, and Y. Gurevich. The Classical Decision Problem. Springer-
Verlag, 2001.
[9] J. R. B¨uchi. Weak second-order arithmetic and ﬁnite automata. Zeitschrift f¨ur
Mathematische Logik und Grundlagen der Mathematik, 6:66–92, 1960.
[10] H. Comon, M. Dauchet, R. Gilleron, C. L¨oding, F. Jacquemard, D. Lugiez,
S. Tison, and M. Tommasi. Tree automata techniques and applications. Available
on: http://tata.gforge.inria.fr/, 2007. Release 12 October 2007.
[11] T. Cormen, C. Leiserson, R. Rivest, and C. Stein. Introduction to Algorithms. MIT
Press, 2nd edition, 2001.
[12] B. Courcelle. An axiomatic deﬁnition of context-free graph grammars and appli-
cations to NLC grammars. Theoretical Computer Science, 55:141–181, 1987.
[13] B. Courcelle. Graph rewriting: An algebraic and logic approach. In J. van Leeuwen,
editor, Handbook of Theoretical Computer Science, volume 2, pages 194 – 242.
Elsevier, 1990.
266

Algorithmic meta-theorems
267
[14] B. Courcelle. The monadic second-order theory of graphs VII: Graphs as relational
structures. Theoretical Computer Science, 101:3–33, 1992.
[15] B. Courcelle, R.G. Downey, and M.R. Fellows. A note on the computability of
graph minor obstruction sets for monadic second order ideals. Journal of Universal
Computer Science, 3:1194–1198, 1997.
[16] B. Courcelle and J. Engelfriet. A logical characterization of the sets of hyper-
graphs deﬁned by hyperedge replacement grammars. Mathematical Systems The-
ory, 28:515–552, 1995.
[17] B. Courcelle, J. Engelfriet, and G. Rozenberg. Handle-rewriting hypergraphs gram-
mars. Journal of Computer and System Sciences, 46:218–270, 1993.
[18] B. Courcelle, J. Makowski, and U. Rotics. Linear time solvable optimization
problems on graphs of bounded clique-width. Theory of Computing Systems,
33(2):125–150, 2000.
[19] B. Courcelle and S. Olariu. Upper bounds to the clique width of graphs. Discrete
Applied Mathematics, 101:77–114, 2000.
[20] B. Courcelle and S.-I. Oum. Vertex-minors, monadic second-order logic, and a
conjecture by Seese. Journal of Combinatorial Theory, Series B, 97(1):91–126,
2007.
[21] A. Dawar, M. Grohe, and S. Kreutzer. Locally excluding a minor. In Logic in
Computer Science (LICS), pages 270–279, 2007.
[22] A. Dawar, M. Grohe, S. Kreutzer, and N. Schweikardt. Approximation schemes for
ﬁrst-order deﬁnable optimisation problems. In Logic in Computer Science (LICS),
pages 411–420, 2006.
[23] A. Dawar, M. Grohe, S. Kreutzer, and N. Schweikardt. Model theory makes formu-
las large. In Proc. of the 34th International Colloquium on Automata, Languages
and Programming (ICALP), volume 4596 of Lecture Notes in Computer Science,
pages 913–924, 2007.
[24] E. Demaine and M. Hajiaghayi. Graphs excluding a ﬁxed minor have grids as
large as treewidth, with combinatorial and algorithmic applications through bidi-
mensionality. In Proc. of the 16th ACM-SIAM Symposium on Discrete Algorithms
(SODA), pages 682–689, 2005.
[25] E. Demaine and M. Hajiaghayi. The bidimensionality theory and its algorithmic
applications. The Computer Journal, pages 332–337, 2008.
[26] E. Demaine and M. Hajiaghayi. Linearity of grid minors in treewidth with appli-
cations through bidimensionality. Combinatorica, 28(1):19–36, 2008.
[27] E. Demaine, M. Hajiaghayi, F. Fomin, and D. Thilikos. Bidimensional parameters
and local tree-width. SIAM Journal of Discrete Mathematics, 2004.
[28] E. Demaine, M. Hajiaghayi, and D. Thilikos. The bidimensional theory of
bounded-genus graphs. SIAM Journal of Discrete Mathematics, 20(2):357–371,
2006.
[29] E. D. Demaine, M. Hajiaghayi, and K. Kawarabayashi. Algorithmic graph minor
theory: Decomposition, approximation, and coloring. In 46th Annual Symposium
on Foundations of Computer Science (FOCS), pages 637–646, 2005.
[30] R. Diestel. Graph Theory. Springer-Verlag, 3rd edition, 2005.
[31] J. Doner. Tree acceptors and some of their applications. Journal of Computer and
System Sciences, 4:406–451, 1970.

268
Stephan Kreutzer
[32] F. Dorn, F. Fomin, and D. Thilikos. Catalan structures and dynamic programming
in H-minor-free graphs. In Proc. of the 19th ACM-SIAM Symposium on Discrete
Algorithms (SODA), pages 631–640, 2008.
[33] F. Dorn, F. Fomin, and D. Thilikos. Subexponential parameterized algorithms.
Computer Science Review, 2:29–39, 2008.
[34] R. Downey and M. Fellows. Fixed-parameter tractability and completeness I: Basic
results. SIAM Journal on Computing, 24:873–921, 1995.
[35] R. Downey and M. Fellows. Fixed-parameter tractability and completeness II: On
completeness for W[1]. Theoretical Computer Science, 141:109–131, 1995.
[36] R. Downey and M. Fellows. Parameterized Complexity. Springer, 1998.
[37] H.-D. Ebbinghaus and J. Flum. Finite Model Theory. Springer, 2nd edition,
1999.
[38] H.-D. Ebbinghaus, J. Flum, and W. Thomas. Mathematical Logic. Springer, 2nd
edition, 1994.
[39] J. Engelfriet and V. van Oostrom. Logical description of context-free graph lan-
guages. Journal of Computer and System Sciences, 3:489–503, 1997.
[40] P.
Hlinˇen´y
and
S.-I.
Oum.
Finding
branch-decompositions
and
rank-
decompositions.
Available
at
http://www.math.uwaterloo.ca/∼
sangil/, 2007.
[41] W. Espelage, F. Gurski, and E. Wanke. Deciding clique-width for graphs of
bounded tree-width. In Proc. of the 7th International Workshop on Algorithms
and Data Structures (WADS), volume 2125 of Lecture Notes in Computer Science,
pages 87–98, 2001.
[42] M. R. Fellows, F. A. Rosamond, U. Rotics, and S. Szeider. Clique-width mini-
mization is np-hard. In 38th ACM Symposium on Theory of Computing (STOC),
pages 354–362, 2006.
[43] M.R. Fellows and M.A. Langston. An analogue of the Myhill-Nerode theorem
and its use in computingﬁnite-basis characterizations. In Proceedings of the 30th
Annual IEEE Symposium on Foundations of Computer Science, pages 520–525,
1989.
[44] M.R. Fellows and M.A. Langston. On search, decision and the efﬁciency of
polynomial-time algorithms. In Proc. of the 21st ACM Symposium on Theory
of Computing (STOC), pages 501–512, 1989.
[45] J. Flum and M. Grohe. Fixed-parameter tractability, deﬁnability, and model-
checking. SIAM Journal of Computing, 31(1):113–145, 2001.
[46] J. Flum and M. Grohe. Parameterized Complexity Theory. Springer, 2006. ISBN
3-54-029952-1.
[47] M. Frick and M. Grohe. Deciding ﬁrst-order properties of locally tree-
decomposable structures. Journal of the ACM, 48:1148 – 1206, 2001.
[48] H. Gaifman. On local and non-local properties. In J. Stern, editor, Herbrand
Symposium, Logic Colloquium ’81, pages 105–135. North Holland, 1982.
[49] M. R. Garey, D. S. Johnson, and L. Stockmeyer. Some simpliﬁed NP-complete
problems. In Proc. of the 6th ACM Symposium on Theory of Computing (STOC),
pages 47–63, 1974.
[50] J.F. Geelen, A.M.H. Gerards, N. Robertson, and G. Whittle. On the excluded
minors for the matroids of branch-width k. Journal of Combinatorial Theory,
Series B, 88:261–265, 2003.

Algorithmic meta-theorems
269
[51] E. Gr¨adel, C. Hirsch, and M. Otto. Back and forth between guarded and modal
logics. ACM Transactions on Computational Logics, 3(3):418–463, 2002.
[52] M. Grohe. Local tree-width, excluded minors, and approximation algorithms.
Combinatorica, 23(4):613–632, 2003.
[53] M. Grohe. Logic, graphs, and algorithms. In T.Wilke J.Flum, E.Gr¨adel, editor,
Logic and Automata – History and Perspectives. Amsterdam University Press,
2007.
[54] Q-P. Gu and H. Tamaki. Optimal branch-decomposition of planar graphs in O(n3)
time. In Proc. of the 32nd International Colloquium on Automata, Languages and
Programming (ICALP), pages 373–384, 2005.
[55] F. Gurski and E. Wanke. The tree-width of clique-width bounded graphs without
kn, n. In Proc. of the 27th International Workshop on Graph-Theoretic Concepts
in Computer Science (WG), volume 1928 of Lecture Notes in Computer Science,
pages 196–205, 2001.
[56] F. Gurski and E. Wanke. Minimizing NLC-width is NP-complete. In Proc. of the
31st International Workshop on Graph-Theoretic Concepts in Computer Science
(WG), pages 69–80, 2005.
[57] W. Hodges. A shorter model theory. Cambridge University Press, 1997.
[58] V. Jel´ınek. The rank-width of the square grid. In Proc. of the 34th International
Workshop on Graph-Theoretic Concepts in Computer Science (WG), 2008.
[59] S. Kreutzer. On the parameterised intractability of monadic second-order logic. In
Proc. of Computer Science Logic (CSL), pages 348–363, 2009.
[60] S. Kreutzer and S. Tazari. On brambles, grid-like minors, and parameterized
intractability of monadic second-order logic. In Symposium on Discrete Algo-
rithms (SODA), 2010. to appear.
[61] K. Kuratowski. Sur le probl´eme des courbes gauches en topologie. Fundamentae
Mathematicae, 15:271 – 283, 1930.
[62] J. Lagergren. Upper bounds on the size of obstructions and intertwines. Journal of
Combinatorial Theory, Series B, 73:7–40, 1998.
[63] L. Libkin. Elements of Finite Model Theory. Springer, 2004.
[64] J. Makowski. Algorithmic uses of the Feferman-Vaught theorem. Annals of Pure
and Applied Logic, 126:159–213, 2004.
[65] J. Neˇsetˇril and P. Ossona de Mendez. Grad and classes with bounded expansion I.
Decompositions. European Journal of Combinatorics, 29(3):760–776, 2008.
[66] J. Neˇsetˇril and P. Ossona de Mendez. Grad and classes with bounded expansion II.
Algorithmic aspects. European Journal of Combinatorics, 29(3):777–791, 2008.
[67] J. Neˇsetˇril and P. Ossona de Mendez. Grad and classes with bounded expansion III.
Restricted graph homomorphism dualities. European Journal of Combinatorics,
29(4):1012–1024, 2008.
[68] J. Neˇsetˇril and P. Ossona de Mendez. On nowhere dense graphs. to appear in
European Journal on Combinatorics, 2008.
[69] R. Niedermeier. Invitation to Fixed-Parameter Algorithms. Oxford University
Press, 2006. ISBN 0-19-856607-7.
[70] S.-I. Oum. Rank-width is less than or equal to branch-width. Journal of Graph
Theory, 57(3):239–244, 2008.
[71] S.-I. Oum and P.D. Seymour. Approximating clique-width and branch-width. Jour-
nal of Combinatorial Theory, Series B, 96:514 – 528, 2006.

270
Stephan Kreutzer
[72] C. Papadimitriou. Computational Complexity. Addison-Wesley, 1994.
[73] N. Robertson, P. Seymour, and R. Thomas. Quickly excluding a planar graph.
Journal of Combinatorial Theory, Series B, 1994.
[74] N. Robertson and P. D. Seymour. Graph minors V. Excluding a planar graph.
Journal of Combinatorial Theory, Series B, 41(1):92–114, 1986.
[75] N. Robertson and P. D. Seymour. Graph minors X. Obstructions to tree-
decompositions. Journal of Combinatorial Theory B, 52:153–190, 1991.
[76] N. Robertson and P.D. Seymour. Graph minors I–XXIII. Appearing in Journal of
Combinatorial Theory, Series B since 1982.
[77] N. Robertson and P.D. Seymour. Graph minors III. Planar tree-width. Journal of
Combinatorial Theory, Series B, 36:49–64, 1984.
[78] N. Robertson and P.D. Seymour. Graph minors XIII. The disjoint paths problem.
Journal of Combinatorial Theory, Series B, 63:65–110, 1995.
[79] N. Robertson and P.D. Seymour. Graph minors XVI. Excluding a non-planar graph.
Journal of Combinatorial Theory, Series B, 77:1–27, 1999.
[80] N. Robertson and P.D. Seymour. Graph minors XX. Wagner’s conjecture. Journal
of Combinatorial Theory, Series B, 92:325–357, 2004.
[81] D. Seese. The structure of models of decidable monadic theories of graphs. Annals
of Pure Applied Logic, 53(2):169–195, 1991.
[82] D. Seese. Linear time computable problems and ﬁrst-order descriptions. Mathe-
matical Structures in Computer Science, 5:505–526, 1996.
[83] P. Seymour. A bound on the excluded minors for a surface, 1995. Unpublished
manuscript.
[84] P. Seymour and R. Thomas. Call routing and the ratcatcher. Combinatorica,
14(2):217–241, 1994.
[85] J. W. Thatcher and J. B. Wright. Generalised ﬁnite automata theory with an
application to a decision problem of second-order logic. Mathematical Systems
Theory, 2:57–81, 1968.
[86] W. Thomas. Languages, automata, and logic. In G. Rozenberg and A. Salomaa,
editors, Handbook of Formal Languages, volume III, pages 389–455. Springer,
1997.
[87] C. Thomassen. A simpler proof of the excluded minor theorem for higher surfaces.
Journal of Combinatorial Theory, Series B, 70:306–311, 1997.
[88] M. Vardi. On the complexity of relational query languages. In Proc. of the 14th
Symposium on Theory of Computing (STOC), pages 137–146, 1982.
[89] M. Vardi. On the complexity of bounded variable queries. In Proc. of the 14th ACM
Symposium on Principles of Database Systems (PODS), pages 266–276, 1995.
[90] K. Wagner. ¨Uber eine Eigenschaft der ebenen Komplexe. Mathematische Annalen,
114:570–590, 1937.
[91] E. Wanke. k-NLC graphs and polynomial algorithms. Discrete Applied Mathemat-
ics, 54:251–266, 1994.

6
Model theoretic methods for fragments of FO
and special classes of (ﬁnite) structures
martin ottoa
6.1
Introduction
page 272
6.1.1
Expressiveness over restricted classes of structures
272
6.1.2
Basic terminology and notational conventions
276
6.2
Model theoretic games and bisimulation
281
6.2.1
The semantic game: veriﬁer vs. falsiﬁer
281
6.2.2
The comparison game: back and forth
285
6.2.3
Natural restrictions/variations
292
6.2.4
Bisimulation as the master game
301
6.2.5
Locality and modularity of the ﬁrst-order game
303
6.3
Special classes of transition systems
306
6.3.1
Tree unfoldings and locally tree-like systems
306
6.3.2
Non-classical modal characterisation theorems
313
6.4
From graphs to hypergraphs
320
6.4.1
Hypergraph bisimulation
321
6.4.2
Tree-likeness: acyclicity criteria
322
6.4.3
Excursion: extension properties
325
6.5
Locality and special classes of relational structures
327
6.5.1
Tree-decompositions and treewidth
327
6.5.2
Non-classical proofs for (variants of) classical
characterisations
331
6.6
Concluding remarks
337
Bibliography
339
Abstract
Some prominent fragments of ﬁrst-order logic are discussed from a game-
oriented and modal point of view, with an emphasis on model theoretic
techniques for the non-classical context. This includes the context of ﬁnite
a Technische Universit¨at Darmstadt, otto@mathematik.tu-darmstadt.de
271

272
Martin Otto
model theory as well as the model theory of other natural non-elementary
classes of structures. We stress the modularity and compositionality of
the games as a key ingredient in the exploration of the expressive power
of logics over speciﬁc classes of structures. The leading model theo-
retic theme is expressive completeness – or the characterisation of frag-
ments of ﬁrst-order logic as expressively complete over some class of
(ﬁnite) structures for ﬁrst-order properties with some prescribed semantic
preservation behaviour. In contrast with classical expressive complete-
ness arguments, the emphasis here is on explicit model constructions and
transformations, which are guided by the game analysis of both ﬁrst-order
logic and of the imposed semantic constraints.
keywords: ﬁnite model theory, model theoretic games, bisimulation, modal
and guarded logic, expressive completeness, preservation and characterisation
theorems
6.1 Introduction
6.1.1 Expressiveness over restricted classes of structures
The purpose of this survey is to highlight game-oriented methods and explicit
model constructions for the analysis of fragments of ﬁrst-order logic, in par-
ticular in restriction to non-elementary classes of structures. The following is
meant to highlight and preview some key points in terms of both the material
to be covered and the perspective that we want to adopt in its presentation. All
these points will be addressed in a more self-contained manner in the technical
sections; an outline of the structure of the technical sections concludes this
preview.
Varying the class of structures
The class of all ﬁnite structures is one
prominent non-elementary class of interest, but recent developments in ﬁnite
model theory have broadened the perspective. While the ﬁrst tier of results
in ﬁnite model theory, which set the stage and clariﬁed much of the speciﬁcs
of ﬁnite model theory, brought predominantly negative results (‘failures’ in
comparison to classical model theory, the ﬁrst and foremost being the ‘failure
of compactness’ in ﬁnite model theory), a much more positive picture has
emerged with a focus on speciﬁc classes of well-behaved ﬁnite structures
rather than the class of all ﬁnite structures (cf. Weinstein’s tame fragments and
tame classes [51]). What good behaviour means for classes of structures, may
of course depend on the model theoretic issue at hand. Nevertheless, there are

Fragments of FO and special classes of structures
273
some interesting recurring themes, revolving around tree-likeness on the one
side and locality criteria on the other side, in delineating well-behaved classes
of (ﬁnite) structures.
Expressiveness and expressive completeness
Our leading model theoretic
theme in terms of results is that of expressive completeness. We regard expres-
sive completeness results as classical hallmarks in the study of expressiveness
of fragments of ﬁrst-order logic. Think of a classical example like the Łos–
Tarski existential preservation theorem (cf. Theorem 6.5.2) that a ﬁrst-order
formula is preserved under extensions if, and only if, it is logically equiva-
lent to an existential formula. The preservation claim in this statement – that
existential formulae are preserved under extensions – is a trivial exercise in syn-
tactic induction, and its truth carries over to any restricted class of structures.
The expressive completeness statement – that within ﬁrst-order, the existential
fragment is expressively complete for properties preserved under extensions –
requires real model theoretic proof. The classical proof in [11] uses elementary
extensions, whose availability hinges on the use of the compactness theorem for
ﬁrst-order logic. So that proof does not relativise to arbitrary restricted classes,
and in fact the relativisation to the class of all ﬁnite structures is a typical
example of a ‘failure in ﬁnite model theory’ (due to Tait and Gurevich, see for
instance [15]). Preservation of a ﬁrst-order property under extensions among
ﬁnite structures does not imply expressibility in existential ﬁrst-order logic
over ﬁnite structures. Some instances of classical preservation theorems, like
Łos–Tarski, fail in restriction to the class of all ﬁnite structures, but are true –
with totally new proofs – in interesting restricted classes of ﬁnite structures (cf.
Theorem 6.5.9 for results pertaining to extension preservation, from [3]). Other
instances, like van Benthem’s theorem concerning preservation under bisim-
ulation (cf. Corollary 6.3.5), or, more classically, the Lyndon–Tarski theorem
(cf. Theorem 6.5.3), which associates preservation under homomorphisms with
the existential positive fragment, do have literal analogues in restriction to the
class of all ﬁnite structures as well as to some other restricted classes of struc-
tures of interest (cf. sections 6.3.2 and 6.5.2) – with new proofs that do not draw
on the classical proofs but shed interesting new light on the classical results as
well. And in some few instances we know of expressive completeness results
over restricted classes of (ﬁnite) structures that require more expressive frag-
ments than the classical analogue; a recent example concerning bisimulation
preservation is discussed in section 6.3.2.
Explicit model constructions and transformations
Compactness, and with
it many of the typical model constructions prevalent in classical expressive

274
Martin Otto
completeness results, are typically not available over the restricted classes of
structures under consideration. Where expressive completeness results can be
obtained over non-elementary classes, the methods are very different from the
classical ones. The technical crux of many expressive completeness results,
classical or otherwise, consists in an upgrading of transfer or equivalence rela-
tions between structures. For instance, in the case of preservation under some
equivalence relation ⇋like bisimulation associated with expressibility in the
fragment L: here preservation under ⇋must be linked to preservation under
ﬁnitary approximations ⇋ℓto L-equivalence, ﬁnitary in the sense of ﬁnite
index and in the sense that its classes are L-deﬁnable (think of approximations
parameterised, e.g., by quantiﬁer rank ℓ). As these ﬁnitary approximations ⇋ℓ
are rougher than full ⇋, the task of showing that every ﬁrst-order property ϕ
preserved under ⇋is even preserved under some ⇋ℓ, involves model theo-
retic transformations that allow us to boost ⇋ℓeither to ⇋or to some other
equivalence under which ϕ is preserved (e.g., on account of being ﬁrst-order of
a certain quantiﬁer rank). The classical treatment of the Łos–Tarski theorem,
for instance, can similarly be viewed as an upgrading of a transfer relationship
A ⇒∃B (existential sentences true in A are also true in B), or of its ﬁnitary
approximations, to a substructure relationship between elementarily equiva-
lent companion structures of A and B. (In this case, B admits an elementary
extension that embeds A as a substructure, by compactness.) It follows that
any ﬁrst-order ϕ preserved under extensions is preserved under ⇒∃, and – by
another compactness argument – therefore also under some ﬁnite quantiﬁer
rank approximation ⇒ℓ
∃to ⇒∃.
As will be discussed in section 6.3.2, such upgrading arguments tend to
proceed in orthogonal directions of entirely different character, depending on
whether they are based on classical compactness arguments (often involving
elementary chains and saturation) or on explicit and ﬁnitary model transforma-
tions, which may also be carried out within some restricted, non-elementary
class of structures like the class of just all ﬁnite structures. Explicit model con-
structions and transformations can thus sometimes replace the sweeping clas-
sical compactness arguments that guarantee the existence of nice and smooth
(but typically inﬁnite) representatives of the structures at hand, in which crucial
technicalities (e.g., back-and-forth arguments) can be dealt with more elegantly.
But there is also something to be gained, even from the classical point of view,
from the more explicit, more controlled and more constructive nature of the
alternative model transformations: in key examples of expressive completeness
results to be discussed below, for instance, bounds on the quantiﬁer rank of the
target formulae are an integral part of the proofs based on explicit model con-
structions and transformations. In this sense, the alternative approach, which is

Fragments of FO and special classes of structures
275
necessitated by the loss of compactness in ﬁnite model theory, can offer a new
perspective and sometimes extra information on classical results.
Model theoretic games
The equivalences and transfer relations between
structures underlying semantic preservation properties on the one hand, and
logical equivalences or transfer relations induced by fragments of ﬁrst-order
logic on the other hand, are closely linked to model theoretic games or back-
and-forth systems. As pointed out above, upgrading arguments between these
equivalences and suitable ﬁnitary approximations, which are themselves nat-
urally cast as game equivalences, play a crucial role in expressive complete-
ness proofs. The methodological importance of model theoretic games, both
to understand the semantics and expressive power of logics and to guide the
desired explicit model constructions or transformations (over restricted classes
of structures), is being put at the centre of this presentation. We shall here
especially discuss variants of the classical Ehrenfeucht–Fra¨ıss´e game and the
ﬁrst-order model checking game for several fragments of ﬁrst-order logic.
A prominent place among these variants is given to the modal Ehrenfeucht–
Fra¨ıss´e game, or bisimulation game. In section 6.3, bisimulation games and
model transformations that respect bisimulation feature prominently in the
discussion of expressive completeness results for modal logics over various
classes of Kripke structures. Also locality of ﬁrst-order logic in the sense of
Gaifman’s theorem (cf. Theorem 6.2.13) is presented in terms of the modular-
ity of the ﬁrst-order Ehrenfeucht–Fra¨ıss´e game w.r.t. locality in the Gaifman
graph. Locality-based approximations to ﬁrst-order equivalence also play a
role in some of the expressive completeness results for modal logics, or in the
upgrading between approximate levels of bisimulation and ﬁrst-order equiva-
lence. Structurally, the concept of locality will also be important in connection
with classes of structures deﬁned in terms of wideness criteria in section 6.5.
Bisimulation as the game of games
Putting games – model checking games
that deﬁne the semantics of a logic and Ehrenfeucht–Fra¨ıss´e model comparison
games – at the centre of the analysis of fragments of ﬁrst-order logic, it becomes
very natural to adopt a modal perspective [9, 10] and to relate other fragments
and their games to the bisimulation game. We thus draw on bisimulation games
and bisimulation equivalence not just in the study of modal fragments but
also on its role as an equivalence between game graphs that encapsulate the
semantics of other fragments. The connection is made by looking at the natural
game graphs associated with model checking games or Ehrenfeucht–Fra¨ıss´e
games as Kripke structures. The elements of these Kripke structures are formed

276
Martin Otto
by the observable conﬁgurations in the underlying structures, their accessibility
relations reﬂect the transitions between game positions, which in turn reﬂect
the available quantiﬁcation patterns of the fragment at hand. For the modal
fragment itself, the structure (Kripke structure, transition system) is its own
game graph, in which the elements can be navigated along the edges (of the
given accessibility or transition relation). Richer fragments have access to more
complex types of conﬁgurations within structures and possibly more complex
rules for navigation between conﬁgurations. For instance, in the k-variable
fragment FOk ⊆FO we deal with arbitrary conﬁgurations consisting of up to k
elements, while in the guarded fragment GF ⊆FO the conﬁgurations need to
be covered by some relational ground atom. This view may not directly offer
new technical insights, but has the advantage of making explicit a unifying and,
I think, intuitive framework whose specialisations to individual fragments are
of course very well understood.
Structure of the paper
The overall structure of the paper is as follows. In
section 6.2 we review model checking and model comparison games for FO
and some of its fragments from a modal perspective; we also discuss Gaifman
locality in relation to the FO Ehrenfeucht–Fra¨ıss´e game. Section 6.3 deals
with expressive completeness issues for modal logics over speciﬁc classes of
transition systems. The extension of the concept of bisimulation from graphs to
hypergraphs, its relationship with the guarded fragment and a connection with
extension properties for partial automorphisms is discussed in section 6.4. In
section 6.5 we turn to locality based techniques for special classes of relational
structures, and to expressive completeness for preservation under extensions
and homomorphisms.
Sections 6.2 and 6.3 are meant to be fairly expository, and may serve either
as a brief introduction to the fragments and methods discussed, or as an invi-
tation to re-discover some rather familiar concepts in a slightly different light.
Sections 6.4 and 6.5 are more technical and also less self-contained. To a large
extent they may, on the other hand, also be considered independently of the
ﬁrst part. The intention is to give at least some high-level account of some more
recent results and developments in the framework of this survey.
6.1.2 Basic terminology and notational conventions
Structures and assignments
Throughout we only consider relational struc-
tures. Typically τ will be a ﬁnite relational signature, and we refer to the
maximal arity of relations in τ as its width. A τ-structure with universe A will

Fragments of FO and special classes of structures
277
usually be denoted as A = (A, (RA)R∈τ), but we often omit superscripts where
the structure is clear from context.
Within a τ-structure A, we look at (partial) assignments (to an ofﬁ-
cial set of ﬁrst-order variables x1, x2, . . .), described by partial functions
β : (xi) →A. Assignments to ﬁnite tuples of variables are often regarded as
momentarily ﬁxed parameter tuples, like a = (a1, . . . , ak) ∈Ak as an assign-
ment β : (xi →ai)i=1,...,k. Such (ﬁnite) assignments will also play a role
in games as conﬁgurations (tuples of marked elements) within a structure,
often directly associated also with the substructure induced on the subset
[a] := {a1, . . . , ak} ⊆A. Because we do not want to clutter terminology with
a ﬁne distinction between tuples and assignments, we also think of assign-
ments (which ofﬁcially are assignments to variables xi) as partial functions
β : i →β(i) over a domain of positive natural numbers. Notation for modiﬁ-
cations of assignments is as in β a
i , for the assignment obtained by changing
(or extending) β at i (at xi) to take the value a. For the semantics of formulae
ϕ(x) with free variables among those listed in the tuple x, notations A, a |= ϕ,
A |= ϕ[a], and A, β |= ϕ are used interchangeably, if β is an assignment to (at
least) the free variables of ϕ and assigns a to x.
Among important speciﬁc types of structures we mention the following to
clarify terminology. Other more speciﬁc classes of structures will be introduced
at appropriate places.
Directed and undirected graphs are structures over relational vocabularies of
width 2, i.e., we admit several binary relations (edge-labelled directed graphs)
and unary predicates (vertex colours). More traditional plain directed graphs
are a special case, with just a single binary edge relation. We also view directed
edge-labelled and vertex-coloured graphs as transition systems, with several
transition relations and atomic state predicates. Such transition systems are just
a terminological variant of Kripke structures, as the structures for modal logics.
Undirected graphs are graphs with a single edge relation that is symmetric and
irreﬂexive, viewed as a special case of directed graphs.
A (directed) tree is a directed graph that has a root w.r.t. the union of its binary
relations such that every other element is reachable on a unique edge-labelled
directed path from this node. Note that this implies irreﬂexivity (no loops),
antisymmetry (no edges in opposite directions, not even with different labels)
and that there are no multiple edges (with different labels). More generally, a
directed graph or transition system is called simple if it has no loops and no
multiple edges (not even in opposite directions).1
1 In section 6.3.2 we also discuss transitive tree structures, which are trees in the partial order
sense, not in the graph sense, but that will be highlighted there.

278
Martin Otto
Hypergraphs, which are at the centre of section 6.4, are not regarded as rela-
tional structures but as second-order structures of the format H = (A, S) with
a universe A and a subset of the power set S ⊆P(A) as the set of hyperedges.
We shall encounter hypergraphs as auxiliary combinatorial structure, induced
by relational structures, but will not look at logics over hypergraphs.
Gaifman graph and distance
With any structure in a ﬁnite relational vocab-
ulary τ we associate an undirected graph, its Gaifman graph.
Deﬁnition 6.1.1
The Gaifman graph of the τ-structure A is the undirected
graph G(A) = (A, EG(A)) with the same universe A and an edge (a, b) ∈EG(A)
for a ̸= b if a and b occur together in some tuple within some relation RA,
R ∈τ.
The associated notion of Gaifman distance is just ordinary graph distance
(minimal length of a connecting path, or inﬁnity) between elements in G(A).
We denote this distance as d(· , ·). Finite distance relations like d(x, y) ⩽k are
clearly FO-deﬁnable in A. In graphs (τ ﬁnite and of width 2), d(x, y) ⩽1 is
quantiﬁer free deﬁnable, while in general the required quantiﬁer rank is the
width of τ minus 2. An easy induction shows that d(x, y) ⩽2q is deﬁnable by
a ﬁrst-order formula ϕ(x, y) for any ﬁnite τ.
Deﬁnition
6.1.2
The
Gaifman
neighbourhood
of
radius
ℓ,
or
ℓ-
neighbourhood for short, of an element a in A is the subset N ℓ(a) =
{b ∈A: d(a, b) ⩽ℓ} ⊆A. By extension, the ℓ-neighbourhood of a tuple
a = (a1, . . . , ak) in A is the union of the Nℓ(ai).
A subset (or tuple) in A is ℓ-scattered if its elements (or components) have
pairwise distance greater than 2ℓ(i.e., if their ℓ-neighbourhoods are disjoint).
By the above considerations, ℓ-neighbourhoods of tuples, or the property of
a tuple to be ℓ-scattered, are all ﬁrst-order deﬁnable, for every ℓ∈N and for
any ﬁxed ﬁnite τ.
A relational structure is called acyclic if its Gaifman graph is acyclic; for
directed graphs as relational structures, this is different from the usual notion
which only forbids directed cycles.
A directed graph or transition system is ℓ-acyclic if its Gaifman graph is
acyclic in every ℓ-neighbourhood (this rules out undirected cycles of lengths
up to 2ℓ+ 1).
Logics
We write FO for ﬁrst-order logic, or more speciﬁcally FO[τ] for the
set of ﬁrst-order formulae over vocabulary τ. The set of free variables of a

Fragments of FO and special classes of structures
279
ﬁrst-order formula ϕ is denoted free(ϕ). Notation as in ϕ = ϕ(x) indicates that
free(ϕ) ⊆[x] (the set of variables listed as components of the tuple x).
Quantiﬁer-rank is deﬁned as usual for ﬁrst-order formulae, and denoted
qr(ϕ). Atomic and quantiﬁer-free types of tuples a in a τ-structure A provide full
descriptions of a at the quantiﬁer-free level. Formally we may deﬁne the atomic
type of a (in a matching tuple of variables, so that β : x →a is appropriate
as an assignment) as the set of all atomic and negated atomic formulae α(x)
in variables x for which A |= α[a]. It is clear that the correspondingly deﬁned
quantiﬁer-free type is fully determined by the atomic type, and that both can be
summarised by a single quantiﬁer-free formula in case τ is ﬁnite. The atomic
or quantiﬁer-free type of a in A fully determines the isomorphism type of A↾[a]
(of conﬁguration a in A).
FOk stands for the k-variable fragment of FO, which uses only the variable
symbols x1, . . . , xk. The ﬁnite variable fragments have played a very prominent
role in the development of ﬁnite model theory as witnessed for instance in
[15, 33]; we shall not focus on these fragments very much here, but treat the
associated k-pebble games as a typical and natural example in the exposition
of section 6.2.
Apart from fragments of FO, we occasionally look at its inﬁnitary extension
FO∞(classically denoted L∞ω), which extends the syntactic framework of FO
by allowing disjunctions and conjunctions over arbitrary sets of formulae. Con-
nectedness of graphs, for instance, becomes deﬁnable in FO∞with the use of
an inﬁnite disjunction to express “d(x, y) < ∞” as “{d(x, y) ⩽n: n ∈ω}”.
Formulae in FO∞have ordinal quantiﬁer rank, deﬁned by the usual inductive
clauses extended by taking suprema for inﬁnite disjunctions or conjunctions.
The quantiﬁer-rank of the formula “d(x, y) < ∞” would thus be ω, that of
the natural sentence deﬁning connectivity ω + 2. Similar inﬁnitary extensions
naturally arise, e.g., for the modal fragment to be discussed next.
Basic modal logic is denoted ML, or ML[τ] for a given vocabulary of width 2
appropriate for transition systems (Kripke structures). We typically use a τ with
binary transition relations Eα (regarding the indices α as edge labels) and unary
predicates Pj (associated to atomic state properties or atomic propositions pj).
The formulae of ML[τ] are generated from the atomic propositions pj by means
of boolean connectives and modal quantiﬁcations with ♦α or □α. The deﬁning
clause for the semantics of ϕ = ♦αψ, say at a state a in a τ-structure A, is
A, a |= ϕ
iff
A, b |= ψ for some b such that (a, b) ∈EA
α ,
and dually for □αψ, which is equivalent to ¬♦α¬ψ. We also view ML[τ] as a
fragment of FO[τ], having only formulae in one free variable, via the standard

280
Martin Otto
translation that associates pj with Pjx and ♦αψ with ∃y(Rαxy ∧ψ(y)) so that,
dually, □αψ is associated with ∀y(Rαxy →ψ(y)). This is brieﬂy reviewed in
connection with the model checking game for modal logic in section 6.2.3.
The extension of basic modal logic with modal quantiﬁcation backward
along Eα (inverse modalities) is denoted ML
−; the extension by a global modal-
ity, corresponding to the introduction of modal quantiﬁcation associated with
the full binary relation, is denoted ML
∀; the combined extension with both these
additions is ML
−∀. For background in connection with our treatment of modal
logics and much more material on the model theory of modal logics see in
particular [17].
The guarded fragment GF is deﬁned to be a syntactic fragment of FO
consisting of formulae in which all quantiﬁcations are relativised as in
ϕ(x) = ∃y(α(x′) ∧ψ(x′)), or
ϕ(x) = ∀y(α(x′) →ψ(x′)),
where α(x′) is an atomic τ-formula (a relational atom, or an equality: the
guard atom) such that free(ψ) ⊆var(α) (and y is a sub-tuple of x′ such that
[x′] \ [y] ⊆[x]).
The quantiﬁcation pattern of guarded logic extends that of modal logic.
For a modal vocabulary τ, GF[τ] properly contains (the standard ﬁrst-order
translations of) ML[τ] and even ML
−∀[τ]. One motivation for the study of the
guarded fragment stems from the analogy with modal logic, and the exten-
sion of modal quantiﬁcation patterns from Kripke structures to more general
relational structures. Guarded fragments were proposed in [2] with a view to
explaining the good algorithmic and model theoretic properties of modal logics
in a richer fragment of ﬁrst-order logic and other than the 2-variable fragment
[23]; see [21]. In many ways the guarded fragment has been shown to be a
rather well-behaved intermediary between ﬁrst-order and modal logic, in terms
of its model theoretic and algorithmic properties. For instance (like modal logic
and unlike FOk for k ⩾3), GF has the ﬁnite model property and is decidable:
the satisﬁability problem for GF[τ] is complete for deterministic exponential
time if τ is ﬁxed (more precisely, for any ﬁxed bound on the width of τ), and
complete for doubly exponential time without this constraint [21]. Similarly to
the tree model property of modal logic (which is a consequence of bisimulation
invariance and the model transformation of tree unfolding, see in particular
section 6.3.1), GF has a generalised tree model property, which similarly stems
from invariance under guarded bisimulation and the availability of guarded tree
unfoldings. For these considerations we refer to the discussion in section 6.4.2,

Fragments of FO and special classes of structures
281
where we interpret these phenomena in the light of a generalisation of bisim-
ulations from graphs to hypergraphs. For further results concerning the model
theory of GF and some of its generalisations see [21, 31, 25, 24, 8, 32] among
many others.
The semantics of the above-mentioned fragments, though assumed familiar,
will be reviewed again in section 6.2.3 when we discuss the associated model
checking games. There we shall proceed in the order of increasing specialisa-
tion, from FO to FOk to GF to (variants of ) ML.
6.2 Model theoretic games and bisimulation
As mentioned above, we adopt a non-standard perspective of looking at ﬁrst-
order logic (and some of its fragments) through modal eyes. Connections are
made through games, at two levels: at the level of model checking games,
which capture the semantics, and at the level of model comparison games,
which capture degrees of logical indistinguishability between structures.
No technical knowledge of model checking games and Ehrenfeucht-Fra¨ıss´e
games is assumed. The reader who has some familiarity with model checking
games and the Ehrenfeucht-Fra¨ıss´e technique for various fragments and exten-
sions of FO on the other hand, will recognise the familiar notions in a slightly
different perspective.
6.2.1 The semantic game: veriﬁer vs. falsiﬁer
We take a look at the ﬁrst-order model checking game from a modal point
of view. We shall then want to present some fragments of ﬁrst-order logic in
terms of restricted game boards; the same view will uniformly be applied to
the Ehrenfeucht–Fra¨ıss´e model comparison games in the next section.
A transition system of observable conﬁgurations
With the relational vocab-
ulary τ associate the vocabulary τ ∗consisting of binary transition relations Ei
for i ⩾1 and unary predicates Pθ for atomic τ-types θ = θ(x) in ﬁnite tuples
of variables from (xi)i⩾1. With a τ-structure A associate the following τ ∗
transition system O(A) of observable conﬁgurations over A:
– the universe of O(A) is the set of partial assignments to variables (xi)i⩾1;
– Ei is interpreted as {(β, β a
i ): a ∈A} (modiﬁcations of assignments at xi);
– Pθ as the set of assignments β satisfying θ (in particular var(θ) ⊆dom(β)).

282
Martin Otto
In a straightforward manner one obtains a uniform translation from FO[τ]
over A to ML[τ ∗] over the associated O(A). This translation,
FO[τ] −→ML[τ ∗]
ϕ(x) −→ϕ∗,
is such that for all β with free(ϕ) ⊆dom(β):
A, β |= ϕ
⇔
O(A), β |= ϕ∗.
At the quantiﬁer-free level, ϕ = ϕ(x) translates into
ϕ∗:=

Pθ : ϕ ∈θ, var(θ) = var(ϕ)

;
the translation is compatible with boolean connectives; and existential quan-
tiﬁcation translates into a modal diamond in a natural manner, as in
ϕ = ∃xiψ(x)
−→
ϕ∗= ♦iψ∗.
Note that the modal vocabularies involved are a priori inﬁnite; this can be
avoided if we restrict attention to the k-variable fragment FOk[τ] for ﬁxed k and
ﬁxed ﬁnite relational vocabulary τ. In this case, there are only ﬁnitely many Pθ
corresponding to atomic τ-types in variables x = (x1, . . . , xk); we may restrict
attention to full assignments to all the variables {x1, . . . , xk}, which can be
identiﬁed with An; and we just retain k transition relations Ei for 1 ⩽i ⩽k.
Further natural restrictions to be discussed in section 6.2.3 lead to modal and
guarded logics.
The model checking game
The idea to associate a two-person game with
the semantics of ﬁrst-order logic goes back at least to Lorenz’ and Lorenzen’s
dialogue games [40, 41] between a proponent and an opponent of some asser-
tion. The current interest in these games stems not from foundational issues
but from their algorithmic content, or more precisely from their conceptual
strengths towards the design of efﬁcient model checking algorithms, see, e.g.,
[22, 50].
With formulae ϕ and τ-structures A with partial assignments β we associate
a game played by two players, V (veriﬁer) and F (falsiﬁer) such that the
winning positions in the game determine whether or not A, β |= ϕ.
We present this basic and simple idea in a modular fashion that uses the
transition system of observable conﬁgurations as one constituent of the game
(representing the structure input to the model checking problem). The other
constituent is essentially the syntax tree of the formulae to be checked (repre-
senting the formula input to the model checking problem). For a transparent

Fragments of FO and special classes of structures
283
account of the algorithmic content of this game, and its complexity analysis,
compare [22].
Let  ⊆FO[τ] be a set of negation normal form formulae that is closed
under subformulae (negation normal form restricts the occurrence of nega-
tions to negated atoms). Let S() be the transition system whose universe
is , with transition relations E∨, E∧, E∃xi and E∀xi (i ⩾1) interpreted as
follows.
E∨contains the pairs (ϕ, ϕ1) and (ϕ, ϕ2) for ϕ = ϕ1 ∨ϕ2 ∈; similarly for
E∧;
E∃xi consists of all pairs (ϕ, ψ) for ϕ = ∃xiψ ∈; similarly for E∀xi.
The game graph G := G(A, ) for the  model checking game over A may
then be interpreted in a subsystem of the product system
O(A) × S().
More speciﬁcally, the universe of G(A, ) is the set of all syntactically appropri-
ate assignment/formula pairs, {(β, ϕ): free(ϕ) ⊆dom(β)}. The relevant tran-
sition relations of G(A, ) are
in G(A, )
in O(A)
in S()
E∨:=
id
×
E∨
(disjunctive moves)
E∧:=
id
×
E∧
(conjunctive moves)
Ei,∃:=
Ei
×
E∃xi
(existential moves)
Ei,∀:=
Ei
×
E∀xi
(universal moves)
As atomic predicates we use PV and PF, which partition the universe of
G(A, ) according to:
P G
F =

(β, ϕ): ϕ = ϕ1 ∧ϕ2 or ϕ = ∀xiψ

∪

(β, ϕ): ϕ atomic or negated atomic, A, β |= ϕ

,
P G
V =

(β, ϕ): ϕ = ϕ1 ∨ϕ2 or ϕ = ∃xiψ

∪

(β, ϕ): ϕ atomic or negated atomic, A, β ̸|= ϕ

.
The rules of the game are then simply the following, according to which the
players move a pebble in the game graph G:
– Positions in PV require a move by V :
V moves along any E∨- or Ei,∃-edge (as available in current position);
V loses when stuck for a move.
– Positions in PF require a move by F:
F moves along any E∧- or Ei,∀-edge (as available in current position);
F loses when stuck for a move.

284
Martin Otto
As formula complexity is strictly reduced in each move, all plays are ﬁnite.
Positions in which neither player can move are terminal positions for the game
and the player who ought to move has lost. This happens exactly in positions
associated with atomic or negated atomic formulae, and here the attribution
of these nodes to V and F is such that V wins (because F ought to move) if
A, β |= ϕ, and vice versa. Clearly the game is positionally determined, and the
following is proved by an easy induction on the structure of the formula (or on
the length of the remaining game).
Lemma 6.2.1
The veriﬁer V has a winning strategy in the model checking
game on A precisely in those positions (β, ϕ) for which A, β |= ϕ.
Let us sketch part of the game graph in one tiny example. For a binary
relation R consider the formula ϕ(x) = ∃y

Rxy ∧∀x(Rxx ∨Rxy)

over the
R-structure A with two elements a and b and with R-edges as indicated by
arrows:
a
 b 
The model checking game to determine whether A |= ϕ[a] has positions
(β, ψ) where ψ is one of the subfurmulae of ϕ and β a (partial) assignment
to variables x, y. We may represent β by an {a, b, ·}-word of length 2 and
enumerate the subformulae ψ as ϕ0 := Rxx, ϕ1 := Rxy, ϕ2 = ϕ0 ∨ϕ1, ϕ3 :=
∀xϕ2, ϕ4 := ϕ1 ∧ϕ3 such that ϕ = ∃yϕ4.
(a ·, ∃yϕ4)
V

V












(ab, ϕ1 ∧ϕ3)
F

F

(aa, ϕ1 ∧ϕ3)
F

F

(ab, ϕ1)
(ab, ∀xϕ2)
F

F

(aa, ϕ1)
(ab, ϕ0 ∨ϕ1)
V

V

(bb, ϕ0 ∨ϕ1)
V

V











(ab, ϕ0)
(ab, ϕ1)
(bb, ϕ0)
(bb, ϕ1)
In this partial sketch of the game tree, winning positions for V are underlined.

Fragments of FO and special classes of structures
285
There is a natural variant of the model checking game that does not restrict
formulae to negation normal form. The transition corresponding to the elim-
ination of a negation, say from ¬ϕ to ϕ, corresponds to a swap of players’
roles. Let us therefore call the players neutrally player 1 and player 0. Positions
in the game graph are extended by an extra component ℘∈{0, 1} to indicate
which of the two players acts as veriﬁer; the opponent, ¯℘, correspondingly
acts as falsiﬁer. The two component games, G(A, ) × {0} and G(A, ) × {1}
are each as before (but not insisting on negation normal form formulae, and
with player ℘in the role of V ), and linked by E¬-edges from (β, ¬ϕ, ℘) to
(β, ϕ, ¯℘). E¬-edges prescribe forced moves (for player ℘say, but it does not
matter) from conﬁgurations in which the leading connective of ϕ is a negation.
Then the winning positions of player 1 are those (β, ϕ, ℘) in which either
℘= 1 and A, β |= ϕ or ℘= 0 and A, β ̸|= ϕ.
It is also straightforward to adapt the model checking game to deal with
FO∞rather than FO. E∨and E∧can have inﬁnite out-degree reﬂecting the
syntax of inﬁnitary disjunctions and conjunctions; everything else remains just
the same; in particular plays are still ﬁnite, albeit not necessarily with a uniform
ﬁnite bound.
6.2.2 The comparison game: back and forth
The familiar Ehrenfeucht–Fra¨ıss´e style model comparison games are two player
games played over two structures. A game conﬁguration in these games may be
seen as a pairing between two observable conﬁgurations, one from each struc-
ture. The game is such that the winning positions determine whether or not
(or to which degree) these two observable conﬁgurations are logically indistin-
guishable. We present the basic idea in the slightly non-standard terminology
of (pairings between) observable conﬁgurations in order to highlight the con-
nection between the comparison games and the model checking games. This
point of view will contribute to a rather uniform presentation of fragments via
restrictions imposed at the level of observable conﬁgurations.
The ﬁrst-order Ehrenfeucht–Fra¨ıss´e game
Consider two τ-structures A
and A′ over the same ﬁnite relational vocabulary τ. For partial assignments
β, β′ to the same (ﬁnite) subset of variables (xi)i⩾1 in A and A′, respectively,
we write
A, β ≡q A′, β′
for FO-equivalence up to quantiﬁer-rank q, i.e., A, β |= ϕ ⇔A′, β′ |= ϕ for
all ϕ ∈FO[τ] such that free(ϕ) ⊆dom(β) = dom(β′) and qr(ϕ) ⩽q. If A and

286
Martin Otto
A′ are clear from the context, we also write just
β ≡q β′.
The coarsest of these equivalences, A, β ≡0 A′, β′ corresponds to a local
isomorphism: π : β(i) →β′(i) for i ∈dom(β) = dom(β′) being an isomor-
phism between the induced substructures A↾image(β) and A′↾image(β′), which
is the same as equality of quantiﬁer-free types.
Elementary equivalence, A, β ≡A′, β′, without the restriction on quantiﬁer-
rank, is similarly deﬁned. Note that ≡is the limit (coarsest common reﬁnement)
of the approximations (≡q)q∈ω.
Further, A, β ≡∞A′, β′ stands for equivalence w.r.t. inﬁnitary logic FO∞.2
The ﬁrst-order Ehrenfeucht–Fra¨ıss´e game over A and A′ is played by two
players, whom we call player I and player II. We describe the game protocol
in terms of rounds, each round consisting of an exchange of moves: challenge
by I/response by II.
The game board: positions. Positions between rounds are pairs (β, β′) of assign-
ments to the same ﬁnite subset of variables (xi)i⩾1. Only locally isomorphic
assignments will be admissible for player II; we speak of sound positions:
Sound positions. Position (β, β′) is sound if A, β ≡0 A′, β′, i.e., if the corre-
spondence β(i) →β′(i) describes a local isomorphism. In terms of O(A) and
O(A′): β ∈Pθ ⇔β′ ∈Pθ for all atomic θ.
Single round and overall protocol. A single round consists of a chal-
lenge/response exchange of moves as follows. In position (β, β′),
– I chooses i ⩾1 and makes a move
 either along an Ei-edge in O(A) from β,
or along an Ei-edge in O(A′) from β′.
– II must make a move along an Ei-edge in the opposite structure.
This exchange of moves results in an overall transition from position (β, β′)
to some successor position (γ, γ ′), where γ = β a
i for some a ∈A and γ ′ =
β′ a′
i for some a′ ∈A′.
We distinguish different levels of the game according to how many rounds
are played.
The q-round game Gq(A; A′) (for ﬁxed q ∈ω): play continues from an initial
position through q rounds (or until a position is reached that is not sound).
2 Equivalence up to quantiﬁer-rank α in FO∞can be deﬁned, for every ordinal α. For ﬁnite
relational vocabularies, ≡coincides with ≡ω, equivalence up to quantiﬁer-rank ω in FO∞.
Note, however, that ﬁnitary and inﬁnitary ﬁrst-order equivalences do not coincide even at
quantiﬁer-rank 1 for inﬁnite relational vocabularies.

Fragments of FO and special classes of structures
287
The ﬁnite-round game Gω(A; A′): in the initial position, player I ﬁrst selects
some q ∈ω, then play continues in Gq(A; A′) from the initial position.
The inﬁnite game G∞(A; A′): play continues through an inﬁnite number of
rounds (or until a position is reached that is not sound).
In each variant, II loses as soon as the position is not sound. Maintaining
soundness of the evolving position is in fact the only commitment for II: II
wins the q-round game Gq after completion of round q if this ﬁnal position
is sound; similarly II wins the ﬁnite-round game Gω if she wins Gq for the
q initially selected by I; and she wins the inﬁnite game G∞if play continues
indeﬁnitely without violation of soundness.3
In all of these games we typically also specify the initial position as
in Gq(A, β; A′, β′). For instance, we say that II has a winning strategy in
Gq(A, β; A′, β′) if (β, β′) is a winning position for player II in Gq(A; A′) (or
in Gq(A, β; A′, β′)).
It is obvious that plays of Gq and Gω are ﬁnite and end in a position in which
one of the players has won; hence Gq and Gω are positionally determined. But
also G∞is rather easily shown to be positionally determined, without recourse
to deeper results from game theory, as part of the model theoretic analysis
underpinning the following theorem. The core of this well-known analysis can
be summarised as follows.
Theorem 6.2.2 (Ehrenfeucht–Fra¨ıss´e and Karp)
For all structures of the same
ﬁnite relational vocabulary, A and A′, winning positions in games characterise
levels of ﬁrst-order equivalence in the sense of the following equivalences.
(a) (β, β′) is a winning position for II in Gq(A; A′) if, and only if, A,
β ≡q A′, β′.
(b) (β, β′) is awinningpositionfor II in Gω(A; A′) if, and only if, A, β ≡A′, β′.
(c) (β, β′) is a winning position for II in G∞(A; A′) if, and only if, A,
β ≡∞A′, β′.
We sketch the game-oriented skeleton of the underlying arguments in their
most rudimentary form to highlight this aspect (and deliberately ignoring some
of the logical niceties, like characteristic formulae, which the more thorough
analysis presented in textbooks typically yields).
(i) For the direction from left to right, one shows that logical inequivalence
yields a winning strategy for player I. This follows from the observation that I
3 Clearly a variant formulation to essentially the same effect would restrict the game board to
sound positions right away, making II lose when she is stuck for a response. This formulation,
however, has the slight disadvantage of restricting us to sound initial positions, too.

288
Martin Otto
can choose his challenge in a single round from a sound position such that, no
matter what response II chooses, the resulting position is logically inequivalent
at a lower quantiﬁer-rank.
Why is that? A glance at the model checking game helps to illustrate the
point. For instance, if β ̸≡m+1 β′ (but β ≡0 β′), then this inequivalence mani-
fests itself in some formula ∃xiψ with ψ of quantiﬁer-rank at most m. Suppose
w.l.o.g. that A, β |= ∃xiψ while A′, β′ |= ∀xi¬ψ. Then a good move for the
veriﬁer in position (β, ∃xiψ) in the model checking game over A obviously
makes a good move for I in this game.4
(ii) In the opposite direction, player II always has a strategy, for her response
to I’s challenge in a single round, to maintain the required level of logical
equivalence. For instance towards (a) or (b), for a challenge γ = β a
i in a
position (β, β′) such that β ≡m+1 β′, II can ﬁnd a′ ∈A such that β a
i ≡m β′ a′
i .
Otherwise, there would have to be a distinguishing formula ψa′ of quantiﬁer-
rank m for every choice of a′ ∈A′, such that A, β a
i |= ψa′ while A′, β′ a′
i ̸|= ψa′.
But then the formula ∃xi

a′ ψa′ would distinguish β and β′ at quantiﬁer-rank
m + 1.
If the underlying structures (and hence the branching degree of the transition
systems of observable conﬁgurations) are inﬁnite, this argument crucially uses
the fact that, for a ﬁxed tuple of free variables there are only ﬁnitely many
formulae of quantiﬁer-rank m over a ﬁxed ﬁnite relational vocabulary, up to
logical equivalence – this is what brings ∃xi

a′ ψa′ into ﬁrst-order, even if A′
is inﬁnite.5 We note that the corresponding claims in (a) and (b) of the theorem
actually fail for inﬁnite relational vocabularies, even over ﬁnite structures. For
(c) on the other hand, to which the above argument is readily adapted, ﬁniteness
(of the conjunction or of the vocabulary) is not essential.
The equally familiar description in terms of back-and-forth systems corre-
sponds to a delineation of a winning region for II with the appropriate closure
conditions (the back-and-forth conditions) that guarantee that player II has
responses to keep the game within the prescribed region, against all challenges
by I. The essential difference between the ﬁnite and the inﬁnite game is that, in
the ﬁnite games, winning regions are stratiﬁed according to how many rounds
are still to be survived. The winning region for the inﬁnite game, on the other
4 Entirely analogous reasoning applies towards (c) and for inequivalence in FO∞, w.r.t. its
ordinal-valued quantiﬁer-rank.
5 While this is easily proved by induction on quantiﬁer-rank, these preparatory considerations are
clearly not even required for the argument if we deal just with ﬁnite models.

Fragments of FO and special classes of structures
289
hand, is static, corresponding to an invariant that needs to be maintained indef-
initely (this is the classical notion of back-and-forth equivalence or partial
isomorphism in model theory, see for instance [30]).
Example 1: ﬁnite linear orderings
The ﬁrst example illustrating the use-
fulness of the ﬁrst-order Ehrenfeucht–Fra¨ıss´e game in almost any textbook
presentation concerns the limitations of FO in expressing properties of ﬁnite
linear orderings (or discrete linear orderings more generally). We just state the
following well-known result in order to stress its technical afﬁnity with simple
locality based arguments to be considered later.
Lemma 6.2.3
Consider two ﬁnite linear orderings A = (N, <)↾[0, m] and
A′ = (N, <)↾[0, m′] with assignments to tuples
β = n = (n0, . . . , nk) where 0 = n0 < n1 < · · · < nk−1 < nk = m and
β′ = n′ = (n′
0, . . . , n′
k) where 0 = n′
0 < n′
1 < · · · < n′
k−1 < n′
k = m′.
We write di := ni+1 −ni and d′
i := n′
i+1 −n′
i for distances between consec-
utive points in these assignments. Then the following are equivalent for any
q ⩾1:
(i) A, β ≡q A′, β′
(ii) for 0 ⩽i < k: di = d′
i or both di, d′
i ⩾2q.
For the naked ﬁnite linear orderings one obtains that
A ≡q A′
⇐⇒
|A| = |A′| or |A|, |A′| ⩾2q −1.
For (ii) ⇒(i) in the lemma, consider the ﬁrst round in a game played
from a position satisfying the distance constraints (ii) with critical distance 2q.
It sufﬁces to exhibit a strategy for player II to respond to any challenge by
player I in such a manner that the resulting position satisﬁes the analogous
distance constraints (ii), but now with critical distance 2q−1 instead of 2q.
W.l.o.g. we may assume that I extends the conﬁguration β by some new
element n ∈Ii = (ni, ni+1). The case that I plays in A′ instead is symmetric.
In case di = d′
i (the pair of intervals concerned have exactly the same length),
II may select an element n′ ∈I ′
i = (n′
i, n′
i+1) at precisely the same distances
from the end points in I ′
i as n has in Ii; the resulting position even satisﬁes the
distance constraints with critical distance 2q again.

290
Martin Otto
In the more interesting case, we have di ̸= d′
i but di, d′
i ⩾2q. We consider
cases, as to the sub-division of the interval Ii = (ni, ni+1) by n:
di 2q
<2q−1
one part small/
one large
2q−1
both parts
large
2q−1
2q−1
ni
ni+1
n
ni
ni+1
n
As the distances of n from the end points of Ii add up to di, at most one of
these distances can be less than 2q−1; if one distance is ‘small’ in this sense,
II may copy this distance exactly to ﬁnd a matching n′ ∈I ′
i (the other distance
will automatically be ‘large’, i.e., ⩾2q−1 just as on the side of Ii); if both
distances are at least 2q−1, then II similarly ﬁnds n′ ∈I ′
i which is at least that
far from both end points of I ′
i.
It is a nice exercise to formalise sentences in quantiﬁer rank q that, over
ﬁnite linear orderings, require at least 2q −1 elements, thus showing that the
given bounds are tight.
It is also useful to draw on the compositionality of strategies for II w.r.t.
concatenation of linearly ordered intervals (slightly more generally, strategies
for player II are compatible with ordered sums of linearly ordered structures in
an otherwise monadic vocabulary; or with concatenation of word structures).
The implicit decomposition of the game into subgames on intervals in the above
strategy considerations reﬂects this.
Remark
The above game argument illustrates the well-known fact that, for
instance, no FO sentence can distinguish even length from odd length ﬁnite
linear orderings. Any sentence ϕ proposed for the purpose is defeated by the
example of linear orderings of lengths 2q and 2q −1 for q := qr(ϕ).
Maybe somewhat unexpectedly (and disturbing only from a didactic point
of view), this particular ﬁnite model theory assertion can also be shown by
classical means. Suppose there were a sentence ϕ ∈FO[<] such that a ﬁnite
linear ordering satisﬁes ϕ if, and only if, it is of even length. Let [ϕ]⩽x be
the relativisation of ϕ to the initial segment formed by x. Let ψ0 ∈FO[<] be
the usual characterisation of discrete linear orderings with ﬁrst and without
last element; ψ1 ∈FO[<] the assertion that precisely every other element x

Fragments of FO and special classes of structures
291
satisﬁes [ϕ]⩽x. Then ψ0 ∧ψ1 would characterise the order type of (ω, <),
which is impossible by compactness. To see that ψ0 ∧ψ1 forces the standard
model, consider any non-standard model (A, <) of ψ0 as in the sketch. Since
the non-standard part of (A, <) consists of an ordered sum of parts ordered
like (Z, <), the successor operation induces an automorphism of the non-
standard part. Therefore [ϕ]⩽x cannot distinguish next neighbours within the
non-standard part, and (A, <) ̸|= ψ0 ∧ψ1.

(ω,<)

· · ·

succ
−→

· · ·
This argument immediately also shows that the unary predicate P consisting
of every other element of a ﬁnite linear ordering and starting with the minimal
element cannot be explicitly deﬁnable in FO[<] over the class of all ﬁnite linear
orderings. Since the given speciﬁcation of P translates into an obvious implicit
deﬁnition in FO[<, P], the example directly refutes the ﬁnite model theory
analogue of Beth’s theorem. In this light, the given automorphism argument
just shows that the implicit deﬁnition of P over ﬁnite linear orderings does
not extend to any implicit deﬁnition that would be good over the class of all
discrete linear orderings with ﬁrst element.
Example 2: a simple locality argument
(also compare section 6.2.5) Let τ
be a ﬁnite relational vocabulary. A formula ϕ(x) ∈FO[τ] is called ℓ-local if,
in any τ-structure A, whether A |= ϕ[a] is fully determined by A↾Nℓ[a] (the
ℓ-neighbourhood of a):
A |= ϕ[a]
⇔
A↾N ℓ[a] |= ϕ[a].
Similarly ϕ(x) is invariant under disjoint unions if for all A, a and B,
A |= ϕ[a]
⇔
A ⊕B |= ϕ[a],
where A ⊕B is the disjoint union of A and B.
Lemma 6.2.4
If ϕ ∈FO[τ] is invariant under disjoint unions, then ϕ is ℓ-local
for ℓ= 2qr(ϕ) −1.
Remark: the bound on ℓis optimal, since there is, for every q, a quantiﬁer-
rank q formula ϕq(x) ∈FO[E, P ] asserting that N2q−1(x) ∩P ̸= ∅.6
Proof. Let ϕ be invariant under disjoint unions, q := qr(ϕ) and ℓ:= 2q −
1. For a ∈A and A0 := A↾Nℓ(a) it sufﬁces to show that A |= ϕ[a] iff
6 One obtains ϕq(x) inductively, based on ϕq+1(x) := ∃y(d(x, y) ⩽2q ∧ϕq(y)).

292
Martin Otto
A0 |= ϕ[a]. By invariance under disjoint unions, moreover, it sufﬁces to estab-
lish an equivalence of the form A, a ⊕C ≡q A0, a ⊕C for a suitable structure
C. Taking C to be the disjoint union of q further disjoint isomorphic copies
each of A and of A0, we argue this equivalence:


◦
· · · 

◦
!
"#
$
q copies of A
a
A


•
	


◦
· · · 	


◦
!
"#
$
q copies of A0
≡q


◦
· · · 

◦
!
"#
$
q copies of A
a
A0
	


•
	


◦
· · · 	


◦
!
"#
$
q copies of A0
In the game on these structures, II wins the q-round game as follows. We use
dm := 2q−m as a critical distance to be observed in round m. II is to play such
that the conﬁgurations resulting from round m are linked by a component-wise
trivial isomorphism between their (dm −1)-neighbourhoods. This condition is
satisﬁed at the start, for m = 0; for m = q it still guarantees a local isomorphism
between the ﬁnal conﬁgurations, hence a win for II.
Here is how to maintain the condition through round m of the game for
m ⩾1:
(i) if I’s challenge goes to some element at distance greater than dm from
the current conﬁguration, then II responds with the same element in a new
isomorphic component on the opposite side (new in the sense of not yet involved
in the current conﬁguration; such are always left).
(ii) if I’s challenge goes to an element within distance dm of the cur-
rent conﬁguration, then II ﬁnds a response via the trivial local isomor-
phism between the (dm−1 −1)-neighbourhoods of the current conﬁgurations.
We note that d(x, y) ⩽dm implies Ndm−1(y) ⊆Ndm−1−1(x), as d(x, z) ⩽
d(x, y) + d(y, z) ⩽dm + dm −1 = dm−1 −1.
6.2.3 Natural restrictions/variations
Several of the most natural fragments of FO can be presented in terms of
restrictions or modiﬁcations of the system O(A) of observable conﬁgurations

Fragments of FO and special classes of structures
293
associated with structure A. The k-variable fragment FOk of FO, for instance,
exactly corresponds to the restriction that only up to k elements of A are
“simultaneously observable” – we just need to restrict the assignments to size
k. While this is a uniform, purely quantitative restriction, the modal and guarded
fragments of ﬁrst-order logic are based on structural, qualitative restrictions.
In the guarded fragment GF, access to observable conﬁgurations is restricted
by the requirement that the target conﬁguration be guarded, i.e., covered by
some relational ground atom (which is explicitly reﬂected in the syntax of
guarded quantiﬁcation). In the more basic modal fragment ML of FO, A itself
is the system of observable conﬁgurations – in this case the transition relations
between the (trivial, one-point) conﬁgurations are the key to the restrictions
imposed in modal quantiﬁcation. Below we treat k-variable logic, guarded
logic and modal logic in this order of increasing specialisation, with particular
emphasis on modal logic and its comparison game, the bisimulation game.
The k-variable fragment and the k-pebble game
The k-variable fragment FOk ⊆FO in a relational vocabulary τ consists of all
ﬁrst-order formulae in which only the variable symbols x1, . . . , xk occur, bound
or free. Assignments over τ-structures A can thus be restricted and normalised
to be full assignments to these k variables. We therefore identify assignments
with k-tuples.
Correspondingly, let Ok(A) be the restriction of O(A) to {β : |β| = k} = Ak.
It is easy to see that the restriction of both the model checking game and
of the comparison game that ensues if O(A) is consistently replaced with
Ok(A) are adequate for the semantics of FOk and for the induced notions of
k-variable equivalence. The k-variable Ehrenfeucht–Fra¨ıss´e game is just the k-
pebble game: moves along Ei-edges in Ok(A) correspond to the re-positioning
of the i-th pebble on A. The correspondence between the different levels of
the game and of k-variable equivalence are the following, for ﬁnite relational
vocabularies τ:
≡k
q
: FOk-equivalence up to quantiﬁer-rank q;
captured by the q-round k-pebble game Gk
q.
≡k : FOk-equivalence;
captured by the ﬁnite-round k-pebble game Gk
ω.
≡k
∞: FOk
∞-equivalence;
captured by the inﬁnite k-pebble game Gk
∞.
It is important to note that Ok(A) is of ﬁnite type for each ﬁnite τ, and
of polynomial size in the size of A, for ﬁnite A. For the model checking

294
Martin Otto
implications see [23, 22] and also some related remarks in section 6.5.1. In
particular, the combined model checking complexity for FOk is complete for
Ptime, while for FO it is complete for Pspace.
The guarded fragment and the guarded bisimulation game
The characteristic feature of the guarded fragment GF of ﬁrst-order logic [2] is
the relativisation of ﬁrst-order quantiﬁcation to guarded tuples – similar to the
restriction along accessibility edges in modal logic. Also compare the remarks
in section 6.1.2 where GF was introduced as a fragment of FO.
We start out with a discussion of a very liberal setting for the guarded
fragment that most naturally reﬂects the syntactic freedom allowed in the
standard formalisation of GF as given in section 6.1.2. Afterwards we also
indicate some more succinct alternative formulations that correspond to certain
syntactic normalisations (e.g., regarding the number of variables used) to which
GF can be subjected without impairing its expressive power; such less liberal
formalisations can be of technical advantage in the model theoretic analysis of
GF and its relatives.
Recall that a subset s ⊆A is guarded in the τ-structure A if it is a
singleton set or, if for one of the relations R ∈τ there is some tuple
a = (a1, . . . , ar) ∈RA for which s = [a].7 In particular, the cardinality of
guarded subsets is bounded by the width of the vocabulary τ. A tuple b in
A is called guarded if [b] ⊆s for some guarded subset s. The same terminol-
ogy applies to assignments β in A.
Call a tuple b or an assignment β in A strictly guarded if [β] is itself a guarded
subset. More speciﬁcally, for an atomic τ-formula α, we say the assignment β
is strictly guarded by α if var(α) = dom(β) and A, β |= α, which implies that
[β] is indeed a guarded subset. (In order to capture also guarded singleton sets,
we allow α to be an equality atom.)
A system of observable conﬁgurations for GF
We work with the following
system of observable conﬁgurations OG(A) over the set of all ﬁnite (partial)
assignments over A with new binary transitions relations Eα,ρ (see below) and
unary predicates Pθ (as before). The universe of OG(A) is the same as in O(A)
for FO (this is for the liberal, redundant formalisation).
The transition relations of OG(A) describe passages from some assignment
β to a new assignment β′ where the target assignment β′ is required to be
strictly guarded by some atomic formula α. Each transition relation speciﬁes
7 Recall that we denote as [b] the set of components of a tuple b, and similarly write [β] for the
image set of an assignment β.

Fragments of FO and special classes of structures
295
both the atomic formula α and a set of identities between components of the
old and the new assignment. As both β and β′ are ﬁnite partial functions on the
positive integers, a set of identities between components can be speciﬁed as a
ﬁnite set ρ of pairs of positive integers. We write β
ρ= β′ if β(i) = β′(j) for
all (i, j) ∈ρ. Then for every ρ and α, let Eα,ρ be interpreted as the following
transition relation on OG(A):
Eα,ρ =

(β, β′): β
ρ= β′, β′ strictly guarded by α

.
Unary predicates Pθ for atomic types θ(x) are as in the basic system O(A).
Guarded model checking
The game graph for the model checking of for-
mulae in GF is obtained from OG(A) and a suitable formalisation of the syntax
of guarded quantiﬁcation in close analogy to the basic case. With the formation
rule of existential guarded quantiﬁcation, for instance,
ϕ(x) = ∃y(α(x′) ∧ψ(x′)),
where y is a subtuple of x′, associate an Eα,ρ,∃-edge in the syntax tree from
ϕ(x) to ψ(x′), where ρ = {(i, j): xi = x′
j}. In the game graph GG(A, ),
correspondingly, there are Eα,ρ,∃-edges from positions (β, ϕ(x)) to positions
(β′, ψ(x′)) such that x ⊆dom(β), x′ ⊆dom(β′), (β, β′) ∈Eα,ρ in OG(A). Sim-
ilarly, universal guarded quantiﬁcations ϕ(x) = ∀y(α(x′) →ψ(x′)) give rise to
edges in Eα,ρ,∀in the syntax tree, and induce transition relations EG
α,ρ,∀in
GG(A, ).
Note that existential and universal quantiﬁcation of variables in GF pro-
ceeds in batches (so as to cover a guarded successor set fully in one step) rather
than element-wise. Correspondingly, ﬁrst-order quantiﬁer-rank is replaced by
the nesting depth of guarded quantiﬁcation steps for an appropriate analy-
sis of quantiﬁer complexity. This is important for the induced levels of GF
equivalence, which are considered in connection with the comparison game of
guarded bisimulation below.
Guarded bisimulation
In line with the general idea, positions between
rounds in the guarded Ehrenfeucht-Fra¨ıss´e game GG(A, A′) are matching pairs
of assignments (β, β′) in A and A′. With the possible exception of the initial
position of the game, which we choose to ignore in the following, we may
restrict attention to positions in which both β and β′ are strictly guarded (this
is guaranteed for successor positions after the ﬁrst round, by the rules below).
Soundness means that the induced correspondence β(i) →β′(i) for i ∈
dom(β) = dom(β′) is a local isomorphism; insofar as the assignments are
strictly guarded in their structures, the correspondence is a bijection between

296
Martin Otto
guarded subsets and thus a local isomorphism between induced substructures
on guarded subsets s = [β] and s′ = [β′]. Challenge/response pairs of moves
responsible for taking the game through a single round are governed by I’s
selection of an Eα,ρ and an Eα,ρ successor γ of β in OG(A) or an Eα,ρ
successor γ ′ of β′ in OG(A′), and thus, together with II’s response, to a new
local isomorphism between substructures induced on a new pair of guarded
subsets t = [γ ] and t′ = [γ ′] (insofar as the successor position is sound again,
i.e., unless II has lost).
A conceptually smoother, equivalent formulation therefore is the follow-
ing, which we take as the preferred description of the guarded bisimulation
game. Positions in the game are local bijections σ : s →s′ between guarded
subsets s ⊆A and s′ ⊆A′. In a single round played from position σ : s →s′,
I proposes either a guarded subset t ⊆A or a guarded subset t′ ⊆A′; II has to
respond with a guarded subset in the opposite structure (call this other subset
t′ ⊆A′ or t ⊆A, as the case may be) and a bijection ρ : t →t′ that is compat-
ible with σ. Compatibility of ρ with σ means that ρ needs to agree with σ on
s ∩t if I chose t; and on s′ ∩t′ if I chose t′. II loses if there is no such ρ or if
ρ is not a local isomorphism.
Either formulation of the game supports the usual analysis, which, as
expected, establishes correspondences between winning positions for II in
the different levels of the game and equivalence in GF. For ﬁnite relational
vocabularies τ these are:
≡G
q
: GF-equivalence up to guarded nesting depth q;
captured by the q-round guarded bisimulation game GG
q .
≡G : GF-equivalence;
captured by the ﬁnite-round guarded bisimulation game GG
ω.
≡G
∞: GF∞-equivalence;
captured by the inﬁnite guarded bisimulation game GG
∞.
More succinct representations
Another, much more succinct view on the
observable conﬁgurations can be based on more restricted classes of assign-
ments: it essentially sufﬁces to admit strictly guarded assignments with domain
{1, . . . , k} where k is the width of τ. This second aspect corresponds to the nor-
malisation of variables to x1, . . . , xk as in FOk.8 Here we use strictly guarded
assignments to variables x1, . . . , xk, or surjective partial maps from {1, . . . , k}
onto guarded subsets of A.
8 Even more restrictively, [25] for technical convenience uses a format with only injective
assignments, there called guarded lists.

Fragments of FO and special classes of structures
297
The type of the resulting system of guarded observable conﬁgurations is
ﬁnite for ﬁnite τ. The model checking game obtained in analogy with the
above, by making the obvious changes and restrictions regarding the syntax of
formulae, then really is for (a speciﬁc syntactic variant of) GFk := GF ∩FOk.
A closer analysis of the Ehrenfeucht–Fra¨ıss´e games and notions of guarded
equivalence resulting from the two different formalisations would show that
there is no loss of expressiveness as far as properties of (strictly) guarded
tuples are concerned. The only real restriction concerns expressiveness at the
quantiﬁer-free level and in boolean combinations, and this is inessential for
many purposes. The difference arises, trivially, because GF does not impose any
restrictions on boolean combinations. Analysis of the game shows, however,
that any formula of GF (in the liberal format) is logically equivalent to a boolean
combination of quantiﬁer-free formulae and strictly guarded formulae (each of
which can, up to a necessary renaming of variables, be formalised in the above
fragment GFk).
Corollary 6.2.5
Any formula in GF[τ] with explicitly guarded free variables
is equivalent to a formula in GF ∩FOk where k is the width of τ.
The modal fragment and the bisimulation game
Modal logic is naturally interpreted over transition systems (Kripke structures
in traditional terminology). Having chosen a modal perspective for our analysis
of fragments, we may now choose the transition system A itself – as a relational
structure in a given vocabulary τ with binary relations Eα and unary predicates
Pj – as the system of modally observable conﬁgurations, putting OM(A) =
A. To keep in line with the general framework we may want to replace the
individual Pj in A by Pθ that are complete propositional types in the pj/Pj (in
ﬁrst-order terms: atomic Pj-types in single variables x, containing for each Pj
either the atomic formula Pjx or its negation ¬Pjx).
Modal model checking
The modal model checking game over structure A is
played in a game graph based on A and the syntax tree of the modal formulae
under consideration. With the formation rule of existential modal quantiﬁcation
ϕ = ♦αψ
we associate an E♦α edge in the syntax tree from ϕ to ψ. In the game graph
GM(A, ), this induces edges from positions (a, ϕ) to positions (b, ψ) for
(a, b) ∈EA
α . Analogously for □α quantiﬁcation: edges in E□α from ϕ = □αψ
to ψ in the syntax tree give rise to transitions in GM(A, ) from (a, ϕ) to (b, ψ)
for every (a, b) ∈EA
α .

298
Martin Otto
It is clear that the model checking game for FO2 emulates the modal model
checking game, via the standard translation of ML into FO2:
(♦αψ)x =
∃y(Eαxy ∧ψy),
(□αψ)x = ∀y(Eαxy →ψy),
where {x, y} = {x1, x2}. In terms of this translation, a move along an Eα edge
(a, b) in the A component of GM(A, ) is simulated by an E2 move from any
position of the form (a, ∗) to (a, b) or by an E1 move from any (∗, a) to (b, a) in
the O2(A) component of G2(A, FO()). At the same time this emulation can be
interpreted in GG(A, FO()), since {a, b} is a strictly guarded assignment and
(a, a) is linked to (a, b), for instance, by an Eα,ρ edge in O2(A) for ρ = {(1, 1)}.
Bisimulation
The bisimulation game is the Ehrenfeucht–Fra¨ıss´e game for
modal logic. It also has a special status because of its fundamental nature as
the quintessential back-and-forth game – game equivalence of game graphs –
to be discussed in the following section.
In line with the general approach, the positions (between rounds) in
GM(A, A′) are pairs of observable conﬁgurations in O(A) = A and O(A′) = A′,
i.e., pairs (a, a′) ∈A × A′. The challenge/response exchange that constitutes a
single round is as follows:
– I selects a transition relation Eα, and
 either some Eα successor b of a in A,
or some Eα successor b′ of a′ in A′.
– II has to respond by selecting an Eα successor in the opposite structure.
Overall this results in a successor position (b, b′) for which (a, b) ∈EA
α and
(a′, b′) ∈EA′
α . A position (a, a′) is sound if a and a′ satisfy exactly the same
predicates Pj (atomic propositions pj in modal terminology), which clearly
corresponds to quantiﬁer-free indistinguishability in ML[τ].
Because of their immediate importance we introduce the usual dedicated
notation for the levels of equivalence that are deﬁned in terms of winning
positions for player II in the different levels of this bisimulation game. As
above, the q-round, ﬁnite-round, and inﬁnite bisimulation game on A and A′
are denoted GM
q (A, A′), GM
ω (A, A′), and GM
∞(A, A′). We then deﬁne
A, a ∼q A′, a′
iff
(a, a′) is a winning position for II in GM
q (A, A′);
A, a ∼ω A′, a′
iff
(a, a′) is a winning position for II in GM
ω (A, A′);
A, a ∼A′, a′
iff
(a, a′) is a winning position for II in GM
∞(A, A′).
Note that ∼is the classical notion of bisimulation equivalence – equivalence
w.r.t. the inﬁnite bisimulation game, and as such the modal counterpart of partial
isomorphism.

Fragments of FO and special classes of structures
299
We denote the relevant levels of equivalence in modal logic as ≡M
q (up
to modal nesting depth q), ≡M (full equivalence in ﬁnitary ML), and ≡M
∞
(equivalence in the inﬁnitary extension ML∞). The associated Ehrenfeucht–
Fra¨ıss´e and Karp theorems then state, for ﬁnite modal vocabularies τ, the
following equivalences:
A, a ∼q A′, a′
⇔
A, a ≡M
q A′, a′.
A, a ∼ω A′, a′
⇔
A, a ≡M
ω A′, a′.
A, a ∼A′, a′
⇔
A, a ≡M
∞A′, a′.
Modal variations
The simple extensions of basic modal logic by inverse
modalities and/or global modality, ML
−, ML
∀and ML
−∀, are matched by cor-
responding variations in O(A) and G(A, A′). To deal with inverse modal-
ities, O(A) is enriched with the converse relations to the Eα, (E−
α )A =
{(b, a): (a, b) ∈EA
α }; to deal with the global modality, O(A) is expanded
by the full binary relation U A = A × A. Everything else, including associ-
ated Ehrenfeucht–Fra¨ıss´e and Karp theorems, is then set up by straightforward
analogy and we leave the details as an exercise. For later use, we denote the
levels of two-way global bisimulation equivalence corresponding to the com-
bined extension by inverse modalities and the global modality by ≈q, ≈ω
and ≈.
Bisimulations as relations and back-and-forth systems
We also want to
use the notational variants corresponding to back-and-forth systems for bisim-
ulation games. Inﬁnitary bisimulation equivalence (the modal counterpart of
partial isomorphism) between the nodes of two structures A and A′, in par-
ticular, is captured by the relation Z ⊆A × A′ comprising exactly the win-
ning positions for II in GM
∞(A, A′) (known as the largest bisimulation relation
between A and A′, cf. [9, 17]). Any other relation Z ⊆A × A′ that delineates
an appropriately closed winning region for II is also a bisimulation relation,
and necessarily a subset of the largest such. Corresponding ﬁnite bisimulation
levels are described by stratiﬁed back-and-forth systems in the usual manner.
Again, natural and straightforward adaptations for, e.g., two-way global bisim-
ulations are obtained. The difference lies in the closure conditions (back-and-
forth conditions), which reﬂect the nature of the challenges that I is allowed,
since II must have responses to all of them within the prescribed collection of
positions.
A particular variant of bisimulation relationships is realised by homomor-
phisms whose graphs are bisimulation relations (bounded morphisms in clas-
sical modal terminology, cf. [9, 17]). For instance, in the case of the two-way

300
Martin Otto
global bisimulation relation ≈, we write
π : A, a
≈
−→A′, a′
to indicate that π : A →A′ is a map sending a to a′ and such that its graph is
a bisimulation relation with the back-and-forth closure conditions appropriate
for global two-way bisimulation game (in particular π needs to be a surjective
homomorphism).
Saturation and Hennessy–Milner properties
We shall later look at the
relationship between equivalence w.r.t. the inﬁnite game G∞and the ﬁnite
approximations to the ﬁnite-round game Gω induced by the q-round games
(Gq)q∈ω also for games other than bisimulation. It is therefore interesting to
understand under which conditions there is no gap between the limit of the
ﬁnite approximations and full inﬁnitary equivalence. In the modal situation,
or for the bisimulation game, this situation is particularly transparent, and at
the same time holds the key to the general situation for other fragments in the
game-oriented analysis.
Deﬁnition 6.2.6
Let A be a τ transition system with transition relations Eα.
(i)  ⊆ML[τ] is called a ♦α-type at a ∈A if A, a |= ♦α
 0 for every
ﬁnite 0 ⊆; it is realised at a ∈A if there is some b such that (a, b) ∈
EA
α and A, b |= .
(ii) A is called modally saturated if, for all α and all a ∈A, every ♦α-type at
a is realised at a.
It is not hard to see that ω-saturated transition systems, and in particular
ﬁnite transition systems are modally saturated. But a very simple argument also
shows that even all ﬁnitely branching transition systems are modally saturated.
In the case of a structure A that is ﬁnitely branching (w.r.t. Eα) at a, consider
some ♦α-type  at a. Suppose  were not realised at a. This means that, for
every Eα successor b of a there must be some ϕb ∈ not satisﬁed at b. But
then the ﬁnite subset 0 of these ϕb would violate the deﬁning condition for a
♦α-type at a: A, a |= □α

b ¬ϕb, whence A, a ̸|= ♦α
 0.
For this and also for the reasoning behind the lemma below, compare part (ii)
of the argument indicated in connection with Theorem 6.2.2.
Deﬁnition 6.2.7
A class of transition systems has the Hennessy–Milner
property if over this class, modal equivalence ≡M coincides with full bisimu-
lation ∼.

Fragments of FO and special classes of structures
301
Note that, since even for not necessarily ﬁnite vocabularies τ, ∼ω implies
≡M, the Hennessy–Milner property implies that in particular also ﬁnite bisimu-
lation equivalence coincides with full bisimulation equivalence. The following
lemma also implies that for modally saturated transition systems, modal equiv-
alence, ﬁnite and full bisimulation equivalence all fall into one, even for inﬁnite
vocabularies.
Lemma 6.2.8
The class of modally saturated transition systems has the
Hennessy–Milner property.
The straightforward game argument for this is again suggested by the rea-
soning underlying Theorem 6.2.2, part (ii), but ﬁniteness of τ is not required.
Playing over modally saturated structures, II can maintain modal equivalence
between conﬁgurations. Consider a position (a, a′) in the game GM
∞(A, A′) for
which A, a ≡M A′, a′, and think of a challenge played by I, with a move along
(a, b) ∈EA
α say. In general (and even for ﬁnite vocabulary) modal equivalence
A, a ≡M A′, a′ (or even A, a ∼ω A′, a′) would only provide II with responses
b′ that are good for surviving q further rounds, where this could be a separate
response for each individual q. Now, however, the full modal theory of b in
A constitutes a ♦α-type at a in A, and modal equivalence A, a ≡M A′, a′ is
good enough to ensure that it therefore also is a ♦α-type at a′ in A′. By modal
saturation, therefore, this ♦α-type is realised at a′ in A′, and any such realisation
gives II a valid response in the game which maintains ≡M. But maintaining ≡M
equivalence throughout the game, II cannot lose; so this gives her a strategy
in GM
∞.
6.2.4 Bisimulation as the master game
An analysis of whole families of fragments of FO w.r.t. their notions of ﬁnite
and inﬁnitary equivalence can very nicely be based on the analysis of the
bisimulation game over the transition systems of observable conﬁgurations
associated with the particular fragment.
The possible advantage of this perspective lies in the conceptual separation of
the game theoretic commonality, which is here uniformly described in terms of
bisimulation, and the particular constraints of the fragment under consideration,
which enters the picture through the right formalisation of the observable
conﬁgurations. The natural criterion for the right formalisation lies in the
adequacy of the induced model checking game for the semantics of the given
fragment.
The treatment of FO and fragments like FOk, GF and ML (and some of
its simple variants) can be put in a uniform format as follows. Let L ⊆FO be

302
Martin Otto
a fragment associated with systems of observable conﬁgurations OL(A) over
relational structures A in a ﬁnite relational vocabulary τ. Together with the
overhead that links syntax of L with moves in the model checking game with
structure inputs OL(A), this model checking game can be taken as a speciﬁcation
of the semantics of L. The bisimulation game between OL(A) and OL(A′) then
is a representation of the Ehrenfeucht-Fra¨ıss´e or model comparison game for L.
This representation is adequate at a round-by-round level in terms of a syntactic
notion of depth in L that corresponds to the number of quantiﬁcation rounds
required in model checking a formula in L. The speciﬁcation of the model
checking game is in turn reﬂected in the format of OL(A). As an example
for the latter point, consider GF as presented above: we deliberately chose
transitions in OG(A) to link any two strictly guarded patches in one transition
rather than a sequence of transitions corresponding to one-new-element-at-a-
time moves as in O(A). The latter option would have turned FO quantiﬁer-rank
into our measure of semantic complexity in GF whereas the chosen stipulation
relates to the coarser but more intuitive notion of guarded nesting depth. With
the appropriate notion of depth that is implicit in the granularity of the model
checking game based on OL(A) come the notions of ≡L
q as ﬁnite approximations
to ≡L, and (for ﬁnite vocabulary) an Ehrenfeucht–Fra¨ıss´e theorem of the format
A, β ≡L
q A′, β′
⇔
OL(A), β ∼q OL(A′), β′, for q ∈ω, and
A, β ≡L A′, β′
⇔
OL(A), β ∼ω OL(A′), β′.
At the same time, a notion of inﬁnitary L-equivalence is induced by the full
bisimulation relation, O(A), β ∼OL(A′), β′, supporting a Karp theorem of the
format
A, β ≡L
∞A′, β′
⇔
OL(A), β ∼OL(A′), β′,
which can now also be seen as a speciﬁcation of what L∞(in terms of its model
checking game) needs to be.
Beyond a uniform perspective on the games and equivalences themselves,
the modal perspective on fragments of FO can also indicate what the right
transfer of other game-related notions to fragments should be. As one example
we state the following observation concerning ω-saturation (in the usual ﬁrst-
order context).
Observation 6.2.9
A is ω-saturated if, and only if, O(A) is modally saturated.
Similar correspondences can then be taken to deﬁne the appropriate notion of
ω-saturation in the context of fragments L ⊆FO (e.g., for FOk or GF), in terms
of modal saturation of the corresponding OL(A). This allows us to extrapolate

Fragments of FO and special classes of structures
303
to a range of in-between fragments from the Hennessy–Milner property of
modal logic to other fragments with the appropriate notion of ω-saturation.
In particular, the right types to be considered for this notion of saturation are
derived from the modal ♦-types in the OL(A).
On the other hand, for many natural fragments including FOk, GFk and
all the modal fragments, classical ﬁrst-order ω-saturation implies ω-saturation
(and the Hennessy–Milner property) in the sense of L. This is due to the
following.
Observation 6.2.10
For any fragment L ⊆FO for which the system of observ-
able conﬁgurations OL(A) is uniformly ﬁrst-order interpretable in A itself, ω-
saturation of A implies ω-saturation of OL(A), which (by the previous obser-
vation) implies modal saturation of OL(A), and hence the analogue of the
Hennessy–Milner property for L over the class of ω-saturated structures.
Note that this modal view is based on imposing the modal picture and the
bisimulation game on richer fragments of ﬁrst-order logic, uniformly via the
appropriate system of observable conﬁgurations and games. Alternatively, one
may think of a specialisation of the classically well understood situation for
ﬁrst-order and its inﬁnitary counterpart, their links with classical Ehrenfeucht-
Fra¨ıss´e games and Karp’s theorem (cf. Theorem 6.2.2). In connection with the
last observation for instance, ω-saturation (in the classical sense, w.r.t. FO-
types) implies ω-saturation in the sense of L for a fragment L ⊆FO, since L-
types are (partial) FO-types; a Hennessy–Milner property for ω-saturated struc-
tures then follows because player II has a strategy to maintain L-equivalence in
the inﬁnite L-game starting from L-equivalent conﬁgurations. But this, and how
L-types are to be deﬁned so that they can be transferred between L-equivalent
conﬁgurations as required for this argument, may be best understood system-
atically in terms of the game and its observable conﬁgurations as discussed
above.
6.2.5 Locality and modularity of the ﬁrst-order game
Games and the Ehrenfeucht–Fra¨ıss´e method are well suited to the exploration of
the expressive power of FO not just classically but equally well over restricted
classes of structures, and also to understanding the nature of fragments within
FO. Such explorations typically depend on the availability of suitable struc-
tures over which the game can be usefully analysed. In order to facilitate the
analysis, and equally importantly also as an indication of where to look for the
right candidate structures, one can often use the modularity of the game w.r.t.
Gaifman locality. We saw a glimpse of that aspect in Lemma 6.2.4 above.

304
Martin Otto
For Gaifman’s theorem, we want to establish that position (a, a′) in
Gq(A; A′) is a winning position for II, i.e., that A, a ≡q A′, a′, on the basis
of
– suitable global conditions on A and A′ (without reference to a and a′),
and
– purely local conditions on these parameters within their structures of the
form
A↾Nℓ(a), a ≡r A′↾Nℓ(a′), a′
for values of ℓand r that are recursively determined as functions of q.
Towards an understanding of the nature of the global requirement, and for
a gradation of both the local and global equivalences involved, we need the
following deﬁnition.
Deﬁnition 6.2.11
(i) For any ϕ(x) we write ϕℓ(x) for its relativisation to the
(FO-deﬁnable) ℓ-neighbourhood of its free variables, ϕℓ(x) := [ϕ]Nℓ(x).
If q = qr(ϕ), we refer to ϕℓas a local formula of Gaifman rank (ℓ, q).
(ii) A basic ℓ-local sentence is a sentence of the form
∃x1 . . . ∃xm

i<j
d(xi, xj) > 2ℓ∧

i
ψℓ(xi),
asserting the existing of an ℓ-scattered m-tuple whose components satisfy
the ℓ-local formula ψℓ(x). If q = qr(ψ), we regard the above basic local
sentence as one of Gaifman rank (ℓ, q, m).
Deﬁnition 6.2.12
The conﬁgurations A, a and A′, a′ are (ℓ, q, m)-Gaifman-
equivalent, denoted as A, a ≡ℓ
q,m A′, a′, if:
(i) A↾Nℓ(a), a ≡q A′↾Nℓ(a′), a′, i.e., a and a′ satisfy the same ℓ-local formu-
lae ϕℓfor qr(ϕ) ⩽q (local condition).
(ii) A and A′ satisfy the same basic local sentences of ranks (ℓ′, q′, m′) for all
ℓ′ ⩽ℓ, q′ ⩽q and m′ ⩽m (global condition).
For ﬁxed ﬁnite relational vocabulary and ﬁxed arity of the tuples a, each
≡ℓ
q,m has ﬁnite index, and respects ≡. Clearly also ≡ℓ
q,m is monotone w.r.t. the
ranks (ℓ, q, m). Gaifman’s theorem says that ≡ℓ
q,m approximates full ﬁrst-order
equivalence ≡well, in the sense that ≡is the common reﬁnement or limit of
all levels ≡ℓ
q,m.
Theorem 6.2.13 (Gaifman)
Any FO-formula is preserved under ≡ℓ
q,m for
suitable (ℓ, q, m). Equivalently: any formula of FO is logically equivalent to a
boolean combination of local formulae and basic local sentences.

Fragments of FO and special classes of structures
305
Gaifman’s original proof establishes the second statement by induction
on the FO formula under consideration. The link with the modularity of the
Ehrenfeucht–Fra¨ıss´e game, however, is brought out more clearly in an argu-
ment given in [15], which we adapt to give a brief sketch. To prove the ﬁrst of
the statements in the theorem, it inductively sufﬁces to establish the following
assertion about good responses for II.
Claim 6.2.14
If A and A′ are (L, Q, m)-Gaifman-equivalent 9 for values of
L and Q that are sufﬁciently large in relation to ℓand q, and if a and a′ of arity
less than m are such that
A ↾NL(a), a ≡Q A′ ↾NL(a′), a′
local pre-condition
then for any b ∈A there is some b′ ∈A′ such that
A ↾Nℓ(ab), ab ≡q A′ ↾Nℓ(a′b′), a′b′,
local post-condition
and, symmetrically, with the roles of b and b′ exchanged.
The claim is established on the basis of a case distinction w.r.t. the distance of
b from a. Suitable conditions on the choices of L and Q are extracted along the
way. Choosing L ⩾3ℓ+ 1 and Q ⩾q + 1 at least, any b ∈N 2ℓ+1(a) can be
dealt with according to the local pre-condition. For b that are further away from
a, A↾Nℓ(ab) is the disjoint union of A↾Nℓ(a) and A↾Nℓ(b). Due to modularity
of the game w.r.t. disjoint unions, it sufﬁces to ﬁnd b′ ∈A′ that is also far from
a′ and such that A′↾Nℓ(b′), b′ ≡q A↾Nℓ(b), b. In this case we rely on the global
condition on A and A′ for a further case distinction. We use the global condition
for scattered tuples w.r.t. a quantiﬁer-rank q formula ψ(x) that characterises
A↾N ℓ(b), b up to ≡q. We need to guarantee that A′ has a matching b′, i.e., we
seek some b′ ̸∈N2ℓ+1(a′) satisfying ψℓ.
Firstly, if A and hence also A′ have (2ℓ+ 1)-scattered m-tuples of elements
satisfying ψℓ, then one of the components of any such tuple in A′ will serve
as b′.
If, on the other hand, there are no such m-tuples, then the maximal size
n < m of (2ℓ+ 1)-scattered tuples for ψℓis the same in A and A′. Now
a comparison with n0, the maximal size of (2ℓ+ 1)-scattered tuples for ψℓ
within N2ℓ+1(a) can help to locate b′, provided L ⩾3ℓ+ 1 and provided Q
is large enough to force the same n0 to work in A′↾N2ℓ+1(a′) (via the local
pre-condition).
9 Due to the absence of parameters this involves only the global condition (ii) of
Deﬁnition 6.2.12.

306
Martin Otto
If n0 < n, then there must be realisations of ψℓoutside N2ℓ+1(a′) and any
such is a good choice for b′.
The remaining subcase that n0 = n (no surplus of realisations of ψℓbeyond
N2ℓ+1(a′)), implies in particular that d(a, b) ⩽6ℓ+ 3 and the existence of such
an element satisfying ψℓat distance greater than 2ℓ+ 1 but at most 6ℓ+ 3 is
covered by the local pre-condition, provided L ⩾7ℓ+ 3 and Q is large enough
to cover this (under the local pre-condition), too.
6.3 Special classes of transition systems
Up to bisimulation, every transition system is equivalent to a tree via a bisimi-
lar tree unfolding, just as every game graph can be replaced by the associated
game tree, typically making the representation structurally simpler though
less succinct. Correspondingly, any bisimulation invariant logic (logic whose
formulae are preserved under bisimulation equivalence) has the tree model
property. Because cycles are unfolded into inﬁnite paths, bisimulation equiv-
alent tree models may necessarily be inﬁnite even though the original model
was ﬁnite. So bisimilar unfoldings into tree models are typically not avail-
able within classes of ﬁnite models. In the investigation of the model the-
oretic relationship between bisimulation invariant fragments of FO with FO
itself, however, Gaifman locality can be used to replace acyclicity by local
acyclicity in key arguments. We brieﬂy review the classical construction of
bisimilar unfoldings into tree models and then review a construction of locally
acyclic bisimilar companion structures from [42]. These are used to estab-
lish variants of the classical model theoretic characterisations of modal frag-
ments of FO in terms of bisimulation preservation (van Benthem’s theorem, cf.
Corollary 6.3.5 below) over natural, restricted classes of transition systems in
section 6.3.2.
6.3.1 Tree unfoldings and locally tree-like systems
Bisimulation invariance and the tree model property
Let A be a transition system in a ﬁnite vocabulary τ consisting of binary
relations Eα and unary predicates Pj. With a ∈A we associate the following
bisimilar unfolding of A at a, A∗
a. The universe of A∗
a is the set of all ﬁnite,
edge-labelled paths from a in A, σ = (a0, α1, a1, . . . , αn, an), where a0 = a
and (ai−1, ai) ∈EA
αi. The transition relation Eα of A∗
a corresponds to path
extensions by single EA
α edges; the unary predicate Pj in A∗
a consists of those

Fragments of FO and special classes of structures
307
paths that end in P A
j . Then the map that associates to every path its last element,
viewed as a map π : A∗
a →A, induces a bisimulation:
π : A∗
a
∼
−→A
A∗
a, σ ∼A, π(σ).
It follows that every bisimulation invariant logic has the tree model property:
satisﬁability implies satisﬁability in a tree model. The tree model property has
important algorithmic consequences. Since it reduces satisﬁability issues to
problems over trees, strong classical results like Rabin’s decidability result for
the MSO theory of trees [45] and in particular automata theoretic methods can
be brought to bear, see also [49]. The example below illustrates the usefulness
of this simple insight for the (classical) model theory of modal logic, in giving
an alternative proof for van Benthem’s classical characterisation theorem for
modal logic (a preservation theorem in classical model theoretic terminology).
We ﬁrst discuss the classical argument, though, with emphasis on the more
interesting aspect of expressive completeness.
Theorem 6.3.1 (van Benthem)
Any bisimulation invariant ﬁrst-order for-
mula ϕ(x) ∈FO[τ] is equivalent to a formula of ML[τ] (and, conversely, this
condition is sufﬁcient to guarantee bisimulation invariance).
A simple compactness argument shows that, if ϕ is not expressible in
ML, then there are A, a ≡M A′, a′ such that A |= ϕ[a] while A′ ̸|= ϕ[a′]. In
ω-saturated elementary extensions ˆA ≽A and ˆA′ ≽A′, which are modally
saturated, one automatically upgrades A, a ∼ω A′, a′ and A, a ≡M A′, a′ to
ˆA, a ∼ˆA′, a′ (cf. the Hennessy–Milner property in Lemma 6.2.8), whence
ˆA |= ϕ[a] and ˆA′ ̸|= ϕ[a′] refutes preservation under ∼.
We turn to alternative approaches that work with explicit model construc-
tions and transformations. We shall later see how this alternative approach
relativises to many restricted classes (in particular also of ﬁnite models) where
compactness is not available. But even in the classical context, and working
over the class of all frames, such an explicit and game-based approach yields
extra beneﬁts.
Example: van Benthem’s theorem via explicit constructions
The follow-
ing auxiliary observation is straightforward from the bisimulation game: any
common upper bound on the lengths of directed paths from the elements in a
bisimulation game position is also a bound on the number of rounds that can
be played by I.

308
Martin Otto
Observation 6.3.2
For directed, rooted trees A, a and A′, a′ of depths ⩽ℓ:
A, a ∼ℓA′, a′
⇒
A, a ∼A′, a′.
Combining this with the tree model property, we ﬁnd the following.
Claim 6.3.3
Any ℓ-local ϕ(x) ∈FO[τ] that is invariant under ∼is invariant
under ∼ℓ.
Proof. We need to show for A, a ∼ℓA′, a′ that A |= ϕ[a] ⇔A′ |= ϕ[a′].
Replacing both structures by their bisimilar unfoldings from the distinguished
nodes (and appealing to ∼invariance of ϕ), then truncating both tree structures
at depth ℓ(and appealing to ℓ-locality of ϕ), we have transformed the given
situation into
A, a ≃(ℓ)
ˆA, ˆa ∼ˆA′, ˆa′ ≃(ℓ) A′, a′,
where ≃(ℓ)stands for isomorphism up to depth ℓfrom the distinguished node.
The central bisimulation equivalence is based on Observation 6.3.2. But now
A |= ϕ[a] ⇔A′ |= ϕ[a′] follows by ∼invariance and ℓ-locality.
Claim 6.3.4
If ϕ(x) ∈FO[τ] is preserved under ∼, then it is preserved under
∼ℓfor ℓ= 2qr(ϕ) −1.
Proof. As ∼invariance implies invariance under disjoint unions, Lemma 6.2.4
shows that ϕ is ℓ-local, thus ∼ℓinvariant by Claim 6.3.3.
As ∼ℓis of ﬁnite index, and each ∼ℓclass deﬁnable in ML at nesting depth
ℓ, we directly have the following version of van Benthem’s theorem, which
even gives a tight bound on the modal nesting depth which is not implicit in
the classical proof.
Corollary 6.3.5
Any quantiﬁer-rank q formula ϕ(x) ∈FO[τ] that is preserved
under bisimulation is equivalent to a formula of ML[τ] of nesting depth ⩽
2q −1.
It may be worth representing the overall strategy of upgrading a concrete
level of ∼ℓto preservation of ϕ in this approach. The transformations, from
top to bottom in the diagram, involve ﬁrstly a tree unfolding and secondly
truncation at depth ℓ. The ﬁrst step preserves ∼, the second simultaneously
preserves ∼ℓand ϕ (by Lemma 6.2.4). Consequently ϕ is preserved all along
the vertical, but also along the bottom horizontal (as here ∼ℓguarantees full ∼
equivalence, by Observation 6.3.2). Thus ϕ is shown to be preserved along the

Fragments of FO and special classes of structures
309
top horizontal, too.
A, a
∼ℓ
∼
A′, a′
∼
•
unfolding

A∗
a, a
∼ℓ
∼ℓ/ ≃(ℓ)
(A′)∗
a′, a′
∼ℓ/ ≃(ℓ)
•
truncation

A∗↾Nℓ(a), a
∼ℓ
∼
(A′)∗↾Nℓ(a′), a′
•
The construction of unfoldings shows that every τ transition system is
bisimilar to a τ-tree, and (by taking disjoint unions of unfoldings at different
elements as appropriate) globally bisimilar to a τ-forest. Obvious variations
of these constructions provide acyclic companion structures that are (globally)
two-way bisimilar.
As pointed out above, not every ﬁnite transition system is bisimilar to a
ﬁnite acyclic system. Note that, for instance, the above proof of van Benthem’s
theorem fails to yield the ﬁnite model theory version (due to Rosen [46]): the
argument crucially uses bisimulation invariance of ϕ in the transition from A, a
to A∗
a, where the target structure may be inﬁnite.
In the case of Corollary 6.3.5 there is in fact an easy way out: the full
(and potentially inﬁnite) tree unfoldings of the given ﬁnite structures in the
proof of Claim 6.3.3 can in that context be replaced by truncations to depth ℓ
with isomorphic copies of the ﬁnite original structures attached at the cut-off
points to yield fully bisimilar companions that are both ﬁnite and tree-like up to
depth ℓ. This simple modiﬁcation yields a proof of Rosen’s ﬁnite model theory
analogue of van Benthem’s theorem [46], including the tight bound on nesting
depth in our version [42].
In connection with stronger and, in particular, global notions of bisimulation
equivalence, however, better approximations to acyclicity in ﬁnite models are
required. The upgrading will lead from suitable levels of ﬁnitary game equiva-
lence to appropriate levels of local FO equivalence (Gaifman equivalence).

310
Martin Otto
Locally acyclic bisimilar covers
Recall that a transition system is simple if it does not have loops or mul-
tiple edges (not even in opposite directions); it is called ℓ-acyclic if every
ℓ-neighbourhood in its Gaifman graph is acyclic (this forbids undirected cycles
of lengths up to 2ℓ+ 1).
Deﬁnition 6.3.6
A bisimilar cover π : ˆA
≈
−→A is a homomorphism π whose
graph is a global two-way bisimulation: ˆA, ˆa ≈A, π(ˆa) for all ˆa ∈ˆA. We call
π faithful if it preserves in- and out-degrees w.r.t. each individual relation
Eα ∈τ.
A (faithful) simple ℓ-acyclic cover of A is a (faithful) bisimilar cover
π : ˆA
≈
−→A by a simple ℓ-acyclic τ-structure ˆA.
Lemma 6.3.7
Every ﬁnite τ transition system admits, for every ℓ, a ﬁnite
faithful simple ℓ-acyclic cover.
The construction in [42] uses for ˆA a product of the given A with a ﬁnite
group G which has a generator ge for every edge e ∈˙
αEA
α and such that the
Cayley graph of G w.r.t. this set of generators has girth greater than 2ℓ+ 1
(compare [1] for such groups) – much as the tree unfolding could be described
in terms of a product with the inﬁnite free group of this set of generators.
Over the cartesian product A × G one puts an Eα-edge precisely from (a, h)
to (b, k) if e = (a, b) ∈EA
α and k = h ◦ge. In this fashion, any cycle in the
product projects to a cycle in the Cayley graph of G, and hence its length is
bounded from below by the girth of that graph.
The following is a simple auxiliary observation towards an ℓ-local upgrading
of ℓ-bisimulation equivalence to ≡q. A natural strategy for II can be based
on maintaining full isomorphism of the substructures generated by the paths
connecting the elements of the current conﬁgurations to the roots [14].
Observation 6.3.8
Let A, a ∼ℓA′, a′ be two directed τ-trees of depths ⩽ℓ
with roots a and a′, such that every node apart from the root is one of at least
q bisimilar siblings. Then A, a ≡q A′, a′. The same holds w.r.t. two-way ℓ-
bisimulation equivalence in acyclic ℓ-neighbourhoods A↾Nℓ(a) and A′↾Nℓ(a′)
with at least q equivalent siblings to choose from in every node.
Structures that have at least q equivalent successors/predecessors in every
node are easily obtained by taking products with {1, . . . , q} in the natural man-
ner. We write A →A ⊗q for this transformation, and identify a distinguished
element a with (a, 1) in the new structure were appropriate.

Fragments of FO and special classes of structures
311
Faithful bisimilar covers preserve this property, and can be used to achieve
local acyclicity and therefore local ≡q-equivalence, viz. ≡ℓ
q,0, by the above
observation.
Example: van Benthem–Rosen once more
Combining the passage to A ⊗q
(boosting multiplicities) with a bisimilar unfolding, one obtains a variant proof
of Claim 6.3.4 (and through it Corollary 6.3.5 and its ﬁnite model theory
analogue, too). Let qr(ϕ) = q and ℓ:= 2q −1. Let ˆA be the tree unfolding
from (a, 1) in A ⊗q (or the truncation of this unfolding glued with copies of
A if we want to deal with ﬁnite structures exclusively), similarly for A′, a′.
A, a
∼ℓ
∼
A′, a′
∼
ˆA, ˆa
∼ℓ
≡ℓ
q,0
ˆA′, ˆa′
Now ≡ℓ
q,0 equivalence in the bottom horizontal follows from Observation 6.3.8;
preservation of ϕ along the bottom horizontal additionally uses Lemma 6.2.4
again.
Acyclic bisimilar covers really come into their own in upgradings to some
target level ≡ℓ
q,m of Gaifman equivalence with m > 0, i.e., if the ﬁrst-order
property at hand really does express non-trivial global conditions on the exis-
tence or non-existence of certain local types – global in the sense of not only
involving the ℓ-neighbourhood of the distinguished element.10
We look, as a typical example, at the characterisation of ML
−∀⊆FO in terms
of invariance under ≈(global two-way bisimulation) [42]. Again, we stress the
expressive completeness phenomenon, as preservation of ML
−∀under ≈is
obvious.
Theorem 6.3.9
Both classically and in the sense of ﬁnite model theory: any
ﬁrst-order formula ϕ(x) ∈FO[τ] that is preserved under ≈is equivalent to a
formula of ML
−∀[τ].
10 See [42] for a discussion that for any ϕ(x) ∈FO that is invariant under disjoint sums (over
ﬁnite structures, or indeed over some other class which itself is closed under disjoint sums),
only ≡ℓ
q,m for m = 0, 1 can matter.

312
Martin Otto
This follows from the following claim, based on an upgrading of ≈ℓto ≡ℓ
q,m
in an explicit ≈preserving model transformation, under which in particular the
class of ﬁnite structures is closed.
Claim 6.3.10
If ϕ(x) ∈FO[τ] is preserved under ≈(over ﬁnite structures),
then it is preserved under ≈ℓand hence expressible in ML
−∀[τ] at nesting depth
ℓ, for some ℓ. Any ℓsuch that ϕ is preserved under ≡ℓ
q,m for some q, m will
do, i.e., the Gaifman locality radius of ϕ gives a bound on the necessary modal
nesting depth.11
A
≈ℓ
≈
A′
≈
•
boosting multiplicities

A ⊗q
≈ℓ
≈
A′ ⊗q
≈
•
locally acyclic covers

ˆA
≈ℓ
≡ℓ
q,1
≈
ˆA′
≈
•
disjoint sums

m · ˆA
≈ℓ
≡ℓ
q,m
m · ˆA′
•
Proof. We just mention the upgrading steps towards the proof of the claim,
also indicated in the diagram below.
11 For simplicity, the modal nesting depth in ML
−∀discounts ∀/∃quantiﬁers, which w.l.o.g. can
be eliminated from within the scope of modal quantiﬁcations so that they only occur ‘on the
outside.’

Fragments of FO and special classes of structures
313
The ﬁrst step, passage to a product with {1, . . . , q}, serves to boost all
multiplicities to at least q: every Eα successor or predecessor of any node
belongs to a group of at least q siblings related by automorphisms of the entire
structure.
The second step yields an ℓ-acyclic bisimilar cover of the resulting structures
so that the ℓ-neighbourhood of any node will be acyclic, and maintains the at-
least-q-similar-siblings property due to the preservation of in- and out-degrees
in faithful covers. In these circumstances, the ≈ℓrelationship between the two
structures guarantees ≡ℓ
q,1 equivalence, by Observation 6.3.8.
Finally we can, if we wish, upgrade ≡ℓ
q,1 further to ≡ℓ
q,m, for any desired
level m, by just passing to m disjoint copies of the structures obtained so far.
This step guarantees that any local isomorphism type that is realised at all
is a member of a scattered set of at least m many nodes of the same local
isomorphism type, so that ≡ℓ
q,1 implies ≡ℓ
q,m. As pointed out above, however,
this last upgrading can be made redundant by showing right away that ϕ must
be preserved under some ≡ℓ
q,1 (i.e., m = 1 sufﬁces).
It is clear that arguments of the kind explored here may have entirely different
relativisations from the classical arguments. While classical model theoretic
arguments based on compactness go through in restriction to any elementary
class of structures, the above argument goes through, for instance, in restriction
to any class of (ﬁnite) transition systems that is closed under ≈. But while
this upgrading argument, and hence the expressive completeness result, does
relativise to the class of all ﬁnite transition systems, it does for instance not
immediately relativise to the class of connected or rooted (ﬁnite) transitions
systems: clearly the last step does not preserve connectivity (and there is no
immediate reason why a ﬁrst-order formula ϕ(x) that is invariant under ≈over
connected structures should be preserved by some ≡ℓ
q,1), and even the ﬁrst step
does not preserve rootedness.
6.3.2 Non-classical modal characterisation theorems
The general format
Analogues of the van Benthem theorem in classical and ﬁnite model theory
for stronger and in particular global forms of bisimulation in the style of
Theorem 6.3.9 are pursued in [42]. Many further natural variations of the
underlying class of (ﬁnite) structures are explored in [14], with an emphasis
also on methodological distinctions. In all these cases, concrete and explicit
model transformations adapted to the classes at hand are used, which in many

314
Martin Otto
cases also provide alternative routes to characterisations over some interesting
elementary classes of not necessarily ﬁnite structures.
We highlight the general format of a characterisation theorem for a fragment
L of FO of this kind. Let L ⊆FO be a fragment of FO with
(1) equivalences ⇋q for the relation of L-equivalence up to rank q, which we
assume to have ﬁnite index; it follows that ⇋q classes are L-deﬁnable at
rank q.
(⇋q is induced by the q-round game GL
q.)
(2) the common reﬁnement of the (⇋q)q∈ω, ⇋ω, capturing ≡L.
(⇋ω is induced by GL
ω.)
(3) the full inﬁnitary equivalence ⇋associated with GL
∞.
The assumptions that each ⇋q has ﬁnite index and that ≡L is the limit of these
ﬁnitary game equivalences reﬂect the ‘ﬁnitary nature’ of L. In this context
we want to show, over a given class C of τ-structures, that the following are
equivalent for ϕ(x) ∈FO[τ]:
(i) ϕ is preserved under ⇋over C, i.e.,
for all A, a and A′, a′ in C: A, a ⇋A′, a′ ⇒

A |= ϕ[a] ⇔A′ |=
ϕ[a′]

.
(ii) ϕ is equivalent over C to a formula ˜ϕ ∈L[τ], i.e.,
there is some ˜ϕ ∈L[τ] s.t. for all A, a in C: A |= ϕ[a] ⇔A |= ˜ϕ[a].
It is worth looking at the two implications separately:
Preservation, (ii) ⇒(i), is a trivial consequence of the game analysis of L-
equivalence (our assumptions above). Moreover, the validity of this implication
over the class of all structures trivially implies its validity in restriction to any
subclass C. In particular a preservation statement trivially implies its ﬁnite
model theory analogue.
Expressive completeness, (i) ⇒(ii), is the crucial and non-trivial part of the
equivalence, which is sensitive to the class C. In particular, expressive complete-
ness does not generally relativise to subclasses, and a classical result cannot
generally be expected to persist in the sense of ﬁnite model theory.12
If ⇋ω coincides with ⇋∞in ω-saturated structures, as is typically the case,13
then expressive completeness of L for ﬁrst-order properties that are preserved
12 An easy example of a known failure of the ﬁnite model theory version of a classically valid
expressive completeness result close to our concerns is provided by ≡2
∞and FO2: the class of
all ﬁnite linear orderings is closed under ≡2
∞within the class of ﬁnite structures, but not
deﬁnable in FO2.
13 Our discussion of saturation and the Hennessy–Milner property in section 6.2 and especially
section 6.2.4 indicates that this is true whenever the corresponding OL(A) is uniformly
FO-interpretable over A.

Fragments of FO and special classes of structures
315
under ⇋over the class of all τ-structures follows from the assumptions (along
the lines of the classical proof outlined for van Benthem’s theorem above, for
instance).
Under the assumptions made, expressibility of ϕ in L (over C) is equivalent
to preservation of ϕ under some level of ⇋ℓ(over C). Therefore, the expressive
completeness of L for ⇋invariance over C is equivalent (for any C) to the
implication
ϕ(x) preserved under ⇋(over C)
⇒ϕ(x) preserved under ⇋ℓ(over C) for some ℓ∈ω,
which is a particular ‘compactness property’ that may or may not be valid,
depending on the nature of ⇋and C. The classical manner of establishing
this compactness property, as well as the alternative explicit and game-oriented
constructions indicated above may both be cast as upgradings of equivalences,
albeit in orthogonal directions. The juxtaposition of the generic diagrams below
may serve to make this distinction apparent. While the classical upgrading
involves a transformation of structures up to full FO equivalence (passage
to ω-saturated elementary extensions say) to boost ⇋ω to ⇋, the alternative
upgrading consists of a transformation of structures up to full (inﬁnitary) ⇋to
boost a concrete ﬁnitary level of ⇋ℓto an approximate level ˙≡of ﬁrst-order
equivalence that is good enough to preserve ϕ. In the examples encountered
here, ˙≡is either some level ≡q or ≡ℓ
q,m. The following two sections will review
and summarise some of the results obtained along these lines in [14].
A, a
ω
≡
A , a
≡
A∗, a
(A )∗, a
A, a
A, a
ˆA, a
˙≡
ϕ
ˆA , a
Explicit upgrading through local control
By approximating FO equivalence by a concrete level of Gaifman equivalence
we shift the emphasis to local control over FO equivalence. This allows us
to make use of explicit model constructions that lead to locally acyclic struc-
tures, as in Lemma 6.3.7, which means that locally ≈ℓcan be upgraded to ≡q
(if multiplicities have been boosted in preparation) via Observation 6.3.8. For

316
Martin Otto
characterisations of ∼∀invariance rather than ≈(global but only forward bisim-
ulation, related to ML
∀), a correspondingly higher level of global ℓ0-bisimulation
equivalence can ﬁrst be upgraded (in a transformation up to full global forward
bisimulation ∼∀) to ≈ℓ1, which can then be further upgraded to some ≡ℓ
q,m as
above. In this manner, for example the expressive completeness results below
are proved in [14].
A rooted structure is a τ-structure A, a with distinguished element a as a
root from which all elements of A are reachable on directed paths. For tree
structures compare section 6.1.2. Note that even the class of not necessarily
ﬁnite rooted structures is not elementary. Also note that for rooted structures,
the full inﬁnitary equivalences ∼∀and ∼coincide at the roots, while the ﬁnite
levels clearly do not.
Theorem 6.3.11
ML
∀is expressively complete for ﬁrst-order properties that
are preserved under ∼over the following classes C of structures:
(i) the class of rooted structures.
(ii) the class of ﬁnite rooted structures.
(iii) the class of tree structures.
(iv) the class of ﬁnite tree structures.
Another natural and classically important class of transition systems (as
Kripke structures in the context of knowledge representation) is the class of
equivalence structures: τ-structures in which all transition relations Eα are
interpreted as equivalence relations. And even though transitivity requirements
tend to trivialise locality analysis (also compare the next section), equivalence
structures are amenable to an analysis and to upgrading transformations based
on locally acyclic covers. Here FO interpretations can be used to adapt both
the construction of suitable covers and the analysis of bisimulation invariant
FO properties. As far as local acyclicity in bisimilar covers is concerned, the
following can be obtained from Lemma 6.3.7 via simple FO translations.
Lemma 6.3.12
Every ﬁnite equivalence structure admits, for every ℓ, a faithful
bisimilar cover by some ﬁnite equivalence structure in which
(i) any two equivalence classes (w.r.t. to distinct Eα) intersect in at most one
element,
(ii) all cycles of lengths up to 2ℓ+ 1 stay within a single Eα class for some
α.
Over such essentially ℓ-acyclic structures, an analogue of Observation 6.3.8
is available to show that global ℓ-bisimulation can be upgraded to ≡ℓ
q,m for any
required level of q and m. Therefore, ∼invariance implies ∼ℓinvariance also
over the class of ﬁnite equivalence structures.

Fragments of FO and special classes of structures
317
Corollary 6.3.13
ML
∀is expressively complete for ﬁrst-order properties that
are preserved under global bisimulation ∼∀over the class of ﬁnite equivalence
structures.
Explicit upgrading through decomposition
Locality arguments cannot be used to great effect over structures that trivialise
Gaifman locality. For instance, the Gaifman graph of directed transitive trees
(trees with a partial order) has diameter 2, and ≡ℓ
q,m is essentially just ≡q, for
ℓ⩾1. On some related and particularly interesting classes of transition systems
with one transitive transition relation, however, one may instead base expressive
completeness proofs for modal fragments on another classical constructive
approach to the analysis of games: composition arguments w.r.t. order. We saw
a glimpse of this in the Ehrenfeucht–Fra¨ıss´e analysis of ﬁnite linear orderings
in section 6.2.2 (Lemma 6.2.3).
We consider the example of rooted, irreﬂexive transitive tree structures with
a single transition relation E: A = (A, EA, (P A
i )) with distinguished root a,
with a transitive and irreﬂexive partial order relation EA such that the set of
E-predecessors of any element b ∈A is well-ordered by EA with minimal
element a. For succinctness we refer to such structures as ≺-trees. The class
of all ≺-trees (ﬁnite and inﬁnite ones) is non-elementary (due to the well-
foundedness condition); and so is the class of all ﬁnite ≺-trees (due to the
ﬁniteness condition).
We review the key decomposition idea from [14] that allows us to upgrade ℓ-
bisimulation equivalence between (ﬁnite) ≺-trees A, a ∼ℓA′, a′ to quantiﬁer-
rank q ﬁrst-order equivalence ≡q through a transformation that preserves full
bisimulation equivalence.
In a preparatory step, we boost multiplicities and unravel in order to achieve
some homogeneity w.r.t. paths in ≺-trees.
For a given q let the ≺-trees Aq
0 and Aq
q−1 (an expansion of Aq
0 by colours
for certain ≡q−1 types) be obtained from A, a as follows.
The universe and the interpretation of the unary predicates of Aq
0 are those
of the bisimilar unfolding of A ⊗{1, . . . , q} from one of the representatives
of the root a (say we identify a with (a, 1)); for its transition relation we pass
to the transitive closure of the transition relation in the unfolding. It is easily
checked that this transformation leads to a bisimilar ≺-tree Aq
0, which is ﬁnite if
A is. Even for inﬁnite A the ≺-tree Aq
0 has predecessor sets that are ﬁnite linear
orderings rather than arbitrary well-orderings. In addition, due to the unfolding
step in its construction, Aq
0 has the following useful representation property for
its paths. Any path a0 = a, a1, . . . , an from the root in Aq
0, can be matched with
some full path ˆa0 = a, ˆa1, . . . , ˆan consisting of the full predecessor set of the

318
Martin Otto
target node ˆan in Aq
0, such that ai and ˆai are not only bisimilar but even are the
roots of isomorphic subtrees.
Towards an inductive analysis of ≡q, we use Aq
q−1, which is the expansion
of Aq
0 with new unary predicates that colour every node with the ≡q−1-class of
the subtree rooted at this node in Aq
0.
In order to show how suitable levels of ℓ-bisimulation between ≺-trees A, a
and A′, a′ can be upgraded to ≡q equivalence in bisimilar ≺-trees, we ﬁrstly
replace A and A′ by the ≺-trees Aq
0, a ∼A, a and (A′)q
0, a′ ∼A′, a′. It then
sufﬁces to show, in the context of an induction on q, that for some sufﬁciently
large ℓ(depending on q):
(∗)
Aq
q−1, a ∼ℓ(A′)q
q−1, a′
⇒
Aq
0, a ≡q (A′)q
0, a′.
For this, a composition argument can be used towards a reduction to the
analysis of Ehrenfeucht–Fra¨ıss´e games over ﬁnite coloured linear orderings.
We associate with an element b in Aq, a the coloured ﬁnite linear ordering Ib
induced on the interval [a, b] in Aq; similarly I′
b′ with any b′ in (A′)q, a′. Then
Ib, a, b ≡q−1 I′
b′, a′, b′
⇒
Aq
q−1, a, b ≡q−1 (A′)q
q−1, a′, b′,
due to compositionality of strategies in the games. A winning strategy for II in
the remaining (q −1)-round game on the ≺-trees can be based on
(a) a strategy in the (q −1)-round game on the induced linear orderings: this
provides a match between subtrees rooted along the coloured paths [a, b]
and [a′, b′].
(b) strategies to play within colour-matched subtrees based on their ≡q−1
equivalence.
Therefore, it sufﬁces to guarantee that for every b there is some b′ (and
vice versa, for every b′ a b) such that Ib, a, b ≡q−1 I′
b′, a′, b′, provided only
that Aq
q−1, a ∼ℓ(A′)q
q−1, a′. A bound on such an ℓcan now be extracted from
the Ehrenfeucht–Fra¨ıss´e game on ﬁnite coloured linear orderings. The follow-
ing is a consequence of the compatibility of the game with ordered sums or
concatenation (we leave it as a nice exercise; see [15] and also [14] for details).
Observation 6.3.14
There is a bound N (depending on q and the number
of colours) such that any ﬁnite coloured linear ordering (with constants for
the ﬁrst and last elements) of length greater than N has some proper ≡q−1
equivalent substructure.
In the case of the ﬁnite coloured orderings Ib this means that, up to ≡q−1,
only those of lengths up to N need to be taken into account (any substructure
of an Ib is realised as Iˆb for suitable ˆb by the homogeneity property of Aq
q−1).

Fragments of FO and special classes of structures
319
But the isomorphism types of (substructures of) Ib of size up to N are clearly
governed by the ∼N−1 type of Aq
q−1, a, whence we get (∗) for ℓ= N −1.
Based on this decomposition approach, the following are obtained in [14].
Theorem 6.3.15
ML is expressively complete for ﬁrst-order properties that
are preserved under bisimulation over the following classes C of partially
ordered trees:
(i) the class of irreﬂexive transitive trees.
(ii) the class of ﬁnite irreﬂexive transitive trees.
While the classes of rooted reﬂexive transitive structures or reﬂexive tran-
sitive trees display a similar behaviour [14], the picture changes if reﬂexivity
is not uniformly prescribed. For transitive tree-like structures in which some
nodes may be reﬂexive, a marked difference between ﬁnite and not necessarily
ﬁnite structures becomes important. The ﬁrst-order formula
ϕ(x) = ∃y(Exy ∧Eyy),
expressing accessibility of a reﬂexive node, is
(a) invariant under bisimulation over the class of ﬁnite transitive structures, but
(b) not invariant under bisimulation over the class of all transitive structures.
Point (b) is illustrated by the simple example of the inﬁnite irreﬂexive unfolding
of a structure consisting of a single reﬂexive node. For (a) consider ﬁnite
transitive structures A, a ∼A′, a′ and assume that A |= ϕ[a]. Consider a play
of I from a to some reﬂexive b in A followed by a sequence of stationary moves
at b (b is reﬂexive) that is long enough to force the sequence of responses by
II to visit some node b′ twice: as b′ is on a cycle, it is reﬂexive.
[14] shows that an extension of basic modal logic with a modality as sug-
gested by ϕ above, asserting that there is some reﬂexive successor satisfying
ψ, is expressively complete for bisimulation invariant ﬁrst-order properties
over ﬁnite transitive tree-like structures. For expressive completeness over the
wider classes of all ﬁnite transitive structures a stronger variant of this new
modality is required, which also captures reachability of an E-clique (rather
than a single reﬂexive node) realising several distinct formulae. As indicated
above, such extra modalities are necessary in the ﬁnite, but not compatible with
bisimulation in transitive structures in general. (In fact it is not ﬁniteness, but
the absence of inﬁnite strictly forward-directed E-paths, that matters, see [14].)
Over ﬁnite transitive structures and some related restricted classes of transi-
tive transition systems, the decomposition based analysis in [14] also extends
from ﬁrst-order to monadic second-order logic.

320
Martin Otto
Among the long open questions in this area remain the ﬁnite model theory
status of
– the Janin–Walukiewicz result [34] that the modal µ-calculus is expres-
sively complete for monadic second-order properties preserved under
bisimulation, and
– expressive completeness of the guarded fragment for the ﬁrst-order prop-
erties preserved under guarded bisimulation, established in the classical
setting in [2].
The second issue, concerning guarded bisimulation as a generalisation of
modal bisimulation, also leads over to the following section.
6.4 From graphs to hypergraphs
The guarded fragment of FO and, more fundamentally, the concept of guarded
bisimulations (compare section 6.2.3) point to a hypergraph structure induced
by a relational structure, over and above the graph structure embodied in the
Gaifman graph. With the relational τ-structure A we can associate the hyper-
graph of guarded subsets of A, whose universe is the universe A of A and
whose hyperedges are the guarded subsets s ⊆A of A:
H(A) =

A, {s ⊆A: s a guarded subset }

.
Generally, with any hypergraph H = (A, S), one also associates the graph
over the same universe A whose edge relation is precisely the union of the
cliques induced by the hyperedges of H:
G(H) = (A, E)
where E = 
s∈S{(a, b): a, b ∈s, a ̸= b}.
In the case of the hypergraph H(A) this just returns the Gaifman graph
G(A).
The graph G(H), however, contains less information, since not every clique
in G(H) need be induced by a hyperedge. The complete graph on three ele-
ments, K3, for instance, occurs as G(H) for H = K3 as well as for any hyper-
graph that has the full set of three elements as one of its hyperedges. In the
classical literature on hypergraphs [7], a hypergraph H such that all cliques in
G(H) are induced by hyperedges is called conformal; conformality plays a role
in acyclicity criteria for hypergraphs. In the next section we brieﬂy look at the
natural notion of hypergraph bisimulation and discuss corresponding notions
of acyclicity and unfoldings.

Fragments of FO and special classes of structures
321
6.4.1 Hypergraph bisimulation
If we disregard the local relational content in guarded bisimulations, i.e., if we
relax the soundness condition on positions in the game from local isomorphism
of relational substructures to just local bijections, we obtain a natural notion
of hypergraph bisimulation. Guarded bisimulations become a special case of
hypergraph bisimulations between the associated hypergraphs of guarded sub-
sets. For questions of acyclicity and of tree decomposability, the actual local
relational content does not matter and it makes sense to work with the more
fundamental notion of hypergraph bisimulation.
The hypergraph bisimulation game
The positions in the bisimulation game
on hypergraphs H = (A, S) and H ′ = (A′, S′) are local bijections ρ : s →
s′ between hyperedges s ∈S and s′ ∈S′. The challenge/response exchange
between players I and II in a single round, from position ρ : s →s′, is played
as follows:
– I selects either some hyperedge t ∈S or some hyperedge t′ ∈S′;
– II has to respond with a position σ : t →t′ (involving the hyperedge
proposed by I and a match with a hyperedge in the opposite structure)
such that ρ agrees with σ on the overlap (between s and t if I chose t, or
between s′ and t′ if I chose t′).
II loses if she has no such response. Otherwise, winning conditions in the
q-round game, the ﬁnite-round game and the inﬁnite game are as usual. We
correspondingly deﬁne equivalences in terms of winning positions for II.
Deﬁnition 6.4.1
For hypergraphs H = (A, S) and H ′ = (A′, S′): H, a ∼q
H, a′ if the bijection ρ : a →a′ is a winning position in the q-round bisimu-
lation game on the hypergraphs H and H ′. Equivalences H, a ∼ω H ′, a′ and
H, a ∼H ′, a′ are similarly deﬁned w.r.t. the ﬁnite-round and inﬁnite games.
Deﬁnition 6.4.2
A bisimilar cover of the hypergraph H = (A, S) by the
hypergraph ˆH = ( ˆA, ˆS) is a map π : ˆA →A such that
(i) π is injective in restriction to every ˆs ∈ˆS.
(ii) S = {π(ˆs): ˆs ∈ˆS}.
(iii) π comprises a winning strategy for II in the inﬁnite bisimulation game in
the sense that II can maintain positions in which hyperedges are matched
through π.
Consider the special case of H = H(A), the hypergraph of guarded subsets
of the τ-structure A. It is not hard to see that any bisimilar cover π : ˆH →H

322
Martin Otto
by a hypergraph ˆH = ( ˆA, ˆS) induces a guarded cover
π : ˆA →A,
where ˆA is simply obtained by pulling the relational interpretation on A back to
ˆA in such a way that every restriction of π to a hyperedge of ˆH becomes a local
isomorphism. One checks that this leads to a well-deﬁned interpretation of a
τ-structure over the universe ˆA, for which indeed also H( ˆA) = ˆH. In particular
π now comprises a winning strategy for II in the inﬁnite guarded bisimulation
game on ˆA and A (compare (iii) above). These simple considerations sug-
gest to view hypergraph bisimulation just as ‘guarded bisimulations without
relations’ – or to view guarded bisimulation as a relational incarnation of a
possibly more fundamental notion of hypergraph bisimulation.
6.4.2 Tree-likeness: acyclicity criteria
Full acyclicity (in the hypergraph sense) can be achieved, up to bisimulation,
through a process of bisimilar unfolding in close analogy with the tree unfolding
of transition systems. We present this basic construction before relating it to
the relevant notions of acyclicity and tree-likeness that it exempliﬁes.
Bisimilar hypergraph unfolding
Consider a hypergraph H = (A, S). We
want to ﬁnd a tree-like hypergraph ˆH that provides a bisimilar cover for H;
while overlaps between hyperedges have to be reproduced in
ˆH, it should
otherwise and in particular globally be as free (free of incidental overlaps)
as possible. The construction follows the idea of a tree unfolding of a transi-
tion system, but instead of nodes, subsets need to be joined – joined through
identiﬁcations in overlaps as prescribed in H, compare [25].
With H ﬁrstly associate the tree S∗of all ﬁnite sequences of hyperedges, with
a successor relation linking a sequence σ ∈S∗to its immediate extensions σˆs
for s ∈S. We obtain the universe ˆA of the desired hypergraph ˆH as a quotient
of the following auxiliary set D, which may be seen as a disjoint union of
path-labelled copies of hyperedges s ∈S:
D :=

(σˆs, a) ∈S+ × A: a ∈s

⊆S∗× A.
In this set, we want to identify same elements in nodes that are labelled with
next-neighbour paths. Let ˙= be the reﬂexive, symmetric, transitive closure of
the relation that links (σ, a) to (σˆs, a) in D. In the following we write [σ, a]

Fragments of FO and special classes of structures
323
for the ˙= equivalence class of (σ, a) ∈D. We put
ˆA := D
%
˙=,
ˆS :=
ˆsσ : s ∈S, σ ∈S∗
,
where ˆsσ = {[σˆs, a]: a ∈s} for σ ∈S∗, s ∈S.
One checks that π : ˆH →H, [σ, a] →a is well-deﬁned and a bisimilar
hypergraph cover. In line with the above remarks, if the same construction is
applied to the hypergraph H = H(A) associated with the guarded subsets of a
τ-structure A, then the obvious expansion of ˆA to a τ-structure yields a guarded
bisimilar cover of A. In both cases, the tree structure of S∗also provides a tree
decomposition of the new hypergraph ˆH, or of the τ-structure ˆA.
Deﬁnition 6.4.3
A tree decomposition of H = (A, S) consists of a tree T
together with a surjective map ρ : T →S such that for every a ∈A the subset
{t ∈T : a ∈ρ(t)} ⊆T is connected in T .
It may be intuitive that the existence of a tree decomposition is an acyclicity
condition. Consider a tree decomposition ρ of a ﬁnite hypergraph H with
ﬁnite tree T . One can use ρ to reduce H to the empty hypergraph by repeated
application of the following two reduction steps
– removal of an element a ∈A that is covered by at most one hyperedge
(more precisely, a is removed from A and from the hyperedge covering
it).
– removal of a hyperedge s that is contained in some other hyperedge that
is retained.
For the claimed reduction, essentially just proceed from the leaves of T : a leaf
of T is mapped to a hyperedge that is either contained in the hyperedge at
its predecessor node, or it contains some elements not covered by any other
hyperedge. Removal of hyperedges or elements based on this procedure is
compatible with maintaining a tree decomposition.14
If we transfer this notion of a hypergraph tree decomposition to relational
structures (cf. Deﬁnition 6.5.1 for tree decompositions in that sense), there
is an important difference: the usual notion of tree decomposition is more
liberal in allowing arbitrary subsets of A to be associated with the nodes of
the representation tree, while here we would only admit guarded sets. A cycle
(viewed as a hypergraph with size 2 hyperedges) does not admit a hypergraph
tree decomposition, but it does admit tree decompositions based on subsets of
14 Note that to deal with inﬁnite hypergraphs, it is necessary to phrase the reduction condition for
ﬁnite sub-hypergraphs rather than the full graph; e.g., a two-way inﬁnite edge chain is not
decomposable as such.

324
Martin Otto
size 3. We return to ordinary tree decompositions of relational structures in
section 6.5.1 below.
It follows that every logic invariant under guarded bisimulation (i.e., whose
formulae are preserved under guarded bisimulations) has a bounded treewidth
model property or generalised tree model property [21]. This property is of
great value in the algorithmic model theory of GF and of its extensions that
still are sublogics of GF∞like guarded ﬁxpoint logic [24], because it allows
a reduction of satisﬁability issues to the model theory of trees, via a coding of
models in tree representations.
Proposition 6.4.4 (Gr¨adel)
GF has the following generalised tree model
property: any satisﬁable ϕ ∈GF[τ] is satisﬁable in a model that admits a tree
decomposition w.r.t. guarded subsets, and in particular one of treewidth less
than the width of τ.15
Returning to hypergraphs, the classical criterion for hypergraph acyclicity
is the following. As shown in [6] it coincides (for ﬁnite hypergraphs) with
hypergraph tree decomposability in the sense of Deﬁnition 6.4.3 above, as well
as with several other criteria. For classical hypergraph theory compare [7].
Deﬁnition 6.4.5
A hypergraph H = (A, S) with associated graph G(H) is
called acyclic if it satisﬁes the following two conditions:
(i) conformality: every clique in G(H) is contained in some hyperedge of
H.
(ii) chordality: every cycle of length at least 4 in G(H) has a chord: there are
two nodes that are not next neighbours along the cycle that are linked (by
an edge of G(H)/hyperedge of H).
Clearly hypergraph unfoldings are acyclic in this sense, so that every hyper-
graph admits a bisimilar cover by an acyclic hypergraph. Conformality can
be achieved in ﬁnite conformal bisimilar hypergraph covers according to [31];
this, however, had left open the following for quite some time.
Question 6.4.6
Does every ﬁnite hypergraph admit bisimilar covers by ﬁnite
conformal and ℓ-acyclic hypergraphs, for all ℓ?
Recent progress [43, 44] shows that the answer is yes for a natural and
seemingly strongest possible notion of bounded acyclicity which forbids short
15 Treewidth is deﬁned to be one less than the maximal size of sets needed in a tree
decomposition, here bounded by the width of τ minus 1.

Fragments of FO and special classes of structures
325
chordless cycles.16 The following example shows that acyclicity cannot be
achieved even locally in ﬁnite bisimilar hypergraph covers.
Example
Consider a cartwheel hypergraph Hn consisting of an exterior cycle
of nodes a1, . . . , an, a1 plus a central node a, and with hyperedges {a, ai, ai+1}
for i ∈Z/nZ. The exterior cycle of length n is without chord, and any bisimilar
cover of Hn will still have cycles in the 1-neighbourhood of any node related
to a, albeit possibly longer cycles.
The positive resolution to Question 6.4.6 is also the starting point for proving
the ﬁnite model theory analogue of the classical characterisation theorem [2] for
GF in [43]. Previously, only the graph case, or the case of GF[τ] for relational
vocabularies of width 2, had been settled positively in [42].
6.4.3 Excursion: extension properties
The basic idea towards the construction of ﬁnite conformal bisimilar hypergraph
covers in [31] is quite simple – and surprisingly contrary to the intuition of an
unfolding. It essentially focuses on the footprints of forbidden cliques in the
associated graph G( ˆH). We illustrate the key idea with a (generic) local example
of the task.
Let, for instance, H = (A, S) be a ﬁnite hypergraph with a tuple of pair-
wise distinct nodes a = (a1, . . . , an) such that [a] = {a1, . . . , an} is a clique
in G(H) not contained in any hyperedge of H. We want to construct a bisim-
ilar cover π : ˆH →H by a ﬁnite hypergraph
ˆH = ( ˆA, ˆS) such that no lift
ˆa = (ˆa1, . . . , ˆan) with ˆai ∈π−1(ai) forms a clique in G( ˆH). Let A0 := A \ [a]
and put
ˆA := A0 ∪([a] × {1, . . . , n −1});
π↾A0 = id,
π(aj, i) = aj.
We now set ˆS to be the set of all subsets ˆs ⊆ˆA such that
(i) π↾ˆs is a bijection onto some s ∈S.
(ii) for (aj, i), (aj′, i′) ∈ˆs, if (aj, i) ̸= (aj′, i′), then i ̸= i′:
any two distinct nodes in ˆs above a must have distinct tags in {1, . . . ,
n −1}.
On one hand, one checks that π : ˆH →H is a bisimilar cover. Crucially, the
back-and-forth conditions do not give rise to requirements (of the back kind)
to produce a hyperedge ˆs whose projection to A would cover all of [a]: this
is clear, since [a] is not contained in any hyperedge of H. On the other hand,
16 A weaker notion of acyclicity is used to explore the ﬁnite model theory of the guarded and
clique guarded fragments in [5].

326
Martin Otto
condition (ii) rules out the possibility of a clique in G( ˆH) above a: if each pair
of components in ˆa were to be linked by a hyperedge, then they would have
to have pairwise distinct tags, which is impossible simply by the pigeon-hole
principle.
A uniform application of this idea, for all forbidden cliques simultaneously,
yields a ﬁnite conformal cover which moreover has useful automorphism prop-
erties [31].
An automorphism of a hypergraph is a permutation of its universe that
preserves the set of hyperedges. We say that the cover π : ˆH →H lifts auto-
morphisms of H if for every automorphism ρ of H there is an automorphism
of ˆH such that ρ ◦π = π ◦ˆρ. The cover is homogeneous, if for every pair of
hyperedges ˆs1, ˆs2 ∈ˆS above the same s ∈S, there is some automorphism σ of
ˆH mapping ˆs1 to ˆs2.
Lemma 6.4.7
Every ﬁnite hypergraph H = (A, S) admits a bisimilar cover
π : ˆH →H by some ﬁnite conformal hypergraph ˆH = ( ˆA, ˆS).
Every ﬁnite relational τ-structure A admits a guarded cover by some ﬁnite
τ-structure ˆA whose hypergraph of guarded subsets H( ˆA) is conformal.
Moreover, the cover can be chosen homogeneous and such that it lifts all
automorphisms of the base structure.
Herwig–Lascar extension theorems, EPPA
A local automorphism of a
τ-structure A is a partial bijection p of A that is an isomorphism between
the substructures induced on dom(p) and image(p). The following extension
theorem for local automorphisms is from [27], also compare [29].
Theorem 6.4.8 (Herwig)
Let A0 be a ﬁnite τ-structure. Then there is a ﬁnite
extension A1 ⊇A0 such that every local automorphism of A0 extends to a full
automorphism of A1. A1 can be chosen such that every guarded subset of A1
is the image under some automorphism of A1 of a guarded subset of A0.
The last condition is in the given situation in fact equivalent to saying that,
for every relation R ∈τ:
RA1 = 
ρ∈Aut(A1) ρ(RA0).
If A′
1 at ﬁrst only satisﬁes the automorphism extension property, and
G′ = Aut(A′
1), then replacing RA′
1 by 
ρ∈G′ ρ(RA0) preserves the automor-
phism extension property and yields a structure that also satisﬁes the additional
requirement on guarded subsets. A combination with Lemma 6.4.7 then gives
the following strengthening of the theorem [31].

Fragments of FO and special classes of structures
327
Corollary 6.4.9
For every ﬁnite A0 there is a ﬁnite extension A2 ⊇A0 such
that every local automorphism of A0 extends to a full automorphism of A2 and
such that every clique in G(A2) is the image under some automorphism of A2
of some clique in G(A0).
Proof. Let A1 ⊇A as in Theorem 6.4.8. Let H1 = (A1, S) be the hypergraph
with hyperedges
S =

ρ(A0): ρ ∈Aut(A1)

.
We may now apply Lemma 6.4.7 to obtain a conformal bisimilar cover π : ˆH →
H1 with hypergraph ˆH = ( ˆA, ˆS). The desired τ-structure A2 = ˆA is obtained
by interpreting the relations over the universe ˆA such that, for every ˆs ∈ˆS,
the local bijection π↾ˆs : ˆs →s becomes a local isomorphism between ˆA↾ˆs and
A1↾s. A0 may be isomorphically embedded into this new structure ˆA by singling
out any particular ˆs ∈ˆS above s = A0 ∈S. The automorphism properties of
the cover as stated in Lemma 6.4.7 guarantee that the local automorphisms of
the embedded A0 still extend to automorphisms of ˆA. And G( ˆA) does not have
any cliques other than those that are unavoidable automorphic copies of cliques
already present in the embedded A0: this is a consequence of the conformality
of ˆH and the fact that G( ˆA) consists of the union of the G( ˆA)↾ˆs for ˆs ∈ˆS, each
of which is an isomorphic copy of G(A0) by construction.
Further corollaries of this are (simpler proofs of) the extension theorem for
local automorphisms within the class of ﬁnite triangle-free graphs [27], the
class of ﬁnite clique-free graphs [28], or the class of ﬁnite relational structures
with conformal hypergraphs of guarded sets.
The corollary as stated has also been employed in [31] to yield a very
transparent proof of the ﬁnite model property of the clique guarded fragment,
just as Theorem 6.4.8 itself yields a very natural proof of the ﬁnite model
property for basic GF ﬁrst given by Gr¨adel [21].
6.5 Locality and special classes of relational structures
6.5.1 Tree-decompositions and treewidth
Bounded treewidth has emerged as one central notion of ‘tameness’ or ‘well-
behavedness’ in ﬁnite relational structures, which is useful both algorithmically
and model theoretically. For instance, model checking for ﬁrst-order or monadic
second-order formulae becomes more tractable if the input is restricted to ﬁnite

328
Martin Otto
structures of bounded treewidth. But also decidability issues, in particular sat-
isﬁability, can often be linked to a priori bounds on the treewidth of target
models – a phenomenon best known, and in its purest form, for logics with the
tree model property, e.g., due to bisimulation invariance. As pointed out above,
the bounded treewidth model property of logics invariant under guarded bisim-
ulation extends this beneﬁt to richer settings. Moreover, bounded treewidth has
featured in recent analogues to classical expressive completeness issues over
ﬁnite structures. While bounded treewidth certainly is not the only structural
restriction that helps to overcome well known obstacles in ﬁnite model theory,
it seems to occupy a central place in such concerns. We here mainly want to
discuss several such results, especially results concerning expressive complete-
ness for fragments of FO, in the light of connections with techniques stemming
form the fundamental notion of Gaifman locality.
Bounded treewidth is also at the center of Stephan Kreutzer’s chapter [39]
in this volume, where the algorithmic impact of bounded treewidth, among
other structural criteria, is treated in depth. There the reader will also ﬁnd a
much more detailed account of the connections between bounded treewidth and
model checking complexities for ﬁrst- and monadic second-order logic than
what is sketchily hinted at below.
Relational structures of bounded treewidth
We have already come across
a special form of tree decompositions in section 6.4.2, cf. Deﬁnition 6.4.3, and
now brieﬂy review the general notion of a tree decomposition underlying the
deﬁnition of treewidth.
Deﬁnition 6.5.1
A tree decomposition of the ﬁnite relational structure A
consists of a tree T together with a map ρ : T →P(A) associating subsets of
A with the nodes of T in such a manner that
(i) every relational ground atom of A is contained in some ρ(t).
(ii) for all a ∈A, {t ∈T : a ∈ρ(t)} ⊆T is connected in T .
The width of the tree decomposition (T, ρ) is maxt∈T |ρ(t)| −1.
The treewidth of A, tw(A) is the minimal width among all tree decompositions
of A.
Ck[τ] :=

A: tw(A) ⩽k

denotes the class of ﬁnite τ-structures of treewidth
up to k.
Note that (i) is the same as to say that the subsets used in a tree decomposition
of A must cover the guarded subsets.17 The correction by −1 in the deﬁnition
17 That they must not themselves be guarded subsets accounts for the difference in comparison
with Deﬁnition 6.4.3; a tree decomposition of A is a hypergraph decomposition of some
hypergraph that may be coarser than the hypergraph H(A) of guarded subsets.

Fragments of FO and special classes of structures
329
of treewidth is so that trees get treewidth 1 (rather than 2, which is the required
patch size).
Model checking complexity
For the complexity of the model checking prob-
lem for some logic L over the class C, one distinguishes
– combined complexity, where both ϕ ∈L and A ∈C vary, and the input
size is the sum of the input sizes, |ϕ| + ||A||;18
– data complexity, where the formula ϕ ∈L is ﬁxed, and the variation is in
the structure, with input size measure ||A||;
– expression complexity, with ﬁxed A and varying ϕ ∈L.
The following are some well known cornerstones for the model checking
complexity of monadic second-order logic MSO, FO and some fragments of
FO considered above:
– MSO model checking over Ck (treewidth k structures) has linear com-
bined complexity due to a fundamental theorem of Courcelle [12], where
“linear” refers to a complexity in O(||A|| · |ϕ|). On the class of all ﬁnite
graphs, on the other hand, MSO clearly captures graph properties at any
level of the polynomial hierarchy (this is w.r.t. data complexity).
– FO-formulae have logarithmic data complexity (i.e., poly-logarithmic in
||A|| or |A|, but with syntactic parameters of the formula in the exponent)
[15, 33].
– The combined complexity of FO model checking is complete for Pspace
(this is even true for formula complexity over the ﬁxed naked two-element
structure, by a simple reduction of the Pspace complete satisﬁability
problem for quantiﬁed boolean formulae).
– The combined complexity for model checking FOk, on the other hand,
is complete for Ptime for every k ⩾2, and even linear (in the sense of
O(||A|| · |ϕ|)) for ML as well as for GF, and still Ptime complete even
for ML, [48, 23, 8, 19].
Interestingly,
measures
of
tree-likeness
improve
model
checking
complexities – both on the side of the structure (e.g., model checking over
bounded treewidth structures) and on the side of the formula input (e.g., model
checking conjunctive queries with templates of bounded treewidth). We just
mention some key results with pointers to the literature, and again refer to [39]
for a more thorough treatment of some of these.
18 ||A|| stands for the size of a succinct encoding of the relational structure A. E.g., for graphs A
in an adjacency list encoding, ||A|| ∈O(n2), but it can be sub-quadratic in the number n = |A|
of vertices for graphs with few edges. Finer complexity accounts need to be based on a random
access model of computation, so that access to the input structure does not distort the real
algorithmic content of formula evaluation.

330
Martin Otto
FO data and combined complexity and local constraints
For FO data
complexity, Frick and Grohe [16] establish a linear bound over any class C
of structures whose treewidth is locally bounded. A class C of structures has
locally bounded treewidth if the treewidth of ℓ-neighbourhoods in structures
from C is uniformly bounded by some function in the radius ℓ. The underlying
model checking algorithm is based on a presentation of the formula in Gaifman
form. With this, the checking of ‘global’ structural properties reduces to local
evaluation of FO formulae in ℓ-neighbourhoods and a graph theoretic core
algorithm that checks for existence of scattered tuples in the Gaifman graph,
vertex-coloured according to the local pre-processing. For generalisations and
more recent successes of this approach to ﬁrst-order model checking complexity
in classes tamed by local conditions on graph invariants see Grohe’s survey
[26] as well as Kreutzer’s chapter [39] in this volume, with a view also to the
parameterised complexity of the combined model checking problem.
Combined complexity for fragments of FO
The combined complexity of
conjunctive query evaluation has been studied intensively, with a natural moti-
vation central to database theory and with interesting connections to constraint
satisfaction problems. Also in these investigations tree-likeness (in this case of
syntactic features of very special FO formulae) plays a major role. Conjunc-
tive query evaluation is the model checking of existential positive prenex FO
formulae whose quantiﬁer-free core is just a conjunction of relational atoms,
ϕ = ∃x 
i αi(xi) with atomic αi (in subtuples of variables xi of x). The link
with homomorphism problems and hence with constraint satisfaction (see for
instance [36, 38]) is natural and straightforward. The desired assignment to
variables x over the τ-structure A is a homomorphism from a τ-structure Xϕ
induced by the conjuncts αi on the set of variables [x] into A,
β : Xϕ
hom
−→A.
Note that while the data complexity is poly-logarithmic for each individual
(ﬁrst-order) ϕ or X, in general one expects an exponential dependency on the
number of variables in ϕ or on the size of X.
It turns out that the hypergraph H(Xϕ) holds one key to better bounds on
the complexity of the associated homomorphism/query evaluation problems.
In fact ϕ is (equivalent to a formula) in GF if H(Xϕ) is acyclic, in which
case model checking becomes linear in |ϕ|. Indeed, a tree decomposition of
H(Xϕ) yields a translation into GF and hence a reduction to the linear model
checking of GF. This generalises to ϕ with a ﬁxed bound on the treewidth of Xϕ,
where the model checking can be based on the auxiliary acyclic hypergraph of
bounded width extracted from the tree decomposition (instead of H(Xϕ) itself).

Fragments of FO and special classes of structures
331
In these cases, which admit considerable further extensions in terms of weaker
notions of bounded widths (e.g., bounded hypertreewidth rather than treewidth
[20]), combined model checking remains in Ptime [18, 20].
But also reductions to FOk can be seen as essential for tractability. For any
ﬁnite τ-structures X and A, the following are equivalent [13, 38]:
(i) existence of a homomorphism from X to A, X
hom
−→A;
(ii) A |= ∃xηX, where ηX is the positive diagram of X;
(iii) the transfer property X ⇒pos ∃∗A, meaning that every positive existen-
tial sentence true in X is also true in A.
For X = Xϕ, where ϕ is a conjunctive query, ϕ is equivalent to ∃xηX (cf. (ii)).
For X ∈Ck, this sentence is expressible in positive existential FOk+1 [37, 38], so
that (iii) above can be replaced by a transfer condition for all positive existential
FOk+1 rather than FO. In this context, therefore, the Ptime analysis of winning
positions in the (positively restricted, one-sided) (k + 1)-pebble game [35] on
X versus A decides the homomorphism problem.
6.5.2 Non-classical proofs for (variants of) classical
characterisations
With this section we return to expressive completeness issues, related to the
existential and the existential positive fragments of FO over classes of ﬁnite
structures. A ﬁrst-order sentence ϕ ∈FO[τ] is preserved under extensions if in
every substructure relationship A ⊆B between τ-structures, A |= ϕ implies
B |= ϕ. Similarly, ϕ is preserved under homomorphisms if for every homomor-
phism A
hom
−→B between τ-structures, A |= ϕ implies B |= ϕ. As an embed-
ding of a substructure is a special case of homomorphism, preservation under
homomorphisms implies preservation under extensions. Clearly, existential
sentences are preserved under extensions, while existential positive sentences
are even preserved under homomorphisms.
The classical results are the following. We explicitly state the more interest-
ing expressive completeness statements.
Theorem 6.5.2 (Łos–Tarski)
The existential fragment of ﬁrst-order logic
is expressively complete for ﬁrst-order properties that are preserved under
extensions.
Theorem 6.5.3 (Lyndon–Tarski)
The existential positive fragment of ﬁrst-
order logic is expressively complete for ﬁrst-order properties that are preserved
under homomorphisms.

332
Martin Otto
These are proved classically, e.g. in [11], by means of a compactness argu-
ment for the construction of suitable elementary extensions, respectively ele-
mentary chain constructions.
Classically, as well as towards possible restrictions of the expressive com-
pleteness claim to some class C other than the class of all τ-structures,
both essentially amount to ﬁniteness claims for classes of minimal models
(within C).
We refer to substructure minimal models as generators w.r.t. extensions,
and, as generators w.r.t. homomorphisms, also to so-called cores. In a class
closed under homomorphisms, the natural generators are simultaneously mini-
mal w.r.t. the weak substructure relationship and w.r.t. inverse homomorphisms.
We review some standard terminology in this connection.
A weak substructure relationship between τ-structures, denoted A ⊆w B,
requires that A ⊆B and RA ⊆RB for every relation R in τ (rather than
RA = RB↾A as in the substructure relationship A ⊆B). A retraction is a
homomorphism h from some structure A onto a weak substructure A0 ⊆w
A such that h↾A0 = id. It is worth noting that a retraction h: A
ret
−→A0 is
accompanied by a trivial inclusion homomorphism back from A0 into A, since
A0 ⊆w A. A structure whose only retraction is the identity is called a core.
Every ﬁnite relational structure A possesses a retract onto some core and this
core is unique up to isomorphism. It is then straightforward to see that a
homomorphism closed class of ﬁnite structures is generated by its members
that are cores; viz., generated as the class of all weak extensions of these. But
the subclass of ⊆w-minimal members generates the same class.
Deﬁnition 6.5.4
(a) A is a substructure minimal (⊆-minimal) model of ϕ if
A |= ϕ and A′ ̸|= ϕ for all A′ ⊊A.
(b) A is a weak-substructure minimal (⊆w-minimal) model of ϕ if A |= ϕ and
A′ ̸|= ϕ for all A′ ⊊w A.
(c) A is a core model of ϕ if A |= ϕ and A is a core.
Observation 6.5.5
Let C0 be a class of ﬁnite τ-structures that is closed under
extensions. Then the following are equivalent:
(i) C0 is deﬁnable (within the class of ﬁnite τ-structures) by an existential
ﬁrst-order sentence.
(ii) C0 has, up to isomorphism, ﬁnitely many substructure minimal members.
For the crucial direction, (ii) ⇒(i): if A1, . . . , AN are the isomorphism types
of substructure minimal members in C0, then C0 is deﬁnable by the disjunction
over the existentially quantiﬁed algebraic diagrams of the Ai. For (i) ⇒(ii) it

Fragments of FO and special classes of structures
333
sufﬁces to observe that the size of substructure minimal models of an existential
prenex sentence ϕ is bounded by the number of variables.
The above equivalence persists in restriction to any class C of τ-structures
that is itself closed under substructures (some such extra condition on the
surrounding class C is necessary for (i) ⇒(ii), not for (ii) ⇒(i)).
Similarly one obtains the following, where a disjunction over the existen-
tially quantiﬁed positive diagrams of ⊆w-minimal models, which are cores,
provides a canonical deﬁnition in existential positive FO. We state the equiv-
alence relative to the class of all (ﬁnite) τ-structures, but it similarly holds in
restriction to any class C of τ-structures that is closed, e.g., under substructures.
Observation 6.5.6
For any class C0 of (ﬁnite) τ-structures that is closed
under homomorphisms, the following are equivalent:
(i) C0 is deﬁnable (within the class of ﬁnite τ-structures) by a sentence in
existential positive FO.
(ii) C0 has, up to isomorphism, ﬁnitely many ⊆w-minimal members.
(iii) C0 has, up to isomorphism, ﬁnitely many ⊆-minimal members.
(iv) C0 has, up to isomorphism, ﬁnitely many homomorphism minimal core
members.
As we are dealing with ﬁnite relational vocabularies τ, a ﬁnite bound on the
number of isomorphism types of minimal models is equivalent to a bound on
the size of minimal models.
It has been known for a long time that the Łos–Tarski theorem (Theo-
rem 6.5.2) fails in the sense of ﬁnite model theory (with counterexamples due
to Tait and Gurevich, see e.g. [15]).
The status of the Lyndon–Tarski theorem (Theorem 6.5.3) in ﬁnite model
theory, on the other hand, had been an important open problem for quite some
time when it was resolved, positively, by Rossman [47].
Beside the overall ﬁnite model theory version, however, one may of course
investigate the status of these expressive completeness issues in restriction to
various classes of (ﬁnite) structures of interest. In the following sections we
outline a particular criterion of well-behavedness motivated by considerations
of Gaifman locality, which has led to interesting results along these lines.
Wideness criteria
The wideness criteria proposed in [4, 3] couple the existence of large scattered
subsets to the size of structures. In the context of the minimal model criteria as
in Observations 6.5.5 and 6.5.6 above they can be used to derive upper bounds
on the size of minimal models. Models exceeding a certain size cannot be

334
Martin Otto
minimal if their richness in scattered sets allows one to extract smaller models
on the basis of a Gaifman representation of the ﬁrst-order property at hand.
Deﬁnition 6.5.7
A structure is (ℓ, m)-wide if its Gaifman graph contains an
ℓ-scattered subset of size m.
A class C of τ-structures is called wide if there is a function N : N × N →N,
such that, for all ℓand m and A ∈C, if |A| ⩾N(ℓ, m), then A is (ℓ, m)-wide.
C is called almost wide if, for some ﬁxed k, the analogous condition applies
after the removal of a suitable subset of at most k elements from the structures
A at hand.
A typical example of a wide class is the class of graphs of ﬁxed bounded
degree. The class of trees, on the other hand, is not wide (there are arbitrarily
large trees of diameter 2), but almost wide: a large tree either has long branches
or a node of high degree; removal of a single node of high degree also produces
a large scattered set. Similarly, in a tree decomposition of ﬁxed bounded width
of a sufﬁciently large graph or relational structure, a large scattered set becomes
available at least after the removal of the elements associated with some high
degree node in the decomposition tree. A much more profound analysis is
necessary to show almost wideness for every class of graphs that excludes a
minor [4].
Proposition 6.5.8 (Atserias–Dawar–Kolaitis)
The class of treewidth k graphs
is almost wide. By extension, Ck[τ], the class of τ-structures of treewidth up to
k, is almost wide.
More generally, any class of graphs with excluded minor is almost wide,
and by extension any class of τ-structures whose Gaifman graphs avoid some
minor.
Expressive completeness for extension preservation
The following summarises key results from [3].
Theorem 6.5.9 (Atserias–Dawar–Grohe)
The size of ⊆-minimal models of a
ﬁrst-order sentence ϕ that is preserved under extensions can be bounded over
the following classes of ﬁnite structures:
(i) acyclic relational structures (i.e., directed coloured graphs with acyclic
Gaifman graphs);
(ii) wide classes C, like any class of graphs of bounded degree.
(iii) Ck, the class of all ﬁnite structures of treewidth up to k.
As a consequence, existential FO is expressively complete for ﬁrst-order prop-
erties preserved under extensions over these classes.

Fragments of FO and special classes of structures
335
Interestingly, there are almost wide classes over which existential FO is not
expressively complete for ﬁrst-order properties preserved under extensions. A
counterexample over the class of planar graphs is given in [3].
The underlying idea in the proof of the theorem is to choose parameters
ℓ, q, m from a Gaifman representation of ϕ, such that ϕ is preserved under
≡ℓ
q,m, and then to isolate a proper substructure A0 ⊊A that at the same time is
≡ℓ
q,m equivalent to some extension ˆA ⊇A, in any large enough model A. The
actual argument in [3] involves a sophisticated ﬁnite chain construction.
Expressive completeness for homomorphism preservation
The connection between wideness criteria and bounds on the number (or size)
of ⊆w-minimal models, which is crucial according to Observation 6.5.6, is pro-
vided by the following theorem. It stems from the analysis of the boundedness
problem for Datalog programs (least ﬁxpoint recursion over positive existential
FO) over ﬁnite structures.
Theorem 6.5.10 (Ajtai–Gurevich)
Let C be a class of ﬁnite τ-structures that
is closed under substructures and disjoint unions. If ϕ ∈FO is preserved under
homomorphisms within C, then there are ℓ, m ∈N such that no (ℓ, m)-wide
model of ϕ can be ⊆-minimal.
The same applies w.r.t. wideness after removal of up to k elements, for
ﬁxed k.
Corollary 6.5.11 (Atserias–Dawar–Kolaitis)
Over any class of ﬁnite struc-
tures that is almost wide and closed under substructures and disjoint unions,
existential positive FO is expressively complete for ﬁrst-order properties pre-
served under homomorphisms.
That minimal models cannot be too wide in the sense of Theorem 6.5.10,
comes from a Gaifman representation of ϕ. We sketch the argument that, for a
ﬁrst-order sentence ϕ that is preserved under ≡ℓ
q,m and under homomorphisms
(within C), there are L, M ∈N such that no (L, M)-wide model of ϕ can be
⊆w-minimal. More precisely, there are
r M, large enough w.r.t. L, Q, such that within any L-scattered subset of size
M in A |= ϕ we ﬁnd some pair of elements a ̸= b for which A, a ≡L
Q,0 A, b;
r L and Q, large enough w.r.t. ℓ, q, such that A, a ≡L
Q,0 A, b implies the
following transfer property for Gaifman rank (ℓ, q, 1)-assertions:
A ⇒ℓ
q,1 B := A↾(A \ {b}),

336
Martin Otto
meaning that every sentence of the form ∃xχ ℓ(x) where qr(χ) ⩽q that is
true in A remains true in B (A with b removed).19
M simply needs to be chosen large w.r.t. the number of quantiﬁer-rank Q
types of single elements (in their L-neighbourhood) in order to guarantee the
existence of distinct but ≡L
Q,0 equivalent nodes by the pigeon-hole principle.
For such a and b, the desired transfer of ∃xχ ℓ(x)-assertions follows from
≡L
Q,0 equivalence provided L ⩾2ℓand Q large enough so that for all qr(χ) ⩽q,
the assertion
∃x′
d(x, x′) ⩽ℓ∧χ ℓ(x′)

(∗)
is L-local and of quantiﬁer rank ⩽Q. Compare the diagram below for this
proof sketch. In the non-trivial case A |= χ ℓ[a′] for some a′ ∈Nℓ(b), so that
after the removal of b, there is no guarantee that still B |= χℓ[a′]. Using ≡L
Q,0
equivalence between a and b, though, (∗) is true of a if it is true at b. Hence there
is a corresponding b′ ∈Nℓ(a) such that A |= χℓ[b′]. So B |= χℓ[b′] follows,
since the L-neighbourhood of a is unaffected by the removal of b.
•a
A
•b
L
•
a
⇒q,1
•a
b
B
◦b
•
It follows that A ⊕m · B ≡ℓ
q,m m · B (with disjoint sums of m isomorphic
copies of B plus one copy of A on the left-hand side). Therefore, B |= ϕ is a
smaller model of ϕ:
A
hom
−→A ⊕m · B ≡ℓ
q,m m · B
hom
−→B.
Expressive completeness of the existential positive fragment of FO for
homomorphism preservation over the class of all ﬁnite relational structures –
the ﬁnite model theory version of the Lyndon–Tarski Theorem – has been
shown by Rossman in [47]. His approach is based on a combinatorial analysis
of existential positive types and saturation arguments for these, which can be
brought to a sufﬁcient level of closure in a ﬁnite chain construction. Leaving
aside much of the actual sophistication of the combinatorial analysis, there
19 Note that this is a one-directional transfer rather than an equivalence. E.g., in a graph
consisting just of a large cycle, the removal of any single element results in a structure that is
inequivalent in the sense of ≡1
1,1.

Fragments of FO and special classes of structures
337
is one aspect of Rossman’s approach that may deserve to be highlighted in
connection with the leading themes of this survey. That is the manner in which
the new argument is based on explicit model construction (as opposed to an
abstract model existence argument), and can be viewed as an upgrading (not
of an equivalence, but of a unidirectional transfer relationship) to approximate
ﬁrst-order equivalence, which is orthogonal to the classical argument. This is
an interesting parallel with the observations in section 6.3.2. While a traditional
proof of the Lyndon-Tarski Theorem can be based on the upgrading indicated
in the left-hand diagram, Rossman’s proof amounts to the upgrading indicated
in the right-hand diagram. In the traditional picture, transfer w.r.t. the full exis-
tential positive fragment of FO is upgraded, in a classical saturation argument
based on compactness, to yield a homomorphism between structures that are
elementarily equivalent to the original ones. In the ‘explicit’ construction of
Rossman’s, on the other hand, a speciﬁc ﬁnite level of transfer (existential pos-
itive formulae of quantiﬁer rank up to r) is upgraded to a speciﬁc ﬁnite level of
ﬁrst-order equivalence that preserves the given sentence ϕ.
A
⇒pos ∃

≡
B
≡
A∗
hom

B∗
A
⇒r
pos ∃

retract

B

retract

ˆA
≡q
ϕ
ˆB
Moreover, Rossman’s proof has a classical variant, in which the chain con-
struction is extended to an inﬁnite limit, that yields a completely new, alternative
proof of the classical Lyndon–Tarski result with added value. In fact, Rossman
shows that existential positive FO is expressively complete for ﬁrst-order sen-
tences preserved under homomorphisms, level-by-level w.r.t. quantiﬁer-rank.
In the classical model theory version of his proof, Rossman realises the above
upgrading for r = q, while in the ﬁnite model theory version there is no ele-
mentary bound on r in terms of q.
6.6 Concluding remarks
The focus on a model theory of well-behaved classes of (ﬁnite) structures –
adapted to speciﬁc application areas, or to the study of speciﬁc logics, or to
other speciﬁc model theoretic themes – offers promising perspectives for the

338
Martin Otto
development and ramiﬁcation of ﬁnite model theory. Finiteness as the only
constraint, which often entails ‘negative’ results, may not be the best choice
for many reasons.
It can be that the class of all ﬁnite structure is still not a good match for the
natural domain of reasoning for certain application areas; some model theoretic
answers – ‘positive’ or ‘negative’ – may still be ‘too easy’ over the class of all
ﬁnite structures. In modal reasoning, for instance, rootedness or connectivity
constraints are arguably essential in the intuitive modelling. More generally, the
‘generic ﬁnite structure that we mean’ may well have more speciﬁc structural
properties than an ‘arbitrary ﬁnite structure.’
It can also be that the class of all ﬁnite structures is too liberal a setting for
structural insights into certain issues. Deﬁnability and expressive completeness
results, for instance, that fail over the class of all ﬁnite structures may not
just be recovered but also clariﬁed overall through a better understanding of the
structural conditions that support them. In this sense there is not just ﬁnite model
theory, but there may be many adequate domains of structures for individual
issues.
I think both aspects are important from the modelling point of view (i.e.,
in relation to applications), also clearly from an algorithmic point of view, but
also from the point of view of classical issues in model theory. Sophisticated
adaptations of classical techniques, like the analysis of types and the use of
chain constructions in Rossman’s result, enrich ﬁnite model theory but also cast
fresh light on long-standing classical results. In this context the constructive
aspect of explicit model constructions or model transformations – in contrast
with smooth abstract existence proofs in classical model theory – is an important
methodological contribution.
It seems that the modularity in game-oriented arguments and model con-
structions, as illustrated by the power of an analysis in terms of Gaifman
locality, has had comparatively little impact on traditional classical model the-
ory. The great potential of another aspect of modularity, viz. decomposition
techniques, has apparently been realised more fully. The combination of such
aspects may lead to a better model theoretic view of more complex hierarchi-
cal decompositions in particular for ﬁnite structures; and there may be more
ﬂavours of structural regularity, smoothness or tameness in ﬁnite structures to
be discovered.

Bibliography
[1] Alon, N. 1995. Tools from Higher Algebra. Pages 1749–1783 of: Graham, R.,
Gr¨otschel, M., and Lovasz, L. (eds), Handbook of Combinatorics, vol. II. North-
Holland.
[2] Andr´eka, H., van Benthem, J., and N´emeti, I. 1998. Modal Languages and Bounded
Fragments of Predicate Logic. Journal of Philosophical Logic, 27, 217–274.
[3] Atserias, A., Dawar, A., and Grohe, M. 2005. Preservation under extensions on
well-behaved ﬁnite structures. Pages 1437–1449 of: Proceedings of 32nd Interna-
tional Colloquium on Automata, Languages and Programming ICALP’05. LNCS,
vol. 3580.
[4] Atserias, A., Dawar, A., and Kolaitis, P. 2006. On preservation under homo-
morphisms and unions of conjunctive queries. Journal of the ACM, 53, 208–
237.
[5] Barany, V., Gottlob, G., and Otto, M. 2010. Querying the guarded fragment. Pages
2–11 of: Proceedings of 25th Annual IEEE Symposium on Logic in Computer
Science LICS’10.
[6] Beeri, C., Fagin, R., Maier, D., and Yannakakis, M. 1983. On the desirability of
acyclic database schemes. Journal of the ACM, 30, 497–513.
[7] Berge, C. 1973. Graphs and Hypergraphs. North-Holland.
[8] Berwanger, D., and Gr¨adel, E. 2001. Games and Model Checking for Guarded
Logics. Pages 70–84 of: Proceedings of the 8th International Conference on Logic
for Programming and Automated Reasoning LPAR’01. LNCS, vol. 2250.
[9] Blackburn, P., de Rijke, M., and Venema, Y. 2001. Modal Logic. Cambridge Tracts
in Theoretical Computer Science. Cambridge University Press.
[10] Blackburn, P., van Benthem, J., and Wolter, F. (eds). 2007. Handbook of Modal
Logic. Elsevier.
[11] Chang, C. C., and Keisler, H. J. 1990. Model Theory. North-Holland.
[12] Courcelle, B. 1990. Graph rewriting: An algebraic and logic approach. Pages
194–242 of: van Leeuwen, J. (ed), Handbok of Theoretical Computer Science,
volume B. Elsevier.
[13] Dalmau, V., Kolaitis, P., and Vardi, M. 2002. Constraint satisfaction, bounded
treewidth, and ﬁnite-varaible logics. Pages 310–326 of: Proceedings of 8th Inter-
national Conference on Constraint Programming. LNCS, vol. 2470.
339

340
Martin Otto
[14] Dawar, A., and Otto, M. 2009. Modal characterisation theorems over special
classes of frames. Annals of Pure and Applied Logic, 161, 1–42. Extended journal
version of LICS’05 paper.
[15] Ebbinghaus, H.-D., and Flum, J. 1999. Finite Model Theory. 2nd edn. Springer.
[16] Frick, M., and Grohe, M. 2001. Deciding ﬁrst-order properties of locally tree-
decomposable structures. Journal of the ACM, 48, 1184–1206.
[17] Goranko, V., and Otto, M. 2007. Model Theory of Modal Logic. Pages 249–329
of: Blackburn, P., van Benthem, J., and Wolter, F. (eds), Handbook of Modal Logic.
Elsevier.
[18] Gottlob, G., Leone, N., and Scarcello, F. 2001. The complexity of acyclic conjunc-
tive queries. Journal of the ACM, 43, 431–498.
[19] Gottlob, G., Gr¨adel, E., and Veith, H. 2002a. Datalog LITE: A deductive query
language with linear time model checking. ACM Transactions on Computational
Logic, 3, 1–35.
[20] Gottlob, G., Leone, N., and Scarcello, F. 2002b. Hypertree decompositions and
tractable queries. Journal of Computer and System Sciences, 64, 579–627.
[21] Gr¨adel, E. 1999. On the restraining power of guards. Journal of Symbolic Logic,
64, 1719–1742.
[22] Gr¨adel, E. 2007. Finite model theory and descriptive complexity. Pages 125–230
of: Finite Model Theory and Its Applications. Springer.
[23] Gr¨adel, E., and Otto, M. 1999. On Logics with Two Variables. Theoretical Com-
puter Science, 224, 73–113.
[24] Gr¨adel, E., and Walukiewicz, I. 1999. Guarded ﬁxed point logic. Pages 45–54
of: Proceedings of 14th Annual IEEE Symposium on Logic in Computer Science
LICS’99.
[25] Gr¨adel, E., Hirsch, C., and Otto, M. 2002. Back and forth between guarded and
modal logics. ACM Transactions on Computational Logics, 3, 418–463.
[26] Grohe, M. 2008. Logic, graphs, and algorithms. Pages 357–422 of: Flum, J.,
Gr¨adel, E., and Wilke, T. (eds), Logic and Automata, History and Perspectives.
Amsterdam University Press.
[27] Herwig, B. 1995. Extending partial isomorphisms on ﬁnite structures. Combina-
torica, 15, 365–371.
[28] Herwig, B. 1998. Extending partial isomorphisms for the small index property of
many omega-categorical structures. Israel Journal of Mathematics, 107, 93–124.
[29] Herwig, B., and Lascar, D. 2000. Extending partial isomorphisms and the proﬁnite
topology on free groups. Transactions of the AMS, 352, 1985–2021.
[30] Hodges, W. 1993. Model Theory. Cambridge University Press.
[31] Hodkinson, I., and Otto, M. 2003. Finite conformal hypergraph covers and Gaifman
cliques in ﬁnite structures. Bulletin of Symbolic Logic, 9, 387–405.
[32] Hoogland, E., Marx, M., and Otto, M. 1999. Beth deﬁnability for the guarded
fragment. In: Gebrandy, J., Marx, M., de Rijke, M., and Venema, Y. (eds), JFAK –
Essays Dedicated to Johan van Benthem on the Occasion of his 50th Birthday.
Amsterdam University Press. CD-ROM.
[33] Immerman, N. 1998. Decsriptive Complexity. Graduate Texts in Computer Sci-
ence. Springer.
[34] Janin, D., and Walukiewicz, I. 1996. On the Expressive Completeness of the
Propositional mu-Calculus with Respect to Monadic Second Order Logic. Pages

Fragments of FO and special classes of structures
341
263–277 of: Proceedings of 7th International Conference on Concurrency Theory
CONCUR’96. LNCS, vol. 1119.
[35] Kolaitis, P. 2007. On the expressive power of logics on ﬁnite models. Pages 27–123
of: Finite Model Theory and Its Applications. Springer.
[36] Kolaitis, P., and Vardi, M. 2000a. Conjunctive-query containment and constraint
satisfaction. Journal of Computer and System Sciences, 61, 302–332.
[37] Kolaitis, P., and Vardi, M. 2000b. A game-theoretic approach to constraint sat-
isfaction. Pages 175–181 of: Proceedings of 0f 17th Conference on Artiﬁcial
Intelligence AAAI’00.
[38] Kolaitis, P., and Vardi, M. 2007. A logical approach to constraint satisfaction.
Pages 339–370 of: Finite Model Theory and Its Applications. Springer.
[39] Kreutzer, S. 2008. Algorithmic Meta-Theorems. In: Esparza, J., Michaux, C., and
Steinhorn, C. (eds), Finite and Algorithmic Model Theory. CUP. (this volume).
[40] Lorenz, K. 1968. Dialogspiele als semantische Grundlage von Logikkalk¨ulen.
Archiv f¨ur Mathematische Logik und Grundlagenforschung, 11, 32–55 and 73–
100.
[41] Lorenzen, P. 1961. Ein dialogisches Konstruktivit¨atskriterium. Pages 193–200 of:
Inﬁnitistic Methods, Proceedings of the Symposium on Foundations of Mathemat-
ics, Warsaw 1959. Oxford University Press.
[42] Otto, M. 2004. Modal and guarded characterisation theorems over ﬁnite transition
systems. Annals of Pure and Applied Logic, 130, 173–205.
[43] Otto, M. 2010a. Highly acyclic groups, hypergraph covers and the guarded frag-
ment. Pages 12–21 of: Proceedings of 25th Annual IEEE Symposium on Logic in
Computer Science LICS’10.
[44] Otto, M. 2010b. Highly acyclic groups, hypergraph covers and the guarded frag-
ment. Draft of extended version of LICS 2010 paper.
[45] Rabin, M. 1969. Decidability of second order theories and automata on inﬁnite
trees. Transactions of the AMS, 141, 1–35.
[46] Rosen, E. 1997. Modal logic over ﬁnite structures. Journal of Logic, Language
and Information, 6, 427–439.
[47] Rossman, B. 2008. Homomorphism preservation theorems. Journal of the ACM,
55.
[48] Vardi, M. 1995. On the complexity of bounded-variable queries. Pages 266–276 of:
Proceedings of 14th Annual ACM Symposium on Principles of Database Systems
PODS’95.
[49] Vardi, M. 1997. Why is modal logic so robustly decidable? Pages 149–184 of:
Immerman, N., and Kolaitis, P. (eds), Descriptive Complexity and Finite Models.
DIMACS Series in Discrete Mathematics and Theoretical Computer Science, vol.
31. AMS.
[50] Vardi, M. 2006. Games as an algorithmic construct. Tutorial, Isaac Newton Insti-
tute workshop on Games and Veriﬁcation (Logic and Algorithms programme).
[51] Weinstein, S. 2007. Unifying themes in ﬁnite model theory. Pages 1–25 of: Finite
Model Theory and Its Applications. Springer.


