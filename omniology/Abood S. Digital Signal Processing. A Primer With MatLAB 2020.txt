
Digital Signal Processing 
A Primer With MATLAB® 

Digital Signal Processing 
A Primer With MATLAB® 
Samir I. Abood 

MATLAB® is a trademark of The MathWorks, Inc. and is used with permission. The MathWorks does not warrant the accuracy 
of the text or exercises in this book. This book’s use or discussion of MATLAB® software or related products does not constitute 
endorsement or sponsorship by The MathWorks of a particular pedagogical approach or particular use of the MATLAB® software. 
CRC Press 
Taylor & Francis Group 
6000 Broken Sound Parkway NW, Suite 300 
Boca Raton, FL 33487-2742 
© 2020 by Taylor & Francis Group, LLC 
CRC Press is an imprint of Taylor & Francis Group, an Informa business 
No claim to original U.S. Government works 
Printed on acid-free paper 
International Standard Book Number-13: 978-0-367-44493-8 (Hardback) 
This book contains information obtained from authentic and highly regarded sources. Reasonable efforts have been made to pub-
lish reliable data and information, but the author and publisher cannot assume responsibility for the validity of all materials or the 
consequences of their use. The authors and publishers have attempted to trace the copyright holders of all material reproduced in 
this publication and apologize to copyright holders if permission to publish in this form has not been obtained. If any copyright 
material has not been acknowledged please write and let us know so we may rectify in any future reprint. 
Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or utilized in any 
form by any electronic, mechanical, or other means, now known or hereafter invented, including photocopying, microfilming, and 
recording, or in any information storage or retrieval system, without written permission from the publishers. 
For permission to photocopy or use material electronically from this work, please access www.copyright.com (http://www.copy-
right.com/) or contact the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 978-750-8400. 
CCC is a not-for-profit organization that provides licenses and registration for a variety of users. For organizations that have been 
granted a photocopy license by the CCC, a separate system of payment has been arranged. 
Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for identification 
and explanation without intent to infringe. 
Visit the Taylor & Francis Web site at 
http://www.taylorandfrancis.com 
and the CRC Press Web site at 
http://www.crcpress.com 

Dedicated to 
My great parents, who never stop giving of themselves in countless ways, 
My beloved brothers and sisters; 
My dearest wife, who offered me unconditional love  
with the light of hope and support; 
My beloved kids: Daniah, and Mustafa, whom I can't force myself to stop loving; 
To all my family, the symbol of love and giving. 


Contents 
Preface............................................................................................................................................ xiii 
Acknowledgments............................................................................................................................xv 
Author ............................................................................................................................................xvii 
Chapter 1 
Continuous and Discrete Signals .................................................................................1 
1.1 
Continuous Signals............................................................................................1 
1.1.1 
Generation of Continuous Signals in MATLAB .................................1 
1.1.2 
Operations on Signals and Sequences..................................................2 
1.2 
Discrete-Time Signals .......................................................................................5 
1.2.1 
Complex Sequences..............................................................................5 
1.3 
Signals and Systems ..........................................................................................6 
1.4 
Classification of Signals and Systems ...............................................................6 
1.4.1 
Continuous-Time and Discrete-Time Signals ......................................6 
1.4.2 
Analog and Digital Signals ..................................................................6 
1.4.3 
Deterministic and Random Signals......................................................6 
1.4.4 
Periodic and Nonperiodic Signals........................................................7 
1.4.5 
Power and Energy Signals....................................................................7 
1.4.5.1 
What Is Digital Signal Processing? ......................................7 
1.4.5.2 
Why DSP?.............................................................................7 
1.4.5.3 
Applications (DSP)...............................................................7 
1.5 
Introduction to MATLAB in DSP.....................................................................8 
1.5.1 
MATLAB Windows.............................................................................8 
1.5.2 
Basic Commands in MATLAB............................................................9 
1.6 
Some Fundamental Sequences........................................................................ 11 
1.6.1 
Impulse Response in MATLAB ........................................................ 11 
1.6.2 
Signal Duration .................................................................................. 12 
1.7 
Generation of Discrete Signals in MATLAB.................................................. 12 
Problems..................................................................................................................... 17 
Chapter 2 
Signals Properties....................................................................................................... 19 
2.1 
Periodic and Aperiodic Sequences..................................................................19 
2.2 
Even and Odd Parts of a Signal (Symmetric Sequences).................................20 
2.3 
Signal Manipulations.......................................................................................23 
2.3.1 
Transformations of the Independent Variable....................................23 
2.3.1.1 
Shifting ...............................................................................23 
2.3.1.2 
Reversal ..............................................................................23 
2.3.1.3 
Time-Scaling ......................................................................23 
2.3.1.4 
Addition, Multiplication, and Scaling ................................24 
2.3.1.5 
Addition ..............................................................................24 
2.3.1.6 
Multiplication......................................................................24 
2.3.1.7 
Scaling ................................................................................24 
2.3.1.8 
Signal Decomposition.........................................................24 
2.4 
Discrete-Time Systems....................................................................................25 
2.4.1 
System Properties...............................................................................25 
2.4.1.1 
Memoryless System............................................................25 
2.4.1.2 
Additivity............................................................................26 
vii 

viii 
Contents 
2.4.1.3 
Homogeneity.......................................................................26 
2.4.1.4 
Stability...............................................................................26 
2.5 
Linear Time-Invariant Causal Systems (LTI).................................................27 
2.5.1 
Linearity.............................................................................................27 
2.5.2 
Time-Invariance ................................................................................. 31 
2.5.3 
Causality............................................................................................. 32 
2.6 
Definitions .......................................................................................................36 
2.6.1 
Continuous-Time System ...................................................................36 
2.6.2 
Discrete-Time System ........................................................................37 
2.6.2.1 
Delay Operator....................................................................38 
2.6.2.2 
Convolution Property..........................................................38 
2.6.2.3 
Impulse Function................................................................38 
2.6.2.4 
Impulse Response...............................................................38 
2.6.2.5 
Frequency Response ...........................................................38 
2.7 
System Output .................................................................................................39 
2.7.1 
Causality.............................................................................................39 
2.7.2 
Stability ..............................................................................................39 
2.7.3 
Invertibility.........................................................................................40 
2.7.4 
Memory..............................................................................................40 
Problems.....................................................................................................................42 
Chapter 3 
Convolution ................................................................................................................ 47 
3.1 
Linear Convolution..........................................................................................47 
3.2 
Convolution Properties .................................................................................... 47 
3.2.1 
Commutative Property ....................................................................... 47 
3.2.2 
Associative Property ..........................................................................48 
3.2.3 
Distributive Property..........................................................................48 
3.3 
Types of Convolutions .....................................................................................48 
3.3.1 
Equations Method ..............................................................................49 
3.3.1.1 
Convolution of Two Sequences in MATLAB..................... 53 
3.3.2 
Graphical Method ..............................................................................54 
3.3.3 
Tabular Method .................................................................................. 55 
Problems.....................................................................................................................60 
Chapter 4 
Difference Equations..................................................................................................65 
4.1 
Difference Equations and Impulse Responses ................................................65 
4.2 
System Representation Using Its Impulse Response.......................................66 
4.3 
The Methods That One May Use to Solve the Difference Equations ............. 67 
4.4 
The Classical Approach...................................................................................68 
Problems.....................................................................................................................72 
Chapter 5 
Discrete-Time Fourier Series (DTFS)........................................................................ 75 
5.1 
DTFS Coefficients of Periodic Discrete Signals ............................................. 75 
5.2 
Parseval’s Relation...........................................................................................77 
5.3 
Discreet Fourier Series....................................................................................79 
Problems.....................................................................................................................83 

Contents 
ix 
Chapter 6 
Discrete-Time Fourier Transform (DTFT) ................................................................85 
6.1 
Frequency Response........................................................................................85 
6.2 
DTFT for Any Discrete Signal........................................................................87 
6.3 
Inverse DTFT ..................................................................................................88 
6.4 
Interconnection of Systems .............................................................................89 
6.5 
DTFT Properties ............................................................................................. 91 
6.6 
Applications of DTFT ..................................................................................... 91 
6.7 
LSI Systems and Difference Equations........................................................... 91 
6.8 
Solving Difference Equations Using DTFT....................................................93 
6.9 
Frequency Response in MATLAB................................................................ 102 
Problems...................................................................................................................106 
Chapter 7 
Discrete Fourier Transform (DFT) .......................................................................... 109 
7.1 
Method of Decimation-in-Frequency............................................................109 
7.2 
Method of Decimation-in-Time..................................................................... 112 
7.3 
Properties of Discrete Fourier Transform ..................................................... 117 
7.4 
Discrete Fourier Transform of a Sequence in MATLAB ............................. 122 
7.5 
Linear Convolution Using the DFT...............................................................123 
7.6 
Generation of Inverse Discrete Fourier Transform in MATLAB.................124 
Problems...................................................................................................................125 
Chapter 8 
Fast Fourier Transform (FFT).................................................................................. 129 
8.1 
Fast Fourier Transform Definition................................................................. 129 
8.1.1 
Decimation-in-Time FFT ................................................................. 129 
8.1.2 
Decimation-in-Frequency FFT ........................................................ 129 
8.2 
Finding the FFT of Different Signals in MATLAB...................................... 134 
8.3 
Power Spectral Density Using Square Magnitude and Autocorrelation ....... 135 
8.3.1 
Equivalence of FFT and N-phase Sequence Component 
Transformation .................................................................................136 
Problems................................................................................................................... 140 
Chapter 9 
Z-Transform.............................................................................................................. 143 
9.1 
Z-Transform Representation.......................................................................... 143 
9.2 
Region of Convergence (ROC)...................................................................... 144 
9.3 
Properties of the z-transform ......................................................................... 147 
9.4 
Inverse z-transform........................................................................................ 151 
9.4.1 
Partial Fraction Expansion and a Look-up Table.............................151 
9.4.2 
Power Series .....................................................................................154 
9.4.3 
Contour Integration ..........................................................................154 
Problems................................................................................................................... 163 
Chapter 10 Z-Transform Applications in DSP............................................................................ 165 
10.1 Evaluation of LTI System Response Using Z-Transform .............................. 165 
10.2 Digital System Implementation from Its Function........................................ 165 
10.3 Pole-Zero Diagrams for a Function in the z-Domain.................................... 172 
10.4 Frequency Response Using z-Transform ....................................................... 172 
Problems................................................................................................................... 174 

x 
Contents 
Chapter 11 Pole-Zero Stability ................................................................................................... 179 
11.1 Concept Poles and Zeros ............................................................................... 179 
11.1.1 Stability Determination Based z-Transform..................................... 179 
11.1.2 The Z-Transform .............................................................................. 179 
11.1.3 The “z-Plane” ................................................................................... 180 
11.2 Difference Equation and Transfer Function.................................................. 180 
11.3 BIBO Stability ............................................................................................... 182 
11.4 The z-Plane Pole-Zero Plot and Stability ...................................................... 183 
11.5 Stability Rules ............................................................................................... 184 
Problems................................................................................................................... 191 
Chapter 12 Sampling................................................................................................................... 193 
12.1 Relating the FT to the DTFT for Discrete-Time Signals .............................. 193 
12.2 Sampling........................................................................................................ 194 
12.3 Band-Limited Signals.................................................................................... 194 
12.4 Sampling of Continuous-Time Signals.......................................................... 194 
12.5 Sampling Theorem ........................................................................................ 196 
12.6 Band-Pass Sampling......................................................................................200 
12.7 Quantization ..................................................................................................200 
12.8 Uniform and Non-Uniform Quantization...................................................... 201 
12.9 Audio Sampling.............................................................................................205 
12.10 Sampling Rate ...............................................................................................205 
Problems...................................................................................................................205 
Chapter 13 Digital Filters ...........................................................................................................209 
13.1 Types Of Filters.............................................................................................209 
13.1.1 Low-Pass Filters...............................................................................209 
13.1.2 High-Pass Filters ..............................................................................209 
13.1.3 Band-Pass Filters..............................................................................209 
13.1.4 Band-Stop Filters..............................................................................209 
13.2 Infinite-Impulse-Response (IIR) Digital Filter ............................................. 212 
13.2.1 Design of Filters Using Bilinear Transformation ............................ 213 
13.2.2 Infinite-Impulse Response Filtering................................................. 215 
13.2.3 Filter Characteristics ........................................................................ 216 
13.3 Finite Impulse Response (FIR) Digital Filter................................................ 217 
13.3.1 The Advantages of FIR Filters......................................................... 218 
13.3.2 FIR Specifications............................................................................ 218 
13.3.3 Gibbs Phenomenon and Different Windowing ................................ 219 
13.4 Comparison of IIR and FIR Digital Filters................................................... 219 
Problems...................................................................................................................220 
Chapter 14 Implementation of IIR..............................................................................................223 
14.1 Direction-Form I Realization........................................................................223 
14.2 Direction-Form II Realization.......................................................................224 
14.3 Cascade (Series) Realization .........................................................................225 
14.4 Parallel Realization .......................................................................................226 
14.5 Transposed-Direct-Form-I............................................................................. 231 
14.6 Transposed-Direct-Form-II ........................................................................... 232 

Contents 
xi 
14.7 Implementation of a Notch Filter by MATLAB ...........................................234 
14.8 Implementation of Infinite-Impulse Response Filters...................................237 
14.8.1 
Analog-to-Digital Filter Design .......................................................237 
14.8.2 Bilinear Transformation...................................................................237 
Problems...................................................................................................................239 
Chapter 15 Implementation of FIR............................................................................................. 241 
15.1 Finite Impulse Response Filter Representation............................................. 241 
15.2 Window Method............................................................................................246 
15.3 FIR-Filter Length Estimation Using Window Functions .............................. 252 
Problems...................................................................................................................259 
Chapter 16 Digital Filter Design.................................................................................................263 
16.1 IIR Filter Design............................................................................................263 
16.1.1 
Analog-Filter Design........................................................................263 
16.1.2 
Bilinear Transformation (IIR Digital Filter)....................................273 
16.1.3 
Higher-Order IIR Digital Filters ......................................................277 
16.1.4 
IIR Digital High-Pass, Band-Pass, and Band-Stop   
Filter Design.....................................................................................279 
16.1.5 
Design a IIR Low-Pass Filter Using MATLAB...............................282 
16.1.6 
Design a IIR High-Pass Filter Using MATLAB..............................283 
16.1.7 
Design an IIR Band-Pass Filter Using MATLAB ...........................284 
16.2 FIR-Filter Design...........................................................................................285 
16.2.1 Design of FIR Filters Using Windows.............................................286 
Problems...................................................................................................................292 
Selected Bibliography ..................................................................................................................295 
Appendix A: Complex Numbers.................................................................................................297 
Appendix B: Mathematical Formulas........................................................................................301 
Appendix C: MATLAB ...............................................................................................................309 
Index.............................................................................................................................................. 315 


Preface 
Digital signal processing (DSP) denotes various techniques for improving the accuracy and reli-
ability of digital communications. The philosophy behind DSP is quite complicated. Digital signal 
processing converts signals from an analog form into digital data that can then be analyzed and 
consequently turned back into an analog signal with improved quality after the DSP system has 
finished its work. 
In DSP, the engineers usually study digital signals in one of the following domains: time domains, 
frequency domains, spatial domains, and wavelet domains. 
The applications of DSP include digital image processing, audio signal processing, audio com-
pression, speech processing, video compression, digital communications, digital synthesizers, 
speech recognition radar systems, ultrasound and sonar, financial signal processing, seismology, 
and biomedicine. 
The DSP algorithms can be run on general-purpose computers and implemented using soft-
ware code program, and Simulink also can implement by using hardware as modern technologies 
for digital signal processing include more powerful general-purpose controllers, microprocessors, 
stream processors, and field-programmable gate arrays (FPGAs). 
The typical processing approach in the time domain is an improvement of the input signal 
through a method called filtering. In digital filters there are two types of filter with and without 
feedback. There are various ways to characterize filters: as a linear filter, causal filter, time-invariant 
filter, stable filter, finite impulse response (FIR) filter, and infinite impulse response (IIR) filter. 
The signals are converted from the time domain to the frequency domain usually through the use 
of the Fourier Transform. The Fourier Transform, also called spectrum or spectral analysis, con-
verts the time information into a magnitude and phase component of each frequency. The engineer 
needs to study the spectrum to control which frequencies are present in the input signal and which 
are missing. 
Digital filters originate in both IIR and FIR types. While FIR filters are always stable, IIR filters 
have feedback loops that may become unstable and oscillate. Digital filters can be analyzed through 
the z-transform, which provides a tool for analyzing stability issues of digital IIR filters. Also, it is 
analogous to the analyse and designs analog IIR filters represent the Laplace transform 
The book offers a good understanding of a signal’s behavior and its applications. The book 
begins with the study of signals and systems. Then it presents their applications in the different 
types of configurations shown in lucid detail. The book presents the relation of signals and systems. 
This book is intended for college students, both in community colleges and universities. 
This book is organized into 16 chapters. With a short review of the basic concept of continuous 
and discrete signals in Chapter 1, it starts with a discussion of continuous and discrete signals and 
the generation of continuous and discrete signals in MATLAB®. It also discusses the classification 
of signals and systems, MATLAB in DSP, and the applications of DSP. Chapter 2 presents signal 
properties as periodic and aperiodic sequences, even and odd parts of a signal, transformations of 
the independent variable, and linear time-invariant causal systems (LTI). The description of linear 
convolution, convolution properties, and types of convolutions is discussed in Chapter 3. 
Chapter 4 covers difference equations, and system representation using impulse response. Chapter 
5 deals with the Discrete-Time Fourier Series (DTFS) coefficients of periodic discrete signals. It 
includes the Discreet Fourier Series of the discrete systems. Discrete-Time Fourier Transform 
(DTFT), frequency response, DTFT for discrete signals, and the interconnection of systems in 
the frequency domain are covered in Chapter 6. Discrete Fourier Transform algorithms (DFT) are 
included in Chapter 7. The chapter also elaborates on the method of decimation-in-frequency and 
in time. 
xiii 

xiv 
Preface 
In Chapter 8, the principles of the Fast Fourier Transform, decimation-in-frequency method, and 
decimation-in-time method are examined. Chapter 9 discusses the z-transform, region of conver-
gence (roc), properties of the z-transform, and it also discusses the inverse of z-transform. Chapter 
10 describes the z-transform applications in DSP for evaluating LTI system responses using z-trans-
form and implementation of the system using z-transform. Chapter 11 introduces pole-zero stability, 
difference equations and transfer function, and the stability of DSP systems. 
Chapter 12 discusses sampling relating the FT to the DTFT for discrete-time signals, the sam-
pling of continuous-time signals, and instantaneous sampling. The description of digital filters and 
filter types and specifications is discussed in Chapter 13. Chapter 14 presents the implementation of 
IIR digital filters and their properties and the design of a notch filter by MATLAB. 
Chapter 15 deals with the implementation of Finite Impulse Response (FIR), and it is design. 
Chapter 16 deals with the digital filter design, the realization of digital filters, and direction-form 
I realization. 
Earlier experience using the MATLAB program is not needed since the author highly recom-
mends that the reader studies this material in conjunction with the MATLAB Student Version. 
Chapter 1 and Appendix C of this text provides a practical introduction to MATLAB. 
MATLAB® is a registered trademark of The MathWorks, Inc. For product information, please 
contact: 
The MathWorks, Inc. 
3 Apple Hill Drive 
Natick, MA 01760-2098 USA 
Tel: 508 647 7000 
Fax: 508-647-7001 
E-mail: info@mathworks.com 
Web: www.mathworks.com 

Acknowledgments 
I appreciate the suggestions and comments from several reviewers, including assistance from 
Prof. Zainab Ibrahim/University of Baghdad/Electrical Engineering Department, Dr. Muna Fayyadh/ 
Colorado Technical University, and special thanks to Nafisa Islam/Prairie View A&M University 
Their frank and positive criticisms led to considerable improvement of this work. 
Finally, I express my profound gratitude to my wife and children, without whose cooperation 
this project would have been challenging if not impossible. We appreciate feedback from students, 
professors, and other users of this book. I can be reached at sameeralrifaee74@ieee.org sabood@ 
student.pvamu.edu and sameeralrifaee74@gmail.com. 
xv 


Author 
Samir I. Abood received his BSc and MSc from the University of Technology, Baghdad, Iraq, in 
1996 and 2001, respectively. From 1997 to 2001, he worked as an engineer at the same university. 
From 2001 to 2003, he was an assistant professor at the University of Baghdad and AL-Nahrain 
University, and from 2003 to 2016, he was an assistant professor at Middle Technical University 
University, Baghdad, Iraq. Presently, he is doing his PhD in the Electrical and Computer Engineering 
Department at Prairie View A&M University, Prairie View, Texas. He is the author of 25 papers and 
four books. His main research interests are in the area of sustainable power and energy systems, 
microgrids, power electronics, and motor drives, the application of digital PID controllers, digital 
methods to electrical measurements, digital signal processing, and control systems. 
xvii 


1 Continuous and  
Discrete Signals 
Mathematically, signals are represented as a function of one or more independent variables. At 
this point, we are focusing the attention on signals that involve a single independent variable. 
Conventionally, it will generally refer to the independent variable as time. There are two types of 
signals: continuous-time signals and discrete-time signals. In this chapter will focus on the kinds 
of signals 
This chapter gives you a quick way to become familiar with the MATLAB software by introduc-
ing you the basic features, commands, and functions. You will discover that entering and solving 
complex numbers in MATLAB is as easy as entering and solving real numbers, especially with the 
help of MATLAB built-in complex functions. Upon completion this chapter, and Appendix A you 
should know how to start MATLAB, how to get HELP, how to assign variables in MATLAB and 
to perform the typical complex numbers operations (i.e., complex conjugate, addition, subtraction, 
multiplication, division, expression simplification) and the conversions of complex numbers in both 
rectangular and polar forms with and without using MATLAB built-in functions. 
1.1 CONTINUOUS SIGNALS 
The continuous-time signal is the signals or quantities that can be defined and represented at certain 
time instants of the sequence. A speech signal as a function of time can be classified as a contin-
uous-time signal while the discrete-time signal is the signals or quantities that can be defined and 
represented at certain time instants of the sequence. The weekly Dow Jones stock market index is 
an example of a discrete-time signal. 
To distinguish between continuous-time and discrete-time signals, we use the symbol “t” to 
denote the continuous variable and “n” to indicate the discrete-time variable. And for the contin-
uous-time signals, we will enclose the independent variable in parentheses (•), for discrete-time 
signals we will insert the independent variable in square brackets [•]. 
A discrete-time signal [nx] may represent a phenomenon for which the independent variable 
is inherently discrete. Also, a discrete-time signal [nx] may represent successive samples of an 
underlying aspect for which the independent variable is continuous. For example, the processing of 
speech on a digital computer requires the use of a discrete-time sequence representing the values 
of the continuous-time speech signal at discrete points of time. Mostly, it is important to consider 
signals as related through a modification of the independent variable. These modifications will usu-
ally lead the signal to reflection, scaling, and shift. 
1.1.1 Generation of Continuous siGnals in MatlaB 
The following is a MATLAB program to generate continuous-time signals like unit step, sawtooth, 
triangular, sinusoidal, ramp, and sinc function. 
%generate unit Step 
clc; 
clear all; 
close all; 
t=-20:0.01:20; 
1 

2 
Digital Signal Processing 
L=length(t); 
for i=1:L 
if t(i)<0 
x1(i)=0; 
x2(i)=0; 
else 
x1(i)=1; 
x2(i)=t(i); 
end; 
end; 
figure; 
plot(t,x1); 
xlabel('t'); 
ylabel('amplitude'); 
title('unit step'); 
grid 
Figure 1.1 shows the output after running the program. 
1.1.2 operations on siGnals and sequenCes 
To perform various operations on signals such as addition, multiplication, scaling, shifting, and 
folding using the MATLAB program follow the below. 
%Sum of two signals 
clc; 
close all; 
clear all; 
t=0:0.001:1; 
L=length(t); 
f1=1; 
f2=3; 
x1=sin(2*pi*f1*t); 
unit step 
amplitude 
1 
0.8 
0.6 
0.4 
0.2 
0 
–20 
–15 
–10 
–5 
0 
5 
10 
15 
20 
t 
FIGURE 1.1 Generation of the unit step function. 

3 
Continuous and Discrete Signals 
x2=sin(2*pi*f2*t); 
figure; 
subplot(2,1,1); 
plot(t,x1,’b’,t,x2,’r’); 
xlabel(‘t’); 
ylabel(‘amplitude’); 
title(‘The signals x1(t) and x2(t)’); 
x3=x1+x2; 
subplot(2,1,2); 
plot(t,x3); 
xlabel(‘t’); 
ylabel(‘amplitude’); 
title(‘The sum of x1(t) and x2(t)’); 
Figure 1.2 Shows the results obtained from the sum of the two functions. 
% Multiplication of two signals 
clc; 
close all; 
clear all; 
t=0:0.001:1; 
L=length(t); 
f1=1; 
f2=3; 
x1=sin(2*pi*f1*t); 
x2=sin(2*pi*f2*t); 
figure; 
subplot(2,1,1); 
plot(t,x1,’b’,t,x2,’r’); 
xlabel(‘t’); 
ylabel(‘amplitude’); 
title(‘The signals x1(t) and x2(t)’); 
x4=x1.*x2; 
subplot(2,1,2); 
plot(t,x4); 
xlabel(‘t’); 
ylabel(‘amplitude’); 
title(‘The multiplication of x1(t) and x2(t)’); 
The signals x1(t) and x2(t) 
–1 
0 
1
amplitude 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1 
t 
The sum of x1(t) and x2(t) 
2 
–2 
0
amplitude 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1 
t 
FIGURE 1.2 The sum of functions. 

4 
Digital Signal Processing 
The signals x1(t) and x2(t) 
amplitude 
amplitude
1 
0 
–1 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1 
t 
The multiplication of x1(t) and x2(t)
1 
0 
–1 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1 
t 
FIGURE 1.3 The multiplying of two functions. 
Figure 1.3 shows the results obtained from multiplying the two functions. 
% Shifting of two signals 
clc; 
close all; 
clear all; 
t=0:0.001:1; 
L=length(t); 
f1=1; 
f2=3; 
x1=sin(2*pi*f1*t); 
x2=sin(2*pi*f2*t); 
figure; 
subplot(2,1,1); 
plot(t,x1,’b’,t,x2,’r’); 
xlabel(‘t’); 
ylabel(‘amplitude’); 
title(‘The signals x1(t) and x2(t)’); 
The signals x1(t) and x2(t) 
1 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1 
t 
the shifting of x1(t)and x2(t)
1 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1 
t 
–1 
0
amplitude 
–1 
0
amplitude 
FIGURE 1.4 The Shifting function. 

Continuous and Discrete Signals 
5 
x3=[zeros(1,100),x2(1☹L-100))]; 
subplot(2,1,2); 
plot(t,x3); 
title(‘the shifting of x1(t)and x2(t)’); 
xlabel(‘t’); 
ylabel(‘amplitude’); 
Figure 1.4 shows the results obtained from shifting the function. 
1.2 DISCRETE-TIME SIGNALS 
A discrete-time signal is an indexed sequence of real, imaginary, or complex numbers, and it 
is a function of an integer-valued n that is denoted by x(n). Although the independent variable 
n need not necessarily represent “time” (n may, for example, correspond to a spatial coordinate 
or distance), x(n) is generally referred to as a function of time. Figure 1.5 shows a real-valued 
signal x(n). 
In some problems and applications, it is convenient to view x(n) as a vector. Thus, the sequence 
values x(0) to x(N – 1) may often be considered to be the elements of a column vector as follows: 
X = [x( ), (  ), 
0 x 1 … x N 
]
, (  −1) 
T 
(1.1) 
Discrete-time signals are often derived from sampling a continuous-time signal, such as speech, 
with an analog-to-digital (A/D) converter. For example, a continuous-time signal x(n) that is sam-
pled at a rate of fs = l/Ts samples per second produces the sampled signal x(n), which is related to 
xa(t) as follows: 
x n  
x
n( 
(1.2) 
( )  = 
a 
Ts) 
1.2.1 CoMplex sequenCes 
Generally, a discrete-time signal may be complex-valued. A complex signal can be expressed either 
in terms of its real or imaginary parts, 
z n  = a n  + 
( )  = Re{z n
 
} + j Im {z n }
( )  ( )  j b n
 ( )  
( )
(1.3) 
or in the polar form in terms of its magnitude and phase, 
x(n) 
–2 –1 
0
1 
2 
3 
4
5 
6 
n 
FIGURE 1.5 Generation of a discrete function. 

6 
Digital Signal Processing 
z n  =
( )  z n
( )  exp  j 
{z n }
arg
(
 ) 
(1.4) 
The magnitude may be derived from the real and imaginary parts as follows: 
2
2 
2
z n
( )  = Re z n
( )} + Im z n  }
{
{ ( )
(1.5) 
Whereas the phase may be found using 
−1 Im {z n
( )}
arg{z n  
tan Re z n  } 
(1.6) 
( )} = 
{ ( )  
If z(n) is a complex sequence, the complex conjugate, denoted by z*(n), is formed by changing the 
sign on the imaginary part of z(n): 
* 
( )} − 
( )
z = Re{z n 
j Im {z n  } = z n
( )  
− j arg z n }
exp
 
{ ( )  
(1.7) 
1.3 SIGNALS AND SYSTEMS 
Signals and systems are important for expressing the mathematical model in the modern commu-
nication system. Signals are time-varying quantities such as voltages or current. And, the system 
is a combination of devices and networks (subsystems) that are chosen to perform the desired 
function. Because of the sophistication of modern communication systems, a great deal of analysis 
and experimentation with trial subsystems occurs before the actual building of the desired system. 
Therefore, the communication engineer’s tools are the mathematical models for producing signals 
and systems. 
1.4 CLASSIFICATION OF SIGNALS AND SYSTEMS 
The signals and systems are classified into: 
1.4.1 Continuous-tiMe and disCrete-tiMe siGnals 
By the term continuous-time signal, we mean a real or complex function of time s(t), where the 
independent variable t is continuous. 
If t is a discrete variable, i.e., s(t) is defined at discrete times, then the signal s(t) is a discrete-time 
signal. A discrete-time signal is often identified as a sequence of numbers, denoted by {s(n)}, where 
n is an integer. 
1.4.2 analoG and diGital siGnals 
If a continuous-time signal s(t) can take on any values in a continuous-time interval, then s(t) is 
called an analog signal. 
If a discrete-time signal can take on only a finite number of distinct values, {s(n)}, then the signal 
is called a digital signal. 
1.4.3 deterMinistiC and randoM siGnals 
Deterministic signals are those signals whose values are completely specified for any given time. 
Random signals are those signals that take random values at any given times. 

Continuous and Discrete Signals 
7 
1.4.4 periodiC and nonperiodiC siGnals 
A signal s(t) is a periodic signal if s(t) = s(t + nT0), where T0 is called the period and the integer 
n > 0. 
If s(t) ≠s(t + T0) for all t and any T0, then s(t) is a nonperiodic or a periodic signal. 
1.4.5 power and enerGy siGnals 
A complex signal s(t) is a power signal if the average normalized power P is finite, where 
T /2 
1
*
P = lim ∫ s t s t dt 
( )  
0 < P < ∞
( )  
(1.8) 
T →∞ T 
−T /2 
and s*(t) is the complex conjugate of s(t). 
A complicated signal s(t) is an energy signal if the normalized energy E is finite, where 
∞
∞ 
2
E = ∫s( )t s  
*( )t dt
 
= ∫ s t
dt 0 
E
( )  
<
< ∞ 
(1.9) 
−∞ 
−∞ 
In communication systems, the received waveform is usually categorized into the desired part that 
contains the information signal and the undesired part, which is called noise. 
1.4.5.1 What Is Digital Signal Processing? 
A signal is a function of a set of independent variables with time being perhaps the most prevalent 
single variable. The signal itself carries some kind of information available for observation. By the 
term processing, we mean operating in some fashion on a signal to extract some useful information. 
In many cases, this processing will be a nondestructive “transformation” of the given data signal; 
however, some essential processing methods turn out to be irreversible and thus destructive. Also, 
the word digital means that the processing is done with a digital computer or particular purpose 
digital hardware. 
1.4.5.2 Why DSP? 
• Rapid advancement in integrated circuit design and manufacture, which leads to more pro-
duction of powerful DSP system on a single chip with decreasing size and cost. 
• Digital processing is inherently stable and reliable. 
• In many cases, DSP is used to process several signals simultaneously; it is done by using a 
technique known as “TDM” (time-division-multiplexing). 
• Digital implementation permits easy adjustment of process characteristics during 
processing, such as that needed for implementing adaptive circuits. 
1.4.5.3 Applications (DSP) 
• Spectral Analysis 
• Speech Recognition 
• Biomedical Signal Analysis 
• Digital Filtering 
• Digital Modems 
• Data Encryption 
• Image Enhancement and Compression 

8 
Digital Signal Processing 
1.5 INTRODUCTION TO MATLAB IN DSP 
MATLAB, which stands for Matrix Laboratory, is a compelling program for performing numerical 
and symbolic calculations. It is widely used in science and engineering, as well as in mathematics. 
The basics of the technical language of MATLAB is a technical language to ease scientific compu-
tations, and the name derived from Matrix Laboratory. It provides many of the attributes of spread-
sheets and programming languages. MATLAB is a case sensitive language (a variable named “c” is 
different than another one called “C”). In interactive mode, MATLAB scripts are platform indepen-
dent (right for cross-platform portability). MATLAB works with matrices. Everything MATLAB 
understands is a matrix (from text to large cell arrays and structure arrays). The MATLAB environ-
ment shown in Figure 1.6. 
1.5.1 MatlaB windows 
MATLAB works through three basic windows. 
Command window: This is the main window. It is characterized by the MATLAB command 
prompt “>>.” When you launch the MATLAB application, the program starts with window and all 
commands, including those for user-written programs, are typed into this window at the MATLAB 
prompt. 
Graphics window: The output of all graphics commands typed in the command window are 
flushed to the graphics or figure window, which is a separate gray window with a white background 
color. The user can create as many windows as the system memory will allow. 
Edit window: This is where you write, edit, create, and save your programs in files called M 
files. 
Input–output: MATLAB supports interactive computation taking the input from the screen and 
flushing the output to the screen. Also, it can read input files and write output files. 
Data type: The fundamental data type in MATLAB is the array. It encompasses several distinct 
data objects-integers, real numbers, matrices, character strings, structures, and cells. There is no 
need to declare variables as real or complex; MATLAB automatically sets the variable as real. 
FIGURE 1.6 The MATLAB environment. 

8 
Continuous and Discrete Signals 
9 
Dimensioning: Dimensioning is automatic in MATLAB. No dimension statements are required 
for vectors or arrays. We can find the dimensions of an existing matrix or a vector with the size and 
length commands. 
All programs and commands can be entered either in the command window or in the M file using 
the MATLAB editor; then you can save all M files in the folder “work” in the current directory. 
1.5.2 BasiC CoMMands in MatlaB 
No. 
Commands 
Description 
1 
Y = 0:2:20 
This instruction indicates a vector Y which as initial value 0 and final value 20 with 
an increment of 2. Therefore: 
Y = [0 2 4 6 8 10 12 14 16 18 20]. 
2 
M = 40:5:100 
M = [40 45 50 55 60 65 70 75 80 85 90 95 100]. 
3 
N = 0: 1/pi: 1 
N = [0, 0.3183, 0.6366, 0.9549]. 
4 
zeros (1,5) 
Creates a vector of one row and five columns whose values are zero Output = [0 0 
0 0 0]. 
5 
ones (2,6) 
Creates a vector of two rows and six columns 
Output = 1 1 1 1 1 1 
1 1 1 1 1 1. 
6 
a = [2 2 –5] 
a*b = [6 10 –20]. 
b = [3 5 4] 
7 
plot (t,x) 
This instruction will display a figure window which indicates the plot of x versus t. 
If x = [6 7 8 9] 
t = [1 2 3 4] 
stem (t,x) 
This instruction will display a figure window as shown. 
(Continued) 

10 
Digital Signal Processing 
No. 
9 
Commands 
Subplot 
Description 
This function divides the figure window into rows and columns. 
Subplot (2, 2, 1) divides the figure window into three rows and three columns 
1,2,3,4,…. represent the number of the figure. 
(3,3,1) 
(3,3,2) 
(3,3,3) 
(3,3,4) 
(3,3,5) 
(3,3,6) 
(3,3,7) 
(3,3,8) 
(3,3,9) 
10 
Conv 
Syntax: y = conv(a,b) 
Description: y = conv(a,b) convolves vectors a and b. 
11 
Disp 
Syntax: disp(X) 
Description: disp(X) displays an array, without printing the array name. If X 
contains a text string, the string is displayed. 
12 
FFT 
FFT(X) is the discrete Fast Fourier Transform (FFT) of vector X. For matrices, the 
FFT operation applied to each column. For N-D arrays, the FFT operation 
operates on the first non-singleton dimension. FFT(X,N) is the N-point FFT, 
padded with zeros if X has less than N-points and truncated if it has more. 
13 
ABS 
Absolute value. 
ABS(X) is the absolute value of the elements of X. When X is complex, ABS(X) is 
the complex modulus (magnitude) of the elements of X. 
14 
ANGLE 
Phase angle. 
ANGLE(H): the phase angles, in radians, of a matrix with complex elements. 
15 
INTERP 
Y = INTERP(X,L) re-samples the sequence in vector X at L times the original 
sample rate. The resulting resampled vector Y is L times longer, LENGTH(Y) = 
L*LENGTH(X). Resample data at a higher rate using low-pass interpolation. 
16 
DECIMATE 
Y = DECIMATE(X,M) re-samples the sequence in vector X at 1/M times the 
original sample rate. The resulting resampled vector Y is M times shorter, 
LENGTH(Y) = CEIL(LENGTH(X)/M). By default, DECIMATE filters the data 
with an 8th order Chebyshev Type I low-pass filter with cut-off frequency, 
8*(Fs/2) /R, before re-sampling. Resample data at a lower rate after 
low-pass filtering. 
17 
xlabel 
Syntax: xlabel('string') 
Description: xlabel('string') labels the x-axis of the current axes. 
18 
ylabel 
Syntax: ylabel('string') 
Description: ylabel('string') labels the y-axis of the current axes. 
19 
Title 
Syntax: title('string') 
Description: title('string') outputs the string at the top and in the center of the 
current axes. 
20 
grid on 
Syntax: grid on. 
Description: grid on adds major grid lines to the current axes. 
21 
Help 
List topics on which support is available. 
22 
Help command name 
Provides help on the topic selected. 
23 
Demo 
Runs the demo program. 
(Continued) 

11 
Continuous and Discrete Signals 
No. 
Commands 
Description 
24 
Who 
Lists variables currently in the workspace. 
25 
Whos 
Lists variables currently in the workspace with their size. 
26 
Clear 
Clears the workspace, all the variables are removed. 
32 
Clear x,y,z 
Clears only variables x,y,z. 
33 
Quit 
Quits MATLAB. 
34 
ﬁr, delay, cas, sos, cas2can 
FIR and IIR filtering. 
35 
cﬁr2, cdelay2, wrap2 
Circular FIR filtering. 
36 
dtft 
DTFT computation. 
37 
sigav, sg, sgﬁlt, ecg 
Signal averaging, SG smoothing. 
38 
kwind, I0, kparm, kparm2 
Kaiser window. 
39 
klh, dlh, kbp, dbp, kdiff, 
FIR filter design. 
ddiff, khilb, dhilb 
40 
lhbutt, bpsbutt, lhcheb1, 
IIR filter design. 
lhcheb2, bpcheb2, bscheb2 
1.6 SOME FUNDAMENTAL SEQUENCES 
There are three simple discrete-time signals that are frequently used in the representation and 
description of more complicated signals. These are the unit sample, the unit step, and the exponen-
tial. The unit sample, 
Impulse response: Denoted by δ(n), and defined by 
1 
n = 0
d( ) = 
(1.10) 
n 
 
0 
otherwise 
1.6.1 iMpulse response in MatlaB 
To find the impulse response of the given LTI system given in a difference equation form or transfer 
function form of any order and plot the same. The impulse response of the system generates using 
the MATLAB program as follow: 
clc; 
clear all; 
close all; 
num=input('type the numerator vector'); 
den=input('type the denominator vector'); 
N= input(' enter the desired length of the output sequence'); 
n=0:N-1; 
imp=[1 zeros(1,N-1)]; 
H=filter(num, den, imp); 
disp(' the impulse response of the system is '); 
disp(H); 
stem(n,H); 
xlabel('n'); 
ylabel('h(n)'); 
title(' Impulse response'); 
Ans: 
type the numerator vector [1 3 –3 2 5 –2 2 4 –4] 

12 
Digital Signal Processing 
type the denominator vector 1 
enter the desired length of the output sequence 12 
the impulse response of the system is 
1
3
–3 2 5 –2 2
4
–4 0
0
0 
The unit step, denoted by u(n), is defined by 
1 
n ≥ 0 
u n  
 
(1.11) 
( )  = 
0
 otherwise 
and is related to the unit sample by 
n 
u n
( )  = ∑d n
( )
(1.12) 
k=−∞ 
Similarly, a unit sample is written as a difference of two steps: 
n
 u n
 (
d( )  = ( )  − u n −1) 
(1.13) 
Finally, an exponential sequence is defined by 
x n
( )  = an 
(1.14) 
where a is a real or complex number. Of particular interest is the exponential sequence that formed 
when a
e
=
− jwo  where ωo is a real number. In this case, x(n) is a complex exponential: 
jnw0
e 
= cos(nw0 )+ j sin(nw0 )
(1.15) 
1.6.2 siGnal duration 
Discrete-time signals are conveniently classified in terms of their duration or extent. For exam-
ple, a discrete-time sequence is said to be a ﬁnite-length sequence if it is equal to zero for all 
values of n outside a finite interval [N1, N2]. Signals that are not finite in length, such as the 
unit step and the complex exponential, are said to be inﬁnite-length sequences. Infinite-length 
sequences may be further classified as either being right-sided, left-sided, or two-sided. A right-
sided sequence is any infinite-length sequence that is equal to zero for all values of n < no for 
integer no. The unit step is an example of a right-sided sequence. Similarly, an infinite-length 
sequence x(n) is said to be left-sided if, for integer no, x(n) = 0 for all n > no. An example of a 
left-sided sequence is 
≤ 
x n  u n0 − 
(1.16) 
( )  = ( 
n) = 
 
1 
n
n0 
0 
n
n0
> 
which is a time-reversed and delayed unit step. An infinite-length signal that is neither right-sided 
nor left-sided, such as the complex exponential, is referred to as a two-sided sequence. 
1.7 GENERATION OF DISCRETE SIGNALS IN MATLAB 
To write a MATLAB program to generate discrete-time signals like a unit-impulse, unit step, unit 
ramp, exponential signal, and sinusoidal sequences follow the below. 

13 
Continuous and Discrete Signals 
% Generation of unit impulse, unit step, and unit ramp Sequences 
clc; 
clear all; 
close all; 
n=-10:1:10; 
L=length(n); 
for i=1:L 
if n(i)==0 
x1(i)=1; 
else x1(i)=0; 
end; 
if n(i)>=0 
x2(i)=1; 
x3(i)=n(i); 
else x2(i)=0; 
x3(i)=0; 
end; 
end; 
figure; 
stem(n,x1); 
xlabel(' n ---->'); 
ylabel('amplitude---->'); 
title('Unit-impulse signal'); 
Figure 1.7 shows the generation of a unit-impulse discrete function. 
Unit step 
clc; 
clear all; 
close all; 
n=-5:1:15; 
L=length(n); 
for i=1:L 
if n(i)>=0 
x1(i)=1; 
x2(i)=n(i); 
else 
x1(i)=0; 
x2(i)=0; 
end; 
Unit impulse signal
1.2 
1 
0.8 
0.6 
0.4 
0.2 
0 
–0.2 
–10 
–8 
–6 
–4 
–2 
0 
2 
4 
6 
8 
n 
FIGURE 1.7 Generation of unit-impulse discrete function. 
amplitude 
10 

14 
Digital Signal Processing 
end; 
figure; 
stem(n,x1); 
xlabel('n'); 
ylabel('amplitude'); 
title('Unit step signal') 
grid 
Figure 1.8 shows the generation of a unit-impulse discrete function. 
clc; 
clear all; 
close all; 
n=-5:1:20; 
L=length(n); 
for i=1:L 
if n(i)>=0 
x1(i)=1; 
x2(i)=n(i); 
else 
x1(i)=0; 
x2(i)=0; 
end; 
end; 
stem(n,x2); 
xlabel('n'); 
ylabel('amplitude'); 
title('Unit ramp signal'); 
Figure 1.9 shows the generation of a unit ramp discrete function. 
Generate exponential sequence a < 1 
clc; 
clear all; 
close all; 
n=-10:1:10; 
L=length(n); 
a=0.7; 
x1=a.^n; 
Unit step signal
1.2 
1 
0.8 
0.6 
0.4 
0.2 
0 
–0.2 
–5 
0 
5 
10 
15 
n 
FIGURE 1.8 Generation of unit step discrete function. 
amplitude 

15 
Continuous and Discrete Signals 
Unit ramp signal 
0 
5 
10 
15 
20 
amplitude 
–5 
0 
5 
10
15
20 
n 
FIGURE 1.9 Generation of unit ramp discrete function. 
stem(n,x1); 
xlabel('n'); 
ylabel('amplitude'); 
title('exponential signal'); 
Figure 1.10 shows the generation of an exponential sequence a < 1 discrete function. 
% Exponential sequence a > 1 
clc; 
clear all; 
close all; 
n=-5:1:15; 
L=length(n); 
a=1.5; 
x1=a.^n; 
stem(n,x1); 
xlabel('n'); 
ylabel('amplitude'); 
title('exponential signal'); 
exponential signal
40 
0 
10 
20 
30 
amplitude 
–10
–8
–6
–4
–2
0 
2 
4 
6 
8
 10 
n 
FIGURE 1.10 Shows the generation of exponential sequence a < 1 discrete function. 

16 
Digital Signal Processing 
exponential signal 
0 
100 
200 
300 
400 
amplitude 
–5 
0 
5
10
15 
n 
FIGURE 1.11 Generation of exponential sequence a > 1 discrete function. 
Figure 1.11 shows the generation of an exponential sequence a > 1 discrete function. 
% Generate exponential sequence a = 1 
clc; 
clc; 
clear all; 
close all; 
n=-15:1:15; 
L=length(n); 
a=1; 
x1=a.^n; 
stem(n,x1); 
xlabel('n'); 
ylabel('amplitude'); 
title('exponential signal'); 
Figure 1.12 shows the generation of an exponential sequence a = 1 discrete function. 
% Generate sinusoidal sequence 
clc; 
clear all; 
close all; 
exponential signal 
–0.2 
0 
0.2 
0.4 
0.6 
0.8 
1 
1.2 
amplitude 
–15
–10 
–5 
0 
5 
10 
n 
FIGURE 1.12 Generation of exponential sequence a = 1 discrete function. 
15 

Continuous and Discrete Signals 
17 
n=-20:1:20; 
L=length(n); 
f=0.1; 
x1=sin(2*pi*f*n); 
stem(n,x1); 
xlabel('n'); 
ylabel('amplitude'); 
title('sinusoidal signal'); 
Figure 1.13 shows the generation of a sine discrete function. 
PROBLEMS 
1.1 Write a MATLAB program to generate a delayed unit step signal with a delay of 8 seconds, 
then run it and display the result. 
1.2 Write a MATLAB program to determine the average normalized power of the triangular 
signal generated then run the program to display the result. 
1.3 Write a program to display the signals: 
i x t( )  = 
( )  −3t u t  −
+ 2
( −. )
t u t
 ( 
1) 
t u t 1 5 
ii f t( )  = u 
sin 
 p 
T
t 



 − u 
− sin 
 p 
T
t 



 
1.4 Write a MATLAB program to generate: 
• A delayed unit sample sequence with a delay of 13 samples. 
• A delayed unit step sequence with an advance of 7 samples. 
• An exponential sequence with a = 1.4. 
• A sinusoidal sequence of frequencies 0.7, 1.3, and 5. 
Run the modified program and display the sequences generated. 
1.5 Write MATLAB programs to generate the square wave, and the sawtooth wave sequences, 
of the types shown in Figure 1.14 a and b. Using these programs, generate and plot the 
sequences. 
1.6 Write MATLAB programs to generate the wave impulse sequences given below. Using 
these programs, create and plot the sequences. 
x n  u 4 − ) =

 
0
4 
n
n 
>
≤ 
4
4 
( )  = ( 
n 
 
sinusoidal signal 
–1 
–0.5 
0 
0.5 
1 
amplitude 
–20 
–15 
–10 
–5 
0 
5 
10 
15 
20 
n 
FIGURE 1.13 Generation of sine discrete function. 

18 
Digital Signal Processing 
x(n) 
0
1 
2
3 
4 
5 
6
7
8 
n 
–3
(a) 
x(n) 
4 
3 
2 
1 
n
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
1 
2 
3 
4 
1 
2 
3 
4 
(b) 
FIGURE 1.14 Sequences for Problem 1.5. 
1.7 Write MATLAB programs to generate the wave impulse sequences given below. Using 
these programs, create and plot the sequences. 
x n  u(2 + n = 
 
8 
n ≤−2 
( )  =
)
0 
n > −2 
1.8 Write MATLAB programs to generate the wave unit step sequences given below. Using 
these programs, create and plot the sequences. 
1 
n ≥ 1 
u n  

( )  = 
0
 otherwise 
1.9 Write MATLAB programs to generate the wave unit step sequences given below. Using 
these programs, generate and plot the sequences. 
0 7. 5 
n ≥−2 
u n
( )  0
 otherwise 


 
= 

2 Signals Properties 
A discrete-time system has inputs and outputs that are discrete-time functions, and a continuous-
time system has inputs and outputs that are continuous-time functions. This chapter deals with the 
signal’s properties of discrete signals as Periodic and Aperiodic Sequences, Symmetric Sequences, 
Even and Odd Parts of a Signal in MATLAB, Signal Manipulations, Transformations of the 
Independent Variable, Signal Decomposition. Also, the chapter, including System Properties and 
Linear time-invariant causal systems. 
2.1 PERIODIC AND APERIODIC SEQUENCES 
A discrete-time signal is organized into two categories. It has to be either periodic or aperiodic. 
Suppose a signal x(n) is classified to be periodic, for positive real integer N, and 
x n  = x n
( 
(2.1) 
( )  
+ N) 
For all samples n. It resembles the equivalence of repeating itself in the sequence for each of the N 
samples. If a signal is periodic with period N, it is also periodic with period 2N, period 3N, and all 
other integer multiples of N. If the signal x(n) is not satisfied for any integer N, then x(n) is assumed 
to be an aperiodic signal. 
Example 2.1 
The signals 
n 
n 
a
n ≤ 0 
x n
( )  = a u n 
1 
( )  = 0 
n > 0

and x = cos(n2 
( )  = e j n/  is periodic and has a funda-
2 
) are not periodic, whereas the signal x n
3 
p
8 
mental period of N = 16. 
If x1(n) is a sequence that is periodic with a period of N1, and x2(n) is an additional sequence 
that is periodic with a period of N2, the sum 
( )  
+ x n
x n  = x n
( )  
( )
(2.2) 
1
2 
will continuously be periodic, and the fundamental period will be 
N N
N = gcd
1
2
, 
) 
(2.3) 
(N N
1
2 
where gcd(N1,N2) means the greatest common divisor of N1 and N2. Likewise, the same phenom-
ena are valid for the product; that is 
x n  = x n x n
( )
(2.4) 
( )  
1( )
2 
will be periodic with a period of N. However, the first period could be smaller. Given any sequence 
of x(n), a periodic signal may always be molded by replicating x(n) as follows: 
∞ 
y n  = ∑x n
( 
(2.5) 
( )  
−kN) 
k=−∞ 
where N is a positive integer, and in this case y(n) will be periodic with period N. 
19 

20 
Digital Signal Processing 
2.2 EVEN AND ODD PARTS OF A SIGNAL (SYMMETRIC SEQUENCES) 
A discrete-time signal will often possess some form of symmetry that is manipulated in solving 
problems. Two symmetries of interest are as follows: 
Definition: A real-valued signal is said to be even if, for all n, 
x n  
x
n
( )  (
)
=
−
(2.6) 
whereas a signal is said to be odd if, for all n, 
x n  
x
n
( )  
(
)
= − − 
(2.7) 
Any signal x(n) is decomposed into a sum of its even part, x(n), and it is an odd part, x(n) as follows: 
( )  
+ x n
x n  = x n
( )  
( )
(2.8) 
e
o 
To find the even part of x(n), we form the sum 
x n
( )  = 1 x n
( )  + 
−}
e
{ 
x
n
(
)
(2.9) 
2 
whereas to find the odd part we take the difference 
x n
( )  = 1 x n
( )  − 
−} 
(2.10) 
o
{ 
x
n
(
)
2 
For complex sequences, the symmetries of interest are slightly different. 
A complex signal is said to be conjugate symmetric (hermitian) if, for all n, 
x n  = x *( 
(2.11) 
( )  
-n) 
and a signal is said to be conjugate antisymmetric if, for all n, 
x n  = -x *( 
(2.12) 
( )  
-n) 
Any complex signal may always be decomposed into a sum of a conjugate symmetric signal and a 
conjugate antisymmetric signal. 
Follow the MATLAB program below to find the even and odd parts of a signal. 
clc; 
clear all; 
close all; 
t=-10:0.1:10; 
A=0.8; 
x1=sin(t); 
x2=sin(-t); 
if(x2==x1) 
disp('The given signal is even signal'); 
else 
if(x2==(-x1)) 
disp('The given signal is odd signal'); 
else 
disp('The given signal is neither even nor odd'); 
end 
end 
xe=(x1+x2)/2; 
xo=(x1-x2)/2; 
subplot(2,2,1); 

21 
Signals Properties 
plot(t,x1); 
xlabel('t');ylabel('x(t)');title('signal x(t)'); 
subplot(2,2,2); 
plot(t,x2); 
xlabel('t');ylabel('x(t)');title('signal x(-t)'); 
subplot(2,2,3); 
plot(t,xe); 
xlabel('t');ylabel('x(t)');title('even part signal x(t)'); 
subplot(2,2,4); 
plot(t,xo); 
xlabel('t');ylabel('x(t)');title('odd part signal x(t)'); 
Figure 2.1 shows an odd signal after running the program. 
clc; 
clear all; 
close all; 
t=-10:0.1:10; 
A=0.8; 
x1=cos(t); 
x2=cos(-t); 
if(x2==x1) 
disp('The given signal is even signal'); 
else 
if(x2==(-x1)) 
disp('The given signal is odd signal'); 
else 
disp('The given signal is neither even nor odd'); 
end 
end 
xe=(x1+x2)/2; 
xo=(x1-x2)/2; 
subplot(2,2,1); 
plot(t,x1); 
xlabel('t');ylabel('x(t)');title('signal x(t)'); 
subplot(2,2,2); 
plot(t,x2); 
xlabel('t');ylabel('x(t)');title('signal x(-t)'); 
subplot(2,2,3); 
signal x(t) 
signal x(–t)
1 
–1 
0
x(t) 
–1 
0 
1 
x(t) 
–10
–5 
0 
5 
10
–10
 –5
 0 
5
 10 
t
t 
even part signal x(t) 
odd part signal x(t) 
1 
x(t)
0 
x(t)
0 
–1 
–1 
–10
–5 
0 
5 
10
–10
–5 
0 
5 
10 
t
t 
FIGURE 2.1 Odd signal. 
1 

22 
Digital Signal Processing 
signal x(t) 
signal x(–t)
1 
–1 
0
x(t) 
–1 
0 
1 
x(t) 
–10
–5 
0 
5 
10
–10
–5 
0 
5 
10 
t
t 
even part signal x(t) 
odd part signal x(t)
1 
–1 
0
x(t) 
–1 
0 
1 
x(t) 
–10
–5 
0 
5 
10
–10
–5 
0 
5 
10 
t
t 
FIGURE 2.2 Even signal. 
plot(t,xe); 
xlabel('t');ylabel('x(t)');title('even part signal x(t)'); 
subplot(2,2,4); 
plot(t,xo); 
xlabel('t');ylabel('x(t)');title('odd part signal x(t)'); 
Figure 2.2 shows an even signal after running the program. 
clc; 
clear all; 
close all; 
t=-10:0.1:10; 
K=1.2; 
x1=K.^(t); 
x2=K.^(-t); 
if(x2==x1) 
disp('The given signal is even signal'); 
else 
if(x2==(-x1)) 
disp('The given signal is odd signal'); 
else 
disp('The given signal is neither even nor odd'); 
end 
end 
xe=(x1+x2)/2; 
xo=(x1-x2)/2; 
subplot(2,2,1); 
plot(t,x1); 
xlabel('t');ylabel('x(t)');title('signal x(t)'); 
subplot(2,2,2); 
plot(t,x2); 
xlabel('t');ylabel('x(t)');title('signal x(-t)'); 
subplot(2,2,3); 
plot(t,xe); 
xlabel('t');ylabel('x(t)');title('even part signal x(t)'); 
subplot(2,2,4); 
plot(t,xo); 
xlabel('t');ylabel('x(t)');title('odd part signal x(t)'); 
Figure 2.3 shows neither an even nor an odd signal after running the program. 

23 
10 
4 
Signals Properties 
signal x(t) 
signal x(–t)
10 
0 
5
x(t) 
0 
5
x(t) 
–10
–5 
0 
5 
10
–10
–5 
0 
5 
10 
t
t 
even part signal x(t) 
odd part signal x(t)
5 
0 
2
x(t) 
–5 
0
x(t) 
–10
–5 
0 
5 
10
–10
–5 
0 
5 
10 
t
t 
FIGURE 2.3 Neither even nor odd signal. 
2.3 SIGNAL MANIPULATIONS 
The study of discrete-time signals and systems, will be concerned with the manipulation of signals. 
These manipulations are commonly compositions of a few necessary signal transformations. 
2.3.1 TransformaTions of The independenT Variable 
Sequences are often altered and manipulated by modifying the index n as follows: 
y n  = x f( (  )) 
(2.13) 
( )  
n 
Where f(n) is a function of n, there are some values of n which gives its role an undefined state, spe-
cifically if f(n) is not an integer then y(n) = x(f(n)) is perceived as undefined. The effects of modify-
ing the index n can be achieved by using a simple tabular approach of listing, where each value for n 
will give the setting y(n) = x(f(n)). The most common transformations of the independent variables 
are noted as shifting, reversal, and scaling, which are defined below. 
2.3.1.1 Shifting 
Shifting is the transformation defined by the notation f(n) = n – no. For the statement, y(n) = x 
(n – no), if no is positive (referred to as a delay), then x(n) is shifted to the right by no samples. 
Likewise, if no is negative (referred to as an advance), then it will be shifted to the left by no samples 
(referred to as an advance). 
2.3.1.2 Reversal 
This transformation is estimated by the statement f(n) = –n which involves “flipping” the signal x(n) 
concerning the index n. 
2.3.1.3 Time-Scaling 
This transformation is defined by the either the notation x(n) = Mn or f(n) = n/N where M and N are 
positive integers. In the case of f(n) = Mn, the sequence x(Mn) is formed by taking every Mth sample 
of x(n) (this operation is known as down-sampling). For the statement, f(n) = n/N the sequence 
y(n) = x(f (n)) is defined as follows: 
n  
=
±
± 
, 
y t( )  = 
x N  
n 
0, N, 2N 
(2.14) 
0 
otherwise 

24 
Digital Signal Processing 
(This operation is known as up-sampling.) 
Shifting, reversal, and time-scaling operations are perceived as order-dependent. For example, 
see the two systems that are shown in Figure 2.4. One of them represents a delay followed by a 
reversal, and then the other one shows a reversal followed by a delay. As identified before, the out-
puts of these two systems are not the same. 
2.3.1.4 Addition, Multiplication, and Scaling 
The most common types of amplitude transformations are addition, multiplication, and scaling. 
2.3.1.5 Addition 
The sum of two signals 
y n  = x n  + 
( )  
n
( )  
( )  x n  −∞<
< ∞ 
(2.15) 
1
2 
is formed by the pointwise addition of the signal values. 
2.3.1.6 Multiplication 
The multiplication of two signals 
y n
( )  = x n x n  
( )  ( )  −∞<  n < ∞
(2.16) 
1
2 
is formed by the pointwise product of the signal values. 
2.3.1.7 Scaling 
Amplitude scaling of a signal x(n) by a constant c is accomplished by multiplying every signal value 
by c: 
y n  = c x n
 
( )  
(2.17) 
( )  
−∞<  n < ∞
This operation may also be considered to be the product of two signals, x(n) and f(n) = c. 
2.3.1.8 Signal Decomposition 
The unit sample may be used to decompose an arbitrary signal x(n) into a sum of weighted and 
shifted unit samples as follows: 
x n  =  + x(
) (
 
n + ) + x( ) (−1 d n + x( ) (  n − ) + x( ) (  n
( )  
−1 d 
1
0 x 
) ( )
 1 d 
1
2 d 
− 2) +
(2.18) 
x(n) 
x(n-no) 
x(-n-no) 
Tno 
Tr 
(a) 
x(n) 
x(-no) 
x(-n+no) 
Tno
Tr 
(b) 
FIGURE 2.4 Time-scaling operation. (a) A delay Tno followed by a time-reversal Tr. (b) A time-reversal Tr 
followed by a delay Tno. 

Signals Properties 
25 
This decomposition may be written concisely as: 
∞ 
x n
( )  = ∑x k
( )d(n
k) 
(2.19) 
− 
k=−∞ 
where each term in the sum, x(n) δ (n – k), is a signal that has an amplitude of x(k) at the time n = k 
and a value of zero for all other values of n. This decomposition is the discrete version of the sifting 
property for continuous-time signals and used in the derivation of the convolution sum. 
2.4 DISCRETE-TIME SYSTEMS 
A discrete-time system is a mathematical operator or mapping that transforms one signal (the input) 
into another signal (the output) using a fixed set of rules or operations. The notation T [.] is used to 
represent a general system as shown in Figure 2.5, in which an input signal x(n) is transformed into 
an output signal y(n) through the transformation T [.]: 
y n  = x
n
( )  
2( )
or 
y n  = .
(y n −1 + ( ) 
( )
0 5  
) x n  
However, it could be described as a system in terms of an algorithm that provides a sequence of 
instructions or operations that is to apply to the input signal, such as: 
y n  = 0 5  y n
( − ) + . 
( )
1( )
. 
1 
1
0 25 x n  
y n  = 0 25
 
. 
y n − ) + 0 5
2 
2(
1 
. x n
( )  
( )
3 
1
0 5 x n
y n
( )  = 0 4. y n
3( − ) + . 
( )
y n
( )  = y n  + 
( )  + y n
1( )  y n  
3
2 
( )
2.4.1 sysTem properTies 
2.4.1.1 Memoryless System 
The first property is concerned with whether or not a system has memory. A system is said to be 
memoryless if the output at any time of n = no depends only on the input at a time of n = no. In other 
words, a system is memoryless if, for any no, we can determine the value of y(no) given only the 
value of x(no). 
2
For example, the system y n
( )  = x
n  is memoryless because y(no
( )
) depends only on the value 
of x(no) at the time no. The system y n  = ( )  + x n  ) on the other hand, is not memoryless 
( )  x n  
( −1 
because the output at the time no depends on the value of the input both at the time and at the 
time (no – 1). 
x(n) 
y(n)=T[x(no)] 
T[.] 
FIGURE 2.5 Discrete-time system. 

26 
Digital Signal Processing 
2.4.1.2 Additivity 
An additive system is one for which the response to a sum of inputs is equal to the sum of the inputs 
individually. Thus, A system is said to be additive if T x ( )
n + x n
 
2( )  T x n  
( )  T x  n 
2( )
[ 1 
] = [ 1 
]+ [ 
] for any 
signals x1(n) and x2(n). 
2.4.1.3 Homogeneity 
A system is said to be homogeneous if scaling the input by the constant results in a scaling of the 
output by the same amount. Specifically, a system is said to be homogeneous if T cx n
( )] = 
]
[ 
cT x n  
[ ( )
for any complex constant c and any input sequence x(n). 
Example 2.2 
The system defined by 
x n  
y n =
( )  
2( )  
x n − )
(
1 
which is not additive because 
(x n
1 
+ x n
( )
2
( )  
2 
)
T x ( )
n + x n 
[ 1 
2( )] = x n
( −
+
1) x n
( −1)
1
2 
which is not the same as 
[ 1 
2( )] = (x n
( ))
2 
+ x n
( ))
2 
1 
( 2
T x ( )
n + x n 
x n
( − 1) 
x n
( − 1)
1
2 
This system is, however, homogeneous because, for an input cx(n) the output is 
( )= (c x( )
n )
2 
(x n
( ))
2 
[
]
T c
 x n  
= c 
= cT x n  
( )
c x(n − 1) 
(x n − 1) 
( )  
+ x n
On the other hand, the system defined by the equation y n = x n
( )  
*( ) is additive because 
x n + x n  
x n
( − 1 + x n
( − 1
* = 
( )  + x n − ) 
*(
)
) 
x n  
*( 
1 
x n  x n − )
[ 1( )  
2( )]+[ 1
2 
] 
 1
1 
+  2( )  + x2
1 
However, this system is not homogeneous because the response to cx(n) is 
T c x n  
c x( )
n
c x n  
+ *
*( − 1)
 
( ) = 
which is not the same as 
cT x n  
n
c
* 
− 1
[ ( )] = c x( )  + x n
(
) 
. 
2.4.1.4 Stability 
In many applications, it is essential for a system to have a response, y(n), that is bounded in ampli-
tude whenever the input is bounded. A system with this property is said to be stable in the bounded 
input/bounded output (BIBO) sense. Specifically, a system is said to be stable in the defined input/ 
bounded output sense if, for any input that is bounded, x n
( )  ≤
<
A ∞, the output will be bounded, 
y n
( )  ≤
<
B ∞. 
For a linear shift-invariant system, stability is guaranteed if the unit sample response is summable: 
∞ 
∑h n
( )  < ∞
n=−∞ 

Signals Properties 
27 
Example 2.3 
n
A system with unit sample response h n
( )  = a u n
( ) will be stable whenever a < 1 because 
¥
¥ 
å 
n 
1 
h n
( )  
a = 
a < 1
=å 
1- a 
n=-¥ 
n=0 
The system is described by the equation y(n) = nx(n). On the other hand, it is not described as 
stable because the response to a unit step, x(n) = u(n), is y(n) = nu(n), which is unbounded. 
2.5 LINEAR TIME-INVARIANT CAUSAL SYSTEMS (LTI) 
Linear time-invariant systems are the most important systems in DSP fields. Besides the previously 
mentioned properties, the most important features of this system are linearity, time-invariance, and 
causality. 
2.5.1 lineariTy 
A system that is both additive and homogeneous is said to be linear. Thus, a system is said to be 
linear if T a x n
( )  + a x  n
 
( )]+ a T x  n ] for any two inputs x
) and x
( )] = a T x  n
 
( )
) and any 
complex constants a1 and a2. 
Linearity greatly simplifies the evaluation of the response of a system to a given input. For 
example, given x(n): 
[ 1 1
2
2
 
1 [ 1
2 [ 2 
1(n
2(n
∞ 
x n
( )  = ∑x k
( )  d(n
k) 
(2.20) 
− 
k=−∞ 
and using the additivity property it follows that the output y(n) is written as 

∞ 

∞ 
y n  = T x n
 
] = T ∑x k
( ) (
 
− ) = ∑T x k
 
d n −k
( )  
[ ( )  
d n
k
 
[ ( ) ( 
)]
(2.21) 


k=−∞ 
 
k=−∞ 
Because the coefficients x(k) are constants, we may use the homogeneity property to write: 

∞ 

∞ 
y n  = T ∑ ( ) (
 
n −k)∑x k T  [d( − )]
( )  
x k
 
d 
( )  
n
k
(2.22) 


k=−∞ 
k=−∞ 
If we define hk(n) as the response of the system to a unit sample at time n = k, 
h n  = T [d(n − k ]
k( )  
) 
(2.23) 
∞ 
y n  = ∑x k h n
( )
(2.24) 
( )  
( )  k 
k=−∞ 
which is known as the superposition summation. 
For example, consider the digital filters as: 
[ ]  [ ]  x n −
+ [ 
2]
1) y n  = x n  + [ 
1] x n −
+ as represented in Figure 2.6. 
2) y n  = y n
[ −1 + [ ] as represented in Figure 2.7. 
[ ]  
] x n
3) y n  = 1 8  y n  ]
. y n
[ 
2] x n  −.
[ 
] x n  
 as represented in Figure 2.8. 
[ ]  .
[
 −
−
 −
+
 
[ ]  1 9  x n −
+ [ −2
1
0 9
 
1
] 

28 
Digital Signal Processing 
y(n)
T 
T
T
T 
Σ 
x(n) 
x(n-1) 
x(n-2) 
x(n-3) 
Delay (-1) 
FIGURE 2.6 
y n
[ ] = [ ] + x n −
+ [ −
+
]  represen at on.
x n  
[ 
1] x n  2 
t i
y(n)
T 
x(n) 
y(n-1) 
Σ 
FIGURE 2.7 
y n  = [ − ] x n  represe tat on.
[ ]  y n  1 + [ ]
n
i
y(n)
T 
T
T
T 
Σ 
x(n) 
x(n-1) 
y(n-2) 
y(n-1) 
-1.9 
-0.9 
1.8 
FIGURE 2.8 
y n
[ ] = .
[
 1
0 9
 
] 
. y n  2] x n
[ ] −1 9x n −
+
1 
x n −2] representation.
1 8y n −
−
 
[ −
+
 
.
[
 ]
[ 
Example 2.4 
Find the first four samples values of the impulse response h[n] for each the following digital 
processors: 
a) The system illustrated in Figure 2.9. 
[ ]  [ ]  x n −
+ [ 
2] 
b) The system y n  = x n  + [ 
1] x n −
+
SOLUTION 
a) From Figure 2.9, the output equation is given as 
y n  = − .
[y n −
+
 [ ] 
[ ]
0 7  
1] x n  
The impulse response is 
h n
[ ]  = − .
[h n −
+
 [ ]
0 7  
1] d n 
The system is causal, so h[n] = 0 for all n<0. 
For n = 0, 
[ ]  
0 7
 
−+
] 
=
+ = 
h 0 = −.
[h 1 d[ ] 
0 
0
1
1

 
29 
Signals Properties 
T
-0.7 
+ 
+ 
x[n] 
y[n]
+ 
FIGURE 2.9 System for Example 2.4. 
n = 1, 
h1 = - .
[ ]
 
h 
+ d 1 = - . * + 0 
[ ]  
0 7
0
 [ ]
 
0 7 1  = -0.7 
n = 2, 
h 2 = - .
[ ]
 
h + d 2 = - . )*( - 0 7
 0 
. 
[ ]  
0 7 1  [ ]
(
 0 7
 . ) +
= 0 49 
n = 3, 
h 3 = - .
[ ]
 
h 
+ d 3 = - . )*( . 
) + 0 = - . 
[ ]  
0 7
2
 [ ]
(
 0 7
0 49 
0 343
x n  
[ 
1] x n  2]
b) y n
[ ]  = [ ]+ x n −
+ [ −
+ 
h n
[ ]  = d n + [n 
]
[n 2
[ ]  d −
+ d 
]
1 
−
+ 
h[ ]
0 = d 0 
[
]
 d 2  = 1
[ ]  d 1 
[
]
+ −+  −
+
 
h[ ]1 = d 1 + [ ]+
−+
 
 = 1
[ ]  d 0 
d[
]1 
h[ ]
2 = d 2 + [ ]+ d 0 +  = 1
[ ]  d 1 
[ ]  
h[ ]
3 = d 3 + [ ]+ d 1 + = 1 
[ ]  d 2 
[ ]  
Example 2.5 
Find the first five sample values of the impulse response h[n] for each system illustrated in Figure 2.10 
1) The impulse response is 
0 5  [ −
d n 
h n[ ] = . h n  1]+ [ ]
The system is causal, so h[n] = 0 for all n<0. 
For n = 0, 
[ ]  0 5
 
−+
 
] 
=
 
+ =
h 0 =
.
[h 1 d[ ] 
0 
0
1
1
n = 1, 
[ ]  
[ ]
 
0 7 1  
+
=
0
0 5 
h1
0 5
0
 
= .
[ ]
 
h 
+ d 1 = - . * 
. 
n = 2, 
h 2 = .
[ ]
 
h + d 2 = 0 5 *(0.5) + 0 = . 
[ ]  0 5 1  [ ]
( . )  
0 25 
n = 3, 
h 3 = .
[ ]
 
h 
+ d 3 = 0 5 *(0.25) + 0 = . 
[ ]  0 5
2
 [ ]
( . )  
0 125 
n = 4, 
h 4 = .
[ ]
 
h 
+ d 2 = 0
 
5
 
*(0.125) + 0 = . 
[ ]  0 5
3
 [ ]
( . )  
0 0625 
… 

30 
Digital Signal Processing 
T
0.5 
+ 
+ 
x[n] 
y[n]
+ 
FIGURE 2.10 System for Example 2.5. 
2) For the step response 
n 
s n  = ∑h m
[ ]  
(
)
m=−∞ 
s 0 = h[ ]
[ ]  
0 = 1
[ ]  h 1
1 5
s[ ]1 = h 0 + [ ]  = . 
s 2 = h[ ]+ [ ]1 + h 2 = 1 75
[ ]  
0 
h 
[ ]  . 
s[ ]
3 = h 0 + [ ]+ h 2 + [ ]
[ ]  h 1 
[ ]  h 3 = 1.875
s 4 = h[ ]
0 + h[ ]1 + h[ ]
2 + h[ ]+ h 4 = 1.9375
[ ]  
3
[ ]  
…and so on. 
Example 2.6 
For the sequence following determine the linearity of each system, where x(n) is the input and y(n) 
is the output. 
a) y(n) = ln(x(n)) 
b) y(n) = 1 + x(n) + x(n + 1) + x(n + 2) 
c) y(n) = x(n) + [x(n + 1) x(n – 2)]/x(n) 
d) y(n) = x(n) sin(nπ/2) 
SOLUTION 
Use y(n) = T[cx(n)] = cT[x(n)] for a linear system. 
a) y(n) = ln(x(n)) → y(n) = ln(cx(n)) = ln c + ln x(n) ≠cT[x(n)], so the system is non-linear. 
b) y(n) = 1 + x(n) + x(n + 1) + x(n + 2) 
y n
1( )  = +
1 x n
1( )  + x n
1( 
1) x n
1( + 2)
+
+
 
1 c
x n
 
+ x n
 
+ ) + x n 
( + 2 
= +  [ ( )
(
1 
)] 
but c y(n) = c [1 + x(n) + x(n + 1) + x(n + 2)] 
so y1(n) ≠c y(n), so the system is non-linear. 
c) y(n) = x(n) + [x(n + 1) x(n – 2)]/x(n) 
y1(n) = x1(n) + [x1(n + 1) x1(n – 2)]/x1(n) 
y n  = cx n
 
( )  + 
( + 1 cx n
 
− ) /
( ) 
1( )  
cx n  )
( 
2  cx n  
[ 
)
 
(
 2 
 
// (  ) 
cy n 
= c x n
 
( )  +[ x n
 
( + 1 x n − )] x n  ] = 
( ) 
Since y1(n) = c y(n), the system is linear. 

Signals Properties 
31 
d) y(n) = x(n) sin(nπ/2) 
Let x(n) = a1 x1(n) + a2 x2(n) 
y n  = a x  n
 
1 1( )sin
 
np/2 + a x  n 
(
( )  
(
) 
( )sin np/2)
2
2
 
= a y  n
 
+ a y n  
1 1( )  
2
2( )  
so the system is linear. 
2.5.2 Time-inVariance 
If a system has the property that a shift (delay) in the input by no results in a shift in the output by 
no, the system is said to be time-invariant. 
Let y(n) be the response of a system to an arbitrary input x(n). The system is said to be time-
invariant if, for any delay of no, the response to x(n – no) is y(n – no). A system that is not time-
invariant is said to be time-varying. 
In effect, a system will be time-invariant if its properties or characteristics do not change with 
time. To test for shift-invariance, one needs to compare y(n – no) to T [x(n – no)]. If they are the same 
for any input x(n) and all shifts no, the system is shift-invariant. 
Example 2.7 
Determine whether each of the following systems is time-invariant. 
a) y n
( )  = x n
2( )
b) y n  = ( )  + x
n
( )  x n  
−
(
)
SOLUTION 
a) If y(n) = x2(n) is the response of the system to x(n), the response of the system to 
x n
′( )  = x n − n ) is y n  
′( )] = x n − o)
( 
o 
′( )  = [x n  
2 
2( 
n . 
Because y'(n) = y(n – no), the system is time-invariant. 
b) First, note that the system’s response to the input x(n) = δ(n) is: 
y n  = d n + d(
)
 
= 2d n
( )  ( )  
−n 
( )
whereas the response to x(n – 1) = δ(n – 1) is 
′( )  = d(n − ) + d(−
y n  
1 
n − 1) 
Because this is not the same as y(n – 1) = 2δ(n – 1), the system is time-variant. 
Example 2.8 
For each sequence in the following Determine whether or not the systems are shift-invariant. 
a) y n  = ( )  + x n  1)
( 
) x n −3
x n  
( −
+ x n −
+ (
 ).
( )  
2 
b) y n
( )  = 3x n u n  
( )  ( ). 
c) y n
( )  =
−
(
).
x
n
d) y n
( )  = nu n 
( ).
n 
e) y n
( )  = ∑x k( )
k=−∞ 

32 
Digital Signal Processing 
SOLUTION 
a) y n  = ( )  + x n  1)
( 
) x n −3
x n  
( −
+ x n −
+ (
)
( )  
2 
When a response is shifted by n0: 
y n −n ) = x n
n
( −
+
0) x n − 
−
+
n 
1) x n
n
−
−
+
 −
−
)
( 
n 
3)
(
0 
(
0
(
0
2 
x n  
0 
The response of the system to x1 = x(n
n0
− 
) is 
y n  = x n +
(
1 x n
(
) x n
( −3
1( )  
1( )  x n
1 
−
+
)
1 
−
+
2 
1
) 
x n
1 
−n ) + x n
n
1
1 x1 n
n
 2 
1( −
−
n
=
( 
0
( 
0
) 
0
) x n  
3
− 
−
+
( − 
−
+ 
0
) 
Since y n  = y n
( 
, the system is shift-invariant.
1( )  
− n0)
b) y n
( )  = 3x n u n
( ) ( )
y n  = 3x n f n
( )  
( ) ( )
where f(n) is the varying function. Systems of this form are always shift-varying provided 
f(n) is not a constant. So, the sequence y n
( )  = 3 ( )  ( )
x n u n  is shift-varying. 
c) y n
( )  =
−
(
)
x
n
y n  = x
n
 
= ( − n
1( )  
1(
)
 x n  
0
− 
) 
( −
0 = 
−
0 )
x
n
 0
y n  n ) 
x( (n
n ) = (−+ n ) 
which is not equal to y1(n). Therefore, the system is shift-varying. 
d) y n
( )  = 
( )
nu n . 
Shift the input x n − n ) 
1( 
0 
y n  = (n
n )⋅ ( − n0
1( )  
− 0 u n  
) 
y n
( − n0) = (n − n
u n
n
0)⋅ ( − 0) 
which is equal to y n
1( ). Therefore, the system is shift-invariant. 
n 
e) y n
( )  = ∑x k( )
k=−∞ 
Shifting the input x n − n )
1( 
0 
n 
n n
− 0 
y n  = ∑x k − n ) = ∑x k
1( )
(
0 
( )
k=−∞ 
k=−∞ 
Since this is equal to y n − n0 
he system is shift-invariant.
( 
), t
2.5.3 causaliTy 
A system property that is important for real-time applications is causality, which is defined as a 
system is said to be causal if, for any no, the response of the system at a time of no depends only on 
the input up to a time of n = no. 
For a causal system, changes in the output cannot precede changes in the input. Thus, if x1(n) = 
x2(n) for n ≤no, y1(n) must be equal to y2(n) for n ≤no. A LTI system will be causal if and only if 
h(n) is equal to zero for n < 0. 

33 
Signals Properties 
Example 2.9 
The system described by the equation y(n) = x(n) + x(n – 1) is causal because of the value of the 
output at any time n = no depends only on the input x(n) at the time no and at the time no – 1. The 
system described by y(n) = x(n) + x(n + 1) on the other hand, is noncausal because of the output 
at time n = no depends on the value of the input at the time no – 1. 
Example 2.10 
Given the following linear systems, 
a) y n
( )  = .
( ) + 2 2
. x n − 2), for n ≥ 0
0 9  x n  
( 
b) y n  = .
( − ) + . x n + ) − .
( − ), for n 
( )  1 25 x n  1 2 5 ( 
1
4 4y n  1 
≥ 0 
determine whether each is causal. 
SOLUTION 
a) Since for n ≥ 0, the output y(n) depends on the current input x(n) and its past value 
x(n – 2), the system is causal. 
b) Since for n ≥0, the output y(n) depends on the current input x(n) and its future value 
x(n + 2), the system is noncausal. 
Example 2.11 
The system is described by the sequence: 
x(n) = (5 – n)[u{n) – u(n – 5)]. Determine and draw the following: 
a) y(n) = x(4 – n). 
b) g(n) = x(2n – 3). 
c) h(n) = x(6 – 2n). 
d) v(n) = x(n2 – 2n + 1). 
SOLUTION 
The system described by the sequence: X(n) = (5 – n)[u{n) – u(n – 5)], so the sequence is illustrated 
as shown in Figure 2.1 a. 
Example 2.12 
For the system described by the sequence shown in Figure 2.12, determine and draw 
a) x(n – 2) 
b) x(–n) 
c) x(2n) 
d) x(n/2) 
SOLUTION 
Figure 2.13 shows the solution of Example 2.12, where Figure 2.13a represents the sequence when 
there is a delay of n0 = 2. Figure 2.13b represents time-reversal of the sequence while Figure 2.13c 
illustrates the down-sampling by a factor of 2, and Figure 2.13d represents an up-sampling by a 
factor of 2. 

34 
Digital Signal Processing 
x(n) 
5 
4 
3 
2 
1 
0 
1
2
3 
4
5
n 
(a) x(n) 
x(-n) 
y(n)=x(4-n) 
5 
5 
4 
4 
3 
3 
2 
2 
1 
1 
–5 –4 –3 –2 –1 
0 
1 
n 
–1 
0 
1 
2 
3 
4 
5 n 
(b) y(n)=x(4-n). 
x(n-3) 
g(x)x(2n-3) 
5 
4 
3 
2 
1 
5 
4 
3 
2 
1 
0 
1 
2 
3 
4 
5 
6 
7 
8 
n 
0 
1 
2 
3 
4 
5 
n 
(c) g(n)=x(2n-3). 
x(6-n) 
h(n)=x(6-2n) 
5 
5 
4 
4 
3 
3 
2 
2 
1 
1 
0
1
2
3
4
5
 6
7 
n 
–1
0
1
2
3 
4
5
n 
(d) h(n)=x(6-2n). 
v(n) 
5 
4 
3 
2 
1 
–2
–1 
0
1
2
3
4 
n 
(e) v(n)=x(n2-2n+1). 
FIGURE 2.11 Sample sequences for Example 2.11. 

      
     
     
      
     
      
     
      
     
     
      
     
     
      
     
      
     
      
35 
Signals Properties 
x(n) 
n
0 
1 
2 
3 
4 
5 
6 
7 
8 
1 
2.5 
3.5 
4.5 
FIGURE 2.12 Sample sequences for Example 2.12. 
x(n-2) 
1 
2.5 
3.5 
4.5 
x(2n) 
1 
2.5 
3.5 
4.5 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
n 
0 
1 
2 
3 
4 
5 
6 
7 
8 
n 
(a) 
(b) 
x(-n) 
x(n/2) 
4.5 
4.5 
3.5 
3.5 
2.5
2.5 
1 
1 
0 
1 
2
3
 4
5
 6
7
8
 9
10 11 12 13 14 15 16 n 
(c) 
(d) -n 
FIGURE 2.13 Sample sequences for the solution of Example 2.12. 
Example 2.13 
Determine whether the following the sequences are periodic or aperiodic; for each periodic 
sequence determine the fundamental period. 
a) x(n) = sin(0.125πn) 
b) x(n) = cos(π + 0.5n) 
c) x(n) = sin(nπ/15) ejπn/16 
d) x(n) = Re{ejπn/18}+ Im{ejπn/12} 
SOLUTION 
a) x(n) = sin(0.125πn) 
0.125pn = 2pn 
N 
where N is the sample for one period 
N = 16 integer number, so the sequence is periodic. 
And the fundamental period is 16. 
b) x(n) = cos(π + 0.5n) 
2pn
0 5
. n = N 

36 
Digital Signal Processing 
N = 4π has no integer value, so the sequence is aperiodic. 
c) x(n) = sin(nπ/15) ejπn/16 
np 
2pn 
=
→ N1 = 30 
15 
N1 
np 
2pn 
16 = N2 
→ N2 = 32
N N  
30 ×
1
2
 
32
N = 
=
= 480 
gcd(N N
,
2
1 
) 
2 
N is an integer, so the sequence is periodic and the fundamental period is N = 480. 
d) x(n) = Re{ejπn/18} + Im{ejπn/12} 
np 
2pn 
=
→ N1 = 36 
18 
N1 
np 
2pn 
=
→ N2 = 24 
12 
N2 
N N  
36 × 24
N = 
1
2
 
=
= 432 
gcd(N N
, 
) 
2
1
2 
N is an integer, so the sequence is periodic and fundamental period N = 432. 
2.6 DEFINITIONS 
2.6.1 conTinuous-Time sysTem 
In continuous systems, we use the system function H(s) or H(jω) to describe the frequency response. 
The system function describes the response of a system to the special input x(s,t) = e st. The response 
is y(s,t) = H(s)e st. 
Consider a continuous-time system that is described by a differential equation: 
y t  + a y( )( )  + a y
 
( )( )  + + apy p t
( )  
1 1 t 
2
2 t 
( )( )
(2.25) 
0 ( )  
1 1 t 
x q t
= b x t
 
+ b x
 
( )( )  + + bqx( )( )  
Let us substitute x(t) = est and y(t) = H(s)est. Then x(k)(t) = skest and 
y(t) = skH(s)ewt, and we find 
1+ a s  + a s  ++ 
( )
apsp H s est 
( 
1 
2 2 
) 
(2.26) 
= b + b s ++ bqsq e  st 
( 0
1 
) 
This equation will be valid for all values of t provided the coefficients of e st on each side of the 
equation are equal. Solve for the system function: 
H s( )  = 
b0 + b1s + 
2 
+ bqsq 
p 
(2.27) 
1+ a s  + a s  + + a s
1
2 
p 
This function is valid for all values of s for which the denominator is nonzero, Including complex 
and imaginary values. It tells us that any system that is described by a linear differential equation 
with constant coefficients has a system function that is a ratio of polynomials in s. The coefficients 
are the coefficients from the differential equation. 

Signals Properties 
37 
Consider a continuous-time linear system that is described by an impulse response function h(t). 
The response of the system to any input x(t) is 
∞ 
y t( )  = ∫ H
x t − t)
( ) ( 
d 
(2.28)
t
t 
−∞ 
Now let x(t) = e st and y(t) = H(s)e st. Then we must have 
∞
∞ 
H s e st = ∫ h( )es t( −t)dt = ∫ h( )e−st
( )  
t
t 
dt 
−∞ 
−∞ 
Therefore, 
∞ 
H t( )  = ∫ h( )  −std
t e
t 
(2.29) 
−∞ 
This result shows that the system function and the impulse response are a transform pair for time-
invariant continuous-time linear systems. Either function is just an alternative way of looking at the 
behavior of the system. 
A significant use for the system function is in describing the behavior of the system in the fre-
quency domain. Every sinusoidal waveform is written in terms of exponentials. 
Cos wt) = e j t) + (− w
[ (  w 
e
j t)] / 2
(2.30) 
Hence, the response to x(t) = cos(ωt) is y(t) = [H(jω)ejωt + H(−jω)e −jωt]/2. 
For a linear system with real parameters, such as real coefficients in the differential equation 
or real impulse response, the response to a real input, such as a cosine wave, must also be real. 
This requires that the system function has conjugate symmetry. H(−jω) = H*(jω). Every complex 
number is written in a polar coordinate form. If Z is a complex number, then it can be written in 
the form Z = |Z| e jθ. We can apply this to the system function since it is just a complex number at 
any fixed value of ω. Hence the output is y(t) = [|H(jω)|ej(ωt + θ) + |H(jω)|e − j(ωt + θ)]/2 = |H(jω)| 
cos(ωt + θ). 
Therefore, |H(jω)| is the “gain” of the system at frequency ω and θ is the phase shift at frequency ω. 
2.6.2 discreTe-Time sysTem 
The system function for a discrete-time system is based on the difference equation rather than the 
differential equation. Just as in a continuous system, an exponential input to a discrete system will 
produce an exponential response. 
( )  
1 
a y n  
( − 
b x n 
( −1 + + 
(
y n  + a y n
( − ) + 
( − 2) + + a y n
p) = 
( )  + b x n  ) 
b x n − q)
1
2 
p 
0
1 
q 
Let us now substitute the exponential sequence x(n) = zn. Here z is a complex number, which may 
be expressed in the usual complex number forms wherever that becomes useful in the analysis. Let 
us assume that the response is of the form y(n) = H(z)zn. Substitution into the difference equation 
then produces 
−1 
−2 
− p 
−1 
−q
(1+ a z
1 
+ a z  ++ a z  H z  = ( 0 + b z ++ q
2 
p 
) ( )  b 
1 
b z ) 
This solved for the transferred function given by: 
b0 + b1z−1 + + bqz−q 
H z  
(2.31)
( )  = 1+ a z−1 + a z−2 + + a z− p 
1
2 
p 

38 
Digital Signal Processing 
The close relationship between the system function and the difference equation is evident. The sys-
tem function is defined wherever the denominator is not zero. These locations are called the “poles” 
of the system function. 
2.6.2.1 Delay Operator 
Suppose that the z-transform of x(n) is X(z). Then, the z-transform of x (n − k) is X(z)z − k. This is 
shown by the substitution of x(n − k). We can, therefore, refer to z−1 as the delay operator. 
2.6.2.2 Convolution Property 
Let x1(n) and x2(n) be two sequences with z-transform relationships 
x n  ⇔ X z
1( )  
1( )
x n  ⇔ X z( )
2( )  
2 
Let x(n) = x1(n)*x2(n) be the convolution operation. Then the z-transform is determined by the prod-
uct X(z) = X1(z)X2(z). 
2.6.2.3 Impulse Function 
The function δ(n) is defined as the z-transform Δ(z) = 1, as can be easily established from the defini-
tion (2.7). 
∞ 
x z( )  =∑x n z
( )  −n 
(2.32) 
−∞ 
2.6.2.4 Impulse Response 
The impulse response of a discrete linear time-invariant system is called h(n). 
It is the response of the system to an input δ(n). The output for any other input sequence x(n) is 
given by the convolution 
∞
∞ 
y n  = ∑x m h n  −m) = ∑h m x n
m)
( )  
( ) (
 
( ) ( − 
(2.33) 
m=−∞ 
m=−∞ 
Upon using the convolution property, we find that: 
Y z  = X z H z( )
(2.34) 
( )  
( )  
In particular, if the input is an impulse then X(z) = 1 and the z-transform of the response is just H(z). 
Therefore, h(n) and H(z) are a transform pair 
h n
( )  ⇔ H z( )
(2.35) 
2.6.2.5 Frequency Response 
Just as in the continuous case, we can use an exponential input with a discrete system to determine 
its frequency response. Let x(n) = ejωn be an input sequence. The output from (2.8) is 
∞
∞ 
y n  = ∑h m e
 
j n  m
 
) = e jwn∑h m e 
( )  
−jwm 
(2.36) 
( )  
( )
( − 
m=−∞ 
m=−∞ 
The summation is just H(z) with z = ejω. Hence, an exponential input sequence produces the expo-
nential output sequence 
w
y n
( )  = H e jw e j n 
(
) 

Signals Properties 
39 
where 
∞ 
( jw 
( )  
−jwm
H e  ) = ∑h m e 
(2.37) 
m=−∞ 
The system response H(ejω) provides the same kind of information about a discrete system that 
H(jω) provides about a continuous mode. The position of the frequency variable in the exponent 
means that the function is periodic with period 2π. 
The frequency response of the system is 
∞
∞ 
( 
jw) ∑(
)
 − jw 
∑( 
− jw)
m 
1+ 
1 
ae jw
H e  =
−a me
m =
−a 
= 
(2.38) 
m=−∞ 
m=−∞ 
The gain and phase shift of the system at frequency ω is equal to the magnitude and phase angle of 
H(ejω). These are 
1
H e jw = 
(2.39) 
(1+ acos w)2 + a2 sin2 w
(
) 
f(e jw) = −tan −1 
asin w 
(2.40) 
1+ acos w 
The periodic character of both functions is evident since all of the terms in each expression are 
periodic. 
2.7 SYSTEM OUTPUT 
The response of a system can be calculated in several ways. The difference equation can be imple-
mented directly, transforms can be used, and the output can be calculated by the general implemen-
tation of a digital filter. The program filter is one useful computational implementation. An example 
of such a computation is provided by sigdemo 3 and sigdemo 5. Finally, sigdemo 4 shows how the 
spectrum estimate can be improved by averaging many repetitions of power spectrum computations. 
2.7.1 causaliTy 
The output signal depends on the present and previous values of the input. 
Forward difference system (not causal(+)). 
y n  = x n + ] + [ + 2] + x n
[ ]  [
1 
x n  
[ + 3]
Backward difference system (casual(–)). 
y n
[ ]  = x n  + [ 
1] x n
[ ]  x n −
+ [ −2]
2.7.2 sTabiliTy 
Stability is one which produces a finite or bounded output in response to a bounded input. 
∞ 
S = ∑h k
( )  < ∞ 
k=−∞ 
This is stable if S is finite. 

40 
Digital Signal Processing 
2.7.3 inVerTibiliTy 
If a digital processor with input x[n] gives an output y[n] then its inverse would produce x[n], if fed 
with y[n]. 
1 
y n  = m x n
 
→ [ ]  = 
y n  
.
[ ]  
[ ]  x n 
[ ]  invertability 
m 
y n  = (x n )
3 → [ ]  = y n
[ ]  
[ ]  
x n  
3 [ ]  no-invertibility. 
2.7.4 memory 
A processor possesses memory if its present output y[n] contains a storage or delay element and the 
output depends upon one or more previous input value as x[n – 1], x[n – 2],… 
Example 2.14 
The DSP system has x[n] input and y[n] output, and determines which of the properties, linearity, 
time-invariance, causality, stability, invertibility, and memory, are possessed by systems defined 
by the following sequences: 
a) y[n] = x[n] – x[n – 1] 
b) y[n] = y[n – 1] + x[n + 1] 
c) y[n] = n x[n] 
d) y[n] = cos(x[n]) 
SOLUTION 
a) Linear, time-invariant, causal, stable, invertible, and memory. 
b) Linear, time-invariant, noncausal, unstable, invertible, and memory. 
c) Linear, time-variant, causal, stable, invertible, and no-memory. 
d) Non-linear, time-invariant, causal, stable, not-invertible, and no-memory. 
Example 2.15 
Compute the system output 
y n  = 1 5y n − ) + 
( − ) + . x n
( )  .
(
2
2x n  1
2 2 ( )
for the first four samples using the following initial conditions: 
(a) Initial conditions: y(
)2 
. ,y(
)1 
0 x −
= − 
( )  = ( .  
n u n
−
= 0 5
 
−
=
, (  1) 
1, and input x n  
0 75 )
( ) 
(b) Zero initial conditions: y(
)
 y(
)
 0, and x(−
=
)
0 
( )  = ( .  )
( )
−
=
 −
=
 
n u n
2 
1 
1 
, and input x n  
0 75 
SOLUTION 
(a) For n = 0, and using the initial conditions, we obtain the input and output as 
x( )  = ( .  
0 u 0
0
 0 75 )
(
 
) = 1
y( )  = 1 5
 
y 
)
2x(
) 
. x( )
0 
.
(−
+
 1
0
2 
−
+ 2 2  
. × 0 5
. 
2
(
)1 
. × =
1 5  
−
× −
+
 
2 2  
.
= 
1
4 95 
For n = 1, and using the initial conditions, we obtain the input and output as 
x( )1 = ( .
0 75 1 u
)
(1
0
) = .75

41 
Signals Properties 
y( )  = 
y 
) 
x( ) + . x( )
.
(−
+
1 2
0
 2 2
1
1 5 
1 
= . × 0
2
 
. × . 
= − .
1 5  
−
× +
1 2 2
0 75 
0 35
n = 2, 
x( )  = ( .
0 75 2 u 2 = 0.5625
2 
)
( ) 
y( )  = 
y 
+
x( ) + . x( )2
2 
.
( ) 
2 2
1 5
0
 2 1  
. × ( .
)
 
−
× 0 75
2 2
0 5625 
. × . 
= 7.1
= 1 5
4 95
2
 . 
+ 
1625 
n = 3, 
x( )  = ( .
0 75 3 u 3 = 0.4218
3 
)
( ) 
y( )  = 
y + x( ) + . x( )3
3 
.
( ) 
2 2
1 5
1
 2
2
 
. × −
( 0 35
2
 
× . 
+ 2 2  × .
= 1 5  
.
)
 
− 
0 5625 
. 
0 4218 
=
.
= −0 722
It can be seen that the further value of the output can be obtained recursively. 
(b) Setting n = 0, and using the initial conditions, we obtain the input and output as 
x( )  = ( .  
0 u 0
0 
0 75 )
(
 
) = 1
y( )  = 1 5y 
)
2x(
) 
. x
.
( 2 
1 2 2 ( )
0 
−
+ 
−
+ 
0 
. ×
−
×
+
0
2
 
. × = 2 2
= 1 5  
0
2 2
1
 . 
For n = 1, and using the initial conditions, we obtain the input and output as 
x( )1 = ( .
0 75 1 u
)
(1
0
) = .75
y( )  = 
y 
) 
x( ) + . x( )
.
(−
+
1 2
0
 2 2
1
1 5 
1 
= . × 0
2
 
. × . 
= − .
1 5  
−
× +
1 2 2
0 75 
0 35
For n = 2, and using the past values of the input and output, 
x( )  = ( .
0 75 2 u 2 = 0.5625
2 
)
( ) 
y( )  = 
y 
+ 2 1( ) + . x 2
2 
.
( ) 
x 
2 2
1 5
0
 
( )  
= . × . 
2
0 75 + . × 0 5625 =
.
1 5  2 2  −
× . 
2 2  
. 
3 037 5 
For n = 3, 
x( )  = ( .
0 75 3 u 3 = 0.4218
3 
)
( ) 
y( )  = 
y + x( ) + . x( )3
3 
.
( ) 
2 2
1 5
1
 2
2
 
.
)
 
−
× 0 5625 
. 
0 4218 = −0.722
= 1 5
. × −
( 0 35
2
 . 
+ 2 2  × . 
= 
The further value of the output can be obtained recursively. 
Example 2.16 
Compute the DSP system output 
y n  = 5 x n
( )  + 2 ( 
) 
y n −
−2 5
. 
(
x n −
−.
(
 1) 
y n
( )  
1
1 5 
−2) 
with the initial conditions y(
)
1 y −
=
)
, x(
)1 
−1, and input x n  = ( . )
( ).
−
=
2 
, ( 1
0
 −
=
( )  0 5  n u n  

42 
Digital Signal Processing 
(a) Compute the system response y(n) for 25 samples using MATLAB. 
SOLUTION 
A MATLAB program to compute the system response for 20 samples is given below along with the 
corresponding output shown in graphical form. 
Clc; 
Clear all; 
Close all; 
xi = [0 -1]; 
yi = [1 0]; 
n = 0:1:24; 
x = (0.5).^n; 
x = [xi x]; 
> 
y = []; 
y = [yi y]; 
for k = 3:1:27 
r = 5*x(k-2)+2*x(k-1)-1.5*y(k-1)-2.5*y(k-2); 
y = [y r]; 
end 
subplot(2,1,1), stem(n,x(3:27),'filled','LineWidth',2), grid on 
xlabel('n'); ylabel('x(n)'); 
subplot(2,1,2), stem(n,y(3:27),'filled','LineWidth',2), grid on 
xlabel('n'); ylabel('y(n)'); 
Figure 2.14 shows plots of the input and system output for Example 2.16. 
PROBLEMS 
2.1 Write a program to determine the even and odd parts of the signal x(t) given by 
t


 
−at
Ae 
0 
x t( )  = 
<
t 
Then, run the program and display x(t), and the even and odd parts. 
Assume α > 0, A > 0. 
2.2 Write a program to find the even and odd parts of the following sequences: 
a) x1(n) = u(n) 
b) x2(n) = an u(n), a > 0. 
Then, use this program to display x1(n), x2(n), and the even and odd parts of each sequence. 
0 
0 
0 
0.5 
1 
x(n) 
0 
5 
10
15
20
25 
n 
5 
×10 
–5 
0 
5 
y(n) 
0 
5 
10
15
20
25 
n 
FIGURE 2.14 Plots of the input and system output for Example 2.16. 

43 
Signals Properties 
x(n) 
x(n) 
3
4 
0
1 
2 
3 
4 
5
6 
n
-1 
0
1
2
3 
4
5
6 
n 
-1 
(a) 
(b) 
-3 
x(n) 
x(n) 
2 
2 
0
1 
2
3 
4
5 
6
7 
8 
9 n
-1 
0 
1
2 
3
4 
5
6 
7 
8
n 
-1 
-2
- 2  
(c) 
(d) 
FIGURE 2.15 Sample sequences for Problem 2.3. 
x(n) 
x(n) 
4 
4 
3 
3 
2 
2 
1 
1 
0
1
2
3
4
5
6
7
8
n 
0 
1
2
3 
4
5 
6
7 
8
n 
(a) 
(b) 
x(n) 
x(n) 
2
2 
1
1 
0 
1
2
3 
4
5 
6
7 
8
n 
–n 
–5
–4
–3
–2
–1 
0 
1 
(d) 
(c) 
FIGURE 2.16 Sample sequences for Problem 2.5. 

44 
Digital Signal Processing 
2.3 Find the mathematical expressions for the following signals shown in Figure 2.15 
2.4 Sketch the following signals 
a x(n) = –u(n – 3) 
b y(n) = u(n + 2) + 2δ(n – 1) 
c g(n) = r(n – 1) – 2r(n – 4) 
2.5 Find the mathematical expressions for the following signals below (Figure 2.16) 
2.6 Sketch the following sequences: 
a. x n
( )  = d(n 2) 2d(n 
) 
.
( )
 
+ 2d(n
1
1 5
 
d n 
−
−
) 
d(n
+
−
 +
−
 
1
3
 −3) 
b. x n  = 2d(n + ) − 4d(n − ) + .
(
 − 4) + . u n
( )
1 
1
2 5u n  
2 5 ( − 6) 
c. x n
( )  = −2d(n 
)
2d(n 1 
4 ( −
+
−
1
) 
u n
−
+
 
4) 
d. x n  = d(n + ) − 2d(n + ) + 
( − 2) + u n
( )
3 
1
2u n  
4 ( − 3) 
2.7 Determine which of the following is a linear system: 
a. y n
( )  = 2 ( )  + 2x n −
−2 2( )
x n  
( 
2) 
x
n
b. y n  = ( − 2) + x n − ) − ( )  + 4x n
( )  x n  
(
1 
x n  
( )
c. y n  = . 
3( − ) − x n − 2) + 2 ( − ) − x n
( )  2 5x n  1
2 ( 
x n  1
3 ( ) 
2.8 Given the following linear systems, find which one is time-invariant: 
a. y n
( )  = −2 x n −2)
( 
b. y n  = 3 ( − ) + 2 x n
( )  
x n  3
( − 2) 
c. y n  = 4 ( − 6) + 2 x n
( )  
x n  
( − 3) 
d. y n
( )  = 4 x n2
(
)
2.9 Determine which of the following linear systems is causal: 
a. y n
( )  = .
( )
 
+100 x n −
−20
 
(
0 5  x n  
( 
2) 
x n −4) 
x n  
.
( )
 
− 2 x n  
b. y n
( )  = ( + 4) + 0 5
 
x n  
( − 2) 
c. y n
( )  = .
(
 − 2) +100 x n − 2) − 20
 
x n − )
0 5  y n  
( 
(
3 
d. y n
( )  = .
(
) 
100 x n −
−
 x n −2)
y n −
 
−+  
( 
1
20
 
(
0 5
1
1
 
) 
2.10 Determine causality for each of the following linear systems: 
a. y n
( )  = .
( )
 
+ 6 x n −
−. x n −)
2 5  x n  
( 
2) 2 1 ( 
1 
b. y n  = ( + 2) − 2 5
 
x n
( )  y n  
.
(
 −1) 
c. y n  = ( − ) + 
x n
( )  y n  1
1 5
 
.
(
 + 2) 
2.11 Find the unit-impulse response for each of the following linear systems: 
a. y n
( )  = .
( )
 
−. x n −);
 
for n ≥0, x −
=
2
0 x −
=
)
0
1 5  x n  2 5 (
1 
(
)
 , ( 1 
b. y n  = .
( 
)
2 x n  
for n ≥0 y −
= ,
( )  1 75
 
y n −
+
 
( ); 
, ( 1 
0
1
) 
( )  
0 8  y n −
−
1
( −
+
1
0 x −
=
 
0 
c. y n  = −.
(
 ) x n  )
2 x n
(
 
); for n ≥, ( 1) 
, y(
)
−
= 
1
0 
2.12 Determine stability for the following linear system: 
y n  = 0 5  x n − ) + 
( − 2) − 4 x n
( )  .
(
1
2
 
x n  
( − 3) 
x(n) and y(n) are the input and output signals of a digital processor. Determine how the 
following properties are exhibited by each of the systems defined below: linearity, time-
invariance, causality, stability, and memory: 
a) y n  = −x(4 −n
( )  
) 
b) y n
( )  = ( )  + x n −
−
)
( 
x n  
( 
1
2
 
x n −2) 

45 
Signals Properties 
10 
T
X1(n) 
X2(n) 
Y(n) 
FIGURE 2.17 System for Problem 2.14. 
FIGURE 2.18 System for Problem 2.15. 
c) y n
( )  =
⋅( )
n x n 
2.13 Draw a block diagram for a digital processor with the following recurrence formula. 
Distinguish clearly between its nonrecursive and recursive memory. 
a) y n  = .
(
 − ) − . y n − 2) + .
 ( )
 
− . x n
( )  1 5  y n  1
0 5
 
( 
0 75
 
x n  0 4
 
( − 2) 
b) y n  = .
( − ) − . y n − ) + .
 ( )
 
+ . x n  
( )  1 35
 
y n  1 
0 7 ( 
3
1 75 x n  2 5  ( −1) 
c) y n  = .
(
 − ) − . y n − ) + .
( )
 
− . x n  
( )  0 5  y n  1
0 7
 
( 
1 
0 9  x n  1 5  ( −1) 
2.14 Find the output response for the following system shown in Figure 2.17 if: 
X n
1( )  = 0 1.
( )
 
d n + 0 5. d(n 1
0 6
 
) 
.
(
d n −
+
2) 0 6. d(n −)
−
+
 
3 
X n  = d(n 1 
d( )  +1 5
 
d n 
)
. d(n −2
2( )  
+
+
 
) 
n 
.
(
 −
−
1
1 6  
) 
2.15 Find the response of the system shown in Figure 2.18 due to a unit step input. 


3 Convolution 
Characteristics of linear systems are described by the system’s impulse response, as administrated 
by the mathematics of convolution. The important of the impulse response is because of its uses in 
many practical aspects, as echo suppression in long-distance telephone calls. This chapter describes 
the properties of one of the most common applications of impulse response called convolution. 
First, several conventional coevolution methods discussed. Second, it will be presented dealing 
with cascade and parallel combinations of linear systems. Third, the technique of correlation will 
introduce. Fourth, a different problem with convolution examined. 
3.1 LINEAR CONVOLUTION 
A system that is both linear and shift-invariant (time-invariant) is referred to as a linear shift-
invariant (LSI) system. If x(n) is the response of an LSI system to the unit sample δ(n), its response 
to δ(n – k) will be h(n – k). Therefore, in the superposition the sum is given as: 
∞ 
y n  
x k h  n 
k 
k
( )  
( )  ( )
= 
=−∞ 
∑ 
(3.1) 
then it becomes: h n
k( )  
and it follows that 
= h n  k 
( 
)
− 
y n  
x k h n
k
k 
( )  
( )  ( 
)
= 
− 
=−∞ 
∞ 
∑ 
(3.2) 
This equation is known as the convolution sum and written as 
y n  
x n  h n
( )  ( )* (  ) 
= 
(3.3) 
Where * indicates the convolution operator. The sequence h(n) referred to as the unit sample 
response or impulse response provides a complete characterization of an LSI system. In other 
words, the response of the system to any input x(n) is found once h(n) is known. 
3.2 CONVOLUTION PROPERTIES 
Convolution is a linear operator and, therefore, has several essential properties, including the com-
mutative, associative, and distributive properties. 
3.2.1 Commutative ProPerty 
The commutative property states that the order in which two sequences convolved is not essential. 
Mathematically, the commutative property is 
x n
( )* ( )
 
h n  = h n  x n
(
 
)* ( )
(3.4) 
From a systems point of view, this property states that a system with a unit sample response h(n) and 
input x(n) behaves in the same way as a system with a unit sample response x(n) and an input h(n). 
This illustrated in Figure 3.1(a) (Figure 3.1). 
47 

h1(n)
h2(n)
h1(n)
h1(n)
48 
Digital Signal Processing 
x(n) 
y(n) 
h(n) 
x(n) 
y(n)
h(n) 
FIGURE 3.1 The commutative property. 
x n  h n  h n
( )*
(
 ) *  ( )
1 
2
[ 
] 
= x n  h n  h n
( )* 
( )* ( )
1 
2
[ 
] 
(3.5) 
3.2.2 assoCiative ProPerty 
The convolution operator satisfies the associative property, which is 
h
n
eq ( )  = h n  h n
( )*
( )
1 
2 
(3.6) 
From a systems point of view, the associative property states that if two systems with unit sample 
responses h1(n) and h2(n) are connected in cascade as shown in Figure 3.1(b), an equivalent system is 
one that has a unit sample response equal to the convolution of h1(n) and h2(n) (Figure 3.2): 
3.2.3 Distributive ProPerty 
The distributive property of the convolution operator expresses as 
x n
( )*[h n
( ) + 2( ) 
x n  h n + ( )*
( ) 
2
1 
h n ] = ( )* 1( )  x n  h n
(3.7) 
From a systems point of view, this property asserts that if two systems with unit sample responses 
h1(n) and h2(n) are connected in parallel, as illustrated in Figure 3.4(c), an equivalent system is one 
that has a unit sample response equal to the sum of h1(n) and h2(n) (Figure 3.3): 
h
n
( )  = h n
1( )  + h n
(3.8)
eq 
2( )
3.3 TYPES OF CONVOLUTIONS 
Several different approaches are used, and the one that is the easiest will depend upon the form and 
type of sequences convolved. 
1. Equations Method 
2. Graphical Method 
3. Alternative Method 
x(n) 
y(n)
x(n)
y(n)
h1(n) 
h2(n) 
x(n) 
y(n) 
h1(n)+h2(n) 
FIGURE 3.2 The associative property. 
h1(n) 
x(n) 
y(n) 
h2(n) 
x(n) 
y(n) 
h1(n)+h2(n) 
FIGURE 3.3 The distribution property. 

49 
Convolution 
FIGURE 3.4 The convolution sequences. 
3.3.1 equations methoD 
1) N is the number of samples of the resultant signal from convolution processing for one period 
N
N
N
= 
1 + 
2 −1
(3.9) 
where N1 is the number of samples of the first signal, 
N2 is the number of samples of the second signal, and 
N  is the number of samples of the resultant signal. 
2) The left and right extremes are found using the left and right extremes of the two sequences 
to be convolved, i.e., 
y
 x
h
l = 
l + l 
(3.10) 
y
 x
h
r = 
r + r 
(3.11) 
Where xl, hl, and yl are the left extremes of the signals x, h, and y, respectively. In a similar 
manner, xr, hr, and yr are the right extremes of the signals x, h, and y, respectively. 
Example 3.1 
Find the convolution of the two discrete-time signals which are given below: 
x n  = [ , , , , ],
 
and h n  
1 −
−
 
( )  11 0 11 
( )
[
 
=
,
,
,
2
3 4 ]
where x(0) = 0, and h(0) = 4. 
SOLUTION 
From the graphs shown in Figure 3.4, we have xl = −2, xr = 2, hl = −3, and hr = 0 
Therefore, the left and right extremes of the convolved signal yL(n) are 
yl = x + l 
2
(
)3
l
h = −+ − = −5 
yr =
 +
 =
+
=
xr 
hr
2
0
 2
The number of samples is: 
N1 = 5 N 
4 
= 
1 +
 −=
+
−=  
4
1
 8
,
2 =
⇒
 
N
N
N 2
1
5
 

50 
Digital Signal Processing 
The convolved signal yL(n) is expressed as 
∞ 
y
n
 = ∑x k h n
k)
L( )  
( ) ( − 
k=−∞ 
when n = 0 
∞ 
yL( ) = 
x k h  k
0 ∑( ) (
)
− 
k=−∞ 
x
h 
x(
) ( )  
1
1
h 
+ ( ) ( ) + x
h
1 
−) + x
h
2
(
) ( )  
2
2 +
−
 
x
h
 
( ) ( 1 
( ) (−2)
=
−
 
0
0
 
( )1 0 + 1 0 + 0 4
( )
( )1
3
 (
)
 −5
( )
( )( )
( )
(
)
( )1
2
= 
+
−
+
−
=
when n = 1 
∞ 
yL( ) = ∑x k h 1−k)
1 
( ) ( 
k=−∞ 
x
h 
x(
) ( )  
1
2
h 
+ ( ) ( ) + x
h
1 
0) + x
h −1
(
) ( )  
2
3 +
−
 
x
h
 
( ) (  )
=
−
 
0
1
( ) ( 
2 
( )1 0 + 1 0 + 0 0
( )
( )1 4  
(
)
 1
( )  ( )( )  ( )
+ 
1
3
= 
( )  ( )
+ 
−
= 
when n = 2 
∞ 
yL( ) = ∑x k h 2 −k)
2 
( ) ( 
k=−∞ 
x
h 
x(
) ( )  
1
3
h 
+ ( ) ( ) + x
h
1
) + ( ) (0)
(
) ( )  
2
4 +
−
 
x
h
0
2
( ) ( 
2
=
−
 
1 
x
h
1 0 + 1 0 + 
( )  ( )1 0 + 
( ) = 4
= ( )( )  ( )
0 0 + 
1 4
( )
( )
( )
( )
when n = −1 
∞ 
∑( ) (−−k
yL(
)
−
=
1 
x k h  1
) 
k=−∞ 
x 2
1
h
x(
) ( )
h 
+ ( ) (
)
 
0 
−
+
1 
x( h −
+ x( ) (  ) 
3
(
) ( ) +
−1
0
 x
h
 
1)
2 
2 h −
=
−
 
) (  ) 
( )1 0
( )  ( )
+ 1 4 + 0 (
)
( )
1 1( )
( )  ( ) −
+ 
−
+
3 
(
)
( )
= 3
= 
1
2
 
when n = −2 
∞ 
yL(
)
 
x k h −−
2 k)
−
= ∑( ) (
2 
k=−∞ 
x 2
0
h
x(
) (
)
h −
+
1 
( ) (
)
 
2 
x( h 3 
x( ) (−4)
(
) ( ) +
−1 
x
h
0 
−
+
 ) (
) 
2 h
=
−
 
1 
−
+
 
= ( )1 4 + 1
3
(
)
( )
0 
2 
( )
( )
+ 1 0
−
+ 1 1  
( ) = 2
( )  ( ) −
+
 (
)
( )
when n = −3 
∞ 
( ) (−−k
yL(
)
−
=
3 ∑x k h  3
) 
k=−∞ 
x 2 h 1 
x(
) (
)
h −
+ ( ) (
)
 
3 
x( ) (
)
 
1 h 4 
x 2 h −5
=
−
 
0 
−
+
(
) (
)
−
+
 −1
2 
x
h
 
(
−
+ ( ) (
)
( )1
3
(
)
( )
−
+ 
(
)
 ( )
0 1 + 1 0 + 
( )
−
+ 
( )  ( )( )  ( )1 0 = −5 
= 
1
2
 

51 
Convolution 
when n = −4 
∞ 
( ) (
 
−−k
yL(
)
−
=
4 ∑x k h  4
) 
k=−∞ 
x 2 h 2 
x(
) (
)
 
h −
+
 
( ) (
)
 
4 
x( ) (
)
 
1 h 5 
x 2 h −6
=
−
 
0 
−
+ 
(
) (
)
 
−
+
−
 
1
3 
x
h
 
(
−
+ ( ) (
)
= ( )(
)
 ( )( )  ( )
+ 0 0 + 1 0 + 
( )
−
+
 
1 1  
( )  ( )( )  ( )
= −1
1
2
 
1 0  
when n = −5 (Figure 3.5) 
∞ 
yL(
)
 
x k h −−
5 k)
−
= ∑( ) (
 
5 
k=−∞ 
x 2 h 3 
x(
) (
)
 
h −
+
 
( ) (
)
 
5 
x( ) (
)
 
1 h 6 
x 2 h −7
=
−
 
0 
−
+ 
(
) (
)
 
−
+
 −
 
1
4 
x
h
 
(
−
+ ( ) (
)
= ( )1 1( )  ( )
+ 0 0
( )  ( )( )  ( )
+ 1 0
+ 1 0
( )  ( )
+ 1 0  
( ) = 1 
Example 3.2 
Find the response of the filter with an impulse response h(n) = [1,2,4] to the input sequence 
x(n) = [1,2]. 
SOLUTION 
The type of convolution is a linear convolution. 
Here, N1 = 2 and N2 = 3. Then N = N1 + N2 – 1 = 4. 
∞ 
y n
( )  = ∑x k h n  
( ) ( −k)
L 
k =−∞ 
Therefore, 
∞ 
yL ( )  = ∑x k h  −k = x 0 h 0 + x( ) (
)
 1 1
 
+ ( )( )  = 1
( ) (
)
 ( ) ( )  
1h −
=
 
( )( )  2 0
0
1 
k =−∞ 
yL (n) 
4 
3 
2 
1 
-4 -3 
-5 
-2
-1 
0
1
2 
n 
-1 
-2 
-3 
-4 
-5 
FIGURE 3.5 The convoluted sequence. 

52 
Digital Signal Processing 
∞ 
yL( )  = ∑x k h 1−k) = x( ) ( )  + x 1
0
 = 1 2  + ( )( )  
1 
( ) (
 
h 
( ) ( )  
h 
( )( )  2 1  = 4
0
1
 
k=−∞ 
∞ 
yL( )  = 
x k h  2 −k) = x( ) ( )  + x 1 1  = 1 4  + ( )( )  
2 ∑ ( ) (
 
h 
( )  ( )  
h 
( )( )  2 2  = 8
0
2
 
k=−∞ 
∞ 
y ( )  = ∑x k h 3 −k) = x( ) ( )  + x
h 
1
2
 = 1 0  + ( )( )  
L 3 
( ) (
 
h 
( ) ( )  ( )( )  2 4  = 8
0
3
 
k=−∞ 
L( )  
, ,
⇒ y n  = [ ,1 4 8 8]
Example 3.3 
Determine the linear convolution of the two finite duration sequences given below: 
 
−≤
≤ 
1
1
1 n 1 
1 
−≤ ≤ 
n 1
x n  = 
and h n  =
( )   
( )   
0 
otherwise 
0 
otherwise 
SOLUTION 
We know that the convolution of the two sequences is expressed as 
∞
∞ 
y n  = ∑x k h n  k
 
( ) (
 
− ) = ∑ (
L( )  
x n
k h k  
− ) ( )
k=−∞ 
k=−∞ 
First plot the given sequences (Figure 3.6). 
To find the convolution, we have 
∞ 
n =
⇒
0 
yL( )  = ∑x k h  k 
−
0 
( ) (
)
 
k=−∞ 
x(
) ( )  
h 
+ x
h
0
0
 
+ x
h
( ) (
)
=
−1
1
 ( ) ( )  
1 
−1 
= 1 1 + ( )( )  + 1 1
 
( )( )  1
 
1
 ( )( )  = 3 
when 
∞ 
n =
⇒yL 1 = 
x k h 1−k
1 
( )  ∑( ) (
 ) 
k=−∞ 
x
h 
+ 
0
1
 
+ x
h
( ) ( )
=
−
(
) ( )  
1
2
 x
h
( ) ( )  
1
0
= 1 0 + ( )( )  + 1 1
 
( )( )  1 1
 ( )( )  = 2 
FIGURE 3.6 The convolution sequences. 

53 
Convolution 
when 
∞ 
n =
⇒yL 2 = 
( ) (
 
2 −k)
2 
( )  ∑x k h  
k=−∞ 
x
h 
+
0
2
 
+ x
h
( )  ( )
=
−
(
) ( )  x
h
 
1
1
1
3
 ( ) ( )  
( )(0 +
= 1 ( )  ( )( )  ( )( )
1 0
 
+ 1 1
 
= 1 
when 
∞ 
n = − ⇒
 
y −1 = ∑( ) (
 
−− k
1 
L(
)
 
x k h  1
) 
k=−∞ 
=
−
x
h 
+ 
0 
−1 + x
h
( ) (
)
(
) ( )  x
h
( ) (
)
 1 
−
1
0
 
2) 
= ( )( )  ( )( )  ( )( )
+ 1 1 + 1 0  =
1 1  
2 
when (Figure 3.7) 
∞ 
n = −⇒
 
y −2 = ∑( ) (
 
−− k
2 
L(
)
 
x k h  2
) 
k=−∞ 
=
−
x 1 h −
+ ( ) (
)
 
0 
−
+ x
h −3
1 
x
h
 2 
( )1 ( 3
(
) (
)
 
) 
1 1 + 1 0  + 1 0  = 1
= ( )( )  ( )( )  ( )( )  
3.3.1.1 Convolution of Two Sequences in MATLAB 
To write a MATLAB program to find the convolution of two sequences follow the below. 
clc; 
clear all; 
close all; 
n=0:8; 
x1=1; 
x2=0; 
y1=x1.*(n>=0 & n<=2)+x2.*(n>=2 & n<=8); 
subplot(2,2,1); 
stem(n,y1); 
axis([0 8 0 1.5]); 
xlabel('time n ---->'); 
FIGURE 3.7 The convoluted sequence. 

54 
Digital Signal Processing 
ylabel('amplitude---->'); 
title('the sequence y1[n]') 
y2=x1.*(n>=0 & n<=4)+x2.*(n>=4 & n<=8); 
subplot(2,2,2); 
stem(n,y2); 
axis([0 8 0 1.5]); 
xlabel('time n ---->'); 
ylabel('amplitude---->'); 
title('the sequence y2[n]') 
y=conv(y1,y2); 
L=length(y); 
n=0:L-1; 
subplot(2,2,[3,4]); 
stem(n,y); 
axis([0 10 0 4]); 
xlabel('time n ---->'); 
ylabel('amplitude---->'); 
title('the convolution sequence of y1[n]&y2[n]'); 
Figure 3.8 shows the convolution and convoluted sequences obtained from running the MATLAB 
program. 
3.3.2 GraPhiCal methoD 
The steps for finding out the convolution sum are as follows: 
1) Plotting: Plot both sequences, as a function of k. 
2) Folding: Fold the signal x2(k) about the origin, meaning x2(n) becomes x2(−n). 
3) Shifting: Shift x2(−k) to the right by, n0 it is positive or shift x2(−k) to the left by n0 if n0 it 
is negative to obtain x2(n0 − k). 
4) Multiplication: Multiply the product sequence x2(k) by x2(n0 − k) to obtain the product 
sequence. 
5) Summation: Sum all the values of the product sequence to obtain the value of the output 
at a time n = n0. 
x(n) 
h(n) 
1.5 
1.5 
amplitude
amplitude
1 
0.5 
1 
0.5 
0 
0 
0
2
4
6
8 
0
2
4
6
8
n
 n 
y(n)=x(n)*h(n) 
0 
1 
2 
3 
4 
amplitude 
–1
0 
1 
2 
3 
4 
5 
6 
7 
8 
9
10 
n 
FIGURE 3.8 The convolution and convoluted sequences. 

Convolution 
55 
Example 3.4 
The previous example can also be solved using the graphical method below. 
We know that (Figure 3.9) 
∞ 
y n
( )  = ∑x k h n
( ) ( −k)
L 
k=−∞ 
Alternative Method: Using the matrix representation, the linear convolution of the given two 
sequences is determined as in Table 3.1 
So the result of convolution is given as y
n = [ ,1 4 8 8].
L( )  
, ,  
3.3.3 tabular methoD 
Example 3.5 
Find the convolution between 
( )  
] 
( )  5 4 3, ,2 1] 
x n  = [1 2 3 4 5 
, ,  , ,  and h n  = [ , ,  
SOLUTION 
N1 = 5, N2 = 5, N1 + N2 = 5 + 5 = 10, N1 + N2 = 1 = 10 – 1 = 9 so the output sequence will be 
from y(0) to y(9) 
1
2
3
4
5 
← x(n) 
y(0)
1
2
3
4 
5 
← Reversed h(n) 
y(1) 
1
2
3
4
5 
y(2) 
1
2
3
4
5 
y(3) 
1
2
3
4
5 
y(4) 
1
2
3
4
5 
y(5) 
1
2
3
4
5 
y(6) 
1
2
3
4
5 
y(7) 
1
2
3
4
5 
y(8) 
1
2
3
4
5 
y(9) 
1
2
3
4
5 
y(0) = 1*5 = 5 
y(1) = 1*4 + 2*5 = 14 
y(2) = 1*3 + 2*4 + 3*5 = 26 
y(3) = 1*2 + 2*3 + 3*4 + 4*5 = 40 
y(4) = 1*1 + 2*2 + 3*3 + 4*4 + 5*5 = 55 
y(5) = 2*1 + 3*2 + 4*3 + 5*4 = 40 
y(6)= 3*1 + 4*2 + 5*3 = 26 
y(7) = 4*1 + 5*2 = 14 
y(8) = 5*1 = 5 
y(9) = 0 
Example 3.5 
Convolve x(n) = (0.5)n u(n) 
With the ramp sequence h(n) = u(n) 
The convolution of x(n) with h(n) is given by 
¥ 
y n  = x n
( ) * ( )
h n  = åx k h n - k)
( )  
( ) ( 
k =-¥ 
¥ 
é
k 
ù
ë( . )
( )û
- k
= å 0 5  u k  [ u n
(
)] 
k =-¥ 

56 
Digital Signal Processing 
FIGURE 3.9 The convolution and convoluted sequences of Example 3.4. 
u(k) = 0 for k<0, and u(n – k) = 0 for k>n, so 
n 
y n
( )  = x n  h n  =∑[( . ) ]  n
( )* ( )
 0 5  k 
≥ 0 
k=0 
n 
y n
( )  = x n  h n  =∑( . )  n
( )* ( )
 0 5  k 
≥ 0 
k=0 

57 
Convolution 
FIGURE 3.9 (Continued) 
Using series given in the table, we have 
− ( . )n+1 
1
0 5 
y n  = x n
( )* ( ) =
( )  
h n  
− .
1 0 5 
= 2 1  ( . ) 
0 5  n+1 
n ≥ 0
− 
 
Example 3.6 
Convolve x(n) = (0.8)n u(n) with the ramp sequence h(n) = n u(n). 
The convolution of x(n) with h(n) is given by 
∞ 
y n  = x n
( )* ( ) = ∑x k h n −k)
( )  
h n  
( ) (  
k=−∞ 
∞ 
k
[( . )  u k( )] ([ n
k u n
− ) (  − k)]
= ∑ 0 8  
k=−∞ 

58 
Digital Signal Processing 
n 
∑
=
−
FIGURE 3.9 (Continued) 
TABLE 3.1 
Convolution of Two 
Sequences 
h(n) 
x(n) 
1
2
4 
1 
1
2
4 
2 
2
4
8 
u(k) = 0 for k<0, and u(n – k) = 0 for k>n, so 
[(
 
n
k
 
k 0 
k
≥0
h n
( )* ( )
 
y n
( )  
)( . ) ]  
0 8
=
=
x n  
n 
n
n 
y n  = x n  h n  = n∑( . )  −∑k( . ) 
n
( )  ( )* ( )
 0 8  k 
0 8  k 
≥ 0 
k=0 
k=0 
Using the series given in the table, we have 

Convolution 
59 
y n  = x n
( )* ( )
( )  
h n  
1
0 8
- ( . )n+1 
n( . )n+ 2 - (n + 1 0 8 n-1 + 0.8 
0 8  
)( . )
= n 
-
1 0 8 
1 0 8 2
- .
( - . ) 
5
1
n - 0 8 n+1 
25ëé ( . )  
0 8 n+ 2 - (n + )( . )n-1 + 0 8ûù
= 
éë 
( . ) 
ùû -
n 
1 0 8 
. 
n ³ 0 
= 
n + 
. n 
+ 31 25 0 8 + 20ùûu n  n ³
éë5 
11 25 0 8 
( . )n 
.
( . )n 
( )  
0 
Example 3.7 
Convolve x n  = ( . )n u n  with the ramp seque ce h n
( ) = 0 5 n [ ( ) − ( − 10)].
( )
0 7
( ) 
n
( . ) u n  u n  
SOLUTION 
∞ 
y n  = x n
( )* ( ) = ∑x k h n −k)
( )  
h n  
( ) (  
k=−∞ 
For n<0, y(n) = 0. 
For 0 ≤n ≤10, 
∞ 
y n  = x n
( )* ( )
h n  = 
( . )k u n  − ( −10) ( .  )n−k u n
( )  
∑0 5  [ ( )  u n  
] 0 7  
( −k) 
k=−∞ 
10 
=∑0 5 k( .
− 
( −k)
( . ) 0 7 n k u n  
k=0 
u n − k) = 1
for k ≤ n
( 
, so 
10 
h n  ∑( . ) ( .  )
y n
( ) = x n
( )* ( ) = 
0 5 k 0 7 n−k 
k=0 
10 
k
n 
−k
y n
( ) =∑( . ) (  . ) ( .  )
0 5  0 7  0 7  
k=0 
10 
= 0 7 n
k 
−k
( . ) ∑( . ) ( . ) 
0 5  0 7  
k=0 
10 
k 
0. )n 
k=0 
= (0 7  ∑

 7
5
 
1− 
 
5 

 
n+1 
= 0 7
( . )n 
7 
1− 
 7
5
 
y n  =
. (  . )n  
1−
5 


n+1 
0 
n
( )  3 5 0 7   

≤
≤10 

7


 
For n ≥10, u n − k) = 1 f
ll k in the r n
refore,
( 
or a
a ge 0 ≤k ≤10, the
y n  = 3 5 0 7  
. (  . )n  
1− 
 5 


11 
n
( )  
 

≥ 10 


 
7 
 
y n  = . 
( . )n
n
( )  3 4135 0 7  
≥ 10 

60 
Digital Signal Processing 
FIGURE 3.10 The convolution sequences of Example 3.8. 
Example 3.8 
∞ 
y n  = ∑h k x n  −k)
( )  
( ) ( 
k =−∞ 
a. Using the graphical method; 
b. Using the tabular method. 
SOLUTION 
(a) Graphical method: Sketches of x(k) and h(k) are given in the following (Figures 3.10 and 3.11). 
And for n ≥7, y(n) = 0. 
(b) Tabular method 
k 
−4 −3 −2 −1 0 
1 
2 
3 
4 
5 
6 
7 
x(k) 
−2 −2 −2 1 
1 
h(k) 
2 −1 −1 
x(−k) 
1 
1 −2 −2 −2 
y( )
0
 2
 2
 4
=
´ - = -
x(1 − k) 
1 
1 −2 −2 −2 
y( )
1
 2
 2
(
)
(
)
1 
2 
2
=
´ - + -
´ -
= -
x(2 − k) 
1 
1 −2 −2 −2 
y( )
2
 2
 2
(
)
(
)
(
)
(
)
1 
2 
1 
2
 0
=
× −+ −
× −
+ −
× −
=
x(3 − k) 
1 
1 −2 −2 −2 
y( )
3
 2
1
(
)
(
)
(
)
(
)
1 
2 
1 
2
 6
=
×
 + − × − + − × − = 
x(4 − k) 
1 
1 −2 −2 −2 
y 4
 2
1
 1
 1
 1 
2
 3
( ) =
×
 + −(
) ×( ) + −(
) × −(
) = 
x(5 − k) 
1 
1 −2 −2 −2 
y( )
(
)
( )
(
)
( )
5
 1
 
1
 1 
1 
2
= − ×
 + −
×
 = − 
x(6 − k) 
1 
1 −2 −2 −2 
y( )
(
)
( )
6 
1 
1 
1
= − ×
 = − 
x(7 − k) 
1 
1 −2 −2 −2 
y( )
7
 0
= 
PROBLEMS 
3.1 Find the convolution of the two discrete-time signals which are given below: 
x n  = [ , , ,  , ,  ], and h n  = −1 4 3 2 
( )  0 1 2 3 4 5
 
( )  [
, , , ] 
where x(0) = 0, and h(0) = 4. 
3.2 Find the convolution of the two discrete-time signals which are given below: 
( )  
( )  = −
[
, , ,
x n  = −
[
, , ,  
1 1 2 3 4 5
 
, ,  ], and h n  
1 4 3  2 ] 
where x(2) = 3, and h(–1) = –1 

61 
Convolution 
FIGURE 3.11 The convoluted sequence of Example 3.8. 

62 
Digital Signal Processing 
3.3 Find the convolution of the two discrete-time signals which are given below: 
( )  
( )
[
 
= −1 2 1
x n  = −
[
, , , ],
 
1 1 2 5  and h n  
, , ]
where x(2) = 3, and h(0) = –1 
3.4 Write a program to convolve the two digital sequences given by: 
x1 = 3r[n + 3] − 3r[n −1] −12u[n − 4] 
 
n 
for 0 
n
exp( )
 
≤
≤3 
x2 =  
0 
otherwise 
Then, run the program and display the result. 
3.5 Write a program to perform the linear convolution of the two sequences below in the time 
domain. 
n 
for 0 
n
≤
≤3 
h n  

( )  = 
0 
otherwise 
n 
for 1 n
|
|
 
−≤ ≤ 1
x n
( )  =  
0 
otherwise 
Use this program, to generate and plot the sequences h(n), x(n), and the output sequence. 
3.6 Write a program to compute the output y(t) for a continuous-time LTI system whose impulse 
response h(t) and the input x(t) are given by: 
−at 
at
h t  = e
u t
x t
 
( ), ( )
 
= 
(− ), a
( )  
e u
t
 
> 0 
Use this program, to generate and plot the signals h(t), x(t), and y(t). 
3.7 Convolve x(n) = (0.45)n u(n) 
With the ramp sequence h(n) = n u(n) 
The convolution of x(n) with h(n) is given by 
∞ 
y n  = x n  h n  = ∑x k h
( ) (  n
k)
( )  ( )* ( )
 
− 
k=−∞ 
3.8 Convolve x(n) = (0.5)n u(n) 
With the ramp sequence h(n) = (n – 1) u(n) 
The convolution of x(n – 2) with h(n) is given by 
∞ 
y n  = x n  h n  = ∑x k h
( ) (  n
k)
( )  ( )* ( )
 
− 
k=−∞ 
3.9 Convolve x n
( )  = ( .
)
( )
0 75 n u n  
With the ramp sequence h n  = ( .  ) [u n  − u n − )]
( )  0 45 n 
( )
 ( 
5 
3.10 Convolve x n  = 0 9  n u n
( )  ( . )
( ) 
With the ramp sequence h n  = ( .  )n[u n  − u n − 6)]
( )
0 65 
( )
 ( 
3.11 Find the convolution for the two sequences: 
x n  = 0 8  n u n  
( )  = 0 8  n u n − ).
( )  ( . )
( ), h n  ( . )
(
 1 

63 
Convolution 
3.12 Find the convolution for the two of following: 
n
n
A X n
( )  = ( . )
( ), h n  = 0 8  u n − ).
0 8  u n  
( )
( . )
(
 1 
B X n
( )  = [ , , , , ,  ], h n  = [ ,  , ,  ]. 
0 0 0 3 1 2 
( )  4 2 3 2 
C h n  = sin( *
/
 
4 
u n − ( − 4)]*( 2n 
( )  
n p 
)*[ (  ) u n 
−1) 
x n  = 
n p 4)*[ (  − ) − u n 
( )  cos( *
/
 
u n 1
( − 5)] 
3.13 Let y(n) = x(n)⊗h(n) and w(n) = x(n – 1)⊗h(n – 2) where x(n) and h(n) are given as shown 
below to 
find y(n). Express w(n) in terms of y(n) using a z-transformation (Figure 3.12). 
3.14 Find the convolution of the two sequences: 
x n  = d(n 2) 2d(n 4) 3d(n
( )  
−
− 
−
+ 
−6) 
( )  
+
+
3 
n 
2) d(n
h n  = 2d(n 
) d( )  + 2d(n −
+
 −3) 
3.15 Using the following sequence definitions 
−1, 
k = 0 1 2
, , 
 1, 
k = 0,


( )
1
3 4 
1 
= ,2 
x k  = , 
k = , 
and h k
( )  = − , 
k 1 
 0 
elsewhere 
 0 
elsewhere


evaluate the digital convolution. 
3.16 Determine stability for each of the following linear systems: 
∞ 
y n  =∑ . 
k x n − k)
( )  
0 72 ( 
k=0 
∞ 
y n  =∑3k x n
(
( )  
− k) 
k=0 
3.17 Given the sequence 
 3, 
k = , ,
0 1 2  
 
 
h k
( ) = 1, 
k = 3,4 
0 
elsewhere 
where k is the time index or sample number. 
a. Sketch the sequence h(k) and the reverse sequence h(−k). 
b. Sketch the shifted sequences h(−k + 2) and h(−k − 3). 
h(n) 
x(n) 
2 
–1
2 
2 
1
1 
n 
n 
FIGURE 3.12 The convolution sequences of Problem 3.13. 

64 
Digital Signal Processing 
3.18 Using the following sequence definitions 
 
 
3, 
k 
, , 
0 1 2  
3, 
k 
0, 
= 
= 
 
 
h k
( ) = 2, 
k 
, 
and x k 
3 4 
( )  
2, 
k 1,2 
= 
= 
= 
 0 
elsewhere 
 0
elsewhere 
evaluate the digital convolution. 
∞ 
y n  = ∑x k h n
k)
( )  
( ) ( − 
k=−∞ 
a. Using the graphical method. 
b. Using the tabular method. 
c. Applying the convolution formula directly. 
3.19 Given the sequence definitions 
− 
0 1 2  
= ,
 2 
k = , ,  
 2 5. 
k 
0 


( )  1 5  
3 4  
1 2  
= 1 2
x k  = 
. 
k = , 
and h k 
( )  =
− . 
k 1, 


0 
elsewhere 
0 
elsewhere 
evaluate the digital convolution. 
∞ 
y n  = ∑h k x n  −k)
( )  
( ) (  
k=−∞ 
a. Using the graphical method. 
b. Using the table method. 
c. Applying the convolution formula directly. 

4 Difference Equations 
The signals classify to two types with respect to time. One can think of time as a continuous 
variable, or one can think of time as a discrete variable. The ﬁrst case often leads to differential 
equations. Difference equations relate to differential equations as discrete mathematics relates to 
continuous mathematics. We will not discuss differential equations in these notes.in this chapter 
will discuss the difference equation as one application in discrete signals 
4.1 DIFFERENCE EQUATIONS AND IMPULSE RESPONSES 
Now we study the difference equation and its impulse response. 
Format of Difference Equations 
A causal, linear, time-invariant system can be described by a difference equation with the fol-
lowing general form: 
y n  + b y n
 
− ) + + 
( − ) = a
 
x n  + 
( −1) + + a 
( − M
( )  
(
1 
b
y n  N
 
( )  a x n
 
x n  
) 
(4.1) 
1 
N 
0
1 
M 
where b1,…, bN and a0, a1,…, aM are the coefﬁcients of the difference equation. The equation above 
can further be written as: 
N
M 
y n
( )  = −∑b y n
j
 
( −
+∑a x(n
i
j 
) 
i 
− ) 
(4.2) 
j=1 
i=0 
Notice that y(n) is the current output, which depends on the past output samples y(n − 1),…, y(n − N), 
the current input sample x(n), and the past input samples, x(n − 1),…, x(n − N). 
For an LTI system that is described by a difference equation, the unit sample response, h(n), is 
found by solving the differential equation for x(n) = δ(n) assuming initial rest. 
For a nonrecursive system, bj’s = 0, the difference equation becomes: 
M 
y n
( )  =∑a x(n
i
i 
− ) 
(4.3) 
i=0 
And the output is simply a weighted sum of the current and past input values. As a result, the unit 
sample response is 
M 
h n  = 
ai d(n − i
( )  ∑ 
) 
(4.4) 
i=0 
Thus, h(n) is ﬁnite in length, and the system is referred to as a ﬁnite-length impulse response (FIR) 
system. However, if bj’s ≠ 0, the unit sample response is, in general, inﬁnite in length and the system 
is referred to as an inﬁnite-length impulse response (IIR) system. For example, if: 
( )
1 
( )
 
= b
 
u n
y n  = b y n
 
( − ) + x( )
n , the unit sample response is h n 
n ( ). 
(4.5) 
65 

66 
Digital Signal Processing 
Example 4.1 
Given the following difference equation: 
( )  0 25
 
( 
+ x n  
y n  = . 
y n − 1)
 ( ) 
identify the nonzero system coefficients. 
SOLUTION 
By comparing variables that lead to: a0 = 1 and −
= 0 25 
b 
−0 25 
b 
. 
⇒
=
.
1
1 
Example 4.2 
Given a linear system described by the difference equation: 
y n  = x n
( )  + 0 5  x n − 1) 
( )  
.
(
 
determine the nonzero system coefficients. 
SOLUTION 
By comparing variables that lead to: a0 = 1 and a1 = 0.5 
4.2 SYSTEM REPRESENTATION USING ITS IMPULSE RESPONSE 
A linear time-invariant system can be completely described by its unit-impulse response, which is 
deﬁned as the system response due to the impulse input δ(n) with zero initial conditions. With the 
obtained unit-impulse response h(n), we can represent the linear time-invariant system. 
Example 4.3 
Given the linear time-invariant system 
y n
( )  = .
( )
 
x n  + 0 25
 
( 
0 5  
. 
x n − 1), with an initial condition x(−1) = 0 
determine the unit-impulse response h(n). 
SOLUTION 
Let x(n) = δ(n), then 
h n  = y n  = .
( )
 
+ . 
x n − ) = .
( )
 
+ . 
d(n 
( )  ( )
0 5  x n  0 25
 
( 
1 
0 5d n 
0 25 
− 1) 
Thus, for this linear system, we have: 
.
0 5  
0
=
n 

=
h n
( )  
.
0 25 
1
=
n 
0 
elsewhere 
Example 4.4 
Given the difference equation 
y n  = 0 25
 
. 
y n  ) 
( ) for
 
n ≥0 and y(−
=
)
0
( )  
( −
+
 
x n
1
1 
determine the unit-impulse response h(n). 

Difference Equations 
67 
SOLUTION 
Let x(n) = δ(n), then, h(n) = 0.25 h(n – 1) + δ(n) 
To solve for h(n), we evaluate 
h 0 =
. 
h 
) d 0 =
. 
×
+1
1
( )  0 25 (−
+
 
( )
 
0 25
0
 
1 
= 
h =
. 
h 0 + d( )
 
= 0 25
1
 0
0.25
( )1
0 25 ( )
 1 
. 
× +
=
 
h 2 = . 
h 1 + d( )
 
= 0 25
0 5
0
 
. +
=
( )
0 25 ( )
 2 
. 
× 
0.0625 
With the calculated results, we can predict the impulse response as 
h n  = ( .  )n u n  = d( )
 
+ 0
 
25 
. 
d(n − 1
0
 
0625 d(n − 2 + 
( )  0 25
 
( )
 n 
) + .
) 
4.3 THE METHODS THAT ONE MAY USE TO SOLVE 
THE DIFFERENCE EQUATIONS 
There are several different methods that one may use to solve (which means ﬁnding y(n)) the dif-
ferential equations for a general input x(n). These are: 
1. The tabulation method. 
2. The classical approach. 
3. Using z-transforms, which will be discussed later. 
Important note: The Solving of the difference equation, its mean, ﬁnding a form solution for y(n) 
for a given x(n) 
The Tabulation Method 
The ﬁrst is to set up a table of input and output values and evaluate the difference equation 
for each value of n. This approach would be appropriate if only a few output values needed to be 
determined. 
Example 4.5 
Given the linear time-invariant system 
y n  = .
( )
 
x n  + 0 2
. 5 ( − 1), with an initial condition x(−1) = 0 
( )  0 5  
x n  
a. Determine the unit-impulse response h(n). 
b. Write the output using the obtained impulse response. 
SOLUTION 
a. From a previous example: 
.
0 5  
0
=
n 

=
h n
( )  
.
0 25 
1
=
n 
0 
elsewhere 
b. Using the convolution of the equation, y(n) can be rewritten as: 
y n  = h( ) ( )  + h 1 x n − ) 
( )  
0 x n
 ( ) ( 
1 
From this result, it is noted that if the difference equation without the past output terms, y(n − 1),…, 
y(n − N), that is, the corresponding coefficients b1,…, bN, are zeros, the impulse response h(n) has 
a finite number of terms. We call this a finite impulse response (FIR) system. 

68 
Digital Signal Processing 
Example 4.6 
Given the difference equation 
y n  = 0 25 
. 
y n  ) 
( ) for n ≥0 and y(−
=
)
0 
( )  
( −
+ x n
1 
1 
a. Determine the unit-impulse response h(n). 
b. Write the output using the obtained impulse response. 
c. For a step input x(n) = u(n), verify and compare the output responses for the first three 
output samples using the difference equation and digital convolution sum. 
SOLUTION 
a. From a previous example, the predicted impulse response is: 
h n  = ( .  
n u n  = d( ) + . 
d(n − ) + . 
d(n − )
( )  0 25 )
( ) 
n 
0 25 
1
0 0625 
2 +  
b. The output sequence is a sum of infinite terms expressed as 
y n
( )  = h 0 x n + h( ) ( 
1) h
x n 2 
( ) ( )  
1 x n −
+
2
)
( ) ( −
+ 
( )
0 25 ( 
1 
2
( −
+
= x n  + . 
x n −
+
) 0 06 
. 
25 x n
2)

c. From the difference equation and using the zero initial condition, we have 
y n  = 0 25 
. 
y n  ) 
( ) for n ≥0 and y(−
=
)
0 
( )  
( −
+ x n
1 
1 
n = 
y 
= 0 25 
. y −
+ x( )
0 =
( )  = 1
0
0
, ( ) 
(
)1 
u 0 
1
1
, ( ) 
. y( )  
1
0 25 ( ) 
1 = 1 25
n = y 
= 0 25 0  + x( )  = . 
u 0 + u( ) 
. 
n = 
y 
= 0 25 1
y( )  + x 2 = 0 25 
. 
´ 1 25 + ( )2 = .
2
2
.
( )  
. 
u
, (  ) 
1 3125 
… 
Applying the convolution sum yields: 
( )  ( )  0 25 x n −
+
 
(
2 
−
+
y n  = x n  + . 
( 
1) 0 0625 
. 
x n  
) 
n =
, ( )
y 
= x 0 + 0 25 
. 
x(
)
 . 
x(
)
−
+ 
−
+
2 
0
0
 ( ) 
1
0 0625 
= u( )
0 + 0 25 
. 
u(−
+
)
. 
5 u −
+ = 1
1
0 062 
2
(
)
1
1
( ) 
0
. 
−
+
n = , ( ) 
y 
= x 1
0 25
+ . 
x( )  + 0 0625 x( 1)  
1
0 25 ( ) 
. 
u
= u( )  + . 
u 0 + 0 0625 (
)
−
+
1  = 1.25 
n = 
y 
= x( ) 
2
0 25
+ . 
x( )  + . 
x 0
2
2
 
1
0 0625 ( ) +
, ( ) 
 
= u 
+ . 
u 1
0
 
0625 
. 
(0) +
( )  
( ) + 
u 
 =
2
0
 
25 
1.3125 
Notice that this impulse response h(n) contains an inﬁnite number of terms in its duration due to the 
past output term y(n − 1). Such a system, as described in the preceding example, is called an inﬁnite 
impulse response (IIR) system. Note that we cannot have a closed-form expression for y(n). Up to now, 
this is a problem. But using the classical approach, a closed-form expression for y(n) can be obtained. 
4.4 THE CLASSICAL APPROACH 
In the classical approach you must ﬁnd the homogeneous and particular solutions. So for a given 
difference equation, the general solution is a sum of two parts, 

69 
Difference Equations 
y n
( )  = y n
h( )  + y
n
(4.5) 
p( )
where yh(n) is known as the homogeneous solution, and yp(n) is the particular solution. The homoge-
neous solution is the response of the system to input x(n) = 0. The particular solution is the response 
of the system to input x(n), assuming zero initial conditions. 
The homogeneous solution is found by solving the homogeneous difference equation: 
N 
y n
( )  +∑b y n
j
 
) = 0 
(4.6) 
j ( − 
j=1 
The solution to the above equation is found by assuming a solution of the form: 
y n
( )  = zn 
(4.7) 
h 
Substituting this solution, we obtain the polynomial equation: 
N 
n 
n
j
−
z +∑bj z 
= 0 
(4.8) 
j=1 
The polynomial in braces is called the characteristic polynomial. 
For p roots zj, the general solution to the homogeneous differential equation is: 
p 
hy n
( )  =∑
=
j 1 
A z
j 
n 
j 
(4.9) 
where the constants Aj are chosen to satisfy the initial conditions. 
For a particular solution, it is necessary to ﬁnd the sequence yp(n) that satisﬁes the differential 
equation for the given x(n). However, for many of the standard inputs that we are interested in, the 
solution will have the same form as the input. 
Table 4.1 lists the particular solution for some commonly encountered inputs. For example, if 
x(n) = an u(n), the particular solution will be of the form: 
y
n
( )  = C an 
(4.10) 
p 
provided a is not a root of the characteristic equation. The constant C is found by substituting the 
solution into the differential equation. Note that for x(n) = an δ(n), the particular solution is zero. 
Because x(n) = 0, for n > 0, the unit sample only affects the initial condition of y(n). 
TABLE 4.1 
Particular Solution Functions 
x(n) 
Particular Solution 
C u(n) 
C1 
C n 
C1n + C2 
n
n
C a
C1 a 
C cos(nωo) 
C1 cos(nωo) + C2 sin(nωo) 
C sin(nωo) 
C1 cos(nωo) + C2 sin(nωo) 
C an cos(nωo) 
C1an cos(nωo) + C2an sin(nωo) 
C δ (n) 
None (zero) 

70 
Digital Signal Processing 
Example 4.7 
Find the solution to the difference equation: 
y n  − .
(
y n − 2 = 2 ( ) 
( )
0 5  
) 
x n
for x(n) = u(n) assuming initial conditions of y(−1) = 2 and y(−2) = 0. 
SOLUTION 
We begin by finding the particular solution. From the Table 4.1, we see that for x(n) = u(n): 
y n  C 
p( )  = 
1
Substituting this solution into the differential equation, we find 
2 
C1 − 0 5  C1 = 2 ⇒ C1 =
⇒ C1 = 4
. 
1 0 5 
− . 
n
To find the homogeneous solution, we set yh(n) = z , which gives the characteristic polynomial: 
z2 − 0 5  = 0 ⇒ (z − .
 )(
 
z + .
) = 0
. 
0 707 
0 707 
Therefore, the homogeneous solution has the form: 
y n  = A ( . 
)n + A (−0 707 )n 
h( )  
1 0 707 
2
. 
Thus, the total solution is: 
y n  =
+ A1( . 
)n + A2(−.
)n
n 
( )  4
 0 707 
0 707 
≥0 
The constants A1 and A2 must now be found so that the total solution satisﬁes the given initial 
conditions, y(−1) = 1 and y(−2) = 0. Because the total solution given above only applies for n ≥ 0, we 
must derive an equivalent set of initial conditions for y(0) and y(1). Evaluating the equation given in 
the example at n = 0 and n = 1. We have: 
At n = 0 
.
(
 = x 0
y( )
0 − 0 5
 
y −2)
 ( ) = 1
y( )
0 −. *  = x 0 =
→y 0
0 5 0  ( )
1 
( )  = 1 
n = 1 
y( )1
0 5
 
− 
y − ) = x 1
.
( 1 
( ) = 1 
y( )  −. *  = x 1
1 
y 1 = .
1
0 5 1  ( )  =
→( )  1 5 
Substituting these derived initial conditions into the total solution, we have: 
y n
( )  =
+ A1(0
 
707 
. 
)n + A ( 
n
4
2 −0 707 
. 
) 
y( )
4 A1 + A2 = 1 →A1
2
0 =
+
 
+ A = −3 
y( )
4 
. 
A1 − . 
A2 = . →A1 + A2 = −2 5
1 =
+ 0 707 
0 707 
1 5  
. 
Solving for A1 and A2 we ﬁnd: 
A1 = −3 268
. 
A2 = 0.268 

71 
Difference Equations 
Thus, the solution is: 
y n  =
−. 
( . 
)n + .
(−.
)n
n
( )  4
3 268 0 707 
0 268 0 707 
≥0 
Example 4.8 
Use MATLAB to solve the following discrete-time system difference equation 
y n  ) 
−y n  + 3 ( 
)
1 5x n  + 4x n −)
( +
=
1 
2 ( )  y n  1 
.
( ) 
(
−
+
 
1 
compute the value of y at n = 5, when the input sequence is x(n) = [1 −2 3 −4], and the initial 
conditions are Y(1) = 1, y(2) = 1. 
x=[1 −2 3 −4]; 
y(1)=1; 
y(2)=1; 
for n=2:4 
y(n+1)=−2*y(n)+3*y(n−1)+1.5*x(n)+4*x(n−1); 
end 
y(5) 
Ans 21 
Example 4.9 
Write a MATLAB program to simulate the following difference equation: 
8 [ ]− 5y n − ] − y n − 2 = x n + x n − 1]
y n  
[ 
1
2 [ 
] 
[ ]
3 [ 
for an input, x[n] = 2n u[n] and the initial conditions: y[−1] = 0 and y[0] = 1. 
Find values of x[n], the input signal, and y[n], the output signal and plot these signals over the 
range, −1 = n = 10. 
n = 1:10; 
a = [8 −5 −2]; 
b = [1 3]; 
yi = [1 0]; 
xi = 1; 
zi = filtic(b,a,yi,xi); 
y = filter(b,a,2.^n,zi) 
Ans: 
Y(n) = [1.2500 2.2813 4.2383 8.2192 16.1966 32.1777 64.1602 128.1445 256.1304 
512.1 76] 
Example 4.10 
Using MATLAB, draw the output response for the difference equation given by 
( )
0 1
( 
1 
y k
y k  = . *  y k − ) + .72 * ( − 2) + 5 
SOLUTION 
clc; 
clear all; 
n=[1:25]; 
y(1) = 1; 

72 
Digital Signal Processing 
y(2) = 2; 
for k=3:25; 
y(k)=0.1*y(k−1)+.72*y(k−2)+5; 
end 
stem(n,y,'o') 
xlabel('time ---->'); 
ylabel('amplitude---->'); 
Figure 4.1 shows an output result after running the MATLAB program for Example 4.10. 
PROBLEMS 
4.1 Given the following difference equation 
y n  = . 
y n − 2) + ( − ) − . 
x n
( )  0 25
 
( 
x n  1
0 25 ( − 2) 
identify the nonzero system coefﬁcients. 
4.2 Given the following difference equation 
y n  = .
(y n − ) + .
( −1)
( )
0 5  
1
0 2
 
x n  
identify the nonzero system coefﬁcients. 
4.3 Given a linear system described by the difference equation: 
y n
( )  = x n
( )  + .
(
 1) x n −
+
) 0 75
 
( −3)
0 5  x n −
+ (
2 
. 
x n  
determine the nonzero system coefﬁcients. 
4.4 Given the linear time-invariant system 
y n  = . 
x n  + . 
x n
( 
)
. 
x n −2), with an initial condition = 0 
( )  0 75
 
( )
 0 25 
−
+
1
0 85 ( 
determine the unit-impulse response h(n). 
4.5 Given the difference equation 
y n  = 0 25
 
. 
y n  ) 0 25
 
. 
( )  for
 
n ≥0 and y 1
( )  
( −
+
 
x n  
(
)
0
1 
−
=
determine the unit-impulse response h(n). 
4.6 Given the difference equation 
y n  = . 
y n − ) + .
( − ) for
 
n ≥ 0 and y(
)1 = 0
( )  0 25
 
( 
1 
0 25
 
x n  1 
− 
determine the unit-impulse response h(n). 
0 
5 
10 
15 
20 
25 
30 
amplitude 
0 
5 
10 
15 
20 
25 
n 
FIGURE 4.1 Output result from the program of Example 4.10. 

Difference Equations 
73 
4.7 Given the linear time-invariant system 
y n  = .
( )
 
x n  + 0 75
 
. 
( − 2), With an initial condition x(−1) = 0 
( )  0 5  
x n  
a. Determine the unit-impulse response h(n). 
b. Write the output using the obtained impulse response. 
4.8 Given the difference equation 
y n  = 0 25
 
. 
y n  ) 0 75
 
. 
( )  for
 
n ≥0 and y 1
( )  
( −
+
 
x n  
(
)
1
1 
−
=
a. Determine the unit-impulse response h(n). 
b. Write the output using the obtained impulse response. 
c. Input x(n) = u(n), verify and compare the output responses for the ﬁrst three output 
samples using the difference equation and digital convolution sum. 
4.9 Given the difference equation 
y n  = y n  )
.
 ( )
 
+ . 
x n −) for
 
n ≥0 and y(
)
( )  ( −
+
 
x n  0 75
 
(
1 
1
1
0 75 
−
= 1
a. Determine the unit-impulse response h(n). 
b. Write the output using the obtained impulse response. 
c. Input x(n) = u(n), verify and compare the output responses for the ﬁrst three output 
samples using the difference equation and digital convolution sum. 
4.10 Find the solution to the difference equation: 
y n  − .
(y n − 2) = ( ) 
( )  0 5  
x n
for x(n) = u(n) assuming initial conditions of y(−1) = 2 and y(−2) = 0. 
4.11 Find the solution to the difference equation 
( )  0 75
 
( 
= a x n 
y n  − . 
y n − 2)
 ( ) 
for x(n) = u(n) assuming initial conditions of y(−1) = 2 and y(−2) = 0. 
And a is a positive and constant number. 
4.12 Find H(z) for the following difference equations: 
(a) 
y n
[ ]  = [ ]
 
−3x n −
+ 2 [
x n  
[ 
1] 
x n −2]
(b) 
y n
[ ]  = [ − ] − y n − ] − .
[
 − 2]
x n  1
2 [ 
1
0 5
 
y n  
4.13 Use MATLAB to recursively determine and plot the system output y[n] for 0 < = n < = 30 
if the system is described by the difference equation 
y n  = 0 1y n − ] + .
[ − 2] + 5x n
[ ]  .
[
 1
0 72 y n  
[ ]. 
The initial conditions are y[−1] = 1 and y[−2] = −1, and the input is x[n] = d[n] (i.e., the 
unit-impulse). Present the stem plot with labeled horizontal and vertical axes (i.e., n and y[n] 
respectively). Based on the stem plot, what can you conclude concerning the stability of the 
system? 


5 Discrete-Time Fourier 
Series (DTFS) 
The representation of periodic signals becomes the discrete-time Fourier series (DTFS), and for 
aperiodic signals, it becomes the discrete-time Fourier transform(DTFT). The motivation for rep-
resenting discrete-time signals as a linear combination of complex exponentials is identical in both 
continuous-time and discrete-time. The complex exponentials are eigenfunctions of linear, time-
invariant systems, and consequently, the effect of an LTI system on each of these basic signals is 
simply the amplitude change. An LTI system is completely considered by a spectrum applies at each 
frequency. In representing discrete-time periodic signals through the Fourier series, use harmoni-
cally related complex exponentials with fundamental frequencies. In this chapter will discuss the 
discrete-time Fourier transform and its application in digital signal processing. 
5.1 DTFS COEFFICIENTS OF PERIODIC DISCRETE SIGNALS 
The discrete-time signal x(n) is periodic if for a positive value of N, 
x n
( )  = x n  + N)
( 
(5.1) 
Let us look at a process in which we want to estimate the spectrum of a periodic digital signal x(n), 
sampled at a rate of fs Hz with the fundamental period T0 = NT, as shown in Figure 5.1, where there 
are N samples within the duration of the fundamental period, and T = 1/ fs is the sampling period. 
According to Fourier series analysis, the coefficients of the Fourier series expansion of a continu-
ous periodic signal x(t) in a complex form is given by: 
ck = T 
1
0 ∫x t  e
 
−jkw0tdt −∞< k
( )  
< ∞
(5.2) 
T0 
where k is the number of harmonics corresponding to the harmonic frequency of kf0, and w0 = 2p / T0 
and f0 = 1/ T0  are the fundamental frequency in radians per second and in Hz, respectively. To apply 
this to Equation (5.2), we substitute T0 = NT with w0 = 2p / T0  and approximate the integration over 
one period using a summation by replacing dt = T and t = nT. We obtain: 
1 
N −1 
−j 2pkn 
ck = 
x n e 
N 
−∞< k < ∞
(5.3) 
∑( )
N n=0 
and, the discrete signal x(n) can be given as: 
N −1
2pkn 
x n  ∑c e
j 
−∞<  
(5.4) 
( )  = 
k
N 
n < ∞
k=0 
where Ω0 = 2p . 
N 
The value of k varies over any range of N successive integers, and for convenience we indicate 
this by expressing the limits of the summation as k = N . For example, k could take on the values 
k = 0, 1, 2, …, N–1 or k = 3, 4, …, N + 2. The two Equations (5.3) and (5.4) could be written in a 
more general form: 
75 

76 
Digital Signal Processing 
x(N)=x(0) 
n 
N 
To=NT 
x(n) 
0 
x(0) 
FIGURE 5.1 Periodic discrete signals. 
- j 
ck = 1 åx n e 
2p 
N
kn 
- ¥ < k < ¥  (Analysis equation) 
(5.5)
( )
N n
N
= 
2pkn 
x n  = ∑c e
j N 
−∞< n < ∞ (Synthesis equation)
( )  
k 
(5.6) 
k
N
= 
Note: For symmetric x(n), it’s convenient to use the following: 
• For N odd, we choose (k and n) = –(N–1)/2 to (N–1)/2. 
• For N even, we choose (k and n) = –N/2 to N/2–1. 
Since the coefficients ck are obtained from the Fourier series expansion in complex form, the resul-
tant spectrum ck will have two sides. There is an essential feature of Equation (5.5) in which the 
Fourier series coefficient ck is periodic of N. We can verify this as follows: 
N −1
2p(k N n
+ ) 
N −1
2pkn 
+ 
1 
− j
N 
1 
( )  
− j
N 
− j2pn
ck N  = N ∑x n e
( )  
= N ∑x n e 
e
1 
(5.7) 
= 
n=0 
n=0�
 
�
 
ck 
Since e− j2pn = cos(2np) − jsin(2np 
1, it follows that c +
= ck
) = 
k N  
Therefore, the two-sided line amplitude spectrum ck  is periodic, as shown in Figure 5.2. We 
note the following points: 
a. As displayed in Figure 5.2, only the line spectral portion between frequency −fs/2 and fre-
quency fs/2 (folding frequency) represents the frequency information of the periodic signal. 
b. Note that the spectral portion from fs/2 to fs is a copy of the spectrum in the negative fre-
quency range of −fs/2 to 0 Hz due to the spectrum being periodic for every N f0 Hz. Again, 
the amplitude spectral components indexed from fs/2 to fs can be folded at the folding 
frequency fs/2 to match the magnitude of the spectral components indexed from 0 to fs/2 in 
terms of fs − f Hz, where f is in the range of fs/2 to fs. 
Sometimes, we compute the spectrum over the range of 0 to fs Hz with non-negative indi-
ces, that is, 
N
ck = N 
1 ∑n
N 
=
− 
0
1 
x n e
( )  
− j 2pkn 
(5.8) 
k = 0 1 2,
,
 
N
, ,  … 
−1 

                    
                
                        
                 
     
77 
Discrete-Time Fourier Series (DTFS) 
DC component at k fo=0xfo=0 Hz 
f 
|Ck| 
-fs/2 
-fo 
fo 
fs/2 
fs-fo 
fs fs+fo 
fs=Nfo 
1st harmonic at k fo=1xfo=fo Hz 
FIGURE 5.2 Periodic discrete signals show the harmonics. 
We can apply the same equation to find the negative indexed spectral values if they are 
required. 
c. For the kth harmonic, the frequency is: 
f = kf0 
Hz 
(5.9) 
where f0, in Hz, is the frequency resolution, which is the frequency of the spacing between 
the consecutive spectral lines. 
5.2 PARSEVAL’S RELATION 
For discrete periodic signals, Parseval’s relation relates the energy Eg in one period of the sequence 
to the energy in one period of the Fourier series coefficients as: 
2 
2
Eg = 
x n
( )  = ∑ ck 
(5.10) 
N 
1 ∑ 
n
N
= 
k
N
= 
Before presenting several examples illustrating the DTFS, be reminded that the starting values of 
the indices n and k in the synthesis and analysis equations are arbitrary because both x(n) and ck are 
N periodic. The range for the indices may thus be chosen to simplify the solution at hand. 
Example 5.1 
The periodic signal: 
x t( )  = sin(2pt) 
is sampled using the rate fs = 4 Hz. 
a. Compute the spectrum ck using the samples in one period. 
b. Plot the two-sided amplitude spectrum ck  over the range of –2 to 2 Hz. 
SOLUTION 
a. From the analog signal, we can determine the fundamental frequency w0 = 2p  radians 
per second and f0 = w0 = 2p = 1Hz, and the fundamental period T0 = 1 second. Since 
2p 
2p 
1
we used the sampling interval T =
= .
0 25 second, we get the sampled signal as: 
fs 
x t  = x nT 
sin(2 nT 
sin(0.5
( )  
( 
) = 
p 
) = 
pn) 
and plot the first eight samples, as shown in Figure 5.3. 

    
     
      
       
        
     
          
      
       
      
78 
Digital Signal Processing 
n 
x(n) 
x(0) 
x(1) 
1 
N=4 
FIGURE 5.3 Input signal x(n). 
Choosing the duration of one period, N = 4, we get the sample values as follows: 
x( )  = 0 x 
= ; x( )  = 0 x 3 = −1
0 
; ( ) 
1
1
 2 
; ( ) 
Using the equation of ck, 
3 
c0 = 1 
x( )
n = 1 x 0 + x( )1 + x 2 + x( )  = 1 0
1
 
)
4 ∑
4 ( ( )  
( )
3 )
4 ( + +
−
0
1
 = 0 
n=0 
1
3 
−j 2 1n 
1 ( )  ( )  −jp /2 
( )  −jp 
3 e−j3p /2
c1 = ∑x n e  
p 
4 =
(x 0 + x 1 e 
+ x 2 e 
+ x 
)
( )  
( )
4
4 
n=0 
−
+
−
= −
1 
j . .
= 1 (x( )
0 −jx( )1 −x( )2 + jx( )3 ) =
−
0 
j( )1 0 
j(
)
 
0 5  
4 
Similarly, we get: 
1
3 
− j 2 2n 
1
3 
− j p n
p 
2 3  
c2 = 
x n e  
4 = 0 and c3 = 
x n e  
= j .
∑ ( )  
∑ ( )  
4
0 5
4
4 
n=0 
n=0 
Using periodicity ck = ck+N, it follows that: 
c−1 = c3 = j0 5
. 
and c−2 = c2 = 0 
b. The amplitude spectrum ck  for the digital signal is sketched in Figure 5.4. 
As we know, the spectrum in the range of –2 to 2 Hz presents the information of the 
sinusoid with a frequency of 1 Hz and a peak value of 2 
= 1, which is converted from 
two sides to one side by doubling the spectral value. Note that we do not double the 
direct-current (DC) component, that is, c0. 
ck 
|Ck| 
1st harmonic 
f
-5 
-4 
-3 
-2 
-1 
0 
1 
2 
3 
4 
5 
fs/2=2 
FIGURE 5.4 The amplitude spectrum 
.
ck 

Discrete-Time Fourier Series (DTFS) 
79 
5.3 DISCREET FOURIER SERIES 
For a signal x[n] of finite-length, the DFT is DFS of the periodic extension, x~[n], of that signal x[n] 
and another way to view DFT is that it’s a sampling of continuous DTFT. 
Given that it is possible to reconstruct the original signal from the sampled signal provided, 
the sampling is more significant than the Nyquist frequency. We know that the DTFT for the 
sampled signal is a series of replications of the spectrum of the original signal at frequencies 
spaced by the sampling frequency. Now, since DTFT is continuous and periodic, we can fur-
ther breakdown the DTFT into intervals and it will still be possible to reconstruct the DTFT 
and consequently the original signal. This act of breaking down or sampling the DTFT is 
called DFT. 
Example 5.2 
Determine the spectra (DFS) of the signals below: 
a. x[n] = cos 3pn 
b. x[n] = 1, 1, 0, 0 
SOLUTION 
a. The signal is not periodic, and therefore cannot expand into the Fourier series. 
N−1 
jk2pn 
b. X k  = 
x n e 
N
[ ]
1 ∑( )  
− 
N n=0 
We know that DFS is expressed as 
N−1 
jk2pn 
X k  = 
x n e
[ ]
1 ∑( )  
− 
N 
N n=0 
Here N = 4, therefore, we have 
3 
jk n 
X k  = 
x n e
[ ]
1 ∑( )  
− 2 
p 
4 n=0 
[ ]
1 ∑
3 
( )  
−jk n
p 
X 0 = 
x n e  
2 
4 n=0 
So, when 
3 
k =
⇒X 0 =∑( )  e0
0 
( )  
x n  
n=0 
x 0 + x 1 + x 2 + x( )
= ( )
( )
( )  
3 
= + +
+
=
0
0
 2
1 1  
when 
3 
p 
2
k =
⇒X 1 =∑( )  e
1 
( )  
x n  
−j n/ 
n=0 
= x 0 + x 1e−jp /2 + x 2 e−jp + x 
−j3p /
( )  
( )
3 e 
3
2
( )  
( )  
1
1e−jp /2 + 0 e−jp + ( )  −j3p /2 
1
= + ( )  
( )
0 e 
= −j 

 

 
   

80 
Digital Signal Processing 
when 
3 
k =
⇒X 2 =∑( )  e−j n
2 
( )  
x n  
p 
n=0 
= x 0 + x 1e−jp + x 2 e−j2p + x( )  −j3p
( )
( )  
( )  
3 e 
= 1+ ( )  −jp + 0 e−j2p + ( )e−j3p = 0
1
1e 
( )  
0 
when 
3 
k =
⇒X 3 =∑( )  e−j3pn/2
3 
( )  
x n  
n=0 
= ( )  ( )  j3
2
p / 
( )  −j3p 
3 −j p /
x 0 + x 1e−
+ x 2 e 
+ x( )e 
9
2
= + ( )  −j3
2
( )  −j p 
( )  −j9p /2 
1
1
1e 
p / + 0 e 
3 + 0 e 
= + j 
So, X k  = [ ,  − j 0 1+ j]
( )  2 1
, ,  
Example 5.3 
For the periodic signal: 




↑ 

 
……
x n
( ) = 
, , , , , ,  , , , , , ,
2 1 0 1 2 32 1 0 1 2 …… . 
a. Compute the spectrum ck using the samples from one period. 
b. Calculate the energy of the signal using both sides of Parseval’s relation. 
SOLUTION 
1 
− j 2p 
N
kn 
a. ck = 
x n e
∑ ( )
N n
N
= 
2
2pkn 
ck = 1 ∑x n e  
−j 
−3 ≤
≤
( )  
N
k 
2 
6 n=−3 
1  
j 6pk
j 4pk
j 2pk 
−j 2pk 
−j 4pk  
ck =
x −3 e 
6 
x 
2 e 
6 
x 
1 e 
6 + x 0 +
1
6 + x ( ) e 
6 
+
−
 
+
−
(
)
 
( )  x
e
(
)
(
)
 
( )  
2 
6  
 

6pk 
4pk 
2pk 
2pk 
4pk 
1
−j
−j
j 
j 
j
6 +1e 
6 + 2 e 
6 
6 
6
0 e
+ 3+ 2 e
+1e

 

 
=
k 
6 
c 
1 
j 4pk
j 2pk 
−j 2pk 
−j 4pk  
ck =
e 
6 + 2 e 
6 +
+ 2 e 
6 + e 
6 
3 
6  
 
Re-arrange the exponential terms: 

 




3+




4pk 
4pk 
2pk 
2pk
1
−
−
j 
j 
j 
j
6 
6 
6 
6
2 
2
+
+
e
=
c 
e
+
e 
e
k 
6 
2cos 2pk 
4cos pk
3
3 

81 
Discrete-Time Fourier Series (DTFS) 
c = 1 

+
cos 2pk + 4cos pk  
3 k
k 
3
2
 
 
−
≤
 ≤2 
6 
3
3 
9
4 
1 
c0 = 
, c1 = c−1 = 
, c2 = c−2 = 0, c−3 = 
6
6 
6 
2 
2
1 
2
1
2
2 
2 
2 
2
2
19
b. Eg = 1 ∑ x n
( )  = ∑ x n
( )  =
(0 + 1 + 2 + 3 + 2 + 1 ) = 
N 
6 
6
6 
n
N
= 
n=−3 
2 
2 
2 
1
2
2 
4
2 
9
2 
⎛ 4
2
2  
114
Eg = ∑ck 
= ∑ck 
= 
0
0 
=
6+ ( ) + 6 + 6+ 6+ ( )  
36 
k
N
= 
k=−3 
 
 
19 
114
∴ Eg =
= 
6 
36 
Example 5.4 
For the periodic signal: 
x n
( )  = cos 
 
p 
8 n + f
 
a. Compute the spectrum ck using the samples from one period. 
b. Plot the two-sided amplitude spectrum 
.
ck 
SOLUTION 
a. The fundamental period of x(t
= 2
16.
) is N =16. Hence, Ω0 
p / 
e
j(p /8)n+f + e 
− j(p /8)n+f 
x n  =
( )  
2 
( )  1 − jf 
− j(p /8)n 
1 
jf 
j(p /8)n 
x n  = 
e
e 
+ 
e
e
 
2
2 
Compare x(n) with: 
x n
( )  = ∑ 
7 
c
e
j p 
8 
kn 
k 
k=−8 
and by inspection, we get: 
1 −jf 
2 e
k = −1 
1 jf
ck =  e
k = 1
.
2 
0 
−≤k ≤7 
and k
 
8 
≠±1 
 
b. The amplitude spectrum ck  for the signal is sketched in Figure 5.5. 
Example 5.5 
Find the DFS coefficients of the periodic sequence with a period of x(n). Plot the magnitudes and 
phases of the sequence of x(n), within one period, has the form of (Figure 5.6): 

82 
Digital Signal Processing 
|Ck| 
0.5 
–20 
–10 
10 
20 
k 
FIGURE 5.5 The amplitude spectrum 
.
ck 
magnitude responce
4 
0 
2
amplitude 
–5 
2 
0 
k 
phase responce 
5 
10 
–5 
0 
k 
5 
10 
–2 
0
amplitude 
FIGURE 5.6 The magnitude and phase spectrum of Example 5.5. 
1 
n 
0 
n 


 
, ,
0 1 2
= 
x n
( ) = 
3,4
= 




+

 
j2pk 
5 
1 2  
 
ALGORITHM 5.1 
N=5; 
x=[1 1 1 0 0]; 
k=-N:2*N; 
%plot for 3 periods 
Xm=abs(1+2.*cos(2*pi.*k/N)); 
figure; 
subplot(2,1,1); 
stem(k,Xm,'o') 
xlabel('k'); 
ylabel('amplitude'); 
title('magnitude response'); 
%magnitude computation 
subplot(2,1,2); 
Xa=angle(exp(-2*j*pi.*k/5).*(1+2.*cos(2*pi.*k/N))); 
%phase computation 

2pk
−
Using DFS X k( ) = e 
cos 

5 

Discrete-Time Fourier Series (DTFS) 
83 
stem(k,Xa,'o') 
xlabel('k'); 
ylabel('amplitude'); 
title('phase response'); 
PROBLEMS 
5.1 The periodic signal: 
x t( )  = sin(2pt)
is sampled using the rate fs = 8 Hz. 
a. Compute the spectrum ck using the samples from one period. 
b. Plot the two-sided amplitude spectrum ck  over the range of –4 to 4 Hz. 
5.2 The periodic signal: 
x t  = cos pt
( )  
( )
is sampled using the rate fs = 4 Hz. 
a. Compute the spectrum ck using the samples from one period. 
b. Plot the two-sided amplitude spectrum ck  over the range of –2 to 2 Hz. 
5.3 The periodic signal 
x t  = cos pt
( )  
( )
is sampled using the rate fs = 6 Hz. 
a. Compute the spectrum ck using the samples from one period. 
b. Plot the two-sided amplitude spectrum ck  over the range of –3 to 3 Hz. 
5.4 For the periodic signal 


x n
( ) = 


↑ 

 
……, ,2 3 4 3 2 1 2 3 4 3 2 
, ,  , , , ,  , ,  , ,…… 
a. Compute the spectrum ck using the samples from one period. 
b. Calculate the energy of the signal using both sides of Parseval’s relation. 
5.5 For the periodic signal 


x n
( ) = ……, ,1 2 3 3 2 1 1 2 3 3 2 
, , ,  , , ,  , , ,  , 
 

↑ 
 
 
…… 
a. Compute the spectrum ck using the samples from one period. 
b. Calculate the energy of the signal using both sides of Parseval’s relation. 
5.6 For the periodic signal 
x n
( )  = cos 
 16 
p n + f
 
a. Compute the spectrum ck using the samples from one period. 
b. Plot the two-sided amplitude spectrum 
.
ck 
5.7 For the periodic signal 
x n
( )  = sin 
 
p 
4 n + f
 

84 
Digital Signal Processing 
a. Compute the spectrum ck using the samples from one period. 
b. Plot the two-sided amplitude spectrum 
.
ck 
5.8 For the periodic signal 
x n
( )  = sin  p n + f 
 8 
 
c. Compute the spectrum ck using the samples from one period. 
d. Plot the two-sided amplitude spectrum 
.
ck 
5.9 For the periodic signal 
x n
( )  = sin 
 16 
p n + f
 
a. Compute the spectrum ck using the samples from one period. 
b. Plot the two-sided amplitude spectrum 
.
ck 
5.10 Determine the DTFS coefficients ck by inspection for the discrete signal: 
1
3p  
x n  = + sin  
pn 

( )  1 
+
12 
8 
pn
pn
5.11 The periodic digital signal is given by x n
( )  = +
1 sin  
+ 2 cos

8 
4  
Find its Fourier series coefficients, and sketch their real and imaginary parts. 
pn
pn
5.12 The periodic digital signal is given by x n
( )  = +
1
2
 
sin  
+ 3 cos 

4 
8  
Find its Fourier series coefficients, and sketch their real and imaginary parts. 

6 Discrete-Time Fourier 
Transform (DTFT) 
The Fourier representation of signals plays an essential part in both continuous and discrete-time 
signal processing. It delivers a method for mapping signals into another domain in which to oper-
ate them. The Fourier representation mainly useful is the property that the convolution operation 
mapped to multiplication. Also, the Fourier transform provides a different method to understand 
the systems and signals. 
Discrete-Time Fourier Transform (DTFT) is used to analyze the frequency spectrum of a discrete 
signal with a computer because computers can only handle a finite number of values. This chapter 
presents analysis a frequency response for a signal using MATLAB, and the Inverse Discrete-Time 
Fourier Transform(IDTFT), also chapter will submit the Applications of DTFT and analysis of LSI 
Systems and Solving Difference Equations using DTFT. 
6.1 FREQUENCY RESPONSE 
Eigen functions of linear shift-invariant systems are sequences that, when input to the system, pass 
through with only a change in (complex) amplitude. If the input is x(n), the output is y(n) = λ x(n), 
where λ, the eigenvalue, generally depends on the input x(n). 
Signals of the form 
x n  e jnw −∞<  
(6.1) 
( )  = 
n < ∞
where ω is a constant, are Eigen functions of LSI systems. Which is shown in the convolution sum: 
∞ 
( )  ( )* ( ) ∑
y n  = h n  x n  = 
h k x n  
( ) (  −k) 
(6.2) 
k=−∞ 
∞
∞ 
w( −) 
jnw 
−jkw
=∑h k e
 
( )  
j
n k = e ∑h k e 
( )  
k=−∞ 
k=−∞ 
jw 
jnw
= H e(
)e 
(6.3) 
w
Thus, the eigenvalue, which we denote as H e( 
j ), is 
∞ 
H e jw = 
h k e − jkw 
(6.4) 
( 
) ∑ ( )  
k=−∞ 
w
The function H e( 
j ) is called the frequency response of the systems. 
w
Note that, H e j ) is, in general, a complex valued quantity. Thus, it is written in terms of its real
( 
-
and imaginary parts. 
jw 
jw 
jw
H e  = H
e
 )+ j HI e 
(6.5) 
(
) 
R( 
(
)
85 

86 
Digital Signal Processing 
or in terms of its magnitude and phase, 
jw 
jw 
f
w
H e( 
) = H e  ) e j h (
)
(6.6) 
( 
and 
jw
H
e
 )
− 
I (
f w
( )  = tan 1 
H
e
 ) 
(6.7) 
h
jw 
R( 
A graphical representation that is often used instead of the phase is the group delay, which is defined 
as follows: 
f w
t w
( )  = −d
h( )
(6.8) 
h 
dw 
In evaluating the group delay, the phase is taken to be a continuous and differentiable function of ω 
by adding integer multiples of π to the principal value of the phase. 
Graphical representations of the frequency response are of great value in the analysis of LSI 
systems, and plots of the magnitude and phase are commonly used. However, another useful graphi-
( 
jw
cal representation is a plot of 20 log H e ) versus ω. The units on the log magnitude scale are 
decibels (abbreviated dB). One of the advantages of a log magnitude plot is that because the loga-
( 
jw 
rithm expands the range for small values of H e ) , it is useful in displaying the fine detail of the 
frequency response near zero. 
Finally, the inverse DTFT is given by: 
p 
jw 
jnw
h n
( )  = 2
1 
p ∫H e  e 
dw 
(6.9) 
(
) 
−p 
Before being given an example, put your mind to the following closed-form expressions for some 
commonly encountered series: 
N −1 
N
∑ 
n 
1− a 
a = 
(6.10) 
1 − a 
n=0 
N −1 
n 
(N −1)aN +1 − NaN + a 
na = 
2 
(6.11) 
∑
(1 − a)
n=0 
N −1 
∑n = 1
2 N N −) 
(6.12) 
( 
1 
n=0 
∞ 
an = 
a < 1
(6.13) 
∑ 
1− 
1 
a 
n=0 
∞ 
∑ 
a 
a < 1
(6.14) 
n=0 
nan =
(1 − a)
2 
N −1 
2
∑n = 1
6 N(N −1 2N −)
)( 
1 
(6.15) 
n=0 

87 
Discrete-Time Fourier Transform (DTFT) 
n 
∑ 
1
1 
−
− 
a
a
n+1 
an = 
(6.16) 
k =0 
Example 6.1 
Consider the LSI system with unit sample response 
h n  = an u n
( )  
( )
where α is a real number with a < 1. The frequency response is 
∞
∞ 
jw 
−jnw 
n 
−jnw
H e  
=∑h n e 
=∑a
(
)
( )  
e 
n=−∞ 
n=0 
∞ 
=∑(ae−jw )
n = 1−a 
1 
e−jw 
n=0 
The squared magnitude of the frequency response is 
2 
H e jw
( 
) 
H e  H
e
j 
j
w 
w
= ( 
) 
( 
)
* 
1 
1 
1 
= 
⋅ 
= 
e 
jw
a
− 
−
1 
e jw
a
−
1 
a 
a 
w
+ 
−
2
1 
2 cos 
and the phase is 
jw
H e  )
I (
−1 −asinw
f w
h( )  = tan−1 
= tan 
H
e jw 
1− acos w
R (
) 
Finally, the group delay is found by differentiating the phase. The result is 
a2 −acos w
t
w = 
2
h ( )
1+a −2a cos w 
Example 6.2 
For a system with a frequency response given by 
w ≤ wc
H e( 
jw ) = 




1
0 
wc < w ≤ p 
(this system is referred to as an ideal low-pass filter), the unit sample response is 
wc 
( )  1 
jnw 
1  
jnwc 
− jnwc 
sinnwc
h n  = 2p ∫ e
dw = 2j n  e 
− e 
 = 
pn
p
−wc 
Note that this system is noncausal (it is also unstable) and, therefore, unrealizable. 
6.2 DTFT FOR ANY DISCRETE SIGNAL 
The frequency response of a linear shift-invariant system is found by multiplying h(n) by a complex 
exponential, e− jnw , and summing over n. The Discrete-Time Fourier transform of a sequence, x(n), 
is defined in the same way, 

88 
Digital Signal Processing 
∞ 
X e jw = 
x n e − jnw
( 
) ∑ ( )  
(6.17) 
n=−∞ 
Thus, the frequency response of a linear shift-invariant system, H e jw  is the DTFT of the unit 
(
)
sample response, h(n). For the DTFT of a sequence to exist, the summation in X e jw must con-
(
)
verge. So, in turn, this requires that x(n) be summable: 
∞ 
∑x n
( )  S 
(6.18) 
=
< ∞ 
n =−∞ 
Example 6.3 
Find the DTFT of the sequence 
x n = −an u
n
 )
( )  
(−−1 
a > 1
SOLUTION 
∞
−1 
X e jw = 
x n e−jnw = − 
an e−jnw
( 
) ∑ 2( )  
∑ 
n=−∞ 
n=−∞ 
Changing the limits on the sum, we have 
∞
∞ 
X e jw = − 
a−n e jnw = − 
a−1 e−jw n +1
(
)
∑
∑( 
)
n=1 
n=0 
If a > 1, this sum is (Table 6.1) 
X e jw =
+ 1
(
) 
1− a 
1 
−1e jw 
X e jw 
1 
for a > 1
( 
) = 1− a e− jw 
6.3 INVERSE DTFT 
jw
Given X e(
), the sequence x(n) is recovered using the inverse DTFT, 
p 
jw 
jnw
x n
( )  = 2
1 
p ∫X e  e 
dw 
(6.19) 
(
) 
−p 
The inverse DTFT is viewed as a decomposition of x(n) into a linear combination of all complex 
exponentials. Table 6.1 contains a list of some useful DTFT pairs. 
Note that in some cases x(n) is not summable. But by allowing the DTFT to contain impulses, we 
may consider the DTFT of sequences that contain complex exponentials. 
Example 6.4 
Find the inverse DTFT of: 
X e jw = d w  w 0 )
(
) 
(
− 

89 
Discrete-Time Fourier Transform (DTFT) 
TABLE 6.1 
DTFT Sequences 
Sequence 
DTFT 
aδ (n) 
a 
a
n
d ( − no) 
ae− jnow 
a
a
( )
2p d  w
ae jnwo
a2p d(w
w
− 
o) 
a u n
a
n ( ), 
< 1
1 
1 − ae− jw 
n
−a u(−n −1), a > 1
1 
1 − ae− jw 
(n + )a u n  
1 
n ( ), a < 1
1 
(1 − ae− jw )
2 
cos nwo
ap d w
w
 ) + ap d w
wo
( + 
o 
( − 
) 
We have 
x n  
X e  e 
d 
e
j 
jn 
jn
( )  = 
( 
) 
= 
− 
1 ∫
2 
1 
2 
0 
p 
w 
p 
p 
p 
w 
w 
w 
Example 6.5 
Find the inverse DTFT of: 
X e jw 
p d  w
 p d w  
( 
) = 
−
( 
) + 
+
( 
)
2 
2 
SOLUTION 
Computing the inverse DTFT, we find 
x n  
e 
e 
n
j n  
j n
( )  = 
+ 
=
−
1 
2 
1 
2 
2
2 
2 
cos( ) 
6.4 INTERCONNECTION OF SYSTEMS 
1. Cascade systems 
A cascade of two linear shift-invariant systems is shown in Figure 6.1. 
h n  h n  h n
( )  
( )*
( ) 
= 1 
2 
and a frequency response 
H e  
H e  H
e
j 
j 
j
w 
w 
w
( 
) = 
( 
) 
( 
)
1 
2 
The log magnitude is the sum of the log magnitudes of the individual systems, 
20 
20 
20
1 
2
log
 log 
log 
H e  
H e  
H
e
j 
j 
j
w 
w 
w
( 
) = 
( 
) + 
( 
) 
(6.20) 
(6.21) 
(6.22) 

90 
Digital Signal Processing 
x(n) 
y(n) 
h1(n) 
h2(n) 
FIGURE 6.1 Cascade systems. 
and the phase and group delay are additive, 
f w
( )  = f w
1( )  
+ f w
(6.23) 
2( )
( )  
+ t w
t w = t w
( )  ( )
(6.24) 
1
2 
2. Parallel systems: A parallel connection between two linear shift-invariant systems. As 
shown in Figure 6.2 
( )  
+ h n
h n  = h n
( )  
( )
(6.25) 
1
2 
The frequency response of the parallel network is 
jw 
jw 
jw
H e  = H e  )+ H
e
 
(6.26) 
(
) 
1 ( 
2 (
) 
3. A feedback network is commonly found in control applications. Figure 6.3 shows a feed-
back network. 
This network may be analyzed as follows. With 
g n  = x n + ( )* ( ) 
y n  
(6.27) 
( )  ( )  b n  
y n  = a n
( )* (  ) 
(6.28) 
( )  
g n
The frequency response of this system, if it exists, is 
Y e jw 
A e jw 
jw 
(
) 
(
)
H e( 
) = 
X e  )
= 
1− A e  
( 
(6.29) 
jw 
jw 
jw
( 
(
)B e  ) 
h1(n) 
x(n) 
y(n) 
h2(n) 
FIGURE 6.2 Parallel systems. 
x(n) 
a(n) 
y(n)
g(n) 
b(n) 
FIGURE 6.3 Feedback network. 

Discrete-Time Fourier Transform (DTFT) 
91 
6.5 DTFT PROPERTIES 
There are several features of the DTFT that may be used to simplify the evaluation of the DTFT and 
its inverse. A summary of the DTFT properties appears in Table 6.2. 
6.6 APPLICATIONS OF DTFT 
In this section, we present some applications of the DTFT in the discrete-time signal analysis. These 
include finding the frequency response of an LSI system that is described by a difference equation, 
performing convolutions, solving difference equations that have zero initial conditions, and design-
ing inverse systems. 
6.7 LSI SYSTEMS AND DIFFERENCE EQUATIONS 
A significant part of LSI systems contains those whose input, x(n), and output, y(n), are related by a 
linear constant-coefficient difference equation. 
Example 6.5 
Consider the linear shift-invariant system characterized by the second-order linear constant-coef-
ficient difference equation: 
y n  = . 
y n  
)
. 
y n
(
) x n  −1
 
4142 
. 
( 
) x n  2
( )  1 3433 ( −
−
 −
+
 
( )  
x n  1
1
0
 
9025 
2 
−
+ ( −) 
The frequency response can be found through inspection without solving the difference equation 
for h(n) as follows: 
− . 
e− jw + e−2 jw 
H e jw = 
1 1  4142 
(
) 
1 1  3433 e− jw + 0 9025 
. 
e−2jw
− . 
TABLE 6.2 
DTFT Properties 
Property 
Sequence 
DTFT 
Linearity 
a x( )
n + a y n  
a X  e jw + a Y e  
jw 
1 
2 ( )
1 (
) 
2 (
) 
a a  X e jw 
jw
Convolution 
a x n
a2 y n
( ) 
(
⋅Y e  )
1 ( )* 
1
2
 
)
( 
−n
− jw
Time-reversal 
a x(
)
a X(e
) 
− jnow 
jw
Shift 
a x n
no) 
ae 
(
( − 
X e  ) 
jnwo
j 
− o
(w w
Modulation 
ae 
( )
a X(e
x n  
) 
* 
− jw
Conjugation 
a x n
a X  (
( )* 
e ) 
( 
jw
dX e )
( )
Derivative 
a n x n
j 
dw 
p 
Multiplication 
a x n a y n
( )
a a  
X e jw ⋅Y e
j( −) d
1 ( )  2 
1
2
1 ∫( 
)
( 
w q ) q
2p
−p 

92 
Digital Signal Processing 
Performing Convolutions 
The DTFT provides another method for performing convolutions in the time domain, because the 
DTFT maps convolution in the time domain into multiplication in the frequency domain, 
Example 6.6 
If the unit sample response of an LSI system is: 
h n = an u n
( )  
( )
Let us find the response of the system to the input x n = bn u n
( )  
( ) where a < 1, b < 1, and a ≠ b. 
Because the output of the system is the convolution of x(n) with h(n) 
y n = h n  x n  
( )  ( )* ( ) 
And the DTFT of y(n) is 
jw 
jw 
jw
Y e( 
) = H e  ) (
= 
− jw ⋅
− jw
( 
X e  ) 
1− a 
1 
e 
1− b 
1 
e 
( 
jw
Therefore, all that is required is to find the inverse DTFT of Y e ). This may be done easily by 
expanding Y e jw  as follows: 
(
)
Y e  ) 
1 
A 
-
+ 
B
jw 
jw
( 
= (1- a e - jw )(1- b e - jw )
= 1- a e
jw 
1- b e -
where A and B are constants that are to be determined. Expressing the right-hand side of this 
expansion over a common denominator, 
1 
(A
B
+ ) -(Ab + a)
- jw
B
e 
(1- a e - jw )(1- b e - jw )
= (1- a e - jw )(1- b e - jw ) 
and equating the coefficients, the constants A and B may be found by solving the pair of equations: 
A
B
1
+
=
Ab + Ba = 0 
The result is 
a
A = 
-
a
b
b
B = -
-
a
b
Therefore, 
a 
a 
Y e jw
( 
) = 
jw 
a
b
-
-
-
-
jw 
a
b
b 
-
-
-
1 a e 
1 
e 
and it follows that the inverse DTFT is 
y n  = 
 a
an − 
b
bn
 u n
( )  
( )
a
b
− 
−

a
b

Discrete-Time Fourier Transform (DTFT) 
93 
6.8 SOLVING DIFFERENCE EQUATIONS USING DTFT 
In the previous chapter, we looked at methods for solving difference equations in the “time domain.” 
The DTFT may be used to solve difference equations in the “frequency domain” provided that the 
initial conditions are zero. The procedure is to transform the difference equation into the frequency 
domain by taking the DTFT of each term in the equation, solving it for the desired term, and finding 
the inverse DTFT. 
Example 6.7 
Solve the below for y(n) assuming zero initial conditions, 
y n  − . 
y n − ) = ( )
 
− x n − )
for ( )  = d n 
( )  0 25
 
( 
1 
x n  
(
2 
x n  
( ).
We begin by taking the DTFT of each term in the difference equation: 
Y e jw − 0 25 e− jw Y
 e
 
jw = X
 
e
 
jw 
e−2 jw X e jw 
(
) 
. 
(
) 
(
) − 
(
)
. 
Because of the DTFT of x(n) is X e jw = 1,
(
) 
Y e jw ) 
1− e−2 jw 
= 
1 
− 
e−2jw 
.
( 
=
− . e− jw 
1 0 25 
− . e− jw 
1 0 25 
− . e− jw
1 0 25 
Using the DTFT pair 
DTFT 
1
( .  )
( ) ⇔
− jw
0 25 n u n  
1 0  25 
. e
− 
the inverse DTFT of Y e jw ) may be easily found using the linearity and shift properties, 
( 
( )  0 25
 
)
( )
( .
)
 u n
y n  = ( .  
n u n  − 0
 
25 n−2 ( − 2) 
. 
Example 6.8 
Find the frequency response for the following LSI system 
a) h n
( )  = d( )  + d(n 
1
3 
n 
2
) 
d(n
−
+ 3 
−) 
b) h n  = 
 4
1
 
n+3 
u n − 3)
( )  
( 
SOLUTION 
∞ 
−jw )
( )  −jnw
H e( 
= ∑h n e  
n=−∞ 
∞ 
−jw 
−jnw
H e( 
) = ∑ d n + 2d(n −
+ 3d(n
[ ( )  
1) 
−3)]e 
n=−∞ 
Since, 
∞ 
∑[d(n
n
 e−jnw =
−jn0w
− 0)] 
e 
n=−∞ 

94 
Digital Signal Processing 
So, 
H e−jw = +
1 2e−jw + 3e−j3w
(
)
∞ 
H e−jw 
h n e−jnw
( 
) = ∑ ( )  
n=−∞ 
H e− jw = ∑
∞ 


 4
1
 
n+3 
u n − 3)
 
e− jnw
(
) 
( 
n=0  
 
= ∑
∞ 
 1 
n+ 3 
 e 
− j n+ )w 
 4 
( 
3 
n=0  
 
= 
 
1
 
3 
e− j3w ∑
∞ 

 
1
 
n
 e− jnw 
4 
n=0  4 
 
3 
∞ 
n 
= 
 1 

 e− j3w ∑
 1 e− jw 

 
4
4 
n=0 
Using the geometric series, we find 
æ 1 ö
3 
- j3w 
1 
= ç ÷ e 
è 4 ø 
1- 1 e - jw 
4 
Example 6.9 
Find the frequency response of an LSI system described by the difference equation 
y n
( )  −. 
y n  1) 
( ) + x n −
+
1 3 (
0 75 ( −
= x n  
2 ( 
) 
x n −2) 
. 
SOLUTION 
To find the frequency, we find DTFT for the difference equation 
−jw 
jw 
−jw 
−j2w 
jw
− 
Y e )
3 
X e )
(1 0  75 
. e 
) (
=
+
(1 2e 
+ e 
) (
Y e jw 
− jw 
− j2w
(
= 
)
+ e 
+ 3e
jw
H e  ) 
(
( 
)
= 1 2  
− .
X e jw 
1 0 75e− jw 
Example 6.10 
Find the DTFT of the following sequence 
a) x1 = ( . )
(
u n + 2
0 8  n 
) 
∞ 
−jw 
−jnw
X e
1 
) = ∑x n e
( 
1( )  
n=−∞ 
∞ 
= ∑(0.8)
( +  
n u n  2) e−jnw 
n=−∞ 

95 
Discrete-Time Fourier Transform (DTFT) 
∞ 
= ∑(0.8)n e−jnw 

n=−2 
∞ 
= ∑(0.8 e−jw )
n 
n=−2 
∞ 
= (0.8e− jnw )
−2 ∑(0.8e− jw )
n 
n=0 
∞ 
j2w 
− jw
= 25 e ∑(0.8 e 
)
n 
16 
n=0 
25 
j2w 
1 
= 16 e 
1− 0.8 e− jw 
b) x n = an sin (
)
2 
( )
n
2( )  
n u
∞ 
−jw 
−jnw
X
e( 
= ∑x n
2( )e
2 
)
n=−∞ 
∞ 
−jw 

n 

−jnw
X
e
 
= ∑a sin(2n u

2 
)
n
e
( 
) ( ) 
n=−∞ 
∞ 
=∑ an sin( n
e− jnw
 
2 ) 
n=0 
∞ 
n  e j n
2 − e− j n 
− jnw
=∑a  
2j 
2 
 e 
n=0 

 
∞ 
j n
 − j2n 
− jnw
n 
2
= 1 ∑a (e 
− e 
)e 
2j n=0 
∞ 
n
 j n
 
2 
− jnw 
n 
− j n
2 
− jnw
= 1 ∑(a e
e 
− a e
e 
)
2j n=0 
∞
∞ 
n
 j n
 
2 
− jnw 
n 
− j2n 
− jnw
= 2
1 
j∑(a e
e 
) − 2
1 
j∑(a e
e 
) 
n=0 
n=0 
∞
∞ 
n 
= 2
1 
j∑(ae 
− j(w−2) )n − 2
1 
j∑(ae− j(w+ 2) ) 
n=0 
n=0 
1  
1
1 
 
= 2j 1− ae− j(w −2) − 1−ae− j(w + 2)  
1  
a sin 2e− jw 
 
= 2j 
1 2  
− jw 
2 − j2w 

− a cos 2e 
+ a e 
0 
otherwise 
≥
0 25
 
)
( .  
n 
for
 
0 and even only 
n
c) x n
3( ) = 
∞ 
X
e−jw 
x n
( )e−jnw 
3 ( 
) = ∑ 3 
n=−∞ 

96 
Digital Signal Processing 
∞ 
− jw 
n 
− jnw
X
e
3 
= ∑ 0 25 e
(
) 
( .  ) 
n=0 2 4 …
, , , 
∞ 
− jw 
2n 
− j2nw
X
e( 
=∑ 0 25 ) e
3 
) 
( .  
n=0 
=∑
∞  1 e− j2w  
n 
 16 
 
n=0 
1 
= 
1− 1 e− j2w 
16 
Example 6.11 
Find the DTFT of the following sequence (Figure 6.4). 
a) Find the transfer function H(e jw ) 
b) Find the frequency response if 
h n
1 
= d n + (n 1
(n 2
2
( )  ( )  d 
) d 
) 
h n
−
+
 −
= 
( )
h n  = 0 5 n u n = 
4( )
3( )  ( . )
(
 ) 
h n
SOLUTION 
jw 
jw 
jw 
a) G e ) = H e
1 
)⋅ H
e )
1 (
( 
2( 
jw 
jw 
jw 
) 
H
e )
G2 (e 
= H
e
3 ( 
)⋅ 
4 ( 
Y e jw 
H(e jw ) = (
( 
jw 
)
) 
= G1 (e jw ) + G2 (e jw )
X e 
jw 
jw 
jw 
jw 
jw 
jw 
H e ) = 
= H e
1 
⋅ H
e
 + 
3 ( 
)⋅ H
e
( 
Y
X 
(
( 
e
e 
)
) 
(
)
2(
) H
e
 
4 (
)
jw 
b) H e jw 
1 e−jw + e−j2w 
jw 
=
+
 
= H
e
1( 
)
2(
) 
So, 
G1 (e jw ) =
+
(1 e−jw + e−j2w )
2 
h2(n) 
x(n) 
h4(n) 
h1(n) 
h3(n) 
y(n) 
FIGURE 6.4 System of Example 6.11. 

97 
Discrete-Time Fourier Transform (DTFT) 
jw 
jw 
H
e
3 
) = 
1 
j 
= H
e
( 
1 0 5 
. e− w 
4 (
)
− 
So, 
e jw =
G2 ( 
)

− .
1 
e− jw 
 
2 
 1 0 5 
jw 
jw 
jw 
jw 
jw 
jw 
H e ) = 
= H e
1 
⋅ H
e
 + 
3 ( 
)⋅ H
e
( 
Y
X 
(
( 
e
e 
)
) 
(
)
2(
) H
e
 
4 (
)
jw 
Therefore, 
jw 
(
)
(
−jw 
−j2w 

 
1 
−jw 
H(e ) =
Y
X (
e
e 
jww
 )
=
+
1 e 
+ e 
)
2 +
1 0 5 


2 
j 
−. e 
Example 6.12 
Find the DTFT of the following sequence (Figure 6.5). 
jw 
a) Find the transfer function H(e )
b) Find the frequency response if 
h n = d n + 2 (n − 2 
3 (n − 2 = 
2
1 
( )  d 
) + d 
) 
h n
( )  
( )
( )
( .
)
( ) = h n
h n = 0 75 n u n  
( )
3
4 
SOLUTION 
jw 
jw 
jw 
e ) = 
2 
H
e
a) G1 ( 
H
e( 
)⋅ 
3 (
) 
G 
e jw 
G e jw 
H
e jw 
2 ( 
) = 
1 ( 
) + 
4 (
) 
e jw 
H
e jw ⋅ H
e jw + H
e jw 
G2 ( 
) = 
2(
)
3 (
) 
4 (
) 
jw 
H e jw ) = 
Y
X 
(
( 
e
e 
)
) 
= H e jw ⋅G 
e jw 
( 
jw 
1(
)
2 (
) 
( 
jw 
jw 
1( 
jw ) 
( 
jw 
3 ( 
jw )
( 
jw 
H e ) = 
Y
X 
(
( 
e
e jw 
)
) 
= H e  ⋅H
e
2 
)⋅ H
e
 + H
e
4 
) 
h3(n) 
x(n) 
y(n) 
h1(n) 
h2(n) 
h4(n) 
FIGURE 6.5 System of Example 6.12. 

98 
Digital Signal Processing 
jw 
H e jw =
= H e jw ⋅ H
e jw ⋅ H
e jw + H e jw ⋅ H
e jw 
(
) 
Y
X 
(
( 
e
e 
)
) 
1(
)
2(
)
3 (
) 
1(
)
4 (
) 
jw 
jw 
−jw 
−j2w 
jw 
b) H e
1(
) =
+
1 2e 
+ 3e 
= H
e
2(
) 
and 
jw 
jw 
H
e( 
) = 
1 
− jw = H
e
3
4 (
)
1 0.75e
− 
jw 
( 
jw ) 
Y
X 
(
( 
e
e 
)
) 
1( 
jw )
2( 
jw )
3 ( 
jw ) 
1( 
jw )
4 ( 
jw ) 
H e 
=
= H e  ⋅ H
e
 ⋅ H
e
 + H e  ⋅ H
e
jw 
Therefore, 
jw 
−jw 
−j w 
H(e ) =
Y
X 
(
(
e
e
j
j 
ww
 
)
)
=
+
(1 2e 
+ 3e
2 )
2 ⋅
−.75
1 
−jw 
1 0
e 
+
+
1 2e−jw + e−j2w )⋅ 
1 
−jw 
( 
3 
1 0.75
− 
e 
Y e jw 
+ e− jw + e− j2w 
1 2  
3 
H(e jw ) = 
X 
(
(e 
)
)
= ( 
1 0
) ⋅ + e− jw + e− j2w 
2
2
 
3
jw 
− .75e− jw 
Example 6.13 
A LSI system is described by a difference equation, 
y n
( )  = .
(n
)
y 
− 1 + a x n
0 1  
( )
a) Find the gain value α so that the magnitude of the transfer function is equal to that value 
at the dc condition. 
b) Find the half power point. 
SOLUTION 
y n  = .
(
y n − 1 + a ( )
( )
0 1  
) 
x n
Take DTFT 
jw 
jw 
jw 
jw
Y e  
= . e
Y e 
+ a
(
) 
0 1  − 
(
) 
X (e ) 
−
− jw 
jw 
X e jw
(1 0 1
. e 
)Y (e ) = a (
) 
jw 
H e jw =
= 
a
(
) 
Y
X 
(
( 
e
e jw 
)
) 
( − . e− jw )
1 0 1
Y e jw 
jw 
jw 
H(e ) = 
X 
(
(e 
)
)
= (1 0 1
− .
cos
( 
a
w − j sinw)) 
jw 
jw 
H(e ) = 
Y
X 
(
( 
e
e jw 
)
)
= (1 0
− . cos 
1 
w
a 
) − j 0 1
. sinw 

99 
Discrete-Time Fourier Transform (DTFT) 
a
jw 
=
H(e ) 
( − . cos w)
2 + (0 1 
w)
2
1 0 1 
. sin 
a 
=
H(e jw ) 
. 
− . cos w
1 01 0 2
At dc ω = 0 so, 
a
1= 
1 01 0 2
. 
− . 
a = 0.9 
Therefore, 
jw 
jw 
( 
0 9  
jw 
− jw 
H(e ) = 
Y
X ( 
e
e 
)
)
= (1 0 1
− .
. 
e 
) 
Example 6.14 
A LTI system is described by a difference equation 
y n
( )  = . y n − 1)
( 
+ a x n
0 8  
( ) 
a) Find the gain value α so that the magnitude of the transfer function is equal to that value 
at the dc condition. 
b) Find the half power point. 
SOLUTION 
y n
( )  = . y n − 1)
( 
+ a x n
0 8  
( ) 
Take DTFT 
jw 
. 
− jw 
jw 
X e jw
Y e  
= 0 8e
Y e 
+ a
(
) 
(
)
(
) 
−
− jw 
jw
a X e jw
(1 0 8
. e 
)Y (e ) = 
(
) 
jw 
H(e jw ) = 
Y
X 
(
( 
e
e jw 
)
)
= ( − . 
a 
e− jw )
1 0 8
jw 
H e jw =
= 
X e 
(1 0 8
−
( 
w − j sinw)
(
) 
Y (
( 
e
jw 
)
) 
.
cos 
a 
) 
jw 
jw 
H(e ) = 
Y
X 
(
( 
e
e jw 
)
) 
= 1 0.8cosw
a 
j
( − 
) − 0.8sinw 
a 
=
H(e jw ) 
( − . cosw)
2 
0.8sinw)
2
1 0 8 
+ ( 
a 
=
H(e jw ) 
. 
− . cosw
1 64
1 6

100 
Digital Signal Processing 
At dc ω = 0 so, 
a
1= 
1 64
1 6 
. 
− . 
a = 0.2 
Therefore, 
(
)
H e jw =
= 
.
(
) 
Y e j
j 
w
w 
0 2  
− jw
X e  
− . e
(
)
(1 0 8 
) 
1 
0 2
. 
= 
2 
1 64
1
 
6 
−
. 
. cosw 
Solving this, we get w = 0 124p
. 
rad. 
Example 6.15 
Write a difference equation to implement a system with a frequency response 
( 
jw = +
− 
. 
e− jw + .
0
 
9 
e− j2w
w 
1
 0 8 
H e  ) 
1 0 7
 
e− jw − . e− j2 
SOLUTION 
jw 
jw 
jw 
H e  ) = 
Y e  ) 
1− e− jw 
− jw 
+ . e− j2 
− 
w 
j2w
X e  ) 
1 0 7
 
e 
− .
( 
(
( 
=
+ . 
0 8 
0 9 e 
After cross-multiplying, we have 
− jw 
− j2w 
jw 
− jw 
− j2w 
jw
1 0 7
 
e 
− 0 9
 
(
= 1− e 
+ 0 8
. e 
X e  )
 + .
. e 
 Y e  ) 
 
( 
. 
Taking the inverse DTFT of each term gives the desired difference equation 
y n
( )  + 0 7y n  
)
.
( 
) 
x n  −x n
( 
1
0
) 
8x n
.
(
 −
−
 
y n −
=
 
( )  
−
+ .
(
 −2
1
0 9
 2 
) 
y n
( )  = −0 7y n  
)
.
( 
) x n  −x n
( 
1
0
) 
8x n
.
(
 −
+
 y n −
+ ( )  
−
+
 
.
(
 −2
1
0 9
 2 
) 
Example 6.16 
Find the group delay for each of the following systems, where α is a real number. 
a) For the sequence, the frequency response 
jw 
- jw
H e  ) = - e
( 
1 2
jw
- jw
H e( 
= -
e
)
1 2  
H e jw = - ( 
w - j sinw) 
(
)
1 2  cos 
Therefore, the phase is 
j w  = tan -1 2sin w
( )  
-
cos w
1 2  

101 
Discrete-Time Fourier Transform (DTFT) 
t = d 
dw j w
( )  = d tan -1 2sinw 
dw 
-
1 2  w
cos 
2 
ö
d
d
1 
sin
æ 
w
j w
( )  =
t = 
ç
÷ 
è
2 dw
dw 
-
1 2
æ 2sinw ö 
w
cos ø
1+ ç
÷ 
è -
cosw ø
1 2  
Therefore, 
1 
æ ( -
cosw) 2cosw -(2sinw)
2 ö
1 2  
t = 
2 ç 
2 
÷ 
1+ æ
ç 2sinw ÷
çè 
( -
cosw) 
÷ø
ö 
1 2  
è -
cosw ø
1 2  
So, after simplification, becomes 
2 2  - cosw)
(
t = 
( -
cosw)
2
5
4
 
Example 6.17 
Find the group delay for each of the following systems, where α is a real number. 
a) For the sequence, the frequency response is 
H e(
) 
−
j
j
= −b
1
w 
w
e 
H e(
) 
−
j
j
= −b
1
w 
w
e 
H e(
j ) = −
1 
( 
w) 
b 
w −
w
j sin
cos 
Therefore, the phase is 
j w  = tan−1 
b sinw
( )  
1− b cosw 
tan−1 
b sinw
d
d
j w
( )  =
t = 
1− b
d
dw
w
cosw 
 b
w  
t = d 
dw
d
1 
sin
j w
( )  = 
 

2 
1− b
dw

 
w
b 
cos
sinw
1+ 
 1− b cosw 
Therefore, 
1 
(1− b cosw) b cosw −(b sinw)
2  
t =


 b sinw  
2 ⎝ 
(1− b cosw)
2 

1+ 
 1− b cosw  
So, after simplification, it becomes 
b b − cosw
(
)
t = 
2
(1+ b − 2b cosw)
2 

102 
Digital Signal Processing 
Example 6.18 
 
+
+
 ( −
= x n  1
( 

tanw
j y n
( 
1) 
j y n  1) 
( +
−
) x n −1) = 
SOLUTION 
Take the DYFT for the lift side 
j y n
( 
1) 
j y n  
)
( +
−
1) x n
 
( −
= x n  
( −1)
+
+
 
1 

j y n
( 
1) 
j y n  
)
( +
−
1) x n
 
( −
= x n  
( −1)
+
+
 
1 

je jw + je− jw Y e jw = e jw −e− jw X e jw
 
( 
)
 
( 
) 
Y e jw 
jw 
− jw
(
) 
[e 
+ e 
]
[e jw − 
2j
e− jw ] 
=
= 
X e jw ) 
[ je jw + je− jw ]
[ je jw + je− jw]
( 
2 
sinw 
=
= tanw 
cosw 
6.9 FREQUENCY RESPONSE IN MATLAB 
To find the frequency response of the given LTI system given in difference equation form or transfer 
function form and to plot the same follow the below. 
clc; 
clear all; 
close all; 
num=input('enter the numerator vector: '); 
den=input('enter the denominator vector: '); 
N= input(' enter the number of frequency points: '); 
w=0:pi/N:pi; 
H=freqz(num,den,w); 
figure; 
subplot(2,2,1); 
plot(w/pi,real(H)); 
xlabel('\omega/\pi'); 
ylabel('Amplitude'); 
title('real part'); 
subplot(2,2,3); 
plot(w/pi,imag(H)); 
xlabel('\omega/\pi'); 
ylabel('Amplitude'); 
title('imag part'); 
subplot(2,2,2); 
plot(w/pi,abs(H)); 
xlabel('\omega/\pi'); 
ylabel('Magnitude'); 
title('Magnitude spectrum'); 
subplot(2,2,4); 
plot(w/pi,angle(H)); 

103 
2 
Discrete-Time Fourier Transform (DTFT) 
real part 
Magnitude spectrum
2 
0 
1
Amplitude
0 
1
Magnitude 
0 
0.2 
0.4 
0.6 
0.8 
1 
0
 0.2 
0.4
 0.6 
0.8 
1 
imag part 
Phase spectrum
1 
5 
1 
0
phase(radians)
Amplitude
0 
–1 
0 
–5 
0 
0.2 
0.4 
0.6 
0.8 
0.2 
0.4
 0.6 
0.8 
1 
FIGURE 6.6 Frequency response using the MATLAB program. 
xlabel('\omega/\pi'); 
ylabel('phase(radians)'); 
title('Phase spectrum'); 
enter 
enter the numerator vector: [1 1 1 1] 
enter the denominator vector: [1 1] 
enter the number of frequency points: 512 
Output 
Figure 6.6 shows the frequency response from the output of a MATLAB program. 
Example 6.19 
Given the B and A coefficients of a filter as below: 
B = [–0.09355 –0.01558 0.1 –0.01558 –0.09355] 
A = [1] 
Write down a MATLAB program to compute the magnitude frequency response and phase 
response of this filter. If the sampling rate is 8,000 Hz, then write down MATLAB code to plot the 
magnitude in dB and phase response in degrees as a function of frequency in Hz. 
SOLUTION 
The magnitude frequency response and the phase response are computed by the MATLAB pro-
gram shown below along with the code for the desired plots. 
[response, w] = freqz([0.1 0.2 0.3 0.2 0.1],[1], 512); 
magnitude = abs(response); 
magnitude_db = 20*log10(magnitude); 
phase_degree = 180*unwrap(angle(response))/pi; 
figure, 
subplot(2,1,1); 
plot(w, magnitude_db); 
grid; 
xlabel('Frequency (rad)'); 
ylabel('Magnitude response(dB)'); 

104 
Digital Signal Processing 
0 
0.5 
1 
1.5
 2 
2.5 
3 
3.5 
Frequency (rad) 
0 
0.5 
1 
1.5
 2 
2.5 
3 
3.5 
Frequency (rad) 
FIGURE 6.7 Frequency response of Example 6.19. 
subplot(2,1,2); 
plot(w, phase_degree); 
grid; 
xlabel('Frequency (rad)'); 
ylabel('Phase response(degrees)'); 
Figure 6.7 Shows the frequency response of Example 6.19. 
Example 6.20 
Given the following digital system with a sampling rate of 8,000 Hz, 
y n
( )  = .
( )
 
x n + 0 5  ( 
0 5  
. x n − 1) 
determine the frequency response of the system. 
SOLUTION 
Taking the z-transform of both sides of the difference equation, we get 
0 5 ( )
 
0 5z
X z 
Y z
( )  = . X z + . 
−1 ( )
⇒ Y z
( )  = 0 5  + . 
−1) ( )
( .  0 5z
X z 
Therefore, the transfer function of the system is given by 
H z  = Y z
( )  = ( .  + . z−1
( )  
0 5
0 5  )
X z
( )  
To find out the frequency response of the system, we replace z with e jΩ, which leads to 
jΩ 
. 
− jΩ)
H e( 
) = (0 5
. + 0 5e 
The transfer function can be written as 
H e jΩ= 0 5
. + 0 5cos Ω− j . 
( )
(
) 
. 
( )  0 5sin Ω 
–150 
–100 
–50 
0 
Magnitude
response (dB) 
–400 
–200 
0
Phase response
(degrees) 

105 
Discrete-Time Fourier Transform (DTFT) 
Therefore, the magnitude frequency response and phase response are given by 
H e jΩ = 0 5  
0 5sin Ω
. + 0 5
. cos ( )
Ω−j . 
( )
(
)
. + 0 5cos Ω)
2 + −. sin (Ω)
2 
=
(0 5
. 
( )  ( 0 5  
) 
and 
. sin ( )   
∠H e jΩ= tan 
−0 5  
Ω
(
) 
 .
. 
( )
0 5  + 0 5cos Ω 
Which is an example of a low-pass filter. 
Example 6.21 
Given the following digital system with a sampling rate of 8,000 Hz, 
y n = x n
( )  − 0 5y n − 1) 
( )  
.
(
 
determine the frequency response of the system. 
SOLUTION 
Taking the z-transform of both sides of the difference equation, we get 
Y z  = X z
( )  − 0 5  −1 ( ) 
( )  
. z
Y z 
⇒ Y z + . z
Y(z) = X(z)
( )  0 5  −1 
(1 0 5 −1) 
( )
⇒
+ . z
Y(z) = X z 
Therefore, the transfer function of the system is given by 
Y z  
1 
H z
( )  = ( )  = 
X z
( )  ( + . z ) 
( 
1 0 5 −1 
To find out the frequency response of the system, we replace z with e jΩ, leads to 
jΩ) 
1 
H e  
= ( + . e− jΩ)
1 0 5 
The transfer function is written as 
H e( 
jΩ) = (1 0 5 
1
0 5 
Ω)
+ . cos ( )
Ω− j . sin ( )
Therefore, the magnitude frequency response and phase response are given by 
1
jΩ
H e  ) =
( 
(1 0 5
+ . cos ( )
Ω−j 0 5 
( )
Ω
. sin 
) 
1 
= 
Ω)
2 + −0. sin 
5 
(Ω))
2
(1 0
+ . cos 
5 
( )  ( 
and 

106 
Digital Signal Processing 
∠
j )
Ω= −tan 
1 0 5 
. cos 
+ 


. sin 
H e
PROBLEMS 
6.1 
Find the frequency response for the LSI system with unit sample response 
h n  = an u n −1)
( )  
( 
< 1. 
Ω
( )
Ω
0 5
( )  
6.2 
Find the frequency response for the LSI system with unit sample response 
h n  = a d(n −
( )  
n 
1) 
− 
< 1. 
x n  = an u n −1)
( )  
( 
a > 1 
(
This is an example of a high-pass filter. 
α
where  is a real number with a 
α
where  is a real number with a 
6.3 
Find the DTFT of the sequence 
6.4 
Find the DTFT of the sequence 
x n  = 2n u n −1)
( )  
( 
a > 1 
6.5 Find the inverse DTFT of: 
w
X e j ) = 2p d  w
 
− 4)+ 2 
(
(
( 
p d w  + 4) 
6.6 
Find the frequency response of the linear shift-invariant system characterized by the second-
order linear constant-coefficient difference equation 
y n  = . 
y n  )
. 
y n
( 
2) x n  −. 
(
) x n  2
( )  1 3433 ( −
−
 −
+
 
( )  1
 
4142 x n  1
( −)
1
0
 
9025 
−
+
 
6.7 
If the unit sample response of an LSI system is: 
h n  = an u n −1)
( )  
( 
n
find the response of the system to the input x n
( )  = b u n
( ) where a < 1, b < 1 and a
b.
≠ 
6.8 
Solve for y(n) assuming zero initial conditions, 
y n  −.
(y n  1) 
x n
( )
 
+ x n  1) 
( −2 
x n
( −
−x n  
)
for ( )  = d n
( )  0 5  
−
=
 
( ). 
We begin by taking the DTFT of each term in the difference equation: 
6.9 
Solve for y(n) assuming zero initial conditions, 
y n  = x n  + .
(
 )
. x n −2) for (  ) = d n
( )  0 5x n −
−
 
( 
x n
( )  
1
0 75 
( ). 
We begin by taking the DTFT of each term in the difference equation: 
6.10 Find the frequency response for the following in an LSI system 
a) h n  = d n + .
(n 2) d(n 
( )  ( )
0 5  d 
−
+
 − 3) 
 1 
n−3 
b) h n  = 
u n − 3) 
( )  
(
 5 

107 
Discrete-Time Fourier Transform (DTFT) 
6.11 Find the frequency response for the following in an LSI system 
a) h n
( )  = d( )
n + 0 2.
(
d n −
+
)
. 
d(n −2)
1
0 25 
 1 
n+3 
b) h n  =   
u n + 3) 
( )  
(
8 
6.12 Find the DTFT of the following sequence 
a) x n
1( )
( .
)
(
= 0 75 n u n − 2) 
2 
n−1 
) (  
b) x n
( )  = a 
sin( 2n u n −1) 
6.13 Find the DTFT of the following sequence 
y n
( ) = 

 
1 
0 
otherwise 
−
( . )n
0 5
≥ 
for 
1 and even only
n 
6.14 Find the DTFT of the following sequence (Figure 6.8). 
a) Find the transfer function H(e jw ) 
b) Find the frequency response if 
h n
( ) = d (n + 1) 
(n − 1) 
(n − 2) = h ( )
n
1 
+ d 
+ d 
3 
2( )  ( . 5 n+1 ( )  h n
h n  = 0 7 ) 
u n = 
4( )
6.15 Find the DTFT of the following sequence (Figure 6.9). 
a) Find the transfer function H(e jw ) 
b) Find the frequency response if 
1( )  
) + 
n 
− 2) = h3 n
h n  = d (n + 1
2d ( ) + 3d (n 
( )
2( )  ( . )n-1 ( ) 
h n
h n  = 0 9
u n = 
4( ) 
h2(n) 
x(n) 
h4(n) 
h1(n) 
h3(n) 
y(n) 
FIGURE 6.8 System of Problem 6.14. 
h3(n) 
x(n) 
h1(n) 
h2(n) 
h4(n) 
y(n) 
FIGURE 6.9 System of Problem 6.15. 

108 
Digital Signal Processing 
6.16 A LSI system is described by a difference equation 
y n  = .
(y n − 2) + b ( )
( )  0 1  
x n
a) Find the gain value α so that the magnitude of the transfer function is equal at dc condition. 
b) Find the half power point. 
6.17 Find the inverse DTFT 
p 
X e( 
jw ) = 
5e j2w
p 
3 < w < 3 
0 
otherwise 
6.18 Write a program to determine the magnitude and phase responses of the system described by 
the transfer function: 
S2 + wo 
2 
H S
( )  = 
S2 + 2 wo S + wo 
2 
Q 
Then, run the program and display the results. 
6.19 Let h(n) be the unit sample response of a LSI system. Write a program to determine the fre-
quency response when: 
 1 
n+2 
h n  = 
u n − 2)
( )  
(
 3 
Then, use this program to display the amplitude and phase responses. 
6.20 A first-order recursive digital filter is specified by the relation: 
( )  
(
1 
x n
y n  = a y n − ) + ( ), for n ≥ 0. 
where y(n) and x(n) are the output and the input sequences, respectively. 
Write a program to determine and display the magnitude and phase responses for this 
filter. 

7 Discrete Fourier 
Transform (DFT) 
Discrete Fourier Transform is one of the great mathematical solutions in DSP to convert the sig-
nals from discrete-time to discrete frequency, this chapter will present Method of Decimation-
in-Frequency, and Method of Decimation-in-Time for the sequences. The Properties of Discrete 
Fourier Transform will discuss. Also Discrete Fourier Transform of a sequence in MATLAB and 
…
its application in Linear convolution and Generation of Inverse Discrete Fourier Transform (IDFT). 
−1
N 
∑ 
7.1 METHOD OF DECIMATION-IN-FREQUENCY 
The DFT of a given sequence x(n), where n= 0, 1, …, N−1, can be determined by the following 
relationship, 
, 
kn
− 
X k
( )  
x n W
( )  
for k 
, ,
0 1  
N 1
(7.1) 
= 
= 
N 
n 
The twiddle factor WN is given by 
= 0 
W 
e 
N 
j 
N
N 
j 
N
= 
= 
 
 
 
 + 
 
 
 

− 2 
2 
2
p 
p 
p
/ 
cos 
sin 
(7.2) 
In this case, N must have the power of two, i.e., it can take up values 
N = 2 4  8 16 …
, ,  ,
,
 
Equation (7.1) is expanded as 
X k  
x 
x W 
x N 
W
N 
k 
N 
k N
( )  
( )  ( )  
( 
)
= 
+ 
+ 
+ 
− 
−
( 
)
0 
1 
1 
1
 
(7.3) 
The right-hand side of Equation (7.3) can be further split as follows 
X k  
x 
x W 
x N 
W 
x N W 
N 
k 
N 
k N 
N 
k N 
( )  
( )  ( )
= 
+ 
+ 
−
 
 
 
 
+  
 
 
 
+ 
−
 
 
 
 
0 
1 
2 
1 
2 
2 1 
 
2 
2 1 
1 
2 
1 
1 
 
 
 
 
+
 
 
 
 
−
( 
)
+ 
+
 
 
 
 
+ 
+ 
−
x N 
W 
x N 
W
N 
k N 
N 
k N
 
( 
) 
(7.4) 
Or written as 
X k  
x n W 
x n W  
n 
N 
N 
kn 
n N  
N 
N 
kn
( )  
( )  
( )  
/ 
/ 
= 
+ 
= 
( 
)− 
= 
− 
∑ 
∑ 
0 
2
1
 
2 
1 
(7.5) 
Consider the second summation on the right-hand side of Equation (7.5), i.e., 
n N  
N 
N 
kn
x n W 
= 
− 
∑ 
/ 
( )  
2 
1 
109 

110 
Digital Signal Processing 
Let us substitute 
N
N 
N 
m
n
 
at n = 
, m = 0 and
at n =
−1 m
=
−
 ⇒ 
N 
, 
=
−1 
2
2 
2 
Therefore, 
N −1 
(N /2
1
)− 
 
N 
 N (N / )−
2
1
 
∑ 
∑
 
2  
k m+ 
k 
∑  
2  
 
N  
 
 

 
 
N  
x n W N
kn = 
x m + 
N 
2 = WN 
2
N
km
( )  
W 
x m + 
W 
n N /2 
m=0 
m=
= 
0 
As 
N
N /2 
−j 2 
N 
p . N 
2 
−jp 
cos( ) 
sin( )  = −1
W 
= e 
= e 
= 
p + j 
p 
Therefore, 
N  
W
k2 = W N /2 )
k = −
(
)k 
N 
(
N 
1 
Thus, 
N −1 
N /2
1
−
(
)
∑x n
( )WN
kn = −
(
)k ∑x

m + N 
2 

WN
km
1 
n N /2 
m
=
=0 
As m is a dummy variable (used for summation only), we can use n in its place, i.e., 
N −1 
N /2
1
−
(
)
∑x n
( )WN
kn = −
(
)k ∑x

n + N 
2 

WN
kn
1 
n N /2 
n
=
=0 
Thus, the DCT coefficient X(k) (from Equation (7.5)) can be written as 
(N /2
1
 
(N )−
)− 
/2
1
 
X k
( )  = ∑ x n WN
kn 
(
)k ∑ x
 n + N 
2 
 WN
kn
( )  
+ −1 
(7.6) 
n=0 
n=0 
For k = 2m as an even number, from Equation (7.6), we can write 
 N 
 N  
 2  −1 
 2  −1 
∑ ( )  2mn + −1 2m ∑ 

 
N 
2 
⎞
 W 2mn
X
m
(2 ) = 
x n W N 
(
)
 
x n + 
N 
n=0 
n=0 
 N 
 N  
 
−1 
 
−1 
2
2 
∑ 
∑ 

 
N  
= 
x n W
( )  N 
2mn + 
x n +
⎟ WN 
2mn 
(7.7)
2  
n=0 
n=0 
 N 
 N ⎞ 
 2  −1 
 2  −1 
∑ 
 

 
N 
2 


 
2mn ∑ 
2mn
( )  
N 
a n WN 
= 
x n  + x n + 
W 
= 
( )  
n=0 
n=0 
And for k = 2m + 1 as an odd number, from Equation (7.6), we can write 

111 
Discrete Fourier Transform 
(N /2
1
)− 
(N /2
1
)− 
X
m
2
) ∑x n WN
(2m+1)n + −
(
)1 (2m+1) ∑x

n + N 
2 

WN
(2m+1)n
(
1 
( )
+
=
 
n=0 
n=0 
2
1
−
(N /2
1
−
(N / )
)
= ∑
( )  N
(2m+1)n ∑

 
N 
 
N
(2m+1)n 
x n W 
− 
x n + 
W 
2
n=0 
n=0 
− 
N 
−
(N /2
1
 
/ )
= ∑
( )  
 
N 
2 


 
N
n 
N 
2mn ∑
( )  N
n 
N
2 
) 
( 
2
1
 
x n  −x n + 
W W  = 
b n W
mn 
n=0 
n=0 
Using the fact that 
2 
− j 2p .2 
− j(N 
2p 
/2)
WN = e
N 
= e 
= WN /2 
We can write 
(N / )−
2
1
 
= DFT  
a n with
( )  
N 
2 points  
∑ 
=
mn
X
m
2 )
( 
a n W
( )  
(7.9) 
N /2 
n=0 
N / −
2
1
(
)
n
mn 
n
X
m
(2 +
=
) 
b n W W  = DFT 
( )
1 ∑
( )  N
N /2 
b n W N with N point ⎫
(7.10)
 
2 
 
n=0 
where a(n) and b(n) are given by 
 
N  
N 
a n  = x n  + x n + 
, for n = 0 1 2  …,
( )  ( )  
, , ,  
−1
(7.11)
 
2  
2 
 
N  
N
b n  = x n  − x n + 
, for n = 0 1 2  …,
( )  ( )  
, , ,  
−1 
(7.12)
 
2  
2 
or collectively 
 
 
 
N 
DFT a n  with
( )  
points
 
2 
DFT { x n  with
( )  
N points} = 
(7.13) 
DFT  
 
N
n
 
 
b n W
( )  wi th 
points
N 
2 
It could be noted that the number of complex multiplications is drastically reduced (especially for 
large N) when using FFT instead of DFT. For a sequence with N-points, 
Number of complex multiplications in DFT = N 2 
(7.14) 
N
Number of complex multiplications in DFT = 
log 2(
)
(7.15)
N 
2 
A similar approach has been developed for finding out the inverse DFT using the decimation-in-
frequency method of FFT. For the inverse DFT, we have 
N −1 
x n  = 1 ∑X k W N 
For n = , ,…, N
( )  
( )  −kn 
0 1  
−1
(7.16)
N n=0 

112 
Digital Signal Processing 
This equation is written as, 
N −1 
x n  = 
X k W N 
For n = , ,…, N
( )  1 ∑ ( )   kn 
0 1  
−1
(7.17)
N n=0 
Whereas, 
2p 
WN = WN 
−1 = e
j N 
(7.18) 
Therefore, in this case 
 
 
 
N 
iDFT a n with
( )  
points
 
2 
iDFT { x n with
( )  
N points} = 
(7.19) 
 
 
 n
N

 
iDFT b n W
( )  with 
points
N 
2 
where a(n) and b(n) are given by 
 
N  
N 
a n  = x n  + x n + 
, for n = 0 1 2  …,
( )  ( )  
, , ,  
−1
(7.20)
 
2  
2 
 
N  
N
b n  = x n  − x n + 
, for n = 0 1 2  …,
( )  ( )  
, , ,  
−1 
(7.21)
 
2  
2 
7.2 METHOD OF DECIMATION-IN-TIME 
In this method, we split the input sequence into the even indexed and odd indexed sequences, as 
below 
(N /2
1
N −1 
(N /2
1
)− 
)− 
X k  =∑x n W
( )  
= ∑ x(2m W  
+ ∑ x
m + 1 W W  
for k = 0 1 … N −
( )  
N
kn 
) 
N 
2km 
(2 
) 
N
k 
N 
2km 
, ,
,
 1
n=0 
m=0 
m=0 
whereas, 
WN = e− j2p/ N = cos
 2p 

 + j sin 
 2p 

 
(7.22)
N
N 
and 
N = 2 4 8 1
, , ,
,… 
Using the fact that 
WN 
2 = e 
− j 2 
N 
p .2 = e 
− j(N 
2p 
/2) = WN /2 
(7.23) 
we get 
N / )− 
N /2
1
)−
( 
2
1
 
( 
X k  = 
x
m W
(2 ) 
N
km 
/2 + WN
k 
x
m + 1)WN
km 
/2 
(7.24)
( )  ∑
∑ (2 
m=0 
m=0 
We define new functions 

113 
Discrete Fourier Transform 
N / )− 
( 
2
1
 
km
G k  = ∑ x
m W
 
(2 ) 
N /2 = DFT
 
x(2m) with (
/
 
2) points 
(7.25) 
( )  
{ 
N 
} 
m=0 
N / )−
( 
2
1
 
km
∑ (2 
1 WN /2 
1 
(
/ 2) 
} 
(7.26) 
H k
( )  = 
x
m + ) 
= DFT
 
{x(2m + ) with N 
points 
m=0 
We also note that 
 
N  
N
G k  = G k + 
, for k = 0 1  …
−
( )  
 
 
, ,
,
 1
(7.27) 
2
2 
 
N  
N
H k  = H k + 
, for k = 0 1  …
−
( )  
 
 
, ,
,
 1
(7.28) 
2
2 
So we get 
N
X k  G k  W H k
 
N 
k
( )  
( )  
( ),
= 
+ 
k 
, ,
,
= 
…
for
 0
 
1 
2 −1 
(7.29) 
Also, keep in view 
W 
W
N 
N k 
N 
k
2 +
 
 
 
 = − 
(7.30) 
For the second half, we can write 
 
N  
k
N
X k +
= G k  − 
N ( ), for k = , ,
,
 1
 
 
( )  W H k
 
0 1  …
− 
(7.31) 
2
2 
Let x(n) be a finite duration sequence. Then the N-point DFT of the sequence x(n) is expressed as 
N −1 
− jk2pn 
X k  =∑x n e 
DFT 
(7.32) 
[ ]  
( )  
N 
k=0 
where 
k = 0 1  …, N −1
, ,
and the corresponding Inverse Discrete Fourier Transform (IDFT) is expressed as 
N −1 
jk2pn 
x n  = 
X k e N 
IDFT 
(7.33) 
[ ]  1 ∑ ( )
N k=0 
Where 
n = 0 1  …, N −1
, ,
Now, let us define the twiddle factor as 
− jk2p 
Wn = e
N 
(7.34) 
Hence, DFT and IDFT equations are written as 

114 
Digital Signal Processing 
kn 
k = , ,
0 1  …, N − 1
(7.35) 
X k
( ) = 
x n  W
( )  N 
=0
n 
and 
−1
N 
∑ 
N −1 
x n  = 
X k  W
( )  −kn 
n = , ,…, N
( )  1 ∑ 
N 
0 1  
−1 
(7.36)
N k=0 
Example 7.1 
Find the DFT of the sequence x n = 11 0 0  and the IDFT of Y k = 1 0 1 0 .
( )  [ , , ,  ]
( )  [ , , ,  ]
SOLUTION 
We know that DFT expressed as 
N−1 
− jk2pn 
X k  =∑x n e
[ ]  
( )  
N 
k=0 
Here N = 4, therefore, we have 
3 
( )  
( )  j nk/2
− p
X k  =∑x n  e 
n=0 
So when 
3 
k =
Þ
0 
X( ) =å x n e
( )
0
0 
n=0 
x 0 + x 1 + x 2 + x( )
= ( )
( )
( )  
3 
= + +
+
= 2
1 1 0
0
 
when 
3 
- j n/
p 
2
k =
Þ
1 
X( )1 =å x n e
( )  
n=0 
= x 0 + x 1e - jp /2 + x 2 e - jp + x( )  - j3p /
( )
( )  
( )  
3 e 
3
2
1
1e - jp /2 + 0 e - jp + ( )  - j3p /2 
1
= + ( )  
( )
0 e 
= - j 
when 
3 
2 
- j n
p
k =
Þ
2 
X( ) =å x n e
( )  
n=0 
= x 0 + x 1e - jp + x 2 e - j2p + x 
- j3p
( )
( )  
3 e
( )  
( )  
= 1+ ( )  - jp + 0 e - j2p + ( )e - j3p = 0
1
1e 
( )  
0 
when 
3 
3 
- j3pn/2
k =
Þ
3 
X( ) =åx n e
( )  
n=0 
= ( )  ( )  j3
2
p / 
( )  - j3p 
3 - j p /
x 0 + x 1e -
+ x 2 e 
+ x( )e 
9
2
= + ( )  - j3
2
( )  - j p 
( )  - j9p /2 
1
1
1e 
p / + 0 e 
3 + 0 e 
= + j 

115 
Discrete Fourier Transform 
So, X k  = 2 1- j, ,
( )
[ ,  
0 1+ j]
Also, we know that the IDFT is expressed as 
N-1 
( )  
( )
2 nk N
p 
/
y n  = 1 åY k  e j 
N k=0 
Here N = 4, therefore, we have 
3 
y n = 1åY k e j nk
( )  
( )  p 
/2 
4 m=0 
So when 
3 
n =
Þ
0 
y( ) = 1åY k e
( )  0
0 
4 k=0 
1 Y 0 + Y 1 + Y 2 + Y( )]
= 
[ ( ) 
( ) 
( ) 
3 
4 
1
1 
= 
[ + + + ] = 
1 0  1 0  
4
2 
when 
3 
p
n =
Þ
1 
y( )1 = 1åY k e
( )  j k /2 
4 k=0 
=
é ( )  ( )1 jp /2 
( )  jp 
( )  j3p /
1 Y 0 + Y
e 
+ Y 2 e 
+ Y 3 e 3
2ù
4 ë
û 
= 1 é + ( )  jp /2 
( )  jp 
0 e j3p /2ù
ë1
0 e 
+ 1e 
+ ( )  
û = 0 
4 
when 
3 
n =
Þ
2 
y( ) = 1åY k e
( )  j k
2 
p 
4 k=0 
4
1 
ë Y 0 + Y 
e jp + Y 2 e j2p + Y 3 e j3p ùû
=
é ( )
( )1 
( )  
( )  
= 1 éë1
0
+ ( )e jp + ( )1e j2p + ( )
0 e j3p ùû = 1 
4
2 
when 
3 
3 
3
2
n =
Þ
3 
y( ) = 1åY k e
( )  j
k
p / 
4 k=0 
= 4
1 éëY 0 + Y 
e j3
2
p / + Y( )2 e j3 + Y( ) 
j p / 
û
( )  ( )1 
p 
3 e 9
2ù
= 1 
+ ( )e j3
2
p / + ( )  j3p + 0 e j9p /2
é1
0
 
1e 
( )  
ù = 0 
4 ë
û 
é 1
1 
ù 
So, y n
ëê 2 0 2 
ûú
( ) = 
, ,  ,0 

116 
Digital Signal Processing 
Example 7.2 
Given a sequence x(n
≤
≤3, where 
) for 0 
n 
x( )  = 1 x 1 = , x( )  = 3 x
, ( )
 2
2 
, ( ) = 4
0 
3 
a. Evaluate the DFT, i.e., X(k). 
b. Evaluate and sketch the resulting two-sided amplitude spectrum, i.e., Ak. 
c. Evaluate and draw the resulting one-sided amplitude spectrum, i.e., Ak. 
SOLUTION 
(a) According to the definition of DFT 
−
N 1 
∑
kn
−
X k( )  
x n WN
( )  
for k 
, , ,  
0 1 2 
N
1
=
=
, 
…, 
n 
where 
=0 
WN = e− j2p /N 
In this case, N = 4, therefore the DFT can be written as 
X k  = x( )  + x W
 
( )  4 
k + x
W
 
2
2k + ( )  4
3k
( )
0
1 
( )  
x
W 
4
3 
Therefore, 
X( )  = x( )  + x( )  + x( )2 + x( )  1 2
3
4
10
0
0
1 
3 = +
+
+
 = 
0 
x W  x
W
 
2 
( )
X( )1 = x( )  + ( )1 
4
1 + ( )  4
2 + x
W
3 
4
3 
( )  −2
4
 x
e 
2 
4
4
3 
p /
= x( )  + x
e
 
1 
j p / + ( )  −j4p / + x
e−j6
4
0 
( )  
= +
1
2
 j 
3 1
(
)
 ( )  
2 j
−
+
 −
+
 
4 j = −+ 2
( )(
)
 
X( )  = x( )
0 + ( )  4
2 + x
W
2 
4
4 
4
6
x W  
( )  
+ x
W
3
2
1 
( )  
( )  −4
4
 x
e 
2 
8
4
3 
p /4
= x( )  + x
e
 
1 
j p / + ( )  −j8p / + x
e−j12
0 
( )  
1
2
( )(
)
 
−
+
+
+
 −
=
1
3(
)
 
1
= +  
1
4(
)
 −2 
x W 3 
( )  4
6 
x
W 9
X( )3 = x( )
0 + ( )1 
4 + x
W
2 
+ ( )  4
3 
( )  j p / 
x
e 
2 −j1 p /4 
3 −18
4
= x( )  + x
e
 
1 −6
4
 + ( )  12 
+ x
e
j
p /
0 
( )  
1
2
( )( )  
j 
3 1
(
)
 (
)
 2
= +  
+
−
+
−
= −− 
4 j
j2 
(b) Two-sided amplitude spectrum 
The two-sided amplitude spectrum is given by 
1 
1
2 
2 
Ak = 
X k( )  
(Real[X k ]) + (Imag[X k ])
= 
( )  
( )
N 
N 
Therefore (Figure 7.1), 
10
1 
2
2 
0 
10 
( )  
2 5
A = 
(
)
 + 0 
=
= . 
4 
4 
8
A1 = 1 
−2 2 + ( )2 =
= 0.7071
(
)
 2 
4 
4 

117 
Discrete Fourier Transform 
3 
2 
1 
0
1
2 
3 
FIGURE 7.1 Amplitude spectrum of Example 7.2 part b. 
3 
2 
1 
0
1 
2 
3 
FIGURE 7.2 Amplitude spectrum of Example 7.2 part c. 
2
A2 = 1 
−2 2 + 0 2 =
= .
(
)
( )  
0 5
4 
4 
A3 = 1 
−2 2
(
)2 = 
8 = 0.7071
(
)
 + −2 
4 
4 
(c) One-sided amplitude spectrum 
The one-sided amplitude spectrum is given by 
1 X k( )  
k = 0
⎪ 

 
=
N
Ak 
2 X k( )  k = 1 2
, ,
N
…,
/ 2 
N 
N 
4
Now, 
=
= 2Therefore (Figure 7.2),
2
2 
A0 = 2 5
. 
A1 =
×
2
0
 
7071 
. 
= 1.4141
A2 
2
0.5
1
= .0
=
×
 
It is observed that since the sequence x(n) did not have any symmetry with the origin, the DFT, X(k) 
contained complex values even though x(n) is real. In the case of Y(k), having even symmetry, for 
the origin, both Y(k) and y(n) are real. 
7.3 PROPERTIES OF DISCRETE FOURIER TRANSFORM 
1) Periodicity 
This property states that if a discrete-time signal is periodic, then its DFT will also be 
periodic. Also, if a signal or sequence repeats its waveform after several N samples, 
then it is called a periodic signal or sequence and N is called the period of the signal. 
Mathematically, 

118 
Digital Signal Processing 
if X(k) is an N-point DFT of x(n), then we have 
x n + N) = ( )  for all values of n
( 
x n 
(7.37) 
X k  N
( + ) = X k
( )  for all values of k 
2) Linearity 
The linearity property states that if X1(k) and X2(k) are the N-points DFT of x1(n) and 
x2(n) respectively, a and b are arbitrary constants either real or complex-valued, then we 
have 
ax n + bx n
( )  ⇔ 
1( )  + X k
1( )  
2 
aX k 
b
2( )
(7.38) 
3) Convolution 
If x1(n) X1(k) and x2(n) X2(n) 
Then, 
N −1 
∑x n  x n
⋅ ( )  ↔ X k ⋅ X k
1( )  2 
1( )  2( )
(7.39) 
m=0 
Example 7.3 
Find the DFT values for the sample data sequence x n = [ , , , ,  , ]
( )  11 2 2 3 3  and determine the corre-
sponding amplitude and phase spectrum. 
SOLUTION 
It is known that the N-point DFT of a finite sequence x(n) is defined as 
N−1 
− 
p k N
X k( )  =∑x n e 
k = , ,  ,N
( )  j2 n / 
0 1… 
− 1
n=0 
5 
( )  
( )  j nk
p 
/3
We have N = 6, then X k  =∑x n e 
So, 
n=0 
5 
X( )  =∑x n e
0 
( )
0 
n=0 
= x( )  + x( )  + x( )  + x( )  + x( )  + x( )
0
1
2
3 
4 
5 
= + +
+
+
+
1 1 2 2
3
3
 
= 12 
5 
1 
( )  −j n/
p 
3
X( )  =∑x n e  
n=0 
x( )  + x
e
1 −jp /3 + x 2 e−j2p /3 + x( )e−jp + ( )
4 
−j4
3
p / 
x
e−j5
3
( )
( )  
3 
x
e
 
+ 5 
p /
= 
0 
( )  
( )  −jp /3 
( )  −j2p /3 
( )  −jp 
(3 
−j p / 
( )e− 
p /
= +  e 
+ 2 e 
+ 2 e 
+ )e 
4
3
 + 
j5
3
1
1
 
3 
1
0 5 −j0 866 
. 
) 
(
.
 −j0 866 )
2 1  (
.
 + j0 866 ) + 3 0 5 
( .  + j0 866
( .  
2 0 5 
. 
+
−
+
(
)
 3 0 5
− 
.
.
= +  
+
− 
3
) 
= −1 5  + j2 598
.
. 

119 
Discrete Fourier Transform 
5 
X( )  =∑x n e−j2pn/3
2 
( )  
n=0 
x( ) + x
e
1 
j p / + x 2 e−j4
3
 + x( )e−j2 + ( )  −j8p /3 + 5 −j10
3
= 
0 
−2
3
 
p / 
p 
( )  
p /
( )
( )  
3 
x
e
4 
x
e
 
= +  
−j2
3
( )  −j p /
2 e− j2 
( )  −j8p /3 
3 e−j10
3
1
1( )e 
p / + 2 e 
4
3
 + ( )  
p + 3 e 
+ ( )  
p / 
= + −0 5 −j0 866 ) 2 0 5+ j0 866 ) + ( ) +
−. −j0 866 ) +
−. + j0 866 )
1 (
.
 
. 
+
−
 
. 
21
3 0 5 
( 
. 
(
(
.
 
3 0 5 
. 
. + j .
= −1 5  0 866 
5 
X( )  =∑x n e−j2pn
3 
( )  
n=0 
= x( ) + x
e
1 −jp + x( )e−j2p + x 3 e−j3p + x( ) e−j4p +
−j5p
0
( )
2 
( )  
4 
x(5)e 
−jp 
2 e−j2p 
( )  −j3p 
3 e−j4p + ( )e−j5p
= +
1
1( )e 
+ ( )  
+ 2 e 
+ ( )  
3 
= −+
1 1  21( ) + −
+ 31( )
2 1  
+
−
(
)
(
)
 
3 1  
5 
X( )  =∑x n e−j4pn/3
4 
( )  
n=0 
= 
0 
( )  
4
3
 ( )  
p /
3 
x
e
4 
p / 
( )  20p /3
x( ) + x
e
1 −j p / + x 2 e−j8
3
 + x( )e−j4p + ( )  −j16
3
 + 5 −j
x
e
 
( )  
p / 
8
3
 
p 
( )  −j20p /3
= +
1
1e−j4
3
 + ( )2 e−j p / + ( )2 e −j4p + ( )3 e−j16
3
 
/ + 3 e 
(
.
 + j0 866 ) +
−
 −j . 6 ) + 21 
(
. + j0 866 ) 
( 
. −j0 866 )
1 
(
.
 
+
− 
3 0 5
= + −0 5 
. 
2 0 5 
0 8 
( ) 3 0 5 
. 
+
−
 
. 
= −1 5 −j0 866
.
. 
5 
5 
( )  −j5pn/3 
X( )  =∑x n e  
n=0 
( )  −j p / 
( )  −j10p /3 
3 − j5 
x
e
( )  −j20
3
 
5 −j25p /
= x( )
0 + x
e
1 
5
3
 + x 2 e 
+ x( )e 
p + 4 
p / + x
e
( )  
3 
= +
1
1e−j5
3
p / + ( )2 e−j10p /3 + (2)e−j5p + ( ) 
3 e−j 
p / + 3 e−j25
( )  
20
3
 ( ) 
p /3 
1
0 5+ j0 866 ) 
(
.
 + j0.8
) 
(
) 
(
. −j0 866 ) + ( . −j0 866
( .  
. 
2 0 5 
866 +
−
+
−
2 1
3 0 5 
. 
3 0 5
= +  
+
− 
.
) 
= −1 5 −j2 598
.
. 
Hence, 
X k  = 12 − . + j . 
− . + j .
0 
− . − j0 866 − 1 5 − j2 598
( )   
1 5
2 598 
1 5
0 866 
1 5 
. 
. 
. 
 
The corresponding amplitude spectrum is found as 
X k( )  [
, , .  , , . 
, ]
= 12 3 1  732 0 1  732 3 
and the corresponding phase spectrum is 
∠X k = [ ° 
° 
°
° −150° −120°
( )  0 120 150 0 
]
Example 7.4 
Evaluate the DFT of the sequence X[n] = [1,0,0,1], n ≥0. 

120 
Digital Signal Processing 
SOLUTION 
N = 4 (k = 0 → 4−1 = 3) 
X k  =∑ 
3 
x n e 
− jk2
4 
p n 
[ ]  
( )  
n=0 
X[ ] = x 0 + x[ ]+ x 2 + [ ] = 2
0 
[ ]  
1
[ ]  x 3 
j2pp
− 
X[ ]1 =
+
1 e 
2
1 j
=
+
X[ ] = 0
2
X[ ]
1
j
1 =
−
Example 7.5 
Find the circular convolution between x1(n) = [1,1,2,2] and x2(n) = [1,2,3,4] using DFT and IDFT. 
SOLUTION 
For x1(n) = [1, 1, 2, 2], we have 
N−1 
1( )  
1( )  − j
n
p k N
2
/
X k =∑x n e
n=0 
Here, N = 4, therefore, we have 
3 
X k
1( )  =∑x n e
1( )  − j n
p k /2 
n=0 
So, when 
3 
k =
⇒
0 
X1( )  =∑x n e
1
0 
( )
0 
n=0 
x 0 + x 1 + x 2 + x( )
= ( )
( )
( )  
3 
= + +
+
=
2
2
 6
1 1  
when 
3 
p 
2
k =
⇒
1 
X ( )1 =∑x n e
( )  −j n/
1
1 
n=0 
= 
1( )  
1 
−jp /2 
1( )  −jp 
1 3 −j3
2
x 0 + x ( )1e 
+ x 2 e 
+ x ( )e 
p / 
1
1( )e−jp /2 + ( )2 e−jp + ( )e−j3p /2
= +  
2 
1
0
( 
j)
2 1  ) +
j)
= +  −
+
−−
( 
j0
( 
1
2 0  + 
= −
j 
when 
3 
2 
( )  −j n
p
k =
⇒
2 
X1( )  =∑x n e
1 
n=0 
= 
1( )  
1 
−jp 
1( )  −j2p 
1 3 −j3p
x 0 + x ( )1e 
+ x 2 e 
+ x ( )e 
= + ( )e−jp + 2 e−j2p + ( )  −j3p
1
1
( )  
2 e 
( 1 j0) + ( −j ) 2 1  j0) =
= + −−
1 
21
0
 
+
−−
(
0 

121 
Discrete Fourier Transform 
when 
3 
3
2
3 
( )  −j
n
p /
k =
⇒
3 
X1( ) =∑x n e
1 
n=0 
x 0 + x 
e 
j3
2
p / + x 2 e−j3p + x 3 −j p / 
= 
1( )  
1( )1
− 
1( )  
1( )e
9
2
( )
−j3
2
p / 
( )
−j3 
( )
−j p /
= +
1
1e 
+ 2 e 
p + 2 e
9
2 
= +  +
+
)
2 −1
0) + ( 
j)
1
1
0
 j 
(−−j 
2 0 − 
= −−
( 
j 
So, X k = 6
1
 0
1
 j]
1( )  [ ,−+ j, ,−− 
3 
For x n = 1 2 3 4
e h v
( ) =∑x n e
2( )
2( )  [ , , , ], w
a
2 
− j n
p k /2
e X k  
So, when 
n=0 
3 
k =
⇒
0 
X2( ) =∑x n e
2( )
0
0 
n=0 
= 
2( )  
2( )  
2( )  
2 3
x 0 + x 1 + x 2 + x ( )
= +
+
+
 =
1 2
3
4
 10 
when 
3 
p 
2
k =
⇒
1 
X ( )1 =∑x n e
( )  −j n/
2
2 
n=0 
x2 0 + x2 1e−jp /2 + x2 2 e−jp + x2(3 e−j3
2
= 
( )
( )  
( )  
( )  
p / 
1
2
( )e−jp /2 + ( )3 e−jp + ( )e−j3p /2
= +  
4 
( 
)
( 
j 
(
)
2
2
= +
1 2 0 −j +
−−
3
1
0) + 4 0 + j = −+ j 
when 
3 
p
2 
( )  ∑x n
k =
⇒X2 2 = 
2( )e−j n  
n=0 
= 
2( )  
2 
−jp 
2( )
−j2p 
2 3 −j3p
x 0 + x ( )1e 
+ x 2 e 
+ x ( )e 
= + ( )e−jp + 3 e−j2p + ( )
−j3p
1
2
( )  
4 e 
( 
j ) + 31−j0) 
( 
− j0) = −2
= +  −− 
( 
+
−
1 2 1
0
 
4
1 
when 
3 
3 
( )  
x n
−j
n
p /
3
2
k =
⇒X2 3 =∑
2( )e 
n=0 
= x2 0 + x2 1e
j3
2
p / + x2 2 e−j3 
x2 3 −j p /
( )  
( )
− 
( )  
p + 
( )e
9
2
= +
1
2 e−j3
2 + 3 e−j3p + 4 e−j9p /
( )  
p /
( )
( )  
2 
1 2 0 
j) 
( 1
0
 ( − 
= −−j
= + ( +
+ 3 −−j ) + 4 0  j) 
2
2 
So, 
X k
2 
= 10 2 j ,
,
 
j2 
( )  [
,−+ 2
2
2
− −− ]

122 
Digital Signal Processing 
Then 
X k = X k  X k( )  
3( )  
1( )⋅ 
2 
60 −+ 
), ,(−− 
2
= [
,( 1 j)(−2+ j2 0  1 j)(−2− j )]
−4j
= [
,
60 4 0 4
, ,  j] 
w th t x n  
}
We kno
a
3( ) = IDFT{X k
3( )
3 
p 
2
x n
3( ) = 1∑X k e
3( )  j nk / 
n = 0 1 2 3
4 
, , , 
m=0 
3 p /2
= 1 ⎡60 − j e
4 jnp /2 + j e
4 j n  
4 
when 
1 
n =
⇒x3( )
0 =

− 
+ j4
0 
60 
j4 
= 15 
4 
when 
n =
⇒x3 1 = 4
1 
60 −4 jp /2 + j e j3p /2 

1 
( )  

j e  
4 

1 
= 
60 −j
j
 j
4( ) + 4 −j 
(
)
4 
= 1 60 4
4] = 17
[
+
+
4 
when 
n =
⇒x3 2 = 4
1 
60 −4 jp + j e j3p 
 
2 
( )  

j e  
4 

1 
= 
60 
−
−j4
1
(
)
−
+ j4
1
(
)
4 
1 
= 
60 + j4 −j4= 15 
4 
when 
n =
⇒x 3 = 4
1 60 −4 j3
2
 + j e j p / 
3 
3( )  
j e
p / 
4
9
2
1
− 
−
+
j4(
)j 
j
j 
=
60 
4( )
4 
= 1[60 −4
4] = 13 
4 
Therefore, x n = 15 17 15 13
,
,
 ]. 
3( )  [
,
 
7.4 DISCRETE FOURIER TRANSFORM OF A SEQUENCE IN MATLAB 
To find the Discrete Fourier Transform of a sequence use the below. 
clc; 
clear all; 
close all; 
M=input('Enter the sequence :'); 

Discrete Fourier Transform 
123 
N=length(M); 
for k=1:N 
y(k)=0; 
for i=1:N 
y(k)=y(k)+M(i)*exp((-2*pi*j/N)*((i-1)*(k-1))); 
end; 
end; 
k=1:N 
disp('The result is:');y 
figure(1); 
subplot(211); 
stem(k,abs(y(k))); 
grid; 
xlabel('n'); 
ylabel('Amplitudes'); 
title('Magnitude response'); 
subplot(212); 
stem(angle(y(k))*180/pi); 
grid; 
xlabel('n'); 
ylabel('phase'); 
title('Phase response'); 
Enter the sequence :[2 −1 −2 4] 
k = 1 2 3 4 
The result is: 
y = [3.0000 + 0.0000i 4.0000 + 5.0000i – 3.0000 – 0.0000i] 
Figure 7.3 shows an amplitude and phase spectrum using DFT of a sequence in MATLAB. 
7.5 LINEAR CONVOLUTION USING THE DFT 
The DFT provides a convenient way to perform convolutions without having to evaluate the con-
volution sum. Specifically, if h(n) is N1 points long, and x(n) is N2 points long, h(n) may be linearly 
convolved with x(n) as follows: 
1. Pad the sequences h(n) and x(n) with zeros so that they are of the length N ≥N1 + N2 – 1. 
2. Find the N-point DFTs of h(n) and x(n). 
Mangnitude response 
0 
5 
10
Amplitudes 
1 
1.5 
2 
2.5
 3 
3.5 
4 
n 
Phase response 
–200 
0 
200 
phase 
1 
1.5
 2 
2.5
 3 
3.5 
4 
n 
FIGURE 7.3 Amplitude and phase spectrum using DFT of a sequence in MATLAB. 

124 
Digital Signal Processing 
3. Multiply the DFTs to form the product Y(k) = H(k) X(k). 
4. Find the inverse DFT of Y(k). 
7.6 GENERATION OF INVERSE DISCRETE FOURIER TRANSFORM IN MATLAB 
To find the Inverse Discrete Fourier Transform of a sequence use the below. 
clc; 
clear all; 
close all; 
M=input('Enter the sequence :'); 
N=length(M); 
for n=1:N 
y(n)=0; 
for k=1:N 
y(n)=y(n)+M(k)*exp((2*pi*j*(k-1)*(n-1))/N); 
end; 
end; 
n=1:N 
x=1/N*y(n) 
figure(1); 
stem(n,x); 
grid; 
xlabel('n'); 
ylabel('Amplitudes'); 
title('Mangnitude response'); 
Enter the sequence: [1 −2 −3 4] 
n = 1 2 3 4 
x = [0.0000 + 0.0000i 1.0000 – 1.5000i –1.0000 + 0.0000i 1.0000 + 1.5000i] 
Figure 7.4 shows an amplitude spectrum using IDFT of a sequence in MATLAB. 
Example 7.6 
Evaluate the IDFT of the sequence X[k] = [2,1 + j,0,1 – j] 
N−1 
jk2ppn 
x n  = 
X k e
( )
[ ]  1 ∑ 
N 
N k =0 
Mangnitude response 
–1 
–0.5 
0 
0.5 
1 
1.5 
Amplitude 
0 
0.5 
1 
1.5 
2 
2.5 
3 
3.5 
4 
n 
FIGURE 7.4 Amplitude spectrum using IDFT of a sequence in MATLAB. 

Discrete Fourier Transform 
125 
1
3 
jk2ppn 
x n  = ∑X k e 
4
[ ]  
( )
4 k =0 
2 0  
x 0 = 1∑ 
3 
X k e
( )  
jk p 
[ ]  
4 
= 1
4 k =0 
3 
jk2 1  
x[ ] = 4
1∑X k e  4 
p 
= 0
1 
( )  
k =0 
2 2  
x 2 = 4
1∑ 
3 
X k e
( )  
jk p 
[ ]  
4 
= 0 
k =0 
1
3 
jk2 3  
x 3 = 4∑X k e
( )  4 
p 
[ ]  
= 1
k =0 
So x[n]=[1 0 0 1] 
Example 7.7 
Given a discrete-time sequence x(n) = [1 2 3 4 5], use the MATLAB program to estimate the tone 
frequency using DFT. 
SOLUTION 
clc; 
clear all; 
N=5; 
x=[1 2 3 4 5]; 
subplot(2,1,1); 
Y=abs(fft(x)) 
stem([0:N-1],abs(fft(x))); 
xlabel('k'); 
ylabel('amplitude'); 
title('Magnitude Response'); 
grid 
subplot(2,1,2); 
stem([0:N-1],angle(fft(x))); 
xlabel('k'); 
ylabel('amplitude'); 
title('Phase Response'); 
grid 
Y = [15.0000 4.2533 2.6287 2.6287 4.2533] 
Figure 7.5 shows an amplitude and phase spectrum using DFT for Example 7.7. 
PROBLEMS 
7.1 
Find the DFT of the sequence x(n)=[1,1,1,1]. 
7.2 
Find the IDFT of the sequence x(n)=[1,1,1,1]. 

126 
Digital Signal Processing 
Magnitude Response 
–0.5
0
0.5
1 
1.5 
2
2.5
3 
3.5 
4
4.5 
k 
Phase Response 
–0.5
0
0.5
 1 
1.5 
2 
2.5 
3 
3.5
 4 
4.5 
k 
FIGURE 7.5 Amplitude and phase spectrum using DFT of Example 7.7. 
7.3 
Given a sequence x(n) for 0 ≤
≤3, where 
n 
x 0 = 4,
( )
 
x 1 = , 
( ) = 2 x
( )  
3 x 
3 =
2 
,
( ) 1 
a. Evaluate its DFT, i.e., X(k). 
b. Evaluate and sketch the resulting two-sided amplitude spectrum, i.e., Ak. 
c. Evaluate and draw the resulting one-sided amplitude spectrum, i.e., Ak. 
7.4 
Given a sequence x(n) for 0 ≤
≤3, where 
n 
x( )  = 1 x 1 = −
 
, x( )  = −
 
1 x
,
( )
 1
2 
,
( ) = 1
0 
3 
a. Evaluate its DFT, i.e., X(k). 
b. Evaluate and sketch the resulting two-sided amplitude spectrum, i.e., Ak. 
c. Evaluate and draw the resulting one-sided amplitude spectrum, i.e., Ak. 
7.5 Find the DFT values for the sample data sequence x(n)=[1,–1,2,–2,3,–3] and determine the 
corresponding amplitude and phase spectrum. 
7.6 
Find the DFT values for the sample data sequence x(n)=[1,–1,1,–1,1,–1] and determine the 
corresponding amplitude and phase spectrum. 
7.7 
Evaluate the DFT of the sequence X[n]=[–1,0,0,1], n ≥1. 
7.8 
Find the circular convolution between x1(n)=[1,–1,–2,2] and x2(n)=[1,2,3,4] using DFT and 
IDFT. 
7.9 
Find the circular convolution between x1(n)=[1,1,–2,–2] and x2(n)= [1,2,3,4] using DFT and 
IDFT. 
7.10 Given a sequence x(n) for 0 ≤n ≤3, where x(0) =1, x(1) =2, x(2) =3, and x(3) =4, calculate 
DFT X(k) 
7.11 Given a sequence x(n) for 0 ≤n ≤3, where x(0)=1, x(1) =1, x(2) =–1, and x(3) =0, calculate 
DFT X(k) 
7.12 Write a program to find the DFT of h(n) and x(n). Then, perform the linear convolution of the 
two sequences below in the time domain. Compare with the result obtained by using the DFT 
relations. 
0 
5 
10 
15
amplitude 
–5 
0 
5
amplitude 

127 
Discrete Fourier Transform 
 
n 
0 
0 
otherwise 
= 
1
1
=
n 
0 5. 
for 
1 
0 5. 
for n 1
= 

for n 
0
= 
 
 
 
h n
( ) = 
for 
and x n
( ) = 
 0 
otherwise 
7.13 A signal has the following signal values x(n)= [1,2,0,3], estimate the real and imaginary parts 
using: 
I-
DFT. 
II- DFS. 
III- DTFT. 
Write a MATLAB program to find the DFT and IDFT convolution of h(n) and x(n) by 
using the matrix method. 
h n  = sin (n*
/ 4)*
(
 )
u n − u n 
n−1
( )  
p 
( − 4 ]
[ 
) *2 
x n  = 
(n*
/ 4)*
(
 − ) − u n
( )  cos 
p 
[u n 1
( − 5)]
7.14 Let x(n) be the sequence: 
x n  = 2d n 
d(n 2) d(n
( )  
( )  + 
−
+
 −4)
The five-point DFT of x(n) is computed, and the resulting sequence is squared: 
Y k  = X k
( )  
2( )
A five-point inverse DFT is then computed to produce the sequence y(n). Write a program 
to find the sequence y(n). 
7.15 Consider a digital sequence sampled at the rate of 20,000 Hz. If we use the 8,000-point DFT 
to compute the spectrum, determine: 
a. The frequency resolution. 
b. The folding frequency in the spectrum. 
7.16 Use the DFT to compute the amplitude spectrum of a sampled data sequence with a sampling 
rate fs =2,000 Hz. It requires the frequency resolution to be less than 0.5 Hz. Determine the 
number of data points used by the FFT algorithm and actual frequency resolution in Hz, if 
the data samples are available for selecting the number of data points. 


8 Fast Fourier Transform (FFT) 
FFT is a very efficient method for computing the DFT coefficients. It reduces the number of com-
plex multiplications from N2 in case of DFT to simply (N /
log
) 
2 N
2 
(
) In the case of FFT. The only 
restriction on the algorithm is that the sequence x(ne) should consist of 2m Samples, where m is a 
positive integer – in other words, the number N of samples in the sequence should be a power of 2, 
i.e., N = 2, 4, 8, 16, … etc. If x(n) does not contain 2m samples, then we append it with zeros until the 
number of samples in the resulting sequence becomes a power of 2. 
There are several ways in which the FFT could). We shall study radix-2 FFT algorithms, 
namely, 
• Decimation-in-Frequency method. 
• Decimation-in-Time method. 
Other types include radix-4 and split-radix methods. 
8.1 FAST FOURIER TRANSFORM DEFINITION 
The Fast Fourier Transform (FFT) is defined as an algorithm which efficiently computes the 
Discrete Fourier Transform (DFT). It is worth mentioning that FFT gives the correct results of 
DFT values, not an approximation. It is a DFT with a reduced number of necessary arithmetic 
operations. Table 8.1 shows the principle truth table as a base to build up the FFT algorithm where 
the binary number represent the input to the FFT and the reversed binary represent the output of 
the FFT. 
8.1.1 Decimation-in-time FFt 
The shuffling of the input sequence that takes place is due to the successive decimations of x(n). A 
complete eight-point decimation-in-time FFT is shown in Figure 8.1. The ordering that the results 
correspond to are a bit-reversed indexing of the original sequence. In other words, if the index n 
was written in binary form, the order in which in the input sequence must be accessed is found 
by reading the binary representation for n in reverse order as illustrated in the Table 8.1 for N = 8. 
Finally, note that the input sequence x(n) is in bit-reversed order, and the frequency samples X(k) are 
in normal order. 
8.1.2 Decimation-in-Frequency FFt 
Another class of FFT algorithms is the decimation-in-frequency. A complete eight-point decima-
tion-in-frequency FFT is shown in Figure 8.2. The complexity of the decimation-in-frequency FFT 
is the same as the decimation-in-time, and the computations performed in place. Finally, note that 
the input sequence x(n) is in normal order, and the frequency samples X(k) are in bit-reversed order 
(Figure 8.2). 
129 

130 
Digital Signal Processing 
TABLE 8.1 
FFT Algorithm Truth Table 
n 
Binary 
Bit-reversed binary 
n′ 
0 
000 
000 
0 
1 
001 
100 
4 
2 
010 
010 
2 
3 
011 
110 
6 
4 
100 
001 
1 
5 
101 
101 
5 
6 
110 
011 
3 
7 
111 
111 
7 
Example 8.1 
0 = 0
 
3535
= .
= 0
 
6464
Find the decimation-in-time FFT for the data sequence x( )
. 
, x( )1
0
 
3535, x( )2
. 
, 
3 = 1
 
0607
= 0
 
3535
= −1
 
0607
= −1
 
3535
.
x( )
. 
, x( )
4
. 
, x( )5 
.
, x( )
6 
.
, x( )
7 = −0
 
3535. 
SOLUTION 
By applying the input values, the output of the second stage will be 
A 0 =
. 
+ W4
0(−.
) =
.
( 
j )(−.
) = 0 + j
( )  0 707 
0 707 
0 707 +
+
 
0 707 
1
0
 
0 
A 1
0
 W ( . 
)
0
( 
j )( . 
)
0 
j
( )  =
+
 1 1 999 
0 
1 1 999 =
− 1.999
4 
=
+
 −
 
A 2 = . 
+ W 2(−.
) = . 
( 1
0)(−.
) = . 
+ j0
( )  0 707 
4 
0 707 
0 707 + −+
 
j 
0 707 
1 414 
A 3
0 W4 ( . 
)
0
( 
j )( . 
)
0 
j
( )  =
+
 3 1 999 
0 
1 1 999 =
+ 1.999
=
+
 +
 
B 0 = − . 
+ W4
0( . 
) = −
 
. 
+ ( + j )( . 
) = 0 + j
( )  
0 707 
0 707 
0 707 
1
0
 
0 707 
0 
B 
= . 
+ W4
1( . 
) = . 
+ (0 − j )( . 
) = . 
− j
( )1
1 414 
1 414 
1 414 
1 1 414 
1 414 
1.414 
FIGURE 8.1 Eight-point decimation-in-time FFT. 

131 
Fast Fourier Transform (FFT) 
FIGURE 8.2 Eight-point decimation-in-frequency FFT. 
B 2 = − . 
+ W 2( . 
) = − .
( 
j )( . 
) = − . 
+ j
( )  
0 707 
4 0 707 
0 707 + −+  
1 414
1
0
 
0 707 
0 
B 3 = . 
+ W4
3( . 
) = . 
+ (0 + j )( . 
) = . 
+ j
( )  1 414 
1 414 
1 414 
1 1 414 
1 414 
1.414 
Calculate the outputs of the third stage of the FFT to arrive at the final answer 
X( )  = A 0 + 
0 ( )  0 
j 
( 
j )( + j0) 
0 
j0
0
 j0
0
 
( )  W B 0 =
+
 +
−0 0  
=
+
+
+ 
=
∠0
0 
8
0
1
 
( )  W B 1
0
 1 999 
0 707 
0 707 1 414 
. 
)
X( )1 = A 1 +
8
1 ( )  =
−j . 
+ ( . 
−j . 
)( . 
−j1 414 
1 999 +
−j .
=
−
0 
j . 
0 
1 999 =
−
 =
∠
0 
j4
4 −90 
X( )  = A 2 + 
8
2 ( )  = . 
j0 (0 
j )(−. 
+ j
2 
( )  W B 2 
1 414 + 
+
−1
1
 
414 
0) 
= . 
1 
1 414 j . 
2 45
1 414 + 
+
+
j0
0
 j .414 = . 
+ 1 414 =
∠
 
X( )  = A 3 +
8
3 ( )  0 
j . 
(
. 
−j . 
)( . 
+ j
( )  W B 3 =
+ 1 999 
0 707 
0 707 1 414 
. 
)
3 
+ − 
1 414 
=
+ 1 999 +
−1 999 
0 0
0 + j .
0 
j . 
=
∠ 
X( )  = A 0 +
8
4 ( )  0 
j0 ( 1+ j )( + j0) 
0 
j0
0
 j 

4 
( )  W B 0 =
+
 + −
0 0  
0
0 0
=
+
+
+
 =
∠
( )  W B 1
0
 1 999 + −0 707 
0 707 1 414 
. 
)
X( )5 = A 1 +
8
5 ( )  =
−j . 
(
. 
+ j . 
)( . 
−j1 414 
0 −j .
0 
j . 
=
−j0 =
∠

=
−1 999 +
+ 1 999 
0 
0 0  
6 
( )  W B 2 
1 414 + 
+
+ 1
1
 
414 
0)
X( )  = A 2 + 
8
6 ( )  = . 
j0 (0 
j )(−. 
+ j 
. 
+ 
+
−1. 
1 414 j 

= 1 414 j0
0
 j 414 = . 
−1 414 
. 
=
∠
2 −45 
X( )  = A 3 + 
7 ( )  0 
j . 
+ ( . 
+ j . 
)( . 
+ j
( )  W B 3 =
+ 1 999 
0 707 
0 707 1 414 
1 414 )
7 
8 
. 
=
+
0 
j . 
0 
1 999 
0 
j4
1 999 +
+ j . 
4 90
=
+
 =
∠
 
Figure 8.3 shows the eight-point decimation-in-time FFT. 

132 
Digital Signal Processing 
FIGURE 8.3 Eight-point decimation-in-time FFT of Example 8.1. 
Example 8.2 
Find the decimation-in-time FFT for the data sequence 
x n
( )  
. 
. 
.
= 0 5  
0
 0
 
5
 0 
0 5  
0 
.
0 5 
.
0 
SOLUTION 
Figure 8.4 shows the eight-point decimation-in-time FFT. 
FIGURE 8.4 Eight-point decimation-in-time FFT of Example 8.2. 

133 
Fast Fourier Transform (FFT) 
Example 8.3 
Given a sequence x(n) For 0 ≤
≤3, where x(0) = 1, x(1) = 2, x(2) = 3, and x(3) = 4: 
n 
a. Determine its DFT X(k) using the decimation-in-frequency FFT method? 
b. Determine the number of complex multiplications by doing part (a). 
SOLUTION 
(a) According to the FFT (decimation-in-frequency method) for calculating DFT of a given 
sequence 

DFT a n with
( )
 
N

points

2
DFT x n with N
( )
{
points} = 
T b n W
( )
 
N
n
 


DF
with 
points
N 
2 
− 2
where, WN
n = e
j 
n N
p / = cos 
 
2ppn
 + j sin 
 
2ppn
 
and 
N
N 
a n  = x n + x n + 
, for n = 0 1 2  …,
( )  ( )  
 
N 
2 

 
, , ,  N 
2 − 1
b n  = x n  − x n + 
, for n = 0 1 2 …,
( )  ( )  
 
N 
2 

 
, , ,  N 
2 − 1
The DFT of the given sequence, using FFT (decimation-in-frequency method) is given in 
the following Figures 8.5 and 8.6, respectively. 
Therefore, the DFT coefficients are 
X( )  = 10 ,
( ) 
2
2j X( )  = −2, and
0 
X 1 = −+  ,
2 
X( )
2
j. 
3 = − 
2 
N 
4 
(b) Number of complex multiplications in DFT = 
log (N) = 
4 =
log ( )  4. 
2 
2 
2
2 
FIGURE 8.5 Four-point decimation-in-time FFT. 
FIGURE 8.6 Four-point decimation-in-time FFT of Example 8.3. 

134 
Digital Signal Processing 
8.2 FINDING THE FFT OF DIFFERENT SIGNALS IN MATLAB 
To find the FFT of different signals like an impulse, step, ramp, and exponential. The FFT can 
generate these by using the command FFT for impulse, step, ramp, and exponential sequences. In 
the process of finding the FFT, the length of the FFT is taken as N. The FFT consists of two parts: 
magnitude plot and phase plot. The magnitude plot is the absolute value of magnitude versus the 
samples, and the phase plot is the phase angle versus the samples. 
clc; 
clear all; 
close all; 
t=-2:1:2; 
x=[zeros(1,2) 1 zeros(1,2)]; 
subplot (3,1,1); 
stem(t,x); 
grid; 
x=[0 0 1 0 0]; 
disp(x); 
title ('Impulse Response'); 
xlabel ('n'); 
ylabel ('Amplitude'); 
yn=x; 
N=30; 
xk=fft(yn,N); 
magxk=abs(xk); 
angxk=angle(xk); 
k=0:N-1; 
subplot(3,1,2); 
stem(k,magxk); 
grid; 
xlabel('k'); 
ylabel('|y(k)|'); 
subplot(3,1,3); 
stem(k,angxk); 
disp(xk); 
grid; 
xlabel('k'); 
ylabel('arg(y(k))'); 
Figure 8.7 shows the impulse FFT analysis signals using the MATLAB program. 
clc; 
clear all; 
close all; 
t=-2:1:2; 
x=[zeros(1,2) 1 ones(1,2)]; 
subplot (3,1,1); 
stem(t,x); 
grid; 
x=[0 0 1 1 1]; 
disp(x); 
title ('Impulse Response'); 
xlabel ('n'); 
ylabel ('Amplitude'); 
yn=x; 
N=30; 
xk=fft(yn,N); 

135 
Fast Fourier Transform (FFT) 
Impulse Response 
–2 
–1.5
–1 
–0.5 
0 
0.5 
1 
1.5 
2 
n 
0 
5 
10
15
20
25
30 
k 
5 
0 
5 
10
15
20
25
30 
k 
FIGURE 8.7 FFT of impulse sequence analysis signals in MATLAB. 
magxk=abs(xk); 
angxk=angle(xk); 
k=0:N-1; 
subplot(3,1,2); 
stem(k,magxk); 
grid; 
xlabel('k'); 
ylabel('|y(k)|'); 
subplot(3,1,3); 
stem(k,angxk); 
disp(xk); 
grid; 
xlabel('k'); 
ylabel('arg(y(k))'); 
Figure 8.8 shows the FFT of unit step sequence analysis signals in MATLAB. 
8.3 POWER SPECTRAL DENSITY USING SQUARE 
MAGNITUDE AND AUTOCORRELATION 
To compute the power spectral density of the given signals using square magnitude and 
autocorrelation. 
The stationary random processes do not have finite energy and later do not processes a Fourier 
Transform. Such signals have limited average power and hence are characterized by a power spec-
tral density (PSD). The following program uses the property of PSD that is calculated from its 
autocorrelation function by taking the time average. In the square magnitude method, after taking 
the FFT by taking the absolute value one can get the PSD. 
Program: 
clc; 
clear all; 
close all; 
f1=2000; %the frequency of first sequence in Hz 
0 
0.5 
1
Amplitude
0 
0.5 
1 
|y(k)| 
–5 
0
arg(y(k)) 

136 
4 
Digital Signal Processing 
Impulse Response 
0 
0.5 
1
Amplitude
–2 
–1.5
–1 
–0.5 
0 
0.5 
1 
1.5 
2 
n 
0 
2
|y(k)| 
0 
5 
10
15
20
25 
k 
5 
–5 
0
arg(y(k))
0 
5 
10
15
20
25
30 
k 
FIGURE 8.8 FFT of unit step sequence analysis signals in MATLAB. 
f2=4000; %the frequency of the second sequence in Hz 
fs=10000;%Enter the sampling frequency in Hz 
t=0:1/fs:1; 
x=2*sin(2*pi*f1*t)+3*sin(2*pi*f2*t)+rand(size(t)); 
px1=abs(fft(x).^2); 
px2=abs(fft(xcorr(x),length(t))); 
subplot(211) 
plot(t*fs,10*log10(px1));%square magnitude 
grid; 
xlabel('Frequency (Hz)'); 
ylabel('Magnitude(dB)'); 
title('PSD'); 
subplot(212) 
plot(t*fs,10*log10(px2));%autocorrelation 
grid; 
xlabel('Frequency (Hz)'); 
ylabel('Magnitude(dB)'); 
title('PSD'); 
Figure 8.9 shows an FFT power spectral density. 
8.3.1 EquivalEncE of ffT and N-phasE sEquEncE componEnT TransformaTion 
We have seen that N-point DFT is given by the following expression 
N −1 
− j2pnm 
N 
X m
( )  =∑x e
(8.1) 
n 
n=0 
j2p
Let a
e
= 
N  be the Nth root of the unit. Then the following relationships can be easily derived. 
30 

137 
Fast Fourier Transform (FFT) 
PSD 
100 
0 
1000 
2000 
3000 
4000 
5000 
6000 
7000 
8000 
9000 
10000 
Frequncy (Hz) 
PSD 
80 
0 
1000 
2000 
3000 
4000 
5000 
6000 
7000 
8000 
9000 
10000 
Frequncy (Hz) 
FIGURE 8.9 FFT Power spectral density. 
1) 1+
+
 2 + −−−−−+ aN −1 = 0
a
a
 
(8.2) 
Proof: using the geometric progression series formula 
x
x
+ r
x
+ r2 + −−−−+xr N −1 = x(1 −r N) 
(8.3)
(1 −r) 
2 
− 
1 1  −aN) 
1 1
N 1
( 
( − )
We 1+
+
 + −−−−+a 
= 
=
= 0
a
a
 
because aN = 1 
(1−a) 
(1 −a)
m
N − 
m
m
2) From a a
= 1 and a
a
= 1, we get
(
)* 
(
)* = a
am 
N −m 
(8.4) 
Hence a * = aN −1, (a2)* = aN −2 etc. 
(8.5) 
−1
*
3) From the fact that a a = 1 and a a = 1, we have 
−1
* 
N −1 
−2 
a * 2 
N −2 etc. 
(8.6)
a = a = a 
and a = (
)
 = a 
Now using the a-operator, DFT transformation m = 0, – – – –, N − 1 can be written as follows. 
X( )  = x0 + x1 + −−−−+xN −1
0 
x a−1 
1(a−1)N −1 
(8.7)
X( )1 = x0 + 1 
+ −−−+ xN − 
–50 
0 
50
Magnitude(dB) 
40 
60
Magnitude(dB) 
X N −
=
) 
x + x a−(N −1) + −−−−+xN − (a−1)(N −1)2 
(
1
0
1 
1 
Arranging it in a matrix format, we get the following 

X( )  
1
1 
−
−
 
1 
x0 
0 

X( )  
1 
a−1
(a−1)N −1 x1 
1 
 
 
 
= 

 
 
  
(8.8)
 
 


 

 
  
X N −)
 
−1 N −1 
−1)(N −1) xN −1 
(
1 
1 (a ) 
−
−
(a 
2 
 
 

 
 
 
 
 
 
 
 
 
 
138 
Digital Signal Processing 
or stated more compactly 
[ ]
X = [ ][ ]
P x 
(8.9) 
Where 
P i j = a−1)(i−1)( j−1)
( ,  )
(
 
(8.10) 
The ith row of the matrix P indexes the ith frequency component, while the jth column of the P− 
it is easy to verify that 
H
p p  0
(i
j
≠ ) 
(8.11)
i
j = 
H
p p  N 
(8.12)
i
i = 






 
pH = pT * = pi 
* T 
(8.13)
i 
(
)
i 
( )
i.e., each column is first transposed into a row, and every element is then replaced by its complex 
conjugate. 
For a real number, the complex conjugate is identical to the original number. Hence on real-
valued vectors, Hermitian and transpose operators are the same. However, for complex-valued vec-
h
matrix indexes the 
sample. The matrix − enjoys an exceptional property viz. it’s columns or
j
P
t
h
h
rows that are orthogonal to each other. If 
and  denote the 
and  column of the model , then,
i
j
P
t
t
p
p
i
j
Where 
indicates the Hermitian operator defined as
H
tors, the two differ. 
It is now easy to verify that 
− 
1 
1 
1 
− 
 
1
1 
1 





 
−
2 
1
N
− 
a
a 
a 
1 
H
H
and 
(8.14) 
P 
P 
P 
= 
= 
N 
1
−1)2
−1) 
2(
−
( 
1) 
(
N 
N 
N
− 
 
a 
a 
a 
Thus, 
[ ]
X = [ ][ ]
P x 
(8.15) 
[ ]
x = 
[P
X
1 
H][ ]
(8.16)
N 
The invertibility of P, in essence, captures the transform property of DFT. 
This effort is considered to be significantly high for real-time computing. However, with some 
ingenuity, researchers have shown that the task is achieved by approximate (N/2)log 2 N computa-
tions. This fast approach to computing all possible frequency transforms in the discrete domain 
is called the Fast Fourier Transform. For example, with N=8 brute force implementation of (1) 
requires 64 complex multiplications, which are reduced to 12 multiplications with FFT. As we 
would not have much use for FFT in this book, we will not pursue this topic any further. Rather, we 
will now establish an equivalence between two very well known transforms viz. multiple DFT or 
FFT and sequence component transformation. 
We will first review the N-phase sequence transformation. Consider an N-phase (balanced or 
unbalanced) system (N ≥3). Let the phasors in the phase domain (e.g., Va, Vb, Vc for the three-phase 

139 
Fast Fourier Transform (FFT) 
system) be represented by x x ……, x
,
,
. Then, these phasors can be expressed as a linear combina-
tion of an N-set of balanced N-phase systems as follows. 
1
2
N 
0-sequence component 
For n-phasor, the zero sequence system each of equal magnitude and angle 
x1 + x2 + −−−+ xN
X0 = 
(8.17)
N 
(+ve) 1-sequence component 
x1 + x a
x
2 + 3 a2 + −−−+ xN aN −1 
N 
(8.18)
X = 
1 
For -phasor, the positive sequence system. If 
is taken as a reference, then 
is equal in mag-
X
X
n
1,1
1,2
2p
( )
nitude to 
but by angle 
i.e., X
X
a
=
x1
1 2,
, 
(8.19)
X = 
2 
−2
−2
N
This system is obtained by relating lag in consecutive phases to the operator 
(or 
).
a
a
Figure 8.10(a, b, and c) shows the symmetrical components system for a three-phase system. 
Expressing these equations in a matrix format, we obtain the following equations: 
−
a
N −1 
1 1  
N
(–ve) 2-sequence component 
x1 + x a2 + x3 a4 + −−−+ x
a2 N −1 
2 
N (
)
 
N 






 
2 N −1
4 N −1
(N −1)2 
x + x
a 
+ 
(
)
 + −−−+ x a
XN −1 = 
1 
2 (
)
 
x3 a
N 
(8.20) 





 
N 
1 
1 
1 
− 
1
1 
1 
X
 
x1
0 





 
2 
1
N
− 
X 
a
a 
a 
x
1 
2
1 
2
4 
2( 
1)
N
− 
1 
|
| 
(8.21) 
| 
| 
a 
a 
a
= N 
| 
| 
2
−
−1)
( 
1) 
2( 
)
(
N 
N 
N

−
X 
1
1 
Thus, writing compactly 
X 
−1][ ]
[ ]  
= [P
x 
x
a 
a 
a
N 
N 
 
 
 


⎥


 





 





 
− 
− 
 
FIGURE 8.10 (a, b, and c) visualize the system for a three-phase system. 

140 
Digital Signal Processing 
or 
[ ]
x = [ ][ ]
P X 
(8.22) 
Where 
X = [X0,
,
X1 …, XN −1 ]
T 
(8.23) 
x = [x x
,
,…, x ]
T 
(8.24)
1
2
N 
Thus, we conclude that FFT and sequence transformation (defined from the sequence domain to the 
phase domain) involve the same transformation matrix P. Hence, the two transforms are mathemati-
cally equivalent. In particular for N = 3, with a-phase as the reference phasor, we see the following 
equivalence relationships. 
1 
1 
1 









1 
1




1 
Va

 
 V0 
1
1 


 


 


V2 


 
2 
(8.25) 
Vb 
V1 
= 
a 
a 
2
Vc 


 
a
a 
and from DFT, we get 
 Va 
( )
0 
1
1 
V 
V 
V 


 


 

⎥
 
2
( )1 
(8.26) 
Vb 
= 
a 
a 
2
( )
2 
Vc 


 
a
a 
This mathematical equivalence brings out an important concept viz. transformations and decompo-
sitions done via orthogonal matrices which can have multiple interpretations. However, there is one 
important difference between the two transformations. The samples x0, …, xN−1 in signal processing 
are real numbers while corresponding phasors in sequence analysis are complex numbers. Thus, 
while there is a redundancy in information in the DFT domain which leads to DFT symmetry, there 
is no such redundancy in the sequence domain. Hence, in the sequence domain, we do not come 
across such a property. 
PROBLEMS 
8.1 
Find the decimation-in-time FFT for the data sequence x(0) =0.5, x(1) =0.25, x(2) =–0.25, 
x(3) =–0.5, x(4) =–0.5, x(5) =–0.25, x(6) =0.25, x(7) =0.5. 
8.2 
Given eight samples values x(0), x(1),…,x(7)., draw a diagram to compute the DFT of the 
given sequence. 
a. Using the decimation-in-frequency FFT method. 
b. Using the decimation-in-time FFT method. 
8.3 
Compute the eight-point DFT of the sequence. 
1
0 
n
≤
≤3 
x n  
( )  = 
0 
otherwise 
a. Using the decimation-in-frequency FFT method. 
b. Using the decimation-in-time FFT method. 
8.4 
Compute the eight-point DFT of the sequence 
1
0 
n
≤
≤7 
x n  =  
.
( )  
0 
otherwise 

Fast Fourier Transform (FFT) 
141 
a. Using the decimation-in-frequency FFT method. 
b. Using the decimation-in-time FFT method. 
8.5 Compute the eight-point DFT of the sequence 
a 
0 
n
≤
≤3 
x n  =  
.
( )  
0 
otherwise 
Where a is a real number and constant. 
a. Using the decimation-in-frequency FFT method; and 
b. Using the decimation-in-time FFT method. 
8.6 
Compute the eight-point DFT of the sequence 
a 
0 
n
≤
≤3 
x n  
( )  = 
0 
otherwise 
Where a is a real number and constant. 
a. Using the decimation-in-frequency FFT method; and 
b. Using the decimation-in-time FFT method. 
8.7 
Compute the eight-point inverse DFT of the sequence made up of DFT coefficients X(k) as 
X( )
0 = 4 X 1 = 1− j(1
,
( ) 
+ 2 ), X( )
2 = 0,
(
X 3) = 1 − j(1 − 2 ), 
X( )
4 = 0 X 5 = 1+ j 1
,
( ) 
( − 
2 X 6 = 0 X 7 = 1+ j(
),
( ) 
,
( )  
1+ 2 ). 
a. Using the decimation-in-frequency FFT method. 
b. Using the decimation-in-time FFT method. 
8.8 
Compute the eight-point inverse DFT of the sequence made up of DFT coefficients X(k) as 
X( )  = .
,
 
X( )  = .
, X( )  = .
, X( )  = 0 25
0 
0 25 
1 
0 125 
2 
0 125 
3 
.
,
X( )  = .
, X( )  0 25 X( )  = 0 25 X( )  = 0 125
4 
0 125 
5 = 0.
,
6 
.
,
7 
. 
a. Using the decimation-in-frequency FFT method. 
b. Using the decimation-in-time FFT method. 
8.9 
Compute the eight-point DFT of the sequence 
x( )  = . ,  x( )  = . ,  x( )  = . ,  x( )  = 1 1
0 
1 1
1
 1 1
2 
1 1
3
 . ,
x( )  = 0 x 5 = , x( )  = , x
4 
, ( ) 0 
6 
0
( )  
7 = 0. 
a. Using the decimation-in-frequency FFT method. 
b. Using the decimation-in-time FFT method. 
8.10 Draw the eight-point DIT-FFT signal flow graph for the following sequence 
X n
( )  
. , . , . , . , , , ,  ]
= [0 5 0 5 0 5 0 5  0 0 0 0
8.11 Given a sequence x(n). For 0 ≤
≤3, where x(0)=4, x(1) =3, x(2) =2, and x(3) =1,
n 
a. Determine its DFT X(k) using the decimation-in-frequency FFT method. 
b. Determine the number of complex multiplication in doing part (a). 
8.12 Write a MATLAB program to find the autocorrelation of the following signal: 
g(t)= e-2t u(t), Then, use the Wiener–Khintchine theorem to determine the energy spectral  
density of the signal. 
Use this program to display the autocorrelation function and the energy spectral density. 


9 Z-Transform 
The z-transform is useful for the manipulation of discrete data sequence and has acquired a new 
significance in the formulation and analysis of discrete-time systems. It is used extensively today in 
the area of applied mathematics digital signal processing, control theory, population science, eco-
nomics. These discrete models are solved with difference equations in a manner that is analogous 
to solving continuous models with differential equations. The role played by the z-transform in the 
solution of difference equations corresponds to that represented by the Laplace transforms in the 
solution of differential equations. In this chapter the z-transform representation will present, also 
the Region of convergence (ROC), Properties of the z-Transform, and the Inverse z-Transform. 
9.1 Z-TRANSFORM REPRESENTATION 
In the previous chapters, we saw that the Discrete-Time Fourier Transform (DTFT) of sequence x(n) 
is equal to the sum: 
∞ 
X e jw ) = ∑x n e −jnw 
(9.1) 
( 
( )  
n=−∞ 
However, for this series to converge, it is necessary that the signal is summable. 
The z-transform is a generalization of the DTFT that allows one to deal with such sequences and 
is defined as follows: 
Definition: The z-transform of a discrete-time signal x(n) is characterized by: 
∞ 
X z( )  = ∑x n z −n
( )  
(9.2) 
n=−∞ 
In other words, the relation between X e jw ) and X ) is: 
(
(z
X e jw ) = X z
( 
( )  = jw 
(9.3) 
z e
where z = ejω is a complex variable. 
According to the fact that for most situations, the digital signal x(n) is the causal sequence, that 
is, x(n) = 0 for n < 0, then X(z) will be: 
∞ 
X z( )  =∑x n z −n
( )  
(9.4) 
n=0 
Thus, the definition in the above equation is referred to as a one-sided z-transform or a unilateral 
transform. 
Example 9.1 
Prove that the convolution in the time domain implies convolution in the z-domain, i.e., 
Z x n
x n
 
( ( )* 2( )  Z x n
Z x n
 
( 1( )  
2( )) = 
1( )  ( )
1 
) = 
)
(
 
X z X z 
2 
143 

144 
Digital Signal Processing 
SOLUTION 
According to the definition of the convolution, we have 
∞ 
x n
( ) = x n  x n  
* 
( ) =∑ ( − )
 
( )
( )  2 
x n  k x k 
2
1
1 
k =0 
Taking z-transform 

∞ 

∞
∞ 
 
X n
( ) = Z x n
x n
 
* 2( )) = Z  
x n  k x k
 
)
 
( )  
2 
=
 
x (n
k x k
z
)
( )
−n
( 1( )  
∑ 1( − 
∑∑ 1 n − 
2 
 
 k =0 
 
n=0  k =0 
 
It is written as 
∞
∞ 
X n =∑x k
( )z k ⋅∑x n
k)z 
−
−
n k
( )  
2 
− 
1( − 
(
)
k =0 
n=0 
Let n − k = m, and then the second summation can be written as 
∞
∞ 
X n =∑x k z −k ⋅∑x m z  
(
)
−m
( )
2( )  
1 
k =0 
m=−k 
Using causality of both sequences, the second summation can be started from m = 0 instead of 
m = −k. Therefore, using the definition of z-transform, we have 
X n = X n ⋅ X n
( )
( )  
1( )
2 
Hence, proved. 
9.2 REGION OF CONVERGENCE (ROC) 
In Equation (9.2), all the values of z that make the summation exist (the sum converged) form a region 
of convergence in the z-transform domain. The region of convergence is defined based on the particular 
sequence x(n) being applied. Note that we deal only with the unilateral z-transform, and hence when 
performing inverse z-transform (which we shall study later), we are restricted to the causal sequence. 
Example 9.2 
Given the sequence x(n) = u(n), find the z-transform of x(n). 
SOLUTION 
The z-transform is given by 
∞
∞ 
X z  =∑u n
( )z−n ∑
−1)
n 
( )  
=
(z 
n=0 
n=0 
It is an infinite geometric series that converges to 
z
X z
( )  = z − 1 
with a condition z−1 < 1. 
The region of convergence for all values of z is given as |z| > 1 

Z-Transform 
145 
Example 9.3 
Considering the exponential sequence x n  = a u n
-transform of the sequence x(n
( )  
n ( ), find the z
). 
SOLUTION 
From the definition of the z-transform, it follows that 
∞
∞ 
n 
−n 
−1 n 
X z  =∑a u n z
( )  
∑
)
( )  
=
(az 
n=0 
n=0 
This geometric series which will converge for az−1 < 1
z
X z  = 
,
( )  
for z > a 
z
a
− 
The z-transform for common sequences is summarized in Table 9.1. 
Example 9.4 
Find the z-transform for each of the following sequences x(n). 
a) x n
( )  = 2 5u n
.
( ) 
 pn
b) x n  
2
( )  = sin 4  
c) x n
( )  = ( . )
( ) 
0 8  n u n  
n 
 pn 
d) x n
( )  = 0 8  sin 
( )
( . ) 
u n
 4  
. n 
pn
−0 5  

e) x n  = e 
cos 
u n
( )
( )  
 4  
SOLUTION 
a) x n
( )  = 2 5u n
.
( ) 
From Table 9.1 
X z  = Z x n ] = Z 
.
( )
u n  = 2 5  z
z 
− 1
( )  
[ ( )  
2 5  
. 
 pn
b) x n  
2
( )  = sin 4  
From Table 9.1 
 p  
zsin 
X z  Z x n
[ ( )  Z 
2sin
 p 
4 
n 

 

 = 
z2 − 2zcos 

⎛
 
4 
p 
 
4 
n
 + 1
( )  = 
] = 
2 
c) x n
( )  = ( . )
( )
0 8  n u n  
n
X z  = Z x n 
Z ( . )
( ) 
0 8  u n  
z
( )  
[ ( )] = 
= z − .
0 8

146 
Digital Signal Processing 
TABLE 9.1 
Table of z-Transform Pairs (for Causal Sequences) 
No. 
Signal 
z-transform 
Region of Convergence 
x(n), n ≥0 
Z(x(n)) = X(z) 
∞ 
1 
x(n) 
∑x n z −n
( )  
n=0 
2 
δ(n) 
1 
Entire z-plane 
3 
au(n) 
az 
|z| > 1 
z − 1 
4 
nu(n) 
( 
z 
1)
|z| > 1 
z − 
2 
z z + 1
(
)
5 
n2 u(n)
|z| > 1
(z −1)
3 
6 
an u(n) 
z 
|z| > |a| 
z
a
− 
7 
e−na u(n) 
z 
|z| > e−a 
−
−a
z
e
az
8 
nan u(n)
|z| > |a|
(z
a)
2
− 
sin( ) 
9 
sin (an) u(n) 
z
a 
|z| > |1| 
z2 − 2zcos( ) 
a + 1 
( 
cos( ) )
10 
cos (an) u(n) 
z z − 
a 
|z| > |1| 
z2 − 2zcos( ) 
a + 1 
asin( ) 
b  z
11 
an sin (bn) u(n)
|z| > |a| 
z2 − 2acos( )  + a2
b
z
 
z z − acos( ) 
 
b 
12 
an cos (bn) u(n)
|z| > |a| 
z2
2acos( )  + a2
−  
b
z
 
e−a sin( ) 
b  z 
>
−a
z
e
z2 − 2e−a cos( )  + e−2a 
13 
e−an sin (bn) u(n) 
b
z
 
z z − e−a cos( ) 
 
b  
>
−a
z
e
z2 − 2e−a cos( )  + e−2a 
14 
e−an cos (bn) u(n) 
b
z
 
A P
n 
(nq
f u n 
Az + A z
cos 
+ ) ( )
* 
15 
2 
z
P
− 
z
P*
− 
where P and A are complex constants  
defined by 
P = P ∠q , A = A ∠f 

Z-Transform 
147 
d) x n
( ) = ( . )
0 8 n sin pn 
4 u n
( ) 
X z  = Z x n
 Z ( .
0 8) sin 
u n
( )  
[ ( )] = 

 
n 

 
pn
 ( )
 

4 

 p 
0 8z n
. 
si  4 
= 
z2 − 2 0 8 
* .  zcos
 pn 

 + 0 82 
. 
4 
e) x n  = e . ncos
 pn 

 ( )
( )  
−0 5  
u n  
4 
X z  = Z x n
 Z e . cos p  u n
( )
( )  
[ ( )] = 


−0 5n 

 4 
n 
 

 

−0 5  
 p  
z z − e 
cos
 
. 
 

4 
= 
2 
−0.5 
 pn
−0 5 2
.
z − 2* e
zcos 4  + (e 
) 
9.3 PROPERTIES OF THE Z-TRANSFORM 
In this section, we study some important properties of the z-transform these properties are widely 



used in driving the z-transform functions of difference equations and solving the system output 

 
responses of linear digital systems with constant system coefficients. 
For the following: 
n=∞ 
{ [ ]} ∑ 
−n = F z
Z
f n
 
= 
f n z  
[ ]  
( )
(9.5) 
n=0 
n=∞ 
Z g
{ } =∑g z−n = ( )
n 
n 
G z  
(9.6) 
n=0 
• Linearity 
Z afn + bg } = aF z( )  + bG z 
(9.7) 
{ 
n 
( ). 
and ROC is Rf ∩ Rg, 
which follows on from the definition of z-transform. 
• Time shifting 
If we have f n
[ ]  ⇔ F z  
( ), then 
f n − n0] ⇔ z−n0 F z
[ 
( )
(9.8) 
The ROC of Y(z) is the same as F(z) except that there are possible pole additions or dele-
tions at z = 0 or z = ∞. 
Proof: 
Let y n
[ ]  = f n
[ − n0], then 
∞ 
Y z  ∑f n  
0 
−n 
(9.9) 
( )  = 
n
z
[ − ] 
n=−∞ 

148 
Digital Signal Processing 
Assume k = n – n0, then n = k + n0, substituting in the above equation we have: 
∞ 
( )  
[ ]  k n  
−n
−−
Y z  = ∑f k z 
0 = z 
0 F z[ ]
(9.10) 
k=−∞ 
• Multiplication by an exponential sequence 
Let y n = z f n , then 
[ ]  
0 
n [ ]
 z 
Y z( )  = X 
(9.11) 
 z0  
The consequence is pole and zero locations that are scaled by z0. If the ROC of FX(z) is 
rR < |z| < rL, then the ROC of Y(z) is 
rR < z / z0 < r
 
i e  
, . ., z rR < z < z0 rL
L 
0 
Proof: 
∞ 
∞
−n 
n 
−n
Y z  = 
z x n z  = 
[ ]  
= X 
(9.12) 
( )  ∑ 0 [ ]  
∑x n 
 
z
z 

 

 
z
z 

 
n=−∞ 
n=−∞ 
0
0 
The consequence is pole and zero locations that are scaled by z0. If the ROC of X(z) is 
rR<|z|< rL, then the ROC of Y(z) is 
rR < z / z0 < rL, i.e., z rR < z < z0 rL
0 
• Differentiation of X(z) 
If we have f n
[ ]  ⇔ F z  
( ), then 
Z 
dF z 
nf[ ]
n ←→z 
and ROC = 
f
− 
( )  
R 
(9.13) 
z 
Proof: 
∞ 
F z  = ∑f n z
 
[ ]  
dF z 
( )  
−n −z 
( )  
dz 
n=−∞ 
∞ 
−−
= −z∑−n f n z 
[ ]  n 1 
(9.14) 
n=−∞ 
∞ 
dF z 
z
= ∑−n f n z  
[ ]  −n −z dz 
( )   
[ ]
←→nf n 
n=−∞ 
• Conjugation of a Complex Sequence 
If we have f n
[ ]  ⇔ F z  
( ), then 
∗ 
z 
∗
∗
f
n ←→F
z
 
= 
f 
(9.15) 
[ ]   
(
)
 and ROC 
R 
Proof: 
Let y[n] = f * [n], then 
∗ 
∗
−n 
∗−n 
∗
∗
Y z( )  = ∑
∞ 
f
n z
 
= 
∑
∞ 
[ ][
]
 

= F
z
[ ]  
 
f n z   
(
)
(9.16) 
n=−∞ 
n=−∞ 
 

Z-Transform 
149 
• Time-reversal 
If we have f n
[ ]  ⇔ F z  
( ), then 
∗ 
z 
∗ 
∗
f −
←
n 
F (1 z ) 
(9.17) 
[
]
 → 
Let y[n] = f * [−n], then 
∗ 
∗ 
∗)
−k 
 
∗(
Y z( )  = ∑
∞ 
f ∗[
]
−n z
 
−n = 

∑
∞ 
f[
][
]
 
−n z∗−n 
 = 

∑
∞ 
f k
[ ](1 z 

= F 1 z ∗) 
(9.18) 
n=−∞ 
n=−∞ 

k=

=−∞ 
If the ROC of F(z) is rR < |z| < rL, then the ROC of Y(z) is 
1 
1
∗ 
rR < 1 z < rL i.e., 
> z > 
rR 
rL 
When the time-reversal is without conjugation, it is easy to show 
f
n
[
]
z→F
−
← 
(1 z)
(9.19) 
1 
1
and ROC is 
> z > 
rR 
rL 
A comprehensive summary of the z-transform properties is shown in Table 9.2 
Example 9.5 
Find the z-transform of x(n) = 3n + 2*3n. 
SOLUTION 
From the linearity property 
[ ( )  
[3 
n 
Z n
 2
3n 
Z x n ] = Z n + 2 × 3 ] = 3 [ ]+ Z[
]
z
z
Z n  = 
2 and Z 3n
{ }  
{
}
 
= 
(z − 1) 
(z − 3) 
Therefore, 
3z 
2z 
Z x
[ (  )] 
n = 
2 +
(z − 1)
(z − 3) 
Example 9.6 
Find the z-transform of each of the following sequences: 
n
n
(a) x n
( )  = 2 u n  + (
( )  3 1 2  ) u n
( )
(b) x n
( )  = cos(5 ) (  ).
n u n 
SOLUTION 
n
(a) Because x(n) is a sum of two sequences of the form α u(n), using the linearity property of 
the z-transform, and referring to Table 9.1, the z-transform pair 
13 −1 
1
3 
4 − 2 z 
X z
( )  =
−1 +
= 
1 2
− z 
1 −1 
( − 
1 −1
1− 2 z 
1 2z)
1− 2 z  

150 
Digital Signal Processing 
TABLE 9.2 
Summary of z-Transform Properties 
No. 
Property 
Sequence 
z-Transform 
1 
Addition 
x n  x n
1 
2
( )  
( )
+ 
X 
X z
z
1 
2
( )  
( )
+ 
2 
Constant multiple 
cx(n) 
c X(z) 
3 
Linearity 
ax n
 bx n
1 
2
( )  
( )
+ 
aX 
bX z 
z
1 
2
( )  
( )
+ 
4 
Delay unit step 
u(n – m) 
Z 
Z 
m
1 
1 
− 
− 
5 
Time delay shift 
x n  m 
n m
( 
)
− 
−
U( 
) 
Z 
X z
−m 
( )
6 
Forward 1 tap 
x(n + 1) 
Z(X(z) – x(0)) 
7 
Forward m tap 
x(n + 1) 
Z 
X z 
x Z
m 
i 
m 
i 
i
( )  − 
 
 
 
 
 
 
= 
− 
−
∑ 
0 
1 
8 
Complex translation 
e x n
n ( )
X(ze−1) 
9 
Frequency scale 
b x n
n ( )
X(zb−1) 
10 
Differentiation 
n x n
( )
–Z X’(z) 
11 
Conjugation 
x n
* ( )
X
z
* 
*
(
)
12 
Time-reversal 
x(−n) 
X z( −1 ) 
13 
Integration 
1 
n x n
( )
−∫ 
X z  
Z dz
( )  
14 
Discrete-time convolution 
x n  x n
1 
2
( )  
( )
* 
X z X
z
1 
2
( )  ( )
15 
Initial time 
x(0) 
lim ( )
n 
X z
→∞ 
16 
Final value 
lim ( )
n 
x n  
→∞ 
lim 
( )
( 
) 
n 
Z 
X z 
→ 
− 
1 
1 
(b) For this sequence, we write 
j n  
− j n
5
5
x n = cos( n u( )  = 12 ( 
( )
( )  
5 ) n 
e 
+ e 
)u n 
Therefore, the z-transform is 
1
1 
1
1 
X z  
j n  −1 +
− j n
( )  = 
5
5 
−1
2 1− e
z
 2 1− e
z 
With a region of convergence |z| > 1. Combining the two terms, we have 
1− z−1cos 5
X z
( )  = 1 2z−1cos 5 + z−2
− 
Example 9.7 
Find the z-transform of the sequence given by 
x n  = u n
( )  - ( .  )
( ) 
( )  
0 85 nu n  

Z-Transform 
151 
SOLUTION 
X z
( )  = Z x n
( )] = 
( )]− Z  

Z u n  
( .
0 85 nu n
[
[ 
)
( ) 
z
z 
=
-
z - 1 z - 0 8
. 
9.4 INVERSE Z-TRANSFORM 
The z-transform of the sequence x(n) and the inverse z-transform of the function x(z) are defined as, 
respectively, 
x n
( ) = 
X z z
dz 
(9.20)
2
1
p jò ( )
n-1 
where the circular symbol on the integral sign denotes a closed counter in the complex plane. 
The z-transform is a useful tool in linear systems analysis. However, just as important as tech-
niques for finding the z-transform of a sequence are methods that may be used to invert the z-trans-
form and recover the sequence x(n) from X(z). Three possible approaches are described below. 
The inverse z-transform may be obtained by at least three methods: 
1. Partial fraction expansion and look-up table 
2. Power series expansion 
3. Residue method 
9.4.1 Partial Fraction ExPansion and a look-uP tablE 
Now we are ready to deal with the inverse z-transform using the partial fraction, expansion, and 
look-up table. The general procedure is as follows: 
1. Eliminate the negative powers of z for the z-transform function X(z) 
2. Determine the rational function X(z)\z (assuming it is proper), and apply the partial fraction 
expanded function X(z)\z using the formula in Table 9.1. 
3. Multiply the expanded function X(z)\z by z on both sides of the equation to obtain X(z). 
4. Apply the inverse z- transform using Table 9.1 
The partial fraction format and the formula for calculating the constant are listed in Table 9.1. 
For z-transforms that are rational functions of z, 
−1 
−1
∑
q 
b k z
( )  
∏
q (1 − bkz )
X z  = 
k=0 
= C
k=0
( )  
p
p 
(9.21)
∑ a k z
( )  −1 
∏
(1 − bkz−1 ) 
k=0 
k=1 
A simple and straightforward approach to find the inverse z-transform is to perform a partial frac-
tion expansion of X(z). Assuming that p > q and that all of the roots in the denominator are simple, 
αi ≠αk for i ≠k, X(z) expands as follows: 
p 
X z  ∑1 − 
A 
a 
k
z−1 
(9.22)
( )  = 
k
k=1 
for some constants Ak for k = 1,2, … p. The coefficients Ak may be found by multiplying both sides 
of Equation (9.3) by (1 – αk z−1) and setting z = αk. The result is 

152 
Digital Signal Processing 
Ak = (1− akz ) ( )

−1 X z   
(9.23) 
If p ≤q, the partial fraction expansion must include a polynomial in z−1 of order (p – q). The coef-
ficients of this polynomial found by long division (i.e., by dividing the numerator polynomial by the 
denominator). For multiple-order poles, the expansion must be modified. For example, if X(z) has a 
second-order pole at z = αk, the expansion will include two terms, 
B1 
B2
+ 
1 − akz−1 (1 − akz−1 )
2 
where B1 and B2 are given by 
B1 = ak 
 dz
d (1− akz−1 )
2 
( )

X z 
(9.24) 
B2 = 
(1 − akz−1 )
2 
( )

X z  
(9.25) 
Example 9.8 
Find the inverse of the following z-transform 
1
X z  =
( )  (1− z −1)( − . z −1)
1
 
0 8  
SOLUTION 
Multiplying the numerator and the denominator by z2 we get 
1 
z2 
z2 
X z  = 
=
( )  (1− z −1)(1
 
0 8  
− . z −1)
× z2 
(z − 1)(z − 0.8) 
Dividing both sides by z, we have 
X z  
z
( ) = 
z 
(z − 1)(z − 0.8) 
We notice that the right-hand side of the above equation is a proper rational polynomial of z. 
Also, we see that the denominator of the right-hand side has distinct poles, therefore, the right hand 
side in partial fraction form, 
X z  
( ) = 
A
B 
z 
( z -1)
+ ( z - 0.8) 
To find out the unknown constants A and B, we use: 
é 
X z ù 
z 
ù
( )  
é 
A = 
ëê(z -1) ´ 
z
z=1 
= 
êë
ê(z -1) ´ z -1)(z - . )úû
ú 
z=1
ûú 
( 
0 8 
é 
z 
ù 
1 
= 
ê
ê( z - 0.8)ú
ú 
= ( -
)
= 5 
ë
û z=1 
1
0 8 . 

Z-Transform 
153 
X z  
z
B = 
(z −0 8. ) × 
( )  
 
= 
 
(z −0 8. ) ×

 

z z= . 
 
(z −1)(z −0 8 . )
0 8  
z=0 8. 
 
z 
 
0 8. 
= 
(z −1 
 
. 
= 0 8  1
− )
= −4 

) z=0 8  
( . 
Substituting the values, we have, 
X z
( ) = 
5 
(
)
−4 
z 
( z − 1)
+ ( z − . )
0 8  
Or it can be written as (by multiplying both sides by z) 
5z 
4
( )
X z  = (z − 1)
−(z − 0 8. ) 
Taking the inverse z-transform of both sides and using Table 9.1, we have 
 
z 

 
z 
 
x n
( ) = Z−1( ( )  
5Z−1 ( z − 1)− 
−1 ( z − . 

X z ) = 
4Z 
0 8)




= 5u n  
( . )
(
u n
( ) − 4(0 8 n
Example 9.10 
Suppose that a sequence x(n) has a z-transform 
4 − 7 z−1 + 1 z−2 
X z  
4
4
( )  = 
1− 3 z−1 + 1 z−2 
4
8 
SOLUTION 
4 − 7 z−1 + 1 z−2
4 − 7 z−1 + 1 z−2 
X z  
4
4 
= 
4
4
( )  = 
1− 4
3 z−1 + 8
1 z−2 

1− 2
1 z−1 

 

1 − 4
1 z−1 

 
with a region of convergence |z| > ½. Because p = q = 2, and the two poles are simple, the partial 
fraction expansion has the form 
K2 
K3
X z  K1 
+
( )  =
+ − 1 −1 
− 1 −1 
1
2 z  
1
4 z  
The constant K1 is found by long division, and equal to 2. K2 and K3 are equal to 3 and –1, 
respectively. 
Thus, the complete partial fraction expansion becomes 
3
1
X z  2 
−
( )  =
+ −1 −1 
−1 −1 
1 
z 
1 
z 

2 


4 


 
154 
Digital Signal Processing 
Finally, because the region of convergence is the exterior of the circle |z| > 1, x(n) is the right-sided 
sequence 
x n  = 2d n + ( . )
( )
( .
)
 
u n
( )  
( )  3 0 5  nu n − 0 25 n ( )
9.4.2 PowEr sEriEs 
The z-transform is a power series expansion, 
∞ 
X z( )  =∑x n z
 
 x(
)z
x(
)z
( )  −n =
 
+
−
 
2
2 +
−1
1 
n= 
(9.26) 
x( )
0 + x( )z−1 
x 2 z−2 +
+ 
1 
+ ( )  

where the sequence values x(n) are the coefficients of z –n in the expansion; therefore, if we can find 
the power series expansion for X(z), the sequence values x(n) may be found by simply picking off 
–n
the coefficients of z
. 
Example 9.11 
Consider the z-transform 
+
 Z
c
X z  = log 
( )  
Z > c
 Z  
SOLUTION 
The power series expansion of this function is 
( )  
 Z
c
+
 
−1
X z  = log
 
 
= log (1+ c Z  ) 
Z > c 
Z 
∞ 1 
n+1 n 
−n
=∑ n (
)
−1 
c Z  
n > 0 
n=1 
Therefore, the sequence x(n) with this z-transform is 
 1 (
)1 n+1 n

− 
c
n > 0 
x n  = n
( )  
0 
otherwise

9.4.3 contour intEgration 
Another approach that may be used to find the inverse z-transform of X(z) is to use contour integra-
tion. This procedure relies on Cauchy’s integral theorem, which states that if C is a closed contour 
that encircles the origin in a counterclockwise direction, 
1 
2p j 
−k
z
dz = 

 
1 
0 
k 1
= 
(9.27) 
k ≠ 1
∫ 
C 
with 
∞ 
X z( )  = ∑x n z −n
( )  
(9.28) 
n=−∞ 

Z-Transform 
155 
Cauchy’s integral theorem may be used to show that the coefficients x(n) may be found from X(z) 
as follows: 
1 
n−1
x n  = 2p j∫ X z z
dz 
(9.29)
( )  
( )  
C 
where C is a closed contour within the region of convergence of X(z) that encircles the origin in a 
counterclockwise direction. Contour integrals of this form may often be evaluated with the help of 
Cauchy’s residue theorem, 
x n  = 2p 
1 
j∫ X z z
d
( )  n−1 z =∑( residues of X z z  
n−1 at the poles inside C) 
(9.30)
( )  
( )  
C 
If X(z) is a rational function of z with the first-order pole at z = αk, 
x n
( )  = 2p 
1 
j∫ X z z
d
( )  n−1 z =∑( residues of X z z  
n−1 at the poles inside C)
( )  
C 
n−1 

−1 
n−1 
Res X z z 
at z = a 
 1 − z ak) X z z
( )  

 ( )  
k= ( 
(9.31) 
Contour integration is particularly useful if only a few values of x(n) are needed. 
Example 9.12 
Find the inverse of each of the following z-transforms: 
2 
−2
i. X z  1 2  Z + Z )
0 <
( )  = + ( 
z < ∞ 
1
1
ii. X z  =
−1 +
−1
.
( )  
0 5  < z 
1 0 5Z 
1 0 2
− . Z
− . 
1
iii. X z  
−1 
−2
( )  = 
z > 2 
1 2Z + Z
+ 
1
iv. X z  
z > 1
−1 
−2
( )  = (1− Z )(1− Z ) 
SOLUTION 
i. Because X(z) is a finite-order polynomial, x(n) is a finite-length sequence. Therefore, x(n) 
is the coefficient that multiplies z–1 in X(z). Thus, x(0) = 4 and x(2) = x(–2) = 3. 
ii. This z-transform is a sum of two first-order rational functions of z. Because the region of 
convergence of X(z) is the exterior of a circle, x(n) is a right-sided sequence. Using the 
z-transform pair for a right-sided exponential, we may invert X(z) easily as follows: 
n 
 1 
n 
x n  = 0 5  u n  + 3 
( )
( )  ( . )
(
 ) 
u n
 3 
iii. Here we have a rational function of z with a denominator that is quadratic in z. Before 
we can find the inverse z-transform, we need to factor the denominator and perform a 
partial fraction expansion: 
1
1
( )  =
X z  
Z −1 + Z −2 = (1 2  −1)(1+ Z −1)
1 2
+
+ Z 

+  + 
+  
156 
Digital Signal Processing 
1
1
X z  
−
( )  = ( + Z −1)
(1+ Z −1)
1 2  
Because x(n) is right-sided, the inverse z-transform is 
x n
( ) =
-
(
)
( )
(
)
nu n  - -1 nu n
( )
2
2
 
iv. One way to invert this z-transform is to perform a partial fraction expansion. With 
1 
X z
( )  = (1− Z −1)(1− Z −2 ) 
The solution is given as follows: 
( )  0 2  + −1 n 
2 +  u n
x n  = . 5 1 ( ) + (n 
1)
( ) 
Example 9.13 
Find the inverse z-transform of the second-order system by 
1 0  25 
. 
Z −1
+
X z  =
( )  
z > .
0 5
(1 0 5 
. Z −1)
2
− 
Here we have a second-order pole at z = ½. The partial fraction expansion for X(z) is 
K1 
K2
X z  
+ 
2
( )  = 1− 2
1 z−1 

 − 2
1 −1

 
 
1 
z 
The constants K1 and K2 are –0.5 and 1.5, respectively, so 
. 
1 5
.
−0 5
X z
( )  =
+
− 1 −1 
1 −1 
2 
1
2 z  

1− 
z 
2 
and 
x n
( ) = -( . )n+1u n  + (n + )( . )n+1u n
0 5  
( ) 3 
1 0 5  
( )
Example 9.14 
Find the inverse z-transform of X(z) = sin z. 
SOLUTION 
To find the inverse z-transform of X(z) = sin z, we expand X(z) in a Taylor series of z = 0 as follows: 
Because 
∞ 
X z  = ∑x n z−n
( )  
( )  
n=−∞ 
So, 
dX z
( )
X z  = X z
( )  
( )  + z 
z=0 
dz 
z=0 
2 
2 ( )  
z d X z
z
d X z  
n
n ( )
+ 2! dz2 
n! dzn 
z=0 
z= 0 

Z-Transform 
157 
5 
∞ 
n+
3 
2
1
 
z
z 
z 
1 n
z
=
−
+
 −
=
 
 ∑(
)
− 
3! 
5! 
=
n 0 
+
(
 )
n
2 
1 ! 
Because 
∞ 
X z  = ∑x n z 
( )  
( )  −n 
n=−∞ 
We may associate the coefficients in the Taylor series expansion with the sequence values x(n). 
Thus, we have 
∞ 
n+
2
1
 
x n
( )  =∑(
)
 (2 
z
n +1)! 
−1 n 
n=0 
1
(
)1 n
= − 
+1)! 
n = −−
−
 
,
, 5 …
1 3  , 
n
(2 
Example 9.15 
Evaluate the following integral: 
1 
1 2
+ Z −1 − Z −2
3
z dz 
2p j ∫ 
C (1 0 5
 
− . Z −1)
1− 2 Z −1

3 
where the contour of integration C is the unit circle. 
SOLUTION 
Recall that for a sequence x(n) that has a z-transform X(z), and the sequence may be recovered 
using contour integration as follows: 
1 
n−1
x n  = 2p j ∫ X z z
dz
( )  
( )  
C 
Therefore, the integral that is to be evaluated corresponds to the value of the sequence x(n) at n = 4 
that has a z-transform 
1 2Z −1 − Z −2
+
X z  =
( )  
( − . Z −1)
1− 3
2 Z −1

1 0 5
 
Thus, we may find x(n) using a partial fraction expansion of X(z) and then evaluate the sequence at 
n = 4. With this approach, however, we are finding the values of x(n) for all of n. Alternatively, we 
could perform long division and divide the numerator of X(z) by the denominator. The coefficient 
multiplying z –4 would then be the value of x(n) at n = 4, and the value of the integral. However, 
because we are only interested in the value of the sequence at n = 4, the easiest approach is to 
evaluate the integral directly using Cauchy’s integral theorem. The value of the integral is equal to 
the sum of the residues of the poles of X(z)z3 inside the unit circle. Because 
3 
+ Z −1 − Z −2
3
1 2
X z z = 
z
( )  
(1 0 5
 
Z −1)
1− 3
2 Z −1

− . 
has poles at z = 1/2 and z = 2/3, 

158 
Digital Signal Processing 
3
REs X z z3 
( )  
= − 
z= . 
16
0 5  
and 
112
REs X z z3 
( )  
= 
z= / 
81
2 3  
Therefore, we have 
1 
3 
112
X z z
dz = −
+ 
= 1.195 
2p j ∫ ( )  n−1 
16 
81 
C 
Example 9.16 
Find the z-transform for the following sequences: 
a. x n  = 15u n
( )  
( )
b. x n  = 10sin
.
 n u n
( )  
(0 25p ) ( )
c. x n  = 0 5 nu n
( )  ( .  )
( ) 
d. x n
( )  ( . ) sin
= 0 5 n
. 
n u n
(0 25p ) ( )
e. x n  = e−0 1  co (0 25p ) ( )
( )  
. n 
s
.
 n u n  
SOLUTION 
(a) From Table 9.1, we get 
X z  = Z x n 
Z (15u n
( )  
15
( )  
( ( )) = 
) = z − 1
(b) From Table 9.1, we obtain 
X z  = Z x n 
Z (10sin
.
(0 25 n u n
( )  
( ( )) = 
p ) ( )) 
10sin
.
( 
p ) z 
7 07 z
0 25 
. 
= 
= 
2 
2
z − z cos
. 5 pn) + 1 
z − 1 414
2 
(0 2 
. 
z + 1 
(c) From Table 9.1, we get 
n
X z
( ) = Z x n ) = Z (( . )
( )
u n ) = 
z
( ( )  
0 5  
z − .
0 5  
(d) From Table 9.1, we get 
X z  
Z x n 
= 
( . ) sin . 
p n u n
( )  
( )  Z 
0 5 n 
0 25 
( )
=
(
)
( 
( 
)
) 
. × sin . 
p z
0 5  
(0 25 )
= z2 −
× 0. × z c
0 25 n + ( . )2
2 0 5  
os( . 
pp )
0 5 
0 3536 z
. 
= z2 −1 4142z + 0 25
. 
. 
(e) From Table 9.1, we get 

Z-Transform 
159 
X z
( ) = Z x n 
Z (e 
cos
.
(0 25 n u n )
( ( )) = 
−0 1
. n 
p ) ( )
0 1
z z − e− . cos
.
(
(0 25p ))
= 
z 2 − 2z e−0.1cos
.
 p ) + (e−0.1)
2
(0 25 
z z − 0 6397
( 
. 
)
= z2 − 1 279 z + .
. 
0 8187 
Example 9.17 
Find the inverse of the following z-transform, 
1
X z  =
( )  ( − z −1)( − . z −1)
1 
1 0 5  
Eliminating the negative power of z by multiplying by z2 and determine by 
2
z 
2 
−1 
−1
X z
( ) = 
z 
1− z 
( − . z )
(
) 1 0 5  
Dividing both sides by z leads to 
X z  
z
( ) = 
z 
(z − 1)(z − 0.5) 
A 
B 
= (z - 1)
+ (z - 0.5) 
z
A = lim 
= 2
z=1 (z − 0 5)
. 
z
B = lim 
= 1
z=0 5
. (z − 1) 
−1 
−1 
−1 
n
X z ) = 
(z − 1)
(z − . )
( )  ( .  u n
x n
( ) = Z ( ( )  Z 
 
z 

 + Z 
 
z 

= u n + 0 5))
( )
0 5 
Example 9.18 
Find the inverse of the following z-transform 
z 
z
i. X z  =
+
1
( )  
z −1 + z 
0.8)
( 
)
(
− 
2z 
5z
ii. X z
( ) =
+ 
(z − 1)
2 
(z − .
2 
0 8) 
-6 
-5 
iii. X z
z 
z 
-4
( ) =
+ 
+ z 
- .
z + 1 z 
0 7 
SOLUTION 
Dividing both sides by z, we have 
z 
z
i. X z  =
+
1
( )  
z −1 + z 
0.8)
( 
)
(
− 

160 
Digital Signal Processing 
x n  = Z −1( ( ))
( )  
X z 


 
 
= Z −1( )1 + Z −1 
(z
z 
− 1)
+ Z −1 
(z − 
z 
0.8)
 

 
= d (n ) + u n + 0 8 nu n
( )
( . )  ( )  
2z 
5z
ii. X z
( ) = 
2 + 
2 
z − 1 
z 
0 8
( 
)
(
− . ) 
( )  
−1 X z 
−1 
Z −1
x n  = Z ( ( )) = Z 

 
(z 
2 
− 
z 
1)
2 

 
+ 


(z − 
5z 
.
2 


 
0 8) 
= 2n u n
( ) + n( . )  ( )
5
0 8 n u n 
n
= 2r n
( ) + 5 0 8  
( . )
( )
r n  
-6 
-5 
iii. X z  = z 
+ 
z 
+ z -4
( )  
- .
z + 1 z 
0 7 
−6 
−5 
x n  = Z −1( ( )  Z −1
 z
z 
+ 1 

 + Z −1
 z − 
z 
0 7 
. 

 + Z −1(
−4)
( )  
X z ) = 
z 
x n  = Z −1 z −7 
z 
 
Z −1 z −6 
z 
 
Z −1 
−4
( )  
 
+
 
+
(z )
z + 1 
z − 0.7 
x n
( ) = u n - 7)
( . )
(
 - 6) 
(n
( 
+ 0 7 nu n  
+ d 
- 4) 
Example 9.19 
Determine the convolution of the following two sequences, using z-transform, 
1 
d ( )
x n
( ) = 3 n + 2d (n - 1) 
x n
( ) = 2 ( )  (
n - d 
2 
d 
n - 1) 
SOLUTION 
Taking the z-transform of the two sequences, we have 
X z  = Z 3d ( )
n + 2d (n −1 
3
2z 1 
1( )  
( 
)) =
+
 − 
X z
( ) = Z 2d ( )  (d n −1)
2 
1
2 
(
n − 
) =
−z − 
Using the z-transform property for convolution of two sequences, we have 
−1 
−1
( )  
( )
( )  
)
)
X z  = X z X z
1
2 
= (3
2
+ z 
(2 − z 
Therefore, 
X z
( ) =
+
6 z -1 - 2z -2 
Taking inverse z-transform of both sides (and using shift theorem), we have 
-1 
-1 
-1 
-1 
-1 
-2
x n  = Z 
( ) = 6Z ( )1 + Z (z ) - 2Z (z )
( )  
(
)
X z 
6d n + d n -
-
)
( - 2)
= 
( )
( 
1
2d n

Z-Transform 
161 
Example 9.20 
Given a transfer function depicting a DSP system 
z - 1
H z  =
( )  z + .
0 5
Determine 
(a) The impulse response h(n). 
(b) The step response s(n). 
(c) The system response y(n), if the input is given as x n  = 0 5 nu n .
( )  ( .  )
( )
SOLUTION 
Part (a): In this case x n  = d n 
) = 1. As 
( )  ( ), thus X(z
Y z
H z  =
( )  
( )
X z
( )
Therefore, in this case, the z-transform of the output is equal to the transfer function: 
H z  = Y z  
( )  
( )
By taking the inverse z-transform of the transfer function, we can find out the unit-impulse response 
h(n), of the system. The transfer function is written as 
H z  
z 1
( )  =
− 
z 
z z + . 
( 
0 5) 
This can further be written in the form of partial fractions as 
H z
( )  A
B 
=
+ 
z
z 
(z 
. )
+ 0 5  
where 
z −1 
−
0
1
A = 
= ( + . )
= −2 
0
0 5 
(z + 0 5
. ) z=0 
z −1
. −
0 5
1
 
B = 
= 
= −1
z 
0 5
z= .
0 5
. 
Thus, we have 
H z
( )  −2 
−1 
=
+ 
z
z 
(z + 0 5
. ) 
or 
H z
( )  = − − (z − 
z 
. ) 
2 
0 5  
Taking inverse z-transform of both sides (and using Table 5.1), we get 
( )  
− 0 5 nu n
h n  = −2d( )
n 
( . )
( ) 
which is the required impulse response of the system. 
z
Part (b): In this case x n
( )  = u n  
( )  = 
. As 
( ), thus X z  
z − 1 
Y z
H z  =
( )  
( )
X z
( )

162 
Digital Signal Processing 
Therefore, in this case, 
(z − 1) 
z 
( ) ( )  =
Y z
( )  = H z X z  (z + 0 5
. ) (z − 1) 
It is written as 
Y z
( )  = 
z − 1 
= 
1 
z
z + 0 5
. 
z −) 
(z + 0 5) 
( 
)( 
1
. 
Taking inverse z-transform of both sides, we get 
y n
( )  = −0 5  nu n
(
. )
( ) 
which is the required step response of the system. 
z
Part (c): In this case x n
( )  = ( .  
nu n  
( )
0 25 )
( ), X z  = z 
.
− 0 25 
Y z
H z  =
( )  
( )
X z
( )
Therefore, in this case, 
(z − 1) 
z 
Y z
( )  = H z X z  (z + 0 5
. )
⋅(z − . 
( ) ( )  = 
0 25 ) 
It is written as 
Y z  
z 1 
( )  =
− 
z 
(z + 0 5
. )(z − 0 25 
. ) 
Further, it can be written in the form of partial fractions as 
Y z  
( )  = 
A
B 
z
z + . )
+ z − 0 25 )
( 
0 5  ( 
. 
where 
z −1 
− . −1
0 5
A = (z −0 25 
. ) 
= (−0 5
. −0 25 )
= 2 
. 
z=−0 5
. 
z −1 
. 
−
0 25
1
 
B = 
= 
= −1
(z + 0 5
. ) 
. 
+ .
0 25
0 5 
z= .
0 25 
Thus, we have 
Y z  
2 
−1 
( )  = 
z 
(z + 0 5
. )
+ (z − . )
0 25 
or 
2z
z 
Y z  =
( )  
0 25 )
(z + 0 5
. )
−(z − . 
Taking inverse z-transform of both sides, we get 
( )  2 0 5
 
n 
nu n  
y n  =
−
(
. )
( )
( .
)
 
u n −0 25 
( )

Z-Transform 
163 
PROBLEMS 
9.1 Given the sequence x n
( )  = u n  ) 
-transform of x(n).
( −1 , find the z
9.2 Given the sequence x n
( )  = u n  ) 
-transform of x(n).
( +1 , find the z
9.3 Considering the exponential sequence 
( )  = a u
−1 , find the z
x n  
n ( 
) 
-transform of the 
sequence x(n). 
9.4 Considering the exponential sequence 
( )  = a u
+1 , find the z
x n  
n ( 
) 
-transform of the 
sequence x(n). 
9.5 Find the z-transform for each of the following sequences x(n). 
a) x n
( )  = 2 5u n − )
.
(
 1 
b) x n  = 102sin 
 pn 

 
( )  
4 
c) x n
( )  = 0 8  nu n − ) 
( . )
(
 1 
d) x n
( )  = ( .  )
sin 
0 8  n−1 

 pn 

 u n  
( −1)
4 
e) ( )  = e . n cos 
 
p 
4 
n
 u n −1) 
n 
−0 5  
( 
9.6 Find the z-transform of x(n)= 3n + 2*3n−1. 
9.7 Find the z-transform of each of the following sequences: 
n
n
a) x n
( ) = 2 u n − 1)+ 3
(
(1 2) u n( − 1) 
b) x n
( )  cos 5 
-1 
= 
(
)
n u n(
) 
9.8 Find the z-transform of the sequence given by 
x n  = u n
( + 1 - 0 85 nu n -1)
( )  
)
( .
)
(
 
9.9 Find the z-transform of the sequence given by 
x n  = d n - d n 1) 
(n
1( )  
( )
( -
+ d 
- 2) 
x n  = 1 5d n + 2 (n -1)
2( )  
.
( ) 
d 
( )  
1 
x n
Also, find the convolution x n  = x n
( )*
( ) 
2 
9.10 Find the inverse of the following z-transform 
10
X z  =
( )  
1
0 3
−
−1
( − . z 1)(1 
0 7
− . z ) 
9.11 Find the z-transform 
 Z
c
+
X z  = log
( )  
Z > c
 Z  
9.12 Find the inverse of each of the following z-transforms: 
3 
−3
i. X z  1
2
 Z + Z )
0 <
( )  = + ( 
z < ∞ 
10 
10
ii. X z  =
− 
.
( )  
− . 
−1 
−1 
0 5  < z 
1
0 5Z 
1
0 2
− . Z 

164 
Digital Signal Processing 
10Z
iii. X z( )  =
−1 
−2 
z > 2 
1
2Z + Z
+ 
1
iv. X z  
z > 1
( )  = 
Z(1 − Z −1 )(1 − Z −2 ) 
9.13 Find the inverse z-transform of X(z) = cos z. 
9.14 Given a transfer function depicting a DSP system 
z -1
H z  =
( )  z z + . )
( 
0 5  
Determine 
(a) The impulse response h(n). 
(b)The step response s(n). 
( )  ( . )
( )
n
(c) The system response y(n), if the input is given as x n  = 0 8  u n . 
9.15 Given a transfer function depicting a DSP system 
z z -1)
(
H z  =
( )  (z + 0 5. ) 
Determine 
(a) The impulse response h(n). 
(b)The step response s(n). 
(c) The system response y(n), if the input is given as x n  = 0 75 nu n .
( )  ( .  )
( ) 
9.16 Find the  z-transform for each of the following sequences (from the definition of the 
z-transform), 
a. x n
( )  = 4 u n
( )
b. x n
( )  0 7  nu n
= ( . )
( ) 
−2n ( )
c. x n
( )  = e
u n
d. x n
( )  = 2 0 8
 
n 
0 2p ) ( )
( . ) cos( .  n u n 
e. x n  = . e−3n sin( .  pn u n  
( )  2 5  
0 2
) ( ) 
9.17 Using the properties of the z-transform, find the z-transform for each of the following 
sequences: 
a. x n  = ( −) 
0 5 nu n
( )  u n  1 + ( . )
( ) 
−3(n−5)
(0 1  
)) ( 
b. x n
( )  = e 
cos
.
 p(n − 5 u n − 5) 
where u n − ) = 1 for n ≥ 5 and u n − ) = 0 for n < 5. 
(
5 
(
5 

10 Z-Transform 
Applications in DSP 
Z- transform is used in many applications of mathematics and signal processing. The applications of 
z transform are Analyze the discrete linear system, finding frequency response Analysis of discrete 
signal, Helps in system design and analysis and also checks the systems stability and analysis of 
digital filters. This chapter will focus on some these applications 
10.1 EVALUATION OF LTI SYSTEM RESPONSE USING Z-TRANSFORM 
Figure 10.1 shows an LTI system where h(n) is the impulse response of the system, and H(z) is 
the transfer function, the input signal x(n) and the output response is y(n), the transfer function in 
z-domain is given as 
Y z( )
H z( )  = H e( 
jw ) = X z  
(10.1) 
( )
10.2 DIGITAL SYSTEM IMPLEMENTATION FROM ITS FUNCTION 
The z-transform is a linear transformation, the system implementation produce is similar to that in 
the time domain. The most convenient form for system synthesis is the z-transform of the general 
difference equation given by 
M
b 
−k 
−k
( )  ∑ 
+∑b z  X z  
Y z = 
a z  Y z  
( )  
( )
(10.2) 
k
k 
k=1 
k q
= 
1 Gain: Figure 10.2 shows a gain block, where k is the value of gain. 
2 Delay: Figure 10.3 shows a delay block. 
3 Addition: Figure 10.4 shows an addition block used to add two or more signals. 
Example 10.1 
Find the impulse response and the transfer function of the following system as shown in Figure 10.5. 
SOLUTION 
y n  = x n
( )  + K y n − 1)
( )  
( 
Y z
( )  = X z
( )  + K Y z z  −1
( )  
For impulse response x(n) = δ(n) 
X(z) = 1 
Y z
( )  = + K Y z z  −1
1 
( )  
1
Y z
( )  = 1− K z−1 
165 

166 
Digital Signal Processing 
FIGURE 10.1 LTI processor system. 
FIGURE 10.2 Gain block. 
X(z) 
Y(z)=K X(z)
K 
X(z) 
Y(z)=K X(z) 
FIGURE 10.3 Delay block. 
X(z) 
Y(z)= X(z)+W(z) 
+ 
W(z) 
FIGURE 10.4 Addition block. 
+ 
K
X(z) 
Y(z) 
FIGURE 10.5 System for Example 10.1. 
Example 10.2 
Implement a second-order recursive filter for the sequence 
y n  = 2r cos
 
o ( − ) − r
 
y n  − ) + x n
( )
 
− r 
( )  
w y n
 
1 
2 ( 
2 
cos wo x(n − 1) 
SOLUTION 
Take z-transform for both sides to get 
( )  
oY z z  −1 
2 ( )
 
−2 
X z  
cos wo X z z−1
Y z  = 2r cos
 
w ( )
 
− r Y z z  + ( )
 
− r 
( )  

167 
Z-Transform Applications in DSP 
So the system implement as shown in Figure 10.6. 
Example 10.3 
Given a second-order transfer function 
2 5 1 
−1 
. ( − z )
H z  =
( )  
+
−1 
−2
(1 1 3 
. z 
+ 0 36 
. 
z ) 
Perform the filter realizations and write the difference equations using the cascade form realiza-
tions via the first-order sections. 
SOLUTION 
For the cascade realization, the transfer function is written in the product form. The given transfer 
function is 
. ( − z −2)
2 5 1 
H z  =
( )  1 1 3z −1 + 0 36 
. 
z −2
+ . 
The numerator polynomial is factorized as 
−2 
−1 
−1
( )  2 5 1( 
( −
( 
)
B z  = . 
− z ) = 2 5 1  
. 
z ) 1+ z 
The denominator polynomial is factorized as 
A z  =
+ . z −1 + . 
z −2 =
+ . z −1 + . z −1 + . 
z −2
( )  1 1 3 
0 36 
1 0 4 
0 9 
0 36 
=
−1
0
−1 1 0 4 −1 =
+ . 
−1 1 0 9 −1
1 1  0 4
+ . z 
+ 0 9
. z 
+ . z 
1 0 4 z 
+ . z
( 
)
( 
)
( 
)( 
) 
Therefore, the transfer function is written as 
−1 
−1
2 5 1 
. ( − z )(1+ z )
H z  = 
1 0 4 −1 
−1
( )  ( + . z )(1 0 9
+ . z ) 
Or 
 . − . z −1 1+ z −1 
2 5  2 5
H z  =
= H z
H (
( )  
( )⋅ 
)
 1 0 4
+ . z −1  + . z −1 
1
2 z
1 0 9 
+ 
+ 
x(n) 
y(n) 
2 r cos (wo) 
-r2 
-r cos (wo) 
+ 
FIGURE 10.6 System for Example 10.2. 

168 
Digital Signal Processing 
Thus, in this case 
2 5  2 5  
. z −1 
. −
H z = 
1( )  1 0 4 
+ . z −1 
1+ z −1 
H z
( ) =
−1
2 
1 0 9 
+ . z 
Each one of H z
( ) can be realized in direct-form I or direct-form II. Overall, we get 
( ) and H z
the cascaded realization with two sections. It should be noted that there could be other forms for 
1
2
1+ z −1
. − . 
−1
2 5  2 5  z
H z
( ) and H z
2( ), for example, we could have taken H z
( ) =
−1 , H z
( ) =
−1 , to 
1 
1
2
1 0 4 
+ . z 
1 0 9 
+ . z 
yield the same H z . Using the former H z
( ), and using direct-form II realizations for 
( )
( ) and H z
1
2
the two cascaded sections as shown in Figure 10.7, we get the following difference equations: 
 
2 5  2 5  
. z −1
. −
Section 1: H z = 
 
1( )  1 0 4 
+ . z −1  
w n
( ) = x n
( ) - 0 4  ( 
1
. w n - 1) 
y n = 2 5
. w n - .
( - 1
( )  
( )
2 5w n  ) 
 
1+ z −1  
1 
1
1 
Section 2: H z = 
 
2( )  1 0 9 
+ . z −1 
w n = y n
1 
− .
( − 1 
2( )  
( )  
w n
0 9
2 
) 
y n = w n
( ) + w n - 1)
( )
2 
2( 
Example 10.4 
A relaxed (zero initial conditions) DSP system is described by the difference equation 
( )
0 1  
1
0 2
 2 
( ) + x n
y n + .
(
y n - ) - . y n
( - ) = x n  
( - 1) 
Determine the impulse response y(n) due to the impulse sequence x(n) = δ(n). 
SOLUTION 
Taking the z-transform of both sides of the given equation, we get 
Z y n ) + . Z y n  
( 
1 −0 2
 
Z y n
 
)) = Z x n  + Z x n 
)) 
(10.1) 
( ( )
0 1  
( −))
. 
( ( −2 
( ( ))
( ( −1 
We have 
Z y n 
= ( )
( ( )) Y z 
Z x n 
= ( )
( ( )) 
X z 
2.5 
1 
y(n)
x(n) 
-2.5 
+ 
y1(n) 
-0.4 
+ 
w1(n) 
1 
+ 
-0.9 
+ 
w2(n) 
FIGURE 10.7 System for Example 10.3. 

169 
Z-Transform Applications in DSP 
Using shift theorem, we have 
−1
Z x n − 1 ) = z X z
( ( 
) 
( )
Also, we can apply to sift the theorem for y in a case of zero initial conditions, i.e., 
−
Z y n − 1 ) = z Y z
( ( 
) 
1 ( )
−2
Z y n − 2 ) = z Y z
( ( 
) 
( )
Putting these values in Equation (10.1), we have 
0 1  −1 ( ) 
−2 
−1 ( )
Y z
( ) + . z Y z − . 
( ) = X z
0 2z Y z  
( ) + z X z 
−1 
−2
1
⇒ Y z
( )( + . z 
− 0 2z 
= X z ( 
−)
1 0 1 
. 
) 
( ) 1+ z 
As x(n) = δ(n) therefore (from Table 9.1), X(z) = 1. The above equation can now be written as 
−1
(1+ z )
Y z  =
( )  
+
−1 
−2
(1 0 1 
. z 
− 0 2 
. z ) 
Multiplying both the numerator and the denominator with z2, we get 
z z + 1
Y z  =
( )  (z2 +
( 
. z −
) 
0 2)
0 1  
. 
The denominator is factorized as 
z z(
+ 1) 
z z(
+ 1) 
z( + )
z z  1
Y z = 
= 
2 
0 5  
) − 
+ . 
( )  ( 
0 2)
= ( ( + .
. (z 
. ) 
z 
0 5)
z + . z − 0 4
. z − . 
z z  0 5  0 4  + 0 5)
( 
(z − 0 4
. ) 
(10.2) 
Y z  
(z + 1)
( )
⇒
= 
z 
(z + 0 5
. )(z 
. )
− 0 4  
The right-hand side of the above equation is a proper rational polynomial, with the denominator 
polynomial having distinct poles. Therefore, it can be written into partial fractions as 
Y z  
( )  
A
B 
z 
= (z + 0 5
. )
+ (z - . ) 
(10.3)
0 4  
To find out the unknown constants A and B, we use: 
A = 
(z 
0 5  
X z
( )


+ . ) × 

z 
z=−0 5
. 
= 

⎢(z + . ) × ( 
( 
. 
z 
)
+
( 
1) 
. 
 
=−0 5
 
0 5  
z + 0 5  z −0 4)z 
. 
 
)  
. + 
.
(z + 1 
(−0 5  1) 
0 5  
0 5556
= 
(z −0 4
. )
 z=−0 5  
= (− . − . )
= −0 9  = − . 
0 5
0 4  
. 
. 
X z 
 
. 
(z 
1 
⎤ 
 
( )  
+ )
B = 
(z − 0 4
. ) × z 
 
= (z − 0 4) × z + 0 5
. )(z − 0 4   
z=0 4  

( 
. )z= . 
. 
 
0 4  
(z + 1)
( . + ) 
.
 
0 4
1 
1 4  
= 

 
. )
 
z 
. 
= 0 4  0 5  = 
9
. 
(z + 0 5  
( . + . ) 
0.
= 1 5556 
=0 4  

170 
Digital Signal Processing 
Equation (10.3) becomes: 
Y z  
− . 
1 5556
( ) = 0 5556 
. 
z
z + . )
+ z − 0 4)
( 
0 5  ( 
. 
−0 5556 
. 
z 
. 
z 
1 5556
Y z
( ) = 
z + . 
+ z − 0 4)
( 
0 5)
( 
. 
Taking an inverse z-transform of both sides 
 0 5556 
. 
z 
. 
z
−
 
1 5556  
( )  
−1( (  )) 
−1 
(
+ 0 5  
−1 
(
−. 
y n = Z
Y z 
= Z  z 
. ) + Z 
z 
0 4)


⎝

= −0 5556 Z −1 
+
. 
−1 
. 
1 5556 Z 
(
( 
)) 
z 
0 4  
= −0 5556)(−0 5
. ) 
( ) +
. 
)
. 
u n  
( 
) 

z −−
z 
0 5
. 


( 
) 
⎛
(
− 
z 
. )

 
( 
. 
u n  (1 5556 0 4
n 
(
)
n ( )  
Thus, the output signal is 
y n = -0 5556 )(- . )n u n + 1 5556 0 4 n 
( )
( )
(
.
 
0 5  
( )
( .  
)( . )  u n  
Example 10.5 
A relaxed (zero initial conditions) DSP system is described by the difference equation 
y n = . y n - ) + . 
y n
( - ) + x n + 0 1x n - 1)
( )
0 4 ( 
1
0 32 
2 
( )  .
(
 
Determine the impulse response y(n) due to the impulse sequence x(n) = δ(n). 
SOLUTION 
y n - . y n - ) - . 
y n
( - ) + x n + 0 1x n - 1)
( )
0 4 ( 
1
0 32 
2 
( )  .
(
 
Taking a z-transform of both sides of the given equation, we get 
Z y( ( )
n ) −0 4Z y n
( 
1 −0 32Z y n 
)) = Z x n  + 0 1 
))
. 
( −))
. 
( ( −2 
( ( ))
. Z x n
( ( −1 
−1 
−2 
−1
Y z − . z Y z − . 
( ) = X z + 0.1 
( )
( )
0 4  
( ) 0 32z Y z  
( )  
z X z 
−1 
−2 
−1
⇒ 
1 0 4 
X z (1 0 1
Y z
( )( − . z 
− 0.32z ) = ( ) + . z ) 
As x(n) = δ(n) therefore (from Table 9.1), X(z) = 1. the above equation can now be written as 
−1
(1 0 1 
. z
+
)
Y z  =
( )  
−
−1 
−2
(1 0 4 
. z 
− 0 32 
. 
z ) 
Multiplying both the numerator and the denominator with z2, we get 
z z + .
( 
0 1)
Y z  =
( )  
2
(z − . z − 0 32)
0 4  
. 
The denominator is factorized as 
z z(
+ .
0 1)
Y z  =
( )  z + . 
z - 0 8)
( 
0 4)( 
. 

171 
Z-Transform Applications in DSP 
( )  
(z + 0 1)
Y z  
.
Þ
= (z + 0 4
. )(z - . )
z 
0 8  
The right-hand side of the above equation is a proper rational polynomial, with the denominator 
polynomial having distinct poles. Therefore, it can be written into partial fractions as 
Y z  
( ) = 
A
B 
z
z + . )
+ z - 0 8)
( 
0 4  ( 
. 
To find out the unknown constants A and B, we use 
A = 
 z + 0 4) × X z
( )


( 
. 

z 
z=−0 4
. 

+ . 
z + . )
 
= (z 
0 4) × 
( 
0 1  
 

(z + 0 4)(z − . )
⎣ 
. 
0 8  z 
.
=−0 4  
(z + 0 1  
(−0 4  0 1  
. + .
. ) 
 
) 
0 25
=  
= 
. 
(z −0 8   
. 
− . −0 8)
= 
. )
( 0 4  
. 
z=−0 4  
 
X z
( )
B = 
(z − . ) × z 

0 8  
z= .
0 8  
= ⎢
(z 
0 8  
(z + 0 1)
 
 
− . ) × (z + 0 5
. ) z 
. 
− 0 8)

( 
. 
z= .
0 8  
(z + 0 1)
( . + 
) = 0 62
.  
0 4  0 1  
. 
= 
(z + 0 4
. )
 z=0 8
. 
= ( . + . )
. 
0 4  0 4  
Equation (10.3) becomes 
Y z
( ) = 
0 25 
. 
0 625
. 
z
z + . )
+ z - 0 8)
( 
0 4  ( 
. 
0 25z 
0 625 
. 
z
( )
Y z  = (z 
. 
+ . )
+ (z - 0 8)
0 4  
. 
Taking an inverse z-transform of both sides 
y n  = Z −1( ( ))
( )  
Y z 
 0 25z 
0 625 
. 
z  
= Z −1 z 
.
. )
+ Z −1 z 
0 8)⎟ 
( + 0 4  
( − . 
 
z 

 
z 
 
= (0 25 
. ) Z −1 
z −−0 4))+ ( . 
)
−1 
 z 
0 8   
( 
( 
. 
 
0 625 Z 
(
− . )
n 
n 
= (0.25 ( 
. 
u n
( ) + ( . 
.
( )
0 4) 
0 625 0 8  u n
) − 
)(
) 
Thus, the output signal is 
( )
( .  
0 4 n ( )  ( .  
)( . )n u n
y n  = 0 25 )(- . )  u n + 0 625 0 8  
( )

172 
Digital Signal Processing 
10.3 POLE-ZERO DIAGRAMS FOR A FUNCTION IN THE Z-DOMAIN 
The z-plane command computes and displays the pole-zero diagram of the z-function, as shown in 
Figure 10.8. 
The command is 
z plane(b,a) 
To display the pole value, use root(a). 
To display the zero value, use root(b). 
0 8  z−1 + z−1 
( )
X z = 1
2
. 
z−1 + 3 z−1
− 
clc; 
clear all 
b=[0 0.8 1]; 
a= [1 -2 3]; 
roots(a) 
roots(b) 
zplane(b,a); 
ans = 1.0000 + 1.4142i 
1.0000 - 1.4142i 
ans = -1.2500 
Figure 10.8 shows the zero-pole diagram of the Z-function. 
10.4 FREQUENCY RESPONSE USING Z-TRANSFORM 
The Freqz function computes and displays the frequency response of the given z-transform of the 
function 
freqz(b, a, Fs) 
b = coeff. of numerator. 
a = coeff. of denominator. 
Fs = sampling frequency. 
FIGURE 10.8 Zero-pole diagram of the z-function. 

173 
Z-Transform Applications in DSP 
MATLAB Code: 
clc; 
clear all; 
b=[2 10 4 5 3] 
a= [5 3 2 1 1] 
freqz(b,a); 
Figure 10.9 shows the magnitude and phase response using z-transform. 
Example 10.6 
Plot the magnitude and phase of the frequency response of the given digital filter 
Using freqz function: 
( )  .
( )
 
0 75
 
y n -
- 0 9  ( - )
Y n  = 1 5 x n + . 
(
1)
. y n  2 
MATLAB Code: 
clc; 
clear all; 
b = [1.5]; 
a= [1, -0.75, 0.9]; 
w = [0:1:100]*pi/100; 
H=freqz(b,a,w); 
magH = abs(H); 
phaH = angle(H)*180/pi; 
subplot(2,1,1); 
plot(w/pi,magH); 
title('Magnitude Response'); 
xlabel('frequency (rad/sec)'); 
ylabel('|H(f)|'); 
subplot(2,1,2); 
plot(w/pi,phaH); 
title('Phase Response'); 
xlabel('frequency (rad/sec)'); 
ylabel('Degrees'); 
Figure 10.10 shows magnitude and phase response using z-transform for Example 10.6. 
10 
5 
0 
Phase (degrees) 
Magnitude (dB) 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
Normalized Frequency (
 rad/sample) 
-100 
-200 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
Normalized Frequency (
 rad/sample) 
FIGURE 10.9 Magnitude and phase response using z-transform. 
1
0 
1

174 
Digital Signal Processing 
Degrees 
|H(f)| 
Magnitude Response
20 
15 
10 
5 
0 
0
 0.1 
0.2 
0.3 
0.4
 0.5 
0.6
 0.7 
0.8 
0.9 
1 
frequency (rad/sec) 
Phase Response
50 
0 
-50 
-100 
0 
0.1 
0.2 
0.3 
0.4 
0.5 
0.6 
0.7 
0.8 
0.9 
1 
frequency (rad/sec) 
FIGURE 10.10 Magnitude and phase response using z-transform for Example 10.6. 
PROBLEMS 
10.1 Obtain the output for the following input x(n) and impulse response h(n) using z-transform 
x(n) = 10 u(n) 
h(n) = 5 u(n) 
10.2 Find the impulse response and the transfer function of the following system as shown in 
Figure 10.11. 
10.3 Find the impulse response and the transfer function of the following system as shown in 
Figure 10.12. 
X(z) 
Y(z) 
+ 
-0.75 
FIGURE 10.11 System for Problem 10.2. 
Y(z) 
+ 
-0.75 
FIGURE 10.12 System for Problem 10.3. 

Z-Transform Applications in DSP 
175 
10.4 A signal x(n) begins at n = 0 and has seven finite sample values [1 2 3 2 1 –1 1] if it forms 
the input to a LTI processor whose impulse response h(n) begins at n = 0 and has four finite 
sample values [1 1 1 1] convolute x(n) with h(n) to find output y(n) using z-transform. 
10.5 Given two sequences 
x n  = 5 d n − 2 d(n − 2)
1( )  
( )  
x n  = 3 d(n
2( )  
− 3) 
a. Determine the z-transform of convolution of the two sequences using the convolution 
property of the z-transform, 
X z( )  = X z X z( )
1( )  2 
b. Determine convolution by the inverse z-transform from the result in part (a), 
−1
x n  = Z 
( )  2( ))
( )  
(X
 z X z 
1 
10.6 Find the inverse z-transform for each of the following functions, 
10z
z 
a. X z =
−
4
( )  
− 
z −1 
z + 0.5 
−5z 
10z 
2z
b. X z( )  = (z −1)
+
(z −1)
2 +
(z − 0 8. )
2 
z 
c. X z =
( )  z2 +1 2. z +1 
( )  4z−4 
z−1 
−8 + z−5 
d. X z  =
+ 
+ z 
z −1 (z −1 2 
z − .
) 
0 5
10.7 Using the partial fraction expansion method, find the inverse z-transform for each of the fol-
lowing functions, 
1 
a. X z = 
2
( )  z − . z − 0 04 
0 3  
. 
2
b. X z =
( )  
z − . 
z + 0 4)
( 
0 2)( 
. 
z 
c. X z =
( )  
z + . ) z2 −+ 0 5)
( 
0 2  ( 
z 
. 
z z( + 0 5. )
d. X z( )  = 
2 
(z − . ) (z − 0 6) 
0 1  
. 
10.8 A system is described by the difference equation 
( )
0 6  
) 
4 0 8  nu n
y n + .
(y n −1 = ( . )  ( )
Determine the solution when the initial condition is y(−1) = 2. 
10.9 A system is described by the difference equation 
y n −1 5y n − ) + .
( − 2) = ( . )
 
n−1u n
( )  .
(
 1
0 06 y n  
2 0 4  
( −1) 
Determine the solution when the initial condition is y(−1) = 1 and y(−2) = 1. 

176 
Digital Signal Processing 
10.10 Given the following difference equation with the input–output relationship of a specific ini-
tially relaxed system (all initial conditions are zero), 
y n  − .
(y n − ) + .
( − 2) = x n
1
0 1
 
y n  
( )  + 2x n −1)
( )
0 7  
( 
a. Find the impulse response sequence y(n) due to the impulse sequence δ(n). 
b. Find the output response of the system when the unit step function u(n) is applied. 
10.11 Given the following difference equation with the input–output relationship of a specific ini-
tially relaxed DSP system (all initial conditions are zero), 
y n  − .
(y n − ) + .
( − 2) = x n
y n  
( )  + 1 5
 
x n −1)
( )
1 4  
1
0 29 
.
(
 
a. Find the impulse response sequence y(n) due to the impulse sequence δ(n). 
b. Find the output response of the system when the unit step function u(n) is applied. 
10.12 Given the following difference equation, 
y n  = 0 5x n  + .
( 
) 
y n  1
( )  .
( )
 0 5x n −
+ .
(
 −)
1
0 5
 
a. Find the transfer function H(z). 
b. Determine the impulse response y(n) if the input is x(n) = 4δ(n). 
c. Determine the step response y(n) if the input is x(n) = 10u(n). 
10.13 Given the following difference equation, 
y n
( )  = x n  −.
(
 1
0 5
 
) 
. y n
( )  0 5y n −
+
 ( −2) 
a. Find the transfer function H(z). 
b. Determine the impulse response y(n) if the input is x(n) = δ(n). 
c. Determine the step response y(n) if the input is x(n) = u(n). 
10.14 Convert each of the following transfer functions into its difference equation 
z2 − . z
0 25 
(a) H z  = 
2
( )  z + . z + 0 18 
1 1  
. 
z2 − . z + 0 3
0 1  
.
(b) H z  = 
3
( )  
z 
10.15 Given the following digital system with a sampling rate of 10,000 Hz, 
y n
( )  = .
( )
 
x n  + 0 5  (
0 5  
. x n − 2) 
a. Determine the frequency response of the system. 
b. Calculate and plot the magnitude and phase-frequency responses. 
c. Determine the filter type, based on the magnitude frequency response. 
10.16 Given the following digital system with a sampling rate of 10,000 Hz, 
y n  = x n
( )  − 0 5y n − 2)
( )  
.
(
 
a. Determine the frequency response of the system. 
b. Calculate and plot the magnitude and phase-frequency responses. 
c. Determine the filter type, based on the magnitude frequency response. 
10.17 Given the following difference equation for a digital system, 
( )  
a x n −
+ ( 
2) 
a −
2
y n
( )  = x n  −2cos( ) (  1) x n −
+ 2g cos( )  g 
where γ = 0.75 and α = 30°, 
a. Find the transfer function H(z). 
b. Plot the poles and zeros on the z-plane with the unit circle. 
c. Determine the stability of the system from the pole-zero plot. 

177 
Z-Transform Applications in DSP 
d. Calculate the amplitude (magnitude) frequency response of H(z). 
e. Calculate the phase-frequency response of H(z). 
10.18 Given the first-order IIR system 
− z−1
1
2
H z  =
( )  1
0 5 
. z−1
− 
Realize H(z) and develop the difference equations using the following forms: 
1. Direct-form I 
2. Direct-form II 
10.19 Given the filter 
− . 
−1 
−2
1
0 9
 
z 
− 0
 
1 
. z
( )
H z = 1
0 3
 
z−1 − 0
 
04 
. 
z−2
− . 
Realize H(z) and develop the difference equations using the following forms: 
a. Direct-form I 
b. Direct-form II 
c. Cascade (series) form via the first-order sections 
d. Parallel form via the first-order sections 
10.20 Given the filter 
1
2
 
z−1 + z−2
+
H z =
( )  1
0 5
 
z−1 + 0
 
25 
. 
z−2
− . 
Use MATLAB to plot: 
a. Its magnitude frequency response. 
b. Its phase-frequency response. 
10.21 Find the FFT for the input and output of the digital filter as shown in Figure 10.13 for the 
input signal X(n) = [1 2 3 4]. 
10.22 Express the following z-transform in a factored form, plot its poles and zeros, and then deter-
mine its ROCs. 
z4 + 2z3 + 4z2
6z
4 
+
+ 3
G z  =
( )  
1 5  +
−.
3z4 + 3z3 −. z2 
z 
1 2
10.23 Determine the partial fraction expansion of the z-transform G(z) given by 
3z3 
G z( )  = 2z3 + 3z2 − 4z −1 
FIGURE 10.13 Filter for Problem 10.21. 


1 Pole-Zero Stability 
In DSP applications, the difference equation and transfer function are very important to study the 
characteristics of the system. The stability and frequency response can be examined based on the 
developed transfer function. This chapter will illustrate the concept of pole-zero stability, Stability 
determination based z-transform, determination pole and zeros from Difference Equation and 
Transfer Function and the Stability rules. 
11.1 CONCEPT POLES AND ZEROS 
A general causal digital filter has the difference equation: 
N
M 
y n  ∑a x n
i
 
i 
− ) − 
b x(n
k
(11.1)
( )  = 
(
∑ k 
−) 
i=0 
k=0 
which is of the order max{N,M}, and is recursive if any of the bj coefficients are nonzero. A second-
order recursive digital filter therefore has the difference equation: 
a x n −
+
 [ −
−b y n −
−
 [ −2]
y n
[ ]  = a x n
0 [ ]  +
1 [ 
1] a x n
2 
2] 
1 [ 
1] b y n
2 
A digital filter with a recursive linear difference equation can have an infinite-impulse-response. 
Remember that the frequency response of a digital filter with impulse response {h[n]} is: 
∞ 
W
H e jW = 
h n e− j
n
(11.2)
( 
) ∑ ( )  
n=−∞ 
11.1.1 Stability Determination baSeD z-tranSform 
An LTI system that can be described using z-transform as a ratio is 
N z( )  k z − 1 )
− z2 ) z − z3
( 
z
z( 
(
)… 
H z  = 
−
(z
p
 −
)… 
(11.3)
( )  D z( )  = (z
p1 )
− 
2 )(z
p3 
Where k is the system gain and the constants z1, z2, z3, …, are called zeros pf X(z), because they are 
values of (z) for which H(z) is zero. Conversely p1, p2, p3, …, are called poles of H(z). The poles and 
zeros are either a real or complex conjugate number. 
The digital system is stable, if and only all poles of the system lie inside the unit circle in the 
z-plane. 
11.1.2 the z-tranSform 
n
Consider the response of a causal stable LTI digital filter to the special sequence {z } where z is 
complex. If {h[n]} is the impulse response, by discrete-time convolution, the output is a sequence 
{y[n]} where 
∞
∞ 
( )  
( )  n k  
n 
− 
− 
k
y n  = ∑h n z 
= z ∑h n z
( )  
k=−∞ 
k=−∞ 
(11.4) 
= z H z
n ( )  
179 

180 
Digital Signal Processing 
The expression obtained for H(z) is the “z-transform” of the impulse response. H(z) is a complex 
number when evaluated for a given complex value of z. 
It indicates that for a stable causal system, H(z) must be finite when evaluated for a complex 
number z with modulus greater than or equal to one. 
∞
∞ 
Since H z  = ∑h n
[ ]z−n and the frequency-response H e iW ) = ∑h[n]z− j
n
( )  
:
(
 
W 
n=−∞ 
n=−∞ 
it is clear that replacing z by ejΩ in H(z) gives H(ejΩ). 
11.1.3 the “z-Plane” 
Conveniently, it is represented as complex numbers on an “Argand diagram” as illustrated in 
Figure 11.1. The main reason for doing this is that the modulus of the difference between two com-
plex numbers a + jb and c + jd say, i.e., | (a + jb) – (c + jd) |is represented graphically as the length 
of the line between the two complex numbers as plotted on the Argand diagram. 
If one of these complex numbers, c + jd say is zero, i.e., 0 + j0, then the modulus of the other 
number |a + jb| is the distance of a + jb from the origin 0 + j0 on the Argand diagram. 
Of course, any complex number like a + jb can be converted into polar form Rejθ where R = 
|a + jb| and θ = tan–1(b/a). Plotting a complex number expressed as Rejθ on an Argand diagram is also 
illustrated above. We draw an arrow of length R starting from the origin and set at an angle θ from 
the “real part” axis (measured anti-clockwise). Rejθ is then at the tip of the arrow. In the illustration 
above, θ is about π/4 or 45 degrees. If R = 1, Rejθ = ejθ and on the Argand diagram would be a point 
at a distance one from the origin. Plotting ejθ for values θ in the range of 0 to 2π 360° produces points 
all of which lie on a “unit circle,” i.e., a circle of radius 1, with the center as the origin. 
Where the complex numbers plotted on an z-diagram are values of z for which we are interested 
in H(z), the diagram is referred to as “the z-plane.” Points with z = ejΩ lie on a unit circle, as shown in 
Figure 11.2. Remember that |ejΩ| = |cos(Ω) + jsin(Ω)| = √[cos2(Ω) + sin2(Ω)] = 1. Therefore, evaluat-
ing the frequency response H(eiΩ) for Ω in the range 0 to π is equivalent to evaluating H(z) for z = ejΩ 
which goes around the upper part of the unit circle as Ω goes from 0 to π. 
11.2 DIFFERENCE EQUATION AND TRANSFER FUNCTION 
The general difference equation is given by 
y n  = b x n
( )  + 0 
−1 
 + b x n
M
 
M 
− 
a y  n −1 
 − a y n − N)
0 
b x n  )+ 
) −
)+ 
N ( 
(11.5)
( )  
(
( 
1 ( 
The supposition that all initial conditions of this system are zero, and the X(z), and Y(z) represent the 
z-transforms of the sequences x(n), and y(n), respectively, taking the z-transform of Equation (11.5) 
yields 
FIGURE 11.1 Complex number phasor diagram. 

181 
Pole-Zero Stability 
FIGURE 11.2 z-plane diagram. 
Y z  = b X z
 
( )  + 
( )  −1 + + b
 
X z z
 
− M − a Y z z
 
−1 + − 
( )  − N
( )  
b X z z
 
( )  
( )  
a Y z z 
(11.6) 
0
0 
M 
1 
N 
The z-transfer function H(z) defined as the ratio of z-transform of the output Y(z) to the z-transform 
of the input X(z). To get the transfer function rearrange Equation (11.6) as 
( )  
1 
−1 
− M 
A z
Y z  
b0 + b z
 
++ b
 
z 
M 
( )
H z( )  =
= 
= 
(11.7) 
X z  
1+ a z−1 ++ a z− N 
B z( )
( )  
1 
N 
where H(z) defined as the transfer function with its numerator and denominator polynomials is 
defined as 
A z  
b0 + b1z−1 + + bMz− M
( )  = 
(11.8) 
B z( )  = +
1 a z−1 +
+
 −N
 a z
(11.9) 
1 
N 
The z-transfer function represents the digital filter in the z-domain, as shown in Figure 11.3. 
Example 11.1 
A DSP system is described by the following difference equation 
( )  ( )  
( 
y n  ) − 0 8  
−)
y n = x n + x n( − 1
1 2
 
) − . x n − 2) − 2 ( − 1
. y n( 
2 
Find the transfer function H(z), the numerator polynomial A(z), and the denominator polynomial 
equation B(z). 
SOLUTION 
Taking the z-transform on both sides of the previous difference equation we achieve 
Moving the last two terms to the left side of the difference equation and factoring Y(z), i.e. 
–2y(n – 1) – 0.8y(n – 2) 
Z-transform input 
Z-transform output 
Digital Filter Transfer Function 
H(z) 
X(z) 
Y(z) 
FIGURE 11.3 z-transfer function and represent as the digital filter. 

182 
Digital Signal Processing 
On the left side X(z) on the right side, we obtain 
( )  ( )  
( 
y n  ) − 0 8  
−)
y n  = x n + x n( − 1
1 2
 
) − . x n − 2) − 2 ( − 1
. y n( 
2 
Y z  = X z + ( )  −1 − 
X z Z  −2 − 2 ( )
 
−1 − . Y z Z −2
( )  X z Z
 
.
( )
 
Y z Z 
0 8
( )
1 2  
( )  
Y z + Y z Z
 
−1 + .
( )
 
−2 = X z + ( )
 
−1 − . X z Z −2
( )  2 ( )  
0 8Y z Z  
( )
 
X z Z 
1 2 ( )  
 + Z −1
. 
−2  ( ) 
 
−1
. Z −2  X z
1 2  + 0 8Z 
Y z  = 1+ Z 
− 1 2 
( )
Y z  
1+ Z −1 − 1.2 −2
( )  = 
Z 
X z  
+ Z −1 + . 
−2
( )
1 2  
0 8Z 
Y z  
Z2 +
−.
( )  = 
Z 
1 2  
X z  
Z2 +
+
 
0.8
( )  
2Z 
The numerator polynomial A( )
 
= Z2 + Z − .
z 
1 2
The denominator polynomial B(z) = Z2 + 2Z + 0.8 
Example 11.2 
A DSP system is described by the following difference equation 
y n
( )  = x n − 0 35
 
. 
x n − 1
. x n
( )  
( 
) + 1 2  ( − 2)
Find the transfer function H(z), the numerator polynomial A(z), and the denominator polynomial 
equation B(z). 
SOLUTION 
Taking the z-transform on both sides of the previous difference equation we achieve 
y n
( )  = x n − 0 35
 
. 
x n − 1
. x n
( )  
( 
) + 1 2  ( − 2)
Y z  = X z − .
 ( )
 
−1 + . X z Z −2
( )  
( )  0 35X z Z 
1 2 ( )  
Y z  =  − . 
Z −1 + . Z −2  X z
( )  1 0 35 
1 2  
( )
Y z  
1 0 35 
− . 
Z −1 + . Z −2  
( )  =  
1 2  
X z
( )  
The numerator polynomial is A(z) = −. 
Z −1 + . Z −2 
1 0 35 
1 2  
The denominator polynomial is B(z) = 1
11.3 BIBO STABILITY 
A system is said to be bounded-input/bounded-output stable (BIBO stable or just stable) if the out-
put signal is bounded for all input signals that are bounded. 
Consider a discrete-time system with input x and output y. The input is said to be bounded if there 
is a real number M < ∞ such that x k
( )  ≤M for all k. 
An output is bounded if there is a real number N < ∞ such that  y k
( )  ≤N  for n. 
The system is stable if, for any input bounded by M, there is some bound N on the output. 
Theorem: 
A discrete-time LTI system is stable if and only if its impulse response is summable. 

183 
Pole-Zero Stability 
Proof: 
Consider a discrete-time LTI system with impulse response h. The output y corresponding to the 
input x is given by the convolution sum, 
∞ 
∀∈Integers, (  )
 
y n
 
= ∑ ( ) (  − ) 
(11.10) 
n 
h m x n
m
m=−∞ 
Suppose that the input bounded with bound M. Then, applying the triangle inequality, we see 
that 
∞
∞ 
y n
( )  ≤∑h m
( )  x n −m
(
) ≤ M∑h m
( )
(11.11) 
m=−∞ 
m=−∞ 
Thus, if the impulse response is summable, then the output is bounded with bound 
∞
∑
N
M
=
h m
( )
(11.12) 
m=−∞ 
Proof: 
To show that the system is not stable, we need to find one bounded input for which the output 
either does not exist or is not bounded. Such information is given by 
∀∈Integers,
n 
h
n
− 
x n
( )  = (
)
 h n  ≠
, ( ) 0 
h
n
(
)
− 
(11.13) 
= 0, ( ) 
h n  = 0 
The input is bounded, with bound M = 1. Plugging this input to the convolution sum (1) and evaluat-
ing at n = 0, we get 
∞
∞ 
2 
∞ 
y( )  = ∑h m x −m) ∑ 
h m))
0 
( ) (
 = 
( (  
= ∑h m
( )
(11.14) 
h m
( )
m=−∞ 
m=−∞ 
m=−∞ 
But since the impulse response is not summable, y(0) does not exist or is not finite, so the system is 
not stable. 
11.4 THE Z-PLANE POLE-ZERO PLOT AND STABILITY 
A handy tool for analyzing digital systems is the z-plane pole-zero plot. This graphical technique 
allows us to investigate the characteristics of the digital system shown in Figure 11.3, including 
system stability. In general, a digital transfer function can be written in the pole-zero form, and we 
can plot the poles and zeros on the z-plane. The z-plane is depicted in Figure 11.4 and has the fol-
lowing features: 
1. The horizontal axis is the real part of the variable z, and the vertical axis represents the 
imaginary part of the variable z. 
2. The z-plane is divided into two parts by a unit circle. 
3. Each pole is marked on the z-plane using the cross symbol ×, while each zero is plotted 
using the small circle symbol. 

184 
Digital Signal Processing 
Im 
Real
1
-1 
j 
-j 
Inside of 
unit circle 
Outside of 
unit circle 
FIGURE 11.4
 z-plane pole-zero plot. 
11.5 STABILITY RULES 
Similar to the analog system, the digital system requires that all poles plotted on the z-plane must 
be inside the unit circle. We summarize the rules for determining the stability of a DSP system as 
follows: 
1. If the outermost pole(s) of the z-transfer function H(z) describing the DSP system is(are) 
inside the unit circle in the z-plane pole-zero plot, then the system is stable. 
2. If the outermost pole(s) of the z-transfer function H(z) is(are) outside the unit circle in the 
z-plane pole-zero plot, the system is unstable. 
3. If the outermost pole(s) is(are) first-order pole(s) of the z-transfer function H(z) and on the 
unit circle in the z-plane pole-zero plot, then the system is marginally stable. 
4. If the outermost pole(s) is(are) multiple-order pole(s) of the z-transfer function H(z) and on 
the unit circle in the z-plane pole-zero plot, then the system is unstable. 
5. The zeros do not affect system stability. 
Notice that the following facts apply to a stable system (bounded-in/bounded-out [BIBO] stability 
discussed in Chapter 2): 
1. If the input to the system is bounded, then the output of the system will also be bounded, 
or the impulse response of the system will go to zero in a finite number of steps. 
2. An unstable system is one in which the output of the system will grow without bound due 
to any bounded input, initial condition, or noise, or its impulse response will grow without 
being bound. 
3. The impulse response of a marginally stable system stays at a constant level or oscillates 
between two finite values. 
Example 11.3 
The example illustrating the rules of stability 
When the input is impulse sequence x n
( )  = d n 
( ) as in Figure 11.5(a) and the difference output 
equation is given as y n  = x n
( )  + 0 7
. 5 (
( )  
y n − 1), the transfer function is given as 
z
H z  =
= Y z
( )  
( )
z − .
0 75 
n
and the output response can be written as y n
( )  0 75
. ) u n
= (
( )  as in Figure 11.5(b). 
The z-plane is given in Figure 11.5(c) and shows the stability of the system. 

   
    
      
     
185 
Pole-Zero Stability 
x(n)= (n) 
y(n) 
1
1 
0.75 
0.5625 
0.4218 
n
-2 
-1 
0 
1 
2 
n 
(a) Input signal 
(b) Output sequence 
Im 
Real 
1
-1 
j 
-j 
-1
(c) Z-plane representation 
FIGURE 11.5 Response of a stable system. (a) Input signal. (b) Output sequence. (c) Z-plane representation. 
When the input is an impulse sequence x n
( )  = d n
( ) as in Figure 11.6(a) and the difference out-
put equation is given as y n  = x n
( )  + 1 25 
. 
(
( )  
y n − 1), the transfer function is given as 
z
H z  =
= Y z
( )  
( )
z − .
1 25 
n
And the output response can be written as y n
( )  1 25
. ) u n
= (
( ) as in Figure 11.6b 
The z-plane is given in Figure 11.6c and shows the stability of the system. 
When the input is an impulse sequence x n
( )  = d n 
( ) as in Figure 11.7 and the difference output 
equation is given as y n  = x n
( )  + y n − 1), the transfer function is given as
( )  
( 
z
H z  =
= Y z
( )  
( )
z − 1 
And the output response can be written as y n
( )  = u n  
( ) as in Figure 11.8. 
The z-plane is given in Figure 11.9 and shows the stability of the system. 
Example 11.4 
Given the following transfer function 
z−1 − . z−2
0 6
( )
H z  = 1 1 2z−1 + 0 55 
. 
z−2
+ . 
Convert it into its pole-zero form. 

      
     
    
    
   
    
   
     
      
     
     
      
       
      
      
186 
Digital Signal Processing 
x(n)= (n) 
y(n) 
n
-2 
-1
 0 
1 
2 
3.81 
1 
3.05 
2.44 
1.953 
0 
1 
2 
3 
4 
5 
6 
1.5625 
1.25
1 
(a) Input signal 
Im 
j 
(c) Z-plane representation 
Real 
-1
 
1 1.25 
-j 
n 
(b) Output sequence 
FIGURE 11.6 Response of the unstable system. (a) Input signal. (b) Output sequence. (c) Z-plane 
representation. 
x(n)= (n) 
x(n) 
1 
n
-2 
-1
 0 
1 
2 
1 
n
0 
1 
2 
3 
4 
5 
(a) Input signal 
(b) Output sequence 
Im 
j 
(c) Z-plane representation 
Real
-1
 
1 
-j 
FIGURE 11.7 Response of the critical stable system. (a) Input signal. (b) Output sequence. (c) Z-plane 
representation. 

187 
Pole-Zero Stability 
Im 
-0.6 
j0.4359 
0.6 
Real
1
-1 
j 
-j 
-j0.4359 
FIGURE 11.8 z-plane representation of Example 11.4. 
Im 
0.5 
-0.5 
0.5 
Real
1
-1 
j 
-j 
-1
-0.5 
FIGURE 11.9 z-plane representation of Example 11.6a. 
SOLUTION 
We first multiply the numerator and denominator by z2 to obtain the transfer function whose 
numerator and the denominator polynomials have the positive powers of z, as follows 
2 
−1 
−2
z
z
 − . z
( 
0 6  )
H z  =
( )  
z2 (1 1 2
+ . z−1 + 0 55 
. 
z−2 ) 
z − .
0 6
H z  =
( )  z2 + . z + 0 55
1 2  
. 
The zero of H(z): z −0 6
. =
→
0 
z 
0 6 
. 
The poles of H(z): z2 +1 2z + 0 55
0
 
. 
=
→z = −0 6
. ± j . 
. 
0 4359 
From Figure 11.10, the poles are seen inside the unit circle, so the system is stable 
Example 11.5 
Given the following transfer function 
−2
z(1− z )
H z  =
( )  
+
−1 
−2
(1 1 3 
. z 
+ 0 36 
. 
z ) 
Convert it into its pole-zero form. 

188 
Digital Signal Processing 
Im 
0.5 
-0.5 
0.75 
Real
1
-1 
j 
-j 
-1
-2 
FIGURE 11.10 z-plane representation of Example 11.4b. 
SOLUTION 
We first multiply the numerator and denominator by z2 to obtain the transfer function whose 
numerator and the denominator polynomials have the positive powers of z, as follows 
−2
2 
2
(1− z ) z 
z − 1
H z
( )  = ( 
−1 
−2) 
2 = 
2 
+ .
1 1 3
+ . z 
+ 0 36 
. 
z
z 
z + 1 3
. z 
0 36 
Putting the numerator polynomial equal to zero and then finding the roots, gives us the zeros of 
the transfer function, 
z2
1
0
−=  
(z − 1)(z + 1) = 0 
Therefore, we get z1 = 1 and z2 = −1 as the roots. 
Now, setting the denominator polynomial equal to zero and find the roots, gives us the poles 
of the transfer function, 
z2 + . z + 0 36
0
1 3  
. 
= 
−1 3
. ± ( 
)
2 − ( )( .  
−1 3
. ± 
. 
− .
1 3  
4 1 0 36 ) 
1 69
1 44
. 
z = 
= 
21 
2
( )  
−1 3  ± 
. 
−1. ± .
. 
0 25 
3
0 5 
− .
= 
=
= −0 4
. ,  0 9  
2
2 
Therefore, the poles are p1 = −0.4 and p21 = −0.9. The transfer function can now be written in the 
pole-zero form as 
(z − 1)(z + 1)
H z  =
( )  z + . 
z + 0 9)
( 
0 4)( 
. 
Example 11.6 
The following transfer functions describe digital systems 
( )  ( 
0 5  
(z 
(
− 
2
0 5
. 
z 
) 
. 
a) H z  = 
z −. ) z +
+ 0 5) 

189 
Pole-Zero Stability 
(z2 + . )
0 25 
( )  
2 
b) H z  = 
z − . )(z + 4z +
)
( 
0 5  
4.5 
(z + 0 25 
. ) 
c) H z  = 
z − . ) z + 1.5 + ) 
( )  ( 
0 25
 
( 
2 
z 
1 
(z2 +
+
z 
0 25 )
. 
d) H z  = 
2 
( )  
z −1 z 
1 z 
. ) 
(
 )
 
(
 )
+ ( −0 6  
For each, sketch the z-plane pole-zero plot and determine the stability status for the digital system. 
SOLUTION 
a) Put the numerator polynomial equal to zero and then find the roots, 
z − 0 5
. = 0 
Therefore, we get z1 = 0.5 as the root. 
Now, set the denominator polynomial equal to zero and find the roots, which gives us  
the poles of the transfer function, 
2
z −0 5) z +
+ . )
0
( 
. ( 
z 
0 5  = 
This leads to 
z − 0 5
. = 0 
and 
−±  1 − ( )( . ) = 1
1−2
1 
( )2 
4 1 0 5  
−±  
z = 
21 
2
( )  
−±  − 1 = −. ± j = −0 5  ± j0 5
1 
1 0  
= 
.
. 
2
2 
Therefore, the poles are p1 = 0.5, p2 = −0.5 + j0.5 and p3 = −0.5 − j0.5. The magnitudes 
of these poles are 
= 0 5
.
p1 
p2 
. 
0 5
= −0 5  + j . = (
. )
 
−0 5 2 + 0 5 2
( . )  = 0 707 
. 
p3 
. 
0 5
= −0 5  −j . = (
.
 
)
 
0 5 2 + −
 
( 0 5 2 
.
− 
. )  = 0 707 
It can be noticed that the magnitudes of all the poles are less than 1, so they are inside 
the unit circle in the z-plane pole-zero plot. Therefore, the system is stable. It is shown 
in the Figure 11.9. 
b) Put the numerator polynomial equal to zero and then find the zero roots of the transfer 
function, 
z2 + 0 25
0
. 
= 
z2 = −0 25
. 
z =
−0 25 = ±  .
. 
j0 5 
Therefore, we get z1 = +j0.5 and z2 = −j0.5 as the roots. 

190 
Digital Signal Processing 
Now, set the denominator polynomial equal to zero and find the roots, which gives us 
the poles of the transfer function, 
(z − 0 75
 
. )(z2 + 4z + 4 5
. ) = 0 
It leads to 
z −0 75
0
 z 
.
. 
=
→
= 0 75 
and 
−±  4 − ( )( . ) = − ± j0
 
707 
4 
( )2 
4 1 4 5  
z = 
2
. 
21( )  
Therefore, the poles are p1 = 0.75, p2 = −2 + j0.707, and p3 = −2 − j0.707. 
It can be noticed that the two poles are outside the unit circle on z-plane pole-zero. 
Therefore, the system is unstable. It is shown in Figure 11.10. 
c) Put the numerator polynomial equal to zero and then find the roots, 
z + . 
=
0 25
0
Therefore, we get z1 = −0.25 as the root. 
Now, setting the denominator polynomial equal to zero and finding the roots, gives us  
the poles of the transfer function, 
2
z − 0 25
 
. ) z + 1 5
 
+ )
(
( 
. z 
1 = 0 
This leads to 
z − 0 5  = 0 so z = 0 25 
.
. 
and 
−1 5  ± (
 
. )  
2 
4 1 1 
z = 
. 
1 5  − ( )( )  = −0 75 ± j .
. 
0 66 
21( )  
Therefore, the poles are p1 = 0.25, p2 = −0.75 + j0.66 and p3 = −0.75 − j0.66. The mag-
nitudes of these poles are 
= 0 25
.
p1 
p2 
. 
0 66 
= −0 75
 
+ j . 
= 1
p3 
. 
0 66 
= −0 75
 
−j . 
= 1
It can be noticed that the magnitudes of the two poles are on unity circle 1, so the system 
is marginally stable. This is shown in Figure 11.9. 
2
d) (z +
+
z 
0 2
. 5) = 0  gives the two zeros at z = –0.5 
(z - 1)
2 ( z + 1)(z - 0 6  
0
. ) = 
gives the poles at p = 1 (two poles) and one pole at p = –1 and p = 0.6, respectively 
And the system is marginally stable. 
Example 11.7 
Check the stability of the system given by 
A z − )2 
( )  
(
1
H z  = 
) 
0 5  
) 
.
. )
(z − 0 4
. (z − . + j0 5
. (z − 0 5  − j0 5  
where A is a constant number. 

191 
Pole-Zero Stability 
Im 
j 
0.4 
0.5 
-0.5 
0.5 
Real
-1 
1 
-j 
FIGURE 11.11 z-plane representation of Example 11.7. 
SOLUTION 
z −.
0 
z
0 4  =
→
0.4 
z −0 5  + j0 5  =
→
= 0.5 −j0 5
. 
.
0 
z 
. 
. 
.
0 
z 
.
z −0 5  −j0 5  =
→
= 0 5 
. + j0 5 
The poles are inside the unit circle, so the system is stable (Figure 11.1 ). 
PROBLEMS 
11.1 Convert each of the following transfer functions into its pole-zero form. 
z( − . z )
1
0 16 −2 
( )
H z  =
+ . 
−1 
−2
1
0 7z + 0 1 
. z 
11.2 Given that each of the following transfer functions describe digital systems, sketch the z-plane 
pole-zero plot, and determine the stability status for the digital system. 
z z( −. 
0 75)
(a) H z  =
( )  
2
z + . )(z +
+ 0.8)
( 
0 25 
z 
z z2 + .
( 
0 25)
(b) H z  =
( )  (z − 0 5. )(z2 + 4z + 7) 
z z + . 
( 
0 15)
(c) H z  =
( )  
2
z + . ) z +1 4141 + )
( 
0 2  ( 
. 
z 1 
z z2 +
+
z 0 25 
( 
. )
(d) H z  = 
2
( )  
z −1 z 1 
z 
. )
( 
)( 
) 
+
( −0 36 
11.3 An LTI system is represented by the difference equation: 
y n  = . y n − ) − . 
y n
( − 2) + x n −1 + x n − 2
( )
0 7 (
1
0 12 
( 
)
( 
) 
1. Find the system transfer function H(z). 
2. Draw and obtain the poles and zeros; is the system is stable? 
3. Find the output response if the input is the unit step sequence given by x(n) = u(n). 

192 
Digital Signal Processing 
11.4 A DSP system is described by the following difference equation 
y n
( )  = x n  −.
(
 1
1 8
 
) 
. x n
( )  0 9x n −
+
 ( −2) 
Find the transfer function H(z), the numerator polynomial A(z), and the denominator poly-
nomial equation B(z). 
11.5 A DSP system is described by the following difference equation 
y n
( )  = x n  −.
(
 1
0 7
 
) 
. x n
( )  1 2x n −
+
 ( −2) 
Find the transfer function H(z), the numerator polynomial A(z), and the denominator poly-
nomial equation B(z). 
11.6 The following transfer functions describe digital systems. 
(z −1 5. )
(a) H z  =
( )  
z + . ) z2 +
+ 0 5)
( 
1 5  ( 
z 
. 
2
(z + . )
1 25 
(b) H z  =
( )  
2
(z − 0 5. )(z + 4z + 3) 
0 25 
(c) H z( )  = (z − . 
(z 
)
+
(z2
. 
+1 
) 
.5z + )
0 25
 
3 
2z +
+
z 0 25 )
( 
. 
(d) H z  = 
2
( )  
z −1 
z 0.9 z 0.2
(
 )
 
( + 
)( − 
) 
For each, sketch the z-plane pole-zero plot and determine the stability status for the digital 
system. 

12 Sampling 
In digital signal processing, sampling is the convert a continuous-time signal to a discrete-time 
signal, Such as conversion of a sound wave (a continuous signal) to a sequence of samples (a dis-
crete-time signal). A sample is a value or set of values at a point in time and space. A sampler is 
a subsystem or operation that extracts samples from a continuous signal. A theoretical ideal sam-
pler produces samples equivalent to the instantaneous value of the continuous signal at the desired 
points. 
12.1 RELATING THE FT TO THE DTFT FOR DISCRETE-TIME SIGNALS 
First, we must establish the relation between discrete-time-frequency Ω0 and continuous-time-fre-
quency ω0. 
Given, 
x t = e j t
w and 
( )  = e j n
(12.1) 
( )  
g n 
Ω 
Let, g(n) = x(nT), this implies that, 
Ω 
w
e j n = e j Tn 
(12.2) 
and we may define Ω = ωT. 
Now, to relate FT to DTFT consider: 
∞ 
Ω
X e jΩ= 
x n e − j n
(12.3) 
( 
) ∑ ( )  
n=−∞ 
s 
FT 
s 
DTFT 
(
)
The aim is to seek an FT pair x t( )⇔ X
j( w)  which corresponds to x n
( )  ⇔ X e jΩ 
where xs(t) is a continuous-time signal that corresponds to x(n), and the FT Xs(jω) corresponds 
( 
jΩ
to the DTFT X e ). 
Now, 
( 
jΩ
X
jw) = X e  
(12.4) 
s 
(
) 
Ω=wT 
∞ 
X
jw) = ∑x n e −j T
w n 
s( 
( )  
(12.5) 
n=−∞ 
Taking inverse FT for Xs(jω) by using 
FT 
d( − T 
w n 
(12.6) 
t
n
 ) ⇔ e j T
To obtain the continuous-time signal description of the discrete-time signal: 
∞ 
s( )  ∑ 
t
n
x t = 
x n
( )  d( − T) 
(12.7) 
n=−∞ 
193 

 
 
194 
Digital Signal Processing 
and, hence, 
x t  
x n  t
nT 
X j 
x n e
s 
FT 
s 
j Tn
( )  
( 
)
( )  (
 ) 
( )
= 
− 
⇔ 
= 
∞ 
∞ 
−
∑ 
∑
d 
w 
w 
(12.8) 
n=−∞ 
n=−∞ 
See the following (Figure 12.1). 
12.2 SAMPLING 
The sampling operation generates a discrete-time signal x(n) from a continuous-time signal x(t). 
Note that x(t) is a band-limited signal. 
12.3 BAND-LIMITED SIGNALS 
A band-limited signal is a signal g(t) with a spectrum which is zero above a specified frequency 
fH Hz. 
g t  ⇔ G( )  0
for 
( )  
w = 
w > wH = 2p fH 
(12.9) 
12.4 SAMPLING OF CONTINUOUS-TIME SIGNALS 
Let x(n) be a discrete-time signal that is equal to the samples of x(t) at integer multiples of a sam-
pling interval T. That is x(n) = x(nT). The effect of sampling is evaluated by relating the DTFT of 
x(n) to the FT of x(t). Figure 12.2 shows the concept of sampling. 
X(j ) 
2
-2 
1 
X(exp j ) 
2
-2 
1 
n 
x(n) 
1 
2 
3 
-1 
t 
1 
2 
3 
-1 
Impulse conversion 
-
2 
DTFT 
FT 
X(t) 
0 1
2
3
 
FIGURE 12.1 Relation between FT and DTFT. 

Sampling 
195 
t 
xs(t) 
t
p(t) 
1 
t 
x(t) 
FIGURE 12.2 Concept of sampling. 
Begin with the continuous-time representation for the discrete-time signal x(n): 
∞ 
s( )  ∑ 
t
n
x t = 
x n
( )  d( − T) 
(12.10) 
n=−∞ 
∞ 
x t = ∑x n
( T) d( − 
) 
(12.11) 
s( )  
t
 nT 
n=−∞ 
Since, x t d t
n ) = x nT ) d( − T
s
( )  (
 
− T 
( 
t
n ), we may rewrite x (t) as: 
x t( )  = x t p t  
( )  ( )
(12.12) 
where 
s
∞ 
p t = ∑d(t
nT
( )  
− 
) 
(12.13) 
n=−∞ 
Then, multiplication in the time domain corresponds to convolution in the frequency domain: 
1
X
jw) = 
X jw)*
(
 
s(
( 
P jw) 
(12.14) 
2p 
∞ 
X
jw) = 2
1 
p X jw)*
 
2 
T 
p ∑d w −kw )
s( 
( 
( 
0 
(12.15) 
k=−∞ 
2p
Where, ws = 
 is the sampling frequency. 
T 

196 
Digital Signal Processing 
Now, convolve X(jω) with each impulse: 
∞ 
X
jw) = 
X(w −kw ) 
(12.16) 
s (
1 ∑ 
s
T k =−∞ 
Notes on the above equations: 
1. The FT of the sampled signal is given by an infinite sum of versions of the original signal’s 
FT. 
2. The shifted versions are offset by integer multiples of ωs. 
3. The shifted versions may overlap with each other if ωs is not large enough compared to the 
frequency content of X(jω). 
Assume that x(t) has frequency contents of –Wn < ω < Wp. Under this condition, three cases are 
stated: 
1. ωs = 3W. See Figure 12.3(b). 
2. ωs = 2W. See Figure 12.3(c). 
3 
3. ws = 
W . See Figure 12.3(d). 
2 
We conclude that the shifted versions of X(jω) overlap one another when ωs < 2W. 
Aliasing phenomena (see Figure 12.3 (d)) 
• Aliasing is the overlapping in the shifted replicas of the original signal. 
• It occurs when ωs < 2W. 
• It distorts the spectrum of the original signal. 
• Therefore, the original signal spectrum X(jω) (the middle one in Figure 12.3 (d)) cannot 
be reconstructed. 
• To prevent aliasing, we must have ωs > 2W, where W is the highest frequency component 
in the signal. 
12.5 SAMPLING THEOREM 
The sampling theorem states that a band-limited signal which has no frequency components higher 
than fH Hz can be recovered completely from a set of samples taken at the rate of fs (≥2fH) samples 
per second. 
The above sampling theorem is also called the uniform sampling theorem for base-band or low-
pass signals. 
The minimum sampling rate, 2fH samples per second, is called the Nyquist rate; its reciprocal 
1/2fH, measured in seconds, is called the Nyquist interval. 
In sampling, a strict distinction between base-band and pass-band signals made as follows: 
For base-band signals, B ≥fL Hz. 
For pass-band signals, B < fL Hz. 
where B is the bandwidth of the signal g(t), and fL is the lowest frequency of the signal g(t). 
Sampling Theory: 
The sample concept of sampling is given as switch as shown in Figure 12.4, and the sampled signal  
using switching sampling is given in Figure 12.5. 

Sampling 
197 
FIGURE 12.3 Sampling at a different sampling frequency ωs. 
fs = sampling frequency rate in sample/sec or Hz. 
1
Ts = 
(12.18) 
fs 
Ts sampling period time (sec). 
Nyquist Condition 
fs ≥ 2 fm 
(12.19) 

198 
Digital Signal Processing 
Input signal 
fs 
F(t),f(nTs) 
FIGURE 12.4 Basic concept of sampling. 
f(t) 
A 
t 
-A 
Ts 
f(t) 
Ts 
s(t) 
Sampled signal 
Short 
Open 
Open 
(a) 
(b) 
(c) 
1 
t 
A 
t 
-A 
FIGURE 12.5 Sampled signal using switching sampling. 
Nyquist rate frequency in sample/sec or Hz. 
fs(min) = 2 fm 
(12.20) 
Example 12.1 
Calculate the sampling rate frequency for the signal f t( )  = 2sin(2p × 103t)  (Figure 12.6). 
SOLUTION 
wm = 2p × 103 rad = 2pfm
sec 

Sampling 
199 
f(t) 
2 
1 msec 
t 
-2 
Ts=0.5 msec 
FIGURE 12.6 Sample signal using switching sampling of Example 12.1. 
1
fm 
Tm 
= 
→
1kHz 
= fm 
= 1msec 
fs =
fm
2 
fs
→
 
=
× =
2 1
2msec 
Ts = fs 
1 = 0 5
. msec 
Example 12.2 
Find the Nyquist rate and the Nyquist interval for each of the following signals: 
(a) f t( )  = 2cos(800pt)cos(4200pt) 
(b) f t( )  = sin(300pt) 
pt 
2




 
SOLUTION 
(a) f t( )  = 2cos(800pt)cos(4200pt) 
= cos(3400pt)
cos(5000 t 
+ 
p ) 
Thus f(t) is a band-limited signal with fH = 2,500 Hz. Hence the Nyquist rate is 5,000 Hz 
1
and the Nyquist interval is 
= 0 2
. ms. 
5000 
cos(250pt)
(c) f t( ) = 
pt 




 
Thus f(t) is a band-limited signal with ωH = 300π (i.e., fH = 150 Hz). Hence, the Nyquist 
1
rate is 300 Hz and the Nyquist interval is 
. 
ms.
= 3 33
300 
(c) From the frequency convolution theorem, we find that the signal f(t) is also band-limited 
and its bandwidth is twice that of the signal of part (b), that is, fH = 250 Hz. Thus, the 
1
Nyquist rate is 500 Hz, and the Nyquist interval is 
= 2ms. 
500 
sin(300pt) 
1 
w
(b) f t( ) =
⇔
rect 
300 
600
pt 
p 

200 
Digital Signal Processing 
12.6 BAND-PASS SAMPLING 
The band-pass sampling theorem states that if a band-pass signal g(t) has a spectrum of bandwidth 
B and an upper-frequency limit fu, then g(t) can be recovered from gs(t) by band-pass filtering if fs = 
2fu/k, where k is the largest integer not exceeding fu/B. All higher sampling rates are not necessarily 
usable unless they exceed fs = 2fu. 
Example 12.3 
Consider the band-pass signal x(t) with the spectrum shown below (Figure 12.7): 
Check the band-pass sampling theorem by sketching the spectrum of the ideally sampled sig-
nal xs(t) when fs = 25 kHz. 
SOLUTION 
fu
From the figure above we have, fu = 30 kHz and B = 10 kHz. Then 
= 3 and k = 2. Hence, we 
2fu 
B 
have fs =
= 30kHz (Figure 12.8). 
k 
For fs = 30 kHz, it can be seen that g(t) is recovered from the sampled signal by using a band-pass 
filter. g(t) can be recovered by using a low-pass filter with a cut-off frequency fc = 30 kHz. 
12.7 QUANTIZATION 
The objective of the quantization process is to represent each sample by a fixed number of bits. 
For example, if the amplitude of signal resulting from the sampling process ranges between (−1V 
and +1V), there is an infinite value of the voltage between (−1 and +1). For instance, one value can be 
−0.27689V. To assign a different binary sequence to each voltage value, we would have to construct 
a code of infinite length. Therefore, we can take a limited number of voltage values between (−1V 
and +1V) to represent the original signal, and these values must be discrete. 
X(f) 
f (kHz) 
-30 
-20
 20 
30 
FIGURE 12.7 Signal of Example 12.2. 
Xs(f) 
-20
 20 
f (kHz)
-30 
30
25
-25 
FIGURE 12.8 Sampled signal of Example 12.2. 

Sampling 
201 
Assume that the quantization steps were in 0.1V increments, and the voltage measurement for 
one sample is 0.58V. That would have to be rounded off to 0.6V, the nearest discrete value. Note that 
there is a 0.02V error, the difference between 0.58V and 0.6V. The error from the true value to the 
quantized value is called quantization distortion (Figure 12.9). 
The higher the quantization level, the better quality of the system will deliver. However, increas-
ing the quantization level has two major costs: 
1) The cost of designing a system that needs a sizable binary code. 
2) The time it takes to process this large number of quantizing steps by the encoder. 
Therefore, a considerable number of quantizing levels may induce unwanted delays in the system. 
12.8 UNIFORM AND NON-UNIFORM QUANTIZATION 
From the above discussion, it is clear that the quantization noise depends on the step size. When the 
steps have a uniform size, the quantization is called uniform quantization. 
For uniform quantization, the quantization noise is the same for all signal magnitudes. Therefore, 
with uniform quantization, the signal to noise ratio (SNR) is worse for low-level signals than for 
high-level signals. 
Non-uniform quantization can provide fine quantization of the weak signal and coarse quantiza-
tion of the strong signal. Thus in the case of non-uniform quantization, quantization noise can be 
made proportional to signal size. The effect is to improve the overall SNR by reducing the noise for 
the predominant weak signals, at the expense of an increase in noise for the rarely occurring strong 
signals. 
Example 12.4 
For the spectrum of the signal shown in Figure12.10, find the output signal if fm = 1 kHz (Figure 12.10). 
a) fs = 3 kHz 
b) fs = 4 kHz 
c) fs = 6 kHz 
SOLUTION 
a) fs = 3 kHz 
fs < 2fm 
Under-sampling (aliasing) (Figure 12.11). 
FIGURE 12.9 Concept of quantization. 

202 
Digital Signal Processing 
-2f 
2f 
fm (kHz)
X(f) 
1 
FIGURE 12.10 Signal of Example 12.4. 
1 
-9 
-6 
-3 
0 
X(f) 
3 
6 
9 
fm (kHz) 
-3 -2 
fm (kHz)
1 
-5 
-1 
3
2 
5
1 
FIGURE 12.11 Sampled signal of Example 12.4 a. 
b) fs = 4 kHz 
f = 2fm = 2* 2
4
 
s 
= kHz 
Low bandwidth (Figure 12.12). 
c) fs = 6 kHz 
fs > 2fm 
High bandwidth (Figure 12.13). 
1 
fm (kHz) 
-16 -8
-4 
0 
4 
8 
16 
X(f) 
-6 
-4 
1 
-2 
2 
4
0 
8 
fm (kHz)
FIGURE 12.12 Sampled signal of Example 12.4 b. 

Sampling 
203 
0 
24 
fm (kHz) 
1 
-6 
-4 
fm (kHz)
X(f) 
1 
6 
12
-6
-12
-24 
-2 
2 
4
0 
8
6
-8 
FIGURE 12.13 Sampled signal of Example 12.4 c. 
Example 12.5 
Sketch the following signals in discrete-time with fs = 4 Hz and N = 4 
a) x t( )  = 3cos(2pt) 
b) x t( )  = 5cos(200pt) + 2cos(2pt) 
SOLUTION 
1
1 
t
nT f = 4 = 
=
= .
= 
, 
0 25sec
s
s
 
Ts 
4 
a) x t( )  = 3cos (2pt) 
x nTs) = 3cos 2pnT = 3cos 2 ´ 0 25 ´ n)
(
( 
s)
( p 
. 
x 0 = 3 x 
= , x 2 = -3 x
( )  , ( ) 
1
0
 ( )  
, (3) = 0 
b) x t( )  = 5cos(200pt) + 2cos(2pt) 
x nTs) = 5cos(200pnTs 
2cos(2pnTs)
( 
) + 
(
)
. 
cos 2 
.
x nTs = 5cos(200p ´ 0 25 ´ n) + 2c
( p ´ 0 25 ´ n) 
x( )  = 2, ( ) = , x( )2 = -2 x 3
0 
x 1
0
 
, ( ) = 0 
Example 12.6 
The period of a periodic discrete-time function is 0.125 milliseconds, and it is sampled at 1,024 
equally-spaced points. It assumed that with this number of samples, the sampling theorem is satis-
fied, and thus there will be no aliasing. 
a) Compute the interval between frequency components in KHz 
b) Compute the period of the frequency spectrum in KHz 
c) Compute the sampling frequency fs 
d) Compute the Nyquist frequency 

204 
Digital Signal Processing 
SOLUTION 
a) Intervals between samples and periods in discrete-time and frequency domains Tt = 
0.125 milliseconds and N = 1,024 points. Therefore, the time between successive time 
components are 
Tt 
0 125 
. 
× 10−3 
tt =
= 
= .
0 122 µsec 
N 
1024 
b) the period Tf of the frequency spectrum is 
1
1
ft =
= 
−3 = .
8 192 MHz 
Tt 
0 122 
. 
× 10 
c) the sampling frequency fs is 
fs ≥ 2ft ≥ 2 × 8 192MHz 
.
 
d) the Nyquist frequency must be equal or less than half the sampling frequency that is 
fs = ft = 2× 8 192 MHz = 
.
2 
. 
16 384 MHz 
Example 12.7 
Given an analog signal: 
x t( )  = 5cos
 
(2p ⋅ 2000t) + 3cos (2p ⋅ 3000t), for t ≥ 0, 
sampled at a rate of 8,000 Hz. 
a. What is the Nyquist rate for this signal? 
b. Sketch the spectrum of the sampled signal up to 20 kHz (Figure 12.14). 
c. Sketch the recovered analog signal spectrum if an ideal low-pass filter with a cut-off 
frequency of 4 kHz is used to filter the sampled signal to recover the original signal 
(Figure 12.15). 
SOLUTION 
(a) For the given signal fmax = 3,000 Hz. According to the sampling theorem, the Nyquist 
rate/limit is FN = 2fmax = 6,000 Hz. To avoid aliasing noise, the given signal should be 
sampled at a rate higher than FN. 
(b) Using Euler’s formula, we get 
x t( )  = 3 e− j2p⋅3000t + 5 e− j2p⋅2000t + 5 e j2p⋅2000t + 3 e j2p⋅3000t 
2 
2 
2
2 
The spectrum of the sampled signal is sketched below: 
FIGURE 12.14 Sampled signal of Example 12.7 before filtering. 

Sampling 
205 
FIGURE 12.15 Sampled signal of Example 12.7. 
(c) Based on the spectrum in part (b), the sampling theorem condition is satisfied. Hence, 
we can recover the original spectrum using a reconstruction low-pass filter with a cut-off 
frequency of 4 kHz. The recovered spectrum is sketched below: 
12.9 AUDIO SAMPLING 
Digital audio sampling is one of the most important applications of sampling; it is used in pulse-
code modulation and digital signals for sound reproduction. This includes analog-to-digital conver-
sion (ADC), digital-to-analog conversion (DAC), storage, and transmission. In effect, the system 
commonly referred to as digitalis is, in fact, a discrete-time, discrete-level analog of a previous elec-
trical analog. While modern systems can be quite subtle in their methods, the primary usefulness 
of a digital system is the ability to store, retrieve, and transmit signals without any loss of quality. 
12.10 SAMPLING RATE 
A commonly seen unit of sampling rate is Hz, which stands for Hertz and means “samples per sec-
ond.” As an example, 48 kHz is 48,000 samples per second. 
When it is necessary to capture audio covering the entire 20–20,000 Hz range of human hear-
ing, such as when recording music or many types of acoustic events, audio waveforms are typically 
sampled at 44.1 kHz (CD), 48 kHz, 88.2 kHz, or 96 kHz; the approximately double-rate requirement 
is a consequence of the Nyquist theorem. Sampling rates higher than about 50 kHz to 60 kHz cannot 
supply more usable information for human listeners. Early professional audio equipment manufac-
turers chose sampling rates in the region of 40 to 50 kHz for this reason. 
The Audio Engineering Society recommends a 48 kHz sampling rate for most applications but 
gives recognition to 44.1 kHz for Compact Discs (CD) and other consumer uses, 32 kHz for trans-
mission-related applications, and 96 kHz for higher bandwidth or relaxed anti-aliasing filtering. 
A more complete list of common audio sample rates is given in Table 12.1. 
PROBLEMS 
12.1 Find the Nyquist rate and the Nyquist interval for each of the following signals: 
(a) f t( )  = 10cos
 
(2000pt)cos (4000pt) 
sin (100pt)
(b) f t( )  = 
pt 
 sin (100pt) 
2 
(c) f t( )  = 
 
pt 
 

206 
Digital Signal Processing 
TABLE 12.1 
Common Audio Sample Rates 
Sampling rate 
Use 
8,000 Hz 
Telephone and encrypted walkie-talkie, wireless intercom and wireless microphone 
transmission; adequate for human speech but without sibilance. 
11,025 Hz 
Audio CDs; PCM, audio analysis. 
16,000 Hz 
Most modern VoIP and VVoIP communication products. 
22,050 Hz 
Audio CDs; PCM, MPEG audio and for audio analysis of low-frequency energy. 
32,000 Hz 
Digital video. video tapes, DAT (LP mode), NICAM digital audio, wireless 
microphones. digitizing FM radio. 
37,800 Hz 
CD-XA audio. 
44,056 Hz 
Used by digital audio locked. 
44,100 Hz 
Audio CD, audio (VCD, SVCD, MP3). 
47,250 Hz 
PCM sound recorder. 
48,000 Hz 
The standard audio sampling rate used by professional digital video equipment such 
as tape recorders, video servers, vision mixers, and so on. Mixing consoles and 
digital recording devices. 
50,000 Hz 
First commercial digital audio recorders from the late 70s from 3M and Sound stream. 
50,400 Hz 
The sampling rate used by the Mitsubishi X-80 digital audio recorder. 
64,000 Hz 
Uncommonly used, but supported by some hardware and software. 
88,200 Hz 
Some professional CD recording equipment. 
96,000 Hz 
DVD-Audio, some LPCM DVD tracks, audio tracks, HD DVD. 
176,400 Hz 
HDCD recorders and production. 
192,000 Hz 
DVD-Audio, DVD tracks, audio tracks, and HD DVD tracks, 
352,800 Hz 
Used for recording and editing Super Audio CDs. 
2,822,400 Hz 
Direct Stream Digital. 
5,644,800 Hz 
Some professional DSD recorders. 
11,289,600 Hz 
Uncommon professional DSD recorders. 
22,579,200 Hz 
Experimental DSD recorders. 
12.2 The period of a periodic discrete-time function is 0.25 milliseconds, and it is sampled at 
1,024 equally-spaced points. It is assumed that with this number of samples, the sampling 
theorem is satisfied, and thus there will be no aliasing. 
a. Compute the period of the frequency spectrum in KHz. 
b. Compute the interval between frequency components in KHz. 
c. Compute the sampling frequency fs. 
d. Compute the Nyquist frequency. 
12.3 Given an analog signal: 
x t( )  = 5cos
 
(2p ⋅1000t)+ 3cos (2p ⋅ 2000t), for t ≥ 0,
sampled at a rate of 8,000 Hz. 
a) What is the Nyquist rate for this signal? 
b) Sketch the spectrum of the sampled signal up to 20 kHz. 
c) Sketch the recovered analog signal spectrum if an ideal low-pass filter with a cut-off fre-
quency of 4 kHz is used to filter the sampled signal to recover the original signal. 
12.4 Given an analog signal: 
x t( )  = 5cos
 
(2p ⋅ 2500t)+ 3cos (2p ⋅2000t), for t ≥ 0, 
sampled at a rate of 8,000 Hz. 

Sampling 
207 
a. What is the Nyquist rate for this signal? 
b. Sketch the spectrum of the sampled signal up to 25 kHz. 
c. Sketch the recovered analog signal spectrum if an ideal low-pass filter with a cut-off fre-
quency of 4 kHz is used to filter the sampled signal to recover the original signal. 
12.5 Given an analog signal: 
x t( )  = 5cos(2p ⋅1500t), for t ≥ 0,
sampled at a rate of 8,000 Hz, 
a. Sketch the spectrum of the original signal. 
b. Sketch the spectrum of the sampled signal from 0 kHz to 20 kHz. 
12.6 Given an analog signal: 
x t( )  = 5cos
 
(2p ⋅ 2500t)+ 2cos (2p ⋅3200t), for t ≥ 0, 
sampled at a rate of 8,000 Hz. 
a. Sketch the spectrum of the sampled signal up to 20 kHz. 
b. Sketch the recovered analog signal spectrum if an ideal low-pass filter with a cut-off fre-
quency of 4 kHz is used to filter the sampled signal to recover the original signal. 
12.7 Given an analog signal: 
x t( )  = 5cos
 
(2p ⋅ 2500t)+ 2cos (2p ⋅ 4500t), for t ≥ 0, 
sampled at a rate of 8,000 Hz. 
a. Sketch the spectrum of the sampled signal up to 20 kHz. 
b. Draw the recovered analog signal spectrum if an ideal low-pass filter with a cut-off fre-
quency of 4 kHz is used to filter the sampled signal to recover the original signal. 
c. Determine the frequency / frequencies of aliasing noise. 
12.8 Given an analog signal: 
x t( )  = 10cos
 
(2p ⋅ 5500t)+ 5sin (2p ⋅ 7500t), for t ≥ 0, 
sampled at a rate of 8,000 Hz. 
a. Sketch the spectrum of the sampled signal up to 20 kHz. 
b. Draw the recovered analog signal spectrum if an ideal low-pass filter with a cut-off fre-
quency of 4 kHz is used to filter the sampled signal to recover the original signal. 
c. Determine the frequency/frequencies of aliasing noise. 
12.9 Consider the analog signal: 
x t( )  = 3cos (100pt) 
a. Determine the minimum sampling rate required to avoid aliasing. 
b. Suppose that the signal is sampled at a rate of 200 Hz. What is the discrete-time signal 
obtained after sampling? 
c. Suppose that the signal is sampled at the rate of fs = 75 Hz. What is the discrete-time signal 
obtained after sampling? 
0 <
< f 
F
d. What is the frequency 
s  of a sinusoid signal that yields samples identical to those 
obtained in part (c)? 
2 
12.10 Given the analog signal: 
x t( )  = 3cos
 
(50
 
pt)+ 10 sin (300pt) − cos
 
(100pt), for t ≥ 0, 
What is the Nyquist rate for this signal? 

208 
Digital Signal Processing 
12.11 Consider the analog signal: 
x t( )  = 3cos
 
(2000pt)+ 5sin (6000pt)+ 10cos
 
(12000pt), for t ≥ 0, 
a. What is the Nyquist rate for this signal? 
b. Assume now that we sample this signal using a sampling rate of 5,000 samples/sec. What 
is the discrete-time signal obtained after sampling? 
12.12 If the analog signal to be quantized is a sinusoidal waveform, that is, 
x t( )  = 9 5. sin (2000 × pt) 
and if the bipolar quantizer uses 6 bits, determine 
a. Number of quantization levels. 
b. The quantization step size or resolution, Δ, assuming that the signal range is from −10 
to 10 V. 
c. The signal power to quantization power ration. 
12.13 A digital communication link carries binary-coded words representing samples of an input 
signal 
x t( )  = 2cos(600pt)+ 2cos(1800pt)
a
The link is operated at 10,000 bits/s, and each input sample quantized into 1,024 different 
voltage levels. 
a. What is the sampling frequency and the folding frequency? 
b. What is the Nyquist rate for the signal xa(t)? 
c. What are the frequencies in the resulting discrete-time signal x[n]? 
d. What is the resolution Δ? 

13 Digital Filters 
Digital Filters are intended to pass signal components of certain frequencies without distortion. 
To pass the signal, the frequency response should be equal to the signal’s frequencies (pass -band). 
The frequency response should be equal to zero to block the signal. (stopband). This chapter will 
discuss the types of filters according to the pass signal and will discuss the Finite Impulse Response 
Digital Filter and Infinite impulse response digital filter. 
13.1 TYPES OF FILTERS 
There are four types of filter according to the pass frequencies. 
13.1.1 Low-Pass FiLters 
Low-pass filters are designed to pass low frequencies, from zero to a certain cut-off frequency and 
to block high frequencies. 
13.1.2 HigH-Pass FiLters 
High-pass filters are designed to pass high frequencies, from a certain cut-off frequency and to 
block low frequencies. 
13.1.3 Band-Pass FiLters 
Band-pass filters are designed to pass a certain frequency range, which does not include zero and 
to block other frequencies. 
13.1.4 Band-stoP FiLters 
Band-stop filters are designed to block a certain frequency range, which does not include zero and 
to pass other frequencies. 
Figure 13.1 shows the types of these filters. 
Example 13.1 
Plot the magnitude frequency response for the low-pass filter given by the transfer function 
z
H z  =
( )  z − .
( 
0 25) 
SOLUTION 
clear all 
close all 
clc 
[h w] = freqz([1], [1 -0.25], 1024); 
phi = 180*unwrap(angle(h))/pi; 
figure 
plot(w, abs(h)); 
grid on; 
xlabel('Frequency (radians)'); 
ylabel('Magnitude'); 
209 

210 
Digital Signal Processing 
FIGURE 13.1 Types of filters. 
Figure 13.2 shows a LPF Response. 
Example 13.2 
Plot the magnitude frequency response for the high-pass filter given by the transfer function 
H z  =
−. z −1
( )  1 1 5 
SOLUTION 
clear all 
close all 
FIGURE 13.2 LPF response for Example 13.1. 

Digital Filters 
211 
clc 
[h w] = freqz([1 -1.5], [1], 1024); 
phi = 180*unwrap(angle(h))/pi; 
figure 
plot(w, abs(h)); 
grid on; 
xlabel('Frequency (radians)'); 
ylabel('Magnitude'); 
Figure 13.3 shows a HPF Response. 
Example 13.3 
Plot the magnitude frequency response for the band-pass filter given by the transfer function 
. z2 − 0 5
0 5  
.
H z  =
( )  z2 − . 
z + 0.25
0 25 
SOLUTION 
clear all 
close all 
clc 
[h w] = freqz([0.5 0 -0.5], [1 -0.25 0.25], 1024); 
phi = 180*unwrap(angle(h))/pi; 
figure 
plot(w, abs(h)); 
grid on; 
xlabel('Frequency (radians)'); 
ylabel('Magnitude'); 
Figure 13.4 shows a response of BPF. 
FIGURE 13.3 HPF response for Example 13.2. 

212 
Digital Signal Processing 
FIGURE 13.4 BPF response for Example 13.3. 
Example 13.4 
Plot the magnitude frequency response for the stop-pass filter given by the transfer function 
1 0 9
 
z −1 + 0
 
81 
. 
z −2
− .
H z  =
( )  1 0 6
 
z −1 + 0
 
36 
. 
z −2
− . 
SOLUTION 
clear all 
close all 
clc 
[h w] = freqz([1 -0.9 0.81], [1 -0.6 0.16], 1024); 
phi = 180*unwrap(angle(h))/pi; 
figure 
plot(w, abs(h)); 
grid on; 
xlabel('Frequency (radians)'); 
ylabel('Magnitude'); 
Figure 13.5 shows a SPF Response. 
13.2 INFINITE-IMPULSE-RESPONSE (IIR) DIGITAL FILTER 
Digital IIR filters are derived from their analog counterparts. There are several common types 
of analog filters: Butterworth which has maximally flat pass-bands in filters of the same order, 
Chebyshev which have a ripple in the pass-band, and elliptic filters which are equi-ripple in both the 
pass-band and the stop-band. 
• Our strategy will be to design the filter in the analog domain and then transform the filter 
to the digital domain. 
• We can derive this transformation by recalling the relationship between the Laplace trans-
form and the z-transform: 
• This transformation is known as the bilinear transform. 

Digital Filters 
213 
FIGURE 13.5 SPF response for Example 13.4. 
13.2.1 design oF FiLters Using BiLinear transFormation 
A method to map the left half of the s-plane to the inside unit circle of the z-plane. 
Mapping of the s-plane to the z-plane 
• A point on the jΩ-axis in the s-plane mapped onto a point on the unit circle in the z-plane. 
• A point in the left-half of the s-plane with σ < 0 mapped inside of the unit circle in the 
z-plane. 
• A point in the right-half of the s-plane with σ > 0 mapped outside of the unit circle in the 
z-plane. 
Figure 13.6 shows the s- and the z-plane. 
j 
Im z 
Re z
0 
0 
1
-1 
S-Plane 
Z-Plane 
FIGURE 13.6 The s- and z-plane. 

214 
Digital Signal Processing 
• The design of the digital IIR Filter, H(z), from the analog filter, Ha(s), requires a mapping 
of the s-plane to the z-plane. 
• The point in the left-half of the s-plane should map to points inside the unit circle to pre-
serve the stability of the analog filter. 
• Bilinear transformation is given by 
2  z −1 
s = 
(13.1)
T  z +1 
• Maps a single point in the s-plane to a unique point in the z-plane. 
• The relationship 
H z  = H s
( )  
( )  
2  z−1 
(13.2)
z→ T  z+1 
• Frequency wrapping, 
Ω=  2 tan 
 
w 
2 

 
(13.3) 
T 
• Choose T = 2 to simplify the design procedure. 
• So, the parameter T does not affect H(z). 
1+ s 
z = 
(13.4)
1− s 
Example 13.5 
Convert the following analog first-order low-pass filter into a digital filter given as the analog 
transfer function 
Ω
H
s( )  = 
c 
LP 
s + Ωc 
SOLUTION 
Applying bilinear transformation, 
ΩcT (1+ z−1)
Ωc
G
z
( )  = 
= 
2 
LP 
−1

Ωc
s + Ωc 
2 1−z 
−1 
T 
−1 
s=  
−1 
(1− z ) + 
(1 + z )
T  1+z  
2 
1− a  1+ z−1  
1− tan(w T 2
c / )
= 
where a = 
2  1− az−1  
1+ tan(wcT / 2)2
Example 13.6 
Convert the following analog first-order high-pass filter into digital filter given the analog transfer 
function: 
s
HHP ( )s = s + Ωc 
SOLUTION 
Applying bilinear transformation, 

Digital Filters 
215 
1+ a  1− z−1  
G
z
 
= 
sc 

−1
−1
HP ( )
s + Ωc 
2 1−z 
= 
2  1− az  
s= T 
−1 
 1+ z  
13.2.2 inFinite-imPULse resPonse FiLtering 
This section introduces IIR filters. In this chapter, we will study some commonly used IIR-filtering 
structures, design processes, and implementations on both fixed-point and floating-point DSP pro-
cessors. Also, important practical issues such as quantization effects in different IIR-filter structures, 
fixed-point implementations, and scaling problems are examined using FDATool. An application 
that uses IIR filters for DTMF generation and detection is presented at the end of the chapter. 
FIR-filter characteristics were introduced in this chapter and briefly compared with IIR filters. In 
general, IIR filters have the following features: 
1. Nonlinear phase: IIR filters have a nonlinear-phase response over the frequency of interest. 
Therefore, group delay varies at different frequencies and results in phase distortion. 
2. Stability issue: IIR filters are not always stable due to their recursive realization. Therefore, 
a careful d sign approach is needed to ensure that all of the poles of an IIR filter lie inside 
the unit circle to guarantee a stable filter, especially for fixed-point implementations as 
well as the inputs. Due to the nature of output feedback, there is an inherent one sample 
delay in the feedback section. The IIR filter performs two inner (or dot) products of vec-
tors, one is for the feedforward section between vectors b and x, and the other for the 
feedback section between vectors a and y. The design of the IIR filter determines two 
sets of coefficients, {bj, i = 0,1, … , L – 1} and {am, m = 1,2, … , M – I}, to meet a given 
specification. Also, the IIR filter is recursive in computation, which results in an infinite-
impulse-response. Therefore, the IIR filter must be designed with special care to prevent 
any growing or oscillation of the impulse response that can lead to an unstable filter. 
By taking the z-transform using the time-shift property, we have 
( )  ( 0
1 
−1  
L−1 
−+
L 1 )
(
1 
−1
2 
−2  
M −1 
M )Y z
Y z  = b + b z
 
+
+
 
b
Z
 X Z
 
( )  −a z
 
+ a z
 
+
+
 
a
z−
+1 
( )
(13.5) 
l−1 
m−1 
= x z ∑b z−i − ( )∑
−m
( )  
y z  
a z
i
m 
i=0 
m=1 
By rearranging the terms, we obtain the transfer function of an IIR filter expressed as 
( )  y z( )
x z  = x z( )
∑
l−1 
b z−1 
i 
i=0
0 + b1z−1 +
+ L−1Z −+
b 
 b
L 1 
= 
m 
= 
−
+
 
(13.6) 
−1 
a0 + a z −1 +a
z
am 1 
m 1 
1+∑a z−m 
1 
− 
m 
m+1 
The IIR filter is expressed as the ratio of polynomials in z–l with (L − 1) zeros and (M − 1) poles. The 
roots of the numerator and the denominator polynomials determine zeros and poles, respectively. 
To ensure a stable filter, all of the poles must be placed inside the unit circle in the z-plane. The IIR 
filter provides greater flexibility in the filter design since both the poles and zeros contribute to the 
frequency response. 

216 
Digital Signal Processing 
13.2.3 FiLter CHaraCteristiCs 
The coefficient vector of the FIR filter is identical to the impulse response of the filter. However, the 
impulse response of the IIR filter is not similar to the coefficient vector. The length of the impulse 
response for the IIR filter can be infinity; thus, the filter is called the infinite-impulse-response filter. 
The transfer function is given in Equation (13.6) and can be evaluated on the unit circle to obtain 
the frequency response expressed as 
∑
L−1 
b e− j i
w 
i 
( )z e
jw 
i=0
H( )
w = H z =
= 
m−1 
(13.7) 
− j m
w
1+∑a e
m 
i=0 
The frequency response is a function of the continuous-frequency variable and is a periodic function 
with a period equal to 2. Therefore, we only need to evaluate the frequency response from 0 to 2π 
or from −π to π. The DFT can be applied to evaluate the frequency response H(ω) at equally-spaced 
frequency points ωk = 2πk/N, k = 0,1, … , N − 1. 
The magnitude response │H(ω)│and the phase response ¢ (ω) are periodic functions with a 
period of 2π. If the IIR filter has real-valued coefficients, the real part of the frequency response 
is an even function, and the imaginary part is an odd function. As such, the magnitude and phase 
responses are even and odd functions, respectively, expressed as 
X( )
w = X(−w) 
( )  = −
(
). 
(13.8) 
and f w  
f 
Therefore, we only need to compute the magnitude and phase responses from 0 to π for IIR filters 
with real coefficients. 
The FIR filter with symmetric coefficients has a linear-phase response. The IIR filter, however, 
is not able to guarantee a linear-phase response, which also implies that the IIR filter is not able to 
produce a constant phase (or group) delay. 
Given an IIR filter with coefficient vector b = [1 1.5] and a = [1 −0.25 0.6], the transfer function 
of the filter given as 
1
0 5 
. z
+
H z  =
( )  1
0 25 z -1 + 0 6. z -2
- . 
This function shows that the impulse response is no longer related to the coefficient vectors b and a. 
We can use the MATLAB functions impz, freqz, grpdelay, and z-plane to analyze the preceding 
transfer function as follows: 
clc; 
clear all; 
b =[1 1.5] 
a = [1 -.25 0.6] 
figure 
impz(b,a); pause; 
zplane(b,a); pause; 
freqz(b,a); pause; 
grpdelay(b,a); pause; 
The impulse response, pole-zero diagram, and magnitude and phase responses are shown in 
Figure 13.7. From these results, we observe that the impulse response of a stable IIR filter con-
verges (decays) to a minimum value as time increases. The pole-zero plot shows both the pole and 
zero locations. For a stable IIR filter, all poles must lie inside the unit circle. From the magnitude 

Digital Filters 
217 
FIGURE 13.7 Characteristics of an IIR filter: (a) Impulse response, (b) pole-zero diagram, and (c) magnitude 
and phase responses. 
response shown in Figure 13.7c, the filter is a low-pass filter. However, the phase is nonlinear within 
the pass-band; thus, the group delay is no longer a constant over the pass-band. 
13.3 FINITE IMPULSE RESPONSE (FIR) DIGITAL FILTER 
FIR 
The finite impulse response filter is a filter whose impulse response is of a finite duration because 
it settles to zero in finite time. This contrasts with infinite-impulse-response filters, which may have 
internal feedback and may continue to respond indefinitely (usually decaying). 
A FIR digital filter has a finite number of non-zero coefficients of its impulse response: 
h n  0
for 
( )  = 
n > M 
The mathematical model of a causal FIR digital filter: 
M −1 
y n  =∑h k x n  
( )  ( 
(13.9) 
( )  
− k) 
k =0 

218 
Digital Signal Processing 
Digital FIR filters cannot be derived from analog filters since causal analog filters cannot have a 
finite impulse response. In many digital signal processing applications, FIR filters are preferred over 
their IIR counterparts. 
13.3.1 tHe advantages oF Fir FiLters 
• FIR filters have a linear phase. Linear-phase filters are important for applications where 
frequency dispersion due to nonlinear phase is harmful (e.g., speech processing). 
• FIR filters are stable. 
• Excellent design methods are available for various kinds of FIR filters. 
• Infection finite-precision errors: FIR filters are less sensitive to finite-precision errors 
effects such as coefficient quantization errors and round-off noise. 
13.3.2 Fir sPeCiFiCations 
A filter specification is usually based on the desired magnitude response. For example, the specifica-
tion for a low-pass filter illustrated in Figure 13.8. The pass-band is defined as the frequency range 
over which the input signal is passed with approximate unit gain. Thus, the pass-band is defined by 0 
≤ω ≤ω1, where wp is called the pass-band-cut-off (edge) frequency. The width of the pass-band is 
usually called the bandwidth of the filter. For a low-pass filter, the bandwidth is ω1. The input-signal 
components that lie within the stop-band are attenuated to a level that effectively eliminates them 
from the output signal. The stop-band is defined by ω1 ≤ω ≤ω2 ≤π, where ω2 is called the stop-
band-edge frequency. The transition band is defined as ω1 < ω < ω2, which is between the pass-band 
and the stop-band. In this region, the filter magnitude response is typically, 
A1 = 20Log 10 (1+ d1 ) db 
(13.10) 
and 
A = −20
10 d ) db 
2 
Log ( 2 
(13.11) 
For example, suppose that δ1= 0.1 and δ2= 0.01, we have A1 = 20log10 (1.1) = 0.828 dB and A2 = −20 
log10 (0.0l) = 40 dB. 
There are two MATLAB functions (syntax given below), that can be used to perform this filter-
ing process: 
Passband 
Transition 
band 
Stopband 
1+ 1 
1- 1 
1 
0 
1 
2 
H( ) 
A1 
A2 
FIGURE 13.8 Low-pass filter specification. 

Digital Filters 
219 
Zi = filter
,
 
B A Y  Xi )
( 
, ,
i 
y = filter
,
 
B A x  Zi
( 
, ,  ) 
where B and A are vectors for the coefficients given as 
A = [1a a …a 
and B = [b b b  …b
1
2
 
N ] 
0
1
2
 
M ] 
Xi and Yi are the vectors containing the initial conditions. Also x,y is the input and system output 
vectors. 
The function filtic is used to obtain the initial states required by the second function filter. The 
function filter is based on the direct-form II realization to implement a digital filter from its differ-
ence equation form. 
The following MATLAB code illustrates how to solve by using filtic and filter MATLAB 
functions. 
clear all; 
b = [0 1 2]; 
a = [1 0 -2.5]; 
Xi = [-1 0]; 
Yi = [0 1]; 
Zi = filtic(b, a, Yi, Xi); 
n = 0:5; 
x = (0.95).^n; 
y = filter(b, a, x, Zi) 
y = 1.5000 -1.0000 6.7000 0.3025 19.4124 3.2855 
13.3.3 giBBs PHenomenon and diFFerent windowing 
Direct truncation of the impulse response leads to the well-known Gibbs phenomenon. It manifests 
itself as a fixed percentage overshoot and ripple before and after a discontinuity in the frequency 
response. 
The effect of the windowing is that the ripple from the side lobes produces a ripple in the result-
ing frequency response. The windows may satisfy some reasonable optimality criterion: 
a) The small width of the main portion of the frequency response of the window containing 
as much the total energy as possible. 
b) Side lobes of the frequency response that decrease in energy rapidly as ω tends to π. 
13.4 COMPARISON OF IIR AND FIR DIGITAL FILTERS 
IIR type digital filters have the advantage of being economical in their use of delays, multipliers, 
and adders. They have the disadvantage of being sensitive to coefficient round-off inaccuracies and 
the effects of overflow in fixed-point arithmetic. These effects can lead to instability or serious dis-
tortion. Also, an IIR filter cannot be an exactly linear phase. 
FIR filters may be realized by non-recursive structures which are simpler and more convenient 
for programming, especially on devices specifically designed for digital signal processing. These 
structures are always stable, and because there is no recursion, round-off, and overflow errors are 
easily controlled. A FIR filter can be a linear phase. The main disadvantage of FIR filters is that 
large orders can be required to perform fairly simple filtering tasks. Table 13.1 shows the important 
difference between using IIR or FIR. 

220 
Digital Signal Processing 
TABLE 13.1 
Difference between IIR and FIR 
IIR 
FIR 
Efficiency 
More than FIR. 
Less. 
Design 
Complex in design than FIR. 
Easy to design. 
Phase Linearity 
Difficult to control, nonlinear. 
Linear phase always possible. 
Stability 
Can be unstable because of feedback. 
Always stable (no feedback). 
Order 
Less. 
More. 
History 
Derived from analog filters. 
No analog history. 
PROBLEMS 
13.1 Given the difference equation 
y n  = x n − ) − .
( − ) + . 
y n
( )  ( 
1
0 75 y n  1
0 125 ( − 2) 
a. Use the MATLAB functions filter() and filtic() to calculate the system response y(n) for 
, ,  
 with the input of x n  ( . )
( ) 
−
 −
= 
y 
)
2
n = 0 1 2 3 4
, ,
( )  = 0 5 nu n   and initial conditions:x(
)
−
=
1 
1, ( 2 
and y(−1) = 1; 
b. Use the MATLAB functions filter() and filtic() to calculate the system response 
y(n
n
, , , ,  with the input of ( )  = 0 5 nu n
) for 
= 0 1 2 3 4
x n  ( .  )
( )  and zero initial conditions: 
x(
)
−
=
1
0 y −
=
) 0 and y(−1) = 0. 
, ( 2 
13.2 Given the filter 
1 − z−1 + z−2 
H z  =
( )  1
0 9
 
z−1 + 0
 
81 
. 
z−2
− . 
a. Plot the magnitude frequency response and phase response using MATLAB. 
b. Specify the type of filtering. 
c. Find the difference equation. 
d. Perform filtering, that is, calculate y(n) for the first 1,000 samples for each of the following 
inputs using MATLAB, assuming that all initial conditions are zeros and the sampling 
rate is 8,000Hz: 
3
(1) x n
( )  = cos(p ⋅10 ⋅ n / 8000) 
(2) x n
( )  = cos( p ⋅ 
3 ⋅ n / 
)
6
10 
8000 
 8 
3 

(3) x n
( )  = cos 
p ⋅10 ⋅ n / 8000
 3 
 
e. Repeat part (d) using MATLAB function filter(). 
13.3 Find H(z) for the following difference equations 
(a) y n
[ ]  = 2x n  −3 [ 
] 
x n
[ ]
 x n −
+
 [ −4]
1
6
 
(b) y n  = x n − ] − [ − ] − 0 5y n
[ ]  [
1 
y n  1 
.
[
 − 2] 
13.4 Show that passing any sequence {x[n]} through a system with H(z) = z−1 produces {x[n − 1]} 
i.e., all samples are delayed by one sampling interval. 
13.5 Calculate the impulse response of the digital filter with 
1
H z( )  = − z−1
1
2
 

Digital Filters 
221 
L1 
L2 
x[n] 
y[n] 
{h1[n]} 
{h2[n]} 
FIGURE 13.9 System for Problem 13.7. 
13.6 Draw the signal-flow graph, for Example 13.5 and plot its poles and zeros. 
13.7 If discrete-time LTI systems L1 and L2, with impulse responses {h1 [n] } and {h 2 [n]}, 
respectively, are serially cascaded, as shown in Figure 13.9, calculate the overall impulse 
response. Show that this will not be affected by interchanging L1 and L2. 
13.8 Design a fourth-order band-pass IIR digital filter with lower and upper cut-off frequencies at 
300 Hz and 3,400 Hz when fS = 8 kHz. 
13.9 Design a fourth-order band-pass IIR digital filter with lower and upper cut-off frequencies at 
2,000 Hz and 3,000 Hz when fS = 8 kHz. 
13.10 What limits how good a notch filter we can implement on a fixed-point DSP processor? 
In theory, we can make a notch sharper and sharper by reducing the –3dB bandwidth and/ 
or increasing the order. What limits us in practice? 
How sharp can a notch get in 16-bit fixed pt arithmetic? 
13.11 What order of FIR filter would be required to implement a π/4 notch approximately as good 
as a second-order IIR π/4 notch with 3 dB bandwidth 0.2 radians/sample? 
13.12 What order of FIR low-pass filter would be required to be approximately as good as the 
second-order IIR low-pass filter (π/4 cut-off) designed in these notes? 


14 Implementation of IIR 
There are many different structures for realizing digital IIR filters, and we need to understand 
and determine a suitable arrangement for a particular application. The factors to be consid-
ered include errors in quantizing filter coefficients, noise introduced by fixed-point arithmetic, 
propagation of quantization errors, computational load, memory usage, and programming con-
sideration and flexibility. In this section, we examine the following commonly used IIR filter 
structures: 
1. Direct form I 
2. Direct form II 
3. Cascade form 
4. Parallel form 
5. Transposed direct form I 
6. Transposed direct form II 
14.1 DIRECTION-FORM I REALIZATION 
The transfer function of a digital filter is given by 
Y z  
b + b z
 
−1 ++ b z − M 
( )
H z( )  = 
( )  = 
0
1 
−1 
M 
− N = B z  
(14.1) 
X z  
1+ a z  ++ a z  
A z
( )  
1 
N 
( )
This expression can also be written as 
Y z  = H z X z( )
(14.2) 
( )  
( )  
or 
b + b z
 
−1 ++ M 
− M 
Y z( )  =
−1 
− N 
X z
 0
1 
b z 
 ( )
(14.3) 
 1+ a z  ++ a z   
1 
N 
Taking the inverse z-transform of the Equation (14.2) yields the difference equation 
y n  = b x n
 
+ 
(
)  b x(n
M
( )  
0 ( )  b x n  
1 
−
+
 +
 
1 
M 
− 
) 
−a y n
 
1 ( −1) − a y n  
( − 2) − − N ( −
2 
a y n
N) 
(14.4) 
This difference equation can be realized by a direct-form I realization. We introduce the product 
and delay block diagram as shown in Figure 14.1. 
The direct-form I realization of the difference Equation (14.3) is given in Figure 14.2. 
The direct-form I realization of the second-order IIR filter (N = M = 2) is given by 
b x n  −
+
1 
−
−a y n  
(14.5) 
y n
( )  = b x n
 
0 ( )  + 
(
) b x n
 
2 (
2) 
1 ( −
−
) a y n 
2 ( −2)
1
1 
As shown in Figure 14.3. 
223 

224 
Digital Signal Processing 
FIGURE 14.1 Product and delay block diagram. 
x(n) 
y(n)
b0 
b1 
b2 
-a1 
-a2 
-aN
bM 
x(n-1) 
x(n-2) 
x(n-M) 
y(n-1) 
y(n-2) 
y(n-N) 
+ 
Z–1
Z–1 
Z–1 
Z–1 
Z–1 
Z–1 
FIGURE 14.2 Direct-form I structure. 
Z–1 
Z–1 
Z–1 
Z–1 
x(n) 
y(n) 
b0 
b1 
b2 
-a1 
-a2 
x(n-1) 
x(n-2) 
y(n-1) 
y(n-2) 
+ 
FIGURE 14.3 Second-order direct-form I structure. 
14.2 DIRECTION-FORM II REALIZATION 
Using the digital filter transfer function, we can write 
B z( )  
 X z( )
Y z  = H z X z  
( )  = A z( )  ( )  = B z  A z 
( )  
( )  
X z  
( )  
(14.6) 
( )  
The expression can also be written as 

Implementation of IIR 
225 
Y z( )  = b + b z
 
−1 + + b z − M 
 1+ a z−1 + + a z− N 
( 0
1 
M 
) 
X z( )  
 
(14.7) 
1 
N 
By defining 
1
W z( )  =
−1 
− N X z( )
(14.8) 
+ a z  + + a z
1
1 
N 
We have 
−1 
− M
Y z( )  = (b0 + b z
 
++ bMz 
W z 
(14.9) 
1 
) ( )
The corresponding difference equations for Equations (14.2) and (14.3) are 
a w n
 
−
−
 ( 
2)  a w(n
N
w n
( )  = x n
( )  − 
( 
1) a w n  −
−
−
 −
) 
(14.10) 
and 
0 
b w n  −
+
 +
 
1 
M 
− 
) 
(14.11) 
1
2 
N 
y n
( )  = b w n
 
( )  +
1 ( 
)  b w(n
M
These difference equations can be implemented by a direct-form II realization as shown in 
Figure 14.4. 
The direct-form II realization of the second-order IIR filter (N
M
=
= 2) is given by the equations. 
w n  = x n  − 
( 
1) a w n  
(14.12) 
( )  ( )  a w n
 
−
−
 ( −2)
1
2 
b w n  
1 
−
+
 
)
y n
( ) = b w n
 
0 ( ) + 
( 
1) b w n 
2 ( −2 
(14.13) 
As shown in Figure 14.5. 
14.3 CASCADE (SERIES) REALIZATION 
The digital filter transfer function can be factorized and written as 
H z
( ) = H z
H
z
 
1( )⋅ 
( ) 
k( )
2 
H
z
(14.14) 
b0 
y(n)
x(n) 
Z–1 
Z–1 
Z–1 
b1 
b2 
bM 
w(n-1) 
w(n-2) 
w(n-M) 
+ 
-a1 
-a2 
-aN 
+ 
w(n) 
FIGURE 14.4 Direct-form II structure. 

226 
Digital Signal Processing 
+ 
b0 
y(n)
x(n) 
b1 
b2 
w(n-1) 
w(n-2) 
+ 
-a1 
-a2 
w(n) 
Z–1 
Z–1 
FIGURE 14.5 Second-order direct-form II structure. 
where 
k( )
H
z  is chosen as the first- or second-order transfer function (section), defined as, 
 bk0 + b z 
k1 
−1  
H
z
k( ) =
−1 
(14.15) 
 1+ a z   
k1 
or 
 b
+ b z
 
−1 + b z −2  
H
z
( ) = 
k0 
k1 
k2 
(14.16) 
k 
−1 
−2
 
+ a z
k 
+ a z  
1
1 
k2 
The block diagram for the cascade (or series) realization is shown in Figure 14.6. 
For the individual first or second-order transfer function (section), one can use either direct-form 
I or direct-form II realizations. 
14.4 PARALLEL REALIZATION 
The digital filter transfer function can be written as 
( )  
++ H
z
H z = H z  H
z
 
( ) + 
( )  
( )
(14.17) 
1
2 
k 
where 
k( )
H
z  is chosen as the first- or second-order transfer function (section), defined as, 
 
bk0 

H
z
k( ) = 
(14.18) 
 1+ a z−1  
k1 
or 
 
bk0 + b z 
k1 
−1 
 
H
z
k( ) =
−1 
−2 
(14.19) 
k1 
k2
 1+ a z  + a z
 
The block diagram for the parallel realization is shown in Figure 14.7. 
Here again, for the individual first- or second-order transfer function (section), one can use either 
direct-form I or direct-form II realizations. 
FIGURE 14.6 Cascade (or series) realization. 

227 
Implementation of IIR 
FIGURE 14.7 Parallel realization. 
Example 14.1 
Given a second-order transfer function 
−1
0 5 1 
. ( − z ) 
−1 
−2
H z
( ) = 
1 1 3
 
z + . 
z )
( + . 
0 36 
Perform the filter realizations and write the difference equations using the following realizations 
(1) Direct-form I and direct-form II 
(2) Cascade form via the first-order sections 
(3) Parallel form via the first-order sections 
SOLUTION 
Part (1): The transfer function in its “delay” form can be written as 
. − . z −2
0 5  0 5  
H z  =
( )  1 1 3
 
z −1 + . 
z −2
+ . 
0 36 
Comparing it with the standard delay form of the transfer function 
b0 + b1z −1 +  + bMz −M 
( ) =
H z  
1+ a z −1 +  + a z −N 
1 
N 
We identify, that M = 1, N = 2, and 
b0 = 0 5  b = 0 0  
2
1 
. ,  b = −0 5
. ,  
. 
a1 = 1 3  a2 = .
. ,  
0 36 
The difference equation form for the direct-form I realization is given by 
( )  0 5  
−
−
 ( 
)
. 
y n
y n  =
.
( )
 
x n  −0 5
. x n
( 
2
1 3
 
) 
. y n  1 
0 36
 
( −)
−
−
 
2 
The direct-form I realization for this filter shown in Figure 14.8. 
For the direct-form II realization, we write the difference equation as made up of the following 
two difference equations 
w n  = x n  −.
( 
)
. 
w n  2
( )  ( )
1 3w n −
−
1
0 36 ( −) 
y n  = . w n  − . w n − )
( )  0 5
( )
 
0 5
( 
2 
The direct-form II realization of the filter is shown below in Figure 14.9. 
Part (2): For the cascade realization, the transfer function is written in the product form. This is 
achieved by factorization of the numerator and the denominator polynomials. The given transfer 
function is 

228 
Digital Signal Processing 
x(n) 
y(n) 
0.5 
-0.5 
-1.3 
-0.36 
x(n-1) 
x(n-2) 
y(n-1) 
y(n-2) 
+ 
Z–1 
Z–1 
Z–1 
Z–1 
FIGURE 14.8 The direct-form I realization of Example 14.1. 
0.5 
y(n)
x(n) 
-0.5 
w(n-1) 
w(n-2) 
+ 
-1.3 
-0.36 
+ 
w(n) 
Z–1 
Z–1 
FIGURE 14.9 The direct-form II realization of Example 14.1. 
−2
0 5 1 
. ( − z )
( )
H z  = 1 1 3z −1 + . 
z −2
+ . 
0 36 
The numerator polynomial can be factorized as 
( )  0 5 1 
−2 
0 5 1  
−1 
−1
B z  = . ( − z ) = . ( − z )(1+ z ) 
The denominator polynomial can be factorized as 
A z  =
+ . z −1 + . 
z −2 =
+ . z −1 + . z −1 + . 
z −2
( )  1 1 3 
0 36 
1 0 4 
0 9 
0 36 
( 
)
(1 0 4z )
= 1 1  0 4
+ . z −1 + 0 9
. z −1 
+ . 
−1 
. 
)
−1 
−1
=
+
(1 0 4z (1 0 9
+ . z ) 
Therefore, the transfer function can be written as 
0 5 1 
−1 
−1 
. ( − z )(1+ z )
H z  =
( )  (1 0 4z −1)(1 0 9
+ . z −1)
+ . 
or 
 . − . z −1 1+ z −1 
0 5  0 5
H z  = 
H z  H ( )
( )  
 1 0 4
+ . z −1  + . z −1 = 
1( )⋅ 
2 z
1 0 9 

229 
Implementation of IIR 
Thus, in this case 
0 5  0 5  
. z −1 
. −
H z  = 
1( )  1 0 4 
+ . z −1 
1+ z −1 
H z
( ) =
−1
2 
1 0 9
+ . z 
H1(z) and H2(z) can both be realized in direct-form I or direct-form II. Overall, we get the cas-
caded realization with two sections. It should be noted that there could be other forms for H1(z) 
1+ z −1
. − . 
−1
0 5  0 5z
( )  
−1 , H z  
−1 , to yield
and H2(z); for example, we could have taken H z
1 
= 
2( ) = 
1 0 4
+ . z 
1 0 9
+ . z 
the same H(z). Using the former H1(z) and H2(z), and using direct-form II realizations for the two 
cascaded sections as shown in Figure 14.10, we get the following difference equations: 
 
0 5  0 5  
. z −1
. −
Part (1):  H z = 
 
1( )  1 0 4
+ . z −1  
w n = x n
( ) − 0 4  ( 
1( )  
. w n − 1) 
y n = 0 5w n
( ) − .
( − 1
( )
. 
0 5w n  ) 
 
1+ z −1  
1 
1
1 
Part (2):  H z =
−1
 
2( )  1 0 9
+ . z  
2
. w n − 1
w n
( ) = y n
1( ) − 0 9
2( 
) 
y n = w n
( ) + w n − 1)
( )
2 
2( 
Part (3): For the parallel realization, the transfer function is written in partial fraction form. The 
given transfer function is 
0 1  −2 
.( − z )
( )
H z  = 1 1 3z −1 + . 
z −2
+ . 
0 36 
Multiplying the numerator and denominator with z2 we get 
2
0 5
. (z − 1)
H z = 
2
( )  z + . z + 0 36
1 3  
. 
The denominator polynomial can be factorized as 
( )  
2 
1 3  
0 36 
2
0 4 
0 9 + .
A z  = z + . z + . 
= z + . z + . z 0 36 
= 
0 4 
. ) = 
+ 0 9)
1(z + . ) + 0 9 
. z z(
+ 0 4 
(z + 0 4
. )(z 
. 
Therefore, the transfer function can be written as 
0 5
. (z2 − 1)
H z  =
( )  z + . 
z + 0 9)
( 
0 4)( 
. 
0.5 
1 
y(n)
x(n) 
-0.5 
+ 
y1(n) 
-0.4 
+ 
w1(n) 
1 
+ 
-0.9 
+ 
w2(n) 
Z–1 
Z–1 
FIGURE 14.10 Cascaded realization Example 14.1. 

230 
Digital Signal Processing 
or 
2
( )  
0 5
. (z − 1)
H z  = 
z 
z z + 0 4
. )(z + 0 9
.
(
) 
Writing it into partial fractions form, 
H z
A 
C 
=
+ 
z 
( )  
z 
(z + 
B 
0 4
. )
+ (z + 0 9
. ) 
where 
 
0 5(z2 −1)

. 
0 5(z2 −1)
. 
A
z 

= 
= 
= − .
1 39
z z(
+ 0 4
. (z + . 
0 9  
z 0 4)(z + 0.9)
(
+ .
 
)
) 
z=0
z=0 
2 
2
 
0 5(z −1)
 
0 5(z −1)
. 
0 4  
= 
= −2 1
.
B = (z + . )
 z z + 
.
0 4  z + 0 9   
z(z 
0 9)
+ .
( 
. )( 
. ) 
z=− .
0 4
z=−0 4
. 
c = (z + 0 9)


0 5
. (z2 −1) 


0 5(z2 −1)
. 
. 
= 
= 0 21
. 
z z + 0 4  z + 0 9  
 
.
. 
z(z 
0 4)
+ .
( 
)( 
) 
z=−0 9
.
z=−0 9
. 
Therefore, 
H z
( )  − . 
− .
.
1 39 
2 1 
0 21 
z 
= 
z 
+ (z + 0 4
. )
+ (z + .
0 9) 
or 
2 1z 
0 21 
. z
1 39 −
H z
( ) = − . 
(z + 
.
. )
+ (z + 0 9)
0 4  
. 
In delay form, it can be written as 
2 1
. 
.
0 21
H z = −1 39 
. 
+ . 
−1 
−1
( )  
−(1 0 4z )
+ (1 0 9
+ . z ) 
or we can write it as 
H z = H z + 
( ) + H z
( )  
( )  H z  
( )
1
2
3 
This filter shows that there are three sections in the parallel realization. They can be individually 
realized using either direct-form I or direct-form II realizations. We use the direct-form II realiza-
tion. The difference equations for each of the three parallel sections are 
Section 1: H z
( )
1 39
( 
1 
= − . ) 
y n = −1 39 x n
1( )  
.
( )
 
2 1  
 
Section 2: H z = − 
. 
 

( )  
 
2 
(1 0 4
+ . z −1) 

 
w n = x n − 0 4
. 
2( − 1)
2( )  ( )  
w n  
y n
( ) = . w n
2 
2 1  2( ) 


0 21
.
Section 3:  
H z
3( ) =

1 0 9
( +
−1) 
. z 

231 
Implementation of IIR 
FIGURE 14.11 Parallel realization Example 14.1. 
w
n = x n
( )  − 0 9  (
( )  
. w
n − 1)
3
3 
y n = − . w
n
3( )  0 21 3( ) 
The output is y n
( )  = 
1( )  + 
2( )  + 
3( )
y n  y n  y n and the parallel realization is shown in Figure 14.1 . 
14.5 TRANSPOSED-DIRECT-FORM-I 
The transposition theorem uses to convert the direct-form I realization into the transposed IIR filter 
shown in Figure 14.12. We can note the changes in the signal flow, adder nodes, and branching 
nodes in the transposed IIR filters. By setting ai = 0 for i = 1,2, … , M – 1, we obtain the transposed 
structure of the FIR filter. 
Both direct-form and transposed-form IIR filters are very sensitive to quantization errors because 
quantization errors in the feedback section are fed back and accumulated in the filter, which becomes 
severe when the filter order is high. A more robust structure for reducing quantization errors is to 
break down the high order IIR filter into a cascade of second-order IIR filters (or bi-quads). The 
general expression of cascading K bi-quads to form a 2X-order IIR filter is 
bk0 + b z + k2
H Z  = G∏ 
k
k( )  = G∏ 
k
k1 
−1 
−1 
b z 
−2 
−2 
(14.20)
( )  
H z 
1+ a z  + a z  
k=1 
k−1 
k1 
k2 
bo
y(n) 
+ 
x(n) 
+ 
+ 
-a1 
-a2 
+ 
b1 
b2 
Z–1 
Z–1 
Z–1 
Z–1 
FIGURE 14.12 Transposed-direct-form-I. 

232 
Digital Signal Processing 
where G is a gain. An example of cascading two bi-quads to form a fourth-order IIR filter is 
shown in Figure 14.12. Cascading a single first-order IIR filter with a series of filter transposi-
tions may also be called flow graph reversal, and transposing a single-input/single-output (SISO) 
filter does not alter its transfer function. This fact can be derived as a consequence of Mason’s 
gain formula for signal-flow graphs or Tellegen’s theorem (which implies that a LTI signal-flow 
graph is entered reciprocally with its transpose). Transposed-direct-form-I implementation is a 
second order IIR digital filter. Note that the input signal comes in from the right, and the output 
is on the left. 
14.6 TRANSPOSED-DIRECT-FORM-II 
Figure 14.13 shows the transposed-direct-form-II structure. To facilitate comparison of the trans-
posed with the original, the input and output signals remain “switched,” so that signals generally 
flow right-to-left instead of the usual left-to-right. 
Example 14.2 
Find H(z) for the difference equation: 
y n  = x n
[ ]+ x n − 1]
[ ]  
[ 
SOLUTION 
The impulse response is: {h[n]} = {…, 0, 1, 1, 0,… } 
∞ 
1 
∴H z  = ∑h n z
 
= ∑h n z  
[ ]  =
( )  
[ ]  −n 
−n 
1+ z−1
n=−∞ 
n=−0 
Example 14.3 
Find H(z) for the recursive difference equation: 
y n
[ ]  = a x n
a x n  
[ ]+ 
[ −
−b y n −1]
0 
1
1] 
1 [ 
x(n)
y(n) 
b1 
b2 
bo 
-a1 
-a2 
+ 
+ 
+ 
Z–1 
Z–1 
FIGURE 14.13 Transposed-direct-form-II. 

233 
Implementation of IIR 
SOLUTION 
Remember that if x[n] = zn then y[n] = H(z) zn, y[n – 1] = H(z) zn – 1 etc. Substitute this into the dif-
ference equation to obtain: 
H z
( )zn = a z n + a z n − 1 − bH z z n − 1
0 
1 
1 ( )  
Therefore, 
a + a z−1 
( )  =
H z  
0
1 
−1
1+ b z
1 
except when z = –b 1. When z = –b 1, H(z) = ∞. 
By the same method, H(z) for a general digital filter whose difference equation was given 
earlier is: 
a + a z−1 + a z−2 +  + a z−N 
H z
( )  = 
0
1 
2 
N 
(with b = 1) 
(14.21)
b + b z−1 + b z−2 +  + b z−M 
0 
0
1 
2 
M 
Given H(z) in this form, we can easily go back to its difference equation and hence its signal-flow 
graph, as illustrated by the following example. 
Example 14.4 
Give a signal-flow graph for the second-order digital filter with: 
a + a z−1 + a z−2 
( )  =
H z  
0 
+ 1
1 
−1 
2
2 
−2
1 b z  + b z  
SOLUTION 
The difference equation is: 
[ ]
0 
1 
−
+
2 
−
−
1 [
] 
2 [
y n  = a x n
a x n
[ ]+ 
[ 
1] a x n
[ 
2] b y n −
−
1 b y n −2]
The signal-flow graph in Figure 14.14 is readily deduced from this difference equation. It is 
referred to as a second-order or “bi-quadratic” IIR section in “direct-form I.” 
Alternative signal-flow graphs can generally be found for a given difference equation. Considering 
again the “direct-form I” bi-quadratic section in Figure 14.14, re-ordering the two halves in this 
signal-flow graph provides Figure 14.15 which will have the same impulse response as the sig-
nal-flow graph in Figure 14.14. Now observe that may be simplified to the signal-flow diagram in 
+ 
+ 
+
+ 
x(n) 
y(n)
a0 
a1 
a2 
-b1 
-b2 
Z–1 
Z–1 
Z–1 
Z–1 
FIGURE 14.14 “Direct-form I” Bi-quadratic section. 

234 
Digital Signal Processing 
a0 
y(n)
x(n) 
+ 
+ 
-b1 
-b2 
+ 
+ 
a1 
a2 
Z–1 
Z–1 
Z–1 
Z–1 
FIGURE 14.15 “Direct-form I” rearranged. 
x(n) 
y(n) 
+ 
+ 
-b1 
-b2 
+ 
+ 
a0 
a1 
a2 
W 
W1 
W2 
Z–1 
Z–1 
FIGURE 14.16 “Direct-Form II” Bi-quadratic section. 
Figure 14.16 which is known as a “direct-form II” implementation of a bi-quadratic section. It has 
the minimum possible number of delay boxes and is said to be “canonical.” Its system function is 
identical to that of the “direct-form I” signal-flow graph, and therefore it can be implemented any 
second-order bi-quadratic system function. 
14.7 IMPLEMENTATION OF A NOTCH FILTER BY MATLAB 
Assume, we want to design a fourth-order “notch” digital filter to eliminate an unwanted sinusoid at 
800 Hz without severely affecting the rest of the signal. The sampling rate is FS = 10 kHz. 
One simple way is to use the MATLAB function “butter” as follows: 
FS=10000; 
FL = 775; FU = 825; 
[a b] = butter(2, [FL FU]/(FS/2),'stop'); 
a = [0.98 -3.43 4.96 -3.43 0.98]; 
b = [1 -3.47 4.96 -3.39 0.96]; 
freqz(a, b); 
freqz(a, b, 512, FS); 
axis([0 FS/2 -50 5]); 
The frequency responses (gain and phase) produced by the final two MATLAB statements are 
as in Figure 14.17. 
Since the Butterworth band-stop filter will have –3 dB gain at the two cut-off frequencies 
FL = 775 and FU = 825, the notch has “–3 dB frequency bandwidth”: 25 + 25 = 50 Hz. 

235 
Implementation of IIR 
–40 
–20 
0 
Magnitude (dB) 
–400 
–300 
–200 
–100 
0 
Phase (degrees) 
0 
500 
1000 
1500 
2000 
2500 
3000 
3500 
4000 
4500 
5000 
Frequency (Hz) 
0 
500 
1000 
1500 
2000 
2500 
3000 
3500 
4000 
4500 
5000 
Frequency (Hz) 
FIGURE 14.17 The frequency responses (gain and phase). 
Now consider how to implement the fourth-order digital filter. The MATLAB function gave us: 
a = [0.98 -3.43 4.96 -3.43 0.98] 
b = [1 -3.47 4.96 -3.39 0.96] 
The transfer (system) function is, therefore, 
. z−1 + . z−2 − . z−3 + . z−4
 0 98
3
 
43 
. 
− 
4 96 
3 43 
0 98 
 
H z( )  =

− 
−1 
−
−3 
−4
1
3
 
47 
. z + 4 96 
. z 2 − 3 39 
. z + 0 96 
. z 
 
A “direct-form II” implementation of the fourth-order notch filter would have the signal-flow graph 
shown if Figure 14.18. 
This implementation works adequately in MATLAB. But “direct-form” IIR implementations of 
order greater than two are rarely used. Sensitivity to round-off error in coefficient values will be 
high. Also, the range of “intermediate” signals in the z–1 boxes will be high. 
High word-length floating-point arithmetic hides this problem, but in fixed-point arithmetic, 
great difficulty occurs. Instead we use “cascaded bi-quad sections.” 
Given a fourth-order transfer function H(z). Instead of the direct-form realization in Figure 14.19: 
we prefer to arrange two bi-quad sections, with a single leading multiplier G, as in Figure 14.20: 
MATLAB will convert the fourth-order transfer function H(z) to this new form. Do it as follows 
after getting a and b for the fourth-order transfer function, H(z), as before: 
[a b] = butter(2, [FL FU]/(FS/2),’stop’); 
[SOS G] = tf2sos(a,b) 
• MATLAB responds with: 
SOS = 1 -1.753 1 1 -1.722 0.9776 
1 -1.753 1 1 -1.744 0.9785 
G = 0.978 

236 
Digital Signal Processing 
x(n) 
y(n) 
+ 
+ 
3.47 
+ 
+ 
0.98 
-3.43 
+ 
-4.96 
+ 
4.96 
+ 
3.39 
-0.96 
+ 
-3.43 
0.98 
Z–1 
Z–1 
Z–1 
Z–1 
FIGURE 14.18 “Direct-Form II” implementation of the fourth-order notch filter. 
H(z)
x[n] 
y[n]
FIGURE 14.19 Equivalent fourth-order transfer function H(z). 
H1(z) 
H2(z)
x[n] 
y[n] 
G 
FIGURE 14.20 Arrange two bi-quad sections. 
In MATLAB, “SOS” stands for “second-order section” (i.e., bi-quad) and the function “tf2SOS” 
converts the coefficients in arrays “a” and “b” to the new set of coefficients stored in array “SOS” 
and the constant G. The array SOS has two rows: one row for the first bi-quad section another row 
for the second bi-quad section. In each row, the first three terms specify the non-recursive part and 
the latter three terms define the recursive part. Therefore H(z) may now be realized as shown in 
Figure 14.21. 
x(n) 
+ 
+ 
1.72 
-0.978 
+ 
+ 
1 
-1.753 
1 
y(n) 
+ 
+ 
1.74 
0.979 
+ 
+ 
1 
1.753 
1 
-1.753 
Z–1 
Z–1 
Z–1 
Z–1 
FIGURE 14.21 Fourth-order IIR notch filter recognized as two bi-quad (SOS) sections. 

Implementation of IIR 
237 
14.8 IMPLEMENTATION OF INFINITE-IMPULSE RESPONSE FILTERS 
Since the analog-filter design is a well-developed technique, a systematic approach in designing 
a digital IIR filter is to design an analog IIR filter and then convert it into the equivalent digital 
filter. An alternate method is to create a digital IIR filter directly in the digital domain by using 
the algorithmic design procedure which solves a set of linear or nonlinear equations. The former 
approach is used to design typical low-pass, high-pass, band-pass, and band-stop filters. The latter 
approach is used to design filters with arbitrary frequency responses or constraints which have 
no analog prototype filters. We briefly explain the principles of these two design techniques in 
this section. 
14.8.1 AnAlog-to-DigitAl Filter Design 
An analog low-pass filter is first designed based on commonly used analog filters such as Butterworth, 
Chebyshev I and II, and elliptic filters. It is followed by either (1) performing frequency transforma-
tions in the analog domain and then applying analog-to-digital (or the s-plane to the z-plane) map-
ping or (2) applying analog-to-digital mapping before performing the frequency transformation in 
the digital domain. The frequency transformation is the process of converting a low-pass filter into 
another low-pass, band-pass, high-pass, or band-stop filter with different cut-off frequencies using 
some mapping functions. The frequency transformation can be carried out in either an analog or a 
digital domain. 
14.8.2 BilineAr trAnsFormAtion 
A better and more commonly used the s-plane to the z-plane mapping is the bilinear transformation 
defined as 
( − z
S = T 
2 1
(1+ z 
−
− 
1
1
)
) 
(14.22) 
The bilinear transformation is a rational function that maps the left-half of the s-plane into the 
internal of the unit circle in the z-plane. It is a one-to-one mapping that maps the entire frequency 
along the jΩ-axis from −∞ to ∞ onto the unit circle (–π to π) only once. This result of a nonlinear 
relationship between analog frequency and digital frequency is expressed as 
−1 ΩT  
w = 2 tan 
(14.23) 
 2  
LPF coefficients can be found, and the response can be plotted, as shown in Figure 14.22. 
clc; 
clear all; 
close all; 
rp=0.2; % passband ripple 
rs=50; %stopband ripple 
wp=1700; % passband freq 
ws=3400; % stopband freq 
fs=8000; %sampling freq 
w1=2*wp/fs; w2=2*ws/fs; 
[n,wn]=buttord(w1,w2,rp,rs,'s'); 
[b,a]=butter(n,wn,'low','s'); 
w=0:.1:pi; 
[h,om]=freqs(b,a,w); 

238 
Digital Signal Processing 
m=20*log10(abs(h)); 
an=angle(h); 
figure 
plot(om/pi,m); 
title('IIR - LPF response '); 
xlabel(' Normalized freq.'); 
ylabel('Gain (dB)'); 
Figure 14.22 shows the response of LPF using the butter command. 
HPF coefficients can be found, and the response can be plotted, as shown in Figure 14.23. 
clc; 
clear all; 
close all; 
rp=0.2; %passband ripple 
rs=100; %stopband ripple 
wp=1500; % passband freq 
ws=3000; % stopband freq 
fs=10000;%sampling freq 
w1=2*wp/fs;w2=2*ws/fs; 
[n,wn]=buttord(w1,w2,rp,rs,'s'); 
[b,a]=butter(n,wn,'high','s'); 
w=0:.01:pi; 
[h,om]=freqs(b,a,w); 
m=20*log10(abs(h)); 
an=angle(h); 
figure 
plot(om/pi,m); 
title('IIR-HPF response'); 
xlabel('Normalized freq.'); 
ylabel('Gain (dB)'); 
Figure 14.23 shows the response of HPF using the butter command. 
FIGURE 14.22 LPF using butter command. 

239 
Implementation of IIR 
FIGURE 14.23 HPF using butter command. 
PROBLEMS 
14.1 Given a second-order transfer function 
5 1 − z−1
(
)
H z =
( )  (1+ z−1 + 3.36z−2) 
Perform the filter realizations and write the difference equations using the following 
realizations. 
(1) Direct-form I and direct-form II 
(2)Cascade form via the first-order sections 
(3)Parallel form via the first-order sections 
14.2 Given a second-order transfer function 
−1
0 5 1 
. ( − z )
H z =
( )  
1
3z−1 + . z−2)
( + 
2 5  
Perform the filter realizations and write the difference equations using the following 
realizations. 
(1) Direct-form I and direct-form II 
(2)Cascade form via the first-order sections 
(3)Parallel form via the first-order sections 
14.3 Find H(z) for the difference equation: 
y n  = x n
[ ]  + x n −1]
[ ]  
[ 
14.4 Find H(z) for the difference equation: 
y n  = x n
[ ]  + x n −1]
[ ]  
[ 

240 
Digital Signal Processing 
14.5 Find H(z) for the recursive difference equation: 
[ ]  
−
+
1
]
y n  = x n
[ ]  + x n
[ 
1] b y[n −1 
14.6 Find H(z) for the recursive difference equation: 
0
1 x n
 
−
+
1 y[n −1
y n
[ ]  = 2a x n
 
[ ]  −a
[
 1] b 
] 
14.7 Give a signal-flow graph for the second-order digital filter with: 
2
3
 
z−1 + 4 z−2
+
H z( )  = 5
6
 
z−1 + 7 z−2
+ 

15 Implementation of FIR 
In digital signal processing, a finite impulse response (FIR) filter is a filter whose impulse response 
or response to any finite length input is finite duration because it settles to zero in finite time. FIR 
filters contain as many poles as they have zeros. but all of the poles are located at the origin because 
all of the poles are located inside the unit circle, the FIR filter is ostensibly stable. This chapter will 
focus on the Implementation and design of FIR filter. 
15.1 FINITE IMPULSE RESPONSE FILTER REPRESENTATION 
A FIR filter is entirely specified by the following difference equation (input–output relationship): 
M 
b x n −
+
 + 
( −
∑b x n
i
y n
( )  = b x n
( )  + 
( 
1)  b x n
M) = 
( −) 
(15.1)
0
1 
M
i 
i= 
The frequency response of an ideal low-pass filter can be shown in Figure 15.1a. 
Mathematically it is given by 
(
)

1, 
0 ≤Ω
Ωc
≤ 
H e jΩ=  
(15.2)
0, 
Ωc ≤Ω≤p

The frequency Ωc is the low-pass cut-off frequency. It can be shown that the corresponding impulse 
response of the ideal low-pass filter is, as shown in Figure 15.1b. A truncated part of the impulse 
response is shown (the actual response extends to infinity on both sides) from n = −M to n = M. It 
is given by 
 
Ωc 
p , 
n = 0 
⎪

=
h n
( )  
(15.3) 
)
Ω
(
sin 
c n 
The impulse response is symmetric to n = 0. In this case, the z-transform of the impulse response 
is given by 
h M 
1 
+ + h
z
H z( )  = h M z
(
)
 
M + ( 
− )zM −1 
( ) 1
1 
(15.4) 
+ h( )  + h 1 z−1 +h M
( 
− M+1 
h M z M
0 
( )  
−1)z 
+ h(
)
 
− 
To obtain a causal impulse response, we shift the non-causal impulse response by M samples, to 
yield the transfer function of a causal ideal low-pass FIR filter: 
H z  
b + b z−1 + b z−2 + +
−2 M 
(15.5)
( )  = 0
1 
2 
b2Mz 
where 
bn = h(n
M) for n = , , ,
,
 M
− 
0 1 2  … 2 . 
(15.6) 

 
≠ 0 
n 
pn 
241 

242 
Digital Signal Processing 
FIGURE 15.1 Finite Impulse Response. (a) Ideal low-pass frequency response. (b) impulse response of an 
ideal low-pass filter. 
Also, we can obtain the design equations for the other types of FIR filters, such as high-pass, band-
pass, and band-stop. Table 15.1 gives the formulas for these types of FIR filters for their filter coef-
ficient calculations. 
Example 15.1 Using an FIR low-pass filter 
(a) Calculate the filter coefficients for a 3-tap with a cut-off frequency of 1,200 Hz and a 
sampling rate of 12,000 Hz using the Fourier transform method. 
(b) Determine the transfer function and difference equation FIR system. 
(c) Compute and plot the frequency response. 
SOLUTION 
Part (a): We first determine the normalized cut-off frequency 
1200
Ωc = 2 f T
c 
= 2 ×
= . p
p 
s
p 
0 2  radians 
12000 
In this case 2M + =
1 3, therefore, using Table 7.1, 
 
Ωc , 
n = 0
 
p
h n  = 
( )  
sin (Ωc n) 
 
pn 
−M
n ≤ M
≤ 
 
Therefore, 
Ωc 
0 2
. p
h( )
0 =
= 
= 0 2
. 
p
p 

243 
Implementation of FIR 
TABLE 15.1 
Summary of Ideal Impulse Responses for Standard FIR Filters 
Ideal Impulse Response h(n) (non-causal 
Filter type 
FIR coefficients) 

Ωc , 
n = 0

Low-pass 
h n  =  
p
( )  

Ωc n 
sin (
)
 
M
n
M
−
≤
≤ 
 
pn 

p −Ωc 

, 
n = 0 
High-pass 
h n  = 
sin 
p 
(
)
( )  

Ωc n
− 
−
≤
≤ 
M
n
M
 
pn 
Ω
Ω
 
 
H −
L 

, 
n = 0 
( )  
Band-pass 
h n  = 
 
ΩH n 
p 
sin ΩL n
sin
 
(
)
(
)
− 
−
≤
≤ 
M
n
M
 
pn 
pn 
 
p −
+
 
Ω
Ω
 

H
L , 
n = 0 
 
p
Band-stop 
h n  =
( )   

sin
 
ΩH n 
sin ΩL n
(
 ) +
(
 )
M
n
M
− 
pn 
pn 
−
≤
≤ 
 
Casual FIR-filter coefficients: shifting h(n) to the right by samples. 
Transfer function: H z  
b0 + b z
 
−1 + b2 z−2 + 
2 
−2 M
( )  =
+ b M z 
Where b = h(n − M) for n = 0, 1, 2, …, 2 
n
sin
 
(Ωc 
sin ( .
) 
0 2p)
h( )1 =
= 
= 0.1871
p
p 
using symmetry, h −
=
1 
h( )  0 1871
(
)
 1 =
. 
Delaying h(n) by M = 1 samples, we get Filter Coefficients 
b0 = h 0
1
 = h −
= 0.1871
( − ) 
(
)1 
b1 = h 1 1
− ) = h( )
0 = 0 2 
(
. 
1 1  ( )  = 0
 
1871
b2 = h( − ) = h 1
. 
Part (b): Therefore, the transfer function in this case is 
H z  = b + b z
 
−1 + b z−2 = . 
+ . z−1 + . 
z−2
( )  
0 
1 
2 
0 1871 0 2  
0 1871 
The difference equation is 
y n  =
. 
x n  + . x n
( 
)
. 
x n −2
( )  0 1871 (
 
)
 
0 2  
−
+
 
(
)
1
0
 
1871 
Part (c): The frequency response of the filter is 
jΩ
− jΩ
−2 jΩ
H e( 
) = 0 1871 + . e 
+ 0 1871 
. 
e
. 
0 2  

244 
Digital Signal Processing 
It can be written as 
H e jΩ= e−jΩ 0 1871e jΩ+ 0 2  + . 
e−2jΩ
(
)
( . 
. 
0 1871 
) 
−jΩ 
jΩ
− 2 jΩ
= e 
(0 2  + 0 1871(e 
))
.
. 
+ e 
−jΩ( .
. 
Ω
= e 
0 2  + 0 1871× 2cos( )) 
−jΩ 
. 
0 3742 cos Ω
= e 
(0 2  + . 
( )) 
Thus, the magnitude frequency response is 
( 
jΩ
H e ) = 0 2  + 0 3742 cos(Ω)
.
. 
And the phase response is 
−Ω, 
0 2
. + 0 3742 cos ( )  
> 0
. 
Ω
∠H e jΩ=
(
)

−
+ p 
. + . 
cos Ω
Ω 
0 2
0 3742 
( )  
< 0 
In FIR filters with symmetrical coefficients, the phase response has a linear behavior in the 
pass-band. 
It means that all frequency components of the filter input within the pass-band are subject to 
the same amount of time delay at the filter output. It is a requirement of applications in 
audio and speech filtering, where phase distortions need to be avoided. 
If the design method can’t produce the symmetrical coefficients, then the resultant FIR filter 
does not have a linear-phase property which leads to distortions in the filtered signal. This 
distortion is due to the nonlinear phase shown with the example below. 
x n = x n
( ) + 
( ) = sin( . 
n u n + 
0 15p n
x n  
0 05p ) ( )  sin( . 
u n
( )
1 
2 
) ( )
1 
n
.
( 
p 
)+ n
.
y n
( ) = si
0 05 (n − 8) 
si (0 15p (n − 8)) Linear Phase 
2( )  
n
.
 p 
)+ n
.
 (
y n = si (0 05 (n − p /2) 
si (0 15p n − p /2)) Non-Linear Phase 
The FIR filter has a good phase property, but it does not give an acceptable magnitude frequency 
response. The result with a 17-tap low-pass filter is also shown below. 
There are oscillations (ripple) in the pass-band (main lobe) and stop-band (side lobe) of the 
magnitude frequency response. This is due to Gibbs oscillations, originating from the 
abrupt truncation of the infinite-impulse-response of the low-pass filter. 
This behavior can be avoided with the help of windowing. 
Example 15.2 
(a) Calculate the filter coefficients for a 5-tap FIR band-pass filter with a lower cut-off frequency 
of 2,000 Hz and an upper cut-off frequency of 2,400 at a sampling rate of 8,000 Hz. 
(b) Determine the transfer function and plot the frequency responses with MATLAB. 
SOLUTION 
Part (a): We first determine the normalized cut-off frequencies 
WL = 2ppfL = 2 × 2000 = . p radians
p 
0 5  
fs 
8000 

245 
Implementation of FIR 
WH = 2ppfL = 2p × 2400 = .
0 6p radians 
fs 
8000 
In this case 2M +
=
1
5, therefore, from Table 7.1, 
 
W
WH −W
WL 

, 
n = 0 
 
p 
h n  = 
( )  
sin W
WH n) −sin W
WL n , 
−≤ ≤
2 
n 
2
( 
(
) 
 
np 
np 
The noncausal FIR coefficients are 
H − W
WL 
0 6pp − 0 5
. pp
W
W
.
h( )
0 =
= 
= 0 1
. 
pp
 
H 
) 
L 
) 
sin
.
(
(0 5
sin(W
 
× 1 
sin(W
 × 1 
0 6pp)
sin
.
 pp)
h( )1 = 
− 
=
−
= −0 01 558
.
5
p × 1 
p × 1 
pp
 
sin W
 
× 2 
sin W
 × 2 
(1 2  )
sin
.
 pp)
( 
H 
)
( 
L 
) 
sin
.
 pp
(1 0
h( )
2 = 
− 
=
−
= −0.09355
0
p × 2 
p × 2
2p 
2p 
Using the symmetry property 
h −
=
1 
h( )  
0 0158
(
)
 1 = − . 
h −
=
2 
h( )  
0 09355
(
)
 2 = − . 
Thus, the filter coefficients are obtained by delaying by M = 2 samples, as Filter Coefficients 
b0 = h 0
2
 = h − 
= −0.09355
− )
2
( 
(
)
 
(1 2  
(
)
 
= −0 01558
b1 = h 
− ) = h −1
. 
2
2
 ( )  = 0 1
b2 = h( − ) = h 0
. 
b3 = h 3
2
− ) = h( )1 = −0 01558
(
. 
b4 = h(4
2
− ) = h( )
2 
0 09355
= − . 
Part (b): Therefore, the transfer function in this case is 
H z  = b + b z −1 + b z −2 + b z −3 + b z −4
( )
0
1
2 
3 
4 
= − . 
−1 0 1  −2
0 09355 −0 01558 
. 
z 
+ . z 
− 0 01558z −3 − . 
−4 
. 
0 09355z 
The difference equation is 
y n  = − . 
x n  − . 
x n
( − ) + 
x n
( )  0 09355 ( ) 0 01558 
1
0 1 
− )
.
(
 2 
. 
x n
( −3 − .09355 (
−0 01558 
) 0 0
x n −4) 
Part (c): The frequency response of the filter is 
H e jW
 = −0 09355 −0 01558e−jW
 + . 
−2 jW
 
(
)
.
. 
0 1e 
−0 01558 −3 jW
 
−4 jW
 
. 
e 
−0 09355 
. 
e 

246 
Digital Signal Processing 
It can be written as 
H e jW
 = e−2 jW
 −0 09355e2 jW
 − 0 01558 
. 
e jW
 + . − . 
e− jW
 − 0 0935 5 
−2 jW
 
(
) 
( 
. 
0 1  0 01558 
. 
e 
) 
e−2 jW
 (0 1− 0 01558(e jW
 + e− jW
 ) − . 
(e2 jW
 + e−2 jW
 ))
= 
. 
. 
0 09355 
−2 jW
 ( .
. 
( 
)
. 
( 
W
 
= e 
0 1− 0 01558 2 cos(W
 ) − 0 09355 2 cos( 2 ))) 
−2 jW
 
. 
W
 
0 1871 
)
= e 
(0 1− 0.03116cos(
)
 
− . 
cos( 2W
 ) 
15.2 WINDOW METHOD 
We have seen Gibbs oscillations are produced in the pass-band and stop-band in the design of FIR 
filters which are not desirable features of the FIR filter. To solve this problem, the window method 
is developed. 
The Gibbs oscillations mainly result due to the abrupt truncation of the infinite-length coefficient 
sequence of the impulse response of the FIR filter. A window function is a symmetrical function 
which can gradually weigh the designed FIR coefficients down to zeros at both ends of for the range 
−M
n
M
≤
≤
. Applying the window sequence to the filter coefficients gives 
h
n
 h n
( )  = ( )⋅ w n
w
( )
(15.7) 
where, w(n) designates the window function. The commonly used window functions in FIR filters 
are: 
1. Rectangular Window: 
w
n
( )  = , 
M
n
M 
(15.8)
rec 
1 
− 
≤
≤
 
2. Triangular (Bartlett) Window: 
n 
w
n =
−
 , − 
≤
≤
tri ( )  1 
M
n
M 
(15.9)
M 
3. Hanning Window: 
w
n = . + . cos 
 npp

 , − M
n
M
han ( )  0 5  0 5  
≤
≤ 
(15.10)
M 
4. Hamming Window: 
w
n = . 
+ . 
cos 
 
n
M 
pp
 , − 
≤
≤ 
(15.11)
ham ( )  0 54
0 46 
M
n
M 
5. Blackman Window: 
w
n = . 
+ . cos  npp 
0 08 
. 
cos  2npp , − 
≤
≤
black ( )  0 42
0 5 
 M + 
 M  
M
n
M 
(15.12) 
Example 15.3 
(a) Calculate the filter coefficients for a 3-tap FIR low-pass filter with a cut-off frequency of 
1,000 Hz and a sampling rate of 10,000 Hz using the Hamming window function. 
(b) Determine the transfer function and difference equation of the designed FIR system. 
(c) Compute and plot the frequency response. 
SOLUTION 
Part (a): We first determine the normalized cut-off frequency 

247 
Implementation of FIR 
1000
Wc = 2 f T
c 
= 2 ×
= . p 
pp 
s
p 
0 2  radians 
10000 
In this case 2M +
=
1
3, therefore, using Table 7.1, 
 
W
Wc , 
n = 0
 
p 
h n  =
( )   sin(W
Wc n)

−M
n
M
≤
≤
 
p n 
Therefore, 
W
Wc 
0 2
. pp
h( )
0 =
= 
= 0 2
. 
pp
 
sin W
Wc) 
sin 0 2  )
(
( . pp
h( )1 =
= 
= 0.1871
pp
 
h −
=
1 
h( )  0 1871(using symmetry)
(
)
 1 =
. 
The windowed impulse response is calculated as 
hw( )  = h 0 w 
0 = . × . = .
0 
( )  ham ( )  0 2
1
 
0
0 2 
hw( )  = h
w
1 
ham 1 = . 
× . 
= .
1 
( )  
( )  0 1871 0 08
0 01497 
(
)
 (
)1 
0 08
0 01497
−
=
 −
hw(
)1 
h 
1wham −
= 0 1871 
. 
× . 
=
. 
Delaying h(n) by M = 1 samples, we get b0 = hw −1 
0.01497, b1 = h ( )
0 = 0.2, and
(
)
 
= 
w 
b2 = hw( )1 = 0.01497. 
Part (b): Therefore, the transfer function in this case is 
H z  = b + b z −1 + b z −2 = . 
+ . z −1 + . 
z −2
( )  
0 
1 
2 
0 01497 0 2  
0 01497 
The difference equation is 
y n  =
. 
x n + . x n
( 
)
. 
x n −2
( )  0 01497 ( ) 0 2  
−
+
 
(
)
1
0
 
01497 
Part (c): The frequency response of the filter is 
H e jW
 = 0 01497 
. 
+ . e− jW
 + 0 01497e−2 jW
 
(
) 
0 2  
. 
It can be written as 
H e jW
 = e− jW
 0 01497 e jW
 + 0 2  + 0 01497e−2 jW
 
(
) 
( . 
.
. 
)
− jW
 
jW
 
−2 jW
 
e 
(0 2  + 0 01497(e 
+ e
= 
.
. 
)) 
= e− jW
 (0 2
. + . 
× 2cos(W
 )
0 001497 
) 
= e− jW
 ( . + 0 02994 cos(
0 2
. 
s W)) 
Thus, the magnitude frequency response is 
H e jW
 
= 0 2  + 0 02994 cos(W
 )
.
.
(
) 
And the phase response is 
H e jW
 = −W
 ,
. + 0 02994 cos(
)
W
 > 0
0 2  
.
∠(
)

−
+ p 
. + . 
cos(W
 
W
 
0 2  0 02994 
) < 0 

248 
Digital Signal Processing 
FIGURE 15.2 Frequency response in Example 15.3. 
A MATLAB program to plot the frequency response is given in the following (Figure 15.2). 
clc; 
clear all; 
fs = 10000; 
B = [0.01497 0.2 0.01497]; 
A = [1]; 
[h w] = freqz(B, A, 1024); 
f1 = w*fs/(pi); 
Angle = 180*unwrap(angle(h))/pi; 
figure 
subplot(2,1,1), plot(f1, 20*log10(abs(h))); 
grid on; 
axis([0 fs -25 0]); 
xlabel('Frequency (Hz)'); 
ylabel('Magnitude'); 
title('Magnitude Response')' 
subplot(2,1,2), 
plot(f1, Angle); 
grid on; 
axis([0 fs -250 50]); 
xlabel('Frequency (Hz)'); 
ylabel('Phase (degrees)'); 
title('Angle Response')' 
Example 15.4 
To implement the FIR filter for a given sequence by using windowing techniques. A Finite Impulse 
Response (FIR) filter is a discrete linear time-invariant system whose output is based on the 
weighted summation of a finite number of past inputs. 

249 
Implementation of FIR 
A FIR transversal filter structure can be obtained directly from the equation for discrete-time 
convolution. 
N – 1 
y [n] = Σ X(k) h(n – k) 0 < n < N – 1 
k = 0 
In this equation, x(k) and y(n) represent the input to and output from the filter at time n. h(n – k) 
are the transversal filter coefficients at time n. These coefficients are generated by using FDS (filter-
design software or digital filter-design package). 
Types of windows available are Rectangular, Barlett, Hamming, Hanning, Blackman, etc. This 
FIR filter is an all-zero filter. 
% window function rectangular 
clc; 
clear all; 
close all; 
rp=0.02; % passband ripple 
rs=0.01; % stopband ripple 
fp=1000; %passband freq 
fs=2000; %stopband freq 
f=10000; %sampling freq 
wp=2*fp/f; 
ws=2*fs/f; 
num=-20*log10(sqrt(rp*rs))-13; 
dem=14.6*(fs-fp)/f; 
n=ceil(num/dem); 
n1=n+1; 
if(rem(n,2)~=0) 
n1=n; 
n=n-1; 
end 
y=rectwin(n1); 
%LPF 
b=fir1(n,wp,y); 
[h,o]=freqz(b,1,256); 
m=20*log10(abs(h)); 
subplot(2,1,1);plot(o/pi,m); 
title('LPF'); 
ylabel('Gain in dB'); 
xlabel(' Normalized frequency'); 
%HPF 
b=fir1(n,wp,'high',y); 
[h,o]=freqz(b,1,256); 
m=20*log10(abs(h)); 
subplot(2,1,2); 
plot(o/pi,m); 
title('HPF'); 
ylabel('Gain in dB'); 
xlabel(' Normalized frequency'); 
Figure 15.3 shows the response of a window function rectangular FIR filter for a low- and high-
pass filter. 
% window function triangular 
clc; 
clear all; 

250 
Digital Signal Processing 
close all; 
rp=0.02; % passband ripple 
rs=0.01; % stopband ripple 
fp=1000; %passband freq 
fs=2000; %stopband freq 
f=10000; %sampling freq 
wp=2*fp/f; 
ws=2*fs/f; 
num=-20*log10(sqrt(rp*rs))-13; 
dem=14.6*(fs-fp)/f; 
n=ceil(num/dem); 
n1=n+1; 
if(rem(n,2)~=0) 
n1=n; 
n=n-1; 
end 
y=triang(n1); 
%LPF 
b=fir1(n,wp,y); 
[h,o]=freqz(b,1,256); 
m=20*log10(abs(h)); 
subplot(2,1,1);plot(o/pi,m); 
title('LPF'); 
ylabel('Gain(dB)'); 
xlabel('Normalized frequency'); 
%HPF 
b=fir1(n,wp,'high',y); 
[h,o]=freqz(b,1,256); 
m=20*log10(abs(h)); 
FIGURE 15.3 Response of window function rectangular FIR filter. 

251 
Implementation of FIR 
subplot(2,1,2);plot(o/pi,m); 
title('HPF'); 
ylabel('Gain(dB)'); 
xlabel('Normalized frequency'); 
Figure 15.4 shows the response of a window function triangular FIR filter for a low- and high-
pass filter. 
Example 15.5 
(a) Design a 5-tap FIR band-reject filter with a lower cut-off frequency of 2,000 Hz, an 
upper cut-off frequency of 2,400 Hz and a sampling rate of 8,000 Hz using the Hamming 
window method. 
(b) Determine the transfer function. 
SOLUTION 
Part (a): We first determine the normalized cut-off frequencies 
2000
WL 
p L
s
0 5p radians
= 2 f T = 2p ×
= . 
8000 
2400
WH = 2 f T = 2 ×
= . p radians
p H
s
p 
0 6  
8000 
In this case 2M +
=
1
5, therefore, using Table 7.1, 
 
pp −W
WH −W
WL 

n = 0 
h n  =  
p 
( )  
sin(W
WH n)
sin(W
WH n)
+ 
2 
n
−≤ ≤2
 
np 
np 
FIGURE 15.4 Response of window function triangular FIR filter. 

252 
Digital Signal Processing 
Therefore, 
pp − W
WH − W
WL 
pp − . pp − .
h( )
0 =
= 
0 6  
0 5pp = 0 9
. 
pp
 
sin W
WH)
sin W
WH)
0 6pp)
sin
.
 pp)
(
( 
sin
.
(
(0 5
h( )1 = −
+
= − 
+ 
= 0 01558
. 
pp
 p
p 
H 
sin(W
 H2 
(1 2  
sin( )
pp
sin(2W
 )
)
sin
.
 pp)
h( )
2 = − 
+ 
= −
+
= 0.09355
2p 
2p 
pp
 
h −
=
1 
h( )  0 01558 (usingsymmetry)
(
)
 1 =
. 
h −
=
2 
h( )  0 09355 (using symmetry)
(
)
 2 =
. 
Applying the Hamming window function, we have 
w
0 = . 
+ 0 46 cos
ham( )  0 54 
. 
 0 × pp= 1 0
.
 2  
wham( )1 = . 
+ 0 46 cos 
 
1× 
2 
pp

0 54 
. 
= 0 5
. 4 
wham( )  = 0 54 + . 
cos 
 
2 × 
2 
pp
 = 0 08 
.
2 
. 
0 46 
w 
(
)
−
=
1 
wham ( )  = 0 54 (using symmetry)
ham 
1
. 
w 
(
)
−
=
2 
wham ( )  = 0 08 (using symmetry)
ham 
2
. 
The windowed impulse response is calculated as 
hw( )  = h 0 w 
0 = . × . = .
0 
( )  ham ( )  0 9
1
 
0
0 9 
h ( )1 = h
w 
( )1 = 0 01558 × .
w
( )1 
ham 
. 
0 54
0
= .00841
hw( )
2 = h 2 wham ( )  = 0 09355 × .
( )  
2
. 
=
0 08
0
 
.00748 
(
)
 (
)1 
0 54
0
 
00841
−
=
 −
hw(
)1 
h 
1wham −
= 0 01558 
. 
× . 
=
. 
hw(
)
 h 
2 
ham −
=
. 
×
=
.
(
)w 
2 
0 09355 
.
−
=
 −
2 
(
)
 
0 08
0 00748 
Delaying h(n) by M = 2 samples, we get b0 = hw −2 
0.00748, b1 = hw −1 
0.00841,
(
)
 
= 
(
)
 
= 
b2 = hw( )  = 0 9, b3 = hw 1 
0.00841 and b4 = hw( )  = 0 00748 
0
. 
( )  = 
2
. 
. 
Part (b): Therefore, the transfer function in this case is 
H z  = b + b z −1 + b z −2 + b z −3 + b z −4
( )
0
1
2 
3 
4 
= . 
−1 0 9  −2
0 00748 + 0 00841 
. 
z 
+ . z 
+ 0 00841 
. 
z −3 + . 
−4
0 00748z 
15.3 FIR-FILTER LENGTH ESTIMATION USING WINDOW FUNCTIONS 
Given the required pass-band ripples specification and stop-band attenuation, the appropriate win-
dow length can be estimated based on the performances of the window functions. For illustrative 

253 
Implementation of FIR 
purpose, we use the low-pass filter frequency domain specification (the same can be extended to 
other types of filter specifications). 
The normalized transition band frequency is defined as 
Df = 
/ fs 
(15.13) 
Based on this, the FIR-filter lengths for various window functions are given in Table 15.2 below. It 
can be noted that the cut-off frequency is determined by 
fc = ( fstop − fpass ) / 2
(15.14) 
The pass-band ripple is defined as 
d p dB = 20 ⋅ log10 (1 + d p )
(15.15) 
while the stop-band attenuation is defined as (Table 15.2) 
fstop − fpass 
d dB = −20⋅log10 d s
s 
( )
(15.16) 
Example 15.6 
Design a band-pass FIR filter with the following specifications: 
Lower stop-band = 0 – 600 Hz 
Pass-band = 1,500 – 2,400 Hz 
Upper stop-band = 3,500 – 4,000 Hz 
Stop-band attenuation = 50 dB 
Pass-band ripple = 0.05dB 
Sampling rate = 10,000 Hz 
Determine the FIR-filter length and the cut-off frequency to be used in the design equation. 
SOLUTION 
We first determine the normalized transition band 
1500 − 600 = 0 09
∆f1 = 
. 
10000 
TABLE 15.2 
Filter Length Estimation Using Window (Df 
f 
f 
fs 
= 
stop − pass / ) 
Window Function 
Pass-band 
Stop-band 
Window Type 
w(n), −M≤n≤ M 
Window Length 
Ripple (dB) 
Attenuation (dB) 
Rectangular 
1 
N = 0 9. /D f 
0.7416 
21 
Hanning 
0 5. + 0 5. cos  
M
np 

N = 3 1. /  ∆f
0.0546 
44 
 

np
cos 

 
 + 
= 3 3. /  ∆
Hamming 
0 5. 4
0 46
+ .
N
f
0.0194 
53
 

M 
 

n 
M 
2 p
M
np 
= 5 5. /  ∆
Blackman 
0 42
0 5 
.
. 
+ 
cos 
0 08
.
N
f
0.0017 
74
 
 

cos 

254 
Digital Signal Processing 
3500 − 2400 
2 
= 0 11
∆f = 
. 
10000 
The filter lengths based on above transition bands (for Hamming window) are 
3 3  
N1 = 
. 
= 37 
0 09 
. 
3 3
N2 = 
. 
= 30 
0 11 
. 
The nearest higher odd N is chosen as for the Hamming window 
N = 37 
The lower and higher cut-off frequencies for the band-pass filter will be 
1500 + 600
f1 =
= 1050Hz 
2 
3500 + 2400
f1 =
= 2950Hz 
2 
The normalized lower and higher cut-off frequencies for the band-pass filter will be 
1050
ΩL = 2 f T = 2 ×
= . p radians
p L
s
p 
0 21 
10000 
2950
ΩH = 2 f T
H 
= 2 ×
= . 
p
p 
s
p 
0 59 radians 
10000 
In this case, 2M + =
1 37  will be the number of taps for the band-pass filter. 
A MATLAB program to plot the frequency response is given in the following (Figure 15.5). 
clc; 
clear all; 
Ntap = 37; 
Ftype = 3; 
WL = 0.21*pi; 
WH = 0.59*pi; 
Wtype = 4; 
fs = 10000; 
B=firwd(Ntap,Ftype,WL,WH,Wtype); 
A = 1; 
omega = 0:0.1:pi; 
f = omega*fs/(2*pi); 
[hz, w] = freqz(B, A, omega); 
magnitude = 20*log10(abs(hz)); 
phase = 180*unwrap(angle(hz))/pi; 
figure, 
subplot(2,1,1); 
plot(f, magnitude); 
grid on; 
xlabel('Frequency (Hz)'); 
ylabel('Magnitude response(dB)'); 
subplot(2,1,2); plot(f,phase); 
grid on; 
xlabel('Frequency (Hz)'); 
ylabel('Phase response(degrees)'); 

255 
Implementation of FIR 
FIGURE 15.5 Frequency response in Example 15.6. 
The FIR have a finite number of elements and in h(n) they are 
H n = [h( ), ( ), ( ),
,
 
0 h 1 h 2 … (
( )  
h N +1)]
( )
0 
1 −1
2 
−2 
h N
 −(N +1)
H z = h( )  + h( )z 
+ h( )z 
++ ( +1)z 
(15.17) 
N −1 
Y z
−k 
( )
H z = 
h k z 
= 
(15.18) 
( )  
( )
∑ 
X z( )
k=0 
Y z  = X z  h
 
( )  + h( )z−1 + h( )z−2 ++ ( −1)z−(N −1)
( )  
( )   0
1 
2 
h N
 
 
Y n
( )  = h( ) ( )  + h( )  (
 
1 x n  
) h 2 

0 x n
 
−
+
1 
x n 
2)
( ) (
 
−
+
(15.19) 
The system equation consists of only zeros, and has no feedback (Figure 15.6). 
The digital filter above consists of three parts, which are 
1. Delay represented by z−1. 
2. Multiplication. 
3. Addition. 
Example 15.7 
Find the output samples sequence values from the digital filter shown in Figure 15.7 if the input 
sequence x(n) = [1 1 1 1] (Figure 15.8). 
SOLUTION 
At n = 0. x(0) = 1 
At n = 1. x(1) = 1 

256 
Digital Signal Processing 
y(n) 
h(0) 
X 
h(1 
Z–1 
Z–1 
Z–1 
) 
X 
h(2) 
X 
h(N-1) 
X 
x(n) 
x(n-1) 
x(n-2) 
x(n-(N-1)) 
FIGURE 15.6 Structure of FIR filter. 
0.5 
X 
0.5 
X 
x(n) 
x(n-1) 
y(n) 
Z–1 
FIGURE 15.7 System for Example 15.7. 
At n = 2. x(2) = 1 
At n = 3. x(3) = 1 
y(n) = [0.5 1 1 1] 
Example 15.8 
Find the FFT for the input and output of the digital filter as shown in Figure 15.9 for the input 
sequence of x(n) = [1 1 1 1]. 
SOLUTION 
1) FFT for x(n) is given in Figures 15.10 and 15.11 
2) FFT for y(n), must find the output y(n) from the digital filter as follows Figure 15.12. 
So, y(n) = [0.5 0 0 0] 
Now use the FFT for y(n) to find Y(k) Figure 15.13 
So, Y(k) = [0.5 0.5 0.5 0.5] Figure 15.14 
Example 15.9 
Design a low-pass FIR filter with the following specifications: 

257 
Implementation of FIR 
FIGURE 15.8 System for steps of the solution of Example 15.7. 
0.5 
X 
0.5 
X 
x(0) = 1
 x(-1) = 0 
y(0) = 0.5 
0
0.5 
0.5 
X 
0.5 
X 
x(1) = 1 
x(0) = 1 
y(1) = 1 
0.5 
0.5 
Z–1 
Z–1 
(a) 
(b) 
0.5 
X 
0.5 
X 
x(2) = 1
 x(1) = 1 
y(2) = 1 
0.5 
0.5 
0.5 
X 
0.5 
X 
x(3) = 1 
x(2) = 1 
y(3) = 1 
0.5 
0.5 
Z–1 
Z–1 
(c) 
(d) 
0.5 
X 
–0.5 
X 
x(n) 
x(n-1) 
y(n) 
Z–1 
FIGURE 15.9 System of Example 15.8. 
Cut-off frequency = 1 kHz 
Stop-band attenuation = 28 dB at frequency 2 kHz 
Sampling rate = 8 kHz use Hanning window 
SOLUTION 
The normalized lower and higher cut-off frequencies for the band-pass filter will be 
1000 
w 
= 2p f T = 2p ×
= . p radians 
1new 
L
s
 
0 25 
8000 
2000 
w 
= 2p f T = 2p ×
= . p radians 
2new 
H
s
 
0 75 
8000 

258 
Digital Signal Processing 
FIGURE 15.10 FFT for x(n) of Example 15.8. 
FIGURE 15.11 FFT output for x(n) of Example 15.8. 
X(k) 
4 
0 
1 
2 
3 
k 
0.5 
X 
-0.5 
X 
x(0) = 1
 x(-1) = 0 
y(0) = 0.5 
0
0.5 
0.5 
X 
-0.5 
X 
x(1) = 1 
x(0) = 1 
y(1) = 0 
-0.5
0.5 
Z–1 
Z–1 
(a) 
(b) 
x(2) = 1 
X
X 
Z–1 
x(1)=1 
x(3) = 1 
X
X 
Z–1 
x(2) = 1 
0.5 
-0.5 
0.5 
-0.5 
0.5 
y(n)=0 
y(3) = 0
(c) 
(d) 
FIGURE 15.12 System for steps of the solution of Example 15.8. 
-0.5 

259 
Implementation of FIR 
FIGURE 15.13 FFT for y(n) of Example 15.8. 
Y(k) 
0.5 
0 
1 
2 
3 
k 
FIGURE 15.14 FFT output for y(n) of Example 15.8. 
w1new = wc 
2 ×
N = 
p
p
 = 33 
0 25 p
0 5
. p − . 
2M
1
+ = 33
M = 16 
w
n
 
= . + . cos
 

 np 

 , − M
n
M 
han( )  0 5  0 5  
≤
≤ 
M 
For LPF 

Ωc , 
n = 0
 
p
h n = 
( )  
sin (Ωc n)
−M
n ≤ M
≤
 
pn 
PROBLEMS 
15.1 Calculate the filter coefficients for a 3-tap FIR low-pass filter with a cut-off frequency of 
1,000 Hz and a sampling rate of 10,000 Hz using the Fourier Transform method. 
(a) Determine the transfer function and difference equation of the designed FIR system. 
(b)Compute and plot the frequency response. 
15.2 Calculate the filter coefficients for a 3-tap FIR low-pass filter with a cut-off frequency of 450 
Hz and a sampling rate of 5,000 Hz using the Fourier Transform method. 
(a) Determine the transfer function and difference equation of the designed FIR system. 
(b)Compute and plot the frequency response. 

260 
Digital Signal Processing 
15.3 (a) Calculate the filter coefficients for a 5-tap FIR band-pass filter with a lower cut-off frequency 
of 1,800 Hz and an upper cut-off frequency of 2,000 at a sampling rate of 10,000 Hz. 
(b) Determine the transfer function and plot the frequency responses with MATLAB. 
15.4 (a) Calculate the filter coefficients for a 5-tap FIR band-pass filter with a lower cut-off fre-
quency of 2,000 Hz and an upper cut-off frequency of 2,800 at a sampling rate of 5,000 Hz. 
(b) Determine the transfer function and plot the frequency responses with MATLAB. 
15.5 (a) Calculate the filter coefficients for a 3-tap FIR low-pass filter with a cut-off frequency of 
4,400 Hz and a sampling rate of 8,500 Hz using the Hamming window function. 
(b) Determine the transfer function and difference equation of the designed FIR system. 
(c) Compute and plot the frequency response. 
15.6 (a) Design a 5-tap FIR band-reject filter with a lower cut-off frequency of 1,000 Hz, an upper 
cut-off frequency of 1,400 Hz and a sampling rate of 8,000 Hz using the Hamming win-
dow method. 
(b) Determine the transfer function. 
15.7 Design a band-pass FIR filter with the following specifications: 
Lower Stop-band = 0 – 550 Hz 
Pass-band = 1,650 – 2,350 Hz 
Upper stop-band = 3,550 – 4,100 Hz 
Stop-band attenuation = 52 dB 
Pass-band ripple = 0.04 dB 
Sampling rate = 10,000 Hz 
Determine the FIR-filter length and the cut-off frequency to be used in the design equation. 
0.5 
X 
0.5 
X 
x(n) 
x(n-1) 
y(n) 
Z–1 
FIGURE 15.15 System for problem 15.8. 
x(n) 
x(n-1) 
0.5 
–0.5
X 
X 
Z–1 
y(n) 
FIGURE 15.16 System for problem 15.9. 

261 
Implementation of FIR 
0.5 
X 
0.5 
X 
x(n) 
x(n-1) 
y(n) 
Z–1 
FIGURE 15.17 System for problem 15.10. 
15.8 Find the output samples sequence values from the digital filter shown in Figure 15.15 if the 
input sequence x(n) = [1 0 0 1]. 
15.9 Find the output samples sequence values from the digital filter shown in Figure 15.16 if the 
input sequence x(n) = [0 1 1 0]. 
15.10 Find the FFT for the input and output of the digital filter as shown in Figure 15.17 for the input 
sequence of x(n) = [1 0 1 0]. 
15.11 Design a low-pass FIR filter with the following specifications: 
Cut-off frequency = 1.2 kHz 
Stop-band attenuation = 27 dB at frequency 2 kHz 
Sampling rate = 8.5 kHz use Hamming window 


16 Digital Filter Design 
16.1 IIR FILTER DESIGN 
There are many methods for designing an IIR filter, but one of the simplest ways is to use an analog-
filter design then with a suitable transformation the function H(s) is transformed to digital in the 
z-domain H(z). 
16.1.1 AnAlog-Filter Design 
These are classified into the Butterworth filter and the Chebyshev filter. 
1) Butterworth filter 
a) low-pass filter 
To design a low-pass filter use the following steps: 
Step 1: From the characteristics of the filter in the frequency domain as in Figure 16.1, the 
order of the filter is calculated from 
 
 
k1 
10 
−
− 
10 
1 


 


 
log 10 
k2 
10 
−
− 
10 
1 
(16.1) 
n = 
 
 
w1
2log 10  
 
w2 
Step 2: From Table 16.1, find how the function B(s) is related to the order n: 
Step 3: Find the cut-off frequency 
wc = 
w1 
1 2n 
(16.2) 

− k1 
 
/ 
10 10 −1


Step 4: Find the transfer function of the filter 
1 
H s( )  = 
(16.3) 
s
B s( )  s= wc 
Example 16.1 
Design analog LPF that has pass-band attenuation of 2 dB at 15 rad/sec and stop-band attenuation 
of 10 dB at 30 rad/sec (Figure 16.2). 

k1 
10 

−
− 
= 



= 
1 
1 
10



log 10 
k2 
10 
−
−
10 
2
n


w1
2log 10 

w2 
263 

264 
Digital Signal Processing 
|H( )| 
0 dB 
k1 
k2 
-3 dB 
2
1 
c 
Pass 
Stop 
Band 
Band 
FIGURE 16.1 Low-pass Butterworth filter response. 
TABLE 16.1 
Binominal of Filter Denominator 
n
B(s) 
1 
S + 1 
2 
s2 + 2s + 1 
3
s +1 s2 
s 
1
(
 )
 
(
+
+ ) 
2
2
4 
(s + . 
s + 1)(s + 1
 
8477 s 
)
0 7653 
. 
+ 1 
|H( )| 
0 dB 
-2 
-10 
-3 dB 
30
15 
c 
Pass 
Band 
Stop 
Band 
FIGURE 16.2 Low-pass Butterworth filter response of Example 16.1. 
From Table 16.1 
B s( ) = s2 + 2s + 1
1 
H s( ) = 
s
B s( ) s= wc 
1
H s( ) = 
2s + 2s + 1 
s 
s= wc 

265 
Digital Filter Design 
15 
wc = 
1 2n = 
. rad/sec
17 2 
 
2 
 
/ 
1010 − 1


1
H s( )  = 
2
 s  
s 
 17 2 
.  + 2
. + 1
17 2 
b) high-pass filter 
Step 1: From the characteristics of the filter in the frequency domain, the order of the filter 
is calculated from 
 
 
k1 
10 
−
− 
10 
1 


 


 
log 10 
k2 
10
−
− 
10 
1 
(16.4) 
n = 
 
 
w2
2log 10  
 
w1 
Step 2: From the table, find how the function B(s) is related to the order n: 
n
B(s) 
1 
S + 1 
2 
s2 + 2s + 1 
(
 )
 
(
+
+1)
3
s +1 s2 
s 
2
2
4 
(s + 0 7653 
. 
s + 1)(s + 1
 
8477 
. 
s + 1) 
Step 3: Find the cut-off frequency from Figure 16.3. 
wc = w2 
(16.5) 
Step 4: 
1
H s( )  = 
(16.6) 
B s( )  wc 
s= s 
Example 16.2 
Design an analog HPF that has pass-band attenuation of 3 dB at 5 rad/sec and stop-band attenu-
ation of 15 dB at 2 rad/sec. Use Figure 16.4. 
SOLUTION 

−k1 
10 
 
− 
= 



= 
1 
1 
10



log 10 
k2 
10 
−
−
10 
2
n


w1
2log 10 

w2 

266
﻿Digital Signal Processing
From the table
	
B s
s
s
( ) =
+
+
2
2
1	
	
H s
B s
s
s
c
( )
( )
=
=
1
w 	
	
H s
s
s
s
s
c
( ) =
+
+
=
1
2
1
2
w 	
	
H s
s
s
( ) =
+
+




1
5
2 5
1
2
	
	
c)	 band-pass filter
	
Figure 16.5 shows the band-pass Butterworth filter response; the steps for design are as 
follows:
	
Step 1: From the characteristics of the filter in the frequency domain, the order of the filter 
is calculated from
0 dB
k2
k1
c
|H( )|
Pass 
Band
Stop 
Band
1
 = 
2
FIGURE 16.3  High-pass Butterworth filter response.
0 dB
-3
-15
5
|H( )|
Pass 
Band
Stop 
Band
2
FIGURE 16.4  High-pass Butterworth filter response of Example 16.2.

267
Digital Filter Design﻿
	
n
p
k
k
=
−
−










−
−
log
log [ ]
10
10
10
10
10
1
10
1
2
1
2
	
(16.7)
	
p
r
= 1
w 	
(16.8)
	
wr
A
B
=


min
or
	
(16.9)
	
A
u
l
u
l
= −
+
−
(
)
w
w w
w w
w
1
2
1
	
(16.10)
	
B
u
l
u
l
=
−
−
(
)
w
w w
w
w
w
2
2
2
	
(16.11)
	
Step 2: From the table, find how the function B(s) is related to the order n:
n
B(s)
1
S + 1
2
s
s
2
2
1
+
+
3
s +
(
)
+
+
(
)
1
1
2s
s
4
s
s
s
s
2
2
0 7653
1
1 8477
1
+
+
(
)
+
+
(
)
.
.
Step 3: To find the transfer function in the s-plane
	
H s
B s
s
s
s
u
l
u
l
( )
( )
=
=
−
−
(
)
1
2
w w
w
w
	
(16.12)
0 dB
k1
k2
|H( )|
Pass Band
Stop 
Band
c
Stop 
Band
l
1
2
u
FIGURE 16.5  Band-pass Butterworth filter response.

268
﻿Digital Signal Processing
2) Chebyshev filter
	
a)	 low-pass filter
	
Figure 16.6 shows the low-pass Chebyshev filter response; the steps for design are as 
follows:
	
Step 1:
	
k1
10
2
10
1
= −
+
(
)
log
ε
	
(16.13)
	
k
A
2
10
20
= −
log ( )	
(16.14)
	
g
A
=
−
2
2
1
ε
	
(16.15)
	
w
w
w
r =
2
1
	
(16.16)
	
Step 2:
	
n
g
g
r
r
=
+
−




+
−




log
log
10
2
10
2
1
1
w
w
	
(16.17)
	
Step 3: From the table find the coefficients b0, b1, b2,…
	
H s
k
V s
n
n
( )
( )
=
	
(16.18)
	
k
b
n
b
n
n =
+



0
2
0
1
ε
even
odd
	
(16.19)
	
V s
b
b s
b s
b s
b s
n
n
n
( ) =
+
+
+
+
+
0
1
2
2
3
3

	
(16.20)
	
H s
k
V s
n
n
s
s
c
( )
( )
=
= w
	
(16.21)
0 dB
k1
k2
|H( )|
Pass Band
Stop 
Band
1=
c
2
FIGURE 16.6  Low-pass Chebyshev filter response.

269
Digital Filter Design﻿
Example 16.3
Design a Chebyshev LPF for Figure 16.7.
SOLUTION
	
k1
10
2
10
1
= −
+
(
)
log
ε
	
	
−= −
+
(
)
2
10
1
10
2
log
ε
	
	
ε = 0 7647
.
	
	
k
A
2
10
20
= −
log ( )	
	
−
= −
20
20
10
log
)
(A 	
A = 10
	
g
A
=
−
=
2
2
1
13
ε
	
	
w
w
w
r =
=
2
1
1 3
. 	
	
n
g
g
r
r
=
+
−




+
−




=
≅
log
log
.
10
2
10
2
1
1
4 3
5
w
w
	
N = 5 odd so kn = b0
From the table
	
V s
b
b s
b s
b s
b s
b s
n( ) =
+
+
+
+
+
0
1
2
2
3
3
4
4
5
5	
	
V s
s
s
s
s
s
n( )
.
.
.
.
.
=
+
+
+
+
+
0 1228
0 5805
0 97439
1 6888
0 9368
1
2
3
4
5	
	
H s
k
V s
n
n
s
s
c
( )
( )
=
= w
	
0 dB
-2
-20
|H( )|  dB
Pass Band
Stop 
Band
(rad/sec)
40
52
FIGURE 16.7  Low-pass Chebyshev filter response for Example 16.3.

270
﻿Digital Signal Processing
	
H s
k
s
s
s
s
s
n
s
s
c
( )
.
.
.
.
.
=
+
+
+
+
+
=
0 1228
0 5805
0 97439
1 6888
0 9368
1
2
3
4
5
w
	
	
H s
k
s
s
s
n
( )
.
.
.
.
=
+
+



+




0 1228
0 5805 40
0 97439 40
1 6888 40
2
3
+



+ 



0 9368 40
1 40
4
5
.
s
s
	
	 b)	 high-pass filter
	
Figure 16.8 shows the high-pass Chebyshev filter response; the steps for design are as 
follows:
	
Step 1:
	
k
A
1
10
20
= −
log ( )	
(16.22)
	
k2
10
2
10
1
= −
+
(
)
log
ε
	
(16.23)
	
g
A
=
−
2
2
1
ε
	
(16.24)
	
w
w
w
r =
2
1
	
(16.25)
	
Step 2:
	
n
g
g
r
r
=
+
−




+
−




log
log
10
2
10
2
1
1
w
w
	
(16.26)
	
Step 3: From the table find the coefficients b0, b1, b2,…
	
H s
k
V s
n
n
s
s
c
( )
( )
=
= w 	
(16.27)
0 dB
k1
k2
|H( )|
Pass Band
Stop 
Band
1
FIGURE 16.8  High-pass Chebyshev filter response.

271
Digital Filter Design﻿
	
k
b
n
b
n
n =
+



0
2
0
1
ε
even
odd
	
(16.28)
	
V s
b
b s
b s
b s
b s
n
n
n
( ) =
+
+
+
+
+
0
1
2
2
3
3

	
(16.29)
	
H s
k
V s
n
n
s
s
c
( )
( )
=
= w 	
(16.30)
Example 16.4
Design a Chebyshev HPF for the response shown in Figure 16.9, with a cut-off frequency of 
40 rad/sec with a permissible ripple frequency of 2 rad/sec and stop-band attenuation of 20 dB 
at 15 rad/sec.
SOLUTION
	
k2
10
2
10
1
= −
+
(
)
log
ε
	
	
−= −
+
(
)
2
10
1
10
2
log
ε
	
	
ε = 0 7647
.
	
	
k
A
1
10
20
= −
log ( )	
	
−
= −
20
20
10
log ( )
A 	
A = 10
	
g
A
=
−
=
2
2
1
13
ε
	
	
w
w
w
r =
=
2
1
2 6
. 	
0 dB
-20
-2
|H( )|
Pass Band
Stop 
Band
40
15
FIGURE 16.9  High-pass Chebyshev filter response for Example 16.4.

272
﻿Digital Signal Processing
	
n
g
g
r
r
=
+
−




+
−




=
log
log
10
2
10
2
1
1
2
w
w
	
N = 2 even so kn = b0
From the table
	
V s
b
b s
b s
n( ) =
+
+
0
1
2
2	
	
V s
s
s
n( )
.
.
=
+
+
0 63
0 8
1 2	
	
H s
k
V s
n
n
s
s
c
( )
( )
=
= w 	
	
k
b
n =
+
0
2
1 ε
	
	
H s
b
s
s
s
s
c
( )
.
.
=
+
+
+
=
0
2
2
1
0 63
0 8
1
ε
w
	
	
H s
k
s
s
n
( )
.
.
=
+
+ 



0 63
0 8 40
1 40
2 	
	
c)	 band-pass filter
	
Figure 16.10 shows the band-pass Chebyshev filter response; the steps for design are as 
follows:
	
Step 1: From the characteristics of the filter in the frequency domain, the order of the filter 
is calculated from
	
wr
A
B
=


min
or
	
(16.31)
0 dB
k1
k2
|H( )|
Pass Band
Stop 
Band
Stop 
Band
l
1
2
u
FIGURE 16.10  Band-pass Chebyshev filter response.

273
Digital Filter Design﻿
	
A
u
l
u
l
= −
+
−
(
)
w
w w
w w
w
1
2
1
	
(16.32)
	
B
u
l
u
l
=
−
−
(
)
w
w w
w
w
w
2
2
2
	
(16.33)
	
Step 2:
	
k
A
1
10
10
= −
log ( )	
(16.34)
	
k2
10
2
20
1
= −
+
(
)
log
ε
	
(16.35)
	
g
A
=
−
2
2
1
ε
	
(16.36)
	
n
g
g
r
r
=
+
−




+
−




log
log
10
2
10
2
1
1
w
w
	
(16.37)
	
Step 3: From the table, find how the function B(s) is related to the order n:
n
B(s)
1
S + 1
2
s
s
2
2
1
+
+
3
s +
(
)
+
+
(
)
1
1
2s
s
4
s
s
s
s
2
2
0 7653
1
1 8477
1
+
+
(
)
+
+
(
)
.
.
Step 4: To find the transfer function in the s-plane
	
H s
B s
s
s
s
u
l
u
l
( )
( )
=
=
+
−
(
)
1
2
w w
w
w
	
(16.38)
16.1.2  Bilinear Transformation (IIR Digital Filter)
To design an IIR digital filter, a suitable transformation called a bilinear transformation is used; this 
transformation transforms the left-hand-side of the s-plane into the interior inside of the unit circle 
in the z-plane.
This bilinear transformation transforms the transfer function H(s) of the analog filter
	
s
f
z
z
s
=
−
+




−
−
2
1
1
1
1 	
(16.39)
fs: sampling frequency.
Z−1: delay element by Ts
if s = jω, z
e
j
−
−
=
1
l
where λ Digital frequency (rad)
ω: Analog frequency (rad/sec)

274
﻿Digital Signal Processing
and the relation between λ and ω are given by
	
s
j
T
e
e
s
j
j
=
=
−
+




−
−
w
l
l
2
1
1
	
(16.40)
	
=
−
+




−
−
2
2
2
2
2
T
e
e
e
e
s
j
j
j
j
l
l
l
l
/
/
/
/
	
(16.41)
	
= 2
2
Ts
tan l 	
(16.42)
or
	
l
w
=




−
2
2
1
tan
Ts
	
(16.43)
Example 16.5
Using a bilinear transformation design, realize a digital LPF with the following characteristics
	
a	 Monotone pass-band
	
b	 3 dB cut-off frequency of π/2 rad
	
c	 Stop-band attenuation of 15 dB at 3π/4 rad(Ts = 1 sec) (see Figure 16.11)
SOLUTION
Convert a digital frequency λ in rad to an analog frequency ω in rad/sec
	
w
l
= 2
2
Ts
tan
/
	
	
w
p
1
2
1
4
2
=
=
tan
rad/sec	
	
w
p
2
2
1
3 8
4 8
=
=
tan
. rad/sec	
Figure 16.12 shows the low-pass bilinear transformation filter in terms of λ.
0 dB
-3
-15
 dB
|H( )|
1
2
FIGURE 16.11  Low-pass bilinear transformation filter frequency response of Example 16.5.

275
Digital Filter Design﻿
Monotone to Butterworth
	
n
k
k
=
−
−














=
−
−
log
log
10
10
10
10
1
2
10
1
10
1
2
2
1
2
w
w
	
From the table
	
B s
s
s
( ) =
+
+
2
2
1	
	
H s
B s
s
s
c
( )
( )
=
=
1
w
	
	
H s
s
s
s
s
c
( ) =
+
+
=
1
2
1
2
w
	
	
w
w
c
k
n
=
−




=
−
1
10
1 2
10
1
2
1
/
rad/sec	
	
H s
s
s
( ) =
+
+




1
2
2 2
1
2
	
Design digital filter Ts = 1 sec so fs = 1 Hz
	
s
f
z
z
s
=
−
+




−
−
2
1
1
1
1 	
	
s
z
z
=
−
+




−
−
2 1
1
1
1 	
	
H z
z
z
z
z
( ) =
−
+



+
−
+



+
−
−
−
−
1
1
1
2 1
1
1
1
1
2
1
1
	
0 dB
-3
-15
 dB
|H( )|
/2
3 /4
FIGURE 16.12  Low-pass bilinear transformation filter λ response of Example 16.5.

276
﻿Digital Signal Processing
	
H z
Y z
X z
z
z
z
( )
( )
( )
.
.
=
=
+
+
+
−
−
−
1 2
3 4
0 58
1
2
2 	
	
y n
x n
x n
x n
y n
( )
.
( )
(
)
(
)
.
(
)
=
+
−
+
−
−
−


1
3 4
2
1
2
0 58
2 	
Figure 16.13 Shows the bilinear transformation of a LPF structure.
Example 16.6
Design of a second-order IIR low-pass digital filter using the bilinear transform method operates 
at a cut-off frequency of ΩC = π/4 radians/sample. The analog transfer function Ha(s) for a second-
order Butterworth low-pass filter with 3 dB cut-off at ωC = 2tan(ΩC/2) = 2 tan (π/8) radians/second. 
Therefore, ωC = 2 tan (π/8) = 0.828. It is well known by analog-filter designers that the transfer 
function for a second-order Butterworth low-pass filter with cut-off frequency ω = 1 radian/sec-
ond is:
	
H s
s
s
a( ) =
+(
) +
1
1
2
2 	
When the cut-off frequency is ω = ωC rather than ω = 1, the second-order expression for H(s) 
becomes:
	
H s
s
s
a
C
C
( )
( /
)
( /
)
=
+
+
1
1
2
2
w
w
	
Replacing s with jω and taking the modulus of this expression gives G(ω) = 1/√[1 + (ω/ωC)2n] with 
n = 2, which is a second-order Butterworth low-pass gain-response approximation. Deriving the 
above expression for Ha(s) and corresponding expressions for higher orders is not part of our syl-
labus. It will not be necessary since MATLAB will take care of it.
Setting ωC = 0.828 in this formula, then replacing s by 2(z – 1)/(z + 1) gives us H(z) for the 
required IIR digital filter.
Example 16.7
Design a second-order Butterworth IIR low-pass filter using the MATLAB program with a cut-off 
frequency of Ωc = π/8.
x(n)
y(n)
x(n-1
Z-1
Z-1
Z-1
Z-1
)
x(n-2)
y(n-1)
y(n-2)
+
+
+
+
1/3.4
2/3.4
1/3.4
+
1/3.4
FIGURE 16.13  bilinear transformation LPF structure of Example 16.5.

277
Digital Filter Design﻿
SOLUTION
clc;
clear all; 
[a b] = butter (2, 0.125)
a = [0.0300 0.0599 0.0300]
b = [1.0000 -1.4542 0.5741]
The required expression for H(z) is
	
H z
z
z
z
z
( )
.
.
.
.
.
=
+
+
−
+
−
−
−
−
0 0300
0 0599
0 0300
1 1 4542
0 5741
1
2
1
2
	
	
H z
z
z
z
z
( )
.
.
.
=
+
+
−
+




−
−
−
−
0 03
1 2
1 0 94
0 33
1
2
1
2 	
Which may be realized by the signal-flow graph in Figure 16.14. Note the saving of two multipliers 
by using a multiplier to scale the input by 0.03.
16.1.3  Higher-Order IIR Digital Filters
When recursive filters are of an order higher than two, then they are highly sensitive to quantiza-
tion error and overflow. Therefore, higher-order IIR filters are designed as cascades of bi-quadratic 
sections.
Example 16.8
Design a fourth-order Butterworth-type IIR low-pass digital filter with a 3 dB cut-off at one-
sixteenth of the sampling frequency fS.
SOLUTION
Relative cut-off frequency is π/8. The MATLAB command below produces the arrays a and b with 
the numerator and denominator coefficients for the fourth-order system function H(z).
clc;
clear all;
[a b] = butter(4, 0.125)
y(n)
x(n)
+
+
0.94
-0.03
+
+
1
2
1
0.03
Z-1
Z-1
FIGURE 16.14  A second-order Butterworth IIR-LPF of Example 16.7.

278
﻿Digital Signal Processing
The output produced by MATLAB is
a = 0.00093 0.0037 0.0056 0.0037 0.00093
b = 1.0000 -2.9768 3.4223 -1.7861 0.3556
The system function is, therefore, as follows:
	
H z
z
z
z
z
( )
.
.
.
.
.
.
=
+
+
+
+
−
−
−
−
−
0 00093
0 0037
0056
0037
0 00093
1 2 977
1
2
3
4
z
z
z
z
−
−
−
−
+
−
+




1
2
3
4
3 422
1 786
0 3556
.
.
.
	
It corresponds to the fourth-order “direct-form” signal-flow graph shown in Figure 16.15.
Higher-order IIR digital filters are generally not implemented like this. They are implemented as 
cascaded bi-quad or second-order sections (SOS). Fortunately, MATLAB can transform the “direct-
form” coefficients to second-order section (SOS) coefficients using a “Signal Processing Toolbox” 
function “tf2sos” as follows:
clc;
clear all;
[a b] = butter(4, 0.125)
[sos G] = tf2sos(a,b)
The output produced by MATLAB is
a = 0.0009 0.0037 0.0056 0.0037 0.0009
b = 1.0000 -2.9768 3.4223 -1.7861 0.3556
sos = 1.0000 2.0000 1.0000 1.0000 -1.3651 0.4776
      1.0000 2.0000 1.0000 1.0000 -1.6117 0.7445
G = 9.3350e−04
This produces a 2-dimensional array “SOS” containing two sets of bi-quad coefficients and a 
“gain” constant G. Mathematically, the system function based on this data is as follows:
Z-1
Z-1
Z-1
Z-1
x(n)
y(n)
+
+
0.0037
+
+
0.00093
-2.9768
+
0.0056
+
3.4223
+
0.0037
0.00093
+
-1.7861
0.3556
FIGURE 16.15  A fourth-order “direct-form II” realization of Example 16.8.

279
Digital Filter Design﻿
	
H z
z
z
z
z
z
z
( )
.
.
.
=
+
+
−
+




+
+
−
−
−
−
−
−
9 3350
1
2
1 1 365
0 478
1
2
04
1
2
1
2
1
e
−
−
−
−




2
1
2
1 1 612
0 745
.
.
z
z
	
Practically, the effect of G is often distributed among the two sections, especially in fixed-point 
arithmetic, noting that, 0.033 × 0.028 ≈ 9.3350e−04. Also, these two sections can be in order or an 
alternative expression for H(z) is as follows:
	
H z
z
z
z
z
z
z
( )
.
.
.
.
=
+
+
−




+
+
−
−
−
−
−
−
0 033
1
2
1 1 612
0 745
0 028
1
2
1
2
1
2
1
2
1
2
1 1 365
0 478
−
+




−
−
.
.
z
z
	
This alternative expression for H(z) may be realized in the form of cascaded bi-quadratic sections, 
as shown in Figure 16.16.
16.1.4  IIR Digital High-Pass, Band-Pass, and Band-Stop Filter Design
The bilinear transformation can apply to analog system functions, which are high-pass, band-pass, 
or band-stop to obtain digital filter equivalents. For example, a “high-pass” digital filter can be 
designed as illustrated below:
Example 16.8
Design a fourth-order high-pass IIR filter with cut-off frequency fs/8.
SOLUTION
Execute the following MATLAB commands and proceed as for a low-pass filter
clc;
clear all;
[a b] = butter(4,0.125,'high');
freqz(a,b);
[sos G] = tf2sos(a,b)
title('Response of HPF')
The output produced by MATLAB is:
a = 0.5963 -2.3852 3.5778 -2.3852 0.5963
b = 1.0000 -2.9768 3.4223 -1.7861 0.3556
sos = 1.0000 -2.0000 1.0000 1.0000 -1.3651 0.4776
      1.0000 -2.0000 1.0000 1.0000 -1.6117 0.7445
G = 0.5963
Figure 16.17 shows the Response of a fourth-order IIR-HPF using MATLAB.
x(n)
+
+
1.6
-0.74
+
+
1
2
1
+
+
1.36
-0.48
+
+
1
2
1
0.033
0.028
y(n)
Z-1
Z-1
Z-1
Z-1
FIGURE 16.16  Fourth-order IIR Butterworth LPF with cut-off fs/8.

280
﻿Digital Signal Processing
Example 16.9
Design a second(fourth)-order band-pass filter with ωL = π/2, ωu = 3π/4.
SOLUTION
Execute the following MATLAB statements:
clc;
clear all;
[a b] = butter(2,[0.5 0.75])
freqz(a,b);
[sos G] = tf2sos(a,b)
The MATLAB output is
a = 0.0976 0 -0.1953 0 0.0976
b = 1.0000 1.2190 1.3333 0.6667 0.3333
sos = 1.0000 -2.0000 1.0000 1.0000 0.1665 0.5348
      1.0000 2.0000 1.0000 1.0000 1.0524 0.6232
G = 0.0976
Figure 16.18 shows the response of a second(fourth)-order band-pass filter using the MATLAB 
program.
Example 16.10
Design a fourth(eighth)-order band-pass filter with ωL = π/5, ωu = π/2.5.
FIGURE 16.17  Response of fourth-order IIR-HPF of Example 16.8.

281
Digital Filter Design﻿
SOLUTION
Execute the following MATLAB statements:
clc;
clear all;
[a b] = butter(4,[0.2 0.4])
freqz(a,b); axis([0 1 -40 0]);
[sos G] = tf2sos(a,b)
The MATLAB output is
a = 0.0048 0 -0.0193 0 0.0289 0 -0.0193 0 0.0048
b =1.0000 -3.9366 8.2604 -11.2174 10.7836 -7.3914 3.5765 -1.1150 0.1874
sos =
 1.0000	-2.0000	 1.0000	1.0000	-0.7574	 0.5088
 1.0000	 2.0001	 1.0001	1.0000	-1.1268	 0.5820
 1.0000	 1.9999	 0.9999	1.0000	-0.5824	 0.7556
 1.0000	-2.0000	 1.0000	1.0000	-1.4701	 0.8374
G = 0.0048
Figure 16.19 response of second(eighth)-order band-pass filter using MATLAB program.
Example 16.11
Design a fourth(eighth)-order band-stop filter with ωL = π/8, ωu = π/4.
SOLUTION
Execute the following MATLAB statements:
clc;
clear all;
FIGURE 16.18  Response of second(fourth)-order band-pass filter for Example 16.9.

282
﻿Digital Signal Processing
[a b] = butter(4,[0.125 0.25], 'stop')
freqz(a,b);
axis([0 1 -40 0]);
[sos G] = tf2sos(a,b)
The MATLAB output is
a = 0.5963 -4.0442 12.6706 -23.7586 29.0767 -23.7586 12.6706 -4.0442 
0.5963
b = 1.0000 -5.9147 16.1669 -26.5104 28.4581 -20.4605 9.6300 -2.7200 
0.3556
sos =
 1.0000 -1.6960 1.0006 1.0000 -1.3252 0.6585
 1.0000 -1.6950 0.9994 1.0000 -1.5276 0.7253
 1.0000 -1.6953 1.0001 1.0000 -1.3139 0.8278
 1.0000 -1.6958 0.9999 1.0000 -1.7480 0.8993
G =0.5963
Figure 16.20 response of fourth(eighth)-order band-stop filter using MATLAB program.
16.1.5  Design a IIR Low-Pass Filter Using MATLAB
clc;
clear all;
fs =4000;
fc = 1500;
C = 2-cos(2*pi*fc/fs);
A(2) = sqrt(C^2 - 1)-C;
A(1) = 1;
FIGURE 16.19  Response of second(eighth)-order band-pass filter for Example 16.10.

283
Digital Filter Design﻿
B = 1+A(2);
[H, w] = freqz(B, A);
H = 20*log10(abs(H));
plot(w/(2*pi)*fs/1000, H, fc/1000, -3, 'o');
title(' IIR-LPF Response ');
xlabel('Frequency (kHz)');
ylabel('Magnitude (dB)');
The output produced by MATLAB is shown in Figure 16.21.
16.1.6  Design a IIR High-Pass Filter Using MATLAB
clc;
clear all;
fs = 20000;
fc = 1000;
C = 2-cos(2*pi*fc/fs);
A(2) = sqrt(C^2 - 1);
A(1) = 1;
B = 1-A(2);
[H, w] = freqz(B, A);
H = 20*log10(abs(H));
plot(w/(2*pi)*fs/1000, H);
title('IIR-HPF Response');
xlabel('Frequency (k Hz)');
ylabel('Magnitude (dB)');
The output produced by MATLAB is shown in Figure 16.22.
FIGURE 16.20  Response of fourth(eighth)-order band-stop filter for Example 16.11.

284
﻿Digital Signal Processing
16.1.7  Design an IIR Band-Pass Filter Using MATLAB
fs =25000;
fc = 7000;
Bw = 4000;
A(3) = exp(-2*pi*(Bw/fs));
A(2) = -4*A(3)/(1+A(3))*cos(2*pi*fc/fs);
A(1) = 1;
FIGURE 16.21  IIR-LPF response.
FIGURE 16.22  IIR high-pass filter response.

285
Digital Filter Design﻿
B = 1-A(3) *sqrt(1-A(2)*A(2)/(4*A(3)));
[H, w] = freqz(B, A);
H = 20*log10(abs(H));
plot(w/(2*pi)*fs/1000, H);
title('IIR BPF Response');
xlabel('Frequency (k Hz)');
ylabel('Magnitude (dB)');
The output produced by MATLAB is shown in Figure 16.23.
16.2  FIR-FILTER DESIGN
For a certain FIR filter to be a linear phase, the following equation must be satisfied
	
h n
h N
n
n
N
( )
(
)
, ,
=
−−
=
−
1
0 1 1
1
…
	
and N is the odd number of the coefficient.
	
1	 Convert the unit of ω from rad/sec to rad.
	
w
p
1
2
new =
f T
L
s	
(16.44)
	
w
p
2
2
new =
f T
H
s	
(16.45)
	
w
w
1new =
c	
(16.45)
	
2	 Calculate the number of samples N which must be an odd number
	
N
k
=
−
2
2
1
p
w
w
new
new
	
(16.46)
FIGURE 16.23  IIR BPF response.

286
﻿Digital Signal Processing
	
3	 Calculate
	
a =
−
N
1
2
	
(16.47)
	
4	 Using the type of window and type of filter.
16.2.1  Design of FIR Filters Using Windows
The most straightforward approach for designing a FIR filter is to obtain a finite-length impulse 
response by truncating an infinite duration impulse response sequence. If H
e
d
jww
(
) is an ideal 
desired frequency response, then
	
H
e
h n e
d
j
n
d
jn
ww
ww
(
) =
=−∞
∞
−
∑
( )
	
(16.48)
where hd(n) is the corresponding impulse response sequence, i.e.,
	
h n
H
e
e
d
d
d
j
jn
( ) =
(
)
−∫
1
2pp
ww
pp
pp
ww
ww
	
(16.49)
The sequence hd(n), is of infinite duration, and it must be truncated to obtain a finite-duration 
impulse response. The window method is the one way to get a finite-duration causal impulse 
response is to known h(n), and it is defined as
	
h n
h
n
N
n
d
( )
( )
=
≤
≤
−



0
1
0
otherwise
	
(16.50)
Generally, we can represent h(n) as the product of the desired impulse response and a finite duration 
“window” w(n); i.e.,
	
h n
h n w n
d
( )
( ) ( )
=
	
(16.51)
where in the example
	
w n
n
N
( ) =
≤
≤
−



1
0
1
0
otherwise
	
(16.52)
	
w e
e
e
e
e
wN
jw
n
N
jwn
jwN
jw
jw N
(
) =
=
−
−
=



=
−
−
−
−
−
−




∑
0
1
1
2
1
1
2
sin





sin w
2
	
(16.53)
However, for the rectangular window, the “side lobes” are not insignificant. In fact, as N increases, 
the peak amplitudes of the main lobe and the side lobes grow in a manner such that the area under 
each lobe is a constant, while the width of each lobe decreases with N.
The main disadvantage of FIR filters is the possible requirement of a much higher-order filter 
(more coefficients) than IIR filters with comparable performance. As a result, it incurs longer delays, 
and higher computational costs and memory requirements. Also, there is no direct conversion from 
the popular analog-filter design to the digital FIR filter. Optimization of FIR-filter models requires 
computer programs for intensive computations.

287
Digital Filter Design﻿
The phase and group-delay characteristics of FIR filters are generally better than those of IIR 
filters. A FIR filter with good phase characteristics is usually the right choice for applications where 
wave shape is essential. However, IIR filters may be better than FIR filters for narrowband, sharp 
cut-off filters where phase is not necessary.
The I/O equation for a FIR filter of length L (or order L – 1) can be expressed as
	
y n
b x x
b x n
b
x n
L
b x n
i
b x n
L
i
i
L
T
( )
( )
(
)
(
)
(
)
( )
=
+
−
+
+
−
+
=
−
=
−
=
−
∑
0
1
1
0
1
1
1

,
	
(16.54)
where T denotes the transposition of the vector, b is the filter coefficient vector (L × 1) defined as
	
b
b b
bL
T
= [
]
−
0
1
1
…
	
(16.55)
and the signal vector (array or buffer) at time n is defined as
	
x n
x n x n
x n
L
L
( )
( ) (
)
(
)
=
−
−
+
[
]
1
1
…
	
(16.56)
The design of FIR filters determines the coefficients {bi,i = 0,1, … , L – 1} needed to achieve the 
desired filter characteristics with as few coefficients as possible.
Equation (16.54) implies that the FIR-filtering is equivalent to an inner (or dot) product of vectors 
or a linear convolution of the two sequences. A FIR filter is a non-recursive filter, which generates 
its output by simply scaling previous input samples by filter coefficients and then summing the 
weighted inputs. The coefficients are constants and determined by using the filter-design process. 
However, the signal vector x(n) is a time function which needs to be updated every sampling period 
when the newest sample x(n) is available.
By taking the z-transform of both sides of Equation (16.54) and using the time-shift property, 
we have
	
y z
b x z
b z x z
b
z
x z
x z
biz
L
L
i
i
L
( )
( )
( )
( )
( )
=
+
+
=
−
−
−+
−
=
−
∑
0
1
1
1
1
0
1

	
Digital filter design involves the computation of filter coefficients to approximate the desired fre-
quency response. The design process starts from the filter specification and the implementation of 
the desired filter in the following five steps:
Step 1: Specification – The desired frequency response is determined by specifying filter 
characteristics in a frequency domain.
Step 2: Design criteria – A measure of the quality of the filter chosen by selecting design 
criteria.
Step 3: Realization – A class of filter chosen by selecting the filter type, structure, and length 
of the filter. An algorithm is then chosen to calculate the desired filter coefficients.
Step 4: Quantization – Quantization involves quantizing filter coefficients for a given word 
length, analyzing the finite-precision effects, and optimizing the quantized filter to reduce 
quantization errors.
Step 5: Implementation – Implementation involves verifying the designed filter using simula-
tion and implementing it in the software (or hardware).

288
﻿Digital Signal Processing
Some FIR-filter design methods may be simple such as the Fourier technique, which is introduced 
later. However, no single approach is optimal for every filter characteristic. Filter coefficients can 
be generated using some rational equations. However, using an optimization technique to obtain an 
optimum filter demands intensive computation. Also, the primary concern for implementing filters 
on fixed-point DSP processors for real-time applications is the limited precision. The theory for 
analyzing finite, word-length effects is too complicated to compute by hand; thus, we usually rely 
on computer software for designing digital filters.
A filter-design software package, such as MATLAB with the Signal Processing Toolbox and 
Filter-Design Toolbox, not only saves time when designing a filter quickly but also supports the 
design of a quantized filter for a given word length. We can explore many possibilities such as filter 
characteristics, structures, and different word lengths quickly using the software package.
Example 16.12
By the impulse response truncation method (via the windowing method during the rectangular 
window application) design a low-pass filter of order N = 15 with pass-band cut-off frequency 
(pass-band edge frequency) f0 = 1 kHz. The sampling frequency is fs = 4 kHz.
SOLUTION
	
fS = 4kHz	
	
f0
1
= kHz	
	
w
p
p
p
0
3
3
2
2
4 10
1 10
2
=
=
⋅
=
f
f
s
o
.
.
	
	
H e j
(
)
w
w
w
p
w
w
p
=
≤
=
>
=






1
2
0
2
0
0
for
for
	
	
h n
H e
e
d
e
d
e
jn
j
j n
j n
j n
( )
/
/
=
(
)
=
=





−
−
∫
∫
1
2
1
2
1
1
2
2
2
p
w
p
w
p
w
p
p
w
p
p
w
w

=
−










=
−
=
−
−
−
p
p
p
p
p
p
p
p
/
/
2
2
2
2
2
2
1
2
2
1
2
n
e
j
e
j
n
e
e
j
jn
jn
jn
jn
sin n
n
p
p
2




	
Then h(0) = 0.5
	
f n
h n
n
( )
( )
=
−
<
<
for
7
7	
Example 16.13
Given the following digital system with a sampling rate of 8,000 Hz,
	
y n
x n
y n
( )
( )
.
(
)
=
−
−
0 5
1 	

289
Digital Filter Design﻿
Determine the frequency response of the system.
SOLUTION
Taking the z-transform of both sides of the difference equation, we get
	
Y z
X z
z
Y z
Y z
z
Y z
X z
z
Y z
X
( )
( )
.
( )
( )
.
( )
( )
.
( )
=
−
⇒
+
=
⇒
+
(
)
=
−
−
−
0 5
0 5
1 0 5
1
1
1
( )
z
	
Therefore, the transfer function of the system is given by
	
H z
Y z
X z
z
( )
( )
( )
.
=
=
+
(
)
−
1
1 0 5
1 	
To find out the frequency response of the system, we replace z with e jW
W, which leads to
	
H e
e
j
j
W
W
W
W
(
) =
+
(
)
−
1
1 0 5
.
	
It can be written as
	
H e
j
jW
W
W
W
W
W
(
) =
+
−
(
)
1
1 0 5
0 5
. cos(
)
. sin(
) 	
Therefore, the magnitude frequency response and phase response are given by
	
H e
j
W
W
W
W
W
W
W
W
W
W
(
) =
+
−
(
)
=
+
(
) + −
1
1 0 5
0 5
1
1 0 5
0 5
2
. cos(
)
. sin(
)
. cos(
)
. sin(
)
(
)
2
	
and
	
∠(
) = −
−
+




H e jW
W
W
W
W
W
tan
. sin(
)
. cos(
)
0 5
1 0 5
	
This is an example of a high-pass filter.
Example 16.14
	 (a)	 Calculate the filter coefficients for a 5-tap FIR band-pass filter with a lower cut-off frequency 
of 2,000 Hz and an upper cut-off frequency of 2,400 at a sampling rate of 8,000 Hz.
	 (b)	 Determine the transfer function and the difference equation.
	 (c)	 Find out the frequency response of the filter.
SOLUTION
Part (a): We first determine the normalized cut-off frequencies
	
W
WL
L
s
f
f
=
=
×
=
2
2
2000
8000
0 5
pp
pp
pp
.
radians	

290
﻿Digital Signal Processing
	
W
WH
H
s
f
f
=
=
×
=
2
2
2400
8000
0 6
pp
pp
pp
.
radians	
In this case 2M + 1 = 5, therefore, from Table 15.1,
	
h n
n
n
n
n
n
n
H
L
H
L
( )
,
sin
sin
,
=
−
=
(
) −
(
)
−≤
≤






W
W
W
W
W
W
W
W
pp
pp
pp
0
2
2
	
The non-causal FIR coefficients are
	
h
H
L
( )
.
.
.
0
0 6
0 5
0 1
=
−
=
−
=
W
W
W
W
pp
pp
pp
pp
	
	
h
H
L
( )
sin
sin
sin
.
sin
.
.
1
1
1
1
1
0 6
0 5
0 01
=
×
(
)
×
−
×
(
)
×
=
(
) −
(
) = −
W
W
W
W
pp
pp
pp
pp
pp
pp
558	
	
h
H
L
( )
sin
sin
sin
.
sin
.
.
2
2
2
2
2
1 2
2
1 0
2
0
=
×
(
)
×
−
×
(
)
×
=
(
) −
(
) = −
W
W
W
W
pp
pp
pp
pp
pp
pp
09355	
Use the symmetry property
	
h
h
(
)
( )
.
−
=
= −
1
1
0 01558	
	
h
h
(
)
( )
.
−
=
= −
2
2
0 09355	
Thus, the filter coefficients are obtained by delaying by M = 2 samples, as
FILTER COEFFICIENTS
	
b
h
h
0
0
2
2
0 09355
=
−
=
−
= −
(
)
(
)
.
	
	
b
h
h
1
1 2
1
0 01558
=
−
=
−
= −
(
)
(
)
.
	
	
b
h
h
2
2
2
0
0 1
=
−
=
=
(
)
( )
. 	
	
b
h
h
3
3
2
1
0 01558
=
−
=
= −
(
)
( )
.
	
	
b
h
h
4
4
2
2
0 09355
=
−
=
= −
(
)
( )
.
	
Part (b): Therefore, the transfer function in this case is
	
H z
b
b z
b z
b z
b z
z
z
( )
.
.
.
=
+
+
+
+
= −
−
+
−
−
−
−
−
−
0
1
1
2
2
3
3
4
4
1
2
0 09355
0 01558
0 1
−
−
−
−
0 01558
0 09355
3
4
.
.
z
z
	
The difference equation is
	
y n
x n
x n
x n
x n
( )
.
( )
.
(
)
.
(
)
.
(
)
.
= −
−
−
+
−
−
−
−
0 09355
0 01558
1
0 1
2
0 01558
3
0 09355
4
x n
(
)
−
	
Part (c): The frequency response of the filter is

291
Digital Filter Design﻿
	
H e
e
e
e
e
j
j
j
j
W
W
W
W
W
W
W
W
(
) = −
−
+
−
−
−
−
−
0 09355
0 01558
0 1
0 01558
0 09355
2
3
.
.
.
.
.
−4 jW
W
	
Casual FIR-filter coefficients: shifting h(n) to the right by samples 1, 2, …, M.
T ransfer Function:
	
H z
b
b z
b z
b
z
M
M
( ) =
+
+
+
+
−
−
−
0
1
1
2
2
2
2

	
where
	
b
h n
M
for n
n =
−
=
…
(
)
, , ,
,
0 1 2
2	
Example 16.15
A digital filter with a sampling rate of 1,000 Hz is required to eliminate an unwanted 105 Hz sinu-
soidal component of an input signal without affecting the magnitudes of other parts too severely. 
Design a fourth-order “notch” filter for this purpose whose 3 dB bandwidth is not greater than 10 Hz.
SOLUTION
clc;
clear all;
FS=1000;
FL=100;
FU=110;
[a b]=butter(2,[FL,FU]/(FS/2), 'stop')
freqz(a,b);
title('Response of SPF')
[SOS G] = tf2sos(a,b)
The MATLAB output is
a = 0.9565 -3.0248 4.3043 -3.0248 0.9565
b = 1.0000 -3.0920 4.3024 -2.9575 0.9150
SOS = 1.0000 -1.5811 1.0000 1.0000 -1.5184 0.9553
      1.0000 -1.5811 1.0000 1.0000 -1.5736 0.9578
G = 0.9565
The output produced by MATLAB is shown in Figure 16.24.
Example 16.16
Design a second-order low-pass digital filter. Given:
	
H s
s
s
c
c
c
( ) =
+
+
w
w
w
2
2
2
2
	
The sampling frequency is 5 Hz, and the desired low-pass cut-off frequency is 0.318 Hz (2 rad/
sec). Our desired digital cut-off frequency is 2 rd/sec * (1/5 Hz) = 0.4 rad.
SOLUTION
	
Ωc
c
T
=



= (
)



=
2
2
2
1 5
0 4
2
2 027
tan
/
tan
.
.
w
rd/sec	

292
﻿Digital Signal Processing
	
fc
c
=
=
Ω/
.
(
.
)
2
0 323
0 318
p
Hz shifted from
Hz 	
	
H s
s
s
s
s
c
c
c
( )
.
.
.
=
+
+
=
+
+
w
w
w
2
2
2
2
2
0 16
0 567
0 16 	
	
H z
H s
z
z
z
z
s T
z
z
( )
( )
.
(
)
.
.
=
=
+
+
−
+
=
−
+
−
−
−
−
2
1
1
1
2
1
2
0 0309 1 2
1 1 444
0 5682
	
PROBLEMS
	16.1	 For the digital filter of the z-plane pole and zero patters shown in Figure 16.25, find the filter 
transfer function, difference equation, and sketch the impulse response sequence with a filter 
gain of 10.
	16.2	 Use the bilinear transformation to design a digital filter based on a three-order Butterworth 
HPF H(s) = 1/S(S2 + 1.414S + 1). The digital filter should have a digital cut-off frequency 
equal to 10 kHz, while the sampling frequency of the input signal is 1 kHz.
	16.3	 Design the digital low-pass filter with a 3-dB cut-off frequency, ωc = 0.25π using the bilinear 
transformation method to analog a Butterworth low-pass filter defined by
	
H
s
s
a
s
( )
[
(
)]
/
/
=
+
1 1
Ω
	
	16.4	 Determine the low-pass digital filter with a 3-dB cut-off frequency of 0.2π and its frequency 
response from the analog filter given by Ha(s) = Ωc/s + Ωc, where Ωc is the 3-dB cut-off 
frequency.
	16.5	 Design a LPF IIR digital filter with a 3 dB cut-off frequency of 1 kHz and stop-band attenu-
ation of 28 dB at 2 kHz. Use fs = 8kHz and the Chebyshev approximation.
FIGURE 16.24  Response of a fourth-order “notch” filter of Example 16.15.

293
Digital Filter Design﻿
	16.6	 Design an HPF IIR digital filter with a monotone pass-band and a cut-off frequency of π/2 
rad with attenuation of –3 dB stop-band attenuation of –15 dB at a frequency of π/4. Use fs = 
1 Hz and the Chebyshev approximation.
Im
Re
2-poles
|Z|=1
FIGURE 16.25  z-plain of Problem 16.1.


295
Bibliography
	
1. 	Vijay K. Madisetti and Douglas B. Williams, Digital Signal Processing Hand Book, CRC net base, 1999.
	
2. 	D. S. G. Pollock, A Handbook of Time-Series Analysis, Signal Processing and Dynamics, Signal 
Processing and Its Applications, Academic Press, 1999.
	
3. 	Alan V. Oppenheim, Signals and Systems, Prentice-Hall Signal Processing Series, 1996.
	
4. 	Richard G. Lyons, Understanding Digital Signal Processing, Prentice Hall PTR, 1997.
	
5. 	Jonathan Y. Stein, Digital Signal Processing: A Computer Science Perspective, A Wiley-Interscience 
Publication, John Wiley & Sons, Inc., 2000.
	
6. 	John G. Proakis and Dimitris G. Manolakis, Digital Signal Processing Principles, Algorithms, and 
Applications, 3rd Edition, Prentice-Hall International, Inc., 1996.
	
7. 	Stanley H. Mneney, An Introduction to Digital Signal Processing: A Focus on Implementation, River 
Publishers ApS, 2008
	
8. 	Allen B. Downey, Think DSP Digital Signal Processing in Python Version 1.0.9, Green Tea Press, 
Needham, MA, 2014.
	
9. 	Vinay K. Ingle and John G. Proakis, Digital Signal Processing Using MATLAB®, 3rd Edition, Publisher, 
Global Engineering: Christopher M. Shortt, 2012.
	 10. 	Jonathan Blackledge, Digital Signal Processing, 2nd Edition, Horwood Publishing, Chichester, West 
Sussex, England, 2006.
	 11. 	Vijay K. Madisetti and Douglas B. Williams, Digital Signal Processing Handbook, CRC Press LLC, 1999.
	 12. 	Monson H. Hayes, Schaum’s Outline of Theory and Problems of Digital Signal Processing, McGraw-
Hill, 1998.
	 13. 	Andreas Antoniou, Digital Signal Processing: SIGNALS SYSTEMS AND FILTERS, McGraw-Hill, 2006.
	 14. 	Matthew N. O. Sadiku and Warsame Hassan Ali, Signals and Systems: A Primer with MATLAB®, 1st 
Edition, CRC Press, 2015.
	 15. 	Brigham, E. O., The Fast Fourier Transform and Its Applications, Prentice Hall, Englewood Cliffs, NJ, 1988.
	 16. 	Buck, J. R., M. M. Daniel, and A. C. Singer, Computer Explorations in Signals and Systems, 2nd 
Edition, Prentice Hall, Upper Saddle River, NJ, 2002.
	 17. 	Cadzow, J. A. and H. F. Van Landingham, Signals, Systems, and Transforms, Prentice Hall, Englewood 
Cliffs, NJ, 1985.
	 18. 	Carlson, G. E., Signal and Linear System Analysis with MATLAB, 2nd Edition, John Wiley & Sons, 
New York, 1998.
	 19. 	Chapiro, L. F., Signals and Systems Using MATLAB, Elsevier, Burlington, MA, 2011.
	 20. 	Chen, C., Linear System Theory and Design, 3rd Edition, Oxford University Press, New York, 1999.
	 21. 	Chen, C., Signals and Systems, 3rd Edition, Oxford University Press, New York, 2004.
	 22. 	Denbigh, P., System Analysis and Signal Processing, Addison Wesley Longman, Essex, UK, 1998.
	 23. 	ElAli, T. S., Discrete Systems and Digital Signal Processing with MATLAB, CRC Press, Boca Raton, FL, 
2004.
	 24. 	Anderson, A. H. et al., VHDL executable requirements, Proceedings 1st Annual RASSP Conference, pp. 
87–90, Arlington, VA, August, 1994. URL: http://rassp.scra.org/public/confs/1st/papers.html#VER.
	 25. 	Shaw, G. A. and Anderson, A. H., Executable requirements: Opportunities and impediments, in IEEE 
Proceedings of the International Conference on Acoustics, Speech, and Signal Processing, pp. 1232–
1235, Atlanta, GA, May 7–10, 1996.
	 26. 	Frank, G. A., Armstrong, J. R., and Gray, F. G., Support for model-year upgrades in VHDL test benches, 
in Proceedings of the 2nd Annual RASSP Conference, pp. 211–215, Arlington, VA, July 24–27, 1995. 
URL: http://rassp.scra.org/public/confs/2nd/papers.html.
	 27. 	ISO/IEC 11172, Information Technology—Coding of Moving Picture and Associated Audio for Digital 
Storage Media at up to about 1.5 Mbit/s, 1993. https://www.iso.org/standard/22412.html
	 28. 	Rowe, L. A., Patel, K. et al., mpeg encode/mpeg play, Version 1.0, available via anonymous ftp at ftp://
mm-ftp.cs.berkeley.edu/pub/multimedia/mpeg/bmt1r1.tar.gz, Computer Science Department, EECS 
University of California at Berkeley, May 1995.
	 29. 	International Standard ISO/IEC 13818, Information technology -Generic coding of moving pictures and 
associated audio information: Systems Second edition, 2000.
	 30. 	S. A. Tretter, Communications System Design Using DSP Algorithms, Plenum Press, New York, NY, 1995.

296
﻿Selected Bibliography
	 31. 	Egolf, T. W., Famorzadeh, S., and Madisetti, V. K., Fixed-point co-design in DSP, in VLSI Signal 
Processing Workshop, Vol. 8, October, 1994.
	 32. 	Thomas, D., Adams, J., and Schmit, H., A model and methodology for hardware-software codesign, in 
IEEE Design & Test of Computers, September, 1993.
	 33. 	Kalavade, A. and Lee, E., A global criticality/local phase driven algorithm for the constrained hard-
ware/software partitioning problem, in Proceedings of the Third International Workshop on Hardware/
Software Codesign, September, 1994.
	 34. 	Bracewell, R. N., The Fourier Transform and Its Applications, 2nd Edition, McGraw-Hill, New York, 
1978.
	 35. 	 R. Schaumann and M. E. Van Valkenburg,  Design of Analog Filters, New York: Oxford University 
Press, 2001.
	 36. 	Alan V. Oppenheim and Ronald W. Schafer, Discrete-Time Signal Processing, 2nd Edition, Prentice 
Hall Signal Processing Series, 1999, ISBN 0-13-754920-2.
	 37. 	Steven W. Smith, The Scientist and Engineer’s Guide to Digital Signal Processing, California Technical 
Publishing, 2007.
	 38. 	A. Antoniou, Digital Filters: Analysis, Design, and Applications, New York, McGraw-Hill, 1993.
	 39. 	Dragoslav Mitronivić and Jovan, Kečkić, The Cauchy Method of Residues: Theory and Applications, D. 
Reidel Publishing Company, 1984, ISBN 90-277-1623-4.
	 40. 	Wolfram Mathworld, Partial Fraction Decomposition. URL: http://mathworld.wolfram.com/
PartialFractionDecomposition.html. Last accessed 10th May 2008.
	 41. 	J. Eyre and J. Bier, “The evolution of DSP Processors,” A BDTI White Paper, Berkeley Design Technology 
Inc., 2000.
	 42. 	A. V. Oppenheim and R. W. Schafer, Discrete-Time Signal Processing, Prentice Hall, 1989.
	 43. 	A. V. Oppenheim and R. W. Schafer, Digital Signal Processing, Prentice Hall, 1975.
	 44. 	A. Papoulis, Signal Analysis, McGraw-Hill, 1977.
	 45. 	C. S. Burrus, J. H. McClellan, A. V. Oppenheim, T. W. Parks, R. W. Schafer, H. W. Schuessler, Computer-
Based Exercises for Signal Processing Using Matlab, Prentice Hall, 1994.
	 46. 	L. R. Rabiner and R. W. Schafer, Digital Processing of Speech, Prentice Hall, 1978.
	 47. 	J. M. Mendel, Lessons in Estimation Theory for Signal Processing, Communications and Control, 
Prentice Hall, 1995.
	 48. 	D. B. Percival and A. T. Walden, Spectral Analysis for Physical Applications, Cambridge Press, 1993.
	 49. 	Candy, J. V. Signal Processing, McGraw-Hill, 1988.
	 50. 	S. K. Mitra,  Digital Signal Processing: A Computer Based Approach, 2nd Edition, McGraw-Hill, 2001.
	 51. 	A. Antoniou, Digital Filters: Analysis, Design and Applications, 2nd Edition, Mc-Graw-Hill, New 
York, NY, 1993.
	 52. 	DSP Selection Guide, SSDV004S, Texas Instrument Inc., Printed by Southwest Precision Printers, 
Houston, Texas, 2007.
	 53. 	G. Marven and G. Ewers, A Simple Approach to Digital Signal Processing, Texas Instruments. ISBN 
0-904 047-00-8, 1994.
	 54. 	Michael R. Williams, A History of Computing Technology, IEEE Computer Society Press, ISBN 
0-8186-7739-2, 1997.
	 55. 	A. W. Burks, H. H. Goldstine, and  J. von Neumann, Preliminary Discussion of the Logical Design of 
an Electronic Computing Instrument, 1963.
	 56. 	P. A. Regalia,  Adaptive IIR Filtering for Signal Processing Control, Marcel Dekker, New York, 1995.
	 57. 	A. V. Oppenheim and  R. W. Schafer, Discrete-Time Signal Processing, Englewood Cliffs, NJ: Prentice-
Hall, 1989.
	 58. 	A. Papoulis, Probability, Random Variables, and Stochastic Processes, McGraw-Hill, New York, 1991.
	 59. 	D. S. G. Pollock, A Handbook of Time-Series Analysis, Signal Processing and Dynamics, Signal 
Processing and Its Applications, Academic Press, 1999.

297
Appendix A: Complex Numbers
The ability to handle complex numbers is important in signals and systems. Although calculators 
and computer software packages such as MATLAB are now available to manipulate complex num-
bers, it is advisable that students be familiar with how to handle them by hand.
A.1  REPRESENTATION OF COMPLEX NUMBERS
A complex number z may be written in rectangular form as
	
z
x
jy
=
+
	
(A.1)
where j =
−1; x is the real part of z while y is the imaginary part; that is
	
x
z
y
z
=
=
Re( )
Im( )
,
	
(A.2)
Since j =
−1
	
1
1
1
2
3
2
4
2
2
5
4
j
j
j
j
j j
j
j
j
j
j
j j
j
= −
= −
=
⋅
= −
=
⋅
=
=
⋅
=

	
(A.3)
A second way of representing the complex number z is by specifying its magnitude r and angle θ 
it makes with the real axis, as shown in Figure B.1. This is known as the polar form. It is given by
	
z
z
r
=
∠= ∠
q
q	
(A.4)
where
	
r
x
y
y
x
=
+
=
−
2
2
1
,
tan
q
	
(A.5a)
or
	
x
r
y
r
=
=
cos ,
sin
q
q	
(A.5b)
that is,
	
z
x
jy
r
r
jr
=
+
= ∠=
+
q
q
q
cos
sin 	
(A.6)

298
﻿Appendix A
In converting from rectangular to polar form using Equation (A.5), we must exercise care in deter-
mining the correct value of θ. These are the four possibilities:
	
z
x
jy
y
x
z
x
jy
y
x
=
+
=
= −+
=
° −
−
−
,
tan
(
,
tan
(
q
q
1
1
1
180
2
st quadrant)
nd quadrant)
rd quadrant)
z
x
jy
y
x
z
x
jy
= −−
=
° +
=
−
=
° −
−
,
tan
(
,
ta
q
q
180
3
360
1
n
(
−1
4
y
x
th quadrant)
	
(A.7)
if x and y are positive.
The third way of representing the complex number x is the exponential form:
	
z
re j
=
q	
(A.8)
This is almost the same as the polar form, because we use the same magnitude r and the angle θ.
The three forms of representing a complex number are summarized as follows.
	
z
x
jy
x
r
y
r
z
r
r
x
y
=
+
=
=
= ∠
=
+
=
,
(
cos ,
sin )
,
,
tan
q
q
q
q
Rectangular form
2
2
−
−




=
=
+
=




1
2
2
1
y
x
z
re
r
x
y
y
x
j
Polar form
Exponent
q
q
,
,
tan
iial form
	
(A.9)
A.2  MATHEMATICAL OPERATIONS
Two complex numbers z
x
jy
z
x
jy
1
1
1
2
2
2
=
+
=
+
and
 are equal if and only their real parts are equal 
and their imaginary parts are equal, that is
	
x
x
y
y
1
2
1
2
=
=
,
	
(A.10)
The complex conjugate of the complex number z = x + jy is
	
z
x
jy
r
re
j
* =
−
= ∠−
=
−
q
q	
(A.11)
Thus, the complex conjugate of a complex number is found by replacing every j by –j.
Given two complex number z
x
jy
r
z
x
jy
r
1
1
1
1
1
2
2
2
2
2
=
+
= ∠
=
+
=
∠
q
q
  and  
, their sum is
	
z
z
x
x
j y
y
1
2
1
2
1
2
+
=
+
+
+
(
)
(
)	
(A.12)
and their difference is
	
z
z
x
x
j y
y
1
2
1
2
1
2
−
=
−
+
−
(
)
(
)	
(A.13)
While it is more convenient to perform addition and subtraction of complex numbers in rectangular 
form, the product and quotient of two complex numbers are best done in polar or exponential form. 
For their product,
	
z z
rr
1 2
1 2
1
2
=
∠
+
q
q 	
(A.14)

299
Appendix A﻿
Alternatively, using the rectangular form
	
z z
x
jy
x
jy
x x
y y
j x y
x y
1 2
1
1
2
2
1 2
1 2
1 2
2 1
=
+
+
=
−
+
+
(
)(
)
(
)
(
)
	
(A.15)
For their quotient,
	
z
z
r
r
1
2
1
2
1
2
=
∠
−
q
q 	
(A.16)
Alternatively, using the rectangular form,
	
z
z
x
jy
x
jy
1
2
1
1
2
2
=
+
+
	
(A.17)
We rationalize the denominator by multiplying both the numerator and denominator by z2
*.
	
z
z
x
jy
x
jy
x
jy
x
jy
x x
y y
x
y
j x
1
2
1
1
2
2
2
2
2
2
1 2
1 2
2
2
2
3
2
=
+
−
+
−
=
+
+
+
(
)(
)
(
)(
)
y
x y
x
y
1
1 2
2
2
2
3
−
+
	
(A.18)
A.3  EULER’S FORMULA
Euler’s formula is an important result in complex variables. We derive it from the series expansion 
of ex, cos θ, and sin θ. We know that
	
e
x
x
x
x
x = +
+
+
+
+
1
2
3
4
2
3
4
!
!
!
	
(A.19)
Replacing x by jθ gives
	
e
j
j
jq
q
q
q
q
= +
−
−
+
+
1
2
3
4
2
3
4
!
!
!
	
(A.20)
Also,
	
cos
!
!
!
q
q
q
q
=
−
+
−
+
1
2
4
6
2
4
6
	
(A.21a)
	
sin
!
!
!
q
q
q
q
q
=
−
+
−
+
3
5
7
3
5
7
	
(A.21b)
so that
	
cos
sin
!
!
!
!
q
q
q
q
q
q
q
+
= +
−
−
+
+
−
j
j
j
j
1
2
3
4
5
2
3
4
5
	
(A.22)
Comparing Equations (A.20) and (A.22), we conclude that
	
e
j
jq
q
q
=
+
cos
sin 	
(A.23)
This is known as Euler’s formula. The exponential form of representing a complex number as in 
Equation (A.8) is based on Euler’s formula. From Equation (A.23), notice that
	
cos
Re(
),
sin
Im(
)
q
q
q
q
=
=
e
e
j
j
	
(A.24)

300
﻿Appendix A
and that
	
e jq
q
q
=
+
=
cos
sin
2
2
1	
(A.25)
Replacing θ by –θ in Equation (A.23) gives
	
e
j
j
−
=
−
q
q
q
cos
sin 	
(A.26)
Adding Equations (A.23) and (A.26) yields
	
cosq
q
q
=
+
(
)
−
1
2 e
e
j
j 	
(A.27)
Subtracting Equation (A.26) from Equation (A.23) yields
	
sinq
q
q
=
−
(
)
−
1
2 j e
e
j
j
	
(A.28)
The following identities are useful in dealing with complex numbers. If z
x
jy
r
=
+
= ∠q, then
	
zz
z
x
y
r
*
|
|
=
=
+
=
2
2
2
2	
(A.29)
	
z
x
jy
re
r
j
=
+
=
=
∠
q
q
/
/
2
2	
(A.30)
	
z
x
jy
r
n
r
n
j
n
n
n
n
n
=
+
=
∠
=
+
(
)
(cos
sin
)
q
q
q 	
(A.31)
	
z
x
jy
r
n
k n
k
n
n
n
n
1
1
1
2
0 1 2
1
/
/
/
(
)
/
/ ,
, , ,
,
=
+
=
∠
+
=
−
q
p
…
	
(A.32)
	
ln(
)
ln
ln
ln
re
r
e
r
j
j
k
k
j
j
q
q
q
p
=
+
=
+
+
=
2
(
integer)	
(A.33)
	
e
e
e
j
e
j
j
j
j
j
±
±
−
= −
=
=
= −
p
p
p
p
1
1
2
2
2
/
/
	
(A.34)
	
Re
Re
cos
Im
Im
(
)
(
)
e
e e
e
t
e
e e
j
t
t
j t
t
j
t
t
j t
a
w
a
w
a
a
w
a
w
w
+
+
(
) =
(
) =
(
) =
(
) = ee
t
ta
w
sin
	
(A.35)

301
Appendix B: Mathematical Formulas
The appendix contains all the formulas needed to solve the problems in this book.
B.1  QUADRATIC FORMULAS
The roots of the quadratic equation
	
ax
bx
c
2
0
+
+
=
	
	
x x
b
b
ac
a
1
2
2
4
2
,
= −±
−
	
B.2  TRIGONOMETRIC IDENTITIES
	
sin(
)
sin
−
= −
x
x	
	
cos(
)
cos
−
=
x
x	
	
sec
cos
,
csc
sin
x
x
x
x
=
=
1
1 	
	
tan
sin
cos
,
cot
tan
x
x
x
x
x
=
=
1
	
	
sin
cos
x
x
±
(
) = ±
90°
	
	
cos
sin
x
x
±
(
) =
90°
∓
	
	
sin
sin
x
x
±
(
) = −
180°
	
	
cos
cos
x
x
±
(
) = −
180°
	
	
cos
sin
2
2
1
x
x
+
= 	
	
a
A
b
B
c
C
sin
sin
sin
=
=
(law of sines)	
	
a
b
c
bc
A
2
2
2
2
=
+
−
cos
(law of cosines)	
	
tan
tan
(
1
2
1
2
A
B
A
B
a
b
a
b
−
(
)
+
(
)
=
−
+
law of tangents)	

302
﻿Appendix B
	
sin
sin cos
cos sin
x
y
x
y
x
y
±
(
) =
±
	
	
cos
cos cos
sin sin
x
y
x
y
x
y
±
(
) =
∓
	
	
tan
tan
tan
tan
tan
x
y
x
y
x
y
±
(
) =
±
1∓
	
	
2sin sin
cos
cos
x
y
x
y
x
y
=
−
(
) −
+
(
)	
	
2sin cos
sin
sin
x
y
x
y
x
y
=
+
(
) −
−
(
)	
	
2cos cos
cos
cos
x
y
x
y
x
y
=
+
(
) −
−
(
)	
	
sin
sin cos
2
2
x
x
x
=
	
	
cos
cos
sin
cos
sin
2
2
1
1
2
2
2
2
2
x
x
x
x
x
=
−
=
−=
−
	
	
tan
tan
tan
2
2
1
2
x
x
x
=
−
	
	
cos
cos(
)
2
1
2
2
x
x
=
+
	
	
sin
cos(
)
2
1
2
2
x
x
=
−
	
	
a
x
b
x
K
x
K
a
b
b
a
cos
sin
cos
,
tan
+
=
+
(
)
=
+
=
−




−
q
q
where
and
2
2
1
	
	
e
x
j
x
jx
±
=
±
cos
sin
(Euler’s formula)	
	
cos x
e
e
jx
jx
=
+
−
2
	
	
sin x
e
e
j
jx
jx
=
−
−
2
	
B.3  TRIGONOMETRIC SUBSTITUTION
Form
Trig Sub
Identity
a
x
2
2
+
x = a tan θ
1
2
2
+
=
tan
sec
q
q
a
x
2
2
−
x = a sin θ
1
2
2
−
=
sin
cos
q
q
x
a
2
2
−
x = a sec θ
sec
tan
2
2
1
q
q
−=

303
Appendix B﻿
B.4  HYPERBOLIC FUNCTIONS
	
sinh x
e
e
x
x
=
−
(
)
−
1
2
	
	
cosh x
e
e
x
x
=
+
(
)
−
1
2
	
	
tanh
sinh
cosh
x
x
x
=
	
	
coth
tanh
x
x
=
1
	
	
csc
sinh
hx
x
=
1
	
	
sec
cosh
hx
x
=
1
	
	
sinh
sinh cosh
cosh sinh
x
y
x
y
x
y
±
(
) =
±
	
	
cosh
cosh
cosh
sinh sinh
x
y
x
y
x
y
±
(
) =
±
	
	
tan
tan
tan
tan
tan
x
y
x
y
x
y
±
(
) =
±
1∓
	
B.5  DERIVATIVES
If U = U(x), V = V(x), and a = constant,
	
d
dx aU
a dU
dx
(
) =
	
	
d
dx UV
U dV
dx
V dU
dx
(
) =
+
	
	
d
dx
U
V
V dU
dx
U dV
dx
V



=
−
2
	
	
d
dx aU
naU
n
n
(
) =
−1	
	
d
dx a
a
a dU
dx
U
U
(
) =
1n
	
	
d
dx e
e
dU
dx
U
U
(
) =
	

304
﻿Appendix B
	
d
dx
U
U dU
dx
sin
cos
(
) =
	
	
d
dx
U
U dU
dx
cos
sin
(
) = −
	
	
d
dx
U
U
dU
dx
tan
cos
=
1
2
	
B.6  INDEFINITE INTEGRALS
If U = U(x), V = V(x), and a = constant,
	
adx
ax
C
=
+
∫
	
	
UdV
UV
VdU
∫
∫
=
−
(integration by parts)	
	
U dU
U
n
C
n
n
n
∫
=
+
+
≠
+1
1
1
,
	
	
dU
U
U
C
∫
=
+
1n
	
	
a dU
a
a
C
a
a
U
U
∫
=
+
>
≠
1n
,
,0
1	
	
e dx
a e
C
ax
ax
∫
=
+
1
	
	
xe dx
e
a
ax
C
ax
ax
∫
=
−
(
)+
2
1
	
	
x e dx
e
a
a x
ax
C
ax
ax
2
3
2
2
2
2
∫
=
−
+
(
)+
	
	
1n
1n
x dx
x
x
x
C
=
−
+
∫
	
	
sin
cos
ax dx
a
ax
C
= −
+
∫
1
	
	
cos
sin
ax dx
a
ax
C
=
+
∫
1
	
	
sin
sin
2
2
2
4
ax dx
x
ax
a
C
=
−
+
∫
	

305
Appendix B﻿
	
cos
sin
2
2
2
4
ax dx
x
ax
a
C
=
+
+
∫
	
	
x
ax dx
a
ax
ax
ax
C
sin
sin
cos
=
−
(
)+
∫
1
2
	
	
x
axdx
a
ax
ax
ax
C
cos
cos
sin
=
+
(
)+
∫
1
2
	
	
x
ax dx
a
ax
ax
ax
a x
ax
C
2
3
2
2
1 2
2
sin
sin
cos
cos
=
+
−
(
)+
∫
	
	
x
ax dx
a
ax
ax
ax
a x
ax
C
2
3
2
2
1 2
2
cos
cos
sin
sin
=
−
+
(
)+
∫
	
	
e
bx dx
e
a
b
a
bx
b
bx
C
ax
ax
∫
=
+
−
(
)+
sin
sin
cos
2
2
	
	
e
bx dx
e
a
b
a
bx
b
bx
C
ax
ax
∫
=
+
+
(
)+
cos
cos
sin
2
2
	
	
sin
sin
sin
sin
,
ax
bx dx
a
b x
a
b
a
b x
a
b
C
a
b
=
−
(
)
−
(
)
−
+
(
)
+
(
)
+
≠
∫
2
2
2
2	
	
sin
cos
cos
cos
,
ax
bx dx
a
b x
a
b
a
b x
a
b
C
a
b
= −
−
(
)
−
(
)
−
+
(
)
+
(
)
+
≠
∫
2
2
2
2	
	
cos
cos
sin
sin
,
ax
bx dx
a
b x
a
b
a
b x
a
b
C
a
b
=
−
(
)
−
(
)
+
+
(
)
+
(
)
+
≠
∫
2
2
2
2	
	
dx
a
x
a
x
a
C
2
2
1
1
+
=
+
∫
−
tan
	
	
x dx
a
x
x
a
x
a
C
2
2
2
1
+
=
−
+
∫
−
tan
	
	
dx
a
x
a
x
x
a
a
x
a
C
2
2 2
2
2
2
1
1
2
1
+
(
)
=
+
+



+
∫
−
tan
	
B.7  DEFINITE INTEGRALS
If m and n are integers,
	
sin ax dx =
∫
0
0
2p
	

306
﻿Appendix B
	
cosax dx =
∫
0
0
2p
	
	
sin
cos
2
2
0
0
2
ax dx
ax dx
=
=
∫
∫
p
p
p
	
	
sin
sin
cos
cos
,
mx
nx dx
mx
nx dx
m
n
=
=
≠
∫
∫
0
0
0
p
p
	
	
sin
cos
,
,
mx
nx dx
m
n
m
m
n
m
n
=
+
=
−
+
=



∫
0
2
2
0
2
p
even
odd
	
	
sin
sin
sin
sin
,
,
mx
nx dx
mx
nx dx
m
n
m
n
=
=
≠
≠



−∫
∫
0
0
2
p
p
p
p
	
	
sin
,
,
,
ax
x
dx
a
a
a
=
−







∞
∫
p
p
2
0
2
0
> 0
= 0
< 0
	
	
sin2
0
2
x
x
dx
∞
∫
= p 	
	
cos
,
,
bx
x
a dx
a e
a
b
ab
2
2
0
2
0
0
+
=
>
>
∞
−
∫
p
	
	
x
bx
x
a dx
e
a
b
ab
sin
,
,
2
2
0
2
0
0
+
=
>
>
∞
−
∫
p
	
	
sin
sin
cx dx
c x dx
0
2
0
1
2
∞
∞
∫
∫
=
=
	
	
sin
sin
cos
cos
,
2
0
2
0
2
0
2
0
2
nx dx
x dx
nx dx
x dx
n
=
=
=
=
=
∫
∫
∫
∫
p
p
p
p
p
an integeer	
	
sin
sin
cos
cos
,
,
,
mx
nx dx
mx
nx dx
m
n m n
=
=
≠
∫
∫
0
0
0
p
p
integers	

307
Appendix B﻿
	
sin
cos
,
,
mx
nx dx
m
m
n
m
n
m
n
=
−
+
=
+
=



∫
2
0
2
2
0
odd
even
p
	
	
e
dx
t
j
tx
±
−∞
∞
=
∫
2p
d( )	
	
x e
dx
n
a
n
ax
n
−
∞
+
∫
=
0
1
! 	
	
e
dx
a
a
a x
−
∞
=
>
∫
2 2
2
0
0
p ,
	
	
x e
dx
n
a
a
n
ax
n
n
2
0
1
2
1 3 5
2
1
2
∞
−
+
∫
=
−
i i iii(
)
p 	
	
x
e
dx
n
a
a
n
ax
n
2
1
0
1
2
2
0
+
∞
−
+
∫
=
>
! ,
	
B.8  L’HOPITAL’S RULE
If f(0) = 0 = h(0), then
	
x
x
f x
h x
f
x
h x
→
→
=
′
′
0
0
lim
( )
( )
lim
( )
( ) 	
where the prime indicates differentiation.
B.9  SUMMATION
	
k
N N
k
N
=
+
=∑
1
2
1
1
(
)	
	
k
N N
N
k
N
2
1
1
6
1 2
1
=
+
+
=∑
(
)(
)	
	
k
N
N
k
N
3
2
2
1
1
4
1
=
+
=∑
(
) 	
	
a
a
a
a
k
k
N
N
=
+
∑
=
−
−
≠
0
1
1
1
1	

308
﻿Appendix B
	
a
a
a
a
a
k
k M
N
N
M
=
+
∑
=
−
−
≠
1
1
1	
	
N
k
a
b
a
b
N
k
N
N
k
k
N
k
k
N
k
N 



=
+



=
−
−
=∑
(
) ,
!
(
)! !
where
0
	
B.10  NUMERICAL INTEGRATION APPROXIMATIONS
	
TRAP( )
n
b
a
n
f x
f x
f x
f x
f x
n
n
=
−
(
)+
( )+
(
)+
+
(
)+ (
)


−
2
2
2
2
0
1
2
1

	
	
SIMP( )
n
b
a
n
f x
f x
f x
f x
f x
f x
n
n
=
−
(
)+
( )+
(
)+
( )+
+
(
)+
(
−
−
3
4
2
4
2
4
0
1
2
3
2
1

)+ (
)


f xn
	
B.11  POWERS OF THE TRIG FUNCTIONS
	
1)	Integrals of the form: sin
cos
m
n
x
x dx
∫
 m or n odd
	
Strategy: If m is odd, save a sine factor and convert to cosine
	
If n is odd, save a cosine factor and convert to sine
	
2)	Integrals of the form: sin
cos
m
n
x
x dx
∫
 m and n even and non-negative
	
Strategy: use ½ angle identities:
	
cos
cos(
)
2
1
2
2
x
x
=
+
; sin
cos(
)
2
1
2
2
x
x
=
−
	
3)	Integrals of the form: sec
tan
m
n
x
x dx
∫
; if m is even
	
Strategy: Save a sec2 x and convert to a tangent
	
4)	Integrals of the form: sec
tan
m
n
x
x dx
∫
; if n is odd
	
Strategy: Save a secx tanx and convert to secant
	
5)	 tann x dx
∫
 n any positive integer
	
Strategy: convert a tan2 x to sec2x – 1 and distribute; repeat if necessary
	
6)	 secm x dx
∫
; m is odd
	
Strategy: Integrate by parts

309
Appendix C: MATLAB
The word of MATLAB is an abbreviation for Matrix Laboratory implying that MATLAB is a 
MATLAB is available for Macintosh, Unix, and Windows operating systems.
The appendix introduces the reader to programming with the software package MATLAB. It is 
assumed that the reader has had some previous experience with a high-level programming language 
and is familiar with the techniques of writing loops, branching using logical relations, calling sub-
routines, and editing; therefore, this appendix starts with the essential and present computational 
tools that employ matrices and vectors/arrays to carry out numerical analysis, signal processing, and 
scientific visualization tasks.
A brief introduction to MATLAB is presented in this appendix and Chapter 1 are enough to be 
able to solve problems in this book. Other information on MATLAB required in this book is pro-
vided on a chapter-to-chapter basis as needed.
MATLAB has become a powerful tool for technical professionals worldwide. A student version 
of MATLAB is available for PCs. A copy of MATLAB can be obtained from:
The Mathworks, Inc.
3 Apple Hill Drive
Natick, MA 01760-2098
Phone:(508) 647-7000
Website: http://www.mathworks.com
To begin to use MATLAB, we use the following operators. Type commands into MATLAB 
prompt “>>” in the command window. To get help, type
>> help
C.1  MATLAB BASICS
To ﬁnd additional information about commands, options, and examples, the reader is urged to make 
use of the online help facility and the Reference and User’s Guides that accompany the software.
Table C.1 Basic Operations
Operation
MATLAB formula
Addition
a + b
Subtraction
a – b
Division (right)
a/b (means a ÷ b)
Division (left)
a\b (means b ÷ a)
Multiplication
a*b
Power
a^b

310
﻿Appendix C
Table C.2 Basic Functions
Function
Remark
abs(x)
Absolute value or complex magnitude of x
acos, acosh(x)
Inverse cosine and inverse hyperbolic cosine of x in radians
acot, acoth(x)
Inverse cotangent and inverse hyperbolic cotangent of x in radians
angle(x)
Phase angle (in radian) of a complex number x 
asin, asinh(x)
Inverse sine and inverse hyperbolic sine of x in radians
atan, atanh(x)
Inverse tangent and inverse hyperbolic tangent of x in radians
conj(x)
Complex conjugate of x
cos, cosh(x)
Cosine and hyperbolic cosine of x in radian
cot, coth(x)
Cotangent and hyperbolic cotangent of x in radian
exp(x)
Exponential of x
fix
Round toward zero
imag(x)
Imaginary part of a complex number x
log(x)
Natural logarithm of x
log2(x)
Logarithm of x to base 2
log10(x)
Common logarithms (base 10) of x
real(x)
Real part of a complex number x
sin, sinh(x)
Sine and hyperbolic sine of x in radian
sqrt (x)
Square root of x
tan, tanh(x)
Tangent and hyperbolic tangent of x in radian
Table C.3 Matrix Operations
Operation
Remark
A’
Finds the transpose of matrix A
det(A)
Evaluates the determinant of matrix A
inv(A)
Calculates the inverse of matrix A
eig(A)
Determines the eigenvalues of matrix A
diag(A)
Finds the diagonal elements of matrix A
expm(A)
Exponential of matrix A
Table C.4 Special Matrices, Variables, And Constants
Matrix/Variable/Constant
Remark
eye
Identity matrix
ones
An array of ones
zeros
An array of zeros
i or j
Imaginary unit or sqrt(–1)
pi
3.142
NaN
Not a number
inf
Infinity
eps
A very small number, 2.2e–16
rand
Random element

311
Appendix C﻿
Table C.5 Vector Operations
Vector
Remark
sum(a)
Sum of vector elements
mean(a)
Mean of vector elements
std(a)
Standard deviation
max(a)
Maximum
min(a)
Minimum
Table C.6 Complex Numbers
real(A)
The real part of A
imag(A)
The imaginary part of A
conj(A)
The complex conjugate of A
abs(A)
The modulus of A
angle(A)
The phase angle of A
Table C.7 Matrix Operations
Operation
MATLAB formula
Matrix Addition
+
Matrix Subtraction
–
Matrix Multiplication
*
Right Matrix Division
/
Left Matrix Division
\
Raise to a power
^
Transpose matrix
‘
Table C.8 Array Operations
Operation
MATLAB formula
Array Multiplication
.*
Right Array Division
./
Left Array Division
.\
Raise to a power
.^
Table C.9 Matrices and Functions
Operation
Remark
sqrtm(x)
The matrix square root
expm(x)
The matrix exponential base e
logm(x)
The matrix natural logarithm

312
﻿Appendix C
Table C.10 Utility Matrices
Operation
Remark
zeros(n)
n*n matrix where each element is 0 
zeros(m,n)
m*n matrix where each element is 0 
ones(n)
n*n matrix where each element is 1 
ones(m,n)
m*n matrix where each element is 1
rand(n)
n*n matrix of random numbers 
rand(m,n)
m*n matrix of random numbers 
eye(n)
n*n identity matrix
Table C.11 Relational and Logical Operations
Operation
MATLAB formula
Less than
< 
Less than or equal
<= 
Greater than
> 
Greater than or equal
>= 
Equal
= = 
Not equal
~=
Table C.12 Boolean logic operations
Operation
MATLAB formula
AND
& 
OR
| 
NOT
~
Table C.13 Variable Control Commands
Operation
Remark
who
List all the variables in memory
whos
List all the variables in memory with more information
clear
Remove all variables from memory
clear <variable>
Remove specified variables from memory
Table C.14 File Control Commands
Operation
Remark
dir
List the contents of the current director
ls
List the contents of the current directory
what
List the MATLAB files in the current directory
cd <directory>
Change the current directory
type <filename>
Display the contents of a text or.m file
delete <filename>
Delete a file
diary <filename>
Record all commands and results to a file
Diary
off Stop above

313
Appendix C﻿
Table C.15 Saving, Exporting and Importing Data
Operation
Remark
Save
Save all variable to the file MATLAB.mat 
load
Load in variables from the file MATLAB.mat 
save <filename>
Save all the variable to the file filename.mat
load <filename>
Load in the variables from the file filename.mat
save <filename> <variable>
Save only the variable variable to the file filename.mat
load <filename> <variable>
Load in only the variable variable from the file filename.mat
save <filename> <variable> -ascii
Save the variable to the text file filename
load <filename>.<ext>
Load from the text file, to the variable called filename
save <filename> <variable> -ascii -
double Save variable to the text file filename using double 
precision
csvwrite(<filename>.cvs, M)
Write matrix M to csv
file. M=csvread(<filename>.csv)
Load from the csv file, into variable M
C.2  USING MATLAB TO PLOT
To plot using MATLAB is easy. For a two-dimensional plot, use the plot command with two argu-
ments, such as
>> plot(xdata,ydata)
where xdata and ydata are vectors of the same length containing the data to be plotted.
MATLAB will let you graph multiple plots together and distinguish them with different colors.
It is obtained with the command plot (xdata, ydata, “color”), where the color is indicated by 
using a character string from the options listed in Table C.5.
Table C.16 Various Color and Line Types
y
yellow
.
point
m
magenta
o
circle
c
cyan
x
x-mark
r
red
+
plus
g
green
–
solid
b
blue
*
star
w
white
:
dotted
k
black
-.
dashdot
--
dashed

314
﻿Appendix C
Table C.17 Plotting Commands
Command
Comments
bar(x,y)
a bar graph
contour(z)
a contour plot
errorbar(x,y,l,u)
a plot with error bars
hist(x)
a histogram of the data
plot3(x,y,z)
a three-dimensional version of plot()
polar(r, angle)
a polar coordinate plot
stairs(x,y)
a stairstep plot
stem(n,x)
plots the data sequence as stems
subplot(m,n,p)
multiple (m-by-n) plots per window
surf(x,y,x,c)
a plot of a three-dimensional colored surface
hold on
Hold the plot on the screen
hold off
Release the plot on the screen
hold
Toggle the hold state

315
Index
A
Alternative method, 48, 55
Analog-filter design
Butterworth filter, 263–267
Chebyshev filter, 268–273
Analog signal, 6
Analog-to-digital filter design, 237
Aperiodic sequences, 19
Argand diagram, 180
Associative property, 48
Audio sampling, 205
Autocorrelation, 135
B
Band-limited signals, 194
Band-pass filters, 200, 209
magnitude frequency response, 211–212
Band-pass sampling, 200
Band-stop filters, 209
magnitude frequency response, 212
BIBO stability, 183–184
Bilinear transformation, 212, 214, 237–239, 273–274, 279
Boolean logic operations, 312
Butterworth analog filter, 212, 263
C
Cascade (series) realization, 225–226
Cascade systems, 89–90
Cauchy’s integral theorem, 154, 155
Cauchy’s residue theorem, 155
Causality, 32, 39
Characteristic polynomial, 69
Chebyshev analog filter, 212, 268
Classical approach, 68–69
Command window, 8
Commutative property, 47–48
Complex numbers
Euler’s formula, 299–300
mathematical operations, 298–299
phasor diagram, 181
representation, 297–298
Continuous and discrete signals, 1–17
fundamental sequences
impulse response, MATLAB, 11–12
signal duration, 12
MATLAB, 8–11
commands, 9–11
windows, 8–9
signals and systems, 6
classification, 6–7
Continuous signals, 1–5
Continuous-time signal, 1, 5–6, 36–37
MATLAB generation, 1–2
operations, signals and sequences, 2–5
Continuous-time system, 36–37
Contour integration, 154–155
Convolution, 47–64, 92, 118, 123–124
linear convolution, 47
properties, 38, 118
associative property, 48
commutative property, 47–48
distributive property, 48
types, 48–60
equations method, 49
graphical method, 54
tabular method, 55
D
Data type, 8
Decimation-in-frequency method, 109–112, 129, 131
Decimation-in-time method, 112–118, 129
Definite integrals, 305–307
Delay operator, 38
Deterministic signal, 6
DFT, see Discrete fourier transform
Difference equations, 39, 65–73, 91–93, 179,  
180–182, 223
equation solving methods
the classical approach, 68–72
the tabulation method, 67–68
using z-transforms, 67
and impulse responses, 65–66
system representation, impulse response, 66–67
Different windowing, 219
Digital audio sampling, 205
Digital filters
band-pass filters, 209
magnitude frequency response, 211–212
band-stop filters, 209
magnitude frequency response, 212
finite impulse response (FIR) digital filter, 218–220
advantages, 218
different windowing, 219
gibbs phenomenon, 219
specifications, 218–219
high-pass filters, 209
magnitude frequency response, 210–211
IIR filters vs. FIR filters, 219–220
infinite-impulse-response (IIR) digital filter, 212–217
characteristics, 216–217
filters design, bilinear transformation, 213–215
infinite-impulse response filtering, 215
low-pass filters, 209
magnitude frequency response, 209–210

316
﻿Index
Digital signal, 6
MATLAB generation, 12–17
Dimensioning window, 8
Direction-form I realization, 223–224
Direction-form II realization, 224–225
Discrete fourier series (DFS), 79–83
Discrete fourier transform (DFT), 109–127, 216
decimation-in-frequency method, 109–112
decimation-in-time method, 112–118
inverse discrete fourier transform, MATLAB 
generation, 124–125
linear convolution, 123–124
matlab sequence, 122–123
properties
convolution, 118
linearity, 118
periodicity, 117–118
Discrete signal, 87–88
Discrete-time fourier series (DTFS), 75–84
discrete fourier series, 79–83
DTFS coefficients, periodic discrete signals,  
75–77
Parseval’s relation, 77–78
Discrete-time fourier transform (DTFT), 75, 85–108
applications, 91
difference equations, 91–92
discrete signal, 87–88
frequency response, 85–87
in MATLAB, 102–106
interconnection of systems, 89–90
inverse DTFT, 88–89
LSI systems, 91–92
properties, 91
solving difference equations, 93–102
Discrete-time signal, 1, 5–6, 19, 75
complex sequences, 5–6
Discrete-time systems, 19, 25, 37–39
convolution property, 38
delay operator, 38
frequency response, 38–39
impulse function, 38
impulse response, 38
system properties
additivity, 26
homogeneity, 26
memoryless system, 25
stability, 26–27
Distributive property, 48
DTFS, see Discrete-Time Fourier Series
DTFT, see Discrete-time Fourier transform
E
Edit window, 8
Eigenvalue, 85
Energy signal, 7
Equations method, 49
convolution of two sequences
in MATLAB, 53–54
Euler’s formula, 299–300
Even and Odd, 20–23
Even signal, 20–23
F
Fast fourier transform (FFT), 10, 129–141
decimation-in-frequency FFT, 129, 131, 133
decimation-in-time FFT, 129–130, 132, 133
defined, 129
FFT of different signals, MATLAB, 134–135
power spectral density, square magnitude and 
autocorrelation, 135–140
FFT equivalence, 136–140
N-phase sequence component transformation, 
136–140
Feedback network, 90
FFT, see Fast fourier transform
Filter coefficients, 288, 290–294
Finite impulse response (FIR) digital filter, 215–219, 
217–219, 241–261, 285–288
advantages, 218
design, 285–292
different windowing, 219
gibbs phenomenon, 219
length estimation, window functions, 252–259
representation, 241–246
specifications, 218–219
window method, 246–252
Finite-length impulse response (FIR) system, 65
Finite-length sequence, 12
FIR, see Finite impulse response digital filter; Finite-
length impulse response system
Frequency response, 38–39, 85–87, 102–103, 172–173, 
209, 216
in MATLAB, 102–106
G
Gibbs phenomenon, 219
Graphical method, 54
Graphics window, 8
Group delay, 86
H
Hermitian operator, 138
High-pass filters, 209, 265, 270, 283–284
magnitude frequency response, 210–211
Homogeneous, 26
Homogeneous solution, 69
Hyperbolic functions, 303
I
IDFT, see Inverse discrete fourier transform
IDTFT, see Inverse discrete-time fourier transform
IIR, see Infinite-impulse-response digital filter; Infinite-
length impulse response (IIR) system
Impulse function, 38
Impulse response, 11–12, 38, 47
in MATLAB, 11–12
Impulse sequences, 135
Indefinite integrals, 304–305
Infinite-impulse-response (IIR) digital filter
characteristics, 216–217

317
Index﻿
design
analog-filter, 263–277
band-pass IIR filter, 280–281
band-pass IIR filter, MATLAB, 284–285
band-stop IIR filter, 281–282
higher-order IIR digital filters, 277–279
high-pass IIR filter, 279–280
high-pass IIR filter, MATLAB, 283–284
low-pass IIR filter, MATLAB, 282–283
filters design, bilinear transformation,  
213–215
implementation
analog-to-digital filter design, 237
bilinear transformation, 237–239
infinite-impulse response filtering, 215
notch filter implementation, MATLAB, 234–236
structures
cascade (series) realization, 225–226, 229–230
direction-form I realization, 223–224, 227–229
direction-form II realization, 224–225, 227–229
parallel realization, 226–227, 229–231
transposed-direct-form-I, 231–232
transposed-direct-form-II, 232–234
Infinite-impulse-response (IIR) filter, 212–217, 219–220, 
223–239, 263–285
Infinite-length impulse response (IIR) system, 65
Infinite-length sequence, 12
Input–output window, 8
Inverse discrete fourier transform (IDFT), 109
MATLAB generation, 124–125
Inverse discrete-time fourier transform (IDTFT), 88–89
Inverse z-transform, 151–162
contour integration, 154–155
partial fraction expansion, 151–154
power series expansion, 154
L
Left-sided sequence, 12
L’Hopital’s rule, 307
Linear convolution, 47, 123–124
Linearity property, 118
Linear shift-invariant (LSI) system, 47, 66, 91–92
Linear time-invariant (LTI) causal systems
causality, 32
linearity, 27–28
time-invariance, 31
Linear time-invariant (LTI) system, 27–36, 66
Low-pass filters, 209, 263, 268, 282–283
magnitude frequency response, 209–210
LSI, see Linear shift-invariant system
M
Mathematical formulas
definite integrals, 305–307
derivatives, 303–304
hyperbolic functions, 303
indefinite integrals, 304–305
L’Hopital’s rule, 307
numerical integration approximations, 308
quadratic formulas, 301
summation, 307–308
trig functions powers, 308
trigonometric identities, 301–302
trigonometric substitution, 302
Matrix Laboratory (MATLAB), 311
array operations, 311
basic function, 310
basic operations, 309
Boolean logic operations, 312
color and line types, 313
commands, 9–11
complex numbers, 311
file control commands, 312
impulse response in, 11–12
matrices, variables, and constants, 310
matrices and functions, 311
matrix operations, 310, 311
as plot, 313
plotting commands, 314
relational and logical operations, 312
saving, exporting and importing data, 313
utility matrices, 312
variable control commands, 312
vector operations, 311
windows, 8–9
Memory, 40
Memoryless system, 25
N
Nonperiodic signal, 7
Non-uniform quantization, 201
Notch filter implementation, MATLAB, 234–236
Numerical integration approximations, 308
Nyquist interval, 196
Nyquist rate, 196, 198
O
Odd signal, 20–23
One-sided amplitude spectrum, 117
P
Parallel realization, 226–231
Parallel systems, 90
Parseval’s relation, 77–78
Partial fraction expansion, 151–154
Pass-band-cut-off (edge) frequency, 218
Periodic and nonperiodic signals, 7
Periodic discrete signals, 76, 77
Periodicity property, 117–118
Periodic sequences, 19
Periodic signal, 7
Polar form, 297
Pole-zero diagrams, 172
Pole-zero stability
BIBO stability, 182–183
concept poles and zeros
stability determination, z-transform, 179
z-plane, 180
z-transform, 179–180

318
﻿Index
difference equation and transfer function, 180–182
stability rules, 184
z-plane pole-zero plot and stability, 183–184
Power and energy signals, 7
Power series expansion, 154
Power signal, 7
Power spectral density (PSD), 135–140
square magnitude and autocorrelation, 135–140
FFT equivalence, 136–140
N-phase sequence component transformation, 
136–140
Problems, 17–18, 42–45, 60–64, 72–73, 83–84, 106–108, 
125–127, 140–141, 163–164, 174–177, 191–192, 
205–208, 220–221, 239–240, 259–261, 
292–293
Properties of Discrete Fourier Transform, 117–118
PSD, see Power spectral density
Q
Quadratic formulas, 301
Quantization, 200–201
Quantization distortion, 201
R
Random signal, 6
Region of convergence (ROC), 144–147
Right-sided sequence, 12
ROC, see Region of convergence 
S
Sampling
band-limited signals, 194
of continuous-time signals, 194–196
DTFT vs. FT, discrete-time signals, 193–194
rate, 205–206
theorem, 196–199
Shifting function, 4
Signal manipulations, 23–25
independent variable transformations
addition, 24
multiplication, 24
reversal, 23
scaling, 24
shifting, 23
signal decomposition, 24–25
time-scaling, 23–24
Signals and systems, 6, 7
classification, 6–7
Signals properties
aperiodic sequences, 19
continuous-time system, 36–37
discrete-time systems
additivity, 26
convolution property, 38
delay operator, 38
frequency response, 38–39
homogeneity, 26
impulse function, 38
impulse response, 38
memoryless system, 25
stability, 26–27
even signal, 20–23
linear time-invariant causal systems (LTI)
causality, 32
linearity, 27–28
time-invariance, 31
odd signal, 20–23
periodic sequences, 19
signal manipulations
independent variable transformations, 23–25
system output
causality, 39
invertibility, 40
memory, 40
stability, 39
Stability, 26, 39, 184, 215
Stopband-edge frequency, 218
Superposition summation, 27
System output
causality, 39
invertibility, 40
memory, 40
stability, 39
T
Tabular method, 55
Tabulation method, 67–68
Time scaling, 23–24
Transfer function, 180–182
Transposed-direct-form-I structure, 231–232
Transposed-direct-form-II structure, 232–234
Trig functions powers, 308
Trigonometric identities, 301–302
Trigonometric substitution, 302
Twiddle factor, 109, 113
Two-sided amplitude spectrum, 116
Two-sided sequence, 12
U
Uniform quantization, 201
Unit sample response, see Impulse response
Unit step sequences, 136
Unit step signal, 14
W
Window method, 246–252
X
Xdata, 313
Y
Ydata, 313
Z
Z-plane, 180
Z-plane diagram, 181
Z-plane pole-zero plot, 184

319
Index﻿
Z-transform, 143–155, 165–172, 179–180
applications
audio sampling, 205
band-pass sampling, 200
digital system implementation, 165–171
frequency response, 172–178
LTI system response evaluation, 165
non-uniform quantization, 201
pole-zero diagrams, Z-domain, 172
quantization, 200–201
sampling rate, 205–206
sampling theorem, 196–199
uniform quantization, 201
inverse z-transform, 151–162
contour integration, 154–155
partial fraction expansion, 151–154
power series expansion, 154
properties, 147–151
region of convergence (ROC), 144–147
representation, 143–144


