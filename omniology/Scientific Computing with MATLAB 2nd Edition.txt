

Scientific Computing 
with MATLAB®
Second Edition


Scientific Computing 
with MATLAB®
Second Edition
Dingyü Xue
Northeastern University
Shenyang, China 
 YangQuan Chen
University of California
Merced, USA 

MATLAB® is a trademark of The MathWorks, Inc. and is used with permission. The MathWorks does not warrant the 
accuracy of the text or exercises in this book. This book’s use or discussion of MATLAB® software or related products 
does not constitute endorsement or sponsorship by The MathWorks of a particular pedagogical approach or particular 
use of the MATLAB® software.
CRC Press
Taylor & Francis Group
6000 Broken Sound Parkway NW, Suite 300
Boca Raton, FL 33487-2742
© 2016 by Taylor & Francis Group, LLC
CRC Press is an imprint of Taylor & Francis Group, an Informa business
No claim to original U.S. Government works
Version Date: 20160113
International Standard Book Number-13: 978-1-4987-5778-2 (eBook - PDF)
This book contains information obtained from authentic and highly regarded sources. Reasonable efforts have been 
made to publish reliable data and information, but the author and publisher cannot assume responsibility for the valid-
ity of all materials or the consequences of their use. The authors and publishers have attempted to trace the copyright 
holders of all material reproduced in this publication and apologize to copyright holders if permission to publish in this 
form has not been obtained. If any copyright material has not been acknowledged please write and let us know so we may 
rectify in any future reprint.
Except as permitted under U.S. Copyright Law, no part of this book may be reprinted, reproduced, transmitted, or uti-
lized in any form by any electronic, mechanical, or other means, now known or hereafter invented, including photocopy-
ing, microfilming, and recording, or in any information storage or retrieval system, without written permission from the 
publishers.
For permission to photocopy or use material electronically from this work, please access www.copyright.com (http://
www.copyright.com/) or contact the Copyright Clearance Center, Inc. (CCC), 222 Rosewood Drive, Danvers, MA 01923, 
978-750-8400. CCC is a not-for-profit organization that provides licenses and registration for a variety of users. For 
organizations that have been granted a photocopy license by the CCC, a separate system of payment has been arranged.
Trademark Notice: Product or corporate names may be trademarks or registered trademarks, and are used only for 
identification and explanation without intent to infringe.
Visit the Taylor & Francis Web site at
http://www.taylorandfrancis.com
and the CRC Press Web site at
http://www.crcpress.com

Contents
Preface
xiii
Preface of the First Edition
xv
1
Computer Mathematics Languages — An Overview
1
1.1
Computer Solutions to Mathematics Problems
. . . . . . . . . . . . . . . .
1
1.1.1
Why should we study computer mathematics language? . . . . . . .
1
1.1.2
Analytical solutions versus numerical solutions . . . . . . . . . . . .
5
1.1.3
Mathematics software packages: an overview
. . . . . . . . . . . . .
5
1.1.4
Limitations of conventional computer languages . . . . . . . . . . . .
6
1.2
Summary of Computer Mathematics Languages
. . . . . . . . . . . . . . .
8
1.2.1
A brief historic review of MATLAB
. . . . . . . . . . . . . . . . . .
8
1.2.2
Three widely used computer mathematics languages . . . . . . . . .
8
1.2.3
Introduction to free scientiﬁc open-source softwares . . . . . . . . . .
9
1.3
Outline of the Book
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
1.3.1
The organization of the book . . . . . . . . . . . . . . . . . . . . . .
9
1.3.2
How to learn and use MATLAB
. . . . . . . . . . . . . . . . . . . .
11
1.3.3
The three-phase solution methodology . . . . . . . . . . . . . . . . .
11
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2
Fundamentals of MATLAB Programming and Scientiﬁc Visualization
15
2.1
Essentials in MATLAB Programming
. . . . . . . . . . . . . . . . . . . . .
16
2.1.1
Variables and constants in MATLAB . . . . . . . . . . . . . . . . . .
16
2.1.2
Data structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
2.1.3
Basic statement structures of MATLAB . . . . . . . . . . . . . . . .
18
2.1.4
Colon expressions and sub-matrices extraction
. . . . . . . . . . . .
19
2.2
Fundamental Mathematical Calculations
. . . . . . . . . . . . . . . . . . .
20
2.2.1
Algebraic operations of matrices
. . . . . . . . . . . . . . . . . . . .
20
2.2.2
Logic operations of matrices . . . . . . . . . . . . . . . . . . . . . . .
22
2.2.3
Relationship operations of matrices . . . . . . . . . . . . . . . . . . .
22
2.2.4
Simpliﬁcations and presentations of analytical results
. . . . . . . .
22
2.2.5
Basic number theory computations . . . . . . . . . . . . . . . . . . .
24
2.3
Flow Control Structures of MATLAB Language
. . . . . . . . . . . . . . .
25
2.3.1
Loop control structures
. . . . . . . . . . . . . . . . . . . . . . . . .
26
2.3.2
Conditional control structures . . . . . . . . . . . . . . . . . . . . . .
27
2.3.3
Switch structure
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
2.3.4
Trial structure
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
2.4
Writing and Debugging MATLAB Functions
. . . . . . . . . . . . . . . . .
30
v

vi
Contents
2.4.1
Basic structure of MATLAB functions . . . . . . . . . . . . . . . . .
30
2.4.2
Programming of functions with variable numbers of arguments in
inputs and outputs . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
2.4.3
Inline functions and anonymous functions . . . . . . . . . . . . . . .
34
2.4.4
Pseudo code and source code protection . . . . . . . . . . . . . . . .
34
2.5
Two-dimensional Graphics
. . . . . . . . . . . . . . . . . . . . . . . . . . .
35
2.5.1
Basic statements of two-dimensional plotting
. . . . . . . . . . . . .
35
2.5.2
Plotting with multiple horizontal or vertical axes . . . . . . . . . . .
37
2.5.3
Other two-dimensional plotting functions
. . . . . . . . . . . . . . .
38
2.5.4
Plots of implicit functions . . . . . . . . . . . . . . . . . . . . . . . .
39
2.5.5
Graphics decorations . . . . . . . . . . . . . . . . . . . . . . . . . . .
40
2.5.6
Data ﬁle access with MATLAB . . . . . . . . . . . . . . . . . . . . .
42
2.6
Three-dimensional Graphics
. . . . . . . . . . . . . . . . . . . . . . . . . .
44
2.6.1
Plotting of three-dimensional curves . . . . . . . . . . . . . . . . . .
44
2.6.2
Plotting of three-dimensional surfaces
. . . . . . . . . . . . . . . . .
45
2.6.3
Viewpoint settings in 3D graphs
. . . . . . . . . . . . . . . . . . . .
48
2.6.4
Surface plots of parametric equations . . . . . . . . . . . . . . . . . .
49
2.6.5
Spheres and cylinders
. . . . . . . . . . . . . . . . . . . . . . . . . .
50
2.6.6
Drawing 2D and 3D contours . . . . . . . . . . . . . . . . . . . . . .
51
2.6.7
Drawing 3D implicit functions
. . . . . . . . . . . . . . . . . . . . .
52
2.7
Four-dimensional Visualization . . . . . . . . . . . . . . . . . . . . . . . . .
53
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
55
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3
Calculus Problems
61
3.1
Analytical Solutions to Limit Problems
. . . . . . . . . . . . . . . . . . . .
61
3.1.1
Limits of univariate functions . . . . . . . . . . . . . . . . . . . . . .
62
3.1.2
Limits of interval functions
. . . . . . . . . . . . . . . . . . . . . . .
64
3.1.3
Limits of multivariate functions . . . . . . . . . . . . . . . . . . . . .
66
3.2
Analytical Solutions to Derivative Problems
. . . . . . . . . . . . . . . . .
67
3.2.1
Derivatives and high-order derivatives . . . . . . . . . . . . . . . . .
67
3.2.2
Partial derivatives of multivariate functions . . . . . . . . . . . . . .
69
3.2.3
Jacobian matrix of multivariate functions . . . . . . . . . . . . . . .
71
3.2.4
Hessian partial derivative matrix . . . . . . . . . . . . . . . . . . . .
72
3.2.5
Partial derivatives of implicit functions . . . . . . . . . . . . . . . . .
72
3.2.6
Derivatives of parametric equations . . . . . . . . . . . . . . . . . . .
74
3.2.7
Gradients, divergences and curls of ﬁelds . . . . . . . . . . . . . . . .
74
3.3
Analytical Solutions to Integral Problems . . . . . . . . . . . . . . . . . . .
75
3.3.1
Indeﬁnite integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . .
76
3.3.2
Computing deﬁnite, inﬁnite and improper integrals . . . . . . . . . .
77
3.3.3
Computing multiple integrals . . . . . . . . . . . . . . . . . . . . . .
79
3.4
Series Expansions and Finite-term Series Approximations . . . . . . . . . .
80
3.4.1
Taylor series expansion
. . . . . . . . . . . . . . . . . . . . . . . . .
80
3.4.2
Fourier series expansion . . . . . . . . . . . . . . . . . . . . . . . . .
83
3.5
Inﬁnite Series and Products . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
3.5.1
Series
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
3.5.2
Product of sequences . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
3.5.3
Convergence test of inﬁnite series . . . . . . . . . . . . . . . . . . . .
89

Contents
vii
3.6
Path Integrals and Line Integrals . . . . . . . . . . . . . . . . . . . . . . . .
91
3.6.1
Path integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
3.6.2
Line integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
3.7
Surface Integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
94
3.7.1
Scalar surface integrals . . . . . . . . . . . . . . . . . . . . . . . . . .
94
3.7.2
Vector surface integrals
. . . . . . . . . . . . . . . . . . . . . . . . .
96
3.8
Numerical Diﬀerentiation
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
97
3.8.1
Numerical diﬀerentiation algorithms . . . . . . . . . . . . . . . . . .
97
3.8.2
Central-point diﬀerence algorithm with MATLAB implementation .
98
3.8.3
Gradient computations of functions with two variables . . . . . . . .
100
3.9
Numerical Integration Problems
. . . . . . . . . . . . . . . . . . . . . . . .
101
3.9.1
Numerical integration from given data using trapezoidal method . .
102
3.9.2
Numerical integration of univariate functions . . . . . . . . . . . . .
103
3.9.3
Numerical inﬁnite integrals . . . . . . . . . . . . . . . . . . . . . . .
106
3.9.4
Evaluating integral functions
. . . . . . . . . . . . . . . . . . . . . .
107
3.9.5
Numerical solutions to double integrals
. . . . . . . . . . . . . . . .
108
3.9.6
Numerical solutions to triple integrals . . . . . . . . . . . . . . . . .
111
3.9.7
Multiple integral evaluations
. . . . . . . . . . . . . . . . . . . . . .
112
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
113
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
119
4
Linear Algebra Problems
121
4.1
Inputting Special Matrices
. . . . . . . . . . . . . . . . . . . . . . . . . . .
122
4.1.1
Numerical matrix input . . . . . . . . . . . . . . . . . . . . . . . . .
122
4.1.2
Deﬁning symbolic matrices
. . . . . . . . . . . . . . . . . . . . . . .
126
4.1.3
Sparse matrix input
. . . . . . . . . . . . . . . . . . . . . . . . . . .
127
4.2
Fundamental Matrix Operations
. . . . . . . . . . . . . . . . . . . . . . . .
128
4.2.1
Basic concepts and properties of matrices . . . . . . . . . . . . . . .
128
4.2.2
Matrix inversion
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
4.2.3
Generalized matrix inverse
. . . . . . . . . . . . . . . . . . . . . . .
138
4.2.4
Matrix eigenvalue problems . . . . . . . . . . . . . . . . . . . . . . .
140
4.3
Fundamental Matrix Transformations
. . . . . . . . . . . . . . . . . . . . .
142
4.3.1
Similarity transformations and orthogonal matrices . . . . . . . . . .
142
4.3.2
Triangular and Cholesky factorizations . . . . . . . . . . . . . . . . .
144
4.3.3
Companion, diagonal and Jordan transformations
. . . . . . . . . .
149
4.3.4
Singular value decompositions . . . . . . . . . . . . . . . . . . . . . .
152
4.4
Solving Matrix Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . .
155
4.4.1
Solutions to linear algebraic equations . . . . . . . . . . . . . . . . .
155
4.4.2
Solutions to Lyapunov equations . . . . . . . . . . . . . . . . . . . .
158
4.4.3
Solutions to Sylvester equations . . . . . . . . . . . . . . . . . . . . .
161
4.4.4
Solutions of Diophantine equations . . . . . . . . . . . . . . . . . . .
163
4.4.5
Solutions to Riccati equations . . . . . . . . . . . . . . . . . . . . . .
165
4.5
Nonlinear Functions and Matrix Function Evaluations . . . . . . . . . . . .
166
4.5.1
Element-by-element computations
. . . . . . . . . . . . . . . . . . .
166
4.5.2
Computations of matrix exponentials . . . . . . . . . . . . . . . . . .
166
4.5.3
Trigonometric functions of matrices
. . . . . . . . . . . . . . . . . .
168
4.5.4
General matrix functions
. . . . . . . . . . . . . . . . . . . . . . . .
171
4.5.5
Power of a matrix
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
173

viii
Contents
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
175
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
180
5
Integral Transforms and Complex-valued Functions
183
5.1
Laplace Transforms and Their Inverses
. . . . . . . . . . . . . . . . . . . .
184
5.1.1
Deﬁnitions and properties . . . . . . . . . . . . . . . . . . . . . . . .
184
5.1.2
Computer solution to Laplace transform problems
. . . . . . . . . .
185
5.1.3
Numerical solutions of Laplace transforms . . . . . . . . . . . . . . .
187
5.2
Fourier Transforms and Their Inverses . . . . . . . . . . . . . . . . . . . . .
190
5.2.1
Deﬁnitions and properties . . . . . . . . . . . . . . . . . . . . . . . .
190
5.2.2
Solving Fourier transform problems . . . . . . . . . . . . . . . . . . .
191
5.2.3
Fourier sinusoidal and cosine transforms . . . . . . . . . . . . . . . .
193
5.2.4
Discrete Fourier sine, cosine transforms
. . . . . . . . . . . . . . . .
194
5.2.5
Fast Fourier transforms
. . . . . . . . . . . . . . . . . . . . . . . . .
195
5.3
Other Integral Transforms
. . . . . . . . . . . . . . . . . . . . . . . . . . .
197
5.3.1
Mellin transform . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
197
5.3.2
Hankel transform solutions
. . . . . . . . . . . . . . . . . . . . . . .
198
5.4
z Transforms and Their Inverses
. . . . . . . . . . . . . . . . . . . . . . . .
200
5.4.1
Deﬁnitions and properties of z transforms and inverses . . . . . . . .
200
5.4.2
Computations of z transform . . . . . . . . . . . . . . . . . . . . . .
201
5.4.3
Bilateral z transforms . . . . . . . . . . . . . . . . . . . . . . . . . .
202
5.4.4
Numerical inverse z transform of rational functions . . . . . . . . . .
203
5.5
Essentials of Complex-valued Functions
. . . . . . . . . . . . . . . . . . . .
203
5.5.1
Complex matrices and their manipulations
. . . . . . . . . . . . . .
204
5.5.2
Mapping of complex-valued functions
. . . . . . . . . . . . . . . . .
204
5.5.3
Riemann surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
206
5.6
Solving Complex-valued Function Problems . . . . . . . . . . . . . . . . . .
207
5.6.1
Concept and computation of poles and residues . . . . . . . . . . . .
207
5.6.2
Partial fraction expansion for rational functions . . . . . . . . . . . .
210
5.6.3
Inverse Laplace transform using PFEs . . . . . . . . . . . . . . . . .
214
5.6.4
Laurent series expansions . . . . . . . . . . . . . . . . . . . . . . . .
215
5.6.5
Computing closed-path integrals
. . . . . . . . . . . . . . . . . . . .
219
5.7
Solutions of Diﬀerence Equations
. . . . . . . . . . . . . . . . . . . . . . .
221
5.7.1
Analytical solutions of linear diﬀerence equations . . . . . . . . . . .
221
5.7.2
Numerical solutions of linear time varying diﬀerence equations
. . .
222
5.7.3
Solutions of linear time-invariant diﬀerence equations
. . . . . . . .
224
5.7.4
Numerical solutions of nonlinear diﬀerence equations . . . . . . . . .
225
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
226
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
6
Nonlinear Equations and Numerical Optimization Problems
231
6.1
Nonlinear Algebraic Equations
. . . . . . . . . . . . . . . . . . . . . . . . .
232
6.1.1
Graphical method for solving nonlinear equations . . . . . . . . . . .
232
6.1.2
Quasi-analytic solutions to polynomial-type equations . . . . . . . .
234
6.1.3
Numerical solutions to general nonlinear equations . . . . . . . . . .
238
6.2
Nonlinear Equations with Multiple Solutions
. . . . . . . . . . . . . . . . .
240
6.2.1
Numerical solutions
. . . . . . . . . . . . . . . . . . . . . . . . . . .
241
6.2.2
Finding high-precision solutions . . . . . . . . . . . . . . . . . . . . .
245

Contents
ix
6.2.3
Solutions of underdetermined equations . . . . . . . . . . . . . . . .
247
6.3
Unconstrained Optimization Problems . . . . . . . . . . . . . . . . . . . . .
248
6.3.1
Analytical solutions and graphical solution methods
. . . . . . . . .
249
6.3.2
Solution of unconstrained optimization using MATLAB . . . . . . .
250
6.3.3
Global minimum and local minima . . . . . . . . . . . . . . . . . . .
252
6.3.4
Solving optimization problems with gradient information
. . . . . .
255
6.4
Constrained Optimization Problems
. . . . . . . . . . . . . . . . . . . . . .
257
6.4.1
Constraints and feasibility regions
. . . . . . . . . . . . . . . . . . .
257
6.4.2
Solving linear programming problems
. . . . . . . . . . . . . . . . .
258
6.4.3
Solving quadratic programming problems . . . . . . . . . . . . . . .
263
6.4.4
Solving general nonlinear programming problems . . . . . . . . . . .
264
6.5
Mixed Integer Programming Problems . . . . . . . . . . . . . . . . . . . . .
268
6.5.1
Enumerate method in integer programming problems
. . . . . . . .
268
6.5.2
Solutions of linear integer programming problems . . . . . . . . . . .
270
6.5.3
Solutions of nonlinear integer programming problems . . . . . . . . .
271
6.5.4
Solving binary programming problems . . . . . . . . . . . . . . . . .
273
6.5.5
Assignment problems
. . . . . . . . . . . . . . . . . . . . . . . . . .
275
6.6
Linear Matrix Inequalities
. . . . . . . . . . . . . . . . . . . . . . . . . . .
276
6.6.1
A general introduction to LMIs . . . . . . . . . . . . . . . . . . . . .
276
6.6.2
Lyapunov inequalities
. . . . . . . . . . . . . . . . . . . . . . . . . .
277
6.6.3
Classiﬁcation of LMI problems . . . . . . . . . . . . . . . . . . . . .
279
6.6.4
LMI problem solutions with MATLAB . . . . . . . . . . . . . . . . .
279
6.6.5
Optimization of LMI problems by YALMIP Toolbox . . . . . . . . .
281
6.7
Solutions of Multi-objective Programming Problems
. . . . . . . . . . . . .
283
6.7.1
Multi-objective optimization model . . . . . . . . . . . . . . . . . . .
283
6.7.2
Least squares solutions of unconstrained multi-objective program-
ming problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
283
6.7.3
Converting multi-objective problems into single-objective ones
. . .
284
6.7.4
Pareto front of multi-objective programming problems . . . . . . . .
287
6.7.5
Solutions of minimax problems . . . . . . . . . . . . . . . . . . . . .
289
6.7.6
Solutions of multi-objective goal attainment problems . . . . . . . .
290
6.8
Dynamic Programming and Shortest Path Planning
. . . . . . . . . . . . .
291
6.8.1
Matrix representation of graphs . . . . . . . . . . . . . . . . . . . . .
292
6.8.2
Optimal path planning of oriented graphs . . . . . . . . . . . . . . .
292
6.8.3
Optimal path planning of undigraphs
. . . . . . . . . . . . . . . . .
296
6.8.4
Optimal path planning for graphs described by coordinates . . . . .
296
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
297
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
303
7
Diﬀerential Equation Problems
305
7.1
Analytical Solution Methods for Some Ordinary Diﬀerential Equations
. .
306
7.1.1
Linear time-invariant ordinary diﬀerential equations . . . . . . . . .
306
7.1.2
Analytical solution with MATLAB . . . . . . . . . . . . . . . . . . .
307
7.1.3
Analytical solutions of linear state space equations . . . . . . . . . .
310
7.1.4
Analytical solutions to special nonlinear diﬀerential equations . . . .
311
7.2
Numerical Solutions to Ordinary Diﬀerential Equations
. . . . . . . . . . .
312
7.2.1
Overview of numerical solution algorithms . . . . . . . . . . . . . . .
312
7.2.2
Fixed-step Runge–Kutta algorithm and its MATLAB implementation 314

x
Contents
7.2.3
Numerical solution to ﬁrst-order vector ODEs . . . . . . . . . . . . .
315
7.3
Transforms to Standard Diﬀerential Equations
. . . . . . . . . . . . . . . .
320
7.3.1
Manipulating a single high-order ODE . . . . . . . . . . . . . . . . .
320
7.3.2
Manipulating multiple high-order ODEs . . . . . . . . . . . . . . . .
321
7.3.3
Validation of numerical solutions to ODEs . . . . . . . . . . . . . . .
325
7.3.4
Transformation of diﬀerential matrix equations . . . . . . . . . . . .
326
7.4
Solutions to Special Ordinary Diﬀerential Equations . . . . . . . . . . . . .
328
7.4.1
Solutions of stiﬀordinary diﬀerential equations . . . . . . . . . . . .
329
7.4.2
Solutions of implicit diﬀerential equations . . . . . . . . . . . . . . .
332
7.4.3
Solutions to diﬀerential algebraic equations . . . . . . . . . . . . . .
335
7.4.4
Solutions of switching diﬀerential equations . . . . . . . . . . . . . .
337
7.4.5
Solutions to linear stochastic diﬀerential equations . . . . . . . . . .
338
7.5
Solutions to Delay Diﬀerential Equations
. . . . . . . . . . . . . . . . . . .
342
7.5.1
Solutions of typical delay diﬀerential equations . . . . . . . . . . . .
342
7.5.2
Solutions of diﬀerential equations with variable delays . . . . . . . .
344
7.5.3
Solutions of neutral-type delay diﬀerential equations . . . . . . . . .
347
7.6
Solving Boundary Value Problems
. . . . . . . . . . . . . . . . . . . . . . .
348
7.6.1
Shooting algorithm for linear equations
. . . . . . . . . . . . . . . .
348
7.6.2
Boundary value problems of nonlinear equations
. . . . . . . . . . .
350
7.6.3
Solutions to general boundary value problems . . . . . . . . . . . . .
352
7.7
Introduction to Partial Diﬀerential Equations . . . . . . . . . . . . . . . . .
355
7.7.1
Solving a set of one-dimensional partial diﬀerential equations . . . .
355
7.7.2
Mathematical description to two-dimensional PDEs
. . . . . . . . .
357
7.7.3
The GUI for the PDE Toolbox — an introduction
. . . . . . . . . .
358
7.8
Solving ODEs with Block Diagrams in Simulink
. . . . . . . . . . . . . . .
365
7.8.1
A brief introduction to Simulink
. . . . . . . . . . . . . . . . . . . .
365
7.8.2
Simulink — relevant blocks . . . . . . . . . . . . . . . . . . . . . . .
365
7.8.3
Using Simulink for modeling and simulation of ODEs
. . . . . . . .
367
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
373
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
379
8
Data Interpolation and Functional Approximation Problems
381
8.1
Interpolation and Data Fitting
. . . . . . . . . . . . . . . . . . . . . . . . .
382
8.1.1
One-dimensional data interpolation . . . . . . . . . . . . . . . . . . .
382
8.1.2
Deﬁnite integral evaluation from given samples . . . . . . . . . . . .
385
8.1.3
Two-dimensional grid data interpolation . . . . . . . . . . . . . . . .
387
8.1.4
Two-dimensional scattered data interpolation . . . . . . . . . . . . .
389
8.1.5
Optimization problems based on scattered sample data
. . . . . . .
392
8.1.6
High-dimensional data interpolations . . . . . . . . . . . . . . . . . .
393
8.2
Spline Interpolation and Numerical Calculus
. . . . . . . . . . . . . . . . .
394
8.2.1
Spline interpolation in MATLAB . . . . . . . . . . . . . . . . . . . .
395
8.2.2
Numerical diﬀerentiation and integration with splines
. . . . . . . .
398
8.3
Fitting Mathematical Models from Data
. . . . . . . . . . . . . . . . . . .
401
8.3.1
Polynomial ﬁtting
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
401
8.3.2
Curve ﬁtting by linear combination of basis functions
. . . . . . . .
403
8.3.3
Least squares curve ﬁtting . . . . . . . . . . . . . . . . . . . . . . . .
405
8.3.4
Least squares ﬁtting of multivariate functions . . . . . . . . . . . . .
407
8.4
Rational Function Approximations . . . . . . . . . . . . . . . . . . . . . . .
408

Contents
xi
8.4.1
Approximation by continued fraction expansions . . . . . . . . . . .
408
8.4.2
Pad´e rational approximations . . . . . . . . . . . . . . . . . . . . . .
412
8.4.3
Special approximation polynomials . . . . . . . . . . . . . . . . . . .
414
8.5
Special Functions and Their Plots
. . . . . . . . . . . . . . . . . . . . . . .
416
8.5.1
Gamma functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
416
8.5.2
Beta functions
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
418
8.5.3
Legendre functions . . . . . . . . . . . . . . . . . . . . . . . . . . . .
419
8.5.4
Bessel functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
420
8.5.5
Mittag–Leﬄer functions . . . . . . . . . . . . . . . . . . . . . . . . .
421
8.6
Signal Analysis and Digital Signal Processing . . . . . . . . . . . . . . . . .
425
8.6.1
Correlation analysis
. . . . . . . . . . . . . . . . . . . . . . . . . . .
425
8.6.2
Power spectral analysis
. . . . . . . . . . . . . . . . . . . . . . . . .
427
8.6.3
Filtering techniques and ﬁlter design . . . . . . . . . . . . . . . . . .
429
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
433
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
436
9
Probability and Mathematical Statistics Problems
437
9.1
Probability Distributions and Pseudorandom Numbers
. . . . . . . . . . .
438
9.1.1
Introduction to probability density functions and cumulative distribu-
tion functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
438
9.1.2
Probability density functions and cumulative distribution functions
of commonly used distributions . . . . . . . . . . . . . . . . . . . . .
439
9.1.3
Random numbers and pseudorandom numbers
. . . . . . . . . . . .
447
9.2
Solving Probability Problems . . . . . . . . . . . . . . . . . . . . . . . . . .
448
9.2.1
Histogram and pie representation of discrete numbers
. . . . . . . .
448
9.2.2
Probability computation of continuous functions
. . . . . . . . . . .
450
9.2.3
Monte Carlo solutions to mathematical problems . . . . . . . . . . .
451
9.2.4
Simulation of random walk processes . . . . . . . . . . . . . . . . . .
453
9.3
Fundamental Statistical Analysis . . . . . . . . . . . . . . . . . . . . . . . .
454
9.3.1
Mean and variance of stochastic variables . . . . . . . . . . . . . . .
454
9.3.2
Moments of stochastic variables . . . . . . . . . . . . . . . . . . . . .
456
9.3.3
Covariance analysis of multivariate stochastic variables . . . . . . . .
457
9.3.4
Joint PDFs and CDFs of multivariate normal distributions
. . . . .
458
9.3.5
Outliers, quartiles and box plots
. . . . . . . . . . . . . . . . . . . .
459
9.4
Statistical Estimations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
462
9.4.1
Parametric estimation and interval estimation . . . . . . . . . . . . .
462
9.4.2
Multivariate linear regression and interval estimation . . . . . . . . .
463
9.4.3
Nonlinear least squares parametric and interval estimations . . . . .
466
9.4.4
Maximum likelihood estimations . . . . . . . . . . . . . . . . . . . .
468
9.5
Statistical Hypothesis Tests . . . . . . . . . . . . . . . . . . . . . . . . . . .
469
9.5.1
Concept and procedures for statistic hypothesis test . . . . . . . . .
469
9.5.2
Hypothesis tests for distributions . . . . . . . . . . . . . . . . . . . .
471
9.6
Analysis of Variance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
474
9.6.1
One-way ANOVA
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
474
9.6.2
Two-way ANOVA
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
476
9.6.3
n-way ANOVA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
478
9.7
Principal Component Analysis
. . . . . . . . . . . . . . . . . . . . . . . . .
478
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
480

xii
Contents
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
483
10 Topics on Nontraditional Mathematical Branches
485
10.1 Fuzzy Logic and Fuzzy Inference . . . . . . . . . . . . . . . . . . . . . . . .
485
10.1.1 MATLAB solutions to classical set problems
. . . . . . . . . . . . .
485
10.1.2 Fuzzy sets and membership functions
. . . . . . . . . . . . . . . . .
488
10.1.3 Fuzzy rules and fuzzy inference . . . . . . . . . . . . . . . . . . . . .
494
10.2 Rough Set Theory and Its Applications
. . . . . . . . . . . . . . . . . . . .
496
10.2.1 Introduction to rough set theory . . . . . . . . . . . . . . . . . . . .
496
10.2.2 Data processing problem solutions using rough sets . . . . . . . . . .
499
10.3 Neural Network and Applications in Data Fitting Problems . . . . . . . . .
502
10.3.1 Fundamentals of neural networks . . . . . . . . . . . . . . . . . . . .
503
10.3.2 Feedforward neural network . . . . . . . . . . . . . . . . . . . . . . .
504
10.3.3 Radial basis neural networks and applications . . . . . . . . . . . . .
511
10.3.4 Graphical user interface for neural networks . . . . . . . . . . . . . .
514
10.4 Evolutionary Computing and Global Optimization Problem Solutions
. . .
516
10.4.1 Basic idea of genetic algorithms . . . . . . . . . . . . . . . . . . . . .
517
10.4.2 Solutions to optimization problems with genetic algorithms . . . . .
518
10.4.3 Solving constrained problems . . . . . . . . . . . . . . . . . . . . . .
522
10.4.4 Solving optimization problems with Global Optimization Toolbox
.
522
10.4.5 Towards accurate global minimum solutions . . . . . . . . . . . . . .
528
10.5 Wavelet Transform and Its Applications in Data Processing . . . . . . . . .
529
10.5.1 Wavelet transform and waveforms of wavelet bases . . . . . . . . . .
530
10.5.2 Wavelet transform in signal processing problems
. . . . . . . . . . .
534
10.5.3 Graphical user interface in wavelets
. . . . . . . . . . . . . . . . . .
538
10.6 Fractional-order Calculus
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
538
10.6.1 Deﬁnitions of fractional-order calculus . . . . . . . . . . . . . . . . .
539
10.6.2 Properties and relationship of various fractional-order diﬀerentiation
deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
540
10.6.3 Evaluating fractional-order diﬀerentiation . . . . . . . . . . . . . . .
541
10.6.4 Solving fractional-order diﬀerential equations . . . . . . . . . . . . .
547
10.6.5 Block diagram based solutions of nonlinear fractional-order ordinary
diﬀerential equations . . . . . . . . . . . . . . . . . . . . . . . . . . .
553
10.6.6 Object-oriented modeling and analysis of linear fractional-order
systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
557
Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
564
Bibliography
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
567

Preface
Since the ﬁrst edition of this book published in 2008, computing landscape changed radically,
from cloud computing to big data science, from wearable computing to internet of things,
from deep learning to driverless cars... yet in more general sense, computing happens in all
walks of life, from falling rocks to withering leaves, from climate change to extreme weather,
from gene editing to digital matter... But one thing not changed is the scientiﬁc computing
fundamentals that cover all college mathematics. Busy students, engineers and scientists
need “fast-food” ways to compute and get problems solved reliably.
Oliver Heaviside once said “Mathematics is of two kinds, Rigorous and Physical. The
former is Narrow: the latter Bold and Broad. To have to stop to formulate rigorous
demonstrations would put a stop to most physico-mathematical inquiries. Am I to refuse
to eat because I do not fully understand the mechanism of digestion?”1 Today, we can
ask a similar question: Am I to refuse to compute because I do not fully understand the
mechanism of numerics? As we discussed in the Preface of the ﬁrst edition, we need a new
way of learning scientiﬁc computing so that we can focus more on “computational thinking.”
With these goals in mind, this edition includes the following new features:
(1) A signiﬁcant amount of new material is introduced, speciﬁcally: four-dimensional
volume visualization, interval limit, inﬁnite series convergence, numerical multiple integral,
arbitrary matrix analysis, matrix power, diﬀerence equations, numerical integral trans-
forms, Laurent series, matrix equation solutions, multi-objective optimizations, dynamic
programming and shortest path problems, matrix diﬀerential equations, switching ODEs,
delay ODEs, special functions, principal component analysis, Monte Carlo algorithm, outlier
detection, radial basis network, particle swarm optimization, and a completely new section
on fractional calculus.
(2) The three-phase solution procedure proposed by the authors has been followed
throughout the book. Namely, to solve a problem, the physical explanation of the
mathematical problem to be solved is given ﬁrst, followed by the methodology of how
to formulate the problem in MATLAB®-compatible framework, and ﬁnally, the third phase
is to call MATLAB functions to solve the problem. The guideline is useful in real world
problem solving with lots of illustrative examples.
(3) Mathematical branches are arranged more systematically. Using the traditional styles
in mathematical presentation (as in typical mathematics courses), however, concentrations
are made on how the problems are solved. If there are existing MATLAB functions, or third-
party products, suggestions are made to use them directly. If there are not, or if existing
ones are problematic, new MATLAB functions are written and easy-to-use calling syntaxes
are designed and explained.
(4) Soon after the publication of the ﬁrst edition, MATLAB R2008b was released,
from which the symbolic engine is replaced, and some of the commands, especially those
1Edge A. Oliver Heaviside (1850–1927) - Physical mathematician. Teaching Mathematics and Its
Applications 2: 55-61, 1983.
xiii

xiv
Preface
involving overload functions and Maple internal functions, cannot be used for the symbolic
computation problems. In the new edition, compatibility with the new versions of MATLAB
are supported.
(5) Enhanced examples and exercises are included to support the materials throughout
the new edition. A complete set of teaching materials, composed of about 1500 PPT slides
and a solutions manual, is provided with the book. The relevant materials can be downloaded
from the authors-maintained web-site at
https://mechatronics.ucmerced.edu/Scientific-Computing-with-MATLAB-2ndEd
Financial support from the National Natural Science Foundation of China under Grant
61174145 is acknowledged. Thanks also go to Drs. Yanliang Zhang and Lynn Crisanti
for arranging the ﬁrst author’s visit to MathWorks, Natick, MA for discussing a possible
MOOC project for the book. A MOOC in Chinese is just made ready and will be released
soon, thanks to the support from Liaoning Provincial Education Bureau and Northeastern
University, China. Classroom videos in English are scheduled. New information and links
on the MOOC progress will be anounced in the above web-site.
MATLAB and Simulink® are registered trademarks of The MathWorks, Inc. For product
information, please contact:
The MathWorks, Inc.
3 Apple Hill Drive
Natick, MA, 01760-2098, USA
Tel: 508-647-7000
Fax: 508-647-7101
E-mail: info@mathworks.com
Web: http://www.mathworks.com
This new edition was suggested and supported by Sunil Nair, Publisher, CRC Press,
Taylor and Francis Group. We are thankful for Sunil’s patience and constructive comments.
We wish to specially thank Michael Davidson, Project Editor, Taylor and Francis Group,
LLC for helping us with an excellent copy-editing service. We would like to extend our
appreciation to Professor Jian-Qiao Sun of University of California, Merced for adopting the
ﬁrst edition of the book for his ME021 “Engineering Computing” course and for motivating
a new edition with a bigger format size. The new materials of the book have been used in
a course entitled “MATLAB and Scientiﬁc Computing” for two semesters in Northeastern
University, China. All the students of Lang Shijun Automation Experimental Classes 1309
and 1410, especially Mr. Weiming Mi and Mr. Huaijia Lin, are acknowledged for some new
insights and the hard work of modiﬁcations of the PPT slides and solutions manual.
Last but not least, Dingy¨u Xue would like to thank his wife Jun Yang and his daughter
Yang Xue; YangQuan Chen would like to thank his wife Huifang Dou and his sons Duyun,
David and Daniel, for their patience, understanding and complete support throughout this
book project.
Dingy¨u Xue, Shenyang, Liaoning, China
YangQuan Chen, Merced, California, USA

Preface of the First Edition
Computational Thinking2, coined and promoted by Jeannette Wing of Carnegie Mellon
University, is getting more and more attention. “It represents a universally applicable
attitude and skill set everyone, not just computer scientists, would be eager to learn and use”
as acknowledged by Dr. Wing, “Computational Thinking draws on math as its foundations.”
The present book responds to “Computational Thinking” by oﬀering the readers enhanced
math problem solving ability and therefore, the readers can focus more on “Computational
Thinking” instead of “Computational Doing.”
The breadth and depth of one’s mathematical knowledge might not match his or her
ability to solve mathematical problems. In today’s applied science and applied engineering,
one usually needs to get the mathematical problems at hand solved eﬃciently in a timely
manner without complete understanding of the numerical techniques involved in the solution
process. Therefore, today, arguably, it is a trend to focus more on how to formulate the
problem in a form suitable for computer solution and on the interpretation of the results
generated from the computer. We further argue that, even without a complete preparation of
mathematics, it is possible to solve some advanced mathematical problems using a computer.
We hope this book is useful for those who frequently feel that their level of math preparation
is not high enough because they still can get their math problems at hand solved with the
encouragement gained from reading this book.
Using
computers
to
solve
mathematical
problems
today
is
ubiquitous.
MATLAB®/Simulink is considered as the dominant software platform for applied math
related topics. Sometimes, one simply does not know one’s problem could be solved in a
much simpler way in MATLAB or Simulink. From what Confucius wrote, “The craftsman
who wishes to work well has ﬁrst to sharpen his implements,”3 it is clear that MATLAB
is the right, already sharpened “implement.” However, a bothering practical problem is
this: MATLAB documentation only shows “this function performs this,” and what a user
with a mathematical problem at hand wants is, “Given this math problem, through what
reformulation, and then, use of what functions will get the problem solved.” Frequently, it
is very easy for one to get lost in thousands of functions oﬀered in MATLAB plus the same
amount, if not more, of functions contributed by the MATLAB users community. Therefore,
the major contribution of this book is to bridge the gap between “problems” and “solutions”
through well grouped topics and tightly yet smoothly glued MATLAB example scripts and
reproducible MATLAB-generated plots.
A distinguishing feature of the book is the organization and presentation of the material.
Based on our teaching, research and industrial experience, we have chosen to present the
course materials following the sequence
• Computer Mathematics Languages — An Overview
• Fundamentals of MATLAB Programming
• Calculus Problems
2http://www.cs.cmu.edu/afs/cs/usr/wing/www/Computational Thinking.pdf
3Confucius. http://www.confucius.org/lunyu/ed1509.htm.
xv

xvi
Preface of the First Edition
• Linear Algebra Problems
• Integral Transforms and Complex Variable Functions
• Nonlinear Equations and Optimization Problems
• Diﬀerential Equations Problems
• Data Interpolation and Functional Approximation Problems
• Probability and Statistics Problems
• Nontraditional Methods
In particular, in the nontraditional mathematical problem solution methods, we choose
to cover some interesting and practically important topics such as set theory and fuzzy
inference system, neural networks, wavelet transform, evolutionary optimization methods
including genetic algorithms and particle swarm optimization methods, rough set based
data analysis problems, fractional-order calculus (derivative or integral of non-integer order)
problems, etc., all with extensive problem solution examples. A dedicated CAI (computer
aided instruction) kit including more than 1,300 interactive PowerPoint slides has been
developed for this book for both instruction and self-learning purposes.
We hope that readers will enjoy playing with the scripts and changing them as they
wish for a better understanding and deeper exploration with reduced eﬀorts. Additionally,
each chapter comes with a set of problems to strengthen the understanding of the chapter
contents. It appears that the book is presenting in certain depth some mathematical
problems. However, the ultimate objective of this book is to help the readers, after
understanding roughly the mathematical background, to avoid the tedious and complex
technical details of mathematics and ﬁnd the reliable and accurate solutions to the interested
mathematical problems with the use of MATLAB computer mathematics language. There
is no doubt that the readers’ ability to tackle mathematical problems can be signiﬁcantly
enhanced after reading this book.
This book can be used as a reference text for almost all college students, both
undergraduates and graduates, in almost all disciplines which require certain levels of
applied mathematics. The coverage of topics is practically broad yet with a balanced depth.
The authors also believe that this book will be a good desktop reference for many who have
graduated from college and are still involved in solving mathematical problems in their jobs.
Apart from the standard MATLAB, some of the commercial toolboxes may be
needed. For instance, the Symbolic Math Toolbox is used throughout the book to
provide alternative analytical solutions to certain problems. Optimization Toolbox, Partial
Diﬀerential Equation Toolbox, Spline Toolbox, Statistics Toolbox, Fuzzy Logic Toolbox,
Neural Network Toolbox, Wavelet Toolbox, and Genetic Algorithm and Direct Search
Toolbox may be required in corresponding chapters or sections. A lot of MATLAB functions
designed by the authors, plus some third-party free toolboxes, are also presented in the book.
For more information on MATLAB and related products, please contact
The MathWorks, Inc.
3 Apple Hill Drive
Natick, MA, 01760-2098, USA
Tel: 508-647-7000
Fax: 508-647-7101
E-mail: info@mathworks.com
Web: http://www.mathworks.com
The writing of this book started more than 5 years ago, when a Chinese version4 was
4Xue Dingy¨u and Chen YangQuan, Advanced applied mathematical problem solutions using MATLAB,
Beijing: Tsinghua University Press, 2004

Preface of the First Edition
xvii
published in 2004. Many researchers, professors and students have provided useful feedback
comments and input for the newly extended English version. In particular, we thank the
following professors: Xinhe Xu, Fuli Wang of Northeastern University; Hengjun Zhu of
Beijing Jiaotong University; Igor Podlubny of Technical University of Kosice, Slovakia;
Shuzhi Sam Ge of National University of Singapore, Wen Chen of Hohai University, China.
The writing of some parts of this book has been helped by Drs. Feng Pan, Daoxiang Gao,
Chunna Zhao and Dali Chen, and some of the materials are motivated by the talks with
colleagues at Northeastern University, especially Drs. Xuefeng Zhang and Haibin Shi. The
computer aided instruction kit and solution manual were developed by our graduate students
Wenbin Dong, Jun Peng, Yingying Liu, Dazhi E, Lingmin Zhang and Ying Luo.
Moreover, we are grateful to the Editors, LiMing Leong and Marsha Hecht, CRC
Press, Taylor & Francis Group, for their creative suggestions and professional help. The
“Book Program” from The MathWorks Inc., in particular, Hong Yang, MathWorks, Beijing,
Courtney Esposito, Meg Vuliez and Dee Savageau, are acknowledged for the latest MATLAB
software and technical problem support.
The authors are grateful to the following free toolbox authors, to allow the inclusion of
their contributions in the companion CD:
Dr. Brian K Birge, for particle swarm optimization toolbox (PSOt)
John D’Errico, for fminsearchbnd Toolbox
Mr. Koert Kuipers for his BNB Toolbox
Dr. Johan L¨ofberg, University of Link¨oping, Sweden for YALMIP
Mr. Xuefeng Zhang, Northeastern University, China for RSDA Toolbox
Last but not least, Dingy¨u Xue would like to thank his wife Jun Yang and his daughter
Yang Xue; YangQuan Chen would like to thank his wife Huifang Dou and his sons Duyun,
David and Daniel, for their patience, understanding and complete support throughout this
work.
Dingy¨u Xue
Northeastern University
Shenyang, China
xuedingyu@mail.neu.edu.cn
YangQuan Chen
Utah State University
Logan, Utah, USA
yqchen@ieee.org


Chapter 1
Computer Mathematics Languages — An
Overview
Mathematical problems are essential in almost all aspects of scientiﬁc and engineering
research. The mathematical models should normally be established ﬁrst, then, the solutions
of the models under investigation can be obtained. Speciﬁc knowledge is required for the
establishment of mathematical models, which needs the expertise of the researchers, and
with the established models, the numerical and analytical approaches presented in this
book can be used to solve the problems. In this chapter, a brief introduction to computer
mathematical problems is given, and it will be illustrated through simple examples why
computer mathematical languages should be learned. A concise history of the development
of computer mathematical languages and mathematical tools will be introduced. Finally
the framework of the book is presented. Also, an overview of the mathematics branches
involved is given in this chapter.
1.1
Computer Solutions to Mathematics Problems
1.1.1
Why should we study computer mathematics language?
We all know that manual derivation of solutions to mathematical problems is a useful
skill when the problems are not so complicated. However, for a great variety of mathematical
problems, manual solutions are laborious or even not possible. Therefore, computers must be
employed for solving these problems. There are basically two ways of solving these problems
by computers. One is to verbally implement the existing numerical algorithms using general
purpose computer languages such as Fortran or C. The other way is to use speciﬁc computer
languages with a good reputation. These languages include MATLAB, Mathematica and
Maple. In this book, they are referred to as the computer mathematics languages. The
numerical algorithms can only be used to handle computation problems by numbers, while
for problems like to ﬁnd the solutions to the symbolic equation x3+ax+c=d, where a, c, d
are not given numerical values but symbolic variables, the numerical algorithms cannot be
used. The computer mathematics languages with symbolic computation capabilities should
be used instead.
We shall use the term “mathematical computation” throughout the book, whereas the
term really means both numerical and analytical computation of mathematical problems.
Normally, analytical solutions are explored ﬁrst, and if there are no analytical solutions,
numerical solutions are obtained.
Before systematically introducing the contents of the book, the following examples are
given such that the readers may understand and appreciate the necessity of using the
computer mathematics languages.
1

2
Scientiﬁc Computing with MATLAB®
Example 1.1
In calculus courses, the concepts and derivation methods are introduced
with an emphasis on manual deduction and computation. If a function f(x) is given by
f(x) =
sin x
x2 + 4x + 3, how could one derive d4f(x)
dx4
manually?
Solution
One can derive it using the methods taught in calculus courses. For instance,
the ﬁrst-order derivative df(x)/ dx can be derived ﬁrst, the second-order derivative, third-
order derivative and ﬁnally fourth-order derivative of the function f(x) can be evaluated in
turn. In this way, even higher-order derivatives of the function can be derived manually,
in theory. However, the procedure is more suitable to be carried out with computers. With
suitable computer mathematics languages, the fourth-order derivative of the function f(x)
can be calculated using a single statement
>> syms x; f=sin(x)/(x^2+4*x+3); y=diff(f,x,4)
and the result obtained is
y =
sin x
x2 + 4x + 3 +4 (2x + 4) cos x
(x2 + 4x + 3)2 −12 (2x + 4)2 sin x
(x2 + 4x + 3)3 +
12 sin x
(x2 + 4x + 3)2 +
24 sinx
(x2 + 4x + 3)3
+ 48 (2x + 4) cos x
(x2 + 4x + 3)3 + 24 (2x + 4)4 sin x
(x2 + 4x + 3)5 −72 (2x + 4)2 sin x
(x2 + 4x + 3)4 −24(2x + 4)3 cos x
(x2 + 4x + 3)4 .
It is obvious that manual derivation could be a tedious and laborious work, and it could be
quite complicated. Wrong results may be obtained even with a slightly careless manipulation
of formulae. Therefore, even though the results can be obtained manually, after hours of
hard work, the results may be suspicious and untrustworthy. If the computer mathematics
languages are used, the tedious and unreliable work can be avoided. For example, by using
MATLAB language, the accurate d100f(x)/ dx100 can be obtained within a second!
Example 1.2
In many ﬁelds, the roots of polynomial equations are often needed. The
well-known Abel–Ruﬃni Theorem states that there is no general solution in radicals to
polynomial equations of degree ﬁve or higher. The problems can be solved numerically
using the Lin–Bairstow algorithm. Solve a polynomial equation
s6 + 9s5 + 135
4 s4 + 135
2 s3 + 1215
16 s2 + 729
16 s + 729
64 = 0.
Solution Applying the Lin–Bairstrow method, under double-precision scheme, the roots of
the equation obtained are
s1,2 = −1.5056 ± j0.0032,
s3,4 = −1.5000 ± j0.0065,
s5,6 = −1.4944 ± j0.0032.
Substituting s1 back to the original equation, the error can be found to be −8.7041 ×
10−14 −j1.8353 × 10−15. In fact, all the roots to the above equation are exactly −1.5, if the
symbolic facilities of the computer mathematics languages are used. Below are the statements
used in the example
>> p=[1 9 135/4 135/2 1215/16 729/16 729/64]; roots(p) %
numeric
p1=poly2sym(p); solve(p1) %
analytic solution of polynomial equations
Example 1.3
Do you remember how to ﬁnd the determinant of an n × n matrix?
Solution In linear algebra courses, the determinant of a matrix is suggested to be evaluated
by algebraic complements. For instance, for an n×n matrix, its determinant can be evaluated
from determinants of n matrices of size (n −1) × (n −1). Similarly, the determinant of

Computer Mathematics Languages — An Overview
3
each (n −1) × (n −1) matrix can be obtained from determinants of n −1 matrices of size
(n −2) × (n −2). In other words, the determinant of an n × n matrix can eventually be
obtained from the algebraic sum of many determinants of 1 × 1 matrices, i.e., the scalar
itself. Therefore, it can be concluded that the analytical solution to the determinant of any
given matrix exists.
In fact, the above mathematical conclusion neglected the computability and feasibility
issue. The computation load for such an evaluation task could be extremely tremendous,
which requires (n −1)(n + 1)! + n operations. For instance, when n = 25, the number
of ﬂoating-point operations (ﬂops) for the computation is 9.679 × 1027, which amounts
to 5580 years of computation on mainframe of 55 million billion (5.5 × 1016) ﬂops per
second (the fastest mainframe in the world in 2014). Therefore, the algebraic complement
method, although elegant and instructive, is not practically feasible. In real applications, the
determinants of even larger sized matrices are usually needed (n ≫25), which is clearly not
possible to directly apply the algebraic complement method mentioned above.
In numerical analysis courses, various algorithms have been devised. However, due to
ﬁnite-precision numerical computation, these algorithms may have numerical problems when
the matrix is close to being singular. For example, consider the Hilbert matrix given by
H =
⎡
⎢⎢⎢⎣
1
1/2
1/3
· · ·
1/n
1/2
1/3
1/4
· · ·
1/(n + 1)
...
...
...
...
...
1/n
1/(n + 1)
1/(n + 2)
· · ·
1/(2n −1)
⎤
⎥⎥⎥⎦.
For n = 25, an erroneous determinant det(H) = 0 could actually be obtained even if
double-precision is used. On the other hand, if computer mathematics language is used, the
analytical solution of the determinant of an 80 × 80 Hilbert matrix can be obtained within
2.5 seconds:
det(H)=
1
99030101466993477878867678 · · ·000000000000

	

3790 decimal digits, with some digits omitted
≈1.009794 × 10−3790.
Below are the actual commands used in MATLAB for this problem
>> n=80; H=sym(hilb(n)); d=det(H) % build Hilbert matrix, ﬁnd determinant
Example 1.4
Consider the well-known nonlinear Van der Pol equation
y′′ + μ(y2 −1)y′ + y = 0,
and when μ is large, i.e., μ = 1000, how to numerically solve the equation.
Solution
The conventional numerical algorithms for solving diﬀerential equations such
as the standard Runge–Kutta method may cause numerical problems. Specialized numerical
algorithms for stiﬀordinary diﬀerential equations (ODEs) should be used instead, rather
than the standard Runge–Kutta methods in numerical analysis courses. Two lines of
statements in MATLAB are adequate in solving numerically such an equation
>> mu=1000; f=@(t,x)[x(2); -mu*(x(1)^2-1)*x(2)-x(1)]; % describe ODE
[t,x]=ode15s(f,[0,3000],[-1;1]); plot(t,x) % solve with graphics
As another example, the ﬁrst-order delay diﬀerential equation (DDE)
dy(t)
dt
= −0.1y(t) + 0.2
y(t −30)
1 + y10(t −30)

4
Scientiﬁc Computing with MATLAB®
cannot be solved using the commonly taught algorithms in numerical analysis courses.
Speciﬁc MATLAB functions or block diagram modeling tool Simulink can be used instead.
Details of the methods will be given later in the book.
Example 1.5
Solve the linear programming problem given below
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
2x2+x3+4x4+2x5⩽54
3x1+4x2+5x3−x4−x5⩽62
x1,x2⩾0, x3⩾3.32, x4⩾0.678, x5⩾2.57
−2x1 −x2 −4x3 −3x4 −x5.
Solution
Since the original problem is a linear constrained optimization problem, the
analytical unconstrained method, i.e., setting the derivatives of the objective function with
respect to each decision variable xi to zeros, cannot be used. With linear programming tools
in MATLAB, the following statements can be used
>> P.f=[-2 -1 -4 -3 -1]; P.Aineq=[0 2 1 4 2; 3 4 5 -1 -1];
P.Bineq=[54 62]; P.lb=[0;0;3.32;0.678;2.57]; P.solver=’linprog’;
P.options=optimset; x=linprog(P) % solve linear programming problem
and the numerical solutions can be found easily as x1 = 19.7850, x2 = 0, x3 = 3.3200, x4 =
11.3850, x5 = 2.5700.
Applying algorithms in numerical analysis or optimization courses, conventional
constrained optimization problems can be solved. However, if other special constraints are
introduced, for instance, the decision variables are constrained to be integers, the integer
programming must be used. There are not so many books introducing softwares that can
tackle the integer and mixed-integer programming problems. If we use MATLAB, the
solutions to this example problem are easily found as x1 =19, x2=0, x3 =4, x4 =10, x5 =5.
>> P.solver=’intlinprog’; P.options=optimoptions(’intlinprog’);
P.intcon=1:5; x=intlinprog(P)
Example 1.6
In many other courses of applied mathematics branches, such as integral
transform, complex-valued functions, partial diﬀerential equations, data interpolation and
ﬁtting, probability and statistics, can you still remember how to solve the problems after
the ﬁnal exams?
Example 1.7
With the rapid development of modern science and technology, many new
mathematics branches, such as fuzzy set, rough set, artiﬁcial neural network, evolutionary
computing algorithms have emerged. It would be a hard and time consuming task to use
the branches to solve particular problems, without using speciﬁc computer tools. If low-level
programming is expected, the researcher needs to fully understand the technical contents
of the branches, as well as how to implement the algorithms with computer languages.
However, if the existing tools and frameworks are used instead, the problems can be solved
in a much simpler manner.
In many subjects, such as electric circuits, electronics, motor drive, power electronics,
automatic control theory, more sophisticated examples and problems are usually skipped due
to the lack of introduction of high-level computer software tools. If computer mathematics
languages are introduced routinely in the above courses, complicated practical problems
can be solved and innovative solutions to the problems can be explored.

Computer Mathematics Languages — An Overview
5
1.1.2
Analytical solutions versus numerical solutions
The development of modern sciences and engineering depends heavily on mathematics.
However, the research interests of pure mathematicians are diﬀerent from other scientists
and engineers. Mathematicians are often more interested in ﬁnding the analytical or closed-
form solutions to mathematical problems. They are in particular interested in proving
the existence and uniqueness of the solutions, and do not usually care much about what
the solutions are. Engineers and scientists are more interested in ﬁnding the exact or
approximate solutions to the problems at hand and usually do not care too much about the
details on how the results are obtained, as long as the results are reliable and meaningful.
The most widely used approaches for ﬁnding the approximate solutions are the numerical
techniques.
It is quite common to ﬁnd that analytical solutions do not exist in reality in many
diﬀerent mathematics branches. For instance, it is well-known that the deﬁnite integral
2
√π
 a
0
e−x2 dx has no analytical solution. To solve the problem, mathematicians introduce
a special function erf(a) to denote it and do not care what in particular the numerical value
is. In order to ﬁnd an approximate value, scientists and engineers have to use numerical
approaches.
Another example is that the irrational number π has no closed-form solution. The ancient
Chinese astronomer and scientist Zu Chongzhi (429–500), also known as Tsu Ch’ung-chih,
found that the value is between 3.1415926 and 3.1415927, in about A.D. 480. This value is
accurate enough in most science and engineering practices. Even with the imprecise value
3.14 found by Archimedes (B.C. 287–B.C.212) in about B.C. 250, the solutions to most
engineering problems are often acceptable.
The above discussions hint that an approximate numerical solution is ubiquitous. In
many cases, only showing existence and uniqueness of solutions is not enough. We need to
compute the solution using computers.
The breadth and depth of one’s mathematical knowledge might not match one’s ability
of getting mathematical problems solved. In today’s applied science and engineering, one
usually needs to get the mathematical problems at hand solved eﬃciently in a timely manner
without complete understanding of the numerical techniques involved even in the solution
process. Therefore, today, arguably, it is a trend to focus more on how to formulate the
problem in a form suitable for computer solution and on the interpretation of the results
generated from the computer.
Numerical techniques have already been used in many scientiﬁc and engineering areas.
For instance, in mechanics, ﬁnite element methods (FEM) have been used in solving partial
diﬀerential equations. In aerospace and control, numerical linear algebra and numerical
solutions to ordinary diﬀerential equations have successfully been used for decades. For
simulation experiments in engineering and non-engineering areas, numerical solutions to
diﬀerence and diﬀerential equations are the core problems. In hi-tech developments, digital
signal processing based on fast Fourier transform (FFT) has been regarded as a routine task.
There is no doubt that if one masters one or more practical computation tools, signiﬁcant
enhancement of mathematical problem solving capability can be expected.
1.1.3
Mathematics software packages: an overview
The emerging digital computers fueled the developments of numerical as well as
symbolic computation techniques. In the early stages of the development of numerical

6
Scientiﬁc Computing with MATLAB®
computation techniques, some well established packages, such as the eigenvalue-based
package EISPACK [1, 2], linear algebra package LINPACK [3] in the USA, the NAG package
by the Numerical Algorithm Group in the UK, and the package in the well accepted book
Numerical Recipes [4], appeared and were widely used with good user feedback.
The famous EISPACK and LINPACK packages are both speciﬁc packages for numerical
linear algebra applications. Originally developed in the USA, EISPACK and LINPACK
packages were written in Fortran. To have a ﬂavor of how to use the packages, let us
consider eigenvalues (WR, WI for their real and imaginary parts) and eigenvectors Z of
an N × N real matrix A. As suggested by EISPACK, the standard solution method is by
sequentially calling relevant subroutines provided in EISPACK as follows:
CALL BALANC(NM,N,A,IS1,IS2,FV1)
CALL ELMHES(NM,N,IS1,IS2,A,IV1)
CALL ELTRAN(NM,N,IS1,IS2,A,IV1,Z)
CALL HQR2(NM,N,IS1,IS2,A,WR,WI,Z,IERR)
IF (IERR.EQ.0) GOTO 99999
CALL BALBAK(NM,N,IS1,IS2,FV1,N,Z)
Apart from the main body of the program, the user should also write a few lines to
input or initialize the matrix A to the above program and return or display the results
obtained by adding some display or printing statements. Then, the whole program should
be compiled and linked with the EISPACK library to generate an executable program. It
can be seen that the procedure is quite complicated. Moreover, if another matrix is to be
solved, the whole procedure might be repeated, which makes the solution process even more
complicated.
It is good news that the mathematical software packages are continuously developing,
implementing the leading-edge numerical algorithms, providing more eﬃcient, more reliable,
faster and more stable packages. For instance, in the area of numerical algebra, a new
LaPACK is becoming the leading package. Unlike the original purposes of EISPACK or
LINPACK, the objectives of LaPACK have been changed. LaPACK is no longer aiming
at providing libraries or facilities for direct user applications. Instead, LaPACK provides
support to mathematical software and languages. For example, MATLAB and a freeware
Scilab have abandoned the packages of LINPACK and EISPACK, and adopted LaPACK as
their low-level library support.
1.1.4
Limitations of conventional computer languages
Many people are using conventional computer languages, such as C and Fortran, in their
research. Needless to say that these languages were very useful, and they were the low-level
supporting languages of the computer mathematics languages such as MATLAB. However,
for the modern scientiﬁc and engineering researchers, these languages are not adequate for
solving their complicated computational problems. For instance, even for very experienced
C programmers, they may not be able to write C code to ﬁnd the indeﬁnite integral of a
given function, these involve knowledge of mathematical mechanization. Even for numerical
computations, there are limitations. Here two examples are given to illustrate the problems.
Example 1.8
It is known that Fibonacci sequence can be generated with the following
recursive formula, a1 =a2 =1, and ak = ak−1 + ak−2, k = 3, 4, · · ·. Please compute its ﬁrst
100 terms.
Solution Data type for each variable is assigned in C programming language ﬁrst. Since

Computer Mathematics Languages — An Overview
7
the terms in the sequence are integers, it is natural to select the data types int or long. If
int is selected, the following C program can be written.
main()
{
int a1, a2, a3, i;
a1=1; a2=1; printf("%d
%d
",a1,a2);
for (i=3; i<=100; i++){a3=a1+a2; printf("%d
",a3); a1=a2; a2=a3;
}}
It seems that the sequence can be obtained simply by using the program. But wait. Are
the results obtained correct? If the program is executed, from the 24th term, the value of the
sequence is negative, and from that term on, the terms are sometimes positive, sometimes
negative. It is obvious that some peculiar things must have happened in the program. The
problem is caused by the int data type, since the range of it is (−32767, 32767). If a term
is beyond this range, wrong results are generated. Even if long data type is adopted instead,
the correct answers may only last till about 10 more terms. To solve the problem of ﬁnding
the ﬁrst 100 terms, or even more, of Fibonacci sequence is certainly beyond the capabilities
of average C users, or even experienced C programmers. Extremely slight carelessness may
lead to misleading results.
With the use of MATLAB, this kind of trivial thing should not be considered. The
following code can be written directly
>> a=[1 1]; for i=3:100, a(i)=a(i-1)+a(i-2); end; a
Besides, for more accurate representation of the terms, symbolic data type can be used
instead, by substituting the ﬁrst statement with a = sym([1,1]). In this case, the 100th
term is a100 = 354224848179261915075, and even more, the 10000th term may be obtained,
with about 32 seconds of computation, and all the 2089 decimal digits can be found, whose
display may occupy more than half a page of the book.
Example 1.9
Write a universal C program to compute the product of two matrices.
Solution It is known from linear algebra courses that if matrix A is an n × p one, while
B is a p × m one, the product of the two matrices can be obtained with
cij =
p

k=1
aikbkj, i = 1, · · · , n, j = 1, · · · , m
From the formula, the kernel part of the program is the triple loop structure
for (i=0; i<n; i++){for (j=0; j<m; j++){
c[i][j]=0; for (k=0; k<p; k++) c[i][j]+=a[i][k]*b[k][j]; }}
It seems again that the problem can be solved with these simple statements. Unfortunately
there is still a serious problem in the short code, the multiplicability of the two matrices is
not considered. Imprecisely speaking, when the number of columns of A equals the number
of rows of B, the product can be found, otherwise, they are not multiplicable. To solve the
problem, an extra if statement should be added
if cols of A != rows of B, display an error message
Unfortunately by introducing such a statement, a new problem emerges. In mathematics,
when A or B is a scalar, the product of A and B can be found, however, this case is expelled
by introducing the above if statement. To solve the problem, more if statements are expected
to check the scalar cases.

8
Scientiﬁc Computing with MATLAB®
Although the above modiﬁcations are made, this program is not a universal one, since
complex matrices were not considered ar all. More statements are needed to make the
program universal.
It can be seen from the example that, if C or similar computer languages are used, the
programmers must be very careful to consider all the possible cases. If one or more cases
were not considered, wrong or misleading results may be obtained. In MATLAB, this kind of
trivial thing need not to be considered at all. The command C = A*B can be used directly. If
the two matrices are multiplicable, the product can be obtained, otherwise, an error message
will be displayed to indicate why the product cannot be found.
Of course, in real-time control and similar areas, C or similar languages have their own
advantages. Although some of the MATLAB code can be translated into C automatically,
this is beyond the scope of this book.
1.2
Summary of Computer Mathematics Languages
1.2.1
A brief historic review of MATLAB
In the late 1970s, Professor Cleve Moler, the Chairman of the Department of Computer
Science at the University of New Mexico found that the solutions to linear algebraic problems
using the then most advanced EISPACK and LINPACK packages were too complicated.
MATLAB (MATrix LABoratory) was then conceived and developed. The ﬁrst release of
MATLAB was freely distributed in late 1970s. Cleve Moler and Jack Little co-founded
The MathWorks Inc. in 1984 to develop the MATLAB language [5]. At that time, state
space-based control theory was rapidly developing, and a signiﬁcant amount of numerical
algebra problems needed to be solved. The appearance of MATLAB and its Control Systems
Toolbox soon attracted the attention of the control community. More and more control
oriented toolboxes were written by distinguished experts in diﬀerent control disciplines,
which added higher reputations to MATLAB. It is true that MATLAB was initiated by a
numerical mathematician, but its impacts and innovations were ﬁrst built by the control
community. Soon it became the general purpose language of control scientists and engineers.
With more and more new toolboxes in many other engineering disciplines, MATLAB is
becoming the de facto standard language of science and engineering.
1.2.2
Three widely used computer mathematics languages
There are three leading computer mathematics languages in the world with high
reputations. They are MATLAB of MathWorks Inc., Mathematica of Wolfram Research
and Maple of Waterloo Maple. They each have their own distinguishing merits, for instance,
MATLAB is good at numerical computation and easy in programming, while Mathematica
and Maple are powerful in pure mathematics problems involving symbolics and derivations.
The numerical computation capability of MATLAB is much stronger than the other two
languages. Besides, various nice toolboxes by experts can be used to tackle the problems
with high eﬃciency. In addition, the symbolic computation engine in Maple was used to
solve symbolic computation problems, and now with the MuPAD engine. Therefore, the
symbolic computation capability of MATLAB is essentially as good as Mathematica and

Computer Mathematics Languages — An Overview
9
Maple for most engineering mathematical problems. When the readers have mastered such
a computer mathematics language like MATLAB, the ability of handling mathematical
problems could be enhanced signiﬁcantly.
1.2.3
Introduction to free scientiﬁc open-source softwares
Although many extremely powerful scientiﬁc computation facilities have been provided
in the computer mathematics languages such as MATLAB, Maple and Mathematica, there
are certain limitations in their applications in research and education, for example, they are
expensive commercial softwares. Moreover, some of the core source codes are not accessible
to the users. Therefore, the open-source softwares are welcome in scientiﬁc computation as
well. Some inﬂuential softwares include:
(i) Scilab Scilab is developed and maintained by INRIA, France. The syntaxes are very
similar to MATLAB. It is a free open-source software which concentrates in particular on
control and signal processing. The Scicos in Scilab is a block diagram simulation environment
similar to Simulink. The web-page of Scilab is http://www.scilab.org/.
(ii) Octave
Octave was ﬁrst released in 1993. It is a promising open-source
software for numerical computation, initiated from numerical linear algebra. The earlier
objective of the software was to provide support in education. The web-page of Octave is
http://www.gnu.org/software/octave/.
(iii) Others Some other small-scale numerical matrix computation softwares such as
Freemat and SpeQ are all attractive free softwares.
1.3
Outline of the Book
The book can be used as a reference text or even a textbook of a new course on scientiﬁc
computation. The applications of all branches of college mathematics can be taught in such
a course with broad coverage, which enables the students to view mathematics from a
diﬀerent angle. This will signiﬁcantly increase the ability of the students for mathematical
problem solutions. The book can also be used as a reference book for actual mathematical
problem solutions.
1.3.1
The organization of the book
The contents of the book are summarized below:
Chapter 1, the current chapter, answers the question “Why MATLAB” in scientiﬁc
computation and gives an overview of the development of MATLAB and other computer
mathematics languages.
Chapter 2, “Fundamentals of MATLAB Programming,” introduces brieﬂy the pro-
gramming essentials of MATLAB, including data structure, ﬂow control structures and
M-function programming. Two-dimensional, three-dimensional graphics, or even four-
dimensional graphics, through volume visualization techniques, are also presented. This
chapter is the basis for the materials in the book.
Chapter 3, “Calculus Problems,” covers the problems in college calculus, from a diﬀerent
viewpoint. The subjects introduced in the chapter include limits, derivatives and integrals

10
Scientiﬁc Computing with MATLAB®
of univariate and multivariate functions. Series expansion problems such as Taylor series
and Fourier series expansions as well as series sums and products are covered. Convergency
tests of inﬁnite series are explored. MATLAB solutions to path, line and surface integrals
are illustrated. Finally, numerical diﬀerentiation and integral (or quadrature) are also
introduced.
Chapter 4, “Linear Algebra Problems,” studies linear algebra problems using both
analytical and numerical methods. Special matrices in MATLAB are ﬁrst discussed followed
by basic matrix analysis, matrix transformation and matrix decomposition problems. Matrix
equation solutions, including linear equations, Lyapunov equation and Riccati equations,
are introduced. How to evaluate matrix functions is introduced for both the exponential
function and the functions of arbitrary forms. Also, the integer power of matrices are also
explored.
Chapter 5, “Integral Transforms and Complex-valued Functions,” includes the solutions
to Laplace transform problems and their inverse, Fourier transforms and their variations,
z, Mellin and Hankel transforms. Numerical solutions of integral transform are illustrated,
where numerical inverse Laplace transform and fast Fourier transform are in particular
discussed. The analysis of complex-valued functions are also introduced, including poles,
residues, partial fraction expansion, Laurent series, and closed-path integral problems, all
with many illustrative solution examples. Diﬀerence equation solutions are explored also in
the chapter.
Chapter 6, “Nonlinear Equations and Optimization Problems,” explores the search
methods for linear equations, nonlinear equations and nonlinear matrix equations. The
unconstrained optimization, constrained optimization and mixed integer programming
problems are demonstrated. Linear matrix inequality (LMIs) problems are also covered in
the chapter. Multi-objective optimization problems and dynamical programming problems
are also introduced. Dynamic programming problems, with particular applications in
shortest path planning problems, are demonstrated.
Chapter 7, “Diﬀerential Equations Problems,” mainly covers analytical as well as
numerical solutions to ordinary diﬀerential equations. Diﬀerent types of ordinary diﬀerential
equations, including stiﬀequations, implicit equations, diﬀerential algebraic equations, delay
diﬀerential equations and the boundary valued equations are illustrated. An introduction
to partial diﬀerential equations is also given brieﬂy through examples. In particular, block
diagram-based modeling and numerical solutions of diﬀerential equations are explored with
the sophisticated Simulink environment.
Chapter 8, “Data Interpolation and Functional Approximation Problems,” studies the
interpolation problems such as simple interpolation, cubic spline and B-spline problems. We
show that numerical diﬀerentiation and integration problems can be solved with splines.
Polynomial ﬁtting, continued fraction expansion and Pad´e approximation as well as least
squares curve ﬁtting methods are all covered and illustrated. An introduction to signal
ﬁltering and de-noising problems is also presented brieﬂy in this chapter.
Chapter 9, “Probability and Mathematical Statistics Problems,” studies the probability
distributions and pseudorandom number generators ﬁrst. Statistical analysis to the
measured random data is then illustrated. Hypothesis tests for a few common applications
are presented, and the analysis of variance method is demonstrated brieﬂy through
examples. An introduction to principal component analysis problems is also given.
Chapter 10, “Nontraditional Solution Methods,” covers a wide variety of interesting
topics, such as traditional set theory, rough set theory, fuzzy set theory and fuzzy inference

Computer Mathematics Languages — An Overview
11
system, neural networks, wavelet transform, evolutionary optimization methods including
genetic algorithms and particle swarm optimization methods. Most interestingly, fractional-
order calculus (derivatives or integrals of non-integer order) problems are introduced with
basic numerical computational techniques and examples.
1.3.2
How to learn and use MATLAB
The best way to learn a computer language like MATLAB is learning through extensive
practice. MATLAB should be installed on your computer, and when invoked, the main
interface is shown in Figure 1.1. The Command Window is the place where MATLAB
commands are issued, and >> is the MATLAB prompt. For new users of MATLAB, it
is advised to type demo after the MATLAB prompt, and experience the facilities provided
in an easy-to-understand manner.
FIGURE 1.1: Main interface of MATLAB.
In this book, almost all the engineering mathematics branches are involved. On-line
help facilities provided in MATLAB are useful for getting extra information of a particular
function or a class of problems. The readers are recommended to get acquainted with such
facilities. Help information can be obtained with the Help menu in the MATLAB command
window, as shown in Figure 1.2(a). If the Using the Desktop menu item is selected, an on-line
help window is opened, as shown in Figure 1.2(b).
Alternatively, the commands help or doc can be issued in the MATLAB command
window, and the command lookfor can be used to search keywords.
1.3.3
The three-phase solution methodology
A three-phase methodology proposed by the authors is used throughout the book in
presenting mathematical problem solutions [6]. The three phases are respectively “What,”
“How” and “Solve.” In the “What” phase, the physical explanation of the mathematical
problem to be solved is presented. Even though the students have not yet learned the

12
Scientiﬁc Computing with MATLAB®
(a) the Help menu
(b) on-line help window
FIGURE 1.2: On-line help information.
corresponding mathematics course, he can understand roughly what the problem is really
about. In the “How” phase, the mathematical problem should be described in a manner
understandable by MATLAB. In the ﬁnal “Solve” phase, appropriate MATLAB functions
should be called to solve the problem directly. If there is an existing MATLAB function, the
syntax of the function is presented, and if there is not one, a universal function is written
to solve the problem.
Example 1.10 Let us revisit the materials in Example 1.5, where the linear programming
problem is involved, the philosophy used in the book is illustrated
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
2x2+x3+4x4+2x5⩽54
3x1+4x2+5x3−x4−x5⩽62
x1,x2⩾0, x3⩾3.32, x4⩾0.678, x5⩾2.57
−2x1 −x2 −4x3 −3x4 −x5.
Solution
To solve such a problem, even though the reader may have not learned
optimization courses, the solution can be obtained following the three-phases.
(i) “What” phase
In this book, we shall explain ﬁrst the physical meaning of the
mathematical problem. In this particular example, the mathematical formula means that
under the simultaneous inequality constraints
⎧
⎨
⎩
2x2 + x3 + 4x4 + 2x5 ⩽54
3x1 + 4x2 + 5x3 −x4 −x5 ⩽62
x1, x2 ⩾0, x3 ⩾3.32, x4 ⩾0.678, x5 ⩾2.57,
how can we ﬁnd a set of decision variables xi, to minimize the objective function
f(x) = −2x1 −x2 −4x3 −3x4 −x5.
(ii) “How” phase
Illustrate the readers how to represent the problem in MATLAB.
The code in Example 1.5 can be used to establish variable P. The mathematical problem
should be expressed in a format understandable by MATLAB.
>> P.f=[-2 -1 -4 -3 -1]; P.Aineq=[0 2 1 4 2; 3 4 5 -1 -1];

Computer Mathematics Languages — An Overview
13
P.Bineq=[54 62]; P.lb=[0;0;3.32;0.678;2.57]; P.solver=’linprog’;
P.options=optimset; % express the linear programming problem in structure P
(iii) “Solve” phase
Call the linprog() function and get the result.
>> x=linprog(P) % solve the problem with appropriate function linprog
It appears that the book is presenting in certain depth some mathematical problems.
However, the ultimate objective of this book is to help the readers, after understanding
roughly the mathematical background, to bypass the tedious and complex technical details
of mathematics and ﬁnd the reliable and accurate solutions to the interested mathematical
problems with the use of MATLAB computer mathematics language. There is no doubt that
the readers’ capability in tackling mathematical problems can be signiﬁcantly enhanced after
reading this book.
Exercises
Exercise 1.1 Install MATLAB on your machine, and issue the command demo. From
the dialog boxes and menu items of the demonstration program, experience the powerful
functions provided in MATLAB.
Exercise 1.2 In order to understand the three-phase learning stage, please revisit Example
1.5, and see which statements belong to the second and third phases. Also, please think about
what should be done for the ﬁrst phase.
Exercise 1.3 Solve the following Lyapunov equation by starting the command
>> lookfor lyapunov
and see whether there is any function related to the keyword lyapunov. If there is one, say,
the lyap function is found, type doc lyap and see whether there is a way to solve this
Lyapunov equation. Check the accuracy of the solution by back substitution.
⎡
⎣
8
1
6
3
5
7
4
9
2
⎤
⎦X + X
⎡
⎣
16
4
1
9
3
1
4
2
1
⎤
⎦=
⎡
⎣
1
2
3
4
5
6
7
8
0
⎤
⎦.
Bibliography
[1] Garbow B S, Boyle J M, Dongarra J J, et al. Matrix eigensystem routines — EISPACK
guide extension, Lecture notes in computer sciences, volume 51. New York: Springer-
Verlag, 1977
[2] Smith B T, Boyle J M, Dongarra J J, et al. Matrix eigensystem routines – EISPACK
guide, Lecture notes in computer sciences, volume 6. New York: Springer-Verlag, second
edition, 1976

14
Scientiﬁc Computing with MATLAB®
[3] Dongarra J J, Bunsh J R, Molor C B. LINPACK user’s guide. Philadelphia: Society of
Industrial and Applied Mathematics, 1979
[4] Press W H, Flannery B P, Teukolsky S A, et al. Numerical recipes, the art of scientiﬁc
computing. Cambridge: Cambridge University Press, 1986
[5] Moler C B.
Evolution of MATLAB (Video of presentation at Tongji University,
China, subtitled by Xue D Y). http://v.youku.com/v show/id XNDc0NTM4NzQw.html
?tpa=dW5pb25faWQ9MjAwMDE0XzEwMDAwMV8wMV8wMQ, 2012
[6] Xue D Y. Mathematics education made more practical with MATLAB. Presentation at
the First MathWorks Asian Research Faculty Summit, Tokyo, Japan, November, 2014

Chapter 2
Fundamentals of MATLAB Programming
and Scientiﬁc Visualization
MATLAB language is becoming a widely accepted scientiﬁc language, especially in the
ﬁeld of automatic control. In other engineering and non-engineering disciplines such as
economics and even biology, MATLAB is also an attractive and promising computer
mathematics language. In this book, we shall concentrate on the introduction to MATLAB
with its applications in solving applied mathematics problems. A good working knowledge
of MATLAB language will enable one not only to understand in depth the concepts and
algorithms in research but also increase the ability to do creative research work and apply
MATLAB to actively tackle the problems in other related research areas.
As a programming language, MATLAB has the following advantages:
(i) Clarity and high eﬃciency
MATLAB language is a highly integrated language.
A few MATLAB sentences may do the work of hundreds of lines of source code of other
languages. Therefore, the MATLAB program is more reliable and easy to maintain.
(ii) Scientiﬁc computation
The basic element in MATLAB is a complex matrix of
double-precision. Matrix manipulations can be carried out directly. Numerical computation
functions provided in MATLAB, such as the ones for solving optimization problems or
other mathematical problems, can be used directly. Also, symbolic computation facilities
are provided in MATLAB’s Symbolic Math Toolbox to support formula derivation.
(iii) Graphics facilities MATLAB language can be used to visualize the experimental
data in an easy manner. Implicit functions can be drawn with ease in the MATLAB
environment. Moreover, the graphical user interface and object-oriented programming are
also supported in MATLAB.
(iv) Comprehensive toolboxes and blocksets
There are a huge amount of
MATLAB toolboxes and Simulink blocksets contributed by experienced programmers and
researchers.
(v) Powerful system simulation facilities
The powerful block diagram-based
modeling technique provided in Simulink can be used to analyze systems with almost
any complexity. In particular, under Simulink, the control blocks, electronic blocks and
mechanical blocks can be modeled together under the same framework, which is currently
not possible in other computer mathematics languages.
In Section 2.1, the fundamental information about MATLAB programming, such as
the data types, statement structures, colon expressions and sub-matrix extraction is
introduced. In Section 2.2, the basic operations, including algebraic, logic and relationship
operations, and simpliﬁcation of symbolic formulae, and an introduction to number theory
are presented. The ﬂow control such as loop structures, conditional structures, switches
and trial structures are introduced in Section 2.3. In Section 2.4, the most important
programming structure, the M-function, is illustrated with useful hints on high-level
programming. In Section 2.5, two-dimensional graphics facilities are presented, where two-
dimensional sketching and implicit function expressions are illustrated in particular. Three-
15

16
Scientiﬁc Computing with MATLAB®
dimensional graphics are presented in Section 2.6, where mesh, surface and contour plots
can be drawn. Viewpoint setting and other facilities are introduced. In Section 2.7, even
more sophisticated four-dimensional volume visualization is also presented.
Only very essential introductory knowledge is presented in the chapter. More materials
on MATLAB will be provided gradually through practical examples in later chapters.
2.1
Essentials in MATLAB Programming
2.1.1
Variables and constants in MATLAB
MATLAB variable names consist of a letter, followed by any number of letters, digits or
underscores, with maximum length of 63. For instance, MYvar12, MY Var12 and MyVar12 are
valid variable names, while 12MyVar and MyVar12 are invalid ones, since the ﬁrst character
is not a letter. The variable names are case-sensitive, i.e., the variables Abc and ABc are
diﬀerent variables.
In MATLAB, some of the names are reserved for the constants. They can however be
assigned to other values. It is suggested that these names should not be reassigned to other
values if possible.
(i) eps — error tolerance for ﬂoating-point operation. The default value is eps= 2.2204×
10−16, and if the absolute value of a quantity is smaller than eps, it can be regarded as 0.
(ii) i and j — If i or j is not overwritten, they both represent √−1. If they are
overwritten, they can be restored with the i = sqrt(−1) command.
(iii) Inf — the MATLAB representation of inﬁnity quantity +∞. It can also be written
as inf. Similarly −∞can be written as -Inf. When 0 is used in the denominator, the
value Inf can be generated, with a warning. This agrees with the IEEE standard. For
mathematical computation, this deﬁnition has its advantages over C language.
(iv) NaN — not a number, which is often returned by the operations 0/0, Inf/Inf and
others. Noted that NaN times Inf will return NaN.
(v) pi — double-precision representation of the circumference ratio π.
(vi) lasterr — returns the error message received last time. It can be a string variable,
with empty string for no error message generated.
(vii) lastwarn — returns the last obtained warning message.
2.1.2
Data structures
I. Numeric data type
Numerical computation is the most widely used computation form in MATLAB. To
ensure high-precision computations, double-precision ﬂoating-point data type is used, which
is 8 bytes (64 bits). According to the IEEE standard, it is composed of 11 exponential bits,
52 fraction bits and a sign bit, representing the data range of ±1.7×10308, with about 15∼17
signiﬁcant decimal digits. The MATLAB function for deﬁning this data type is double().
In other special applications, i.e., in image processing, an unsigned 8 bit integer can
be used, whose function is uint8(), representing the value in (0, 255). Thus, signiﬁcant
memory space is saved. Also, the data types such as int8(), int16(), int32(), uint16()
and uint32() can be used.

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
17
II. Symbolic data type
Symbolic variables are also deﬁned in MATLAB in contrast to the conventional numerical
variables. They can be used in formula derivation and analytical solutions of mathematical
problems. Before ﬁnding analytical solutions, the related variables should be declared as
symbolic ones, with the syms statement syms var list var props, where var list is the list of
variables to be declared, separated by spaces. If necessary, the types of the properties of the
variables can be assigned by var props, which can either be real or positive. For instance,
if one wants to assume that a,b are symbolic variables, the statement syms a b can be used.
Also, the statement syms a real can be used to indicate that a is a real variable.
Further assumptions can be made to speciﬁc symbolic variables. For instance, if symbolic
variables t ⩽4 and x ̸= 2 are to be assigned, they must ﬁrst be speciﬁed as symbolic
variables, then, assume() function can be used
>> syms t x; assume(t<=4); assume(x~=2); % declares t ⩽4 and x ̸= 2
Function assumeAlso() can also be used to pose more speciﬁcations on certain symbolic
variables. For instance, if x is real and −1 ⩽x < 5, the MATLAB declaration is
>> syms x real; assume(x>=-1); assumeAlso(x<5); % declare −1⩽x<5
The type of symbolic variables can be extracted with assumptions() function.
For instance, if variable a is declared with the command syms a real, the function
call assumptions(a) returns R , while for x deﬁned above, assumptions() function
returns [x < 5,x >= 1]. Alternatively, the variable can be assigned with the command
assume(x>= −1 & x < 5).
Example 2.1 Please declare a positive symbolic integer k such that it is a multiple of 13,
and it does not exceed 3000.
Solution
It can be found by simple calculation that 3000/13 is slightly larger than 230.
Thus, the following MATLAB commands can be used to deﬁne such a k
>> syms k1; assume(k1,’integer’); assumeAlso(k1<=230); % upper bound
assumeAlso(k1>0); k=13*k1 % declare lower bound and multiples of 13
The variable precision arithmetic function vpa() can be used to display the symbolic
variables in any precision. The syntax of the function is vpa(A,n) or vpa(A), where A is
the variable to be displayed, and n is the number of digits expected, with the default value
of 32 decimal digits.
Example 2.2
Display the ﬁrst 300 decimal digits of π.
Solution The following statement can be used directly to display the exact value of π, with
up to 300 terms
>> vpa(pi,300) % display the ﬁrst 300 decimal digits of π
and the result is shown as 3.1415926535897932384626433832795028841971693993751058209
749445923078164062862089986280348253421170679821480865132823066470938446095505
822317253594081284811174502841027019385211055596446229489549303819644288109756
659334461284756482337867831652712019091456485669234603486104543266482133936072
6024914127.
One may also require a large number of digits to be displayed. Also, the result obtained
with the statement vpa(pi) is 3.1415926535897932384626433832795.

18
Scientiﬁc Computing with MATLAB®
III. Other data types
Apart from the commonly used numerical data types in MATLAB, the following data
types are also provided such that
(i) Strings
String variables are used to store messages. The string is quoted with single
quotation marks, such as ’Hello world’.
(ii) Multi-dimensional arrays
Three-dimensional and even multi-dimensional arrays
are the direct extension of matrices.
(iii) Cell arrays
Cells are extension of matrices, whose elements are no longer values.
The element, referred to as cells, of cell arrays can be of any data type. For instance, A{i,j}
can be used to represent the (i, j)th term of the cell array A.
(iv) Structured variables
A structured variable A may have many ﬁelds represented
as A.b, and ﬁeld b can be of any data type.
(v) Classes and objects
MATLAB allows the use of classes in the programming. For
instance, the transfer function class in control can be used to represent a transfer function of
a system in a single variable. An example of the creation and overload function programming
of an object is given in Section 10.6.
2.1.3
Basic statement structures of MATLAB
Two types of MATLAB statements can be used:
(i) Direct assignment
The basic structure of this type of statement is
variable= expression
and expression can be evaluated and assigned to the variable deﬁned in the left-hand-side,
and established in MATLAB workspace. If there is a semicolon used at the end of the
statement, the result is not displayed. Thus, the semicolon can be used to suppress the
display of intermediate results. If the left-hand-side variable is not given, the expression will
be assigned to the reserved variable ans. Thus, the reserved variable ans always stores the
latest statements without a left-hand-side variable.
Example 2.3
Specify the matrix A =
⎡
⎣
1
2
3
4
5
6
7
8
0
⎤
⎦into MATLAB workspace.
Solution The matrix A can easily be entered into MATLAB workspace, with the following
statement
>> A=[1,2,3; 4 5,6; 7,8 0] % enter a matrix directly
where >> is the MATLAB prompt, which is given automatically in MATLAB. Under the
prompt, various MATLAB commands can be speciﬁed. For matrices, square brackets should
be used to describe matrices, with the elements in the same row separated by commas, and
the rows are separated by semicolons. The double-precision matrix variable A can then be
established in MATLAB workspace. The matrix A can be displayed in MATLAB command
window.
A semicolon at the end of the statement suppresses the display of such a matrix. The
size of a matrix can be expanded or reduced dynamically, with the following statements.
>> A=[1,2,3; 4 5,6; 7,8 0];
% assignment is made, however, no display
A=[[A; [1 2 3]], [1;2;3;4]]; % dynamically deﬁne the size of matrix

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
19
Example 2.4
Enter complex matrix B =
⎡
⎣
1+j9
2+j8
3+j7
4+j6
5+j5
6+j4
7+j3
8+j2
0+j1
⎤
⎦into MATLAB.
Solution Specifying a complex matrix in MATLAB is as simple as with the case for real
matrices. The notations i and j can be used to describe the imaginary unit. Thus, the
following statement can be used to enter the complex matrix B
>> B=[1+9i,2+8i,3+7j; 4+6j 5+5i,6+4i; 7+3i,8+2j 1i] % complex matrix
(ii) Function call statement
The basic function call statement is
[returned arguments] = function name(input arguments)
where, the regulation for function names are the same as in variable names. Generally
the function names are the ﬁle names in the MATLAB path. For instance, the function
name my fun corresponds to the ﬁle my fun.m. Of course, some of the functions are built-in
functions in MATLAB kernel, such as the inv() function.
More than one input argument and returned argument are allowed, in which case,
commas should be used to separate the arguments. For instance, the function call
[U S V ] = svd(X) performs singular value decomposition to a given matrix X, and
the three arguments U, S, V will be returned.
2.1.4
Colon expressions and sub-matrices extraction
Colon expression is an eﬀective way in deﬁning row vectors. It is useful in generating
vectors and in extracting sub-matrices. The typical form of colon expression is v = s1:s2:s3.
Thus, a row vector v can be established in MATLAB workspace, with the initial value s1,
the increment s2 and the ﬁnal value s3. If the term s2 is omitted, a default increment of 1
is used instead. The examples given below illustrate the use of colon expressions.
Example 2.5
For diﬀerent increments, establish vectors for t ∈[0, π].
Solution One may select an increment 0.2. The following statement can be used to establish
a row vector such that
>> v1=0: 0.2: pi % generate a row vector
and the row vector is then established such that
v1 =[0, 0.2, 0.4, 0.6, 0.8, 1, 1.2, 1.4, 1.6, 1.8, 2, 2.2, 2.4, 2.6, 2.8, 3].
It is noted that the last term in v1 is 3, rather than π.
The following commands can be used to input row vectors using colon expressions
>> v2=0: -0.1: pi
% negative step here means no vector generated
v3=0:pi
% with the default step-size of 1
v4=pi:-1:0
% the new vector in the reversed order
thus, v2 is a 1 × 0 (empty) matrix, v3 =[0, 1, 2, 3], while v4 =[3.142, 2.142, 1.142, 0.142].
The sub-matrix of a given matrix A can be extracted with the MATLAB statement,
and the matrix can be extracted with B = A(v1,v2), where v1 vector contains the rows
to retain, and v2 contains the numbers of columns. Therefore, the relevant columns and
rows can be extracted from matrix A. The sub-matrix can be returned in matrix B. If v1
is assigned to :, all the elements in the v2 columns can be extracted. The keyword end can
be used to indicate the last row or column.

20
Scientiﬁc Computing with MATLAB®
Example 2.6 With the following statements, diﬀerent sub-matrices can be extracted from
the given matrix A, such that
>> A=[1,2,3; 4,5,6; 7,8,0];
B1=A(1:2:end, :)
% extract all the odd rows of matrix A
B2=A([3,2,1],[1 1 1]) % copy the reversed ﬁrst column to all columns
B3=A(:,end:-1:1)
% ﬂip left to right the given matrix A
B4=A([2 2 2],:)
% copy the second row of A three times
and the sub-matrices extracted with the above statements are
B1 =
1
2
3
7
8
0

, B2 =
⎡
⎣
7
7
7
4
4
4
1
1
1
⎤
⎦, B3 =
⎡
⎣
3
2
1
6
5
4
0
8
7
⎤
⎦, B4 =
⎡
⎣
4
5
6
4
5
6
4
5
6
⎤
⎦.
2.2
Fundamental Mathematical Calculations
2.2.1
Algebraic operations of matrices
Suppose matrix A has n rows and m columns, it is then referred to as an n × m matrix.
If n = m, then, matrix A is also referred to as a square matrix. The following algebraic
operations can be deﬁned:
(i) Matrix transpose
In mathematics textbooks, the transpose of matrices is often
denoted as AT. For an n × m matrix A, the transpose matrix B can be deﬁned as bji =
aij, i = 1, · · · , n, j = 1, · · · , m, therefore, B is an m × n matrix. If matrix A contains
complex elements, a special transpose can also be deﬁned as bji = a∗
ij, i = 1, · · · , n, j =
1, · · · , m, i.e., the complex conjugate transpose matrix B is deﬁned. This kind of transpose
is referred to as the Hermitian transpose, denoted as B = AH. In MATLAB, A’ can be
used to evaluate the Hermitian matrix of A. The simple transpose can be obtained with
A.’. For a real matrix A, A’ is the same as A.’.
(ii) Addition and subtraction
Assume that there are two matrices A and B in
MATLAB workspace, the statements C = A + B and C = A −B can be used respectively
to evaluate the addition and subtraction of these two matrices. If the matrices A and B are
with the same size, the relevant results can be obtained. If one of the matrices is a scalar,
it can be added to or subtracted from the other matrix. If the sizes of the two matrices are
diﬀerent, error messages can be displayed.
(iii) Matrix multiplication
Assume that matrix A of size n × m and matrix B of
size m × r are two variables in MATLAB workspace, and the columns of A equal the rows
of B, the two matrices are referred to as compatible. The product can be obtained from
cij =
m

k=1
aikbkj, where i = 1, 2, · · · , n, j = 1, 2, · · · , r.
(2-2-1)
If one of the matrices is a scalar, the product can also be obtained. In MATLAB, the
multiplication of the two matrices can be obtained with C = A*B. If the two matrices are
not compatible, an error message will be given.
(iv) Matrix left division
The left division of the matrices A\B can be used to solve
the linear equations AX = B. If matrix A is nonsingular, then, X = A−1B. If A is not

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
21
a square matrix, A\B can also be used to ﬁnd the least squares solution to the equations
AX = B.
(v) Matrix right division
The statement B/A can be used to solve the linear
equations XA = B. More precisely, B/A = (A’\B’)’.
(vi) Matrix ﬂip and rotation
The left-right ﬂip and up-down ﬂip of a given
matrix A can be obtained with B = fliplr(A) and C = flipud(A) respectively, such
that bij = ai,n+1−j and cij = am+1−i,j. The command D = rot90(A) rotates matrix A
counterclockwise by 90◦, such that dij = aj,n+1−i. Command D = rot90(A,k) is also
allowed to rotate matrix A by 90k◦in a counterclockwise direction.
(vii) Matrix power
Ax computes the matrix A to the power x when matrix A is
square. In MATLAB, the power can be evaluated with F = A^x.
(viii) Dot operation
A class of special operation is deﬁned in MATLAB. The
statement C = A.*B can be used to obtain element-by-element product of matrices A
and B, such that cij = aijbij. The dot product is also referred to as the Hadamard product.
Dot operation plays an important role in scientiﬁc computation. For instance, if a vector
x is given, then, the vector [x5
i ] cannot be obtained with x^5. Instead, the command x.^5
should be used. In fact, some of the functions such as sin() can also be used in element-
by-element operation.
Dot operation can be used to deal with other problems, for instance, the statement
A.^A can be used, with the (i, j)th element then deﬁned as aaij
ij . Therefore, the matrix
can be obtained
⎡
⎣
11
22
33
44
55
66
77
88
00
⎤
⎦=
⎡
⎣
1
4
27
256
3125
46656
823543
16777216
1
⎤
⎦.
Example 2.7
Consider again the matrix A in Example 2.3. Find all the cubic roots of
such a matrix and verify the results.
Solution The cubic root of the matrix A can easily be found and validated with
>> A=[1,2,3; 4,5,6; 7,8,0]; C=A^(1/3), e=norm(A-C^3) % cubic root & verify
and it can be found, with an error of e = 8.2375×10−15, that
C =
⎡
⎣
0.7718 + j0.6538
0.4869 −j0.0159
0.1764 −j0.2887
0.8885 −j0.0726
1.4473 + j0.4794
0.5233 −j0.4959
0.4685 −j0.6465
0.66929 −j0.6748
1.3379 + j1.0488
⎤
⎦.
In fact, the cubic root of matrix A should have three solutions. The other two roots can
be rotated as Cej2π/3 and Cej4π/3, with the following statements
>> j1=exp(sqrt(-1)*2*pi/3); A1=C*j1, A2=C*j1^2 % rotate to ﬁnd more roots
norm(A-A1^3), norm(A-A1^3)
% validate the results
and the other two roots, through veriﬁcation, are
A1 =
⎡
⎣
−0.9521 + j0.3415
−0.2297 + j0.4296
0.1618 + j0.2971
−0.3814 + j0.8058
−1.1388 + j1.0137
0.1678 + j0.7011
0.3256 + j0.7289
0.2497 + j0.9170
−1.5772 + j0.6343
⎤
⎦,
and
A2 =
⎡
⎣
0.1803 −j0.9953
−0.2572 −j0.4137
−0.3382 −j0.0084
−0.5071 −j0.7332
−0.3085 −j1.4931
−0.6911 −j0.2052
−0.7941 −j0.0825
−0.9190 −j0.2422
0.2393 −j1.6831
⎤
⎦.

22
Scientiﬁc Computing with MATLAB®
It should be pointed out that symbolic matrices like this cannot be used to directly ﬁnd its
cubit root, however, vpa() can be used to increase the accuracy. If the following statements
are used, the norm of the error matrix is around 10−39.
>> A=sym([1,2,3; 4,5,6; 7,8,0]); C=A^(sym(1/3)); C=vpa(C); norm(C^3-A)
2.2.2
Logic operations of matrices
Logical data was not implemented in earlier versions of MATLAB. The nonzero value
is regarded as logic 1, while a zero value is deﬁned as logic 0. In new versions of MATLAB,
logical variables are deﬁned and the above rules also apply.
Assume that the matrices A and B are both n × m matrices, the following logical
operations are deﬁned:
(i) “And” operation In MATLAB, the operator & is used to deﬁne element-by-element
“and” operation. The statement A & B can then be deﬁned.
(ii) “Or” operation
In MATLAB, the operator | is used to deﬁne element-by-element
“or” operation. The statement A | B can then be deﬁned.
(iii) “Not” operation
In MATLAB, the operator ~ can be used to deﬁne the “not”
operation such that B = ∼A.
(iv) Exclusive or The exclusive or operation of two matrices A and B can be evaluated
from xor(A,B).
2.2.3
Relationship operations of matrices
Various relationship operators are provided in MATLAB. For example, the command
C = A > B performs element-by-element comparison between matrices A and B, with the
element cij = 1 for aij > bij, and cij = 0 otherwise. The equality relationship can be tested
with == operator, while the other operators >=, ∼= can also be used.
The special functions such as find() and all() can also be used to perform relationship
operations. For instance, the index of the elements in C equal to 1 can be obtained from
find(C == 1). The following commands
>> A=[1,2,3; 4 5,6; 7,8 0]; % enter a matrix
i=find(A>=5)’ % ﬁnd all the indices in A whose value is larger than 5
can be used, and the indices can be found as i = 3, 5, 6, 8. It can be seen that the function
arranges ﬁrst the original matrix A in a single column, on a column-wise basis. The indices
can then be returned.
The functions all() and any() can also be used to check the values in the given matrices.
For instance
>> a1=all(A>=5) % check each column whether all larger than 5
a2=any(A>=5) % check each column whether any larger than 5
and it can be found that a1 = [0, 0, 0], a2 = [1, 1, 1].
2.2.4
Simpliﬁcations and presentations of analytical results
The Symbolic Math Toolbox can be used to derive mathematical formulas. The results,
however, are often not presented in their simplest form. The results should then be

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
23
simpliﬁed. The easiest way of simpliﬁcation is by the use of simplify() function, where
diﬀerent simpliﬁcation methods are tested automatically until the simplest result can be
obtained, with the syntax
f1 = simplify(f)
% try various simpliﬁcation methods automatically
where f is the original symbolic expression, and f1 is the simpliﬁed result.
Apart from the easy-to-use simplify() function, the function collect() can be used
to collect the coeﬃcients, and function expand() can be used to expand a polynomial.
The functions factor(), lcm() and gcd() can also be used in processing polynomials. The
function numden() can be used to extract the numerator and denominator from a given
expression.
Example 2.8
If a polynomial P(s) is given by P(s) = (s + 3)2(s2 + 3s + 2)(s3 + 12s2 +
48s + 64), process it with various functions and understand the results converted.
Solution A symbolic variable s should be declared ﬁrst, then, the full polynomial can be
expressed easily and the polynomial can then be established in MATLAB workspace. With
the polynomial, one can ﬁrst simplify it with the simplify() function
>> syms s; P=(s+3)^2*(s^2+3*s+2)*(s^3+12*s^2+48*s+64) % build expression
P1=simplify(P), P2=expand(P)
% try diﬀerent forms
and one ﬁnds that P1 = (s+ 3)2(s+ 4)3(s2 + 3s+ 2), P2 = s7+21s6+185s5+883s4+2454s3+
3944s2+3360s+1152.
The new factor() function extracts all the factors in a vector, thus, the factorized form
can be obtained as P4 = (s + 1)(s + 2)(s + 3)2(s + 4)3.
>> P3=factor(P), P4=prod(P3) % ﬁnd the factorized form
The function subs() provided in the Symbolic Math Toolbox can be used to perform
variable substitution, and the syntaxes are
f1 = subs(f,x1,x∗
1)
% replace one variable
f1 = subs(f,{x1, x2, · · · , xn},{x∗
1, x∗
2, · · · , x∗
n}) % replace several together
where f is the original expression. With the statement, the variable x1 in the original
function can be substituted with a new variable or expression x∗
1. The result is given in the
variable f1. The latter syntax can be used to substitute many variables simultaneously.
The function latex() can be used to convert a symbolic expression into a LATEX-readable
string, which can be embedded into a LATEX document.
Example 2.9
For a given function f(t) = cos(at + b) + sin(ct) sin(dt), evaluate its Taylor
expression with the function taylor() and convert the results in LATEX.
Solution A full description on Taylor series expansion will be given in Section 3.4. Here
the function taylor() can be used straightforwardly to get the results. Applying the function
latex() to the results, the LATEX can be obtained.
>> syms a b c d t;
% declare symbolic variables
f=cos(a*t+b)+sin(c*t)*sin(d*t); % deﬁne the function f(t)
f1=taylor(f,’Order’,5);
% ﬁnd ﬁrst 5 terms in Taylor series
latex(f1)
% can be converted to a LATEX string

24
Scientiﬁc Computing with MATLAB®
The results can be embedded into a LATEX document, and through compilation, the
following results can be obtained
f(t) ≈cos b−at sinb +

−a2 cos b
2
+cd

t2 + a3 sin b
6
t3 +
a4 cos b
24
−cd3
6 −c3d
6

t4.
Unfortunately, there are no directly usable converters to other word processing programs
such as Microsoft Word.
2.2.5
Basic number theory computations
Basic data transformation and number theory functions are provided in MATLAB, as
shown in Table 2.1. The following examples are used to illustrate the functions. Through
the example, the readers can observe the results.
TABLE 2.1: Functions for data transformations.
function
syntax
function description
floor()
n = floor(x)
round towards −∞for each value in variable x, mathematically denoted
as n = ⌊x⌋
ceil()
n = ceil(x)
round towards +∞for x, mathematically denoted as n = ⌈x⌉
round()
n = round(x)
round to nearest integer for x
fix()
n = fix(x)
round towards zero for variable x
rat()
[n,d] = rat(x)
ﬁnd rational approximation for variable x, and the numerator and
denominator are returned respectively in n and d
rem()
B = rem(A,C)
ﬁnd the remainder after division to variable A
gcd()
k = gcd(n,m)
compute the greatest common divisor for n and m
lcm()
k = lcm(n,m)
compute the least common multiple for n and m
factor()
f = factor(n)
prime factorization
perms()
V = perms(v)
for vector v, list all the permutations of its elements to construct matrix
V . Limitations: maximum length of v is 10.
isprime()
v1 = isprime(v)
check whether each component in v is prime or not. Set those values in v1
to 1 for prime numbers, otherwise, set to 0
primes()
v = primes(n)
ﬁnd all the prime numbers less than n and return in vector v
Example 2.10
For a given data set −0.2765, 0.5772, 1.4597, 2.1091, 1.191, −1.6187, ob-
serve the integers obtained using diﬀerent rounding functions.
Solution The following statements can be used to round the original vector
>> A=[-0.2765,0.5772,1.4597,2.1091,1.191,-1.6187];
v1=floor(A), v2=ceil(A) % round towards −∞and +∞respectively
v3=round(A), v4=fix(A)
% round towards 0 and nearest integers
and the integer vectors obtained are v1 = [−1, 0, 1, 2, 1, −2], v2 = [0, 1, 2, 3, 2, −1], v3 =
[0, 1, 1, 2, 1, −2], v4 = [0, 0, 1, 2, 1, −1].
Example 2.11
Assume that a 3 × 3 Hilbert matrix can be speciﬁed with the statement
A = hilb(3), perform the rational transformation.
Solution The following statements can be used to ﬁnd the rational approximation

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
25
>> A=hilb(3); [n,d]=rat(A) % extract the numerator and denominator matrices
and the integer matrices obtained are n =
⎡
⎣
1
1
1
1
1
1
1
1
1
⎤
⎦, d =
⎡
⎣
1
2
3
2
3
4
3
4
5
⎤
⎦.
Example 2.12
Find the greatest common divisor and least common multiple to the
numbers 1856120 and 1483720, and ﬁnd the prime factorization to the least common
multiplier obtained.
Solution Since the values are very large, one should not use the double-precision represen-
tations. The symbolic representations must be used instead. The following statements can
be used
>> m=sym(1856120); n=sym(1483720); gcd(m,n), lcm(m,n), factor(lcm(n,m))
which yield the greatest common divisor of 1960 and the least common multiple of
1405082840, whose prime factorization is (2)3(5)(7)2(757)(947), while in new versions of
MATLAB, the factor() function returns a vector [2, 2, 2, 5, 7, 7, 757, 947].
Here the functions gcd() and lcm() can only be used to deal with two variables. If more
than two variables are expected, nested calls are allowed such that gcd(gcd(m,n),k).
Example 2.13
List all the prime numbers in the interval [1, 1000].
Solution
The prime numbers can easily be recognized by the function isprime(A). All
the prime numbers less than 1000 can be extracted and stored in vector b. Alternatively, a
simpler command b = primes(1000) can be used.
>> a=1:1000; b=a(isprime(a))
% extract all the prime numbers
Example 2.14
There are 5 persons to arrange to take group photographs. The persons
are labeled 1 to 5. Please list all the possibilities of their locations.
Solution This is a typical permutation problem, since we are not only interested in how
many permutations, but also interested in what are all the possible permutations. The
following commands can be issued, and all the permutations are returned in matrix P ,
whose size is 120 × 5, where 120 = 5!.
>> P=perms(1:5), size(P)
% ﬁnd the number of permutations
If the persons are labeled as ’a’∼’e’, the command P = perms(’abcde’) can be used
instead, and again 120 permutations are represented in string matrix P .
2.3
Flow Control Structures of MATLAB Language
As a programming language, the loop structures, conditional control structures, switch
structures and trial structures are provided in MATLAB. These structures are illustrated
in this section.

26
Scientiﬁc Computing with MATLAB®
2.3.1
Loop control structures
The loop structures can be introduced by the keywords for or while, and ended with
the end command. The two kinds of loop structures are shown in Figures 2.1 (a) and (b),
respectively.
(i) The for loop structures
The syntax of the structure is
for i = v, loop statements body, end
When using the for loop structure, a component in vector v is extracted and assigned
to variable i each time, the loop statements body can be executed. Then, the control goes
back to the for statement again to extract the next component in vector v. This process
goes on and on, until all the components in v are used.
extract from vector v
execute the
loop body
all values in
v chosen?
?
?
?
?
-
Yes
No
(a) for loop structure
conditions satisﬁed?
all values in
v chosen?
/
?
-
U
Yes
No
(b) while loop structure
FIGURE 2.1: Illustration of loop structures.
If v is a matrix, then, each time a column of v is extracted to assign to the variable
i, and the loop statements body is executed. This process goes on, until all the columns in
matrix v are extracted.
(ii) The while loop structures
The syntax of the structure is
while (condition), loop statements body, end
The condition expression is crucial in the while loop structure. If it is true, the loop
statements body is executed, and the control returns back to the while command to
evaluated condition again. The loop structure will be executed again and again, until
condition becomes false.
There are diﬀerences between the two functions. Examples will be given below to show
the advantages and disadvantages of these structures.
Example 2.15
Compute the sum of S =
100

i=1
i using loop structures.
Solution The for and while loop structures can be used with the following statements,
and the same results can be obtained
>> s1=0; for i=1:100, s1=s1+i; end
s2=0; i=1; while (i<=100), s2=s2+i; i=i+1; end; s1, s2
where it can be seen that the for loop structure is simpler. In fact, the simplest statement

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
27
for this problem is sum(1:100). In the function call, the built-in function sum() can be used
to solve the problem.
Example 2.16
Find the minimum value of m such that S =
m

i=1
i > 10000.
Solution It can be seen that it is not possible to solve such a problem with the for loop
structure. However, the structure of while can be used easily to ﬁnd m
>> s=0; m=0; % set counter m and accumulate variable s to zeros
while (s<=10000), m=m+1; s=s+m; end, [s,m] % the value of m is expected
with m = 141 and the sum is s = 10011.
The loop statements can be used in nested format. The statement break can be used to
terminate the loop structure of the current level.
Example 2.17
Evaluate numerically the sum of the series S =
100000

i=1
 1
2i + 1
3i

.
Solution The execution time can be measured with the statements tic and toc. The time
needed in vectorization is about 0.052 seconds, and the one needed in loops is 0.192 seconds.
Therefore, the vectorization method is normally faster.
>> tic, s=0; for i=1:100000, s=s+1/2^i+1/3^i; end; toc
tic, i=1:100000; s=sum(1./2.^i+1./3.^i); toc % vectorized method
In order to demonstrate the performance of vectorization, the number of terms is
exaggerated. Normally 20∼30 terms are suﬃcient for the exact solutions. The performance
of loops was signiﬁcantly speeded up in new versions of MATLAB.
The speed of loop is slightly slower, even in new versions of MATLAB, compared
with other programming languages. Therefore, the loops may be avoided, and vectorized
programming techniques are recommended.
2.3.2
Conditional control structures
Conditional control structures are the most widely used control structures in actual
programming. The simplest if structure is
if condition, statements, end
In the structure, if the condition is satisﬁed, the statements will be executed, otherwise,
the statements are bypassed. The control then returns to the point after end.
Complicated if structures with else and elseif branches are also supported. The
structures can be shown in Figure 2.2.
if (condition 1) % If condition 1 is satisﬁed, statement group 1 is executed
statement group 1 % other sub-level if can be nested
statement group 1 % other sub-level if can be nested
elseif (condition 2) % Otherwise, if condition 2 is met, group 2 executed
statement group 2
...
...
% more conditional control statements

28
Scientiﬁc Computing with MATLAB®
else
% if none of the above conditions are satisﬁed, deﬁne defaults
statement group n + 1
end
In the structure, the condition 1 is assessed ﬁrst. If it is true, statement group 1 is
executed, and then, control is passed to the point after end statement; if condition 1 is not
true, the condition 2 is evaluated, and if it is true, statement group 2 is executed, then,
control is passed to end; if none of the listed conditions are satisﬁed, statement group n + 1
after else is executed.
condition 1
condition 2
condition n
?
?
?
?
?
?
-
?
......
?
?
?
?
?
Yes
Yes
Yes
No
No
No
group 1
group 2
group n
group n + 1
FIGURE 2.2: Illustrations of conditional control structures.
Example 2.18
Solve the problem in Example 2.16 again using the combinations of for
and if structures.
Solution It has been shown in Example 2.16 that the for loop structure is not suitable for
ﬁnding the minimum m such that the sum is greater than 10000. The for loop can be used
with if structure to solve the problem.
>> s=0; for i=1:10000, s=s+i; if s>10000, break; end, end, s
The break command is used to terminate current loop. Therefore, the structure of the
program is more complicated than that of the while structure.
2.3.3
Switch structure
The switch structure is illustrated in Figure 2.3, with the structure
switch switch expression
case expression 1, statements 1
case {expression 2, expression 3,· · · , expression m}, statements 2
...

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
29
otherwise, statements n
end
· · ·
· · ·
?
equals to
?
?
?
?
?
?
?
?
?
?
?
?
?
?
equals to
equals to
equals to
· · ·
· · ·
expression 1
switch expression
group 1
expression 2
expression 3
...
expression m
group 2
otherwise
group n
FIGURE 2.3: Illustrations of switch structures.
where the crucial part in switch structure is the evaluation of switch expressions. If it matches
a value in a case statement, the statements after the case statement should be executed.
Once completed, the switch structure is terminated.
There exist diﬀerences between the switch statements in MATLAB and in C languages.
The following tips should be noted in programming with MATLAB:
(i) When the value of the switch expression equals expression 1, the statement group
1 should be executed. After execution, the structure is completed. There is no need to
introduce a break statement before the next case.
(ii) If one is checking whether one of several expressions is satisﬁed, the expressions must
be given in cell format.
(iii) If none of the expressions are satisﬁed, the paragraph in otherwise should be
executed. It is similar to the default statement in C language.
(iv) The execution results are independent of the orders of the case statement. When
there exist two or more case statements having the same expressions, those listed behind
may never be executed.
2.3.4
Trial structure
A trial structure is provided in MATLAB, whose syntax is
try,
statement group 1, catch,
statement group 2, end
Normally, only the statement group 1 is executed. However, if an error occurs during
execution of any of the statements, the error is captured into lasterr, and the statement
group 2 is executed. The trial structure is useful in practical programming.

30
Scientiﬁc Computing with MATLAB®
2.4
Writing and Debugging MATLAB Functions
Two types of source programs are supported in MATLAB, both in ASCII format. One of
the codes is the M-script program, which is a series of MATLAB statements to be evaluated
in sequence, just as the batch ﬁles in DOS. The execution of this type of program is simple,
one can simply key in the ﬁle name under the >> prompt. M-scripts process the data in
MATLAB workspace, and the results are returned back to MATLAB workspace. M-scripts
are suitable for dealing with small-scale computations.
Example 2.19
Consider again the problem in Example 2.16. The program can be used
to ﬁnd the smallest m such that the summation is greater than 10000. If one wants to
ﬁnd such m’s for the summation greater than 20000 or 30000, the original program should
be modiﬁed. This method is quite complicated and inconvenient. If a mechanism can be
established such that the user may deﬁne 20000 or 30000 externally, without modifying
the original program, the mechanism is quite reasonable. This kind of mechanism is often
referred to as the function.
M-function is the major structure in MATLAB programming. In practical programming,
M-script programming is not recommended. In this section, MATLAB functions and some
tricks in programming are given.
2.4.1
Basic structure of MATLAB functions
MATLAB functions are led by the statement function, whose fundamental structure is
function [return argument list] = funname(input argument list)
comments led by % sign
input and output variables check
main body of the function
The actual numbers of input and returned arguments can be extracted respectively by
nargin and nargout. In the function call, the two variables are generated automatically.
If more than one input or returned argument is needed, they should be separated with
commas in the lists. The comments led by % will not be executed. The messages in the
leading comments can be displayed by the help command.
From the system view points, the MATLAB functions can be regarded as a variable
processing unit, which receives variables from the calling function. Once the variables are
processed, the results will be returned back to the calling function. Apart from the input and
returned arguments, the other variables within the function are local variables, which vanish
after function calls. Examples will be given to demonstrate the programming techniques.
Example 2.20
Rewrite the M-script in Example 2.19 in M-function.
Solution Consider the requests in Example 2.19. One may choose the input argument as
k, and returned arguments of m and s, where s is the sum of ﬁrst m terms. The function
can then be written as
function [m,s]=findsum(k) % function framework
s=0; m=0; while (s<=k), m=m+1; s=s+m; end

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
31
The previous function can be saved in a ﬁle findsum.m. One can then call such a function
for diﬀerent values of k, without modifying the function. For instance, if the targeted sum is
145323, the following statements can be used to ﬁnd the smallest value of m, which returns
m = 539, s1 = 145530.
>> [m1,s1]=findsum(145323) % ﬁnd the terms make the sum larger than 145323
It can be seen that the calling format is quite ﬂexible, and we may ﬁnd the needed
results without modifying the original program. Thus, this kind of method is recommended
in programming.
Example 2.21 Assume that a MATLAB function is needed in obtaining an n×m Hilbert
matrix, whose (i, j)th element is hi,j = 1/(i + j −1). The following additional requests are
also to be implemented:
(i) If only one input argument n is given in the calling command, a square matrix should
be generated, such that m = n.
(ii) Certain help information to this function is required.
(iii) Check the formats of input and returned arguments.
Solution
In actual programming, it is better to write adequate comments, which are
beneﬁcial to the programmer as well as to the maintainer of the program. The required
MATLAB function myhilb() can be written and stored as myhilb.m in the default MATLAB
search path.
function A=myhilb(n,m)
%MYHILB
is used to generate a rectangular Hilbert matrix
%
A=MYHILB(N,M) generates an NxM Hilbert matrix A
%
A=MYHILB(N) generates an NxN square Hilbert matrix A
%See also: HILB % the blank line below is deliberately used
%
Designed by Professor Dingyu XUE, Northeastern University, PRC
%
5 April, 1995, Last modified by DYX at 30 July, 2001
if nargout>1, error(’Too many output arguments.’); end
if nargin==1, m=n; % if one input argument used, generate square matrix
elseif nargin==0 | nargin>2, % check the number of input arguments
error(’Wrong number of input arguments.’); % display error message
end
for i=1:n, for j=1:m, A(i,j)=1/(i+j-1); end, end % Hilbert matrix
In the program, the comments are led by the % sign. To implement the requirement in
item (i), one should check whether the number of input argument is 1, i.e., whether nargin
is 1. If so, the column number m is set to n, the row number, thus, a square matrix can be
generated. If the numbers of input or returned arguments are not correct, the error messages
can be given. The double for loops will generate the required Hilbert matrix.
The on-line help command help myhilb will display the following information
MYHILB
The function is used to illustrate MATLAB functions.
A=MYHILB(N, M) generates an NxM Hilbert matrix A;
A=MYHILB(N) generates an NxN square Hilbert matrix A;
See also: HILB.

32
Scientiﬁc Computing with MATLAB®
It should be noted that only the ﬁrst few lines of information are displayed, while the
author information is not displayed. This is because there is a blank line before the author
information.
The following commands can be used to generate Hilbert matrices
>> A1=myhilb(4,3)
% two input arguments yield a rectangular matrix
A2=myhilb(4)
% while one input argument yields a square matrix
and the two matrices can then be established as
A1 =
⎡
⎢⎢⎣
1
0.5
0.33333
0.5
0.33333
0.25
0.33333
0.25
0.2
0.25
0.2
0.16667
⎤
⎥⎥⎦, A2 =
⎡
⎢⎢⎣
1
0.5
0.33333
0.25
0.5
0.33333
0.25
0.2
0.33333
0.25
0.2
0.16667
0.25
0.2
0.16667
0.14286
⎤
⎥⎥⎦.
There is in fact a bug in the function, since symbolic Hilbert matrix is not supported due
to the use of the for loop. The command such as H = myhilb(sym(3),7) cannot be used.
To solve the problem, the last code line should be replaced by
[i,j]=meshgrid(1:m,1:n); A=1./(j+i-1); % supporting symbolic arguments
Example 2.22
MATLAB functions can be called recursively, i.e., a function may call
itself. Please write a recursive function to evaluate the factorial n!.
Solution Consider the factorial n!. From the deﬁnition n! = n(n −1)!, it can be seen that
the factorial of n can be evaluated from the factorial of n −1, while n −1 can be evaluated
from n −2, and so on. The exits of the function call should be 1! = 0! = 1. Therefore, the
recursive function can be written as follows, with the comments omitted.
function k=my_fact(n) % recursive function to compute factorial
if nargin~=1, error(’Error: Only one input variable accepted’); end
if fix(n)~=n | n<0 % check whether n is a non-negative integer
error(’n should be a non-negative integer’); % if not, error message
end
if n>1, k=n*my_fact(n-1);
% if n > 1, evaluate recursively
elseif any([0 1]==n), k=1; end % if 0! = 1! = 1, assign the exits
In the function, isinteger(n) cannot be used to check whether n is an integer or not,
it is only applicable to check whether n is an integer data type or not. Some other functions
started with is are, ischar, isreal, isfinite(), they are useful in actual programming
activities.
It can be seen that, in the function, the judgement whether n is a non-negative integer is
made. If not, an error message will be declared. If it is, the recursive function calls will be
used such that when n = 1 or 0, the result is 1, which can be used as an exit to the function.
For instance, 11! can be evaluated with my fact(11), and the result obtained is 39916800.
In fact, the factorial for any non-negative integer can be evaluated directly with function
factorial(n), and the kernel of such a function is prod(1:n). Also, gamma(n + 1) can
be used. If n is substituted by sym(n), an analytical solution can be found. For instance,
factorial(sym(500)) returns the exact value of 500!, with all the 1134 decimal digits.
Example 2.23
Compare the advantages and disadvantages of a recursive algorithm with
loop structure in constructing the Fibonacci arrays.
Solution
It is for sure that the recursive algorithm is an eﬀective method for a class

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
33
of problems. However, this method should not be misused. A counter-example is shown in
this example. Consider the Fibonacci array, where a1 = a2 = 1, and the kth term can be
evaluated from ak = ak−1 + ak−2 for k = 3, 4, · · ·. A MATLAB function can be written for
the problem
function a=my_fibo(k) % recursive function to generate Fibonacci sequence
if k==1 | k==2, a=1; else, a=my_fibo(k-1)+my_fibo(k-2); end
and for k = 1, 2, the exit can be made such that it returns 1. If the 25th term is expected,
the following statements can be used, and the time required is 7.6 seconds.
>> tic, my_fibo(25), toc % never try more terms with recursive form
If one is expecting the term k = 30, several hours of time might be required. If the loop
structure is used, within 0.02 second, the whole array can be obtained for k = 100.
>> tic, a=[1,1]; for k=3:100, a(k)=a(k-1)+a(k-2); end, toc
It can be seen that the ordinary loop structure only requires a very short execution time.
Thus, the recursive function call should not be misused. Further observations show that since
the values of the terms are too large, the above statements under double-precision scheme
may not yield accurate results, symbolic data types should be used instead. For instance, if
the ﬁrst statement a = [1 1] is replaced by a = sym([1 1]), an accurate sequence can be
constructed, and a100 = 354224848179261915075.
2.4.2
Programming of functions with variable numbers of arguments in
inputs and outputs
In the following presentation, the variable number of input and returned arguments is
introduced based on the cell data type. It should be mentioned that most of the MATLAB
functions are implemented in this format.
Example 2.24
The product of two polynomials can be evaluated from the conv()
function, based on the algorithm of ﬁnding the convolution of two arrays. Write a function
to evaluate directly the multiplications of an arbitrary number of polynomials.
Solution Cell data type can be used to write the function convs(), which can be used to
evaluate the multiplication of an arbitrary number of polynomials.
function a=convs(varargin) % with arbitrary number of input arguments
a=1; for i=1:nargin, a=conv(a,varargin{i}); end % use loop structure
The input argument list is passed to the function through the cell variable varargin.
Consequently, the returned arguments can be speciﬁed in varargout, if necessary. Under
such a function, the multiplication of an arbitrary number of polynomials can be obtained.
The following statements can be used to call the function
>> P=[1 2 4 0 5]; Q=[1 2]; F=[1 2 3]; D=convs(P,Q,F) % multiply polynomials
E=conv(conv(P,Q),F)
% nested calls are to be used with conv() function
G=convs(P,Q,F,[1,1],[1,3],[1,1])
% direct use of convs()
where the obtained vectors are respectively
E = [1, 6, 19, 36, 45, 44, 35, 30]T, G = [1, 11, 56, 176, 376, 578, 678, 648, 527, 315, 90]T.

34
Scientiﬁc Computing with MATLAB®
2.4.3
Inline functions and anonymous functions
In order to describe simply the mathematics functions, inline functions can be
used. The functions are equivalent to the M-functions. However, with inline func-
tion, it may no longer be necessary to save ﬁles. The format of inline function is
fun = inline(function expression,list of variables), where the function expression is the
actual contents of the function to be expressed, and the list of variables contains all the
input variables, with each variable given as a string. The inline function is useful in the
descriptions in diﬀerential equations and objective functions given later. The function type
accepts only one returned variable. The mathematical function f(x, y) = sin(x2 + y2) can
be expressed as f = inline(’sin(x.^2+y.^2)’,’x’,’y’).
Anonymous function is a better type of function deﬁnition, the structure of the function
is similar to the inline function, but it is more concise and easy to use. The syntax of the
function is
f = @(list of variables)function contents, e.g., f = @(x,y)sin(x.^2+y.^2)
Note that the variable currently existing in MATLAB workspace can be used directly
in the function. For instance, the variables a and b in MATLAB workspace can be used in
the anonymous function f = @(x,y)a*x.^2+b*y.^2 to describe the mathematical function
f(x, y) = ax2 +by2. If such a function has been deﬁned, while the variables a, b change after
that, the values of those in the anonymous function will not change, unless it is deﬁned
again.
2.4.4
Pseudo code and source code protection
The aim of introducing pseudo code in MATLAB is two-fold. One of the aims is to
increase the speed of code, since with pseudo code technique, MATLAB code can be
converted to some extent executable code, and the conversion is no longer needed, such
that the total execution time is reduced. The other aim is to convert ASCII MATLAB
source code into binary code, so that other users can execute normally the code, but are
unable to read the source code, so as to protect the source code.
The pcode command provided in MATLAB can be used to do the conversion, and the
suﬃx of the converted ﬁles is .p. If one wants to convert a MATLAB function mytest.m to
P code, the command to use is pcode mytest; if one wants the generated P code located
in the same folder of the M code, the command pcode mytest -inplace can be used; if
one wants to convert the .m ﬁles in a whole folder into P code, he can enter the folder with
cd command, then, type the command pcode *.m. If there is no error in the source code,
all the ﬁles can be converted, otherwise, the conversion will be aborted, and error messages
will be displayed. The programmer can also use this method to check whether his source
code has syntax errors or not. If both .m and .p exist in the same folder, the .p ﬁle has more
advantage in execution.
Please note that, the user must save his original.m ﬁles in safe places. Make sure that
the source ﬁles are not deleted, otherwise, they cannot be recovered from the .p code.

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
35
2.5
Two-dimensional Graphics
Graphics and visualization are the most signiﬁcant advantages of MATLAB. A series
of straightforward and simple functions are provided in MATLAB for two-dimensional and
three-dimensional graphics. Experimental and simulation results can be easily interpreted
in graphical form. In this section, the two-dimensional graphics functions will be illustrated.
2.5.1
Basic statements of two-dimensional plotting
Assume that a sequence of experimental data is acquired. For instance, at time instances
t = t1, t2, · · · , tn, the function values are y = y1, y2, · · · , yn. The data can be entered to
MATLAB workspace such that t = [t1, t2, · · · , tn] and y = [y1, y2, · · · , yn]. The command
plot(t,y) can be used to draw the curve for the data. The “curve” is in fact represented
by poly-lines, joining the sample points.
It can be seen that the syntax of the function is quite straightforward. In actual
applications, the plot() function can alternatively be called in other extended ways.
(i) t is still a vector, and y can be expressed by a matrix such that
y =
⎡
⎢⎢⎢⎣
y11
y12
· · ·
y1n
y21
y22
· · ·
y2n
...
...
...
...
ym1
ym2
· · ·
ymn
⎤
⎥⎥⎥⎦.
The same function can also be used to draw m curves, with each row of matrix y
corresponding to a curve.
(ii) t and y are both matrices, and the sizes of the two matrices are the same. The plots
between each row of t and y can be drawn.
(iii) Assume that there are many pairs of such vectors or matrices, (t1, y1), (t2, y2), · · · ,
(tm, ym), the following statement can be used directly to draw the corresponding curves.
plot(t1,y1,t2,y2,· · · ,tm,ym)
(iv) The line types, line width and color information of the curves can separately be
speciﬁed with the command
plot(t1,y1,option 1,t2,y2,option 2,· · · ,tm,ym,option m)
where the available options are shown in Table 2.2. The combinations of the options are also
allowed. For instance, the combination ’r-.pentagram’ indicates the red dash dot curve,
with the sample points marked by pentagrams.
After the curves are drawn, the command grid on can be used to add grids to the
curves, while the grid off command may remove the grids. Also, hold on command can
reserve the current axis. Other plot() function can be used to superimpose curves on top
of the existing ones. hold off command may remove the holding status.
Example 2.25
Draw the curve of y = sin(tan x) −tan(sin x), x ∈[−π, π].
Solution The curve of f(x) can be drawn easily with the following statements
>> x=[-pi : 0.05: pi];
% specify the vector with a step-size of 0.05
y=sin(tan(x))-tan(sin(x)); % evaluate the function values
plot(x,y)
% draw the curve

36
Scientiﬁc Computing with MATLAB®
TABLE 2.2: Options in MATLAB plotting commands.
line type
line color
markers
opts
meaning
opts
meaning
opts
meaning
opts
meaning
opts
meaning
’-’
solid
’b’
blue
’c’
cyan
’*’
∗
’pentagram’
✩
’--’
dash
’g’
green
’k’
black
’.’
dotted
’o’
⃝
’:’
dotted
’m’
magenta
’r’
red
’x’
×
’square’
□
’-.’
dash-dot
’w’
white
’y’
yellow
’v’
∇
’diamond’
♦
’none’
none
’^’
△
’hexagram’
✡
’>’
▷
’<’
◁
and the curve in Figure 2.4 (a) can be obtained.
−4
−3
−2
−1
0
1
2
3
4
−3
−2
−1
0
1
2
3
(a) with the default step-size of 0.05
−4
−3
−2
−1
0
1
2
3
4
−3
−2
−1
0
1
2
3
(b) improved curve with variable-step-sizes
FIGURE 2.4: Two dimension curve for the given function.
It can be seen from the curve that it is rather sluggish over the intervals x ∈(−1.8, −1.2)
and x ∈(1.2, 1.8), since the step-size 0.05 is too large for these intervals. The step-size for
these intervals should be selected smaller such that
>> x=[-pi:0.05:-1.8,-1.801:.001:-1.2, -1.2:0.05:1.2,...
1.201:0.001:1.8, 1.81:0.05:pi]; % with variable-step-size
y=sin(tan(x))-tan(sin(x));
% evaluate the function
plot(x,y)
% draw the curve
The modiﬁed curve of the function is given in Figure 2.4 (b). It can be seen that the
curve is signiﬁcantly improved in the new plot. Alternatively, for the whole interval, a ﬁxed
step-size of 0.001 can be selected.
Example 2.26
Please draw the saturation function y =

1.1sign(x),
|x| > 1.1
x,
|x| ⩽1.1.
Solution It is obvious that one can create a vector of x, then, for each point, construct
an if clause to calculate the value of y. An alternative way is to use vectorized format to
evaluate the function values. With the following statements, the segmented function can be
drawn as shown in Figure 2.5.

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
37
>> x=[-2:0.02:2];
%
generate an x vector with increment of 0.02
y=1.1*sign(x).*(abs(x)>1.1)+x.*(abs(x)<=1.1); plot(x,y)
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
−1.5
−1
−0.5
0
0.5
1
1.5
FIGURE 2.5: Segmented saturation function.
Even more simply, the command plot([−3,−1.1,1.1,3],[−1.1,−1.1,1.1,1.1]) can be
used to draw the saturation poly-lines.
In MATLAB graphics, each curve or the axis is an object, and the window is another
object. The properties of the objects can be assigned by set() function, or extracted by
get() function. The syntaxes of the functions are
set(handle,’prop name 1’,prop value 1,’prop name 2’,prop value 2,· · · )
v = get(object,prop name’)
where prop name and prop value are respectively the names and values of the corresponding
properties. These two functions are very useful in graphical user interface programming.
2.5.2
Plotting with multiple horizontal or vertical axes
Suppose that we have two set of data, and the diﬀerences in the magnitude of them
are huge, the readability of the one with smaller magnitude will be very poor, if they are
plotted together with the same plot() function. In this case, the plotyy() function should
be used, to have diﬀerent y scales in the same plot, as will be demonstrated through the
following example.
Example 2.27
Please draw together the two functions y1 = sin x, y2 = 0.01 cosx.
Solution The two curves can be drawn together with the following statements, as shown
in Figure 2.6(a). Since there are huge diﬀerences in magnitude, the curve of y2 can hardly
be read. Thus, the direct plotting is not suitable for this example.
>> x=0:0.01:2*pi; y1=sin(x); y2=0.01*cos(x); plot(x,y1,x,y2,’--’)
The function plotyy() can be used instead to draw the plots with two y axes, as shown
in Figure 2.6(b).
>> plotyy(x,y1,x,y2)
% draw curves in two y axes

38
Scientiﬁc Computing with MATLAB®
0
1
2
3
4
5
6
−1
−0.5
0
0.5
1
(a) improper plots
0
1
2
3
4
5
6
7
−1
−0.5
0
0.5
1
0
1
2
3
4
5
6
7
−0.01
−0.005
0
0.005
0.01
(b) plots with two y axes
FIGURE 2.6: Plots of two curves with signiﬁcant magnitude diﬀerences.
In some particular applications, three or even four vertical axes might be needed.
This can be done by downloading the ﬁles plotyyy() [1], plot4y() [2] and others from
MathWorks’ File Exchange. The function plotxx() can also be used to draw plots with
two horizontal axes [3].
2.5.3
Other two-dimensional plotting functions
Apart from the standard Descartes coordinate curves, MATLAB also provides other
special two-dimensional graphical functions, and the common syntaxes of the functions are
given in Table 2.3. In the functions, parameters x,y are respectively the horizontal and
vertical axis data, and c the color options. The parameters ym,yM are the vectors of lower-
and upper-boundaries in error plots. The functions are demonstrated through the following
examples.
TABLE 2.3: Other two-dimensional plotting functions.
general syntax
explanation
general syntax
explanation
bar(x,y)
two-dimensional bar chart
comet(x,y)
comet trajectory
compass(x,y)
compass plot
errorbar(x,y,ym,yM)
errorbar plot
feather(x,y)
feather plot
fill(x,y,c)
ﬁlled plot
hist(y,n)
histogram
loglog(x,y)
logarithmic plot
polar(x,y)
polar plot
quiver(x,y)
quiver graph
stairs(x,y)
stairs plot
stem(x,y)
stem plot
semilogx(x,y)
x-semi-logarithmic plot
semilogy(x,y)
y-semi-logarithmic plot
Example 2.28
Draw the polar plots for the function ρ = 5 sin(4θ/3).
Solution
A vector θ can be constructed ﬁrst, over the interval θ ∈(0, 2π), then, the
function value vector ρ can be calculated. With the polar() function, the polar plot can be
drawn as shown in Figure 2.7 (a).
>> theta=0:0.01:2*pi; rho=5*sin(4*theta/3); polar(theta,rho)
It seems that the polar plot thus obtained is incomplete, since the interval is selected too

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
39
  1
  2
  3
  4
  5
30
210
60
240
90
270
120
300
150
330
180
0
(a) (0, 2π) interval
  1
  2
  3
  4
  5
30
210
60
240
90
270
120
300
150
330
(b) (0, 6π) interval
FIGURE 2.7: Polar plots.
small. To have a complete polar plot, the interval must be selected, at least, as (0, 6π), where
6π is the period of the polar function. The complete polar plot is shown in Figure 2.7 (b).
If it is diﬃcult to ﬁnd the exact period, just select a large number, e.g., 100π.
Example 2.29 Draw the sinusoidal curve with diﬀerent functions in diﬀerent areas of the
graphics window.
Solution The following commands can be used to draw the expected curves as shown in
Figure 2.8, where function subplot(n,m,k) can be used to divide the graphics window into
several parts, with n, m, respectively the total numbers of rows and columns, and k indicates
the serial of the area.
>> t=0:.2:2*pi; y=sin(t);
% generate the data for plots
subplot(2,2,1), stairs(t,y)
% partition the graphics window
subplot(2,2,2), stem(t,y)
% stem plot in upper-right portion
subplot(2,2,3), bar(t,y)
% bar chart in lower-left portion
subplot(2,2,4), semilogx(t,y) % semilogx in lower-right portion
2.5.4
Plots of implicit functions
For an implicit function f(x, y) = 0, the relationship between x and y cannot be explicitly
formulated. Therefore, the conventional plot() function cannot be used. The MATLAB
function ezplot() can be used to draw the implicit function curve, with default range of
[−2π, 2π]
ezplot(implicit function expression,range)
The implicit function expression can be a string, a symbolic expression or an anonymous
function. In the former two cases, the variables x, y can be regarded as symbols, thus, dot
operation is not necessary.
Example 2.30
Draw the curve of the implicit function
f(x, y) = x2 sin(x + y2) + y2ex+y + 5 cos(x2 + y) = 0.

40
Scientiﬁc Computing with MATLAB®
0
2
4
6
8
−1
−0.5
0
0.5
1
0
2
4
6
8
−1
−0.5
0
0.5
1
(a) stairs() function
(b) stem() function
0
1
2
3
4
5
6
−1
−0.5
0
0.5
1
10
0
−1
−0.5
0
0.5
1
(c) bar() function
(d) semilogx() function
FIGURE 2.8: Diﬀerent representations of the same function.
Solution From the given function, it can be seen that the analytical explicit solution of x-y
relationship cannot be found. Thus, the plot() function cannot be used for such a function.
The following MATLAB statements can be used to draw the implicit function as shown in
Figure 2.9 (a).
>> ezplot(’x^2*sin(x+y^2)+y^2*exp(x+y)+5*cos(x^2+y)’) % implicit function
The expression of the implicit function can also be expressed by a symbolic expression,
and the same plots can be obtained
>> syms x y; f=x^2*sin(x+y^2)+y^2*exp(x+y)+5*cos(x^2+y); ezplot(f)
Alternatively, anonymous functions can be used to describe the implicit functions,
however, dot operations can be used to speed up the function evaluation process.
>> f=@(x,y)x.^2.*sin(x+y.^2)+y.^2.*exp(x+y)+5*cos(x.^2+y); ezplot(f)
The above functions selected automatically the ranges of x, y ∈(−2π, 2π). The ranges
can be speciﬁed to (−10, 10) with the following statements, with the new implicit curve shown
in Figure 2.9 (b).
>> ezplot(’x^2*sin(x+y^2)+y^2*exp(x+y)+5*cos(x^2+y)’,[-10 10])
2.5.5
Graphics decorations
The graphics window with editing tools is shown in Figure 2.10, by clicking the
button
in the toolbar. The user may choose to apply text and arrows to the plots.
In the graphics editing interface, there are three parts, with the left part corresponding
to the View →Figure Palette menu item, where arrows and text can be added to the curve.
2D and 3D axes can also be added to the curve. The bottom part of the window corresponds

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
41
−6
−4
−2
0
2
4
6
−6
−4
−2
0
2
4
6
(a) default curves
−10
−5
0
5
10
−10
−5
0
5
10
(b) curves within larger area
FIGURE 2.9: Curves of implicit functions.
FIGURE 2.10: MATLAB graphics window with editing tools.
to the Property Editor menu item, which allows the selections of color, line styles or fonts to
the selected objects. The right part of the window corresponds to the View →Plot Browser
menu item, which allows the user to add new data or superimpose new curves.
Select the menu item View →Plot Edit Toolbar, an extra toolbar with be added to the
ﬁgure window, as shown in Figure 2.11, also allowing to manipulate text and arrow objects
on graphs.
Local zooming and 3D view point settings are also provided in the plots. The button
in the toolbar can be used to read coordinate information of points on curves or surfaces,
with simple mouse clicking. The icon
can be used to change viewpoint of 3D plots. An

42
Scientiﬁc Computing with MATLAB®
6
plotting
tools
6
text font
settings
6
text object
allignment
6
arrow & text
drawing tools
6
draw
shapes
6
object
allignment
FIGURE 2.11: Figure editing toolbar.
example of a typical graphics display under the view-point change is shown in Figure 2.12,
where a 2D curve is displayed under a 3D framework.
−5
0
5
−1
−0.5
0
0.5
1
−1
0
1
X: −3.3444
Y: 0.20145
FIGURE 2.12: 3D representations of 2D curves.
A subset of LATEX commands can be used to add mathematical formulas to the plots.
LATEX is a well established scientiﬁc type-setting system, and a subset of its mathematical
symbols are supported in MATLAB. One may use them to superimpose formulas to the
plots.
(i) The symbols are led by the backslash signs \, and the available symbols are listed in
Table 2.4.
(ii) Superscripts and subscripts are represented by ^ and , respectively. For instance,
a 2^2+b 2^2=c 2^2 represents a2
2 + b2
2 = c2
2. If more than one symbol is used in the
superscript, they should be written within the { and } signs. For instance a^Abc gives
aAbc, while a^{Abc} gives aAbc.
LATEX scientiﬁc type-setting system is widely used in the academic world. Interested
readers may further refer to Reference [4].
2.5.6
Data ﬁle access with MATLAB
The command pair save and load can be used to access data ﬁles. If the save command
is used alone, all the variables in MATLAB workspace will be saved to the ﬁle matlab.mat,
in binary format. The contents of the binary ﬁles can only be retrieved with load command.
If one wants to save the variables A, B and C into a binary ﬁle mydat.mat, the command
save mydat A B C can be used.
If the three variables are to be saved in the ASCII format into ﬁle mydat.dat, the
command save /ascii mydat.dat A B C should be used instead.

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
43
TABLE 2.4: TEX compatible commands in MATLAB.
c
TEX
c
TEX
c
TEX
c
TEX
α
\alpha
β
\beta
γ
\gamma
δ
\delta
ϵ
\epsilon
ε
\varepsilon
ζ
\zeta
η
\eta
lower-
θ
\theta
ϑ
\vartheta
ι
\iota
κ
\kappa
case
λ
\lambda
μ
\mu
ν
\nu
ξ
\xi
Greeks
o
o
π
\pi
ϖ
\varpi
ρ
\rho
ι
\iota
κ
\kappa
ϱ
\varrho
σ
\sigma
ς
\varsigma
τ
\tau
υ
\upsilon
φ
\phi
ϕ
\varphi
χ
\chi
ψ
\psi
ω
\omega
upper-
Γ
\Gamma
Δ
\Delta
Θ
\Theta
Λ
\Lambda
case
Ξ
\Xi
Π
\Pi
Σ
\Sigma
Υ
\Upsilon
Greeks
Φ
\Phi
Ψ
\Psi
Ω
\Omega
ℵ
\aleph
′
\prime
∀
\forall
∃
\exists
common
℘
\wp
ℜ
\Re
ℑ
\Im
∂
\partial
math
∞
\infty
∇
\nabla
√
\surd
∠
\angle
symbols
¬
\neg

\int
♣
\clubsuit
♦
\diamondsuit
♥
\heartsuit
♠
\spadesuit
binary
±
\pm
·
\cdot
×
\times
÷
\div
math
◦
\circ
•
\bullet
∪
\cup
∩
\cap
symbols
∨
\vee
∧
\wedge
⊗
\otimes
⊕
\oplus
relat-
⩽
\leq
⩾
\geq
≡
\equiv
∼
\sim
ional
⊂
\subset
⊃
\supset
≈
\approx
⊆
\subseteq
math
⊇
\supseteq
∈
\in
∋
\ni
∝
\propto
symbols
|
\mid
⊥
\perp
←
\leftarrow
↑
\uparrow
⇐
\Leftarrow
⇑
\Uparrow
arrows
→
\rightarrow
↓
\downarrow
⇒
\Rightarrow
⇓
\Downarrow
↔
\leftrightarrow
↕
\updownarrow
If long or complicated path or ﬁle names are used, the functions load() should be used,
with X = load(ﬁlename), and a variable X will be loaded into MATLAB workspace.
Microsoft Excel ﬁles are also supported in MATLAB, with the functions xlsread() to
load ﬁle into MATLAB workspace, in the syntax
X = xlsread(ﬁlename,range)
where, the range can be marked as a rectangular region such as ’B5:C67’, meaning that
the data in the Excel ﬁle, from column B to C, and from the 5th row to the 67th, all loaded
into MATLAB workspace to form matrix X. Another function, xlswrite(), can be used
to write variables into Excel ﬁles.
Example 2.31
Suppose in the Excel ﬁle census.xls, the annual population records of a
certain province provided, with column B the years, while column C the population record.

44
Scientiﬁc Computing with MATLAB®
The eﬀective data start from the 5th row and end at row 67. Please load the year information
to vector t and population to vector p.
Solution It can be seen from the above description that the eﬀective data are located in
columns B and C, and from row 5 to row 67, the range speciﬁcation can be represented as
’B5:C67’. Therefore, the following statements can be used to load the year and population
into MATLAB workspace, and then distribute them to the vectors t and p.
>> X=xlsread(’census.xls’,’B5:C67’); t=X(:,1); p=X(:,2); plot(t,p)
2.6
Three-dimensional Graphics
2.6.1
Plotting of three-dimensional curves
The two-dimensional function plot() can be extended to a three-dimensional (3D) curve
drawing with the new plot3() function, whose syntaxes are
plot3(x,y,z)
plot3(x1, y1, z1, option 1, x2, y2, z2, option 2, · · · , xm, ym, zm, option m)
where the options are the same as shown in Table 2.2.
Similar to other 2D curve drawing functions, the functions stem3(), fill3() and bar3()
can also be applied to 3D curves.
Example 2.32
Suppose the position of a particle in 3D space is described by the
parametric equations
x(t) = t3e−t sin 3t, y(t) = t3e−t cos 3t, z = t2,
where t ∈[0, 2π].
Please draw the trajectory of the particle.
Solution A time vector t can be established ﬁrst, then, the vectors x, y, z can be computed.
The 3D curve can be drawn with the plot3() function, as shown in Figure 2.13 (a). It should
be noted that dot operations are used in the evaluations.
>> t=0:.1:2*pi;
% establish the t vector, with dot operation
x=t.^3.*exp(-t).*sin(3*t); y=t.^3.*exp(-t).*cos(3*t); z=t.^2;
plot3(x,y,z), grid
% 3D curve drawing
The stem3() function can be used to obtained the plot in Figure 2.13 (b), superimposed
by the 3D curve.
>> stem3(x,y,z); hold on; plot3(x,y,z), grid
To display the trajectory of the 3D curve, comet3() function is recommended.
Alternatively function ezplot3() can be used to draw 3D curves, and the latter statement
can be used to draw dynamically the trajectory of the 3D curve.
>> syms t; x=t^3*exp(-t)*sin(3*t); y=t^3*exp(-t)*cos(3*t); z=t^2;
ezplot3(x,y,z,[0,2*pi]); figure; ezplot3(x,y,z,[0,2*pi],’animate’);

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
45
−2
−1
0
1
2
−2
0
2
0
10
20
30
40
(a) 3D curve plots
−2
−1
0
1
2
−2
0
2
0
10
20
30
40
(b) superimposed with the plot with stem3()
FIGURE 2.13: Three-dimensional plots.
2.6.2
Plotting of three-dimensional surfaces
If function z = f(x, y) is given, the 3D surface of the function can be drawn. One can
generate mesh grid data in the x-y plane, with the meshgrid() function. The function
values z for each grid can be evaluated. The functions mesh() and surf() can be used to
draw the 3D mesh plots and surface plots. The syntaxes of the functions are
[x,y] = meshgrid(v1, v2)
% mesh grid matrices generation
z = expression, for instance z = x.*y
% z matrix dot computation
surf(x,y,z)
or
mesh(x,y,z)
% mesh and surface plots
where v1 and v2 are the vectors with coordinate grids in the x and y axes, and two matrices
x, y can be generated. Dot operation is involved in the evaluation of the z matrix. The 3D
surface can also be drawn with the surfc(), surfl() and waterfall() functions. Also,
the contour() and contour3() functions can be used to draw 2D and 3D contour plots.
Other simple functions such as ezsurf(), ezmesh(), ezcontour() and ezcontourf()
can also be used to draw 3D plots, with the mathematical explicit expression z = f(x, y)
speciﬁed.
Example 2.33
Consider the function z = f(x, y) = (x2 −2x)e−x2−y2−xy. Select in the
x-y plane an area and draw the 3D plots.
Solution One may use the meshgrid() function to specify the mesh grids on the x-y plane.
The values of the function can be evaluated directly for the matrix z. The mesh plot can be
drawn as shown in Figure 2.14 (a).
>> [x,y]=meshgrid(-3:0.1:3,-2:0.1:2); % generate mesh grid matrices
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y); mesh(x,y,z) % draw mesh plot
If one uses surf() function to replace the mesh() function, the corresponding surface
plot can be obtained as shown in Figure 2.14 (b).
>> surf(x,y,z)
% surface plot
3D surface plots can be decorated by shading command, and the options flat and
interp can be used. The decorations are shown in Figures 2.15 (a) and (b), respectively.
Other functions, such as waterfall(x,y,z) and contour3(x,y,z,30) can be used to
draw 3D plots as shown in Figures 2.16 (a) and (b).

46
Scientiﬁc Computing with MATLAB®
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) mesh() plot
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(b) surf() plot
FIGURE 2.14: Mesh and surface plots of a given function.
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) shading flat
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(b) shading interp
FIGURE 2.15: 3D surfaces decorated by the shading command.
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) waterfall() plots
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(b) contour3() plots
FIGURE 2.16: Other 3D representations.
Example 2.34
Display graphically the surface of the following function
z = f(x, y) =
1

(1 −x)2 + y2 +
1

(1 + x)2 + y2 .

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
47
Solution The following statements can be used to draw the 3D surface of the function, as
shown in Figure 2.17 (a).
>> [x,y]=meshgrid(-2:.1:2); % generate mesh grid data
z=1./(sqrt((1-x).^2+y.^2))+1./(sqrt((1+x).^2+y.^2)); % evaluate function
surf(x,y,z), shading flat % draw surface plot
−2
−1
0
1
2
−2
−1
0
1
2
0
2
4
6
8
10
12
(a) ﬁxed-step-size
−2
−1
0
1
2
−1
−0.5
0
0.5
1
0
5
10
15
(b) variable-step-size
FIGURE 2.17: Three-dimensional surfaces under diﬀerent grids.
In fact, there are problems around the (±1, 0) points, where the function values tend to
inﬁnity. Thus, variable-step-size mesh grids can be constructed, and the new 3D surface can
be obtained as shown in Figure 2.17 (b).
>> xx=[-2:.1:-1.2,-1.1:0.02:-0.9,-0.8:0.1:0.8,0.9:0.02:1.1,1.2:0.1:2];
yy=[-1:0.1:-0.2, -0.1:0.02:0.1, 0.2:.1:1];
[x,y]=meshgrid(xx,yy); % generate a denser mesh grid data
z=1./(sqrt((1-x).^2+y.^2))+1./(sqrt((1+x).^2+y.^2)); % evaluate function
surf(x,y,z), shading flat; zlim([0,15]) % draw surface plot
Example 2.35
Assume that a piecewise function is described below [5]
p(x1, x2) =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
0.5457 exp(−0.75x2
2 −3.75x2
1 −1.5x1),
x1 + x2 > 1
0.7575 exp(−x2
2 −6x2
1),
−1 < x1 + x2 ⩽1
0.5457 exp(−0.75x2
2 −3.75x2
1 + 1.5x1),
x1 + x2 ⩽−1.
Show the function in a three-dimensional surface.
Solution It is obvious that the function value can be evaluated with loops and if statements,
however, the process could be very complicated. Thus, the piecewise function conﬁguration
statements based on relational operations can be used instead to evaluate the functions as
follows
>> [x1,x2]=meshgrid(-1.5:.1:1.5,-2:.1:2); % evaluate piecewise function
z= 0.5457*exp(-0.75*x2.^2-3.75*x1.^2-1.5*x1).*(x1+x2>1)+...
0.7575*exp(-x2.^2-6*x1.^2).*((x1+x2>-1) & (x1+x2<=1))+...
0.5457*exp(-0.75*x2.^2-3.75*x1.^2+1.5*x1).*(x1+x2<=-1);
h=surf(x1,x2,z), xlim([-1.5 1.5]); shading flat % surface plot

48
Scientiﬁc Computing with MATLAB®
−1.5
−1
−0.5
0
0.5
1
1.5
−2
−1
0
1
2
0
0.2
0.4
0.6
0.8
FIGURE 2.18: Surface of a piecewise function with two variables.
and the three-dimensional surface can be shown in Figure 2.18.
It is worth mentioning that all the logic conditions in the piecewise function must be
mutually exclusive to avoid conﬂicts. Also, in the last sentence, the handle h is deliberately
returned. If one wants to remove the surface, a command delete(h) can be given.
2.6.3
Viewpoint settings in 3D graphs
In the MATLAB 3D graphics facilities, viewpoint setting functions are provided, which
allows the user to view the plot from any angle. Two ways are provided: one is the toolbar
facility in the ﬁgure window, and the other is the view() function.
An illustration to the deﬁnition of the viewpoint is given in Figure 2.19 (a), where the
two angles α and β can be used to deﬁne uniquely the viewpoint. The azimuth angle α is
deﬁned as the angle between the projection line in x–y plane with the negative y-axis, with
a default value of α = −37.5◦. The elevation angle β is deﬁned as the angle with the x-y
plane, with a default value of β = 30◦.
y
x
z
azimuth α
elevation β
view point
negative
y-axis
(a) deﬁnition of viewpoints
−1.5
−1
−0.5
0
0.5
1
1.5
−2
−1
0
1
2
0
0.5
1
(b) 3D surface after viewpoint change
FIGURE 2.19: Viewpoint settings of three-dimensional surfaces.
The function view(α,β) can be used to set the viewpoint, where the angles α and β are
the azimuth and elevation angles, respectively. For instance, the setting view(0,90) shows

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
49
the planform, while view(0,0) and view(90,0) show the front view and the side elevation,
respectively.
For instance, one may change the viewpoint in the three-dimensional surface display
shown in Figure 2.18. One may set α = 20◦, and β = 50◦, the following statements can be
used, and the results shown in Figure 2.19 (b) can be obtained.
>> view(20,50), xlim([-1.5 1.5]) % set the range of x-axis
Example 2.36
Consider again the surface plot in Example 2.33. View the surface from
diﬀerent angles.
Solution The surface plots from diﬀerent viewpoints can be obtained using the following
statements, as shown in Figure 2.20.
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
−3
−2
−1
0
1
2
3
−0.5
0
0.5
1
1.5
−2
0
2
−2
0
2
−0.5
0
0.5
1
1.5
FIGURE 2.20: A surface with orthographic views.
>> [x,y]=meshgrid(-3:0.1:3,-2:0.1:2);
% generate mesh grid data
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y);
% evaluate function
subplot(221), surf(x,y,z), view(0,90); % planform
subplot(222), surf(x,y,z), view(90,0); % side elevation
subplot(223), surf(x,y,z), view(0,0);
% front view
subplot(224), surf(x,y,z),
% 3D surface plot
2.6.4
Surface plots of parametric equations
If the 3D function is given by parametric equations
x = fx(u, v), y = fy(u, v), z = fz(u, v),
(2-6-1)
and um
⩽u ⩽uM, vm
⩽v
⩽vM, the 3D surface plot can be obtained with
ezsurf(fx,fy,fz,[um,uM,vm,vM]), with default boundaries of u, v in interval (−2π, 2π).
Example 2.37
The well-known M¨obius strip is mathematically expressed as
x = cos u + v cos u
2 cos u,
y = sin u + v cos u
2 sin u,
z = v sin u
2 ,

50
Scientiﬁc Computing with MATLAB®
with, for instance, 0 ⩽u ⩽2π, −0.5 ⩽v ⩽0.5. Please draw M¨obius strip.
Solution
The variables u and v should be declared ﬁrst as symbolic variables, and the
parametric equations can be speciﬁed, and the M¨obius strip can be obtained with the following
statements, and the rotated version is as shown in Figure 2.21.
>> syms u v; x=cos(u)+v*cos(u/2)*cos(u); y=sin(u)+v*cos(u/2)*sin(u);
z=v*sin(u/2); ezsurf(x,y,z,[0,2*pi,-0.5,0.5])
−1.5
−1
−0.5
0
0.5
1
1.5
−1.5
−1
−0.5
0
0.5
1
1.5
−0.5
0
0.5
FIGURE 2.21: Rotated view of M¨obius strip.
2.6.5
Spheres and cylinders
The data for a unit sphere, centered at the origin, can be generated with the function
[x,y,z] = sphere(n), and such a sphere can be drawn directly with surf(). If there is
no returned argument in the function call, a sphere can be drawn directly. The argument n
can be speciﬁed such that the sphere can have n × n faces.
Example 2.38
Please draw a unit sphere at the original, also on the same coordinates,
draw another sphere with a radius of 0.3 and centered at (0.9, −0.8, 0.6).
Solution The data for the unit sphere can be generated ﬁrst, and based on the data, the
two spheres can be drawn as shown in Figure 2.22 (a).
>> [x,y,z]=sphere(50); surf(x,y,z), hold on % draw the unit sphere ﬁrst
x1=0.3*x+0.9; y1=0.3*y-0.8; z1=0.3*z+0.6; surf(x1,y1,z1) % smaller one
Cylinders in MATLAB are created by rotating a curve around z-axis for 360◦. If the
curve is deﬁned as a vector r, standing for the radius, the data for the cylinder can be
generated with [x,y,z] = cylinder(r,n). If no returned arguments are speciﬁed, the
cylinder can be drawn directly. Please note that the default interval of z is z ∈(0, 1).
Example 2.39
Suppose the radius of the cylinder is r(z) = e−z2/2 sin z, z ∈(−1, 3),
please draw the cylinder.
Solution The radius can be calculated ﬁrst, and the data for the standard cylinder can be
obtained, and it can be mapped from z ∈(0, 1) interval to z ∈(−1, 3), with the following
statements, as shown in Figure 2.22 (b).
>> z0=-1:0.1:3; r=exp(-z0.^2/2).*sin(z0); [x,y,z]=cylinder(r);
z=-1+4*z; surf(x,y,z) % map z axis from (0, 1) to (−1, 4)

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
51
−1
−0.5
0
0.5
1
−2
−1
0
1
−1
−0.5
0
0.5
1
(a) two spheres
−0.4
−0.2
0
0.2
0.4
0.6
−0.4
−0.2
0
0.2
0.4
0.6
−1
−0.5
0
0.5
1
1.5
2
2.5
3
(b) cylinder
FIGURE 2.22: Three-dimensional surfaces.
2.6.6
Drawing 2D and 3D contours
If the mesh grid data x, y, z for explicit function z = f(x, y) are known, the function
contour() can be used to draw 2D contour, with contour(x,y,z,n), where n is the
expected number of contour lines and can be omitted. Alternatively, a pair of functions can
be called
[C,h] = contour(x,y,z,n), clabel(C,h)
where h is the handle of all contour lines, and C returns all the height information, which
can ﬁnally be superimposed on the contours with the last statement.
Functions contourf() and contour3() can be used to draw ﬁlled contour plots and 3D
contours, respectively, with the syntaxes
contourf(x,y,z,n), and
contour3(x,y,z,n)
Example 2.40
Consider the piecewise function used in Example 2.35, please draw its
contour plots.
Solution The mesh grid data can be generated ﬁrst, as it was done in Example 2.35, and
the ordinary contours can be drawn with contour() function, as shown in Figure 2.23(a).
Also, the contours with superimposed height information can be obtained, as shown in Figure
2.23(b).
>> [x1,x2]=meshgrid(-1.5:.1:1.5,-2:.1:2);
z= 0.5457*exp(-0.75*x2.^2-3.75*x1.^2-1.5*x1).*(x1+x2>1)+...
0.7575*exp(-x2.^2-6*x1.^2).*((x1+x2>-1) & (x1+x2<=1))+...
0.5457*exp(-0.75*x2.^2-3.75*x1.^2+1.5*x1).*(x1+x2<=-1);
[C,h]=contour(x1,x2,z); clabel(C,h)
The following statements can be used directly to draw ﬁlled and 3D contours, as shown
in Figures 2.24(a) and (b). In the last statement, the number of contour lines is set to 30,
otherwise, the contours are too sparsely distributed.
>> subplot(121), contourf(x1,x2,z); subplot(122), contour3(x1,x2,z,30)

52
Scientiﬁc Computing with MATLAB®
−1
−0.5
0
0.5
1
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
(a) ordinary contours
0.1
0.1
0.1
0.1
0.2
0.2
0.2
0.3
0.3
0.3
0.4
0.4
0.5
0.5
0.6
0.7
−1
−0.5
0
0.5
1
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
(b) contours superimposed with heights
FIGURE 2.23: Contours of a piecewise function.
−1
−0.5
0
0.5
1
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
(a) ﬁlled contours
−1
−0.5
0
0.5
1
−2
−1
0
1
2
0
0.2
0.4
0.6
0.8
(b) 3D contours with 30 lines
FIGURE 2.24: Filled and 3D contours.
2.6.7
Drawing 3D implicit functions
The functions surf() and mesh() discussed so far can only be used to draw 3D plots
with known data, probably generated from known explicit function z = f(x, y). If a three-
dimensional implicit function g(x, y, z) = 0 is known, function ezimplot3() [6] can be used,
with the syntax ezimplot3(fun,[xm,xM,ym,yM,zm,zM]) , where, fun can be described
by anonymous functions, string, M-functions or by symbolic expressions. The default axes
ranges of xm, xM, ym, yM, zm, zM are ±2π. If only one pair of xm, xM is speciﬁed, all the
three axes share the same settings.
Example 2.41
Assume that an implicit function
g(x, y, z) = x sin

y+z2
+ y2 cos (x+z)+zx cos

z+y2
= 0
is known, and the interested ranges are x, y, z ∈(−1, 1), please draw the 3D surface.
Solution Strings and anonymous functions can both be used to describe the original implicit
function
>> f=@(x,y,z)x*sin(y+z^2)+y^2*cos(x+z)+z*x*cos(z+y^2);

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
53
The surface of the function can be obtained with the following commands, as shown in
Figure 2.25(a).
>> ezimplot3(f,[-1 1])
% draw 3D surface for the implicit function
(a) the 3D surface
(b) superimposed by a sphere
FIGURE 2.25: Surfaces of 3D implicit functions.
The following statements can be used to superimpose a unit sphere x2+y2+z2 =1 on the
surface, as shown in Figure 2.25(b).
>> f1=@(x,y,z)x^2+y^2+z^2-1; ezimplot3(f1,[-1 1]); % no hold on needed
2.7
Four-dimensional Visualization
In the three-dimensional plotting facilities illustrated earlier, function z = S(x, y) with
two independent variables are involved. If a function has three independent variables,
with its mathematical representation of v = V (x, y, z), volume visualization should be
introduced. There are quite a lot of practical examples for functions with three independent
variables. For instance, the internal temperature of a three-dimensional solid object, or the
ﬂow rate or concentration of liquid. These kinds of functions are not suitable to be visualized
with ordinary three-dimensional plots, and it is not possible to display four-dimensional plots
on ordinary two-dimensional screens. Special three-dimensional plots must be introduced.
In volume visualizations, slices are adopted to observe the values of the functions inside a
three-dimensional function. Computerized tomography (CT) images are good examples in
observing internal structures with slices. Of course, time-driven three-dimensional animation
can also be regarded as four-dimensional plots.
Again the meshgrid() function can be used to generate three-dimensional mesh grids,
and the three-dimensional arrays x,y,z can be established. The volume data V can be
evaluated through dot operation. Then, the function slice() can be called to draw the
slices, with the syntax slice(x,y,z,V ,x1,y1,z1), where, x, y, z and V are the data

54
Scientiﬁc Computing with MATLAB®
for volume visualization, while x1, y1 and z1 are the data for describing slices. If constant
vectors are used, the slices are perpendicular to the corresponding axes. The slices can also
be generated as rotated planes or even other types of surfaces, details will be given through
examples.
Example 2.42
Assume that a function
V (x, y, z) =

xx + y(x+y)/2 + z(x+y+z)/3
is with three independent variables. Please observe the function through volume visualiza-
tion techniques, and observe the properties through slices.
Solution Since square roots are taken, the axes x, y and z are assigned within nonnegative
ranges. The following statements can be used to visualize the data V . The groups of slices
are perpendicular to the axes can be speciﬁed. For instance, the ﬁrst group of slices were
ﬁxed at x = 1, x = 2, perpendicular to x axis, and the second and third groups are at y = 1,
y = 2 and z = 0, z = 1, respectively. The slices thus generated are shown in Figure 2.26(a).
>> [x,y,z]=meshgrid(0:0.1:2); V=sqrt(x.^x+y.^((x+y)/2)+z.^((x+y+z)/3));
slice(x,y,z,V,[1 2],[1 2],[0 1]); % volume visualization with slices
0
0.5
1
1.5
2
0
0.5
1
1.5
2
0
0.5
1
1.5
2
(a) slices perpendicular to the axes
0
0.5
1
1.5
2
0
0.5
1
1.5
2
0
0.5
1
1.5
2
(b) a rotated slice
FIGURE 2.26: The eﬀect of the slices.
As indicated earlier, an ordinary plane can be speciﬁed as z = 1. Then, it can be rotated
45◦along the x axis. In this case, the vectors x1, y1, z1 can be extracted from the rotated
plane, and the volume visualization with such a slice can be obtained, as shown in Figure
2.26(b).
>> [x0,y0]=meshgrid(0:0.1:2); z0=ones(size(x0)); % generate z = 0 plane
h=surf(x0,y0,z0); rotate(h,[1,0,0],45); % rotate plane 45◦along x-axis
x1=get(h,’XData’); y1=get(h,’YData’); z1=get(h,’ZData’); % get data
slice(x,y,z,V,x1,y1,z1), hold on, slice(x,y,z,V,2,2,0) % draw slices
In order to
observe the slices easily, a
simple-to-use graphical user interface
vol visual4d() is designed. To use the interface, the volume data x, y, z and V should
be generated ﬁrst, and interface can then be called with vol visual4d(x,y,z,V ). The
controls in the interface can be used directly to adjust the positions of the slices.
Example 2.43
Function vol visual4d() can be used to process the data generated in
Example 2.42. The volume visualization with default slices is shown in Figure 2.27. The user

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
55
FIGURE 2.27: Default slices in volume visualization.
can now adjust the positions of the slices with mouse dragging actions. The check boxes
can be turned on or oﬀto control the slices.
>> [x,y,z]=meshgrid(0:0.1:2); V=sqrt(x.^x+y.^((x+y)/2)+z.^((x+y+z)/3));
vol_visual4d(x,y,z,V); % volume visualization with GUI
Exercises
Exercise 2.1 In MATLAB environment, the following statements can be given
tic, A = rand(500); B = inv(A); norm(A*B-eye(500)), toc
Run the statements and observe results. If you are not sure of the commands, just use
the on-line help facilities to display information on the related functions. Then, explain in
detail the statement and the results.
Exercise 2.2 Suppose that a polynomial can be expressed by f(x) = x5 +3x4 +4x3 +2x2 +
3x+6. If one wants to substitute x by (s−1)/(s+1), the function f(x) can be changed into
a function of s. Use the Symbolic Math Toolbox to do the substitution and get the simplest
result.
Exercise 2.3 Please simplify sin(kπ + π/6), for any integer k.
Exercise 2.4 Input the matrices A and B into MATLAB workspace where

56
Scientiﬁc Computing with MATLAB®
A =
⎡
⎢⎢⎣
1
2
3
4
4
3
2
1
2
3
4
1
3
2
4
1
⎤
⎥⎥⎦,
B =
⎡
⎢⎢⎣
1 + j4
2 + j3
3 + j2
4 + j1
4 + j1
3 + j2
2 + j3
1 + j4
2 + j3
3 + j2
4 + j1
1 + j4
3 + j2
2 + j3
4 + j1
1 + j4
⎤
⎥⎥⎦.
It is seen that A is a 4×4 matrix. If a command A(5, 6) = 5 is given, what will happen?
Exercise 2.5 Command A = rand(3,4,5,6,7,8,9,10,11) can be used to generate a
multi-dimensional array. How many elements are there in the array? Please ﬁnd the sum
of all its elements.
Exercise 2.6 Find the ﬁrst 200 digits of the irrational numbers
√
2,
6√
11, sin 1◦, e2, ln 21.
Exercise 2.7 Please show the following identical equations
(i) ejπ + 1 = 0, (ii) 1 −2 sin α cos α
cos2 α −sin2 α = 1 −tanα
1 + tanα.
Exercise 2.8 If f(x) = x2 −x −1, please ﬁnd f(f(f(f(f(f(f(f(f(f(x)))))))))), and also
express the result in a polynomial. What is the degree of the polynomial?
Exercise 2.9 If the mathematical functions are known
f(x) =
x sin x
√
x2 + 2(x + 5), g(x) = tan x,
please ﬁnd out the functions f(g(x)) and g(f(x)).
Exercise 2.10 Since double-precision scheme is quite limited in representing accurately
large numbers, symbolic calculations are often used to ﬁnd factorials of large numbers.
Please use numerical and symbolic methods to calculate C10
50, where, Cn
m = m!/[n!(m −n)!].
Alternatively function nchoosek(sym(m),n) can be used.
Exercise 2.11 For a matrix A, if one wants to extract all the even rows to form matrix B,
what command should be used? Suppose that matrix A is deﬁned by A = magic(8), establish
matrix B with suitable statements and see whether the results are correct or not.
Exercise 2.12 Please list all the positive integers such that it is a multiple of 11 and does
not exceed 1000. Please also ﬁnd all the integers which are multiples of 11 in the [3000, 5000]
interval.
Exercise 2.13 How many prime numbers are there in the interval [1, 1000000]? Please ﬁnd
the product of all the prime numbers in the interval. What is the number and how many
digits are there? Measure the time elapsed in the evaluation.
Exercise 2.14 It is known in Example 2.12 that gcd() and lcm() functions can be used to
ﬁnd the greatest common divisor and least common multiple of two entities only. Please write
functions gcds() and lcms() such that an arbitrary number of entities can be processed.
Exercise 2.15 Implement the following piecewise function where x can be given by scalar,
vectors, matrices or even other multi-dimensional arrays, the returned argument y should
be the same size as that of x. The parameters h and D are scalars.
y = f(x) =
⎧
⎨
⎩
h,
x > D
h/Dx,
| x |⩽D
−h,
x < −D.

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
57
Exercise 2.16 A recursive formula is given by xn+1 = xn
2 +
3
2xn
, with x1 = 1. Please
ﬁnd a suitable number n, such that the terms after xn approaches a certain constant. The
accuracy requirement is 10−14. Please ﬁnd also the constant.
Exercise 2.17 Please calculate S =
∞

n=1

1 + 2
n2

, under the precision requirement of
ϵ = 10−12.
Exercise 2.18 It is known that
arc tan(x) = x −x3
3 + x5
5 −x7
7 + · · · .
Let x = 1, the following formula can be derived
π ≈4

1 −1
3 + 1
5 −1
7 + 1
9 −1
11 + · · ·

.
Please calculate the approximate value of π, with the precision requirement 10−6.
Exercise 2.19 Generate a 100 × 100 magic matrix, and ﬁnd out the entities greater than
100, and substitute the entities by 0.
Exercise 2.20 Evaluate using numerical method the sum
S = 1 + 2 + 4 + · · · + 262 + 263 =
63

i=0
2i,
the use of vectorized form is suggested. Check whether accurate solutions can be found and
why. Find the accurate sum using the symbolic computation methods. What happened in
numerical and analytical solutions, if the number of terms is increased to 640.
Exercise 2.21 Please use two algorithms to solve the equation f(x) = x2 sin(0.1x+2)−3 = 0.
(i) Bisection method. If in an interval (a, b), f(a)f(b) < 0, there will be at least one
solution. Take the middle point x1 = (b −a)/2, and based on the relationship of f(x1) and
f(a), f(b), determine in which half interval there exists solutions. Middle point in the new
half interval can then be taken. Repeat the process until the size of the interval is smaller
than the pre-speciﬁed error tolerance ϵ. Find the solution with bisection method in interval
(−4, 0), with ϵ = 10−10.
(ii) Newton–Raphson method. Select an initial guess of xn, the next approximation
can be obtained with xn+1 = xn −f(xn)/f ′(xn). If the two points are close enough, i.e.,
|xn+1 −xn| < ϵ, where ϵ is the error tolerance. Find the solution with x0 = −4, and
ϵ = 10−12.
Exercise 2.22 Write an M-function mat add(), with the A = mat add(A1,A2,A3,· · · )
syntax. It is required that an arbitrary number of input arguments Ai are allowed.
Exercise 2.23 A MATLAB function can be written whose syntax is
v = [h1, h2, hm, hm+1, · · · , h2m−1]
and
H = myhankel(v)
where the vector v is deﬁned, and out of it, the output argument should be an m×m Hankel
matrix.

58
Scientiﬁc Computing with MATLAB®
Exercise 2.24 From matrix theory, it is known that if a matrix M is expressed as M =
A + BCBT, where A, B and C are the matrices of relevant sizes, the inverse of M can
be calculated by the following algorithm
M −1 =

A + BCBT−1
= A−1 −A−1B

C−1 + BTA−1B
−1
BTA−1
The matrix inversion can be carried out using the formula easily. Suppose that there is
a 5 × 5 matrix M, from which the three other matrices can be found.
M =
⎡
⎢⎢⎢⎢⎣
−1
−1
−1
1
0
−2
0
0
−1
0
−6
−4
−1
−1
−2
−1
−1
0
2
0
−4
−3
−3
−1
3
⎤
⎥⎥⎥⎥⎦
,
A =
⎡
⎢⎢⎢⎢⎣
1
0
0
0
0
0
3
0
0
0
0
0
4
0
0
0
0
0
2
0
0
0
0
0
4
⎤
⎥⎥⎥⎥⎦
,
B =
⎡
⎢⎢⎢⎢⎣
0
1
1
1
1
0
2
1
0
1
1
1
1
2
1
0
1
0
0
1
1
1
1
1
1
⎤
⎥⎥⎥⎥⎦
,
C =
⎡
⎢⎢⎢⎢⎣
1
−1
1
−1
−1
1
−1
0
0
−1
0
0
0
0
1
1
0
−1
−1
0
0
1
−1
0
1
⎤
⎥⎥⎥⎥⎦
.
Write the statement to evaluate the inverse matrix. Check the accuracy of the inversion.
Compare the accuracy of the inversion method and the direct inversion method with inv()
function.
Exercise 2.25 Please generate the ﬁrst 300 terms of the extended Fibonacci sequence
T (n) = T (n −1) + T (n −2) + T (n −3), n = 4, 5, · · ·, with T (1) = T (2) = T (3) = 1.
Exercise 2.26 Consider the following iterative model

xk+1 = 1 + yk −1.4x2
k
yk+1 = 0.3xk,
with initial conditions x0 = 0, y0 = 0. Write an M-function to evaluate the sequence xi, yi.
30000 points can be obtained by the function to construct the x and y vectors. The points
can be expressed by a dot, rather than lines. In this case, the so-called H´enon attractor can
be drawn.
Exercise 2.27 The well-known Mittag–Leﬄer function is deﬁned as
fα(z) =
∞

k=0
zk
Γ(αk + 1),
where Γ(x) is a Gamma function which can be evaluated with gamma(x). Write an M-
function with syntax f = mymittag(α,z,ϵ), where ϵ is the error tolerance, with default
value of ϵ = 10−6. Argument z is a numeric vector. Draw the curves for Mittag–Leﬄer
functions with α = 1 and α = 0.5.
Exercise 2.28 Chebyshev polynomials are mathematically deﬁned as
T1(x) = 1, T2(x) = x, Tn(x) = 2xTn−1(x) −Tn−2(x), n = 3, 4, 5, · · · .
Please write a recursive function to generate a Chebyshev polynomial, and compute
T10(x). Please write a more eﬃcient function as well to generate Chebyshev polynomials,
and ﬁnd T30(x).

Fundamentals of MATLAB Programming and Scientiﬁc Visualization
59
Exercise 2.29 A regular triangle can be drawn by MATLAB statements easily. Use the
loop structure to design an M-function that, in the same coordinates, a sequence of regular
triangles can be drawn, each by rotating a small angle, for instance, 5◦, from the previous
one.
Exercise 2.30 Select suitable step-sizes and draw the function curve for sin (1/t), t ∈
(−1, 1).
Exercise 2.31 For suitably assigned ranges of θ, draw polar plots for the following
functions.
(i) ρ = 1.0013θ2,
(ii) ρ = cos(7θ/2),
(iii) ρ = sin(θ)/θ,
(iv) ρ = 1 −cos3(7θ).
Exercise 2.32 Please draw the curves of x sin x + y sin y = 0 for −50 ⩽x, y ⩽50.
Exercise 2.33 Find the solutions to the following simultaneous equations using graphical
methods and verify the solutions.
(i)

x2 + y2 = 3xy2
x3 −x2 = y2 −y,
(ii)

e−(x+y)2+π/2 sin(5x + 2y) = 0
(x2 −y2 + xy)e−x2−y2−xy = 0.
Exercise 2.34 Please save a 100 × 100 magic matrix into an Excel ﬁle.
Exercise 2.35 Assume that the power series expansion of a function is
f(x) = lim
N→∞
N

n=1
(−1)n x2n
(2n)!.
If N is large enough, power series f(x) converges to a certain function ˆf(x). Please
write a MATLAB program that plots the function ˆf(x) in the interval x ∈(0, π). Observe
and verify what function ˆf(x) is.
Exercise 2.36 Draw the 3D surface plots for the functions xy and sin xy, respectively.
Also, draw the contours of the functions. View the 3D surface plot from diﬀerent angles,
especially with orthographic views.
Exercise 2.37 Please draw 2D and 3D Lissajous ﬁgures under the parametric equations
x = sin t, y = sin at and z = sin bt, for diﬀerent parameters a and b, where, please try the
following rational and irrational parameters and see what may happen.
(i) a = 1/2, b = 1/3, (ii) a =
8√
2, b =
√
3.
Exercise 2.38 For the parametric equations [7], please draw the surfaces
(i) x = 2 sin2 u cos2 v, y = 2 sin u sin2 v, z = 2 cosu sin2 v, −π/2 ⩽u, v ⩽π/2,
(ii) x = u −u3
3 + uv2, y = v −v3
3 + vu2, z = u2 −v2, −2 ⩽u, v ⩽2.
Exercise 2.39 A vertical cylinder can be described by parametric equation x = r sin u, y =
r cos u, z = v, along z axis, with r the radius. If x and z are swopped, the cylinder can be
represented along x axis. Please draw several cylinders with diﬀerent radii and directions
together in the same coordinate.
Exercise 2.40 Please draw a cone, whose top is at (0,0,2), and bottom at the plane z = 0,
with a radius of 1.

60
Scientiﬁc Computing with MATLAB®
Exercise 2.41 In graphics command, there is a trick in hiding certain parts of the plot. If
the function values are assigned to NaNs, the point on the curve or the surface will not be
shown. Draw ﬁrst the surface plot of the function z = sin xy. Then, cut oﬀthe region that
satisﬁes x2 + y2 ⩽0.52.
Exercise 2.42 Please draw the 3D surface of f(x, y) = sin

x2 + y2

x2 + y2
for −8 ⩽x, y ⩽8.
Exercise 2.43 Lambert W function is a commonly used special function, its mathematical
form is W(z)eW(z) = z. Please draw the curve of the function.
Exercise 2.44 Draw the surface plot and contour plots for the following functions. Draw
also with the functions surfc(), surfl() and waterfall(), and observe the results.
(i) z = xy, (ii) z = sin x2y3, (iii) z =
(x −1)2y2
(x −1)2 + y2 , (iv) z = −xy e−2(x2+y2).
Exercise 2.45 Please draw the surface of the three-dimensional implicit function
(x2 + xy + xz)e−z + z2yx + sin(x + y + z2) = 0.
Exercise 2.46 Please draw the two following two surfaces and observe the intersections
x2 + y2 + z2 = 64, y + z = 0.
Exercise 2.47 Please draw the sliced volume visualization for the following functions
(i) V (x, y, z) =

ex + e(x+y)−xy + e(x+y+z)/3−xyz, (ii) V (x, y, z) = e−x2−y2−z2.
Bibliography
[1] Gilbert D. Extended plotyy to three y-axes. MATLAB Central File ID: # 1017, 2001
[2] Bodin P. PLOTY4 support for four y axes. MATLAB Central File ID: # 4425, 2004
[3] Gilbert D. PLOTXX create graphs with two x axes. MATLAB Central File ID: # 317,
1999
[4] Lamport L. LATEX: a document preparation system — user’s guide and reference manual.
Reading MA: Addision-Wesley Publishing Company, second edition, 1994
[5] Xue D. Analysis and computer aided design of nonlinear systems with Gaussian inputs.
Ph.D. thesis, Sussex University, U.K., 1992
[6] Morales G. Ezimplot3: implicit 3D functions plotter. MATLAB Central File ID #23623
[7] Majewski M. MuPAD Pro computing essentials. Berlin: Springer, 2002

Chapter 3
Calculus Problems
The calculus established by Isaac Newton and Gottfried Wilhelm Leibniz is fundamental
to many branches of sciences and engineering. In traditional calculus courses, limits,
diﬀerentiations, integrals, series expansions such as Taylor series and Fourier series
expansions for univariate and multivariate functions are the main topics discussed. The
analytical solutions to these problems can be obtained by the direct use of the corresponding
functions provided by the Symbolic Math Toolbox of MATLAB which will be discussed in
Sections 3.1 to 3.3. The Taylor series expansions for univariate and multivariate functions as
well as the Fourier series expansions are discussed in Section 3.4, moreover, the ﬁtting quality
and interval are assessed graphically, if ﬁnite-term series expansions are used. In Section
3.5, the sum and product of sequences problems are discussed. Convergency test for inﬁnite
series and convergent internals are explored. Sections 3.6 and 3.7 present methods for path
integrals and surface integrals. Most of the materials presented in this chapter are symbolic-
based, which cannot be solved using conventional computer programming languages such
as C for average users. Computer mathematics languages such as MATLAB should be used
instead.
In college mathematics courses, to ﬁnd the limit or integral of a certain function required
good experiences, and the experiences can only be acquired by doing a tremendous amount
of exercises. In these sections, a uniﬁed three-phase solution pattern is introduced: (i)
declare symbolic variables, (ii) express the functions as symbolic expressions, and (iii) use
appropriate MATLAB function to ﬁnd the answer. Equipped with the powerful computer
tools, the readers are able to solve the calculus problems easily, without the need of
mastering the skills in calculus problem solutions.
In many scientiﬁc and engineering researches, the analytical solutions to calculus
problems may face diﬃculties, when the original functions are not given explicitly. For
problems with measured data, numerical diﬀerentiations and integrals should be applied
accordingly. They are illustrated in Sections 3.8 and 3.9, respectively. Alternative solutions
to the same numerical calculus problems using spline interpolation will be given in Chapter
8. Solutions to diﬀerential equation problems will be presented in Chapter 7. As an extension
to the traditional (integer-order) calculus, non-integer-order or fractional-order calculus, will
be discussed in Chapter 10.
For readers who wish to check the detailed explanations of calculus, we recommend the
free textbooks [1,2].
3.1
Analytical Solutions to Limit Problems
The Symbolic Math Toolbox of MATLAB can be used directly in solving the limit
problems, the diﬀerentiation problems, and the integral problems. Using the methods
61

62
Scientiﬁc Computing with MATLAB®
presented in this and the following two sections, the readers will be equipped with the
ability in solving ordinary calculus problems directly by computers.
3.1.1
Limits of univariate functions
Assume that the function to be analyzed is f(x), the limit is denoted as
L = lim
x→x0 f(x),
(3-1-1)
meaning the value of the function when the independent variable x inﬁnitely approaches
to x0, where x0 can be either a given constant or inﬁnity. For certain functions, the left or
right limit can be denoted as
L1 = lim
x→x−
0
f(x),
or L2 = lim
x→x+
0
f(x),
(3-1-2)
where the former means to approach the point x0 from the left-hand side which is referred
to as the left limit problem. The latter is referred to as the right limit problem. The limit
problems summarized above can be solved by the use of the limit() function, where
L = limit(fun,x,x0)
% calculate the limit
L = limit(fun,x,x0,’left’ or ’right’)
% the one-sided limit
To use the functions in Symbolic Math Toolbox, symbolic variables such as x should be
declared ﬁrst. Then, the limit function fun can be expressed. If x0 is ∞, one can assign it to
inf. If the one-sided limit is required, the ’left’ or ’right’ option should be speciﬁed. The
following examples are used to demonstrate the use of the limit() function in MATLAB.
If there is only one symbolic variable used in ﬁrst syntax, it can be omitted in the
function call. The list of actual symbolic variables used in an expression f can be extracted
with symvar() function, with list = symvar(f).
Example 3.1
Find the limit lim
x→0
sin x
x
.
Solution Everyone who has essential knowledge on calculus knows that the limit is 1. In
order to let the computer solve the problem, the following three-step procedures should be
used: (i) declare symbolic variables, (ii) write the symbolic expression of function f, and (iii)
call limit() function to get the result. The three steps can be implemented in MATLAB
with the following three statements
>> syms x; f=sin(x)/x; limit(f,x,0) % the three-step procedures
Since in the second statement, x is a symbolic variable rather than a vector or a matrix,
there is no need to describe the function with dot operations. The symbolic variables in
expression f can be extracted with the symvar() function, and it can be seen that x is the
only symbolic variable in the expression, therefore, the argument x can be omitted in the
function calls
>> v=symvar(f), L=limit(f,0) % ﬁnd the independent variable
Example 3.2
Solve the limit problem lim
x→∞x

1 + a
x
x
sin b
x.
Solution Similar to the example above, the three steps can also be used, and the obtained
result is L = eab. It can be seen that, for the user, the solution process of the complicated
limit problem is not more diﬃcult than the previous example.

Calculus Problems
63
>> syms x a b; f=x*(1+a/x)^x*sin(b/x); L=limit(f,x,inf)
If v = symvar(f) is used, the variable vector v returned is [a, b, x]. Therefore, x cannot
be omitted in the function call.
Example 3.3
Solve the one-sided limit problem lim
x→0+
ex3 −1
1 −cos
√
x −sin x
.
Solution
With the limit() function, the one-sided limit can easily be solved, with the
limit of 12.
>> syms x; f=(exp(x^3)-1)/(1-cos(sqrt(x-sin(x))));
L=limit(f,x,0,’right’) % compute the right limit directly
One can further verify the above problem graphically over a proper range of interest.
For instance, if the interval (−0.01, 0.01) is considered, the function over the interval can
be drawn in Figure 3.1. It can be seen that the point at x = 0 was deliberately excluded to
avoid 0/0 computation, which yields NaN.
−0.01
−0.008 −0.006 −0.004 −0.002
0
0.002
0.004
0.006
0.008
0.01
12
12
12
12
12
12
12.0001
12.0001
FIGURE 3.1: The curve of the function around x = 0.
>> x0=-0.01:0.0005:0.01; x0=x0(x0~=0); % exclude 0 from the vector
plot(x0,subs(f,x,x0),00,12,’o’)
% draw the curve
L2=limit(f,x,0), L3=limit(f,x,0,’left’)
It can be seen that the limit of the original problem is also 12, no matter if approaching
it from left or from right hand side.
Consider again the original problem. The aim of the original one-sided limit requirement
ensures that the expression under the square root sign is nonnegative. In fact, for imaginary
variables, one can still ﬁnd from the Euler’s formula that cos jα = (eα + e−α)/2. Thus, the
one-sided limits for the function are the same for this example, which further veriﬁes that
the original function is continuous around x = 0 as also seen from Figure 3.1.
For a certain point x = a, if the left and right limits of function f(x) are equal, a
is referred to as the ﬁrst-type discontinuity, otherwise, it is referred to as the second-type
discontinuity, as will be demonstrated by the following simple example.
Example 3.4
Please ﬁnd the left and right limit of function tan t at point t →π/2.
Solution The two one-sided limits can be obtained easily, and the results are respectively
L1 = ∞and L2 = −∞.

64
Scientiﬁc Computing with MATLAB®
>> syms t; f=tan(t); % declare symbolic variable and function
L1=limit(f,t,pi/2,’left’), L2=limit(f,t,pi/2,’right’) % compute limits
Example 3.5
Please ﬁnd the limit of a sequence lim
n→∞
3√
n2 sin n!
n + 1
.
Solution The procedures of ﬁnding the limit of a sequence are exactly the same as the limit
of a function. The symbolic variables must be declared ﬁrst, then, the sequence should be
expressed as a symbolic expression. Finally the function limit() must be called to get the
results. For this example, the following commands should be issued, and the result is 0.
>> syms n; f=n^(2/3)*sin(factorial(n))/(n+1); F=limit(f,n,inf)
Example 3.6
Please ﬁnd the limit of
lim
n→∞n arctan

1
n(x2 + 1) + x

tann π
4 + x
2n

.
Solution The expression is a function of x, and it is also a sequence. However, this does
not cause extra diﬃculties when MATLAB is used. The following statements can be issued
to ﬁnd the limit ex/(x2 + 1).
>> syms x n;
% declare x and n as symbolic variables
f=n*atan(1/(n*(x^2+1)+x))*tan(pi/4+x/2/n)^n; limit(f,n,inf)
Even more accurately, the variable n should be declared as an integer, and the ﬁrst
sentence should be rewritten as follows, and the result is the same.
>> syms x n; assume(n,’integer’);
% declare n as an integer
3.1.2
Limits of interval functions
An example is used in this section, before the concept of interval function is introduced.
Example 3.7
Please ﬁnd the limits lim
n→∞xn and lim
x→∞xn.
Solution
The limits cannot be easily found with old versions of MATLAB. In the new
versions, with MuPAD symbolic engine, piecewise functions are supported, thus, the limits
can be found directly with the following statements
>> syms x n real; f=x^n; L1=limit(f,n,inf), L2=limit(f,x,inf)
The results are piecewise functions, with the description of L2 as follows
piecewise([n == 0,1],[0 < n,Inf],[n < 0,0])
the two limits can be expressed mathematically as
L1 =
⎧
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎩
1,
x = 1
∞,
x > 1
no limit,
x < −1
0,
0 < x < 1 or −1 < x < 0,
L2 =
⎧
⎪
⎪
⎨
⎪
⎪
⎩
1,
n = 0
∞,
n > 0
0,
n < 0.
It seems that something imprecise in the last condition in L1, where the point x = 0
should be included, such that the condition should be −1 < x < 1.

Calculus Problems
65
For certain functions such as sin x, the limit does not exist, when x →∞. With the
low-level support of MuPAD, which is the actual symbolic engine in the new versions of the
Symbolic Math Toolbox, the limit can be found, such that there are interval limits.
L = feval(symengine,’limit’,f,’x=infinity’,’Intervals’)
where, feval() function can be used to call directly the low-level function limit() under
MuPAD, and the arguments are also passed to MuPAD.
Example 3.8
Assume that a, b > 0, please ﬁnd the limit
lim
x→∞a sin 8x2 + b cos(2x −2).
Solution With the low-level MuPAD command, it can be found that the interval limit is
(−a −b, a + b).
>> syms a b positive, syms x; f=a*sin(8*x^2)+b*cos(2*x-2);
L=feval(symengine,’limit’,f,’x=infinity’,’Intervals’)
Piecewise functions are supported in MuPAD, the new symbolic engine of MATLAB
Symbolic Math Toolbox. Low-level MuPAD commands must be issued, and may not be
convenient for ordinary MATLAB users. Thus, an interface function piecewise() is written
to describe piecewise functions
function f=piecewise(varargin), str=[];
try
for i=1:2:length(varargin),
str=[str,’[’,varargin{i},’,’,varargin{i+1},’],’];
end
catch, error(’Input arguments should be given in pairs.’), end
f=feval(symengine,’piecewise’,str(1:end-1));
The syntax of the function is f = piecewise(var1,var2,· · ·), where the input arguments
var must be provided in pairs, with the ﬁrst describing the condition, and the last for the
symbolic expression. They should both be declared as strings. In the condition string, the
logic keywords such as and, or and not can be used.
The try-catch structure is used in the interface function to insure the arguments appear
in pairs, otherwise, an error message will be displayed. Since there will be an extra comma
by the end of the ﬁnal string, the command 1:end-1 is used to discard it.
Example 3.9
Consider the saturation function in Example 2.26
y =

1.1 sign(x),
|x| > 1.1
x,
|x| ⩽1.1.
Describe it in piecewise function, and draw the curve.
Solution
With the use of the piecewise() interface, the saturation function can be
expressed as a symbolic expression. Then, the curves can be drawn directly, and it is exactly
the same as the one obtained in Example 2.26. It should be noted that, due to the limitations
in symbolic calculation, the thus deﬁned piecewise function cannot be drawn directly with
ezplot() function.
>> f=piecewise(’abs(x)>1.1’,’1.1*sign(x)’,’abs(x)<=1.1’,’x’);
syms x; x0=-3:0.01:3; f1=subs(f,x,x0); plot(x0,f1)

66
Scientiﬁc Computing with MATLAB®
The condition |x| ⩽1.1 can also be described mathematically as −1.1 ⩽x ⩽1.1 and
can also be understood as x ⩾−1.1 and x ⩽1.1. Thus, the corresponding string can also be
expressed as ’x >= −1.1 and x <= 1.1’.
3.1.3
Limits of multivariate functions
Two kinds of limits are often encountered in multivariate functions, one is sequential
limit, and the other is multiple limit. Assume for a function f(x, y) with two independent
variables, the sequential limits are deﬁned as
L1 = lim
x→x0

lim
y→y0 f(x, y)

,
or L2 = lim
y→y0

lim
x→x0 f(x, y)

,
(3-1-3)
where, x0 and y0 can either be values or functions. The sequential limits can also be
evaluated with the nested calls to the limit() function
L1 = limit(limit(f,x,x0),y,y0), or L1 = limit(limit(f,y,y0),x,x0)
Example 3.10
Please ﬁnd the sequential limit
lim
y→∞
 
lim
x→1/√y e−1/(y2+x2) sin2 x
x2

1 + 1
y2
x+a2y2!
.
Solution Since √y is involved, y should be declared as a positive symbolic variable (no need
to do so in earlier versions). Therefore, the limit problem can be solved with the following
statements, and the result is ea2.
>> syms x a; syms y positive; % deﬁne y > 0. Not necessary in old versions
f=exp(-1/(y^2+x^2))*sin(x)^2/x^2*(1+1/y^2)^(x+a^2*y^2);
L=limit(limit(f,x,1/sqrt(y)),y,inf) % compute limit
Apart from sequential limits, there is also a multiple limit for multivariate functions
deﬁned as
L =
lim
x→x0
y→y0
f(x, y).
(3-1-4)
Normally speaking, if the two sequential limits both exist and are equal, the multiple
limit may be equal to that value. It should be pointed out that in some special cases, even
though the two sequential limits are the same, the multiple limit does not exist. In that
case, approaching from diﬀerent directions should also be considered.
Example 3.11
Try to solve the double limit problem
lim
x →∞
y →∞

xy
x2 + y2
x2
.
Solution The two sequential limits can be obtained with the following statements, and they
both are equal to 0. Moreover, two other directions, x→y2 and y→x2 can also be evaluated,
and the same limits can be found.
>> syms x y; f=(x*y/(x^2+y^2))^(x^2);
L1=limit(limit(f,x,inf),y,inf), L2=limit(limit(f,y,inf),x,inf)
L3=limit(limit(f,x,y^2),y,inf), L4=limit(limit(f,y,x^2),x,inf)

Calculus Problems
67
Example 3.12
Please check the existence of the multiple limit
lim
x →0
y →0
xy
x2 + y2 .
Solution
To deﬁnitely compute the multiple limit is diﬃcult, since all the approaching
directions should be considered. To indicate the nonexistence is comparatively easier. For
instance, suppose y = rx, with r a symbolic variable, if the limit of x →0 is r dependent,
that is adequate to indicate the nonexistence of the multiple limit. Other functions of y can
also be tested.
>> syms r x y; f=x*y/(x^2+y^2); L=limit(subs(f,y,r*x),x,0)
and the limit is L = r/(r2 + 1), therefore, the multiple limit is nonexistence.
3.2
Analytical Solutions to Derivative Problems
3.2.1
Derivatives and high-order derivatives
For a function described by y = f(x), the ﬁrst-order derivative of y(x) with respect to
x is deﬁned as
y′(x) = dy(x)
dx
= lim
Δx→0
f(x + Δx) −f(x)
Δx
.
(3-2-1)
The second-order derivative is the ﬁrst-order derivative of y′(x) with respect to x. The
high-order derivatives are also deﬁned accordingly.
If the function f(x) is described as a symbolic expression fun, the function diff() can
be used to calculate its derivatives, with the syntaxes
y = diff(fun,x)
% ﬁnd the derivative
y = diff(fun,x,n)
% evaluate the nth order derivative
If there is only one variable in the function, the independent variable name can be
omitted. If n is omitted, the ﬁrst-order derivative can be found. The three-step procedure
discussed earlier can also be used to ﬁnd the derivatives of given functions.
Example 3.13
Compute d4f(x)
dx4
for a given function f(x) =
sin x
x2 + 4x + 3.
Solution This was the very ﬁrst example given at the beginning of the book. The derivatives
can easily be obtained with the following MATLAB functions. The variable x should be
declared as a symbolic variable ﬁrst, then, the function diff() can be called to ﬁnd the
ﬁrst-order derivative.
>> syms x; f=sin(x)/(x^2+4*x+3); f1=diff(f) % three-step procedure
and the result obtained is
f1 =
cos x
x2 + 4x + 3 −(2x + 4) sin x
(x2 + 4x + 3)2 .
In recent versions, the above commands can alternatively be rewritten as

68
Scientiﬁc Computing with MATLAB®
>> syms x; f(x)=sin(x)/(x^2+4*x+3); f1(x)=diff(f) % f(x) allowed
The function ezplot() can be used to draw the original function and its ﬁrst order
derivative, as shown in Figure 3.2.
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
−0.1
−0.05
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
f(x)
df(x)/ dx
FIGURE 3.2: The curves of the original function and its derivative.
>> ezplot(f,[0,5]); hold on; ezplot(f1,[0,5]); % draw curves directly
The fourth-order derivative can be simply calculated from
>> f4=diff(f,x,4) % ﬁnd the 4th order derivative
and the result obtained is
f4 =
sin x
x2 + 4x + 3 +
12 sin x
(x2 + 4x + 3)2 +
24 sinx
(x2 + 4x + 3)3 −24(2x + 4)3 cos x
(x2 + 4x + 3)4
−12(2x + 4)2 sin x
(x2 + 4x + 3)3
−48(2x + 4)2 sin x
(x2 + 4x + 3)4
+ 24(2x + 4)4 sin x
(x2 + 4x + 3)5
+ 4 (2x + 4) cos x
(x2 + 4x + 3)2
+16 (2x + 4) cos x
(x2 + 4x + 3)3
+ 8 (8x + 16) cos x
(x2 + 4x + 3)3
−6 (2x + 4) (8x + 16) sin x
(x2 + 4x + 3)4
.
From the above simpliﬁed results, it is clear that the direct use of the function simplify()
is not suﬃcient for this example. For the given example, it can immediately be found that
one may extract the terms sin x and cos x from the results and the coeﬃcients for these
terms can be simpliﬁed separately such that
>> collect(simplify(f4),sin(x)), collect(simplify(f4),cos(x))
The even more concise results can be obtained shown as follows:
d4f(x)
dx4
= 8(x5 + 10x4 + 26x3 −4x2 −99x −102)
cos x
(x2 + 4x + 3)4 +
(x8 + 16x7 + 72x6 −32x5 −1094x4 −3120x3 −3120x2 + 192x + 1581)
sin x
(x2 + 4x + 3)5 .
The diﬀerentiation function diff() can easily be used to ﬁnd high-order derivatives. For
instance, the 100th order derivative of the same function can be found within 15 seconds (in
earlier versions, the results can be found within 1 second).
>> tic, diff(f,x,100); toc % compute the 100th order derivative

Calculus Problems
69
Example 3.14
If the function is given by F(t) = t2f(t) sin t, where f(t) is another
function, please derive the third order derivative formula. Also, if f(t) = e−t, please ﬁnd
the third order derivative of F(t), and validate the result.
Solution In recent versions, the command syms f(t) can be used to declare function f(t).
Therefore, the third order derivative of F(t) can be found with
>> syms t f(t); % deﬁne function f(t). In old versions, use f=sym(’f(t)’)
F=f*t^2*sin(t); G=simplify(diff(F,t,3)) % evaluate 3rd order derivative
and the result is
d3F(t)
dt3
=
 d3f(t)
dt3
sin t + 3d2f(t)
dt2
cos t −3df(t)
dt
sin t −f(t) cos t

t2
+

6d2f(t)
dt2
sin t + 12df(t)
dt
cos t −6f(t) sin t

t + 6df(t)
dt
sin t + 6f(t) cos t.
The following commands can be used to ﬁnd the third order derivative of F(t), by
substituting f(t) with e−t, or by direct diﬀerentiation. It can be seen that the two results are
exactly the same
y1(t) = 2e−t 
t2 cost + t2 sin t −6t cos t + 3 cost −3 sin t

.
>> y1=simplify(subs(G,f,exp(-t)))
% variable substitution
simplify(diff(t^2*sin(t)*exp(-t),3)-y1) % validate the results
Please note that, in the last statement, simplify() function is used to simplify the
diﬀerence between the results of the two methods. It is a common way in MATLAB to show
that the two results are identical, if the simpliﬁed diﬀerence is zero.
Example 3.15 Assume a matrix function H(x) is given below, please ﬁnd its third order
derivative with respect to x.
H(x) =
 
4 sin 5x
e−4x2
3x2 + 4x + 1
√
4x2 + 2
!
.
Solution Function diff() can also be used to ﬁnd the high-order derivatives of a matrix
function H(x). It takes derivatives to each matrix element hi,j(x) independently, in the
same way as in dot operation. The new matrix function N(x) can be found
>> syms x; H=[4*sin(5*x), exp(-4*x^2); 3*x^2+4*x+1, sqrt(4*x^2+2)]
N=diff(H,x,3) % compute 3rd order derivative to each element individually
The resulting derivative matrix function is
N(x) = d
dxH(x) =
⎡
⎢⎣
−500 cos5x
192x e−4x2 −512x3 e−4x2
0
24
√
2 x3
(2x2 + 1)5/2 −
12
√
2x
(2x2 + 1)3/2
⎤
⎥⎦.
3.2.2
Partial derivatives of multivariate functions
There is no direct function which can be used in ﬁnding the partial derivatives in
MATLAB. The function diff() can actually be used instead. For instance, if a function

70
Scientiﬁc Computing with MATLAB®
f(x, y) with two variables is deﬁned, the partial derivative ∂m+nf/(∂xm∂yn) can be
evaluated by the nested use of the diff() function as follows:
f = diff(diff(fun,x,m),y,n), or
f = diff(diff(fun,y,n),x,m)
Example 3.16 Find the partial derivatives of z = f(x, y) = (x2 −2x)e−x2−y2−xy function
and investigate the function further using graphical method.
Solution The partial derivatives ∂z/∂x and ∂z/∂y can be evaluated easily using
>> syms x y; z=(x^2-2*x)*exp(-x^2-y^2-x*y); % function expression
zx=simplify(diff(z,x)), zy=simplify(diff(z,y)) % compute gradients
and the mathematical representations of the derivatives are
∂z(x, y)
∂x
= −e−x2−y2−xy(−2x + 2 + 2x3 + x2y −4x2 −2xy)
∂z(x, y)
∂y
= −x(x −2)(2y + x)e−x2−y2−xy.
Within the rectangular region where x ∈(−3, 3), y ∈(−2, 2), mesh grids can be deﬁned
and the partial derivatives can be obtained numerically over the mesh grids. The three-
dimensional surface of the original function is shown in Figure 3.3 (a).
>> [x0,y0]=meshgrid(-3:.2:3,-2:.2:2);
% generate mesh grid matrices
z0=double(subs(z,{x,y},{x0,y0}));
% substituting the two variables
surf(x0,y0,z0), axis([-3 3 -2 2 -0.7 1.5]) % three-dimensional surface
From the partial derivatives obtained, the numerical solutions at the mesh grids can be
evaluated. The function quiver() can then be used to draw attractive curves, and the curves
can be superimposed over the contour of the original function with the following statements,
as shown in Figure 3.3 (b).
>> contour(x0,y0,z0,30), hold on
% contours of the function
zx0=subs(zx,{x,y},{x0,y0}); zy0=subs(zy,{x,y},{x0,y0});
quiver(x0,y0,-double(zx0),-double(zy0))
% draw the negative gradients
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) three-dimensional surface
−3
−2
−1
0
1
2
3
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
(b) contours with gradients
FIGURE 3.3: Graphical interpretation of the functions with two variables.

Calculus Problems
71
Example 3.17
For a given function with three independent variables x, y and z,
f(x, y, z) = sin(x2y)e−x2y−z2, ﬁnd the partial derivative ∂4f(x, y, z)/(∂x2∂y∂z).
Solution The following MATLAB statements can be given to solve this problem
>> syms x y z; f=sin(x^2*y)*exp(-x^2*y-z^2);
% the original function
df=diff(diff(diff(f,x,2),y),z); df=simplify(df) % compute directly
The results can be obtained as
−4ze−x2y−z2
cos x2y −10yx2 cos x2y + 4x4y2 sin x2y + 4x4y2 cos x2y −sin x2y

.
3.2.3
Jacobian matrix of multivariate functions
Assume that there are n independent variables, and m functions deﬁned as
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
y1 = f1(x1, x2, · · · , xn)
y2 = f2(x1, x2, · · · , xn)
...
...
ym = fm(x1, x2, · · · , xn).
(3-2-2)
The partial derivative ∂yi/∂xj for each combination of i and j can be represented in the
matrix form as
J =
⎡
⎢⎢⎢⎣
∂y1/∂x1
∂y1/∂x2
· · ·
∂y1/∂xn
∂y2/∂x1
∂y2/∂x2
· · ·
∂y2/∂xn
...
...
...
...
∂ym/∂x1
∂ym/∂x2
· · ·
∂ym/∂xn
⎤
⎥⎥⎥⎦
(3-2-3)
and such a matrix is referred to as the Jacobian matrix. Jacobian matrices are quite useful
in many research areas, such as robotics and image processing. Jacobian matrix can be
obtained using the jacobian() function of the Symbolic Math Toolbox directly. The syntax
of the function is
J = jacobian([y1,y2,· · · ,ym],[x1,x2,· · · ,xn]) ,
where [x1,x2,· · · ,xn] is the vector of independent variables, and the multivariate functions
are represented in vector [y1,y2,· · · ,ym].
Example 3.18
Consider that the functions for coordinate transformation are deﬁned
as x = r sin θ cos φ, y = r sin θ sin φ and z = r cos θ. Find the Jacobian matrix of these
functions.
Solution Three independent variables can be declared, and the three functions can then be
expressed in a vector. The following statements can be used to ﬁnd the Jacobian matrix
>> syms r theta phi; x=r*sin(theta)*cos(phi); y=r*sin(theta)*sin(phi);
z=r*cos(theta); J=jacobian([x; y; z],[r theta phi])
The Jacobian matrix is obtained as
J =
⎡
⎣
sin θ cos φ
r cos θ cos φ
−r sin θ sin φ
sin θ sin φ
r cos θ sin φ
r sin θ cos φ
cos θ
−r sin θ
0
⎤
⎦.

72
Scientiﬁc Computing with MATLAB®
3.2.4
Hessian partial derivative matrix
For a given scalar function f(x1, x2, · · · , xn) with n independent variables, the deﬁnition
of a Hessian matrix is
H =
⎡
⎢⎢⎢⎣
∂2f/∂x2
1
∂2f/∂x1∂x2
· · ·
∂2f/∂x1∂xn
∂2f/∂x2∂x1
∂2f/∂x2
2
· · ·
∂2f/∂x2∂xn
...
...
...
...
∂2f/∂xn∂x1
∂2f/∂xn∂x2
· · ·
∂2f/∂x2
n
⎤
⎥⎥⎥⎦.
(3-2-4)
It can be seen that, a Hessian matrix is in fact a matrix second order derivatives of scalar
function f(x1, x2, · · · , xn), and the new MATLAB function hessian() can be used to ﬁnd
Hessian matrix, with H = hessian(f,x), where, x = [x1, x2, · · · , xn]. In earlier versions
of MATLAB, a Hessian matrix can be obtained with
H = jacobian(jacobian(f,x),x)
Example 3.19
Find the Hessian matrix for the function in Example 3.16.
Solution The following statements can be used directly
>> syms x y; f=(x^2-2*x)*exp(-x^2-y^2-x*y); % deﬁne original function
H=simplify(hessian(f,[x,y]))
% compute Hessian matrix
and the result is
H = e−x2−y2−xy

4x −2(2x −2)(2x + y) −2x2 −(2x −x2)(2x + y)2 + 2
2x −(2x −2)(x + 2y) −x2 −(2x −x2)(x + 2y)(2x + y)
2x −(2x −2)(x + 2y) −x2 −(2x −x2)(x + 2y)(2x + y)
x(x −2)(x2 + 4xy + 4y2 −2)

.
3.2.5
Partial derivatives of implicit functions
Assume that an implicit function is deﬁned as f(x1, x2, · · · , xn) = 0. The partial
derivative ∂xi/∂xj among the independent variables can be obtained using the following
formula
∂xi
∂xj
= −
∂
∂xj
f(x1, x2, · · · , xn)
∂
∂xi
f(x1, x2, · · · , xn)
.
(3-2-5)
Since the derivatives of f with respect to xi and xj can easily be obtained separately
with the function diff(), the partial derivative of ∂xi/∂xj can be obtained directly using
the MATLAB functions F = -diff(f,xj)/diff(f,xi).
For function f(x, y), if ∂y/∂x = F1(x, y) is found (here, partial derivative notation is
still used, so that the formula can be used directly in multivariate functions), the second
order derivative can easily be derived
F2(x, y) = ∂2y
∂x2 = ∂F1(x, y)
∂x
+ ∂F1(x, y)
∂y
F1(x, y).
(3-2-6)

Calculus Problems
73
Higher order derivatives can be formulated recursively from
Fn(x, y) = ∂ny
∂xn = ∂Fn−1(x, y)
∂x
+ ∂Fn−1(x, y)
∂y
F1(x, y)
(3-2-7)
The above recursive formula can easily be implemented with MATLAB, and directly
usable for multivariate functions. The nth order partial derivative f1 = ∂ny/∂xn can be
evaluated directly with the syntax f1 = impldiff(f,x,y,n). The listing of the function is
function dy=impldiff(f,x,y,n)
if mod(n,1)~=0 | n<0, error(’n should positive integer’)
else, F1=-simplify(diff(f,x)/diff(f,y)); dy=F1; %
ﬁrst-order
for i=2:n, dy=simplify(diff(dy,x)+diff(dy,y)*F1);
end, end
Example 3.20
Consider the implicit function f(x, y) = (x2 −2x)e−x2−y2−xy = 0. Please
ﬁnd ∂y/∂x and ∂3y/∂x3.
Solution The ﬁrst order derivative can be obtained directly, either by using Eqn (3-2-5),
or by the recursive function
>> syms x y; f=(x^2-2*x)*exp(-x^2-y^2-x*y); % special original function
F1=impldiff(f,x,y,1)
% compute directly 1st order derivative function
with the result
∂y
∂x = F1(x, y) = −3x3 + 6x2 + 4x −4
2x (x + 2y) (x −2)
−1
2.
Second and third order derivatives can be obtained with the recursive function
>> F2=impldiff(f,x,y,2), F3=impldiff(f,x,y,3),
[n,d]=numden(F3), simplify(n) % extract the numerator and denominator
and the results are
F2(x, y) = ∂2y
∂x2 = −3x4 −12x3 + 16x2 −8x + 8
2x2 (x + 2y) (x −2)2
−

−3x3 + 6x2 + 4x −4
2
2x2(x + 2y)3(x −2)2
,
F3(x, y) = ∂3y
∂x3 = −
−54x9 + (324 −54y) x8 +

−54y2 + 324y −482

x7
+

324y2 −616y −408

x6 +

−552y2 + 264y + 1164

x5
+

128y3 + 72y2 + 432y + 128

x4 −

256y4 + 192y2 + 96

+

64y4 −384y3 + 816y2 −416y −888

x3
+

−192y4 + 768y3 −672y2 + 384y + 96

x2
+

384y4 −512y3 + 384y2 −192y + 288

x
x3(x + 2y)5(x −2)3
.
Example 3.21
Please ﬁnd the derivatives of the function x2 + xy + y2 = 3 [3].
Solution The following statements can be used to ﬁnd the high order derivatives. Besides,
since x2 + xy + y2 = 3, the conditions can also be substituted back in the results to further
simplify them.
>> syms x y; f=x^2+x*y+y^2-3; F1=impldiff(f,x,y,1)
f2=impldiff(f,x,y,2); F2=subs(f2,x^2+x*y+y^2,3)
f3=impldiff(f,x,y,3); F3=subs(f3,x^2+x*y+y^2,3)
f4=impldiff(f,x,y,4); F4=subs(f4,x^2+x*y+y^2,3)

74
Scientiﬁc Computing with MATLAB®
and the following results can be obtained
F1 = −2x + y
x + 2y, F2 = −
18
(x + 2y)3 , F3 = −
162x
(x + 2y)5 , F4 = −648

4x2 + xy + y2
(x + 2y)7
,
where, sometimes the simpliﬁed results obtained with subs() may still not be the simplest
one. For instance, F4 may still be simpliﬁed manually as F4 = −1944(x2 + 1)
(x + 2y)7
.
It should be noted that the result F4 in new versions of MATLAB is not thus simple,
manual simpliﬁcations are needed.
3.2.6
Derivatives of parametric equations
When the function y(x) is given as parametric equations y = f(t), x = g(t), the nth
order derivative of the function dny/ dxn can be calculated recursively using the following
formula
dy
dx = f ′(t)
g′(t)
d2y
dx2 = d
dt
f ′(t)
g′(t)

1
g′(t) = d
dt
dy
dx

1
g′(t)
...
dny
dxn = d
dt
dn−1y
dxn−1

1
g′(t).
(3-2-8)
Using the recursive calling structure, the following MATLAB function can be written to
implement the above algorithm directory
function result=paradiff(y,x,t,n)
if mod(n,1)~=0 | n<0, error(’n should positive integer’)
else, if n==1, result=diff(y,t)/diff(x,t);
%
the exit
else, result=diff(paradiff(y,x,t,n-1),t)/diff(x,t); % recursive call
end, end
Example 3.22
For the parametric equations y =
sin t
(t + 1)3 , x =
cos t
(t + 1)3 , ﬁnd the third
order derivative d3y
dx3 .
Solution From the above parametric equations, the derivative can be found by
>> syms t; y=sin(t)/(t+1)^3; x=cos(t)/(t+1)^3; % input parametric equations
f=paradiff(y,x,t,3); [n,d]=numden(f); F=simplify(n)/simplify(d)
The results can be simpliﬁed into the following form:
d3y
dx3 = −3(t + 1)7[(t4 + 4t3 + 6t2 + 4t −23) cost −(4t3 + 12t2 + 32t + 24) sin t]
(t sin t + sin t + 3 cos t)5
.
3.2.7
Gradients, divergences and curls of ﬁelds
Fields are usually classiﬁed as scalar ﬁelds and vector ﬁelds. A scaler ﬁeld is represented
as a scalar function ϕ(x, y, z), and a vector ﬁeld is mathematically expressed as
v(x, y, z) = [X(x, y, z), Y (x, y, z), Z(x, y, z)].
(3-2-9)

Calculus Problems
75
Gradient of a scalar ﬁeld is deﬁned as
gradϕ(x, y, z) =
∂ϕ(x, y, z)
∂x
, ∂ϕ(x, y, z)
∂y
, ∂ϕ(x, y, z)
∂z

,
(3-2-10)
and the gradient converts a scalar ﬁeld into a vector ﬁeld. The gradient of function ϕ(x, y, z)
can be evaluated with g = jacobian(ϕ,[x,y,z]).
The divergence and curl of vector ﬁeld v(x, y, z) are deﬁned respectively as
div v(x, y, z) = ∂X(x, y, z)
∂x
+ ∂Y (x, y, z)
∂y
+ ∂Z(x, y, z)
∂z
,
(3-2-11)
curl v(x, y, z) =
∂Z
∂y −∂Y
∂z

,
∂X
∂z −∂Z
∂x

,
∂Y
∂x −∂X
∂y

.
(3-2-12)
The divergence and curl of vector function v can be evaluated with symbolic functions,
with d = divergence(v,[x,y,z]) and c = curl(v,[x,y,z]). The divergence of a vector
ﬁeld is a scalar function, and curl is a vector function. These functions can be nested to
evaluate complicated mathematical operations.
Example 3.23
For the given vector function
X(x, y, z) = x2 sin y, Y (x, y, z) = y2 sin xz, Z(x, y, z) = xy sin(cos z),
please compute the divergence and curl.
Solution
The vector function can be expressed ﬁrst, and the divergence and curl can be
obtained directly with the following statements
>> syms x y z; v=[(x^2)*sin(y), (y^2)*sin(x*z), x*y*sin(cos(z))];
d=divergence(v,[x,y,z]), c=curl(v,[x,y,z]) % direct computation
and the results are
d = 2y sin xz + 2x sin y −xy cos(cos z) sin z,
c =

x sin(cos z) −xy2 cos xz, −y sin(cos z) , y2z cos xz −x2 cos y

.
Example 3.24
Please show that curl [gradu(x, y, z)] = 0.
Solution The above property can easily be proven, if the following statements are issued,
where the results are a zero vector.
>> syms x y z u(x,y,z); v=jacobian(u,[x,y,z]); simplify(curl(v,[x,y,z]))
3.3
Analytical Solutions to Integral Problems
In calculus, integral problems are the inverse problems of derivative problems. The
integrals are often described mathematically as

f(x) dx,
 b
a
f(x) dx,

· · ·

f(x1, x2, · · · , xn) dxn · · · dx2 dx1
(3-3-1)

76
Scientiﬁc Computing with MATLAB®
where function f(·) is referred to as the integrand. The ﬁrst integral is referred to as
the indeﬁnite integral, while F(x) is referred to as the primitive function. The other two
integrals are respectively referred to as the deﬁnite integral and multiple integral. To solve the
integral problems, according to calculus courses, one has to select, largely by experience, the
integration methods, such as integration by substitution, or integration by parts, or others.
Therefore, solving integral problems could be a tedious task, and it may be totally dependent
upon the one’s experiences and skills. In this section, a skill and experience-independent
approach is presented.
3.3.1
Indeﬁnite integrals
The int() function provided in the Symbolic Math Toolbox of MATLAB can be used
directly to evaluate the indeﬁnite integrals to given functions. The syntax of the function is
F = int(fun,x), where the integrand can be described by the symbolic expression fun. If
only one variable appears in the integrand, the argument x can be omitted. The returned
argument is the primitive F(x). In fact, the general solution to the indeﬁnite integral
problem is F(x) + C, with C an arbitrary constant.
For any integrable functions, the use of the function int() can reduce the complicated
work such that the primitive function can be obtained directly. However, for symbolically
non-integrable functions, the int() function may not yield useful results either. In this case,
numerical methods have to be used instead.
Example 3.25 Consider the function given in Example 3.13. The diff() function can be
used to ﬁnd the derivatives of f(x). If the indeﬁnite integrals are made upon the results,
check whether the original function can be restored.
Solution The original function can be deﬁned and the integral can be taken on the ﬁrst-
order derivative such that
>> syms x; y=sin(x)/(x^2+4*x+3); y1=diff(y); y0=int(y1)
the result is exactly the same as the original function f(x). According to the rules of
indeﬁnite integrals, a group of functions f(x) + C are found.
Now consider taking the fourth-order derivative to the original function by applying
int() four times in a nested way as follows:
>> y4=diff(y,4); F=int(int(int(int(y4)))); simplify(F)
and the result is still the same as the original function. In fact, not only f(t), a cluster of
functions can also be constructed manually
F(x) =
sin x
x2 + 4x + 3 + C1 + C2x + C3x2 + C4x3.
Example 3.26
Show that

x3 cos2 ax dx = x4
8 +
x3
4a −3x
8a3

sin 2ax +
3x2
8a2 −
3
16a4

cos 2ax + C.
Solution The following MATLAB statements can be used:
>> syms a x; f=simplify(int(x^3*cos(a*x)^2,x)) % evaluate the left-hand side

Calculus Problems
77
and the simpliﬁed results can be obtained as
1
16a4

4a3x3 sin (2ax) + 2a4x4 + 6a2x2 cos (2ax) −6 ax sin (2ax) + 3 −3 cos (2ax)

.
It can be seen that the result is not the same as the one on the right-hand side. Let us
check the diﬀerence. Using the following scripts
>> f1=x^4/8+(x^3/(4*a)-3*x/(8*a^3))*sin(2*a*x)+...
(3*x^2/(8*a^2)-3/(16*a^4))*cos(2*a*x); % evaluate right-hand side
simplify(f-f1)
% diﬀerence is taken and simplify to see whether it is zero
After simpliﬁcation, the diﬀerence is −3/(16a4), not zero. However, fortunately, since
the diﬀerence between the two primitive functions is a constant, it can be included into the
ﬁnal constant C. Therefore, the original equation is proven.
Example 3.27
Consider the two integrands
f(x) = e−x2/2,
and
g(x) = x sin(ax4)ex2/2.
They are both known to be non-integrable. Compute the indeﬁnite integral to the two
functions.
Solution Let us consider ﬁrst the integral to the integrand f(x) = e−x2/2. The following
MATLAB functions can be used
>> syms x; int(exp(-x^2/2)) % evaluate integral directly
and the result obtained is
√
2π erf(
√
2x)/2. Since the original integrand is not integrable,
a special function erf(x) =
2
√π
 x
0
e−t2 dt is invented by mathematicians. Therefore, the
“analytical” solution to the original problem can be obtained.
The second integrand can be tested under the int() function, with the following
MATLAB statements
>> syms a x; int(x*sin(a*x^4)*exp(x^2/2)) % try to compute directly
and the returned message shows the same statement as the original command, meaning that
the explicit solutions cannot be obtained.
3.3.2
Computing deﬁnite, inﬁnite and improper integrals
If the indeﬁnite integral of f(x) can be written as F(x) + C, and F(x) has no
discontinuities in (a, b), the deﬁnite integral over the interval (a, b) can be obtained from
I = F(b) −F(a). In practical applications, the indeﬁnite integrals may not exist, however,
the deﬁnite or inﬁnite integrals may be needed. For instance, the special function erf(x)
in the previous examples cannot be directly solvable, while erf(1.5) is needed, numerical
methods should be used instead.
The deﬁnite integrals and improper integrals are also part of calculus. For instance,
although the function erf(x) is deﬁned previously, the integral of a particular value of
x cannot be obtained analytically. In this case, deﬁnite integrals, in cooperation with
numerical methods, can be obtained. The function int() can be used to evaluate the
deﬁnite and inﬁnite integrals. The syntax of the function is I = int(fun,x,a,b), where x is
the independent variable, (a, b) is the integral interval. For inﬁnite integrals, the arguments

78
Scientiﬁc Computing with MATLAB®
a and b can be assigned to -Inf or Inf. Also, if no exact value can be obtained directly,
the vpa() function can be used to evaluate the solutions numerically. Alternatively, if x is
not continuous in the interval [a, b], the integral is referred to as improper integral. Suppose
at x = c, a ⩽c ⩽b, the function f(x) is not continuous, the improper integral should be
evaluated mathematically with
 b
a
f(x) dx = lim
ϵ→0+
 c−ϵ
a
f(x) dx + lim
ϵ→0+
 b
c+ϵ
f(x) dx.
(3-3-2)
With MATLAB Symbolic Math Toolbox, the improper integral can be evaluated directly
with I = int(f,x,a,b), if the integral exists.
Example 3.28
Consider the integrands given previously in Example 3.27. When a = 0,
b = 1.5 (or ∞), evaluate the values of the integral.
Solution The following statements can be used in solving the deﬁnite and inﬁnite integral
problems
>> syms x; I1=int(exp(-x^2/2),x,0,1.5), vpa(I1,70)
I2=int(exp(-x^2/2),x,0,inf) % evaluate inﬁnite integral
where I1 =
√
2π erf(3
√
2/4)/2, and the high-precision numerical solution to the deﬁnite
integral is I1 = 1.0858533176660165697024190765422650425342362935321563267299172293
0853. The analytical solution to the inﬁnite integral is I2 =

π/2.
Example 3.29
Solve the deﬁnite integral problems for functional boundaries
I(t) =
 e−2t
cos t
−2x2 + 1
(2x2 −3x + 1)2 dx.
Solution The function int() can be used in solving deﬁnite integrals, and the following
statements can be used
>> syms x t real; f=(-2*x^2+1)/(2*x^2-3*x+1)^2; % input integrand
I=simplify(int(f,x,cos(t),exp(-2*t)))
% integral directly
and a piecewise result can be obtained. It is indicated in the result that, only when t > 0
and (cos t > 1/2 or ln2 < 2t), the integral can be found
I = −

e−2t −cos t
 
2e−2t cos t −1

(cos t −1) (2 cost −1) (e−2t −1) (2e−2t −1).
With the alternative integral approach, the primitive function F(x) can be found ﬁrst,
and the integral seems to be computable with I =F(b)−F(a). However, the assumption on
F(x) is continuous cannot be satisﬁed for all t, which means I = F(b)−F(a) should be used
conditionally. The conditions obtained above are the ones making I = F(b) −F(a) usable,
otherwise, the integral may be inﬁnite or unsolvable.
Example 3.30
Please evaluate the improper integral
 e
1
1
x

1 −ln2x
dx.
Solution It can be seen that at x = e, the integrand is discontinuous, therefore, the integral
is an improper integral. The problem can be solved directly with the following statements,
and the result is π/2.
>> syms x; f=1/x/sqrt(1-log(x)^2); I=int(f,x,1,exp(sym(1)))

Calculus Problems
79
3.3.3
Computing multiple integrals
Multiple integral problems can also be solved by using the same MATLAB function
int(). Generally speaking, usually the inner integrals should be carried out ﬁrst, and then,
outer integrals. However, the sequence of integrals should be observed. In each integration
step, the int() function can be used. Therefore, sometimes in certain integration steps, the
inner integral may not yield a primitive function, which results in no analytical solution to
the overall integral problem. If the sequence of integrals can be changed, analytical solutions
may be obtained. Numerical solutions to multiple integral problems will be presented in
Section 3.9.5.
Example 3.31
Compute the multiple integrals

· · ·

F(x, y, z) dx2 dy dz where the
integrand F(x, y, z) is deﬁned as
−4ze−x2y−z2
cos x2y −10yx2 cos x2y + 4x4y2 sin x2y + 4x4y2 cos x2y −sin x2y

.
Solution In fact, the above F(x, y, z) function was obtained by taking partial derivatives
to the function f(x, y, z) deﬁned in Example 3.17. Therefore, taking inverse operations in
this example should restore the same primitive function.
One may integrate once with respect to z, once to y and twice to x. The following results
can be obtained through simpliﬁcation
>> syms x y z; % evaluate integral in the sequential order z →y→x→x
f0=-4*z*exp(-x^2*y-z^2)*(cos(x^2*y)-10*cos(x^2*y)*y*x^2+...
4*sin(x^2*y)*x^4*y^2+4*cos(x^2*y)*x^4*y^2-sin(x^2*y));
f1=int(f0,z); f1=int(f1,y); f1=int(f1,x); f1=simplify(int(f1,x))
with the primitive function f1 = sin(x2y)e−x2y−z2, which is exactly the same as the one
deﬁned in Example 3.17.
Now if one alters the sequence of integrals, i.e., change the order to z →x →x →y,
the result is still the same. In earlier versions, diﬀerent sequences of integration may yield
diﬀerent results.
>> f2=int(f0,z); f2=int(f2,x); f2=int(f2,x); f2=simplify(int(f2,y))
Example 3.32
Compute the deﬁnite integral I =
 2
0
 π
0
 π
0
4xze−x2y−z2 dz dy dx.
Solution The following statements can be given to calculate the deﬁnite integral
>> syms x y z % compute directly the triple integral with simple command
I=int(int(int(4*x*z*exp(-x^2*y-z^2),z,0,pi),y,0,pi),x,0,2)
and the results obtained are
I = −

2e−π2 −2
 γ
2 + ln (2) + ln (π)
2
−Ei (−4π)
2

where eulergamma is the Euler constant γ, Ei(x) =
 x
−∞
et/t dt is an exponential integral.
The integrand is not integrable analytically. However, numerical solutions can be found.
Therefore, the accurate numerical solution to the original problem can be found from
vpa(ans) command, and the integral value is 3.10807940208541272.

80
Scientiﬁc Computing with MATLAB®
3.4
Series Expansions and Finite-term Series Approximations
Taylor series expansions to univariate and multivariate functions will be discussed in
this section. The Fourier series expansion to given functions are also to be discussed. In
particular, with the powerful graphics facilities in MATLAB, the ﬁtting quality and ﬁtting
interval can also be assessed using ﬁnite-term series approximations.
3.4.1
Taylor series expansion
I. Taylor series expansion of univariate functions
The Taylor series expansion about the point x = 0 can be written as
f(x) = a1 + a2x + a3x2 + · · · + akxk−1 + o(xk)
(3-4-1)
where the coeﬃcients ai can be obtained from
ai =
1
(i −1)! lim
x→0
di−1
dxi−1 f(x),
i = 1, 2, 3, · · · .
(3-4-2)
The expansion is also referred to as the Maclaurin series. If the Taylor series expansion is
made about the x = a point, the series can then be written as
f(x) = b1 + b2(x −a) + b3(x −a)2 + · · · + bk(x −a)k−1 + o[(x −a)k]
(3-4-3)
where the bi coeﬃcients can be obtained from
bi =
1
(i −1)! lim
x→a
di−1
dxi−1 f(x),
i = 1, 2, 3, · · · .
(3-4-4)
Taylor series expansion can be obtained by the use of the taylor() function, provided
in the Symbolic Math Toolbox. The syntaxes of the function are
f1 = taylor(fun,x,’Order’,k)
% Taylor series about x = 0 point
f1 = taylor(fun,x,’Order’,k,a)
% expansion about the x = a point
where fun is a symbolic expression of the original function, and x is the independent variable.
If there is only one independent variable in fun, x can be omitted. The argument k is the
order required in the expansion, with a default number of terms of 6. If an extra argument
a is given, the expansion is then made about the x = a point. The Taylor series expansion
solutions are demonstrated in the following examples. In old versions of Symbolic Math
Toolbox, the argument ’Order’ should not be provided.
Example 3.33
Consider again the function f(x) = sin x/(x2 + 4x + 3) given in Example
3.13. Find the ﬁrst 9 terms of Taylor series expansion about x = 0 point. Consider also the
series expansions about points x = 2 and x = a.
Solution The following statements can be used to specify the given function. The ﬁrst 9
terms of Taylor series expansion can be obtained with
>> syms x; f=sin(x)/(x^2+4*x+3); f1=taylor(f,x,’Order’,9)

Calculus Problems
81
and the result is
f1 = −386459x8
918540
+ 515273x7
1224720 −3067x6
7290
+ 4087x5
9720
−34x4
81
+ 23x3
54
−4x2
9
+ x
3 .
In classical calculus courses, no analysis had been made upon the ﬁtting quality of the
ﬁnite number of terms approximation for a given function, since there were no ready tools
available. With the use of MATLAB, the original function as well as the ﬁnite term Taylor
series approximation can be compared graphically as shown in Figure 3.4(a).
>> ezplot(f,[-1,1]), hold on; ezplot(f1,[-1,1]) % compare the functions
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−2
−1.5
−1
−0.5
0
f(x)
f1(x)
(a) (−1, 1) interval
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
−0.8
−0.6
−0.4
−0.2
0
0.2
(b) (−0.65, 0.65) interval
FIGURE 3.4: Finite term Taylor series approximation.
It can be seen that the 9th order Taylor series expansion for the original function is
not good for interval [−1, 1]. If the interval is reduced to (−0.65, 0.65), the ﬁtting quality
is shown in Figure 3.4(b) which is good enough. Therefore, with the graphical facilities in
MATLAB, the ﬁtting qualities can be examined easily.
Now consider the Taylor series expansion about the point x = 2. The series can be
derived using the following statement:
>> f2=taylor(f,x,’Order’,9,2) % expand about x = 2
Since the expansion is lengthy, only ﬁrst ﬁve terms are shown here
f2 = sin 2
15 +
cos 2
15 −8 sin 2
225

(x−2)−
127 sin2
6750
+ 8 cos2
225

(x−2)2
+
23 cos2
6750
+ 628 sin2
50625

(x−2)3 +

−15697
6075000 sin (2) +
28
50625 cos (2)

(x −2)4 .
If one wants to ﬁnd the series expansion about the x = a point, the Taylor series
expansion can still be derived using similar statements
>> syms a; f3=taylor(f,x,’Order’,9,a) % expand about x = a
Here only the ﬁrst three terms are shown
f3 =
sin a
a2 + 3 + 4a +

cos a
a2 + 3 + 4a −(4 + 2a) sin a
(a2 + 3 + 4a)2

(x −a) +

−
sin a
(a2 + 3 + 4a)2
−
sin a
2(a2+3+4a)−

a2 cos a+3 cosa+4a cosa−4 sina−2a sina

(4+2a)
(a2+3+4a)3
!
(x −a)2.

82
Scientiﬁc Computing with MATLAB®
Example 3.34
Expand the sinusoidal function y = sin x into Taylor series, and compare
the approximation quality for diﬀerent terms.
Solution In order to ﬁnd out the relationship between the ﬁtting quality and the number
of terms used, the loop structure should be used. The following statements can be issued to
solve the problem, where the ﬁtting curves shown in Figure 3.5 can be obtained.
−6
−4
−2
0
2
4
6
−1
−0.5
0
0.5
1
n=10
n = 6
n = 8
n=12
n = 14
FIGURE 3.5: Taylor series approximation to given sinusoidal functions.
>> syms x; y=sin(x); ezplot(y); hold on % plot original function
for n=[8:2:20], f1=taylor(y,x,’Order’,n), ezplot(f1); end % diﬀerent n
For fewer terms, the satisfactory ﬁtting interval is small. If the number of terms is
increased, the satisfactory ﬁtting interval will also increase. For instance, if one selects
n = 16, the ﬁtting is satisfactory over the interval (−2π, 2π). The ﬁrst 20 terms in the
Taylor series expansion are obtained as
sin x ≈x −1
6x3 +
1
120x5 −
1
5040x7 +
1
362880x9 −
1
39916800x11 +
1
6227020800x13
−
1
1307674368000x15 +
1
355687428096000x17 −
1
121645100408832000x19.
II. Taylor series expansion of multivariate functions
The Taylor series expansion of a multivariate function f(x1, x2, · · · , xn) is
f(x) = f(a) +

(x1 −a1) ∂
∂x1
+ · · · + (xn −an) ∂
∂xn

f(x)
""""
x=a
+
1
2!

(x1 −a1) ∂
∂x1
+ · · · + (xn −an) ∂
∂xn
2
f(x)
"""""
x=a
+ · · · +
1
k!

(x1 −a1) ∂
∂x1
+ · · · + (xn −an) ∂
∂xn
k
f(x)
"""""
x=a
+ · · ·
(3-4-5)
where (a1, · · · , an) is the center point of Taylor series expansion. In order to avoid
misunderstanding, the terms can be regarded as the derivatives of function fun. Then, the

Calculus Problems
83
function evaluation can be made to the point (a1, a2, · · · , an). The Taylor series expansion
to multivariate functions can be obtained from
F = taylor(f,[x1,x2,· · · ,xn],[a1,a2,· · · ,an],’Order’,k)
where k is the order of the expansion, and fun is the multivariate function.
Example 3.35
Consider again the function z = f(x, y) = (x2 −2x)e−x2−y2−xy shown in
Example 3.16. Find its Taylor series expansion.
Solution The following statements can be used to get the Taylor series expansion about
the origin
>> syms x y; f=(x^2-2*x)*exp(-x^2-y^2-x*y); % original function
F=taylor(f,[x,y],’Order’,8) % 8th order Taylor series expansion
whose mathematical representation is
F = x7
3 +

y + 1
2

x6 +

2y2 + y −1

x5 +
7y3
3
+ 3y2
2
−2y −1

x4
+

2y4+y3−3y2−y+2

x3 +

y5+ y4
2 −2y3−y2+2y+1

x2 +
y6
3 −y4+2y2−2

x
If one wants to expand the original function about x = 1, y = a point, the following
statements can be used
>> syms a; F=taylor(f,[x,y],[1,a],’Order’,3), F1=simplify(F)
and the expansion and its simpliﬁcation can be found as
F(x, y) = −e−a2−a−1 #a
2 + 1

(a + 2) −2

(x −1)2 −(2a + 1) (a −y)
−(a −y)2

(2a + 1)

a + 1
2

−1

+ (a + 2) (x −1) −1
+ (a −y) (x −1)

(2a + 1)
a
2 + 1

+ (a + 2)

a + 1
2

−1
$
F1(x) = −1
2 e−a2−a−1
4a4 −4a3x −8a3y + 8a3 + a2x2 + 4a2xy −12a2x
+ 4a2y2 −12a2y + 14a2 + 4ax2 + 10axy −12ax
+4ay2 −12ay + 10a + 2xy −4x −y2 −4y + 6

3.4.2
Fourier series expansion
Consider a periodic function f(x) deﬁned over the interval x ∈[−L, L]. The function is
with a period of T = 2L. For the function deﬁned on other intervals, it can be extended
to periodic functions such that f(x) = f(kT + x), where k is an arbitrary integer. A given
function f(x) can be approximated by an inﬁnite series such that
F(x) = a0
2 +
∞

n=1

an cos nπ
L x + bn sin nπ
L x

(3-4-6)

84
Scientiﬁc Computing with MATLAB®
where
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
an = 1
L
 L
−L
f(x) cos nπx
L
dx,
n = 0, 1, 2, · · ·
bn = 1
L
 L
−L
f(x) sin nπx
L
dx,
n = 1, 2, 3, · · · .
(3-4-7)
Such a series is referred to as the Fourier series and an, bn are referred to as Fourier
coeﬃcients. If the original function f(x) is periodic over arbitrary interval x ∈(a, b),
compute L = (b −a)/2, such that with variable substitution x = ˆx + L + a, the new
function f(ˆx) is mapped in ˆx ∈(−L, L), and the above expansion can be carried out.
Unfortunately, there is no existing function for Fourier series expansion provided in
MATLAB. Based on the above formula, the algorithm can be designed as follows
Require: Symbolic expression f(x), independent variable x
Set default variables p ←6, a ←−π, b ←π
Compute L = (b −a)/2, variable substitution x = ˆx + L + a in f(x)
Compute a0, from (3-4-7), compute F(ˆx) = a0/2
for n = 1 To p do
Compute and store an and bn from (3-4-7), update F(ˆx) from (3-4-6)
end for
Variable substitution ˆx = x −L −a, map F(ˆx) back to F(x).
The new function fseries() can be written to implement the algorithm, and it can be
seen that the MATLAB statements are very concise implementations of the algorithm.
function [F,A,B]=fseries(f,x,varargin) % construct Fourier series
[p,a,b]=default_vals({6,-pi,pi},varargin{:});
L=(b-a)/2; f=subs(f,x,x+L+a); A=int(f,x,-L,L)/L; B=0; F=A/2;
for n=1:p % loop structure for the ﬁrst p terms
an=int(f*cos(n*pi*x/L),x,-L,L)/L; % compute the coeﬃcients
bn=int(f*sin(n*pi*x/L),x,-L,L)/L;
A=[A,an]; B=[B,bn]; F=F+an*cos(n*pi*x/L)+bn*sin(n*pi*x/L);
end
F=subs(F,x,x-L-a); % variable substitution
A low-level supporting function to accept default argument is implemented in
default vals(), and it may be used by many other functions in the book
function varargout=default_vals(vals,varargin)
if nargout~=length(vals), error(’number of arguments mismatch’);
else, n=length(varargin)+1;
varargout=varargin; for i=n:nargout, varargout{i}=vals{i};
end, end, end
The syntax of the function is [F,A,B] = fseries(f,x,p,a,b), where f is the given
function; x is the independent variable; p is number of the terms required in the expansion
and (a, b) is the interval for x. If a, b arguments are omitted, the default interval [−π, π] will
be used. The returned arguments A, B contain the Fourier coeﬃcients, F is the symbolic
expression of the Fourier series expansion.

Calculus Problems
85
Example 3.36
Find the Fourier series expansion to the function y = x(x −π)(x −2π),
where x ∈(0, 2π).
Solution The Fourier series for the given function can easily be expressed
>> syms x; f=x*(x-pi)*(x-2*pi); [F,A,B]=fseries(f,x,12,0,2*pi)
where the ﬁrst 12 terms in the Fourier series are as follows:
F(x) = 12 sin x + 3 sin 2x
2
+ 4 sin 3x
9
+ 3 sin 4x
16
+ 12 sin 5x
125
+ sin 6x
18
+ 12 sin 7x
343
+3 sin8x
128
+ 4 sin 9x
243
+ 3 sin 10x
250
+ 12 sin 11x
1331
+ sin 12x
144
.
From these results, the analytical form can be summarized as f(x) =
∞

n=1
12
n3 sin nx.
The ﬁrst 12 terms in the Fourier series expansion and the original function can be
graphically compared as shown in Figure 3.6 (a) with the following statements
>> ezplot(f,[0,2*pi]), hold on, ezplot(F,[0,2*pi]) % comparisons
0
1
2
3
4
5
6
−10
−5
0
5
10
(a) over interval (0, 2π)
−2
0
2
4
6
8
−10
−5
0
5
10
(b) a larger interval (−π, 3π)
FIGURE 3.6: Accuracy of ﬁnite term Fourier series approximation.
If one wants to further examine the approximation over a larger interval x ∈(−π, 3π),
the following statements should be used
>> ezplot(f,[-pi,3*pi]), hold on, ezplot(F,[-pi,3*pi]) % larger interval
and the curves are shown in Figure 3.6 (b). It can be seen that over the (0, 2π) interval the
ﬁtting is quite good. In other regions, since the Fourier series is made upon the assumption
that it is periodically extended, therefore, it cannot approximate the original function in
other intervals at all.
Example 3.37 Now consider a square wave deﬁned over the interval (−π, π), where y = 1
when x ⩾0, and y = −1 otherwise. Expand the function using Fourier series and observe
how many terms in the function may give good approximation.
Solution Since in symbolic expressions inequality cannot be used, the square wave can be
expressed as f(x) = |x|/x. In this way, the numerical and analytical expressions in Fourier
series can be obtained for diﬀerent terms in the expression. The curves can be obtained as
shown in Figure 3.7 (a).

86
Scientiﬁc Computing with MATLAB®
>> syms x; f=abs(x)/x;
% square wave deﬁnition
xx=[-pi:pi/200:pi]; xx=xx(xx~=0); xx=sort([xx,-eps,eps]); % remove 0
yy=subs(f,x,xx); plot(xx,yy), hold on
% draw the original function
for n=1:20 % try diﬀerent orders of Fourier series
[f1,a,b]=fseries(f,x,n); y1=subs(f1,x,xx); plot(xx,y1)
end
−4
−3
−2
−1
0
1
2
3
4
−1.5
−1
−0.5
0
0.5
1
1.5
(a) over interval (−π, π)
−8
−6
−4
−2
0
2
4
6
8
−1.5
−1
−0.5
0
0.5
1
1.5
(b) a larger interval (−2π, 2π)
FIGURE 3.7: Approximation of square wave by Fourier series.
It can be seen that when 10 terms are used, the approximation is satisfactory. Even if
the number of terms increases, the ﬁtting accuracy may not be improved signiﬁcantly. A
ﬁnite Fourier series of the original function can be obtained by
>> [f1,a,b]=fseries(f,x,14); f1 % 14th order Fourier series expansion
and the expansion can be written as
f1(x) = 4sin x
π
+ 4 sin 3x
3π
+ 4 sin 5x
5π
+ 4 sin 7x
7π
+ 4 sin 9x
9π
+ 4 sin 11x
11π
+ 4 sin 13x
13π
,
which can further be summarized as f(x) = 4
π
∞

k=1
sin(2k −1)x
2k −1
.
Again the Fourier series expansion is established upon the assumption that it is
periodically extended over the original function, therefore, the ﬁtting in other intervals may
be incorrect, as shown in Figure 3.7 (b).
>> xx=[-2*pi:pi/200:2*pi]; xx=xx(xx~=0); xx=sort([xx,-eps,eps]);
yy=subs(f,x,xx); plot(xx,yy), y1=subs(f1,x,xx); line(xx,y1)
3.5
Inﬁnite Series and Products
Informally speaking, the term “series” is usually used to indicate the sum of sequences,
and sometimes it is also used to indicate a sequence. The two meanings are not strictly
distinguished in the book. In this section, the sum and product of sequences are introduced.
Also, the convergent intervals of inﬁnite series are also studied.

Calculus Problems
87
3.5.1
Series
The function symsum() provided in the Symbolic Math Toolbox can be used to evaluate
the sum of ﬁnite and inﬁnite series with known general terms. The syntax of the function is
S = symsum(fk,k,k0,kn), where fk is the general term of the series, k is the serial number,
and k0 and kn are the initial and ﬁnal terms of the series, respectively. They can be set to
inf for inﬁnite series. The sum of series can be written as
S =
kn

k=k0
fk.
(3-5-1)
If there is only one symbolic variable deﬁned in fk, the variable k can be omitted in the
function call.
Example 3.38
Compute the ﬁnite sum S = 20 + 21 + 22 + · · · + 262 + 263 =
63

i=0
2i.
Solution Numerical solution to the problem can be found from
>> format long; s=sum(2.^[0:63]) % evaluate the sum of 64 terms numerically
with s = 1.844674407370955×1019. Since the data type of double is used, only 16 digits can
be reserved. Therefore, the exact result cannot be obtained under double-precision scheme.
The function symsum() can be used to solve the problem
>> syms k; symsum(2^k,0,63) % evaluate the sum of 64 terms symbolically
where s1 = 18446744073709551615 can be obtained. The problem can even be solved with
a simpler command S = sum(sym(2).^[0:63]), and the same result can be obtained. The
method can be extended to calculate for more terms, for instance, it is possible to calculate
the sum to 201 terms
>> s2=symsum(2^k,0,200) % computing series with more terms
and s2 = 3213876088517980551083924184682325205044405987565585670602751. The exact
solution cannot possibly be obtained using the double-precision data type.
Example 3.39
Compute the inﬁnite series
S =
1
1 × 4 +
1
4 × 7 +
1
7 × 10 + · · · +
1
(3n −2)(3n + 1) + · · · .
Solution With the use of the symbolic function
>> syms n; s=symsum(1/((3*n-2)*(3*n+1)),n,1,inf) % compute inﬁnite series
the sum result s = 1/3 can be obtained. The same problem can be tried using numerical
method with double data type. For instance, if 10,000,000 terms are selected to be added
up, the following statements can be used directly
>> m=1:10000000; s1=sum(1./((3*m-2).*(3*m+1))); format long; s1
and the sum is s1 = 0.33333332222165. It can be seen that although a very large number of
terms are selected with a long time consumed, there still exists unavoidable diﬀerence and
the error reaches 10−6 level. It can be seen that when m = 107, the value of the general term

88
Scientiﬁc Computing with MATLAB®
is around 10−15, therefore, it seems that the additional error in the summation may not be
very large. In fact, since double-precision data type is used, some of the terms may not be
added to the S variable. Therefore, even though more terms are used in the summation, the
accuracy cannot be further increased.
Example 3.40
Evaluate the inﬁnite series with an extra variable x.
J = 2
∞

n=0
1
(2n + 1)(2x + 1)2n+1 .
Solution
In the examples studied earlier, numerical methods can be used to ﬁnd the
approximate solutions. If in the general term, extra independent variables are involved,
numerical methods can no longer be used. Symbolic method has to be used to solve the
problem. For instance, the sum can be evaluated with
>> syms n x; s1=symsum(2/((2*n+1)*(2*x+1)^(2*n+1)),n,0,inf);
s1=simplify(s1) % simplify the inﬁnite series
and a piecewise function can be the result. It can be read as when x > 0 or x < −1, the
sum is s1 = 2arctan(1/(2x + 1)). It can be seen that, not only the sum s1, the convergent
interval can also be obtained with only the new Symbolic Math Toolbox.
Example 3.41
Solve the limit problem with the series
lim
n→∞

1 + 1
2 + 1
3 + 1
4 + · · · + 1
n

−lnn

.
Solution
So far, the series and limit problems have been discussed and illustrated
separately. For this mixed problem, the following MATLAB statements can be used to solve
it, where the ﬁnite sum should be made ﬁrst using symsum(1/m,m,1,n)
>> syms m n; limit(symsum(1/m,m,1,n)-log(n),n,inf), vpa(ans)
and eulergamma can be obtained, i.e., the Euler constant γ can be obtained whose value can
be evaluated with vpa() function as γ = 0.57721566490153286060651209.
It should be noted that in the computation, one should not evaluate the inﬁnite sum
before limit. Otherwise, the original problem cannot be correctly solved.
Example 3.42
Please ﬁnd the sum
S = lim
n→∞

1 + 1
n2

sin π
n2 +

1 + 2
n2

sin 2π
n2 + · · · +

1 + n −1
n2

sin (n −1)π
n2

.
Solution
To get correct results, the general term must be extracted correctly. In this
example, the general term is ak = (1 + k/n2) sin(kπ/n2), with k = 1, 2, · · · , n−1. Thus,
the sum can be obtained from the statement below, and the result is S = π/2.
>> syms n k; % express the general term and ﬁnd inﬁnite series
S=simplify(limit(symsum((1+k/n^2)*sin(k*pi/n^2),k,1,n-1),n,inf))
3.5.2
Product of sequences
The computation of sequence product P =
b

n=a
f(n) can be directly obtained with the
MATLAB function symprod(), with P = symprod(fun,n,a,b)).

Calculus Problems
89
Example 3.43
Calculate the sequence product
∞

k=2

1 −
2
k(k + 1)

.
Solution The general term can be written as pk = 1 −2/k/(k + 1). Therefore, with the
following statements, the inﬁnite product is P = 1/3.
>> syms k; p=1-2/k/(k+1); P=symprod(p,k,2,inf) % inﬁnite product
Example 3.44
Please ﬁnd the inﬁnite sum of the series
S = 1 −1
2 + 1 × 3
2 × 4 −1 × 3 × 5
2 × 4 × 6 + 1 × 3 × 5 × 7
2 × 4 × 6 × 8 −1 × 3 × 5 × 7 × 9
2 × 4 × 6 × 8 × 10 + · · · .
Solution This is the series problem, while from the second term on, the general term is
the product of a ﬁnite series
sn = (−1)n
n

k=1
%
(2k −1)/(2k)
&
, with n = 1, 2, · · · , ∞.
Therefore, the original problem can be rewritten as S = 1 + '∞
n=1 sn, which can be
obtained with the following statements, and the sum is S =
√
2/2.
>> syms k n, s=(-1)^n*symprod((2*k-1)/(2*k),k,1,n); % general term
S=1+symsum(s,n,1,inf) % evaluate the inﬁnite series
Example 3.45
Please ﬁnd the product P =
∞

n=1

1 + x
n

e−x/n.
Solution The general term contains an independent variable x, however, this will not cause
any diﬃculties for the user. The problem can be solved with
>> syms n x; p=(1+x/n)*exp(-x/n); P=symprod(p,n,1,inf)
and the result is a piecewise function
P =

0,
x is a negative integer
e−γx/Γ(x + 1),
else, with γ the Euler constant
3.5.3
Convergence test of inﬁnite series
There are diﬀerent kinds of series in real applications, and sometimes, the closed-form
solution of the inﬁnite series cannot be obtained, even with function symsum() or other
powerful tools. The convergence test is important in such a case. An inﬁnite series
S = a1 + a2 + · · · + an + · · · =
∞

k=1
an
(3-5-2)
is said to be convergent, if the sum S has a ﬁnite limit, when n →∞. If the limit is inﬁnite,
the series is divergent. If an > 0 for all n, the series is referred to positive series.
There are several approaches in testing the convergence of a given series.
(i) If lim
n→∞an ̸= 0, the series is divergent.
(ii) If the series
∞

n=1
|an| is convergent, then,
∞

n=1
an is also convergent. Moreover, it is

90
Scientiﬁc Computing with MATLAB®
referred to as absolutely convergent.
For positive series, the following tests can be made.
(iii) D’Alembert’s test: Compute lim
n→∞
an+1
an
= ρ. If ρ < 1, the series is convergent; ρ > 1,
the series divergent; ρ = 1, the convergency cannot be assessed directly.
(iv) Raabe’s test: If ρ = 1 in (iii), then, compute lim
n→∞n
 an
an+1
−1

= R. If R > 1,
the series is convergent; if R < 1, it is divergent; while if R = 1, the convergency cannot be
assessed.
For alternating series, deﬁned as
S = b1 −b2 + b3 −b4 + · · · + (−1)n−1bn + · · · =
∞

n=1
(−1)n−1bn,
(3-5-3)
the following tests can be made.
(v) Compute lim
n→∞
bn+1
bn
= ρ. If ρ < 1, the series is absolutely convergent; ρ > 1, the
series divergent; ρ = 1, the convergency cannot be assessed directly.
(vi) If bn+1 ⩽bn, and the limit of bn is 0, the series is convergent.
(vii) Compute ρ = lim
n→∞n
 bn
bn+1
−1

, and for bn > 0, if ρ > 1, the series is absolutely
convergent; if 0 < ρ ⩽1, the alternating series is conditional convergent; otherwise, it is
divergent.
Example 3.46
Please test the convergency of the following inﬁnite series
S =
∞

n=1
2n
1 × 3 × 5 × · · · × (2n −1) =
∞

n=1
2n
n

k=1
(2k −1)
.
Solution For the positive series, the limit of an+1/an can be found easily with
>> syms n k positive; assume(n,’integer’); a=2^n/symprod(2*k-1,k,1,n)
F=simplify(subs(a,n,n+1)/a), L=simplify(limit(F,n,inf))
and it can be seen that the limit is 0, which means that the series is convergent. The term
an+1/an can be obtained, however, the simpliﬁed form cannot be obtained by computer.
Manual simpliﬁcations are made, with the ones after the ⇒sign.
an+1
an
= 4 (2n)! (n + 1)!
(2n + 2)! n!
⇒
4(2n)! (n + 1)n!
(2n + 2)(2n + 1)(2n)! n! =
2
2n + 1.
Example 3.47
Test the convergency of the following inﬁnite series
1
1 + 1
2 + 1
3 −1
4 −1
5 −1
6 + 1
7 + 1
8 + 1
9 −1
10 −1
11 −1
12 + · · ·
Solution Since it is well-known that inﬁnite series '∞
n=1 1/n is not convergent, the above
series is not absolutely convergent. Therefore, the convergency cannot be tested in this way.
We can express another alternating series with the entities in groups of 3, such that the
general term can be written as

Calculus Problems
91
bn =

1
3n −2 +
1
3n −1 + 1
3n

, n = 1, 2, 3, · · ·.
For the alternating series, (ii) is not applicable, since the limit is 1; with (v), manual
processing is needed, although it is obvious that bn+1 ⩽bn. Test (vii) can be tried with
>> b=1/(3*n-1)+1/(3*n-2)+1/(3*n); L=limit(n*(b/subs(b,n,n+1)-1),n,inf)
and, since L = 1 > 0, the alternating series is conditional convergent.
Example 3.48
A series of function is deﬁned by
∞

n=1
1 × 3 × 5 × · · · × (2n −1)
2 × 4 × 6 × · · · × (2n)
p x −1
2
n
, p is real.
Please ﬁnd the interval of x, such that the inﬁnite series is convergent.
Solution When the symbolic variables are deﬁned, the general term an can be expressed,
and the limit of an+1/an can be taken, and the simpliﬁed result is L = (x −1)/2. To make
the inﬁnite series convergent, |L| < 1 should be satisﬁed, and by solving |(x −1)/2| < 1, it
can be found that the convergent interval is x ∈(−1, 3).
>> syms n k positive; syms p real; assume(n,’integer’);
a=(symprod(2*k-1,k,1,n)/symprod(2*k,k,1,n))^p*((x-1)/2)^n;
F=simplify(subs(a,n,n+1)/a), L=simplify(limit(F,n,inf))
Let x = −1, the series is an alternating one, from (vii), it is found that L = p/2, which
means when p > 0, x = −1 is convergent. Therefore, x = −1 is referred to as a conditional
convergent boundary.
>> b=(symprod(2*k-1,k,1,n)/symprod(2*k,k,1,n))^p; % general term
L=limit(n*(b/subs(b,n,n+1)-1),n,inf)
% with Raabe-like test
If x = 3, it is a positive series, test (ii) also have L = p/2, which means that the point
is absolutely convergent when p > 2, otherwise, it is divergent. If x = −1, the series is also
absolutely convergent when p > 2.
3.6
Path Integrals and Line Integrals
Surprisingly, path integrals and line integrals cannot be solved by the existing MATLAB
functions. In this section, the concepts and integration method for path and line integrals
are summarized ﬁrst and then, solutions to these problems will be demonstrated through
examples.
3.6.1
Path integrals
Path integrals are originated from the evaluation of the total mass of a spatial wire with
unevenly distributed density. Assume that the density of a path l is f(x, y, z). Then, the
total mass of the wire can be evaluated from the following equation
I1 =

l
f(x, y, z) ds
(3-6-1)

92
Scientiﬁc Computing with MATLAB®
where ds is the arc length at a certain point. Thus, this kind of integral is also known as
the integral with respect to arc. If f(x, y, z) ≡1, i.e., the density is evenly distributed and
equals unity, the total length of the wire is calculated.
If the variables x, y and z are given respectively by parametric equations x = x(t),
y = y(t), z = z(t), they can be substituted into the f(·) function, and the diﬀerentiation of
the arc ds can be written as
ds =
(dx
dt
2
+
dy
dt
2
+
dz
dt
2
dt, or
ds =

x2
t + y2
t + z2
t dt.
(3-6-2)
Then, the path integral can be converted into an ordinary integral with respect to t
I =
 tM
tm
f[x(t), y(t), z(t)]

x2
t + y2
t + z2
t dt.
(3-6-3)
For the integrand with two variables, f(x, y), it can also be converted into ordinary
integrals. Therefore, the path integral problem can be solved with MATLAB using the
previously described procedures. Especially if the two variables satisfy y = y(x), the integral
can be simpliﬁed to
I =
 xM
xm
f[x, y(x)]

1 + y2x dx.
(3-6-4)
Based on the above formula, a MATLAB function can be written, where the integral
can be evaluated in the ﬁrst part of code, with the syntaxes
I = path integral(f,[x,y],t,tm,tM)
% 2D integral
I = path integral(f,[x,y,z],t,tm,tM)
% 3D integral
function I=path_integral(F,vars,t,a,b)
if length(F)==1, I=int(F*sqrt(sum(diff(vars,t).^2)),t,a,b);
else, F=F(:).’; vars=vars(:); I=int(F*diff(vars,t),t,a,b); end
In the syntaxes, [x, y] or [x,y,z] are the parametric equations of the curve, with two
and three independent variables. If the curve is deﬁned as y = f(x), the vector can also be
speciﬁed as [x,y].
Example 3.49
Compute

l
z2
x2 + y2 ds, where the path l is deﬁned by parametric
equations as x = a cos t, y = a sin t, z = at, with 0 ⩽t ⩽2π and a > 0.
Solution The following statements can be used for this path integral problem
>> syms t; syms a positive; x=a*cos(t); y=a*sin(t); z=a*t;
f=z^2/(x^2+y^2); I=path_integral(f,[x,y,z],t,0,2*pi)
and the result is I = 8
√
2
3 π3a.
Example 3.50
Compute

l
(x2 + y2) ds where path l is deﬁned as the positive direction
curve encircled by the paths y = x and y = x2.
Solution The following statements can be used to draw the two paths shown in Figure 3.8.
The arrows, shown in counterclockwise direction are deﬁned as the positive direction.

Calculus Problems
93
0
0.2
0.4
0.6
0.8
1
1.2
0
0.5
1
1.5
FIGURE 3.8: Illustration of the integration paths.
>> x=0:.001:1.2; y1=x; y2=x.^2; plot(x,y1,x,y2) % integral path
It can be seen that the original integration problem can be divided into two sub-integration
problems. Therefore, the following statements can be used to add the two sub-integrals up to
get the ﬁnal solutions
>> syms x; y=x; f=(x^2+y^2); I1=path_integral(f,[x,y],x,1,0)
y=x^2; f=(x^2+y^2); I2=path_integral(f,[x,y],x,0,1), I=I1+I2
and the result is
I = 349
768
√
5 −2
3
√
2 −7ln
√
5 + 2

512
.
3.6.2
Line integrals
Line integral problems are originated from physics, where the total work is done by the
force f(x, y, z) along a spatial curve l. This kind of integral problem can be expressed as
I2 =

l
f(x, y, z) ds
(3-6-5)
where f(x, y, z) = [P(x, y, z), Q(x, y, z), R(x, y, z)] is a row vector. The diﬀerentiation of the
line ds is a column vector. If the line can be described by a parametric equation of t such
as x(t), y(t), z(t), with t ∈(a, b), the vector ds can then be written as
ds =
dx
dt , dy
dt , dz
dt
T
dt.
(3-6-6)
The dot product of two vectors can be carried out directly, and the line integrals can be
redeﬁned as an ordinary integral as follows:
I2 =
 b
a
[P(x, y, z), Q(x, y, z), R(x, y, z)]
dx
dt , dy
dt , dz
dt
T
dt
(3-6-7)

94
Scientiﬁc Computing with MATLAB®
which can also be solved by using MATLAB function path integral(), and the code is
given in the second part of the function. The syntaxes of the function are
I = path integral([P,Q],[x,y],t,a,b)
% 2D and 3D integrals
I = path integral([P,Q,R],[x,y,z],t,a,b)
% with vector integrand
Example 3.51 Compute the integral

l
x + y
x2 + y2 dx−x −y
x2 + y2 dy, where the line l is deﬁned
as the positive circle given by x2 + y2 = a2, a > 0.
Solution
If one wants to evaluate the line integral, the circle can be interpreted as the
parametric equations x = a cost, y = a sin t for 0 ⩽t ⩽2π. Thus, the following statements
can be used to calculate the line integral, with the result I = 2π.
>> syms t; syms a positive; x=a*cos(t); y=a*sin(t);
F=[(x+y)/(x^2+y^2),-(x-y)/(x^2+y^2)];
I=path_integral(F,[x,y],t,2*pi,0) % integral
Example 3.52
Compute the line integral

l
(x2 −2xy) dx + (y2 −2xy) dy, where the line
l is deﬁned as the parabolic curve y = x2 (−1 ⩽x ⩽1).
Solution
In fact, the equations given are already the parametric equations of x. The
derivative of x with respective to x is 1. The following statements can be used to solve
the line integral problem, with the result I = −14/15.
>> syms x; y=x^2; F=[x^2-2*x*y,y^2-2*x*y]; % deﬁne 2D vector integrand
I=path_integral(F,[x,y],x,-1,1)
% evaluate integral
3.7
Surface Integrals
Two types of surface integrals are considered in this section, the scalar type and the
vector type. The deﬁnitions and solutions to the problems will be summarized ﬁrst followed
by the detailed solution procedures with MATLAB script-based examples.
3.7.1
Scalar surface integrals
The scalar-type surface integrals are deﬁned as
I =

S
φ(x, y, z) dS
(3-7-1)
where dS is the diﬀerentiated area. Thus, this kind of integral is also referred to as the surface
integrals with respect to area. If φ(x, y, z) ≡1, the area of the surface can be computed.
Let the surface S be deﬁned by z = f(x, y). The original surface integral can be converted
into a double integral over the x-y plane, such that
I =

σxy
φ[x, y, f(x, y)]

1 + f 2
x + f 2
y dx dy
(3-7-2)

Calculus Problems
95
where σxy is the integration region, which is an ordinary double integral problem.
The MATLAB implementation of the above formula is given in the ﬁrst part of the
following function, with the syntax
I = surf integral(f,z,[x,y],[ym,yM],[xm,xM])
function I=surf_integral(f,xx,uu,um,vm)
if length(f)==1 % scalar surface integral
if length(xx)==1 % surface by explicit function
I=int(int(f*sqrt(1+diff(xx,uu(1))^2+diff(xx,uu(2))^2),...
uu(2),um(1),um(2)),uu(1),vm(1),vm(2));
else
% surface described by parametric equation
xx=[xx(:).’ 1]; x=xx(1); y=xx(2); z=xx(3); u=uu(1); v=uu(2);
E=diff(x,u)^2+diff(y,u)^2+diff(z,u)^2;
F=diff(x,u)*diff(x,v)+diff(y,u)*diff(y,v)+diff(z,u)*diff(z,v);
G=diff(x,v)^2+diff(y,v)^2+diff(z,v)^2;
I=int(int(f*sqrt(E*G-F^2),u,um(1),um(2)),v,vm(1),vm(2));
end
else % vector surface integral
if length(xx)==1 % surface by explicit function
syms x y z; ua=sqrt(1+diff(xx,x)^2+diff(xx,y)^2);
cA=-diff(xx,x)/ua; cB=-diff(xx,y)/ua; cC=1/ua;
I=surf_integral(f(:).’*[cA; cB; cC],xx,uu,um,vm);
else, x=xx(1); y=xx(2); z=xx(3); u=uu(1); v=uu(2);
A=diff(y,u)*diff(z,v)-diff(z,u)*diff(y,v);
B=diff(z,u)*diff(x,v)-diff(x,u)*diff(z,v);
C=diff(x,u)*diff(y,v)-diff(y,u)*diff(x,v); % compute with (3-7-11)
F=A*f(1)+B*f(2)+C*f(3);
% integrand
I=int(int(F,uu(1),um(1),um(2)),uu(2),vm(1),vm(2));
end
end
Example 3.53 Compute

S
xyz dS, where the integral surface S is deﬁned as the region
enclosed by the four planes x = 0, y = 0, z = 0, x + y + z = a and a > 0.
Solution
Denote the four planes by S1,S2,S3 and S4. The original surface integral can
be calculated using

S
=

S1
+

S2
+

S3
+

S4
. Considering the planes S1, S2, S3,
since the integrands are all 0, only the integral on the S4 should be considered. The plane
S4 can mathematically be described as z = a −x −y, and the area of integral is then
0 ⩽y ⩽a −x, 0 ⩽x ⩽a. Then, the following statements can be used to evaluate the
surface integral
>> syms x y; syms a positive; z=a-x-y; f=x*y*z;
I=surf_integral(f,z,[x,y],[0,a-x],[0,a])
which gives I =
√
3a5/120.
If the parametric equations for the surface are given by
x = x(u, v), y = y(u, v), z = z(u, v),
(3-7-3)

96
Scientiﬁc Computing with MATLAB®
the surface integral can then be obtained using the following formula
I =

Σ
φ[x(u, v), y(u, v), z(u, v)]

EG −F 2 du dv
(3-7-4)
where
E = x2
u + y2
u + z2
u, F = xuxv + yuyv + zuzv, G = x2
v + y2
v + z2
v.
(3-7-5)
MATLAB implementation of the above formula are given in the second part of the
function surf integral(), with the syntax
I = surf integral(f,[x,y,z],[u,v],[um,uM],[vm,vM])
Example 3.54
Compute the surface integral

S
(x2y + zy2) dS, where the surface S is
deﬁned as x = u cosv, y = u sin v, z = v, 0 ⩽u ⩽a, 0 ⩽v ⩽2π.
Solution The following statements can be used to calculate the integrals
>> syms u v; syms a positive; x=u*cos(v); y=u*sin(v); z=v;
f=x^2*y+z*y^2; I=surf_integral(f,[x,y,z],[u,v],[0,a],[0,2*pi])
and the result is I = 1
8π2 
2a3
a2 + 1 −a

a2 + 1 −arcsinha

.
3.7.2
Vector surface integrals
The second category of surface integral is also referred to as the surface integrals in
vector ﬁelds. Suppose the integrand is given by a row vector Γ = [P, Q, R], while dv is
given by a column vector dv = [dy dz, dx dz, dx dy]T, the mathematical description to the
problem is
I =

S+Γ dv =

S+P(x, y, z) dy dz + Q(x, y, z) dx dz + R(x, y, z) dx dy,
(3-7-6)
where the positive surface S+ is deﬁned with z = f(x, y). The surface integral problem can
then be converted into the scalar surface integral problem
I =

S+ [P(x, y, z) cosα + Q(x, y, z) cos β + R(x, y, z) cos γ] dS
(3-7-7)
where z is replaced by f(x, y), and
cos α =
−fx

1 + f 2x + f 2y
, cos β =
−fy

1 + f 2x + f 2y
, cos γ =
1

1 + f 2x + f 2y
.
(3-7-8)
Therefore, the

1 + f 2
x + f 2
y term may cancel the relevant term in (3-7-2), and the
surface integral can be written as
I =

σxy
−Pfx dy dz −Qfy dx dz + R dx dy.
(3-7-9)
If the surface is described by the parametric equations in (3-7-3), the following equations
can be obtained
cos α=
A
√
A2+B2+C2 , cos β =
B
√
A2+B2+C2 , cos γ =
C
√
A2+B2+C2
(3-7-10)

Calculus Problems
97
where
A = yuzv −zuyv, B = zuxv −xuzv, C = xuyv −yuxv.
(3-7-11)
Then, from the converted scalar surface integral (3-7-7), it can be found that the
denominator in (3-7-10) cancels the

EG −F 2 term. Thus, the vector surface integral
can be simpliﬁed as the following standard double integral
I =
 vM
vm
 uM(v)
um(v)
[AP(u, v) + BQ(u, v) + CR(u, v)] du dv.
(3-7-12)
The above algorithms are implemented in surf integral() function, in the ﬁnal part
of the code, with the syntaxes
I = surf integral([P,Q,R],z,[u,v],[um,uM],[vm,vM])
I = surf integral([P,Q,R],[x,y,z],[u,v],[um,uM],[vm,vM])
Example 3.55
Compute the surface integral

x3 dy dz, where the surface S is deﬁned
as the positive side of the ellipsoid surface x2/a2 + y2/b2 + z2/c2 = 1.
Solution
The parametric equations can be introduced such that x = a sin u cos v, y =
b sin u sin v, z = c cos u and 0 ⩽u ⩽π
2 , 0 ⩽v ⩽2π. The following statements can be used
to compute the surface integral, with the result I = 2πa3cb/5.
>> syms u v; syms a b c positive;
x=a*sin(u)*cos(v); y=b*sin(u)*sin(v); z=c*cos(u);
I=surf_integral([x^3,0,0],[x,y,z],[u,v],[0,pi/2],[0,2*pi])
3.8
Numerical Diﬀerentiation
If the original function is symbolically given, the analytical solutions to the diﬀerentiation
problem can be obtained directly with the MATLAB built-in function diff(). The 100th
order derivative can be obtained within seconds. However, in some applications where the
original function is not known, only experimental data are given, the analytical or symbolic
methods cannot be used. In this case, numerical methods must be used to get the derivatives
from the experimental data. There is no dedicated function available in solving numerical
diﬀerentiation problems in MATLAB. Thus, simple numerical algorithms are presented in
this section with detailed implementation of the algorithms together with examples on how
to solve the numerical diﬀerentiation problems in MATLAB.
3.8.1
Numerical diﬀerentiation algorithms
Assume that there is a set of measured data (ti, yi) with evenly distributed time instances
ti = iΔt, i = 1, · · · , N, and the sample time is Δt. Theoretically, the derivative is deﬁned
as
dy(t)
dt
= lim
Δt→0
y(t + Δt) −y(t)
Δt
(3-8-1)

98
Scientiﬁc Computing with MATLAB®
However, unfortunately, in practical applications, the condition Δt →0 cannot be
satisﬁed. Therefore, only an approximated derivative can be obtained
y′
i ≈Δyi
Δt ;
y′
i = yi+1 −yi
Δt
+ o(Δt).
(3-8-2)
where, o(Δt) is inﬁnitesimal quantity, and it virtually means that the error is similar to the
scale of Δt. This formula is also referred to as the forward diﬀerence algorithm.
Similarly, backward diﬀerence formula is deﬁned as
y′
i ≈Δyi
Δt ;
y′
i = yi −yi−1
Δt
+ o(Δt).
(3-8-3)
When the value of Δt is large, the accuracy of the diﬀerentiation cannot be guaranteed.
So other improved numerical diﬀerentiation algorithms should be considered. For instance,
the central-point algorithm can be used. The ﬁrst-order derivative can also be deﬁned as
y′
i ≈yi+1 −yi−1
2Δt
+ o(Δt2).
(3-8-4)
High-order diﬀerentiation formulae can be similarly derived as follows:
y′′
i ≈yi+1 −2yi + yi−1
Δt2
y′′′
i ≈yi+2 −2yi+1 + 2yi−1 −yi−2
2Δt3
y(4)
i
≈yi+2 −4yi+1 + 6yi −4yi−1 + yi−2
Δt4
.
(3-8-5)
There is yet another set of central-point diﬀerence algorithms with even higher accuracy
of o(Δt4), deﬁned as follows:
y′
i ≈−yi+2 + 8yi+1 −8yi−1 + yi−2
12Δt
y′′
i ≈−yi+2 + 16yi+1 −30yi + 16yi−1 −yi−2
12Δt2
y′′′
i ≈−yi+3 + 8yi+2 −13yi+1 + 13yi−1 −8yi−2 + yi−3
8Δt3
y(4)
i
≈−yi+3 + 12yi+2 −39yi+1 + 56yi −39yi−1 + 12yi−2 −yi−3
6Δt4
.
(3-8-6)
3.8.2
Central-point diﬀerence algorithm with MATLAB
implementation
The numerical diﬀerentiation algorithm given in (3-8-6) has the error level of o(Δt4)
which can be used to solve numerical diﬀerentiation problems with higher numerical
accuracy. Even when Δt is not too small, good approximation can still be expected due
to its error level. Based on the algorithm, a MATLAB function is prepared as follows:
function [dy,dx]=diff_ctr(y,Dt,n)
y1=[y 0 0 0 0 0 0]; y2=[0 y 0 0 0 0 0]; y3=[0 0 y 0 0 0 0];
y4=[0 0 0 y 0 0 0]; y5=[0 0 0 0 y 0 0]; y6=[0 0 0 0 0 y 0];
y7=[0 0 0 0 0 0 y];
switch n

Calculus Problems
99
case 1,
dy=(-y1+8*y2-8*y4+y5)/12/Dt;
case 2,
dy=(-y1+16*y2-30*y3+16*y4-y5)/12/Dt^2;
case 3,
dy=(-y1+8*y2-13*y3+13*y5-8*y6+y7)/8/Dt^3;
case 4,
dy=(-y1+12*y2-39*y3+56*y4-39*y5+12*y6-y7)/6/Dt^4;
end
dy=dy(5+2*(n>2):end-4-2*(n>2)); dx=([2:length(dy)+1]+(n>2))*Dt;
The syntax of the function is [dy,dx] = diff ctr(y,Δt,n), where y is the vector
containing measured data for evenly distributed points, and Δt is the sample time. The
argument n speciﬁes the order of derivatives. The returned arguments dy is the derivative
vector computed, while the argument dx is the corresponding vector of independent
variables. It should be noted that the two vectors are a few points shorter than the original
y vector.
Example 3.56 The function deﬁned in Example 3.13 is still used in the demonstration of
the algorithm. Since the original function is known, the analytical solution can be obtained
for comparison. Sample data of the function can be generated from the function, and with
the help of the data, the derivatives of the ﬁrst- up to the fourth-order can be calculated,
and the results can be compared with the analytical solutions.
Solution An evenly spaced vector x is generated ﬁrst. Since the original function is known,
the analytical solutions to derivatives can be obtained. Then, if one substitutes the vector x
into the obtained analytical functions, the theoretical derivative vectors can be obtained for
comparison.
>> h=0.05; x=0:h:pi; syms x1; y=sin(x1)/(x1^2+4*x1+3);
yy1=diff(y); f1=subs(yy1,x1,x); % get the contrast data analytically
yy2=diff(yy1); f2=subs(yy2,x1,x); yy3=diff(yy2); f3=subs(yy3,x1,x);
yy4=diff(yy3); f4=subs(yy4,x1,x);
From the data points yi generated above, the ﬁrst-order up to the fourth-order derivatives
from the data can be calculated easily with the function diff ctr(), and the results are
shown in Figure 3.9 together with the exact solutions. It can be seen that one may not
observe the diﬀerence.
>> y=sin(x)./(x.^2+4*x+3);
% generate the data to be used
[y1,dx1]=diff_ctr(y,h,1); subplot(221), plot(x,f1,dx1,y1,’:’);
[y2,dx2]=diff_ctr(y,h,2); subplot(222), plot(x,f2,dx2,y2,’:’)
[y3,dx3]=diff_ctr(y,h,3); subplot(223), plot(x,f3,dx3,y3,’:’);
[y4,dx4]=diff_ctr(y,h,4); subplot(224), plot(x,f4,dx4,y4,’:’)
Quantitative studies for the fourth-order derivative show that the maximum error between
the exact results and the calculated results is as small as 3.5025×10−4.
>> double(norm((y4-f4(4:60))./f4(4:60))) % ﬁnd the norm of the error in f (4)(x)

100
Scientiﬁc Computing with MATLAB®
−0.5
0
0.5
−1
−0.5
0
0.5
0
1
2
3
0
1
2
3
0
1
2
3
−15
−10
−5
0
FIGURE 3.9: Comparisons of derivatives of diﬀerent orders.
3.8.3
Gradient computations of functions with two variables
Consider the function z(x, y) with two variables representing a 3D surface. The function
gradient() can be used to calculate the gradients for the function. The syntax of the
function is [fx,fy] = gradient(z), where the “gradients” fx and fy thus calculated are
not the actual gradients, since the coordinates x and y are not considered. If the matrix
z is obtained, the gradients can be obtained using the following statements fx = fx/Δx,
fy = fy/Δy, where Δx and Δy are respectively the step-sizes for x and y.
Example 3.57
Consider the function given in Example 3.16. Assume that the mesh grid
data can be generated. Compute the gradients of the original function and analyze the error.
Solution The data can be generated using the following statements. The gradients here are
obtained from the data rather than from the analytical function. The 3D attractive curves
can also be drawn as shown in Figure 3.10, and it should be the same as the one in Figure
3.3 (b).
>> syms x y; z=(x^2-2*x)*exp(-x^2-y^2-x*y); % symbolic expression
[x0,y0]=meshgrid(-3:.2:3,-2:.2:2); z0=subs(z,{x,y},{x0,y0}); % function
[fx,fy]=gradient(double(z0)); fx=fx/0.2; fy=fy/0.2; % compute gradient
contour(x0,y0,z0,30); hold on; quiver(x0,y0,fx,fy)
% draw quiver plot
The error surface is shown in Figure 3.10 where it can be seen that in most regions, the
errors are relatively small. In other areas, the errors are large. This means that the spacing
in the grid is too large to provide accurate gradient information. In order to reduce the error,
the step-size should be reduced.
>> zx=diff(z,x); zx0=double(subs(zx,{x,y},{x0,y0}));
zy=diff(z,y); zy0=double(subs(zy,{x,y},{x0,y0}));
subplot(121), surf(x0,y0,abs(fx-zx0)); axis([-3 3 -2 2 0,0.08])
subplot(122), surf(x0,y0,abs(fy-zy0)); axis([-3 3 -2 2 0,0.11])
If the spacing in grids is reduced both by half, the following statements can be used, and
the new error surface can be calculated again as shown in Figure 3.11. It can be observed
that the error is also reduced compared to Figure 3.10.

Calculus Problems
101
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
0
0.02
0.04
0.06
0.08
(a) ∂z/∂x
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
0
0.02
0.04
0.06
0.08
0.1
(b) ∂z/∂y
FIGURE 3.10: Error surface of the gradient of the function.
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
0
0.02
0.04
0.06
0.08
(a) ∂z/∂x
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
0
0.02
0.04
0.06
0.08
0.1
(b) ∂z/∂y
FIGURE 3.11: The error surface with reduced spacing in mesh grids.
>> [x1,y1]=meshgrid(-3:.1:3,-2:.1:2); z1=subs(z,{x,y},{x1,y1});
[fx,fy]=gradient(double(z1)); fx=fx/0.1; fy=fy/0.1;
z1=double(subs(zx,{x,y},{x1,y1})); z2=double(subs(zy,{x,y},{x1,y1}));
subplot(121), surf(x1,y1,abs(fx-z1)); axis([-3 3 -2 2 0,0.08])
subplot(122), surf(x1,y1,abs(fy-z2)); axis([-3 3 -2 2 0,0.1])
3.9
Numerical Integration Problems
Numerical integration problems are important in traditional numerical analysis courses.
In this section, several cases are considered. If the integrand is not known, integral can be
approximated based on a set of measured data. If the integrand is known but not integrable,
various integrals can be approximated numerically.

102
Scientiﬁc Computing with MATLAB®
3.9.1
Numerical integration from given data using trapezoidal method
Deﬁnite integral of a univariate function is deﬁned as
I =
 b
a
f(x) dx.
(3-9-1)
It is known that if the integrand f(x) is theoretically not integrable, even with the powerful
computer program, the analytical solutions to the problem cannot be obtained. Thus,
numerical solutions to the problems should be pursued instead. Numerical computation of
an integral of univariate function is also known as quadrature. There are various numerical
quadrature algorithms to solve the integration problem. The widely used algorithms include
the trapezoidal method, the Simpson’s algorithm, the Romberg’s algorithm, etc. The basic
idea of the algorithms is to divide the whole interval [a, b] into several sub-intervals [xi, xi+1],
i = 1, 2, · · · , N, where x1 = a and xN+1 = b. Then, the integration problem can be converted
to the summation problem as follows:
 b
a
f(x) dx =
N

i=1
 xi+1
xi
f(x) dx =
N

i=1
Δfi.
(3-9-2)
The easiest method is to use trapezoidal approximation to each sub-interval. The
numerical integration can be obtained by the use of trapz() function, whose syntax is
S = trapz(x,y), where x is a vector, and the number of rows of matrix y equals the
number of the elements in vector x. If the variable y is given as a multi-column matrix, the
numerical integration to several functions can be evaluated simultaneously.
Example 3.58
Compute the deﬁnite integrals to the functions sin x, cos x, sin x/2 within
the interval x ∈(0, π) using the trapezoidal algorithm.
Solution The vector for horizontal axis is generated ﬁrst and from it, the values of diﬀerent
functions can be evaluated such that the numerical integration can be obtained
>> x1=[0:pi/30:pi]’; y=[sin(x1) cos(x1) sin(x1/2)]; S=trapz(x1,y)
and the results are S = [1.99817196134365, 0, 1.99954305299081].
Since the step-size is selected as h = π/30 ≈0.1 which is considered as quite large, there
exist errors in the results. In Section 8.1.2, the algorithm will be used with the interpolation
method to improve the quality of numerical integration results.
Example 3.59
Compute
 3π/2
0
cos 15x dx with various step-sizes.
Solution
Before solving the problem, the following statements can be used to draw the
curves of the integrand as shown in Figure 3.12. It can be seen that there exists strong
oscillation in the integrand.
>> x=[0:0.01:3*pi/2, 3*pi/2]; y=cos(15*x); plot(x,y) % integrand curve
The theoretical solution to the problem is 1/15. For diﬀerent step-sizes, h = 0.1, 0.01,
0.001, 0.0001, 0.00001, 0.000001, the following statements can be used in approximately
solving the integrals. The relevant results are given in Table 3.1.
>> syms x, A=int(cos(15*x),0,3*pi/2)
% analytical solution
h0=pi./[30,300,3000,30000,300000,3000000]; v=[]; H=3*pi/2;

Calculus Problems
103
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
FIGURE 3.12: The plot of the integrand f(x) = cos 15x.
TABLE 3.1: Step-size selection and computation results.
step-size
integral
error
time (s)
step-size
integral
error
time (s)
π/30
0.052359878
0.0143
0.000
π/30000
0.066666653
1.35×10−8
0.0034
π/300
0.066529532
0.00014
0.0002
π/300000
0.066666667
1.35×10−10
0.0356
π/3000
0.066665296
1.35×10−6
0.005
π/3000000
0.066666667
1.35×10−12
0.266
for h=h0, % evaluate integral with diﬀerent step-sizes
tic, x=[0:h:H]; y=cos(15*x); I=trapz(x,y); v=[v; h,I,1/15-I]; toc
end
It can be seen that when the step-size h reduces, the integral accuracy increases. For
instance, if the step-size is selected as h = 10−6, 11 digits can be preserved in the result.
Thus, for this example, it takes as long as eight seconds for computation. If the step-size is
further reduced, the computational eﬀort demanded will be too high to be accepted.
3.9.2
Numerical integration of univariate functions
In traditional numerical analysis courses, several other numerical algorithms are usually
explored for univariate functions.
A new powerful numerical integration function integral() is introduced in MATLAB
8.0, and the syntaxes are
I = integral(fun,a,b), I = integral(fun,a,b,property pairs)
where fun can be used to specify the integrand. It can either be an M-ﬁle saved in fun.m
ﬁle, or an anonymous function or an inline function. The syntax of such a function should
be y = fun(x). The arguments a and b are the lower- and upper-bounds in the deﬁnite
integral, respectively. Other speciﬁcations can be described with property pairs and will be
illustrated through examples later. In earlier versions, the functions quad(), quadl() and
quadgk() should be used instead.
Example 3.60 For the integral erf(x) =
2
√π
 x
0
e−t2 dt, which was shown not integrable,

104
Scientiﬁc Computing with MATLAB®
compute the integral using numerical methods.
Solution Before ﬁnding the numerical integration of a given function, the integrand should
be speciﬁed ﬁrst. There are three ways for specifying the integrand.
(i) M-function The ﬁrst method is to express the integrand using a MATLAB function,
where the input argument is the variable x. Since many x values need to be processed
simultaneously, x vector can ﬁnally be used as the input argument, and the computation
within the function should be expressed in dot operations. An example for expressing such
a function is shown as follows, saved in c3ffun.m ﬁle.
function y=c3ffun(x)
% describe integrand with M-function
y=2/sqrt(pi)*exp(-x.^2); % dot operation should be used here
(ii) Anonymous function
Anonymous function expression is an eﬀective way for
describing the integrand. The format of the function is even more straightforward than the
inline expression. The integrand can be expressed by the anonymous function as follows:
>> f=@(x)2/sqrt(pi)*exp(-x.^2); % with anonymous function, no ﬁle needed
(iii) Inline function
The integrand can also be described by the old fashioned inline
function, where the input argument x should be appended after the integrand expression.
>> f=inline(’2/sqrt(pi)*exp(-x.^2)’,’x’);% inline function not recommended
It should be pointed out that the anonymous function expression is the fastest among the
three. The drawbacks of the representation are that it can only return one argument, and
function evaluations with intermediate computations are not allowed. Thus, the anonymous
function is used throughout the book whenever possible. If anonymous function cannot be
used, the M-function description will be used.
When the integrand has been declared by any of the above three methods, the integral()
function can be used to solve the deﬁnite integral problem
>> f=@(x)2/sqrt(pi)*exp(-x.^2); % anonymous function expression
I1=integral(f,0,1.5), I2=integral(@c3ffun,0,1.5)% same results
and I1 = I2 = 0.966105146475311. In fact, the high-precision solution to the same problem
can be obtained with the use of Symbolic Math Toolbox
>> syms x, y0=vpa(int(2/sqrt(pi)*exp(-x^2),0,1.5),60)
where y0 = 0.96610514647531071393693372994990579499622494325746147328575.
Comparing the results obtained above, it can be found that the accuracy of the numerical
method is the highest possible under double-precision scheme.
Example 3.61
Compute the integral of a piecewise function
I =
 4
0
f(x) dx, where f(x) =
⎧
⎨
⎩
ex2,
0 ⩽x ⩽2
80
4 −sin(16πx),
2 < x ⩽4.
Solution The piecewise function is displayed in ﬁlled curve in Figure 3.13. It can be seen
that the curve is not continuous at x = 2 point.
>> x=[0:0.01:2, 2+eps:0.01:4,4]; % x vector, with an extra value at 2+ϵ
y=exp(x.^2).*(x<=2)+80./(4-sin(16*pi*x)).*(x>2); % piecewise function
y(end)=0; x=[eps, x]; y=[0,y]; fill(x,y,’g’)
% intrgral area in green

Calculus Problems
105
0
0.5
1
1.5
2
2.5
3
3.5
4
0
10
20
30
40
50
60
FIGURE 3.13: Filled plot of the integrand.
With the use of relationship expressions, the integrand can be described and the functions
integral() can be used respectively to solve the original problem
>> f=@(x)exp(x.^2).*(x<=2)+80*(x>2)./(4-sin(16*pi*x));
I1=integral(f,0,4) % evaluate integral with default setting
and it is found that I1 = 57.764450125048498.
In fact, the original problem can also be divided into the integrals over (0, 2) and (2, 4)
intervals. The analytical solution function int() can then be used to ﬁnd the analytical
solutions to the original problem
>> syms x; I=vpa(int(exp(x^2),0,2)+int(80/(4-sin(16*pi*x)),2,4))
with I = 57.764450125053010333315235385182.
Compared with the analytical solutions, the results obtained by the integral() function
is not quite accurate. The property pair argument should be used. In this case, it is better to
the relative error tolerance, denoted by RelTol, to a very small number
>> I2=integral(f,0,4,’RelTol’,1e-20) % evaluate integral with error tolerance
the new result obtained is I2 = 57.764450125053017, again it is satisfactory under double-
precision scheme.
Example 3.62
Compute again the integral deﬁned in Example 3.59.
Solution
From the ﬁxed-step algorithm demonstrated in Example 3.59, it can be found
that only when the step-size is selected to be a very small value, the high accuracy can be
achieved. However, with the help of variable-step algorithms, the original problem can be
solved within a much shorter time and with much higher accuracy.
>> f=@(x)cos(15*x); tic, S=integral(f,0,3*pi/2), toc % numerical integral
It can be found that S = 0.06666666666667, and the elapsed time is 0.005 seconds, much
faster and more accurate than the ﬁxed-step method.
Thus, it can be concluded that the variable-step of integrals has much more advantages
than the ﬁxed-step method taught in numerical analysis courses. In real applications, this
function is highly recommended.

106
Scientiﬁc Computing with MATLAB®
Example 3.63
Please solve the integral in complex domain
 6−j5
2
e−x2−jx sin(7 + j2)x dx.
Solution If there are complex quantities in the integrand or boundaries, there is no extra
diﬃculties for the user to ﬁnd the results. The commands below can be used to ﬁnd accurate
results of I = −0.924460417702 + 25.7920728107j.
>> f=@(x)exp(-x.^2-1i*x).*sin((7+2i)*x); % integrand description
I=integral(f,2,6-5i,’RelTol’,1e-20)
% numerical integral
syms x; F=exp(-x^2-1i*x)*sin((7+2i)*x); I0=vpa(int(F,2,6-5i))
Example 3.64
Consider again the oscillatory problem in Example 3.59, with a much
larger interval [ 0, 100 ]. Please ﬁnd numerically the integral.
Solution Since the interval is too large and the oscillation is too strong in the integrand,
the numerical integral functions such as quadl(), quadgk() may all fail to get good results.
With the new integral() function, the result obtained is I1 = −0.066260130460300, while
with analytical method, I = sin(1500)/15 ≈−0.066260130460443564274.
>> f=@(x)cos(15*x); I1=integral(f,0,100,’RelTol’,1e-20) % numerical
syms x; I=int(cos(15*x),x,0,100), vpa(I) % analytical solution
3.9.3
Numerical inﬁnite integrals
The function integral() can be used to evaluate inﬁnite integrals directly. In earlier
versions, quadgk() function should be used [4]. For inﬁnite integrals, just write -inf or inf
in the appropriate intervals.
Example 3.65
Please evaluate the inﬁnite integral
 ∞
0
e−x2 dx.
Solution With the following numerical function call, the results obtained are
I = 0.886226925452758, I1 = √π/2 ≈0.88622692545275801365.
It can be seen that the error is around 10−16.
>> f=@(x)exp(-x.^2); I=integral(f,0,inf,’RelTol’,1e-20) % numerical
syms x; I1=int(exp(-x^2),0,inf), vpa(I1) % analytical solution
Example 3.66
For a given function I(α) =
 ∞
0
e−αx2 sin(α2x) dx, please draw the curve
of I(α) versus α, where α ∈(0, 4).
Solution
Previous discussed integrals are integrals of an individual function, while here
integrals of a series of functions (for diﬀerent α’s) are expected. With vectorized approach,
the following statements can be used, and the expected curve is shown in Figure 3.14. In
earlier versions, loop structures or quadv() function should be used.
>> a=0:0.1:4; f=@(x)exp(-a*x.^2).*sin(a.^2*x);
%
vector a is supported
I=integral(f,0,inf,’RelTol’,1e-20,’ArrayValued’,true); plot(a,I)

Calculus Problems
107
0
0.5
1
1.5
2
2.5
3
3.5
4
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
0.45
0.5
FIGURE 3.14: Integral I(α) versus α.
3.9.4
Evaluating integral functions
The numerical integrals discussed so far are deﬁnite integrals over the interval (a, b),
and the integral function curves cannot be obtained. Here, the integral function evaluation
problem is solved with the following function. The starting point of the integral function at
x = a is 0, since the deﬁnite integral in interval (a, a) is 0.
function [x,f1]=intfunc(f,a,b,n)
if nargin<=3, n=100; end; x=linspace(a,b,n); f1=0; f0=0;
for i=2:n,
f2=f0+integral(f,x(i-1),x(i),’RelTol’,1e-20); f1=[f1, f2]; f0=f2;
end
The syntax of the function is [x,f1] = intfunc(f,a,b,n), with the default value of n
as 100.
Example 3.67
Draw the integral curve of the piecewise function in Example 3.61.
Solution
Since the function ex2 in not integrable analytically, the curve of the integral
cannot be obtained with ezplot() function. Numerical methods should be used instead.
The piecewise integrand should be deﬁned ﬁrst as an anonymous function, then, function
intfunc() can be called to solve the original function and the curve is obtained as shown in
Figure 3.15. It can also be seen that the deﬁnite integral in Example 3.61 is the right hand
side point.
>> f=@(x)exp(x.^2).*(x<=2)+80./(4-sin(16*pi*x)).*(x>2);
[x1,f1]=intfunc(f,0,4,100); plot(x1,f1,x1(end),f1(end),’o’), f1(end)
Example 3.68
Evaluate numerically the Ei function Ei(x) =
 x
−∞
et/t dt, and draw the
curve in interval x ∈(1, 5).
Solution
Since the function intfunc() is written to evaluate integral functions in the
interval (−∞, x), and the function expected in the example is in the interval (1,5), the
original function can be written as the sum of integrals of two intervals, (−∞, 1) and (1, x).
The former one can be obtained with integral() function and the latter with intfunc().
The following statements can be issued, and the curve of Ei function is shown in Figure
3.16.

108
Scientiﬁc Computing with MATLAB®
0
0.5
1
1.5
2
2.5
3
3.5
4
0
10
20
30
40
50
60
FIGURE 3.15: Integral function curve obtained.
>> f=@(t)exp(t)./t; I0=integral(f,-inf,1); % integrand description
[x,I1]=intfunc(f,1,5); I=I1+I0; plot(x,I) % integral function plot
1
1.5
2
2.5
3
3.5
4
4.5
5
0
5
10
15
20
25
30
35
40
45
FIGURE 3.16: Plot of Ei function.
In fact, Ei function can be obtained directly with ei() function, it can be seen that the
curve shown in Figure 3.16 is exactly the same as the one by ei() function.
>> I2=ei(x); line(x,I2); % draw the curve of Ei function directly
3.9.5
Numerical solutions to double integrals
Now consider the double integrals deﬁned over a rectangular region
I =
 yM
ym
 xM
xm
f(x, y) dx dy,
(3-9-3)
and the function integral2() can be used to solve this type of problem, with the syntaxes
y = integral2(fun,xm,xM,ym,yM)
% double integral
y = integral2(fun,xm,xM,ym,yM,property pairs)
% more properties
while in old versions, function dblquad() should be used instead.

Calculus Problems
109
Example 3.69
Compute the double deﬁnite integral
J =
 1
−1
 2
−2
e−x2/2 sin(x2 + y) dx dy.
Solution With the anonymous function to describe the integrand, the double integral can
be evaluated numerically from the following statements
>> f=@(x,y)exp(-x.^2/2).*sin(x.^2+y);
% integrand description
I1=integral2(f,-2,2,-1,1,’RelTol’,1e-20) % numerical solutiom
syms x y; f=exp(-x.^2/2).*sin(x.^2+y);
% analytical solution process
I0=double(int(int(f,x,-2,2),y,-1,1))
% double precision display
and the result is I1 = 1.574498159218787, with I0 = 1.57449815921736. It can be seen that
the numerical result is quite accurate.
Implementing the same idea in intfunc(), mesh grid data of the integral function can
be obtained, and the surface of the integral can be obtained. Although sometimes the
integrands may be non-integrable, the surface can still be drawn with ease. The syntax of
the function is
[x,y,f1] = intfunc2(f,xm,xM,ym,yM,n,m)
where, f is the anonymous or M-function, (xm, xM) and (ym, yM) are integration rectangular
region, and n, m are the numbers of cells in x, y axes, with default values of 50. The returned
variable f1(end,end) is the value of the deﬁnite integral.
function [yv,xv,f1]=intfunc2(f,xm,xM,varargin)
[ym,yM,n,m]=default_vals({xm,xM,50,50},varargin{:});
xv=linspace(xm,xM,n); yv=linspace(ym,yM,m); d=yv(2)-yv(1);
[x y]=meshgrid(xv,yv); f2=zeros(n,m);
for i=2:n, for j=2:m,
f2(i,j)=integral2(f,xv(1),xv(i),yv(1),yv(j));
end, end
Example 3.70
Please draw the surface of the integral in Example 3.69.
Solution
The integrand is described by the anonymous function, and the surface of the
integral can be obtained as shown in Figure 3.17.
>> f=@(x,y)exp(-x.^2/2).*sin(x.^2+y); % integrand description
[y,x,z]=intfunc2(f,-2,2,-1,1); surf(x,y,z), I=z(end,end)
The new MATLAB function integral2() also supports the numerical solution of the
double integral deﬁned as
I =
 xM
xm
 yM(x)
ym(x)
f(x, y) dy dx.
(3-9-4)
In the syntax of the function integral2(), function handles can also be used for the
boundaries ym and yM, i.e., M-functions or anonymous functions can be used to describe
ym(x) and yM(x), while xm and xM must be ﬁxed numbers. Please note the order of
integrations is y ﬁrst, then to x.

110
Scientiﬁc Computing with MATLAB®
−1
−0.5
0
0.5
1
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
2
FIGURE 3.17: Surface of the integral.
Now consider the double integral, where the order of integration is x ﬁrst, then to y.
I =
 yM
ym
 xM(y)
xm(y)
f(x, y) dx dy.
(3-9-5)
The current version of the function integral2() does not support xm described with
function handles. Conversions must be made manually ﬁrst. Let ˆx = y, and ˆy = x, after
variable swopping, the original integral can be rewritten as
I =
 ˆxM
ˆxm
 ˆyM(ˆx)
ˆym(ˆx)
f(ˆy, ˆx) dˆy dˆx.
(3-9-6)
Comparing (3-9-5) and (3-9-6), it can be seen that the integral can be directly obtained,
by just swopping the orders of x and y in the integrand.
Example 3.71
Compute the double deﬁnite integral
J =
 1
−1/2
 √
1−x2/2
−√
1−x2/2
e−x2/2 sin(x2 + y) dy dx.
Solution This is the right integration order. Thus, the inner bounds yM(x) and ym(x) can
be deﬁned with anonymous functions, and then, the double integral can be evaluated directly
with
>> yM=@(x)sqrt(1-x.^2/2);
ym=@(x)-sqrt(1-x.^2/2); % inner bounds
f=@(x,y)exp(-x.^2/2).*sin(x.^2+y);
% integrand
I=integral2(f,-1/2,1,ym,yM,’RelTol’,1e-20)
% numerical integration
and the value of integration can be found as I = 0.411929546173382. Now consider the
analytical method
>> syms x y % analytical solution procedure
i1=int(exp(-x^2/2)*sin(x^2+y),y,-sqrt(1-x^2/2),sqrt(1-x^2/2));
int(i1,x,-1/2,1), I0=vpa(ans)
% warning message given
and it is prompted that the integral does not exist, and with vpa() function, the high-
precision numerical result can be written as 0.41192954617629511965175994017. It can be
seen that the numerical solutions are very accurate.

Calculus Problems
111
Example 3.72
If the original integral problem is changed to
J =
 1
−1
 √
1−y2
−√
1−y2 e−x2/2 sin(x2 + y) dx dy
the analytical problem cannot be used to ﬁnd the results, even with the help of vpa()
function. Numerical method should be tried. Since the order of the integration is ﬁrst to x,
then to y, the anonymous function of the integrand should just be described as f = @(y,x),
and the solution can be found
>> fh=@(y)sqrt(1-y.^2); fl=@(y)-sqrt(1-y.^2); % inner bounds
f=@(y,x)exp(-x.^2/2).*sin(x.^2+y);
% swopped order
I=integral2(f,-1,1,fl,fh,’RelTol’,eps)
% evaluate integral
which yields I = 0.536860382698816, which is still very easy. For numerical methods, the
numerical integration results will not be aﬀected by whether the integrand is theoretically
integrable or not.
3.9.6
Numerical solutions to triple integrals
The triple deﬁnite integral is described by
I =
 xM
xm
 yM
ym
 zM
zm
f(x, y, z) dz dy dx,
(3-9-7)
the problem can be solved with the integral3() function with the syntax
I = integral3(fun,xm,xM,ym,yM,zm,zM,property pairs)
where fun describes the integrand. The arguments ym,yM,zm,zM are all allowed to use
constants or function handles. It is required that the handles of z must be functions of
x and y, and handles of y must be functions of x. The boundaries of x must be constants.
Therefore, the triple integrals over non-rectangular regions can also be evaluated easily with
the function. Again, attention must be paid to the order of integral, which is z →y →x. If
the order is otherwise given, rearrange them in the description of integrand, before carrying
out numerical integral process.
Example 3.73
Compute the triple integral in Example 3.32
 2
0
 π
0
 π
0
4xze−x2y−z2 dz dy dx.
Solution
The anonymous function is used to specify the integrand. Therefore, the
following statements can be used to compute the triple integral, and the result is I =
3.108079402085465.
>> f=@(x,y,z)4*x.*z.*exp(-x.*x.*y-z.*z); % integrand in dot operation
tic, I=integral3(f,0,2,0,pi,0,pi,’RelTol’,1e-20), toc % solve directly
Example 3.74
Evaluate numerically the triple integral
 2
0
 1+x
1−x
 √
1−x2−y2
0
4xze−x2y−z2 dz dy dx.
Solution Fortunately for this example, the high-precision results can be obtained with the
statements as I0 = −177.14581094852176489995670313839.

112
Scientiﬁc Computing with MATLAB®
>> syms x y z; f=4*x*z*exp(-x^2*y-z^2);
I0=vpa(int(int(int(f,z,0,sqrt(1-x^2-y^2)),y,1-x,1+x),x,0,2))
In fact, the numerical solution to the integral can also be found easily with the following
statements, regardless whether the original problem is integrable or not. The numerical
solution is −177.1458109485222, and it is accurate enough for most practical applications.
>> f=@(x,y,z)4*x.*z.*exp(-x.^2.*y-z.^2); % describe integrand
zM=@(x,y)sqrt(1-x.^2-y.^2); ym=@(x)1-x; yM=@(x)1+x; % integral bounds
I=integral3(f,0,2, ym,yM, 0,zM,’RelTol’,1e-20) % numerical integral
3.9.7
Multiple integral evaluations
NIT Toolbox [5] can be used to solve multiple integral problems with other hyper-
rectangular regions. For instance, the quadndg() function can be used for these problems.
Consider the standard multiple integral given by
I =
 x1M
x1m
 x2M
x2m
· · ·
 xpM
xpm
f(x1, x2, · · · , xp) dxp · · · dx2 dx1,
(3-9-8)
the integral can be solved numerically with
I = quadndg(f,[x1m, x2m, · · · , xpm],[x1M, x2M, · · · , xpM],ϵ)
where, f is the M-function description of the integrand, and ϵ is the error tolerance.
Example 3.75
Solve again the triple integral problem in Example 3.73
 2
0
 π
0
 π
0
4xze−x2y−z2 dz dy dx.
Solution
Denote x1 = x, x2 = y, x3 = z, the original integrand can be rewritten as
f(x) = 4x1x3e−x2
1x2−x2
3, and anonymous or M-functions can be used to describe it, and
the integral can be evaluated numerically, with the result I = 3.108079402085409. It can be
seen that the result is almost the same as the one obtained in Example 3.73, however, the
eﬃciency is much higher — for this example, just 1/10 of the time required.
>> f=@(x)4*x(1)*x(3)*exp(-x(1)^2*x(2)-x(3)^2); % integrand description
tic, I=quadndg(f,[0 0 0],[2,pi,pi]), toc
% evaluation of integral
Example 3.76
Solve the pentaple integral problem
I =
 5
0
 4
0
 1
0
 2
0
 3
0
3√v√wx2y3z dz dy dx dw dv.
Solution For this example, its analytical solution can be found, as 120
3√
5.
>> syms x y z w v; F=v^(1/3)*sqrt(w)*x^2*y^3*z; % multiple integrand
I=int(int(int(int(int(F,z,0,3),y,0,2),x,0,1),w,0,4),v,0,5)
In practical situations, there is no analytical solutions to pentaple integrals. Numerical
approaches should be used instead. Denote x1 = v, x2 = w, x3 = x, x4 = y, x5 = z, the
integrand can be rewritten as
f(x) =
3√x1
√x2x2
3x3
4x5.

Calculus Problems
113
The integrand can be described with anonymous function, and the problem can be solved,
with I = 205.2205 ≈120
3√
5. The time elapsed for this example is about 48 seconds.
>> f=@(x)(x(1))^(1/3)*sqrt(x(2))*x(3)^2*x(4)^3*x(5); % describe integrand
tic, I=quadndg(f,[0 0 0 0 0],[5,4,1,2,3]), toc
% numerical integral
Example 3.77
Evaluate the pentaple integral problem.
I =
 5
0
 4
0
 1
0
 2
0
 3
0

e−3√v sin √w + e−x2y3z
dz dy dx dw dv.
Solution This integrand is not integrable, and numerical method should be used to solve
the problem. Denote again x1 = v, x2 = w, x3 = x, x4 = y, x5 = z, the integrand can be
rewritten as
f(x) = e−3√x1 sin √x2 + e−x2
3x3
4x5.
The following statements can be used, and the result is I = 113.60574122. Although the
integrand is much more complicated than the previous one, the time elapsed are almost the
same.
>> f=@(x)exp(-(x(1))^(1/3))*sin(sqrt(x(2)))+exp(-x(3)^2*x(4)^3*x(5));
tic, I=quadndg(f,[0 0 0 0 0],[5,4,1,2,3]), toc % numerical integral
Exercises
Exercise 3.1 Compute the following limit problems:
(i) lim
x→∞(3x + 9x)1/x,
(ii) lim
x→∞
(x + 2)x+2(x + 3)x+3
(x + 5)2x+5
, (iii) lim
x→a
tan x
tan a
cot(x−a)
,
(iv) lim
x→0
 
1
ln

x +
√
1 + x2 −
1
ln(1 + x)
!
,
(v) lim
x→∞

3
x3 + x2 + x + 1 −

x2 + x + 1 ln (ex + x)
x

.
Exercise 3.2 Please ﬁnd sequential limits lim
x→a

lim
y→b f(x, y)

and lim
y→b

lim
x→a f(x, y)

(i) f(x, y) = sin
πx
2x + y, a = ∞, b = ∞,
(ii) f(x, y) = 1
xy tan
xy
1 + xy , a = 0, b = ∞.
Exercise 3.3 Compute the following double limit problems:
(i)
lim
x→−1
y→2
x2y + xy3
(x + y)3 ,
(ii)
lim
x→0
y→0
xy
√xy + 1 −1, (iii)
lim
x→0
y→0
1 −cos

x2 + y2

x2 + y2
ex2+y2 .

114
Scientiﬁc Computing with MATLAB®
Exercise 3.4 Compute the derivatives of the following functions:
(i) y(x) =

x sin x
√
1 −ex,
(ii) y(t) =
(
(x −1)(x −2)
(x −3)(x −4),
(iii) atany
x = ln(x2 + y2),
(iv) y(x) = −1
na ln xn + a
xn
, n > 0.
Exercise 3.5 Please ﬁnd the 4th order derivative y(t) =
(
(x −1)(x −2)
(x −3)(x −4).
Exercise 3.6 Compute the 10th order derivative of the function y =
1 −√cos ax
x (1 −cos √ax).
Exercise 3.7 In calculus courses, when the limit of a ratio is required, where both the
numerator and the denominator tend to 0 or ∞, simultaneously, L’Hˆopital’s law can be
used, i.e., to evaluate the limits of derivatives of numerator and denominator. Verify the
limit
lim
x→0
ln(1 + x) ln(1 −x) −ln(1 −x2)
x4
by the consecutive use of L’Hˆopital’s law, and compare the result with the one directly
obtained with limit() function.
Exercise 3.8 For parametric equation
) x = ln cos t
y = cos t −t sin t,
compute dy
dx and d2y
dx2
""""
t=π/3
.
Exercise 3.9 Please ﬁnd the ﬁrst order derivatives for the parametric equations
(i)

x(t) = a(ln tan t/2 + cos t −sin t)
y(t) = a(sin t + cos t),
(ii)

x(t) = 2at/(1 + t3)
y = a(3at2)/(1 + t3).
Exercise 3.10 Assume that u = cos−1
*x
y . Verify that
∂2u
∂x∂y = ∂2u
∂y∂x.
Exercise 3.11 For a given function

xu + yv = 0
yu + xv = 1,
compute
∂2u
∂x∂y.
Exercise 3.12 Assume that f(x, y) =
 xy
0
e−t2 dt. Compute x
y
∂2f
∂x2 −2 ∂2f
∂x∂y + ∂2f
∂y2 .
Exercise 3.13 Please ﬁnd dy/ dx, d2y/ dx2 and d3y/ dx3 from the parametric equation
(i) x = e2t cos2 t, y = e2t sin2 t,
(ii) x = arc sin
t
√
1 + t2 , y = arc cos
t
√
1 + t2 .
Exercise 3.14 If x2 −xy + 2y2 + x −y −1 = 0, please calculate dy/dx, d2y/ dx2 and
d3y/ dx3 at x = 0, y = 1.
Exercise 3.15 Given a matrix f(x, y, z) =
 3x + eyz
x3 + y2 sin z

, compute its Jacobian matrix.

Calculus Problems
115
Exercise 3.16 If u = x −y + x2 + 2xy + y2 + x3 −3x2y −y3 + x4 −4x2y2 + y4, please ﬁnd
∂4u
∂x4 ,
∂4u
∂x3∂y and
∂4u
∂x2∂y2 .
Exercise 3.17 If u = ln
1

(x −ξ)2 + (y −η)2 , please ﬁnd
∂4u
∂x∂y∂ξ∂η.
Exercise 3.18 If z = ϕ

x2 + y2
, please ﬁnd y ∂z
∂x −x∂z
∂y .
Exercise 3.19 If u = xφ(x + y) + yϕ(x + y), please ﬁnd ∂2u
∂x2 −2 ∂2u
∂x∂y + ∂2u
∂y2 .
Exercise 3.20 Let z = F(r, θ), where r and θ are functions of x and y, deﬁned by system
of equations, x = r cos θ, y = r sin θ. Find ∂z/∂x and ∂z/∂y.
Exercise 3.21 Please ﬁnd the divergences and curls of the following vector function
(i) v(x, y) =

5x2y −4xy, 3x2 −2y

,
(ii) v(x, y, z) =

x2y2, 1, z

,
(iii) v(x, y, z) =

2xyz2, x2z2 + z cos yz, 2x2yz + y cos yz

.
Exercise 3.22 Compute the following indeﬁnite integrals:
(i) I(x) = −

3x2 + a
x2 (x2 + a)2 dx,
(ii) I(x) =


x(x + 1)
√x + √1 + x dx,
(iii) I(x) =

xeax cos bx dx, (iv) I(x) =
 earc tan x + x ln(1 + x2) + 1
1 + x2
dx,
(v) I(t) =

eax sin bx sin cx dx, (vi) I(x) =

dx

(1 + x2)ln(x +

1 + x2)
.
Exercise 3.23 Compute the deﬁnite integrals and inﬁnite integrals:
(i) I =
 ∞
0
cos x
√x dx,
(ii) I =
 1
0
1 + x2
1 + x4 dx,
(iii)
 1
e−2πn
""""cos

ln 1
x
"""" dx.
Exercise 3.24 Please ﬁnd the following deﬁnite integrals and improper integrals:
(i)
 0.75
0
1
(x + 1)
√
x2 + 1
dx,
(ii)
 1
0
arc sin√x

x(1 −x)
dx,
(iii)
 π/4
0
sin x −cos x
sin x + cos x
2n+1
dx.
Exercise 3.25 Please ﬁnd the integral I(s) =
 s
0
ex√
ex −1
ex + 3
dx.
Exercise 3.26 Laplace transform of a given function f(t) is deﬁned as F(s)
=
 ∞
0
e−stf(t) dt. Please ﬁnd the Laplace transforms to the following functions
(i) f(t) = 1,
(ii) f(t) = eβt,
(iii) f(t) = sin αt, (iv) f(t) = tm.

116
Scientiﬁc Computing with MATLAB®
Exercise 3.27 Please ﬁnd the following indeﬁnite integrals:
(i)
 sin2 x −4 sin x cos x + 3 cos2 x
sin x + cos x
dx, (ii)
 sin2 x −sin x cos x + 2 cos2 x
sin x + 2 cosx
dx.
Exercise 3.28 For the function f(x) = e−5x sin(3x + π/3), compute
 t
0
f(x)f(t + x) dx.
Exercise 3.29 Please ﬁnd the triple integral

V
x3y2z dx dy dz, where V is given by
0 ⩽x ⩽1, 0 ⩽y ⩽x, 0 ⩽z ⩽xy.
Exercise 3.30 Please ﬁnd the following multiple integrals:
(i)
 π
0
 π
0
|cos(x + y)| dx dy,
(ii)
 1
0
 1−x
−1
arc sin(x + y) dy dx,
(iii)

|x|+|y|⩽1
(|x| + |y|) dx dy,
(iv)

π2⩽x2+y2⩽4π2 sin

x2 + y2 dx dy.
Exercise 3.31 For diﬀerent values of a’s, please ﬁnd I =
 ∞
0
cos ax
1 + x2 dx.
Exercise 3.32 Please show that for any function f(t),
 b
a
f(t) dt = −
 a
b
f(t) dt.
Exercise 3.33 Please solve the multiple integral problems:
(i)
 2
0
 √
4−x2
0

4 −x2 −y2 dy dx, (ii)
 3
0
 3−x
0
 3−x−y
0
xyz dz dy dx,
(iii)
 2
0
 √
4−x2
0
 √
4−x2−y2
0
z(x2 + y2) dz dy dx,
(iv)
 1
0
 x
0
 y
0
 z
0
xyzue6−x2−y2−z2−u2 du dz dy dx,
(v)
 7/10
0
 4/5
0
 9/10
0
 1
0
 11/10
0

6 −x2 −y2 −z2 −w2 −u2 dw du dz dy dx.
Exercise 3.34 Compute the Fourier series expansions for the following functions, and
compare graphically the approximation and exact results, using ﬁnite numbers of terms:
(i) f(x) = (π −|x|) sin x, −π ⩽x < π,
(ii) f(x) = e|x|, −π ⩽x < π,
(iii) f(x) =

2x/l,
0 < x < l/2
2(l −x)/l,
l/2 < x < l
, where l = π.
Exercise 3.35 Obtain the Taylor series expansions for the following functions, and
compare graphically the approximation and exact results with ﬁnite numbers of terms:
(i)
 x
0
sin t
t
dt, (ii) ln
1 + x
1 −x

,
(iii) ln

x +

1 + x2

,
(iv) (1 + 4.2x2)0.2,
(v) e−5x sin(3x + π/3) expansions about x = 0 and x = a points, respectively.

Calculus Problems
117
Exercise 3.36 Find Taylor series expansions to the following multivariate functions:
(i) f(x, y) = ex cos y, about x = 0, y = 0, and x = a, y = b,
(ii) f(x, y) = ln(1 + x)ln(1 + y), about x = 0, y = 0 and x = a, y = b.
Exercise 3.37 Find Taylor series expansion of the function f(x, y) = 1 −cos

x2 + y2

x2 + y2
ex2+y2
about x = 1, y = 0 point.
Exercise 3.38 Compute the ﬁrst n term ﬁnite sums and inﬁnite sums:
(i)
1
1 × 6 +
1
6 × 11 + · · · +
1
(5n −4)(5n + 1) + · · ·
(ii)
1
2 + 1
3

+
 1
22 + 1
32

+ · · · +
 1
2n + 1
3n

+ · · ·
(iii) 1
3
x
2

+ 1 × 4
3 × 6
x
2
2
+ 1 × 4 × 7
3 × 6 × 9
x
2
3
+ 1 × 4 × 7 × 10
3 × 6 × 9 × 12
x
2
4
+ · · · .
Exercise 3.39 Find the sum of the following inﬁnite series:
(i)
∞

n=1
sin2 nα sin nx
n
,

0 < α < π
2

,
(ii)
∞

n=0
(−1)nn3
(n + 1)! xn, (iii)
∞

n=0
x4n+1
4n + 1.
Exercise 3.40 Compute the ﬁrst n term ﬁnite sums and inﬁnite sums of the following
series
(i)
3√x + ( 5√x −
3√x) + ( 7√x −
5√x) + · · · + ( 2k+1√x −
2k−1√x) + · · · ,
(ii) 1 + m
1! x + m(m −1)
2!
x2 + · · · + m(m −1) · · · (m −n + 1)
n!
xn + · · · .
Exercise 3.41 If the general terms an are known, please ﬁnd the inﬁnite sum:
(i) an =
√
1 + n −√n
p lnn −1
n + 1,
(ii) ak =
1
n1+k/lnn .
Exercise 3.42 Find the sum of the sequences:
(i)
∞

n=1
xn
(1+x)(1+x2) · · · (1+xn), (ii)
∞

n=2
(−1)n
n2+n−2, (iii)
∞

n=2
1
n2(n+1)2(n+2)2 .
Exercise 3.43 Compute the following limits:
(i) lim
n→∞

1
22 −1 +
1
42 −1 +
1
62 −1 + · · · +
1
(2n)2 −1

,
(ii) lim
n→∞n

1
n2 + π +
1
n2 + 2π +
1
n2 + 3π + · · · +
1
n2 + nπ

.
Exercise 3.44 Show that cos θ + cos 2θ + · · · + cos nθ = sin(nθ/2) cos[(n + 1)θ/2]
sin θ/2
.
Exercise 3.45 Please ﬁnd the products of the inﬁnite sequences:
(i)
∞

n=1
(2n+1)(2n+7)
(2n+3)(2n+5), (ii)
∞

n=1
9n2
(3n−1)(3n+1), (iii)
∞

n=1
a(−1)n/n, a > 0.

118
Scientiﬁc Computing with MATLAB®
Exercise 3.46 For an =
 π/4
0
tannx dx, compute S =
∞

n=1
1
n(an + an+2).
Exercise 3.47 Please assess the convergency of the following inﬁnite series:
(i)
∞

n=2

n
1 + n2
n
, (ii)
∞

n=10
1
lnn ln(lnx), (iii)
∞

n=1
(−1)n
n + 1
(n + 1)√n + 1 −1,
(iv) 3
2 −3 × 5
2 × 5 + 3 × 5 × 7
2 × 5 × 8 + · · · + (−1)n−1 3 × 5 × 7 × · · · × (2n + 1)
2 × 5 × 8 × · · · × (3n −1) + · · · .
Exercise 3.48 Please ﬁnd the interval of x, such that the inﬁnite series converge.
(i)
∞

n=1
(−1)n
 2n (n!)2
(2n + 1)!
p
xn, (ii)
∞

n=1
32n n
2n xn(1 −x)n, (iii)
∞

n=1
1
xn sin π
2n .
Exercise 3.49 Compute the following path and line integrals:
(i)

l
(x2 + y2) ds, l: x = a(cos t + t sin t), y = a(sin t −t cos t), for 0 ⩽t ⩽2π,
(ii)

l
(yx3 + ey) dx + (xy3 + xey −2y) dy, where l is given by the upper-semi-ellipsis of
a2x2 + b2y2 = c2,
(iii)

l
y dx−x dy+(x2+y2) dz, l: x=et, y=e−t, z =at, 0⩽t⩽1, for a>0,
(iv)

l
(ex sin y −my) dx + (ex cos y −m) dy, where l is deﬁned as the closed path from
(a, 0) to (0, 0), then, with the upper-semi-circle x2 + y2 = ax.
Exercise 3.50 Suppose a curve is described by polar function r = ρ(θ), with θ ∈(θm, θM),
the length of the curve can be evaluated from
L =
 θM
θm

ρ2(θ) + [dρ(θ)/ dθ]2 dθ.
Please ﬁnd the length of the curve ρ = a sin2 θ/3, θ ∈(0, 3π).
Exercise 3.51 Compute the surface integrals, where S is the bottom side of the semi-sphere
z =

R2−x2−y2.
(i)

S
xyz3 ds,
(ii)

S
(x + yz3) dx dy.
Exercise 3.52 For the measured data given in Table 3.2, evaluate numerically its
derivatives and deﬁnite integral.
TABLE 3.2: Computed data in Exercise 3.52.
xi
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1.1
1.2
yi
0
2.2077
3.2058
3.4435
3.241
2.8164
2.311
1.8101
1.3602
0.9817
0.6791
0.4473
0.2768

Calculus Problems
119
Exercise 3.53 Compute the gradient of the measured data in Table 3.3 for a function of
two variables. Assume that the data were generated by the function f(x, y) = 4 −x2 −y2.
Generate the data and verify the results of gradient with theoretical results.
TABLE 3.3: Computed data in Exercise 3.53.
0
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
4
3.96
3.84
3.64
3.36
3
2.56
2.04
1.44
0.76
0
0.2
3.96
3.92
3.8
3.6
3.32
2.96
2.52
2
1.4
0.72
−0.04
0.4
3.84
3.8
3.68
3.48
3.2
2.84
2.4
1.88
1.28
0.6
−0.16
0.6
3.64
3.6
3.48
3.28
3
2.64
2.2
1.68
1.08
0.4
−0.36
0.8
3.36
3.32
3.2
3
2.72
2.36
1.92
1.4
0.8
0.12
−0.64
1
3
2.96
2.84
2.64
2.36
2
1.56
1.04
0.44
−0.24
−1
1.2
2.56
2.52
2.4
2.2
1.92
1.56
1.12
0.6
0
−0.68
−1.44
1.4
2.04
2
1.88
1.68
1.4
1.04
0.6
0.08
−0.52
−1.2
−1.96
1.6
1.44
1.4
1.28
1.08
0.8
0.44
0
−0.52
−1.12
−1.8
−2.56
1.8
0.76
0.72
0.6
0.4
0.12
−0.24
−0.68
−1.2
−1.8
−2.48
−3.24
2
0
−0.04
−0.16
−0.36
−0.64
−1
−1.44
−1.96
−2.56
−3.24
−4
Exercise 3.54 Evaluate the deﬁnite integral
 π
0
(π −t)1/4f(t) dt, f(t) = e−t sin(3t + 1)
numerically. Also, evaluate the integration function F(t) =
 t
0
(t−τ)1/4f(τ) dτ numerically
for diﬀerent sample points of t, such that t = 0.1, 0.2, · · · , π, and draw the F(t) plot.
Exercise 3.55 Evaluate numerically the following multiple integral problems. It should
be noted that there are no analytical solutions to these problems. Therefore, the obtained
numerical results should be double-checked by varying step-sizes or default accuracies.
(i)
 2
0
 e−x2/2
0

4 −x2 −y2e−x2−y2 dy dx
(ii)
 2
0
 √
4−x2
0
 √
4−x2−y2
0
z(x2 + y2)e−x2−y2−z2−xz dz dy dx
(iii)
 7/10
0
 4/5
0
 9/10
0
 1
0
 11/10
0

6 −x2 −y2 −z2 −w2 −u2 dw du dz dy dx.
Bibliography
[1] Strang G. Calculus. Free textbook at http://ocw.mit.edu/ans7870/resources/Stran
g/strangtext.htm: Wellesley-Cambridge Press, 1991

120
Scientiﬁc Computing with MATLAB®
[2] Dawkins P. Calculus I, II, & III. http://tutorial.math.lamar.edu/pdf/CalcII/Calc
I Complete.pdf; http://tutorial.math.lamar.edu/pdf/CalcII/CalcII Complete
.pdf; http://tutorial.math.lamar.edu/pdf/CalcIII/CalcIII Complete.pdf, 2007
[3] Demidovich B P. Problems in mathematical analysis. Mowsco: MIR Publishers, 1970
[4] Shampine L F. Vectorized adaptive quadrature in MATLAB. Journal of Computational
and Applied Mathematics, 2008, 211(2):131–140
[5] Wilson H, Gardner B. Numerical integration toolbox (NIT).

Chapter 4
Linear Algebra Problems
Linear algebra deals with vectors, vector spaces or linear spaces, linear maps or linear
transformations and systems of linear equations. It is ubiquitous in modern applied
mathematics and almost all engineering ﬁelds. Although nonlinear models are true models
of the real world systems, in the natural sciences and the social sciences nonlinear models are
usually approximated by linear ones for initial eﬀective characterization. The importance
of linear algebra and the ability to solve linear algebra problems is obvious.
Although many readers might not be able to quickly compute the determinant of a given
3×3 or even 4×4 matrix by hand, one should not feel bad about this inability. We leave this
low-level computation to computer mathematics languages, such as MATLAB. In fact, many
computer mathematics languages, such as MATLAB, originated from the early research of
numerical linear algebra. For instance, the well-known EISPACK package [1] focused on
the computation of eigen-systems of matrices. Another well-known package, LINPACK [2],
was developed to solve general linear algebra problems using numerical algorithms. With
the development of computer science, matrix computations are now no longer restricted
to numerical computations. Analytical solutions can also be found for many linear algebra
problems. Successful computer mathematics languages such as Mathematica, Maple and
the Symbolic Math Toolbox of MATLAB can be used to analytically solve certain problems
in linear algebra.
In Section 4.1, as a warming up, how to input some special matrices, such as identity
matrix, companion matrix and Hankel matrix, and symbolic matrices is presented. In the
section, arbitrary matrix input can also be entered in MATLAB workspace. In Section
4.2, basic concepts of matrix analysis are presented and illustrative MATLAB scripts are
given for solving matrix determinant, trace, rank, norm, inverse matrix and eigen-system
problems. Matrix decomposition methods such as similarity transformation, orthogonal
decomposition, triangular factorization and singular value decomposition are explained and
demonstrated in Section 4.3. These decomposition methods can be used to simplify matrix
analysis problems among many other potential beneﬁts. Section 4.4 presents solutions
to various matrix equations, such as linear algebraic equations, Lyapunov equations,
Sylvester equations as well as Riccati equations. An example in the solution of polynomial
Diophantine equation is also presented. Both analytical solution algorithms and their
MATLAB implementations are given. In Section 4.5, evaluations of matrix functions such
as exponential functions and trigonometry functions will be discussed. In particular, this
chapter ends with an introduction of a general method for computing matrix functions
of arbitrary forms and power of matrix by using detailed illustrative examples with the
respective MATLAB scripts.
For readers who wish to check the detailed explanations of linear algebra, we recommend
the free textbooks [3–5]. In fact, the materials covered in the chapter are far beyond those
in conventional linear algebra textbooks.
121

122
Scientiﬁc Computing with MATLAB®
4.1
Inputting Special Matrices
4.1.1
Numerical matrix input
Although all the matrices can be entered into MATLAB workspace using the low-
level statement discussed earlier, it might be complicated for some matrices with special
structures. For instance, if one wants to enter an identity matrix, one should use the existing
function eye() instead. In this section, the speciﬁcations of some special matrices will be
presented.
I. Matrices of zeros, ones and identity matrices
In matrix theory, a matrix with all its elements 0 is referred to as a zero matrix, while
a matrix with all its elements 1 is referred to as a matrix of ones. If the diagonal elements
are 1 with the rest of the elements 0, the matrix is referred to as an identity matrix. This
concept can be extended to m × n matrices. Matrix of zeros, matrix of ones and identity
matrix can be entered into MATLAB using the following statements
A = zeros(n), B = ones(n), C = eye(n)
% n × n square matrix
A = zeros(m, n); B = ones(m, n); C = eye(m, n)
% m × n matrix
A = zeros(size(B))
% with the same size of B
Example 4.1
Please generate a 3 × 8 zero matrix A and an extended identity matrix B,
with the same size of A.
Solution
The matrices can be entered into MATLAB environment using the following
statements
>> A=zeros(3,8), B=eye(size(A)) % the matrices can be entered easily
The two matrices can be established in MATLAB workspace
A =
⎡
⎣
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
⎤
⎦, B =
⎡
⎣
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
⎤
⎦.
Functions zeros() and ones() can also be used to deﬁne multi-dimensional arrays. For
instance, zeros(3,4,5) can be used to deﬁne a 3×4×5 zero array.
II. Matrices with random elements
If all the elements in a matrix satisfy uniform distribution within the [0, 1] interval, it
can be deﬁned using MATLAB function rand(). The syntaxes of such a function are as
follows
A = rand(n)
% generates an n × n uniformly distributed random matrix
A = rand(n,m)
% generates an n × m random matrix
Function rand() can also be used to deﬁne multi-dimensional random arrays. Another
function randn() can be used to deﬁne standard normal distributed random matrices. The
statement B = rand(size(A)) can be used to declare a random matrix of size A.

Linear Algebra Problems
123
Here, the random number is in fact pseudorandom numbers, and can be generated
mathematically. It is easy to generate random numbers satisfying certain predeﬁned
distributions. Another advantage of pseudorandom numbers are that they can be generated
repeatedly.
If one wants to obtain a uniformly distributed random number over (a, b) interval,
one may generate uniformly distributed pseudorandom matrix V = rand(n,m) over (0, 1)
interval, then, the expected matrix can be generated by V1 = a + (b −a)*V command.
If all the elements satisfy a standard normal distribution N(0,1), i.e., normal distribution
with zero mean and unity variance, command V = randn(n,m) can be used. If a normal
distribution of N(μ, σ2) is satisﬁed, the sequence can be generated with V1 = μ + σ*V should
be used.
III. Diagonal matrices
Mathematical description to a diagonal matrix is
diag(α1, α2, · · · , αn) =
⎡
⎢⎢⎢⎣
α1
α2
...
αn
⎤
⎥⎥⎥⎦,
(4-1-1)
where all the non-diagonal elements are 0. A MATLAB function diag() can be used to
deal with diagonal matrix related problems
A = diag(V )
% deﬁne a matrix from given vector
V = diag(A)
% extract diagonal vector from a given matrix
A = diag(V ,k)
% deﬁne the kth diagonal elements V
Example 4.2
MATLAB function diag() is an interesting function. Diﬀerent syntaxes
are allowed for diﬀerent tasks. For instance, the following statements can be used to deﬁne
diﬀerent matrices
>> C=[1 2 3]; V=diag(C), V1=diag(V)
C=[1 2 3]; V2=diag(C,2), V3=diag(C,-1) % use of diag() function
and they yield
V =
⎡
⎣
1
0
0
0
2
0
0
0
3
⎤
⎦, V1 =
⎡
⎣
1
2
3
⎤
⎦, V2 =
⎡
⎢⎢⎢⎢⎣
0
0
1
0
0
0
0
0
2
0
0
0
0
0
3
0
0
0
0
0
0
0
0
0
0
⎤
⎥⎥⎥⎥⎦
, V3 =
⎡
⎢⎢⎣
0
0
0
0
1
0
0
0
0
2
0
0
0
0
3
0
⎤
⎥⎥⎦.
In fact, k can be assigned to negative integers, indicating one wants to specify the kth
lower-diagonal elements. With the use of such properties
>> V=diag([1 2 3 4])+diag([2 3 4],1)+diag([5 4 3],-1) % tri-diagonal
the tri-diagonal matrix V =
⎡
⎢⎢⎣
1
2
0
0
5
2
3
0
0
4
3
4
0
0
3
4
⎤
⎥⎥⎦can then be established.

124
Scientiﬁc Computing with MATLAB®
Assume that
there exist
the
following matrices A1,
A2,
· · · , An,
the
MAT-
LAB function blkdiag() can be used to generate block diagonal matrix A, with
A = blkdiag(A1,A2,· · · ,An), such that
A =
⎡
⎢⎢⎢⎣
A1
A2
...
An
⎤
⎥⎥⎥⎦.
(4-1-2)
IV. Hankel matrices
The general form of a Hankel matrix is given below, with all the elements in each back-
diagonal the same.
H =
⎡
⎢⎢⎢⎣
c1
c2
· · ·
cm
c2
c3
· · ·
cm+1
...
...
...
...
cn
cn+1
· · ·
cn+m−1
⎤
⎥⎥⎥⎦.
(4-1-3)
In MATLAB, the Hankel matrix based on two given vectors c and r can be constructed
by H = hankel(c,r), and the ﬁrst column of matrix H can be assigned to vector c, with
the last row assigned to r. Thus, using the properties of a Hankel matrix, the full Hankel
matrix can then be established.
If there is only one vector c speciﬁed, the command H = hankel(c) can be used to
construct an upper-triangular Hankel matrix.
Example 4.3
Establish the following Hankel matrices using MATLAB statements
H1 =
⎡
⎣
1
2
3
4
5
6
7
2
3
4
5
6
7
8
3
4
5
6
7
8
9
⎤
⎦,
H2 =
⎡
⎣
1
2
3
2
3
0
3
0
0
⎤
⎦.
Solution
In order to construct the above Hankel matrix, the c and r vectors should
be assigned to c = [1,2,3], r = [3 4 5 6 7 8 9]. The Hankel matrices can then be
established with the following statements.
>> c=[1 2 3]; r=[3 4 5 6 7 8 9]; H1=hankel(c,r), H2=hankel(c)
V. Hilbert matrices and their inverses
Hilbert matrix is a special matrix whose (i, j)th element is deﬁned as hi,j = 1/(i+j −1).
An n × n square Hilbert can be written as
H =
⎡
⎢⎢⎢⎣
1
1/2
1/3
· · ·
1/n
1/2
1/3
1/4
· · ·
1/(n + 1)
...
...
...
...
...
1/n
1/(n + 1)
1/(n + 2)
· · ·
1/(2n −1)
⎤
⎥⎥⎥⎦.
(4-1-4)
The syntax for generating the Hilbert matrix is A = hilb(n).
Large-sized Hilbert matrices are bad-conditioned matrices. Overﬂow will often occur
during inverting such a matrix. Thus, a direct inverse Hilbert matrix can be obtained with
function B = invhilb(n).
Since Hilbert matrices are very close to singular matrices, one must be very careful

Linear Algebra Problems
125
in dealing with such matrices. It is suggested here that symbolic computation be used. If
numerical methods are used, do validate the results.
VI. Vandermonde matrices
For a given sequence c = {c1, c2, · · · , cn}, a Vandermonde matrix can be established
such that the (i, j)th element is deﬁned as vi,j = cn−j
i
, i, j = 1, 2, · · · , n.
V =
⎡
⎢⎢⎢⎣
cn−1
1
cn−2
1
· · ·
c1
1
cn−1
2
cn−2
2
· · ·
c2
1
...
...
...
...
...
cn−1
n
cn−2
n
· · ·
cn
1
⎤
⎥⎥⎥⎦.
(4-1-5)
A Vandermonde matrix can be established with V = vander(c) function in MATLAB
for a given vector c.
Example 4.4
Establish a Vandermonde matrix
A =
⎡
⎢⎢⎢⎢⎣
1
1
1
1
1
16
8
4
2
1
81
27
9
3
1
256
64
16
4
1
625
125
25
5
1
⎤
⎥⎥⎥⎥⎦
.
Solution To generate such a matrix, one should select c = [1,2,3,4,5]. Thus, with the
following statements, the corresponding Vandermonde can be constructed.
>> c=[1, 2, 3, 4, 5];
V=vander(c) % create a Vandermonde matrix
VII. Companion matrices
Assume that there exists a monic polynomial, i.e., in the polynomial, the highest order
term with coeﬃcient 1
P(s) = sn + p1sn−1 + p2sn−2 + · · · + pn−1s + pn,
(4-1-6)
a companion matrix can be established such that
Ac =
⎡
⎢⎢⎢⎢⎢⎣
−p1
−p2
· · ·
−pn−1
−pn
1
0
· · ·
0
0
0
1
· · ·
0
0
...
...
...
...
...
0
0
· · ·
1
0
⎤
⎥⎥⎥⎥⎥⎦
.
(4-1-7)
A companion matrix can be established using B = compan(p), where p is a polynomial
coeﬃcient vector, and compan() function will automatically transform it into monic form.
Example 4.5
For a polynomial P(s) = 2s4 + 4s2 + 5s + 6, ﬁnd its companion matrix.
Solution
The characteristic polynomial can be entered ﬁrst, it can be converted into a
monic polynomial automatically, and then, the companion matrix A can be established using
the following statements
>> P=[2 0 4 5 6]; A=compan(P) % create a companion matrix

126
Scientiﬁc Computing with MATLAB®
and the following companion matrix can be generated
A =
⎡
⎢⎢⎣
0
−2
−2.5
−3
1
0
0
0
0
1
0
0
0
0
1
0
⎤
⎥⎥⎦.
VIII. Random integer matrices
Based on the rand() function, an integer matrix with random entities in the interval
[a, b] can be generated with A = randintmat(a,b,n,m), and if m is omitted, an n × n
matrix can be generated. The listing of the function is
function A=randintmat(a,b,n,m)
% generate a random integer matrix
if nargin==3, m=n; end
% generate a square matrix
a=floor(a); b=floor(b); A=floor(a+(b-a+1)*rand(n,m));
Example 4.6
Please generate a 10 × 10 nonsingular matrix with 0’s and 1’s.
Solution An inﬁnite loop can be used to generate such a matrix, and if the matrix generated
is nonsingular, break command can be used to terminate the loop. The commands are
>> while(1), A=randintmat(0,1,10); if det(A)~=0, break; end, end
4.1.2
Deﬁning symbolic matrices
For a given numerical matrix A, one may transform it by B = sym(A) into a symbolic
matrix. Thus, all the numerical matrices can be transformed into symbolic matrices so as
to achieve higher accuracy. In some cases, it is even possible to ﬁnd analytical solutions.
A symbolic matrix with all its elements numbers can be converted to a double-precision
matrix with A1 = double(A).
A symbolic matrix with arbitrary elements aij can be generated with the sym() function,
with A = sym(’a%d%d’,[n,m]). Arbitrary vectors with a single subscript can also be
generated with
v = sym(’a%d’,[1,n]), or , v = sym(’a%d’,[n,1])
Example 4.7
Please generate the three arbitrary matrices and a column vector
A=
⎡
⎢⎢⎣
a11
a12
a13
a14
a21
a22
a23
a24
a31
a32
a33
a34
a41
a42
a43
a44
⎤
⎥⎥⎦, B =
⎡
⎢⎢⎣
a11
a12
a21
a22
a31
a32
a41
a42
⎤
⎥⎥⎦, C =
⎡
⎢⎢⎣
f11
f12
f13
f14
f21
f22
f23
f24
f31
f32
f33
f34
f41
f42
f43
f44
⎤
⎥⎥⎦, v =
⎡
⎢⎢⎣
v1
v2
v3
v4
⎤
⎥⎥⎦.
Solution The following commands can be used directly
>> A=sym(’a%d%d’,4), B=sym(’a%d%d’,[4,2]), % create arbitrary matrices
C=sym(’f%d%d’,4), v=sym(’v%d’,[4,1])
If one wants to declare the components of the matrices or vectors as real entities or
entities having other properties, assumeAlso() function can be used. For instance, the
following commands can be used

Linear Algebra Problems
127
>> assumeAlso(A,’real’); assumeAlso(B,’integer’) % set matrix properties
The arbitrary matrices constructed with sym() function are constant matrices. If an
arbitrary matrix function is expected, for instance, M = {mij(x, y)}, a MATLAB function
any matrix() can be written
function A=any_matrix(nn,a_str,varargin) % generate a matrix function
v=varargin; n=nn(1); if length(nn)==1, m=n; else, m=nn(2); end
s=’’; k=length(v); K=0; if n==1 | m==1, K=1; end
if k>0, s=’(’;
% specify independent variables if needed
for i=1:k, s=[s ’,’ char(v{i})]; end, s(2)=[]; s=[s ’)’];
end
for i=1:n, for j=1:m, % processing each element of the matrix
if K==0, str=[a_str int2str(i),int2str(j) s];
else, str=[a_str int2str(i*j) s]; end % generate an arbitrary vector
eval([’syms ’ str]); eval([’A(i,j)=’ str ’;’]); % assign elements
end, end
The vector or matrix functions can be established with commands such as
A = any matrix([5,1],’a’,x,y), or, v = any matrix(5,’m’,t)
where a 5 × 1 vector A(x, y), with elements ai(x, y), and a 5 × 5 square matrix v(t), with
elements mij(t), can be established.
For other special matrices, such as Vandermonde matrix, Hankel matrix and companion
matrix, the functions described above can also be used, in recent versions of MATLAB, to
generate symbolic matrices.
Example 4.8
Establish a companion matrix from the following polynomial
P(λ) = a1λ9 + a2λ8 + a3λ7 + · · · + a8λ2 + a9λ + a10.
Solution With the use of the new support of compan() function, the required matrix can
be established using the following statements
>> a=sym(’a%d’,[1,10]); A=compan(a) % create symbolic companion matrix
the following matrix A can be generated
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
−a2/a1 −a3/a1 −a4/a1 −a5/a1 −a6/a1 −a7/a1 −a8/a1 −a9/a1 −a10/a1
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
1
0
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
4.1.3
Sparse matrix input
In many applications, there might be extremely large scale matrices, with most of their
elements zeros, with very few nonzero entities, this kind of matrix is also referred to as

128
Scientiﬁc Computing with MATLAB®
a sparse matrix. Some of the input and analysis functions in MATLAB support sparse
matrices with high eﬃciencies.
Sparse matrices can be loaded into MATLAB workspace with function sparse(), with
the syntax A = sparse(p,q,w), where, p, q are the row and column indices of nonzero
elements, while w is the vector composed of nonzero elements. The lengths of the three
vectors must be the same, otherwise, an error message will be given.
With B = full(A), a sparse matrix A can be converted into an ordinary matrix B,
and with A = sparse(B), an ordinary matrix can be converted to a sparse matrix. If a
matrix with more than 2/3 of its elements zeros, it is more economic to store it in sparse
form.
Example 4.9
Please generate a 10 × 10 identity matrix in sparse form.
Solution
To generate sparse matrices, the rows, columns and entities of the nonzero
elements should be speciﬁed in vectors. Therefore, the matrix can be generated with
>> i=1:10; j=1:10; v=ones(1,10); A=sparse(i,j,v) % sparse identity matrix
In fact, such a matrix can be generated with speye() function directly.
4.2
Fundamental Matrix Operations
4.2.1
Basic concepts and properties of matrices
I. Determinant
The determinant of matrix A = {aij} is deﬁned as
D =| A |= det(A) =

(−1)ka1k1a2k2 · · · ankn,
(4-2-1)
where the sum is taken over all possible permutations on n elements, and the sign is positive
if the permutation is even and negative if the permutation is odd.
There are many algorithms which can be used to compute the determinant of a matrix.
A built-in function det() provided in MATLAB can be used to calculate the determinant
d = det(A), and this function applies both to symbolic and numerical matrices.
Example 4.10
Compute the determinant of a given matrix A =
⎡
⎢⎢⎣
16
2
3
13
5
11
10
8
9
7
6
12
4
14
15
1
⎤
⎥⎥⎦.
Solution The determinant of matrix A can be obtained and it equals 0, which means that
matrix A is singular.
>> A=[16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1]; det(A), det(sym(A))
Example 4.11 From the example given in Chapter 1, it is known that large-sized Hilbert
matrix is very close to singular. Calculate analytically the determinant of an 80×80 Hilbert
matrix.
Solution The function hilb() can be used to declare a numerical 80 × 80 Hilbert matrix.

Linear Algebra Problems
129
It can then be transformed into a symbolic matrix. The det() function in MATLAB can be
used to calculate analytically the determinant of the matrix.
>> A=sym(hilb(80)); det(A) % determinant of 80 × 80 Hilbert matrix
Therefore, the determinant can be obtained as
det(H)=
1
99030101466993477878867678 · · ·000000000000

	

3790 digits, with some digits omitted
≈1.009794 × 10−3790.
Example 4.12
Please derive the formula for the determinant of a 4 × 4 matrix.
Solution A 4×4 arbitrary matrix can be generated ﬁrst, and based on it, symbolic function
det() can be used to ﬁnd its determinant.
>> A=sym(’a%d%d’,4); d=det(A) % determinant of an arbitrary 4 × 4 matrix
The determinant can be obtained as
d=a11a22a33a44−a11a22a34a43−a11a23a32a44+a11a23a34a42+a11a24a32a43−a11a24a33a42
−a12a21a33a44+a12a21a34a43+a12a23a31a44−a12a23a34a41−a12a24a31a43+a12a24a33a41
+a13a21a32a44−a13a21a34a42−a13a22a31a44+a13a22a34a41+a13a24a31a42−a13a24a32a41
−a14a21a32a43+a14a21a33a42+a14a22a31a43−a14a22a33a41−a14a23a31a42+a14a23a32a41,
where the terms in the results are grouped in 6, deliberately by the author with square
brackets. It can be seen that, the ﬁrst group of terms are associated with a11, and the
second group are associated with a12, and so on. Thus, the determinant can be written as
a11A11 + a12A12 + a13A13 + a14A14, where, Aij is referred to as the algebraic complement
of aij, and it is in fact the determinant of the sub matrix, with the ith row and jth column
elements removed, and then, multiplied by (−1)i+j.
If the algebraic complement of A23 is expected, two approaches can be used. The following
statements can be used to ﬁnd it.
A23 = −a11a32a44 + a11a34a42 + a12a31a44 −a12a34a41 −a14a31a42 + a14a32a41
>> i=2; j=3; B=A; B(i,:)=[]; B(:,j)=[]; A23=(-1)^(i+j)*det(B)
Alternatively, delete all the terms which do not contain a23 in d, then, divide the result
by a23. The results obtained are exactly the same.
>> syms a23; A23_1=simplify((d-subs(d,a23,0))/a23)
Based on the concept of algebraic complement of a matrix, a new matrix
adj(A) =
⎡
⎢⎢⎢⎣
A11
A21
· · ·
An1
A12
A22
· · ·
An2
...
...
...
...
A1n
A2n
· · ·
Ann
⎤
⎥⎥⎥⎦
(4-2-2)
can be constructed, and adj(A) is referred to as the adjoint matrix of the square matrix A,
and it is in fact the transpose of the matrix of algebraic complements of A. The adjoint
matrix of A can be obtained with B = adjoint(A). The algebraic complement A23 in the
previous example can be extracted with
>> B=adjoint(A).’; A23=B(2,3) % call function to get the whole adjoint matrix

130
Scientiﬁc Computing with MATLAB®
II. Trace
For a square matrix A = {aij}, i, j = 1, 2, · · · , n, the trace of the A is deﬁned as
tr(A) =
n

i=1
aii,
(4-2-3)
i.e., the trace of a matrix is deﬁned as the sum of diagonal elements. From linear algebra
theory, the trace of a matrix equals the sum of the eigenvalues. The trace of matrix A can
be obtained using the MATLAB function trace(), such that t = trace(A). The trace of
the matrix in Example 4.10 can be obtained directly from trace(A) = 34.
III. Rank
If for a given n × m matrix, there exist maximum rc linearly independent columns, the
column rank of the matrix is rc. If rc = m, the matrix is referred to as a full column rank
matrix. Similarly, if there exist maximum rr linearly independent rows, the row rank of the
matrix is rr. If rr = n, matrix A is referred to as a full row rank matrix. It can be shown that
the column rank and row rank of the same matrix are identical, and they both can be called
the rank of the matrix, i.e., rank(A) = rc = rr. The rank of matrix A is mathematically
denoted as rank(A).
There are various algorithms for calculating the ranks of given matrices. Some of the
algorithms may be numerically unstable. A built-in function rank() has been provided in
MATLAB which applies to both numerical and symbolic matrices. The syntaxes of the
function are
r = rank(A)
% symbolic or numerical
r = rank(A,ε)
% numerical rank with error tolerance of ε
where A is the given matrix, and ε is user speciﬁed error tolerance.
Example 4.13
Find the rank of matrix A in Example 4.10.
Solution The MATLAB function rank(A) can be used to calculate the rank of matrix A
and rank(A) = 3, which indicates that A is not a full rank matrix.
Example 4.14
Now consider the 20 × 20 Hilbert matrix in Example 4.11. Find the rank
of the matrix in numerical and analytic methods, respectively.
Solution The following commands can be used to ﬁnd the rank numerically
>> H=hilb(20); rank(H) % numerical rank, may be wrong
and it can be seen that the rank of the matrix is 13, which means that the matrix is not of
full rank. Now let us try the analytic method
>> H=sym(hilb(20)); rank(H) % analytical rank, correct
and it is concluded that the rank of the matrix is 20. Therefore, if the numerical method is
adopted, one should be very careful, since misleading results can sometimes be obtained.

Linear Algebra Problems
131
IV. Norms
The norms of a matrix can be considered as a measure of “size” of the matrix. Before
introducing the concept of the norms of the matrices, the norms of the vectors are introduced
ﬁrst. For a vector x in linear space, if there exists a function ρ(x) satisfying the following
three conditions:
(i) ρ(x) ⩾0 and ρ(x) = 0 if and only if x = 0;
(ii) ρ(ax) = |a|ρ(x), a is any given scalar;
(iii) for vectors x and y, there exists ρ(x + y) ⩽ρ(x) + ρ(y).
Then, ρ(x) is referred to as the norm of the vector x. There are various forms of the
norms. It can be shown that a class of norms deﬁned below satisﬁes all the above three
conditions.
||x||p =
+ n

i=1
| xi |p
,1/p
, p = 1, 2, · · · , and ||x||∞= max
1⩽i⩽n | xi |,
(4-2-4)
where the notation ||x||p is used to deﬁne the p-norm of the vector x.
The deﬁnition of the norms of a matrix A is
||A∥= sup
x̸=0
||Ax ∥
||x|| ,
(4-2-5)
for any non-zero vector x. Similar to vector norms, the commonly used norms of a matrix
are the following three
||A||1 = max
1⩽j⩽n
n

i=1
|aij|, ||A||2 =

smax(ATA), ||A∥∞= max
1⩽i⩽n
n

j=1
|aij|,
(4-2-6)
where s(X) is the eigenvalue of matrix X, while smax(ATA) is the maximum eigenvalue of
matrix ATA. In fact, ||A||2 equals the maximum singular value of matrix A.
The norms of a matrix can be evaluated using the MATLAB function norm(). Note that
the norm() function applies only to numerical matrices. The syntaxes of the function are
N = norm(A)
% default for ||A||2
N = norm(A,options)
% options could be 1,2,inf, see Table 4.1
Diﬀerent norms of matrix A in Example 4.10 can be evaluated using the following
MATLAB statements
>> A=[16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1];
[norm(A), norm(A,2), norm(A,1), norm(A,Inf), norm(A,’fro’)]
where ||A||1 = ||A||2 = ||A||∞= 34, ||A||F = 38.6782. The matrix here is a special matrix
such that the norms ||A||1 = ||A||2 = ||A||∞but in general cases, the speciﬁc values of the
norms should not be the same.
It should be noted that the function norm() is not applicable to symbolic matrices
containing variables.
V. Characteristic polynomials
When a symbolic variable s is introduced, the determinant of the matrix sI −A can be
constructed, and it is a polynomial of s, expressed as
C(s) = det(sI −A) = sn + c1sn−1 + · · · + cn−1s + cn,
(4-2-7)

132
Scientiﬁc Computing with MATLAB®
TABLE 4.1: The options for the norm() function.
options
deﬁnitions and algorithms
none
the maximum singular value, i.e., ||A||2
2
the same as defaults, i.e., ||A||2
1
1-norm of the matrix, i.e., ||A||1
Inf or ’inf’
inﬁnite norm, i.e., ||A||∞
’fro’
Frobenius norm of the matrix, i.e., ||A||F = tr(ATA)
integer p
applies only to vectors. For matrices, only 1,2, inf and ’fro’ are allowed
-inf
For vectors only, where ||A||−∞= min(|  ai|)
and polynomial C(s) is referred to as the characteristic polynomial of matrix A. In
the formula, the coeﬃcients ci, i = 1, 2, · · · , n are referred to as the coeﬃcients of the
characteristic polynomial.
A MATLAB function c = poly(A) can be used to evaluate the coeﬃcients of the
characteristic polynomial of matrix A, where the returned vector c contains the coeﬃcients
in descending order of s of the characteristic polynomial. If the input argument A is a
vector, the poly() function will return the polynomial coeﬃcients vector whose roots are
given in A.
It should also be noted that this function is no longer usable to symbolic A matrix.
An alternative function charpoly() with the same syntax can be used instead. To get
characteristic polynomial expression with variable x, the function can be called with
p = charpoly(A,x).
Example 4.15
Find the characteristic polynomial of matrix A in Example 4.10.
Solution Using the poly() function, the following results can be obtained
>> A=[16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1]; c1=poly(A)
the coeﬃcient vector is c1 = 103 × [0.0010, −0.0340, −0.0800, 2.7200, −0.0000]T, and it can
be seen that there might exist minor errors in the results.
Using symbolic matrix A, the function charpoly() will yield a characteristic polynomial
such that ϕ(x) = x4 −34x3 −80x2 + 2720x.
>> A=sym(A); c2=charpoly(A) % coeﬃcient vector is returned in new versions
In practical applications, there are other algorithms which can be used to calculate
numerically the coeﬃcients of the characteristic polynomial of a matrix. For instance, the
Leverrier–Faddeev recursive algorithm is an accurate algorithm for solving such problems.
ck+1 = −1
ktr(ARk),
Rk+1 = ARk + ck+1I,
k = 1, · · · , n,
(4-2-8)
where R1 = I, c1 = 1.
In the above algorithm, an identity matrix I is assigned to matrix R1. Then, for each
value of k, the matrix Rk is recursively updated, and then, the value of ck can be found.
Based on such an algorithm, the following MATLAB function can be written
function c=poly1(A)
[nr,nc]=size(A); I=eye(nc);
R=I; c=[1 zeros(1,nc)];
for k=1:nc, c(k+1)=-1/k*trace(A*R); R=A*R+c(k+1)*I; end

Linear Algebra Problems
133
Example 4.16 With the new poly1() function, accurate result can be achieved
>> c=poly1(A) % call the new function to get accurate result
such that c = [1, −34, −80, 2720, 0], which is the accurate result.
Example 4.17
For a given vector B = [a1, a2, a3, a4, a5], establish the corresponding
Hankel matrix, then, ﬁnd the characteristic polynomial.
Solution
The command A = hankel(B) can be used to construct a symbolic Hankel
matrix. Thus, the function charpoly(A) can then be used to calculate its characteristic
polynomial coeﬃcients.
>> syms x; a=sym(’a%d’,[1,5]); A=hankel(a);
%
construct a Hankel matrix
p=charpoly(A,x); p=collect(p,x)
The mathematical representation of the characteristic equation can be written as
p(A) = x5 + (−a3 −a1 −a5)x4 + (a5a1 + a3a1 + a5a3 −2a2
4 −2a2
5 −a2
2 −a2
3)x3
+ (a2
4a1+a2
5a3+a2
4a5 + a2
2a5+a2
4a3−a3a1a5−2a2a5a4a2
5a1−2a2a4a3+2a3
5+a3
3)x2
+ (−3a2
4a3a5 + a4
5 + a2
4a2
5 + a4
4 −a3
5a1 + a2
5a2
3 + 2a2a2
5a4 −a3
5a3)x −a5
5.
VI. Evaluation of polynomial matrices
Polynomial matrices take the following form
B = a1An + a2An−1 + · · · + anA + an+1I,
(4-2-9)
where A is a given matrix, I is an identity matrix whose size is the same as matrix
A. The matrix B is then the polynomial matrix. In MATLAB, the polynomial matrix
can be evaluated using the function polyvalm(), such that B = polyvalm(a,A), where
a = [a1, a2, · · · , an, an+1] are the coeﬃcients in descending order of s of the polynomial.
It should be noted that function polyvalm() can only be used when a is a double-
precision vector. In order to extend it into symbolic computation, the following MATLAB
function can be written.
function B=polyvalmsym(p,A)
E=eye(size(A)); B=zeros(size(A)); n=length(A);
for i=n+1:-1:1, B=B+p(i)*E; E=E*A; end
On the other hand, if polynomial operation is deﬁned upon “dot operation” basis such
that
C = a1x.^n + a2x.^(n −1) + · · · + an+1,
(4-2-10)
the matrix C can be evaluated from C = polyval(a,x).
Example 4.18
Cayley–Hamilton Theorem is a very important theorem in linear algebra.
The theorem states that if the characteristic polynomial of matrix A is
f(s) = det(sI −A) = a1sn + a2sn−1 + · · · + ans + an+1,
(4-2-11)
then, f(A) = 0, i.e.,
a1An + a2An−1 + · · · + anA + an+1I = 0.
(4-2-12)

134
Scientiﬁc Computing with MATLAB®
Assume that matrix A is a Vandermonde matrix. Verify that it satisﬁes the Cayley–
Hamilton Theorem.
Solution The following statements can be used to verify the theorem.
>> A=vander([1 2 3 4 5 6 7]); p=poly(A); B=polyvalm(p,A); norm(B)
The norm of the error matrix is 2.1887×106, which is too large because the poly()
function is not accurate for the matrix. Therefore, something strange might have happened
in the veriﬁcation.
It has been indicated that the function poly() may cause errors, and for this particular
matrix, the error is so large that misleading results are obtained. So for this matrix, the new
function poly1() should be used instead. And it can be seen that with the new function,
exact solutions can easily be obtained.
>> p1=poly1(A); B1=polyvalm(p1,A); norm(B1)
It can be seen from the results that B matrix obtained is a matrix of zeros, which means
that for the given matrix, the Cayley–Hamilton Theorem holds.
Example 4.19
Please show that an arbitrary 5 × 5 matrix satisﬁes Cayley–Hamilton
Theorem.
Solution An arbitrary matrix should be generated ﬁrst, then, charpoly() function can be
used to ﬁnd the coeﬃcients of the polynomial matrix, and ﬁnally polyvalm() function can
be used to ﬁnd the polynomial matrix. Simpliﬁcation to the resulted matrix can be made and
see whether it is a matrix of zeros. For the example, the elapsed time is around 5 seconds,
and Cayley–Hamilton Theorem can be veriﬁed. To validate the theorem for an arbitrary 6×6
matrix, 2 minutes are needed.
>> A=sym(’a%d%d’,5); p=charpoly(A); tic % generate an arbitrary matrix A
E=simplify(polyvalmsym(p,A)), toc
% show Cayley−Hamilton Theorem
VII. Symbolic polynomials and coeﬃcient extractions
A polynomial can either be represented in a numerical way or in a symbolic way. In the
former case, a polynomial of x
p(x) = a1xn + a2xn−1 + · · · + anx + an+1
(4-2-13)
can be expressed by a coeﬃcient vector such that p = [a1, a2, · · · , an+1]. In the latter
case, it can be expressed by symbolic polynomials. One may convert a numerical polynomial
to a symbolic one using poly2sym() function, and the function sym2poly() can be used to
convert in the other way. The syntaxes of the two functions are rather simple.
f = poly2sym(p),
or
f = poly2sym(p,x),
or
p=sym2poly(f)
Example 4.20
Represent the f = s5 + 2s4 + 3s3 + 4s2 + 5s + 6 in both numerical and
symbolic forms.
Solution For simplicity, a vector can be constructed from the coeﬃcients of the polynomial,
and then, the function poly2sym() can be used to ﬁnd the symbolic representation
>> P=[1 2 3 4 5 6];
% coeﬃcients of the polynomial in descending order
f=poly2sym(P,’v’) % v is used as the operator

Linear Algebra Problems
135
and the symbolic polynomial can be obtained as f = v5 + 2v4 + 3v3 + 4v2 + 5v + 6. The
numerical function can be obtained with P = sym2poly(f).
Function C = coeffs(P,x) can be used to extract coeﬃcients, in ascending order of x,
and if x is the only symbolic variable in P, it can be omitted.
Example 4.21
Please extract the coeﬃcients of x from polynomial (x + 2y)8.
Solution
It is obvious that the original polynomial is a polynomial of x and y. If the
coeﬃcients are to be extracted in ascending order of x, the following statements can be
issued
>> syms x y; P=(x+2*y)^8; p=coeffs(P,x) % extract coeﬃcients of x in P
and the result is p = [256y8, 1024y7, 1792y6, 1792y5, 1120y4, 448y3, 112y2, 16y, 1].
Unfortunately when there are missing terms in the polynomial, the behavior of coeffs()
function may not be satisfactory, and sym2poly() function cannot handle polynomials with
other symbolic parameters. A new MATLAB function is needed to extract the coeﬃcients
in descending order of x.
For a given polynomial in (4-2-13), it is easily found that
an+1 = p(0), and ai =
1
(n −i + 1)!
dn−i+1p(x)
dxn−i+1
""""
t=0
, i = 1, 2, · · · , n.
(4-2-14)
The above coeﬃcient extraction algorithm can be implemented as
function c=polycoef(p,x)
c=[]; n=0; p1=p; n1=1; nn=1; if nargin==1, x=symvar(p); end
while (1), % loop for all the coeﬃcients
c=[c subs(p1,x,0)]; p1=diff(p1,x); n=n+1; n1=n1*n; nn=[nn,n1];
if p1==0, c=c./nn(1:end-1); c=c(end:-1:1); break;
end, end
4.2.2
Matrix inversion
For an n × n nonsingular square matrix A, if there exists a matrix C of the same size
satisfying
AC = CA = I,
(4-2-15)
where I is an identity matrix, then, matrix C is referred to as the inverse matrix of A,
denoted as C = A−1.
A MATLAB function C = inv(A) is provided to calculate the inverse matrix C, and
this function is applicable for both numerical and symbolic matrices.
Example 4.22
Compute the inverse matrix for the given Hilbert matrix.
Solution Let us consider ﬁrst a 4 × 4 Hilbert matrix. The MATLAB function inv() can
be used to ﬁnd the inverse matrix
>> format long; H=hilb(4); H1=inv(H), norm(H*H1-eye(4))

136
Scientiﬁc Computing with MATLAB®
and the equation obtained below with the error is around 1.3931×10−12. The inverse matrix
obtained is
⎡
⎢⎢⎣
15.999999999999
−119.99999999999
239.99999999998 −139.99999999999
−119.99999999999
1199.9999999999 −2699.9999999997
1679.9999999998
239.99999999998
−2699.9999999997
6479.9999999994 −4199.9999999996
−139.99999999999
1679.9999999998 −4199.9999999996
2799.9999999997
⎤
⎥⎥⎦.
Since a large-sized Hilbert matrix is close to a singular matrix, the use of numerical
function inv() is not recommended for Hilbert matrices. The function invhilb() can be
used instead to ﬁnd the accurate inverse matrix. For the 4 × 4 Hilbert matrix, the inverse
matrix can be obtained
>> H2=invhilb(4); norm(H*H2-eye(size(H)))
and the error is reduced to 5.6843×10−14, which means that the function invhilb() improves
signiﬁcantly for inverse matrices. Now consider a 10×10 Hilbert matrix, the inverse matrices
by inv() and invhilb() can be obtained
>> H=hilb(10); H1=inv(H); norm(H*H1-eye(size(H)))
H2=invhilb(10); norm(H*H2-eye(size(H)))
and the errors by these approaches are respectively 0.0032 and 2.5249×10−5. The accuracy
is very low. If the size of the matrix is further increased to 13, then, the commands
>> H=hilb(13); H1=inv(H); norm(H*H1-eye(size(H)))
H2=invhilb(13); norm(H*H2-eye(size(H)))
will detect the error norms by using the above two methods respectively as 81.1898, 11.7781.
They are too high to be practically used.
Fortunately, the function inv() is also provided in the Symbolic Math Toolbox, which can
be used to evaluate the inverse matrix for symbolic matrices. Even for large-sized nonsingular
matrices, the use of such a function can return error-free solutions. Using the following
commands, the inverse matrix of a 7 × 7 Hilbert can be obtained and displayed
>> H=sym(hilb(7)); inv(H) % exact computation of inverse matrix
and the exact inverse can then be found
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
49
−1176
8820
−29400
48510
−38808
12012
−1176
37632
−317520
1128960
−1940400
1596672
−504504
8820
−317520
2857680
−10584000
18711000
−15717240
5045040
−29400
1128960 −10584000
40320000
−72765000
62092800
−20180160
48510
−1940400
18711000
−72765000
133402500
−115259760
37837800
−38808
1596672 −15717240
62092800 −115259760
100590336
−33297264
12012
−504504
5045040
−20180160
37837800
−33297264
11099088
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
In fact, even for a 50 × 50 Hilbert matrix, the exact inverse matrix can be obtained and
it can be shown that there is zero error norm in the results. The elapsed time is around 9
seconds.
>> tic, H=sym(hilb(50)); norm(H*inv(H)-eye(size(H))), toc % larger matrix
Example 4.23 Compute the inverse matrix for the matrix A in Example 4.10 and observe
the diﬀerences using numerical and analytical methods.
Solution
One can enter the matrix, and then, use inv() function to ﬁnd its numerical
inverse

Linear Algebra Problems
137
>> A=[16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1]; % input matrix
B=inv(A), A*B
% compute and validate the inverse
and it prompted that “Warning: Matrix is close to singular or badly scaled. Results may be
inaccurate. RCOND = 1.306145e-017,” and the matrix A and AB obtained are respectively
B =
⎡
⎢⎢⎣
−2.6495 −7.9484
7.9484
2.6495
−7.9484 −23.845
23.845
7.9484
7.9484
2.38455 −23.845 −7.9484
2.6495
7.9484
−7.9484 −2.6495
⎤
⎥⎥⎦×1014, AB =
⎡
⎢⎢⎣
1
0
−1 −0.25
−0.25
0
0
0.875
0.25
0.5
0
0.25
0.15625
0.125
0 1.7344
⎤
⎥⎥⎦.
It can be seen that a warning message is displayed claiming that A matrix is close to
a singular matrix, thus, the results are useless. The product AB is no longer an identity
matrix. The command norm(A*B-eye(size(A))) indicates that the norm of the error
matrix is as big as 1.6408.
In fact, for singular matrices, there is no inverse matrix satisfying (4-2-15). For the
same problem, from the Symbolic Math Toolbox function B = inv(sym(A)), the returned
B is FAIL.
Example 4.24 The symbolic function inv() can be applied also to matrices with symbolic
variables. Find the inverse of Hankel matrix with variables.
Solution For instance, the inverse matrix of a given Hankel matrix can easily be obtained
with the direct use of inv()
>> a=sym(’a%d’,[1,4]); H=hankel(a); inv(H) % direct inverse of Hankel matrix
the inverse matrix is
H−1 =
⎡
⎢⎢⎣
0
0
0
1/a4
0
0
1/a4
−1/a2
4a3
0
1/a4
−1/a2
4a3
−1/a3
4(a2a4 −a2
3)
1/a4
−1/a2
4a3
−1/a3
4(a2a4 −a2
3)
−(a1a2
4 −2a2a3a4 + a3
3)/a4
4
⎤
⎥⎥⎦.
In classical linear algebra textbooks, reduced row echelon form is useful in ﬁnding
the inverse of a given matrix. An identity matrix can be appended to the right of the
original matrix. After reduced row echelon conversion, the left half of the appended matrix
is converted to an identity matrix, while the right half is the inverse. In MATLAB,
H1 = rref(H) can be used to ﬁnd the reduced row echelon form. This function can be
used in the inverse matrix evaluation.
Example 4.25
To use reduced row echelon form to ﬁnd the inverse in the previous
example, the following statements can be issued
>> a=sym(’a%d’,[1,4]); H=hankel(a); H0=inv(H) % generate a Hankel matrix
H1=[H eye(4)]; H2=rref(H1), H3=H2(:,5:8)
% compute inverse again
The inverse H3 is exactly the same as H0. The reduced row echelon form H2 is also
shown, whose left half is an identity matrix, and the right is the inverse H3
H2 =
⎡
⎢⎢⎣
1
0
0
0
0
0
0
1/a4
0
1
0
0
0
0
1/a4
−1/a2
4a3
0
0
1
0
0
1/a4
−1/a2
4a3
−1/a3
4(a2a4 −a2
3)
0
0
0
1
1/a4
−1/a2
4a3
−1/a3
4(a2a4 −a2
3)
−(a1a2
4 −2a2a3a4 + a3
3)/a4
4
⎤
⎥⎥⎦.

138
Scientiﬁc Computing with MATLAB®
Using the concept of adjoint matrix, the inverse of matrix A can also be obtained with
B = adjoint(A)/det(A).
Example 4.26
Please show that for a 3 × 3 arbitrary matrix A(t), we have
dA−1(t)
dt
= −A−1(t)dA(t)
dt
A−1(t).
Solution
In this example, arbitrary matrix function A(t) is involved. The function
any matrix() can be used to generate such a matrix, and the following commands can
be used to validate the above equation. It can be seen that the simpliﬁed error is a zero
matrix, hence, the equation is proved.
>> syms t; A=any_matrix(3,’a’,t); iA=inv(A); % generate matrix and inverse
simplify(diff(iA,t)+iA*diff(A,t)*iA)
% validate the equation
4.2.3
Generalized matrix inverse
It can be seen that even with the Symbolic Math Toolbox, the inverse problems to a
singular matrix cannot be handled. In fact, in a strict sense, no inverse matrix exists at all
for singular matrices. In practical applications, one may need an “inverse” for singular or
even rectangular matrices. Thus, a generalized matrix should be deﬁned. For a given matrix
A, if there exists another matrix N such that
ANA = A,
(4-2-16)
the matrix N is referred to as the generalized inverse matrix of matrix A, denoted by
N = A−. For an n × m rectangular matrix A, the generalized inverse matrix N is an
m × n matrix. It can be shown that there are an inﬁnite number of N’s satisfying such a
condition.
One may introduce a norm criterion such that
min
N ||AN −I||
(4-2-17)
is minimized, and it can be shown that for any given matrix A, there exists a unique matrix
M such that the three conditions below are satisﬁed
(i) AMA = A,
(ii) MAM = M,
(iii) AM and MA are both Hermitian symmetrical matrices.
Such a matrix M is referred to as the Moore–Penrose inverse or pseudoinverse of A,
denoted by M = A+.
A MATLAB function pinv() can be used to ﬁnd the Moore–Penrose pseudoinverse of
a given matrix. The syntaxes of the function are
M = pinv(A)
% evaluate the Moore-Penrose pseudoinverse
M = pinv(A,ϵ)
% evaluate the inverse numerically with precision of ϵ
where the variable ϵ is used to judge whether a value is zero or not. The returned matrix M
is the Moore–Penrose pseudoinverse of the original matrix A. If A is a nonsingular square
matrix, the resulted pseudoinverse is in fact the inverse of the original matrix. However, the
speed of the pinv() function is signiﬁcantly lower than that of the inv() function. In new
versions of MATLAB, pinv() also works for symbolic matrices.

Linear Algebra Problems
139
Example 4.27
Find the pseudoinverse of the singular matrix A in Example 4.10.
Solution For the singular matrix, the Moore–Penrose pseudoinverse of the matrix should
be established instead, using the following statements.
>> A=[16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1]; B=pinv(A), A*B
The Moore–Penrose inverse of the matrix B and AB are
B =
⎡
⎢⎢⎣
0.1011
−0.0739 −0.0614
0.0636
−0.0364
0.0386
0.0261
0.001103
0.0136
−0.0114 −0.0239
0.0511
−0.0489
0.0761
0.0886
−0.0864
⎤
⎥⎥⎦,
AB =
⎡
⎢⎢⎣
0.95
−0.15
0.15
0.05
−0.15
0.55
0.45
0.15
0.15
0.45
0.55 −0.15
0.05
0.15 −0.15
0.95
⎤
⎥⎥⎦.
With symbolic call of the pinv() function
>> B1=pinv(sym(A)), B1*A, A*B1 % symbolic computation of pseudoinverse
the Moore–Penrose inverse can be written as
B1 =
⎡
⎢⎢⎣
55/544
−201/2720
−167/2720
173/2720
−99/2720
21/544
71/2720
3/2720
37/2720
−31/2720
−13/544
139/2720
−133/2720
207/2720
241/2720
−47/544
⎤
⎥⎥⎦.
With the result, the matrices B1A and AB1 are the same
AB1 = B1A =
⎡
⎢⎢⎣
19/20
−3/20
3/20
1/20
−3/20
11/20
9/20
3/20
3/20
9/20
11/20
−3/20
1/20
3/20
−3/20
19/20
⎤
⎥⎥⎦.
From these results obtained, it can be observed that the values in A+ are meaningful,
and AA+ is no longer an identify matrix. Now the three conditions for the Moore–Penrose
pseudoinverse can be checked using the following statements:
>> [norm(A*B*A-A), norm(B*A*B-B), norm(A*B-(A*B)’), norm(B*A-(B*A)’)]
with errors respectively 2.2383×10−14, 7.6889×10−17, 1.0753×10−15, 9.3653×10−16. It can be
seen that the above obtained matrix B is the Moore–Penrose inverse of the original matrix.
Performing Moore–Penrose inverse to matrix B, it can be seen that (A+)+ = A, with error
1.9278×10−14.
>> pinv(B), norm(ans-A) % restore original matrix by taking pseudoinverse twice
Example 4.28
For the following rectangular matrix A, ﬁnd its rank and Moore–Penrose
inverse. Check whether the pseudoinverse obtained is correct or not
A =
⎡
⎣
6
1
4
2
1
3
0
1
4
2
−3
−2
−5
8
4
⎤
⎦.
Solution The following commands can be given to get the rank of the matrix. It can be
seen that the rank is 2, rather than 3, which means that the matrix is not a full-rank matrix.
>> A=[6,1,4,2,1; 3,0,1,4,2; -3,-2,-5,8,4]; rank(A)

140
Scientiﬁc Computing with MATLAB®
Since matrix A is a singular rectangular matrix, the function pinv() can be used to
evaluate the Moore–Penrose pseudoinverse of the matrix. Then, each of the three conditions
for Moore–Penrose pseudoinverse can be veriﬁed, and it can be shown that the resulted
matrix is correct.
>> A1=pinv(A), A2=pinv(sym(A)), A3=double(A2) % compute pseudoinverse
[norm(A*A1*A-A), norm(A1*A-A’*A1’), ...
% validation
norm(A1*A-A’*A1’), norm(A*A1-A1’*A’)]
The pseudoinverse matrices are
A1 =
⎡
⎢⎢⎢⎢⎣
0.07303
0.041301
−0.02215
0.01077
0.001995
−0.01556
0.04589
0.017757
−0.03851
0.03272
0.043097
0.063847
0.01636
0.021548
0.031923
⎤
⎥⎥⎥⎥⎦
, A2 =
⎡
⎢⎢⎢⎢⎣
183/2506
207/5012
−111/5012
27/2506
5/2506
−39/2506
115/2506
89/5012
−193/5012
41/1253
54/1253
80/1253
41/2506
27/1253
40/1253
⎤
⎥⎥⎥⎥⎦
and ||A+AA+ −A+|| = 1.0263 × 10−16, ||AA+A −A|| = 8.1145 × 10−15, ||A+A −
(A)H(A+)H|| = 3.9098×10−16, ||A+A−(A)H(A+)H|| = 1.6653×10−16. The double-precision
representation of symbolic A2 is exactly the same as A1.
4.2.4
Matrix eigenvalue problems
I. Eigenvalues and eigenvectors of a matrix
For the given matrix A, if there exists a non-zero vector x and a scalar λ satisfying
Ax = λx,
(4-2-18)
then, λ is referred to as an eigenvalue of matrix A, while the vector x is referred to as
the eigenvector of A corresponding to the eigenvalue λ. Strictly speaking, the eigenvector x
should be referred to as the right eigenvector. If the eigenvalues are distinct, the eigenvectors
are linearly independent. Thus, a nonsingular square eigen-matrix can be constructed. A
diagonal matrix can be obtained if such a matrix is used to perform similar transformation.
The eigenvalues and eigenvectors can easily be obtained using the eig() function. The
syntaxes of the function are
d = eig(A)
% only eigenvalues are required
[V ,D] = eig(A)
% if both eigenvalues and eigenvectors are expected
where, d is a vector containing all the eigenvalues, while D is a diagonal matrix whose
diagonal elements are the eigenvalues of the matrix, and each column in matrix V contains
the eigenvector to the corresponding eigenvalues. The following relationship AV = V D is
satisﬁed. This function applies also to complex A matrix as well as symbolic ones.
The deﬁnition of the roots of the characteristic polynomial discussed earlier is exactly
the same as the eigenvalues. If the characteristic polynomial can be exactly known, the
function roots() can also be used in evaluating the eigenvalues of the matrix.
Example 4.29
Compute the eigenvalues and eigenvectors of A in Example 4.10.
Solution Using numerical method, the eigenvalues can be obtained by the direct use of the
eig() function such that
>> A=[16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1]; eig(A)

Linear Algebra Problems
141
and it can be seen that they are 34, ±8.9442719, −2.234826×10−15.
The eig() function provided in the Symbolic Math Toolbox can also be used to evaluate
the eigenvalues and eigenvectors of a given matrix. Even for large-sized matrices, results
with very high accuracy can be obtained.
>> eig(sym(A)) % symbolic computation of eigenvalues
Thus, the exact eigenvalues of the matrix are 0, 34, ±4
√
5.
For the same matrix A, the eigenvalues and eigenvectors can be solved numerically such
that
>> [v,d]=eig(A) % ﬁnd eigenvalues and eigenvector matrix
the numerical solutions to the eigenvector and eigenvalues are
v =
⎡
⎢⎢⎣
−0.5
−0.8236
0.3764
−0.2236
−0.5
0.4236
0.02361
−0.6708
−0.5
0.02361
0.4236
0.6708
−0.5
0.3764
−0.8236
0.2236
⎤
⎥⎥⎦,
d =
⎡
⎢⎢⎣
34
0
0
0
0
8.9443
0
0
0
0
−8.9443
0
0
0
0
9.416×10−16
⎤
⎥⎥⎦.
If the Symbolic Math Toolbox is used, the eigenvalues and eigenvectors can easily be
found such that
>> [v,d]=eig(sym(A)) % symbolic computation
and it can be found
v =
⎡
⎢⎢⎣
−1
1
−8
√
5 −17
8
√
5 −17
−3
1
4
√
5 + 9
−4
√
5 + 9
3
1
1
1
1
1
4
√
5 + 7
−4
√
5 + 7
⎤
⎥⎥⎦,
d =
⎡
⎢⎢⎣
0
0
0
0
0
34
0
0
0
0
4
√
5
0
0
0
0
−4
√
5
⎤
⎥⎥⎦.
If matrix A has repeated eigenvalues, the eigenvector matrix will be a singular matrix.
When numerical algorithms are used, the obtained eigenvalues may not be exactly the same,
due to numerical errors. Thus, the obtained V matrix may not be singular, although it is
extremely close to a singular one.
II. Generalized eigenvalues and eigenvectors
Assume that there exists a scalar λ and a non-zero vector x such that
Ax = λBx,
(4-2-19)
where B is a symmetrical positive-deﬁnite matrix, λ is referred to as the generalized
eigenvalue, while x is the generalized eigenvector. In fact, the ordinary eigenvalue problem
is a special case of the generalized eigenvalue problem when B = I is assumed.
If matrix B is a nonsingular square matrix, the generalized eigenvalue problem can be
converted to the eigenvalue problem for matrix B−1A.
B−1Ax = λx,
(4-2-20)
i.e., λ and x are respectively the eigenvalues and eigenvectors of matrix B−1A. In MATLAB,

142
Scientiﬁc Computing with MATLAB®
the function eig() can be used to compute directly the generalized eigenvalues and
eigenvectors such that
d = eig(A,B)
% generalized eigenvalue evaluation
[V ,D] = eig(A,B)
% generalized eigenvalues and eigenvectors
With the eig() function, the generalized eigenvalues and eigenvectors can be obtained
in matrices D and V , where AV = BV D. It should be noted that the matrix B is no
longer restricted to positive-deﬁnite matrices.
Example 4.30
Now consider the matrices
A =
⎡
⎢⎢⎣
5
7
6
5
7
10
8
7
6
8
10
9
5
7
9
10
⎤
⎥⎥⎦,
B =
⎡
⎢⎢⎣
2
6
−1
−2
5
−1
2
3
−3
−4
1
10
5
−2
−3
8
⎤
⎥⎥⎦.
Compute the generalized eigenvalues and eigenvector matrices for the (A, B) pair.
Solution The following statements can be entered
>> A=[5,7,6,5; 7,10,8,7; 6,8,10,9; 5,7,9,10];
B=[2,6,-1,-2; 5,-1,2,3; -3,-4,1,10; 5,-2,-3,8];
[V,D]=eig(A,B), norm(A*V-B*V*D) % generalized eigenvalues and validations
and the eigenvalues and eigenvector matrices can be obtained
V =
⎡
⎢⎢⎣
0.3697
−0.37409 + j0.62591
−0.37409 −j0.62591
1
0.99484
−0.067434 −j0.25314
−0.067434 + j0.25314
−0.60903
0.79792
0.92389 + j0.026381
0.92389 −j0.026381
−0.23164
1
−0.65986 −j0.32628
−0.65986 + j0.32628
0.13186
⎤
⎥⎥⎦,
D =
⎡
⎢⎢⎣
4.7564
0
0
0
0
0.047055 + j0.17497
0
0
0
0
0.047055 −j0.17497
0
0
0
0
−0.003689
⎤
⎥⎥⎦.
and the norm of the error matrix is 1.5783×10−14.
4.3
Fundamental Matrix Transformations
4.3.1
Similarity transformations and orthogonal matrices
For a square matrix A, if there exists a nonsingular matrix B, then, the original A
matrix can be transformed into the following form
X = B−1AB,
(4-3-1)
and this transformation is referred to as similarity transformation, and matrix B is referred
to as the similarity transformation matrix. It can be shown that the determinant, rank,
trace and eigenvalues of the transformed matrix are not changed. Through properly chosen

Linear Algebra Problems
143
transformation matrix B, one may transform the original matrix A to other forms without
changing important properties of matrix A.
For a class of special transformation matrices T , if it satisﬁes T −1 = T H, where T H is the
Hermitian conjugate transpose of matrix T , matrix T is then referred to as an orthogonal
matrix, and it can be denoted that Q = T . Therefore, it can be seen that the orthogonal
matrix Q satisﬁes
QHQ = I,
and QQH = I,
(4-3-2)
where I is an n × n identity matrix.
A MATLAB function Q = orth(A) can be used to construct the orthonormal basis for
the column space of matrix A. If matrix A is nonsingular, the orthonormal basis matrix Q
obtained satisﬁes the conditions in (4-3-2). If matrix A is singular, however, the columns in
matrix Q equals the rank of matrix A, and satisﬁes QHQ = I, other than QQH = I.
Example 4.31
Compute the orthonormal basis for matrix A =
⎡
⎢⎢⎣
5
9
8
3
0
3
2
4
2
3
5
9
3
4
5
8
⎤
⎥⎥⎦.
Solution The orthonormal basis of a given matrix A can be established directly with the
orth() function, and the following statements can also be used to verify the properties of
the orthogonal matrix obtained.
>> A=[5,9,8,3; 0,3,2,4; 2,3,5,9; 3,4,5,8]; Q=orth(A) % orthonormal basis
[norm(Q’*Q-eye(4)), norm(Q*Q’-eye(4))]
% veriﬁcation of the properties
The orthonormal basis of A can then be found as
Q =
⎡
⎢⎢⎣
−0.61967134
0.77381388
−0.026187275
−0.12858357
−0.25484758
−0.15505966
0.94903028
0.10173858
−0.51978107
−0.52982004
−0.15628279
−0.65168555
−0.52998848
−0.31057898
−0.27245447
0.74055484
⎤
⎥⎥⎦,
with calculation errors ||QHQ −I|| = 4.6395×10−16, ||QQH −I|| = 4.9270×10−16.
Example 4.32
Consider the singular matrix A deﬁned in Example 4.10. Compute the
orthonormal basis matrix, and then, verify its properties.
Solution The orthonormal basis of matrix A can be obtained easily by the direct use of
the function orth().
>> A=[16,2,3,13; 5,11,10,8; 9,7,6,12; 4,14,15,1]; Q=orth(A),
a=norm(Q’*Q-eye(3)), Q1=orth(sym(A)), norm(Q1’*Q1-eye(3))
It can be seen that since A is a singular matrix with a rank of 3, the orthonormal basis
constructed is a rectangular matrix, and in the recent versions of MATLAB, the function
orth() support symbolic computation such that
Q =
⎡
⎢⎢⎣
−0.5
0.67082039324994
0.5
−0.5
−0.22360679774998
−0.5
−0.5
0.22360679774998
−0.5
−0.5
−0.67082039324994
0.5
⎤
⎥⎥⎦,
Q1 =
⎡
⎢⎢⎣
8
√
42/63
−635
√
21
√
12178/767214
109
√
5
√
6089/60890
5
√
42/126
391
√
21
√
12178/383607
−163
√
5
√
6089/60890
√
42/14
11
√
21
√
12178/42623
−197
√
5
√
6089/60890
2
√
42/63
1117
√
21
√
12178/767214
211
√
5
√
608960890
⎤
⎥⎥⎦,

144
Scientiﬁc Computing with MATLAB®
and the error ||QHQ −I|| = 1.0140×10−15.
4.3.2
Triangular and Cholesky factorizations
I. Row elimination and exchange with matrix multiplications
By left or right multiplying a matrix with deliberately selected matrix, the form of
the original matrix is changed. The selection of transformation matrices are demonstrated
through examples.
Example 4.33
For a given matrix A given below, please observe the eﬀect of matrix
multiplication with a deliberately chosen matrix E.
A =
⎡
⎢⎢⎣
16
2
3
13
5
11
10
8
9
7
6
12
4
14
15
1
⎤
⎥⎥⎦, E =
⎡
⎢⎢⎣
1
0
0
0
0
1
0
0
−2
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
Solution
The two matrices can be entered ﬁrst, then, the three matrices, A1 = EA,
A2 = AE and E1 = E−1 can be computed
>> A=[16,2,3,13; 5,11,10,8; 9,7,6,12; 4,14,15,1]; E=eye(4);
E1=inv(E), E(3,1)=-2; A1=E*A, A2=A*E
The three matrices are
A1 =
⎡
⎢⎢⎣
16
2
3
13
5
11
10
8
−23
3
0
−14
4
14
15
1
⎤
⎥⎥⎦, A2 =
⎡
⎢⎢⎣
10
2
3
13
−15
11
10
8
−3
7
6
12
−26
14
15
1
⎤
⎥⎥⎦, E1 =
⎡
⎢⎢⎣
1
0
0
0
0
1
0
0
2
0
1
0
0
0
0
1
⎤
⎥⎥⎦.
Is anything in particular observed? Declare E as an identity matrix ﬁrst, the ﬁnal E is
generated by setting the element in the third row, ﬁrst column (denoted by (3,1)th element)
to −2. E1 is a copy of E, however, the sign of its (3,1)th element is altered.
Now let us observe A1, which is obtained by left multiplying E to matrix A. Comparing
A and A1, it can be seen that only the third row is changed. The new third row is generated
by multiplying −2 to all the elements in the ﬁrst row and added to the third row of A. In
A2, only the ﬁrst column is changed into the sum of the ﬁrst column of A and −2 times
the third column of A.
With these rules in mind, matrix E can be deliberately constructed. For instance, if one
wants to eliminate all the elements in the ﬁrst column, except the ﬁrst one. The matrix E1
can be constructed with the following statements
>> E1=sym(eye(4)); E1(2:4,1)=-A(2:4,1)/A(1,1), A1=E1*A
and the constructed matrix and the product are given below, exactly the same as the one we
expected.
E1 =
⎡
⎢⎢⎣
1
0
0
0
−5/16
1
0
0
−9/16
0
1
0
−1/4
0
0
1
⎤
⎥⎥⎦, A1 =
⎡
⎢⎢⎣
16
2
3
13
0
83/8
145/16
63/16
0
47/8
69/16
75/16
0
27/2
57/4
−9/4
⎤
⎥⎥⎦.
Further another matrix E2 can be selected to eliminate the rest of the elements in column
two in A1, with a new E2, such that the matrices can be obtained with

Linear Algebra Problems
145
>> E2=sym(eye(4)); E2([1 3 4],2)=-A1([1 3 4],2)/A1(2,2), A2=E2*A1
E=E2*E1; A3=E*A % it can be seen that EA is the same as E2E1A
and the solutions are
E2 =
⎡
⎢⎢⎣
1
−16/83
0
0
0
1
0
0
0
−47/83
1
0
0
−108/83
0
1
⎤
⎥⎥⎦, A2 =
⎡
⎢⎢⎣
16
0
104/83
1016/83
0
83/8
145/16
63/16
0
0
−68/83
204/83
0
0
204/83
−612/83
⎤
⎥⎥⎦.
The overall transform matrix obtained is E = E2E1. This is the foundation of the
echelon and triangular factorization approaches.
Example 4.34
Still use the A matrix in Example 4.33. Now select the transform matrix
as follows, and observe what happens in matrix multiplications.
A =
⎡
⎢⎢⎣
16
2
3
13
5
11
10
8
9
7
6
12
4
14
15
1
⎤
⎥⎥⎦, E =
⎡
⎢⎢⎣
0
0
0
1
0
1
0
0
0
0
1
0
1
0
0
0
⎤
⎥⎥⎦.
Solution The matrix E is in fact constructed from an identity matrix, with its ﬁrst and
fourth rows exchanged. The matrices A1 = EA and A2 = AE can be computed with the
following statements
>> A=sym([16,2,3,13; 5,11,10,8; 9,7,6,12; 4,14,15,1]);
E=sym(eye(4)); E([1,4],:)=E([4,1],:); A1=E*A, A2=A*E
and the matrices can be obtained
A1 =
⎡
⎢⎢⎣
4
14
15
1
5
11
10
8
9
7
6
12
16
2
3
13
⎤
⎥⎥⎦, A2 =
⎡
⎢⎢⎣
13
2
3
16
8
11
10
5
12
7
6
9
1
14
15
4
⎤
⎥⎥⎦.
It can be observed that by left multiplying E to matrix A, the ﬁrst and fourth rows in
matrix A are swopped, to form the new matrix A1. If right multiplication is performed,
column swap is made.
II. Triangular factorizations
The triangular factorization of a matrix is also known as the LU factorization, where
the original matrix can be factorized into the product of a lower-triangular matrix L and
an upper-triangular matrix U, such that A = LU, where L and U can respectively be
written as
L =
⎡
⎢⎢⎢⎣
1
l21
1
...
...
...
ln1
ln2
· · ·
1
⎤
⎥⎥⎥⎦,
U =
⎡
⎢⎢⎢⎣
u11
u12
· · ·
u1n
u22
· · ·
u2n
...
...
unn
⎤
⎥⎥⎥⎦,
(4-3-3)
where the entities lij and uij can be calculated recursively that
lij =
aij −
j−1

k=1
likukj
ujj
,
(j < i),
and uij = aij −
i−1

k=1
likukj,
(j ⩾i),
(4-3-4)

146
Scientiﬁc Computing with MATLAB®
with initial values deﬁned as u1i = a1i, i = 1, 2, · · · , n.
It should be noted that since the pivot element was not selected in the above formula,
the direct use of such an algorithm may not be numerically stable, since small values or even
0 might be used as denominators. In MATLAB, a pivot-based LU factorization function
lu() is provided such that
[L,U] = lu(A)
% LU factorization A = LU
[L,U,P ] = lu(A)
% P is the permutation matrix, A = P −1LU
where L and U are transformed lower- and upper-triangular matrices. In MATLAB, the
lu() function considers the selection of pivoting element, thus, reliable results will be
ensured. The actual matrix L is not necessarily lower-triangular. In recent versions of
MATLAB, symbolic version of lu() is also supported, while in the ﬁrst syntax, pivot is
not considered.
Example 4.35
Consider the LU factorization problem to Example 4.10. Try to use the
two calling syntaxes of lu() to compute the triangular factorization, and then, compare the
results.
Solution For matrix A, the triangular factorization is performed such that
>> A=[16 2 3 13; 5 11 10 8; 9 7 6 12; 4 14 15 1]; [L1,U1]=lu(A)
where
L1 =
⎡
⎢⎢⎣
1
0
0
0
0.3125
0.76852
1
0
0.5625
0.43519
1
1
0.25
1
0
0
⎤
⎥⎥⎦,
U1 =
⎡
⎢⎢⎣
16
2
3
13
0
13.5
14.25
−2.25
0
0
−1.8889
5.6667
0
0
0
3.5527×10−15
⎤
⎥⎥⎦.
It can be seen that L1 matrix is not a lower-triangular matrix. It is the permutated
triangular matrix. Now, let us consider the other syntax to the lu() function
>> [L,U,P]=lu(A) % pivot is considered, and L is not really triangular
where
L=
⎡
⎢⎢⎣
1
0
0
0
0.25
1
0
0
0.3125
0.7685
1
0
0.5625
0.4352
1
1
⎤
⎥⎥⎦, U =
⎡
⎢⎢⎣
16
2
3
13
0
13.5
14.25
−2.25
0
0 −1.8889
5.6667
0
0
0
3.55×10−15
⎤
⎥⎥⎦, P =
⎡
⎢⎢⎣
1
0
0
0
0
0
0
1
0
1
0
0
0
0
1
0
⎤
⎥⎥⎦.
It should be noted that the matrix P is not an identity matrix, and it is just a
permutation matrix of such a matrix. The matrix A can be transformed back if the statement
inv(P )*L*U is used. If the symbolic lu() function is used
>> A=sym(A); [L2,U2]=lu(A) % symbolic computation, with L triangular
the exact triangular matrices can be found as
L2 =
⎡
⎢⎢⎣
1
0
0
0
5/16
1
0
0
9/16
47/83
1
0
1/4
108/83
−3
1
⎤
⎥⎥⎦,
U2 =
⎡
⎢⎢⎣
16
2
3
13
0
83/8
145/16
63/16
0
0
−68/83
204/83
0
0
0
0
⎤
⎥⎥⎦.
Example 4.36
For an arbitrary 3 × 3 matrix, please ﬁnd its LU factorization.
Solution The following commands can be used directly

Linear Algebra Problems
147
>> A=sym(’a%d%d’,3); [L U]=lu(A) % LU factorization for arbitrary matrix
and the results are
L =
⎡
⎣
1
0
0
a21/a11
1
0
a31/a11
(a32 −a12a31/a11)(a22 −a12a21/a11)
1
⎤
⎦,
U =
⎡
⎢⎢⎣
a11
a12
a13
0
a22 −a12a21/a11
a23 −a13a21/a11
0
0
a33 −(a23 −a13a21/a11) (a32 −a12a31/a11)
a22 −a12a21/a11
−a13a31
a11
⎤
⎥⎥⎦.
III. Cholesky factorization of symmetrical matrices
If matrix A is a symmetrical matrix, it can be factorized using LU factorization algorithm
such that
A = LLT =
⎡
⎢⎢⎢⎣
l11
l21
l22
...
...
...
ln1
ln2
· · ·
lnn
⎤
⎥⎥⎥⎦
⎡
⎢⎢⎢⎣
l11
l21
· · ·
ln1
l22
· · ·
ln2
...
...
lnn
⎤
⎥⎥⎥⎦,
(4-3-5)
and the LU factorization algorithm can be simpliﬁed such that
lii =
-
.
.
/aii −
i−1

k=1
l2
ik,
lji = 1
ljj
+
aij −
j−1

k=1
likljk
,
,
j < i,
(4-3-6)
and such an algorithm is referred to as the Cholesky factorization algorithm. To start with
the algorithm, one should have initially l11 = √a11, lj1 = aj1/l11.
A MATLAB function chol() is provided to perform Cholesky factorization such that
an upper-triangular matrix D is returned D = chol(A), where D = LT. Again in recent
versions of MATLAB, chol() function can also be used to deal with symbolic matrices.
Example 4.37
Consider a symmetrical matrix A, perform numerical and analytical
Cholesky factorizations.
A =
⎡
⎢⎢⎣
9
3
4
2
3
6
0
7
4
0
6
0
2
7
0
9
⎤
⎥⎥⎦.
Solution The Cholesky factorizations can be obtained directly with
>> A=[9,3,4,2; 3,6,0,7; 4,0,6,0; 2,7,0,9]; D=chol(A), L=chol(sym(A))
and the solutions are respectively
D =
⎡
⎢⎢⎣
3
1
1.3333
0.66667
0
2.2361
−0.59628
2.8324
0
0
1.9664
0.40684
0
0
0
0.60648
⎤
⎥⎥⎦, L =
⎡
⎢⎢⎢⎢⎢⎢⎣
3
0
0
0
1
√
5
0
0
4
3
−4
√
5
15
√
870
15
0
2
3
19
√
5
15
2
√
870
145
4
√
174
87
⎤
⎥⎥⎥⎥⎥⎥⎦
.

148
Scientiﬁc Computing with MATLAB®
IV. Positive-deﬁnite and regular matrices: deﬁnitions and tests
The concept of positive-deﬁniteness of matrices is established upon symmetrical
matrices. Before introducing the concept, the leading principal minors of a given matrix
are deﬁned. Assume that a symmetrical matrix A is
A =
⎡
⎢⎢⎢⎢⎢⎣
a11
a12
a13
· · ·
a1n
a12
a22
a23
· · ·
a2n
a13
a23
a33
· · ·
a3n
...
...
...
...
...
a1n
a2n
a3n
· · ·
ann
⎤
⎥⎥⎥⎥⎥⎦
,
(4-3-7)
with the upper-left cornered sub-matrices deﬁned as the leading principal sub-matrices. The
determinants of the sub-matrices are referred to as minors and can be calculated directly.
If all the leading principal minors of the matrix are positive, the matrix is referred to as a
positive-deﬁnite matrix. If they have alternative signs, the matrix is referred to as a negative-
deﬁnite matrix. If all the minors are non-negative, the matrix is referred to as a positive
semi-deﬁnite matrix.
The MATLAB function [D,p] = chol(A) can also be used to check whether a matrix
is positive-deﬁnite or not, where for positive-deﬁnite matrix A, p = 0 will be returned. Thus,
such a function can be used to check whether a symmetrical matrix is positive-deﬁnite or
not. For matrices which are not positive-deﬁnite, a variable p will be returned, where p −1
is the size of the sub-matrix in A which is positive-deﬁnite, i.e., the size of matrix D.
If a complex matrix A satisﬁes
AHA = AAH
(4-3-8)
where AH is the Hermitian transpose of matrix A, then, the matrix is referred to as a
regular matrix. The judgement can be made using the following MATLAB statements
norm(A’*A-A*A’)< ϵ, if 1 is returned, then, it can be concluded that A is a regular
matrix.
Example 4.38
Judge whether matrix A given below is a positive-deﬁnite matrix or not.
Then, perform Cholesky factorization to the matrix.
A =
⎡
⎢⎢⎣
7
5
5
8
5
6
9
7
5
9
9
0
8
7
0
1
⎤
⎥⎥⎦.
Solution Cholesky factorization to matrix A is performed
>> A=[7,5,5,8; 5,6,9,7; 5,9,9,0; 8,7,0,1]; [D,p]=chol(A)
The positive-deﬁnite part D of the matrix can be obtained. It is seen that matrix A is
not a positive-deﬁnite matrix, therefore, p̸=0. It is found that

2.6457513
1.8898224
0
1.5583874

, and
p = 3.
If one calls the chol() function to an asymmetrical matrix A, the results are also
obtained. However, the results are useless, since it erroneously forced the original matrix
into the symmetrical one. Strictly speaking, Cholesky factorization cannot be performed
upon asymmetrical matrices.

Linear Algebra Problems
149
4.3.3
Companion, diagonal and Jordan transformations
I. Transform an ordinary matrix into companion form
For a given matrix A, if there exists a column vector x, such that matrix T created by
T = [x, Ax, · · · , An−1x] is nonsingular, the matrix A can be transformed into a companion-
like matrix. The conversion matrix T is not unique.
Example 4.39
Transform the matrix in Example 4.31 into a companion matrix.
Solution A column vector x can be generated randomly, and then, rounded such that only
0’s and 1’s appear in the vector. Loop structure can be used to ﬁnd such an x vector so that
the matrix T generated is a nonsingular matrix.
>> A=[5,7,6,5; 7,10,8,7; 6,8,10,9; 5,7,9,10];
while(1), x=floor(2*rand(4,1)); T=sym([x A*x A^2*x A^3*x]);
if rank(T)==4, break; end, end
T, A1=inv(T)*A*T
which yields
T =
⎡
⎢⎢⎣
1
11
326
9853
0
15
453
13696
1
16
472
14296
0
14
444
13489
⎤
⎥⎥⎦,
A1 =
⎡
⎢⎢⎣
0
0
0
−1
1
0
0
100
0
1
0
−146
0
0
1
35
⎤
⎥⎥⎦.
It should be noted that the matrix T is not unique. The matrix A1 is quite similar to
the companion matrix deﬁned in (4-1-7). If one does need the standard companion form,
the following statements can further be given
>> T1=inv(T*fliplr(eye(4)))’, A2=inv(T1)*A*T1
the transformation matrix and companion form are as follows:
T =
1
14053
⎡
⎢⎢⎣
−318
10591
−29493
19064
−176
5243
3298
−11368
318
−10591
29493
−5011
75
−1835
−13063
2928
⎤
⎥⎥⎦,
A2 =
⎡
⎢⎢⎣
35
−146
100
−1
1
0
0
0
0
1
0
0
0
0
1
0
⎤
⎥⎥⎦.
II. Diagonal matrix transformation
If there is no repeated eigenvalues in matrix A, the eigenvector matrix V obtained
with eig() function can be used as the transformation matrix, and through similarity
transformation, the diagonal matrix can be obtained, and the diagonal elements are in fact
the eigenvalues of the matrix.
Example 4.40
Please perform diagonalization to the following matrix
A =
⎡
⎢⎢⎣
3
2
2
2
1
2
−2
−2
−1
−2
0
−2
0
1
3
5
⎤
⎥⎥⎦.
Solution
It can be seen through the following commands that the eigenvalues of A are
1, 2, 3, 4, and are distinct. Thus, the transformation matrix can be selected as the eigenvector
matrix

150
Scientiﬁc Computing with MATLAB®
>> A=[3,2,2,2; 1,2,-2,-2; -1,-2,0,-2; 0,1,3,5];
[v,d]=eig(sym(A)); A1=inv(v)*A*v % A1 is the same as d
and the transformation and diagonalized matrices can be found as
v =
⎡
⎢⎢⎣
1
0
−1
0
−1
0
1
−1
−1
−1
1
0
1
1
−2
1
⎤
⎥⎥⎦,
A1 =
⎡
⎢⎢⎣
1
0
0
0
0
2
0
0
0
0
3
0
0
0
0
4
⎤
⎥⎥⎦.
Example 4.41 Consider the following matrix with complex eigenvalues. Please convert it
into a diagonal matrix.
A =
⎡
⎢⎢⎣
1
0
4
0
0
−3
0
0
−2
2
−3
0
0
0
0
−2
⎤
⎥⎥⎦.
Solution The eigenvalues and eigenvector matrix can both be obtained with eig() function.
>> A=[1,0,4,0; 0,-3,0,0; -2,2,-3,0; 0,0,0,-2]; [V,D]=eig(sym(A))
The transformation matrix and diagonal matrix can be obtained as
V =
⎡
⎢⎢⎣
−1
0
−1 + j
−1 −j
−1
0
0
0
1
0
1
1
0
1
0
0
⎤
⎥⎥⎦,
J =
⎡
⎢⎢⎣
−3
0
0
0
0
−2
0
0
0
0
−1 −2j
0
0
0
0
−1 + 2j
⎤
⎥⎥⎦.
It can be seen that the diagonal matrix contains complex values. In the next part, we
shall ﬁnd a way to convert it to some kind of special “diagonal” matrix.
III. Jordan transformation
The matrices containing repeated eigenvalues cannot be decomposed into diagonal
matrices. Instead, Jordan decomposition should be used.
Example 4.42
For a given matrix
A =
⎡
⎢⎢⎣
−71
−65
−81
−46
75
89
117
50
0
4
8
4
−67
−121
−173
−58
⎤
⎥⎥⎦,
compute its eigenvalues and eigenvector matrix using both numerical and analytical
methods.
Solution
With the use of MATLAB, the numerical solutions to the eigenvalues can be
found from the following statements
>> A=[-71,-65,-81,-46; 75,89,117,50; 0,4,8,4; -67,-121,-173,-58];
D=eig(A), [V1,D1]=eig(sym(A)) % repeated eigenvalues
where the eigenvalues of matrix A are λ(A) = −8.0045, −8 ± 8 + j0.004, −7.9955, and
they seem to be distinct eigenvalues. In fact, the numerical results are misleading, and with
symbolic computation, it is found that −8 is the quadruple eigenvalue of the matrix, and
the eigenvector matrix is a column vector of v = [17/8, −13/8, 1, −19/8]T. This means that

Linear Algebra Problems
151
the eigenvector matrix is not invertible and cannot transform the matrix into a diagonal
matrix.
Due to the restrictions of numerical packages and languages, including the numerical
solutions provided by MATLAB language, the best data type is the double-precision one.
Thus, in computation with such languages, computation errors are unavoidable.
In order to solve this kind of problem, it is suggested that the symbolic data type be used
instead. Using the jordan() function in the Symbolic Math Toolbox, the Jordan matrix as
well as the nonsingular generalized eigenvector matrix can be obtained. The syntaxes of the
function are
J = jordan(A)
% only the Jordan matrix J returned
[V ,J] = jordan(A)
% Jordan J and generalized vector matrix V
When the generalized eigenvector matrix V is found, the Jordan canonical form can be
obtained from J = V −1AV . It should be noted that the main diagonal elements in the
Jordan matrix are the eigenvalues, with the main sub-diagonal elements taking 1’s.
Example 4.43
Perform Jordan decomposition for the matrix in Example 4.42.
Solution The Jordan decomposition for a given symbolic matrix can be obtained directly
by the use of jordan() function such that
>> A=[-71,-65,-81,-46; 75,89,117,50; 0,4,8,4; -67,-121,-173,-58];
[V,J]=jordan(sym(A)) % ﬁnd Jordan decomposition
and one has
V =
⎡
⎢⎢⎣
−18496
2176
−63
1
14144
−800
75
0
−8704
32
0
0
20672
−1504
−67
0
⎤
⎥⎥⎦,
J =
⎡
⎢⎢⎣
−8
1
0
0
0
−8
1
0
0
0
−8
1
0
0
0
−8
⎤
⎥⎥⎦.
The matrix V is now a full-rank matrix and is invertible. Therefore, it is possible
to implement some special operations which are very hard to implement using numerical
methods. The applications of such a function will be demonstrated later.
Example 4.44
Please revisit the matrix in Example 4.41, where there are complex
eigenvalues. The diagonal elements contain complex values. If in the transformation matrix,
the real and imaginary parts are extracted to form two columns to replace the complex
conjugate columns, the following MATLAB function can be written
function V1=realjordan(V)
n=length(V); i=0; vr=real(V); vi=imag(V); n1=n;
while(i<n1), i=i+1; V1(:,i)=vr(:,i), vv=vi(:,i);
if any(abs(vv)>1e-10), i=i+1; V1(:,i)=vv;
end, end
Therefore, for the matrix with complex eigenvalues, alternative real Jordan form can be
transformed
>> A=[1,0,4,0; 0,-3,0,0; -2,2,-3,0; 0,0,0,-2]; [V,D]=eig(sym(A));
V1=realjordan(V), A1=inv(V1)*A*V1 % ﬁnd real Jordan form

152
Scientiﬁc Computing with MATLAB®
and the transformation matrix and real Jordan form are
V1 =
⎡
⎢⎢⎣
−1
0
−1
1
−1
0
0
0
1
0
1
0
0
1
0
0
⎤
⎥⎥⎦,
A1 =
⎡
⎢⎣
−3
0
0
0
0
−2
0
0
0
0
−1 −2
0
0
2
−1
⎤
⎥⎦.
It can be seen that A1 is no longer a diagonal matrix. It is a real matrix with a Jordan
block in the lower-right corner of matrix A1.
Example 4.45
Perform Jordan transformation to the following matrix.
A =
⎡
⎢⎢⎢⎢⎢⎢⎣
0
−1
0
0
−1
1
0.5
0
−0.5
0
−1
0.5
−0.5
0
−0.5
0
0
0.5
468.5
452
304.5
577
225
360.5
−468
−450
−303
−576
−223
−361
−467.5
−451
−303.5
−576
−223
−361.5
⎤
⎥⎥⎥⎥⎥⎥⎦
.
Solution The eigenvalues of the matrix A can be obtained
>> A=[0,-1,0,0,-1,1; 0.5,0,-0.5,0,-1,0.5; -0.5,0,-0.5,0,0,0.5;
468.5,452,304.5,577,225,360.5; -468,-450,-303,-576,-223,-361;
-467.5,-451,-303.5,-576,-223,-361.5];
A=sym(A); eig(A), [v,J]=jordan(A)
and the eigenvalues are −2, −2, −1 ± j2, −1 ± j2. It can be seen that there exist repeated
complex eigenvalues −1 ± j2. The simplest way to manipulate is to swap the 4th and 5th
column in the transformation matrix v, and call realjordan() function to extract the real
transformation matrix. In this case, the real Jordan block matrix can be obtained
>> v(:,[4 5])=v(:,[5,4]); V=realjordan(v), J=inv(V)*A*V
and the new real transformation matrix and transformed real Jordan matrix can ﬁnally be
found as
V =
⎡
⎢⎢⎢⎢⎢⎢⎣
423/25
−543/125
851/100
757/100
334/125
−9321/1000
−423/25
7431/250
2459/100
663/100
−7431/500
−509/1000
423/5
−471/10
−757/40
851/40
471/20
−1887/80
4371/25
−70677/250
−47327/400
−9191/100
70677/500
247587/4000
−4653/25
31353/125
16263/200
15991/200
−31353/250
−96843/2000
−5922/25
76539/250
22507/200
12399/200
−76539/500
−74767/2000
⎤
⎥⎥⎥⎥⎥⎥⎦
,
J =
⎡
⎢⎢⎢⎢⎢⎣
−2
1
0
0
0
0
0
−2
0
0
0
0
0
0
−1 −2
1
0
0
0
2
−1
0
1
0
0
0
0
−1 −2
0
0
0
0
2
−1
⎤
⎥⎥⎥⎥⎥⎦
.
4.3.4
Singular value decompositions
Singular values of a matrix can be regarded as a measure of the matrix. For any given
n × m matrix A, one has
ATA ⩾0,
AAT ⩾0,
(4-3-9)

Linear Algebra Problems
153
and in theory, it follows that
rank(ATA) = rank(AAT) = rank(A).
(4-3-10)
It can further be shown that the matrices ATA and AAT have the same non-negative
eigenvalues λi. The square roots of these non-negative eigenvalues are referred to as the
singular values of matrix A, denoted as
σi(A) =

λi(ATA).
(4-3-11)
Example 4.46
For a matrix A =
⎡
⎣
1
1
μ
0
0
μ
⎤
⎦, where μ = 5eps, ﬁnd the rank of matrix A
using (4-3-10).
Solution
It is obvious that the rank of matrix A is 2. The same result can be obtained
from the following MATLAB statement.
>> A=[1 1; 5*eps,0; 0,5*eps]; rank(A) % directly assess the rank
Now consider the method in (4-3-10) for calculating the rank of matrix A. If ATA is
used for ﬁnding the rank of matrix A, it can be seen that
ATA =
1 + μ2
1
1
1 + μ2

,
and under double-precision scheme, since μ2 is around 10−30, it can be completely neglected
when added to 1. Thus, matrix ATA is reduced to a matrix of ones. It can be concluded
that the rank of matrix A is 1, which is obviously wrong. Therefore, the concepts of singular
values for matrix A should be introduced to provide a better characterization for the matrices.
If matrix A is an n × m matrix, it can be decomposed as
A = LA1M
(4-3-12)
where matrices L and M are orthogonal matrices, and A1 = diag(σ1, · · · , σn) is a diagonal
matrix, whose elements satisfy the inequality σ1 ⩾σ2 ⩾· · · ⩾σn ⩾0. If σn = 0, then,
matrix A is singular. The rank of matrix A is in fact the number of non-zero quantities
in the diagonal elements of matrix A1. The transformation is referred to as singular value
decomposition (SVD).
A singular value decomposition function svd() is provided in MATLAB
S = svd(A)
% only singular value decomposition required
[L,A1,M] = svd(A)
% singular value decomposition
where A is the original matrix and the returned matrix A1 is a diagonal matrix, while the
matrices L and M are orthogonal matrices, satisfying A = LA1M T. In recent versions
of MATLAB, symbolic A is supported, however, there are usually no analytical solutions,
only high-precision solutions are obtained.
The singular values of a matrix often determine the properties of the matrix. When
some of the singular values are large, while others are small, and they diﬀer signiﬁcantly,
then, very small perturbation to certain elements in the matrix may signiﬁcantly aﬀect the
behavior of the matrix. This kind of matrix is often referred to as an ill- or bad-conditioned

154
Scientiﬁc Computing with MATLAB®
matrix. If zeros exist in the singular values, then, the matrix is a singular matrix. The ratio of
maximum singular value σmax and the minimum one σmin is deﬁned as the condition number
of the matrix, denoted by cond(A), i.e., cond(A) = σmax/σmin. The larger the condition
number of the matrix, the more sensitive the matrix is. The maximum and minimum singular
values of the matrix may also be denoted by ¯σ(A) and σ(A), respectively. A MATLAB
function cond(A) is provided to calculate the condition number of the matrix A, and for
singular matrices, the condition number is inﬁnity.
Example 4.47
Performing SVD to the matrix A in Example 4.10.
Solution
If the MATLAB function svd() is used, the matrices L, A1 and M can be
obtained. The condition number can also be calculated by the singular values.
>> A=[16,2,3,13; 5,11,10,8; 9,7,6,12; 4,14,15,1]; [L,A1,M]=svd(A)
It can be found that the decomposed matrices are
L =
⎡
⎢⎢⎣
−0.5
0.67082
0.5
−0.22361
−0.5
−0.22361
−0.5
−0.67082
−0.5
0.22361
−0.5
0.67082
−0.5
−0.67082
0.5
0.22361
⎤
⎥⎥⎦, A1 =
⎡
⎢⎢⎣
34
0
0
0
0
17.889
0
0
0
0
4.4721
0
0
0
0
0
⎤
⎥⎥⎦,
M =
⎡
⎢⎢⎣
−0.5
0.5
0.67082
−0.22361
−0.5
−0.5
−0.22361
−0.67082
−0.5
−0.5
0.22361
0.67082
−0.5
0.5
−0.67082
0.22361
⎤
⎥⎥⎦.
It can be seen that since there exists a zero singular value, the original matrix is a
singular matrix. The condition number of the matrix should be inﬁnity; however, since
numerical calculation is used, there might be minor errors. The commands cond(A) will
result the condition number 3.2592×1016.
One can convert matrix A into a symbolic variable, then, with the function svd(), more
accurate singular value decomposition can be obtained.
Example 4.48
For a rectangular matrix A =

1
3
5
7
2
4
6
8

, perform singular value
decomposition to matrix A, and then, verify the results.
Solution The following statements can be given such that
>> A=[1,3,5,7; 2,4,6,8]; [L,A1,M]=svd(A); A2=L*A1*M’; norm(A-A2)
The decomposited matrices are
L =
−0.64142
−0.76719
−0.76719
0.64142

, A1 =
14.269
0
0
0
0
0.62683
0
0

,
M =
⎡
⎢⎢⎣
−0.15248
0.82265
−0.3945
−0.37996
−0.34992
0.42138
0.2428
0.80066
−0.54735
0.020103
0.69791
−0.46143
−0.74479
−0.38117
−0.54621
0.040738
⎤
⎥⎥⎦,
and it can be seen that the error ||LA1V T −A|| = 9.7277×10−15 and, for this example,
LA1V T will restore the original matrix A, with very small error.

Linear Algebra Problems
155
4.4
Solving Matrix Equations
Solutions of various matrix equations are discussed in the section. The commonly
encountered linear algebraic equation in AX
=
B is discussed ﬁrst, followed by
Lyapunov equations, Sylvester equations and Riccati equations. Polynomial equations such
as Diophantine equations are also discussed.
4.4.1
Solutions to linear algebraic equations
Consider the linear algebraic equation
Ax = B,
(4-4-1)
where A are B given matrices
A =
⎡
⎢⎢⎢⎣
a11
a12
· · ·
a1n
a21
a22
· · ·
a2n
...
...
...
...
am1
am2
· · ·
amn
⎤
⎥⎥⎥⎦,
B =
⎡
⎢⎢⎢⎣
b11
b12
· · ·
b1p
b21
b22
· · ·
b2p
...
...
...
...
bm1
bm2
· · ·
bmp
⎤
⎥⎥⎥⎦,
(4-4-2)
and the target is to ﬁnd matrix x for the equation. According to linear algebra theory,
in some cases, there are unique solutions, and in other cases, the equation may have an
inﬁnite number of solutions, or have no solution at all. Thus, here the solutions to the linear
equation can be considered thoroughly.
(i) Unique solutions
If m = n and rank(A) = n, then, the equations in (4-4-1) have
unique solutions
x = A−1B.
(4-4-3)
The solution x = inv(A)*B can be obtained immediately using MATLAB to the
original equation. It should be noted that if the numerical method is used, sometimes the
inv() function may lead to erroneous results. For instance, if cond(A) is very large, the
results may be unreliable. If the Symbolic Math Toolbox is used, then, this problem may
be avoided.
Example 4.49
Solve the linear algebraic equations
⎡
⎢⎢⎣
1
2
3
4
4
3
2
1
1
3
2
4
4
1
3
2
⎤
⎥⎥⎦X =
⎡
⎢⎢⎣
5
1
4
2
3
3
2
4
⎤
⎥⎥⎦.
Solution The analytical solutions to the given equations can be obtained using the following
MATLAB statements.
>> A=[1 2 3 4; 4 3 2 1; 1 3 2 4; 4 1 3 2]; B=[5 1; 4 2; 3 3; 2 4];
x=inv(sym(A))*B % ﬁnd the analytical solution
Therefore, the solutions can be written as x =
⎡
⎢⎢⎣
−9/5
12/5
28/15
−19/15
58/15
−49/15
−32/15
41/15
⎤
⎥⎥⎦.
Substituting the results back to the equations, one may ﬁnd that there is no error. If in
the above statement, the numerical statement is used instead, i.e., x = inv(sym(A))*B is
replaced by x = inv(A)*B, an error level of 10−15 may be achieved.

156
Scientiﬁc Computing with MATLAB®
(ii) Equations with inﬁnite number of solutions
One may construct ﬁrst the
judging matrix C out of A, B matrices
C =
⎡
⎢⎢⎢⎣
a11
a12
· · ·
a1n
b11
b12
· · ·
b1p
a21
a22
· · ·
a2n
b21
b22
· · ·
b2p
...
...
...
...
...
...
...
...
am1
am2
· · ·
amn
bm1
bm2
· · ·
bmp
⎤
⎥⎥⎥⎦.
(4-4-4)
If rank(A) = rank(C) = r < n, the original equations (4-4-1) have an inﬁnite number
of solutions. One may ﬁnd the n −r basic set of solutions xi, i = 1, 2, · · · , n −r to the
homogeneous equations Ax = 0. From which, for any constant αi, i = 1, 2, · · · , n −r, the
general solutions to the homogeneous equations can be written as
ˆx = α1x1 + α2x2 + · · · + αn−rxn−r.
(4-4-5)
The solution basis can be found directly using MATLAB function null() such that
Z = null(sym(A)), and the function null() can also be used in numerical cases, where
in this case, the syntax Z = null(A,’r’) should be used instead. The resulted Z matrix
should have n −r columns, to which each one is referred to as a basic set of solutions for
the given matrix A.
Solving equations (4-4-1) is not a diﬃcult task. If a special solution x0 to (4-4-1) can be
found, the general solutions to the original equations can be constructed from x = ˆx + x0.
In fact, the special solution can be found from x0 = pinv(A)*B.
Example 4.50
Find all the solutions of linear algebraic equation [6]
⎡
⎢⎢⎣
1
4
0
−1
0
7
−9
2
8
−1
3
9
−13
7
0
0
2
−3
−4
12
−8
−1
−4
2
4
8
−31
37
⎤
⎥⎥⎦X =
⎡
⎢⎢⎣
3
9
1
4
⎤
⎥⎥⎦.
Solution The matrices A and B can be entered ﬁrst, and matrix C can be constructed.
Judging from the ranks of A and C,
>> A=[1,4,0,-1,0,7,-9; 2,8,-1,3,9,-13,7;
0,0,2,-3,-4,12,-8; -1,-4,2,4,8,-31,37];
B=[3; 9; 1; 4]; C=[A B]; rank(A), rank(C) % the ranks are equal
it can be seen that they both equal to 3, which is smaller than the number of unknowns. It
can then be concluded that the equations have an inﬁnite number of solutions, with four free
variables. The null space Z and a particular solution x0 can be obtained with
>> Z=null(sym(A)), x0=sym(pinv(A)*B) % ﬁnd the null space
a=sym(’a%d’,[4,1]); x=Z*a+x0, E=A*x-B % construct the general solution
The null space and a particular solution of the equations can be found as follows, from
which the general solutions of the equations can be found for all free symbolic entities a1,
a2, a3 and a4.

Linear Algebra Problems
157
Z =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
−4
−2
−1
3
1
0
0
0
0
−1
3
−5
0
−2
6
−6
0
1
0
0
0
0
1
0
0
0
0
1
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
, x0 =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
92/395
368/395
459/790
−24/79
347/790
247/790
303/790
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
, x=
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
−4a1 −2a2 −a3 + 3a4 + 92/395
a1 + 368/395
−a2 + 3a3 −5a4 + 459/790
−2a2 + 6a3 −6a4 −24/79
a2 + 347/790
a3 + 247/790
a4 + 303/790
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
Alternatively, with the reduced row echelon form technique, the general solution can also
be found
>> C=[A B]; D=rref(C) % resolve the equation with reduced row echelon form
with the reduced row echelon form of
D =
⎡
⎢⎢⎣
1
4
0
0
2
1
−3
4
0
0
1
0
1
−3
5
2
0
0
0
1
2
−6
6
1
0
0
0
0
0
0
0
0
⎤
⎥⎥⎦.
It can be seen that the variables x2, x5, x6 and x7 are free variables. The general solutions
can be interpreted from matrix D, that x1 = −4x2 −2x5 −x6 + 3x7 + 4, x3 = −x5 + 3x6 −
5x7 + 2, x4 = −2x5 + 6x6 −6x7 + 1.
Example 4.51
Please solve the following underdetermined linear algebraic equation
4
7
1
4
3
7
4
6

x =
3
4

.
Solution The ranks of A and C are all 2 and are equal. Thus, the original equation has
an inﬁnite number of solutions. With the two following two approaches, the solutions are
found
x1 =
⎡
⎢⎢⎣
a1
a2 + 8/21
6a1/5 + 7a2/5 + 1/3
−13a1/10 −21a2/10
⎤
⎥⎥⎦,
x2 =
⎡
⎢⎢⎣
3b1 + 2b2 −1
−13b1/7 −12b2/7 + 1
b1
b2
⎤
⎥⎥⎦.
>> A=[4,7,1,4; 3,7,4,6]; B=[3; 4]; C=[A B]; rank(A), rank(C)
syms a1 a2 b1 b2; x1=null(sym(A))*[a1; a2]+sym(A\B), A*x1-B
a=rref(sym([A B])); x2=[a(:,3:5)*[-b1; -b2; 1]; b1; b2], A*x2-B
It can be seen that the two sets of solutions all satisfy the original equation.
(iii) Equations with no solutions
If rank(A) < rank(C), then, the equations
in (4-4-1) are conﬂict equations, and there are no solutions to such equations. Applying
Moore–Penrose inverse x = pinv(A)*B, one may obtain the least squares solution to the
original equations such that the norm of the error ||Ax −B|| is minimized.
Example 4.52
Please solve the following algebraic linear equation
⎡
⎢⎢⎣
1
2
3
4
2
2
1
1
2
4
6
8
4
4
2
2
⎤
⎥⎥⎦X =
⎡
⎢⎢⎣
1
2
3
4
⎤
⎥⎥⎦.

158
Scientiﬁc Computing with MATLAB®
Solution The matrices A and B can be entered ﬁrst, and matrix C can be constructed. It
can be seen that the rank of matrix C is 3, which is higher than that of matrix A, indicating
that there is no solution to the original equations
>> A=[1 2 3 4; 2 2 1 1; 2 4 6 8; 4 4 2 2];
B=[1:4]’; C=[A B]; [rank(A), rank(C)] % the ranks are diﬀerent
One may use function pinv() to evaluate the Moore–Penrose inverse to matrix A, then,
the least squares solutions to the conﬂict equations can be obtained as
>> x=pinv(A)*B, norm(A*x-B) % validate the result, try also x=pinv(sym(A))*B
Using the above statements, one may ﬁnd the solutions xT = [0.9542, 0.7328, −0.0763,
−0.29771]. Substituting the solution back to the original equations, the norm of the solution
error is 0.4472, which is the smallest possible error level.
For linear algebraic equations of the form xA = B, one may perform transpose to both
sides of the equation to transform the original equation to the following form
ATz = BT,
(4-4-6)
where z = xT, the new equations can be transformed into the form in (4-4-1), and the
above methods can be applied directly to solve the original problems.
4.4.2
Solutions to Lyapunov equations
I. Continuous Lyapunov equations
A continuous Lyapunov equation can be expressed as
AX + XAT = −C,
(4-4-7)
and it is known that Lyapunov equations are originated from stability theory of diﬀerential
equations, where one often expects −C to be symmetrical positive-deﬁnite n × n matrix. It
follows that the solution X is also an n × n symmetrical matrix. Direct solutions to such
equations were rather diﬃcult; however, with the use of powerful computer mathematics
languages, such a function can be solved easily by using the lyap() function provided in
the Control Systems Toolbox. The syntax of the function is X = lyap(A,C), and if one
speciﬁes matrices A and C, the numerical solutions to the Lyapunov equations can be
obtained immediately.
Example 4.53
Assume that in (4-4-7), the matrices A and C are given by
A =
⎡
⎣
1
2
3
4
5
6
7
8
0
⎤
⎦,
C = −
⎡
⎣
10
5
4
5
6
7
4
7
9
⎤
⎦,
solve the corresponding Lyapunov equation and check the accuracy of the solutions.
Solution One may enter the matrices into MATLAB, then, solve the equation using the
following MATLAB statements
>> A=[1 2 3;4 5 6; 7 8 0];
C=-[10, 5, 4; 5, 6, 7; 4, 7, 9];
X=lyap(A,C), norm(A*X+X*A’+C) % numerical solution and validation

Linear Algebra Problems
159
the solution obtained is
X =
⎡
⎣
−3.9444444444444
3.8888888888889
0.38888888888889
3.8888888888889
−2.7777777777778
0.22222222222222
0.38888888888889
0.22222222222222
−0.11111111111111
⎤
⎦,
and the norm of the error matrix is ||AX + XAT + C|| = 2.64742×10−14. It can be seen
that the accuracy in the solutions obtained is very high.
II. Analytical solutions to Lyapunov equations
For simplicity, the matrices in the Lyapunov equation can be rearranged such that
X =
⎡
⎢⎢⎢⎣
x1
x2
· · ·
xm
xm+1
xm+2
· · ·
x2m
...
...
...
...
x(n−1)m+1 x(n−1)m+2
· · ·
xnm
⎤
⎥⎥⎥⎦, C =
⎡
⎢⎢⎢⎣
c1
c2
· · ·
cm
cm+1
cm+2
· · ·
c2m
...
...
...
...
c(n−1)m+1 c(n−1)m+2
· · ·
cnm
⎤
⎥⎥⎥⎦.
The Lyapunov equation can be rewritten as a simple linear equation
(A ⊗I + I ⊗A)x = −c,
(4-4-8)
where A ⊗B denotes the Kronecker product of matrices A and B such that
A ⊗B =
⎡
⎢⎣
a11B
· · ·
a1mB
...
...
...
an1B
· · ·
anmB
⎤
⎥⎦,
(4-4-9)
and MATLAB evaluation of the product is C = kron(A,B).
It can now be seen that the conditions when the equation has a unique solution is
no longer that −C is a positive-deﬁnite symmetrical matrix. It requires that the matrix
(A ⊗I + I ⊗A) is a nonsingular square matrix.
Example 4.54
Consider again the Lyapunov equation in Example 4.53, and ﬁnd the
analytical solutions.
Solution
The analytical solution of the Lyapunov equation can be obtained from the
following statements, and if one substitutes the solutions back to the original equation, there
is no error.
>> I=eye(3); A0=sym(kron(A,I)+kron(I,A)); % construct (A⊗I + I⊗A) matrix
c=reshape(C’,9,1); x0=-inv(A0)*c; x=reshape(x0,3,3)’ % analytical
The analytical solutions can be obtained as
x =
⎡
⎣
−71/18
35/9
7/18
35/9
−25/9
2/9
7/18
2/9
−1/9
⎤
⎦.
Example 4.55
Traditionally in Lyapunov equations, one may assume that matrix C
is a real and symmetrically positive-deﬁnite matrix. Find whether there are solutions to
Lyapunov equations if C is not a symmetrical real matrix.
Solution Since the Lyapunov equation was originated from stability theory, it was usually
assumed that matrix −C is a real and symmetrically positive-deﬁnite matrix. In fact,

160
Scientiﬁc Computing with MATLAB®
(4-4-12) will also have unique solutions even when the above conditions are not satisﬁed.
For instance, if matrix C is changed into a complex asymmetrical matrix
C = −
⎡
⎣
1 + j1
3 + j3
12 + j10
2 + j5
6
11 + j6
5 + j2
11 + j1
2 + j12
⎤
⎦,
while matrix A remains unchanged in Example 4.53, the complex solution matrix X will be
immediately obtained.
>> A=[1 2 3;4 5 6; 7 8 0]; % specify the matrices
C=-[1+1i, 3+3i, 12+10i; 2+5i, 6, 11+6i; 5+2i, 11+1i, 2+12i];
A0=sym(kron(A,eye(3))+kron(eye(3),A));
c=reshape(C.’,9,1);
x0=-inv(A0)*c; x=reshape(x0,3,3).’
norm(A*x+x*A.’+C) % validation of the results
The solution is
x =
⎡
⎣
−5/102 + j1457/918
15/17 −j371/459
−61/306 + j166/459
4/17 −j626/459
−10/51 + j160/459
115/153 + j607/459
−55/306 + j166/459
−26/153 −j209/459
203/153 + j719/918
⎤
⎦,
and it can be concluded that there is no error at all in the solution. Thus, if one does not
consider the energy concept in the physical model, matrix C can be generalized into any
matrix in the Lyapunov matrix.
III. Solutions of Stein equations
The typical form of Stein equation is
AXB −X + Q = 0,
(4-4-10)
where, all the equations are n×n square matrices. Similar to the previous discussion, matrix
X can be expanded as a vector x, and matrix Q can be expanded as another vector q.
Thus, Stein equation can be solved directly with the following linear algebraic equation

In2×n2 −BT ⊗A

x = q.
(4-4-11)
Example 4.56
Please solve the following Stein equation
⎡
⎣
−2
2
1
−1
0
−1
1
−1
2
⎤
⎦X
⎡
⎣
−2
−1
2
1
3
0
3
−2
2
⎤
⎦−X +
⎡
⎣
0
−1
0
−1
1
0
1
−1
−1
⎤
⎦= 0.
Solution The equation can be solved with the following MATLAB statements
>> A=[-2,2,1; -1,0,-1; 1,-1,2]; B=[-2,-1,2; 1,3,0; 3,-2,2];
Q=[0,-1,0; -1,1,0; 1,-1,-1]; x=inv(sym(eye(9))-kron(B’,A))*Q(:);
X=reshape(x,3,3), norm(A*X*B-X+Q) % solve and validate
and the analytical solution is
X =
⎡
⎣
4147/47149
3861/471490
−40071/235745
−2613/94298
2237/235745
−43319/235745
20691/94298
66191/235745
−10732/235745
⎤
⎦.

Linear Algebra Problems
161
IV. Discrete Lyapunov equations
A discrete Lyapunov equation can be expressed in the form
AXAT −X + Q = 0,
(4-4-12)
which can be solved easily by using dlyap() function provided by Control Systems Toolbox
of MATLAB. The syntax of the function is X = dlyap(A,Q). The analytical solution
method will be discussed later.
Example 4.57
Solve the discrete Lyapunov equation
⎡
⎣
8
1
6
3
5
7
4
9
2
⎤
⎦X
⎡
⎣
8
1
6
3
5
7
4
9
2
⎤
⎦
T
−X +
⎡
⎣
16
4
1
9
3
1
4
2
1
⎤
⎦= 0.
Solution
The numerical solution to the equation can easily be solved by the use of the
function dlyap() such that
>> A=[8,1,6; 3,5,7; 4,9,2]; Q=[16,4,1; 9,3,1; 4,2,1];
X=dlyap(A,Q), norm(A*X*A.’-X+Q)
% solve and check accuracy
with the error of 2.7778×10−14, and
X =
⎡
⎣
−0.16474
0.06915
−0.016785
0.052843
−0.029785
−0.0061542
−0.10198
0.044959
−0.030541
⎤
⎦.
4.4.3
Solutions to Sylvester equations
A Sylvester equation takes the general form
AX + XB = −C,
(4-4-13)
where A is an n × n matrix, B is an m × m matrix, and C and X are n × m matrices. This
equation is also known as the generalized Lyapunov equation. The function lyap() can still
be used such that X = lyap(A,B,C). Schur decomposition is an eﬀective way in solving
such an equation.
Similar to the above mentioned Lyapunov equation, the analytical solutions can also be
found with the help of Kronecker products
(A ⊗Im + In ⊗BT)x = c.
(4-4-14)
If (A ⊗Im + In ⊗BT) is nonsingular, the Sylvester equation has a unique solution.
Combining the above mentioned analytical solution algorithms, a symbolic-based
MATLAB function lyapsym.m for Sylvester equations can be written. The listing of the
function is
function X=lyapsym(A,B,C)
if nargin==2, C=B; B=A.’; end
[nr,nc]=size(C); A0=kron(A,eye(nc))+kron(eye(nr),B.’);
try
C1=C.’; x0=-inv(A0)*C1(:); X=reshape(x0,nc,nr).’;
catch, error(’singular matrix found.’), end

162
Scientiﬁc Computing with MATLAB®
Considering the discrete Lyapunov equation shown in (4-4-12). If one multiplies both
sides of the equation by (AT)−1, then, the original discrete Lyapunov equation can be
rewritten as
AX + X[−(AT)−1] = −Q(AT)−1.
Let B = −(AT)−1, C = Q(AT)−1, the equation can be transformed into a Sylvester
equation deﬁned in (4-4-13). Thus, the new lyapsym() function can be used to solve such
equations. The syntaxes of the function now are
X = lyapsym(A,C)
% continuous Lyapunov equation
X = lyapsym(A,-inv(B),Q*inv(B))
% Stein equation
X = lyapsym(A,-inv(A’),Q*inv(A’))
% discrete Lyapunov equation
X = lyapsym(A,B,C)
% Sylvester equation
In recent versions of MATLAB, sylvester() function is provided for ﬁnding numerical
solutions of Sylvester equations, using the Kronecker product based algorithm. The syntax
of the function is also X = sylvester(A,B,C).
Example 4.58
Solve the following Sylvester equation
⎡
⎣
8
1
6
3
5
7
4
9
2
⎤
⎦X + X
⎡
⎣
16
4
1
9
3
1
4
2
1
⎤
⎦=
⎡
⎣
1
2
3
4
5
6
7
8
0
⎤
⎦.
Solution The original equation can easily be solved by calling lyap() function
>> A=[8,1,6; 3,5,7; 4,9,2]; B=[16,4,1; 9,3,1; 4,2,1];
C=-[1,2,3; 4,5,6; 7,8,0]; X=lyap(A,B,C), norm(A*X+X*B+C)
and the solution with error norm of 1.0436×10−14 can be obtained
X =
⎡
⎣
0.074872
0.089913
−0.43292
0.0080716
0.48144
−0.21603
0.019577
0.18264
1.1579
⎤
⎦.
If one wants to have the analytical solutions, the following statements can be given
>> x=lyapsym(sym(A),B,C), norm(A*x+x*B+C) % ﬁnd analytical solution
the solution now is
x =
⎡
⎣
1349214/18020305
648107/7208122
−15602701/36040610
290907/36040610
3470291/7208122
−3892997/18020305
70557/3604061
1316519/7208122
8346439/7208122
⎤
⎦,
and it can be seen that there is no longer any error in the solution.
Example 4.59
Consider again the discrete Lyapunov equation given in Example 4.57,
now ﬁnd the analytical solution of the equation.
Solution The analytical solutions to the original equation can be found
>> A=[8,1,6; 3,5,7; 4,9,2]; Q=[16,4,1; 9,3,1; 4,2,1];
x=lyapsym(sym(A),-inv(A.’),Q*inv(A.’)), norm(A*x*A.’-x+Q)

Linear Algebra Problems
163
the solution can then be found, and it is with zero error.
x =
⎡
⎣
−22912341/139078240
48086039/695391200
−11672009/695391200
36746487/695391200
−20712201/695391200
−4279561/695391200
−70914857/695391200
31264087/695391200
−4247541/139078240
⎤
⎦.
Example 4.60
Solve the Sylvester equation with
A =
⎡
⎣
8
1
6
3
5
7
4
9
2
⎤
⎦,
B =
2
3
4
5

,
C =
⎡
⎣
1
2
3
4
5
6
⎤
⎦.
Solution
In Sylvester equations, the matrix C is not necessarily square. The analytical
solutions to the equation can be found using the new lyapsym() function
>> A=[8,1,6; 3,5,7; 4,9,2]; B=[2,3; 4,5]; C=-[1,2; 3,4; 5,6];
X=lyapsym(sym(A),B,C), norm(A*X+X*B+C)
and the solution with zero error is found
X =
⎡
⎣
−2853/14186
−11441/56744
−557/14186
−8817/56744
9119/14186
50879/56744
⎤
⎦.
If the (2,1)th parameter in B matrix is changed to a free variable a, the Sylvester equation
can still be solved with
>> syms a real; B=sym(B); B(2,1)=a;
X=simplify(lyapsym(A,B,C)), norm(A*X+X*B+C) % solve and validate
with the validated solution
X =
⎡
⎢⎢⎢⎢⎢⎢⎢⎣
6

3a3 + 155a2 −2620a + 200

27a3 −3672a2 + 69300a + 6800
−
513a2 −10716a + 80420
27a3 −3672a2 + 69300a + 6800
4

9a3 −315a2 + 314a + 980

27a3 −3672a2 + 69300a + 6800
−
3

201a2 −7060a + 36780

27a3 −3672a2 + 69300a + 6800
2

27a3 −1869a2 + 25472a −760

27a3 −3672a2 + 69300a + 6800
−477a2 + 4212a + 194300
27a3 −3672a2 + 69300a + 6800
⎤
⎥⎥⎥⎥⎥⎥⎥⎦
.
4.4.4
Solutions of Diophantine equations
The equations discussed so far are matrix equations. Now consider a polynomial equation
given by
A(s)X(s) + B(s)Y (s) = C(s),
(4-4-15)
where, A(s), B(s) and C(s) are known polynomials given by
A(s) = a1sn + a2sn−1 + a3sn−2 + · · · + ans + an+1,
B(s) = b1sm + b2sm−1 + b3sm−2 + · · · + bms + bm+1,
C(s) = c1sk + c2sk−1 + c3sk−2 + · · · + cks + ck+1.
(4-4-16)
Such a polynomial equation is referred to as a Diophantine equation. Without losing

164
Scientiﬁc Computing with MATLAB®
generality, assume that m ⩽n. The orders of the unknown polynomials X(s) and Y (s) are
respectively m −1 and n −1, such that
X(s) = x1sm−1 + x2sm−2 + x3sm−3 + · · · + xm−1s + xm,
Y (s) = y1sn−1 + y2sn−2 + y3sn−3 + · · · + yn−1s + yn.
(4-4-17)
The matrix form of the Diophantine equation can be written as
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
a1
0
· · ·
0
b1
0
· · ·
0
a2
a1
...
0
b2
b1
...
0
a3
a2
...
0
b3
b2
...
0
...
...
...
a1
...
...
...
b1
an+1
an
...
a2
·
·
...
b2
0
an+1
...
a3
·
·
...
b3
...
...
...
...
...
...
...
...
0
0
· · ·
an+1
0
0
· · ·
bm+1
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
x1
x2
...
xm
y1
y2
...
yn
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
=
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
0
...
0
c1
c2
...
ck+1
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
.

	

m columns

	

n columns
(4-4-18)
The coeﬃcient matrix is the transpose of Sylvester matrix. It can be shown that, if two
polynomials A(s) and B(s) are coprime, the Sylvester matrix is nonsingular. Therefore, the
equation has a unique solution. To check whether two polynomials are coprime or not, the
simplest way is to ﬁnd the greatest common divisor of the two polynomials and see whether
it includes s. If no polynomial is found in greatest common divisor, the two polynomials are
coprime.
A MATLAB function can be written to construct a Sylvester matrix
function S=sylv_mat(A,B)
n=length(B)-1; m=length(A)-1; S=[];
A1=[A(:); zeros(n-1,1)]; B1=[B(:); zeros(m-1,1)];
for i=1:n, S=[S A1]; A1=[0; A1(1:end-1)]; end
for i=1:m, S=[S B1]; B1=[0; B1(1:end-1)]; end; S=S.’;
Based on such a function, a MATLAB function diophantine() for solving the
Diophantine equation can be written as follows
function [X,Y]=diophantine(A,B,C,x)
A1=polycoef(A,x); B1=polycoef(B,x); C1=polycoef(C,x);
n=length(B1)-1; m=length(A1)-1; S=sylv_mat(A1,B1);
C2=zeros(n+m,1); C2(end-length(C1)+1:end)=C1(:); x0=inv(S.’)*C2;
X=poly2sym(x0(1:n),x); Y=poly2sym(x0(n+1:end),x);
Example 4.61
Please solve the Diophantine equation with the polynomials
A(s) = s4 −27s3
10
+ 11s2
4
−1249s
1000 + 53
250,
B(s) = 3s2 −6s
5 + 51
25, C(s) = 2s2 + 3s
5 −9
25.
Solution The following statements can be used to solve the equation

Linear Algebra Problems
165
>> syms s; A=s^4-27*s^3/10+11*s^2/4-1249*s/1000+53/250;
B=3*s^2-6*s/5+51/25; C=2*s^2+3*s/5-9/25;
[X,Y]=diophantine(A,B,C,s), simplify(A*X+B*Y-C)
The solutions to the Diophantine equation can be obtained as follows. If the results are
substituted back to the original equation, it can be seen that the error is zero, which validated
the results.
X(s) = 4280 s
4453 + 9480
4453,
Y (s) = −4280s3
13359 + 364s2
13359 + 16882s
13359 −1771
4453.
4.4.5
Solutions to Riccati equations
A Riccati equation is a quadratic matrix equation which can be written as
ATX + XA −XBX + C = 0.
(4-4-19)
Due to the quadratic term of matrix X, solving such an equation is more diﬃcult
than Lyapunov type equations. There are no analytical solutions to such equations. A
numerical-based function are() is provided in the Control Systems Toolbox, such that
X = are(A,B,C).
Example 4.62
Consider the Riccati equation in (4-4-19), where
A =
⎡
⎣
−2
1
−3
−1
0
−2
0
−1
−2
⎤
⎦, B =
⎡
⎣
2
2
−2
−1
5
−2
−1
1
2
⎤
⎦,
C =
⎡
⎣
5
−4
4
1
0
4
1
−1
5
⎤
⎦.
Find the numerical solution, and then, validate the results.
Solution The following commands can be used in solving the Riccati equation
>> A=[-2,1,-3; -1,0,-2; 0,-1,-2]; B=[2,2,-2; -1 5 -2; -1 1 2];
C=[5 -4 4; 1 0 4; 1 -1 5]; X=are(A,B,C), norm(A.’*X+X*A-X*B*X+C)
and the numerical solution is found
X =
⎡
⎣
0.98739491
−0.7983277
0.418869
0.57740565
−0.13079234
0.57754777
−0.284045
−0.073036978
0.69241149
⎤
⎦.
It can also be found that the norm of the error matrix is 1.8605×10−14, which is small
enough. More solutions can be given in Chapter 6.
Of course, there are limitations in solving Riccati equations, since are() function can
only return one solution. Are there any other solutions? If there are, how many are there and
how can they be found? Are there any complex solutions? How to solve diﬀerent variations
of Riccati equations such as
AX + XD −XBX + C = 0,
AX + XD −XBXT + C = 0.
(4-4-20)
The current version of are() function fail to ﬁnd solutions to all these problems. In
Chapter 6, methods will be presented in ﬁnding all the possible solutions to these problems.

166
Scientiﬁc Computing with MATLAB®
4.5
Nonlinear Functions and Matrix Function Evaluations
Two kinds of functions for matrices are provided in MATLAB. One is for element-by-
element calculation of matrices, while the other is for matrix functions. In this section, these
two types of functions are explored.
4.5.1
Element-by-element computations
A large number of functions have been provided in MATLAB to carry out element-
by-element nonlinear function computation. For instance, the sin(x) function used in
Chapter 2 calculates sinusoidal to each element of the matrix x. The element-by-element
computation is useful especially in graphics. The “dot operation” is another example of
element-by-element operation. The commonly used element-by-element nonlinear functions
are summarized in Table 4.2. The syntax for this kind of operation is very simple,
B = funname(A),
for instance
B = sin(A) .
TABLE 4.2: Commonly used element-by-element nonlinear functions.
Function name
Meaning
Function name
Meaning
abs()
absolute value
asin(),acos(),atan()
inverse triangular functions
sqrt()
square roots
log(),log10()
logarithmic function
exp()
exponential function
real(),imag(),conj()
real, imaginary or conjugates
sin(),cos(),tan()
triangular functions
round(),floor(),ceil()
integer functions
Example 4.63
Consider the matrix A in Example 4.10. Call the functions exp() and
sin() to complete nonlinear functions computations.
Solution The following functions can be used, and the element-by-element exponential and
sinusoidal functions can be found
>> A=[16,2,3,13; 5,11,10,8; 9,7,6,12; 4,14,15,1]; exp(A), sin(A)
The results obtained are
exp(A) =
⎡
⎢⎢⎣
8.8861×106
7.3891
20.086
4.4241×105
148.41
59874
22026
2981
8103.1
1096.6
403.43
1.6275×105
54.598
1.2026×106
3.269×106
2.7183
⎤
⎥⎥⎦,
sin(A) =
⎡
⎢⎢⎣
−0.2879
0.9093
0.14112
0.42017
−0.95892
−0.99999
−0.54402
0.98936
0.41212
0.65699
−0.27942
−0.53657
−0.7568
0.99061
0.65029
0.84147
⎤
⎥⎥⎦.
4.5.2
Computations of matrix exponentials
Apart from element-by-element nonlinear computation of matrices, sometimes the
nonlinear functions on the whole matrices, i.e., matrix functions, are expected. For instance,

Linear Algebra Problems
167
if one wants to have the exponential function to a matrix, special algorithms should be
required.
The exponential function of matrix A is deﬁned as an inﬁnite series
eA =
∞

i=0
1
i!Ai = I + A + 1
2A2 + 1
3!A3 + · · · + 1
m!Am + · · · .
(4-5-1)
Nineteen diﬀerent numerical algorithms have been summarized in Reference [7], and
each algorithm has its own advantages. The built-in MATLAB function expm() can be
used with E = expm(A). Taylor series approximation can also be used to evaluate the
exponential function from the above deﬁnition with a truncation algorithm.
Example 4.64
Consider a matrix
A =
⎡
⎢⎢⎢⎢⎣
−2
1
0
0
−2
1
0
0
−2
−5
1
0
−5
⎤
⎥⎥⎥⎥⎦
.
Compute the exponential function eA, then, calculate the logarithmic function and see
whether the original matrix A can be restored. Also, ﬁnd analytically eAt.
Solution
The following MATLAB statements can be used to calculate the exponential
matrix B = eA, then, the use of logm() function can be used to calculate the logarithmic
function to restore matrix A
>> A=[[-2 1 0; 0 -2 1; 0 0 -2], zeros(3,2); zeros(2,3) [-5 1; 0 -5]];
B=expm(A), C=logm(B), norm(C-A) % numerical solution and validation
Thus, one may ﬁnd that
B =
⎡
⎢⎢⎢⎢⎣
0.13534
0.13534
0.067668
0
0
0
0.13534
0.13534
0
0
0
0
0.13534
0
0
0
0
0
0.0067379
0.0067379
0
0
0
0
0.0067379
⎤
⎥⎥⎥⎥⎦
,
and C is almost equal to A, with the restoration error ||C −A|| = 3.9014×10−15. It can be
seen that the accuracy of such algorithms is very high.
The expm() function is also applicable to symbolic matrices. For instance, the
exponential function eAt can also be obtained by the direct use of such a function. This
kind of problem cannot be solved using the numerical methods of course.
>> syms t; expm(A*t) % symbolic computation
So the results can be written as
eAt =
⎡
⎢⎢⎢⎢⎣
e−2t
te−2t
t2e−2t/2
0
0
0
e−2t
te−2t
0
0
0
0
e−2t
0
0
0
0
0
e−5t
te−5t
0
0
0
0
e−5t
⎤
⎥⎥⎥⎥⎦
.
In fact, since matrix A is a block Jordan matrix, the results can easily be written out,
even without the help of computers.

168
Scientiﬁc Computing with MATLAB®
Example 4.65
For a given matrix A, calculate eAt.
A =
⎡
⎣
−3
−1
−1
0
−3
−1
1
2
0
⎤
⎦.
Solution The exponential function of A can be obtained directly using the expm() function
such that
>> syms t; A=[-3,-1,-1; 0,-3,-1; 1,2,0]; F=simplify(expm(A*t))
and the result is
F =
⎡
⎣
−e−2t(−1 + t)
−te−2t
−te−2t
−t2e−2t/2
−e−2t(−1 + t + t2/2)
−te−2t(2 + t/2)
te−2t/2
te−2t(2 + t/2)
e−2t(1 + 2t + t2/2)
⎤
⎦.
Now consider a Jordan transformation technique for solving such a problem. First,
Jordan transformation should be obtained such that
>> [V,J]=jordan(A)
%
Jordan transformation
the transformation can then be obtained
V =
⎡
⎣
0
−1
1
−1
0
0
1
1
0
⎤
⎦,
J =
⎡
⎣
−2
1
0
0
−2
1
0
0
−2
⎤
⎦,
where the matrix V obtained is no longer singular.
Since the exponential of a Jordan matrix is known, it can be directly entered, and then,
the exponential function of the original matrix can be obtained from
>> J1=[exp(-2*t), t*exp(-2*t), 1/2*t^2*exp(-2*t);
0,
exp(-2*t),
t*exp(-2*t);
0,
0,
exp(-2*t)];
A1=simplify(V*J1*inv(V))
and the results are exactly the same as the one obtained above.
It should be noted that the use of Jordan matrix to solve the exponential matrix function
is not the best method, since it can be calculated directly otherwise. The use of the Jordan
function here indicates that this method can be extended to other applications. And in later
subsections, the use of Jordan matrices will be explored thoroughly.
4.5.3
Trigonometric functions of matrices
There are no MATLAB functions for trigonometric matrix operations. One may use
the universal function funm() instead to ﬁnd the numerical solution to such problems.
This function is intended to be used for any nonlinear matrix functions, such that
A1 = funm(A,fun), where the name of the function should be quoted using single quotation
marks. For instance, if one wants to evaluate sin A, the statement B = funm(A,’sin’)
should be provided. Only in the most recent versions such as MATLAB R2014b, the
functions like funm(A*t,’sin’) can be used directly.
It should be noted that in earlier versions of MATLAB, since the computation used
the eigenvector-based algorithm, erroneous results may be obtained if A has repeated
eigenvalues.

Linear Algebra Problems
169
Example 4.66
Consider again the matrix given in Example 4.64. Find the sinusoidal
function of the matrix.
Solution The function funm() can be used to calculate the sinusoidal matrix.
>> A=[[-2 1 0; 0 -2 1; 0 0 -2], zeros(3,2); zeros(2,3) [-5 1; 0 -5]];
funm(A,’sin’)
Thus, the result can be obtained
sin A =
⎡
⎢⎢⎢⎢⎣
−0.9093
−0.41615
0.45465
0
0
0
−0.9093
−0.41615
0
0
0
0
−0.9093
0
0
0
0
0
0.95892
0.28366
0
0
0
0
0.95892
⎤
⎥⎥⎥⎥⎦
.
In fact, some certain matrix functions can be evaluated by the use of Taylor series
expansion technique. For instance, sinusoidal function can be evaluated from
sin A =
∞

i=0
(−1)i A2i+1
(2i + 1)! = A −1
3!A3 + 1
5!A5 + · · · .
(4-5-2)
So the MATLAB function can be written to compute the sinusoidal matrix
function E=sinm1(A)
E=zeros(size(A)); F=A; k=1;
while norm(E+F-E,1)>0, E=E+F; F=-A^2*F/((k+2)*(k+1)); k=k+2; end
Example 4.67
Solve again the above problem with the new sinm1() function.
Solution
From the above explanation, it can be seen that the seemingly complicated
sinusoidal matrix functions can easily be solved using a few statements in MATLAB. With
such a function, sin A can easily be obtained
>> E=sinm1(A)
It can be measured that 39 terms have been added in the above computation, and the
results are exactly the same as the one obtained from the previous example.
For sinusoidal and cosine functions, if a scalar a is given, the trigonometric functions
satisfy the well-known Euler formula, such that eja = cos a+j sin a and e−ja = cos a−j sin a.
From them, one can ﬁnd out immediately that
sin a = 1
j2(eja −e−ja),
cos a = 1
2(eja + e−ja),
(4-5-3)
and the new formula holds also if the scalar a is replaced by a matrix A. Some examples
will be given to show such computations.
Example 4.68
Consider also the matrix in Example 4.64, evaluate sin A.
Solution The existing expm() function can be used to evaluate the sinusoidal function
>> A=[[-2 1 0; 0 -2 1; 0 0 -2], zeros(3,2); zeros(2,3) [-5 1; 0 -5]];
j=sqrt(-1); A1=(expm(A*j)-expm(-A*j))/(2*j)

170
Scientiﬁc Computing with MATLAB®
which yields
sin A =
⎡
⎢⎢⎢⎢⎣
−0.9093
−0.41615
0.45465
0
0
0
−0.9093
−0.41615
0
0
0
0
−0.9093
0
0
0
0
0
0.95892
0.28366
0
0
0
0
0.95892
⎤
⎥⎥⎥⎥⎦
,
which agrees well with the results in Example 4.67, which means that the algorithm is correct.
Example 4.69
Consider a given matrix
A =
⎡
⎢⎢⎣
−7
2
0
−1
1
−4
2
1
2
−1
−6
−1
−1
−1
0
−4
⎤
⎥⎥⎦.
It is known that the matrix contains repeated eigenvalues. Compute matrix functions
sin At and cos At. Also, please ﬁnd tanAt.
Solution
From (4-5-3), the following statements can be obtained for the sinusoidal and
cosine functions.
>> A=sym([-7,2,0,-1; 1,-4,2,1; 2,-1,-6,-1; -1,-1,0,-4]);
syms t; j=sym(sqrt(-1)); % declare symbolic variables
A1=simplify((expm(A*j*t)-expm(-A*j*t))/(2*j)) % sinusoidal function
A2=simplify((expm(A*j*t)+expm(-A*j*t))/2)
% cosine function
The results obtained are
sin At=
⎡
⎢⎢⎣
−2/9 sin3t+(t2−7/9) sin6t−5/3t cos6t
−1/3 sin3t+1/3 sin6t+t cos6t
−2/9 sin3t+(t2+2/9) sin6t+1/3t cos6t
−1/3 sin3t−2/3 sin6t+t cos6t
−2/9 sin3t+(−2t2+2/9) sin6t+4/3t cos6t
−1/3 sin3t+1/3 sin6t−2t cos6t
4/9 sin3t+(t2−4/9) sin6t+1/3t cos6t
2/3 sin3t−2/3 sin6t+t cos6t
−2/9 sin3t+(2/9+t2) sin 6t−2/3t cos6t
1/9 sin3t+(−1/9+t2) sin 6t−2/3t cos6t
−2/9 sin3t+(2/9+t2) sin 6t+4/3t cos6t
1/9 sin3t+(−1/9+t2) sin 6t+4/3t cos6t
−2/9 sin3t−(7/9+2t2) sin 6t−2/3t cos6t
1/9 sin 3t−(1/9+2t2) sin 6t−2/3t cos6t
4/9 sin 3t+(−4/9+t2) sin 6t+4/3t cos6t
−2/9 sin3t+(−7/9+t2) sin 6t+4/3t cos6t
⎤
⎥⎥⎦
cos At=
⎡
⎢⎢⎣
2/9 cos3t+(−t2+7/9) cos6t−5/3t sin6t
1/3 cos3t−1/3 cos6t+t sin6t
2/9 cos3t−(t2+2/9) cos6t+1/3t sin6t
1/3 cos3t+2/3 cos6t+t sin6t
2/9 cos3t+(2t2−2/9) cos6t+4/3t sin6t
1/3 cos3t−1/3 cos6t−2t sin6t
−4/9 cos3t+(−t2+4/9) cos6t+1/3t sin6t
−2/3 cos3t+2/3 cos6t+t sin6t
2/9 cos3t−(2/9+ t2) cos 6t−2/3t sin6t
−1/9 cos3t+(1/9−t2) cos 6t−2/3t sin6t
2/9 cos3t−(2/9+t2) cos 6t+4/3t sin6t
−1/9 cos3t+(1/9−t2) cos 6t+4/3t sin6t
2/9 cos3t+(7/9+2t2) cos 6t−2/3t sin6t
−1/9 cos3t+(1/9+2t2) cos 6t−2/3t sin6t
−4/9 cos3t+(4/9−t2) cos 6t+4/3t sin6t
2/9 cos3t+(7/9−t2) cos 6t+4/3t sin6t
⎤
⎥⎥⎦.
The above results were actually obtained in old versions of Symbolic Math Toolbox, and
in new versions, far more complicated results are obtained and cannot be simpliﬁed. In later
examples, an alternative approach is used.
Since sin At and cos At are obtained, the matrix function tanAt can be evaluated with
F = A1*inv(A2), however, it might too complicated to present here.
In recent versions of MATLAB, the matrix functions sin At, cos At and tanAt can

Linear Algebra Problems
171
be obtained directly with funm(A*t,’sin’), funm(A*t,’cos’) and funm(A*t,’tan’),
respectively.
4.5.4
General matrix functions
In this section, a Jordan matrix-based algorithm [8] is presented and implicated for the
evaluation of an arbitrary function ϕ(A). Also, the matrix functions containing the time
variable t can be evaluated. Before presenting such an algorithm, let us ﬁrst observe the
behaviors of a nilpotent matrix.
Example 4.70
Please observe the behavior of a nilpotent matrix.
Solution Observe the power of the nilpotent matrix in a loop
>> H=diag([1 1 1],1), for i=2:4, H^i, end % observe the positions of 1’s
and the following power matrices can be observed, and it can be seen that from H4 on, all
the subsequent powers are zero matrices
H =
⎡
⎢⎢⎣
0
1
0
0
0
0
1
0
0
0
0
1
0
0
0
0
⎤
⎥⎥⎦, H2 =
⎡
⎢⎢⎣
0
0
1
0
0
0
0
1
0
0
0
0
0
0
0
0
⎤
⎥⎥⎦, H3 =
⎡
⎢⎢⎣
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
⎤
⎥⎥⎦, H4 =
⎡
⎢⎢⎣
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
⎤
⎥⎥⎦.
With Jordan decomposition, matrix A can be transformed such that
A = V
⎡
⎢⎢⎢⎣
J1
J2
...
Jm
⎤
⎥⎥⎥⎦V −1.
(4-5-4)
Using Jordan matrix decomposition, the arbitrary function ϕ(A) can be evaluated from
ϕ(A) = V
⎡
⎢⎢⎢⎣
ϕ(J1)
ϕ(J2)
...
ϕ(Jm)
⎤
⎥⎥⎥⎦V −1.
(4-5-5)
To solve such a problem, one can ﬁrst write an mi × mi Jordan block Ji as Ji =
λiI + Hmi, where λi is a repeated eigenvalue of multiplicity mi, and Hmi is a nilpotent
matrix, i.e., when k ⩾mi, Hk
mi ≡0. It can be shown that the matrix function ϕ(Ji) can
be obtained as follows:
ϕ(Ji) = ϕ(λi)Imi + ϕ′(λi)Hmi + · · · + ϕ(mi−1)(λi)
(mi −1)! Hmi−1
mi
.
(4-5-6)
An algorithm is designed to compute arbitrary matrix function ϕ(A).
Require: Matrix A, prototype expression ϕ(x), independent variable x
For A, ﬁnd Jordan transform matrices V , J, and mark m Jordan blocks,
for i = 1 To m do

172
Scientiﬁc Computing with MATLAB®
Extract Ji from J, compute ϕ(Ji) from (4-5-6), compose ϕ(J)
end for
Compute the matrix function ϕ(A) from (4-5-5).
Based on the above algorithm, the following new MATLAB funmsym() function can be
written. This function can be used to ﬁnd the analytical solution of any matrix function.
The listing of the function is
function F=funmsym(A,fun,x)
[V,T]=jordan(A); vec=diag(T); v1=[0,diag(T,1)’,0];
v2=find(v1==0); lam=vec(v2(1:end-1)); m=length(lam);
for i=1:m,
k=v2(i):v2(i+1)-1; J1=T(k,k); F(k,k)=funJ(J1,fun,x);
end
F=V*F*inv(V);
function fJ=funJ(J,fun,x)
%
sub function to compute ϕ(Ji)
lam=J(1,1); f1=fun; fJ=subs(fun,x,lam)*eye(size(J));
H=diag(diag(J,1),1); H1=H; %
generate nilpotent matrix H1
for i=2:length(J)
%
compute ϕ(Ji) in a loop
f1=diff(f1,x); a1=subs(f1,x,lam); fJ=fJ+a1*H1; H1=H1*H/i;
end
The syntax of the function is A1 = funmsym(A,funx,x), where x is a symbolic variable,
funx is the prototype function ϕ(·) of variable x. For instance, if one wants eA, function
funx should be deﬁned as exp(x). In fact, the variable funx can be assigned to an arbitrarily
complicated function, i.e., exp(x*t) means that one wants to have eAt, and t could also be
a symbolic variable. Composite functions such as exp(x*cos(x*t)) can also be used here
to indicate that one wants to calculate ϕ(A) = eA cos At.
Example 4.71
Solve the matrix functions in Example 4.69 with the new function.
Solution It has been indicated that the matrix functions sin At, cos At and tanAt obtained
with new Symbolic Math Toolbox are complicated, while in old versions, the results are much
simpler. The simpliﬁed results can be obtained with the following commands. Thus, this
method is recommended.
>> A=sym([-7,2,0,-1; 1,-4,2,1; 2,-1,-6,-1; -1,-1,0,-4]);
syms t x; C=simplify(funmsym(A,cos(x*t),x))
S=simplify(funmsym(A,sin(x*t),x)), T=simplify(funmsym(A,tan(x*t),x))
Example 4.72
For matrix
A =
⎡
⎢⎢⎣
−7
2
0
−1
1
−4
2
1
2
−1
−6
−1
−1
−1
0
−4
⎤
⎥⎥⎦,
compute the matrix functions F1 = eA cos At and F2 = eA2tA2 + sin(A3t)At + esin At.
Solution If the matrix function F1 = eA cos At is required, the following MATLAB state-
ments should be entered

Linear Algebra Problems
173
>> A=[-7,2,0,-1; 1,-4,2,1; 2,-1,-6,-1; -1,-1,0,-4];
syms x t; F1=funmsym(sym(A),exp(x*cos(x*t)),x)
Since the results obtained are very lengthy, only the ﬁrst term of the results is displayed
as follows:
ϕ1,1(A) = 2/9e−3 cos 3t + (2t sin 6t + 6t2 cos 6t)e−6 cos 6t + (cos 6t −6t sin 6t)2e−6 cos 6t
−5/3(cos6t −6t sin 6t)e−6 cos 6t + 7/9e−6 cos 6t.
It can be seen from the results that in ϕ1,1(t), the term e−6 cos 6t is repeatedly used, thus,
one may collect that term using the following statement to simplify the result
>> collect(F1(1,1),exp(-6*cos(6*t)))
which leads to the following simpliﬁed result of ϕ1,1(A)
ϕ1,1(A) =

12t sin6t + 6t2 cos 6t + (cos 6t −6t sin 6t)2 −5
3 cos 6t + 7
9

e−6 cos 6t + 2
9e−3 cos 3t.
Further, if one assumes t = 1, the matrix eA cos A can be found such that
>> subs(A1,t,1), % which is the same as expm(A*funm(A,’cos’))
The complicated function is
eA cos A =
⎡
⎢⎢⎣
4.3583
6.5044
4.3635
−2.1326
4.3718
6.5076
4.3801
−2.116
4.2653
6.4795
4.2518
−2.2474
−8.6205
−12.984
−8.6122
4.3832
⎤
⎥⎥⎦.
The complicated matrix function eA2tA2 + sin(A3t)At + esin At can also be evaluated
directly with funmsym() function
>> F=funmsym(A,exp(x^2*t)*x^2+sin(x^3*t)*x*t+exp(sin(x*t)),x)
4.5.5
Power of a matrix
The target of the section is to ﬁnd the kth power a given square matrix, i.e., Ak, where
k is a positive integer. If k is not an integer, it is meaningless discussing the matrix Ak since
it is a sum of an inﬁnite number of matrices. There is no use to run MATLAB command
A^k, since no result can be found. We shall begin this section with a simple example, and
then, the idea can be generalized to arbitrary matrices.
Suppose A can be transformed into a Jordan matrix, A = V JV −1. Then, Ak =
V JkV −1, and we shall concentrate on ﬁnding Jk.
As it was pointed out in the previous subsection that J = λI + Hm, where, Hm is
m × m nilpotent matrix, with Hk
m ≡0, for k ⩾m. With binomial expansion, it is known
that
Jk = λkI + kλk−1Hm + k(k −1)
2!
λk−2H2
m + · · · .
(4-5-7)
Since Hm
m and subsequent terms are all zero, the above equation can be reduced to the
sum of m terms, and the analytical solution of Jk can easily be obtained.
Example 4.73 Consider a given matrix studied in Example 4.65, rewritten below. Please
ﬁnd Ak for an integer k.

174
Scientiﬁc Computing with MATLAB®
A =
⎡
⎣
−3
−1
−1
0
−3
−1
1
2
0
⎤
⎦.
Solution Jordan transformation can be carried out ﬁrst
>> A=sym([-3,-1,-1; 0,-3,-1; 1,2,0]); syms k, [V J]=jordan(sym(A))
it is found J is a 3 × 3 Jordan matrix, with eigenvalue of λ = −2. Thus, H = J −λI can
be used to extract the nilpotent matrix, and the power of the matrix can be easily found with
>> A0=-2*eye(3); H=J-A0; % ﬁnd nilpotent matrix and add up 3 terms
J1=A0^k+k*A0^(k-1)*H+k*(k-1)/2*A0^(k-2)*H^2, F=simplify(V*J1*inv(V))
and the ﬁnal kth power of A can be found as follows, and it is interesting to note that it
applies also for negative integers
F =
⎡
⎣
(−2)k(k + 2)/2
(−2)kk/2
(−2)kk/2
−(−2)(k−2)k(k −1)/2
(−2)k(−k2 + 5k + 8)/8
−(−2)kk(k −5)/8
(−2)kk(k −5)/8
(−2)kk(k −9)/8
(−2)k(k2 −9k + 8)/8
⎤
⎦.
Bearing in mind the approach presented in funmsym(), a similar MATLAB function can
be written as follows, with the kernel funJ() replaced by the new function powJ()
function F=mat power(A,k)
[V,T]=jordan(A); vec=diag(T); v1=[0,diag(T,1)’,0]; v2=find(v1==0);
lam=vec(v2(1:end-1)); m=length(lam);
for i=1:m,
k0=v2(i):v2(i+1)-1; J1=T(k0,k0); F(k0,k0)=powJ(J1,k);
end
F=simplify(V*F*inv(V));
function fJ=powJ(J,k)
%
sub function to compute Jk
i
lam=J(1,1); I=eye(size(J)); H=J-lam*I; fJ=lam^k*I; H1=k*H;
for i=2:length(J)
fJ=fJ+lam^(k+1-i)*I*H1; H1=H1*H*(k+1-i)/i;
end
Example 4.74
Consider the matrix in Example 4.72, compute F = Ak.
A =
⎡
⎢⎢⎣
−7
2
0
−1
1
−4
2
1
2
−1
−6
−1
−1
−1
0
−4
⎤
⎥⎥⎦,
Solution The matrix can be entered ﬁrst. With the MATLAB statements
>> A=[-7,2,0,-1; 1,-4,2,1; 2,-1,-6,-1; -1,-1,0,-4];
syms k, A=sym(A); F=mat_power(A,k) % evaluate directly Ak
the power of it can easily be found and manually simpliﬁed as
F =
⎡
⎢⎢⎣
2(−3)k/9 + (−6)k(k/4 + 7/9 + k2/36)
(−3)k/3 −(−6)k(k/6 + 1/3)
2(−3)k/9 + (−6)k(−k/12 −2/9 + k2/36)
(−3)k/3 + (−6)k(−k/6 + 2/3)
2(−3)k/9 + (−6)k(−k/6 −2/9 −k2/18)
(−3)k/3 + (−6)k(k/3 −1/3)
−4(−3)k/9 + (−6)k(4/9 −k/12 + k2/36)
−2(−3)k/3 + (−6)k(2/3 −k/6)

Linear Algebra Problems
175
2(−3)k/9+(−6)k(k/12−2/9+k2/36)
−(−3)k/9+(−6)k(k/12−1/9+k2/36)
2(−3)k/9−(−6)k(k/4+2/9+k2/36)
−(−3)k/9 + (−6)k(1/9 −k/4 + k2/36)
2(−3)k/9+(−6)k(k/6+7/9−k2/18)
(−6)k(k/6 + 1/9 −k2/18) −(−3)k/9
(−6k)(4/9−k/4+k2/36)−4(−3)k/9
2(−3)k/9 + (−6)k(−k/4+7/9+k2/36)
⎤
⎥⎥⎦
To validate the results, the following statement can be issued, and it can be seen that the
matrix of A12345 using two methods yield the same result
>> simplify(A^12345-subs(F,k,12345))
Exercises
Exercise 4.1 Please generate a diagonal matrix with diagonal elements a1, a2, · · · , a12.
Exercise 4.2 Jordan matrix is a very practical matrix in matrix analysis courses. The
general form of the matrix is described as
J =
⎡
⎢⎢⎢⎣
−α
1
0
· · ·
0
0
−α
1
· · ·
0
...
...
...
...
...
0
0
0
· · ·
−α
⎤
⎥⎥⎥⎦,
e.g., J1 =
⎡
⎢⎢⎢⎢⎣
−5
1
0
0
0
0
−5
1
0
0
0
0
−5
1
0
0
0
0
−5
1
0
0
0
0
−5
⎤
⎥⎥⎥⎥⎦
.
Construct matrix J1 with the MATLAB function diag().
Exercise 4.3 Please enter the two 20×20 matrices without loops. Find their determinants,
traces and characteristic polynomial coeﬃcients.
A =
⎡
⎢⎢⎢⎢⎣
a
b
...
...
a
b
b
a
...
...
b
a
⎤
⎥⎥⎥⎥⎦
,
B =
⎡
⎢⎢⎢⎢⎢⎣
x
a
a
· · ·
a
a
x
a
· · ·
a
a
a
x
· · ·
a
...
...
...
...
a
a
a
a
· · ·
x
⎤
⎥⎥⎥⎥⎥⎦
.
Exercise 4.4 Nilpotent matrix is a special matrix deﬁned as Hn =
⎡
⎢⎢⎢⎢⎢⎣
0
1
0
· · ·
0
0
0
1
· · ·
0
...
...
...
...
...
0
0
0
· · ·
1
0
0
0
· · ·
0
⎤
⎥⎥⎥⎥⎥⎦
.
Verify for any pre-speciﬁed n, Hi
n = 0 is satisﬁed for all i ⩾n.
Exercise 4.5 Can you recognize from the way of display whether a matrix is a numeric
matrix or a symbolic matrix? If A is a numeric matrix and B is a symbolic matrix, can
you predict whether the product C=A*B is a numeric matrix or a symbolic matrix? Verify
this through a simple example.
Exercise 4.6 Compute the determinant of a Vandermonde matrix, and ﬁnd its simpliﬁed
representation.

176
Scientiﬁc Computing with MATLAB®
A=
⎡
⎢⎢⎢⎢⎣
a4
a3
a2
a
1
b4
b3
b2
b
1
c4
c3
c2
c
1
d4
d3
d2
d
1
e4
e3
e2
e
1
⎤
⎥⎥⎥⎥⎦
.
Exercise 4.7 Input matrices A and B in MATLAB, and convert them into symbolic
matrices.
A =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
5
7
6
5
1
6
5
2
3
1
0
0
1
4
6
4
2
0
6
4
4
3
9
6
3
6
6
2
10
7
6
0
0
7
7
7
2
4
4
0
7
7
4
8
6
7
2
1
7
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
,
B =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
3
5
5
0
1
2
3
3
2
5
4
6
2
5
1
2
1
1
3
4
6
3
5
1
5
2
1
2
4
1
0
1
2
0
1
−3
−4
−7
3
7
8
12
1
−10
7
−6
8
1
5
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
Exercise 4.8 Check whether the matrices given in the above exercise are singular or not.
Find the rank, determinant, trace and inverse matrices for them. Check whether the inverse
matrices are correct or not.
Exercise 4.9 Please generate a 15 × 15 matrix, whose elements are 0’s and 1’s, and the
determinant of the matrix is 1.
Exercise 4.10 Please generate a 20 × 20 matrix as follows, and ﬁnd the determinants,
trace and characteristic polynomial. Can you guess what is the possible determinant of an
n × n such a matrix? Please validate your guess for a larger n.
A =
⎡
⎢⎢⎢⎢⎢⎢⎣
x −a
a
a
· · ·
a
a
x −a
a
· · ·
a
a
a
x −a
...
a
...
...
...
...
a
a
a
a
· · ·
x −a
⎤
⎥⎥⎥⎥⎥⎥⎦
.
Exercise 4.11 Find the characteristic polynomials, eigenvalues and eigenvectors for the
matrices A and B in Exercise 4.7.
Exercise 4.12 Perform singular value decompositions, LU factorizations and orthogonal
decompositions to the matrices A and B in Exercise 4.7.
Exercise 4.13 Consider the matrices in Exercise 4.7, please check whether they satisfy
Cayley–Hamilton Theorem. If there are errors, is there any way in to reduce errors?
Exercise 4.14 For arbitrary matrices
A1 =
⎡
⎣
a11
a12
a13
a21
a22
a23
a31
a32
a33
⎤
⎦, A2 =
⎡
⎢⎢⎣
a11
a12
a13
a14
a21
a22
a23
a24
a31
a32
a33
a34
a41
a42
a43
a44
⎤
⎥⎥⎦, A3 =
⎡
⎢⎢⎢⎢⎣
a11
a12
a13
a14
a15
a21
a22
a23
a24
a25
a31
a32
a33
a34
a35
a41
a42
a43
a44
a45
a51
a52
a53
a54
a55
⎤
⎥⎥⎥⎥⎦
verify the Cayley–Hamilton Theorem.

Linear Algebra Problems
177
Exercise 4.15 Please write a low-level MATLAB function to ﬁnd the inverse of a given
square matrix A using the rules in Example 4.33.
Exercise 4.16 Perform LU factorization and SVD decomposition to the following matrices
A =
⎡
⎢⎢⎢⎢⎣
8
0
1
1
6
9
2
9
4
0
1
5
9
9
8
9
9
4
7
9
6
9
8
9
6
⎤
⎥⎥⎥⎥⎦
, B =
⎡
⎢⎢⎣
1
2
2
2
1
1
2
0
1
1
1
0
0
0
2
0
⎤
⎥⎥⎦.
Exercise 4.17 Please check whether the following matrices are positive-deﬁnite matrices.
If they are, please ﬁnd their Cholesky factorizations.
A =
⎡
⎢⎢⎣
1
3
4
8
3
2
7
2
4
7
2
8
8
2
8
6
⎤
⎥⎥⎦, B =
⎡
⎢⎢⎣
12
13
24
26
31
12
27
11
10
9
22
18
42
22
10
16
⎤
⎥⎥⎦.
Exercise 4.18 Compute the eigenvalues, eigenvectors and singular values of the following
matrices.
A =
⎡
⎢⎢⎢⎢⎣
2
7
5
7
7
7
4
9
3
3
3
9
8
3
8
5
9
6
3
6
2
6
8
5
4
⎤
⎥⎥⎥⎥⎦
,
B =
⎡
⎢⎢⎢⎢⎣
703
795
980
137
661
547
957
271
12
284
445
523
252
894
469
695
880
876
199
65
621
173
737
299
988
⎤
⎥⎥⎥⎥⎦
.
Exercise 4.19 Please check whether the following matrices are positive-deﬁnite ones, if so,
please ﬁnd the Cholesky factorized matrices.
A =
⎡
⎢⎢⎢⎢⎣
9
2
1
2
2
2
4
3
3
3
1
3
7
3
4
2
3
3
5
4
2
3
4
4
5
⎤
⎥⎥⎥⎥⎦
,
B =
⎡
⎢⎢⎢⎢⎣
16
17
9
12
12
17
12
12
2
18
9
12
18
7
13
12
2
7
18
12
12
18
13
12
10
⎤
⎥⎥⎥⎥⎦
.
Exercise 4.20 Perform the Jordan transformation for the following matrices, and also ﬁnd
the corresponding transformation matrices.
A =
⎡
⎢⎢⎣
−2
0.5
−0.5
0.5
0
−1.5
0.5
−0.5
2
0.5
−4.5
0.5
2
1
−2
−2
⎤
⎥⎥⎦, B =
⎡
⎢⎢⎣
−2
−1
−2
−2
−1
−2
2
2
0
2
0
3
1
−1
−3
−6
⎤
⎥⎥⎦.
Exercise 4.21 Please ﬁnd the eigenvalues and Jordanian canonical form of the following
matrix. It is known that the original matrix contains complex eigenvalues, please ﬁnd out a
real transformation matrix to complete Jordanian transformation.
A =
⎡
⎢⎢⎢⎢⎢⎢⎣
−5
−2
−4
0
−1
0
1
−2
2
0
−1
−2
2
2
0
3
2
0
1
3
1
0
3
1
−1
−2
−3
−4
−4
1
3
4
3
1
2
−1
⎤
⎥⎥⎥⎥⎥⎥⎦
.

178
Scientiﬁc Computing with MATLAB®
Exercise 4.22 Please consider the matrices in Exercise 4.20. Try to select suitable
transformation matrices to convert the matrices into companion forms.
Exercise 4.23 Find the basic set of solutions of the homogenous equations
(i)
⎧
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎩
6x1 + x2 + 4x3 −7x4 −3x5 = 0
−2x1 −7x2 −8x3 + 6x4
= 0
−4x1 + 5x2 + x3 −6x4 + 8x5 = 0
−34x1 + 36x2 + 9x3 −21x4 + 49x5 = 0
−26x1 −12x2 −27x3 + 27x4 + 17x5 = 0,
(ii) A=
⎡
⎣
−1
2 −2
1
0
0
3
2
2
1
3
1
3
2 −1
⎤
⎦.
Exercise 4.24 Please check whether the following two matrices similar or not. If they are
similar, what is the transformation matrix, to transform A into B?
A =
⎡
⎢⎢⎣
−2
1
−1/2
0
−1/2
−7/2
0
−1/2
0
0
−2
0
1/2
1/2
−1/2
−7/2
⎤
⎥⎥⎦, B =
⎡
⎢⎢⎣
−11/4
−1/4
−3/4
0
3/4
−15/4
−1/4
0
1/2
−1/2
−5/2
0
3/2
−3/2
1/2
−2
⎤
⎥⎥⎦.
Exercise 4.25 Find the numerical and analytical solutions to the following linear algebraic
equations, and then, validate the results.
⎡
⎢⎢⎣
2
−9
3
−2
−1
10
−1
10
5
0
8
−2
−4
−6
3
−5
−6
−6
−8
−4
⎤
⎥⎥⎦X =
⎡
⎢⎢⎣
−1
−4
0
−3
−8
−4
0
3
3
9
−5
3
⎤
⎥⎥⎦.
Exercise 4.26 Check whether the equation has a solution.
⎡
⎢⎢⎣
16
2
3
13
5
11
10
8
9
7
6
12
4
14
15
1
⎤
⎥⎥⎦X =
⎡
⎢⎢⎣
1
3
4
7
⎤
⎥⎥⎦.
Exercise 4.27 Find the analytical solutions to the following linear algebraic equations, and
then, validate the results.
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
2
9
4
12
5
8
6
12
2
8
7
3
3
7
3
0
3
5
7
5
10
3
11
6
6
9
9
1
11
2
1
4
6
8
7
5
−18
1
−9
11
−1
18
26
−27
−1
0
−15
−13
18
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
X =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎣
1
9
5
12
4
12
10
9
0
5
10
18
−20
2
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
Exercise 4.28 For the matrices A and B, please calculate A ⊗B and B ⊗A. Are they
equal to each other?
A =
⎡
⎢⎢⎣
−1
2
2
1
−1
2
1
0
2
1
1
0
1
0
2
0
⎤
⎥⎥⎦,
B =
⎡
⎣
3
0
3
3
2
2
3
1
1
⎤
⎦.

Linear Algebra Problems
179
Exercise 4.29 Find the analytical and numerical solutions to the following Sylvester
equation, and verify the results.
⎡
⎢⎢⎢⎢⎣
3
−6
−4
0
5
1
4
2
−2
4
−6
3
−6
7
3
−13
10
0
−11
0
0
4
0
3
4
⎤
⎥⎥⎥⎥⎦
X + X
⎡
⎣
3
−2
1
−2
−9
2
−2
−1
9
⎤
⎦=
⎡
⎢⎢⎢⎢⎣
−2
1
−1
4
1
2
5
−6
1
6
−4
−4
−6
6
−3
⎤
⎥⎥⎥⎥⎦
.
Exercise 4.30 Find the analytical and numerical solutions to the so-called Stein equation
given below and verify the results.
⎡
⎣
−2
2
1
−1
0
−1
1
−1
2
⎤
⎦X
⎡
⎣
−2
−1
2
1
3
0
3
−2
2
⎤
⎦−X +
⎡
⎣
0
−1
0
−1
1
0
1
−1
−1
⎤
⎦= 0.
Exercise 4.31 Please ﬁnd the numerical and analytical solutions to the discrete Lyapunov
equation AXAT −X + Q = 0, where
A =
⎡
⎢⎢⎣
−2
−1
0
−3
−2
−2
−1
−3
2
2
−3
0
−3
1
1
−3
⎤
⎥⎥⎦, Q =
⎡
⎢⎢⎣
−12
−16
14
−8
−20
−25
11
−20
3
1
−16
1
−4
−10
21
10
⎤
⎥⎥⎦.
Exercise 4.32 Assume that a Riccati equation is given by P A + ATP −P BR−1BTP +
Q = 0, where
A=
⎡
⎢⎢⎣
−27
6
−3
9
2
−6
−2
−6
−5
0
−5
−2
10
3
4
−11
⎤
⎥⎥⎦, B =
⎡
⎢⎢⎣
0
3
16
4
−7
4
9
6
⎤
⎥⎥⎦, Q=
⎡
⎢⎢⎣
6
5
3
4
5
6
3
4
3
3
6
2
4
4
2
6
⎤
⎥⎥⎦, R=

4
1
1
5

.
Solve the equation and verify the result.
Exercise 4.33 Solve the following Diophantine equations and validate the solutions.
(i) A (x) = 1 −0.7x, B (x) = 0.9 −0.6x, C (x) = 2x2 + 1.5x3,
(ii) A (x) = 1 + 0.6x −0.08x2 + 0.152x3 + 0.0591x4 −0.0365x5,
B (x) = 5 −4x −0.25x2 + 0.42x3, C (x) = 1.
Exercise 4.34 Certain functions can be expressed by polynomial functions, i.e., Taylor
series expansions. In these functions, if x is substituted by matrix A, the nonlinear function
can also be expressed for matrices. Write M-functions for the matrix function evaluation
problems and verify the results with funmsym().
(i) cos A = I −1
2!A2 + 1
4!A4 −1
6!A6 + · · · + (−1)n
(2n)! A2n + · · ·
(ii) arc sinA = A +
1
2 · 3A3 +
1 · 3
2 · 4 · 5A5 +
1 · 3 · 5
2 · 4 · 6 · 7A7
+ 1 · 3 · 5 · 7
2 · 4 · 6 · 8 · 9A9 + · · · +
(2n)!
22n(n!)2(2n + 1)A2n+1 + · · ·
(iii) lnA=A−I−1
2(A−I)2+ 1
3(A−I)3 −1
4(A−I)4 + · · · + (−1)n+1
n
(A−I)n + · · · .

180
Scientiﬁc Computing with MATLAB®
Exercise 4.35 For an autonomous linear diﬀerential equation of the form x′(t) = Ax(t),
the analytical solution can be written as x(t) = eAtx(0). Find the analytical solution to the
equation
x′(t) =
⎡
⎢⎢⎣
−3
0
0
1
−1
−1
1
−1
1
0
−2
1
0
0
0
−4
⎤
⎥⎥⎦x(t),
x(0) =
⎡
⎢⎢⎣
−1
0
3
1
⎤
⎥⎥⎦.
Exercise 4.36 Compute the logarithmic matrices, ln A and ln At of the following matrix
A. Please validate the results with the reliable expm() function.
A =
⎡
⎢⎢⎣
−1
−1/2
1/2
−1
−2
−5/2
−1/2
1
1
−3/2
−5/2
−1
3
−1/2
−1/2
−4
⎤
⎥⎥⎦.
Exercise 4.37 Please compute the trigonometric functions sin At, cos At and tan At and
cot At for the following matrices
A1 =
⎡
⎢⎢⎣
−15/4
3/4
−1/4
0
3/4
−15/4
1/4
0
−1/2
1/2
−9/2
0
7/2
−7/2
1/2
−1
⎤
⎥⎥⎦, A2 =
⎡
⎢⎢⎣
−1
0
0
0
0
−1
1
0
2
0
−2
1
−1
0
0
−2
⎤
⎥⎥⎦.
Exercise 4.38 If a block Jordan matrix A is given by
A=
⎡
⎣
A1
A2
A3
⎤
⎦,
where A1 =
⎡
⎣
−3
1
0
0
−3
1
0
0
−3
⎤
⎦,
A2 =
−5
1
0
−5

, A3 =
⎡
⎢⎢⎣
−1
1
0
0
0
−1
1
0
0
0
−1
1
0
0
0
−1
⎤
⎥⎥⎦,
ﬁnd the solutions to eAt, sin

2At + π
3

, eA2tA2 + sin(A3t)At + esin At.
Exercise 4.39 For a given matrix A, ﬁnd matrix functions eAt, sin At, eAt sin

A2eAtt

,
also please ﬁnd Ak.
A =
⎡
⎢⎢⎣
−9/2
0
1/2
−3/2
−1/2
−4
1/2
−1/2
3/2
1
−5/2
3/2
0
−1
−1
−3
⎤
⎥⎥⎦.
Bibliography
[1] Garbow B S, Boyle J M, Dongarra J J, et al. Matrix eigensystem routines — EISPACK
guide extension, Lecture notes in computer sciences, volume 51. New York: Springer-

Linear Algebra Problems
181
Verlag, 1977
[2] Dongarra J J, Bunsh J R, Molor C B. LINPACK user’s guide. Philadelphia: Society of
Industrial and Applied Mathematics, 1979
[3] Heﬀeron J. Linear algebra. Saint Michael’s College, USA: Open source textbook at
http://joshua.smcvt.edu/linearalgebra/, 2006
[4] Meyer C D. Matrix analysis and applied linear algebra. Philadelphia: Society for Indus-
trial and Applied Mathematics. http://www.matrixanalysis.com/DownloadChapters
.html, 2001
[5] Dawkins P. Linear algebra. http://tutorial.math.lamar.edu/pdf/LinAlg/LinAlg
Complete.pdf, 2007
[6] Beezer R A. A ﬁrst course in linear algebra, version 2.99. Washington: Department
of Mathematics and Computer Science University of Puget Sound, 1500 North Warner,
Tacoma, Washington, 98416-1043, http://linear.ups.edu/, 2012
[7] Moler C B, Van Loan C F. Nineteen dubious ways to compute the exponential of a
matrix. SIAM Review, 1979, 20:801–836
[8] Huang L. Linear algebra in systems and control theory. Beijing: Science Press, 1984 (in
Chinese)


Chapter 5
Integral Transforms and Complex-valued
Functions
Integral transform technique can usually be used to map a problem from one domain into
another, such that the new problem may easily be solved in the transformed domain. For
instance, the Laplace transform can be used to map a linear time-invariant (LTI) ordinary
diﬀerential equation (ODE) into an algebraic equation. Therefore, the properties of the
original problem, such as stability, can easily be determined, which lays a foundation of
the classical control theory. In many real applications, Fourier transforms as well as Mellin
transforms and Hankel transforms are all very useful. Therefore, computer-aided solutions
to integral transform problems deserve special attention and are the main topics of this
chapter. This chapter is especially useful, if the readers have yet not learnt similar courses.
The integral transforms can be obtained directly with MATLAB, and it is, for the readers,
as simple as solving calculus problems discussed in Chapter 3.
In Section 5.1, deﬁnition and properties of Laplace transform and the inverse Laplace
transform are summarized. Our focus is on the MATLAB-based solutions to Laplace
transform problems. Numerical Laplace transform and its inverse are also presented for
problems with no analytical solutions. Section 5.2 presents Fourier transform and its inverse
transform, again with a focus on the MATLAB-based solutions. Moreover, sine and cosine
Fourier transforms and discrete Fourier transforms are brieﬂy introduced. Fast Fourier
transform, a numerical tool for Fourier transform is also presented. In Section 5.3, Mellin and
Hankel transforms are introduced, while z transform and inverse z transform are introduced
in Section 5.4 with illustrative examples taken from discrete-time signals and systems. In
Section 5.5, a brief introduction to complex-value function is given, to show Riemman surface
and mapping of complex-value functions. Problems from typical complex-valued function
courses such as singularities, poles and residues are demonstrated together with partial
fraction expansions for rational functions in Section 5.6, where an evaluation method of
closed-path integrals is introduced based on the concepts of residues. Essential singularities
and Laurent series for given functions are also discussed in the section. Section 5.7 devoted to
the presentation of diﬀerence equations, where analytical solutions and recursive numerical
solutions are given.
For readers who wish to check the detailed explanations of complex-valued functions,
Laplace and Fourier transforms, we recommend the open source textbook [1] (Chapters
6-13, 31, 32).
183

184
Scientiﬁc Computing with MATLAB®
5.1
Laplace Transforms and Their Inverses
Integral transform introduced by the French mathematician Pierre-Simon Laplace
(1749–1827) can be used to map the ordinary diﬀerential equations into algebraic equations.
Thus, it established the foundation for many research areas. For instance, the Laplace
transform established the basis for the modeling, analysis and synthesis of control systems.
In this section, the deﬁnition and basic properties of Laplace transform and inverse
Laplace transform are summarized ﬁrst. Then, we focus on the solutions to Laplace
transform problems and their applications using MATLAB. For functions whose analytical
representations of Laplace or inverse Laplace transforms do not exist, numerical solutions
are introduced.
5.1.1
Deﬁnitions and properties
The one-sided Laplace transform of a time function f(t) is deﬁned as
L [f(t)] =
 ∞
0
f(t)e−st dt = F(s),
(5-1-1)
where L [f(t)] is the notation of Laplace transform. The properties of Laplace transform
are summarized below without proofs.
(i) Linear property
L [af(t)±bg(t)]=aL [f(t)]±bL [g(t)] for scalars a and b.
(ii) Time-domain shift
L [f(t −a)] = e−asF(s).
(iii) s-domain property
L [e−atf(t)] = F(s + a).
(iv)
Diﬀerentiation property
L [df(t)/ dt] = sF(s) −f(0+). Generally, the nth
order derivative can be obtained from
L
 dn
dtn f(t)

=snF(s)−sn−1f(0+)−sn−2 df(0+)
dt
−· · ·−dn−1f(0+)
dtn−1
.
(5-1-2)
If the initial values of f(t) and the other derivatives are all zero, (5-1-2) is simpliﬁed as
L
dnf(t)
dtn

= snF(s),
(5-1-3)
and these properties are the crucial formulas to map ordinary diﬀerential equations into
algebraic equations.
(v) Integration property
If zero conditions are assumed, L
 t
0
f(τ) dτ

= F(s)
s
.
Generally, the Laplace transform of the multiple integral of f(t) can be obtained from
L
 t
0
· · ·
 t
0
f(τ) dτ n

= F(s)
sn .
(5-1-4)
(vi) Initial value property
lim
t→0 f(t) = lim
s→∞sF(s).
(vii)
Final value property
If F(s) has no pole with non-negative real part, i.e.,
Re(s) ⩾0, then
lim
t→∞f(t) = lim
s→0 sF(s).
(5-1-5)

Integral Transforms and Complex-valued Functions
185
(viii) Convolution property L [f(t) ∗g(t)] = L [f(t)]L [g(t)], where the convolution
operator ∗is deﬁned as
f(t) ∗g(t) =
 t
0
f(τ)g(t −τ) dτ =
 t
0
f(t −τ)g(τ) dτ.
(5-1-6)
(iv) Other properties
L [tnf(t)] = (−1)n dnF(s)
dsn
,
L
f(t)
tn

=
 ∞
s
· · ·
 ∞
s
F(s) dsn.
(5-1-7)
If the Laplace transform of a signal f(t) is F(s), the inverse Laplace transform of F(s)
is deﬁned as
f(t) = L −1[F(s)] =
1
j2π
 σ+j∞
σ−j∞
F(s)est ds,
(5-1-8)
where σ is greater than all the real part of the poles of function F(s). The deﬁnitions of
poles will be given later.
5.1.2
Computer solution to Laplace transform problems
It is hard if not impossible to write programs with numerical computation-based
languages such as C to solve Laplace transform problems. Computer algebra systems should
be used instead. For instance, the Symbolic Math Toolbox of MATLAB can be used to
solve the problems easily and analytically. The procedures for solving such problems are
summarized as follows:
(i) The symbolic variables such as t should be declared using the syms command. The
time-domain function f(t) should be deﬁned in variable fun.
(ii) Call the laplace() function to solve the problem. Thus, the Laplace transform can
be obtained with the following function call
F = laplace(fun)
% the time variable is given in t
F = laplace(fun,v,u)
% with domain variables v, u speciﬁed
and function simplify() can be used to simplify the obtained symbolic result.
(iii) For complicated problems, the returned results are diﬃcult to read. The function
pretty() can be used to better display the results. Also, the latex() function can be used
to convert the results into LATEX string.
(iv) If the Laplace transform function F(s) is known, it can also be described in the
symbolic expression fun. Then, MATLAB function ilaplace() can be used to calculate the
inverse Laplace transform of the given function. The syntaxes of the function are
f = ilaplace(fun)
% default variable is s
f = ilaplace(fun,u,v)
% specify the domain variables v and u
Example 5.1
For a given time domain function f(t) = t2e−2t sin(t + π), compute its
Laplace transform function F(s).
Solution From the original problem, it can be seen that the time domain variable t should
be declared ﬁrst. With the MATLAB statements, the function f(t) can be speciﬁed. Then,
the laplace() function can be used to derive the Laplace transform of the original function

186
Scientiﬁc Computing with MATLAB®
>> syms t; f=t^2*exp(-2*t)*sin(t+pi); F=laplace(f) % the 3-step procedure
and the result is as follows
F(s) =
2

(s + 2)2 + 1
2 −
2 (2s + 4)2

(s + 2)2 + 1
3 .
Example 5.2
Assume that the original function is given by f(x) = x2e−2x sin(x + π),
compute the Laplace transform, and then, take inverse Laplace transform and see whether
the original function can be recovered.
Solution Similarly, the laplace() function can still be used
>> syms x w; f=x^2*exp(-2*x)*sin(x+pi); F=laplace(f,x,w)
and the result is the same as the one obtained in the previous example, albeit the name of
the variables used are diﬀerent.
If the command f1 = simplify(ilaplace(F)) is used, the result f1(t) = −t2e−2t sin t
can be obtained. Since the equation sin(t+π) = −sin t holds, the original function is actually
restored.
Example 5.3
Compute the inverse Laplace transform for the following complex-valued
function
G(x) =
−17x5 −7x4 + 2x3 + x2 −x + 1
x6 + 11x5 + 48x4 + 106x3 + 125x2 + 75x + 17.
Solution The following statements can be used
>> syms x t;
% declare symbolic variables
G=(-17*x^5-7*x^4+2*x^3+x^2-x+1)... % specify original function
/(x^6+11*x^5+48*x^4+106*x^3+125*x^2+75*x+17);
f=ilaplace(G,x,t)
% evaluate Laplace transform directly
However, the result is far too complicated to display. With the use of vpa(f,7), the
analytical form of the solution can be obtained.
y(t) = −556.2565e−3.2617t + 1.7589e−1.0778t cos 0.6021t
+ 10.9942e−1.0778t sin 0.6021t + 0.2126e−0.5209t
+ 537.2850e−2.5309t cos 0.3998t −698.2462e−2.5309t sin 0.3998t.
Example 5.4 For the function f(t) given in Example 5.1, explore the relationship between
L [d5f(t)/ dt5] and s5L [f(t)].
Solution To solve the problem, the ﬁfth-order derivative to the given function f(t) can be
obtained by function diff(). Then, the Laplace transform can be obtained
>> syms t s; f=t^2*exp(-2*t)*sin(t+pi); % declare variable and function
F=simplify(laplace(diff(f,t,5)))
% evaluate Laplace transform
which yields
F(s) = −2 3000 + 6825s + 6660s2 + 960s4 + 3471s3 + 110s5
(s2 + 4s + 5)3
.
Taking Laplace transform to function f(t), multiplying the result by s5, one may then
subtract the above result to ﬁnd the diﬀerence

Integral Transforms and Complex-valued Functions
187
>> F0=laplace(f); simplify(F-s^5*F0) % simplify the diﬀerence
and the diﬀerence obtained is 6s −48.
It is obvious that the diﬀerence of the two terms is not zero, which seems not to agree
with (5-1-3). This is because the initial conditions here are non-zero. It can easily be found
that f(0) = f ′(0) = f ′′(0) = 0, while f (3)(0) = −6, and f (4)(0) = 48. Hence, the diﬀerence
equals 6s −48.
Example 5.5
Display the diﬀerentiation property of Laplace transform L
d2f(t)
dt2

.
Solution Some of the properties of Laplace transform can be displayed with the use of the
Symbolic Math Toolbox of MATLAB. For this problem, the function f(t) should be declared
ﬁrst, then, the second-order derivative can be obtained with the use of function diff(). The
Laplace transform of the second-order derivative can then be obtained
>> syms t f(t); laplace(diff(f,t,2)) % display the formula
with the display s2F(s) −sf(0) −f ′(0). Also, the formula for the Laplace transform of the
seventh-order derivative can be derived
>> laplace(diff(f,t,7))
and the formula is s7F(s)−s6f(0)−s5f ′(0)−s4f ′′(0)−s3f ′′′(0)−s2f (4)(0)−sf (5)(0)−f (6)(0).
Example 5.6
For the function f(t) = e−5t cos(2t + 1) + 5, compute L [d5f(t)/ dt5].
Solution For the given function f(t), the Laplace and then the inverse Laplace transform
can be performed with the following MATLAB statements
>> syms t; f=exp(-5*t)*cos(2*t+1)+5; % declare symbolic variable and function
F=laplace(diff(f,t,5));
% Laplace transform of the 5th order derivative
F=simplify(F)
% simplify the result
The result obtained is
F(s) = 1475 cos1s −1189 cos1 −24360 sin1 −4282 sin1s
s2 + 10s + 29
.
In fact, a simpliﬁed result can further be obtained if needed. For instance, collecting the
terms in the numerator by using the following statements
>> syms s; F1=collect(F) % collect the terms in the result
The result can be obtained as
F1 = (1475 cos1 −4282 sin1) s −1189 cos1 −24360 sin1
s2 + 10s + 29
.
5.1.3
Numerical solutions of Laplace transforms
The analytic solutions of Laplace transforms of some functions can be obtained with
the direct call of laplace() or ilaplace() functions. However, there exist a great many
functions where analytical solutions of their Laplace and inverse transforms cannot be
obtained. In this case, numerical approaches should be considered.

188
Scientiﬁc Computing with MATLAB®
The INVLAP() function, developed by Juraj Valsa [2, 3], can be used in ﬁnding numerical
solutions of inverse Laplace transforms, with the syntax
[t,y] = INVLAP(f,t0,tf,N,other parameters)
where, the original function can be expressed by f, which is a string containing s. The
arguments (t0, tf) are the interested interval of time t, and N is the number of points of
evaluation. Diﬀerent numbers of N’s can be selected to validate the results. Other parameters
can only be assigned by the experienced users, and it is suggested to use the default
parameters.
Example 5.7
Please solve the inverse Laplace transform problem numerically to the
function given in Example 5.3.
Solution It can be seen from the earlier example that, although the analytical solution does
not exist, a high-precision numerical solution can be found with Symbolic Math Toolbox. For
the same function, the variable x can be substituted by s and can be converted to a string
with char() function. Numerical inverse Laplace transform can be obtained. Compared with
exact method, the maximum relative error is 0.005826%.
>> syms x t; % declare symbolic variables and the function
G=(-17*x^5-7*x^4+2*x^3+x^2-x+1)...
/(x^6+11*x^5+48*x^4+106*x^3+125*x^2+75*x+17);
f=ilaplace(G,x,t); fun=char(subs(G,x,’s’)); % convert to string of s
[t1,y1]=INVLAP(fun,0.01,5,100); tic, y0=subs(f,t,t1); toc
y0=double(y0); err=norm((y1-y0)./y0)
% evaluate the error
If the number of points is increased from 100 to 5000, the elapsed time of INVLAP()
function is about 1.74 seconds, while ilaplace() and subs() functions may need more
than 15 seconds. It can be seen that the numerical algorithm is more eﬀective.
In practical applications, the transfer functions G(s) of a certain complicated system
are known, and the Laplace transform is R(s); the output signal Y (s) = G(s)U(s) can be
obtained. The method can also be used to ﬁnd numerical solutions of the output signal.
Example 5.8
Consider the known Laplace expression
G(s) =
(s0.4 + 0.4s0.2 + 0.5)
√s(s0.2 + 0.02s0.1 + 0.6)0.4(s0.3 + 0.5)0.6 .
Please draw the inverse Laplace transform of G(s) in the interval t ∈(0.01, 1).
Solution Unlike the previous example, function ilaplace() cannot be used in ﬁnding the
analytical solution to the inverse Laplace transform problems, and numerical approach is the
only selection. Select N = 1000, the following statements can be used to ﬁnd numerically
the inverse Laplace transform, and the time domain function is obtained as shown in Figure
5.1. If the number of points N is increased to N = 5000, the same curve can be obtained,
which validated the results.
>> f=’(s^0.4+ 0.4*s^0.2+0.5)/(s^0.2+0.02*s^0.1+0.6)^0.4/(s^0.3+0.5)^0.6’;
[t,y]=INVLAP(f,0.01,1,1000); plot(t,y) % no dot operation in string
It should be noted that, fractional-order polynomial pγ(x) is in fact corresponding to
inﬁnite series, and it is not possible to ﬁnd the analytical solution in inverse Laplace
transforms. Numerical techniques should be used to solve the original problems. The function
is very eﬀective and can be used in practical computations.

Integral Transforms and Complex-valued Functions
189
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
−20
−18
−16
−14
−12
−10
−8
−6
−4
−2
0
2
FIGURE 5.1: Time response obtained from numerical Laplace inverse.
If the analytical solution to the Laplace transform of the input u(t) cannot be obtained,
numerical approaches should also be used as well. In the source code of INVLAP() function,
the loop structure is the major structure in the function, and in each step, an s vector is
created. Based on the vector, numerical integration is used in Laplace transform
L [u(t)] =
 ∞
0
u(t)e−st dt = U(s),
(5-1-9)
where, s is a vector. Since there is the e−st term in the integral, and in practice, if the interval
(0, tf) is large enough, ﬁnite time integrals are used to approximate inﬁnite integrals. Thus,
numerical Laplace transform can be implemented. If the inputs are described by the sample
vectors x0 and u0, the practical input signal u(t) can be approximated with interpolation
methods. Details of signal interpolation will be discussed in Chapter 8.
The dot product of the Laplace input signal and the transfer function G(s) can be
obtained, and it is the Laplace transform of the output signal. In MATLAB 8.0, the
MATLAB function integral() can be used to take numerical integrals with vector s. In
earlier versions, quadv() function can be used instead. Supposed G is the transfer function
of the system, the syntaxes are
[t,y] = num laplace(G,t0,tf,N,f),
% input function f
[t,y] = num laplace(G,t0,tf,N,x0,u0),
% samples of inputs x0, u0
function [t,y]=num_laplace(G,t0,tf,nnt,x0,u0)
FF=strrep(strrep(strrep(G,’*’,’.*’),’/’,’./’),’^’,’.^’);
a=6; ns=20; nd=19; t=linspace(t0,tf,nnt);
if t0==0, t=t(2:end); nnt=nnt-1; end
n=1:ns+1+nd; alfa=a+(n-1)*pi*1j; beta=-exp(a)*(-1).^n; n=1:nd
bdif=fliplr(cumsum(gamma(nd+1)./gamma(nd+2-n)./gamma(n)))./2^nd;
beta(ns+2:ns+1+nd)=beta(ns+2:ns+1+nd).*bdif; beta(1)=beta(1)/2;
for kt=1:nnt
tt=t(kt); s=alfa/tt; bt=beta/tt;
if isnumeric(x0), f=@(x)interp1(x0,u0,x,’spline’).*exp(-s.*x);
else, f=@(x)x0(x).*exp(-s.*x); end
U=integral(f,t0,tf,’ArrayValued’,true);

190
Scientiﬁc Computing with MATLAB®
btF=bt.*eval(FF).*U; y(kt)=sum(real(btF));
end
Example 5.9
Assume that the transfer function of the fractional-order model G(s) is
given in Example 5.8. Please draw the response of the system under the excitation of the
input signal u(t) = e−0.3t sin t2.
Solution
The transfer function of the generalized fractional-order model can be entered
in the same way, and the input function is described by an anonymous function. With the
following statements, the output signal can be obtained as shown in Figure 5.2. The embedded
numerical integration statements are quite consuming, and the following code takes more
than 50 seconds.
>> f=@(t)exp(-0.3*t).*sin(t.^2); % if input function is known
G=’(s^0.4+ 0.4*s^0.2+0.5)/(s^0.2+0.02*s^0.1+0.6)^0.4/(s^0.3+0.5)^0.6’;
tic, [t,y]=num_laplace(G,0,15,400,f); toc, plot(t,y)
0
5
10
15
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
FIGURE 5.2: Output of complex fractional-order system.
Now consider again the input signal. Assume that the mathematical function of the input
signal is unknown, only a set of samples in t ∈(0, 15) interval is known. Interpolation is
used in the input function evaluation, thus, it is quite time consuming, and it may need
about 9 minutes to ﬁnd the numerical solution, even if the number of points in computation
is reduced by half. The curve obtained is virtually the same.
>> x0=0:0.2:15; u0=exp(-0.3*x0).*sin(x0.^2); % if input samples are known
tic, [t,y]=num_laplace(G,0,15,200,x0,u0); toc, plot(t,y)
5.2
Fourier Transforms and Their Inverses
5.2.1
Deﬁnitions and properties
The deﬁnition of Fourier transform is
F[f(t)] =
 ∞
−∞
f(t)e−jωt dt = F(ω).
(5-2-1)

Integral Transforms and Complex-valued Functions
191
If the frequency-domain function F(ω) is known, the inverse Fourier transform can be
obtained from
f(t) = F −1[F(ω)] = 1
2π
 ∞
−∞
F(ω)ejωtdω.
(5-2-2)
The following Fourier transform properties are summarized without proofs.
(i) Linear property
F[af(t)±bg(t)]=aF[f(t)]±bF[g(t)] for scalars a and b.
(ii) Shift property
F[f(t ± a)] = e±jaωF(ω).
(iii) Complex domain shift
F[e±jatf(t)] = F(ω ∓a).
(iv)
Diﬀerentiation property
F[df(t)/ dt] = jωF(ω). Generally, the Fourier
transform of the nth derivative can be evaluated from
F
 dn
dtn f(t)

= (jω)nF[f(t)].
(5-2-3)
(v)
Integration property
F
 t
−∞
f(τ) dτ

=
F(ω)
jω . Generally the Fourier
transform to the nth order integral can be obtained from
F
 t
−∞
· · ·
 t
−∞
f(τ) dτ n

= F[f(t)]
(jω)n .
(5-2-4)
(vi) Scale property
F[f(at)] = 1
aF
ω
a

.
(vii) Convolution property F[f(t) ∗g(t)] = F[f(t)]F[g(t)], where the deﬁnition of
convolution is given in (5-1-6).
5.2.2
Solving Fourier transform problems
Similar to Laplace transform, the variable should be declared ﬁrst, then, the function to
be transformed can be deﬁned in variable fun. With the Fourier transform solver fourier(),
the Fourier transform can be obtained by
F = fourier(fun)
% Fourier transform
F = fourier(fun,v,u)
% transform the function of v into a function of u
Note that the deﬁnition of Fourier transform used in MATLAB is slightly diﬀerent than
the one deﬁned in (5-2-1). In the function fourier(), the Fourier transform is deﬁned as
F[f(x)] =
 ∞
−∞
f(x)e−jωx dx = F1(ω),
(5-2-5)
and it can be seen that the diﬀerence is the factor
√
2π. Throughout this chapter, the
deﬁnition given in (5-2-5) is used.
Also, the deﬁnition of inverse Fourier transform is diﬀerent from the one deﬁned in
(5-2-2). The inverse Fourier transform is deﬁned as
f(x) = F −1[F1(ω)] = 1
2π
 ∞
−∞
F1(ω)ejωxdω,
(5-2-6)

192
Scientiﬁc Computing with MATLAB®
and this deﬁnition will be used throughout this chapter.
The inverse Fourier transform can be obtained using ifourier() function, with the
syntaxes
f = ifourier(fun)
% inverse Fourier transform
f = ifourier(fun,u,v)
% transform the function of u into a function of v
Example 5.10
Compute the Fourier transform for f(t) = 1/(t2 + a2) where a > 0.
Solution The following statements can be used to ﬁnd the Fourier transform.
>> syms t w; syms a positive; f=1/(t^2+a^2); F=fourier(f,t,w)
The result is
F = π(e−aωHeaviside(ω) + eaωHeaviside(−ω))/a,
where, the function Heaviside(ω) is the step function of ω, which is also referred to as
the Heaviside function. If ω ⩾0, Heaviside(ω) is 1, otherwise, it is 0. When ω ⩽0,
Heaviside(−ω) returns 1, otherwise, it is 0. Assuming that ω > 0, then, F can be simpliﬁed
as πe−aω/a. While ω < 0, F can be simpliﬁed as πeaω/a. The result can be summarized as
F[f(t)] = πe−a|ω|/a.
It should be noted that the simplest result obtained above cannot be derived automatically
with MATLAB. The inverse Fourier transform can be obtained using the following statement
>> syms t w; syms a positive; f=pi*exp(-a*abs(w))/a; f1=ifourier(f)
and the result is f1 =
1
a2 + x2 , showing that the original function can be restored.
Example 5.11
Compute the Fourier transform for f(t) = sin2(at)/t with a > 0.
Solution The Fourier transform can be obtained with
>> syms t w; syms a positive; f=sin(a*t)^2/t; fourier(f,t,w)
and the result is
F = jπ(Heaviside(ω −2a) + Heaviside(ω + 2a) −2Heaviside(ω))/2,
and again the result is based on the Heaviside() function. When ω > 2a, the three
Heaviside() are all 1. Thus, F(ω) = 0. If ω ⩽−2a, the three functions are all 0, which
means F(ω) = 0. If 0 < ω < 2a, since the second and third Heaviside() functions are 1,
F(ω) = −jπ/2. When 0 > ω > −2a, F(ω) = jπ/2. The Fourier transform of the original
function can be simpliﬁed manually as
F[f(t)] =
⎧
⎨
⎩
0,
|ω| > 2a
−jπ sign(ω)/2,
|ω| < 2a.
Example 5.12
Now consider a more complicated problem. Assume that the function is
f(t) = e−a|t|/

|t|. Use the MATLAB function fourier() and the direct integration method
to solve the Fourier transform problem.
Solution Now considering ﬁrst the existing function fourier(), the following statements
can be used to solve the Fourier transform problem

Integral Transforms and Complex-valued Functions
193
>> syms t; syms a positive
f=exp(-a*abs(t))/sqrt(abs(t)); F=fourier(f) % fourier() function tried
which gives the string fourier(exp(-a*abs(t))/abs(t)^(1/2),t,w), it means nothing
has been done, and the function call failed to return a solution. Note that the very latest
version of MATLAB yields the analytical result
F(ω) =
√
2π
2

|ω −ja|
+
√
2π
2

|ω + ja|
.
Now, let us try the direct integration method based on the deﬁnition of Fourier transform
(5-2-1). The original integration interval can be divided into two such that
 ∞
−∞
f(t)e−jωt dt =
 0
−∞
f(t)e−jωt dt +
 ∞
0
f(t)e−jωt dt.
Then, the following statements can be tried to solve the Fourier transform problem
>> syms a t positive; syms w real % alternatively try direct integration
f1=exp(a*t)/sqrt(-t); f2=exp(-a*t)/sqrt(t); j=sym(sqrt(-1));
F=int(f1*exp(-j*w*t),-inf,0)+int(f2*exp(-j*w*t),0,inf)
and it is also claimed that the integral failed. This example shows that not all functions
have their corresponding Fourier transforms. For some functions, there exist no Fourier
transforms.
5.2.3
Fourier sinusoidal and cosine transforms
The Fourier sinusoidal transform is deﬁned as
FS [f(t)] =
 ∞
0
f(t) sin ωt dt = Fs(ω).
(5-2-7)
Fourier cosine transform is deﬁned as
FC [f(t)] =
 ∞
0
f(t) cos ωt dt = Fc(ω).
(5-2-8)
Similarly, the inverse Fourier sinusoidal/cosine transforms are deﬁned as
FS
−1[Fs(t)] = 2
π
 ∞
−∞
Fs(ω) sin ωtdω
(5-2-9)
FC
−1[Fc(t)] = 2
π
 ∞
−∞
Fc(ω) cos ωtdω.
(5-2-10)
There are no functions for Fourier sine and cosine transforms provided in MATLAB.
Thus, direct integration can be applied using the Symbolic Math Toolbox. The following
examples are given for computing the Fourier sine and cosine transforms.
Example 5.13 Compute the Fourier cosine transforms to the function f(t) = tne−at, a > 0
for n = 1, 2, · · · , 8.
Solution Since diﬀerent values of n are to be explored, the loop structure of MATLAB can
be used to solve the problem. The following statements can be given to evaluate the Fourier
cosine transforms, and the results are given in Table 5.1.

194
Scientiﬁc Computing with MATLAB®
>> syms t w; syms a positive % declare symbolic variables
for n=1:8
% try Fourier cosine transfor for diﬀerent n’s
f=t^n*exp(-a*t); F=int(f*cos(w*t),t,0,inf); simplify(F)
end
TABLE 5.1: The Fourier cosine transforms for diﬀerent values of n.
n
FC [f(t)]
1∼4
a2 −ω2
(a2 + ω2)2 , −2(−a2 + 3ω2)a
(a2 + ω2)3
, 6(−a2 + 2aω + ω2)(−a2 −2aω + ω2)
(a2 + ω2)4
, 24a(a4 −10a2ω2 + 5ω4)
(a2 + ω2)5
5,6
−120(−a + ω)(a + ω)(a2 −4ωa + ω2)(a2 + 4ωa + ω2)
(a2 + ω2)6
, 720(a6 −21a4ω2 + 35ω4a2 −7ω6)a
(a2 + ω2)7
7
5040
a4 + 4a3ω −6a2ω2 −4aω3 + ω4 a4 −4a3ω −6a2ω2 + 4aω3 + ω4
(a2 + ω2)8
8
40320a −a2 + 3ω2 −a6 + 33a4ω2 −27a2ω4 + 3ω6
(a2 + ω2)9
From the mathematics handbook, the result is actually as follows:
FC
%
tne−at&
= n!

a
a2 + ω2
n+1 [n/2]

m=0
(−1)mC2m+1
n+1
ω
a
2m+1
.
(5-2-11)
Example 5.14
Compute the Fourier cosine transform for
f(t)=

cos t,
0<x<a
0,
otherwise.
Solution It might be diﬃcult to deal with piecewise functions, thus, the direct integration
method can be used to solve the problem. From the piecewise function, it can be seen that the
value of the integrand outside the interval (0, a) is zero, thus, the Fourier cosine transform
can be solved with the following statements
>> syms t w; syms a positive; f=cos(t); % original function
F=simplify(int(f*cos(w*t),t,0,a))
% Fourier cosine transform
and the following piecewise function is obtained
F(ω) =
⎧
⎪
⎨
⎪
⎩
a/2 + sin 2a/4,
ω ∈{−1, 1}
sin [a (ω −1)] /[2 (ω −1)] + sin [a (ω + 1)] /[2 (ω + 1)],
ω ̸∈{−1, 1}
0,
a = π/2 & ω = 3.
5.2.4
Discrete Fourier sine, cosine transforms
Discrete Fourier sine and cosine transforms are also referred to as the ﬁnite Fourier
sine, cosine transforms. The integration interval is changed from t ∈(0, ∞) into a ﬁnite one
t ∈(0, a). Thus, the transforms are deﬁned as
Fs(k) =
 a
0
f(t) sin kπt
a dt,
Fc(k) =
 a
0
f(t) cos kπt
a dt.
(5-2-12)

Integral Transforms and Complex-valued Functions
195
Similarly, the inverse transforms are deﬁned as
f(t) = 2
a
∞

k=1
Fs(k) sin kπt
a ,
(5-2-13)
f(t) = 1
aFc(0) + 2
a
∞

k=1
Fc(k) cos kπt
a .
(5-2-14)
The inverse transforms are no longer integrals, but inﬁnite series. The ﬁnite transforms
can also be obtained with the Symbolic Math Toolbox from deﬁnitions.
Example 5.15
Compute the transform for the piecewise function (a > 0)
f(t) =

t,
t ⩽a/2
a −t,
t > a/2.
Solution
The discrete Fourier sine transforms can be obtained directly as the sum of
integrals of the two intervals from
>> syms t k; syms a positive; f1=t; f2=a-t;
Fs=int(f1*sin(k*pi*t/a),t,0,a/2)+int(f2*sin(k*pi*t/a),t,a/2,a);
F=simplify(Fs) % compute and simplify the result
The simpliﬁed result is then
F = −2a2 sinπk/2 (cos πk/2 −1)
π2k2
.
The simpliﬁed result can further be simpliﬁed manually. Since it is known that
2 sin a cos a = sin 2a, the above result can be simpliﬁed as
FS [f(t)] = a2(2 sin kπ/2 −sin kπ)
k2π2
.
Also, for integer k, sin kπ ≡0. Therefore, the results can be simpliﬁed manually as
FS [f(t)] = 2a2
k2π2 sin kπ
2 .
If integer k is used, and even and odd values of k can be tested individually
>> assume(k,’integer’); k1=2*k; k2=2*k-1; % try odd and even seperately
Fs1=int(f1*sin(k1*pi*t/a),t,0,a/2)+int(f2*sin(k1*pi*t/a),t,a/2,a);
Fs2=int(f1*sin(k2*pi*t/a),t,0,a/2)+int(f2*sin(k2*pi*t/a),t,a/2,a);
F1=simplify(Fs1), F2=simplify(Fs2)
% unify the results
The result is equivalent to the one obtained above.
5.2.5
Fast Fourier transforms
The Fourier transform for discrete sequences xi, i = 1, 2, · · · , N is fundamental to digital
signal processing. The discrete Fourier transform is deﬁned as
X(k) =
N

i=1
xie−2πj(k−1)(i−1)/N,
where 1 ⩽k ⩽N,
(5-2-15)

196
Scientiﬁc Computing with MATLAB®
and its inverse transform is deﬁned as
x(k) = 1
N
N

i=1
X(i)e2πj(k−1)(i−1)/N,
where 1 ⩽k ⩽N.
(5-2-16)
Fast Fourier transform (FFT) technique is the most eﬀective and most practical way in
solving Fourier transform. A built-in function fft() is provided such that f = fft(x). A
useful feature fft() is that the length of the vector does not have to be constrained as 2n.
However, setting length of 2n indeed makes the computation much faster.
For inverse FFT, the function ifft() can be used such that ˆx = ifft(f).
Example 5.16 Given a signal x(t) = 12 sin(2πt+π/4)+5 cos(8πt) and the step-size selected
as h, draw the relationship between the frequency versus FFT magnitude. Observe whether
the original signal can be using inverse FFT.
Solution
The time domain response of the function x(t) can be obtained as shown in
Figure 5.3 (a). It can be seen that it is hard to ﬁnd anything about the properties of the time
domain function.
>> h=0.01; t=0:h:10; x=12*sin(2*pi*t+pi/4)+5*cos(2*pi*4*t); plot(t,x);
For a given sample time h, and the time samples ti, the fundamental frequency is selected
as f0 = 1/(htf), and a frequency vector can be generated as f = [f0, 2f0, 3f0, · · · ]. The
following statements can be used
>> f=t/h/10; X=fft(x); L=1:floor(length(f)/2); stem(f(L),abs(X(L)))
and the relationship between frequency and FFT magnitude is shown in Figure 5.3(b). Here
only half of the data are used to avoid aliasing phenomenon. It can be seen that there are two
peaks in the magnitude plots, and the corresponding frequencies are 1Hz and 4Hz, which are
the same as appeared in the original signal. Thus, FFT techniques can be used to examine
which frequency components are important in the measured discrete signals.
0
2
4
6
8
10
−20
−15
−10
−5
0
5
10
15
(a) time domain plot of original function
0
2
4
6
8
10
0
1000
2000
3000
4000
5000
6000
7000
(b) FFT magnitude versus frequency
FIGURE 5.3: Fast Fourier transform analysis.
Inverse FFT can be evaluated directly by
>> ix=real(ifft(X)); plot(t,x,t,ix,’:’); norm(x-ix) % restore the function

Integral Transforms and Complex-valued Functions
197
and it can be seen that the error in restoring the original function by inverse FFT is as
small as 1.0289×10−13. The restored curve is exactly the same as the one in Figure 5.3 (a).
Two-dimensional and even high-dimensional FFT and their inverses can be solved with
the MATLAB functions fft2(), ifft2(), fftn() and ifftn(), respectively.
5.3
Other Integral Transforms
Apart from the well established Laplace and Fourier transforms, there are other integral
transforms, such as Mellin transform and Hankel transform. The standard Symbolic Math
Toolbox does not provide the functions for these problems. Thus, one can solve the problems
by direct integration. It is recommended that the earlier versions of MATLAB, i.e., the
versions R2008a or earlier, where Maple was used as its symbolic engine, be used to solve
eﬀectively the transformation problems.
5.3.1
Mellin transform
The Mellin transform is deﬁned as
M [f(x)] =
 ∞
0
f(x)xz−1 dx = M(z).
(5-3-1)
Similarly, the inverse Mellin transform is deﬁned as
f(x) = M −1[M(z)] =
1
j2π
 c+j∞
c−j∞
M(z)x−z dz.
(5-3-2)
There is no Mellin transform function provided in the Symbolic Math Toolbox. We can
solve the problem using the direct integration method. Examples are given below to show
the solution process.
Example 5.17
Compute the Mellin transform to f(t) = lnt/(t + a) with a > 0.
Solution By deﬁnition, the following statements can be used to solve the problem
>> syms t z; syms a positive; % try MATLAB R2008a or earlier versions
f=log(t)/(t+a); M=simplify(int(f*t^(z-1),t,0,inf))
and the result can be simpliﬁed as
M [f(t)] = az−1π (ln a sin πz −π cos πz) csc2 πz.
Example 5.18
Compute the Mellin transform to f(t) = 1/(t + a)n, with a > 0. For
diﬀerent integer n, ﬁnd the general form of the transform.
Solution
The following statements can be used to get the Mellin transform problem for
n = 1, 2, · · · , 8,
>> syms t z real; syms a positive % try MATLAB R2008a or earlier versions
for i=1:8, f=1/(t+a)^i; int(f*t^(z-1),t,0,inf), end

198
Scientiﬁc Computing with MATLAB®
which gives respectively
az−1π csc πz,
−a−2+zπ(z −1) csc πz,
1/2a−3+zπ(−2 + z)(z −1) csc πz,
−1/6az−4π(z −1)(−2 + z)(−3 + z) csc πz,
1/24a−5+zπ(z −4)(−3 + z)(−2 + z)(z −1) csc πz,
−1/120a−6+zπ(−5 + z)(z −4)(−3 + z)(−2 + z)(z −1) csc πz,
1/720a−7+zπ(−6 + z)(−5 + z)(z −4)(−3 + z)(−2 + z)(z −1) csc πz,
−1/5040a−8+zπ(−7 + z)(−6 + z)(−5 + z)(z −4)(−3 + z)(−2 + z)(z −1) csc πz.
Thus, by inspection, it can be concluded that the Mellin transform is generally given by
M

1
(t + a)n

= (−1)k−1π
(n −1)! az−n
n−1

i=1
(z −i) csc πz.
As in other transforms, there are a great many functions whose Mellin transforms have no
analytical solutions. In this case, numerical Mellin transforms can be introduced. Numerical
integrations can be used in solving numerical Mellin transform problems. A MATLAB func-
tion mellin trans() is written, with the syntax F = mellin trans(f,z,property pairs),
where property pairs are the same as the ones used in integral() function.
function F=mellin_trans(f,z,varargin)
f1=@(x)f(x).*x.^(z-1); % declare integrand for Mellin transform
F=integral(f1,0,Inf,’ArrayValued’,true,varargin{:});
Example 5.19 For a given function f(x) = sin(3x0.8)/(x + 2)1.5, please solve numerically
to ﬁnd its Mellin transform.
Solution It is obvious that there is no analytical solution to the Mellin transform problem
for the given function. Numerical Mellin transform is the only choice. The original function
can be expressed by an anonymous function ﬁrst, then, numerical Mellin transform can be
taken, and the plot is obtained as shown in Figure 5.4.
>> f=@(x)sin(3*x.^0.8)./(x+2).^1.5; % specify original function
z=0:0.05:1; F=mellin_trans(f,z); plot(z,F)
5.3.2
Hankel transform solutions
Hankel transform is another frequently used integral transform. The νth order Hankel
transform is deﬁned as
H [f(t)] =
 ∞
0
tf(t)Jν(ωt) dt = Hν(ω),
(5-3-3)
where Jν(z) is the Bessel function of order ν, which can be evaluated under MATLAB with
the statement J = besslej(ν,z). The inverse Hankel transform of order ν is deﬁned as
H −1[H(ω)] =
 ∞
0
ωHν(ω)Jν(ωt)dω.
(5-3-4)

Integral Transforms and Complex-valued Functions
199
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
FIGURE 5.4: Numerical Mellin transform.
Example 5.20 Compute the zeroth-order Hankel transform to f(t) = e−a2t2/2, with a > 0.
Solution With the existing MATLAB functions, the following statements can be used in
ﬁnding the zeroth-order Hankel transform
>> syms t w a positive; f=exp(-a^2*t^2/2);
F=int(f*t*besselj(0,w*t),t,0,inf); F=simplify(F) % Hankel transform
f1=int(w*F*besselj(0,w*t),w,0,inf) %
inverse Hankel transform
and the result obtained is F = e−w2/(2a2)/a2. The inverse Hankel transform to the result
is also performed, and the original function is restored. If the order of Bessel function is
changed from 0 to 1, the result contains Bessel function, and the inverse cannot be obtained.
Currently, the above approach can only be used to a very limited category of functions,
and to very low orders of Bessel function, such as ν = 0, which means that most functions
have no analytical solutions in Hankel transforms. Thus, numerical Hankel transform should
be considered instead.
A MATLAB function can be written to implement Hankel transforms directly, with the
syntax of H = hankel trans(f,w,ν,property pairs), where property pairs are the same as
the ones used in integral() function.
function H=hankel_trans(f,w,nu,varargin)
F=@(t)t.*f(t).*besselj(nu,w*t); % specify integrand of Hankel transform
H=integral(F,0,Inf,’ArrayValued’,true); % evaluate numerical integral
Example 5.21
Consider the function in the previous example, with a = 2. Please draw
numerical Hankel transforms for diﬀerent orders of Bessel functions.
Solution The theoretical curve obtained earlier can be drawn directly, and superimposed
on it, the Hankel transforms with diﬀerent orders of Bessel functions can be drawn, as
shown in Figure 5.5. It can be seen that the 0th order transform are almost identical. Also,
the transforms of diﬀerent orders can be obtained easily and quickly. It can also be seen
that the decay of high order Hankel transforms are very slow, and the current curve is not
adequate to evaluate the inverse Hankel transform numerically. In order to evaluate inverse
transforms, larger ranges of ω should be obtained. If the function F(ω) is known, similar
MATLAB statements can be used to evaluate numerically the inverse Hankel transforms.
>> F1=subs(F,a,2); ezplot(F1,[0,10]); % theoretic results

200
Scientiﬁc Computing with MATLAB®
a=2; f=@(t)exp(-a^2*t.^2/2); w=0:0.4:10;
for i=0:4, H=hankel_trans(f,w,i,’ArrayValued’,true); line(w,H); end
0
1
2
3
4
5
6
7
8
9
10
0
0.05
0.1
0.15
0.2
0.25
ν = 0, and theoretical
ν = 1
ν = 2
FIGURE 5.5: Numerical Hankel transform with diﬀerent Bessel orders.
5.4
z Transforms and Their Inverses
5.4.1
Deﬁnitions and properties of z transforms and inverses
The z transform of a discrete sequence f(k), k = 1, 2, · · · is deﬁned as
Z [f(k)] =
∞

k=0
f(k)z−k = F(z).
(5-4-1)
Similar to the presentation of Laplace and Fourier transforms, the properties of z
transforms are summarized below without proofs.
(i) Linear property
Z [af(k)±bg(k)]=aZ [f(k)]±bZ [g(k)] for any scalars a and b.
(ii)
Time domain forward translation property
For nonzero initial value
problems, z transform can be calculated with
Z [f(k + n)] = znF(z) −
n−1

i=0
zn−if(i).
(5-4-2)
Especially, for zero initial condition problems, Z [f(k + n)] = znF(z).
(iii) Backward translation property
Z [f(k −n)] = z−nF(z).
(iv) z-domain proportional property
Z [r−kf(k)] = F(rz).
(v) Frequency-domain derivative property
Z [kf(k)]=−z dF(z)
dz
.
(vi) Frequency-domain integral property
Z
f(k)
k

=
 ∞
z
F(ω)
ω
dω.

Integral Transforms and Complex-valued Functions
201
(vii) Initial value property
lim
k→0 f(k) = lim
z→∞F(z).
(viii) Final value property
If F(z) has no poles outside of the unit circle, the ﬁnal
value satisﬁes
lim
k→∞f(k) = lim
z→1(z −1)F(z).
(5-4-3)
(ix) Convolution property Z [f(k) ∗g(k)] = Z [f(k)]Z [g(k)] where the operator ∗
for discrete signals is deﬁned as
f(k) ∗g(k) =
∞

l=0
f(k)g(k −l).
(5-4-4)
For a z transform function F(z), the inverse z transform is deﬁned as
f(k) = Z −1[f(k)] =
1
j2π
0
F(z)zk−1 dz.
(5-4-5)
5.4.2
Computations of z transform
Z transform and its inverse can be obtained directly with the functions ztrans() and
iztrans() provided in the Symbolic Math Toolbox, with the syntaxes
F = ztrans(fun), F = ztrans(fun,k,z)
% z transform
F = iztrans(fun), F = iztrans(fun,z,k)
% inverse z transform
and if there is only one variable in fun, the arguments k and z can be omitted.
Example 5.22
Compute the z transform for f(kT ) = akT −2 + (akT + 2)e−akT .
Solution The z transform can be obtained directly with the statements
>> syms a T k
% declare the symbolic variables
f=a*k*T-2+(a*k*T+2)*exp(-a*k*T); % deﬁne the discrete function
F=ztrans(f)
% compute the z transform
and the result obtained is
Z [f(kT )] =
aT z
(z −1)2 −2
z
z −1 +
aT ze−aT
(z −e−aT )2 + 2 zeaT 
z
e−aT −1
−1
.
Example 5.23
Consider the function F(z) =
q
(z−1 −p)m , p ̸= 0. Find the inverse z
transforms for diﬀerent values of m, and then, try to summarize the general formula for the
transform.
Solution Let us try to solve the problem for m = 1, 2, · · · , 8. The loop structure should be
used, and the inverse z transforms can be obtained by
>> syms p q z; assume(p~=0) % specify p ̸= 0 and try diﬀerent m’s
for m=1:8, disp(simplify(iztrans(q/(1/z-p)^m))), end
It can be seen from the displayed results that in some terms under the new versions, the
results contain nchoosek(n,k) function, which is the combination number, meaning that
Ck
n = n!/[k!(n −k)!].

202
Scientiﬁc Computing with MATLAB®
The results can be simpliﬁed manually as
−q/p(1/p)n,
q/p2(1 + n)(1/p)n,
−1/2q(1/p)n(1 + n)(2 + n)/p3,
1/6q(1/p)n(3 + n)(2 + n)(1 + n)/p4,
−1/24q(1/p)n(4 + n)(3 + n)(2 + n)(1 + n)/p5,
1/120q(1/p)n(5 + n)(4 + n)(3 + n)(2 + n)(1 + n)/p6,
−1/720q(1/p)n(6 + n)(5 + n)(4 + n)(3 + n)(2 + n)(1 + n)/p7,
1/5040q(1/p)n(7 + n)(6 + n)(5 + n)(4 + n)(3 + n)(2 + n)(1 + n)/p8.
It is summarized by inspection that the general form of the z transform is
Z −1

q
(z−1 −p)m

=
(−1)mq
(m −1)! pn+m
m−1

i=1
(n + i).
5.4.3
Bilateral z transforms
The previously deﬁned z transforms are for the sum n ⩾0, and also known as one
sided z transform. If the range of n is extended to the entire set of integers, the bilateral z
transforms can be deﬁned
Z [f(k)] =
∞

k=−∞
f(k)z−k = F(z).
(5-4-6)
There are no existing bilateral z transform facilities in MATLAB. Unfortunately,
sometimes, the sum over (−∞, ∞) interval is not supported by the symsum() function.
The original sum can be divided into the sums of two ﬁelds. From the deﬁnitions, the
expression of bilateral z transform can be evaluated with
F = symsum(f*z^(-k),k,0,inf)+ symsum(f*z^(-k),k,-inf,−1)
Example 5.24
Please ﬁnd the bilateral z transform of the f(n) [4]
f(n) =

2n,
n ⩾0
−3n,
n < 0.
Solution From the deﬁnition of bilateral z transform, it can be seen that
Z [f(k)] =
∞

k=−∞
f(k)z−k =
∞

k=0
2kz−k +
−1

−∞
−3kz−k.
The following statements can be issued under old versions of MATLAB
>> syms z k; F=symsum(2^k*z^(-k),k,0,inf)+symsum(-3^k*z^(-k),k,-inf,-1)
and the bilateral z transform can be written as
F =
z
z −2 +
z
z −3.

Integral Transforms and Complex-valued Functions
203
5.4.4
Numerical inverse z transform of rational functions
There are many functions whose inverse z transforms are not analytically obtainable
with iztrans(). Even though for rational functions, the inverse z transforms cannot be
found. Suppose the inverse z transform of a function can be written as
F

z−1
= z−d b0 + b1z−1 + b2z−2 + · · · + bm−1z−(m−1) + bmz−m
a0 + a1z−1 + a2z−2 + · · · + an−1z−(n−1) + anz−n ,
(5-4-7)
and it can be regarded as the power series expansion, of the z−k term, with
F

z−1
= f0 + f1z−1 + f2z−2 + · · · =
∞

k=0
fkz−k,
(5-4-8)
and it happens to be the deﬁnition of z transforms. Long division technique can be
used to expand F

z−1
, and a long division function is implemented with the syntax
y = inv z(num,den,d,N), where, d is the pure delay step, and the coeﬃcient vectors
num = [b0,b1,b2,· · · ,bm], den = [a0,a1,a2,· · · ,an], and the number of calculation points
is N = 10. The inverse z transform sequence can be returned in vector y.
function y=inv_z(num,den,varargin)
[d,N]=default_pars({0,10},varargin{:}); num=zeros(1,N);
for i=1:N-d, y(d+i)=num(1)/den(1);
if length(num)>1, ii=2:length(den);
if length(den)>length(num); num(length(den))=0; end
num(ii)=num(ii)-y(end)*den(ii); num(1)=[];
end, end
Example 5.25
Please ﬁnd numerically the inverse z transform of
G(z) =
z2 + 0.4
z5−4.1z4+6.71z3−5.481z2+2.2356z−0.3645.
Solution Both the numerator and denominator of G(z) can be multiplied together by z−5,
and the following rational expression can be obtained
F

z−1
= z−3
1 + 0.4z−2
1 −4.1z−1 + 6.71z−2 −5.481z−3 + 2.2356z−4 −0.3645z−5.
The following statements can be used to evaluate numerically the inverse z transform,
and the sequence obtained is shown in Figure 5.6.
>> num=[1 0 0.4]; den=[1 -4.1 6.71 -5.481 2.2356 -0.3645];
N=50; y=inv_z(num,den,3,N); t=0:(N-1); stem(t,y)
5.5
Essentials of Complex-valued Functions
By name, complex-valued functions are those whose independent variables are complex
numbers. Since the complex data type is the fundamental data type of MATLAB, the
previous MATLAB functions in calculus and linear algebra can be used directly in complex-
valued function related problems. In this section, the graphics facilities and mapping display
of complex-valued functions are introduced.

204
Scientiﬁc Computing with MATLAB®
0
5
10
15
20
25
30
35
40
45
50
0
50
100
150
200
250
300
350
400
FIGURE 5.6: Numerical solution of inverse z transform.
5.5.1
Complex matrices and their manipulations
It has been pointed out earlier than complex matrices can be used directly in MATLAB
in exactly the same way as real matrices. Assume that a complex matrix Z is given, it can
be manipulated by the following functions:
(i) Compute complex conjugate with Z1 = conj(Z).
(ii) Extract real and imaginary parts with R = real(Z), I = imag(Z).
(iii)
Get magnitude and phase with A = abs(Z), P = angle(Z), while the unit in
phase is radians.
Example 5.26
Reconsider the Jordan canonical form in Example 4.41. Since the matrix
has complex eigenvalues, the transformation matrix should be modiﬁed manually. The
following command can also be used to update the transformation matrix, and the same
real Jordan matrix can be obtained.
>> A=[1,0,4,0; 0,-3,0,0; -2,2,-3,0; 0,0,0,-2]; [V,D]=eig(sym(A));
V=real(V)+imag(V), D1=inv(V)*A*V % convert to Jordan real matrix
5.5.2
Mapping of complex-valued functions
If the independent variable z of function f(z) is complex, the function is referred to as a
complex-valued function. Since complex matrix is the fundamental data type in MATLAB,
most of the algorithms in MATLAB do not speciﬁcally distinguish whether they are dealing
with real or complex matrices. Therefore, most of the existing functions can be used in
the computation of complex matrices directly. For instance, the analytical and numerical
computation functions in calculus apply to complex functions directly.
Example 5.27
For complex-valued function f(z), please evaluate f (3)(−j
√
5).
f(z) = z2 + 3z + 4
(z −1)5
.
Solution
The following commands can be used directly, and the result obtained is d3 =
0.8150 −j0.6646.
>> syms z; f=(z^2+3*z+4)/(z-1)^5; % describe the original symbolic function
f3=diff(f,z,3); d3=simplify(subs(f3,z,-1i*sqrt(5))) % ﬁnd derivative

Integral Transforms and Complex-valued Functions
205
Mapping is a very important kind of transformation in complex-valued functions. The
so-called mapping is to perform variable substitution in complex-valued functions, i.e., by
changing z into w, where z = g(w). The commonly used mapping are translation mapping
z = w + γ, inverse mapping z = 1/w and bilinear mapping z = (aw + b)/(cw + d), where
γ is a ﬁxed complex number, a, b, c, d are ﬁxed real numbers. The translation mapping
translates the origin of the function to point γ; inverse mapping converts a point inside a
unit circle to one outside the circle; bilinear transform implements the mapping between
lines and circles in diﬀerent planes. The simplest way in implementing diﬀerent kinds of
mapping is using subs() function.
Example 5.28 Consider again the complex function f(z) = (z2+3z+4)/(z−1)5 in Example
5.27. Perform bilinear transformation z = (s −1)/(s + 1).
Solution The expected bilinear mapping can be obtained directly with function subs(), and
the result should be simpliﬁed.
>> syms z s; f=(z^2+3*z+4)/(z-1)^5; F=simplify(subs(f,z,(s-1)/(s+1)))
The mapped function is F(s) = −1/[16(s + 1)3(4s2 + 3s + 1)].
Example 5.29
This example shows how bilinear transformation s = (z −1)/(z + 1) can
be used to map points inside a unit circle into points on the left-hand-side points in a plane.
A series of points inside a unit circle can be generated and stored in complex matrix z, as
shown in Figure 5.7(a).
>> [x,y]=meshgrid(-1:0.1:1); ii=find(x.^2+y.^2<=1); x=x(ii); y=y(ii);
z=x+sqrt(-1)*y; plot(z,’+’); hold on; ezplot(’x^2+y^2=1’)
With bilinear mapping of s = (z −1)/(z + 1), the matrix z can be mapped into complex
matrix s, as displayed in Figure 5.7(b). It can be seen that the points in the unit circle are
converted to the ones in the left-hand-side plane.
>> s=(z-1)./(z+1); plot(s,’x’) % mapping points in s plane
−1.5
−1
−0.5
0
0.5
1
1.5
−1.5
−1
−0.5
0
0.5
1
1.5
(a) points inside a unit circle
−20
−15
−10
−5
0
−10
−8
−6
−4
−2
0
2
4
6
8
10
(b) mapped points in s domain
FIGURE 5.7: Mapping from z domain into s domain.

206
Scientiﬁc Computing with MATLAB®
5.5.3
Riemann surfaces
The mapping graphics of complex-valued functions are diﬀerent from the 3D graphics
discussed in Chapter 2. One should generate polar grid with the cplxgrid() function, and
the Riemann surface can be shown with cplxmap() function, with the syntaxes
z = cplxgrid(n)
% generates polar grids
cplxmap(z,f)
% draw the 3D complex mapping Riemann surface
Example 5.30
Draw the Riemann surface of the function f(z) = z3 sin z2.
Solution The Riemann surface of the given function can be displayed with the following
statements, as shown in Figure 5.8.
>> z=cplxgrid(50); f=z.^3.*sin(z.^2); cplxmap(z,f) % draw Riemann surface
−1
−0.5
0
0.5
1
−1
−0.5
0
0.5
1
−2
−1
0
1
2
FIGURE 5.8: Riemann surface of a complex-valued function.
For a complex variable z, the Riemann surfaces of a multivalued function may have
many branches. For instance, function f(z) =
n√z has n branches. MATLAB provides a
function cplxroot(n) to draw directly all the branches of Riemann surfaces of the root
mapping of
n√z.
Example 5.31
Please draw the Riemann surfaces of
3√z and
4√z.
Solution
The Riemann surfaces of
3√z and
4√z can be directly drawn with function
cplxroot(), and the surfaces are shown respectively in Figures 5.9(a) and (b).
>> subplot(121), cplxroot(3), subplot(122), cplxroot(4) % surfaces of roots
The limitations of cplxroot() function are that, it can only be used to draw Riemann
surfaces of root functions, and cannot be used to draw other multi-valued functions. The
existing function cplxmap() can be extended and saved as a new function cplxmap1().
Then, delete the mesh() and hold statement. Then, it can be used to draw Riemann surfaces
of multi-valued complex functions.
Example 5.32
Use the modiﬁed function to draw the Riemann surfaces of
3√z.
Solution To redraw the Riemann surfaces of function
3√z, it is known that if f1(z) is a

Integral Transforms and Complex-valued Functions
207
−1
−0.5
0
0.5
1
−1
−0.5
0
0.5
1
−1
−0.5
0
0.5
1
(a) cubic root
−1
−0.5
0
0.5
1
−1
−0.5
0
0.5
1
−1
−0.5
0
0.5
1
(b) the fourth root
FIGURE 5.9: Riemann surfaces of
n√z.
branch of f(z) =
3√z, then, the other two branches can be obtained by f1(z)e−2jπ/3 and
f1(z)e−4jπ/3. The following statements can be used to draw directly the Riemann surfaces
of
3√z, and the results are exactly the same as the ones in Figure 5.9(a).
>> z=cplxgrid(30); f1=z.^(1/3); a=exp(-2i*pi/3); cplxmap1(z,f1)
hold on; cplxmap1(z,a*f1); cplxmap1(z,a^2*f1); zlim([-1 1])
5.6
Solving Complex-valued Function Problems
In this section, commonly encountered problems in complex-valued functions will be
manipulated. The concept of poles and residues are ﬁrst studied. Partial fraction expansion
and Laurent series expansions are discussed, and ﬁnally the closed-path integral of complex-
valued function is studied.
5.6.1
Concept and computation of poles and residues
Before introducing the ideas of poles and residues, the concept of analytic complex
functions is introduced. The complex function f(z) is said to be analytic, if it is holomorphic,
and the derivatives are ﬁnite, at all the points within the complex region. The points which
make the function f(z) not analytic are referred to as the singularities. The poles of functions
are special singularities which makes the polynomial denominator of f(z) equal zero.
Assume that z = a is a pole of the function f(z), and there exists the smallest positive
integer m such that the new function (z −a)mf(z) is analytic at point z = a, then,
point z = a is referred to as a pole of multiplicity m. The poles can be obtained with
[p,m] = poles(f), and if there is more than one pole, they are returned in the column
vector p, together with their multiplicity vector m. The poles within the interested interval
(a, b) can be obtained with [p,m] = poles(f,a,b).
If z = a is a single pole, then, the residue is deﬁned as
Res

f(z), z = a

= lim
z→a(z −a)f(z).
(5-6-1)

208
Scientiﬁc Computing with MATLAB®
If z = a is a pole of multiplicity m, the residue is deﬁned as
Res

f(z), z = a

= lim
z→a
1
(m −1)!
dm−1
dzm−1

f(z)(z −a)m
.
(5-6-2)
Thus, the evaluation of residues can be made very easy. The following statements can
be used in evaluating the residues to diﬀerent kinds of poles.
c = limit(F*(z −a),z,a)
% single pole
c = limit(diff(F*(z−a)^m,z,m−1)/factorial(m−1),z,a)
% multiple poles
It can be seen that the ﬁrst statement is a special case of statement 2, when m = 1.
Thus, the second statement is used globally in evaluating the residues.
Example 5.33
Compute the residues of the function
f(z) =
1
z3(z −1) sin

z + π
3

e−2z.
Solution It can be seen from the original function that z = 0 is a pole of multiplicity 3,
while z = 1 is a single pole. Therefore, the following MATLAB statements can be used to
evaluate the residues at the two poles
>> syms z; f=sin(z+pi/3)*exp(-2*z)/(z^3*(z-1)); [p,m]=poles(f)
for i=1:length(p) % ﬁnd residues for all the poles
F=limit(diff(f*(z-p(i))^m(i),z,m(i)-1)/factorial(m(i)-1),z,p(i))
end
and the residues are respectively 1
2 −
√
3
4
for z = 0, and e−2 sin

1 + π
3

for z = 1.
An algorithm is designed below to ﬁnd the poles and residues of a given function
Require: Symbolic expression f(x), optional interval (a, b)
Find all the poles p and their multiplicities m
for i = 1 To m do
Compute and store the residues computed from (3-4-6)
end for.
An automatic pole and residue evaluation function residuesym(), with the syntax
[r,p,m] = residuesym(f,a,b), can be written based on the above algorithm, where a,
and b can be omitted. The listing of function is
function [r,p,m]=residuesym(f,a,b), z=symvar(f);
if nargin==1, [p,m]=poles(f); else, [p,m]=poles(f,a,b); end
for k=1:length(p) % compute residues for all the poles
r(k)=limit(diff(f*(z-p(k))^m(k),z,m(k)-1)/factorial(m(k)-1),z,p(k));
end
Example 5.34
Compute the residue of the function f(z) = sin z −z
z6
.
Solution
It can be found by the following statements that the point z = 0 is a pole of
multiplicity 3, and the residue is r = 1/120.

Integral Transforms and Complex-valued Functions
209
>> syms z; f=(sin(z)-z)/z^6; [r,p,m]=residuesym(f)
It seems that the multiplicity of the pole is 6 rather than 3. Consider the Taylor series
expansion to the sin z function. It can be seen that
f(z) = (z−z3/6+z5/120−z7/5040+· · ·)−z
z6
= −1/6+z3/120−z5/5040+· · ·
z3
.
Therefore, the multiplicity of the pole is indeed 3 rather than 6.
In fact, in practical situations, we can try diﬀerent values of k in a loop, from k = 1, to
ﬁnd the smallest k, such that
lim
z→a
dk−1
dzk−1

(z −a)k f(z)

< ∞,
then, the value of k can be regarded as the multiplicity of the pole. With function poles(),
the multiplicity can also be measured accurately for this example.
Also, it is interesting to note that for this example, even if k is selected as a very large
number, the value of the limit is still 1/120. Therefore, in practical applications, even though
the multiplicity cannot be assessed correctly, a large number can be selected to ﬁnd the correct
residue.
>> syms z; f=(sin(z)-z)/z^6; R2=limit(diff(f*z^2,z,1)/factorial(1),z,0)
R3=limit(diff(f*z^3,z,2)/factorial(2),z,0),
R20=limit(diff(f*z^20,z,19)/factorial(19),z,0)
Example 5.35
Compute the residues of the function f(z) =
1
z sin z .
Solution Unfortunately the poles() function failed to ﬁnd the poles and their multiplici-
ties. It can be seen that there are inﬁnite numbers of poles. At z = 0, the multiplicity is 2,
while at z = ±kπ, with integer k = 1, 2, · · · , the multiplicity is 1. For the pole at z = 0, the
residue can then be found from
>> syms z; f=1/(z*sin(z)); c0=limit(diff(f*z^2,z,1),z,0) % residue at 0
and the residue for z = 0 is 0.
Now for the poles z = ±kπ, some integers can be tried, for instance, k = 1, 2, 3, 4, and
the residues for these poles can be obtained such that
>> k=[-4 4 -3 3 -2 2 -1 1]; c=[]; % try diﬀerent integers to ﬁnd clues
for kk=k; c=[c,limit(f*(z-kk*pi),z,kk*pi)]; end; c
and it can be seen that for the vector k = [−4, 4, −3, 3, −2, 2, −1, 1], the residues evaluated
are c =

−1
4π, 1
4π , 1
3π, −1
3π , −1
2π, 1
2π, 1
π , −1
π

. It can then be concluded that Res[f(z), z =
kπ] = (−1)k 1
kπ . In fact, with recent versions of MATLAB, the same results can be obtained
with the following statements
>> syms k; assume(k,’integer’), assumeAlso(k~=0); % k is a nonzero integer
R=simplify(limit(f*(z-k*pi),z,k*pi))
% evaluate residue directly

210
Scientiﬁc Computing with MATLAB®
5.6.2
Partial fraction expansion for rational functions
Consider the rational function
G(z) = B(z)
A(z) =
b1zm + b2zm−1 + · · · + bmz + bm+1
zn + a1zn−1 + a2zn−2 + · · · + an−1z + an
,
(5-6-3)
where ai and bi are all constants. The concept of coprimeness of rational functions is very
important. The two polynomials A(z) and B(z) are coprime if there does not exist any
common divisor containing z. The greatest common divisor of two polynomials can be very
diﬃcult to ﬁnd manually. However, with help of the gcd() function provided in the Symbolic
Math Toolbox of MATLAB, the greatest common divisor C can easily be found with the
syntax C = gcd(A,B), where A and B are the two polynomials. If C is a polynomial, then,
the two polynomials are not coprime. The two polynomials can then be simpliﬁed to A/C
and B/C, respectively.
Example 5.36
Check whether the two polynomials A(z), B(z) are coprime or not
A(z) = z4 + 7z3 + 13z2 + 19z + 20,
B(z) = z7 + 16z6 + 103z5 + 346z4 + 655z3 + 700z2 + 393z + 90.
Solution The greatest common divisor can be obtained with the gcd() function
>> syms z; A=z^4+7*z^3+13*z^2+19*z+20;
B=z^7+16*z^6+103*z^5+346*z^4+655*z^3+700*z^2+393*z+90;
d=gcd(A,B)
%
ﬁnd the greatest common divisor
and it can be seen that the greatest common divisor is d(z) = (z + 5). Thus, the two
polynomials are not coprime. The two polynomials can easily be reduced with
>> N=simplify(A/d), D=simplify(B/d), F=N/D % ﬁnd coprime rational function
then, A(z)/d(z) = z3 + 2z2 + 3z + 4, and B(z)/d(z) = (z + 2)(z + 3)2(z + 1)3. Thus, the
original rational function can be simpliﬁed as
F =
z3 + 2z2 + 3z + 4
(z + 2)(z + 3)2(z + 1)3 .
If the polynomials A(z) and B(z) are coprime, and the roots −pi, i = 1, 2, · · · , n of the
polynomial equation A(z) = 0 are all distinct, the original rational function G(z) can be
expanded into the following form
G(z) =
r1
z + p1
+
r2
z + p2
+ · · · +
rn
z + pn
,
(5-6-4)
and the expansion is referred to as the partial fraction expansion. In the expression, ri are
the residues, denoted as Res[G(−pi)], which can be obtained from the limit formula such
that
ri = Res[G(z), z = −pi] =
lim
z→−pi G(z)(z + pi).
(5-6-5)
If the term (z + pi)k exists in the denominator, i.e., −pi is the pole of multiplicity k, the
corresponding sub-expansion can be written as
ri
z + pi
+
ri+1
(z + pi)2 + · · · +
ri+k−1
(z + pi)k .
(5-6-6)

Integral Transforms and Complex-valued Functions
211
Thus, the values ri+j−1 can be evaluated from the following formula
ri+j−1 =
1
(j −1)!
lim
z→−pi
dj−1
dzj−1
%
G(z)(z + pi)k&
, j = 1, 2, · · · , k.
(5-6-7)
A numerical function residue() is provided in MATLAB, which can be used in the
partial fraction expansion of a given rational function G(z). The syntax of the function
is [r,p,K]= residue(b,a), where a = [1,a1,a2,· · · , an], and b = [b1,b2,· · · ,bm]. The
returned arguments r and p are vectors containing the ri coeﬃcients and −pi poles, in
(5-6-4). If repeated poles exist, the ri terms can be replaced with the coeﬃcients in (5-6-6).
The argument k is the direct term, which for the function satisfying m < n, K will return
an empty matrix. The function can be used to automatically judge whether the pole −pi is
repeated, so as to arrange the values of ri. It is worth mentioning that, if the function has
repeated poles, the numerical approach is unreliable. Symbolic partial fractional expansion
should be performed.
Example 5.37
Compute the partial fraction expansion for the following function
G(z) =
z3 + 2z2 + 3z + 4
z6 + 11z5 + 48z4 + 106z3 + 125z2 + 75z + 18.
Solution The following statements can be used to take partial fraction expansion
>> n=[1,2,3,4]; d=[1,11,48,106,125,75,18]; format long % display format
[r,p,k]=residue(n,d); [n,d1]=rat(r); [n,d1,p] % numerical solution
with nT = [−17, −7, 2, 1, −1, 1], dT
1 = [8, 4, 1, 8, 2, 2], pT = [−3, −3, −2, −1, −1, −1], where
p is the vector of poles, n, d1 are the corresponding numerators and denominators of the
coeﬃcients r. It can be seen that −3 is a pole of multiplicity 2, −2 is a single pole, while
−1 is a pole of multiplicity 3. Thus, the partial fraction expansion can be written as
G(z) = −
17
8(z + 3) −
7
4(z + 3)2 +
2
z + 2 +
1
8(z + 1) −
1
2(z + 1)2 +
1
2(z + 1)3 .
Example 5.38
Compute the partial fraction expansion of the following function
G(z) =
2z7 + 2z3 + 8
z8+30z7+386z6+2772z5+12093z4+32598z3+52520z2+45600z+16000.
Solution With the residue() function, the numerical solutions can be obtained. And for
this example, the partial fraction expansion can be obtained
>> n=[2,0,0,0,2,0,0,8]; d=[1,30,386,2772,12093,32598,52520,45600,16000];
[r,p]=residue(n,d)
and due to the limitations in the numerical results, it might be diﬃcult to ﬁnd the multiplicity
of poles. Thus, the exact partial fraction expansion cannot be obtained. From the results
obtained, it can be approximately assumed that p1 = −5 and p2 = −4 are poles of
multiplicity 3, while p3 = −2 and p4 = −1 are single poles. Thus, the partial fraction
expansion can be written as
49995.9030930686
(z + 5)
+ 28488.5832580441
(z + 5)2
+ 13040.9999762507
(z + 5)3
−50473.1527861460
(z + 4)
21449.5555022347
(z + 4)2
−5481.3333201362
(z + 4)3
+ 1.2222222224
(z + 2)
+ 0.0023148148
(z + 1)
.

212
Scientiﬁc Computing with MATLAB®
It should be noted that approximations are made in writing the above denominators, the
original one is even more imprecise.
Clearly, a better analytical or symbolic function is expected without numerical issues
that may cause the pole multiplicity issues. In new versions of MATLAB, the symbolic
engine MuPAD provides a low-level function partfrac(), and can be called from MATLAB
with F = feval(symengine,’partfrac’,f).
An interface with the same name is written, with the syntaxes
F = partfrac2(f), F = partfrac2(f,z) or
F = partfrac2(f,’List’) ,
where, the listing of the interface function partfrac() is
function Y=partfrac2(varargin)
Y=feval(symengine,’partfrac’,varargin{:});
In the ﬁrst two synatxes, the partial fraction expansion F is returned, while in the third
one, F(1) returns the coeﬃcient vector, while F(2), the denominator of each term.
Example 5.39
Compute the partial fraction expansion to f(z) in Example 5.37.
Solution The following statements can be used to solve the problem
>> syms z;
f=(z^3+2*z^2+3*z+4)/(z^6+11*z^5+48*z^4+106*z^3+125*z^2+75*z+18);
G1=partfrac2(f), %
or G2=feval(symengine,’partfrac’,f)
and the result below is exactly the same as the one obtained earlier
G1(z) = −
17
8(z + 3) −
7
4(z + 3)2 +
2
z + 2 +
1
8(z + 1) −
1
2(z + 1)2 +
1
2(z + 1)3 .
Example 5.40
Now consider again the rational function G(z) deﬁned in Example 5.38.
Write the partial fraction expansion using analytical methods.
Solution In Example 5.38, the numerical approach was used, and the results may not be
accurate. Thus, the problem can be explored with the symbolic function
>> syms z
G=(2*z^7+2*z^3+8)/(z^8+30*z^7+386*z^6+...
2772*z^5+12093*z^4+32598*z^3+52520*z^2+45600*z+16000);
f=partfrac2(G), simplify(f-G)
and then, the expected partial fraction expansion is
f(z) =
13041
(z + 5)3 +
341863
12(z + 5)2 +
7198933
144(z + 5) −
16444
3(z + 4)3 +
193046
9(z + 4)2
−1349779
27(z + 4) +
11
9(z + 2) +
1
432(z + 1).
Compared with the results obtained in Example 5.38, the new result is more convincing.
The diﬀerence between the expansion and the original function can be found with
simplify(f-G) which is 0.
If the following statements are issued
>> Y=partfrac2(G,’List’), n=Y(1), d=Y(2)

Integral Transforms and Complex-valued Functions
213
the two vectors are returned,
n =
11
9 , 1
432, 7198933
144
, 341863
12
, 13041, −1349779
27
, 193046
9
, −16444
3

,
d = [z + 2, z + 1, z + 5, (z + 5)2, (z + 5)3, z + 4, (z + 4)2, (z + 4)3].
Example 5.41
For the non-coprime rational function in Example 5.36, the overloaded
residue() function can be used to write out the partial fraction expansion to the rational
function G(z) = A(z)/B(z).
Solution The following statements can be speciﬁed to solve the problem
>> syms z; A=z^4+7*z^3+13*z^2+19*z+20;
B=z^7+16*z^6+103*z^5+346*z^4+655*z^3+700*z^2+393*z+90;
partfrac2(A/B,z)
and it can be seen that
A(z)
B(z) = −
7
4 (z + 3)2 −
17
8 (z + 3) +
2
(z + 2) +
1
2 (z + 1)3 −
1
2 (z + 1)2 +
1
8 (z + 1),
where in the results, the term regarding z + 5 does not exist at all, since simpliﬁcation was
performed within the partfrac2() function already.
Example 5.42
Compute the partial fraction expansion to the following function
G(z) =
−17z5 −7z4 + 2z3 + z2 −z + 1
z6 + 11z5 + 48z4 + 106z3 + 125z2 + 75z + 17.
Solution The numerical residue() can be used ﬁrst
>> num=[-17 -7 2 1 -1 1]; den=[1 11 48 106 125 75 17];
[r,p,k]=residue(num,den); [r,p,k] % compute partial fraction numerically
and the partial fraction expansion can be written as
−556.256530687201
z + 3.261731010738 +
0.212556796963
z + 0.520859605293
0.879464926195 −j5.497076257858
z + 2.53094582005−j0.39976310545 + 0.879464926195 + j5.497076257858
z + 2.53094582005 + j0.39976310545
+268.64252201892 + j349.12310949979
z + 2.53094582005 −j0.39976310545 + 268.64252201892 −j349.12310949979
z + 2.53094582005 + j0.39976310545 .
However, with the symbolic function partfrac2() used, no analytical solution can be
found, since there are no poles found analytically
>> syms z;
G=(-17*z^5-7*z^4+2*z^3+z^2-z+1)...
/(z^6+11*z^5+48*z^4+106*z^3+125*z^2+75*z+17);
G1=partfrac2(G,z)
If there exists irrational pole z0 in the denominator equation D(z) = 0, there is no root-
ﬁnding algorithm to express accurately irrational value of z0 with ﬁnite digits, approximate
value ˆz0 can be used instead. It should be substituted into (5-6-2) to ﬁnd the approximate
residue
Res[f(z), ˆz0] = lim
z→ˆz0
1
(m −1)!
dm−1
dzm−1 [(z −ˆz0)m f(ˆz0)] .
(5-6-8)

214
Scientiﬁc Computing with MATLAB®
Assume that with vpa() function, all the approximate poles zi, i = 1, 2, · · · , n can
be obtained, and they can be used to compose the denominator. To replace the original
denominator, the approximate function f1(z) can be used to replace f(z) in (5-6-8). Thus,
f1(z) and (z −ˆz0)m can be canceled at ˆz0 point, and the approximate residue can be found.
The listing of the new function is
function f=partfrac1(F)
f=sym(0); z=symvar(F);
[num,den]=numden(F); x0=vpasolve(den); [x,ii]=sort(double(x0));
x0=x0(ii); x=[x0; rand(1)]; kvec=find(diff(double(x))~=0);
ee=x(kvec); kvec=[kvec(1); diff(kvec(:,1))];
a0=limit(den/z^length(x0),z,inf); F1=num/(a0*prod(z-x0));
for i=1:length(kvec), for j=1:kvec(i),
m=kvec(i); z0=ee(i); k=subs(diff(F1*(z-z0)^m,z,j-1),z,z0);
f=f+k/(z-z0)^(m-j+1)/factorial(j-1);
end, end
and the syntax of the function is f = partfrac1(F), where, F is the analytic expression of
the rational function. The returned f is the approximate partial fractional expansion.
Example 5.43
Solve the partial fraction expansion problem in Example 5.42.
Solution Since no exact factorization of the denominator exists, the partfrac2() function
cannot be used. Function partfrac1() can be used instead to perform approximate partial
fraction expansion
>> syms z;
G=(-17*z^5-7*z^4+2*z^3+z^2-z+1)...
/(z^6+11*z^5+48*z^4+106*z^3+125*z^2+75*z+17);
F=partfrac1(G) % combination of analytical and numerical
The approximate partial fraction expansion obtained is
F(z) = 0.2125568
z + 0.52086 + 0.8794649 + 5.49707626j
z + 1.077759 + 0.6021066j + 268.64252 −349.1231095j
z + 2.530946 + 0.399763j
+
556.25653
z + 3.261731 + 0.8794649 −5.49707626j
z + 1.077759 −0.6021066j + 268.64252 + 349.1231095j
z + 2.530946 −0.399763j .
5.6.3
Inverse Laplace transform using PFEs
It has been shown that the Symbolic Math Toolbox function ilaplace() can tackle the
inverse Laplace transform to the rational function problems very well. However, for a class
of problems where irrational complex roots exist, it has been shown in Example 5.3 that
the results obtained directly will have very poor readability.
It is found by observation of the results in Example 5.42 that some terms can be expressed
by (a + jb)/(s + c + jd), and there is also a complex conjugate term (a −jb)/(s + c −jd).
Thus, the two terms can be simpliﬁed such that
(a + jb)e(c+jd)t + (a −jb)e(c−jd)t = αect sin(dt + φ),
(5-6-9)
where α = −2
√
a2 + b2, and φ = −tan−1(b/a).
Based on such an algorithm, a numerical function pfrac() can be written to enhance
the facilities provided in the original function residue(). The listings of the function are

Integral Transforms and Complex-valued Functions
215
function [R,P,K]=pfrac(num,den)
[R,P,K]=residue(num,den);
for i=1:length(R),
if imag(P(i))>eps, a=real(R(i)); b=imag(R(i));
R(i)=-2*sqrt(a^2+b^2); R(i+1)=-atan2(a,b);
elseif abs(imag(P(i)))<eps, R(i)=real(R(i));
end, end
with the syntax [r,p,K]= pfrac(num,den), where the deﬁnitions of p and K are exactly
the same as the residue() function, and r is deﬁned slightly diﬀerently. If pi is real, then,
ri is the same as the ones described in residue() function. However, if pi is complex, then,
ri and ri+1, return, respectively the values of α and φ.
Example 5.44
Reconsider the problem in Example 5.42. Alternatively, we use
>> num=[-17,-7,2,1,-1,1]; den=[1,11,48,106,125,75,17];
[r,p,k]=pfrac(num,den); format long e; [r,p]
and the result is shown below
L −1[F(s)] = −556.25653068675e−3.2617310107386t + 2.1255679696e−0.5208596052932t
−881.03518709e−2.530945820048808t sin(0.39976310544995t−0.65585087707)
−11.13396711709e−1.0777588719353t sin(0.6021065910608t−2.9829493242804),
which is in a much more readable form.
5.6.4
Laurent series expansions
We have learnt Taylor series in Chapter 3, where the function f(x) can be expanded as
an inﬁnite series of (x −x0) polynomials. Laurent series is an extension of such a series.
If f(z) is analytic within a ring D, R1 < |z −z0| < R2, where, 0 ⩽R1 < R2 < +∞, the
Laurent series can be written as
f(z) =
∞

k=−∞
ck(z −z0)k,
(5-6-10)
where, the coeﬃcients can be calculated from
ck =
1
2πj

|z−z0|=ρ
f(ζ)
(ζ −z0)k+1 dζ,
(5-6-11)
where |z −z0| < ρ can be any circle, with R1 < ρ < R2. If f(z) is analytic in D, the Laurent
series is unique.
It is usually extremely diﬃcult to calculate the coeﬃcients with (5-6-11), an alternative
method can be taken, to calculate the series. Suppose the original function f(z) can be
partitioned into the product of two subfunctions f(z) = f1(z)f2(z), where f2(z) are suitable
for conventional Taylor series expansion, and the other part, f1(z), is to be expanded as the
series of (z−z0)k, when k is negative. Variable substitution x = 1/(z−z0) can be taken ﬁrst,
from it the original function can be substituted into a function of x, with z = (1 + xz0)/x,
and Taylor series about x can be obtained and can be denoted by F1(x). Then, the variable
can be substituted back to z with x = 1/(z −z0). The method can be demonstrated with
an example.

216
Scientiﬁc Computing with MATLAB®
Example 5.45
Please write out the Laurent series of function f(z) = z2e1/z.
Solution
There might be odd behavior at z = 0, due to the existence of e1/z, however,
z = 0 is not a pole, but an essential singularity. From the original function, it can be seen
that it is easier to partition the original function into f1(z) = e1/z, and f2(z) = z2. With
variable substitution z = 1/x, and the Taylor series expansion of the function f1(x) can be
obtained. Then, the variables in the expression can be converted back to the function of z,
by taking x = 1/z. The term f2(z) = z2 can be multiplied back to form the Laurent series
>> syms x z; f1=exp(1/z); f2=z^2; f1a=subs(f1,z,1/x);
F1a=taylor(f1a,x,’Order’,7); F=simplify(f2*subs(F1a,x,1/z))
and the Laurent series is
F(z) = z2 + z + 1
2 + 1
6z +
1
24z2 +
1
123z3 +
1
720z4 +
1
5040z5 + · · · .
In a relatively large interval of z ∈(−20, 20), the curves of the ﬁnite term Laurent series
F(z) and the original function f(z) can be drawn directly with the following statements, as
shown in Figure 5.10, and it can be seen that, apart from the very tiny neighborhood of
essential singularity, z = 0, the two curves are almost identical.
>> ezplot(F,[-20,20]), hold on; ezplot(f1*f2,[-20,20]), plot(0,1/6,’o’)
−20
−15
−10
−5
0
5
10
15
20
0
100
200
300
400
500
600
FIGURE 5.10: Output signal of the diﬀerence equation.
For a given Laurent series, it can be seen that there are inﬁnite terms in F(z) has z−k
as denominators, due to the existence of the essential singularity, and the residue is deﬁned
as the value of c−1, the coeﬃcient of z−1 term.
Example 5.46
Now consider the complex rational function f(z) =
1
z −1 +
1
z −2j. How
to ﬁnd the Laurent series expansion?
Solution
The function f(z) is clearly not analytic at the poles z = 1 and z = 2j. The
regions can be partitioned as, speciﬁcally, (i) the disk | z | < 1, (ii) 1 < | z | < 2, the ring,
and (iii) ∞> | z | > 2, the ring. In the three cases
(i)
If | z | < 1, it is implied that | z | < 2, or | z/2 | < 1 is satisﬁed. Taylor series is
suﬃcient, and with the well-known expansion formula
1
1 −u =
∞

k=0
uk, convergent when |u| < 1,

Integral Transforms and Complex-valued Functions
217
the Taylor series can be written as
F1(z) =
−1
1 −z +
−1/2j
1 −z/(2j) = −
∞

k=0

1 +
1
(2j)k+1

zk.
(ii) If 1 < | z | < 2, function f(z) is analytic, and since the convergent condition is not
satisﬁed for the ﬁrst term, 1/(z −1), it can be rewritten as (1/z)/(1 −1/z), Taylor series
expansion to 1/z can be made, while the Taylor expansion to the second term is valid. Thus,
the Laurent series can be written as
>> syms z x; f1=1/(z-1); f1a=subs(f1,z,1/x);
F2a=taylor(f1a,’Order’,6); F2=subs(F2a,x,1/z)
and the Laurent series can be written as
F2(z) =
−1

k=−∞
zk −
∞

k=0
1
(2j)k+1 zk.
(iii) If | z | > 2, expansions cannot be made on z, and the Taylor series expansions on
1/z should be made
>> f3=1/(z-1)+1/(z-2i); f3a=subs(f3,z,1/x);
F3a=taylor(f3a,’Order’,6); F3=subs(F3a,x,1/z)
and the Laurent series can be written as
F3(z) =
−1

k=−∞

1 +
1
(2j)k+1

zk.
It can be seen from this example that in the three diﬀerent analytic regions, three diﬀerent
Laurent series can be obtained. Thus, the Laurent series expansion is a piecewise function.
Following the cases studied earlier, an algorithm for obtaining Laurent series for a given
rational function is presented
Require: Rational function f(z), the order n, with default 6
Find all the poles p and sort according to | p |
Find diﬀerent radius R, and make a vector v = [ 0, R ]
for i = 1 To the length of v do
Partition f(z) = F1(z) + F2(z), F2(z) with all the poles | z | < Ri+1
Compute f1 ←Taylor series for F1(z), and f2 ←Taylor for F2(z) about 1/z
Compose F(i) = f1 + f2 as the symbolic expansion for Ri < | z | < Ri+1
end for
Generate the piecewise function F0 of Laurent series expansion.
A MATLAB function laurent series() is written based on the algorithm, and a
piecewise function with diﬀerent expansions can be returned.
function [F0,p,m,F]=laurent_series(f,n), [p,m]=poles(f);
STR=’’; if nargin==1, n=6; end
syms z x; assume(z~=0); assume(x~=0); F2=0;
if length(p)==0, error(’The poles cannot be found, failed.’); end
v=sort(unique([sym(0); abs(p)])); v0=[v; inf];

218
Scientiﬁc Computing with MATLAB®
Fx=partfrac2(f,’List’); nv=Fx(1); dv=Fx(2); f=partfrac2(f,z)
for i=1:length(v), F1=f-F2;
f1=taylor(F1,’Order’,n); f2=subs(F2,z,1/x);
f2=taylor(f2,’Order’,n); f2=subs(f2,x,1/z); F(i)=f1+f2;
v1=[char(v(i)) ’<abs(z)’]; F2=0;
if i==length(v), str1=v1;
else, str1=[v1 ’ and abs(z)<’ char(v(i+1))]; end
str2=char(F(i)); STR=[STR, ’’’’ str1 ’’’,’’’ str2 ’’’,’];
for j=1:length(nv), x0=solve(dv(j)); x0=x0(1);
if abs(x0)<v0(i+1)+eps, F2=F2+nv(j)/dv(j); end
end, end
F0=eval([’piecewise(’ STR(1:end-1) ’);’])
For a given Laurent series, it can be seen that there are inﬁnite terms in F(z) has z−k
as denominators, due to the existence of essential singularities, and the residue is deﬁned
as the value of c−1, the coeﬃcient of z−1.
Example 5.47 Consider again the rational function in Example 5.38. Please compute the
Laurent series about z = 0.
Solution The problem can be solved easily with the new function laurent series()
>> syms z
G=(2*z^7+2*z^3+8)/(z^8+30*z^7+386*z^6+...
2772*z^5+12093*z^4+32598*z^3+52520*z^2+45600*z+16000);
F=laurent_series(G) % express Laurent series with a piecewise function
The mathematical interpretation of the piecewise results is
(i) When | z | < 1
F1(z) = −22818679z5
6400000000 + 221063z4
64000000 −4981z3
1600000 + 121z2
50000 −
57z
40000 +
1
2000;
(ii) When 1 < | z | < 2
F2(z) = −216104333z5
172800000000 + 1968701z4
1728000000 −34487z3
43200000 +
71z2
675000 +
961z
1080000
−
49
27000 +
1
432z −
1
432z2 +
1
432z3 −
1
432z4 +
1
432z5;
(iii) When 2 < | z | < 4
F3(z) = 3083895667z5
172800000000 −64031299z4
1728000000 + 3265513z3
43200000 −51527z2
337500 + 330961z
1080000
−16549
27000 + 529
432z −1057
432z2 + 2113
432z3 −4225
432z4 + 8449
432z5;
(iv) When 4 < | z | < 5
F4(z) = −342479989z5
56250000
+ 62140157z4
2250000
−56159897z3
450000
+ 252776089z2
450000
−226630597z
90000
+ 202363009
18000
+ 31883669
144z2
−7198645
144z
−140679637
144z3
+ 618454229
144z4
−2709385813
144z5
;
(v) When | z | > 5

Integral Transforms and Complex-valued Functions
219
F5(z) = 2
z −60
z2 + 1028
z3
−13224
z4
+ 142048
z5
−1346208
z6
+ 11631876
z7
.
5.6.5
Computing closed-path integrals
Now consider the closed-path integral
I =
0
Γ
f(z) dz,
(5-6-12)
where Γ is a closed-path in a counterclockwise direction. Suppose that the closed-path
encircles m poles, pi, (i = 1, 2, · · · , m). The residues Res[f(pi)] of the poles can be obtained
using the MATLAB statements given earlier. The closed-path integral of the f(z) function
can be calculated from
I =
0
Γ
f(z) dz = j2π
m

i=1
Res[f(pi)].
(5-6-13)
It should be mentioned that the closed-path Γ can be of any shape, any curvature, the
integral is only related to the poles it encircles. In other words, if the closed-path is quite
complicated, it might be diﬃcult to evaluate the integral using the curve integral method
presented in Chapter 3, however, it can be evaluated directly by taking curve integrals of
other simple closed-paths, such as circles, as long as they encircle the same poles.
If Γ is in a clockwise direction, the integral I should be multiplied by −1.
Example 5.48
Compute the closed-path integral on | z |=6, and f(z) is given by
f(z) =
2z7 + 2z3 + 8
z8+30z7+386z6+2772z5+12093z4+32598z3+52520z2+45600z+16000.
Solution
It can be seen from Example 5.40 that the partial fraction expansion of the
original function is
f(z) =
13041
(z + 5)3 +
341863
12(z + 5)2 +
7198933
144(z + 5) −
16444
3(z + 4)3 +
193046
9(z + 4)2
−1349779
27(z + 4) +
11
9(z + 2) +
1
432(z + 1).
Therefore, the poles p1 = −1 and p2 = −2 are single poles, and p3 = −4, p4 = −5 are
poles of multiplicity 3. Thus, the residues of the poles are the coeﬃcients of the ﬁrst degree
terms in the expression. Also, it is known that the poles are all encircled by the | z | = 6
path. The closed-path integral solution can be found from
0
| z |=6
f(z) dz = j2π
7198933
144
−1349779
27
+ 11
9 +
1
432

= j4π.
The same result can also be obtained with the function residuesym()
>> syms z
G=(2*z^7+2*z^3+8)/(z^8+30*z^7+386*z^6+2772*z^5+12093*z^4+...
32598*z^3+52520*z^2+45600*z+16000);
[r,p,m]=residuesym(G); I=2i*pi*sum(r) % compute the integral
With the path integral method discussed in Chapter 3, the integral can be evaluated
directly. The path Γ of the circle | z | = 6 can be expressed as z = 6 cos t+j6 sin t, t ∈[0, 2π].
Thus, the following statements can be given to ﬁnd I = j4π.

220
Scientiﬁc Computing with MATLAB®
>> syms t; F=subs(G,z,6*cos(t)+6*sin(t)*sqrt(-1));
% integrand
I=int(F*diff(6*cos(t)+6*sin(t)*sqrt(-1),t),t,0,2*pi) % path integral
If the closed-path is described by | z | = 3, in counterclockwise direction, the two poles
p3 and p4 should be excluded, since they are outside the circle. The integral can then be
obtained with the following statements, and the result is
I = 2πj
11
9 +
1
431

= 529π
216 j.
Also, the same result can be obtained with
>> [r,p,m]=residuesym(G,-3,3); I=2i*pi*sum(r)
The same result can also be obtained with the following integral evaluation
>> F=subs(G,z,3*cos(t)+3*sin(t)*sqrt(-1)); % alternative solution
I=int(F*diff(3*cos(t)+3*sin(t)*sqrt(-1),t),t,0,2*pi)
Example 5.49
Compute the following closed-path integral, where the path Γ is the
counterclockwise closed-path | z | = 2.
I =
0
Γ
1
(z + j1)10(z −1)(z −3) dz.
Solution
It can be seen that the original function has single poles at z = 1 and z = 3.
Also, the pole at z = −j1 is a pole of multiplicity 10. The poles z = 1 and z = −j1 are
encircled by Γ, and z = 3 is not. Therefore, the closed-path integral can be evaluated with
the following statements
>> syms z t; f=1/((z+1i)^10*(z-1)*(z-3)); [r,p,m]=residuesym(f)
with the poles located at p = [−j, 3, 1], and it can be seen that since the ﬁrst and the third
poles are encircled by the | z | = 2 circle, the integral can be evaluated with
>> R=2i*pi*sum(r([1,3])) % evaluate the integral
and the integral can be evaluated as R = (237/312500000 + j779/78125000)π.
With direct path integral method, the same result can be obtained.
>> F=subs(f,z,2*cos(t)+2*sin(t)*sqrt(-1))
% integrand
I=int(F*diff(2*cos(t)+2*sin(t)*sqrt(-1),t),t,0,2*pi) % path integral
If the path Γ is changed to | z | = 4, all three poles are encircled by the path. Therefore,
the closed-path integral can be obtained with
>> R=2i*pi*sum(r) % evaluate the integral through residues
and the integral is 0, which can also be conﬁrmed by direct integration method.
>> F=subs(f,z,4*cos(t)+4*sin(t)*sqrt(-1))
I=int(F*diff(4*cos(t)+4*sin(t)*sqrt(-1),t),t,0,2*pi)
Example 5.50
Find the closed-path integral I =

| z |=1
z2e1/z dz.
Solution The Laurent series of the function has been obtained in Example 5.45, and for
this function, it is clear that z = 0 is an essential singularity of the function. However,
since it is not a pole, it cannot be obtained with poles() function. The residue of z = 0 is
the Laurent series coeﬃcient c−1 = 1/6, therefore, the closed-path integral can be obtained
as I = 2πjc−1 = πj/3. The result can be validated with path integral commands

Integral Transforms and Complex-valued Functions
221
>> syms z t; f=z^2*exp(1/z); F=subs(f,z,cos(t)+sin(t)*sqrt(-1));
I=int(F*diff(cos(t)+sin(t)*sqrt(-1),t),t,0,2*pi) % direct path integral
In traditional complex function courses, the univariate integrals can also be converted to
the closed-path integrals of complex functions by variable substitutions. For instance, the
integral
 ∞
0
sin x
x
dx is often solved in this way. With the use of MATLAB function int(),
the above problem can be solved directly. Therefore, it is not recommended to convert it to
complex functions.
>> syms x; I=int(sin(x)/x,x,0,inf) % direct integral is recommended
5.7
Solutions of Diﬀerence Equations
A linear diﬀerence equation is given by
y[(k+n)T ]+a1y[(k+n−1)T ]+a2y[(k+n−2)T ]+· · ·+any(kT )
= b1u[(k−d)T ]+b2u[(k−d−1)T ] + · · · + bmu[(k−d−m+1)T ],
(5-7-1)
where, T is the sample time, also known as sampling period. Similar to continuous systems
described by diﬀerential equations, the coeﬃcients ai and bi are all constants, and the
system is referred to as a linear time-invariant discrete system. Besides, the corresponding
input and output signals can be expressed as u(kT ) and y(kT ), where u(kT ) is the input
signal in the kth sample time, and y(kT ) is the output at the same time. For simplicity,
denote y(t) = y(kT ), and denote y[(k + i)T ] by y(t + i), the diﬀerence equation can be
simply rewritten as
y(t + n) + a1y(t + n −1) + a2y(t + n −2) + · · · + any(t)
= b1u(t + m −d) + b2u(t + m −d −1) + · · · + bm+1u(t −d).
(5-7-2)
5.7.1
Analytical solutions of linear diﬀerence equations
For the linear diﬀerence equation given earlier, if the initial values of y(0), y(1), · · · ,
y(n −1) contain nonzero elements, z transform can be taken to both sides of (5-7-2), and
we have
znY (z)−
n−1

i=0
zn−iy(i)+a1zn−1Y (z)−a1
n−2

i=0
zn−iy(i)+· · ·+anY (z)
= z−d
 
b1zmU(z) −b1
m−1

i=0
zn−iu(i) + · · · + bm+1U(z)
!
.
(5-7-3)
It can be found that
Y (z) = (b1zm + b2zm−1 + · · · + bm+1)z−dU(z) + E(z)
zn + a1zn−1 + a2zn−2 + · · · + an
,
(5-7-4)

222
Scientiﬁc Computing with MATLAB®
where, E(z) is the expression obtained from the input and output according to (5-4-2)
E(z) =
n−1

i=0
zn−iy(i) −a1
n−2

i=0
zn−iy(i) −a2
n−3

i=0
zn−iy(i) −· · · −an−zy(0) + ˆu(n), (5-7-5)
where
ˆu(n) = −b1
m−1

i=0
zn−iu(i) −· · · −bmzu(0).
(5-7-6)
Taking inverse z transform to Y (z), the analytical solution y(t) can be obtained. Based
on the previous approach, the MATLAB function for solving linear time-invariant diﬀerence
equation can be written
function y=diff_eq(A,B,y0,U,d)
E=0; n=length(A)-1; syms z; if nargin==4, d=0; end
m=length(B)-1; u=iztrans(U); u0=subs(u,0:m-1);
for i=1:n, E=E+A(i)*y0(1:n+1-i)*[z.^(n+1-i:-1:1)].’; end
for i=1:m, E=E-B(i)*u0(1:m+1-i)*[z.^(m+1-i:-1:1)].’; end
Y=(poly2sym(B,z)*U*z^(-d)+E)/poly2sym(A,z); y=iztrans(Y);
with the syntax y = diff eq(A,B,y0,U,d), where A and B are coeﬃcient vectors, U is
the z transform of the input signal, and y0 is the initial values of the output vector, d is the
delay constant, with a default value of 0. The function can be used in ﬁnding the analytical
solution of the diﬀerence equation.
Example 5.51
Please solve the following diﬀerence equation
48y(n+4)−76y(n+3)+44y(n+2)−11y(n+1)+y(n)=2u(n+2)+3u(n+1)+u(n),
where, y(0) = 1, y(1) = 2, y(2) = 0, y(3) = −1, and the input is u(n) = (1/5)n.
Solution The vectors A and B can be extracted directly from the equation, and the initial
vector and input can also be entered into MATLAB environment. Function diff eq() can
then be used to solve the diﬀerence equation
>> syms z n; u=(1/5)^n; U=ztrans(u);
% evaluate z transform of the input
y=diff_eq([48 -76 44 -11 1],[2 3 1],[1 2 0 -1],U) % analytical solution
n0=0:20; y0=subs(y,n,n0); stem(n0,y0) % numerical response and plot
and it can be seen that the analytical solution is
y(n) = 432
5
1
3
n
−26
5
1
2
n
−752
5
1
4
n
+ 175
3
1
5
n
−42
5
1
2
n
(n −1) .
The output signal can also be obtained as shown in Figure 5.11, and it can be seen that
the initial points are all obtained in the solution.
5.7.2
Numerical solutions of linear time varying diﬀerence equations
Linear time varying state space equation can be written as

x(k + 1) = F (k)x(k) + G(k)u(k),
x(0) = x0
y(k) = C(k)x(k) + D(k)u(k),
(5-7-7)
and with recursive approach, we have

Integral Transforms and Complex-valued Functions
223
0
2
4
6
8
10
12
14
16
18
20
−1.5
−1
−0.5
0
0.5
1
1.5
2
2.5
FIGURE 5.11: Output signal of the diﬀerence equation.
x(1) = F (0)x0 + G(0)u(0)
x(2) = F (1)x(1) + G(1)u(1) = F (1)F (0)x0 + F (1)G(0)u(0) + G(1)u(1)
...
and the solutions of equation can be eventually obtained with
x(k) = F (k−1)F (k−2) · · · F (0)x0+G(k−1)u(k−1)
+ F (k−1)G(k−2)u(k−2) + · · · + F (k−1) · · · F (0)G(0)u(0)
=
k−1

j=0
F (j)x0 +
k−1

i=0
⎡
⎣
k−1

j=i+1
F (j)
⎤
⎦G(i)u(i).
(5-7-8)
If F (i), G(i) are known, the above recursive algorithm can be used directly in the solution
of time varying diﬀerence equation. Also, the iterative process can be used to solve the
equation, from the known x(0), and ﬁnd x(1) from (5-7-7), and then ﬁnd x(2), · · · , so that
the solutions at all the time instances can be iteratively obtained.
Example 5.52
Please solve the following time varying diﬀerence equation [5]
x1(k + 1)
x2(k + 1)

=
0
1
1
cos(kπ)
 x1(k)
x2(k)

+
sin(kπ/2)
1

u(k),
where,
x1(0)
x2(0)

=
1
1

,
and u(k) =
) 1,
k = 0, 2, 4, · · ·
−1,
k = 1, 3, 5, · · · . .
Solution With iteration method, the for loop structure can be used, and the state variables
at all the time instances can be obtained directly, as shown in Figure 5.12.
>> x0=[1; 1]; x=x0;
% initial states
for k=0:100, if rem(k,2)==0, u=1; else, u=-1; end % compute input
F=[0 1; 1 cos(k*pi)]; G=[sin(k*pi/2); 1];
% compute F and G
x1=F*x0+G*u; x0=x1; x=[x x1];
% iterate for one step
end
subplot(211), stairs(x(1,:)), subplot(212), stairs(x(2,:))

224
Scientiﬁc Computing with MATLAB®
−4
−2
0
2
0
10
20
30
40
50
60
70
80
90
100
−5
0
5
FIGURE 5.12: Response of a discrete time varying system.
5.7.3
Solutions of linear time-invariant diﬀerence equations
A linear time-invariant diﬀerence equation is F (k) = · · · = F (0) = F , G(k) = · · · =
G(0) = G, and it can be found from (5-7-8) that
x(k) = F kx0 +
k−1

i=0
F k−i−1Gu(i).
(5-7-9)
However, it is not an easy thing to compute the sum in the above equation, an alternative
method needs to be considered.
Now, let us reconsider the equation in (5-7-7), its time-invariant form can be rewritten
as

x(k + 1) = F x(k) + Gu(k),
x(0) = x0
y(k) = Cx(k) + Du(k).
(5-7-10)
Take z transform to both side of the equation, with the property in (5-4-2), it can be
found that
X(z) = (zI −F )−1[zx0 + GU(z) −Gzu0],
(5-7-11)
and the analytical solution of the discrete equation can be derived as
x(k)=Z −1 %
z(zI−F )−1&
x0+Z −1 1
(zI−F )−1[GU(z)−Gzu0]
2
.
(5-7-12)
The kth power of a constant matrix F can also be computed with
F k = Z −1 %
z(zI −F )−1&
.
(5-7-13)
Example 5.53
For a state space model of a given discrete equation given below, ﬁnd the
analytical solution of the step responses of the states.
x(k + 1) =
⎡
⎢⎢⎣
11/6
−5/4
3/4
−1/3
1
0
0
0
0
1/2
0
0
0
0
1/4
0
⎤
⎥⎥⎦x(k) +
⎡
⎢⎢⎣
4
0
0
0
⎤
⎥⎥⎦u(k),
x0 = 0.
Solution With the following statements, the analytical solutions can be found
>> F=sym([11/6 -5/4 3/4 -1/3; 1 0 0 0; 0 1/2 0 0; 0 0 1/4 0]);
G=sym([4; 0; 0; 0]); syms z k; U=ztrans(sym(1));
x=iztrans(inv(z*eye(4)-F)*G*U,z,k)

Integral Transforms and Complex-valued Functions
225
and the analytical solutions can be written as
x(k) =
⎡
⎢⎢⎢⎢⎣
48(1/3)k −48(1/2)kk −72(1/2)k −24(1/2)kC2
k−1 + 48
144(1/3)k −48(1/2)kk −144(1/2)k −48(1/2)kC2
k−1 + 48
216(1/3)k −192(1/2)k −48(1/2)kC2
k−1 + 24
24(1/2)kk −24(1/2)kC2
k−1 −144(1/2)k + 162(1/3)k + 6.
⎤
⎥⎥⎥⎥⎦
In fact, in the returned results, combination nchoosek(n,k) is expressed, mathematically
written as Ck
n, and it can be evaluated from Ck
n = n!/(n −k)!/k!. For instance, C2
k−1 can be
simpliﬁed as a polynomial (k −1)(k −2)/2 = (k2 −3k + 2)/2. Therefore, the solution can
be manually simpliﬁed as
x(k) =
⎡
⎢⎢⎢⎢⎣
−12(8 + k + k2)(1/2)k + 48(1/3)k + 48
24(−8 + k + 2k2)(1/2)k + 144(1/3)k + 48
24(−10 + 3k −k2)(1/2)k + 216(1/3)k
12(−14 + 5k −k2)(1/2)k + 162(1/3)k + 6
⎤
⎥⎥⎥⎥⎦
.
Alternatively, since there is only the C2
k−1 term in the result, the following statement can
be used to simplify the results, and the simpliﬁed version is equivalent to the one obtained
manually.
>> x1=simplify(subs(x,nchoosek(k-1,2),(k-1)*(k-2)/2))
Example 5.54 Consider the Ak problem in Example 4.74, please ﬁnd Ak using inverse z
transform.
Solution It can be seen from (5-7-13) that, the matrix Ak can be found with the following
statements, and the result is the same as the one obtained in Example 4.74.
>> A=[-7,2,0,-1; 1,-4,2,1; 2,-1,-6,-1; -1,-1,0,-4]; % enter original matrix
syms z k; F1=iztrans(z*inv(z*eye(4)-A),z,k);
% inverse z transform
F2=simplify(subs(F1,nchoosek(k-1,2),(k-1)*(k-2)/2)) % simpliﬁcation
5.7.4
Numerical solutions of nonlinear diﬀerence equations
Assume that the diﬀerence equation is given in explicit form
y(t) = f(t, y(t −1), · · · , y(t −n), u(t), · · · , u(t −m)),
(5-7-14)
recursive method can be used to ﬁnd the solutions numerically.
Example 5.55
Assume a nonlinear diﬀerence equation is given by
y(t) =
y(t −1)2 + 1.1y(t −2)
1 + y(t −1)2 + 0.2y(t −2) + 0.4y(t −3) + 0.1u(t),
and assume the input signal is a sinusoidal function u(t) = sin t, and the sample time is
T = 0.05 s, please ﬁnd the numerical solutions of the diﬀerence equation.
Solution
A vector y0 for storing the past information is introduced, and its three
components y0(1), y0(2) and y0(3) store respectively y(t −3), y(t −2) and y(t −1). Within
the loop structure, the vector y0 is updated. Thus, with the following loop structure, the
diﬀerence equation can be solved recursively, and the input and output signals are shown in
Figure 5.13.

226
Scientiﬁc Computing with MATLAB®
>> y0=zeros(1,3); T=0.05; t=0:T:8*pi; u=sin(t); % initial setting
for i=1:length(t)
y(i)=(y0(3)^2+1.1*y0(2))/(1+y0(3)^2+0.2*y0(2)+0.4*y0(1))+...
0.1*u(i); y0=[y0(2:3), y(i)]; % recursively update the vector
end
plot(t,y,t,u)
0
2
4
6
8
10
12
14
−1
−0.5
0
0.5
1
FIGURE 5.13: Numerical solutions of nonlinear diﬀerence equation.
It can be seen that under the excitation of sinusoidal signal, distortions are observed in
the output signal of nonlinear systems.
Exercises
Exercise 5.1 Perform Laplace transforms for the following functions
(i) f(t) = sin αt
t
,
(ii) f(t) = t5 sin αt,
(iii) f(t) = t8 cos αt,
(iv) f(t) = t6eαt,
(v) f(t) = 5e−at + t4e−at + 8e−2t,
(vi) f(t) = eβt sin(αt + θ),
(vii) f(t) = e−12t + 6e9t.
Exercise 5.2 Take inverse transforms for the problems solved above and see whether the
corresponding original function can be restored.
Exercise 5.3 The following properties are also given for Laplace transforms. Verify for
diﬀerent values of n, that the following formula are satisﬁed.
(i) L [tnf(t)] = (−1)n dnL [f(t)]
dsn
,
(ii) L [tn−1/2] =
√π(2n −1)!
2n
s−n−1/2.
Exercise 5.4 Perform inverse Laplace transforms to the following F(s).
(i) F(s) =
1
√
s2(s2 −a2)(s + b)
,
(ii) F(s) = √s −a −
√
s −b,

Integral Transforms and Complex-valued Functions
227
(iii) F(s) = lns −a
s −b ,
(iv) F(s) =
1
√s(s + a),
(v) F(s) =
3a2
s3 + a3 ,
(vi) F(s) = (s −1)8
s7
,
(vii) F(s) = ln s2 + a2
s2 + b2 ,
(viii) F(s) = s2 + 3s + 8
38
i=1(s + i)
,
(ix) F(s) = 1
2
s + α
s −α.
Exercise 5.5 Show the Laplace transforms where the non-integer power of s is introduced,
which is the fundamental of fractional-order calculus.
(i) L [tγ] = Γ(γ + 1)
sγ+1
, one should check diﬀerent values of γ
(ii) L

1
√
t (1 + at)

= π
a es/aerfc

s/a

for a > 0.
Exercise 5.6 One of the applications of Laplace transform is that it can be used in
solving linear constant diﬀerential equations with zero initial conditions, using the property
L [dnf(t)/ dtn] = snL [f(t)]. Solve the diﬀerential equations
(i) y′′(t) + 3y′(t) + 2y(t) = e−t,
y(0) = y′(0) = 0;
(ii) y′′ −y = 4 sin t + 5 cos 2t,
y(0) = −1, y′(0) = −2;
(iii)
⎧
⎨
⎩
x′′ −x + y + z = 0
x + y′′ −y + z = 0
x + y + z′′ −z = 0,
x(0) = 1, x′(0) = y(0) = y′(0) = z(0) = z′(0) = 0.
Exercise 5.7 Assume that a fractional-order system is constructed of two sub models G1(s)
and G2(s), in parallel connection, and the overall model can be obtained with G(s) = G1(s)+
G2(s). Please ﬁnd the step response of the overall system, where
G1(s) =
(s0.4 + 2)0.8
√s(s2 + 3s0.9 + 4)0.3 ,
G2(s) =
s0.4 + 0.6s + 3
(s0.5 + 3s0.4 + 5)0.7 .
Exercise 5.8 If the two sub models G1(s) and G2(s) in the previous problem are in series
connection, and the overall model can be expressed as G(s) = G2(s)G1(s), please draw the
step response of the overall system.
Exercise 5.9 Perform Fourier transforms to the following functions, and then, perform
inverse Fourier transforms to see whether the original functions can be restored.
(i) f(x) = x2(3π −2|x|),
(ii) f(t) = t2(t −2π)2,
(iii) f(t) = e−t2,
(iv) f(t) = te−|t|.
Exercise 5.10 Perform Fourier sine and cosine transforms for the following functions and
then, perform inverse transformation and see whether the original functions can be restored.
(i) f(t) = e−t ln t,
(ii) f(x) = cos x2
x
,
(iii) f(x) = ln
1

1 + x2 ,
(iv) f(x) = x(a2 −x2), a > 0,
(v) f(x) = cos kx.
Exercise 5.11 Compute the discrete Fourier sine and cosine transforms for the functions
(i) f(x) = ekx, and (ii) f(x) = x3.

228
Scientiﬁc Computing with MATLAB®
Exercise 5.12 Write the Mellin transform for the function
f(x) =

sin(alnx),
x ⩽1
0,
otherwise.
Exercise 5.13 Perform z transforms to the time sequences f(kT ), and verify the results.
(i) f(kT )=cos(kaT ), (ii) f(kT )=(kT )2e−akT , (iii) f(kT )= 1
a(akT −1+e−akT),
(iv) f(kT ) = e−akT −e−bkT ,
(v) f(kT ) = 1 −e−akT (1 + akT ).
Exercise 5.14 Perform inverse z transforms to the following functions.
(i) F(z) =
10z
(z −1)(z −2),
(ii) F(z) =
z−1(1 −e−aT )
(1 −z−1)(1 −z−1e−aT ),
(iii) F(z) =
z
(z −a)(z −1)2 ,
(iv) F(z) = Az[z cos β −cos(αT −β)]
z2 −2z cos(αT ) + 1
.
Exercise 5.15 Take inverse Laplace transform to the following functions, then, take z
transform and verify the results.
(i) G(s) =
b
s2(s + a),
(ii) G(s) =
b
s2(s + a)2
1 −e−T s
s
.
Exercise 5.16 For G(s) = 1/(s + 1)3, if one substitutes s = 2(z −1)/[T (z + 1)] into
G(s), the function H(z) can be obtained. This kind of transform is referred to as bilinear
transform. For T = 1/2, ﬁnd H(z). One may also assume that z = (1 + T s/2)/(1 −T s/2),
inverse bilinear transform can be performed. Check whether the original function can be
restored.
Exercise 5.17 Assume that z = x + jy, where x and y satisfy x2 + (y −1)2 = 1. It is
obvious that z is a circle. Please use w = 1/z to map the circle into other kind of curve.
What is the mapped curve?
Exercise 5.18 Show that
Z
#
1 −e−akT 
cos bkT + a
b sin bkT
4
=
z(Az + B)
(z −1)(z2 −2ze−aT cos bT + e−2aT ),
where
A = 1 −e−aT cos bT −a
b e−aT sin bT,
B = e−2aT + a
b e−aT sin bT −e−aT cos bT.
Exercise 5.19 For the function
f(z) =
z2 + 4z + 3
z5 + 4z4 + 3z3 + 2z2 + 5z + 2e−5z,
ﬁnd the poles and their multiplicities and compute the residues for each pole.
Exercise 5.20 Judge whether the following pairs of polynomials are coprime or not. If not,
ﬁnd the terms which can simplify B(z)/A(z).

Integral Transforms and Complex-valued Functions
229
(i) B(z) −3z4 + z5 −11z3 + 51z2 −62z + 24,
A(z) = z7 −12z6 + 26z5 + 140z4 −471z3 −248z2 + 1284z −720,
(ii) B(z) = 3z6 −36z5 + 120z4 + 90z3 −1203z2 + 2106z −1080,
A(z) = z9+15z8+79z7+127z6−359z5−1955z4−3699z3−3587z2−1782z−360.
Exercise 5.21 Please draw Riemann surfaces for the following functions
(i) f(z) = z cos z2,
(ii) f(z) = ze−z2(cos z −sin z).
Exercise 5.22 Please write out the Laurent series of the functions, and ﬁnd the residues
(i) f(z) = ze−1/z2[sin(1/z) −cos(1/z)],
(ii) f(z) = z5 cos(1/z2).
Exercise 5.23 Please write the Laurent series for the following function
f(z) =
3
z −1 +
1
(z −1)2 +
1
z −2 +
1
(z −2)2 +
5
z + i +
5
z −i.
Exercise 5.24 Perform partial fraction expansions for the following functions, and ﬁnd
the poles, the multiplicities and the residures of the functions
(i) f(z) =
3z4 −21z3 + 45z2 −39z + 12
z7 + 15z6 + 96z5 + 340z4 + 720z3 + 912z2 + 640z + 192,
(ii) f(z) =
z + 5
z8+21z7+181z6+839z5+2330z4+4108z3+4620z2+3100z+1000,
(iii) f(z) =
3z6 −36z5 + 120z4 + 90z3 −1203z2 + 2106z −1080
z7 + 13z6 + 52z5 + 10z4 −431z3 −1103z2 −1062z −360,
(iv) f(z) =
(z2 + 4z + 3)e−5z
z5 + 7z4 −2z3 −100z2 −232z −160.
Exercise 5.25 Find the poles, multiplicities and residues of the following functions
(i) f(z) =
1 −sin ze−2z
z7 sin(z −π/3)(z4 + 10z3 + 35z2 + 50z + 24),
(ii) f(z) =
(z −3)4
z4 + 5z3 + 9z2 + 7z + 2(sin z −e−3z),
(iii) f(z) = (1 −cos 2z)(1 −e−z2)
z3 sin z
.
Exercise 5.26 Evaluate the closed-path integrals
(i)
0
Γ
z15
(z2 + 1)2(z4 + 2)3 dz, where Γ is the positive circle | z | = 3;
(ii)
0
Γ
z3
1 + z e1/z dz, where Γ is the positive circle | z | = 2;
(iii)
0
Γ
cos z(1 −e−z2) sin(3z + 2)
z sin z
dz, where Γ is the positive circle | z | = 1,
(iv)

| z |=2
z −2
z3(z −1)(z −3) dz.

230
Scientiﬁc Computing with MATLAB®
Exercise 5.27 Fibonacci sequence, a(1) = a(2) = 1, a(t+2) = a(t)+a(t+1), t = 1, 2, · · ·,
is a linear diﬀerence equation. Please ﬁnd the analytical solution of its general term a(t).
Exercise 5.28 Solve the following linear diﬀerence equations.
(i) 72y(t) + 102y(t −1) + 53y(t −2) + 12y(t −3) + y(t −4) = 12u(t) + 7u(t −1), where
u(t) is step input signal, and y(−3) = 1, y(−2) = −1, y(−1) = y(0) = 0;
(ii) y(t) −0.6y(t −1) + 0.12y(t −2) + 0.008y(t −3) = u(t), u(t) = e−0.1t, and the initial
value of y(t) is 0.
Exercise 5.29 Please solve the following nonlinear diﬀerence equation
y(t) = u(t) + y(t −2) + 3y2(t −1) + y(t −2) + 4y(t −1) + 2u(t)
1 + y2(t −2) + y2(t −1) , and when t ⩽0, the
initial values are y(t) = 0, and u(t) = e−0.2t.
Exercise 5.30 Assume the state space models of the discrete systems are given below, please
ﬁnd the analytical solutions of the step responses of the systems, and compare with numerical
solutions.
(i) x(t + 1) =

0
1
−0.16
−1

x(t) +

1
1

u(t), xT(0) = [ 1, −1 ],
(ii) x(t + 1) =
⎡
⎢⎢⎣
11/6
−1/4
25/24
−2
1
1
−1
−1
0
1
−1
0
0
1
−3/4
0
⎤
⎥⎥⎦x(t) +
⎡
⎢⎢⎣
2
1/2
−3/8
1/4
⎤
⎥⎥⎦u(t), xT(0) = [ 0, 0, 1, 1 ].
Bibliography
[1] Mauch S. Advanced mathematical methods for scientists and engineers. Open source
textbook at http://www.its.caltech.edu/~sean/ applied math.pdf, 2004
[2] Valsa J, Branˇcik L. Approximate formulae for numerical inversion of Laplace transforms.
International Journal of Numerical Modelling: Electronic Networks, Devices and Fields,
1998, 11(3):153–166
[3] Valsa J. Numerical inversion of Laplace transforms in MATLAB, MATLAB Central
File ID: #32824, 2011
[4] Song S N, Sun T, Zhang G W. Complex-valued function and integral transforms. Beijing:
Science Press, 2006. (in Chinese)
[5] Zheng D Z. Linear system theory (2nd edition). Beijing: Tsinghua University Press,
2002. (in Chinese)

Chapter 6
Nonlinear Equations and Numerical
Optimization Problems
The solutions to linear algebraic equations have been discussed extensively in Chapter 4.
However, most frequently encountered are nonlinear equations in science and engineering
problems. Solving nonlinear equations could be computationally expensive; therefore, the
solving of approximate linear equations was indispensable especially in the early times when
the computers were not powerful enough. Today, with the rapid development of computing
technology, directly solving nonlinear equations is becoming increasingly important. In this
chapter, we will focus on MATLAB solutions to nonlinear equations and optimization
problems. In Sections 6.1 and 6.2, solutions to nonlinear algebraic equations will be
presented. The graphical method for nonlinear equations with one and two unknown
variables will be given ﬁrst, and quasi-analytical solutions will be studied for polynomial
equations and equations convertible to polynomial equations. Numerical solutions to
nonlinear equations and nonlinear matrix equations will also be discussed in this section.
Eﬀorts are made for the user to ﬁnd all possible solutions to the equations with simple
methods.
The so-called optimization is to ﬁnd the values of certain variables such that the
preselected objective function takes maximum or minimum. Optimization technique is very
useful in scientiﬁc research and engineering practice. Equipped with the ideas and methods,
the user’s research capabilities can be signiﬁcantly promoted, since by that time, he may
no longer be satisﬁed with ﬁnding a solution. His target may become “how to ﬁnd the best
solution.”
Optimization problems can be classiﬁed as unconstrained optimization problems
and constrained optimization problems. In Section 6.3, MATLAB-based solutions to
unconstrained optimization problems will be given. Graphical and numerical methods will
be presented and the concept of global optimum solutions and local optimum solutions will
be illustrated. A new solver is proposed aiming at ﬁnding global minimum of unconstrained
problems. In Section 6.4, constrained optimization problems will be studied and MATLAB-
based solution methods will be presented. The concept of feasible regions will be introduced.
In this section, the linear programming, quadratic programming and general nonlinear
programming will be studied and MATLAB-based solutions will be illustrated through
examples. In Section 6.5, the idea of programming problems will be further extended to
integer programming and mixed integer programming problems. An algorithm is proposed
and implemented in MATLAB, aiming at ﬁnding global optimal solutions of constrained
nonlinear programming problems. Mixed linear programming solutions will be studied
and also a MATLAB solver based on the branch-and-bound algorithm is used for solving
nonlinear mixed integer programming problems. Binary programming problems are also
studied. In Section 6.6, a special type of optimization problem — the linear matrix inequality
problem, is fully discussed and the solution methods are presented. An introductory
presentation to multiple objective programming and dynamic programming will be given
231

232
Scientiﬁc Computing with MATLAB®
in Sections 6.7 and 6.8. Note that in Chapter 10, the global optimization methods will be
presented based on evolutionary computing methods.
For readers who wish to check the detailed explanations of various solution techniques
for nonlinear equations, we recommend the free textbook [1] (Chapter 9). For optimization
theory and numerical optimization methods, the free textbook [2] is highly recommended.
For LMIs, we suggest the free textbook [3]. We also found the online resource for deciding
the right software for optimization problems [4] useful and interesting.
6.1
Nonlinear Algebraic Equations
6.1.1
Graphical method for solving nonlinear equations
In has been shown in Chapter 2 that implicit functions with one and two variables can
be drawn easily using the MATLAB function ezplot(). With ezplot(), the nonlinear
equations can be shown graphically and its real solutions can be obtained by extracting the
coordinates of the intersections of the curves. The graphical methods are restricted only
to nonlinear equations with one or two variables. Nonlinear equations with more than two
variables have to be solved numerically or for some special cases, symbolically.
I. Graphical solution of univariate nonlinear equations
The function ezplot() can be used to draw the curve from the implicit function f(x) =
0. The real solutions can be identiﬁed from the intersections of the curves with the line
y = 0.
Example 6.1
Solve the equation e−3t sin(4t + 2) + 4e−0.5t cos 2t = 0.5 using graphical
method and examine the accuracy of the solutions.
Solution The function ezplot() can be used to draw the curve of the function as shown
in Figure 6.1 (a). The intersections with the horizontal axis are the solutions to the original
nonlinear equation.
>> syms t; f=exp(-3*t)*sin(4*t+2)+4*exp(-0.5*t)*cos(2*t)-0.5;
ezplot(f,[0 5])
% draw directly the implicit function
line([0,5],[0,0]) % draw the horizontal axis as well
From the curve it can be observed that there are three real solutions, p1, p2, p3, over the
interval t ∈(0, 5). One may zoom the area around a particular solution until the horizontal
axis reads the same scale. The horizontal scale is then regarded as a solution. An example
of the zoomed curve is shown in Figure 6.1 (b) where a solution t = 0.6738 can be obtained.
Substituting this reading back to the equation
>> t0=0.6738; e=double(subs(f,t,t0)) % ﬁnd the error
the error can be found as e = −2.9852×10−4. So, for this example, the achieved accuracy
of the solution is not quite as high. Similar methods can be used to ﬁnd and validate other
solutions.

Nonlinear Equations and Numerical Optimization Problems
233
0
1
2
3
4
5
−2
−1
0
1
2
p1
p2
p3
(a) the curve for implicit function over t ∈(0, 5)
0.6738
0.6738
0.6738
0.6738
0.6738
0.6738
0.6738
−6
−4
−2
0
2
4
×10−8
(b) zoomed curve and the solution
FIGURE 6.1: Graphical solutions to a univariate equation.
II. Graphical solution of nonlinear equations with two variables
Nonlinear equations with two variables can also be solved easily using the graphical
method. Use ezplot() function to draw the solutions to the ﬁrst equation. Then, use hold
on command to hold the graphics window such that the plot from ezplot() for the second
nonlinear equation is superimposed to the ﬁrst one. The intersections of the two sets of
curves are then the solutions to the original nonlinear equations. The solutions can be read
out graphically using the zooming method illustrated earlier.
Example 6.2
Solve graphically the following simultaneous equations
⎧
⎨
⎩
x2e−xy2/2 + e−x/2 sin(xy) = 0
y2 cos(y + x2) + x2ex+y = 0.
Solution
The graphical method can be used to solve the above nonlinear simultaneous
equations. The ﬁrst equation can be displayed with the direct use of the implicit function
drawing command ezplot(), as shown in Figure 6.2 (a). Unfortunately, the color of the
plots generated by ezplot() function may become very light, and it can be set manually
with speciﬁc MATLAB commands as follows.
>> h=ezplot(’x^2*exp(-x*y^2/2)+exp(-x/2)*sin(x*y)’) % the ﬁrst equation
set(h,’Color’,’b’); hold on;
% hold the coordinate
Use the command hold on to ensure the curves will not be removed. Then, ezplot()
draws the solutions to the second equation. The curves will then be superimposed on the
curves obtained earlier, as shown in Figure 6.2 (b).
>> h=ezplot(’y^2*cos(y+x^2)+x^2*exp(x+y)’), set(h,’Color’,’r’)
The intersections are then the solutions to the nonlinear equation sets. In this way,
all the real solutions to the given simultaneous equations in the interested ranges can be
displayed. To get the coordinates of a certain point, for instance point B in Figure 6.2 (b),
one may zoom the area around the point again and again until all the scales on the x-
and y-axes read the same, as shown in Figure 6.3 (a). Thus, the solution at point B is
x = −0.7327, y = 1.5619.

234
Scientiﬁc Computing with MATLAB®
−6
−4
−2
0
2
4
6
−6
−4
−2
0
2
4
6
(a) solutions to the ﬁrst equation
−6
−4
−2
0
2
4
6
−6
−4
−2
0
2
4
6
B
(b) superimposed curves
FIGURE 6.2: Graphical solutions to the nonlinear equations.
−0.7327
−0.7327
−0.7327
−0.7327
−0.7327
1.5619
1.5619
1.5619
1.5619
1.5619
1.5619
1.5619
x
y
(a) zooming for a solution
0
1
2
3
4
5
6
7
8
−15
−10
−5
0
x
y
(b) a larger region
FIGURE 6.3: More on the graphical solutions.
From Figure 6.2 (b) it is also found that most of the solutions are located in the
fourth quadrant. Thus, a large area can be chosen. For instance, the rectangular region
(0, 0), (8, −10) can be selected, and the solutions in the new area can be displayed as shown
in Figure 6.3 (b).
>> h1=ezplot(’x^2*exp(-x*y^2/2)+exp(-x/2)*sin(x*y)’,[0,8,-15,0])
hold on, h2=ezplot(’y^2*cos(y+x^2)+x^2*exp(x+y)’,[0,8,-15,0])
set(h1,’Color’,’b’); set(h2,’Color’,’r’) %
set the colors of the curves
6.1.2
Quasi-analytic solutions to polynomial-type equations
Before illustrating solutions to polynomial equations, let us consider two simple-to-solve
equations.
Example 6.3 Consider a 1500-year-old ancient Chinese math legend: In a cage, there are
chicks and rabbits, with a total of 35 heads and 94 feet. How many chicks and rabbits in
the cage?
Solution With modern mathematics, simultaneous equations can be established, x+y = 35

Nonlinear Equations and Numerical Optimization Problems
235
and 2x + 4y = 94, where x and y are the numbers of chicks and rabbits, respectively. Of
course, this can be solved with simple methods such as linear algebra. Is there any better
way to solve this kind of problem with MATLAB?
Example 6.4
Solve the following equations using the graphical method.

x2 + y2 −1 = 0
0.75x3 −y + 0.9 = 0.
Solution Using the graphical method, the two curves for the two equations can be displayed
easily using the following statements, as shown in Figure 6.4. The intersections are the
solutions to the original equations.
>> h1=ezplot(’x^2+y^2-1’); hold on % solutions to the ﬁrst equation
h2=ezplot(’0.75*x^3-y+0.9’)
% the second equation
set(h1,’Color’,’b’); set(h2,’Color’,’r’) %
set the colors of the curves
−1.5
−1
−0.5
0
0.5
1
1.5
−1
−0.5
0
0.5
1
FIGURE 6.4: Solutions using graphical method.
It can be seen from the curves in Figure 6.4 that there are two intersections. However,
it cannot be simply concluded that the original equations have only two solutions. One may
solve y from the second equation and ﬁnd that y is a function of x3. Substituting the equation
into the ﬁrst one, it can be concluded that the equation can be converted into a polynomial
equation of x, with the highest degree of 6. Thus, the polynomial equation must have 6 roots.
Where are the other 4 roots?
The new function vpasolve() provided in the Symbolic Math Toolbox of MATLAB is
quite eﬀective in ﬁnding all the solutions, real and complex, to polynomial-type equations,
while the solve() function can only be used in ﬁnding analytical solutions, if they exist.
The function can be used in ﬁnding solutions to the simultaneous equations which can be
converted to polynomial equations. The syntaxes of the function are as follows. Please note
that the syntaxes of the function are diﬀerent from the ones in old versions.
S = vpasolve([eqn1,eqn2,· · · ,eqnn])
[x,y,· · ·] = vpasolve([eqn1,eqn2,· · · ,eqnn])
[x,y,· · ·] = vpasolve([eqn1,eqn2,· · · ,eqnn],[x,y,· · ·])
[x,y,· · ·] = vpasolve([eqn1,eqn2,· · · ,eqnn],[x,y,· · ·],[x0,y0,· · · ])

236
Scientiﬁc Computing with MATLAB®
where eqni is the symbolic expression, with == representing the equal signs, of the ith
equation to be solved. In old versions, strings can be used to express the equations, and
it seems that string descriptions are not recommended in future versions. Also, in the
function call, initial search points in the independent variables can be assigned with the
vector [x0,y0,· · · ].
In this way, simultaneous equations can easily be represented. In the ﬁrst statement, a
structured variable S is returned, and the solutions are ﬁelds of S. For instance, S.x and
S.y.
Example 6.5
Solve again the two equations in Examples 6.3 and 6.4.
Solution
For the rabbit–chick cage problem, the MATLAB statements can be used, and
the solution is x = 23, y = 12, meaning there are 23 chicks and 12 rabbits in the cage.
>> syms x y; [x0 y0]=vpasolve(x+y==35,2*x+4*y==94) % or with solve()
The vpasolve() function can be used in solving the equations in Example 6.4 with
>> syms x y; [x0,y0]=vpasolve(x^2+y^2-1==0,0.75*x^3-y+0.9==0)
and the solutions are found as
x =
⎡
⎢⎢⎢⎢⎢⎢⎣
.35696997189122287798839037801365
.8663180988361181101678980941865 + j1.21537126646714278013183785444
−.553951760568345600779844138827 + j.354719764650807934568637899349
−.98170264842676789676449828873194
−.553951760568345600779844138827−j.354719764650807934568637899349
.8663180988361181101678980941865−j1.21537126646714278013183785444
⎤
⎥⎥⎥⎥⎥⎥⎦
y =
⎡
⎢⎢⎢⎢⎢⎢⎣
.93411585960628007548796029415446
−1.4916064075658223174787216959 + j.705882007214022677539188271388
.929338302266743628529852766772 + j.2114382218589592361562338176221
.19042035099187730240977756415289
.929338302266743628529852766772 −j.2114382218589592361562338176221
−1.4916064075658223174787216959−j.705882007214022677539188271388
⎤
⎥⎥⎥⎥⎥⎥⎦
.
For this high-degree polynomial-type equation, according to the well-known Abel–Ruﬃni
Theorem, there exist no analytical solutions. The Symbolic Math Toolbox can be used
to obtain high-precision solutions. These types of solutions are referred to as the quasi-
analytical solutions. It can be seen that apart from the two sets of real solutions, there are
yet other sets of complex conjugate solutions to the original nonlinear equations. These
solutions cannot be obtained using graphical methods.
If the solutions are to be validated, it is better to express the equations with symbolic
expressions, rather than with equations. For this example, the equations can be solved and
validated with the following statements, and the norm of the error matrix is about 3.67×
10−38, far more accurate than the ones obtained under double-precision scheme.
>> syms x y; F=[x^2+y^2-1, 0.75*x^3-y+0.9]; % describe the equations
[x0,y0]=vpasolve(F,[x,y]), norm(subs(F,{x,y},{x0,y0})) % solve & verify
It can be seen in the example that, although the solution process in the two problems
are completely diﬀerent, the interface for the user is exactly the same. This is the beauty
of MATLAB — the equations can be described in a uniﬁed form, and the problems can be
solved with the same solver.

Nonlinear Equations and Numerical Optimization Problems
237
Example 6.6
The polynomial-type equations with more variables can also be obtained
using the vpasolve() function. Find the solutions to the following equations
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
x + 3y3 + 2z2 = 1/2
x2 + 3y + z3 = 2
x3 + 2z + 2y2 = 2/4.
Solution The equations given are with three variables x, y, z. It can be seen that there are
only polynomial terms, thus, it can theoretically be converted into a univariate polynomial
equation. Even for a complicated set of equations, it is as easy as the simple cage equation
to the user, since, the quasi-analytical solutions of the equations can be solved with
>> syms x y z;
F=[x+3*y^3+2*z^2-1/2, x^2+3*y+z^3-2, x^3+2*z+2*y^2-2/4];
[x0,y0,z0]=vpasolve(F,[x,y,z]), size(x0) % ﬁnd and count solutions
It can be found that the obtained x0 is a 27 × 1 column vector, which means that the
original equations can be converted into a univariate polynomial equation with a degree of
27. Thus, the quasi-analytical solutions can be obtained using the above statements. The
solutions can be validated, and it can be seen that, the norm of the error matrix is as low
as 6.16×10−34.
>> norm(subs(F,{x,y,z},{x0,y0,z0})) % substitute back to ﬁnd the error
In fact, the terms given in the equations can also be written as a product of polynomials.
For instance, if the last equation in the third equation is given by x3 + 2zy2 = 2/4, with the
product of polynomials such as zy2, the solutions to the original equations can still be found
by the direct use of the solve() function. The statements used are
>> F(3)=x^3+2*z*y^2-2/4; [x0,y0,z0]=vpasolve(F,[x,y,z])
norm(subs(F,{x,y,z},{x0,y0,z0})) % substitute back to ﬁnd the error
and quasi-analytical solutions can be found, and the norm of the error for the new equations
can be as small as 7.3485×10−34.
Example 6.7
Solve the following equations where the reciprocals to the variables are
involved
⎧
⎪
⎨
⎪
⎩
1
2x2 + x + 3
2 + 21
y +
5
2y2 + 3 1
x3 = 0
y
2 + 3
2x + 1
x4 + 5y4 = 0.
Solution It is not likely possible to solve this kind of complicated equation without the help
of powerful computer mathematics languages. However, with the following statements the
quasi-analytical solutions can be obtained easily.
>> syms x y; clear F; F(1)=x^2/2+x+3/2+2/y+5/(2*y^2)+3/x^3;
F(2)=y/2+3/(2*x)+1/x^4+5*y^4; [x0,y0]=vpasolve(F), size(x0)
e=norm(subs(F,{x,y},{x0,y0})) % substitute back to ﬁnd the error
and it can be seen that there are 26 pairs of solutions. Substituting all the solutions back to
the original equations, one can immediately ﬁnd that the norm of the error is 1.7374×10−33,
which means that the solutions are very accurate.

238
Scientiﬁc Computing with MATLAB®
Function solve() was the major algebraic equation solver in old versions of Symbolic
Math Toolbox. In recent versions, this function can only be used in solving equations with
analytical solutions. If there is no analytical solution, vdpsolve() function is recommended.
Example 6.8
Solve the equations with constants
⎧
⎨
⎩
x2 + ax2 + 6b + 3y2 = 0
y = a + x + 3.
Solution
The solve() function can be used directly to solve the equations, even if it
contains extra variables. The solutions to the problem can be obtained by the direct use of
the function calls such that
>> syms a b x y; % ﬁnd analytical solution
F=[x^2+a*x^2+6*b+3*y^2, y-a-(x+3)]; [x0,y0]=solve(F,[x,y])
and the solutions can be written as
x = −6a −18 ± 2
√
−21a2 −45a −27 −24b −6ab −3a3
2(4 + a)
,
y = a + (x + 3).
In fact, the method may apply to third- or fourth-degree equations as well. However, the
solutions are usually too complicated to display.
It should be noted that the analytical or quasi-analytical solution methods introduced
in the previous subsections are not general-purpose. They can only be used in dealing with
problems convertible to high-degree univariate polynomial equations. Furthermore, for most
nonlinear equations, we cannot expect to ﬁnd all the possible solutions.
6.1.3
Numerical solutions to general nonlinear equations
A numerical solution function fsolve() provided in MATLAB can be used to search
for a real solution to given nonlinear equations. The syntaxes of the function are
x = fsolve(fun,x0)
% simplest syntax
[x,f,flag,out]= fsolve(fun,x0,opts,p1,p2,· · · )
% formal full syntax
where fun can either be an M-function, an anonymous function or an inline function
describing the equations to be solved. The variable x0 is the initial search point for the
solution. A numerical solution to the equations can be obtained by searching method from
the initial point x0 using numerical algorithms. If a solution is successfully found, the
returned flag is greater than 0, otherwise, the search is not successful.
For more complicated problems, the solution control option opts can be used to select
methods and control accuracies in searching the solution. The opts variable is deﬁned as
a structured variable, with the commonly used ﬁelds explained in Table 6.1. The following
syntaxes can be used in modifying the contents in the control options
opts = optimset;
% get default controls
opts.TolX= 1e-10; or set(opts,’TolX’,1e-10) % set control parameters
where, some of the ﬁelds such as MaxFunEvals are problem dependent, which is usually set
to 100 to 200 times the number of variables. The user may change the options using the
above mentioned function calls.

Nonlinear Equations and Numerical Optimization Problems
239
TABLE 6.1: Control options for equation solutions and optimizations.
ﬁeld name
explanation to the options
Display
To control whether the intermediate results are displayed, with the values ’off’ for no
display, ’iter’ for display in each iteration, ’notify’ for alert at none convergence,
and ’final’ for ﬁnal results display only
GradObj
To indicate whether the gradient information is used in optimization. The options are
’off’ and ’on’, with ’off’ the default
LargeScale
To indicate whether large-scale algorithms are used, with options ’on’ and ’off’. For
problems with only a few variables, it should be set to ’off’
MaxIter
The maximum allowed iterations for equation solution and optimization. This value can
be increased for problems failed to converge within the current control options
MaxFunEvals
The maximum allowed times of objective function calls
TolFun
The error tolerance of objective functions
TolX
The error tolerance of the solutions
Additional parameters p1, p2, · · · , pm are also allowed in the function calls.
Example 6.9
Consider again the equation e−3t sin(4t + 2) + 4e−0.5t cos 2t = 0.5 deﬁned
in Example 6.1. Find the solutions using numerical methods for a better accuracy.
Solution Using the vpasolve() function
>> syms t x; f=exp(-3*t)*sin(4*t+2)+4*exp(-0.5*t)*cos(2*t)-0.5;
t0=vpasolve(f), subs(f,t,t0) % ﬁnd a solution with vpasolve()
it can be found that the solution is t0 = 0.67374570500134756702960220427474, with an
error of 6.5×10−35. It is obvious that the nonlinear equation has no analytical solutions.
Graphical methods shown in Example 6.1 can be used to ﬁnd the numerical solutions.
However, the accuracy achieved by graphical method may not be very high. From the
approximate solution by graphical approach t = 3.5203, better results can be obtained by
directly using the fsolve() function.
By combining the graphical and numerical methods, it can be seen that a better solution
can be found
>> y=@(t)exp(-3*t).*sin(4*t+2)+4*exp(-0.5*t).*cos(2*t)-0.5;
[t,f]=fsolve(y,3.5203)
such that t = 3.52026389294877 and f = −6.06378×10−10. The solution found is much
more accurate than the graphical method. To get even better approximations, one can further
modify the control options with the following statements
>> ff=optimset; ff.TolX=1e-16; ff.TolFun=1e-30; % higher precision
[t,f]=fsolve(y,3.5203,ff)
% solve again
and the new solution is t = 3.52026389244155 with f = 0.
Example 6.10
Solve the equations in Example 6.4 using numerical algorithms.
Solution
Before solving such equations, the variables should be selected such that the
unknowns to be solved are assigned as a vector. Selecting the variables p1 = x, p2 = y, the
original simultaneous equations can be rewritten in matrix form as

240
Scientiﬁc Computing with MATLAB®
F (p) = [ p2
1 + p2
2 −1, 0.75p3
1 −p2 + 0.9 ]T = 0.
An anonymous function can be written to describe the two equations as a column vector,
and then, one may select the initial values at p0 = [1, 2]T. The function fsolve() can be
used directly to solve the original equations and ﬁnd a solution.
>> f=@(p)[p(1)^2+p(2)^2-1; 0.75*p(1)^3-p(2)+0.9]; % describe equation
[x,Y,c,d]=fsolve(f,[1; 2])
% numerical solution
The solution found is x = [0.35696997, 0.93411586]T, with the error Y = [0.1215 ×
10−9, 0.0964×10−9]. It can also be found by examining the d argument that 21 function calls
are made. Thus, the algorithm is quite eﬀective.
Similarly, the original equations can also be described by the inline function or by M-ﬁle.
With the anonymous functions, there is no need to create a separate M-ﬁle for each problem,
which makes the ﬁle management more tidy and convenient.
If the initial values are changed to p0 = [−1, 0]T, then, by using
>> [x,Y,c,d]=fsolve(f,[-1,0]’) % search solution from another initial point
another solution is found at x = [−0.981703, 0.1904204]T, and this time 15 function calls
are made and the norm of the error vector is 0.5618×10−10. In this example, it can be seen
that the selection of initial values may lead to other solutions.
If a complex initial value is selected, for instance, x0 = [−1 −j1, 1 −j1], complex root
can be found with fsolve() function
>> x0=[-1-1i; 1-1i]; [x,Y,c,d]=fsolve(f,x0) % search from complex point
with x = [−0.5540 −j0.3547, 0.9293 −j0.2114]T. With diﬀerent complex initial value
selections, all the other 3 complex solutions can be found.
Example 6.11 Consider the well-known Lambert W equation W(x)eW(x) = x, where x is
a ﬁxed value, and W(x) is the unknown variable to be solved. Please draw the curve W(x)
for x ∈(0, 5).
Solution
If the parameter x changes, the equation itself also changes. If an M-function
or other form is used to describe the equation, the ﬁle should be modiﬁed, which makes
the description of equation complicated. In this case, if x is represented as an additional
parameter, and there is no more need to modify the M-function. The following statements
can be used to draw Lambert W function. In fact, the MATLAB function lambertw() can
be used to evaluate Lambert W function directly, with y1 = lambertw(x0).
>> f=@(W,x)W.*exp(W)-x; x0=0:0.1:5; y=[]; opts=optimset;
for x=x0, y0=fsolve(f,x,opts,x); y=[y y0]; end, plot(x0,y)
6.2
Nonlinear Equations with Multiple Solutions
In Section 4.4.5, a special form of nonlinear matrix equation, algebraic Riccati equation,
is discussed. However, the solution is based on a very specialized algorithm, which cannot
be extended to other forms of nonlinear matrix equations. For instance, if the equation is
changed to
AX + XD −XBX + C = 0,
(6-2-1)

Nonlinear Equations and Numerical Optimization Problems
241
or even a tricky form
AX + XD −XBXT + C = 0,
(6-2-2)
the are() function is no longer applicable. So here, a nonlinear matrix equation solution
method is given for solving general nonlinear matrix equations.
Also, think about the plots given in Figure 6.2. How can we ﬁnd all the solutions to the
given simultaneous equations in the interested area?
In this section, we shall explore generalized ways in ﬁnding solutions to nonlinear
equations, using numerical, or even high-precision approaches.
6.2.1
Numerical solutions
Assume that a matrix equation is given by F (X) = 0, where both X and F (·) are both
n×m matrices. Anonymous functions or M-functions can be used to describe the equations.
The function fsolve() can be used in solving directly the equations.
In order to solve matrix or other nonlinear equations with multiple solutions, the
following algorithm can be formulated
Require: Anonymous function Y = F (X), initial solution X, range of interested region
A, error tolerance ϵ
Initialization, construct initial stored solution set X, in a 3D array
while true do
Randomly generate an x0, and ﬁnd a solution x with fsolve()
if this solution does not exist in X then
Store it in X
end if
if no new solution found in tlim seconds then
Terminate the while loop with break command
end if
end while
A MATLAB function more sols() is written to implement the algorithm. The user may
terminate the function at any time by pressing Ctrl-C keys. The listing of the function is as
follows
function more_sols(f,X0,varargin)
[A,tol,tlim]=default_vals({1000,eps,30},varargin{:});
if length(A)==1, a=-0.5*A; b=0.5*A; else, a=A(1); b=A(2); end
ar=real(a); br=real(b); ai=imag(a); bi=imag(b);
ff=optimset; ff.Display=’off’; [n,m,i]=size(X0);
ff1=ff; ff.TolX=tol; ff.TolFun=tol; X=X0;
try, err=evalin(’base’,’err’);
catch, err=0; end, if i<=1; err=0; end, tic
while (1),
x0=ar+(br-ar)*rand(n,m);
if abs(imag(A))>1e-5, x0=x0+(ai+(bi-ai)*rand(n,m))*1i; end
[x,aa,key]=fsolve(f,x0,ff1);
t=toc; if t>tlim, break; end
if key>0, N=size(X,3);

242
Scientiﬁc Computing with MATLAB®
for j=1:N, if norm(X(:,:,j)-x)<1e-5; key=0; break; end, end
if key>0, [x1,aa,key]=fsolve(f,x,ff);
if norm(x-x1)<1e-5 & key>0; X(:,:,i+1)=x1;
assignin(’base’,’X’,X); err=max([norm(aa),err]);
assignin(’base’,’err’,err); i=i+1, tic
end, end, end, end
The syntax of the function is more sols(f,X0,A,ϵ,tlim), and the low-level function
default vals() was deﬁned in Chapter 3, which can be used to assign default variables.
The argument A can be a number or an interval [a,b], specifying the interested solution
region. If it is a number, the interested region is (−A/2, A/2), and the default value of
A = 1000, usually meaning to search solutions in large region. If the argument A contains
imaginary part, the variables of A or a, b pair specify the range of solutions, and complex
solutions are also expected. The default value of the argument ϵ is eps. The default value
of the argument tlim is 30, meaning if within 30 seconds there is no new solution found, the
function is terminated normally. The user may also terminate the function at any time, by
pressing the Ctrl-C keys.
Compared with other functions, this function is very special, since inﬁnite loop is used.
It may be terminated at any time by the user by pressing the Ctrl-C keys, it is not suitable
to assign returned arguments. Function assignin() is used in the loop, so that each time
a new solution is found, the variables X and err in MATLAB workspace are updated. The
variable X is a three-dimensional array, with X(:,:,i) storing the ith solution found, and
variable err stores the maximum norm of errors so far found.
If the function is terminated, and the user wants to resume the function, the argument
X in MATLAB workspace can be used as the initial X0 in the function call. For instance,
more sols(f,X) can be used to resume.
Example 6.12
Solve again the Riccati equation in Example 4.62, where the matrices are
given below
A =
⎡
⎣
−2
1
−3
−1
0
−2
0
−1
−2
⎤
⎦, B =
⎡
⎣
2
2
−2
−1
5
−2
−1
1
2
⎤
⎦,
C =
⎡
⎣
5
−4
4
1
0
4
1
−1
5
⎤
⎦.
Solution
To ﬁnd all the real solutions, the Riccati equation should be described as an
anonymous function, and more sols() function can be used, in the statement, the initial
matrix X0 is set to an empty 3 × 3 × 0 array, with the ﬁrst two 3’s indicating the size of
the solution matrix.
>> A=[-2,1,-3; -1,0,-2; 0,-1,-2]; B=[2,2,-2; -1 5 -2; -1 1 2];
C=[5 -4 4; 1 0 4; 1 -1 5]; f=@(X)A’*X+X*A-X*B*X+C;
more_sols(f,zeros(3,3,0)); X, err % ﬁnd all the real solutions
If this function is left running, after some time, it can be terminated normally, and the
maximum error norm is 1.4904×10−12, and all the 8 real matrix solutions can be found
X1 =
⎡
⎣
0.9874
−0.7983
0.4189
0.5774
−0.1308
0.5775
−0.2840
−0.0730
0.6924
⎤
⎦, X2 =
⎡
⎣
1.2213
−0.4165
1.9775
0.3578
−0.4894
−0.8863
−0.7414
−0.8197
−2.3560
⎤
⎦,
X3 =
⎡
⎣
0.6665
−1.3223
−1.7200
0.3120
−0.5640
−1.1910
−1.2273
−1.6129
−5.5939
⎤
⎦, X4 =
⎡
⎣
−2.1032
1.2978
−1.9697
−0.2467
−0.3563
−1.4899
−2.1494
0.7190
−4.5465
⎤
⎦,

Nonlinear Equations and Numerical Optimization Problems
243
X5 =
⎡
⎣
−0.1538
0.1087
0.4623
2.0277
−1.7437
1.3475
1.9003
−1.7513
0.5057
⎤
⎦, X6 =
⎡
⎣
0.8878
−0.9609
−0.2446
0.1072
−0.8984
−2.5563
−0.0185
0.3604
2.4620
⎤
⎦,
X7 =
⎡
⎣
23.9467
−20.6673
2.4529
30.1460
−25.9830
3.6699
51.9666
−44.9108
4.6410
⎤
⎦, X8 =
⎡
⎣
−0.7619
1.3312
−0.8400
1.3183
−0.3173
−0.1719
0.6371
0.7885
−2.1996
⎤
⎦.
If complex solutions are also expected, the following commands should be speciﬁed, and
altogether 20 real and complex solutions can be found
>> more_sols(f,X,1000+1000i); X, err % ﬁnd all the complex solutions
Example 6.13
Now consider the new Riccati-like equation given in (6-2-2), where
A =
⎡
⎣
2
1
9
9
7
9
6
5
3
⎤
⎦, B =
⎡
⎣
0
3
6
8
2
0
8
2
8
⎤
⎦, C =
⎡
⎣
7
0
3
5
6
4
1
4
4
⎤
⎦, D =
⎡
⎣
3
9
5
1
2
9
3
3
0
⎤
⎦.
Find and verify all the possible solutions.
Solution To date, there are no other existing algorithms for solving such types of equations.
With the function more sols(), and selecting the default search region, all the 16 solutions
can be found, and the function call may terminate normally, with maximum error norm of
1.5504 × 10−10.
>> A=[2 1 9; 9 7 9; 6 5 3]; B=[0 3 6; 8 2 0; 8 2 8];
C=[7 0 3; 5 6 4; 1 4 4]; D=[3 9 5; 1 2 9; 3 3 0];
f=@(X)A*X+X*D-X*B*X.’+C; more_sols(f,zeros(3,3,0)); X, err
If complex solutions are also allowed, the following commands can be issued, and all the
38 solutions can eventually be found.
>> more_sols(f,X,1000+1000i); X, err % ﬁnd all the complex solutions
Example 6.14
Consider again the nonlinear simultaneous equations in Example 6.2.
Please ﬁnd all the numerical solutions within the range of −2π ⩽x, y ⩽2π.
⎧
⎨
⎩
x2e−xy2/2 + e−x/2 sin(xy) = 0
y2 cos(y + x2) + x2ex+y = 0.
Solution
In Example 6.2, the graphical method was used, and many intersections were
witnessed in the interested area. If the graphical method is to be used to ﬁnd all the interested
solutions, it might be a time-consuming task, since each time, only one solution can be
found by the zooming facilities. Furthermore, the accuracy of the solutions found by the
graphical method is extremely low. The new more sols() function can be used instead to ﬁnd
numerically all the solutions in the interested area. Since the interested area is (−2π, 2π),
we can set A = [−2*pi,2*pi]. Also, since [0, 0] is one solution of the equation, it can be
used as the starting point in the solution process. The following statements can be used to
describe the equations with anonymous function, then, the solution function can be called.
It can be seen that the maximum error norm is 1.8829×10−13.
>> f=@(x)[x(1)^2*exp(-x(1)*x(2)^2/2)+exp(-x(1)/2)*sin(x(1)*x(2));
x(2)^2*cos(x(2)+x(1)^2)+x(1)^2*exp(x(1)+x(2))];
more_sols(f,[0; 0],[-2*pi,2*pi]); err

244
Scientiﬁc Computing with MATLAB®
All the solutions obtained are marked on top of the graphical solutions, as shown in
Figure 6.5. It can be seen that all the real solutions in this area are found, and the accuracy
is much higher than the graphical solutions.
−6
−4
−2
0
2
4
6
−6
−4
−2
0
2
4
6
FIGURE 6.5: All the solutions of the nonlinear simultaneous equations.
>> h1=ezplot(’x^2*exp(-x*y^2/2)+exp(-x/2)*sin(x*y)=0’);
hold on; h2=ezplot(’y^2*cos(y+x^2)+x^2*exp(x+y)=0’);
x=X(1,1,:); x=x(:); y=X(2,1,:); y=y(:); plot(x,y,’o’)
set(h1,’Color’,’b’); set(h2,’Color’,’r’)
It is worth mentioning that, some of the solutions thus searched are not in the interested
area. We can exclude those solutions with the following statements, and ﬁnally it can be
found that there are 41 solutions located in the interested area.
>> ii=find(abs(X(1,1,:))<=2*pi & abs(X(2,1,:))<=2*pi);
X_sol=X(:,:,ii); size(ii) % ﬁnd and count the roots in the area
Example 6.15
Consider the simultaneous equations sin(x −y) = 0 and cos(x + y) = 0.
Please ﬁnd all the real solutions for 0 ⩽x, y ⩽4π.
Solution Graphical approach can be used ﬁrst, and the distribution of the solutions in the
interested area, as depicted as shown in Figure 6.6(a).
>> h1=ezplot(’sin(x-y)’,[0,4*pi]); set(h1,’Color’,’b’); hold on
h2=ezplot(’cos(x+y)’,[0,4*pi]); set(h2,’Color’,’r’);
The original equations can be described by anonymous function, and select the interested
area A = [0,4*pi]. With the more sols() function, all the solutions in the area can be
obtained, as shown in Figure 6.6(b). It can be seen that all the real solutions in the interested
area are found.
>> f=@(x)[sin(x(1)-x(2)); cos(x(1)+x(2))];
% describe the equations
more_sols(f,zeros(2,1,0),[0,4*pi]);
% ﬁnd the solutions in (0, 4π) area
x=X(1,1,:); y=X(2,1,:); plot(x(:),y(:),’o’) % draw the solutions
Example 6.16
Solve the fractional-order polynomial equation
x2.3 + 5x1.6 + 6x1.3 −5x0.4 + 7 = 0.
Solution An “obvious” way is to introduce z = x0.1, and the original equation is mapped

Nonlinear Equations and Numerical Optimization Problems
245
0
2
4
6
8
10
12
0
2
4
6
8
10
12
(a) graphical method
0
2
4
6
8
10
12
0
2
4
6
8
10
12
(b) all the solutions
FIGURE 6.6: All the solutions in the interested area.
into an ordinary polynomial equation of z, with 23 solutions. It seems that x = z10 are the
solutions of the original equation, and the idea can be implemented in MATLAB
>> syms x z; f1=z^23+5*z^16+6*z^13-5*z^4+7; p=sym2poly(f1); r=roots(p);
f=x^2.3+5*x^1.6+6*x^1.3-5*x^0.4+7; r1=r.^10, double(subs(f,x,r1))
Unfortunately, most of the “solutions” thus obtained do not satisfy the original equation.
How many solutions are there in the original equation? This question can be answered with
the following statements, and believe it or not, there are only two solutions in the equation
x = −0.1076 ± j0.5562. The remaining 21 solutions are extraneous roots.
>> f=@(x)x.^2.3+5*x.^1.6+6*x.^1.3-5*x.^0.4+7;
more_sols(f,zeros(1,1,0),100+100i), x0=X(:)
6.2.2
Finding high-precision solutions
In fact, vpasolve() function can be used to solve more accurately nonlinear solutions
as well, with the user-selected initial search points.
[x,y,· · · ] = vpasolve([eqn1,eqn2,· · · ,eqnn],[x,y,· · ·],[x0,y0,· · · ])
Note that, the equations must be speciﬁed in symbolic expressions, or alternatively, ==
can be used for equal sign in equations, and when omitted, it means = 0. Variable list
[x,y,· · · ] can be omitted, and retrieved with symvar() automatically. Initial search point
is allowed to be assigned in [x0,y0,· · · ]. More than that, for polynomial types of equations,
all the high-precision solutions can also be found.
Example 6.17
Consider again the Riccati equation in Example 4.62. Try to ﬁnd all the
high-precision solutions with vpasolve().
Solution The function vpasolve() can be tried, and a total of 20 solutions can be found,
with 8 of them real solutions. The solutions are the same as the ones obtained in Example
6.12, but with much higher precision.
>> A=[-2,1,-3; -1,0,-2; 0,-1,-2]; B=[2,2,-2; -1 5 -2; -1 1 2];
C=[5 -4 4; 1 0 4; 1 -1 5]; X=sym(’x%d%d’,3);
F=A’*X+X*A-X*B*X+C; Y=vpasolve(F) % ﬁnd all the solutions of Riccati equation

246
Scientiﬁc Computing with MATLAB®
The returned variable Y is a structured variable, and the solutions can be converted to
cells, and then, can be rearranged in a matrix with the following statements
>> Z=struct2cell(Y); [n,m]=size(Z); V=[]; for i=1:n, V=[V Z{i}]; end
In this case, each row in matrix V is a solution. Now let us validate the 5th solution.
It can be seen that when the 5th solution is substituted back into the original equation, the
norm of the error matrix is 6.2×10−38, which is far beyond the capabilities of any numerical
algorithms under double-precision scheme.
>> x=V(5,:); X0=reshape(x,3,3).’; norm(subs(F,X,X0)) % the 5th solution
For the problem in Example 6.13, since XT is involved, a tremendous amount of time
is needed, and all the 38 solutions in high-precision scheme can be found.
Example 6.18 Revisit the nonlinear equations in Example 6.2. Now, consider solving the
equations with vpasolve() function. If initial search point is not speciﬁed, only one solution
can be found, at x = y = 0.
>> syms x y;
F=[x^2*exp(-x*y^2/2)+exp(-x/2)*sin(x*y),y^2*cos(y+x^2)+x^2*exp(x+y)];
[x0,y0]=vpasolve(F) % try to solve the equation
In the function more sols(), MATLAB function fsolve() is used as the kernel.
Similarly, vpasolve() can also be used as the kernel, for ﬁnding high-precision solutions of
nonlinear equations. A new solver can be written
function more_vpasols(f,X0,varargin)
[A,tlim]=default_vals({1000,60},varargin{:}); X=X0;
if length(A)==1, a=-0.5*A; b=0.5*A; else, a=A(1); b=A(2); end
ar=real(a); br=real(b); ai=imag(a); bi=imag(b); [i,n]=size(X0); tic
while (1),
x0=ar+(br-ar)*rand(1,n);
if abs(imag(A))>1e-5, x0=x0+(ai+(bi-ai)*rand(1,n))*1i; end
V=vpasolve(f,x0); N=size(X,1); key=1;
if length(V)==0, continue, else, x=sol2vec(V); end
t=toc; if t>tlim, break; end
for j=1:N, if norm(X(j,:)-x)<1e-5; key=0; break; end, end
if key>0, i=i+1;
X=[X; x]; disp([’i=’,int2str(i)]); assignin(’base’,’X’,X); tic
end, end, end
function v=sol2vec(A)
v=[]; A=struct2cell(A); for i=1:length(A), v=[v, A{i}]; end
The syntax of the function is more vpasols(f,X0,A,tlim), with a low-level supporting
function sol2vec() embedded in the same ﬁle.
The argument f should be speciﬁed as a symbolic row vector in describing the
simultaneous equations, and the initial X0 should be assigned to zeros(0,n), with n the
number of unknowns. The other arguments are the same as the ones on more sols(),
discussed earlier. The returned argument X(i,:) storing the ith solution found. It is worth
mentioning that the speed of more vdpsols() is much slower than that of more sols().

Nonlinear Equations and Numerical Optimization Problems
247
Example 6.19
Consider the simultaneous equations in Example 6.14. Find all the
solutions in the interval −2π < x, y < 2π under high-precision scheme.
Solution The following commands can be used directly and all the solutions in the interested
area can be found with the following statements
>> syms x y; % ﬁnding all the high-precision solutions
F=[x^2*exp(-x*y^2/2)+exp(-x/2)*sin(x*y),y^2*cos(y+x^2)+x^2*exp(x+y)];
more_vpasols(F,zeros(0,2),4*pi)
To check the accuracy of one of the solutions, the solutions of x0 and y0 in the interested
area can be extracted and sorted ﬁrst. The following statements can be used, and the norm
of the errors is 7.79×10−32, the accuracy is much higher than the ones obtained in Example
6.14. It took about nearly half an hour, much longer than with more sols() function, to
ﬁnd all the 41 solutions.
>> x0=X(:,1); y0=X(:,2); ii=find(abs(x0)<2*pi & abs(y0)<2*pi);
x0=x0(ii); y0=y0(ii); [x0 ii]=sort(x0); y0=y0(ii);
double(norm(subs(F,{x,y},{x0,y0}))), size(x0)
ezplot(F(1)), hold on, ezplot(F(2)), plot(x0,y0,’o’)
6.2.3
Solutions of underdetermined equations
Algebraic equations are referred to as underdetermined, if there are fewer equations than
the number of unknowns. The implicit equation f(x, y) = 0 discussed earlier is an example
of underdetermined equation, and it has been shown that all the points on the curves drawn
with ezplot() are the solutions of the implicit equation. In this section, a further example
is given to show the possible solutions of typical underdetermined equations.
Example 6.20
Please solve the following underdetermined equations
⎧
⎨
⎩
x2ze−xy2z2/2 + e−x/2z2 sin(xy) = 0
y2 cos(y + x2) + x2ex+yz = 0.
Solution
Since there are two equations, with three unknowns x, y and z, the original
equations are underdetermined. One may ﬁrst ﬁx the value of z, and ﬁnd all the solutions
of x and y, with more sols() function. Then, ﬁx another value of z and perform the same
process again. In this way, the possible solutions of the original equations can be found.
This process is quite time-consuming, however, it may be valuable in solving such kind of
equations. The solutions for the ith value of z can also be retrieved with A{i} and B{i}.
The points of the solutions are shown in Figure 6.7 (a).
>> z0=0.1:0.1:1;
for i=1:length(z0), z=z0(i);
f=@(x)[x(1)^2*z*exp(-x(1)*x(2)^2*z^2/2)+exp(-x(1)/2)*z^2*sin(x(1)*x(2));
x(2)^2*cos(x(2)+x(1)^2)+x(1)^2*exp(x(1)+x(2))*z];
more_sols(f,zeros(2,1,0),[-2*pi,2*pi]); x=X(1,1,:); y=X(2,1,:);
A{i}=x(:); B{i}=y(:); plot3(x(:),y(:),z*ones(size(x(:))),’o’), hold on
end
axis([-2*pi, 2*pi, -2*pi, 2*pi, 0,1])

248
Scientiﬁc Computing with MATLAB®
>> for i=1:length(z0), z=z0(i);
[x,ii]=sort(A{i}); y=B{i}(ii); zz=z*ones(size(x));
plot3(x,y,zz,x,y,zz,’o’), hold on
end
−5
0
5
−5
0
5
0
0.2
0.4
0.6
0.8
1
(a) samples of the solutions
(b) intersections of surfaces
FIGURE 6.7: Solutions of underdetermined equations.
Alternatively, the original equations can be solved graphically with ezimplot3()
function, and the results are shown in Figure 6.7 (b), the intersection curves of the two
sets of surfaces are the solutions of the equations.
>> f1=@(x,y,z)x^2*z*exp(-x*y^2*z^2/2)+exp(-x/2)*z^2*sin(x*y);
f2=@(x,y,z)x^2*cos(y+x^2)+x^2*exp(x+y)*z;
ezimplot3(f1,[-2*pi,2*pi,-2*pi,2*pi,0,1])
ezimplot3(f2,[-2*pi,2*pi,-2*pi,2*pi,0,1])
6.3
Unconstrained Optimization Problems
Unconstrained optimization problems are considered as simpler than constrained
optimization problems. The mathematical description of unconstrained problems is that
min
x f(x),
(6-3-1)
where x = [x1, x2, · · · , xn]T are referred to as decision variables, or optimization variables,
and scalar function f(·) is referred to as the objective function. The task is to ﬁnd a
vector x such that the value of the objective function f(x) is minimized. Thus, the
optimization problem is also referred to as the minimization problem. In fact, the deﬁnition
of minimization problem may not lose the generality. For instance, the maximization
problem can be converted to minimization problem by multiplying −1 to its objective
function. Therefore, the optimization problems studied in this book are for minimization
problems.

Nonlinear Equations and Numerical Optimization Problems
249
6.3.1
Analytical solutions and graphical solution methods
It is known from advanced mathematics courses that the necessary conditions for an
unconstrained optimization problem are that at the optimum point x∗, the ﬁrst-order
derivatives of the objective function are all 0’s. Thus, the following simultaneous equations
can be established
∂f
∂x1
""""
x=x∗
= 0,
∂f
∂x2
""""
x=x∗
= 0, · · · ,
∂f
∂xn
""""
x=x∗
= 0.
(6-3-2)
Solving the above equations, the extremum points can be obtained. In fact, the extremum
points obtained may not be all minimum points, some of the points may actually be
maximum points. Minimum points can be judged by taking the second-order derivatives,
where positive second-order derivative means that minimum points are obtained. For
univariate functions, the analytical method can be considered. However, for multivariate
problems, solving the equations derived may be even more diﬃcult than solving the
optimization problem itself.
The graphical solutions to optimization problems with one variable are quite straight-
forward. The derivative function can be drawn ﬁrst and the minimum points can be
read from the curves. Functions with two variables may also be solved using graphical
methods. However, for problems with three or more variables, graphical methods may not
be applicable.
Example 6.21 From the equation f(t) = e−3t sin(4t + 2) + 4e−0.5t cos(2t) −0.5 studied in
Example 6.1, use graphical and analytical methods to study the optimality of the function.
Solution The ﬁrst-order derivative of the objective function can be derived ﬁrst and with
the function ezplot(), the ﬁrst-order derivative can be drawn over the interval t ∈[0, 4] as
shown in Figure 6.8 (a).
>> syms t; y=exp(-3*t)*sin(4*t+2)+4*exp(-0.5*t)*cos(2*t)-0.5;
y1=diff(y,t); ezplot(y1,[0,4]) % ﬁnd intersection of derivative with x-axis
In fact, ﬁnding the solution points of y1(t) = 0 is not easier than the direct ﬁnding of
optimum points. With the graphical method, two points A1 and A2 can be found. From the
ﬁrst-order derivative, it can be seen that the point A1 has a positive second-order derivative,
thus, it corresponds to the minimum point, while for point A2, a negative second-order
derivative corresponds to the maximum point. The value of A1 can be obtained using the
following statements
>> t0=vpasolve(y1), ezplot(y,[0,4]) % draw the ﬁrst-order derivative
y2=diff(y1); y0=subs(y2,t,t0)
% verify positive 2nd-order derivative
where t0 = 1.4528424981725411893375778, and y0 = 7.85534202533336013794644, which
means that the point has a positive second-order derivative. Therefore, the minimum point
has been obtained. It can further be conﬁrmed from Figure 6.8 (b) that A1 is the minimum
point, and A2 is the maximum point.
Since the original problem is a nonlinear function, analytical solutions may not be
obtained. Note that the solution to the ﬁrst-order derivative equation is not easier than the
direct solution to the unconstrained optimization problem. For practical applications rather
than demonstrations, such a graphical method is not recommended. Direct solutions to the
optimization problems are recommended instead.

250
Scientiﬁc Computing with MATLAB®
0
0.5
1
1.5
2
2.5
3
3.5
4
−8
−6
−4
−2
0
2
A1
A2
(a) ﬁrst-order derivative
0
0.5
1
1.5
2
2.5
3
3.5
4
−2
−1
0
1
2
3
4
A1
A2
(b) objective function
FIGURE 6.8: Minimum solution using graphical method.
6.3.2
Solution of unconstrained optimization using MATLAB
An unconstrained optimization problem solver, fminsearch(), is provided in MATLAB.
Moreover, a similar function fminunc() is also provided in the Optimization Toolbox. Both
functions have the same syntaxes. For instance,
x = fminunc(fun,x0)
% simplest call
[x,f,flag,out]= fminunc(fun,x0,opt,p1,p2,· · · )
% more general form
where the input and output arguments are very similar to the fsolve() function described
earlier. The control options are also the same. Furthermore, the whole optimization problem
can be described with a structured variable problem, and the problem can be solved with
x = fminunc(problem).
The improved simplex algorithm in Reference [5] is used to solve the optimization
problem. This method is an eﬀective one in solving unconstrained optimization problems.
The following examples will be given for illustrations.
Example 6.22
For a function with two variables given by z = (x2 −2x)e−x2−y2−xy, ﬁnd
the minimum with MATLAB functions, and interpret the solutions graphically.
Solution
The surface of the function was studied in Chapter 2, and the target of
minimization is to ﬁnd the values of x and y where the surface is at its valley.
The variables in the objective function are x, y, not the same as in the standard
unconstrained optimization deﬁnition. A vector x should be deﬁned by the variable
substitutions such that x1
= x, and x2
= y. Thus, the objective function can be
rewritten as f(x) = (x2
1 −2x1)e−x2
1−x2
2−x1x2. Describing it with the anonymous function,
the following statements can be used to ﬁnd the optimal solution, and the solution is
x = [0.6110, −0.3056]T.
>> f=@(x)(x(1)^2-2*x(1))*exp(-x(1)^2-x(2)^2-x(1)*x(2));
x0=[2; 1]; x=fminsearch(f,x0) % minimization from an initial point
Similarly, the same problem can be solved with the fminunc() function, where
>> x=fminunc(f,x0) % a more eﬀective function with the same syntax

Nonlinear Equations and Numerical Optimization Problems
251
and the solution obtained is x = [0.6110, −0.3055]T.
Normally, the number of the objective function calls in the fminunc() function is
much less than the fminsearch() function, since a more eﬀective algorithm is used in
fminunc(). Therefore, if one installs the Optimization Toolbox, it is suggested that the
function fminunc() be used for unconstrained optimization problems.
To illustrate and monitor the solution process graphically, an output function can be
written in the following format
function stop=myout(x,optimValues,state), stop=false;
switch state % monitoring intermediate results
case ’init’, hold on
% preparation
case ’iter’, plot(x(1),x(2),’o’), % display intermediate results
text(x(1)+0.1,x(2),int2str(optimValues.iteration));
case ’done’, hold off % ﬁnishing up display process
end
In the function, at each iteration, the intermediate point found is marked and numbered.
To monitor the optimization process, the OutputFcn option must be set to @myout.
To demonstrate the optimization process, the contour plot of the objective function can
be drawn ﬁrst. If x0 = [2, 1]T is used as the initial search point, the following statements
can be used to monitor the searching process, the search trajectory can be superimposed on
the contours of the given function using the following statements, as shown in Figure 6.9,
where the overlapped numbers mean that at the points, the searching step-size is very small,
and the points found are close to each other.
>> [x,y]=meshgrid(-3:.1:3, -2:.1:2); % draw contour and search trajectory
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y); contour(x,y,z,30);
ff=optimset; ff.OutputFcn=@myout; x0=[2 1]; x=fminunc(f,x0,ff)
0
12
3
4567
−3
−2
−1
0
1
2
3
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
FIGURE 6.9: Search trajectory.
With Optimization Toolbox of MATLAB, structured variable can be used to describe
optimization problems, which makes the solution process more standardized. All the ﬁelds,
objective, x0, solver and options, are essential ﬁelds in the function. A structured
variable P can be created, with its ﬁeld P.objective to describe objective function, and
its ﬁeld P.x0 to describe initial search point. The other two ﬁelds can usually be set to

252
Scientiﬁc Computing with MATLAB®
P.options= optimset, P.solver= ’fminunc’.
Then, the variable P can be used to describe the optimization problem. Function
[x,fm,flag]= fminunc(P) can be used to solve directly the unconstrained optimization
problems.
Example 6.23
Please solve again the unconstrained optimization problem in Example
6.22, with the use of structured variables.
Solution
The structured variable P describing the whole optimization problem can be
established with the following statements. Then, the function fminunc() can be used directly
in solving the optimization problem, and the result is exactly the same as the one obtained
in Example 6.22. Please note that in the ﬁrst sentence, make sure the variable P is cleared
from MATLAB workspace before use. Also, the options ﬁeld in P must be assigned. The
four ﬁelds are essential for fminunc().
>> clear P; P.solver=’fminunc’; P.options=optimset;
P.objective=@(x)(x(1)^2-2*x(1))*exp(-x(1)^2-x(2)^2-x(1)*x(2));
P.x0=[2; 1]; [x,b,c,d]=fminunc(P) %
the 4 ﬁelds are essential
6.3.3
Global minimum and local minima
According to multivariable calculus, the necessary condition for a minimum point to
exist is that df(x)/ dx = 0. However, the points satisfying such a condition may not be
unique, and in many real applications, there might be many such points. If a search method
is used, only one such point at a time can be found from a given initial point, and this point
may not be the global minimum point. The concepts of global minimum and local minima
are illustrated through the following example.
Example 6.24
Consider the minimization problem of Rastrigin function [6]
f(x1, x2) = 20 + x2
1 + x2
2 −10(cosπx1 + cos πx2).
Draw the surface of the objective function, and try to ﬁnd the optimal solution with
simple searching algorithm, and see what may happen.
Solution
The surface of the function can be immediately obtained with the following
statements, as shown in Figure 6.10 (a). It can be seen that the surface changes irregularly,
and there are a great amount of peaks and valleys.
>> ezsurf(’20+x1^2+x2^2-10*(cos(pi*x1)+cos(pi*x2))’)
The planform view of the surface can be obtained as shown in Figure 6.10 (b). It can
be distinguished by the colors that the valley in the center is the global minimum, and the
rest of the valleys are local minima. Furthermore, the four neighbors of the global minimum
point can be regarded as suboptimal local minima.
>> view(0,90), shading flat
A few initial points are selected, and optimizations can be performed from these initial
points
>> f=@(x)20+x(1)^2+x(2)^2-10*(cos(pi*x(1))+cos(pi*x(2)));
x1=fminunc(f,[2,3]), f(x1), x2=fminunc(f,[-1,2]), f(x2)
x3=fminunc(f,[8 2]), f(x3), x4=fminunc(f,[-4,6]), f(x4)

Nonlinear Equations and Numerical Optimization Problems
253
−5
0
5
−5
0
5
0
20
40
60
80
(a) 3D view
−6
−4
−2
0
2
4
6
−6
−4
−2
0
2
4
6
(b) planform view
FIGURE 6.10: Surface of Rastrigin function.
and the solutions are
x1 = [1.9602, 1.9602], f(x1) = 7.8409,
x2 = [−0.0000, 1.9602], f(x2) = 3.9205,
x3 = [7.8338, 1.9602], f(x3) = 66.6213, x4 = [−3.9197, 5.8779], f(x4) = 50.9570.
It can be seen from the optimization results that the “optimal” objective functions have
signiﬁcant diﬀerences. Most of them, if not all, are local minima. If the initial values are
not set properly, it is very likely to ﬁnd a local minima.
It can be seen from the above example that sometimes the solution obtained directly from
the function calls may be a local minimum, rather than global minimum. Thus, diﬀerent
initial conditions should be tested to possibly improve the solutions. Genetic algorithm-
based optimization techniques can signiﬁcantly improve the globalness of the minima,
since many initial conditions are tested simultaneously. However, even genetic algorithm-
based algorithms cannot guarantee the global solution. In Section 10.4, introductions
and application illustrations will be given on genetic algorithms and other evolutionary
optimization approaches.
An alternative method is proposed here, aiming at ﬁnding the global optimal solution
of such an objective function.
Require: Objective function f(x), interval (a, b), number of decision variables n, number
of runs N
Initialization: Assign f0 = ∞
for i = 1 To N do
Randomly generate an x0, and ﬁnd a solution x and f1 = f(x)
if f1 < f0 then
Store x, and let f0 = f1
end if
end for
A MATLAB function can be written based on the algorithm.
function [x,f0]=fminunc_global(f,a,b,n,N,varargin)
k0=0; f0=Inf; if strcmp(class(f),’struct’), k0=1; end

254
Scientiﬁc Computing with MATLAB®
for i=1:N, x0=a+(b-a)*rand(n,1);
if k0==1, f.x0=x0; [x1 f1 key]=fminunc(f);
else, [x1 f1 key]=fminunc(f,x0,varargin{:}); end
if key>0 & f1<f0, x=x1; f0=f1; end
end
The syntax of the function is [x,fmin] = fminunc global(fun,a,b,n,N), where fun is
the MATLAB description of the objective function, implemented either as an anonymous
function, or an M-function, and it can also be the structured variable for the entire
optimization problem. When the number of N is properly selected, the returned arguments
x and fmin are quite likely the global solution of the problem.
Example 6.25 Consider again the optimization problem in Example 6.24. The number of
loops N can be set to 50, it can be seen that global minimum at x1 = x2 = 0 can be found.
>> f=@(x)20+x(1)^2+x(2)^2-10*(cos(pi*x(1))+cos(pi*x(2))); F=[];
[x,f0]=fminunc_global(f,-2*pi,2*pi,2,50); % try to ﬁnd global solution
To further validate the new global optimization problem solver, we can call the function
100 times. It is found that each time, the function is successful in ﬁnding the global optimum.
>> F=[];
for i=1:100, % try the function 100 times and assess successful rate
[x,f0]=fminunc_global(f,-2*pi,2*pi,2,50); F=[F,f0];
end
Of course, the global optimal point is x1 = x2 = 0, and uniformly distributed random
numbers in each run is quite likely to have an initial point near (0, 0), so that global optimal
solution can be found each time. Therefore, it is unfair to compare this method with other
ones through such an example.
Example 6.26
Now suppose the original Rastrigin function is modiﬁed as
f(x1, x2) = 20 + (x1/30−1)2 + (x2/20−1)2 −10[cos(x1/30−1)π + cos(x2/20−1)π],
run the global search function 100 times, and see the successful rate in ﬁnding the global
optimal solutions.
Solution If the searching area is extended to ±100, the following statements can be tested
>> f=@(x)20+(x(1)/30-1)^2+(x(2)/20-1)^2-10*(cos(pi*(x(1)/30-1))+...
cos(pi*(x(2)/20-1))); F=[]; tic
for i=1:100 % try to solve the new problem 100 times
[x,f0]=fminunc_global(f,-100,100,2,50); F=[F,f0];
end, toc
It can be seen that in the 100 runs of the solver, only 3 times failed to ﬁnd the
global optimal point at (30, 20), the rest are successful. The unsuccessful 3 times all
stopped at the neighbors of the global optimum, and, in fact, they can be regarded as the
suboptimal solutions. Therefore, this method can be considered reliable and trustworthy.
If the fminunc global() function is executed alone, it is quite likely to ﬁnd the global
optimum.
>> [x,f0]=fminunc_global(f,-100,100,2,50) % try to ﬁnd global solution

Nonlinear Equations and Numerical Optimization Problems
255
6.3.4
Solving optimization problems with gradient information
Sometimes, the convergence speed for solving optimization problems may be very low,
and the exact optimum may not even be obtained using the information provided in
the objective function alone. Thus, the gradient information can be used to improve the
optimization process.
In some functions of the Optimization Toolbox, the gradient information can also be
provided in the MATLAB function describing the objective function. In this case, two
arguments are returned with the ﬁrst one still describing the objective function, and the
second one for the gradients. Furthermore, in this case, the GradObj, a ﬁeld in the control
options, should be set to ’on’. The optimization solver can then be used to solve the
optimization problems with the gradient information. Anonymous functions are no longer
usable, since only one returned variable is allowed.
Example 6.27
Consider the Rosenbrock function
f(x1, x2) = 100(x2 −x2
1)2 + (1 −x1)2.
Solve the unconstrained minimization problem for the function.
Solution It can be seen that the objective function is made of two squared terms. Thus,
when x2 = x1 = 1, the objective function takes its global minimum. Three-dimensional
contours of the function can be drawn as shown in Figure 6.11.
>> [x,y]=meshgrid(0.5:0.01:1.5); z=100*(y.^2-x).^2+(1-x).^2;
contour3(x,y,z,100), zlim([0,310]) % draw 3D contour of objective func
0.5
1
1.5
0.5
1
1.5
0
100
200
300
FIGURE 6.11: Three-dimensional contours for the Rosenbrock function.
From the contours, the minimum is located in a very ﬂat and narrow valley. Thus,
Rosenbrock function is also known as the banana function. In the valley, the change of
the objective function is extremely slow, therefore, it is a very challenging problem to
optimization algorithms. This function is often used as a benchmark problem to test whether
an optimization algorithm is good or not. The following statements can be used to solve the
optimization problem without the gradient information.
>> f=@(x)100*(x(2)-x(1)^2)^2+(1-x(1))^2;
ff=optimset; ff.TolX=1e-10; ff.TolFun=1e-20; x=fminunc(f,[0;0],ff)
The best solution obtained is x1 = 0.9999956, and x2 = 0.9999912. It can be seen that

256
Scientiﬁc Computing with MATLAB®
although very tough error tolerances are used, the exact minimum still cannot be obtained.
A warning is also given, expecting the gradient information.
For the given Rosenbrock function, the gradient vector can easily be obtained by
>> syms x1 x2; f=100*(x2-x1^2)^2+(1-x1)^2;
J=jacobian(f,[x1,x2]) % ﬁnd analytically the gradients
and the Jacobian matrix is J = [−400(x2 −x2
1)x1 −2 + 2x1, 200x2 −200x2
1]. Therefore, the
gradient matrix J can be described in the objective function, and it is rewritten as
function [y,Gy]=c6fun3(x)
y=100*(x(2)-x(1)^2)^2+(1-x(1))^2;
Gy=[-400*(x(2)-x(1)^2)*x(1)-2+2*x(1); 200*x(2)-200*x(1)^2];
It should be noted that since two returned arguments are expected in the function, neither
inline function nor anonymous function can be used to describe the new objective function.
M-function is the only choice in describing the gradients. The following statements can be
used to solve the optimization problem:
>> ff.GradObj=’on’; x=fminunc(@c6fun3,[0;0],ff) % use gradient information
and the solution found is x = [1.000000000000018, 1.000000000000036]T. It can be seen
that with the gradient information, the optimization is signiﬁcantly speeded up, and the
accuracy is also signiﬁcantly improved, which approaches the analytical values. Such an
accuracy cannot be obtained without specifying the gradient information. However, in some
other applications, the derivation and programming of gradient information could be very
diﬃcult, if not impossible, and one has to directly solve the optimization problem without
the gradient information. The global solver fminunc global() can also be used to replace
fminunc() function, and a much more accurate solution can normally be found.
>> x=fminunc_global(@c6fun3,-10,10,2,50,ff) % global solver with gradients
Structured variable can also be used in describing the optimization problem, and the
following statements yield the same result.
>> clear P; P.solver=’fminunc’; ff=optimset; P.objective=@c6fun3;
ff.GradObj=’on’; ff.TolX=1e-20; ff.TolFun=1e-20; P.options=ff;
P.x0=[2; 1]; [x,b,c,d]=fminunc(P) % structured variable description
If fminunc global() is used, a more accurate solution can be found, and the cost is,
the elapsed time may be increased by 100 times, around 45 seconds.
>> tic, [x1,b]=fminunc_global(P,-10,10,2,100), toc
It is worth mentioning that, Rosenbrock function was deliberately designed to examine
the eﬀectiveness of the optimization algorithms, and it is an artiﬁcial function. In practical
applications, gradient information is not needed in a great amount of optimization
algorithms, and optimization problems can equally be solved successfully.

Nonlinear Equations and Numerical Optimization Problems
257
6.4
Constrained Optimization Problems
A general description to constrained optimization problems is
min
x s.t. G(x)⩽0
f(x),
(6-4-1)
where x = [x1, x2, · · · , xn]T. The interpretation of such a description is that, under the
constraints G(x) ⩽0, a decision vector x is expected which minimizes the objective function
f(x). In practical optimization problems, the constraints could be very complicated. For
instance, it can be equalities or inequalities, and it can also be linear or nonlinear.
Sometimes, these functions may not easily be described by mathematical functions.
6.4.1
Constraints and feasibility regions
The solution area x satisfying all the constraints G(x) ⩽0 is referred to as the feasible
region. A function of two variables will be given below, and the feasible regions will be
illustrated graphically.
Example 6.28 Consider the optimization problem with two variables given below. Study
the optimization problem using the graphical method.
max
x s.t.
⎧
⎨
⎩
9⩾x2
1+x2
2
x1+x2⩽1
−x2
1 −x2.
Solution From the given constraints, the initial square region [−3, 3] can be selected and
mesh grids can be made. Then, the objective function for unconstraint problems can be
obtained using the following statements.
>> [x1,x2]=meshgrid(-3:.1:3);
% grid data generation
z=-x1.^2-x2;
% calculate objective function over the grids
When the constraints are introduced, one may remove the points outside the feasible
region from the three-dimensional surface by setting the values to NaN, and the solutions can
then be found graphically using the following statements.
>> i=find(x1.^2+x2.^2>9); z(i)=NaN; %
ﬁnd x2
1+x2
2 >9 points and assign NaN
i=find(x1+x2>1); z(i)=NaN;
%
ﬁnd x1+x2 >1 points, assign values to NaN
surf(x1,x2,z); shading interp; %
draw the allowed surface
The three-dimensional surface plot can be drawn as shown in Figure 6.12 (a). If one
wants to observe the three-dimensional surface from the top, then, the command view(0,90)
can be used, and the two-dimensional projection can be obtained as shown in Figure 6.12 (b).
The region shown on the graph is the feasible region. The maximum value in this feasible
region is the solution to the constrained optimization problem. Using the graphical method,
it can be found that the solution is x1 = 0, x2 = −3, with the maximum value 3.
For problems with one or two variables, the graphical solution is of course the most
eﬀective and straightforward method. However, for problems with more variables, the
graphical solution method cannot be used. Numerical searching methods should be used
instead and, again, there is to date no method to judge whether the solutions obtained is
global or not.

258
Scientiﬁc Computing with MATLAB®
−3
−2
−1
0
1
2
3
−2
0
2
−10
−8
−6
−4
−2
0
zmax
(a) three-dimensional surface plot
−3
−2
−1
0
1
2
3
−3
−2
−1
0
1
2
3
(b) feasible region
FIGURE 6.12: Graphical solution to a 2D optimization problem.
6.4.2
Solving linear programming problems
I. Solutions of standard linear programming problems
Linear programming problems are special constrained programming problems whose
objective function and constraints are all linear with respect to x. The general mathematical
description is
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
Ax⩽B
Aeqx=Beq
xm⩽x⩽xM
f Tx.
(6-4-2)
In order to solve the problem eﬀectively, the constraints can further be classiﬁed to linear
equality constraints Aeqx = Beq and linear inequality constraints Ax ⩽B. Moreover, the
upper- and lower-bounds xM and xm can be introduced, such that xm ⩽x ⩽xM.
For inequality constraints, the standard description under MATLAB is the “⩽”
relationship. If certain constraints are given by “⩾” relationship, then, −1 can be multiplied
to both sides of the inequality such that the inequalities can be converted to the “⩽”
relationship.
Linear programming problems are the simplest and most widely used constrained
optimization problems. There are many algorithms suggested for this kind of optimization
problem. The simplex algorithm is proven to be the most eﬀective algorithm and with the
well established function linprog(), the linear programming problems can easily be solved,
with the syntaxes
[x,fopt,flag,c]= linprog(problem)
[x,fopt,flag,c]= linprog(f,A,B,Aeq,Beq,xm,xM,x0,opts)
where f, A, B, Aeq, Beq, xm, xM are the same as in the above general formulation.
The argument x0 is the user selected initial search point, which can be omitted. If certain
constraints do not exist, replace the matrices with empty ones. After the function call,
the optimized results are returned in variable x, and the optimum objective function is
returned in fopt. A positive flag indicates the successful function call. Structured variable
description to linear programming problems can also be used.
It should be noted that a linear programming problem is a convex problem, and in simple

Nonlinear Equations and Numerical Optimization Problems
259
terms, if a minimum is found, it must be the global minimum. Thus, the initial choice of
x0 is not important and can usually be omitted.
Example 6.29
Solve the following linear programming problem:
min
x
s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
2x2+x3+4x4+2x5⩽54
3x1+4x2+5x3−x4−x5⩽62
x1,x2⩾0, x3⩾3.32, x4⩾0.678, x5⩾2.57
−2x1 −x2 −4x3 −3x4 −x5.
Solution For this linear programming problem, the objective function can be deﬁned by the
vector f =[−2, −1, −4, −3, −1]T. There are two inequality constraints
A =
0
2
1
4
2
3
4
5
−1
−1

,
and B =
54
62

.
Since there are no equality constraints, the matrices Aeq and Beq can be declared as
empty matrices. From the original problem, it is also seen that the lower-bound of x can
be deﬁned as xm = [0, 0, 3.32, 0.678, 2.57]T, and since there is no upper-bound, xM can be
assigned to an empty vector. Thus, the problem can be solved directly using the following
MATLAB statements, and the result can be obtained immediately
>> f=-[2 1 4 3 1]’; A=[0 2 1 4 2; 3 4 5 -1 -1];
B=[54; 62]; Ae=[]; Be=[]; xm=[0,0,3.32,0.678,2.57];
ff=optimset; ff.TolX=1e-15; ff.TolFun=1e-20; ff.TolCon=1e-20;
[x,f_opt,key,c]=linprog(f,A,B,Ae,Be,xm,[],[],ff)
where x = [19.785, 0, 3.32, 11.385, 2.57]T, fopt = −89.5750, and key=1, meaning that the
solution is successful. In fact, only 5 steps are used in ﬁnding the optimal solution for this
problem.
Linear programming problems can also be described by a structured variable P, and
its ﬁelds lb and ub are used to describe the bounds xm and xM, while the ﬁelds Aineq,
bineq, Aeq, beq are used respectively to describe matrices A, B, Aeq, Beq. The solver
ﬁeld can be set to ’linprog’, and objective function vector f can be described by the f
ﬁeld. Function linprog(P) can be used to solve directly the linear programming problem
P. In this function, f, solver and options are essential ﬁelds, while others are optional
ones.
Example 6.30
Structured variables can be used to model the linear programming
problems. Since the ﬁelds Aeq and Beq are empty ones, there is no need to describe them
in P variable. The following statements can be used, and the same results can be obtained.
>> clear P; P.f=-[2 1 4 3 1]’; P.Aineq=[0 2 1 4 2; 3 4 5 -1 -1];
P.bineq=[54; 62]; P.lb=[0,0,3.32,0.678,2.57]; P.solver=’linprog’;
ff=optimset; ff.TolX=1e-15; ff.TolFun=1e-20; ff.TolCon=1e-20;
P.options=ff; [x,f_opt,key,c]=linprog(P)
Example 6.31
Consider the linear programming problem with four variables deﬁned as
follows. Solve it using the Optimization Toolbox of MATLAB.
max
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x1/4−60x2−x3/50+9x4⩽0
−x1/2+90x2+x5/50−3x4⩾0
x3⩽1, x1⩾−5, x2⩾−5, x3⩾−5, x4⩾−5
3
4 x1 −150x2 + 1
50 x3 −6x4.

260
Scientiﬁc Computing with MATLAB®
Solution In the original problem, the maximization is required. It should be converted ﬁrst
to the minimization problem by multiplying −1 to the objective function. The new objective
function can be rewritten as −3x1/4 + 150x2 −x3/50 + 6x4. From the linear programming
problem formulation, it can be seen that f = [−3/4, 150, −1/50, 6]T.
For the given constraints, xi ⩾−5 will lead to a lower-bound vector xm = [−5;−5;
−5;−5]. Similarly, the upper-bound vector xM = [Inf;Inf;1;Inf], with Inf for +∞. Also,
in the two inequality constraints, the second one is given by the ⩾relationship. We should
multiply both sides by −1 to convert it into the ⩽inequality. Thus, the matrices for the
inequalities can be written as
A =

1/4
−60
−1/50
9
1/2
−90
−1/50
3

, B =

0
0

.
Since there are no equality constraints, one should assume that Aeq = [],Beq = [].
Therefore, the original linear programming problem can be solved using the following
statements
>> clear P; P.f=[-3/4,150,-1/50,6];
P.Aineq=[1/4,-60,-1/50,9; 1/2,-90,-1/50,3]; P.bineq=[0;0];
P.lb=[-5;-5;-5;-5]; P.ub=[Inf;Inf;1;Inf]; ff=optimset;
ff.TolX=1e-15; ff.TolFun=1e-20; TolCon=1e-20; P.options=ff;
P.solver=’linprog’; [x,a,b,c]=linprog(P)
and within 19 iterations, the solution x = [−5, −0.194667, 1, −5]T can be found. The
objective function reaches its minimum at fopt = −55.47.
II. Linear programming with double subscripts
In real applications, one may ﬁnd some linear programming problems are presented,
where the decision variable is given by a matrix, rather than a vector. Conversions must be
made ﬁrst to convert such kind of problems into standard linear programming problems,
then, linorog() can be used to solve the original problem. After solution, the vectorized
decision variable should be converted back to the decision matrix.
Example 6.32
Consider a tricky double subscripted linear programming problem given
below. Find the optimal solution to the problem.
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x11+x12+x13+x14⩾15
x12+x13+x14+x21+x22+x23⩾10
x13+x14+x22+x23+x31+x32⩾20
x14+x23+x32+x41⩾12
xij⩾0, (i=1,2,3,4,j=1,2,3,4)
2800(x11+x21+x31+x41)+4500(x12+x22+x32)+6000(x13+x23)+7300x14.
Solution
Since the linprog() function can only be used to solve single subscripted
problems, the original problem should be converted ﬁrst by rearranging the variables such
that x1 = x11, x2 = x12, x3 = x13, x4 = x14, x5 = x21, x6 = x22, x7 = x23, x8 = x31, x9 =
x32, x10 = x41. The original problem can then be rewritten as

Nonlinear Equations and Numerical Optimization Problems
261
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
−(x1+x2+x3+x4)⩽−15
−(x2+x3+x4+x5+x6+x7)⩽−10
−(x3+x4+x6+x7+x8+x9)⩽−20
−(x4+x7+x9+x10)⩽−12
xi⩾0, i=1,2,··· ,10
2800(x1 + x5 + x8 + x10) + 4500(x2 + x6 + x9) + 6000(x3 + x7) + 7300x4.
The following MATLAB statements can then be used in ﬁnding the solutions to the
optimization problem
>> clear P; P.solver=’linprog’; P.options=optimset;
P.f=2800*[1 0 0 0 1 0 0 1 0 1]+4500*[0 1 0 0 0 1 0 0 1 0]+...
6000*[0 0 1 0 0 0 1 0 0 0]+7300*[0 0 0 1 0 0 0 0 0 0];
P.Aineq=-[1 1 1 1 0 0 0 0 0 0; 0 1 1 1 1 1 1 0 0 0;
0 0 1 1 0 1 1 1 1 0; 0 0 0 1 0 0 1 0 1 1];
P.bineq=-[15; 10; 20; 12]; P.lb=[0 0 0 0 0 0 0 0 0 0];
x=linprog(P)
and it is found that x = [4.2069, 0, 0, 10.7931, 0, 0, 0, 8, 1.2069, 0.0000]. Converting the
solutions back to the double subscripted format, one has x11 = 4.2069, x14 = 10.7931,
x31 = 8, x32 = 1.2069, and the rest of the variables are all zeros.
III. Modeling and solution of transportation problems
Transportation problems are essential problems both in “Operations Research” courses
and real applications. A typical transportation problem is illustrated in Table 6.2 [7].
Suppose it is required to transport the n kinds of products from the m suppliers. The
transportation cost of each unit of product is speciﬁed as cij, and the total requirement for
the ith product is di, while the total of products in the ith supplier is si. The target of the
transportation problem is to decide how many units of each product is required from each
supplier, with the total transportation cost minimized.
TABLE 6.2: Typical table for a transportation problem.
cost per unit distributed
supply
diﬀerent kinds of products
1
2
· · ·
n
si
1
c11
c12
· · ·
c1n
s1
sources
2
c21
c22
· · ·
c2n
s2
· · ·
· · ·
· · ·
· · ·
· · ·
m
cm1
cm2
· · ·
cmn
sm
demond
d1
d2
· · ·
dn
To model such a problem mathematically, the decision variables xij should be selected,
according to each cost cij. Therefore, the transportation problem can be modeled by linear

262
Scientiﬁc Computing with MATLAB®
programming problems with double subscripts as
min
X s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
n

j=1
xij=si,i=1,2,··· ,m
m

i=1
xij=dj,j=1,2,··· ,n
xij⩾0,i=1,2,··· ,m,j=1,2,··· ,n
m

i=1
n

j=1
cijxij.
(6-4-3)
To solve the linear programming problem with double subscripts, it is rather a tedious
and error-prone task to convert it ﬁrst into single subscript problems. An automatic
modeling and solution function is written, to allow direct use of double subscript matrix C,
and vectors s, d. The syntax of the function is X = transport linprog(C,s,d). With
the function, the transportation problem can be solved directly, and the optimal solution is
returned in X.
function [x,f,key]=transport_linprog(F,s,d,intkey)
[m,n]=size(F); X=zeros(n*m,m); Y=zeros(n*m,n);
for i=0:m-1, X(i*(n+n*m)+1:i*(n+n*m)+n)=1; end
for k=1:n*m+1:n*m*n, i=0:m-1; Y(k+n*i)=1; end
Aeq=[X Y]’; xm=zeros(1,n*m); F1=F.’; f=F1(:).’; Beq=[s(:); d(:)];
if nargin==3, [x,f,key]=linprog(f,[],[],Aeq,Beq,xm);
else, [x,f,key]=intlinprog(f,1:n*m,[],[],Aeq,Beq,xm); x=round(x); end
x=reshape(x,n,m).’;
Example 6.33 Assume that a department store is planning to purchase clothes from three
diﬀerent cities I, II and III. Four kinds of clothes, A, B, C and D, are to be purchased, with
the amounts required for A, B, C and D are respectively 1500, 2000, 3000 and 3500. It is
known that the maximum supplies of the three cities are respectively 2500, 2500 and 5000.
It is also known that the expected proﬁt of the clothes are given in Table 6.3. Please design
a purchase plan, which maximizes the total proﬁt.
TABLE 6.3: Expected proﬁt for each type of clothes.
diﬀerent types of clothes
total supply
cities
A
B
C
D
si
I
10
5
6
7
2500
II
8
2
7
6
2500
III
9
3
4
8
5000
total requirement di
1500
2000
3000
3500
Solution
The original problem is a maximum proﬁt problem, therefore, the objective
function should be multiplied by −1 to convert it to a minimization problem. The lower
bounds of the decision variables are zeros. The following statements can be used to solve the
problem directly.
>> C=[10 5 6 7; 8 2 7 6; 9 3 4 8]; s=[2500 2500 5000];
d=[1500 2000 3000 3500]; X=transport_linprog(-C,s,d)
f=sum(C(:).*X(:)) % compute the maximized proﬁt

Nonlinear Equations and Numerical Optimization Problems
263
and the obtained matrix X is
X =
⎡
⎣
0
2000
500
0
0
0
2500
0
1500
0
0
3500
⎤
⎦,
f = 72000,
meaning to purchase 2000 B and 500 C clothes from city I; purchase 2500 C from city II;
1500 A and 3500 D from city III, with a total of expected proﬁt f = 72000.
If the demands are changed to d = [1500, 2500, 3000, 3500], the decision variables
returned may become fractional numbers. In that case, integer programming should be
introduced. This will be discussed later.
6.4.3
Solving quadratic programming problems
Quadratic programming problems are another category of simple constrained optimiza-
tion problems. In quadratic programming problems, the objective function contains the
quadratic form of vector x. The constraints are still linear. The general form of quadratic
programming is
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
Ax⩽B
Aeqx=Beq
xm⩽x⩽xM
1
2 xTHx + f Tx.
(6-4-4)
Comparing the problem in linear programming, it can be seen that a quadratic form
xTHx is introduced to describe x2
i and xixj terms. The quadprog() function can be used
to solve the quadratic programming problems, with the following syntaxes
[x,fopt,flag,c]= quadprog(problem)
[x,fopt,flag,c]= quadprog(H,f,A,B,Aeq,Beq,xm,xM,x0,opts)
where in the function call, H matrix should be declared, while the other arguments
are exactly the same as those in linear programming problems. Quadratic programming
problems can also be modeled with structured variables, in a similar manner, as in the
linear programming problems. H matrix should be assigned to its H ﬁeld, and its solver
ﬁeld can be set to ’quadprog’.
Example 6.34
Solve the following quadratic programming problems with four variables:
min
x s.t.
⎧
⎨
⎩
x1 + x2 + x3 + x4 ⩽5
3x1 + 3x2 + 2x3 + x4 ⩽10
x1, x2, x3, x4 ⩾0
(x1 −1)2 + (x2 −2)2 + (x3 −3)2 + (x4 −4)2.
Solution In order to solve the original problem, the objective function should be rewritten
such that
f(x) = x2
1 −2x1 + 1 + x2
2 −4x2 + 4 + x2
3 −6x3 + 9 + x2
4 −8x4 + 16
= (x2
1 + x2
2 + x2
3 + x2
4) + (−2x1 −4x2 −6x3 −8x4) + 30.
Since the constant term does not aﬀect the optimization problem solving, it can be
omitted safely. Thus, the matrices for quadratic programming can then be deﬁned as

264
Scientiﬁc Computing with MATLAB®
H = diag([2, 2, 2, 2]), and f T = [−2, −4, −6, −8]. Therefore, the following statements can
be used to solve this quadratic programming problem
>> clear P; P.f=[-2,-4,-6,-8]; P.H=diag([2,2,2,2]);
OPT=optimset; OPT.LargeScale=’off’; %
turn oﬀthe large-scale algorithm
P.options=OPT; P.solver=’quadprog’; P.lb=zeros(4,1);
P.Aineq=[1,1,1,1; 3,3,2,1]; P.Bineq=[5;10]; [x,f_opt]=quadprog(P)
with the solutions x = [0, 0.6667, 1.6667, 2.6667]T, fopt = −23.6667.
It should be noted that since there is a factor 1/2 in the quadratic term, the generation
of matrix H should be prepared with care. Thus, the diagonal terms in H should be 2’s
instead of 1’s in this example. It should also be noted that the constant term was removed in
performing the optimization computation. The constant should be added back to the optimum
value such that the objective function is 6.3333.
6.4.4
Solving general nonlinear programming problems
The general nonlinear programming problems are formulated as follows:
min
x s.t. G(x)⩽0
f(x),
(6-4-5)
where x = [x1, x2, · · · , xn]T. For simplicity, the constraints can further be classiﬁed into
linear inequalities and equalities, upper- and lower-bounds, and nonlinear equalities and
inequalities. The original constraints can thus be rewritten as
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
Ax⩽B
Aeqx=Beq
xm⩽x⩽xM
C(x)⩽0
Ceq(x)=0
f(x).
(6-4-6)
A MATLAB function fmincon() can be used to solve general nonlinear programming
problems. The syntaxes of the function are
[x,fopt,flag,c]= fmincon(problem)
[x,fopt,flag,c]= fmincon(fun,x0,A,B,Aeq,Beq,xm,xM,CFun,opts,p1,p2,· · · )
where fun is the M-function or anonymous function to describe the objective function.
The argument x0 is the initial search point. The deﬁnitions of A, B, Aeq, Beq, xm, xM
are the same as in (6-4-6). The argument CFun is the M-function to describe the nonlinear
constraints, with two returned arguments, indicating the inequality and equality constraints,
respectively. The argument opts is the control options. The returned arguments are exactly
the same as in other optimization functions in MATLAB.
Nonlinear programming problems can also be modeled with structured variable problem,
whose solver ﬁeld must be set to ’fmincon’, and nonlinear constraint functions can be
assigned to the nonlcon ﬁeld.
Example 6.35
Solve the following nonlinear programming problem:

Nonlinear Equations and Numerical Optimization Problems
265
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x2
1+x2
2+x2
3−25=0
8x1+14x2+7x3−56=0
x1,x2,x3⩾0
1000 −x2
1 −2x2
2 −x2
3 −x1x2 −x1x3.
Solution In this problem, there are nonlinear constraints, thus, the original problem is not
a quadratic programming problem. Nonlinear programming solvers should be used to solve
this problem. The objective function can be expressed by an anonymous function. Moreover,
since the two constraints are all equalities, thus, the constraint functions can be expressed
as
function [c,ceq]=opt_con1(x), c=[]; % specify the two constraints
ceq=[x(1)*x(1)+x(2)*x(2)+x(3)*x(3)-25; 8*x(1)+14*x(2)+7*x(3)-56];
where the nonlinear inequalities and nonlinear equalities are returned respectively in
arguments c and ceq. Since there is no inequality constraint, the argument c is then assigned
to an empty matrix.
Having declared the constraints, the matrices A, B, Aeq, Beq are now all empty matrices.
The lower-bound vector can be written as xm = [0, 0, 0]T. If the initial point is selected as
x0 = [1, 1, 1]T, the problem can then be solved using the following statements
>> clear P; ff=optimset; ff.LargeScale=’off’; ff.TolFun=1e-30;
ff.TolX=1e-15; ff.TolCon=1e-20; P.x0=[1;1;1]; P.lb=[0;0;0];
P.objective=@(x)1000-x(1)*x(1)-2*x(2)*x(2)-x(3)*x(3)-x(1)*x(2)-x(1)*x(3);
P.solver=’fmincon’; P.nonlcon=@opt_con1; P.options=ff;
[x,f_opt,c,d]=fmincon(P)
with x = [3.5121, 0.2170, 3.5522]T, and fopt = 961.7151. Totally 111 calls to the objective
functions are made during the solution process.
Since the second constraint is in fact linear, it can be removed from the nonlinear
constraint function. Thus, the constraint function can be simpliﬁed as
function [c,ceq]=opt_con2(x)
ceq=x(1)*x(1)+x(2)*x(2)+x(3)*x(3)-25; c=[];
and the linear equality constraint can be declared in the following statements, and the
solution obtained using the following is exactly the same as the one obtained previously.
>> P.Aeq=[8,14,7]; P.beq=56; P.nonlcon=@opt_con2; x=fmincon(P)
Example 6.36
Please solve the following nonlinear programming problem [8]
min
q,w,k s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
q3+9.625q1w+16q2w+16w2+12−4q1−q2−78w=0
16q1w+44−19q1−8q2−q3−24w=0
2.25−0.25k⩽q1⩽2.25+0.25k
1.5−0.5k⩽q2⩽1.5+0.5k
1.5−1.5k⩽q3⩽1.5+1.5k
k.
Solution It can be seen from the model that the decision variables are q, w and k, while
the standard nonlinear programming problem solver can only solve vector decision variable
problems. Variable substitutions should be made ﬁrst to convert the problem into a standard

266
Scientiﬁc Computing with MATLAB®
problem. The following variables are assigned x1 = q1, x2 = q2, x3 = q3, x4 = w, x5 = k.
Also, the inequality constraints should be rewritten. The original problem can be manually
written as
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x3+9.625x1x4+16x2x4+16x2
4+12−4x1−x2−78x4=0
16x1x4+44−19x1−8x2−x3−24x4=0
−0.25x5−x1⩽−2.25
x1−0.25x5⩽2.25
−0.5x5−x2⩽−1.5
x2−0.5x5⩽1.5
−1.5x5−x3⩽−1.5
x3−1.5x5⩽1.5
x5.
The following statements can be used to describe the nonlinear constraints
function [c,ceq]=c6exnls(x), c=[];
ceq=[x(3)+9.625*x(1)*x(4)+16*x(2)*x(4)+16*x(4)^2+12-4*x(1)-x(2)-78*x(4);
16*x(1)*x(4)+44-19*x(1)-8*x(2)-x(3)-24*x(4)];
Structured variable P is used to describe the original problem, and random numbers are
used as the initial searching vector, and the results of optimization process is
x = [1.9638, 0.9276, −0.2172, 0.0695, 1.1448],
optimal objective function is 1.1448, and the value of flag is 1, meaning the solution process
is successful.
>> clear P; P.objective=@(x)x(5); P.nonlcon=@c6exnls;
P.Aineq=[-1 0 0 0 -0.25; 1 0 0 0 -0.25; 0 -1 0 0 -0.5;
0 1 0 0 -0.5; 0 0 -1 0 -1.5; 0 0 1 0 -1.5];
P.bineq=[-2.25; 2.25; -1.5; 1.5; -1.5; 1.5]; P.solver=’fmincon’;
P.options=optimset; P.x0=rand(5,1); [x,fm,flag]=fmincon(P)
It should be noted that the above solution may still be a local minimum of the problem.
The method in Section 6.3.3 can be extended to constrained optimization problems, and the
new function is
function [x,f0]=fmincon_global(f,a,b,n,N,varargin)
x0=rand(n,1); k0=0; if strcmp(class(f),’struct’), k0=1; end
if k0==1, f.x0=x0; [x f0]=fmincon(f);
else, [x f0]=fmincon(f,x0,varargin{:}); end
for i=1:N, x0=a+(b-a)*rand(n,1);
if k0==1, f.x0=x0; [x1 f1 key]=fmincon(f);
else, [x1 f1 key]=fmincon(f,x0,varargin{:}); end
if key>0 & f1<f0, x=x1; f0=f1; end
end
The syntax of the function is
[x,fmin] = fmincon global(fun,a,b,n,N,others)
where fun can be a structured variable, or the handle of the objective function. In latter case,
others arguments can be used to specify constraints, as in the case of fmincon() function.

Nonlinear Equations and Numerical Optimization Problems
267
Example 6.37
With the above function, the problem can be solved with the fol-
lowing statements, and global optimum can be obtained, as x
=
[2.4544, 1.9088,
2.7263, 1.3510, 0.8175]T, whose ﬁfth value x5 is the value of the objective function.
>> [x,f0]=fmincon_global(P,0,5,5,50) % ﬁnd global optimum solution
If the function call is executed 100 times, it is quite likely all the runs ﬁnd the global
optimal solutions, which means that the new solver is successful in ﬁnding global optimal
solutions. The total test time is about 15 minutes.
>> tic, X=[];
for i=1:100, % run 100 times the function and assess the successful rate
[x,f0]=fmincon_global(P,0,5,5,50); X=[X; x’];
end, toc
Example 6.38
Consider again the optimization problem in Example 6.35. Solve the
problem using gradients and compare the results with the original example.
Solution For the given objective function f(x), the gradient vector, or the Jacobian matrix,
can be derived
>> syms x1 x2 x3; f=1000-x1*x1-2*x2*x2-x3*x3-x1*x2-x1*x3;
J=jacobian(f,[x1,x2,x3]) % ﬁnd the gradients analytically
and the gradient matrix can be written as
J =
 ∂f
∂x1
, ∂f
∂x2
, ∂f
∂x3
T
=
⎡
⎣
−2x1 −x2 −x3
−4x2 −x1
−2x3 −x1
⎤
⎦.
With the gradients, the objective function can then be rewritten as
function [y,Gy]=opt_fun2(x)
y=1000-x(1)*x(1)-2*x(2)*x(2)-x(3)*x(3)-x(1)*x(2)-x(1)*x(3);
Gy=[-2*x(1)-x(2)-x(3); -4*x(2)-x(1); -2*x(3)-x(1)];
where, Gy returns the gradient vector of the objective function. The following statements can
be used
>> clear P; ff=optimset; ff.LargeScale=’off’; ff.GradObj=’on’;
ff.TolFun=1e-30; ff.TolX=1e-15; ff.TolCon=1e-20;
P.x0=[1;1;1]; P.lb=[0;0;0];
P.objective=@opt_fun2; P.solver=’fmincon’; P.nonlcon=@opt_con1;
P.options=ff; [x,f_opt,c,d]=fmincon(P)
ﬁnd the solution x = [3.5121, 0.2170, 3.5522]T, and fopt = 961.7151. In total, 79 calls to the
objective functions are made during the solution process.
For this example, if the gradients are used, 13 iterations are needed which are fewer than
the one without gradients, where 16 iterations are needed. However, taking into account the
time needed in deriving and coding the gradients, the actual time required may be much
greater. Therefore, sometimes it may not be worthwhile to use gradient information for
certain applications.

268
Scientiﬁc Computing with MATLAB®
6.5
Mixed Integer Programming Problems
In many applications, all or part of the decision variables may be required to be integers
for the optimization problems, which are referred to as the integer programming problems. If
only part of the decision variables are required to be integers, they are referred to as mixed
integer programming problems. In some applications, the allowable values for the decision
variables are either 0’s or 1’s, and are referred to as binary programming problems, also
known as the 0-1 programming problems.
6.5.1
Enumerate method in integer programming problems
Enumerate method, also known as brutal force method, means that all the possible feasible
combinations of the decision variables are enumerated, from which the global optimal
solution can be found. This method is only applicable to integer programming problems.
If the intervals of the decision variables are known, theoretically all the combinations can
be enumerated, from which the feasible combinations can be found. The objective function
values can then be sorted, and the optimal solution can be found from the sorting results.
This method seems to be very simple and straightforward, however, for large-scale problems,
i.e., with too many decision variables, and/or the range of the variables are too large to
enumerate, computation or even storage burden are too much to be solved even by the
most powerful computers in the world. The related mathematical problems are referred to
as non-polynomial hard (or NP hard) problems. Enumerate methods are only suitable for
solving small-scale problems.
Example 6.39
Consider the linear programming problem studied in Example 6.29.
min
x
s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
2x2+x3+4x4+2x5⩽54
3x1+4x2+5x3−x4−x5⩽62
x1, x2⩾0, x3⩾3.32, x4⩾0.678, x5⩾2.57
−2x1 −x2 −4x3 −3x4 −x5.
If all the decision variables xi must be integers, the original problem is an integer
linear programming problem. Please solve the integer programming problem with enumerate
method.
Solution For this kind of small-scale problem, enumerate method should be used. We can
assume that all the components in xM are 25, the following statements can be used, and it
can be found that the global optimum is x = [ 19, 0, 4, 10, 5 ]T, with fmin = −89.
>> N=25; [x1,x2,x3,x4,x5]=ndgrid(1:N,0:N,4:N,1:N,3:N);
i=find((2*x2+x3+4*x4+2*x5<=54) & (3*x1+4*x2+5*x3-x4-x5<=62));
x1=x1(i); x2=x2(i); x3=x3(i); x4=x4(i); x5=x5(i);
f=-2*x1-x2-4*x3-3*x4-x5; [fmin,ii]=sort(f);
index=ii(1); x=[x1(index),x2(index),x3(index),x4(index),x5(index)]
There are two problems to be noted. One is that the search region is set to x1 ∈[0, 25]. If
the region is extended from 25 to 30, there will be signiﬁcant increase in both computational
eﬀort and memory allocations. For instance, the memory required for the ﬁve variables xi
will be 315 × 5 × 8/220 = 1092.1MB. Thus, enumerate methods are not suitable for this kind
of problem.

Nonlinear Equations and Numerical Optimization Problems
269
The other problem is that there are other combinations of x which may have slightly
larger objective functions than the global optimum one. These combinations can be referred
to as the suboptimal solutions. When enumerate method is used, suboptimal can also be
found as shown in Table 6.4.
>> L=15; fx=fmin(1:L)’ % global and sub-optimal solutions
in=ii(1:L); x=[x1(in),x2(in),x3(in),x4(in),x5(in),fmin(1:15)]
TABLE 6.4: Optimum and sub-optimum solutions.
x1
x2
x3
x4
x5
f
x1
x2
x3
x4
x5
f
x1
x2
x3
x4
x5
f
19
0
4
10
5
−89
19
0
4
9
7
−88
11
0
8
10
3
−87
18
0
4
11
3
−88
16
0
6
8
8
−88
10
0
9
9
4
−87
17
0
5
10
4
−88
20
0
4
7
11
−88
8
0
10
9
4
−87
15
0
6
10
4
−88
15
0
6
10
3
−87
5
0
12
8
5
−87
12
0
8
9
5
−88
13
0
7
10
3
−87
18
0
4
10
5
−87
Example 6.40
Please solve the following nonlinear integer programming problem with
enumerate method
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
−x2
1−x2
2−x2
3−x2
4−x1+x2−x3+x4+8⩾0
−x2
1−2x2
2−x2
3−2x2
4+x1+x4+10⩾0
−2x2
1−x2
2−x2
3−2x2
4+x2+x4+5⩾0
x2
1 + x2
2 + 2x2
3 + x2
4 −5x1 −5x2 −21x3 + 7x4
Solution
Select the interested regions for the decision variables as −N ∼N, and let
N = 30, all the possible xi’s can be generated, and all the feasible solutions can be found
directly. The feasible solutions can then be sorted, and the global optimal solution can be
found as x = [0, 1, 2, 0]T, with objective function −38. Apart from the global solution, some
suboptimal solutions can also be found [0, 0, 2, 0], [0, 1, 2, 1], [0, 1, 1, −1] and [1, 2, 1, 0] can
also be found.
>> N=30; [x1 x2 x3 x4]=ndgrid(-N:N); % generate all possible combinations
ii=find(-x1.^2-x2.^2-x3.^2-x4.^2-x1+x2-x3+x4+8>=0 & ...
-x1.^2-2*x2.^2-x3.^2-2*x4.^2+x1+x4+10>=0 & ...
-2*x1.^2-x2.^2-x3.^2-2*x4.^2+x2+x4+5>=0); % all the constraints
x1=x1(ii); x2=x2(ii); x3=x3(ii); x4=x4(ii); % all the feasible solutions
ff=x1.^2+x2.^2+2*x3.^2+x4.^2-5*x1-5*x2-21*x3+7*x4; % ﬁrst 5 solutions
[fm,ii]=sort(ff); k=ii(1:5); X=[x1(k),x2(k),x3(k),x4(k)], fm(1:5)
It should be pointed out that, enumerate method cannot be used in solving problems with
mixed integer programming problems, since some of the decision variables are continuous
and cannot be enumerated. In this case, searching methods should be used instead.

270
Scientiﬁc Computing with MATLAB®
6.5.2
Solutions of linear integer programming problems
In the recent versions of Optimization Toolbox, a function intlinprog() is provided in
solving linear mixed integer programming problems, with the syntaxes
[x,fm,key,c]= intlinprog(problem)
[x,fm,key,c]= intlinprog(f,intcon,A,b,Aeq,beq,xm,xM,options)
The syntaxes are very similar to the ones in linprog() function. The new input
argument intcon actually indicates the indexes of the decision variables to be integers.
In the description of structured variable problem, the essential ﬁelds are f, intcon, solver
and options. Compared with the one in linprog(), the diﬀerences are that, intcon ﬁeld
must be speciﬁed, and
problem.solver= ’intlinprog’,
problem.options= optimoptions(’intlinprog’)
Due to the limitations in the new function intlinprog(), the requested integer decision
variables are not really integers. There might be slight errors. The best way to correct the
results is to use x(intcon)= round(x(intcon)) command after the function call, when
it is claimed successful.
Example 6.41
Consider again the linear integer programming problem in Example 6.29.
Please solve also the mixed linear programming problem, when the 1st, 4th and 5th decision
variables are requested as integers.
Solution The ordinary integer linear programming problem can be solved directly with the
following statements
>> clear P; P.solver=’intlinprog’; P.options=optimoptions(’intlinprog’);
P.lb=[0; 0; 3.32; 0.678; 2.57]; P.f=[-2 -1 -4 -3 -1];
P.Aineq=[0 2 1 4 2; 3 4 5 -1 -1]; P.Bineq=[54; 62];
P.intcon=[1 2 3 4 5]; [x,f,a,b]=intlinprog(P), x=round(x)
It can be seen that the result is exactly the same as the one obtained in Example 6.29,
however, this result is more reliable, since the one with enumerate method was obtained with
the assumption that N ⩽25.
Now consider the mixed integer linear programming program. According to the request,
with intcon should be set to [1, 4, 5], and the problem can be solved with the following
statements, with the result of X = [19, 0, 3.8, 11, 3]T. It should be noted also that the problem
cannot be solved with enumerate method.
>> P.intcon=[1 4 5]; [x,f,a,b]=intlinprog(P) % integer LP solution
x(P.intcon)=round(x(P.intcon)) % ﬁne tuning the solutions
Example 6.42
Consider the transportation problem in Example 6.33. If the decision
variables are required to be integers, please solve the problem again.
Solution In the function transport linprog() discussed in Example 6.33, we left a tuning
knob, i.e., to use the fourth input argument in the function call. In this case, the linear
integer programming problem can be solved automatically, and the results obtained this way
are integers

Nonlinear Equations and Numerical Optimization Problems
271
>> C=[10,5,6,7; 8,2,7,6; 9,3,4,8]; b=[1500 2500 3000 3500];
a=[2500 2500 5000]; x=transport_linprog(-C,a,b,1) % maximization
f=sum(C(:).*X(:)) % evaluate the expected proﬁt
6.5.3
Solutions of nonlinear integer programming problems
One of the most frequently used algorithms for mixed integer programming problems
is the branch-and-bound algorithm. Details of the algorithm are omitted and an existing
MATLAB function bnb20(), developed by Koert Kuipers of Groningen University in The
Netherlands, can be used directly. The function can be downloaded freely from MathWorks
ﬁle-exchange website. The function is updated and some bugs are ﬁxed in the book, and
now the function allows the use of anonymous functions and models described by structured
variables. The syntax is
[err,f,x]= BNB20 new(fun,x0,intcon,xm,xM,A,B,Aeq,Beq,CFun)
where, most of the arguments in the function call are the same as in other optimization
functions. The function fmincon() is called by the BNB20 new() function. The variables x
and f are returned respectively and if err is empty, the results obtained are correct. The
argument intcon is the same as the one deﬁned in intlinprog() function.
If the original optimization problem is described by a structured variable P, its intcon
ﬁeld should be set to the intcon vector discussed earlier. The problem can be solved with
[err,f,x]= BNB20 new(P).
Example 6.43
Solve again the integer and mixed integer linear programming problems
in Example 6.29, with the nonlinear mixed integer programming solver.
Solution In the new BNB20 new() function, anonymous functions are supported. Since all
the xi’s are expected to be integers, the intcon vector should be set to [1, 2, 3, 4, 5]. Also, the
upper-bound can no longer be set to Inf, and ﬁnite values should be assigned instead. For
instance, the upper-bounds can be assigned to 20000. The following statements can then be
used
>> f=@(x)-[2 1 4 3 1]*x; xm=[0,0,3.32,0.678,2.57]’; x0=ceil(xm);
A=[0 2 1 4 2; 3 4 5 -1 -1]; intcon=1:5; Aeq=[]; Beq=[];
B=[54; 62]; xM=20000*ones(5,1);
[errmsg,fm,X]=BNB20_new(f,x0,intcon,xm,xM,A,B,Aeq,Beq)
and the solution obtained is x = [19, 0, 4, 10, 5]T.
When the problem is described by a structured variable P, the problem can be solved with
the following statements, and the same results can be obtained
>> clear P; P.objective=f; P.lb=xm; P.x0=x0; P.ub=xM; % structured variable
P.Aineq=A; P.Bineq=B; P.intcon=intcon; [errmsg,fm,X]=BNB20_new(P)
If x1, x4, x5 are constrained to be integers while the other two variables can be arbitrarily
chosen, then, the original problem is a mixed integer programming problem. The argument
intcon should be modiﬁed accordingly to intcon= [1,4,5], then, the problem can be solved
with the following statements, and the result is X = [19, 0, 3.8, 11, 3]T. Again the result is
the same as the one obtained with the intlinprog() function.
>> P.intcon=[1,4,5]; [errmsg,fm,X]=BNB20_new(P) % solve again

272
Scientiﬁc Computing with MATLAB®
Example 6.44
Please solve the following integer programming problem [9]
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x1−2x2+12+x3⩾0
−x2
1+3x2−8−x3⩾0
x1⩾0,x2⩾0,x3⩾0
x3
1 + x2
2 −4x1 + 4 + x4
3.
Solution Since the original problem contains nonlinear constraints, the following MATLAB
function can be written
function [c,ce]=c6exinl(x)
ce=[]; c=[-x(1)+2*x(2)-12-x(3); x(1)^2-3*x(2)+8+x(3)];
With the following statements, the problem can be solved directly, and the solution
obtained is x = [ 1, 3, 0 ]T.
>> clear P; P.objective=@(x)x(1)^3+x(2)^2-4*x(1)+4+x(3)^4;
P.intcon=1:3; P.nonlcon=@c6exinl; P.lb=[0;0;0];
P.ub=100*[1;1;1]; P.x0=P.ub; [err,fm x]=BNB20_new(P)
Since the original problem is a small-scale problem, enumerate method can be used to
ensure global optimal solution can be found. The result obtained is exactly the same as the
searching method. Besides, some suboptimal solutions can also be found, which cannot be
obtained with searching methods.
>> N=200; [x1 x2 x3]=meshgrid(0:N);
% generate all the possible combinations
ii=find(x1-2*x2+12+x3>=0 & -x1.^2+3*x2-8-x3>=0); % evaluate constraints
x1=x1(ii); x2=x2(ii); x3=x3(ii); % ﬁnd all the feasible solutions
ff=x1.^3+x2.^2-4*x1+4+x3.^4; [fm,ij]=sort(ff); % sort the solutions
k=ij(1:5); [x1(k) x2(k) x3(k)], fm(1:5)
% extract the ﬁrst 5 solutions
Example 6.45 Solve the discrete optimization problem [10], where x1 are multiples of 0.25,
and x2 are multiples of 0.1
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x2
1−6x1+x2−11⩽0
−x1x2+3x2+ex1−3−1⩽0
x2⩾3
2x2
1 + x2
2 −16x1 −10x2.
Solution
MATLAB cannot be used to solve directly discrete optimization problems. In
fact, two new variables y1 = 4x1, and y2 = 10x2 can be introduced, and with variable
substitution, we have x1 = y1/4, x2 = y2/10. The original problem can be rewritten as the
integer programming problem of new decision variables yi
min
y s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
y2
1/16−6y1/4+y2/10−11⩽0
−y1y2/40+3y2/10+ey1/4−3−1⩽0
y2⩾30
2y2
1/16 + y2
2/100 −4y1 −y2.
The nonlinear constraints can be expressed in MATLAB
function [c,ceq]=c6mdisp(y), ceq=[];
c=[y(1)^2/10-6*y(1)/4+y(2)/10-11;
-y(1)*y(2)/40+3*y(2)/10+exp(y(1)/4-3)-1];

Nonlinear Equations and Numerical Optimization Problems
273
Assume that the lower and upper bounds of the variable y1 are ±200 (i.e., the bounds
of x1 are ±50), and the upper bound of y2 is 200, and lower bound is 30 (i.e., 3 ⩽x2 ⩽
20). With BNB20 new() function, the following statements can be used to solve the problem
directly, and the solution is x = [4, 5]T, and it is slightly diﬀerent from the one, (4, 4.75),
given in [9]. Since both the solutions are feasible solutions, and the one obtained here has
slightly smaller objective function.
>> clear P; P.objective=@(y)2*y(1)^2/16+y(2)^2/100-4*y(1)-y(2);
P.nonlcon=@c6mdisp; P.lb=[-200;30]; P.ub=[200;200]; P.intcon=[1,2];
P.x0=[12;30]; [errmsg,ym,y]=BNB20_new(P); x=[y(1)/4,y(2)/10]
The enumerate method can also be used in solving discrete optimization problems.
Assume that the range of decision variables are (−20, 20), the following statements can
be used to solve the problem, and the global optimal solution is (4, 5). Meanwhile some
suboptimal points, (4, 5.1), (4, 4.9), (4, 4.8), (4, 5.2) can also be found.
>> [x1 x2]=meshgrid(-20:0.25:20,3:0.1:20);
ii=find(x1.^2-6*x1+x2-11<=0 & -x1.*x2+3*x2+exp(x1-3)-1<=0);
x1=x1(ii); x2=x2(ii); ff=2*x1.^2+x2.^2-16*x1-10*x2; [fm,ij]=sort(ff);
k=ij(1:5); X=[x1(k) x2(k)], fm(1:5)
6.5.4
Solving binary programming problems
The so-called binary programming is the optimization problem, where the decision
variables xi to be optimized are 0’s and 1’s. It seems quite easy to solve the binary
programming problems, since one may try to substitute all the possible combinations of
each variable, and the optimum point can be found by comparing the calculated objective
functions. In fact, this brutal force method is only applicable to small-scale problems. For
large-scale problems, for instance, if there are n variables to be optimized, the size of the
possible combinations will be 2nn which might be prohibitive to run on an average computer.
Thus, specially design search methods should be used instead.
A function bintprog() could be used to solve binary linear programming problems, with
x = bintprog(f,A,B,Aeq,Beq). However, this function has been removed in R2014b,
and intlinprog() is recommended for binary linear programming problems. Binary
nonlinear programming problems can be solved with BNB20 new().
Example 6.46
Solve the following binary linear programming problem.
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
x1+2x2−x3⩽2
x1+4x2+x3⩽4
x1+x2⩽3
4x2+x3⩽6
−3x1 + 2x2 + 5x3.
Solution From the linear programming model, the required vectors and matrices f, A and
B can easily be constructed and the binary linear programming problem can be solved from
>> f=[-3,2,-5]; A=[1 2 -1; 1 4 1; 1 1 0; 0 4 1]; B=[2;4;5;6];
xm=[0,0,0]; xM=[1,1,1]; intcon=[1,2,3]; % setting for binary programming
x=intlinprog(f,intcon,A,B,[],[],xm,xM)
% binary programming

274
Scientiﬁc Computing with MATLAB®
and the solution is x = [1, 0, 1]T.
For such a small-scale problem, the enumerate method can be used to test for all possible
combinations of the variables whether the constraints are satisﬁed. Then, by simple sorting
to the feasible combinations, according to the values of the objective function, the optimum
solution can be found. In this case, the global optimal solution can be obtained
>> [x1,x2,x3]=meshgrid([0,1]); % generate all the possible combinations
i=find((x1+2*x2-x3<=2)&(x1+4*x2+x3<=4)&(x1+x2<=3)&(4*x1+x3<=6));
f=-3*x1(i)+2*x2(i)-5*x3(i); [fmin,ii]=sort(f); % sort feasible solutions
index=i(ii(1)); x=[x1(index),x2(index),x3(index)] % global optimal solution
with x = [1 0 1]T. Moreover, all feasible solutions to the problem can be found using the
following statements, which were not possible to be found using other methods
>> x=[x1(i(ii)),x2(i(ii)),x3(i(ii))]; [x fmin]
where x1 = [1, 0, 1]T, f(x1) = −8, x2 = [0, 0, 1]T, f(x2) = −5, x3 = [1, 0, 0]T, f(x3) =
−3, x4 = [0, 0, 0]T, f(x4) = 0, x5 = [0, 1, 0]T, f(x5) = 2.
Direct calls to BNB20 new() functions, with the lower- and upper-bounds xm, xM set to
zeros and ones vectors, respectively, can also solve the binary programming problems.
Example 6.47
Solve the binary linear programming problem in Example 6.46 with the
BNB20 new() function.
Solution
An anonymous function can be used to express the objective function. When
the lower- and upper-bounds xm, xM set to zeros and ones vectors, respectively, the binary
programming problem can also be solved for the example using the following statements
>> f=@(x)[-3 2 -5]*x; xm=[0;0;0]; xM=[1;1;1]; x0=xm;
intcon=[1,2,3]; A=[1 2 -1; 1 4 1; 1 1 0; 0 4 1];
B=[2;4;5;6]; [err,f,x]=BNB20_new(f,x0,intcon,xm,xM,A,B)
where x=[1, 0, 1]T and f =−8. The result is exactly the same as the one in Example 6.46.
In fact, the last two constraints are redundant and can be removed.
Example 6.48
Please solve the mixed binary programming problem [9].
min
x,y
s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
0.8ln(x2+1)+0.96ln(x1−x2+1)−0.8x3⩽0
ln(x2+1)+1.2ln(x1−x2+1)−x3−2y3⩾−2
x2−x1⩽0
x2−2y1⩽0
x1−x2−2y2⩽0
y1+y2⩽1
0⩽x⩽[2,2,1]T,y∈{0,1}
5y1+6y2+8y3+10x1−7x3−18ln(x2+1)−19.2ln(x1−x2+1)+10.
Solution
Since there exists nonlinear constraints and objective functions, function
intlinprog() cannot be used. Nonlinear mixed integer programming solvers should be used
instead. Similar to the previous discussed problems, two decision vectors x, y are involved,
and cannot be handled with MATLAB functions directly. The two decision vectors should be
converted to the one with only one decision vector. A new decision vector x is introduced,
whose ﬁrst three components are the original x vector, while the other three components

Nonlinear Equations and Numerical Optimization Problems
275
should be x4 = y1, x5 = y2 and x6 = y3. Therefore, the original problem can be manually
rewritten as
min
x
s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
0.8ln(x2+1)+0.96ln(x1−x2+1)−0.8x3⩾0
ln(x2+1)+1.2ln(x1−x2+1)−x3−2x6⩾−2
x2−x1⩽0
x2−2x4⩽0
x1−x2−2x5⩽0
x4+x5⩽1
0 ⩽x ⩽[2,2,1,1,1,1]T
5x4 + 6x5 + 8x6 + 10x1 −7x3 −18ln(x2 + 1) −19.2ln(x1 −x2 + 1) + 10.
The nonlinear constraints can be expressed in the following MATLAB function
function [c,ceq]=c6mmibp(x), ceq=[]; % no equality constraints
c=[-0.8*log(x(2)+1)-0.96*log(x(1)-x(2)+1)+0.8*x(3); % ﬁrst 2 constraints
-log(x(2)+1)-1.2*log(x(1)-x(2)+1)+x(3)+2*x(6)-2];
Structured variable can be used to express the binary programming problem, and the
following statements can be used, and the result is x = [ 1.301, 0, 1, 0, 1, 0 ]T, with the
optimal objective function 6.098. The solution x = [ 1.301, 0, 1, 1, 0, 1 ]T recommended in [9]
is incorrect, since its objective function is 13.0098.
>> clear P; P.intcon=[4,5,6]; P.x0=[0,0,0,0,0,0]’;
P.objective=@(x)5*x(4)+6*x(5)+8*x(6)+10*x(1)-7*x(3) ...
-18*log(x(2)+1)-19.2*log(x(1)-x(2)+1)+10; % objective function
P.ub=[2 2 1 1 1 1]’; P.lb=[0 0 0 0 0 0]’; P.bineq=[0;0;0;1];
P.Aineq=[-1 1 0 0 0 0; 0 1 0 -2 0 0; 1 -1 0 0 -2 0; 0 0 0 1 1 0];
P.nonlcon=@c6mmibp; [errmsg,fm,x]=BNB20_new(P) % solve the problem
6.5.5
Assignment problems
The assignment problem is a special type of binary linear programming problem where
assignees are being assigned to perform tasks, under the following assumptions [7]:
(i) The number of assignees and the number of tasks are the same;
(ii) Each assignee is to be assigned to exactly one task;
(iii) Each task is to be performed by exactly one assignee.
Assume that the costs cij associated with assignee i performing task j are all known,
and the objective is to determine how all n assignments should be made to minimize the
total cost. The mathematical model of the typical assignment problem is expressed as
min
X s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎩
n

j=1
xij=1,i=1,2,··· ,n
n

i=1
xij=1,j=1,2,··· ,n
xijare binary numbers,i=1,2,··· ,n,j=1,2,··· ,n
n

i=1
n

j=1
cijxij,
(6-5-1)
and it can be seen that it is a special case of the transportation problem, with m = n,
si = 1 and di = 1. Besides, the decision variables are binary numbers.
A MATLAB function assignment prog() is written to solve the assignment problems.
The syntax of the function is X = assignment prog(C), where C is the cost matrix.

276
Scientiﬁc Computing with MATLAB®
function [x,fv,key]=assignment_prog(C)
[n,m]=size(C); c=C(:); A=[];b=[]; Aeq=zeros(2*n,n^2);
for i=1:n, Aeq(i,(i-1)*n+1:n*i)=1; Aeq(n+i,i:n:n^2)=1; end
beq=ones(2*n,1); xm=zeros(n^2,1); xM=ones(n^2,1);
[x,fv,key]=intlinprog(c,1:n^2,A,b,Aeq,beq,xm,xM); x=reshape(x,n,m).’;
Example 6.49
Please solve the assignment problem with a cost matrix
C =
⎡
⎢⎢⎢⎢⎣
12
7
9
7
9
8
9
6
6
6
7
17
12
14
9
15
14
6
6
10
4
10
7
10
9
⎤
⎥⎥⎥⎥⎦
.
Solution The cost matrix can be entered ﬁrst, and the problem can be solved directly
>> C=[12,7,9,7,9; 8,9,6,6,6; 7,17,12,14,9; 15,14,6,6,10; 4,10,7,10,9];
[X fv]=assignment_prog(C) % solve directly the assignment problem
The solution of the assignment problem can be found as
X =
⎡
⎢⎢⎢⎢⎣
0
0
0
0
1
1
0
0
0
0
0
1
0
0
0
0
0
0
1
0
0
0
1
0
0
⎤
⎥⎥⎥⎥⎦
, with fv = 32,
meaning the ﬁrst task is assigned to assignee 5, the second task is assigned to assignee 1,
and so on. In this case, the total cost is minimized to 32.
6.6
Linear Matrix Inequalities
The theory of linear matrix inequalities (LMI) has been attracting the attention of
research communities for a decade especially from researchers in the control systems
community [3]. The concept of LMI and its applications are based on the fact that LMIs can
be reduced to linear programming problems which can easily be solved by computers [11].
In this section, the concepts of LMI will be presented ﬁrst, followed by the MATLAB
solution examples using the Robust Control Toolbox, as well as a free YALMIP Toolbox.
6.6.1
A general introduction to LMIs
Linear matrix inequalities can be generally described as
F (x) = F0 + x1F1 + · · · + xmFm < 0,
(6-6-1)
where x = [x1, · · · , xm]T is the coeﬃcient vector of a polynomial. It is also referred to as
a decision vector. The matrices Fi are Hermitian matrices. If the LMI matrix F (x) is a
negative-deﬁnite matrix, the solution set is convex, i.e.,
F [αx1 + (1 −α)x2] = αF (x1) + (1 −α)F (x2) < 0,
(6-6-2)

Nonlinear Equations and Numerical Optimization Problems
277
where α > 0, 1 −α > 0. The solution is also referred to as the feasible solution. From two
such LMIs F1(x) < 0 and F2(x) < 0, a single LMI can be constructed such that

F1(x)
0
0
F2(x)

< 0.
(6-6-3)
It can be seen that several LMIs Fi(x) < 0, i = 1, 2, · · · , k can be combined into a single
LMI such that F (x) < 0, where
F (x) =
⎡
⎢⎢⎢⎣
F1(x)
F2(x)
...
Fk(x)
⎤
⎥⎥⎥⎦< 0.
(6-6-4)
6.6.2
Lyapunov inequalities
Consider ﬁrst the Lyapunov stability problem. Lyapunov theory states that for a given
positive-deﬁnite matrix Q, if the Lyapunov equation
ATX + XA = −Q
(6-6-5)
has positive-deﬁnite solution X, the matrix A is stable, i.e., all the eigenvalues of the matrix
are located in the left-hand-side of the complex plane. The previous equation can also be
converted into a Lyapunov inequality
ATX + XA < 0.
(6-6-6)
Since X is a symmetrical matrix, a vector x containing the n(n + 1)/2 elements can be
used to describe the original matrix such that
xi = Xi,1,
i = 1, · · · , n, xn+i = Xi,2, i = 2, · · · , n, · · · ,
(6-6-7)
and it follows that
x(2n−j+2)(j−1)/2+i = Xi,j,
j = 1, 2, · · · , n,
i = j, j + 1, · · · , n.
(6-6-8)
A MATLAB function can be created for the above conversion as follows:
function F=lyap2lmi(A0)
if prod(size(A0))==1, n=A0; A=sym(’a%d%d’,n); % symbolic matrix
else, n=size(A0,1); A=A0; end
vec=0; for i=1:n, vec(i+1)=vec(i)+n-i+1; end
for k=1:n*(n+1)/2,
X=zeros(n); i=find(vec>=k); i=i(1)-1; j=i+k-vec(i)-1;
X(i,j)=1; X(j,i)=1; F(:,:,k)=A.’*X+X*A;
end
The function can be called by F = lyap2lmi(A), where A can be a double-precision
matrix. Note that if A is simply an integer, it indicates a square symbolic matrix to be
established. The returned argument F is a three-dimensional array, and F ( :, :, i) is the Fi
matrix.

278
Scientiﬁc Computing with MATLAB®
Example 6.50 If in the Lyapunov inequality A =
⎡
⎣
1
2
3
4
5
6
7
8
0
⎤
⎦, ﬁnd its LMI representation.
For a 3 × 3 matrix A, display its LMI form.
Solution The matrix A is entered by the statements
>> A=[1,2,3; 4,5,6; 7,8,0]; F=lyap2lmi(A)
and it can be found that the Fi matrices are
x1
⎡
⎣
2
2
3
2
0
0
3
0
0
⎤
⎦+ x2
⎡
⎣
8
6
6
6
4
3
6
3
0
⎤
⎦+ x3
⎡
⎣
14
8
1
8
0
2
1
2
6
⎤
⎦
+x4
⎡
⎣
0
4
0
4
10
6
0
6
0
⎤
⎦+ x5
⎡
⎣
0
7
4
7
16
5
4
5
12
⎤
⎦+ x6
⎡
⎣
0
0
7
0
0
8
7
8
0
⎤
⎦< 0.
For a symbolic 3 × 3 matrix, the following statement can be given instead
>> F=lyap2lmi(3) % generate symbolic expression
such that the LMI can be written as
x1
⎡
⎣
2a11
a12
a13
a12
0
0
a13
0
0
⎤
⎦+ x2
⎡
⎣
2a21
a22+a11
a23
a22+a11
2a12
a13
a23
a13
0
⎤
⎦+ x3
⎡
⎣
2a31
a32
a33+a11
a32
0
a12
a33+a11
a12
2a13
⎤
⎦
+ x4
⎡
⎣
0
a21
0
a21
2a22
a23
0
a23
0
⎤
⎦+ x5
⎡
⎣
0
a31
a21
a31
2a32
a33 + a22
a21
a33 + a22
2a23
⎤
⎦+x6
⎡
⎣
0
0
a31
0
0
a32
a31
a32
2a33
⎤
⎦< 0.
Some nonlinear inequalities can be converted into LMIs, too. For instance, for a
partitioned matrix F (x) =
⎡
⎣F11(x) F12(x)
F21(x) F22(x)
⎤
⎦, if F11(x) is a square matrix, the following
three cases are equivalent:
F (x) < 0
(6-6-9)
F11(x) < 0,
F22(x) −F21(x)F −1
11 (x)F12(x) < 0
(6-6-10)
F22(x) < 0,
F11(x) −F12(x)F −1
22 (x)F21(x) < 0.
(6-6-11)
The above property is known as Schur complement.
Consider an algebraic Riccati inequality
ATX + XA + (XB −C)R−1(XB −CT)T < 0,
(6-6-12)
where R = RT > 0. Due to its quadratic term, it is not an LMI. However, with
Schur complement, the original nonlinear inequality can be converted equivalently into the
following LMIs
X > 0,
 
ATX + XA XB −CT
BTX −C
−R
!
< 0.
(6-6-13)

Nonlinear Equations and Numerical Optimization Problems
279
6.6.3
Classiﬁcation of LMI problems
LMI problems can be classiﬁed into three typical problems, i.e., the feasible solution
problems, linear objective function minimization problems and the generalized eigenvalue
problems.
(i) Feasible solution problem
The so-called feasible solution problem is in fact the
feasible region problem in optimization, i.e., for the inequality
F (x) < 0,
(6-6-14)
ﬁnd a feasible solution. The feasible solution problem is to ﬁnd the solution F (x) < tminI,
where the minimum tmin is to be found. If tmin < 0 can be found, there exist solutions to
the original problem, otherwise, there is no feasible solution.
(ii) Linear objective function minimization problems
Consider the problem
min
x s.t. F (x)<0 cTx.
(6-6-15)
Since the constraints are given as LMIs, and the objective function is also linear, this
problem can also be solved using ordinary linear programming methods.
(iii)
The generalized eigenvalue problems
The generalized eigenvalue problem
is most commonly seen in LMI optimizations. Recall the generalized eigenvalue problem in
Chapter 4, which is expressed as Ax = λBx. Such a problem can be expressed by general
matrix functions as A(x) < λB(x), and λ can be regarded as the generalized eigenvalue.
Therefore, the optimization problem becomes
min
λ,x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
A(x)<λB(x)
B(x)>0
C(x)<0
λ.
(6-6-16)
Other constraints can be written as C(x) < 0. The generalized eigenvalue problem can be
expressed as a special LMI problem.
6.6.4
LMI problem solutions with MATLAB
The LMI solver in MATLAB is currently provided in the Robust Control Toolbox.
However, the way of describing the LMIs are quite complicated. An example is presented
to show in detail the uses of the LMI solver.
The following procedures are used to describe LMIs in MATLAB:
(i) Create an LMI model
An LMI framework can be established with setlmis([])
function. Therefore, a framework can be established in MATLAB workspace.
(ii)
Deﬁne the decision variables
The decision variables can be declared by
lmivar() function, with P = lmivar(key,[n1,n2]), where key speciﬁes the type of the
decision matrix, with key = 2 for an ordinary n1 × n2 matrix P , while key= 1 for an
n1 × n1 symmetrical matrix. If key = 1, n1 and n2 are both vectors, P is a block diagonal
symmetrical matrix. If key = 3, P is a special matrix, which is not discussed in this book.
The interested readers may refer to the Robust Control Toolbox manual [12].
(iii)
Describe LMIs in partitioned form
The LMIs can be described by the
lmiterm() function and its syntax is quite complicated
lmiterm([k,i,j,P ],A,B,flag)
where k is the number of the LMIs. Since an LMI problem may be described by several

280
Scientiﬁc Computing with MATLAB®
LMIs, one should number each of them. If an LMI is given Gk(x) > 0, then, k should be
described by −k. A term in a block in the partitioned matrix can be described by lmiterm()
function, with i, j representing respectively the row and column numbers of the block. P
is the declared decision variables, and the matrices A, B indicate the matrices in the term
AP B. If flag is assigned as ’s’, the symmetrical term AP B + (AP B)T is speciﬁed. If
the whole term is a constant matrix, P is set to 0, and matrix B is omitted.
(iv) Conﬁrm the LMI model
After all the LMIs are declared by the lmiterm()
function, G = getlmis can be used to conﬁrm the model G.
(v)
Solve the LMI problem
For the declared G model, the LMI optimization
problems can be solved in one of the following three forms
[tmin,x] = feasp(G,options,target)
% feasible solution
[copt,x] = mincx(G,c,options,x0,target)
% linear objective function
[λ,x] = gevp(G,nlfc,options,λ0,x0,target)
% generalized eigenvalues
The solution x thus obtained is a vector, and the dec2mat() function can be used to
extract the matrix. The control variable options is deﬁned as a 5-element vector, whose
ﬁrst element declares the precision requirement, with its default value of 10−5.
Example 6.51
For the Riccati inequality ATX + XA + XBR−1BTX + Q < 0, where
A =
⎡
⎣
−2
−2
−1
−3
−1
−1
1
0
−4
⎤
⎦, B =
⎡
⎣
−1
0
0
−1
−1
−1
⎤
⎦,
Q =
⎡
⎣
−2
1
−2
1
−2
−4
−2
−4
−2
⎤
⎦,
R = I2,
ﬁnd a feasible positive-deﬁnite solution X.
Solution The original nonlinear matrix inequality is obvious not an LMI. Using the Schur
complement, this Riccati inequality can be expressed by a partitioned LMI as follows. Also,
since a positive-deﬁnite solution is expected, the second LMI can be established
 
ATX+XA+Q XB
BTX
−R
!
< 0,
and X > 0.
One may number the Riccati inequality as no. 1, and the positive-deﬁnite inequality as
no. 2. Thus, one can set k to 1 and 2 respectively in using the lmiterm() function. It
should also be noted that the matrix X is a 3×3 symmetrical matrix. Therefore, the feasible
solution to the original problem can be obtained with the following statements. It should also
be noted that since the second inequality is X > 0, its number should be −2 instead of 2.
>> A=[-2,-2,-1; -3,-1,-1; 1,0,-4]; B=[-1,0; 0,-1; -1,-1];
Q=[-2,1,-2; 1,-2,-4; -2,-4,-2]; R=eye(2); % enter the matrices
setlmis([]);
% create a blank LTI framework
X=lmivar(1,[3 1]);
% declare X as a 3 × 3 symmetrical matrix
lmiterm([1 1 1 X],A’,1,’s’) % (1, 1)th block, ’s’ means ATX + XA
lmiterm([1 1 1 0],Q)
% (1, 1)th, appended by constant matrix Q
lmiterm([1 1 2 X],1,B)
% (1, 2)th, meaning XB
lmiterm([1 2 2 0],-1)
% (2, 2)th, meaning −R
lmiterm([-2,1,1,X],1,1)
% the second inequality meaning X > 0
G=getlmis;
% complete the LTI framwork setting
[tmin b]=feasp(G);
% solve the feasible problem
X=dec2mat(G,b,X)
% extract the solution matrix X

Nonlinear Equations and Numerical Optimization Problems
281
It is found that tmin = −0.2427, and the feasible solution to the original problem is
X =
⎡
⎣
1.0329
0.4647
−0.23583
0.4647
0.77896
−0.050684
−0.23583
−0.050684
1.4336
⎤
⎦.
It is worth mentioning that, due to possible problems in the new Robust Control Toolbox,
if the command lmiterm([1 2 1 X],B’,1) is used to describe the symmetrical term in
the ﬁrst inequality, wrong results were found. Thus, the symmetrical terms should not be
described again in solving LMI problems.
6.6.5
Optimization of LMI problems by YALMIP Toolbox
The YALMIP Toolbox released by Dr. Johan L¨ofberg is a more ﬂexible general
purpose optimization language in MATLAB, with support also for LMI problems [13]. The
description of LMI problems is much simpler and more straightforward than the ones in
the Robust Control Toolbox. The YALMIP Toolbox can be downloaded for free from The
MathWorks Inc.’s ﬁle-exchange site. The toolbox is also provided with the companion CD.
Decision variables can be declared in YALMIP Toolbox with sdpvar() function, which
can be called in the following ways
X = sdpvar(n)
% symmetrical matrix description
X = sdpvar(n,m)
% rectangular matrix declaration
X = sdpvar(n,n,’full’)
% declaration of a square asymmetrical matrix
The decision variables declared previously can further be treated, for instance, hankel()
function can be applied on a decision vector to form the decision matrix in Hankel form.
Similarly, the functions intvar() and binvar() can be used to declare integer and binary
variables, respectively; thus, integer programming and binary programming problems can
be handled.
For sdpvar decision variables, the symbols [ and ] can be used to describe LMIs. If
there are many LMIs, they can be joined together with the , sign, to form a single LMI
representation.
An objective function, when necessary, can also be described, and the LMI optimization
programs can be solved with the following syntaxes
s = solvesdp(F)
% ﬁnd a feasible solution
s = solvesdp(F,f)
% optimization with objective function f
s = solvesdp(F,f,options) % options allowed such as algorithm selection
where F is the collection of constraints. After the solution, the X = double(X) command
can be used to extract the solution matrix X.
Example 6.52
With the use of the YALMIP Toolbox, the problem in Example 6.51 can
be solved using simpler commands such that
>> A=[-2,-2,-1; -3,-1,-1; 1,0,-4]; B=[-1,0; 0,-1; -1,-1];
Q=[-2,1,-2; 1,-2,-4; -2,-4,-2]; R=eye(2); X=sdpvar(3);
F=[[A’*X+X*A+Q, X*B; B’*X, -R]<0, X>0];
sol=solvesdp(F); X=double(X) % solve the LMI problem

282
Scientiﬁc Computing with MATLAB®
and it can be seen that the results are exactly the same.
Example 6.53
Solve the linear programming problem in Example 6.29 again.
Solution For simplicity, the original problem can be rewritten as
min
x
s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
2x2+x3+4x4+2x5⩽54
3x1+4x2+5x3−x4−x5⩽62
x1,x2⩾0,x3⩾3.32,x4⩾0.678,x5⩾2.57
−2x1 −x2 −4x3 −3x4 −x5.
It is obvious that x is a 5 × 1 column vector, and the original problem can be solved with
the following statements
>> x=sdpvar(5,1); % declare decision variable is a 5 × 1 double vector
F=[2*x(2)+x(3)+4*x(4)+2*x(5)<=54,
% specify the two constraints
3*x(1)+4*x(2)+5*x(3)-x(4)-x(5)<=62,
x>=[0;0;3.32;0.678;2.57]];
% specify the lower bounds
sol=solvesdp(F,-[2 1 4 3 1]*x); x=double(x) % solve directly the problem
and the solution is x = [19.785, 0, 3.32, 11.385, 2.57]T, which is exactly the same as the one
obtained in the original example. Now assuming that the decision variables are integers
with the intvar() function, the integer linear programming problem can be solved by the
following scripts:
>> x=intvar(5,1); % declare decision variable is a 5 × 1 integer vector
F=[2*x(2)+x(3)+4*x(4)+2*x(5)<=54,
% specify the two constraints
3*x(1)+4*x(2)+5*x(3)-x(4)-x(5)<=62,
x>=[0;0;3.32;0.678;2.57]];
% specify the lower bounds
sol=solvesdp(F,-[2 1 4 3 1]*x); x=double(x) % solve LMI problem
which gives the solution x = [19, 0, 4, 10, 5]T, the same as the one in Example 6.39.
Example 6.54
For a linear system (A, B, C, D), its H∞norm can directly be evaluated
by norm() function. The norm evaluation problem can also be posed into the following LMI
framework
min
γ, P
s.t.
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
⎡
⎣
ATP + P A
P B
CT
BTP
−γI
DT
C
D
−γI
⎤
⎦< 0
P > 0
γ.
(6-6-17)
Find the H∞norm for the system
A =
⎡
⎢⎢⎣
−4
−3
0
−1
−3
−7
0
−3
0
0
−13
−1
−1
−3
−1
−10
⎤
⎥⎥⎦, B =
⎡
⎢⎢⎣
0
−4
2
5
⎤
⎥⎥⎦, C = [ 0, 0, 4, 0 ], D = 0.
Solution With the YALMIP Toolbox, the H∞norm is computed to 0.4640, which is quite
close to the value obtained by the norm() function.
>> A=[-4,-3,0,-1; -3,-7,0,-3; 0,0,-13,-1; -1,-3,-1,-10];
B=[0; -4; 2; 5]; C=[0,0,4,0]; D=0; gam=sdpvar(1); P=sdpvar(4);
F=[[A*P+P*A’,P*B,C’; B’*P,-gam,D’; C,D,-gam]<0, P>0];
sol=solvesdp(F,gam); double(gam), norm(ss(A,B,C,D),’inf’)

Nonlinear Equations and Numerical Optimization Problems
283
6.7
Solutions of Multi-objective Programming Problems
The optimization problems discussed so far are assumed scalar objective function f(x),
and those problems are single-objective function problems. If the objective function is a
vector F (x), the problem is referred to as multi-objective programming problems. In this
section, an introduction is made on multi-objective programming problems.
6.7.1
Multi-objective optimization model
The general form of multi-objective programming problem is
J =
min
x s.t. G(x)⩽0
F (x),
(6-7-1)
where, F (x) = [f1(x), f2(x), · · · , fp(x)]T. An example of multi-objective modeling will be
given, and physical interpretation will be illustrated.
Example 6.55
Assume that three kinds of candies, A1, A2, A3, are supplied in the shop,
and the prices are respectively $4, $2.8 and $2.4 per kilogram. If one wants to buy some
candies, total cost cannot exceed $20, total weight cannot be less than 6kg, and the total
weight of candies A1 and A2 cannot be less than 3kg. How should he design the best
purchasing plan? (source of data from [14])
Solution The ﬁrst thing in solving such a problem is how to deﬁne the “best” purchasing
plan. In this example, the best plan is to have the least cost, while buy the heaviest candies.
Thus, the two objective functions should be introduced, and it is obvious that the these two
objective functions are in conﬂict. The other conditions can be regarded as the constraints.
The modeling procedure is needed in this example. Assume that the purchased weights of
the three kinds of candies A1, A2, A3 are respectively x1, x2 and x3 kg’s, respectively, the
two objective functions can be written as
cost: f1(x) = 4x1 + 2.8x2 + 2.4x3 →min,
total weight: f2(x) = x1 + x2 + x3 →max.
If they are uniﬁed as a minimization problem, and considering the constraints, the multi-
objective programming model can be established as
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
4x1+2.8x2+2.4x3⩽20
x1+x2+x3⩾6
x1+x2⩾3
x1,x2,x3⩾0
 
4x1 + 2.8x2 + 2.4x3
−(x1 + x2 + x3)
!
.
6.7.2
Least squares solutions of unconstrained multi-objective program-
ming problems
Assume that multi-objective function is given by
F (x) = [f1(x), f2(x), · · · , fp(x)]T,

284
Scientiﬁc Computing with MATLAB®
the unconstrained optimization problem can be converted into the following single-objective
programming problem
min
x s.t.xm⩽x⩽xM
f 2
1 (x) + f 2
2 (x) + · · · + f 2
p(x).
(6-7-2)
The converted single-objective programming problem can be solved directly with the
approaches discussed earlier. Also, the lsqnonlin() in MATLAB can be used to solve the
problem, with the syntax
[x,nf,fopt,flag,c]= lsqnonlin(fun,x0,xm,xM)
where, fun is the MATLAB description of the objective function vector, it can either be
M-functions or anonymous functions. The argument x0 is the initial search point vector.
The optimal solution and objective function are returned in vectors x and fopt, and the
norm is returned in variable nf.
Example 6.56 Please ﬁnd the least squares solution for the following unconstrained multi-
objective nonlinear programming problem.
min
x s.t.
⎡
⎢⎢⎣
0
0
0
⎤
⎥⎥⎦⩽x⩽
⎡
⎢⎢⎣
3
π
5
⎤
⎥⎥⎦
 
(x1 + 2x2 + 3x3) sin(x1 + x2)e−x2
1−x2
3 + 5x3
e−x2
2−4x3
2 cos(4x1 + x2)
!
.
Solution The vector form of the objective function can be speciﬁed ﬁrst, and the problem
can be solved with the following statements, and the result obtained is x=[2.9998, 3.1415, 0].
>> f=@(x)[(x(1)+2*x(2)+3*x(3))*sin(x(1)+x(2))*...
exp(-x(1)^2-x(3)^2)+5*x(3); % the 2 objective functions
exp(-x(2)^2-4*x(2)^3)*cos(4*x(1)+x(2))];
xm=[0; 0; 0]; xM=[3; pi; 5]; x0=xM; x=lsqnonlin(f,x0,xm,xM)
In fact, the objective function can be redeﬁned, and with the fmincon() function, the
problem can be solved and the solution obtained is x = [3, 3.1416, 0]. It is worth mentioning
that, the latter method can also be used in ﬁnding least squares solutions to problems with
constraints.
>> G=@(x)f(x)’*f(x); x=fmincon(G,x0,[],[],[],[],xm,xM)
6.7.3
Converting multi-objective problems into single-objective ones
There are a great amount of numerical algorithms used in solving single-objective
optimization problems, to use them in solving multi-objective programming problems, the
latter must be converted to single-objective programming problems. In this section, the
conversion methods such as weighting method, least squares method are presented.
I. Linear weighting transforms
In order to convert a multi-objective programming problem into a single-objective one,
the simplest way is to introduce weighting on each objective function and sum them up.

Nonlinear Equations and Numerical Optimization Problems
285
The new objective function in scalar form can be written as
f(x) = w1f1(x) + w2f2(x) + · · · + wpfp(x),
(6-7-3)
where, w1 + w2 + · · · + wp = 1, and 0 ⩽w1, w2, · · · , wp ⩽1.
Example 6.57
Try diﬀerent weights, and solve the problem in Example 6.55.
Solution
The original problem can be converted to the following single-objective linear
programming problem
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
4x1+2.8x2+2.4x3⩽20
−x1−x2−x3⩽−6
−x1−x2⩽−3
x1,x2,x3⩾0
(w1[4, 2.8, 2.4] −w2[1, 1, 1])x.
The best purchasing plans can be computed under diﬀerent weights, using the loop
structure, and the results are shown in Table 6.5. It can be seen that under diﬀerent selections
of the weighting coeﬃcients, the best purchasing plans are also diﬀerent. Besides, x1 ≡0,
this is because there are no speciﬁc constraints on x1, the value of it should be made as small
as possible.
>> f1=[4,2.8,2.4]; f2=[-1,-1,-1]; Aeq=[]; Beq=[]; xm=[0;0;0]; C=[];
A=[4 2.8 2.4; -1 -1 -1; -1 -1 0]; B=[20;-6;-3]; ww1=[0:0.1:1];
for w1=ww1, w2=1-w1; % try diﬀerent weighting
x=linprog(w1*f1+w2*f2,A,B,Aeq,Beq,xm); C=[C; w1 w2 x’ f1*x -f2*x]
end
TABLE 6.5: Optimal plans under diﬀerent weighting coeﬃcients.
w1
w2
x1
x2
x3
cost
weight
w1
w2
x1
x2
x3
cost
weight
0
1
0
3
4.8333
20
7.8333
0.6
0.4
0
3
3
15.6
6
0.1
0.9
0
3
4.8333
20
7.8333
0.7
0.3
0
3
3
15.6
6
0.2
0.8
0
3
4.8333
20
7.8333
0.8
0.2
0
3
3
15.6
6
0.3
0.7
0
3
3
15.6
6
0.9
0.1
0
3
3
15.6
6
0.4
0.6
0
3
3
15.6
6
1
0
0
3
3
15.6
6
0.5
0.5
0
3
3
15.6
6
II. Best compromise solutions to linear programming problems
Consider the following multi-objective linear programming problem
J = max
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
Ax⩽B
Aeqx=Beq
xm⩽x⩽xM
Cx,
(6-7-4)
where, the objective function coeﬃcients are a matrix, rather than a vector. Each objective
function fi(x) = cix, i = 1, 2, · · · , p can be considered as the beneﬁt of the ith party, and

286
Scientiﬁc Computing with MATLAB®
the best compromise solution is the compromise of the decision, on the beneﬁt of all the
parties. Of course, under the constraints and the interactions among the parties, it is not
possible to let every party gain its maximum beneﬁt. Some compromise must be made by
all parties. The best compromise solution can be found uniquely. The procedures in ﬁnding
the best compromise solution is as follows:
(i) Solve individually the linear programming problems for each objective function, and
ﬁnd the values of the objective functions fk, k = 1, 2, · · · , p.
(ii) The single-objective function can be constructed
f(x) = −1
f1
c1x −1
f2
c2x −· · · −1
fp
cpx.
(6-7-5)
(iii) The best compromise solution can be converted into the following single-objective
linear programming problem
J = min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
Ax⩽B
Aeqx=Beq
xm⩽x⩽xM
f(x).
(6-7-6)
Based on the above algorithm, a MATLAB function can be written to ﬁnd the best
compromise solution of multi-objective linear programming problems, where the maximum
value is found
function [x,f,flag,cc]=linprog_c(C,A,B,Aeq,Beq,xm,xM)
[p,m]=size(C); c=0;
for i=1:p, [x,f]=linprog(C(i,:),A,B,Aeq,Beq,xm,xM); c=c-C(i,:)/f; end
[x,f,flag,cc]=linprog(c,A,B,Aeq,Beq,xm,xM);
Example 6.58
Find the best compromise solution of the problem in Example 6.55.
Solution It can be seen that the best compromise solution can be obtained with the following
statements, and the results are x = [0, 3, 4.8333]T, with total cost of $20, and total weight
of candies 7.8333 kg.
>> C=[-4 -2.8 -2.4; 1 1 1]; A=[4 2.8 2.4; -1 -1 -1; -1 -1 0];
B=[20; -6; -3]; Aeq=[]; Beq=[]; xm=[0;0;0]; xM=[];
x=linprog_c(C,A,B,Aeq,Beq,xm,xM), C*x
Example 6.59
Find the best compromise solution of the following problem
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
2x1+4x2+x4⩽110
5x3+3x4⩾180
x1+2x2+6x3+5x4⩽250
x1,x2,x3,x4⩾0
⎡
⎢⎢⎢⎣
3x1 + x2 + 6x4
10x2 + 7x4
2x1 + x2 + 8x3
x1 + x2 + 3x3 + 2x4
⎤
⎥⎥⎥⎦.
Solution
From the multi-objective linear programming problem, matrix C can be
constructed, together with the other constraints, the best compromise solution can be found
with linprog c() function, and the result is x = [0, 26.087, 32.6087, 5.6522]T, and the
compromised objective functions [60, 300.4348, 286.9565, 135.2174]T.

Nonlinear Equations and Numerical Optimization Problems
287
>> C=-[3,1,0,6; 0,10,0,7; 2,1,8,0; 1,1,3,2];
A=[2,4,0,1; 0,0,-5,-3; 1,1,6,5]; B=[110; -180; 250];
Aeq=[]; Beq=[]; xm=[0;0;0;0]; xM=[];
x=linprog_c(C,A,B,Aeq,Beq,xm,xM), -C*x
III. Least squares solutions of linear programming problems
Consider the least squares representation of the multi-objective programming problem
given by
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
Ax⩽B
Aeqx=Beq
xm⩽x⩽xM
1
2 || Cx −d ||2,
(6-7-7)
the least squares solution can be obtained with
x = lsqlin(C,d,A,B,Aeq,Beq,xm,xM,x0,options)
and since the problem is a convex problem, the selection of x0 is not important.
Example 6.60
Consider again the multi-objective linear programming problem in
Example 6.59, please ﬁnd its least squares solution.
Solution
From the given problem, the matrix C
is established, and other con-
straints can be speciﬁed. The lsqlin() function can be used to solve the problem,
and the result is x = [0, 0, 28.4456, 12.5907]T, and the optimal objective functions are
[75.544, 88.1347, 227.5648, 110.5181]T.
>> C=[3,1,0,6; 0,10,0,7; 2,1,8,0; 1,1,3,2]; d=zeros(4,1);
A=[2,4,0,1; 0,0,-5,-3; 1,1,6,5]; B=[110; -180; 250]; Aeq=[]; Beq=[];
xm=[0;0;0;0]; xM=[]; x=lsqlin(C,d,A,B,Aeq,Beq,xm,xM), C*x
Please note that, since the solution algorithm and target are diﬀerent from the best
compromise method, the solutions are also diﬀerent.
6.7.4
Pareto front of multi-objective programming problems
It can be seen from the previous discussion that the solutions to multi-objective pro-
gramming problems are not unique. Now, let us consider the multi-objective programming
problem as an alternative. Assume that one of the objective functions is expressed by some
scatters, then, the number of objective functions is reduced by one. New results may be
found, if multi-objective programming problems are treated in this way.
Example 6.61
Reexamine the multi-objective optimization problem studied in Example
6.55 using scatters.
Solution Assume that the total cost in the original problem is represented by a series of
scatters mi ∈(15, 20), then, the original problem can be converted to a single-objective linear
programming problem.

288
Scientiﬁc Computing with MATLAB®
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
4x1+2.8x2+2.4x3=mi
−x1−x2−x3⩽−6
−x1−x2⩽−3
x1,x2,x3⩾0
−[ 1, 1, 1 ]x.
The above formula means that, if the total cost is mi, what is the maximum weight of
candies that can be purchased under the constraints. In this way, the largest weight ni can be
obtained. For diﬀerent values of mi, diﬀerent ni can be obtained. The relationship between
cost and total weight are shown in Figure 6.13. Please note that not all the scatters in the
plane the solutions of multi-objective optimization problems, since the optimization of mi
was not yet considered.
>> f2=[-1,-1,-1]; Aeq=[4 2.8 2.4]; xm=[0;0;0];
A=[-1 -1 -1; -1 -1 0]; B=[-6;-3]; mi=15:0.1:20; ni=[];
for m=mi, Beq=m; x=linprog(f2,A,B,Aeq,Beq,xm); ni=[ni,-f2*x]; end
plot(mi,ni)
15
15.5
16
16.5
17
17.5
18
18.5
19
19.5
20
6
6.2
6.4
6.6
6.8
7
FIGURE 6.13: The relationship of the two objective functions.
Consider double-objective programming problem. The scatters of feasible solutions can
be obtained ﬁrst, and shown in x-y plane, as shown in Figure 6.14. Since the targets of the
original problem is to let the two axes f1 and f2 take smallest values, a curve can be extracted
from the scatters. All the points on the curve are the solutions of the original problem, and
the curve is referred to as Pareto set or Pareto front. Based on the Pareto front extracting
function contributed by Gianluca Dorini, Yi Cao developed an improved fast extracting
package [15], the syntax of the main function is K = paretofront([f1,f2,· · · ,fp]), where,
f1, f2, · · · , fp are column vectors composed of scatters of the feasible solutions.
Example 6.62
Please extract the Pareto front from Example 6.55.
Solution
Similar to the enumerate method, mesh grids of the variables x1, x2, x3 are
generated, and those points outside the feasible regions are removed. The Pareto front can
be extracted with paretofront(), as shown in Figure 6.15.
>> [x1,x2,x3]=meshgrid(0:0.1:4);
ii=find(4*x1+2.8*x2+2.4*x3<=20&x1+x2+x3>=6&x1+x2>=3);

Nonlinear Equations and Numerical Optimization Problems
289
-
6
f1
f2
feasible solutions
Pareto front
O
FIGURE 6.14: Illustration of Pareto front.
xx1=x1(ii); xx2=x2(ii); xx3=x3(ii); f1=4*xx1+2.8*xx2+2.4*xx3;
f2=-(xx1+xx2+xx3); k=paretofront([f1 f2]);
plot(f1,f2,’x’), hold on; plot(f1(k),f2(k),’o’)
15.5
16
16.5
17
17.5
18
18.5
19
19.5
20
−7.8
−7.6
−7.4
−7.2
−7
−6.8
−6.6
−6.4
−6.2
−6
−5.8
FIGURE 6.15: Pareto front in Example 6.55.
6.7.5
Solutions of minimax problems
A class of important problems in multi-objective programming problems is the minimax
problems. Assume that there are a group of p objective functions fi(x), i = 1, 2, · · · , p, a
maximum value can be extracted from each objective function, i.e.,
max
x s.t. G(x)⩽0 fi(x), and
the set of maximum values are still a function of x. The minimum value from the set of
maximum values is expected, i.e.,
J = min

max
x s.t. G(x)⩽0
fi(x)

,
(6-7-8)
and this kind of problem is referred to as a minimax problem. If the maximum value is
interpreted as a worst case, or maximum loss, minimax problem is to ﬁnd a way to minimize

290
Scientiﬁc Computing with MATLAB®
the losses. Constrained minimax problems are generally written as
J = min max
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
Ax⩽B
Aeqx=Beq
xm⩽x⩽xM
C(x)⩽0
Ceq(x)=0
fi(x).
(6-7-9)
Function fminimax() provided in MATLAB Optimization Toolbox can be used in
solving minimax problems. The syntax of the function is
[x,fopt,flag,c]= fminimax(fun,x0,A,B,Aeq,Beq,xm,xM,CFun,options,p1,p2,· · · )
and it can be seen that the syntax is very close to the fmincon() function. The multi-
objective function can also be expressed as M-functions or anonymous functions.
Example 6.63
Please solve the following minimax problem
min
max
x s.t.
⎧
⎨
⎩
4.3x1+3.8x2⩽4.9
x1+x2⩽3
⎡
⎢⎢⎢⎣
x2
1 sin x2 + x2 −3x1x2 cos x1
−x2
1e−x2 −x2
2e−x1 + x1x2 cos x1x2
x2
1 + x2
2 −2x1x2 + x1 −x2
−x2
1 −x2
2 cos x1x2
⎤
⎥⎥⎥⎦.
Solution The above minimax problem can be solved with the following statements directly,
with randomly selected initial search point, the solution of the original problem is x =
[0.5319, 0.6876].
>> f=@(x)[x(1)^2*sin(x(2))+x(2)-3*x(1)*x(2)*cos(x(1));
-x(1)^2*exp(-x(2))-x(2)^2*exp(-x(1))+x(1)*x(2)*cos(x(1)*x(2));
x(1)^2+x(2)^2-2*x(1)*x(2)+x(1)-x(2);
-x(1)^2-x(2)^2*cos(x(1)*x(2))];
A=[4.3 3.8; 1 1]; B=[4.9; 3]; x=fminimax(f,rand(2,1),A,B)
In fact, with function fminimax(), other variations of minimax problems can also be
solved, such as minimin problem
J = min

min
x s.t. G(x)⩽0
fi(x)

.
(6-7-10)
The problem can be converted to the following minimax problem
J = min

max
x s.t. G(x)⩽0
−fi(x)

.
(6-7-11)
6.7.6
Solutions of multi-objective goal attainment problems
In practical optimization problems, sometimes the feasible solutions cannot be found,
and the constraints should be relaxed to some extent. for instance, the inequality constraints
Ax ⩽B can be rewritten as Ax ⩽B + d−−d+. In the practical solution process, the

Nonlinear Equations and Numerical Optimization Problems
291
biases (d−, d+) are introduced into the objective function and to minimize the biases. This
type of optimization problem is referred to as a multi-objective goal attainment problem.
Function fgoalattain() provided in MATLAB Optimization Toolbox can be used in
solving multi-objective goal attainment problems, whose mathematical representation is
min
x,γ s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
F (x)−wγ⩽g
Ax⩽B
Aeqx=Beq
c(x)⩽0
ceq(x)=0
xm⩽x⩽xM
γ,
(6-7-12)
where, F (x) is the objective function vector, and w are the weights on the objective
functions. The vector g contains the values that the objectives attempt to attain. The
syntax of the function is
x = fgoalattain(fun,x0,g,w,A,B,Aeq,Beq,xm,xM,CFun,options,p1,p2,· · · )
Example 6.64
Solve the problem in Example 6.55 using goal attainment method.
Solution It is obvious that the accepted goals for the two objective functions are 20 and
−6. Apart from that, weights on the two objective functions should be introduced. If “less
cost” is concentrated, the weight of it can be assigned to 80%, while the weight on the other
is 20%. The following statements can be used in solving the original problem, and the result
obtained is x = [0, 3, 3.6875]T, with f(x) = [17.25, −6.6875]T.
>> f=@(x)[[4,2.8,2.4]*x; [-1 -1 -1]*x]; Aeq=[]; Beq=[]; xm=[0;0;0];
x0=xm; w=[0.8,0.2]; goal=[20; -6]; A=[-1 -1 0]; B=[-3];
x=fgoalattain(f,x0,goal,w,A,B,[],[],xm), f(x)
6.8
Dynamic Programming and Shortest Path Planning
The optimization problems discussed so far can be classiﬁed as static optimization
problems, since the objective functions and constraints are ﬁxed in the whole solution
process. In scientiﬁc research and engineering, we often meet another category of
optimization problem, where the programming problems consist of several overlapped
subproblems. The subproblems should be solved and combined to get the overall solution
of the whole problem. In ordinary problem solving strategies, since the subproblems are
related to each other, the subproblems are usually to be solved several times. It is the job
of dynamic programming to solve each subproblem only once, so as to minimize the time
used in the whole problem solution process.
Dynamic programming, which was proposed by Richard Bellman in the 1940s and
get matured in the late 1950s [16], is another area of optimization. The theory has many
applications, and in particular, it is useful in computer programming. In this section, the
application and solution of dynamic programming problems in shortest path planning of
oriented and other graphs are presented.

292
Scientiﬁc Computing with MATLAB®
6.8.1
Matrix representation of graphs
Before introducing the representation of graphs, some ideas about graphs are presented.
An example of a graph is shown in Figure 6.16 [17].
1
2
1
2
3
*
~
4
~

5
6
-
-
>
R
7
8
-
:
-
*
9
-
1
s
3
4
12
6
4
7
15
3
7
7
2
15
10
FIGURE 6.16: A typical oriented graph.
In graph theory, the graphs are constructed by nodes and edges. In the graph shown
in Figure 6.16, the nodes are the encircled numbers. The edge is the path that connects
directly to the nodes, and in the graph, the edges are the arrows between the nodes. If the
edge is one-directional, then, the graph is referred to as oriented or directed (also known as
a digraph), otherwise, it is referred to as an undigraph.
Apart from nodes and edges, the entities weights are also essential in graphs. The weights
are the numbers above the edges, which usually stand for the distance, or traveling time in
the edges.
There are diﬀerent ways to represent a graph, and the representation most suitable for
computer modeling is the incidence matrix method. If there are n nodes in a graph, it can
be described by an n × n matrix R. Assuming that the edge from node i to node j has a
weight of k, the matrix element can be expressed by R(i, j) = k. Such a matrix is referred
to as an incidence matrix. If there is no edge from node i to j, we can assign R(i, j) = 0.
However, certain algorithms may assign the element value to R(i, j) = ∞.
The sparse form representation of incidence matrices can also be used in MATLAB to
describe graphs. Suppose that a graph is composed of n nodes and m edges. It is known that
the ith edge is from node ai to node bi, and the edge has a weight of wi, i = 1, 2, · · · , m.
Three vectors can be established, and an incidence matrix can be declared in MATLAB
with the following statements
a = [a1,a2,· · · ,am,n]; b = [b1,b2,· · · ,bm,n]; % start and end nodes
w = [w1,w2,· · · ,wm,0]; R = sparse(a,b,w); % edge, incidence matrix
Note that the last element in each vector ensures a square incidence matrix R.
Sparse matrices and ordinary ones can be converted with functions full() and sparse(),
respectively.
6.8.2
Optimal path planning of oriented graphs
The oriented graph representation of optimal path searching can also be encountered
in many application areas. With dynamic programming theory, the method of backward
derivation is usually adopted from the destination to the starting node. An example will be
given to demonstrate the backward derivation methods. Then, a computer solution to the

Nonlinear Equations and Numerical Optimization Problems
293
same problem will be used with relevant functions in the Bioinformatics Toolbox, which is
the MATLAB implementation of the Dijkstra algorithms.
I. Solutions by dynamic programming technique
An example of an oriented graph is used to show dynamic programming with applications
to the shortest path problem. The problem is to be demonstrated with a manual solution
method ﬁrst.
Example 6.65
Please ﬁnd the shortest path in the oriented graph shown in Figure 6.16,
from nodes ①to ⑨, using dynamic programming method.
Solution The number on top of each edge indicates the shortest distance required to travel
from its starting node to the ending node. The shortest path from node ①to node ⑨has to
be calculated.
Consider the destination node, node ⑨. Mark the distance at the node as (0). Connected
to this node, there are three nodes, respectively, nodes ⑥, ⑦and ⑧. Since there is only one
edge to travel to the destination node, the shortest distances of these nodes are, respectively,
15, 3 and 10, that is, the weights of the edges. From node ⑤to node ⑦, there is only one
edge, therefore, the shortest distance from node ⑤is 10, that is, the sum of the distance
labeled on node ⑦plus the weight of the edge. Now let us ﬁnd the label on node ④. From node
④, there are edges to nodes ⑤, ⑥, ⑦and ⑧, respectively. Summing the weights separately to
the corresponding labels, the sums are, respectively, 14, 18, 17 and 17, being 14 the smallest.
Therefore, the label on node ④should be (14). In a similar way, the labels on node ②and ③
can be marked to (20) and (17), and the label on node ①can be marked as (19), the shortest
distance expected. From the above, it can be seen that the shortest path is nodes ①→③→
④→⑤→⑦→⑨, as shown in Figure 6.17.
(0)
(3)
(10)
(10)
(14)
(20)
(17)
(19)
(15)
~

>
-
s
1
2
1
2
3
*
4
~
5
6
-
-R
7
8
:
-
*
9
-
1
3
4
12
6
4
7
15
3
7
7
2
15
10
FIGURE 6.17: Manual solution to the oriented graph problem.
From the above, it can be seen that the method is quite straightforward and easy to
understand. However, for large-scale problems, manual derivation is extremely complicated
and error-prone. Computer solutions are necessary and will be explained later.
II. Search and illustration of oriented graphs
Some relevant functions are provided in the Bioinformatics Toolbox to solve graphs and
shortest path searching problems. For instance, to establish an object for an oriented graph,

294
Scientiﬁc Computing with MATLAB®
the function view() is used to display the object, and the function graphshortestpath()
is used to solve directly the shortest path problems. The syntaxes of these functions are
P = biograph(R)
% create an object P
[d,p] = graphshortestpath(P,n1,n2)
% ﬁnd the shortest path
where R is the incidence matrix of an oriented graph, expressed as either an ordinary or
a sparse matrix. The matrix can be processed by the biograph() function to establish
an object for the oriented graph. For the oriented graph shown in Figure 6.16, the matrix
element R(i, j) refers to the weight of the edge from node i to node j. Having established the
object P, function graphshortestpath() can be used to solve the shortest path problem
directly. The arguments n1 and n2 are, respectively, the starting and terminal node numbers.
The returned variable d is the shortest distance, while vector p returns the node numbers on
the shortest path. Other functions can be used to further show the search results graphically.
Example 6.66
Considering again the problem in Example 6.65, the MATLAB functions
in the Bioinformatics Toolbox can be used to reexamine the original problem.
Solution From Figure 6.16, it can be seen that the information of each edge in the graph is
summarized as shown in Table 6.6, where the starting node, ending node and the weight of
each edge are obtained. The following commands can be used to enter the incidence matrix
R, from which the graph is generated automatically with the view() function, and the handle
is assigned to h. The automatically drawn graph is shown in Figure 6.18(a). Note that when
constructing the incidence matrix R, you have to make sure that it is a square matrix.
>> a=[1 1 2 2 3 3 4 4 4 4 5 6 6 7 8]; b=[2 3 5 4 4 6 5 7 8 6 7 8 9 9 9];
w=[1 2 12 6 3 4 4 15 7 2 7 7 15 3 10]; R=sparse(a,b,w); R(9,9)=0;
obj=biograph(R); h=view(obj); h.ShowWeights=’on’; % show the graph
TABLE 6.6: Edge data.
start
end
weight
start
end
weight
start
end
weight
start
end
weight
1
2
1
1
3
2
2
5
12
2
4
6
3
4
3
3
6
4
4
5
7
4
7
15
4
8
7
4
6
2
5
7
7
6
8
7
6
9
15
7
9
3
8
9
10
For a given oriented graph object deﬁned in R, the function graphshortestpath() can
be used to ﬁnd the shortest path, and with the help of the view() function, the shortest path
is shown in red; the result is shown in Figure 6.18(b). It can be seen that the result obtained
is exactly the same as the one obtained manually.
>> [d,p]=graphshortestpath(R,1,9) % shortest path from node ①to node ⑨
set(h.Nodes(p),’Color’,[1 0.4 0.4])
edges=getedgesbynodeid(h,get(h.Nodes(p),’ID’));
set(edges,’LineColor’,[1 0 0])
% the path in red is the shortest

Nonlinear Equations and Numerical Optimization Problems
295
Node 1
Node 2
Node 3
Node 4
Node 5
Node 6
Node 7
Node 8
Node 9
 1 
 2 
 6 
 12 
 3 
 4 
 4 
 2 
 15 
 7 
 7 
 7 
 15 
 3 
 10 
Node 1
Node 2
Node 3
Node 4
Node 5
Node 6
Node 7
Node 8
Node 9
 1 
 2 
 6 
 12 
 3 
 4 
 4 
 2 
 15 
 7 
 7 
 7 
 15 
 3 
 10 
(a) automatic drawing
(b) shortest path display
FIGURE 6.18: Oriented graph and solution of shortest path program.
III. Dijkstra shortest path algorithm and its implementation
The shortest path between two nodes can be obtained directly with Dijkstra algo-
rithm [18]. In fact, if the starting node is assigned, the shortest paths to all the other nodes
can be obtained together, without sacriﬁcing searching speed. In shortest path algorithms,
Dijkstra algorithm is the most eﬀective one. Based on Dijkstra algorithm, the following
function is written
function [d,path]=dijkstra(W,s,t)
[n,m]=size(W); ix=(W==0); W(ix)=Inf;
if n~=m, error(’Square W required’); end
visited(1:n)=0; dist(1:n)=Inf; parent(1:n)=0; dist(s)=0; d=Inf;
for i=1:(n-1),
%
ﬁnd the relation between each node and the origin
ix=(visited==0); vec(1:n)=Inf; vec(ix)=dist(ix);
[a,u]=min(vec); visited(u)=1;
for v=1:n, if (W(u,v)+dist(u)<dist(v)),
dist(v)=dist(u)+W(u,v); parent(v)=u;
end; end; end
if parent(t)~=0, path=t; d=dist(t); %
trace back to ﬁnd the shortest path
while t~=s, p=parent(t); path=[p path]; t=p; end
end
The function can be called with [d,p] = dijkstra(W ,s,t), where W is the square
incidence matrix, and s, t are, respectively, the serial number of the starting node, and
ending node. The returned argument d is the shortest path, while p is a vector containing
the serial numbers of nodes in the shortest path. Please note that in the function, the entities

296
Scientiﬁc Computing with MATLAB®
0 in the W matrix are reassigned automatically to ∞, so that the Dijkstra algorithm can
work normally.
Example 6.67
Solve again the problem in Example 6.65 with Dijkstra algorithm.
Solution The following statements can be used, and the results are exactly the same as the
one obtained in Example 6.65.
>> a=[1 1 2 2 3 3 4 4 4 4 5 6 6 7 8];b=[2 3 5 4 4 6 5 7 8 6 7 8 9 9 9];
w=[1 2 12 6 3 4 4 15 7 2 7 7 15 3 10]; R=sparse(a,b,w); R(9,9)=0;
W=ones(9); [d,p]=dijkstra(R.*W,1,9) % ﬁnd the shortest path
6.8.3
Optimal path planning of undigraphs
In practical applications, for instance in route ﬁnding in cities, the relevant graphs can
also be described by undigraphs, since for nodes A and B, the distance from node A to
node B is exactly the same as that from node B to node A. Manipulating undigraphs is also
simple. Assume that the edges are assigned ﬁrst to be one-directional, and the incidence
matrix R1 can then be entered. The incidence matrix for the undigraph can be obtained
directly from R = R1 + RT
1 . If there are one-way streets in the city, manual modiﬁcation
can be made. For instance, if the edge from node i to j is one way, the element of R(i, j) is
retained, and set R(j, i) = 0.
For some special undigraphs, the weights from node i to node j may be diﬀerent from
the weight from node j to node i. The elements in matrix R can be modiﬁed manually, too,
so that even more general problems can be solved with the functions.
6.8.4
Optimal path planning for graphs described by coordinates
If the nodes are speciﬁed by its absolute coordinates (xi, yi), and the connections of
these notes are also speciﬁed, the weights of the sides can be calculated directly as the
Euclidian distances of the nodes. Thus, the incidence matrix can be established, and the
shortest path problems can be solved.
Example 6.68
Assume that there are 11 cities, distributed at the following coordinates
(4, 49), (9, 30), (21, 56), (26, 26), (47, 19), (57, 38), (62, 11), (70, 30), (76, 59), (76, 4), (96, 4),
the roads between the cities are shown in Figure 6.19. Please ﬁnd the shortest distance from
city A to city B. If the road between cities ⑥and ⑧are in construction, please ﬁnd a new
shortest path.
Solution The incidence matrix should be entered ﬁrst. The sparse matrix can be created
based on the oriented graph, and the weighting matrix can be set to a matrix of ones.
The incidence matrix of the undigraph can be obtained from the oriented graph, and the
actual weights of the sides can be calculated directly from the Euclidian distance, i.e., dij =

(xi −xj)2 + (yi −yj)2. Thus, the eﬀective weighting matrix can be obtained by the product
of the two matrices. With the following statements, the shortest path can be found as from
city A →②→④→⑥→⑧→city B, and the shortest distance is 111.6938.
>> x=[4,9,21,26,47,57,62,70,76,76,96];
y=[49,30,56,26,19,38,11,30,59,4,32];
for i=1:11, for j=1:11,
% calculate Euclidian distance matrix

Nonlinear Equations and Numerical Optimization Problems
297
0
10
20
30
40
50
60
70
80
90
100
0
10
20
30
40
50
60
9
11
1
3
2
4
5
6
7
10
8
A
B
FIGURE 6.19: Map of city locations and traﬃc.
D(i,j)=sqrt((x(i)-x(j))^2+(y(i)-y(j))^2);
end, end
n1=[1 1 2 2 3 4 4 5 5 6 6 6 7 8 7 10 8 9];
n2=[2 3 3 4 4 5 6 6 7 7 8 9 8 9 10 11 11 11];
R=sparse(n1,n2,1); R(11,11)=0; R=R+R’; [d,p]=dijkstra(R.*D,1,11)
If the route from node ⑥to node ⑧is not usable, we can set R(8, 6)= R(6, 8)= ∞. In
this case, the following statements can be used to ﬁnd the optimal path again, and the new
result is city A →②→④→⑤→⑦→⑧→city B, with the shortest distance of 122.9394.
>> R(6,8)=Inf; R(8,6)=Inf; [d,p]=dijkstra(R.*D,1,11)
Exercises
Exercise 6.1 Find the solutions to the following equations, and verify the accuracy of the
solutions.
(i)
⎧
⎪
⎪
⎨
⎪
⎪
⎩
24xy −x2 −y2 −x2y2 = 13
24xz −x2 −z2 −x2z2 = 13
24yz −y2 −z2 −y2z2 = 13,
(ii)
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x2y2 −zxy −4x2yz2 = xz2
xy3 −2yz2 = 3x3z2 + 4xzy2
y2x −7xy2 + 3xz2 = x4zy.
Exercise 6.2 Solve and validate the following equations with the given parameter t [19]

t31 + t23y + t17x + t11y2 + t5xy + t2x2 = 0
t37 + t29y + t19x + t13y2 + t7xy + t3x2 = 0.
Exercise 6.3 Solve graphically the following equations, and verify the results.
(i) e−(x+1)2+π/2 sin(5x + 2) = 0,
(ii)

(x2 + y2 + 10xy)e−x2−y2−xy = 0
x3 + 2y = 4x + 5.
Exercise 6.4 Find by numerical methods the solutions to the above problems, and verify
the results.

298
Scientiﬁc Computing with MATLAB®
Exercise 6.5 Find and validate all the solutions to the following modiﬁed Riccati equation,
and verify the results. Is it possible to ﬁnd all solutions with high-precision?
AX + XD −XBX + C = 0,
where
A =
⎡
⎣
2
1
9
9
7
9
6
5
3
⎤
⎦, B =
⎡
⎣
0
3
6
8
2
0
8
2
8
⎤
⎦, C =
⎡
⎣
7
0
3
5
6
4
1
4
4
⎤
⎦, D =
⎡
⎣
3
9
5
1
2
9
3
3
0
⎤
⎦.
Exercise 6.6 Find c such that the integral
 1
0
(ex −cx)2 dx is minimized.
Exercise 6.7 Solve the unconstrained optimization problems
min
x
100(x2 −x2
1)2 + (1 −x1)2 + 90(x4 −x2
3) + (1 −x2
3)2+
10.1
%
(x2 −1)2 + (x4 −1)2&
+ 19.8(x2 −1)(x4 −1).
Exercise 6.8 Try to ﬁnd the global for the following objective function
f(x1, x2) = −
sin

0.1 +

(x1 −4)2 + (x2 −9)2

1 + (x1 −4)2 + (x2 −9)2
.
Exercise 6.9 A set of challenging benchmark problems for evaluating optimization al-
gorithms can be solved using MATLAB. Solve the following unconstrained optimization
problems with MATLAB:
(i) De Jong’s problems [20]
J = min
x xTx = min
x (x2
1 + x2
2 + · · · + x2
p),
where xi ∈[−512, 512], i = 1, · · · , p,
with theoretic solution x1 = · · · = xp = 0.
(ii) Griewangk’s benchmark problem
J = min
x
+
1 +
p

i=1
x2
i
4000 −
p

i=1
cos xi
√
i
,
, where xi ∈[−600, 600].
(iii) Ackley’s benchmark problem [21]
J = min
x
⎡
⎣20 + 10−20 exp
⎛
⎝−0.2
-
.
.
/1
p
p

i=1
x2
i
⎞
⎠−exp
+
1
p
p

i=1
cos 2πxi
,⎤
⎦.
(iv) Kursawe’s benchmark problem
J = min
x
p

i=1
|xi|0.8 + 5 sin3 xi + 3.5828, p = 2, and p = 20.
Exercise 6.10 Solve the nonlinear programming problem with graphical methods, and verify
the results using numerical methods.
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x1−x2+2⩾0
−x2
1+x2−1⩾0
x1⩾0,x2⩾0
x3
1 + x2
2 −4x1 + 4.

Nonlinear Equations and Numerical Optimization Problems
299
Exercise 6.11 Try to solve the following linear programming problems:
(i)
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
4x1−x2+2x3−x4=−2
x1+x2−x3+2x4⩽14
2x1−3x2−x3−x4⩾−2
x1,2,3⩾−1
−3x1 + 4x2 −2x3 + 5x4,
(ii)
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
x1+x2+x3+x4=4
−2x1+x2−x3−x6+x7=1
3x2+x3+x5+x7=9
x1,2,··· ,7⩾0
x6 + x7.
Exercise 6.12 Please solve the following optimization problem:
min
x s.t.
⎧
⎨
⎩
−5
i=1(9+i)xi+50000⩾0
xi⩾0,i=1,2,3,4,5
−(x1 + x2 + x3 + x4 + x5).
Exercise 6.13 Please solve the following transportation problems.
(i)
destination
supply
S1
3
7
6
4
5
S2
2
4
3
2
2
S3
4
3
8
5
3
D
3
3
2
2
(ii)
shipping cost
output
S1
464
513
654
867
75
S2
352
416
690
791
125
S3
995
682
388
685
100
D
80
65
70
85
Exercise 6.14 Solve the following quadratic programming problems and also illustrate the
solutions using graphical methods:
(i)
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x1+x2⩽3
4x1+x2⩽9
x1,2⩾0
2x2
1 −4x1x2 + 4x2
2 −6x1 −3x2,
(ii)
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
−x1+x2=1
x1+x2⩽2
x1,2⩾0
(x1 −1)2 + (x2 −2)2.
Exercise 6.15 Try to solve the following optimization problem [19]. Is there any chance to
ﬁnd high-precision solutions to the problem?
max
x,y,z s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
8+5z3x−4z8y+3x2y−xy2=0
1−z9−z3x+y+3z5xy+7x2y+2xy2=0
−1−5z−5z9x−5z8y−2z9xy+x2y+4xy2=0
z.
Exercise 6.16 Solve the constrained optimization problem q and k [8].
min
q,k s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
g(q)⩽0
800−800k⩽q1⩽800+800k
4−2k⩽q2⩽4+2k
6−3k⩽q3⩽6+3k
k,
where
g(q) = 10q2
2q3
3 + 10q3
2q2
3 + 200q2
2q2
3 + 100q3
2q3 + q1q2q2
3 + q1q2
2q3 + 1000q2q3
3
+ 8q1q2
3 + 1000q2
2q3 + 8q1q2
2 + 6q1q2q3 −q2
1 + 60q1q3 + 60q1q2 −200q1.
Exercise 6.17 Solve numerically the following nonlinear programming problems:

300
Scientiﬁc Computing with MATLAB®
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
x1+x2⩽0
−x1x2+x1+x2⩾1.5
x1x2⩾−10
−10⩽x1,x2⩽10
ex1(4x2
1 + 2x2
2 + 4x1x2 + 2x2 + 1).
Exercise 6.18 Solve the following nonlinear programming problems:
(i)
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
41.67x3(1−x2
2/x2
1)/x3
1⩽1
2.5(1−x2
2/x2
1)/x3
1⩽1
10−x3⩽0
0.00613(x2
1 −x2
2)x3,
(ii)
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x1+x2+x3⩽40
5⩽x1⩽20,3⩽x2⩽11
10⩽x3⩽40
x2
1 + 3x2
2 + x3
3.
Exercise 6.19 Please try to ﬁnd global optimal solution
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
0.003079x3
1x3
2x5−cos3 x6⩾0
0.1017x3
3x3
4−x2
5 cos3 x6⩾0
0.09939(1+x5)x3
1x2
2−cos2 x6⩾0
0.1076(31.5+x5)x3
3x2
4−x2
5 cos2 x6⩾0
x3x4(x5+31.5)−x5[2(x1+5) cos x6+x1x2x5]⩾0
0.2⩽x1⩽0.5,14⩽x2⩽22,0.35⩽x3⩽0.6
16⩽x4⩽22,5.8⩽x5⩽6.5,0.14⩽x6⩽0.2618
1
2 cosx6

x1x2(1 + x5) + x3x4

1 + 31.5
x5

.
Exercise 6.20 Solve the following integer linear programming problems:
(i)
max
x s.t.
⎧
⎨
⎩
x⩾0
3534x1+2356x2+1767x3+589x4+528x5+451x6+304x7⩽119567
592x1 + 381x2 + 273x3 + 55x4 + 48x5 + 37x6 + 23x7,
(ii)
max
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x1+x2+x3=30
x4+x5+x6=18
x1+x4=10
x2+x5⩽18
x3+x6⩾30
x1,··· ,6⩾0
120x1 + 66x2 + 72x3 + 58x4 + 132x5 + 104x6.
Exercise 6.21 Solve the following nonlinear integer programming problems [9], and validate
the results with enumerate method.
(i)
min
x
s.t. 12⩽xi⩽32

1
6.931 −x2x3
x1x4
2
,
(ii)
min
x
s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
−2x2
1−3x4
2−x3−4x2
4−5x5+127⩾0
7x1−3x2−10x2
3−x4+x5+282⩾0
23x1−x2
2−6x2
6+8x7+196⩾0
−4x2
1−x2
2+3x1x2−2x2
3−5x6+11x7⩾0
(x1 −10)2 +5(x2 −12)2 +x4
3 +3(x4 −11)2 +10x6
5 +7x2
6 +x4
7 −10x6 −8x7.
Exercise 6.22 Solve the following binary linear programming problems and verify the
results in problems (i) and (ii) using the enumerate methods.

Nonlinear Equations and Numerical Optimization Problems
301
(i)
min
x s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x1−x2+5x3+x4−4x5⩾2
−2x1+6x2−3x3−2x4+2x5⩾0
−2x2+2x3−x4−x5⩽1
5x1 + 7x2 + 10x3 + 3x4 + x5,
(ii)
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x1−x6⩽0
x1−x5⩽0
x2−x4⩽0
x2−x5⩽0
x3−x4⩽0
x1+x2+x3⩽2
−3x1 −4x2 −5x3 + 4x4 + 4x5 + 2x6.
Exercise 6.23 Solve the following binary linear programming problem:
max
x s.t.
Ax⩽
⎡
⎣600
600
⎤
⎦
−fx,
where
A =
 45
0
85
150
65
95
30
0
170
0
40
25
20
0
30
20
125
5
80
25
35
73
12
15
15
40
5
10
0
25
0
0
25
0
165
0
85
0
0
0
0
100
10
12
10
9
0
20
60
40
50
36
49
40
19
150

,
f = [1898, 440, 22507, 270, 14148, 3100, 4650, 30800, 615, 4975, 1160, 4225,
510, 11880, 479, 440, 490, 330, 110, 560, 24355, 2885, 11748, 4550,
750, 3720, 1950, 10500].
Exercise 6.24 Solve the following optimization problem using Robust Control Toolbox and
YALIMP:
min
X s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩

ATX+XA+Q
XB
BTX
−I

< 0
X<0
tr(X),
where A =
⎡
⎣
−1
−2
1
3
2
1
1
−2
−1
⎤
⎦, B =
⎡
⎣
1
0
1
⎤
⎦, Q =
⎡
⎣
1
−1
0
−1
−3
−12
0
−12
−36
⎤
⎦.
Exercise 6.25 Solve the following linear matrix inequalities
⎧
⎪
⎪
⎨
⎪
⎪
⎩
P −1 > 0,
or equavelently P > 0
A1P + P AT
1 + B1Y + Y TBT
1 < 0
A2P + P AT
2 + B2Y + Y TBT
2 < 0,
where
A1 =
⎡
⎣
−1
2
−2
−1
−2
1
−1
−1
0
⎤
⎦, B1 =
⎡
⎣
−2
1
−1
⎤
⎦, A2 =
⎡
⎣
0
2
2
2
0
2
2
0
1
⎤
⎦, B2 =
⎡
⎣
−1
−2
−1
⎤
⎦.

302
Scientiﬁc Computing with MATLAB®
Exercise 6.26 Solve the following unconstrained multi-objective minimization problem,
with
f1(x) = x1, f2(x, z) = g(z)h(f1(x), g(z)), p = 20,
where
g(z) = 1 +
p

i=1
zi
p , and h(f1(x), g(z)) = 1 −

f1(x)/g(z).
Exercise 6.27 Find the best compromise solutions for the following multi-objective linear
programming problems:
(i)
max
z1 = 100x1 + 90x2 + 80x3 + 70x4
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x1+x2⩾30
x3+x4⩾30
3x1+2x2⩽120
3x2+2x4⩽48
x1,x2,x3,x4⩾0
z2 = 3x2 + 2x4,
(ii)
max
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
2x1+5x2+10x3⩽100
x1+6x2+8x4⩽250
5x1+8x2+7x3+10x4⩽350
x1,x2,x3,x4⩾0
⎡
⎢⎢⎣
50x1 + 20x2 + 100x3 + 60x4
20x1 + 70x2 + 5x3
3x2 + 5x4
2x1 + 20x3 + 2x4
⎤
⎥⎥⎦
.
Exercise 6.28 Find the shortest path from node A to node B, in the graphs given in Figure
6.20 (a) and (b).
1
2
4
5
3
6
7
8
9
-
~
?
?
-
=
s
-
-
~ ?
>
-~ ?
2
1
3
6
2
9
4
7
9
5
1
1
6
1
5
5
A
B
(a) oriented graph
4
5
6
7
8
9
10
11
12
1
2
3
1
A
B
5
4
3
4
4
2
3
4
2
7
6
7
2
6
9
4
1
8
2
(b) undigram
FIGURE 6.20: Graphs of the shortest path problems.

Nonlinear Equations and Numerical Optimization Problems
303
Exercise 6.29 Assume that a factory needs to import a machine from an overseas manu-
facturer. There are three ports of exit to select from the manufacturer, and three ports of
entry to select. The machine can then be transported to the factory via one of the two cities.
The transportation costs are shown in Figure 6.21. Please ﬁnd the route with minimized
total transportation cost.
-
j
*
-
-
-

j
j
R
*
q
1
R
q
1
j
*
*

manufacturer
1
2
3
4
5
6
7
8
9
10
factory
city B
city A
ports of entry
ports of exit
20
40
30
70
40
60
30
40
40
50
10
20
10
40
60
30
30
30
30
40
FIGURE 6.21: Roadmap and transportation costs.
Exercise 6.30 Assume that a person usually lives in city C1. He often needs to visit other
cities C2, · · · , C8. The travel costs from city Ci to city Cj are given in the incidence matrix
Ri,j. Please design the cheapest road map for him to travel from city C1 to other cities.
R =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
0
364
314
334
330
∞
253
287
364
0
396
366
351
267
454
581
314
396
0
232
332
247
159
250
334
300
232
0
470
50
57
∞
330
351
332
470
0
252
273
156
∞
267
247
50
252
0
∞
198
253
454
159
57
273
∞
0
48
260
581
220
∞
156
198
48
0
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
Bibliography
[1] Press W H, Flannery B P, Teukolsky S A, et al.
Numerical recipes, the art of
scientiﬁc computing. Cambridge: Cambridge University Press, 1986. Free textbook
at http://www.nrbook.com/a/bookcpdf.php
[2] Boyd S, Vandenberghe L. Convex optimization. Cambridge University Press, 2004.
Free textbook at http://www.stanford.edu/~boyd/cvxbook/bv cvxbook.pdf
[3] Boyd S, Ghaoui L El, Feron E, et al. Linear matrix inequalities in systems and control
theory. Philadelphia: SIAM books, Volume 15 of Studies in Applied Mathematics. Free
textbook at http://www.stanford.edu/~boyd/lmibook/lmibook.pdf, 1994
[4] Mittelmann H D. Decision tree for optimization software. http://plato.asu.edu
/guide.html, 2007

304
Scientiﬁc Computing with MATLAB®
[5] Nelder J A, Mead R. A simplex method for function minimization. Computer Journal,
1965, 7:308–313
[6] Goldberg D E.
Genetic algorithms in search, optimization and machine learning.
Reading, MA: Addison-Wesley, 1989
[7] Hillier F S, Lieberman G J. Introduction to operations research, 10th edition. New
York: McGraw-Hill Education, 2015
[8] Henrion D.
A review of the global optimization toolbox for Maple, 2006.
http://www.laas.fr/~henrion/Papers/mapleglobopt.pdf
[9] Leyﬀer S. Deterministic methods for mixed integer nonlinear programming. Ph.D.
thesis, Department of Mathematics & Computer Science, University of Dundee, U.K.,
1993
[10] Cha J Z, Mayne R W. Optimization with discrete variables via recursive quadratic
programming: Part 2 algorithms and results. Transactions of the ASME, Journal of
Mechanisms, Transmissions, and Automation in Design, 1994, 111:130–136
[11] Willems J C.
Least squares stationary optimal control and the algebraic Riccati
equation. IEEE Transactions on Automatic Control, 1971, 16(6):621∼634
[12] The MathWorks Inc. Robust control toolbox user’s manual, 2007
[13] L¨ofberg J.
YALMIP: a toolbox for modeling and optimization in MATLAB.
Proceedings of IEEE International Symposium on Computer Aided Control Systems
Design. Taipei, 2004, 284∼289
[14] Gao L F. Optimization theory and methods. Shenyang: Northeastern University Press,
2005. (in Chinese)
[15] Cao Y. Pareto set. MATLAB Central File ID: # 15181, 2007
[16] Bellman R. Dynamic programming. Princeton, NJ: Princeton University Press, 1957
[17] Lin Y X.
Dynamic programming and sequential optimization.
Zhengzhou: Henan
University Press, 1997. (in Chinese)
[18] Dijkstra E W.
A note on two problems in connexion with graphs.
Numerische
Mathematik, 1959, 1:269–271
[19] Sturmfels B. Solving systems of polynomial equations. CBMS Conference on Solving
Polynomial Equations, Held at Texas A & M University, American Mathematical
Society, 2002
[20] Chipperﬁeld A, Fleming P. Genetic algorithm toolbox user’s guide. Department of
Automatic Control and Systems Engineering, University of Sheﬃeld, 1994
[21] Ackley D H. A connectionist machine for genetic hillclimbing. Boston, USA: Kluwer
Academic Publishers, 1987

Chapter 7
Diﬀerential Equation Problems
Diﬀerential equations include ordinary diﬀerential equations (ODEs) and partial diﬀerential
equations (PDEs). It is interesting to note that the phrase “extraordinary diﬀerential
equations” is sometimes used to indicate diﬀerential equations of non-integer orders based
on fractional calculus, which is covered in Section 10.6 of the last chapter. In this chapter,
we focus on integer order diﬀerential equations.
Before Isaac Newton and Gottfried Wilhelm Leibniz invented calculus, people char-
acterized the nature simply by geometry and algebra. With calculus, a dynamic system
view of the nature around us becomes possible. Today, diﬀerential equations are the
most widely used mathematical tools for describing dynamic systems evolving either along
time or along spatial variables. Diﬀerential equations also provide a solid foundation for
mathematical modeling in many scientiﬁc and engineering disciplines. Linear diﬀerential
equations and a few special low-order nonlinear diﬀerential equations may have analytical
solutions. However, generally speaking, most nonlinear equations have no analytical or
close form solutions. Thus, numerical techniques should be adopted for solving these
equations. In Section 7.1, analytical solutions to a special class of ordinary diﬀerential
equations (ODEs) will be explored. It will be explained how linear time-invariant (LTI)
diﬀerential equations can be solved in MATLAB. Moreover, analytical solutions to a
very special ﬁrst-order nonlinear diﬀerential equation is presented. For linear state space
equations the analytical solutions can be obtained by vector integration methods. In Section
7.2, numerical algorithms for ﬁrst-order explicit diﬀerential equations will be presented,
with an illustrative MATLAB implementation. The conversion of various diﬀerent types
of diﬀerential equations, including matrix diﬀerential equations, into ﬁrst-order explicit
ones will be discussed. Most interestingly, numerical solutions to several diﬀerent types of
special diﬀerential equations will be discussed in Section 7.4, which include stiﬀdiﬀerential
equations, diﬀerential algebraic equations (DAEs), implicit diﬀerential equations as well
as switching diﬀerential equations, stochastic diﬀerential equations. In Sections 7.5 to 7.7,
delay diﬀerential equations (DDE), boundary value problems (BVPs) of ordinary diﬀerential
equations and partial diﬀerential equations (PDEs) will be discussed respectively with
extensive demonstrative examples. Section 7.8 brieﬂy discusses the modeling and solution of
diﬀerential equations using Simulink environment with diﬀerent kinds of examples. Solutions
to the Simulink models are obtained by automatic simulation methods based on Simulink’s
extensive libraries of building blocks. We demonstrate that, theoretically speaking, ordinary
diﬀerential equations of almost any complexity can be solved numerically in Simulink.
For readers who wish to check the detailed explanations of various aspects of diﬀerential
equations, we recommend the free textbooks [1] (Chapters 17, 18 and 20) and [2]. The
open source free textbook [3] is also an excellent resource for learning diﬀerential equations
(Chapters 14-34 for ordinary diﬀerential equations and Chapters 35-47 for partial diﬀerential
equations.)
305

306
Scientiﬁc Computing with MATLAB®
7.1
Analytical Solution Methods for Some Ordinary Diﬀerential
Equations
7.1.1
Linear time-invariant ordinary diﬀerential equations
The general description of the linear time-invariant (LTI) ordinary diﬀerential equations
is given by
dny(t)
dtn
+ a1
dn−1y(t)
dtn−1
+ a2
dn−2y(t)
dtn−2
+ · · · + an−1
dy(t)
dt
+ any(t) =
bn
dnu(t)
dtn
+ bn−1
dn−1u(t)
dtn−1
+ · · · + b1
du(t)
dt
+ b0u(t),
(7-1-1)
where ai, bi are constants. For practical reasons, the derivative order in the right-hand-side
should be less than n for the system to be strictly proper. In this case, bn, bn−1 and so on
can be set to zeros.
If the right-hand-side of the equation is 0, the equation is referred to as a homogeneous
ordinary diﬀerential equation.
From the properties of Laplace transform introduced in Section 5.1, for zero initial
condition problems, one has
L
dmy(t)
dtm

= smL [y(t)] = smY (s), L
dmu(t)
dtm

= smL [u(t)] = smU(s).
Therefore, the above linear time-invariant diﬀerential equation can be mapped into the
following algebraic polynomial equation:
Y (s)Q(s) = U(s)P(s),
(7-1-2)
where Q(s) = sn + a1sn−1 + a2sn−2 + · · · + an−1s + an and P(s) = bnsn + bn−1sn−1 + · · · +
b1s + b0. Note that, if initial conditions are not all zeros, extra attention should be paid
during the conversion. The neat form of (7-1-2) with the same coeﬃcients as (7-1-1) is still
possible. However, by rearranging the terms, we can get
Y (s)Q(s) = Y0(s) + U0(s) + U(s)P(s),
(7-1-3)
where Y0(s) and U0(s) are due to nonzero initial conditions in signals y(t) and u(t),
respectively.
The following polynomial equation
Q(s) = sn + a1sn−1 + a2sn−2 + · · · + an−1s + an = 0
(7-1-4)
is referred to as the characteristic equation. If all the roots ri in the characteristic equation
can be obtained and they are all distinct, the general form of the analytical solution to the
corresponding ordinary diﬀerential equation can be written as
y(t) = y1(t) + y0(t),
(7-1-5)
where y0(t) is a particular solution of the original equation, and y1(t) is the general solution
of the homogeneous equation, which can be expressed as
y1(t) = C1er1t + C2er2t + · · · + Cnernt,
(7-1-6)

Diﬀerential Equation Problems
307
where Ci’s are the undetermined constants related to initial conditions. When rj is a
repeated root with multiplicity mj, the term Cjerjt should be replaced by
mj−1

k=0
Cjktkerjt.
(7-1-7)
In general, assume that there are k distinct roots rj, j = 1, 2, · · · , k, and rj has its
multiplicity mj with mj ⩾1 and
k

j=1
mj = n. Then, the general solution of the homogeneous
diﬀerential equation can be written as
y1(t) =
k

j=1
mj−1

k=0
Cjktkerjt.
(7-1-8)
Let us investigate (7-1-2). From the well-known Abel–Ruﬃni Theorem, it is known
that the polynomial equation with degree less than or equal to 4 has analytical solutions.
Thus, it can be concluded that low-order linear time-invariant ordinary diﬀerential equations
have analytical solutions. For higher-order equations, one may combine the numerical and
analytical approaches to ﬁnd quasi-analytical solutions with high accuracy. In this section,
symbolic math-based analytical solution approaches will be presented ﬁrst.
7.1.2
Analytical solution with MATLAB
The function dsolve() provided in the Symbolic Math Toolbox in MATLAB can be
used to symbolically solve a class of ordinary diﬀerential equations with mixed initial and
boundary conditions. The syntaxes of the function are
y = dsolve(fun1,fun2,· · · ,funm)
% default independent variable t
y = dsolve(fun1,fun2,· · · ,funm,’x’)
% independent variable x assigned
where the string variables funi can be used to describe not only diﬀerential equations, but
also initial and boundary conditions. When describing diﬀerential equations in dsolve(),
the symbol D4y is used to denote y(4)(t). One can also use D2y(2)= 3 to denote given
condition as y′′(2) = 3. With dsolve(), the analytical solutions to a class of ordinary
diﬀerential equations can easily be found. If the independent variable in the diﬀerential
equations is x rather than t, this should be declared in the function call statement.
Alternatively, the diﬀerential equations eqni can also be described by symbolic
expressions. This kind of descriptions are suitable for validations. Unfortunately, this kind
of description are not quite suitable for describing equations with high-order boundary
conditions.
Example 7.1
Let the input signal be deﬁned by u(t) = e−5t cos(2t + 1) + 5. Find the
general solution to the following ordinary diﬀerential equation
y(4)(t) + 10y(3)(t) + 35y′′(t) + 50y′(t) + 24y(t) = 5u′′(t) + 4u′(t) + 2u(t).
Solution To solve the original diﬀerential equation using dsolve(), the right-hand-side of
the equation should be evaluated ﬁrst given u(t). Then, the original equation can be solved
using the following statements

308
Scientiﬁc Computing with MATLAB®
>> syms t; u=exp(-5*t)*cos(2*t+1)+5; % declare symbolic variable and input
uu=5*diff(u,t,2)+4*diff(u,t)+2*u; % evaluate the right-hand side of ODE
y=dsolve([’D4y+10*D3y+35*D2y+50*Dy+24*y=’,char(uu)]) % solve directly
where in the above statements, the variable uu is a symbolic expression. Since the diﬀerential
equation should be expressed in a string, char() function is used to convert it, and square
brackets are used to join the left- and right-hand sides of the equation together to form a
complete string description. The ﬁnal solution to this diﬀerential equation is found as
y(t)= 5
12 −343
520e−5t cos(2t+1)−547
520e−5t sin(2t+1)+C1e−4t+C2e−3t+C3e−2t+C4e−t,
where Ci’s are undetermined constants. Given 4 independent initial or boundary conditions,
the constants Ci can then be solved uniquely.
If the equations are described by symbolic expressions, the following MATLAB commands
can be used instead, and the same results can be found.
>> syms y(t); % describe the ODE in an symbolic expression
y0=dsolve(diff(y,4)+10*diff(y,3)+35*diff(y,2)+50*diff(y)+24*y==uu)
Now let us assume that the following conditions are given y(0) = 3, y′(0) = 2, y′′(0) =
y(3)(0) = 0. Use the following statements to ﬁnd the solution to the original ordinary
diﬀerential equation.
>> y=dsolve([’D4y+10*D3y+35*D2y+50*Dy+24*y=’,char(uu)],’y(0)=3’,...
’Dy(0)=2’,’D2y(0)=0’,’D3y(0)=0’) % specify initial conditions
which is
y(t) = 5
12 −343
520e−5t cos (2t+1) −547
520e−5t sin(2t+1)
+

−445
26 cos 1 −51
13 sin 1 −69
2

e−2t +

−271
30 cos 1 + 41
15 sin 1 −25
4

e−4t
+
179
8 cos 1 + 5
8 sin 1 + 73
3

e−3t +
133
30 cos 1 + 97
60 sin 1 + 19

e−t.
The solution can be validated with the following statements
>> simplify(diff(y,4)+10*diff(y,3)+35*diff(y,2)+50*diff(y)+24*y-uu)
for i=0:3, subs(diff(y,i),t,0), end % validations of the solution
To describe the diﬀerential equations with symbolic expressions, extra signals should be
introduced, and the following statements can be used, and the same results can be obtained.
Please note that, the deﬁnitions of the extra signals Dy, D2y and D3y cannot be omitted.
>> syms t y(t); Dy=diff(y); D2y=diff(y,2); D3y=diff(y,3);
u=exp(-5*t)*cos(2*t+1)+5; uu=5*diff(u,t,2)+4*diff(u,t)+2*u;
y1=dsolve(diff(y,4)+10*diff(y,3)+35*diff(y,2)+50*diff(y)+24*y==uu,...
y(0)==3,Dy(0)==2,D2y(0)==0,D3y(0)==0)
With the powerful Symbolic Math Toolbox, solutions to some seemingly impossible-
to-solve ordinary diﬀerential equations can be obtained easily. For instance, let y(0) =
1/2, y′(π)=1, y′′(2π) = 0, y′(2π) = 1/5, the analytical solution to this diﬀerential equation
can be obtained

Diﬀerential Equation Problems
309
>> y=dsolve([’D4y+10*D3y+35*D2y+50*Dy+24*y=’,char(uu)],’y(0)=1/2’,...
’Dy(pi)=1’,’D2y(2*pi)=0’,’Dy(2*pi)=1/5’)
It is possible to display the analytical form of the undetermined constants Ci but each
coeﬃcient will take about 10 lines at least. In this situation, a fairly accurate approximate
representation to these terms can be used such that the quasi-analytical solution to the
equation can be found with vpa(ans), where the solution obtained above can be expressed by
y(t) = 5
12 −343
520e−5t cos(2t + 1) −547
520e−5t sin(2t + 1) −219.1291604e−t
+ 442590.9052e−4t + 31319.63786e−2t −473690.0889e−3t.
Example 7.2
The above diﬀerential equation contains only real poles. In fact, in the
dsolve() function, diﬀerential equations containing complex poles can also be solved. Now
consider the following equation
y(5)(t) + 5y(4)(t) + 12y(3)(t) + 16y′′(t) + 12y′(t) + 4y(t) = 3u′(t) + 3u(t),
where the input signal u(t) = sin t, and y(0) = y′(0) = y′′(0) = y(3)(0) = y(4)(0) = 0. Try
to use the analytical solution approach for this equation.
Solution One can solve the diﬀerential equation using the following statements
>> syms t; u=sin(t); uu=3*diff(u)+3*u; % compute right-hand side
y=dsolve([’D5y+5*D4y+12*D3y+16*D2y+12*Dy+4*y=’ char(uu)],...
’y(0)=0’,’Dy(0)=0’,’D2y(0)=0’,’D3y(0)=0’,’D4y(0)=0’)
simplify(y) % solve linear time-invariant ODE with repeated complex poles
The analytical solution can then be found
y(t) = −2
5 sin t −1
5 cos t + e−t + 11
10e−t sin t −4
5e−t cos t −1
2e−tt cos t.
Example 7.3
Find the analytical solution to the following simultaneous ordinary
diﬀerential equations:

x′′(t) + 2x′(t) = x(t) + 2y(t) −e−t
y′(t) = 4x(t) + 3y(t) + 4e−t.
Solution
The linear diﬀerential equation set can also be solved directly using dsolve()
function. For instance, the above equation can be solved with
>> [x,y]=dsolve(’D2x+2*Dx=x+2*y-exp(-t)’,’Dy=4*x+3*y+4*exp(-t)’)
and it can be found that the solutions are
⎧
⎨
⎩
x(t) = −6te−t + C1e−t + C2e(1+
√
6)t + C3e−(−1+
√
6)t
y(t) = 6te−t−C1e−t+2

2+
√
6

C2e(1+
√
6)t + 2

2−
√
6

C3e−(−1+
√
6)t + 1
2e−t.
Example 7.4
Solve the following high-order linear diﬀerential equations
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x′′ −x + y + z = 0,
x + y′′ −y + z = 0,
x + y + z′′ −z = 0,
x(0) = 1, y(0) = z(0) = x′(0) = y′(0) = z′(0) = 0.

310
Scientiﬁc Computing with MATLAB®
Solution
With the following statements, the diﬀerential equations can be solved directly
with
>> [x,y,z]=dsolve(’D2x-x+y+z=0’,’x+D2y-y+z=0’,’x+y+D2z-z=0’,...
’x(0)=1, y(0)=0, z(0)=0’,’Dx(0)=0, Dy(0)=0, Dz(0)=0’)
and the solutions of the equations obtained are
x(t)= e
√
2t
3
+ e−
√
2t
3
+ cos t
3
, y(t)= cos t
3
−e−
√
2t
6
−e
√
2t
6 , z(t)= cos t
3
−e−
√
2t
6
−e
√
2t
6
.
Example 7.5
Consider the time-varying diﬀerential equation given by
x2(2x −1)d3y
dt3 −(4x −3)xd2y
dx2 −2xdy
dx + 2y = 0.
Solution It seems that the equation can be solved easily with
>> syms x; y=dsolve(’x^2*(2*x-1)*D3y-(4*x-3)*x*D2y-2*x*Dy+2*y=0’)
It should be noted that in the original equation, the independent variable is x rather than
the default t, thus, the equation cannot be solved correctly with the above statement. To solve
the equation, the notation ’x’ should be used in the function call, otherwise, the solution
obtained is wrong. The equation can be solved with
>> y=simplify(dsolve(’x^2*(2*x-1)*D3y+(4*x-3)*x*D2y-2*x*Dy+2*y=0’,’x’))
simplify(x^2*(2*x-1)*diff(y,3)+(4*x-3)*x*diff(y,2)-2*x*diff(y)+2*y)
The solution of the diﬀerential equation is as follows. Substituting the results back to the
equation, it can be seen that the error is 0, which means that the result y is the solution of
the original equation.
y(x) = −1
16x(2C1 −C3 + 8C3x + 32C2x2 + 8C3x2lnx).
If recent versions of MATLAB are used, the diﬀerential equation can alternatively be
speciﬁed as a symbolic expression. In this case, there is no need to declare the variable x
again in the function call. The same results can be obtained.
>> syms x y(x); % an alternative way in describing and solution of ODE
y0=dsolve(x^2*(2*x-1)*diff(y,3)+(4*x-3)*x*diff(y,2)-2*x*diff(y)+2*y)
simplify(y0) % simplify the results
7.1.3
Analytical solutions of linear state space equations
Assume that the linear time-invariant state space model is given by

x′(t) = Ax(t) + Bu(t)
y(t) = Cx(t) + Du(t),
(7-1-9)
where, A, B, C and D are constant matrices, and the initial state vector x0 is given. The
analytical solution can be written mathematically as
x(t) = eA(t−t0)x(t0) +
 t
t0
eA(t−τ)Bu(τ) dτ.
(7-1-10)

Diﬀerential Equation Problems
311
It can be seen that the input signal u(t) is a function of t, while in the above equation, the
function of τ is expected, the MATLAB function subs() can be used in variable substitution.
Also, the exponential of matrices and deﬁnite integrals are involved; these can be processed
with expm() and int() functions. Thus, the solution can be obtained with
x = expm(A*t)*x0 + int(expm(A*(t-τ))*B*subs(u,t,τ),τ,0,t)
An example is given to show how to get the analytical solutions of the equations, with
the direct use of appropriate MATLAB functions.
Example 7.6
Assume that the input signal is u(t) = 2 + 2e−3t sin 2t, and the matrices in
the state space equation are given below. Find the analytical solution.
A =
⎡
⎢⎢⎣
−19
−16
−16
−19
21
16
17
19
20
17
16
20
−20
−16
−16
−19
⎤
⎥⎥⎦, B =
⎡
⎢⎢⎣
1
0
1
2
⎤
⎥⎥⎦, CT =
⎡
⎢⎢⎣
2
1
0
0
⎤
⎥⎥⎦, D = 0, x0 =
⎡
⎢⎢⎣
0
1
1
2
⎤
⎥⎥⎦.
Solution With the direct used of (7-1-10), the analytical solution of the equation can be
obtained with the following statements
>> syms t tau; u=2+2*exp(-3*t)*sin(2*t); % declare symbolic variables/input
A=[-19,-16,-16,-19; 21,16,17,19; 20,17,16,20; -20,-16,-16,-19];
B=[1; 0; 1; 2]; C=[2 1 0 0]; x0=[0; 1; 1; 2]; % enter matrices
x=expm(A*t)*x0+int(expm(A*(t-tau))*B*subs(u,t,tau),tau,0,t);
y=simplify(C*x) % compute the output signal
The analytical solution obtained is
y(t) = 119
8 e−t + 57e−3t + 127t
4
e−t + 4t2e−t −135
8 e−3t cos 2t + 77
4 e−3t sin 2t −54.
With recent versions of MATLAB, the matrix diﬀerential equations can alternatively be
solved with the following statements, and the same results can be obtained
>> syms x1(t) x2(t) x3(t) x4(t); X=[x1; x2; x3; x4]; % alternatively
R=dsolve(diff(X)==A*X+B*u,X(0)==x0); y=C*[R.x1; R.x2; R.x3; R.x4]
7.1.4
Analytical solutions to special nonlinear diﬀerential equations
Very few nonlinear diﬀerential equations have analytical solutions. If there are, the
solutions can be obtained with the dsolve() function. An example for the analytical
solution to a special nonlinear diﬀerential equation is demonstrated. Another example is
also presented where the analytical solution is not possible.
Example 7.7 Find the analytical solution to the ﬁrst-order nonlinear diﬀerential equation
x′(t) = x(t)(1 −x2(t)).
Solution Such a simple nonlinear diﬀerential equation can be solved analytically using the
function dsolve().
>> syms x; x=dsolve(’Dx=x*(1-x^2)’) % solve directly
Therefore, the analytical solutions are x(t) =
*
1
1 −eC−2t . Apart from this solution,

312
Scientiﬁc Computing with MATLAB®
x(t) = ±1, and x(t) = 0 are all solutions of the equation.
This is a lucky case. Now, let us slightly change the original ordinary diﬀerential
equation, for instance, by adding 1 to the right-hand side of the original equation. The
following statements can be used to solve the modiﬁed diﬀerential equation. With no surprise,
no solution can be found by using dsolve().
>> syms x; x=dsolve(’Dx=x*(1-x^2)+1’) % no analytical solution exists
Example 7.8
Find the analytical solution to the well-known Van der Pol equation
d2y(t)
dt2
+ μ(y2(t) −1)dy(t)
dt
+ y(t) = 0.
Solution From the previous examples, it seems that the function dsolve() is quite powerful
in ﬁnding analytical solutions to many diﬀerential equations. Here we are trying to solve
the Van der Pol nonlinear equation. The following statements
>> syms mu; y=dsolve(’D2y+mu*(y^2-1)*Dy+y=0’) % no analytical solution exists
can be executed but from the message “Explicit solution could not be found,” which means
that there is no analytical solution at all to the given Van der Pol equation.
It can be seen that the function dsolve() cannot be used to solve general nonlinear
ordinary diﬀerential equations. Thus, to solve nonlinear equations, numerical methods have
to be used. In the rest of this chapter, we shall concentrate on numerical solutions of various
diﬀerential equations.
7.2
Numerical Solutions to Ordinary Diﬀerential Equations
In the previous section, analytical solutions for a limited class of ordinary diﬀerential
equations were discussed and demonstrated. It is also noted that there is no analytical
solutions to most nonlinear diﬀerential equations. Therefore, numerical algorithms should
be used.
7.2.1
Overview of numerical solution algorithms
A large category of numerical solution algorithms for ordinary diﬀerential equations
is for the so-called initial value problems (IVPs). The standard vector form of ﬁrst-order
explicit diﬀerential equations is given by
x′(t) = f(t, x(t)),
x(t0) = x0,
(7-2-1)
where xT(t)
=
[x1(t), x2(t), · · · , xn(t)] is referred to as the state vector, x(t0)
=
[x1(t0), · · · , xn(t0)]T is the given initial value vector, and f T(·) = [f1(·), f2(·), · · · , fn(·)]
is the vector of any nonlinear functions.
In this section, we shall explore numerical algorithms for solving x(t), t ∈[t0, tf], where
tf is also referred to as the terminal time.
For the above initial value problems, the Euler’s algorithm is obviously the most

Diﬀerential Equation Problems
313
straightforward algorithm. Although the algorithm is very simple, understanding such an
algorithm will help us to better understand other complicated algorithms.
Assume that at time t0, the state vector is written as x(t0). Given a small calculation
step-size h, the left-hand-side of the diﬀerential equation can be approximately written as
ˆx(t0 + h) = [x(t0 + h) −x(t0)]/h, at least it is true when h →0. Substituting it back to the
original equation, the approximate solution at time t0 + h can be written as
ˆx(t0 + h) ≈x(t0) + hf(t0, x(t0)).
(7-2-2)
The above approximate solution certainly contains errors. Thus, the state vector at time
t0 + h should be written as
x(t0 + h) = ˆx(t0 + h) + R0 = x0 + hf(t, x0) + R0,
(7-2-3)
where the vector R0 is the approximation error. Denoting x1 = x(t0 + h), ˆx1 = ˆx(t0 + h)
approximates the state vector at time t0 + h. In this numerical procedure, one can simply
denote the numerical solution by x1.
The state vector at time tk is denoted by xk. At time tk + h, the Euler’s algorithm
generates a new state vector
xk+1 = xk + hf(t, xk).
(7-2-4)
Thus, a recursive algorithm can be used to evaluate the solutions in each time instant
over the given time interval t ∈[0, tf]. In this way, the numerical solutions at time instances
t0 + h, t0 + 2h, · · · can be obtained.
To increase the accuracy of the solutions, one may reduce the step-size h. However,
one cannot expect to reduce the step-size unlimitedly. The following two reasons should be
considered:
(i) Slowing down in computation
If an extremely small step-size is selected, the
number of computation points over the solution interval will signiﬁcantly increase.
(ii) Increasing the cumulative errors
No matter how small the step-size is, the
roundoﬀerror in numerical solutions is unavoidable. As pointed out earlier, decreasing the
step-size means the increase in computation points, which also means that the cumulative
error and error propagation may increase. The relationship among the step-size, roundoﬀ
error, cumulative error and the overall error are sketched in Figure 7.1 (a) for illustration.
step-size h
overall error
roundoﬀ
error
computation error
cumulative
error
(a) sketch of errors
ϵ
tk + h
tk
tk+ 1
2
solution in one step ˜xk+1
solution in two
steps ˆxk+1
f(t, x)
xk
t
(b) variable step-size algorithm
FIGURE 7.1: Errors and step-sizes.
Thus, in order to eﬀectively solve the ordinary diﬀerential equations, the following
considerations should be in place:

314
Scientiﬁc Computing with MATLAB®
(i) Suitable step-size selection
If simple algorithms such as the Euler’s algorithm
are used, one should choose suitable step-sizes, neither too large, nor too small.
(ii) Improved algorithms
Since the above simple Euler’s algorithm is a trapezoidal
approximation of the original integration problem, the accuracy is rather low when the step-
size is not small enough. It usually cannot eﬀectively solve the original ordinary diﬀerential
equation problems. Other advanced algorithms should be adopted to replace the Euler’s
algorithm. Successful algorithms include the Runge–Kutta’s algorithm and the Adams’
algorithm, etc.
(iii) Variable step-size algorithms
It has been suggested that one should “suitably”
choose the step-size. The concept of “suitable step-size” is very vague. The selection of step-
size sometimes depends on the experience and the diﬀerential equation at hand. In fact,
many numerical algorithms allow the use of variable-step-size computation. When the error
detected is small, a relatively large step-size can be chosen. However, when the detected error
is large, a smaller step-size will be used instead. Using this variable step-size mechanism,
fast and accurate algorithms can be devised for ordinary diﬀerential equations.
The basic idea of variable step-size algorithm is illustrated in Figure 7.1 (b). If at the
current time instant tk, the state vector is xk, then, the state vector ˜xk+1 at time instant
tk+h can be obtained. On the other hand, if one divides the step-size by two halves, the state
vector at time tk + h obtained by integrating two steps using half step-size h/2 is denoted
by ˆxk+1. The error of the state vectors using the two methods is ϵ = ||ˆxk+1 −˜xk+1||, and
if it is smaller than the preassigned error tolerance, then, the original step-size can be used,
and accordingly, the step-size can be increased. If the error is too large, the step-size should
be decreased to ensure the computational accuracy. Thus, the above method considers both
the computation speed and the computation accuracy. Such algorithms are referred to as
adaptive or variable step-size algorithm.
7.2.2
Fixed-step Runge–Kutta algorithm and its MATLAB implemen-
tation
Fourth-order ﬁxed-step Runge–Kutta algorithm is a classical diﬀerential equation solving
algorithm, often taught in numerical analysis courses. It had been considered as an eﬀective
and easy-to-implement numerical algorithm.
The above fourth-order Runge–Kutta algorithm calculates the state vector at the next
step using
xk+1 = xk + 1
6(k1 + 2k2 + 2k3 + k4),
(7-2-5)
where the four additional intermediate variables are introduced such that
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
k1 = hf(tk, xk)
k2 = hf

tk + h
2 , xk + k1
2

k3 = hf

tk + h
2 , xk + k2
2

k4 = hf(tk + h, xk + k3),
(7-2-6)
where h is the ﬁxed step-size.
Therefore, with the use of the recursive algorithm, the initial value problem at time
instants t0 + h, t0 + 2h, · · · , within the time interval t ∈[t0, tf] can be solved numerically
step by step.

Diﬀerential Equation Problems
315
Based on the above algorithm, its MATLAB implementation is written as:
function [tout,yout]=rk_4(fun,tspan,y0)
ts=tspan; t0=ts(1); tf=ts(2); yout=[]; tout=[]; y0=y0(:);
if length(ts)==3, h=ts(3); else, h=(ts(2)-ts(1))/100; tf=ts(2); end
for t=[t0:h:tf]
k1=h*feval(fun,t,y0); k2=h*feval(fun,t+h/2,y0+0.5*k1);
k3=h*feval(fun,t+h/2,y0+0.5*k2); k4=h*feval(fun,t+h,y0+k3);
y0=y0+(k1+2*k2+2*k3+k4)/6; yout=[yout; y0’]; tout=[tout; t];
end
where tspan can be given in two ways. One way is to specify an evenly distributed time
vector and the other is to use tspan = [t0,tf,h], where t0 and tf are the initial and ﬁnal
time, h the step-size. The argument fun is the function handle for describing the function
f(t, x). The argument y0 provides the initial state vector. The time vector and the matrix
containing states at each time instant are returned in arguments tout and yout, respectively.
The above algorithm seems to be rather simple. However, from a numerical accuracy
point of view, it may not be a good algorithm, since numerical accuracy during the
computation is not monitored. Thus, the overall numerical accuracy of the algorithm
cannot be guaranteed. In later examples, this algorithm will be compared with variable-
step algorithm.
7.2.3
Numerical solution to ﬁrst-order vector ODEs
I. Runge–Kutta–Felhberg algorithm
German mathematician Erwin Felhberg proposed an improved version of the algorithm
based on the traditional Runge–Kutta algorithm [4]. Within each computation step, six
evaluations of the fi(·) function are performed to ensure high-precision and numerical
stability. The algorithm is also known as the 4/5 Runge–Kutta–Felhberg algorithm.
Assuming that the current step-size is hk, the six intermediate variables ki are evaluated
by the following formula:
ki = hkf
⎛
⎝tk + αihk, xk +
i−1

j=1
βijkj
⎞
⎠,
i = 1, 2, · · · , 6,
(7-2-7)
where tk is the current time instant, and intermediate parameters αi, βij and other
parameters are given in Table 7.1. The parameter pairs αi, βij are also referred to as
the Dormand–Prince pairs. The state vector at the next time instant is obtained from
xk+1 = xk +
6

i=1
γiki.
(7-2-8)
Of course, this algorithm seems to be a ﬁxed-step type like the 4th order Runge–Kutta
algorithm in the previous subsection. However, in practical applications, an error vector
ϵk = '6
i=1(γi −γ∗
i )ki can be obtained, and the step-size can be adjusted according to
this error vector. This algorithm is often referred to as the adaptive step-size algorithm. It
cannot only ensure the accuracy of numerical solutions but also provide faster speed.
In contrast with the concepts in feedback control, the ﬁxed-step algorithm is somewhat
like an open-loop control structure. It does not care whether the error of solution is

316
Scientiﬁc Computing with MATLAB®
TABLE 7.1: Coeﬃcients in 4/5 Runge–Kutta-Felhberg algorithm.
αi
βij
γi
γ∗
i
0
16/135
25/216
1/4
1/4
0
0
3/8
3/32
9/32
6656/12825
1408/2565
12/13
1932/2197
−7200/2197
7296/2197
28561/56430
2197/4104
1
439/216
−8
3680/513
−845/4104
−9/50
−1/5
1/2
−8/27
2
−3544/2565
1859/4104
−11/40
2/55
0
acceptable or not using the identical step-size throughout the computation period. However,
the variable-step algorithm is similar to the closed-loop control concept. It monitors the
errors in the solution process and whenever necessary, the step-size can be adjusted
according to the estimated computation error.
II. MATLAB functions for solving ordinary diﬀerential equations
To solve the ODEs numerically, the following procedures are needed
(i) Standard form
Express the equations in the form of ﬁrst-order explicit equations,
x′(t) = f(t, x), with known x0.
(ii)
Describe the equations
The standard form, i.e., x′(t) = f(t, x), should be
described correctly in MATLAB. MATLAB functions with the leading statements should
be written
function xd = fun(t,x)
% without additional variables
function xd = fun(t,x,p1,p2,· · · )
% with additional variables
where t is the time variable. Note that even the original equation is time-independent, and
the argument t should still be used, to avoid argument mismatch problems. The variable xd
is the derivative of the state vector. Alternatively, anonymous functions can also be used to
describe the equations.
(iii) Solve the equations
The MATLAB function ode45() is the most widely used
initial value problem solver. In the algorithm, the variable-step 4/5 Runge–Kutta–Felhberg
algorithm is implemented. The syntaxes of the function are
[t,x] = ode45(fun,[t0, tf],x0)
% direct solutions
[t,x] = ode45(fun,[t0, tf],x0,opts)
% solver with control options
[t,x] = ode45(fun,[t0, tf],x0,opts,p1,p2, · · · )
% solver with additional variables
where the diﬀerential equations should be expressed using an M-function fun, an anonymous
function. The structures of the functions will be explained through examples later. The time
span [t0, tf] describes the time interval for numerical solutions. If only one value is provided,
it means that the ﬁnal value tf with the default setting of initial time at t0 = 0. For initial
value problems, one should also specify the initial state vector x0.
Note that this function allows the selection of tf < t0, where t0 can be regarded as
the ﬁnal time, with tf the initial time. Also, x0 can be regarded as the ﬁnal value of the
equations. Thus, this function can also be used for ﬁnal value problems.
(iv) Validate the solutions
This procedure is crucial in real applications and will
be demonstrated with examples later.

Diﬀerential Equation Problems
317
In actual diﬀerential equation solving processes, sometimes one may further assign some
control options. This can be done with the use of the variable opts. The initial opts template
can be obtained with the function odeset(). This template is a structured variable with
many ﬁelds. Some of the frequently used ﬁelds are given in Table 7.2.
TABLE 7.2: Control parameters in diﬀerential equation solutions.
Parameters
Descriptions to the parameters
RelTol
Upper-bound of the relative error tolerance. The default value is 0.001, i.e., 0.1% relative
error. In most applications, this value should be reduced to ensure that the results are
accurate
AbsTol
A vector controlling the permissible absolute error in states. The default value is 10−6.
Of course, this value can be changed to improve the accuracy of solution
MaxStep
Maximum allowed step-size
Mass
Mass matrix, which is used in describing diﬀerential algebraic equations
Jacobian
The function describing the Jacobian matrix ∂f/∂x. If the Jacobian matrix is known, the
simulation process can speed up
Two methods can be used in modifying the opts template. One is by the use of the
function odeset(), and the other is by the modiﬁcation of the ﬁelds directly. For instance,
if one wants to assign the relative error tolerance to 10−7, either of the following statements
can be used
opts = odeset(’RelTol’,1e-7);
% assign it by odeset() function
opts = odeset; opts.RelTol= 1e-7;
% by direct assignment
In many diﬀerential equation solution applications, sometimes additional variables may
be used for ﬂexible testing of various parameter combinations. These additional variables,
denoted by p1, p2, · · · , pm, should be properly declared and passed to the MATLAB
description for the f(t, x) function. When calling the diﬀerential equation solver, the
parameters should also be matched in the same order.
Apart from the solver ode45(), other solvers can also be used, and among them, there
are solvers ode15s(), ode23(), ode113(), ode23t(), ode23tb(), ode23s().
Example 7.9
Consider the well-known Lorenz equation given by
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x′
1(t) = −βx1(t) + x2(t)x3(t)
x′
2(t) = −ρx2(t) + ρx3(t)
x′
3(t) = −x1(t)x2(t) + σx2(t) −x3(t),
where β = 8/3, ρ = 10, σ = 28. The initial values are given by x1(0) = x2(0) = 0, x3(0) = ϵ,
and ϵ is a very small positive number, i.e., ϵ = 10−10. Find the numerical solutions to the
initial value problem of the given diﬀerential equations.
Solution
It is obvious that these ordinary diﬀerential equations are nonlinear time-
invariant with no analytical solutions. Numerical solutions should be pursued. For the
equations, an anonymous function can be prepared as follows for use with the function
ode45() to directly solve the equations.

318
Scientiﬁc Computing with MATLAB®
>> f=@(t,x)[-8/3*x(1)+x(2)*x(3); -10*x(2)+10*x(3); ...
-x(1)*x(2)+28*x(2)-x(3)]; % 3 rows for 3 equations in vector form
t_final=100; x0=[0;0;1e-10];
% terminate tine and initial states
[t,x]=ode45(f,[0,t_final],x0); subplot(121), plot(t,x)
% solve & plot
subplot(122), plot3(x(:,1),x(:,2),x(:,3)); grid % phase space trajectory
In the above MATLAB statements, t final denotes the terminating time, x0 is the
initial state vector. The ﬁrst drawing command shows the dynamical curves of the states
versus time, as in Figure 7.2 (a). In the second drawing command, the three-dimensional
phase space trajectory is visualized as shown in Figure 7.2 (b). So, the seemingly diﬃcult
nonlinear diﬀerential equations with known initial values can be solved using only a few
MATLAB statements.
0
10
20
30
40
50
60
70
80
90
100
−30
−20
−10
0
10
20
30
40
50
(a) time responses of the state variables
0
10
20
30
40
50
−20
−10
0
10
20
−30
−20
−10
0
10
20
30
(b) 3D phase space trajectory
FIGURE 7.2: Numerical solutions of the Lorenz equations.
Furthermore, the best command to visualize the three-dimensional trajectory is by the
use of the function comet3(x(:,1),x(:,2),x(:,3)), where the animated display shows
the trace of the trajectory.
From the above example, it can be observed that if the diﬀerential equations to be solved
can be expressed by ﬁrst-order explicit ones, using the numerical solutions can immediately
be found with function ode45(). Therefore, preparing a MATLAB function describing the
equations is a crucial step in solving the initial value problems.
III. Solving ODEs with additional variables in MATLAB
In the ordinary diﬀerential equation solving process, frequently one may introduce
additional variables so that when the parameters in the equations are changed, they can
be modiﬁed through the additional variables rather than having to modify the MATLAB
function itself. For instance, the Lorenz equations in Example 7.9 contain parameters such
as β, ρ and σ and they can all be considered as additional variables. Thus, when their
values change, one does not have to modify the MATLAB function describing the Lorenz
equations. The following example illustrates the method and beneﬁts of using additional
variables in diﬀerential equation solvers.
Example 7.10
Write a MATLAB function to describe the Lorenz equations in Example

Diﬀerential Equation Problems
319
7.9 with additional variables. Then, use the new function to ﬁnd the numerical solutions for
another set of parameters β = 2, ρ = 5 and σ = 20.
Solution Select the variables β, ρ and σ as the additional variables. The new anonymous
function for the diﬀerential equations can then be written as
>> f=@(t,x,beta,rho,sigma)[-beta*x(1)+x(2)*x(3);
-rho*x(2)+rho*x(3); -x(1)*x(2)+sigma*x(2)-x(3)];
From the new anonymous function, the following statements can be used instead for the
numerical solutions
>> t_final=100; x0=[0;0;1e-10]; % terminate tine and initial states
b1=8/3; r1=10; s1=28;
%
one may also use other variable names
[t,x]=ode45(f,[0,t_final],x0,[],b1,r1,s1); subplot(121), plot(t,x)
subplot(122); plot3(x(:,1),x(:,2),x(:,3)); % phase space trajectory
With the above statements, it can be seen that the additional variables can easily be passed
to function f(t, x). Moreover, the opts variable is replaced by an empty matrix, which means
that the control parameters need not be changed.
Using MATLAB functions with additional variables, the Lorenz equation with other
values of β, ρ and σ can be solved directly, without the need of modifying the existing
anonymous function, and with β = 1, ρ = 5 and σ = 20, the following statements can be
used to ﬁnd the numerical solutions. The time responses and phase space trajectory obtained
are shown in Figures 7.3 (a) and (b), respectively.
>> tf=100; x0=[0;0;1e-10]; b2=2; r2=5; s2=20;
% additional parameters
[t2,x2]=ode45(f,[0,tf],x0,[],b2,r2,s2); subplot(121), plot(t2,x2)
subplot(122); plot3(x2(:,1),x2(:,2),x2(:,3)); % phase space trajectory again
0
20
40
60
80
100
−20
−10
0
10
20
30
40
(a) time responses of state variables
0
20
40
60
−20
0
20
−20
0
20
40
(b) three-dimensional phase trajectory
FIGURE 7.3: Results of Lorenz equations under a new set of parameters.
If the diﬀerential equation can be described by anonymous function, it is not necessary
to use additional variables, since the variables in MATLAB workspace can be used directly.
For instance, the equation can be solved with
>> b=8/3; r=10; s=28; % anonymous function uses workspace variables
f=@(t,x)[-b*x(1)+x(2)*x(3); -r*x(2)+r*x(3); -x(1)*x(2)+s*x(2)-x(3)];
[t,x]=ode45(f,[0,t_final],x0); % solve ODE for another set of data

320
Scientiﬁc Computing with MATLAB®
7.3
Transforms to Standard Diﬀerential Equations
From the above description and introduction, it can be seen that only the ﬁrst-order
vector form explicit ordinary diﬀerential equations x′(t) = f(t, x) can be solved using the
relevant diﬀerential equation solvers in MATLAB. If the equations are described by high-
order ones, one has to convert the equations ﬁrst into the ﬁrst-order vector form explicit
equations. In this subsection, two diﬀerent cases are explored.
7.3.1
Manipulating a single high-order ODE
Assume that a high-order diﬀerential equation can be expressed as
y(n) = f(t, y, y′, · · · , y(n−1)),
(7-3-1)
and the initial conditions of the output signal and its derivatives are y(0), y′(0), · · · ,
y(n−1)(0). One may select a set of state variables
x1 = y, x2 = y′, · · · , xn = y(n−1).
(7-3-2)
Taking ﬁrst order derivatives for the above variables, it is immediately found that x′
1 =
y′ = x2, x′
2 = y′′ = x3, · · · , x′
n−1 = y(n−1) = xn. Finally, x′
n = y(n). Taking into account
of the original diﬀerential equation, it is found that x′
n = f(t, x1, x2, · · · , xn). Summarizing
the above results, the high-order diﬀerential equation can be converted into the following
ﬁrst-order vector form explicit equations
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
x′
1 = x2
x′
2 = x3
...
x′
n = f(t, x1, x2, · · · , xn),
(7-3-3)
with initial states x1(0) = y(0), x2(0) = y′(0), · · · , xn(0) = y(n−1)(0). Therefore, the
converted diﬀerential equations can directly be solved using the numerical methods
introduced earlier.
Example 7.11
Consider again the Van der Pol equation y′′ + μ(y2 −1)y′ + y = 0. If the
initial conditions y(0) = −0.2, y′(0) = −0.7 are given, solve numerically the Van der Pol
equation for diﬀerent values of μ’s.
Solution
Since the MATLAB functions illustrated earlier can only deal with ﬁrst-order
explicit diﬀerential equations, conversion should be made before the problem can be solved
numerically using the MATLAB ODE solvers. For this example, by choosing the state
variables x1 = y, x2 = y′, the original diﬀerential equation can be converted to

x′
1 = x2
x′
2 = −μ(x2
1 −1)x2 −x1.
It is not wise to write one function for each interested value of μ. The concept of
additional variables should be introduced so as to pass the value of μ to the function f(t, x).
Thus, an anonymous function can be written. The calling syntax of ode45() is by additional

Diﬀerential Equation Problems
321
variables. The initial state vector is given by x = [−0.2, −0.7]T, and the ﬁnal solution can
be obtained from
>> f=@(t,x,mu)[x(2); -mu*(x(1)^2-1)*x(2)-x(1)]; x0=[-0.2;-0.7];
t_final=20; mu=1; [t1,y1]=ode45(f,[0,t_final],x0,[],mu);
mu=2; [t2,y2]=ode45(f,[0,t_final],x0,[],mu); plot(t1,y1,t2,y2,’:’)
figure; plot(y1(:,1),y1(:,2),y2(:,1),y2(:,2),’:’)
and for μ = 1, 2, the time responses and the phase plane trajectories are shown respectively
in Figures 7.4 (a) and (b). It can be seen that both the phase plane trajectories settle down
on corresponding closed-paths. The closed-path is referred to as the limit cycle.
0
5
10
15
20
−4
−3
−2
−1
0
1
2
3
4
(a) time responses for diﬀerent values of μ
−3
−2
−1
0
1
2
3
−4
−3
−2
−1
0
1
2
3
4
(b) phase plane trajectories
FIGURE 7.4: Van der Pol equation solutions for diﬀerent values of μ’s.
If one changes the value of μ, say, μ = 1000, and sets the terminate time tf = 3000, the
following statements can be used to ﬁnd the numerical solution to the corresponding Van
der Pol equation.
>> x0=[2;0]; t_final=3000; % a counter example, do not run the following
mu=1000; [t,y]=ode45(f,[0,t_final],x0,[],mu);
However, even after a long wait, the solutions cannot be found, since the step-size used
might be too small and too many computation points may be involved. Thus, this kind of
ordinary diﬀerential equation with known initial values may not be suitably solvable by
ode45() functions. In the next section, stiﬀequations-based algorithms will be presented
to solve the problem.
7.3.2
Manipulating multiple high-order ODEs
Now consider the diﬀerential equation sets composed of several explicit high-order
diﬀerential equations. For example,

x(m) = f(t, x, x′, · · · , x(m−1), y, · · · , y(n−1))
y(n) = g(t, x, x′, · · · , x(m−1), y, · · · , y(n−1)).
(7-3-4)
Let us still select the state variables x1 = x, x2 = x′, · · · , xm = x(m−1), xm+1 =

322
Scientiﬁc Computing with MATLAB®
y, xm+2 = y′, · · · , xm+n = y(n−1). Therefore, the original high-order diﬀerential equations
can be converted to
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x′
1 = x2
...
x′
m = f(t, x1, x2, · · · , xm+n)
x′
m+1 = xm+2
...
x′
m+n = g(t, x1, x2, · · · , xm+n).
(7-3-5)
Therefore, the desirable ﬁrst-order vector form explicit ordinary diﬀerential equations
can be obtained. The following example illustrates the conversion and solution process.
Example 7.12
The trajectory (x, y) of the Apollo satellite satisﬁes the following
diﬀerential equation sets [5]
x′′ = 2y′ + x −μ∗(x + μ)
r3
1
−μ(x −μ∗)
r3
2
,
y′′ = −2x′ + y −μ∗y
r3
1
−μy
r3
2
,
where μ = 1/82.45, μ∗= 1 −μ, r1 =

(x + μ)2 + y2, r2 =

(x −μ∗)2 + y2. It is known
that the initial values are given by x(0) = 1.2, x′(0) = 0, y(0) = 0, y′(0) = −1.04935751.
Solve the diﬀerential equations and draw the trajectory of (x, y).
Solution
The state variables are chosen as x1 = x, x2 = x′, x3 = y, x4 = y′. Thus, the
ﬁrst-order explicit diﬀerential equations can be found as follows
⎧
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎩
x′
1 = x2
x′
2 = 2x4 + x1 −μ∗(x1 + μ)/r3
1 −μ(x1 −μ∗)/r3
2
x′
3 = x4
x′
4 = −2x2 + x3 −μ∗x3/r3
1 −μx3/r3
2,
where r1 =

(x1 + μ)2 + x2
3, r2 =

(x1 −μ∗)2 + x2
3, and μ = 1/82.45, μ∗= 1 −μ.
From the above mathematical equations obtained, the MATLAB function describing the
original diﬀerential equations is prepared as follows:
function dx=apolloeq(t,x) % not suitable for anonymous function
mu=1/82.45; mu1=1-mu; r1=sqrt((x(1)+mu)^2+x(3)^2);
r2=sqrt((x(1)-mu1)^2+x(3)^2);
% intermediate variables computation
dx=[x(2); 2*x(4)+x(1)-mu1*(x(1)+mu)/r1^3-mu*(x(1)-mu1)/r2^3;
x(4); -2*x(2)+x(3)-mu1*x(3)/r1^3-mu*x(3)/r2^3];
Since there are some intermediate computation steps involved, the anonymous or inline
functions are not suitable. Using ode45() function, the numerical solutions of the equations
are as follows, with the trajectory shown in Figure 7.5 (a).
>> x0=[1.2; 0; 0; -1.04935751];
% initial states
tic, [t,y]=ode45(@apolloeq,[0,20],x0); toc % measure time elapsed
length(t), plot(y(:,1),y(:,3)) % count number of points computed
For this example, the elapsed time is 0.33 seconds. Also, the number of points calculated
is returned by the use of length() function. For this example, the number of points is 689.
In fact, the obtained trajectory is not correct, since in the simulation control parameters,

Diﬀerential Equation Problems
323
the relative error tolerance RelTol is too large. To have more accurate results, one usually
should reduce that value, for instance, to 10−6. Let us use the following statements to solve
the diﬀerential equations again:
>> options=odeset; options.RelTol=1e-6; % set controls and try again
tic, [t1,y1]=ode45(@apolloeq,[0,20],x0,options); toc % measure time
length(t1), plot(y1(:,1),y1(:,3))
% count number of points
The elapsed time is 0.701 seconds, with 1873 computation points. The new trajectory
obtained is shown in Figure 7.5 (b). It can be seen that the diﬀerent results are obtained
and further reducing the error tolerance will yield the same numerical results. It can be
concluded that it is always necessary to validate the simulation results after simulation by
reducing the error tolerance RelTol.
−1.5
−1
−0.5
0
0.5
1
1.5
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(a) results with default parameters (erroneous)
−1.5
−1
−0.5
0
0.5
1
1.5
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(b) improved results
FIGURE 7.5: The trajectories of Apollo with diﬀerent numerical accuracy speciﬁcations.
The following statements can be used to ﬁnd the step-sizes used in the simulation process,
as shown in Figure 7.6. The minimum step-size is 1.8927×10−4.
0
5
10
15
20
0
0.01
0.02
0.03
0.04
0.05
FIGURE 7.6: The step-sizes over time in the simulation process.
>> plot(t1(1:end-1),diff(t1)), min(diff(t1)) % plot step-size
From the above step-size curve, it can be seen that when variable step-size algorithms
are used, the step-size can be adapted according to the error accuracy requirements. In part

324
Scientiﬁc Computing with MATLAB®
of the simulation period, step-sizes larger than 0.03 are used. However, in order to keep
precision under control, at some points, very small step-size of 2×10−4 is used. If ﬁxed-step
algorithms are used, in order to make sure that the simulation results reliable, a small step-
size of 2×10−4 should be used in the whole simulation process. The computation required
becomes a total of 105 steps, which is 56 times more than the number of points used in the
variable-step algorithm. Therefore, variable step-size approaches are more eﬀective.
Example 7.13
Solve the Apollo problem using ﬁxed-step Runge–Kutta algorithm.
Solution To use ﬁxed-step algorithms, one should consider two problems ﬁrst: (i) how to
select the step-size, (ii) how to ensure the accuracy in computation. The ﬁrst problem can
only be solved by trial-and-error approach. When selecting step-sizes, small step-size can be
tested. However, the computational cost could be very high. For instance, a step-size of 0.01
will produce the trajectory shown in Figure 7.7 (a). The computation time is 2.654 seconds.
>> x0=[1.2; 0; 0; -1.04935751]; % initial states and solve the ODE
tic, [t,y]=rk_4(@apolloeq,[0,20,0.01],x0); toc, plot(y(:,1),y(:,3))
It is obvious that the results thus obtained are wrong, thus, a smaller step-size should be
used instead. If one selects a smaller step-size 0.001, more accurate results can be obtained
and the trajectory is shown in Figure 7.7 (b). However, the time required is 97.079 seconds,
which is about 138 times the time required for the variable-step computation.
>> tic, [t2,y2]=rk_4(@apolloeq,[0,20,0.001],x0); toc % solve again
plot(y2(:,1),y2(:,3))
% draw trajectory
−80
−60
−40
−20
0
20
40
60
80
−100
−50
0
50
100
(a) step-size of 0.01
−1.5
−1
−0.5
0
0.5
1
1.5
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
(b) step-size of 0.001
FIGURE 7.7: The Apollo trajectories under diﬀerent step-sizes.
In fact, strictly speaking, the results obtained using the ﬁxed-step algorithm cannot satisfy
the requirement of 10−6 relative error tolerance, although the shape of the responses is similar
to the one obtained from variable-step ODE solvers.
The following example illustrates how to transform two simultaneous high-order implicit
diﬀerential equations into the standard ﬁrst-order vector form ones involving symbolic
computation.
Example 7.14
Consider the following high-order implicit diﬀerential equations

Diﬀerential Equation Problems
325

x′′ + 2y′x = 2y′′
x′′y′ + 3x′y′′ + xy′ −y = 5.
Convert it into the ﬁrst-order explicit diﬀerential equations.
Solution In the above two equations, both x′′ and y′′ are cross-related. Let us still select
the state variables as x1 = x, x2 = x′, x3 = y, x4 = y′. Our purpose is to eliminate one
of the high-order terms and solve for the other. Thus, it can be found that the analytical
expression of y′′ is
y′′ = y′x + x′′
2 .
Substituting it into the section equation, x′′ can be found that
x′′ = 2y + 10 −2xy′ −6xx′y′
2y′ + 3x′
.
Thus, the state equation can be written as
x′
2 = 2x3 + 10 −2x1x4 −6x1x2x4
2x4 + 3x2
,
x′
4 = x3 + 5 −x1x4 + 2x1x2
4
2x4 + 3x2
.
The converted ﬁrst-order explicit diﬀerential equation can then be written as
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x′
1 = x2
x′
2 = 2x3 + 10 −2x1x4 −6x1x2x4
2x4 + 3x2
x′
3 = x4
x′
4 = x3 + 5 −x1x4 + 2x1x2
4
2x4 + 3x2
.
In fact, some of the above equations may not be easily solved manually. Sometimes
one may solve the conversion problem using Symbolic Math Toolbox. For simplicity, denote
dx = x′′ and dy = y′′, thus, dx and dy are x′
2 and x′
4. The following statements can be used
to solve the equations
>> syms x1 x2 x3 x4 dx dy % solve analytically for dx and dy
[y1,y2]=solve(dx+2*x4*x1==2*dy,dx*x4+3*x2*dy+x1*x4-x3==5,dx,dy)
The derivatives of the variables can be written as
x′
2 = −23x4x1x2 −5 + x4x1 −x3
3x2 + 2x4
, x′
4 = 2x2
4x1 + 5 −x4x1 + x3
3x2 + 2x4
.
It can be seen that the results are exactly the same as the previous results.
For more complicated problems, solving the corresponding algebraic equations manually
might be extremely diﬃcult, if not impossible. Therefore, algebraic equations may be
embedded in the MATLAB function describing the ﬁrst-order explicit equations. These
related numerical solution methods will be discussed in the following section.
7.3.3
Validation of numerical solutions to ODEs
It has been shown through examples that if the control parameters are not properly
chosen, the solutions may not even be correct. Thus, the numerical solutions should be
validated. However, since the equations have no analytic solutions, an alternative method

326
Scientiﬁc Computing with MATLAB®
to validate the solution is by setting the control parameters to diﬀerent values and checking
whether they yield the same results. The most eﬀective control parameter is the RelTol
property. The default value for it is 10−3, which is usually too large for many applications. It
can be set to 10−6 or even 10−8. This approach may usually not add too much computation
eﬀort. Alternatively, selecting diﬀerent ODE solvers may also cross-validate the results.
7.3.4
Transformation of diﬀerential matrix equations
In some real applications, matrix-type diﬀerential equations are preferred. For instance,
the Lagrange equation can be expressed as
MX′′ + CX′ + KX = F u(t),
(7-3-6)
where M, C, K are n × n matrices, and X, F are n × 1 column vectors. Introducing the
vectors x1 = X and x2 = X′, it is found that x′
1 = x2, and x′
2 = X′′. From (7-3-6), it is
found that X′′ = M −1
F u(t) −CX′ −KX

. The new state vector can be expressed as
x = [xT
1 , xT
2 ]T, the state space equation can be rewritten as
x′(t) =
 
x2(t)
M −1
F u(t) −Cx2(t) −Kx1(t)

!
,
(7-3-7)
which is exactly an explicit vector form ﬁrst-order diﬀerential equations directly solvable
with the corresponding MATLAB ODE solver functions.
Example 7.15
Consider the inverted pendulum model expressed as [6]
M(θ)θ′′ + C(θ, θ′)θ′ = F (θ),
where θ = [a, θ1, θ2]T, and a is the position of the cart, and θ1, θ2 are the angles of the two
bars. The matrices are given by
M(θ) =
⎡
⎣
mc + m1 + m2
(0.5m1 + m2)L1 cos θ1
0.5m2L2 cos θ2
(0.5m1 + m2)L1 cos θ1
(m1/3 + m2)L2
1
0.5m2L1L2 cos θ1
0.5m2L2 cos θ2
0.5m2L1L2 cos θ1
m2L2
2/3
⎤
⎦,
C(θ, θ′) =
⎡
⎣
0
−(0.5m1 + m2)L1θ′
1 sin θ1
−0.5m2L2θ′
2 sin θ2
0
0
0.5m2L1L2θ′
2 sin(θ1 −θ2)
0
−0.5m2L1L2θ′
1 sin(θ1 −θ2)
0
⎤
⎦,
F (θ) =
⎡
⎣
u(t)
(0.5m1 + m2)L1g sin θ1
0.5m2L2g sin θ2
⎤
⎦.
The parameters for a particular experimental system are mc = 0.85kg, m1 = 0.04kg,
m2 = 0.14kg, L1 = 0.1524m, and L2 = 0.4318m. Find the step response of the system.
Solution The coeﬃcient matrices M(θ1, θ2), C(θ1, θ2) and F (θ1, θ2) contain the nonlinear
terms of the state vector x, for instance the cosine terms of θ1. Introducing additional
variables x1 = θ and x2 = θ′, the new state vector x = [xT
1 , xT
2 ]T can be constructed and
the explicit ﬁrst-order diﬀerential equation can be established
function dx=inv_pendulum(t,x,u,mc,m1,m2,L1,L2,g)

Diﬀerential Equation Problems
327
M=[mc+m1+m2, (0.5*m1+m2)*L1*cos(x(2)), 0.5*m2*L2*cos(x(3))
(0.5*m1+m2)*L1*cos(x(2)),(m1/3+m2)*L1^2,0.5*m2*L1*L2*cos(x(2))
0.5*m2*L2*cos(x(3)),0.5*m2*L1*L2*cos(x(2)),m2*L2^2/3];
C=[0,-(0.5*m1+m2)*L1*cos(x(5))*sin(x(2)),-0.5*m2*L2*x(6)*sin(x(3))
0, 0, 0.5*m2*L1*L2*x(6)*sin(x(2)-x(3))
0, -0.5*m2*L1*L2*x(5)*sin(x(2)-x(3)), 0];
F=[u; (0.5*m1+m2)*L1*g*sin(x(2)); 0.5*m2*L2*g*sin(x(3))];
dx=[x(4:6); inv(M)*(F-C*x(4:6))];
The input signal u(t) is a step signal, and the following statements can be used to solve
numerically the diﬀerential equations. The results are shown in Figures 7.8 (a) and (b).
0
0.1
0.2
0.3
0.4
0.5
−5
−4
−3
−2
−1
0
1
a
θ2
θ1
(a) θ curves
0
0.1
0.2
0.3
0.4
0.5
−25
−20
−15
−10
−5
0
5
a′
θ′
2
θ′
1
(b) θ′ curves
FIGURE 7.8: Step responses of the inverted pendulum.
>> opt=odeset; opt.RelTol=1e-8; u=1; mc=0.85;
m1=0.04; m2=0.14; L1=0.1524; L2=0.4318; g=9.81; x0=zeros(6,1);
[t,x]=ode45(@inv_pendulum,[0,0.5],x0,opt,u,mc,m1,m2,L1,L2,g);
subplot(121), plot(t,x(:,1:3)), subplot(122), plot(t,x(:,4:6))
It should be noted that the inverted pendulum system is naturally unstable. A properly
designed input signal constructed from the state vector information should be applied to
stabilize the system.
Furthermore, if the matrices M, C, K and F are independent of X, the original matrix
type diﬀerential equations become linear time-invariant diﬀerential equations, given by
⎡
⎣x′
1(t)
x′
2(t)
⎤
⎦=

0
I
−M −1K −M −1C
 ⎡
⎣x1(t)
x2(t)
⎤
⎦+

0
M −1F

u(t).
(7-3-8)
Riccati diﬀerential equations are another commonly encountered matrix diﬀerential
equations. The general form of the equation is
P ′(t) = ATP (t) + P (t)A + P (t)BP (t) + C,
(7-3-9)
where, B, C are symmetrical matrices. Assume that the condition P (tf) at terminal time
tf is known, and the numerical solution over the time interval (t0, tf) is expected. Since
the function P (t) is in matrix form and should be converted to vector form, the function
reshape() can be used to convert a vector to a matrix, or use P (:) to convert a matrix into
a vector. The following command can be used to describe the Riccati diﬀerential equation,

328
Scientiﬁc Computing with MATLAB®
function dy=ric_de(t,x,A,B,C)
P=reshape(x,size(A)); Y=A’*P+P*A+P*B*P+C; dy=Y(:);
Luckily, the function ode45() allows the actual “starting time” larger than the “terminal
time,” thus, in solving the ODE, the time span tspan= [tf,0], with the following syntax
[t,p] = ode45(@ric de,[tf,0],Pf(:),opts,A,B,C).
Example 7.16 Suppose the matrices and terminal values of a Riccati diﬀerential equation
are given below. Please solve numerically the Riccati diﬀerential equation.
A =
⎡
⎣
6
6
17
1
0
−1
−1
0
0
⎤
⎦, B =
⎡
⎣
0
0
0
0
4
2
0
2
1
⎤
⎦, C =
⎡
⎣
1
2
0
2
8
0
0
0
4
⎤
⎦, P1(0.5) =
⎡
⎣
1
0
0
0
3
0
0
0
5
⎤
⎦.
Solution With the relevant statements, the Riccati diﬀerential equations can be solved, and
the results are shown in Figure 7.9.
>> A=[6,6,17; 1,0,-1; -1,0,0]; B=[0,0,0; 0,4,2; 0,2,1];
C=[1,2,0; 2,8,0; 0,0,4]; P1=[1,0,0; 0,3,0; 0,0,5];
[t,p]=ode45(@ric_de,[0.5,0],P1(:),[],A,B,C); plot(t,p)
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
0.45
0.5
−1
0
1
2
3
4
5
p33(t)
p22(t)
p11(t)
p23(t) = p32(t)
p12(t) = p21(t)
p13 =p31
FIGURE 7.9: Numerical solutions of Riccati diﬀerential equation.
Now, with the value obtained at t = 0 in the previous solution used as the initial vector,
and Riccati equation can be solved again, and the results are also shown in Figure 7.9, and
it can be seen that exactly the same results can be obtained.
>> P=p(end,:); P0=reshape(P,size(A)); % the ﬁnal value matrix
[t1,p1]=ode45(@ric_de,[0,0.5],P0(:),[],A,B,C); plot(t1,p1) % solution
7.4
Solutions to Special Ordinary Diﬀerential Equations
From the introduction and examples in Section 7.2, one can easily convert a given
ordinary diﬀerential equation into ﬁrst-order vector form explicit one. The function ode45()
can then be used to solve the equations. However, it is also shown from some examples, for
instance the Van der Pol equation with μ = 1000 cannot be solved by using the ode45()

Diﬀerential Equation Problems
329
function. Thus, other types of diﬀerential equations should be introduced, for instance,
the stiﬀequations. Special MATLAB functions can be used to solve the stiﬀequation
problems. Moreover, some special types of diﬀerential equations such as diﬀerential algebraic
equations, implicit diﬀerential equations and delay diﬀerential equations will be discussed
in this section.
7.4.1
Solutions of stiﬀordinary diﬀerential equations
In many diﬀerential equations, some states change very rapidly while others may change
very slowly. This type of diﬀerential equation is usually referred to as a stiﬀequation. The
function ode45() is not suitable for stiﬀequations. An alternative function, ode15s(), can
be used instead and this function has exactly the same syntax as that of the ode45()
function.
Example 7.17 Find the numerical solutions to the Van der Pol equation, when μ = 1000,
which was used as a counter example in Example 7.11.
Solution
Similar to the statements given earlier, if the function ode15s() is used, the
states can be obtained directly in 3.15 seconds, and the time responses of the states are
shown in Figure 7.10.
>> h_opt=odeset; h_opt.RelTol=1e-6; x0=[2;0]; t_final=3000;
f=@(t,x,mu)[x(2); -mu*(x(1)^2-1)*x(2)-x(1)];
tic, mu=1000; [t,y]=ode15s(f,[0,t_final],x0,h_opt,mu); toc
subplot(121), plot(t,y(:,1)); subplot(122); plot(t,y(:,2))
0
500
1000
1500
2000
2500
3000
−3
−2
−1
0
1
2
3
(a) state variable x1(t)
0
500
1000
1500
2000
2500
3000
−1500
−1000
−500
0
500
1000
1500
(b) state variable x2(t)
FIGURE 7.10: Solutions of Van der Pol equation with μ = 1000.
It can be seen that, stiﬀODE solver can be used to solve this type of equation rapidly. It
can be seen that that the two equations at some particular points have almost vertical time
responses, which makes the selection of step-size diﬃcult.
Example 7.18 In classical textbooks regarding numerical solutions to ordinary diﬀerential
equations, the following equation is regarded as stiﬀ.
y′ =
⎡
⎣
−21
19
−20
19
−21
20
40
−40
−40
⎤
⎦y,
y0 =
⎡
⎣
1
0
−1
⎤
⎦.

330
Scientiﬁc Computing with MATLAB®
Find the numerical solutions with MATLAB.
Solution The analytical solutions of the equations can be found symbolically by the following
statements
>> syms t; A=sym([-21,19,-20; 19,-21,20; 40,-40,-40]);
y0=[1; 0; -1]; y=expm(A*t)*y0 % analytical solution of linear equation
which yields
y(t) =
⎡
⎢⎢⎢⎣
0.5e−2t + 0.5e−40t(cos 40t + sin 40t)
0.5e−2t −0.5e−40t(cos 40t + sin 40t)
e−40t(sin 40t −cos 40t)
⎤
⎥⎥⎥⎦.
Now let us consider the numerical solutions to the same problem. Prepare an anonymous
function, and ﬁnd the numerical solutions by the following statements
>> opt=odeset; opt.RelTol=1e-6;
f=@(t,x)[-21,19,-20; 19,-21,20; 40,-40,-40]*x;
tic,[t,y]=ode45(f,[0,1],[1;0;-1],opt); toc % ﬁnd numerical solution
x1=exp(-2*t); x2=exp(-40*t).*cos(40*t); x3=exp(-40*t).*sin(40*t);
y1=[0.5*x1+0.5*x2+0.5*x3, 0.5*x1-0.5*x2-0.5*x3, -x2+x3];
plot(t,y,t,y1,’:’) % compare exact and numerical solution
and it can be seen that only 0.16 seconds are used to ﬁnd the solutions using the ode45()
function. The analytical and numerical solutions can be shown in Figure 7.11 (a). It can be
seen that the accuracy of the results are rather high, and computation speed is also very high.
The stiﬀness of the problem seems to be not very obvious. This is because the variable-step
algorithm is used, and the step-size can adaptively be modiﬁed so the stiﬀness of the problem
may not cause serious issues. However, if a ﬁxed-step algorithm is used, for instance, the
fourth-order Runge–Kutta algorithm is applied, the following statements
>> tic, [t2,y2]=rk_4(f,[0,1,0.01],[1;0;-1]); toc, plot(t,y1,t2,y2,’:’)
produce numerical results shown in Figure 7.11 (b) together with the analytical curves.
The elapsed time is 0.21 seconds, which is slightly longer than the direct use of ode45()
function. From the results, it can be seen that the ﬁxed-step approach gives erroneous results
if the step-size if large. Further reducing the step-size until h = 0.0001 seconds, one can
still see the diﬀerence between the analytical and numerical results. However, this time, the
time required is about 26 seconds, which is 162 times longer than the time required for the
ode45() function. Thus, in practical applications, the variable-step algorithm should be used
whenever possible.
It can further be tested that in the ﬁxed-step algorithm, if the step-size is 0.00001, the
time required may as long as 8124 seconds, more than two hours.
It can be concluded that for many conventional stiﬀequations, one may still try to use
the ordinary ODE solvers such as ode45() rather than the stiﬀequation solver. If for some
examples, the time consumed using ode45() is too much, the stiﬀequation solver should
be used instead. This will be illustrated in the following Example 7.19.
Example 7.19
Consider the following ordinary diﬀerential equations

Diﬀerential Equation Problems
331
0
0.2
0.4
0.6
0.8
1
−1
−0.5
0
0.5
1
x1(t)
x2(t)
x3(t)
(a) variable-step solutions
0
0.2
0.4
0.6
0.8
1
−1
−0.5
0
0.5
1
(b) ﬁxed-step solutions
FIGURE 7.11: Comparisons of solutions of a traditional stiﬀequation.
⎧
⎨
⎩
y′
1(t) = 0.04(1 −y1(t)) −(1 −y2(t))y1(t) + 0.0001(1 −y2(t))2
y′
2(t) = −104y1(t) + 3000(1 −y2(t))2,
where the initial values are y1(0) = 0, y2(0) = 1. Within the time interval t ∈(0, 100), ﬁnd
a suitable algorithm for the initial value problem.
Solution
For the given diﬀerential equations, an anonymous function can be written to
describe the right-hand-side functions, then, the following statements can be issued in the
MATLAB command window to ﬁnd the numerical solutions.
>> f=@(t,y)[0.04*(1-y(1))-(1-y(2))*y(1)+0.0001*(1-y(2))^2;
-10^4*y(1)+3000*(1-y(2))^2];
tic, [t2,y2]=ode45(f,[0,100],[0;1]); toc % measure time elapsed
length(t2), plot(t2,y2)
% count number of points
After a long wait for about 43 seconds, the numerical solutions can be obtained. The
number of points computed is 356,941. The numerical solutions are shown in Figure 7.12
(a). It is found that the function ode45() takes too much time. Also, the step-sizes can be
obtained from the following statements
>> plot(t2(1:end-1),diff(t2)) % draw step-size
and the step-sizes are shown in Figure 7.12 (b). It can be seen that during the whole
simulation period the step-sizes are very small. In most of the time interval, the step-sizes
are about 0.004, which increases signiﬁcantly the computation time. The adaptation in the
step-size also consumes a tremendous amount of time.
Now consider the use of ode15s() instead, the following statements can be used
>> opt=odeset; opt.RelTol=1e-6; % use another solver and try again
tic,[t,y]=ode15s(f,[0,100],[0;1],opt); toc, length(t), plot(t,y)
and it can be seen that the time required is reduced signiﬁcantly to 0.26 seconds, which is
about 1/160 of the time by ode45(). The number of points computed is 169. The curves
obtained are almost identical to the previous results.

332
Scientiﬁc Computing with MATLAB®
0
20
40
60
80
100
0
0.2
0.4
0.6
0.8
1
(a) solutions to diﬀerential equations
0
20
40
60
80
100
0
0.5
1
1.5
2
×10−3
(b) step-sizes in simulation
FIGURE 7.12: Solution of using the 4/5 RKF algorithm.
7.4.2
Solutions of implicit diﬀerential equations
The so-called implicit diﬀerential equations are those not convertible into the ﬁrst-order
vector form explicit diﬀerential equations as in (7-2-1). In earlier versions of MATLAB,
solvers for these implicit equations were not provided. The following two examples
demonstrate the implicit diﬀerential equation solution procedures.
Example 7.20
Consider the following implicit diﬀerential equation
⎧
⎨
⎩
x′
1(t) sin x1(t) + x′
2(t) cos x2(t) + x1(t) = 1
−x′
1(t) cos x2(t) + x′
2(t) sin x1(t) + x2(t) = 0,
where x1(0) = x2(0) = 0. Find the numerical solutions to the initial value problem.
Solution Let x = [x1, x2]T. The matrix form of the equation can be written as
A(x)x′ = B(x), where A(x) =
 sin x1
cos x2
−cosx2
sin x1

,
B(x) =
1 −x1
−x2

.
If A(x) is a nonsingular matrix for all x, the ﬁrst-order vector form explicit equation can
be expressed by x′ = A−1(x)B(x). Using the methods stated earlier, the numerical solutions
can be obtained. However, it is not possible to prove theoretically that the matrix A(x) is
a nonsingular matrix. Thus, one may initially assume that matrix A(x) is nonsingular.
During the diﬀerential equation solving process, if there is no error message displayed, it will
indicate that for the solutions the matrix A(x) is nonsingular. Thus, the solutions obtained
are valid. If, however, error messages appear, then, the solutions obtained are useless.
For the equations to be solved, an anonymous function can be written, and the following
statements can be used
>> f=@(t,x)inv([sin(x(1)) cos(x(2)); -cos(x(2)) sin(x(1))])...
*[1-x(1); -x(2)]; opt=odeset; opt.RelTol=1e-6;
[t,x]=ode45(f,[0,10],[0; 0],opt); plot(t,x) % try to solve
The obtained state variables are shown in Figure 7.13. Since in the solution process, no
error messages are given, this indicates that for the solution points, the matrix A(t) is not
singular. Thus, the solutions obtained may be valid.

Diﬀerential Equation Problems
333
0
1
2
3
4
5
6
7
8
9
10
−0.2
0
0.2
0.4
0.6
0.8
1
1.2
x2(t)
x1(t)
FIGURE 7.13: Time responses of the state variables.
Example 7.21
The previous example is very simple and can be converted into explicit
diﬀerential equations immediately. Now consider a set of more complicated implicit
equations given by
⎧
⎨
⎩
x′′(t) sin y′(t) + (y′′(t))2 = −2x(t)y(t)e−x′(t) + x(t)x′′(t)y′(t)
x(t)x′′(t)y′′(t) + cos y′′(t) = 3y(t)x′(t)e−x(t).
The state variables can be selected as x1 = x, x2 = x′, x3 = y, x4 = y′. The initial
states of the equation are x = [1, 0, 0, 1]T. Find the numerical solutions of the initial value
problem.
Solution Obviously the analytical solutions for state derivatives x′
2 and x′
4 cannot be written
out as in Example 7.14. Hence, a numerical-based converting algorithm is introduced such
that the numerical solutions for each state variable x′ can be obtained.
From the original equations, assume that p1 = x′′, p2 = y′′, then, the following equation
can be written as

p1 sin x4 + p2
2 + 2x1x3e−x2 −x1p1x4 = 0
x1p1p2 + cos p2 −3x3x2e−x1 = 0,
and from the following MATLAB statements, the algebraic equation solution statements can
be embedded into the MATLAB function describing the diﬀerential equations. The MATLAB
function can then, be written as
function dy=c7impode(t,x)
dx=@(p,x)[p(1)*sin(x(4))+p(2)^2+2*x(1)*x(3)*exp(-x(2))-x(1)*p(1)*x(4);
x(1)*p(1)*p(2)+cos(p(2))-3*x(3)*x(2)*exp(-x(1))];
ff=optimset; ff.Display=’off’; dx1=fsolve(dx,x([1,3]),ff,x);
dy=[x(2); dx1(1); x(4); dx1(2)]; % embed algebraic equation solver
Once calling the function, from the input arguments x, the newly deﬁned variables p1, p2
can be used in the anonymous function, and with the use of the fsolve() function, the
variables p1 and p2 can be numerically solved. In the above MATLAB statements, x is used
as the additional variable. Thus, from this function, the variables pi can be obtained. Since
the obtained p1, p2 are in fact the derivatives of the state variables such that p1 = x′
2, p2 =
x′
4, the explicit diﬀerential equations can then be obtained and the corresponding MATLAB
scripts are given in the function as well.

334
Scientiﬁc Computing with MATLAB®
Once the explicit diﬀerential equations are obtained, the solutions to the implicit
diﬀerential equations can be solved numerically using the following statements and the time
responses of the states are shown in Figure 7.14.
>> [t,x]=ode15s(@c7impode,[0,2],[1,0,0,1]); plot(t,x) % solve ODE
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
0.5
1
1.5
2
2.5
3
3.5
4
x1(t)
x2(t)
x3(t)
x4(t)
FIGURE 7.14: Time responses of the implicit diﬀerential equations.
Function ode15i() is provided for the solutions of implicit diﬀerential equations. If the
mathematical descriptions to the implicit diﬀerential equations is written as
F [t, x(t), x′(t)] = 0, and x(t0) = x0, x′(t0) = x′
0,
(7-4-1)
then, the function fun can be used to describe the implicit equations. The new MATLAB
function decic() can be used to solve the compatible undeﬁned initial conditions. Then,
the solver function ode15i() can be used to solve the implicit diﬀerential equations.
[x∗
0,x′∗
0 ] = decic(fun,t0,x0,xF
0 ,x′
0,x′F
0 )
% ﬁnd consistent initial values
res = ode15i(fun,tspan,x∗
0,x′∗
0 )
% solve implicit equations
The solution process of the implicit diﬀerential equations is diﬀerent from the explicit
equations. In numerically solving implicit equations, the initial state variables and their
derivatives should both be declared, and they cannot be assigned arbitrarily, otherwise, there
might be conﬂicting initial conditions. Before the solution, the 2n initial values (x0, x′
0) can
only have n independent ones. The rest of the values should be solved from the corresponding
implicit algebraic equations. Thus, in the actual solution process, if one cannot determine
the values x′∗
0 , the function decic() can be used to solve for compatible initial values. In the
function call, (x0, x′
0) can be any initial values, while xF
0 and x′F
0 are both n-dimensional
column vectors and when the vector element is 1, it means that the corresponding initial
value is to be maintained, otherwise, it indicates that the initial value should be resolved.
From the corresponding algebraic equation solver, the compatible initial values x∗
0 and x′∗
0
can be obtained. The implicit diﬀerential equations can then be solved with the function
ode15i(). The returned variables res.x and res.y are respectively t and x as in other
ODE solvers. The following example demonstrates the numerical solution process of implicit
diﬀerential equations.

Diﬀerential Equation Problems
335
Example 7.22
Solve the implicit diﬀerential equations given in Example 7.21 using the
implicit ODE solver ode15i().
Solution Still select the state variables x1 = x, x2 = x′, x3 = y, x4 = y′ and the original
equations can be converted into the following:
⎧
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎩
x′
1 −x2 = 0
x′
2 sin x4 + x′2
4 + 2e−x2x1x3 −x1x′
2x4 = 0
x′
3 −x4 = 0
x1x′
2x′
4 + cos x′
4 −3e−x1x3x2 = 0.
Thus, the implicit diﬀerential equations can be entered in MATLAB using anonymous
function. The deﬁnitions of the initial values x0 are exactly the same as before. The function
decic() can be used to determine the initial derivatives. Thus, xF
0 should be assigned to a
vector of ones. Since a consistent x′
0 is expected, the indicator x′F
0 should be set to an all
zero vector. The following statements can be used to solve the implicit equations:
>> f=@(t,x,xd)[xd(1)-x(2);
xd(2)*sin(x(4))+xd(4)^2+2*exp(-x(2))*x(1)*x(3)-x(1)*xd(2)*x(4);
xd(3)-x(4);
x(1)*xd(2)*xd(4)+cos(xd(4))-3*exp(-x(1))*x(3)*x(2)];
x0=[1,0,0,1]; xd0=[0;1;1;-1]; x0F=[1 1 1 1]; xd0F=[];
% retain x0
[x0,xd0]=decic(f,0,x0,x0F,xd0,xd0F) % compute compatible conditions
r=ode15i(f,[0,2],x0,xd0); plot(r.x,r.y) % draw the time responses
With the decic() function, the consistent initial derivatives x′
0 =[0, 1.6833, 1, −0.5166]T
can be obtained. Then, the implicit equations can be solved, and the time responses of the
states can be drawn. It can be seen that the results are exactly the same as the ones shown
in Figure 7.14.
7.4.3
Solutions to diﬀerential algebraic equations
The so-called diﬀerential algebraic equation (DAE) means that some of the diﬀerential
equations are degenerated to algebraic equations. Thus, these algebraic equations appear
as the constraints in the diﬀerential equations. Diﬀerential algebraic equations cannot be
solved directly using the methods presented earlier.
The general form of the diﬀerential equations is given by
M(t, x)x′ = f(t, x), x(t0) = x0,
(7-4-2)
where the f(t, x) function description is exactly the same as in the previous sections. For
diﬀerential algebraic equations, the matrix M(t, x) is singular. Thus, in the solutions options
for MATLAB functions, the Mass property can be used to describe the matrix M(t, x) in
MATLAB. Then, the diﬀerential algebraic equations can be solved.
Example 7.23
Find the solutions to the following diﬀerential algebraic equation:
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x′
1 = −0.2x1 + x2x3 + 0.3x1x2
x′
2 = 2x1x2 −5x2x3 −2x2
2
0 = x1 + x2 + x3 −1,

336
Scientiﬁc Computing with MATLAB®
with initial conditions x1(0) = 0.8, x2(0) = x3(0) = 0.1.
Solution The last equation is an algebraic equation. It can also be regarded as a constraint
among the three state variables. The matrix form of the diﬀerential algebraic equations can
be written as
⎡
⎣
1
0
0
0
1
0
0
0
0
⎤
⎦
⎡
⎣
x′
1
x′
2
x′
3
⎤
⎦=
⎡
⎣
−0.2x1 + x2x3 + 0.3x1x2
2x1x2 −5x2x3 −2x2
2
x1 + x2 + x3 −1
⎤
⎦.
Clearly in MATLAB, function f(t, x) can be expressed by an anonymous function. The
matrix M can also be entered into MATLAB workspace, and the following statements can
be entered as well into MATLAB command window. In this problem, the solver ode45()
generates wrong results. Thus, the stiﬀequation based algorithms should be used instead.
>> f=@(t,x)[-0.2*x(1)+x(2)*x(3)+0.3*x(1)*x(2);
2*x(1)*x(2)-5*x(2)*x(3)-2*x(2)*x(2); x(1)+x(2)+x(3)-1];
M=[1,0,0; 0,1,0; 0,0,0]; options=odeset; options.Mass=M;
x0=[0.8; 0.1; 0.1]; [t,x]=ode15s(f,[0,20],x0,options); plot(t,x)
From the above statements, the diﬀerential algebraic equations can be directly solved and
the time responses of the states are shown in Figure 7.15.
0
2
4
6
8
10
12
14
16
18
20
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
x1(t)
x2(t)
x3(t)
FIGURE 7.15: Numerical solutions to diﬀerential algebraic equations.
In fact, some of the diﬀerential algebraic equations can be converted into lower-order
explicit diﬀerential equations. For instance, in the example, from the constraint, one may
immediately ﬁnd that x3(t) = 1 −x1(t) −x2(t). Substituting it into the other two equations
yields

x′
1 = −0.2x1 + x2(1 −x1 −x2) + 0.3x1x2
x′
2 = 2x1x2 −5x2(1 −x1 −x2) −2x2
2,
and the original three-state diﬀerential algebraic equations can be converted into a second-
order diﬀerential equation. A new anonymous function can be written to describe the
equations. The results using the two methods are exactly the same.
>> x0=[0.8; 0.1]; % input initial conditions
fDae=@(t,x)[-0.2*x(1)+x(2)*(1-x(1)-x(2))+0.3*x(1)*x(2);
2*x(1)*x(2)-5*x(2)*(1-x(1)-x(2))-2*x(2)*x(2)];
[t1,x1]=ode45(fDae,[0,20],x0); plot(t1,x1,t1,1-sum(x1’))

Diﬀerential Equation Problems
337
Note that, in this converted case, even with the use of function ode45(), the results are
still valid.
The implicit diﬀerential equation solver ode15i() can also be used to solve this
problem. An anonymous function can be written to describe the implicit equation. Let
x0 = [0.8,0.1,*]’ and xF
0 = [1,1,0]’, where * is used to denote free values. The following
statements can be used to ﬁnd compatible initial conditions. The original diﬀerential
algebraic equation can be solved in this way, and the same results can be obtained. It can be
seen that with the use of the method, a more straightforward solution process can be enjoyed.
>> f=@(t,x,xd)[xd(1)+0.2*x(1)-x(2)*x(3)-0.3*x(1)*x(2);
xd(2)-2*x(1)*x(2)+5*x(2)*x(3)+2*x(2)^2; x(1)+x(2)+x(3)-1];
x0=[0.8;0.1;2]; x0F=[1;1;0]; xd0=[1;1;1]; xd0F=[];
[x0,xd0]=decic(f,0,x0,x0F,xd0,xd0F) % compatible initial conditions
res=ode15i(f,[0,20],x0,xd0); plot(res.x,res.y) % solve equations
With the above solution commands, the compatible initial values are x(0)=[0.8, 0.1, 0.1]T
and x′(0) = [−0.126, 0.09, 1]T.
Example 7.24
Solve the implicit diﬀerential equations given in Example 7.20 using the
diﬀerential algebraic equation solver.
Solution
In Example 7.20, one converts the original equations to ﬁrst-order explicit
diﬀerential equations by inverting matrix A(x). In fact, an assumption has already been
made that the matrix A(t) is nonsingular. Although it happens that the assumption is correct
for this example, the numerical algorithm used is not quite reliable and convincing, strictly
speaking. For this kind of problem, the diﬀerential algebraic equation solvers can also be
used.
For the original equations, an anonymous function can be written for the diﬀerential
equation, and another anonymous function for the mass matrix. The diﬀerential algebraic
equation can then be solved using the following statements:
>> f=@(t,x)[1-x(1); -x(2)]; % describe ODE with an anonymous function
fM=@(t,x)[sin(x(1)),cos(x(2)); -cos(x(2)),sin(x(1))]; % mass matrix
options=odeset; options.Mass=fM; options.RelTol=1e-6;
[t,x]=ode45(f,[0,10],[0;0],options); plot(t,x) % solve and plot
and the results obtained are exactly the same as the ones shown in Figure 7.13.
7.4.4
Solutions of switching diﬀerential equations
The research on switching systems is an active research area in control system theory [7].
The so-called switching system is a system composed of several subsystems, and the system
is switched among the subsystems under certain conditions, known as switching laws. The
general form of the subsystems is expressed as
x′(t) = fi(t, x),
i = 1, · · · , m.
(7-4-3)
The overall system is switched among various subsystems under the given switching
laws. With the proper design of switching laws, the whole system fi(·) may be stabilized.

338
Scientiﬁc Computing with MATLAB®
Example 7.25
Assume that the subsystems are described by x′ = Aix, where
A1 =

0.1
−1
2
0.1

, A2 =

0.1
−2
1
0.1

.
It can be seen that the two subsystems are unstable. The switching laws are:
(i) When x1x2 < 0, i.e., the states are in the II and IV quadrants, switch to A1
(ii) When x1x2 ⩾0, i.e., the states are in the I and III quadrants, switch to A2.
Under the initial states x1(0) = x2(0) = 5, please solve the switching diﬀerential equation
with MATLAB.
Solution
Under the given switching laws, the switching system can be expressed by the
following MATLAB function
function dx=switch_sys(t,x)
if x(1)*x(2)<0, A=[0.1 -1; 2 0.1]; else, A=[0.1 -2; 1 0.1]; end
dx=A*x; % describe the switching ODE
The following commands can be used to solve the switching system, the time response
and phase plane plot are obtained as shown in Figure 7.16. It can be seen that, the overall
system composed of two unstable subsystems is stabilized under suitable switching laws.
>> [t,x]=ode45(@switch_sys,[0,30],[5;5]); % solve equations
plot(t,x), figure; plot(x(:,1),x(:,2))
0
5
10
15
20
25
30
−6
−4
−2
0
2
4
6
8
x1(t)
x2(t)
(a) time response
−6
−4
−2
0
2
4
6
−6
−4
−2
0
2
4
6
8
(b) phase plane trajectory
FIGURE 7.16: Time response and switching eﬀect of the system.
In fact, for simplicity, the switching system can alternatively be described with the
following anonymous function
>> f=@(t,x)(x(1)*x(2)<0)*[0.1 -1; 2 0.1]*x+...
(x(1)*x(2)>=0)*[0.1 -2; 1 0.1]*x;
7.4.5
Solutions to linear stochastic diﬀerential equations
Consider a ﬁrst-order linear diﬀerential equation described by
y′(t) + ay(t) = γ(t),
(7-4-4)
where a is a given constant. Assume that γ(t) is Gaussian white noise with zero mean and
a variance of σ2. It is known that the output signal y(t) is also Gaussian, with zero mean,

Diﬀerential Equation Problems
339
and a variance of σ2
y = σ2/(2a). Assume that the input signal is kept a constant ek within
a computation step-size, the original system can be discretized as
yk+1 = e−Δt/ayk + (1 −e−Δt/a)σek,
(7-4-5)
where Δt is a computation step-size, and ek is a pseudorandom number which satisﬁes
standard normal distribution N(0, 1). It can be seen that
E[y2
k+1] = e−2Δt/aE[y2
k] + 2σe−Δt/aE[ekyk] + σ2(1 −e−Δt/a)2E[e2
k].
(7-4-6)
If the input and output signals are stationary processes, then, E[y2
k+1]=E[y2
k]=σ2
y, and
since yk and ek are independent, then, E[ykek] = 0. Also, E[e2
k] = 1. It can be shown that
σ2
y = σ2(1 −e−Δt/a)2
(1 −e−2Δt/a)
= σ2(1 −e−Δt/a)
1 + e−Δt/a
.
(7-4-7)
If Δt/a →0, and the numerator and denominator in (7-4-7) are approximated by power
series, it can be seen that
σ2
y =
lim
Δt/a→0
Δt/a + o[(Δt/a)2]
2 + o(Δt/a)
σ2 = Δt
2a σ2.
(7-4-8)
It can be seen that the variance of the output signal depends on the computation step-
size Δt. Of course, the results are not correct. This means that, when the input signal is
random, conventional methods cannot be used in simulation.
Because of this, in some simulation software, other kinds of processes are used to replace
Gaussian white noise. For instance, in the ACSL language, the Ornstein–Uhlenbeck process
was used to approximate Gaussian white noise so that the input signal could maintain a
constant within a certain frequency range. However, the simulation result thus obtained is
not satisfactory either.
Assume that the linear state space representation
x′(t) = Ax(t) + B[d(t) + γ(t)], y(t) = Cx(t),
(7-4-9)
where A is an n × n matrix, B is an n × m matrix, C is an r × n matrix and d(t) is an
m × 1 deterministic input signal, γ(t) is an m × 1 Gaussian white noise vector, satisfying
E[γ(t)] = 0, E[γ(t)γT(t)] = Vσδ(t −τ).
(7-4-10)
Introducing a vector γc(t) = Bγ(t), it can be shown that γc(t) is also a Gaussian white
noise, satisfying
E[γc(t)] = 0, E[γc(t)γT
c (t)] = Vcδ(t −τ),
(7-4-11)
where vc = σBV BT is an m × m covariance matrix, then, (7-4-9) can be rewritten as
x′(t) = Ax(t) + Bd(t) + γc(t), y(t) = Cx(t).
(7-4-12)
The analytical solutions of the states can be written as
x(t) = e−Atx(t0) +
 t
t0
eA(t−τ)d(τ)Bdτ +
 t
t0
γc(t)dτ.
(7-4-13)
Assume that t0 = kΔt, t = (k + 1)Δt, where Δt is the computation step-size, and

340
Scientiﬁc Computing with MATLAB®
assume that within a computation step-size, the deterministic input d(t) is constant, that
is, if Δt ⩽t ⩽(k + 1)Δt, d(t) = d(kΔt). The discrete form of (7-4-13) can be written as
x[(k+1)Δt] = F x(kΔt)+Gd(kΔt)+γd(kΔt), y(kΔt) = Cx(kΔt),
(7-4-14)
where F = eAΔt, G =
 Δt
0
eA(Δt−τ)B dτ, and
γd(kΔt) =
 (k+1)Δt
kΔt
eA[(k+1)Δt−τ]γc(t)dτ =
 Δt
0
eAtγc[(k + 1)Δt −τ] dτ.
(7-4-15)
It can be seen that F and G matrices are exactly the same as those in deterministic
systems. When there exists a stochastic input, discretization of the system is slightly
diﬀerent. It can be shown that γd(t) is also a Gaussian white noise vector, satisfying
E[γd(kΔt)] = 0, E[γd(kΔt)γT
d (jΔt)] = V δkj,
(7-4-16)
where V =
 Δt
0
eAtVceATtdt. With Taylor series techniques
V =
 Δt
0
∞

k=0
Rk(0)
k!
tk dt =
∞

k=0
Vk,
(7-4-17)
where Rk(0) and Vk can recursively be obtained as
⎧
⎨
⎩
Rk(0) = ARk−1(0) + Rk−1(0)AT
Vk =
Δt
k + 1(AVk−1 + Vk−1AT),
(7-4-18)
with initial values R0(0) = R(0) = Vc, V0 = VcΔt. With the singular value decomposition
technique, matrix V can be written as V = UΓUT, where U is an orthogonal matrix, and Γ
is a diagonal matrix containing nonzero elements. Cholesky factorization can be performed
such that V = DDT, and γd(kΔt) = De(kΔt), where e(kΔt) is an n × 1 vector, and
e(kΔt) = [ek, ek+1, · · · , ek+n−1]T, such that the components ek satisfy a standard normal
distribution, that is, ek ∼N(0, 1). A recursive solution can be obtained
x[(k + 1)Δt] = F x(kΔt) + Gd(kΔt) + De(kΔt),
y(kΔt) = Cx(kΔt).
(7-4-19)
Based on the above algorithm, the discretization algorithm for continuous linear
stochastic diﬀerential equation can be written as
function [F,G,D,C]=sc2d(G,V,T)
G=ss(G); G=balreal(G); A=G.a; B=G.b; C=G.c; [F,G]=c2d(A,B,T);
V0=B*V*B’*T; Vd=V0; vmax=sum(sum(abs(Vd))); vv=vmax; v0=1; i=1;
while (v0<1e-10*vmax) % terminate condition
V1=T/(i+1)*(A*V0+V0*A’); v0=sum(abs(V1(:)));
Vd=Vd+V1; V0=V1; vv=[vv v0]; i=i+1;
end
[U,S,V0]=svd(Vd); V0=sqrt(diag(S)); Vd=diag(V0); D=U*Vd;
In simulation, a set of pseudorandom numbers can be generated, and the vector e(kΔt)

Diﬀerential Equation Problems
341
can be constructed. Then, the state vector x[(k + 1)Δt] at the next time instance can be
evaluated, and the current output signal y(kΔt) can be obtained
y′(t) = −1
ay(t) + 1
aγ0(t).
(7-4-20)
The discrete form of the output signal can be written as
yk+1 = eΔt/ayk + σ
*
1
2a

1 −e−2Δt/a
ek.
(7-4-21)
Example 7.26
Consider a transfer function model deﬁned as
G(s) =
s3 + 7s2 + 24s + 24
s4 + 10s3 + 35s2 + 50s + 24.
If a white noise signal is used to excite the system, solve the diﬀerential equation.
Solution We can select a sample time T = 0.001, the discretized model can be obtained
with the following MATLAB statements
>> G=tf([1,7,24,24],[1,10,35,50,24]); T=0.02; [F,G0,D,C]=sc2d(G,1,T)
The matrices in the discretized model can be found as
F =
⎡
⎢⎢⎣
0.9838
−0.0067
0.0132
0.0013
0.0067
0.9883
0.0702
0.0036
0.0132
−0.0702
0.8653
−0.0257
0.0013
−0.0036
−0.0257
0.9684
⎤
⎥⎥⎦,
G0 =
⎡
⎢⎢⎣
0.0182
−0.0036
−0.0076
−0.0007
⎤
⎥⎥⎦,
D =
⎡
⎢⎢⎣
−0.1303
0
0
0
0.0235
0
0
0
0.0594
0
0
0
0.0061
0
0
0
⎤
⎥⎥⎦,
and C = [0.9216, 0.1663, −0.4201, −0.0431]. From the discrete model, 30,000 simulation
points can be calculated with the following statements, and the time response of the system
is shown in Figure 7.17(a).
>> n_point=30000; r=randn(n_point+4,1); r=r-mean(r);
y=zeros(n_point,1); x=zeros(4,1); d0=0;
for i=1:n_point, x=F*x+G0*d0+D*r(i:i+3); y(i)=C*x; end
t=0:.02:(n_point-1)*0.02; subplot(121), plot(t,y)
v=covar(G,1); xx=linspace(-2.5,2.5,30); yy=hist(y,xx);
yy=yy/(30000*(xx(2)-xx(1))); yp=exp(-xx.^2/(2*v))/sqrt(2*pi*v);
subplot(122), bar(xx,yy), hold on; plot(xx,yp)
It can be seen that the output signal behaves in a disorderly way. For systems with
random signal, statistical analysis may be more informative. Histograms can be used to
approximate probability density functions, as shown in Figure 7.17(b). The result obtained
from simulation data agrees well with the theoretical results, and this means that the
simulation results are valid for stochastic diﬀerential equation.

342
Scientiﬁc Computing with MATLAB®
0
100
200
300
400
500
600
−3
−2
−1
0
1
2
3
(a) time response
−3
−2
−1
0
1
2
3
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
(b) probability density function
FIGURE 7.17: Response to stochastic inputs.
7.5
Solutions to Delay Diﬀerential Equations
The diﬀerential equations presented so far have the standard form of x′(t) = f(t, x(t)),
where all the signals in the equations happen at the same time t. If some of the signal
contains not only the values at current time t, but also have values in the past, the diﬀerential
equations are referred to as delay diﬀerential equations. In this section, numerical solutions
of various delay diﬀerential equations are presented, including general delay diﬀerential
equations, neutral-type delay diﬀerential equations and variable delay-time diﬀerential
equations.
7.5.1
Solutions of typical delay diﬀerential equations
The general form of the delay diﬀerential equations is given by
x′(t) = f(t, x(t), x(t −τ1), x(t −τ2), · · · , x(t −τn)),
(7-5-1)
where τi ⩾0 are the delay constants for state variables x(t).
A MATLAB function dde23()
[8] is provided to solve numerically delay diﬀerential
equations using implicit Runge–Kutta algorithms, with the syntax
sol = dde23(fun1,τ,fun2,[t0, tf],options)
where τ = [τ1, τ2, · · · , τn], fun1 is the function describing the delay diﬀerential equations
and fun2 is used to describe the history of the state vector for t ⩽t0, which can either
be a MATLAB function or a constant. The returned variable sol is a structure, with its
sol.x and sol.y ﬁelds describing the time vector t and states matrix x, respectively. The
returned variable x is diﬀerent from the x matrix from the ode45() function. It is arranged
on a row basis instead of a column.
The entrance of function fun1 is fun1 = @(t,x,Z), where Z is used to describe delayed
states, with the kth column, Z(:,k), storing the state vector x(t −τk).
Example 7.27
The delay diﬀerential equations are given by

Diﬀerential Equation Problems
343

x′(t) = 1 −3x(t) −y(t −1) −0.2x3(t −0.5) −x(t −0.5)
y′′(t) + 3y′(t) + 2y(t) = 4x(t),
where when t ⩽0, x(t) = y(t) = y′(t) = 0. Solve numerically the delay diﬀerential equations.
Solution
The values of x(t), y(t) at time instants t, t −1 and t −0.5 are involved in
the delay diﬀerential equations, thus, special functions are required for the equations. One
straightforward way is to introduce a set of state variables, such that x1(t) = x(t), x2(t) =
y(t), x3(t) = y′(t), then, the original equation can be transformed into the following ﬁrst-
order vector form explicit delay diﬀerential equations such that
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x′
1(t) = 1 −3x1(t) −x2(t −1) −0.2x3
1(t −0.5) −x1(t −0.5)
x′
2(t) = x3(t)
x′
3(t) = 4x1(t) −2x2(t) −3x3(t).
Two delay constants τ1 = 1 and τ2 = 0.5 can be deﬁned. Thus, from the ﬁrst state
equation, the delay constant to the ﬁrst state x1(t), both the delay constants τ1 and τ2 are
involved. However, for the second state x2(t), only the delay constant τ2 is used. The delay
diﬀerential equation can be expressed by
function dx=c7exdde(t,x,Z)
z1=Z(:,1); z2=Z(:,2);
dx=[1-3*x(1)-z1(2)-0.2*z2(1)^3-z2(1); x(3); 4*x(1)-2*x(2)-3*x(3)];
where zk is the state vector of x(t −τk), and can be extracted from the input argument
Z(:,k). Alternatively, the delay equation can be rewritten as
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x′
1(t) = 1 −3x1(t) −z2,1(t) −0.2z3
1,2(t) −z1,2(t)
x′
2(t) = x3(t)
x′
3(t) = 4x1(t) −2x2(t) −3x3(t),
where, zi,k = Z(i,k). Thus, the diﬀerential equation can be implemented with anonymous
function as
>> f=@(t,x,Z)[1-3*x(1)-Z(2,1)-0.2*Z(1,2)^3-Z(1,2);
x(3); 4*x(1)-2*x(2)-3*x(3)];
Then, the following statements can be used to ﬁnd the numerical solutions to the delay
diﬀerential equations
>> lags=[1 0.5]; tx=dde23(@c7exdde,lags,zeros(3,1),[0,10]);
plot(tx.x,tx.y(2,:)) % please note the ﬁelds x and y in solution tx
and the time response of y(t) can be obtained as shown in Figure 7.18 (a).
It should be noted that, if constant vector x0 is used to describe the history function
fun2, it means that for t ⩽t0, the history value of the states remain at x0. In the next
example, the delay equations with time-varying history functions will be demonstrated.
Example 7.28
Reconsider the delay diﬀerential equation in Example 7.27. If the history
functions of the state are given by x1(t) = e2.1t, x2(t) = sin t, x3(t) = cos t, for t ⩽0. Please
solve the delay equation solution again.
Solution Anonymous functions for describing the history of states at t ⩽0 are given below.

344
Scientiﬁc Computing with MATLAB®
0
1
2
3
4
5
6
7
8
9
10
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
(a) zero history states
0
1
2
3
4
5
6
7
8
9
10
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
(b) history state function
FIGURE 7.18: Numerical solutions to the delay diﬀerential equations.
The new solution of the delay diﬀerential equation can also be found, as shown in Figure
7.18 (b).
>> f=@(t,x,Z)[1-3*x(1)-Z(2,1)-0.2*Z(1,2)^3-Z(1,2);
x(3); 4*x(1)-2*x(2)-3*x(3)]; % describe the delay ODE
f2=@(t,x)[exp(2.1*t); sin(t); cos(t)];
% describe the history functions
lags=[1 0.5]; tx=dde23(f,lags,f2,[0,10]); plot(tx.x,tx.y(2,:))
7.5.2
Solutions of diﬀerential equations with variable delays
Function ddesd() provided in MATLAB can be used to solve diﬀerential equations with
variable delays. The time delay terms can be described with MATLAB functions, so that
the diﬀerential equations with variable delays can be described. Of course, the method can
be extended, such that function ddensd() can be used to solve neutral-type diﬀerential
equations. The syntax of function ddesd() is
sol = ddesd(fun1,fτ,fun2,[t0,tf],options)
where, fτ is the function handle of the delay function, and it can be described with M-
functions or anonymous functions.
Example 7.29
If the history of the states are zero, please solve the following delay
diﬀerential equations
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x′
1(t) = −2x2(t) −3x1(t −0.2| sin t|)
x′
2(t) = −0.05x1(t)x3(t) −2x2(t −0.8) + 2
x′
3(t) = 0.3x1(t)x2(t)x3(t) + cos(x1(t)x2(t)) + 2 sin 0.1t2.
Solution It is obvious that there exists variable time delays, i.e., the state signal at time
instance t −0.2| sin t|. Thus, function dde23() is not suitable in the solutions of these
equations. It can be seen that the ﬁrst delay term is at time t −0.2| sint|, the second is at
constant t−0.8, and history states for t ⩽0 are zeros. The following statements can be used
to solve the equation with variable delays, and the result is shown in Figure 7.19.
>> tau=@(t,x)[t-0.2*abs(sin(t)); t-0.8];
f=@(t,x,Z)[-2*x(2)-3*Z(1,1); -0.05*x(1)*x(3)-2*Z(2,2)+2;

Diﬀerential Equation Problems
345
0.3*x(1)*x(2)*x(3)+cos(x(1)*x(2))+2*sin(0.1*t^2)];
sol=ddesd(f,tau,zeros(3,1),[0,10]); plot(sol.x,sol.y)
Diﬀerent control parameters or algorithms can be used to validate the results. For
instance relative error tolerance is used, and it can be seen that exactly the same result
is obtained.
>> ff=odeset; ff.RelTol=1e-12; sol=ddesd(f,tau,zeros(3,1),[0,10],ff);
hold on; plot(sol.x,sol.y)
0
1
2
3
4
5
6
7
8
9
10
−2
−1
0
1
2
3
4
5
x3(t)
x2(t)
x1(t)
FIGURE 7.19: Numerical solutions of equations with variable delays.
It should be noted that, although the second delay time constant is 0.8, it should be
expressed as t −0.8, rather than 0.8, otherwise, wrong results will be returned. In fact, if it
is written as 0.8, then, x2(0.8) is used, rather than the correct x2(t −0.8).
Example 7.30
Consider the problem in the previous equations again. If the history of
states are given by x1(t) = sin(t + 1), x2(t) = cos t, x3(t) = e3t, for t ⩽0, please solve the
equations. Also, assume that the history of the states at t < 0 are zeros, while at t = 0, the
initial values of the states satisfy the history formula, please solve again the equations.
Solution
Is it was demonstrated earlier, the history of states can be expressed by an
anonymous function. Thus, the diﬀerential equations with nonzero history of states can
be solved with the following statements, and the result is shown in Figure 7.20 (a).
>> tau=@(t,x)[t-0.2*abs(sin(t)); t-0.8];
% the delay functions
f=@(t,x,Z)[-2*x(2)-3*Z(1,1); -0.05*x(1)*x(3)-2*Z(2,2)+2;
0.3*x(1)*x(2)*x(3)+cos(x(1)*x(2))+2*sin(0.1*t^2)];
f2=@(t,x)[sin(t+1); cos(t); exp(3*t)]; % the history functions
sol=ddesd(f,tau,f2,[0,10]); plot(sol.x,sol.y) % solve the DDE
If the history of states are zeros, and only at t = 0, the initial values are nonzero, the
history can be expressed again, and the results are obtained as shown in 7.20(b). It can be
seen that the two cases have large diﬀerences.
>> f2=@(t,x)[sin(t+1); cos(t); exp(3*t)]*(t==0);
sol=ddesd(f,tau,f2,[0,10]); plot(sol.x,sol.y)

346
Scientiﬁc Computing with MATLAB®
0
1
2
3
4
5
6
7
8
9
10
−1
0
1
2
3
4
5
6
x3(t)
x2(t)
x1(t)
(a) nonzero history
0
1
2
3
4
5
6
7
8
9
10
−2
−1
0
1
2
3
4
5
x3(t)
x2(t)
x1(t)
(b) zero history, nonzero initial states
FIGURE 7.20: Solutions of diﬀerential equations with nonzero initial values.
Example 7.31
Solve the slightly modiﬁed diﬀerential equations
⎧
⎪
⎪
⎨
⎪
⎪
⎩
x′
1(t) = −2x2(t) −3x1(t −0.2| sin t|)
x′
2(t) = −0.05x1(t)x3(t) −2x2(αt) + 2,
where α = 0.77
x′
3(t) = 0.3x1(t)x2(t)x3(t) + cos(x1(t)x2(t)) + 2 sin 0.1t2.
Solution It can be seen that in the second equation, there is a term x2(0.77t), it means
that the equation used the value at 0.77t of signal x2. It could be an extremely complicated
problem to solve, however, the user can just ﬁll 0.77*t in the time delay function, and the
diﬃcult tasks can be handled internally by MATLAB. The following statements can be used,
and the result can be obtained as shown in Figure 7.21.
>> tau=@(t,x)[t-0.2*abs(sin(t)); 0.77*t]; % describe the delay time
f=@(t,x,Z)[-2*x(2)-3*Z(1,1); -0.05*x(1)*x(3)-2*Z(2,2)+2;
0.3*x(1)*x(2)*x(3)+cos(x(1)*x(2))+2*sin(0.1*t^2)];
sol=ddesd(f,tau,zeros(3,1),[0,10]); plot(sol.x,sol.y) % solve DDE
0
1
2
3
4
5
6
7
8
9
10
−1
0
1
2
3
4
5
6
x1(t)
x2(t)
x3(t)
FIGURE 7.21: Numerical solutions of equations with variable delays.
Please note that in the examples, the delay signals xi(αt) and xi(t −β(t)) can be used,
however, the delay time should be less than t, i.e., α ⩽1 and β(t) ⩾0, meaning the signal
happened in the past, otherwise, the signal value xi(t) is used automatically in the DDE
solver, without any warning.

Diﬀerential Equation Problems
347
7.5.3
Solutions of neutral-type delay diﬀerential equations
The general form of neutral-type delay diﬀerential equation is
x′(t) = f(t, x(t), x(t −τ1), x′(t −τ2)),
(7-5-2)
where, the current and past values of the derivatives of the state variables appear simultane-
ously in the equation. Delay vectors τ1 = [τp1, τp2, · · · , τpm] and τ2 = [τq1, τq2, · · · , τqk] are
used to describe the delays in the states and derivatives of the states, respectively. Neutral-
type delay diﬀerential equations cannot be solved with function dde23(). It can only be
solved with ddensd() function (MATLAB 8.0 onwards), with the syntax
sol = ddensd(fun1,τ1,τ2,fun2,[t0,tf],options)
If the delay time are not constants, references to ddesd() function call, and change τ1
and τ2 to function handles. They can be described by M-functions or anonymous functions.
Example 7.32
Please solve the following neutral-type delay diﬀerential equation
x′(t) = A1x(t −0.15) + A2x′(t −0.5) + Bu(t),
where, the input signal is u(t) ≡1, and the matrices are given by
A1 =
⎡
⎣
−13
3
−3
106
−116
62
207
−207
113
⎤
⎦,
A2 =
⎡
⎣
0.02
0
0
0
0.03
0
0
0
0.04
⎤
⎦,
B =
⎡
⎣
0
1
2
⎤
⎦.
Solution Since the derivative terms at diﬀerent time, x′(t) and x′(t −0.5), appear in the
equation simultaneously, the function dde23() cannot be used. Function ddensd() can be
used directly in solving the problem. The delay constants for the states and its derivatives
are τ1 = 0.15 and τ2 = 0.5. The following anonymous can be used to describe neutral-type
delay diﬀerential equations, and then, the equations can be solved directly. The states are
obtained as shown in Figure 7.22.
>> A1=[-13,3,-3; 106,-116,62; 207,-207,113]; u=1;
A2=diag([0.02,0.03,0.04]); B=[0; 1; 2]; % input matrices
f=@(t,x,z1,z2)A1*z1+A2*z2+B*u; x0=zeros(3,1); % neutral-type DDE
sol=ddensd(f,0.15,0.5,x0,[0,15]); plot(sol.x,sol.y) % solve and plot
0
5
10
15
−1
0
1
2
3
4
5
x1(t)
x2(t)
x3(t)
FIGURE 7.22: Numerical solutions of neutral-type delay diﬀerential equations.

348
Scientiﬁc Computing with MATLAB®
Example 7.33
Consider again the non-neutral-type delay diﬀerential equation with
variable delays, studied in Example 7.31. Please solve it again with neutral-type DDE
solver.
Solution
The delay of the derivative signal can be expressed with an empty matrix [ ].
Thus, the following statements can be used to solve the original problem, and the results
obtained are exactly the same as the one shown in Figure 7.19.
>> f=@(t,x,Z,z)[-2*x(2)-3*Z(1,1); -0.05*x(1)*x(3)-2*Z(2,2)+2;
0.3*x(1)*x(2)*x(3)+cos(x(1)*x(2))+2*sin(0.1*t^2)];
sol=ddensd(f,tau,[],zeros(3,1),[0,10]); plot(sol.x,sol.y)
7.6
Solving Boundary Value Problems
In the previous sections, only initial value problems were considered, i.e., from the given
x0, the state vector x at other time instants is to be evaluated. In practical situations,
some states at time t = 0 are given while other states at t = tf are also given. This kind of
diﬀerential equation problem involving mixed initial and ﬁnal conditions is referred to as the
boundary value problems (BVPs). Boundary value problems cannot be solved directly from
ode45() type functions. In this section, we focus on how to solve boundary value problems
of ordinary diﬀerential equations.
The two-point boundary value problem (TPBVP) of a given diﬀerential equation involves
mixed initial and ﬁnal conditions. In this section, we illustrate the two-point boundary value
problem solution procedures using a second order diﬀerential equation as examples. General
boundary value problems are considered in the next subsection.
7.6.1
Shooting algorithm for linear equations
Consider a simple case. A linear diﬀerential equation is given by
y′′(t) + p(t)y′(t) + q(t)y(t) = f(t),
(7-6-1)
where, p(t), q(t) and f(t) are all known functions, the boundary conditions in (7-6-11) are
also in their simplest form
y(a) = γa,
y(b) = γb.
(7-6-2)
The basic idea of a shooting algorithm is to select an initial condition for y′(0), and
solve the initial value problem, then, use the error between the obtained ﬁnal value and the
given y(b), to adjust the initial condition y′(0) recursively, so that the error approaches zero
eventually.
For the boundary value problem of the linear diﬀerential equation, the main procedures
of the shooting algorithm are
(i) Solve the following initial value problem and ﬁnd y1(b)
y′′
1 (t) + p(t)y′
1(t) + q(t)y1(t) = 0,
y1(a) = 1, y′
1(a) = 0.
(7-6-3)
(ii) Solve the following initial value problem and ﬁnd y2(b)
y′′
2 (t) + p(t)y′
2(t) + q(t)y2(t) = 0,
y2(a) = 0, y′
2(a) = 1.
(7-6-4)

Diﬀerential Equation Problems
349
(iii) Solve the following equation to ﬁnd the numerical solution yp(b)
y′′
p(t) + p(t)y′
p(t) + q(t)yp(t) = f(t),
yp(a) = 0, y′
p(a) = 1.
(7-6-5)
(iv) If y2(b) ̸= 0, compute m, the appropriate initial value
m = γb −γay1(b) −yp(b)
y2(b)
.
(7-6-6)
(v) Solve the following initial value problem, and the solution of y(x) is the solution of
the boundary value problem
y′′(t) + p(t)y′(t) + q(t)y(t) = f(t),
y(a) = γa, y′(a) = m.
(7-6-7)
The corresponding explicit form of (7-6-3) and (7-6-4) are obtained
⎧
⎨
⎩
x′
1 = x2
x′
2 = −q(t)x1 −p(t)x2,
(7-6-8)
with initial vectors [1, 0]T and [0, 1]T, respectively.
The explicit form of (7-6-5) and (7-6-7) is
⎧
⎨
⎩
x′
1 = x2
x′
2 = −q(t)x1 −p(t)x2 + f(t),
(7-6-9)
with initial vectors [0, 0]T and [γa, m]T, respectively. The following MATLAB function can
be written as
function [t,y]=ln_shooting(p,q,f,tspan,x0f,varargin)
if isnumeric(p), p=@(t)p; end, if isnumeric(q), q=@(t)q; end
if isnumeric(f), f=@(t)f; end,
% for constants, establish function handles
t0=tspan(1); tfinal=tspan(2); ga=x0f(1);gb=x0f(2);
f1=@(t,x)[x(2); -q(t)*x(1)-p(t)*x(2)]; f2=@(t,x)f1(t,x)+[0; f(t)];
[t,y1]=ode45(f1,tspan,[1; 0],varargin{:});
[t,y2]=ode45(f1,tspan,[0; 1],varargin{:});
[t,yp]=ode45(f2,tspan,[0; 0],varargin{:});
m=(gb-ga*y1(end,1)-yp(end,1))/y2(end,1);
[t,y]=ode45(f2,tspan,[ga;m],varargin{:});
and the syntax of the function is
[t,y] = ln shooting(p,q,f,tspan,x0f,others)
where p, q and f are the function handles of the given functions of the equation. The
argument tspan = [a,b] is the interval of computation. The vector x0f = [γa,γb] is the
boundary value vector. Other arguments such as options in the ODE solver can also be
used in the function call.
Example 7.34
Solve the boundary value problem of the following equation
y′′(x) −

2 −1
x

y′(x) +

1 −1
x

y(x) = x2e−5x,
with y(1) = π, y(π) = 1.
Solution The analytical solution of the equation can be found directly, however, the result
is very complicated, and contains special function. The curve of signal y(t) is shown in
Figure 7.23.

350
Scientiﬁc Computing with MATLAB®
>> y=dsolve(’D2y-(2-1/x)*Dy+(1-1/x)*y=x^2*exp(-5*x)’,...
’y(1)=pi’,’y(pi)=1’,’x’) % analytical solution
ezplot(y,[1,pi])
% plot of the solution
Compare with the descriptions of the original equation, the functions p, q and f can be
found, and described by anonymous functions. The numerical solution of the boundary value
problem can be obtained, also as shown in Figure 7.23, almost identical to the one expressed
by the analytical solution.
>> p=@(x)-(2-1./x); q=@(x)1-1./x; f=@(x)x.^2.*exp(-5*x);
[t,y]=ln_shooting(p,q,f,[1,pi],[pi; 1]); line(t,y(:,1))
1
1.2
1.4
1.6
1.8
2
2.2
2.4
2.6
2.8
3
1
1.5
2
2.5
3
3.5
4
x1(t) and y(t)
FIGURE 7.23: Numerical solutions of linear boundary value problem.
7.6.2
Boundary value problems of nonlinear equations
The two-point boundary value problem for second-order diﬀerential equation can be
mathematically described as follows:
y′′(x) = F(x, y, y′).
(7-6-10)
In the interested interval [a, b], the following two boundary conditions are known:
αay(a) + βay′(a) = ηa,
αby(b) + βby′(b) = ηb.
(7-6-11)
In some simple cases, the boundary conditions are speciﬁed as
y(a) = γa, y(b) = γb.
(7-6-12)
Assume that the original two-point boundary value problem can be converted to an
initial value problem as follows:
y′′ = F(x, y, y′),
y(a) = γa, y′(a) = m.
(7-6-13)
That is, the two-point boundary value problem is converted to solving y(b|m) = γb,
which means to evaluate the value of y(b) based on the information of m. Using the following
Newton’s iterative algorithm the value of m can be obtained:
mi+1 = mi −
y(b|mi) −γb
(∂y/∂m)(b|mi) = mi −v1(b) −γb
v3(b)
,
(7-6-14)

Diﬀerential Equation Problems
351
where v1 = y(x|mi), v2 = y′(x|mi), v3 = (∂y/∂m)(x|mi), v4 = (∂y′/∂m)(x|mi), and clearly,
the original boundary value problem can be converted to a series of initial value problems
that can be solved using the numerical algorithms given in the previous sections.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎩
v′
1 = v2,
v1(a) = γa
v′
2 = F(x, v1, v2),
v2(a) = m
v′
3 = v4,
v3(a) = 0
v′
4 = ∂F
∂y (x, v1, v2)v3 + ∂F
∂y′ (x, v1, v2)v4,
v4(a) = 1,
(7-6-15)
where in order to solve explicitly ∂F/∂y, ∂F/∂y′, an auxiliary value of m can be introduced
such that the initial value problems in (7-6-15) can be solved. The results can be substituted
into (7-6-14) for one step. Then, in turn the results can be substituted into (7-6-15). When
the values of m computed in the two algorithms meet the pre-speciﬁed error tolerance, the
iteration stops and the required m is found. In this way, from (7-6-13), the original boundary
value problem can be considered as solved. The above algorithm can be implemented in the
following MATLAB function
function [t,y]=nlbound(funcn,funcv,tspan,x0f,tol,varargin)
t0=tspan(1);tfinal=tspan(2); ya=x0f(1); yb=x0f(2); m=1; m0=0;
while (norm(m-m0)>tol), m0=m;
[t,v]=ode45(funcv,tspan,[ya;m;0;1],varargin{:});
m=m0-(v(end,1)-yb)/(v(end,3));
end
[t,y]=ode45(funcn,tspan,[ya;m],varargin{:});
where a MATLAB user deﬁned function funcv() must be prepared to describe the initial
value problems deﬁned in (7-6-15). An example is given below to illustrate the coded
algorithm.
Example 7.35
Solve the following boundary value problem for the nonlinear diﬀerential
equation
y′′ = F(x, y, y′) = 2yy′, y(0) = −1, y(π/2) = 1.
Solution
The partial derivatives can easily be found as ∂F/∂y = 2y′, ∂F/∂y′ = 2y.
Substituting them back to the fourth equation in (7-6-15), it can immediately be found that
v′
4 = 2v2v3 + 2v1v4. Thus, the related functions can be expressed by anonymous functions.
The following statements can be used to solve this two-point boundary value problem. The
time histories of the states are shown in Figure 7.24. It can be seen that the solution x1(t)
satisﬁes the two given boundary conditions.
>> f1=@(t,v)[v(2); 2*v(1)*v(2); v(4); 2*v(2)*v(3)+2*v(1)*v(4)];
f2=@(t,x)[x(2); 2*x(1)*x(2)]; % describe the two equations
[t,y]=nlbound(f2,f1,[0,pi/2],[-1,1],1e-8); plot(t,y); xlim([0,pi/2]);
It is known that the analytical solution of the two-point boundary value problem is y(x) =
tan(x −π/4). The following statements can be used to check the accuracy of the above
numerical results.
>> y0=tan(t-pi/4); norm(y(:,1)-y0) % compare with analytical solution
The norm of the error vector is 1.6629×10−5, which is satisfactory.

352
Scientiﬁc Computing with MATLAB®
0
0.5
1
1.5
−1
−0.5
0
0.5
1
1.5
2
2.5
x1(t)
x2(t)
FIGURE 7.24: Solutions to a simple two-point boundary value problem.
7.6.3
Solutions to general boundary value problems
The two-point boundary value problems are quite restricted, since they can only be
used to deal with second-order diﬀerential equations with known parameters. Assume the
diﬀerential equation to be analyzed is given by
y′ = f(t, y, θ),
(7-6-16)
where, the time t ∈[a, b], y is the state vector and θ is the vector of unknown parameters.
The general boundary conditions are given by
φ[y(a), y(b), θ] = 0.
(7-6-17)
To convert the original problems into initial value problems, several algebraic equations
should be solved. If the numbers of unknowns and equations are the same, numerical
algebraic equation solution algorithms can be used. The boundary value problems to be
solved here are more general, since the equations and undetermined constants can be
handled at the same time.
The bvp5c() function provided in MATLAB can be used to solve the above general
boundary value problems [9]. The procedures of problem solution are summarized below:
(i)
Parameter initialization
The bvpinit() function can be used to initialize
the BVP. The equation and the undetermined constants can be described together in
this function such that sinit = bvpinit(v,x0,θ0), where v contains the sample times
generated by v = linspace(a,b,M). M should be set to small integers for computation
speed, e.g., M = 5. Apart from the vector v, the initial search points of the state vector x0
and undetermined constants θ0 should also be provided.
(ii) MATLAB descriptions to ODEs and BVPs
The description of diﬀerential
equations is exactly the same as the one in the initial value problems illustrated in the
previous sections. The description of boundary values in (7-6-17) will be demonstrated
through examples in the following.
(iii) Solving the BVPs
The bvp5c() function can be used in solving boundary value
problems
sol = bvp5c(fun1,fun2,sinit,options,p1,p2,· · · )
where fun1 and fun2 are respectively the diﬀerential equations and the boundary values.
The returned argument sol is a structured variable, whose ﬁelds sol.x and sol.y store

Diﬀerential Equation Problems
353
respectively the t vector and the state matrix. The ﬁeld sol.parameters stores the
undetermined constant vector θ.
Example 7.36 Solve again the boundary value problem in Example 7.35, rewritten below,
with the bvp5c() solver
y′′ = F(x, y, y′) = 2yy′, y(0) = −1, y(π/2) = 1.
Solution Let x1 = y, x2 = y′. The ﬁrst-order vector form explicit ODE can be written as
x′
1 = x2, x′
2 = 2x1x2. Anonymous functions can be used to describe the diﬀerential equations
and the boundary values.
For the boundary conditions, suppose the left and right bounds can be denoted by a and
b, y(0) = −1 condition can be denoted as x1(a) + 1 = 0, or denoted as xa(1) + 1 = 0. The
condition y(π/2) = 1 can be expressed by x1(b) −1 = 0, or xb(1) −1 = 0. Therefore, the
boundary conditions can be written as follows
>> f2=@(xa,xb)[xa(1)+1; xb(1)-1]; % describe the boundary conditions
The bvp5c() function can be used to solve directly the boundary value problem, and the
result is shown in Figure 7.25 (a). It can be seen that the curve obtained is not smooth, this
is because the number of points selected in bvpinit() function is too small. If the number
of points is changed from 5 to 20, the curve will be smooth, and the result is exactly the
same as the one in the previous example.
>> f1=@(t,x)[x(2); 2*x(1)*x(2)]; f2=@(xa,xb)[xa(1)+1; xb(1)-1];
sinit=bvpinit(linspace(0,pi/2,5),rand(2,1)); % parameter initialization
sol=bvp5c(f1,f2,sinit); plot(sol.x,sol.y)
% solve and plot
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
−1
−0.5
0
0.5
1
1.5
2
2.5
y′(t)
y(t)
(a) y(0) = −1, y(π/2) = 1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
y′(t)
y(t)
(b) y′(π/2) = 1, y(π/2) −y(0) = 1
FIGURE 7.25: Solutions of boundary value problem.
The bvp5c() function can also be used to solve more complicated boundary value
problems. For instance, if the boundary value problem is changed to y′(π/2) = 1, y(π/2) −
y(0) = 1, it can be denoted as x2(b) −1 = 0, x1(b) −x1(a) −1 = 0, and the function fun2
should be changed as follows
>> f2=@(xa,xb)[xb(2)-1; xb(1)-xa(1)-1];
% boundary conditions
sol=bvp5c(f1,f2,sinit); plot(sol.x,sol.y) % solve and plot
and the results are shown in Figure 7.25 (b).

354
Scientiﬁc Computing with MATLAB®
Example 7.37
Consider the problem in the previous example. A random initial value
y′(0) can be selected, from which the diﬀerential equation can be solved to ﬁnd ˆy(tf). An
objective function can be designed to minimize |y(tf) −ˆy(tf)|, and ﬁnd a suitable initial
value y′(0). In this case, the boundary value problem can be converted into an optimization
problem. Solve the problem again using this method.
Solution The objective function can be written as follows
function y=c7meqopt(x,f,tspan,x0,ypf)
x0vec=[x0; x]; [t,y]=ode45(f,tspan,x0vec); y=abs(ypf-y(end,2));
With such a function, optimization can be performed to ﬁnd the exact initial value x2(0),
as the decision variable. In this case, the exact x2(0) can be found x2(0) = 1.7585 and
the diﬀerential problem can be solved again under such an initial condition. The obtained
solution is exactly the same as the one obtained in the previous example.
>> x0=-1; ypf=1; tspan=[0,pi/2]; f1=@(t,x)[x(2); 2*x(1)*x(2)];
x=fminunc(@c7meqopt,rand(1),’’,f1,tspan,x0,ypf) % perform optimization
x0a=[x0; x]; [t,y]=ode45(f1,tspan,x0a); plot(t,y) % solve and plot
Example 7.38
Given the ordinary diﬀerential equation
⎧
⎨
⎩
x′(t) = 4x(t) −αx(t)y(t)
y′(t) = −2y(t) + βx(t)y(t),
with initial and ﬁnal conditions x(0) = 2, y(0) = 1, x(3) = 4, y(3) = 2, ﬁnd the parameters
α and β and solve the boundary value problem.
Solution Choosing the state variables x1 = x, x2 = y, the original problem can be converted
into an explicit diﬀerential equation with respect to x. Let v1 = α and v2 = β. The ODE
and boundary value problem can then be expressed by the following anonymous functions
>> f=@(t,x,v)[4*x(1)+v(1)*x(1)*x(2); -2*x(2)+v(2)*x(1)*x(2)];
g=@(ya,yb,v)[ya(1)-2; ya(2)-1; yb(1)-4; yb(2)-2]; % boundaries
and it can be seen that the description to boundary value problem is quite straightforward
in MATLAB. The bvpinit() function should be called to initialize the time array. The
initial states and parameters α and β should also be speciﬁed. Since there are two states
and two undetermined constants, they both can be set to rand(2,1). With these initial
parameters, the function bvp5c() can be called to solve the boundary value problem as well
as the undetermined constants α and β.
>> x1=[1;1]; x2=[-1;1]; sinit=bvpinit(linspace(0,3,20),x1,x2);
options=bvpset; options.RelTol=1e-8; S=bvp5c(f,g,sinit,options);
S.parameters % show undermined parameters
subplot(121), plot(S.x,S.y); subplot(122), plot(S.y(1,:),S.y(2,:));
The results are shown in Figure 7.26. Meanwhile, it is found that α = −2.3721, β = 0.8934.
From the simulation results, it is found that the boundary conditions are satisﬁed, which
veriﬁes the obtained results. It should be noted that if the initial vectors x1 and x2 are not
properly chosen, the Jacobian matrix generated might be singular. In this case, the initial
vectors should be chosen again diﬀerently so that convergent results can be obtained.

Diﬀerential Equation Problems
355
0
0.5
1
1.5
2
2.5
3
0.5
1
1.5
2
2.5
3
3.5
4
4.5
x1(t)
x2(t)
(a) time responses of the states
1
1.5
2
2.5
3
3.5
4
4.5
0.8
1
1.2
1.4
1.6
1.8
2
2.2
2.4
2.6
2.8
(b) phase plane trajectory
FIGURE 7.26: Solution to the boundary value problem.
7.7
Introduction to Partial Diﬀerential Equations
Apart from ordinary diﬀerential equations, partial diﬀerential equations (PDEs) are also
very useful in science and engineering. In MATLAB many partial diﬀerential equations can
be solved by the Partial Diﬀerential Equation Toolbox. In this section, a general introduction
to partial diﬀerential equations is given and some particular types of the two-dimensional
partial diﬀerential equations solvable in the easy-to-use GUI of the PDE Toolbox are
illustrated.
A PDE contains 4 elements: the PDE, the initial conditions (ICs), the boundary
conditions (BCs) and the domain of interest. In the following, we will introduce the solution
procedures for 1D PDEs ﬁrst and then 2D PDEs.
7.7.1
Solving a set of one-dimensional partial diﬀerential equations
A partial diﬀerential equation solver pdepe() provided in MATLAB PDE Toolbox can
be used to solve numerically the general 1D partial diﬀerential equations of the following
form
c

x, t, u, ∂u
∂x
 ∂u
∂t = x−m ∂
∂x

xmf

x, t, u, ∂u
∂x

+ s

x, t, u, ∂u
∂x

,
(7-7-1)
where the partial diﬀerential equation to be solved should be modeled in the following
function [c,f,s] = pdefun(x,t,u,ux), where pdefun is the function name, the functions
c, f and s can be calculated from the given arguments.
Boundary conditions can be described by the following function
p(x, t, u) + q(x, t, u). ∗f

x, t, u, ∂u
∂x

= 0,
(7-7-2)
where .* operation is the MATLAB element-by-element dot product. These boundary
conditions can be described by the following MATLAB function
[pa,qa,pb,qb] = pdebc(x,t,u,ux)
Apart from the above two MATLAB functions, the initial conditions should also be

356
Scientiﬁc Computing with MATLAB®
described. The initial conditions are usually deﬁned as u(x, t0) = u0. Thus, a simple
MATLAB function can be prepared by using u0 = pdeic(x).
One can also select the variable vectors x and t. With the use of the above functions,
the pdepe() function can be used to solve the PDE. The syntax of the function is
sol = pdepe(m,@pdefun,@pdeic,@pdebc,x,t).
Example 7.39
Solve the following partial diﬀerential equations:
⎧
⎪
⎪
⎨
⎪
⎪
⎩
∂u1
∂t = 0.024∂2u1
∂x2 −F(u1 −u2)
∂u2
∂t = 0.17∂2u2
∂x2 + F(u1 −u2),
where F(x) = e5.73x−e−11.46x, and the initial conditions are given by u1(x, 0) = 1, u2(x, 1) =
0 and the boundary conditions are
∂u1
∂x (0, t) = 0, u2(0, t) = 0, u1(1, t) = 1, ∂u2
∂x (1, t) = 0.
Solution
Comparing the given diﬀerential equation with the standard form described in
(7-7-1), we can rewrite the equation as

1
1

. ∗∂
∂t

u1
u2

= ∂
∂x

0.024∂u1/∂x
0.17∂u2/∂x

+

−F(u1 −u2)
F(u1 −u2)

,
with m = 0, and
c =
1
1

,
f =
0.024∂u1/∂x
0.17∂u2/∂x

,
s =
−F(u1 −u2)
F(u1 −u2)

.
Thus, the M-function describing the equation is written as
function [c,f,s]=c7mpde(x,t,u,du)
c=[1; 1]; y=u(1)-u(2); F=exp(5.73*y)-exp(-11.46*y); s=[-F; F];
f=[0.024*du(1); 0.17*du(2)]; % describe the three functions in PDE
Referring to the boundary conditions in (7-7-2), the following boundary conditions can
be constructed such that
left bounds

0
u2

+

1
0

. ∗f =

0
0

,
right bounds

u1 −1
0

+

0
1

. ∗f =

0
0

,
and the MATLAB function for the boundary conditions can be prepared as
function [pa,qa,pb,qb]=c7mpbc(xa,ua,xb,ub,t)
pa=[0; ua(2)]; qa=[1;0]; pb=[ub(1)-1; 0]; qb=[0;1]; % the boundaries
The initial conditions for this partial diﬀerential equation can be given by an anonymous
function.
With these three functions, if the vectors x and t are used, the following statements
solve the given diﬀerential equation where the solutions u1 and u2 are visualized in
Figures 7.27 (a) and (b), respectively.
>> x=0:.05:1; t=0:0.05:2; m=0; u0=@(x)[1; 0];
S=pdepe(m,@c7mpde,u0,@c7mpbc,x,t); subplot(121), surf(x,t,S(:,:,1))
subplot(122), surf(x,t,S(:,:,2))

Diﬀerential Equation Problems
357
0
0.2
0.4
0.6
0.8
1
0
0.5
1
1.5
2
0
0.2
0.4
0.6
0.8
1
t
x
(a) u1(t, x)
0
0.2
0.4
0.6
0.8
1
0
0.5
1
1.5
2
0
0.2
0.4
0.6
0.8
t
x
(b) u2(t, x)
FIGURE 7.27: Solution surfaces in partial diﬀerential equations.
7.7.2
Mathematical description to two-dimensional PDEs
The PDE Toolbox can be used to solve 2D partial diﬀerential equations via a very handy
graphical user interface pdetool. Some of the 2D partial diﬀerential equations solvable via
the PDE Toolbox are introduced and examples are given to demonstrate the use of the
PDE GUI.
I. Elliptic partial diﬀerential equations
The general form of an elliptic partial diﬀerential equation is given by
−div(c∇u) + au = f(x, t),
(7-7-3)
where u=u(x1, x2, · · · , xn, t)=u(x, t), and ∇u is the gradient of u deﬁned as
∇u =
 ∂
∂x1
, ∂
∂x2
, · · · ,
∂
∂xn

u.
(7-7-4)
The divergence div(v) is deﬁned as
div(v) =
 ∂
∂x1
+
∂
∂x2
+ · · · +
∂
∂xn

v.
(7-7-5)
Thus, div(c∇u) can further be deﬁned as
div(c∇u) =
 ∂
∂x1

c ∂u
∂x1

+
∂
∂x2

c ∂u
∂x2

+ · · · +
∂
∂xn

c ∂u
∂xn

.
(7-7-6)
If c is a constant, the above equation can be simpliﬁed as
div(c∇u) = c
 ∂2
∂x2
1
+ ∂2
∂x2
2
+ · · · + ∂2
∂x2n

u = cΔu,
(7-7-7)
where Δ is also referred to as the Laplacian operator. Thus, the elliptic PDE can further
be simpliﬁed as
−c
 ∂2
∂x2
1
+ ∂2
∂x2
2
+ · · · + ∂2
∂x2n

u + au = f(x, t).
(7-7-8)

358
Scientiﬁc Computing with MATLAB®
II. Parabolic partial diﬀerential equations
The general form of a parabolic partial diﬀerential equation is given by
d∂u
∂t −div(c∇u) + au = f(x, t).
(7-7-9)
If c is a constant, the above equation can be simpliﬁed as
d∂u
∂t −c
∂2u
∂x2
1
+ ∂2u
∂x2
2
+ · · · + ∂2u
∂x2n

+ au = f(x, t).
(7-7-10)
III. Hyperbolic partial diﬀerential equations
The general form of a hyperbolic partial diﬀerential equation is given by
d∂2u
∂t2 −div(c∇u) + au = f(x, t).
(7-7-11)
If c is a constant, the above equation can be simpliﬁed as
d∂2u
∂t2 −c
∂2u
∂x2
1
+ ∂2u
∂x2
2
+ · · · + ∂2u
∂x2n

+ au = f(x, t).
(7-7-12)
It can be seen from the above three types of partial diﬀerential equations that the most
signiﬁcant diﬀerence is the order of the derivative of the function u with respect to t. If the
derivative term is zero, the equation is elliptic. The ﬁrst- and second-order derivative terms
correspond to parabolic and hyperbolic equations, respectively.
Finite element-based algorithms are implemented in the PDE Toolbox. In the elliptic
equations, the variables c, a, d and f can all be deﬁned as any given functions, while in the
other two types of PDEs, they must be constants.
IV. Eigenvalue problem
An eigenvalue partial diﬀerential equation problem is deﬁned as
−div(c∇u) + au = λdu.
(7-7-13)
If c is a constant, the above equation can be simpliﬁed as
−c
∂2u
∂x2
1
+ ∂2u
∂x2
2
+ · · · + ∂2u
∂x2n

+ au = λdu.
(7-7-14)
7.7.3
The GUI for the PDE Toolbox — an introduction
I. PDE Toolbox — an overview
A GUI for solving partial diﬀerential equations is provided in the PDE Toolbox. The
interface can be used in solving 2D partial diﬀerential equations. The solution regions
of interest can be drawn freely by the GUI tools using combinations of circles, ellipsis,
rectangles and polygons. Moreover, the regions of interest can be organized by set operations
such as union, diﬀerence and intersect, etc. Two-dimensional partial diﬀerential equations
can easily be solved using the GUI.

Diﬀerential Equation Problems
359
FIGURE 7.28: Graphical user interface of the PDE solver.
Type pdetool in the MATLAB prompt, and a user interface shown in Figure 7.28 will
be displayed. This interface can be used in solving the given partial diﬀerential equation.
The PDE user interface has the following functions:
(i)
Menu system
A complete and comprehensive menu system is provided in the
interface, which makes most of the functions callable directly from the menu items and
toolbar buttons.
(ii)
Toolbar
The detailed explanation to the buttons on the toolbar is shown in
Figure 7.29. The toolbar can be used to deﬁne the solution regions of interest, to set
parameters in the partial diﬀerential equation, to solve the equation and to visualize the
results. The right-hand side of the interface provides a list box containing diﬀerent types of
solvable partial diﬀerential equations.
(iii) Set formula
Set formula edit box can be used to deﬁne set operations, such as
union, intersect and diﬀerence operations.
(iv) Solution regions
The user can draw solution regions, and then, solve the two-
dimensional equations within the solution region. 3D display can also be obtained.
FIGURE 7.29: Toolbar in the PDE solver GUI.

360
Scientiﬁc Computing with MATLAB®
II. Drawing and deﬁning the PDE solution region
An illustrative example is introduced to deﬁne the solution region in the GUI. One can
ﬁrst select the ellipses and rectangle buttons and draw the regions, deﬁned as sets, as shown
in Figure 7.30 (a). Then, the solution region can be deﬁned using the set operation edit box
such that the contents are changed to (R1+E1+E3)-E2, which means removal of the set E2
from the union of the rectangle R1, the ellipses E1, and E3. Therefore, the button labeled
as ∂Ω can be used to deﬁne the solution region. The menu item Boundary →Remove All
Subdomain Borders can be used to remove the curves within the adjacent regions. Thus, the
solution region can then be obtained as shown in Figure 7.30 (b).
(a) region deﬁnition
(b) actual solution region
FIGURE 7.30: Solution region for partial diﬀerential equations.
From the given solution region, if one clicks the Δ button, triangular mesh can be
generated within the solution region, as shown in Figure 7.31 (a). If one is not satisﬁed with
the mesh, the reﬁne mesh button can be used to add more grids to the region and the ﬁnal
grids can be shown in Figure 7.31 (b). It is worth mentioning that the ﬁner the mesh, the
more accurate solutions can be obtained. However, the cost is that the longer computation
time is required.
−1.5
−1
−0.5
0
0.5
1
1.5
−1
−0.5
0
0.5
1
(a) default mesh speciﬁcations
−1.5
−1
−0.5
0
0.5
1
1.5
−1
−0.5
0
0.5
1
(b) reﬁned mesh
FIGURE 7.31: Generation of the grids within the solution region.

Diﬀerential Equation Problems
361
III. Boundary conditions for 2D PDEs
In the interface, the boundary conditions can be represented by the ∂Ω button. Generally
speaking, the Dirichlet and Neumann types of boundary conditions are supported. These
two types of boundary conditions are discussed below:
(i) Dirichlet conditions Dirichlet boundary conditions are described as follows:
h

x, t, u, ∂u
∂x

u
""""
∂Ω
= r

x, t, u, ∂u
∂x

,
(7-7-15)
where ∂Ω denotes the boundary of the solution region. Assume that certain conditions must
be satisﬁed on the solution boundary, one can simply specify the functions r and h which
can be either constants or functions of x and u, ∂u/∂x. For convenience, one may assume
that h = 1. In the following example, how to specify the Dirichlet boundary conditions in
MATLAB will be illustrated.
(ii) Neumann conditions
The extended form is given by
 ∂
∂n(c∇u) + qu
""""
∂Ω
= g,
(7-7-16)
where ∂u/∂n is the partial derivative of vector x in the normal direction.
If Boundary →Specify Boundary Conditions menu item is selected, a dialog box as in
Figure 7.32 will show up. The boundary conditions can be speciﬁed through the dialog box.
If ones wants to assign zero values on all the boundaries, ﬁll 0 in the r edit box.
FIGURE 7.32: Boundary condition setting dialog box.
IV. PDE solution examples via PDE Toolbox
The solution region, boundary conditions can be speciﬁed using the methods discussed
earlier. If the partial diﬀerential equations can be speciﬁed, the = button in the toolbar can
be used to solve the partial diﬀerential equations. An example will be given below to show
the solution procedures.
Example 7.40
Solve the following hyperbolic partial diﬀerential equation
∂2u
∂t2 −∂2u
∂x2 −∂2u
∂y2 + 2u = 10.
Solution From the given partial diﬀerential equation, one can immediately ﬁnd that c =
1, a = 2, f = 10 and d = 1. Click the PDE button in the toolbar. A dialog box as in

362
Scientiﬁc Computing with MATLAB®
FIGURE 7.33: PDE parameters setting dialog box.
Figure 7.33 shows. From the radio button on the left, select the Hyperbolic option, and the
parameters can be entered in the dialog box.
If the numerical solutions are required, click the = button in the toolbar and the solutions
can immediately be obtained as shown in Figure 7.34 (a), where pseudocolors are used to
denote the values of u(x, y). It should be noted that only the solution u(x, y) at t = 0 is
displayed. Later on, it will be shown how the solutions at other t values can be visualized.
The boundary value conditions can be modiﬁed. For instance, the Dirichlet conditions
can still be used, and assume r = 5 on the boundaries. Use the dialog box to ﬁll 5 into the
r edit box. Solve the partial diﬀerential equations again, and the obtained results are shown
in Figure 7.34 (b).
(a) solutions
(b) solutions after boundary changes
FIGURE 7.34: Solutions to the partial diﬀerential equations.
Numerical results can be visualized in many diﬀerent ways. If the 3D button is clicked,
a dialog box shown in Figure 7.35 appears. One can select the Contour icon to show
the contours of the solutions. If the Arrows option is selected, attraction curves will be
displayed. When the two options are selected simultaneously, the results are visualized in
Figure 7.36 (a).
It should be noted that, in the dialog box shown in Figure 7.35, list boxes are provided for
each item of the Property column. For instance, the default for the ﬁrst item is u, indicating
all the analyses are made for the function u(·). The results displayed are the function of

Diﬀerential Equation Problems
363
FIGURE 7.35: Dialog box for results display format settings.
u(x, y). If other functions are to be visualized, the button ▼to the right should be clicked.
Another list box is then shown and other functions can be selected for visualization.
In the menu item Height (3d-plot), a graphics window is opened and a three-dimensional
mesh grid plot is generated, as shown in Figure 7.36 (b).
(a) contour representation
−1.5
−1
−0.5
0
0.5
1
1.5
−1
−0.5
0
0.5
1
0
0.5
1
Time=10   Height: u
(b) three-dimensional representations
FIGURE 7.36: Diﬀerent representations of the solutions.
V. Animation of the time varying solutions
The default time vector is deﬁned as t=0:10. The results shown in Figure 7.34 are only
at the ﬁnal time t = 10. From the hyperbolic equations, it can be seen that the solutions
should also be a function of time t. Thus, animation should be used to dynamically display
the solutions. Let us still use the PDE in Example 7.40 to illustrate the animation process.
Use the menu item Solve →Parameters and a dialog box is displayed so as to specify
the time vector. For instance, if in the edit box, one speciﬁes the vector 0:0.1:4, the
solutions will then be made over the new time vector instead. In the dialog box shown
in Figure 7.35, the Animation check box can be selected. The Options button can be
used to adjust the speed in animations (the default speed is 6 frames per second). The
animation can then be obtained directly. The Plot →Export Movie menu item can be

364
Scientiﬁc Computing with MATLAB®
used to export the animation variable into the MATLAB workspace. For instance, the
animation results can be saved to MATLAB variable M, and with the use of the movie(M)
function, animation can be played in a MATLAB graphics window. Furthermore, using the
movie2avi(M,’myavi.avi’) command, the animation can be saved in the myavi.avi ﬁle
for later play.
VI. Solving PDEs when parameters are not constants
In the partial diﬀerential equations discussed earlier, c, a, d, f coeﬃcients are all assumed
constant. In practical applications, however, c, a, d, f may be functions. For elliptic PDEs,
the solvers currently allow the use of function to describe the above-mentioned coeﬃcients.
The variables x and y are used to represent x1, x2 or x, y, while the variables ux and uy are
for ∂u/∂x and ∂u/∂y, respectively. They can be described by any nonlinear functions. The
following example illustrates the solution process when c, a, d, f are not constants.
Example 7.41
Assume that the partial diﬀerential equations are described as
−div

1
1 + |∇u|2 ∇u

+ (x2 + y2)u = e−x2−y2,
with boundaries at 0. Solve numerically the partial diﬀerential equations.
Solution It can be found that the original partial diﬀerential equation is elliptic, with
c =
1
(
(1 +
∂u
∂x
2
+
∂u
∂y
2 ,
a = x2 + y2,
f = e−x2−y2,
and the boundary conditions are 0. One may still use the pdetool interface shown in
Figure 7.33. In the partial diﬀerential equation type dialog box, select the Elliptic item,
and in the c edit box, specify 1./sqrt(1+ux.^2+uy.^2). In edit boxes of a and f, specify
respectively x.^2+y.^2 and exp(-x.^2-y.^2). Then, open the Solve →Parameters dialog
box and select the Use nonlinear solver property (it should be noted that this option is only
applicable to elliptic equations), and the equal sign icon can be clicked to solve the equation.
The results obtained are shown in Figures 7.37 (a) and (b).
(a) contour representation
−1.5
−1
−0.5
0
0.5
1
1.5
−1
−0.5
0
0.5
1
4.5
5
5.5
 
   Color: u  Height: u
 
4.7
4.75
4.8
4.85
4.9
4.95
5
(b) three-dimensional grid representation
FIGURE 7.37: Diﬀerent presentations of the PDE solutions.

Diﬀerential Equation Problems
365
7.8
Solving ODEs with Block Diagrams in Simulink
7.8.1
A brief introduction to Simulink
The Simulink environment was ﬁrst proposed by The MathWorks Inc., in around 1990.
The original name was SimuLAB [10], and it took the current name in 1992. From the
name Simulink, we can see two meanings: “simu” and “link,” which means to connect the
blocks together, then, to perform simulation for the system thus constructed. Simulink is
an eﬀective tool useful in deﬁning diﬀerent types of ODEs and other algebraic equations.
Of course, the functions provided in Simulink are not limited to ODE solvers. It
can also be used to construct control systems with the existing and extended blocks.
Moreover, modeling and simulation to engineering systems, such as motor and drive systems,
mechanical systems and communication systems, can be carried out very easily, with
the help of the Simulink blocksets and MATLAB toolboxes. Simulink, a very powerful
environment, can be used to model and simulate dynamic systems of almost any complexity
using Simulink block libraries and user-deﬁned blocks [11, 12]. Only materials related to
ordinary diﬀerentia equation solutions are discussed in this section.
The most commonly used Simulink blocks will be introduced, and then, examples will
be given to show the modeling and simulation procedures.
7.8.2
Simulink — relevant blocks
One can issue the command open system(’simulink’) in the MATLAB window,
so that the block library window of Simulink can be opened as shown in Figure 7.38.
It can be seen that block groups are also provided. For instance, the groups such as
Sources, Continuous are provided. Each of the groups further contains sub-groups or blocks.
Theoretically speaking, the systems of almost any complexity can be modeled and simulated
using the facilities provided in Simulink.
FIGURE 7.38: Block library window in Simulink environment.
Hundreds of Simulink blocks are provided, and it is not possible to describe all of them.

366
Scientiﬁc Computing with MATLAB®
Here only the blocks related to diﬀerential equation modeling are summarized and some of
the commonly used blocks are made into a user-group, named as odegroup. The command
odegroup can be used to open the user deﬁned blockset, as shown in Figure 7.39.
1
Out1
Transport
Delay
1
s+1
Transfer Fcn
Switch
Step
Sine Wave
Scope
Product
K*u
Matrix
Gain
eu
Math
Function
MATLAB
Function
MATLAB Fcn
Look−Up
Table
1
s
Integrator
1
Gain
f(u)
Fcn
em
1
Constant
Clock
1
In1
FIGURE 7.39: User-deﬁned most commonly used blocks.
The frequently used blocks are summarized below
(i) Input and output port blocks (In1, Out1)
These blocks can generate a variable
yout in MATLAB workspace. Any signal in the simulation model can be connected to the
Scope blocks.
(ii) Clock block generates time t, and it can be used in the modeling of time varying
diﬀerential equations.
(iii)
Commonly used input blocks
The Sine block can be used in generating
sinusoidal signals. The block Step can be used in generating the step signal, and the Constant
block can be used to deﬁne the constant signals.
(iv)
Integrator block (Int)
The block is used to evaluate integral to the input
signal. For instance, assume that the input to the ith integrator is x′
i(t), the output of the
integrator is then xi(t). The use of integrator is a crucial step in the modeling of diﬀerential
equations. For high-order linear diﬀerential equations, it can also be modeled by Transfer
Function blocks.
(v) Transport delay blocks (Transport Delay)
The output signal is the value of the
input signal at time t −τ. It can be used in modeling of delay diﬀerential equations.
(vi)
Gain blocks (Gain, Sliding Gain and Matrix Gain)
These gain blocks are very
useful in Simulink modeling. The deﬁnitions of them are diﬀerent. The Gain block is used
to amplify the input signal. If the input signal is u, the output of the block is Ku. The
Matrix Gain block is used for vector input signal u, whose output is Ku. The Sliding Gain
block implements a scroll bar so that the gain of the block can be changed arbitrarily using
mouse dragging.
(vii) Mathematical operation blocks These blocks can be used to perform algebraic
operations such as plus, minus and times as well as logical operations.
(viii) Mathematical function blocks These blocks can be used to perform nonlinear
functions such as trigonometry functions or exponential functions.
(ix) Signal vectorization blocks
The Mux block can be used as the vector signal
composed of individual input signals. The Demux block can be used to extract scalar signals
from the vector signal.

Diﬀerential Equation Problems
367
7.8.3
Using Simulink for modeling and simulation of ODEs
Using suitable blocks, the diﬀerential equations can be constructed using Simulink. The
solution of the ODEs can be obtained with the function sim(), with the following syntax
[t,x,y] = sim(model name,tspan,options)
which is quite similar to the function ode45(). Examples will be given in the following to
demonstrate the modeling and simulation of diﬀerent types of diﬀerential equations. The
Lorenz equation will be studied ﬁrst, followed by the delay diﬀerential equations.
Example 7.42
Consider again the Lorenz equation studied in Example 7.9
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
x′
1(t) = −βx1(t) + x2(t)x3(t)
x′
2(t) = −ρx2(t) + ρx3(t)
x′
3(t) = −x1(t)x2(t) + σx2(t) −x3(t),
where β = 8/3, ρ = 10 and σ = 28, and the initial states are x1(0) = x2(0) = 0, and
x3(0) = 10−10. Model the diﬀerential equations with Simulink, and then, ﬁnd the solutions
using simulation technique.
Solution
Since there are three ﬁrst-order derivative terms, three integrators are used to
describe respectively x′
1(t), x′
2(t) and x′
3(t). The outputs of these blocks are x1(t), x2(t) and
x3(t). The framework of the system can be established as shown in Figure 7.40 (a). Double
click each integrator block and the initial state variables can be speciﬁed for each integrator.
With the framework, the states and their derivatives are deﬁned, and with the use of Mux
block, the state vector can be deﬁned such that x(t) = [x1(t), x2(t), x3(t)]T. Then, the Lorenz
equation can be established when the derivative terminals are assigned to suitable signals.
For instance, the ﬁrst equation, x′
1(t) = −βx1(t) + x2(t)x3(t), can be speciﬁed with the use
of Fcn block. One can ﬁll the edit box of Fcn block with the string -beta*u[1]+u[2]*u[3].
The other two equations can also be modeled in a similar way, such that the original ODEs
can be constructed in Simulink as shown in Figure 7.40 (b). The numerical solutions of the
equations can be obtained using simulation methods.
1
s
Integrator2
1
s
Integrator1
1
s
Integrator
x1(t)
dx1(t)/ dt
x2(t)
dx2(t)/ dt
x3(t)
dx3(t)/ dt
(a) integrator speciﬁcations
1
Out1
Mux
1
s
1
s
1
s
Integrator
−beta*u[1]+u[2]*u[3]
−rho*(u[2]−u[3])
−u[1]*u[2]+sigma*u[2]−u[3]
x1(t)
dx1(t)/ dt
x(t)
x2(t)
dx2(t)/ dt
x3(t)
dx3(t)/ dt
(b) Simulink model (ﬁle: c7mlor1b.mdl)
FIGURE 7.40: Simulink model of the Lorenz equation.
The following statements can be used to solve the Simulink model. The results obtained
are exactly the same as the ones given in Figures 7.2 (a) and (b).

368
Scientiﬁc Computing with MATLAB®
>> beta=8/3; rho=10; sigma=28; % assign another set of parameters
[t,x]=sim(’c7mlor1b’,[0,100]); subplot(121), plot(t,x) % simulation
subplot(122), plot3(x(:,1),x(:,2),x(:,3)) % draw 3D phase space trajectory
It should be noted that the variables beta, rho and sigma can be entered directly into
MATLAB workspace, rather than specifying them as additional variables. The initial states
can be speciﬁed in relevant dialog boxes.
It is noted that for problems of small scales, the modeling of the diﬀerential equations
in Simulink is more complicated than the direct use of ode45() function. However, for
complicated ordinary diﬀerential equations, using Simulink may make the equation solution
process straightforward.
In fact, Interpreted MATLAB Function block in User-Deﬁned Functions group can be used
in modeling the diﬀerential equations easily. A MATLAB function can be written to describe
the right-hand-side of the explicit diﬀerential equation, as a static function of y = f(x),
and the ﬁle can be embedded in the block.
Example 7.43
For the right-hand-side of the equation in the previous example can be
expressed in MATLAB as the following static function
function y=c7mode1(x), b=8/3; r=10; s=28;
y=[-b*x(1)+x(2)*x(3); -r*x(2)+r*x(3); -x(1)*x(2)+s*x(2)-x(3)];
and the ﬁle can be saved in ﬁle c7mode1.m. The model in Figure 7.41 (a) can be constructed,
where a vectorized integrator is used to accept the vector signal x(t). The initial values of
the equation can be set as a vector [0;0;1e−10] in the integrator. The model yields exactly
the same result, as the one obtained in the previous example.
Out1
1
Interpreted MATLAB
Function
Interpreted
MATLAB Fcn
Integrator
1
s
(a) ﬁle c7mode1a.mdl
Out1
1
MATLAB Function
u
y
fcn
Integrator
1
s
(b) another ﬁle: c7mode1b.mdl
FIGURE 7.41: The new Simulink models for the Lorenz equation.
Alternatively, if the MATLAB Function block in the same group is used, the MATLAB
function can be embedded in the block, and no extra MATLAB function ﬁles are necessary.
Unfortunately in this case, the embedded function will be compiled with Stateﬂow and a
lot of other ﬁles are generated. The ﬁrst method is recommended. Besides, the additional
variables are not supported, and S-function or extra input ports will be used, if the extra
parameters are used.
Example 7.44
Consider the delay diﬀerential equations in Example 7.27, where

x′(t) = 1 −3x(t) −y(t −1) −0.2x3(t −0.5) −x(t −0.5)
y′′(t) + 3y′(t) + 2y(t) = 4x(t).

Diﬀerential Equation Problems
369
Solve numerically the delay diﬀerential equations using Simulink.
Solution
The equation has already been solved in the previous example by the use of
function dde23(), where some MATLAB functions are used. However, this method is not
quite straightforward.
Now consider the ﬁrst equation. One may move the −3x(t) term to the left-hand side,
and the original equation can be converted to
x′(t) + 3x(t) = 1 −y(t −1) −0.2x3(t −0.5) −x(t −0.5).
Thus, the state x(t) can be regarded as the output signal from the transfer function 1/(s+
3), while the input signal to the transfer function is 1 −y(t−1)−0.2x3(t−0.5)−x(t−0.5).
In the second equation, the y(t) signal can be regarded as the output of block 4/(s2 +3s+2),
while the input to the block is x(t). The transport delay blocks can be connected to the
signals x(t) and y(t) to generate the delayed signals from them. From the above analysis,
the Simulink model shown in Figure 7.42 can be constructed.
1
Out1
Transport
Delay1
Transport
Delay
Transfer Fcn1
Transfer Fcn
Step
Scope
0.2*u(1)^3+u(1)
Fcn
1
s + 3
4
s2+3s+2
y(t)
x(t)
FIGURE 7.42: Simulink model (ﬁle: c7mdde2.mdl).
When the model is established, the following statements can be used to solve the
diﬀerential equations. The output signal y(t) obtained is exactly the same as the one obtained
in Example 7.27. Also, the solutions can be displayed on the Scope in the simulation model.
>> [t,x]=sim(’c7mdde2’,[0,10]); plot(t,x)
Of course, if one is not used to the transfer function representation, one can still assume
that x1 = x, x2 = y, x3 = y′; thus, the original ordinary diﬀerential equations are converted
to the ﬁrst-order explicit diﬀerential equations
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
x′
1(t) = 1 −x1(t) −x2(t −1) + 0.2x3
1(t −0.5) −x1(t −0.5)
x′
2(t) = x3(t)
x′
3(t) = −4x1(t) −3x3(t) −2x2(t).
Since there are three equations, three integrators should be used, and the Simulink model
can then be established using the descriptions given earlier. The same numerical results are
obtained.
Example 7.45
Now let us consider the neutral-type delay diﬀerential equations deﬁned
in Example 7.32, where

370
Scientiﬁc Computing with MATLAB®
A1 =
⎡
⎣
−13
3
−3
106
−116
62
207
−207
113
⎤
⎦,
A2 =
⎡
⎣
0.02
0
0
0
0.03
0
0
0
0.04
⎤
⎦,
B =
⎡
⎣
0
1
2
⎤
⎦.
Model and solve it with Simulink.
Solution The equations cannot be directly solved using the dde23() function. Simulink-
based modeling can be used to describe the equations, and it can also be simulated via
Simulink. Before building the Simulink model, the following statements can be entered to
deﬁne the given matrices
>> A1=[-13,3,-3; 106,-116,62; 207,-207,113];
A2=diag([0.02,0.03,0.04]); B=[0; 1; 2];
Now consider the original equations. Deﬁne an integrator, and then, deﬁne the output
signal to the integrator as the state vector, x(t) and the input signal is automatically the
derivative of the states x′(t). Transport delay blocks can be appended to the two signals to
describe the signals x(t −τ1) and x′(t −τ2). Thus, the Simulink model can be constructed
as shown in Figure 7.43.
1
Out1
Step
A1* u
A2* u
B* u
1
s
Integrator
τ1 =0.15
τ2 =0.5
FIGURE 7.43: Neutral-type DDE model (ﬁle: c7mdde3.mdl).
This neutral type delay diﬀerential equation can easily be solved and the time responses
are shown in Figure 7.44.
>> [t,x]=sim(’c7mdde3’,[0,8]); plot(t,x) % direct simulation model
0
5
10
15
−1
0
1
2
3
4
5
x1(t)
x2(t)
x3(t)
FIGURE 7.44: Solutions to delay diﬀerential equations.

Diﬀerential Equation Problems
371
Example 7.46 Assume that the initial states are zeros, please solve the following variable
delay diﬀerential equations
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
x′
1(t) = −2x2(t) −3x1(t −0.2| sin t|)
x′
2(t) = −0.05x1(t)x3(t) −2x2(t −0.8)
x′
3(t) = 0.3x1(t)x2(t)x3(t) + cos(x1(t)x2(t)) + 2 sin 0.1t2.
Solution
Similar to the modeling process of other diﬀerential equations, a vectorized
integrator is needed to describe the state vector x(t). The six signals composed of x(t),
x1(t −0.2| sint|), x2(t −0.8) and t can be grouped together with Mux block to form the
output signal vector. The following MATLAB static function can be written and saved in
the Interpreted MATLAB Function block.
function y=c7fdde6(x)
y=[-2*x(2)-3*x(4); -0.05*x(1)*x(3)-2*x(5)+2;
0.3*x(1)*x(2)*x(3)+cos(x(1)*x(2))+2*sin(0.1*x(6)^2)];
Thus, the Simulink model shown in Figure 7.45 can be established, and in the system, the
variable delay term can be expressed by the Variable Time Delay block, with its second input
port driven by the signal 0.2| sint|. It can be seen that the simulation results are exactly the
same as the one obtained in Figure 7.19.
Out1
1
Variable
To
Transport Delay
Terminator
Mux
Interpreted MATLAB
Function
Interpreted
MATLAB Fcn
Integrator
1
s
Fcn
0.2*abs(sin(u))
Demux
Clock
τ =0.8
x(t)
x(t)
FIGURE 7.45: Simulink model of variable delay diﬀerential equations (ﬁle: c7mdde6.mdl).
If there exist nonzero initial values in the state vectors, and the history data for t < 0
are zeros, the initial vector of the integrator can be set to a nonzero vector, for instance,
x0 = [ sin 1, cos 1, 1 ]T. The simulation results obtained are exactly the same as the one
obtained in Figure 7.20 (b).
In Section 7.4.5, linear systems driven by stochastic inputs are studied with time domain
approach, which cannot be extended in use for nonlinear systems. Simulink modeling and
simulation can be adopted for nonlinear systems, and the stochastic input can be generated
by the Band-limited White Noise block, in the Sources group, and cannot be generated by
other random number generator blocks. Fixed-step simulation is recommended and the
step-size in simulation can be assigned to the block. Besides, since the system is driven by
stochastic signals, and the number of points in simulation should be set to a large number,
for instance, 30,000.

372
Scientiﬁc Computing with MATLAB®
Example 7.47 Consider again the linear stochastic diﬀerential equation in Example 7.26.
Please solve the problem with Simulink.
Solution The Simulink model is shown in Figure 7.46. Assume that the computation step-
size is T = 0.02 s, the Simulink model can be executed, and the following statements can be
used to draw the histogram, and the results are exactly the same as the one shown in Figure
7.17 (b), and the simulation results are validated.
>> w=0.2; x=-2.5:w:2.5; y1=hist(yout,x); bar(x,y1/length(yout)/w);
x1=-2.5:0.05:2.5; v=0.6655; y2=1/sqrt(2*pi)/v*exp(-x1.^2/2/v^2);
line(x1,y2)
% superimposed theoretical probability density function
Out1
1
Transfer Fcn
s  +7s  +2s+24
3
2
s  +10s  +35s  +50s+24
4
3
2
Band−Limited White Noise
FIGURE 7.46: Simulink model of linear stochastic diﬀerential equation (c7mrand.mdl).
Example 7.48
Consider the nonlinear system structure as shown in Figure 7.47, where
the transfer function and saturation can be described as
G(s) =
s3 + 7s2 + 24s + 24
s4 + 10s3 + 35s2 + 50s + 24, nonlinearity N(e) =
⎧
⎨
⎩
2 sign(e),
|e| > 1
2e,
|e| ⩽1.
-
−
-
N (e)
-
-
G(s)
-
?
6
e(t)
r(t)
γ(t)
y(t)
FIGURE 7.47: Block diagram of a stochastic nonlinear system model.
Assume that the mean and variance of the Gaussian white noise disturbance γ(t) are
0 and 3, respectively, and the deterministic signal is r(t) = 0. Perform simulation to the
system, and ﬁnd the distribution of the error signal e(t).
Solution The Simulink model can be established as shown in Figure 7.48.
After simulation, the two variables tout and yout are returned back into MATLAB
workspace. The time response of the last 500 points in simulation are shown in Figure 7.49
(a), and it can be seen that the results are meaningless. The histogram obtained from the
whole simulation results can also be obtained with the following statements, as shown in
Figure 7.49 (b), and it is the probabilistic distribution of the error signal e(t).
>> plot(tout(end-500:end),yout(end-500:end)); c=linspace(-2,2,20);
y1=hist(yout,c); figure; bar(c,y1/(length(tout)*(c(2)-c(1))))

Diﬀerential Equation Problems
373
Out1
1
Transfer Fcn
s  +7s  +24s+24
3
2
s  +10s  +35s  +50s+24
4
3
2
Saturation
Gain
2
Constant
0
Band−Limited
White Noise
FIGURE 7.48: Simulink model of the nonlinear stochastic diﬀerential equation
(ﬁle:
c7mnlrsys.mdl).
295
295.5
296
296.5
297
297.5
298
298.5
299
299.5
300
−1
−0.5
0
0.5
1
1.5
(a) time responses
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
(b) probability density function
FIGURE 7.49: Simulation result of signal e(t).
Exercises
Exercise 7.1 Find the general solution to the following linear time-invariant ordinary
diﬀerential equation:
d5y(t)
dt5
+ 13d4y(t)
dt4
+ 64d3y(t)
dt3
+ 152d2y(t)
dt2
+ 176dy(t)
dt
+ 80y(t)
= e−2t 
sin

2t + π
3

+ cos 3t

.
With the initial conditions y(0) = 1, y(1) = 3, y(π) = 2, y′(0) = 1, y′(1) = 2, ﬁnd the
analytical solution. Verify the obtained results by back-substitution.
Exercise 7.2 Please ﬁnd the general solutions of the following equations
(i)
⎧
⎨
⎩
x′′(t) −2y′′(t) + y′(t) + x(t) −3y(t) = 0
4y′′(t) −2x′′(t) −x′(t) −2x(t) + 5y(t) = 0,

374
Scientiﬁc Computing with MATLAB®
(ii)
⎧
⎨
⎩
2x′′(t) + 2x′(t) −x(t) + 3y′′(t) + y′(t) + y(t) = 0
x′′(t) + 4x′(t) −x(t) + 3y′′(t) + 2y′(t) −y(t) = 0.
Exercise 7.3 Find the general analytical solution to the following linear time-invariant
simultaneous ordinary diﬀerential equations:
⎧
⎨
⎩
x′′(t) + 5x′(t) + 4x(t) + 3y(t) = e−6t sin 4t
2y′(t) + y(t) + 4x′(t) + 6x(t) = e−6t cos 4t.
If initial and boundary conditions are x(0) = 1, x(π) = 2, y(0) = 0, ﬁnd the corresponding
speciﬁc solution. Verify the results by back-substitution.
Exercise 7.4 Find the analytical solutions to the following linear time-varying ordinary
diﬀerential equations:
(i) Legendre equation: (1 −t2)d2x(t)
dt2
−2tdx(t)
dt
+ n(n + 1)x(t) = 0,
(ii) Bessel equation: t2 d2x(t)
dt2
+ tdx(t)
dt
+ (t2 −n2)x(t) = 0.
Exercise 7.5 Find the analytical solution to the following nonlinear diﬀerential equation:
y′′(x) −

2 −1
x

y′(x) +

1 −1
x

y(x) = x2e−5x.
Furthermore, if the boundaries are speciﬁed by y(1) = π, y(π) = 1, ﬁnd the analytical
solution.
Exercise 7.6 Solve the following linear time-invariant diﬀerential equations using Laplace
transform method:
⎧
⎨
⎩
x′′(t) + y′′(t) + x(t) + y(t) = 0, x(0) = 2, y(0) = 1
2x′′(t) −y′′(t) −x(t) + y(t) = sin t, x′(0) = y′(0) = −1.
Compare the obtained results with those by numerical methods.
Exercise 7.7 Find the general solutions to the following ordinary diﬀerential equations.
(i) x′′(t) + 2tx′(t) + t2x(t) = t + 1,
(ii) y′(x) + 2xy(x) = xe−x2,
(iii) y(3)(t) + 3y′′(t) + 3y′(t) + y(t) = e−t sin t.
Exercise 7.8 Please ﬁnd analytical solutions for the following nonlinear diﬀerential
equations
(i) y′(x) = y4(x) cos x + y(x) tan x,
(ii) xy2(x)y′(x) = x2 + y2(x), xy′(x) + 2y(x) + x5y3(x)ex = 0.
Exercise 7.9 Please ﬁnd the solutions of the following diﬀerential equations, and plot the
trajectory of the variables (x, y).
⎧
⎨
⎩
(2x′′(t) −x′(t) + 9x(t)) −(y′′(t) + y′(t) + 3y(t)) = 0,
(2x′′(t) + x′(t) + 7x(t)) −(y′′(t) −y′(t) + 5y(t)) = 0,
,
where, x(0) = x′(0) = 1 and y(0) = y′(0) = 0.

Diﬀerential Equation Problems
375
Exercise 7.10 Please solve the following time-varying diﬀerential equations
(i) (x2 −2x + 3)y′′′(x) −(x2 + 1)y′′(x) + 2xy′(x) −2y(x) = 0,
(ii) x2ln xy′′(x) −xy′(x) + y(x) = 0,
(iii) (et + 1)y′′(t) −2y′(t) −ety(t) = 0.
Exercise 7.11 Please solve the following diﬀerential equations
(i)
dx(t)
x3(t) + 3x(t)y2(t) = dy(t)
2y3(t) =
dz(t)
2y2(t)z(t), (ii)
⎧
⎨
⎩
d2y(x)/ dx2 + 2y(x) + 4z(x) = ex
d2z(x)/ dx2 −y(x) −3z(x) = −x.
Exercise 7.12 Limit cycle is a common phenomenon in nonlinear diﬀerential equations.
For dynamic systems governed by nonlinear diﬀerential equations, no matter what initial
values are selected, the phase trajectory will settle down on the same closed path, which is
referred to as the limit cycle. Solve the following diﬀerential equations and draw the limit
cycle in the x-y plane:
⎧
⎨
⎩
x′(t) = y(t) + x(t)(1 −x2(t) −y2(t))
y′(t) = −x(t) + y(t)(1 −x2(t) −y2(t)).
Try diﬀerent initial values, and check whether the phase plane plot converges to the same
limit cycle.
Exercise 7.13 Consider the following nonlinear diﬀerential equations. It was pointed out
in [13] that there are multiple limit cycles, r = 1/(nπ), n = 1, 2, 3, · · ·. Please solve the
equations numerically and observe the status of the limit cycles.
⎧
⎨
⎩
x′(t) = −y(t) + x(t)f

x2(t) + y2(t)

y′(t) = x(t) + y(t)f

x2(t) + y2(t)

,
where, f(r) = r2 sin(1/r).
Exercise 7.14 Consider the well-known R¨ossler equation described as
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
x′(t) = −y(t) −z(t)
y′(t) = x(t) + ay(t)
z′(t) = b + (x(t) −c)z(t),
where a = b = 0.2, c = 5.7 and x1(0) = x2(0) = x3(0). Draw the 3D phase trajectory
and also its projection on the x-y plane. In preparing the MATLAB scripts, the parameters
a, b, c are suggested to be used as additional variables. If the parameters are changed to
a = 0.2, b = 0.5, c = 10, solve the problem again and observe the change of phase behavior.
Exercise 7.15 Consider the following Chua’s circuit equation well-known in chaos studies:
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
x′(t) = α[y(t) −x(t) −f(ξ)]
y′(t) = x(t) −y(t) + z(t)
z′(t) = −βy(t) −γz(t),
where the nonlinear function f(ξ) is described by
f(ξ) = bξ + 1
2(a −b)(|ξ + 1| −|ξ −1|), and a < b < 0.

376
Scientiﬁc Computing with MATLAB®
Prepare an M-function to describe the above equations, and draw the phase trajectory
for the parameters α = 9, β = 100/7, γ = 0, a = −8/7, b = −5/7, and initial conditions
x(0) = −2.121304, y(0) = −0.066170, z(0) = 2.881090.
Exercise 7.16 For the Lotka–Volterra’s predator–prey equations
⎧
⎨
⎩
x′(t) = 4x(t) −2x(t)y(t)
y′(t) = x(t)y(t) −3y(t),
with initial conditions x(0) = 2, y(0) = 3, solve the time responses of x(t) and y(t), and
also plot the phase plane trajectory.
Exercise 7.17 Consider Duﬃng equation
x′′(t) + μ1x′(t) −x(t) + 2x3(t) = μ2 cos t, with x1(0) = γ, x2(0) = 0.
(i) Assume that μ1 = μ2 = 0, please solve the equation numerically and draw the phase
plots in the same coordinates for diﬀerent initial values, for instance, γ = [0.1 : 0.1 : 2];
(ii) If μ1 = 0.01, μ2 = 0.001, please draw the phase plots for diﬀerent initial conditions,
for instance, γ = 0.99, 1.01;
(iii) If x2(0) = 0.2, please draw the phase plots again for diﬀerent γ.
Exercise 7.18 Select appropriate state variables to convert the following high-order
ordinary diﬀerential equations into ﬁrst-order vector-form explicit ones. Solve the equations
and plot the phase trajectories.
(i)
⎧
⎨
⎩
x′′(t) = −x(t) −y(t) −(3x′(t))2 + (y′(t))3 + 6y′′(t) + 2t
y(3) = −y′′ −x′ −e−x −t,
with x(1) = 2, x′(1) = −4, y(1) = −2, y′(1) = 7, ¨y(1) = 6,
(ii)
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
x′′(t) −2x(t)z(t)x′(t) = 3x2(t)y(t)t2
y′′(t) −ey(t)y′(t) = 4x(t)t2z(t)
z′′(t) −2tz′(t) = 2te−x(t)y(t),
with
⎧
⎨
⎩
z′(1) = x′(1) = y′(1) = 2
z′(1) = x(1) = y(1) = 3.
(iii)
⎧
⎨
⎩
x(4)(t) −8 sin ty(t) = 3t −e−2t
y(4)(t) + 3te−5tx(t) = 12 cost,
with
⎧
⎪
⎨
⎪
⎩
x(0) = y(0) = 0, x′(0) = y′(0) = 0.3
x′′(0) = y′′(0) = 1, x′′′(0) = y′′′(0) = 0.1.
Exercise 7.19 Solve the following nonlinear time-varying diﬀerential equation
y(3)(t) + ty(t)y′′(t) + t2y′(t)y2(t) = e−ty(t), y(0) = 2, y′(0) = y′′(0) = 0,
and plot y(t). Select the ﬁxed-step Runge–Kutta algorithm for solving the same problem
as the baseline and compare in speed and accuracy with other MATLAB ODE solvers for
this problem.
Exercise 7.20 Find the analytical and numerical solutions of the high-order simultaneous
linear time-invariant ordinary diﬀerential equations and compare the results:
⎧
⎨
⎩
x′′(t) = −2x(t) −3x′(t) + e−5t,
x(0) = 1, x′(0) = 2
y′′(t) = 2x(t) −3y(t) −4x′(t) −4y′(t) −sin t,
y(0) = 3, y′(0) = 4.

Diﬀerential Equation Problems
377
Exercise 7.21 Consider the following nonlinear diﬀerential equations:
⎧
⎨
⎩
u′′(t) = −u(t)/r3(t)
v′′(t) = −v(t)/r3(t),
where r(t) =

u2(t) + v2(t), and u(0) = 1, u′(0) = 2, v′(0) = 2, v(0) = 1. Select a set of
state variables and convert the original ordinary diﬀerential equations to the form solvable
by MATLAB. Plot the curves of u(t), v(t), and the phase plane trajectory.
Exercise 7.22 Consider the following implicit ODEs [14]
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎩
u′
1(t) = u3(t)
u′
2(t) = u4(t)
2u′
3(t) + cos(u1(t) −u2(t))u′
4(t) = −g sin u1(t) −sin(u1(t) −u2(t))u2
4(t)
cos(u1(t) −u2(t))u′
3(t) + u′
4(t) = −g sin u2(t) + sin(u1(t) −u2(t))u2
3(t),
where u1(0) = 45, u2(0) = 30, u3(0) = u4(0) = 0 and g= 9.81. Solve the above initial value
problem and plot the time responses to the given initial states.
Exercise 7.23 Numerically solve the following implicit diﬀerential equations
⎧
⎨
⎩
x′
1(t)x′′
2(t) sin(x1(t)x2(t)) + 5x′′
1(t)x′
2(t) cos(x2
1(t)) + t2x1(t)x2
2(t) = e−x2
2(t)
x′′
1(t)x2(t) + x′′
2(t)x′
1(t) sin(x2
1(t)) + cos(x′′
2(t)x2(t)) = sin t,
where x1(0) = 1, x′
1(0) = 1, x2(0) = 2, x′
2(0) = 2. Plot the phase trajectory.
Exercise 7.24 The following linear time-invariant diﬀerential equations are considered
as stiﬀ. Solve the initial value problems using ordinary and stiﬀODE solver provided in
MATLAB. Meanwhile, try to solve these equations using analytical methods and verify the
accuracy of the numerical results.
(i)
⎧
⎪
⎨
⎪
⎩
y′
1(t) = 9y1(t) + 24y2(t) + 5 cos t −1
3 sin t, y1(0) = 1
3
y′
2(t) = −24y1(t) −51y2(t) −9 cos t + 1
3 sin t, y2(0) = 2
3,
(ii)
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
y′
1(t) = −0.1y1(t) −49.9y2(t), y1(0) = 1
y′
2(t) = −50y2(t), y2(0) = 2
y′
3(t) = 70y2(t) −120y3(t), y3(0) = 1.
Exercise 7.25 Consider the following chemical reaction diﬀerential equations
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
y′
1(t) = −0.04y1(t) + 104y2(t)y3(t)
y′
2(t) = 0.04y1(t) −104y2(t)y3(t) −3 × 107y2
2(t)
y′
3(t) = 3 × 107y2
2(t),
where the initial values are y1(0) = 1, y2(0) = y3(0) = 0. Note that the above equations
might be regarded as stiﬀ. Solve the initial value problem with ode45() and the stiﬀsolver
ode15s() and check whether the obtained results are comparable or not.

378
Scientiﬁc Computing with MATLAB®
Exercise 7.26 Solve the boundary value problem in Exercise 7.5 using numerical methods
and draw the solution y(t). Compare the accuracy of the results with the analytical results
obtained earlier.
Exercise 7.27 Solve numerically the following diﬀerential equations with zero initial
conditions
(i)
⎧
⎨
⎩
x′(t) =

x2(t) −y(t) + 3 −3
y′(t) = arc tan(x2(t) + 2x(t)y(t)),
(ii)

x′(t) = ln(2 −y(t) + 2y2(t))
y′(t) = 4 −

x(t) + 4x2(t).
Exercise 7.28 Please solve the following diﬀerential equation with zero initial conditions
⎧
⎨
⎩
cos x′′(t)y′′′(t) −cos x′′(t) −y′′(t) −x(t)y′(t) + e−x(t)y(t) = 2
sin x′′(t) cos y′′′(t) −x(t)y′(t) + x′′(t)y(t) −y2(t)y′(t) = 5.
Exercise 7.29 Please solve the following delay diﬀerential equation, where for t ⩽0, it is
known that x(t) = t, and y(t) = et.
⎧
⎨
⎩
x′(t) = x2(t −0.2) + y2(t −0.2) −6x(t −0.5) −8y(t −0.1)
y′(t) = x(t)[2y(t −0.2) −x(t) + 5 −2x2(t −0.1)].
If the last term in the equation is changed from x2(t −0.1) to x′(t −0.1), solve the
equation again.
Exercise 7.30 Solve the boundary value problems where
(i) x′′ + 1
t x′ +

1 −1
4t2

x =
√
t cos t, with x(1) = 1, x(6) = −0.5,
(ii) −u′′(x) + 6u(x) = e10x cos 12x, u(0) = u(1) = 1.
Exercise 7.31 For the Van der Pol equation y′′ + μ(y2 −1)y′ + y = 0, if μ = 1, ﬁnd the
numerical solutions for boundary conditions y(0) = 1, y(5) = 3. If μ is an undetermined
constant, an extra condition y′(5) = −2 can be used. Solve the parameter μ as well as the
equation. Plot the obtained solution and verify the results.
Exercise 7.32 Solve the boundary value problem with undetermined parameter c, where
⎧
⎨
⎩
x′(t) = x2(t) −y(t)
y′(t) = [ x(t) −y(t) ][ x(t) −y(t) −c ],
with
⎧
⎨
⎩
x(0) = y(0) = 0
y(5) = 1.
Exercise 7.33 Please solve the boundary value problem given by
y′′(x) = λ2(y2(x) + cos2 πx) + 2π2 cos 2πx, where y(0) = y(1) = 0, and y′(0) = 1.
Exercise 7.34 An infectious disease with periodic outbreak can be described by Kermack–
McKendrick model [8]
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
y′
1(t) = −y1(t)y2(t −1) + y2(t −10)
y′
2(t) = y1(t)y2(t −1) −y2(t)
y′
3(t) = y2(t) −y2(t −10),

Diﬀerential Equation Problems
379
where, for t ⩽0, the history is described by y1(t) = 5, y2(t) = 0.1, y3(t) = 1, please solve
numerically the equation for t ∈[0, 40].
Exercise 7.35 Consult the method described in Example 7.37, extend the method to handle
high-order diﬀerential equations with undetermined constants. Please validate the method
with the equation in Example 7.38.
Exercise 7.36 Solve numerically the partial diﬀerential equations below and draw the
surface plot of the solution u.
⎧
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎩
∂2u
∂x2 + ∂2u
∂y2 = 0
u|x=0,y>0 = 1,
u|y=0, x⩾0 = 0
x > 0,
y > 0.
Exercise 7.37 Consider the following simple linear time-invariant diﬀerential equation
y(4)(t) + 4y(3)(t) + 6y′′(t) + 4y′(t) + y(t) = e−3t + e−5t sin(4t + π/3),
with the initial conditions given by y(0) = 1, y′(0) = y′′(0) = 1/2, y(3)(0) = 0.2. Construct
the simulation model with Simulink, and ﬁnd the simulation results.
Exercise 7.38 Consider the following time varying diﬀerential equation
y(4)(t) + 4ty(3)(t) + 6t2y′′(t) + 4y′(t) + y(t) = e−3t + e−5t sin(4t + π/3),
with the initial conditions y(0) = 1, y′(0) = y′′(0) = 1/2, y(3)(0) = 0.2. Construct a Simulink
model, solve the diﬀerential equation and plot the solution trajectories.
Exercise 7.39 Consider the following delay diﬀerential equation
y(4)(t) + 4y(3)(t −0.2) + 6y′′(t −0.1) + 6y′′(t) + 4y′(t −0.2) + y(t −0.5) = e−t2.
It is assumed that for t ⩽0, the above delay diﬀerential equation has zero initial
conditions. Construct a Simulink model and solve the delay diﬀerential equations. Moreover,
use the function dde23() to solve the same problem and compare the results from these two
methods.
Bibliography
[1] Press W H, Flannery B P, Teukolsky S A, et al. Numerical recipes, the art of scientiﬁc
computing. Cambridge: Cambridge University Press, 1986
[2] Dawkins P. Diﬀerential equations. http://tutorial.math.lamar.edu/pdf/DE/DE
Complete.pdf, 2007
[3] Mauch S. Advanced mathematical methods for scientists and engineers. Open source
textbook at http://www.its.caltech.edu/~sean/applied math.pdf, 2004
[4] Fehlberg E. Low-order classical Runge–Kutta formulas with step size control and their
application to some heat transfer problems. Technical Report 315, NASA, 1969

380
Scientiﬁc Computing with MATLAB®
[5] Forsythe G E, Malcolm M A, Moler C B.
Computer methods for mathematical
computations. Englewood Cliﬀs: Prentice-Hall, 1977
[6] Bogdanov A. Optimal control of a double inverted pendulum on a cart. Technical
Report CSE-04-006, Department of Computer Science & Electrical Engineering, OGI
School of Science & Engineering, OHSU, 2004
[7] Liberzon D, Morse A S. Basic problems in stability and design of switched systems.
IEEE Control Systems Magazine, 1999, 19(5):59–70
[8] Shampine L F, Thompson S. Solving DDEs in MATLAB. Applied Numerical Mathema-
tics, 2001, 37(4):441–458
[9] Shampine L F, Kierzenka J, Reichelt M W.
Solving boundary value problems for
ordinary diﬀerential equation problems in MATLAB with bvp4c, 2000
[10] The MathWorks Inc. SimuLAB, a program for simulating dynamic systems, user’s
guide, 1990
[11] The MathWorks Inc. Simulink user’s manual, 2007
[12] Xue D, Chen Y Q. System simulation techniques with MATLAB/Simulink. London:
Wiley, 2013
[13] Enns R H, McGuire G C. Nonlinear physics with MAPLE for scientists and engineers.
Boston: Birkh¨auser, second edition, 2000
[14] Molor C B. Numerical computing with MATLAB. MathWorks Inc, 2004

Chapter 8
Data Interpolation and Functional
Approximation Problems
In scientiﬁc research and engineering practice, a lot of experimental data are generated.
Based on the experimental data, the problems of data interpolation and function ﬁtting
may always be encountered. The existing data can be regarded as the samples, the
so-called data interpolation is to numerically generate new data points from a discrete
set of known samples. In Section 8.1, one-dimensional, two-dimensional or even high-
dimensional interpolation problems are solved in MATLAB. An interpolation-based
numerical integration method is also introduced. In Section 8.2, two of the most widely used
splines for interpolation are introduced, the cubic spline and the B-spline. Spline function-
based numerical diﬀerentiations and integrations are also introduced. The integration
results are even more accurate than those presented in Chapter 3 and Section 8.1. Data
interpolation problems can easily be solved by following the examples in these two sections.
The so-called function approximation problem is to extract the function representation
from the measured sample points. Polynomial approximations and the least squares method
for nonlinear function approximation will be studied. Furthermore, Pad´e approximations
and continued fraction approximations for given functions are explored in Section 8.3. In
Section 8.6, the correlation analysis of signals and experimental data are introduced. Fast
Fourier transforms and ﬁlter-based de-noising and other signal processing problems are
introduced.
At this point, let us note the diﬀerence between “interpolation” and “ﬁtting.” The key
distinguishing feature for “interpolation” is that the obtained interpolation function passes
through all given data points, while for “ﬁtting” the obtained ﬁtting function may not pass
all the given data points.
Some problems in the chapter are also related to those topics presented in other chapters,
with Chapter 10 in particular. For instance, the data ﬁtting problems can be solved with
neural networks to be discussed in Section 10.3. Data ﬁltering and de-noising problems can
also be solved with wavelet transform techniques to be introduced in Section 10.5.
For readers who wish to check the detailed explanations of various data interpolation
techniques and function ﬁtting methods, we recommend the free textbook [1] (Chapters 3,
5 and 15). We also found the online resource [2] useful and interesting (Chapter 5).
381

382
Scientiﬁc Computing with MATLAB®
8.1
Interpolation and Data Fitting
8.1.1
One-dimensional data interpolation
I. Solving one-dimensional data interpolation problems
Assume that the function f(x) is a one-dimensional function and the mathematical
formula is not known. If at a set of N distinct points x1, x2, · · · , xN, the values of the function
are measured as y1, y2, · · · , yN. The points (x1, y1), (x2, y2), · · · , (xN, yN) are often referred
to as sample points. The idea of using sample points for ﬁnding other unknown points is
called interpolation.
Many interpolation functions have been provided in MATLAB, such as the one-
dimensional interpolation function interp1(), two-dimensional interp2() and the poly-
nomial ﬁtting function polyfit().
One-dimensional interpolation function interp1() can be called, with the syntax
y1 = interp1(x,y,x1,method), where x = [x1, x2, · · · , xN]T and y = [y1, y2, · · · , yN]T.
The two vectors provide the information of the sample points. The argument x1 is the
points of independent variable to be interpolated. It can be a scalar, a vector or a matrix.
The interpolated results are returned in argument y1. The default of method argument is
’linear’. Alternative options for the method argument can be ’nearest’, ’pchip’ (in old
versions, ’cubic’) and ’spline’. Usually it is recommended that the ’spline’ option be
used. Extrapolations, i.e., the interpolation point is outside of the interval [x1, xN] can also
be performed with y1 = interp1(x,y,x1,method,’extrap’).
Example 8.1
Assume the sample points are generated from the function f(x) = (x2 −
3x + 5)e−5x sin x. Interpolate the sample points and see whether a smoother curve can be
reconstructed.
Solution The sample data can be generated with the following statements, where the spacing
can be selected as a large value, such as 0.12. The sample points are then obtained as shown
in Figure 8.1 (a).
>> x=0:.12:1; y=(x.^2-3*x+5).*exp(-5*x).*sin(x); plot(x,y,x,y,’o’)
It can be seen that the “curve” is formed by joining the adjacent points with straight
lines. The curves around the sample points are not very smooth. One may select another
vector of densely distributed x1 data, and then, use interp1() function to calculate the
interpolations to these points.
>> x1=0:.02:1; y0=(x1.^2-3*x1+5).*exp(-5*x1).*sin(x1);
y1=interp1(x,y,x1); y2=interp1(x,y,x1,’pchip’);
y3=interp1(x,y,x1,’spline’); y4=interp1(x,y,x1,’nearest’);
plot(x1,[y1’,y2’,y3’,y4’],x,y,’o’,x1,y0), L=49
e1=max(abs(y0(1:L)-y2(1:L))), e2=max(abs(y0-y3)), e3=max(abs(y0-y4))
Then, with diﬀerent methods, the interpolation results are compared with the theoretical
results from the given function obtained as shown in Figure 8.1 (b), with maximum absolute
errors e1 = 0.0177, e2 = 0.0086, e3 = 0.1598.
It can be seen that the linear interpolation is exactly the same as the one in Figure
8.1 (a) and the quality of ’nearest’ option is very poor. The interpolation results under

Data Interpolation and Functional Approximation Problems
383
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
(a) sample points
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
(b) comparison of diﬀerent methods
FIGURE 8.1: Results of one-dimensional interpolation methods.
the ’pchip’ and ’spline’ options are much smoother. In fact, the interpolation using
the ’spline’ method gives much better interpolation to the original function. Thus, it is
recommended to use the ’spline’ option in solving one-dimensional interpolation problems.
Example 8.2
Write a piece of code, which allows the user to draw manually a smooth
curve, interpolated by splines.
Solution In applications, the user can pick a few points with the ginput() function. Then,
interpolation can be made to obtain a smooth curve. The above idea can be implemented in
the MATLAB function shown below
function sketcher(vis)
x=[]; y=[]; i=1; h=[]; axes(gca);
while 1, [x0,y0,but]=ginput(1);
if but==1, x=[x,x0]; y=[y,y0];
h(i)=line(x0,y0); set(h(i),’Marker’,’o’); i=i+1; else, break
end, end
if nargin==0, delete(h); end
xx=[x(1):(x(end)-x(1))/100: x(end)];
yy=interp1(x,y,xx,’spline’); line(xx,yy)
II. Lagrange interpolation algorithm and its application
The Lagrange interpolation algorithm is the most presented interpolation method in the
interpolation part of numerical analysis textbooks, e.g. [3]. For known sample points xi, yi,
the interpolation on x vector can be obtained as
φ(x) =
N

i=1
yi
N

j=1,j̸=i
x −xj
(xi −xj).
(8-1-1)
Based on the above algorithm, a MATLAB function is prepared as follows:
function y=lagrange(x0,y0,x)
ii=1:length(x0); y=zeros(size(x));
for i=ii, ij=find(ii~=i); y1=1;
for j=1:length(ij), y1=y1.*(x-x0(ij(j))); end

384
Scientiﬁc Computing with MATLAB®
y=y+y1*y0(i)/prod(x0(i)-x0(ij));
end
Example 8.3
Consider a well-known function f(x) = 1/(1 + 25x2), −1 ⩽x ⩽1, where
a set of points can be evaluated as sample points. Based on the points, the interpolation
points can be obtained using Lagrange interpolation method, and the results are shown in
Figure 8.2 (a).
>> x0=-1+2*[0:10]/10; y0=1./(1+25*x0.^2);
x=-1:.01:1; y=lagrange(x0,y0,x);
% Lagrange interpolation
ya=1./(1+25*x.^2); plot(x,ya,x,y,’:’,x0,y0,’o’)
From the interpolation results, it can be seen that the interpolation is far from the
theoretic curve. The higher the degree of the polynomials, the more serious the divergence.
This phenomenon is referred to as the Runge phenomenon. Thus, for this example, the
Lagrange interpolation method failed. The function interp1() can be used instead to solve
the problem. The spline interpolation can be obtained with the following statements, and
the ﬁtting results are shown in Figure 8.2 (b). Thus, the function provided in MATLAB
does not have the Runge phenomenon any more, so it can be safely used.
>> y1=interp1(x0,y0,x,’pchip’); y2=interp1(x0,y0,x,’spline’);
plot(x,ya,x,y1,’:’,x,y2,’--’)
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−0.5
0
0.5
1
1.5
2
(a) failure of Lagrange interpolation
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
(b) interp1() interpolation
FIGURE 8.2: Interpolation results comparison.
III. Forecast problems in one-dimensional interpolations
The so-called forecast problem is to predict the data in the future based on the existing
ones. Practical examples of forecast technique are population forecast and weather forecast.
As mentioned earlier, forecast problems are essentially the extrapolation problems, and can
be implemented in interp1() function, with the option ’extrap’. If the option ’spline’
is used, ’extrap’ option cannot be used, since extrapolation problems can be handled
automatically with the spline interpolation computations.
Example 8.4
In Example 2.31, the population information was stored in an Excel ﬁle.

Data Interpolation and Functional Approximation Problems
385
The samples can be extracted from it on the basis of 5-year interval. Please interpolate from
the sample data the number of population in the years 1949–2015.
Solution Since the population information in the Excel contains the data in the period of
1949–2011, and the samples are made as 1949, 1954, · · · , 2004, 2009, the data before 2009
can be regarded as interpolation, and after that, it can be regarded as extrapolation problems.
The data obtained, as well as the original data, are shown in Figure 8.3.
>> X=xlsread(’census.xls’,’B5:C67’); t=X(:,1); p=X(:,2);
t0=t(1:5:end); p0=p(1:5:end); t1=1949:2015;
y=interp1(t0,p0,t1,’spline’,’extrap’); plot(t,p,t1,y,t0,p0,’o’)
1950
1960
1970
1980
1990
2000
2010
1500
2000
2500
3000
3500
4000
4500
FIGURE 8.3: Population computation with interpolation and extrapolation approaches.
It should be noted that, population forecast is a complicated problem, and should be studied
with speciﬁc models, such as population dynamics. The population are aﬀected by other
factors, such as population policies, natural disasters and others. The data-based results are
in fact unreliable.
8.1.2
Deﬁnite integral evaluation from given samples
The deﬁnite integral evaluation based on sample points has been discussed and the
trapezoidal approach trapz() has been presented in Section 3.9.1. From Example 3.58, it is
seen that if the sample points are sparsely distributed, there exist large errors in the results.
If interpolation is used in the evaluation of the intermediate points, the interpolation-based
numerical integration function can be written as
function y=quadspln(x0,y0,a,b)
f=@(x)interp1(x0,y0,x,’spline’); y=integral(f,a,b);
whose syntax is I = quadspln(x0,y0,a,b), where x0 and y0 are vectors composed of sample
points, [a, b] is the integration interval. With quadspln() function, the deﬁnite integral can
be obtained as illustrated in the following examples.
Example 8.5
Consider again the problem in Example 3.58. Use the interpolation-based
method to evaluate the deﬁnite integral.
Solution From the theoretical method it is known that the integral is 2. The trapezoidal
method can be applied to evaluate the integral. If the step-size is too large, the approximation

386
Scientiﬁc Computing with MATLAB®
accuracy is not satisfactory. Here the interpolation-based method is applied to the same
sample points
>> x0=linspace(0,pi,30); y0=sin(x0); I1=trapz(x0,y0) % trapezoidal method
I2=quadspln(x0,y0,0,pi) % evaluate the integral with interpolation method
The trapezoidal result is I1 = 1.9980, and with interpolation I2 = 2, with absolute error
of −3.36×10−7. It can be seen that the interpolation-based integral algorithm yields more
accurate results.
An even more exaggerated example is as follows. Suppose that there are only 5 unevenly
distributed sample points measured, the results by the use of interpolation method and
trapezoidal methods can be compared
>> x0=[0,0.4,1 2,pi]; y0=sin(x0);
% sample points generation
plot(x0,y0,x0,y0,’o’)
% the sample points are shown in Figure 8.4 (a)
I=quadspln(x0,y0,0,pi)
% only 1% relative error obtained
I1=trapz(x0,y0)
% with the trapz() function, relative error reaches 7.9%!
0
0.5
1
1.5
2
2.5
3
3.5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
(a) distribution of sample points
0
0.5
1
1.5
2
2.5
3
3.5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
(b) comparison of diﬀerent methods
FIGURE 8.4: The integration results with only ﬁve sample points.
and the results with these two methods are I = 2.0191, I1 = 1.8416, respectively. In fact, even
with such sparsely distributed sample points, the ﬁtting results are still very satisfactory. The
interpolation function together with the sample points are shown in Figure 8.4 (b), which
are quite close to the original true function.
>> x=linspace(0,pi,30); y0a=sin(x); y=interp1(x0,y0,x,’spline’);
plot(x0,y0,x,y,’:’,x,y0a,x0,y0,’o’)
Example 8.6
Consider again the oscillatory function in Example 3.59. Assume that 150
sample points are measured. Evaluate the deﬁnite integral with the quadspln() function
and verify the accuracy of the results.
Solution The numerical solutions to the deﬁnite integral can be obtained from the generated
sample points
>> x=linspace(0,3*pi/2,200); y=cos(15*x); I=quadspln(x,y,0,3*pi/2)
and the result obtained is I = 0.066672375. Note that the true integral is 1/15.

Data Interpolation and Functional Approximation Problems
387
Clearly, the interpolation-based method achieves quite high accuracy. The following
statements can be used to draw the original and interpolated curves as shown in Figure
8.5. The ﬁtting results are also quite satisfactory. The diﬀerence between the original and
interpolated curves are hardly seen from the ﬁgure.
>> x0=[0:3*pi/2/1000:3*pi/2]; y0=cos(15*x0); % theoretical value
y1=interp1(x,y,x0,’spline’); plot(x,y,x0,y1,’:’)
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
FIGURE 8.5: Original function and interpolation curves.
From this example, it can be seen that if there are signiﬁcant oscillations in the integrand,
the accuracy of integral evaluations cannot be guaranteed if the number of sample points is
large enough.
8.1.3
Two-dimensional grid data interpolation
The two-dimensional (2D) interpolation function interp2() is provided in MATLAB
with the syntax
z1 = interp2(x0,y0,z0,x1,y1,method), where x0, y0, z0 are the
measured sample points in mesh grid form. The arguments x1, y1 are the points to be
interpolated. They are not necessarily given in mesh grid form. They can be in any form,
scalars, vectors, matrices or even multi-dimensional arrays. The returned argument z1 is
the interpolation results, which is exactly the same data type as x1 or y1. The method
options are ’linear’, ’pchip’ and ’spline’. Similar to the one-dimensional interpolation
function, the method ’spline’ is recommended. Examples will be given in the following
to illustrate the 2D grid data interpolation.
Example 8.7 From the given function z = (x2−2x)e−x2−y2−xy, generate a set of relatively
sparsely distributed mesh grid sample data. From the data, interpolate the whole surface,
and compare the results with the exact surface.
Solution
The grid data can be obtained as shown in Figure 8.6 (a) by the following
MATLAB scripts. It can be seen that the surface obtained is not very smooth.
>> [x,y]=meshgrid(-3:.6:3,-2:.4:2); z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y);
surf(x,y,z), axis([-3,3,-2,2,-0.7,1.5])
Now, select more densely distributed interpolation points in mesh grid form. The
following statements can be used to evaluate the interpolation points with the interpolated
surface shown in Figure 8.6 (b).

388
Scientiﬁc Computing with MATLAB®
>> [x1,y1]=meshgrid(-3:.2:3, -2:.2:2); % generate sparse meshgrid
z1=interp2(x,y,z,x1,y1); surf(x1,y1,z1), axis([-3,3,-2,2,-0.7,1.5])
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) surface from the sample points
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(b) interpolation with linear method
FIGURE 8.6: Comparison of two-dimensional interpolations.
It can be seen that the interpolation results using the linear method is still rather
rough. Let us try ’pchip’ and ’spline’ options and the obtained results are compared
in Figure 8.7.
>> z1=interp2(x,y,z,x1,y1,’pchip’); z2=interp2(x,y,z,x1,y1,’spline’);
subplot(121), surf(x1,y1,z1), axis([-3,3,-2,2,-0.7,1.5])
subplot(122), surf(x1,y1,z2), axis([-3,3,-2,2,-0.7,1.5])
It can be seen that the interpolation results are all satisfactory, especially with the spline
interpolation option. Thus, the ’spline’ option is recommended.
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) cubic interpolation
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(b) spline interpolation
FIGURE 8.7: Comparisons of interpolation with other methods.
Furthermore, since the original function is known, the exact solutions can be obtained.
The following statements can be used to compute the error surface between the two
interpolated matrices z1 and z2 and the exact z, respectively, as shown in Figure 8.8 (a),
(b). It can be seen that the spline interpolation results are much more accurate than the ones
by the cubic interpolation. The error surface comparison suggests again that the ’spline’
option is recommended.
>> z=(x1.^2-2*x1).*exp(-x1.^2-y1.^2-x1.*y1);
% exact functions
subplot(121), surf(x1,y1,abs(z-z1)), axis([-3,3,-2,2,0,0.08])
subplot(122), surf(x1,y1,abs(z-z2)), axis([-3,3,-2,2,0,0.025])

Data Interpolation and Functional Approximation Problems
389
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.06
−0.04
−0.02
0
0.02
0.04
(a) cubic algorithm
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.06
−0.04
−0.02
0
0.02
0.04
(b) spline algorithm
FIGURE 8.8: Error surfaces of the interpolation results.
8.1.4
Two-dimensional scattered data interpolation
Through the above examples, it can be seen that the two-dimensional interpolation
problems can easily be solved with the function interp2(). However, it should be noted that
there are some restrictions. For example, only the data given in grid format can be handled
by the function interp2(). If a scattered sample data set is provided, the interp2()
function cannot be used. However, in many practical problems, the scattered data set
(xi, yi, zi) is usually provided, rather than the grid data. The general function griddata()
can then be used instead, with the syntax z = griddata(x0,y0,z0,x,y,’v4’), where x0,
y0, z0 are the vectors composed of the sample points. They can be the data vectors of
arbitrarily distributed sample points. The arguments x, y are the expected interpolation
positions, which can be described as single point, vectors or mesh grid matrices. The
returned argument z is in the same format as x, representing the interpolation results.
The option ’v4’ is the unnamed interpolation algorithm used in MATLAB version 4.0,
which has many advantages. Apart from the ’v4’ option, other options such as ’linear’,
’pchip’ and ’nearest’ can also be used. However, the option ’v4’ is recommended.
Example 8.8
Consider again the function z = (x2 −2x)e−x2−y2−xy. In the rectangular
region, x ∈[−3, 3], y ∈[−2, 2], a set of 200 sample points (xi, yi) can be selected randomly
and the values zi can be calculated. Based on the data, perform the interpolation using
griddata() and visualize the error surface.
Solution
The randomly selected 200 can be generated with the following statements,
and the vectors x, y and bmz can be established. Since the data set is not given in the
grid format, the surface plot cannot be drawn directly from the data. Scattered points can
be displayed instead as shown in Figure 8.9 (a), with the sample points distribution on
the x-y plane shown in Figure 8.9 (b). It can be seen that the sample points are evenly
scattered.
>> x=-3+6*rand(200,1); y=-2+4*rand(200,1);
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y);
% data generation
subplot(121), plot3(x,y,z,’x’), axis([-3,3,-2,2,-0.7,1.5]), grid
subplot(122), plot(x,y,’x’)
% two-dimensional distribution
The points to be interpolated can still be selected as grid format data using the method
shown in Example 8.7. The interpolated data can then be obtained with the ’cubic’

390
Scientiﬁc Computing with MATLAB®
−4
−2
0
2
4
−2
−1
0
1
2
−1
−0.5
0
0.5
1
1.5
(a) scattered three dimension plot
−3
−2
−1
0
1
2
3
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
(b) projection in the x-y plane
FIGURE 8.9: Visualization of the known sample points.
and ’v4’ options, and the interpolated surfaces are shown in Figures 8.10 (a) and (b),
respectively. It can be seen that the surface interpolation using the ’v4’ algorithm is much
better. Some of the points with the ’cubic’ options are actually missing.
>> [x1,y1]=meshgrid(-3:.2:3, -2:.2:2);
z1=griddata(x,y,z,x1,y1,’pchip’); subplot(121), surf(x1,y1,z1)
axis([-3,3,-2,2,-0.7,1.5]); z2=griddata(x,y,z,x1,y1,’v4’);
subplot(122),
surf(x1,y1,z2), axis([-3,3,-2,2,-0.7,1.5])
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−1
−0.5
0
0.5
1
1.5
(a) cubic interpolation
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−1
−0.5
0
0.5
1
1.5
(b) ’v4’ interpolation
FIGURE 8.10: Comparison of interpolation surfaces for a 2D function.
Next, let us check the interpolation errors. The error surfaces using the two interpolation
algorithms are obtained as shown in Figures 8.11 (a) and (b), respectively. It can be seen
that the interpolation quality of the ’v4’ option is much superior to the one obtained with
the cubic interpolation algorithm.
>> z0=(x1.^2-2*x1).*exp(-x1.^2-y1.^2-x1.*y1);
subplot(121), surf(x1,y1,abs(z0-z1)); axis([-3,3,-2,2,0,0.1])
subplot(122), surf(x1,y1,abs(z0-z2));
axis([-3,3,-2,2,0,0.1])
Example 8.9
In the previous example, the sample points in the x-y plane are evenly
scattered. Now, let us remove some of the points, and then, perform interpolation and
observe what happens.
Solution
If the points within the circle centered at (−1, −1/2) with a radius of 0.5 are

Data Interpolation and Functional Approximation Problems
391
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.1
0
0.1
0.2
0.3
(a) cubic interpolation
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.1
0
0.1
0.2
0.3
(b) ’v4’ interpolation
FIGURE 8.11: Interpolations errors for a two-dimensional function.
removed from the vectors x, y and z, the following statements can be used to remove the
samples.
>> ii=find((x+1).^2+(y+0.5).^2>0.5^2); % ﬁnd the points within the circle
x=x(ii); y=y(ii); z=z(ii); plot(x,y,’x’) % display the samples
t=[0:.1:2*pi,2*pi]; x0=-1+0.5*cos(t); y0=-0.5+0.5*sin(t);
line(x0,y0)
% superimpose the circle on the samples
The new samples are distributed as shown in Figure 8.12 (a) with the circle superimposed.
The samples within the circle have been removed. With the new set of samples, the
interpolated surface is obtained as shown in Figure 8.12 (b). The quality of ﬁttings looks
satisfactory.
>> [x1,y1]=meshgrid(-3:.2:3, -2:.2:2); z1=griddata(x,y,z,x1,y1,’v4’);
surf(x1,y1,z1), axis([-3,3,-2,2,-0.7,1.5]) % draw interpolated surface
−3
−2
−1
0
1
2
3
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
(a) sample data distribution
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−1
−0.5
0
0.5
1
1.5
(b) Surface interpolation
FIGURE 8.12: The new samples distribution and interpolated surface.
Error surface of the interpolation is visualized in Figure 8.13 (a) where it can be observed
that although some samples are removed, the ﬁtting result is still satisfactory.
>> z0=(x1.^2-2*x1).*exp(-x1.^2-y1.^2-x1.*y1); % compute theoretical data
surf(x1,y1,abs(z0-z1)), axis([-3,3,-2,2,0,0.15]) % draw error surface

392
Scientiﬁc Computing with MATLAB®
The error contours are also shown in Figure 8.13 (b), superimposed with the circle. It
can be seen that the ﬁtting results are satisfactory, apart from the regions where samples are
removed.
>> contour(x1,y1,abs(z0-z1),30); hold on, plot(x,y,’x’); line(x0,y0)
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.1
−0.05
0
0.05
0.1
(a) error surface
−3
−2
−1
0
1
2
3
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
(b) two-dimensional contour
FIGURE 8.13: Error surface and error contour for the 2D interpolation.
It can be concluded that the quality of interpolation depends mainly on the distribution
of measured samples. If the samples within a certain area are not suﬃcient, the quality of
interpolation in that area cannot be obtained satisfactorily. Clearly, the more sample data,
the better interpolation accuracy.
8.1.5
Optimization problems based on scattered sample data
In practical applications, sometimes the mathematical form of the objective function
is not known, instead, a set of scattered sample data are known. In this case, spline
interpolation method can be used to approximate the objective function, such that the
optimization problems can be solved.
Example 8.10 Consider again the function given in Example 8.7. Generate a set of sample
data, and based on the scattered sample data, ﬁnd and validate the minimum of the function.
Solution A set of scattered sample data can be generated ﬁrst, and an anonymous function
for the objective function can be constructed, within it, spline interpolation function can be
embedded. With the following statement, the interpolation-based optimization results are
x = 0.6069, y = −0.3085. The contour plot of the objective function can also be obtained as
shown in Figure 8.14. It can be seen that the results are correct.
>> x=-3+6*rand(200,1); y=-2+4*rand(200,1); % generate random data
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y);
% generate scattered sample data
f=@(p)griddata(x,y,z,p(1),p(2),’v4’); x=fminunc(f,[0,0])
[x0,y0]=meshgrid(-3:0.1:2,-2:0.1:2);
z0=(x0.^2-2*x0).*exp(-x0.^2-y0.^2-x0.*y0); contour(x0,y0,z0,30)

Data Interpolation and Functional Approximation Problems
393
X= 0.6
Y= −0.3
Level= −0.64124
−3
−2.5
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
−2
−1.5
−1
−0.5
0
0.5
1
1.5
2
FIGURE 8.14: Contour plots with the solutions.
8.1.6
High-dimensional data interpolations
Three-dimensional mesh grid can also be generated with the previously discussed
function meshgrid(), with [x,y,z] = meshgrid(x1,y1,z1), where x1, y1, z1 are the
necessary segmentation vectors. The returned arguments x, y, z are in three-dimensional
arrays, in grid format.
The n-dimensional grid data can be generated with the function ndgrid(), and the
syntax of the function is [x1,· · · ,xn] = ndgrid(v1,· · · ,vn), where v1, · · · , vn are the
segmentation of the n-dimensional data, which are given in vectors. The returned argument
x1, · · · , xn are the n-dimensional arrays in grid format.
It should be noted that the data structures generated by functions ndgrid()
and meshgrid() are diﬀerent. Function meshgrid() can only be used in two- and
three-dimensional data generation, while ndgrid() can be used in the generation of
higher-dimensional data. For two-dimensional data, the mesh grid data generated by
[x,y] = meshgrid(· · ·) and [x1,y1] = ndgrid(· · ·) satisfy x = xT
1 , and y = yT
1 , while in
three-dimensional data generations, the data generated by [x,y,z] = meshgrid(· · ·) and
[x1,y1,z1] = ndgrid(· · ·) have the same z and z1, and x(:,:,i) array is a ﬁxed matrix
for each i. Similar things happen to the arrays xT
1 , y and yT
1 , and besides, x(:,:,i)=
x1(:,:,i)T. A function mesh2nd() can be written to implement conversion between the
two types of grid data.
function [x1,y1,z1,v1]=mesh2nd(x,y,z,v)
if nargin==3, x1=x.’; y1=y.’; z1=z.’;
elseif nargin==4, z1=z;
for i=1:size(x,3), x1(:,:,i)=x(:,:,i).’;
y1(:,:,i)=y(:,:,i).’; v1(:,:,i)=v(:,:,i).’;
end
else, error(’Error in input arguments’), end
For the samples obtained in grid format, the functions interp3() and interpn() can
be used to solve interpolation problems. The syntaxes of these functions are similar to the
interp2() function. If the scattered three-dimensional or n-dimensional data are given, the
functions griddata3() and griddatan() can be used, and these functions are similar to
the griddata() function.
Example 8.11
Consider again the function V (x, y, z) in Example 2.42.

394
Scientiﬁc Computing with MATLAB®
V (x, y, z) =

xx + y(x+y)/2 + z(x+y+z)/3.
Generate a set of data and show the volume visualization representation of the interpolated
data.
Solution Function meshgrid() can be used to generate a set of sparsely distributed sample
data. Function vol visual4d() can be used to compare the original data and interpolated
data, as shown in Figure 8.15. It can be seen that the interpolated data is quite accurate.
>> [x,y,z]=meshgrid(0:0.3:2); [x0 y0 z0]=meshgrid(0:0.1:2);
V=sqrt(x.^x+y.^((x+y)/2)+z.^((x+y+z)/3));
V0=sqrt(x0.^x0+y0.^((x0+y0)/2)+z0.^((x0+y0+z0)/3));
V1=interp3(x,y,z,V,x0,y0,z0,’spline’); vol_visual4d(x0,y0,z0,V1)
FIGURE 8.15: Slice views of the original and interpolation data.
8.2
Spline Interpolation and Numerical Calculus
The Spline Toolbox provided in MATLAB can be used to better solve the interpolation
problems. Moreover, numerical diﬀerentiation and integration problems can be solved easily
using this toolbox. This section can be regarded as an extension to Sections 8.1, 3.8 and
3.9.
Spline functions can be regarded as an eﬀective approximation method. The most widely
used spline functions are the cubic splines and B-splines. The creation of these splines will
be shown in this section, and then, numerical diﬀerentiation and integration can be solved
using the Spline Toolbox.

Data Interpolation and Functional Approximation Problems
395
8.2.1
Spline interpolation in MATLAB
I. Cubic splines and MATLAB solutions
The deﬁnition of cubic spline function is that for n sample points (xi, yi) (i = 1, 2, · · · , n)
where x1 < x2 < · · · < xn, the following three conditions are to be satisﬁed. The function
S(x) is referred to as cubic spline function with n nodes.
(i) S(xi)=yi, (i=1, 2, · · · , n), i.e., the curve passes through all the samples.
(ii) In each interval [xi, xi+1], S(x) is given as a cubic polynomial
S(x) = ci1(x −xi)3 + ci2(x −xi)2 + ci3(x −xi) + ci4.
(8-2-1)
(iii) S′(x) and S′′(x) are continuous in the interval [x1, xn].
A cubic spline object can be established with the function csapi() provided in the Spline
Toolbox. The syntax of the function is simply S = csapi(x,y), where x = [x1, x2, · · · , xn],
y = [y1, y2, · · · , yn] are the sample points. Therefore, the returned argument S is a cubic
spline object, whose ﬁelds include the sub-intervals, cubic function coeﬃcients of each
piecewise cubic function.
The interpolation curves can be drawn with the function fnplt(). For given independent
variable vector xp, the interpolation results can be evaluated from the function fnval() with
the syntax fnplt(S), yp = fnval(S,xp), where the vector yp contains the interpolation
results for the given vector xp.
Example 8.12 Compute the cubic spline interpolation results for the sparsely distributed
sample points in Example 8.6.
Solution The cubic spline interpolation can be obtained and compared with the theoretical
data as shown in Figure 8.16.
0
0.5
1
1.5
2
2.5
3
0
0.2
0.4
0.6
0.8
1
FIGURE 8.16: Interpolation with cubic splines.
>> x0=[0,0.4,1 2,pi]; y0=sin(x0); sp=csapi(x0,y0), fnplt(sp,’:’);
hold on, ezplot(’sin(t)’,[0,pi]); plot(x0,y0,’o’); sp.coefs
The coeﬃcients of the piecewise polynomials are given in Table 8.1. For instance, in the
interval (0.4, 1), the interpolation polynomial can be expressed as
S2(x) = −0.1627(x −0.4)3 −0.1876(x −0.4)2 + 0.9245(x −0.4) + 0.3894.

396
Scientiﬁc Computing with MATLAB®
TABLE 8.1: The coeﬃcients of the piecewise cubic functions.
interval
c0
c1
c2
c3
(0, 0.4)
−0.16265031
0.007585654
0.99653564
0
(0.4, 1)
−0.16265031
−0.18759472
0.92453202
0.38941834
(1, 2)
0.024435717
−0.48036529
0.52375601
0.84147098
(2, π)
0.024435717
−0.40705814
−0.36366741
0.90929743
Example 8.13
Interpolate the data given in Example 8.1 using cubic splines.
Solution The following statements can be used to establish a cubic spline object-based on
the given data. The obtained piecewise cubic function coeﬃcients are shown in Table 8.2.
The cubic spline object can then be used in the interpolation method.
>> x=0:.12:1; y=(x.^2-3*x+5).*exp(-5*x).*sin(x); % generate samples
sp=csapi(x,y); fnplt(sp), sp.breaks, sp.coefs % build a spline object
TABLE 8.2: Coeﬃcients of piecewise cubic spline interpolation.
piecewise
coeﬃcients of cubic polynomials
piecewise
coeﬃcients of cubic polynomials
interval
c1
c2
c3
c4
interval
c1
c2
c3
c4
(0, 0.12)
24.7396
−19.359
4.5151
0
(0.48, 0.6)
−0.2404
0.7652
−0.5776
0.1588
(0.12, 0.24)
24.7396
−10.4526
0.9377
0.3058
(0.6, 0.72)
−0.4774
0.6787
−0.4043
0.1001
(0.24, 0.36)
4.5071
−1.5463
−0.5022
0.3105
(0.72, 0.84)
−0.4559
0.5068
−0.2621
0.0605
(0.36, 0.48)
1.9139
0.07623
−0.6786
0.2358
(0.84, 0.96)
−0.4559
0.3427
−0.1601
0.03557
The function csapi() can be used to establish the cubic spline object for multivariate
data in the grid format, with S = csapi({x1,x2,· · · ,xn},z), where the variables xi and
z are the grid points, and the cubic spline object is returned in S.
Example 8.14
Interpolate the grid data in Example 8.8 with cubic splines and draw the
interpolation surface.
Solution The following statements can be used to establish the cubic spline object sp. The
surface obtained is shown in Figure 8.17, which is the same as the one obtained with the
interp2() function.
>> x0=-3:.6:3; y0=-2:.4:2; [x,y]=ndgrid(x0,y0);
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y); sp=csapi({x0,y0},z); fnplt(sp);
It should be noted that the matrices x and y are obtained with ndgrid() rather than
meshgrid(). Be careful that the arrangement of the matrices is diﬀerent in this example.

Data Interpolation and Functional Approximation Problems
397
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
FIGURE 8.17: Interpolation results of two-dimensional function.
II. B-spline and its MATLAB functions
B-spline is another type of commonly used splines. Suppose the interested interval (a, b)
is divided into several intervals, a = t0 < t1 < t2 < · · · < tm = b, where ti is referred to as
a knot, the piecewise approximate function can be written as
F(t) =
m

i=0
piBi,k(t),
(8-2-2)
where pi are the coeﬃcients, k is the order, with k ⩽m. Bi,k(x) is the kth order B-spline
basis, which can be computed recursively with
Bi,0(t) =

1,
if ti < t < ti+1
0,
otherwise,
(8-2-3)
and for j = 1, 2, · · · , k, i = 0, 1, 2, · · · , m
Bi,j(t) =
t −ti
ti+j −ti
Bi,j−1(t) +
ti+j+1 −t
ti+j+1 −ti+1
Bi+1,j−1(t).
(8-2-4)
The function spapi() for deﬁning the B-spline object is introduced. If the samples are
given in vectors x and y, the following statements can be used to deﬁne a B-spline object
S with the syntax S = spapi(k,x,y), where k is the order of B-spline. It can be seen that
kth order B-spline is essentially kth order piecewise polynomials. Normally one may select
k = 4 or 5 to ensure good interpolation results. For speciﬁc problems, a suitable increase in
k may improve the quality of interpolation results.
Example 8.15
Interpolate the functions given in Examples 8.12 and 8.13 with B-splines.
Compare with the results obtained using cubic splines.
Solution
For the Example 8.12, the following statements can be used to interpolate the
data with the results shown in Figure 8.18 (a). It can be seen that one can hardly distinguish
the interpolation curve from the theoretical one.
>> x0=[0,0.4,1 2,pi]; y0=sin(x0); ezplot(’sin(t)’,[0,pi]); hold on
sp1=csapi(x0,y0); fnplt(sp1,’--’); % cubic spline interpolation
sp2=spapi(5,x0,y0); fnplt(sp2,’:’) % B-spline with order k = 5
From the above observations, the B-spline interpolation is far better than the cubic spline
for this example. For the data in Example 8.13, the B-spline interpolation results are shown

398
Scientiﬁc Computing with MATLAB®
in Figure 8.18 (b). Again, here, the B-spline interpolation is much better than the cubic
spline interpolation. In practical applications, if k selected is too large, a suitable one will
be assigned instead. Please try an order of 100, and see what happens.
0
0.5
1
1.5
2
2.5
3
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
(a) data interpolation for Example 8.12
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
(b) data interpolation for Example 8.13
FIGURE 8.18: The interpolation curves with spline interpolations.
>> x=0:.12:1; y=(x.^2-3*x+5).*exp(-5*x).*sin(x); % generate samples
ezplot(’(x^2-3*x+5)*exp(-5*x)*sin(x)’,[0,1]), hold on % draw curve
sp1=csapi(x,y); fnplt(sp1,’--’); sp2=spapi(5,x,y); fnplt(sp2,’:’)
8.2.2
Numerical diﬀerentiation and integration with splines
It has been shown that splines can be used to evaluate numerical integrals and even when
the samples are sparsely distributed, good results can still be obtained. Compared with the
algorithms in Sections 3.8 and 3.9, the spline-based algorithm has its own advantages.
The spline-based integration is deﬁned as F(x) =
 x
x0
f(t) dt, where x0 is the pre-speciﬁed
boundary. Clearly, the deﬁnite integral can be evaluated from I = F(b) −F(a).
I. Numerical diﬀerentiation
The spline function-based numerical diﬀerentiation to the given sample points can be
calculated from the function fnder()
Sd = fnder(S,k)
% kth order derivative of S
Sd = fnder(S,[k1,· · · ,kn])% partial derivatives for multivariate functions
Example 8.16
Consider the sample points in Example 8.13. Compute the numerical
diﬀerentiations to the samples with cubic function or B-spline functions and compare the
results with the theoretical ones.
Solution
From the generated samples, the cubic and B-spline data objects can be
established. Then, the derivatives can be obtained with fnder() function, and the curves
can be shown in Figure 8.19.
>> syms x; f=(x^2-3*x+5)*exp(-5*x)*sin(x); ezplot(diff(f),[0,1]),
hold on, x0=0:.12:1; y0=double(subs(f,x,x0)); % generate samples
sp1=csapi(x0,y0); dsp1=fnder(sp1,1); fnplt(dsp1,’--’) % derivative

Data Interpolation and Functional Approximation Problems
399
sp2=spapi(5,x0,y0); dsp2=fnder(sp2,1); % derivative with B-spline
fnplt(dsp2,’:’); axis([0,1,-0.8,5])
% compare the results
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
−0.5
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
FIGURE 8.19: Numerical diﬀerentiations based on spline interpolations.
From Figure 8.19, many other theoretical curves can also be displayed. It can be seen that
the numerical diﬀerentiations with B-spline is very satisfactory. Piecewise cubic polynomials
may also give very good results. Since the samples are extremely sparsely distributed, the
method in Section 3.8 cannot yield good results.
Example 8.17
Fit the ∂2z/(∂x∂y) surface with the data obtained in Example 8.14.
Compare the surface with the exact results.
Solution
The following statements can be used to generate the data. With the B-spline
ﬁtting, the numerical diﬀerentiation can be evaluated and the surface is then shown in
Figure 8.20 (a).
>> x0=-3:.3:3; y0=-2:.2:2; [x,y]=ndgrid(x0,y0);
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y); % generate samples
sp=spapi({5,5},{x0,y0},z); dspxy=fnder(sp,[1,1]); fnplt(dspxy)
The following statements can be used to evaluate the exact partial derivatives theoretically
and the surface is obtained as shown in Figure 8.20 (b). It can be seen that the results are
almost the same, which indicates that the numerical method is reliable.
>> syms x y; z=(x^2-2*x)*exp(-x^2-y^2-x*y); % original function
ezsurf(diff(diff(z,x),y),[-3 3],[-2 2]) % draw partial derivative surface
II. Numerical integration
The cubic and B-splines can be used to approximate the integrand that is deﬁned by
a given data set. From the spline interpolation, the numerical integration can be obtained.
The method to be introduced here is diﬀerent from the quadspln() function discussed in
Section 8.1.2. The function quadspln() can only be used to evaluate the deﬁnite integral,
while the function fnint() can be used to obtain an approximate integration function. Of
course, it can also be used to evaluate deﬁnite integrals, fi = fnint(S), where fi are vectors
which return the integration at each x point. The indeﬁnite integral can be obtained by
adding a constant to the results. If the deﬁnite integral over the [a, b] interval is required,
we can use I = diff(fnint(S,[a, b])).

400
Scientiﬁc Computing with MATLAB®
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−2
−1
0
1
2
(a) spline interpolation results
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−2
−1
0
1
2
(b) theoretical results
FIGURE 8.20: The second-order partial derivative surface.
Example 8.18 Consider again the sparsely distributed samples in Example 8.5. Compute
the deﬁnite and indeﬁnite integrals using spline interpolations.
Solution
The two spline objects can be established and with the function fnint(), the
integral function can be evaluated and also the deﬁnite integral can be obtained
>> x=[0,0.4,1 2,pi]; y=sin(x); % generate sparsely distributed samples
sp1=csapi(x,y); a=fnint(sp1,1); xx=fnval(a,[0,pi]); p1=xx(2)-xx(1)
sp2=spapi(5,x,y); b=fnint(sp2,1); xx=fnval(b,[0,pi]); p2=xx(2)-xx(1)
and the deﬁnite integrals by the two spline functions are obtained as p1 = 2.01905235, and
p2 = 1.99994177102, respectively. It can be seen that the results with cubic spline are the
same as the results obtained in Example 8.5. With the B-splines, much better results can be
obtained.
The approximate primitive function can also be obtained from sample data. For instance,
the approximate primitive function can be obtained with B-splines and it is displayed together
with the true one as shown in Figure 8.21.
>> ezplot(’-cos(t)+2’,[0,pi]); hold on, fnplt(a,’--’); fnplt(b,’:’)
0
0.5
1
1.5
2
2.5
3
1
1.5
2
2.5
3
FIGURE 8.21: The approximate primitive function from spline interpolation.
It should be noted that fnint() function can only be used to evaluate integral functions
for univariate functions, and for multivariate functions, integral functions can be obtained
with fnder() function, with negative orders.

Data Interpolation and Functional Approximation Problems
401
Example 8.19
Draw the integral surface for the function studied in Example 3.69.
J =
 1
−1
 2
−2
e−x2/2 sin(x2 + y) dx dy.
Solution The B-spline object can be created ﬁrst, and the integral object can be constructed
with fnder() function. The three-dimensional surface of the integral can be evaluated and
the surface can be obtained, which is exactly the same as the one obtained in Example 3.70.
>> x0=-2:0.1:2; y0=-1:0.1:1; [x y]=ndgrid(x0,y0);
z=exp(-x.^2/2).*sin(x.^2+y); S=spapi({5,5},{x0,y0},z);
S1=fnder(S,[-1 -1]); S2=fnval(S1,{x0,y0}); surf(y0,x0,S2)
8.3
Fitting Mathematical Models from Data
The interpolation methods discussed earlier can be used to evaluate the values of
unknown points, however, mathematical expressions cannot be obtained. In practical
applications, mathematical expressions are needed. In this section, some methods, such as
polynomial ﬁtting, multivariate linear regression and least squares nonlinear curve ﬁttings
are presented.
8.3.1
Polynomial ﬁtting
The Lagrange interpolation is a type of polynomial ﬁtting. The objective of the
polynomial ﬁtting is to ﬁnd a set of coeﬃcients ai, i = 1, 2, · · · , n + 1, such that the
polynomial
ϕ(x) = a1xn + a2xn−1 + · · · + anx + an+1
(8-3-1)
can be used to ﬁt the original data in least squares sense. The diﬀerence between the
polynomial ﬁtting and the interpolation is that, in polynomial ﬁtting, the samples are not
necessarily on the ﬁtting curve. A MATLAB function polyfit() can be used to solve
polynomial ﬁtting problems, with the syntax p = polyfit(x,y,n), where the arguments
x and y are the vectors of sample points. The argument n is the selected degree of
polynomial ﬁtting. The returned argument p stores the coeﬃcients of the polynomial in
descending order. The function poly2sym() can be used to convert the results into symbolic
polynomials. Also, the function polyval() can be used to evaluate the values of polynomials.
The following examples illustrate the use of polynomial ﬁtting.
Example 8.20
Consider the sample points in Example 8.1. Solve the polynomial ﬁtting
problems for diﬀerent degrees and ﬁnd a suitable degree.
Solution Using the following statements, the ﬁtting curve is shown in Figure 8.22 (a)
>> x0=0:.1:1; y0=(x0.^2-3*x0+5).*exp(-5*x0).*sin(x0); % generate samples
p3=polyfit(x0,y0,3); vpa(poly2sym(p3),10)
% get third-order polynomial
x=0:.01:1; ya=(x.^2-3*x+5).*exp(-5*x).*sin(x); % generate denser points
y1=polyval(p3,x); plot(x,y1,x,ya,x0,y0,’o’)
% ﬁtting quality
where the cubic function is p3(x) = 2.84x3 −4.7898x2 + 1.9432x + 0.0598. From the ﬁtting
curve, it can be seen that the ﬁtting quality is very poor. Thus, to address the ﬁtting accuracy
problem, it is natural to increase the degree of the polynomial. For diﬀerent degrees such as
4, 5 and 6, the ﬁtting curves can be obtained as shown in Figure 8.22 (b).

402
Scientiﬁc Computing with MATLAB®
>> p4=polyfit(x0,y0,4); y2=polyval(p4,x); p5=polyfit(x0,y0,5);
y3=polyval(p5,x); p6=polyfit(x0,y0,6); y4=polyval(p6,x);
plot(x,ya,x0,y0,’o’,x,y2,x,y3,x,y4) % ﬁtting of diﬀerent polynomials
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
−0.05
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
(a) cubic polynomial ﬁttings
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
(b) the ﬁtting for other polynomials
FIGURE 8.22: Fitting results of polynomials of diﬀerent degrees.
From the ﬁtting results, it can be seen that when n ⩾6, the ﬁtting quality is satisfactory.
The sixth degree polynomial obtained can be obtained from
>> vpa(poly2sym(p6),4) % display 6th degree polynomial
that is, p6(x) = −11.24x6 + 43.44x5 −68.6x4 + 56.46x3 −24.88x2 + 4.828x + 0.0001977.
Polynomial ﬁtting to a given function is in fact related to the Taylor series expansion.
However, to evaluate the Taylor series, it is required that the original function be given. This
is not realistic for many practical problems. For this example, since the original function is
known, the Taylor series can be used to get a truncated polynomial
>> syms x; y=(x^2-3*x+5)*exp(-5*x)*sin(x); P=vpa(taylor(y,’Order’,7),5)
which reads as follows
P = −205.0x6 + 192.2x5 −142.0x4 + 77.67x3 −28.0x2 + 5.0x.
Comparing the results of truncated Taylor series expansion with the polynomial ﬁtting,
it can be seen that the two polynomials are signiﬁcantly diﬀerent. This means that the
polynomial approximation to a given function may not be unique. Although the mathematical
forms of the two polynomials are completely diﬀerent, the ﬁtting curves could be very close
within a speciﬁc interval.
Example 8.21
Consider again the function in Example 8.3. Observe the polynomial
ﬁttings to the original function.
Solution Polynomial ﬁttings are not always accurate. Consider the samples in Example
8.3. Using diﬀerent degrees n, the polynomial ﬁtting can be obtained, with ﬁtting results
shown in Figure 8.23 (a).
>> x0=-1+2*[0:10]/10;y0=1./(1+25*x0.^2); x=-1:.01:1; ya=1./(1+25*x.^2);
p3=polyfit(x0,y0,3); p5=polyfit(x0,y0,5); p8=polyfit(x0,y0,8);
y1=polyval(p3,x); y2=polyval(p5,x); y3=polyval(p8,x);
p10=polyfit(x0,y0,10); y4=polyval(p10,x);
% diﬀerent orders
plot(x,ya,x,y1,x,y2,’-.’,x,y3,’--’,x,y4,’:’) % ﬁtting comparisons

Data Interpolation and Functional Approximation Problems
403
In fact, truncated Taylor series expansion to this function is even poorer. The following
statements can be used to ﬁnd the Taylor series for the original function, and the ﬁtting is
shown in Figure 8.23 (b). It can be seen that the Taylor series ﬁtting is erroneous for the
example, and the polynomial obtained is p(x) = 1 −25x2 + 625x4 −15625x6 + 390625x8.
>> syms x; y=1/(1+25*x^2); p=taylor(y,x,’Order’,10), ezplot(p,[-1,1])
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−0.5
0
0.5
1
1.5
2
(a) ﬁtting of derivatives
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
0
0.5
1
1.5
2
2.5
x 10
5
(b) truncated Taylor series expansion
FIGURE 8.23: Polynomial ﬁtting and the truncated Taylor series.
8.3.2
Curve ﬁtting by linear combination of basis functions
Assume that the original function is composed of linear combination of a set of known
basis functions f1(x), f2(x), · · · , fn(x)
g(x) = c1f1(x) + c2f2(x) + c3f3(x) + · · · + cnfn(x),
(8-3-2)
where c1, c2, · · · , cn are undetermined constants. The measured data points obtained are
(x1, y1), (x2, y2), · · · , (xM, yM). The following linear equations can be established
Ac = y,
(8-3-3)
where
A =
⎡
⎢⎢⎢⎣
f1(x1)
f2(x1)
· · ·
fn(x1)
f1(x2)
f2(x2)
· · ·
fn(x2)
...
...
...
...
f1(xM)
f2(xM)
· · ·
fn(xM)
⎤
⎥⎥⎥⎦,
y =
⎡
⎢⎢⎢⎣
y1
y2
...
yM
⎤
⎥⎥⎥⎦,
(8-3-4)
and c = [c1, c2, · · · , cn]T. The least squares solution of the problem is c = A\y.
Example 8.22 The measured data points (xi, yi) are given in Table 8.3. Assume that the
original function is given in the form
y(x) = c1 + c2e−3x + c3 cos(−2x)e−4x + c4x2.
Compute the undetermined constants ci with least squares method.
Solution The undetermined constants ci can be obtained from the following:

404
Scientiﬁc Computing with MATLAB®
TABLE 8.3: Measured data.
xi
0
0.2
0.4
0.7
0.9
0.92
0.99
1.2
1.4
1.48
1.5
yi
2.88
2.2576
1.9683
1.9258
2.0862
2.109
2.1979
2.5409
2.9627
3.155
3.2052
>> x=[0,0.2,0.4,0.7,0.9,0.92,0.99,1.2,1.4,1.48,1.5]’;
y=[2.88;2.2576;1.9683;1.9258;2.0862;2.109;2.1979;2.5409;...
2.9627;3.155;3.2052];
% input the given samples
A=[ones(size(x)) exp(-3*x), cos(-2*x).*exp(-4*x) x.^2];
c=A\y; c1=c’, x0=[0:0.01:1.5]’; % ﬁnd least squares solution
A1=[ones(size(x0)),exp(-3*x0),cos(-2*x0).*exp(-4*x0),x0.^2];
y1=A1*c; plot(x0,y1,x,y,’x’)
% ﬁtting results
and the result is cT = [1.2200208134, 2.33972067466, −0.6797329188, 0.8699983522]. The
ﬁtting curve is shown in Figure 8.24 with the given samples. It can be seen that the ﬁtting
is successful.
0
0.5
1
1.5
1.8
2
2.2
2.4
2.6
2.8
3
3.2
3.4
3.6
FIGURE 8.24: Original data and the ﬁtting curve.
Example 8.23
Given the measured data in Table 8.4, ﬁnd a ﬁtting function.
TABLE 8.4: Measured data.
xi
1.1052
1.2214
1.3499
1.4918
1.6487
1.8221
2.0138
2.2255
2.4596
2.7183
3.6693
yi
0.6795
0.6006
0.5309
0.4693
0.4148
0.3666
0.3241
0.2865
0.2532
0.2238
0.1546
Solution The measured data can be shown in Figure 8.25 (a).
>> x=[1.1052,1.2214,1.3499,1.4918,1.6487,1.8221,2.0138,...
2.2255,2.4596,2.7183,3.6693];
y=[0.6795,0.6006,0.5309,0.4693,0.4148,0.3666,0.3241,...
0.2864,0.2532,0.2238,0.1546];
% input the given samples
plot(x,y,x,y,’*’) % direct plot, nothing special observed from plots
By inspection, it is hard to determine a possible form of the ﬁtting function. One

Data Interpolation and Functional Approximation Problems
405
may perform a nonlinear transformation to the original data, and see whether they can
be described by linear functions. For instance, the logarithmic transformation to both x, y
can be attempted as shown in Figure 8.25 (b), and it can be observed that it is linear.
>> x1=log(x); y1=log(y);
plot(x1,y1,x1,y1,’*’) % logarithmic ﬁtting
1
1.5
2
2.5
3
3.5
4
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
(a) original data
0
0.2
0.4
0.6
0.8
1
1.2
1.4
−2
−1.8
−1.6
−1.4
−1.2
−1
−0.8
−0.6
−0.4
−0.2
(b) ﬁtting of logarithmic transformed data
FIGURE 8.25: Original data and ﬁtting results for the transformed data.
The linear ﬁtting function can be tested where ln y = a ln x + b, i.e., y = ebxa. The
coeﬃcients a, b and eb can be obtained with the following statements
>> A=[x1’ ones(size(x1’))]; c=[A\y1’]’, d=exp(c(2)) % ﬁtting parameters
then, c = [−1.23389448522593, −0.26303708610220]T, eb = 0.76871338819924. The ﬁtting
function is then y(x) = 0.76871338819924x−1.23389448522593.
Example 8.24
Polynomial ﬁtting can be regarded as a special example of the linear
combination of basis function ﬁttings. In this case, the basis functions can be written as
fi(x) = xn+1−i, i = 1, 2, · · · , n + 1. Solve the polynomial ﬁtting problem in Example 8.20
and observe the ﬁtting results.
Solution From the above algorithm, the sample data can be generated and the polynomial
ﬁtting can be performed which yields exactly the same results as in Example 8.20.
>> x=[0:.1:1]’; y=(x.^2-3*x+5).*exp(-5*x).*sin(x); n=6; A=[];
for i=1:n+1, A(:,i)=x.^(n+1-i); end, c=A\y % least squares solution
which means that the polynomial is
p6(x) = −11.24x6 + 43.44x5 −68.60x4 + 56.46x3 −24.88x2 −4.8x + 0.0002.
8.3.3
Least squares curve ﬁtting
Given a set of data xi, yi, i = 1, 2, · · · , N, and given the original function, referred to as
the prototype function, ˆy(x) = f(a, x), where a is the vector of undetermined constants, the
objective of the least squares approximation is to ﬁnd the undetermined constants which
minimize the objective function
J = min
a
N

i=1
[yi −ˆy(xi)]2 = min
a
N

i=1
[yi −f(a, xi)]2.
(8-3-5)

406
Scientiﬁc Computing with MATLAB®
The lsqcurvefit() function provided in the Optimization Toolbox can be used
to solve the least squares curve ﬁtting problems. The syntax of the function is
[a,Jm] = lsqcurvefit(fun,a0,x,y,am,aM,opts), where fun is the MATLAB descrip-
tion to the prototype function. It can either be an M-function, an anonymous or an inline
function. The argument a0 is a vector containing the initial guess of a. The vectors x and
y store respectively the input and output data. The undetermined constants are returned
in the a vector, and the objective function is in Jm.
Example 8.25
The sample data set is generated with the following statements
>> x=0:.1:10; y=0.12*exp(-0.213*x)+0.54*exp(-0.17*x).*sin(1.23*x);
and assume that the prototype function satisﬁes y(x) = a1e−a2x + a3e−a4x sin(a5x), where
ai are the undetermined constants. The least squares curve ﬁtting algorithm can be used
to ﬁnd the coeﬃcients. Compute the coeﬃcients which minimize the objective function.
Solution The prototype function can ﬁrst be expressed by an anonymous function, then,
the following statements can be used to evaluate the undetermined constants
>> f=@(a,x)a(1)*exp(-a(2)*x)+a(3)*exp(-a(4)*x).*sin(a(5)*x); % prototype
[a,res]=lsqcurvefit(f,[1,1,1,1,1],x,y) % least squares ﬁtting
x1=0:0.02:10; y1=f(a,x1); plot(x1,y1,x,y,’o’) % ﬁtting results
and the estimated vector a = [0.1200, 0.2130, 0.5400, 0.1700, 1.2300]T, with the minimized
objective function 1.7927×10−16. It can be seen that the ﬁtting results are extremely accurate.
The sample points and the ﬁtting curves are shown in Figure 8.26.
0
1
2
3
4
5
6
7
8
9
10
−0.3
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5
0.6
FIGURE 8.26: Comparisons of ﬁtting results.
Example 8.26
The measured data points are given in Table 8.5, and also the prototype
function is known to be y(x) = ax + bx2e−cx + d. Compute using least squares method the
undetermined constants a, b, c, d.
TABLE 8.5: Measured data.
xi
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
yi
2.3201
2.6470
2.9707
3.2885
3.6008
3.9090
4.2147
4.5191
4.8232
5.1275
Solution The following statements can be entered in MATLAB workspace

Data Interpolation and Functional Approximation Problems
407
>> x=0.1:0.1:1; % generate samples
y=[2.3201,2.6470,2.9707,3.2885,3.6008,3.9090,...
4.2147,4.5191,4.8232,5.1275];
Let a1 = a, a2 = b, a3 = c, a4 = d, the prototype function can be rewritten as
y(x) = a1x + a2x2e−a3x + a4.
Thus, an anonymous function can be written for the prototype function, and the following
statement can be used to evaluate the coeﬃcients
>> f=@(a,x)a(1)*x+a(2)*x.^2 .*exp(-a(3)*x)+a(4); % prototype function
a=lsqcurvefit(f,[1;2;2;3],x,y), y1=f(a,x); plot(x,y,x,y1,’o’)
with a = [3.1001, 1.5027, 4.0046, 2.0000]T. Change the initial search point to x0 = [1, 0, 0, 0],
>> a=lsqcurvefit(f,[1;0;0;0],x,y), y1=f(a,x); plot(x,y,x,y1,’o’)
a
=
[3.0746, 0.0000, −15.5811, 2.0513]T. If initial point is x0
=
[1, 0, 0, 1]T, a
=
[3.0826, 0.0000, −11.2685, 2.0462]T. It can be seen that for this example, the ﬁtting model
is not unique, however, they all give good ﬁtting results. The sample points and the ﬁtted
curve are shown in Figure 8.27, and it can be seen that the ﬁtting is satisfactory.
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
2
2.5
3
3.5
4
4.5
5
5.5
FIGURE 8.27: Comparison of ﬁtting results.
8.3.4
Least squares ﬁtting of multivariate functions
If a function has several independent variables, with a prototype function
z = f(a, x),
function lsqcurvefit() can still be used in ﬁtting the function to ﬁnd the vector a, where
a = [a1, a2, · · · , an], x = [x1, x2, · · · , xm]. The prototype function should be described
by M-functions or anonymous functions, and the function lsqcurvefit() can be used to
evaluate the undetermined constant vector a. In describing the xi variable in the objective
function, the whole column should be extracted with x(:,i).
Example 8.27
Assume that the prototype function is given by
v = a1xa2x + a3ya4(x+y) + a5za6(x+y+z),
where, there are three independent variables. If the data are given in the data ﬁle

408
Scientiﬁc Computing with MATLAB®
c8data1.dat, where the ﬁrst three columns are the independent variables x, y, z, and the
4th column is the output variable v, please ﬁnd the undetermined constants ai using least
squares method.
Solution To solve the problem, a vector form of the independent variables is described in
x, with x1 = x, x2 = y, x3 = z, and prototype function is rewritten as
v = a1xa2x1
1
+ a3xa4(x1+x2)
2
+ a5xa6(x1+x2+x3)
3
,
and it can be described by an anonymous function. Also, since the data is given in a data
ﬁle, function load() can be used to input the data into MATLAB workspace. Sub-matrix
extraction approach can be used to create matrix X and vector v, so that the undetermined
constants a = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6] can be found with the following statements, to
minimize the sum of squared errors, to 1.0904×10−7. In fact, the original data were generated
by the function with a = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6], and it can be seen that the undetermined
constants obtained are accurate.
>> f=@(a,x)a(1)*x(:,1).^(a(2)*x(:,1))+...
a(3)*x(:,2).^(a(4)*(x(:,1)+x(:,2)))+...
a(5)*x(:,3).^(a(6)*(x(:,1)+x(:,2)+x(:,3)));
XX=load(’c8data1.dat’); X=XX(:,1:3); v=XX(:,4);
a0=[2 3 2 1 2 3]; [a,f,err,key]=lsqcurvefit(f,a0,X,v)
8.4
Rational Function Approximations
8.4.1
Approximation by continued fraction expansions
Continued fraction is often regarded as an eﬀective way in approximating certain
functions. The typical form of a continued fraction expansion to a given function f(x)
can be expressed by
f(x) = b1 +
(x −a)c1
b2 +
(x −a)c2
b3 +
(x −a)c3
b4 +
(x −a)c4
b5 + (x −a)c5
· · ·
,
(8-4-1)
where, bi are constants, ci are rational numbers and a is the reference point for continued
fraction expansion.
There is no continued fraction expansion functions provided in MATLAB, while low-level
support of MuPAD has a set of functions. Therefore, an interface contfrac() is written to
directly ﬁnd the continued fraction expansion of a given function, with the syntaxes
cf = contfrac(f,n),
[cf ,r] = contfrac(f,n,a)
where, f is the symbolic expression of the original function, a is the reference point (with a
default value of 0), n is the expected level of the expansion. The returned variable cf is the
expansion of MuPAD expression. The returned variable r is the rational approximation of
the function. If f is a constant, the returned variable is returned in cf . The listing of the
function is as follows

Data Interpolation and Functional Approximation Problems
409
function [cf,r]=contfrac(f,varargin)
[n,a]=default_vals({6,0},varargin{:});
if isanumber(f), cf=feval(symengine,’contfrac’,f,n);
p1=char(cf); k=strfind(p1,’,’); k1=strfind(p1,’/’);
if nargout>1, r=sym(p1(k(end)+1:k1-1))/sym(p1(k1+1:end-1)); end
else, if isfinite(a), str=num2str(a); else, str=’infinity’; end
cf=feval(symengine,’contfrac’,f,[’x=’ str],n);
if nargout>1, r=feval(symengine,’contfrac::rational’,cf); end
end
A supporting function isanumber() is written below, and it is used to detect whether
a is a number, either in double-precision or symbolic forms
function key=isanumber(a) % returns 1 if argument is a number
key=0; if length(a)~=1, return; end
switch class(a)
case ’double’, key=1;
% if a double precision number
case ’sym’, try, double(a); key=1; catch, end % or a symbolic number
end
Example 8.28 Let us ﬁrst observe the continued fraction expansion-based approximation
to a constant. The irrational number π can be approximated with a 20-level continued
fraction. Find a suitable degree such that good approximation can be obtained.
Solution The 20-level continued fractions to π can be directly obtained with
>> [cf,r]=contfrac(pi,20), latex(cf) % write continued fraction of π
The returned variable cf is a continued fraction object with coeﬃcient vector
c = [3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2],
and the irrational number π is approximated as 14885392687/4738167652, (with accurate
20 decimal digits). From the coeﬃcient vector, the continued fraction of π can be written as
π ≈3 +
1
7 +
1
15 +
1
1 +
1
292 +
1
1 +
1
1 +
1
1 +
1
2 +
1
1 +
1
3 +
1
1 +
1
14 +
1
2 +
1
1 +
1
1 +
1
2 + · · ·
.

410
Scientiﬁc Computing with MATLAB®
It can be seen from the continuous fraction expression that, the value of 292 is relatively
large compared with other entities, so that the roundoﬀerror can be very accurate, if the
rational expansion is rounded up to this level, with 103993/33102 ≈3.141592653012. If the
digit 20 in the command is substituted to other digits, the ﬁtting results and accuracies are
given in Table 8.6, such that continued fractions yield accurate approximation.
TABLE 8.6: Approximation of π, with diﬀerent levels of continued fractions.
level
rational
approximations
0
π
3.14159265358979323846
8, 9
103993/33102
3.141592653
10
208341/66317
3.1415926535
11
312689/99532
3.1415926536
12
1146408/364913
3.14159265359
13, 14
5419351/1725033
3.14159265358981
15
80143857/25510582
3.1415926535897926
16
165707065/52746197
3.1415926535897934
17
411557987/131002976
3.14159265358979326
18
1068966896/340262731
3.141592653589793235
19
6167950454/1963319607
3.14159265358979323838
20
14885392687/4738167652
3.14159265358979323849
If command [cf ,r] = contfrac(pi,120) is given, the rational approximation of π is
expressed as
π ≈1244969988745789040106366155256015114976454553337906033890313
396286255419907262612262286579004636343912658949984351074158 .
To assess the accuracy of the above rational approximation, the following command can
be given, and the accuracy is around 2.975×10−120.
>> 10^log10(abs(vpa(sym([’124496998874578904010636615525601511497645455’,...
’3337906033890313/39628625541990726261226228657900463634391265894’,...
’9984351074158-pi’]),200))) % estimate the error, thanks John D’Errico
Example 8.29
Establish the ﬁrst 10 levels of continued fractions for the function f(x) =
e−x sin x/(x + 1)3 and obtain the rational approximation.
Solution The ﬁrst 10 levels of continued fractions can be obtained with
>> syms x; f=sin(x)*exp(-x)/(x+1)^3; [cf,r]=contfrac(f,10)
and the continued fraction cf can be written as
f(x) ≈
x
1 +
x
1
4 +
x
−12
5 +
x
−25
43 +
x
7396
1685 +
x
2839225
4863128 +
x
−44767468256
2592461805 + · · ·
,

Data Interpolation and Functional Approximation Problems
411
and the rational approximation r can be written as
r(x) =
−170455846739x5 + 472453225650x4 + 3615529382220x3
−20275122684600x2 + 28175852788020x
2071713977216x5 + 14187032489655x4 + 58214153847990x3
+110354057230620x2 + 92428288467480x + 28175852788020
.
The curves of the original function f(x) and its rational approximation r(x) in the
interval [0, 2] are shown in Figure 8.28 (a). It can be seen that the ﬁtting is very satisfactory,
in fact, the two curves cannot be distinguished from the ﬁgure, unless a series of zooming
actions are made.
>> ezplot(f,[0,2]); hold on; ezplot(r,[0,2]) % compare the two functions
If the interval is increased to (0, 5), the ﬁtting results shown in Figure 8.28 (b) suggest
that more levels are needed to improve the ﬁtting quality.
>> ezplot(f,[0,5]), hold on; ezplot(r,[0,5]) % compare over lager interval
0
0.5
1
1.5
2
0
0.02
0.04
0.06
0.08
0.1
(a) ﬁtting results in (0, 2) interval
0
1
2
3
4
5
0
0.02
0.04
0.06
0.08
0.1
(b) ﬁtting of the enlarged region
FIGURE 8.28: Comparison of continued fraction expansion approximation.
Alternatively, the center point of expansion can be shifted to the right, for instance, let
x = 0.9, and increase the level number to 11, the new continued fraction expansion can be
obtained with the following statements and the ﬁtting result is shown in Figure 8.29. It can
be seen that there is no diﬀerence visible between the two curves.
>> [cf,r1]=contfrac(f,11,0.9) % compute the continued fraction expansion
ezplot(f,[0,5]), hold on, ezplot(r1,[0,5]) % compare the two functions
The approximated rational expression can be written manually as
r1(x) ≈
3.11x5 −49.44x4 + 309.9x3 −892.75x2 + 976.28x + 0.000806
48.34x5 + 264.81x4 + 1420.84x3 + 3247.73x2 + 3012.28x + 976.29.
The continued fraction expansion can be written as
f(x) ≈0.04643 +
x −0.9
−12.0628 +
x −0.9
−0.1239 +
x −0.9
11.3557 +
x −0.9
0.07631 +
x −0.9
44.90233 + · · ·
,

412
Scientiﬁc Computing with MATLAB®
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.01
0.02
0.03
0.04
0.05
0.06
0.07
0.08
0.09
0.1
FIGURE 8.29: Improved continued fraction approximation over [0, 5].
It should be noted that, in this example, the center point should not exceed x = 1. Also,
the coeﬃcients in the rational approximation are not sensitive. If the above ﬁnite digit
approximation is used, the ﬁtting quality is still satisfactory.
>> r2=(3.11*x^5-49.44*x^4+309.9*x^3-892.75*x^2+976.28*x+0.000806)/...
(48.34*x^5+264.81*x^4+1420.84*x^3+3247.73*x^2+3012.28*x+976.29);
ezplot(r2,[0,5])
8.4.2
Pad´e rational approximations
Assume that the power series expansion of a given function f(s) is
f(s) = c1 + c2s + c3s2 + c4s3 + · · · =
∞

i=1
cisi−1,
(8-4-2)
and assume that the r/mth degree Pad´e approximation is expressed by
Gr
m(s) =
βr+1sr + βrsr−1 + · · · + β1
αm+1sm + αmsm−1 + · · · + α1
=
r+1

i=1
βisi−1
m+1

i=1
αisi−1
,
(8-4-3)
where α1 = 1, β1 = c1. Let
∞

i=1
cisi−1 = Gr
m(s). The following equation can be obtained:
m+1

i=1
αisi−1
∞

i=1
cisi−1 =
r+1

i=1
βisi−1.
(8-4-4)
Equating the terms with the same power of s, the coeﬃcients αi, i = 2, · · · , m + 1 and
βi, i = 2, · · · , k + 1 can be obtained from
W x = w,
v = V y,
(8-4-5)

Data Interpolation and Functional Approximation Problems
413
where
x = [α2, α3, · · · , αm+1]T,
w = [−cr+2, −cr+3, · · · , −cm+r+1]T
v = [β2 −c2, β3 −c3, · · · , βr+1 −cr+1]T,
y = [α2, α3, · · · , αr+1]T,
(8-4-6)
and
W =
⎡
⎢⎢⎢⎣
cr+1
cr
· · ·
0
· · ·
0
cr+2
cr+1
· · ·
c1
· · ·
0
...
...
· · ·
...
...
...
cr+m
cr+m−1
· · ·
cm−1
· · ·
cr+1
⎤
⎥⎥⎥⎦,
(8-4-7)
V =
⎡
⎢⎢⎢⎣
c1
0
0
· · ·
0
c2
c1
0
· · ·
0
...
...
...
...
...
cr
cr−1
cr−2
· · ·
c1
⎤
⎥⎥⎥⎦.
(8-4-8)
It can be shown [4] that, if the degree of numerator is one less than that of the
denominator, the Pad´e approximation is equivalent to the Cauer II form of the continued
fraction expansion. A MATLAB function padefcn() can be prepared to compute the Pad´e
rational approximation to a given f(x) function. The function is
function [nP,dP]=padefcn(c,r,m)
w=-c(r+2:m+r+1)’; vv=[c(r+1:-1:1)’; zeros(m-1-r,1)];
W=rot90(hankel(c(m+r:-1:r+1),vv)); V=rot90(hankel(c(r:-1:1)));
x=[1 (W\w)’]; y=[1 x(2:r+1)*V’+c(2:r+1)];
dP=x(m+1:-1:1)/x(m+1); nP=y(r+1:-1:1)/x(m+1);
Example 8.30
Find the rational approximation to the function f(x) = e−2x.
Solution Let us select the degree of the numerator as 0, and select diﬀerent degrees for the
denominator. The Pad´e rational approximation can be obtained by the following MATLAB
scripts, and the ﬁtting results are given in Figure 8.30.
>> syms x; c=taylor(exp(-2*x),’Order’,10); c=sym2poly(c);
c=c(end:-1:1); x=0:0.01:8; nd=[3:7]; plot(x,exp(-2*x));
for i=1:length(nd) % try diﬀerent orders
[n,d]=padefcn(c,0,nd(i)); y=polyval(n,x)./polyval(d,x); line(x,y)
end
It can be seen from Figure 8.30 that third-degree Pad´e approximation gives a reasonably
good ﬁtting. If the degree is increased, the quality of ﬁtting may also increase. The eighth-
degree ﬁtting to the original function is actually very satisfactory, with
P8(s) =
157.5
x8 + 4x7 + 14x6 + 42x5 + 105x4 + 210x3 + 315x2 + 315x + 157.5.
Based on the above algorithm, the symbolic version of the padefcn() functions can be
rewritten as
function G=padefcnsym(f,r,m)
c=taylor(f,’Order’,r+m+1); c=polycoef(c); c=c(end:-1:1);
w=-c(r+2:m+r+1)’; vv=[c(r+1:-1:1)’; zeros(m-1-r,1)];

414
Scientiﬁc Computing with MATLAB®
0
1
2
3
4
5
6
7
8
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
FIGURE 8.30: Original curve and ﬁtting curves.
W=rot90(hankel(c(m+r:-1:r+1),vv)); V=rot90(hankel(c(r:-1:1)));
X=[1 (W\w)’]; y=[1 X(2:r+1)*V’+c(2:r+1)]; dP=X(m+1:-1:1)/X(m+1);
nP=y(r+1:-1:1)/X(m+1); syms x; G=poly2sym(nP,x)/poly2sym(dP,x);
Example 8.31
Solve the Pad´e approximation problem in Example 8.30 with symbolic
computation.
Solution The Pad´e approximation can be obtained with
>> syms x; f=exp(-2*x); G=padefcnsym(f,0,8) % symbolic computations
The Pad´e approximation is given below, and it can be seen that the rational approxima-
tion is exactly the same as the one obtained in the previous example.
G(x) =
315
2 (x8 + 4x7 + 14x6 + 42x5 + 105x4 + 210x3 + 315x2 + 315x + 315/2).
8.4.3
Special approximation polynomials
Apart from the Pad´e approximation functions, many polynomials, such as Legendre,
Chebyshev, Laguerre and Hermite polynomials can be used in function approximation. The
polynomials are deﬁned as
(i) Legendre polynomials, whose mathematical descriptions are
Pn(x) =
1
2n−1 (n −1)!
dn−1
dxn−1 (x2 −1)n−1, n = 1, 2, 3, · · · .
(8-4-9)
The polynomials can be constructed recursively for n = 2, 3, · · · with
P1(x) = 1, P2(x) = x, Pn+1(x) = 2n −1
n
xPn(x) −n −1
n
Pn−1(x).
(8-4-10)
(ii) Chebyshev polynomials, with mathematical form of
Tn(x) = cos

(n −1) arc cosx

, with |x| ⩽1, n = 1, 2, 3, · · · ,
(8-4-11)
and the recursive implementations are
T1(x) = 1, T2(x) = x, Tn+1 = 2xTn(x) −Tn−1(x), n = 2, 3, · · · .
(8-4-12)

Data Interpolation and Functional Approximation Problems
415
(iii) Laguarre polynomials, whose mathematical form are
Ln(x) =
ex
(n −1)!
dn−1
dxn−1 xn−1e−x, with x ⩾0, n = 1, 2, 3, · · · ,
(8-4-13)
and the recursive formula for n = 2, 3, · · · are
L1(x) = 1, L2(x) = 1 −x, Ln+1(x) = 2n −1 −x
n
Ln(x) −n −1
n
Ln−1(x).
(8-4-14)
(iv) Hermite polynomials, with mathematical form
Hn(x) = (−1)n−1ex2 dn−1
dxn−1 e−x2, |x| < ∞, n = 1, 2, 3, · · · ,
(8-4-15)
and the recursive formula for n = 2, 3, · · · are
H1(x) = 1, H2(x) = 2x, Hn+1 = 2xHn(x) −2(n −1)Hn−1(x).
(8-4-16)
These polynomials can be generated with the following MATLAB function, with the
syntax P = fitting poly(type,n,x), where the argument type can be used to indicate
the type of polynomials. The vector of the polynomials is returned in argument P .
function P=fitting_poly(type,N,x)
switch type % handle diﬀerent types of ﬁtting polynomials
case {’P’,’Legendre’}, P=[1,x];
% Legendre polynomials
for n=2:N, P(n+1)=(2*n-1)/n*x*P(n)-(n-1)/n*P(n-1); end
case {’T’,’Chebyshev’}
% Chebyshev polynomials
P=[1,x]; for n=2:N, P(n+1)=2*x*P(n)-P(n-1); end
case {’L’,’Laguerre’}, P=[1,1-x]; % Laguerre polynomials
for n=2:N, P(n+1)=(2*n-1-x)/n*P(n)-(n-1)/n*P(n-1); end
case {’H’,’Hermite’},
% Hermite polynomials
P=[1,2*x]; for n=2:N, P(n+1)=2*x*P(n)-2*(n-1)*P(n-1); end
end
Example 8.32
Please generate the 10th terms of the four polynomials.
Solution With the following function calls, the expected polynomials can easily be obtained,
and the last terms in the vectors are expanded
>> syms x; P=fitting_poly(’P’,10,x); P=expand(P(end))
L=fitting_poly(’L’,10,x); L=expand(L(end))
T=fitting_poly(’T’,10,x); T=expand(T(end))
H=fitting_poly(’H’,10,x); H=expand(H(end))
The 10th terms in the four polynomials can easily be obtained
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
P(x) = 46189x10
256
−109395x8
256
+ 45045x6
128
−15015x4
128
+ 3465x2
256
−63
256,
T (x) = 512x10 −1280x8 + 1120x6 −400x4 + 50x2 −1,
L(x)=
x10
3628800−
x9
36288 + x8
896 −x7
42 + 7x6
24 −21x5
10 + 35x4
4
−20x3+ 45x2
2
−10x+1,
H(x) = 1024x10 −23040x8 + 161280x6 −403200x4 + 302400x2 −30240.

416
Scientiﬁc Computing with MATLAB®
The polynomials can be used as the basis functions so that the least squares methods
can be used in approximating functions. For instance, if Chebyshev polynomials are used,
the prototype function with m terms can be expressed mathematically as
y = f(a, x) = a1T1(x) + a2T2(x) + · · · + amTm(x),
(8-4-17)
and lsqcurvefit() function can be used to ﬁnd the undetermined parameters ai. The
function fitting poly() is not suitable for use in function approximation problems. An
alternative function can be written to describe the prototype function with Chebyshev
polynomials
function y=cheby_poly(a,x) % a and x are both column vectors
a=a(:); x=x(:); n=length(a); X=[ones(size(x)) x]; % the ﬁrst two columns
for i=2:n-1, X(:,i+1)=2*x.*X(:,i)-X(:,i-1); end, y=X*a;
Example 8.33
Consider the polynomial ﬁtting problem studied in Example 8.24. Please
solve the ﬁtting problem with Chebyshev polynomials.
Solution The Chebyshev polynomials ﬁtting can be obtained with the following statements,
and eventually the polynomial can be obtained
>> x0=[0:.1:1]’; y0=(x0.^2-3*x0+5).*exp(-5*x0).*sin(x0); % generate samples
a0=ones(7,1); a=lsqcurvefit(@cheby_poly,a0,x0,y0)
% least squares
syms x; T=fitting_poly(’T’,6,x); P=vpa(expand(T*a),4) % get polynomial
with vector a = [−41.6760, 74.3281, −52.0080, 27.6921, −10.6832, 2.7153, −0.3514]T, while
the polynomial obtained is
P(x) = −11.24x6 + 43.44x5 −68.6x4 + 56.46x3 −24.88x2 + 4.828x + 0.0001975,
which is almost the same as the one obtained in Example 8.24. It should be noted that the
least squares ﬁtting established in this way is essentially optimal polynomial ﬁtting, and the
ﬁtting quality should be similar with polyfit() function results.
8.5
Special Functions and Their Plots
In deﬁnite integral computations, it is often found that some functions cannot be
integrated, for instance the integrand e−x2. Special functions erf(·) can be introduced to
denote the integral. Also, in solving some particular forms of nonlinear ordinary diﬀerential
equations, other special functions are usually deﬁned. In practical applications, a great
amount of special functions are being used, among them, the commonly used ones are
Gamma functions and Beta functions. For diﬀerential equations, Bessel, Legendre, Mittag–
Leﬄer functions are often used. In this section, introductions to these functions are
presented, and their plots are given.
8.5.1
Gamma functions
I. Ordinary Gamma function
Gamma function is the analytical description of the following inﬁnite integral
Γ(α) =
 ∞
0
e−ttα−1 dt.
(8-5-1)

Data Interpolation and Functional Approximation Problems
417
It can be validated through integration by parts that Γ(α+1) = αΓ(α), and Γ(1) = 1. It
can be seen that, if α is a non-negative integer, Γ(α + 1) = α!. Therefore, Gamma function
is an extension of factorials in the real domain. If α is a negative integer, Γ(α + 1) tends
to ±∞. Gamma functions can be evaluated directly with y = gamma(x), where x can be a
real vector, matrix, symbolic variable or other data types, and y evaluates Gamma function
to all the entities in x.
Example 8.34
Please show from deﬁnition that, for any nonnegative integer k, there
exists Γ(k) = (k −1)!.
Solution The property can be shown directly with the statements
>> syms t k; assume(k,’integer’); assumeAlso(k>=0); % non-negative integer
I=int(exp(-t)*t^(k-1),t,0,inf) % compute from deﬁnition
Example 8.35
Please validate some of the properties of Gamma functions
Γ
1
2

= √π, Γ(α)Γ(1 −α) =
α
sin πα, Γ(α)Γ(−α) =
−π
α sin πα,
(8-5-2)
Γ
1
2 + α

Γ
1
2 −α

=
π
cos πα,
lim
α→∞
αzΓ(α)
Γ(α + z) = 1, Rez > 0.
(8-5-3)
Solution With symbolic gamma() function, the properties can be validated directly
>> syms a z; I1=gamma(sym(1/2)), % compute with gamma()
I2=simplify(gamma(a)*gamma(1-a)), I3=simplify(gamma(a)*gamma(-a))
I4=simplify(gamma(1/2+a)*gamma(1/2-a))
I5=limit(a^z*gamma(a)/gamma(a+z),a,Inf)
Example 8.36
Please draw Gamma function in the interval (−5, 5).
Solution
The following statements can be used to draw Gamma function, as shown in
Figure 8.31. Since at points α = 0, −1, −2, · · ·, the values of Γ(α) tends to inﬁnity. In order
to have a better view of the plot, the y-axis is zoomed manually to make it more informative.
>> x=-5:0.002:5; plot(x,gamma(x)), ylim([-15,15]) % draw Gamma function curve
−5
−4
−3
−2
−1
0
1
2
3
4
5
−15
−10
−5
0
5
10
15
FIGURE 8.31: Gamma function plot.

418
Scientiﬁc Computing with MATLAB®
Example 8.37
Some integral problems can be solved using the concept of Gamma
function, and the results can be regarded as “analytical solutions” of the deﬁnite integrals.
Please solve the following indeﬁnite integral
I =
 ∞
0
tx−1 cos t dt, x > 0.
Solution With the following statements the problem can be solved
>> syms t; syms x positive; I=simplify(int(t^(x-1)*cos(t),t,0,inf))
and the result obtained is a piecewise function mathematically interpreted as
I =
⎧
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎩
2x√π Γ (x/2)
2Γ ((1 −x)/2),
x < 1
no analytical solution,
x = 1 or 2 ⩽x
cos(πx/2) Γ (x) ,
x < 1 or x ∈(1, 2) .
The values of Gamma functions can also be evaluated through numerical integrals, also
it can be evaluated through the following inﬁnite series
Γ(x) = 1
xe−γx
∞

n=1

n
n + x

ex/n,
(8-5-4)
where, γ ≈0.57721566490153286 is the Euler γ constant.
II. Incomplete Gamma function
If the upper bound of the Gamma integral is ﬁnite, then, Gamma function is referred
to as incomplete Gamma function, deﬁned as
Γ(x, α) =
1
Γ(α)
 x
0
e−ttα−1 dt,
α ⩾0.
(8-5-5)
The incomplete Gamma function can be evaluated with y = gammainc(x,α).
III. Gamma function with complex arguments
It is also noted that the gamma() function in MATLAB applies only to real arguments.
If the arguments are complex, a MATLAB function below can be written, based on the
deﬁnition in (8-5-1)
function y=gamma_c(z), f=@(t)exp(-t).*t.^(z-1);
if isreal(z), y=gamma(z);
else, y=integral(f,0,inf,’ArrayValued’,true); end
8.5.2
Beta functions
The Beta function is deﬁned as
B(m, α) =
 1
0
tm−1(1 −t)α−1 dt = Γ(m)Γ(α)
Γ(m + α) , m, α > 0.
(8-5-6)
Beta function can be evaluated directly with y = beta(m,x).

Data Interpolation and Functional Approximation Problems
419
Example 8.38
Please draw the functions of Beta functions for diﬀerent values of m.
Solution If m = 1, the Beta function plot can be obtained immediately, as shown in Figure
8.32 (a). For diﬀerent other values of m, the surface of Beta function can be obtained.
Through proper adjustment of the viewpoint, the surface can be shown in Figure 8.32 (b).
>> m=1; x=0.1:0.1:3; y=beta(m,x); subplot(121), plot(x,y); subplot(122)
m=1:10; Z=[]; for i=m, Z=[Z; beta(i,x)]; end; surf(x,m,Z)
0
0.5
1
1.5
2
2.5
3
0
2
4
6
8
10
(a) Beta function when m = 1
0
1
2
3
0
5
10
0
2
4
6
8
10
(b) surface of Beta function for diﬀerent m
FIGURE 8.32: Beta function plots.
Similar to incomplete Gamma functions, incomplete Beta function is deﬁned as
Bx(z, m) =
1
B(z, w)
 x
0
tm−1(1 −t)z−1 dt,
(8-5-7)
with R(m) > 0, R(z) > 0, and 0 ⩽x ⩽1. Incomplete Beta function can be evaluated
directly with y = betainc(x,z,m).
8.5.3
Legendre functions
Consider the Legendre diﬀerential equation
(1 −t2)d2x
dt2 −2tdx
dt + n(n + 1)x = 0,
(8-5-8)
and there is no analytical solution, therefore, the general solution of the equation can be
written as
x(t) = C1Pn(t) + C2Qn(t),
(8-5-9)
where, C1, C2 are arbitrary constants, Pn(t) and Qn(t) are, respectively, ﬁrst and second
type Legendre functions, deﬁned as
Pn(t) =
∞

k=0
(−1)k
Γ(k + n + 1)
(k!)2Γ(n −k + 1)
1 −t
2
k
,
|1 −t| < 2,
(8-5-10)
Qn(t) = 1
2Pn(t) ln
t + 1
t −1

−
n

k=1
1
k Pk−1(t)Pn−k(t).
(8-5-11)

420
Scientiﬁc Computing with MATLAB®
Extending (8-5-8), a series of Legendre diﬀerential equations can be constructed as
(1 −t2)d2x
dt2 −2tdx
dt +

n(n + 1) −
m2
1 −t2

x = 0,
(8-5-12)
where, the Legendre functions can be denoted as P m
n (t), satisfying
P m
n (t) = (−1)m(1 −t2)m/2 dm
dtm Pn(t).
(8-5-13)
Function legendre() can be used to evaluate Legendre functions, P m
n (t), with the syntax
Y = legendre(n,x). Here Y is a matrix, whose rows are P 0
n(x), P 1
n(x), · · · , P n
n (x). Also,
it is required that −1 < x < 1.
Example 8.39 Legendre functions can be obtained directly with the following statements,
as shown in Figure 8.33. Legendre functions of other orders can be drawn similarly.
>> x=-1:0.04:1; Y=legendre(2,x); plot(x,Y) % draw Legendre plots
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
−1.5
−1
−0.5
0
0.5
1
1.5
2
2.5
3
P 2
2 (t)
P 1
2 (t)
P 0
2 (t)
FIGURE 8.33: Legendre function plots.
8.5.4
Bessel functions
Consider the following Bessel diﬀerential equation
t2 d2x
dt2 + tdx
dt + (t2 −λ2)x = 0.
(8-5-14)
If λ is not integer, power series approximation can be used, and the general solution of
the diﬀerential equation can be written as
x(t) = C1Jλ(t) + C2J−λ(t),
(8-5-15)
where, C1 and C2 are arbitrary constants, Jλ(t) is the ﬁrst type λth order Bessel function
deﬁned as
Jλ(t) =
∞

m=0
(−1)m
tλ+2m
2λ+2mm! Γ(λ + m + 1),
(8-5-16)

Data Interpolation and Functional Approximation Problems
421
and it applies to the cases when λ is not an integer. If λ = n is a positive integer, the ﬁrst
type Bessel has the following properties
Jn(t) = (−1)nJ−n(t),
Jn(x)
dt
= n
t Jn(t) −Jn+1(t),

tnJn−1(t) dt = tnJn(t).
(8-5-17)
If λ = n is an integer, Jn(t) and J−n(t) are linearly independent, thus, the general
solution cannot be described with (8-5-15). The second type nth order Bessel function
should be deﬁned, and it is also known as Neumann function.
Nλ(t) = Jλ(t) cos λt −J−λ(t)
sin λt
,
(8-5-18)
and when λ = n, the solution in (8-5-14) can be rewritten as
x(t) = C1Jn(t) + C2Hn(t).
(8-5-19)
Function besselj() can be used to evaluate the ﬁrst type Bessel functions, with the
syntax y = besselj(λ,x), where λ is the order. The second type Bessel function can be
evaluated with bessely() function, and the syntax of the function is exactly the same as
besselj() function. The third type Bessel function, also known as Hankel function, can be
evaluated with besselh().
Example 8.40
Draw the plot of the ﬁrst type Bessel functions.
Solution The plots of Bessel functions with various parameters can be obtained as shown
in Figures 8.34 (a) and (b).
>> lam=0; x=-10:0.1:10; y=besselj(lam,x); subplot(121), plot(x,y);
lam=-2:2; subplot(122), for i=lam, plot(x,besselj(i,x)); hold on; end
−10
−8
−6
−4
−2
0
2
4
6
8
10
−0.5
0
0.5
1
(a) λ = 0
−10
−8
−6
−4
−2
0
2
4
6
8
10
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
J0(x)
J1(x)
J−1(x)
J2(x)=J−2(x)
(b) for various λ values
FIGURE 8.34: First type Bessel function curves.
8.5.5
Mittag–Leﬄer functions
Mittag–Leﬄer function is the extension of simple exponential functions. The simplest
form of Mittag–Leﬄer function was introduced by Swedish mathematician Magnus Gustaf
Mittag–Leﬄer in 1903 [5], it is also known as Mittag–Leﬄer function with one variable.

422
Scientiﬁc Computing with MATLAB®
Later, Mittag–Leﬄer functions with two and more variables are introduced. The importance
of Mittag–Leﬄer function in fractional-order calculus is similar to the exponential functions
in traditional calculus. In this section, deﬁnitions and computations of Mittag–Leﬄer
functions are presented.
The Mittag–Leﬄer function with one variable is deﬁned as
Eα(z) =
∞

k=0
zk
Γ(αk + 1),
(8-5-20)
where, α is a complex number, and for R(α) > 0, the inﬁnite series is convergent.
It is obvious that, exponential function ez is a special case of Mittag–Leﬄer function,
since it can be seen that when α = 1
E1(z) =
∞

k=0
zk
Γ(k + 1) =
∞

k=0
zk
k! = ez.
(8-5-21)
Besides, the functions for α = 2, α = 1/2 can also be derived as
E2(z) =
∞

k=0
zk
Γ(2k + 1) =
∞

k=0
(√z)2k
(2k)!
= cosh √z,
(8-5-22)
E1/2(z) =
∞

k=0
zk
Γ (k/2 + 1) = ez2(1 + erf(z)) = ez2erfc(−z).
(8-5-23)
Consider again the Mittag–Leﬄer function with one variable, if the value of 1 in the
Gamma function is substituted with another free variable β, the Mittag–Leﬄer function
with two variables is deﬁned as
Eα,β(z) =
∞

k=0
zk
Γ(αk + β),
(8-5-24)
where, α, β are complex, and convergent conditions for any complex variable z are that
R(α) > 0, R(β) > 0. If β = 1, the Mittag–Leﬄer is reduced to a univariate Mittag–Leﬄer
function, i.e.,
Eα,1(z) = Eα(z).
(8-5-25)
Other special cases of Mittag–Leﬄer functions can be derived
E1,2(z) =
∞

k=0
zk
Γ(k + 2) = 1
z
∞

k=0
zk+1
(k + 1)! = ez −1
z
,
(8-5-26)
E1,3(z) =
∞

k=0
zk
Γ(k + 3) =
∞

k=0
zk
(k + 2)! = 1
z2
∞

k=0
zk+2
(k + 2)! = ez −1 −z
z2
.
(8-5-27)
More generally, we have [6]
E1,m(z) =
∞

k=0
zk
Γ(k+m) =
1
zm−1
∞

k=0
zk+m−1
(k+m−1)! =
1
zm−1
+
ez −
m−2

k=0
zk
k!
,
,
(8-5-28)
and it can be found that
E2,2(z) =
∞

k=0
zk
Γ(2k + 2) =
1
√z
∞

k=0
(√z)2k+1
(2k + 1)! = sinh √z
√z
,
(8-5-29)

Data Interpolation and Functional Approximation Problems
423
E2,1(z2) =
∞

k=0
z2k
Γ(2k + 1) =
∞

k=0
z2k
(2k)! = cosh z,
(8-5-30)
E2,2(z2) =
∞

k=0
z2k
Γ(2k + 2) = 1
z
∞

k=0
z2k+1
(2k + 1)! = sinh z
z
.
(8-5-31)
The Mittag–Leﬄer function with one and two variables can be evaluated with MATLAB
function, with the following syntaxes
F1 = mittag leffler(α,z), and
F1 = mittag leffler([α,β],z)
function f=mittag_leffler(aa,z)
aa=[aa 1]; a=aa(1); b=aa(2); % please use MATLAB R2008a or earlier
syms k; f=simplify(symsum(z^k/gamma(a*k+b),k,0,inf));
Please note that due to the limitations of symsum() function in the new versions, the
mittag leffler() function sometimes may not yield correct results. Therefore, MATLAB
R2008a or earlier versions are recommended.
Example 8.41 Find the analytic expression of Mittag–Leﬄer functions with one variable
α, for α = 1/3, 3, 4, 5, · · ·.
Solution
With the direct use of mittag leffler() function, the analytical solutions of
the necessary Mittag–Leﬄer functions can be obtained
>> syms z; I1=mittag_leffler(1/sym(3),z), I2=mittag_leffler(3,z)
I3=mittag_leffler(4,z), I4=mittag_leffler(5,z)
and the following results can be obtained
E1/3(z) = −ez3 
−6 π Γ (2/3) +
√
3 Γ2 (2/3) Γ

1/3, z3
+ 2 Γ

2/3, z3
π

2π Γ (2/3)
,
E3(z) = 1
3 e
3√z + 2
3 e−3√z/2 cos
+√
3
2
3√z
,
,
E4(z) = 1
4 e
4√z + 1
4 e−4√z + 1
2 cos

4√z

,
E5(z)= e
5√z
5 + 2
5ecos(2π/5) 5√z cos

sin
2π
5

5√z

+ 2
5e−cos(π/5) 5√z cos

sin
π
5

5√z

.
Example 8.42 Please ﬁnd the Mittag–Leﬄer functions with two variables, such as E4,1(z),
E4,5(z), E5,6(z) and E1/2,4(z).
Solution With proper parameters α and β, the Mittag–Leﬄer functions can be obtained
directly with
>> syms z, I5=mittag_leffler(4,1,z), I6=mittag_leffler(4,5,z)
I7=mittag_leffler(5,6,z), I8=mittag_leffler(1/sym(2),4,z)
and the results obtained are
E4,1(z) = 1
4e
4√z + 1
4e−4√z + 1
2 cos
4√z,
E4,5(z) = −1
4 + 1
4z

e
4√z + e−4√z + ej 4√z + e−j 4√z
,

424
Scientiﬁc Computing with MATLAB®
E5,6(z) = −1
z + e
5√z
5z

1 + e(−1)2/5 + e(−1)4/5 + e−(−1)1/5 + e−(−1)3/5
,
E1/2,4(z) = ez2
z6 −1
z6 −1
z4 −
1
2z2 + zez2erf (z)
z7
−
8
15√πz −
4
3√πz3 −
2
√πz5 .
The nth order derivative of Mittag–Leﬄer functions with two variables, Eα,β(z) can be
obtained with
dn
dzn Eα,β(z) =
∞

k=0
(k + n)!
k! Γ(αk + αn + β)zk
(8-5-32)
In some particular ﬁelds, Mittag–Leﬄer functions with three or four parameters are
used, and the deﬁnitions of these functions are
E γ
α,β(z) =
∞

k=0
Γ(k + γ)
Γ(αk + β)Γ(γ)
zk
k! ,
(8-5-33)
and
E γ,q
α,β(z) =
∞

k=0
Γ(kq + γ)
Γ(αk + β)Γ(γ)
zk
k! ,
(8-5-34)
where α, β, γ are complex numbers, q is an integer, and the convergent conditions for any
z are R(α) > 0, R(β) > 0, R(γ) > 0. It is also known that
E 1
α,β(z) = Eα,β(z),
E γ,1
α,β(z) = E γ
α,β(z).
(8-5-35)
In general, for any positive integer n, one has
dn
dzn E γ,q
α,β(z) = Γ(qn + γ)
Γ(γ)
E γ+qn,q
α,β+nα(z).
(8-5-36)
Based on the previous expression, a MATLAB can be written to evaluate numerically
the derivatives of Mittag–Leﬄer functions. Truncation algorithm is used in the function.
Sometimes the function may fail to converge, and in this case, the function MLF() written by
Slovakia scholar, Professor Igor Podlubny [7], can be used instead. The function is reliable,
but the speed of it is extremely slow. The reliable function is embedded in the function, so
as to ensure both the speed and the reliability of the function.
function f=ml_func(aa,z,varargin)
aa=[aa,1,1,1]; a=aa(1); b=aa(2); c=aa(3); q=aa(4); f=0; k=0; fa=1;
[n,eps0]=default_vals({0,eps},varargin{:});
if n==0
while norm(fa,1)>=eps0 % check truncation error
fa=gamma(k*q+c)/gamma(c)/gamma(k+1)/gamma(a*k+b) *z.^k;
f=f+fa; k=k+1;
% accumulation and continue
end
if any(~isfinite(f)), eps1=round(-log10(eps0)); % if not converge
if c*q==1, f=MLF(a,b,z,eps1); f=reshape(f,size(z)); % use MLF
else, error(’Error: truncation method failed’); end, end
else, aa(2)=aa(2)+n*aa(1); aa(3)=aa(3)+aa(4)*n;
f=gamma(q*n+c)/gamma(c)*ml_func(aa,z,0,eps0); % compute derivative
end

Data Interpolation and Functional Approximation Problems
425
The syntaxes of the function are
f = ml func(α,z,n,ϵ0)
% nth order derivative of Eα(z)
f = ml func([α,β],z,n,ϵ0)
% nth order derivative of Eα,β(z)
where the default value of ϵ0 is eps, and the default value of n is zero, meaning to evaluate
the original Mittag–Leﬄer function. In fact, the function can be used to deal with Mittag–
Leﬄer functions with three or four variables.
Example 8.43
Evaluate numerically the function E1/2,4(z) studied in Example 8.42, and
compare the results with analytical results.
Solution The following statements can be used to ﬁnd the analytical and numerical results
of the function, as shown in Figure 8.35. It can be seen that the two results agree well. For
this example, if the time interval is too large, the truncation method may fail, and function
MLF() can be called automatically. However, the speed of the evaluation process may become
very slow.
>> syms z, I8=mittag_leffler([1/sym(2),4],z);
t=0:0.01:2; y=subs(I8,z,t); y1=ml_func([1/2,4],t); plot(t,y,t,y1)
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
0
0.2
0.4
0.6
0.8
1
1.2
1.4
FIGURE 8.35: Mittag–Leﬄer function plot.
8.6
Signal Analysis and Digital Signal Processing
8.6.1
Correlation analysis
Correlation analysis can be used to characterize both stochastic and deterministic
signals. Consider a deterministic signal x(t). The auto-correlation function is deﬁned as
Rxx(τ) = lim
T →∞
1
T
 T
0
x(t)x(t + τ) dt,
τ ⩾0,
(8-6-1)

426
Scientiﬁc Computing with MATLAB®
and the correlation function is an even function, i.e., Rxx(−τ) = Rxx(τ). The cross-
correlation function of two signals x(t) and y(t) is deﬁned as
Rxy(τ) = lim
T →∞
1
T
 T
0
x(t)y(t + τ) dt,
τ ⩾0.
(8-6-2)
Clearly, when the functions are all given, the auto-correlation and cross-correlation
functions can be evaluated by using Symbolic Math Toolbox. In some cases, it is possible
to obtain analytical solutions.
Example 8.44
Consider the signal x(t) = A1 cos(ω1t + θ1) + A2 cos(ω2t + θ2), and ω1 ̸=
±ω2. Compute its auto-correlation function.
Solution It is known that the symbolic variables should be declared ﬁrst. Then, the function
x(t) can be deﬁned, and the following statements can be used to evaluate the auto-correlation
function.
>> syms A1 A2 t1 t2 t tau T w1 w2; assume(w1~=w2);
assumeAlso(w1~=-w2); x=A1*cos(w1*t+t1)+A2*cos(w2*t+t2);
Rxx=simplify(limit(int(x*subs(x,t,t+tau),t,0,T)/T,T,inf))
The analytical solution can be found that
Rxx(τ) = 1
2A2
1 cos(ω1τ) + 1
2A2
2 cos(ω2τ).
Given two sets of data xi, yi, (i = 1, 2, · · · , n), the following formula can be used to
evaluate the correlation coeﬃcients
rxy =

(xi −¯x)(yi −¯y)

(xi −¯x)2

(yi −¯y)2
.
(8-6-3)
The MATLAB function corrcoef() can be used to obtain the correlation coeﬃcients
R of vectors x and y using the following syntaxes:
R = corrcoef(x,y),
or
R = corrcoef([x,y])
Example 8.45
Generate sample points from the functions y1 = te−4t sin 3t and y2 =
te−4t cos 3t, and then, compute the correlation coeﬃcient matrix.
Solution With the following statements, the correlation matrix can be obtained
>> x=0:0.01:5; y1=x.*exp(-4*x).*sin(3*x); y2=x.*exp(-4*x).*cos(3*x);
R=corrcoef(y1,y2) % compute correlation coeﬃcient matrix
and the correlation coeﬃcients obtained are
R =

1
0.477585851214039
0.477585851214039
1

.
Consider now the sampled data xi, yi, (i = 1, 2, · · · , n). The auto-correlation function of
the discrete signal xi can be evaluated from
cxx(k) = 1
N
n−[k]−1

l=1
x(l)x(k + l),
0 ⩽k ⩽m −1,
(8-6-4)

Data Interpolation and Functional Approximation Problems
427
where m < n. The auto-correlation function obtained is also an even function. Similarly,
the cross-correlation function is deﬁned as
cxy(k) = 1
N
n−[k]−1

l=1
x(l)y(k + l),
0 ⩽k ⩽m −1.
(8-6-5)
Similarities of two discrete signals can be studied with the help of correlation functions.
The auto-correlation function and cross-correlation function can both be evaluated with the
use of function xcorr(). The syntaxes are
Cxx = xcorr(x,N),
and
Cxy = xcorr(x,y,N)
where N is the maximum value of k and it can be omitted.
Example 8.46
Consider again the data generated from Example 8.45. Compute
numerically the auto-correlation, cross-correlation functions and compare the results with
theoretical curves.
Solution Specify a time vector in the interval t ∈(0, 5). The output signals can be generated
in vectors x and y. The auto-correlation and cross-correlation functions can be obtained as
shown in Figures 8.36 (a) and (b), respectively.
>> t=0:0.05:5; x=t.*exp(-4*t).*sin(3*t); y=t.*exp(-4*t).*cos(3*t);
N=30; c1=xcorr(x,N); x1=[-N:N]; subplot(121), stem(x1,c1)
subplot(122), c1=xcorr(x,y,N); x1=[-N:N]; stem(x1,c1)
−30
−20
−10
0
10
20
30
−0.01
0
0.01
0.02
0.03
0.04
0.05
(a) auto-correlation analysis
−30
−20
−10
0
10
20
30
−0.015
−0.01
−0.005
0
0.005
0.01
0.015
0.02
0.025
0.03
0.035
(b) cross-correlation analysis
FIGURE 8.36: Correlation function analysis.
8.6.2
Power spectral analysis
For the discrete sample data vector y, the MATLAB function psd() can be used to
evaluate its power spectral density. However, it is found that the result obtained is not
satisfactory. The Welch transform based estimation algorithm is introduced here instead [8].
Assume that n is the length of the vector y to be processed. These data can be divided
into K = [n/m] groups with a vector length of m such that
x(i)(k) = y[k + (i −1)m], 0 < k ⩽m −1, 1 ⩽i ⩽K.
(8-6-6)

428
Scientiﬁc Computing with MATLAB®
With the Welch algorithm, the following K equations can be established.
J(i)
m (ω) =
1
mU
"""""
m−1

k=0
x(i)(k)w(k)e−jωk
"""""
2
,
(8-6-7)
where w(k) is the data processing window function. For instance, it can be the Hamming
window deﬁned as
w(k) = a −(1 −a) cos
 2πk
m −1

, k = 0, · · · , m −1.
(8-6-8)
If a = 0.54, and
U = 1
m
m−1

k=0
w2(k),
(8-6-9)
the power spectral density of the signal can be estimated with
P w
xx(ω) = 1
K
K

j=1
J(i)
m (ω).
(8-6-10)
The following procedure can be used to compute the power spectral densities of the
signal [9].
(i) Calculate X(i)
m (l)=
m−1

k=0
x(i)(k)w(k)e−j[2π/(mΔt)]lk in groups with fft().
(ii) In group i, compute
"""X(i)
m (l)
"""
2
, the accumulative sum Y (l)=
K

i=1
"""X(i)
m (l)
"""
2
.
(iii) From the following formula, the power spectral density can be obtained
P w
xx
 2π
mΔtl

=
1
KmU Y (l).
(8-6-11)
The function fft() is used in calculating X(i)
m
(i) MATLAB function fft() can be used to compute discrete Fourier transforms. The
resulting P w
xx should be multiplied by Δt.
(ii)
To increase the eﬀectiveness of the algorithm, m should be chosen as 2k −1 for
integer k.
A MATLAB function psd estm() can be written to estimate the power spectral density
of a given sequence, listed as
function [Pxx,f]=psd_estm(y,m,T,a)
if nargin==3, a=0.54; end
k=[0:m-1]; Y=zeros(1,m); m2=floor(m/2); f=k(1:m2)*2*pi/(length(k)*T);
w=a-(1-a)*cos(2*pi*k/(m-1)); K=floor(length(y)/m); U=sum(w.^2)/m;
for i=1:K, xi=y((i-1)*m+k+1)’; Xi=fft(xi.*w); Y=Y+abs(Xi).^2; end
Pxx=Y(1:m2)*T/(K*m*U);
The syntax of the function is [Pxx,f] = psd estm(y,m,Δt,a). In this function, in
order to avoid the aliasing phenomenon, half of the transformation data should be selected.
In this function, the deﬁnitions of y and m are the same, and Δt is the sample time. The
returned arguments f and Pxx are respectively the frequency and the power spectral density.

Data Interpolation and Functional Approximation Problems
429
8.6.3
Filtering techniques and ﬁlter design
Before presenting technical details of ﬁlters, the applications of ﬁlters are illustrated
through an example.
Example 8.47
To illustrate the concept of ﬁltering techniques, the function y(x) =
e−x sin(5x) is studied. Suppose a set of function data is generated, disturbed by the white
noise signal with the zero mean and the variance of 0.05. Draw the corrupted signal ﬁrst.
Solution The following statements can be used, and the noisy signal is shown in Figure
8.37.
>> x=0:0.002:2; y=exp(-x).*sin(5*x);
% generate data
r=0.05*randn(size(x)); y1=y+r; plot(x,y1) % draw noised plot
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
FIGURE 8.37: Data corrupted by noises.
For the corrupted signal shown in Figure 8.37, a noise elimination technique should be
applied. For instance, ﬁlters can be used to ﬁlter out the noise to extract the actual signal.
I. Linear ﬁlters — general models
Linear ﬁlters can generally be written as
H(z) = b1 + b2z−1 + b3z−2 + · · · + bn+1z−n
1 + a1z−1 + a2z−2 + · · · + amz−m .
(8-6-12)
Assume that the input signal is x(n), the ﬁltered output signal can be expressed using
the following diﬀerence equation:
y(k) = −a1y(k −1) −a2y(k −2) −· · · −amy(k −m)
+ b1x(k) + b2x(k −1) + b3x(k −2) · · · + bn+1x(k −n).
(8-6-13)
With diﬀerent combinations of n and m, three types of ﬁlters are deﬁned
(i) FIR ﬁlter The ﬁnite impulse response (FIR) ﬁlter requires m = 0 in (8-6-12). The
variable a is then a scalar. This ﬁlter is also known as the moving average (MA) ﬁlter. The
vector b can be used to deﬁne the ﬁlter.
(ii) IIR ﬁlter The inﬁnite impulse response (IIR) ﬁlter, also known as auto-regressive

430
Scientiﬁc Computing with MATLAB®
(AR) or all-pole ﬁlter required n = 0, i.e., b is a scalar and the vector a can be used to
represent the ﬁlter. An advantage of FIR is that it is always stable [10].
(iii) ARMA ﬁlter The auto-regressive moving average (ARMA) ﬁlter is also known as
general IIR ﬁlter, where n and m are not zero. The vectors a and b can be used to express
the ﬁlter.
Assume that the ﬁlter is given by vectors a and b, and the signal to be ﬁltered is given
by vector x. The function filter() can be used to evaluate the ﬁltered signal vector y
where y = filter(b,a,x).
Filters can be classiﬁed into low-pass ﬁlters, high-pass ﬁlters, band-stop and band-pass
ﬁlters. It is known from the ﬁlter names that a low-pass ﬁlter allows the signal with low
frequency to pass the ﬁlter directly with little or no attenuation while the signal’s high-
frequency content will be ﬁltered out or attenuated. High-pass ﬁlters ﬁlter out the low-
frequency signal components. A band-pass ﬁlter allows the signal components of certain
frequency range to pass directly, while those of other frequencies are ﬁltered out. In real
applications, these ﬁlters are used depending on the purpose of the signal processing.
For example, the noise in Example 8.47 is a high-frequency noise, thus, a low-pass ﬁlter
is needed, i.e., the magnitude is set to 1 or nearly 1 for low-frequency signals, while
to 0 for high-frequency noises. In this way, the noise may be eliminated. If the ﬁlter is
known, the function freqz() can be used to analyze the magnitude of the ﬁlter, such that
[h,w] = freqz(b,a,N), where N is the number of points to be analyzed. The returned
argument h is the complex gain, and w is the frequency vector. The complex gain includes
the information of magnitudes and phases. If only the magnitude information is required,
plot(w,abs(h)) can be used to visualize the ﬁlter frequency response. Alternatively, Bode
magnitude plot can be obtained with the command semilogx(w,20*log10(abs(h))).
Example 8.48
Assume that a ﬁlter is given by
H(z)=
1.2296 × 10−6(1 + z−1)7
(1 −0.7265z−1)(1 −1.488z−1 + 0.5644z−2)
(1 −1.595z−1 + 0.6769z−2)(1 −1.78z−1 + 0.8713z−2)
.
Compute the complex gain and observe the ﬁltered signals.
Solution The vectors b and a of the ﬁlter can be entered into MATLAB, where the function
conv() can be used to perform polynomial multiplications. The following statements can also
draw the gain-frequency curve as shown in Figure 8.38 (a). It can be seen from the curve
that, for low frequencies, the gain is close to 1, which means that no ﬁltering action is made
over these frequencies. For high frequencies, the gain approaches to 0, which means that the
high-frequency noise can be removed or attenuated from the signal.
>> b=1.2296e-6*conv([1 4 6 4 1],[1 3 3 1]); a=conv([1,-0.7265],...
conv([1,-1.488,0.5644],conv([1,-1.595,0.6769],[1,-1.78,0.8713])));
x=0:0.002:2; y=exp(-x).*sin(5*x); r=0.05*randn(size(x)); y1=y+r;
[h,w]=freqz(b,a,100); subplot(121), plot(w,abs(h)) % draw magnitude
subplot(122), y2=filter(b,a,y1);
plot(x,y1,x,y2)
% ﬁltered signal
It can be seen from the results shown in Figure 8.38 (b) that, in the ﬁltered signal, the
noise is successfully removed. Note that there exist small delays in the ﬁltered signal. In
real-time or online ﬁltering, this delay is unavoidable. However, when performing oﬀ-line
ﬁltering, it is possible to have zero delay by using the so-called “zero-phase ﬁltering” which
can be done by the MATLAB function filtfilt() with the same syntax as filter().

Data Interpolation and Functional Approximation Problems
431
0
0.5
1
1.5
2
2.5
3
0
0.2
0.4
0.6
0.8
1
(a) the gain of the ﬁlter
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
−0.5
0
0.5
1
(b) original signal and the ﬁltered one
FIGURE 8.38: Filter gain and ﬁlter results.
II. Filter design using MATLAB
It has been shown from the previous examples that the noisy signal can be ﬁltered
with a properly designed ﬁlter. There are various algorithms and relevant toolboxes in
MATLAB for ﬁlter design and simulation problems. The most widely used ﬁlters are the
Butterworth ﬁlters and the Chebyshev ﬁlters. They can be designed with the butter(),
cheby1() (Chebyshev type I) and cheby2() (Chebyshev type II) functions. The syntaxes
of these functions are
[b,a] = butter(n,ωn), [b,a] = cheby1(n,r,ωn), [b,a] = cheby2(n,r,ωn)
where n is the order of the ﬁlter, which can either be selected by the user, or be a relevant
function, for instance, buttord(). The argument ωn is the normalized frequency, which
deﬁnes the ratio of the ﬁlter frequency and the Nyquist frequency of the signal. Assume
that there are N sampling points, and step-size is Δt. The fundamental frequency can then
be calculated as f0 = 1/Δt Hz. Then, the Nyquist frequency is deﬁned as f0/2.
Example 8.49
Consider the signal in Example 8.47. Design Butterworth ﬁlters for
diﬀerent combinations of orders and the natural frequencies of wn, and compare the ﬁltering
results.
Solution Again ωn = 0.1 can be selected. With the following statements, the Butterworth
ﬁlters of diﬀerent orders can be designed, and the gain and ﬁlter results are shown in Figures
8.39 (a) and (b), respectively. It can be seen that with the increment of order n, the ﬁlter
curve becomes smoother, and the delay also increases.
>> f1=figure; f2=figure;
for n=5:2:20, figure(f1); [b,a]=butter(n,0.1);
y2=filter(b,a,y1); plot(x,y2); hold on
figure(f2); [h,w]=freqz(b,a,100); plot(w,abs(h)); hold on
end
If one selects the 7th order ﬁlter structure, diﬀerent values of ωn can be tested for
Butterworth ﬁlters. The gain and ﬁlter results can be obtained as shown in Figures 8.40 (a)
and (b), respectively. It can be seen that when ωn increases, the delay will decrease and
ﬁltering results may get worse. The large value of ωn may not provide any beneﬁt.

432
Scientiﬁc Computing with MATLAB®
0
0.5
1
1.5
2
2.5
3
3.5
0
0.2
0.4
0.6
0.8
1
n = 5
n = 5
(a) gain
0
0.5
1
1.5
2
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
n increases
(b) ﬁltered curves
FIGURE 8.39: Butterworth ﬁlters with diﬀerent orders.
>> for wn=0.1:0.1:0.7, figure(f1); [b,a]=butter(7,wn);
y2=filter(b,a,y1); plot(x,y2); hold on
figure(f2); [h,w]=freqz(b,a,100); plot(w,abs(h)); hold on
end
0
0.5
1
1.5
2
2.5
3
3.5
0
0.2
0.4
0.6
0.8
1
(a) gain
0
0.5
1
1.5
2
−0.5
0
0.5
1
(b) ﬁltered curves
FIGURE 8.40: Butterworth ﬁlters with diﬀerent frequencies.
If high-pass ﬁlters are required, the simplest way is to design it with the formula 1 −
H(z−1), where H(z−1) is the low-pass ﬁlter designed using the methods shown earlier.
Also, the function butter() can be used to design high-pass and band-pass ﬁlters with the
syntaxes
[b,a] = butter(n,wn,’high’)
% high-pass ﬁlter
[b,a] = butter(n,[w1, w2])
% band-path ﬁlter

Data Interpolation and Functional Approximation Problems
433
Exercises
Exercise 8.1 Generate a sparsely distributed data from the following functions. Use one-
dimensional interpolation method to smooth the curves, with diﬀerent methods. Compare
the interpolation results with the theoretical curves.
(i) y(t) = t2e−5t sin t, where t ∈(0, 2),
(ii) y(t) = sin(10t2 + 3), for t ∈(0, 3).
Exercise 8.2 Generate a set of mesh grid data and randomly distribute the data from the
prototype function
f(x, y) =
1
3x3 + ye−x2−y4 sin(xy2 + x2y).
Fit the original 3D surface with two-dimensional interpolation methods and compare the
results with the theoretical ones.
Exercise 8.3 Assume that a set of data is given as shown in Table 8.7. Interpolate the data
into a smooth curve in the interval x ∈(−2, 4.9). Compare the advantages and disadvantages
of the algorithms.
TABLE 8.7: Measured data for Problem 8.3.
xi
−2
−1.7
−1.4
−1.1
−0.8
−0.5
−0.2
0.1
0.4
0.7
1
1.3
yi
0.1029
0.1174
0.1316
0.1448
0.1566
0.1662
0.1733
0.1775
0.1785
0.1764
0.1711
0.1630
xi
1.6
1.9
2.2
2.5
2.8
3.1
3.4
3.7
4
4.3
4.6
4.9
yi
0.1526
0.1402
0.1266
0.1122
0.0977
0.0835
0.0702
0.0579
0.0469
0.0373
0.0291
0.0224
Exercise 8.4 Assume that a set of measured data is given in a ﬁle c8pdat.dat. Draw the
3D surface using interpolation methods.
Exercise 8.5 Assume that a set of measured data is given in a ﬁle c8pdat3.dat, whose 1∼3
columns are the coordinates of x, y, z, and the fourth column saves the measured function
value V (x, y, z). Perform three-dimensional interpolation from the data.
Exercise 8.6 Generate a set of data from the function
f(x) =
√1 + x −√x −1
√2 + x + √x −1,
for x=3 : 0.4 : 8. The cubic splines and B-splines can be used to perform data interpolation
tasks. From the ﬁtted splines, take the second-order derivatives and compare the results with
the theoretical curves.
Exercise 8.7 Assume that the measured data are given in Table 8.8. Draw the 3D surface
plot for (x, y) within the rectangular region (0.1, 0.1) ∼(1.1, 1.1).
Exercise 8.8 For the measured data samples (xi, yi) given in Table 8.9, piecewise cubic
polynomial splines can be used, and ﬁnd the coeﬃcients of each polynomial.

434
Scientiﬁc Computing with MATLAB®
TABLE 8.8: Measured data for Problem 8.7.
yi
x1
x2
x3
x4
x5
x6
x7
x8
x9
x10
x11
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1.1
0.1
0.8304
0.8272
0.824
0.8209
0.8182
0.8161
0.8148
0.8146
0.8157
0.8185
0.823
0.2
0.8317
0.8324
0.8358
0.842
0.8512
0.8637
0.8797
0.8993
0.9226
0.9495
0.9801
0.3
0.8358
0.8434
0.8563
0.8746
0.8986
0.9284
0.9637
1.0045
1.0502
1.1
1.1529
0.4
0.8428
0.8601
0.8853
0.9186
0.9598
1.0086
1.0642
1.1253
1.1903
1.2569
1.3222
0.5
0.8526
0.8825
0.9228
0.9734
1.0336
1.1019
1.1763
1.254
1.3308
1.4017
1.4605
0.6
0.8653
0.9104
0.9684
1.0383
1.118
1.2045
1.2937
1.3793
1.4539
1.5086
1.5335
0.7
0.8807
0.9439
1.0217
1.1117
1.2102
1.311
1.4063
1.4859
1.5377
1.5484
1.5052
0.8
0.899
0.9827
1.082
1.1922
1.3061
1.4138
1.5021
1.5555
1.5572
1.4915
1.346
0.9
0.92
1.0266
1.1482
1.2768
1.4005
1.5034
1.5661
1.5678
1.4888
1.3156
1.0454
1
0.9438
1.0752
1.2191
1.3624
1.4866
1.5684
1.5821
1.5032
1.315
1.0155
0.6247
1.1
0.9702
1.1278
1.2929
1.4448
1.5564
1.5964
1.5341
1.3473
1.0321
0.6126
0.1476
TABLE 8.9: Measured data for Problem 8.8.
xi
1
2
3
4
5
6
7
8
9
10
yi
244.0
221.0
208.0
208.0
211.5
216.0
219.0
221.0
221.5
220.0
Exercise 8.9 The one-dimensional and two-dimensional data given in Exercises 8.3 and
8.7 can be used for cubic splines and B-splines interpolation. Find the derivatives of the
related interpolated functions.
Exercise 8.10 Consider again the data in Exercise 8.3. Polynomial ﬁtting can be used to
model the data. Select a suitable degree such that good approximation by polynomials can be
achieved. Compare the results with interpolation methods.
Exercise 8.11 Consider again the data in Exercise 8.3. Assume that the prototype of the
function for the data is
y(x) =
1
√
2πσ e
−(x−μ)2/2σ2
.
The values of the parameters μ and σ are not known. Use least squares curve ﬁtting
methods to see whether suitable μ and σ can be identiﬁed. Observe the ﬁtting results.
Exercise 8.12 The polynomial generating function fitting poly() discussed in the
text is suitable for producing polynomials in symbolic form, while it is not suitable to
polynomial evaluation needed in curve ﬁtting. Please write numerical versions useful in
the lsqcurvefit() function call.
Exercise 8.13 Consider the polynomial ﬁtting problem studied in Example 8.20. If
Legendre, Chebyshev, Laguerre and Hermit polynomials are used, respectively, please ﬁnd
the suitable orders and the ﬁtting performances.

Data Interpolation and Functional Approximation Problems
435
Exercise 8.14 Express the irrational constants e,
√
19, lg2, sin 1◦, Euler γ in terms of
continued fractions. Observe how many continued fraction levels are expected to get a suitable
approximation.
Exercise 8.15 Find good approximations to the functions given below using continued
fraction expansions and Pad´e approximations. Observe the ﬁtting results obtained and ﬁnd
suitable degrees of the rational functions.
(i) f(x) = e−2x sin 5x,
(ii) f(x) =
x3 + 7x2 + 24x + 24
x4 + 10x3 + 35x2 + 50x + 24e−3x.
Exercise 8.16 Assume that the data in Exercise 8.7 satisﬁes a prototype function of
z(x, y) = a sin(x2y) + b cos(y2x) + cx2 + dxy + e. Identify the values of a, b, c, d, e with
least squares method. Verify the identiﬁcation results.
Exercise 8.17 Please extend the function gamma(x) such that the Gamma function with
complex argument x can be evaluated.
Exercise 8.18 Evaluate and draw the following Mittag–Leﬄer functions and verify
(8-5-30).
(i) E1,1(z), (ii) E2,1(z),
(iii) E1,2(z),
(iv) E2,2(z)
Exercise 8.19 Prove the following identities involving Mittag–Leﬄer functions and graph-
ically visualize both sides of each identity for veriﬁcation purposes.
(i) Eα,β(x) + Eα,β(−x) = 2Eα,β(x2),
(ii) Eα,β(x) −Eα,β(−x) = 2xEα,α+β(x2),
(iii) Eα,β(x) =
1
Γ(β) + Eα,α+β(x),
(iv) Eα,β(x) = βEα,β+1(x) + αx d
dxEα,β+1(x).
Exercise 8.20 Given a signal f(t) = e−3t cos(2t + π/3) + e−2t cos(t + π/4), evaluate the
formula of the auto-correlation function of the signal. Generate a sequence of randomly
distributed data, and verify the results in a numerical way.
Exercise 8.21 Evaluate the auto-correlation function for the Gaussian distribution func-
tion deﬁned as
f(t) =
1
√
2π × 3e−t2/(2×32).
Generate a sequence of signals and compare them using Gaussian distributed data to
check whether the resulted description is close to the theoretical result.
Exercise 8.22 Assume that the noisy signal can be generated with the following statements
>> t=0:0.005:5; y=15*exp(-t).*sin(2*t); % generate samples of a signal
r=0.3*randn(size(y)); y1=y+r;
% add random noises
Find the Nyquist frequency of the signal. Based on the Nyquist frequency, design an
eighth-order Butterworth ﬁlter which can be used to eﬀectively ﬁlter out the noise while
having a relatively small delay due to ﬁltering.
Exercise 8.23 High-pass ﬁlters can be used to ﬁlter out information with low-frequencies,
and retain the high-frequency details. Design a high-pass ﬁlter for the data shown in Exercise
8.22. From the obtained high frequency noise information, compare the statistical behavior
of the noise signal obtained.

436
Scientiﬁc Computing with MATLAB®
Bibliography
[1] Press W H, Flannery B P, Teukolsky S A, et al.
Numerical recipes, the art of
scientiﬁc computing. Cambridge: Cambridge University Press, 1986. Free textbook
at http://www.nrbook.com/a/bookcpdf.php
[2] Wikipedia. List of numerical analysis topics
[3] Lancaster L, ˇSalkauskas K.
Curve and surface ﬁtting: an introduction.
London:
Academic Press, 1986
[4] Bosley M J, Lees F P. A survey of transfer function derivations from higher-order
state-variable models. Automatica, 1972, 8:765–775
[5] Wikipedia. Mittag–Leﬄer function
[6] Podlubny I. Fractional diﬀerential equations. San Diego: Academic Press, 1999
[7] Podlubny I. Mittag–Leﬄer function. MATLAB Central File ID: #8737
[8] Oppenheim A V, Schafer R W. Digital signal processing. Englewood Cliﬀs: Prentice-
Hall, 1975
[9] Xue D. Analysis and computer aided design of nonlinear systems with Gaussian inputs.
Ph.D. thesis, Sussex University, U.K., 1992
[10] The MathWorks Inc. Signal processing toolbox user’s guide, 2007

Chapter 9
Probability and Mathematical Statistics
Problems
The theory of probability and mathematical statistics is a very important branch in
experimental sciences. The solutions to probability and mathematical statistics problems
sometimes could be quite involved. The traditional statistics usually relies heavily on
lookup-tables. A very comprehensive statistics toolbox is provided in MATLAB which
contains a lot of handy functions for solving related probability and mathematical
statistics problems. In Section 9.1, the basic concepts of probability density function
(PDF) and cumulative distribution function (CDF) are introduced. Given probability
distributions, various probability related example problems are solved using Statistics
Toolbox. In this section, pseudorandom number generators of diﬀerent distributions, such
as uniform distribution, normal distribution, Poisson distribution, etc., are introduced
and demonstrated. In Section 9.2, probability problems are studied, either by theoretic
computation, or with histograms, based on experimental data. A very brief introduction
to Monte Carlo method is also presented in the section. Some random walk problems are
studied with simulation methods. In Section 9.3, the computation of statistical quantities,
such as mean, variance, moments and covariances is covered for both univariate and
multivariate distributions together. Also, an introduction to outlier detection problems is
given in the section. The parametric estimation and interval estimation problems, together
with their MATLAB implementations, are given in Section 9.4 where multi-variable linear
regression and least squares data ﬁtting problems are also presented. In Section 9.5, the
hypothesis test problems including mean value test, normality test and given distribution
test, are discussed. The variance analysis problems and applications are presented in Section
9.6 with detailed example solutions in MATLAB. In Section 9.7, principal component
analysis approach is brieﬂy introduced, and its applications in dimension reduction is
demonstrated through a simple example.
For readers who wish to check the detailed explanations of probability and statistics, we
recommend the open source textbook [1] for probability and the online e-textbook [2] for
statistics.
437

438
Scientiﬁc Computing with MATLAB®
9.1
Probability Distributions and Pseudorandom Numbers
9.1.1
Introduction to probability density functions and cumulative
distribution functions
The probability density function for a continuous stochastic variable is often denoted as
p(x), where
p(x) ⩾0, and
 ∞
−∞
p(x) dx = 1.
(9-1-1)
The cumulative distribution function F(x) is deﬁned as the probability of an event when
ξ ⩽x happens for the stochastic variable ξ
F(x) =
 x
−∞
p(ξ) dξ.
(9-1-2)
This function is a monotonic increasing function satisfying
0 ⩽F(x) ⩽1,
and F(−∞) = 0, F(∞) = 1.
(9-1-3)
For multivariate stochastic variable problems, joint probability density function
p(x1, x2, · · · , xn) ⩾0 can be used, with
 ∞
−∞
· · ·
 ∞
−∞
p(x1, x2, · · · , xn) dx1 dx2 · · · dxn = 1,
(9-1-4)
and multivariate cumulative distribution function is deﬁned as
F(x1, x2, · · · , xn) =
 xn
−∞
· · ·
 x1
−∞
p(ξ1, ξ2, · · · , ξn) dξ1 dξ2 · · · dξn.
(9-1-5)
Example 9.1
Assume that the joint probability density function of two stochastic
variables is given below, please determine the parameter c.
p(x, y) =

c e−(4x+3y),
0 < x < 1, y > 0
0,
otherwise.
Solution Bearing in mind the property in (9-1-4), the value of c can be determined with
the following statements, and it is found c = 12e4/(e4 −1).
>> syms c x y; p=c*exp(-(4*x+3*y)); % deﬁne probability density function
P=int(int(p,y,0,inf),x,0,1); c=solve(P==1) % evaluate probability
Given the probability fi = F(xi), to determine the value of xi, lookup-table methods
can normally be used. Since F(xi) is monotonic, xi can easily be found. This problem is also
referred to as the inverse distribution problem. In fact, functions provided in the Statistics
Toolbox can be used to easily, accurately and straightforwardly solve this type of inverse
problem. In this section, some of the commonly encountered probability distributions will
be summarized and visualized.

Probability and Mathematical Statistics Problems
439
9.1.2
Probability density functions and cumulative distribution func-
tions of commonly used distributions
Many similar functions are provided in Statistics Toolbox. The functions with suﬃxes
of pdf, cdf and inv are used to indicate the probability density function, cumulative
distribution function and inverse distribution function, respectively. The related functions
are summarized in Table 9.1. Other suﬃxes of the function include rnd, stat and fit,
meaning random number generator, statistics analysis and parametric estimation.
TABLE 9.1: Keywords and function names in Statistics Toolbox.
keyword
distribution
parameters
keyword
distribution
parameters
beta
Beta distribution
a, b
bino
binomial distribution
n, p
chi2
χ2 distribution
k
ev
extreme value
μ, σ
exp
exponential
λ
f
F distribution
p, q
gam
Gamma distribution
a, λ
geo
geometric
p
hyge
hypergeometric
m, p, n
logn
lognormal distribution
μ, σ
mvn
multivariate normal
μ, σ
nbin
negative binomial
ν1, ν2, δ
ncf
noncentral F
k, δ
nct
noncentral T
k, δ
ncx2
noncentral χ2
k, δ
norm
normal distribution
μ, σ
poiss
Poisson distribution
λ
rayl
Rayleigh distribution
b
t
T-distribution
k
unif
uniform distribution
a, b
wbl
Weibull distribution
a, b
Apart from these functions, uniﬁed functions such as pdf() are also provided to evaluate
probability density functions of a certain distribution. Similar uniﬁed functions such as
cdf(), icdf(), fitdist() are also provided and will be presented later in the section.
I. Normal distribution
The probability density function of normal distribution is deﬁned as
p(x) =
1
√
2πσ e−(x−μ)2/(2σ2),
(9-1-6)
where μ and σ2 are, respectively, the mean and variance of the normal distribution. The
functions normpdf() and normcdf() provided in the Statistics Toolbox can be used to
evaluate the probability density functions and cumulative distribution functions of such a
distribution. Also, if the distribution value F is known, the function norminv() can be used
to evaluate the corresponding x. The syntaxes of these functions are
p = normpdf(x,μ,σ), F = normcdf(x,μ,σ), x = norminv(F ,μ,σ)
where x is a vector of given points, p vector contains the values of probability density
functions and at x. The vector F returns the cumulative distribution functions at x. Clearly,
the normal distribution is a function of the mean μ and the standard deviation σ.
If the uniﬁed functions are used, the syntaxes are
p = pdf(’norm’,x,μ,σ), F = cdf(’norm’,x,μ,σ), x = icdf(’norm’,F ,μ,σ)

440
Scientiﬁc Computing with MATLAB®
Example 9.2
For diﬀerent combinations of (μ, σ2) such as (−1, 1), (0, 0.1), (0, 1), (0, 10),
(1, 1), draw the probability density functions and cumulative distribution functions of
normal distributions.
Solution With MATLAB Statistics Toolbox, these density functions can be drawn easily
and accurately for any combination of μ and σ2. Therefore, the use of computer mathematics
languages can help the readers to solve eﬀectively the probability and statistics problems.
The problem can easily be solved with MATLAB. One can assign a vector x composed
of points in the interval (−5, 5) and two other vectors deﬁned to represent the possible
combinations of the variables μ and σ2. Then, the functions normpdf() and normcdf() can
be used to draw the corresponding probability density functions and cumulative distribution
functions, as shown in Figures 9.1 (a) and (b), respectively.
−5
0
5
0
0.2
0.4
0.6
0.8
1
1.2
1.4
μ = 0, σ2 = 0.1
μ = −1, σ2 = 1
μ = 1, σ2 = 1

μ = 0
σ2 = 10
μ = 0, σ2 = 1
(a) probability density functions
−5
0
5
0
0.2
0.4
0.6
0.8
1
μ = 1, σ2 = 1
μ = 0, σ2 = 1
μ = 0
σ2 = 10
μ = 0
σ2 = 0.1
μ=−1
σ2 =1
(b) cumulative distribution functions
FIGURE 9.1: PDFs and CDFs of normal distribution.
>> x=[-5:.02:5]’; p=[]; F=[];
mu=[-1,0,0,0,1]; sig=[1,0.1,1,10,1]; sig=sqrt(sig);
for i=1:length(mu) % plots for diﬀerent parameters μ and σ
p=[p,normpdf(x,mu(i),sig(i))]; F=[F,normcdf(x,mu(i),sig(i))];
end
subplot(121), plot(x,p), subplot(122), plot(x,F)
From the probability density function curves, it can be observed that if σ2 remains the
same, the shapes of the probability density functions are exactly the same as if they are
obtained by translating the curves according to μ. If the values of σ are diﬀerent, the shapes
are also diﬀerent. The smaller the value of σ2, the narrower the curve of probability density
functions.
The combination of μ = 0, σ2 = 1 is referred to as the standard normal distribution,
which is usually denoted by N(0, 1).
II. Poisson distribution
The Poisson distribution is diﬀerent from the continuous distribution functions discussed
earlier. It requires that vector x is composed of positive integers. The probability density
function of the Poisson distribution is
p(x) = λx
x! e−λx, x = 0, 1, 2, 3, · · · ,
(9-1-7)

Probability and Mathematical Statistics Problems
441
where λ is a positive integer.
Poisson distribution is a function of positive integer parameter λ. The related functions
poisspdf(), poisscdf() and poissinv() are provided in Statistics Toolbox to evaluate
the probability density functions, cumulative distribution functions and inverse distribution
function, respectively. The syntaxes of the function are
p = poisspdf(x,λ), F = poisscdf(x,λ), x = poissinv(F ,λ)
where the vector x contains given integers, which can be speciﬁed with x = 0:k. The values
in p are the probability density function corresponding to the points in the vector x. The
vector F returns the cumulative distribution function corresponding to vector x.
The uniﬁed functions are used in the following syntaxes
p = pdf(’poiss’,x,λ), F = cdf(’poiss’,x,λ), x = icdf(’poiss’,F ,λ)
Example 9.3 For the parameter λ selected as λ = 1, 2, 5, 10, draw the probability density
functions and cumulative distribution functions of the Poisson distributions.
Solution
One can create a vector of x ﬁrst, and then, for diﬀerent values of λ, the
functions poisspdf() and poisscdf() can be used in a loop structure. The probability
density functions and cumulative distribution functions can be obtained as shown in Figures
9.2 (a), (b), respectively.
>> x=[0:15]’; p=[]; F=[]; lam1=[1,2,5,10];
for i=1:length(lam1) % plots for diﬀerent values of parameter λ
p=[p,poisspdf(x,lam1(i))]; F=[F,poisscdf(x,lam1(i))];
end
subplot(121), plot(x,p), subplot(122), plot(x,F)
0
5
10
15
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
λ = 1
λ = 2
λ = 5
λ = 10
(a) probability density functions
0
5
10
15
0
0.2
0.4
0.6
0.8
1
λ = 2
λ = 5
λ = 10
λ = 1
(b) cumulative distribution functions
FIGURE 9.2: PDFs and CDFs of the Poisson distribution.
III. Rayleigh distribution
The probability density function of Rayleigh distribution is deﬁned as
p(x) =
⎧
⎨
⎩
x
b2 e−x2/(2b2),
x ⩾0
0,
x < 0,
(9-1-8)

442
Scientiﬁc Computing with MATLAB®
which contains a parameter b. The functions raylpdf(), raylcdf() and raylinv()
provided in the Statistics Toolbox can be used to evaluate the relevant functions. Also,
the uniﬁed functions can be used. The syntaxes of these functions are
p = raylpdf(x,b), F = raylcdf(x,b), x = raylinv(F ,b)
p = pdf(’rayl’,x,b), F = cdf(’rayl’,x,b), x = icdf(’rayl’,F ,b)
Example 9.4
Draw the probability density functions and cumulative distribution
functions of the Rayleigh distribution for b = 0.5, 1, 3, 5.
Solution Assign a vector x in the interval (−0.1, 5), and also a parameter vector b1, the
raylpdf() and raylcdf() functions can be used to draw probability density functions and
cumulative distribution functions, as shown in Figures 9.3 (a) and 9.3 (b), respectively.
0
1
2
3
4
5
0
0.2
0.4
0.6
0.8
1
1.2
1.4
b = 0.5
b = 1
b = 3
b = 5
(a) probability density functions
0
1
2
3
4
5
0
0.2
0.4
0.6
0.8
1
b = 0.5
b = 1
b = 3
b = 5
(b) cumulative distribution functions
FIGURE 9.3: PDFs and CDFs of the Rayleigh distribution.
>> x=[-eps:-0.02:-0.05,0:0.02:5]; x=sort(x’); b1=[.5,1,3,5]; p=[]; F=[];
for i=1:length(b1) % PDF and CDF plots for diﬀerent values of b
p=[p,raylpdf(x,b1(i))]; F=[F,raylcdf(x,b1(i))];
end
subplot(121), plot(x,p), subplot(122), plot(x,F)
IV. Gamma distribution
The probability density function of the Gamma distribution is deﬁned as
p(x) =
⎧
⎨
⎩
λaxa−1
Γ(a) e−λx
x ⩾0
0
x < 0.
(9-1-9)
The probability density function of Gamma distribution is a function of the parameters
a and λ. The functions gampdf(), gamcdf() and gaminv() and the uniﬁed functions can
be used with the following syntaxes
p = gampdf(x,a,λ), F = gamcdf(x,a,λ), x = gaminv(F ,a,λ)
p = pdf(’gam’,x,a,λ), F = cdf(’gam’,x,a,λ), x = icdf(’gam’,F ,a,λ)

Probability and Mathematical Statistics Problems
443
Example 9.5
For the parameter combinations (a, λ) as (1, 1), (1, 0.5), (2, 1), (1, 2), (3, 1),
draw the probability density functions and cumulative distribution functions of the Gamma
distribution.
Solution
A vector x can be established over the interval (−0.5, 5), two variable vectors
are also deﬁned as a1 and lam1, then, the functions gampdf() and gamcdf() can be used
to plot the probability density functions and cumulative distribution functions as shown in
Figures 9.4 (a) and (b), respectively.
−1
0
1
2
3
4
5
0
0.5
1
1.5
2
a = 1, λ = 0.5
a = 1, λ = 1
 a = 1, λ = 2

a = 2, λ = 1
a = 3, λ = 1
(a) probability density functions
−1
0
1
2
3
4
5
0
0.2
0.4
0.6
0.8
1
a = 1
λ = 0.5
a = 3, λ = 1
a = 1, λ = 1
a = 1, λ = 2
a = 2, λ = 1
(b) cumulative distribution functions
FIGURE 9.4: PDFs and CDFs of the Gamma distribution.
>> x=[-0.5:.02:5]’; p=[]; F=[]; a1=[1,1,2,1,3]; lam1=[1,0.5,1,2,1];
for i=1:length(a1)
p=[p,gampdf(x,a1(i),lam1(i))]; F=[F,gamcdf(x,a1(i),lam1(i))];
end
subplot(121), plot(x,p), subplot(122), plot(x,F)
There is a minor problem in the probability density function curves. Since a step-size of
0.02 is selected to form the x vector, the probability density function will jump from 0 to
the maximum value. To avoid this, the x vector generating statement should be modiﬁed to
>> x=[eps, 0:0.02:5]; x=sort(x’); % insert ϵ in vector
V. χ2 distribution
The probability density function of the χ2 distribution is deﬁned as
p(x) =
⎧
⎪
⎨
⎪
⎩
1
2k/2Γ (k/2)
xk/2−1e−x/2,
x ⩾0
0,
x < 0,
(9-1-10)
where the parameter k is a positive integer. It can also be seen that the χ2 function is a
special Gamma distribution, with a = k/2 and λ = 1/2. The PDF of the χ2 distribution is
also a function of k. The functions chi2pdf(), chi2cdf() and chi2inv() can be used to
evaluate relevant functions for χ2 distribution. The syntaxes of the functions are
p = chi2pdf(x,k), F = chi2cdf(x,k), x = chi2inv(F ,k)
p = pdf(’chi2’,x,k), F = cdf(’chi2’,x,k), x = icdf(’chi2’,F ,k)

444
Scientiﬁc Computing with MATLAB®
Example 9.6
For the parameter k selected as 1, 2, 3, 4, 5, draw the probability density
functions and cumulative distribution functions of χ2 distributions.
Solution Select a vector x within the interval (−0.05, 1), and also deﬁne a vector k1. Call
the functions chi2pdf() and chi2cdf() directly. The PDFs and CDFs can be drawn as
shown in Figures 9.5 (a) and (b), respectively.
>> x=[-eps:-0.02:-0.05,0:0.02:2]; x=sort(x’); k1=1:5; p=[]; F=[];
for i=1:length(k1)
p=[p,chi2pdf(x,k1(i))]; F=[F,chi2cdf(x,k1(i))];
end
subplot(121), plot(x,p), subplot(122), plot(x,F)
0
0.5
1
1.5
2
0
0.5
1
1.5
2
2.5
3
k = 1
k = 2
k = 3
(a) probability density functions
0
0.5
1
1.5
2
0
0.2
0.4
0.6
0.8
1
k = 1
k = 2
k = 3
k = 4
k = 5
(b) cumulative distribution functions
FIGURE 9.5: PDFs and CDFs of the χ2 distribution.
VI. T distribution
The probability density function of the T distribution is deﬁned as
p(x) = Γ ((k + 1)/2)
√
kπ Γ (k/2)

1 + x2
k
−(k+1)/2
,
(9-1-11)
with a positive integer parameter k. The functions tpdf(), tcdf() and tinv() can be used
to evaluate relevant functions, with the syntaxes
p = tpdf(x,k), F = tcdf(x,k), x = tinv(F ,k)
p = pdf(’t’,x,k), F = cdf(’t’,x,k), x = icdf(’t’,F ,k)
Example 9.7
Draw the probability density functions and cumulative distribution
functions of T distribution for k = 1, 2, 5, 10.
Solution
Again an x vector is deﬁned over the interval (−5, 5). Another vector k1 can
also be established and with the following statements, the probability density functions and
cumulative distribution functions can be obtained as shown in Figures 9.6 (a) and (b),
respectively.

Probability and Mathematical Statistics Problems
445
>> x=[-5:0.02:5]’; k1=[1,2,5,10]; p=[]; F=[];
for i=1:length(k1)
p=[p,tpdf(x,k1(i))]; F=[F,tcdf(x,k1(i))];
end
subplot(121), plot(x,p), subplot(122), plot(x,F)
−5
0
5
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
0.4
k = 1
k = 10
k = 5
k = 2
(a) probability density functions
−5
0
5
0
0.2
0.4
0.6
0.8
1
k = 1
k = 10
k = 5
k = 2
(b) cumulative distribution functions
FIGURE 9.6: PDFs and CDFs of the T distribution.
VII. F distribution
The probability density function of the F distribution is deﬁned as
p(x) =
⎧
⎪
⎨
⎪
⎩
Γ ((p + q)/2)
Γ (p/2) Γ (q/2)pp/2qq/2xp/2−1(p + qx)−(p+q)/2,
x ⩾0
0,
x < 0,
(9-1-12)
and the probability density function is a function of parameters p and q, with p and q
positive integers. The syntaxes of the functions are
p = fpdf(x,a,b), F = fcdf(x,p,q), x = finv(F ,p,q)
p = pdf(’f’,x,a,b), F = cdf(’f’,x,p,q), x = icdf(’f’,F ,p,q)
Example 9.8
Draw the probability density functions and cumulative distribution
functions for the T distributions with the (p, q) pairs as (1, 1), (2, 1), (3, 1), (3, 2), (4, 1).
Solution Deﬁne a vector x in the interval (−0.1, 1), and two other vectors p1 and q1 can
be deﬁned for the given pairs. The probability density functions and cumulative distribution
functions can be obtained with the functions fpdf() and fcdf(), as shown in Figures 9.7 (a)
and (b), respectively.
>> x=[-eps:-0.02:-0.05,0:0.02:1]; x=sort(x’);
p1=[1 2 3 3 4]; q1=[1 1 1 2 1]; p=[]; F=[];
for i=1:length(p1)
p=[p,fpdf(x,p1(i),q1(i))]; F=[F,fcdf(x,p1(i),q1(i))];
end
subplot(121), plot(x,p), subplot(122), plot(x,F)

446
Scientiﬁc Computing with MATLAB®
0
0.2
0.4
0.6
0.8
1
0
0.5
1
1.5
2
2.5
(1,1) 
(2,1) 
(3,2) 
(4,1) 
(3,1) 
(a) probability density functions
0
0.2
0.4
0.6
0.8
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
(1,1) 
(2,1) 
(3,2) 
(4,1) 
(3,1) 
(b) cumulative distribution functions
FIGURE 9.7: PDFs and CDFs of the F distribution.
VIII. Alpha-stable distribution
The probability density function of alpha-stable distribution is [3]
p(x) = exp
#
−σα|x|α 
1 −jβ sign(x) tan πα
2

+ jμx
4
,
(9-1-13)
where, 0 < α ⩽2, also known as index of stability, −1 < β < 1 is known as the skewness
parameter, σ > 0 is the scaling factor and μ is the shift, or location parameter. When
β = μ = 0, the distribution is symmetrical.
When α = 1, the distribution is a symmetric Cauchy distribution, whose probability
density function is represented as
p(x) = exp
)
−σ|x|

1 −2j
π β sign(x)ln|x|

+ jμx
$
.
(9-1-14)
A set of alpha-stable functions in MATLAB is written and released by Mark Veillette [4],
the relevant names of the functions are stblpdf(), stblcdf(), stblinv(), stblfit() and
stblrnd(). The syntaxes of the functions are
p = stblpdf(x,α,β,σ,μ), F = stblcdf(x,α,β,σ,μ), x = stblinv(F ,α,β,σ,μ)
It should be noted that since the functions are not those provided in the Statistics
Toolbox, the functions pdf(), cdf() cannot be used in the evaluation of the distribution.
alpha-stable stable distribution is useful in modeling and simulation of stochastic processes
with heavy tails, and it is useful in many ﬁelds such as ﬁnance and economics.
Example 9.9 Please observe the probability density functions of alpha-stable distribution
under diﬀerent combinations of the parameters.
Solution
Assume that β = μ = 0, σ = 1, and change the values of α, the probability
density function curves can be obtained as shown in Figure 9.8 (a). It can be seen that the
curves obtained are symmetrical. If β = 0.5, the probability density functions can also be
obtained, as shown in Figure 9.8 (b), and it can be seen that the distributions are skewed.
>> x=-5:0.01:5; b1=0; b2=0.5; m=0; s=1; Y1=[]; Y2=[];
for a=0.5:0.25:1.5, % try diﬀerent values of α

Probability and Mathematical Statistics Problems
447
Y1=[Y1; stblpdf(x,a,b1,s,m)]; Y2=[Y2; stblpdf(x,a,b2,s,m)];
end
subplot(121), plot(x,Y1); subplot(122), plot(x,Y2)
−5
−4
−3
−2
−1
0
1
2
3
4
5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
α = 0.5
↷
α increasing
(a) symmetric distribution
−5
−4
−3
−2
−1
0
1
2
3
4
5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
α = 0.5
α = 0.75
α = 1.25
1
(b) skewed distribution
FIGURE 9.8: PDFs of alpha-stable distribution.
9.1.3
Random numbers and pseudorandom numbers
In scientiﬁc research and statistical analysis, random data are always expected. There
are two ways of generating random numbers. One is to generate the random numbers by
speciﬁc electronic devices, which is referred to as the physical method. The other method is to
generate random numbers using mathematical algorithms. The random numbers generated
by this method are calculated from corresponding mathematical formulae, and the random
numbers generated are referred to as pseudorandom numbers.
There are two advantages in utilizing pseudorandom numbers. One is that the random
numbers are repeatable for the same random number seed, which makes repetitive
experiments possible. The other advantage is that the distributions of the random numbers
generated can be speciﬁed as needed. For instance, random numbers satisfying uniform
distribution, normal distribution or Poisson distribution, etc. can be selected by the user.
Two functions, rand() and randn(), have been introduced in Section 4.1 for generating
uniformly distributed and normally distributed random matrices. Apart from these two
types of random numbers, other types of random numbers are summarized in Table 9.1. In
particular, several commonly used pseudorandom number generators are list below.
A = gamrnd(a,λ,n,m) % generates an n × m random matrix satisfying Γ
B = chi2rnd(k,n,m)
% generates pseudorandom numbers satisfying χ2
C = trnd(k,n,m)
% T distribution
D = frnd(p,q,n,m)
% F distribution
E = raylrnd(b,n,m)
% Rayleigh distribution
A uniﬁed function random() is used to generate pseudorandom numbers, with the syntax
N = random(type,parameters,n,m), where, type and parameters are the same as the ones
in Table 9.1. For instance, the above A and C matrices can be generated alternatively with
the function

448
Scientiﬁc Computing with MATLAB®
A = random(’gam’,a,λ,n,m), C = random(’t’,k,n,m)
Function rng() can be used to control the generation of pseudorandom numbers, and
the control variables can be obtained with c = rng, where c is a structured variable, with
many useful ﬁelds. For instance, the ﬁeld Seed is useful to select the seed in pseudorandom
number generation. With such a member, the same set of random numbers can be generated
if necessary, so that repetitive experiments are possible.
Example 9.10
Please generate two sets of identical 1000 T distribution pseudorandom
numbers.
Solution If the function random() is called twice, with the same commands, the random
numbers generated are deﬁnitely diﬀerent. This is not good in doing repetitive experiments. If
two sets of identical random numbers are expected, it is useful to save the data. Alternatively,
it is better to have the same type of settings in the random number generators. The following
commands can be used to generate the expected identical pseudorandom numbers.
>> c=rng; A1=random(’t’,1,1,1000); rng(c); % use the same setting
A2=random(’t’,1,1,1000); norm(A1-A2)
% the diﬀerence should be zero
9.2
Solving Probability Problems
Probability is the measure of the likeliness that an event will occur. The computation
of probability is illustrated in this section for discrete numbers and continuous functions.
Diﬀerent kinds of graphical representation approaches are demonstrated in the section. Also,
Monte Carlo algorithm and random walk simulations are presented.
9.2.1
Histogram and pie representation of discrete numbers
Assume that a set of data x1, x2, · · · , xn are measured, and it is known that the numbers
are in the interval (a, b). Sometimes, it is useful to divide the interval into m bins, such that
b1 = a, bm+1 = b. The number kj, j = 1, 2, · · · , m of the samples of xi falling in each bin
(bj, bj+1) can be counted. The entities fj = kj/n are referred to as the frequency.
With MATLAB function hist(), the frequencies can be obtained with
k = hist(x,b); f = k/n; bar(b,f); or pie(f)
With the vectors b and f, the histogram and pie chart can also be obtained. These kinds
of graphical interpretations will be demonstrated through the following examples.
Example 9.11 Generate a 30000×1 vector with numbers satisfying Rayleigh distribution
for b = 1. Verify the probability density function of the random numbers with histograms.
Solution From the above presentations, the function raylrnd() can be used to generate
a vector containing 30000 × 1 random values satisfying Rayleigh distribution. Assigning a
vector xx, the function hist() can be used to evaluate the numbers in each bin deﬁned
in vector xx. In fact, the actual bin should be generated by adding half the width of bin.
The probability density function can be approximated with the bar() function. Also, the
exact result can be obtained for comparison as shown in Figure 9.9. It can be seen that the
generated data correspond to the Rayleigh distribution very well.

Probability and Mathematical Statistics Problems
449
0
0.5
1
1.5
2
2.5
3
3.5
4
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
FIGURE 9.9: Distribution evaluation with Rayleigh functions.
>> b=1; p=raylrnd(1,30000,1); xx=0:.1:4; x1=xx+0.05; yy=hist(p,x1);
yy=yy/(30000*0.1); bar(x1,yy), y=raylpdf(xx,1); line(xx,y)
Example 9.12 Assume that a set of 200 data are measured to the lifetime of incandescent
lamps in given in Table 9.2 [5]. It can be seen that the data are distributed in the intervals
(500, 1500). Please create suitable bins and represent the frequencies with histogram and
pie charts.
TABLE 9.2: Life in hours of 200 incandescent lamps (Data from [5]).
1067
919
1196
785
1126
936
918
1156
920
948
855
1092
1162
1170
929
950
905
972
1035
1045
1157
1195
1195
1340
1122
938
970
1237
956
1102
1022
978
832
1009
1157
1151
1009
765
958
902
923
1333
811
1217
1085
896
958
1311
1037
702
521
933
928
1153
946
858
1071
1069
830
1063
930
807
954
1063
1002
909
1077
1021
1062
1157
999
932
1035
944
1049
940
1122
1115
833
1320
901
1324
818
1250
1203
1078
890
1303
1011
1102
996
780
900
1106
704
621
854
1178
1138
951
1187
1067
1118
1037
958
760
1101
949
992
966
824
653
980
935
878
934
910
1058
730
980
844
814
1103
1000
788
1143
935
1069
1170
1067
1037
1151
863
990
1035
1112
931
970
932
904
1026
1147
883
867
990
1258
1192
922
1150
1091
1039
1083
1040
1289
699
1083
880
1029
658
912
1023
984
856
924
801
1122
1292
1116
880
1173
1134
932
938
1078
1180
1106
1184
954
824
529
998
996
1133
765
775
1105
1081
1171
705
1425
610
916
1001
895
709
610
916
1001
895
709
860
1110
1149
972
1002
Solution For clarity in presentation, the data are stored in a data ﬁle, c9dlamp.dat. The
data can be imported into MATLAB workspace with load() function. The bins can be
selected as [500, 600, 700, · · · , 1500]. In fact, since the width of each bin is 100, half of the
width should be added to the bins to compute their centers before using hist() function, to
count the frequency. The histogram and pie chart of the data can be obtained as shown in
Figure 9.10.
>> A=load(’c9dlamp.dat’); bins=[500:100:1500]+50;
% load data from ﬁle

450
Scientiﬁc Computing with MATLAB®
f=hist(A,bins)/length(A); subplot(121), bar(bins,f) % draw histogram
subplot(122), pie(f)
% draw pie chart
550
650
750
850
950 1050 1150 1250 1350 1450 1550
0
0.05
0.1
0.15
0.2
0.25
0.3
0.35
(a) histogram representation
1%
3%
6%
13%
29%
20%
22%
4%
3%
(b) pie chart
FIGURE 9.10: Histogram and pie chart of the lamp lifetime.
9.2.2
Probability computation of continuous functions
It has been shown earlier that the deﬁnition of the cumulative distribution function F(x)
is the probability of a stochastic variable ξ falling in the interval (−∞, x). For instance, the
probability of the random number ξ falling in the interval [x1, x2] can be represented by
P[x1 ⩽ξ ⩽x2]. The following formulas can be used to evaluate the probabilities
⎧
⎪
⎪
⎨
⎪
⎪
⎩
P[ξ ⩽x] = F(x),
% probability of ξ ⩽x
P[x1 ⩽ξ ⩽x2] = F(x2) −F(x1),
% probability of x1 ⩽ξ ⩽x2
P[ξ ⩾x] = 1 −F(x),
% probability of ξ ⩾x,
(9-2-1)
where the cumulative distribution functions are given.
Example 9.13
Assume that a stochastic variable x satisﬁes Rayleigh distribution, with
b = 1. Compute the probabilities when the variable x falls in the intervals [0.2, 2] and [1, ∞).
Solution The probabilities of the stochastic variable x falling in the intervals (−∞, 0.2] and
(−∞, 2] can easily be found. Therefore, the probability of variable x falling into the interval
[0.2, 2] can be evaluated from
>> b=1; p1=raylcdf(0.2,b); p2=raylcdf(2,b); P1=p2-p1
and the probability is P1 = 0.844863. Also, the probability of the variable x falling in the
interval (1, ∞] can alternatively be evaluated from
>> p1=raylcdf(1,b); P2=1-p1
and the probability can be found as P2 = 0.606531.
For multivariate cases, joint probability density function p(x1, x2, · · · , xn) is used. The
probability of the stochastic variables ξi falling in the area ξi ⩽ai can be evaluated from
P(ξ ⩽a) =
 a1
−∞
 a2
−∞
· · ·
 an
−∞
p(ξ1, ξ2, · · · , ξn) dξn · · · dξ2 dξ1.
(9-2-2)

Probability and Mathematical Statistics Problems
451
Example 9.14
Assume that the joint probability density function of the two stochastic
variables ξ and η is given by
p(x, y) =

x2 + xy
3 ,
0 ⩽x ⩽1, 0 ⩽y ⩽2
0,
otherwise.
Determine the probability P(ξ < 1/2, η < 1/2).
Solution From the given joint probability density function p(x, y), the probability P(ξ <
x0, η < y0) can be evaluated with the following statements
>> syms x y; f=x^2+x*y/3; P=int(int(f,x,0,1/2),y,0,1/2)
and it can be found that the probability is P = 5/192. In the original problem, p(x, y) is
zero when the independent variables x and/or y are zero. Therefore, in the integrals, only
the ﬁrst quadrant is considered.
Example 9.15 Assume that between locations A and B, there are six sets of traﬃc lights.
The probability of a red light at each set of traﬃc lights is the same, with p = 1/3. Suppose
that the number of red traﬃc lights on the road for locations A to B satisﬁes a binomial
distribution B(6, p). Find the probability of the event that one meets only once the red
traﬃc light from A to B. Also, varying the value of p to plot the probability functions.
Solution
Since it is known that at each traﬃc light, the probability of meeting a red
light satisﬁes a binomial distribution, and it can be calculated with functions binopdf() or
pdf(). Assume that the number of meeting red traﬃc light is x, then, the values of x can
be 0, 1, 2, · · · , 6, and the corresponding probability density can be evaluated with
>> x=0:6; y=binopdf(x,6,1/3) % evaluate PDF for binomial distribution
and it can be found that y = [0.0878, 0.2634, 0.3292, 0.2195, 0.0823, 0.0165, 0.0014]. It can be
seen that, the probability of meeting a red light once is 0.2634, and the probability of meeting
a red light at least once can be evaluated in either of the two ways, one is subtract from 1
the probability when no red light is met, while the other is to sum up all but the ﬁrst entity
of y vector. It can be found that the probability is p = 91.22%.
>> P=1-y(1)
%
or to sum up P=sum(y(2:end))
If the value of p in the binomial distribution changes, loop structure can be used to
calculate the probability of meeting at least once, as shown in Figure 9.11.
>> p0=0.05:0.05:0.95; y=[];
for p=p0, y=[y 1-binopdf(0,6,p)]; end, plot(p0,y,1/3,P,’o’)
9.2.3
Monte Carlo solutions to mathematical problems
Buﬀon’s needle is an old example of the statistical experiment, carried out by a French
mathematician Georges-Louis Leclerc, Comte de Buﬀon (1707–1788) in the 18th century.
He dropped a needle onto a ﬂoor, made of parallel strips of wood, and counted the number
of times the needle lie across a line between two strips.
The so-called Monte Carlo method is another interesting statistical experiment to ﬁnd
the values of uncertain variables using a large number of random quantities, based on
random distributions.

452
Scientiﬁc Computing with MATLAB®
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
p = 1/3
FIGURE 9.11: Probability of having at least one red light with diﬀerent p.
Consider the plot shown in Figure 9.12 (a). Generate N sets of two random numbers xi
and yi satisfying uniform distribution in the interval [0, 1]. Assume that the number of points
falling in the quarter circle, i.e., x2
i +y2
i ⩽1, is N1. Since the area of the quarter circle is π/4,
while the area of the square is 1, It is known from probability theory that the probability
of a random point falls in the quarter circle is π/4. If the number of random points is large
enough, it can be seen that N1/N ≈π/4, from which it is found that π ≈4N1/N. The
value of π can be approximated using such a formula.
-
6
x
y
-
6
x
y
integrand f(t)
y = M
x = a
x = b
(a) the value of π
(b) numerical integration
FIGURE 9.12: Applications of Monte Carlo method.
Example 9.16
Use Monte Carlo method to evaluate approximately the value π.
Solution The following MATLAB statements can be used
>> N=100000; x=rand(1,N); y=rand(1,N); i=(x.^2+y.^2)<=1; % random points
N1=sum(i); p=N1/N*4 % approximate the value of π with Monte Carlo method
and it is found that π ≈3.1418. If the value of N further increases, the accuracy may or
may not increase. More importantly, never expect to ﬁnd the exact value of π in this way.
Consider also the deﬁnite integral problem
 b
a
f(x) dx shown in Figure 9.12 (b). Again

Probability and Mathematical Statistics Problems
453
generate N sets of two random numbers xi and yi satisfying the uniform distribution in the
intervals [a, b] and (0, M), respectively. For a value of xi, the numbers of points satisfying
f(xi) ⩽yi is counted as N1. It is found that N1
N ≈
1
M(b −a)
 b
a
f(x) dx, from which the
integral can be approximated with [6]
 b
a
f(x) dx ≈M(b −a)N1
N
.
(9-2-3)
It should be noted that the evaluation is only possible when M ⩾f(x) ⩾0, otherwise,
modiﬁed representations should be used.
Example 9.17
Evaluate
 3
1

1 + e−0.2x sin(x + 0.5)

dx using Monte Carlo method.
Solution The following statements can be used, and the integral can be evaluated numeri-
cally and analytically such that p = 2.7395, I = 2.74393442001018.
>> f=@(x)1+exp(-0.2*x).*sin(x+0.5); a=1; b=3; M=2; N=100000;
x=a+(b-a)*rand(N,1); y=M*rand(N,1); i=y<=f(x); N1=sum(i);
p=M*N1*(b-a)/N
% approximately compute integral with Monte Carlo method
syms x; I=vpa(int(1+exp(-0.2*x)*sin(x+0.5),x,a,b)) % direct integral
9.2.4
Simulation of random walk processes
Brownian motion is an interesting stochastic process. Suppose there is a particle in a two-
dimensional plane, it moves randomly in speed and direction. For simplicity, the position
of it can be evaluated recursively from
xi+1 = xi + σΔxi, yi+1 = yi + σΔyi,
(9-2-4)
where σ is the scaling factor related to the diﬀusion coeﬃcient. The increments Δxi and
Δyi satisﬁes standard normal distribution. Simulation is an eﬀective approach in studying
this kind of process.
Example 9.18
Please study with simulation approach for Brownian motion. If the
increments are replaced by alpha-stable distribution process, please study the motion.
Solution For simplicity, select σ = 1 in both the two processes. The following statements
can be used to compute Brownian motion and alpha-stable motion, with α = 1.5, as shown
in Figures 9.13 (a) and (b), respectively. The alpha-stable motion is also known as L´evy
ﬂight.
>> n=1000; x=zeros(2,n); y=zeros(2,n); s=1; r1=randn(2,n); a=1.5;
r2=stblrnd(a,0,1,0,2,n); % generate alpha-stable random numbers
for i=2:n, % compute recursively with loop structure
x(1,i)=x(1,i-1)+s*r1(1,i); y(1,i)=y(1,i-1)+s*r1(2,i);
x(2,i)=x(2,i-1)+s*r2(1,i); y(2,i)=y(2,i-1)+s*r2(2,i);
end
subplot(121), plot(x(1,:),y(1,:),’-o’) % draw Brownian motion
subplot(122), plot(x(2,:),y(2,:),’-o’) % draw alpha-stable motion

454
Scientiﬁc Computing with MATLAB®
−70
−60
−50
−40
−30
−20
−10
0
10
−20
−15
−10
−5
0
5
10
15
20
25
30
(a) Brownian motion
−50
0
50
100
150
200
−140
−120
−100
−80
−60
−40
−20
0
20
(b) alpha-stable motion
FIGURE 9.13: Random walk plots.
9.3
Fundamental Statistical Analysis
9.3.1
Mean and variance of stochastic variables
Assume that the probability density function of a continuous stochastic variable x is
given by p(x). The following formulae can be used to evaluate the mathematical expectation
E[x] and the variance D[x], respectively:
E[x] =
 ∞
−∞
xp(x) dx, D[x] =
 ∞
−∞
(x −E[x])2 p(x) dx,
(9-3-1)
and mathematical expectation is also known as the mean of the function.
Clearly, these two important statistical quantities or statistics can be evaluated through
the direct integral approach.
Example 9.19 Calculate the mean and variance of Gamma distribution with a > 0, λ > 0
using direct integration method.
Solution
The following statements can be used to evaluate the mean and variance of
Gamma distribution analytically:
>> syms x; syms a lam positive
p=lam^a*x^(a-1)/gamma(a)*exp(-lam*x); m=int(x*p,x,0,inf)
s=simplify(int((x-1/lam*a)^2*p,x,0,inf))
The results obtained are m = a/λ and s = a/λ2, while unfortunately, the latter one can
only be obtained with earlier versions of MATLAB.
For a set of measured data x1, x2, x3, · · · , xn, the sample mean and sample variance are
alternatively deﬁned as
¯x = 1
n
n

i=1
xi, ˆs2
x =
1
n −1
n

i=1
(xi −¯x)2,
(9-3-2)
with ˆsx referred to as the standard deviation.

Probability and Mathematical Statistics Problems
455
Another important quantity is the median value. For a given set of sorted data x1 ⩽
x2 ⩽· · · ⩽xn, if n is odd, the median value is deﬁned as x(n+1)/2; while if n is even, the
median value is deﬁned as (xn/2−1 + xn/2+1)/2.
Like sample mean values, median values are sometime important in statistics. Consider
the case, there is a set of normally distributed data, and the range of all the numbers are
around (−5, 5), but there are a couple of points in the set located far away. For instance,
their values are about 30. These points are considered as outliers, and due to the existence
of these points, the sample mean value may be seriously aﬀected, while the median values
are unchanged.
Let a set of measured data be expressed by vector x = [x1, x2, x3, · · · , xn]T. The
MATLAB functions mean(), var(), std() and median() can be used to evaluate the sample
mean, sample variance, standard deviation and median value, respectively, with
m = mean(x), s2 = var(x), s = std(x), m1 = median(x)
These four functions can also be used to process the data given in matrices on a column
basis. Also, these functions can be used to measure the properties of all the elements in a
matrix or multi-dimensional array with the command m1 = mean(x(:)).
Example 9.20
Generate a set of 30000 normally distributed random numbers with the
mean and variance given by 0.5 and 1.52, respectively. Compute the sample mean and
variance of the generated data. If the total number of points is signiﬁcantly reduced, what
may happen?
Solution
The following statements can be used to generate the random numbers. The
sample mean, variance, standard deviation and median value can be evaluated directly from
>> p=random(’norm’,0.5,1.5,30000,1); mean(p), var(p), std(p), median(p)
and it can be seen that μ = 0.4990, σ2 = 2.2188 and ¯s = 1.4896, m1 = 0.5066, pretty
close to the original exact values. If one reduces the number of points, for instance to 300
points, the following statements can be used, and it can be seen that the statistical quantities
become μ = 0.4698, σ2 = 2.5523, ¯s = 1.5976, m1 = 0.4557, which deviates far away from
the expected values.
>> p=random(’norm’,0.5,1.5,300,1); mean(p), var(p), std(p), median(p)
The commonly encountered distribution functions have been summarized earlier. If the
distribution is given, the functions such as normstat() and gamstat() can be used directly
to evaluate the mean and variance of the normal and Gamma distributions. Similar to the
suﬃx pdf, the suﬃx stat is used to indicate the statistics properties. For instance, the
syntax of gamstat() is [μ,σ2] = gamstat(a,λ), where the returned arguments are the
mean and variance of the given distribution.
Example 9.21
Evaluate the mean and variance of Rayleigh distribution with the
parameter b=0.45.
Solution Since Rayleigh distribution is considered, the function raylstat() should be used,
and the mean and variance of the distribution can be evaluated as m = 0.5640, s = 0.0869.
>> b=0.45; [m,s]=raylstat(b) % compute the mean and variance

456
Scientiﬁc Computing with MATLAB®
9.3.2
Moments of stochastic variables
Suppose that x is a continuous variable, and p(x) is its probability density function; its
rth raw moment and rth central moment are deﬁned as
νr =
 ∞
−∞
xrp(x) dx,
μr =
 ∞
−∞
(x −μ)rp(x) dx,
(9-3-3)
and it can be seen that ν1 = E[x], μ2 = D[x].
Example 9.22
Consider the raw moment and central moment problems for Gamma
distributions in Example 9.19. Summarize the general formula from the ﬁrst few quantities.
Solution The raw moment of the signal can easily be evaluated from
>> syms x; syms a lam positive; p=lam^a*x^(a-1)/gamma(a)*exp(-lam*x);
for n=1:6, m=factor(int(x^n*p,x,0,inf)), end % compute the raw moments
and the ﬁrst ﬁve raw moments are
a
λ,
a
λ2 (a+1),
a
λ3 (a+1)(a+2),
a
λ4 (a+1)(a+2)(s+3),
a
λ5 (a+1)(a+2)(a+3)(a+4),
a
λ6 (a+1)(a+2)(a+3)(a+4)(a+5)
which can be summarized as
νk = 1
λk a(a + 1)(a + 2) · · · (a + k −1) = 1
λk
k−1

i=0
(a + k) = λ−kΓ(a + k)
Γ(a)
.
In fact these results can also be obtained from
>> syms k x; assume(k,’integer’); assumeAlso(k>0) %
k is a positive integer
m=simplify(int((x)^k*p,x,0,inf))
with m = λ−kΓ(k + a)/Γ(a), which is exactly the same as the one summarized above.
Similarly, the central moments of the stochastic variable can be evaluated from
>> for n=1:7, s=simplify(int((x-1/lam*a)^n*p,x,0,inf)), end
The ﬁrst seven central moments obtained are (again the results can only be obtained with
MATLAB R2008a or earlier versions)
0,
a
λ2 , 2a
λ3 , 3a(a + 2)
λ4
, 4a(5a + 6)
λ5
, 5a(3a2 + 26a + 24)
λ6
, 6a(35a2 + 154a + 120)
λ7
.
No further compact formulae, however, can be summarized from the above results.
For a set of random samples x1, x2, · · · , xn, the rth raw moment and central moment
are deﬁned as
Ar = 1
n
n

i=1
xr
i ,
Br = 1
n
n

i=1
(xi −¯x)r.
(9-3-4)
The moment() function provided in the Statistics Toolbox can be used to evaluate the
central moments of all given order. There is no such function to evaluate the raw moment.
In fact, according to the deﬁnition, the rth raw and central moments can be evaluated from
Ar = sum(x.^r)/length(x), and
Br = moment(x,r)

Probability and Mathematical Statistics Problems
457
Example 9.23
Consider again the random numbers generated earlier. Please ﬁnd the
moments from the generated pseudorandom numbers.
Solution The moments of diﬀerent orders can be evaluated with
>> A=[]; B=[]; p=normrnd(0.5,1.5,30000,1); n=1:5;
for r=n, A=[A, sum(p.^r)/length(p)]; B=[B,moment(p,r)]; end
and the moments obtained are
A = [0.508053449, 2.5154715759, 3.5456642980, 18.8911497429, 40.791198267]
B = [0, 2.257353268872, −0.026041939834, 15.381462246655, −1.208702122593].
Actually, the analytical method can be used to evaluate the exact values of the moments,
with the following statements
>> syms x; A1=[]; B1=[]; p=1/(sqrt(2*pi)*1.5)*exp(-(x-0.5)^2/(2*1.5^2));
for i=1:5
A1=[A1,vpa(int(x^i*p,x,-inf,inf),12)];
B1=[B1,vpa(int((x-0.5)^i*p,x,-inf,inf),12)];
end
with A1 = [0.5, 2.5, 3.5, 18.625, 40.8125], and B1 = [0, 2.25, 0, 15.1875, 0], which agree very
well with the above numerical results.
9.3.3
Covariance analysis of multivariate stochastic variables
Assume that the data pairs (x1, y1), (x2, y2), (x3, y3), · · · , (xn, yn) are samples of a
function with two stochastic variables (x, y). The covariance sxy and correlation coeﬃcient
η of the two variables are deﬁned as
sxy =
1
n −1
n

i=1
(xi −¯x)(yi −¯y),
η = sxy
sxsy
,
(9-3-5)
and from the above deﬁnition, a matrix C can also be deﬁned
C =

cxx
cxy
cyx
cyy

,
(9-3-6)
where cxx = σ2
x, cxy = cyx = sxy and cyy = σ2
y. The matrix C is referred to as the covariance
matrix.
The deﬁnition of the covariance matrix with more variables can also be extended from
the above deﬁnition. The function cov() can also be used to evaluate the covariance matrix,
with the syntax C = cov(X), where each column in matrix X is regarded as the samples
of a random signal. If X is a vector, however, the sample variance will be returned instead.
Example 9.24
Generate four sets of standard normally distributed random data points.
Evaluate the covariance matrix for the four signals.
Solution The random signals can be generated with the randn() function, such that it has
four columns, each one containing 30000 elements. This means that four signals are deﬁned
with each one containing 30000 samples. The covariance matrix can then be obtained, and
theoretically, it should be an identity matrix, if the four signals generated are independent.

458
Scientiﬁc Computing with MATLAB®
>> p=randn(30000,4); C=cov(p) % compute covariance matrix
The covariance matrix can be found as follows, which is quite near to an identity matrix.
Thus, the four signals generated this way are indeed independent.
C =
⎡
⎢⎢⎣
1.006377779
0.001258868464
0.004726044354
−0.000519010644
0.001258868464
1.003955935
−0.000945450079
0.004802025815
0.004726044354
−0.000945450079
1.011043483
−0.01189535769
−0.0005190106435
0.004802025815
−0.01189535769
0.9947556372
⎤
⎥⎥⎦.
9.3.4
Joint PDFs and CDFs of multivariate normal distributions
Assume that a set of n stochastic variables ξ1, ξ2, · · · , ξn satisfy normal distribution.
Also, it is assumed that their means are μ1, μ2, · · · , μn, from which a mean vector μ can
be deﬁned. The covariance matrix can be represented as Σ2. Thus, the joint probability
density function is deﬁned as
p(x1, x2, · · · , xn) =
1
√
2π Σ−1e−(x−µ)TΣ−2(x−µ)/2,
(9-3-7)
where x = [x1, x2, · · · , xn]T.
The function mvnpdf() is provided in Statistics Toolbox to evaluate the joint PDF,
with the following syntax p = mvnpdf(X,μ,Σ2), where X is a matrix with n columns,
each representing a stochastic variable.
Example 9.25
If the mean vector and covariance matrix are deﬁned as μ = [−1, 2]T,
Σ2 = [1, 1; 1, 3], draw the joint probability density function. If the covariance matrix is a
diagonal matrix, draw the surface of new joint probability density function.
Solution The random matrix with two columns can be generated from the grid data obtained
with the meshgrid() function. The function mvnpdf() can be used to evaluate the joint
probability density function as a column vector. The function reshape() can be used to
restore the grid matrix. The surface of the joint probability density function can be obtained
as shown in Figure 9.14 (a).
>> mu1=[-1,2]; Sigma2=[1 1; 1 3]; % mean vector and covariance matrix
[X,Y]=meshgrid(-3:0.1:1,-2:0.1:4); xy=[X(:) Y(:)];
% grid data
p=mvnpdf(xy,mu1,Sigma2); P=reshape(p,size(X));
% joint pdf
surf(X,Y,P)
% the surface of the joint pdf
If diagonal covariance matrix is studied, the following statements can then be introduced,
and the joint probability density function can be obtained as shown in Figure 9.14 (b).
>> Sigma2=diag(diag(Sigma2));
% eliminate the non-diagonal elements
p=mvnpdf(xy,mu1,Sigma2); P=reshape(p,size(X)); surf(X,Y,P)
The mvnrnd() function provided in the Statistics Toolbox can be used to gener-
ate multivariate pseudorandom numbers under normal distribution, with the syntax
R = mvnrnd(μ,Σ2,m,n), where the m sets of random numbers will be returned in an
m × n matrix R, with each column corresponding to a random signal.

Probability and Mathematical Statistics Problems
459
−3
−2
−1
0
1
−2
0
2
4
0
0.02
0.04
0.06
0.08
0.1
0.12
(a) original covariance matrix
−3
−2
−1
0
1
−2
0
2
4
0
0.02
0.04
0.06
0.08
0.1
(b) diagonal covariance matrix
FIGURE 9.14: The joint probability density function surface.
Example 9.26
Observe the two types of normally distributed random numbers with
speciﬁcations in Example 9.25.
Solution The following statements can be used to generate the two sets of random numbers,
with each set containing 2000 samples. The distribution of the samples on the x-y plane are
obtained as shown in Figures 9.15 (a) and (b), respectively. It can be seen that when the
covariance matrix is diagonal, there is no relationship between the two variables. Thus, the
variables are independent.
>> mu1=[-1,2]; Sigma2=[1 1; 1 3]; % non-diagonal covariance matrix
R1=mvnrnd(mu1,Sigma2,2000); subplot(121), plot(R1(:,1),R1(:,2),’o’)
Sigma2=diag(diag(Sigma2)); % create a diagonalized covariance matrix
R2=mvnrnd(mu1,Sigma2,2000); subplot(122), plot(R2(:,1),R2(:,2),’o’)
−5
−4
−3
−2
−1
0
1
2
3
−4
−2
0
2
4
6
8
(a) covariance matrix
−5
−4
−3
−2
−1
0
1
2
3
−4
−2
0
2
4
6
8
(b) diagonal covariance matrix
FIGURE 9.15: Distribution of two-dimensional stochastic variables.
9.3.5
Outliers, quartiles and box plots
An outlier is an observation that lies outside the overall pattern of a distribution [7]. Some
of the outliers can be spotted by direct observations from the data set, with histograms or

460
Scientiﬁc Computing with MATLAB®
data distribution plots. It is usually helpful to spot and remove the outliers, especially in
multivariate cases.
The concept of median value, also known as the second quartile q2, of the vector v
was discussed earlier. With the concept median value in mind, the original data vector can
further be divided into two halves, one with data smaller than the median value, denoted as
v1, and the other, denoted by v3. The median values, q1 and q3, of the two vectors can also
be obtained. The three median values are denoted as quartiles, and can be obtained with
q = quantile(v,3), where q = [q1, q2, q3]. The quartiles q1 and q3 are referred to the ﬁrst
and third quartiles of the data set. The interquartile range (IQR) is deﬁned as the distance
between the ﬁrst and third quartiles, IQR = q3 −q1, and the data fall 1.5 × IQR above q3
or below q1 are considered the outliers.
The box plot of the data vector v can be obtained with boxplot(v). The concept of
the box plot will be presented through an example.
Example 9.27
Consider the data set studied in Example 9.12. Draw and interpret the
box plot, and ﬁnd the quartiles and outliers.
Solution The box plot of the data set can be obtained directly with the following function
calls, as shown in Figure 9.16.
>> A=load(’c9dlamp.dat’); boxplot(A), q=quantile(A,3)
In the box plot, we can see the three horizontal lines in the box, representing the values of
q = [909.5, 997, 1108], the quartiles. Also, it can be seen that there are crosses, marked for
the outliers in the data set. The other two horizontal lines are the minimum and maximum
values, after the outliers excluded.
500
600
700
800
900
1000
1100
1200
1300
1400
1
q1
q2
q3
3 outliers
outlier
minimum
maximum
FIGURE 9.16: The box plot with quartiles and outliers.
In the syntax of boxplot() function, if v is a matrix with m columns, m boxes will be
displayed in the plot.
An alternative function outliers() is written by Niccolo Battistini [8] of Rutgers
University. The outliers in a vector v can be detected with interquartile range method,
as well as Grubbs method. The syntax of the function is [v1,v2] = outliers(v,opts,α),
where opts can be ’grubbs’ or ’quartile’, however, the former one is recommended, and
α is the signiﬁcance level. The returned vector v2 contains the outliers, while v1 is the
vector with outliers removed.

Probability and Mathematical Statistics Problems
461
Example 9.28
Consider again the data in Example 9.27. Please ﬁnd the outliers with
Grubbs method.
Solution With the following statements, the outliers can be detected and returned in vector
v2, with v2 = [521, 529].
>> A=load(’c9dlamp.dat’); [v1 v2]=outliers(A,’grubbs’,0.05)
For multivariate problems, an outlier detection function moutlier1() written by Anto-
nio Trujillo-Ortiz [9] of Universidad Autonoma de Baja California, Mexico is recommended,
with moutlier1(X,α), with X the m column matrix, and α the signiﬁcance level.
Example 9.29
The information of 29 NBA teams were given in Table 9.3 [7]. Please ﬁnd
the outliers in the multivariate problem.
TABLE 9.3: Some data of NBA teams (Data from [7]).
team
value
revenue
income
team
value
revenue
income
number
($millions)
($millions)
($millions)
number
($millions)
($millions)
($millions)
1
447
149
22.8
2
401
160
13.5
3
356
119
49
4
338
117
−17.7
5
328
109
2
6
290
97
25.6
7
284
102
23.5
8
283
105
18.5
9
282
109
21.5
10
280
94
10.1
11
278
82
15.2
12
275
102
−16.8
13
274
98
28.5
14
272
97
−85.1
15
258
72
3.8
16
249
96
10.6
17
244
94
−1.6
18
239
85
13.8
19
236
91
7.9
20
230
85
6.9
21
227
63
-19.7
22
218
75
7.9
23
216
80
21.9
24
208
72
15.9
25
202
78
-8.4
26
199
80
13.1
27
196
70
2.4
28
188
70
7.8
29
174
70
-15.1
Solution The data can be entered into MATLAB workspace ﬁrst, and with the moutlier1()
function call, the 14th team is spotted as the outlier.
>> X=[447,149,22.8; 401,160,13.5; 356,119,49; 338,117,-17.7; 328,109,2;
290,97,25.6; 284,102,23.5; 283,105,18.5; 282,109,21.5; 280,94,10.1;
278,82,15.2; 275,102,-16.8; 274,98,28.5; 272,97,-85.1; 258,72,3.8;
249,96,10.6; 244,94,-1.6; 239,85,13.8; 236,91,7.9; 230,85,6.9;
227,63,-19.7; 218,75,7.9; 216,80,21.9; 208,72,15.9; 202,78,-8.4;
199,80,13.1; 196,70,2.4; 188,70,7.8; 174,70,-15.1];
moutlier1(X,0.05)
% ﬁnd outliers from the multivariate problem
The result can be veriﬁed with the projections of the scatter plot on x–y, x–z and y–z
planes, as shown in Figure 9.17.
>> subplot(131), plot(X(:,1),X(:,2),’o’) % projection on x--y plane
subplot(132), plot(X(:,1),X(:,3),’o’) % projection on x--z plane
subplot(133), plot(X(:,2),X(:,3),’o’) % projection on y--z plane

462
Scientiﬁc Computing with MATLAB®
It is obvious from Figures 9.17 (b) and (c) that, the data in the 14th team is indeed the
outliers, from multivariate point of view.
150
200
250
300
350
400
450
60
70
80
90
100
110
120
130
140
150
160
(a) x–y plane
150
200
250
300
350
400
450
−100
−50
0
50
14th team
(b) x–z plane
60
80
100
120
140
160
−100
−50
0
50
14th team
(c) y–z plane
FIGURE 9.17: Projections of 3D scatter plot on diﬀerent planes.
9.4
Statistical Estimations
9.4.1
Parametric estimation and interval estimation
If a set of data x = [x1, x2, · · · , xn]T is measured, and it is known that they
satisfy a certain distribution, for instance, normal distribution, the function normfit()
can be used to evaluate the mean μ and variance σ2
via maximum likelihood
method. Also, the conﬁdence intervals Δμ and Δσ2 can be obtained, with the syntax
[μ,σ2,Δμ,Δσ2] = normfit(x,Pci), where the argument Pci is the conﬁdence level, for
instance, 0.95 for 95% of conﬁdence. The function norminv() can then be used to evaluate
the relevant needed quantities. It can be predicted that the bigger the value of Pci, the
narrower the conﬁdence interval, and the more accurate the parameters are estimated.
Similar to the PDFs, other functions for evaluating the means and variances for
other distributions can also be made. For instance, the mean and variance of Gamma
distribution can be estimated by using gamfit(), and those for Rayleigh distribution by
using raylfit(), as summarized in Table 9.1.
Example 9.30
Generate a set of random numbers with Gamma distribution, where a =
1.5 and λ = 3. From the generated data, the parameters can be estimated with diﬀerent
conﬁdence levels, and compare the results.
Solution First, generate a set of 30000 random data. Select the conﬁdence levels at 90%,
92%, 95%, 98%. The following statements can be used to estimate the parameters with the
given conﬁdence levels
>> p=gamrnd(1.5,3,30000,1); Pv=[0.9,0.92,0.95,0.98]; A=[];
for i=1:length(Pv) % try diﬀerent conﬁdence levels
[a,b]=gamfit(p,Pv(i)); A=[A; Pv(i),a(1),b(:,1)’,a(2),b(:,2)’];
end

Probability and Mathematical Statistics Problems
463
The results are obtained and shown in Table 9.4. It can be seen that the estimated
parameters are not aﬀected with the conﬁdence levels. However, the conﬁdence intervals can
be diﬀerent. Normally, a conﬁdence level of 95% should be used.
TABLE 9.4: Parameter estimation results.
conﬁdence
estimation results of a
estimation results of λ
level
ˆa
amin
amax
ˆλ
λmin
λmax
90%
1.506500556
1.505099132
1.507901979
2.991117941
2.987797191
2.994438691
92%
1.506500556
1.505380481
1.507620631
2.991117941
2.988463861
2.993772021
95%
1.506500556
1.505801226
1.507199886
2.991117941
2.98946084
2.992775042
98%
1.506500556
1.506220978
1.506780134
2.991117941
2.990455465
2.991780417
Now consider the impact of the size of random number group on the estimation, by
selecting respectively 300, 3000, 30000, 300000, 3000000 random numbers. The conﬁdence
level of 95% is assumed; therefore, the estimation intervals may also change and the
variations are shown in Table 9.5.
TABLE 9.5: Parameter estimation results.
number of
estimation results of a
estimation results of λ
values
ˆa
amin
amax
ˆλ
λmin
λmax
300
1.548677954
1.540991679
1.55636423
2.91172985
2.896265076
2.927194623
3000
1.476057561
1.473908973
1.47820615
3.040589493
3.035438607
3.04574038
30000
1.503327455
1.502624743
1.504030167
2.976242793
2.974591027
2.977894559
300000
1.509546583
1.509323617
1.50976955
2.984774009
2.984252596
2.985295421
3000000
1.498005677
1.497935817
1.498075536
3.006048895
3.005882725
3.006215065
>> num=[300,3000,30000,300000,3000000]; A=[];
for i=1:length(num), p=gamrnd(1.5,3,num(i),1);
[a,b]=gamfit(p,0.95); A=[A;num(i),a(1),b(:,1)’,a(2),b(:,2)’];
end
It can be seen from the table that, when the number of random samples is small, the
estimated parameters may not be satisfactory. Normally 30,000 samples are acceptable.
9.4.2
Multivariate linear regression and interval estimation
Assume that the output signal y is the linear combination of n input signals
x1, x2, · · · , xn such that
y = a1x1 + a2x2 + a3x3 + · · · + anxn,
(9-4-1)

464
Scientiﬁc Computing with MATLAB®
where a1, a2, · · · , an are undetermined constants. Assume that m groups of experiments are
made with the measured data arranged in the following format:
y1 = x11a1 + x12a2 + · · · + x1,nan + ε1
y2 = x21a1 + x22a2 + · · · + x2,nan + ε2
...
ym = xm1a1 + xm2a2 + · · · + xm,nan + εm.
(9-4-2)
where εi is the measuring error of the ith observation. The following matrix equation can
then be set up
y = Xa + ε,
(9-4-3)
where a = [a1, a2, · · · , an]T is the vector with undetermined constants. If the original data
were obtained in experiments, there exist errors in each equation in (9-4-1) denoted by
ε = [ε1, ε2, · · · , εm]T. Also, the vector y = [y1, y2, · · · , ym]T is the observed value, and the
matrix X is composed of observed independent variables such that
X =
⎡
⎢⎢⎢⎢⎢⎣
x11
x12
· · ·
x1n
x21
x22
· · ·
x2n
...
...
...
...
xm1
xm2
· · ·
xmn
⎤
⎥⎥⎥⎥⎥⎦
.
(9-4-4)
Assume that the objective function for the problem is to have the minimized sum of the
squared errors, i.e., J = min εTε, then, the undetermined constant vector a of the linear
regression model can be obtained from
ˆa = (XTX)−1XTy.
(9-4-5)
From the knowledge of linear algebra illustrated in Chapter 4, the least squares
solution to the above equation can be obtained from a = X\y
or more formally
a = inv(X’*X)*X’*y.
A multivariate linear regression function regress() for parameter estimation and
conﬁdence interval estimation is provided in MATLAB, and the syntax of the function
is [ˆa,aci] = regress(y,X,α), where 1 −α is the conﬁdence level speciﬁed by the user.
Example 9.31
Assume that the linear regression model is
y = x1 −1.232x2 + 2.23x3 + 2x4 + 4x5 + 3.792x6.
With 120 set of generated data points xi, the output vector y can be computed ﬁrst.
Based on this information, the undetermined constants ai can be estimated, with given
conﬁdence intervals.
Solution
Linear regression can be used to process the generated data. The following
statements can be used to construct the matrix X and the vector y. The least squares
method can be used to estimate the undetermined constants a under 98% of conﬁdence.
>> a=[1 -1.232 2.23 2 4,3.792]’; X=randn(120,6); y=X*a; % generate data
[a,aint]=regress(y,X,0.02) % multivariate linear regression and intervals

Probability and Mathematical Statistics Problems
465
The estimated parameter and the conﬁdence interval can be obtained as
a =
⎡
⎢⎢⎢⎢⎢⎢⎣
1
−1.232
2.23
2
4
3.792
⎤
⎥⎥⎥⎥⎥⎥⎦
,
aint =
⎡
⎢⎢⎢⎢⎢⎢⎣
1
1
−1.232
−1.232
2.23
2.23
2
2
4
4
3.792
3.792
⎤
⎥⎥⎥⎥⎥⎥⎦
.
It can be seen that there is no error in the estimated results, and the conﬁdence interval
is 100%. If the samples are corrupted by noises, for instance, normally distributed noise
N(0, 0.5) can be added to the samples within the interval. The following statements can then
be used to perform linear regression analysis. The estimated parameters and their conﬁdence
intervals can be obtained and shown in Figure 9.18 (a), with errorbar() function.
>> yhat=y+sqrt(0.5)*randn(120,1); [a,aint]=regress(yhat,X,0.02)
errorbar(1:6,a,aint(:,1)-a,aint(:,2)-a) % regression parameters
0
1
2
3
4
5
6
7
−2
−1
0
1
2
3
4
5
(a) with noise σ2 = 0.5
0
1
2
3
4
5
6
7
−2
−1
0
1
2
3
4
5
(b) with noise σ2 = 0.1
FIGURE 9.18: Parameter estimations with conﬁdence intervals.
The parameters and the intervals are obtained as
a =
⎡
⎢⎢⎢⎢⎢⎢⎣
1.03887888369425
−1.20360949260729
2.19454416841833
1.89146235051598
34.0628445587228
8.70540411609337
⎤
⎥⎥⎥⎥⎥⎥⎦
,
aint =
⎡
⎢⎢⎢⎢⎢⎢⎣
0.92959508774995
1.14816267963855
−1.313314026578
−1.09390495863658
2.07413724843311
2.31495108840356
1.77199410730299
2.01093059372896
33.9418338141614
34.1838553032841
8.59651534574785
8.8142928864389
⎤
⎥⎥⎥⎥⎥⎥⎦
.
Reducing the variance to 0.1, the estimated parameters are obtained using the following
statements as shown in Figure 9.18 (b). It can be seen that the estimation results are even
more accurate.
>> yhat=y+sqrt(0.1)*randn(120,1); [a,aint]=regress(yhat,X,0.02);
errorbar(1:6,a,aint(:,1)-a,aint(:,2)-a) % regression parameters

466
Scientiﬁc Computing with MATLAB®
9.4.3
Nonlinear least squares parametric and interval estimations
Assume that a set of data xi, yi, i = 1, 2, · · · , N is measured satisfying a given prototype
functional relationship ˆy(x) = f(a, x), where a is the vector containing undetermined
constants. Since the measured data is corrupted with noises, the original function can be
written as ˆy(x) = f(a, x) + ε, where ε represents the residual error. An objective function
can be introduced
I = min
a
N

i=1
[yi −ˆy(xi)]2 = min
a
N

i=1
[yi −f(a, xi)]2.
(9-4-6)
Minimizing the above objective function, the undetermined constants a can be
estimated. Substituting the estimated a back to the prototype function, the residue error
εi = yi −f(a, xi) can be obtained. Similar to the least squares estimation shown in Section
8.3.3, the least squares ﬁtting with Levenberg–Marquardt algorithm is implemented in the
function nlinfit(). The Jacobian vector ji of the residual error with respect to a can
also be obtained. Conﬁdence interval estimation can also be obtained with the function
nlparci(), and the results can be obtained with 95% conﬁdence level, with the syntaxes
[a,r,J] = nlinfit(x,y,fun,a0)
% least squares estimation
c = nlparci(a,r,J)
% conﬁdence interval with 95% of conﬁdence
where x and y contain the measured data. The function fun represents the prototype
function, which can be described either by an M-function, an anonymous function or an
inline function. The initial values a0 of the estimated parameters should also be speciﬁed.
It can be seen that the input arguments are the same as the lsqcurvefit() function. The
returned argument a vector contains the estimated parameters, and r returns the residue
error vector for the estimation. Matrix J is the Jacobian and based on the information, the
estimation of conﬁdence intervals c can be found. The parametric estimation and conﬁdence
interval estimation are illustrated by the following examples.
Example 9.32
The parametric estimation can be performed to the measured data in
Example 8.25 with least squares ﬁtting method. The 95% conﬁdence level is assumed.
Please solve the parametric estimation and conﬁdence interval estimation problems.
Solution
Assume that the prototype function is in the form of y(x) = a1e−a2x +
a3e−a4x sin(a5x), where the parameters ai are the undetermined constants. An anonymous
function can be used to describe the prototype function and the undetermined constants can
be evaluated by using nlinfit() function
>> f=@(a,x)a(1)*exp(-a(2)*x)+a(3)*exp(-a(4)*x).*sin(a(5)*x);
x=0:0.1:10; y=f([0.12,0.213,0.54,0.17,1.23],x);
[a,r,j]=nlinfit(x,y,f,[1;1;1;1;1]); ci=nlparci(a,r,j)
and it is found that
a =
⎡
⎢⎢⎢⎢⎣
0.11999999763418
0.21299999458274
0.54000000196818
0.17000000068705
1.22999999996315
⎤
⎥⎥⎥⎥⎦
,
ci =
⎡
⎢⎢⎢⎢⎣
0.11999999712512
0.11999999814323
0.21299999340801
0.21299999575747
0.54000000124534
0.54000000269101
0.17000000036077
0.17000000101332
1.22999999978603
1.23000000014028
⎤
⎥⎥⎥⎥⎦
.
It can be seen that the results obtained are more accurate than the default results obtained

Probability and Mathematical Statistics Problems
467
with lsqcurvefit(). However, more accurate results are not possible. The associated
nlparci() function can be used to get the conﬁdence intervals for the parameters, with
95% of conﬁdence level.
If the original samples yi are corrupted with noises uniformly distributed in the interval
[0, 0.02], the following statements can be used to estimate the parameters and conﬁdence
intervals for the new samples
>> y=f([0.12,0.213,0.54,0.17,1.23],x)+0.02*rand(size(x));
[a,r,j]=nlinfit(x,y,f,[1;1;1;1;1]); ci=nlparci(a,r,j)
errorbar(1:5,a,ci(:,1)-a,ci(:,2)-a)
and it can be found that
a =
⎡
⎢⎢⎢⎢⎣
0.12281531581639
0.17072641296744
0.55113088779121
0.17347639675132
1.2291686258648
⎤
⎥⎥⎥⎥⎦
,
ci =
⎡
⎢⎢⎢⎢⎣
0.11857720435195
0.12705342728083
0.16221631527879
0.17923651065609
0.54465309442893
0.55760868115349
0.17055714192171
0.17639565158094
1.22755955648343
1.23077769524618
⎤
⎥⎥⎥⎥⎦
.
The estimated parameters and their conﬁdence intervals are shown in Figure 9.19.
0
1
2
3
4
5
6
0
0.2
0.4
0.6
0.8
1
1.2
1.4
FIGURE 9.19: Estimated parameters and conﬁdence intervals.
Example 9.33
Assume that the prototype function is
f(a, x) = (a1x3
1 + a2) sin(a3x2x3) + (a4x3
2 + a5x2 + a6).
Solve the multivariate nonlinear regression problem for a set of noisy data with the
function nlinfit().
Solution Assume that the initial values of ai are all 1’s. The following statements can be
used to deﬁne the function f, and to generate a data set X serving as the observed data.
>> a=[1;1;1;1;1;1]’; % initial search vector
f=@(a,x)(a(1)*x(:,1).^3+a(2)).*sin(a(3)*x(:,2).*x(:,3))+...
(a(4)*x(:,3).^3+a(5)*x(:,3)+a(6)); % prototype function description
X=randn(120,4); y=f(a,X)+sqrt(0.2)*randn(120,1); % noised data
With the observed data, the following statements can be used to estimate ai, and the
results can be shown in Figure 9.20 (a) where we can observe that the ﬁtting is satisfactory.

468
Scientiﬁc Computing with MATLAB®
>> [ahat,r,j]=nlinfit(X,y,f,[0;2;3;2;1;2]); ci=nlparci(ahat,r,j);
y1=f(ahat,X); plot([y y1]) % nonlinear regression parameters and intervals
The estimated parameters and the conﬁdence intervals are
a =
⎡
⎢⎢⎢⎢⎢⎢⎣
1.04839959073146
1.01882085899938
0.98446778587739
0.99107092667601
1.02519403669663
1.05040136072101
⎤
⎥⎥⎥⎥⎥⎥⎦
,
ci =
⎡
⎢⎢⎢⎢⎢⎢⎣
0.96893545453576
1.12786372692717
0.88884528207121
1.14879643592754
0.89167073268603
1.07726483906874
0.96675355288178
1.01538830047025
0.9270517440877
1.12333632930555
0.99419821923406
1.10660450220796
⎤
⎥⎥⎥⎥⎥⎥⎦
.
0
20
40
60
80
100
120
−30
−20
−10
0
10
20
(a) nonlinear regression
0
1
2
3
4
5
6
7
0
0.2
0.4
0.6
0.8
1
(b) parametric estimation and conﬁdence interval
FIGURE 9.20: Nonlinear regression for multivariate functions.
The results are exactly the same as the ones obtained previously. With the function
nlparci(), the conﬁdence interval can also be found. The conﬁdence intervals with 95%
conﬁdence level are visualized in Figure 9.20 (b).
>> errorbar(1:6,ahat,ci(:,1)-ahat,ci(:,2)-ahat) % plot with error bars
9.4.4
Maximum likelihood estimations
Maximum likelihood estimation (MLE) is a frequently used method in statistics for
parameter and interval estimation. Normally when a statistical model is known, with
undetermined constants, and also a set of experimental data is obtained, maximum
likelihood approach can be used to estimate the undetermined constants and intervals. In
MATLAB, mle() function can be used to carry out maximum likelihood estimation tasks.
Here only one syntax of the function is presented, [p,p1] = mle(’norm’,X,α), where X
is a data vector assumed to satisfy a normal distribution, and α is the conﬁdent level.
The returned variables p contained the estimated mean and variance, while p1 returns the
estimated intervals.
Example 9.34
A batch of light bulbs produced by a factory may have diﬀerent lumen
levels. The lumen here is regarded as a stochastic variable ξ. It is assumed that ξ satisﬁes the
normal distribution N(μ, σ2). Now take 120 samples randomly from the products, and the
lumen levels of the samples are given in Table 9.6. Please estimate the mean and variance
using maximum likelihood method.

Probability and Mathematical Statistics Problems
469
TABLE 9.6: The lumen levels of the test samples.
216
203
197
208
206
209
206
208
202
203
206
213
218
207
208
202
194
203
213
211
193
213
208
208
204
206
204
206
208
209
213
203
206
207
196
201
208
207
213
208
210
208
211
211
214
220
211
203
216
224
211
209
218
214
219
211
208
221
211
218
218
190
219
211
208
199
214
207
207
214
206
217
214
201
212
213
211
212
216
206
210
216
204
221
208
209
214
214
199
204
211
201
216
211
209
208
209
202
211
207
202
205
206
216
206
213
206
207
200
198
200
202
203
208
216
206
222
213
209
219
Solution For the clarity in presentation, the data was stored in an ASCII ﬁle c9dlumen.dat.
The data should be loaded into MATLAB workspace ﬁrst, and the function mle() can be
used to estimate the parameters
>> X=load(’c9dlumen.dat’);
% load the data into MATLAB workspace
[p,p1]=mle(’norm’,X,0.05) % estimate the mean and variance with MLE method
The estimated mean is 208.8167, with an interval of [207.6737, 209.9596], and the
estimated variance is 6.2968, with interval [5.6118, 7.2428].
9.5
Statistical Hypothesis Tests
9.5.1
Concept and procedures for statistic hypothesis test
For a given data set, we can assume certain statistic properties, for instance, certain
distribution. How to check the assumption made on the data set is also known as hypothesis
test. Hypothesis test is very important in statistics. For instance, someone may propose
a hypothesis that the average lifetime of a certain light bulb product is over 3000 hours.
How to check whether this hypothesis is correct? The exact way to check it is to turn all
the bulbs on, and measure the lifetime of all the bulbs. This is, of course, not a feasible
solution to the test. In statistics, one may randomly select a certain number of bulbs for
the hypothesis test.
I. Test of signiﬁcance
One may claim that the average value of a product speciﬁcation is μ0. To test whether
this claim is true, one can select randomly n samples, and ﬁnd the sample mean ¯x and
sample deviation s. Now the hypothesis can be made as H0: μ = μ0, i.e., the mean of
the product speciﬁcation is μ0. The following procedures can be carried out to perform
hypothesis test:
(i) Establish a statistical variable u as
u =
√n(¯x −μ0)
s
,
(9-5-1)
and statistical variable u satisﬁes a standard normal distribution N(0, 1).

470
Scientiﬁc Computing with MATLAB®
(ii) Select a signiﬁcance level α, for instance, α = 0.05.
(iii) Compute the inverse normal distribution function Kα/2 such that
 Kα/2
−Kα/2
1
√
2π e
−x2
2 dx < 1 −α,
(9-5-2)
which can be evaluated with Kα/2 = norminv(1 −α/2,0,1). This value can alternatively
be evaluated with Kα/2 = icdf(’norm’,1 −α/2,0,1).
(iv) Make decision: If |u| < Kα/2, the hypothesis H0 cannot be rejected, otherwise, the
hypothesis H0 can be rejected with (1 −α) × 100% of conﬁdence.
Example 9.35 Suppose it is known that the average strength of a product is μ0 = 9.94kg.
Now a new manufacturing technique is adopted. Two hundred pieces of the product were
selected randomly and the average strength is measured as ¯x = 9.73kg, with a standard
deviation s = 1.62kg. Check whether the new manufacturing technique will aﬀect the
average strength of the product.
Solution The hypothesis for the problem can be deﬁned as H0: μ = 9.94 kg, meaning the
new manufacturing technique will not aﬀect the average strength of the product. To solve
this type of hypothesis test problem, the following statements can be issued
>> n=200; mu0=9.94; xbar=9.73; s=1.62; u=sqrt(n)*(mu0-xbar)/s
alpha=0.02; K=norminv(1-alpha/2,0,1), H=abs(u)<K
With the above MATLAB statements, it is found that u = 1.8332, K = 2.3263, and most
importantly, H = 1, meaning |u| < K, therefore, the hypothesis H0 cannot be rejected. In
other words, the new manufacturing technique will not aﬀect the average strength of the
product.
II. Comparing two means
Another type of typical hypothesis test is usually used to check whether two sets of data
have signiﬁcant diﬀerence or not.
Select randomly n1 samples from the ﬁrst set of data, and measure the sample mean ¯x1
and sample deviation s1. Select also randomly n2 samples from the second set, and measure
¯x2 and s2. The hypothesis is deﬁned as H0: μ1 = μ2, i.e., the mean of the two sets of data
are equal. In other words, the two sets of data have no signiﬁcant diﬀerence. The hypothesis
test can be carried out in the following procedures:
(i) A statistical variable t can be computed
t =
¯x1 −¯x2

s2
1/n1 + s2
2/n2
,
(9-5-3)
which satisﬁes T distribution.
(ii)
Select a signiﬁcance level α and compute T0, with T0 = tinv(α/2,k) or
T0 = icdf(’t’,α/2,k), where k = min(n1 −1, n2 −1).
(iii)
Make decision: If |t| < |T0|, the hypothesis H0 cannot be rejected, otherwise, it
can be rejected with (1 −α) × 100% conﬁdence.

Probability and Mathematical Statistics Problems
471
Example 9.36 Twenty patients suﬀering from insomnia are divided randomly into groups
A and B, with ten patients each. They were given medicines A and B, respectively. The
extended sleeping hours are measured as shown in Table 9.7. Determine whether there are
signiﬁcant diﬀerences in the healing eﬀect.
TABLE 9.7: Extended sleeping hours.
A
1.9
0.8
1.1
0.1
−0.1
4.4
5.5
1.6
4.6
3.4
B
0.7
−1.6
−0.2
−1.2
−0.1
3.4
3.7
0.8
0
2
Solution
The simplest way to check the diﬀerence of two sets of data is to make the
hypothesis — H0: μ1 = μ2, i.e., the means of the two sets of data are equal. The following
statements can be made to carry out the hypothesis test
>> x=[1.9,0.8,1.1,0.1,-0.1,4.4,5.5,1.6,4.6,3.4];
y=[0.7,-1.6,-0.2,-1.2,-0.1,3.4,3.7,0.8,0,2];
n1=length(x); n2=length(y); k=min(n1-1,n2-1);
t=(mean(x)-mean(y))/sqrt(std(x)^2/n1+std(y)^2/n2)
a=0.05; T0=tinv(a/2,k), H=abs(t)<abs(T0)
with t = 1.8608, k = 9, T0 = −2.2622. Since H = 1, the hypothesis cannot be rejected. In
other words, the medicines do not have signiﬁcant diﬀerence in eﬀect.
Since the two set of samples are known, the box plots for the two sets can be obtained as
shown in Figure 9.21, which also cross-validated the above conclusion.
>> boxplot([x.’ y.’]) % draw box plots for the two sets of data
−1
0
1
2
3
4
5
1
2
FIGURE 9.21: The box plots of the two sets.
9.5.2
Hypothesis tests for distributions
MATLAB solution to simple hypothesis test problems have been shown in the previous
examples. In fact, many MATLAB functions are provided in the Statistics Toolbox to solve
diﬀerent hypothesis test problems, for instance, mean value test for normal distributions,
normality test and arbitrary given distribution test. In this subsection, hypothesis tests
based on the Statistics Toolbox are presented.

472
Scientiﬁc Computing with MATLAB®
I. Hypothesis test of the mean of normal distribution
Given a set of data satisfying the normal distribution with its standard deviation σ
known. The hypothesis H0 is made to claim that the mean of the distribution is μ.
This hypothesis test can be performed through Z test with the function ztest(), where
[H,s,μci] = ztest(X,μ,σ,α), with H the test result. When H = 0, it means that the
hypothesis H0 cannot be rejected, otherwise, the hypothesis should be rejected, with a
conﬁdence level of α. The value of s is the signiﬁcance level, and μci is the conﬁdence
interval of the mean.
If the standard deviation for the normal distribution is not known, the T test can be
used to perform hypothesis test on the means. The MATLAB function ttest() can be used
to perform such a test, with [H,s,μci] = ttest(X,μ,α).
Example 9.37
Generate a set of random numbers satisfying the normal distribution.
Perform hypothesis test on the mean of the random numbers.
Solution Let us ﬁrst generate 400 random numbers satisfying N(1, 22). Since the standard
deviation is 2, the hypothesis H0 : μ = 1 can be established. With the following MATLAB
statements
>> r=normrnd(1,2,400,1); [H,p,ci]=ztest(r,1,2,0.02) % carry out Z test
it can be found that H = 0, p = 0.43594320476, ci = [0.8453, 1.3105]. Since H = 0, the
hypothesis cannot be rejected. In other words, the hypothesis can be accepted with 98% of
conﬁdence.
If the hypothesis is changed to H0 : μ = 0.5, the following statements can be used,
and the value of H is 1. In this case, the hypothesis H0 should be rejected. The conﬁdence
interval for the mean value remains the same.
>> [H,p,ci]=ztest(r,0.5,2,0.02) % carry out Z test
It is found that H = 1, p = 7.5118×10−9, ci = [0.845, 1.3105].
If the standard deviation is not known, the T test can be used to test the H0 : μ = 1
hypothesis by using the following MATLAB statement
>> [H,p,ci]=ttest(r,1,0.02) % carry out T test
and the results obtained are H = 0, p = 0.4517, ci = [0.8363534005, 1.3194589956], which
means that the hypothesis can be accepted with 98% conﬁdence.
II. Hypothesis test of normality
Testing whether a set of random numbers satisﬁes the normal distribution can be
performed with MATLAB directly. Two functions, jbtest() and lillietest() are
provided in the Statistics Toolbox, which implement the Jarque–Bera and Lilliefors
hypothesis test algorithms, respectively [10]. They can be used to test whether the random
samples are normal or not. The syntaxes of the two functions are
[H,s] = jbtest(X,α)
% Jarque–Bera test
[H,s] = lillietest(X,α)
% Lilliefors test

Probability and Mathematical Statistics Problems
473
Example 9.38
Consider again the data in Example 9.34, with the data given in Table
9.6. Please verify whether the normal distribution assumption is acceptable.
Solution
The data should be entered into MATLAB workspace ﬁrst, and the function
jbtest() can be used
>> X=load(’c9dlumen.dat’); % load the data into MATLAB workspace
[H,p]=jbtest(X,0.05)
% test whether the data satisfy normal distribution
The obtained results are H = 0, p = 0.7281, which means that the experimental data satisﬁes
a normal distribution.
Having shown that the distribution is normal, the mean and variance with conﬁdence
intervals can be estimated with the use of the normfit() function
>> [mu1,sig1,mu_ci,sig_ci]=normfit(X,0.05) % parameter estimation
and the estimated parameters are μ = 208.8167, σ2 = 6.3232, and the corresponding conﬁ-
dence intervals are (207.6737, 209.9596), and (5.6118, 7.2428), respectively. The estimation
results are quite close to the one obtained in Example 9.34, using maximum likelihood
method.
Example 9.39
Generate a set of random numbers satisfying Gamma distribution. Verify
whether the same random numbers also satisfy a normal distribution using the hypothesis
test method. Of course, we know that it does not satisfy normal distribution, and the result
of hypothesis test should be 1.
Solution The following statements can be used to generate a set of pseudorandom numbers
satisfying the Gamma distribution. The function jbtest() can then be used, and the
following results can be obtained.
>> r=gamrnd(1,3,400,1); [H,p,c,d]=jbtest(r,0.05) % normality test
It can be found that H = 1, p = 0, i.e., the hypothesis H0 should be rejected.
III. Kolmogorov–Smirnov test for other distributions
The Jarque–Bera and Lilliefors hypothesis test algorithms can only be used to test
whether the set of data to be tested satisﬁes normal distribution or not. They cannot be
used for testing other distributions. The Kolmogorov–Smirnov test algorithm is an eﬀective
algorithm which can be used to test whether it satisﬁes arbitrarily given distributions.
The kstest() function can be used [H,s] = kstest(X,cdﬀun,α), where the matrix
cdﬀun is composed of two columns, one for the independent variable, and the other for
the cumulative distribution function of the target distribution. By establishing the cdﬀun
matrix, the existing function or the user-deﬁned functions can be used. Thus, this MATLAB
function can be used to test arbitrary distribution function.
Example 9.40
Test whether the random numbers generated in Example 9.39 satisfy the
Gamma distribution.
Solution Assume that the data satisfy Gamma distribution. Then, the function gamfit()
can be used to estimate the two parameters a and λ
>> r=gamrnd(1,3,400,1); alam=gamfit(r) % parameter estimation

474
Scientiﬁc Computing with MATLAB®
and ˆa = 1.0456 and ˆλ = 3.2868. The cumulative distribution function of Gamma distribution
is computed by gamcdf(sort(r),alam(1),alam(2)). The results can be given in the
kstest() function so that the hypothesis test can be performed
>> r=sort(r); [H,p]=kstest(r,[r gamcdf(r,alam(1),alam(2))],0.05)
and for this example, H = 0 and p = 0.8772. Thus, the hypothesis can be accepted which
means that the samples satisfy Gamma distribution, with ˆa = 1.0456 and ˆλ = 3.2868,
which validates the distribution test problem. In fact, the samples are generated by Gamma
distribution with a = 1 and λ = 3.
9.6
Analysis of Variance
The hypothesis test discussed earlier can only be used to test the behaviors of one or two
statistic variables. For problems with more than two variables, analysis of variance should
be employed. Analysis of variance, also known as ANOVA, is a statistical analysis approach
proposed by the British statistician Ronald Fisher. It can be used in many ﬁelds, such as
in medical research, scientiﬁc tests and quality control.
Since the classiﬁcation of the test samples are diﬀerent, the method of variance analysis
may also be diﬀerent. Commonly used classiﬁcation methods include one-way method,
two-way method and n-way method. The analysis of variance method and its solutions
in MATLAB will be demonstrated via several examples.
9.6.1
One-way ANOVA
One-way analysis of variance is to check whether the external factor has a signiﬁcant
impact on the observations. Assume that for a certain disease, N types of medicines can
be tested. The target of the analysis is determining whether the medicines have the same
healing eﬀect. In mathematics words, whether each group has the same mean.
To do the test, the patients are divided randomly into N groups, with m patients each.
The healing time can be measured, and denoted as yi,j, where i is the group number,
i = 1, 2, · · · , N, and j is the patient number, j = 1, 2, · · · , m. Using the colon expression in
MATLAB, the measured data in the ith group for all patients is yi,:, and the data for the jth
patient for all groups are y:,j. Also, ¯yi,: denotes the average healing time in the ith group,
while ¯y:,: for the average healing time for all the patients. The standard variance analysis
table can be constructed as shown in Table 9.8, where SS stands for sum of squares, DOF
stands for degree of freedom. Based on the table, certain necessary rules can be extracted.
Hypothesis tests are used in the analysis of variance, that is, to propose H0 assuming
that all the average observed measures are the same. The most important quantities are the
last two columns of the table, the statistic F and the probability p, which can be evaluated
from the inverse distribution function. If the value of the probability p < α, with α the
selected conﬁdence level, the hypothesis H0 should be rejected. Otherwise, the hypothesis
cannot be rejected.
A function anova1() provided in the Statistics Toolbox can be used to per-
form one-way analysis of variance for the test data. The syntax of the function is
[p,tab,stats]= anova1(X), where X is the data set to be analyzed. The experimental

Probability and Mathematical Statistics Problems
475
TABLE 9.8: Variance analysis table.
source
sum of squares
DOF
mean squares
F
probability p
groups
SSA=

i
ni¯y2
i,:−N ¯y2
:,:
I −1
MSSA= SSA
I −1
MSSA
MSSE
p = P (FI−1,N−I > c)
error
SSE=

i

k
y2
i,k −

i
ni¯y2
i,:
N −I
MSSE= SSE
N −I
total
SST=

i

k
y2
i,k −N ¯y2
:,:
N −1
data should be given as an m × n matrix, with each column corresponding to the measured
data of the same group. The probability p, variance analysis table tab in the format of Table
9.8 are returned. The other returned argument stats is the structured data containing the
statistic quantities. Two windows will also be automatically opened, one displaying the
table shown in Table 9.8 and the other showing the box plot.
Example 9.41
Suppose that there are ﬁve medicines to cure a certain disease. Assume
that there are 30 patients, randomly divided in 5 test groups, with 6 patients in each test
group. For each test group, only one medicine is used. The healing time for each patient
is recorded as shown in Table 9.9. Conclude whether there is signiﬁcant diﬀerence in the
eﬀect. (Data and example source, Reference [11].)
TABLE 9.9: Experimental data on healing time (days).
patient
medicine numbers
patient
medicine numbers
number
1
2
3
4
5
number
1
2
3
4
5
1
5
4
6
7
9
2
8
6
4
4
3
3
7
6
4
6
5
4
7
3
5
6
7
5
10
5
4
3
7
6
8
6
3
5
6
Solution From the given table, matrix A can be established in MATLAB and the mean
value of each column is obtained as [7.5, 5, 4.3333, 5.1667, 6.1667]. The analysis of variance
is then carried out
>> A=[5,4,6,7,9; 8,6,4,4,3; 7,6,4,6,5; 7,3,5,6,7; 10,5,4,3,7; 8,6,3,5,6];
mean(A), [p,tbl,stats]=anova1(A) % analysis of variance
and the probability is returned as p = 0.01359. Two windows are opened automatically
by function anova1(), as shown respectively in Figures 9.22 (a) and (b). The value of
probability is p = 0.0136 < α, where α = 0.02 or 0.05. Thus, the hypothesis is to be rejected
with 98% of conﬁdence, i.e., it can be concluded that there is signiﬁcant diﬀerence among the
medicines. In fact, from the box plot obtained, the healing time of medicine 3 is signiﬁcantly
shorter than medicine 1.

476
Scientiﬁc Computing with MATLAB®
(a) variance table
3
4
5
6
7
8
9
10
1
2
3
4
5
(b) box plot
FIGURE 9.22: Results of one-way analysis of variance.
9.6.2
Two-way ANOVA
If there are two factors which may aﬀect the statistical properties of a certain
phenomenon, the concept of two-way variance analysis can be used. The measured data
yi,j,k are expressed as a three-dimensional array y(i, j, k) in MATLAB.
Based on the two-way analysis, three hypotheses are introduced:
⎧
⎪
⎪
⎨
⎪
⎪
⎩
H1 : α1 = α2 = · · · = αI, αi is the eﬀect when factor 1 acts alone
H2 : β1 = β2 = · · · = βJ,
βj is the eﬀect when factor 2 acts alone
H3 : γ1 = γ2 = · · · = γIJ, γk is the eﬀect when both factors act.
(9-6-1)
For the two-way analysis of variance, the ANOVA table constructed is shown in Table
9.10, where the interactive SSAB eﬀect can be evaluated from (9-6-2).
SSAB = K

ij
¯y2
i,j,: −JK

i
¯y2
i,:,: −IK

j
¯y2
:,j,: + IJK ¯y2
:,:,:.
(9-6-2)
The deﬁnitions of the three probabilities are
⎧
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎩
pA =P

F[I−1,IJ(K−1)] > c1

if pA < c1 reject hypothesis H1
pB =P

F[J−1,IJ(K−1)] > c2

if pB < c2 reject hypothesis H2
pAB =P

F[(I−1)(J−1),IJ(K−1)]>c3

if pAB < c3 reject hypothesis H3.
(9-6-3)
Two-way analysis of variance problems can be solved with the anova2() function
[p,tab,stats]= anova2(X,n). The argument n is the number of subjects in each group.

Probability and Mathematical Statistics Problems
477
TABLE 9.10: Table of two-way analysis of variance.
source
square of sums
DOF
mean squared error
F
p
factor A
SSA=JK

i
¯y2
i,:,: −IJK ¯y2
:,:,:
I −1
MSSA= SSA
I −1
MSSA
MSSE
pA
factor B
SSB=IK

i
¯y2
:,j,: −IJK ¯y2
:,:,:
J −1
MSSB= SSB
J −1
MSSB
MSSE
pB
interaction
SSAB see (9-6-2)
(I−1)(J −1)
MSSAB=
SSAB
(I−1)(J −1)
MSSAB
MSSE
pAB
errors
SSE=

ijk
y2
i,j,k−K

i

j
¯y2
i,j,:
IJ(K −1)
MSSE=
SSE
IJ(K −1)
total
SST=

ijk
y2
i,j,k −IJK ¯y2
:,:,:
IJK −1
Example 9.42 Suppose that there are three species of pines planted in four diﬀerent living
conditions. Select randomly ﬁve samples in each group of subjects for measurement. The
chest radii of the trees are measured, and the data are given in Table 9.11. Perform two-way
analysis of variance on the data and check whether there exists signiﬁcant diﬀerences (Data
source, book [11]).
TABLE 9.11: Measured data for the pines.
pine
living conditions
species
1
2
3
4
1
23
15
26
13
21
25
20
21
16
18
21
17
16
24
27
14
17
19
20
24
2
28
22
25
19
26
30
26
26
20
28
19
24
19
25
29
17
21
18
26
23
3
18
10
12
22
13
15
21
22
14
12
23
25
19
13
22
16
12
23
22
19
Solution
The data in the table can be entered into MATLAB workspace. Calling the
function anova2(), the results are obtained as shown in Figure 9.23, which are exactly
the same as the ones in Reference [11].
>> B=[23,15,26,13,21,25,20,21,16,18,21,17,16,24,27,14,17,19,20,24;
28,22,25,19,26,30,26,26,20,28,19,24,19,25,29,17,21,18,26,23;
18,10,12,22,13,15,21,22,14,12,23,25,19,13,22,16,12,23,22,19];
anova2(B’,5); % two-way variance analysis
FIGURE 9.23: Results of two-way analysis of variance.

478
Scientiﬁc Computing with MATLAB®
It can be seen from the results that, since pA is very small, the hypothesis H1 should be
rejected. It can be concluded that factor A has a signiﬁcant impact upon the phenomenon
observed, i.e., the tree species has signiﬁcant impact on the chest radius of the trees. The
other two hypothesis cannot be rejected.
9.6.3
n-way ANOVA
Similar to two-way analysis of variance presented earlier, three-way and even n-way
analysis of variance are supported in the Statistics Toolbox with the function manova1().
Interested readers may refer to References [12,13].
9.7
Principal Component Analysis
Principal components analysis (PCA) is an eﬀective approach in modern statistic
analysis. Assume that a phenomenon is caused simultaneously by several factors, principal
component analysis method can be used to identify which of the factors are important,
and the less important factors can be neglected. In this way, the dimensions of the original
problem can be reduced, so as to simplify the original problems.
Assume that a phenomenon can be aﬀected by n factors, x1, x2, · · · , xn, and there are
M sets if measured data. An M × n matrix X can be used to represent the data, and the
means of each column is denoted by ¯xi, i = 1, 2, · · · , n. The main procedures of principal
component analysis are as follows:
(i)
With the corr() function, the n × n covariance matrix R of matrix X can be
established
rij =
-
.
.
/
M

k=1
(xki −¯xi)(xkj −¯xj)
-
.
.
/
M

k=1
(xki −¯xi)2
M

k=1
(xkj −¯xj)2
.
(9-7-1)
(ii)
The eigenvectors ei of matrix R can be established, according to the sorted
eigenvalues λ1 ⩾λ2 ⩾· · · ⩾λn ⩾0. Normalization are made to each column of the
eigenvector matrix, i.e., ||ei|| = 1, or 'n
j=1 e2
ij = 1. The operation can be performed
with eig() function, and since the eigenvalues were made in ascending order, it should
be rearranged with fliplr() function.
(iii) Compute the contribution from each and the principal components
contribution from the principal component: γi =
λi
n

k=1
λk
,
(9-7-2)
accumulated contributions: δi =
i

k=1
λk
n

k=1
λk
.
(9-7-3)

Probability and Mathematical Statistics Problems
479
If the contribution rate of the ﬁrst s eigenvalues exceed a certain value, e.g., 85%∼95%,
the s factors can be regarded as the principal components, and the original n-dimensional
problems can be reduced to s-dimensional problems.
(iv) Deﬁne new variables Z = XL, such that
⎧
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎩
z1 = l11x1 + l21x2 + · · · + ln1xn
z2 = l12x1 + l22x2 + · · · + ln2xn
...
zn = l1nx1 + l2nx2 + · · · + lnnxn,
(9-7-4)
where, the coeﬃcients lji in the ith column of the transformation matrix can be computed
with lji =

λieji. Principal component analysis can be carried out on the obtained
coeﬃcients lij. Normally the ﬁrst s components can be used as the principal components,
and the entities in the columns after sth column in matrix L may be very close to zeros.
The last n −s variables in the z variable in (9-7-4) can be neglected, the m new variables
can be used to describe the original problem.
⎧
⎪
⎨
⎪
⎩
z1 = l11x1 + l21x2 + · · · + ln1xn
...
zs = l1sx1 + l2sx2 + · · · + lnsxn.
(9-7-5)
Under appropriate linear transformation, the original n-dimensional problem can be
reduced to an s-dimensional problem.
Assume that a variable is aﬀected by many factors, and these factors can be measured
with observers in real applications. The measured data sometimes contain redundant
information. Principal component method can be used to extract information, and high-
dimensional problems can be reduced as low-dimensional ones. An example is given below
to demonstrate the use of principal component analysis applications.
Example 9.43
Assume that a set of three-dimensional sample points are generated with
the parametric equations x = t cos 2t, y = t sin 2t, z = 0.2x + 0.6y. Please reduce the
dimensions with principal component analysis approach.
Solution
The data can be generated with the following MATLAB statements, and the
three-dimensional curve is shown in Figure 9.24 (a).
>> t=[0:0.1:3*pi]’; x=t.*cos(2*t); y=t.*sin(2*t); z=0.2*x+0.6*y;
X=[x y z]; R=corr(X); [e,d]=eig(R), d=diag(d), plot3(x,y,z)
It can be seen from the ﬁgure that, the curve should be located within a certain plane.
Thus, a new coordinate system can be introduced, so that the original three-dimensional
curve can be compressed and shown in a two-dimensional plane.
R=
⎡
⎣
1
−0.0789
0.2536
−0.0789
1
0.9443
0.2536
0.9443
1
⎤
⎦, e=
⎡
⎣
0.2306
−0.9641
0.1314
0.6776
0.256
0.6894
−0.6983
−0.0699
0.7124
⎤
⎦, d=
⎡
⎣
0
1.0393
1.9607
⎤
⎦.
It can be seen that the ﬁnal L matrix can be established, and since the ﬁrst two
eigenvalues are very large while the third one tends to zero, two factors are necessary for
eﬀectively describing the original problem.
>> d=d(end:-1:1); e=fliplr(e); D=[d’; d’; d’];
% sort the eigenvalues
L=real(sqrt(D)).*e, Z=X*L; plot(Z(:,1),Z(:,2)) % draw 2D plot

480
Scientiﬁc Computing with MATLAB®
−10
−5
0
5
10
−10
0
10
−10
−5
0
5
(a) original 3D curve
−15
−10
−5
0
5
10
15
−10
−8
−6
−4
−2
0
2
4
6
8
(b) reduced 2D curve
FIGURE 9.24: Three-dimensional curve and dimension reduction eﬀect.
Thus, the transformation matrix can be found as
L =
⎡
⎣
0.1840
−0.9829
0
0.9653
0.2610
0
0.9975
−0.0713
0
⎤
⎦,
i.e., a new set of coordinates can be introduced

z1 = 0.1840x + 0.9653y + 0.9975z
z2 = −0.9829x + 0.2610y −0.0713z.
In this way, the three-dimensional problem can be reduced to a two-dimensional problem.
The reduced two-dimensional curve can be obtained as shown in Figure 9.24 (b). It can be
seen that the two-dimensional curve can be extracted, and it contains all the information of
the original plot.
Exercises
Exercise 9.1 The PDF of Rayleigh distribution is given by
pr(x) =
 x
b2 e−x2/(2b2),
x ⩾0
0,
x < 0.
Derive analytically the cumulative distribution function, mean, variance, central moment
and raw moments of the distribution. Generate a pseudorandom sequence satisfying Rayleigh
distribution and verify numerically whether the numerical generation is correct or not.
Exercise 9.2 Assume that the number ξ of cars passing through a traﬃc light satisﬁes
Poisson distribution. Also, assume that the probabilities of no car passing through and
exactly one car passing through are the same. Please ﬁnd out the probability of at least
two cars passing through the traﬃc light.
Exercise 9.3 Assume that in a foreign language examination, the randomly selected
samples indicate that the scores satisfy approximately the normal distribution, with a mean
value of 72. The number of those scores higher than 96 is 2.3% of all the number of students.
Find the probability of a student whose score is between 60 and 80.

Probability and Mathematical Statistics Problems
481
Exercise 9.4 Generate 30000 pseudorandom numbers satisfying normal distribution of
N(0.5, 1.42). Find the mean and standard deviation of the data set. Observe the histogram
of the data to see whether they agree with theoretical distribution. Change the width of the
bins and see what may happen.
Exercise 9.5 Please carry out coin-tossing experiment with MATLAB. If you toss a coin
1000 times, check how many times you get heads. What happens if you toss the coin 10000,
100000 or more times? — Hints: You may deﬁne a standard uniformly distributed number
ξ > 0.5 as heads in the computerized experiment.
Exercise 9.6 Assume a set of data is measured and given in Table 9.12 [7]. Please ﬁnd the
three quartiles, and draw the box plot. Are there any outliers in the data set?
TABLE 9.12: The measured data in Exercise 9.6.
0
3.9
5.64
8.22
0
5.62
3.92
6.81
30.61
0
73.2
0
46.7
0
0
26.41
22.82
0
0
3.49
0
0
4.81
9.57
5.36
0
5.66
0
59.76
12.38
15.74
0
0
0
0
9.37
20.78
7.1
7.89
5.53
Exercise 9.7 Assume that a set of data was measured as shown in Table 9.13. Use
MATLAB to perform the following hypothesis tests:
(i) Assume that the data satisﬁes normal distribution with a standard deviation of 1.5.
Test whether the mean value of the data is 0.5.
(ii) If the standard deviation is not known, test whether the mean is still 0.5.
(iii) Test whether the distribution of the data is normal.
TABLE 9.13: The measured data in Exercise 9.7.
−1.7908
0.3238
4.6927
−2.3586
−0.0940
2.8943
5.3067
3.1634
−3.2812
−3.4389
0.0903
2.5006
−0.6758
−3.2431
−3.2440
−0.0521
−0.0796
0.4653
−0.7905
2.0690
3.9223
5.6959
0.7327
−1.083
−1.8152
−2.9145
−2.6714
1.7065
0.0819
2.3258
0.4135
1.6804
−1.3172
1.132
1.047
0.5219
4.4827
−1.112
0.5201
1.9318
3.2618
0.4735
2.031
−0.7177
−2.3273
0.6606
1.2325
−0.9750
2.3831
3.4477
−1.0665
2.5546
−4.8203
−2.5004
−0.2812
1.2122
−2.0178
1.2073
−1.1251
1.236
0.5169
0.6259
2.7278
2.9135
−1.6181
1.6246
1.8958
0.7403
−1.1234
−1.0142
−1.2615
−1.9909
0.9925
−1.1022
−2.1428
3.3757
3.357
4.6585
0.04734
0.1640
1.8206
1.5924
1.0887
0.47461
−1.7976
−0.7326
−1.5161
−0.1190
0.4540
−5.0103
−0.0652
0.48874
3.2303
0.49816
−0.40375
1.0868
0.80414
5.4782
1.1275
1.5649
1.5803
−0.1215
−0.118
−0.0612
0.8908
0.4704
0.1872
3.8942
2.8812
0.7631
2.0033
3.372
0.2005
1.3923
0.23873
−0.80559
−2.1176
−3.8764
1.8988
−0.8300
Exercise 9.8 For a prototype linear function y = a1x1 + a2x2 + a3x3 + a4x4 + a5x5, with
ﬁve independent variables x1, x2, x3, x4, x5 and one output y, the data in Table 9.14 are
obtained. Find the values ai and their conﬁdence intervals using linear regression method.

482
Scientiﬁc Computing with MATLAB®
TABLE 9.14: The measured data in Exercise 9.8.
x1
8.11
9.25
7.63
7.89
12.94
10.11
7.57
9.92
7.74
7.3
9.48
11.91
x2
2.13
2.66
0.83
1.54
1.74
0.79
0.68
2.93
2.01
1.35
2.81
2.23
x3
3.98
−0.68
1.42
−0.96
−0.28
3.37
4.58
2.15
2.66
3.69
1
−0.98
x4
6.55
6.85
6.25
5.34
6.85
7.2
6.12
6.07
5.51
6.6
6.15
6.43
x5
5.92
7.54
5.39
4.65
6.47
5.1
6.04
5.37
6.54
6.55
5.8
3.95
y
27.676
38.774
23.314
23.828
35.154
21.779
25.516
29.845
32.642
28.443
31.5
23.554
Exercise 9.9 Assume that a set of measured data xi and yi are given in Table 9.15, and
the prototype function is f(x) = a1e−a2x cos(a3x + π/3) + a4e−a5x cos(a6x + π/4). Estimate
the values of ai and their conﬁdence intervals.
TABLE 9.15: The measured data in Exercise 9.9.
x
1.027
1.319
1.204
0.684
0.984
0.864
0.795
0.753
1.058
0.914
1.011
0.926
y
8.8797
5.9644
7.1057
8.6905
9.2509
9.9224
9.8899
9.6364
8.5883
9.7277
9.023
9.6605
Exercise 9.10 Suppose that tests have been made on a group of randomly selected fuses,
and it is found that the burn-out currents of the fuses are 10.4, 10.2, 12.0, 11.3, 10.7, 10.6,
10.9, 10.8, 10.2, 12.1 A. Suppose that these random values satisfy normal distribution. Find
the burn-out current and its conﬁdence interval under the conﬁdence level α ⩽0.05.
Exercise 9.11 Assume that the boiling points under certain atmospheric pressures are
tested with the multiple measured data 113.53, 120.25, 106.02, 101.05, 116.46, 110.33,
103.95, 109.29, 93.93, 118.67◦C. Check whether they satisfy normal distribution under the
conﬁdence level of α ⩽0.05.
Exercise 9.12 Assume the measured data given in Table 9.16 satisﬁes the following
prototype function y(t) = c1e−5t sin(c2t) + (c3t2 + c4t3)e−3t. Find from the data the
parameters ci’s and their conﬁdence interval.
TABLE 9.16: The measured data in Exercise 9.12.
t
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
y
0
0.1456
0.2266
0.2796
0.3187
0.3479
0.3677
0.3777
0.3782
0.37
t
1
1.1
1.2
1.3
1.4
1.5
1.6
1.7
1.8
1.9
y
0.3546
0.3335
0.3085
0.2812
0.253
0.225
0.198
0.1726
0.1492
0.1279
t
2
2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
y
0.109
0.0922
0.0776
0.065
0.0541
0.0449
0.0371
0.0305
0.025
0.0204
Exercise 9.13 Assume that 12 sample plants are randomly selected from areas A and B.
The iron element content in μg/g is measured as shown in Table 9.17. Assume that the
iron element content in the plant satisﬁes a normal distribution and the variance of the
distribution is not aﬀected by the area. Test whether the distribution of the iron element
content is the same.

Probability and Mathematical Statistics Problems
483
TABLE 9.17: The measured data in Exercise 9.13.
area A
11.5
18.6
7.6
18.2
11.4
16.5
19.2
10.1
11.2
9
14
15.3
area B
16.2
15.2
12.3
9.7
10.2
19.5
17
12
18
9
19
10
Exercise 9.14 Assume that 12 samples are obtained for a stochastic variable as 9.78, 9.17,
10.06, 10.14, 9.43, 10.60, 10.59, 9.98, 10.16, 10.09, 9.91, 10.36. Find the deviation of the
data and its conﬁdence interval.
Exercise 9.15 Assume that stochastic variables A and B are sampled in Table 9.18. Check
whether they have signiﬁcant statistic diﬀerences.
TABLE 9.18: The measured data in Exercise 9.15.
A
10.42
10.48
7.98
8.52
12.16
9.74
10.78
10.18
8.73
8.88
10.89
8.1
B
12.94
12.68
11.01
11.68
10.57
9.36
13.18
11.38
12.39
12.28
12.03
10.8
Exercise 9.16 Suppose that ﬁve diﬀerent dyeing techniques are tested for the same cloth.
Diﬀerent dyeing techniques and diﬀerent machines are tested randomly, and the percentage
of washing shrinkage are given in Table 9.19. Judge whether the dyeing techniques have
signiﬁcant eﬀect on the washing shrinkage.
TABLE 9.19: The measured data in Exercise 9.16.
machine
dyeing techniques
machine
dyeing techniques
number
1
2
3
4
5
number
1
2
3
4
5
1
4.3
6.1
6.5
9.3
9.5
2
7.8
7.3
8.3
8.7
8.8
3
3.2
4.2
8.6
7.2
11.4
4
6.5
4.2
8.2
10.1
7.8
Exercise 9.17 Assume that the heights of randomly selected Year-5 pupils in three schools
are measured in Table 9.20. Check whether there are signiﬁcant diﬀerences in the heights in
these three schools. (α = 0.05)
Exercise 9.18 The table in Table 9.21 recorded the daily output of three operators on four
diﬀerent machines. Check the following
(i) whether there are signiﬁcant diﬀerences in the skill of the operators
(ii) whether there are signiﬁcant diﬀerences in the machines
(iii) whether the interaction is signiﬁcant (α = 0.05)
Bibliography
[1] Grinstead C M, Snell J L.
Grinstead and Snell’s introduction to probability. The
CHANCE Project: Open source textbook at http://math.dartmouth.edu/~prob/
prob/prob.pdf, 2006

484
Scientiﬁc Computing with MATLAB®
TABLE 9.20: The measured data in Exercise 9.17.
school
measured height data
1
128.1
134.1
133.1
138.9
140.8
127.4
2
150.3
147.9
136.8
126
150.7
155.8
3
140.6
143.1
144.5
143.7
148.5
146.4
TABLE 9.21: The measured data in Exercise 9.18.
machine
operator number
machine
operator number
number
1
2
3
number
1
2
3
M1
15
15
17
19
19
16
16
18
21
M3
15
17
16
18
17
16
18
18
18
M2
17
17
17
15
15
15
19
22
22
M4
18
20
22
15
16
17
17
17
17
[2] StatSoft Inc. Electronic statistics textbook. Tulsa, OK: StatSoft. Electronics textbook
at http://www.statsoft.com/textbook/stathome.html, 2007
[3] Janicki A, Weron A. Simulation and chaotic behavior of α-stable stochastic processes.
New York: Marcel Dekker Inc, 1994
[4] Veillette M. STBL: α-stable distributions for MATLAB. MATLAB Central File ID: #
37514, 2012
[5] Ross M S. Introduction to probability and statistics for engineers and scientists (4th
edition). Burlington, MA: Elsevier Academic Press, 2009
[6] Landau D P, Binder K. A guide to Monte Carlo simulations in statistical physics.
Cambridge University Press, 2000
[7] Moore D S, McCabe G P, Craig B A. Introduction to the practice of statistics, the 6th
Edition. New York: W H Freeman and Company, 2007
[8] Battistini N. Outliers. MATLAB Central File ID: #35048
[9] Trujillo-Ortiz A. Moutlier1. MATLAB Central File ID: #12252
[10] Conover W J. Practical nonparametric statistics. New York: Wiley, 1980
[11] Lu X. Applied statistics. Beijing: Tsinghua University Press, 1999. (in Chinese)
[12] Cody R P, Smith J K. Applied statistics and the SAS programming language. Prentice
Hall, ﬁfth edition, 2006
[13] The MathWorks Inc. Statistics toolbox user’s manual, 2007

Chapter 10
Topics on Nontraditional Mathematical
Branches
In the previous chapters, traditional branches of advanced applied mathematics have been
summarized, and our focus was on computer aided solutions to those problems. Over
the last few decades, many new applied math topics emerged which are referred to as
nontraditional mathematics in this book. For instance, fuzzy logic and fuzzy inference are
presented and used for imitating imprecise human thinking and linguistic behaviors. The
artiﬁcial neural networks are established based on the mathematical model imitating the
neural network of biological systems. The genetic algorithm-based optimization procedures
are proposed based on the principles of survival of the ﬁttest. These new branches of applied
mathematics are promising areas of research in science and engineering oﬀering important
tools for real-life problems. In Section 10.1, classical set theory, fuzzy set and fuzzy
inference are presented with their implementations in MATLAB. Fundamental introduction
to rough set and rough set-based attribute reduction is given in Section 10.2 with real-
life examples. Section 10.3 introduces artiﬁcial neural network in general and feedforward
neural network in particular with back-propagation algorithms, where MATLAB solutions
for network construction, training and generalization are presented using data ﬁtting
problems for illustration. Radial basis neural networks are also illustrated, and graphical
user interface-based solution is demonstrated. In Section 10.4, evolutionary optimization
algorithms, including genetic algorithms and particle swarm optimization methods, are
introduced. The global solutions to optimization problems are also explored. Wavelet-based
methods and solutions are given in Section 10.5 using signal de-noising as an application
example. In Section 10.6, a comprehensive introduction to fractional-order calculus and
numerical solutions to fractional-order ordinary diﬀerential equations is given, where from
a programming point of view, the design and application of the classes and objects dedicated
for fractional-order calculus are demonstrated thoroughly.
It should be noted that only very brief introductions to the mathematical background
and theoretical description are given. Our focus, again, is on the solutions of the related
math problems using MATLAB.
10.1
Fuzzy Logic and Fuzzy Inference
10.1.1
MATLAB solutions to classical set problems
Set theory is the foundation of modern mathematics. The so-called set is a collection of
objects, with each object deﬁned as a member of the set. If the object a is a member of set
A, it is denoted as a ∈A, and we call it “a belongs to set A.” If b is not a member of the
485

486
Scientiﬁc Computing with MATLAB®
set A, it is denoted as b ̸∈A. A set is called an enumerable set if all its members can be
enumerated. In MATLAB, enumerable sets can be represented by vectors or cell arrays.
Example 10.1 The following MATLAB statements can be used to deﬁne enumerable sets
>> A=[1 2 3 5 6 7 9 3 4 11]
% set of digits, repeated members are allowed
B={1 2 3 5 6 7 9 3 4 11}
% the above set can also be described by cells
C={’ssa’,’jsjhs’,’su’,’whi’,’kjshd’,’kshk’}
% set of strings
The set operations provided in MATLAB are summarized in Table 10.1 with brief
explanations. These functions can be nested to establish complicated set operations.
TABLE 10.1: Set operations under MATLAB.
operations
MATLAB functions
descriptions to set operations
set union
A = union(B,C)
Union of sets B and C, such that A = B  C, where the returned
results are sorted
diﬀerence
A = setdiff(B,C)
The diﬀerence of the sets B and C, denoted as A = B \ C. This
operation removes the members in set C from set B. The remaining
members, after sorting, are returned
intersection
A = intersect(B,C)
The sorted results of the intersect of sets B and C, where A =
B  C
exclusive or
A = setxor(B,C)
Exclusive or operation of the sets B and C, i.e., removes set B  C
from set B  C, mathematically A = (B  C)\(B  C). Sorted
results are returned
unique
A = unique(B)
Find the non-repeating elements in set B, i.e., to delete the extra
repeated members with returned set sorted
belong to
key = ismember(a,B)
Check where a belongs to set B, key = a ∈B, returns 1 or 0. If a
is a set, key is a vector of 0’s and 1’s
Example 10.2
For the three sets A
=
{1, 4, 5, 8, 7, 3}, B
=
{2, 4, 6, 8, 10} and
C = {1, 7, 4, 2, 7, 9, 8}, perform the relevant set operations. Verify the commutative law
(A 9 B) : C = (A : C) 9(B : C).
Solution The three sets can be expressed in MATLAB easily and the related functions can
be called to perform set operations
>> A=[1,4,5,8,7,3]; B=[2,4,6,8,10]; C=[1,7,4,2,7,9,8]; % deﬁne sets
D=unique(C), E=union(A,B), F=intersect(A,B)
% set operations
and the unique set D is found such that D = [1, 2, 4, 7, 8, 9], where the extra repeated set
member 7 is removed, and the result is sorted. The union and intersection are also found
as E = [1, 2, 3, 4, 5, 6, 7, 8, 10], and F = [4, 8].
The following statement is used to verify the commutative law where the set diﬀerence is
taken between the sets at the left-hand side and the right-hand side. The result is an empty
matrix, indicating that the commutative law holds for the given sets.
>> L=intersect(union(A,B),C); R=union(intersect(A,C),intersect(B,C));
G=setdiff(L,R) % the set diﬀerence is an empty set
The function ismember() can be called such that

Topics on Nontraditional Mathematical Branches
487
>> H=ismember(A,B), I=A(ismember(A,B)) % show I = A : B
and it is found that H = [0, 1, 0, 1, 0, 0], indicating the second and fourth members in set
A, i.e., members 4 and 8, belong to set B. These members can be extracted to form set I,
which is the same as the intersection of sets A and B, i.e., I = A : B.
Example 10.3
Consider the sets A and B containing strings
A = {’skhsak’,’ssd’,’ssfa’}, and B ={’sdsd’,’ssd’,’sssf’}.
Find the union and intersection of A and B. If C={’jsg’,’sjjfs’,’ssd’}, verify the
distributive law such that (A 9 C) : B = (A : B) 9 (C : B).
Solution
The set containing strings can be expressed by cell objects. The set operations
can be calculated easily by the following scripts
>> A={’skhsak’,’ssd’,’ssfa’}; B={’sdsd’,’ssd’,’sssf’};
F=union(A,B), D=intersect(A,B) % simple set computation
and the union and intersection of sets A and B are found
F = {’sdsd’,’skhsak’,’ssd’,’ssfa’,’sssf’},
D = {’ssd’}.
When set C is speciﬁed, the distributive law can be veriﬁed with the following statements,
since, the result R is an empty set.
>> C={’jsg’,’sjjfs’,’ssd’}; L=intersect(union(A,C),B);
R=union(intersect(A,B),intersect(C,B)); E=setdiff(L,R)
Subset and set inclusion are the important concepts in set theory. The so-called set
inclusion means that if all the members in set A belong to set B, it is said that A is
included in set B, denoted by A ⊆B, or if set B includes set A, A is also called a subset
of set B, while B is referred to as a superset of A. If B \ A is not empty, the set inclusion
is referred to as strict inclusion, denoted by A ⊂B. Set A is then referred to as a proper
subset of B. Set inclusion functions are not directly provided in MATLAB, but the following
statements can be used to check the set inclusion and strict inclusion.
v = all(ismember(A,B)) % v= 1 for A ⊆B, all the elements in A belong to B
v = all(ismember(A,B))&(length(setdiff(B,A))>0) % v = 1 for A ⊂B
Example 10.4
Consider the sets E, F in Example 10.2, check whether F ⊂E is true.
Verify the reﬂexive law of set A, i.e., A ⊆A.
Solution The following statements can be used to conﬁrm the set inclusion relationship,
with k = 1, meaning F is a subset of E.
>> A=[1,4,5,8,7,3]; B=[2,4,6,8,10]; % input the two sets
E=union(A,B); F=intersect(A,B); k=all(ismember(F,E)) % set operations
In fact, F = A 9 B and E = A : B, thus, E ⊂F. It can also be veriﬁed that A ⊆A, i.e.,
the reﬂexive law, with key = 0, key1= 1, meaning A is not a proper subset of A. However,
A is a subset of set A.
>> key=all(ismember(A,A)) & (length(setdiff(A,A))>0)
key1=all(ismember(A,A))
% A ⊆A is satisﬁed

488
Scientiﬁc Computing with MATLAB®
Example 10.5
Let us consider the veriﬁcation of the well-known Goldbach’s conjecture,
which states that any even integer greater than 2 can be expressed by the sum of two prime
numbers. It is one of the oldest unsolved problems in number theory which dates back to
the time of Euler.
Solution For ﬁnite even integers, the full set of all the possible sums of two prime numbers
within a given range can be constructed as set c. One can then check whether the terms in
the set of even integers c1 not belonging to c is empty. The following statements can be used
to verify the conjecture for even integers in [4, 2000].
>> iA=primes(1040); c=[]; for i=iA, c=[c i+iA]; end,
c=unique(c); c1=4:2:2000; c2=ismember(c1,c); C=c1(c2==0)
It can be seen that the set C is an empty one, which veriﬁes the conjecture for small
integer numbers. It should be noted that a larger c should be constructed. With the parallel
computers, the even integers c up to 4 × 1018 have been veriﬁed with no exception [1].
10.1.2
Fuzzy sets and membership functions
I. Membership functions
From the classical set theory, it is seen that an event a either belongs to set A, or does
not belong to set A. There is no other relationship. In modern science and engineering, the
fuzzy concepts might be useful, which may require that the event a belongs to set A to
some extent. This is the fundamental motivation of fuzzy set theory.
The concept of fuzzy set was proposed by Professor LotﬁA. Zadeh in 1965 [2]. Currently
the concept of fuzzy logic has been applied to almost all research and application areas. For
example, fuzzy control is an attractive and promising research topic in control engineering.
Actually, fuzzy concept has been used earlier in the book. For instance, in the variable-
step computation, it has been stated that “when the error is large · · · .” The word “large”
is a fuzzy description. However, fuzzy procedures were not used there.
In real world situations, precision is not everything. Professor Zadeh points out that
“As complexity rises, precise statements lose meaning, and meaningful statements lose
precision.”
Example 10.6
The membership functions of fuzzy sets “old” and “young” were
introduced by Professor Zadeh. Assume that the universe U = [0, 120], the membership
functions are deﬁned as
μO(u)=
⎧
⎪
⎪
⎨
⎪
⎪
⎩
0,
0⩽u⩽50
 
1 +
u−50
5
−2!−1
,
50<u⩽120,
μY(u)=
⎧
⎪
⎪
⎨
⎪
⎪
⎩
 
1 +
u−25
5
−2!−1
,
0⩽u⩽25
0,
25<u⩽120.
The plots of the two membership functions can be drawn with the following statements,
as shown in Figure 10.1.
>> u=0:0.1:120; mu_o=1./(1+((u-50)/5).^(-2)).*(u>50);
mu_y=1./(1+((u-25)/5).^(-2)).*(u<25); plot(u,mu_y,u,mu_o)

Topics on Nontraditional Mathematical Branches
489
0
20
40
60
80
100
120
0
0.2
0.4
0.6
0.8
1
μY(u)
μO(u)
FIGURE 10.1: Membership functions of “old” and “young” fuzzy sets.
Membership function is a very important concept in fuzzy set theory. It states the “grade
of membership” of an element a belonging to set A, denoted as μA(a). The membership
function of classical set is either 1 or 0, indicating a either belongs to A or does not.
However, for fuzzy sets, the value of the membership function is between 0 and 1. Some of
the commonly used membership functions are summarized below.
(i)
Bell-shaped membership functions
The mathematical description to bell-
shaped membership function is
f(x) =
1
1 +
""""
x −c
a
""""
2b ,
(10-1-1)
and function gbellmf() in Fuzzy Logic Toolbox can be used to evaluate the membership
function with y = gbellmf(x,[a,b,c]), where x is the value of independent variable x,
and y contains the values of membership functions.
Example 10.7 The following statements can be used to draw the bell-shaped membership
functions for diﬀerent combinations of parameters a, b, c, in Figure 10.2.
>> x=[0:0.05:10]’; y=[]; a0=1:5; b=2; c=3;
for a=a0, y=[y gbellmf(x,[a,b,c])]; end
y1=[]; a=1; b0=1:4; c=3; for b=b0, y1=[y1 gbellmf(x,[a,b,c])]; end
y2=[]; a=2; b=2; c0=1:4; for c=c0, y2=[y2 gbellmf(x,[a,b,c])]; end
subplot(131), plot(x,y); subplot(132), plot(x,y1);
subplot(133), plot(x,y2)
It can be seen from the curves that the shapes of the membership function can be
modiﬁed by changing respectively the parameters a, b, c. One may use these parameters to
shape the membership functions depending on the application requirements.
(ii) Gaussian membership functions
The mathematical description to Gaussian
membership function is given by
f(x) = e
−(x−c)2
2σ2 ,
(10-1-2)
and function gaussmf() in Fuzzy Logic Toolbox can be used to evaluate the membership
function with y = gaussmf(x,[σ,c]), where x is the value of independent variable x, and
y contains the values of membership function.

490
Scientiﬁc Computing with MATLAB®
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
a = 1
a = 2
a = 3
a = 4
b = 2, c = 3
(a) a parameter changes
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
b = 4
b = 3
b = 2
b = 1
a = 2, c = 3
(b) b parameter changes
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
c = 1
c = 2
c = 3
c = 4
a = 2, c = 2
(c) c parameter changes
FIGURE 10.2: Bell-shaped membership function.
Example 10.8
For diﬀerent values of c and σ, the Gaussian membership function can be
drawn as shown in Figure 10.3. The shape of the function is the same as the normal PDF
studied in Chapter 9. It can be seen that when the values of c change, the shape of the
membership function is unchanged. Only translations are made.
>> x=[0:0.05:10]’; y=[]; c0=1:4; s=3; y1=[]; c=5; sig0=1:4;
for c=c0, y=[y gaussmf(x,[s,c])]; end
for sig=sig0, y1=[y1 gaussmf(x,[sig,c])]; end;
subplot(121), plot(x,y); subplot(123), plot(x,y1)
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
c = 1
c = 2
c = 3
c = 4
σ = 3
(a) c parameter
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
σ = 4
σ = 3
σ = 2
σ = 1
c = 5
(b) σ parameter
FIGURE 10.3: Gaussian membership function.
(iii)
Sigmoid membership functions
The mathematical description to sigmoid
membership function is given by
f(x) =
1
1 + e−a(x−c) ,
(10-1-3)
which can be evaluated with the MATLAB function y = sigmf(x,[a,c]).
Example 10.9
The shapes of sigmoid function for diﬀerent parameters of a and c are
visualized in Figure 10.4. When c varies, the curve may translate to left or right with the
shape of the curve unchanged.

Topics on Nontraditional Mathematical Branches
491
>> x=[0:0.05:10]’; y=[]; c0=1:3; a=3;
for c=c0, y=[y sigmf(x,[a,c])]; end
y1=[]; c=5; a0=1:2:5; for a=a0, y1=[y1 sigmf(x,[a,c])]; end;
subplot(121), plot(x,y); subplot(122), plot(x,y1)
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
c = 1
c = 2
c = 3
a = 3
(a) changing c
0
2
4
6
8
10
0
0.2
0.4
0.6
0.8
1
a = 5
a = 3
a = 1
c = 5
(b) changing a
FIGURE 10.4: Sigmoid membership function.
II. An interactive membership function editor
A graphical user interface is provided for membership function manipulations in the
Fuzzy Logic Toolbox: the command mfedit can be used to open the interface shown in
Figure 10.5. The prototypes of three membership functions are given, and one can edit the
membership function with mouse drag and click.
If one more fuzzy set, or membership function is to be added, the menu item Edit →Add
custom MF can be selected and a dialog box is shown in Figure 10.6 (a). The membership
function can then be introduced as shown in Figure 10.6 (b).
III. Building fuzzy inference systems
The newfis() function provided in the Fuzzy Logic Toolbox can be used to construct
the data structure of the fuzzy inference system (FIS). The syntax of the function is
ﬁs = newfis(name), where the string variable name is used to describe the name of the
FIS. The structured variable fis can be established. The properties in the FIS include the
fuzziﬁcation, fuzzy inference and defuzziﬁcation, etc. These properties can also be used in
the deﬁnition of newfis() function, or, they can be deﬁned later. Having deﬁned the FIS
object fis, the function addvar() can be used to deﬁne input and output variables to the
object, with the following syntaxes
fis = addvar(fis,’input’,iname,vi)
% add an input variable iname
fis = addvar(fis,’output’,oname,vo)
% add an output variable oname
where vi and vo are the ranges, i.e., the universes, of the input and output variables.
They are described as row vectors of the minimum and maximum of the variable. The
input and output variables can also be deﬁned with the graphical user interface fuzzy.
The membership functions can be speciﬁed with the addmf() function, or directly, with the
mfedit() interface.

492
Scientiﬁc Computing with MATLAB®
FIGURE 10.5: Editing interface for membership functions.
(a) Edit menu
(b) modiﬁed membership function
FIGURE 10.6: Modiﬁcations of membership functions.
Example 10.10 Suppose that there are two input variables, ip1 and ip2, and one output
variable op. Assume that the universe of the input ip1 is (−3, 3), with three membership
functions, all selected as bell-shaped function. The universe for input signal ip2 is (−5, 5),
also three Gaussian-type membership functions are deﬁned. The universe of the output op
is (−2, 2), whose membership function is sigmoidal functions. The framework of the fuzzy
inference system can be established. Also, the graphical user interface fuzzy() can be used
to edit the FIS.
>> fff=newfis(’c10mfis’);
% set up a new fuzzy inference model
fff=addvar(fff,’input’,’ip1’,[-3,3]);
% deﬁne input 1
fff=addvar(fff,’input’,’ip2’,[-5,5]);
% deﬁne input 1

Topics on Nontraditional Mathematical Branches
493
fff=addvar(fff,’output’,’op’,[-2,2]);
% deﬁne the output
fuzzy(fff)
% edit using graphical interface fuzzy()
The fuzzy inference system modiﬁcation interface can be opened with the function
fuzzy(), as shown in Figure 10.7.
FIGURE 10.7: Graphical user interface of fuzzy inference system.
The Edit →Membership functions menu item can be selected in the interface, and the
membership function editing interface will be displayed as shown in Figure 10.5. The icon
labeled ip1 in the interface can be selected, and Edit →Add MFs menu item can be selected,
a dialog box shown in Figure 10.8 (a) opens. The user can deﬁne the membership functions
in the dialog box. For instance, the output membership function, after editing procedure,
can be obtained as shown in Figure 10.8 (b).
(a) membership function dialog box
(b) modiﬁed membership function for output
FIGURE 10.8: Edited results of membership functions.

494
Scientiﬁc Computing with MATLAB®
10.1.3
Fuzzy rules and fuzzy inference
I. Fuzziﬁcation
If three fuzzy sets or membership functions are deﬁned for a certain signal, the physical
meanings of the three sets may be “very small,” “medium” and “very large.” If ﬁve sets
are used, the physical meanings can also be deﬁned as “very small,” “small,” “medium,”
“large” and “very large.” An exact signal can be fuzziﬁed into a fuzzy signal.
II. Fuzzy rules and inference
If all the input signals are fuzziﬁed, the if – else clauses can be used to represent the
fuzzy inference relationship. For instance, if the input signal ip1 is “very small,” and input
ip2 is “very large,” then, set the output signal op to “very large.” The inference rule can
be represented by
if ip1 is “ very small” and ip2 is “very large,” then, op = “very large”
Fuzzy inference rule can be established with the ruleedit() interface, or by the menu
item Edit →Rules in the mfedit() interface. A typical rule editing interface is shown in
Figure 10.9, and the user can add all rules to the rule library, with the Add rule button.
One may also delete certain rules by clicking the Delete rule button.
FIGURE 10.9: Edit box of fuzzy inference rules.
The rules can further be modiﬁed by clicking the Change Rule button. When the
modiﬁcation of the rules is completed, the Close button can be used to close the relevant
windows. The fuzzy inference can be displayed as 3D surfaces with the View →Surface
button, as shown in Figure 10.10, indicating the map from input signals to outputs.
Fuzzy rules can also be expressed by vectors. Multiple rules can be expressed by matrices
comprising diﬀerent vectors. The matrix is referred to as a fuzzy rule matrix. In each row of
the matrix, there are m+n+2 elements, where m and n represent the numbers of input and
output variables. The ﬁrst m elements in the vector correspond to the sequence numbers

Topics on Nontraditional Mathematical Branches
495
FIGURE 10.10: 3D surface.
of the input fuzzy sets, while the next n elements correspond to the numbers of the output
sets. The (m + n + 1)th element expresses the weight, while the last element represents the
logic relationship, such that 1 represents “and” and 2 represents “or.” For instance, the
third rule in Example 10.9 can be expressed by vector [3, 2, 1, 1, 2].
From these rule vectors, a matrix R consisting of all the rule vectors can be
established. The following command can be used to add a rule matrix to a fis object:
fis = addrule(fis,R).
III. Defuzziﬁcation
Through fuzzy inference, a fuzzy output variable op can be generated. In practice, the
exact or crispy value of the obtained fuzzy output signal is needed. The process of converting
a fuzzy signal to the exact signal is referred to as defuzziﬁcation. Various defuzziﬁcation
algorithms are supported in the Fuzzy Logic Toolbox, and they can be selected from the
dialog box in Figure 10.7, i.e., from the list box shown in Figure 10.11.
FIGURE 10.11: FIS system.
The fuzzy inference data thus created can be saved to a ﬁle by the File →Export →To
Disk menu item, with the ﬁle extension of *.fis. For instance, the fuzzy inference system
created above can be saved into ﬁle c10mﬁs.ﬁs. The process can be saved too with the
writefis() function. The menu item File →Export →To Workspace saves the FIS into
MATLAB workspace.
Fuzzy inference problems can be solved by y = evalfis(X,fis) function where X
is a matrix, whose columns contain the exact values of each input signal. The function
evalfis() can be used to deﬁne the fuzzy inference system, to perform fuzziﬁcation ﬁrst,
then, to perform fuzzy inference and ﬁnally to defuzzify the inference results. The exact
output is returned in argument y.

496
Scientiﬁc Computing with MATLAB®
Example 10.11
Assume that the fuzzy inference system is the one deﬁned in the last
example. Draw the 3D surface of the fuzzy inference results.
Solution The following statements can be used to import the fuzzy inference system, draw
mesh grids in the interested region on the x-y plane, and call evalfis() function to evaluate
the z values. The 3D surface can then be obtained as shown in Figure 10.12.
>> fff=readfis(’c10mfis.fis’);
% read in the fuzzy inference system
[x,y]=meshgrid(-3:.2:3,-5:.2:5);
% create mesh grids
x1=x(:); y1=y(:); z1=evalfis([x1 y1],fff); % fuzzy inference
z=reshape(z1,size(x)); surf(x,y,z)
% surface plot
−3
−2
−1
0
1
2
3
−5
0
5
−2
−1
0
1
2
FIGURE 10.12: Output surface obtained from fuzzy inference system.
10.2
Rough Set Theory and Its Applications
10.2.1
Introduction to rough set theory
I. Rough set theory
The idea of rough set was publicized by Professor Zdzislaw Pawlak, a Polish mathemati-
cian, in 1982, for the development of automatic rule generation systems and soft-computing
problems. In the earlier 1990s, the researchers began to realize the importance of rough sets.
In 1991, Pawlak published a research monograph, which established the mathematical basis
of rough sets [3]. Rough set theory provides a new mathematical framework for processing
imprecise and incomplete information, and ﬁnding hidden rules from huge amounts of data.
It is widely recognized that rough set theory is the foundation for data mining, knowledge
discovery and information reduction problems.
II. Fundamental concepts in rough sets
Assume that X, Y ∈U and R is the equivalent relationship deﬁned on the universe U.
The lower-approximation set of the set X on R is deﬁned as
R(X) =
;
{Y ∈U/R : Y ⊆X},
(10-2-1)

Topics on Nontraditional Mathematical Branches
497
where R(X) is the maximum set of entities that for sure belong to the set X, also referred
to as positive region, denoted by POS(X).
Similarly, the upper-approximation set of the set X on R is deﬁned as
R(X) =
;
{Y ∈U/R : Y ∩R ̸= φ},
(10-2-2)
where φ is an empty set, and R(X) is the minimum set of entities which possibly belongs
to set X.
Based on the above deﬁnitions, the boundary set can be deﬁned as BND(X) =R(X)−
R(X). If BND(X) is an empty set, the set X reduces to a crisp set on R. If on the other
hand, BND(X) is non-empty, X is a rough set on R.
Suppose that the decision table can be represented by matrix S in MATLAB. One can
extract its ﬁrst m columns to represent conditional attributes C, and the rest of the columns
for decisional attributes D. The upper-approximation set R(X) and lower-approximation
set R(X) can be obtained by calling the rslower() and rsupper() functions, respectively,
such that
Sl = rslower(X,a,S)
% ﬁnd the lower-approximation set Sl
Su = rsupper(X,a,S)
% ﬁnd the upper-approximation set Su
Sd = setdiff(Su,Sl)
% ﬁnd the boundary set Sd
and the boundary set can be obtained by calling the setdiff() function in MATLAB. The
contents of rslower() and rsupper() functions are listed below
function w=rslower(y,a,T)
z=ind(a,T); w=[]; [p,q]=size(z);
for u=1:p,
zz=setdiff(z(u,:),0); if ismember(zz,y), w=cat(2,w,zz); end
end
function w=rsupper(y,a,T)
z=ind(a,T); w=[]; [p,q]=size(z);
for u=1:p
zz=setdiff(z(u,:),0); zzz=intersect(zz,y);
if length(zzz)~=0, w=cat(2,w,zz); end
end
and the common supporting function ind() is used to evaluate the indiscernibility
relationship to be deﬁned later.
Example 10.12
For the toy set U = {x1, x2, x3, x4, x5, x6, x7}. Assume that they have
three attributes, namely, “color R1,” “shape R2” and “size R3.” For the color attribute, it
is assumed that R1 = {0, 1, 2}, representing “red,” “green” or “blue.” The shape attribute
R2 = {0, 1, 2}, denoting “square,” “round” and “triangular.” The size attribute R3 = {0, 1},
indicating “large” and “small.”
For the relationship in the attributes, the red toys can be described as {x1, x2, x7},
green ones {x3, x4} and blue ones {x5, x6}. It can then be written as U|R1 = {{x1, x2, x7},
{x3, x4}, {x5, x6}}.

498
Scientiﬁc Computing with MATLAB®
III. Information decision system
The information decision system T can be expressed as a quadruple T = (U, A, C, D),
where U is the set of entities, i.e., the universe. A is the attribute set. If set A can further
be divided into conditional attribute set C and decisional attribute set D, i.e., C ∪D = A
and C ∩D = φ, the information system is referred to as a decision system or a decision
table.
In rough set theory, a decision table can be used to describe the entities in a given
universe. A decision table is a two-dimensional table with each row corresponding to an
entity, and each column corresponding to a certain attribute. Again the attributes can be
classiﬁed as conditional attributes and decisional attributes. The entities in the universe
can be classiﬁed into diﬀerent decisional classes due to its diﬀerent conditional attributes.
Table 10.2 is a typical example of a decision table. The universe U = {x1, x2, · · · } is a set
of entities, C = {c1, · · · , cm} is a conditional attribute set, while D = {d1, · · · , dk} is a
decisional attribute set. The term fij represents the jth conditional attribute of the ith
entity, and gij represents the jth decisional attribute of the ith entity.
TABLE 10.2: Decision table.
C
D
U
c1
c2
. . .
cm
d1
· · ·
dk
x1
f11
f12
. . .
f1m
g11
· · ·
g1k
x2
f21
f22
· · ·
f2m
g21
· · ·
g2k
...
...
...
...
...
...
...
...
xn
fn1
fn2
· · ·
fnm
gn1
· · ·
gnk
TABLE 10.3: Example 10.13.
C properties
D
U
a
b
c
d
sales
1
1
0
1
1
1
2
1
0
0
0
1
3
0
0
1
0
0
4
1
1
0
1
0
5
1
1
1
2
2
6
2
1
0
2
2
7
2
2
0
2
2
Example 10.13
Consider the toy problem in Example 10.12. Assume that there are four
relevant attributes, “a” for color, “b” for shape, “c” for size and “d” for price. It is known
that x1,2,4,5 are yellow, x3 is red and x6,7 are green. Also, x1,2,3 are square, x4,5,6 are round
and x7 is triangular; x1,3,5 are large while the rest is small; x2,3 are cheap ones, x1,4 are
medium priced and x5,6,7 are expensive ones. From sales status, x3,4 are good, x1,2 are
average and x5,6,7 are poor. Construct the decision table.
Solution
Assume that for the color attribute, {0, 1, 2} can be used to describe “red,”
“yellow” and “green;” for shape, {0, 1, 2} for “square,” “round” and “triangular;” for size,
{0, 1} for “small” and “large;” for price, {0, 1, 2} for “low,” “medium” and “high,” and for
sales, the decision attribute, {0, 1, 2} for “good,” “average” and “poor.” The decision table
can easily be constructed as shown in Table 10.3. One of the applications of rough set theory
is that it can be used to check which of the conditional attributes contributes the most to the
sales attribute, and which has little impact.
Example 10.14 Let the universe U = {x1, x2, x3, x4, x5, x6, x7, x8, x9, x10}, with relations
R = {R1, R2}, and
U/R1 = {{x1, x2, x3, x4}, {x5, x6, x7, x8}, {x9, x10}},
U/R2 = {{x1, x2, x3}, {x4, x5, x6, x7}, {x8, x9, x10}}
If X ={x1, x2, x3, x4, x5}, ﬁnd the upper- and lower-approximation sets of X.
Solution
From the given conditions, the three subsets for U/R1 and U/R2 can be

Topics on Nontraditional Mathematical Branches
499
represented as {0, 1, 2}. Thus, the decision table in Table 10.4 can be established in S.
Here the decision table is rotated for neat type-setting purposes. If X = {1, 2, 3, 4, 5}, the
ﬁrst two columns can be extracted for vector a. The upper- and lower-approximation sets of
X can be obtained by using
TABLE 10.4: Rotated decision table.
Universe X
x1
x2
x3
x4
x5
x6
x7
x8
x9
x10
U/R1 relation
0
0
0
0
1
1
1
1
2
2
U/R2 relation
0
0
0
1
1
1
1
2
2
2
>> S=[0,0; 0,0; 0,0; 0,1; 1,1; 1,1; 1,1; 1,2; 2,2; 2,2];
X=[1,2,3,4,5]; a=[1,2]; S1=rslower(X,a,S)
S2=rsupper(X,a,S), Sd=setdiff(S2,S1)
% compute the three sets
The sets are obtained as S1 = [1, 2, 3, 4], S2 = [1, 2, 3, 4, 5, 6, 7] and Sd = [5, 6, 7].
It can be seen from the decision table that, the sets for {U/R1, U/R2} are {0, 0},
{0, 1}, {1, 1}, {1, 2} and {2, 2}. For the selected entities X = {1, 2, 3, 4, 5}, those involved
with {U/R1, U/R2} are only {0, 0}, {0, 1} and {1, 1}. Thus, those belonging to set X
are {1, 2, 3, 4}, i.e., {x1, x2, x3, x4}. The lower-approximation set is then {x1, x2, x3, x4}.
Similarly, the set with the entities which may probably belong to X is the upper-
approximation set of X. Since x6, x7 and x5 are all {1, 1}, thus, apart from the entities in
the lower-approximation set, the upper-approximation set also includes x5, x6, x7. The latter
three entities belong to the boundary set. Besides, since the boundary set is non-empty, it
belongs to a rough set.
In the information system, for each subset R ⊆A, the indiscernibility relationship is
deﬁned as
IND(R) = {(x, y) ∈U × U : r ∈R : r(x) = r(y)}.
(10-2-3)
The MATLAB implementation of the function is listed below
function aa=ind(a,x)
[p,q]=size(x); [ap,aq]=size(a); z=1:q;
tt=setdiff(z,a); x(:,tt(size(tt,2):-1:1))=-1;
for r=q:-1:1, if x(1,r)==-1, x(:,r)=[]; end, end
for i=1:p, v(i)=x(i,:)*10.^(aq-[1:aq]’); end
y=v’; [yy,I]=sort(y); y=[yy I];
[b,k,l]=unique(yy); y=[l I]; m=max(l); aa=zeros(m,p);
for ii=1:m, for j=1:p, if l(j)==ii, aa(ii,j)=I(j); end, end, end
10.2.2
Data processing problem solutions using rough sets
I. Reductions in rough set
Nowadays people live in the information explosive era. It is easier and easier to get more
and more information. However, a huge amount of unprocessed information causes “data
disasters.” To tackle this kind of problem, the so-called data mining techniques should be
used.

500
Scientiﬁc Computing with MATLAB®
The aim of the reduction of information system is simply deleting and neglecting
the unnecessary and redundant information, without aﬀecting the original decision. New
decision rules can be generated with the reduced information set.
Attribute reduction means ﬁnding the minimum set of conditional attributes without
aﬀecting the decisional attributes. One decision table may simultaneously have several
reductions. The set of attributes which is common to all the reductions is referred to as the
core set of R, denoted as Core(R).
Details of the attribute reduction algorithms are not given here. Only a few MATLAB-
based functions, such as redu() and core(), are introduced with their usage explained.
The Rough Set Data Analysis (RSDA) Toolbox with the related functions can be obtained
from the aforementioned book. For details of the algorithms and implementations, please
refer to Reference [4]. The updated version of the Toolbox is provided with the package of
the book.
Assume again that the decision table is described by matrix S, whose c columns are
stored in matrix C for conditional attributes, and the d columns are the decisional attributes
in matrix D. Thus, the minimum set of attributes can be extracted by the redu() function,
and the core set can be extracted by using the function core(), with the following syntaxes
y = redu(c,d,S)
% attribute reduction, the minimum set from C to D
y = core(c,d,S)
% extract the core set from C to D
II. Application examples of rough set in information reduction
With the use of the attribute reduction concepts, and in particular, the relevant
MATLAB functions, two illustrative examples are demonstrated in the following [4].
Example 10.15
LCDs are often used to show the 10 digits, from 0∼9, with a seven-
segment display unit. The seven-segment display units are shown in Figure 10.13 (a). If a
a
d
b
c
g
f
e
(a) seven-segment display
(b) reduced display
FIGURE 10.13: LCD displays and reduction results.
segment is lighted, it is denoted as 1, otherwise, 0. The truth table for the encoding system
is given in Table 10.5. Find the unnecessary segments by attribute reduction using rough
set theory.
Solution
For digit recognition by human vision, it is necessary to use a seven-segment
LCD display. If one segment is missing, the recognition of digits may become very diﬃcult.
However, sometimes it may not be necessary to have all the seven segments in place in
order to recognize digit by computer vision. If one does ﬁnd a certain segment which is not
necessary, the LCD display may be reduced or further simpliﬁed. With the use of rough set

Topics on Nontraditional Mathematical Branches
501
TABLE 10.5: Truth table of LCD.
code
C attributes
D
code
C attributes
D
X
a
b
c
d
e
f
g
value
X
a
b
c
d
e
f
g
value
0
1
1
1
1
1
1
0
0
5
1
0
1
1
0
1
1
5
1
0
1
1
0
0
0
0
1
6
1
0
1
1
1
1
1
6
2
1
1
0
1
1
0
1
2
7
1
1
1
0
0
0
0
7
3
1
1
1
1
0
0
1
3
8
1
1
1
1
1
1
1
8
4
0
1
1
0
0
1
1
4
9
1
1
1
1
0
1
1
9
techniques, reduction can be tried to check whether certain segments can be reduced, without
aﬀecting the recognition of digits. The following commands can be given
>> C=[1,1,1,1,1,1,0; 0,1,1,0,0,0,0; 1,1,0,1,1,0,1; 1,1,1,1,0,0,1;
0,1,1,0,0,1,1; 1,0,1,1,0,1,1; 1,0,1,1,1,1,1; 1,1,1,0,0,0,0;
1,1,1,1,1,1,1; 1,1,1,1,0,1,1];
D=[0:9]’; X=[C D]; c=1:7; d=8;
Y=core(c,d,X) % where columns 1-7 are C properties, 8 for D
with the reduction result Y = [1, 2, 5, 6, 7], which means that the segments a, b, e, f and g in
the LCD are irreducible. The segments 3 and 4, i.e., the segments c and d in Figure 10.13 (a)
can be removed without aﬀecting the recognition of digits by computers. The corresponding
mapping patterns are shown in Figure 10.13 (b). However, for human visual recognition,
the above reduction may be useless. On the other hand, for the recognition by machines, this
kind of reduction is no doubt useful, since less information is needed. The reduction idea
shown in this example is promising for character recognition via machine vision.
Example 10.16
The outbreak of severe acute respiratory syndrome (SARS) in 2003
caused terrors globally. The accurate diagnosis of SARS is very diﬃcult. Some data collected
from newspapers and magazines are given in Table 10.6. All the 12 attributes are analyzed
with rough set theory to see whether some of the attributes are redundant for the diagnosis
purpose. The major attributes can be found from the 12 attributes. It should be noted that
some data may not be accurate, and the entries are far from complete. Thus, the conclusion
here is not usable for clinical diagnosis.
Solution From the data given in the table, the reduction of attributes with rough sets can
be used to ﬁnd which attributes contribute much more towards the diagnosis of SARS
>> D=[1; 0; 0; 0; 0; 0; 0; 1; 1; 1; 1; 1];
C=[1,1,1,1,0,0,0,0,1,1,0,1; 0,0,0,0,0,0,0,0,0,0,0,0;
1,0,1,0,0,0,0,0,0,1,0,0; 0,0,0,1,1,1,1,0,1,0,1,1;
1,0,0,1,1,1,1,1,0,1,1,0; 0,1,0,1,1,1,1,1,1,0,0,1;
1,0,0,0,1,1,1,0,0,1,1,1; 1,1,1,1,0,0,0,0,1,1,0,1;
1,0,1,1,1,0,0,0,1,1,0,1; 1,1,1,1,0,0,0,0,1,1,0,1;
1,0,1,1,1,0,0,0,1,1,0,1; 1,0,1,1,1,0,0,0,1,1,0,1];
Y=redu(1:12,13,[C D])
with Y = [3, 4], indicating that attributes 3 and 4 are irreducible, which means that “blood
test” and “fever with temperature higher than 38◦C” are the irreducible attributes.

502
Scientiﬁc Computing with MATLAB®
TABLE 10.6: Collected incomplete data for diagnosing SARS.
universe
C properties
D
U
c1
c2
c3
c4
c5
c6
c7
c8
c9
c10
c11
c12
SARS
1
1
1
1
1
0
0
0
0
1
1
0
1
1
2
0
0
0
0
0
0
0
0
0
0
0
0
0
3
1
0
1
0
0
0
0
0
0
1
0
0
0
4
0
0
0
1
1
1
1
0
1
0
1
1
0
5
1
0
0
1
1
1
1
1
0
1
1
0
0
6
0
1
0
1
1
1
1
1
1
0
0
1
0
7
1
0
0
0
1
1
1
0
0
1
1
1
0
8
1
1
1
1
0
0
0
0
1
1
0
1
1
9
1
0
1
1
1
0
0
0
1
1
0
1
1
10
1
1
1
1
0
0
0
0
1
1
0
1
1
11
1
0
1
1
1
0
0
0
1
1
0
1
1
12
1
0
1
1
1
0
0
0
1
1
0
1
1
c1 — hacking cough, c2 — breath diﬃculties, c3 — blood test, c4 — temperature ⩾38◦C
c5 — X-ray test abnormal, c6 — with phlegm, c7 — high white blood cells, c8 — chill
c9 — ache in muscles, c10 — hypodynamia, c11 — pleurodynia, c12 — headache
III. MATLAB graphical user interface for rough set reduction
Based on the rough set theory and its reduction methods, a MATLAB interface is
written and included in the RSDA Toolbox. The command rsdav3 can be given to start
the interface, as shown in Figure 10.14. The Browse button can be used to import the
decision table, and the column numbers for attributes in C and D can also be speciﬁed.
Then, the Redu button can be used to perform attribute reduction tasks, and the results
are shown in the Results box. The free toolbox is provided in the book package.
10.3
Neural Network and Applications in Data Fitting Problems
Artiﬁcial neural networks (ANN) were originated from studying and understanding the
behavior of complicated neural networks of living creatures. In human brains, there are
about 1011 interlinked units, known as neurons. Each neuron has about 104 links with other
neurons [5]. When the mathematical representations of artiﬁcial neurons are established, the
interconnected neurons can be used to construct artiﬁcial neural networks. However, due to
the limitations of the status of computers today, neural networks as complicated as human
brains cannot be built so far.
In this section, an introduction to mathematical descriptions of artiﬁcial neurons
and neural networks are given ﬁrst, followed by the descriptions of MATLAB solutions
to the neural network-based problems. The neural networks graphical user interface is
demonstrated in detail.

Topics on Nontraditional Mathematical Branches
503
FIGURE 10.14: Graphical user interface for data analysis with rough sets.
10.3.1
Fundamentals of neural networks
I. Concept and structure of an artiﬁcial neuron
The structure of an artiﬁcial neuron is shown in Figure 10.15, where x1, x2, · · · , xn are
input signals. The weighted sum of them, plus the threshold b, forms linear function ui. The
signal is further processed by the nonlinear transfer function f(ui) to generate the output
signal y.
transfer
function f(·)
-

-
:
*
q
threshold b
weights w1
w2
output y
wk
wn
inputs x1
x2
...
...
xn
xk
y = f(ui)
ui =
n

i=1
wixi −b
-
FIGURE 10.15: Basic structure of an artiﬁcial neuron.
In this artiﬁcial neuron model, the weights wi and the transfer function or activation
function f(·) are the two important elements. The weights can be considered as the
intensities of the input signals which can be determined by repeated training from the
samples. Normally the transfer function should be selected as a monotonic function such
that the inverse function uniquely exists. Commonly used transfer functions are sigmoidal
functions and logarithmic sigmoidal functions, expressed respectively by
sigmoid function f(x) =
2
1 + e−2x −1 = 1 −e−2x
1 + e−2x ,
(10-3-1)
logarithmic sigmoid function
f(x) =
1
1 + e−x .
(10-3-2)
The simple saturation function and step function can also be used as transfer functions.
The shapes of some typical transfer functions are shown through the following examples.

504
Scientiﬁc Computing with MATLAB®
Example 10.17
Draw some of the commonly used activation functions.
Solution The following MATLAB statements can be used to draw the sigmoid functions,
as shown in Figure 10.16.
>> x=-2:0.01:2; y=tansig(x); plot(x,y)
The logsig() function can be used to replace the tansig() function to draw the logarithmic
sigmoid function. Also, other MATLAB functions can be used to draw the commonly used
transfer functions, as shown in Figure 10.16.
−2
−1
0
1
2
−1
−0.5
0
0.5
1
tansig(x) 
−2
−1
0
1
2
0
0.2
0.4
0.6
0.8
1
logsig(x) 
−2
−1
0
1
2
0
0.2
0.4
0.6
0.8
1
satlin(x) 
−2
−1
0
1
2
−1
−0.5
0
0.5
1 hardlims(x) 
−2
−1
0
1
2
0
0.2
0.4
0.6
0.8
1 radbas(x) 
−2
−1
0
1
2
0
0.2
0.4
0.6
0.8
1 tribas(x) 
FIGURE 10.16: Diﬀerent curves of the commonly used transfer functions.
II. Artiﬁcial neural networks
The artiﬁcial neurons can be connected together to form a network, known as the
artiﬁcial neural network. The word “artiﬁcial” is usually dropped oﬀand neural network is
commonly used. With diﬀerent ways of connections, diﬀerent types of neural networks can
be established. In this section, only the feedforward structure will be presented. Since in
the training procedure, the error is propagated in the reversed direction, this network type
is often referred to as the back-propagation (BP) neural network. The typical structure of
a BP neural network is shown in Figure 10.17. In the network, there are the input layer,
several intermediate layers known as hidden layers, and the output layer. In this book, the
last hidden layer is in fact the output layer.
There are signiﬁcant amounts of neural networks in literature, such as feedforward
networks, Hopﬁeld networks, self-organizing networks. In recent versions of Neural Network
Toolbox of MATLAB, several typical network structures are recommended. For instance, for
function ﬁtting and approximation purposes, the fitnet() function can be used to create
the neural network. Usually a two-layer feedforward neural network is adopted, and the
default training algorithm is Levenberg–Marquardt back-propagation algorithm.
For pattern recognition purposes, patternnet() is recommended.
10.3.2
Feedforward neural network
The use of a neural network is a three-step procedure. In the ﬁrst step, the neural network
structure should be deﬁned. In the second step, the network must be trained with samples,

Topics on Nontraditional Mathematical Branches
505
input layer
the 1st
hidden layer
· · ·
the kth
hidden layer
output layer
also the (k + 1)th layer
x1
x2
...
xn
1
2
h1
1
2
hi
1
2
hk
1
2
m
m = hk+1
y1
y2
...
ym
w11
w22
wnh1
w21
w12
w2h1
w1h1
wn1
wn2
v11
v22
vhkm
v21
v12
v2m
v1m
vhk1
vhk2
FIGURE 10.17: Basic structure of neural network.
and proper weights in the neurons should be found. In the third step, the generalization can
be made. In other words, simulation and validation of the network should be performed.
I. Network structure
Consider a feedforward neural network with two layers, i.e., k = 2, with m and n the
numbers of output and input ports, respectively. Denote p as the number of nodes in the
hidden layer. The illustration of the neural network is given in Figure 10.18. The signals
before and after the transfer functions of the hidden layer nodes are
uj =
n

i=1
wijxi + b1j,
u′
j = F1(uj),
j = 1, · · · , p,
(10-3-3)
where, b1j is the threshold of hidden layer nodes, while the signals before and after the
transfer functions at the output layer are respectively
y′
j =
p

i=1
vjiu′
i + b2j,
yj = F2(y′
j),
j = 1, · · · , m.
(10-3-4)
1
2
p
1
2
p
F1(x)
F1(x)
F1(x)
1
n
-
-
-
j
3
7
*
z
w
x1
xn
w11
w1p
w12
wnp
-
-
-
1
m
1
m
F2(x)
F2(x)
-
-
-
-
y1
ym
q
R
:
j
7
*
v11
vpm
u′
1
u1
up
u′
p
y′
1
y′
m
hidden layer
output layer
input signals
FIGURE 10.18: Structure of the feedforward neural network with one hidden layer.
If there are N sets of practical sample data for training, the relationships between the

506
Scientiﬁc Computing with MATLAB®
inputs and outputs are as follows
x11
x12
· · ·
x1n
⇒
ˆy11
· · ·
ˆy1m
x21
x22
· · ·
x2n
⇒
ˆy21
· · ·
ˆy2m
...
...
...
...
...
...
...
xN1
xN2
· · ·
xNn
⇒
ˆyN1
· · ·
ˆyNm.
(10-3-5)
The problem in neural network training is to train the network repeatedly with the
weighting quantities wij, vij and threshold bij, such that the error between the computed
output yi and the real output signal ˆyi is minimized. An appropriate criterion is to have
the sum of the squared errors minimized
min
W , V , B
N

l=1
m

i=1
(yli −ˆyli)2.
(10-3-6)
For this kind of unconstrained optimization problem, the target is to solve equations, and
ﬁnd the ﬁnal weighting matrices W and V , to minimize the criterion. Various algorithms
can be used to select the initial values of weighting quantities Wij, Vij, and assume the
initial values are assigned as W 0
ij, V 0
ij, the following recursive algorithm can be used [6]
W l+1
ij
= W l
ij + βel
jal
i,
V l+1
jt
= V l
jt + αdl
tγl
j,
(10-3-7)
where, i = 1, · · · , n,j = 1, · · · , p, t = 1, · · · , m, and α and β are the velocity constants.
Intermediate variables al
i, γl
j, el
j and dl
t can be evaluated recursively.
It is quite easy to construct a feedforward network under BP algorithm with the Neural
Network Toolbox of MATLAB. The function fitnet() can be used, with the syntax
net = fitnet([h1,h2,· · · ,hk]), where, hi are number of nodes in the ith hidden layer.
It is worth mentioning that the actual number of layers is k + 1, with the last layer the
output layer with linear transfer functions. The neural network object net is then created,
whose important properties are listed in Table 10.7. Examples are given below to show the
creation of neural network objects.
Example 10.18
Assume that there are two inputs and one output signal. Establish a
feedforward neural network object with the fitnet() function.
Solution
Consider a feedforward network, with one hidden layer composed of 8 nodes.
The following statements can be used to establish the neural network object in MATLAB
workspace
>> net=fitnet(8); % one hidden layer with 8 nodes
In fact, a two-layer network is constructed, with the second layer the output layer, and
the number of nodes are in fact the number of output signals.
Now assume that in a new network, there are two hidden layers. In the ﬁrst hidden layer
there are 4 nodes, and in the second layer, there are 8 nodes. The following statements can
be used to establish the neural network model.
>> net=fitnet([4 6]); % two hidden layers, with 4 and 6 nodes in each layer

Topics on Nontraditional Mathematical Branches
507
TABLE 10.7: Common properties of neural network.
property names
data type
descriptions
defaults
net.IW
cell
input and hidden layer weights, where net.IW{1}
stores the weights of the ﬁrst hidden layer, while
net.IW{i + 1} for the ith hidden layer
random
net.numInputs
integer
number of inputs, it can be calculated automatically
from the sizes of xm or xM
net.numLayers
integer
number of layers
net.LW
cell
output layer weighting matrix
random
net.trainParam.epochs
integer
maximum training steps, when the error criterion is
met, the training stops
100
net.trainParam.lr
double
learning rate
0.01
net.trainParam.goal
double
training error criterion, if the error is smaller than this
value, the training stops
0
net.trainFcn
string
training
algorithms,
the
selectable
options
are
’traincgf’ (conjugate gradient with Fletcher–Reeves
updates),
’train’
(batch
training),
’traingdm’
(gradient
descent
with
momentum),
’trainlm’
(Levenberg-Marquardt algorithm)
’train’
II. Training of neural networks
If the neural network model net has been established, the function train() can be used
to train the parameters in the network
[net,tr,Y1,E] = train(net,X,Y )
where the variable X is an n × M matrix, with n the number of input signals, and M the
number of samples for training. The variable Y is an m × M matrix, with m the number
of outputs. The variables X and Y store respectively the inputs and outputs data of the
samples. From the function call, the network can be trained, and the returned variable net
is the trained object. The argument tr is a structured variable with training information,
where tr.epochs returns the number of epochs, meaning steps in the training process of an
artiﬁcial neural network, and tr.perf returns the objective function values in each training
step. The arguments Y1 and E matrices are the output and model errors of the network,
respectively, and the training error can be visualized by plotperform(tr).
If the training up to the maximum epochs cannot ﬁnd a satisfactory network, a warning
message will be given. The training results can be used as the initial weights, and one can
continue the training process until a satisfactory network is obtained. If the satisfactory
network still cannot be obtained, there might be problems in the network structure and a
new structure should be tested.
III. Generalization of neural networks
After training, the neural network can be tested and validated, then, it can be used as a
computation unit. In practical applications, the samples can be divided randomly into two
groups, with one group used in training, and the other group used in validation.
When the input signals other than the ones in the samples are provided, the output can
be evaluated from the unit. This process is also known as the simulation or generalization
of neural networks. This process can be used to solve data ﬁtting problems. For the

508
Scientiﬁc Computing with MATLAB®
input signals in matrix X1, the output can be evaluated using the function sim() where
Y1 = sim(net,X1). Alternatively, if net is the name of the neural network object, the
function Y1 = net(X1) can be used directly to compute the output signals.
Example 10.19
For the problem in Example 8.25, use neural network to ﬁt the data.
If the input signal is a sinusoidal function, please compute the output signal through the
neural network.
Solution The following statements can be given to compute the sample data. A two-layer
feedforward network structure can be selected. Assume that the hidden layer comes with 5
nodes. The network parameters are trained for generalization, with the training error shown
in Figure 10.19 (a) and the generalization results shown in Figure 10.19 (b). It can be
observed that the training is satisfactory, and almost no diﬀerence can be observed from the
true results.
>> x=0:.5:10; x0=[0:0.1:10];
y=0.12*exp(-0.213*x)+0.54*exp(-0.17*x).*sin(1.23*x);
y0=0.12*exp(-0.213*x0)+0.54*exp(-0.17*x0).*sin(1.23*x0);
net=fitnet(5); [net,tr]=train(net,x,y); subplot(121), plotperform(tr)
y1=net(x0); subplot(122), plot(x,y,’o’,x0,y0,x0,y1,’:’);
0
5
10
15
20
25
30
35
40
10
−8
10
−6
10
−4
10
−2
10
0
Best Validation Performance is 3.2463e−05 at epoch 34
Mean Squared Error  (mse)
40 Epochs
 
 
Train
Validation
Test
Best
test
validation
train
best
(a) training error
0
2
4
6
8
10
−0.4
−0.2
0
0.2
0.4
0.6
(b) ﬁtting by neural network
FIGURE 10.19: Data ﬁtting with neural network.
The following statements can be used to extract the weights of the trained neural network
>> w1=net.IW{1}, w2=net.LW{2,1} % weights for hidden layer and output
and the weights obtained are
from input to hidden layer: wT
1 = [7.4494, −3.8019, −3.9805, 4.5079, 7.6978],
from hidden layer to output:
w2 = [0.1988, 0.7808, −1.0970, −1.4687, 1.0793]
and each time, the trained weights may be completely diﬀerent. The weights of the neural
network have no physical meaning; slight change in the weights may lead to diﬀerent
computation results.
The structure of the neural network can be obtained with command view(net), as shown
in Figure 10.20.
The number of hidden layer nodes can further be increased, for instance, to 20. The

Topics on Nontraditional Mathematical Branches
509
FIGURE 10.20: Structure of feedforward neural network.
new network can be created and trained, and the training error reaches an extremely small
value for only 4 epochs, as shown in Figure 10.21 (a). The curve ﬁtting, i.e., generalization,
results are shown in Figure 10.21 (b).
>> net1=fitnet(20); [net1,tr]=train(net1,x,y);
subplot(121), plotperform(tr)
subplot(122), y1=net1(x0); plot(x0,y0,x0,y1,x,y,’o’)
0
0.5
1
1.5
2
2.5
3
3.5
4
10
−15
10
−10
10
−5
10
0
Best Validation Performance is 0.049861 at epoch 1
Mean Squared Error  (mse)
4 Epochs
 
 
Train
Validation
Test
Best
train
best
(a) training error
0
2
4
6
8
10
−0.3
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5
0.6
(b) ﬁtting results with neural network
FIGURE 10.21: Fitting results with 20 nodes in the hidden layer.
It can be seen from the generalization results that the curve ﬁtting results are very poor,
albeit on the samples, the ﬁttings are good. This means that due to the increase of hidden
layer nodes, the generalization process goes wrong. However, to date there is no universally
accepted method on how to assign reasonable numbers of nodes. The node numbers and
number of layers can only be assigned by trial-and-error methods.
If a neural network object net is created, function gensim(net) can be used to generate
a Simulink model for the network. Therefore, the neural network block generated can be
directly used in simulation.
Example 10.20
For the neural network constructed in the previous example, please
evaluate the output of the system under Simulink environment, if the input signal is a
sinusoidal signal.
Solution A Simulink block can be generated with gensim() function, and the sinusoidal
signal block is used as the input of the system, shown in Figure 10.22 (a). With the excitation
of the sinusoidal input, the output of the system can be obtained with the Simulink model.
Alternatively, the same output signal can be obtained with the commands, as shown in Figure
10.22 (b).

510
Scientiﬁc Computing with MATLAB®
>> t=0:0.01:2*pi; y=net(sin(t)); plot(tout,yout,t,y,’--’)
(a) Simulink model (c10mnn1a.mdl)
0
1
2
3
4
5
6
7
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5
0.6
(b) output signal
FIGURE 10.22: Simulink model and output signal.
Example 10.21 Fitting the two-dimensional data with neural network for the data given
in Example 8.7.
Solution The data for neural network training and generalization can be generated ﬁrst,
and a two-layer neural network, with 20 nodes in the hidden layer can be established and
trained, and the generalized surface obtained is shown in Figure 10.23 (a). It can be seen
that the ﬁtting is not good.
>> N=200; x=-3+6*rand(1,N); y=-2+4*rand(1,N);
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y);
[x2,y2]=meshgrid(-3:.1:3, -2:.1:2); x1=x2(:)’; y1=y2(:)’;
net=fitnet(20); [net,b]=train(net,[x; y],z);
z1=net([x1; y1]); z2=reshape(z1,size(x2)); surf(x2,y2,z2)
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) two-layer network
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(b) three-layer network
FIGURE 10.23: Fitting results with diﬀerent structures.
We can now try a three-layer network structure. Assume that there are 10 nodes each in
hidden layers 1 and 2. In the third layer, of course, one should use one node, the same as
the number of outputs. The generalization result, represented as a 3D surface, is shown in
Figure 10.23 (b). The ﬁtting quality is signiﬁcantly improved with the new neural network.

Topics on Nontraditional Mathematical Branches
511
>> net=fitnet([10,10]); [net,b]=train(net,[x; y],z);
z1=net([x1; y1]); z2=reshape(z1,size(x2)); surf(x2,y2,z2)
Now select 20 nodes in both hidden layers. From the new generalization results shown
in Figure 10.24 (a), it can be seen that even though the number of nodes increased, the
generalization becomes even worse.
>> net=fitnet([20,20]); [net,b]=train(net,[x; y],z);
z1=net([x1; y1]); z2=reshape(z1,size(x2)); surf(x2,y2,z2)
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(a) 20 nodes in both layers
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
(b) four-layer network
FIGURE 10.24: Fitting results with diﬀerent structures.
A four-layer neural network can also be tried, with 7 nodes each on the three hidden
layers. The ﬁtting result is shown in Figure 10.24 (b). It can be seen that the ﬁtting quality
is even better than the one in Figure 10.23 (b).
>> net=fitnet([7 7 7]); [net,b]=train(net,[x; y],z);
z1=net([x1; y1]); z2=reshape(z1,size(x2)); surf(x2,y2,z2)
Example 10.22 Consider the exaggerated interpolation problem studied in Example 8.5,
where only ﬁve samples were used to restore the sinusoidal curve. Please check whether it
is possible to construct a neural network to do the same job.
Solution Diﬀerent number of nodes can be tried for the problem, however, unfortunately,
the sinusoidal curve cannot be restored with only ﬁve samples, an example of the ﬁtting
result is obtained in Figure 10.25. In the example in Chapter 8, due to the assumptions in
spline function, the sinusoidal curve can be restored easily.
>> x=[0,0.4,1 2,pi]; y=sin(x); x1=0:0.01:pi;
net=fitnet(10); net=train(net,x,y); y1=net(x1); plot(x1,y1,x,y,’o’)
10.3.3
Radial basis neural networks and applications
Radial basis function (RBF) is a type of exponential function deﬁned as
ϕ(x) = e−b||x−c|| = e−b(x−c)T(x−c),
(10-3-8)
where, c is the center, and b > 0 is an adjustable parameter. Function radbas() is used

512
Scientiﬁc Computing with MATLAB®
0
0.5
1
1.5
2
2.5
3
3.5
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
FIGURE 10.25: Failure in ﬁtting of a sinusoidal curve.
to compute the standard radial basis function yi = e−x2
i , and the function in (10-3-8) can
easily be found through simple computation.
Radial basis neural network is a special neural network structure. Consider the typical
two-layer feedforward neural network shown in Figure 10.18. If the transfer function of F1(x)
is radial basis function, while F2(x) in the output layer is a linear function, the network
structure is referred to as radial basis network.
Example 10.23
Draw the RBF curves for diﬀerent (c, b) parameters.
Solution
Selecting the centers at c = −2, 0, 2, and b = 1, the curves of the radial basis
functions can be obtained, as shown in Figure 10.26 (a). It can be seen that the shapes of
the curves are exactly the same. Only translations of c units are made.
>> x=-4:0.1:4; cc=[-2,0,2]; b=1;
for c=cc, y=exp(-b*(x-c).^2); plot(x,y); hold on; end
−4
−3
−2
−1
0
1
2
3
4
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
c = −2
c = 0
c = 2
0.8326
(a) diﬀerent c’s
−4
−3
−2
−1
0
1
2
3
4
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
b = 0.1
b = 1
b = 5
(b) diﬀerent b’s
FIGURE 10.26: Radial basis functions under diﬀerent parameters.
Selecting the center at c = 0, and assume b = [0.1, 1, 5], the curves of radial basis function
can be obtained as shown in Figure 10.26 (b).
>> x=-4:0.1:4; bb=[0.1,1,5]; c=0;
for b=bb, y=exp(-b*(x-c).^2); plot(x,y); hold on; end

Topics on Nontraditional Mathematical Branches
513
Although the structure of radial basis network is of feedforward type, it is not BP
network, since the training is not completed with back-propogation algorithms. With the
Neural Network Toolbox of MATLAB, it can be seen that the use of radial basis network
is easier, since two functions newrbe() and sim() can be used in the establishment and
training process. The number of hidden layer nodes is selected automatically with the
function call. Examples are given below to demonstrate the use of these functions.
Example 10.24
Consider the data in Example 10.19. Please ﬁt the curve using a radial
basis neural network.
Solution The samples can be generated ﬁrst, and the RBF neural can be created, trained
and generalized, and the ﬁtting results are shown in Figure 10.27. It can also be seen that
the ﬁtting quality is slightly better than the one with fitnet(). The default number of
hidden layer nodes is 21, and the weights can be retrieved with net.IW{1} and net.LW{2,1}
commands.
>> x=0:.5:10; y=0.12*exp(-0.213*x)+0.54*exp(-0.17*x).*sin(1.23*x);
u=[0:0.1:10]; v=0.12*exp(-0.213*u)+0.54*exp(-0.17*u).*sin(1.23*u);
net=newrbe(x,y); y1=net(u); plot(x,y,’o’,u,v,u,y1,’:’);
0
1
2
3
4
5
6
7
8
9
10
−0.3
−0.2
−0.1
0
0.1
0.2
0.3
0.4
0.5
0.6
FIGURE 10.27: One-dimensional ﬁtting.
−3
−2
−1
0
1
2
3
−2
−1
0
1
2
−0.5
0
0.5
1
1.5
FIGURE 10.28: Two-dimensional ﬁtting.
Example 10.25
Please ﬁt the 2D surface of Example 10.21 with RBF network.
Solution With RBF network, the ﬁtting surface can be obtained as shown in Figure 10.28,
and the number of hidden layer nodes is automatically selected as 121.
>> N=200; x=-3+6*rand(1,N); y=-2+4*rand(1,N);
z=(x.^2-2*x).*exp(-x.^2-y.^2-x.*y); net=newrbe([x; y],z);
[x2,y2]=meshgrid(-3:.1:3, -2:.1:2); x1=x2(:)’; y1=y2(:)’;
z1=sim(net,[x1; y1]); z2=reshape(z1,size(x2)); surf(x2,y2,z2)
Example 10.26
Let us revisit the exaggerated problem in Example 10.22. Please assess
the ﬁtting quality using RBF network.
Solution
With the following statements, the RBF network can be established, and the
ﬁtting result is obtained as shown in Figure 10.29, with 5 hidden layer nodes. It can be seen
that the ﬁtting quality is very high, and the numerical integral obtained is I = 1.9963. It
is more accurate than the cubic spline result in Example 8.18, yet less accurate than the
B-spline result.

514
Scientiﬁc Computing with MATLAB®
>> x=[0,0.4,1 2,pi]; y=sin(x); x1=0:0.01:pi; y0=sin(x1);
net=newrbe(x,y); y1=net(x1); plot(x1,y1,x1,y0,x,y,’o’)
f=@(x)net(x); I=integral(f,0,pi)
0
0.5
1
1.5
2
2.5
3
0
0.2
0.4
0.6
0.8
1
FIGURE 10.29: Fitting result of sinusoidal curve.
With view(net) command, the structure of the RBF network is obtained as shown in
Figure 10.30.
FIGURE 10.30: Structure of RBF network.
10.3.4
Graphical user interface for neural networks
A graphical user interface is provided in the Neural Network Toolbox. The command
nntool can be used to start the GUI shown in Figure 10.31. The interface can be used to
create neural network, then, train and simulate the network. The example below is given
to show the use of the interface.
Example 10.27
Consider the problem in Example 10.19. Use the nntool interface to
solve the same problem.
Solution The following statements can be used to import data into MATLAB workspace.
Then, nntool can be used to load the interface shown in Figure 10.31. The interface can be
used in neural network data ﬁtting.
>> x=0:.5:10; x0=[0:0.1:10];
y=0.12*exp(-0.213*x)+0.54*exp(-0.17*x).*sin(1.23*x);
y0=0.12*exp(-0.213*x0)+0.54*exp(-0.17*x0).*sin(1.23*x0);
nntool
% start the user interface of neural networks
Click the Import button to import the samples and the dialog box shown in Figure 10.32

Topics on Nontraditional Mathematical Branches
515
FIGURE 10.31: Graphical user interface for neural network.
FIGURE 10.32: Data input interface.
appears. Select the variables x and xx as input variables, and y as target variables, by
selecting the combinations in the interface.
Click the New Network button to select the structure of neural network, with the graphical
user interface shown in Figure 10.33 (a). The default (Feedforward Backprop) network
structure can be established, with (Number of layers) set to 2. The node numbers in each
layer can also be set, where the number for layer 1 is 8. One may also set the transfer
functions by selecting the Transfer Function list box to Logsig. Click the Create button, and
the neural network structure can be created.
The network structure can be displayed by clicking the View button, as shown in Figure
10.33 (b).
The network can be trained by clicking the Train button, and the dialog box shown in
Figure 10.34 is displayed. The training data can be speciﬁed ﬁrst and training parameters
can be set by clicking the Training Parameters tag to show the dialog box shown in Figure
10.35. The network can then be trained by clicking the Train button, and the training curve
is shown in Figure 10.19 (a). If the termination conditions are satisﬁed, the training stops

516
Scientiﬁc Computing with MATLAB®
(a) neural network structure setting
(b) display of neural network
FIGURE 10.33: Structure setting and display of neural network.
and the required parameters can be obtained. The trained network can be exported back to
the environment with the Export button. The generalization results are obtained with the
following statements, as shown in Figure 10.19 (b).
FIGURE 10.34: Dialog box for neural network training.
>> y1=sim(network1,x0); plot(x,y,’o’,x0,y0,x0,y1,’:’)
10.4
Evolutionary Computing and Global Optimization Problem
Solutions
It has been pointed out in Chapter 6 that the conventional searching methods in
optimization may lead to local optimum points. Thus, various parallel searching algorithms

Topics on Nontraditional Mathematical Branches
517
FIGURE 10.35: Training parameter setting dialog box.
are proposed, aimed at ﬁnding the global optimum solutions. Evolutionary computing is
attractive for the innovation of ideas, and its capabilities in ﬁnding the global optimum
solutions. Among the evolution methods, genetic algorithm based approaches and particle
swarm optimization algorithms are the most widely used ones. In this section, global
optimization algorithms and their application with MATLAB functions are presented.
10.4.1
Basic idea of genetic algorithms
Genetic algorithm (GA) is a class of evolutionary computing methods following the
law of “survival of the ﬁttest.” [7] The method was ﬁrst proposed by Professor John
Holland of Michigan University in 1975. The main idea of the method is to search from
a population consisting of randomly distributed individuals. The individuals are encoded,
regarded as genes with chromosomes, in a certain way. The population evolves generation
by generation through reproduction, crossover and mutation, until individuals with the best
ﬁtness function are found. Another similar method is the particle swarm optimization (PSO)
method, which imitates the coordinated motion in ﬂocks of birds searching for food. In this
section, MATLAB solutions to optimization problems using genetic algorithms and particle
swarm optimization methods are introduced.
The general procedures of a simple genetic algorithm are as follows:
(i) Select an initial population P0 with N individuals. Evaluate the objective functions
for all the individuals. The initial population P0 can be established randomly.
(ii) Set the generation to i = 1, which means the ﬁrst generation.
(iii)
Compute the values of selective functions, i.e., select some individuals in a
probabilistic way from the current population.
(iv) Create the population of the next generation Pi+1, by reproduction, crossover and
mutation.
(v) Set i = i + 1. If the termination conditions are not satisﬁed, go to (iii) to continue
evolution.
Compared with traditional optimization methods, the genetic algorithms have mainly
the following diﬀerences [8]:
(i) In searching the optimum points, the genetic algorithms allow searches from many
initial points in a parallel way. Thus, it is more likely to ﬁnd global optimum points than
with the traditional methods, which initiate searches from a single point.
(ii)
Genetic algorithms do not depend on the gradient information of the objective

518
Scientiﬁc Computing with MATLAB®
functions. Only the ﬁtness functions, i.e., objective functions are necessary in optimum
points search.
(iii) Genetic algorithms evaluate and select the objective function in a probabilistic way
rather than a deterministic way. Thus, there are slight diﬀerences among each run.
10.4.2
Solutions to optimization problems with genetic algorithms
There are several genetic algorithm toolboxes under MATLAB. The Global Optimization
Toolbox (former name is Genetic Algorithm and Direct Search Toolbox, GADT) by
MathWorks is the oﬃcial toolbox, and its functions are updated in each release of MATLAB.
Apart from that, the Genetic Algorithm Optimization Toolbox (GAOT) [9] developed by
Christopher Houck, Jeﬀery Joines and Michael Kay, North Carolina State University and the
GA Toolbox [8] written by Peter Fleming and Andrew Chipperﬁeld of Sheﬃeld University
are among the most commonly used free toolboxes.
For instance, in the GAOT, the main function ga() was renamed as gaopt() to avoid
the conﬂict with ga() function in Global Optimization Toolbox. The new ﬁle name is used
throughout this book. The function can be used directly to solve optimization problems. The
beneﬁt of such a function is that the intermediate search results are also available. In GAOT
Toolbox, three selective functions are provided, such as roulette(), normGeomSelect()
and tournSelect(), with normGeomSelect() the default.
In this section, the two toolboxes are explored for optimization problems.
I. Applications of GAOT Toolbox in optimization
The gaopt() function in GAOT Toolbox is illustrated ﬁrst. gaopt() can be called in
the following formats:
[a,b,c]= gaopt(bound,fun)
% the simplest form
[x,b,c]= gaopt(bound,fun,p,v,P0,fun1,n)
% with more arguments
where bound=[xm,xM] stores the lower-bound xm and upper-bound xM of the decision
variables x. The argument fun is the ﬁle name string of M-function describing the objective
function. It should be noted that the description of objective function is diﬀerent from the
other optimization routines. Examples will be given later to demonstrate the syntax of the
objective function. The returned argument a is composed of the solution x and the value of
the objective function fopt. The argument b stores the information of the ﬁnal population.
The argument c returns the intermediate search results.
In the second syntax, the argument p is the additional variables in the objective function,
v is the display precision control vector, P0 is the initial population, and fun1 is the extra
function name, with default of ’maxGenTerm’, the maximum allowed generation, and n is
the number of generations. Of course, other functions are allowed, for instance, selective
function, and mutation function, etc. Details can be found from Reference [9].
Example 10.28 Now consider a simple function f(x) = x sin(10πx)+2, x ∈(−1, 2). Find
the maximum value of f(x), and the value of x.
Solution The objective function within the speciﬁed interval is drawn as shown in Figure
10.36, with the following simple MATLAB statements. Clearly, f(x) is oscillatory with many
extreme points in the interval.
>> ezplot(’x*sin(10*pi*x)+2’,[-1,2])

Topics on Nontraditional Mathematical Branches
519
−1
−0.5
0
0.5
1
1.5
2
0
0.5
1
1.5
2
2.5
3
3.5
4
xmax
FIGURE 10.36: Objective function curve.
Optimization functions provided in the Optimization Toolbox, like all traditional
optimization approaches, need the initial values for searching the optimum. Diﬀerent initial
values may yield diﬀerent optimization results. For this example, the following statements
are tested and the search results for diﬀerent initial values are given in Table 10.8.
>> f=@(x)-x.*sin(10*pi*x)-2; v=[];
for x0=[-1:0.8:1.5,1.5:0.1:2]
x1=fmincon(f,x0,[],[],[],[],-1,2); v=[v; x0,x1,f(x1)];
end
So, from this example, when the initial value is selected randomly, it may be very hard
to ﬁnd the global optimum point, unless the fmincon global() developed in Chapter 6 is
used.
TABLE 10.8: Optimal solutions from diﬀerent search points x0.
x0
x1
f(x1)
x0
x1
f(x1)
x0
x1
f(x1)
−1
−1
−2
1.4
1.4506983
−3.4503492
1.7
1.2508097
−3.2504050
−0.2
−0.65155382
−2.6507777
1.5
0.25396846
−2.2519973
1.8
1.8505475
−3.8502738
0.6
0.65155379
−2.6507777
1.6
1.6506138
−3.6503069
1.9
0.4522327
−2.4511207
To solve the problem with a genetic algorithm, an objective function should be expressed
by an M-function
function [sol,y]=c10mga1(sol,options)
x=sol(1); y=x.*sin(10*pi*x)+2;
It can be seen that the objective function description is diﬀerent from the ones required
by traditional optimization algorithms in the following sense: (i) the maximum function
is speciﬁed; (ii) the input and returned arguments are diﬀerently deﬁned. With the use of
gaopt() function, the following statements can be given.
>> [a,b,c,d]=gaopt([-1,2],’c10mga1’); x=a(1), f=a(2)
where the global result returned in a is x∗= 1.8505, with the optimum value f(x∗) = 3.8503.

520
Scientiﬁc Computing with MATLAB®
The intermediate results are given in Table 10.9, with the abbreviation gen. for the generation
number. It can be seen that from generation 12, the results obtained are acceptable for this
example.
TABLE 10.9: Intermediate search results using genetic algorithm.
generations
x
f(x)
generations
x
f(x)
generations
x
f(x)
1
1.833411
3.590014
6
1.85168
3.849101
11
1.850281
3.850209
2
1.647955
3.644557
8
1.851659
3.849144
12
1.85054
3.850274
3
1.858199
3.796899
9
1.851091
3.850004
100
1.850547
3.850274
Example 10.29 Find the minimum value of the function f(x) = (x1+x2)2+5(x3−x4)2+
(x2 −2x3)4 + 10(x1 −x4)4 using genetic algorithm.
Solution It is obvious that the global optimum solution to the problem is x1 = x2 = x3 =
x4 = 0. In order to use a genetic algorithm, the M-function below should be established. It
should be noted that here, the maximum objective function is expressed.
function [S,f]=c10mga3(S,options), x=S(1:3);
f=-(x(1)+x(2))^2-5*(x(3)-x(4))^2-(x(2)-2*x(3))^4-10*(x(1)-x(4))^4;
Selecting the ranges for xi such that −1 ⩽xi ⩽1, i = 1, 2, 3, 4, the function gaopt()
can be called to solve this optimization problem, with the intermediate results shown in Table
10.10.
TABLE 10.10: Intermediate search results using genetic algorithm.
generations
x1
x2
x3
x4
f(x1, x2, x3, x4)
1
0.053034683
0.40724952
0.13840848
−0.01682375
−0.33287436
5
0.063661288
0.084587914
0.042225122
0.096858012
−0.036913734
10
0.061948198
−0.00062694769
0.089349763
0.074719112
−0.0058649774
14
0.061948198
−0.035582875
0.089349763
0.074719112
−0.003874042
21
0.061948198
−0.039947967
0.089349763
0.087316197
−0.0027943115
28
0.030899005
−0.028464643
0.089349763
0.087316197
−0.0019697798
32
0.022521945
−0.0085565429
0.089313262
0.087316197
−0.0016188571
37
0.016334305
−0.0076107093
0.089291541
0.087316197
−0.0015513478
41
0.016334305
−0.0082057068
−0.02253066
−0.02328211
−9.5374641×10−5
44
0.014834811
−0.0082619779
−0.016819586
−0.017633545
−5.8042763×10−5
70
0.014761402
−0.013351969
−0.017506533
−0.017633545
−1.3300401×10−5
77
0.014761402
−0.013966665
−0.01184689
−0.01104842
−8.2658502×10−6
85
0.013772082
−0.013965442
−0.011333
−0.01107414
−4.1891828×10−6
100
0.013121641
−0.01320957
−0.010778171
−0.010696633
−3.264236×10−6
>> [a,b,c,d]=gaopt([-1,1; -1 1; -1 1; -1 1],’c10mga3’); x=a(1:4)
It is found from the solutions that x1 = 0.0131, x2 = −0.0132, x3 = −0.0108, x4 = −0.0107,
with some errors in the solutions.

Topics on Nontraditional Mathematical Branches
521
Similar to the procedures used in the previous example, here 2000 generations are tested.
The intermediate results are shown in Table 10.11. It can be found that the results are
x∗= [−0.0032, 0.0032, −0.0014, −0.0014], which are more accurate than the ones obtained
in the previous example.
>> xmM=[-ones(4,1),ones(4,1)];
[a,b,c,d]=gaopt(xmM,’c10mga3’,[],[],[],’maxGenTerm’,2000);
TABLE 10.11: Intermediate search results for more generations.
generations
x1
x2
x3
x4
f(x1, x2, x3, x4)
1
0.52943125
−0.18554265
0.17102598
0.42105685
−0.50969811
4
0.30026929
−0.15235023
0.0046551376
0.073501054
−0.072705948
9
0.25969559
−0.24700356
0.0046551376
0.073501054
−0.040194938
21
0.18429634
−0.17440885
0.051175939
0.073501054
−0.009963743
32
0.18448868
−0.17115196
0.055131714
0.062716218
−0.0089361333
40
0.15139802
−0.17115196
0.055131714
0.060727809
−0.0074944505
60
0.12157312
−0.14269825
0.0069953616
0.011040366
−0.0026235247
127
0.11836763
−0.11881963
0.0087307561
0.01355787
−0.0016683703
147
−0.055877859
0.060775121
0.0097285242
0.014063368
−0.00036014666
252
−0.044906673
0.04604043
0.0078889251
0.0078620251
−7.9664135×10−5
562
−0.025653189
0.024757092
0.0070596265
0.007048969
−1.2253193×10−5
765
−0.024463789
0.024672404
0.0070538013
0.007039069
−9.9062381×10−6
841
−0.0026816486
0.003508872
−0.001446297
−0.0014440959
−6.8602555×10−7
2000
−0.0031643672
0.0031641119
−0.0013999645
−0.0014000418
−1.3622025×10−9
Now consider again the unconstrained optimization problem in Chapter 6. The solution
to such a problem can be solved with the following statements
>> f=@(x)(x(1)+x(2))^2+5*(x(3)-x(4))^2+(x(2)-2*x(3))^4+10*(x(1)-x(4))^4;
ff=optimset; ff.MaxIter=10000; ff.TolX=1e-7;
x=fminsearch(f,10*ones(4,1),ff)
with the solution xT = [0.0304, −0.0304, −0.7534, −0.7534]×10−6. It can be seen that the
accuracy of traditional methods is much higher than that of the genetic algorithm-based
methods.
Example 10.30
Consider again the revised Rastrigin function in Example 6.26
f(x1, x2) = 20 + (x1/30−1)2 + (x2/20−1)2 −10[cos(x1/30−1)π + cos(x2/20−1)π],
Run 100 times of the gaopt() function, and compare the time and successful rate in
ﬁnding the global optimal solutions, with the fmincon global() function.
Solution The objective for gaopt() can be written as
function [S,f]=c10mga5(S,options), x=S(1:2);
f=-20-(x(1)/30-1)^2-(x(2)/20-1)^2+10*(cos(pi*(x(1)/30-1))+...
cos(pi*(x(2)/20-1)));

522
Scientiﬁc Computing with MATLAB®
If the gaopt() function is called 100 times, 60.35 seconds are needed.
>> X=[]; range=[-100 100; -100 100];
tic, for i=1:100, x=gaopt(range,’c10mga5’); X=[X; x]; end, toc
Analyzing the results in matrix X, it is found that all the 100 calls reached the global
optimal point, although the results are not very accurate. With the code in Chapter 6, the
successful rate is not thus high, and the time elapsed is longer, about 150 seconds. It can be
seen that GAOT has obvious advantages in unconstrained optimization problems.
10.4.3
Solving constrained problems
It has been shown that the ordinary genetic algorithm-based methods can only be used
in solving unconstrained problems. For constrained optimization problems, it is sometimes
possible to convert it into unconstrained problems.
Example 10.31 Solve the following linear programming problem with genetic algorithm.
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎩
−2x1+x2+x3⩽9
−x1+x2⩾−4
4x1−2x2−3x3=−6
x1,2⩽0,x3⩾0
(x1 + 2x2 + 3x3).
Solution From the equality constraint, it is found that x3 = (6+4x1 −2x2)/3. Substituting
x3 into the original problem, problems with two variables can be reformulated. The following
M-function can be written to describe the objective function
function [sol,y]=c10mga4(sol,options)
x=sol(1:2); x=x(:); x(3)=(6+4*x(1)-2*x(2))/3;
y1=[-2 1 1]*x; y2=[-1 1 0]*x;
if (y1>9 | y2<-4 | x(3)<0), y=-100; else, y=-[1 2 3]*x; end
where x3 can be calculated ﬁrst from x1 and x2. The constraints are checked with x. For
the points where the constraints are not satisﬁed, the objective functions are set to −100
as penalties. The constrained optimization problem can now be solved using the genetic
algorithm. The intermediate results are listed in Table 10.12.
>> [a,b,c]=gaopt([-200 0; -200 0],’c10mga4’,[],[],[],’maxGenTerm’,1000)
The obtained results are x1 = −6.9983, x2 = −10.9967, and it is found from x3 =
(6 + 4x1 −2x2)/3 that x3 = 3.2583×10−5.
In fact, the linear programming function can be used to ﬁnd a more precise solution,
where xT = [−6.99999999999967, −10.99999999999935, 0].
>> f=[1 2 3]; A=[-2 1 1; 1 -1 0]; B=[9; 4]; Aeq=[4 -2 -3]; Beq=-6;
x=linprog(f,A,B,Aeq,Beq,[-inf;-inf;0],[0;0;inf]);
10.4.4
Solving optimization problems with Global Optimization Tool-
box
There are several global optimization problem solvers provided in the new Global
Optimization Toolbox. Speciﬁcally, particle swarm optimization (PSO) algorithm, simulated

Topics on Nontraditional Mathematical Branches
523
TABLE 10.12: Intermediate search results using genetic algorithm.
generations
x1
x2
f(x)
generations
x1
x2
f(x)
1
−186.2892
−196.6231
−100
596
−6.9076
−10.8243
28.5382
58
−1.0380
0
−0.8100
797
−6.9372
−10.9094
28.6862
63
−1.2029
0
0.0143
841
−6.9797
−10.9683
28.8983
114
−1.3579
−2.0200
0.7895
921
−6.9909
−10.9825
28.9547
141
−6.1889
−9.9597
24.9444
995
−6.9983
−10.9966
28.9914
230
−6.6159
−10.2321
27.0796
999
−6.9983
−10.9967
28.9915
481
−6.7766
−10.5617
27.8832
1000
−6.9983
−10.9967
28.9915
annealing algorithm, genetic algorithm, as well as pattern search algorithm are implemented,
with the latter two targeting at solving constrained optimization problems.
I. Particle swarm optimizations
Particle swarm optimization (PSO) is a class of evolutionary computing optimization
algorithm initially proposed in Reference [10]. The algorithm is motivated by the
phenomenon in nature where birds are seeking food. It is a useful algorithm in ﬁnding
global solutions to optimization problems.
Assume that within a certain area, there is a piece of food (global optimum point), and
there are a ﬂock of randomly distributed birds (or particles). Each particle has its personal
best value pi,b, and the swarm has its best value gb up to now. The position and speed of
each particle can be updated with the formula

vi(k + 1) = φ(k)vi(k) + α1γ1i(k)[pi,b −xi(k)] + α2γ2i(k)[gb −xi(k)]
xi(k + 1) = xi(k) + vi(k + 1),
(10-4-1)
where γ1i and γ2i are uniformly distributed random numbers in the interval [0, 1]. The
argument φ(k) is the momentum function, while α1 and α2 are acceleration constants.
In the new Global Optimization Toolbox for MATLAB R2014b, particleswarm()
function is provided to solve unconstrained optimization problems with particle swarm
optimization algorithms, with the syntaxes
[x,fm,key] = particleswarm(problem),
[x,fm,key] = particleswarm(f,n,xm,xM,opts)
while in the structured variable problem, the ﬁelds solver, objective, nvars are essential.
Example 10.32
Please solve the revised Rastrigin function problem with particle swarm
optimization approach.
Solution
The same particleswarm function can be called 100 times with the following
statements
>> f=@(x)20+(x(1)/30-1)^2+(x(2)/20-1)^2-...
10*(cos(pi*(x(1)/30-1))+cos(pi*(x(2)/20-1))); tic
X=[]; for i=1:100, [x g]=particleswarm(f,2); X=[X; x g]; end, toc

524
Scientiﬁc Computing with MATLAB®
The 100 runs of particleswarm() function takes only about 5.3 seconds, and the
successful rate for ﬁnding the global optimum point is 98%, and the accuracy is also much
higher than that of the ga() function.
Example 10.33
Solve the unconstrained optimization problem in Example 10.29 by the
PSO method.
Solution The objective function for the PSO solver can be in an anonymous function, and
the solutions can be found within 0.15 seconds, and the norm of the decision variable x is
5.3×10−5.
>> f=@(x)(x(1)+x(2))^2+5*(x(3)-x(4))^2+(x(2)-2*x(3))^2+10*(x(1)-x(4))^2;
tic, [x g]=particleswarm(f,4), norm(x), toc
Example 10.34
Consider again the constrained optimization problem in Example 10.31.
Find the solution with the particle swarm optimization method.
Solution Similar to the M-function for the genetic algorithm, another M-function can be
written for the objective function with the constraints. It should be noted that vectorized
format should be used.
function y=c10mpso4(x)
x3=(6+4*x(1)-2*x(2))/3; x=[x x3]’; y1=[-2 1 1]*x; y2=[-1 1 0]*x;
y=[1 2 3]*x; if y1>9|y2<-4|x3<0|x1>0|x2>0, y=100; end
With the above MATLAB statements, the accurate solution xT = [−7, −11, 0] can be
obtained.
>> x=particleswarm(@c10mpso4,2,[-50,-50],[0,0]); % call particle swarms
x=[x(1:2) (6+4*x(1)-2*x(2))/3]
% ﬁnd the 3rd argument
II. Genetic algorithm based solver
The ga() function provided in the Global Optimization Toolbox oﬀers an alternative
way in solving optimization problems using genetic algorithms. The function is quite similar
to other traditional optimization functions, and it can be used to solve constrained problems
as well. The syntaxes of the function are
[x,f,flag,out]= ga(fun,n,opts)
% unconstrained problem
[x,f,flag,out]= ga(fun,n,A,B,Aeq,Beq,xm,xM,CFun,intcon,opts)
where fun is a MATLAB description of the objective function, whose format is consistent
to the ones in the Optimization Toolbox. The argument n is the number of variables to
be optimized. The opts argument contains the control properties which can be set by the
function gaoptimset(), similar to optimset() function in Chapter 6. The commonly used
control properties are listed in Table 10.13. It seems that the function can be used in solving
mixed integer programming problems, with intcon arguments.
The search results are returned in the vector x. The other input and returned arguments
are the same as the functions in the Optimization Toolbox. In particular, if flag is larger
than 0, successful solutions to the problem are achieved. However, even if flag is positive,
the solution found is not necessarily a global optimum solution.

Topics on Nontraditional Mathematical Branches
525
TABLE 10.13: Commonly used control properties in GADS Toolbox.
property name
explanation to the options
Generations
maximum allowed generations, with a default 100
InitialPopulation
initial population matrix, the default population is created by random numbers
PopulationSize
the number of individuals in the population, with default 20
SelectionFcn
setting of the selective function, and the default @selectionstochunif,
and
other functions @selectionremainder, @selectionuniform, @selection roulette,
@selectiontournament
TolFun
similar to optimset properties, the termination condition for the objective function.
Also, TolX, TolCon can be set
Example 10.35 Let us consider the revised Rastrigin function studied earlier. Please run
ga() function 100 times and see the successful rate in ﬁnding the global optimal solutions.
Solution With default settings of the ga() function, the function is called 100 times with
the following loop structure
>> f=@(x)20+(x(1)/30-1)^2+(x(2)/20-1)^2-...
10*(cos(pi*(x(1)/30-1))+cos(pi*(x(2)/20-1)));
X=[]; tic, for i=1:100, [x,ff]=ga(f,2); X=[X; x ff]; end, toc
About 100 seconds are needed, and it is happy to see that all the solutions are global
optimum ones, although the accuracy is not very high.
Example 10.36
Consider again the linear programming problem studied in Example
10.31, please solve again with ga() function.
Solution Since ga() function can be used to solve constrained optimization problems, there
is no need to express the constraints as penalties in the objective function. The constrained
optimization problem can be solved directly with
>> f=@(x)[1 2 3]*x(:); A=[-2 1 1; 1 -1 0]; B=[9; 4];
Aeq=[4 -2 -3]; Beq=-6; xm=[-inf;-inf;0]; xM=[0;0;inf];
[x a k]=ga(f,3,A,B,Aeq,Beq,xm,xM)
and sometimes the global optimal solution can be found, while sometimes the solution cannot
be found, even though linear programming problem is a convex one.
Example 10.37
Solve again the nonlinear integer programming problem studied in
Example 6.45, with genetic algorithm.
Solution The mathematical form of the problem is given by
min
y s.t.
⎧
⎪
⎪
⎨
⎪
⎪
⎩
y2
1/16−6y1/4+y2/10−11⩽0
−y1y2/40+3y2/10+ey1/4−3−1⩽0
y2⩾30
2y2
1/16 + y2
2/100 −4y1 −y2,
with the nonlinear constraints given in ﬁle c6mdisp.m. With ga() function, the IntCon ﬁeld
should be assigned, and the problem can be solved with genetic algorithm, with the following
statements, with the result y = [16, 50]. It can be seen that the result is the same as the one
obtained in the original example.

526
Scientiﬁc Computing with MATLAB®
>> clear P; P.fitnessfcn=@(y)2*y(1)^2/16+y(2)^2/100-4*y(1)-y(2);
P.nonlcon=@c6mdisp; P.IntCon=[1,2]; P.lb=[-200; 30]; P.ub=[200; 200];
P.solver=’ga’; P.options=gaoptimset; P.nvars=2; [y,a key c]=ga(P)
Example 10.38
Consider the nonlinear programming problem studied in Example 6.36,
with its standard form given by
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
x3+9.625x1x4+16x2x4+16x2
4+12−4x1−x2−78x4=0
16x1x4+44−19x1−8x2−x3−24x4=0
−0.25x5−x1⩽−2.25
x1−0.25x5⩽2.25
−0.5x5−x2⩽−1.5
x2−0.5x5⩽1.5
−1.5x5−x3⩽−1.5
x3−1.5x5⩽1.5
x5.
Please solve the problem with ga() function.
Solution Since there are two equation constraints, for genetic algorithm solvers which does
not supporting constraints, the nonlinear equation solver should be embedded in the objective
function, and it can be seen that the solution process would be extremely complicated. With
fmincon global() function in Chapter 6, the global optimal solution can be found easily.
Now let us try the new ga() function, which allows the handling of constraints. The
following statements can be used to solve the problem. Unfortunately, the result obtained is
x = [1.7650, 2.1223, 0.1556, 1.5729, 2.3657], far away from the global optimal solution, with
x5 = 0.8175.
>> f=@(x)x(5); fnl=@c6exnls;
A=[-1 0 0 0 -0.25; 1 0 0 0 -0.25; 0 -1 0 0 -0.5;
0 1 0 0 -0.5; 0 0 -1 0 -1.5; 0 0 1 0 -1.5];
B=[-2.25; 2.25; -1.5; 1.5; -1.5; 1.5]; Aeq=[]; Beq=[];
xm=[]; xM=[]; x=ga(f,5,A,B,Aeq,Beq,xm,xM,fnl)
The time consuming function call was tested 30 times, which takes about 350 seconds,
and none of the results are near the global optimal point. While with the use of
fmincon global() function, each time the global optimal solution can be found.
Summarizing the above results, it can be seen that, to the opinion of the authors, the
ga() function is not recommended in real applications, unless it is signiﬁcantly improved
in later releases.
III. Other optimization problem solvers
Two other functions simulannealbnd() and patternsearch() are also provided in
the Global Optimization Toolbox. Function simulannealbnd() can be used to solve
unconstrained optimization problem with bounds on the decision variable, the syntaxes
of the function are
x = simulannealbnd(f,x0,xm,xM,opts), x = simulannealbnd(problem)
The pattern search based function patternsearch() can be used to solve nonlinear
programming problems, and its syntax is the same as fmincon() function. It should be
noted that the two functions all need an initially selected search point.

Topics on Nontraditional Mathematical Branches
527
Example 10.39
Solve again with the revised Rastrigin function problem with the two
solvers.
Solution It is found that in the two functions, initial search points should be speciﬁed. 100
runs of each function can be carried out with the following statements, and the initial search
point is generated randomly.
>> f=@(x)20+(x(1)/30-1)^2+(x(2)/20-1)^2-...
10*(cos(pi*(x(1)/30-1))+cos(pi*(x(2)/20-1)));
xm=[-100; -100]; xM=[100; 100]; tic, X=[]; Y=[];
for i=1:100, x0=-100+200*rand(2,1);
[x g]=simulannealbnd(f,x0,xm,xM); X=[X; x’ g];
end, toc
tic, for i=1:100, x0=-100+200*rand(2,1);
[x g]=patternsearch(f,x0); Y=[Y; x’ g];
end, toc
For the simulated annealing algorithm, the successful rate for ﬁnding the global optimal
point is 44%, and the time elapsed is 118 seconds. For the pattern search algorithm, the
successful rate is similar, and the time elapsed is only 4.5 seconds.
A L´evy ﬂight based PSO solver is developed by Zhuo Li [11], where vectorized form is
used in describing the objective function. With such a tool, 100 runs are executed, and all
the runs ﬁnd the global optimal solution, with rather high precision. The time elapsed for
the 100 runs is about 42 seconds.
>> f=@(x)20+(x(:,1)/30-1).^2+(x(:,2)/20-1).^2-...
10*(cos(pi*(x(:,1)/30-1))+cos(pi*(x(:,2)/20-1)));
tic, X=[]; for i=1:100
[g x]=levyPSO(f,xm’,xM’,100,600); X=[X; x g];
end, toc
Summarizing all the functions tried up to now for the same problem, comparisons are
given in Table 10.14.
TABLE 10.14: Comparisons of revised Rastrigin function solutions.
solver function
toolbox
successful rate
time
norm error
fminunc global()
author developed function
98%
153
3.1×10−12
ga()
Global Optimization Toolbox
100%
21
0.039
gaopt()
GAOT Toolbox (free)
100%
60
3.28×10−8
particleswarm()
Global Optimization Toolbox
97%
5.3
4.54×10−8
patternsearch()
Global Optimization Toolbox
29%
4.5
1.4×10−9
simulannealbnd()
Global Optimization Toolbox
44%
118
0.14
levyPSO()
Free L´evy-ﬂight based PSO Solver
100%
42
3.71×10−10
Example 10.40 Solve again the problem in Example 6.36, with pattern search algorithm.
Solution
The genetic algorithm function ga() was tried in Example 10.38, but failed.
The following statements can be used with the pattern search algorithm, and the solution

528
Scientiﬁc Computing with MATLAB®
found is x = [1.9085, 0.8169, 2.0208, 0.1250, 1.3662]. Clearly it is again not the global optimal
solution.
>> clear P; P.objective=@(x)x(5); P.nonlcon=@c6exnls;
P.Aineq=[-1 0 0 0 -0.25; 1 0 0 0 -0.25; 0 -1 0 0 -0.5;
0 1 0 0 -0.5; 0 0 -1 0 -1.5; 0 0 1 0 -1.5];
P.bineq=[-2.25; 2.25; -1.5; 1.5; -1.5; 1.5]; P.options=gaoptimset;
P.solver=’patternsearch’; P.X0=rand(5,1); patternsearch(P)
Running the patternsearch() function 100 times, the time elapsed is 355 seconds,
much slower than the other functions. The successful rate for ﬁnding the global solution is
extremely low, about 2%. Again this algorithm is not recommended to use in real applications
with constraints.
With fmincon global() function written in Chapter 6, the global optimal solution can
be found easily, within 2.54 seconds, the global solution is found
x = [2.4544, 1.9088, 2.7263, 1.3510, 0.8175].
>> P.solver=’fmincon’; P.options=optimset;
tic, fmincon_global(P,-100,100,5,10), toc %
10.4.5
Towards accurate global minimum solutions
In general, it can be concluded that the traditional optimization algorithms may ﬁnd
a solution with good accuracy, however, the global optimality cannot be ensured. For
oscillatory surfaces, local minima are inevitable. The evolutionary computing algorithms
can likely ﬁnd the global optimal solutions, since multiple initial points are used. However,
the accuracy of the solution may not be satisfactorily high. A combination of the two types of
optimization algorithms can be made, for instance, with the use of evolutionary algorithms,
a less accurate global solution can be found ﬁrst. This solution can then be used as an initial
search point for the traditional optimization algorithms in order to ﬁnd the accurate global
optimum solutions.
Example 10.41
Solve accurately the optimization problem
min
x, y s.t.
)
−1⩽x⩽3
−3⩽y⩽3
sin(3xy) + (x −0.1)(y −1) + x2 + y2.
Solution
The surface plot of the objective function can be obtained as shown in Figure
10.37. It can be seen that the surface is oscillatory, which makes the global optimization a
diﬃcult task.
>> [x,y]=meshgrid(-1:0.1:3,-3:0.1:3);
z=sin(3*x.*y+2)+(x-0.1).*(y-1)+x.^2+y.^2; surf(x,y,z);
To solve numerically the original problem, new variables x1 = x, x2 = y can be selected,
and the original problem can be rewritten as
min
x s.t.
⎧
⎨
⎩
−1⩽x1⩽3
−3⩽x2⩽3
sin(3x1x2) + (x1 −0.1)(x2 −1) + x2
1 + x2
2.

Topics on Nontraditional Mathematical Branches
529
−1
0
1
2
3
−3
−2
−1
0
1
2
3
−10
0
10
20
30
FIGURE 10.37: Surface of the objective function.
If the traditional nonlinear programming technique is used, using an anonymous function
to describe the objective function, the following statements can be used
>> f=@(x)sin(3*x(1)*x(2)+2)+(x(1)-0.1)*(x(2)-1)+x(1)^2+x(2)^2;
x0=rand(1,2); x=fmincon(f,x0,[],[],[],[],[-1;-3],[3;3]), f(x)
and the optimum point is xT = [0.9299, 0.6577], with the objective function value 0.3742.
Using GAOT, the objective function can be written as
function [sol,y]=c10mga6(sol,options)
x=sol(1:2); y=-sin(3*x(1)*x(2)+2)-(x(1)-0.1)*(x(2)-1)-x(1)^2-x(2)^2;
Within the selected search boundaries, the problem can be solved again to ﬁnd the
solution, which is x1 = 1.225588050491944, x2 = −0.918235615244950. The objective
function in this case is −0.795033762096730. It is clear that the solution by traditional
optimization method is a poor local minimum.
>> xmM=[-1 3; -3 3]; % set the boundaries
[a,b,c,d]=gaopt(xmM,’c10mga6’); x=a(1:2), f0=-a(3)
Using the results from applying the genetic algorithm as the initial search points,
the following statements can be used to ﬁnd a more accurate solution which is x1 =
1.225533324173843 and x2 = −0.918286942316160, and the objective function becomes
−0.795033772873523, which is slightly better than the genetic algorithm result.
>> ff=optimset; ff.TolX=1e-10; ff.TolFun=1e-20;
x=fmincon(f,a(1:2),[],[],[],[],[-1;-3],[3;3],[],ff), f(x)
10.5
Wavelet Transform and Its Applications in Data Processing
Fourier transform is a very important technique in signal processing. However, the
ordinary Fourier transform has certain limitations. For instance, it maps the time-domain
representation into the frequency-domain representation, where features in the original
domain may get lost. Therefore, for many types of signals, the processed results may not
be satisfactory. For stationary signals, Fourier transform may be very useful. However, for

530
Scientiﬁc Computing with MATLAB®
non-stationary and transient signals with sudden changes, the Fourier transform may not
be suitable, since the features of the sudden changes may be neglected. Thus, other types
of transforms, for instance, short-time Fourier transform should be used. Moreover, the
wavelet transform technique emerged in the 1980s is a very powerful tool used widely, in
particular, in signal and image processing.
10.5.1
Wavelet transform and waveforms of wavelet bases
A wavelet is a function with zero mean which can be translated and scaled to form a
family of functions. In this section, fundamental concepts of continuous and discrete wavelet
transforms are introduced. Some of the commonly used wavelet bases are introduced.
I. Continuous wavelet transform
The continuous wavelet transformation formula is given by
W ϕ
a,b[f(t)] =
1

|a|
 ∞
−∞
f(t)ϕa,b(t) dt = Wϕ(a, b),
(10-5-1)
where
ϕa,b(t) = ϕ
t −b
a

,
and
 ∞
−∞
ϕ(t) dt = 0,
(10-5-2)
and the function ϕ(t) is referred to as wavelet basis, and ϕa,b(t) is generated by translation
and scaling from the wavelet basis.
Example 10.42
Consider the “Mexican hat” wavelet basis given by ϕ(t) = 1 −t2
√
2π e
−t2
2 .
Draw the wavelet bases for diﬀerent values of a and b.
Solution From the given mathematical formula of the wavelet basis, the function ezplot()
can be used to draw the relevant curves. The translation and scaling operations can be carried
out with the subs() function. The curves for diﬀerent values of a and b can be obtained as
shown in Figures 10.38 (a) and (b).
>> syms t; f=(1-t^2)*exp(-t^2/2)/sqrt(2*pi);
subplot(121), ezplot(f,-4,4), hold on;
% wavelet basis plot
ezplot(subs(f,t,t-1),-4,4); ezplot(subs(f,t,t+1),-4,4) % translation
subplot(122), ezplot(f,-4,4), hold on;
ezplot(subs(f,t,t/2),-4,4); ezplot(subs(f,t,2*t),-4,4) % scaling
From the above example, it is seen that the parameter b can translate the wavelet basis
to the right or left while a expands or shrinks the waveform accordingly. If a < 1, the
waveform of the basis will be shrunken to form the new wavelet signal. Wavelet analysis is
performed by computing the coeﬃcients for diﬀerent combinations of a and b. The wavelet
signals multiplied by the corresponding coeﬃcients sum up to reconstruct the original signal.
Similar to other integral transform problems, the inverse wavelet transforms are also deﬁned:
f(t) =
1
Cϕ
 ∞
−∞
 ∞
−∞
Wϕ(a, b)ϕa,b(t) da db,
(10-5-3)
where
Cϕ =
 ∞
−∞
| ˆϕ(ω)|2
|ω|
dω.
(10-5-4)

Topics on Nontraditional Mathematical Branches
531
−4
−3
−2
−1
0
1
2
3
4
−0.2
−0.1
0
0.1
0.2
0.3
0.4
basis
b = −1
b = 1
-
b increase

−b increase
(a) translation for diﬀerent b’s when a = 1
−4
−3
−2
−1
0
1
2
3
4
−0.1
0
0.1
0.2
0.3
0.4
a = 1/2
a = 2
(b) scaling for diﬀerent a’s when b = 0
FIGURE 10.38: Waveforms of Mexican hat basis for diﬀerent a and b.
The coeﬃcients of continuous wavelet transforms can be evaluated with the cwt()
function, with the following syntaxes
Z = cwt(y,a,fun)
% wavelet coeﬃcients matrix Z
Z = cwt(y,a,fun,’plot’)
% absolute value plots
where the fun is the name of wavelet basis to be discussed more later. Here, the wavelet
basis name for Mexican hat wavelet basis is denoted by ’mexh’.
Example 10.43 Perform continuous wavelet transform for the function f(t) = sin t2, and
visualize its coeﬃcients.
Solution The data in the interval t ∈[0, 2π] can be generated directly with the following
statements, and the time domain function is shown in Figure 10.39 (a).
>> t=0:0.03:2*pi; y=sin(t.^2); plot(t,y)
Taking the option ’mexh’ wavelet basis as the template, the wavelet coeﬃcients Wϕ(a, b)
can be obtained as shown in Figure 10.39 (b).
>> a=1:32; Z=cwt(y,a,’mexh’,’plot’);
The following statements can be used to draw the surface plot of the wavelet coeﬃcients,
as shown in Figure 10.40.
>> surf(t,a,Z); shading flat; axis([0 2*pi,0,32,min(Z(:)) max(Z(:))])
II. Discrete wavelet transform
If the signal f(t) is expressed by a discrete sequence f(k), and the wavelet basis
ϕ(t) is selected, the translated and scaled wavelet function can be written as ϕa,b(t) =
√
2ϕ (2mt −n), whose discrete form can be written as ϕa,b(k) =
√
2ϕ (2mk −n). The
wavelet transform of the discrete signal is written as
W ϕ
n,m[f(k)] =
√
2

k
f(k)ϕ (2mk −n) dt = Wϕ(m, n),
(10-5-5)

532
Scientiﬁc Computing with MATLAB®
0
1
2
3
4
5
6
−1
−0.8
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
1
(a) time domain function f(t)
Absolute of Values of Ca,b for a =  1 2 3 4 5 ...
Time (or Space) b
Scales a
20
40
60
80
100
120
140
160
180
200
 1
 3
 5
 7
 9
11
13
15
17
19
21
23
25
27
29
31
(b) continuous wavelet transform coeﬃcients
FIGURE 10.39: Continuous wavelet transform.
0
1
2
3
4
5
6
0
10
20
30
−4
−2
0
2
4
FIGURE 10.40: Surface plot of continuous wavelet transform coeﬃcients.
and the inverse discrete wavelet transform is expressed as
f(k) =

m

n
Wn,m(k)ϕm,n(k).
(10-5-6)
The function dwt() provided in the Wavelet Toolbox can be used for discrete wavelet
transform, with the syntax [Ca,Cd] = dwt(x,fun), where x is the original data, fun is
the selected wavelet basis, which can be ’mexh’ or other functions to be discussed more
later. The returned argument Ca can be used to describe the approximated coeﬃcients of
the original function, while the argument Cd returns the detailed coeﬃcients. Normally the
argument Ca corresponds to the low- and mid-frequency information, while Cd corresponds
to the high-frequency information. The lengths of vectors Ca and Cd are half of the length
of the original vector x.
The vectors Ca and Cd can be used to perform inverse wavelet transform with the
function ˆx = idwt(Ca,Cd,fun) to restore the original vector ˆx.
Example 10.44 Generate a signal sequence corrupted by noises. Perform discrete wavelet
transform to the sequence. Perform also inverse wavelet transform to the sequence, and see
whether the original function can be restored.
Solution The white noise with a standard deviation of 0.1 is added to the original signal

Topics on Nontraditional Mathematical Branches
533
f(t) = sin t2 given in Example 10.43. The corrupted data are shown in Figure 10.41. It can
be seen that the noise level is quite visible. Using discrete wavelet transform, the waveforms
of approximated and detailed coeﬃcients are shown in the same window. It can be seen that
the resulted signal removes noises to some extent. For better ﬁltering results, more steps in
wavelet transform should be used.
>> x=0:0.002:2*pi; y=sin(x.^2); r=0.1*randn(size(x));
y1=y+r; subplot(211); plot(x,y1)
% draw the original corrupted signal
[cA,cD]=dwt(y1,’db4’);
% discrete wavelet transform
subplot(223), plot(cA); subplot(224), plot(cD)
0
1
2
3
4
5
6
−2
0
2
0
1
2
−2
0
2
0
1
2
3
(a) original function
(b) Ca coeﬃcients
(c) Cd coeﬃcients
FIGURE 10.41: Discrete wavelet transform of a given function.
The obtained Ca and Cd vectors can be used to perform the inverse discrete wavelet
transform. Comparing the transformed sequence and the original sequence, it can be seen
that the error is very small, with an error norm of 6.16×10−12.
>> y2=idwt(cA,cD,’db4’); norm(y1-y2)
III. Wavelet bases provided in the Wavelet Toolbox
A large amount of wavelet bases such as Haar basis, Daubechies basis, Mexican hat
basis, Bior basis, etc. can be generated and tested by wavemngr() function. The syntax
of the function is wavemngr(’read’,1). For instance, Haar wavelet basis is denoted as
’haar’. Daubechies families are denoted as ’db1’, ’db2’, etc. Bior families are ’bior1.3’,
’bior2.4’, etc. Mexican hat wavelet basis can be denoted as ’mexh’. The wavelet basis
function can be evaluated with the wavefun() function. The function can be called as
[ϕ,x] = wavefun(fun,n)
% Gaussian, Mexican hat wavelet bases
[φ,ϕ,x] = wavefun(fun,n) % Daubechies, Symlets orthogonal families
[φ1,ϕ1,φ2,ϕ2,x] = wavefun(fun,n)
% Bior basis
where n is the number of iterations computed, default is 8. The argument ϕ is the wavelet
basis, and φ is the wavelet derivatives. In Bior wavelet bases, the vectors φ1 and ϕ1 are used
for wavelet computation, while the vectors φ2 and ϕ2 are used for wavelet reconstruction.

534
Scientiﬁc Computing with MATLAB®
Example 10.45 Select Daubechies 6 wavelet basis (’db6’) to draw the wavelet waveforms
of diﬀerent iterations.
Solution
The iteration numbers 2, 4, 6, 8 can be used in the function call to draw the
wavelets as shown in Figure 10.42. It can be seen that when the iteration is 8, smooth
waveform can be achieved. Thus, normally, one should select the iteration number to 8.
>> [a,y,x]=wavefun(’db6’,2); subplot(141), plot(x,y)
[a,y,x]=wavefun(’db6’,4); subplot(142), plot(x,y)
[a,y,x]=wavefun(’db6’,6); subplot(143), plot(x,y)
[a,y,x]=wavefun(’db6’,8); subplot(144), plot(x,y)
0
5
10
−1
−0.5
0
0.5
1
n=2
2
4
6
8
10
−1
−0.5
0
0.5
1
n=4
0
5
10
−1
−0.5
0
0.5
1
n=6
2
4
6
8
10
−1
−0.5
0
0.5
1
n=8
FIGURE 10.42: The waveforms of Daubechies 6 for diﬀerent iterations.
Example 10.46
Show the waveforms of some commonly used wavelet bases.
Solution The following statements can be used to draw wavelets of some selected wavelet
bases, as shown in Figure 10.43, where ’db1’ is in fact the Haar basis. Daubechies wavelet
families are smooth when ’db6’ is used. For Symlets wavelet families, the function ’sym6’
is smooth.
>> subplot(5,4,1), [a,y,x]=wavefun(’db1’); plot(x,y), % other db bases
subplot(5,4,9), [a,y,x]=wavefun(’sym2’); plot(x,y),% other sym bases
subplot(5,4,13), [a,y,x]=wavefun(’coif2’); plot(x,y)
subplot(5,4,15), [y,x]=wavefun(’gaus2’); plot(x,y)
subplot(5,4,17), [a,y,b,c,x]=wavefun(’bior1.3’); plot(x,y)
10.5.2
Wavelet transform in signal processing problems
Similar to the Fourier transform technique, wavelet transform is also very useful in signal
processing and image processing problems. Some unique characteristics of wavelet transform
are not oﬀered in conventional frequency-domain analysis. Here, wavelet transform-based
signal decomposition and reconstruction in MATLAB are demonstrated by a de-noising
example in this section.
Wavelet transform can be used to perform signal decomposition, that is, to express a
given signal S by two parts, Ca1 and Cd1. The lengths of the two vectors are half the length
of S. The vector Ca1 preserves the low- and mid-frequency information or “approximate”
information, while Cd1 retains the high-frequency, or “detailed” information. From the
viewpoint of de-noising signal processing task, the latter high-frequency content can be
regarded as noise information. The vector Ca1 can further be decomposed with wavelet
transform into Ca2 and Cd2. Further decomposition leads to Ca3 and Cd3, and so on. The
decomposition process is shown in Figure 10.44 (a). The vectors Cai are referred to as the
approximate coeﬃcients, and Cdi is the detailed coeﬃcients.

Topics on Nontraditional Mathematical Branches
535
0.2
0.4
0.6
0.8
1
−1
−0.5
0
0.5
1
db1
0
1
2
3
−2
−1
0
1
2
db2
0
2
4
6
−2
−1
0
1
2
db3
0
2
4
6
8
−1
0
1
2
db4
0
5
10
−2
−1
0
1
2
db5
2
4
6
8
10
−1
−0.5
0
0.5
1
db6 
2
4
6
8
10
12
−1
−0.5
0
0.5
1
db7 
0
5
10
−1
−0.5
0
0.5
1
db8
0
1
2
3
−2
−1
0
1
2
sym2
2
4
6
−1
0
1
sym4
0
5
10
15
−1
0
1
2
sym6
0
5
10
15
−1
0
1
2
sym8
0
5
10
−0.5
0
0.5
1
1.5
coif2
0
10
20
30
−1
0
1
2
coif4
−5
0
5
−0.5
0
0.5
1
1.5
gaus2
−5
0
5
−1
0
1
2
gaus4
0
2
4
6
−2
−1
0
1
2
bior1.3 
0
5
10
−2
−1
0
1
2
bior1.5 
0
2
4
6
−5
0
5
10
bior2.2 
0
5
10
15
−2
0
2
4
bior2.6
FIGURE 10.43: Waveforms of commonly used wavelet bases.
The function wavedec() provided in Wavelet Toolbox can be used in one-dimensional
wavelet decomposition, with [C,L] = wavedec(x,n,fun), where x is the original signal,
n is the level of decomposition. fun is the name of the wavelet basis, for instance ’db6’.
After the decomposition, the two vectors C and L are returned, as shown in Figure 10.44
(b). The original vector C is decomposed into a vector whose length is the same as that of
x. The short sub-vectors are joined together, and the lengths of the sub-vectors are indexed
in the vector L.
The approximate coeﬃcients Ca and detailed coeﬃcients Cd after decomposition can
be extracted from the vectors C and L, with the functions appcoef() and detcoef(),
respectively, by the syntaxes
Cai = appcoef(C,L,fun,n);
% extract approximate coeﬃcients
Cdi = detcoef(C,L,i);
% extract detailed coeﬃcients
where n is the level of extraction.
Some of the noises can be ﬁltered out from the approximate coeﬃcients and detailed
coeﬃcients, by reconstructing the signal with the function wrcoef(), whose syntax

536
Scientiﬁc Computing with MATLAB®
S
Ca1
Ca2
Ca3
Cd2
Cd3
Cd1
?
?
?
?
?
?
(a) wavelet decomposition
Ca3
Cd2
L(1)
L(2)
Cd3
Cd1
L(3)
L(4)
L(5)
9
q
}
>
K

O


M
C vector
(b) storage format
FIGURE 10.44: Illustrations of wavelet decomposition.
is ˆx = wrcoef(type,C,L,fun,n), where type can be set to ’a’ or ’d’, representing
approximate coeﬃcients and detailed coeﬃcients, respectively. If ’a’ is selected, the
reconstructed signal may ﬁlter out certain high-frequency noises.
Example 10.47
For the data given in Example 10.44, three-level wavelet decomposition
can be performed. Compare the de-noise eﬀects for diﬀerent wavelet bases.
Solution The noisy signal in Example 10.44 shown in Figure 10.41 (a) can still be used
for de-noising tests.
>> x=0:0.002:2*pi; y=sin(x.^2); r=0.1*randn(size(x)); y1=y+r; plot(x,y1)
For three-level wavelet decomposition, the following statements can be used to get the
waveforms of the sub-vectors as shown in Figure 10.45, where the widths of the axes have
been rearranged manually. It can be seen that part of the noise is ﬁltered out in each
decomposition level. Thus, the ﬁnal Ca3 contains less noise information.
>> [C,L]=wavedec(y1,3,’db6’); cA3=C(1:L(1)); subplot(141), plot(cA3)
dA3=C(L(1)+1:sum(L([1 2]))); subplot(142), plot(dA3)
dA2=C(sum(L(1:2))+1:sum(L(1:3))); subplot(143), plot(dA2)
dA1=C(sum(L(1:3))+1:sum(L(1:4))); subplot(144), plot(dA1)
0
200
400
−5
0
5
0
200
400
−0.5
0
0.5
0
200
400
600
−0.5
0
0.5
0
500
1000
1500
−0.5
0
0.5
FIGURE 10.45: Wavelet decomposition illustrations.
The wavelet basis ’db6’ can be used, and the approximate coeﬃcients can be obtained as
shown in Figure 10.46 (a). If ’db2’ is used instead, the de-noising result shown in Figure
10.46 (b) can be obtained. The two wavelet bases do not have signiﬁcant diﬀerences in
de-noising eﬀect for this example.
>> A3=wrcoef(’a’,C,L,’db6’,3); subplot(121), plot(A3); subplot(122)
[C,L]=wavedec(y1,3,’db2’); A3=wrcoef(’a’,C,L,’db2’,3); plot(A3)
Two commonly used wavelet bases, ’bior2.6’ and ’coif4’ can also be tried for the
de-noising purposes, and the results are still the same as the one shown in Figure 10.46 (a).
It is seen that for this example, there is no signiﬁcant diﬀerence in the de-noising eﬀect.

Topics on Nontraditional Mathematical Branches
537
0
500
1000
1500
2000
2500
3000
−1.5
−1
−0.5
0
0.5
1
1.5
(a) ’db6’ basis
0
500
1000
1500
2000
2500
3000
−1.5
−1
−0.5
0
0.5
1
1.5
(b) ’db2’ basis
FIGURE 10.46: De-noising eﬀects under diﬀerent wavelet bases.
>> [C,L]=wavedec(y1,3,’bior2.6’); A3=wrcoef(’a’,C,L,’bior2.6’,3);
[C,L]=wavedec(y1,3,’coif4’); A3a=wrcoef(’a’,C,L,’coif4’,3);
subplot(121), plot(A3), subplot(122),
plot(A3a)
Example 10.48
Reconsider the digital ﬁltering problem in Example 8.48. Filter the
corrupted signal using wavelet method and compare the results.
Solution
The ﬁlter in Example 8.48 can be used again for the noisy signal. The 4-level
wavelet ﬁlter with ’db6’ basis is used for the same signal. The de-noising eﬀects are
compared in Figure 10.47. It can be seen that there exists delay in the ﬁltering result in
Chapter 8 while the wavelet-based ﬁltering contributes no delay and the de-noising eﬀect is
much better.
>> b=1.2296e-6*conv([1 4 6 4 1],[1 3 3 1]); a=conv([1,-0.7265],...
conv([1,-1.488,0.5644],conv([1,-1.595,0.6769],[1,-1.78,0.8713])));
x=0:0.002:2; y=exp(-x).*sin(5*x); r=0.05*randn(size(x)); y1=y+r;
y2=filter(b,a,y1);
% ﬁlter used in Example 8.48
[C,L]=wavedec(y1,4,’db6’); A4=wrcoef(’a’,C,L,’db6’,4);
plot(x,y,x,y2,x,A4)
% comparisons of the two ﬁlters
0
0.5
1
1.5
2
−0.6
−0.4
−0.2
0
0.2
0.4
0.6
0.8
FIGURE 10.47: De-noising eﬀect comparisons for given signal.

538
Scientiﬁc Computing with MATLAB®
10.5.3
Graphical user interface in wavelets
An easy-to-use graphical user interface is provided in the Wavelet Toolbox, which can
be used for solving one-dimensional and two-dimensional wavelet transform problems. The
command wavemenu is used to start the interface, and the window shown in Figure 10.48
appears. If a one-dimensional wavelet transform problem is to be solved, the Wavelet 1-D
button should be clicked. The interface guides the user to import data ﬁle, select wavelet
basis and perform wavelet analysis for the data. Details of using the interface will not be
given in this book. The interested readers are suggested to consult the users’ manual of
Wavelet Toolbox and play with the demos oﬀered in the toolbox.
FIGURE 10.48: Graphical user interface for wavelet analysis.
10.6
Fractional-order Calculus
In Chapter 3, the calculus problems have been discussed, and the related materials are
also shown in other chapters. It is quite interesting to note that before the invention of
calculus, only algebra, geometry, and statics could be subjects of study. With calculus,
lots of new subjects emerge such as dynamics, modeling, etc., which enable us to better
characterize the world around us. It is known that the nth order derivative of a function

Topics on Nontraditional Mathematical Branches
539
f(t) can be mathematically described by dny/ dxn, a notation invented by Leibniz not
Newton who suggested dot notation. With Leibniz’s notation, one may ask “What does
n = 1/2 mean to the notation?” Actually, this is the question asked in a letter by the French
mathematician Guillaume Fran¸cois Antoine L’Hˆopital to one of the inventors of calculus,
German mathematician Gottfried Wilhelm Leibniz more than 300 years ago. In answering
the letter, Leibniz said, “It will lead to a paradox, from which one day useful consequences
will be drawn.” This marks the beginning of fractional-order calculus. However, earlier
research concentrated on theoretical math issues. It is now being widely used in many
areas. For instance, in the discipline of automatic control, fractional-order controller is
a promising new topic. In this section, an easy-to-follow introduction to fractional-order
calculus will be presented with how to get started using MATLAB in mind. Our treatment
in this section, although not very mathematically rigorous, is practically useful since we
presented a comprehensive introduction to numerical solutions to fractional-order ﬁltering
and fractional-order ordinary diﬀerential equations. Furthermore, from a programming point
of view, the design and application of MATLAB classes and objects dedicated for fractional-
order calculus demonstrated thoroughly in this section are of great value.
10.6.1
Deﬁnitions of fractional-order calculus
Various deﬁnitions appeared in the development and studies of fractional-order calculus.
Some of the deﬁnitions are directly extended from the conventional integer-order calculus.
The commonly used deﬁnitions are summarized as follows:
I. Fractional-order Cauchy integral formula
The formula is extended from integer-order calculus
Dαf(t) = Γ(α + 1)
j2π

C
f(τ)
(τ −t)α+1 dτ,
(10-6-1)
where C is the closed-path that encircles the poles of the function f(t).
The integrals and derivatives for sinusoidal and cosine functions can be expressed by
dk
dtk

sin at

= ak sin

at + kπ
2

, dk
dtk

cos at

= ak cos

at + kπ
2

.
(10-6-2)
It can also be shown with Cauchy’s formula that if k is not an integer, the above formula
is still valid.
II. Gr¨unwald–Letnikov deﬁnition
The fractional-order diﬀerentiation and integral can be deﬁned in a uniﬁed way such
that
t0Dα
t f(t) = lim
h→0
1
hα
[(t−t0)/h]

j=0
(−1)j
α
j

f(t −jh),
(10-6-3)
where
α
j

are the binomial coeﬃcients; the subscripts to the left and right of D are
the lower- and upper-bounds in the integral. The value α can be positive or negative,
corresponding to diﬀerentiation and integration, respectively.

540
Scientiﬁc Computing with MATLAB®
III. Riemann–Liouville deﬁnition
The fractional-order integral is deﬁned as
t0D−α
t
f(t) =
1
Γ(α)
 t
t0
(t −τ)α−1f(τ) dτ,
(10-6-4)
where 0 < α < 1, and t0 is the initial time. Let t0 = 0, the notation of integral can be
simpliﬁed to D−α
t
f(t). The Riemann–Liouville deﬁnition is a widely used deﬁnition for
fractional-order diﬀerentiation and integral [12]. Similarly, fractional-order diﬀerentiation is
deﬁned as
t0Dβ
t f(t) = dn
dtn

t0D−(n−β)
t
f(t)

=
1
Γ(n −β)
dn
dtn
 t
t0
f(τ)
(t −τ)β−n+1 dτ

,
(10-6-5)
where n −1 < β ⩽n.
IV. Caputo deﬁnition
The Caputo fractional-order diﬀerentiation is deﬁned by
t0Dα
t f(t) =
1
Γ(1 −α)
 t
t0
f (m+1)(τ)
(t −τ)α dτ,
(10-6-6)
where α = m + γ, m is an integer and 0 < γ ⩽1. Similarly, by Caputo’s deﬁnition, the
integral is described by
t0D−γ
t
f(t) =
1
Γ(γ)
 t
t0
f(τ)
(t −τ)1−γ dτ,
γ > 0.
(10-6-7)
10.6.2
Properties and relationship of various fractional-order
diﬀerentiation deﬁnitions
I. Properties of fractional-order derivatives
The properties of fractional-order calculus are summarized below [14]:
(i) The fractional-order diﬀerentiation t0Dα
t f(t) of an analytic function f(t) with respect
to t is also analytic.
(ii) If α = n, the fractional-order derivative is identical to integer-order derivative, and
also t0D0
t f(t) = f(t).
(iii) The fractional-order diﬀerentiation is linear, i.e., for any constants c, d
t0Dα
t [cf(t) + dg(t)] = c t0Dα
t f(t) + d t0Dα
t g(t).
(10-6-8)
(iv) Fractional-order diﬀerentiation operators satisfy commutative law, i.e.,
t0Dα
t

t0Dβ
t f(t)

= t0Dβ
t

t0Dα
t f(t)

= t0Dα+β
t
f(t).
(10-6-9)
II. Laplace transforms of fractional-order derivaatives
The Laplace transform of a fractional-order integral can be expressed by
L

t0D−γ
t
f(t)

= s−γL [f(t)].
(10-6-10)

Topics on Nontraditional Mathematical Branches
541
Under Riemann–Liouville deﬁnition, Laplace transform of the diﬀerentiation of a
function can be written as
L

RL
t0 Dα
t f(t)

= sαL [f(t)] −
n−1

k=0
sk %
t0Dα−k−1
t
f(t)
&
t=t0 .
(10-6-11)
The Laplace transform of integrals under Caputo deﬁnition is identical to those under
Riemann–Louiville deﬁnition, and the Laplace transform to diﬀerentiations under Caputo
deﬁnition satisﬁes
L
%C
t0Dγ
t f(t)
&
= sγF(s) −
n−1

k=0
sγ−k−1f (k)(t0).
(10-6-12)
Especially, when the initial values of f(t) and their integer-order derivatives are all
zero, L [C
t0Dα
t f(t)] = sαL [f(t)]. It is also seen that Caputo deﬁnition is more suitable in
describing a class of fractional-order diﬀerential equations with nonzero initial conditions.
III. Relationships among diﬀerent deﬁnitions
It can be shown that for great varieties of functions, the Gr¨unwald–Letnikov and
Riemann–Liouville deﬁnitions are equivalent [13]. The major diﬀerence between Caputo and
Riemann–Liouville deﬁnitions are the diﬀerentiations to a constant, with the former, the
diﬀerentiation is bounded, while in the later, it is unbounded.
If function y(t) has nonzero initial conditions, and the order α ∈(0, 1), it can be found
by comparing the Caputo and Riemann–Liouville deﬁnitions that
C
t0Dα
t y(t) = RL
t0 Dα
t (y(t) −y(t0)),
(10-6-13)
where, the αth order derivative of constant y(t0) is
RL
t0 Dα
t y(t0) = y(t0)(t −t0)−α/Γ(1 −α),
(10-6-14)
and the relationship between the two deﬁnitions can be derived as
C
t0Dα
t y(t) = RL
t0 Dα
t y(t) −y(t0)(t −t0)−α
Γ(1 −α)
.
(10-6-15)
More generally, if the order α > 1, denote m = ⌈α⌉, then
C
t0Dα
t y(t) = RL
t0 Dα
t y(t) −
m−1

k=0
y(k)(t0)
Γ(k −α + 1)(t −t0)k−α,
(10-6-16)
and the 0 ⩽α ⩽1 case is only a special one in the formula.
If α < 0, it has been pointed out earlier that, Riemann–Liouville and Caputo deﬁnitions
are identical.
10.6.3
Evaluating fractional-order diﬀerentiation
I. Computation via Gr¨unwald–Letnikov deﬁnitions
The most straightforward way in evaluating the fractional-order derivatives numerically
is to use the Gr¨unwald–Letnikov deﬁnition which is given again
t0Dα
t f(t) = lim
h→0
1
hα
[(t−t0)/h]

j=0
(−1)j

α
j

f(t −jh) ≈1
hα
[(t−t0)/h]

j=0
w(α)
j
f(t −jh),
(10-6-17)

542
Scientiﬁc Computing with MATLAB®
where w(α)
j
= (−1)j
α
j

are the coeﬃcients of binomial expression (1 −z)α, and can be
evaluated recursively from
w(α)
0
= 1,
w(α)
j
=

1 −α + 1
j

w(α)
j−1, j = 1, 2, · · · .
(10-6-18)
If the step-size h is small enough, (10-6-17) can be used directly to calculate
approximately the values of the fractional-order derivatives, with an accuracy of o(h) [13].
The following MATLAB function can be written, with y1 = glfdiff(y,t,γ), where y, t
describe the original function using evenly distributed samples. The returned vector y1 is
the γth order derivative.
function dy=glfdiff(y,t,gam)
h=t(2)-t(1); y=y(:); t=t(:);
w=1; for j=2:length(t), w(j)=w(j-1)*(1-(gam+1)/(j-1)); end
for i=1:length(t), dy(i)=w(1:i)*[y(i:-1:1)]/h^gam; end
Example 10.49 It is well known in the traditional calculus framework that, the derivatives
of constants are zeros, and the ﬁrst-order integral is straight lines. Please see what happens
with fractional-order diﬀerentiation and integrals.
Solution A vector y of constants can be generated ﬁrst. Function glfdiff() can be used
to evaluate fractional-order derivatives and integrals, as shown in Figure 10.49. It can be
seen that the behaviors of fractional-order calculus are diﬀerent from the traditional ones.
>> t=0:0.01:1.5; gam=[-1 -0.5 0.3 0.5 0.7]; y=ones(size(t)); dy=[];
for a=gam, dy=[dy; glfdiff(y,t,a)]; end, plot(t,dy)
0
0.5
1
1.5
0
0.5
1
1.5
2
2.5
3
α=−0.5
α = −1
α=0.3
α=0.5
α=0.7
FIGURE 10.49: Fractional-order derivatives and integrals of a constant.
Example 10.50
For function f(t) = e−t sin(3t + 1), t ∈(0, π), study the behaviors of the
fractional-order derivatives.
Solution
Select the step-sizes, T = 0.01 and 0.001, the 0.5th order derivative can be
evaluated as shown in Figure 10.50 (a). It can be seen that, when t is close to 0, there are
some diﬀerences. For larger t, the two solutions are very close. Normally speaking, selecting
T = 0.01 may give accurate results.

Topics on Nontraditional Mathematical Branches
543
>> t=0:0.001:pi; y=exp(-t).*sin(3*t+1); dy=glfdiff(y,t,0.5); plot(t,dy);
t=0:0.01:pi; y=exp(-t).*sin(3*t+1); dy=glfdiff(y,t,0.5); line(t,dy)
For diﬀerent selections of γ, the 3D surface representation of the fractional-order
derivative can be obtained as shown in Figure 10.50 (b).
>> Z=[]; t=0:0.01:pi; y=exp(-t).*sin(3*t+1); % describe the original function
for gam=0:0.1:1, Z=[Z; glfdiff(y,t,gam)]; end % compute FO derivatives
surf(t,0:0.1:1,Z); axis([0,pi,0,1,-1.2,6]) % draw the surface
0
0.5
1
1.5
2
2.5
3
−2
0
2
4
6
8
10
12
14
(a) comparisons under diﬀerent step-sizes
0
1
2
3
0
0.5
1
−1
0
1
2
3
4
5
6
γ
t
(b) fractional-order derivative surface
FIGURE 10.50: Fractional-order diﬀerentiation of the function.
Example 10.51
Consider a sinusoidal function f(t) = sin(3t + 1). Find its 0.75th order
derivative with Gr¨unwald–Letnikov deﬁnition and Cauchy’s formula, and compare the
results.
Solution
According to Cauchy’s formula and (10-6-2), the 0.75th order derivative
can be obtained as 0D0.75
t
f(t) = 30.75 sin (3t + 1 + 0.75π/2). With the Gr¨unwald–Letnikov
deﬁnition, the derivative can be evaluated with glfdiff() function. The two derivative
curves are compared in Figure 10.51 (a).
0
0.5
1
1.5
2
2.5
3
3.5
−4
−2
0
2
4
6
8
Gr¨unwald–Letnikov deﬁnition
Cauchy’s
(a) comparisons of diﬀerent deﬁnitions
0
1
2
3
0
0.5
1
−3
−2
−1
0
1
2
3
γ
t
(b) 3D surface by Cauchy’s formula
FIGURE 10.51: Comparisons and 3D surfaces.

544
Scientiﬁc Computing with MATLAB®
>> t=0:0.01:pi; y=sin(3*t+1); y1=3^0.75*sin(3*t+1+0.75*pi/2);
y2=glfdiff(y,t,0.75); plot(t,y1,t,y2,’--’)
It can be seen that when t is small, there exists signiﬁcant diﬀerence between the two
deﬁnitions. This is because, in these two deﬁnitions, the assumptions of the function at t < 0
are considered diﬀerently. In Cauchy’s formula, it is assumed that the function can also be
described by f(t) = sin(3t + 1) when t < 0, however, for Gr¨unwald–Letnikov deﬁnition, it
is assumed that f(t) = 0 for t < 0. Therefore, in the later case, there is a jump at t = 0,
which causes the diﬀerence.
Again, the 3D surface can also be found for diﬀerent orders γ, with the following
statements, as shown in Figure 10.51 (b). It can be seen that the fractional-order derivatives
provide information between the original function and its ﬁrst-order derivative.
>> gam=[0:0.1:1]; Y=[]; t=0:0.01:pi; y=sin(3*t+1);
for a=gam, Y=[Y; 3^a*sin(3*t+1+a*pi/2)]; end, surf(t,gam,Y)
II. Numerical computation of Caputo derivatives
It was pointed out that the fractional-order integrals under Caputo and Gr¨unwald–
Letnikov deﬁnitions are equivalent, function glfdiff() can be used directly in evaluating
integrals. For fractional-order derivatives, if α > 0, the fractional-order derivative under
Caputo deﬁnition can be evaluated directly with (10-6-16), and the MATLAB implemen-
tation is given as
function dy=caputo(y,t,gam,vec,L)
t0=t(1); dy=glfdiff(y,t,gam); if nargin<=4, L=10; end
if gam>0, m=ceil(gam); if gam<=1,vec=y(1); end
for k=0:m-1, dy=dy-vec(k+1)*(t-t0).^(k-gam)./gamma(k+1-gam); end
yy1=interp1(t(L+1:end),dy(L+1:end),t(1:L),’spline’); dy(1:L)=yy1;
end
The syntax of the function is y1 = caputo(y,t,α,y0,L), with, α ⩽0, the Gr¨unwald–
Letnikov integral is returned. If α < 1, the initial vector y(t0) is extracted directly with
y, while if α > 1, the initial vector y0 should be supplied for function y(t), with y0 =
[y(t0), y′(t0), · · · , y(m−1)(t0)], and m = ⌈α⌉. In practical computations, there might exist
large errors in the ﬁrst few terms of the Caputo derivatives, therefore, interpolation can be
performed for the ﬁrst L terms. The default value of L is 10, and when the order increases,
the value of L should also be increased.
Example 10.52 Consider again the sinusoidal function in Example 10.51, f(t) = sin(3t+
1). Please ﬁnd the 0.3th, 1.3th and 2.3th order derivatives.
Solution It can be seen that the value of the function at t = 0 is sin 1, thus, the diﬀerence
of the two deﬁnitions is d(t) = t−0.3 sin 1/Γ(0.7). The two curves under Gr¨unwald–Letnikov
and Caputo deﬁnitions can be obtained as shown in Figure 10.52 (a). It can be seen that
with nonzero initial conditions, the diﬀerence of the two deﬁnitions are rather large.
>> t=0:0.01:pi; y=sin(3*t+1); d=t.^(-0.3)*sin(1)/gamma(0.7);
y1=glfdiff(y,t,0.3); y2=caputo(y,t,0.3,0); plot(t,y1,t,y2,’--’,t,d,’:’)
Since the curve of C
0 D2.3
t
y(t) is expected, the initial values y′(0) and y′′(0) are required.
These values can be obtained symbolically and converted to double-precision ones. The 1.3th
and 2.3th order derivatives can be obtained. To have good approximations in the ﬁrst few
terms, interpolation is performed, and the results are shown in Figure 10.52 (b).

Topics on Nontraditional Mathematical Branches
545
0
0.5
1
1.5
2
2.5
3
−3
−2
−1
0
1
2
3
compensation
Gr¨unwald–Letnikov deﬁnition
Caputo deﬁnition
(a) 0.3th order derivative
0
0.5
1
1.5
2
2.5
3
−10
−5
0
5
0
0.5
1
1.5
2
2.5
3
−10
0
10
20
C
0 D1.3
t
y(t)
C
0 D2.3
t
y(t)
(b) 1.3th and 2.3th order derivatives
FIGURE 10.52: Fractional-order derivatives under diﬀerent orders.
>> syms t; y=sin(3*t+1); y00=sin(1); y10=double(subs(diff(y,t),t,0));
y20=double(subs(diff(y,t,2),t,0)); t=0:0.01:pi; y=sin(3*t+1);
y1=caputo(y,t,1.3,[y00 y10],10); y2=caputo(y,t,2.3,[y00,y10,y20],30);
plotyy(t,y1,t,y2)
III. Using ﬁltering algorithm to compute the fractional-order calculus
In the fractional-order derivative evaluation method discussed above, the function f(t) or
its samples are known. In many other applications, the signal f(t) is generated dynamically.
In this case, a ﬁlter can be designed to evaluate fractional-order derivative of f(t) in real-
time.
For the fractional-order derivative, its Laplace representation is sγ, which exhibits
straight lines in both Bode magnitude and phase plots. Thus, it is not possible to ﬁnd
a ﬁnite order ﬁlter to ﬁt the straight lines for all the frequencies. However, it is useful to ﬁt
the frequency responses over a frequency range of interest.
Diﬀerent continuous ﬁlters have been studied in Reference [14], among which the
Oustaloup’s ﬁlter [15] has certain advantages. For the selected frequency range of interest,
(ωb, ωh), the continuous ﬁlter can be written as
Gf(s) = K
N

k=1
s + ω′
k
s + ωk
,
(10-6-19)
where, the poles, zeros and gain can be evaluated from
ω′
k = ωbω(2k−1−γ)/N
u
, ωk = ωbω(2k−1+γ)/N
u
, K = ωγ
h,
(10-6-20)
with ωu =

ωh/ωb. Based on the above algorithm, the following function can be written
function G=ousta_fod(gam,N,wb,wh)
k=1:N; wu=sqrt(wh/wb);
wkp=wb*wu.^((2*k-1-gam)/N); wk=wb*wu.^((2*k-1+gam)/N);
G=zpk(-wkp,-wk,wh^gam); G=tf(G);
The continuous ﬁlter can be designed as G = ousta fod(γ,N,ωb,ωh), where γ is the
order of derivative, and N is the order of the ﬁlter.
Example 10.53
Select the frequency range of interest as ωb = 0.01, ωh = 1000rad/sec,

546
Scientiﬁc Computing with MATLAB®
and design the continuous-time approximate fractional-order ﬁlters. For the function f(t) =
e−t sin(3t + 1), calculate the 0.5th order derivative and verify the obtained results.
Solution The 5th order ﬁlter can be designed
>> G5=ousta_fod(0.5,5,0.01,1000), bode(G5)
and the ﬁlter designed is
G(s) = 31.62s5 + 6248s4 + 1.122×105s3 + 1.996×105s2 + 3.514×104s + 562.3
s5 + 624.8s4 + 3.549×104s3 + 1.996×105s2 + 1.111×105s + 5623
The Bode diagrams of the above approximate ﬁlter are shown in Figure 10.53 (a),
superimposed by the theoretical straight lines. The ﬁlter output is shown in Figure 10.53
(b). Moreover, the 0.5th order derivative obtained through Gr¨unwald–Letnikov deﬁnition
can be obtained using the following MATLAB scripts and the obtained derivative curve is
also shown in Figure 10.53 (b). Clearly, the ﬁlter output of this example is fairly accurate.
−20
0
20
40
Magnitude (dB)
10
−3
10
−2
10
−1
10
0
10
1
10
2
10
3
10
4
0
30
60
Phase (deg)
Bode Diagram
Frequency  (rad/s)
ωb
ωh
(a) Bode diagram with Oustaloup ﬁlter
0
0.5
1
1.5
2
2.5
3
−1
−0.5
0
0.5
1
1.5
2
(b) derivative curves
FIGURE 10.53: Comparisons of approximate fractional-order ﬁlters.
>> t=0:0.001:pi; y=exp(-t).*sin(3*t+1);
y1=lsim(G,y,t); y2=glfdiff(y,t,0.5); plot(t,y1,t,y2)
Of course, if one is not satisﬁed with the ﬁlters, the frequency range of interest and the
order of the ﬁlter can both be increased. The ﬁtting result in the frequency interval (10−4, 104)
and ﬁtting results are shown in Figure 10.54. It can be seen that the order N = 5 is not
suitable, higher order should be tried.
>> G=ousta_fod(0.5,5,1e-4,1e4); G1=ousta_fod(0.5,7,1e-4,1e4);
G2=ousta_fod(0.5,9,1e-4,1e4); G3=ousta_fod(0.5,11,1e-4,1e4);
bode(G,’-’,G1,’--’,G2,’:’,G3,’-.’)
IV. A modiﬁed Oustaloup ﬁlter
In practical applications, it is frequently found that the ﬁlter from using the ousta fod()
function cannot exactly ﬁt the whole expected frequency range of interest. A new improved
ﬁlter for a fractional-order derivative in the frequency range of interest [ωb, ωh], which is
shown to perform better, is introduced in this subsection. The modiﬁed ﬁlter is [16]
sγ ≈
dωh
b
γ 
ds2 + bωhs
d(1 −γ)s2 + bωhs + dγ

N

k=−N
s + ω′
k
s + ωk
,
(10-6-21)

Topics on Nontraditional Mathematical Branches
547
−50
0
50
Magnitude (dB)
10
−5
10
0
10
5
0
30
60
Phase (deg)
Bode Diagram
Frequency  (rad/s)
FIGURE 10.54: Fitting results under diﬀerent orders in ﬁlters.
where
ω′
k = (dωb/b)(γ−2k)/(2N+1) ,
ωk = (bωh/d)(γ+2k)/(2N+1) .
(10-6-22)
Through a number of experimentation conﬁrmation and theoretic analyses, the modiﬁed
ﬁlter achieves good approximation when b = 10 and d = 9. With the above algorithm, a
MATLAB function new fod() is written
function G=new_fod(r,N,wb,wh,b,d)
if nargin==4, b=10; d=9; end
mu=wh/wb; k=-N:N; w_kp=(mu).^((k+N+0.5-0.5*r)/(2*N+1))*wb;
w_k=(mu).^((k+N+0.5+0.5*r)/(2*N+1))*wb; K=(d*wh/b)^r;
G=zpk(-w_kp’,-w_k’,K)*tf([d,b*wh,0],[d*(1-r),b*wh,d*r]);
with the syntax Gf = new fod(γ,N,ωb,ωh,b,d), and due to the limitations of the
algorithm, ωhωb = 1 is required.
Example 10.54
Consider again the problem in Example 10.53, and select ωb = 0.001,
ωh = 1000. Please observe the behaviors of the new ﬁlter, and the fractional-order
derivatives.
Solution With the two ﬁlters designed, Bode diagrams can be obtained as shown in Figure
10.55 (a). The fractional-order derivative curve can be obtained as shown in Figure 10.55
(b). It can be seen from the requency response ﬁtting that, the modiﬁed ﬁlter is better than
the Oustaloup ﬁlter.
>> G1=ousta_fod(0.5,2,0.001,1000); G2=new_fod(0.5,2,0.001,1000);
subplot(121), bode(G1,’-’,G2,’--’), t=0:0.001:pi;
y=exp(-t).*sin(3*t+1); y1=lsim(G1,y,t); y2=lsim(G2,y,t);
y0=glfdiff(y,t,0.5); subplot(122), plot(t,y1,t,y2,t,y0)
10.6.4
Solving fractional-order diﬀerential equations
A class of linear time-invariant (LTI) fractional-order diﬀerential equations (FODE) can
be written as [13]
anDβn
t y(t) + an−1Dβn−1
t
y(t) + · · · + a1Dβ1
t y(t) + a0Dβ0
t y(t) = u(t),
(10-6-23)

548
Scientiﬁc Computing with MATLAB®
−60
−40
−20
0
20
40
Magnitude (dB)
10
−4
10
−3
10
−2
10
−1
10
0
10
1
10
2
10
3
10
4
0
45
90
Phase (deg)
Bode Diagram
Frequency  (rad/s)
ωb
ωh
(a) Bode diagram
0
0.5
1
1.5
2
2.5
3
−1
0
1
2
3
4
5
6
(b) fractional-order derivative
FIGURE 10.55: Fractional-order derivatives with diﬀerent ﬁlters.
where u(t) is the input signal. If the initial conditions are zero, the equation is Riemann–
Liouville diﬀerential equation, while the ones with nonzero initial conditions, are referred
to as Caputo diﬀerential equations. In this section, numerical solutions of the two types of
diﬀerential equations will be introduced. If the initial conditions are zero, the simpliﬁed
transfer function can be written as
G(s) = Y (s)
U(s) =
1
ansβn + an−1sβn−1 + · · · + a1sβ1 + a0sβ0 .
(10-6-24)
I. Analytical solutions of linear fractional-order equations
With Mittag–Leﬄer function presented in Chapter 8, the analytical solution of the
n-term fractional-order diﬀerential equation is given in general form [17] by
y(t)
=
1
an
∞

m=0
(−1)m
m!

k0+k1+···+kn−2=m
k0⩾0;··· ,kn−2⩾0
(m; k0, k1, · · · , kn−2)
n−2

i=0
 ai
an
ki
t(βn−βn−1)m+βn+n−2
j=0 (βn−1−βj)kj−1
(10-6-25)
E (m)
βn−βn−1,βn+n−2
j=0 (βn−1−βj)kj

−an−1
an
tβn−βn−1

,
where Eλ,μ(z) is the Mittag–Leﬄer function deﬁned in (8-5-24), m is an integer.
The system response expression (10-6-25) sometimes is too complicated to use. Here a
special form of the model G(s) = 1/(a2sβ2 + a1sβ1 + a0) is studied. The step response of
the system is written as [18]
y(t) = 1
a2
∞

k=0
(−1)kˆak
0t−ˆa1+(k+1)β2
k!
E (k)
β2−β1,β2+β1k+1

−ˆa1tβ2−β1
,
(10-6-26)
where ˆa0 = a0/a2, ˆa1 = a1/a2. Similar to the ml func() function, the step response solution
function can be written as
function y=ml_step(a0,a1,a2,b1,b2,t,eps0)
y=0; k=0; ya=1; a0=a0/a2; a1=a1/a2; if nargin==6, eps0=eps; end

Topics on Nontraditional Mathematical Branches
549
while max(abs(ya))>=eps0 % if error exists, continue add terms
ya=(-1)^k/gamma(k+1)*a0^k*t.^((k+1)*b2).*... % compute the next term
ml_func([b2-b1,b2+b1*k+1],-a1*t.^(b2-b1),k,eps0);
y=y+ya; k=k+1;
end
y=y/a2;
whose syntax is y = ml step(a0,a1,a2,β1,β2,t,ϵ0).
Example 10.55
Please solve numerically the fractional-order diﬀerential equation
D0.8y(t) + 0.75D0.4y(t) + 0.9y(t) = u(t), with zero initial conditions, and the input is
unit step signal.
Solution It is obvious that a0 = 0.9, a1 = 0.75, a2 = 1, β1 = 0.4, β2 = 0.8. The numerical
solution of the original diﬀerential equation can be obtained, as shown in Figure 10.56.
>> t=0:0.001:5; y=ml_step(0.9,0.75,1,0.4,0.8,t); plot(t,y)
0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
FIGURE 10.56: Solution of the fractional-order diﬀerential equation.
From the above simulation example, it can be seen that both methods give correct
results. However, the computation based on Gr¨unwald–Letnikov’s deﬁnition is much simpler
than the Mittag–Leﬄer function-based method. Thus, it will be used later in the book.
II. A closed-form solution to linear fractional-order diﬀerential equations
with zero initial conditions
If the initial values of the output signal y(t), input signal u(t) and their derivatives at
t = 0 are all zeros, and the right hand side of the equation contains ˆu(t) alone, the original
diﬀerential equation can be simpliﬁed as
anDβn
t y(t) + an−1Dβn−1
t
y(t) + · · · + a1Dβ1
t y(t) + a0Dβ0
t y(t) = ˆu(t),
(10-6-27)
where, ˆu(t) is composed of the linear combination of a signal u(t) and its fractional-order
derivatives, and can be evaluated independently
ˆu(t) = b1Dγ1
t u(t) + b2Dγ2
t u(t) + · · · + bmDγm
t
u(t).
(10-6-28)
For simplicity in the presentation, assume that βn > βn−1 > · · · > β1 > β0 > 0. If the

550
Scientiﬁc Computing with MATLAB®
following two special cases emerge, conversions should be made ﬁrst, then, the solutions can
be found.
(i) If the order of the original equation does not satisfy the inequalities, the terms in
the original equation should be sorted ﬁrst.
(ii) If there exists negative βi’s, fractional-order integral-diﬀerential equation is involved.
In this case, new variable z(t) = Dβ0
t y(t) should be introduced, such that the original
equation can be converted to the fractional-order diﬀerential equation og signal z(t).
Consider the Gr¨unwald–Letnikov deﬁnition in (10-6-17), the modiﬁed discrete version
can be written as
t0Dβi
t y(t) ≈
1
hβi
[(t−t0)/h]

j=0
w
(βi)
j
yt−jh =
1
hβi
⎡
⎣yt +
[(t−t0)/h]

j=1
w
(βi)
j
yt−jh
⎤
⎦
(10-6-29)
where w
(βi)
0
can still be evaluated recursively
w
(βi)
0
= 1,
w
(βi)
j
=

1 −βi + 1
j

w
(βi)
j−1, j = 1, 2, · · · .
(10-6-30)
Substituting the formula to (10-6-23), the closed-form numerical solution to the
fractional-order diﬀerential equation can be obtained as
yt =
1
n

i=0
ai
hβi
⎡
⎣ut −
n

i=0
ai
hβi
[(t−t0)/h]

j=1
w
(βi)
j
yt−jh
⎤
⎦.
(10-6-31)
Now consider the general form of the fractional-order diﬀerential equation in (10-6-38),
the right-hand side of the function can be evaluated, and the equation can be converted
into the form in (10-6-23). In practical programming, the original linear problem can
be equivalently converted to evaluate the ˆy(t) signal under the excitation of u(t), then,
take fractional-order derivatives to ˆy(t). Based on the algorithm, a MATLAB function
fode sol() can be written to solve numerically linear fractional-order diﬀerential equations
with zero initial conditions.
function y=fode_sol(a,na,b,nb,u,t) % fractional-order diﬀerential equation
h=t(2)-t(1); D=sum(a./[h.^na]); nT=length(t); D1=b(:)./h.^nb(:);
nA=length(a); vec=[na nb]; y1=zeros(nT,1); W=ones(nT,length(vec));
for j=2:nT, W(j,:)=W(j-1,:).*(1-(vec+1)/(j-1)); end
for i=2:nT,
A=[y1(i-1:-1:1)]’*W(2:i,1:nA); y1(i)=(u(i)-sum(A.*a./[h.^na]))/D;
end
for i=2:nT, y(i)=(W(1:i,nA+1:end)*D1)’*[y1(i:-1:1)]; end
The function can be called with y = fode sol(a,na,b,nb,u,t), where, the time and
input vectors can be obtained in vectors in t and u.
Example 10.56
Solve numerically the following fractional-order diﬀerential equation
D3.5
t
y(t) + 8D3.1
t
y(t) + 26D2.3
t
y(t) + 73D1.2
t
y(t) + 90D0.5
t
y(t) = 90 sint2.
Solution The vectors a and n can be extracted from the original equation ﬁrst, and then,

Topics on Nontraditional Mathematical Branches
551
function fode sol() can be used to solve the original equations. The curves of input and
output signals can be obtained as shown in Figure 10.57. So, one should verify the numerical
results obtained. The simplest way is to modify the control parameters in the solution. For
instance, one can change the step-size from 0.002 to 0.001, and check whether they give the
same results. For this example, it can be seen that the results are the same, as shown in
Figure 10.57.
>> a=[1,8,26,73,90]; n=[3.5,3.1,2.3,1.2,0.5];
G=fotf(a,n,1,0); t=0:0.002:10; u=90*sin(t.^2); y=lsim(G,u,t);
subplot(211), plot(t,y); subplot(212), plot(t,u)
0
1
2
3
4
5
6
7
8
9
10
0
0.5
1
0
1
2
3
4
5
6
7
8
9
10
−100
0
100
y(t)
u(t)
FIGURE 10.57: Input signal and solution of the equation.
III. Solutions of Caputo diﬀerential equations with nonzero initial conditions
If there exists nonzero initial values in the input, output and their derivatives, the above
algorithm cannot be used to ﬁnd the numerical solutions. Numerical solution algorithms
are needed to solve Caputo fractional-order diﬀerential equations.
Consider the linear Caputo fractional-order diﬀerential equation given by
an C
t0Dβn
t y(t) + an−1 C
t0Dβn−1
t
y(t) + · · · + a1 C
t0Dβ1
t y(t) + a0 C
t0Dβ0
t y(t) = ˆu(t).
(10-6-32)
For convenience, assume that βn > βn−1 > · · · > β1 > β0 ⩾0. Also, assume that only
ˆu(t) function appears in the right hand side of the equation. If there are fractional-order
derivatives of u(t) in the right hand side of the equation, the method used earlier can be
applied to evaluate ˆu(t) ﬁrst the linear combinations.
If m = ⌈βn⌉, m initial conditions, y(t0), y′(t0), · · · , y(m−1)(t0), are needed to uniquely
solve the original fractional-order diﬀerential equation. Thus, an auxiliary signal z(t) is
introduced such that
z(t) = y(t) −y(t0) −y′(t0)t −· · · −
1
(m −1)!y(m−1)(t0)tm−1,
(10-6-33)
where the initial values of z(t) and its ﬁrst (m −1)th order derivatives are all zeros. The
above expression can also be written as
y(t) = z(t) + y(t0) + y′(t0)t + · · · +
1
(m −1)!y(m−1)(t0)tm−1.
(10-6-34)

552
Scientiﬁc Computing with MATLAB®
Since the initial values of z(t) and its derivatives are all zeros, CDβi
t z(t) = RLDβi
t z(t),
the βith order Caputo derivative of y(t0) + y′(t0)t + · · · + y(m−1)(t0)tm−1/(m −1)! can be
evaluated directly with
function s=poly2caputo(a,r,t0), syms v tau; if nargin==2, t0=0; end
if r==ceil(r), s=diff(poly2sym(a,u),r);
else, s=int(diff(poly2sym(a,’tau’),ceil(r))/((u-tau)^(r-ceil(r)+1))...
/gamma(ceil(r)-r),tau,t0,u);
end
The syntax of the function is s = poly2caputo(a,β,t0), where,
a = [y(m−1)(t0), y(m−2)(t0), · · · , y′(t0), y(t0)]
(10-6-35)
is the vector of initial conditions, β is the order. The returned s is the symbolic expression
of the derivative of the polynomial.
With the compensation function given above, the original diﬀerential equation can be
converted to
anRL
t0 Dβn
t z(t) + an−1RL
t0 Dβn−1
t
z(t) + · · · + a1RL
t0 Dβ1
t z(t) + a0RL
t0Dβ0
t z(t)
= ˆu(t) −
n

i=0
aiCDβi

y(t0) + y′(t0)t + · · · +
1
(m −1)!y(m−1)(t0)tm−1

.
(10-6-36)
Similar to fode sol() function, a Caputo diﬀerential equation solver can be written,
with the syntax y = fode caputo(a,na,y0,u,t), where, u is the samples of the input
signal, and t is the vector of time.
function [y,z]=fode_caputo(a,na,y0,u,t), h=t(2)-t(1);
D=sum(a./[h.^na]); nT=length(t); nb=0; b=1; D1=b(:)./h.^nb(:);
nA=length(a); vec=[na nb]; y1=zeros(nT,1); W=ones(nT,length(vec));
for i=1:length(a), u=u-a(i)*subs(poly2caputo(y0,na(i),t(1)),’v’,t); end
for j=2:nT, W(j,:)=W(j-1,:).*(1-(vec+1)/(j-1)); end
for i=2:nT,
A=[y1(i-1:-1:1)]’*W(2:i,1:nA); y1(i)=(u(i)-sum(A.*a./[h.^na]))/D;
end
z=y1’; y=z+polyval(y0,t);
Example 10.57
Consider again the linear equation studied in Example 10.56. If the
equation is a Caputo equation, with initial conditions y(0) = 1, y′(0) = −1, y′′(0) = 2,
and y′′′(0) = 3, please solve the equation again.
Solution An initial condition vector can be constructed based on the initial conditions, and
then, the following statements can be used to solve numerically the Caputo equation, and
the result obtained is shown in Figure 10.58.
>> a=[1,8,26,73,90]; n=[3.5,3.1,2.3,1.2,0.5];
t=0:0.001:10; u=90*sin(t.^2); y0=[3 2 -1 1]; % compute the input
y=fode_caputo(a,n,y0,u,t); plot(t,y) % solve Caputo equation

Topics on Nontraditional Mathematical Branches
553
0
1
2
3
4
5
6
7
8
9
10
0
1
2
3
4
5
6
FIGURE 10.58: Numerical solutions of Caputo equations.
10.6.5
Block diagram based solutions of nonlinear fractional-order
ordinary diﬀerential equations
If nonlinear fractional-order diﬀerential equation is given, and in particular, the nonlinear
diﬀerential equation is only part of the whole system model, conventional solvers are
not suitable in ﬁnding the numerical solutions, and a block diagram based algorithm is
needed. In this section, the Oustaloup ﬁlter or the modiﬁed ﬁlter are used as the kernel
in constructing nonlinear fractional-order diﬀerential equations. Zero and nonzero initial
condition problems are both discussed in the section.
I. Nonlinear equations with zero initial conditions
It can be seen that the Oustaloup ﬁlters given in the previous subsection are eﬀective
ways for evaluating fractional-order diﬀerentiations. Since the orders of the numerator and
denominator in the ordinary Oustaloup ﬁlter are the same, it is likely to cause algebraic
loops. Thus, a low-pass ﬁlter should be appended to the ﬁlter. The block in Figure 10.59
(a) can be used for modeling fractional-order diﬀerentiators.
With the use of masking technique in Simulink [19], the designed block can be masked as
shown in Figure 10.59 (b). Double click such a block and a dialog box appears as in Figure
10.59 (c). The corresponding parameters can be ﬁlled into the dialog box to complete the
fractional-order diﬀerentiator block. The following code can be attached to the masked
block.
wb=ww(1); wh=ww(2); G=ousta_fod(gam,n,wb,wh);
num=G.num{1}; den=G.den{1}; str=’Fractional\n’;
if isnumeric(gam)
if gam>0, str=[str, ’Der
s^’ num2str(gam)];
else, str=[str, ’Int
s^{’ num2str(gam) ’}’]; end
else, str=[str, ’Der
s^gam’]; end
Example 10.58 Solve the linear fractional-order diﬀerential equations in Example 10.56,
and compare the results with other methods.
Solution For linear fractional-order diﬀerential equations, the block diagram-based method
is not as straightforward as the method used in Example 10.56. An auxiliary variable z(t) =
D0.5
t
y(t) can be introduced, and the original diﬀerential equation can be rewritten as

554
Scientiﬁc Computing with MATLAB®
1
Out1
T.s+1
1
Transfer Fcn1
num(s)
den(s)
Transfer Fcn
1
In1
c10mfode
Fractional
Der  s^0.9
(a) ﬁlter for fractional-order diﬀerentiator
(b) masked block
(c) parameter dialog box
FIGURE 10.59: Fractional-order diﬀerentiator block design.
z(t) = sin(t2) −1
90
%
D3
t z(t) + 8D2.6
t
z(t) + 26D1.8
t
z(t) + 73D0.7
t
z(t)
&
.
The Simulink block diagram shown in Figure 10.60 can be established based on the new
equation. With stiﬀODE solvers, the numerical solution to the problem can be found and
the results are exactly the same as the one in Figure 10.57.
1
Out1
1/90
Gain4
73
Gain2
26
Gain1
8
Gain
Fractional
Int  s^{−0.5}
Fractional
Der  s^0.7
Fractional
Der  s^0.8
Fractional
Der  s^0.6
90*sin(u[1]^2)
Fcn
du/dt
Derivative2
du/dt
Derivative1
du/dt
Derivative
Clock
FIGURE 10.60: Simulink block diagram (ﬁle: c10mfod1.mdl).
Example 10.59
Solve the nonlinear fractional-order diﬀerential equation
3D0.9y(t)
3 + 0.2D0.8y(t) + 0.9D0.2y(t) +
""2D0.7y(t)
""1.5 + 4
3y(t) = 5 sin 10t.
Solution From the given equation, the explicit form of y(t) can be written as
y(t) = 3
4

5 sin 10t −
3D0.9y(t)
3 + 0.2D0.8y(t) + 0.9D0.2y(t) −
""2D0.7y(t)
""1.5

Topics on Nontraditional Mathematical Branches
555
and from the explicit expression of y(t), the block diagram in Simulink can be established
in Figure 10.61 (a). From the simulation model, the simulation results can be obtained as
shown in Figure 10.61 (b). The results are veriﬁed by diﬀerent control parameters in the
ﬁlter, and they give consistent results.
y(t)
1
Out1
Sine Wave
Product
3
Gain4
0.75
Gain3
2
Gain2
0.9
Gain1
0.2
Gain
Fractional
Der  s^0.7
Fractional
Der  s^0.2
Fractional
Der  s^0.8
Fractional
Der  s^0.9
abs(u)^1.5
Fcn
3
Constant
(a) Simulink model (ﬁle: c10mfod2.mdl)
0
1
2
3
4
−2.5
−2
−1.5
−1
−0.5
0
0.5
(b) simulation results
FIGURE 10.61: Simulink description and simulation results.
II. Numerical solution of Caputo diﬀerential equations with nonzero initial
conditions
Similar to the masking process of the Riemann–Liouville operator discussed earlier, a
masked Caputo operator is shown in Figure 10.62.
Out1
1
Transfer Fcn
num(s)
den(s)
Fcn
f(u)
Clock
In1
1
(a) Simulink ﬁlter
Caputo operator
Fractional
Der s^0.3
(b) masked block
(c) parameter dialog box of the operator
FIGURE 10.62: Caputo fractional-order diﬀerentiator block.
The initialization code in the block can be modiﬁed as
wb=ww(1); wh=ww(2); G=ousta_fod(gam,n,wb,wh); G1=tf(G);
num=G1.num{1}; den=G1.den{1}; str=’Fractional\n’;
strmodel=[get_param(gcs,’Name’),’/’ get_param(gcb,’Name’) ’/Fcn’];
set_param(strmodel,’Expr’,char(poly2caputo(a,gam)));
if isnumeric(gam)

556
Scientiﬁc Computing with MATLAB®
if gam>0, str=[str, ’Der s^’ num2str(gam) ];
else, str=[str, ’Int s^{’ num2str(gam) ’}’]; end
else, str=[str, ’Der s^gam’]; end
where, function poly2caputo() is the compensation function expressed in a function block
Fcn, discussed earlier.
Assume that the highest order in the equation is α, and m = ⌈α⌉, m initial conditions,
y(t0), y′(t0), y′′(t0), · · · , y(m−1)(t0) are needed in the numerical solution. An auxiliary signal
z(t) can be introduced
z(t) = y(t) −y(t0) −y′(t0)t −1
2!y′′(t0)t2 −· · · −
1
(m −1)!y(m−1)(t0)tm−1.
(10-6-37)
Thus, the signal y(t) in the Caputo equation can be converted to the Riemann–
Liouville equation of signal z(t). Thus, the nonlinear fractional-order diﬀerential equations
can be solved directly with block diagram methods.
Example 10.60
Solve the Caputo diﬀerential equation given by [20]
C
0 D1.455
t
y(t) = −t0.1 E1,1.545(−t)
E1,1.445(−t)ety(t)C
0 D0.555
t
y(t) + e−2t −
% C
0 D1
t y(t)
&2 ,
where, y(0) = 1, y′(0) = −1. The analytical solution y = e−t can be used to validate the
solution. It should be noted that there were errors in the original equation in [20] and are
modiﬁed here, where the Mittag–Leﬄer functions in two parameters are used instead.
Solution Introducing the auxiliary signal z(t) = y(t) −y(0) −y′(0)t = y(t) −1 + t, the
variable y(t) = z(t) + 1 −t can be substituted back to the original equation to convert it to
an equation of signal z(t), with zero initial conditions.
C
0 D1.455
t
[z(t) + 1 −t] = −t0.1et E1,1.545(−t)
E1,1.445(−t)y(t) C
0 D0.555
t
[z(t) + 1 −t]
+ e−2t −
% C
0 D1
t [z(t) + 1 −t]
&2 .
It is known in (10-6-16) that, for the signal z(t) with zero initial conditions, C
0 Dαz(t) =
RL
0 Dαz(t). Besides, it is known from the Caputo deﬁnition, since C
0 D1.455[z(t) + 1 −t] takes
the second order derivative with respect to t, the augmented 1 −t term vanishes. Therefore,
C
0 D1.455[z(t) + 1 −t] = RL
0 D1.455z(t). The original Caputo equation can be converted to
RL
0 D1.455
t
z(t) = −t0.1et E1,1.545(−t)
E1,1.445(−t)y(t)C
0 D0.555
t
y(t) + e−2t−[ z′(t) −1]2 .
The term C
0 D0.555y(t) can be modeled directly with the Caputo operator block. Therefore,
the Simulink model shown in Figure 10.63 can be established. Besides, since Mittag–Leﬄer
is used, its S-function implementation can be constructed
function [sys,x0,str,ts]=sfun_mls(t,x,u,flag,a)
switch flag
case 0, sizes=simsizes;
sizes.NumContStates=0; sizes.NumDiscStates=0; sizes.NumOutputs=1;
sizes.NumInputs=1; sizes.DirFeedthrough=1; sizes.NumSampleTimes=1;
sys=simsizes(sizes); x0=[]; str=[]; ts=[-1 0];
case 3, sys=ml_func([1,a],u);
case {1,2,4,9}, sys=[];

Topics on Nontraditional Mathematical Branches
557
Out1
1
S−Function1
sfun_mls
S−Function
sfun_mls
Riemann−Liouville operator
In1
Out1
Fractional
Int s^{−0.455}
Product1
Product
Integrator
1/s
Gain
−1
Fcn5
−u+1
Fcn4
(u−1)^2
Fcn1
exp(−2*u)
u^0.1*exp(u)
Clock
Caputo operator
Fractional
Der s^0.555
Add2
z(t)
y(t)
−t + 1
z′(t)
FIGURE 10.63: Simulink description of the nonlinear equation (c10mcaputo).
otherwise, error([’Unhandled flag=’,num2str(flag)]);
end
The Simulink model can be solved numerically, and the result of the nonlinear Caputo
solution can be obtained as shown in Figure 10.64. It can be seen that the result is quite
close to its theoretical one of e−t.
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
0.4
0.5
0.6
0.7
0.8
0.9
1
FIGURE 10.64: Solution of the nonlinear equation.
10.6.6
Object-oriented modeling and analysis of linear fractional-
order systems
Consider the linear fractional-order diﬀerential equation in (10-6-23). If the initial values
of the input signal u(t) and output signal y(t), and their derivatives are all zeros, with the

558
Scientiﬁc Computing with MATLAB®
property in Laplace transform, the fractional-order transfer function can be established
G(s) =
b1sγ1 + b2sγ2 + · · · + bmsγm
a1sη1 + a2sη2 + · · · + an−1sηn−1 + ansηn e−T s,
(10-6-38)
and in the transfer function model, a delay term with T seconds of time delay is introduced.
The numerator and denominator are referred to as pseudo-polynomials.
Compared with the well-known integer-order transfer functions, it can be seen that in
the fractional-order transfer function models, apart from the coeﬃcients in numerator and
denominator pseudo-polynomials, the orders are also needed. Therefore, four vectors and a
vector can be used to describe uniquely the fractional-order transfer function in (10-6-38).
An FOTF (fractional-order transfer function) class can be established in MATLAB to handle
this type of model. Also, according to the facilities provided in the Control System Toolbox,
a series of overload functions should also be written, such that the modeling and analysis
of fractional-order systems are in fact as easy and straightforward as in integer-order ones.
I. Creation of FOTF class
To establish a MATLAB class, a name must be assigned. In our case, the name is
selected as FOTF. Therefore, a folder @fotf in MATLAB’s search path should be created.
Two essential functions fotf.m and display.m must be written in the folder, with the ﬁrst
one for deﬁning the class, while the latter for displaying the class. Also, supporting facilities
are introduced.
(i) Programming with the fotf.m function. A MATLAB function fotf.m should
be created to declare the FOTF class, as follows
function G=fotf(a,na,b,nb,T)
if nargin==0,
% an empty FOTF
G.a=[]; G.na=[]; G.b=[]; G.nb=[]; G.ioDelay=0; G=class(G,’fotf’);
elseif isa(a,’fotf’), G=a;
% existing FOTF
elseif nargin==1 & isa(a,’double’), G=fotf(1,0,a,0,0); % a gain block
elseif isa(a,’tf’) | isa(a,’ss’),
% integer-order one
[n,d]=tfdata(tf(a),’v’); nn=length(n)-1:-1:0;
nd=length(d)-1:-1:0; G=fotf(d,nd,n,nn,a.ioDelay);
elseif nargin==1 & a==’s’, G=fotf(1,0,1,1,0);
% an operator
else, ii=find(abs(a)<eps); a(ii)=[]; na(ii)=[];
% ordinary FOTF
ii=find(abs(b)<eps); b(ii)=[]; nb(ii)=[];
if nargin==5, G.ioDelay=T; else, G.ioDelay=0; end
G.a=a; G.na=na; G.b=b; G.nb=nb; G=class(G,’fotf’);
end
Now in MATLAB command window, a command G = fotf(a,na,b,nb,T ) can be used
to create a fractional-order transfer function object, with
a = [a1,a2,· · · ,an], b = [b1,b2,· · · ,bm],
na = [β1,β2,· · · ,βn], nb = [γ1,γ2,· · · ,γm].
These vectors are used to represent the coeﬃcients and orders of denominators and
numerators of the fractional-order transfer functions. The argument T is the delay constant.
It can be omitted if there is no delay in the model.
Similar to the deﬁnitions of integer-order transfer functions, s = fotf(’s’) command

Topics on Nontraditional Mathematical Branches
559
can also be used to declare a fractional-order diﬀerentiation operator s. Also, G = fotf(k)
can be used to convert a constant into an FOTF object. If G is an LTI object in Control
System Toolbox, command G = fotf(G) can be used to convert it into a fractional-order
one.
(ii)
Display function
Another essential function is the display function, named
as display.m. The listing of the function is given below, and the function can be used
to display the FOTF object automatically, once created. The function simplify() is an
overload function used to simplify the object and will be presented later.
function display(G)
G=simplify(G); strN=polydisp(G.b,G.nb); strD=polydisp(G.a,G.na);
nn=length(strN); nd=length(strD); nm=max([nn,nd]);
disp([char(’ ’*ones(1,floor((nm-nn)/2))) strN]), ss=[];
T=G.ioDelay; if T>0, ss=[’ exp(-’ num2str(T) ’s)’]; end
disp([char(’-’*ones(1,nm)), ss]);
disp([char(’ ’*ones(1,floor((nm-nd)/2))) strD])
function strP=polydisp(p,np) % subfunction to display pseudo-polynomial
if length(np)==0, p=0; np=0; end,
P=’’; [np,ii]=sort(np,’descend’); p=p(ii); L=length(p);
for i=1:L, P=[P,’+’,num2str(p(i)),’s^{’,num2str(np(i)),’}’]; end
P=P(2:end); P=strrep(P,’s^{0}’,’’); P=strrep(P,’+-’,’-’);
P=strrep(P,’^{1}’,’’); P=strrep(P,’+1s’,’+s’);
strP=strrep(P,’-1s’,’-s’); nP=length(strP);
if nP>=2 & strP(1:2)==’1s’, strP=strP(2:end); end
Example 10.61
Please enter the following FOTF model into MATLAB workspace.
G(s) =
0.8s1.2 + 2
1.1s1.8 + 1.9s0.5 + 0.4 e−0.5s.
Solution The following MATLAB statements can be issued, and an FOTF object G can
be constructed in MATLAB workspace.
>> G=fotf([1.1,1.9,0.4],[1.8,0.5,0],[0.8,2],[1.2,0],0.5) % FOTF object
(iii) Other facilities. Further, apart from the two essential functions fotf.m and
display.m, if we want to access the ﬁelds in the FOTF object directly with MATLAB,
the following two ﬁles are written. With these functions, commands like G.nb and G.na =
[0.1,0.2] are supported
function A=subsasgn(G,index,InputVal)
switch index.subs
case {’a’,’na’,’b’,’nb’,’ioDelay’},
eval([’G.’ index.subs,’=InputVal;’]);
if length(G.a)~=length(G.na) | length(G.b)~=length(G.nb)
error(’Error: field pairs (na,a) or (nb,b) mismatched.’)
else, A=fotf(G.a,G.na,G.b,G.nb,G.ioDelay); end
otherwise,
error(’Error: Available fields are a, na, b, na, ioDelay.’);
end

560
Scientiﬁc Computing with MATLAB®
function A=subsref(G,index)
switch index.subs
case {’a’,’na’,’b’,’nb’,’ioDelay’}, A=eval([’G.’ index.subs]);
otherwise,
error(’Error: Available fields are a, na, b, na, ioDelay.’);
end
It should be noted that all the ﬁles should be placed in the @fotf folder, and nowhere
else, otherwise, existing MATLAB functions will be aﬀected.
II. Interconnections of FOTF objects
With the use of Control System Toolbox of MATLAB, the integer-order LTI models can
be evaluated with sum, product and feedback() operations, when the parallel, series or
feedback connections are involved. Following the idea used in the Control System Toolbox,
the following overload functions can be written, and these functions should be placed again
in the @fotf folder [21]. The functions with some modiﬁcations and extensions are listed
here.
(i) Product of two FOTF objects, with G = G1*G2, computing the overall model,
when two FOTFs G1(s) and G2(s) are in series connection. The formula for ﬁnding series
connected system is
G(s) = G1(s)G2(s) = N1(s)N2(s)
D1(s)D2(s)e−(τ1+τ2)s.
(10-6-39)
function G=mtimes(G1,G2) % handle series connected FOTF blocks
G1=fotf(G1); G2=fotf(G2); a=kron(G1.a,G2.a); b=kron(G1.b,G2.b);
na=kronsum(G1.na,G2.na); nb=kronsum(G1.nb,G2.nb);
G=simplify(fotf(a,na,b,nb,G1.ioDelay+G2.ioDelay));
For simplicity, Kronecker sum A ⊕B is introduced
A ⊕B =
⎡
⎢⎣
a11 + B
· · ·
a1m + B
...
...
...
an1 + B
· · ·
anm + B
⎤
⎥⎦,
(10-6-40)
in contrast to Kronecker product A ⊗B, and similar to kron() function, a Kronecker sum
function kronsum() is written
function C=kronsum(A,B)
[ma,na]=size(A); [mb,nb]=size(B);
A=reshape(A,[1 ma 1 na]); B=reshape(B,[mb 1 nb 1]);
C=reshape(bsxfun(@plus,A,B),[ma*mb na*nb]); % structure copied from kron
(ii) Sum function, with G = G1 + G2, computing the overall model, when two FOTFs,
G1(s) and G2(s), are connected in parallel. If the delays of the two blocks are the same,
where τ1 = τ2, denoted by τ, the sum action can be carried out, and the formula for the
evaluation of parallel connection is
G(s) = G1(s) + G2(s) = N1(s)D2(s) + N2(s)D1(s)
D1(s)D2(s)
e−τs.
(10-6-41)

Topics on Nontraditional Mathematical Branches
561
function G=plus(G1,G2)
% handle parallel connected FOTF blocks
G1=fotf(G1); G2=fotf(G2);
% unify to FOTF objects
if G1.ioDelay==G2.ioDelay
% if delays are the same, problem solvable
a=kron(G1.a,G2.a); na=kronsum(G1.na,G2.na);
b=[kron(G1.a,G2.b),kron(G1.b,G2.a)];
nb=[kronsum(G1.na,G2.nb),kronsum(G1.nb,G2.na)];
G=simplify(fotf(a,na,b,nb,G1.ioDelay));
else, error(’cannot handle different delays’); end
(iii) Negative feedback function, with G = feedback(G1,G2). The overall model
of two FOTFs in negative feedback connection can be obtained, if there are no delays of the
two blocks. The feedback connection of the two blocks can be processed. If positive feedback
is involved, G2 should be replaced by −G2. The formula for ﬁnding the overall model is
given by
G(s) =
G1(s)
1 + G1(s)G2(s) =
N1(s)D2(s)
D1(s)D2(s) + N1(s)N2(s).
(10-6-42)
function G=feedback(G1,G2)
% handle feedback connected FOTF blocks
G1=fotf(G1); G2=fotf(G2);
% unify to FOTF objects
if G1.ioDelay==0 & G2.ioDelay==0
% blocks without delays, problem solvable
b=kron(G1.b,G2.a); nb=kronsum(G1.nb,G2.na);
na=[kronsum(G1.nb,G2.nb), kronsum(G1.na,G2.na)];
a=[kron(G1.b,G2.b), kron(G1.a,G2.a)]; G=simplify(fotf(a,na,b,nb,0));
else, error(’cannot handle blocks with delays’); end
(iv)
Other simple supporting functions, with uminus() for G1(s) = −G(s), to
enable the use of G1 = −G command. Function G = inv(G1) can be used to compute
G(s) = 1/G1(s); function minus() is used to compute G(s) = G1(s) −G2(s), allowing
G = G1 −G2; Function eq() is used to check whether the two FOTFs G1 and G2 are equal.
If key = G1==G2 returns 1, the two FOTFs are equal.
function G=uminus(G1), G=G1; G.b=-G.b;
function G=inv(G1), G=fotf(G1.b,G1.nb,G1.a,G1.na);
function G=minus(G1,G2), G=G1+(-G2);
function key=eq(G1,G2), G=G1-G2; key=(length(G.nb)==0|norm(G.b)<1e-10);
(v)
Right division function, with the syntax G = G1/G2, compute G(s)
=
G1(s)/G2(s).
function G=mrdivide(G1,G2)
G1=fotf(G1); G2=fotf(G2); G=G1*inv(G2); G.ioDelay=G1.ioDelay-G2.ioDelay;
if G.ioDelay<0, warning(’block with positive delay’); end
(vi) Power function, with the syntax G = G1^n. If G1 is an FOTF, then, n must be
an integer. Otherwise, G1 must be an s operator.
function G1=mpower(G,n)
if n==fix(n), % ﬁnd out whether power is an integer
if n>=0, G1=1; for i=1:n, G1=G1*G; end
% integer power of FOTF
else, G1=inv(G^(-n)); end
% handling negative power
elseif G==fotf(1,0,1,1), G1=fotf(1,0,1,n); % power of operator
else, error(’mpower: power must be an integer.’); end

562
Scientiﬁc Computing with MATLAB®
(vii)
Simpliﬁcation function, with the syntax G = simplify(G), used to simplify
the pseudo-polynomials in the numerator and denominator. The subfunction polyuniq() is
used to collect the terms in the pseudo-polynomials. The subfunction is a low-level function
of simplify() and cannot be called directly by other functions.
function G=simplify(G1)
[a,n]=polyuniq(G1.a,G1.na); G1.a=a; G1.na=n; na=G1.na;
[a,n]=polyuniq(G1.b,G1.nb); G1.b=a; G1.nb=n; nb=G1.nb;
if length(nb)==0, nb=0; G1.nb=0; G1.b=0; end
nn=min(na(end),nb(end)); nb=nb-nn; na=na-nn;
G=fotf(G1.a,na,G1.b,nb,G1.ioDelay);
function [a,an]=polyuniq(a,an) % collect terms in the pseudo-polynomial
[an,ii]=sort(an,’descend’); a=a(ii); ax=diff(an); key=1;
for i=1:length(ax) % here ax is the order diﬀerence vector
if ax(i)==0,
% collect terms of the same order
a(key)=a(key)+a(key+1); a(key+1)=[]; an(key+1)=[];
else, key=key+1; end
end
Example 10.62 Please input the fractional-order PID controller Gc(s) = 5+2s−0.2+3s0.6
into MATLAB workspace
Solution An FOTF operator s can be speciﬁed ﬁrst, then, the following commands can be
used to input the fractional-order PID controller model
>> s=fotf(’s’); Gc=5+2*s^(-0.2)+3*s^0.6 % declare operator then add up
An FOTF model is returned as Gc(s) = (3s0.8 + 5s0.2 + 2)/s0.2.
Example 10.63
Please enter the following complicated fractional-order transfer function
model into MATLAB workspace
G(s) =
(s0.3 + 3)2
(s0.2 + 2)(s0.4 + 4)(s0.4 + 3).
Solution For complicated models, an FOTF operator s can be deﬁned ﬁrst, then, simple
commands can be used to input the system into MATLAB workspace.
>> s=fotf(’s’); G=(s^0.3+3)^2/(s^0.2+2)/(s^0.4+4)/(s^0.4+3)
The result is expressed in FOTF format as
G(s) =
s0.6 + 6s0.3 + 9
s + 2s0.8 + 7s0.6 + 14s0.4 + 12s0.2 + 24.
Example 10.64 Assume that in a typical unity negative feedback system, the two transfer
functions in the forward path are given by
G(s) =
0.8s1.2 + 2
1.1s1.8 + 0.8s1.3 + 1.9s0.5 + 0.4, Gc(s) = 1.2s0.72 + 1.5s0.33
3s0.8
,
please ﬁnd the closed-loop fractional-order system.
Solution The two components can be entered into MATLAB environments ﬁrst as FOTF
objects, then, function feedback() can be called to get the closed-loop model

Topics on Nontraditional Mathematical Branches
563
>> G=fotf([1.1,0.8 1.9 0.4],[1.8 1.3 0.5 0],[0.8 2],[1.2 0]);
Gc=fotf([3],[0.8],[1.2 1.5],[0.72 0.33]); G0=feedback(G*Gc,1)
The closed-loop model can be obtained
G0(s) =
0.96s1.59 + 1.2s1.2 + 2.4s0.39 + 3
3.3s2.27+2.4s1.77+0.96s1.59+1.2s1.2+5.7s0.97+1.2s0.47+2.4s0.39+3.
With the FOTF class established, further analysis and design functions can be written
for linear fractional-order transfer functions, and the developed functions are listed in Table
10.15. For details, please check [22].
TABLE 10.15: Analysis functions of linear fractional-order systems.
syntax
explanation of the function
y = step(G,t)
compute the unit step response of G, if no argument is returned, draw
automatically the step response
y = lsim(G,u,t)
compute the time response G to arbitrary input u
key = isstable(G)
assess the stability of fractional-order system G
H = rlocus(G)
draw the root locus for the system G
H = bode(G,w)
compute/draw Bode diagram of the system G, over frequency vector w. Similar
functions are nyquist() and nichols()
n = norm(G,k)
compute the norms of the system G, with default k = 2, for H2 norm. For k = inf,
compute H∞
Example 10.65
Consider again the fractional-order PID control problem, with
G(s) =
(s0.3 + 3)2
(s0.2 + 2)(s0.4 + 4)(s0.4 + 3), Gc(s) = 0.1s1.3 + 0.02 +
10
s0.95 .
Please ﬁnd the norms of the plant model, and draw the open-loop Bode diagram and
closed-loop step response of the system, with FOTF tools.
Solution
The two blocks can be entered as FOTF blocks, the open-loop and closed-loop
models can be obtained, respectively. Based on the models, the Bode diagram and step
response can be obtained easily as shown in Figures 10.65 (a) and (b). It can be seen that,
with the use of the FOTF tools, the analysis of linear fractional-order systems is as simple
as it is in dealing with integer-order linear systems.
>> s=fotf(’s’); G=(s^0.3+3)^2/(s^0.2+2)/(s^0.4+4)/(s^0.4+3) % plant
Gc=0.1*s^1.3+0.02+10/s^0.95; % enter the controller model
w=logspace(-1,3); subplot(121), bode(G*Gc,w) % open-loop Bode diagram
t=0:0.01:10; subplot(122), step(feedback(G*Gc,1),t) % closed-loop
The norms of the plant model can be evaluated directly with the overload norm() function,
with n1 = 2.7167 and n2 = 8.6115. The following statements can be used to assess the
stability of the closed-loop system, from which it can be seen that the system is stable.
>> n1=norm(G), n2=norm(G,inf) % compute the norms of the plant model
G1=feedback(G*Gc,1); key=isstable(G1) % key is 1 for stable

564
Scientiﬁc Computing with MATLAB®
−20
0
20
40
Magnitude (dB)
10
−1
10
0
10
1
10
2
10
3
−315
−270
−225
−180
−135
−90
−45
Phase (deg)
Bode Diagram
Frequency  (rad/s)
(a) open-loop Bode diagram
0
1
2
3
4
5
6
7
8
9
10
0
0.2
0.4
0.6
0.8
1
1.2
1.4
(b) closed-loop step response
FIGURE 10.65: System analysis plots.
Exercises
Exercise 10.1 Consider a tipping problem in a restaurant [23]. Assume that the average
rate for the tips is 15% of the consumption. The service level and food quality are used to
calculate the tip. The service level can be written as “good,” “average” and “poor,” and the
food quality can also be expressed as other fuzzy descriptions. Establish a fuzzy inference
system for determining the tips.
Exercise 10.2 Consider the sampled data set (xi, yi) given in Table 10.16. Construct
a neural network model and plot the training curve in the interval x ∈(1, 10). Test
diﬀerent neural network structures and training algorithms. Compare the ﬁtting results
under diﬀerent structures.
TABLE 10.16: Measured data of Exercise 10.2.
xi
1
2
3
4
5
6
7
8
9
10
yi
244.0
221.0
208.0
208.0
211.5
216.0
219.0
221.0
221.5
220.0
Exercise 10.3 For the actual measured data given in Table 10.17, construct a neural
network to ﬁt the surface in the rectangular region (0.1, 0.1) ∼(1.1, 1.1). Compare the
results with data interpolation algorithms.
Exercise 10.4 Solve the benchmark problems in Exercise 6.9 using genetic algorithms and
PSO methods.
Exercise 10.5 Solve the constrained optimization problem with genetic algorithms and
PSO methods and compare the results with traditional optimization algorithms.

Topics on Nontraditional Mathematical Branches
565
TABLE 10.17: Measured data of Exercise 10.3.
yi
x1
x2
x3
x4
x5
x6
x7
x8
x9
x10
x11
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
1.1
0.1
0.8304
0.8273
0.8241
0.8210
0.8182
0.8161
0.8148
0.8146
0.8158
0.8185
0.8230
0.2
0.8317
0.8325
0.8358
0.8420
0.8513
0.8638
0.8798
0.8994
0.9226
0.9496
0.9801
0.3
0.8359
0.8435
0.8563
0.8747
0.8987
0.9284
0.9638
1.0045
1.0502
1.1
1.1529
0.4
0.8429
0.8601
0.8854
0.9187
0.9599
1.0086
1.0642
1.1253
1.1904
1.257
1.3222
0.5
0.8527
0.8825
0.9229
0.9735
1.0336
1.1019
1.1764
1.254
1.3308
1.4017
1.4605
0.6
0.8653
0.9105
0.9685
1.0383
1.118
1.2046
1.2937
1.3793
1.4539
1.5086
1.5335
0.7
0.8808
0.9440
1.0217
1.1118
1.2102
1.311
1.4063
1.4859
1.5377
1.5484
1.5052
0.8
0.8990
0.9828
1.082
1.1922
1.3061
1.4138
1.5021
1.5555
1.5573
1.4915
1.346
0.9
0.9201
1.0266
1.1482
1.2768
1.4005
1.5034
1.5661
1.5678
1.4889
1.3156
1.0454
1
0.9438
1.0752
1.2191
1.3624
1.4866
1.5684
1.5821
1.5032
1.315
1.0155
0.6248
1.1
0.9702
1.1279
1.2929
1.4448
1.5564
1.5964
1.5341
1.3473
1.0321
0.6127
0.1476
min
x s.t.
⎧
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎨
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎪
⎩
0.003079x3
1x3
2x5−cos3 x6⩾0
0.1017x3
3x3
4−x2
5 cos3 x6⩾0
0.09939(1+x5)x3
1x2
2−cos2 x6⩾0
0.1076(31.5+x5)x3
3x2
4−x2
5 cos2 x6⩾0
x3x4(x5+31.5)−x5[2(x1+5) cos x6+x1x2x5]⩾0
0.2⩽x1⩽0.5,14<⩽x2⩽22,0.35⩽x3⩽0.6
16⩽x4⩽22,5.8⩽x5⩽6.5,0.14⩽x6⩽0.2618
1
2 cosx6

x1x2(1 + x5) + x3x4

1 + 31.5
x5

.
Exercise 10.6 Assume that the corrupted signal is generated from
>> t=0:0.005:5; y=15*exp(-t).*sin(2*t); r=0.3*randn(size(y)); y1=y+r;
Perform de-noising tasks with wavelet transforms and compare the results with the
ﬁltering techniques in Exercise 8.22.
Exercise 10.7 A series of experimental data is given in ﬁle c10rsdat.txt which is made
up as a 60 × 13 table. Each column corresponds to an attribute and the last column is
the decision attribute. Use rough set reduction technique to check which attribute is most
important to the event in the decision.
Exercise 10.8 For the signal f(t) = e−3t sin(t + π/3) + t2 + 3t + 2, ﬁnd the 0.2th order
derivative and 0.7th order integral. Draw the relevant curves.
Exercise 10.9 Design a ﬁlter for Exercise 10.8. The fractional-order derivatives and
integrals can be obtained with the ﬁlter. Compare the results with the ones obtained with
Gr¨unwald–Letnikov method.
Exercise 10.10 Consider a fractional-order linear diﬀerential equation described by [13]
0.8D2.2
t
y(t) + 0.5D0.9
t
y(t) + y(t) = 1, y(0) = y′(0) = y′′(0) = 0.
Solve the solution using numerical method. If one changes the orders of 2.2 and 0.9

566
Scientiﬁc Computing with MATLAB®
respectively to 2 and 1, an approximate integer-order diﬀerential equation can be obtained.
Compare the accuracy of the integer-order approximation.
Exercise 10.11 Find the closed-loop model from the typical negative feedback structure.
(i) G(s)=
211.87s + 317.64
(s+20)(s+94.34)(s+0.17), Gc(s)= 169.6s+400
s(s + 4)
, H(s)=
1
0.01s + 1,
(ii) G(s)=
s0.4 + 5
s3.1+2.8s2.2+1.5s0.8+4, Gc(s)=3+2.5s−0.5+1.4s0.8, H(s)=1.
Exercise 10.12 Consider the linear fractional-order diﬀerential equation given by
Dx(t) +

9
1 + 2λ
α
Dαx(t) + x(t) = 1, 0 < α < 1,
where λ = 0.5, α = 0.25. Solve the equation numerically.
Exercise 10.13 Find a good approximation for the modiﬁed Oustaloup’s ﬁlter, to s0.7 and
see which N can best ﬁt the fractional-order diﬀerentiator.
Exercise 10.14 Two ﬁlter approximation approaches are proposed in the chapter on
fractional-order derivatives. Please compare the two ﬁlters for the following fractional-order
system, in frequency and step response ﬁtting.
G(s) =
s + 1
10s3.2 + 185s2.5 + 288s0.7 + 1.
Exercise 10.15 Solve the following nonlinear fractional-order diﬀerential equation with the
block diagram-based algorithm
D2x(t) + D1.455x(t) +

D0.555x(t)
2
+ x3(t) = f(t),
where f(t) is a unit square wave input signal of 1 Hz and the system has zero initial
conditions.
Exercise 10.16 Consider the fractional-order nonlinear diﬀerential equation expressed by
the Simulink model shown in Figure 10.66. Write out the mathematical expression of the
equation and draw the output signal y(t).
1
Out1
Fractional
Int  s^{−0.2}
Fractional
Der  s^0.2
Fractional
Der  s^0.8
Fractional
Der  s^0.6
u[1]^2*sin(abs(u[2]))+u[3]^3
Fcn1
5*sin(u[1]^2+5)
Fcn
Clock
FIGURE 10.66: Simulink model (ﬁle: c10mfode4.mdl).

Topics on Nontraditional Mathematical Branches
567
Exercise 10.17 Solve the well-known Bagley–Torvik fractional-order diﬀerential equation [20]
Ay′′(t) + BD3/2y(t) + Cy(t) = C(t + 1), with y(0) = y′(0) = 1,
and show that the solutions are independent of the constants A, B and C.
Exercise 10.18 Analyze the stability of the closed-loop system, and draw Bode diagram
and closed-loop step response for the following system.
G(s) =
s1.2 + 4s0.8 + 7
8s3.2 + 9s2.8 + 9s2 + 6s1.6 + 5s0.4 + 9,
Gc(s) = 10 +
9
s0.97 + 10s0.98.
Bibliography
[1] Weisstein E W. Goldbach conjecture. From MathWorld — A Wolfram Web Resource.
http://mathworld.wolfram.com/GoldbachConjecture.html
[2] Zadeh L A. Fuzzy sets. Information and Control, 1965, 8:338–353
[3] Pawlak Z. Rough sets — theoretical aspects of reasoning about data. Boston, USA:
Kluwer Academic Pub., 1991
[4] Zhang X F. Research and program development of rough set data analysis system.
Master’s thesis, Northeastern University, 2004. (in Chinese)
[5] Hagan M T, Demuth H B, Beale M H.
Neural network design.
PWS Publishing
Company, 1995
[6] Wang X, Wang H, Wang W H. Principles and applications of artiﬁcial neural networks.
Shenyang: Northeastern University Press, 2000. In Chinese
[7] Goldberg D E.
Genetic algorithms in search, optimization and machine learning.
Reading, MA: Addison-Wesley, 1989
[8] Chipperﬁeld A, Fleming P. Genetic algorithm toolbox user’s guide. Department of
Automatic Control and Systems Engineering, University of Sheﬃeld, 1994
[9] Houck C R, Joines J A, Kay M G. A genetic algorithm for function optimization: a
MATLAB implementation, 1995
[10] Kennedy J, Eberhart R.
Particle swarm optimization.
Proceedings of IEEE
International Conference on Neural Networks. Perth, Australia, 1995, 1942∼1948
[11] Li Z. L´evy PSO. MATLAB Central File ID: #50277
[12] Hilfer R. Applications of fractional calculus in physics. Singapore: World Scientiﬁc,
2000
[13] Podlubny I. Fractional diﬀerential equations. San Diego: Academic Press, 1999
[14] Petr´aˇs I, Podlubny I, O’Leary P. Analogue realization of fractional order controllers.
Fakulta BERG, TU Koˇsice, 2002

568
Scientiﬁc Computing with MATLAB®
[15] Oustaloup A, Levron F, Nanot F, et al.
Frequency band complex non integer
diﬀerentiator: characterization and synthesis.
IEEE Transactions on Circuits and
Systems I: Fundamental Theory and Applications, 2000, 47(1):25–40
[16] Xue D, Zhao C N, Chen Y Q. A modiﬁed approximation method of fractional order
system. Proceedings of IEEE Conference on Mechatronics and Automation. Luoyang,
China, 2006, 1043–1048
[17] Podlubny I.
The Laplace transform method for linear diﬀerential equations of the
fractional order.
Proc. of the 9th International BERG Conference. Kosice, Slovak
Republic (in Slovak), 1997, 119–119
[18] Podlubny I. Fractional-order systems and PIλDμ-controllers. IEEE Transactions on
Automatic Control, 1999, 44(1):208–214
[19] Xue D, Chen Y Q. System simulation techniques with MATLAB/Simulink. London:
Wiley, 2013
[20] Cachan J, Groningen F, Paris B. The analysis of fractional diﬀerential equations. New
York: Springer, 2010
[21] Monje C A, Chen Y Q, Vinagre B M, Xue D, Feliu V. Fractional-order systems and
controls — fundamentals and applications. London: Springer, 2010
[22] Xue D Y, Chen Y Q. Modeling, analysis and design of control systems in MATLAB
and Simulink. Singapore: World Scientiﬁc Press, 2014
[23] The MathWorks Inc. Fuzzy logic toolbox user’s manual, 2007


