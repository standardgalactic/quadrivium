Answering Queries
Using Views
Foto Afrati
Rada Chirkova
H.V. Jagadish, Series Editor


Answering Queries Using Views


Synthesis Lectures on Data
Management
Editor
H.V. Jagadish, University of Michigan
Founding Editor
M. Tamer Özsu, University of Waterloo
Synthesis Lectures on Data Management is edited by H.V. Jagadish of the University of Michigan.
The series publishes 80–150 page publications on topics pertaining to data management. Topics
include query languages, database system architectures, transaction management, data
warehousing, XML and databases, data stream systems, wide scale data distribution, multimedia
data management, data mining, and related subjects.
Answering Queries Using Views
Foto Afrati and Rada Chirkova
2017
Databases on Modern Hardware: How to Stop Underutilization and Love Multicores
Anatasia Ailamaki, Erieta Liarou, Pınar Tözün, Danica Porobic, and Iraklis Psaroudakis
2017
Instant Recovery with Write-Ahead Logging: Page Repair, System Restart, Media
Restore, and System Failover, Second Edition
Goetz Graefe, Wey Guy, and Caetano Sauer
2016
Generating Plans from Proofs: The Interpolation-based Approach to Query
Reformulation
Michael Benedikt, Julien Leblay, Balder ten Cate, and Efthymia Tsamoura
2016
Veracity of Data: From Truth Discovery Computation Algorithms to Models of
Misinformation Dynamics
Laure Berti-Équille and Javier Borge-Holthoefer
2015

iv
Datalog and Logic Databases
Sergio Greco and Cristina Molinaro
2015
Big Data Integration
Xin Luna Dong and Divesh Srivastava
2015
Instant Recovery with Write-Ahead Logging: Page Repair, System Restart, and Media
Restore
Goetz Graefe, Wey Guy, and Caetano Sauer
2014
Similarity Joins in Relational Database Systems
Nikolaus Augsten and Michael H. Böhlen
2013
Information and Inﬂuence Propagation in Social Networks
Wei Chen, Laks V.S. Lakshmanan, and Carlos Castillo
2013
Data Cleaning: A Practical Perspective
Venkatesh Ganti and Anish Das Sarma
2013
Data Processing on FPGAs
Jens Teubner and Louis Woods
2013
Perspectives on Business Intelligence
Raymond T. Ng, Patricia C. Arocena, Denilson Barbosa, Giuseppe Carenini, Luiz Gomes, Jr.,
Stephan Jou, Rock Anthony Leung, Evangelos Milios, Renée J. Miller, John Mylopoulos, Rachel
A. Pottinger, Frank Tompa, and Eric Yu
2013
Semantics Empowered Web 3.0: Managing Enterprise, Social, Sensor, and Cloud-based
Data and Services for Advanced Applications
Amit Sheth and Krishnaprasad Thirunarayan
2012
Data Management in the Cloud: Challenges and Opportunities
Divyakant Agrawal, Sudipto Das, and Amr El Abbadi
2012
Query Processing over Uncertain Databases
Lei Chen and Xiang Lian
2012

v
Foundations of Data Quality Management
Wenfei Fan and Floris Geerts
2012
Incomplete Data and Data Dependencies in Relational Databases
Sergio Greco, Cristian Molinaro, and Francesca Spezzano
2012
Business Processes: A Database Perspective
Daniel Deutch and Tova Milo
2012
Data Protection from Insider Threats
Elisa Bertino
2012
Deep Web Query Interface Understanding and Integration
Eduard C. Dragut, Weiyi Meng, and Clement T. Yu
2012
P2P Techniques for Decentralized Applications
Esther Pacitti, Reza Akbarinia, and Manal El-Dick
2012
Query Answer Authentication
HweeHwa Pang and Kian-Lee Tan
2012
Declarative Networking
Boon Thau Loo and Wenchao Zhou
2012
Full-Text (Substring) Indexes in External Memory
Marina Barsky, Ulrike Stege, and Alex Thomo
2011
Spatial Data Management
Nikos Mamoulis
2011
Database Repairing and Consistent Query Answering
Leopoldo Bertossi
2011
Managing Event Information: Modeling, Retrieval, and Applications
Amarnath Gupta and Ramesh Jain
2011

vi
Fundamentals of Physical Design and Query Compilation
David Toman and Grant Weddell
2011
Methods for Mining and Summarizing Text Conversations
Giuseppe Carenini, Gabriel Murray, and Raymond Ng
2011
Probabilistic Databases
Dan Suciu, Dan Olteanu, Christopher Ré, and Christoph Koch
2011
Peer-to-Peer Data Management
Karl Aberer
2011
Probabilistic Ranking Techniques in Relational Databases
Ihab F. Ilyas and Mohamed A. Soliman
2011
Uncertain Schema Matching
Avigdor Gal
2011
Fundamentals of Object Databases: Object-Oriented and Object-Relational Design
Suzanne W. Dietrich and Susan D. Urban
2010
Advanced Metasearch Engine Technology
Weiyi Meng and Clement T. Yu
2010
Web Page Recommendation Models: Theory and Algorithms
Sule Gündüz-Ögüdücü
2010
Multidimensional Databases and Data Warehousing
Christian S. Jensen, Torben Bach Pedersen, and Christian Thomsen
2010
Database Replication
Bettina Kemme, Ricardo Jimenez-Peris, and Marta Patino-Martinez
2010
Relational and XML Data Exchange
Marcelo Arenas, Pablo Barcelo, Leonid Libkin, and Filip Murlak
2010

User-Centered Data Management
Tiziana Catarci, Alan Dix, Stephen Kimani, and Giuseppe Santucci
2010
Data Stream Management
Lukasz Golab and M. Tamer Özsu
2010
Access Control in Data Management Systems
Elena Ferrari
2010
An Introduction to Duplicate Detection
Felix Naumann and Melanie Herschel
2010
Privacy-Preserving Data Publishing: An Overview
Raymond Chi-Wing Wong and Ada Wai-Chee Fu
2010
Keyword Search in Databases
Jeﬀrey Xu Yu, Lu Qin, and Lijun Chang
2009

viii
Copyright © 2018 by Morgan & Claypool
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in
any form or by any means—electronic, mechanical, photocopy, recording, or any other except for brief quotations
in printed reviews, without the prior permission of the publisher.
Answering Queries Using Views
Foto Afrati and Rada Chirkova
www.morganclaypool.com
ISBN: 9781681730318
paperback
ISBN: 9781681730325
ebook
DOI 10.2200/S00805ED1V01Y201709DTM046
A Publication in the Morgan & Claypool Publishers series
SYNTHESIS LECTURES ON DATA MANAGEMENT
Lecture #46
Series Editor: H.V. Jagadish, University of Michigan
Founding Editor: M. Tamer Özsu, University of Waterloo
Series ISSN
Print 2153-5418
Electronic 2153-5426

Answering Queries Using Views
Foto Afrati
National Technical University of Athens
Rada Chirkova
North Carolina State University
SYNTHESIS LECTURES ON DATA MANAGEMENT #46
C
M
&
cLaypool
Morgan
publishers
&

ABSTRACT
The topic of using views to answer queries has been popular for a few decades now, as it cuts
across domains such as query optimization, information integration, data warehousing, website
design, and, recently, database-as-a-service and data placement in cloud systems.
This book assembles foundational work on answering queries using views in a self-
contained manner, with an eﬀort to choose material that constitutes the backbone of the re-
search. It presents eﬃcient algorithms and covers the following problems: query containment;
rewriting queries using views in various logical languages; equivalent rewritings and maximally
contained rewritings; and computing certain answers in the data-integration and data-exchange
settings. Query languages that are considered are fragments of SQL, in particular, select-project-
join queries, also called conjunctive queries (with or without arithmetic comparisons or nega-
tion), and aggregate SQL queries.
KEYWORDS
conjunctive queries, aggregate queries, arithmetic comparisons, negation, acyclic
queries, query containment, query equivalence, equivalent query rewritings,
maximally contained query rewritings, tuple-generating dependencies, equality-
generating dependencies, the chase algorithm query containment and rewriting un-
der dependencies, data exchange, determinacy

xi
Contents
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix
1
Queries and Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1
Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2
Using Views in Database Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2.1 Views and Use Cases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2.2 Views and Technical Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3
Answering Queries Using Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.1 Producing All the Answers—Equivalent Rewritings. . . . . . . . . . . . . . . . 5
1.3.2 Producing a Subset of the Answers—Contained Rewritings . . . . . . . . . 7
1.3.3 Data Exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.4
Relational Databases and Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.4.1 Conjunctive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.4.2 Conjunctive Queries with Arithmetic Comparisons (CQAC) . . . . . . . 13
1.4.3 Conjunctive Queries with Negation (CQN) . . . . . . . . . . . . . . . . . . . . . 14
1.4.4 Unions of Conjunctive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.4.5 Conjunctive Queries with Aggregation (CQA) . . . . . . . . . . . . . . . . . . . 15
1.5
The Structure of the Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.6
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
2
Query Containment and Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.1
CQ Query Containment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.1.1 Containment Mapping and Homomorphisms: Canonical Database . . 22
2.1.2 Query Evaluation vs. Query Containment . . . . . . . . . . . . . . . . . . . . . . 24
2.2
CQAC Query Containment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.2.1 Multiple Containment Mappings and Normalization: Set of
Canonical Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
2.2.2 When Normalization is not Needed . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.2.3 When Single Mapping Suﬃces–the Homomorphism Property:
AC-canonical Databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

xii
2.3
CQN Query Containment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
2.3.1 Set of Canonical Databases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
2.4
CQA Query Containment and Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.4.1 MAX Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
2.4.2 SUM Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
2.4.3 More General Aggregate Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
2.5
Acyclic CQs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
2.5.1 Deﬁnition of Acyclic Queries and Special Cases . . . . . . . . . . . . . . . . . . 46
2.5.2 Eﬃcient Algorithm for Checking Query Containment . . . . . . . . . . . . 49
2.5.3 Eﬃcient Algorithm for Query Evaluation . . . . . . . . . . . . . . . . . . . . . . . 51
2.6
Query Equivalence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
2.7
Containment and Equivalence for Unions of Queries . . . . . . . . . . . . . . . . . . . 55
2.8
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
3
Finding Equivalent Rewritings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
3.1
Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
3.1.1 Expansion of a Rewriting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.1.2 Contained Rewritings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
3.2
CQ Queries and Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.2.1 Canonical Rewritings and the Naive Algorithm . . . . . . . . . . . . . . . . . . 65
3.2.2 Properties of the Expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
3.2.3 Algorithm CoreCover . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
3.3
Acyclic CQ Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
3.4
CQAC Queries and Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
3.4.1 Algorithms for Finding Equivalent Rewritings for Queries and
Views with ACs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
3.4.2 When the Homomorphism Property Holds . . . . . . . . . . . . . . . . . . . . . 75
3.5
Rewriting CQN Queries using CQN Views . . . . . . . . . . . . . . . . . . . . . . . . . . 77
3.6
CQA Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
3.6.1 Unfoldings of Rewritings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
3.6.2 Equivalence of Unfoldings and Rewritings . . . . . . . . . . . . . . . . . . . . . . 81
3.6.3 Constructing Central Rewritings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
3.6.4 Non-central Rewritings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
3.7
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87

xiii
4
Maximally Contained Rewritings (MCRs) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.1
Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.1.1 CQAC Queries and Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
4.2
Finding MCRs for CQ Queries and Views: The MS Algorithm. . . . . . . . . . . 95
4.2.1 Finding MCDs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
4.2.2 Property of MCDs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.2.3 Combining MCDs—Most Relaxed Rewriting . . . . . . . . . . . . . . . . . . 100
4.3
CQACs, the Homomorphism Property, Extending Algorithm MS . . . . . . . 102
4.3.1 Exportable and Distinguishable Variables of an Expansion . . . . . . . . 104
4.3.2 AC-MCDs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
4.3.3 Combining AC-MCDs and MCDs, and Adding ACs . . . . . . . . . . . . 108
4.4
Datalog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
4.4.1 Deﬁnition of the Datalog Language. . . . . . . . . . . . . . . . . . . . . . . . . . . 111
4.4.2 Views that are Unions of CQs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
4.4.3 Rewriting Datalog Queries–the Inverse-rule Algorithm . . . . . . . . . . . 114
4.4.4 CQAC-SI Queries and Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
4.5
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
5
Answering Queries in Presence of Dependencies . . . . . . . . . . . . . . . . . . . . . . . 125
5.1
Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
5.1.1 The Chase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
5.1.2 Weakly Acyclic Sets of Tgds. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
5.1.3 Property of the Chase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
5.2
Query Containment under Dependencies. . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
5.3
Equivalent Rewritings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
5.3.1 Algorithm for CQ Queries, Views, and Rewritings . . . . . . . . . . . . . . 133
5.3.2 Finding Equivalent Rewritings for Weakly Acyclic LAV
Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
5.4
MCRs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
5.4.1 Functional Dependencies Need Recursion . . . . . . . . . . . . . . . . . . . . . . 137
5.4.2 Inverse-rule Algorithm for Finding MCRs in Presence of Egds. . . . . 139
5.5
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
6
Answering Queries in Data Exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
6.1
Complete Data Exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
6.2
Data Exchange with Arithmetic Comparisons . . . . . . . . . . . . . . . . . . . . . . . . 146
6.2.1 Dependencies with Arithmetic Comparisons . . . . . . . . . . . . . . . . . . . 147

xiv
6.2.2 The AC-chase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
6.2.3 Solutions and Universal Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
6.2.4 Solutions and Conjunctive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
6.2.5 Query Answering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
6.2.6 When the Homomorphism Property Holds—Preliminaries . . . . . . . 158
6.2.7 Succinct AC-chase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
6.2.8 Computing Certain Answers Using Succinct AC-chase . . . . . . . . . . . 164
6.3
Incomplete Data Exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
6.3.1 Incomplete Instances. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
6.3.2 The IDE Setting and the Corresponding CDE Settings . . . . . . . . . . 168
6.3.3 Computing Certain Answers in IDE Settings . . . . . . . . . . . . . . . . . . . 169
6.4
Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
7
Answering Queries Using Views . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
7.1
Certain Answers for Queries in Presence of View Instances . . . . . . . . . . . . . 173
7.1.1 Closed vs. Open World Assumption . . . . . . . . . . . . . . . . . . . . . . . . . . 173
7.1.2 Certain Answers vs. MCRs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
7.2
Determinacy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.2.1 Deﬁnitions and Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.2.2 Path Queries—Single View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
7.2.3 Path Queries—CQ is Almost Complete for Rewriting. . . . . . . . . . . . 181
7.2.4 Chain Queries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
8
Bibliographical Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
8.1
Query Containment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.1.1 Query Containment—Set Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . 190
8.1.2 Query Containment—Bag Semantics, Aggregation . . . . . . . . . . . . . . 191
8.1.3 Acyclicity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
8.2
Query Rewriting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
8.2.1 Binding Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
8.3
Dependencies—The Chase. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
8.4
Data Exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
8.5
Other Related Work. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
8.5.1 Determinacy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
8.5.2 More Recent Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197

xv
9
Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
Authors’ Biographies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215


xvii
Preface
Views are used in various scenarios; some of the view-based settings have been considered in
depth by the research community. The settings that we cover in this book include the following.
1. The problem of rewriting queries using views, where a set of views and a set of queries are
given, and we need to ﬁnd equivalent rewritings (if they exist) of the queries using these
views.
2. Sometimes we cannot ﬁnd equivalent rewritings but can still compute a signiﬁcant part of
the answer to the query. This gives rise to the problems of computing certain answers and
of ﬁnding maximally contained query rewritings.
3. The picture of ﬁnding rewritings changes when we assume that the data satisfy certain
constraints (dependencies). We re-examine the problem of ﬁnding rewritings for the set-
ting in which the constraints are tuple-generating dependencies and equality-generating
dependencies.
4. A closely related topic based on the same theoretical foundations is the data-exchange
setting. We deﬁne the concept of certain answers and present algorithms to ﬁnd them.
5. Some theoretical aspects of the more general problem of answering queries using views
have also been investigated in more general and abstract settings, such as determining the
(query) language fragments for which there are rewritings in the cases where the queries
are determined by the views.
In order to solve problems in the above settings, we need technical tools. Thus, we provide
detailed treatments of some tools, including conjunctive-query containment (with and without
arithmetic comparisons and negation), the chase algorithm for reasoning about dependencies,
and going beyond nonrecursive languages to ﬁnd rewritings, with a discussion of Datalog.
What the book is not about: This book is not about indexes or data structures that imple-
ment the techniques considered in the exposition. Instead, this books focuses on the formal-logic
perspective on the topic.
The book is written in a linear way, in the sense that each chapter depends on all the
previous chapters. We have made every eﬀort for the book to be self-contained, thus there are no
substantial prerequisites. A reader familiar with the basics of the theory of database systems and
knowledge of logic will move faster through the chapters. Exercises are included. More exercises,

xviii
PREFACE
including online exercises, and any supplementary material will be found on the website1 of the
book.
Foto Afrati and Rada Chirkova
October 2017
1bit.ly/2zMYBHf

xix
Acknowledgments
Rachel Pottinger kindly reviewed this book and provided constructive comments. JeﬀUllman
contributed immensely in an elegant and concise way in the improvement of this book. We
acknowledge here his many comments that have greatly improved and enhanced the text.
Foto Afrati and Rada Chirkova
October 2017


1
C H A P T E R
1
Queries and Views
In this chapter, we ﬁrst introduce the topic that we discuss in this book by presenting some
application scenarios that hint at the technical issues to which they give rise (Section 1.2). An
informal discussion follows about speciﬁc technical problems in answering queries using views
with concrete examples (Section 1.3). Then, for completeness and consistency of notation, we
give formal deﬁnitions for the relational data model and query languages (Section 1.4). We
conclude the chapter with an outline of the structure of the book.
This is the only chapter of the book that is structured so that it can be read in a nonlinear
way. Section 1.4 is the only part of this chapter that is a prerequisite for the rest of the book
and is independent of the rest of the sections in this chapter. The other sections oﬀer motivation
for studying the topic and a few examples to introduce the main idea of answering queries
using views and introduce the notion of “query rewriting.” The already motivated reader and
those familiar with such concepts can skip those sections. For the readers who ﬁrst introduce
themselves to the topic of views, Section 1.3 can be read before or after Section 1.4 depending
on their level of familiarity with the notation. For readers that are not familiar with SQL, they
can skip safely the SQL part in Section 1.3 and, depending on their familiarity with the notation
of conjunctive query as a rule, they may read Section 1.3 before or after Section 1.4. For readers
that are familiar with SQL but not the rule-notation of conjunctive queries, Section 1.3 can also
serve as a smooth introduction to how the two notations relate to each other.
1.1
VIEWS
A view is a query on a database. However, what we understand by “view” may not be the same
as a query when it comes to its functionality in a database system. For example, a view may not
be submitted by a user, hence its output is not necessarily forwarded to a user who requested
this information, but is stored for future use. Also, a view may not be physically stored at all, but
used to enable users to form simpler queries. In the ﬁrst case, we refer to it as materialized view,
and in the second case we say that it is a virtual view.
When we use a CREATE statement in SQL, what we actually deﬁne can be seen as a
virtual view, which, in turn, is treated in queries as if it were a physically stored base table. The
database-management system maintains the deﬁnition of the view, unless it is explicitly changed.
When views are used in a query, then the tuples of the actually physically stored relations are
called to compute the output of the views, as per their deﬁnition.

2
1. QUERIES AND VIEWS
Materialized views are physically stored. Thus, they may serve the purpose of speeding up
the computation of queries, by providing parts of the query that are already precomputed and
stored.
In the next two sections, we present examples of views and how they play a role in some
query-answering scenarios. SQL queries use the Datalog rule syntax in this book. This is the
only chapter that contains references to SQL queries, for the sake of those readers who want
to see how their familiar SQL queries can be expressed in the Datalog-rule syntax that we use
throughout the book.
1.2
USING VIEWS IN DATABASE SYSTEMS
We now mention some use cases, invoking application scenarios where views come to be use-
ful, and then we mention some technical problems that arise from these scenarios. In the next
section, we will give concrete examples in SQL for the notions we mention here.
1.2.1
VIEWS AND USE CASES
We mention some application scenarios to see the role of views in database systems. Later in
this chapter we will also give some concrete examples around these scenarios.
• Query optimization: We can signiﬁcantly speed up query processing if we have precom-
puted some part of the query in the form of views. Many queries may share common sub-
queries, which, if identiﬁed, can be precomputed as views and save a lot of “duplicated”
computation (indexed views).
• Data integration: Using views to address data-integration problems is a popular technique.
In that, we have two approaches: (a) views describe a set of autonomous heterogenous
data sources and are deﬁned over a global mediated schema, over which the query is also
deﬁned. This is known as the local as view (LAV) approach. In this case, query processing
needs to rewrite the query ﬁrst—as we will be explaining later; (b) views represent the
global schema over which the query is deﬁned, while the views themselves are deﬁned
over the data sources. This is known as the global as view (GAV) approach. In this case,
query processing is straightforward.
• Data exchange: When we have heterogenous sources, we often want to transform data
structured under a schema into data structured under another schema (they are called source
and target schemas, respectively). The transformation is deﬁned by an expression written
in a particular language, pretty much as a view is deﬁned, only more general (therefore it is
referred to as the GLAV approach—incorporating both the LAV and GAV approaches).
The goal is again to materialize data under the target schema that satisfy the relationship
between the schemas, with the purpose of being used to answer queries posed over the

1.2. USING VIEWS IN DATABASE SYSTEMS
3
target schema. However, only the information in the data of the source schema should be
used to provide these answers.
• Data warehousing: A data warehouse stores data for the purpose of reporting and data
analysis. Data warehouses are repositories of integrated data that come from various
sources (that can be thought of as views). They serve two main types of queries, Online
Analytical Processing (OLAP) and Online Transaction Processing (OLTP).
OLAP is characterized by a relatively low volume of transactions; queries are complex and
use aggregation. The OLAP approach is used to analyze multidimensional data (often in
star databases) from many sources.
OLTP is characterized by a large number of short online transactions (INSERT, UP-
DATE, DELETE).
1.2.2
VIEWS AND TECHNICAL ISSUES
For the scenarios of Section 1.2.1 to be addressed in a satisfactory way, we need to understand
how to compute a query using a set of views (which we either choose or are given), or, more
generally, how to produce answers to a query that is deﬁned over a schema diﬀerent from the
schema of the data. Further, we need to understand how to select views with the maximum
beneﬁt (e.g., when used to speed up query computation). Here is a list of the main technical
problems that this book will present, together with a discussion of how they arise in the above
scenarios. We will mention them brieﬂy in this section and then, in Section 1.3, we will give
concrete SQL examples, which will enlighten some technical points that we do not mention in
any detail below.
• Computing certain answers using views in the LAV setting. The concept of “certain an-
swers” is often used when there are not any equivalent rewritings. Then, intuitively, ﬁnding
the certain answers is the best we can do. Their high-level deﬁnition (which will be made
formal in later chapters in the book) is as follows: We are given view deﬁnitions for views
in V and a query deﬁnition for query Q, with all the deﬁnitions over the same database
schema. We are also given data in a database V.D/, where V.D/ is the result of com-
puting the views on D. There exists also a database D over the schema of the query and
view deﬁnitions, but we do not know what D is. All we know is that D is some database
such that when we apply the view deﬁnitions, we get the local database V.D/ that we can
access. Now we want to ﬁnd as many answers as possible to the query computed on D,
but having access only to V.D/. The answers that are desirable to be found this way are
called certain answers. Certain answers capture the intuition that we want to include in
our result those answers that have the following property: No matter what D is, as long as
we can construct V.D/ from it using the view deﬁnitions, the certain answers will be in
Q.D/. The application scenarios include data integration and data warehousing (here all

4
1. QUERIES AND VIEWS
the answers are desirable, but if we cannot ﬁnd them all, then we have to settle for only
the certain answers).
• Computing certain answers using views in the data-exchange (GLAV) setting. Here, we
are given a data-exchange transformation from the source schema to the target schema.
Given any database on the source schema, we want to ﬁnd a database (possibly incomplete)
on the target schema that, for, any query Q, can be used to derive as many answers as
possible among those that the query Q would have derived on the source schema. The
application scenarios include all applications of data exchange and in general, applications
of interoperability in businesses.
• Equivalent rewritings. We are given view deﬁnitions and a query deﬁnition, all the deﬁ-
nitions being over the same database schema. We want to ﬁnd another query, which now
is over the schema of the views (i.e., it uses only the views as the basic database relations),
such that the resulting query is equivalent to the given query. The constructed query is
called an equivalent rewriting. The equivalent rewriting and the original query are equiv-
alent in the following sense: We compute the views over the original database (on the
schema of the views and the query) D, to get database V.D/. Now equivalence of the
rewriting and of the original query means that when we compute the query on D, we get
the same set of answers as the answers of the rewriting over V.D/; and, of course, we want
that to happen for every database D. The application scenarios include query optimization
and data warehouses.
• Maximally contained rewritings (MCRs). The setting is the same as that for producing
certain answers. However, now we try to ﬁnd a rewriting that gives the certain answers,
or at least most of them. One reason for looking for MCRs is because the complexity
of computing a query in one of the common database languages is often lower than the
complexity of computing all certain answers.
1.3
ANSWERING QUERIES USING VIEWS
We compute a query QV on a database D, and then store (i.e., materialize) the answer V.D/ D
QV .D/ for future use. We may not have access to database D after that (for various reasons,
e.g., D is too large to access eﬃciently). Thus, if we have another query Q on the schema of
D that requires the data in D to be computed, we want to ﬁgure out how we can compute Q
using the data in V.D/. As an example, suppose D is a directed graph, i.e., its schema is a single
binary relation, and suppose QV is asking for all paths of length 2 in the graph. Now, if query Q
wants to compute all paths of length 4, it can use V.D/ to compute all the answers that would
have been computed if D were available (no answers are lost). If, however, Q asks for all paths
of length either 2 or 3, then only a portion of the answers can be computed using V.D/. Thus,
we have essentially two problems to look at: either how to produce the same set of answers using

1.3. ANSWERING QUERIES USING VIEWS
5
the views (i.e., V.D/), or “do our best” and produce a subset of the answers. Let us look at these
two problems in a little more detail here. We begin with a motivating example to explain the
notions of certain answers, equivalent rewritings, and maximally contained rewritings.
In the examples, when we deﬁne the queries, we use both the Datalog rule syntax of a
conjunctive query that we deﬁne formally in the next section, and the equivalent deﬁnition in
SQL.
Example 1.1
Let us take two conjunctive queries deﬁned as follows:
Q1 W q1.ename/ :- Employee.eID; addr; tel; zip; ename/; Dept.‘Toy0; eID/;
which is equivalent to the following SQL query:
SELECT ename FROM Employee, Dept
WHERE Employee.eID=Dept.eID AND dname='Toy'.
Query Q1 asks for the names of the
employees that work in the Toy department.
Q2 W q2.ename/ :- Employee.eID; addr; tel; zip; ename/; Dept.‘Toy0; eID/; zip ¤ 94304:
This query is equivalent to the following SQL query: SELECT ename FROM Employee, Dept
WHERE Employee.eID=Dept.eID AND dname='Toy' AND zip<>94304. Query Q2 asks for
the names of the employees that work in the Toy department, except for those whose zip code
is 94304.
Now we consider two views deﬁned as follows:
V1 W v1.ename; eID/ :- Employee.eID; addr; tel; zip; ename/; zip ¤ 94304;
which is equivalent to the following SQL query:
SELECT ename, eID FROM Employee
WHERE zip<>94304. View V1 returns a binary relation that consists of the tuples that associate
with each eID the corresponding name of this employee, but only for those employees whose
zip¤ 94304.
V2 W v2.dname; eID/ :- Dept.dname; eID/;
which is equivalent to the following SQL query:
SELECT dname, eID FROM Dept.
View
V2 returns a binary relation that consists of all the tuples of relation Dept.
We are going to argue that the views V1 and V2 can be used to produce all the answers to
query Q2, but this is not the case for query Q1. However, the view answers can still be used to
produce some (but not all) answers for query Q1.
1.3.1
PRODUCING ALL THE ANSWERS—EQUIVALENT REWRITINGS
Creating an equivalent rewriting is a way to produce all the answers to a query.
Deﬁnition 1.2
(Equivalent rewritings)
Given a query Q and a set of views V, a query P is an equivalent rewriting of the query Q using

6
1. QUERIES AND VIEWS
V if P uses only the views in V, and for any database D on the schema of the base relations, we
have that P.V.D// D Q.D/, where V.D/ is the database computed by evaluating the views in
V on D.
Let us see how it works for the views and queries of Example 1.1.
Example 1.3
We refer to the queries and views of Example 1.1. Let us take the following
rewriting:
R W r.ename/ :- v1.ename; eID/; v2.dname; eID/;
which in SQL is:
SELECT ename
FROM
v1, v2
WHERE
v1.eID = v2.eID
Now let us consider a concrete database instance, the one shown in Figures 1.1 and 1.2. Let
us ﬁnd answers to the queries on this database instance. In Figures 1.3a, 1.3b, 1.3c, and 1.3d, we
ﬁnd the results of applying the query Q1, the query Q2, and the views V1 and V2 on the instance
of the database in Figures 1.1 and 1.2.
Employee:
eID
addr
tel
zip
ename
13
82 Main St
450
94305
Andrew
54
12 Alton Ave
300
94304
John
45
14 Main Ave
314
94304
George
Figure 1.1: Database instance: relation employee.
Dept:
dname eID
Toy
13
Toy
54
Books
45
Figure 1.2: Database instance: relation Dept.
Now we apply the rewriting R on the instance of V1 and V2 (that are depicted in Fig-
ures 1.3c and 1.3d); the result in shown in Figure 1.3e.

1.3. ANSWERING QUERIES USING VIEWS
7
Q1:
Q2:
V1:
V2
R:
:
ename
ename
eID
ename
dname
eID
ename
Andrew
Andrew
13
Andrew
Toy
13
Andrew
John
Toy
54
Books
45
(d)
(e)
(c)
(b)
(a)
Figure 1.3: Answers to the queries.
The result of R (Figure 1.3e) is the same as the result of Q2 (Figure 1.3b). We will show
in Chapter 3 (the chapter about equivalent rewritings) that this is not a coincidence: It can be
proved rigorously using Deﬁnition 1.2 that this will be the case for any database instance.
1.3.2
PRODUCING A SUBSET OF THE ANSWERS—CONTAINED
REWRITINGS
Example 1.4
We continue with the same query, views, and data as in Example 1.3. In Fig-
ure 1.3a we see the result of Q1 as applied to the database shown in Figures 1.1 and 1.2.
We observe that the rewriting R from the previous example produces a subset of the
answers of Q2. This is no coincidence either: R will always produce a subset of the answers of
Q2. We will discuss such rewritings in Chapter 4, where we call R a contained rewriting. Those
among the contained rewritings that produce most of the answers to the query will be called
maximally contained rewritings (MCRs) and this is where we focus in Chapter 4.
Thus, the problem that we illustrated in this section is the following: We are given the
deﬁnitions of a query and a set of views (e.g., query Q1 and views V1 and V2 in Example 1.3. We
are given relations that represent the views (we will call it a “view instance”) (e.g., the relations in
Figures 1.3c and 1.3d). We are asked to compute answers to the query.
For contained rewritings, there is a subtlety that does not occur in the case of equivalent
rewritings. Contained rewritings are not necessarily computed on V.D/, i.e., a view instance
that is produced by computing the views on a certain database instance D. It may be required to
be computed on a subset I of V.D/. In other words, we may have two diﬀerent ways to obtain
a view instance I: (1) either construct it from the relations in D in which case I D V.D/ (and
this is what is the case when we do query optimization) (2) or seeing I as the source that resulted
from V.D/ where D does not consist of a single set of given relations but rather diﬀerent such
sets, even in diﬀerent locations, thus we assume I  V.D/ (and this is the case when I is a
description of what you can expect from a source that in data-integration practical scenarios).

8
1. QUERIES AND VIEWS
In the former case (I D V.D/), we say that we consider the closed world assumption (CWA),
while, in the latter case (I  V.D/), we say that we consider the open world assumption (OWA).
We will discuss about CWA and OWA in the beginning of Chapter 4.
We discussed one way to solve the problem of answering queries using views which is
by ﬁnding equivalent and contained rewritings. We will discuss such rewritings and eﬃcient
algorithms to ﬁnd them in Chapters 3, 4, and 5. In Chapter 6, we will take a diﬀerent approach
that we will present below in Section 1.3.3.
Equivalent and contained rewritings depend on the language of the rewriting in addition
to the query and views deﬁnition and the given input database. There is another concept that
we will deﬁne formally in Chapter 7 that is not related to any rewriting; this is the concept of
“certain answers.” Certain answers are not necessarily obtained via rewritings. We will discuss,
in Chapter 7, the relationship between the output of a maximally contained rewriting and the
set of certain answers.
1.3.3
DATA EXCHANGE
We look at the same problem as the one we described in the end of Section 1.3.2, which we
repeat below.
We are given the deﬁnitions of a query and a set of views (e.g., query Q1 and views V1
and V2 in Example 1.3. We are given relations that represent the views (we will call it a “view
instance”) (e.g., the relations in Figures 1.3c and 1.3d). We are asked to compute answers to the
query.
The approach we will discuss in this section is to solve this problem by creating a database
of the relations used in the query and then apply the query on this database to get the answers
to the query. We consider an example.
Example 1.5
We consider queries and views as in Example 1.3. We will use the view instance
given in Figures 1.3c and Figures 1.3d to create relations EmployeeT and DeptT to use in the
place of Employee and Dept to answer the query.
Looking at the database of V1 (see Figures 1.3c) and the deﬁnition of V1, the maximum
we can guess about what tuples the relation EmployeeT could have is in Figure 1.4. In other
words, we know there is a tuple in Employee which has the value 13 in the attribute eID and
the value Andrew in the attribute ename but we do not know anything about the values of the
attributes Addr, tel, and zip. Thus, we represent their values by Nulls, which we call X, Y , and
Z.
Similarly looking at V2 we can guess the whole relation Dept because the deﬁnition of V2
is to copy the relation Dept.
Now we apply both query Q1 on relations Dept and EmployeeT. We get an answer which
is the same as what we see in Figure 1.3e. However, if we apply query Q2 on relations Dept and
EmployeeT, we get the empty set as output, because query Q2 has the additional constraint that

1.4. RELATIONAL DATABASES AND QUERIES
9
EmployeeT:
eID
addr
tel
zip
ename
13
X
Y
Z
Andrew
Figure 1.4: Incomplete database instance: relation EmployeeT.
the zip must not be equal to 94,304. However, in closer inspection of the information we have,
we observe that in the deﬁnition of the view V1 this constraint appears. Thus for the tuple in
Figure 1.4, we may add this additional information on the Null Z since it is known. Hence, we
can also ﬁnd the answer to Q2 to be same as what we see in Figure 1.3e.
This approach is referred to as data exchange. We will discuss this approach to ﬁnding
answers to queries in Chapter 6.
1.4
RELATIONAL DATABASES AND QUERIES
A relation is a named, two-dimensional table of data. Each column of the relation has a distinct
name that is called attribute; and each row of data (called tuple) is a sequence of values of the
attributes of the relation, one value for each attribute. The number of the attributes is the arity of
the relation. A relation schema is a signature of the form r.A1; A2; : : : ; An/ deﬁned by the name
r of the relation, and a sequence of all attributes .A1; A2; : : : ; An/ in the relation. A collection
of tuples over a relation schema is a relation instance. A (relational) database schema, S, is a set of
relational schemas, whereas a (relational) database instance (database, for short) over schema S is
a set of relation instances, one instance for each relation schema in S. We describe a database
instance by listing the tuples appearing in each relation instance of a database, and attaching to
each tuple the name of the relation that the tuple belongs to.
A predicate is naturally associated with a relation over the same signature, in that predicate
Pr.t/ is true for tuple t iﬀt belongs to relation r. In the rest of the book we will refer to relations
and predicates interchangeably, often denoting them by the same symbol.
Example 1.6
Let database D D fr1.a; b/; r2.c; d/g contain two tuples; the tuple .a; b/ in-
cluded in the relation r1, and the tuple .c; d/ included in the relation r2.
Example 1.7
A database T with two relations:
Employee(eID, addr, tel, zip, ename);
Dept(dname, eID).

10
1. QUERIES AND VIEWS
The relation Employee contains data on employees such as ID .eID/, address .addr/, telephone
.tel/, zip code .zip/, employee’s name .ename/. The table Dept stores information concerning
the name of the department .dname/ and the ID of each employee .eID/. Figure 1.5 shows an
instance of the relation/table Employee, and Figure 1.6 shows an instance of the relation/table
Dept.
Employee:
eID
addr
tel
zip
ename
13
82 Main St
450
94305
Andrew
54
12 Alton Ave
300
94304
John
45
14 Main Ave
314
94304
George
Figure 1.5: Database instance: relation Employee.
Dept:
dname eID
Toy
13
Toy
54
Books
45
Figure 1.6: Database instance: relation Dept.
1.4.1
CONJUNCTIVE QUERIES
A database query is a mapping from databases to relations. This mapping is usually speciﬁed by
a logical formula on the schema S of the input database.
A conjunctive query (CQ for short) is a database query given by an ordinary select-project-
join SQL query with equality comparisons. A conjunctive query is deﬁnable by a positive ex-
istential ﬁrst-order formula, with conjunctions as its only Boolean connective, i.e., it has the
following form that produces a set of value vectors for the vector of variables X:
fX W 9Y .X; Y /; where .X; Y / D
^
igi.Xi/g:
Conjunctive queries are usually written as Datalog rules of the form:
Q W q.X/ :- g1.X1/; : : : ; gn.Xn/;
where g1; : : : ; gn are database relation names, X1, : : : , Xn are vectors of variables or constants
and X is a vector of variables. We say that query Q is deﬁned by a rule, where the atom q.X/ is

1.4. RELATIONAL DATABASES AND QUERIES
11
the head of the rule, while the atoms gi.Xi/’s on the right of :- constitute the body of the rule.
Each gi.Xi/ is also called a subgoal. The variables in X are called distinguished or head variables,
whereas the variables in Xi but not in X are called non-distinguished variables. The query is
Boolean (i.e., the output is either true or false) when the head has no variables.
Safe conjunctive queries are those CQs where all the head variables also occur in their body.
We only consider safe conjunctive queries.
The result of a CQ, which is also called answer or output of the CQ, is given by a database
containing a single relation, and is obtained by evaluating the CQ on D. A subgoal gi.Xi/
becomes true if after substituting the variables in Xi we get a tuple in relation gi in D. A con-
junctive query is evaluated on a relational database D by substituting variables in the deﬁnition
of the query by values in D. If, after this substitution, all the subgoals become true, then the
tuple in the head of the deﬁnition/rule is added to the output of the query.
Example 1.8
The following conjunctive query on the schema of the database of Figure 1.5 asks
about the names of the employees with zip code 94303.
A.name/ :- T .eID; addr; tel; 94304; name/:
It is equivalent to the following SQL query:
SELECT DISTINCT name FROM T WHERE zip=94304
The answer to this query is a relation with one attribute in its schema that contains two tuples:
.John/ and .George/.
Example 1.9
The following query lists all the zip-code information:
A.zip/ :- T .eID; addr; tel; zip; name/:
It is equivalent to the following SQL query:
SELECT DISTINCT zip FROM T.
The answer
to this query on the database of Figure 1.5 is the table in Figure 1.7.
Answer:
zip
94305
94304
Figure 1.7

12
1. QUERIES AND VIEWS
Set vs. bag semantics:
What we deﬁned as the output of a conjunctive query above is the most
common deﬁnition that uses the set semantics of CQs. This is what we will use throughout this
book, except when we treat aggregate queries, where we need bag semantics or set-bag semantics.
We will give their deﬁnition in this paragraph.
In set semantics we used variable substitutions to compute a tuple in the output of a query.
However, we may have more than one variable substitutions that give the same tuple as output.
In this case, we can deﬁne bag semantics, for the case where we want to keep count of how many
substitutions give a speciﬁc tuple.1
Here we deﬁne those semantics formally. We ﬁrst deﬁne substitution formally: a substitu-
tion  is a ﬁnite set of the form fX1=Y1; : : : ; Xn=Yng, where each Yi is a variable or a constant,
and X1, : : : , Xn are distinct variables. When Y1; : : : ; Yn are distinct variables,  is called renam-
ing.
Let  D fX1=Y1; : : : ; Xn=Yng be a substitution. Applying  on the body E of a CQ,
denoted as .E/, means that we simultaneously replace each occurrence of Xi in E by Yi (i.e.,
.Xi/ D Yi), for all i D 1; : : : ; n. (We assume that all the variables of E are in the domain of
.) Similarly, when applying  on a CQ Q, denoted as .Q/, we apply  both on the head and
the body of Q.
Given a database instance D (which is either set valued or bag valued), we evaluate CQ
Q on D as follows: for each substitution  of the variables in the body of Q we check whether
all ground facts (that is, tuples without variables) that result from this substitution are in D. If
they are, then this is a valuation of Q on D, and the head of Q under  contributes a tuple to
the multiset (bag) of tuples that is the answer to the query. If the evaluation is done under set
semantics, then we disregard multiplicities and turn the multiset into a set. From this deﬁnition,
notice that there might be multiple valuations giving the same tuple in the head of Q. However,
in set semantics the number of diﬀerent valuations giving the same tuple in the head of Q is not
reﬂected in the answer of the query, since the answer to the query is always a set. On the other
hand, in both bag-set and bag semantics we take into consideration all the valuations.
The diﬀerence between bag-set and set semantics is that under the former, the database
instance is set valued, and under the latter it is bag valued. That is, a relation R can be deﬁned
either as a set of tuples or a multiset (a.k.a. bag) of tuples. In the second case, each tuple from the
core set (of the multiset) has associated with it a multiplicity, which records the number of times
this tuple appears in the multiset. For example, the multiset f.1; 2/; .1; 2/; .2; 3/g has two tuples
in the core set: the tuple .1; 2/ with multiplicity equal to 2, and the tuple .2; 3/ with multiplicity
equal to 1. In a set-valued database, all stored relations are sets; in a bag-valued database, multiset
stored relations are allowed. In query evaluation under bag-set semantics, we allow computation
1In evaluating SQL queries in relational database-management systems, all such possible tuples are computed, and then
deduplication is performed if the query calls for that.

1.4. RELATIONAL DATABASES AND QUERIES
13
of query answers only on set-valued databases, whereas in query evaluation under bag semantics,
bag-valued databases are permitted.
Example 1.10
Consider the same query as in Example 1.9 but computed under bag semantics.
A.zip/ :- T .eID; addr; tel; zip; name/:
The equivalent SQL query is as in Example 1.9, except the word DISTINCT is removed:
SELECT zip FROM T
The answer now, however, gives back a multiset (bag) in Figure 1.8.
Answer:
zip
94305
94304
94304
Figure 1.8
That is, every time an answer is computed, we list it in the table, regardless of the fact that
it was computed using a diﬀerent valuation (a diﬀerent tuple in this simple example). Note that
the database instance in this example is a set, which means that the query answer under bag-set
semantics will be the same as under bag semantics.
1.4.2
CONJUNCTIVE QUERIES WITH ARITHMETIC COMPARISONS
(CQAC)
CQs with arithmetic comparisons are of the following form:
q. NX/ :- g1. NX1/; : : : ; gn. NXn/; C1; : : : ; Cm:
Now we have two diﬀerent kinds of subgoals in the body. The set of relational subgoals called or-
dinary subgoals g1. NX1/; : : : ; gn. NXn/ (as in CQs deﬁned previously), is also known as “regular sub-
goals,” “uninterpreted subgoals,” or “ordinary subgoals.” (2) The set of arithmetic-comparison
subgoals Ci. Each Ci is an arithmetic comparison of the form “A1  A2,” where A1 is a variable
or a constant, and A2 is a variable. If they are variables, they appear in the ordinary subgoals. The
operator “” is ¤, <, , D, >, or . We use the terms “inequality” and “arithmetic comparison,”
or simply “comparison,” interchangeably to denote either of the above operators. In addition,
we make the following assumptions about the arithmetic comparisons.
1. Values for the arguments in the arithmetic comparisons are chosen from an inﬁnite, totally
densely ordered set, such as the rationals or reals.

14
1. QUERIES AND VIEWS
2. The arithmetic comparisons are not contradictory; that is, there exists an instantiation of
the variables such that all the arithmetic comparisons are true.
3. All the comparisons are safe, i.e., each variable in the comparisons appears in some ordinary
subgoal.
We evaluate a CQAC in the same way as we evaluate a CQ, except that we also require
that all the arithmetic-comparison subgoals become true after we substitute values/constants for
variables.
Example 1.11
We refer again to the database instance of Figure 1.5, and pose the query:
A.zip/ :- T .eID; addr; tel; zip; name/; zip > 94304:
This query asks for a list of zip codes that are greater than 94304. The equivalent SQL query is:
SELECT zip FROM T WHERE zip > 94304. The answer to this query appears in Figure 1.9.
Answer:
zip
94305
Figure 1.9
Finally, the following example shows that the picture is diﬀerent if the domain is not
densely ordered.
Example 1.12
Consider the following query:
Q.x/ :- r.x/; x > 5; x < 7; x ¤ 6:
If the domain is the set of integers, then the output of this query is empty on any database
instance. But this is not true if the domain is the set of reals.
1.4.3
CONJUNCTIVE QUERIES WITH NEGATION (CQN)
The general form of a conjunctive query with safe negated subgoals .CQN/ is:
H :- G1 ^ : : : ^ Gn ^ :F1 ^ : : : ^ :Fm;

1.4. RELATIONAL DATABASES AND QUERIES
15
where H is h.X/ and Gi; Fi are of the form gi.X/; fi.X/. The G’s are called positive subgoals,
while the F ’s are called negative subgoals. A CQN is safe if each variable appearing in a negated
subgoal also appears in a positive subgoal. We consider only safe CQNs.
Example 1.13
Suppose we have a database with two binary relations r1 and r2, and in the
database instance, r1 has the tuples f.1; 2/; .2; 3/g and r2 has the tuples f.2; 4/; .4; 5/; .3; 2/g.
Consider the query:
A.X; Y / :- r1.X; Y /; :r2.Y; X/:
The answer to this query is f.1; 2/g, because for the tuple .2; 3/ in r1 there is the tuple .3; 2/ in
r2, which makes the second subgoal, :r2.Y; X/, false. For an equivalent SQL query, we need to
use the NOT EXISTS predicate.
1.4.4
UNIONS OF CONJUNCTIVE QUERIES
A union of CQs (or CQACs or CQNs) is deﬁned by a number of CQs (CQACs, CQNs, re-
spectively) and the output is the union (as a set) of the sets of tuples given in the output of each
of the CQs (CQACs, CQNs, respectively).
Example 1.14
The union of the following two queries
A.zip/ :- T .eID; addr; tel; zip; name/; zip > 94304
A.zip/ :- T .eID; addr; tel; zip; name/; zip D 94304;
when applied to the database shown in Figure 1.5, gives as output the same as the following
query:
A.zip/ :- T .eID; addr; tel; zip; name/:
In general, however, a union of conjunctive queries cannot be equivalently deﬁned by a single
conjunctive query.
1.4.5
CONJUNCTIVE QUERIES WITH AGGREGATION (CQA)
Let us denote the body of a conjunctive query by A. An assignment (a.k.a. substitution)  for A
is a mapping of the variables appearing in A to constants, and of the constants appearing in A
to themselves. Assignments are naturally extended to tuples and atoms.
We assume that the data we want to aggregate are real numbers, R. If S is a set, then
M.S/ denotes the set of ﬁnite multisets over S. A k-ary aggregate function is a function ˛ W
M.Rk/ ! R that maps multisets of k-tuples of real numbers to real numbers. An aggregate
term is an expression built up using variables and aggregate functions. Every aggregate term with
k variables gives rise to a k-ary aggregate function in a natural way.

16
1. QUERIES AND VIEWS
We use ˛.y/ as abstract notation for a unary aggregate term, where y is the variable in
the term. Aggregate queries that we consider have (unary or 0-ary) aggregate functions count,
count./, sum, max, and min. Note that count is over an argument, whereas count./ is the only
function that we consider that takes no argument. (There is a distinction in SQL semantics
between count and count./.) In the remainder of this book, we will not refer again to the dis-
tinction between count and count./, as our results carry over.
An aggregate query is a conjunctive query augmented by an aggregate term in its head. For
a query with a k-ary aggregate function ˛, the syntax is
q.Ns; ˛. Ny//  A :
(1.1)
Here, A is a conjunction of atoms, see deﬁnition of conjunctive queries; ˛. Ny/ is a k-ary aggregate
term; Ns are the grouping attributes of q; none of the variables in Ny appears among Ns. Finally, q is
safe, that is, all the variables in Ns and Ny occur in A. We consider queries with unary aggregate
functions sum, count, max, and min.
Deﬁnition 1.15
With each aggregate query q (Eq. (1.1)) we associate its conjunctive core Mq:
Mq.Ns; Ny/  A :
(1.2)
We deﬁne the semantics of an aggregate query as follows: Let D be a database and q an
aggregate query as in Eq. (1.1). When q is applied on D, it yields a relation q.D/ that is deﬁned
by the following three steps. First, we compute the core Mq of q on D as a bag B. We then form
equivalence classes in B: Two tuples belong to the same equivalence class if they agree on the
values of the grouping arguments of q. This is the grouping step. The third step is aggregation; it
associates with each equivalence class a value that is the aggregate function computed on a bag
that contains all the values of the input argument(s) of the aggregated attribute(s) in this class.
For each class, it returns one tuple, which contains the values of the grouping arguments of q
and the computed aggregated value.
Example 1.16
Consider the aggregate query
Answer.zip; count/ :- T .eID; addr; tel; zip; name/;
which is equivalent to the following SQL query: SELECT zip, COUNT FROM T GROUPBY zip
This query ﬁrst computes a bag, exactly as the query in Example 1.10, because the query in
Example 1.10 is the core of the query in this current example. Then the query counts in the
resulting relation the tuples with each speciﬁc zip code. The ﬁnal answer appears in Figure 1.10.
This answer is correct, because in the answer to the query of Example 1.10, there are two
tuples with zip code 94304, and one tuple with zip code 94305.

1.5. THE STRUCTURE OF THE BOOK
17
Answer:
zip
count
94305
1
94304
2
Figure 1.10
Example 1.17
Consider a database with three relations—relation P that stores transactions,
and relations T and W that store information about store branches, all with self-explanatory
attribute names:
P(storeId, product, salePrice, profit, dayOfSale, monthOfSale, yearOfSale);
T(storeId, storeChain); W(storeId, storeCity).
Suppose a user is interested in the answers to query Q, which gives total sales per prod-
uct per year per city, for all stores. Q can be deﬁned in SQL as follows:
SELECT product, yearOfSale, storeCity, SUM(salePrice) FROM P, W WHERE
P.storeId = W.storeId GROUP BY product, yearOfSale, storeCity;
In Datalog-rule notation:
q.Y; M; U; sum.Z// :- p.X; Y; Z; T; N; L; M/; w.X; U /:
1.5
THE STRUCTURE OF THE BOOK
In this book we want to present, formally and rigorously, algorithms and their technical tools
that are relevant to solving problems related to the topic of answering queries using views. We
focus on presenting eﬃcient algorithms that ﬁnd good (e.g., minimal) rewritings and ﬁnd certain
answers. In terms of computational complexity of the problems we present, the algorithms we
present give upper bounds, for the case of minimization optimization problems. We do not focus
on the complexity analyses, concentrating instead on correctness proofs for the algorithms. The
lower bounds and other related issues are discussed in the bibliographical notes. We also include
exercises, which call for applying the algorithms to concrete inputs, or refer to theoretical results
that can be easily solved by the presented techniques.
Algorithms for ﬁnding rewritings of queries using views are based on whether two queries
give the same answers on any input database, or on whether one gives a subset of the answers of
the other query. These are the problems of query containment (one query gives a subset of the
answers of the other query) and query equivalence (two queries give the same set of answers). In
Chapter 2 we present eﬃcient algorithms that test query containment, using technical tools such
as homomorphisms and containment mappings. (These tools are used throughout the book.) We

18
1. QUERIES AND VIEWS
discuss the relationship between the problems of query containment and query evaluation, as
both use homomorphisms. The algorithms range from simple to more complex, as we add to
CQs extra expressive power by allowing arithmetic comparisons and negation. We introduce the
notion of canonical database, and show how it is used in testing query containment. For con-
junctive queries with arithmetic comparisons, the “homomorphism property” enables simpler
containment tests. Aggregate queries behave diﬀerently due to not belonging to core relational
algebra. Their evaluation depends on bag semantics: as an intermediate step we compute a CQ,
but store the output as a bag. This is the only reason we also discuss bag semantics and bag-set
semantics. We do not refer to them outside the scope of aggregate queries. Finally, some queries
with special structure have simpler algorithms for query containment and evaluation. We discuss
one class of such queries, acyclic queries.
Chapters 3 and 4 discuss eﬃcient algorithms for ﬁnding rewritings of queries using sets of
views: Chapter 3 discusses equivalent rewritings, and Chapter 4 discusses maximally contained
rewritings. The existence of both kinds of rewritings depends on the language of rewritings,
as illustrated with examples. In both chapters, we discuss the central notion of expansion of a
rewriting and examine its properties, which allow for eﬃcient algorithms for ﬁnding rewritings.
Chapter 3 presents eﬃcient algorithms for ﬁnding equivalent rewritings for conjunctive
queries with or without arithmetic comparisons. We also discuss equivalent rewritings for ag-
gregate queries. For equivalent rewritings, the notion of canonical rewriting is central.
Chapter 4 presents eﬃcient algorithms for ﬁnding maximally contained rewritings
(MCRs) for CQs and CQACs with the homomorphism property. It also includes Datalog
queries, and presents the inverse-rule algorithm for ﬁnding MCRs using CQ views. Chapter 4
also discusses cases of nonrecursive queries and views where we need recursion in order to ﬁnd
an MCR. The open-world assumption vs. the closed-world assumption are also discussed in
Chapter 4.
Chapter 5 revisits the problems of the previous three chapters in the presence of constraints
on the data. These constraints are tuple-generating dependencies and equality-generating de-
pendencies. Here we discuss the chase algorithm, and show how it helps in solving such prob-
lems.
Chapter 6 discusses settings where (a) all the answers to a query cannot be derived, and
(b) the deﬁnitions that derive data from a set of base data (this is what views do when they are
computed on base data) are given in more general form than conjunctive queries, speciﬁcally
in the form of tuple-generating dependencies. We deﬁne the notion of certain answers based
on possible worlds, and present algorithms that ﬁnd certain answers. We also present more
expressive tuple-generating dependencies that use arithmetic comparisons. We discuss the chase
algorithm and study conditions for its termination.
The problem of answering queries using views gives rise to questions of theoretical im-
portance, some of them quite challenging. Chapter 7 considers some of these questions, such

1.6. EXERCISES
19
as computing certain answers (which is similar to a special case of the data-exchange problem)
and its relationship with MCRs and determinacy.
Chapter 8 contains bibliographical notes, which in particular point out complexity results
for the problems considered in the book. With the exception of Chapter 8, throughout the book
we do not use citations and do not present hardness results for the problems being discussed.
That is, we oﬀer the algorithms with correctness (and complexity, when necessary) proofs, but
we do not delineate complexity in the main text. The reason for this presentation style is that in
the main text we focus on methods and techniques, as well as on how they are used to discover
algorithms.
1.6
EXERCISES
1.1.
Consider the queries q1 and q2:
q1.X/ :- r.X; Y /; r.Y; X/; r.X; X/; s.X/:
q2.Y / :- r.X; Y /; r.Y; X/; r.X; X/; s.X/:
Compute each of them on the database:
D D fr.1; 1/; s.1/; r.2; 2/; s.2/; r.1; 2/; r.2; 1/g:
1.2.
Consider the query:
q.X1; X2; X3; X4/ :- a.X1; X2; X3; X4/; b.X1; X2; X3/; c.X1; X2/; d.X1/:
Compute this query on the following database:
D D fa.1; 2; 3; 4/; b.1; 2; 3/; c.1; 2/; d.1/; a.1; 2; 2; 4/; b.1; 2; 2/; a.1; 2; 2; 1/g:
1.3.
Consider the query:
q.X1; X2; X3; X4/ :- a.Y; X3; X4/; b.Y; X1; X2/; c.Y; X5/; d.Y; X6/; f .Y /:
Compute this query on the following database:
D D fa.8; 3; 4/; b.8; 1; 2/; c.8; 5/; d.8; 6/; f .8/; a.8; 4; 4/g:
1.4.
Consider the queries q1 and q2:
q1.X/ :- r.X; Y /; r.Y; X/; r.X; X/; s.X/; X < 9:
q2.Y / :- r.X; Y /; r.Y; X/; r.X; X/; s.X/; X < 1:
Compute each of them on the database:
D D fr.1; 1/; s.1/; r.2; 2/; s.2/; r.1; 2/; r.2; 1/g:

20
1. QUERIES AND VIEWS
1.5.
Consider the query:
q.X1; X2; X3; X4/ :- a.X1; X2; X3; X4/; b.X1; X2; X3/; c.X1; X2/; d.X1/; X3 < 3:
Compute this query on the following database:
D D fa.1; 2; 3; 4/; b.1; 2; 3/; c.1; 2/; d.1/; a.1; 2; 2; 4/; b.1; 2; 2/; a.1; 2; 2; 1/g:
1.6.
Consider the query:
q.X1; X2; X3; X4/ :- a.X1; X2; X3; X4/; b.X1; X2; X3/; c.X1; X2/; d.X1/; X2 < X3:
Compute this query on the following database:
D D fa.1; 2; 3; 4/; b.1; 2; 3/; c.1; 2/; d.1/; a.1; 2; 2; 4/; b.1; 2; 2/; a.1; 2; 2; 1/g:

21
C H A P T E R
2
Query Containment and
Equivalence
The problem of rewriting queries using views is closely related to the problem of checking for
query containment or equivalence. For most classes of problems, containment tests enable simple
algorithms to rewrite queries using views. Rewriting queries is one of the techniques that is most
often used to answer queries using views.
In this chapter we discuss containment tests for conjunctive queries (CQs), conjunctive
queries with arithmetic comparisons (CQACs), conjunctive queries with negation (CQNs), and
SQL aggregate queries, which will be written in the notation of conjunctive queries supple-
mented with information about the groupby attributes and the aggregated attribute. We call
queries of the latter type conjunctive queries with aggregation (CQA queries). We will also present
containment tests that are of lower complexity for special cases of these queries.
Deﬁnition 2.1
We say that query Q2 is contained in query Q1, denoted Q2 v Q1, iﬀ, for any
database D, the set of answers to Q2 computed on D is a subset of the set of answers to Q1
computed on D, i.e., Q2.D/  Q1.D/.
We say that two queries Q1 and Q2 are equivalent, denoted Q1  Q2, iﬀeach query is
contained in the other, i.e., Q1 v Q2 and Q2 v Q1.
(It follows from the deﬁnition that Q1  Q2 iﬀfor all databases D we have that Q1.D/ D
Q2.D/.)
As an example, a query Q2 on a binary relation (that can be thought of as a graph) that
computes all paths of length 2 with the path beginning at a node with ID greater than 43 is
contained in query Q1 that computes all paths of length 2. (That is, the query Q1 does not
include the additional restriction that will be represented by the arithmetic comparison > 43—
we will see details of such queries later in this chapter.)
2.1
CQ QUERY CONTAINMENT
To present an algorithm for testing CQ containment, we need to introduce some technical
notions.

22
2. QUERY CONTAINMENT AND EQUIVALENCE
2.1.1
CONTAINMENT MAPPING AND HOMOMORPHISMS:
CANONICAL DATABASE
If r is a relation symbol of arity n, and X0
is take values from domain Dom, then r.X1; : : : ; Xn/
is an atom over domain Dom. A relational structure S is a set of atoms over a domain Dom.S/
of variables and constants. A relational atom without variables among its arguments is called a
ground atom. The body of a conjunctive query is a ﬁnite relational structure. A database instance
(or database) is a ﬁnite relational structure with only ground atoms.
Deﬁnition 2.2
A homomorphism from relational structure S to relational structure S0 is a func-
tion h W Dom.S/ ! Dom.S0/ such that:
If ai is a constant, then h.ai/ D ai, and
If ri.a1; : : : ; ami / is an atom in S, then ri.h.a1/; : : : ; h.ami // is an atom in S0.1
We say that a homomorphism h is one-to-one if, whenever ai ¤ aj, then h.ai/ ¤ h.aj /. We say
that there is an isomorphism between two relational structures iﬀthere is a one-to-one homo-
morphism from one onto the other and vice versa. In such cases, we say that the two structures
are isomorphic. If the isomorphism is from a structure to itself, then we call it automorphism.
The deﬁnition for conjunctive queries is related to a relational structure over the domain
of variables and constants that are used in the deﬁnition. The relational structure related to a CQ
deﬁnition can either be the set of all atoms that appear in the deﬁnition of the query (both head
and body of the query), or just the atoms that appear in the head. We choose what is customary,
by relating a CQ to the relational structure that contains the atoms in its body.
Deﬁnition 2.3
A containment mapping homomorphism h from the relational structure of the
body of Q1 to the relational structure of the body of Q2, which additionally maps the head of
Q1 to the head of Q2. (That is, if q1.X1; : : : ; Xn/ is the head of Q1, then q2.h.X1/; : : : ; h.Xn//
is the head of Q2.)
We will show that a conjunctive query Q2 is contained in another conjunctive query Q1
if and only if there is a containment mapping from Q1 to Q2. An example follows. In the rules
in the example, as in all the rules that we write, the reader can assume that an uppercase letter
represents a variable. A lowercase letter can represent a constant or a predicate name. For the
names of rules, we shall use uppercase letters, typically Q or R.
Example 2.4
Consider queries Q1 and Q2:
Q1 W q1.X; Y / :- a.X; Z1/; b.Z1; Z2/; c.Z2; Y /;
1The standard deﬁnition of homomorphism does not necessarily require that the relation symbol has to be the same in both
structures. For the needs of this book, and as is customary in related literature, this restricted deﬁnition of homomorphism
is suﬃcient.

2.1. CQ QUERY CONTAINMENT
23
Q2 W q2.X0; Y 0/ :- a.X0; Z0
1/; b.Z0
1; Z0
1/; c.Z0
1; Y 0/; a.X0; Y 0/:
A containment mapping from Q1 to Q2 is deﬁned by giving a mapping  from the variables of
Q1 to the variables of Q2. Let us consider the following mapping :
fX ! X0; Y ! Y 0; Z1 ! Z0
1; Z2 ! Z0
1g:
It is indeed a containment mapping, because the variables in the head of Q1 are mapped
position-wise to the variables in the head of Q2, and each subgoal of Q1 is mapped to a subgoal
of Q2 with the same relation symbol. That is, a.X; Z1/ is mapped to a.X0; Z0
1/, b.Z1; Z2/ is
mapped to b.Z0
1; Z0
1/, and c.Z2; Y / is mapped to c.Z0
1; Y 0/. This containment mapping proves
that query Q2 is contained in query Q1. Notice that the subgoal a.X0; Y 0/ of Q2 is not a target
of any subgoal of Q1, i.e., it is not used to verify the containment mapping . In other words,
the subgoal a.X0; Y 0/ can be deleted from Q2, and the containment mapping will still be valid.
These queries have an intuitive meaning on labeled graphs, which explains containment
in an intuitive level as follows: Think of the atoms as representing arcs with labels, so that Q1
in this example is any path from node X to node Y of length 3, labeled by sequence a; b; c.
Query Q2 here is a path from node X0 to node Y 0 of length 3, labeled by sequence a; b; c, which
contains a loop with arc labeled b, and also has an arc labeled a between nodes X0 and Y 0. It is
not hard to show that whenever the latter happens, then the former also happens.
When we evaluate a query on a database, i.e., when we replace variables in the deﬁnition
of the query by values in the database, this is equivalent to ﬁnding a homomorphism from the
body of the query to the database that maps the head of the query deﬁnition to the computed
tuple t. We will refer to such homomorphisms as homomorphism that computes t. We often need
to consider the relational structure of the body of a CQ deﬁnition as a database, i.e., as a result
of replacing all the variables by distinct constants (distinct among themselves and distinct from
the constants already in the query deﬁnition). We call the resulting structure a canonical database
of the CQ, and denote it by DQ. Formally, there are an inﬁnite number of canonical databases,
as it all depends on the choice of the constants we use. At the same time, as all these databases
are isomorphic, we refer from here on to “the” canonical database of a conjunctive query.
We state and prove the CQ containment-test result in the following theorem.
Theorem 2.5
A CQ query Q2 is contained in CQ query Q1 iﬀthere is a containment mapping from
Q1 to Q2.
Proof. For the “if” direction: Suppose there is a containment mapping from Q1 to Q2. A con-
tainment mapping is a homomorphism. When Q2 is evaluated on database D producing a tuple
t, this tuple is produced because of a homomorphism from the body of Q2 to the database. This
homomorphism can be combined with the homomorphism of the given containment mapping,
to produce a homomorphism from the body of Q1 to the database. The latter homomorphism

24
2. QUERY CONTAINMENT AND EQUIVALENCE
will produce the tuple t in the result of evaluating Q1 on the database D. Thus, Q2 is contained
in Q1.
For the “only-if” direction: Suppose Q2 is contained in Q1. Let the database DQ2 be the
canonical database of Q2. Since the tuple in D that corresponds to the head of Q2 is in the
result when we compute Q2 on DQ2, this tuple is also in the result when we compute Q1 on
DQ2. But computing Q1 on DQ2 means there is a homomorphism from the body of Q1 to DQ2.
However, DQ2 is isomorphic to the body of Q2. Hence, this homomorphism is a containment
mapping from Q1 to Q2.

The canonical database is the minimal counterexample if containment is not satisﬁed. This
is stated in the following theorem, which gives an alternative containment test. (We omit the
straightforward proof.)
Theorem 2.6
A CQ query Q2 is contained in CQ query Q1 iﬀQ1 computes its head atom on the
canonical database of Q2.
A containment mapping from Q1 to Q2 is deﬁned by a mapping  from the variables of
Q1 to the variables of Q2. Since it is a homomorphism (and since no atom in the body of a CQ
is duplicated), a containment mapping deﬁnes a unique mapping from all the subgoals of Q1 to
subgoals of Q2 (but not necessarily all the subgoals of Q2). We refer to this as induced subgoal
mapping by . A containment mapping from Q1 to Q2 is called subgoals-onto if its induced
subgoal mapping uses each subgoal of Q2 as the target of some subgoal of Q1. The containment
mapping in Example 2.4 is not subgoals-onto, because the subgoal a.X0; Y 0/ of Q2 is not a
target of any subgoal of Q1 under this mapping.
2.1.2
QUERY EVALUATION VS. QUERY CONTAINMENT
In Section 2.1.1, we already noticed the relationship between query evaluation and query con-
tainment, and saw how they are both based on the existence of homomorphisms. (This is the
ﬁrst hint that conjunctive queries are preserved under homomorphisms.) Actually, the relation-
ship between the two problems is strong, so algorithms for one of the problems can be used for
the other. For one direction, we have already seen how CQ query containment can be tested by
evaluating the containing query on the canonical database of the contained query. (Here and in
the rest of the book wherever clear from the context, we say “contained (containing, respectively)
query” to refer to a query that we hypothesize to be contained in (to contain, respectively) the
other query.)
We illustrate the other direction with an example.
Example 2.7
Suppose that on a database D D fr.1; 2/; r.2; 3/; r.3; 4/g, we would like to know
whether the tuple .1; 3/ is in Q1.D/, where Q1 is the following path query:
Q1.X; Y / :- r.X; Z/; r.Z; Y /:

2.1. CQ QUERY CONTAINMENT
25
We form query Q2 by constructing its subgoals out of the tuples in the database D; the head of
Q2 has the two variables that correspond to .1; 3/:
Q2.X1; X3/ :- r.X1; X2/; r.X2; X3/; r.X3; X4/:
Now, it is easy to check that indeed Q2 is contained in Q1, because there is a containment
mapping from Q1 to Q2. Moreover, since the body of Q2 and the database D are isomorphic,
this containment mapping gives the homomorphism that computes .1; 3/ in Q1.D/.
Preservation of CQs under Homomorphisms
Recall that a database instance is a relational structure that uses only constants, rather than vari-
ables. For database instances, it is useful to deﬁne a slightly diﬀerent notion of homomorphism,
which highlights an interesting property of CQs. (We will not use this deﬁnition of homomor-
phism again in this book, unless very speciﬁcally stated with pointers to the deﬁnition below.
Thus, we do not need to introduce a distinguishing name for it.)
Deﬁnition 2.8
A homomorphism from database D to database D0 is a function h W dom.D/ !
dom.D0/ such that
if .a1; : : : ; ami / 2 ri, then .h.a1/; : : : ; h.ami // 2 ri.
Notice that this deﬁnition does not require constants to map to the same constant as in Deﬁni-
tion 2.2.
Deﬁnition 2.9
Query Q is preserved under homomorphisms if, whenever D and D0 are two
databases and there is a homomorphism h as in Deﬁnition 2.8 from D to D0, we have that
if .a1; : : : ; am/ 2 Q.D/, then .h.a1/; : : : ; h.am// 2 Q.D0/.
We say that D0 is the homomorphic image of D under h, if h is onto and, whenever .a0
1; : : : ; a0
mi / 2
ri, there exists an a1; : : : ; ami such that .a1; : : : ; ami / 2 ri and h.aj / D a0
j ; j D 1; : : : ; mi.
CQs without constants in their deﬁnition are preserved under homomorphisms. The fol-
lowing CQ is not preserved under homomorphisms:
q.X/ :- p.X; Y /; r.Y; 3/:
Indeed, consider databases D D fp.1; 2/; r.2; 3/g and D0 D fp.1; 2/; r.2; 4/g. There is a homo-
morphism from D to D0 as in Deﬁnition 2.8. At the same time, because of the constant 3 in the
deﬁnition of the query, this homomorphism does not enable a computation of the atom q.1/ in
q.D0/ as it does in q.D/.

26
2. QUERY CONTAINMENT AND EQUIVALENCE
We now summarize the two algorithms for CQ query containment.
CQ containment test 1:
Given two conjunctive queries Q1 and Q2, Q2 v Q1 if and only if there
is a containment mapping from Q1 to Q2, such that the mapping maps
each constant to the same constant and maps each variable to either a
variable or a constant. Under this mapping, the head of Q1 becomes
the head of Q2, and each subgoal of Q1 maps to some subgoal of Q2.
CQ containment test 2:
Given two conjunctive queries Q1 and Q2, Q2 v Q1 if and only if Q1
computes its head on the canonical database of Q2.
2.2
CQAC QUERY CONTAINMENT
Recall that we use “CQ” to represent “conjunctive query,” “AC” for “arithmetic comparison,”
and “CQAC” for “conjunctive query with arithmetic comparisons.” We write a CQAC as “Q D
Q0 C ˇ,” where “ˇ” denotes the comparisons of Q, and “Q0” denotes the query obtained by
deleting the comparisons from Q. We say that a set of arithmetic comparisons is consistent if there
is an assignment of values over densely totally ordered domains such that all the comparisons in
the set are true.
Whenever we consider CQAC queries in this book, we assume a densely totally ordered
domain. Before we proceed, consider the following example, which shows that the picture is
diﬀerent if the domain is not densely totally ordered.
Example 2.10
Consider the following query:
Q.X/ :- r.X/; X > 5; X < 7; X ¤ 6:
If the domain is the integers (which is not a densely totally ordered domain), then the output of
Q is empty on any database instance. Thus, the query is contained in all queries. However, over
the reals (which is a densely totally ordered domain), this is not true.
The following query Q0 uses inconsistent arithmetic comparisons. Hence, its output is
empty on any database, independently of the domain being densely totally ordered or not.
Q0.X/ :- r.X/; X > 5; X < 4:
Indeed, consider the database instance D D fr.6:5/g. The output Q.D/ of Q on D is f.6:5/g.
The output Q0.D/ of Q0 on D is empty.

2.2. CQAC QUERY CONTAINMENT
27
2.2.1
MULTIPLE CONTAINMENT MAPPINGS AND NORMALIZATION:
SET OF CANONICAL DATABASES
Deﬁnition 2.11
Let Q1 and Q2 be two conjunctive queries with arithmetic comparisons
(CQACs). We want to test whether Q2 v Q1. To do the testing, we ﬁrst normalize each of
Q1 and Q2 to, respectively, Q0
1 and Q0
2, as follows.
• For each occurrence of a shared variable X in a normal (i.e., relational) subgoal, except for
the ﬁrst occurrence, replace the occurrence of X by a fresh variable Xi, and add X D Xi
to the comparisons of the query; and
• for each constant c in a normal subgoal, replace the constant by a fresh variable Z, and
add Z D c to the comparisons of the query.
Theorem 2.12 below says that Q2 v Q1 iﬀthe comparisons in the normalized version Q0
2
of Q2 logically imply (denoted by “)”) the disjunction of the images of the comparisons of the
normalized version Q0
1 of Q1 under each containment mapping from the normal subgoals of
Q0
1 to the normal subgoals of Q0
2.
Theorem 2.12
Let Q1; Q2 be CQACs, and Q0
1 D Q0
10 C ˇ0
1; Q0
2 D Q0
20 C ˇ0
2 be the respective queries after
normalization. Suppose there is at least one containment mapping from Q0
10 to Q0
20. Let 1; : : : ; k
be all the containment mappings from Q0
10 to Q0
20. Then Q2 v Q1 if and only if the following logical
implication  is true:
 W ˇ0
2 ) 1.ˇ0
1/ _ : : : _ k.ˇ0
1/:
(We refer to  as the containment entailment throughout this book.)
Proof. For the “if” direction: First observe the following: If the containment entailment holds,
then for any assignment of constants to variables in Q2 that computes a tuple, there is at least one
containment mapping i that makes i.ˇ0
1/ true. (Since we are considering constants, the “OR”
in the implication means that one speciﬁc clause becomes true.) Now, if a tuple t is computed
by query Q2 on a database D, there is a homomorphism h from Q0
20 to D that produces t such
that ˇ0
2 is satisﬁed, i.e., all the comparisons in h.ˇ0
2/ are true. However, the homomorphism h
assigns constants to the variables of the containment entailment that makes ˇ0
2 true. Thus, there
is a i such that the same assignment makes i.ˇ0
1/ true. But this assignment is the assignment
of constants to the variables of h ı i. Hence, we can combine i with the homomorphism h
from Q2 to D that produced t, and thus prove that t is computed by the query Q1 as well.
For the “only-if” direction: Suppose Q2 is contained in Q1. Assume database D on which
we compute tuple t in Q1.D/ and in Q2.D/ using homomorphisms h1 and h2 respectively. The
tuples Dt in D we use as targets in h2 make a homomorphic image of Q20. Now, observe that

28
2. QUERY CONTAINMENT AND EQUIVALENCE
any homomorphism form Q10 (actually the homomorphism coulk be from anywhere, but here
we are interested about Q10) to a homomorphic image of Q20 can be produced a) by equating
variables of Q0
10 (the normalized version of Q10) in two ways: ﬁrst we equate variables as the
ACs in ˇ1 imply and then we equate the rest of variables arbitrarily, b) by assigning values to
the targets of the variables that are remaining after applying the equating. An example follows
to illustrate this observation.
Example 2.13
Suppose we have 1:
X ! X0, Y ! Y 0, Z ! Z0, W ! W 0, U ! U 0.
(Observe that since we have normalized there are no variables among the primed versions
which appear more than once in 1.) Suppose ˇ1 D X D Y ^ X  Z. Suppose we have the
homomorphism h:
X ! x0, Z ! z0, W ! z0.
Where x0 and z0 are constants (later we will assume that these constants come from the
values of some database). Then h comes from 1 after a) equating X D Y because this is what
ˇ1 tells, and also choosing arbitrarily to equate W D U . Now, after the equation, 1 becomes:
X ! X0, Z ! Z0, W ! W 0.
Now we assign values to X0; Z0 and W 0: X0 D x0; Z0 D z0; W 0 D z0 and produce h.
Suppose the containment entailment does not hold This, after the above observation,
yields the following: Replace in the containment entailment each variable, say Xj, by h2.Xj /.
Then all the disjuncts become false. Hence, any homomorphism ht from Q10 to Dt is such that
ht.ˇ1/ is not satisﬁed. Hence t cannot be computed in Q1.Dt/, which is a contradiction.

Observe that normalization helps, because we do not miss any containment mappings—
see Examples 2.15 and 2.20 to gain intuition. Also, observe that in Theorem 2.12, the “OR”
operation “_” in the implication is critical, since there might not be a single mapping i from
Q1;0 to Q2;0 such that ˇ2 ) i.ˇ1/. The following example shows that to prove containment,
we need to consider all possible mappings.
Example 2.14
Consider the following queries:
Q1./
:- r.X1; X2/; r.X2; X3/; r.X3; X4/; r.X4; X5/; r.X5; X1/; X1 < X2:
Q2./
:- r.X1; X2/; r.X2; X3/; r.X3; X4/; r.X4; X5/; r.X5; X1/; X1 < X3:
The two queries have diﬀerent comparisons, which do not become the same even after
applying automorphisms to the variables that preserve the structure of the regular subgoals.
(Notice that the two variables in the comparison X1 < X2 appear in the same subgoal, whereas
the two variables in the comparison X1 < X3 never appear in the same subgoal.) At the same
time, rather surprisingly, Q1  Q2 holds. To show Q1 v Q2, we consider the ﬁve mappings
from the ﬁve ordinary subgoals of Q2 to the ﬁve of Q1; here, each mapping corresponds to a

2.2. CQAC QUERY CONTAINMENT
29
cyclic shift of the variables. Under these mappings, ˇ2 becomes X1 < X3, X2 < X4, X3 < X5,
X4 < X1, and X5 < X2, respectively. We can show the following:
.X1 < X2/ ) .X1 < X3/ _ .X2 < X4/ _ .X3 < X5/ _ .X4 < X1/ _ .X5 < X2/:
It can be shown that if the right-hand side of the implication is false, then X1 D X2.
We conclude that Q1 v Q2. It can be proved in a similar way that Q2 v Q1. Notice that
there is no single containment mapping i such that ˇ2 ) i.ˇ1/.
Notice that in Example 2.14 we did not need normalization. The following example shows
that the containment test of Theorem 2.12 does not go through until we normalize both queries;
once both queries are normalized, we can ﬁnd the mappings and check the logical implication.
Example 2.15
Consider the following queries:
Q1./
:- p.A; 4/; A < 4:
Q2./
:- p.X; 4/; p.Y; X/; X  4; Y < 4:
Q2 is contained in Q1. The informal justiﬁcation is that if the value of the variable X in Q2 is
less than 4, then the subgoal p.A; 4/ can be mapped to the subgoal p.X; 4/, and if the value of
X is 4, then the second subgoal becomes p.Y; 4/; in this case, subgoal p.A; 4/ maps to p.Y; 4/.
However, there is only one containment mapping from the ordinary subgoals of Q1 to Q2: that
mapping sends A to X. But X  4 together with Y < 4 does not imply X < 4. Thus, we would
have concluded that the logical entailment is false. Now let us begin by normalizing the queries.
The normalized versions of the two queries are:
Q0
1./
:- p.A; B/; A < 4; B D 4:
Q0
2./
:- p.X; Z/; p.Y; X1/; X  4; Y < 4; X D X1; Z D 4:
To convince ourselves that normalizing only Q2 does not suﬃce, we may want to try to work
through the test of Theorem 2.12 on Q1 and Q0
2. The informal reason that it does not work is that
if we are to consider more than one mapping, then we must map subgoal p.A; 4/ to p.Y; X1/,
but constant 4 in the subgoal requires a constant to map to (speciﬁcally, the same constant 4),
and X1 is not a constant. However, when we deal with Q0
1, we do not have this problem, because
now we have two possible mappings: We map the only subgoal of Q0
1 either to the ﬁrst subgoal
of Q0
2 or to the second subgoal of Q0
2, which amounts to mapping the variable B to either Z or
X1.
After applying the two mappings on the normalized queries, we check the following en-
tailment:
X  4 ^ Y < 4 ^ X D X1 ^ Z D 4 ) .X < 4 ^ Z D 4/ _ .Y < 4 ^ X1 D 4/:
An equivalent rewriting of the entailment provides us with a tautology:
X  4 ^ Y < 4 ^ X D X1 ^ Z D 4 )

30
2. QUERY CONTAINMENT AND EQUIVALENCE
.X < 4 _ Y < 4/ ^ .X < 4 _ X1 D 4/ ^ .Z D 4 _ Y < 4/ ^ .Z D 4 _ X1 D 4/:
The following example is even simpler, as each query there has only one AC.
Example 2.16
Consider the queries:
Q1./
:- p.A; 4/; A < 4:
Q2./
:- p.X; 4/; p.3; X/; X  4:
The normalized versions of the queries are:
Q0
1./
:- p.A; B/; A < 4; B D 4:
Q0
2./
:- p.X; Z/; p.W; Y /; X  4; X D Y; Z D 4; W D 3:
There are two containment mappings from the ordinary subgoals of Q0
1 to the ordinary subgoals
of Q0
2.
In the following example, the contained query has no ACs, and the containing query has
only two ACs. Yet the normalization step is needed.
Example 2.17
For the following two queries, without normalization we would never consider
the mapping from the second subgoal of Q1 to the fourth subgoal of Q2. Yet this mapping is
needed to prove the containment of Q2 in Q1:
Q1.W /
:- q.W /; p.X; Y; Z; Z0; U; U /; X < Y; Z > Z0:
Q2.W /
:- q.W /; p.X; Y; 2; 1; U; U /; p.1; 2; X; Y; U; U /; p.1; 2; 2; 1; X; Y /:
The intuitive explanation of the containment uses the variables X and Y of Q2: If X D Y , then
the p-subgoal of Q1 is mapped to the third p-subgoal of Q2. Otherwise, in case X < Y , the
p-subgoal of Q1 is mapped to the ﬁrst p-subgoal of Q2, and if X > Y , then the p-subgoal of
Q1 is mapped to the second p-subgoal of Q2. We have exhausted all the cases.
Another containment test is based on canonical databases, which are deﬁned for CQACs
as follows:
Deﬁnition 2.18
For a CQAC query Q, the set of its canonical databases with respect to another
CQAC query Q0 is constructed as follows: consider the set of the variables of Q and of the
constants of Q and Q0; we partition this set into blocks, with the restriction that two distinct
constants do not belong to the same block.
For each total ordering of the blocks, we construct a canonical database of Q by: (a) equat-
ing the variables in the same block to a distinct constant (or the constant in the block if there
is one), so that the total ordering is satisﬁed; and (b) adding to the canonical database exactly

2.2. CQAC QUERY CONTAINMENT
31
those tuples (ground atoms) that result from replacing the variables in the relational atoms in
the body of Q by the constants in their block.
We now test for Q2 v Q1, as follows: consider all the canonical databases of Q2 with
respect to Q1. Then Q2 v Q1 iﬀthe following holds on any canonical database D of Q2: If the
head of Q2 is computed on D, then the head of Q1 is also computed on D.
Observe that, unlike the case of CQs, not all the canonical databases of a CQAC query Q
necessarily produce the head of Q. However, we can prune the number of canonical databases by
keeping only those on which Q computes its head (notice that the only reason that Q would not
compute its head is that the ACs are not satisﬁed). If we have deleted the canonical databases
that fail to compute the head of Q2, then we need to only test for the head of Q1 to test for
containment of Q2 to Q1.
Theorem 2.19
Let Q1 and Q2 be CQACs. Then Q2 v Q1 if and only if Q1 computes its head on
each canonical database of Q2 with respect to Q1.
Proof. When Q2 computes a tuple, it does that by assigning values (constants) to the variables
in the body of the query (i.e., by ﬁnding a homomorphism). The target of this homomorphism is
isomorphic to one of the canonical databases. Thus, if Q2 v Q1, then there is a homomorphism
from Q1 to the target (or the corresponding canonical database). For the other direction, observe
that if there is a computation of a tuple t of Q2 on any given database D, then this means that one
of the canonical databases of Q2 is isomorphic with the target of the homomorphism that derives
the tuple t. If there is a homomorphism from Q1 to the corresponding canonical database of Q2,
then there is a homomorphism to the target (of Q2) in the given database (which is isomorphic
to the canonical database).

The following example tests for containment based on canonical databases. In fact, observe
also that in this example, if we do the containment test based on the containment entailment,
then normalization is needed.
Example 2.20
Consider the following queries:
Q1./
:- p.A/; q.A/; A < 4:
Q2./
:- p.X/; q.Y /; X  Y; Y  X; Y < 4:
Q2 is contained in Q1, but there is no containment mapping from the non-normalized body of
Q1 to the non-normalized body of Q2.
Now let us test for containment based on the canonical databases of Q2. Q2 has two
variables, X and Y , and one constant, 4. We can construct the following canonical databases.

32
2. QUERY CONTAINMENT AND EQUIVALENCE
1. There are three blocks, each containing one element of the set f X, Y , 4 g. In constructing
canonical databases for ordered domains, we use the reals as the representative domain;
thus we do not have to point out the order of its elements. Thus, we have the following
canonical databases: fp.1/; q.2/g, fp.2/; q.1/g, fp.3/; q.5/g, fp.5/; q.3/g, fp.5/; q.6/g, and
fp.6/; q.5/g. Note that we have considered all the total orderings of X and Y with respect
to themselves and the constant 4—these are X < Y < 4, Y < X < 4, X < 4 < Y , Y <
4 < X, 4 < X < Y , 4 < Y < X.
2. Now we form two blocks in the following three ways: .X; Y /; 4; .X; 4/; Y ; and .Y; 4/; X.
We now derive seven more canonical databases: fp.3/; q.3/g, fp.4/; q.4/g, fp.5/; q.5/g,
fp.4/; q.3/g , fp.4/; q.5/g, fp.3/; q.4/g, and fp.5/; q.4/g.
3. Finally, we have one block with all the items equated; this results in one more canonical
database, fp.4/; q.4/g.
Now we can prune the above canonical databases by observing that, e.g., the ACs imply
that X D Y , hence that excludes all the databases that were constructed by considering three
blocks. Moreover, we have that both X < 4 and Y < 4, hence that leaves us with the database
fp.3/; q.3/g to check against Q1. Indeed, there is a homomorphism from Q1 to this database,
which satisﬁes the single AC (since 3 < 4).
CQAC containment test 1:
Given two conjunctive queries with arithmetic comparisons Q1 and
Q2, Q1 v Q2 if and only if there are containment mappings 1; : : : ; k
from Q2 to Q1, such that the following entailment is true:
 W ˇ0
2 ) 1.ˇ0
1/ _ : : : _ k.ˇ0
1/:
CQAC containment test 2:
Given two conjunctive queries with arithmetic comparisons Q1 and
Q2, Q1 v Q2 if and only if the following holds: Consider all the canon-
ical databases of Q2 with respect to Q1. Then Q2 v Q1 iﬀthe follow-
ing holds on any such canonical database D of Q2: If the head of Q2
is computed on D, then the head of Q1 is also computed on D.
2.2.2
WHEN NORMALIZATION IS NOT NEEDED
Finally, there are cases where we do not need to normalize, as the following theorem shows.
Theorem 2.21
Consider two CQAC queries, Q1 D Q10 C ˇ1 and Q2 D Q20 C ˇ2, not necessar-
ily normalized, over densely totally ordered domains. Suppose ˇ1 contains only  and , and each of
ˇ1 and ˇ2 does not imply any “=” restrictions. Then Q2 v Q1 if and only if
0 W ˇ2 ) 1.ˇ1/ _ : : : _ l.ˇ1/;

2.2. CQAC QUERY CONTAINMENT
33
where 1; : : : ; l are all the containment mappings from Q10 to Q20.
Proof. One of the directions is easy: If the containment entailment is true, then in any database
that satisﬁes ˇ2, one of the i.ˇ1/ will be satisﬁed (because we deal with constants), and hence
containment is proven.
Now we prove the other direction: Suppose Q2 is contained in Q1. Assume database D0
on which we compute tuple t in Q1.D0/ and in Q2.D0/ using homomorphisms h1 and h2
respectively. The tuples Dt in D0 we use as targets in h2 constitute a homomorphic image of
Q20.
We explained in the proof of Theorem 2.12 that each homomorphism h1 as above results
from one of the i’s in the statement of Theorem 2.12. In the same sense h1 may result from
one of the i’s. However not all homomorphisms h1 result from one of the i’s. We will prove
here that there is always such a homomorphism among the i’s for the setting of this theorem
(i.e., when we only have  and  in the containing query). Actually a homomorphisms h1
results from one of the i’s iﬀ, h1 maps each variable (say X) in Q20 to variable c such that all
occurrences of X in Q20 are mapped by h1 to occurrences of c such that there is a h2 from Q20
to database Dt such that h2 uses those occurrences of c as targets of the same attribute in Q20.
Consider in Q2 all variables (say C and D, which we use as an example in this proof)
such that there is (or implied by the ACs) in ˇ0
2 (this ˇ0
2 comes from ˇ2 after normalization) the
AC C  D but the AC C D D is not implied by ˇ0
2. If h2 maps C and D (and all attributes
with this property – as we said, we will refer only to C and D as an example in this proof but we
mean all such cases) on diﬀerent constants, then it is easy to see that h1 results from one of the
i’s. This is so, because if X D Y in ACs of Q1 then X and Y are mapped on the value of the
same attribute of Q2, since attributes with  or  ACs connecting them in Q2 do not map to
the same constant according to h2. In the rest of this proof we will address the case where such
C and D are mapped on the same constant by h2.
Suppose in Dt, h2 maps C and D in the same constant c. We replace in Dt all such c
with c1 for the target of C and with c2 for the target of D such that c1 < c2 and construct D0
t.
Now there is a homomorphism h0
2 (in particular h0
2 comes from h2 after moving the targets of
the variables in question, i.e., C maps to c1 and D maps to c2) that computes tuple t0 in Q2.D0
t/
that corresponds to t. (t0 corresponds to t in the following way: if values for the attributes C
and D do not appear in t then t0 D t, otherwise t0 comes from t after replacing the new values
c1 and c2 for the values of attributes C and D.) Hence there is also a homomorphism h0
1 that
computes t0 in Q1.D/. It is easy to see that for homomorphism h0
1, there is a mapping 1 among
the i’s such that h0
1 results from 1. For this to prove, observe that h0
1 is such that if X D Y (is
implied by the ACs) in ˇ0
1, then X and Y are mapped by h0
1 to a value that is the value of the
same attribute (as opposed to being the value of two attributes as in the case of c above which
was the value for attribute C and for attribute D). Intuitively, since we used diﬀerent constants
c1 and c2 for the values of C and D, h0
1 has not taken advantage of the possibility of having
C D D.

34
2. QUERY CONTAINMENT AND EQUIVALENCE
Now we claim that the same 1 can be used to ﬁnd a homomorphism h11 that computes
t in Q1.D/. Homomorphism h11 is produced from h0
1 by mapping each attribute mapped to
c1 to c and each attribute mapped to c2 to c and keeping the rest the same as in h0
1. This h11
satisﬁes the ACs in Q1 because of the following observation:
We have only  or  arithmetic comparisons in Q1, hence for a given AC among X and
Y (or between X and a constant cx) in ˇ1 we can deduce the following: given a homomorphism
A from Q1 to database D0 such that, regarding this AC the homomorphism satisﬁes it in the
sense: A.X/ < A.Y / (or A.X/ < cx or A.X/ > cx ), then homomorphism A also satisﬁes
it in the sense A.X/ D A.Y / (or A.X/ D cx). Thus, whichever the case in Dt, 1 can be used
to ﬁnd h11.

2.2.3
WHEN SINGLE MAPPING SUFFICES–THE HOMOMORPHISM
PROPERTY: AC-CANONICAL DATABASES
In this section we present some observations concerning those special cases where the contain-
ment test for CQACs can be simpliﬁed. These cases are those where the test for containment is
simpler, in that a single containment mapping suﬃces. We state in Theorems 2.22 and 2.54 two
such cases. Theorem 2.22 concerns the case where the ACs in the contained query induce a total
ordering on its variables together with the constants in both queries. For example, if the con-
tained query Q2 has only variables X and Y and also uses constants 4 and 15, and the containing
query Q1 uses constant 20, then, X < Y is not suﬃcient, because we also need to know how X
and Y compare with all the constants, i.e., 4, 15, and 20. At the same time, the following is a total
ordering: 4 < X < 15 < Y < 20. The following is also a total ordering: X < 4 < 15 < 20 D Y .
Theorem 2.22
Let Q1 D Q10 C ˇ1 and Q2 D Q20 C ˇ2 be CQAC queries. If ˇ2 is a total order-
ing of all the variables in Q2;0 and of all the constants in both Q1 and Q2, then Q2 v Q1 iﬀthere is
a single containment mapping  from Q1;0 to Q2;0 such that ˇ2 ) .ˇ1/.
Proof. In this case, there is a single canonical database of Q2 up to isomorphism, on which Q2
computes its head.

A query is called left semi-interval (LSI) query if all its comparisons are left semi-interval
(LSI) comparisons, i.e., are all of the form X < c or X  c, where X is a variable and c is a
constant. A right semi-interval (RSI) query and a right semi-interval (RSI) comparison are deﬁned
similarly, i.e., the comparisons are all of the form X > c or X  c, where X is a variable and
c is a constant. We use the notation SI (“semi-interval”) to refer to the queries and sets of
comparisons that contain both LSI and RSI comparisons. When we say that a semi-interval
arithmetic comparison is open, we mean that its operator is either < or >; when we say that an
arithmetic comparison is closed, we mean that its operator is either  or . We refer analogously

2.2. CQAC QUERY CONTAINMENT
35
to open LSI or RSI and closed LSI and RSI. The same result as Theorem 2.23, below, holds for
CRSI comparisons in the containing query, since this is a symmetric case.
Theorem 2.23
Let Q1 be a conjunctive query with closed left semi-interval arithmetic-comparison
subgoals (CLSIs), and Q2 a conjunctive query that uses only  or  comparisons in ˇ2, and ˇ2 does
not imply “=” restrictions. Then Q2 v Q1 iﬀthere is a single containment mapping  from Q1;0 to
Q2;0 such that ˇ2 ) .ˇ1/.
Proof. Suppose Q2 is contained in Q1. First, we notice that, according to Theorem 2.21, nor-
malization is not needed. (Indeed, if there are equalities, we can “absorb” them by having all the
variables (or variables and constants) that are equated replaced by the same variable or constant
in the normal (relational) subgoals, up until the point where there are no more equalities in the
arithmetic-comparison subgoals.) Thus, the right-hand side of the containment entailment (as
deﬁned in the containment test, see Theorem 2.12) contains only CLSIs.
We consider now the containment entailment, and turn its right-hand side into a conjunc-
tion of disjunctions. Let us say that one of the conjuncts is d1 _ d2 _ : : :. Then the containment
entailment is equivalent to several entailments, each coming from one conjunct of the right-hand
side, as follows: the left-hand side is the same as in the original entailment, and the right-hand
side is this conjunct. Thus, for the above conjunct the right-hand side is d1 _ d2 _ : : :. Each
conjunct being a disjunction of CLSIs makes the entailment simpler to reason about: It is not
hard to prove that such an entailment holds iﬀthere is one disjunct, di, on the right-hand side,
such that the left-hand side implies this disjunct di. In other words, di is directly implied by the
left-hand side of the original entailment.
However, now going back to the original entailment (and before we have turned the right-
hand side into a conjunction), we notice that di occurs in one of the disjuncts. Thus, we can delete
this di from the original entailment, which results in an entailment to satisfy with strictly fewer
arithmetic comparisons. We proceed with this new entailment in a similar manner, and continue
to argue in the same fashion, producing a sequence of entailments up until the point where one
of the disjuncts, ej D .ˇ1/, of the original entailment is such that all its conjuncts are directly
implied by the left-hand side of the original entailment. This ej gives the single homomorphism,
, which proves the desired query containment.

We say that two classes of queries have the homomorphism property iﬀ, in order to check
containment for a query belonging to one class in a query belonging to another class, the exis-
tence of a single homomorphism suﬃces, for which the following is true: ˇ2 ) .ˇ1/. Since
the homomorphism property is a general property that concerns homomorphisms between re-
lational structures, we deﬁne it below for any relational structure. First, we deﬁne a relational

36
2. QUERY CONTAINMENT AND EQUIVALENCE
structure with arithmetic comparisons to be a set of relational atoms over variables and constants,
together with a set of arithmetic comparisons that use variables that appear in relational atoms.
Deﬁnition 2.24
(Homomorphism property)
For two relational structures with arithmetic comparisons, K1 and K2, we say that the homomor-
phism property holds from K1 to K2 if the following two statements are equivalent.
1. We normalize K1 D K10 C ˇ1 and K2 D K20 C ˇ2 to K0
10 C ˇ0
1 and K0
20 C ˇ0
2, respec-
tively (see Deﬁnition 2.11 for normalization). Let 1; : : : ; k be all the homomorphisms
from K0
10 to K0
20. Then the following is true:
ˇ0
2 ) 1.ˇ0
1/ _ : : : _ k.ˇ0
1/:
2. There is a homomorphism  from K10 to K20, such that the following is true:
ˇ2 ) .ˇ1/:
We say that a pair of sets of arithmetic comparisons .B1; B2/ enables the homomorphism
property if the homomorphism property holds from K1 to K2, where K1 is a relational structure
with ACs from B1, and K2 is a relational structure with ACs from B2.
Thus, if we denote by B1 the set of closed left semi-interval arithmetic comparisons, and
B2 is the set of only  or  comparisons, under the condition that they do not imply “=” re-
strictions (i.e., the subset considered each time), then Theorem 2.23 says that the pair .B1; B2/
enables the homomorphism property.
CQAC containment test—homomorphism property: Given two
conjunctive queries with arithmetic comparisons Q1 and Q2, Q1 v Q2
if and only if there is a containment mapping from Q2 to Q1, such that
the mapping maps a constant to the same constant, and maps a variable
to either a variable or a constant. Under this mapping, the head of Q2
becomes the head of Q1, each subgoal of Q2 becomes a subgoal in Q1,
and the image of each arithmetic comparison in Q2 can be matched
with an arithmetic comparison in Q1 that entails (yields) this image.
We now deﬁne canonical databases a bit diﬀerently: They now have variables instead of
constants, and include ACs over these variables.
Deﬁnition2.25
Let Q be a CQAC query. An AC-canonical database of this query is a canonical
database of the regular (relational) subgoals of Q, which is modiﬁed by using variables instead
of constants and by adding the AC subgoals (comparisons) of Q on these variables.

2.2. CQAC QUERY CONTAINMENT
37
The following theorem shows the usefulness of the AC-canonical database.
Theorem 2.26
Let .B1; B2/ be a pair of sets of arithmetic comparisons that enables the homomor-
phism property. Let Q be a query with ACs from B1, and Q0 a query with ACs from B2. Then the
following is true: If there is a homomorphism from Q to the AC-canonical database of Q0 such that the
ACs in Q0 imply the image of the ACs in Q, then there is a homomorphism from Q to any canonical
database of Q0 that satisﬁes the ACs in Q.
The following example shows how to use this result.
Example 2.27
Q1./
:- r.X; Y /; r.Y; Z/; Z  8; X  3:
Q2./
:- r.X; Y /; r.Y; Y /; s.W /; Y  W; W  5; X  2:
We will Q2 is contained in Q1. First we use the general containment test for CQACs. Then
observe that the homomorphism property holds, because the ACs in the containing query are
all CLSIs, and the ACs in the contained query use only . Hence we can apply Theorem 2.26.
There are two containment mappings from the relational subgoals of Q1 to the relational
subgoals of Q2: The mapping 1 that maps X to X, Y to Y , and Z to Y , and the mapping 2
that maps all the variables to Y . We form the containment entailment (as used in Theorem 2.12):
Y  W ^ W  5 ^ X  2 ) 1.Z  8 ^ X  3/ _ 2.Z  8 ^ X  3/;
which becomes:
Y  W ^ W  5 ^ X  2 ) .Y  8 ^ X  3/ _ .Y  8 ^ Y  3/:
We can see that this entailment is true, because the following is true:
Y  W ^ W  5 ^ X  2 ) .Y  8 ^ X  3/;
which means that the mapping 1 was suﬃcient to prove the containment.
The containment test can be now simpliﬁed by using Theorem 2.26. The AC-canonical
database of Q2 is: fr.X; Y /; r.Y; Y /; s.W /; Y  W; W  5; X  2g. Now, we compute the query
Q1 on this AC-canonical database. In order to do that, we use the 1 from Q1 to this AC-
canonical database. This proves the containment, because the ACs in Q2 imply the images of
the ACs in Q1, i.e.,
Y  W ^ W  5 ^ X  2 ) .Y  8 ^ X  3/;
which is the same implication that was observed in the reasoning above. Theorem 2.26 guar-
antees that if we could not ﬁnd a single containment mapping to satisfy the requirement about
ACs, then The query Q2 would not be contained in Q1.

38
2. QUERY CONTAINMENT AND EQUIVALENCE
2.3
CQN QUERY CONTAINMENT
The containment test for CQNs is based on canonical databases, whose construction begins in
the same way as for CQACs, but then proceeds diﬀerently.
2.3.1
SET OF CANONICAL DATABASES
We construct a set of canonical databases as follows. The ﬁrst stage is the same as that for
CQACs: We consider only the positive query subgoals, and enumerate all the possible partitions
of their variables into blocks. We then assign a distinct constant to each block. (We do not have
to worry about taking these constants from a totally ordered domain, because in case of CQNs
ordering does not matter.) The result of this stage is the basic canonical databases.
In the second stage, we check whether we can compute the head of the query on each of
the basic canonical databases. The ones that pass this test comprise the canonical databases of
the query.
In the third and ﬁnal stage, from the canonical databases formed in the second stage we
construct more canonical databases, as follows. For each canonical database formed in the second
stage, we form a number of databases from the tuples of the relations mentioned in the query,
with all possible ways of using the available constants. (We do not use any additional constants.)
For each of those databases, we check whether the head of the query can be computed: For each
database for which the answer is positive, the database becomes another canonical database of
the query.
Example 2.28
Consider the following queries:
Q1./
:- r.X; Y /; s.Y; Z/; r.X; Z/; :r.X; X/:
Q2./
:- r.X; Y /; s.Y; Z/; r.X; Z/; :r.X; X/; :s.Z; Z/:
Let us show that Q2 is contained in Q1. Indeed, the basic canonical databases of Q2 are the
canonical databases of the following ﬁve CQs:
Qa./
:- r.X; Y /; s.Y; Z/; r.X; Z/:
Qb./
:- r.X; X/; s.X; Z/; r.X; Z/:
Qc./
:- r.X; Y /; s.Y; Y /; r.X; Y /:
Qd./
:- r.X; Y /; s.Y; X/; r.X; X/:
Qe./
:- r.X; X/; s.X; X/:
These ﬁve CQs are all the homomorphic images of the body of Qa:
Qa./
:- r.X; Y /; s.Y; Z/; r.X; Z/:
Now we check whether we can compute the head of Q2 on those basic canonical databases.
This check is passed only by the canonical database of Qa. To see why, let us take one of the
other four CQs, say Qb. Its canonical database is D D fr.1; 1/; s.1; 2/; r.1; 2/g. There is only

2.3. CQN QUERY CONTAINMENT
39
one homomorphism from the positive subgoals of Q2 to D. Under this homomorphism, the
negated subgoals of Q2 are not satisﬁed, in particular the ﬁrst one, :r.X; X/, because of the
presence of r.1; 1/. Hence the head of Q2 is computed on D.
Now we proceed with the canonical database D0 of Qa, D0 D fr.1; 2/; s.2; 3/; r.1; 3/g.
Remember that D0 is still a basic canonical database for Q2. Now we form a number of databases,
by adding more facts to D0 using in all possible ways its constants 1, 2, and 3. Among the
resulting databases, the ones that qualify as canonical databases for Q2 are the ones on which
the head of Q2 is computed. Thus, e.g., D0
1 D fr.1; 2/; s.2; 3/; r.1; 3/; r.1; 1/g does not qualify,
because the negated subgoal :r.X; X/ is not true. (All the other instances that come from D0 D
fr.1; 2/; s.2; 3/; r.1; 3/g and do not contain r.1; 1/, qualify as canonical databases.) E.g., if we
take D0
2 D fr.1; 2/; s.2; 3/; r.1; 3/; r.2; 1/; r.3; 3/; s.2; 2/g, this qualiﬁes as a canonical database
of Q2.
Now that we have formed the canonical databases of Q2, we check for each of them
whether it can be used to derive the head of Q1. As an example, let us see what Q1 computes
when applied on D0. Q1 computes to true on D0, because of the homomorphism X ! 1, Y ! 2,
Z ! 3, which makes the non-negated subgoals true. In addition, the negated subgoal becomes
true, because D0 does not include the fact r.1; 1/. This test works for all the canonical databases
of Q2, hence Q2 v Q1.
If, however, we had another query for Q1, say Q0
1:
Q1./
:- r.X; Y /; s.Y; Z/; r.X; Z/; :r.Y; Y /;
then Q2 v Q0
1 would not hold. To prove this, we only need one canonical database of Q2 to
use as a counterexample. Indeed, on D00 D fr.1; 2/; s.2; 3/; r.1; 3/; r.2; 2/g, the head of Q2 is
computed, but the head of Q0
1 is not.
Theorem2.29
Let Q1 and Q2 be CQN queries. Then Q1 v Q2 iﬀthe procedure given in Figure 2.1
outputs “yes.”
Proof. (() Let D be any database, and t be a tuple in the set of answers to the query Q1 on D,
i.e., t is in Q1.D/. The mapping from Q1 to D that produces t equates some variables of Q1;
let Qi
1 be Q1 with those variables merged. There is a homomorphism from the positive subgoals
in the body of Qi
1 to D that maps the head of Qi
1 to t. The image of this homomorphism is
isomorphic to a canonical database Dj that makes the body of Qi
1 true. That is, t is in Q2.D/.
Therefore, Q1 v Q2.
()) Suppose Q1 v Q2. If the test is not successful, then one of the canonical databases of Q2
is a counterexample database that proves that containment does not hold.

40
2. QUERY CONTAINMENT AND EQUIVALENCE
Containment of CQNs (checking whether Q2 ⊑ Q1):
1. Construct the set of basic canonical databases that correspond to all the partitions of 
the set of variables of Q2.
a. For each partition, assign a unique constant to each block of the partition.
b. Create basic canonical database DB by replacing each variable in the body of Q2 by 
the constant of its block, and treat the resulting subgoals as the only tuples in the 
database (i.e., freeze the body of Q2). T e basic canonical DB is the set of the resulting 
positive subgoals.
2. For each basic canonical DB D constructed in step (1), check that if Q2(D) contains the 
frozen head of Q2, then so does Q1(D).
3. If the above check is successful, then we must also consider the larger set of (extended) 
canonical DB’s D′, formed by adding to D other tuples, which are formed from the same 
symbols as D, but not using any of the tuples among the negated subgoals of Q2
Q2
. Check 
that Q1(D′) contains the frozen head of Q2.
4. If the above condition holds for all the D′, then Q2 ⊑
⊑
 
holds; if not, then 
 Q1
Q1
 
does not hold.
Figure 2.1: Containment test for CQNs.
CQN containment test:
Given two conjunctive queries with negation Q1 and Q2, Q2 v Q1 if
and only if the following holds: Consider all the canonical databases of
Q2 with respect to Q1. Then Q2 v Q1 iﬀthe following holds on any
canonical database D of Q2: If the head of Q2 is computed on D, then
the head of Q1 is also computed on D.

2.4
CQA QUERY CONTAINMENT AND EQUIVALENCE
One categorization of aggregate operators considers those that are duplicate insensitive, and those
that are duplicate sensitive. An aggregate operator is duplicate insensitive if, when it is computed
on a bag, the result does not depend on the multiplicities, otherwise it is duplicate sensitive. Max
and min are in the ﬁrst category, and sum and count are in the second category.

2.4. CQA QUERY CONTAINMENT AND EQUIVALENCE
41
For duplicate-insensitive queries, we provide a detailed analysis with examples, by fo-
cusing on max queries. (Min queries are “symmetical” to max, so the analysis is similar.) For
duplicate-sensitive queries, the analysis is analogous. We then introduce a more general cate-
gory of expandable queries; this category contains the aggregate operators max, min, sum, and
count.
Recall that to evaluate aggregate queries, we form bags of tuples. In this context, the
following theorem is relevant and useful.
Before we state the theorem, let us clarify that under set semantics, a conjunctive query
with duplicate subgoals is equivalent to the same query with the duplicate subgoals removed.
Thus, we never assume that we have duplicate subgoals in conjunctive queries. Theorem 2.30,
below, says that under bag-set semantics, duplicate subgoals can be removed as well.
Theorem 2.30
(1) Two conjunctive queries are bag equivalent iﬀthey are isomorphic. (2) Two con-
junctive queries are bag-set equivalent iﬀthey are isomorphic after the duplicate subgoals are removed.
2.4.1
MAX QUERIES
To gain intuition, we begin with an example of a max query.
Example 2.31
Consider queries
q1.X; max.Y //  r.X; Z/; s.Z; Y /;
q2.X; max.Y //  r.X; Z/; s.Z; Y /; s.Z0; Y /;
q3.X; max.Y //  r.X; Z/; s.Z; Y /; t.W; Y /:
The following database is a counterexample to the containment of q3 in q1:
D D fr.1; 2/; s.2; 5/; t.6; 5/; s.2; 7/g:
On this database, q3 computes one tuple, .1; 7/, because there are two appropriate homomor-
phisms from the body of the query to the database, which compute the set f.1; 5/; .1; 7/g. How-
ever, there is only one appropriate homomorphism from the body of q1 to the database, which
computes the set f.1; 5/g. Hence the output of q1 on D is f.1; 5/g. This is proof that q3 is not
contained in q1, although there is a homomorphism from the body of q3 to the body of q1 that
maps both the grouping (i.e., x) and aggregate (i.e., y) attributes to themselves.
At the same time, the queries q1 and q2 are equivalent, although their bodies are not
isomorphic up to duplicate-subgoal elimination.2 Later, we will prove a theorem that says that
2We assume that a CQ may have duplicate subgoals only under bag semantics. For set semantics, this does not make any
diﬀerence, so, for the rest of the book, duplicate subgoals do not appear.

42
2. QUERY CONTAINMENT AND EQUIVALENCE
for max queries with only one grouping attribute in each, query containment reduces to query
equivalence.
When we talk about appropriate homomorphisms between subgoals of aggregate queries,
we refer to homomorphisms that map all the head attributes of one query to the same attributes
of the other query.
Theorem 2.32
Two max queries q1 and q2 with single aggregation are equivalent if and only if
their conjunctive cores (see Deﬁnition 1.15 for conjunctive core of an aggregate query) Mq1 and Mq2 are
set equivalent.
The proof of this result is based on the observation that if the conjunctive cores are not
set equivalent, then one value for the aggregated attribute can appear in the result of applying
the conjunctive core on a database for one query and not for the other. This value could be the
maximum, and this will give diﬀerent results.
Theorem 2.33
For two max queries with only one grouping attribute in each, one is contained in
the other iﬀthese queries are equivalent.
Proof. For one of the directions, the proof is straightforward. For the other direction, suppose
the queries are not equivalent. Then we can construct a counterexample database. We have two
cases: If there is no homomorphism from the body of Q1 to the body of Q2, then we can
construct a counterexample database the same way as we did for CQs. Suppose there is a ho-
momorphism from the body of Q1 to the body of Q2, but there is no homomorphism from
the body of Q2 to the body of Q1. Then we can construct a counterexample database D so that
there is an extra homomorphism from the body of Q1 to some part of the database. We make
sure that this part has the maximum value for the aggregated attribute, say value v1, whereas for
the homomorphisms of Q2, the maximum value is lower, say v2 < v1 (for the same grouping
attribute value ax). Then, in the output of Q2 we have the tuple .ax; v1/, whereas in Q1 we have
the tuple .ax; v2/.
Now, in detail, we construct the counterexample database D as follows. We place in D all
the facts of the canonical database of the conjunctive core of Q1. Here, assume that ax is the
value of the grouping attribute, and v1 is the value of the aggregated attribute. Then we use a
fresh constant v2 (not used so far in the facts we added in D), and add more facts in D: We add
all facts of the canonical database of the conjunctive core of Q2, where the value of the grouping
attribute is ax and the value of all the other attributes is v2. Finally, we choose v2 so that v2 < v1.


2.4. CQA QUERY CONTAINMENT AND EQUIVALENCE
43
When there is more than one grouping attribute, then for max queries, containment may
hold without the queries being equivalent.
Example 2.34
Consider queries
q1.X; X0; max.Y //  r.X; Z/; s.Z; Y /; r0.X; X0/;
q2.X; X0; max.Y //  r.X; Z/; s.Z; Y /; s.Z0; Y /; r0.X; X0/; s0.X; X0/:
The bodies of q1 and q2 are not such that there is an appropriate homomorphism both ways,
therefore the queries are not equivalent (it is easy to build a counterexample database), but q2
is contained in q1. The reason is that q2 may miss (wrto q1) certain tuples with a speciﬁc list
of values of the grouping attributes. At the same time, in those cases where q2 does not miss
a grouping-attribute value, whenever there is a homomorphism from the body of q2 to the
database, then there is a homomorphism from the body of q1 to the same tuples of the database.
To see this, consider the database
D D fr.1; 2/; s.2; 5/; s.2; 7/; r0.1; 9/; r0.1; 8/; s0.1; 8/g:
The result of the query q2 on D is f.1; 8; 7/g, whereas the result of the query q1 on D is
f.1; 8; 7/; .1; 9; 7/g.
The reason that q2 is contained in q1 is a little more subtle: In the query deﬁnitions in
this example, we can see that the subgoals in the body of the query that do not allow homo-
morphisms among the bodies both ways are the primed subgoals (with relation symbols s0 and
r0). However, these subgoals contain only grouping attributes. Hence, when we compute either
query on a database, those subgoals either generate homomorphisms with a speciﬁc value-list of
grouping attributes, or they do not. When such homomorphisms are generated by q2, they are
also generated by q1. (Note that this does not hold the other way around, hence there is con-
tainment but not equivalence in this case.) Since the rest of the subgoals in both queries have
homomorphisms both ways, both queries generate the same homomorphisms on the database.
The following theorem proves this point.
For an aggregate query Q, we say that a subgoal is a grouping subgoal if it only contains
grouping attributes. We call all the other subgoals non-grouping subgoals. When we check query
containment or equivalence, we think of the grouping attributes in the head of both queries as
having the same names.
Theorem 2.35
For max queries Q1 and Q2 with minimized cores, Q2 is contained in Q1 iﬀthe
following is true: (a) the set of grouping subgoals of Q1 is a subset of the set of grouping subgoals of Q2
and (b) between the non-grouping subgoals of the two queries there are containment mappings both
ways.

44
2. QUERY CONTAINMENT AND EQUIVALENCE
Proof. When the conditions (a) and (b) do not hold, we have two cases. (i) The ﬁrst of the two
conditions holds, but the second does not; then there is a counterexample database that is con-
structed along the lines of the counterexample database in the proof of Theorem 2.33. (ii) The
ﬁrst of the two conditions does not hold; then a counterexample database can be constructed so
that it produces a list of values of the grouping attributes for Q2 but not for Q1. This counterex-
ample database is constructed as follows: suppose Q1 has a grouping subgoal g, and Q2 does
not have g. We construct the canonical database D of the core of Q2. Since the core of Q1 is
minimized (i.e., before we decide that g is not in Q2), g does not map to any fact in D (other-
wise the core of Q1 would not have been minimized). Thus, Q2 produces a nonempty result on
D, but Q1 produces an empty result. Actually, this proof shows that it is suﬃcient to minimize
the set of grouping subgoals, i.e., to delete any grouping subgoal that homomorphically maps to
another grouping subgoal.
For the other direction, suppose both conditions (a) and (b) hold. Then if the grouping
subgoals of Q2 can be mapped to a database, then a “same-value” mapping can be used for
the grouping subgoals of Q1 and the same database, so that a tuple with these grouping values
is formed on the database for both queries. Because the non-grouping subgoals have homo-
morphisms both ways between them, the same homomorphisms on the database can be found
for both queries. Hence for any assignment of values to the grouping attributes, the aggregate
operator provides the same value in both queries.

Note: Theorem 2.33 assumes that there are no unary relations on the grouping attribute.
2.4.2
SUM QUERIES
The analysis here is analogous to that of Section 2.4.1, and the proofs of the following two
theorems are analogous to their previous-section counterparts as well.
Theorem 2.36
Two sum queries are equivalent iﬀtheir cores are bag-set equivalent.
Theorem 2.37
For two sum queries with only one grouping attribute in each, containment holds iﬀ
the queries are equivalent.
In the following theorem, we assume that conjunctive queries may have duplicate subgoals.
This assumption does not make a diﬀerence in the case of set semantics, and the only place in
this book where this assumption makes a diﬀerence is when we discuss aggregate queries. By
minimizing the set of grouping subgoals in a query deﬁnition, we mean deleting any grouping
subgoal that homomorphically maps to another grouping subgoal.
Theorem 2.38
For sum queries Q1 and Q2 with minimized sets of grouping subgoals, containment
of Q2 in Q1 holds iﬀthe following is true: (a) the set of all the grouping subgoals of Q1 is a subset of

2.4. CQA QUERY CONTAINMENT AND EQUIVALENCE
45
the set of all the grouping subgoals of Q2 and (b) the non-grouping subgoals of the two queries are
isomorphic after duplicate-subgoals elimination.
CQA containment test:
Given two CQA queries Q1 and Q2, Q2 v Q1 if and only if the
following holds.
The set of all the grouping subgoals of Q1 is a subset of the set of all
the grouping subgoals of Q2, and the following additional conditions
hold:
(a) for min and max: the non-grouping subgoals of Q2 and Q1 have
appropriate homomorphisms from one to the other; and
(b) for sum and count: the non-grouping subgoals of Q2 and Q1 are
isomorphic after duplicate-subgoal elimination.
2.4.3
MORE GENERAL AGGREGATE OPERATORS
We now turn to an exploration of the problems of containment and equivalence of compatible
queries:
Deﬁnition 2.39
(Compatible queries)
Two queries are compatible if the tuples of arguments in their heads are identical.
An aggregate function  is expandable if equality, as computed on two diﬀerent multisets,
implies equality as computed on two other multi-sets, each of which comes from the respective
original multiset by multiplying all the multiplicities by the same number. In other words, if
.B/ D .B0/ and B1 comes from B by multiplying all the multiplicities by integer k, and B0
1
comes from B0 by multiplying all the multiplicities by the same integer k, then .B1/ D .B0
1/.
The aggregation functions max, min, cntd, count, sum, avg, and topK are expandable.
For expandable functions, testing query containment is reduced to testing query equiv-
alence, as follows. The inspiration comes from the following theorem for CQs (the proof is
straightforward using methods that have been explained in this chapter).
Theorem 2.40
Suppose Q1; Q2, and Q3 are compatible queries. Given CQs Q1 and Q2, let query
Q3 have the same head as those of Q1 and Q2, and have a body that contains all the subgoals of Q1
and Q2 and has no other subgoals. Then Q2 is contained in Q1 iﬀQ2 and Q3 are equivalent.
To check containment for aggregate expandable queries Q and Q0, we need to deﬁne two
new queries. Each new query has the same head as Q and Q0. Further, the body of Q1 comprises

46
2. QUERY CONTAINMENT AND EQUIVALENCE
the subgoals of Q0 twice, and the body of Q2 comprises all the subgoals of Q and all the subgoals
of Q0 (and has no other subgoals).
Theorem 2.41
Let Q and Q0 be compatible aggregate queries with expandable aggregate operators.
Then Q0 is contained in Q iﬀQ1 and Q2 as constructed above are equivalent.
The proof of this result is based on the material provided in this section and is left as an
exercise to the reader.
2.5
ACYCLIC CQS
As we have discussed, testing for query containment and query evaluation for CQs both use
checking for the existence of a homomorphism as a subroutine. When the queries are “acyclic
CQs,” then we can ﬁnd a homomorphism more eﬃciently—which, intuitively, is not surprising,
because we expect to be able to take advantage of the tree-like structures (hence lack of cycles)
in the query deﬁnitions. In this section, we deﬁne acyclic CQs, and then present these eﬃcient
algorithms.
2.5.1
DEFINITION OF ACYCLIC QUERIES AND SPECIAL CASES
A hypergraph extends the deﬁnition of a graph in that it contains edges, each edge including
more than two nodes and is formally deﬁned as follows: a hypergraph is a pair .V; E/, where
V is a set of nodes and E is a set of hyperedges, each hyperedge containing a subset of the
nodes. Figure 2.2 shows a hypergraph with V D fA; B; C; D; E; F; G; H; I; J; Kg and with six
hyperedges, each hyperedge being indicated by an ellipse in the ﬁgure. Thus, e.g., the leftmost
hyperedge in the ﬁgure contains the nodes K and G, while the highest hyperedge contains the
nodes A; H; D; and E. A conjunctive query can be viewed as corresponding to a hypergraph: the
attributes of the query are the nodes of the hypergraph, and there is a hyperedge for each subgoal
in the body of the query, which includes exactly the attributes/nodes that are in the schema of
this relation.
A hypergraph is acyclic if the “GYO-elimination” procedure results in a single hyperedge.
(The name GYO comes from the ﬁrst letter of three authors of a related paper—see Chapter 8 for
more details.) The GYO-elimination procedure eliminates a hyperedge e1 from the hypergraph
if this hyperedge is consumed by another hyperedge e2. Hyperedge e1 is consumed by hyperedge e2
if the attributes of e2 can be partitioned into two sets, the set of attributes that belong only to e1
and no other hyperedges, and the set of attributes that belong to both e1 and e2. The elimination
procedure creates a parse tree, where edge e1 is a child of the edge e2 when e1 is eliminated due
to being consumed by e2. The nodes of this tree are the hyperedges of the hypergraph.
Deﬁnition 2.42
A CQ query is acyclic if its corresponding hypergraph is acyclic.

2.5. ACYCLIC CQS
47
A
H
E
D
C
F
J
I
G
B
K
Figure 2.2: Hypergraph for the query of Example 2.43. This hypergraph is acyclic.
Example 2.43
Consider a CQ with the following relations in the body:
r1.A; H; D; E/; r2.B; H; E; G; I/; r3.E; D; C/; r4.K; G/; r5.I; J /; r1.E; D; C; F /:
Figure 2.2 shows the hypergraph that corresponds to this query. We will show that this is an
acyclic query, because its corresponding hypergraph is acyclic.
We apply GYO elimination to the hypergraph of Figure 2.2. We observe that the hyper-
edge fK; Gg is consumed by hyperedge fB; H; E; G; Ig, because K only belongs to the former
hyperedge and G to the latter. Thus, we start by eliminating the hyperedge fK; Gg, and begin
building the parse tree in Figure 2.3 by connecting hyperedge fK; Gg to its parent hyperedge
fB; H; E; G; Ig. Now, hyperedge fF; D; C; Eg is consumed by hyperedge fD; C; Eg, thus we
proceed with building the parse tree by making fD; C; Eg the parent of fF; D; C; Eg. Observe
that the hyperedge fA; H; D; Eg does not consume fF; D; C; Eg, because F is the only node
of fF; D; C; Eg that does not belong to any other hyperedge, and the rest of its nodes need to
belong to the same hyperedge to enable the conclusion that it is consumed by this hyperedge.
Below, we deﬁne chain queries and path queries, which we will use in this book in several
diﬀerent contexts. Queries in both classes are acyclic and have parse trees that are simple paths.
Deﬁnition 2.44
A CQ query is a chain query if it is deﬁned over binary predicates, and the
following also holds: The set of subgoals of the query, when viewed as a labeled graph, forms a
directed path, whose start and end nodes are the only arguments in the head. (For example, the
following query is a chain query: q.X; Y / :- a.X; Z1/; b.Z1; Z2/; c.Z2; Y /.)
Path queries are chain queries over a single binary relation. Path queries can be fully deﬁned
by the length of the path in the body (i.e., the number of subgoals in the body). Hence, we denote

48
2. QUERY CONTAINMENT AND EQUIVALENCE
A H D E
B H E G I
E D C
E D C F
I J
K G
Figure 2.3: The parse tree of the hypergraph for the query of Example 2.43.
by Pk the path query of length k. We denote the language of all chain queries by CQchain, and
the language of all path queries by CQpath.
We will also work with the class of Boolean path queries, denoted P b
k and with the meaning
that the body of P b
k is the same as Pk, but the head contains no variables. In other words,
a Boolean path query returns the value true or false, depending on whether its variables are
instantiated to nodes along a path in the graph that represents the database.
Chain queries have parse trees that are simple paths; that is, each node in the parse tree
has only one child. Notice that, in general, hypergraphs (and corresponding CQs) do not have
unique parse trees. Other classes of acyclic queries that have been studied for their special prop-
erties include (a) tall queries (informally deﬁned as a series of relational subgoals, each relation
having a subset of the attributes of the previous one—a parse tree is a simple path), and (b) star
queries (informally deﬁned as having a subgoal that can be the parent in a parse tree of all other
subgoals, i.e., it contains all the attributes appearing in each subgoal which are not unique to
the subgoal). Tall queries have the property that (unlike chain queries), when attributes or even
whole relations are deleted, they remain connected and are still tall queries. Moreover, in tall
queries, there is an attribute (or attributes) of a relation that appear in all the other relations.
The following are examples of tall queries and star queries:
Tall query: q.X1; X2; X3; X4/ :- a.X1; X2; X3; X4/; b.X1; X2; X3/; c.X1; X2/; d.X1/:
Star query: q.X1; X2; X3; X4/ :- a.Y; X3; X4/; b.Y; X1; X2/; c.Y; X5/; d.Y; X6/; f .Y /:

2.5. ACYCLIC CQS
49
2.5.2
EFFICIENT ALGORITHM FOR CHECKING QUERY
CONTAINMENT
Now let Q1 be a Boolean path query on binary relation e, so its schema is a single binary relation.
Let Q2 be a CQ for which we would like to check whether it is contained in Q1. Suppose the
schema of Q2 is a single binary relation; so data over such schema can be thought of as a directed
graph. How do we check containment?
We can prove that containment holds iﬀthe canonical database of Q2 (which includes a
graph on relation e) contains a path labeled e (not necessarily simple) of length that is the same
as the path of Q1. There is a polynomial algorithm (in the size of Q2 and Q1) to check this: In
the ﬁrst stage, look for paths of length 1. In the second stage of the algorithm, check whether
those paths can be extended to paths of length 2, and so on. In the i-th stage, check whether the
paths of length i   1 can be extended to paths of length i. In order to implement each stage, all
that is needed is to keep a table of nodes by lengths up to length i   1, and all that is needed to
record for each node N in the current stage is whether there is a path of length i from any node
to node N. For that, the algorithm checks whether there is an adjacent edge that can extend the
path.
To see that the runtime of the algorithm is polynomial, notice that the number of its
stages is at most equal to the length of the path in Q1. Also, in each stage we visit all the edges
of the graph for the query Q2, to determine whether they can form a longer path. This checking
is bounded from above by the size of the query Q2. Thus, the total time is proportional to
O.size.Q1/  size.Q2//.
When the containing query is an acyclic CQ and the contained query is any CQ, then
the following algorithm checks for containment eﬃciently.
The algorithm follows one of the parse trees of Q1. In each step, the algorithm considers
a subgoal si of Q1, such that all the children of si in the parse tree were processed in earlier
steps of the algorithm. For each partial mapping  from si to the subgoals of Q2, the algorithm
checks whether  is “successful;” it is successful if , together with the partial mappings from
the children of si, can be assembled into a (“larger”) partial mapping from si and its children to
some set of subgoals of Q2.
We now provide a formal description of the algorithm. Let Q1 and Q2 be two CQ queries,
such that Q1 is acyclic; we would like to check whether Q2 is contained in Q1. Let T be a parse
tree for the query Q1, such that each node, i, in T corresponds to subgoal si of the query.
For each node i of T , the algorithm maintains a set of tuples; each tuple consists of the
same number of variables of Q2. For example, for the parse tree of Figure 2.3, if the node
.B; H; E; G; I/ is node 2, then the relation is M2.H; E/, because the parent of this node is
the root, and .H; E/ are the attributes in the intersection of the nodes .B; H; E; G; I/ and
.A; H; D; E/.

50
2. QUERY CONTAINMENT AND EQUIVALENCE
Algorithm Acyclic Containment:
1. Initialize all sets of leaves as follows. For each leaf i in T , corresponding to subgoal gi of
Q1, consider all homomorphisms from gi to any subgoal of Q2; for each such homomor-
phism h, add h.t/ to the relation Mi for leaf i, where t are the shared variables between gi
and its parent. All the leaves are labeled “processed.”
2.
For each subgoal g such that all its children are processed, do:
3.
For each homomorphism hg from g to the subgoals of Q2, do:
4.
For each child gi of g in the parse tree, do: check whether h.ti/ is in Mi
where ti is the tuple of variables from g that are shared with gi.
If it is not, abort hg.
5.
Put hg.t/ into the relation Mi.g/,
where i.g/ is the name of the node of the parse tree for the subgoal g,
and t are the variables that g shares with its parent (or all its variables
if g is the root of the entire tree) in the parse tree.
6.
Label subgoal g “processed.”
7. If the list for the root of the entire tree is nonempty, then return “Q2 is contained in Q1”;
otherwise, return “Q2 is not contained in Q1.”
Example 2.45
We will apply the algorithm to check for containment of the query Q2, which
has the following subgoals:
r1.A; H; D; E/; r2.P 0; H; E; P; P /; r3.E; D; P /; r4.P; P /; r5.P; P /; r1.E; D; P; P /;
in the query Q1, which is the acyclic query
r1.A; H; D; E/; r2.B; H; E; G; I/; r3.E; D; C/; r4.K; G/; r5.I; J /; r1.E; D; C; F /;
whose hypergraph is shown in Figure 2.2. We will use the parse tree shown in Figure 2.3. Let
us call the leaves in Figure 2.3 node 1, node 2, and node 3 (corresponding to .K; G/, .I; J /,
and .E; D; C; F /, respectively). We call node 4 the parent of nodes 1 and 2, we call node 5 the
parent of node 3, and call node 6 the root of the tree. Thus, the algorithm maintains the re-
lations: M1.G/; M2.I/; M3.E; D; C/; M4.H; E/; M5.E; D/; M6.A; H; E; D/. Running the al-
gorithm is easy in this example, because from each subgoal of the query Q1 there is only one
homomorphism to the subgoals of query Q2, except for the subgoal with relation r1, which has
two homomorphisms. Now, for the leaves the relations Mi will be:
M1.G/ D fP g; M2.I/ D fP g; M3.E; D; C/ D f.E; D; P /; .A; H; D/g:

2.5. ACYCLIC CQS
51
For node 4, we ﬁnd the homomorphism h that maps B to P 0, H to H, E to E, G to P , and I
to P . Since h.G/ D P , we need to check whether P is in M1.G/. Since h.I/ D P , we also need
to check whether P is in M2.I/. Since both are true, we put .H; E/ in M4.H; E/. We proceed
in the same fashion, and conclude that Q2 is contained in Q1.
Theorem 2.46
Given CQ queries Q1 and Q2, such that Q1 is acyclic. Then Q1 contains Q2 iﬀ
algorithm AcyclicContainment returns “Q2 is contained in Q1.”
Proof. For the “if” direction, assume the algorithm returns “Q2 is contained in Q1.” Then it is
easy to prove that there is a homomorphism from Q1 to Q2, which proves the containment. For
the other direction, we prove the following inductive hypothesis for the subtrees of the parse
tree T0 of the query Q1.
Inductive hypothesis: If there is a homomorphism h from the subgoals of the subtree T of
Q1 to the subgoals of Q2, and T has at most n subgoals, then h.t/ is in the relation Mi, where
i is the node at the root of subtree T .
Now, let h be any homomorphism from the subgoals of subtree T of Q1 to the subgoals
of Q2, and let T have n C 1 subgoals. Then any subtree rooted at a child ij of node i has at most
n subgoals, therefore the inductive hypothesis holds, and h.tij / is in the relation Mij , where tij
are the shared variables between the subgoal gi of node i and the subgoal gij of node ij. Hence,
when the algorithm considers homomorphism hg from subgoal g (that is at node i in the parse
tree) to the subgoals of Q2, where hg is h restricted to g, the algorithm will ﬁnd for each child
ij ; j D 1; 2; : : : of i, that hg.tij / belongs in the relation Mij . Hence, the algorithm will put h.t/
in the relation Mi, where t are the shared variables between g and its parent.

Time complexity: In each iteration and for each subgoal in the containing query, we keep
account of the subgoals in the contained query that satisfy, in the bottom-up fashion, the partial
containment mapping. This number is at most equal to the number of subgoals in the contained
query, times the number of subgoals in the containing query.
CQ containment test—when the containing query is acyclic:
Polynomial-time algorithm: The algorithm ﬁnds homomorphisms
from the acyclic query to the contained query by following the parse
tree of the former query in a bottom up fashion.
2.5.3
EFFICIENT ALGORITHM FOR QUERY EVALUATION
As explained in Section 2.1.2, CQ query containment is related to CQ query evaluation, since
both are based on ﬁnding homomorphisms from one relational structure to another. This is
one reason to discuss the algorithm of lower complexity than the general case that computes an

52
2. QUERY CONTAINMENT AND EQUIVALENCE
acyclic CQ. Another reason is that later, when we present algorithms for ﬁnding rewritings, part
of the algorithm is to compute the views on the canonical database of the query. Thus, when the
views are acyclic queries, this part of the algorithm is of lower complexity.
For query evaluation, we will give an algorithm whose runtime is polynomial both in the
size of the query and in the size of the data, as well as in the size of the output. Shortly we will
illustrate with examples that sometimes a query output may be empty, but in some cases the
query output can be exponential in the size of the input relations and the size of the query, even
if the CQ is acyclic.
The following is an example where the output of a conjunctive query is exponential in the
size of the input relations.
Example 2.47
Consider a query
q.X1; : : : ; Xn/ :- R1.X1; X2/; : : : ; Rn 1.Xn 1; Xn/:
For the relations mentioned in the query, let each attribute of each such relation accept
values from the domain f1; 2; 3; 4g. Let each relation consist of all the eight tuples that can be
formed using this domain, such that one component of each tuple is odd, and the other is even.
Then the output of the query consists of all the tuples that alternate odd and even components,
with the total of 2nC1 tuples. Yet the sum of the sizes of the n   1 input relations is only 8.n   1/.
The
semijoin algorithm, described below, has been developed to address the challenge
of handling intermediate query answers of size that could be exponential in the size of the
input and output data. When we say that we compute a semijoin of two relations r1 and r2, the
meaning is that we compute the query q. NX/ W  r1. NX/; r2. NY / (we use the notation NX for a vector
of variables), and then replace r1 with the result.
In the algorithm, the intent of the semijoin phase is to eliminate all the dangling tuples,
i.e., those tuples that will not contribute to the ﬁnal output; this is done by computing a series
of semijoin operations on the input relations. Then in the join phase, the algorithm performs a
series of joins on the semijoined relations. The dangling-tuple elimination in the semijoin phase
guarantees that the sizes of all the intermediate join outputs during the join phase are smaller
than or equal to the size of the ﬁnal output. We now discuss each phase in detail.
Semijoin Phase
Consider a parse tree T induced by the GYO-elimination of an acyclic query. The semijoin phase
of the semijoin algorithm operates as follows. The semijoin phase has two stages: the bottom-up
stage and the top-down stage. That is, one stage works from the leaves up on the parse tree, and
the other phase works from the root down toward the leaves.
Bottom-up stage: If the tree has more than one node, pick a leaf representing relation R, and let
S be the relation represented by the parent of this leaf.

2.5. ACYCLIC CQS
53
1. Replace S by the semijoin of S with R, that is, by the answer to the following query:
q. NY / :- R. NX/; S. NY /:
2. Remove the leaf for R from the tree.
3. Recursively process the resulting tree.
The top-down stage takes as input the relations computed during the bottom-up stage
and the parse tree of the join.
Top-down stage: If the tree has more than one node, begin with the root (say it represents relation
R), and let S1; : : : ; Si; : : : be the relations represented by all the children of R.
1. For each child S of R, replace S by the semijoin of S with R, i.e., by
q. NX/ :- R. NX/; S. NY /:
2. Mark S “ﬁnished” and mark R “discarded.”
3. Recursively process the resulting tree starting downward from those nodes/relations that
are marked “ﬁnished” but are not marked “discarded.”
In total, this algorithm performs 2.n   1/ semijoin operations.
Join Phase
In this phase, the algorithm performs a series of .n   1/ joins, in any bottom-up order on the
parse tree. We call a database instance locally consistent with respect to a CQ if the instance does not
have “locally dangling tuples.” This means that for any two subgoals of the query, all the tuples
in the corresponding relations are joined together—that is, there are no tuples that cannot ﬁnd
a match in the other relation. We can use the algorithm presented above to make a database
instance locally consistent with respect to an acyclic CQ. We call a database instance globally
consistent with respect to a CQ if every tuple of every relation participates in the join of all the
relations. For acyclic queries, the following holds: when a database instance is locally consistent,
then it is globally consistent. Thus, we can use this algorithm to compute an acyclic CQ in time
that is polynomial in the size of the query, of the database instance, and of the output of the
query on this database instance.

54
2. QUERY CONTAINMENT AND EQUIVALENCE
Evaluating a CQ acyclic query: The runtime of the algorithm is poly-
nomial in the number of subgoals in the query, the number of facts
in the database, and the number of facts in the answer to the query.
The algorithm follows the parse tree of the query and has two phases:
(a) the semijoin phase, which traverses the parse tree ﬁrst bottom up
and then top down, and makes the database instances locally consistent
by computing locally semijoins both ways (i.e., both up and down the
parse tree) and (b) the join phase, which traverses the parse tree bottom
up and computes the ﬁnal query answer.
2.6
QUERY EQUIVALENCE
Query equivalence can be checked by checking query containment both ways. In this section
we discuss an interesting property of CQ queries that are equivalent.
A CQ query Q is minimized if by deleting any subgoal we obtain a query that is not
equivalent to Q. We say then that a minimized query is a core of the given query. The following
result states that the core is unique in a precise sense.
Theorem 2.48
The core of a CQ query is unique up to isomorphism.
Proof. Suppose there are two diﬀerent cores. Then, since the cores are equivalent, there is a
containment mapping from one to the other, i.e., two containment mappings h12 and h21. The
composition of these two containment mappings produces a containment mapping, h1, of one
of the cores, call it c, to itself. This mapping h1 has to be an automorphism, otherwise c is not
a core (because an application of h1 would generate a proper subset of the alleged core with the
same properties). Thus, the containment mappings h12 and h21 (between the allegedly diﬀerent
cores) are one to one (otherwise h1 cannot be an automorphism). Thus, each of h12 and h21 is
an isomorphism.

Example 2.49
Consider queries q and q0:
q./ :- r.X; Y /; r.Y; X/; r.X; X/:
q0.X; Y / :- r.X; Y /; r.Y; X/; r.X; X/:
The core of q is
q./ :- r.X; X/;
and the core of q0 is
q0.X; Y / :- r.X; Y /; r.Y; X/; r.X; X/:

2.7. CONTAINMENT AND EQUIVALENCE FOR UNIONS OF QUERIES
55
The reason is, we cannot map X to Y in q0 as in q, due to the distinguished variables in
the head of q0. (Recall that distinguished variables are the variables in the query deﬁnition that
appear in the head of the deﬁnition.)
Consider now queries q1 and q2:
q1.X/ :- r.X; Y /; r.Y; X/; r.X; X/; s.X/:
q2.Y / :- r.X; Y /; r.Y; X/; r.X; X/; s.X/:
The core of q1 is
q1.X/ :- r.X; X/; s.X/;
and the core of q2 is
q2.Y / :- r.X; Y /; r.Y; X/; r.X; X/; s.X/:
The following algorithm minimizes a CQ, taking advantage of the uniqueness of the core:
Delete query subgoals, until no more subgoals can be deleted without compromising equivalence
with the original query. The proof is straightforward: it does not matter in which order subgoals
are deleted, because either subgoals not belonging to the core are deleted, hence equivalence is
not compromised, or subgoals belonging to the core are deleted, hence equivalence is compro-
mised.
2.7
CONTAINMENT AND EQUIVALENCE FOR UNIONS
OF QUERIES
Suppose we have queries belonging to the classes of unions of: CQ, or CQAC, or CQN queries.
In these cases, the problem of checking containment, for query Q2 in query Q1, reduces to the
problem of ﬁnding tests in which Q1 is a trivial union (i.e., a union with just one disjunct that is
a conjunctive query, possibly with ACs or negation). One can show that to prove containment,
it suﬃces to prove that each disjunct of the contained query is contained in the containing
query. The argument is that if there is a disjunct d of Q2 that is not contained in Q1, then a
counterexample database for containment of d in Q1 can be used as a counterexample database
for the containment of the entire Q2 in Q1.
Moreover, for the general case of Q1 belonging to the class of unions of CQs (i.e., without
arithmetic comparisons or negation), the following theorem holds:
Theorem 2.50
Let Q1 and Q2 be two queries in the language of unions of CQs. Query Q2 is
contained in query Q1 if and only if for each CQ in Q2, there is a CQ in Q1 that contains it.
Now, if we use the containment test with entailment for CQAC (Theorem 2.12), we add
to the entailment the OR of all the mappings from all the queries in the containing query to

56
2. QUERY CONTAINMENT AND EQUIVALENCE
the contained query, and also add the i.ˇj /, where i is a mapping from CQAC Qj, and ˇj
is the arithmetic comparisons of Qj. In particular, we have the following result.
Theorem 2.51
Let Q1 and Q2 be queries in the language of unions of CQACs. Let Q0
i1 D
Q0
i10 C ˇ0
i1; i D 1; 2; : : :, and Q0
j2 D Q0
j20 C ˇ0
j2; j D 1; 2; : : : be the CQAC queries in Q1 and
Q2, respectively, after normalization. Then Q2 is contained in Q1 if and only if the following holds
for each Q0
j2.
For each Q0
i10, let i1j ; : : : ; ik.i;j/j be all the containment mappings from Q0
i10 to Q0
j20 (as-
suming there is at least one such containment mapping). Then the following is true:
 W ˇ0
j2 )
_
i
ik.i;j/j .ˇ0
i1/:
The following example shows that, in contrast with the case of CQs, when checking con-
tainment of query Q2 in Q1 in those cases where both queries are unions of CQACs, it may be
necessary for Q2 to be contained in two or more disjuncts of Q1, rather than in a single disjunct
of Q1. Even if the contained query is a single CQAC, the containing query may need two or
more CQACs for the containment to hold.
Example 2.52
Consider query Q1 with disjuncts q11 and q12:
q11./ :- r.x/; x < 1;
q12./ :- r.x/; x D 1:
Let query Q2 be a CQAC query with a single disjunct:
Q2 W q2./ :- r.x/; x  1:
It can be shown that, while q2 is not contained in either q11 or q12, it is contained in their union.
Consider another example, in which Q2 is a CQ query.
Example 2.53
Consider query Q1 with disjuncts q11 and q12:
q11./ :- r.x/; x  1;
q12./ :- r.x/; x > 1:
Let query Q2 be a CQ query with a single disjunct:
q2./ :- r.x/:
It can be shown that q2 is not contained in either q11 or q12, but is contained in their union.
The tests that use canonical databases for CQACs and CQNs can be extended to the case
where the contained query is a union of CQACs or CQNs, respectively. We again form the
canonical databases of the contained query, and check whether the head of the containing query
can be computed.

2.8. EXERCISES
57
2.8
EXERCISES
2.1.
Theorem 2.21 presents a case where normalization is not needed. Examine the following
cases and prove or disprove that normalization is not needed.
(a) The case where there are no constants in the relational subgoals of the containing
query.
(b) The case where the contained query has only open arithmetic comparisons.
2.2.
Prove the following result.
Theorem 2.54
Let Q1 D Q1;0 C ˇ1 and Q2 D Q2;0 C ˇ2 be two left-semi-interval
(right-semi-interval, respectively) queries. Suppose that either (i) ˇ2 does not contain a closed
arithmetic comparison, or (ii) ˇ1 does not contain an open arithmetic comparison. Then
Q2 v Q1 if and only if there is a single containment mapping  from Q1;0 to Q2;0, such
that ˇ2 ) .ˇ1/.
2.3.
Prove the following result.
Theorem 2.55
Let Q1 be a conjunctive query with left semi-interval arithmetic-
comparison subgoals, and Q2 a conjunctive query with any arithmetic-comparison subgoals.
If Q1 and Q2 do not use constants, then the homomorphism property holds.
2.4.
Deﬁne canonical databases to be used in a query-containment test for the case where
the given conjunctive query contains both negation and arithmetic comparisons.
2.5.
Prove Theorem 2.30.
2.6.
Consider the following relational structures:
S1 W fr.X1; X2; X3/; p.X3; X4/gI
S0
1 W fp.Y; Y /gI
S2 W fr.Y1; Y2; Y2/; p.Y2; Y3/; s.Z; Y3/; p.Y2; Y 0
3/:
There are two homomorphisms from S1 to S2, h1 and h2:
h1 W
X1 ! Y1; X2 ! Y2; X3 ! Y2; X4 ! Y3I
h2 W
X1 ! Y1; X2 ! Y2; X3 ! Y2; X4 ! Y 0
3:
The homomorphism h1 maps the atom p.X3; X4/ to p.Y2; Y3/, while h2 maps the atom
p.X3; X4/ to p.Y2; Y 0
3/.
(a) Check and explain why these two are homomorphisms. Are there any other ho-
momorphisms from S1 to S2?

58
2. QUERY CONTAINMENT AND EQUIVALENCE
(b) How many homomorphisms are there from S0
1 to S2?
2.7.
Prove or disprove that for the following two CQs it is true that Q2 is contained in Q1
under set semantics.
(1) Q1./ :- p.A; B; C/; r.B; C; D/; r.F; C; B/:
Q2./ :- p.X; Y; Z/; r.Y; Z; Y /:
(2) Q1./ :- p.A; B; C/; r.B; C; A/; r.A; C; B/:
Q2./ :- p.X; Y; Z/; r.Y; Z; Y /:
(3) Q1./ :- p.X; Y; Z/; r.Y; Z; Y /:
Q2./ :- p.A; A; C/; r.A; C; C/; s.A; C; A/:
(4) Q1./ :- p.X; Y; Z/; r.Z; Z; Y /:
Q2./ :- p.A; A; C/; r.A; C; A/; r.A; C; C/:
2.8.
Give an argument that would prove or disprove that for the following two CQs it is true
that Q2 is contained in Q1 under bag semantics.
(1) Q1./ :- p.X; Y /:
Q2./ :- p.A; B/; p.A; B/:
(2) Q1./ :- p.X; Y /; p.X; Z/:
Q2./ :- p.A; B/; p.A; B/:
(3) Q1./ :- p.X; Y /:
Q2./ :- p.A; B/; s.A; C/:
2.9.
Prove or disprove that for the following two CQAs it is true that Q2 is contained in Q1
(please consider all the exercises here under set semantics).
(1) Q1./ :- r.X; Y /; X < 7:
Q2./ :- r.9; 7/; r.A; B/; A  B:
(2) Q1./ :- r.X; Y /; X  7:
Q2./ :- r.6; 7/; r.A; B/; A  B; B < 4:
(3) Q1./ :- p.X; Y /; X > Y:
Q2./ :- p.A; 3/; p.4; B/; A  B; B > 3:
(4) Q1./ :- p.X; Y /; X > Y:
Q2./ :- p.A; 3/; p.7; B/; A  B; B > 3:

2.8. EXERCISES
59
2.10. In the setting of Example 2.43, let the contents of the relations be as follows: R1 D f
.a; h; d; e/, .b; c; d; e/, .e; d; c; f /, .e; d; c; m/ g; R2 D f .b; h; e; g; i/, .f; g; h; i;
k/ g; R3 D f .e; d; c/, .l; d; c/ g; R4 D f .k; g/, .k; p/ g; and R5 D f .i; j /, .i; l/ g.
For these relations, compute the join of Example 2.43 by applying the algorithm from
Section 2.5.3 Show the detailed computations through all the stages of the algorithm.
2.11. Redo Exercise 2.10 with the following contents of the ﬁve relations: R1 D f .a; d; h;
e/, .b; c; d; e/, .e; d; c; f /, .e; d; c; m/ g; R2 D f .b; h; e; g; i/, .f; g; h; i; k/ g; R3 D
f .e; d; c/, .l; d; c/ g; R4 D f .k; g/, .k; p/ g; and R5 D f .i; j /, .i; l/ g.
2.12. Prove or disprove that for the following two UCQ queries it is true that Q2 is contained
in Q1.
(1) Q1./ :- p.A; B; C/; r.B; C; D/; r.F; C; B/:
Q1./ :- p.X; Y; Z/; r.Y; Z; Y /:
Q2./ :- p.X; Y; Z/; r.Y; Z; Y /:
Q2./ :- p.A; A; C/; r.A; C; C/; s.A; C; A/:
(2) Q1./ :- p.A; B; C/; r.B; C; D/; r.F; C; B/:
Q1./ :- p.A; B; C/; r.B; C; A/; r.A; C; B/:
Q2./ :- p.X; Y; Z/; r.Y; Z; Y /:
2.13. What are the cores of the following queries?
Q1.A; B; C/ :- p.A; B; C/; r.B; C; D/; r.C; C; B/:
Q2.A; B; C/ :- p.A; B; C/; r.B; C; D/; r.C; C; B/; r.F; C; B/:
2.14. Consider bag semantics. Prove that the following queries are not equivalent:
Q1.A; B; C/ :- p.A; B; C/; r.B; C; D/; r.C; C; B/:
Q2.A; B; C/ :- p.A; B; C/; r.B; C; D/; r.C; C; B/; r.F; C; B/:


61
C H A P T E R
3
Finding Equivalent Rewritings
In this chapter, we use query-containment and query-equivalence tests to ﬁnd equivalent rewrit-
ings of queries using sets of views. We cover the cases of CQ, CQAC, and CQN queries and
views, as well as aggregate queries. We generally restrict the discussion to the cases where we are
looking for a rewriting in the language of conjunctive queries, with or without ACs and nega-
tion. Furthermore, in the case of aggregate queries we restrict our consideration to the fragment
of the language of conjunctive queries with aggregation that is called “central rewritings.” Our
focus will be on ﬁnding (minimal) equivalent rewritings in an eﬃcient way. Other languages for
rewritings will be discussed in other parts of the book.
We begin by deﬁning the notions of expansion and canonical rewriting; for aggregate
queries, we will deﬁne a related notion of unfolding.
3.1
PRELIMINARIES
For a set V of views deﬁned on schema S, we denote by V.D/ the result of computing the views
in V on database D of schema S. That is, V.D/ D S
V 2V V.D/, where V.D/ contains the atom
v.t/ for each answer t to the view deﬁnition V on the database D.
Deﬁnition 3.1
Let Q be a query deﬁned on schema S, and V a set of views deﬁned on S.
Let R be a query formulated in terms of the view relations in the set V. We say that R is an
equivalent rewriting of Q using the views V iﬀfor any database D on the schema S:
R.V.D// D Q.D/:
The following example shows that the existence of an equivalent rewriting depends on the
language of the rewriting.
Example 3.2
Consider a query and views that are path queries. (Recall that Pi is the query
that asks for pairs of nodes on a graph connected by a path of length i—see also Deﬁnition 2.44
for path queries.) Let viewset V comprise two views deﬁned by the path queries P3 and P4.
This means that P3.X; Y / is a query over a schema of a single binary relation; on the graph
represented by that relation, the query ﬁnds pairs of nodes .X; Y / that are connected by a path
(not necessarily simple) of length 3. Similarly, P4.X; Y / ﬁnds pairs of nodes that are connected

62
3. FINDING EQUIVALENT REWRITINGS
by a path of length 4. Let query Q be P7. Then the following query R is an equivalent CQ
rewriting of Q in terms of the two views:
R.X; Y / :- P3.X; Z/; P4.Z; Y /:
Consider now a query Q0 deﬁned as P5. We will show in this chapter that there is no equiva-
lent CQ rewriting of Q0 using the views P3 and P4. However, there is an equivalent ﬁrst-order
rewriting R0 of Q0 in terms of these views:
R0.X; Y / :- 9Z Œ P4.X; Z/ ^ 8W ..P3.W; Z/ ! P4.W; Y // :
Later in the book we will formally prove that R0 is an equivalent rewriting of Q0. Here is some
intuition: Consider the ﬁrst node on a path of length 4 from X to Z; call that node W . The
second condition says that there is a path of length 4 from W to Y . Since there is also an edge
from X to W , there is a path of length 5 from X to Y .
In the remainder of the chapter, we will explore ways to formally prove that the rewritings
in the above examples are actually equivalent to the respective queries, and how to prove for the
query Q0 of Example 3.2 that there is no equivalent rewriting of the query in terms of the given
views, either in the language of CQ or in the language of unions of CQs.
Assumption: We assume that view deﬁnitions do not have repeated variables in their head.
We will discuss this restriction and ways to lift it in other chapters of the book. This assumption
holds in the rest of this book, except for those parts where it is lifted explicitly.
3.1.1
EXPANSION OF A REWRITING
The deﬁnition of equivalent rewriting does not depend on the languages of the queries, views,
or rewritings. When the given query and views are in the language CQACs, we can use the
expansion of the rewriting to show that the rewriting is equivalent to the query (or contained in
the query, as we will discuss shortly). First we deﬁne the notion of expansion for the case of CQ
queries, views, and rewritings.
Deﬁnition 3.3
(Expansion of a rewriting)
Suppose the given views and query are in the language of CQs, and the rewriting R is also a CQ
query. To construct the expansion Rexp of R, we replace each view subgoal gi of R, as follows.
• Suppose vj is the relation symbol of gi.
• We ﬁnd the mapping i from the variables in the head of the deﬁnition of the view vj to
the variables of gi that maps the variable in each position to the variable in the correspond-
ing position. (Such a mapping always exists and is unique due to the above assumption
about non-repetition of variables in view heads.)

3.1. PRELIMINARIES
63
• We use the mapping i to ﬁnd the set of subgoals that will replace gi in R to produce the
expansion Rexp of R.
– Apply i to the body of the deﬁnition of the view vj, replacing each distinguished
variable X in the atoms of the body by i.X/.
– Replace each nondistinguished variable in the deﬁnition of vj by a fresh distinct
variable. (This means that we maintain a set of fresh variables, to be used throughout
for all subgoals in the rewriting, of suﬃciently large cardinality—i.e., we assume have
an inﬁnite supply of fresh variables. Each nondistinguished variable Y is replaced by
a variable, say Z, from this set. Z is then removed from the set and is never reused
in the expansion.)
– We then replace gi in R with the resulting conjunction of subgoals from the body of
the deﬁnition of vj.
For CQAC queries, views, and rewriting, the deﬁnition of expansion is as follows. First
consider only the regular subgoals (together with the head of the deﬁnitions), and ﬁnd the ex-
pansion according to Deﬁnition 3.3. Then for each subgoal in the rewriting add the ACs that
appear in their view deﬁnition, as each AC is a subgoal in the deﬁnition. Finally, the ACs in the
rewriting are kept in the expansion.
Example 3.4
Consider query q and views v1 and v2:
q.X; Y / :- r.X; Z/; r.Z; Y /; r.X; Z0/; r.Z0; Y /; Z > 5; Z0 < 5:
v1.X; Y / :- r.X; Z/; r.Z; Y /; Z > 5:
v2.X; Y / :- r.X; Z/; r.Z; Y /; Z < 5:
The following query R is an equivalent CQ rewriting of q in terms of the views v1 and v2:
R.X; Y / :- v1.X; Y /; v2.X; Y /:
The expansion of the rewriting R is:
Rexp.X; Y / :- r.X; Z00/; r.Z00; Y /; Z00 > 5; r.X; Z0/; r.Z0; Y /; Z0 < 5:
Here, the ﬁrst three subgoals (two ordinary subgoals and an AC subgoal) come from expanding
the view subgoal v1.X; Y / in the rewriting R, and the last three subgoals come from expanding
the view subgoal v2.X; Y / in R. Notice that we have replaced the nondistinguished variable in
the body of the deﬁnition of v1.X; Y / with a fresh variable Z00, and used another fresh variable,
Z0, in the body of the deﬁnition of v2.X; Y /.

64
3. FINDING EQUIVALENT REWRITINGS
Let us construct the above expansion, by following the steps in Deﬁnition 3.1.1. The ﬁrst
subgoal g1 of R is v1.X; Y /, its view symbol is v1, so we consider the deﬁnition for view v1,
which is
v1.X; Y / :- r.X; Z/; r.Z; Y /; Z > 5:
The mapping 1 from the variables in the head of this deﬁnition, v1.X; Y /, to the variables of
the subgoal g1 D v1.X; Y / is 1 W fX ! X; Y ! Y g. We use the set fZ0; Z00g of fresh variables.
Then for the nondistinguished variable Z of v1 we have Z00 D 1.Z/. Thus, v1.X; Y / in R is
replaced with
fr.1.X/; 1.Z//; r.1.Z/; 1.Y //; 1.Z/ > 5g D fr.X; Z00/; r.Z00; Y /; Z00 > 5g:
For the other subgoal of R, g2, we consider the view deﬁnition
v2.X; Y / :- r.X; Z/; r.Z; Y /; Z < 5:
We then ﬁnd mapping 2 and proceed similarly to the case of g1.
Theorem 3.5
Suppose query Q, views V, and rewriting R all belong to the language of CQACs.
Then R is an equivalent rewriting of Q using the views V iﬀRexp  Q.
Proof. Let D be any database, and suppose R.V.D// D Q.D/. On D, we compute V.D/ by
using appropriate homomorphisms from the view deﬁnitions to D. Then on the instance V.D/,
we compute R, by using homomorphisms from the deﬁnition of R to V.D/. Now, any homo-
morphism h that computed a tuple t in R.V.D// can be combined with the homomorphisms
that computed the view tuples that h used in V.D/; thus, we have a homomorphism that com-
putes tuple t in Rexp.D/. We conclude that Rexp.D/ D R.V.D//, thus by transitivity of equality
we obtain Rexp.D/ D Q.D/.
For the other direction, suppose that Rexp  Q is true. Let D be any database. By con-
struction of Rexp, the homomorphism that computes a tuple t in Rexp.D/ can be decomposed
into a set of homomorphisms that compute tuples ti in V.D/ and a homomorphism that com-
putes t in R.V.D//, using the tuples ti. Thus, R.V.D// D Rexp.D/, hence R.V.D// D Q.D/.

3.1.2
CONTAINED REWRITINGS
In the next chapter, we present a detailed discussion of contained rewritings. At the same time,
as an equivalent rewriting is also a contained rewriting (see Deﬁnition 3.6 below), we comment
on contained rewritings in this chapter as well.
Deﬁnition 3.6
(Contained rewriting)
Let Q be a query deﬁned on schema S, and V a set of views deﬁned on S. Let R be a query

3.2. CQ QUERIES AND VIEWS
65
formulated in terms of the view relations in the set V. We say that R is a contained rewriting of
Q using the views V iﬀfor any database D it holds that R.V.D//  Q.D/.
Theorem 3.7
Suppose query Q, views V, and rewriting R all belong to the language of CQACs.
Then R is a contained rewriting of Q using views V iﬀRexp v Q.
The proof of this result is similar to that of Theorem 3.5.
Notice that when we use the term “rewriting,” we refer to a query (in some query language)
that is deﬁned on the schema of the view relations. Thus, a rewriting always has an expansion,
but is not necessarily associated with a speciﬁc query it is “supposed” to rewrite.
CQAC query and views, CQAC rewriting—expansion of a rewrit-
ing:
R is an equivalent rewriting of the given query iﬀthe expansion of the
rewriting is equivalent to the query.
R is a contained rewriting of the given query iﬀthe expansion of the
rewriting is contained in the query.
3.2
CQ QUERIES AND VIEWS
In this section we consider the case of rewriting CQ queries using CQ views. That is, we consider
the case of queries and views without arithmetic comparisons and without negation. Recall that,
unlike the case of CQAC queries, for CQ queries the containment test only needs one homo-
morphism to go through. This property allows for eﬃcient algorithms for ﬁnding an equivalent
rewriting, which is a conjunctive query in case such an equivalent rewriting exists. (If there is
no equivalent CQ rewriting of a CQ query in terms of CQ views, then no equivalent rewriting
can be found in the language of unions of CQs, for either inﬁnite or ﬁnite unions.)
3.2.1
CANONICAL REWRITINGS AND THE NAIVE ALGORITHM
Canonical Rewriting. Let DQ be the canonical database of Q. By computing the views on DQ,
we obtain view instance V.DQ/. We construct the canonical rewriting Rcan as follows. The body
of Rcan contains as subgoals exactly all the view tuples in V.DQ/, after we have replaced each
constant by the variable originally in the respective positions, and the tuple in the head of Rcan
is the same as the tuple in the head of the query Q. Conveniently, we use, throughout the book,
the upper-case-to-lower-case change in the variables to represent the replacement of variables
by constants. Consider an example that illustrates the construction.
Example 3.8
Let query Q be Q W q.X; Y / :- a.X; Z1/,a.Z1; Z2/; b.Z2; Y /, and let the views
V be deﬁned as: V1 W v1.X; Z2/ :- a.X; Z1/,a.Z1; Z2/ and V2 W v2.X; Y / :- b.X; Y /: Then DQ
contains the tuples fa.x; z1/, a.z1; z2/, b.z2; y/g, and V.DQ/ contains the tuples fv1.x; z2/,

66
3. FINDING EQUIVALENT REWRITINGS
v2.z2; y/g. The canonical rewriting Rcan in this case is Rcan.X; Y / :- v1.X; Z2/, v2.Z2; Y /; it
happens to be equivalent to the query Q.
The following result can be used in those cases where we would like to show that there is
no equivalent CQ rewriting of a CQ query using a set of CQ views.
Proposition 3.9
Let Q be a CQ query, and V be a set of conjunctive views. Let Rcan be the canonical
rewriting. If there exists a conjunctive query that is an equivalent rewriting of Q using V, then Rcan
is such a rewriting.
Proof. Suppose there is an equivalent CQ rewriting R of Q using V. First observe that, by
construction of Rcan, there is a containment mapping from its expansion Rexp
can to Q. We will
show that there is also a containment mapping from Q to Rexp
can.
Since R is an equivalent rewriting of Q, there is a homomorphism from Rexp to Q. This
homomorphism can be decomposed to compute the view tuples in DQ; hence, all the subgoals
in R are also subgoals in Rcan. It follows that there is a homomorphism from Q to Rexp
can, because
of the homomorphism from Q to Rexp.

Example 3.10
We build here on the setting of Example 3.2. Recall that the set of views given
in Example 3.2 comprises two views, which are path queries P3 and P4. First consider query Q,
which is the path query P7. A canonical database of the query Q D P7 is
DQ D f.1; 2/; .2; 3/; .3; 4/; .4; 5/; .5; 6/; .6; 7/; .7; 8/g:
If we compute the two views on DQ, we obtain a set with the elements
P3.1; 4/; P3.2; 5/; P3.3; 6/; P3.4; 7/; P3.5; 8/; P4.1; 5/; P4.2; 6/; P4.3; 7/; P4.4; 8/:
From this collection, we derive a rewriting that consists of nine subgoals, corresponding to the
above nine atoms. Consider the following rewriting:
R.X1; X8/ :- P3.X1; X4/; P4.X4; X8/:
This rewriting can be obtained from the canonical rewriting after deleting some subgoals. Specif-
ically, it is obtained by replacing each integer i in the canonical database DQ by Xi in the rewrit-
ing. It can be shown that the expansion of this rewriting is contained in P7. Hence, the rewriting
is an equivalent rewriting of P7 using the views P3 and P4. (In Section 3.2.3 we will discuss how
such a minimal rewriting can be obtained systematically.) This is the rewriting mentioned in Ex-
ample 3.2.
Now consider the query Q0 of Example 3.2; recall that it is the path query P5.
We now prove that there is no equivalent CQ rewriting of Q0 using the views P3 and

3.2. CQ QUERIES AND VIEWS
67
P4. Let us compute the above views on the canonical database DQ0 of Q0 D P5: DQ0 D
f1; 2/; .2; 3/; .3; 4/; .4; 5/; .5; 6/g. The result of the computation is the collection
fP3.1; 4/; P3.2; 5/; P3.3; 6/; P4.1; 5/; P4.2; 6/g:
The canonical rewriting has ﬁve subgoals:
Rcan.X1; X6/ :- P3.X1; X4/; P3.X2; X5/; P3.X3; X6/; P4.X1; X5/; P4.X2; X6/:
The expansion of the rewriting Rcan is
Rexp
can.X1; X6/ :- r.X1; Z2/; r.Z2; Z3/; r.Z3; X4/;
r.X2; Z0
2/; r.Z0
2; Z0
3/; r.Z0
3; X5/; r.X3; Z00
2/; r.Z00
2; Z00
3/; r.Z00
3; X6/;
r.X1; W1/; r.W1; W2/; r.W2; W3/; r.W3; X5/; r.X2; W 0
1/; r.W 0
1; W 0
2/; r.W 0
2; W 0
3/; r.W 0
3; X6/:
It is straightforward to check that there is no containment mapping from P5 to Rexp
can. It follows
that Rcan is not an equivalent rewriting of P5. Thus, according to Proposition 3.9, there is no
equivalent rewriting of P5 in the language of CQ rewritings using the views P3 and P4.
Proposition 3.9 gives rise to the following sound and complete naive algorithm for ﬁnding
a CQ equivalent rewriting for CQ query and views, in case such a rewriting exists.
1. Compute all the views on the canonical database of the query.
2. Form the canonical rewriting.
3. Check whether there is a containment mapping from Q to the expansion of the rewrit-
ing; if so, return the canonical rewriting as an equivalent rewriting. Otherwise, return “no
equivalent CQ rewriting exists.”
For an equivalent CQ rewriting R of query Q in terms of a given viewset, R is minimal if
deleting any subgoal from R results in a rewriting that is not equivalent to Q. We can minimize
a rewriting by deleting views, as long as we still have a containment mapping from the query
to the expansion of the rewriting. In particular, we can do the following: For each containment
mapping from Q to the expansion, to obtain a candidate rewriting, delete all the views that
do not participate as targets in the containment mapping. We repeat the procedure for each
candidate rewriting, until all the containment mappings use the expansions of all the views as
targets. The result is the set of all the minimal rewritings.
As we will discuss in Section 3.2.3, we can do better than this algorithm, as for some
individual views it is easy to tell just from their deﬁnitions whether they can participate in any
equivalent CQ rewriting.
CQ query and views—equivalent rewriting: There is an equivalent
rewriting of the given query in the language of CQs iﬀthe canonical
rewriting is such a rewriting.

68
3. FINDING EQUIVALENT REWRITINGS
3.2.2
PROPERTIES OF THE EXPANSION
Because of the way an expansion is constructed, it has certain properties that can be exploited
to obtain more eﬃcient algorithms for ﬁnding both minimal equivalent rewritings and con-
tained rewritings. Given an expansion Rexp of a rewriting R of query Q in terms of views in set
fV1; : : : ; Vi; : : :g, we can partition the variables in Rexp into two classes.
• The variables that come from replacing nondistinguished variables of some view deﬁnition
with a fresh variable. We call those variables non-exported variables; the intuition is that
they cannot “communicate” with other variables outside the particular view.
• The rest of the variables are called exported variables. Among them are all the variables that
appear in the head of the expansion.
We can further partition the non-exported variables to s view-classes, where s is the num-
ber of subgoals in the rewriting, one class for each subgoal in the rewriting. Thus, a non-exported
variable belongs to view-class T Ci if it has been created from expanding the ith subgoal in the
rewriting, according to its view deﬁnition.
We call a subgoal of Rexp non-exported if it contains at least one non-exported variable.
All other subgoals are called exported subgoals.
Example 3.11
In Example 3.10, we provided the expansion Rexp
can.X1; X6/ of the path query
P5 using the views that are path queries P3 and P4. We reproduce Rexp
can below:
Rexp
can.X1; X6/ :- r.X1; Z2/; r.Z2; Z3/; r.Z3; X4/;
r.X2; Z0
2/; r.Z0
2; Z0
3/; r.Z0
3; X5/; r.X3; Z00
2/; r.Z00
2; Z00
3/; r.Z00
3; X6/;
r.X1; W1/; r.W1; W2/; r.W2; W3/; r.W3; X5/; r.X2; W 0
1/; r.W 0
1; W 0
2/; r.W 0
2; W 0
3/; r.W 0
3; X6/:
This expansion has 6 exported variables (they are the Xi’s) and 12 non-exported variables (these
are all the other variables in the expansion).
The non-exported variables of the expansion can be partitioned into ﬁve view-classes,
as follows. The ﬁrst three subgoals in Rexp
can.X1; X6/ come from replacing the ﬁrst subgoal
P3.X1; X4/ of Rcan.X1; X6/ using the view deﬁnition for view P3—recall that this view def-
inition is P3.X; Y / :- r.X; A/; r.A; B/; r.B; Y /. The ﬁrst three subgoals of the expansion use
two non-exported variables, Z2 (to represent A in the view deﬁntion) and Z3 (to represent B in
the view deﬁntion); thus, these two variables belong to the view class T C1.
Similarly, for the second subgoal in the rewriting, we have that the variables Z0
2 and Z0
3
belong to view-class T C2. Then, for the third subgoal in the rewriting we have that variables Z00
2
and Z00
3 belong to view-class T C3. Similarly, the variables Wi belong to view-class T C4, and the
variables W 0
i belong to view-class T C5.
All the subgoals in this rewriting are non-exported.
Note that the rewriting R in this example is not a contained rewriting of query P5.

3.2. CQ QUERIES AND VIEWS
69
Suppose R is a contained rewriting of Q using a set of views. Then any containment map-
ping  from Q to the expansion Rexp of R has the following property:  can be decomposed
into partial containment mappings, one mapping i for each subgoal gR
i
in R. In particular,
i.X/ D .X/ if .X/ is a variable in the expansion of subgoal gR
i in R. These partial con-
tainment mappings have an important property, the shared-variable property, which is useful in
ﬁnding rewritings eﬃciently. This property is deﬁned as follows.
Deﬁnition 3.12
(Shared-variable property)
Let queries Q and Q0 be CQs. Consider the relational structure S of all the atoms that are
subgoals in the body of CQ Q, and let S0 be any substructure, i.e., subset, of S. Let h be a
homomorphism from the substructure S0 to the relational structure that comprises the subgoals
of Q0. We say that the triple .S; S0; h/ has the shared-variable property if the following is true for
each nondistinguished variable Y of Q0 that is a target of h: Suppose X is a variable that appears
in an atom in S0 for which h.X/ D Y . Then all the atoms of S that contain X are in S0.
If the triple .S; S0; h/ has the shared-variable property, we say that .S; S0; h/ covers the
query subgoals in S0.
Example 3.13
To illustrate the shared-variable property, we consider the following two queries
and two views. (Recall that when there are no variables in the head of the query, the query is
called Boolean query, i.e., its output is “true” or “false.”)
Q1./ :- a.A; B/; c.B; C/:
Q2./ :- a.A; B/:
V1.X; Y / :- a.X; Z/; b.Z; Y /:
V2.X; Y; Z/ :- a.X; Z/; b.Z; Y /:
For the query Q1 and view V1, we take the homomorphism h1: A to X and B to Z. We take
a.A; B/; c.B; C/ for S and only one atom a.A; B/ for S0. Then the triple .S; S0; h1/ does not
have the shared-variable property, because Z is a nondistinguished variable in the deﬁnition
of V1, and B (which maps to Z according to h1) also appears in the subgoal c.B; C/ of Q1,
which (subgoal) is not in S0. However, if we take the query Q1 and view V2, then the triple
.S; S0; h1/ has the shared-variable property, because now Z appears in the head of V2, hence it
is a distinguished variable in the deﬁnition of V2.
For the query Q2 and view V1, the triple .S; S0; h1/ has the shared-variable property,
because the variable B in Q2 does not appear in any other subgoal of Q2.

70
3. FINDING EQUIVALENT REWRITINGS
In both theorems that follow, we use the phrase “homomorphism (or containment map-
ping)  can be decomposed.” By “decomposed” we mean that we can ﬁnd one or more homo-
morphisms i that are restrictions of , such that all variables that appear in  appear in at least
one of the is. The shared-variable property is useful because of the following theorem:
Theorem 3.14
Suppose R is a contained CQ rewriting of a CQ query Q using a set of CQ views.
Let Rexp be the expansion of the rewriting R. Then any containment mapping  from the query to
Rexp can be decomposed into a number of homomorphisms, one homomorphism i for each subgoal in
the rewriting R, as follows.
• Let S0 be the set of those subgoals in Q that map to those subgoals of Rexp that come from expand-
ing the i-th subgoal of the rewriting R, and
• let i be deﬁned as the restriction of  to those variables that appear in S0.
Let S be all the atoms in the body of Q. Then the triple .S; S0; i/ has the shared-variable property.
Proof. A containment mapping is a homomorphism from the data structure of the query sub-
goals to the data structure of the subgoals in the expansion. Consider in the body of the expansion
only those atoms in the set Si that come from expanding a certain subgoal of the rewriting, say
subgoal gi. Now gi uses a view deﬁnition, say for view vi. Restrict  to those atoms Si, and
from there to those atoms in the body of Q that map (according to ) to Si. Let Y 0 be a nondis-
tinguished variable of the deﬁnition of vi, and let Y be the fresh variable that replaced Y 0 to
form the expansion. Then consider the variable X of Q such that Y D .X/. Suppose there is
a subgoal g of Q that contains X, such that g does not map to an atom in Si. This means that
there is another atom, ga, which has arisen from expanding a view subgoal of the rewriting that
(subgoal) was not gi, and that  maps g to ga. Since  is a homomorphism, Y D .X/, and g
contains X, ga should contain Y . This is, however, impossible by construction of the expansion,
because Y is a non-exported variable of the expansion.

In those cases where the rewriting is an equivalent rewriting, the result of Theorem 3.14
can be strengthened.
Theorem 3.15
Suppose R is an equivalent CQ rewriting of a CQ query Q using a set of CQ views.
Suppose the view and query deﬁnitions are minimized, and the rewriting is minimal.
Let Rexp be the expansion of the rewriting R. Then any one-to-one containment mapping, ,
from the query to Rexp can be decomposed into a number of one-to-one mappings, one mapping i for
each subgoal in the rewriting R, as follows.
• Let S0 be the set of the subgoals of Q that map to the subgoals of Rexp coming from expanding the
i-th subgoal of the rewriting R, and
• let i be deﬁned as the restriction of  to those variables that appear in S0.

3.2. CQ QUERIES AND VIEWS
71
Let S be all the atoms in the body of Q. Then the triple .S; S0; i/ has the shared-variable property.
We will use Theorem 3.14 in the next chapter, to construct maximally contained rewrit-
ings. Here we use Theorem 3.15 to describe an eﬃcient algorithm to ﬁnd equivalent CQ rewrit-
ings for CQ queries and views. The interesting observation from Theorem 3.15 is that if a view
tuple from the canonical rewriting participates in any minimal equivalent rewriting, then we
can ﬁnd, for each view independently, a one-to-one containment mapping v from some query
subgoals S0 to its subgoals, such that the shared-variable property holds. The sense in which the
shared-variable property holds is that the triple .S; S0; v/, where S is the set of all subgoals of
the query, has the shared-variable property. Thus, there exists a maximal S0 for which we can
ﬁnd a one-to-one containment mapping v. We call this maximal S0 the tuple core of the view
tuple (i.e., of the subgoal from the canonical rewriting).
Algorithm CoreCover of the next section is based on Theorem 3.15; the algorithm works
by ﬁnding those tuple cores that cover all the subgoals of the query.
CQ query and views—property of the expansion: The rewriting ex-
pansion has the shared-variable property. This enables each homo-
morphism from the query to the expansion to be decomposable into
rewriting-independent sub-homomorphisms. This enables algorithm
CoreCover to ﬁnd eﬃciently an equivalent rewriting, without necessarily
having to consider all the views (as when we use the canonical rewrit-
ing). There are more beneﬁts of this algorithm; for instance, whenever
a view is found to not contribute to the rewriting, it can be removed
from further consideration.
3.2.3
ALGORITHM CORECOVER
We now introduce algorithm CoreCover based on Theorem 3.15. Recall that in Example 3.10
we noticed that if the canonical rewriting is an equivalent rewriting, in general we can still
delete some of its subgoals and get an equivalent CQ rewriting with fewer subgoals. Algorithm
CoreCover does that systematically. We say that a query subgoal is covered by a certain tuple core
if it belongs to the subset from which the containment mapping is considered.
1. For each subgoal in the canonical rewriting, ﬁnd its tuple core.
2. Construct candidate equivalent rewritings, by taking those subgoals of the canonical
rewriting that cover all the subgoals of the query.
3. Check each resulting candidate rewriting for containment in the query.

72
3. FINDING EQUIVALENT REWRITINGS
A tuple core can be empty, in which case we ignore this view tuple in the rewriting, since it
cannot contribute to the containment mapping from the query to the expansion of the rewriting.
Consider an example:
Example 3.16
Let view V1 and query Q be as follows:
V1.X; Y / :- r.X; Z/; r.Z; Y /;
Q.A/ :- r.A; A/; s.A; Z0/; s.Z0; Y 0/:
The canonical rewriting R.V1/
can using only the view V1 is R.V1/
can .A/ :- V1.A; A/. The expansion of
the single subgoal, V1.A; A/, of the canonical rewriting is r.A; B/; r.B; A/. There is no one-to-
one partial containment mapping from subgoals of Q to the atoms r.A; B/; r.B; A/. (Actually,
there is no containment mapping at all.) Hence, the tuple core of V1.A; A/ is empty, and V1 will
not be used for any equivalent rewriting, even if more views were available in the given viewset.
Now consider the following view V2:
V2.X; Y / :- s.X; Z/; s.Z; Y /:
The canonical rewriting in terms of this view is R.V2/
can .A/ :- V2.A; Y 0/. The expansion of the single
subgoal, V2.A; Y 0/, of the canonical rewriting is s.A; Z0/; s.Z0; Y 0/. There is a one-to-one map-
ping from the last two subgoals of the query Q to s.A; Z0/; s.Z0; Y 0/—the mapping maps each
variable to its same-name counterpart. Hence, the tuple core of V2.A; Y 0/ is s.A; Z0/; s.Z0; Y 0/.
Thus, view V2 may be used in an equivalent rewriting if more views were available in the viewset,
e.g., if we also had a view
V3.A/ :- r.A; A/:
Indeed, the view V3 has the tuple core r.A; A/, and we can use it and V2 to form the following
equivalent rewriting of the query Q:
R.A/ :- V3.A; /; V2.A; Y 0/:
The algorithm CoreCover ensures a minimal number of subgoals in rewritings. It can also be
modiﬁed for use with other objectives. For instance, if we have many views, and it is impractical
to consider all of the them, then we can stop considering views (i.e., can stop computing view
tuples on the canonical database of the query) when the CoreCover algorithm has covered all
the subgoals of the query. This is much more eﬃcient than considering the canonical rewriting,
which will contain a large number of subgoals in such cases (i.e., when we have a large number
of views).

3.3. ACYCLIC CQ VIEWS
73
3.3
ACYCLIC CQ VIEWS
We now consider the case where the available views belong to the language of acyclic CQs. We
have already seen in Section 2.1.2 how CQ query evaluation and query containment are related.
Thus, we can use the eﬃcient algorithm for acyclic-CQ query containment to evaluate the views
on the canonical database of the query. The computation of the views will take time polynomial
in the size of query and in the maximum size of any view deﬁnition, multiplied by the number
of views.
3.4
CQAC QUERIES AND VIEWS
Consider the case where the query, views, and rewriting belong to the language CQAC. In the
case of conjunctive queries without arithmetic comparisons, if an equivalent rewriting exists in
the language of unions of conjunctive queries, then there exists one that is a single conjunctive
query. However, for conjunctive queries with arithmetic comparisons this property does not
hold. Indeed, even for very simple cases of conjunctive queries and views with arithmetic com-
parisons, it is often not possible to ﬁnd equivalent rewritings in the form of a single conjunctive
query with arithmetic comparisons. Still, it may be possible to ﬁnd equivalent rewritings in the
form of unions of conjunctive queries with arithmetic comparisons, as the following example
illustrates.
Example 3.17
A CQAC equivalent rewriting of a query may not exist even when the input
query has no ACs. At the same time, a union-of-CQAC equivalent rewriting may exist.
Consider query Q and views V1 and V2:
Q W q./ :- p.X/:
V1 W v1./ :- p.X/; X  0:
V2 W v2./ :- p.X/; X < 0:
We can show that there is no conjunctive query that is an equivalent rewriting of Q using
V1 and V2. Instead, the following union of conjunctive queries is an equivalent rewriting:
r0./ :- v1./:
r0./ :- v2./:
The following example illustrates a diﬀerent challenge.
Example 3.18
Consider query Q and views V1 and V2:
Q W q.X; X/ :- a.X; X/; b.X/; X < 7:

74
3. FINDING EQUIVALENT REWRITINGS
V1 W v1.T; U / :- a.S; T /; b.U /; T  S; S  U:
V2 W v2.T; U / :- a.S; T /; b.U /; T  S; S < U:
The query R W q.A; A/ :- v1.A; A/; A < 7 is an equivalent rewriting of Q using V1. To see why,
suppose that we expand R by replacing the view subgoal v1.A; A/ by its deﬁnition; we obtain
the expansion Rexp W q.A; A/ :- a.S; A/; b.A/; A  S; S  A; A < 7. By equating S and A,
which is permissible due to S  A and A  S, we see that the AC A < 7 also applies, resulting
in S < 7. Hence, the expansion is equivalent to Q. Notice that the deﬁnitions of the views V1
and V2 diﬀer only in their respective second inequalities. However, V2 cannot be used to answer
Q. Thus, it is the comparison subgoal that aﬀects the existence of the rewriting.
3.4.1
ALGORITHMS FOR FINDING EQUIVALENT REWRITINGS FOR
QUERIES AND VIEWS WITH ACS
For the general case of CQAC queries and views, there is an algorithm for ﬁnding a CQAC
equivalent rewriting, and there is an algorithm to ﬁnd a union-of-CQAC equivalent rewriting,
if such a rewriting exists. The following two results establish these facts, by showing that if there
is such a rewriting, then there is a short one, i.e., with a number of subgoals in its deﬁnition that
is bounded by a function of the number of subgoals in the query and in the view deﬁnitions.
Theorem 3.19
(CQAC Equivalent Rewriting) For a query Q and views in the language of con-
junctive queries with arithmetic comparisons, there is an algorithm for ﬁnding an equivalent rewriting
in the language CQAC, if such a rewriting exists.
Proof. Suppose that for query Q, there exists an equivalent CQAC rewriting R. Let Rexp be its
expansion. We will show that there is an equivalent rewriting R0, whose size is bounded by a
function of the size of the query and views deﬁnitions. We consider homomorphisms from the
expansion Rexp to query Q after imposing total orderings on the variables of Q. We consider all
the total orderings of the variables and constants of Q that satisfy the arithmetic comparisons
in Q. For each total ordering, there must be a homomorphism from Rexp to Q that satisﬁes the
arithmetic comparisons in Rexp. For each variable of Rexp we construct a list of the variables of
Q, such that each of these homomorphisms sends the variable of Rexp to that variable. We say
that two variables of Rexp are “equivalent” if their lists are the same. Since the lists are of bounded
length, and each entry on the list has one of the values from the variables of Q only, there is a
bounded number of equivalence classes.
We now construct from R a new rewriting R0 that equates all the “equivalent” variables.
The expansion R1exp of R0 is contained in Rexp, since all we did was equate variables, thus restrict-
ing each of R and Rexp. Moreover, R1exp has containment mappings to Q for all the orderings,
since all we did was equate variables that always went to the same variable of Q anyway. Thus,
Q is contained in R0. Since Q contains Rexp, which contains R1exp, it is also true that R1exp is

3.4. CQAC QUERIES AND VIEWS
75
contained in Q. Thus, R0 is another equivalent rewriting of Q. It follows that there is a bound
on the number of subgoals in R0. Thus, in order to ﬁnd an equivalent rewriting of Q in terms of
the input views, we need to look only at a bounded number of solutions.

Theorem 3.20
(Union-of-CQAC Equivalent Rewriting) For a query Q and views in the lan-
guage of conjunctive queries with arithmetic comparisons, there is an algorithm to ﬁnd an equivalent
rewriting in the language of unions of CQACs, if such a rewriting exists.
Proof. We extend the proof of Theorem 3.19 to the case where an equivalent rewriting is a
union of CQACs. Let R be a union of CQACs that is an equivalent rewriting of Q. Similarly
to the proof of Theorem 3.19, we consider all orderings of the variables in Q that satisfy the
arithmetic comparisons in Q. Now, however, for each ordering, there must be a containment
mapping from the expansion of one of the CQACs of R to Q that preserves the ordering. Then,
for each CQAC in R, we argue as in the proof of Theorem 3.19 to show that we need to look
only at solutions of bounded size for each CQAC of R.

CQAC queries and views—ﬁnding equivalent rewritings: There are
algorithms for ﬁnding equivalent rewritings in the language of CQAC
and in the language of unions of CQACs—if such rewritings exist. The
algorithms are not eﬃcient, in that they consider exhaustively all the
combinations of view subgoals, up to a certain number of subgoals.
3.4.2
WHEN THE HOMOMORPHISM PROPERTY HOLDS
The crux of the problem of rewriting conjunctive queries using views lies in ensuring that the
expansion of the rewritten query is contained in the original query. Testing for containment
of conjunctive queries with arithmetic comparisons can be done more eﬃciently when the ho-
momorphism property holds. Deﬁnition 2.25 in Chapter 2 deﬁnes AC-canonical databases of a
CQAC query; in those cases where the homomorphism property holds, such databases have
the good property pointed out in Theorem 2.26. This justiﬁes the following deﬁnition of AC-
canonical rewritings.
Deﬁnition 3.21
For a CQAC query Q and a set of CQAC views V, an AC-canonical rewriting
of Q using V is a rewriting that uses the view tuples computed on the AC-canonical database
(see Deﬁnition 2.25), in the following sense: A tuple t is in the AC-canonical rewriting if and
only if the homomorphism that computes t is such that the ACs of the AC-canonical database
imply the image of the ACs in the view deﬁnition.

76
3. FINDING EQUIVALENT REWRITINGS
We use Theorem 2.26 to prove the following.
Theorem 3.22
Let .B1; B2/ be a pair of sets of arithmetic comparisons that enables the homomor-
phism property. Let V be a set of CQAC views with all the ACs in their deﬁnitions belonging to the
class B1, and Q be a CQAC query whose all ACs belong to B2. Then, if there is a CQAC equivalent
rewriting of Q using V, the AC-canonical rewriting with possibly additional ACs is such a rewriting.
The additional ACs need only consider constants that already appear in the query Q.
Consider the following query and views.
Example 3.23
Q W q./
:- r.X; Y /; r.Y; Y /; s.W; Y /; Y  W; W  5; X  2:
V1 W v1.Y /
:- r.X; Y /; r.Y; Z/; Z  8; X  3:
V2 W v2.Y /
:- s.W; Y /; Y  W; W  5:
V3 W v3.Y /
:- s.W; Y /; W  15:
V4 W v4.Y /
:- s.W; Y /; W  1:
The AC-canonical database of Q is D D fr.x; y/; r.y; y/; s.w; y/; y  w; w  5; x  2g.
Now we evaluate the four views on this AC-canonical database. The result is the following view
instance on D: DV D fv1.y/; v2.y/; v3.y/g. Notice that for the view V4, there are no tuples in
DV , because the homomorphism h from the subgoals of V4 to D does not satisfy the ACs.
Now the canonical rewriting is
R./ :- v1.Y /; v2.Y /; v3.Y /:
The expansion of this rewriting is
Rexp./ :- r.X; Y /; r.Y; Z/; Z  8; X  3; s.W; Y /; Y  W; W  5; v3.Y /; s.W; Y /; W  15:
Now, if Rexp is equivalent to Q, then there is an equivalent CQAC rewriting of Q using the four
given views; this rewriting is the canonical rewriting. If Rexp is not equivalent to Q, then there
is no equivalent CQAC rewriting of Q using the given views.
CQAC query and views—the homomorphism property: When the
homomorphism property holds, i.e., one homomorphism from the ex-
pansion of the rewriting to the query suﬃces to prove the containment
of the query in the expansion, then the canonical rewriting can be de-
ﬁned and be useful: If there is an equivalent rewriting in the language
CQAC, then the canonical rewriting, possibly with arithmetic com-
parisons added, is such a rewriting.

3.5. REWRITING CQN QUERIES USING CQN VIEWS
77
3.5
REWRITING CQN QUERIES USING CQN VIEWS
We consider queries and views that are CQs with safe negation, and further restrict our consider-
ation to the cases in which all the variables in view deﬁnitions are distinguished, i.e., are all used
in the heads of the view deﬁnitions. Recall that we have deﬁned CQNs with safe negation to be
those queries in which the variables in the negated subgoals also appear in some non-negated
subgoal.
As in the case of CQAC queries and views, here we may also have an equivalent rewriting
in the language of unions of CQNs, but not in the language CQN. Consider an example.
Example 3.24
Consider CQ query Q and CQN views V1 and V2:
Q W q.X; Y / :- a.X; Y /:
V1 W v1.X; Y / :- a.X; Y /; b.Y /:
V2 W v2.X; Y / :- a.X; Y /; :b.Y /:
The following union of CQ queries is an equivalent rewriting of Q using V1 and V2:
q.X; Y / :- v1.X; Y /;
q.X; Y / :- v2.X; Y /:
Note that there is no equivalent CQ rewriting of Q using V1 and V2.
Before we give a formal deﬁnition of a notion whose functionality is the same as the notion of
expansion for CQAC queries and views (and prove a result that is analogous to Theorem 3.5),
we discuss the issue using an example:
Example 3.25
In this example, in the bodies of the queries we use ^ instead of comma, to
emphasize the fact that it is a logical expression that is a conjunction of atoms. We consider
rewriting R and views V, and discuss the intuition for deﬁning an expansion Rexp such that, for
any database D, we have R.V.D// D Rexp.D/. Consider the following rewriting R and views
V1 and V2.
R.X; Y; Z/ :- :v1.X; Y; Z/ ^ v2.X; Y; Z/:
V1 W v1.X; Y; Z/ :- a.X; Y / ^ :a.Y; Z/:
V2 W v2.X; Y; Z/ :- b.X; Y / ^ b.Y; Z/:
Intuitively, we can get the expansion of the rewriting by replacing the view subgoals with the
view deﬁnitions, while maintaining the notation with logical operators:
Rexp.X; Y; Z/ :- :

a.X; Y / ^ :a.Y; Z/

^

b.X; Y / ^ b.Y; Z/

:

78
3. FINDING EQUIVALENT REWRITINGS
That is:
Rexp.X; Y; Z/ :-

:a.X; Y / ^ b.X; Y / ^ b.Y; Z/

_

a.Y; Z/ ^ b.X; Y / ^ b.Y; Z/

:
If we write the disjunction as a union, then Rexp is in the language of unions of CQNs:
Rexp.X; Y; Z/ :- :a.X; Y / ^ b.X; Y / ^ b.Y; Z/;
Rexp.X; Y; Z/ :- a.Y; Z/ ^ b.X; Y / ^ b.Y; Z/:
Indeed, for this deﬁnition of expansion, we have, for all D, R.V.D// D Rexp.D/.
We now formalize the concept of expansion of a rewriting for CQN queries and views.
Deﬁnition 3.26
Let Q be a CQN query, V a set of CQN views, and R a CQN equivalent
rewriting of Q using V . The expansion of R, denoted Rexp, is obtained as follows: replace each
view atom in R with the body of the corresponding view deﬁnition, with each nondistinguished
variable replaced by a fresh variable. The body of R is thus a logical expression that may no longer
be representable as a conjunction of literals (see Example 3.25). We put this logical expression
into the disjunctive normal form. Now each disjunct is used to form a CQN. Rexp then becomes
a union of CQNs, as follows: each disjunct of the logical expression is a CQN in the union, and
the head of Rexp is the same as the head of R.
Theorem 3.27
Suppose query Q, views V, and rewriting R all belong to the language of CQNs.
Suppose the views have no nondistinguished (a.k.a. existential) variables in their deﬁnition. Then R
is an equivalent rewriting of Q using the views V iﬀRexp  Q.
Proof. We show that Rexp.D/ D R.V.D// for every D; this suﬃces to prove the result. We will
ﬁrst show that R.V.D// is contained in Rexp.D/ for every D.
We say that a subgoal of a query, view, or rewriting is negative if it has the negation symbol
: on its atom, otherwise we say it is positive. To compute V.D/, we consider homomorphisms
from the positive subgoals of the view deﬁnitions, such that the negated subgoals in these deﬁ-
nitions are not in D. To compute R.V.D//, we consider homomorphisms from the body of R
on V.D/, such that the negated view subgoals in R are not in V.D/.
Tuple t is in R.V.D// because (i) of homomorphisms i from the positive subgoals of the
view deﬁnitions to D, which compute tuples vj .i. NX//, and homomorphism  from positive
subgoals of R to V.D/ that uses the view tuples computed by i’s to compute t; and (ii) of the
lack of any homomorphisms i that computes a .ti/ for any negative subgoal vj .ti/ in R. In
particular, (ii) means that either there is no homomorphism from the positive subgoals of vj
to produce vj .ti/, or that for any homomorphism i, there is a negative subgoal :a. NX/ in the
deﬁnition of vj, such that a.i. NX// is in D.

3.5. REWRITING CQN QUERIES USING CQN VIEWS
79
Now we compose the homomorphisms i from the positive view subgoals in R with the
homomorphism , and call the resulting homomorphism h. We claim that there is a CQN,
Rexp
i , in Rexp such that t is in Rexp
i .D/ due to the homomorphism h. Observe that h makes
all the subgoals in all the CQNs in Rexp true, as long as these subgoals come from expanding
positive view subgoals in R.
Now consider any negative view subgoal gn in R. Since we only consider safe queries, all
the variables of gn are instantiated by . In addition, the view deﬁnitions have no nondistin-
guished variables. Hence, this instantiation passes on to the subgoals of the corresponding view
deﬁnitions. Since gn is a negative subgoal, this instantiation should make false at least one sub-
goal of the corresponding view deﬁnition. If this false subgoal is positive in the view deﬁnition,
it will pass as negative to some of the CQNs of Rexp, hence these CQNs would become candi-
dates for computing t. If a false subgoal is negative in the view deﬁnition, it will pass as positive
to some of the CQNs of Rexp, hence these CQNs would become candidates for computing t.
However, by construction of Rexp, each subgoal in the expansion of a negative view subgoal in R
meets in a CQN of Rexp with each subgoal in the expansion of any other negative view subgoal
in R. Hence, we continue the same reasoning to argue that one of the candidates will remain a
candidate after processing the second negative view subgoal in R, all the way until we are done
with processing all the negative view subgoals in R. The CQN that remains a candidate until
the end is the one that will compute t.
So far we have shown that R.V.D// is contained in Rexp.D/ for every D. Now we show
that Rexp.D/ is contained in R.V.D// for every D. Suppose tuple t is not in R.V.D// and is
in Rexp.D/. Since t is in Rexp.D/, there is a CQN Rexp
i
of Rexp, such that t is in Rexp
i .D/. The
subgoals of Rexp
i
are formed by taking one subgoal from each view expansion in R for negative
view subgoals in R, and taking all the subgoals of a view expansion for positive view subgoals in
R. Let h be the homomorphism that produces t in Rexp
i .D/. We can decompose h to produce
appropriate tuples for the positive view subgoals in R. We can also decompose h to show that all
appropriate negative view subgoals in R are not in V.D/, hence we can compute t in R.V.D//.

Expansion of a rewriting for CQN rewriting: For CQN queries and
views, where all the views have no nondistinguished (a.k.a. existential)
variables in their deﬁnition, the rewriting expansion can be a union of
CQNs. Similarly t the CQAC case, a rewriting is equivalent to the
query iﬀits expansion is equivalent to the query.
Example 3.28 is more elaborate than Example 3.24. We use it to show how one could use
Theorem 3.27 and the containment test for CQNs to prove equivalence of a rewriting to the
given query.

80
3. FINDING EQUIVALENT REWRITINGS
Example 3.28
Consider query Q and views V1, V2, and V3:
Q W q./ :- a.X; Y /; :a.X; X/:
V1 W v1.X; Y / :- a.X; Y /; :a.Y; X/; :a.X; X/:
V2 W v2.X; Y / :- a.X; Y /; a.Y; X/; :a.X; X/; :a.Y; Y /:
V3 W v3.X; Y / :- a.X; Y /; a.Y; X/; :a.X; X/; a.Y; Y /:
An equivalent rewriting of Q is the following union:
q./ :- v1.X; Y /,
q./ :- v2.X; Y /,
q./ :- v3.X; Y /:
.
Note that there is no rewriting in the form of a single CQN. The four canonical
databases of Q are (i) fa.X; Y /g; (ii) fa.X; Y /; a.Y; Y /g; (iii) fa.X; Y /; a.Y; X/g; and
(iv) fa.X; Y /; a.Y; X/; a.Y; Y /g. The canonical databases (i) and (ii) are covered by the view V1;
the canonical database (iii) is covered by V2; and the canonical database (iv) is covered by V3.
3.6
CQA QUERIES
In this section we discuss CQA queries. As usual, when discussing aggregate queries, we refer
to bags as well as sets. (Throughout this book, the only place we refer to bags/multisets is when
we discuss aggregate queries.) We say that a view V is set valued if V is computed and stored
to be accessed as a set, and that V is bag valued if V is computed and stored to be accessed as a
bag. In rewritings, a bag-valued view V is denoted by an adornment, as V b. When there is no
adornment, we assume that it is easily deduced from the context.
Example 3.29
Consider the following queries, views, and rewritings:
Q1 W q1.S; Y; max.T //
:- p.X; Y; Z; T; N; L; 2005/; t.X; S/:
Q2 W q2.Y; M; U; sum.Z//
:- p.X; Y; Z; T; N; L; M/; w.X; U /:
V1 W v1.X; Y; M; max.T //
:- p.X; Y; Z; T; N; L; M/:
V2 W v2.X; Y; M; sum.Z//
:- p.X; Y; Z; T; N; L; M/:
V3 W v3.X; S/
:- t.X; S/:
V4 W v4.X; U /
:- w.X; U /:
R1 W r1.S; Y; max.K//
:- v1.X; Y; 2005; F; K/; v3.X; S/:
R2 W r2.Y; M; U; sum.J //
:- v2.X; Y; M; J; K/; v4.X; U /:
In each rewriting, the view V1 or V2 is the only subgoal that contributes to the computation of
the aggregation; we call this view central view. Thus, in rewriting R1, the central view is V1 and,
in rewriting R2, the central view is V2. Observe that the other views in the rewritings (V3 or
V4) can be either set valued or bag valued. The view V3 can be either set or bag valued, and the
rewriting R1 will still be equivalent to query Q1. However, the view V4 should be bag valued
for the rewriting R2 to be equivalent to query Q2. We will discuss how to prove this formally in
this section.

3.6. CQA QUERIES
81
We now deﬁne central rewritings.
Deﬁnition 3.30
A central rewriting consists of the following template R:
r. NX; ˛.Y //  v0. NX0; Y /; v1. NX1; Y1/; : : : ; vk. NXk; Yk/;
where ˛ is either a nontrivial aggregate operator or identity (in which case the head is r. NX; Y /)
and the variable Y does not appear in any other place in the rewriting, except the two places
shown. View v0, which contains the variable Y , is called the central view of the rewriting. We
refer to Y as the special variable of the rewriting.
We use the notation CQA/CQ to say that the central view is CQA and the rewriting is
CQ, the notation CQ/CQA to say that the central view is CQ and the rewriting is CQA, and
the notation CQA/CQA when both the central view and the rewriting are CQA.
3.6.1
UNFOLDINGS OF REWRITINGS
In case of aggregate queries, the deﬁnition of unfoldings of rewritings is analogous to the deﬁ-
nition (and use) of the notion of expansion for CQ rewritings. A diﬀerent name is used to alert
the reader to the complexities introduced by aggregation. (Note that aggregate queries are not
relational-algebra queries.)
Deﬁnition 3.31
The unfolding Ru of R is obtained by (a) considering the core CQ for each
view, (b) considering also the core CQ of the rewriting, forming its expansion (as if it were a
CQ query with CQ views), and (c) supplying an aggregate operator  to the special variable Y
of the rewriting in the head of Ru, as follows:  is the aggregate operator of the central view v0
of R when v0 is aggregated, or else is the aggregate operator in the head of R.
3.6.2
EQUIVALENCE OF UNFOLDINGS AND REWRITINGS
Unfoldings may lack equivalence to the respective rewritings. We provide examples that make
several points.
CQ/CQA: A Non-central View has Aggregation:
Example 3.32
Consider a CQ/CQA rewriting R in terms of views V and W ; Ru is the un-
folding of R:
r.B; C; sum.A//
:- v.A; B/; w.B; C; F /:
v.A; B/
:- p.A; B/:
w.B; C; count.D//
:- s.B; C; D/; t.C; G/:
ru.B; C; sum.A//
:- p.A; B/; s.B; C; D/; t.C; G/:

82
3. FINDING EQUIVALENT REWRITINGS
The sum-rewriting R is not equivalent to its unfolding Ru, because the noncentral view W of R
has aggregation. To show the nonequivalence, we let the third (aggregated) argument D in the
head of the view W be the marked argument. We can construct a database D that has four tuples:
D D f p.1; 4/; s.4; 5; 2/; s.4; 5; 3/; t.5; 6/ g. (Note that the tuples s.4; 5; 2/ and s.4; 5; 3/ diﬀer
in the values of the marked variable D in Ru.) We can show that on this database D, the answer
to R is f.4; 5; 1/g, whereas the answer to Ru is f.4; 5; 2/g. Thus, D serves as a counterexample
database in checking the equivalence of R and Ru. The multiplicity 2, which is introduced by the
two tuples in relation s, is captured by the view w but not by the view v. At the same time, in the
rewriting R the view V is the central view that provides the values to compute the aggregated
attribute sum.A/.
CQA/CQ: For Duplicate-insensitive Aggregation, Set-valued Computation is Needed
If bag projection is used as the last step of evaluating R on a database DV, then R.DV/ may
be a nontrivial bag and thus cannot be the same bag as Ru.D/, which is a set on any database.
Consider an example.
Example 3.33
Consider the following views V and W :
v.B; max.A//
:- p.A; B/:
w.B; C; D/
:- s.B; C; D/; t.C; G/:
We use the views to construct the following rewriting R and its unfolding Ru (note that R has
a nondistinguished argument D):
r.B; C; H/
:- v.B; H/; w.B; C; D/:
ru.B; C; max.A//
:- p.A; B/; s.B; C; D/; t.C; G/:
On
the
set-valued
database
D D fp.6; 1/;
s.1; 2; 3/;
s.1; 2; 5/;
t.2; 4/g,
R.DV/ D
f.1; 2; 6/; .1; 2; 6/g is a nontrivial bag if bag projection is used as the last step of comput-
ing R on DV. On the other hand, Ru.D/ is a set f.1; 2; 6/g.
CQA/CQ: Non-central Views Should not have Nondistinguished Variables in Their Deﬁnition
If non-central views have nondistinguished variables in their deﬁnition, then there is a database
D such that R.V.D// ¤ Ru.D/, as is demonstrated in the following example.
Example 3.34
Consider the following setting, with views v and w, rewriting R and its un-
folding, and database instance D:
v.X; Y / :- p.X; Y; W /:
w.X; sum.Z// :- r.X; Z/:
R.X; Y; S/ :- v.X; Y /; w.X; S/:

3.6. CQA QUERIES
83
Ru.X; Y; S/ :- p.X; Y; W /; r.X; Z/:
D D fp.1; 2; 3/; p.1; 2; 4/; r.1; 3/g:
If we compute the two views V and W on D, we get the following V.D/:
v.D/ W .1; 2/; .1; 2/
and
w.D/ W .1; 3/:
If we compute R on V.D/, we get the following R.V.D//:
R W .1; 2; 3/; .1; 2; 3/:
However, if we compute Ru on D, we get the following Ru.D/:
Ru W .1; 2; 6/:
CQA/CQA: The Case where Non-central Views have Aggregation or are Set Valued
If a sum or count rewriting R has non-central views that are set valued or have aggregation, it
could be that R is not equivalent to its unfolding Ru.
Example 3.35
Consider a sum rewriting R and its unfolding Ru:
r.B; sum.W //
:- v1.C; W /; v2.B; C/:
ru.B; count.//
:- s.B; C; D/; t.C; G/:
v1.C; count.//
:- t.C; G/.
v2.B; C/
:- s.B; C; D/.
If the relation for the noncentral view V2 is computed as a set, R and its unfolding Ru are not
equivalent, as evidenced by the database D D fs.1; 2; 3/; s.1; 2; 4/; t.2; 5/g.
Now consider a sum rewriting R0 that has a noncentral view with aggregation; R0 is the
result of slightly modifying in R the noncentral view V2:
v0
2.B; C; count.//
:- s.B; C; D/:
r0.B; sum.W //
:- v1.C; W /; v0
2.B; C; count.//:
The rewriting R0 is not equivalent to its unfolding Ru, as evidenced by the same database D.
The techniques illustrated in these examples show various cases in which the unfolding is
not equivalent to the given rewriting. It turns out that these are the only exceptions, and in all
the other cases we have equivalence. These observations are captured in the following results.
Theorem 3.36
Let R be a CQA rewriting with the max or min operator. Then R  Ru in the
following cases:

84
3. FINDING EQUIVALENT REWRITINGS
• CQ/CQA;
• CQA/CQ, with R is computed as set; and
• CQA/CQA.
Theorem 3.37
Let R be a CQA rewriting with the max or min operator. Then R  Ru in the
following cases:
• CQ/CQA, where all the views are conjunctive without aggregation and are bag valued;
• CQA/CQ, where all the grouping attributes in the central view are also grouping attributes in
the rewriting, all the noncentral views are conjunctive without aggregation, and there are no
nondistinguished variables in their deﬁnitions; and
• CQA/CQA, where all the noncentral views are conjunctive without aggregation and are bag
valued.
3.6.3
CONSTRUCTING CENTRAL REWRITINGS
The algorithm for constructing central rewritings is based on the following proposition, which
uses the results from Section 3.6.2.
Proposition 3.38
The following results hold for the three types of central rewritings.
• In a CQA/CQ rewriting, the set of all grouping attributes of the central view is a subset of the
set of all grouping attributes of the rewriting. (We call this central view grouping complete.)
• In a CQA/CQA rewriting, the set of the grouping attributes of the rewriting is a union of subsets
of the grouping attributes in the central view and of the non-aggregated attributes in noncentral
views. (We call this central view grouping incomplete.)
• In a CQ/CQA rewriting, the set of the grouping attributes of the rewriting is a union of subsets
of the attributes in the central view and of the non-aggregated attributes in noncentral views.
Suppose we are given a query Q, a set of views V, and a rewriting R of the query using
the views. We now discuss how to construct the reduced-core query, the reduced-core viewset, and
the reduced-core rewriting with respect to the viewset V. Given an aggregate view V , we deﬁne its
reduced-core view V r as the view whose body is the body of V and whose head is a new predicate
name V r; the arguments in the head of V r are all the grouping attributes of V . We construct
the reduced-core query in a similar way. For the rewriting R, its reduced-core rewriting with respect

3.6. CQA QUERIES
85
to the viewset V is a conjunctive rewriting Rr whose head attributes are R’s grouping attributes
only, and whose body is the same as the body of R, with the view subgoals of R replaced by the
corresponding reduced-core views. The reduced-core rewriting is a conjunctive query that can be
viewed as a rewriting of the reduced-core query using the reduced-core views. The proposition
that follows shows that if R is an equivalent rewriting of Q using V, then the reduced-core
rewriting of R wrto V is also an equivalent rewriting of Q using V.
Proposition 3.39
Given a query Q and views V, suppose that there exists a central rewriting R
that uses V, including a CQA central view, such that R is equivalent to the query. Then the following
holds: Let V0 be the reduced-core views of V, Rr be the reduced-core rewriting of R with respect to V,
and Q0 be the reduced-core query of Q. Then Rr is an equivalent rewriting of Q0 using V0.
Proof. The proof is a direct consequence of Deﬁnition 3.30 and of the results of Section 3.6.2. In
particular, it is a consequence of the following observations. (a) If R is a rewriting of the query,
then its unfolding is equivalent to the query. (b) All the subgoals that contain the aggregated
attribute in the unfolding of the rewriting are subgoals of the central view. (This follows from
the deﬁnition of central rewritings.) Hence by dropping the aggregated attribute from the head
of the view deﬁnition, we still have a mapping to ensure that the reduced rewriting and the
reduced query are equivalent.

We now describe an algorithm that, given a query and a set of views, constructs all the
central rewritings that are equivalent to the query. We reduce this problem to the problem of
obtaining rewritings for purely conjunctive queries. First we describe the case for max and min
queries.
In the following algorithm, Qr and V r are the reduced-core queries of a query Q and of
the views, respectively. We use the algorithm described previously in this book to ﬁnd equivalent
rewritings of CQ views and queries.
Procedure Find-R. Input: query Q, set of views V
Consider Qr ,V r.
Find all the rewritings of Qr using V r.
For each rewriting Rr do:
Consider the expansion Rr exp
For each containment mapping from Qr to Rr exp do:
If there is a view in the rewriting Rr such that all its subgoals containing its aggregated
attribute are exactly the subgoals containing the aggregated attribute in the
query, then all this view the central view.
If the central view is grouping incomplete, then construct CQA/CQA rewriting.
If the central view is grouping complete, then construct CQA/CQ rewriting.
If there is a conjunctive view in the rewriting Rr such that all the subgoals of the query

86
3. FINDING EQUIVALENT REWRITINGS
containing the aggregated attribute are exactly the subgoals of the view that contain
in the same predicate position an attribute B, then do:
Call this the central view and B the aggregated attribute,
and construct a CQ/CQA rewriting.
end
end
end
CQAqueriesandviews—ﬁndingequivalentrewritings: We focus on
central rewritings, i.e., those rewritings that have only one view subgoal,
called the central view subgoal, which contains the attribute aggregated
in the head of the rewriting. Unfoldings of rewritings are used to rea-
son about the equivalence of the rewriting to the query. In the case of
aggregate queries, for rewritings R and unfoldings Ru, views V, and
database D, the results Ru.D/ of unfoldings are not always equal to
R.V.D// (as was the case of, e.g., CQs and expansions of CQ rewrit-
ings).
3.6.4
NON-CENTRAL REWRITINGS
If we allow in the rewriting aggregate operators beyond sum, avg, count, max, and min, then we
may obtain richer rewritings, such as the one in the following example.
Example 3.40
Consider query q, views v1 and v2, and query r over the views:
q.X; sum.Y // :- a.X; Y; U /; b.Y; W /:
v1.X; Y; count/ :- a.X; Y; U /:
v2.Y; count/ :- b.Y; W /:
r.X; sum.Y; Z1Z2// :- v1.X; Y; Z1/; v2.Y; Z2/:
Here, sum.Y; Z1Z2/ is a new aggregate operator, which computes the sum, over all the values
yi of Y , of the products z1  z2  yj.
For each pair of values for X and Y , the view v1 counts the number of tuples with a certain
value in U . For each value of Y , the view v2 counts the number of tuples with a certain value
in W . Thus, for each value of Y , from the result of the view v2 we know in how many tuples
in the relation b this value occurs. Similarly (albeit in a little more involved manner), from the
result of the view v2 we know for each value of Y , as it is paired with a value of X, in how many
tuples of the relation a this pair appears. By using basic calculations, we can obtain that the
following would give us the result of the query. For each value xj of x we do: for each value yi

3.7. EXERCISES
87
of Y , multiply the result of count in v1 for the tuple .xj ; yi; z1/, by the result of count in v2 for
the tuple .xj ; z2/, then multiply the outcome by the value yj. As a result, we have the sum as
required in the query for the speciﬁc value yj (i.e., if we consider only the tuples that contain yj,
and ignore the others). To ﬁnish up, we do this for all the values of Y , and sum up the partial
results.
3.7
EXERCISES
3.1.
Prove the following: If an equivalent rewriting of a CQ query in terms of CQ views
does not exist in the language of CQs, then there is no such rewriting in the language
of unions (inﬁnite or ﬁnite) of CQs.
3.2.
Prove Theorem 3.15.
3.3.
Prove Theorem 3.36.
3.4.
Prove Theorem 3.37.
3.5.
Find all possible equivalent rewritings of the given query Q using the given set of views
V D f U , V , W , T , M g.
(1) Q.X; Y / :- p.X; Z; N/; s.N; R; Y /:
U.A; B/ :- p.A; C; B/:
V.A; B/ :- p.A; B; C/:
W.A; B/ :- s.A; C; B/:
T .A; B; C/ :- p.A; D; F /; S.F; C; B/:
M.A; B; C; D/ :- p.A; F; C/; s.D; H; B/:
3.6.
Use algorithm CoreCover to ﬁnd all possible equivalent rewritings of the given query Q
using the given set of views V D f U , V , W , M g.
(1) Q.X; Y / :- p.X; N/; s.N; Z/; t.N; Y /:
U.A; B/ :- p.A; C/; s.C; B/:
V.A; B; C/ :- p.A; C/; s.C; B/:
W.A; B; C; D/ :- p.A; C/; t.D; B/:
M.A; B; C/ :- s.A; B/; t.A; C/:
3.7.
Use algorithm CoreCover to ﬁnd all possible equivalent rewritings of the given query Q
using the given set of views V D f U , V , W , M g.
(1) Q.A/ :- p.A; B/; s.B; C/; t.C; B/:
U.X; Y / :- p.X; Z/; s.Z; Y /:

88
3. FINDING EQUIVALENT REWRITINGS
V.X; Y / :- s.X; Z/; t.Z; Y /:
W.X; Y / :- t.X; Y /; s.U; X/:
M.X; Y; Z/ :- s.X; Z/; t.Z; Y /:
3.8.
Find all possible equivalent rewritings of the given query Q using the given set of views
V D f U , V , W , T g.
(1) Q.X/ :- p.X/; s.X; Y /; X  5; X < 10; Y > 8:
U.X/ :- p.X/; X  5:
V.X/ :- s.X; Y /; Y > 8:
W.X/ :- s.Y; X/; Y > 8:
T .X; Y / :- p.X/; s.X; Y /; Y > 9:
3.9.
Find all possible equivalent rewritings of the given query Q using the given set of views
V D f U , V , W g.
(1) Q.Y / :- p.X; Z/; s.Z; Y /; Z > Y; X > 3:
U.X; Y / :- p.X; Y /; X > 3:
V.X; Y / :- p.X; Z/; s.Z; Y /; X > 3:
W.Z; N; Y / :- p.X; Z/; s.N; Y /:

89
C H A P T E R
4
Maximally Contained
Rewritings (MCRs)
We may obtain a view instance I in either of the following two ways.
• Under the Closed World Assumption (CWA), I is such that there is D with I D V.D/.
• Under the Open World Assumption (OWA), I is such that there is D with I  V.D/.
In Chapter 3, we only considered the CWA, as it was proper for equivalent rewritings. For
contained rewritings, however, we may have the following two diﬀerent deﬁnitions.
Deﬁnition 4.1
Given a query Q and a set of view deﬁnitions V, we deﬁne contained rewritings
under the CWA and under the OWA.
• Under the Closed World Assumption (CWA). R is a contained rewriting of Q using V under the
CWA if and only if for every view instance I the following is true: for any database D such
that I D V.D/, we have that R.I/  Q.D/.
• Under the Open World Assumption (OWA). R is a contained rewriting of Q using V under the
OWA if and only if for every view instance I the following is true: for any database D such
that I  V.D/, we have that R.I/  Q.D/.
Deﬁnition 3.6 is equivalent to the above deﬁnition under the CWA. The way in which
the two deﬁnitions are related is expressed by the following two results.
Proposition 4.2
Given a query Q and a set of view deﬁnitions V, R is a contained rewriting under
the OWA if it is a contained rewriting under the CWA.
Proof. If R is a contained rewriting of Q under the OWA, then for any I it holds that for any
database D such that I  V.D/, we have that R.I/  Q.D/. This means that this is true for
any database D such that I D V.D/. Thus R is also a contained rewriting of Q under the CWA.


90
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
For the other result, we need to deﬁne monotone queries.
Deﬁnition4.3
A query Q is monotone if the following is true: if D  D0, then Q.D/  Q.D0/.
Proposition 4.4
Assume monotone queries, views, and rewritings. Given a query Q and a set of
view deﬁnitions V, let R be a monotone query. Then R is a contained rewriting of Q under the CWA
if it is a contained rewriting of Q under the OWA.
Proof. If R is a contained rewriting of Q under the CWA, then for any I it holds that for any
database D such that I D V.D/, we have that R.I/  Q.D/. Consider, for a certain D such that
I D V.D/, any I0 such that I0  V.D/. Since R is monotone, we have that R.I0/  R.V.D//.
Thus R is also a contained rewriting of Q under the OWA.

Thus, the two deﬁnitions coincide for monotone rewritings. CQs and CQACs are mono-
tone queries. In this chapter, we consider the OWA for contained queries; this reﬂects in the
deﬁnition of maximally contained rewritings given in the next section. In the rest of this chapter,
we present the following.
1. For CQ queries and views: An eﬃcient algorithm to ﬁnd maximally contained rewritings
(MCRs) in the language of unions of CQs.
2. For CQAC queries and views: In cases where the homomorphism property holds, the
results are analogous to the case of CQ queries and views. Otherwise, the general case
is more involved. At the same time, we show that in certain cases recursion, such as in
Datalog, is suﬃcient to ﬁnd MCRs. Thus, we proceed as follows.
3. For the case where the queries are in Datalog and the views are CQs, we provide an algo-
rithm for ﬁnding MCRs in the language of Datalog.
4. We illustrate cases where the queries and views are deﬁned by unions of CQs or by CQACs,
but recursion is needed to ﬁnd MCRs.
4.1
PRELIMINARIES
Informally, we deﬁne maximally contained rewritings (MCRs) to be those rewritings in a certain
language that produce all the answers that would be returned by any contained rewriting of the
query under the OWA. The formal deﬁnition is as follows.
Deﬁnition 4.5
A rewriting R is called a maximally contained rewriting (MCR) of query Q
using views V with respect to query language L if (1) R is a contained rewriting of Q using V
in L, and (2) every contained rewriting of Q using V in language L is contained in R.

4.1. PRELIMINARIES
91
The following example demonstrates that an equivalent rewriting under the CWA (which
is also a contained rewriting under the CWA) may not even be a contained rewriting under the
OWA.
Example 4.6
Recall that in Example 3.2 we considered query Q0 deﬁned as path query P5.
(Pi is the query that asks for pairs of nodes on a graph connected by a path of length i—
see Deﬁnition 2.44.) We proved that there is no equivalent CQ rewriting of Q0 using views
P3 and P4. However, there is an equivalent ﬁrst-order rewriting R0 of Q0 in terms of these
views, as given in Example 3.2. The rewriting R0 is equivalent to P5 only if we have access to
all the data computed by the views. On the other hand, if we have access to only some of the
data, then this rewriting is not equivalent to P5. To see this, suppose we have the view instance
I D fP4.1; 2/; P3.3; 2/; P4.3; 4/g. I is a subset of the views P3 and P4 computed on
D D fe.1; 11/; e.11; 12/; e.12; 14/; e.14; 4/; e.3; 31/; e.31; 32/; e.32; 2/; e.3; 34/;
e.34; 35/; e.35; 36/; e.36; 4/g:
We observe that .1; 4/ is in R0.I/. Thus, under the OWA, .1; 4/ should be in Q.D/ too. If .1; 4/
is in Q.D/, then there should exist a path of length ﬁve from node 1 to node 4 in D. However,
there is no such path in D, hence .1; 4/ is an incorrect answer under the OWA. Hence, R0 is not
a contained rewriting of Q0 using the views P3 and P4.
We now provide intuition on how to use Deﬁnition 4.5 to ﬁnd MCRs in the following
example.
Example 4.7
Consider a CQ query Q
q.X; Y / :- a.X; Z/; b.Z; W /; c.W; Y /
and views
V1 W
v1.X; W / :- a.X; Z/; b.Z; W /;
V2 W
v2.W; Y / :- c.W; Y /;
V3 W
v3.Z; Y / :- b.Z; W /; c.W; Y /;
V4 W
v4.X; Z/ :- a.X; Z/;
V5 W
v5.X; Y / :- a.X; Z/; b.Z; Z/; c.Z; Y /:
Let the language of rewritings be unions of CQs (UCQs). The following rewriting, which
consists of three CQs R1, R2 and R3, is the MCR of the query Q for the language UCQ:
R1 W q.X; Y / :- v1.X; Z/; v2.Z; Y /:
R2 W q.X; Y / :- v3.X; Z/; v4.Z; Y /:
R3 W q.X; Y / :- v5.X; Y /:
Observe that R1 is an equivalent rewriting of the query Q using the given views; the same holds
for R2. However, we need both R1 and R2 in a UCQ rewriting to construct an MCR. To see

92
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
why, observe that R1 is not contained in R2 (as queries), although Rexp
1
and Rexp
2
are equivalent.
Moreover, we need rewriting R3, which is a contained but not equivalent rewriting.
The purpose of the following example is to show how to prove that a UCQ rewriting is
an MCR of a CQ query using CQ views.
Example 4.8
Consider query Q, views V1 and V2, and rewriting R, as follows:
.X; Y / :- p.X/; s.Y /:
V1.X/ :- p.X/:
V2.X/ :- s.X/:
R.X; Y / :- V1.X/; V2.Y /:
Here R is an MCR of Q. Indeed, suppose R0 is a contained rewriting of Q using the two
views. Then there is a containment mapping  from Q to the expansion of R0. The mapping
 maps subgoal p.X/ of the query to some subgoal g of the expansion. However, g can be
produced in the expansion only by expanding the view V1. Hence, R0 has a subgoal V1.X/. For
similar reasons, R0 has a subgoal V2.Y /. Hence, there is a containment mapping from R to R0.
4.1.1
CQAC QUERIES AND VIEWS
The problem of ﬁnding MCRs gets considerably more involved in presence of arithmetic com-
parisons. We begin by showing that, unlike the CQ case, we need recursion to ﬁnd an MCR,
even if all the ACs are semi-interval comparisons (see Example 4.9). Then we develop a new no-
tion of AC-containment, motivated by the following observation: Unlike CQ queries and views,
for CQAC queries and views we may have two contained rewritings R1 and R2, such that for
any view instance I we have R2.I/  R1.I/, but R2 is not contained in R1 (see Example 4.10).
Language of Rewritings
The following example shows the importance of the language of maximally contained rewritings.
Example 4.9
Let the query and views be as follows:
Q1./
:- e.X; Z/; e.Z; Y /; X  5; Y  8:
V1.X; Y /
:- e.X; Z/; e.Z; Y /; Z  5:
V2.X; Y /
:- e.X; Z/; e.Z; Y /; Z  8:
V3.X; Y /
:- e.X; Z1/; e.Z1; Z2/; e.Z2; Z3/; e.Z3; Y /:

4.1. PRELIMINARIES
93
To see the intuition in this example, we begin with a simple contained rewriting:
P2 :- V1.X; Z1/; V2.Z1; Y /:
To see that P2 is a contained rewriting of Q1, let us consider its expansion:
P exp
1
:- e.X; Z/; e.Z; Z1/; Z  5; e.Z1; Z0/; e.Z0; Y /; Z0  8:
The query asks for a path of length two with two ends, the start end with value no less than
ﬁve, and the other end with value no greater than eight. Looking at P exp
1 , this path is the
e.Z; Z1/; e.Z1; Z0/.
Now we argue that there is no maximally contained rewriting of this query using these
views in the language of unions of conjunctive queries with arithmetic comparisons. We can
show that for any positive integer k > 0, the query Pk is a contained rewriting of Q1:
Pk :- V1.X; Z1/; V3.Z1; Z2/; V3.Z2; Z3/; : : : ; V3.Zk 1; Zk/; V2.Zk; Y /:
This example shows that to ﬁnd a maximally contained rewriting, we may need a language that
is more expressive than the language of the query or view deﬁnitions.
We now present an important feature of contained rewritings in the case of CQACs.
This feature has to be incorporated in the theory of ﬁnding MCRs with a bounded number
of subgoals. This feature leads to the introduction of AC-containment between rewritings as
queries.
Containment of Rewritings—AC-containment
Unlike CQ queries and views, in the case of CQAC query and views arithmetic comparisons
introduce a challenge for deﬁning MCRs.
• We may have two contained rewritings R1 and R2 of a query, such that for any view
instance I, R2.I/  R1.I/ but R2 is not contained in R1.
An example follows.
Example 4.10
Consider query Q and view V2:
Q.A/
:- p.A/; A < 4:
V2.Y; Z/
:- p.X/; s.Y; Z/; Y  X; X  Z:
The following rewriting is a contained rewriting of the query in terms of the view in the language
CQAC:
R.Y1/ :- V2.Y1; Z1/; V2.Y2; Z2/; Z1  Y2; Y1  Z2; Y1 < 4:
Now consider the following contained rewriting:

94
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
R0.X/ :- V2.X; X/; X < 4:
This rewriting uses only one copy of the view. We can show that R is not contained in R0 and
that R0 is not contained in R.
At the same time, we can show that for any view instance I, R.I/ D R0.I/ holds. The
reason is the following: if there is a tuple .y; z/ in I, then we deduce from the view deﬁnition that
y  z. Thus, we can append to the deﬁnition of the rewriting R this AC, since it is always true. If
we do that for both atoms in the deﬁnition of R, we obtain the ACs Z1  Y2; Y1  Z2; Y1  Z1;
and Y2  Z2; which imply that Y1 D Z1 D Y2 D Z2. Thus, R.I/ D R0.I/.
Example 4.10 shows that a rewriting may have many semantically equivalent yet syn-
tactically diﬀerent variants, whose size is not necessarily a-priori bounded. It turns out that the
“minimized” versions do have bounded size. In order to obtain such a “minimized” version of the
rewriting, it does not suﬃce to simply remove subgoals, which is done in known minimization
techniques, such as CQ minimization. In addition, one may have to also add comparisons. This
is the reason AC-extensions are of interest. Example 4.10 motivates the following deﬁnitions
and formal result.
Deﬁnition 4.11
(AC-extension of a rewriting)
Given a CQAC query, CQAC views, and CQAC contained rewriting R of the query, we deﬁne
the AC-extension Rext of R to be R with ACs added as follows: consider the expansion Rexp of R
and the set Ext of all those ACs implied by the ACs in Rexp that contain only variables appearing
in R. (Recall that in order to form Rexp, we also use fresh variables that are not included in R.)
From Ext, we keep those ACs that are either semi-interval or whose both variables also appear
together in the same view subgoal. We form Rext by adding those ACs to R.
Deﬁnition 4.12
Let R1 and R2 be contained rewritings of query Q using views V. We say
that R2 is AC-contained in R1 if Rext
2 is contained in Rext
1 .
Theorem 4.13
Suppose query Q and views V are CQACs. Let R be a contained rewriting of Q in
the language CQAC. For every database I on the schema of the views (i.e., I is a view instance) such
that there exists a database D deﬁned on the schema of the view deﬁnitions and such that I  V.D/,
tuple t is in R.I/ iﬀit is in Rext.I/.
Proof. The “if” direction is straightforward. For the “only-if ” direction, suppose t is in R.I/. The
computation of t must have used those tuples/facts in I that were computed when we applied the
deﬁnition of some view on some database D0 on the schema of the query and view deﬁnitions.
Thus, the additional ACs that appear in Rext.I/ already hold. (Notice that the ACs in Rext.D/
come from each view deﬁnition separately, rather than being “cross-view” ACs.) Hence, Rext
can use the same tuples/facts that R used to compute t.


4.2. FINDING MCRS FOR CQ QUERIES AND VIEWS: THE MS ALGORITHM
95
You may ﬁnd it interesting to observe that AC-containment does not change things in Ex-
ample 4.9, because the ACs in the view deﬁnitions do not imply any ACs on their distinguished
variables.
For the rest of the book, whenever we refer to rewritings containing each other as queries,
we mean they are AC-contained unless otherwise mentioned.
The structure of the rest of this chapter is as follows. First, for the setting of CQ queries and
views we provide an eﬃcient algorithm, called the MS algorithm, to ﬁnd a maximally contained
rewriting (MCR) in the language of unions of CQs. Then, for CQAC queries and views, we
extend the MS algorithm to the subclass of CQACs for which the homomorphism property
holds.
In Section 4.4 we move to a more expressive language, Datalog. We describe the inverse-
rule algorithm that ﬁnds an MCR for the case of Datalog queries and CQ views. Sections 4.4.2
and 4.4.4 illustrate cases where the queries and views are nonrecursive, but there is no MCR
in the language of unions of CQs or CQACs. At the same time, we show that MCRs in the
language of Datalog can be found.
4.2
FINDING MCRS FOR CQ QUERIES AND VIEWS: THE
MS ALGORITHM
In the case of CQ queries and views, there always exists an MCR in the language of unions of
CQs, due to the following result.
Theorem 4.14
Suppose query Q and views V are CQs. For every contained rewriting R, there is a
contained rewriting R0 with no more subgoals than Q and such that R is contained in R0.
Proof. Let Rexp be the expansion of R. There is a homomorphism h from Q to Rexp that uses
as targets no more subgoals than the number of subgoals in Q. These target subgoals in Rexp
came from expanding some subgoals in R. We construct R0 by keeping those subgoals in R
that provided the targets for h, and by deleting the rest of the subgoals of R. Now, h can still
provide proof that R
0exp is contained in Q, Moreover, there is an obvious homomorphism from
the subgoals of R0 to the subgoals of R, which proves that R is contained in R0.

In this section, we present the algorithm called MiniCon/Shared-Variable algorithm (MS);
the name comes from two algorithms that were developed independently. For CQ inputs, the
algorithm constructs eﬃciently MCRs in the language of unions of CQs. We start with an
example to make some of the key points of this algorithm. In particular, we illustrate Theo-
rem 3.14 of Section 3.2.2, and observe that it can be reﬁned/strengthened. Of Q (Section 3.2.2)
and observe that it can be reﬁned/strengthened.
Example 4.15
Consider the following query:
Q W q1.S; C/ :- a.M; D/; b.D; C/; c.S; M; C/

96
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
and views:
V1:
v1.M1; D1; C1/
:- a.M1; D1/; b.D1; C1/:
V2:
v2.S2; M2; C2/
:- c.S2; M2; C2/:
Consider the contained rewriting R1 of the query:
R1:
q1.S; C/
:- v1.M; D; C/; v2.S; M; C/:
The expansion of R1 is
Rexp
1 :
q1.S; C/
:- a.M; D/; b.D; C/; c.S; M; C/:
Theorem 3.14 tells us that any homomorphism from Q to this expansion can be decom-
posed into two partial homomorphisms, one for each view subgoal in the rewriting R1. Let
us take the ﬁrst subgoal of R1. Then, if we deﬁne S D fa.M; D/; b.D; C/; c.S; M; C/g, S0 D
fa.M; D/; b.D; C/g, and homomorphism h1 from the subgoals of Q to the subgoals of Rexp
1 that
maps M to M, C to C, and D to D, we have that .S; S0; h1/ has the shared-variable property
(see Deﬁnition 3.12). Observe, however, that S0 is not minimal with respect to the shared-
variable property. That is, there is a subset of S0, S0
1 D fa.M; D/g, such that .S; S0
1; h/ has the
shared-variable property, where h maps M to M and D to D. Motivated by this example, we
deﬁne such minimal triples as MCDs (MCD stands for MiniConstruction Description which is
the name that was adopted in the description of the MiniCon algorithm), and reﬁne/strengthen
Theorem 3.14 to Theorem 4.18.
The following are key observations about the MS algorithm.
• We can ﬁnd minimal triples even if we do not know the rewriting and its expansion,
simply by considering partial mappings from the query subgoals to the subgoals of the
view deﬁnitions.
• We can put together such minimal triples to construct a contained rewriting.
We use only the view deﬁnitions to ﬁnd minimal triples with the shared-variable property.
• The ﬁrst triple is the .S; S0
1; h/ that we deﬁned above. Since we use the view deﬁnitions,
the homomorphism h is from the subgoals of the query to the subgoals of the deﬁnition
for the view V1; it maps M to M1 and D to D1.
• The second triple is .S; S0
2; h0/, where S0
2 D fb.D; C/g, and h0 maps D to D1 and C to C1.
• The third triple, which refers to the view subgoal for the view V2, is .S; S00; h00/, where
S00 D fc.S; M; C/g and h00 maps C to C2, M to M2, and S to S2.
Each triple has the shared variable property; together they cover all the query subgoals. Hence,
we can put them together to construct the contained rewriting R1 of the query. The way we put
them together comes from the homomorphisms h; h0, and h00. First we put together the view

4.2. FINDING MCRS FOR CQ QUERIES AND VIEWS: THE MS ALGORITHM
97
subgoals v1.M1; D1; C1/ and v2.S2; M2; C2/ as the only subgoals in the body of the rewriting
with head q1.S; C/. Then we observe that variable M from the query maps (via either of the three
homomorphisms h; h0, and h00) to each of M1 and M2, hence we should have M1 D M2. Simi-
larly, we obtain that C1 D C2. Hence, the rewriting is q1.S; C/ :- v1.M1; D1; C/; v2.S; M1; C/,
which is syntactically isomorphic to the rewriting R1.
Thus, we have constructed a contained rewriting in which the ﬁrst and second triples cor-
respond to the view subgoal v1.M; D; C/, and the third triple—to the view subgoal v2.S; M; C/
in the rewriting. However, if we do this, we miss the fact that the ﬁrst two triples are “indepen-
dent,” meaning that we can use the subgoal v1.M; D; C1/ for the ﬁrst triple, because h puts no
restriction on the third variable in the head of the view deﬁnition for V1. Hence, we introduce
and use a fresh variable C1. For the same reason we use subgoal v1.M1; D; C/, for the second
triple. For the third triple we have to use subgoal v2.S; M; C/. Thus, now we have constructed
the contained rewriting:
R2:
q1.S; C/
:- v1.M; D; C1/; v1.M 0
1; D; C/; v2.S; M; C/:
Observe that R1 is contained in R2, hence R1 does not need to be included in an MCR. We will
deﬁne the rewriting R2 as the most relaxed rewriting that comes from combining these three
triples. The MS algorithm constructs such most relaxed rewritings, as we now explain formally.
4.2.1
FINDING MCDS
The discussion in the previous section hints that we may search for candidate view subgoals for
a contained rewriting by considering each view deﬁnition and ﬁnding all the partial mappings
from a subset of the query subgoals to the subgoals of the view deﬁnition, making sure that the
shared-variable property holds. (See Deﬁnition 3.12 for the shared-variable property.) However,
we do not know yet the format of the head arguments for this view in the rewriting. That is, we
may have a view deﬁnition with head of the form V.X; Y; Z/, but the view may appear in the
rewriting as subgoal V.X; X; Z/, or V.Z; Y; Z/, or V.X; X; X/, or V.X; Y; Y /. Thus, we will be
looking speciﬁcally for partial containment mappings, in which we have relaxed the requirement
that each query variable must map to exactly one variable in the view deﬁnition.
The requirement still holds when a query variable maps to a nondistinguished variable of a
view. At the same time, a query variable is allowed to map to several distinct distinguished vari-
ables of the view. Our allowing this non-function behavior for the mappings will be reconciled
at a later step of the algorithm. For now we provide the intuition: Suppose a query variable W
has been mapped to variables X and Y in V.X; Y; Z/. Then we form a subgoal in the rewriting
for this view, with head V.X; X; Z/, which “restores” the correctness of the mapping.
These mappings also tell us which subgoals in the rewriting share variables, and which
variables are the shared variables. For example, if query variable W maps to variable X in view
V.X; Y; Z/ and to variable Z0 in V.X0; Y 0; Z0/, this means that X D Z0 in the rewriting, i.e.,
the rewriting will have view subgoals V.X; Y; Z/ and V.X0; Y 0; X/, with the shared variable X.

98
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
Finally, we apply transitivity of equality to identify more variables, e.g., if we deduce from
the above that X D Y and Y D Z, we must replace these three variables with a single variable.
Deﬁnition 4.16
(MiniConstruction Description (MCD))
Let query Q and view V be CQs. Consider the relational structure S of all the atoms that
are subgoals in the body of Q; let S0 be any substructure, i.e., subset, of S. We will allow the
homomorphism h, below, to map a variable of the query to multiple variables in the view, as long
as they are all distinguished variables in the view deﬁnition.1 Let h be a homomorphism from
the substructure S0 to the relational structure comprised from the subgoals of V . We say that the
triple .S; S0; h/ is an MCD for view V in a rewriting of Q (or simply an MCD when confusion
does not arise) if .S; S0; h/ has the shared-variable property and is minimal with respect to this
property, i.e., there is no S00 that is a proper subset of S0 such that there exists an h0 for which
.S; S00; h0/ has the shared-variable property.
The following example illustrates the part of Deﬁnition 4.16 that says that the triple should
have the shared-variable property.
Example 4.17
We revisit Example 3.13 to illustrate the shared-variable property. Consider the
following two queries and views:
Q1./ :- a.A; B/; c.B; C/:
Q2./ :- a.A; B/:
V1.X; Y / :- a.X; Z/; b.Z; Y /:
V2.X; Y; Z/ :- a.X; Z/; b.Z; Y /:
We begin by deﬁning sets of subgoals and homomorphism, so we may refer to them. Let
set S have atoms a.A; B/; c.B; C/, and let set S0 comprise atom a.A; B/. These sets may refer to
subgoals of either of the two queries, as determined by the context. Consider the homomorphism
h1 that maps A to X and B to Z; it may refer to variables of either query or view. Let us discuss
what MCDs we can form and why.
MCD for view V2 in a rewriting of Q1: The triple .S; S0; h1/ has the shared-variable
property, as explained in Example 3.13. Moreover, there is no non-empty subset S00 of S0 such
that .S; S00; h1/ is an MCD. We conclude that .S; S0; h1/ is an MCD.
MCD for view V1 in a rewriting of Q2: The triple .S0; S0; h1/ is an MCD.
No MCD for the view V1 in a rewriting of Q1: The triple .S; S0; h1/ is not an MCD,
because Q1 has two subgoals, which share a variable. This prevents .S; S0; h1/ from having the
shared-variable property, because the shared variable B maps to Z, which is not distinguished in
1Technically, h is not a homomorphism, but we still use this term, since we will turn h into a homomorphism when considering
the expansion of the assembled contained rewriting.

4.2. FINDING MCRS FOR CQ QUERIES AND VIEWS: THE MS ALGORITHM
99
the deﬁnition of V1. Interestingly, the same triple works for the view V2, because in its deﬁnition
Z is a distinguished variable.
These are all the MCDs that we can ﬁnd.
4.2.2
PROPERTY OF MCDS
Having deﬁned MCD, we can now restate and strengthen Theorem 3.14 of Section 3.2.2.
Theorem 4.18
Let R be a CQ contained rewriting of a CQ query Q using a set of CQ views V, and
let E be the expansion of the rewriting R. Then any containment mapping  from the query Q to E
can be decomposed into mappings, with at least one mapping for each subgoal in the rewriting R, such
that the mappings can be used to form MCDs and have the following properties: Any two MCDs that
participate in this decomposition have an empty intersection (i.e., the query subgoals they cover do not
overlap), and all the MCDs cover all the query subgoals.
Proof. We ﬁrst show how to deﬁne MCDs from the given mapping . For each variable X of
the query, if .X/ is a non-exported variable that comes from expanding subgoal gR
i of R, then
we set i.X/ D .X/ and make i the only partial mapping that X participates in. Otherwise,
X may participate in two or more partial mappings, as follows: Suppose that subgoal gQ
i of Q
that contains X maps to a subgoal .gQ
i / of the expansion E. (By slightly abusing the notation,
we keep the same name  for the mapping that is induced by  on the subgoals.) Suppose
subgoal .gQ
i / comes from expanding subgoal gR
j in R. Then j .X/ D .X/. However, X
may occur in more than one subgoal of Q; thus, we may also have k.X/ D .X/ for some
k ¤ j. (The multiple occurrences of X in partial mappings will help later in the construction
of the rewriting, by determining which variables of the view subgoals used in the rewriting
should be equated to each other.) The mappings i do not deﬁne MCDs yet, because they
are not minimal with respect to the shared-variable property. To ﬁnd the minimal mappings, we
further decompose each j in the ﬁnest way possible, while retaining the property that each part
of the decomposition still preserves the shared-variable property. The outcome is a collection of
mappings jk for subgoal gR
j in R.
Now we show that the MCDs thus decomposed are disjoint. A MCD either has a single
exported query subgoal (i.e., it contains only exported variables), or has zero exported query
subgoals. Thus, if two MCDs from the same view subgoal of the rewriting (i.e., coming from two
partial mappings jk1 and jk2) have an overlap, they have at least one non-exported subgoal g
in their intersection. If subgoal g belongs in the intersection and shares a variable X with subgoal
g0, then it must be that either (a) X is an exported variable in both MCDs (because both have
the same set of exported variables), or (b) X is a non-exported variable in both MCDs. In the
latter case, g0 belongs in the intersection too. The reason is, whenever two subgoals share a non-
exported variable and one of the subgoals is in both MCDs, then the other has to be in each

100
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
MCD due to the shared-variable property, hence the second subgoal has to be in the intersection
too. Hence, the intersection has the shared-variable property, hence it is an MCD.
Thus, the MCDs of the same view subgoal of the rewriting do not overlap with each other.
We ﬁnish the proof by recalling that MCDs from diﬀerent view subgoals of the rewriting do
not overlap by construction of the expansion.

4.2.3
COMBINING MCDS—MOST RELAXED REWRITING
In Section 4.2.1, as we were discussing the deﬁnition of MCD, we also showed informally how
to use them, i.e., how to combine them to ﬁnd the most relaxed contained rewriting of the given
query. We now formalize the process in Procedure FindMostRelaxedRewriting (Figure 4.1). The
procedure provides a systematic way to ﬁnd all the CQs whose union constitutes an MCR in
the language of unions of CQs.
Input: a set of MCDs.
Output: Te most relaxed rewriting for the input set based on the classes of variables to
 
 be equated.
Method:
 
For each query variable/constant X, do:
 
     Form a class that contains all the view variables/constants that are images of X;
 
While the classes are not disjoint, do:
 
     Merge those classes that share an element;
 
Return (the classes) or fail if there is a class containing two distinct constants.
Figure 4.1: Procedure FindMostRelaxedRewriting.
The following result says that all the rewritings found by Procedure FindMostRelaxe-
dRewriting are actually contained rewritings of the given query.
Theorem 4.19
For a set of non-overlapping MCDs that cover all the subgoals of the input query,
the rewriting that is found by combining these MCDs as in Procedure FindMostRelaxedRewriting
is a contained rewriting in the query.
Now given a set of MCDs that cover all the query subgoals, we can construct more than
one contained rewriting. The following result establishes the semi-lattice structure of all such
contained rewritings. As a result, we can include in the MCR only the top element of the semi-
lattice.
Theorem 4.20
Let R be the set of all the contained rewritings of query Q using a given minimal
set of MCDs that covers all the query subgoals. Then, for any pair (R1; R2) of rewritings in R, there

4.2. FINDING MCRS FOR CQ QUERIES AND VIEWS: THE MS ALGORITHM
101
exists an R in R such that (a) R contains both R1 and R2; and (b) if there exists a rewriting R0 in R
such that R0 contains both R1 and R2, then R0 contains R as well.
Proof. We construct R as follows: The variables of R will be taken from the set of pairs of vari-
ables, where each pair has as its ﬁrst component a variable of R1, and has as its second component
a variable of R2. Atom V..X1; X2/; .Y1; Y2/; : : :/ is a subgoal of R iﬀ(a) atom V.X1; Y1/; : : :/ is
a subgoal of R1, and (b) atom V.X2; Y2/; : : :/ is a subgoal of R2. The head of R is a sequence of
the following pairs: (ﬁrst variable of head of R1, ﬁrst variable of head of R2), (second variable
of head of R1, second variable of head of R2), and so on.
For the R thus constructed, proving part (a) in the statement of the theorem is straightfor-
ward. To prove part (b), let R0 be a minimal rewriting that contains both R1 and R2. Therefore,
there exist two containment mappings, h1 from R0 to R1 and h2 from R0 to R2. We create a
containment mapping h from R0 to R by mapping variable X of R0 to the pair .h1.X/; h2.X//.

We now summarize the algorithm MS.
1. The input is CQ query Q and set of CQ views V.
2. Find all MCDs for each V in V for a rewriting of Q.
3. For each minimal set of MCDs that cover all query subgoals do:
4.
Find and output the most relaxed rewriting.
5. The resulting MCR is the union of all the most relaxed rewritings in the output.
MS algorithm
CQ query and views; ﬁnding MCRs for UCQ
The input is a CQ query and a set of CQ views.
The output is an MCR in the language of union of CQs.
For each given view, ﬁnd all MCDs.
Find minimal sets of MCDs that cover all the query subgoals and do
not overlap.
For each minimal set of MCDs discovered, construct the most relaxed
rewriting using Procedure FindMostRelaxedRewriting.
CQqueryandviews: There is always an MCR in the language of union
of CQs. However, an MCR in the language of CQs may not exist.
Algorithm MS is sound and complete. Theorem 4.18 says that any contained rewriting
has the property of being decomposable into MCDs, hence the algorithm is complete in the

102
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
sense that by using MCDs we do not miss any contained rewriting. Theorem 4.20 says that,
for any combination of MCDs, if we take only the top rewriting in the semi-lattice, then all
other rewritings are contained in it as queries. Thus, we do not miss any CQ contained rewriting
when we form the MCR. Soundness, i.e., the fact that all the rewritings that we ﬁnd are actually
contained in the query, follows from Theorem 4.19.
The algorithm MS has the advantage of not considering views that do not oﬀer the pos-
sibility of a partial mapping. In addition, the algorithm does not consider contained rewritings
that are not necessary, in the sense that they are already contained in another contained rewrit-
ing.
Discussion of the Algorithms MS and CoreCover
The two algorithms, MS for ﬁnding MCRs in the language of unions of CQs and CoreCover for
ﬁnding equivalent rewritings in the language of CQs, are based on the same intuition. We now
discuss the diﬀerences between them, and show by examples why these diﬀerences are necessary.
The following example shows that the requirement that the MCDs be non-overlapping
is necessary for the algorithm MS to be sound.
Example 4.21
Consider a query that is the path query P7, and the view be the path query P4.
We name the subgoals of P7 g1; : : : ; g7, in the order in which they appear along the path. Then,
among others, we have two MCDs, one that covers the subgoals g1; : : : ; g4, and the other that
covers the subgoals g4; : : : ; g7. The two MCDs overlap and together cover all the query subgoals.
However, we can show that R.X; Y / :- P4.X; X4/; P4.X3; Y / is not a contained rewriting of P7.
The following example shows that, in the CoreCover algorithm, the requirement that the
tuple cores not overlap cannot be added. The reason is that adding the requirement would cause
the algorithm to become incomplete.
Example 4.22
Consider query q.X; Y / :- a.X; Y /; b.X; Y /; c.X; Y / and two views, V1.X; Y /
:- a.X; Y /; b.X; Y / and V2.X; Y / :- b.X; Y /; c.X; Y /. We can show that R.X; Y / :- V1.X; Y /;
V2.X; Y / is an equivalent rewriting of the query. However, the tuple core for each view tuple is
the same as its body. The two tuple cores overlap, but both need to be included in the rewriting.
4.3
CQACS, THE HOMOMORPHISM PROPERTY,
EXTENDING ALGORITHM MS
In this section we extend the MS algorithm to ﬁnd MCRs for CQAC queries and views for the
cases where the homomorphism property holds.

4.3. CQACS, THE HOMOMORPHISM PROPERTY, EXTENDING ALGORITHM MS
103
When looking for equivalent rewritings in Chapter 3, we would use the homomorphism
property for the direction of ﬁnding homomorphisms that satisfy the ACs, from view deﬁni-
tions to the query canonical databases (see Theorem 3.22). This means that we were using the
homomorphism property for the direction of testing whether a query is contained in a rewrit-
ing. Now we use the homomorphism property for the direction of testing whether a rewriting
is contained in a query.
Deﬁnition 4.23
Let .B1; B2/ be a pair of sets of arithmetic comparisons that enables the
homomorphism property. Let V be a set of CQAC views with ACs, such that all the ACs
in V are in B2, and let Q be a CQAC query whose all ACs are in B1. Then we say that the
homomorphism property holds for ﬁnding MCRs.
For queries and views in the language of CQAC, we have that when the homomorphism
property holds, there always exists an MCR in the language of unions of CQACs.
Theorem 4.24
Let Q be a query and V a set of views, such that the homomorphism property holds
for ﬁnding MCRs. Then for any contained rewriting R of Q using V there exists a contained rewriting
R1 that AC-contains R, and such that the number of subgoals in R1 is at most equal to the number of
subgoals in the query.
Proof. Consider the AC-extension Re of R and its expansion Rexp
e . Since the homomorphism
property holds, there is a containment mapping  that maps all the ordinary and comparison
subgoals of Q to subgoals in Rexp
e . The key observation here is that there are no two variables
in Re that are equated in Rexp
e —the reason is that all the ACs that would contribute to such
an equation are already exported in Re by deﬁnition. Thus, all the variables that are targets of
 in Rexp
e
appear in at most n subgoals in Re, where n is the number of subgoals in the query.
Hence, we construct a rewriting R1 by keeping those subgoals, both relational and arithmetic
comparison, of Re that contain target variables. We can show that R1 is a contained rewriting
that also contains Re, and hence AC-contains R.

When the homomorphism property holds, we can use the intuition from the CQ case.
When the homomorphism property does not hold, the setting is considerably more involved.
The following example shows that ﬁnding an equivalent rewriting for the case of CQAC queries
and views does not follow the intuition that comes from the CQ case. (As each equivalent
rewriting is also a contained rewriting, this case is of interest in this chapter, whose focus is
on ﬁnding maximally contained rewritings.) While the following example does not give formal
evidence of the complexities of the general case, it is a simple illustration that oﬀers a hint.
Example 4.25
Consider the query Q1 from Example 2.14, which we also repeat here:
Q1./ :- r.X1; X2/; r.X2; X3/; r.X3; X4/; r.X4; X5/; r.X5; X1/; X1 < X2;
as well as two views:

104
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
V1.X1; X3/
:- p.X1; X2/; p.X2; X3/; X1 < X3:
V2.X1; X3/
:- p.X3; X4/; p.X4; X5/; p.X5; X1/:
The following is an equivalent rewriting of Q1 using the views:
R1./ :- V1.X1; X3/; V2.X1; X3/:
Now consider view V3:
V3.X1; X3/
:- p.X1; X2/; p.X2; X3/; X1 < X2:
The following rewriting R2 is an equivalent rewriting of Q1 using the views V3 and V2:
R2./ :- V3.X1; X3/; V2.X1; X3/:
Notice that the bodies of the two rewritings are the same, with the exception that the ﬁrst
relation symbol is diﬀerent (i.e., it is V1 for R1 and V3 for R2). However, the deﬁnitions of V1
and V3 are very diﬀerent.
Now we turn to the cases in which the homomorphism property holds. As in the case
without arithmetic comparisons, the extended MS algorithm has two parts. In the ﬁrst part,
we construct MCDs by ﬁnding partial mappings from the query subgoals to the view subgoals.
In the second part, we combine these mappings to construct a maximally-contained rewriting.
However, there are two major diﬀerences that we will explain next.
4.3.1
EXPORTABLE AND DISTINGUISHABLE VARIABLES OF AN
EXPANSION
We classify the variables in the expansion of a rewriting depending on their potential to enforce
ACs in other variables in the expansion of the rewriting, with the exception of the variables
appearing in the heads of the view deﬁnitions. Thus, each variable in an expansion belongs to one
of the following categories: exported, exportable, distinguishable, and non-exported variables.
We start with examples to oﬀer intuition for the deﬁnitions that will follow.
Exportable Variables
The following example shows that some variables behave like exported variables. This class of
variables was deﬁned in Section 3.2.2, in which we were discussing the properties of the expan-
sion of a rewriting. We can use this example as a justiﬁcation of the deﬁnition of exportable
variables in the next section.
Example4.26
We illustrate that arithmetic comparisons could “export” nondistinguished vari-
ables. Consider the following query Q1 and views V1 and V2:

4.3. CQACS, THE HOMOMORPHISM PROPERTY, EXTENDING ALGORITHM MS
105
Q1.A/
:- p.A/; A  4:
V1.Y; Z/
:- p.X/; s.Y; Z/; Y  X; X  Z:
V2.Y; Z/
:- p.X/; s.Y; Z/; Y  X; X < Z:
The following query R is a contained rewriting of the query Q1 using V1:
R.A/ :- V1.A; A/; A  4:
To see that the containment holds, suppose we expand this query by replacing the view subgoal
V1.A; A/ by its deﬁnition:
Rexp.A/ :- p.X/; s.A; A/; A  X; X  A; A  4:
The arithmetic comparisons in Rexp imply X D A. (X is exported, and hence arithmetic compar-
isons can be added on X in the rewriting—this is done by adding A  4 in the rewriting.) Thus,
the expansion is contained in Q1. Notice how the presence of the arithmetic comparisons helps
in ﬁnding a rewriting. Indeed, consider how the two views diﬀer. Although V1 and V2 diﬀer
only in their second inequalities, V2 cannot be used to answer Q1. The reason is that the variable
X of p.X/ in V2 does not appear in the head, and thus cannot be equated with another view
variable appearing in the head using arithmetic comparisons. Therefore, the condition A  4 in
the query cannot be enforced on V2. However, in V1 the variable X of p.X/ was “exported” as
distinguished, with the help of the proper inequalities.
Distinguishable Variables
Some variables are not necessarily exportable, but may still have some connection (via ACs) with
exported or exportable variables. Hence, one can control them in rewritings by adding ACs.
Example 4.27
Consider the same views as in Example 4.26. To build on the observation of
that example, consider query
Q0./ :- p.A/; A < 4:
Let the rewriting be as follows:
R0./ :- V2.Y; Z/; Z < 4:
The constraint “< 4” is imposed on the argument Z of R0 indirectly, because it is implied in
the expansion of the rewriting by the two inequalities Z < 4 in the rewriting and X < Z in the
deﬁnition of the view.
Now that we presented the intuition with examples, we are ready to deﬁne the four kinds
of variables.

106
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
– Exported variables are the variables in rewritings that occur in the head of the view
subgoals.
– Exportable variables: A variable X is exportable if there are two exported variables Y and
Z, such that the ACs in the view deﬁnition imply Y  X and X  Z. We call the variables Y
and Z anchors of X, speciﬁcally the left anchors and the right anchors, respectively. (There can be
more than one left or right anchors for a given variable.) The intuition for variables of this type
is that the ACs in the view deﬁnition give us the option of making these variables equal to two
exported variables. As a result, we can treat variables of this type as exported.
– Disinguishable variables: A variable X is distinguishable if there is an exported variable
Y such that XY , where  is a comparison operator in f<; >; ; ; ¤g. If there is no other
exported variable Z such that XZY , then Y is called an enabling variable of X. (There can be
more than one enabling variable for a given variable.) The intuition is that we can impose certain
kinds of ACs on variables of this type, due to the presence of ACs in the view deﬁnition.
– Non-exported variables are the rest of the variables.
4.3.2
AC-MCDS
In the case of CQAC queries and views, when the homomorphism property holds for ﬁnding
MCRs, then the components of the algorithm are the same as in the CQ case. We still need
to ﬁgure out how to add ACs. First, we deﬁne a seemingly straightforward replacement of an
MCD, called AC-MCD. However, we add an example to show that we still need to use MCDs,
because AC-MCDs as deﬁned do not cover all the cases.
Deﬁnition 4.28
(AC-MCD)
Let query Q and view V be CQACs. Consider the relational structure S of all the relational
atoms that are subgoals in the body of Q; let S0 be any substructure, i.e., subset, of S. We will
allow the homomorphism h, below, to map a variable of the query to multiple variables in the
view, as long as they are all distinguished or exportable variables in the view deﬁnition.2 Consider
the following.
• Let h be a homomorphism from the substructure S0 to the relational structure that is
comprised from the subgoals of V .
• Let ACV be a set of ACs on the head variables of the view deﬁnition, such that the fol-
lowing is true: The ACs in the view deﬁnition, together with the ACs in ACV , imply the
image under h of the ACs in S0.
• Suppose that the the triple .S; S0; h/ has the shared-variable property and is minimal with
respect to this property.
2Technically, h is not a homomorphism, but we still use this term, since we will turn h into a homomorphism when considering
the expansion of the assembled contained rewriting.

4.3. CQACS, THE HOMOMORPHISM PROPERTY, EXTENDING ALGORITHM MS
107
Then the quadruple .S; S0; h; ACV / is an AC-MCD for view V for rewriting Q.
Cross-View ACs
Example 4.29
Consider the following query and views:
Q./ :- a.X; Y /; b.X0; Z/; Y  Z:
V1 W v1.X/ :- a.X; Y /; Y  X:
V2 W v2.X/ :- b.X; Y /; X  Y:
Compare the two rewritings of Q:
R1./ :- v1.X/; v2.X0/:
R2./ :- v1.X/; v2.X/:
While R2 is contained in the query Q, R1 is not. This example illustrates how the most relaxed
rewriting is not necessarily a contained rewriting.
Now consider removing the ACs from the query Q; the result is the following query:
Q0./ :- a.X; Y /; b.X0; Z/:
Each of R1 and R2 is contained in Q0.
Let us provide some details. Consider the expansions of R1./ and R2./:
Rexp
1 ./ :- a.X; Y /; Y  X; b.X0; Y 0/; X0  Y 0:
Rexp
2 ./ :- a.X; Y /; Y  X; b.X; Y 0/; X  Y 0:
In Rexp
2 , we have the ACs Y  X and X  Y 0. As these ACs imply Y  Y 0, there is a contain-
ment mapping from Q to Rexp
2
such that the ACs in Rexp
2
imply the image of the AC in Q.
Observe that this is not possible for Rexp
1 .
This example shows that AC-MCDs are not suﬃcient for providing contained rewritings
for an MCR. Another point illustrated by the example is that the most relaxed rewriting may
not work, but there could be another rewriting that works. Hence, we need to consider in the
algorithm not just AC-MCDs, but also MCDs, which are formed by ignoring the ACs in the
query and views. We designate the most relaxed rewriting as MCR only when all the ACs
of the query are implied by the images of the ACs in the AC-MCDs; otherwise, we test for
containment in the query all the rewritings formed by using MCDs and AC-MCDs. In the
next section we discuss how to add the necessary ACs to a rewriting formed by using MCDs
and AC-MCDs.

108
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
4.3.3
COMBINING AC-MCDS AND MCDS, AND ADDING ACS
Overall, the procedure for constructing MCRs is similar to the one for the CQ case, except that
now the ﬁnal step involves (a) adding the appropriate ACs and (b) combine the newly added
ACs with the ACs that are already present in the expansion of the rewriting. If we are not able
to add ACs in such a way that the ACs in the expansion of the rewriting imply the image of the
ACs in the query, then we discard the current CQAC rewriting candidate. We now provide the
details.
The original MS algorithm applies to CQ queries and views without arithmetic com-
parisons, and combines MCDs by ﬁnding equivalence classes of variables in the heads of view
deﬁnitions. Recall that in the CQ case, when deﬁning a containment mapping we deﬁne equiv-
alence classes explicitly, understanding an equivalence class as a set of variables that are equated.
In the CQAC case, there is an implicit way to put variables into classes. Whenever two
variables belong to the same class and there is a third variable that is connected to both by
comparisons, these comparisons together with the equation of the two variables (implied by the
fact that they belong to the same equivalence class) may imply that the third variable is also
equal to the two others, and hence should be put into the same class. For example, suppose that
variables X and Y are in the same class, and there are two comparisons, X  Z and Y  Z.
The fact that X and Y are in the same equivalence class would imply that X D Y ; this equation,
together with X  Z and Y  Z, would then imply that Z D X. Hence, Z belongs to the
same class as X and Y .
In the second step of the algorithm, we consider combinations of views for covering all
the query subgoals. Each combination represents a candidate rewriting, and we add comparison
predicates to satisfy the comparison predicates in the query. Let X  c, with  being one of < and
, be an arithmetic comparison in the query, and suppose that X is mapped to a view variable Y
in a partial mapping. The expansion of a rewriting must imply the image of this restriction, i.e.,
Y  c. If Y is distinguished, we can just add “Y  c” to the rewriting. If Y is nondistinguished,
we cannot add any arithmetic comparison using Y directly to the rewriting, since Y does not
appear in the rewriting at all. However, there are two ways to satisfy this restriction even in the
case where Y is nondistinguished.
• Case I: The conjunction of the arithmetic comparisons in the deﬁnition of view V implies
“Y  c.”
• Case II: The conjunction of the arithmetic comparisons in the deﬁnition of view V implies
an AC between a non-distinguished variable Y and a distinguished variable Z; that is
the AC makes Y distinguishable. In this case, we can add to the rewriting an arithmetic
comparison “Z < c” or “Z  c,” as appropriate, to satisfy “Y  c.”

4.3. CQACS, THE HOMOMORPHISM PROPERTY, EXTENDING ALGORITHM MS
109
CQAC MS algorithm—the homomorphism property: When the
homomorphism property holds, in the sense that a single homomor-
phism from the query to the expansion of the rewriting suﬃces to show
the containment of the expansion to the query, then the algorithm MS
can be extended to ﬁnd an MCR in the language of unions of CQACs.
CQAC existence of MCR in unions of CQs—the homomorphism
property: When the homomorphism property holds, in the sense that a
single homomorphism from the query to the expansion of the rewriting
suﬃces to show the containment of the expansion to the query, then
there is always an MCR in the language of unions of CQACs.
We now summarize the algorithm Extended-MS.
1. The input is a CQAC query Q and set of CQAC views V.
2. For each set of exportable variables do:
3.
Find all MCDs and AC-MCDs.
4.
For each minimal set of MCDs and AC-MCDS that cover all the query subgoals, do:
5.
Combine the MCDs and AC-MCDs in the set to form a candidate rewriting R.
6.
Consider rewriting R and all the containment mappings from Q to Rexp.
For each containment mapping, do:
7.
Add ACs to the variables of Rexp that are also variables of R, so that the ACs
in the thus enhanced Rexp imply the image (under the considered
containment mapping) of the ACs in Q.
8.
Return R0, which is R enhanced with the ACs added in Step 7.
9. The MCR of Q using V is the union of all the returned rewritings.
Theorem 4.30
The algorithm Extended-MS ﬁnds an MCR in the language of unions of CQACs in
the cases where the homomorphism property holds for ﬁnding MCRs.
Proof. Let R be a contained rewriting of the given query, and let Rexp be the expansion of R
in which we the variables have been equated in such a way that the ACs in Rexp do not imply
equalities. This means that exportable variables are exported. Notice that this is the only way that
variables other than exported variables may be included among the variables that it is possible

110
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
to equate to other variables or values. Thus, the assumption that equalities are not implied by
the ACs in Rexp covers the part of considering all sets of exportable variables in the algorithm.
Let h be a mapping from the given query Q to Rexp such that h proves containment of
Rexp in Q. The mapping h can be seen as a containment mapping from the query with its ACs
removed to the expansion with its ACs removed. Thus, the decomposition into MCDs is the
same as in the case without ACs. Since the algorithm does not consider most relaxed rewritings,
there is nothing else to prove. The introduction of AC-MCDs is thus just an optimization step,
as the algorithm is already correct without considering them.

Example 4.31
Consider the following query and views:
Q./
:-
t.A/; A < 3:
V1./
:-
t.X1/; X1 < 3:
V2.X3/
:-
t.X1/; p.X2; X3/; X2  X1; X1  X3:
V3.X2; X3/
:-
t.X1/; p.X2; X3; X4/; X2  X1; X3  X1; X1  X4:
By mapping the query subgoal t.A/ to the subgoal t.X1/ of the view V1, we obtain a partial
mapping  that maps the variable A to X1. This forms the MCD .ft.A/g; ft.A/g; ; ;/. For
a rewriting of the query Q that uses this view, the expansion of the rewriting should entail
.A < 3/, i.e., X1 < 3.
Now consider view V2; since V2 has a comparison predicate X1  X3 and X3 is distin-
guished, we can add X3 < 3 to satisfy the inequality X1 < 3. Thus, if we take 0 as the mapping
from the variable of Q to the variable X1 of V2, we obtain the MCD .ft.A/g; ft.A/g; 0; fX1 <
3g/. The comparison predicate in V1 belongs to Case I, since its comparison predicate X1 < 3
can satisfy this inequality. The comparison predicates in V2 belong to Case II.
The comparison predicates in V3 do not belong to either case, thus V3 cannot be used to
cover the query subgoal. Thus, V3 cannot be used to form a subgoal in any contained rewriting.
As a result, we obtain two CQACs each of which is a contained rewriting of Q; their union is
an MCR for Q:
R1./ :- V1./:
R2./ :- V2.X3/; X3 < 3:
4.4
DATALOG
As discussed earlier, the language of MCR is a critical diﬀerentiator for whether an MCR exists
for the given query and views. In this section, we move to a more expressive language, Datalog,
which has recursion. After deﬁning Datalog, in Section 4.4.2 we provide an example with a
CQ query and UCQ views, to illustrate that recursion may sometimes be necessary in ﬁnding
MCRs. (In this book, we will not elaborate further on the case of UCQ views.) In Section 4.4.3

4.4. DATALOG
111
we provide an algorithm for ﬁnding MCRs for the case of Datalog queries and CQ views. In
Section 4.4.4 we illustrate with an example another case in which Datalog is needed to obtain
an MCR for the inputs in the language of CQACs.
4.4.1
DEFINITION OF THE DATALOG LANGUAGE
We have already deﬁned Datalog rules in Chapter 2, where we used the notion to deﬁne con-
junctive queries. A Datalog program is a set of Datalog rules. The predicates that appear in the
heads of the rules are called Intensional Database (IDB) predicates; the predicates that appear
only in the bodies of the rules are called Extensional Database (EDB) predicates. We evaluate
a query given by a Datalog program on a database that consists of relations that correspond to
the EDB predicates. (That is, the EDB predicates represent the relations in the database.) The
evaluation is done by evaluating the rules on the database until no more facts are added to the set
of the derived IDB predicates. (That is, the evaluation follows the ﬁxpoint, or minimal model,
semantics.) The answer to a Datalog program on a database is a set of facts derived on the database
for a designated IDB predicate, which is called the query predicate of the program.
A partial expansion of a Datalog program is a conjunctive query that results from unfold-
ing the rules one or more times; the partial expansion may contain IDB predicates. An expansion
of a Datalog program is a partial expansion that contains only EDB predicates. To avoid con-
fusion with the expansion of a rewriting, when it is not clear from the context, we will use the
term program-expansion to refer to an expansion of a Datalog program. A Datalog program is,
in general, equivalent to an inﬁnite set of conjunctive queries, with one such query for each ex-
pansion. A derivation tree of a fact computed by a Datalog program on an EDB database comes
from the way we unfold the rules to obtain the fact. The tree of a partial expansion is similar to the
derivation tree, with the exception that each node contains atoms of IDB and EDB predicates.
The leaves of the tree contain either EDBs or IDBs that are not unfolded.
We now provide an illustration for derivation trees, as well as for trees for partial expan-
sions and expansions.
Example 4.32
Consider a Datalog program that computes the transitive closure on a graph
given as binary EDB relation e.
q.X; Y / :- e.X; Y /:
q.X; Y / :- q.X; Z/; e.Z; Y /:
This program has one nonrecursive rule, the ﬁrst rule above, and one recursive rule—the second
rule.
One partial expansion is as follows:
q.X; Y / :- q.X; Z/; e.Z; Y 0/; e.Y 0; Y /:
This partial expansion was created by unfolding the atom with predicate q in the recursive rule
using the same rule. The tree of this partial expansion is shown in Figure 4.2. We construct this

112
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
tree as follows: Start with the root q.X; Y /; use the recursive rule to unfold, which results in the
two children of the root, q.X; Y 0/ and e.Y 0; Y /. (We use Y 0 to replace Z in the recursive rule.)
Then unfold q.X; Y 0/, to obtain the two children q.X; Z/ and e.Z; Y 0/. (In the recursive rule,
we replace X with X, Y with Y 0, and Z with Z.)
q(X,Y)
q(X,Y′)
e(Z,Y′)
q(X,Z)
e(Y′,Y)
Figure 4.2: The tree for partial expansion q.X; Y / :- q.X; Z/; e.Z; Y 0/; e.Y 0; Y /:
One expansion is as follows:
q.X; Y / :- e.X; Z/; e.Z; Y 0/; e.Y 0; Y /:
This expansion is obtained from the above partial expansion by unfolding q.X; Z/ using the
nonrecursive rule. The corresponding tree is shown in Figure 4.3. Comparing Figure 4.2 with
Figure 4.3, we observe that the tree for the partial expansion has a leaf that corresponds to the
IDB-predicate atom, while in the expansion tree, all the leaves are EDB atoms.
q(X,Y)
q(X,Y′)
e(Z,Y′)
q(X,Z)
e(Y′,Y)
e(X,Y′)
Figure 4.3: The tree for expansion q.X; Y / :- e.X; Z/; e.Z; Y 0/; e.Y 0; Y /:

4.4. DATALOG
113
Now consider a database instance D for predicate e: D D f.a; b/; .b; c/; .c; d/g. Let us
compute q.a; d/, illustrating the computation with the derivation tree of Figure 4.4. We use the
nonrecursive rule to compute q.a; b/, by replacing X with a and Y with b. This is illustrated at
the lowest level of Figure 4.4, where q.a; b/ has the only child e.a; b/. We then use the recursive
rule to compute the fact q.a; c/, by replacing X with a, Y with c, and Z with b. This is illustrated
in the part of the tree in Figure 4.4 that shows the two children, q.a; b/ and e.b; c/, of the node
q.a; c/. We then use the recursive rule again, to compute the root q.a; d/, whose children are
the facts are used for its computation. This step completes the computation process.
q(a,d)
q(a,c)
e(b,c)
q(a,b)
e(c,d)
e(a,b)
Figure 4.4: Derivation tree that corresponds to the expansion of Figure 4.3.
Observe that the trees of Figure 4.3 and Figure 4.4 are the same, with the exception
that the variables of Figure 4.3 are replaced by constants in Figure 4.4. This is no coincidence,
because the expansion q.X; Y / :- e.X; Z/; e.Z; Y 0/; e.Y 0; Y / was used as a conjunctive query to
compute q.a; d/. The way this expansion tree was constructed was a top-down construction of
the derivation tree in Figure 4.4, which was in turn constructed in the bottom-up fashion.
For more details on the Datalog language, see textbooks mentioned in the bibliographical
notes in the end of this book.
4.4.2
VIEWS THAT ARE UNIONS OF CQS
In this section we consider views that are unions of CQs, also referred to as “disjunctive views.”
This section provides a single example, which illustrates that for views in this language, Datalog
could be used to ﬁnd an MCR of a CQ query.
Example 4.33
Consider query Q and views V1 through V3:
Q./ :- c.X; Y /; a.Z0; Y /; b.Y; Z/:

114
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
v1.Y / :- a.X; Y /:
The view V2 is a disjunctive view with two rules:
v2.X; Y; Z/ :- c.X; Y /; b.Y; Z/; c.X0; Z/:
v2.X; Y; Z/ :- c.X; Y /; a.Y; Z/; c.X0; Z/:
The view V3 is as follows:
v3.X/ :- b.X; Y /:
To ﬁnd a contained rewriting of Q using these three views, we have to use the view V2, as it
is the only view that has an occurrence of an atom with relational symbol c. Thus, a contained
rewriting is the following:
R0./ :- v1.X/; v2.Z; X; W1/; v3.W1/:
Its expansion is
Rexp
0 ./ :- a.W; X/; c.Z; X/; dab.X; W1/; c.X0
1; W1/; b.W1; W 0/:
Here, we use the symbol dab to denote that the relational atom dab.X; W1/ is either a.X; W1/ or
b.X; W1/, according to the deﬁnition of view V2. If dab.X; W1/ is b.X; W1/, then the contain-
ment mapping that proves the containment of this expansion in the query maps X to Z, Y to
X, Z0 to W , and Z to W1. If, on the other hand, dab.X; W1/ is a.X; W1/, then the containment
mapping that proves the containment of this expansion in the query maps X to X0
1, Y to W1,
Z0 to X, and Z to W 0.
We can build many contained rewritings of Q by using any number of occurrences of the
view V2. In fact, for any natural number i, the following is a contained rewriting in Q using the
given views:
R./ :- v1.X/; v2.Z; X; W1/; v2.Z; W1; W2/; v2.Z; W2; W3/; : : : v2.Z; Wi; WiC1/; v3.WiC1/:
Since there are inﬁnitely many contained rewritings, Datalog may be a language in which we
can ﬁnd an MCR for this case.
4.4.3
REWRITING DATALOG QUERIES–THE INVERSE-RULE
ALGORITHM
Consider a setting in which the query deﬁnition is a Datalog program, and the view deﬁnitions
are conjunctive queries.
Deﬁnition 4.34
For each rule R that deﬁnes a view, we construct a number of inverse rules,
one inverse rule Ri for each subgoal of the rule R, as follows. Suppose R is deﬁned as
q.X/ :- g1.X1/; : : : ; gn.Xn/:

4.4. DATALOG
115
Then for each subgoal gi.Xi/ in R we construct the inverse rule Ri:
gi.Y i/ :- q.X/:
Here, the variable X in Y i is the same as in Xi if X appears in X (and in the same position of
Y i as in Xi), otherwise X is replaced by f X.X/ in the same position. Here, f X is a function
symbol that is diﬀerent for each non-distinguished variable X of the view.
Construction of the inverse-rule program: Suppose we are given a Datalog query Q
and set V of CQ views. The inverse-rule program Q of Q with respect to the view set V is
constructed as follows. The program consists of the rules of the query Q, together with the
inverse rules obtained from the views in V. The function-free output of the inverse-rule program
comprises those output tuples of this program that do not contain function symbols.
Consider an illustration of the construction.
Example 4.35
Consider a query Q deﬁned by the following Datalog program:
q.X; Y / :- e.X; Y /:
q.X; Y / :- q.X; Z/; e.Z; Y /:
Let the view V be deﬁned as
V.X; Y / :- e.X; Z/; e.Z; Y /:
For this view, we obtain two inverse rules:
e.X; f .X; Y // :- V.X; Y /:
e.f .X; Y /; Y / :- V.X; Y /:
Here, f .X; Y / intuitively represents the value of Z in the view deﬁnition, because Z appears in
the subgoal but not in the head. The function f is the same in each of the inverse rules created
from the view deﬁnition. The reason is, while we don’t know the value of Z that is needed for
making the body of this rule true for a given X and Y , we do know that it has to be the same Z
in each of the subgoals of the view V .
The following is the inverse-rule program Q of the query Q using the view V :
q.X; Y / :- e.X; Y /:
q.X; Y / :- q.X; Z/; e.Z; Y /:
e.X; f .X; Y // :- V.X; Y /:
e.f .X; Y /; Y / :- V.X; Y /:

116
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
The program has one EDB predicate, V , and is constructed as follows: the ﬁrst two rules are
copied from the deﬁnition of q, and the remaining rules are the inverse rules.
Now we show that the inverse-rule program Q with respect to view set V is an MCR of
Q using V in the language of Datalog.
Theorem 4.36
The function-free output of the inverse-rule program Q of Q with respect to V is
contained in Q.
Proof. We prove ﬁrst that the computation of the inverse-rule program terminates, i.e., that any
ﬁnite-size relations for the views in V produce a ﬁnite number of tuples for the predicate q. We
argue as follows: Observe that there is a ﬁnite set of values that can appear in tuples in the heads
of the rules of the inverse-rule program. (Some of these values are of the form f X.c/, that is,
they use a function symbol with c being a vector of values from the input view relations.) Since
there are only a ﬁnite set of tuples that could ever be deduced for an IDB relation, then the
Datalog program will terminate.
Observe that every bottom-up evaluation of this program progresses in two stages: the
recursive stage, which uses the program of the query, and then the non-recursive stage, which
uses the inverse rules. Thus, the evaluation terminates whenever the Datalog program of the
query terminates.
We now prove the containment. Consider the bottom-up evaluation of Q, and take the
derivation tree T that is constructed during the computation. The leaves of this tree T are view
facts, but their parents are EDB predicates of the Datalog program that computes Q, and the
rest of the tree is the same as a derivation tree T 0 of the Datalog program that computes Q.
The derivation trees T and T 0 correspond to program-expansions E and E0. Viewing E as a
rewriting, we prove now that it is a contained rewriting in Q. Consider any leaf in the derivation
tree T . This leaf is some view fact Vi.t/, whose parent, say ej .t0/, came from the construction
of an inverse rule (and is the head of this inverse rule), hence it appears in the body of the view
deﬁnition of Vi. Thus, an atom ej .t00/ instantiated according to the deﬁnition of view Vi appears
in Eexp as well. It is easy to check that there is a mapping from E0 to Eexp that maps ej .t0/ to
ej .t00/. This proves containment in E0 of the expansion Eexp of E.

Theorem 4.37
The funcion-free output of the inverse-rule program of Q with respect to V is equal
to the output of an MCR of Q using views in V.
Proof. Since a Datalog program is equivalent to an inﬁnite union of CQs, it suﬃces to prove
that any CQ rewriting R that is contained in Q is also contained in the function-free output
of the inverse-rule program of Q with respect to V. Since R is a contained rewriting of Q, its
expansion Rexp is contained in Q. The homomorphism from a program-expansion of Q to Rexp

4.4. DATALOG
117
yields a homomorphism h from the program-expansion of the inverse-rule program of Q using
views V to Rexp. To show that, we follow the argument used in the proof of Theorem 4.36.

Datalog queries, CQ views, MCR inverse-rule program
Constructing the inverse-rule program:
• Use view deﬁnitions to obtain inverse rules that use function sym-
bols.
• Construct the inverse-rule program from the Datalog program
deﬁning the query and from the inverse rules.
• The output of the inverse-rule program is the tuples computed in
the query predicate of the Datalog program that do not contain
function symbols among their values.
Eliminating the function symbols: We can produce a program without function sym-
bols; it would yield the function-free output of the inverse-rule program. We do that by pred-
icate splitting. The intuition for predicate splitting is that we partition the output of a speciﬁc
IDB predicate according to which function symbols occur among its arguments, and in which
argument positions these function symbols occur. For example, if a predicate p has arity three
and we use two function symbols, we will split p into 32C1 new predicates, which we denote
using adornments as p;; (for the outputs without function symbols), p;f1.;:::;/; (for the
outputs with function symbol f1 in the second place only), p;f2.;:::;/; (for the outputs with
function symbol f2 in the second place only), etc. The number of new predicates is .2 C 1/3,
because we also count the case in which a constant appears without function symbols.
For instance, in working with the IDB predicate q of Example 4.35, we would split it
into four new predicates, denoted as q;, qf .;/;, q;f .;/, and qf .;/;f .;/. Now, since we
would prefer to work with notation that does not use function symbols, the arity of the adorned
predicates would change appropriately. That is, q; has arity two, qf .;/; and q;f .;/ each
have arity three, and qf .;/;f .;/ has arity four.
The general procedure for eliminating function symbols is as follows: We deﬁne an adorn-
ment of a predicate p to be a vector with one component for each argument of p, and each ar-
gument can be either  (meaning no function symbol) or a function symbol. For each function
symbol in the adornment, we do not have to state its arity by using *; we still do that, because
this makes the arity of the predicate explicit—and thus improves readability. We consider all
possible adornments for p, proceeding as follows. For each rule with head predicate p, produce
from the rule one or more rules, according to the number of possible adornments of p. For each
particular adornment ˛, we proceed as follows to produce the rules with head p˛. For conve-
nience, we have a preliminary stage where we keep the function symbols in the arguments of

118
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
p˛ in a way that is consistent with ˛. For example, for ˛ D ; f .; /, we have p˛.X; f .Y; Z//.
Then we propagate the variables or functions of variables to the body of the rule, i.e., if the sec-
ond argument of p appears in a position in some subgoal, we replace the variable in this position
with f .Y; Z/. Now, if there are no non-distinguished variables in the body, all that remains to
be done is to add adornments to the predicates in the body of the rule that follow the pattern in
the arguments. For example, if the arguments are X; Y; f .X; W; W 0/; Z, we add the adornment
; ; f .; ; /; . On the other hand, if there are non-distinguished variables in some argu-
ments in the body, then we construct more than one rule, considering all combinations of those
arguments being either  or one of the function symbols used in the inverse rules. In the end,
we drop the function symbols in the arguments of the predicates, by simply deleting them and
listing the variables as they appear. Notice that this means, e.g., that predicate p; will have two
arguments, but predicate pf .;;/; will have four arguments. The output of this function-free
program is the tuples in the query predicate with adornments ; ;  : : :. A detailed example
follows.
Example 4.38
In Example 4.35, we obtained for the predicate q four adorned predicates, q;,
qf .;/;, q;f .;/, and qf .;/;f .;/. Now for the IDBs in the head of each inverse rule, we have
trivially only one adorned predicate. This way, we obtain a new program as shown below. Here,
we use a broken line to separate the rules in accordance with which rules of the MCR provided
in Example 4.35 generate each of these new rules. In other words, the ﬁrst four rules below
originate from the ﬁrst rule for the MCR of Example 4.35, the next eight rules originate from
the second rule, and the last two rules originate from the third and fourth rules, respectively.
q;.X; Y / :- e;.X; Y /: It is easy to see that this rule will never be used.
q;f .;/.X; W; Y / :- e;f .;/.X; W; Y /: This rule will be used only when W D X.
qf .;/;.X; W; Y / :- ef .;/;.X; W; Y /: This rule will be used only when W D Y .
qf .;/;f .;/.X; Y; Y / :- ef .;/;f .;/.X; Y; Y /: This rule will never be used.
————————————–
q;.X; Y / :- q;f .;/.X; Z; Y 0/; ef .;/;.Z; Y 0; Y /:
q;.X; Y / :- q;.X; Z; /; e;.Z; Y /: This rule will never be used.
qf .;/;.X; Y; Z/ :- qf .;/;f .;/.X; Y; X0; Y 0/; ef .;/;.X0; Y 0; Z/:
qf .;/;.X; Y; Z/ :- qf .;/;.X; Y; X0/; e;.X0; Z/: This rule will never be used.
q;f .;/.X; Y; Z/ :- q;f .;/.X; X0; Y 0/; ef .;/;f .;/.X0; Y 0; Y; Z/: This rule will never
be used.
q;f .;/.X; Y; Z/ :- q;.X; X0/; e;f .;/.X0; Y; Z/:
qf .;/;f .;/.X; Y; Z; W / :- qf .;/;.X; Y; Z0/; e;f .;/.Z0; Z; W /:
qf .;/;f .;/.X; Y; Z; W / :- qf .;/;f .;/.X; Y; X0; Y 0/; ef .;/;f .;/.X0; Y 0; Z; W /:
This rule will never be used.
————————————–
e;f .;/.X; X; Y / :- V.X; Y /:
————————————–

4.4. DATALOG
119
ef .;/;.X; Y; Y / :- V.X; Y /:
The output of the program will be the tuples in predicate q;.
We have mechanically listed all the rules. It is not hard to see that some of the rules are
useless (see the comments above). The reason is that, e.g., predicate e; will never have any
tuples, because the two inverse rules (the two last rules in the program) provide tuples only for
predicates e;f .;/ and ef .;/;, and these are the only rules that provide tuples for predicate e
with any adornment.
To see how we do the bookkeeping of which variables to use in the adorned predicates,
we use a preliminary stage. For instance, to get the rule
qf .;/;.X; Y; Z/ :- qf .;/;f .;/.X; Y.X0; Y 0/; ef .;/;.X0; Y 0; Z/;
as explained in the general procedure of function-symbol elimination, we write ﬁrst the more in-
tuitive rule qf .;/;.f .X; Y /; Z/ :- qf .;/;f .;/.f .X; Y /; f .X0; Y 0//; ef .;/;.f .X0; Y 0/; Z/;
and then drop the function symbols.
Now we are going to derive a more compact (i.e., with fewer rules) equivalent program by
making the following observations.
• The only useful rule with head q; is the ﬁrst rule in the second group of rules.
• This rule uses q;f .;/ as the only recursive predicate; the only useful rules with head
q;f .;/ are (a) the second rule in the ﬁrst group of rules, and (b) the sixth rule in the
second group of rules.
• It turns out that these three rules are the only rules apart from the two inverse rules that
will be used to provide tuples in p;. We show below how this is done.
Consider the ﬁrst rule of the second group; we unfold its ﬁrst subgoal using the sixth rule of the
second group. After the unfolding, this yields
q;.X; Y / :- q;.X; X0/; e;f .;/.X0; Z; Y 0/; ef .;/;.Z; Y 0; Y /:
We have already seen that we only have tuples in e;f .;/ if its ﬁrst two arguments are equal,
and that we only have tuples for ef .;/; if its last two arguments are equal. For this reason, we
can use the above rule only if X0 D Z and Y 0 D Y . Thus, we rewrite the rule after replacing Z
with X0 and Y 0 with Y :
q;.X; Y / :- q;.X; X0/; e;f .;/.X0; X0; Y /; ef .;/;.X0; Y; Y /:
Using the ﬁrst inverse rule, we replace e;f .;/.X0; X0; Y / with V.X0; Y /; using the other inverse
rule, we replace ef .;/; with V.X0; Y /. This yields the rule
q;.X; Y / :- q;.X; X0/; V.X0; Y /:
With similar reasoning, we also obtain the base rule
q;.X; Y / :- V.X; Y /:

120
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
These are the two rules of a compact equivalent program.
Note that the equivalence of the program with function symbols to the program without
function symbols is straightforward. Indeed, by doing function-symbol elimination, we simply
“hide” the function symbols in the adornments of the predicates; hence, they become implicit
rather than explicit.
Function-symbol elimination of the inverse-rule program
• Introduce adornments for predicate symbols.
• For each predicate symbol, introduce their adorned version.
• From each rule of the inverse-rule program, construct a collection
of rules using the adorned versions of the predicates.
The procedure of function-symbol elimination may result in the empty query. Consider
an example.
Example
4.39
Let
query
Q
be
given
by
the
following
Datalog
program:
q.X; Y / :- e1.X; Z/; e2.Z; Y /:
q.X; Y / :- q.X; Z/; e1.Z; Z0/; e2.Z0; Y /:
Suppose we are also given two views, deﬁned as follows: V1.X; Y / :- e1.X; Z/; e1.Z; Y /:
V2.X; Y / :- e2.X; Z/; e2.Z; Y /:
The Datalog query q computes all those paths in a labeled graph whose arcs are labeled
e1e2e1e2    . It turns out that the given views cannot be combined into a contained rewrit-
ing of q in the language of CQ. Indeed, one of the views returns paths labeled e1e1, and the
other view returns paths labeled e2e2. We construct now the inverse-rule program to verify this
intuition.
The following is the inverse-rule program Q of the query Q using the views V1 and V2:
q.X; Y / :- e1.X; Z/; e2.Z; Y /:
q.X; Y / :- q.X; Z/; e1.Z; Z0/; e2.Z0; Y /:
e1.X; f1.X; Y // :- V1.X; Y /:
e1.f1.X; Y /; Y / :- V1.X; Y /:
e2.X; f2.X; Y // :- V2.X; Y /:
e2.f2.X; Y /; Y / :- V2.X; Y /:
The ﬁrst rule of this program will not produce any outputs that would not contain function
symbols, for any view instance. Indeed, the ﬁrst rule can only be applied to the outputs of the last
four inverse rules. Thus, e1.X; Z/ can be replaced either by e1.x; f1.x; y// or by e1.f1.x; y/; y/,
for some constants x and y. In the ﬁrst case, the second atom e2.Z; Y / should be such that Z is
replaced by f1.x; y/. But there is no atom of the form e2.f1.x; y/; y/ derived from the last two

4.4. DATALOG
121
rules. Hence, this case will not derive any atom in the output of q. The second case is possible
and will derive an atom of the form q.f1.x; y/; f2.x; y//. If we substitute such an output into
the second, recursive, rule, we will need an atom of the form e1.f2.x; y/; Z0/, which cannot be
derived from the two rules with head e1. Hence, the function-symbol-free output of the above
program will be empty for any view instance. In fact, the recursive rule (the second rule above)
will never be used.
We now discuss function-symbol elimination. Using the reasoning from Example 4.38,
we can obtain the rule
q;.X; Y / :- q;.X; X0/;
e;f1.;/
1
.X0; W; W 0/ef1.;/;f1.;/
2
.W; W 0Z; Y 0/;
ef1.;/;f1.;/
1
.Z; Y 0; W1; W2/; ef1.;/;
2
.W1; W2; Y /:
This rule will never be used, because there is no predicate ef1.;/;f1.;/
2
. In general, unfolding
will yield either predicates e;
i
, or predicates e1 with adornment containing function symbol
f2, or predicates e2 with adornment containing function symbol f1. Since there are no such
predicates in the rules of the inverse-rule program, the output of the program is always empty.
4.4.4
CQAC-SI QUERIES AND VIEWS
We now present an example with CQAC query and views whose all comparisons are semi-
interval (CQAC-SI) comparisons. We show that there is no MCR in the language of unions of
CQs for this example. We also show that a Datalog rewriting is a contained rewriting.
Example 4.40
We revisit Example 4.9. Consider query Q1 and views V1, V2, and V3, deﬁned
as follows:
Q1./
:- e.X; Z/; e.Z; Y /; X  5; Y  8:
V1.X; Y /
:- e.X; Z/; e.Z; Y /; Z  5:
V2.X; Y /
:- e.X; Z/; e.Z; Y /; Z  8:
V3.X; Y /
:- e.X; Z1/; e.Z1; Z2/; e.Z2; Z3/; e.Z3; Y /:
The following Datalog program is a contained rewriting of the input query Q1 using the views
V1.X; Y /, V2.X; Y /, and V3.X; Y /:
R./
:- V1.X; W /; T .W; Z/; V2.Z; Y /:
T .W; W /
:- :
T .W; Z/
:- T .W; U /; V3.U; Z/:
To prove that this is a contained rewriting, we need to prove that each program-expansion is a
contained rewriting. We provide an argument for one of the expansions; the reasoning is similar
for the other expansions.

122
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
We focus on the following program expansion:
E./ :- V1.X; W /; V3.Z1; Z2/V2.Z2; Y /:
Consider the expansion Eexp of E:
Eexp./ :- e.X; Z/; e.Z; W /; Z  5; e.W; Z0
1/; e.Z0
1; Z0
2/; e.Z0
2; Z0
3/; e.Z0
3; Z1/; e.Z1; Z00
1/;
e.Z00
1; Z00
2/; e.Z00
2; Z00
3/; e.Z00
3; Z2/; e.Z2; Z4/; e.Z4; Y /; Z4  8:
To show that Eexp is contained in Q1, we argue informally as follows: Either there is a
mapping that satisﬁes the ACs from the subgoals of Q1 to the second and fourth subgoals of
Eexp, which means that Z0
1  8, or Z0
1 > 8, which means Z0
1  5. If the latter is true, then either
there is a mapping from the subgoals of Q1 to the ﬁfth and sixth subgoals of Eexp, which means
that Z0
3  8, or Z0
3 > 8, which means Z0
3  5. The argument goes on in a similar way, until we
either ﬁnd a mapping that satisﬁes the ACs, or we have arrived in the end of Eexp without ﬁnding
such a mapping. We thus derive that Z00
3  5. Thus, also taking into account that Z4  8, we
conclude that there is a mapping that satisﬁes the ACs on the subgoals e.Z00
3; Z2/ and e.Z2; Z4/
of Eexp.
4.5
EXERCISES
4.1.
Consider query
Q W q1.S; C/ :- a.M; D/; b.D; C/; c.S; M; C/:
and views
V1:
v1.M1; D1; C1/
:- a.M1; D1/; b.D1; C1/:
V2:
v2.S2; M2; C2/
:- c.S2; M2; C2/:
V3:
v3.M3; D3; C3/
:- a.M3; D3/; b.D3; C3/:
Find an MCR in the language of unions of CQs.
4.2.
In the following Example 4.41, prove that the suggested rewriting is an MCR in the
language of unions of CQs.
Example 4.41
Consider a CQ query Q that is the path query P7, and CQ views that
are path queries P2 and P3 (recall the deﬁnition of path queries in Deﬁnition 2.44). Let
the language of rewritings be unions of CQs (UCQ). The following rewriting, which
consists of CQs R1; R2, and R3, is the MCR for the language UCQ:
R1 W q.X; Y / :- P2.X; Z/; P3.Z; Z0/; P2.Z0; Y /:
R2 W q.X; Y / :- P2.X; Z/; P2.Z; Z0/; P3.Z0; Y /:
R3 W q.X; Y / :- P3.X; Z/; P2.Z; Z0/; P2.Z0; Y /:

4.5. EXERCISES
123
Each of R1, R2, and R3 individually happens to be an equivalent rewriting of the query
Q using the given views. However, we need them all in a union-of-CQs rewriting to
construct an MCR. To see why, observe that, for instance, R1 is not contained in R2
(as queries), although Rexp
1
and Rexp
2
are equivalent.
4.3.
Modify the CoreCover algorithm so that the containment test would not be needed. Hint:
decompose the tuple cores into MCDs.
4.4.
Consider query Q that is a path query P9; let the three views be path queries P3; P6,
and P7. Find an MCR of Q using the views in the language of unions of CQs.
4.5.
Consider the query and views of Example 4.9. Prove that, for any positive integer k > 0,
the following is a contained rewriting of the query using the views:
Rk :- V1.X; Z1/; V3.Z1; Z2/; V3.Z2; Z3/; : : : ; V3.Zk 1; Zk/; V2.Zk; Y /:
4.6.
Consider query Q and view V :
Q./ :- p.X; Y /; p.Y; Z/; s.X; Z/; p.Z; Y 0/; p.Y 0; Z0/; s.Z; Z0/; t.Z/:
V.Z; W / :- p.X; Y /; p.Y; Z/; s.X; Z00/; p.Z; Y 0/; p.Y 0; Z0/; s.Z00; Z0/; t.W /;
Z  Z00  W:
Prove that the homomorphism property holds for ﬁnding MCRs. Find an MCR in the
language of unions of CQACs.
4.7.
Consider query Q and view V :
Q./ :- p.X; Y /; p.Y; Z/; s.X; Z/; p.Z; Y 0/; p.Y 0; Z0/; s.Z; Z0/; t.Z/:
V.Z; W / :- p.X; Y /; p.Y; Z/; s.X; Z00/; p.Z; Y 0/; p.Y 0; Z0/; s.Z00; Z0/:
Prove that the homomorphism property holds for ﬁnding MCRs. Find an MCR in the
language of unions of CQs.
4.8.
Consider queries Q and Q0, as well as view V .
Q./ :- p.X; Y /; p.Y; Z/; s.X; Z/; p.Z; Y 0/; p.Y 0; Z0/; s.Z; Z0/; t.Z/:
Q0./ :- p.X; Y /; p.Y; Z/; s.X; Z00/; p.Z; Y 0/; p.Y 0; Z0/; s.Z00; Z0/; t.W /; Z00  5:
V.Z; W / :- p.X; Y /; p.Y; Z/; s.X; Z00/; p.Z; Y 0/; p.Y 0; Z0/; s.Z00; Z0/; t.W /; Z00  W:
Prove that the homomorphism property holds for ﬁnding MCRs. Find an MCR in the
language of unions of CQACs for Q using the view and an MCR for Q0. Why there is
a diﬀerence in the MCR found?

124
4. MAXIMALLY CONTAINED REWRITINGS (MCRS)
4.9.
Let query Q and view V be as follows:
Q.X; Z/ :- a.X; Y /; a.Y; Z/:
V.X; Z; A; B/ :- a.X; Y /; a.Y; Z/; b.A; B/; A  Y; Y  B:
Prove that the homomorphism property holds for ﬁnding MCRs. Find an MCR of Q
using V in the language of unions of CQACs. Hint: think on the dual role of exportable
variables.
4.10. Consider the following query Q and view V :
Q.A/
:-
p.A; A/:
V.X1; X2; X3; X6; X7; X8/
:-
p.X4; X5/; s.X1; X2; X3; X6; X7; X8/,
X3  X5; X5  X7;
X1  X4; X8  X2; X2  X4; X4  X6:
Prove that the homomorphism property holds for ﬁnding MCRs, and ﬁnd an MCR
for the query using the view in the language of unions of CQACs.
4.11. Consider the following query and views:
Q
:- t.A/; p.A/:
V1.X/
:- p.X/:
V2.X; Z/
:- t.X/; p.Y /; s.Y; Z/; X  Y; Y  Z:
Prove that the homomorphism property holds for ﬁnding MCRs. Construct an MCR
in the language of unions of CQACs for the query using the views.
4.12. In Example 4.38, remove the unnecessary rules, and unfold the remaining rules appro-
priately, to show that the resulting MCR is equivalent to
R.X; Y / :- V.X; Y /:
R.X; Y / :- R.X; Z/; V.Z; Y /:

125
C H A P T E R
5
Answering Queries in Presence
of Dependencies
In this chapter we revisit the problems of query containment and of ﬁnding equivalent and
maximally contained rewritings for the case where we are interested in applying the results only
on those database instances that satisfy certain dependencies.
5.1
PRELIMINARIES
We consider dependencies that are tuple-generating dependencies (tgds) and equality-
generating dependencies (egds), with the deﬁnitions to follow. In the deﬁnitions, for notational
consistency with the literature on the topic, we switch the notation to denoting variables using
lowercase letters instead of uppercase, and to denoting vectors of variables in boldface instead
of bar.
Deﬁnition 5.1
(tgds-egds)
Let D be a database schema.
– A tuple-generating dependency .tgd/ is a ﬁrst-order formula of the form
8x
 .x/ ! 9y  .x; y/

:
– An equality-generating dependency .egd/ is a ﬁrst-order formula of the form
8x
 .x/ ! .x1 D x2/

:
In the above formulas, .x/ is a conjunction of atoms over D with variables in x, such that each
variable in x occurs in at least one atom in .x/; x1 and x2 are variables from x. In addition,
 .x; y/ is a conjunction of atoms with variables in x and y, such that each variable in y occurs
in at least one atom in  .x; y/.
In what follows we will drop the quantiﬁers and write tgds using the format
.x/ !  .x; y/;
and will write egds using the format
.x/ ! .x1 D x2/:

126
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
Observe the relationship of Deﬁnition 5.1 with the deﬁnition of conjunctive queries,
which are expressions of the form Q.x/ :- 9y.x; y/, with .x; y/ a conjunction of atoms that
we call subgoals of the query.
Deﬁnition 5.2
Let d W .x/ !  .x; y/ be a tgd and D a database instance. We say that D
satisﬁes d if whenever there is a homomorphism h from .x/ to D, there exists an extension h0
of h such that h0 is a homomorphism from the conjunction .x/ ^  .x; y/ to D. We say that
D satisﬁes an egd .x/ ! x1 D x2 if for each homomorphism h from .x/ to D, we have that
h.x1/ D h.x2/.
5.1.1
THE CHASE
The chase algorithm is the main tool for reasoning about dependencies. It is applied on a database
instance with a given set † of dependencies, and the result after termination is guaranteed to
satisfy †. In this section we describe the chase algorithm, give conditions that guarantee termi-
nation of the chase on any database instance, and provide a formal result that describes a property
of the chase that we use in the rest of this chapter and in Chapter 6. Then in Section 5.3 we use
the chase to develop algorithms for checking CQ query containment and for ﬁnding equivalent
rewritings of CQ queries using CQ views under dependencies.
In this chapter and in Chapter 6, by database instance we understand a set of atoms that
are not necessarily ground atoms (i.e., atoms whose all values are constants). The main reason
is the deﬁnition of the chase procedure, which may be unnecessarily involved otherwise. When
we describe the chase procedure, we call the variables labeled nulls. In many settings (e.g., in
the data-exchange setting, which we present in the next chapter), this term is more suitable, as
these variables play the role of nulls. That is, we form database instances in which we know that a
tuple t belongs in the instance, but we may not know the exact values in all the ﬁelds (argument
positions) in this tuple. For example, an instance may have a tuple t D .5; x; 7; y/, which means
that there is a tuple whose value in the ﬁrst ﬁeld equals 5, and whose value in the third ﬁeld
equals 7; at the same time, we do not know the exact values in the two other ﬁelds in the tuple t.
To represent such information in database instances, we assume an inﬁnite domain of constants
Const, as well as an inﬁnite set Var of variables, called labeled nulls, such that Const \ Var D ;.
A fact is a relational atom over constants from Const and labeled nulls from Var. We deﬁne an
instance to be a set of facts. For an instance K, we use Const(K) and Var(K) to denote the set
of constants and the set of labeled nulls in K, respectively. A ground instance is an instance K
with Var(K) D ;.
The chase procedure is used extensively for dealing with problems related to satisfaction
of tgds and egds. The deﬁnition is as follows.
Deﬁnition 5.3
(Chase step)
Let K be a database instance and † a set of tgds and egds. We distinguish between tgds and
egds.

5.1. PRELIMINARIES
127
(tgd) Let d be a tgd in † of the form .x/ !  .x; y/. Let h be a homomorphism from .x/
to K such that there is no extension h0 of h that maps .x/ ^  .x; y/ to K. We say that
d can be applied to K with homomorphism h. Let K0 be the union of K with the set of
facts obtained by:
(i) extending h to h0 such that each variable in y is assigned a fresh labeled null, followed
by
(ii) taking the image of the atoms of  under h0.
We say that the result of applying d to K with h is K0, and write K
d;h
 ! K0 to denote the
chase step on K with the tgd d.
(egd) Let d be an egd in † of the form .x/ ! .x1 D x2/. Let h be a homomorphism from .x/
to K such that h.x1/ ¤ h.x2/. We say that d can be applied to K with homomorphism h.
We distinguish between two cases.
(a) If h.x1/ and h.x2/ are distinct constants, we say that the result of applying d to K with
h is failure, and write K
d;h
 ! ? to denote the chase step on K with the egd d.
(b) Otherwise, let K0 be K in which we identify h.x1/ and h.x2/ as follows. If one is a
constant and the other is a labeled null, then the labeled null is globally replaced by the
constant; if both are labeled nulls, then one is replaced globally by the other. We say that
the result of applying d to K with h is K0, and write K
d;h
 ! K0 to denote the chase step on
K with the egd d.
We continue with the deﬁnition of the chase.
Deﬁnition 5.4
(Chase)
Let † be a set of tgds and egds, and K be a database instance.
 A chase sequence of K with † is a sequence (ﬁnite or inﬁnite) of chase steps Ki
d;h
 ! K0
iC1, with
i D 0; 1; : : : ; K D K0, and d a dependency in †.
 A ﬁnite chase of K with † is a ﬁnite chase sequence Ki
d;h
 ! K0
iC1, 0  i < m with K D K0,
where either (a) Km D?, or (b) there is no dependency d of † and there is no homomorphism
h such that d can be applied to Km with h. We say that Km is the result of the ﬁnite chase. We
refer to case (a) as a failing ﬁnite chase, and to case (b) as a successful ﬁnite chase.

128
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
5.1.2
WEAKLY ACYCLIC SETS OF TGDS
On some database instances, chase may never terminate; thus, it is of interest to identify condi-
tions under which there is a ﬁnite chase on all database instances. The notion of weak acyclicity
guarantees the termination of chase. A characteristic example of weakly acyclic tgds is the class of
full tgds, i.e., tgds with no existentially quantiﬁed variables. The following deﬁnition formalizes
the concept of weak acyclicity for a set of tgds.
Deﬁnition 5.5
(Weakly acyclic set of tgds)
Let † be a set of tgds and egds over a database schema. We construct a directed graph .called
the dependency graph/; as follows. (1) There is a node for every pair .R; A/ with a relation symbol
R of the schema and an attribute A of R. We call such a pair .R; A/ a position. (2) Add edges as
follows: for each tgd .x/ !  .x; y/ in † and for each x in x that occurs in  .x; y/, we call x
a propagated variable. For a propagated variable x, for each occurrence of x in .x/ in position
.R; Ai/, do the following:
(i) for each occurrence of x in  .x; y/ in position .S; Bj /, add an edge .R; Ai/ ! .S; Bj /
.if it does not already exist/; and
(ii) for each existentially quantiﬁed variable y in y and for each occurrence of y in  .x; y/
in position .T; Ck/, add a special edge .R; Ai/ ! .T; Ck/ .if it does not already exist/.
We say that the set † is weakly acyclic if the dependency graph has no cycle going through
a special edge.
Theorem 5.6
If a set † of tgds and egds is weakly acyclic, then chase with † terminates on every
instance.
Proof. The proof is by induction on the maximum number of special edges along any path in the
dependency graph. If there are no special edges, then no new variables are introduced during any
chase sequence. Thus, there is a ﬁnite number of facts of each relevant arity that can be added
by the chase steps. As a result, the chase will terminate.
Before we continue with the proof, let us make a general observation about the structure
of the dependency graph. If an atom U.x1; : : : ; / appears on the left-hand side of a tgd that has
an existentially quantiﬁed variable at position .T; B/ in its right-hand side, then the following is
true: For every position .U; Xi/, where Xi is an attribute in U , there is a special edge to .T; B/ in
the dependency graph. In other words, for a speciﬁc U , either there are special edges from every
position .U; Xi/ to a certain other position, or there are no special edges at all from any position
.U; Xi/; i D 1; : : :. Thus, the dependency graph, as deﬁned, can be used to state the following:
If the dependency graph has no paths with special edges from a certain position .U; Xi/, then
U participates on the left-hand side of only those tgds that have no existentially quantiﬁed
variables, or does not participate on the left-hand side of tgds at all.

5.1. PRELIMINARIES
129
Suppose that there is only one special edge along any path in the dependency graph. The
following observation is useful in supporting our argument that the number of the fresh variables
introduced by the special edge will be limited. Consider an atom U.x1; : : : ; / in the database Ki
created at some step i of chase, such that a fresh variable is introduced in U.x1; : : : ; /. This means
that there is some special edge in the dependency graph to some position .U; Xj /. According
to the general observation above about the dependency graph, an atom with relational symbol
U either appears on the left-hand side of only those tgds that have no existentially quantiﬁed
variables, or it does not appear in any tgds. Thus, the number of the new variables that will be
introduced equals the number of homomorphisms that exist from the left-hand side of a tgd
to the input database instance, times the maximum number of existentially quantiﬁed variables
in each tgd. Moreover, no other variables will be introduced, because the atoms in the instance
Ki that contain newly introduced variables will not participate in the next chase step that could
introduce new variables. We conclude that the chase will terminate after a ﬁnite number of steps.
The argument for the general case is the same as above. The inductive hypothesis is that
the chase will terminate after a ﬁnite number of steps in those cases where there are at most
i   1 special edges along any path in the dependency graph. If there are at most i special edges,
then we repeat the above argument for the ith special edge along the paths.

5.1.3
PROPERTY OF THE CHASE
We now present the main result that makes the chase algorithm useful in many situations. (Some
of the scenarios will be presented in this and the next chapters.)
Theorem5.7
Let † be a set of tgds and egds, and D a database instance that satisﬁes the dependencies
in †. Suppose K is a database instance, such that there exists a homomorphism h from K to D. Let K†
be the result of a successful ﬁnite chase on K with the set of dependencies †. Then the homomorphism h
can be extended to a homomoprhism h0 from K† to D.
Proof. The proof is by induction on the number of chase steps. Suppose that the chase of
K with † terminates after n steps, with chase sequence K D K1; K2; : : : ; Kn D K†, where
Ki
di;gi
 ! KiC1 for di 2 †. We show for each i D 1; 2; : : : ; n   1 that, whenever there exists
a homomorphism hi W Ki ! D, then there exists an extension of hi to a homomorphism
hiC1 W KiC1 ! D.
Suppose that Ki
d;gi
 ! KiC1 with d 2 †. Consider the following two cases.
1. d is a tgd .x/ !  .x; y/. By Deﬁnition 5.3 of the chase step, there is a homomorphism
gi W .x/ ! Ki. Thus, hi ı gi W .x/ ! D is also a homomorphism and, due to D satis-
fying d, hi ı gi can be extended to a homomorphism h0 W .x/ ^  .x; y/ ! D.
We now construct hiC1. For each variable y in y, denote by zy the fresh variable that
replaces y in the chase step Ki
d;gi
 ! KiC1. Let x be a variable of KiC1. If x is among

130
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
the variables of Ki, then hiC1.x/ D hi.x/. If, however, x does not appear in Ki, then x
is a fresh variable (that is used to extend the homomorphism hi to h0 during the chase
step), and we have that hiC1.x/ D h0.x0/ for an appropriate x0. (Such an x0exists, since the
dependencies are satisﬁed in D.) Thus, hiC1 maps all the variables of KiC1 to constants in
D.
Now hiC1 is a homomorphism for the following reasons.
(a) For each fact f in KiC1 such that all the variables of f are involved in the homo-
morphism hi, by the inductive step we have that hiC1 maps f appropriately to a fact
of D; and
(b) The rest of the facts originated in KiC1 from an application of this chase step; hence
these facts are images of the atoms in the conjunction  of some tgd in †; this means
that the homomorphism h0 used to deﬁne hiC1, when viewed as a mapping from
KiC1 to D, maps each new atom in KiC1 to an atom in D.
2. d is an egd .x/ ! .x1 D x2/. As in the previous case, by the Deﬁnition 5.3 of the chase
step, there is a homomorphism gi W .x/ ! Ki, and we have that hi ı gi W .x/ ! D is a
homomorphism. Because the instance D satisﬁes the egd d, we have that hi.x1/ D hi.x2/.
We now construct hiC1 W KiC1 ! D, such that hiC1.x/ D hi.x/. After this step, the only
diﬀerence between KiC1 and Ki is in that two variables in Ki are equated. We argue as in
the case of tgd to show these variables are already mapped by hi to the same element in
D, because D satisﬁes the dependencies.

The chase
In this section:
We deﬁned chase applied to a database instance K using a set † of tgds
and egds.
We observed that chase does not always terminate, but does terminate
on all instances for weakly acyclic sets of tgds and egds; and
We stated an important property of the chase.
The following is an interesting observation (that also happens to be easy to prove). Because
of this result we can say that computing the canonical rewriting can be done by chasing the
canonical database of the given query with a set of tgds.
Theorem 5.8
Let † be a set of tgds, such that each tgd in † (i) has no existential variables, and
(ii) has one atom on the right-hand side. Let Q be a set of CQ queries where each query Q in Q is

5.2. QUERY CONTAINMENT UNDER DEPENDENCIES
131
constructed from a tgd in † by the following process: (a) the head of Q is the same as the right-hand
side of the selected tgd, and (b) the body of Q is the same as the left-hand side of the tgd. Then for
any database instance K, the result of applying the chase to K with † produces the answers to the
corresponding CQs in Q, and vice versa.
5.2
QUERY CONTAINMENT UNDER DEPENDENCIES
We now deﬁne query containment under dependencies.
Deﬁnition 5.9
Let † be a set of tdgs and egds, and Q1, Q2 be two conjunctive queries. We
say that Q1 is contained in Q2 under the dependencies †, denoted Q1 v† Q2, if for all databases
D that satisfy † we have that Q1.D/  Q2.D/.
Example 5.10
Suppose the database schema is a single binary relation. Let d be the egd
a.X; Y /; a.X; Z/ ! Y D Z. Consider a CQ Q:
q./ :- a.X; Y /; a.X; Z/; a.Y; Z/:
This query is equivalent to the following query Q0
q0./ :- a.X; Y /; a.Y; Y /
on all the database instances that satisfy the egd d.
Containment test when chase terminates: Consider a set † of tgds and egds such that
chase with † terminates (e.g., † is weakly acyclic). Then a conjunctive query Q2 is contained in
conjunctive query Q1 iﬀthere is a containment mapping from Q1 to the chased body Qchase
1
of Q1. We obtain the chased body of Q1 by regarding the body of Q1 as a relational structure,
and by applying to it the chase steps until termination. The labeled nulls used in the deﬁnition
of chase become fresh variables in the query. The outcome of the chase procedure becomes the
set of subgoals of the resulting query Qchase
1
.
The following result formally states this containment test; the proof is based on Theo-
rem 5.7.
Theorem 5.11
If chase of conjunctive query Q with set of dependencies † terminates with outcome
Q†, then for any conjunctive query Q0, the following is true:
Q v† Q0 iﬀthere is a containment mapping from Q0 to Q†.

132
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
Proof. By Theorem 5.7, for any database D that satisﬁes † we have the following: If a tuple t
is computed by a homomorphism ht from the subgoals of Q to D, then there is a homomo-
morphism h0
t from Q† to D that computes t. Hence, Q† computes all the tuples computed
by Q on D. In addition, Q computes all the tuples computed by Q† on D, because there is a
containment mapping from Q to Q†. Thus, Q and Q† are equivalent on D. We conclude that
whenever there is a containment mapping from Q0 to Q†, this means that Q0 contains Q under
†.
For the other direction, suppose Q0 contains Q under †. Consider the canonical database
I of Q†. Q0 computes on I the head of Q†. Hence, there is a containment mapping from Q0
to Q†.

Example 5.12
Consider the query Q and egd d of Example 5.10, repeated here for conve-
nience: d W a.X; Y /; a.X; Z/ ! Y D Z, and Q is
q./ :- a.X; Y /; a.X; Z/; a.Y; Z/:
In chase of the atoms in the body of Q with egd d, there is only one applicable chase step. The
ﬁrst two subgoals of Q are targets of a homomorphism from the left-hand side of d. Thus, we
enforce on the variables of Q the equality Y D Z. The chase yields a query Q0 that is equivalent
to Q under d:
q0./ :- a.X; Y /; a.X; Y /; a.Y; Y /:
The minimized version of Q0 is
q0./ :- a.X; Y /; a.Y; Y /:
Query-containment test for CQs under dependencies
In this section:
We deﬁned query containment under dependencies on the input database
instance.
We observed that the chase (when it terminates) can be used to decide
CQ query containment.

5.3. EQUIVALENT REWRITINGS
133
5.3
EQUIVALENT REWRITINGS
In the following, we deﬁne rewritings that are equivalent to queries for the case where we are
interested only in those database instances that satisfy a set of dependencies. In this case, an
overall equivalent rewriting is still an equivalent rewriting, but if we are not careful, then we may
miss an equivalent rewriting. This means that a rewriting could be equivalent to the query on all
the database instances satisfying the speciﬁc dependencies, but not necessarily on all database
instances.
Deﬁnition5.13
For a query Q, set V of views, and set † of dependencies, an equivalent rewrit-
ing of Q using V in presence of † is a query R over the schema of the views such that, for all the
databases D that satisfy †, R.V.D// D Q.D/ holds.
Example 5.14
Suppose the database schema is a single binary relation; let edg d be
a.X; Y /; a.X; Z/ ! Y D Z: Consider CQ query Q:
q./ :- a.X; Y /; a.X; Z/; a.Y; Z/
and CQ view V :
v./ :- a.X; Y /; a.Y; Y /:
Then the following rewriting R
R./ :- v./
is equivalent to Q under the egd d. The expansion of the rewriting R is
Rexp./ :- a.X; Y /; a.Y; Y /:
As discussed in Example 5.10, while Rexp is equivalent to Q under d, it is not equivalent to Q
in general (i.e., without any dependencies assumed).
5.3.1
ALGORITHM FOR CQ QUERIES, VIEWS, AND REWRITINGS
In the case of CQ queries and views, in order to prove that a rewriting R is equivalent to the
given query, we can still use the expansion of the rewriting. At the same time, we now need to
prove that the expansion is equivalent to the query under the speciﬁc dependencies. That is, we
need to use the chased bodies of both the query and the expansion in checking for equivalence by
containment mappings. (We have already noted this when discussing query containment under
dependencies.)
Theorem 5.15
Let Q be a CQ query, V a set of CQ views, and † a set of tgds and egds such that the
chase sequence of Q with † terminates. Let Q† be the result of chasing Q with † (i.e., Q
†
! Q†.)
Let R†
can be the canonical rewriting of Q† using V.

134
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
Then there is an equivalent CQ rewriting of Q using V in presence of † iﬀR†
can is an equivalent
rewriting of Q in presence of †.
The proof of this result is based on Theorem 5.7. Theorem 5.15 gives rise to an algorithm
that is similar to the algorithm based on canonical rewritings, which we introduced in Chap-
ter 3. The diﬀerence is that now we need to chase the query before constructing the canonical
rewriting.
Example5.16
Consider the setting of Example 5.14. In order to apply Theorem 5.15, we chase
the query with d, to obtain Q†:
q†./ :- a.X; Y /; a.Y; Y /:
Computing the view V on the canonical database of Q† results in a single tuple v./. Thus, the
canonical rewriting is
R./ :- v./:
We argued in Example 5.14 that this is an equivalent rewriting of the query Q under the de-
pendency d.
Equivalent CQ rewritings under dependencies for CQ queries and
views
We deﬁned equivalent rewritings of queries under dependencies.
We observed that the chase (when it terminates) can be used to ﬁnd an
equivalent CQ rewriting, in case there is one.
5.3.2
FINDING EQUIVALENT REWRITINGS FOR WEAKLY ACYCLIC
LAV DEPENDENCIES
In Chapter 3 we discussed an eﬃcient algorithm, CoreCover, for ﬁnding equivalent CQ rewrit-
ings for CQ queries and views. Unfortunately, this algorithm does not carry over to the case in
which we would like to ﬁnd equivalent rewritings in presence of dependencies. The reason is
that this algorithm treats separately the contribution of each view subgoal to the rewriting, with
respect to the containment mapping from the query to the expansion. However, in presence
of dependencies we need to chase the expansion ﬁrst and to then look for the existence of a
containment mapping from the query to the expansion. A chase step, however, may consider
more that one view subgoal (in their expanded form), because the left-hand side of a tgd or
egd may have more than one atom. We can still extend the algorithm CoreCover to the case of

5.3. EQUIVALENT REWRITINGS
135
dependencies, provided that all the given tgds and egds each have one atom on the left-hand
side. We call such dependencies Local As Views (LAV).
In this section we present an algorithm that ﬁnds equivalent rewritings in presence of
weakly-acyclic LAV dependencies, such that each rewriting has the minimum number of sub-
goals. The algorithm, CoreCover†, is an extension of CoreCover. We now present CoreCover†:
1. The input is a CQ query Q, set V of CQ views, and a set of weakly acyclic LAV depen-
dencies †.
2. Chase query Q with † to obtain Q†.
3. Minimize Q† to obtain Qm, the minimal equivalent of Q†.
4. Construct the canonical database D0
Q of Qm; use D0
Q to compute the canonical rewriting
by applying the view deﬁnitions on D0
Q.
5. For each subgoal in the canonical rewriting, take its expansion according to the view def-
inition, and compute the chased expansion. Compute the tuple core of this view subgoal
with respect to its chased expansion and Qm.
6. Use the nonempty tuple cores to cover all the query subgoals in Qm with the minimum
number of tuple cores. For each cover, construct a candidate rewriting by combining the
corresponding view tuples, then check for equivalence with Qm.
The relationship between CoreCover† and the algorithm CoreCover of Chapter 3 is the
following: CoreCover† is a slight modiﬁcation of CoreCover in that CoreCover† uses the minimal
chased query and the chased view tuples; thus, “chased” tuple cores are constructed to contribute
to equivalent rewritings. The proof techniques for the correctness of CoreCover† are largely along
the lines of the proof of correctness of CoreCover.
We now give an example to demonstrate how CoreCover† works.
Example 5.17
Consider a view set V that contains the following four views:
V1.X1; X2/ :- a.X1; Z4/; b.Z4; X2/:
V2.X1; X2/ :- b.X1; Z5/; c.Z5; X2/:
V3.X1; X2; X3/ :- b.X1; X2/; c.X2; X3/:
V4.X1/ :- a.X1; X1/; d.X1; X1/:
Consider a query
Q.X; Y / :- a.X; Z2/; b.Z2; Z3/; c.Z3; Y /; a.Y; Z1/; a.Z1; Y /; d.Y; Y /;
and tgd t W d.X; Y / ! a.X; Y /.

136
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
The result of chasing Q with t is
Q†.X; Y / :- a.X; Z2/; b.Z2; Z3/; c.Z3; Y /;
a.Y; Z1/; a.Z1; Y /; a.Y; Y /;
d.Y; Y /:
Minimizing Q† yields the following query Qm:
Qm.X; Y / :- a.X; Z2/; b.Z2; Z3/; c.Z3; Y /;
a.Y; Y /; d.Y; Y /:
The canonical database is D0
Q D fa.x; z2/; b.z2; z3/; c.z3; y/; a.y; y/; d.y; y/g, and computing
the canonical rewriting on D0
Q yields the following view sugoals in this rewriting: T .Q; V; †/ D
fV1.X1; Z3/; V2.Z2; Y /; V3.Z2; Z3; Y /; V4.Y /g. We next compute the “chased” tuple cores for
each view subgoal in the canonical rewriting.
• V1.X1; Z3/: We have that .V exp
1
/0.X1; Z3/ :- a.X1; Z0
4/; b.Z0
4; Z3/; thus, the chased tuple
core is the set fa.X; Z2/; b.Z2; Z3/g.
• V2.Z2; Y /: We have that .V exp
2
/0.Z2; Y / :- b.Z2; Z0
5/; c.Z0
5; Y /; thus, the chased tuple
core is the set fb.Z2; Z3/; c.Z3; Y /g.
• V3.Z2; Z3; Y /: We have that .V exp
3
/0.Z2; Z3; Y / :- b.Z2; Z3/; c.Z3; Y /; thus, the chased
tuple core is the set fb.Z2; Z3/; c.Z3; Y /g.
• V4.Y /: We have that .V exp
4
/0.Y / :- a.Y; Y /; d.Y; Y /; thus, the chased tuple core is the set
fa.Y; Y /; d.Y; Y /g.
In the last step, CoreCover† ﬁnds a minimum number of view subgoals to cover the
Qm’s subgoals, and constructs a rewriting by combining the corresponding view tuples.
In our example, CoreCover† will ﬁnd only one equivalent rewriting, which is R.X; Y / :-
V1.X1; Z3/; V3.Z2; Z3; Y /; V4.Y /. We can verify that R is an equivalent rewriting of Q using
containment mappings between Qm and Rexp
† :
Qm.X; Y / :- a.X; Z2/; b.Z2; Z3/; c.Z3; Y /;
a.Y; Y /; d.Y; Y /:
Rexp
† .X; Y / :- a.X1; Z0
4/; b.Z0
4; Z3/;
b.Z2; Z3/; c.Z3; Y /; a.Y; Y /;
d.Y; Y /:
For example, if h.X/ D X, h.Z2/ D Z0
4, h.Z3/ D Z3, and h.Y / D Y , then h is a containment
mapping h W Qm ! Rexp
† , which means that Qm v Rexp
† . The other direction is similar.
Notice that if we had not performed the minimization step in Q†, i.e., if we had con-
sidered Q† instead of Qm, then the canonical database D0
Q, the set of chased view subgoals,

5.4. MCRS
137
and the chased tuple cores would be the same, since the two subgoals a.Y; Z1/; a.Z1; Y / could
not be part of any chased tuple core. Indeed, the only view subgoal for which this could
happen is V4.Y /; if we include them in V4.X1/†, it is not hard to see that the mapping
 W fa.Y; Z1/; a.Z1; Y /; a.Y; Y /; d.Y; Y /g ! fa.Y; Y /; d.Y; Y /g is not one to one, as is required
by the deﬁnition of the tuple core. This means that a.Y; Z1/; a.Z1; Y / would not be covered by
the tuple core of any view, and thus CoreCover† would not ﬁnd any equivalent rewriting.
Equivalent CQ rewritings under dependencies for CQ queries and
views.
For LAV dependencies, there is an eﬃcient algorithm to ﬁnd equivalent
rewritings under dependencies.
5.4
MCRS
In this section we ﬁrst show that for CQ queries and views and for a set of egds, we may need
recursion to ﬁnd an MCR in the language of unions of CQs. Speciﬁcally, we show an example
in which there is no MCR that is a ﬁnite union of CQs. We then present a variant of the
inverse-rule algorithm that ﬁnds a Datalog MCR for CQ queries and views in the presence of
egds.
5.4.1
FUNCTIONAL DEPENDENCIES NEED RECURSION
In presence of dependencies, maximally contained rewritings of a query could exist in Datalog
only, as shown in the following example.
Example 5.18
Suppose
that
we
have
a
database
schema
that
contains
relation
schedule (Airline, Flight_no, Date, Pilot, Aircraft). The set of views V contains one view
V.D; P; C/ :- schedule.A; N; D; P; C/;
and we have a set † D fd1; d2g of two egds:
d1 W schedule.A; N; D; P; C/ ^ schedule.A0; N 0; D0; P; C 0/ ! A D A0:
d2 W schedule.A; N; D; P; C/ ^ schedule.A0; N 0; D0; P 0; C/ ! A D A0:
These dependencies say that each pilot works for only one airline, and each aircraft is owned by
only one airline. Consider the query
Q.P / :- schedule.A; N; D; mike; C/; schedule.A; N 0; D0; P; C 0/;

138
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
which asks for pilots working for the same airline as Mike. Because of the dependencies, these
pilots ﬂy aircraft of the same airline.
For each n, the following query Qn is a CQ rewriting contained in Q, assuming the
dependencies in † hold:
Qn.P / :- V.D1; mike; C1/; V.D2; P2; C1/; V.D3; P2; C2/;
V.D4; P3; C2/; V.D5; P3; C3/; V.D6; P4; C3/; : : : ;
V.D2n 2; Pn; Cn 1/; V.D2n 1; Pn; Cn/; V.D2n; P; Cn/:
The intuition behind this contained rewriting is as follows. Each use of a view subgoal introduces
either a pilot that works for the same airline as Mike, or an aircraft owned by Mike’s airline.
Thus, in particular, the ﬁrst two view subgoals above introduce pilot P2 who works for aircraft
C1, which is owned by Mike’s airline. The second and third subgoals give C2, which is an aircraft
for which P2 works, and hence (because of the dependency) owned by Mike’s airline.
In the real world, conditions could hold that would prevent us from getting all the answers
to the query Q. Suppose Mike’s airline has both Boeing and Airbus planes, but Mike only knows
how to ﬂy Boeing, and there are other pilots who only know how to ﬂy Airbus. Then if we start
from Mike, we will never reach an Airbus pilot for the same airline, no matter how large n is in
Qn. Moreover, Qn needs to be arbitrarily long to capture all the answers that can be derived by
a contained CQ rewriting, because we may have an arbitrarily long chain of pilots and aircraft
that respectively work for and are owned by Mike’s airline. Such answers could only be reached
by the number of subgoals in Qn that is equal to the length of this chain.
Consider a contained rewriting, P, of the query Q using views V in Example 5.18, such
that P is a ﬁnite union of CQs. We now show formally that for any such rewriting P, there is
a CQ contained rewriting of Q using V that is not contained in P.
Suppose each CQ in P has at most s subgoals. Suppose s  m. Consider the contained
rewriting QmC1:
QmC1.PmC2/ :- V.D1; mike; C1/; V.D2; P2; C1/; V.D3; P2; C2/;
V.D4; P3; C2/; V.D5; P3; C3/; V.D6; P4; C3/; : : : ;
V.D2m; PmC1; Cm/; V.D2mC1; PmC1; CmC1/; V.D2mC2; PmC2; CmC1/:
We now construct a view instance VmC1 by replacing the variables in the subgoals in the body
of QmC1 with distinct constants, as shown below:
VmC1 D fV.d1; mike; c1/; V.d2; p2; c1/; V.d3; p2; c2/;
V.d4; p3; c2/; V.d5; p3; c3/; V.d6; p4; c3/; : : : ;
V.d2m; pmC1; cm/; V.d2mC1; pmC1; cmC1/; V.d2mC2; pmC2; cmC1/g:
It is easy to see that QmC1.VmC1/ D fmike; p2; : : : ; pmC2g. Since QmC1 is contained in P by
our assumption, there exists a CQ rewriting R 2 P, such that QmC1 v R. We will prove that

5.4. MCRS
139
pmC2 2 R.VmC1/ does not hold, thus proving that QmC1 is not contained in P. (Our argument
will be based on the fact that R has s  m subgoals.)
Assume that pmC2 2 R.VmC1/. By deﬁnition, if P is the (only) variable in the head of
R, there is a homomorphism h W Var.R/ ! Const.VmC1/ such that h.P / D pmC2. If Ri.y/ is
a subgoal in the body of R, then Ri
 h.y/

2 VmC1. We now consider the view instance Vs D
fRi
 h.y/

W Ri.y/ 2 Body.R/g, where we denote by Body.R/ the subgoals in the deﬁnition
of R. That is, Vs contains only the s tuples from VmC1 that were used to produce the answer
fpmC2g, i.e., R.Vs/ D fpmC2g. Since VmC1 contains 2m C 2 > m  s subgoals, at least one of
the tuples in VmC1 is not present in Vs. Let V.d 0; pi; c0/, 2  i  m C 2, be one such tuple. We
now construct a database D0 from Vs by replacing the tuples in Vs with their expansions, as
shown below:
D0 D fschedule.a1; n1; d1; mike; c1/; schedule.a2; n2; d2; p2; c1/;
schedule.a3; n3; d3; p2; c2/; : : : ; schedule.a2i 2; n2i 2; d2i 2; pi 1; ci 1/;
schedule.a2iC2; n2iC2; d2iC2; piC1; ciC1/; : : : ;
schedule.a2m; n2m; d2m; pmC1; cm/; schedule.a2mC1; n2mC1; d2mC1; pmC1; cmC1/
schedule.a2mC2; n2mC2; d2mC2; pmC2; cmC1/g:
Since D0 must satisfy the two given functional dependencies, we have that a1 D a2 D    D ai 1
and aiC1 D aiC2 D    D amC2 hold, but ai 1 D aiC1 does not necessarily hold. Thus, it is clear
that pmC2 62 Q.D0/, which is a contradiction, because R is a contained rewriting of Q, which
means that R.Vs/ includes the fact pmC2.
5.4.2
INVERSE-RULE ALGORITHM FOR FINDING MCRS IN PRESENCE
OF EGDS
We now show how to use the inverse-rule algorithm to ﬁnd MCRs in the language of Datalog
for CQ queries and views in presence of egd dependencies.
We introduce a binary predicate e, which will stand for equality, i.e., e.X; Y / means X D
Y . We construct inverse rules for the views and also for the egds. That is, for each egd A !
X1 D X2 we introduce a rule whose head is e.X1; X2/ and whose body comprises the normalized
version of the atoms in A. (Recall that Deﬁnition 2.11 introduced normalization for checking
for containment of CQAC queries.) Before writing the inverse rules, we also normalize the view
deﬁnitions. Finally, to enforce transitivity on e, we add the rule e.X; Y / :- e.X; Z/; e.Z; Y /: We
do not need to enforce symmetry of e, because it comes from the symmetry of equality. To
illustrate, we now continue with Example 5.18.
Example 5.19
The normalized query rule is one of the rules of the inverse-rule program:
rule 1: Q.P / :- schedule.A; N; D; M; C/; schedule.A1; N 0; D0; P1; C 0/;
e.P; P1/; e.A; A1/; e.M; Mike/:

140
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
The next rule is the inverse rule for the single view in the view set:
rule 2: schedule.f1.D; P; C/; f2.D; P; C/; D; P; C/ :- V.D; P; C/:
The egd: d1 W schedule.A; N; D; P; C/ ^ schedule.A0; N 0; D0; P; C 0/ ! A D A0 creates
the inverse rule:
rule 3: e.A; A0/ :- schedule.A1; N; D; P; C/; schedule.A0
1; N 0; D0; P1; C 0/;
e.P; P1/; e.A; A1/; e.A0; A0
1/:
For the egd d2 W schedule.A; N; D; P; C/ ^ schedule.A0; N 0; D0; P 0; C/ ! A D A0, we
have the inverse rule:
rule 4: e.A; A0/ :- schedule.A1; N; D; P; C/; schedule.A0
1; N 0; D0; P 0; C1/;
e.C; C1/; e.A; A1/; e.A0; A0
1/:
We add also a rule to enforce transitivity of the equality predicate e:
rule 5: e.X; Y / :- e.X; Z/; e.Z; Y /:
To make sure that the relation e is reﬂexive, when we apply the rules we have that e.X; X/
is true for any value of X.
Let us see how this works on the following database instance:
D0 D fschedule.a1; n1; d1; mike; c1/; schedule.a2; n2; d2; p2; c1/;
schedule.a3; n3; d3; p2; c2/; : : : ;
schedule.a2nC2; n2nC2; d2nC2; pnC2; cnC1/g:
On D0, we have the view instance
V.D0/ D fv.d1; mike; c1/; v.d2; p2; c1/; v.d3; p2; c2/; v.d4; p3; c2/; : : : ;
v.d2nC2; pnC1; cnC1/g.
We
apply
rule
2
to
derive
from
the
v
facts
schedule
facts,
e.g.,
schedule.f1.d1; mike; c1/; f2.d1; mike; c1/; d1; mike; c1/,
schedule.f1.d2; p2; c1/; f2.d2; p2; c1/; d2; p2; c1/, and so on. Then we apply rules 3 and 4 as
appropriate, to obtain the e facts
e

f1.d1; mike; c1/; f1.d2; p2; c1/

;
e

f1.d2; p2; c1/; f1.d3; p2; c2/

;
e

f1.d3; p2; c2/; f1.d4; p3; c2/

:

5.5. EXERCISES
141
Then we use the last (ﬁfth) rule, to perform essentially transitive closure on e, which yields all
facts of the form
e

f1.d3; p2; c2/; f1.dm; pm 1; cm 2/

:
Finally, we use these facts and rule 1 to compute the answer
fP.p1/; P.p2/; P.p3/; : : : g:
MCRs for CQ queries and views under dependencies.
There is no MCR in the language of unions of CQs.
A variant of the inverse-rule algorithm ﬁnds an MCR in the language of
Datalog in the presence of egds dependencies.
5.5
EXERCISES
5.1.
Prove Theorem 5.11.
5.2.
Prove Theorem 5.15.
5.3.
Consider Example 5.19. Prove that the following program is a Datalog MCR of Q:
relevantP ilot.mike/:
relevantAirCraf t.C/ :- V.D; mike; C/:
relevantAirCraf t.C/ :- V.D; P; C/; relevantP ilot.P /:
relevantP ilot.P / :- relevantP ilot.P1/; relevantAirCraf t.C/;
v.D1; P1; C/; v.D2; P; C/:
This program results from the procedure described in Example 5.19 after function-
symbol elimination and renaming of IDB predicates.
5.4.
Prove or disprove that for the following two CQs it is true that Q2 is contained in
Q1 under set semantics, in presence of dependencies p.A; B; C/ ! r.B; C; A/ and
r.B; C; A/; r.B; C; D/ ! A D D.
(1) Q1./ :- p.A; B; C/; r.B; C; A/; r.B; C; D/:
Q2./ :- p.X; Y; Z/; r.Z; Y; W /; s.W; Y /:
(2) Q1./ :- p.A; B; C/; r.B; C; D/:
Q2./ :- p.X; Y; Z/:
(3) Q1./ :- p.X; Y; Z/; r.Y; Z; Y /:

142
5. ANSWERING QUERIES IN PRESENCE OF DEPENDENCIES
Q2./ :- p.Y; Y; Z/; r.Y; Z; Y /; s.Y; Y /:
(4) Q1./ :- p.X; Y; Z/; r.Z; Z; Y /:
Q2./ :- p.A; A; C/; r.A; C; A/; r.A; C; C/:
5.5.
Find all possible equivalent rewritings of the given query Q using the given set of views
V D f U , V , W , M g in presence of dependencies p.X; Y /; p.X; Z/ ! Y D Z and
p.X; Y / ! s.Y; Y /.
(1) Q.X; Y / :- p.X; N/; p.X; R/; t.N; Y /:
U.A; B/ :- p.A; B/:
V.A; B; C/ :- p.A; C/; s.C; B/:
W.A; B; C; D/ :- p.A; C/; t.D; B/:
M.A; B; C/ :- s.A; B/; t.A; C/:
5.6.
Use algorithm CoreCover† to ﬁnd all possible equivalent rewritings of the given query
Q using the given set of views V D f U , V , W , M g in presence of weakly acyclic LAV
dependencies p.X; Y / ! X D Y and p.X; Y / ! t.Y; Y /.
(1) Q.A/ :- p.A; B/; s.B; C/; t.C; B/:
U.X; Y / :- p.X; Z/; s.Z; Y /:
V.X; Y / :- s.X; Z/; t.Z; Y /:
W.X; Y / :- t.X; Y /; s.U; X/:
M.X; Y; Z/ :- s.X; Z/; t.Z; Y /:

143
C H A P T E R
6
Answering Queries in Data
Exchange
So far, we have worked with the setting in which we would like to compute answers to query
Q on database D, without having direct access to D. That is, for a set of views V deﬁned on
the schema of D, we are given an instance I, which is either the set of all tuples in V.D/ or its
subset. So, being unable to compute Q directly on D, we have to ﬁnd techniques for answering
Q on the instance I whose schema is that of the view relations. The approach we adopted in
Chapters 3 and 4 was to ﬁnd equivalent or maximally contained rewritings of Q using the views
in V, and to then answer Q by computing the rewritings on I. An alternative approach would
be to use the view deﬁnitions to transform I into an instance D0 on the schema of the query,
and to then compute Q on D0. However, such a transformation is not at all straightforward. We
will begin formalizing an approach to doing this after studying an introductory example.
Example 6.1
Let query Q be the path query P4. (Recall that a path query Pn computes on a
graph pairs of nodes that are separated by a connected path of length n, see Deﬁnition 2.44.)
Let the single available view V be path query P2. That is, the schema of the database has a
binary relation r, hence we can view each instance as a graph on which the query deﬁnes paths
of length four, and the view deﬁnes paths of length two. Clearly, R.X; Y / :- V.X; Z/; V.Z; Y /
is an equivalent rewriting of Q in terms of V . Thus, on an instance I D f.1; 2/; .2; 3/g we would
compute the set R.I/ D f.1; 3/g, which would be returned correctly as Q.D/.
We can also take a diﬀerent approach, to be considered in this chapter. Informally, we can
guess that I comes from a database D D f.1; a/; .a; 2/; .2; b/; .b; 3/g, where a and b are used as
nulls, i.e., we know that these values exist, but do not have access to them.
This instance D yields Q.D/ D f.1; 3/g. To provide some details, we turn the view deﬁ-
nition into a tgd d:
v.X; Y / ! r.X; Z/; r.Z; Y /;
and then apply on I the chase with the set of dependencies † D fdg. It is not hard to check that
the result is the above guessed database J D D† D f.1; a/; .a; 2/; .2; b/; .b; 3/g. In the formal
description of this approach in this chapter, we will refer to a and b as labeled nulls.
We have started out by considering the speciﬁc problem of answering queries using views
from a diﬀerent angle. It turns out that the above approach of using tgds enables us to consider

144
6. ANSWERING QUERIES IN DATA EXCHANGE
a more general setting, as long as we use tgds whose right-hand side may have more than one
atom. We can also introduce additional requirements on the setting, such as dependencies on
the database that we called D, whose schema “ﬁts” the given query. Let us revisit Example 6.1
to illustrate.
Example 6.2
Let us add to the setting of Example 6.1 another tgd, d 0:
r.X; Z/; r.Z; Y / ! r.Z; Z/:
Unlike the tgd d of Example 6.1 whose left-hand side was deﬁned using the schema of the
instance I, d 0 uses the schema of D on both sides.
Applying on I the chase using both tgds, that is, the set † D fd; d 0g, yields the in-
stance J D D† D f.1; a/; .a; 2/; .2; b/; .b; 3/; .a; a/; .2; 2/; .b; b/g. In J, a and b are labeled
nulls. When computing the answers to the query Q by applying it on J, we restrict ourselves to
tuples that do not contain nulls. Under this condition, compared to the setting of Example 6.1
we can ﬁnd additional answers, .2; 2/; .1; 2/; and .2; 3/.
In this chapter we deﬁne a new problem, the data-exchange problem, as follows. Suppose
we are given a source instance I and a set of dependencies, which are of two kinds: source-to-
target dependencies and target dependencies; the former are tgds from the schema of the source
I to the schema of the target instance, which is the same as the schema of the query Q that we
would like to evaluate. For this setting, in Section 6.1 we will deﬁne formally certain answers to
Q, and will show how to ﬁnd certain answers using the chase.
In Example 6.1 we turned a view deﬁnition into a tgd, to illustrate how conjunctive queries
can be translated into tgds. The next step that we take is to introduce into tgds arithmetic com-
parisons, to yield tgd-ACs, similarly to our deﬁning earlier CQACs by introducing arithmetic
comparisons into CQs. In Section 6.2 we consider the problem of data exchange in presence of
arithmetic comparisons. Then we consider in Section 6.3 the data-exchange setting for the cases
in which the given source instance is incomplete. For the problems considered in Sections 6.1
and 6.3 we use the chase deﬁned in Chapter 5, and for the data-exchange setting with arithmetic
comparisons we introduce a chase procedure that can handles arithmetic comparisons.
6.1
COMPLETE DATA EXCHANGE
Let S =fS1; : : : ; Sng and T = fT1; : : : ; Tmg be two disjoint schemas, with each element of S
[ T being a relation schema. We refer to S as the source schema and to T as the target schema.
Instances over S are called source instances, whereas instances over T are called target instances.
Target instances may contain values, called labeled nulls, that appear in the target instance but
not in the source instance (“fresh” values). These unknown values are represented by variables.
A source-to-target dependency is a tgd of the form 8x
 S.x/ ! 9y  T.x; y/
. A tar-
get dependency is either a tgd of the form 8x
 T.x/ ! 9y  T.x; y/

; or an egd of the form

6.1. COMPLETE DATA EXCHANGE
145
8x
 T.x/ ! .xi D xj //. In all dependencies, S.x/,  T.x; y/, and T.x/ are each a conjunc-
tion of relational atoms over S or T, respectively, and xi; xj are among variables in x. Formally,
we assume an inﬁnite domain of constants Const and an inﬁnite set Var of variables, called
labeled nulls, such that Const and Var are disjoint. A source instance is a set of facts over Const,
and a target instance is a set of facts over Const and Var.
We will refer to this setting as the complete1 (CDE) data-exchange setting. The following
deﬁnition summarizes a complete data-exchange setting.
Deﬁnition 6.3
(Complete data-exchange setting)
A complete data-exchange setting .CDE/ is a quadruple M D .S; T; †st; †t/, such that:
 S is the source schema and T is the target schema;
 †st is a ﬁnite set of source-to-target tgds; and
 †t is a ﬁnite set of target tgds and target egds.
We denote by † the union of †st and †t. In CDE settings, we do not aconsider source-
to-target egds, because they are in essence source egds.
We consider query answering for conjunctive queries posed over the target schema. The
semantics adopted for query answering is that of certain answers. Deﬁnition 6.4 deﬁnes certain
answers in CDE settings. Given a CDE setting M and a source instance I, a target instance
J is called a solution for I under M if I [ J satisﬁes †st and J satisﬁes †t. A universal solution
is a solution such that for each solution K, there is a homomorphism that maps the universal
solution into K.
Deﬁnition 6.4
.Certain answers in CDE settings/
Let M D .S; T; †st; †t/ be a CDE setting, q be a union of conjunctive queries posed over the
target schema T, and I be a source instance. The set of certain answers of q with respect to I and
M, denoted by certainM.q; I/, is deﬁned as
certainM.q; I/ D \fq.K/ j K 2 SOL.M; I/g;
where SOL.M; I/ is the set of solutions for I, and q.K/ denotes the result of applying q to
instance K.
An inﬁnite set of solutions may exist in a CDE setting. It then follows from Deﬁnition 6.4
that computing the set of certain answers may involve checking an inﬁnite space of solutions.
We will show that for a CDE setting M and source instance I, we can use the chase to produce
a universal solution J for I under M. A universal solution is used to compute the set of certain
answers to queries in the language of unions of conjunctive queries.
Theorem 6.5
Given a CDE setting M D .S; T; †st; †t/ with source instance I, the chase on I
with dependencies †st [ †t yields a universal solution for I under M.
1The intent of the word “complete” in this context will be apparent in Section 6.3.

146
6. ANSWERING QUERIES IN DATA EXCHANGE
The proof of Theorem 6.5 is a straightforward consequence of the property of the chase
stated in Theorem 5.7.
Theorem 6.6
For the CDE setting M D .S; T; †st; †t/, suppose J is a universal solution for source
instance I. Then we can use J to compute certain answers to queries in the language of unions of con-
junctive queries:
certainM.q; I/ D q.J /#;
where q.J /# is the set of all the “null-free” tuples in q.J /, i.e., the st of all the tuples t in q.J / such
that each value in t is a constant.
In Examples 6.1 and 6.2 we computed the certain answers of the given queries. Notice
that the results presented in this section work only for unions of CQs, that is, for queries without
arithmetic comparisons or negation. We will need the results of the next section to ﬁnd certain
answers to CQAC queries in presence of dependencies that are tgds and egds. These upcoming
results are also more general, in that they consider a (more general) class of dependencies with
arithmetic comparisons permitted in the deﬁnitions.
CDE setting: M D .S; T; †st; †t/
†st: set of tgds
†t : set of tgds and egds.
Universal solution is computed by applying the chase on the input I,
which is an instance of the source schema S.
Let q be a query in the language of unions of conjunctive queries
posed over the target schema T, and let I be a source instance. The
certain answers of q for the input
I and setting M, denoted by
certainM.q; I/, are computed by evaluating q on any single universal
solution.
6.2
DATA EXCHANGE WITH ARITHMETIC
COMPARISONS
In this section we deﬁne the setting of data exchange with arithmetic comparisons (DEAC),
and show how to deﬁne and compute certain answers using a variant of the chase called the
AC-chase. The DEAC setting extends the CDE setting by using arithmetic comparisons.2 We
begin by deﬁning a new class of dependencies.
2CDEAC would be a more consistent name for DEAC; at the same time, the already-reserved word “complete” in CDE is
used for the sake of ease of presentation in Section 6.3.

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
147
6.2.1
DEPENDENCIES WITH ARITHMETIC COMPARISONS
We deﬁne two new classes of dependencies, the class of tuple-generating dependencies with
arithmetic comparisons, which extends the class of tuple-generating dependencies, and the
class of arithmetic-comparison-generating dependencies, which extends the class of equality-
generating dependencies.
Recall that an arithmetic comparison is of the form “AB,” where A is a variable, B is
a variable or a constant, and  is in f; ; <; >; ¤; Dg. The arithmetic comparisons that we
consider are interpreted over densely totally ordered domains.
An instance with arithmetic comparisons (to which we will refer as “instance” whenever clear
from context) is denoted in this chapter by F.x/ D F0.x/ C ˇF.x/, where F0.x/ is a set of relational
atoms and ˇF.x/ is a conjunction of arithmetic comparisons. (We could also use the symbol K
instead of F , to write K.x/ D K0.x/ C ˇK.x/.) An instance with arithmetic comparisons is in
compact form if its conjunction of arithmetic comparisons ˇF does not imply nontrivial equalities.
For each instance with arithmetic comparisons, there is always an instance in compact form that
represents the same ground instances, in the sense that we would obtain the same set of ground
instances by replacing variables with constants so that the ACs are satisﬁed.
Example 6.7
Let F D fH.2; z1/; H.4; z2/; .z1 D z2/ ^ .z2 < 2/g be an instance with arithmetic
comparisons. Clearly, F is not compact because of the equality z1 D z2. A compact instance
obtained from F is F0 D fH.2; z1/; H.4; z1/; z1 < 2g.
We now introduce the class of tuple-generating dependencies with arithmetic comparisons
(tgd-ACs), which extends the class of tuple-generating dependencies (tgds), and also the class of
arithmetic-comparison-generating dependencies (in short acgds), which extends the class of equality-
generating dependencies (egds).
Deﬁnition 6.8
.tgd-AC and acgd/
Let R be a database schema.
– A tuple-generating dependency with arithmetic comparisons .tgd-AC/ is a ﬁrst-order formula of
the form
8x
 .x/ ^ ˇ.x/ ! 9y  .x; y/ ^ ˇ .x; y/

:
– An arithmetic comparison generating dependency .acgd/ is a ﬁrst-order formula of the form
8x
 .x/ ^ ˇ.x/ ! .x1  x2//:
In the above formulas, .x/ is a conjunction of atoms over R with variables in x, with each
variable in x occurring in at least one atom in .x/. In addition,  .x; y/ is a conjunction of
relational atoms with variables in x and y, such that each variable in y occurs in at least one atom
in  .x; y/. Furthermore, x1 is a variable from x and x2 is either a variable from x or a constant;

148
6. ANSWERING QUERIES IN DATA EXCHANGE
ˇ.x/ and ˇ .x; y/ are each a conjunction of arithmetic comparisons with variables from x and
x; y, respectively.
In some cases, we will drop the universal and existential quantiﬁers in tgd-ACs and acgds,
implicitly assuming such quantiﬁcation. We will use the abbreviation rhs, lhs, respectively, to refer
to the right-hand side, left-hand side, respectively, of a tgd-AC or an acgd. A tgd-AC with no
existentially quantiﬁed variables is called full tgd-AC.
Let d W 8x
 .x/ ^ ˇ.x/ ! 9y  .x; y/ ^ ˇ .x; y/
 be a tgd-AC and D a database in-
stance. We say that D satisﬁes d if whenever there is a homomorphism h from .x/ to D such
that ˇ.h.x// is true, there exists an extension h0 of h such that h0 is a homomorphism from
the conjunction .x/ ^  .x; y/ to D with ˇ .h0.x; y// evaluating to true. While for tgds and
egds, there is always a non-empty database on which the dependency is satisﬁed, this property
does not hold for tgd-ACs and acgds. We call a tgd-AC (or an acgd) d consistent if its arith-
metic comparisons are not inconsistent. Notice that if the given arithmetic comparisons d are
inconsistent, there does not exist a non-empty database instance on which d would be satisﬁed.
For dependencies with arithmetic comparisons, the input should be a set of relational
atoms over a totally ordered domain. While ground instances satisfy this requirement, for the
purposes of DEAC data-exchange settings (to be deﬁned in the next section) and of computing
certain answers on them, we need to consider instances that use variables alongside constants.
For this purpose, we deﬁne a t-instance to be a set of relational atoms over a totally ordered
domain that contains both constants and variables. For instance, if we have constants 3 and 4 and
variables X and Y , two possible total orders on them are 3 < X D Y < 4 and 3 < 4 < X < Y .
We will use the term t-homomorphism to refer to a homomorphism from a relational structure
K with arithmetic comparisons to a t-instance Kt such that the homomorphism makes the
dependencies of K true on Kt.
Recall that in the CDE setting that was deﬁned in Section 6.1, we did not use egds in the
set of source-to-target dependencies, because such egds would essentially impose dependencies
on the source data, where they are not needed. For the same reason, we do not use acgds in the
set of source-to-target dependencies in DEAC settings, and also require that the tgd-ACs in
this set have ACs that contain at least one existential variable. The reason is that if a tgd-AC
involves ACs deﬁned over non-existential variables only, then the tgd-AC is equivalent to a set
comprising both acgds and tgd-ACs whose ACs contain at least one existential variable. The
following example illustrates how to produce such an equivalent set of dependencies.
Example 6.9
Consider the following target tgd-AC:
d W a.X; Y/; b.Y; W/ ! c.X; Y/; X < Y.
The arithmetic comparison X < Y does not contain an existentially quantiﬁed variable (i.e., a
variable that only appears on the right-hand side of the tgd-AC). Thus, d is equivalent to a set
of dependencies consisting of a tgd d1 and acgd d2, deﬁned as follows:
d1 W a.X; Y/; b.Y; W/ ! c.X; Y/;

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
149
d2 W a.X; Y/; b.Y; W/ ! X < Y:
6.2.2
THE AC-CHASE
To be able to discuss the DEAC setting further, we need to develop a new technical tool, which
we call AC-chase. A property of the AC-chase is that it is not linear, in the sense that its chase
step can produce from an instance a set of instances, each of which is then chased further. We
now provide the details.
AC-chase
While using the same main idea as the chase procedure, AC-chase it produces a tree rather than
a sequence. The reason is that the result of an AC-chase step on a t-instance may not always be
a t-instance. Instead, it could be an instance containing a partial, rather than a total, order. We
say that a t-instance Kt is induced by instance K if Kt is constructed from K by adding ACs in
such a way that all the variables and constants appearing in the relational atoms in Kt now have
a total ordering, which is imposed on them by the ACs. If K is the instance resulting from an
AC-chase step, before proceeding to the next AC-chase step we might need to consider all the
t-instances induced by K. The result of applying AC-chase is a set of instances found on the
leaves of the AC-chase tree.
Deﬁnition 6.10
.AC-chase step/
Let K D K0 ^ ˇK be a t-instance. An AC-chase step consists of three stages.
Stage I: Construct an instance K0 by adding to K relational facts and arithmetic comparisons.
(a) (tgd-AC): Let d W .x/ ^ ˇ.x/ !  .x; y/ ^ ˇ .x; y/ be a tgd-AC. Let h be a t-
homomorphism from .x/ ^ ˇ.x/ to K, such that there is no extension of h to a t-
homomorphism from .x/ ^ ˇ.x/ ^  .x; y/ ^ ˇ .x; y/ to K. We then say that d can
be applied to K with t-homomorphism h. Let h0 be the underlying homomorphism of h,
and let K0
0 be the union of K0 with the set of facts obtained by:
(i) extending h0 to a homomorphism h0
0 in such a way that every variable in y is assigned
a fresh labeled null, followed by
(ii) taking the image of the atoms in the rhs of d under h0
0.
For each arithmetic comparison x1x2 in ˇ .x/, we add h0
0.x1x2/ to K0
0, and output K0
in compact form.
(b) (acgd): Let d be an acgd .x/ ^ ˇ.x/ ! .x1x2/. Let h be a t-homomorphism from
.x/ ^ ˇ.x/ to K, such that h.x1x2/ is not true. We then say that d can be applied to
K with t-homomorphism h. We add h.x1x2/ to K, and output K0.
Stage II: Check K0 for consistency. We distinguish between two cases.

150
6. ANSWERING QUERIES IN DATA EXCHANGE
(1) If K0 is not consistent, we say that the result of applying d to K with h is “failure,” and
write K
d;h
 ! ?.
(2) Otherwise, we say that the result of applying d to K with h is K0, denoted K
d;h
 ! K0.
Stage III: Return all the induced t-instances K0
1; : : : ; K0
n of K0 in compact form, and denote
this step K
d;h
 ! fK0
1; : : : ; K0
ng.
We now deﬁne the AC-chase tree, the ﬁnite AC-chase, and the successful AC-chase.
Deﬁnition 6.11
.AC-chase tree/
Let † be a set of tgd-ACs and acgds, and J be an instance. An AC-chase tree of J with † is a
tree .ﬁnite or inﬁnite/ such that:
– the root is a dummy node with children all t-instances induced by J; and
– for each node K in the tree, let fK0
1; : : : ; K0
lg be the set of its children. There must exist a
tgd-AC or an acgd d in †, a t-homomorphism h from the lhs of d to K, and an instance
K0, such that K
d;h
 ! K0, and K0
1; : : : ; K0
l are all the t-instances induced by K0.
A ﬁnite AC-chase of J with † is a ﬁnite chase tree such that each leaf is either ? or satisﬁes †.
The result of a ﬁnite AC-chase is the union of all the leaf nodes that are not ?. If the result is not
empty, we refer to it as the result of a ﬁnite successful AC-chase.
Example 6.12
Suppose we have the following set † of dependencies:
d1 W a.X; Y/ ! b.X; Y; Z/; Z  X.
d2 W b.X; Y; Z/; Z < X ! c.X; W/; W  X.
d3 W c.X; X/ ! d.X/.
d4 W c.X; W/; W < X ! e.X/.
Let I D fa.1; 2/g be a ground instance on which we apply AC-chase using the dependen-
cies in †. The AC-chase tree has depth six, and is as follows.
1. The root is I D fa.1; 2/g.
2. Applying d1 to the root yields (a child of the root that is) I1 D fa.1; 2/; b.1; 2; Z/; Z  1g;
this is the second level of the tree.
3. The child of the root has a partial order, so we construct two nodes in the third level of
the tree, as the only possible total orderings are Z < 1 and Z D 1. These are the two total
orderings that are induced by Z  1 in the instance I1 D fa.1; 2/; b.1; 2; Z/; Z  1g that
resulted from the above application of d1. The instances I21 D fa.1; 2/; b.1; 2; 1/g and
I22 D fa.1; 2/; b.1; 2; Z/; Z < 1g are the children of I1.

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
151
4. Applying d2 to I22 yields I31 D fa.1; 2/; b.1; 2; 1/; c.1; W/; W  1g as the child of I22.
5. We create two children of I31, I41 and I42, for the two total orderings induced by the partial
order: I41 D fa.1; 2/; b.1; 2; 1/; c.1; 1/g and I42 D fa.1; 2/; b.1; 2; 1/; c.1; W/; W < 1g.
6. Applying d3 to I41 yields I51 D fa.1; 2/; b.1; 2; 1/; c.1; 1/; d.1/g. Applying d4 to I42 yields
I52 D fa.1; 2/; b.1; 2; 1/; c.1; W/; e.1/; W < 1g.
The output of the AC-chase is the set of the three leaves
fI21; I51; I52g:
The following result is analogous to Theorem 5.7.
Theorem 6.13
Let † be a set of tgds and egds. Suppose D is a ground database instance that satisﬁes
the dependencies in †. Let K be a t-instance such that there is a t-homomorphism h from K to D.
Let K† be the result of a successful ﬁnite AC-chase on K with the set of dependencies †. Then there is
a t-instance, Kt
†, in K† such that t-homomorphism h can be extended to a t-homomoprhism h0 from
Kt
† to D.
Proof. While the proof is generally along the lines of the proof of Theorem 5.7, here we have
the additional task of deciding which child on the chase tree to follow. We choose the one whose
t-instance restricted to the newly added labeled nulls conforms with (i.e., is the same as) the total
order on the structure (D) that we are considering, as follows. Based on extending h through the
previous AC-chase steps, we construct an intermediate hi. Via this hi, in the current AC-chase
step that considers dependency d, we map by mapping  the left-hand side of d to D, then
ﬁnd the extension of  that satisﬁes d. (Such an extension always exists, since D satisﬁes the
dependencies.) The variables in D that are involved in this extension of  have a certain total
order, which is the total order that we use to choose the child on the AC-chase tree of the current
AC-chase step.

We now discuss termination conditions for the AC-chase. We deﬁne weak acyclicity for
a set of AC-tgds by ﬁrst dropping the ACs from the AC-tgds; we call the outcome the derived
set of tgds. We say that a set of AC-tgds is weakly acyclic if the derived set of tgds is weakly acyclic.
The following result can be proven either using the proof of Theorem 5.6, or by observing that
each path on the AC-chase tree can produce a chase sequence if we use the derived set of tgds.
The lengths of the resulting paths are only a fraction shorter than the input path on the AC-
chase tree. The value of the fraction can be computed by observing that dropping the ACs from

152
6. ANSWERING QUERIES IN DATA EXCHANGE
multiple tgd-ACs could result in the same tgd; the number of tgd-ACs resulting in the same
tgd is at most equal to the total number of tgd-ACs in the given set of dependencies.
Theorem 6.14
If a set of AC-tgds and acgds is weakly acyclic ,then the AC-chase using the set ter-
minates on every instance.
6.2.3
SOLUTIONS AND UNIVERSAL SOLUTIONS
We now deﬁne the concepts of solution and universal solution in a DEAC setting. Not sur-
prisingly, both deﬁnitions share similarities with the corresponding deﬁnitions in simple data-
exchange settings (i.e., settings without arithmetic comparisons).
Deﬁnition 6.15
(Solution and universal solution)
Let M D .S; T; †st; †t/ be a DEAC setting, and I be a source instance.
• We call an instance J over T a t-solution for I under M .or simply t-solution, in case I and
M are understood from the context/ if J is a t-instance that satisﬁes the dependencies †t,
and the instance I [ J satisﬁes the dependencies †st [ †t. A t-solution that is a ground
instance is called a ground solution.
• We call an instance J of T a solution for I under M .or simply solution, in case I and M are
understood from the context/ if every t-instance induced by J is a t-solution.
• A universal solution for I under M .or simply universal solution, in case I and M are un-
derstood from the context/ is a set J D fJ1; : : : ; Jmg of solutions for I, such that for every
ground solution K, there is a solution Ji 2 J that t-homomorphically maps to K. A uni-
versal t-solution is a universal solution that consists solely of t-solutions.
The following example illustrates the concepts of solution and universal solution in DEAC set-
tings.
Example 6.16
Let M D .S; T; †st; †t/ be a DEAC setting in which S has a single binary
relation E, T has a single binary relation H, †t D ;, and
†st D f d W E.X; Y /; X < Y ! 9Z .H.X; Z/; H.Z; Y /; Z < Xg:
Let I D fE.2; 5/; E.4; 7/g be a ground instance deﬁned over the source schema S. Consider the
following instances over the target schema T:

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
153
J1 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z2 < z1 < 2g;
J2 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 D z2 < 2g;
J3 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < z2 < 2g;
J4 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < 2 D z2g;
J5 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < 2 < z2 < 4g;
J6 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < 2; z2 > 7g;
J7 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z2 < z1 < 3g;
J8 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < 2; z2  2g;
J9 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < 2; z2 < 4g;
J10 D fH.2; 1/; H.1; 5/; H.4; 0/; H.0; 7/g;
J11 D fH.2; 2/; H.2; 5/; H.4; 0/; H.0; 7/; H.8; 7/g.
Note that in all instances above we omitted the trivial total order 2 < 4 < 5 < 7. For in-
stance, the total order in J1 should be z2 < z1 < 2 < 4 < 5 < 7. J1 is a t-instance, since its arith-
metic comparisons deﬁne a total order of its labeled nulls .z1 and z2/ and its constants in I.
.There is no constant in the tgd-AC./ Similarly, J2, J3, J4, J5, and J6 are all t-instances.
J1 is a t-solution, because the dependency d in †st is satisﬁed on I \ J1. Indeed, there are
two homomorphism from the left-hand side of d to I \ J1, the homomorphism h1 that maps
X to 2 and Y to 5 and the homomorphism h2 that maps X to 4 and Y to 7. In I \ J1, h1 can
be extended to a homomorphism h0
1 that maps the right-hand side of d to I \ J1 (the extended
homomorphism maps Z to z1) and the images of the arithmetic comparisons in d under h0
1
are also satisﬁed, hence h0
1 is a t-homomorphism. Similarly, J2–J5 are t-solutions. J6 is not a
t-solution, because the arithmetic comparison z2 > 7 ruins the possibility of the dependency d
being satisﬁed on I \ J6.
J7, J8, and J9 are instances but not t-instances. Indeed, in each instance two diﬀer-
ent total orderings are possible. In J7, we have at least the following two total orderings:
z2 < z1 < 2 < 3 < 4 < 5 < 7 or z2 < 2 < z1 < 3 < 4 < 5 < 7. (Recall that we have to take into
account the constants 2, 4, 5, and 7.)
In J8, we have at least the following two total orderings: z2 < z1 < 2 < 3 < 4 < 5 < 7
and z1 < z2 < 2 < 3 < 4 < 5 < 7. In J9, we have at least the following two total orderings:
z2 < z1 < 2 < 3 < 4 < 5 < 7 and z1 < z2 < 2 < 3 < 4 < 5 < 7.
J1–J5 are all the t-instances induced by J9; J9 is a solution but not a t-solution, because
it is not a t-instance. Similarly, J7 and J8 are solutions.
Both J10 and J11 are ground instances, since they do not contain labeled nulls. J10 is
a ground solution, because the two homomorphisms from the left-hand side of d to I \ J10
can be extended by mapping the variable Z of d to the constant 1 for the extension of one
of the homomorphisms, and by mapping Z to the constant 0 for the extension of the other
homomorphism. The images of the arithmetic comparisons of d are also satisﬁed, since 1 < 2
and 0 < 4. J11 is not a solution.

154
6. ANSWERING QUERIES IN DATA EXCHANGE
There is a t-homomorphism h from J7 to J1, where h is the identity mapping from
Const.J7/ [ Var.J7/ to Const.J1/ [ Var.J1/. In particular, the mapping turns z2 < z1 < 3
into z2 < z1 < 3, which is implied by z2 < z1 < 2. Similarly, J1 t-homomorphically maps to
the ground instance J10. However, there is no t-homomorphism from J6 to J1, because the
identity mapping from the variables of J6 to the variables of J1 is the only homomorphism,
provided that we ignore the arithmetic comparisons; this is not a t-homomorphism, because the
ACs in J1 do not imply the ACs in J6. In other words, z2 < z1 < 3 does not imply z1 < 2 and
z2 > 7.
Finally, J1, J2, J3, and J4 are all the t-instances induced by J8.
The following result is analogous to Theorem 6.5 for the CDE settings discussed in Sec-
tion 6.1.
Theorem 6.17
Given a DEAC setting M D .S; T; †st; †t/ with source instance I, the AC-chase
on I with dependencies †st [ †t yields a universal solution for I under M.
Example 6.18
.Continued from Example 6.16/
The set J1 D fJ1; : : : ; J5g is a universal t-solution computed by the AC-chase as follows: In the
ﬁrst step, we add the following relational atoms and ACs:
fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < 2; z2 < 4g:
The second step produces the induced t-instances, which yield the set J1 D fJ1; : : : ; J5g.
J3 D fJ9g is a universal solution, since all the induced t-solutions of J9 comprise the
universal t-solution computed above. The set J2 D fJ5; J8g is a universal solution, because all
the induced t-solutions of J8 comprise the universal t-solution computed above, except J5.
We now contrast solutions in DEAC settings with solutions in simple data-exchange
settings (i.e., in settings without arithmetic comparisons). For example, consider instance
K W a.5; N1/; b.5; N2/ and tgd d W a.5; N/; b.5; N/ ! c.X; N/. Observe that K is a solution in simple
data-exchange settings, since there is no homomorphism from the lhs of d to K. However, K
is not a solution in a DEAC setting, because a ground instance of K is K0 W a.5; 8/; b.5; 8/, and
there exists a homomorphism from the lhs of d to K0 that cannot be extended. This observation
should not come as a surprise.
6.2.4
SOLUTIONS AND CONJUNCTIVE QUERIES
We now discuss how solutions for a DEAC setting can be connected to CQAC queries, and
how solutions for a CDE setting can be connected to CQ queries. First, with every instance K
we associate a Boolean conjunctive query with arithmetic comparisons qK, such that the body
of qK contains exactly all the facts in K as subgoals .with labeled nulls replaced by variables/,

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
155
and the (possibly partial) order of K is added to qK as arithmetic-comparison predicates. We
use a fresh predicate name for the predicate in the head of qK. We call qK the corresponding
Boolean query of K. We also associate a Boolean query with a set of instances, by creating for
each instance a Boolean query with the same head predicate and by then taking the union of
the resulting queries. Proposition 6.19 states that a universal solution contains any solution as
a query. Its proof is a rather straightforward consequence of Theorem 6.13. Moreover, we also
provide here for completeness Proposition 6.20, which holds for CDE settings; the proof is
immediate from the deﬁnition of universal solution in CDE settings.
Proposition 6.19
Let M D .S; T; †st; †t/ be a DEAC setting. If J is a universal solution of
.M; I/, then for each K 2 SOL.M; I/, we have that qJ contains qK.
Similarly, for the CDE setting we have the following result, in which qJ and qK are CQs
without arithmetic comparisons.
Proposition6.20
Let M D .S; T; †st; †t/ be a CDE setting. If J is a universal solution of .M; I/,
then for each K 2 SOL.M; I/, we have that qJ contains qK.
6.2.5
QUERY ANSWERING
In this section we study the query-answering problem in DEAC settings, for queries posed over
the target schema that belong to the class of unions of conjunctive queries with arithmetic compar-
isons (unions of CQACs).
Certain answers in a DEAC setting are deﬁned over all ground solutions, because CQAC
queries should be computed over domains that are totally ordered. (Recall that we restrict our-
selves to ground instances over totally ordered domains.)
Deﬁnition 6.21
.Certain answers in DEAC settings/
Let M D .S; T; †st; †t/ be a DEAC setting, I be a source instance, and q be a CQAC query
posed over the target schema T. Then,
certainM.q; I/ D \fq.J / W J 2 GS.M; I/g;
where GS.M; I/ is the set of all the ground solutions for I under M, and q.J / is the result of
evaluating q on J.
In DEAC settings and for CQAC queries, some challenges may arise from the fact that
the query may contain constants that do not appear in the t-instance. Therefore, the order of the
t-instance, even if it is a total order on the instance itself, may no longer be a total order with
respect to the additional constants in the query. For this reason, we introduce the concept of a
qt-instance, deﬁned as an instance that forms a total order with respect to also the constants of
the query.

156
6. ANSWERING QUERIES IN DATA EXCHANGE
Qt-instances
The following example illustrates that the concept of qt-instance may prove to be necessary.
Example 6.22
Consider the following CQAC query:
q W ans.A/ :- R.A/; A < 3:
Let J D fR.X/; X < 7g be a t-instance. If we substitute the constant 2 for the labeled null X 2 J,
the answer to the query would be f2g. However, if we substitute the constant 5 for X, the answer
to the query becomes empty. Observe that, although J deﬁnes a total order with respect to its
own constants and labeled nulls, the query may introduce fresh constants .e.g., the constant 3 in
this case/. Consequently, J may no longer form a total order w.r.t. the labeled nulls, the constants
in the t-instance, and the fresh constants of the query.
Formally, let M D .S; T; †st; †t/ be a DEAC setting, q be a CQAC query, and J be an
instance over T. Let C D Const.J / [ Const.†st [ †t/ [ Const.q/. An instance K is called a
qt-instance with respect to q and J under M if it is a t-instance with respect to C and the labeled
nulls of K. For simplicity, we say that K is a qt-instance induced by J whenever clear from the
context.
Evaluating a CQAC Query on an Instance
We now show how the concept of qt-instance can be used to evaluate a CQAC query q on a
given t-instance J. Let Jq denote the set of qt-instances of J w.r.t. q, which we deﬁne to be all the
qt-instances Ji such that there is a t-homomorphism from J to Ji. Deﬁnition 6.23 formalizes
the evaluation of a CQAC query on a t-instance. We evaluate a query q on a qt-instance K by
treating the labeled nulls in K as distinct constants, and by removing from the output the tuples
containing labeled nulls. (The latter is denoted by the operator “#”.)
Deﬁnition6.23
Let J be an instance and q be a CQAC query. Let Jq be the set of qt-instances
of J w.r.t. q. The result of evaluating q on J, denoted q.J /, is deﬁned as:
q.J / D \fq.K/# W K 2 Jqg;
where q.K/ is the set of answers of q on qt-instance K.
Computing Certain Answers
The following result is analogous to Theorem 6.6.
Theorem 6.24
Let J be a universal solution for a given DEAC setting and source instance. Then
for any query q in the language of unions of CQACs, J can be used to compute the certain answers to
q, as follows:
certainM.q; I/ D \J 2J q.J /:

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
157
Here, q.J / is computed as in Deﬁnition 6.23.
The following example uses Deﬁnition 6.23 to compute certain answers of a query on an
instance.
Example 6.25
Consider the following query Q and t-instance J:
Q:
q./ :- R.A; B/; A > 3; B < 5I
J:
fR.x; y/; R.y; z/; 3 < x < z < 4 < yg:
To test if the query Q is true on the instance J, we need to ﬁnd a homomorphism from the
single subgoal of the query to one of the two facts in J, such that the arithmetic comparisons in
the query would be satisﬁed. Consider homomorphism 1, which maps A to x and B to y. The
homomorphism 1 maps the subgoal R.A; B/ to the fact R.x; y/. We also require that 1.A/ > 3
and 1.B/ < 5, i.e., we require that x > 3 and y < 5. The comparison x > 3 is true in J, but
we know nothing about the comparison y < 5. However, we know that there are two cases for
y: Either y < 5 or y  5. In the ﬁrst case, 1 suﬃces to answer the query. In the second case,
consider 2 that maps A to y and B to z. Now we require that 2.A/ > 3 and 2.B/ < 5, that
is, that y > 3 and z < 5. Since y  5, the ﬁrst requirement is satisﬁed. The second requirement
is also satisﬁed, because z < 4. Thus, the answer to Q on J is true. To compute the answers, we
used the following qt-instances that are induced by the instance J:
J1:
fR.x; y/; R.y; z/; 3 < x < z < 4 < y < 5g:
J2:
fR.x; y/; R.y; z/; 3 < x < z < 4 < y D 5g:
J3:
fR.x; y/; R.y; z/; 3 < x < z < 4 < 5 < yg:
The Algorithm for Computing Certain Answers of a CQAC Query
The main goal of this section is to show how we can use a universal solution to compute the
certain answers of a CQAC query posed over the target schema of a DEAC setting. By Theo-
rem 6.24, the following algorithm computes the certain answers.
1. Compute the universal solution J of the DEAC setting by applying AC-chase.
2. For each leaf of the universal solution, take its qt-instance.
3. For each leaf of the universal solution and for each qt-instance Ji induced by this leaf,
compute q.Ji/.
4. Compute the intersection of all the q.Ji/ computed in Step 3. Keep in the intersection only
those tuples that do not involve variables. The resulting set is the set of certain answers.

158
6. ANSWERING QUERIES IN DATA EXCHANGE
DEAC setting: M D .S; T; †st; †t/
†st: set of tgd-ACs
†t : set of acgds and egd-ACs.
A universal solution is computed by applying the AC-chase algo-
rithm on the input I, which is an instance on the source schema S.
Let q be a union of conjunctive queries with arithmetic compar-
isons posed over the target schema T, and I be a source instance. The
set of certain answers of q for the input I and setting M, denoted by
certainM.q; I/, is computed by evaluating q on the universal solution.
6.2.6
WHEN THE HOMOMORPHISM PROPERTY
HOLDS—PRELIMINARIES
Similarly to what we saw in previous chapters in this book, when we reason about homomor-
phisms in presence of arithmetic comparisons, there could be special cases that allow for simpler
algorithms. In particular, the homomorphism property that we discussed earlier can be useful in
simplifying the AC-chase for special kinds of tgd-ACs and acgds. We now provide the deﬁni-
tion: If .B1; B2/ is a pair of sets of ACs that enables the homomorphism property (see page 36)
and † is a set of tgd-ACs and acgds such that (i) all the ACs on the left-hand sides of all the
dependencies in † belong to the class B1, and (ii) all the ACs on the right-hand sides belong to
B2, then we say that † has the homomorphism property for AC-chase.
Recall that we call a tgd or a tgd-AC full if it does not have existential variables. (That is,
all the variables on the right-hand side of a tgd or tgd-AC also appear on the left-hand side.)
Whenever we use full tgd-ACs in a set of source-to-target dependencies, we will require that
they have ACs only on the left-hand side.
Before we formally introduce a version of AC-chase applicable to the cases in which the
homomorphism property holds, we will provide some intuition, by presenting simple cases in
which we do not need the chase tree to provide answers to queries. We will be using the abbre-
viation UCQAC for the query language of unions of CQACs.
• Case I: †st comprises full tgd-ACs; †t comprises full tgd-ACs and acgds; queries:
UCQAC.
It is straightforward to show that no labeled nulls are produced during the AC-
chase in this case. Indeed, labeled nulls are the only reason for AC-chase to produce a
tree instead of a sequence, because in every step it has to create one or more descendant
t-instances. Thus, in this special case we have only one ground solution.

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
159
• Case II: The dependencies are tgds and egds, and queries are unions of CQs.
While this case is covered by the CDE setting, let us discuss it in a little more de-
tail. In this case, AC-chase will actually create a tree. It turns out that the tree is not
necessary for the purpose of answering CQs, because there are no ACs either in the
dependencies or in the query. Hence, we can show that in this case we can use regular
chase, rather than AC-chase, and then ﬁnd the certain answers by evaluating the query
on the outcome.
For the general case of answering CQAC queries in presence of tgd and egd dependencies,
we need AC-chase. While this case will not be formally discussed further in this book, we
note that the way to approach it is to do postprocessing on the results of AC-chase, as all
the total orderings need to be considered. That is, we use AC-chase on an input I, and
then produce all the t-instances induced by the outcome J. We then obtain the certain
answers to the given CQAC query by evaluating the query on each of theses t-instances
and taking the intersection of the answers. The following example shows that we cannot
do better than considering all total orderings, because one homomorphism is not enough
to evaluate a CQAC query.
Example 6.26
We are given a single source-to-target tgd d and no target dependencies:
d W
r.Z; Z0; W / ! s.W /; p.X; Y; Z0; Z; U; U /; p.Z; Z0; X; Y; U; U /; p.Z; Z0; Z0; Z; X; Y /:
On input instance I D fr.1; 2; 3/g, the output of AC-chase is
J D fs.3/; p.X; Y; 2; 1; U; U /; p.1; 2; X; Y; U; U /; p.1; 2; 2; 1; X; Y /g:
Consider CQAC query Q:
q.W / :- s.W /; p.X; Y; Z; Z0; U; U /; X < Y; Z > Z0:
Evaluating this query on all the t-instances induced by J and taking the intersection of the
answers yields the ﬁnal answer f.3/g. That is, although J is derived by AC-chase and can
on its own represent all the t-solutions that are necessary to answer the query, to answer
the query we still need to perform another step that produces all the t-solutions induced
by J.
Notice the relationship of this case here with the setting of Example 2.17. Indeed, the
intuition is the same in both cases. In this current example, we have to consider all the
total orderings of the variables X; Y , and U , with constants 1 and 2 added, to make sure
that there is a way to satisfy the dependencies using J. While we know we will not get

160
6. ANSWERING QUERIES IN DATA EXCHANGE
any query answer other than (3), it is conceivable that we could get the empty answer if
the arithmetic comparisons in the query q are not satisﬁed when q is computed on J. The
only way to ensure that the arithmetic comparisons of q are satisﬁed is to consider more
than one homomorphism from the query subgoals to J.
• Case III: The dependencies are tgds and egds, and queries belong to the language
UCQAC-LSI with closed LSIs.
This is an extension of the case above in which queries are CQs. In this case, we
can use chase to produce a universal solution J, and then evaluate the query using a
single homomorphism from the query to J. This approach is correct because of the
homomorphism property.
• Case IV: †st comprises tgd-ACs; †t is empty; queries are unions of CQs.
Here, when we use AC-chase, in each chase step the left-hand side of any tgd in
†st can map to constants only. Thus, we do not need the t-instances, and hence do not
need the tree produced by AC-chase.
• Case V: †st comprises tgd-ACs; †t is empty; queries are UCQAC with the homomor-
phism property.
This case is an extension of the previous case.
The succinct AC-chase introduced in the following section builds on the intuition of these
cases.
6.2.7
SUCCINCT AC-CHASE
We introduce a new chase procedure called succinct AC-chase (SAC-chase). In SAC-chase, we
obtain chase sequences, rather than trees as in the case of AC-chase.
For ease of reference, as we did with t-homomorphism, we deﬁne the concept of p-
homomorphism. This notion extends naturally the notion of t-homomorphism, by allowing a map-
ping from an instance with arithmetic comparisons to an instance with partial, rather than total,
order. (Those instances are thus not necessarily t-instances.) The formal deﬁnition follows.
Deﬁnition 6.27
.p-homomorphism/
Let F.x/ D F0.x/ C ˇF .x/ be a instance and K.x/ D K0.x/ C ˇK.x/ be an instance in compact
form. A p-homomorphism h from F to K is a mapping from Const.F / [ Var.F / to Const.K/
[ Var.K/ with the following properties.
 Each constant in F is mapped to itself in K.

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
161
 Whenever R.x1; : : : ; xk/ holds in F , R.h.x1/; : : : ; h.xk// holds in K.
 ˇK.x/ ) ˇF .h.x//.
We say that F p-homomorphically maps to K if there is a p-homomorphism from F to K. A
p-homomorphism h from F to K implies a homomorphism h0 from F0 to K0. We call h0 the
underlying homomorphism of h.
Informally, a p-homomorphism is a homomorphism h from F0 to K0, such that the ACs in K
imply the image under h of the ACs in F .
The following result relates a p-homomorphism to t-homomorphisms. Recall that we
use the term “instance” to refer to sets of relational atoms associated with a set of ACs on the
variables appearing in the atoms.
Proposition 6.28
Let F and K be two instances, with K in compact form. If there exists a p-
homomorphism from F to K, then there exists a t-homomorphism from F to each induced t-instance
of K.
Proof. Let h be the p-homomorphism from F to K, and let Ki be the t-instance induced by
K. By deﬁnition of induced t-instance, there exists a t-homomorphism hi from K to Ki. The
composition hi ı h is a t-homomorphism from F to Ki.

Let d1 be a tgd-AC, d2 be an acgd, and K be an instance, possibly with partial order.
Similarly to the case of instances with total order, we say that K p-satisﬁes d1 if, whenever there
is a p-homomorphism h from the lhs of d1 to K, there exists an extension h0 of h, where h0 is a
p-homomorphism from the conjunction of the lhs and rhs of d1 to K. We say that K p-satisﬁes
d2 if, whenever there is a p-homomorphism h from the lhs of d2 to K, then the image of the
rhs of d2 under h is true. Whenever clear from context, we say simply “satisﬁes.”
We proceed to the deﬁnition of SAC-chase. Technically, a SAC-chase step comprises
the ﬁrst two stages of an AC-chase step (Deﬁnition 6.10), while using a p-homomorphism
rather than a t-homomorphism. A SAC-chase step does not decompose instances into their
induced t-instances. (See Stage III in Deﬁnition 6.10.) As a result, every node in the SAC-
chase step yields a single child instance, rather than multiple children. Notice that, since the
instance considered in each SAC-chase step may contain a partial order, rather than total order,
we consider p-homomorphisms rather than t-homomorphisms. The formal deﬁnition follows.
Deﬁnition 6.29
.SAC-chase Step/
Let K D K0 C ˇK be an instance. A SAC-chase step consists of two stages.
Stage I: Constructing an instance K0 by adding relational facts and arithmetic comparisons to
K:

162
6. ANSWERING QUERIES IN DATA EXCHANGE
(a) (tgd-AC): Let d W .x/ ^ ˇ.x/ !  .x; y/ ^ ˇ .x; y/ be a tgd-AC. Let h be a p-
homomorphism from .x/ ^ ˇ.x/ to K, such that it is not possible to extend h to a
p-homomorphism from .x/ ^ ˇ.x/ ^  .x; y/ ^ ˇ .x; y/ to K. We say that d can be
applied to K with p-homomorphism h. Let h0 be the underlying homomorphism of h,
and let K0
0 be the union of K0 with the set of facts obtained by:
(i) extending h0 to a homomorphism h0
0 such that each variable in y is assigned a fresh
labeled null, followed by
(ii) taking the image of the atoms in the rhs of d under h0
0.
For each arithmetic comparison x1x2 in ˇ .x/, we add h0
0.x1x2/ to K0
0, which gives
rise to K0 in compact form.
(b) (acgd): Let d be an acgd .x/ ^ ˇ.x/ ! .x1x2/, and let h be a p-homomorphism from
.x/ ^ ˇ.x/ to K such that h.x1x2/ is not true. We say that d can be applied to K with
p-homomorphism h. We add h.x1x2/ to K, which gives rise to K0.
Stage II: Checking K0 for consistency. We distinguish two cases:
(i) We say that K0 is not consistent if either h0
0.ˇ .x; y// ^ ˇK (the tgd-AC case) or
h0
0.x1x2/ ^ ˇK (the acgd case) is not consistent. If K0 is not consistent, we say that the
result of applying d to K with h is “failure,” and write K
d;h
 ! ?.
(ii) Otherwise, we say that the result of applying d to K with h is K0, denoted K
d;h
 ! K0.
We continue with the deﬁnition of the SAC-chase, whose structure follows that of regular chase.
Deﬁnition 6.30
.SAC-Chase/
Let † be a set of tgds and egds, and K be a database instance.
 A SAC-chase sequence of K with † is a sequence (ﬁnite or inﬁnite) of SAC-chase steps
Ki
d;h
 ! K0
iC1, with i D 0; 1; : : : ; where K D K0 and d is a dependency in †.
 A ﬁnite SAC-chase of K with † is a ﬁnite chase sequence Ki
d;h
 ! K0
iC1, 0  i < m, with
K D K0, such that either (a) Km D?, or (b) there is no dependency d of † and there is no
homomorphism h such that d can be applied to Km with h. We say that Km is the result of the
ﬁnite SAC-chase. We refer to the case (a) as failing ﬁnite SAC-chase, and to the case (b) as
successful ﬁnite SAC-chase.

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
163
Example 6.31 shows how SAC-chase can be used to compute the singleton universal
solution J3 of Example 6.18.
Example 6.31
.Continued from Example 6.18/
We start with applying the source-to-target dependency
d W E.X; Y/; X < Y ! 9Z .H.X; Z/; H.Z; Y/; Z < X
to the source instance
I D fE.2; 5/; E.4; 7/g
with p-homomorphism X ! 2; Y ! 5. The result of this SAC-chase step is the instance
fE.2; 5/; E.4; 7/; H.2; z1/; H.z1; 5/; z1 < 2g:
Applying to this instance d with p-homomorphism X ! 4; Y ! 7 produces the universal so-
lution J3 D fJ9g, where J9 D fH.2; z1/; H.z1; 5/; H.4; z2/; H.z2; 7/; z1 < 2; z2 < 4g;
J3 D fJ9g is a singleton set. The SAC-chase stops here, because I [ J9 satisﬁes all the depen-
dencies.
The following result parallels those of Theorem 5.7 and Theorem 6.13. The proof follows
the lines of the proof of Theorem 5.7.
Theorem 6.32
Let † be a set of tgds and egds, such that the homomorphism property for chase holds.
Suppose that D is a ground database instance that satisﬁes the dependencies in †, and K is a ground
database instance such that there is a homomorphism h from K to D. Let K† be the result of a successful
ﬁnite SAC-chase on K with set of dependencies †. Then the homomorphism h can be extended to a
homomoprhism h0 from K† to D.
We now discuss termination conditions for SAC-chase. When introducing AC-chase,
we deﬁned weak acyclicity for sets of AC-tgds. The proof of the next result follows from The-
orem 6.14, after we observe that a SAC-chase sequence produces an AC-chase tree. Hence, if
the AC-chase terminates, then the SAC-chase terminates too.
Theorem 6.33
If the given set † of AC-tgds and acgds is weakly acyclic, then SAC-chase with †
terminates on every instance.
Notice that in those cases where there are no target dependencies (even if the source-to-
target dependencies are simple tgds), AC-chase can still produce a tree. This is precisely the
reason why SAC-chase is a useful tool: in certain well-behaving cases it avoids the unnecessary
complexities of AC-chase. Consider an illustration.
Example 6.34
Consider the DEAC setting M D .S; T; †st; †t/, in which †t D ; and

164
6. ANSWERING QUERIES IN DATA EXCHANGE
†st D f d1 W E.X; Y/; X < Y ! 9Z F.X; Z; 8/g.
Consider the source instance I D fE.2; 5/g. The result of SAC-chase on I is the instance
J D fE.2; 5/; F.2; Z1; 8/g. Note that AC-chase would continue, by considering all the t-instances
.7 in total/ induced by J. For instance, for the instances where 2 < Z1, Stage III of the
AC-chase step would consider ﬁve instances, with the respective total orders 2 < 5 < Z1 < 8,
2 < 5 D Z1 < 8, 2 < Z1 < 5 < 8, 2 < 5 < Z1 D 8, and 2 < 5 < 8 < Z1. We observe that, while
the universal solutions produced by SAC-chase and AC-chase are homomorphically equivalent,
SAC-chase is more eﬃcient.
The following result is analogous to Propositions 6.19 and 6.20.
Proposition 6.35
Let M D .S; T; †st; †t/ be a DEAC setting in which the homomorphism prop-
erty for chase holds on the dependencies. For a source instance I, let J be the result of SAC-chase on I.
Then for each instance K in SOL.M; I/; we have that qJ contains qK.
6.2.8
COMPUTING CERTAIN ANSWERS USING SUCCINCT AC-CHASE
We now discuss how to compute certain answers using the result of SAC-chase. We focus on
the case in which:
• the dependencies use closed LSI comparisons (recall that LSI stands for left semi-interval
arithmetic comparisons); and
• the query is a CQAC-LSI that uses closed LSI comparisons.
Deﬁnition 6.36
Given a source instance I and a CQAC query q in a DEAC setting, let J
be the result of SAC-chase on I. We say that a tuple t belongs to q.J / for a query q if there is a
p-homomorphism from q to J that maps the head of q to t.
Theorem 6.37
Let M D .S; T; †st; †t/ be a DEAC setting in which †st and †t use only closed
LSI arithmetics comparisons. Let I be a source instance, and J the result of SAC-chase on I with the
dependencies †st [ †t. Let q be a query in the language of unions of CQACs that uses only closed LSIs.
Then we can compute certain answers to q by using J, as follows:
certainM.q; I/ D q.J /#:
Here, q.J / is evaluated as in Deﬁnition 6.36.

6.2. DATA EXCHANGE WITH ARITHMETIC COMPARISONS
165
Proof. The diﬃcult direction is to prove that q.J /# computes all the certain answers. To show
that, we will prove that there is a t-solution K such that q.K/# = q.J /#. (Recall that q.K/#
includes only those tuples from q.K/ that do not involve variables.)
We now show how to construct K from J. First, replace all the variables in J with distinct
constants in the following way. Let Const be the set of all those constants that appear in I, in
the dependencies †st [ †t, or in the arithmetic comparisons of the query q. If a variable x is
not used in any arithmetic comparison in J, then we replace x with a constant whose value is
larger than any constant in Const. If a variable x is used in an arithmetic comparison in J, then
let c be the smallest constant among the constants ci that appear in the ACs in J as x  ci. Let
c0 be a constant that is smaller than c and, at the same time, larger than any of the constants in
Const that are smaller than c. We replace x with any constant cx such that c0 < cx < c. Observe
that by doing so, we make sure that the following claim is true.
Claim: If there is a homomorphism h from the body of the query q to K that satisﬁes the
ACs of q, then there is a p-homomorphism from the body of q to J.
To prove the claim, we observe that in our replacing the variable x with cx, if a closed
LSI comparison x0  cq of the query q is satisﬁed when the homomorphism h maps x0 to cx,
then cx  cq also holds. From the way we have chosen cx we can derive that c  cq, where c is
as deﬁned above. Hence, x  c implies x  cq. Thus, since the relational atoms in J and K are
isomorphic, the homomorphism h becomes a p-homomorphism from the query body to J. It
follows that all the tuples computed in q.K/# are also computed in q.J /#.
The other direction is to prove that all the tuples computed in q.J /# are certain answers,
i.e., they can be computed on any ground solution. This is shown by arguing as follows. The
p-homomorphism that computes a tuple t in q.J /# can be composed with the homomorphism
from J to any ground solution K, to derive a homomorphism that computes the tuple t in
q.K/#.


166
6. ANSWERING QUERIES IN DATA EXCHANGE
DEAC setting—the homomorphism property
M D .S; T; †st; †t/I
†st: set of tgd-ACs;
†t : set of acgds and egd-ACs.
While this is the same setting as the DEAC setting, we additionally re-
quire that all the given dependencies are such that the homomorphism
property holds.
Let q be a union of conjunctive queries with arithmetic comparisons
posed over the target schema T, and I be a source instance.
Suppose all the given dependencies and the query use only closed
LSI (RSI respectively) ACs. Then Succinct AC-chase applied on I
computes an instance J, such that the certain answers to q can be
obtained by computing q.J /#.
The following example shows a scenario in which succinct AC-chase cannot be used to
compute certain answers.
Example 6.38
Consider a DEAC setting with the following target dependencies:
d1 W
a.x; y/; x < y ! b.x/;
d2 W
a.x; y/; x > y ! b.x/;
d3 W
a.x; y/; x D y ! b.x/;
and with the following source-to-target dependency:
d W
e.x; y/ ! e0.y; z/; a.z; w/:
Suppose the input instance is I D fe.1; 2/g, and the query is Q./ :- b.x/.
The ﬁrst step of SAC chase, which applies to I the dependency d, yields J1 D
fe.1; 2/; e0.2; x/; a.x; y/g. No other step of SAC chase can be applied, because the left-hand
side of any of the three target dependencies does not p-homomorphically map to J1. (That is,
there is no homomorphism such that the ACs in J1 would imply the image of the ACs of di.)
Hence, J1 is the result of SAC chase in this case. The answer to Q on J1 is empty (i.e., false),
which yields the empty set of answer tuples.
This empty-set answer to Q is an incorrect set of certain answer to Q. Indeed, consider
the three t-instances induced by J1:
J11 W fa.x; y/; x < ygI
J12 W fa.x; y/; x > ygI
J13 W fa.x; y/; x D yg:

6.3. INCOMPLETE DATA EXCHANGE
167
(Each of the three instances also includes the two facts e.1; 2/ and e0.2; x/. As these facts do
not participate in any further application of SAC chase steps, we do not refer to these tuples any
further in the rest of the example.)
On the instance J11 we can apply the tgd-AC d1, on the instance J12 we can apply the
tgd-AC d2, and on the instance J13 we can apply the tgd-AC d3, to obtain, respectively, the
following t-instances:
J 0
11 W fa.x; y/; x < y; b.x/gI
J 0
12 W fa.x; y/; x > y; b.x/gI
J 0
13 W fa.x; y/; x D y; b.x/g:
On each of J 0
11, J 0
12, and J 0
13, the query Q evaluates to the empty tuple (i.e., to true), and
the set f./g is the correct set of certain answers to Q in this case.
6.3
INCOMPLETE DATA EXCHANGE
In this section we consider a data-exchange setting in which the input source instance is not
complete, in that there are missing atoms, and the given atoms may involve unknown values
represented by nulls. We consider dependencies that are regular tgds and egds (that is, the types
without arithmetic comparisons), and discuss the problem of evaluating conjunctive queries
(without arithmetic comparisons) over the target schema. We call this setting the incomplete
data-exchange setting (IDE).
6.3.1
INCOMPLETE INSTANCES
Each incomplete instance I represents a set, Rep.I/ (possibly of inﬁnite size), of complete (i.e.,
ground) intances Ij ; j D 1; 2; : : :, deﬁned as follows. For each j D 1; 2; : : :, Ij is such that there
exists a homomorphism from I to Ij. That is, each Ij contains all the tuples in I, with their
null values replaced by constants. Consider the following example.
Example 6.39
Consider incomplete instance I W fa.11; 1; p/g, where p is a null value. I rep-
resents inﬁnitely many complete instances, including the following instances I1—I4:
I1 W fa.11; 1; 1/; a.15; 2; 1/gI
I2 W fa.11; 1; 2/gI
I3 W fa.11; 1; 1/; a.15; 2; 2/gI
I4 W fa.11; 1; 2/; a.15; 2; 3/; b.1; 2/g:
The set Rep.I/ of all the complete instances represented by I comprises all the instances
containing the tuple a.11; 1; p/ for some constant value p; as well as potentially a ﬁnite set of
any other tuples. For each I 2 Rep.I/, there is a homomorphism from I to I. In particular, for
i D 1; 2; 3; 4, there is a homomorphism from I to the instance Ii shown above.
We can require that a set † of dependencies be satisﬁed on an incomplete instance. We
denote by Sat.†/ the set of all the ground instances that satisfy †. Given a (possibly incomplete)

168
6. ANSWERING QUERIES IN DATA EXCHANGE
instance I and a set of dependencies †s, the set Rep.I/ \ Sat.†s/ is the set of those complete
instances represented by I that also satisfy †s. Consider the following example.
Example 6.40
To the setting of Example 6.39, we add the following dependency d:
d W a.Z; X; Y / ! X D Y:
The instance I1 of Example 6.39 does not satisfy the dependency d. Indeed, for the tuple
a.15; 2; 1/ in I1, the dependency d requires that the constants 2 and 1 in the second and third
positions of the atom be the same (which they are not). The only complete instance of Exam-
ple 6.39 that satisﬁes the dependency d is I3. Hence, if we denote by †s the set f d g, the instance
I3 of Example 6.39 is the only ground instance provided in that example that is an element of
the set Rep.I/ \ Sat.†s/.
6.3.2
THE IDE SETTING AND THE CORRESPONDING CDE SETTINGS
The following deﬁnition formalizes an incomplete data-exchange setting.
Deﬁnition 6.41
.Incomplete data-exchange setting/
An incomplete data-exchange setting (IDE) is a quintuple M D .S; T; †s; †st; †t/, where:
 S is a source schema and T is a target schema;
 †s is a ﬁnite set of source tgds and source egds;
 †st is a ﬁnite set of source-to-target tgds; and
 †t is a ﬁnite set of target tgds and target egds.
Let .I; M/ be a pair where
M D .S; T; †s; †st; †t/
is an IDE setting and I is an incomplete instance of schema S. An IDE problem .I; M/ is the
problem of deﬁning certain answers for .I; M/ for a given CQ query.
Corresponding CDE Settings
We saw in Section 6.3.1 how an incomplete instance I and a set of dependencies †s represent
a set of complete instances Rep.I/ \ Sat.†s/.
Let M D .S; T; †s; †st; †t/ be an IDE setting. We call the CDE setting M0 D
.S; T; †st; †t/ the CDE setting that corresponds to M (CCDE setting).
Example 6.42
We revisit Examples 6.39 and 6.40, in which we discussed the incomplete
instance I D fa.11; 1; p/g, with p a null value. For the instance I and the set †s of depen-
dencies given in Example 6.40, all the complete instances in Rep.I/ \ Sat.†s/ must contain

6.3. INCOMPLETE DATA EXCHANGE
169
a.11; 1; 1/. We saw in Example 6.40 that the instance I3 of Example 6.39 is an element of the
set Rep.I/ \ Sat.†s/.
Now assume an IDE setting M, whose set †s of source dependencies comprises the de-
pendency d of Example 6.40, which we reproduce here for convenience:
d W a.Z; X; Y / ! X D Y:
Let M have ﬁxed source and target schemata, S and T, respectively, a ﬁxed set of source-to-target
dependencies †st, and a ﬁxed set of target dependencies †t. The corresponding CDE setting is
M0 D .S; T; †st; †t/; note that M0 includes the source-to-target and target dependencies of M,
but not its source dependencies.
Semantics of Query Answering in IDE Settings
For a given IDE setting M, let M0 be the corresponding CDE setting. Let I be an incomplete
instance of schema S. Let Ii 2 Rep.I/ \ Sat.†s/ for i D 1; 2; : : :, and let SOLi be the set
of solutions for each .Ii; M0/. Let SOL D [i SOLi. We deﬁne certain answers for .I; M/ as
follows.
Deﬁnition 6.43
(CertainB answers)
Let M D .S; T; †s; †st; †t/ be an IDE setting, I be an incomplete source instance, and q a
CQ. Then,
certainB
M.q; I/ D \Ji2SOLq.Ji/:
Here, SOL is as deﬁned above for the corresponding CDE setting M0 for M.
Recall that in the CDE setting, the target instance may contain incomplete data, while
in the IDE setting both the source instance and the target instance may be incomplete. In the
CDE setting, we use labeled nulls to model unknown values in the target instances. In the IDE
setting, for the sake of clarity of presentation we use nulls to represent unknown values in the
source and labeled nulls to represent unknown values in the target.
Similarly to complete data-exchange settings, we assume here an inﬁnite domain of con-
stants Const and an inﬁnite set Var of variables, called labeled nulls, such that Const and Var
are disjoint. We also assume an inﬁnite domain Null of nulls, which is pairwise disjoint from
Const and Var. An incomplete instance over a schema consists of relational facts with constants
from Const, nulls from Null, and labeled nulls from Var. An incomplete source instance in an
IDE setting contains only constants from Const and nulls from Null.
6.3.3
COMPUTING CERTAIN ANSWERS IN IDE SETTINGS
Given an IDE setting M D .S; T; †s; †st; †t/ and a source instance I, we rename the nulls in
I into labeled nulls and apply on the outcome chase with the dependencies †s [ †st [ †t. We
refer to the outcome of the chase projected on the target schema as universal instance.

170
6. ANSWERING QUERIES IN DATA EXCHANGE
Computing CertainB Answers
We now show that the result of chase, i.e., the universal instance, can be used to compute
certainB answers to unions of conjunctive queries, by evaluating the query on the universal in-
stance. The following result states it formally.
Theorem 6.44
Let M D .S; T; †s; †st; †t/ be an IDE setting, and q be a union of conjunctive
queries posed over the target schema T. For every (possibly incomplete) source instance I, we have that
certainB.q; I/ D q.J /#, where J is the result of chase on I with the dependencies †s [ †st [ †t.
Proof. The proof of Theorem 6.44 is a consequence of the property of the chase stated in Theo-
rem 5.7 (Chapter 5). Essentially, we would like to prove that for each Ii in Rep.I/ \ Sat.†s/
for which the CDE problem .Ii; M 0/ has a solution, we have that \fq.Ji/#g D q.J /#, where
J1; : : : ; Jk are universal solutions to the CCDE problems for M.
Ji satisfy the dependencies, hence, according to Theorem 5.7, there is a homomorphism
from J to Ji. Hence, q.J /#  \fq.Ji/g. Moreover, J is a universal solution to one of the CCDE
problems. Hence, \fq.Ji/#g D q.J /#.

The following example shows how the result of the chase can be used to compute certain
answers.
Example 6.45
We revisit Example 6.42, in which we were considering the incomplete source
instance I D fa.11; 1; p/g, with p a null value. Let us also have the following dependencies.
• One source dependency:
ds W a.Z; X; Y / ! X D Y:
• One source-to-target dependency:
dst W a.X; Y; Z/ ! b.X; Y; Z/I and
• No target dependencies.
Let the query be Q1 W q.Y / :- b.Y; Z; X/.
We ﬁrst illustrate how to compute the certain answers to the query in this setting by using
the deﬁnition of certain answers, and then how to compute the answers by using the chase. In
both cases we arrive at the same result.
Computing the certain answers using the deﬁnition: As mentioned in Example 6.42, for the
source instance I there is one CCDE problem .I1; M0/ and inﬁnitely many CCDE problems
.I2i; M0/. Observe that only the CDE problem .I1; M0/ has a solution according to the deﬁni-
tion of solution for the CDE setting. Thus, certainM 0.q; I2i/ D ;. To compute certainM 0.q; I1/,
we apply the theory for CDE settings, i.e., we apply chase on I1 D fa.11; 1; 1/g with the
union of the sets of dependencies given in Example 6.39, to obtain universal solution J1 D

6.4. EXERCISES
171
fb.11; 1; 1/g. We then compute the query on this universal solution. Hence, certainM 0.q; I1/ D
q.fb.11; 1; 1/g/ D f11g.
Thus,
certainB
M.q; I/ D certainM 0.q; I1/ D q.fb.11; 1; 1/g/ D f.11/g:
Computing the certain answers using the chase: The universal instance of I D fa.11; 1; N /g
under M is J D fb.11; 1; 1/g. We compute certainB for Q1 W q.X/ :- b.X; Y; Z/, which yields
q.J / D f.11/g.
IDE setting: M D .S; T; †s; †st; †t/
†s: set of tgds and egds;
†st: set of tgds; and
†t : set of tgds and egds.
Let q be a union of conjunctive queries posed over the target schema T,
and I be a source instance. The certainB answers of q for the input I
and setting M, denoted by certainB
M.q; I/, are computed by evaluating
q on the outcome of the chase algorithm applied on I.
6.4
EXERCISES
6.1.
Prove that for the query language of unions of conjunctive queries with inequalities,
the following two deﬁnitions of certain answers coincide: (a) the deﬁnition based on
solutions in complete data-exchange settings, and (b) the deﬁnition of certain answers
based on ground solutions in DEAC settings. That is, prove the following result.
Proposition 6.46
Let M D .S; T; †st; †t/ be a complete data-exchange setting .without
arithmetic comparisons/. Let q be a union of conjunctive queries with inequalities. Then
certainDE
M .q; I/ D certainM.q; I/ for each input I.
6.2.
Let M D .S; T; †st; †t/ be a DEAC setting with †st D fd W E.Y/ ! A.Y; Z/; Y  Zg
and †t D ;. Let I D fE.5/g be the source instance.
Find the result of the AC-chase on I and the SAC-chase on I, and compare the two
results.
6.3.
Given the following instance I of the source schema f P g and the following dependen-
cies  and , compute the certain answers to the given query Q on the target schema
f T g.

172
6. ANSWERING QUERIES IN DATA EXCHANGE
I D f p.1; 2/; p.1; 3/; p.3; 2/; p.3; 1/ g.
 W
p.X; Y / ! t.X; Y /; t.Y; Y /:
 W
t.X; Y / ! t.Y; X/:
Q.X; Y / :- T .X; Y /; T .Y; X/; T .X; X/:
6.4.
Given the following instance I of the source schema f P g and the following dependen-
cies  and , compute the certain answers to the given query Q on the target schema
f S, T g.
I D f p.1; 2/; p.1; 3/; p.3; 2/; p.3; 1/ g.
 W
p.X; Y / ^ p.Y; W / ! t.X; Z/; t.Y; Z/; s.Z/:
 W
t.X; Y / ^ t.X; Z/ ! Y D Z:
Q.X; Y / :- T .X; Y /; S.Y /:

173
C H A P T E R
7
Answering Queries Using
Views
The problem of answering queries using views suggests several theoretical questions. In this
chapter we discuss some of these questions.
7.1
CERTAIN ANSWERS FOR QUERIES IN PRESENCE OF
VIEW INSTANCES
In this section, we ﬁrst deﬁne the notion of certain answers for a query Q in presence of a view
instance I, under both the closed and open world assumptions. Then, in Section 7.1.2, for a CQ
query Q, set of views V, and MCR R in the language of unions of CQs, we study the question
of whether certain.Q; I/ equals R.I/ under the open world assumption.
7.1.1
CLOSED VS. OPEN WORLD ASSUMPTION
The deﬁnition of certain answers depends on the assumptions, closed world vs. open world, that
we make about views. Given a view instance I, under the closed world assumption (CWA), I
stores all the tuples that satisfy the view deﬁnitions in V, i.e., I D V.D/. Under the open world
assumption (OWA), instance I is possibly incomplete and might store only some of the tuples
that satisfy the view deﬁnitions in V, i.e., I  V.D/. In data integration we usually take the
OWA, while in query optimization we focus on the CWA.
Deﬁnition 7.1
For a query Q and view instance I, we deﬁne the certain answers of (Q; I)
with respect to a set of view deﬁnitions V as follows.
• Under the closed world assumption:
certain.Q; I/ D
\
fQ.D/ W D such that I D V.D/g:
• Under the open world assumption:
certain.Q; I/ D
\
fQ.D/ W D such that I  V.D/g:
In presence of a set of dependencies †, we also require that all the databases D used for
computing certain.Q; I/ satisfy †.

174
7. ANSWERING QUERIES USING VIEWS
Example 7.2
Consider CQ queries and views that are path queries. Let Q be path query
P13; the two views are as follows. V1 is P15, and V2 is P14. Consider a database D that is a
simple path with nodes along the path 1; 2; 3; : : : ; 16. The result of computing the views on D
comprises the tuples V1.1; 16/; V2.1; 15/, and V2.2; 16/. If we are given only the view instance
I D fV1.1; 16/; V2.1; 15/; V2.2; 16/g, under the closed world assumption we know that there is
a path of length 13 from node 2–15. Hence, .2; 15/ is among the certain answers to the query
Q. However, under the open world assumption, since all the tuples in V.D/ are not necessarily
in the view instance, we cannot reason that there is a path in D from node 2–15.
To prove that the set of certain answers to Q is empty under the OWA, we need to reason
that there is a database D0 such that I  V.D0/ and there is no path of length 13 connect-
ing nodes 2 and 15. Such a database would represent a graph that consists of (a) a path of
length 15 from node 1–16, with nodes n0 D 1; n1; n2; : : : ; n15 D 16; (b) a path of length 14
from node 1–15, with nodes n0 D 1; n0
1; n0
2; : : : ; n0
14 D 15; and (c) a path of length 14 from
node 2–16, with nodes n00
0 D 2; n00
1; n00
2; : : : ; n00
14 D 16. On such a database, there is no path from
node 2–15. Hence, the set of certain answers to Q is empty under the OWA.
7.1.2
CERTAIN ANSWERS VS. MCRS
We now prove that for CQ views, a maximally contained rewriting P with respect to the lan-
guage UCQ of a UCQ query Q computes the certain answers of Q under the OWA. That is,
we prove the following result.
Theorem 7.3
Let Q be a UCQ query, V a set of CQ views, and P an MCR of Q with respect
to UCQ. Let I be a view instance such that there exists a database instance D for which I  V.D/
(equivalently, such that certain.Q; I/ ¤ ;). Then, under the open world assumption P computes all
the certain answers of Q in any view instance I: P.I/ D certain.Q; I/.
We begin by pointing out an interesting case, which is essentially a technicality that we
need to consider for the proof of Theorem 7.3. The point in question is the part of the statement
of the theorem that requires the existence of a database instance D for which I  V.D/. We
illustrate with an example. Under the open world assumption, if I 6 V.D/ for all databases D,
and R is an MCR of a query Q using the views with respect to a query language L, then it is
possible for certain.Q; I/ D ; and R.I/ ¤ ; to hold at the same time.
Example7.4
Consider a query Q.x; y/ :- a.x; y/, view v.x; x; y/ :- a.x; y/, and view instance
I D fv.1; 2; 3/; v.4; 4; 5/g. Since v.1; 2; 3/ 2 I and v.1; 2; 3/ 62 V.D/ for any database D, we
have that I 6 V.D/ for all databases D.
There is only one rewriting R.x; y/ :- V.x; x; y/. Then R.I/ D f.4; 5/g, and we have that
certain.Q; I/ D
\
D s:t: IV.D/
Q.D/ D ;; because 6 9D such that I  V.D/:

7.1. CERTAIN ANSWERS FOR QUERIES IN PRESENCE OF VIEW INSTANCES
175
Before we proceed, it is convenient to deﬁne for a given view instance I a canonical
database instance DI that has the property I  V.DI/. First, we construct from the views a
set of tgds (we will refer to them as the view tgds): for each view deﬁnition, the left-hand side
of the tgd is the head of the rule that deﬁnes the view, and the right-hand side is the body of
the rule.
Deﬁnition 7.5
(Canonical database instance of I)
Let I be a view instance for a set of views V. We chase I with the set of the view tgds for V,
to obtain I [ DI. The database DI is called the canonical database instance of I, provided that
I  V.DI/.
Observe that for a given set of views V, view instance I, and database D, the following
statements are equivalent.
• I  V.D/; and
• I [ D satisﬁes the view tgds.
Proposition 7.7, which we are about to formulate, states a condition for I  V.DI/ to hold
for any I, while Proposition 7.8 states that, whenever for a given view instance I there exists a
database D such that I  V.D/, then I  V.DI/. Notice that given a query and a set of views,
for some instance I there may exist a database D such that I  V.D/, but this inclusion may
not hold for all I. As an illustration, a view deﬁnition may have repeated variables, but the tuples
in I could be such that there is a database D for which I  V.D/. Consider an illustration.
Example 7.6
Let a view V be deﬁned as
V W v.X; X/ :- a.X; Y /; b.Y; Z/:
Consider two view instances: I1 D f.5; 5/g and I2 D f.5; 6/g. While it is not hard to ﬁnd a
database D such that I1  V.D/, this is not the case for I2. Indeed, by deﬁnition of the view,
there are no view instances that include a tuple with two diﬀerent values in its two positions.
Proposition 7.7
Given a set V of CQ views, the following statements are equivalent.
1. None of the view deﬁnitions in V has repeated variables in the head.
2. For every instance I of V, there exists a database instance D such that I  V.D/.

176
7. ANSWERING QUERIES USING VIEWS
Proof. .1/ H) .2/: Consider the canonical database instance DI of I. Since the head of Vi does
not contain repeated variables, during the construction of DI by chase, we used a homomor-
phism from the left-hand side of the view tgd for Vi to the head of some tuple Vi.t/ in I. This
chase step will have created all the atoms used to prove that Vi.t/ is in V.DI/.
.2/ H) .1/: Suppose that for every view instance I there exists a database instance D
such that I  V.D/. Toward a contradiction, let V0 2 V be such that V0 has repeated variables
in the head. Without loss of generality, assume that the head of V0 has two repeated variables
and is deﬁned as V0.x; x; x3 : : : ; xn/.
Let I0 be the view instance I0 D ftg, where t D v0.c1; c2; c3; : : : ; cn/, c1 ¤ c2, and
c1; c2; c3; : : : ; cn 2 Const.I/. From our hypothesis we have that there is a database instance
D0 such that I  V.D0/, so t 2 V.D0/. Thus, there is a homomorphism h W Var.V0/  !
Const.V.D//, so that t D v0.h.x/; h.x/; h.x3/; : : : ; h.xn//. Since it also holds that t D
v0.c1; c2; c3; : : : ; cn/, we have that c1 D h.x/ D c2, which is a contradiction, because we as-
sumed that c1 ¤ c2.

Proposition 7.8
Let V be a set of CQ views and I a view instance such that there exists a
database instance D for which I  V.D/. Then the canonical database instance DI of I is such that
I  V.DI/.
Proof. By Theorem 5.7, I [ DI maps to every database I [ D such that I  V.D/. (Recall
that I [ V.D/ satisﬁes the view tgds.)

Proposition 7.9
Let V be a set of CQ views and I a view instance, such that there exists a database
instance D for which I  V.D/. Let Q be a CQ query. Then Q.DI/ is equal to the set of certain
answers of (Q; I) with respect to V.
Proof. We know from Proposition 7.8 that I  V.DI/. Hence, the set of certain answers of
(Q; I) with respect to V is a subset of Q.DI/. Now for all database instances D such that
I  V.D/, the following holds: I homomorphically maps to D [ I, and D [ I satisﬁes the
dependencies of the view tgds. Hence, by Theorem 5.7, there is a homomorphism from DI [ I
to D [ I. Thus, any answer tuple t to Q on DI [ I is an answer on D [ I. It follows that t is
an answer to Q on any database D such that I  V.D/. Thus, t is in the set of certain answers
of (Q; I) with respect to V. Thus, the set of certain answers of (Q; I) with respect to V can be
computed on DI.

Proposition 7.10
Let Q be a CQ query, V a set of CQ views, R a contained CQ rewriting of Q,
and I a view instance such that there exists a database instance D for which I  V.D/. Then R.I/ 
certain.Q; I/.

7.1. CERTAIN ANSWERS FOR QUERIES IN PRESENCE OF VIEW INSTANCES
177
Proof. For the contained rewriting R of Q, suppose the body of R produces a tuple t when
mapped to I; we prove that t is a certain answer to Q. The expansion Rexp homomorphically
maps to DI by construction of DI. There is a containment mapping from Q to Rexp, hence Q
maps to DI to yield t. By Proposition 7.9, Q.DI/ computes exactly the certain answers. Thus,
t is in the set of certain answers of (Q; I) with respect to V.

Proposition 7.11
Let Q be a CQ query and V ba set of CQ views. Let I be a view instance for
which there exists a database instance D satisfying I  V.D/. Then the space S of contained rewritings
of Q using V is ﬁnite and is of size that is a function of the sizes of only the views and the query. In
addition, for each tuple t0 2 certain.Q; I/, a contained CQ rewriting R of Q such that t0 2 R.I/
is an element of S.
Proof. We construct a contained rewriting R that computes t0 on I, as follows. First we con-
struct DI, for which we know that I  V.DI/ holds. Hence, if t0 2 certain.Q; I/, then
t0 2 Q.DI/. Let h be a homomorphism that computes t0 in Q.DI/. If Q has m subgoals, then
h has at most m targets in DI. These targets were constructed from at most m tuples in I; let
these tuples in I be the only elements of the set St. We use the tuples in St to construct R, as
follows: The head of R is t0 with the constants replaced with variables (same constants to same
variables and distinct constants to distinct variables), and the body of R comprises all the tuples
in St in which constants are replaced by variables (same constants to same variables and distinct
constants to distinct variables).
Now we prove that R is a contained rewriting. Observe that Rexp is isomorphic to the
part of DI that is created by the tuples in St. Hence, the homomorphism h maps Q to Rexp. We
conclude that Q contains Rexp.

We now give a proof of Theorem 7.3.
Proof. (Theorem 7.3) We show the following:
1. P.I/  certain.Q; I/; and
2. certain.Q; I/  P.I/.
Since P is a contained rewriting of Q, the ﬁrst claim above is a direct consequence of Proposi-
tion 7.10. To prove the second claim, we ﬁrst consider the case in which I D ;. Then P.I/ D ;,
and we have that
certain.Q; I/ D
\
D s.t. IV.D/
Q.D/ D
\
D s.t. ;V.D/
Q.D/ D
\
for all D
Q.D/ D ;:
Thus, certain.Q; I/ D ;  ; D P.I/.
Suppose now that I ¤ ;. We consider the following two cases.

178
7. ANSWERING QUERIES USING VIEWS
1. There exists a contained rewriting R 2 S such that R.I/ 6 P.I/. Here we obtain a con-
tradiction, because R is a contained rewriting of Q, and we assumed that P is an MCR of
Q using V with respect to UCQ.
2. There is no contained rewriting R 2 S such that R.I/ 6 P.I/. That is, 8R 2 S W R.I/ 
P.I/. Suppose that t0 2 certain.Q; I/. By Proposition 7.11, there is a rewriting in S that
computes t0, i.e., t0 2 R.I/. Hence, t0 2 P.I/.

7.2
DETERMINACY
A query Q can be thought of as deﬁning a partition of the set of all databases, in the sense that
the databases on which the query produces the same set of answer tuples belong to the same
equivalence class. A set of views deﬁnes a partition of the set of all databases in the same sense.
The deﬁnition that follows considers a setting where the view-induced partition is a reﬁnement
of the partition deﬁned by the query. Thus, an equivalence class of V.D/ can be used to ﬁnd the
corresponding equivalence class of Q.D/.
For databases D1 and D2, we use the notation V.D1/ D V.D2/ to represent the statement
that Vi.D1/ D Vi.D2/ holds for each Vi 2 V.
Deﬁnition 7.12
(Views determine query)
Given a query Q and views V, we say that V determines Q if the following is true: for any pair
of databases D1 and D2, if V.D1/ D V.D2/ then Q.D1/ D Q.D2/.
Here, a natural question to ask is the following: Given that a set of views determines a
query, is there an equivalent rewriting of the query using the views and, if so, then in which
language? We discuss this question in this section.
7.2.1
DEFINITIONS AND PRELIMINARIES
Let L be a query language. We say that a subset L1 of L contains almost all the queries in L if the
following holds. We represent L as a disjoint union of sets of queries, called eq-sets, such that
each eq-set contains exactly all the queries in L that are equivalent to each other (i.e., for every
pair of queries coming from a particular eq-set, the queries are equivalent). Then L1 contains
all the queries in L, except those queries that are contained in a ﬁnite number of eq-sets.
Deﬁnition 7.13
Let LQ be a set of queries and V a set of views. Let L be a query language.
We say that L is complete for V-to-LQ rewriting if the following is true for any query Q in LQ:
if V determines Q, then there is an equivalent rewriting of Q using V in the language L .

7.2. DETERMINACY
179
We say that L is almost complete for V-to-LQ rewriting if there exists a subset LQ1 of LQ
that contains almost all the queries in LQ for which L is complete for V-to-LQ1 rewriting.
Deﬁnition 7.14
((Almost) complete language for rewriting)
Let LQ, LV, and L be query languages. We say that L is complete for LV-to-LQ rewriting if
the following is true for any query Q in LQ and any set of views V in LV: If V determines Q,
then there is an equivalent rewriting in L of Q using V (or, in other words, L is complete for
V-to-LQ rewriting).
We say that L is almost complete for LV-to-LQ rewriting if for every set V1 of views from
LV, L is complete for V1-to-LQ rewriting.
The following straightforward result is a good introduction to the concept of determinacy.
Theorem 7.15
If there is an equivalent rewriting of a query Q given a set of views V, then V
determines Q.
Let us denote by CQpath the language of path queries, with the exception of the path
query P1. The proof of the following result sets the stage for Deﬁnitions 7.13 and 7.14.
Theorem 7.16
1. CQ is complete for fP2; P3g-to-CQpath rewriting.
2. CQ is complete for fP3; P4g-to-CQpath1 rewriting, where CQpath1 D (CQpath   fP5g).
3. CQ is amost complete for fP3; P4g-to-CQpath rewriting.
Proof. We provide a detailed proof of part (1). The straightforward reasoning is based on the
observation that any path query Pn, n  2, has an equivalent chain-CQ rewriting using the
views in the set fP2; P3g. Indeed, the rewriting is constructed as follows: If n is an even integer,
then the equivalent rewriting will use the view P2 n=2 times, and if n is odd, then the equivalent
rewriting will use the view P3 once and the view P2 .n   3/=2 times.
The statement “CQ is complete for fP2; P3g-to-CQpath rewriting” means that whenever
the set fP2; P3g determines a query in CQpath, then there is an equivalent rewriting in the
language of CQpath of this path query using this view set. We have proved that for any path
query, there is an equivalent CQpath rewriting. The proof of part (2) follows, and part (3) is a
direct consequence of part (2).

It is interesting to note that the set of views fP3; P4g determines the query P5. Indeed,
the following formula is an equivalent rewriting of P5.X; Y /:
.X; Y / W 9ZŒP4.X; Z/ ^ 8W..P3.W; Z/ ! P4.W; Y //:

180
7. ANSWERING QUERIES USING VIEWS
Note that this formula is not in the language of CQ. Further, there is no CQ equivalent rewriting
of P5 using fP3; P4g, as will be discussed in Proposition 7.21. In the next subsection, we consider
the case in which the set of views is a singleton set, and both the view and the query are path
queries.
7.2.2
PATH QUERIES—SINGLE VIEW
In this subsection we consider the case in which the set of views is a singleton set. We say that
a language L is almost s-complete for LV-to-LQ rewriting if for every view set V1 that contains a
single view from LV, there exists a subset LQ1 of LQ that contains almost all the queries in LQ,
and such that L is s-complete for V1-to-LQ1 rewriting. The deﬁnition of a language L being
s-complete for V1-to-LQ1 rewriting is analogous; it only allows one view in the set of views.
We now set the stage for Theorem 7.17. Let Q be a CQ query with two distinguished
variables that uses only binary relations in its subgoals. Then the set of the query subgoals can
be viewed as a labeled graph. By ignoring the labels and the direction of the edges in this graph,
we obtain an undirected graph Gundirected
Q
. We say that a binary query Q is connected (or is not
disjoint) if there is a path in Gundirected
Q
from one of its distinguished variables to the other.
Theorem 7.17
CQpath is s-complete for CQpath-to-CQpath rewriting.
Proof. For a query Q in CQpath, either Gundirected
Q
is disjoint or it is not. If it is not disjoint,
then the canonical rewriting is an equivalent rewriting. If Gundirected
Q
is disjoint, then V does
not determine Pn. This is a consequence of the following lemma.
Lemma 7.18
Let query Q and views V be CQ chain queries. If the canonical rewriting of Q using
V is disjoint, then V does not determine Q.
Proof. Let database DQ be the canonical database of the query Q. We consider in the set V.DQ/
(from which the canonical rewriting is constructed) the connected components of Gundirected
V.DQ/
.
We refer to any one of those connected components as the connected component that contains
a certain constant from DQ.
Suppose the canonical rewriting of Q using V is disjoint. We construct two databases D0
and D00, such that V.D0/ D V.D00/ and Q.D0/ ¤ Q.D00/. We begin by constructing databases
D1; D2, and D3, each of which is isomorphic to DQ (but see the details below). Then we con-
struct (a) D0 as the union of DQ and D1, and (b) D00 as the union of D2 and D3.
The database D1 is a copy of DQ in which all the constants are replaced by fresh constants.
For ease of reference, we assume that each constant of DQ is replaced in D1 by its primed version,
e.g., c in DQ is replaced in D1 by c0.
Suppose DQ is a simple path from a to b. We construct the database D2 as follows.
Consider an isomorphic image of DQ, with the constants being the same as the corresponding

7.2. DETERMINACY
181
constants in DQ, except that the constants in the connected component of b are replaced by
their corresponding primed versions used in D1. Finally, D3 is the reverse image of D2, in terms
of which constants are used, i.e., if a constant is used in its non-primed version in D2, then it is
used in its primed version in D3, and vice versa. Consider an illustration for query P7 and view
P2. (In this example, node a is represented by node 0 and node b by node 7.)
DQ D f.0; 1/; .1; 2/; .2; 3/; .3; 4/; .4; 5/; .5; 6/; .6; 7/g:
D1 D f.00; 10/; .10; 20/; .20; 30/; .30; 40/; .40; 50/; .50; 60/; .60; 70/g:
D2 D f.0; 10/; .10; 2/; .2; 30/; .30; 4/; .4; 50/; .50; 6/; .6; 70/g:
D3 D f.00; 1/; .1; 20/; .20; 3/; .3; 40/; .40; 5/; .5; 60/; .60; 7/g:
Consider another illustration, this time for query P7 and view P3:
DQ D f.0; 1/; .1; 2/; .2; 3/; .3; 4/; .4; 5/; .5; 6/; .6; 7/g:
D1 D f.00; 10/; .10; 20/; .20; 30/; .30; 40/; .40; 50/; .50; 60/; .60; 70/g:
D2 D f.0; 10/; .10; 2/; .2; 3/; .3; 40/; .40; 5/; .5; 6/; .6; 70/g:
D3 D f.00; 1/; .1; 20/; .20; 30/; .30; 4/; .4; 50/; .50; 60/; .60; 7/g:
We now prove that this construction is correct, i.e., that V.D0/ D V.D00/. Observe that
V.DQ/ \ V.D1/ D ; and V.D2/ \ V.D3/ D ;. The latter claim is not obvious; to prove it, recall
that V.DQ/ is disjoint. This means that the primed versions of constants in D2 appear in facts in
V.D2/ together with other primed versions of constants; the same holds for unprimed versions
of constants in the facts in V.D2/. Indeed, suppose there is a fact that contains a primed and
unprimed version of a constant. This means that the connected component in V.DQ/ that con-
tains b (which is node 7 in our example above) is connected to another connected component in
V.DQ/. This is a contradiction, as it means that the component is not a connected component.
The same observation holds for V.D3/. Since each of V.D0/ and V.D00/ computes the
same number of facts, we have that V.D0/ D V.D00/, where D0 is the union of DQ and D1, and
D00 is the union of D2 and D3. Finally, observe that the fact .0; 7/ is in Q.D0/ but not in Q.D00/.
Thus, this set of views does not determine the query.


7.2.3
PATH QUERIES—CQ IS ALMOST COMPLETE FOR REWRITING
Theorem 7.19
CQ is almost complete for CQpath-to-CQpath rewriting.
This result is a consequence of Lemma 7.20.
Lemma 7.20
Consider query Pn and set of views V=fPk1; Pk2; : : : ; PkKg. Then there is a positive
integer n0 that is a function of k1; k2; : : : ; kK, such that for any n  n0, the following statements are
equivalent.

182
7. ANSWERING QUERIES USING VIEWS
1. There is no equivalent rewriting in CQ of Pn using V;
2. the canonical rewriting of Pn using V is disjoint; and
3. V does not determine Pn.
Proof. We prove (3) ) (1) ﬁrst; this is straightforward, as the existence of an equivalent rewrit-
ing is a witness to determinacy.
The direction (2) ) (3) follows the proof of Lemma 7.18.
The remaining direction is that of (1) ) (2). The proof provided below generalizes the
proof of Theorem 7.16, in the following sense: Since the canonical rewriting R is connected,
there is a path in Gundirected
R
from one distinguished variable to the other. We show that this
path can be used to construct a directed path on the canonical rewriting from one distinguished
variable to the other. Hence, the canonical rewriting is an equivalent rewriting. Note that there
is a ﬁnite number of path queries for which this construction is not possible; these queries are
the queries Pn for all n < n0, where n0 is a positive integer that depends only on the sizes of the
views.
We now prove the direction (1) ) (2), by showing correctness of the following equivalent
statement: If the canonical rewriting is not disjoint, then there exists an equivalent CQ rewriting
of the query.
Because the canonical rewriting is not disjoint, by deﬁnition there is an undirected path
from its start node to its end node. Therefore, †K
iD1xiki D n has an integer solution. The xi’s
are positive integers if the undirected path in the canonical rewriting is traveling toward the
end node, and the solutions are negative otherwise. Here, xi is equal to the number of times
that we consider the path Pki in the canonical rewriting. In the rest of the proof we show that
†K
iD1xiki D n has a positive integer solution for n > n0, where
n0 >
X
i¤qIi;qD1;:::;j
kikq:
This is suﬃcient for constructing a chain CQ rewriting, in which view Pki is used x0
i times,
provided that x0
i is in the positive-integer solution of the above equation. We thus obtain a
CQpath rewriting.
Since †K
iD1xiki D n has an integer solution, the greatest common divisor (GCD) of
k1; : : : kK divides n. (Indeed, if both sides of †K
iD1xiki D n are divided by the GCD, the left-
hand side of the resulting equation is an integer, hence the right-hand side is an integer too,
hence the GCD divides n.) We prove that for n > P
i¤qIi;qD1;:::;K kikq, if the GCD of k1; : : : kK
divides n, then †K
iD1xiki D n has a nonnegative integer solution. We prove it inductively on the
number of ki’s.

7.2. DETERMINACY
183
Inductive hypothesis: For any positive integers k1; : : : kj and for any positive integer m, if
the GCD of k1; : : : kj divides m and
m >
X
i¤qIi;qD1;:::;j
kikq;
(7.1)
then the equation †j
iD1xiki D m has a nonnegative integer solution x0
1; : : : ; x0
j , such that for
any d in f1; 2; : : : ; j g we have that
x0
dkd > m  X
i¤qIi;qD1;:::;j
kikq:
(7.2)
Proof of the inductive hypothesis:
Base Step. For positive integers a1; a2; and b0 such that b0 > a1a2, the Diophantine equa-
tion a1x1 C a2x2 D b0 is known to have a nonnegative integer solution x0
1; x0
2 that satisﬁes
a1x0
1 > b0   a1a2.
Inductive step. Suppose that the inductive hypothesis holds for j   1 ! j. We prove that
it also holds for j ! j C 1. I.e., we prove that for any positive integers k1; : : : kj C1 and any
positive integer p such that the GCD of k1; : : : kj C1 divides p and such that
p >
X
i¤qIi;qD1;:::;j C1
kikq
(7.3)
holds, then the equation †j C1
iD1 xiki D p has a nonnegative integer solution x0
1; : : : ; x0
jC1, such
that for any d in f1; 2; : : : ; j C 1g, we have that
x0
dkd > p  X
i¤qIi;qD1;:::;j C1
kikq:
(7.4)
Without loss of generality, suppose that d D 1. From here on, we assume that k1 D a1 and
k2 D a2. We rewrite the equation as a1x1 C a2x2 D p   †j C1
iD3 xiki. Denoting by b the GCD
of a1 and a2, we obtain .a1=b/x1 C .a2=b/x2 D .p   †j C1
iD3 xiki/=b. We now look for solutions
of p D †j C1
iD3 xiki C bx. Solutions must exist, because the GCD of k3; : : : kj C1; b equals the
GCD of k1; : : : kj C1. (Observe that any common divisor of a1 and a2 must divide b.) Hence,
the GCD divides p. We also have
p > a1a2 C
X
i¤qIi;qD3;:::;j C1
kikq C b
X
iD3;:::;j C1
ki:
(7.5)
(This is due to b < a1 and b < a2.) Hence, according to the inductive hypothesis, p D
†jC1
iD3 xiki C bx has a nonnegative integer solution x0
3; : : : ; x0
j C1; x0, such that
bx0 > p  X
i¤qIi;qD3;:::;j C1
kikq   b
X
iD3;:::;j C1
ki > a1a2:
(7.6)

184
7. ANSWERING QUERIES USING VIEWS
The last inequality holds due to
p > a1a2 C
X
i¤qIi;qD3;:::;j C1
kikq C b
X
iD3;:::;j C1
ki:
(7.7)
We thus obtain .p   †j C1
iD3 x0
i ki/=b D x0. It now suﬃces to show that the equation a1x1 C
a2x2 D bx0 has a nonnegative integer solution x0
1; x0
2, such that a1x0
1 > bx0   a1a2. Observe
that bx0 > a1a2. Further, the GCD of a1; a2 (i.e., b) divides bx0. Hence, a1x1 C a2x2 D bx0
has a nonnegative integer solution x0
1; x0
2, such that a1x0
1 > bx0   a1a2. Hence, a1x0
1 C a2x0
2 D
bx0, and by replacing bx0 we have that a1x0
1 C a2x0
2 D p   †j C1
iD3 x0
i ki. Finally, we show that x0
1
satisﬁes the inequality required in the inductive hypothesis. Indeed, since a1x0
1 > bx0   a1a2,
we obtain
a1x0
1 > bx0   a1a2 >
p  X
i¤qIi;qD3;:::;j C1
kikq   b
X
iD3;:::;j C1
ki   a1a2 > p  X
i¤qIi;qD1;:::;j C1
kikq:
(7.8)

7.2.4
CHAIN QUERIES
The following result gives a simple example of a case in which CQ is not complete for rewriting
a query using a set consisting of two views.
Proposition 7.21
The set of views fP3; P4g determines the query P5. At the same time, there is no
CQ rewriting of P5 using fP3; P4g.
Proof. Let P5.X; Y / :- e.X; Z1/; e.Z1; Z2/; e.Z2; Z3/; e.Z3; Z4/; e.Z4; Y /.
The following formula is an equivalent rewriting of P5:
.X; Y / W 9ZŒP4.X; Z/ ^ 8W..P3.W; Z/ ! P4.W; Y //:
The proof that this is an equivalent rewriting of P5 follows from Theorem 7.22. To see that there
is no CQ rewriting, consider the canonical rewriting
Rc.X; Y / :- P3.X; Z3/; P3.Z1; Z4/; P3.Z2; Y /; P4.X; Z4/; P4.Z1; Y /
of P5. The expansion of Rc is not equivalent to P5.

Theorem 7.22
For the chain conjunctive query
Q.X1; Y / :- r1.X1; X2/; : : : ri 1.Xi 1; Xi/; : : : ; rj  1.Xj 1; Xj /; : : : rn 1.Xn 1; Y /:

7.2. DETERMINACY
185
and set of chain views V = fR2; R3; R4g, where
R2.X1; Xi/ :- r1.X1; X2/; : : : ri 1.Xi 1; Xi/; : : : ; rj 1.Xj  1; Xj /:
R3.Xi; Xj / :- ri.Xi; XiC1/; : : : ; rj  1.Xj  1; Xj /:
R4.Xi; Y / :- ri.Xi; XiC1/; : : : ; rj  1.Xj  1; Xj /; : : : rn 1.Xn 1; Y /:
The following ﬁrst-order formula is an equivalent rewriting of Q using V:
.X; Y / W 9ZŒR2.X; Z/ ^ 8W..R3.W; Z/ ! R4.W; Y //:
Proof. Suppose .a; b/ 2 Q.D/ for database D. By deﬁnition of Q, there must exist a homo-
morphism h from the variables of Q to the constants of D, such that h.X1/ D a and h.Y / D b,
and the facts
r1.h.X1/; h.X2//; : : : ; ri 1.h.Xi 1/; h.Xi//; : : : ;
rj  1.h.Xj  1/; h.Xj //; : : : ; rn 1.h.Xn 1/; h.Y //
are true in D. Hence, .a; h.Xj // 2 R2.D/ holds. Moreover, whenever there exists a homomor-
phism h0 from the variables of R3 to D such that h0.Xj / D h.Xj / and .h0.Xi/; h0.Xj // 2 R3.D/,
deﬁne the homomorphism h00 that (a) coincides with h0 for the variables Xi; : : : Xj, and (b) co-
incides with h for the rest of the variables in the body of R4. Thus, .h00.Xi/; h00.Y // 2 R4.D/.
Hence, the formula .a; b/ is true on V.D/.
For the other direction, suppose .a; b/ holds on V.D/; let c be the witness for Z. This
means that R2.a; c/ holds on V.D/. Thus, there exists a homomorphism h from the variables
of R2 to the constants in D, such that the facts
r1.h.X1/; h.X2//; : : : ; ri 1.h.Xi 1/; h.Xi//; : : : ; rj  1.h.Xj  1/; h.Xj //
are true in D. Hence, R3.h.Xi/; h.Xj // is true. Then, according to , there exists a homomor-
phism h0 such that h0.Xi/ D h.Xi/, so that R4.h0.Xi/; h0.Y //. We deﬁne h00 to coincide with h
for variables X1; : : : ; Xi and to coincide with h0 for the variables XiC1; : : : ; Xn 1; Y . This yields
.a; b/ in Q.D/.



187
C H A P T E R
8
Bibliographical Notes
We begin this chapter by presenting the sources for the original results that have been covered
in detail in this book. We then discuss the related work that either precedes or follows the
development of the results presented in this book; the aims of the discussion include covering
seminal papers that started some of the lines of work, as well as outlining major recent activity
on the topic.
The structure of the rest of this chapter is as follows. In Section 8.1, we discuss the work
focused on investigating the computational complexity of containment tests, for CQs under both
set and bag semantics, as well as for CQACs, CQNs, and aggregate queries. In Section 8.2, we
discuss the papers on query rewritings that originated in the 1990’s, as well as some of the more
recent papers on the topic. In Section 8.3, we ﬁrst mention the papers that pioneered the depen-
dency theory and the chase algorithm, and then, some recent developments. In Section 8.4, we
cite work that has focused on data exchange, the topic that has enjoyed much recent activity; we
discuss in detail some recent and current lines of work. Finally, in Section 8.5, we list recent work
on determinacy, and present the published sources for other theoretical considerations around
the problem of answering queries using views. While our presentation in Sections 8.1–8.5 is
not exhaustive, we make an eﬀort to be representative and to provide pointers to the papers that
showcase major lines of work.
We now initiate the discussion of the published sources of the results that have been
discussed in detail in this book. In reference to the results presented in Section 2.1 on CQ
queries, Chandra and Merlin deﬁned in their 1977 publication [41] the class of conjunctive
queries on relational databases, showed that the containment problem for conjunctive queries is
NP complete, and proved that each conjunctive query has a unique minimal equivalent query.
They also showed that containment mappings can be used for testing containment for this class
of queries.
Some of the algorithms [90, 147] for testing containment for CQAC queries that were
covered in Section 2.2 begin by normalizing the given queries. The containment is then tested by
checking logical implication using multiple containment mappings. Another containment test,
covered in Section 2.2, is based on canonical databases [97, 105]. The homomorphism property
was formally deﬁned in [8], but already observed back in [97].
The test for checking containment between two CQNs, as discussed in Section 2.3, is
described in [138].

188
8. BIBLIOGRAPHICAL NOTES
Sara Cohen’s thesis [44] studied containment and equivalence tests for conjunctive aggre-
gate queries. Section 2.4 presents some of the results of [44].
Acyclic schemas were studied in a series of papers in early work by Beeri and colleagues,
Fagin, and Fagin and colleagues [27, 28, 65, 72]. The containment test presented in Section 2.5
originates from the work [43] by Chekuri and colleagues. It is shown in [43] that testing for
query containment can be done in polynomial time in those cases where the containing query
is acyclic. Algorithms for eﬃcient computation of acyclic joins using semijoins appeared in [34,
146]; the results show that acyclic queries can be evaluated in polynomial time in the sizes of
the input database, of the query, and of the query answer.
The results presented in Section 3.2 are drawn primarily from the work by Levy and col-
leagues [106]. By the results of [106] and [131], for a given query Q there exists a maximally
contained UCQ rewriting, such that each CQ component of the rewriting can have at most as
many subgoals as Q.
The results presented in Section 3.2.3 follow the work of [12]. The results presented in
Section 3.3 follow the work of [43].
In reference to the results presented in Section 3.4, Afrati and colleagues [8] studied the
problem of answering queries using views, where the queries and views are conjunctive queries
with arithmetic comparisons over dense orders. It is shown in [8] that obtaining equivalent
rewritings for conjunctive queries with arithmetic comparisons is decidable.
In reference to the results presented in Section 3.5, Example 3.24 originates from [145].
Further, Afrati and Pavlaki addressed in [13] the problem of rewriting queries using views, for
the case where the queries and views are conjunctive queries with safe negation (CQNs). As
shown in [13], in the case of CQN queries and CQN views without nondistinguished (a.k.a.
existential) variables, ﬁnding equivalent rewritings is decidable in those scenarios where the
rewriting is in the language of CQNs or of unions of CQNs.
The results of Section 3.6 follow Sara Cohen’s work in [44]. The presentation of central
rewritings is from [6].
Section 4.2 presents the results developed in [129] (the MiniCon algorithm) and in [119]
(the SharedVariable algorithm). The earlier bucket algorithm [86, 107] shares the same intuition.
In [8], Afrati and colleagues studied the problem of answering queries using views in the
scenario where the queries and views are conjunctive queries with arithmetic comparisons over
dense orders. The results presented in [8] include a containment test that can be performed in
NP for a special case of CQACs; this test is a reduction to checking for containment of a CQ
query in a Datalog query, where neither query has arithmetic comparisons. Based on this result,
it can be shown that the Datalog query in Example 4.40 is an MCR of the input query in the
language of Datalog. We follow [8] in the presentation of AC-containment in Section 4.3, as
well as in the presentation of the bucket/MS algorithm for the case where the homomorphism
property holds. The results of Section 4.4.3 follow the work [62] by Duschka and Genesereth.

189
Section 5.3 focuses on the problem of ﬁnding equivalent rewritings for the case where
the database schema includes a set of dependencies. Weakly acyclic sets of constraints are in-
troduced in the work by Fagin and colleagues [68]. The concept of a weakly acyclic set of target
dependencies is broad enough to contain as special cases sets of full tuple-generating dependen-
cies (full tgds), as well as acyclic sets of inclusion dependencies. Chase [29, 85, 115] is a useful
tool for reasoning about dependencies, which can also be used for ﬁnding rewritings in presence
of dependencies. That problem was studied in [126], [127], [57], and, [59], as well as in the
work [58] by Deutsch and colleagues.
In Section 5.3 we outlined an algorithm for ﬁnding equivalent rewritings for the case
where the database schema includes a set of dependencies. In Chapter 3 we used the tuple-core
techniques of [11] and [12] to obtain an eﬃcient algorithm for ﬁnding equivalent rewritings in
presence of weakly acyclic sets of local-as-view tuple-generating dependencies. In addition to
the notion of tuple cores, the works [11] and [12] introduced a number of other techniques for
reducing the number of combinations to be considered.
Section 5.4.2 presents work [63] by Duschka and colleagues. The intuition oﬀered in
Example 5.18 is provided by JeﬀUllman.
The results presented in Section 6.1 follow the work [67, 68] by Fagin and colleagues.
[67, 68] formalized the data-exchange setting, and proved that a canonical universal solution can
be computed (if a solution exist) in polynomial time by using the chase procedure [29], provided
the set of target tgds is weakly acyclic. In general, universal solutions may not be unique. Fagin,
Kolaitis, and Popa [69] used the notion of core of a graph or data structure [92], and showed
that the core is also a universal solution, which is in addition the smallest universal solution.
The above setting was generalized by Afrati et al. [9] to include arithmetic comparisons in the
query, as well as in the tgds and egds; these results, presented in Section 6.2, include two chase
algorithms suitable for dealing with arithmetic comparisons: the AC-chase and, for the case
where the homomorphism property holds, the SAC-chase. Section 6.3 presents the work by
Afrati et al. [10] on treating incomplete data.
In presence of incompleteness in the data, it is natural to look for certain answers, that is,
for those query answers that do not depend on the interpretation of the unknown data; this is
discussed in Section 7.1. The concept was ﬁrst formally deﬁned in [114]. Certain answers were
used in [85, 141] as standard semantics in presence of incomplete databases. It then became the
standard semantics of query answering in data integration [104] and data exchange [67]. The
ﬁrst observation about the connection between MCRs and certain answers appeared in [1].
Section 7.2 presents some of the work by Afrati [5] on the topic of determinacy. We
continue the discussion of determinacy later in this current chapter.
Now that we have referenced the works whose results are presented in detail in the ﬁrst
seven chapters of this book, we begin a discussion of the related bibliography and further con-
tributions (to the best of our ability) to the topics discussed in this book. Before we start dis-
cussing the bibliography, let us mention overviews of work in the area, as presented in the

190
8. BIBLIOGRAPHICAL NOTES
survey by Halevy [91] and tutorial by Lenzerini [104], as well as in the book by Doan and
colleagues [61] on principles of data integration. Reference books and textbooks on databases
include [2] and [78].
8.1
QUERY CONTAINMENT
Query evaluation and query containment are related in terms of their complexity results. Barceló
et al. [25] ask the question of whether query-evaluation tractability can help query containment.
Concerning complexity of query evaluation, Vardi in [142] introduced the notions of “data com-
plexity,” “query complexity,” and “combined complexity.” He deﬁned data complexity as the
complexity of evaluating a ﬁxed query on a database instance, expressed as a function of the
size of the database. Combined complexity considers both the query and the database instance
as input variables, and is expressed as a function of their sizes. In this book, unless explicitly
speciﬁed otherwise, we use the term “complexity” to refer to “data complexity.”
8.1.1
QUERY CONTAINMENT—SET SEMANTICS
Chandra and Merlin showed in [41] that the problems of containment, minimization, and
equivalence of conjunctive queries are NP complete. They also presented the containment test
using homomorphisms. For conjunctive queries, restricted classes of queries are known for which
the containment-checking problem is polynomial. For instance, if each database predicate oc-
curs in the contained query at most twice, then the problem can be solved in linear time [134],
but is NP complete if each database predicate occurs at least three times in the body of the
contained query. If the containing query is acyclic, then the containment-checking problem is
polynomial [130].
An eﬃcient algorithm for checking containment between CQNs and unions of CQNs is
given in [145].
Klug [97] showed that the containment-checking problem for the class of conjunctive
queries with arithmetic comparisons is in …P
2 . In the same work, it was also shown that when
only left (or right) semi-interval comparisons are used, the containment-checking problem is
in NP. In a more recent work, Afrati and colleagues [4] showed more classes of conjunctive
queries with arithmetic comparisons for which the problem of query-containment checking is
in NP. Van der Meyden [139] proved Klug’s conjecture that containment for conjunctive queries
with inequality arithmetic comparisons is …P
2 complete; the reductions use only ¤ comparisons.
This result is extended in [101] to use only one ¤ comparison and at most three occurrences of
the same predicate name in the contained query. The same reduction shows that the problem
remains …P
2 complete even in the case where the containing query is acyclic. In fact, Kolaitis
and colleagues [101] proved that the complexity of the containment-checking problem for safe
conjunctive queries with inequalities ranges between coNP and …P
2 completeness, depending on
how many times the name of each database predicate occurs in the body of the contained query.
They also showed that when one of the two queries is ﬁxed, the problem can be DB-complete,

8.1. QUERY CONTAINMENT
191
where DB is the class of all decision problems that are the conjunction of a problem in NP and
a problem in coNP. Koutris and colleagues [103] consider CQ queries with ¤ evaluation and
study combined complexity.
A problem that is related to that of query containment is the problem of the size of a join,
for the case of CQs without nondistinguished variables. This problem has been studied recently
in work by Atserias and colleagues [20, 21].
Van der Meyden [140] addresses complexity of evaluating queries in logical databases
that contain potentially incomplete information about orderings among data points. It is shown
in [140] that, in general, even the data complexity for queries in this setting is intractable; at the
same time, the results include several polynomial-time special cases.
8.1.2
QUERY CONTAINMENT—BAG SEMANTICS, AGGREGATION
The classic foundational work by Chaudhuri and Vardi [42] provides equivalence tests for CQ
bag and bag-set queries; correctness of the tests follows from the results of [47]. Please also
see [46, 51, 52]. Chaudhuri and Vardi [42] also provide a well-known suﬃcient containment
condition for CQ bag queries.
Deﬁnitive results on containment between CQ queries under bag and bag-set semantics
have not been obtained so far. Please see Jayram, Kolaitis, and Vee [96] for original undecid-
ability results on containment of CQ queries with inequalities under bag semantics. The authors
point out that it is not known whether the problem of bag containment for CQ queries is even
decidable. For the case of bag-set semantics, suﬃcient conditions for containment of two CQ
queries can be expressed via containment of (the suitable) aggregate queries with aggregate func-
tion count(*). The latter containment problem can be solved using the methods proposed in [48].
Please see [7, 42] for other results on bag and bag-set containment of CQ queries. The general
problems of containment for CQ bag and bag-set queries remain open.
In her papers [46, 47], Cohen provided an elegant and powerful formalism for treating
queries evaluated under each of set, bag, and bag-set semantics uniformly as special cases of the
more general “combined semantics.” The latter semantics captures user-speciﬁed elimination
of duplicates at intermediate stages of query processing. The papers [46, 47] contain a general
suﬃcient condition for combined-semantics equivalence of CQ queries with disjunction, nega-
tion, and arithmetic comparisons, as well as necessary and suﬃcient equivalence conditions for
special cases. The proof in [47] of its general suﬃcient condition for equivalence of queries is
in terms of containment between the queries under combined semantics. That (implicit) suﬃ-
cient query-containment condition is proved in [47] for the case where the two queries have the
same number of multiset variables. Also, [47] contains an excellent overview of the literature on
query equivalence and containment for query languages that properly contain the language of
CQ queries.

192
8. BIBLIOGRAPHICAL NOTES
Kolaitis [100] presents a comprehensive overview of results on the complexity of the
query-containment problem for conjunctive queries and their variants, under both set semantics
and bag semantics.
Bag containment of unions of conjunctive queries (UCQs) is shown to be undecidable by
Ioannidis and Ramakrishan [95]. The …P
2 hardness result for checking bag containment of CQs
is reported in [42], but the decidability of the problem remains open.
Bag equivalence of UCQs was shown to be decidable (and, similarly to the case of CQs,
was shown to have the same complexity as isomorphism checking) by Cohen et al. [50]; see
also [123].
For aggregate queries, it seems that characterizing query equivalence may be easier than
characterizing query containment. In particular, almost all known results on query containment
for aggregate queries are derived by reduction from query equivalence.
One of the earliest studies of aggregation was by Klug [98], who extended relational al-
gebra and relational calculus to allow aggregate functions and showed the equivalence of these
two languages.
A survey of the containment and equivalence problems for aggregate queries, containing
references to most works on this topic, appears in [45].
The peculiarities of individual aggregate functions make ﬁnding a general solution for the
equivalence and containment problems very diﬃcult. Thus, characterizations for equivalence of
aggregate queries often are deﬁned separately for each aggregate function.
Characterizations have been presented for equivalence of conjunctive queries with the ag-
gregate functions count, sum, max, and count-distinct [49], and these were extended in [50]
to queries with disjunctive bodies. Equivalence of conjunctive queries with aggregate functions
avg and percent were characterized in [87].
Srivastava and colleagues [135] consider the problem of answering queries with aggrega-
tion using views.
8.1.3
ACYCLICITY
Papadimitriou et al. [124] show lower complexity upper bounds for query evaluation for the
extension of conjunctive acyclic queries with ¤ (but not <) inequalities.
Maier et al. [116] show that it is NP complete to determine whether the result of a join
(CQ) is nonempty.
[75] and [81] consider evaluation based on tree decomposition, in ways similar to decom-
position for acyclic queries.
Barceló and colleagues [26] study semantic acyclicity on graph databases.
8.2
QUERY REWRITING
The problem of determining whether there exists an equivalent rewriting of a query using views
was ﬁrst studied by Halevy and colleagues [106]. It is shown in this work that it is NP complete to

8.2. QUERY REWRITING
193
decide whether a given CQ has an equivalent rewriting that is a conjunctive query using a given
set of CQ views. This problem was further investigated in many works, including [12, 84, 106].
In [84], the notion of tuple core is extended to tuple coverage, with the objective of ﬁnding
a minimal (rather than maximal) cover of the query’s subgoals when using view tuples to ﬁnd
equivalent rewritings of a conjunctive query using CQ views. In addition, the notion of tuple
coverage is used in [84] for ﬁnding equivalent rewritings for conjunctive queries with aggregation
using views that are also conjunctive queries with aggregation.
[3, 8, 119, 129] present algorithms for ﬁnding maximally contained rewritings for queries
and views that are conjunctive queries with or without arithmetic comparisons. [62, 64] presents
the inverse-rule algorithm for the problem of ﬁnding maximally contained rewritings in the ab-
sence of dependencies. [63] presents a modiﬁcation of the inverse-rule algorithm to address the
same problem in presence of functional or full dependencies. The algorithm creates a Datalog
program, similarly to the case in which no dependencies are present, and then adds extra rules
that simulate chasing the query with the dependencies. It is noted in [63] that this particular
extension of the inverse-rule algorithm would not work in settings that involve inclusion de-
pendencies that are not full. The reason is, the existential variables introduced by the algorithm
may create new skolem terms recursively, which could lead to nontermination of the semi-naive
evaluation of the resulting Datalog program. Fan and colleagues [73] study equivalent query
rewritings for queries with inequalities.
Koch [99] presents an algorithm that ﬁnds maximally contained rewritings in presence
of dependencies belonging to the class of conjunctive inclusion dependencies. Dependencies in
this class are essentially GLAV mappings viewed as dependencies. The algorithm introduced
in [99] is sound but not complete, and can be seen as an extension of the inverse-rule algorithm
of [63].
Calì and colleagues [37] study the problem of creating maximally contained rewritings
in global-as-view data-integration systems in presence of inclusion dependencies and key con-
straints. It is shown in [37] that the problem is undecidable both in the general case and in the
case where inclusion dependencies are present together with key constraints. [37] also intro-
duces a sound and complete algorithm for the case of inclusion dependencies and in presence
of key constraints together with inclusion dependencies, belonging to the class that the authors
call “non key conﬂicting inclusion dependencies.” The main idea of the algorithm is extended
in [36] to GLAV data-integration systems in presence of tuple-generating dependencies.
Additional work on related problems includes [22, 89]. Bai and colleagues [22] propose
a modiﬁcation of the MiniCon algorithm for the problem of ﬁnding contained rewritings in
presence of inclusion dependencies. The algorithm chases the query and the views with the
dependencies, and then applies a version of MiniCon that utilizes the new view and query sub-
goals. Gryz [89] proposes an algorithm that ﬁnds equivalent rewritings in presence of inclusion
dependencies. The algorithm ﬁrst undoes all the chase steps that may have been applied to the
query, and then uses the inclusion dependencies in ﬁnding for each atom in the query equiv-

194
8. BIBLIOGRAPHICAL NOTES
alent replacement atoms. [89] also presents a modiﬁcation of the algorithm that ﬁnds all the
contained rewritings.
Other related work includes the paper [108] by Levy and colleagues, which considers CQ
queries in presence of inﬁnite sets of views. Deutsch and colleagues [58] consider the problem in
presence of dependencies. The problem in presence of binding patterns is considered in [131].
8.2.1
BINDING PATTERNS
A setting related to that of answering queries using views is the setting in which views are ex-
pressed by restrictions on the access possibilities of the relations, instead of being expressed by
queries. These restrictions are usually given by access (binding) patterns, which specify which po-
sitions in a retrieved relational tuple are free and which are bound. A solution is then a query
plan, which speciﬁes an order in which relations should be accessed, so that the previously ac-
cessed relations oﬀer the bindings to the attributes for the relations to be accessed later. Work
on this topic was started by Rajaraman and colleagues [131], and was followed by Li and col-
leagues [109, 111, 112]. More recent work on this subject has been done by Benedikt and col-
leagues [23, 30, 31, 31, 32, 33], as well as by Deutsch and colleagues [54].
Work by Duschka and colleagues [63] on recursive plans for data integration presents
the inverse-rule method for the case of answering views in presence of dependencies and access
patterns.
The work by Barcelo and colleagues [24] focuses on approximations of conjunctive queries
that are guaranteed to return correct answers. The results in the paper focus on acyclic approxi-
mations, due to acyclic CQs having good complexity properties for various related problems.
Containment of pattern-based queries is studied by David and colleagues in [53]. Fan and
colleagues [74] study answering pattern queries using views.
Ileana and colleagues [93] apply the Chase-Backchase (CB) algorithm to query rewriting
under dependencies, using the concepts of canonical rewriting and universal solution or plan.
This work improves on inspecting all possible minimal rewritings by using provenance.
The recent book by Benedikt and colleagues [30] provides an interpolation-based per-
spective on query reformulation.
8.3
DEPENDENCIES—THE CHASE
Chase was ﬁrst deﬁned and used to address the problem of checking whether a given dependency
is implied by other dependencies [116, 143]; early chase algorithms address this problem. Algo-
rithms that are precursors to chase appear in [14, 15]. The term “chase” appeared ﬁrst in [115].
The work [29] uniﬁed the theory of the implication problem for various dependency classes,
by introducing chase for tuple-generating and equality-generating dependencies. Extensions of
chase, including extensions to XML, are discussed in [55, 56, 60].

8.4. DATA EXCHANGE
195
8.4
DATA EXCHANGE
The problem of data exchange is the problem of exchanging data between databases with dif-
ferent schemas, in such a way that all the dependencies speciﬁed in the setting are satisﬁed. The
data-exchange problem is related to the data-integration problem. In data exchange, however,
the focus is on materializing a target instance (i.e., a solution) that reﬂects the source data as
accurately as possible. In contrast, in data integration the focus is on answering queries posed
over the target schema using views that express the relationship between the target and source
schemas.
A book on foundations of data exchange Arenas and colleagues [16] contains extensive
examples, exposition on data exchange for relational and XML data, as well as recent work on
mapping compositions and inverting schema mappings.
Kolaitis and colleagues show [102] that relaxing the weak-acyclicity assumption for de-
pendencies, even in a minimal way, leads to the existence-of-solution problem becoming unde-
cidable.
Systems supporting data exchange have been developed, such as Clio by IBM Al-
maden [118, 128].
Gottlob and colleagues [80, 82] extended results on the core produced by chase in a
data-exchange setting. [137] uses concepts and intuition from data exchange with arithmetic
comparisons to study the problem of data exchange with arithmetic operations. In this setting,
dependencies may include arithmetic formulas; the study covers the complexity of the existence-
of-solutions problem for several cases of the setting, as well as the data complexity of computing
certain answers for CQ queries with arithmetic operations. Libkin [113] studies data-exchange
solutions under the closed-world assumption (CWA). Work that studies combined complexity
of data exchange appears in [102], schema-mapping composition is studied in [70, 120], and
schema-mapping inversion is considered in [19, 66].
Other work on settings that are similar to data exchange is done by Bernstein and Mel-
nik [35]. Extensions of the data-exchange setting to XML data exchange have been studied
in, e.g., [17, 60]. Extensions to peer data exchange are discussed in [77]. Universal solutions,
which are the preferred solutions to materialize in data exchange, are closely related to strongly-
universal models [56].
The seminal work by Imielinski and Lipski [94] on incomplete data is highly cited and
has often been an inspiration. Many of the subsequent work, including the results presented in
this book, can be seen as extensions of that work. Recent work on incomplete data includes the
papers [18, 71] on data exchange, as well as the work by Sundarmurthy and colleagues [136]
on the complexity of computing certain answers and possible answers on m-tables, which are
extensions of conditional tables in [94].

196
8. BIBLIOGRAPHICAL NOTES
8.5
OTHER RELATED WORK
We ﬁrst present work about determinacy, and then highlight some considerations, most of which
have been discussed in recent work.
8.5.1
DETERMINACY
The deﬁnition of determinacy in this book is as it ﬁrst appears in Nash and colleagues [122].
Determinacy and related notions have also been investigated in [38, 39, 88]. Grumbach and
colleagues introduce in [88] the notion of subsumption and use it to deﬁne complete rewritings.
Calvanese and colleagues introduce in [38, 39] the concept of lossless view with respect to a
query; this notion is investigated in [38, 39] for regular-path queries, under both the sound-
view assumption and the exact-view assumption. Losslessness under the exact-view assumption
is identical to determinacy.
Afrati and colleagues show [5] that for chain queries and views, the views determine
the query if and only if the canonical rewriting is connected. In this case, there is a ﬁrst-order
equivalent rewriting of the query using the views. Afrati [5] shows that the language for chain
CQs is almost complete for CQpath-to-CQpath rewriting and that the language of ﬁrst-order
logic is complete for CQchain-to-CQchain rewriting, where CQchain is the language of chain
CQs. [5] also shows that in the cases where the set of views is a singleton set, CQchain is
complete for CQchain-to-CQchain rewriting. Pasaila [125] extended the work [5] beyond chain
queries, to include more general queries that can be represented by graphs over binary relational
schemas. The work by Francis [76] extended the results presented in Section 7.2 by allowing
disjunction.
Work done by Nash and colleagues [121, 122] includes the following results. First-order
logic (FO) is not complete for FO-to-FO rewriting, in fact, any language complete for FO-to-
FO rewriting must express all computable queries. FO is not complete for 9FO-to-FO rewrit-
ing, but both 9SO and 8SO are complete for such rewriting. Datalog¤ is not complete for
UCQ-to-UCQ rewriting, where UCQ stands for the language of ﬁnite unions of conjunctive
queries. This also holds for CQ¤-to-CQ rewriting. No monotonic language is complete for
CQ-to-CQ rewriting. (Each of CQ¤, UCQ, and Datalog¤ is a monotonic language.) Deter-
minacy is undecidable for UCQ views and queries. Marx in [117] identiﬁes a language, called
packed fragment of FO (PackedFO), that is complete for rewriting for views and queries in the
same language. PackedFO is a generalization of the guarded fragment of FO. The guarded CQs
are exactly the acyclic CQs.
Gogacz and Marcinkowski [79] prove that conjunctive-query determinacy is undecidable
both in the ﬁnite and inﬁnite cases.

8.5. OTHER RELATED WORK
197
8.5.2
MORE RECENT RELATED WORK
A signiﬁcant number of results have been obtained in the direction of understanding various
challenges in the problem of answering queries using views. We present some of these results,
which focus on deﬁning notions and concepts toward addressing the challenges.
The work by Li and colleagues [110] considers the problem of minimizing the number of
given views in ways that would retain the query-answering power enabled by the views.
Rosati [132] provides decidability, undecidability, and complexity results for query an-
swering in description logics. Rosati [133] studies query answering in presence of dependencies
under the open-world assumption (OWA), to isolate cases in which OWA query answering over
ﬁnite databases coincides with OWA query answering over inﬁnite databases—such cases are
referred to as ﬁnitely controllable. The paper establishes ﬁnite controllability for containment of
conjunctive queries under arbitrary inclusion dependencies, as well as under key and foreign-key
dependencies. The results are based on chase, including a modiﬁcation called canonical chase.
Cao and colleagues [40] consider view-based “bounded” rewritings, which are rewritings
that are allowed to access a small fraction of the original database in addition to the view instance.
In [40], the problem is considered for data sets that satisfy access constraints.
Gottlob and colleagues [83] consider the problems of query rewriting and query optimiza-
tion for ontological queries. Such queries are evaluated against knowledge bases, which consist
of extensional databases and associated ontologies represented by assertions and dependencies.
Regular queries and rewritings for them have been studied in the past two decades;
see [144] and references therein. Intuitively, regular queries can be thought of as regular-
language queries on graphs. Unlike general queries, regular queries have decidable query-
containment properties.


199
C H A P T E R
9
Conclusion
What we covered in this book can be arranged along the following four axes that cut across
chapters.
A. (Existence of rewritings in various query languages) This book began by giving basic def-
initions for the notions of query containment, equivalent rewriting, contained rewriting, and
maximally contained rewriting (MCR). Existence of equivalent rewritings and of MCRs de-
pends on the language of the rewriting. In particular, we saw the following.
• For CQ queries and views, equivalent rewritings may not exist in the language of unions
of CQs, but could still be found in ﬁrst-order logic. In contrast, this setting always allows
for existence of MCRs in the language of unions of CQs.
• For CQAC queries and views, there exist MCRs in the language of unions of CQACs
in all the cases in which the homomorphism property holds. In those cases where the
homomorphism property does not hold, ﬁnding MCRs may require a query language
with the power of recursion. That is, MCRs in these scenarios may not always exist in the
language of unions of CQACs.
• For CQ queries and views that are unions of CQs, ﬁnding MCRs may require a query
language with the power of recursion.
• For Datalog queries and CQ views, MCRs always exist in the language of Datalog.
• In presence of constraints on data that are tuple-generating and equality-generating de-
pendencies, ﬁnding MCRs may require recursion even in the case of CQ queries and views,
and even if all the constraints are equality-generating dependencies.
B. (Certain answers) We deﬁne certain answers, a concept independent of the language of
the rewritings. Certain answers are deﬁned both under the open and closed world assumptions
(OWA and CWA, respectively). We showed that CQ contained rewritings for CQ queries and
views coincide under the OWA and the CWA. At the same time, a contained rewriting in a
non-monotone query language (e.g., ﬁrst-order logic) under the CWA is not always a contained
rewriting under the OWA. We showed that for CQ queries and views, MCRs in the language
of unions of CQs can ﬁnd all the certain answers under the OWA.
The data-exchange setting uses tuple-generating and equality-generating dependencies,
rather than queries as views, to deﬁne the relationship between the source instance and the target

200
9. CONCLUSION
instance. Rather than being done via rewritings, certain answers are computed by applying the
query on the target instance that is produced from the source instance using the dependencies.
C. (Algorithms ) This book provided eﬃcient algorithms for the following problems.
• Testing query containment for CQ, CQAC, CQN, and aggregate queries, as well as for
a subclass of CQs called acyclic queries. Algorithms for containment tests are based on
homomorphisms, containment mappings, and canonical databases.
• Finding equivalent rewritings for queries using views for CQs, CQACs, and aggregate
queries. The algorithms are based on query containment and on the concept of expansion
of a rewriting. We discussed CQN queries, including the concept of expansion in this
case.
• Finding maximally contained rewritings for queries using views for CQs, CQACs, as well
as for the case of Datalog queries and CQ views. The algorithms are based on expansions
and their properties. We presented the MS algorithm for the cases of CQs and of CQACs
with the homomorphismproperty. We also presented the inverse-rule algorithm for Dat-
alog queries. Further, we observed that in the case of CQ queries and of views that are
unions of CQs, as well as in the case of CQAC queries, ﬁnding MCRs requires recursion.
• We revisited the above three problems, and provided algorithms, for the cases in which the
data satisfy constraints that are tuple-generating and equality-generating dependencies.
Considering the concept of the chase and its properties was central in the presentation
here.
• In the data-exchange setting, algorithms for ﬁnding certain answers were presented for
three cases.
(a) The case in which the constraints are tuple-generating and equality-generating depen-
dencies. The chase is central in this case.
(b) The case in which the constraints are tuple-generating and equality-generating depen-
dencies with arithmetic comparisons. The AC-chase and SAC-chase are central in this
case.
(c) The case in which the constraints are tuple-generating and equality-generating depen-
dencies, and the input data are incomplete. The chase is central in this case.
D. (Advanced topics) In the context of further exploring the subject of answering queries
using views, we studied determinacy and proved various noteworthy and insightful results.

201
Bibliography
[1] S. Abiteboul and O. M. Duschka.
Complexity of answering queries using materi-
alized views.
In Proc. of the 17th ACM SIGACT-SIGMOD-SIGART Symposium on
Principles of Database Systems, pages 254–263, Seattle, WA, June 1–3, 1998. DOI:
10.1145/275487.275516. 189
[2] S. Abiteboul, R. Hull, and V. Vianu. Foundations of Databases. Addison-Wesley, 1995.
190
[3] F. Afrati, C. Li, and P. Mitra. Answering queries using views with arithmetic compar-
isons. In PODS, Proc. of the 21st ACM SIGMOD-SIGACT-SIGART Symposium on Princi-
ples of Database Systems, pages 209–220, New York, 2002. DOI: 10.1145/543613.543641.
193
[4] F. Afrati, C. Li, and P. Mitra. On containment of conjunctive queries with arithmetic
comparisons. In EDBT, 2004. DOI: 10.1007/978-3-540-24741-8_27. 190
[5] F. N. Afrati. Determinacy and query rewriting for conjunctive queries and views. Theoret-
ical Computer Science, 412(11):1005–1021, 2011. DOI: 10.1016/j.tcs.2010.12.031. 189,
196
[6] F. N. Afrati and R. Chirkova.
Selecting and using views to compute aggre-
gate queries.
Journal of Computer and System Sciences, 77(6):1079–1107, 2011. DOI:
10.1016/j.jcss.2010.10.003. 188
[7] F. N. Afrati, M. Damigos, and M. Gergatsoulis.
Query containment under bag
and bag-set semantics.
Information Processing Letters, 110(10):360–369, 2010. DOI:
10.1016/j.ipl.2010.02.017. 191
[8] F. N. Afrati, C. Li, and P. Mitra.
Rewriting queries using views in the presence of
arithmetic comparisons.
Theoretical Computer Science, 368(1-2):88–123, 2006. DOI:
10.1016/j.tcs.2006.08.020. 187, 188, 193
[9] F. N. Afrati, C. Li, and V. Pavlaki.
Data exchange in the presence of arith-
metic comparisons.
In EDBT, Proc. of the 11th International Conference on Extend-
ing Database Technology, pages 487–498, Nantes, France, March 25–29, 2008. DOI:
10.1145/1352431.1352491. 189

202
BIBLIOGRAPHY
[10] F. N. Afrati, C. Li, and V. Pavlaki.
Data exchange: Query answering for in-
complete data sources.
In 3rd International ICST Conference on Scalable Informa-
tion Systems, INFOSCALE, page 6, Vico Equense, Italy, June 4–6, 2008. DOI:
10.4108/icst.infoscale2008.3476. 189
[11] F. N. Afrati, C. Li, and J. D. Ullman. Generating eﬃcient plans for queries using views.
In SIGMOD, Proc. of the ACM SIGMOD International Conference on Management of Data,
pages 319–330, New York, 2001. DOI: 10.1145/376284.375705. 189
[12] F. N. Afrati, C. Li, and J. D. Ullman.
Using views to generate eﬃcient evaluation
plans for queries. Journal of Computer and System Sciences, 73(5):703–724, 2007. DOI:
10.1016/j.jcss.2006.10.019. 188, 189, 193
[13] F. N. Afrati and V. Pavlaki. Rewriting queries using views with negation. AI Communi-
cations, 19(3):229–237, 2006. 188
[14] A. V. Aho, C. Beeri, and J. D. Ullman. The theory of joins in relational databases. ACM
Transactions on Database Systems, 4(3):297–314, 1979. DOI: 10.1145/320083.320091.
194
[15] A. V. Aho, Y. Sagiv, and J. D. Ullman.
Eﬃcient optimization of a class of rela-
tional expressions. ACM Transactions on Database Systems, 4(4):435–454, 1979. DOI:
10.1145/320107.320112. 194
[16] M. Arenas, P. Barceló, L. Libkin, and F. Murlak. Foundations of Data Exchange. Cam-
bridge University Press, 2014. DOI: 10.1017/cbo9781139060158. 195
[17] M. Arenas and L. Libkin. XML data exchange: Consistency and query answering. Jour-
nal of the ACM, 55(2):7:1–7:72, 2008. DOI: 10.1145/1346330.1346332. 195
[18] M. Arenas, J. Pérez, and J. L. Reutter. Data exchange beyond complete data. Journal of
the ACM, 60(4):28:1–28:59, 2013. DOI: 10.1145/2508028.2505985. 195
[19] M. Arenas, J. Pérez, J. L. Reutter, and C. Riveros. Inverting schema mappings: Bridging
the gap between theory and practice. Proc. of the VLDB Endowment, 2(1):1018–1029,
2009. DOI: 10.14778/1687627.1687742. 195
[20] A. Atserias, M. Grohe, and D. Marx. Size bounds and query plans for relational joins. In
49th Annual IEEE Symposium on Foundations of Computer Science, FOCS, pages 739–748,
Philadelphia, PA, October 25–28, 2008. DOI: 10.1109/focs.2008.43. 191
[21] A. Atserias, M. Grohe, and D. Marx. Size bounds and query plans for relational joins.
SIAM Journal of Computer, 42(4):1737–1767, 2013. DOI: 10.1137/110859440. 191

BIBLIOGRAPHY
203
[22] Q. Bai, J. Hong, and M. F. McTear.
Query rewriting using views in the presence
of inclusion dependencies.
In WIDM, Proc. of the 5th ACM International Workshop
on Web Information and Data Management, pages 134–138, New York, 2003. DOI:
10.1145/956699.956729. 193
[23] V. Bárány, M. Benedikt, and P. Bourhis. Access patterns and integrity constraints revis-
ited. In Proc. of the Joint EDBT/ICDT Conferences, ICDT, pages 213–224, Genoa, Italy,
March 18–22, 2013. DOI: 10.1145/2448496.2448522. 194
[24] P. Barceló, L. Libkin, and M. Romero. Eﬃcient approximations of conjunctive queries.
SIAM Journal of Computer, 43(3):1085–1130, 2014. DOI: 10.1137/130911731. 194
[25] P. Barceló, M. Romero, and M. Y. Vardi. Does query evaluation tractability help query
containment? In Proc. of the 33rd ACM SIGMOD-SIGACT-SIGART Symposium on Prin-
ciples of Database Systems, PODS, pages 188–199, Snowbird, UT, June 22–27, 2014. DOI:
10.1145/2594538.2594553. 190
[26] P. Barceló, M. Romero, and M. Y. Vardi. Semantic acyclicity on graph databases. SIAM
Journal of Computer, 45(4):1339–1376, 2016. DOI: 10.1137/15m1034714. 192
[27] C. Beeri, R. Fagin, D. Maier, A. Mendelzon, J. Ullman, and M. Yannakakis. Properties
of acyclic database schemes. In Proc. of the 13th Annual ACM Symposium on Theory of
Computing, STOC, pages 355–362, New York, 1981. DOI: 10.1145/800076.802489. 188
[28] C. Beeri, R. Fagin, D. Maier, and M. Yannakakis. On the desirability of acyclic database
schemes. Journal of the ACM, 30(3):479–513, 1983. DOI: 10.1145/2402.322389. 188
[29] C. Beeri and M. Y. Vardi. A proof procedure for data dependencies. Journal of the ACM,
31(4):718–741, 1984. DOI: 10.1145/1634.1636. 189, 194
[30] M. Benedikt, J. Leblay, B. ten Cate, and E. Tsamoura.
Generating Plans
from Proofs: The Interpolation-based Approach to Query Reformulation.
Synthe-
sis Lectures on Data Management. Morgan & Claypool Publishers, 2016. DOI:
10.2200/s00703ed1v01y201602dtm043. 194
[31] M. Benedikt, J. Leblay, and E. Tsamoura. Querying with access patterns and integrity
constraints. PVLDB, 8(6):690–701, 2015. DOI: 10.14778/2735703.2735708. 194
[32] M. Benedikt, B. ten Cate, and E. Tsamoura.
Generating low-cost plans from
proofs.
In Proc. of the 33rd ACM SIGMOD-SIGACT-SIGART Symposium on Princi-
ples of Database Systems, PODS, pages 200–211, Snowbird, UT, June 22–27, 2014. DOI:
10.1145/2594538.2594550. 194
[33] M. Benedikt, B. ten Cate, and E. Tsamoura.
Generating plans from proofs.
ACM
Transactions on Database Systems, 40(4):22:1–22:45, 2016. DOI: 10.1145/2847523. 194

204
BIBLIOGRAPHY
[34] P. A. Bernstein and D. W. Chiu. Using semi-joins to solve relational queries. Journal of
the ACM, 28(1):25–40, 1981. DOI: 10.1145/322234.322238. 188
[35] P. A. Bernstein and S. Melnik. Model management 2.0: Manipulating richer mappings.
In Proc. of the ACM SIGMOD International Conference on Management of Data, pages 1–
12, Beijing, China, June 12–14, 2007. DOI: 10.1145/1247480.1247482. 195
[36] A. Calì. Query answering by rewriting in GLAV data integration systems under con-
straints. In SWDB, pages 167–184, 2004. DOI: 10.1007/978-3-540-31839-2_13. 193
[37] A. Calì, D. Lembo, and R. Rosati. Query rewriting and answering under constraints in
data integration systems. In IJCAI, pages 16–21, MK, 2003. 193
[38] D. Calvanese, G. D. Giacomo, M. Lenzerini, and M. Y. Vardi. Lossless regular views.
In PODS, pages 99–108, ACM, 2002. DOI: 10.1145/543613.543646. 196
[39] D. Calvanese, G. D. Giacomo, M. Lenzerini, and M. Y. Vardi. View-based query pro-
cessing: On the relationship between rewriting, answering and losslessness. In Interna-
tional Conference on Database Theory (ICDT), pages 321–336, 2005. DOI: 10.1007/978-
3-540-30570-5_22. 196
[40] Y. Cao, W. Fan, F. Geerts, and P. Lu.
Bounded query rewriting using views.
In
Proc. of the 35th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database
Systems, PODS, pages 107–119, San Francisco, CA, June 26–July 01, 2016. DOI:
10.1145/2902251.2902294. 197
[41] A. K. Chandra and P. M. Merlin. Optimal implementation of conjunctive queries in
relational data bases. In Proc. of the 9th Annual ACM Symposium on Theory of Computing,
pages 77–90, Boulder, CO, May 4–6, 1977. DOI: 10.1145/800105.803397. 187, 190
[42] S. Chaudhuri and M. Y. Vardi. Optimization of Real conjunctive queries. In Proc. of
the 12th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems,
pages 59–70, Washington, DC, May 25–28, 1993. DOI: 10.1145/153850.153856. 191,
192
[43] C. Chekuri and A. Rajaraman. Conjunctive query containment revisited. In Proc. of
the Database Theory, ICDT, 6th International Conference, pages 56–70, Delphi, Greece,
January 8–10, 1997. DOI: 10.1007/3-540-62222-5_36. 188
[44] S. Cohen. Equivalence, Containment and Rewriting of Aggregate Queries. Ph.D. thesis,
Hebrew University, 2004. 188
[45] S. Cohen. Containment of aggregate queries. SIGMOD Record, 34(1):77–85, 2005.
DOI: 10.1145/1058150.1058170. 192

BIBLIOGRAPHY
205
[46] S. Cohen.
Equivalence of queries combining set and bag-set semantics.
In Proc. of
the 25th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems,
pages 70–79, Chicago, IL, June 26–28, 2006. DOI: 10.1145/1142351.1142362. 191
[47] S. Cohen. Equivalence of queries that are sensitive to multiplicities. VLDB Journal,
18(3):765–785, 2009. DOI: 10.1007/s00778-008-0122-1. 191
[48] S. Cohen, W. Nutt, and Y. Sagiv. Containment of aggregate queries. In Proc. of the
Database Theory, ICDT, 9th International Conference, pages 111–125, Siena, Italy, January
8–10, 2003. DOI: 10.1007/3-540-36285-1_8. 191
[49] S. Cohen, W. Nutt, and Y. Sagiv. Deciding equivalences among conjunctive aggregate
queries. Journal of the ACM, 54(2):5, 2007. DOI: 10.1145/1219092.1219093. 192
[50] S. Cohen, W. Nutt, and A. Serebrenik.
Rewriting aggregate queries using views.
In Proc. of the 18th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of
Database Systems, pages 155–166, Philadelphia, PA, May 31–June 2, 1999. DOI:
10.1145/303976.303992. 192
[51] S. Cohen and Y. Y. Weiss. Bag equivalence of XPath queries. In Proc. of the Database The-
ory, ICDT, 13th International Conference, pages 116–128, Lausanne, Switzerland, March
23–25, 2010. DOI: 10.1145/1804669.1804685. 191
[52] S. Cohen and Y. Y. Weiss.
Bag equivalence of tree patterns.
ACM Transactions on
Database Systems, 36(4):24, 2011. DOI: 10.1145/2043652.2043657. 191
[53] C. David, A. Gheerbrant, L. Libkin, and W. Martens. Containment of pattern-based
queries over data trees. In Proc. of the Joint EDBT/ICDT Conferences, ICDT, pages 201–
212, Genoa, Italy, March 18–22, 2013. DOI: 10.1145/2448496.2448521. 194
[54] A. Deutsch, B. Ludäscher, and A. Nash. Rewriting queries using views with access pat-
terns under integrity constraints. In Proc. of the Database Theory, ICDT, 10th International
Conference, pages 352–367, Edinburgh, UK, January 5–7, 2005. DOI: 10.1007/978-3-
540-30570-5_24. 194
[55] A. Deutsch, B. Ludäscher, and A. Nash. Rewriting queries using views with access pat-
terns under integrity constraints. Theoretical Computer Science, 371(3):200–226, 2007.
DOI: 10.1016/j.tcs.2006.11.008. 194
[56] A. Deutsch, A. Nash, and J. B. Remmel.
The chase revisited.
In Proc. of
the 27th ACM SIGMOD-SIGACT-SIGART, Symposium on Principles of Database Sys-
tems, PODS, pages 149–158, Vancouver, BC, Canada, June 9–11, 2008. DOI:
10.1145/1376916.1376938. 194, 195

206
BIBLIOGRAPHY
[57] A. Deutsch, L. Popa, and V. Tannen. Physical data independence, constraints, and opti-
mization with universal plans. In VLDB, Proc. of the 25th International Conference on Very
Large Data Bases, pages 459–470, Edinburgh, Scotland, UK, September 7–10, 1999. 189
[58] A. Deutsch, L. Popa, and V. Tannen. Query reformulation with constraints. SIGMOD
Record, 35(1):65–73, 2006. DOI: 10.1145/1121995.1122010. 189, 194
[59] A. Deutsch and V. Tannen. Reformulation of XML Queries and Constraints. In ICDT,
pages 225–241, 2003. DOI: 10.1007/3-540-36285-1_15. 189
[60] A. Deutsch and V. Tannen. XML queries and constraints, containment and reformula-
tion. Theoretical Computer Science, 336(1):57–87, 2005. DOI: 10.1016/j.tcs.2004.10.032.
194, 195
[61] A. Doan, A. Y. Halevy, and Z. G. Ives. Principles of Data Integration. Morgan Kaufmann,
2012. 190
[62] O. M. Duschka and M. R. Genesereth. Answering recursive queries using views. In
Proc. of the 16th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database
Systems, pages 109–116, Tucson, AZ, May 12–14, 1997. DOI: 10.1145/263661.263674.
188, 193
[63] O. M. Duschka, M. R. Genesereth, and A. Y. Levy. Recursive query plans for data
integration.
Journal of Logic Programming, 43(1):49–73, 2000. DOI: 10.1016/s0743-
1066(99)00025-4. 189, 193, 194
[64] O. M. Duschka and A. Y. Levy. Recursive plans for information gathering. In IJCAI
(1), pages 778–784, 1997. 193
[65] R. Fagin. Degrees of acyclicity for hypergraphs and relational database schemes. Journal
of the ACM, 30(3):514–550, July 1983. DOI: 10.1145/2402.322390. 188
[66] R. Fagin. Inverting schema mappings. ACM Transactions on Database Systems, 32(4):25,
2007. DOI: 10.1145/1292609.1292615. 195
[67] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data exchange: Semantics and query
answering. In International Conference on Database Theory (ICDT), pages 207–224, 2003.
DOI: 10.1007/3-540-36285-1_14. 189
[68] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa.
Data exchange: Seman-
tics and query answering.
Theoretical Computer Science, 336(1):89–124, 2005. DOI:
10.1016/j.tcs.2004.10.033. 189
[69] R. Fagin, P. G. Kolaitis, and L. Popa. Data exchange: Getting to the core. ACM Trans-
actions on Database Systems, 30(1):174–210, 2005. DOI: 10.1145/1061318.1061323. 189

BIBLIOGRAPHY
207
[70] R. Fagin, P. G. Kolaitis, L. Popa, and W. C. Tan. Composing schema mappings: Second-
order dependencies to the rescue. ACM Transactions on Database Systems, 30(4):994–
1055, 2005. DOI: 10.1145/1114244.1114249. 195
[71] R. Fagin, P. G. Kolaitis, L. Popa, and W. C. Tan. Reverse data exchange: Coping with
nulls. In Proc. of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles
of Database Systems, PODS, pages 23–32, Providence, RI, June 19–July 1, 2009. DOI:
10.1145/1966385.1966389. 195
[72] R. Fagin, A. O. Mendelzon, and J. D. Ullman. A simpliﬁed universal relation assumption
and its properties. ACM Transactions on Database Systems, 7(3):343–360, 1982. DOI:
10.1145/319732.319735. 188
[73] W. Fan, F. Geerts, W. Gelade, F. Neven, and A. Poggi. Complexity and composition
of synthesized web services. In Proc. of the 27th ACM SIGMOD-SIGACT-SIGART Sym-
posium on Principles of Database Systems, PODS, pages 231–240, Vancouver, BC, Canada,
June 9–11, 2008. DOI: 10.1145/1376916.1376949. 193
[74] W. Fan, X. Wang, and Y. Wu.
Answering pattern queries using views.
IEEE Transactions on Knowledge Data Engineering, 28(2):326–341, 2016. DOI:
10.1109/TKDE.2015.2429138. 194
[75] J. Flum, M. Frick, and M. Grohe. Query evaluation via tree-decompositions. Journal of
the ACM, 49(6):716–752, 2002. DOI: 10.1145/602220.602222. 192
[76] N. Francis. Asymptotic determinacy of path queries using union-of-paths views. In
18th International Conference on Database Theory, ICDT, pages 44–59, Brussels, Belgium,
March 23–27, 2015. DOI: 10.1007/s00224-016-9697-x. 196
[77] A. Fuxman, P. G. Kolaitis, R. J. Miller, and W. C. Tan. Peer data exchange. ACM Trans-
actions on Database Systems, 31(4):1454–1498, 2006. DOI: 10.1145/1189769.1189778.
195
[78] H. Garcia-Molina, J. D. Ullman, and J. Widom. Database Systems: The Complete Book,
2nd ed., Pearson Education, 2009. 190
[79] T. Gogacz and J. Marcinkowski. Red spider meets a rainworm: Conjunctive query ﬁnite
determinacy is undecidable. In Proc. of the 35th ACM SIGMOD-SIGACT-SIGAI Sym-
posium on Principles of Database Systems, PODS, pages 121–134, San Francisco, CA, June
26–July 01, 2016. DOI: 10.1145/2902251.2902288. 196
[80] G. Gottlob.
Computing cores for data exchange: New algorithms and practical so-
lutions.
In Proc. of the 24th ACM SIGACT-SIGMOD-SIGART Symposium on Prin-
ciples of Database Systems, pages 148–159, Baltimore, MD, June 13–15, 2005. DOI:
10.1145/1065167.1065187. 195

208
BIBLIOGRAPHY
[81] G. Gottlob, N. Leone, and F. Scarcello.
Hypertree decompositions and tractable
queries. In Proc. of the 18th ACM SIGACT-SIGMOD-SIGART Symposium on Princi-
ples of Database Systems, pages 21–32, Philadelphia, PA, May 31–June 2, 1999. DOI:
10.1145/303976.303979. 192
[82] G. Gottlob and A. Nash. Data exchange: Computing cores in polynomial time. In Proc. of
the 25th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems,
pages 40–49, Chicago, IL, June 26–28, 2006. DOI: 10.1145/1142351.1142358. 195
[83] G. Gottlob, G. Orsi, and A. Pieris.
Query rewriting and optimization for ontolog-
ical databases. ACM Transactions on Database Systems, 39(3):25:1–25:46, 2014. DOI:
10.1145/2638546. 197
[84] G. Gou, M. Kormilitsin, and R. Chirkova.
Query evaluation using overlapping
views: Completeness and eﬃciency.
In SIGMOD, Proc. of the ACM SIGMOD In-
ternational Conference on Management of Data, pages 37–48, New York, 2006. DOI:
10.1145/1142473.1142479. 193
[85] G. Grahne. The Problem of Incomplete Information in Relational Databases, volume 554 of
Lecture Notes in Computer Science. Springer, 1991. DOI: 10.1007/3-540-54919-6. 189
[86] G. Grahne and A. O. Mendelzon. Tableau techniques for querying information sources
through global schemas. In Proc. of the Database Theory, ICDT, 7th International Con-
ference, pages 332–347, Jerusalem, Israel, January 10–12, 1999. DOI: 10.1007/3-540-
49257-7_21. 188
[87] S. Grumbach, M. Rafanelli, and L. Tininini. On the equivalence and rewriting of aggre-
gate queries. Acta Informatica, 40(8):529–584, 2004. DOI: 10.1007/s00236-004-0101-y.
192
[88] S. Grumbach and L. Tininini. On the content of materialized aggregate views. In PODS,
pages 47–57, 2000. DOI: 10.1145/335168.335174. 196
[89] J. Gryz.
Query rewriting using views in the presence of functional and inclu-
sion dependencies.
Information Systems, 24(7):597–612, 1999. DOI: 10.1016/s0306-
4379(99)00034-4. 193, 194
[90] A. Gupta, Y. Sagiv, J. D. Ullman, and J. Widom. Constraint checking with partial in-
formation. In PODS, pages 45–55, 1994. DOI: 10.1145/182591.182597. 187
[91] A. Y. Halevy. Answering queries using views: A survey. VLDB Journal, 10(4):270–294,
2001. DOI: 10.1007/s007780100054. 190
[92] P. Hell and J. Nesetril. The core of a graph. Discrete Mathematics, 109(1-3):117–126,
1992. DOI: 10.1016/0012-365x(92)90282-k. 189

BIBLIOGRAPHY
209
[93] I. Ileana, B. Cautis, A. Deutsch, and Y. Katsis. Complete yet practical search for min-
imal query reformulations under constraints.
In International Conference on Manage-
ment of Data, SIGMOD, pages 1015–1026, Snowbird, UT, June 22–27, 2014. DOI:
10.1145/2588555.2593683. 194
[94] T. Imielinski and W. Lipski. Incomplete information in relational databases. Journal of
the ACM, 31(4):761–791, 1984. DOI: 10.1145/1634.1886. 195
[95] Y. E. Ioannidis and R. Ramakrishnan. Containment of conjunctive queries: Beyond
relations as sets. ACM Transactions on Database Systems, 20(3):288–324, 1995. DOI:
10.1145/211414.211419. 192
[96] T. S. Jayram, P. G. Kolaitis, and E. Vee. The containment problem for REAL conjunctive
queries with inequalities. In Proc. of the 25th ACM SIGACT-SIGMOD-SIGART Sympo-
sium on Principles of Database Systems, pages 80–89, Chicago, IL, June 26–28, 2006. DOI:
10.1145/1142351.1142363. 191
[97] A. Klug. On conjunctive queries containing inequalities. Journal of the ACM, 35(1), 1988.
DOI: 10.1145/42267.42273. 187, 190
[98] A. C. Klug.
Equivalence of relational algebra and relational calculus query lan-
guages having aggregate functions.
Journal of the ACM, 29(3):699–717, 1982. DOI:
10.1145/322326.322332. 192
[99] C. Koch. Query rewriting with symmetric constraints. In FoIKS: Proc. of the 2nd Inter-
national Symposium on Foundations of Information and Knowledge Systems, pages 130–147,
London, UK, Springer-Verlag, 2002. DOI: 10.1007/3-540-45758-5_9. 193
[100] P. G. Kolaitis. The query containment problem: Set semantics vs. bag semantics. In Proc.
of the 7th Alberto Mendelzon International Workshop on Foundations of Data Management,
Puebla/Cholula, Mexico, May 21–23, 2013. 192
[101] P. G. Kolaitis, D. L. Martin, and M. N. Thakur. On the complexity of the containment
problem for conjunctive queries with built-in predicates. In PODS, pages 197–204, 1998.
DOI: 10.1145/275487.275510. 190
[102] P. G. Kolaitis, J. Panttaja, and W. C. Tan. The complexity of data exchange. In Proc. of
the 25th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems,
pages 30–39, Chicago, IL, June 26–28, 2006. DOI: 10.1145/1142351.1142357. 195
[103] P. Koutris, T. Milo, S. Roy, and D. Suciu. Answering conjunctive queries with inequal-
ities. In 18th International Conference on Database Theory, ICDT, pages 76–93, Brussels,
Belgium, March 23–27, 2015. DOI: 10.1007/s00224-016-9684-2. 191

210
BIBLIOGRAPHY
[104] M. Lenzerini. Data integration: A theoretical perspective. In Proc. of the 21st ACM
SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, pages 233–
246, Madison, WI, June 3–5, 2002. DOI: 10.1145/543643.543644. 189, 190
[105] A. Levy and Y. Sagiv. Queries independent of updates. In VLDB, pages 171–181, 1993.
187
[106] A. Y. Levy, A. O. Mendelzon, Y. Sagiv, and D. Srivastava.
Answering queries
using views.
In Proc. of the 14th ACM SIGACT-SIGMOD-SIGART Symposium on
Principles of Database Systems, pages 95–104, San Jose, CA, May 22–25, 1995. DOI:
10.1145/212433.220198. 188, 192, 193
[107] A. Y. Levy, A. Rajaraman, and J. J. Ordille. Querying heterogeneous information sources
using source descriptions. In VLDB, Proc. of the 22th International Conference on Very Large
Data Bases, pages 251–262, Mumbai (Bombay), India, September 3–6, 1996. 188
[108] A. Y. Levy, A. Rajaraman, and J. D. Ullman. Answering queries using limited exter-
nal query processors. Journal of Computer Systems and Science, 58(1):69–82, 1999. DOI:
10.1006/jcss.1998.1599. 194
[109] C. Li. Computing complete answers to queries in the presence of limited access patterns.
VLDB, Journal, 12(3):211–227, 2003. DOI: 10.1007/s00778-002-0085-6. 194
[110] C. Li, M. Bawa, and J. D. Ullman. Minimizing view sets without losing query-answering
power. In Proc. of the Database Theory, ICDT, 8th International Conference, pages 99–113,
London, UK, January 4–6, 2001. DOI: 10.1007/3-540-44503-x_7. 197
[111] C. Li and E. Y. Chang. Answering queries with useful bindings. ACM Transactions on
Database Systems, 26(3):313–343, 2001. DOI: 10.1145/502030.502032. 194
[112] C. Li and E. Y. Chang. On answering queries in the presence of limited access patterns. In
Proc. of the Database Theory, ICDT, 8th International Conference, pages 219–233, London,
UK, January 4–6, 2001. DOI: 10.1007/3-540-44503-x_15. 194
[113] L. Libkin.
Data exchange and incomplete information.
In Proc. of the 25th ACM
SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, pages 60–69,
Chicago, IL, June 26–28, 2006. DOI: 10.1145/1142351.1142360. 195
[114] W. Lipski. On semantic issues connected with incomplete information databases. ACM
Transactions on Database Systems, 4(3):262–296, 1979. DOI: 10.1145/320083.320088.
189
[115] D. Maier, A. O. Mendelzon, and Y. Sagiv.
Testing implications of data de-
pendencies.
ACM Transactions on Database Systems, 4(4):455–469, 1979. DOI:
10.1145/582095.582119. 189, 194

BIBLIOGRAPHY
211
[116] D. Maier, Y. Sagiv, and M. Yannakakis.
On the complexity of testing implications
of functional and join dependencies. Journal of the ACM, 28(4):680–695, 1981. DOI:
10.1145/322276.322280. 192, 194
[117] M. Marx. Queries determined by views: Pack your views. In Proc. of the 26th ACM
SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, pages 23–30,
Beijing, China, June 11–13, 2007. DOI: 10.1145/1265530.1265534. 196
[118] R. J. Miller, L. M. Haas, and M. A. Hernández. Schema mapping as query discovery. In
VLDB, Proc. of the 26th International Conference on Very Large Data Bases, pages 77–88,
Cairo, Egypt, September 10–14, 2000. 195
[119] P. Mitra. An algorithm for answering queries eﬃciently using views. In 12th Australasian
Database Conference, ADC, pages 99–106, Bond University, Queensland, Australia, Jan-
uary 29–February 1, 2001. DOI: 10.1109/adc.2001.904470. 188, 193
[120] A. Nash, P. A. Bernstein, and S. Melnik.
Composition of mappings given by em-
bedded dependencies.
ACM Transactions on Database Systems, 32(1):4, 2007. DOI:
10.1145/1206049.1206053. 195
[121] A. Nash, L. Segouﬁn, and V. Vianu. Determinacy and rewriting of conjunctive queries
using views: A progress report. In International Conference on Database Theory (ICDT),
page 207–224, 2007. DOI: 10.1007/11965893_5. 196
[122] A. Nash, L. Segouﬁn, and V. Vianu.
Views and queries: Determinacy and
rewriting.
ACM Transactions on Database Systems, 35(3):21:1–21:41, 2010. DOI:
10.1145/1806907.1806913. 196
[123] W. Nutt, Y. Sagiv, and S. Shurin. Deciding equivalences among aggregate queries. In
Proc. of the 17th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database
Systems, pages 214–223, Seattle, WA, June 1–3, 1998. DOI: 10.1145/275487.275512.
192
[124] C. H. Papadimitriou and M. Yannakakis. On the complexity of database queries. Journal
of the Computer Systems and Science, 58(3):407–427, 1999. DOI: 10.1006/jcss.1999.1626.
192
[125] D. Pasaila. Conjunctive queries determinacy and rewriting. In Database Theory, ICDT,
14th International Conference, pages 220–231, Uppsala, Sweden, March 21–24, 2011.
DOI: 10.1145/1938551.1938580. 196
[126] L. Popa, A. Deutsch, A. Sahuguet, and V. Tannen. A chase too far? In Proc. of the ACM
SIGMOD Conference, pages 273–284, 2000. DOI: 10.1145/342009.335421. 189

212
BIBLIOGRAPHY
[127] L. Popa and V. Tannen.
An equational chase for path-conjunctive queries, con-
straints, and views. In Database Theory, ICDT, 7th International Conference, pages 39–57,
Jerusalem, Israel, January 10–12, 1999. DOI: 10.1007/3-540-49257-7_4. 189
[128] L. Popa, Y. Velegrakis, R. J. Miller, M. A. Hernández, and R. Fagin.
Translat-
ing web data. In VLDB, Proc. of the 28th International Conference on Very Large Data
Bases, pages 598–609, Hong Kong, China, August 20–23, 2002. DOI: 10.1016/b978-
155860869-6/50059-7. 195
[129] R. Pottinger and A. Y. Halevy. Minicon: A scalable algorithm for answering queries
using views. VLDB Journal, 10(2-3):182–198, 2001. 188, 193
[130] X. Qian. Query folding. In ICDE, pages 48–55, 1996. DOI: 10.1109/icde.1996.492088.
190
[131] A. Rajaraman, Y. Sagiv, and J. D. Ullman.
Answering queries using templates with
binding patterns. In Proc. of the 14th ACM SIGACT-SIGMOD-SIGART Symposium on
Principles of Database Systems, pages 105–112, San Jose, CA, May 22–25, 1995. DOI:
10.1145/212433.220199. 188, 194
[132] R. Rosati.
The limits of querying ontologies.
In Database Theory, ICDT, 11th In-
ternational Conference, pages 164–178, Barcelona, Spain, January 10–12, 2007. DOI:
10.1007/11965893_12. 197
[133] R. Rosati. On the ﬁnite controllability of conjunctive query answering in databases under
open-world assumption. Journal of Computer Systems and Science, 77(3):572–594, 2011.
DOI: 10.1016/j.jcss.2010.04.011. 197
[134] Y. Saraiya. Subtree Elimination Algorithms in Deductive Databases. Ph.D. thesis, Depart-
ment of Computer Science, Stanford University, 1991. 190
[135] D. Srivastava, S. Dar, H. V. Jagadish, and A. Y. Levy. Answering queries with aggregation
using views. In VLDB, Proc. of the 22th International Conference on Very Large Data Bases,
pages 318–329, Mumbai (Bombay), India, September 3–6, 1996. 192
[136] B. Sundarmurthy, P. Koutris, W. Lang, J. F. Naughton, and V. Tannen.
m-tables:
Representing missing data. In 20th International Conference on Database Theory, ICDT,
pages 21:1–21:20, Venice, Italy, March 21–24, 2017. 195
[137] B. ten Cate, P. G. Kolaitis, and W. Othman. Data exchange with arithmetic operations.
In Proc. of the Joint EDBT/ICDT Conferences, EDBT, pages 537–548, Genoa, Italy, March
18–22, 2013. DOI: 10.1145/2452376.2452439. 195
[138] J. D. Ullman. Information integration using logical views. Theoretical Computer Science,
239(2):189–210, 2000. DOI: 10.1016/s0304-3975(99)00219-4. 187

BIBLIOGRAPHY
213
[139] R. van der Meyden. The complexity of querying indeﬁnite data about linearly ordered
domains. In PODS, 1992. DOI: 10.1145/137097.137902. 190
[140] R. van der Meyden.
The complexity of querying indeﬁnite data about linearly or-
dered domains.
Journal of Computer and System Sciences, 54(1):113–135, 1997. DOI:
10.1006/jcss.1997.1455. 191
[141] R. van der Meyden. Logical approaches to incomplete information: A survey. In Logics
for Databases and Information Systems, (the book grow out of the Dagstuhl Seminar 9529:
Role of Logics in Information Systems, 1995), pages 307–356, 1998. DOI: 10.1007/978-
1-4615-5643-5_10. 189
[142] M. Y. Vardi. The complexity of relational query languages. In Proc. 14th ACM Symposium
on Theory of Computing, page 137–146, 1982. DOI: 10.1145/800070.802186. 190
[143] M. Y. Vardi. Inferring multivalued dependencies from functional and join dependencies.
Acta Informatica, 19:305–324, 1983. DOI: 10.1007/bf00290729. 194
[144] M. Y. Vardi. A theory of regular queries. In Proc. of the 35th ACM SIGMOD-SIGACT-
SIGAI Symposium on Principles of Database Systems, PODS, pages 1–9, San Francisco, CA,
June 26–July 01, 2016. DOI: 10.1145/2902251.2902305. 197
[145] F. Wei and G. Lausen. Containment of conjunctive queries with safe negation. In Proc.
of the Database Theory, ICDT, 9th International Conference, pages 343–357, Siena, Italy,
January 8–10, 2003. DOI: 10.1007/3-540-36285-1_23. 188, 190
[146] M. Yannakakis. Algorithms for acyclic database schemes. In Proc, of the Very Large Data
Bases, 7th International Conference, pages 82–94, Cannes, France, September 9–11, 1981.
188
[147] X. Zhang and M. Z. Ozsoyoglu. On eﬃcient reasoning with implication constraints. In
DOOD, pages 236–252, 1993. DOI: 10.1007/3-540-57530-8_15. 187


215
Authors’ Biographies
FOTO N. AFRATI
Foto N. Afrati is a professor in the Electrical and Computing Engineering Department of the
NTUA, Greece. She received a B.S. degree from the Mechanical and Electrical Engineering
Department of National Technical University of Athens (NTUA) and a Ph.D. from Imperial
College of the University of London. She is a Fellow of ACM. She has received the ACM
Recognition for Service Award in 2005 and the best-paper award in ICDT 2009. She has been
the program-committee chair for the Conference on Principles of Databases (PODS) 2005,
and for the International Conference on Database Theory (ICDT) 1997, for which she was the
organizing committee chair as well. She currently serves as associate editor of the IEEE TKDE
journal. In 2012–2013, she spent her sabbatical leave visiting Google at Mountain View. She has
published over 100 papers in the areas of databases, algorithms, and distributed computing. Her
research interests are in the area of database theory, recent research interests are mainly in the
area of big data, including query optimization for MapReduce and other distributed platforms.
RADA Y. CHIRKOVA
Rada Y. Chirkova is an associate professor of Computer Science at North Carolina State Uni-
versity. She has received a B.Sc. and a M.Sc., both in Applied Mathematics, from Moscow
State University (Moscow, Russia), and an M.Sc. and a Ph.D., both in Computer Science,
from Stanford University. She is a senior member of the Association for Computing Machin-
ery, and served in 2017 as General Co-Chair of the ACM International Conference on Man-
agement of Data (SIGMOD). She is associate editor of the SIGMOD Record journal and of The
Computer Journal (Oxford). She has co-authored 3 books (including this book), and has over
60 peer-reviewed publications on topics ranging from query containment and equivalence, query
processing, view-based reformulation of data and queries, information security and leakage, to
applications of policies to agent behaviors. She has received the National Science Foundation
(NSF) CAREER Award, as well as numerous IBM Faculty and University Partnership Pro-
gram Awards. Her research interests span information and knowledge management, algorithms
and theory of computation, and data sciences and analytics, with applications including data
wrangling, cyber security, and healthcare information technology.

