Copyright © MathByte Academy

This course is about
the Python language and built-in types
the standard library
idiomatic Python
becoming an expert Python developer
Copyright © MathByte Academy

The Zen of Python
Tim Peters
PEP 20
import this
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
Copyright © MathByte Academy

Quick Refresher
variables
conditionals
functions
loops
classes
Python's type hierarchy
break, continue and try
Copyright © MathByte Academy

Variables and Memory
what are variables?
à symbols for memory addresses
memory
Python memory management
à reference counting, garbage collection
mutability
à function arguments, shared references
what is equality of two objects?
Python memory optimizations
à interning, peephole
Copyright © MathByte Academy

Numeric Types
integers
rationals
exactness
rounding
floats
à binary representations
equality
measures of closeness, approximate equality
Decimals
à alternative to floats
exactness
rounding
precision
complex numbers
à cmath standard library
Copyright © MathByte Academy

Numeric Types - Booleans
associated Truth values
à every object has one
precedence and short-circuiting
Boolean operators
à what they really do
using in context of associated truth values
comparison operators
à identity, value equalities
ordering
Copyright © MathByte Academy

Functions
docstrings and annotations
Lambdas
introspection
functional programming
à map, filter, zip
à reducing functions
à partial functions
higher-order functions
Copyright © MathByte Academy

Functions - Arguments
packing and unpacking
default values
à caveats
positional arguments
keyword-only arguments
variable positional arguments
variable keyword-only arguments
Copyright © MathByte Academy

Functions - Scopes and Closures
global and local scopes
nested scopes
closures
nested closures
Copyright © MathByte Academy

Decorators
decorators
nested decorators
parameterized decorators
stacked decorators
class decorators
decorator classes
applications
à memoization, single dispatch, logging, timing
Copyright © MathByte Academy

Tuples as Data Structures
tuples are not just read-only lists
data structures
packing and unpacking
named tuples
augmenting named tuples
Copyright © MathByte Academy

Modules, Packages and Namespaces
what are modules?
what are packages?
how do the various imports work?
how to manipulate namespaces using packages
zip archives
__main__
Copyright © MathByte Academy

Extras
will keep growing over time
important new features of Python 3.6 and later
best practices
random collection of interesting stuff
send me your suggestions!
additional resources
Copyright © MathByte Academy

Copyright © MathByte Academy

Python Type Hierarchy
focus on types covered in this course
Multi-Line Statements and Strings
Naming Conventions
Conditionals
Functions
Break, Continue, Try
Loops
While
For
Copyright © MathByte Academy

Copyright © MathByte Academy

The following is a subset of the Python type hierarchy that we will cover in this course:
Numbers
Integral
Non-Integral
Integers
Booleans
Floats (c doubles)
Complex
Decimals
Fractions
Copyright © MathByte Academy

Collections
Sequences
Mutable
Immutable
Lists
Tuples
Strings
Sets
Mutable
Immutable
Sets
Frozen Sets
Mappings
Dictionaries
Copyright © MathByte Academy

Callables
User-Defined Functions
Generators
Classes
Instance Methods
Class Instances (__call__())
Built-in Functions (e.g. len(), open())
Built-in Methods (e.g. my_list.append(x))
Singletons
None
Ellipsis (…)
NotImplemented
Copyright © MathByte Academy

Copyright © MathByte Academy

Python Program
physical lines of code
logical lines of code
tokenized
physical newline vs logical newline
end with a logical NEWLINE token
sometimes, physical newlines are ignored
in order to combine multiple physical lines
terminated by a logical NEWLINE token
into a single logical line of code
end with a physical newline character
Conversion can be implicit or explicit
Copyright © MathByte Academy

Implicit
Expressions in:
list literals: [ ]
tuple literals: ( )
dictionary literals: { }
set literals: { }
function arguments / parameters
[1, 
2, 
3]
[1, #item 1 
2, #item 2
3
#item 3
]
def my_func(a, 
b, #comment
c):
print(a, b, c)
my_func(10, #comment
20, 30)
supports inline comments
Copyright © MathByte Academy

Explicit
You can break up statements over multiple lines explicitly, by using the \ (backslash ) character
Multi-line statements are not implicitly converted to a single logical line.
if a 
and b
and c:
if a \
and b \
and c:
Comments cannot be part of a statement, not even a multi-line statement.
if a \
and b \ #comment
and c:
Copyright © MathByte Academy

Multi-Line String Literals
Multi-line string literals can be created using triple delimiters (' single or " double)
'''This is
a multi-line string'''
"""This is
a multi-line string"""
Be aware that non-visible characters such as newlines, 
tabs, etc. are actually part of the string – basically 
anything you type.
You can use escaped characters (e.g. \n, \t), use string formatting, etc.
A multi-line string is just a regular string.
Multi-line strings are not comments, although they can be used as such,
especially with special comments called docstrings.
Copyright © MathByte Academy

Copyright © MathByte Academy

Copyright © MathByte Academy

Identifier names
must follow certain rules
should follow certain conventions
are case-sensitive
my_var
my_Var
ham
Ham
are different identifiers
Copyright © MathByte Academy

start with underscore ( _ ) or letter ( a-z A-Z )
followed by any number of underscores ( _ ), letters ( a-z A-Z ), or digits ( 0-9 )
Must
are all legal names
cannot be reserved words:
False
None
True
and
as
assert
break
class
continue
def
del
elif
else
except
finally
for
from
global
if
import
in
is
lambda
nonlocal
not
or
pass
raise
return
try
while
with
yield
my_var
index1
_var
index_1
__var
__lt__
var
Copyright © MathByte Academy

Conventions
Objects named this way will not get imported by a statement such as : 
from module import *
double underscore
__my_var
This is a convention to indicate "internal use" or "private" objects
Used to "mangle" class attributes – useful in inheritance chains
_my_var
single underscore
Used for system-defined names that have a special 
meaning to the interpreter. 
x < y
x.__lt__(y)
double underscore
__my_var__
__init__
Don't invent them, stick to the ones pre-defined by Python!
Copyright © MathByte Academy

Other Naming Conventions
from the PEP 8 Style Guide
Modules
short, all-lowercase names. Can have underscores.
Packages
short, all-lowercase names. Preferably no underscores.
utilities
db_utils
dbutils
Classes
CapWords (upper camel case) convention
BankAccount
Functions
lowercase, words separated by underscores (snake_case)
open_account
Variables
lowercase, words separated by underscores (snake_case)
account_id
Constants
all-uppercase, words separated by underscores
MIN_APR
https://www.python.org/dev/peps/pep-0008/
A foolish consistency is the hobgoblin of little minds
This is a should-read!
(Emerson)
Copyright © MathByte Academy

memory references
what variables really are
reference counting
memory management
garbage collection
dynamic vs static typing
mutability and immutability
shared references
variable equality
everything is an object
Copyright © MathByte Academy

Copyright © MathByte Academy

Memory
0x1000
0x1001
0x1002
0x1003
0x1004
0x1005
…
Heap
…
object 1
object 2
object 3
Memory Address
Python Memory Manager
Copyright © MathByte Academy

my_var_1 = 10
Memory
0x1000
0x1001
0x1002
0x1003
0x1004
0x1005
…
…
10
hello
my_var_1
reference
0x1000
my_var_2
reference
0x1002
my_var_2 = ‘hello’
my_var_1 references the object at 0x1000
my_var_2 references the object at 0x1002
Copyright © MathByte Academy

In Python, we can find out the memory address 
referenced by a variable by using the id() function.
Example
a = 10
print(hex(id(a)))
This will return a base-10 number. We can convert this 
base-10 number to hexadecimal, by using the hex()
function.
Copyright © MathByte Academy

Copyright © MathByte Academy

2
my_var = 10
my_var
reference
0x1000
10
0x1000
reference
count
0x1000
other_var = my_var
other_var
reference
0x1000
Reference Counting
1
0
1
Python Memory Manager
Copyright © MathByte Academy

Finding the Reference Count
ctypes.c_long.from_address(address).value
sys.getrefcount(my_var)
passing my_var to getrefcount() creates
an extra reference!
Here, we just pass the memory address (an integer),
not a reference – does not affect reference count
Copyright © MathByte Academy

Copyright © MathByte Academy

Circular References
Object A
Object B
var_1
var_2
my_var
Garbage Collector
- can be controlled programmatically using the gc module
- by default it is turned on
- you may turn it off if you’re sure your code does not create circular references – but beware!!
Memory Leak!!
- runs periodically on its own (if turned on)
- you can call it manually, and even do your own cleanup
Copyright © MathByte Academy

In general GC works just fine
but, not always…
If even one of the objects in the circular reference has a destructor [e.g. __del__() ]
the destruction order of the objects may be important
but the GC does not know what that order should be
so the object is marked as uncollectable
and the objects in the circular reference are not cleaned up
memory leak
for Python < 3.4
Copyright © MathByte Academy

Copyright © MathByte Academy

Some languages (Java, C++, Swift) are statically typed
String myVar = “hello”;
variable
name
data
type
value
String
myVar
String
hello
0x1000
myVar = 10;
Does not work!
myVar = “abc”;
This is OK!
ref
myVar has been declared as a String, and cannot be 
assigned the integer value 10 later.
“abc” is a String – so compatible type and assignment
works.
Copyright © MathByte Academy

Python, in contrast, is dynamically typed.
my_var = ‘hello’;
The variable my_var is purely a reference to a string object with value hello.
No type is “attached” to my_var.
my_var = 10;
The variable my_var is now pointing to an integer object with value 10.
myVar
String
hello
0x1000
ref
Int
10
0x1234
ref
Copyright © MathByte Academy

We can use the built-in type() function to determine 
the type of the object currently referenced by a variable.
Remember: variables in Python do not have an inherent static type.
Instead, when we call type(my_var)
Python looks up the object my_var is referencing (pointing to), 
and returns the type of the object at that memory location.
Copyright © MathByte Academy

Copyright © MathByte Academy

my_var = 10
my_var
int
15
0x1234
int
10
0x1000
my_var = 15
Copyright © MathByte Academy

my_var = 10
my_var
int
15
0x1234
int
10
0x1000
my_var = my_var + 5
In fact, the value inside the int objects, can never be changed!
Copyright © MathByte Academy

Copyright © MathByte Academy

Consider an object in memory:
type
state
(data)
0x1000
Changing the data inside the 
object is called modifying the 
internal state of the object.
BankAccount
Acct #: 12345
Balance: 150
0x1000
BankAccount
Acct #: 12345
Balance: 500
0x1000
my_account
internal state (data) has changed
memory address has not changed
Object was mutated
fancy way of saying the internal data has changed
Copyright © MathByte Academy

An object whose internal state can be changed, is called
Mutable
An object whose internal state cannot be changed, is called
Immutable
Copyright © MathByte Academy

Examples in Python
Immutable
Mutable
•
Numbers (int, float, Booleans, etc)
•
Strings
•
Tuples
•
Frozen Sets
•
User-Defined Classes
•
Lists
•
Sets
•
Dictionaries
•
User-Defined Classes
Copyright © MathByte Academy

t = (1, 2, 3)
Tuples are immutable: elements cannot be deleted, inserted, or replaced
But consider this:
a = [1, 2]
b = [3, 4]
Lists are mutable: elements can be deleted, inserted, or replaced
t = (a, b)
t = ([1, 2], [3, 4])
In this case, both the container (tuple), and all its elements (ints) are immutable
a.append(3)
b.append(5)
t = ([1, 2, 3], [3, 4, 5])
In this case, although the tuple is immutable, its elements are not. 
The object references in the tuple did not change
but the referenced objects did mutate!
Copyright © MathByte Academy

t = (1, 2, 3)
tuple is immutable
these are references to immutable object (int)
t = ([1, 2], [3, 4])
tuple is immutable
these are references to a mutable object (list)
Copyright © MathByte Academy

Copyright © MathByte Academy

In Python, Strings (str) are immutable objects.
Once a string has been created, the contents of the object can never be changed
In this code:
my_var = ‘hello’
the only way to modify the “value” of my_var is to re-assign my_var to another object
my_var
hello
0x1000
abcd
0x1234
Copyright © MathByte Academy

Immutable objects are safe from unintended side-effects
def process(s):
s = s + ‘ world’
return s
my_var = ‘hello’
Scopes
module scope
process() scope
my_var
hello
0x1000
s
hello 
world
0x1234
my_var’s reference is passed to process()
0x1000
process(my_var)
print(my_var)
hello
but watch out for immutable collection objects that contain mutable objects
Copyright © MathByte Academy

Mutable objects are not safe from unintended side-effects
def process(lst):
lst.append(100)
my_list = [1, 2, 3]
process(my_list)
my_lists’s reference is passed to process()
Scopes
module scope
process() scope
my_list
1
2
3
0x1000
lst
100
print(my_list)
[1, 2, 3, 100]
0x1000
Copyright © MathByte Academy

Immutable collection objects that contain mutable objects
def process(t):
t[0].append(3)
my_tuple = ([1,2], ‘a’)
process(my_tuple)
my_tuple’s reference is passed to process()
Scopes
module scope
process() scope
my_tuple
[1, 2]
‘a’
0x1000
t
print(my_tuple)
([1, 2, 3], ‘a’)
0x1000
[1, 2, 3]
‘a’
0x1000
Copyright © MathByte Academy

Copyright © MathByte Academy

The term shared reference is the concept of two variables referencing 
the same object in memory (i.e. having the same memory address)
a = 10
10
0x1000
b = a
a
b
def my_func(v):
…
t = 20
my_func(t)
20
0x2000
t
v
Copyright © MathByte Academy

In fact, the following may surprise you:
a = 10
b = 10
10
0x1000
a
b
s1 = ‘hello’
s2 = ‘hello’
hello
0x23FA
s1
s2
In both these cases, Python’s memory manager decides to automatically re-use 
the memory references!!
We’ll revisit this again soon
Is this even safe?
Yes
The integer object 10, and the string object ‘hello’ are immutable
– so it is safe to set up a shared reference
Copyright © MathByte Academy

When working with mutable objects we have to be more careful
a = [1, 2, 3]
b = a
b.append(100)
1
2
3
0x1000
a
b
100
With mutable objects, the Python memory manager will never create shared references
a = [1, 2, 3]
b = [1, 2, 3]
a
1
2
3
0x1000
b
1
2
3
0xF354
Copyright © MathByte Academy

Copyright © MathByte Academy

We can think of variable equality in two fundamental ways:
Memory Address
Object State (data)
is
==
var_1 is var_2
var_1 == var_2
Negation
is not
!=
var_1 is not var_2
var_1 != var_2
not(var_1 is var_2)
not(var_1 == var_2)
identity operator
equality operator
Copyright © MathByte Academy

a = 10
b = a
a is b
a == b
a = ‘hello’
b = ‘hello’
a is b
a == b
but as we’ll see later, don’t count on it!
a = [1, 2, 3]
b = [1, 2, 3]
a is b
a == b
a = 10
b = 10.0
a is b
a == b
Examples
Copyright © MathByte Academy

The None object
The None object can be assigned to variables to indicate that they are not set 
(in the way we would expect them to be), i.e. an “empty” value (or null pointer)
But the None object is a real object that is managed by the Python memory manager
Furthermore, the memory manager will always use a shared reference when assigning
a variable to None
a = None
b = None
c = None
None
0x1000
a
b
c
So we can test if a variable is “not set” or “empty” by comparing it’s memory 
address to the memory address of None using the is operator
a is None
x = 10
x is None
x is not None
Copyright © MathByte Academy

Copyright © MathByte Academy

Throughout this course, we’ll encounter many data types.
•
Integers (int)
•
Booleans (bool)
•
Floats (float)
•
Strings (str)
•
Lists (list)
•
Tuples (tuple)
•
Sets (set)
•
Dictionaries (dict)
•
None (NoneType)
and many more…
We’ll also see other constructs:
•
Operators (+, -, ==, is, …)
•
Functions
•
Classes
•
Types
Copyright © MathByte Academy

But the one thing in common with all these things, is that 
they are all objects (instances of classes)
•
Functions (function)
•
Classes (class)  [not just instances, but the class itself]
•
Types (type)
This means they all have a memory address!
Any object can be assigned to a variable
Any object can be passed to a function
Any object can be returned from a function
As a consequence:
including functions…
including functions…
including functions…
def my_func():
…
my_func
function
state
0x1000
id(my_func)
0x1000
my_func is the name of the function
my_func() invokes the function
Copyright © MathByte Academy

Copyright © MathByte Academy

Important Note:
A lot of what we discuss with memory management, garbage collection and optimizations, 
is usually specific to the Python implementation you use.
In this course, we are using CPython, the standard (or reference) Python 
implementation (written in C).
But there are other Python implementations out there. These include:
•
Jython – written in Java and can import and use any Java class – in fact it even 
compiles to Java bytecode which can then run in a JVM
•
IronPython – this one is written in C# and targets .Net (and mono) CLR
•
PyPy – this one is written in RPython (which is itself a statically-typed subset of Python 
written in C that is specifically designed to write interpreters)
•
and many more…
https://wiki.python.org/moin/PythonImplementations
Copyright © MathByte Academy

Earlier we saw:
a = 10
b = 10
a
b
10
0x1000
But look at this:
a = 500
b = 500
a
500
0x1001
b
500
0x1002
In this case, although it would 
be safe for Python to create 
a shared reference, it does 
not!
Copyright © MathByte Academy

What is going on?
At startup, Python (CPython), pre-loads (caches) a global list of integers in the range [-5, 256]
Optimization strategy – small integers show up often
When we write
a = 10
Python just has to point to the existing reference for 10
But if we write
a = 257
Python does not use that global list and a new object 
is created every time
Interning: reusing objects on-demand
Any time an integer is referenced in that range, Python will use the cached version of that object
Singletons
Copyright © MathByte Academy

Copyright © MathByte Academy

Some strings are also  automatically interned – but not all!
As the Python code is compiled, identifiers are interned
•
variable names
•
function names
•
class names
•
etc.
Identifiers:
•
must start with _ or a letter
•
can only contain _, letters and numbers
Some string literals may also be automatically interned:
•
string literals that look like identifiers (e.g. ’hello_world’)
•
although if it starts with a digit, even though that is not a valid identifier, 
it may still get interned
But don’t count on it!!
Copyright © MathByte Academy

Why do this?
It’s all about (speed and, possibly, memory) optimization.
Python, both internally, and in the code you write, deals with lots and lots of dictionary type lookups,
on string keys, which means a lot of string equality testing.
Let’s say we want to see if two strings are equal:
a = ‘some_long_string’
b = ‘some_long_string’
Using a == b, we need to compare the two strings character by character
But if we know that ‘some_long_string’ has been interned, then a and b are the same string
if they both point to the same memory address
In which case we can use a is b instead – which compares two 
integers (memory address)
This is much faster than the character by character comparison
Copyright © MathByte Academy

Not all strings are automatically interned by Python
But you can force strings to be interned by using the sys.intern() method.
import sys
a = sys.intern(‘the quick brown fox’)
b = sys.intern(‘the quick brown fox’)
a is b à True
When should you do this?
•
dealing with a large number of strings that could have high repetition
e.g. tokenizing a large corpus of text (NLP)
•
lots of string comparisons
In general though, you do not need to intern strings 
yourself. Only do this if you really need to.
much faster than a == b
Copyright © MathByte Academy

Copyright © MathByte Academy

This is another variety of optimizations that can occur at compile time.
Constant expressions
numeric calculations
24 * 60
Python will actually pre-calculate 24 * 60 à 1440
short sequences length < 20
(1, 2) * 5
'abc' * 3
'the quick brown fox' * 10
but not
'hello’ + ‘ world’
à (1, 2, 1, 2, 1, 2, 1, 2, 1, 2)
à abcabcabc
à hello world
(more than 20 characters)
Copyright © MathByte Academy

Membership Tests: Mutables are replaced by Immutables
When membership tests such as:
if e in [1, 2, 3]:
are encountered, the [1, 2, 3] constant, is replaced by its immutable counterpart
(1, 2, 3)
tuple
•
lists à tuples
•
sets à frozensets
Set membership is much faster than list or tuple membership (sets are basically like dictionaries)
So, instead of writing:
if e in [1, 2, 3]:
if e in (1, 2, 3):
or
write
if e in {1, 2, 3}:
Copyright © MathByte Academy

Copyright © MathByte Academy

Four main types of numbers:
Integer Numbers (ℤ)
Rational Numbers (ℚ) 
#
$ #, $ ∈ℤ, $ ≠0
Real Numbers (ℝ) 
Complex Numbers (ℂ) 
+ + -. +, - ∈ℝ
ℤ⊂ℚ⊂ℝ⊂ℂ
0, ±1, ±2, ±3, …
int
Python Type
fractions.Fraction
float
decimal.Decimal
complex
0, -1, 0.125, 
!
" , !, …
Boolean truth values
0 (False), 1 (True)
bool
5
Copyright © MathByte Academy

Copyright © MathByte Academy

Ex: 0, 10, -100, 100000000, …
How large can a Python int become (positive or negative)?
The int data type
Integers are represented internally using base-2 (binary) digits, not decimal.
27     26    25     24    23    22    21    20
128   64  32   16   8   4   2   1
___     ___    ___     ___    ___    ___    ___    ___     
1
0
0
1
1
individual bits ( 0 | 1 )
1 x 16
+ 0 x 8
+ 0 x 4
+ 1 x 2
+ 1 x 1
= 16 + 2 + 1 = 19
(10011)2 = (19)10
Representing the decimal number 19 requires 5 bits
Copyright © MathByte Academy

27     26    25     24    23    22    21    20
128   64  32   16   8   4   2   1
___     ___    ___     ___    ___    ___    ___    ___     
What's the largest (base 10) integer number that can be represented using 8 bits?
Let's assume first that we only care about non-negative integers
1
1
1
1
1
1
1
1
128 + 64 + 32 + 16 + 8 + 4 + 2 + 1
= 28 - 1
= 255
If we care about handling negative integers as well, then 1 bit is reserved to represent the sign of 
the number, leaving us with only 7 bits for the number itself out of the original 8 bits
The largest number we can represent using 7 bits is 27 – 1 = 127
So, using 8 bits we are able to represent all the integers in the range [-127, 127]
Since 0 does not require a sign, we can squeeze out an extra number,
and we end up with the range [-128, 127]
[-27, 27 – 1]
Copyright © MathByte Academy

Similarly, if we want to use 32 bits to store (signed) integers, our range would be:
2(32-1)
= 231 = 2,147,483,648
Range: [-2,147,483,648 … 2,147,483,647]
If we want to use 16 bits to store (signed) integers, our range would be:
2(16-1)
= 215
= 32,768
Range: [-32,768 … 32,767]
If we had an unsigned integer type, using 32 bits our range would be:
[0, 232] = [0 … 4,294,967,296]
= 4,294,967,296 / 1024 kB = 4,194,304 kB
memory spaces (bytes) are limited by their address number à 32 bits
= 4,096 / 1024 GB = 4 GB
= 4,194,304 / 1024 MB = 4,096 MB
In a 32-bit OS:
4,294,967,296 bytes of addressable memory
Copyright © MathByte Academy

Some languages (such as Java, C, …) provide multiple distinct integer data types that use a fixed 
number of bits:
byte
-128, …, 127
signed 8-bit numbers
So, how large an integer can be depends on how many bits are used to store the number.
short
-32,768, …, 32,767
signed 16-bit numbers
int
-231 …, 231 - 1
signed 32-bit numbers
long
-263 …, 263 - 1
signed 64-bit numbers
and more…
Java
Copyright © MathByte Academy

Python does not work this way
The int object uses a variable number of bits
Theoretically limited only by the amount of memory available
Can use 4 bytes (32 bits), 8 bytes (64 bits), 12 bytes (96 bits), etc.
Seamless to us
Of course, larger numbers will use more memory
and standard operators such as +, *, etc. will run 
slower as numbers get larger
[since ints are actually objects, there is a further fixed overhead per integer]
Copyright © MathByte Academy

Copyright © MathByte Academy

Integers support all the standard arithmetic operations:
addition 
+
subtraction 
-
multiplication 
*
division 
/
exponents
**
But what is the resulting type of each operation?
int + int
à int
int - int
à int
int * int
à int
int / int
à float
but, also 
10 / 2 
à 5
(float)
obviously 
3 / 4 
à 0.75
(float)
int ** int
à int
Copyright © MathByte Academy

Two more operators in integer arithmetic
First, we revisit long integer division…
155
4
3
12
35
8
32
3
155 ÷ 4 = 38 with remainder 3
put another way:
155 = 4 * 38 + 3
155 // 4
155 % 4
155 = 4 * (155 // 4) + (155 % 4)
n = d * (n // d) + (n % d)
// is called floor division (div)
% is called the modulo operator (mod)
and they always satisfy:
155
4
numerator
denominator
= 4 *      38    +     3
Copyright © MathByte Academy

What is floor division exactly?
First define the floor of a (real) number
is the largest (in the standard number order) integer <= a
The floor of a real number a
floor(3.14) à 3
floor(1.9999) à 1
But watch out for negative numbers!
floor(-3.1)
-4
-3
-3.1
à -4
So, floor is not quite the same as truncation!
a // b = floor(a / b)
floor(2) à 2
Copyright © MathByte Academy

a = b * (a // b) + a % b
a = 135
b = 4 
135 // 4  à 33 
135 % 4   à 3 
135 / 4 = 33.75 (33 ¾)
And, in fact:
4 * (135 // 4) + (135 % 4) 
= 4 * 33 + 3
= 132 + 3
= 135
a = b * (a // b) + a % b
Copyright © MathByte Academy

Negative Numbers
Be careful, a//b, is not the integer portion of a / b, it is the floor of a / b 
For a > 0 and b > 0, these are indeed the same thing
But beware when dealing with negative numbers!
a = -135
b = 4 
-135 // 4  à -34 
-135 % 4   à 1
-135 / 4 = -33.75 (-33 ¾)
And, in fact:
4 * (-135 // 4) + (-135 % 4) 
= (4 * -34) + 1
= -136 + 1
= -135
135 // 4  à 33 
135 % 4   à 3 
a = b * (a // b) + a % b
Copyright © MathByte Academy

-13 // 4 à -4
-13 / 4
à -3.25
13 // -4 à -4
13 / -4 
à -3.25
-13 % 4 
à 3
13 % -4 
à -3
-13 // -4 à 3
-13 / -4
à 3.25
-13 % -4
à -1
13 // 4
à 3
13 / 4 
à 3.25
13 % 4 
à 1
In each of these cases: a = b * (a // b) + a % b
4 * (13 // 4) + 13 % 4
= 12 + 1 = 13
4 * (-13 // 4) + -13 % 4
= -16 + 3 = -13
-4 * (13 // -4) + 13 % -4
= 16 + -3 = 13
-4 * (-13 // -4) + -13 % -4
= -12 + -1 = -13
Expanding this further…
a = 13   b = 4
a = -13   b = 4
a = 13   b = -4
a = -13   b = -4
Copyright © MathByte Academy

Copyright © MathByte Academy

An integer number is an object – an instance of the int class
The int class provides multiple constructors
a = int (10)
a = int (-10)
Other (numerical) data types are also supported in the argument of the int constructor:
a = int("10")
a = int(10.9)
a = int(True)
a = int(Decimal("10.9"))
As well as strings (that can be parsed to a number)
truncation: a à 10
a = int(-10.9)
truncation: a à -10
a à 1
truncation: a à 10
a à 10
Copyright © MathByte Academy

Number Base
int("123")
à (123)10
When used with a string, constructor has an optional second parameter: base
If base is not specified, the default is base 10 – as in the example above
int("1010", 2)
à (10)10
int("1010", base=2)
à (10)10
int("A12F", base=16)
à (41263)10
int("534", base=8)
à (348)10
int("A", base=11)
int("B", 11)
ValueError: invalid literal for int() with base 11: 'B'
à (10)10
int("a12f", base=16)
à (41263)10
2 <= base <= 36
Copyright © MathByte Academy

Reverse Process: changing an integer from base 10 to another base
built-in functions:
bin(10) à '0b1010'
bin()
oct()
hex()
oct(10) à '0o12'
hex(10) à '0xa'
The prefixes in the strings help document the base of the number
int('0xA', 16) à (10)10
These prefixes are consistent with literal integers using a base prefix (no strings attached!)
a = 0b1010
a à 10
a = 0o12
a à 10
a = 0xA
a à 10
Copyright © MathByte Academy

What about other bases?
Custom code
n: number (base 10)
b: base (target base)
___     ___    ___     ___    ___    ___    ___    ___     
b7     b6    b5     b4    b3    b2    b1   b0
?
?
?
?
?
?
?
?
n = b * (n // b) + n % b
à
n = (n // b) * b + n % b
Copyright © MathByte Academy

n = 232
b = 5
232 = (232 // 5) x 5 + 232 % 5
= 46 x 5 + 2
= [46 x 51] + [2 x 50]
___    ___    ___    ___     
53    52    51   50
?
?
?
?
___    ___    ___    ___     
53    52    51    50
?
?
46
2
= [((46 // 5) x 5 + 46 % 5) x 51] + [2 x 50]
= [(9 x 5 + 1) x 51] + [2 x 50]
= [9 x 52] + [1 x 51] + [2 x 50]
___    ___    ___    ___     
53    52    51    50
?
9
1
2
too big
too big
= [((9 // 5) x 5 + 9 % 5) x 52] + [1 x 51] + [2 x 50]
= [(1 x 5 + 4) x 52] + [1 x 51] + [2 x 50]
= [1 x 53] + [4 x 52] + [1 x 51] + [2 x 50]
___    ___    ___    ___     
53    52    51    50
1
4
1
2
div
2nd mod
3rd mod
1st mod
= [((1 // 5) x 5 + 1 % 5) x 53] + [4 x 52] + [1 x 51] + [2 x 50]
= [(0 x 5 + 1) x 53] + [4 x 52] + [1 x 51] + [2 x 50]
= [0 x 54] + [1 x 53] + [4 x 52] + [1 x 51] + [2 x 50]
___    ___    ___    ___     
53    52    51    50
1
4
1
2
2nd mod
3rd mod
1st mod
4th mod
stop
Copyright © MathByte Academy

Base Change Algorithm
n = base-10 number (>= 0)
b = base (>= 2)
if b < 2 or n < 0: raise exception
if n == 0: return [0]
digits = [ ]
while n > 0:
m = n % b
n = n // b
digits.insert(0, m)
n = 232
b = 5
digits à [1, 4, 1, 2]
n = 1485
b = 16
digits à [5, 12, 13]
This algorithm returns a list of the digits in the specified base b (a representation of n10 in base b)
Usually we want to return an encoded number where digits higher than 9 use letters such as A..Z
We simply need to decide what character to use for the various digits in the base.
Copyright © MathByte Academy

Encodings
But we don't have to use letters or even standard 0-9 digits to encode our number.
Typically, we use 0-9 and A-Z for digits required in bases higher than 10
We just need to map between the digits in our number, to a character of our choice.
0 à 0
1 à 1
…
9 à 9
10 à A
11 à B
…
36 à Z
0 à 0
1 à 1
…
10 à A
11 à B
…
37 à a
38 à b
…
62 à z
0 à a
1 à b
…
9 à i
10 à #
11 à !
…
36 à *
Python uses 0-9 and a-z (case insensitive)
and is therefore limited to base <= 36
Your choice of characters to represent the digits, is your encoding map
Copyright © MathByte Academy

The simplest way to do this given a list of digits to encode, is to create a string with as many 
characters as needed, and use their index (ordinal position) for our encoding map
digits = [ … ]
base b (>=2)
map = '0123456789ABC'
map = ' … ' (of length b)
encoding = map[digits[0]] + map[digits[1]] + …
digits = [4, 11, 3, 12] 
10
Example: Base 12
11
12
encoding = '4B3C'
Encodings
Copyright © MathByte Academy

Encoding Algorithm
digits = [ … ]
map = ' … '
encoding = ''.join([map[d] for d in digits])
encoding = ''
for d in digits:
encoding += map[d]
(a += b à a = a + b)
or, more simply:
we'll cover this in much more detail in the section on lists
Copyright © MathByte Academy

Copyright © MathByte Academy

Base Change Algorithm
n = base-10 number (>= 0)
if b < 2 or n < 0: raise exception
if n == 0: return [0]
digits = [ ]
while n > 0:
m = n % b
n = n // b
digits.insert(0, m)
digits = [ … ]
map = ' … '
encoding = ''.join([map[d] for d in digits])
encoding = ''
for d in digits:
encoding += map[d]
Encoding Algorithm
or, more simply:
Constructor
int(a)
a is a numeric type such as float, Decimal, Fraction, bool, …
int(s, base=10)
s is a string, and base is the base used for the encoded string s
b = base (>= 2)
Copyright © MathByte Academy

Copyright © MathByte Academy

Rational numbers are fractions of integer numbers
1
2
−22
7
8.3
4
Ex:
So
Any real number with a finite number of digits after the decimal point is also a rational number
0.45
à
45
100
is also rational
8.3
4 =
⁄
83 10
4
= 83
10 × 1
4 = 83
40
as is 8.3
1.4
since
8.3
1.4 =
⁄
83 10
⁄
14 10 = 83
10 × 10
14 = 83
14
0.123456789
123456789
109
à
Copyright © MathByte Academy

The Fraction Class
Rational numbers can be represented in Python using the Fraction class in the fractions module
from fractions import Fraction
x = Fraction(3, 4)
y = Fraction(22, 7)
z = Fraction(6, 10)
Fractions are automatically reduced:
Fraction(6, 10) à Fraction(3, 5)
Negative sign, if any, is always attached to the numerator:
Fraction(1, -4) à Fraction(-1, 4)
Copyright © MathByte Academy

Constructors
Fraction(numerator=0, denominator=1)
Fraction(other_fraction)
Fraction(float)
Fraction(decimal)
Fraction(string)
Fraction('10')
à Fraction(10, 1)
Fraction('22/7')
à Fraction(22, 7)
Fraction('0.125')
à Fraction(1, 8)
Copyright © MathByte Academy

Standard arithmetic operators are supported:
+, -, *, /
and result in Fraction objects as well
2
3 × 1
2 = 2
6 = 1
3
Fraction(2, 3) * Fraction(1, 2) à Fraction(1, 3)
2
3 + 1
2 = 4
6 + 3
6 = 7
6
Fraction(2, 3) + Fraction(1, 2) à Fraction(7, 6)
getting the numerator and denominator of Fraction objects:
x = Fraction(22, 7)
x.numerator
à 22
x.denominator
à 7
Copyright © MathByte Academy

float objects have finite precision
any float object can be written as a fraction!
⇒
Fraction(0.75)
à Fraction(3, 4)
à Fraction(11, 8) 
Fraction(1.375)
import math
x = Fraction(math.pi)
y = Fraction(math.sqrt(2))
à Fraction(884279719003555, 281474976710656)
à Fraction(6369051672525773, 4503599627370496)
Even though π and 2 are both irrational
expressible as a rational number
internally represented as floats
⇒
⇒finite precision real number
but it is an approximation
Copyright © MathByte Academy

Converting a float to a Fraction has an important caveat
We'll examine this in detail in a later video on floats
1
8
has an exact float representation
3
10
does not have an exact float representation
Fraction(0.125)
à Fraction(1, 8)
Fraction(0.3)
à Fraction(5404319552844595, 18014398509481984)
format(0.3, '.5f') à 0.30000
format(0.3, '.25f') à 0.2999999999999999888977698
Copyright © MathByte Academy

Constraining the denominator
Given a Fraction object, we can find an approximate equivalent fraction 
with a constrained denominator
using the limit_denominator(max_denominator=1000000) instance method
i.e. finds the closest rational (which could be precisely equal)
with a denominator that does not exceed max_denominator
x = Fraction(math.pi)
à Fraction(884279719003555, 281474976710656)
x.limit_denominator(10)
à Fraction(22, 7)
x.limit_denominator(100)
à Fraction(311, 99)
x.limit_denominator(500)
à Fraction(355, 113)
3.141592653589793
3.142857142857143
3.141414141414141
3.141592920353983
Copyright © MathByte Academy

Copyright © MathByte Academy

The float class is Python's default implementation for representing real numbers
The Python (CPython) float is implemented using the C double type which (usually!) implements
the IEEE 754 double-precision binary float, also called binary64
The float uses a fixed number of bytes
à 8 bytes
(but Python objects have some overhead too)
à 24 bytes
(CPython 3.6 64-bit)
à 64 bits
These 64 bits are used up as follows:
sign
à 1 bit
exponent à 11 bits
significant digits
à 52 bits
à range [-1022, 1023]
à 15-17 significant (base-10) digits
significant digits
à for simplicity, all digits except leading and trailing zeros
1.5E-5 à 1.5 x 10-5
exponent is -5
1.2345
1234.5
12345000000
12345e-50
1.2345e10
0.00012345
Copyright © MathByte Academy

Representation: decimal
Numbers can be represented as base-10 integers and fractions:
0.75
à
%
&' +
(
&''
0.256
à
+
&' +
(
&'' +
,
&'''
à 7 ×10"# + 5 × 10"$
à 2 ×10"# + 5 × 10"$ + 6 × 10"%
2 significant digits
3 significant digits
123.456 à
1×100 + 2 ×10 + 3 ×1 +
#
!$ +
%
!$$ +
&
!$$$
à
1 x 10$ + 2 ×10# + 3 ×10& + 4 ×10"# + 5 × 10"$ + 6 × 10"%
6 significant digits
In general:
2 =
4
'()*
+
2' × 10'
sign = 0 for positive
sign = 1 for negative
2 = (−1),'-+ 4
'()*
+
2' × 10'
Copyright © MathByte Academy

Some numbers cannot be represented using a finite number of terms
2 = (−1),'-+ 4
'()*
+
2' × 10'
but even some rational numbers
1
3 = 0.33 ̇3
= 3
10 +
3
100 +
3
1000 + …
Obviously numbers such as
2 = 1.4142 …
? = 3.14159 …
Copyright © MathByte Academy

Representation: binary
Numbers in a computer are represented using bits, not decimal digits
à instead of powers of 10, we need to use powers of 2
0.11 .
=
1
2 + 1
4 !$
=
1 × 2)! + 1 × 2). !$
This representation is very similar to the one we use with decimal numbers
but instead of using powers of 10, we use powers of 2
=
0.5 + 0.25
!$
=
0.75
!$
Similarly,
0.1101 .
=
1
2 + 1
4 + 0
8 + 1
16 !$
=
1 × 2)! + 1 × 2). + 0 × 2)" + 1 × 2)# !$
=
0.5 + 0.25 + 0.0625
!$
=
0.8125
!$
a binary representation
2 = (−1),'-+ 4
'()*
+
2' × 2'
Copyright © MathByte Academy

The same problem that occurs when trying to represent 
!
" using a decimal expansion also 
happens when trying to represent certain numbers using a binary expansion
0.1 = 1
10
Using binary fractions, this number does not have a finite representation
0.1 !$ = 0. 0 0011 0011 0011 …
.
= 0
2 +
0
4 + 0
8 + 1
16 + 1
32
+ 0
64 + 0
128 + 1
256 + 1
512 +
0
1024 +
0
2048 +
1
4096 +
1
8192 +
…
= 1
16 + 1
32 + 1
256 + 1
512 +
1
4096 +
1
8192 +
…
= 0.0625 + 1
32 + 1
256 + 1
512 +
1
4096 +
1
8192 +
…
base 10
= 0.09375 + 1
256 + 1
512 +
1
4096 +
1
8192 +
…
= 0.09765625 + 1
512 +
1
4096 +
1
8192 +
…
= 0.099609375 +
1
4096 +
1
8192 +
…
= 0.0999755859375 +
…
Copyright © MathByte Academy

So, some numbers that do have a finite decimal representation, 
0.75
!$ =
0.11 .
0.8125
!$ = 0.1101 .
0.1 !$ = 0 0011 0011 0011 …
.
finite
finite
infinite
exact float representation
approximate float representation
do not have a finite binary representation, 
and some do
Copyright © MathByte Academy

Copyright © MathByte Academy

In the previous video we saw that some decimal numbers (with a finite representation)
cannot be represented with a finite binary representation
This can lead to some "weirdness" and bugs in our code (but not a Python bug!!)
x = 0.1 + 0.1 + 0.1
y = 0.3
x == y
à False
format(x, '.25f')
format(y, '.25f')
à 0.3000000000000000444089210
à 0.2999999999999999888977698
Using rounding will not necessarily solve the problem either!
It is no more possible to exactly represent round(0.1, 1) than 0.1 itself
round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)
à False
But it can be used to round the entirety of both sides of the equality comparison
round(0.1 + 0.1 + 0.1, 5) == round(0.3, 5)
à True
Copyright © MathByte Academy

To test for "equality" of two different floats, you could do the following methods:
round both sides of the equality expression to the number of significant digits
round(a, 5) == round(b, 5)
or, more generally, use an appropriate range (ε) within which two numbers are deemed equal
for some B > 0,
D = E
if and only if
D −E < B
def is_equal(x, y, eps)
return math.fabs(x-y) < eps
This can be tweaked by specifying that the difference between the two numbers
be a percentage of their size à the smaller the number, the smaller the tolerance
i.e. are two numbers within x% of each other?
But there are non-trivial issues with using these seemingly simple tests
à numbers very close to zero vs away from zero
Copyright © MathByte Academy

x = 0.1 + 0.1 + 0.1
y = 0.3
print(format(x, '.20f'))
print(format(y, '.20f'))
à 0.29999999999999998890
à 0.30000000000000004441
a = 10000.1 + 10000.1 + 10000.1
b = 30000.3
print(format(a, '.20f'))
print(format(b, '.20f'))
à 30000.30000000000291038305
à 30000.29999999999927240424
12th digit after decimal pt
17th digit after decimal pt
Using an absolute tolerance: abs_tol = 10-15 = 0.000000000000001
then
math.fabs(x - y) < abs_tol
math.fabs(a - b) < abs_tol
à True
à False
Using absolute tolerances…
Δ = 0.00000000000000005551
Δ = 0.00000000000363797881
0.000000000000001
0.000000000000001
Copyright © MathByte Academy

Maybe we should use relative tolerances…
x = 0.1 + 0.1 + 0.1
y = 0.3
a = 10000.1 + 10000.1 + 10000.1
b = 30000.3
Using a relative tolerance: rel_tol = 0.001% = 0.00001 = 1e-5
i.e. maximum allowed difference between the two numbers,
relative to the larger magnitude of the two numbers
tol = rel_tol * max(|x|, |y|)
à tol = 0.000003000000000 
à tol = 0.300003000000000 
math.fabs(x - y) < tol
math.fabs(a - b) < tol
à True
à True
Success!
but is it really?
Copyright © MathByte Academy

x = 0.0000000001
y = 0
Using a relative tolerance: rel_tol = 0.1% = 0.0001 = 1e-3
tol = rel_tol * max(|x|, |y|)
math.fabs(x - y) < abs_tol
à False
So using absolute and relative tolerances, in isolation, makes it
difficult to get a one-size-fits-all solution
à tol = rel_tol * |x|
à 1e-3 * 1e-10 = 1e-13 
(1e-10)
Using a relative tolerance technique does not work well for numbers close to zero!
We can combine both methods
and using the larger of the two tolerances
calculating the absolute and relative tolerances
tol = max(rel_tol * max(|x|, |y|), abs_tol)
à PEP 485
Copyright © MathByte Academy

math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0) 
The math module has that solution for us!
à PEP 485
If you do not specify abs_tol, then it defaults to 0 and you will face the problem
we encountered in the last slide when comparing numbers close to zero.
x = 1000.0000001
y = 1000.0000002
math.isclose(x, y)
à True
a = 0.0000001
b = 0.0000002
math.isclose(a, b)
à False
but
math.isclose(x, y, abs_tol=1e-5) à True
math.isclose(a, b, abs_tol=1e-5)
à True
Copyright © MathByte Academy

x = 1000.01
y = 1000.02
a = 0.01
b = 0.02
If you are going to be using this method, you should
play around with it for a while until you get a good feel
for how it works
Also works well in situations like this:
math.isclose(x, y, rel_tol=1e-5, abs_tol=1e-5)
à True
math.isclose(x, y, rel_tol=1e-5, abs_tol=1e-5)
à False
Copyright © MathByte Academy

Copyright © MathByte Academy

Float à Integer
data loss
different ways to configure this data loss
10.4
10.5
10.6
10?
11?
truncation
floor
rounding
pick your poison!
ceiling
data loss in all cases
10.0001
10.9999
Copyright © MathByte Academy

Truncation
truncating a float simply returns the integer portion of the number
i.e. ignores everything after the decimal point
The math module provides us the trunc() function:
import math
math.trunc(10.4) à 10
math.trunc(10.5) à 10
math.trunc(10.6) à 10
math.trunc(-10.4) à -10
math.trunc(-10.5) à -10
math.trunc(-10.6) à -10
Copyright © MathByte Academy

The int Constructor
The Python int constructor will accept a float
uses truncation when casting the float to an int
int(10.4) à 10
int(10.5) à 10
int(10.6) à 10
int(-10.4) à -10
int(-10.5) à -10
int(-10.6) à -10
Copyright © MathByte Academy

Floor
Definition: the floor of a number is the largest integer less than (or equal to) the number
Gloor K = max O ∈ℤ| O ≤K
10
11
x = 10.4
floor
-11
-10
x = -10.4
floor
Recall also our discussion on integer division – aka floor division: //
For positive numbers, floor and truncation are equivalent but not for negative numbers!
We defined floor division in combination with the mod operation
n = d * (n // d) + (n % d)
But in fact, floor division defined that way yields the same result 
as taking the floor of the floating point division
a // b == floor (a / b)
Copyright © MathByte Academy

Floor
The math module provides us the floor() function:
import math
math.floor(10.4) à 10
math.floor(10.5) à 10
math.floor(10.6) à 10
math.floor(-10.4) à -11
math.floor(-10.5) à -11
math.floor(-10.6) à -11
-11
-10
x = -10.4
floor
10
11
x = 10.4
floor
Copyright © MathByte Academy

Ceiling
Definition: the ceiling of a number is the smallest integer greater than (or equal to) the number
ceil K = min O ∈ℤ| O ≥K
10
11
x = 10.4
ceiling
ceiling
-11
-10
x = -10.4
math.ceil(10.4) à 11
math.ceil(10.5) à 11
math.ceil(10.6) à 11
math.ceil(-10.4) à -10
math.ceil(-10.5) à -10
math.ceil(-10.6) à -10
Copyright © MathByte Academy

Copyright © MathByte Academy

The round() function
round(x, n=0)
Python provides a built-in rounding function:
This will round the number x to the closest multiple of 10)+
you might think of this as rounding to a certain number of digits after the decimal point
which would work for positive n, but n can, in fact, also be negative!
In addition to truncate, floor, and ceiling, we can therefore also use rounding (with n = 0) to 
coerce a float to an integer number
If n is not specified, then it defaults to zero and round(x) will therefore return an int
round(x, n) à same type as x
round(x, 0) à same type as x
round(x) à int
Copyright © MathByte Academy

n = 0
round to the closest multiple of 10)$ = 1
1
2
x = 1.23
closest
0.23
0.77
round(1.23) à 1
Copyright © MathByte Academy

n > 0
n = 1
round to the closest multiple of 10)! = 0.1
1.2
1.3
x = 1.23
closest
0.03
0.07
round(1.23, 1) à 1.2
Copyright © MathByte Academy

n < 0
n = -1
round to the closest multiple of 10)()!) = 10
10
20
x = 18.2
closest
8.2
1.8
round(18.2, -1) à 20
Copyright © MathByte Academy

Ties
1.2
1.3
x = 1.25
0.05
0.05
there is no closest value!!
round(1.25, 1) = ???
We probably would expect round(1.25, 1) to be 1.3
But in fact:
round(1.25, 1)
round(1.35, 1) à 1.4
Similarly, we would expect round(-1.25, 1) to result in -1.3
This type of rounding is called rounding to nearest, with ties away from zero
rounding up
/ away from zero
rounding down
/ away from zero
round(-1.25, 1) à -1.2
round(-1.35, 1) à -1.4
à 1.2
towards 0
away from 0
towards 0
away from 0
Copyright © MathByte Academy

Banker's Rounding
IEEE 754 standard:
rounds to the nearest value, with ties rounded to the nearest value with an 
even least significant digit
1.2
1.3
x = 1.25
0.05
0.05
round(1.25, 1)
2 is even
à 1.2
1.3
1.4
x = 1.35
round(1.35, 1)
4 is even
à 1.4
0.05
0.05
Copyright © MathByte Academy

n = -1
round to the closest multiple of 10)()!) = 10
10
20
x = 15
5
5
round(15, -1) à 20
2 is even
20
30
x = 25
5
5
round(25, -1) à 20
2 is even
Copyright © MathByte Academy

Why Banker's Rounding?
Less biased rounding than ties away from zero
Consider averaging three numbers, and averaging the rounded  value of each:
0.5, 1.5, 2.5
à avg = 4.5 / 3 = 1.5
"standard" rounding:
1,   2,   3
à avg = 6 / 3 = 2
banker's rounding:
0,   2,   2
à avg = 4 / 3 = 1.3…
Copyright © MathByte Academy

If you really insist on rounding away from zero…
One common (and partially incorrect) way to round to nearest unit that often comes up 
on the web is:
int(x + 0.5)
10.3 à int(10.3 + 0.5) = int(10.8) = 10
10.9 à int(10.9 + 0.5) = int(11.4) = 11
10.5 à int(10.5 + 0.5) = int(11.0) = 11
but, this does not work for negative numbers
-10.3 à int(-10.3 + 0.5) = int(-9.8) = -9
-10.9 à int(-10.9 + 0.5) = int(-10.4) = -10
Technically, this is also an acceptable rounding method
referred to as rounding towards + infinity
But this not rounding towards zero !!
-10.5 à int(-10.5 + 0.5) = int(-10.0) = -10
Copyright © MathByte Academy

If you really insist on rounding away from zero…
The correct way to do it:
sign(x) * int(abs(x)+0.5)
sign(x)
int(abs(x)+0.5)
10.5
+
11
11
Python does not have a sign function !
We can however use the math.copysign() function to achieve our goal:
copysign(x, y) returns the magnitude (absolute value) of x but with the sign of y
= int(x + 0.5 * sign(x))
sign K = W+1
if K ≥0
−1
if K < 0
!! Not the same as the 
mathematical sgn
(signum) function!
sign(x) = copysign(1, x)
abs(x)+0.5
10.4
+
10
10
10.9
11.0
10.6
+
11
11
11.1
-10.4
-
10
-10
10.9
-10.5
-
11
-11
11.0
-10.6
-
11
-11
11.5
sign(x) * int(abs(x)+0.5)
Copyright © MathByte Academy

def round_up(x):
from math import fabs, copysign
return copysign(1, x) * int(fabs(x) + 0.5)
A simpler way to code this:
def round_up(x):
from math import copysign
return int(x + copysign(0.5, x))
sign(x) * int(abs(x)+0.5)
int(x + 0.5 * sign(x))
Copyright © MathByte Academy

Copyright © MathByte Academy

The decimal module
float 0.1
à finite decimal expansion
à infinite binary expansion
0.1 !$ = 0. 0 0011 0011 0011 …
.
= 1
16 + 1
32 + 1
256 + 1
512 +
1
4096 +
1
8192 +
…
0.1 !$ = 1
10
(PEP 327)
alternative to using the (binary) float type
à avoids the approximation issues with floats
finite number of significant digits
à rational number
(see videos on rationals)
to add two fractions
à common denominator 
So why not just use the Fraction class?
à complex, requires extra memory
Copyright © MathByte Academy

Why do we even care?
Why not just use binary floats?
finance, banking, and any other field where exact finite representations are highly desirable
amount = $100.01
let's say we are adding up all the financial transactions that took place over a certain time period
1,000,000,000 transactions
100.01 à 100.0100000000000051159076975 
sum à
$100009998761.1463928222656250000000000
$100010000000.00
$1238.85… off!!
(exact decimal)
(approximate binary float)
NYSE: 2-6 billion shares traded daily
Copyright © MathByte Academy

Decimals have a context that controls certain aspects of working with decimals
precision during arithmetic operations
rounding algorithm
This context can be global
à the default context
or temporary (local)
à sets temporary settings without affecting the global settings
default context
à decimal.getcontext()
local context
à decimal.localcontext(ctx=None)
import decimal
creates a new context, copied from ctx
or from default if ctx not specified
returns a context manager (use a with statement)
Copyright © MathByte Academy

Precision and Rounding
ctx = decimal.getcontext()
à context (global in this case)
ctx.prec
à get or set the precision (value is an int)
ctx.rounding
à get or set the rounding mechanism (value is a string)
ROUND_UP
rounds away from zero
ROUND_DOWN
rounds towards zero
ROUND_CEILING
rounds to ceiling (towards +∞)
ROUND_FLOOR
rounds to floor (towards −∞)
ROUND_HALF_UP
rounds to nearest, ties away from zero
ROUND_HALF_DOWN
rounds to nearest, ties towards zero
ROUND_HALF_EVEN
rounds to nearest, ties to even (least significant digit)
float rounding algorithm
Copyright © MathByte Academy

Working with Global and Local Contexts
Global
decimal.getcontext().rounding = decimal.ROUND_HALF_UP
//decimal operations performed here will use the current default context
Local
with decimal.localcontext() as ctx:
ctx.prec = 2
ctx.rounding = decimal.ROUND_HALF_UP
//decimal operations performed here
//will use the ctx context
Copyright © MathByte Academy

Copyright © MathByte Academy

Constructing Decimal Objects
x can be a variety of types
Decimal(x)
The Decimal class is in the decimal module
integers
a = Decimal(10)
import decimal
from decimal import Decimal
other Decimal object
strings
a = Decimal('0.1')
tuples
a = Decimal((1, (3, 1, 4, 1, 5), -4))
à 10
à 0.1
à -3.1415
floats?
yes, but not usually done
Decimal(0.1) à 0.100000000000000005551
Since 0.1 does not have an exact binary float representation
it cannot be used to create an exact Decimal representation
of itself
à Use strings or tuples instead
Copyright © MathByte Academy

Using the tuple constructor
(s, (d1, d2, d3, …), exp)
à +123 x 10-2
1.23
-1.23
à -123 x 10-2
sign
digits
exponent
Z(K) = W0 O[ K ≥0
1 O[ K < 0
Example: -3.1415
à (1, (3, 1, 4, 1, 5), -4)
a = Decimal((1, (3, 1, 4, 1, 5), -4))
a à -3.1415
Copyright © MathByte Academy

Context Precision and the Constructor
Context precision does not affect the constructor
Context precision affects mathematical operations
decimal.getcontext().prec = 2
a = Decimal('0.12345')
a à 0.12345
b = Decimal('0.12345')
b à 0.12345
c = a + b
c à 0.25
a + b = 0.2469
import decimal
from decimal import Decimal
ß global (default) context now has precision set to 2
Copyright © MathByte Academy

Local vs Global Context
decimal.getcontext().prec = 6
a = Decimal('0.12345')
b = Decimal('0.12345')
print(a + b)
import decimal
from decimal import Decimal
à 0.25
with decimal.localcontext() as ctx:
ctx.prec = 2
c = a + b
print(c)
print(c)
à 0.25
à 0.24690
Copyright © MathByte Academy

Copyright © MathByte Academy

Some arithmetic operators don't work the same as floats or integers
// and %
à also divmod()
The // and % operators still satisfy the usual equation:
n = d * (n // d) + (n % d)
But for integers, the // operator performs floor division
à a // b = floor(a/b)
For Decimals however, it performs truncated division
à a // b = trunc(a/b)
10 // 3 à 3
-10 // 3 à -4
Decimal(10) // Decimal(3) à Decimal(3)
Decimal(-10) // Decimal(3) à Decimal(-3)
negative 
numbers!
Copyright © MathByte Academy

D
E
10
3
- keep subtracting b from a as long as a >= b
- figure out the sign of the result
- use absolute values for divisor and dividend
dividend
divisor
- return the signed number of times this was performed
Boils down to the algorithm used to actually perform integer division
10 - 3
= 7
7 - 3
= 4
7 >= 3
4 >= 3
4 - 3
= 1
1 < 3 - STOP
return 3
res is +
−10
3
10 - 3
= 7
7 - 3
= 4
7 >= 3
4 >= 3
4 - 3
= 1
1 < 3 - STOP
return -3
res is -
this is basically the same as truncating the real division
trunc(10/3) à 3
trunc(-10/3) à -3
Copyright © MathByte Academy

But
n = d * (n // d) + (n % d) is still satisfied
Integer
Decimal
n = -135, d = 4
-135 // 4
-135 % 4
-34
-33
1
-3
d * (n // d) + (n % d)
4 * (-34) + 1 = -135 
4 * (-33) + (-3) = -135 
Copyright © MathByte Academy

Other Mathematical Operations
The Decimal class defines a bunch of various mathematical operations, such as sqrt, logs, etc.
but Decimal objects will first be cast to floats
But not all functions defined in the math module are defined in the Decimal class
E.g. trig functions
We can use the math module, 
– so we lose the whole precision mechanism that made us use Decimal objects in the first place!
Usually will want to use the math functions defined in the Decimal class if they are available
Copyright © MathByte Academy

decimal.getcontext().prec = 28
x = 0.01
x_dec = Decimal('0.01')
print(format(root, '1.27f'))
print(format(root_mixed, '1.27f'))
print(root_dec)
à 0.100000000000000005551115123
à 0.100000000000000005551115123
à 0.1
print(format(root * root, '.27f'))
print(format(root_mixed * root_mixed, '.27f'))
à 0.010000000000000001942890293
à 0.010000000000000001942890293
à 0.01
print(root_dec * root_dec)
root = math.sqrt(x)
root_mixed = math.sqrt(x_dec)
root_dec = x_dec.sqrt()
Copyright © MathByte Academy

Copyright © MathByte Academy

There are some drawbacks to the Decimal class vs the float class
- more memory overhead
- not as easy to code: construction via strings or tuples
- not all mathematical functions that exist in the math module have a Decimal counterpart
- performance: much slower than floats (relatively)
Copyright © MathByte Academy

Copyright © MathByte Academy

The complex class
Constructor:
complex(x, y)
x à real part
y à imaginary part
x + yJ
x + yj
Example:
a = complex(1, 2)
(rectangular coordinates)
b = 1 + 2j
a == b à True
x and y (the real and imaginary parts) are stored as floats
Literals
Copyright © MathByte Academy

Some instance properties and methods
.real
à returns the real part
.imag
à returns the imaginary part
.conjugate() à returns the complex conjugate
d = 2 – 3j
d.real à 2
d.imag à -3
d.conjugate() à 2 + 3j
Copyright © MathByte Academy

Arithmetic Operators
The standard arithmetic operators (+, -, / , *, **) work as expected with complex numbers
(1 + 2j) + (3 + 4j) à 4 + 6j
(1 + 2j) * (3 + 4j) à 5 + 10j
Real and Complex numbers can be mixed:
(1 + 2j) + 3  à 4 + 2j
(1 + 2j) * 3 à 3 + 6j
// and % operators are not supported
Copyright © MathByte Academy

Other operations
The == and != operators are supported
Comparison operators such as <, >, <= and >= are not supported
Functions in the math module will not work
Use the cmath module instead
exponentials
logs
trigs and inverse trigs
hyperbolics and inverse hyperbolics
isclose
polar / rectangular conversions
Copyright © MathByte Academy

Rectangular to Polar
import cmath
cmath.phase(x)
Returns the argument (phase) ^ of the complex number x
^ ∈
−?, ?
measured counter-clockwise from the real axis
abs(x)
Returns the magnitude (`) of x
a = -1 + 0j
cmath.phase(a) à 3.1415… (?)
a = -1j
cmath.phase(a) à -1.570… (−
1
.)
abs(a) à 1
abs(a) à 1
a = 1 + 1j
cmath.phase(a) à 0.785… (
1
#)
abs(a) à 1.414… ( 2)
ℜb
ℐd
K
^
`
Copyright © MathByte Academy

Polar to Rectangular
import cmath
cmath.rect(r, phi)
Returns a complex number (rectangular coordinates)
equivalent to the complex number defined by (r, phi)
in polar coordinates
cmath.rect(math.sqrt(2), math.pi/4)
à 1 + 1j
1.0000000000000002+1.0000000000000002j
Copyright © MathByte Academy

Euler's Identity
!01 + 1 = 0
cmath.exp(cmath.pi * 1j) + 1
à 1.2246467991473532e-16j
binary floats tend to spoil the effect!
So, the next best thing:
cmath.isclose(cmath.exp(cmath.pi*1j) + 1, 0, abs_tol=0.0001)
à True
Do note however the same issue with isclose() as we discussed in the float videos:
cmath.isclose(cmath.exp(cmath.pi*1j) + 1, 0)
à False
Copyright © MathByte Academy

Copyright © MathByte Academy

The bool class
Python has a concrete bool class that is used to represent Boolean values.
However, the bool class is a subclass of the int class
issubclass(bool, int)
PEP 285
Two constants are defined: True and False
They are singleton objects of type bool
True
False
isinstance(True, bool)
isinstance(True, int)
à True
à True
à True
0xF345
1
bool
int
0xA101
0
bool
int
i.e. they posses all the properties and 
methods of integers, and add some 
specialized ones such as and, or, etc
Copyright © MathByte Academy

is vs ==
Because True and False are singleton objects, they will always retain their same memory address
throughout the lifetime of your application
So, comparisons of any Boolean expression to True and False can be performed using 
either the is (identity) operator, or the == (equality) operator
a == True
a is True
But since bool objects are also int objects, they can also be interpreted as the integers 1 and 0
int(True) à 1
int(False) à 0
But:
True and 1 are not the same objects
False and 0 are not the same objects
True is 1
à False
True == 1
à True
id(True) ≠id(1)
id(False) ≠id(0)
where a is a bool object
Copyright © MathByte Academy

Booleans as Integers
This can lead to "strange" behavior you may not expect!
True > False
à True
In fact, any integer operation will also work with booleans (//, %, etc)
True + True + True à 3
(True + True + True) % 2 à 1
-True à -1
100 * False à 0
(1 == 2) == False
(1 == 2) == 0
à True
à True
Copyright © MathByte Academy

The Boolean constructor
The Boolean constructor
bool(x)
returns True when x is True, 
Wow, that sounds like a useless constructor!
What really happens is that many classes contain a definition of how to cast instances of 
themselves to a Boolean
Integers have a truth value defined according to this rule:
bool(0) à False
bool(x) à True for any int x ≠0
and False when x is False
But not at all!
– this is sometimes called the truth value (or truthyness) of an object
(upcoming video)
(0 is falsy)
(x is truthy)
Copyright © MathByte Academy

Examples
bool(0) à False
bool(1) à True
bool(100) à True
bool(-1) à True
Copyright © MathByte Academy

Copyright © MathByte Academy

Objects have Truth Values
All objects in Python have an associated truth value
We already saw this with integers
(although to be fair, bool is a subclass of int)
But this works the same for any object
In general, the rules are straightforward
Every object has a True truth value, except:
•
None
•
False
•
0 in any numeric type (e.g. 0, 0.0, 0+0j, …)
•
empty sequences (e.g. list, tuple, string, …)
•
empty mapping types (e.g. dictionary, set, …)
•
custom classes that implement a __bool__ or __len__
method that returns False or 0
which have a False truth value
Copyright © MathByte Academy

Classes define their truth values by defining a special instance method:
__bool__(self)
We will cover this and many other special functions in a later section
When we call bool(100) Python actually executes 100.__bool__()
and therefore returns the result of 100 != 0
which is True
Under the hood
Then, when we call
bool(x)
Python will actually executes x.__bool__()
Example: Integers
def __bool__(self):
return self != 0
(or __len__ )
When we call bool(0)
Python actually executes 0.__bool__()
and therefore returns the result of 0 != 0
which is False
or __len__ if __bool__ is not defined 
if neither is defined, then True
Copyright © MathByte Academy

Examples
bool([1, 2, 3]) à True
bool([]) à False
bool(None) à False
if my_list:
# code block
code block will execute if and only if my_list is 
both not None and not empty
this is equivalent to:
if my_list is not None and len(my_list) > 0:
# code block
bool('abc') à True
bool('') à False
bool(0) à False
bool(0 + 0j) à False
bool(Decimal('0.0') à False
bool(-1) à True
bool(1 + 2j) à True
bool(Decimal('0.1') à True
Copyright © MathByte Academy

Copyright © MathByte Academy

The Boolean Operators: not, and, or
X
Y
not X
X and Y
X or Y
0
0
1
0
0
0
1
1
0
1
1
0
0
0
1
1
1
0
1
1
X
Y
X or Y
X
Y
X and Y
open
False
closed
True
True
False
True
False
True
False
Copyright © MathByte Academy

De Morgan's Theorem
not(A or B) == (not A) and (not B)
not(A and B) == (not A) or (not B)
Commutativity
A or (B or C) == (A or B) or C
A and (B and C) == (A and B) and C
A or B == B or A
A and B == B and A
Associativity
not(x < y) == x >= y
not(x > y) ==
x <= y
Miscellaneous
not(x <= y) == x > y
not(x >= y) ==
x < y
A or B or C
A and B and C
à (A or B) or C
à (A and B) and C
left-to-right evaluation
not(not A) == A
Distributivity
A and (B or C) == (A and B) or (A and C)
A or (B and C) == (A or B) and (A or C)
Copyright © MathByte Academy

Operator Precedence
or
and
not
highest
lowest
precedence
True or True and False
à True or False
à True
(True or True) and False
à True and False
à False
When in doubt, or to be absolutely sure, use parentheses!
Also, use parentheses to make your code more human readable!
a < b or a > c and not x or y
(a < b) or ((a > c) and (not x)) or y
< > <= >= == != in is
()
True or (True and False)
Copyright © MathByte Academy

Short-Circuit Evaluation
X
Y
X or Y
0
0
0
0
1
1
1
0
1
1
1
1
if X is True, then X or Y will be True no matter the value of Y
So, X or Y will return True without evaluating Y if X is True
X
Y
X and Y
0
0
0
0
1
0
1
0
0
1
1
1
if X is False, then X and Y will be False no matter the value of Y
So, X and Y will return False without evaluating Y if X is False
X
Y
X or Y
X
Y
X and Y
True
Y
True
False
Y
False
Copyright © MathByte Academy

Example
Scenario:
There is some data feed that lists a stock symbol, and some financial data.
Your job is to monitor this feed, looking for specific stock symbols defined in some watch 
list, and react only if the current stock price is above some threshold. Getting the current 
stock price has an associated cost.
if symbol in watch_list:
if price(symbol) > threshold:
# do something
If Boolean expressions did not implement short-circuiting, you would probably write:
since calling the price() method has a cost, 
you would only want to call it if the symbol was 
on your watch list
But because of short-circuit evaluation you could write this equivalently as:
if symbol in watch_list and price(symbol) > threshold:
# do something
Copyright © MathByte Academy

Example
name is a string returned from a nullable text field in a database
perform some action if the first character of name is a digit (0-9)
if name and name[0] in string.digits:
# do something
because of short-circuiting and truth values
if name is falsy (either None or an empty string) 
then 
name[0] in string.digits
is not evaluated
this code will break if name is None or an 
empty string
if name[0] in string.digits:
# do something
null à None
''
'abc'
Copyright © MathByte Academy

Copyright © MathByte Academy

Boolean Operators and Truth Values
X
Y
X and Y
X or Y
0
0
0
0
0
1
0
1
1
0
0
1
1
1
1
1
Normally, Boolean operators are defined to operate on and 
return Boolean values
True or False à True
a = 2
b = 3
a > 0 and b < 5 à True
But every object in Python has a truth value (truthiness)
so, for any object X and Y, we could also write
bool(X) and bool(Y)
bool(X) or bool(Y)
In fact, we don't need to use bool()
X and Y
X or Y
So, what is returned when evaluating these expressions?
A Boolean?
No!
Copyright © MathByte Academy

Definition of or in Python
X or Y
If X is truthy, returns X, otherwise returns Y
Does this work as expected when X and Y are Boolean values?
X
Y
X or Y
0
0
0
0
1
1
1
0
1
1
1
1
X is False, so return Y
0
X is False, so return Y
1
X is True, so return X
1
0
0
0
1
1
0
1
1
X is True, so return X
1
X
Y
Result
Rule
If X is truthy, returns X, otherwise evaluates Y and returns it
Copyright © MathByte Academy

Definition of and in Python
X and Y
If X is falsy, returns X, otherwise returns Y
Does this work as expected when X and Y are Boolean values?
X
Y
X and Y
0
0
0
0
1
0
1
0
0
1
1
1
0
0
X is False, so return X
0
0
1
X is False, so return X
0
1
0
X is True, so return Y
0
1
1
X is True, so return Y
1
X
Y
Result
Rule
If X is falsy, returns X, otherwise evaluates Y and returns it
Copyright © MathByte Academy

Consequence: or
X or Y
X
Y
X or Y
None
'N/A'
'N/A'
''
'N/A'
'N/A'
'hello'
'N/A'
'hello'
a = s or 'N/A'
if s is None
a à N/A
if s is ''
a à N/A
if s is a string 
with characters
a à s
i.e. a will either be s or 'N/A' if s is None or an empty string
If X is truthy, returns X, otherwise evaluates and returns Y
Copyright © MathByte Academy

Example
We can expand this further:
a = s1 or s2 or s3 or 'N/A'
In this case, a will be equal to the first truthy value
and is guaranteed to have a value, since 'N/A' is truthy
Example
We have an integer variable a that cannot be zero – if it is zero, we want to set it to 1.
a = a or 1
(left to right evaluation)
Copyright © MathByte Academy

Consequence: and
X and Y
If X is falsy, returns X, otherwise evaluates and returns Y
X
Y
X and Y
10
20/X
2
0
20/X
0
Seems like we are able to avoid a division by zero error using the and operator
a = 10
x = a and total/a
à
x = 10 and total/10
à total/10
a = 0
à
x = 0 and total/0
à 0
Copyright © MathByte Academy

Example
Computing an average
sum, n
Sometimes n is non-zero, sometimes it is
In either case:
avg = n and sum/n
Example
You want to return the first character of a string s, or an empty string if the string is None or empty
if s:
return s[0]
else:
return '' 
Option 1
Option 2
return s and s[0]
à doesn’t handle None case
return (s and s[0]) or ''
Copyright © MathByte Academy

The Boolean not
not is a built-in function that returns a Boolean value
not x
à True if x is falsy
à False if x is truthy
[] à falsy
not [] à True
[1, 2] à truthy
not [1, 2] à False
None à falsy
not None à True
Copyright © MathByte Academy

Copyright © MathByte Academy

Categories of Comparison Operators
==
!=
is
is not
Value Comparisons
Membership Operations
in
not in
Ordering  Comparisons
<
<=
>
>=
Identity Operations
compares memory address – any type
compares values – different types OK,
but must be compatible
doesn't work for all types
used with iterable types
•
binary operators
•
evaluate to a bool value
Copyright © MathByte Academy

Numeric Types
We will examine other types, including iterables, later in this course
Mixed types (except complex) in value and ordering comparisons is supported
Note:
Value equality operators work between floats and Decimals, but as we have seen 
before, using value equality with floats has some issues!
10.0 == Decimal('10.0')
0.1 == Decimal('0.1')
True == 1
Decimal('0.125') == Fraction(1, 8)
True == Fraction(3, 3)
à True
à False
à True
à True
à True
Value comparisons will work with all numeric types
Copyright © MathByte Academy

Ordering Comparisons
Again, these work across all numeric types, except for complex numbers
1 < 3.14
Fraction(22, 7) > math.pi
Decimal('0.5') <= Fraction(2, 3)
True < Decimal('3.14')
Fraction(2, 3) > False
à True
à True
à True
à True
à True
Copyright © MathByte Academy

Chained Comparisons
à True
a < b < c
a == b == c
à
a == b and b == c
à
a < b and b < c
1 == Decimal('1.0') == Fraction(1,1)
1 == Decimal('1.5') == Fraction(3, 2)
à False
1 < 2 < 3
à True
à 1 < 2 and 2 < 3
1 < math.pi < Fraction(22, 7)
à True
à 1 < math.pi and math.pi < Fraction(22, 7)
Copyright © MathByte Academy

Chained Comparisons
a < b > c
à a < b and b > c
5 < 6 > 2
à 5 < 6 and 6 > 2
à True
5 < 6 > 10
à 5 < 6 and 6 > 10
à False
a < b < c < d
à a < b and b < c and c < d
1 < 2 < 3 < 4
à 1 < 2 and 2 < 3 and 3 < 4
à True
1 < 10 > 4 < 5
à 1 < 10 and 10 > 4 and 4 < 5
à True
if my_min == cnt < val > other <= my_max not in lst:
# do something
Copyright © MathByte Academy

Copyright © MathByte Academy

Arguments vs Parameters
Positional vs Keyword-Only Arguments
Optional Arguments via Defaults
Unpacking Iterables and Function Arguments
Extended Unpacking
Variable Number of Positional and Keyword-Only Arguments
Copyright © MathByte Academy

Copyright © MathByte Academy

Semantics!
def my_func(a, b):
# code here
In this context, a and b are called parameters of my_func
Also note that a and b are variables, local to my_func
When we call the function:
x = 10
y = 'a'
my_func(x, y)
x and y are called the arguments of my_func
Also note that x and y are passed by reference
i.e. the memory addresses of x and y are passed
It's OK if you mix up these terms – everyone will understand what you mean!
Copyright © MathByte Academy

x = 10
y = 'a'
my_func(x, y)
def my_func(a, b):
# code here
10
Module Scope
x
y
Function Scope
a
b
0xA13F
'a'
0xE345
Copyright © MathByte Academy

Copyright © MathByte Academy

Most common way of assigning arguments to parameters: via the order in which they are passed
def my_func(a, b):
# code …
my_func(10, 20)
à a = 10, b = 20
my_func(20, 10)
à a = 20, b = 10
Positional Arguments
i.e. their position
Copyright © MathByte Academy

Default Values
A positional arguments can be made optional by specifying a default value for the 
corresponding parameter
def my_func(a, b=100):
# code …
my_func(10, 20)
à a = 5, b = 100
my_func(5)
à a = 10, b = 20
Consider a case where we have three arguments, and we want to make one of them optional:
def my_func(a, b=100, c):
# code …
How would we call this function without specifying a value
for the second parameter?
my_func(5, 25) ???
If a positional parameter is defined with a default value
every positional parameter after it
must also be given a default value
Copyright © MathByte Academy

Default Values
def my_func(a, b=5, c=10):
# code …
my_func(1)
à a = 1, b = 5, c = 10
my_func(1, 2)
à a = 1, b = 2, c = 10
my_func(1, 2, 3)
à a = 1, b = 2, c = 3
But what if we want to specify the 1st and 3rd arguments, but omit the 2nd argument?
i.e. we want to specify values for a and c, but let b take on its default value?
à Keyword Arguments
my_func(a=1, c=2)
à a = 1, b = 5, c = 2
my_func(1, c=2)
à a = 1, b = 5, c = 2
(named arguments)
Copyright © MathByte Academy

Keyword Arguments
Positional arguments can, optionally, be specified by using the parameter name
whether or not the parameters have default values
def my_func(a, b, c)
my_func(1, 2, 3)
my_func(1, 2, c=3)
my_func(a=1, b=2, c=3)
my_func(c=3, a=1, b=2)
But once you use a named argument, all arguments thereafter must be named too
my_func(c=1, 2, 3)
my_func(1, b=2, 3)
my_func(1, b=2, c=3)
à a=1, b=2, c=3
my_func(1, c=3, b=2)
Copyright © MathByte Academy

Keyword Arguments
All arguments after the first named (keyword) argument, must be named too
Default arguments may still be omitted
def my_func(a, b=2, c=3)
my_func(1)
my_func(a=1, b=5)
à a=1, b=2, c=3
my_func(c=0, a=1)
à a=1, b=5, c=3
à a=1, b=2, c=0
Copyright © MathByte Academy

Copyright © MathByte Academy

A Side Note on Tuples
What defines a tuple in Python, is not (), but ,
(1, 2, 3)
1, 2, 3
is also a tuple
à (1, 2, 3)
The () are used to make the tuple clearer
To create a tuple with a single element:
(1)
will not work as intended
à int
1,
or 
(1, )
à tuple
The only exception is when creating an empty tuple:
()
or
tuple()
Copyright © MathByte Academy

Packed Values
Packed values refers to values that are bundled together in some way
Tuples and Lists are obvious
t = (1, 2, 3)
l = [1, 2, 3]
Even a string is considered to be a packed value:
s = 'python'
Sets and dictionaries are also packed values:
set1 = {1, 2, 3}
d = {'a': 1, 'b': 2, 'c': 3}
In fact, any iterable can be considered a packed value
Copyright © MathByte Academy

Unpacking Packed Values
Unpacking is the act of splitting packed values into individual variables contained in a list or tuple
a, b, c = [1, 2, 3]
this is actually a tuple of 3 variables: a, b and c
3 elements in [1, 2, 3]
à need 3 variables to unpack
a à 1
b à 2
c à 3
Does this remind you of how positional arguments were assigned to parameters in function calls?
The unpacking into individual variables is based on the relative positions of each element
Copyright © MathByte Academy

Unpacking other Iterables
a, b, c = 'XYZ'
à a = 'X'    b = 'Y'    c = 'Z'
a, b, c = 10, 20, 'hello'
à a = 10   b = 20   c = 'hello'
this is actually a tuple containing 3 values
In fact, unpacking works with any iterable type
for e in 'XYZ'
à loop returns 'X', 'Y', 'Z'
for e in 10, 20, 'hello'
à loop returns 10, 20, 'hello'
a, b = 10, 20
a = 10
b = 20
instead of writing
we can write
Copyright © MathByte Academy

Simple Application of Unpacking
swapping values of two variables
"traditional" approach
a = 10
b = 20
à
b = 20
a = 10
tmp = a
a = b
b = tmp
using unpacking
a, b = b, a
10
0x123
20
0xF12
a
b
tmp
this works because in Python, the entire 
RHS is evaluated first and completely
then assignments are made to the LHS
Copyright © MathByte Academy

Unpacking Sets and Dictionaries
d = {'key1': 1, 'key2': 2, 'key3': 3}
for e in d
à e iterates through the keys: 'key1', 'key2', 'key3'
so, when unpacking d, we are actually unpacking the keys of d
a, b, c = d
à a = 'key1', b = 'key2', c='key3'
à a = 'key2', b = 'key1', c='key3'
à a = 'key3', b = 'key1', c='key2'
or
or
etc…
Dictionaries (and Sets) are unordered types. 
They can be iterated, but there is no guarantee the order of the results will match your literal!
In practice, we rarely unpack sets and dictionaries in precisely this way.
Copyright © MathByte Academy

Example using Sets
s = {'p', 'y', 't', 'h', 'o', 'n'}
for c in s:
print(c)
p
t
h
n
o
y
à
a, b, c, d, e, f = s
a = 'p'
b = 't'
c = 'h'
…
f = 'y'
Copyright © MathByte Academy

*
**
Copyright © MathByte Academy

The use case for *
We don't always want to unpack every single item in an iterable
We may, for example, want to unpack the first value, and then unpack the remaining values into 
another variable
l = [1, 2, 3, 4, 5, 6]
We can achieve this using slicing:
b = l[1:]
a = l[0]
or, using simple unpacking:
a, b = l[0], l[1:]
We can also use the * operator:
a, *b = l
Apart from cleaner syntax, it also works with any iterable, not just sequence types!
Much of this section applies to Python >= 3.5
(aka parallel assignment)
Copyright © MathByte Academy

Usage with ordered types
a, *b = [-10, 5, 2, 100]
a = -10
b = [5, 2, 100]
a, *b = (-10, 5, 2, 100)
a = -10
b = [5, 2, 100]
this is still a list!
a, *b = 'XYZ'
a = 'X'
b = ['Y', 'Z']
The following also works:
a, b, *c = 1, 2, 3, 4, 5
a = 1
b = 2
c = [3, 4, 5]
a, b, *c, d = [1, 2, 3, 4, 5]
a = 1
b = 2
c = [3, 4]
d = 5
a, *b, c, d = 'python'
a = 'p'
c = 'o'
b = ['y', 't', 'h']
d = 'n'
this is also a list!
Copyright © MathByte Academy

The * operator can only be used once in the LHS an unpacking assignment
For obvious reason, you cannot write something like this:
a, *b, *c = [1, 2, 3, 4, 5, 6]
Since both *b and *c mean "the rest", both cannot exhaust the remaining elements
Copyright © MathByte Academy

Usage with ordered types
We have seen how to use the * operator in the LHS of an assignment to unpack the RHS
However, we can also use it this way:
l1 = [1, 2, 3]
l2 = [4, 5, 6]
l = [*l1, *l2]
à l = [1, 2, 3, 4, 5, 6]
l1 = [1, 2, 3]
l2 = 'XYZ'
l = [*l1, *l2]
à l = [1, 2, 3, 'X', 'Y', 'Z']
a, *b, c = {1, 2, 3, 4, 5}
Copyright © MathByte Academy

Usage with unordered types
Types such as sets and dictionaries have no ordering
s = {10, -99, 3, 'd'}
print(s)
à {10, 3, 'd', -99}
But, the * operator still works, since it works with any iterable
s = {10, -99, 3, 'd'}
a, *b, c = s
a = 10
b = [3, 'd']
c = -99
Sets and dictionary keys are still iterable, but iterating has no guarantee of preserving 
the order in which the elements were created/added
In practice, we rarely unpack sets and dictionaries directly in this way.
Copyright © MathByte Academy

Usage with unordered types
It is useful though in a situation where you might want to create single collection containing all the 
items of multiple sets, or all the keys of multiple dictionaries
d1 = {'p': 1, 'y': 2}
d2 = {'t': 3, 'h': 4}
d3 = {'h': 5, 'o': 6, 'n': 7}
Note that the key 'h' is in both d2 and d3
l = [*d1, *d2, *d3]
à ['p', 'y', 't', 'h', 'h', 'o', 'n']
s = {*d1, *d2, *d3}
à {'p', 'y', 't', 'h, 'o', 'n'}
(order is not guaranteed)
Copyright © MathByte Academy

The ** unpacking operator
When working with dictionaries we saw that * essentially iterated the keys
d = {'p': 1, 'y': 2, 't': 3, 'h': 4}
a, *b = d
a = 'p'
b = ['y', 't', 'h']
(again, order is not guaranteed)
We might ask the question: can we unpack the key-value pairs of the dictionary?
Yes!
We need to use the ** operator
Copyright © MathByte Academy

d1 = {'p': 1, 'y': 2}
d2 = {'t': 3, 'h': 4}
d3 = {'h': 5, 'o': 6, 'n': 7}
Note that the key 'h' is in both d2 and d3
d = {**d1, **d2, **d3}
à {'p': 1, 'y': 2, 't': 3, 'h': 5, 'o': 6, 'n': 7}
Note that the value of 'h' in d3 "overwrote" the first value of 'h' found in d2
Using **
(order not guaranteed)
(note that the ** operator cannot be used in the LHS of an assignment)
Copyright © MathByte Academy

Using **
You can even use it to add key-value pairs from one (or more) dictionary into a dictionary literal:
d1 = {'a': 1, 'b': 2}
{'a': 10, 'c': 3, **d1}
à {'a': 1, 'b': 2, 'c': 3}
{**d1, 'a': 10, 'c': 3}
à {'a': 10, 'b': 2, 'c': 3}
(order not guaranteed)
Copyright © MathByte Academy

Nested Unpacking
Python will support nested unpacking as well.
l = [1, 2, [3, 4]]
Here, the third element of the list is itself a list.
We can certainly unpack it this way:
a, b, c = l
a = 1
b = 2
c = [3, 4]
We could then unpack c into d and e as follows:
d, e = c
d = 3
e = 4
Or, we could simply do it this way:
a, b, (c, d) = [1, 2, [3, 4]]
a = 1
b = 2
c = 3
d = 4
Since strings are iterables too:
a, *b, (c, d, e) = [1, 2, 3, 'XYZ']
a = 1
b = [2, 3]
c, d, e = 'XYZ'
à
c = 'X'
d = 'Y'
e = 'Z'
Copyright © MathByte Academy

How about something like this then?
a, *b, (c, *d) = [1, 2, 3, 'python']
Although this looks like we are using * twice in the same expression, the second * is actually in a 
nested unpacking – so that's OK
a = 1
b = [2, 3]
c, *d = 'python'
à
c = 'p'
d = ['y', 't', 'h', 'o', 'n']
The * operator can only be used once in the LHS an unpacking assignment
Try doing the same thing using slicing…
Copyright © MathByte Academy

*args
Copyright © MathByte Academy

Recall from iterable unpacking
a, b, c = (10, 20, 30)
à
a = 10
b = 20
c = 30
Something similar happens when positional arguments are passed to a function:
def func1(a, b, c):
# code
func1(10, 20, 30)
à
a = 10
b = 20
c = 30
Copyright © MathByte Academy

*args
Recall also:
a, b, *c = 10, 20, 'a', 'b'
à
a=10
b=20
c=['a', 'b']
Something similar happens when positional arguments are passed to a function:
def func1(a, b, *c):
# code
func1(10, 20, 'a', 'b')
à
a=10
b=20
c=('a', 'b')
this is a tuple, not a list
The * parameter name is arbitrary – you can make it whatever you want
It is customary (but not required) to name it *args
def func1(a, b, *args):
# code
Copyright © MathByte Academy

*args exhausts positional arguments
You cannot add more positional arguments after *args
def func1(a, b, *args, d):
# code
func1(10, 20, 'a', 'b', 100)
This will not work!
this is actually OK – covered in next lecture
Copyright © MathByte Academy

Unpacking arguments
l = [10, 20, 30]
def func1(a, b, c):
# code
This will not work:
func1(*l)
But we can unpack the list first and then pass it to the function
func1(l)
à
a = 10
b = 20
c = 30
Copyright © MathByte Academy

Copyright © MathByte Academy

Keyword Arguments
Recall that positional parameters can, optionally be passed as named (keyword) arguments
def func(a, b, c):
# code
func(1, 2, 3)
func(a=1, c=3, b=2)
à
a = 1, b = 2, c = 3
à
a = 1, b = 2, c = 3
Using named arguments in this case is entirely up to the caller.
Copyright © MathByte Academy

Mandatory Keyword Arguments
We can make keyword arguments mandatory.
To do so, we create parameters after the positional parameters have been exhausted.
def func(a, b, *args, d):
#code
In this case, *args effectively exhausts all positional arguments
and d must be passed as a keyword (named) argument
func(1, 2, 'x', 'y', d = 100)
à a = 1, b = 2, args = ('x', 'y'), d = 100
func(1, 2, d = 100)
à a = 1, b = 2, args = (), d = 100
func(1, 2)
d was not a keyword argument
Copyright © MathByte Academy

We can even omit any mandatory positional arguments:
def func(*args, d):
#code
func(1, 2, 3, d=100)
func(d=100)
à args = (1, 2, 3), d = 100
à args = (), d = 100
In fact we can force no positional arguments at all:
def func(*, d):
#code
func(1, 2, 3, d=100)
func(d=100)
à Exception
à d = 100
* indicates the "end" of positional arguments
Copyright © MathByte Academy

Putting it together
def func(a, b=1, *args, d, e=True):
# code
def func(a, b=1, *, d, e=True):
# code
a: mandatory positional argument (may be specified using a named 
argument)
b: optional positional argument (may be specified positionally, as a 
named argument, or not at all), defaults to 1
args: catch-all for any (optional) 
additional positional arguments
*: no additional positional arguments allowed
d: mandatory keyword argument
e: optional keyword argument, defaults to True
Copyright © MathByte Academy

**kwargs
Copyright © MathByte Academy

**kwargs
*args is used to scoop up variable amount of remaining positional arguments
**kwargs is used to scoop up a variable amount of remaining keyword arguments
à tuple
à dictionary
The parameter name args is arbitrary – * is the real performer here
The parameter name kwargs is arbitrary – ** is the real performer here
**kwargs can be specified even if the positional arguments have not been exhausted
No parameters can come after **kwargs
(unlike keyword-only arguments)
Copyright © MathByte Academy

Example
def func(*, d, **kwargs):
# code
func(d=1, a=2, b=3)
à
d = 1
kwargs = {'a': 2, 'b': 3}
func(d=1)
à
d = 1
kwargs = {}
Copyright © MathByte Academy

Example
def func(**kwargs):
# code
func(a=1, b=2, c=3)
à kwargs = {'a': 1, 'b': 2, 'c': 3}
func()
à
kwargs = {}
def func(*args, **kwargs):
# code
func(1, 2, a=10, b=20)
func()
à args = (1, 2)
kwargs = {'a': 10, 'b': 20}
à args = ()
kwargs = {}
Copyright © MathByte Academy

Copyright © MathByte Academy

Recap
positional arguments
keyword-only arguments
specific
may have default values
*args
collects, and exhausts 
remaining positional 
arguments
*
indicates the end of 
positional arguments 
(effectively exhausts)
specific
after positional arguments have ben 
exhausted
may have default values
**kwargs
collects any remaining 
keyword arguments
Copyright © MathByte Academy

positional parameters
can have default values
user may specify them using keywords
non-defaulted params are mandatory args
specific keyword-only args
can have default values
user must specify them using keywords
non-defaulted params are mandatory args
scoops up any additional 
keyword args
scoops up any 
additional positional 
args
indicates no more 
positional args
a, b, c=10
*args / *
kw1, kw2=100
**kwargs
if used, * or *args must also be used
Copyright © MathByte Academy

def func(a, b=10)
def func(a, b, *args)
Examples
def func(a, b, *args, kw1, kw2=100)
def func(a, b=10, *, kw1, kw2=100)
def func(a, b, *args, kw1, kw2=100, **kwargs)
def func(a, b=10, *, kw1, kw2=100, **kwargs)
def func(*args)
def func(*args, **kwargs)
def func(**kwargs)
Copyright © MathByte Academy

Typical Use Case: Python's print() function
*objects
arbitrary number of positional arguments
after that are keyword-only arguments
they all have default values, so they are all optional
Copyright © MathByte Academy

Typical Use Cases
Often, keyword-only arguments are used to modify the default behavior of a function
such as the print() function we just saw
def calc_hi_lo_avg(*args, log_to_console=False):
hi = int(bool(args)) and max(args)
lo = int(bool(args)) and min(args)
avg = (hi + lo)/2
if log_to_console:
print("high={0}, low={1}, avg={2}".format(hi, lo, avg))
return avg
Other times, keyword-only arguments might be used to make 
things clearer.
Having many positional parameters can become confusing, and 
extra care has to be taken to ensure the correct parameters are 
passed in the correct sequence.
Copyright © MathByte Academy

Copyright © MathByte Academy

What happens at run-time…
When a module is loaded:
all code is executed immediately
a = 10
def func(a):
print(a)
the integer object 10 is created and a references it
the function object is created, and func references it
func(a)
the function is executed
Module Code
Copyright © MathByte Academy

What about default values?
def func(a=10):
print(a)
the function object is created, and func references it
func()
the function is executed
Module Code
the integer object 10 is evaluated/created
and is assigned as the default for a
by the time this happens, the default value for a has already been 
evaluated and assigned – it is not re-evaluated when the function is 
called
Copyright © MathByte Academy

So what?
Consider this:
from datetime import datetime
def log(msg, *, dt=datetime.utcnow()):
print('{0}: {1}'.format(dt, msg)
We want to create a function that will write a log entry to the console with a user-specified event 
date/time. If the user does not supply a date/time, we want to set it to the current date/time.
log('message 1')
log('message 2')
a few minutes later:
à 2017-08-21 20:54:37.706994 : message 1
à 2017-08-21 20:54:37.706994 : message 2
Copyright © MathByte Academy

Solution Pattern
We set a default for dt to None
Inside the function, we test to see if dt is still None
if dt is None, set it to the current date/time
otherwise, use what the caller specified for dt
from datetime import datetime
def log(msg, *, dt=None):
dt = dt or datetime.utcnow()
print('{0}: {1}'.format(dt, msg)
In general, always beware of using a mutable object (or a 
callable) for an argument default
recall that this is equivalent to:
if not dt:
dt = datetime.utcnow()
Copyright © MathByte Academy

Copyright © MathByte Academy

First-Class Objects
can be passed to a function as an argument
can be returned from a function
can be assigned to a variable
can be stored in a data structure (such as list, tuple, dictionary, etc.)
Types such as int, float, string, tuple, list and many more are first-class objects.
Functions (function) are also first-class objects
Copyright © MathByte Academy

Higher-Order Functions
Higher-order functions are functions that:
take a function as an argument
(e.g. the simple timer we wrote in the last section)
and/or
return a function
(plenty of that when we cover decorators in the next section)
Copyright © MathByte Academy

Topics in this section
function annotations and documentation
lambda expressions and anonymous functions
built-in higher order functions (such as sorted, map, filter)
some functions in the functools module (such as reduce, all, any)
function introspection
partials
callables
Copyright © MathByte Academy

Copyright © MathByte Academy

Docstrings
We have seen the help(x) function before
à returns some documentation (if available) for x
We can document our functions (and modules, classes, etc) to achieve the same result using 
docstrings
à PEP 257
If the first line in the function body is a string (not an assignment, not a comment, just a string by 
itself), it will be interpreted as a docstring
def my_func(a):
"documentation for my_func"
return a
help(my_func)
à my_func(a)
documentation for my_func
Multi-line docstrings are achieved using… 
multi-line strings!
Copyright © MathByte Academy

Where are docstrings stored?
In the function's __doc__ property
def fact(n):
"""Calculates n! (factorial function)
Inputs:
n: non-negative integer
Returns:
the factorial of n
"""
...
fact.__doc__
à
'Calculates n! (factorial function)\n    \n    Inputs:\n        
n: non-negative integer\n    Returns:\n        the 
factorial of n\n    '
help(fact)
à
fact(n)
Calculates n! (factorial function)
Inputs:
n: non-negative integer
Returns:
the factorial of n
Copyright © MathByte Academy

Function Annotations
Function annotations give us an additional way to document our functions:
def my_func(a: <expression>, b: <expression>) -> <expression>:
pass
def my_func(a: 'a string', b: 'a positive integer') -> 'a string':
return a * b
my_func.__doc__
à empty string
help(my_func)
à my_func(a:'a string', b:'a positive integer') -> 'a string'
à PEP 3107
Copyright © MathByte Academy

Annotations can be any expression
def my_func(a: str, b: 'int > 0') -> str:
return a*b
def my_func(a: str, b: [1, 2, 3]) -> str:
return a*b
x = 3
y = 5
def my_func(a: str) -> 'a repeated ' + str(max(x, y)) + ' times':
return a*max(x, y)
help(my_func) à my_func(a:str) -> 'a repeated 5 times'
Copyright © MathByte Academy

can still be used as before
Default values, *args, **kwargs
def my_func(a: str = 'xyz', b: int = 1) -> str:
pass
def my_func(a: str = 'xyz', 
*args: 'additional parameters',
b: int = 1,
**kwargs: 'additional keyword only params') -> str:
pass
Copyright © MathByte Academy

Where are annotations stored?
In the __annotations__ property of the function
à dictionary 
keys are the parameter names
for a return annotation, the key is return
values are the annotations
def my_func(a: 'info on a', b: int) -> float:
pass
à {'a': 'info on a', 'b': int, 'return': float}
my_func.__annotations__
Copyright © MathByte Academy

Where does Python use docstrings and annotations?
It doesn't really!
Mainly used by external tools and modules
Example: apps that generate documentation from your code
(Sphinx)
Docstrings and annotations are entirely optional, and do not "force" anything in our Python code
We'll look at an enhanced version of annotations in an upcoming section on type hints
Copyright © MathByte Academy

Copyright © MathByte Academy

What are Lambda Expressions?
Lambda expressions are simply another way to create functions
We already know how to create functions using the def statement
lambda [parameter list]: expression
keyword
parameter list
the : is required, even for zero arguments
this expression is evaluated and 
returned when the lambda 
function is called
optional
the expression returns a function object
that evaluates and returns the expression when it is called
(think of it as the "body" of the function)
it can be assigned to a variable
passed as an argument to another function
it is a function, just like one created with def
anonymous functions
Copyright © MathByte Academy

Examples
lambda x: x**2 
lambda x, y: x + y 
lambda : 'hello' 
lambda s: s[::-1].upper()
type(lambda x: x**2)
à function
Note that these expressions are function objects, but are not "named"
à anonymous functions
Lambdas, or anonymous functions, are NOT equivalent to closures
Copyright © MathByte Academy

Assigning a Lambda to a Variable Name
my_func = lambda x: x**2
my_func(3)
à 9
my_func(4)
à 16
type(my_func)
à function
def my_func(x):
return x**2
identical to:
my_func(3)
à 9
my_func(4)
à 16
type(my_func)
à function
Copyright © MathByte Academy

Passing as an Argument to another Function
def apply_func(x, fn):
return fn(x)
apply_func(3, lambda x: x**2)
apply_func(2, lambda x: x + 5)
apply_func('abc', lambda x: x[1:] * 3)
à 9
à 7
à bcbcbc
def fn_1(x):
return x[1:] * 3
apply_func('abc', fn_1)
à bcbcbc
equivalently:
Copyright © MathByte Academy

Limitations
The "body" of a lambda is limited to a single expression
no assignments
no annotations
def func(x: int):
return x**2
lambda x:int : x*2
à line-continuation is OK, but still just one expression
single logical line of code
lambda x: x = 5
lambda x: x = x + 5
lambda x: x * \
math.sin(x)
Copyright © MathByte Academy

Copyright © MathByte Academy

Functions are first-class objects
They have attributes
__doc__
__annotations__
We can attach our own attributes
def my_func(a, b):
return a + b
my_func.category = 'math'
my_func.sub_category = 'arithmetic'
print(my_func.category)
à math
print(my_func.sub_category)
à arithmetic
Copyright © MathByte Academy

The dir() function
dir() is a built-in function that, given an object as an argument, will return a list of valid 
attributes for that object
dir(my_func)
['__annotations__', '__call__', '__class__', '__closure__', 
'__code__', '__defaults__', '__delattr__', '__dict__',
'__dir__', '__doc__', '__eq__', '__format__', '__ge__', 
'__get__', '__getattribute__', '__globals__', '__gt__',
'__hash__', '__init__', '__init_subclass__', '__kwdefaults__', 
'__le__', '__lt__', '__module__', '__name__',
'__ne__', '__new__', '__qualname__', '__reduce__', 
'__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
'__str__', '__subclasshook__', 'category', 'sub_category']
Copyright © MathByte Academy

Function Attributes: __name__, __defaults__, __kwdefaults__
__name__
à name of function
__defaults__
à tuple containing positional parameter defaults
__kwdefaults__
à dictionary containing keyword-only parameter defaults
def my_func(a, b=2, c=3, *, kw1, kw2=2):
pass
my_func.__name__
à my_func
my_func.__defaults__
à (2, 3)
my_func.__kwdefaults__
à {'kw2': 2}
Copyright © MathByte Academy

Function Attribute: __code__
def my_func(a, b=1, *args, **kwargs):
i = 10
b = min(i, b)
return a * b
my_func.__code__
à <code object my_func at 0x00020EEF … >
This __code__ object itself has various properties, which include:
co_varnames
parameter and local variables
my_func.__code__.co_varnames
à ('a', 'b', 'args', 'kwargs', 'i')
parameter names first, followed by local variable names
co_argcount
number of parameters
my_func.__code__.co_argcount
à 2
does not count *args and **kwargs!
Copyright © MathByte Academy

The inspect Module
import inspect
ismethod(obj)
isfunction(obj)
isroutine(obj)
and many others…
What's the difference between a function and a method?
Classes and objects have attributes – an object that is bound (to the class or the object)
def my_func():
pass
def MyClass:
def func(self):
pass
my_obj = MyClass()
ismethod(my_func) à False
isfunction(my_func) à True
ismethod(my_obj.func) à True
isfunction(my_obj.func) à False
An attribute that is callable, is called a method
func is bound to my_obj, an instance of MyClass
isroutine(my_func) à True
isroutine(my_obj.func) à True
Copyright © MathByte Academy

Code Introspection
We can recover the source code of our functions/methods
inspect.getsource(my_func)
à a string containing our entire def statement, including 
annotations, docstrings, etc
We can find out in which module our function was created
inspect.getmodule(my_func)
à <module '__main__'>
inspect.getmodule(print)
à <module 'builtins' (built-in)>
inspect.getmodule(math.sin)
à <module 'math' (built-in)>
Copyright © MathByte Academy

Function Comments
# setting up variable
i = 10
# TODO: Implement function
# some additional notes
def my_func(a, b=1):
# comment inside my_func
pass
inspect.getcomments(my_func)
à '# TODO: Implement function\n# some additional notes'
Many IDE's support the TODO comment to flag functions and other callables
Note that this is not the same as docstrings
Copyright © MathByte Academy

Callable Signatures
inspect.signature(my_func)
à Signature instance
Contains an attribute called parameters
Essentially a dictionary of parameter names (keys), and metadata about the parameters (values)
keys à parameter name
values à object with attributes such as name, default, annotation, kind
kind
POSITIONAL_ONLY
POSITIONAL_OR_KEYWORD
VAR_POSITIONAL
KEYWORD_ONLY
VAR_KEYWORD
Copyright © MathByte Academy

def my_func(a: 'a string', 
b: int = 1, 
*args: 'additional positional args', 
kw1: 'first keyword-only arg', 
kw2: 'second keyword-only arg' = 10,
**kwargs: 'additional keyword-only args') -> str:
"""does something
or other"""
pass
Callable Signatures
for param in inspect.signature(my_func).parameters.values():
print('Name:', param.name)
print('Default:', param.default)
print('Annotation:', param.annotation)
print('Kind:', param.kind)
Copyright © MathByte Academy

Copyright © MathByte Academy

What are callables?
any object that can be called using the () operator
like functions and methods
but it goes beyond just those two…
many other objects in Python are also callable
To see if an object is callable, we can use the built-in function: callable
callable(print) à True
callable('abc'.upper) à True
callable(callable) à True
callable(str.upper) à True
callables always return a value
callable(10) à False
Copyright © MathByte Academy

Different Types of Callables
built-in functions
print
len
callable
built-in methods
a_str.upper
a_list.append
user-defined functions
created using def or lambda expressions
methods
functions bound to an object
classes
MyClass(x, y, z)
à
__new__(x, y, z)
à
__init__(self, x, y, z)
à returns the object (reference)
à creates the new object
class instances
if the class implements __call__ method
generators, coroutines, asynchronous generators 
Copyright © MathByte Academy

Copyright © MathByte Academy

Higher order functions
A function that takes a function as a parameter and/or returns a function as its return value
Example: sorted
map
filter
modern alternative à list comprehensions and generator expressions
Copyright © MathByte Academy

The map function
map(func, *iterables)
func
à some function that takes as many arguments as there are iterable
objects passed to iterables
*iterables
à a variable number of iterable objects
map(func, *iterables) will then return an iterator that calculates the 
function applied to each element of the iterables
The iterator stops as soon as one of the iterables has been exhausted
so, unequal length iterables can be used
Copyright © MathByte Academy

Examples
l = [2, 3, 4]
def sq(x):
return x**2
list(map(sq, l))
à [4, 9, 16]
l1 = [1, 2, 3]
l2 = [10, 20, 30]
def add(x, y):
return x + y
list(map(add, l1, l2))
à [11, 22, 33]
list(map(lambda x, y: x + y, l1, l2))
à [11, 22, 33]
Copyright © MathByte Academy

The filter function
filter(func, iterable)
func
à some function that takes a single argument
iterable
à a single iterable
filter(func, iterable) will then return an iterator that contains all the 
elements of the iterable for which the function called on it is Truthy
If the function is None, it simply returns the elements of iterable that are Truthy
Copyright © MathByte Academy

Examples
l = [0, 1, 2, 3, 4]
list(filter(None, l))
à [1, 2, 3, 4]
def is_even(n):
return n % 2 == 0
list(filter(is_even, l))
à [0, 2, 4]
list(filter(lambda n: n % 2 == 0, l))
à [0, 2, 4]
Copyright © MathByte Academy

The zip function
[1, 2, 3, 4]
[10, 20, 30, 40]
zip
(1, 10), (2, 20), (3, 30), (4, 40)
[1, 2, 3]
[10, 20, 30]
zip
(1, 10, 'a'), (2, 20, 'b'), (3, 30, 'c')
['a', 'b', 'c']
[1, 2, 3, 4, 5]
[10, 20, 30]
zip
(1, 10), (2, 20), (3, 30)
zip(*iterables)
Copyright © MathByte Academy

Examples
l1 = [1, 2, 3]
l2 = [10, 20, 30, 40]
l3 = 'python'
list(zip(l1, l2, l3))
à [(1, 10, 'p'), (2, 20, 'y'), (3, 30, 't')]
l1 = range(100)
l2 = 'abcd'
list(zip(l1, l2))
à [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
Copyright © MathByte Academy

List Comprehension Alternative to map
l = [2, 3, 4]
def sq(x):
return x**2
list(map(sq, l))
[x**2 for x in l]
à [4, 9, 16]
à [4, 9, 16]
[<expression> for <varname> in <iterable>]
list(map(lambda x: x**2, l))
result = []
for x in l:
result.append(x**2)
result à [4, 9, 16]
Copyright © MathByte Academy

List Comprehension Alternative to map
l1 = [1, 2, 3]
l2 = [10, 20, 30]
list(map(lambda x, y: x + y, l1, l2))
à [11, 22, 33]
[x + y for x, y in zip(l1, l2)]
à [11, 22, 33]
Remember:      zip(l1, l2) à [(1, 10), (2, 20), (3, 30)]
Copyright © MathByte Academy

List Comprehension Alternative to filter
l = [1, 2, 3, 4]
list(filter(lambda n: n % 2 == 0, l))
à [2, 4]
[x for x in l if x % 2 == 0]
à [2, 4]
[<expression1> for <varname> in <iterable> if <expression2>]
Copyright © MathByte Academy

Combining map and filter
l = range(10)
list(filter(lambda y: y < 25, map(lambda x: x**2, l)))
à [0, 1, 4, 9, 16]
Using a list comprehension is much clearer:
[x**2 for x in range(10) if x**2 < 25]
à [0, 1, 4, 9, 16]
Copyright © MathByte Academy

Copyright © MathByte Academy

Reducing Functions in Python
These are functions that recombine an iterable recursively, ending up with a single return value
Also called accumulators, aggregators, or folding functions.
Example: Finding the maximum value in an iterable
a0, a1, a2, …, an-1
result = a0
max(a, b) à maximum of a and b
result = max(result, a1)
result = max(result, a2)
result = max(result, an-1)
…
à max value in 
a0, a1, a2, …, an-1
Copyright © MathByte Academy

Because we have not studied iterables in general, we will stay with the special case of sequences. 
(i.e. we can use indexes to access elements in the sequence)
Using a loop
l = [5, 8, 6, 10, 9]
def max_sequence(sequence):
result = sequence[0]
for e in sequence[1:]:
result = max_value(result, e)
return result
max_value = lambda a, b: a if a > b else b
result = 5
result = max(5, 8) = 8
result = max(8, 6) = 8
result = max(8, 10) = 10
result = max(10, 9) = 10
result à 10
Copyright © MathByte Academy

Notice the sequence of steps:
l = [5,     8,     6,     10,     9]
5
max(5, 8)
8
max(8, 6)
8
max(8, 10)
10
max(10, 9)
10
result à 10
Copyright © MathByte Academy

To calculate the min:
l = [5, 8, 6, 10, 9]
def min_sequence(sequence):
result = sequence[0]
for e in sequence[1:]:
result = min_value(result, e)
return result
min_value = lambda a, b: a if a < b else b
All we really needed to do was to change 
the function that is repeatedly applied.
In fact we could write:
def _reduce(fn, sequence):
result = sequence[0]
for x in sequence[1:]:
result = fn(result, x)
return result
_reduce(lambda a, b: a if a > b else b, l) à maximum
_reduce(lambda a, b: a if a < b else b, l) à minimum
Copyright © MathByte Academy

Adding all the elements in a list
add = lambda a, b: a+b
l = [5, 8, 6, 10, 9]
def _reduce(fn, sequence):
result = sequence[0]
for x in sequence[1:]:
result = fn(result, x)
return result
result = 5
result = add(5, 8) = 13
result = add(13, 6) = 19
result = add(19, 10) = 29
result = add(29, 9) = 38
result à 38
_reduce(add, l)
Copyright © MathByte Academy

The functools module
Python implements a reduce function that will handle any iterable, but works similarly to what 
we just saw
from functools import reduce
l = [5, 8, 6, 10, 9]
reduce(lambda a, b: a if a > b else b, l)
à max à 10
reduce(lambda a, b: a if a < b else b, l)
à min à 5
reduce(lambda a, b: a + b, l)
à sum à 38
Copyright © MathByte Academy

reduce works on any iterable
reduce(lambda a, b: a if a < b else b, {10, 5, 2, 4})
à 2
reduce(lambda a, b: a if a < b else b, 'python')
à h
reduce(lambda a, b: a + ' ' + b, ('python', 'is', 'awesome!'))
à 'python is awesome'
Copyright © MathByte Academy

Built-in Reducing Functions
Python provides several common reducing functions:
min
min([5, 8, 6, 10, 9])
à 5
max
max([5, 8, 6, 10, 9])
à 10
sum
sum([5, 8, 6, 10, 9])
à 38
any
any(l)
à
True if any element in l is truthy
False otherwise
all
all(l)
à
True if every element in l is truthy
False otherwise
Copyright © MathByte Academy

Using reduce to reproduce any
l = [0, '', None, 100]
result = bool(0) or bool('') or bool(None) or bool(100)
Here we just need to repeatedly apply the or operator to the truth values of each element
result = bool(0)
à False
result = result or bool('')
à False
result = result or bool(None)
à False
result = result or bool(100)
à True
reduce(lambda a, b: bool(a) or bool(b), l)
Note: 0 or '' or None or 100 à 100
but we want our result to be True/False
so we use bool()
à True
Copyright © MathByte Academy

Calculating the product of all elements in an iterable
No built-in method to do this
But very similar to how we added all the elements in an iterable or sequence:
[1, 3, 5, 6]
à 1 * 3 * 5 * 6
reduce(lambda a, b: a * b, l)
= 1 * 3 * 5 * 6
res = 1
res = res * 3 = 3
res = res * 5 = 3 * 5 = 15
res = res * 6 = 15 * 6 = 90
Copyright © MathByte Academy

Special case: Calculating n!
n! = 1 * 2 * 3 * … * n
5! = 1 * 2 * 3 * 4 * 5
range(1, 6)
à 1, 2, 3, 4, 5
range(1, n+1)
à 1, 2, 3, …, n
To calculate n! we need to find the product of all the elements in range(1, n+1)
reduce(lambda a, b: a * b, range(1, 5+1))
à 5!
Copyright © MathByte Academy

The reduce initializer
The reduce function has a third (optional) parameter: initializer
(defaults to None)
If it is specified, it is essentially like adding it to the front of the iterable.
It is often used to provide some kind of default in case the iterable is empty.
l = []
reduce(lambda x, y: x+y, l)
à exception
l = []
reduce(lambda x, y: x+y, l, 1)
à 1
l = [1, 2, 3]
reduce(lambda x, y: x+y, l, 1)
à 7
l = [1, 2, 3]
reduce(lambda x, y: x+y, l, 100)
à 106
Copyright © MathByte Academy

Copyright © MathByte Academy

Reducing Function Arguments
def my_func(a, b, c):
print(a, b, c)
def fn(b, c):
return my_func(10, b, c)
f = lambda b, c: my_func(10, b, c)
fn(20, 30)
f(20, 30)
à 10, 20, 30
à 10, 20, 30
from functools import partial
f = partial(my_func, 10)
f(20, 30)
à 10, 20, 30
Copyright © MathByte Academy

Handling more complex arguments
def my_func(a, b, *args, k1, k2, **kwargs):
print(a, b, args, k1, k2, kwargs)
def f(b, *args, k2, **kwargs):
return my_func(10, b, *args, k1='a', k2=k2, **kwargs)
f = partial(my_func, 10, k1='a')
Copyright © MathByte Academy

Handling more complex arguments
def pow(base, exponent):
return base ** exponent
square = partial(pow, exponent=2)
cube = partial(pow, exponent=3)
square(5)
cube(5)
à 25
à 75
cube(base=5) à 75
square(5, exponent=3)
à 75
!!
Copyright © MathByte Academy

Beware!!
You can use variables when creating partials
def my_func(a, b, c):
print(a, b, c)
a = 10
f = partial(my_func, a)
f(20, 30)
à 10, 20, 30
a = 100
f(20, 30)
à 10, 20, 30
the memory address of 10 is baked in to the partial
a now points to a different memory address
but the partial still points to the original object (10)
If a is mutable (e.g. a list), then it's contents can be changed
but there arises a similar issue to argument default values
Copyright © MathByte Academy

operator
Copyright © MathByte Academy

Functional Equivalents to Operators
In the last lecture we wrote code such as:
l = [2, 3, 4]
reduce(lambda a, b: a * b, l)
We used a lambda expression to create a functional version of the * operator
This is something that happens quite often, so the operator module was created
This module is a convenience module.
You can always use your own functions and lambda expressions instead.
Copyright © MathByte Academy

The operator module
Arithmetic Functions
add(a, b)
mul(a, b)
pow(a, b)
mod(a, b)
floordiv(a, b)
and many more…
neg(a)
Copyright © MathByte Academy

Comparison and Boolean Operators
lt(a, b)
le(a, b)
gt(a, b)
ge(a, b)
and_(a, b)
or_(a,b)
eq(a, b)
ne(a, b)
is_(a,b)
is_not(a,b)
not_(a,b)
Copyright © MathByte Academy

Sequence/Mapping Operators
concat(s1, s2)
contains(s, val)
countOf(s, val)
getitem(s, i)
setitem(s, i, val)
delitem(s, i)
mutable objects
variants that use slices
Copyright © MathByte Academy

Item Getters
The itemgetter function returns a callable
getitem(s, i)
takes two parameters, and returns a value: s[i]
itemgetter(i)
s = [1, 2, 3]
returns a callable which takes one parameter: a sequence object
f = itemgetter(1)
s = [1, 2, 3]
getitem(s, 1)
à 2
f(s)
à 2
s = 'python'
f(s)
à 'y'
Copyright © MathByte Academy

Item Getters
We can pass more than one index to itemgetter:
l = [1, 2, 3, 4, 5, 6]
s = 'python'
f = itemgetter(1, 3, 4)
f(l)
f(s)
à (2, 4, 5)
à ('y', 'h', 'o')
Copyright © MathByte Academy

Attribute Getters
The attrgetter function is similar to itemgetter, but is used to retrieve object attributes
It also returns a callable, that takes the object as an argument
Suppose my_obj is an object with three properties:
my_obj.a à 10
my_obj.b à 20
my_obj.c à 30
f = attrgetter('a')
f(my_obj)
à 10
f = attrgetter('a', 'c')
f(my_obj)
à (10, 30)
Can also call directly:
attrgetter('a', 'b', 'c')(my_obj)
à (10, 20, 30)
Copyright © MathByte Academy

Calling another Callable
Consider the str class that provides the upper() method:
s = 'python'
s.upper()
à PYTHON
f = attrgetter('upper')
à returns the upper method of s
f(s)
it is a callable, and can be called using ()
f(s)()
à PYTHON
attrgetter('upper')(s)()
à PYTHON
Or, we can use the slightly simpler methodcaller function
methodcaller('upper')('python')
à PYTHON
Basically, methodcaller retrieves the named attribute and calls it as well
It can also handle more arguments, as we'll in the code
Copyright © MathByte Academy

Copyright © MathByte Academy

Variable Scopes
local scope
global scope
nonlocal scope
nested scopes
Closures
what they are
closure scopes
Decorators
what they are
how they are related to closures
convenience of using @
Applications
(they are not equivalent to lambdas!)
Copyright © MathByte Academy

Copyright © MathByte Academy

Scopes and Namespaces
That object can be accessed using that name in various parts of our code
But not just anywhere!
That variable name and it's binding (name and object) only "exist" in specific parts of our code
the portion of code where that name/binding is defined, is called the lexical scope of the variable
these bindings are stored in namespaces
When an object is assigned to a variable
that variable points to some object
a = 10
and we say that the variable (name) is bound to that object
(each scope has its own namespace)
Copyright © MathByte Academy

The Global Scope
The global scope is essentially the module scope.
There is no concept of a truly global (across all the modules in our entire app) scope in Python.
The only exception to this are some of the built-in globally available objects, such as:
True
False
None
It spans a single file only.
The built-in and global variables can be used anywhere inside our module
including inside any function
dict
print
Copyright © MathByte Academy

Global scopes are nested inside the built-in scope
Built-in Scope
If you reference a variable name inside a scope and Python does not find it in that scope's namespace
it will look for it in an enclosing scope's namespace
Module1
Scope
name 
space
Module2
Scope
name 
space
name space
var1
0xA345E
func1
0xFF34A
name 
space
Copyright © MathByte Academy

Examples
module1.py
print(True)
à True
Python does not find True or print in the current (module/global) scope
So, it looks for them in the enclosing scope à built-in
module2.py
print(a)
Finds them there
à run-time Name Error
Python does not find a or print in the current (module/global) scope
So, it looks for them in the enclosing scope à built-in
Find print, but not a
module3.py
print = lambda x: 'hello {0}!'.format(x)
s = print('world')
Python finds print in the module scope
So it uses it!
s à hello world!
Copyright © MathByte Academy

The Local Scope
When we create functions, we can create variable names inside those functions (using assignments)
à Local scope
Variables defined inside a function are not created until the function is called
Every time the function is called, a new scope is created
(this is why recursion works!)
The actual object the variable references could be different
each time the function is called
Variables defined inside the function are assigned to that scope
à Function Local scope
e.g. a = 10
Copyright © MathByte Academy

Example
def my_func(a, b):
c = a * b
return c
my_func
a
b
c
these names will considered local
to my_func
my_func('z', 2)
my_func
aà'z'
bà2
cà'zz'
my_func(10, 5)
my_func
aà10
bà5
cà50
same names, different local scopes
Copyright © MathByte Academy

Built-in Scope
Nested Scopes
Scopes are often nested
Namespace lookups
When requesting the object bound to a variable name:
Python will try to find the object bound to the variable
Module Scope
Local 
Scope
Local 
Scope
Local 
Scope
•
in current local scope first
•
works up the chain of enclosing scopes
e.g. print(a)
Copyright © MathByte Academy

built-in scope
global scope
local 
scope
local 
scope
True
aà10
bà300
bà'a'
Example
module1.py
def my_func(b):
print(True)
print(a)
print(b)
my_func(300)
my_func('a')
Remember reference counting?
When my_func(var) finishes running, the scope is gone too!
and the reference count of the object var was bound to (referenced) is decremented 
We also say that var goes out of scope
a = 10
my_func
Copyright © MathByte Academy

built-in
global
Accessing the global scope from a local scope
When retrieving the value of a global variable from inside a function, Python automatically
searches the local scope's namespace, and up the chain of all enclosing scope namespaces
local
à global
à built-in
What about modifying a global variables value from inside the function?
a = 0
def my_func():
a = 100
print(a)
assignment à Python interprets this as a local variable (at compile-time)
à the local variable a masks the global variable a
local
à 0
print(a)
my_func()
aà100
aà0
my_func
à 100
Copyright © MathByte Academy

The global keyword
We can tell Python that a variable is meant to be scoped in the global scope 
by using the global keyword
a = 0
built-in
aà0
local
global
à 100
def my_func():
global a
a = 100
print(a)
my_func()
my_func
Copyright © MathByte Academy

Example
counter = 0
def increment():
global counter
counter += 1
increment()
increment()
increment()
print(counter)
à 3
Copyright © MathByte Academy

Global and Local Scoping
When Python encounters a function definition at compile-time
it will scan for any labels (variables) that have values assigned to them (anywhere in the function)
if the label has not been specified as global, then it will be local
variables that are referenced but not assigned a value anywhere in the function will not be local, 
and Python will, at run-time, look for them in enclosing scopes
a = 10
def func1():
print(a)
def func2():
a = 100
assignment
at compile time à a local
def func4():
print(a)
a = 100
a is referenced only in entire function
at compile time à a non-local
def func3():
global a
a = 100
assignment
at compile time à a global
(because we told Python a was global)
assignment
at compile time à a local
à when we call func4()
print(a) results in a run-time error
because a is local, and we are 
referencing it before we have 
assigned a value to it!
Copyright © MathByte Academy

Copyright © MathByte Academy

Inner Functions
def outer_func():
# some code
def inner_func():
# some code
inner_func()
We can define functions from inside another function:
global
local (outer_func)
outer_func()
local (inner_func)
Nested local scopes
Both functions have access to the global and built-in scopes as well as their respective local scopes
But the inner function also has access to its enclosing scope – the scope of the outer function
That scope is neither local (to inner_func) nor global – it is called a nonlocal scope
Copyright © MathByte Academy

Referencing variables from the enclosing scope
Consider this example we have seen before:
module1.py
a = 10
def outer_func():
print(a)
outer_func()
When we call outer_func, Python sees the reference to a
Since a is not in the local scope, Python looks in the enclosing (global) scope
Copyright © MathByte Academy

Referencing variables from the enclosing scope
Now consider this example:
module1.py
def outer_func():
a = 10
def inner_func():
print(a)
inner_func()
outer_func()
When we call outer_func, inner_func is created and called
When inner_func is called, Python does not find a in the local (inner_func) scope
So it looks for it in the enclosing scope, in this case the scope of outer_func
Copyright © MathByte Academy

Referencing variables from the enclosing scope
module1.py
a = 10
def outer_func():
def inner_func():
print(a)
inner_func()
outer_func()
When we call outer_func, inner_func is defined and called
When inner_func is called, Python does not find a in the local (inner_func) scope
So it looks for it in the enclosing scope, in this case the scope of outer_func
Since it does not find it there either, it looks in the enclosing (global) scope
Copyright © MathByte Academy

Modifying global variables
We saw how to use the global keyword in order to modify a global variable within a nested scope
a = 10
def outer_func1():
global a
a = 1000
outer_func1()
print(a)
We can of course do the same thing from within a nested function
def outer_func2():
def inner_func():
global a
a = 'hello'
inner_func()
outer_func2()
print(a)
à 1000
à hello
Copyright © MathByte Academy

Modifying nonlocal variables
Can we modify variables defined in the outer nonlocal scope?
def outer_func():
x = 'hello'
def inner_func():
x = 'python'
inner_func()
print(x)
outer_func()
à hello
When inner_func is compiled, Python sees an assignment to x
So it determines that x is a local variable to inner_func
The variable x in inner_func masks the variable x in outer_func
Copyright © MathByte Academy

Modifying nonlocal variables
Just as with global variables, we have to explicitly tell Python we are modifying a nonlocal variable
We can do that using the nonlocal keyword
def outer_func():
x = 'hello'
def inner_func():
nonlocal x
x = 'python'
inner_func()
print(x)
outer_func()
à python
Copyright © MathByte Academy

Nonlocal Variables
Whenever Python is told that a variable is nonlocal
it will look for it in the enclosing local scopes chain until it first encounters the specified variable 
name
def outer():
x = 'hello'
def inner1():
def inner2():
nonlocal x
x = 'python'
inner2()
inner1()
print(x)
à python
outer()
global
local (outer)
local (inner1)
x
local (inner2)
x
inner1
inner2
Beware: It will only look in local scopes, it will not look in the global scope
Copyright © MathByte Academy

Nonlocal Variables
But consider this example:
def outer():
x = 'hello'
def inner1():
x = 'python'
def inner2():
nonlocal x
x = 'monty'
print('inner(before)', x)
inner2()
print('inner(after)', x)
inner1()
print('outer', x)
à python
outer()
à monty
à hello
global
local (outer)
local (inner1)
x
local (inner2)
x
x
Copyright © MathByte Academy

Nonlocal Variables
def outer():
x = 'hello'
def inner1():
nonlocal x
x = 'python'
def inner2():
nonlocal x
x = 'monty'
print('inner(before)', x)
inner2()
print('inner(after)', x)
inner1()
print('outer', x)
à python
outer()
à monty
à monty
global
local (outer)
local (inner1)
x
local (inner2)
x
x
Copyright © MathByte Academy

Nonlocal and Global Variables
x = 100
def outer():
x = 'python'
def inner1():
nonlocal x
x = 'monty'
def inner2():
global x
x = 'hello'
print('inner(before)', x)
inner2()
print('inner(after)', x)
inner1()
print('outer', x)
à monty
outer()
à monty
à monty
global
local (outer)
local (inner1)
x
local (inner2)
x
x
print(x)
à hello
x
Copyright © MathByte Academy

Copyright © MathByte Academy

Free Variables and Closures
Remember: Functions defined inside another function can access the outer (nonlocal) variables
def outer():
x = 'python'
def inner():
print("{0} rocks!".format(x))
inner()
this x refers to the one in outer's scope
outer()
à python rocks!
this nonlocal variable x is called a free variable
when we consider inner, we really are looking at:
•
the function inner
•
the free variable x (with current value python)
This is called a closure
Copyright © MathByte Academy

Returning the inner function
What happens if, instead of calling (running) inner from inside outer, we return it? 
def outer():
x = 'python'
def inner():
print("{0} rocks!".format(x))
inner()
return inner
x is a free variable in inner
We can assign that return value to a variable name:
fn = outer()
fn()
à python rocks!
it is bound to the variable x in outer
this happens when outer runs
when we return inner, we are actually "returning" the closure
this the closure
(i.e. when inner is created)
When we called fn
at that time Python determined the value of x in the extended scope
But notice that outer had finished running before we called fn – it's scope was "gone"
Copyright © MathByte Academy

Python Cells and Multi-Scoped Variables
def outer():
x = 'python'
def inner():
print(x)
return inner
Here the value of x is shared between two scopes:
•
outer
•
closure
The label x is in two different scopes
but always reference the same "value"
Python does this by creating a cell as an intermediary object
outer.x
inner.x
In effect, both variables x (in outer and inner), point to the same cell
When requesting the value of the variable, Python will "double-hop" to get to the final value
cell
0xFF100
0xA500
str
python
0xFF100
indirect reference
Copyright © MathByte Academy

You can think of the closure as a function plus an extended scope that contains the free variables
Closures
The free variable's value is the object the cell points to – so that could change over time!
Every time the function in the closure is called and the free variable is referenced:
def outer():
a = 100
x = 'python'
def inner():
a = 10  # local variable
print("{0} rocks!".format(x))
return inner
fn = outer()
closure
fn à inner
+ extended scope
x
Python looks up the cell object, and then whatever the cell is pointing to
cell
0xFF100
0xA500
str
python
0xFF100
indirect reference
Copyright © MathByte Academy

Introspection
def outer():
a = 100
x = 'python'
def inner():
a = 10  # local variable
print("{0} rocks!".format(x))
return inner
fn = outer()
fn.__code__.co_freevars
à ('x',)
(a is not a free variable)
fn.__closure__
à (<cell at 0xA500: str object at 0xFF100>, )
cell
0xFF100
0xA500
str
python
0xFF100
def outer():
x = 'python'
print(hex(id(x))
def inner():
print(hex(id(x))
print("{0} rocks!".format(x))
return inner
fn = outer()
fn()
0xFF100
0xFF100
indirect reference
indirect reference
indirect reference
Copyright © MathByte Academy

Modifying free variables
def counter():
count = 0
def inc():
nonlocal count
count += 1
return count
return inc
count is a free variable
closure
fn = counter()
fn
fn()
à inc + count à 0
à 1
fn()
à 2
it is bound to the cell count
count's (indirect) reference changed from the object 0 to the object 1
Copyright © MathByte Academy

Multiple Instances of Closures
Every time we run a function, a new scope is created.
If that function generates a closure, a new closure is created every time as well
def counter():
count = 0
def inc():
nonlocal count
count += 1
return count
return inc
f1 = counter()
f2 = counter()
f1()
f1()
f1()
à 1
à 2
à 3
f2()
à 1
f1 and f2 do not have 
the same extended 
scope
they are different instances of the 
closure
closure
the cells are different
Copyright © MathByte Academy

Shared Extended Scopes
def outer():
count = 0
def inc1():
nonlocal count
count += 1
return count
def inc2():
nonlocal count
count += 1
return count
return inc1, inc2
count is a free variable – bound to count in the extended scope
count is a free variable – bound to the same count
f1, f2 = outer()
f1()
à 1
f2()
à 2
returns a tuple containing both closures
Copyright © MathByte Academy

Shared Extended Scopes
You may think this shared extended scope is highly unusual…
but it's not!
def adder(n):
def inner(x):
return x + n
return inner
add_1 = adder(1)
add_2 = adder(2)
add_3 = adder(3)
Three different closures – no shared scopes
add_1(10)
add_2(10)
add_3(10)
à 11
à 12
à 13
Copyright © MathByte Academy

Shared Extended Scopes
But suppose we tried doing it this way:
adders = []
for n in range(1, 4):
adders.append(lambda x: x + n)
Now we could call the adders in the following way:
n = 1: the free variable in the lambda is n, and it is bound to the n we created in the loop
n = 2: the free variable in the lambda is n, and it is bound to the (same) n we created in the loop
n = 3: the free variable in the lambda is n, and it is bound to the (same) n we created in the loop
adders[0](10)
adders[1](10)
adders[2](10)
à 13
à 13
à 13
Remember, Python does not "evaluate" the free variable n until the adders[i] function is called
Since all three functions in adders are bound to the same n
by the time we call adders[0], the value of n is 3
(the last iteration of the loop set n to 3)
Copyright © MathByte Academy

Nested Closures
def incrementer(n):
# inner + n is a closure
def inner(start):
current = start
# inc + current + n is a closure
def inc():
nonlocal current
current += n
return current
return inc
return inner
fn = incrementer(2)
à fn.__code__.co_freevars à 'n'
inc_2 = fn(100) 
à inc_2.__code__.co_freevars à 'current', 'n'
inc_2()
à 102
(inner)
(inc)
(calls inc)
inc_2()
à 104
n=2
current=100, n=2
(current = 102, n=2)
(current = 104, n=2)
Copyright © MathByte Academy

Copyright © MathByte Academy

Recall the simple closure example we did which allowed to us to maintain a 
count of how many times a function was called:
Decorators
def counter(fn):
count = 0
def inner(*args, **kwargs):
nonlocal count
count += 1
print('Function {0} was called {1} times'.format(fn.__name__, count)
return fn(*args, **kwargs)
return inner
def add(a, b=0):
return a + b
add = counter(add)
result = add(1, 2)
à Function add was called 1 times
à result = 3
We essentially modified our add function by wrapping it inside another 
function that added some functionality to it
We also say that we decorated our function add with the function counter
And we call counter a decorator function
using *args, **kwargs means we can call 
any function fn with any combination of 
positional and keyword-only arguments
Copyright © MathByte Academy

Decorators
In general a decorator function:
•
takes a function as an argument
•
returns a closure
•
the closure usually accepts any combination of parameters
•
runs some code in the inner function (closure)
•
the closure function calls the original function using the arguments passed to the closure
•
returns whatever is returned by that function call
outer function
inner function
(fn)
(*args, **kwargs)
does something…
returns fn(*args, **kwargs)
closure
Copyright © MathByte Academy

Decorators and the @ Symbol
In our previous example, we saw that counter was a decorator
and we could decorate our add function using:
add = counter(add)
In general, if func is a decorator function, we decorate another function my_func using:
my_func = func(my_func)
This is so common that Python provides a convenient way of writing that:
@counter
def add(a, b):
return a + b
def add(a, b):
return a + b
add = counter(add)
@func
def my_func(…):
…
def my_func(…):
…
my_func = func(my_func)
is the same as writing
is the same as writing
Copyright © MathByte Academy

Introspecting Decorated Functions
Let's use the same count decorator.
def counter(fn):
count = 0
def inner(*args, **kwargs):
nonlocal count
count += 1
print('{0} was called {1} times'.format(fn.__name__, count)
return fn(*args, **kwargs)
return inner
@counter
def mult(a, b, c=1):
"""
returns the product of three values
"""
return a * b * c
remember we could equally have written:
mult = counter(mult)
mult.__name__
à inner
not mult
mult's name "changed" when we decorated it
they are not the same function after all
help(mult)
à Help on function inner in module __main__:
inner(*args, **kwargs)
We have also "lost" our docstring, 
and even the original function signature
Even using the inspect module's signature does not yield better results
Copyright © MathByte Academy

One approach to fixing this
We could try to fix this problem, at least for the docstring and function name as follows:
def counter(fn):
count = 0
def inner(*args, **kwargs):
nonlocal count
count += 1
print('Function {0} was called {1} times'.format(fn.__name__, count)
return fn(*args, **kwargs)
inner.__name__ = fn.__name__
inner.__doc__ = fn.__doc__
return inner
But this doesn’t fix losing the function signature – doing so would be quite complicated
Instead, Python provides us with a special function that we can use to fix this
Copyright © MathByte Academy

The functools.wraps function
The functools module has a wraps function that we can use to fix the metadata of our inner
function in our decorator
In fact, the wraps function is itself a decorator
def counter(fn):
count = 0
def inner(*args, **kwargs):
nonlocal count
count += 1
print(count)
return fn(*args, **kwargs)
inner = wraps(fn)(inner)
return inner
from functools import wraps
def counter(fn):
count = 0
@wraps(fn)
def inner(*args, **kwargs):
nonlocal count
count += 1
print(count)
return fn(*args, **kwargs)
return inner
but it needs to know what was our "original" function – in this case fn
Copyright © MathByte Academy

def counter(fn):
count = 0
@wraps(fn)
def inner(*args, **kwargs):
nonlocal count
count += 1
print(count)
return fn(*args, **kwargs)
return inner
@counter
def mult(a:int, b:int, c:int=1):
"""
returns the product of three values
"""
return a * b * c
help(mult)
à Help on function mult in module __main__:
mult(a:int, b:int, c:int=1)
returns the product of three values
And introspection using the inspect module works as expected:
inspect.signature(mult)
à <Signature (a:int, b:int, c:int=1)>
You don't have to use @wraps, but it will make debugging easier!
Copyright © MathByte Academy

Copyright © MathByte Academy

Decorator Parameters
In the previous videos we saw some built-in decorators that can handle some arguments:
@wraps(fn)
def inner():
…
@lru_cache(maxsize=256)
def factorial(n):
…
This should look quite different from the decorators we have been creating and using:
@timed
def fibonacci(n):
…
no function call
function call
Copyright © MathByte Academy

The timed decorator
def timed(fn):
from time import perf_counter
def inner(*args, **kwargs):
total_elapsed = 0
for i in range(10):
start = perf_counter()
result = fn(*args, **kwargs)
total_elapsed += (perf_counter() - start)
avg_elapsed = total_elapsed / 10
print(avg_elapsed)
return result
return inner
@timed
def my_func():
…
hardcoded value 10
my_func = timed(my_func)
OR
Copyright © MathByte Academy

One Approach
def timed(fn, reps):
from time import perf_counter
def inner(*args, **kwargs):
total_elapsed = 0
for i in range(reps):
start = perf_counter()
result = fn(*args, **kwargs)
total_elapsed += (perf_counter() - start)
avg_elapsed = total_elapsed / reps
print(avg_elapsed)
return result
return inner
free variable
extra parameter
my_func = timed(my_func, 10)
@timed(10)
def my_func():
…
Copyright © MathByte Academy

Rethinking the solution
@timed
def my_func():
…
my_func = timed(my_func)
So, timed is a function that returns that inner closure that contains our original function
In order for this to work as intended:
@timed(10)
def my_func():
…
timed(10) will need to return our original timed decorator when called
dec = timed(10)
@dec
def my_func():
…
timed(10) returns a decorator
and we decorate our function with dec
Copyright © MathByte Academy

def timed(fn):
from time import perf_counter
def inner(*args, **kwargs):
total_elapsed = 0
for i in range(reps):
start = perf_counter()
result = fn(*args, **kwargs)
total_elapsed += (perf_counter() - start)
avg_elapsed = total_elapsed / reps
print(avg_elapsed)
return result
return inner
def outer(reps):
Nested closures to the rescue!
free variable bound to reps in outer
calling outer(n) returns our original decorator
with reps set to n (free variable)
@outer(10)
def my_func():
…
OR
my_func = outer(10)(my_func)
our original decorator
return timed
Copyright © MathByte Academy

Decorator Factories
The outer function is not itself a decorator 
instead it returns a decorator when called
and any arguments passed to outer can be referenced (as free variables) inside our decorator
We call this outer function a decorator factory function
(it is a function that creates a new decorator each time it is called)
Copyright © MathByte Academy

And finally…
To wrap things up, we probably don't want out decorator call to look like:
@outer(10)
def my_func():
…
It would make more sense to write it this way:
@timed(10)
def my_func():
…
All we need to do is change the names of the outer and timed functions
Copyright © MathByte Academy

def timed(reps):
def dec(fn):
from time import perf_counter
@wraps(fn)
def inner(*args, **kwargs):
total_elapsed = 0
for i in range(reps):
start = perf_counter()
result = fn(*args, **kwargs)
total_elapsed += (perf_counter() - start)
avg_elapsed = total_elapsed / reps
print(avg_elapsed)
return result
return inner
return dec
@timed(10)
def my_func():
…
this was outer
this was timed
we can still use @wraps
Copyright © MathByte Academy

Copyright © MathByte Academy

Tuples are…
read-only lists…
at least that's how many introductions to Python will present tuples!!
This isn't wrong, but there's a lot more going on with tuples…
We really need to think of tuples also as data records
If you only think of tuples as read-only lists, you're going to miss out on some interesting ideas
This is why we are going to start looking at tuples before we even cover sequence types
We are going to focus here on tuples as a data records or structures
We will also look at named tuples
position of value has meaning
Copyright © MathByte Academy

Copyright © MathByte Academy

Tuples vs Lists vs Strings
Tuples
indexable
iterable
immutable
Lists
indexable
iterable
mutable
fixed length
length can change
fixed order
order of elements can change
can do in-place sorts
cannot do in-place sorts
order matters
order matters
Heterogeneous / Homogeneous
Heterogeneous / Homogeneous
containers
containers
Strings
containers
order matters
Homogeneous
indexable
iterable
immutable
fixed length
fixed order
cannot do in-place reversals
can do in-place reversals
Copyright © MathByte Academy

Immutability of Tuples
elements cannot be added or removed
the order of elements cannot be changed
works well for representing data structures:
Point:  (10, 20)
1st element is the x-coordinate
2nd element is the y-coordinate
Circle: (0, 0, 10)
1st element is the x-coordinate of the center
2nd element is the y-coordinate of the center
3rd element is the radius
The position of the data has meaning
City: ('London', 'UK', 8_780_000)
1st element is the name of a city
2nd element is the country
3rd element is the population
Copyright © MathByte Academy

Tuples as Data Records
Think of a tuple as a data record where the position of the data has meaning
london = ('London', 'UK', 8_780_000)
new_york = ('New York', 'USA', 8_500_000)
beijing = ('Beijing', 'China', 21_000_000)
Because tuples, strings and integers are immutable, we are guaranteed
that the data and data structure for london will never change
We can have a list of these tuples:
cities = [('London', 'UK', 8_780_000),
('New York', 'USA', 8_500_000),
('Beijing', 'China', 21_000_000)]
Copyright © MathByte Academy

Extracting data from Tuples
Since tuples are sequences just like strings and lists, we can retrieve items by index
london = ('London', 'UK', 8_780_000)
city = london[0]
country = london[1]
population = london[2]
cities = [('London', 'UK', 8_780_000),
('New York', 'USA', 8_500_000),
('Beijing', 'China', 21_000_000)]
total_population = 0
for city in cities:
total_population += city[2]
You'll notice how the list of cities is homogeneous (contains cities only)
But a city (the tuple) is heterogeneous
Copyright © MathByte Academy

Extracting data from Tuples
We can also use tuple unpacking
We actually already know how to do this – we covered this in the section on function arguments
new_york = ('New York', 'USA', 8_500_000)
packed three values into a tuple
city, country, population = new_york
unpacked tuple
city, country, population = ('New York', 'USA', 8_500_000)
city, country, population = 'New York', 'USA', 8_500_000
Copyright © MathByte Academy

Dummy Variables
This is something you’re likely to run across when you look at Python code that uses tuple unpacking
Sometimes, we are only interested in a subset of the data fields in a tuple, not all of them
city, _, population = ('Beijing', 'China', 21_000_000)
Suppose we are interested only in the city name and the population:
_ is actually a legal variable name – so there's nothing special about it
but by convention, we use the underscore to indicate this is a variable we don't care about
city, ignored, population = ('Beijing', 'China', 21_000_000)
in fact, we could just have used:
Copyright © MathByte Academy

Dummy Variables
It's also used in extended unpacking too
record = ('DJIA', 2018, 1, 19, 25987.35, 26071.72, 25942.83, 26071.72)
symbol, year, month, day, open, high, low, close = record
Let's say we are only interested in the symbol, year, month, day and close fields
We could do it this way:
symbol = record[0]
year = record[1]
month = record[2]
day = record[3]
close = record[7]
looks really bad!
symbol, year, close = record[0], record[1], record[7]
symbol, year, month, day, *_, close = record
symbol, year, month, day, *ignored, close = record
awful!
Copyright © MathByte Academy

Copyright © MathByte Academy

Tuple as Data Structure
We have seen how we interpreted tuples as data structures
The position of the object contained in the tuple gave it meaning
For example, we can represent a 2D coordinate as:
(10, 20)
x
y
If pt is a position tuple, we can retrieve the x and 
y coordinates using:
x, y = pt
x = pt[0]
y = pt[1]
So, for example, to calculate the distance of pt from the origin we could write:
or
dist = math.sqrt(pt[0] ** 2 + pt[1] ** 2)
Now this is not very readable, and if someone sees this code they will have to know that pt[0]
means the x-coordinate and pt[1] means the y-coordinate.
This is not very transparent.
Copyright © MathByte Academy

Using a Class Instead
At this point, in order to make things clearer for the reader (not the compiler, the reader), we 
might want to approach this using a class instead.
class Point2D:
def __init__(self, x, y):
self.x = x
self.y = y
class Stock:
def __init__(self, symbol, year, month, day, open, high, low, close):
self.symbol = symbol
self.year = year
self.month = month
self.day = day
self.open = open
self.high = high
self.low = low
self.close = close
pt = Point2D(10, 20)
distance = sqrt(pt.x ** 2 + pt.y ** 2)
djia.symbol
djia[0]
Tuple Approach
Class Approach
djia.open
djia.close
djia[4]
djia[7]
djia.high – djia.low
djia[5] – djia[6]
Copyright © MathByte Academy

Extra Stuff
At the very least we should implement the __repr__ method
à Point(x=10, y=20)
We probably should implement the __eq__ method too
à Point(10, 20) == Point(10, 20) à True
class Point2D:
def __init__(self, x, y):
self.x = x
self.y = y
def __repr__(self):
return f'Point2D(x={self.x}, y={self.y}'
def __eq__(self, other):
if isinstance(other, Point2D):
return self.x == other.x and self.y == other.y
else:
return False
Copyright © MathByte Academy

Named Tuples to the rescue
There are other reasons to seek another approach. I cover some of those in the coding video
Amongst other things, Point2D objects are mutable – something we may not want!
There's a lot to like using tuples to represent simple data structures
The real drawback is that we have to know what the positions mean, and remember this in our code
If we ever need to change the structure of our tuple in our code (like inserting a value that we forgot)
most likely our code will break!
eric = ('Idle', 42)
last_name, age = eric
eric = ('Eric', 'Idle', 42)
last_name, age = eric
Broken!!
Class approach:
last_name = eric.last_name
age = eric.age
Copyright © MathByte Academy

Named Tuples to the rescue
So what if we could somehow combine these two approaches, essentially creating tuples
where we can, in addition, give meaningful names to the positions?
That's what namedtuples essentially do
They subclass tuple, and add a layer to assign property names to the positional elements
Located in the collections standard library module
from collections import namedtuple
namedtuple is a function
which generates a new class
à class factory
that new class inherits from tuple
but also provides named properties to access elements of the tuple
but an instance of that class is still a tuple
Copyright © MathByte Academy

Generating Named Tuple Classes
We have to understand that namedtuple is a class factory
When we use it, we are essentially creating a new class, just as if we had used class ourselves
namedtuple needs a few things to generate this class:
•
the class name we want to use
•
a sequence of field names (strings) we want to assign, in the order of the elements in the tuple
The return value of the call to namedtuple will be a class
We need to assign that class to a variable name in our code so we can use it to construct instances
In general, we use the same name as the name of the class that was generated
Point2D = namedtuple('Point2D', ['x', 'y'])
field names can be any valid variable name 
except that they cannot start with an underscore
Copyright © MathByte Academy

Point2D = namedtuple('Point2D', ['x', 'y'])
We can create instances of Point2D just as we would with any class (since it is a class)
pt = Point2D(10, 20)
The variable name that we use to assign to the class generated and returned by namedtuple is arbitrary
Pt2D = namedtuple('Point2D', ['x', 'y'])
pt = Pt2D(10, 20)
Generating Named Tuple Classes
Copyright © MathByte Academy

class MyClass:
pass
MyClassAlias = MyClass
Class: 
MyClass
Variable: MyClass
0xFF300
Variable: MyClassAlias
instance_1 = MyClass()
instance_2 = MyClassAlias()
instantiates the same class
Similarly
Pt2DAlias = namedtuple('Point2D', ['x', 'y'])
Class: 
Point2D
Variable: Pt2DAlias
0xFF900
This is the same concept as aliasing a function, or assigning a lambda 
function to a variable name!
Generating Named Tuple Classes
Copyright © MathByte Academy

Generating Named Tuple Classes
There are many ways we can provide the list of field names to the namedtuple function
•
a list of string
•
a tuple of strings
•
a single string with the field names separated by whitespace or commas
namedtuple('Point2D', ['x', 'y'])
namedtuple('Point2D', ('x', 'y'))
à in fact any sequence, just remember that order matters!
namedtuple('Point2D', 'x, y')
namedtuple('Point2D', 'x y')
Copyright © MathByte Academy

Instantiating Named Tuples
After we have created a named tuple class, we can instantiate them just like an ordinary class
In fact, the __new__ method of the generated class uses the field names we provided as param names
Point2D = namedtuple('Point2D', 'x y')
pt1 = Point2D(10, 20)
10 à x
pt2 = Point2D(x=10, y=20)
We can use positional arguments:
And even keyword arguments:
20 à y
10 à x
20 à y
Copyright © MathByte Academy

Accessing Data in a Named Tuple
Since named tuples are also regular tuples, we can still handle them just like any other tuple
•
by index
•
slice
•
iterate
Point2D = namedtuple('Point2D', 'x y')
pt1 = Point2D(10, 20)
x, y = pt1
x = pt1[0]
isinstance(pt1, tuple) à True
for e in pt1:
print(e)
Copyright © MathByte Academy

Accessing Data in a Named Tuple
But now, in addition, we can also access the data using the field names:
Point2D = namedtuple('Point2D', 'x y')
pt1 = Point2D(10, 20)
pt1.x
à 10
pt1.y
à 20
Since namedtuple generated classes inherit from tuple
class Point2D(tuple):
…
pt1 is a tuple, and is therefore immutable
pt1.x = 100
will not work!
Copyright © MathByte Academy

The rename keyword-only argument for namedtuple
Remember that field names for named tuples must be valid identifiers, but cannot start 
with an underscore
This would not work:
Person = namedtuple('Person', 'name age _ssn')
namedtuple has a keyword-only argument, rename
that will automatically rename any invalid field name
uses convention:
_{position in list of field names}
Person = namedtuple('Person', 'name age _ssn', rename=True)
This will now work:
(defaults to False)
And the actual field names would be:
name
age
_2
Copyright © MathByte Academy

Introspection
We can easily find out the field names in a named tuple generated class
class property à _fields
Person = namedtuple('Person', 'name age _ssn', rename=True)
Person._fields
à ('name', 'age', '_2')
Copyright © MathByte Academy

Introspection
Remember that namedtuple is a class factory, i.e. it generates a class
We can actually see what the code for that class is, using the class property _source
Point2D = namedtuple('Point2D', 'x y')
Point2D._source
class Point2D(tuple):
'Point2D(x, y)'
def __new__(_cls, x, y):
'Create new instance of Point2D(x, y)'
return _tuple.__new__(_cls, (x, y))
def __repr__(self):
'Return a nicely formatted representation string'
return self.__class__.__name__ + '(x=%r, y=%r)' % self
x = _property(_itemgetter(0), doc='Alias for field number 0')
y = _property(_itemgetter(1), doc='Alias for field number 1')
à
lots of code omitted
Copyright © MathByte Academy

Extracting Named Tuple Values to a Dictionary
Instance method: _asdict()
that creates a dictionary of all the named values in the tuple
Point2D = namedtuple('Point2D', 'x y')
pt1 = Point2D(10, 20)
pt1._asdict()
à {'x': 10, 'y': 20}
Copyright © MathByte Academy

Copyright © MathByte Academy

Named Tuples are Immutable
So how can we "change" one or more values inside the tuple?
Just like with strings, we have to create a new tuple, with the modified values
Point2D = namedtuple('Point2D', 'x y')
pt = Point2D(0, 0)
Simple approach:
pt = Point2D(100, pt.y)
Suppose we need to change the value of the x coordinate:
Note that the memory address of pt has now changed
Copyright © MathByte Academy

Drawback
This simple approach can work well, but it has a major drawback
Stock = namedtuple('Stock', 'symbol year month day open high low close')
djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)
Suppose we only want to change the close field
djia = Stock(djia.symbol, 
djia.year, 
djia.month, 
djia.day, 
djia.open, 
djia.high, 
djia.low, 
26_394)
painful!
Copyright © MathByte Academy

Maybe slicing or unpacking?
djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)
current = djia[:7]
current à ('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260)
*current, _ = djia current à ['DJIA', 2018, 1, 25, 26_313, 26_458, 26_260]
We can also use the _make class method – but we need to create an iterable that contains all 
the values first:
new_values = current.append(26_394)
new_values à 'DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_394
djia = Stock(*current, 26_394)
djia = Stock._make(new_values)
iterable
new_values = current + (26_394,)
Copyright © MathByte Academy

This still has drawbacks
What if we wanted to change a value in the middle, say day?
djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)
Cannot use extended unpacking (only one starred value in extending unpacking)
*pre, day, *post = djia
makes no sense…
Slicing will work:
pre = djia[:3]
post = djia[4:]
new_values = pre + (26,) + post
new_values à ('DJIA', 2018, 1, 26, 26_313, 26_458, 26_260, 26_394)
djia = Stock(*new_values)
Copyright © MathByte Academy

But even this still has drawbacks!
How about modifying both the day and the high values?
djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)
new_values = djia[:3] + (26,) + djia[4:5] + (26_459,) + djia[6:] 
This is just unreadable and extremely error prone!
There has to be a better way!
djia = Stock(*new_values)
3
5
Copyright © MathByte Academy

The _replace instance method
Named tuples have a very handy instance method, _replace
It will copy the named tuple into a new one, replacing any values from keyword arguments
The keyword arguments are simple the field names in the tuple and the new value
The keyword name must match an existing field name
Stock = namedtuple('Stock', 'symbol year month day open high low close')
djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)
djia = djia._replace(day=26, high=26_459, close=26_394)
djia à 'DJIA', 2018, 1, 26, 26_313, 26_459, 26_260, 26_394
Note that the memory address of djia has now changed
Copyright © MathByte Academy

Extending a Named Tuple
Sometimes we want to create named tuple that extends another named tuple, appending one 
or more fields
Stock = namedtuple('Stock', 'symbol year month day open high low close')
We want to create a new named tuple class, StockExt that adds a single field, previous_close
When dealing with classes, this is sometimes done by using subclassing.
But this not easy to do with named tuples
and there's a cleaner way of doing it anyway
Copyright © MathByte Academy

Extending a Named Tuple
Point2D = namedtuple('Point2D', 'x y')
Let's say we want to create a Point3D named tuple that has an extra parameter
Yes, the obvious, and simplest approach here is best:
Point3D = namedtuple('Point3D', 'x y z')
But what happens if you have a lot of fields in the named tuple? Code is not as clean anymore…
Stock = namedtuple('Stock', 'symbol year month day open high low close')
StockExt = namedtuple('Stock', 'symbol year month day open high low close previous_close')
How about re-using the existing field names in Stock?
Copyright © MathByte Academy

Extending a Named Tuple
Stock = namedtuple('Stock', 'symbol year month day open high low close')
Stock._fields à 'symbol', 'year', 'month', 'day', 'open', 'high', 'low', 'close'
We can then create a new named tuple by "extending" the _fields tuple
new_fields = Stock._fields + ('previous_close', )
StockExt = namedtuple('StockExt', new_fields)
Copyright © MathByte Academy

Extending a Named Tuple
We can also easily use an existing Stock instance to create a new StockExt instance
with the same common values, adding in our new previous_close value:
Stock = namedtuple('Stock', 'symbol year month day open high low close')
djia = Stock('DJIA', 2018, 1, 25, 26_313, 26_458, 26_260, 26_393)
StockExt = namedtuple('StockExt', Stock._fields + ('previous_close', )
djia_ext = StockExt(*djia, 26_000)
or
djia_ext = StockExt._make(djia + (26_000, ))
Copyright © MathByte Academy

Copyright © MathByte Academy

Default Docs for Named Tuples
When we create a named tuple class, default docstrings are created
Point2D = namedtuple('Point2D', 'x y')
Point2D.__doc__ 
à Point2D(x, y)
help(Point2D)
class Point2D(builtins.tuple)
Point2D(x, y)
x
Alias for field number 0
y
Alias for field number 1
Point2D.x.__doc__ 
à Alias for field number 0
à
Point2D.y.__doc__ 
à Alias for field number 1
Copyright © MathByte Academy

Overriding DocStrings
We can override the docstrings simply by specifying values for the __doc__ properties
(this is not unique to named tuples!)
Point2D.__doc__ = 'Represents a 2D Cartesian coordinate.'
Point2D.x.__doc__ = 'x coordinate'
Point2D.y.__doc__ = 'y coordinate'
class Point2D(builtins.tuple)
Represents a 2D Cartesian coordinate.
x
x coordinate
y
y coordinate
help(Point2D)
à
Copyright © MathByte Academy

Default Values
The namedtuple function does not provide us a way to define default values for each field
Two approaches to this:
Create an instance of the named tuple with default values - the prototype
Using a Prototype
Create any additional instances of the named tuple using the prototype._replace method
Using the __defaults__ property
Directly set the defaults of the named tuple constructor (the __new__ method)
Remember that you cannot have non-defaulted parameters 
after the first defaulted parameter
def func(a, b=10, c=20)
def func(a, b=10, c)
You will need to supply a default for every field (can be None)
You do not need to specify a default for every field
Copyright © MathByte Academy

Using a Prototype
Vector2D = namedtuple('Vector2D', 'x1 y1 x2 y2 origin_x origin_y')
vector_zero = Vector2D(x1=0, y1=0, x2=0, y2=0, origin_x=0, origin_y=0)
vector_zero = Vector2D(0, 0, 0, 0, 0, 0)
or
vector_zero à Vector2D(x1=0, y1=0, x2=0, y2=0, origin_x=0, origin_y=0)
To construct a new instance of Vector2D we now use vector_zero._replace instead:
v1 = vector_zero._replace(x1=10, y1=10, x2=20, y2=20)
v1 à Vector2D(x1=10, y1=10, x2=20, y2=20, origin_x=0, origin_y=0)
Copyright © MathByte Academy

Using __defaults__
def func(a, b=10, c=20):
pass
func.__defaults__ à (10, 20)
a
b
c
10 20
no default
The __defaults__ property is writable
So we can set it to a tuple of our choice
Just don't provide more defaults than parameters!
(extras are ignored)
Copyright © MathByte Academy

Using __defaults__
We need to provide defaults to the constructor of our named tuple class
__new__
Vector2D = namedtuple('Vector2D', 'x1 y1 x2 y2 origin_x origin_y')
Vector2D.__new__.__defaults__ = (0, 0)
x1 y1 x2 y2 origin_x
origin_y
0
0
v1 = Vector2D(10, 10, 20, 20)
v1 à Vector2D(x1=10, y1=10, x2=20, y2=20, origin_x=0, origin_y=0)
Isn't this cleaner than the prototype approach?!!
v1 = vector_zero._replace(x1=10, y1=10, x2=20, y2=20)
Copyright © MathByte Academy

Copyright © MathByte Academy

Modules
What are modules exactly?
à objects of type ModuleType
How does Python load modules?
How to import without the import statement
Reloading modules
à why we should not do it!
Import variants
à
import
from … import …
from … import *
Misconceptions
Copyright © MathByte Academy

__main__
in modules
as file names
Zip Archives
importing from a zip archive
zipping an entire Python app
creating an executable Python app in bash
Copyright © MathByte Academy

Packages
What is a package?
How is it different from a module?
The role of __init__.py files in packages
Implicit Namespace Packages
What are they?
How do we create and use them?
vs standard packages
Why use them?
(Python 3.3+)
Copyright © MathByte Academy

Copyright © MathByte Academy

Import variants
import math
# module1.py
is math in sys.modules?
sys.modules
if not, load it and insert ref
math
<module object>
add symbol math to module1's global namespace referencing the same object
module1.globals()
math
<module object>
(if math symbol already exists in module1's namespace, replace reference)
math symbol in namespace
Copyright © MathByte Academy

Import variants
import math as r_math
# module1.py
is math in sys.modules?
sys.modules
if not, load it and insert ref
math
<module object>
add symbol r_math to module1's global namespace referencing the same object
module1.globals()
r_math
<module object>
(if r_math symbol already exists in module1's namespace, replace reference)
math symbol not in namespace
r_math symbol in namespace
Copyright © MathByte Academy

Import variants
from math import sqrt
# module1.py
is math in sys.modules?
sys.modules
if not, load it and insert ref
math
<module object>
add symbol sqrt to module1's global namespace referencing math.sqrt
module1.globals()
sqrt
<math.sqrt object>
(if sqrt symbol already exists in module1's namespace, replace reference)
math symbol not in namespace
Copyright © MathByte Academy

Import variants
from math import sqrt as r_sqrt
# module1.py
is math in sys.modules?
sys.modules
if not, load it and insert ref
math
<module object>
add symbol r_sqrt to module1's global namespace referencing math.sqrt
module1.globals()
r_sqrt <math.sqrt object>
(if r_sqrt symbol already exists in module1's namespace, replace reference)
math symbol not in namespace
Copyright © MathByte Academy

Import variants
from math import *
# module1.py
is math in sys.modules?
sys.modules
if not, load it and insert ref
math
<module object>
add "all" symbols defined in math to module1's global namespace
module1.globals()
pi
<math.pi object>
(if any symbols already exists in module1's namespace, replace their reference)
what "all" means can be 
defined by the module being 
imported
sin
<math.sin object>
and many more…
math symbol not in namespace
Copyright © MathByte Academy

In every case the math module was loaded into memory and referenced in sys.modules
Commonality
Running
from math import sqrt
did not "partially" load math
it only affected what symbols were placed in module1's namespace!
Things may be different with packages, but for simple modules this is the behavior
Copyright © MathByte Academy

Why from <module> import * can lead to bugs
from cmath import *
# module1.py
module1.globals()
sqrt
<cmath.sqrt>
…
from math import *
module1.globals()
sqrt
<math.sqrt>
…
Copyright © MathByte Academy

Efficiency
What's more efficient?
import math
from math import sqrt
or
importing
à same amount of work
calling
math.sqrt(2)
sqrt(2)
This first needs to find the sqrt symbol in math's namespace
dict lookup à super fast!
Copyright © MathByte Academy

Copyright © MathByte Academy

What we've seen so far…
Modules can be imported using
the import statement
importlib.import_module
sys.modules
When a module is imported:
module has to be located (found) somewhere
finders
e.g.   sys.meta_path
module code has to be retrieved (loaded)
loaders
returned by finder à ModuleSpec
a reference to the module is added to the system cache
module is compiled
module is executed
"empty" module typed object is created
system cache is checked first
sys.modules
à if in cache, just returns cached reference
otherwise:
à sets up the module's namespace (module.__dict__ is module.globals())
Copyright © MathByte Academy

Module Finders
sys.meta_path à
_frozen_importlib.BuiltinImporter
_frozen_importlib.FrozenImporter
_frozen_importlib_external.PathFinder
finds built-ins, such as math
finds frozen modules
file-based modules
PathFinder
Finds file-based modules based on sys.path and package __path__
sys.path à
['/home/fmb/my-app',
'/usr/lib/python36.zip',
'/usr/lib/python3.6',
'/usr/lib/python3.6/lib-dynload',
'/usr/local/lib/python3.6/dist-packages',
'/usr/lib/python3/dist-packages']
collections.__path__ à
['/usr/lib/python3.6/collections']
Copyright © MathByte Academy

Module Properties
built-in
import math
type(math) 
à module
math.__spec__ 
à ModuleSpec(name='math', 
loader=<class '_frozen_importlib.BuiltinImporter'>
origin='built-in')
math.__name__
à math
math.__package__ 
à ''
__file__ is not an attribute of math
(built-ins only)
Copyright © MathByte Academy

Module Properties
standard library
import fractions
type(fractions) 
à module
fractions.__spec__ 
à
fractions.__name__
à fractions
fractions.__package__ à ''
fractions.__file__ 
à /usr/lib/python3.6/fractions.py 
ModuleSpec(name='fractions',
loader=<_frozen_importlib_external.SourceFileLoader
object at 0x7fa9bf7ff6d8>,
origin='/usr/lib/python3.6/fractions.py')
Note that fractions.__file__ was found by PathFinder in one of the paths listed in sys.path
Copyright © MathByte Academy

Module Properties
custom module
import module1
type(module1) 
à module
module1.__spec__ 
à
module1.__name__
à module1
module1.__package__ 
à ''
module1.__file__ 
à /home/fmb/my-app/module1.py
Note that module1.__file__ was found by PathFinder in one of the paths listed in sys.path
ModuleSpec(name='module1',
loader=<_frozen_importlib_external.SourceFileLoader
object at 0x7fd9f4c4ae48>,
origin='/home/fmb/my-app/module1.py')
Copyright © MathByte Academy

Some Notes
Python modules may reside
in the built-ins
in files on disk
anywhere else that can be accessed by a finder and a loader
custom finders/loaders à database, http, etc
For file based modules (PathFinder):
They must exist in a path specified in
sys.path
or in a path specified by <package>.__path__
they can even be pre-compiled, frozen, or even inside zip archives
PEP 302
Python docs: 
https://docs.python.org/3/tutorial/modules.html
https://docs.python.org/3/reference/import.html
Copyright © MathByte Academy

Copyright © MathByte Academy

Packages are Modules
Packages are modules
(but modules are not necessarily packages)
They can contain
modules
packages
(called sub-packages)
If a module is a package, it must have a value set for __path__
After you have imported a module, you can easily see if that module is a package by 
inspecting the __path__ attribute
(empty à module, non-empty à package)
Copyright © MathByte Academy

Packages and File Systems
Remember that modules do not have to be entities in a file system
(loaders, finders)
By the same token, packages do not have to be entities in the file system
Typically they are - just as typically modules are file system entities
But packages represent a hierarchy of modules / packages
pack1.mod1
pack1.pack1_1.mod1_1
dotted notation indicates the path hierarchy of modules / packages
and is usually found in __path__
Copyright © MathByte Academy

Importing Nested Packages
If you have a statement in your top-level program such as:
import pack1.pack1_1.module1
The import system will perform these steps:
imports pack1
imports pack1.pack1_1
imports pack1.pack1_1.module1
The sys.modules cache will contain entries for:
pack1
pack1.pack1_1
pack1.pack1_1.module1
The namespace where the import was run contains:
pack1
Copyright © MathByte Academy

File System Based Packages
Although modules and packages can be far more generic than file system based entities,
it gets complicated!
If you're interested in this, then the first document you should read is PEP302
In this course we're going to stick to traditional file based modules and packages
Copyright © MathByte Academy

File Based Packages
à package paths are created by using file system directories and files
Remember: a package is simply a module that can contain other modules/packages
On a file system we therefore have to use directories for packages
The directory name becomes the package name
So where does the code go for the package (since it is a module)?
__init__.py
Copyright © MathByte Academy

__init__.py
To define a package in our file system, we must:
create a directory whose name will be the package name
create a file called __init__.py inside that directory
That __init__.py file is what tells Python that the directory is a package as opposed to 
a standard directory
(if we don't have an __init__.py file, then Python creates an implicit namespace package)
– we'll discuss that later
Copyright © MathByte Academy

What happens when a file based package is imported?
app/
pack1/
__init__.py
module1.py
module2.py
import pack1
the code for pack1 is in __init__.py
that code is loaded, executed and cached in sys.modules with a key of pack1
the symbol pack1 is added to our namespace referencing the same object 
it's just a module!
it's just a module!
but, it has a __path__ property
à file system directory path (absolute)
also has a __file__ property
à file system path to __init__.py (absolute)
Copyright © MathByte Academy

Nested Packages
Packages can contain modules as well as packages
app/
pack1/
__init__.py
module1a.py
module1b.py
pack1_1/
__init__.py
module1_1a.py
module1_1b.py
module inside pack1
pack1.module1a
package inside pack1
pack1.pack1_1
module inside pack1.pack1_1
pack1.pack1_1.module1_1b
Copyright © MathByte Academy

__file__, __path__ and __package__ Properties
Modules have __file__ and __package__ properties
__file__ is the location of module code in the file system
__package__ is the package the module code is located in
(an empty string if the module is located in the application root)
If the module is also a package, then it also has a __path__ property
__path__ is the location of the package (directory) in the file system
Copyright © MathByte Academy

app/
module.py
pack1/
__init__.py
module1a.py
module1b.py
pack1_1/
__init__.py
module1_1a.py
module1_1b.py
module.__file__ à …/app/module.py
module.__path__ à not set
module.__package__ à ''
pack1.__file__ à …/app/pack1/__init__.py
pack1.__path__ à …/app/pack1
pack1.__package__ à pack1
pack1.module1a.__file__ à …/app/pack1/module1a.py
pack1.module1a.__path__ à not set
pack1.module1a.__package__ à pack1
Copyright © MathByte Academy

app/
module.py
pack1/
__init__.py
module1a.py
module1b.py
pack1_1/
__init__.py
module1_1a.py
module1_1b.py
pack1.pack1_1.__file__ à …/app/pack1/pack1_1/__init__.py
pack1.pack1_1.__path__ à …/app/pack1/pack1_1
pack1.pack1_1.__package__ à pack1.pack1_1
pack1.pack1_1.module1_1a.__file__ à …/app/pack1/pack1_1/module1_1a.py
pack1.pack1_1.module1_1a.__path__ à not set
pack1.pack1_1.module1_1a.__package__ à pack1.pack1_1
Copyright © MathByte Academy

app/
module.py
pack1/
__init__.py
module1a.py
module1b.py
pack1_1/
__init__.py
module1_1a.py
module1_1b.py
import pack1.pack1_1.module1_1a
What gets loaded during the import phase?
pack1 is imported and added to sys.modules
at the very least:
pack1_1 is imported and added to sys.modules
module1_1a is imported and added to sys.modules
but, modules can import other modules!
pack1.__init__.py could import other modules/packages
pack1_1.__init__.py could import other modules/packages
module1_1a.__init__.py could import other modules/packages
Copyright © MathByte Academy

app/
module.py
pack1/
__init__.py
module1a.py
module1b.py
pack1_1/
__init__.py
module1_1a.py
module1_1b.py
For example…
# pack1.__init__.py
import pack1.module1a
import pack1.module1b
import pack1.pack1_1.module1_1a
pack1 is imported and added to sys.modules
pack1_1 is imported and added to sys.modules
module1a is imported and added to sys.modules
Just as before:
but now also:
module1_1a is imported and added to sys.modules
module1b is imported and added to sys.modules
Copyright © MathByte Academy

app/
module.py
pack1/
__init__.py
module1a.py
module1b.py
pack1_1/
__init__.py
module1_1a.py
module1_1b.py
For example…
# pack1.__init__.py
import pack1.module1a
import pack1.module1b
import pack1
pack1 is imported and added to sys.modules
module1a is imported and added to sys.modules
module1b is imported and added to sys.modules
Copyright © MathByte Academy

Copyright © MathByte Academy

Code Organization, Ease of Use…
Suppose you have 50 different functions and classes in your program
connect
execute_no_result
execute_single_row
execute_multi_row
normalize_string
convert_str_to_bool
format_iso_date
current_time_utc
authenticate
validate_token
get_permissions
authorize_endpoint
User
UserProfile
Users
BlogPost
BlogPosts
RouteTable
Configuration
JSONEncoder
UnitTests
audit_endpoint
Logger
validate_email
validate_phone
validate_name
etc…
api.py
(single file)
in one file???
Copyright © MathByte Academy

Start with Modules…
api.py
dbutilities.py
typeconversions.py
authentication.py
authorization.py
users.py
blogposts.py
jsonutilities.py
validations.py
logging.py
unittests.py
api/
better…
but still unwieldy – everything is at the top level
import dbutilities
import jsonutilities
import typeconversions
import validations
import authentication
import authorization
import users
etc…
too many imports:
certain modules could be broken down further:
dbutilities à connections, queries
certain modules belong "together":
authentication, authorization à security
users à User, Users, UserProfile
Copyright © MathByte Academy

So, Packages…
api.py
dbutilities.py
typeconversions.py
authentication.py
authorization.py
users.py
blogposts.py
jsonutilities.py
validations.py
logging.py
unittests.py
api/
api/
utilities/
database/
__init__.py
__init__.py
connections.py
queries.py
json/
__init__.py
encoders.py
decoders.py
security/
__init__.py
authentication.py
authorization.py
models/
users/
__init__.py
__init__.py
user.py
userprofile.py
Copyright © MathByte Academy

Another Use Case
You have a module that implements 2 functions/classes for users of the module
Those two objects require 20 different helper functions and 2 additional helper classes
From module developer's perspective:
much easier to break the code down into multiple modules
From module user's perspective:
they just want a single import for the function and the class
i.e. it should look like a single module
Copyright © MathByte Academy

Module Developer's Perspective
mylib/
__init__.py
submod1.py
submod2.py
subpack1
__init__.py
pack1mod1.py
pack1mod2.py
function to be exported to user lives here
class to be exported to user lives here
Smaller code modules, with a specific purpose, are easier to write, debug, test, and understand
Copyright © MathByte Academy

Module User's Perspective
mylib/
__init__.py
submod1.py
submod2.py
subpack1
__init__.py
pack1mod1.py
pack1mod2.py
function to be exported to user lives here
class to be exported to user lives here
User should not have to write:
from mylib.submod1 import my_func
from mylib.subpack1.pack1mod2 import MyClass
Much easier for user if they could write:
import mylib
or, simply
from mylib import my_func, MyClass
mylib.my_func()
mylib.MyClass()
Copyright © MathByte Academy

Using __init__.py
We can use packages' __init__.py code to export (expose) just what's needed by our users
We'll cover this in the next video
Example:
mylib/
__init__.py
submod1.py
submod2.py
subpack1
__init__.py
pack1mod1.py
pack1mod2.py
function to be exported 
to user lives here
class to be exported 
to user lives here
# mylib.__init__.py
from mylib.submod1 import my_func
from mylib.subpack1.pack1mod2 import MyClass
import mylib
mylib.my_func()
mylib.MyClass()
User uses it this way:
our internal implementation is "hidden"
Copyright © MathByte Academy

So, why Packages?
ability to break code up into smaller chunks, makes our code:
easier to write
easier to test and debug
easier to read/understand
easier to document
just like books are broken down into 
chapters, sections, paragraphs, etc.
but they can still be "stitched" together
hides inner implementation from users
makes their code
easier to write
easier to test and debug
easier to read/understand
Copyright © MathByte Academy

Copyright © MathByte Academy

What are Implicit Namespace Packages?
Namespace packages are package-like
directories
but cannot contain __init__.py
These directories are implicitly made into these special types of packages
PEP 420
may contain modules
may contain nested regular packages
may contain nested namespace packages
Copyright © MathByte Academy

Mechanics
utils/
validators/
boolean.py
date.py
json/
__init__.py
serializers.py
validators.py
utils/ does not contains __init__.py
à namespace package
validators/ does not contain __init__.py
à namespace package
boolean.py is a file with a .py extension
à module
json/ contains __init__.py
à regular package
serializers.py is a file with a .py extension
à module
Copyright © MathByte Academy

Regular vs Namespace Packages
Regular Package
Namespace Package
type
type
à module
à module
__init__.py
à yes
__init__.py
à no
single package lives in single 
directory
single package can live in multiple (non-nested) 
directories
__file__
à package __init__
__file__
à not set
paths
à breaks if parent 
directories change 
and absolute imports 
are used
paths
à dynamic path computation
so OK if parent directories change
in fact, parts of the namespace may even be 
in a zip file
(your import statements will still 
need to be modified)
Copyright © MathByte Academy

Example
utils
common
namespace
package
regular
package
type
module
module
utils/
validators/
boolean.py
common/
__init__.py
boolean.py
validators/
app/
__name__
utils
common
__repr__()
<module utils (namespace)>
<module common from '…/app/common'>
__path__
_Namespace(['…/app/utils'])
['…/app/utils']
__file__
not set
…/app/common/__init__.py
__package__
utils
common
à validators
utils.validators
common.validators
Copyright © MathByte Academy

utils/
validators/
boolean.py
date.py
json/
__init__.py
serializers.py
validators.py
import utils.validators.boolean
from utils.validators import date 
import utils.validators.json.serializers
First familiarize yourself with regular packages.
Once you are completely comfortable with them, check out namespace packages if you want
Read PEP 420 – that should definitely be your starting point
Import Examples
Copyright © MathByte Academy

Copyright © MathByte Academy

What's in this section?
Tips and tricks
Pythonic code
Opiniated
Will grow over time
Things I find interesting
Send me your suggestions!
This is NOT going to be discussions of 3rd party Library XYZ
(As of today PyPi has 128,291 packages!)
Copyright © MathByte Academy

Copyright © MathByte Academy

The Python documentation
That should be your top bookmark for Python
https://docs.python.org
Don't forget to make sure you are looking at your version of Python. 
3.6 or above please!
Copyright © MathByte Academy

PEP – Python Enhancement Proposals
These are a fantastic resource to understand how certain things work in Python,
and why they were implemented in a certain way.. 
Index page
Not all PEPs actually make it into Python. Some are rejected, deferred or even withdrawn.
https://www.python.org/dev/peps/
But sometimes a web search such as: Python PEP Style Guide is more practical
search on that page
Reading the PEPs that have not been accepted also provides a lot of insight!
A lot of thought by many people go into these PEPs, whether they make it or not.
Some PEPs are for language features
some are informational only
Copyright © MathByte Academy

PEP 8 – Style Guide and Idiomatic Python
PEP 20 – Zen of Python
or just type import this in a Python console/Jupyter
PEP – Some Notable Ones
PEP 484 – Type Hints
PEP 537 – Python 3.7 Release Schedule
or whatever release your interested in at the time
PEP 468 – Python 3.6 Release Schedule
they provide links to other PEPs relevant to the release
And many many more, depending on what topic you’re interested in
Copyright © MathByte Academy

Wikipedia
Great resource for explanations of general computer science concepts
Copyright © MathByte Academy

Books
These are my favorite Python specific go to books
not in any particular order of importance!
Learning Python
Mark Lutz
Copyright © MathByte Academy

Books
Fluent Python
Luciano Ramalho
Copyright © MathByte Academy

Books
Python Cookbook
David Beazley & Brian K. Jones
Copyright © MathByte Academy

Books
Effective Python: 59 Specific Ways to Write Better Python
Brett Slatkin
Copyright © MathByte Academy

Books
Books
Python in a Nutshell
Alex Martelli, Anna Ravenscroft & Steve Holden
Copyright © MathByte Academy

Other Online Resources I Regularly Use
Raymond Hettinger's Twitter Feed
just awesome!
@raymondh
YouTube
#python tip: zip() with star-arguments is 
great for transposing 2-D data: 
m = [(1, 2, 3), (4, 5, 6)] 
list(zip(*m)) 
[(1, 4), (2, 5), (3, 6)]
example:
Lots of great videos on Python.
Look out for PyCon videos – these are fantastic!
Anything by GvR, Raymond Hettinger, Alex Martelli…
And many more, including any library you're interested in
Planet Python Blog
http://planetpython.org/
Google Searches!
Stack Overflow
https://stackoverflow.com/
Copyright © MathByte Academy

