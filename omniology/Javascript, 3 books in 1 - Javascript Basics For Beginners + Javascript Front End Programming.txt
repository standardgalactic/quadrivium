

© Copyright 2021 - All rights reserved.
The contents of this book may not be reproduced, duplicated or transmitted without direct written
permission from the author.
Under no circumstances will any legal responsibility or blame be held against the publisher for any
reparation, damages, or monetary loss due to the information herein, either directly or indirectly.
Legal Notice:
This book is copyright protected. This is only for personal use. You cannot amend, distribute, sell, use,
quote or paraphrase any part or the content within this book without the consent of the author.
Disclaimer Notice:
Please note the information contained within this document is for educational and entertainment
purposes only. Every attempt has been made to provide accurate, up to date and reliable complete
information. No warranties of any kind are expressed or implied. Readers acknowledge that the author
is not engaging in the rendering of legal, financial, medical or professional advice. The content of this
book has been derived from various sources. Please consult a licensed professional before attempting
any techniques outlined in this book.
By reading this document, the reader agrees that under no circumstances is the author responsible for
any losses, direct or indirect, which are incurred as a result of the use of information contained within
this document, including, but not limited to, —errors, omissions, or inaccuracies.

Table of Contents
JAVASCRIPT
JavaScript Basics for Beginners
Introduction
Chapter One: An Introduction to JavaScript
The Developer of JavaScript
The Use Cases of JavaScript
The <script> Tag
Display
Values
Numbers
Arithmetic
Strings
JavaScript Arrays
Chapter Two: JavaScript Variables
JavaScript Identifiers
Datatypes
Declaration of Variables
The Undefined Variables
Re-Declaration
Arithmetic
JavaScript String Concatenation
JavaScript Let Keyword
Chapter Three: JavaScript Constants
Block Scope
Primitive Values
JavaScript Constants

Chapter Four: Prompts and Conditionals
The JavaScript if Statement
The else Statement
The else if Statement
JavaScript Switch Statement
Chapter Five: JavaScript Strings and Arrays
The lastIndexOf() Method
What If the Index Is Not Found?
The search() Method
JavaScript Arrays
JavaScript Array concat()
Array Sorting
Reverse Gear
Sorting Numeric
Compare Function
Random Sorting
Array Values
Object Array Sorting
JavaScript Iteration
Chapter Six: JavaScript Loops
The for/in Loop
The forEach() Loop
The for/of Loop
Eternal Loops
JavaScript while Loops
The  do/while Loop
JavaScript Break and Continue Statements
Chapter Seven: JavaScript Functions
The Invocation of Function
The () Operator
Functions as Variables

Local Variables
JavaScript Expressions
The constructor()
Self-Invoking
Functions or Objects
The toString() Method
Arrow Functions
Parameters & Arguments
Invocation
Global Objects
Reusing Methods
Chapter Eight: JavaScript Objects
The new Keyword
Object Properties
The Deletion
Dates
JavaScript Classes
Passing Parameters
Class Inheritance
Conclusion
References
JAVASCRIPT
JavaScript Front End Programming
Introduction
React Advantages
React Limitations
Chapter 1: ReactJS - Environment Setup
Local Environment Setup
With Webpack and Babel

The create-react-app Command
Chapter 2: Introducing React JSX
Why Use JSX?
How to Embed Expressions in JSX
JSX is an Expression
Specifying Attributes with JSX
How to Specify Children with JSX
Preventing Injection Attacks with JSX
JSX Represents Objects
Chapter 3: All About Components
The Component Lifecycle
Commonly Used Lifecycle Methods
Lifecycle Methods Rarely Used
Error Boundaries
Class Properties
Instance Properties
Chapter 4: State and Lifecycle
Converting Functions to Classes
Add Local State to a Class
Add Lifecycle Method to the Class
Correctly Using State
Data Flows Down
Chapter 5: ReactJS Props and PropTypes
Understanding Props
What Are React PropTypes?
Chapter 6: ReactJS Forms
Step One – Use JSX to Create a Basic Form
Step Two – Using Uncontrolled Components to Collect Form Data
Step Three – Using Controlled Components to Update Form Data
Step Four – Update Form Properties Dynamically

Chapter 7: ReactJS Events
Creating Events
Listening To Component Events
Adding Event Listeners
Handling Events
Passing an Argument to an Event Handler
Chapter 8: ReactJS Refs
Creating Refs
Using React Refs
Integration with DOM-Based Libraries
Rule of Thumb for Using Refs
Forwarding Refs
Chapter 9: ReactJS Lists and Keys
Rendering Lists in Components
All About Keys
Chapter 10: ReactJS Router
Routers
Routes
Switch Component
Link Component
Nested Routing
Protected Routes
Custom Routes
Chapter 11: ReactJS – Introduction to Flux
Introducing Flux
Mixin Example
Syncing with Web APIs
Chapter 12: ReactJS Animations
Introducing React Animation
Chapter 13: ReactJS Higher Order Components

Higher-Order Functions in JavaScript
What is a Higher-Order Component?
Higher Order Component Structure
Building a Higher Order Component - Example
Chapter 14: ReactJS Best Practices
Chapter 15: Let’s Create a React App
Step One: Setting Up a Boilerplate App
Step Two: The React App Structure
Step Three: Starting the Development Server
Conclusion
References
JAVASCRIPT
JavaScript Back End Programming
Introduction
Chapter One: Setting Up Your Node.js Environment
Windows
Mac and Linux
IDE Installation
IDE – Visual Studio Code
Hello World
Chapter Two: Node.js - REPL Terminal
Step One — Start and Stop the REPL
Step Two — Execute Code in the REPL
Step Three — Mastering REPL Shortcuts
Step Four — The REPL Commands
Chapter Three: Node.js - Package Manager (NPM)
Downloads and Installing Dependencies
Versioning

Running Tasks
Where Does npm Install the Packages?
Using or Executing Packages Installed With npm
Chapter Four: Node.js Callbacks and Promises
Chapter Five: Asynchronous JavaScript Programming
Synchronous JavaScript
Asynchronous JavaScript
Async Callbacks
Promises
Asynchronous Code Nature
Chapter Six: Node.js Event Loops  and Event Emitters
Phase Overview
setImmediate() vs setTimeout()
process.nextTick()
process.nextTick() vs setImmediate()
Chapter Seven: Node.js Buffers
What Are Buffers?
More Fun With Buffers
Chapter Eight: Node.js Streams
What Are Streams?
Async Iterator
How to Create a Writable Stream
pipeline()
The Stream Module
Chapter Nine: Node.js File System
What is the Synchronous and Asynchronous Approach?
Important fs.module Methods
Chapter Ten: Node.js Global Objects
Global Object
Global Modules and Functions

Global Objects
Chapter Eleven: Node.JS Utility Modules
OS Module
OS Module Methods
Path Module
Net Module
Class - net.Server
Class - net.Socket
DNS Module
Domain Module
Chapter Twelve: Node.js Web Module
Web Application Architecture
Using Node to Create a Web Server
Make a Request to Node.js Server
Create a Web Client Using Node
Chapter Thirteen: Node.js Express Framework
What is Express.js?
Installing and Using Express
What are Routes?
Building a Web Server with Express.js
Chapter Fourteen: Node.js RESTful API
HTTP Methods
RESTful Web Services
How to Create RESTful for a Library
List Users
Add User
Show Detail
Delete User
Chapter Fifteen: Node.js Scalable Applications
Strategies of Scalability

The Cluster Module
Load-Balancing an HTTP Server
Broadcasting Messages to All Workers
Increasing Availability of the Server
Zero-Downtime Restarts
Shared State and Sticky Load Balancing
Chapter Sixteen: Node.js Packaging
Packaging Your Node.js App
Package Using the Command-Line
Package Using the Code
Chapter Seventeen: MongoDB + Mongoose with Node.js – Best Practices
for Back End Developers
Why You Need Mongoose
Performing Mongoose Operations
Performing CRUD Operations
Conclusion
References

JAVASCRIPT
JAVASCRIPT BASICS 
FOR BEGINNERS
Andy Vickler

Introduction
This book contains proven steps and strategies on how to code in JavaScript.
I have included in the book step-by-step programming techniques in
JavaScript so that you can learn them properly. JavaScript is a scripted
language. You will see a lot of script embedded in HTML tags. As JavaScript
cannot work alone, I deemed it fit to embed it in HTML so that when you
want to run it, it works well in web browsers.
If you want to practice what you have learned, you can open up a code editor,
copy the code, and paste it in to check out the results. Also, you can simply
load up the page to the web browser to see the results directly on the web
page. Embedded scripts are in ready-to-work form. The best method to learn
the scripts by heart and then edit them to customize them so that you can
learn faster and in a fun way.
Whether you are making websites or are a student who aspires to become a
web developer, or are planning to build a website for your own business, this
book is the best literature you may come across on the market. Once you
have gone through the first couple of chapters, you will be in the right
mindset to move on and learn the complex topics. The best method is to go
slow at first and pace yourself as the concepts become clearer.
Chapter One
An Introduction to JavaScript
JavaScript is an interpreted language. The definition of the language is
broader than the word interpreted. You can define it as a procedural language
that is weakly typed, based on prototypes, and is dynamic and imperative.
JavaScript is developed and implemented in the form of a client-side

programming language. It is a part of the web browser and is seen as
something that can facilitate developers for the implementation of dynamic
features and creation and integration of user interface on the web pages. You
may find some implementation of JavaScript on the server-side as well.
However, the popularity of the JavaScript programming language is largely
based on its applications on the client-side. You may see applications of
JavaScript outside of web applications as well. For example, you may find
them being used as a way to add some interactivity to the desktop widgets
and to documents in PDF format.
JavaScript was initially designed in the same mold as the C language was
designed, but it also takes some Java programming language names. You
should not mistake Java for JavaScript because the two are inherently
different. They have different purposes and semantics as well.
The Developer of JavaScript
Brendan Each developed JavaScript initially with the name Mocha. The name
was changed later on to LiveScript. Late on, it was changed again to
JavaScript. The name confused some people, and it gave the impression that
the new language, namely JavaScript, was an offshoot of Java. People
thought that the new programing language was part of Netscape's marketing
strategy to gain the much-needed prestige in the world of new programming
languages.
The next year, Microsoft introduced a similar client-side language integrated
into their famous Internet Explorer 3.0 browser. It named the language
JScript to get away with brand problems. The term as it sounds and looks was
perceived as so much similar to JavaScript; however, where it differed was
that it could not be made 100% compatible with the specifications of ECMA.
In 1997, a proposal popped up to submit JavaScript to ECMA standards, and
in June 1997, ECMA standards adopted it with the nametag ECMAScript.
The programming language also won the ISO standard recommendation.
JavaScript amassed high-rated popularity because of the way it adapted to the
internet. That is the reason it became one of the most used programming
languages across the planet.

The Use Cases of JavaScript
JavaScript is at work at the client-side of most of the webpages around the
world. When you open a webpage, and it had changed from when you
previously opened it, well, those changes could have been made using
JavaScript. Let me tell you something interesting. Open a web page on your
computer screen. Right-click on the web page and then click on View Source.
You will see the word JavaScript inside the code of the page. Do not confuse
HTML with JavaScript because you may find the two in the code of the page.
HTML is a markup language that allows developers to format the content and
create a dynamic web page. You can turn the text into bold, create the boxes
and tables of your choice, and add buttons and bullets to the page. However,
JavaScript lets you alter the text, add pop-up messages, and validate the text
you have entered through HTML coding. HTML and JavaScript walk side by
side. Where JavaScript moves ahead of HTML is the way it makes the page
dynamic and interactive. It will allow your users to click on certain elements
and open new pages from the existing page.
You should learn JavaScript because it is very easy to implement. All you
need is to put the code in an HTML document and then instruct the browser
to run it. JavaScript works on many computers and operating systems, even
when the systems are offline. With JavaScript's help, you can create
responsive interfaces that refine user experience and offers extremely
dynamic functionality.
JavaScript allows users to load up content in the form of a document
whenever the user needs it, and that too without putting the web page into a
reload. We call the process Ajax. JavaScript allows you to run a test for
existing possibilities in the browser and then react accordingly. The process
is known as defensive Scripting. JavaScript will fix any problems that emerge
on your web pages. It will cover up the holes that exist in the browser
support.
When we compare all that JavaScript can do for us with other programming
languages for the web, we realize that it can do so much more. JavaScript is
highly demanded and loved because it allows you to build complex
applications without any hassle. You can build complex applications with
Flash as well, but JavaScript is the best way to go because it is a web

standard.
When it comes to the uses of JavaScript, the uses keep on changing. At first,
JavaScript's interaction with a website was constricted to forming interaction
and giving users feedback. However, it evolved with time, and now the uses
are much more than how it started.
The use cases of JavaScript are changing with the change of times. Users
need to change the tried, tested, and boring web interface of clicking on links,
filling out information on a web page, and sending off a bunch of forms.
They look at making the same processes more modern and user-friendly.
JavaScript has enabled users to create a sign-up form that has the capacity to
check if a username is already taken or is available. This prevents users from
enduring page reload that can somewhat be highly frustrating. A search box
shows you the more relevant and suggested results when you type something.
It shows something that is based on your entries. The pattern is known as
autocomplete - without JavaScript, that would not have been possible.
The information that needs to change after set times without any input from
the user is possible with the help of JavaScript. JavaScript may attempt to fix
layout issues. By using JavaScript, you may find the exact area and position
of any element on your web page. You can calculate the dimensions of the
window of your browser. By collecting and using this information, you may
help prevent the overlap of elements and other related issues. Let us suppose
you have a menu for different levels. You can prevent the overlap of the
menu items and scroll-bars by checking out the space for the sub-menu.
Perhaps the best way by which JavaScript can help you is to enhance the
interface that HTML gives you.
Code is labeled as the text that forms programs. In many chapters of the
books, you will find a lot of code. Reading and writing code, I must say, is an
integral part of the process to learn and write programs.
Metaprogramming is considered a powerful technique that can enable you to
write a set of programs. The advent of ES6 has further eased off the
utilization of metaprogramming in the world of JavaScript programming.
You can use proxies and other similar features. The proxies of ES6 tend to
facilitate the redefinition of different operations in objects.

The <script> Tag
Let us talk about the symbol that is the most used tag in the book. All the
JavaScript code is enclosed inside the <script> tags.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript rests in the Body</p>
<p id="demo12"></p>
<script>
document.getElementById("demo12").innerHTML = "This is your First JavaScript";
</script>
</body>
</html>
JavaScript Rests in the Body
This is your First JavaScript
The older type of JavaScript was written differently. It had the following
format such as <script type = “text/javascript”>.
There are functions in JavaScript that you can use to execute blocks of code.
You may call a function when some kind of event occurs. An event can be
defined as a click button. You can place any kind of script in an HTML
document. You can place the scripts either in the <head> or in the <body> or
in both of them. The example of using a script in the head is as under:
<!DOCTYPE html>
<html>
<head>
<script>
function FunctionUN() {
document.getElementById("demo34").innerHTML = "I have changed the Paragraph.";
}
</script>
</head>
<body>
<p>You have seen the JavaScript in the Head</p>
<p id="demo">This is a Paragraph.</p>
<button type="button" onclick="FunctionUN()">Click Me</button>
</body>
</html>
You have seen the JavaScript in the Head
This is a Paragraph.
Click Me

When you click the button on the web browser, you will trigger an invocation
of the function. You also can put the script inside the <body> of the HTML
page. You will invoke this function when you click the button.
<!DOCTYPE html>
<html>
<body>
<p>This is A Web Page</p>
<p id="demo1">This is a Paragraph</p>
<button type="button" onclick="FunctionZ()">Click Me</button>
<script>
function FunctionZ() {
document.getElementById("demo1").innerHTML = "I have changed the Paragraph.";
}
</script>
</body>
</html>
This is A Web Page
I have changed the Paragraph.
Click Me
Display
There are different methods to display JavaScript in web browsers.
Programmers use different techniques for display purposes. The first method
that I have used in the book is the document.getElementById(id) method. In
the phrase, id refers to the element that defines the HTML document. The
word innerHTML defines the content of HTML.
<!DOCTYPE html>
<html>
<body>
<p>This is going to be my First Web Page</p>
<p>This will be the First Paragraph.</p>
<p id="demo1234"></p>
<script>
document.getElementById("demo1234").innerHTML = 4567 + 36;
</script>
</body>
</html>
This is going to be my First Web Page
This will be the First Paragraph.
4603
The second method that you can use is the document.write() method. This

also is a simple one. However, I have not created any script in the book by
using this method except for this example to show you how it works:
<!DOCTYPE html>
<html>
<body>
<p>This is going to be my First Web Page</p>
<p>This will be the First Paragraph.</p>
<p id="demo1234"></p>
<script>
document.write (4567 + 36);
</script>
</body>
</html>
This is going to be my First Web Page
This will be the First Paragraph.
4603
If you use this method after loading the HTML page, you will lose all data
because it will be deleted. Therefore, you should beware of the consequences
if you make this mistake. Also, you can create a button with this method and
test the HTML page. See the following example.
<!DOCTYPE html>
<html>
<body>
<p>This is going to be my First Web Page</p>
<p>This will be the First Paragraph.</p>
<button type="button" onclick="document.write(335 + 6)">Click me</button>
</body>
</html>
This is going to be my First Web Page
This will be the First Paragraph.
Click me
Another method is the window alert method.
<!DOCTYPE html>
<html>
<body>
<p>This is going to be my First Web Page</p>
<p>This will be the First Paragraph.</p>
<p id="demo1234"></p>
<script>
window.alert (4567 + 36);
</script>

</body>
</html>
This is going to be my First Web Page
This will be the First Paragraph.
The above-mentioned text will be seen on the browser. Each time you run the
code, you will see the result of the mathematical calculation on an alert
window on the top of the screen. The use of the window keyword is optional.
As the window object in JavaScript is global, you may drop its use and still
get the same result. The following code will deliver the same result.
<!DOCTYPE html>
<html>
<body>
<p>This is going to be my First Web Page</p>
<p>This will be the First Paragraph.</p>
<p id="demo1234"></p>
<script>
alert (4567 + 36);
</script>
</body>
</html>
Another method is the console.log() method. This method is used for
debugging the code and then displaying the data.
<!DOCTYPE html>
<html>
<body>
<p>This is going to be my First Web Page</p>
<p>This will be the First Paragraph.</p>
<p id="demo1234"></p>
<script>
console.log (4567 + 36);
</script>
</body>
</html>
Values
In the world of computers, you will only see one thing that is data. You can
read through the data, modify the data, and create new data. All this data is
stored in the form of sequences that are fundamentally alike. Bits are two-
valued things that are usually described as ones and zeros. If you rip open a

computer, you will see that data takes multiple forms like low and high
charge, weak or strong signal, or dull and shiny spots on a CD. A piece of
discrete information may be reduced to a sequence of ones and zeros. As a
result, they are represented as bits. You can express any number in the form
of bits. The process is the same as that of the decimal number. However,
instead of writing many digits, you only have two to produce the result.
So, what are values? Just imagine an ocean of bits. A typical modern
computer contains about 30 billion bits in the working memory. The working
memory is also known as volatile data storage. The non-volatile storage that
belongs to the hard disk or stands equivalent to that has a couple of orders of
magnitude. If you want to continue working with these quantities of bits
without mixing up and confusing things, you must separate them into tiny
chunks known as values. It must be kept in mind that values are created with
bits, yet these values play multiple roles.
There is a type for each value that determines the role the value has to play.
Some values are labeled as numbers, some as pieces of text, and some are
known as functions. There is standard practice to create a value - you must
invoke its name first. The practice is not only standard but also convenient.
There is no need to collect the right building material for the values or right
away pay for them. Call for one, and you will have one. This doesn’t mean
that the values will be created out of thin air. Each value needs some place to
store itself. So, if you are looking forward to creating a lot of them, you must
think about the storage procedure. However, this is not a problem if you are
looking forward to not creating them simultaneously. When you are not using
a value, it will be discarded by the computer system.
Numbers
Values of the number are numeric values. In a JavaScript code, you will write
it as follows:
13
You will use that inside a program, and it is going to bring bit patterns for the
number in the memory of your computer. JavaScript will use a fixed number
of bits, 64 bits, for storing value for a single number. There are unlimited
patterns that you may create with 64 bits. This means that the amount of

different numbers that the system may represent is restricted. With the N
decimal digits, you have the opportunity to represent the 10N numbers.
The memory of the computer used to be a lot smaller, and people had to use
certain groups of 8 and 16 bits in order to represent the numbers. It had been
easy to overflow some small numbers to end up along with a number that
could not fit inside some bits. Times have changed. Even the computers that
fit into our pockets have immense space to save whatever you need.
These bits store negative numbers, and one bit of them alludes to the sign of a
single number. A bigger issue that you may witness is that non-whole
numbers ought to be represented as well. In order to do this, you need to use
some bits for storing the decimal point’s position.
Arithmetic
The main point is that number is used in arithmetic. They are used in
programming to perform arithmetic operations like addition and
multiplications. The simple operations of multiplication and addition need at
least two numbers to produce a third number. The + is the symbol for
addition, while the * is the symbol for multiplication. Both symbols are
known as operators. When you are programming, and you place an operator
between two numbers, you start an arithmetic operation. You can use
parenthesis to shuffle the order in which operators perform. For example, in
normal circumstances, multiplications come first. But if you put an addition
in parentheses, you change the order. Now the editor will run addition first.
(500 + 100) * 500
When operators appear without parenthesis, their application order is
determined based on precedents.
Strings
Another idea that you must learn by heart before delving into the ocean of
JavaScript programming is the concept of strings. JavaScript strings represent
text. You can write them by enclosing any piece of text that you want to
convert into a string inside quotes. See the following examples.
‘I am looking at the sinking sun.’

“I am going to take a flight to Mars.”
`The weather is balmy, as April has started.`
You can use single quotes, double quotes, and backticks, as I have displayed
in the above-mentioned examples. Putt each quote at the start or at the end of
the strings so that the code editor recognizes the text as strings. You can
literally put anything inside the quotes, and JavaScript will turn it into a
string. However, a few characters of language are difficult to turn. You might
have thought about how you will put quotes inside quotes. The first near-to-
impossible thing to enclose inside strings is including a new line. Newlines
appear when you press enter on the keyboard. You can do that without
escaping when you use backticks.
If you want to include unique characters to a string,  you can use a backslash
(\). A backslash indicates that the character that precedes that is packed up
with a special meaning. The process is known as escaping the character. If
backlash precedes a quote, it will not end the string, but it will be included in
the string. If you insert an ‘n’ character following the backslash, it will be
interpreted in the form of a newline. If you put a ‘t’ after the backslash, it
alludes to a tab character. See the example of the following string.
“I will reach the moon\n And I will travel onwards to Mars.”
What you will see on the web page will look like the following:
I will reach the moon
And I will travel onwards to Mars.
You may come across a situation where you need a backslash inside a string
just to be a backslash and not any special code. If two backslashes tend to
follow each other, they will definitely collapse. Just one will be left in the
value of the resulting string.
You have to model strings in the form of a series of bits so that they can exist
on the computer. The way JavaScript executes it depends on Unicode
standards. These standards tend to assign a specific number to each character
that you need, including the characters from Arabic, Greek, Armenian, and
Japanese. If you have a number for each character, your string will be

described by a specific sequence of numbers. That is how JavaScript executes
the code. Still, you may face some kind of complication. The representation
of JavaScript uses 16 bits per element of the string. Unicode defines much
more characters than this. Some characters like emoji consume two character
positions.
One peculiar aspect of JavaScript strings is that you cannot divide them,
subtract them, and multiply them. However, there is one operator that you
can use on strings. You can use the + operator on JavaScript strings to
concatenate them or, in simple words, combine them into a single whole. See
the following example:
“I” + “am” + “going” + “to” + “Mars” + “.”
Strings values have several associated functions that you can use to perform
different operations. The strings that you write with single or double quotes
behave in the same manner. The only difference in both kinds of strings is the
use of escape characters in strings. When you write something in ${}, the
result will come as computed, then converted into a string, and then included
at the same position.
JavaScript Arrays
JavaScript arrays can be identified with the help of square brackets. The
items of arrays are filled up inside of square brackets and are separated by
commas. See how we can declare arrays.
<!DOCTYPE html>
<html>
<body>
<p>Learn JavaScript Arrays</p>
<p>The indices of JavaScript Arrays are zero-based. It means the first item in
an array is [0].</p>

<p id="array-demo"></p>
<script>
var carsArray = ["Volkswagen","Honda","Toyota", "Suzuki"];
document.getElementById("array-demo").innerHTML = carsArray[0];
</script>
</body>
</html>
Learn JavaScript Arrays
The indices of JavaScript Arrays are zero-based. It means the first item in an
array is [0].
Volkswagen

Chapter Two
JavaScript Variables
Let us start with an example.
My profession is coding.
My state is Texas, USA.
If you have read them, you have added this information to your brain that I
am a coder, and I live in Texas, USA. In the above-mentioned pieces of texts,
the words and phrases coding and Texas, USA work the same way as
variables do in JavaScript. The terms like My Profession and My State refer
to specific values. They have the same relationship with Coding and Texas,
USA that values have in JavaScript with variables.
You can create a variable by writing var (for variable). You will follow it by
the name that you have to assign to the variable. A variable takes a specific
value when you create one. The name of a variable can be anything you like.
It is up to you to decide how it should sound. The value of a variable may
change. The facts of a variable can change.
JavaScript variables can be simply defined as containers used to store values
in the form of data. In the following example, I will use three variables: a, b,
and c and fill them up with different values.
<!DOCTYPE html>
<html>
<body>
<p>These are JavaScript Variables</p>
<p>In the following example, a, b, and c are JavaScript variables.</p>
<p id="variable-demo"></p>
<script>
var a = 50;
var b = 16;
var c = a + b;

document.getElementById("variable-demo").innerHTML =
"The value of c is: " + c;
</script>
</body>
</html>
These are JavaScript Variables
In the following example, a, b, and c are JavaScript variables.
The value of c is: 66
As this is the first example, you need to understand it well. First of all, the
line demarcates the backend code and the frontend of JavaScript. You can say
that it demarcates what you write in the code editor and what you see on the
web page. The h1 and p headings may appear different in the book than if
you display them on a web page. That is because of the h1 and p settings of
the word processor that I am using. They will work fine if you copy and paste
the code in an editor and launch it on a web page. Moreover, this is how I
will write the code embedded in HTML structure in the rest of the book
because this is how you will write it when you create a website. You need
HTML embedding to write scripts in JavaScript in order to get them read by
the web browsers. In the example mentioned above, you can see that each
variable has a variable to hold.
Instead of creating a single alphabet variable, I will now create variables that
have full-word names.
<!DOCTYPE html>
<html>
<body>
<p>You are studying JavaScript Variables</p>
<p>In the following example, the variables will have full-word names.</p>
<p id="variable-demo"></p>
<script>
var milkprice = 150;
var oilprice = 160;
var totalprice = milkprice + oilprice;
document.getElementById("variable-demo").innerHTML =
"The value of totalprice is: " + totalprice;
</script>
</body>
</html>
You are studying JavaScript Variables

In the following example, the variables will have full-word names.
The value of totalprice is: 310
JavaScript Identifiers
JavaScript variables need to be given unique names so that they can be easily
identified. These unique names are labeled as identifiers. Identifiers may be
short names like a, b, c, or lengthy descriptive names like totalprice,
milkprice, and oilprice. There are some naming rules for JavaScript variables.
You can use these rules to minimize the chance of errors.
Variables must not contain digits, letters, dollar signs, and
underscores.
Variables may start with $ sign.
Variables are case sensitive, which makes ‘a’ different from ‘A’
variable.
Variables must have a letter to start with.
You cannot use JavaScript keywords as variables.
If you see an equal sign like ‘=’ in JavaScript, you should not mistake it as
the one that is used in algebra. It has a different purpose.
The information that variables store may be used later on in a program you
create. Scripts are long, so variables make it easy to locate useful values.
Variables facilitate repeat use of a value in the same code. Instead of
remembering the value, you create a variable and fill it in with the value.
Datatypes
JavaScript variables may hold different types of information like digits and
texts. Text values in programming are named text strings. JavaScript may
hold different types of data. As I have already explained, strings must be
written in single and double quotes, whichever suits you. You write numbers
without quotes. If you use quotes for numbers, the browser will interpret it as
a string.
<!DOCTYPE html>
<html>
<body>

<p>You are studying JavaScript Variables</p>
<p>I am defining JavaScript datatypes.</p>
<p id="variable-demo"></p>
<script>
var num = 5555555.889;
var novelist = "Charles Dickens";
var introduction = 'Charles Dickens wrote melodramatic novels!';
document.getElementById("variable-demo").innerHTML =
num + "<br>" + novelist + "<br>" + introduction;
</script>
</body>
</html>
You are studying JavaScript Variables
I am defining JavaScript datatypes.
5555555.889
Charles Dickens
Charles Dickens wrote melodramatic novels!
Declaration of Variables
The process of declaration of a variable is, in fact, the process of creation of a
variable. You might have noticed in the above examples that I used the
keyword var before each variable. Without the var keyword, you cannot
create a variable. Once you have declared a variable, the variable will have
no value. You have to assign one to it just like I did in the examples. Here the
equal sign = is used. You thrust the sign in between the name of the variable
and the value.
The Undefined Variables
In different programs, you can often declare variables without a value. The
value may be something that you can calculate or something that you can
provide to it later on, like the user's input. A variable that you declare without
a value carries an ‘undefined’ value. I will use one of the examples that I
have already created and strip off the variables' value. Let us use the latest
example so that you can understand better.
<!DOCTYPE html>
<html>
<body>
<p>You are studying JavaScript Variables</p>
<p>I am defining JavaScript's undefined variables.</p>

<p id="variable-demo"></p>
<script>
var num;
var novelist;
var introduction;
document.getElementById("variable-demo").innerHTML =
</script>
</body>
</html>
You are studying JavaScript Variables
I am defining JavaScript's undefined variables.
Re-Declaration
It is possible that you have defined and declared a variable but later on
change your mind and make it undefined by the process I just explained. So,
will it make it undefined? The answer is ‘N0.’ Making it undefined after
declaration will not make the variable lose its value.
<!DOCTYPE html>
<html>
<body>
<p>You are learning JavaScript Variables</p>
<p>This is JavaScript's undeclared variables.</p>
<p id="variable-demo"></p>
<script>
var num = 5555.444;
var novelist = "Charles Lamb";
var introduction = "Charles Lamb wrote beautiful humor.";
var num;
var novelist;
var introduction;
document.getElementById("variable-demo").innerHTML =
num + "<br>" + novelist + "<br>" + introduction;
</script>
</body>
</html>
You are learning JavaScript Variables
This is JavaScript's undeclared variables.
5555.444
Charles Lamb
Charles Lamb wrote beautiful humor.

Arithmetic
JavaScript, like other programming languages, allows you to do mathematical
calculations. You can add numbers, produce results, and then forward the
results to a variable for storage. In the code, you can use the operators like =
and +.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Arithmetic</p>
<p>This is JavaScript's undeclared arithmetic.</p>
<p id="variable-demo"></p>
<script>
var a = 15 + 3452 + 13 + 8 + 1;
document.getElementById("variable-demo").innerHTML = a
</script>
</body>
</html>
JavaScript Arithmetic
This is JavaScript's undeclared arithmetic.
3489
Subtraction
The next arithmetic operator to be discussed is subtraction. The sign of the
operator is the same as is used in algebra. You can fill up the program with
the numbers of your choice and put the – sign in between to start the
subtraction process.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Arithmetic</p>
<p>JavaScript subtraction.</p>
<p id="variable-demo"></p>
<script>
var a = 55;
var b = 40;
var c = a - b;
document.getElementById("variable-demo").innerHTML = c

</script>
</body>
</html>
JavaScript Arithmetic
JavaScript subtraction.
15
JavaScript String Concatenation
Just like you learned to add numbers, JavaScript allows you to concatenate
strings. I will use the + operator to join strings in the following example.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript String Concatenation</p>
<p>JavaScript datatypes.</p>
<p id="variable-demo"></p>
<script>
var a = "Charles Dickens" + "" + " wrote" + "" + " melodramatic novels!";
document.getElementById("variable-demo").innerHTML = a
num + "<br>" + novelist + "<br>" + introduction;
</script>
</body>
</html>
JavaScript String Concatenation
JavaScript datatypes.
Charles Dickens wrote melodramatic novels!
JavaScript Let Keyword
In JavaScript, the let keyword aims at the declaration of variables. The var
keyword may also be used for the declaration of variables; however, the key
difference is in the scope of the two. The var keyword is based on function
scope, while the let keyword is based on block scope. Learning how to use
the let keyword is connected to learning the difference between the var
keyword and the let keyword.
Global Scope
The variables that you declare out of JavaScript functions.
<!DOCTYPE html>

<html>
<body>
<p>JavaScript Let Keyword</p>
<p>You can access a GLOBAL variable working from any script or any function.</p>
<p id="let-demo"></p>
<script>
var cars = "BMW";
Function1();
function Function1() {
document.getElementById("let-demo").innerHTML = "I plan to buy a " + cars + " for my
daily commute and offroading.";
}
</script>
</body>
</html>
JavaScript Let Keyword
You can access a GLOBAL variable working from any script or any function.
I plan to buy a BMW for my daily commute and offroading.
You may access global variables from any point inside of a JavaScript
program.
Function Scope
The variables you will declare in the limits of a JavaScript function bear
Function Scope. In the following example, I will declare variables in the
precincts of functions.
<!DOCTYPE html>
<html>
<body>
<p>These are JavaScript Scopes</p>
<p>I will define and declare a variable outside of Function2().</p>
<p id="let-demo1"></p>
<p id="let-demo2"></p>
<script>
Function2();
function Function2() {
var cars = "BMW";
document.getElementById("let-demo1").innerHTML = typeof cars + " " + cars;
}

document.getElementById("let-demo2").innerHTML = typeof cars;
</script>
</body>
</html>
These are JavaScript Scopes
I will define and declare a variable outside of Function2().
string BMW
undefined
I attempted to define the variables in and out of the function. So when I
checked the types of the variables, I learned that the variable thrown out of
the function limits was labeled as undefined. This is the reason we call them
function scope variables. So, if you write a code and mistakenly drive a
variable out of the function, you will see the same message. The solution is to
include the declaration in the function brackets, and the code will start
working fine.
Block Scope
The variables that you declare using the var keyword are void of Block
Scope. Only the variables that you declare within the curly braces may be
accessed from out of the block. Block Scope was introduced in JavaScript in
ES2015. Before this period, it had no scope. While the variables with the var
keyword do not have Block Scope, the variables that you declare using the let
keyword can have Block Scope.
The var keyword, in some cases, creates problems for programmers.
Especially when you attempt to redeclare a variable by including the var
keyword, you will see a bunch of problems popping up in the editor. If you
redeclare a variable within a block, you will also redeclare it out of the same
block. This will cause additional problems in the long run.
<!DOCTYPE html>
<html>
<body>
<p>This code snippet will declare your variable with the var keyword</p>
<p id="let-demo"></p>
<script>
var  xyz = 10000;
// You can see the value of xyz is 10000
{

var xyz = 1;
// Now the redeclared value of xyz variable is 1
}
// See the redelared value of variable xyz has been applied or not
document.getElementById("let-demo").innerHTML = xyz;
</script>
</body>
</html>
This code snippet will declare your variable with the var keyword
1
So, you can see that we ran into a big problem. With the var keyword,
redeclaration can be a hassle to grapple with. This is where the let keyword
comes into play. It solves the problem of redeclaration. If you have used the
let keyword to declare a variable, you will not have any problem when you
redeclare the same variable. In the following code, I will explain how the let
keyword solves the problem of redeclaration.
<!DOCTYPE html>
<html>
<body>
<p>I will use the let keyword now to redeclare a variable</p>
<p id="let-demo"></p>
<script>
var  xyz = 1000;
// The value of xyz variable is 1000
{
let xyz = 1;
// Now the value of xyz is set at 1
}
// The let keyword will let the variable xyz retain the previously declared value
document.getElementById("let-demo").innerHTML = xyz;
</script>
</body>
</html>
I will use the let keyword now to redeclare a variable
1000
As the let keyword was introduced later, Internet Explorer 11 and the
previous versions do not support it. Presently, Chrome 49, Firefox 44, Opera
36, Edge 12, and Safari 11 support the use of the let keyword.
Both var and let keywords have different behaviors when it comes to the use

of JavaScript loops. See the following two examples to understand the
difference between the two keywords.
Example 1
<!DOCTYPE html>
<html>
<body>
<p>The JavaScript let Keyword</p>
<p id="let-demo"></p>
<script>
var xyz = 4;
for (var xyz = 0; xyz < 9; xyz++) {
}
document.getElementById("let-demo").innerHTML = xyz;
</script>
</body>
</html>
The JavaScript let Keyword
9
Example 2:
<!DOCTYPE html>
<html>
<body>
<p>The JavaScript let Keyword</p>
<p id="let-demo"></p>
<script>
let xyz = 4;
for (let xyz = 0; xyz < 9; xyz++) {
}
document.getElementById("let-demo").innerHTML = xyz;
</script>
</body>
</html>
The JavaScript let Keyword
4

In the first example, when I used the var keyword, the variable declared
within the loop redeclares the xyz variable from outside the loop. However,
when I used the let keyword in example 2, the variable declared inside the
loop did not redeclare the one outside of the loop. When you use let to
declare xyz variable inside the for loop, you will only see the xyz variable in
the loop and never out of that.
Both let keyword and var keyword aim at declaring variables. However,
before you use them in creating JavaScript programs, you should understand
the key differences between the two.
The var keyword is largely used in older JavaScript versions,
while the let keyword is considered the latest method to declare
variables. You may say the ley keyword starts with ES6, which
also is known as ES2015.
The var keyword is basically function scoped while the let
keyword is block scoped.
If we talk about what is recommended of the two keywords, we may say that
the let keyword is the best option to consider when you are writing a
program. However, some browsers do not support the let keyword.
Therefore, you may feel the need to use the var keyword. 

Chapter Three
JavaScript Constants
The const keyword in JavaScript was introduced in ES2015. The variables
that are defined with the const keyword work as well as those that are defined
with the let keyword. The only difference is that you cannot reassign them.
Once you initialize a constant, you cannot change its value 0afterward. This
is what makes constant different from the var keyword. If you have to declare
a constant, you need to initialize it first.
You should think over for a while whether you have to use a constant or not
in a program. You should only use it when you are sure that you will not have
to change the value of the variable.
The name of a constant can be a legal identifier.
<!DOCTYPE html>
<html>
<body>
<p>You are learning JavaScript constants</p>
<p>Keep in mind that you cannot change primitive values.</p>
<p id="const-demo"></p>
<script>
try {
const xyz = 89.141592653589793;
xyz = 54.14;
}
catch (err) {
document.getElementById("const-demo").innerHTML = err;
}
</script>
</body>
</html>
You are learning JavaScript constants
Keep in mind that you cannot change primitive values.
TypeError: Assignment to constant variable.

Block Scope
The declaration of variables by using the const keyword is similar to the
declaration by using the let keyword when you are using Block Scope. The
following example will explain how it inclines toward the let keyword and
distances itself from the var keyword.
<!DOCTYPE html>
<html>
<body>
<p>In this example, I will be declaring a Variable by Using the const keyword</p>
<p id="const-demo"></p>
<script>
var  xyz = 15;
// The value of xyz is 15
{
const xyz = 1;
// The value of xyz is 1
}
// The value of xyz is 15
document.getElementById("const-demo").innerHTML = xyz;
</script>
</body>
</html>
In this example, I will be declaring a Variable by Using the const keyword
15
Unlike a variable declared with the var keyword, constants must be assigned
a value upon declaration. You cannot the value section empty. The word
constant is a bit confusing, if not entirely misleading. The keyword const
does not define constant values. In reality, it defines constant references to
the values you use in the equation. That is why you cannot change the
primitive values of constants. However, you can change properties.
Primitive Values
If you give a constant a primitive value, you will not be able to change the
values later on.
<!DOCTYPE html>
<html>
<body>
<p>These are JavaScript constants</p>

<p>Let try if we can change primitive value.</p>
<p id="const-demo"></p>
<script>
try {
const xyz = 5556.175757557757793;
xyz = 3555.19090;
}
catch (err) {
document.getElementById("const-demo").innerHTML = err;
}
</script>
</body>
</html>
These are JavaScript constants
Let try if we can change primitive value.
TypeError: Assignment to constant variable.
While you cannot change the primitive values in JavaScript constants, you
can change objects' properties. In the following example, I will create an
object with the keyword const, and then I will introduce some changes to the
properties of that object to see if I can change them. See the example to get
an idea of how it is done.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript constants</p>
<p>You can change the properties of objects after Declaring them:</p>
<p id="const-demo"></p>
<script>
// I am going to create an object:
const mycar = {name:"Honda", model:"Vezel", make:"Japan", color:"Grey"};
// Let us Change the property:
mycar.model = "Civic";
// You also can add a new property:
mycar.transmission = "Automatic";
// It is time to display your properties:
document.getElementById("const-demo").innerHTML = "I have a " + mycar.name + "." + "
It is of " + mycar.color + " color and its model label is " + mycar.model + ". " + "This car has
" + mycar.transmission + ".";
</script>
</body>

</html>
JavaScript Constants
You can change the properties of objects after Declaring them:
I have a Honda. It is of Grey color, and its model label is Civic. This car has
Automatic.
You saw that I changed the model from Vezel to Civic. I also added new
properties to describe the mode of transmission of the car. This facilitates
programmers as they can create an object and then add or change properties
as they deem fit as per changing needs. However, you cannot reassign a
different object to the same constant in a program. If you do that, you will see
an error.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript constants</p>
<p>Prohibited: You cannot reassign a different object to the same constant:</p>
<p id="const-demo"></p>
<script>
try {
const mycar = {name:"Honda", model:"Vezel", make:"Japan", color:"black"};
mycar = {name:"BMW", model:"Z1", make:"German", color:"red"};
}
catch (err) {
document.getElementById("demo").innerHTML = err;
}
</script>
</body>
</html>
Learning JavaScript constants
Prohibited: You cannot reassign a different object to the same constant:
Constant Arrays
You can create arrays with the const keyword, and you can change them as
well.

Chapter Four
Prompts and Conditionals
A prompt box is used to ask a user to provide information and give a
response field for the answer. The code asks a user some questions and then
offers answers in the respective field for a response. You can change the
response. Whether you leave the default response as-is or change it to
something else, your response will be assigned to a variable.
A prompt code is akin to an alert code. However, there are two differences.
For a prompt code, you need to follow a method to receive a response from
the user, which means that you need to start the code by the declaration of a
variable. After that, you have to use an equal sign. In the prompt, you must
specify a second string, which is the default response that pops up in the field
when you see the display of the prompt. If a user leaves it as-is and instead
clicks OK, your default response will shift to a variable. However, you have
the option to declare a default response or not. You have the option to
assigning the strings to a specific variable, and then you need to specify
variables rather than strings within the parentheses.
Some programmers use the line window.prompt instead of simply writing
prompt. This practice is formal and is considered the right way to write it.
However, as everyone is short on time, most coders prefer to write prompt
instead.
The JavaScript if Statement
In this section, I will explain how you have to deal with different types of
conditions in the world of JavaScript. Let us suppose you have coded a
prompt that asks users to provide the location where the American president
presently lives. Here is the line that users see on display: “Where do you
live?”
If a user answers correctly, you may display an alert that will congratulate

him. To finish this task successfully, you are going to need the if statement. If
the user gives the right answer by entering the White House, he will be
congratulated by your program. If he enters something else, the program
returns nothing. The code will not allow any other answer to the question.
An if statement, which I will include an example of later, starts with the
keyword if. The space that will separate it from parenthesis is a must for the
code. When you have written the if statement and also included the space,
you need to create and fill up a variable with the correct answer to your
question so that the if condition may test it. You have to enclose the condition
inside parentheses. If the condition is true, there will be an alert or any other
kind of action that you have directed the code to perform. The execution may
be of one statement or multiple statements. The first line of the if statement
ends with a curly bracket. An entire if statement concludes with curly
brackets on the same line. This comes as an exception to a rule that a typical
statement concludes with a semicolon. It is common for programmers to omit
the semicolon when the statement is complex, paragraph-like, and has a curly
bracket to the tail.
In some codes, you may also see a triple equal sign in if statements, and you
may think that it is merely an equal sign. However, that’s not the case. The
equal sign is used to assign values to variables. If you are testing variables
with values, you cannot use single equal signs. If you skip this step and use a
single equal sign instead of a triple equal sign, your code will mess up. When
the condition has been met, you may have multiple statements to execute.
Conditional statements have the inherent ability to perform multiple actions
after testing different conditions. More often, when you write a code, you
need to perform a bunch of actions for several decisions. There are different
types of conditional statements that you may use in JavaScript. Here is a
rundown of each of them. I will explain all of them one by one.
The if keyword is used to specify a code, the editor must execute
in case a condition stands true.
The else keyword is used to specify a code that the editor must
execute if the same condition stands false.
The else-if keyword is used to put a new condition to test if the

first condition ended up being false.
The if statement is case sensitive, so the keywords if and IF are two different
words. If you replace if with IF, you will see an error on your screen.
<!DOCTYPE html>
<html>
<body>
<p>I will display "Have a Great Day!" if the time is less than 15:00:</p>
<p id="if-demo">Have a Savory Evening!</p>
<script>
if (new Date().getHours() < 15) {
document.getElementById("if-demo").innerHTML = "Have a Great Day!";
}
</script>
</body>
</html>
I will display "Have a Great Day!" if the time is less than 15:00:
Have a Great Day!
The else Statement
You can use the else statement for the specification of code that needs to be
executed if your condition pops up as false. I will use the same code and add
the else statement to the code to see how we can use the else statement to
extend our code and make it more interactive and user-friendly. Now the user
will have two options instead of the rigid one option code.
<!DOCTYPE html>
<html>
<body>
<p>I would like you to click the button given below to display a greeting as per the current
time:</p>
<button onclick="FunctionX()">Please hit me to display the greetings</button>
<p id="ifelse-demo"></p>
<script>
function FunctionX() {
var myhours = new Date().getHours();
var mygreetings;
if (myhours < 15) {
mygreetings = "Have a Great Day";
} else {
mygreetings = "Have a Great Evening. I hope you enjoy your dinner.";

}
document.getElementById("ifelse-demo").innerHTML = mygreetings;
}
</script>
</body>
</html>
I would like you to click the button given below to display a greeting as per
the current time:
Please hit me to display the greetings
Have a Great Day
You can see that the else statement integrated perfectly into the existing code.
I have taken the liberty to add an interactive button to the code so that users
may know exactly what to do. When a user hits the button, he will get a
message that greets him. The message will be structured as per the time the
program reads at your end. This is how you can build an interactive website
app on your page and engage your visitors. Also, your visitors will love the
way they will be welcomed.
The else if Statement
You can add the else-if statement to the code to specify the new condition if
the first condition returns false. In the following example, I will add more
than two conditions to see how they work and how much improvement they
bring to our code.
<!DOCTYPE html>
<html>
<body>
<p>I would like you to click the button given below to display a greeting as per the current
time:</p>
<button onclick="FunctionX()">Please hit me to display the greetings</button>
<p id="ifelse-demo"></p>
<script>
function FunctionX() {
var mygreetings;
var mytime = new Date().getHours();
if (mytime < 8) {
mygreetings = "Have a Good Morning. I hope you have had a nutritious breakfast. Get
ready for work";
} else if (mytime < 15) {
mygreetings = "Have a Great Day. Don't forget to eat your lunch.";

} else {
mygreetings = "Have a Great Evening. Any special plans for dinner?";
}
document.getElementById("ifelse-demo").innerHTML = mygreetings;
}
</script>
</body>
</html>
I would like you to click the button given below to display a greeting as per
the current time:
Please hit me to display the greetings
Have a Great Day. Don't forget to eat your lunch.
This worked perfectly. Now your program will display greetings messages all
three times of the day. You can customize the message and make it more
interactive as per the needs of your business. Some coders are in the habit of
writing the if statements by removing the curly brackets. The practice is
completely legal; however, it is a bit hard to do. Some programmers put the
initial curly bracket on a new line. Another practice is to write the entire if
statement on a single line, which is easier to do but difficult to read when you
come back to study the structure of your program. I suggest that you follow
the same rule as I have used in the above examples so that you find it easier
to write and understand as well. You may use the double equal sign == in
place of the triple equal sign in most cases. However, you may detect a bit of
technical difference.
There are many formats to write the if statement and the variations of if
statements as well. The possibilities of coding with the if statements are
endless.
JavaScript Switch Statement
You can use the switch statement to perform different actions on JavaScript
conditions. It will help you work on a single code block and execute it as
well. The editor evaluates it once, runs a comparison among values, and in
case of a match, it executes the block. In case of a mismatch, there will be no
execution. The following program will run the switch statement through the
program and comb your computer to see what day is on your computer
calendar and what message the same day contains in the code. It will run the

code through all seven days of the week, and when it reaches a match, it will
run the message that you have already connected to the same day. See the
following code.
<!DOCTYPE html>
<html>
<body>
<p id="switch-demo"></p>
<script>
var weekdays;
switch (new Date().getDay()) {
case 0:
weekdays = "the restful Sunday";
break;
case 1:
weekdays = "the blue blue Monday";
break;
case 2:
weekdays = "the superstitious Tuesday";
break;
case 3:
weekdays = "the hectic Wednesday";
break;
case 4:
weekdays = "the overwhelming Thursday";
break;
case 5:
weekdays = "the joyful Friday";
break;
case  6:
weekdays = "the sleepy Saturday";
}
document.getElementById("switch-demo").innerHTML = "Today is " + weekdays + "." + "
Have a great and productive day!";
</script>
</body>
</html>
Today is the superstitious Tuesday. Have a great and productive day!
In the above code example, you might have noticed the addition of the break
keyword. When the code reaches the break keyword, it jumps out of the
specific switch block. This jumping out of the switch block puts a stopper on
the execution of the switch block. You do not necessarily insert the break
keyword in the last case of the switch block. Include it or not; it will end
anyway. If you exclude the break keyword from the switch block, the web
browser will execute the immediate next case even if there is a mismatch in
the values. So, be ready for an error if you skip the break keyword.

There is another keyword that you may add to the switch statement. It runs
the code even if there is a mismatch.
<!DOCTYPE html>
<html>
<body>
<p id="switch-demo"></p>
<script>
var weekdays;
switch (new Date().getDay()) {
case 0:
weekdays = "it is the restful Sunday";
break;
case 1:
weekdays = "it is the blue blue Monday";
break;
case 3:
weekdays = "it is the hectic Wednesday";
break;
case 4:
weekdays = "it is the overwhelming Thursday";
break;
case 5:
weekdays = "it is the joyful Friday";
break;
case  6:
weekdays = "it is the sleepy Saturday";
break;
default:
weekdays = "I am desperately waiting for the weekend because I have planned a
vacation.";
}
document.getElementById("switch-demo").innerHTML = weekdays
</script>
</body>
</html>
I am desperately waiting for the weekend because I have planned a vacation.
You might be thinking that the default case can only be put in the last of the
code. However, this is not true. You can insert it anywhere in the code, even
at the start of the code. It will work well.
<!DOCTYPE html>
<html>
<body>
<p id="switch-demo"></p>
<script>
var weekdays;
switch (new Date().getDay()) {

default:
weekdays = "I am desperately waiting for the weekend because I have planned a
vacation.";
break;
case 0:
weekdays = "it is the restful Sunday";
break;
case 1:
weekdays = "it is the blue blue Monday";
break;
case 3:
weekdays = "it is the hectic Wednesday";
break;
case 4:
weekdays = "it is the overwhelming Thursday";
break;
case 5:
weekdays = "it is the joyful Friday";
break;
case  6:
weekdays = "it is the sleepy Saturday";
}
document.getElementById("switch-demo").innerHTML = weekdays
</script>
</body>
</html>
I am desperately waiting for the weekend because I have planned a vacation.

Chapter Five
JavaScript Strings and Arrays
I have already explained what strings are and how you can use them in your
scripts. There are some methods that you can use when you are working with
strings. Some primitive values cannot have methods or properties because
they are not objects. However, JavaScript allows primitive values to have
properties and methods because it treats primitive values like objects when
executing properties and methods. You can learn the length of a string you
are using in a program.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the length of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for New York to start my own business.";
var msgY = msgX.length;
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
Learning Properties of JavaScript Strings
This String property will answer the question about the length of your string:
58
Another JavaScript method helps you hunt down a string within a string. The
method I will use here is called indexOf(). If you have specified a string
inside another string, you will have it found out for you. An important note to
remember is that you can create another string inside a string by using single
quotes. The following example will explain the procedure to do that.
<!DOCTYPE html>

<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.indexOf("New York");
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the length of your string:
25
You can see the index of the inner string has been displayed on the screen.
Please remember that JavaScript counts the index number from point zero.
The lastIndexOf() Method
You can use the lastIndexOf() method to see the index of final occurring of
New York, which is our specified inner string.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.lastIndexOf("New York");
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the inner string of your
string:
25

What If the Index Is Not Found?
If the methods fail to find the index, they will return -1. This may happen if
you write the wrong spelling or a completely different word in the code.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.lastIndexOf("Washington");
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the inner string of your
string:
-1
The search() Method
There is another method to locate the specified inner string in a long string. You can use the
search() method for hunting it down if the match is perfect.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.search("New York");
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the inner string of your
string:
25

If you notice the results of the two methods, namely search() and indexOf(),
you will realize they are the same. They accept the same arguments and then
respond with the same values. However, technically, the two methods are
different a great deal. The search() method cannot take in a second starting
position argument, while the indexOf() method cannot take in powerful
search values.
Parts Extraction
You can break up a string into many parts as per the needs of your program.
JavaScript gives us three methods to break up a string. The first method is
labeled as the slice() method. It extracts one part of your string and displays
the same in the form of a new string. You need to execute two parameters;
one is the starting position of the string, and the other is the ending position
of the string. See how you can do that.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.slice(23, 34);
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the inner string of your
string:
'New York'
Please keep in mind that JavaScript counts the index from the 0 point. If one
parameter turns out to be negative, you have to count it from the string's
ending point. It will slice the string backward. You can try it out and get the
result. I will skip it for now and test what happens if you forget to insert the
ending point.

<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.slice(23);
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the inner string of your
string:
'New York' to start my own business.
You can see that it has displayed the rest of the text to the end. If the starting
point is negative and the ending point is missing, you will see the results
being counted from the end to the slicing point.
The second method to cut the string and make a substring is the substring()
method. This is as simple as the slice method is. Where it differs is its
unacceptance of negative indices. See the following example to understand
its use.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.substring(23, 34);
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the inner string of your
string:

'New York'
The third and last slicing method is the substr() method, which is quite
similar to slice(). The second parameter defines the length of the rest of the
sliced string.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p>This String property will answer the question about the inner string of your string:</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.substr(23, 34);
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
This String property will answer the question about the inner string of your
string:
'New York' to start my own business
JavaScript gets interesting when it allows you to replace values inside of a
string. For example, the string I have included in my examples contains New
York as the city that I will be visiting. JavaScript allows you to change the
name of the city instead of writing a new code and creating a new string. This
saves a lot of your time when you are creating lengthy programs. The method
can be identified as replace().
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.replace('New York', 'Las Vegas');
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>

Learning Properties of JavaScript Strings
I am about to leave for 'Las Vegas' to start my own business.
By default, JavaScript replace() will not work if you write NEW YORK
instead of New York. It is case sensitive, and it identifies a different case as a
different word. Therefore, if you find out that the method is not working,
better check out the case of the words. Also, the replace() method only
replaces the first match. If there is more than one New York in the string, it
will only replace the first match and leave out the rest of the words intact. If
you want to use capital case despite the warning, you have to use a regular
expression such as /i with the word to enable the browser to recognize the
match. The regular expression will make the word insensitive. See how you
should write it in the editor.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.replace(/NEW YORK/i, 'Las Vegas');
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
Learning Properties of JavaScript Strings
I am about to leave for 'Las Vegas' to start my own business.
Let us see what the code will look like if you miss out on the regular
expression and still use the capital case in the code.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p id="string-demo"></p>
<script>
var msgX = "I am about to leave for 'New York' to start my own business.";
var msgY = msgX.replace('NEW YORK', 'Las Vegas');

document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
Learning Properties of JavaScript Strings
I am about to leave for 'New York' to start my own business.
You can see that the code does not work anymore.
Go Global
I have already explained that if you have to replace more than one word, you
cannot do that by the replace method. It just does not work. However, there is
a solution to the problem. If you have more than one words that must be
replaced with another word, you need to use a regular expression again. This
time the regular expression is labeled as /g. The method of including the
expression is the same as that of /i. However, I will write a new string and
include the expression so that you can understand it well.
<!DOCTYPE html>
<html>
<body>
<p>Learning Properties of JavaScript Strings</p>
<p id="string-demo"></p>
<script>
var msgX = "The Coach of the NBA team will visit Las Vegas. Las Vegas has a huge fan
base for NBA stars.";
var msgY = msgX.replace(/Las Vegas/g, 'Los Angeles');
document.getElementById("string-demo").innerHTML = msgY;
</script>
</body>
</html>
Learning Properties of JavaScript Strings
The Coach of the NBA team will visit Los Angeles. Los Angeles has a huge
fan base for NBA stars.
There are some additional methods to tune up strings as well. You can
convert a string into upper and lower cases by simple methods.

<!DOCTYPE html>
<html>
<body>
<p>I am converting strings into upper and lower cases:</p>
<button onclick="FunctionX()">You need to Hit me</button>
<p id="string-demo">JavaScript makes your webpages interactive and user-friendly!</p>
<script>
function FunctionX() {
var msg = document.getElementById("string-demo").innerHTML;
document.getElementById("string-demo").innerHTML = msg.toUpperCase();
}
</script>
</body>
</html>
I am converting strings into upper and lower cases:
You need to Hit me
JavaScript makes your webpages interactive and user-friendly!
The above result is displayed when you run the code. Now I will click the
button I have just created. You will see the results in the upper case. I will
only display the results.
I am converting strings into upper and lower cases:
You need to Hit me
JAVASCRIPT MAKES YOUR WEBPAGES INTERACTIVE AND USER-
FRIENDLY!
You can use the other method toLowerCase() to convert the text into lower
case. Just replace toUpperCase() with toLowerCase().
The Concatenation
Concatenation is an integral part of almost all programming languages.
Whenever there is a need to pair up two or more strings, programmers seek
support from concatenation. It is the easiest method to join two more strings.
The concat() method works smoothly if you have written the lines of code
well. The most important things to care about are the placement of commas
and whitespaces. The concat() method is used in place of the plus operator.

There is no difference in the function—the two work as alternatives only. The
following exercise will help you sail through the process of concatenation.
<!DOCTYPE html>
<html>
<body>
<p>Learnig JavaScript Strings</p>
<p id="string-demo"></p>
<script>
var msg1 = "I have been promoted as Chief Executive Officer of Skyfall.";
var msg2 = "I will call a board meeting next week.!";
var msg3 = msg1.concat(" ", msg2);
document.getElementById("string-demo").innerHTML = msg3;
</script>
</body>
</html>
Learning JavaScript Strings
I have been promoted as Chief Executive Officer of Skyfall. I will call a
board meeting next week.!
Almost all string methods have a habit of creating a new string, keeping the
original string intact. They make a copy first and introduce the changes you
suggest to the editor. Programmers say that strings can only be replaced.
They cannot change.
Each day there have been efforts by programmers to introduce some new
things to programming languages. The ECMAScript 2017 introduced more
methods to JavaScript strings. The methods padStart and padEnd are now
being used at the start and end of JavaScript strings.
String Arrays
The heading may appear a bit confusing. There is no such thing as string
arrays. However, there is a new method that turns a string into an array.
<!DOCTYPE html>
<html>
<body>
<p>Please click "Click me" to produce the first array element.</p>
<button onclick="FunctionX()">Click This Button</button>
<p id="string-demo"></p>

<script>
function FunctionX() {
var msg1 = "Texas, Las Vegas, Los Angeles.";
var msg2 = msg1.split(",");
document.getElementById("string-demo").innerHTML = msg2[0];
}
</script>
</body>
</html>
Please click "Click me" to produce the first array element.
Click This Button
Texas
Strings are amazing, and they can help you in your programming ventures a
great deal if you learn well the methods and properties. JavaScript
programming is the easiest and the most flawless of all programming
languages if you have a great eye for nuances.
JavaScript Arrays
Just like variables, JavaScript Arrays, too, are containers of values. However,
they deviate from the properties of variables in the sense that they can hold
more data than a variable in one name. So, whenever you need to load up
more data in the same name, you should use arrays. There is more than one
way to set up an array. The easiest of them is to use the var keyword, then
write the name of the arrays, and give values. An array holds individual
values in one variable. You have to separate them by comma and put them all
inside square brackets. The equal sign must follow the name of the variable.
When you have to access all the array values, you should use the index
number just as you did in the strings. The number between the square
brackets indicates the index. The number must correspond to the position of
values in an array. The most important thing to remember is that the position
of the index starts at 0.
When you have created an array, you are good to go and run it in the web
browser. You should be able to see the requisite value on the screen of your
browser. You can edit the index number and insert something else to display
a different value. Save the edited number and refresh the browser to change

the results. If your array has three items and you put in the number 3 for the
index, you will see that the browser will display the word ‘undefined’ on the
computer screen. This happened because you had only three items in the
array. When you typed 3 for the index, you attempted to display the fourth
item which was not there. Rather than displaying errors, JavaScript adds a
new position in the array, which is not yet defined. JavaScript adds the new
position to the end of the array. It remains undefined until you fill it up with a
reasonable value. You can use the new undefined position to store data as per
your needs.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="array-demo"></p>
<script>
var carsforsale = ["Honda", "Toyota", "GTX", "Ford"];
document.getElementById("array-demo").innerHTML = carsforsale;
</script>
</body>
</html>
Learning JavaScript Arrays
Honda,Toyota,GTX,Ford
You can see in the above-mentioned example that an array in JavaScript is a
special kind of variable that holds multiple values at the same time. If you
have a list of cars that you otherwise might have stored in multiple variables,
you can use an array instead to pack it up with all the values and insert them
in a web page. If you stored them in independent variables, you would have
created four variables with different names. Now that’s 4 cars, so you might
think it is not a big deal to create four independent variables for these values.
However, if you have 4000 values, it will be a problem to create independent
variables for all of them. In this situation, the array comes to help. Similarly,
if you have a hundred values and you must use them in a loop, independent
variables will not help a great deal. Arrays are easier to work with because
you can easily loop through them.
Spaces or line breaks are not of much importance in JavaScript arrays. You
can write them in different formats. See the following example, which has the

same content as above but a different format.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="array-demo"></p>
<script>
var carsforsale = ["Honda",
"Toyota",
"GTX",
"Ford"];
document.getElementById("array-demo").innerHTML = carsforsale;
</script>
</body>
</html>
Learning JavaScript Arrays
Honda,Toyota,GTX,Ford
It has the same result as the previous example. There is another method to
create an array. This is called the JavaScript keyword ‘new.’ I will create an
array by using the keyword new in the example given below.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="array-demo"></p>
<script>
var carsforsale = new Array("Honda", "Toyota", "GTX", "Ford");
document.getElementById("array-demo").innerHTML = carsforsale;
</script>
</body>
</html>
Learning JavaScript Arrays
Honda,Toyota,GTX,Ford
Let us analyze this new format and understand what is different in this. The
first difference is the addition of the keyword new to the start of the array and
right after the equal sign, followed by the keyword Array immediately next to
the keyword New. Another prominent difference is the removal of square

brackets and the addition of parentheses, but both methods work the same
way. The second method is more complicated and extended. For the sake of
simplicity, speed, and readability, you should opt for the first method that
also is known as the array literal method.
Index Numbers
You can access the items of the arrays by using the index number. As already
mentioned, the index for the array starts at number 0. In the following
example, I will access the element that has the zero index.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="array-demo"></p>
<script>
var carsforsale = new Array("Honda", "Toyota", "GTX", "Ford");
document.getElementById("array-demo").innerHTML = carsforsale[0];
</script>
</body>
</html>
Learning JavaScript Arrays
Honda
Index numbers are helpful in the sense that they can aid in changing the
values of the elements of the array. You can replace almost all elements of
the array just by mentioning the index numbers.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="array-demo"></p>
<script>
var carsforsale = new Array("Honda", "Toyota", "GTX", "Ford");
carsforsale[0] = "BMW"
carsforsale[1] = "Mitsubishi"
document.getElementById("array-demo").innerHTML = carsforsale;
</script>
</body>
</html>

Learning JavaScript Arrays
BMW,Mitsubishi,GTX,Ford
Arrays are considered special objects. If you use the typeof operator to check
the type of arrays, you will get the word ‘object’ in return. But we must stick
to the word arrays to describe JavaScript arrays. The reason is that JavaScript
arrays use numbers for accessing elements and objects use names of the items
to give you access to the same items.
You can assign any value to an array. Whatever you can assign to a variable,
you can assign to an array. You can mix up different types in the same arrays.
Programmers more often prefer to give plural names to arrays like cities,
countries, numbers, etc. The reason is that each array is a list of more than
one item. Just like ordinary variables, you may declare one array only once.
JavaScript variables may be dubbed as objects, while JavaScript arrays are
dubbed as special objects because an array may contain different kinds of
variables. You can fill up an array with objects, functions, and even arrays.
Just like strings, the real strength of arrays is because of their rich properties
and built-in methods.
Array Properties
The first property to discuss is the length property. It returns the full length of
an array, which contains all the elements of the array.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="array-demo"></p>
<script>
var carsforsale = new Array("Honda", "Toyota", "GTX", "Ford");
document.getElementById("array-demo").innerHTML = carsforsale.length;
</script>
</body>
</html>
Learning JavaScript Arrays
4
You can build a loop through the items of an array to display all of them or

use all of them in a program. One of the most common methods for creating a loop
is the for loop.
<!DOCTYPE html>
<html>
<body>
<p>These are JavaScript Arrays</p>
<p>I will use the for loop in the following code</p>
<p id="array-demo"></p>
<script>
var carsforsale, msg, cLn, y;
carsforsale = ["BMW", "Mitsubishi", "Honda", "Toyota"];
cLn = carsforsale.length;
msg = "<ul>";
for (y = 0; y < cLn; y++) {
msg += "<li>" + carsforsale[y] + "</li>";
}
msg += "</ul>";
document.getElementById("array-demo").innerHTML = msg;
</script>
</body>
</html>
These are JavaScript Arrays
I will use the for loop in the following code
BMW
Mitsubishi
Honda
Toyota
You have seen how you can display a neat and clean list of items on a web
page. All the items of the array are displayed neatly in the form of bullet
points. Next time you see a similar-looking list on a web page, you should
know that it is the array and the for loop that did the wonder. There is another
function to create the same effect in an array.
<!DOCTYPE html>
<html>
<body>
<p>These are JavaScript Arrays</p>

<p>I will use the for loop in the following code</p>
<p id="array-demo"></p>
<script>
var carsforsale, msg;
carsforsale = ["BMW", "Mitsubishi", "Honda", "Toyota"];
msg = "<ul>";
carsforsale.forEach(FunctionX);
msg += "</ul>"
document.getElementById("array-demo").innerHTML = msg;
function FunctionX(value) {
msg += "<li>" + value + "</li>";
}
</script>
</body>
</html>
These are JavaScript Arrays
I will use the for loop in the following code
BMW
Mitsubishi
Honda
Toyota
Adding Elements
You can add elements to an array by using the push() method. This
JavaScript feature helps a great if you are working a retail firm and you have
to upload new elements to the same array each day. JavaScript is amazing in
the sense that it allows you to declare a variable with no values. After that,
you can use the append function to add values to the same. You can change
the values as well as per your shifting needs. All this may happen in one
array.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>

<p>I will use the push method to append new elements to existing arrays.</p>
<button onclick="FunctionXX()">Please click this Button</button>
<p id="array-demo"></p>
<script>
var veggies = ["Pumpkin", "Tomato", "Ginger", "Potato"];
document.getElementById("array-demo").innerHTML = veggies;
function FunctionXX() {
veggies.push("Spinach");
document.getElementById("array-demo").innerHTML = veggies;
}
</script>
</body>
</html>
Learning JavaScript Arrays
I will use the push method to append new elements to existing arrays.
Please click this Button
Pumpkin, Tomato, Ginger, Potato
You will see the above result when you run the code in the browser. When
you click on the button in the web browser, you will be able to see the newly
appended element in the list of array items. When I click the button, I see the
following result.
Please click this Button
Pumpkin, Tomato, Ginger, Potato,Spinach
You can manipulate the length property to append a new element to your
array. See how you can use the length property.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p>I will use the push method to append new elements to existing arrays.</p>
<button onclick="FunctionXX()">Please click this Button</button>
<p id="array-demo"></p>
<script>
var veggies = ["Pumpkin", "Tomato", "Ginger", "Potato"];

document.getElementById("array-demo").innerHTML = veggies;
function FunctionXX() {
veggies[veggies.length] = ("Spinach");
document.getElementById("array-demo").innerHTML = veggies;
}
</script>
</body>
</html>
Learning JavaScript Arrays
I will use the push method to append new elements to existing arrays.
Please click this Button
Pumpkin, Tomato, Ginger, Potato, Spinach
Arrays can be tricky to work with if you do not know what you are doing. For
example, you can use the index number to append an element to an array. In
the process, if you include a higher index to the code, you will create holes in
the array that will be completely undefined.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p>I will add elements that have high indices. The result will be undefined "holes" in the
array.</p>
<p id="undefinedarray-demo"></p>
<script>
var veggies, msg, cLn, XX;
veggies = ["Pumpkin", "Ginger", "Tomato", "Garlic"];
veggies[8] = "Spinach";
cLn = veggies.length;
msg = "";
for (XX = 0; XX < cLn; XX++) {
msg += veggies[XX] + "<br>";
}
document.getElementById("undefinedarray-demo").innerHTML = msg;
</script>
</body>
</html>
Learning JavaScript Arrays

I will add elements that have high indices. The result will be undefined
"holes" in the array.
Pumpkin
Ginger
Tomato
Garlic
undefined
undefined
undefined
undefined
Spinach
You can see that JavaScript does not return an error in the code. It just creates
an undefined slot in the position that does not have an item to fill in. The
undefined slot can be filled up with items if you need to later on. So, this
cannot actually be called a fatal error.
Associative Arrays
In the world of programming, many programming languages have arrays that
have named indices. The arrays that contain named indexes are labeled as
associative arrays. Some programmers also label them as hashes. JavaScript
has no support for the arrays that have named indexes. Arrays in JavaScript
use numbered indexes.
<!DOCTYPE html>
<html>
<body>
<p id="array-demo"></p>
<script>
var car = [];
car[0] = "BMW";
car[1] = "Germany";
car[2] = 2018;
document.getElementById("array-demo").innerHTML =
car[0] + " " + car[1] + " " + car[2];
</script>
</body>
</html>
BMW Germany 2018

There is a basic difference between JavaScript arrays and JavaScript objects.
I already explained that arrays are numbered while objects are named. Now I
will explain where you should use arrays and where you should use objects.
As for JavaScript objects, you have to use it when you want the elements to
be named as strings which are in the form of text. As for the arrays, you
should use them where you must name the elements in numbers. If you
switch positions, you will get unexpected results in the web browser.
Array Conversion
JavaScript has methods that allow you to convert an array into a string that is
separated by commas. The method is known as the toString() method. I will
use the example of veggies array and add the toString() method to the same,
and the results will be visible in the web browser.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="undefinedarray-demo"></p>
<script>
var veggies = ["Pumpkin", "Ginger", "Tomato", "Garlic"];
document.getElementById("undefinedarray-demo").innerHTML = veggies.toString();
</script>
</body>
</html>
Learning JavaScript Arrays
Pumpkin, Ginger, Tomato, Garlic
You can see that the array has been converted into a string. There is not a
neatly displayed list on the web page. Instead, you can see a jumbled-up list
of items that are separated by commas. Not only does the toString() method
converts an array into a string, but the join() method also does the same. It
joins all the elements into a single whole. This method, too works as fine as
the toString() method. The only difference is that this method allows you to
specify a separator.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="array-demo"></p>

<script>
var veggies = ["Pumpkin", "Ginger", "Tomato", "Garlic"];
document.getElementById("array-demo").innerHTML = veggies.join(" - ");
</script>
</body>
</html>
Learning JavaScript Arrays
Pumpkin - Ginger - Tomato - Garlic
You can see that everything worked the same as with the toString() method.
However, the code showed flexibility when it allowed me to choose the sign
of my choice to separate the converted string elements. I have chosen “ – “
for the separation. However, you can choose other signs like * or +, whatever
suits you.
Popping Arrays
When you are working with arrays to operate a retail outlet or a financial
firm, you can use popping and pushing methods to extract or add elements.
Popping flips off an element out of the array while pushing thrust an element
into an array. The only problem with the popping method is that you can only
remove an element from the end of the array. See the following example to
understand how you can do that.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Arrays</p>
<p id="popping-demo1"></p>
<p id="popping-demo2"></p>
<script>
var veggies = ["Pumpkin", "Ginger", "Tomato", "Garlic"];
document.getElementById("popping-demo1").innerHTML = veggies;
veggies.pop();
document.getElementById("popping-demo2").innerHTML = veggies;
</script>
</body>
</html>
Learning JavaScript Arrays
Pumpkin, Ginger, Tomato, Garlic
Pumpkin, Ginger, Tomato

The last item of the array was popped out with the help of the pop() method.
You can keep repeating the script, and you will end up with an empty array.
Now you have learned how to pop items from arrays, I will explain how to
push elements in. Please remember that you will not see the added element
right after running the code. As I have added a button to the code, you will
have to click on the button first and then display the element. As the code has
a function, the push method will add many instances of the same element to
the code. Keeping clicking, and the browser will keep adding more instances
to the array.
<!DOCTYPE html>
<html>
<body>
<p>Learning Array Methods</p>
<p>The JavaScript push() method will append a new element to your arrays.</p>
<button onclick="FunctionYY()">Click Me</button>
<p id="array-demo"></p>
<script>
var veggies = ["Garlic", "Pumpkin", "Ginger", "Tomato"];
document.getElementById("array-demo").innerHTML = veggies;
function FunctionYY() {
veggies.push("Spinach");
document.getElementById("array-demo").innerHTML = veggies;
}
</script>
</body>
</html>
Learning Array Methods
The JavaScript push() method will append a new element to your arrays.
Click Me
Garlic, Pumpkin, Ginger, Tomato, Spinach
Shifting Arrays
There is another method known as the shift method for removing elements
from the arrays' starting point. Let us suppose you have got an array. I will
use the same veggies array to explain the concept of shifting in arrays.
Contrary to the popping method, the shifting method will remove the first

element from the array. While the shift method removes one element from
the array, the unshift method removes one or more from the beginning of the
array.
With the removal of elements, there is a change in the index numbers as well.
All the other elements in the array will be automatically shifted to lower
indices after you use the shift or unshift method. Once again, merely running
the code in the browser will not remove the element from the start. You will
have to hit the click me button to trigger the change in the array. Also, if you
keep clicking the button, and the browser will keep removing the elements
from the array. This is how it will go on end. The shift() method is highly
flexible in the sense that you can get the removed elements collected inside a
variable. You can then use them at your will and need.
<!DOCTYPE html>
<html>
<body>
<p>Learning Array Methods</p>
<p>The shift()</p>
<button onclick="FunctionYY()">Click Me</button>
<p id="array-demo"></p>
<script>
var veggies = ["Garlic", "Pumpkin", "Ginger", "Tomato"];
document.getElementById("array-demo").innerHTML = veggies;
function FunctionYY() {
veggies.shift();
document.getElementById("array-demo").innerHTML = veggies;
}
</script>
</body>
</html>
Learning Array Methods
The shift()
Click Me
Pumpkin, Ginger, Tomato
There is a method to delete elements from an array. The keyword for the
script is labeled as delete.

<!DOCTYPE html>
<html>
<body>
<p>Learning Array Methods</p>
<p>The delete method</p>
<p id="array-demo1"></p>
<p id="array-demo2"></p>
<script>
var veggies = ["Garlic ", "Pumpkin ", "Ginger ", "Tomato "];
document.getElementById("array-demo1").innerHTML =
"Here is the first vegetable name " + veggies[0];
delete veggies[0];
document.getElementById("array-demo2").innerHTML =
"Here is the first vegetable name: " + veggies[0];
</script>
</body>
</html>
Learning Array Methods
The delete method
Here is the first vegetable name Garlic
Here is the first vegetable name: undefined
The splice() Method
There is a splice() method in JavaScript to add more or multiple elements in
the array. The method also removes elements that are placed after it. I will
use the same array that I used for the other methods so that you can
understand the difference among the methods. The first digit in parentheses is
the starting index for the addition or deletion. The second element shows the
remaining elements to remove. You can use the splice method for copying
consecutive elements at any position you want and then adding them to a new
array.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript splice()</p>
<p>I will use the splice() method to add new elements.</p>
<button onclick="FunctionZZ()">Click Me</button>

<p id="array-demo1"></p>
<p id="array-demo2"></p>
<script>
var veggies = ["Pumpkin ", "Ginger ", "Tomato ", "Potato "];
document.getElementById("array-demo1").innerHTML = "You are seeing the original
Array:<br>" + veggies;
function FunctionZZ() {
veggies.splice(3, 0, "Spinach ", "Garlic ");
document.getElementById("array-demo2").innerHTML = "You are seeing the new Array:
<br>" + veggies;
}
</script>
</body>
</html>
JavaScript splice()
I will use the splice() method to add new elements.
Click Me
You are seeing the original Array:
Pumpkin, Ginger, Tomato, Potato
You are seeing the new Array:
Pumpkin, Ginger, Tomato, Spinach, Garlic, Potato
If you analyze the code snippet, you will see that there are two parameters in
the code. The first parameter (3) points out the position where I instructed the
editor to add a new element – in other words, the element was spliced in. The
second parameter (0) defined the number of elements that I wanted to remove
from the code. The next two parameters instructed the editor to add new
elements to the array.
You also can use the splice() method to expel certain elements from the array.
Although there are many other methods for the task, the splice() method
gives programmers the right way to do away with holes in the array.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript splice()</p>
<p>I will use the splice() method to add new elements.</p>

<button onclick="FunctionZZ()">Click Me</button>
<p id="array-demo1"></p>
<p id="array-demo2"></p>
<script>
var veggies = ["Pumpkin ", "Ginger ", "Tomato ", "Potato "];
document.getElementById("array-demo1").innerHTML = "You are seeing the original
Array:<br>" + veggies;
function FunctionZZ() {
veggies.splice(0, 2);
document.getElementById("array-demo2").innerHTML = "You are seeing the new Array:
<br>" + veggies;
}
</script>
</body>
</html>
JavaScript splice()
I will use the splice() method to add new elements.
Click Me
You are seeing the original Array:
Pumpkin, Ginger, Tomato, Potato
You are seeing the new Array:
Tomato, Potato
In the above-mentioned code snippet, the first parameter (0) defines the point
that should be used as a reference for the addition of new elements. The
second parameter (1) is used to define the number of elements that must be
removed. As I have excluded the previous two additional elements, there will
be no addition of new elements.
Concatenation
JavaScript allows you to concatenate two arrays to produce a new array.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array concat()</p>
<p>The concat() method follows the merging pattern:</p>
<p id="array-demo"></p>

<script>
var veggies = ["Tomato ", "Potato ", "Cauliflower ", "Cabbage "];
var frutoos = ["Orange ", "Fig ", "Guava ", "Date "];
var fruitbasket = veggies.concat(frutoos);
document.getElementById("array-demo").innerHTML = fruitbasket;
</script>
</body>
</html>
JavaScript Array concat()
The concat() method follows the merging pattern:
Tomato, Potato, Cauliflower, Cabbage, Orange, Fig, Guava, Date
The concat() method in JavaScript can be treated with more than two
arguments. You can add another array to merge it up with the two. The
following example will explain the method by which you can merge up to
three arrays.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array concat()</p>
<p>The concat() method follows the merging pattern:</p>
<p id="array-demo"></p>
<script>
var veggies = ["Tomato ", "Potato ", "Cauliflower ", "Cabbage "];
var frutoos = ["Orange ", "Fig ", "Guava ", "Date "];
var summerfrutoos = ["Watermelon ", "Melon ", "Mango "]
var fruitbasket = veggies.concat(frutoos, summerfrutoos);
document.getElementById("array-demo").innerHTML = fruitbasket;
</script>
</body>
</html>
JavaScript Array concat()
The concat() method follows the merging pattern:
Tomato ,Potato ,Cauliflower ,Cabbage ,Orange ,Fig ,Guava ,Date
,Watermelon ,Melon ,Mango
The concat() method also takes strings as arguments. Here is the sample to

learn how to add strings to an array.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array concat()</p>
<p>The concat() method follows the merging pattern:</p>
<p id="array-demo"></p>
<script>
var veggies = ["Tomato ", "Potato ", "Cauliflower ", "Cabbage "];
var fruitbasket = veggies.concat('Spinach ', 'garlic ', 'eggplant ');
document.getElementById("array-demo").innerHTML = fruitbasket;
</script>
</body>
</html>
JavaScript Array concat()
The concat() method follows the merging pattern:
Tomato ,Potato ,Cauliflower ,Cabbage ,Spinach ,garlic ,eggplant
Slicing
You can slice off an array at the point you want. The slice() method produces
pieces of the array and creates new arrays.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array concat()</p>
<p>The concat() method follows the merging pattern:</p>
<p id="array-demo"></p>
<script>
var veggies = ["Tomato ", "Potato ", "Cauliflower ", "Cabbage "];
var freshveggies = veggies.slice(1);
var freshveggies1 = veggies.slice(2);
document.getElementById("array-demo").innerHTML = veggies + "<br><br>" +
freshveggies + "<br><br>" + freshveggies1;
</script>
</body>
</html>
JavaScript Array concat()

The concat() method follows the merging pattern:
Tomato ,Potato ,Cauliflower ,Cabbage
Potato ,Cauliflower ,Cabbage
Cauliflower ,Cabbage
The slice() method keeps the existing array intact. It does not delete any new
element from the source of the array. The example
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array</p>
<p>The concat() method follows the merging pattern:</p>
<p id="array-demo"></p>
<script>
var veggies = ["Tomato ", "Potato ", "Cauliflower ", "Cabbage "];
var freshveggies = veggies.slice(1, 3);
document.getElementById("array-demo").innerHTML = veggies + "<br><br>" +
freshveggies;
</script>
</body>
</html>
JavaScript Array
The concat() method follows the merging pattern:
Tomato ,Potato ,Cauliflower ,Cabbage
Potato ,Cauliflower
If you omit the ending argument, the result has the entire left out array.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array</p>
<p>The concat() method follows the merging pattern:</p>
<p id="array-demo"></p>
<script>
var veggies = ["Tomato ", "Potato ", "Cauliflower ", "Cabbage "];
var freshveggies = veggies.slice(1);

document.getElementById("array-demo").innerHTML = veggies + "<br><br>" +
freshveggies;
</script>
</body>
</html>
JavaScript Array
The concat() method follows the merging pattern:
Tomato ,Potato ,Cauliflower ,Cabbage
Potato ,Cauliflower ,Cabbage
Array Sorting
You can use the sort() method to sort out an array in alphabetical order. This
is helpful when you are working with a huge number of array items in a retail
outlet or a financial firm.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array Sort method</p>
<p>This method will sort out an array in alphabetical order.</p>
<button onclick="FunctionAlpha()">Please Click Me</button>
<p id="demo10"></p>
<script>
var veggies = ["Garlic ", "Spinach ", "Radish ", "Peas ", "Potato "];
document.getElementById("demo").innerHTML = veggies;
function FunctionAlpha() {
veggies.sort();
document.getElementById("demo10").innerHTML = veggies;
}
</script>
</body>
</html>
This is JavaScript Array Sort method
This method will sort out an array in alphabetical order.
Please Click Me

Garlic ,Peas ,Potato ,Radish ,Spinach
Reverse Gear
You can set an array to the reverse position by using the reverse() method. It
will put the elements in reverse order. This method is also known as the
descending method because it reverses the alphabetical order and sets them
into a descending position.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array Sort method</p>
<p>This method will sort out an array in alphabetical order.</p>
<button onclick="FunctionAlpha()">Please Click Me</button>
<p id="demo10"></p>
<script>
var veggies = ["Garlic ", "Spinach ", "Radish ", "Peas ", "Potato "];
document.getElementById("demo").innerHTML = veggies;
function FunctionAlpha() {
veggies.sort();
veggies.reverse();
document.getElementById("demo10").innerHTML = veggies;
}
</script>
</body>
</html>
This is JavaScript Array Sort method
This method will sort out an array in alphabetical order.
Please Click Me
Spinach ,Radish ,Potato ,Peas ,Garlic
Sorting Numeric
The sort() function is by default tuned to sort the values that are in the form
of strings. They work well when you have words to sort out. However, if you
have numbers to sort out, you will land in a problematic situation. The
number 20 is bigger in the eyes of the sorted function as compared with the
number 100. The reason is that 2 is bigger than 1. That’s why it is highly

likely that you may get incorrect results if you try to apply the sorted()
method to arrays.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Array Sort</p>
<p>By clicking the button, you can sort the array in ascending order.</p>
<button onclick="FunctionT()">Click Me</button>
<p id="demo10"></p>
<script>
var nums = [4000, 1000, 15, 555, 253, 102];
document.getElementById("demo10").innerHTML = nums;
function FunctionT() {
nums.sort(function(x, y){return x - y});
document.getElementById("demo10").innerHTML = nums;
}
</script>
</body>
</html>
Learning JavaScript Array Sort
By clicking the button, you can sort the array in ascending order.
Click Me
4000,1000,15,555,253,102
This is how the results look when you run the code in a browser. Now I will
hit the button to get the sorted out results. See the difference below.
Learning JavaScript Array Sort
By clicking the button, you can sort the array in ascending order.
Click Me
15,102,253,555,1000,4000
Now I will use the same sort() method to reverse the order in a descending
pattern. Let us see what type of results we can have by this. I will show the
results that I get after I click the button on the browser screen.
<!DOCTYPE html>

<html>
<body>
<p>Learning JavaScript Array Sort</p>
<p>By clicking the button, you can sort the array in ascending order.</p>
<button onclick="FunctionT()">Click Me</button>
<p id="demo10"></p>
<script>
var nums = [4000, 1000, 15, 555, 253, 102];
document.getElementById("demo10").innerHTML = nums;
function FunctionT() {
nums.sort(function(x, y){return y - x});
document.getElementById("demo10").innerHTML = nums;
}
</script>
</body>
</html>
Learning JavaScript Array Sort
By clicking the button, you can sort the array in ascending order.
Click Me
4000,1000,555,253,102,15
If you get different results, try to click the button and see the results.
Compare Function
You can use the compare function to get the desired results even when you
are dealing with numbers. The purpose of this function is to define a specific
alternative to the sort order. This compare function must return a zero,
negative, or positive value based on what arguments you use. When you feed
the sort() function with a couple of values, it dispatches the values to the
compare function. After that, it sorts these values as per the returned values
that are either negative, positive, or zero. If you see negative results, you will
have x sorted out from y. If you see positive results, you will see y sorted
before x. The figure zero suggests no change in the sorting order of the
values.
This function compares values in an array. When it compares 20 and 100, it
will call the compare function, which will calculate the difference. If the

result is negative, it will declare 20 as lower in value than 100. You can use
the code snippet to make experiments with alphabetic and numeric sorting.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Array Sort</p>
<p>You can use the click buttons to sort out the arrays either in alphabetical order or in
numerical order.</p>
<button onclick="FunctionP()">Click Me to Sort Alphabetically</button>
<button onclick="FunctionQ()">Click Me to Sort Numerically</button>
<p id="demo1"></p>
<script>
var nums = [4045, 1002, 1567, 5234, 251, 100];
document.getElementById("demo1").innerHTML = nums;
function FunctionP() {
nums.sort();
document.getElementById("demo1").innerHTML = nums;
}
function FunctionQ() {
nums.sort(function(x, y){return x - y});
document.getElementById("demo1").innerHTML = nums;
}
</script>
</body>
</html>
Learning JavaScript Array Sort
You can use the click buttons to sort out the arrays either in alphabetical
order or in numerical order.
Click Me to Sort Alphabetically Click Me to Sort Numerically
4045,1002,1567,5234,251,100
The above result is the original one that is displayed when you run the code
in the browser. Here is what happens when you click the button for
alphabetic sorting.
Learning JavaScript Array Sort
You can use the click buttons to sort out the arrays either in alphabetical
order or in numerical order.

Click Me to Sort Alphabetically Click Me to Sort Numerically
100,1002,1567,251,4045,5234
See the results when you do numeric sorting.
Learning JavaScript Array Sort
You can use the click buttons to sort out the arrays either in alphabetical
order or in numerical order.
Click Me to Sort Alphabetically Click Me to Sort Numerically
100,251,1002,1567,4045,5234
Random Sorting
You can use the random method to sort out arrays randomly. See the example
to learn how to add the method to the code and get the desired results. By
using the random method, you will have random sorting of the numbers. I
cannot show all the sorted results here because I get a different result in the
browser each time I click the button. You can use the code and see different
results by clicking the button multiple times. See the following example.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Array Sort</p>
<p>By clicking the button, you can sort the array in ascending order.</p>
<button onclick="FunctionT()">Click Me</button>
<p id="demo10"></p>
<script>
var nums = [4000, 1000, 15, 555, 253, 102];
document.getElementById("demo10").innerHTML = nums;
function FunctionT() {
nums.sort(function(x, y){return 0.5 - Math.random()});
document.getElementById("demo10").innerHTML = nums;
}
</script>
</body>
</html>
Learning JavaScript Array Sort

By clicking the button, you can sort the array in ascending order.
Click Me
15,253,1000,555,102,4000
The problem with the random method is that it favors some numbers over
others. There is another method that is more correct and useful than this one.
It is commonly known as the Fisher-Yates shuffle. The method was
introduced in data science in the early days of data science.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sort Goes On</p>
<h3>This is Fisher-Yates Method</h3>
<p>When you click the button repeatedly, you will sort the array in random order.</p>
<button onclick="FunctionXX()">Click Me</button>
<p id="demo12"></p>
<script>
var nums = [404, 10023, 123, 589, 2511, 102];
document.getElementById("demo12").innerHTML = nums;
function FunctionXX() {
var a, b, c;
for (a = nums.length -1; a > 0; a--) {
b = Math.floor(Math.random() * a)
c = nums[a]
nums[a] = nums[b]
nums[b] = c
}
document.getElementById("demo12").innerHTML = nums;
}
</script>
</body>
</html>
JavaScript Array Sort Goes On
This is Fisher-Yates Method
When you click the button repeatedly, you will sort the array in random
order.
Click Me

404,10023,123,589,2511,102
Array Values
JavaScript does not have any built-in functions to find out the highest or the
lowest value in arrays. However, when you have stored one array, you may
use the index for getting the highest and the lowest values.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sorting Method</p>
<p>You are seeing the lowest number which is <span id="demo4"></span>.</p>
<script>
var nums = [4099999, 124100, 12, 5444, 2544444, 102343];
nums.sort(function(x, y){return x-y});
document.getElementById("demo4").innerHTML = nums[0];
</script>
</body>
</html>
JavaScript Array Sorting Method
You are seeing the lowest number which is 12.
The same code can be used to fish out the highest number. I will reverse the
pattern and hunt down the highest number in the list. Here is the pattern.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sorting Method</p>
<p>You are seeing the lowest number which is <span id="demo4"></span>.</p>
<script>
var nums = [4099999, 124100, 12, 5444, 2544444, 102343];
nums.sort(function(x, y){return y - x});
document.getElementById("demo4").innerHTML = nums[0];
</script>
</body>
</html>
JavaScript Array Sorting Method
You are seeing the lowest number which is 4099999.

This method to find out the highest and the lowest values in an array is the
dumbest method. It also is inefficient as well. If you want to be more precise
and accurate, you can use the Math.max() method and reach the most
accurate number without sifting through an entire array and returning the
answer afterward.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sorting through Max method</p>
<p>Here is the highest number in the array: <span id="demo7"></span>.</p>
<script>
var nums = [4087787878, 1002333333333, 112, 5, 2544, 11220];
document.getElementById("demo7").innerHTML = ArrayMaxPoint(nums);
function ArrayMaxPoint(arr) {
return Math.max.apply(null, arr);
}
</script>
</body>
</html>
JavaScript Array Sorting through Max Method
Here is the highest number in the array: 1002333333333.
Now I will use the same method to find out the lowest value in the array. See
the following example.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sorting through Max method</p>
<p>Here is the highest number in the array: <span id="demo7"></span>.</p>
<script>
var nums = [4087787878, 1002333333333, 112, 5, 2544, 11220];
document.getElementById("demo7").innerHTML = ArrayMaxPoint(nums);
function ArrayMaxPoint(arr) {
return Math.min.apply(null, arr);
}
</script>
</body>
</html>
JavaScript Array Sorting through Max Method

Here is the highest number in the array: 5.
Here is another solution that is considered the fastest way to detect the
highest numbers in an array. In this method, a function enters a loop and
iterates through the array to compare every single value of the array with the
top value that it detects at the first stage. When it has looped through all the
values, it produces the result.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sorting for highest value</p>
<p>Here is the highest number in the array: <span id="demo7"></span>.</p>
<script>
var nums = [4077879878, 10023, 147777777777, 53, 25, 1023];
document.getElementById("demo7").innerHTML = ArrayMaxPoint(nums);
function ArrayMaxPoint(arr) {
var length = arr.length;
var maximum = -Infinity;
while (length--) {
if (arr[length] > maximum) {
maximum = arr[length];
}
}
return maximum;
}
</script>
</body>
</html>
JavaScript Array Sorting for Highest Value
Here is the highest number in the array: 147777777777.
Similarly, you can create a function that will loop through the entire array to
detect first the lowest value and then compare it with the rest of the values of
the array. Finally, it will produce the result in the browser. See how the
minimum function works and loops through the array.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sorting for highest value</p>
<p>Here is the highest number in the array: <span id="demo7"></span>.</p>
<script>

var nums = [4077879878, 10023, 147777777777, 53, 25, 1023];
document.getElementById("demo7").innerHTML = ArrayMinPoint(nums);
function ArrayMinPoint(arr) {
var length = arr.length;
var minimum = Infinity;
while (length--) {
if (arr[length] < minimum) {
minimum = arr[length];
}
}
return minimum;
}
</script>
</body>
</html>
JavaScript Array Sorting for Highest Value
Here is the highest number in the array: 25.
Object Array Sorting
If you have an array with objects, you can sort them with the following
method.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Array Sorting Objects</p>
<p>Please click the buttons to sort out the objects of the car.</p>
<button onclick="FunctionO()">Please Click Me to Sort</button>
<p id="demo2"></p>
<script>
var carsObjects = [
{type:"Honda", year:2020, Make:"Japan", Model:"Vezel"},
{type:"Toyota", year:2010, Make:"Japan", Model:"Fortuner"},
{type:"Toyota", year:2018, Make:"Japan", Model:"Vitz"}
];
ToDisplayCars();
function FunctionO() {
carsObjects.sort(function(x, y){return x.year - y.year});
ToDisplayCars();
}
function ToDisplayCars() {
document.getElementById("demo2").innerHTML =
carsObjects[0].type + " " + carsObjects[0].year + " " + carsObjects[0].Make + " " +

carsObjects[0].Model + "<br>" +
carsObjects[1].type + " " + carsObjects[1].year + " " + carsObjects[0].Make + " " +
carsObjects[0].Model + "<br>" +
carsObjects[2].type + " " + carsObjects[2].year + " " + carsObjects[0].Make + " " +
carsObjects[0].Model;
}
</script>
</body>
</html>
JavaScript Array Sorting Objects
Please click the buttons to sort out the objects of the car.
Please Click Me to Sort
Toyota 2010 Japan Fortuner
Toyota 2018 Japan Fortuner
Honda 2020 Japan Fortuner
I have already sorted it by clicking the sorting button. You may see a
different order when you run the code first in the browser. The order will
only change when hit the sorting button.
JavaScript Iteration
There is more in JavaScript arrays that you can learn and apply when you are
creating web pages. The forEach() method helps you make a function call for
all the elements of the array.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.forEach()</p>
<p>This method makes a function call at least once for all individual array elements.</p>
<p id="demo44"></p>
<script>
var msg = "";
var nums = [4588888, 2234, 12349, 16899, 900025];
nums.forEach(FunctionE);
document.getElementById("demo44").innerHTML = msg;
function FunctionE(Evalue, Eindex, Earray) {
msg = msg + Evalue + "<br>";

}
</script>
</body>
</html>
This is JavaScript Array.forEach()
This method makes a function call at least once for all individual array
elements.
4588888
2234
12349
16899
900025
I have allocated three arguments to the function; the first argument deals with
the value of the item, the second argument deals with the item's index, and
the third argument deals with the array as a whole. I have only deployed the
Evalue parameter in the above-mentioned example. This means that if you do
not need the other two, you can slice them off of the function to simplify the
code. However, If you think you are going to need the other two, you can
keep them and use them later on in separate function calls. The best thing
about Array.forEach() method is that it suits well to all web browsers except
Internet Explorer 8 or its previous versions.
The map() Method
The map() method is used by programmers to create a new array by
performing an individual function on all array elements. It does not execute
the function for the elements that are void of values, and it does not change
the original form of the array. The following example will have an addition
operator adding 1000 to each number in the array and creating a new array
that way.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.map()</p>
<p>I will create a new array by applying the function on all array elements.</p>
<p id="demo90"></p>
<script>

var nums1 = [12345, 7674, 3449, 12316, 9900025];
var nums2 = nums1.map(FunctionM);
document.getElementById("demo90").innerHTML = nums2;
function FunctionM(Mvalue, Mindex, Marray) {
return Mvalue + 1000;
}
</script>
</body>
</html>
This is JavaScript Array.map()
I will create a new array by applying the function on all array elements.
13345,8674,4449,13316,9901025
I will remove the plus operator and add the multiplication operator to produce
different results and create a new array.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.map()</p>
<p>I will create a new array by applying the function on all array elements.</p>
<p id="demo90"></p>
<script>
var nums1 = [12345, 7674, 3449, 12316, 9900025];
var nums2 = nums1.map(FunctionM);
document.getElementById("demo90").innerHTML = nums2;
function FunctionM(Mvalue, Mindex, Marray) {
return Mvalue * 1000;
}
</script>
</body>
</html>
This is JavaScript Array.map()
I will create a new array by applying the function on all array elements.
12345000,7674000,3449000,12316000,9900025000
Please note that the function that I have included in the code takes three
arguments; the first argument is for value, the second is for index, and the
third is for the array as a whole. If you need to work with only one parameter,

you may omit the rest of the parameters. The omission will not affect the
program. It will produce the same results. Just like the preceding method,
Array.map() works well on all web browsers except internet explorer 8 or its
earlier versions.
The filter() Method
The filter() method tends to create a new array with the elements of the array
that manage to pass the test. I will set the filter bar at number 20, which
means that all the numbers that are above 20 will be filtered out by the
method. Users will only see the numbers that are over 20. The rest of the
elements will be hidden.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.filter()</p>
<p>The following program will create a new array by filtering all array elements that tend to
pass the test.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 17, 3459, 18, 2, 6, 23416, 87625];
var over20 = nums.filter(FunctionZ);
document.getElementById("demo789").innerHTML = over20;
function FunctionZ(valueF, indexF, arrayF) {
return valueF > 20;
}
</script>
</body>
</html>
This is JavaScript Array.filter()
The following program will create a new array by filtering all array elements
that tend to pass the test.
45890,3459,23416,87625
The reduce() Method
The reduce() method makes a function call to all the array elements and
produces one value. The method will operate from left to right inside the

array. It keeps the original array intact.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.reduce()</p>
<p>The following program will create a new array by reducing all array elements that tend
to pass the test.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 17, 3459, 18, 2, 6, 23416, 87625];
var over20 = nums.reduce(FunctionZ);
document.getElementById("demo789").innerHTML = over20;
function FunctionZ(Total, valueF) {
return Total + valueF;
}
</script>
</body>
</html>
This is JavaScript Array.reduce()
The following program will create a new array by filtering all array elements
that tend to pass the test.
160433
The most amazing thing about the reduce() method is that it takes an
additional value to start with unlike other methods.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.filter()</p>
<p>The following program will create a new array by filtering all array elements that tend to
pass the test.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 17, 3459, 18, 2, 6, 23416, 87625];
var over20 = nums.reduce(FunctionZ, 5000000000);
document.getElementById("demo789").innerHTML = over20;
function FunctionZ(Total, valueF) {
return Total + valueF;
}

</script>
</body>
</html>
This is JavaScript Array.filter()
The following program will create a new array by filtering all array elements
that tend to pass the test.
5000160433
The reduceRight() Method
The reduceRigth() method tends to run a function on all elements of an array
to produce one value. This method works well, moving from the right side to
the left side of the array. The best thing is that you will be able to keep the
original array intact.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array. reduceRight ()</p>
<p>The following program will create a new array by filtering all array elements that tend to
pass the test.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 17, 3459, 18, 2, 6, 23416, 87625900000];
var sum = nums.reduceRight(FunctionZ);
document.getElementById("demo789").innerHTML = "The Total sum of all the numbers is
" + sum;
function FunctionZ(Total, valueF) {
return Total + valueF;
}
</script>
</body>
</html>
This is JavaScript Array.reduceRight()
The following program will create a new array by filtering all array elements
that tend to pass the test.
The Total sum of all the numbers is 87625972808
The Array.reduceRigth() works well on all the web browsers except the

Internet Explorer 8 or the earlier versions.
The every() Method
The every() method runs a thorough check through the arrays to see if all the
elements in the array pass a test. In the following example, I will run a test to
see if all the elements are bigger than 500 or not.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.every()</p>
<p>The following program will display the results of the test.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 17, 3459, 18, 2, 6, 23416, 87625900000];
var Over500 = nums.every(FunctionZ);
document.getElementById("demo789").innerHTML = "Are all values bigger than 500: " +
Over500;
function FunctionZ(valueF) {
return valueF > 500;
}
</script>
</body>
</html>
This is JavaScript Array.every()
The following program will display the results of the test.
Are all values bigger than 500: false
Now I will deliberately make all the values bigger than 500 and what the
result is.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.every()</p>
<p>The following program will display the results of the test.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 1700, 3459, 1800, 2700, 6222, 23416, 87625900000];
var Over500 = nums.every(FunctionZ);

document.getElementById("demo789").innerHTML = "Are all values bigger than 500: " +
Over500;
function FunctionZ(valueF) {
return valueF > 500;
}
</script>
</body>
</html>
This is JavaScript Array.every()
The following program will display the results of the test.
Are all values bigger than 500: true
The some() Method
There is another method that is used to check how many values of an array
have passed the test. I will check how many values have passed the over 500
test. The method may take more than one argument but as I need one, I will
stick to that. You can add more arguments to sift through the index and
produce the entire array.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.some()</p>
<p>The following program will display the results of the test.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 170, 345, 1800, 270, 622, 23416, 87625900000];
var Over500 = nums.some(FunctionZ);
document.getElementById("demo789").innerHTML = "Are there some values bigger than
500: " + Over500;
function FunctionZ(valueF) {
return valueF > 500;
}
</script>
</body>
</html>
This is JavaScript Array.some()
The following program will display the results of the test.

Are there some values bigger than 500: true
The indexOf() Method
The indexOf() method combs through the array to search for a value and then
return the position of the value. The first item on the list has a position 0
while the second item has a positon 1.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Array.indexOf()</p>
<p>The following program will display the index of the elements of the array.</p>
<p id="demo789"></p>
<script>
var nums = [45890, 170, 345, 1800, 270, 622, 23416, 87625900000];
var p = nums.indexOf(622);
document.getElementById("demo789").innerHTML = "The position of 622 in the array is: "
+ p;
</script>
</body>
</html>
This is JavaScript Array.indexOf()
The following program will display the index of the elements of the array.
The position of 622 in the array is: 5
Let us analyze the syntax of the method. At the start, you need to write the
name of the item that the method must search for. The second part is
optional. You may tell the code about the starting point of the search. The
negative values will start at a specific position and counting will start from
the last point. The search will go on to the end. If the browser does not find
the item, it will return -1 as a result. If the item has more than one instant
presence in the array, it will display the first occurrence's position.
<!DOCTYPE html>
<html>
<body>
<p>This is Array.lastIndexOf()</p>
<p id="demo00"></p>

<script>
var veggies = ["Garlic", "Tomatoes", "Potatoes", "Tomatoes", "Pumpkin", "Tomatoes"];
var a = veggies.lastIndexOf("Tomatoes");
document.getElementById("demo00").innerHTML = "Tomatoes are found at position " +
(a);
</script>
</body>
</html>
This is Array.lastIndexOf()
Tomatoes are found at position 5
The find() Method
The find() method gives you the value of the first item in the array that will
pass the test function.
<!DOCTYPE html>
<html>
<body>
<p>This is Array.find()</p>
<p id="demo00"></p>
<script>
var nums = [444, 55544, 2333, 56666, 22, 876];
var a = nums.find(FunctionZ);
document.getElementById("demo00").innerHTML = "The number that is bigger than 500 =
" + a;
function FunctionZ(valueF) {
return valueF > 500;
}
</script>
</body>
</html>
This is Array.find()
The number that is bigger than 500 = 55544
The findIndex() Method
The findIndex() method will return the index number of the first element of
your array that will go through and pass a test. As the array we are working
on is made of numbers, I will put a condition that the array will test each
number to check if it is lesser than 500 or not.

<!DOCTYPE html>
<html>
<body>
<p>This is Array.findIndex()</p>
<p id="demo055"></p>
<script>
var nums = [444, 55544, 2333, 56, 22, 876];
var a = nums.findIndex(FunctionZ);
document.getElementById("demo055").innerHTML = "The index of the number that is
lower than 500 = " + a;
function FunctionZ(valueF) {
return valueF < 500;
}
</script>
</body>
</html>
This is Array.findIndex()
The index of the number that is lower than 500 = 0

Chapter Six
JavaScript Loops
The JavaScript for loop contains a statement and three expressions. There is
an initialization part that runs before the first execution on the for loop. This
expression is used for the creation of counters. The variables that you create
here are immediately scoped into the for loop. Once the loop is executed and
reached its logical end, these variables get destroyed.
Another important of the JavaScript for loop is the condition. The for loop
checks this expression before the execution of each new iteration. If you omit
this part, the expression is evaluated as true, and the statement in the loop is
executed. If the evaluation is false, the loop stops working.
Another important part of the loop is final-expression. This expression is run
after each iteration. It is used for incrementing the counter. However, you can
also use it for decrementing the counter as well. The statement part of the
loop is the code that has to repeat inside of the loop. You can omit any of
these expressions from the for loop as per need.
For loops in JavaScript are used to count mathematical numbers or iterations
of a statement. They can also repeat a statement in the code. You can exit a
loop only after you have inserted in it a break statement. I will explore more
the break statement in the following sections.
Loops are special because they save from the hassle of writing a code
multiple times. It repeats the code once you have included it in the loop. How
many times a code block should be repeated depends on the number you
include in the code. Also, each time the loop executes the code, the value will
be different. So, although there is the repetition of the code, the repetition
proceeds with some proper method.
<!DOCTYPE html>
<html>
<body>
<p id="forloop-demo"></p>

<script>
var carsforsale = ["Honda", "Toyota", "Vezel", "Fiat", "Volkswagen"];
var msg = "";
var YY;
for (YY = 0; YY < carsforsale.length; YY++) {
msg += carsforsale[YY] + "<br>";
}
document.getElementById("forloop-demo").innerHTML = msg;
</script>
</body>
</html>
Honda
Toyota
Vezel
Fiat
Volkswagen
In this example, I created an array and then added a for loop to iterate through
the elements of the array. The for loop iterated through the items of the array
and displayed them neatly on independent lines.
<!DOCTYPE html>
<html>
<body>
<p id="demo1"></p>
<script>
var msg = "";
var YY;
for (YY = 0; YY < 3; YY++) {
msg += "The next number you will have to add to the list is " + YY + "<br>";
}
document.getElementById("demo1").innerHTML = msg;
</script>
</body>
</html>
The next number you will have to add to the list is 0
The next number you will have to add to the list is 1
The next number you will have to add to the list is 2
In this example, the first statement sets up a variable even before the

initiation of the loop. The second statement defines the proper condition for
this loop to run. According to the condition, the loop must not run more than
three times. The third statement increases the value of the variable by YY++
each time the for loop executes the code.
Usually, you need to use the first statement to initialize the variable in the
loop. However, this must not always happen. JavaScript does not make it
mandatory to start with the first statement. You can skip it and initialize
different values in the first statement.
<!DOCTYPE html>
<html>
<body>
<p id="demo1"></p>
<script>
var carsforsale = ["Vezel", "Fortuner", "Sportage", "Sorento"];
var YY, length, msg;
for (YY = 0, length = carsforsale.length, msg = ""; YY < length; YY++) {
msg += carsforsale[YY] + "<br>";
}
document.getElementById("demo1").innerHTML = msg;
</script>
</body>
</html>
Vezel
Fortuner
Sportage
Sorento
You also can skip the first statement as if your values have been set before
the initiation of the loop.
<!DOCTYPE html>
<html>
<body>
<p id="demo1"></p>
<script>
var carsforsale = ["Vezel", "Fortuner", "Sportage", "Sorento"];
var YY = 0
var length = carsforsale.length
var msg = ""
for (; YY < length; YY++) {

msg += carsforsale[YY] + "<br>";
}
document.getElementById("demo1").innerHTML = msg;
</script>
</body>
</html>
Vezel
Fortuner
Sportage
Sorento
The second statement in the for loop is often used to evaluate the condition of
the starting variable. However, this may not be the case always. JavaScript
does not care anymore. The second statement is optional. If the second
statement returns as true, the loop will restart all over again. If it returns
otherwise, the loop is going to end. If there is an omission of the second
statement, you ought to insert a break into the loop. Otherwise, the loop will
be infinite. You will never be able to stop it. An infinite loop is a dead-end
for you because when a user opens your website that contains an infinite
loop, his or her browser will crash. The user will be unlikely to return to your
website.
The third statement increments the value of the starting variable. However,
the third statement is optional. It can do things like negative incrementing,
positive incrementing, and much more. You can omit the third statement as
well.
<!DOCTYPE html>
<html>
<body>
<p id="demo1"></p>
<script>
var carsforsale = ["Vezel", "Fortuner", "Sportage", "Sorento"];
var YY = 0
var length = carsforsale.length
var msg = ""
for (; YY < length; YY++) {
msg += carsforsale[YY] + "<br>";
YY++;
}

document.getElementById("demo1").innerHTML = msg;
</script>
</body>
</html>
Vezel
Sportage
The most important things to keep in mind are that the counter YY serves
important purposes. It keeps in its memory the number of iterations so that it
can halt looping at the exact point. It also serves as the index number of an
array, allowing the code to move through the array elements as the counter
progresses and increments with the iterations.
The variable name YY cannot be considered as sacred. The name can be
different.  You can choose one according to your liking as long as the name is
legal and it corresponds to the naming rules. Most programmers also use i as
a variable because it indicates the number of iterations that the program must
perform.
The for/in Loop
Another type of the for loop is JavaScript for/in loop. This loop iterates
through all the properties of a particular object.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript For/In Loop</p>
<p>Our for/in loops through all the properties of the object car.</p>
<p id="demo1"></p>
<script>
var msg = "";
var car = {name:"Honda", model:"Vezel", year:2020, make:"Japan"};
var YY;
for (YY in car) {
msg += car[YY] + " ";
}
document.getElementById("demo1").innerHTML = msg;
</script>
</body>
</html>

Learning JavaScript For/In Loop
Our for/in loops through all the properties of the object car.
Honda Vezel 2020 Japan
In this example, the for in loop tends to iterate through the object car. With
each iteration it returns the key (YY). The program uses the key to access a
specific value of the key that is car[YY].
The for/in loop is special because you can pair it up with an array and it will
loop through the properties of the array just like it did with the properties of
the object.
<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=windows-1050" http-equiv="Cont-Type">
</head>
<body>
<p>These are JavaScript For In Loops</p>
<p>I will show how the for/in statement loop through and over Array values.</p>
<p id="demo5"></p>
<script>
var msg = "";
var nums = [5545, 24, 139, 6716, 4425];
var YY;
for (YY in nums) {
msg += nums[YY] + "<br>";
}
document.getElementById("demo5").innerHTML = msg;
</script>
</body>
</html>
These are JavaScript For In Loops
I will show how the for/in statement loop through and over Array values.
5545
24
139
6716

4425
You should drop the idea of using for in over the array loops if you are keen
on the order of the index. The order is independent of implementation. You
cannot access values of the array in the order that you expect. It is important
and better for you to use a for of loop, for loop, and the Array.forEach()
whenever you think the order is special.
The forEach() Loop
This method calls a function, also known as the callback function, one time
for each element of the array.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Array.forEach() loops</p>
<p>This program will call a function one time for each element of the array.</p>
<p id="demo5"></p>
<script>
var msg = "";
var nums = [55545, 454, 1239, 78816, 45625];
nums.forEach(FunctionYZ);
document.getElementById("demo5").innerHTML = msg;
function FunctionYZ(fvalue, findex, farray) {
msg = msg + fvalue + "<br>";
}
</script>
</body>
</html>
Learning JavaScript Array.forEach() loops
This program will call a function one time for each element of the array.
55545
454
1239
78816
45625
The function in the above-mentioned code usually takes in three arguments.
The first argument is the value of the item. The second argument is the index

of the item, and the third argument is the array itself. As the example uses
only the value parameter, you can rewrite it in the following pattern.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Array.forEach() loops</p>
<p>This program will call a function one time for each element of the array.</p>
<p id="demo5"></p>
<script>
var msg = "";
var nums = [55545, 454, 1239, 78816, 45625];
nums.forEach(FunctionYZ);
document.getElementById("demo5").innerHTML = msg;
function FunctionYZ(fvalue) {
msg = msg + fvalue + "<br>";
}
</script>
</body>
</html>
Learning JavaScript Array.forEach() loops
This program will call a function one time for each element of the array.
55545
454
1239
78816
45625
I have excluded all the other parameters except fvalue and still got the same
result.
The for/of Loop
There is another type of for loops in JavaScript, known as the for/of
statement. This statement loops through the values of a particular object that
can be iterated. This statement allows you to create a loop through all kinds
of data structures like Maps, Arrays, NodeLists, and Strings.

When an iteration starts, the value of the next property is automatically
assigned to a variable. Variables in JavaScript are declared with var, const
and let keywords. We have already covered all the topics in the past chapters.
Safari 7, Chrome 38, Opera 25, Edge 12, and Firefox 51 are the only
browsers that presently support the for/of statements. Internet Explorer does
not support it.
<!DOCTYPE html>
<html>
<body>
<p>These are JavaScript For/Of Loop</p>
<p>The for/of statement will create a loop through all the values of objects that you can
iterate through.</p>
<p id="demo6"></p>
<script>
let carsforsale = ["Volkswagen", "Vezel", "Ford", "Fortuner", "Sportage"];
let msg = "";
for (let YY of carsforsale) {
msg += YY + "<br>";
}
document.getElementById("demo6").innerHTML = msg;
</script>
</body>
</html>
These are JavaScript For/Of Loop
The for/of statement will create a loop through all the values of objects that
you can iterate through.
Volkswagen
Vezel
Ford
Fortuner
Sportage
In the next example, I will use a string instead of an array to get the same
result.

<!DOCTYPE html>
<html>
<body>
<p>These are JavaScript For/Of Loop</p>
<p>The for/of statement will create a loop through all the values of objects that you can
iterate through.</p>
<p id="demo6"></p>
<script>
let carsforsale = "Volkswagen, Vezel, Ford";
let msg = "";
for (let YY of carsforsale) {
msg += YY + "<br>";
}
document.getElementById("demo6").innerHTML = msg;
</script>
</body>
</html>
These are JavaScript For/Of Loop
The for/of statement will create a loop through all the values of objects that
you can iterate through.
V
o
l
k
s
w
a
g
e
n
,
V
e
z
e
l
,

F
o
r
d
Eternal Loops
When you create a loop, and it doesn’t have an ending point, it is called an
eternal loop. A loop keeps on going until the computer or browser crashes in
a condition. Eternal loops may happen by accident or by blatant carelessness.
Eternal loops are bad, and they have the tendency to slow down the web
page, driving away the visitors. You may create an eternal loop if you fail to
insert a condition in the code that makes the loop to stop after completing the
intended iterations.
JavaScript while Loops
JavaScript loops execute codes as long as specific conditions stay true. Now
that you have learned about the for loops, I will go on to explain how the
while loops work. The while loops iterate as long as certain conditions stay
true.
I will create an example in which the while loop runs as long as the condition
stands true.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript While Loops</p>
<p id="demo7"></p>
<script>
var msg = "";
var YY = 0;
while (YY < 10) {
msg += "<br>The next digit is " + YY;
YY++;
}
document.getElementById("demo7").innerHTML = msg;
</script>
</body>
</html>
Learning JavaScript While Loops

The next digit is 0
The next digit is 1
The next digit is 2
The next digit is 3
The next digit is 4
The next digit is 5
The  do/while Loop
The do/while loop is considered a variant of the while loop. It will execute
the code once before testing the condition. After that, the loop will be
repeated as long as the specific condition is true. One thing that distinguishes
the do/while from other loops is that it executes the code once, even if you
have set the condition to false. This happens because the browser executes
the code even before testing the condition.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Do/While Loop</p>
<p id="demo8"></p>
<script>
var msg = ""
var YY = 0;
do {
msg += "<br>The next digit is " + YY;
YY++;
}
while (YY < 5); 
document.getElementById("demo8").innerHTML = msg;
</script>
</body>
</html>
This is JavaScript Do/While Loop
The next digit is 0
The next digit is 1
The next digit is 2
The next digit is 3

The next digit is 4
If you analyze and run a comparison between the for and while loops, you
will realize that the two loops are almost the same. The while loop is very
much the same as the for loop. However, the only difference is that the first
and the third statements are omitted here. I will use the same example and
test the for and while loops on it to see how much difference exists between
the two. In the first part, I will use the for loop.
<!DOCTYPE html>
<html>
<body>
<p id="demo9"></p>
<script>
var carsforsale = ["Vezel", "Fortuner", "Land Cruiser", "Jimmy"];
var YY = 0;
var msg = "";
for (;carsforsale[YY];) {
msg += carsforsale[YY] + "<br>";
YY++;
}
document.getElementById("demo9").innerHTML = msg;
</script>
</body>
</html>
Vezel
Fortuner
Land Cruiser
Jimmy
In the following, I will use the while loop to collect the names of the cars for
sale and then display them neatly in the browser.
<!DOCTYPE html>
<html>
<body>
<p id="demo9"></p>
<script>
var carsforsale = ["Vezel", "Fortuner", "Land Cruiser", "Jimmy"];
var YY = 0;
var msg = "";
while (carsforsale[YY]) {
msg += carsforsale[YY] + "<br>";

YY++;
}
document.getElementById("demo9").innerHTML = msg;
</script>
</body>
</html>
Vezel
Fortuner
Land Cruiser
Jimmy
JavaScript Break and Continue Statements
The break and continue statements are inherently related to for and while
loops. The break statement allows you to jump out of the loop and the
continue statement to make a jump over one specific iteration inside the loop.
The later statement does not break the loop. The program continues to move
on. I have already explained the break statement when I discussed the switch
statement in the previous chapters. However, there its use was different as it
was applied to the switch statements. Now I will use the break statement in
the loops.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Loops</p>
<p>I will integrate a <b>break</b> statement to the for loop.</p>
<p id="demo9"></p>
<script>
var msg = "";
var YY;
for (YY = 0; YY < 10; YY++) {
if (YY === 5) { break; }
msg += "The next digit is " + YY + "<br>";
}
document.getElementById("demo9").innerHTML = msg;
</script>
</body>
</html>
Learning JavaScript Loops

I will integrate a break statement to the for loop.
The next digit is 0
The next digit is 1
The next digit is 2
The next digit is 3
The next digit is 4
The loop had to complete the iteration through 10 digits, but as I added a
break statement at position 5, the loop broke out of iterations, and the
program stopped. The continue statement cannot be said to be the opposite of
the break statement because, like the break statement, it also breaks the loop
but then continues with the rest of the iterations of the program. I will use the
same example to elaborate upon how you can benefit from the continue
statement.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Loops</p>
<p>I will integrate a <b>break</b> statement to the for loop.</p>
<p id="demo9"></p>
<script>
var msg = "";
var YY;
for (YY = 0; YY < 10; YY++) {
if (YY === 5) { continue; }
msg += "The next digit is " + YY + "<br>";
}
document.getElementById("demo9").innerHTML = msg;
</script>
</body>
</html>
Learning JavaScript Loops
I will integrate a break statement to the for loop.
The next digit is 0
The next digit is 1
The next digit is 2

The next digit is 3
The next digit is 4
The next digit is 6
The next digit is 7
The next digit is 8
The next digit is 9
The loop broke at point 5 and then continued. You can see that the only
number that is missing in the results is number 5. The continue statement is
suitable for skipping one iteration of a loop. The break statement has only
one purpose: to give you a jump out of a switch or a loop. You can use the
break statement to make a jump out of a code block.

Chapter Seven
JavaScript Functions
Until now, we have created scripts that run the minute the web page loads up
in a browser. There is another way to use the code. You can pack up the code
inside a function and run it in the web browser. Unless you make a function
call, you will not see anything in action on the browser. A function phrase
contains the function keyword, the name of the function, and curly braces.
You have to include a space after the function keyword. After that, you need
to write the name that you choose to give to your function. These are quite
similar to the variable-name tradition. However, the only difference in the
naming of functions is that you can add a number, a letter, $ 0r underscores to
the name of a function. After this, you need to add a set of round brackets or
parentheses to include any arguments. After that, you need to put in the curly
brackets to write the code. You don’t have to write your function on multiple
lines. You can write it on a single line if you are comfortable with that.
However, it is better to write it on multiple lines at the start so that you get a
clear idea of how it is written. In addition, you can correct any mistake easily
if the code does not work well.
A JavaScript function is created to perform a special task. You can execute it
when you make a function call.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Functions</p>
<p>In this example I will make a function call to perform a calculation and gives back the
result:</p>
<p id="demo890"></p>
<script>
function FunctionZZ(x1, x2) {
return x1 * x2;
}
document.getElementById("demo890").innerHTML = FunctionZZ(345, 1222);

</script>
</body>
</html>
Learning JavaScript Functions
In this example, I will make a function call to perform a calculation and gives
back the result:
421590
You can see that there is a function keyword that is followed by the name of
the function. I have included the parentheses in the code. You may include
one or more parameters in the parentheses. The code that you need to include
in the function is put inside the curly brackets. As for the function arguments,
you have to pass them when you have created a function, and now you want
to invoke it. Inside of it, the arguments tend to behave very much like local
variables. A function works the same way as a Subroutine, and a Procedure
do in other programming languages.
The Invocation of Function
The code that you pack up inside a function will only execute if and when
you invoke the function. The process of invoking is also called making a
function call. It may happen when a visitor hits a button on a web page, or
you can invoke it from the JavaScript code. You may also set the function on
self-invoked.
There is a return at the end of a function. When you reach it, the function will
cease to execute. Functions more often compute the return value, and the
value is then returned to the one who made the function call.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Functions</p>
<p>In this example I will make a function call to perform a calculation and gives back the
result:</p>
<p id="demo890"></p>
<script>
var Y = FunctionZZ(55, 2345)
document.getElementById("demo890").innerHTML = Y;

function FunctionZZ(x1, x2) {
return x1 * x2;
}
</script>
</body>
</html>
Learning JavaScript Functions
In this example I will make a function call to perform a calculation and gives
back the result:
128975
In the following example, you will see how I will reuse the code many times
after creating it once. You can fill it up with as many arguments as you like
and produce different results. This saves time and effort when you are
developing a web page. This also makes the process of coding faster and
efficient. See the following example.
<!DOCTYPE html>
<html>
<body>
<p>This will make a function call to convert digits from Fahrenheit to Celsius:</p>
<p id="demo789"></p>
<script>
function toCels(f) {
return (15/90) * (f-40);
}
document.getElementById("demo789").innerHTML = toCels(80);
</script>
</body>
</html>
This will make a function call to convert digits from Fahrenheit to Celsius:
6.666666666666666
The () Operator
The word toCels refers to the object of the function while toCels() refers to
the result of the function. When you access a function without the
parentheses, it will return the object of the function instead of the result of the
function. Let us see how the function behaves when you miss out on the
parentheses.

<!DOCTYPE html>
<html>
<body>
<p>This will make a function call to convert digits from Fahrenheit to Celsius:</p>
<p id="demo789"></p>
<script>
function toCels(f) {
return (15/90) * (f-40);
}
document.getElementById("demo789").innerHTML = toCels;
</script>
</body>
</html>
This will make a function call to convert digits from Fahrenheit to Celsius:
function toCels(f) { return (15/90) * (f-40); }
Instead of the result, we got the script of the function printed on the web
browser,
Functions as Variables
You can use functions in the same way as you use variables in different
assignments, formulas, and calculations. Instead of using variables for storing
the return value of functions, you can use it directly in the form of the
variable value.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Functions</p>
<p id="demo1234"></p>
<script>
document.getElementById("demo1234").innerHTML =
"Presently, the average temperature is about " + toCels(90) + " Celsius";
function toCels(tempfahrenheit) {
return (15/9) * (tempfahrenheit-40);
}
</script>
</body>
</html>
Learning JavaScript Functions

Presently, the average temperature is about 83.33333333333334 Celsius
Local Variables
The variables that you declare inside of a JavaScript function become local to
a function. You can only access local variables from inside of a function.
<!DOCTYPE html>
<html>
<body>
<p>A variable out of a Function is undefined.</p>
<p id="demo15"></p>
<p id="demo25"></p>
<script>
FunctionOP();
function FunctionOP() {
var carsforsale = "BMW";
document.getElementById("demo15").innerHTML =
typeof carsforsale + " " + carsforsale;
}
document.getElementById("demo25").innerHTML =
typeof carsforsale;
</script>
</body>
</html>
A variable out of a Function is undefined.
string BMW
undefined
Local variables can be recognized in the functions. The variables that have
the same name may be used in multiple functions. When a function starts,
you can create local variables. When the function completes, local variables
are deleted.
When you have created a function, you can save the code and load it up in the
browser. If you see nothing happening, you did it right because the code that
exists between the curly braces does not get a display. There are more than
one ways to make a function call. You can use the onLoad function to load
the function to the browser window. You may add the code onLoad to the
start of the function for successful execution.

JavaScript Expressions
You can define a JavaScript function with the help of an expression. You can
store the expression of the function inside a variable.
<!DOCTYPE html>
<html>
<body>
<p>In this example, I will store a function in a variable:</p>
<p id="demo12"></p>
<script>
var Y = function (x, y) {return x * y};
document.getElementById("demo12").innerHTML = Y;
</script>
</body>
</html>
In this example, I will store a function in a variable:
function (x, y) {return x * y}
After the expression has been stored in a variable, you can use the variable in
the function. In the following example, I will allot values to a variable.
<!DOCTYPE html>
<html>
<body>
<p>In this example, I will store a function in a variable:</p>
<p id="demo12"></p>
<script>
var Y = function (x, y) {return x * y};
document.getElementById("demo12").innerHTML = Y(34, 89);
</script>
</body>
</html>
In this example, I will store a function in a variable:
3026
If you analyze the above examples, you will notice that the function lacks a
name. I deliberately kept it anonymous. The functions that are stored inside
the variables are in no need of naming. You can always invoke them by using
the name of the variable. As for the addition of a semicolon to the end, it is
needed to end an executable statement.

The constructor()
JavaScript functions are usually defined with the help of the function
keyword. These functions are created and defined with a constructor().
<!DOCTYPE html>
<html>
<body>
<p>Analyzing the built-in constructor to create functions.</p>
<p id="demo555"></p>
<script>
var FunctionLK = new Function("x", "y", "return x * y");
document.getElementById("demo555").innerHTML = FunctionLK(345, 2);
</script>
</body>
</html>
Analyzing the built-in constructor to create functions.
690
If we consider the practical applications of the constructor(), we will realize
that we don’t have to use the constructor.
<!DOCTYPE html>
<html>
<body>
<p>Analyzing the built-in constructor to create functions.</p>
<p id="demo555"></p>
<script>
var FunctionLK = function(x, y) {return x * y};
document.getElementById("demo555").innerHTML = FunctionLK(345, 2);
</script>
</body>
</html>
Analyzing the built-in constructor to create functions.
690
Self-Invoking
The expressions of functions may be made self-invoking. A self-invoking
expression may be invoked automatically even if you do not make a call. The
expressions of functions will execute automatically if you put parentheses
after the function. It is not possible that you self-invoke a declaration of a

function. You must add parentheses around a function for the sake of
indication that it is the expression of a function.
<!DOCTYPE html>
<html>
<body>
<p>You can invoke functions automatically without calling them:</p>
<p id="demo6789"></p>
<script>
(function () {
document.getElementById("demo6789").innerHTML = "This is calling by myself";
})();
</script>
</body>
</html>
You can invoke functions automatically without calling them:
This is calling by myself
The function in the above-mentioned example is an anonymous self-invoking
function. I did not give it a name. You can use functions as values in the
following manner.
<!DOCTYPE html>
<html>
<body>
<p>You can use Functions as values:</p>
<p>Y = FunctionH(2,2) or Y = 4</p>
<p>In the above cases, Y is a numberbecomes a number with the value of 4.</p>
<p id="demo12"></p>
<script>
function FunctionH(x, y) {
return x * y;
}
var Y = FunctionH(2, 2);
document.getElementById("demo12").innerHTML = Y;
</script>
</body>
</html>
You can use Functions as values:
Y = FunctionH(2,2) or Y = 4
In the above cases, Y is a number becomes a number with the value of 4.

4
You can use JavaScript functions in JavaScript expressions.
<!DOCTYPE html>
<html>
<body>
<p>You can use functions in expressions.</p>
<p id="demo678"></p>
<script>
function Function123(x, y) {
return x * y;
}
var Y = Function123(5, 2) * 8;
document.getElementById("demo678").innerHTML = Y;
</script>
</body>
</html>
You can use functions in expressions.
80
Functions or Objects
If you use the typeof operator we learned about in the previous chapters to
know the type of functions, you will realize that JavaScript functions are best
described in the form of objects. Just like objects, functions in JavaScript
have methods and properties. In the following examples, I will try to apply
some properties to functions and see how it behaves.
<!DOCTYPE html>
<html>
<body>
<p>The arguments.length property is used to return arguments that the function:</p has
received>
<p id="demo90"></p>
<script>
function FunctionP(x, y) {
return arguments.length;
}
document.getElementById("demo90").innerHTML = FunctionP(40, 3, 78);
</script>
</body>
</html>

The arguments.length property is used to return arguments that the function
has received:
3
The toString() Method
If you want to convert your function into a string, you can use the toString()
method to make it happen. Here is how you can manipulate a function and
make it a string.
<!DOCTYPE html>
<html>
<body>
<p>The toString() method converts your function into a string:</p>
<p id="demo12"></p>
<script>
function Function1234(x, y, z) {
return x * y * z;
}
document.getElementById("demo12").innerHTML = Function1234.toString();
</script>
</body>
</html>
The toString() method converts your function into a string:
function Function1234(x, y, z) { return x * y * z; }
A function that is defined as a property to a particular object is labeled as a
method to the object. A function that must create new objects is named an
object constructor.
Arrow Functions
Arrows help you shorten the length of text in a function. The syntax will be
short, and the time to write it will shrink, facilitating more coding in a short
time. If you are using the arrow functions, you no longer need the function
keyword, curly braces and the return keyword.
<!DOCTYPE html>
<html>
<body>

<p>Learning JavaScript Arrow Functions</p>
<p>IE11 or earlier versions do not support Arrow functions.</p>
<p id="demo123"></p>
<script>
const a = (a, b) => a * b;
document.getElementById("demo123").innerHTML = a(50, 50);
</script>
</body>
</html>
Learning JavaScript Arrow Functions
IE11 or earlier versions do not support Arrow functions.
2500
There is no need for this in arrow functions. Arrow functions are not suited
well to define methods pertaining to objects. These functions lack the
hoisting feature. You must define an arrow function before you put it to use
in a program. Without the definition, you will see an error in the program.
The use of const in arrow functions is considered a safer method instead of
using the var keyword. This is because a function expression always has a
constant value. You should remove the curly braces and the return keyword if
only the function consists of a single statement.
Parameters & Arguments
A JavaScript function cannot perform any kind of check on the values of the
parameter. Function parameters are names that are listed in the definition of
the function. The arguments, on the other hand, consist of real values that are
passed to the function. After receiving them, the function works on them and
uses them to create different types of outputs.
There are no set rules to define the parameters. JavaScript function
parameters don’t have to define the data types for the parameters. There is no
typechecking you should do on passed arguments. There is absolutely no
check on the total number of arguments a function receives.
Default Function Parameters
In most cases, you may not feel the need to fill up a function with arguments
and in case of missing arguments, you will see undefined values in the

results. In some cases, you may let it go on. However, in some cases, you
cannot leave out the arguments section undefined. It just does not suit web
browsers. A default value for the parameters will cover up if you miss out on
inserting a value for an argument.
<!DOCTYPE html>
<html>
<body>
<p>I am now setting up a default value to the function parameter.</p>
<p id="demo567"></p>
<script>
function FunctionTUP(a, b) {
if (b === undefined) {
b = 6;
}
return a * b;
}
document.getElementById("demo567").innerHTML = FunctionTUP(6);
</script>
</body>
</html>
I am now setting up a default value to the function parameter.
36
The latest standards of ECMAScript 2015 allows the values of default
parameters in the declaration of the function.
<!DOCTYPE html>
<html>
<body>
<p>I am now setting up a default value to the function parameter.</p>
<p id="demo567"></p>
<script>
function FunctionTUP(a, b = 5) {
return a * b;
}
document.getElementById("demo567").innerHTML = FunctionTUP(6);
</script>
</body>
</html>
I am now setting up a default value to the function parameter.
30

There is a built-in object in JavaScript functions. Programmers name it as
arguments object. This object is pre-filled with an array that you can use
when you invoke a function. This is how you can use a function for hunting
down the highest value in the list of numbers.
<!DOCTYPE html>
<html>
<body>
<p>I am now finding the largest number in an array.</p>
<p id="demo123"></p>
<script>
function findingtheMax() {
var O;
var maximum = -Infinity;
for(O = 0; O < arguments.length; O++) {
if (arguments[O] > maximum) {
maximum = arguments[O];
}
}
return maximum;
}
document.getElementById("demo123").innerHTML = findingtheMax(4, 5, 6, 7, 8, 9, 10, 11,
12, 13, 14);
</script>
</body>
</html>
I am now finding the largest number in an array.
14
The Add Up
You can create a function to add up all the values that the function has
received as input. This is a useful tool to include on your web page. Your
visitors can calculate how much they have spent on your products and how
much they have to pay while checking out. Here is how you can use the add-
up feature of JavaScript functions. If a function has a lot of arguments, in
fact, more than the declared ones, all the arguments may be reached by using
the object of arguments.
<!DOCTYPE html>
<html>
<body>
<p>Here is how you can sum up all the arguments:</p>
<p id="demo555"></p>

<script>
function summingUpAll() {
var Y;
var summingUp = 0;
for(Y = 0; Y < arguments.length; Y++) {
summingUp += arguments[Y];
}
return summingUp;
}
document.getElementById("demo555").innerHTML = summingUpAll(1444, 1232,
1233500, 7115, 454, 123);
</script>
</body>
</html>
Here is how you can sum up all the arguments:
1243868
The parameters, when a function is invoked, act as the arguments of a
function. You can pass on JavaScript arguments by values. The function has
to know the values and not the locations of the arguments. If a specific
function makes a change in the value of an argument, it will not change the
parameter's original value. The changes you make to function arguments
cannot be seen or used out of a function's restrictions.
Invocation
When you have written a function and invoked it, the code inside JavaScript
executes it. Only defining a function does not execute the code. Invoking a
function is the same as calling a function. You should not confuse both
because calling a function is widely used in other programming languages
like Python. JavaScript deviates a bit from the tradition by invoking a
function instead of calling it. You also can say calling upon a function,
executing a function, or starting a function. All the phrases do the same thing,
which is executing the function.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Function</p>
<p>My global function will return the product of different arguments (x , y):</p>
<p id="demo77"></p>
<script>
function FunctionXXX(x, y) {

return x * y;
}
document.getElementById("demo77").innerHTML = FunctionXXX(12, 89);
</script>
</body>
</html>
This is JavaScript Function
My global function will return the product of different arguments (x , y):
1068
The function in the example has no connection to any of the objects. This
brings us to the question as to why the execution was successful in the
absence of an object. The answer is that JavaScript has a default global
object. As JavaScript walks side by side with HTML, the default object in
HTML is the HTML page itself therefore the function is used by the HTML
page. Inside of a browser, the object is the window of your visitor's browser
so the function turns into a window function.
<!DOCTYPE html>
<html>
<body>
<p>This is JavaScript Function</p>
<p>My global function will return the product of different arguments. If you invoke
FunctionXXX, you are actually invoking window.FunctionXXX. Both are the same. (x , y):
</p>
<p id="demo77"></p>
<script>
function FunctionXXX(x, y) {
return x * y;
}
document.getElementById("demo77").innerHTML = FunctionXXX(12, 89);
</script>
</body>
</html>
This is JavaScript Function
My global function will return the product of different arguments. If you
invoke FunctionXXX, you are actually invoking window.FunctionXXX.
Both are the same. (x , y):
1068

The practice of invoking is common but it is not considered good. Methods,
global variables, and functions may land you in naming conflicts and bugs in
a global object.
In JavaScript, if you see the this keyword, you should understand that it is an
object that is the owner of the current code. When you use it in a function, the
value of this is the object which owns the function. This is not actually a
variable but a keyword. You cannot change its value.
Global Objects
When the owner object is lacking in function invocation, the value of this
turns into a global object. Inside of a web browser, the window of the
browser acts as a global object.
<!DOCTYPE html>
<html>
<body>
<p>In HTML programming language, the value of <b>this</b> is the window object.</p>
<p id="demo777"></p>
<script>
var Y = FunctionDD();
function FunctionDD() {
return this;
}
document.getElementById("demo777").innerHTML = Y;
</script>
</body>
</html>
In HTML programming language, the value of this is the window object.
[object Window]
Function as Method
In the world of JavaScript, you can define certain functions in the form of
object methods.
<!DOCTYPE html>
<html>
<body>
<p>Working on JavaScript Functions</p>
<p>thisObject.Namef() will return Mac Millan:</p>

<p id="demo234"></p>
<script>
var thisObject = {
Namef:"Mac",
Namel: "Millan",
completeName: function() {
return this.Namef + " " + this.Namel;
}
}
document.getElementById("demo234").innerHTML = thisObject.completeName();
</script>
</body>
</html>
Working on JavaScript Functions
thisObject.Namef() will return Mac Millan:
Mac Millan
The completeName is a function that belong to an object named as
thisObject. This object owns the function. In the example, the value of this is
thisObject. You can check it out.
<!DOCTYPE html>
<html>
<body>
<p>Working on JavaScript Functions</p>
<p>thisObject.Namef() will return Mac Millan:</p>
<p id="demo234"></p>
<script>
var thisObject = {
Namef:"Mac",
Namel: "Millan",
completeName: function() {
return this;
}
}
document.getElementById("demo234").innerHTML = thisObject.completeName();
</script>
</body>
</html>
Working on JavaScript Functions
thisObject.Namef() will return Mac Millan:

[object Object]
Function Constructor()
You can invoke a function by using a function constructor().
<!DOCTYPE html>
<html>
<body>
<p>Function constructor:</p>
<p id="demo234"></p>
<script>
function FunctionT(argument1, argument2) {
this.Namef = argument1;
this.Namel  = argument2;
}
var Y = new FunctionT("Mac","Millan")
document.getElementById("demo234").innerHTML = Y.Namef;
</script>
</body>
</html>
Function constructor:
Mac
Reusing Methods
With the help of the call() method, you may use a method to apply to
different types of objects. In JavaScript, all functions are methods of objects.
If a function is not, it belongs to a global object.
<!DOCTYPE html>
<html>
<body>
<p>Working on JavaScript Functions</p>
<p>thisObject.Namef() will return Mac Millan:</p>
<p id="demo234"></p>
<script>
var thisObject = {
Namef:"Mac",
Namel: "Millan",
completeName: function() {
return this.Namef + " " + this.Namel;
}
}

Y = thisObject.completeName();
document.getElementById("demo234").innerHTML = thisObject.completeName(); Y
</script>
</body>
</html>
Working on JavaScript Functions
thisObject.Namef() will return Mac Millan:
Mac Millan
The call() Method
The call() method in JavaScript is like a predefined method that you can use
to invoke a method. You can use a method that another object owns.
<!DOCTYPE html>
<html>
<body>
<p>The following example will call the fullName method of a person by using it on another
person:
</p>
<p id="demo90"></p>
<script>
var man = {
completeName: function() {
return this.Namef + " " + this.Namel;
}
}
var man1 = {
Namef:"Christiano",
Namel: "Ronaldo"
}
var man2 = {
Namef:"Lionel",
Namel: "Messi"
}
var Y = man.completeName.call(man1);
document.getElementById("demo90").innerHTML = Y;
</script>
</body>
</html>
The following example will call the fullName method of a person by using it
on another person:

Christiano Ronaldo
Now I will call the completeName method and use it on man2.
<!DOCTYPE html>
<html>
<body>
<p>The following example will call the fullName method of a person by using it on another
person:
</p>
<p id="demo90"></p>
<script>
var man = {
completeName: function() {
return this.Namef + " " + this.Namel;
}
}
var man1 = {
Namef:"Christiano",
Namel: "Ronaldo"
}
var man2 = {
Namef:"Lionel",
Namel: "Messi"
}
var Y = man.completeName.call(man2);
document.getElementById("demo90").innerHTML = Y;
</script>
</body>
</html>
The following example will call the fullName method of a person by using it
on another person:
Lionel Messi
Adding Arguments
The call() method is flexible enough to include many arguments to the
function to make it more interactive and useful. Now that we have a function
that has two men. We can add more arguments to the functions to share more
details about the two men so that we can display the details on a web page.
Suppose you are building a website for soccer stars. You have to add data
about the players to the database so that your visitors may see and read it, and
stay longer on your website. Function’s call() method can help you a great
deal in this venture. I will create an example and add arguments to the same
to see how many arguments we can add and how we can add them.

<!DOCTYPE html>
<html>
<body>
<p>The following example will call the fullName method of a person by using it on another
person:
</p>
<p id="demo90"></p>
<script>
var man = {
completeName: function(profession, economicalstatus) {
return this.Namef + " " + this.Namel + " , " + profession + " , " + economicalstatus;
}
}
var man1 = {
Namef:"Christiano",
Namel: "Ronaldo"
}
var man2 = {
Namef:"Lionel",
Namel: "Messi"
}
var Y = man.completeName.call(man2, "soccer star", "extremely rich");
document.getElementById("demo90").innerHTML = Y;
</script>
</body>
</html>
The following example will call the fullName method of a person by using it
on another person:
Lionel Messi , soccer star , extremely rich
You apply the same arguments to the another person.
<!DOCTYPE html>
<html>
<body>
<p>The following example will call the fullName method of a person by using it on another
person:
</p>
<p id="demo90"></p>
<script>
var man = {
completeName: function(profession, economicalstatus) {
return this.Namef + " " + this.Namel + " , " + profession + " , " + economicalstatus;
}
}
var man1 = {
Namef:"Christiano",
Namel: "Ronaldo"

}
var man2 = {
Namef:"Lionel",
Namel: "Messi"
}
var man3 = {
Namef:"Bill",
Namel: "Gates"
}
var man4 = {
Namef:"Elon",
Namel: "Musk"
}
var Y = man.completeName.call(man4, "Businessperson", "World's Richest Person");
document.getElementById("demo90").innerHTML = Y;
</script>
</body>
</html>
The following example will call the fullName method of a person by using it
on another person:
Elon Musk , Businessperson , World's Richest Person

Chapter Eight
JavaScript Objects
The objects in JavaScript have curly braces around them. You have to write
the properties of objects in the form of name:value pairs. You may separate
them with commas. Objects are treated as emperors in the world of
JavaScript. If you have a thorough concept of objects, you can understand
JavaScript well.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript Objects</p>
<p id="objects-demo"></p>
<script>
var car = {
Name : "BMW",
Make  : "Germany",
model     : 2020,
Color  : "silver"
};
document.getElementById("objects-demo").innerHTML =
car.Name + " is made in " + car.Make + "." + " The model no is " + car.model + " and the
color is " + car.Color + ".";
</script>
</body>
</html>
Learning JavaScript Objects
BMW is made in Germany. The model no is 2020, and the color is silver.
The object that I created in the above-mentioned example has multiple
properties. I have given it a name, the model no, the color, and the make.
This is how you can add more properties in line with the demands of the
object you create.
Almost everything in JavaScript can be objects. Booleans may be objects if

you define them with a new keyword. Similarly, numbers may be objects
when you define them with the same new keyword. Strings may also be
objects when paired up with the new keyword. Math and dates are objects as
well. Arrays and regular expressions are objects. Functions also are objects.
Except for primitives, everything in JavaScript is an object.
Objects may be filled up with variables. An object in JavaScript is a
collection of values that are named. These named values are known as
properties. You saw their applications in the chapter on functions. You can
perform certain actions named as methods on different objects. These
properties may be primitive, like objects and functions. An object method
contains the definition of a function, and you can create and define an object
in JavaScript. You can use a number of methods to do that. You can achieve
this purpose to create an object, namely literal. The keyword new is used for
the creation. Object literal is considered the easiest way to create an object in
JavaScript. By using the object literal, you can do that using one statement
only.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Objects
</p>
<p id="demo90"></p>
<script>
var man1 = { Namef:"Christiano", Namel: "Ronaldo", profession: "soccer star",
economicalstatus: "rich"};
document.getElementById("demo90").innerHTML =
man1.Namef + " is the biggest " + man1.profession + " across the world. He is a " +
man1.economicalstatus + " person."
;
</script>
</body>
</html>
JavaScript Objects
Christiano is the biggest soccer star across the world. He is a rich person.
The lines and spacing are of no importance when it comes to creating objects
in JavaScript. You can use more than one line to create the object and the
result will be the same. See the same example of object creation in another

form.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Objects
</p>
<p id="demo90"></p>
<script>
var man1 = {
Namef:"Christiano",
Namel: "Ronaldo",
profession: "soccer star",
economicalstatus: "rich"
};
document.getElementById("demo90").innerHTML =
man1.Namef + "is the biggest " + man1.profession + " aross the world. He is a " +
man1.economicalstatus + " person."
;
</script>
</body>
</html>
I will write the results here because they are going to be the same. This
method is neat and efficient in writing a clean code. If you get used to writing
clean code like this, you will find it easy to read it once you get back to the
editor to read or change the code.
The new Keyword
The new keyword in the world of JavaScript is the most important. It has
many properties, and you can use it in multiple ways. See its use in the same
example and feel the difference, not in the result but only in the code.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Objects
</p>
<p id="demo90"></p>
<script>
var man1 = new Object();
man1.Namef="Christiano";
man1.Namel = "Ronaldo";

man1.profession = "soccer star";
man1.economicalstatus = "rich";
document.getElementById("demo90").innerHTML =
man1.Namef + " is the biggest " + man1.profession + " across the world. He is a " +
man1.economicalstatus + " person."
;
</script>
</body>
</html>
JavaScript Objects
Christiano is the biggest soccer star across the world. He is a rich person.
You can see that the only difference is that I had to add more words and
symbols and delete some old ones as well. I removed the curly braces, added
the equal sign instead of a colon. I had to remove the commas and add
semicolons in its place. Whatever the changes you observe, I recommend that
you use the literal method for the sake of ease of use. The new keyword only
makes the code more complicated without having any effect on the results.
You can mute JavaScript objects at will. You must address an object by a
reference and not by a value. If you have built an object by a person's
attributes, you cannot create a copy by simple methods.
Object Properties
JavaScript Properties are the most important parts of objects. Each object has
a value named as a property. Each object is built on a set of unordered
properties. You can change them, add more to them or delete them. However,
some of them are read-only.
When you have created an object, you can build a loop through the same to
iterate through all the items of the object. See the following example for
reference.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Object Properties</p>
<p id="demo555"></p>
<script>
var msg = "";

var man1 = {namef:"Lionel", namel:"Messi", agem:33};
var Y;
for (Y in man1) {
msg += man1[Y] + " ";
}
document.getElementById("demo555").innerHTML = msg;
</script>
</body>
</html>
JavaScript Object Properties
Lionel Messi 33
Adding new property to an existing object is never difficult. You can add a
new property by simply giving it a value. I will use the same object that I
have already created. I will add a new property to show the nationality of the
person that is created as an object. See the following example.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Objects
</p>
<p id="demo90"></p>
<script>
var man1 = {
Namef:"Christiano",
Namel: "Ronaldo",
profession: "soccer star",
economicalstatus: "rich"
};
man1.nationality = "Portuguese"
document.getElementById("demo90").innerHTML =
man1.Namef + " is the biggest " + man1.profession + " across the world. He is from " +
man1.nationality + "."
;
</script>
</body>
</html>
JavaScript Objects
Christiano is the biggest soccer star across the world. He is from Portuguese.
The Deletion

Just as the addition of properties is simple and fun, the deletion is also easy
and fun to do. The keyword used is ‘delete.’ By using the keyword,
JavaScript deletes a property from the object. You should be careful when
you are using the delete keyword. It deletes the value as well as the property
in one go and you cannot use the property after you have deleted it. This is
unlike other programming languages. This operator is only applicable on
objects and will have no effect on functions and variables. This operator is
ineffective on the predefined object properties of JavaScript, and your web
application may crash if you do that. This is not good for the reputation of
your website and business.
<!DOCTYPE html>
<html>
<body>
<p>JavaScript Objects
</p>
<p id="demo90"></p>
<script>
var man1 = {
Namef:"Christiano",
Namel: "Ronaldo",
profession: "soccer star",
economicalstatus: "rich"
};
delete man1.nationality
document.getElementById("demo90").innerHTML =
man1.Namef + " is the biggest " + man1.profession + " across the world. He is from " +
man1.nationality + "."
;
</script>
</body>
</html>
JavaScript Objects
Christiano is the biggest soccer star across the world. He is from undefined.
You can see that JavaScript deleted the property even before I could use it in
the program. The word undefined shows that the value of the property is no
more.
Dates
The javaScript date feature is interesting to learn. When you are creating a

new website, you need the date feature to integrate into your web page so that
your visitors can see. It is also helpful in regulating the shipping time and
other details. By default, the output of the date feature in JavaScript is
displayed as per the browser's time zone. The display is in the form of a
complete text string. You can create different objects to include in the display
of the date. The objects may be year, month, hours, seconds, and
milliseconds. You can add more information as your need. You can use the
new Date() method to create a new data object to display the browser's
current date and time.
<!DOCTYPE html>
<html>
<body>
<p>Learning JavaScript new Dates()</p>
<p>The new Date() method will create for you a new date object that has the current date
and time:</p>
<p id="demo678"></p>
<script>
var Y = new Date();
document.getElementById("demo678").innerHTML = Y;
</script>
</body>
</html>
JavaScript Classes
JavaScript is also known as a prototype-based language. Every object in this
language keeps a hidden and internal property known as [[Prototype]]. You
can use it to extend the methods and properties of the objects you create in
the language. You can use the keyword class for the creation of a class.
Another important method to add to your class is the constructor() method.
Just as we added properties to objects, we can add properties to classes. A
class itself is not an object but a template to create objects and work with
them on web browsers.
<!DOCTYPE html>
<html>
<body>
<p>This is the JavaScript Class</p>
<p>I will show you how to create and use the JavaScript Class on your website.</p>
<p id="demo777"></p>

<p id="demo778"></p>
<p id="demo779"></p>
<script>
class LuxCars {
constructor(cname, cyear, cmake, cmodel, ccolor) {
this.cname = cname;
this.cyear = cyear;
this.cmake = cmake;
this.cmodel = cmodel;
this.ccolor = ccolor;
}
}
Car1 = new LuxCars("Ford", 2020, "USA", "Mustang", "Blue");
document.getElementById("demo777").innerHTML =
Car1.cname + " " + Car1.cyear + " " + Car1.cmake + " " + Car1.cmodel + " " + Car1.ccolor;
Car2 = new LuxCars("BMW", 2010, "Germany", "K45", "Silver");
document.getElementById("demo778").innerHTML =
Car2.cname + " " + Car2.cyear + " " + Car2.cmake + " " + Car2.cmodel + " " + Car2.ccolor;
Car3 = new LuxCars("Mercedes", 2021, "Germany", "S-Class", "Black");
document.getElementById("demo779").innerHTML =
Car3.cname + " " + Car3.cyear + " " + Car3.cmake + " " + Car3.cmodel + " " + Car3.ccolor;
</script>
</body>
</html>
This is the JavaScript Class
I will show you how to create and use the JavaScript Class on your website.
Ford 2020 USA Mustang Blue
BMW 2010 Germany K45 Silver
Mercedes 2021 Germany S-Class Black
I have created three different objects by using the same LuxCars class.
Classes offer the easiest methods to create and deploy objects to work. This
program can be helpful to you if you are running a car showroom and you
need a website to reach out to customers. One single class allows you to
create unlimited objects of different cars. Once you create the class, all you
need is to fill it up with the properties and display them on your website.
When a new object comes into being, the constructor method is called upon
and run automatically. This method is special. You must write the clear
spelling ‘constructor.’ When you create a new object in a class, the method

executes automatically, saving your time. This method starts the properties of
objects.
Class Methods
The procedure to write and execute class methods is the same as writing and
creating an object. You have to use the class keyword and the constructor()
method when you are adding a new method to the class. The total number of
methods that you can add does not have an upper cap. You can add any
number at will. Let us add a new method to declare the age of the car.
JavaScript calculates the age of the car by using the current date as a
reference. For example, if a car is produced in 2020, the program will display
the age as 1 year old because the current year is 2021.
<!DOCTYPE html>
<html>
<body>
<p>This is the JavaScript Class</p>
<p>I will show you how to create and use the JavaScript Class on your website.</p>
<p id="demo777"></p>
<p id="demo778"></p>
<p id="demo779"></p>
<script>
class LuxCars {
constructor(cname, cyear, cmake, cmodel, ccolor) {
this.cname = cname;
this.cyear = cyear;
this.cmake = cmake;
this.cmodel = cmodel;
this.ccolor = ccolor;
}
carAge() {
let cdate = new Date();
return cdate.getFullYear() - this.cyear;
}
}
let Car1 = new LuxCars("Ford", 2017, "USA", "Mustang", "Blue");
document.getElementById("demo777").innerHTML =
Car1.cname + " " + Car1.cyear + " " + Car1.cmake + " " + Car1.cmodel + " " + Car1.ccolor
+ " : " + "This car is " + Car1.carAge() + " years old.";
let Car2 = new LuxCars("BMW", 2010, "Germany", "K45", "Silver");
document.getElementById("demo778").innerHTML =
Car2.cname + " " + Car2.cyear + " " + Car2.cmake + " " + Car2.cmodel + " " + Car2.ccolor 
+ " : " + "This car is " + Car2.carAge() + " years old.";
let Car3 = new LuxCars("Mercedes", 2021, "Germany", "S-Class", "Black");
document.getElementById("demo779").innerHTML =
Car3.cname + " " + Car3.cyear + " " + Car3.cmake + " " + Car3.cmodel + " " + Car3.ccolor 

+ " : " + "This car is " + Car3.carAge() + " years old.";
</script>
</body>
</html>
This is the JavaScript Class
I will show you how to create and use the JavaScript Class on your website.
Ford 2017 USA Mustang Blue : This car is 4 years old.
BMW 2010 Germany K45 Silver : This car is 11 years old.
Mercedes 2021 Germany S-Class Black : This car is 0 years old.
Passing Parameters
You can send off parameters to your JavaScript classes. I will pass the age
and year parameters to JavaScript class. See the following example.
<!DOCTYPE html>
<html>
<body>
<p>This is the JavaScript Class</p>
<p>I will show you how to create and use the JavaScript Class on your website.</p>
<p id="demo777"></p>
<p id="demo778"></p>
<script>
class LuxCars {
constructor(cname, cyear, cmake, cmodel, ccolor) {
this.cname = cname;
this.cyear = cyear;
this.cmake = cmake;
this.cmodel = cmodel;
this.ccolor = ccolor;
}
carAge(Y) {
return Y - this.cyear;
}
}
let cdate = new Date();
let cyear = cdate.getFullYear();
let Car1 = new LuxCars("Ford", 2017, "USA", "Mustang", "Blue");
document.getElementById("demo777").innerHTML =
Car1.cname + " " + Car1.cyear + " " + Car1.cmake + " " + Car1.cmodel + " " + Car1.ccolor
+ " : " + "This car is " + Car1.carAge(cyear) + " years old.";

let Car2 = new LuxCars("BMW", 2010, "Germany", "K45", "Silver");
document.getElementById("demo778").innerHTML =
Car2.cname + " " + Car2.cyear + " " + Car2.cmake + " " + Car2.cmodel + " " + Car2.ccolor 
+ " : " + "This car is " + Car2.carAge(cyear) + " years old.";
</script>
</body>
</html>
This is the JavaScript Class
I will show you how to create and use the JavaScript Class on your website.
Ford 2017 USA Mustang Blue : This car is 4 years old.
BMW 2010 Germany K45 Silver : This car is 11 years old.
Class Inheritance
If you want to create a class inheritance, you have to add the extends
keyword to the class. The extends keyword transfers all the methods to the
inherited class.
<!DOCTYPE html>
<html>
<body>
<p>This is the JavaScript Class</p>
<p>I will show you how to create and use the JavaScript Class on your website.</p>
<p id="demo777"></p>
<p id="demo778"></p>
<script>
class LuxCars {
constructor(cname, cyear, cmake, cmodel, ccolor) {
this.cname = cname;
this.cyear = cyear;
this.cmake = cmake;
this.cmodel = cmodel;
this.ccolor = ccolor;
}
present() {
return 'We have a ' + this.cname + ' for sale';
}
}
class Ecar extends LuxCars {
constructor(battery, model) {
super(battery);
this.cmodel = model;
}

show() {
return this.present() + '. It is a ' + this.cmodel + ' model.';
}
}
let Car2 = new Ecar("Tesla", 2010);
document.getElementById("demo778").innerHTML = Car2.show()
</script>
</body>
</html>
This is the JavaScript Class
I will show you how to create and use the JavaScript Class on your website.
We have a Tesla for sale. It is a 2010 model.
The super() method in the above code refers to the parent class. When you
call this method in the constructor method, you get access to the parent class's
properties and methods. The sole purpose of inheritance is that it keeps you
from writing the same code repeatedly. You can write a class once and use its
methods and properties by creating child classes. Whenever you create a new
class, there is no need to write from the start. It saves time and space.
Getters Setters
With classes, you can adjust getters and setters in the browser. Getters and
setters are useful for the properties if you need to do something special with
the returning values. You can use the get and set keywords to add them to
your classes.
<!DOCTYPE html>
<html>
<body>
<p>This is the JavaScript Class</p>
<p>I will show you how to create and use the JavaScript Class on your website.</p>
<p id="demo777"></p>
<p id="demo778"></p>
<script>
class LuxCars {
constructor(carname, caryear, carmake, carmodel, carcolor) {
this.cname = carname;
this.cyear = caryear;
this.cmake = carmake;
this.cmodel = carmodel;

this.ccolor = carcolor;
}
get namec() {
return this.cname;
}
set namec(Y) {
this.cname = Y;
}
}
let Car2 = new LuxCars("Tesla");
document.getElementById("demo778").innerHTML = Car2.namec;
</script>
</body>
</html>
This is the JavaScript Class
I will show you how to create and use the JavaScript Class on your website.
Tesla

Conclusion
Now that you have reached the end of the book, the next step is to practice
more and be a master of JavaScript. I hope you have not only read all the
theory and code, but you have also used the code to load web pages and
display information. I deliberately enclosed all the code in HTML tags so that
you may feel it easy to use it and practice the same.
The best method is to note down the code during revisions and practice them
whenever you have time. Practice is the only way you can master this
scripted language. Memorizing the code and then using it in a web browser
are the best ways to learn JavaScript.

References
Brand, A. W. (2013). PHP, MySQL, JavaScript & HTML
5.  https://khmerbamboo.files.wordpress.com/2014/09/php-mysql-
javascript-html5-all-in-one-for-dummies.pdf
Haverbeke, M. (2018). Eloquent JavaScript. PDF
Drive  https://www.pdfdrive.com/eloquent-javascript-a-modern-
introduction-to-programming-d158409266.html
Https://www.digitalocean.com/community/tutorials/understanding-classes-
in-javascript. (2020, February 12). The advantages and
disadvantages of JavaScript.
freeCodeCamp.org. https://www.freecodecamp.org/news/the-
advantages-and-disadvantages-of-javascript/
JavaScript class inheritance. (n.d.). W3Schools Online Web
Tutorials. https://www.w3schools.com/js/js_class_inheritance.asp
JavaScript output. (n.d.). W3Schools Online Web
Tutorials. https://www.w3schools.com/js/js_output.asp
Patrick, J. (n.d.). JAVASCRIPT A Beginner’s Guide to Learning the Basics of
JavaScript Programming. PDF Drive - Search and download PDF
files for free. https://www.pdfdrive.com/javascript-a-beginners-guide-
to-learning-the-basics-of-javascript-programming-d186477670.html

JAVASCRIPT
JAVASCRIPT FRONT END
PROGRAMMING
Andy Vickler

Introduction
Developed by Facebook and released in 2013, React is one of the best front-
end libraries, used to handle view layers in mobile and web apps. React JS
gives us the ability to create user-interface components that we can reuse, and
it is currently enjoying being the most popular community-back JavaScript
library.
Who This Book is For
This guide is aimed at those who already have some developing and
programming experience and want to get to grips with React JS.  Throughout
the book, we try to explain each concept using simple examples that you can
practice for yourself. Once you have reached the end of the book, you will
have the confidence to work with the library to build your own web apps and
web pages.
Prerequisites
Working with React JS requires that you have a good working knowledge of
JavaScript, CSS, and HTML5. And, although HTML is not used with React
JS, the JSX is much like it, so a working knowledge of HTML is also useful.
The official documentation states that the React JS library helps us build
composable user interfaces and strongly encourages reusable components,
presenting data that will change. It provides us with a much better
programming model and can use Node to render on the server. Using React
helps you implement reactive data flow, which is much easier to reason than
the traditional data binding method.
React Features
React offers plenty of features:
JSX - a JavaScript syntax extension recommended for React
development, although it isn’t strictly necessary.

Components – React JS is strongly focused on components.
Indeed, everything is a component, and if you can get into that
way of thinking, you will find code maintenance much easier
with large-scale projects.
Flux and Unidirectional Data Flow – One of the easiest ways
to reason about your app is with the one-way data flow
implemented by React, using a pattern called Flux.
React Advantages
It uses a JavaScript object called Virtual DOM, much faster than
the regular DOM, and helps to improve the performance of your
apps.
It can be used on both the server and client-side, as well as other
frameworks
The data and component patterns make readability much better,
helping to maintain much bigger apps.
React Limitations
It only works on the app view layer, so you will still need other
technologies to build a complete development tool kit.
It uses JSX and inline templating, which some developers find a
little awkward.
React JS is one of the best tools to have in your front-end development tool
kit, so get stuck in and get to grips with all the concepts and learn how to use
them through simple, practical examples.

Chapter 1
ReactJS - Environment Setup
To kickstart your journey, we’ll begin by setting up the environment you
need for success in your React development. There are quite a few steps to
this, and the first one requires that you install Node.js, so that’s where we
begin.
Local Environment Setup
You are going to need two things on your computer to do this – a text editor
and the Installables for Node.js.
Text Editor
This is used for typing your programs, and there are several different ones
you can use, such as Windows Notepad, Brief, EMACS, Vi, Vim, OS edit
Command, and many more. The one you use will depend on your operating
system, for example, if you use Windows, you will likely use Notepad or Vi
or Vim, while Linux users would stick with Vi or Vim.
When you create a file using the editor, it is known as a source file and is
where your program code is stored. Node.js source files typically have the .js
extension.
Before you start programming, ensure you have a text editor in place first.
Make your choice and follow the download instructions on the editor’s
website if you need to install one. Also, be sure you have sufficient
programming experience – this book is not for those who have no experience.
Node.js Runtime
When you write your source code in the source file, it is written in
JavaScript, and the Node.js interpreter reads, interprets, and executes the
code. Node.js is a binary installation for Linux, SunOS, macOS, and
Windows, both 32-bit and 64-bit architectures.

Download Node.js Archive
Download the newest version of the file from http://nodejs.org/download/ for
your specific operating system.
macOS/Linux/Unix/SunOS
Download the file and open it on your computer. Extract the archive node file
called (osname).tar.gz into /tmp. Move the files from there to a directory
named  /usr/local/nodejs. Here’s an example:
$ cd /tmp
$ wget http://nodejs.org/dist/v6.3.1/node-v6.3.1-linux-x64.tar.gz
$ tar xvfz node-v6.3.1-linux-x64.tar.gz
$ mkdir -p /usr/local/nodejs
$ mv node-v6.3.1-linux-x64/* /usr/local/nodejs
Now add /usr/local/nodejs/bin to your PATH environment variable using one
of the commands below, depending on your OS:
Linux - export PATH=$PATH:/usr/local/nodejs/bin
Mac - export PATH=$PATH:/usr/local/nodejs/bin
FreeBSD - export PATH=$PATH:/usr/local/nodejs/bin
Windows
Download the MSI file and follow the on-screen prompts to get Node.js on
your system. The installer should use the default option of C:\Program
Files\node.js to install the file and set the bin directory (C:\Program
Files\nodejs\bin) in the Path environment variable for you. If you have open
command prompts, restart them so the changes can take effect.
Verifying the Installation
Create a new file and name it main.js. Then add the code below to it:
/* Hello, World! program in node.js */
console.log("Hello, World!")
Use the Node.js interpreter to execute the file using this command:
$ node main.js
You should see the following on your screen:
Hello, World!

Once Node.js is installed and working, React can be installed on it using
npm. There are two ways to do this:
With Webpack and Babel
With the create-react-app command
With Webpack and Babel
Webpack manages independent modules and loads them and is commonly
known as a module bundler. It compiles dependent modules into one bundle,
a singles file, and this can be used during your app development in two ways
– call it using the command line or use webpack.config to configure it.
Babel compiles and transpiles JavaScript and is used for converting a source
code into another one. This allows you to use the EC6 code features because
Babel will convert it to EC5, which any browser can use.
Step One – Creating the Root Folder
Create a new folder and call it reactApp. This is where all the required files
will be installed with the mkdir command:
C:\Users\username\Desktop>mkdir reactApp
C:\Users\username\Desktop>cd reactApp
Creating a module requires that the package.json file is generated so, once
your folder is created, create another file called package.json. To do this, run
the following npm init command at the command prompt:
C:\Users\username\Desktop\reactApp>npm init
That command is asking for module information, like author, description,
package name and so on. You can avoid all this by using the -y option, like
this:
C:\Users\username\Desktop\reactApp>npm init -y
Written to C:\reactApp\package.json:
{
"name": "reactApp",
"version": "1.0.0",
"description": "",
"main": "index.js",
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1"
},
"keywords": [],

"author": "",
"license": "ISC"
}
Step Two – Installing React and react dom
We are trying to install ReactJS along with all its dom packages, and we do
that with two npm commands – install react and react-dom. Use the –save
option to add these packages to the package.json file:
C:\Users\Username\Desktop\reactApp>npm install react --save
C:\Users\Username\Desktop\reactApp>npm install react-dom --save
Alternatively, use one single command to install and save everything:
C:\Users\username\Desktop\reactApp>npm install react react-dom –save
Step Three – Installing Webpack
Because webpack is being used to generate the bundler, we need to install
here things – webpack, webpack-dev-server, and webpack-cli:
C:\Users\username\Desktop\reactApp>npm install webpack --save
C:\Users\username\Desktop\reactApp>npm install webpack-dev-server --save
C:\Users\username\Desktop\reactApp>npm install webpack-cli --save
Or use one command to install everything:
C:\Users\username\Desktop\reactApp>npm install webpack webpack-dev-server webpack-
cli --save
Step Four – Installing Babel
Now we want babel installed, along with the relevant plugins:
C:\Users\username\Desktop\reactApp>npm install babel-core --save-dev
C:\Users\username\Desktop\reactApp>npm install babel-loader --save-dev
C:\Users\username\Desktop\reactApp>npm install babel-preset-env --save-dev
C:\Users\username\Desktop\reactApp>npm install babel-preset-react --save-dev
C:\Users\username\Desktop\reactApp>npm install html-webpack-plugin --save-dev
Or use one command to install them all:
C:\Users\username\Desktop\reactApp>npm install babel-core babel-loader babel-preset-env 
babel-preset-react html-webpack-plugin --save-dev
Step Five – Creating the Files
To finish, more files need to be created and these can be created manually or
by using the command prompt. These are the required files:
C:\Users\username\Desktop\reactApp>type nul > index.html
C:\Users\username\Desktop\reactApp>type nul > App.js

C:\Users\username\Desktop\reactApp>type nul > main.js
C:\Users\username\Desktop\reactApp>type nul > webpack.config.js
C:\Users\username\Desktop\reactApp>type nul > .babelrc
Step Six – Setting the Compiler, Server, and Loaders
Open the file called webpack-config.js and add in the code below. What this
does is set main.js as the webpack entry point. The output path is where the
bundled app is served, and the development server is also being set as 8001
port, although you can choose whatever port you want.
webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
entry: './main.js',
output: {
path: path.join(__dirname, '/bundle'),
filename: 'index_bundle.js'
},
devServer: {
inline: true,
port: 8001
},
module: {
rules: [
{
test: /\.jsx?$/,
exclude: /node_modules/,
loader: 'babel-loader',
query: {
presets: ['es2015', 'react']
}
}
]
},
plugins:[
new HtmlWebpackPlugin({
template: './index.html'
})
]
}
Open package.json and delete the following from the Scripts object:
“test” “echo” \ “Error: no test specified\” && exit 1”
We delete this because we don’t intend to test anything right now.
Instead, we can add two more commands – start and build:
"start": "webpack-dev-server --mode development --open --hot",

"build": "webpack --mode production"
Step Seven – Index.html
This is nothing more than standard HTML and div id =  “app” is being set as
the app’s root element. We also add the bundled app file, index_bundle.js:
<!DOCTYPE html>
<html lang = "en">
<head>
<meta charset = "UTF-8">
<title>React App</title>
</head>
<body>
<div id = "app"></div>
<script src = 'index_bundle.js'></script>
</body>
</html>
Step Eight − App.jsx and main.js
Now we want to add the first of our React components – we’ll delve into
these in detail later but, for now, this one is going to render Hello World:
App.js
import React, { Component } from 'react';
class App extends Component{
render(){
return(
<div>
<h1>Hello World</h1>
</div>
);
}
}
export default App;
We also need to import another component, rendering it to the root app
element. This allows us to see it in a browser:
main.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App.js';
ReactDOM.render(<App />, document.getElementById('app'));
NOTE:
Be aware that you always have to import anything you want to use and, if
you want it usable in a different part of the app, it has to be exported once

created and then imported again into the new location.
Create a new file and call it .babelrc. Add the following code to it:
{
"presets":["env", "react"]
}
Step Nine – Run the Server
Now your setup is finished, the server can be started using the command
below:
C:\Users\username\Desktop\reactApp>npm start
It shows the port that must be opened in the browser, in this case,
http://localhost:8001/. Once it is opened, you will see something like this:
Step Ten – Generate the Bundle
Lastly, we want to generate the bundle, and that requires the build command
being run from the command prompt:
C:\Users\Username\Desktop\reactApp>npm run build
The bundle is generated in the current folder, like this:

The create-react-app Command
If you don’t want to use babel and webpack, there is another, simpler way of
installing ReactJS – using the create-react-app command.
Step One – Installing create-react-app
Install this using the following command:
C:\Users\Username>cd C:\Users\Username\Desktop\
C:\Users\Username\Desktop>npx create-react-app my-app
A folder called my-app is created and placed on your desktop, and all
required files are created with it.
Step Two – Deleting Source Files
Open the my-app folder and look through the src folder. Delete the following
files from it:
C:\Users\Username\Desktop>cd my-app/src
C:\Users\Username\Desktop\my-app\src>del *
C:\Users\Username\Desktop\my-app\src\*, Are you sure (Y/N)? y
Step Three – Adding Files
Add two files into the src folder – index.css and index.js:
C:\Users\Username\Desktop\my-app\src>type nul > index.css
C:\Users\Username\Desktop\my-app\src>type nul > index.js
Add the code below to the index.js file:

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
Step Four – Running It
Lastly, use the start command to run it:
npm start
You should see something like this:
That completes the setup, so we will delve into ReactJS a little deeper by
looking at JSX.

Chapter 2
Introducing React JSX
Look at this variable declaration:
const element = <h1>Hello, world!</h1>;
It looks a bit odd, and you might be wondering whether it is HTML or a
string. Well, it’s neither.
This syntax is an extension to JavaScript called JSX and, although you don’t
have to, it is recommended that you use it with ReactJS to help describe how
the user interface looks. JSX might look and feel like a template language,
but, believe me, it has all the power and might of JavaScript behind it.
It produces react elements, and shortly we will look at how to render them to
the DOM. First, though, a look at the fundamentals of JSX.
Why Use JSX?
React makes a big thing of the fact that logic rendering has an inherent
relationship with other logic in the user interface. That includes event
handling, changes to the state over time, and preparing data for display.
Rather than the technologies being artificially separated by using separate
files or logic and markup, React separates the concerns using components,
nothing than units with loose coupling, which contain both logic and markup.
We’ll discuss components in a later chapter, but this section will give you a
good overview of what to expect.
As I said, you don’t have to use JSX with React, but it is a helpful visual aid
when you work in the JavaScript code with UI. And using it lets React show
you some pretty useful warning messages and error messages.
Now you know what it’s all about, let’s dive into JSX.

How to Embed Expressions in JSX
In the simple example you see below, a variable called name is declared and
then wrapped in a pair of curly brackets so it can be used inside JSX:
const name = 'John Philips';const element = <h1>Hello, {name}</h1>;
ReactDOM.render(
element,
document.getElementById('root')
);
So long as a JavaScript expression is valid, it can be placed in curly brackets
for use in JSX. For example, 5 + 7, formatName(user), and user.FirstName
are valid expressions in JavaScript.
In the next example, we call a JavaScript function called formatName(user)
and embed the result in an <h1> element:
function formatName(user) {
return user.firstName + ' ' + user.lastName;
}
const user = {
firstName: 'Harry',
lastName: 'Philips'
};
const element = (
<h1>
Hello, {formatName(user)}!  </h1>
);
ReactDOM.render(
element,
document.getElementById('root')
);
JSX is split over several lines to make it more readable. Although you don’t
need to do this, it is recommended that you wrap it all in parentheses, so you
steer clear of the problems of automatic semicolon insertion. I won’t go into
that here – if you have knowledge of JavaScript, you have already come
across it.
JSX is an Expression
When JSX expressions have been compiled, they turn into regular function
calls  and can be evaluated to JavaScript objects.  This means JSX can be
used inside for loops and if statements; it can be assigned to a variable,
returned from a function and accepted as an argument too. Here’s an

example:
function getGreeting(user) {
if (user) {
return <h1>Hello, {formatName(user)}!</h1>;  }
return <h1>Hello, Stranger.</h1>;}
Specifying Attributes with JSX
String literals can be specified as attributes by using quote marks, like this:
const element = <div tabIndex="0"></div>;
Curly brackets can also be used for embedding JS expressions in attributes:
const element = <img src={user.avatarUrl}></img>;
When you embed a JS expression inside an attribute, do not place quote
marks around the curly brackets. Quote marks should be used around strings,
and curly braces should be used around expressions, but you should never use
both in one attribute.
WARNING
JSX is nearer to JavaScript than it is HTML and, because of this, the
camelCase naming convention is used by React DOM rather than HTML
attribute names.
For example, tabindex will change to tabIndex, and class will change to
className.
How to Specify Children with JSX
If you have an empty tag, it can be closed straight away using />, just like
you do in XML:
const element = <img src={user.avatarUrl} />;
JSX tags can have children in them:
const element = (
<div>
<h1>Hello!</h1>
<h2>Great to see you here.</h2>
</div>
);

Preventing Injection Attacks with JSX
User input can safely be embedded in JSX:
const title = response.potentiallyMaliciousInput;
// This is safe:
const element = <h1>{title}</h1>;
React DOM will escape values that have been embedded in JSX by default
before it renders them. As such, it means there is no way of injecting
anything not explicitly coded in your application. Everything gets converted
into a string before it is rendered, helping stop cross-site-scripting (XSS)
attacks.
JSX Represents Objects
JSX is compiled down to React.createElement() calls by Babel. Here are two
identical examples:
const element = (
<h1 className="greeting">
Hello, world!
</h1>
);
const element = React.createElement(
'h1',
{className: 'greeting'},
'Hello, world!'
);
Some checks are performed by React.createElement(), helping you write
code that is free of bugs, but essentially, what it does is creates objects like
this:)
// Note: this is a simplified structure
const element = {
type: 'h1',
props: {
className: 'greeting',
children: 'Hello, world!'
}
};
These are React elements, and you could think of them as a way of describing
what we want on the screen. These elements or objects are read by React and
used to construct and keep the DOM up to date.
TIP

Use the Babel language definition your editor supplies to ensure that ES6 and
JSX code are highlighted properly.
Helpful Hints
While this has just been a brief overview of JSX, if you feel you need a
simple primer on what it is and how to use it, keep these helpful hints in
mind:
Never see JSX as a template. Instead, see it as an alternative to
the standard JavaScript syntax that needs to be compiled. For
example, JSX converts XML-like markup to JavaScript.
The Babel tool helps transform ES code and JSX syntax into ES5
code.
JSX is completely separate from React. It will not try complying
with HTML or XML specifications; it is designed as a feature of
ECMAScript, and any similarity to XML or HTML is purely at
the surface – it looks like HTML or XML, making it easy to
write something that feels familiar.
<foo-bar /> is valid in JSX, while <foo-bar> isn’t. Remember, all
tags have to be closed.
Here is JSX summed up in four helpful points:
The required sections can be understood and modified by less
technical users. CSS designers and developers are more likely to
find JSX more familiar than just JavaScript – for example,
HTML markup looks exactly like HTML markup.
JavaScript’s full power can be leveraged in HTML, avoiding the
need to learn and use template languages. The one thing JSX is
not is a template language; it is a syntax that makes it easier to
express UI components in a tree structure.
When you add a JSX transformation step, you can see HTML
errors that you may well have missed before.
JSX strongly recommends inline styles.

There are also some JSX Gotchas that you really need to beware of:
While JSX looks much like HTML, you must remember that there are
important differences:
HTML Entities
HTML entities can be inserted inside literal text in JSX:
<div>First &middot; Second</div>
If you want HTML entities displayed in dynamic content, you are likely to
face double escaping problems. React will escape every string on display by
default to stop XSS attacks.
// Bad: It displays "First &middot; Second"
<div>{'First &middot; Second'}</div>
You can get around this in a few ways, and the easiest is to put the Unicode
character in JS. Ensure that you save the file as UTF-8 and set the proper
UTF-8 directives; otherwise the browser will not be able to display it
properly.
<div>{'First · Second'}</div>
Perhaps a better, safer way is to find the right Unicode character for the entity
and add that into a string:
<div>{'First \u00b7 Second'}</div>
<div>{'First ' + String.fromCharCode(183) + ' Second'}</div>
Mixed arrays can be used with JSX elements and strings.
<div>{['First ', <span>&middot;</span>, ' Second']}</div>
And, as an absolute last resort, raw HTML can be inserted:
<div dangerouslySetInnerHTML={{__html: 'First &middot; Second'}} />
Custom HTML Attributes
If properties are passed to native HTML elements that are not in the HTML
specification, they will not be rendered by React. Custom attributes can be
used, but they must be prefixed with data-:
<div data-custom-attribute="foo" />
If you start your web accessibility attributes with aria-, they will be properly

rendered.
<div aria-hidden={true} />

Chapter 3
All About Components
React allows you to define components as functions or classes and those
defined as a class have plenty of useful features. First, defining a React
component class required the React.Component to be extended:
class Welcome extends React.Component {
render() {
return <h1>Hello, {this.props.name}</h1>;
}
}
A React.Component subclass must have at least one method defined in it.
While most we discuss in this chapter are optional, you must define the
render() method.
One thing I must caution you against doing is creating base component
classes of your own. React components reuse code via composition and not
by inheritance.
NOTE
You are not forced to use ES6 class syntax in React. If you want, you can use
something like the create-react-class module instead.
The Component Lifecycle
Every React component has a number of lifecycle methods. These can be
overridden at certain times during the process to run code.  Here, we are
going to talk about these methods, the most common of which are in bold
text. The rest are rarely used, but you still need to have knowledge of them.
Mounting
Mounting lifecycle methods are called in the order listed below when a
component instance is created and put into the DOM:
constructor()

static getDerivedStateFromProps()
render()
componentDidMount()
NOTE
The UNSAFE_componentWillMount() method is a legacy method and must
not be placed into new code. We’ll talk more about legacy methods later.
Updating
Changes to state or props can cause updates and the following is the order
these methods are called in when we re-render a component:
static getDerivedStateFromProps()
shouldComponentUpdate()
render()
getSnapshotBeforeUpdate()
componentDidUpdate()
NOTE
The following methods are legacy and should not be placed in new code:
UNSAFE_componentWillUpdate()
UNSAFE_componentWillReceiveProps()
Unmounting
This method is called when a component is being removed from the DOM:
componentWillUnmount()
Error Handling
Error handling methods are called when an error occurs during the rendering
process, in a child component’s constructor or a lifecycle method:

static getDerivedStateFromError()
componentDidCatch()
Other APIs
Every component has other APIs:
setState()
forceUpdate()
Class Properties
defaultProps
displayName
Instance Properties
props
state
Commonly Used Lifecycle Methods
In this section, we are going to go over most of the cases you are likely to
encounter when you create React components.
render()
This is the only method that MUST be in the class component. When the
render90 method is called, it examines this.state and this.props and returns
one of the types listed below:
React Element. These are usually created using JSX. For
example, one component used for telling React it needs to render
a DOM mode is <div />, while <MyComponent /> is used to
instruct React to rend a different user-defined component.
Fragments and Arrays. These allow you to return several
elements from render.

Portals. These allow you to render children to other DOM
subtrees.
Numbers and Strings. Both are rendered in the DOM as text
nodes.
Null or Booleans. These do not render anything and are mostly
there to support the test && <Child /> pattern when test is a
Boolean.
This is one function that must be pure. That means it will never modify any
component state, it will never interact directly with the browser, and, when
invoked, it will always return the same result.
If you need browser interaction, use componentDidMount() or another
lifecycle method to do your work in. When render() is kept pure, other
components are easier to work with.
NOTE
If shouldComponentUpdate() comes back as false, render() doesn’t get
invoked.
constructor()
constructor(props)
If state is not initialized and the methods are not bound, your React
component does not need a constructor implemented on it.
React component constructors are called before being mounted. When a
React.Component subclass constructor is implemented, super(props) should
be called first before any other statement is called. If this doesn’t happen,
this.props will not be defined in the constructor, resulting in errors and bugs
in the code.
Normally, constructors are only used in React for two reasons:
To initialize the local state – this is done when an object is
assigned to this.state
To bind an event handler method to an instance

One thing you should never call in the constructor is setState(). If a local state
is required by the component, the initial state should be assigned directly to
this.state in the constructor:
constructor(props) {
super(props);
// Never call this.setState() here!
this.state = { counter: 0 };
this.handleClick = this.handleClick.bind(this);
}
The only place this.state should be directly assigned is in the constructor. In
the other methods, this.setState() should be used instead.
Try not to let any subscriptions or side-effects get into the constructor; in use
cases where that is likely, you should use componentDidMount() instead.
NOTE
Do NOT make the common mistake of copying a prop into state:
constructor(props) {
super(props);
// Never do this!
this.state = { color: props.color };
}
There are two reasons you should not do this – one, it really isn’t necessary
(this.props.color()   can be used directly instead) and, two, it does nothing
more than create bugs as any color prop updates don’t get reflected in the
state.
This pattern should only be used if you are intentionally ignoring the prop
updates. Then, you would want to give the prop another name, something like
defaultColor or initialColor. After that, the component can be forced to
change its key when needed, retting its internal state.
componentDidMount()
This is invoked straight after mounting a component or inserting it into the
tree. Any initialization requiring DOM nodes needs to go here and, if you
need remote endpoint data loaded, this would be the best place for the
network request to be instantiated.
It is also a great place for setting up subscriptions but you mustn’t forget to
use componentWillUnmount to unsubscribe.

setState() can be immediately called in componentDidMount(), triggering
extra rendering. However, this happens before the screen is updated by the
browser, guaranteeing that the user never sees the intermediate state, although
we call render() twice.
This pattern must be used cautiously because it can result in problems with
performance. Most of the time, the initial state can be assigned in the
constructor() but, where you have tooltips and modals and DOM nodes need
measuring before measuring something dependent on position or size, the
pattern can be used.
componentDidUpdate()
componentDidUpdate(prevProps, prevState, snapshot)
Once updating has occurred, componentDidUpdate() is immediately invoked.
However, it will never be called for initial rendering. This should be used to
carry out operations on the DOM after updating a component and is also a
great place for network requests so long as the current and previous props are
compared. For example, some network requests won’t be necessary if there
hasn’t been a change to the props.
componentDidUpdate(prevProps) {
// Typical use (you must compare props):
if (this.props.userID !== prevProps.userID) {
this.fetchData(this.props.userID);
}
}
setState() may be immediately called in componentDidUpdate(), but it has to
be wrapped, like you see above, in a condition. If it isn’t, an infinite loop will
occur along with extra re-rendering – the user won’t see this, but it will have
an effect on the component’s performance. If you want a state mirrored to a
prop that comes from above, use that prop directly.
If you are using your component to implement getSnapShotBefore Update,
which isn’t really likely, it will return the value as a third parameter for
componentDidUpdate(); otherwise, that parameter remains undefined.
NOTE
If shoudComponentUpdate() returns a false value, componentDidUpdate()
won’t be invoked.

componentWillUnmount()
Right before a component gets unmounted and then destroyed, 
componentWillUnmount() is invoked. Use this method to do any clean-up
necessary – this can include canceling any network requests, cleaning
subscriptions you created inside componentDidMount, invalidating any
timers, and other similar tasks.
setState() must not be called in componentWillUnmount(). The component
can never be re-rendered, and any unmounted component cannot be mounted
again.
Lifecycle Methods Rarely Used
The methods we look at here don’t tend to be used much. Sure, they come in
useful now and again,  but most components you use will not need them.
shouldComponentUpdate()
shouldComponentUpdate(nextProps, nextState)
This should be used to tell React that the output from a component does not
get affected by current changes in props or state. By default, every state
change should be re-rendered on, and this is preferable to using the
shouldComponentUpdate() method in most cases.
When a new state or props are received, this method gets invoked before
rendering, and its default is true. It will never be called when forceUpdate() is
used or the initial render.
You should never rely on using this method to prevent renderings as it
usually results in bugs; it is purely there for optimizing performance. Instead
of using shouldComponentUpdate(), consider PureComponent. First, it is a
built-in method and easily called, and second, it doesn’t require you to
handwrite it in. PureComponent lets us perform shallow comparisons of state
and prop, reducing the chances of missing an important update.
If, however you want to write it in, you can use it to compare this.state with
nextState and this.props with nextProps and get false returned, which tells
React to skip the update. Note – if false is returned, it doesn’t stop the re-
rendering of child components where their state is changed.

You should also not use jSON.stringify() or do any deep equality checks in
shoudlComponentUpdate() as it isn’t efficient, and it can hurt performance.
At the time of writing, if false is returned by shouldComponentUpdate() then
render(), UNSAFE_ComponentWillUpdate() and componentDidUpdate() are
not invoked. It is hoped that, in the future shouldComponentUpdate() will be
treated as a hint by React, and not as a directive and that, should it return
false, the component may be re-rendered.
static getDerivedStateFromProps()
static getDerivedStateFromProps(props, state)
This method gets invoked immediately before render() is called, not just on
the initial mount but on all subsequent updates. One of two things should be
returned – an object that updates the state or null, which won’t update
anything.
This method is only used in rare cases where the state is dependent on props
changes over time. For example, it is useful for when you want a
<Transition> component implemented where the component compares the
previous children to the next to determine which should be animated in or
out.
When you derive the state, it makes your code somewhat verbose and makes
components even harder to think about, so you need to consider the simple
alternatives:
If a side effect is needed, i.e., animation or data fetching, as a
response to a change in props, the componentDidUpdate
lifecycle is better.
If you need data recomputed ONLY when there are changes to a
prop, a memorization helper would be more useful
If a state needs to be reset ONLY when a prop changes, think
about using a key to make a component fully uncontrolled or
fully controlled.
The static getDerivedStateFromProps also cannot access the component

instance. You can reuse code between the method and whatever other class
methods are available – this requires extraction of pure functions of the state
and props outside the definition of the class.
Be aware that this method gets fired on ALL renders, irrespective of the
cause. By contrast, UNSAFE_componentWillReceiveProps will only fire
when a re-render is caused by the parent, not by a local setState.
getSnapshotBeforeUpdate()
getSnapshotBeforeUpdate(prevProps, prevState)
This will be invoked immediately before the output rendered the most
recently is committed, for example, to the DOM. Using it lets the component
get information from the DOM before any potential changes, and any value
the lifecycle returns is passed to componentDidUpdate() as a parameter.
This isn’t a common use case, but it might happen in some UIs, such as chat
threads, that need the scroll position handled in a special manner.
Whenever you use this, you should get null or a snapshot value returned. For
example:
class ScrollingList extends React.Component {
constructor(props) {
super(props);
this.listRef = React.createRef();
}
getSnapshotBeforeUpdate(prevProps, prevState) {
// Is a new item being added to the list?
// Capture the scroll position so we it can be adjusted later.
if (prevProps.list.length < this.props.list.length) {
const list = this.listRef.current;
return list.scrollHeight - list.scrollTop;
}
return null;
}
componentDidUpdate(prevProps, prevState, snapshot) {
// If we see a snapshot value, we know new items have been added.
// Adjust scroll, so they don’t push the old items out of the view.
// (Her, the snapshot is the returned value from getSnapshotBeforeUpdate)
if (snapshot !== null) {
const list = this.listRef.current;
list.scrollTop = list.scrollHeight - snapshot;
}
}

render() {
return (
<div ref={this.listRef}>{/* ...contents... */}</div>
);
}
}
These examples illustrate how important it is to read the scrollHeight
property from getSnapshotBeforeUpdate as there could be some delay
between the commit and render lifecycle phases.
Error Boundaries
An error boundary is a component that can catch a JavaScript error, no matter
where it is in the child component tree. It can also catch the error and come
up with a replacement UI instead of the one that crashed. These boundaries
catch errors in lifecycle methods, rendering, and constructors from the entire
tree below the boundary.
Class components become error boundaries when they define one or both of
the 
lifecycle 
methods 
– 
componentDidCatch() 
or 
static
getDerivedStateFromeRROR. When the state is updated from either lifecycle,
you can catch unhandled errors in the tree below and show a replacement UI.
You should never use an error boundary to control flow, only to recover from
an unexpected exception.
NOTE
An error boundary can only catch an error in the tree components below
them; they cannot catch errors within themselves.
static getDerivedStateFromError()
static getDerivedStateFromError(error)
This is invoked once a descendant component has thrown an error. The
method take the error as a parameter and the value it returns should update
state:
class ErrorBoundary extends React.Component {
constructor(props) {
super(props);
this.state = { hasError: false };
}

static getDerivedStateFromError(error) {    // Update state so the next render can show
replacement UI.    return { hasError: true };  }
render() {
if (this.state.hasError) {      // Any custom replacement UI can be rendered     return
<h1>Something went wrong.</h1>;    }
return this.props.children;
}
}
NOTE
The method is only called in the render phase, so you cannot use side effects.
If you need to, you should consider using componentDidCatch().
componentDidCatch()
componentDidCatch(error, info)
This will be invoked once a descendant component has thrown an error, and
it will take two parameters:
1. error – this is the thrown error
2. info – this is an object that has a componentStack key detailing
which component the error was thrown by
It is called in the commit phase, so you can use side effects. It is best used to
log errors and other similar tasks:
class ErrorBoundary extends React.Component {
constructor(props) {
super(props);
this.state = { hasError: false };
}
static getDerivedStateFromError(error) {
// Update state so the next render shows replacement UI.
return { hasError: true };
}
componentDidCatch(error, info) {    // Example "componentStack":    //   in
ComponentThatThrows (created by App)    //   in ErrorBoundary (created by App)    //   in
div (created by App)    //   in
App    logComponentStackToMyService(info.componentStack);  }
render() {
if (this.state.hasError) {
// Any custom replacement UI can be rendered
return <h1>Something went wrong.</h1>;
}
return this.props.children;
}

}
There are slight differences in how the development and production React
builds handle errors in componentDidCatch(). The development build shows
errors 
bubbling 
up 
to 
the 
window, 
meaning 
that 
any
window.addEventListener(‘error’, callback) or window.onerror can intercept
any errors componentDidCatch() catches.
These errors don’t bubble up on the production build, so ancestor error
handlers can only receive those errors componentDidCatch() didn’t explicitly
catch.
NOTE
Should an error occur, a replacement UI can be rendered with
componentDidCatch(). Right now, you can do this by calling setState(), but
this is expected to be deprecated in the near future so get used to using static
getDerivedStateFromError instead.
Other APIs
The lifecycle methods discussed above are called by React but the following
methods can be called by you in your components. There are two:
setState()
forceUpdate()
setState()
setState(updater, [callback])
This method will enqueue any component state changes, telling React to re-
render the component and children with the new state. This would be your
go-to for updating the UI as a response to server responses and event
handlers.
setState() could be thought of as a request to update the component and not a
command. React may delay this request if it thinks it can improve on
performance by updating multiple components in one go. There is no
guarantee that state changes will be immediately applied.
The downside of this is that if you read this.state() right after you call

setState(), it may not reflect the requested changes. You should use a setState
caller, such as setState(updater, callback)) or componentDidUpdate, as both
of these will immediately make the requested change. If the state needs to be
set based on the previous one, refer to the information on the updater
argument later in this section.
When you use setState() it will always result in a re-render if
shouldComponentUpdate() return true. If you are using mutable objects and
you 
cannot 
implement 
conditional 
rendering 
logic 
in
shouldComponentUpdate(), you can avoid un-needed re-renders by only
calling setState() when the new and previous states differ.
setState() takes two parameters or arguments. The first is an updater function
containing the signature:
(state, props) => stateChange
State references the component state as the change is applied. It should never
be mutated directly; instead, you should represent the changes by building
another object based on the props and state input.
For example, let’s say we want to use props.step to increment a state value:
this.setState((state, props) => {
return {counter: state.counter + props.step};
});
The props and state the updater function gets are guaranteed as being up-to-
date, and the updater output is merged with state shallowly.
Parameter two is an optional one. It is a callback function only executed
when setState has finished, and the component has been re-rendered.
Typically, componentDidUpdate() is better for this kind of logic.
Instead of a function, you also have the option of passing an object as the first
setState() argument:
setState(stateChange[, callback])
This will do a shallow merge of the new state and stateChange, for example,
if you need to change an entry in a shopping cart.
this.setState({quantity: 4})

This is an asynchronous form of setState(), and if several calls are made in
the same cycle, they can be batched. For example, if you wanted a shopping
cart quantity increased more than once during the cycle, that would be the
equivalent of:
Object.assign(
previousState,
{quantity: state.quantity + 1},
{quantity: state.quantity + 1},
...
)
Any calls after that will override the previous call’s values in the same cycle,
thus increasing the quantity just once. Where the next state is dependent on
the current one, you should use the updater function form:
this.setState((state) => {
return {quantity: state.quantity + 1};
});
forceUpdate()
component.forceUpdate(callback)
When the state or props in a component change, re-rendering occurs.  If the
render() method is dependent on other data, you should call forceUpdate() to
instruct React to re-render the component.
When you call forceUpdate(), render() is automatically called on the
component and shouldComponentUpdate() will be skipped over. This
triggers the child component’s standard lifecycle methods, including each
child’s shoudComponentUpdate() method. However, unless the markup
changes, DOM will not be updated by React.
You should try not to use forceUpdate() where possible and only read from
this.state and this.props in the render() method.
Class Properties
defaultProps
We can define default Props as a component class property to set the class’s
default props. We shouldn’t use this for null props, but we can use it on
undefined props. Here’s an example:

class CustomButton extends React.Component {
// ...
}
CustomButton.defaultProps = {
color: green
};
If you do not provide props.color, it will default to ‘green’.
render() {
return <CustomButton /> ; // props.color is set to green
}
And, if you set props.color to null, that is how it will stay:
render() {
return <CustomButton color={null} /> ; // props.color will stay as null
}
displayName
This string is used to debug messages, but it doesn’t normally need to be
explicitly set as the name of the class or function defining the component will
infer it. However, if you want a different name displayed for the purpose of
debugging, you can set it explicitly, as well as when a higher-order
component is created. We’ll be discussing those in more detail later in the
book.
Instance Properties
Props
Inside this.props, you can see the props defined by the component’s called.
We’ll be delving into props in a future chapter, but this is a just a brief look.
Specifically, this.props.children is special, usually defined by the JSX
expression’s child tags and not in the tag itself.
state
This contains component-specific data that can change over time. It is a user-
defined state and it should be a standard JavaScript object. If a value is not
used for data flow or rendering, it doesn’t have to go into the state; instead, it
can be defined as a component instance field. We’ll discuss this a little more
later, when we look at Sate and Lifecycle
One thing to remember – this.state should never be mutated directly as, if you
call setState afterward, it could replace your mutation. Always treat this.state
as immutable.

Chapter 4
State and Lifecycle
This chapter will briefly introduce you to the concept of React component
state and lifecycle. Let’s dive right in.
Consider we have an example of a ticking clock. If you want to play along,
create a new file, name it what you want, and add this code to it:
function tick() {
const element = (
<div>
<h1>Hello, world!</h1>
<h2>It is {new Date().toLocaleTimeString()}.</h2>
</div>
);
ReactDOM.render(element, document.getElementById('root'));
}
setInterval(tick, 1000);
What we want to do is make our clock component encapsulated and reusable,
so it sets its own timer and, every second, it will update itself.
The first thing we do is encapsulate the clock’s looks:
function Clock(props) {
return (
<div>      <h1>Hello, world!</h1>      <h2>It is {props.date.toLocaleTimeString()}.
</h2>    </div>  );
}
function tick() {
ReactDOM.render(
<Clock date={new Date()} />,    document.getElementById('root')
);
}
setInterval(tick, 1000);
Something crucial is missing, though – all of this, the Clock setting a timer
and the UI being updated every second should all be implementation details.
So, what we want to do is write this just once and make it, so the clock
updates itself:

ReactDOM.render(
<Clock />,  document.getElementById('root')
);
Implementation requires “state” to be added to the clock component. State is
much like props, which we’ll talk about later, but it’s private, and the
components control it.
Converting Functions to Classes
A function component such as Clock can be converted into a class in just five
steps:
1. An ES6 class is created with an identical name ad extending
React.Component
2. An empty method called render() is added to the class
3. The function body is moved into render()
4. Props are replaced with this.props in the body of render()
5. The empty function declaration that remains is deleted:
class Clock extends React.Component {
render() {
return (
<div>
<h1>Hello, world!</h1>
<h2>It is {this.props.date.toLocaleTimeString()}.</h2>
</div>
);
}
}
Now we have defined Clock as a class and not a function.
Whenever an update occurs, render() is called. But, so long as <Clock /> is
rendered into the same DOM node, just one Clock class instance is used,
allowing it to use local state, lifecycle methods, and other useful features.
Add Local State to a Class
It is a three-step process to take the date out of props and into state:
Step One

The first step is to make a replacement in render() – this.props.date is
replaced with this.state.date.
class Clock extends React.Component {
render() {
return (
<div>
<h1>Hello, world!</h1>
<h2>It is {this.state.date.toLocaleTimeString()}.</h2>      </div>
);
}
}
Step Two
Next a class constructor is added to assign the first this.state:
class Clock extends React.Component {
constructor(props) {
super(props);
this.state = {date: new Date()};  }
render() {
return (
<div>
<h1>Hello, world!</h1>
<h2>It is {this.state.date.toLocaleTimeString()}.</h2>
</div>
);
}
}
Note that props were passed to the base constructor:
constructor(props) {
super(props);    this.state = {date: new Date()};
}
The base constructor should always be called with props by the class
component.
Step Three
The last step is the take the date prop out of the <Clock /> element:
ReactDOM.render(
<Clock />,  document.getElementById('root')
);
Later, the timer code will be added back into the component.
This is what the result looks like:
class Clock extends React.Component {

constructor(props) {    super(props);    this.state = {date: new Date()};  }
render() {
return (
<div>
<h1>Hello, world!</h1>
<h2>It is {this.state.date.toLocaleTimeString()}.</h2>      </div>
);
}
}
ReactDOM.render(
<Clock />,  document.getElementById('root')
);
Next, we will get the Clock to set its time and update every second:
Add Lifecycle Method to the Class
If your application has tons of components, one of the most important things
to do is free up some of the resources used by the destroyed components.
What we need to do is ensure that, every time the Clock gets rendered for the
first time to the DOM, a timer is set up. In React, this is known as mounting. 
We also want to ensure that the timer is cleared when the Clock-produce
DOM is removed. In React, this is known as unmounting.
Whenever a component is mounted and unmounted, we want special methods
to be declared in the component class so some code runs:
class Clock extends React.Component {
constructor(props) {
super(props);
this.state = {date: new Date()};
}
componentDidMount() {  }
componentWillUnmount() {  }
render() {
return (
<div>
<h1>Hello, world!</h1>
<h2>It is {this.state.date.toLocaleTimeString()}.</h2>
</div>
);
}
}
These are known as lifecycle methods.
Once the component output is rendered to the DOM, componentDidMount()
will run, making this a good spot to set the timer up in:

componentDidMount() {
this.timerID = setInterval(      () => this.tick(),      1000    );  }
Note that the timer ID was saved on this.timerID.
So, React sets up this.props, and this.state has some special meaning, but you
can still add other fields manually to the class, especially if you want
something stored that doesn’t have a particular role to play in the data flow,
such as this.timerID.
We’ll use the lifecycle method called componentWillUnmount to tear the
timer down.
componentWillUnmount() {
clearInterval(this.timerID);  }
Lastly, a method is implemented called tick() and this will be run every
second by the clock component. It will schedule updates to the local state of
the component using this.setState().
class Clock extends React.Component {
constructor(props) {
super(props);
this.state = {date: new Date()};
}
componentDidMount() {
this.timerID = setInterval(
() => this.tick(),
1000
);
}
componentWillUnmount() {
clearInterval(this.timerID);
}
tick() {    this.setState({      date: new Date()    });  }
render() {
return (
<div>
<h1>Hello, world!</h1>
<h2>It is {this.state.date.toLocaleTimeString()}.</h2>
</div>
);
}
}
ReactDOM.render(
<Clock />,
document.getElementById('root')
);

Now our clock will tick on every second.
Let’s have a quick recap of what happened and the method order:
1. <Clock /> is passed into ReactDOM.render(). The Clock
component’s constructor is called by React. Clock must show the
current time, so this.state is initialized with an object that
includes the current time. This state will be updated later.
2. The render() method in the Clock component is then called by
React, telling React what it means to be shown on the screen.
Then, the DOM is updated by React to match the render output
of Clock.
3. The tick() method is called by the browser every second and,
inside the method, a UI update is scheduled by the Clock
component. It does this by calling setState() using an object that
has the current time. React uses the call to setState() to know that
the state has changed. The render() method is called to find out
what should be displayed and, this time, the render() method’s
this.state.date is different, and the updated time will be included
in the render output. The DOM is updated accordingly by React.
4. If 
the 
Clock 
component 
is 
taken 
from 
the 
DOM,
componentWillUnmount() is called by React, stopping the timer.
Correctly Using State
There are three important things about setState() you should know:
The state should not be directly modified
In the following example, a component will not be re-rendered:
// Wrong
this.state.comment = 'Hello';
Instead, setState() should be used:
// Correct
this.setState({comment: 'Hello'});
The constructor is the only place where this.state can be assigned.

State updates can be asynchronous
React can potentially put several setState() calls into one update for better
performance. However, because it is possible for this.state and this.props to
be asynchronously updated, you never rely on the values they provide to
calculate the next state.
For example, the counter might not be updated by this code:
// Wrong
this.setState({
counter: this.state.counter + this.props.increment,
});
Fixing it requires another setState() form, this one accepting functions and
not objects. The function’s first parameter is the previous state, and the
second is the props at the exact time the update gets applied.
// Correct
this.setState((state, props) => ({
counter: state.counter + props.increment
}));
The arrow function has been used here, but regular functions work just as
well.
// Correct
this.setState(function(state, props) {
return {
counter: state.counter + props.increment
};
});
State updates get merged
When setState() is called, the object is merged by React into the current state.
For example you may have a number of independent variables in your state:
constructor(props) {
super(props);
this.state = {
posts: [],      comments: []    };
}
Then you can use separate setState() calls to independently update them:
componentDidMount() {
fetchPosts().then(response => {
this.setState({

posts: response.posts      });
});
fetchComments().then(response => {
this.setState({
comments: response.comments      });
});
}
This 
is 
shallow 
merging 
so 
this.state.posts 
is 
left 
intact 
by
this.setState({comments}) but this.state.comments is replaced.
Data Flows Down
Parent and child components cannot know if a specific component is stateless
or stateful, and it shouldn’t make any difference to them if a component is
defined as a class or a function.
This is why you often see state as encapsulated or local – the only component
that can access it is the one that owns the state and sets it.
Components have the option of passing their state as props to child
components:
<FormattedDate date={this.state.date} />
The component called FormattedDate takes the date in its props, but it
doesn’t know whether the data comes from the Clock’s props, state or if it
was input by hand.
function FormattedDate(props) {
return <h2>It is {props.date.toLocaleTimeString()}.</h2>;
}
This is known as a unidirectional or top-down data flow. A state is always
owned by a component. Any UI or data the state derives has the potential to
affect the components lower in the tree.
Imagine a component tree as being a “waterfall” of props. The state for each
component is another source of water joining it at a point but flowing down.
Creating an app component to render three <Clock>s will show us that all the
components are isolated:
function App() {
return (
<div>

<Clock />      <Clock />      <Clock />    </div>
);
}
ReactDOM.render(
<App />,
document.getElementById('root')
);
Each individual clock will set its timer and independently update.
In any React app, whether a components is stateless or stateful is seen as a
component’s implementation detail that can change over time. Stateless
components may be used in a stateful component and vice versa.

Chapter 5
ReactJS Props and PropTypes
Are you confused by props and PropTypes? Many people are and, in this
chapter, I aim to tell you what you need to know – the first thing is that they
can make life incredibly easy for you when you develop React apps.
When you build a React application, you break the UI down into multiple
components, with the implication that data is being passed from one to
another, and props are a critical part of that.
Understanding Props
In React, props are used to pass information between components and,
because there are multiple components in React, props allow us to share data
between the components that need it. It uses unidirectional flow, which
means the data goes from the parent to the child component but using a
callback function lets us go in the opposite direction.
Data comes in several formats – strings, numbers, functions, arrays, objects,
and so on. Props can be passed to any component in the same way as
attributes can be declared in HTML codes. Have a look at this example:
<PostList posts={postsList} />
Here, we have passed a prop called posts to a component called PostList. The
prop’s value is {postsList}.
Let’s look at how data is accessed and passed.
Passing And Accessing Props
Start by creating an application with a list of user names and posts. The app
will have several components – App, PostList, and Post. The post list will
need certain data, like content and user name, and the data can be constructed
like this:

const postsList = [
{
id: 1,
content: "Soon, the pandemic will be over",
user: "Laura Lyle",
},
{
id: 2,
content: "I'm so excited to be getting married",
user: "Julie Jones",
},
{
id: 3,
content: "What do you think of the pandemic",
user: "Simon Stevens",
},
{
id: 4,
content: "Is the world coming to an end",
user: "Mark David",
},
];
Now the App component needs to pull in the data and the component looks
like this:
const App = () => {
return (
<div>
<PostList posts={postsList} />
</div>
);
};
An array of posts is passed to PostList as a prop (we’ll create PostList
shortly.) The parent component is PostList, and it accesses data in postsList.
This data is then passed to Post, which is the child component, as posts props.
Remember, I said there were three components in the app, and we will create
them as we go.
First, the PostList:
class PostList extends React.Component {
render() {
return (
<React.Fragment>
<h1>Latest Users Posts</h1>
<ul>
{this.props.posts.map((post) => {
return (
<li key={post.id}>
<Post {...post} />

</li>
);
})}
</ul>
</React.Fragment>
);
}
}
The PostList component takes a prop of posts. Then it loops through
this.props.posts, returning posted items as Post components. We also used a
key in this code, a unique identifier given to each list item that helps
distinguish between them. We’ll talk more about keys in a later chapter but,
for now, the key is post ID, and no two items can have the same one.
The rest of the properties are then passed to the Post component <Post{…
post} /> as props. So, now we need to create that Post component so we can
use the props in it:
const Post = (props) => {
return (
<div>
<h2>{props.content}</h2>
<h4>username: {props.user}</h4>
</div>
);
};
The Post component is being constructed as a functional component, and not
a class component like PostList was. We did it this way to demonstrate how
props are accessed in a functional component compared to accessing them in
a class component using this.props. In a functional component, props can be
used to access values.
Now you know how to pass props and access them and how information is
passed between components, we need to look at using props with functions.
Passing Functions Via Props
In the last bit, we looked at passing data arrays between components as props,
but what if it were functions we were working with instead? React also
allows functions to pass between components too, and this is useful when we
want a state change triggered in a parent component by its child component. 
Props are meant to be immutable, which means you shouldn’t try changing
their values. That has to be done in the component passing the prop down,
and that is the parent component.

To see this in action, we’ll create an app that changes the app’s state when
listening to a click event. For an app state to be changed in a different
component, the function must be passed down to the component whose state
needs changing. By doing this, we get a function that can change state inside
the child component.
Does that sound complicated?  Try the code below – it will provide a piece of
useful information on the screen using two components. The first is App, and
this is the parent component with the state and function used for setting the
state. The second is ChildComponent, designed to render the info on the
screen when the state changes:
class App extends React.Component {
constructor(props) {
super(props);
this.state = {
isShow: true,
};
}
toggleShow = () => {
this.setState((state) => ({ isShow: !state.isShow }));
};
render() {
return (
<div>
<ChildComponent isShow={this.state.isShow} clickMe={this.toggleShow} />
</div>
);
}
}
We set the state to true and created the method for changing the state in the
App component. The state of the app is passed in render() and the prop called
isShow to the component called ChildComponent. Lastly, the function called
toggleShow() is passed to clickMe as a prop.
This is going to be used in ChildComponent, which looks like:
class ChildComponent extends React.Component {
clickMe = () => {
this.props.clickMe();
};
render() {
const greeting = "Welcome to React Props";
return (
<div style={{ textAlign: "center", marginTop: "8rem" }}>
{this.props.isShow ? (
<h1 style={{ color: "green", fontSize: "4rem" }}>{greeting}</h1>
) : null}

<button onClick={this.clickMe}>
<h3>click Me</h3>
</button>
</div>
);
}
}
What is most important from this is that a function is passed by the App
component as a prop to ChildComponent. The clickMe() function is used in
the ChildComponent as a click handler, but ChildComponent has no idea
what the function’s logic is – it merely waits for the button to be clicked and
then triggers the function. When the function is called, the state changes, after
which the state gets passed down once more as a prop. Any affected
components will then render again.
The app state, isShow, is passed to the ChildComponent as a prop – without
it, the logic cannot be written to show the right greeting after the state is
updated.
Time to look at validating props, and this is done using PropTypes.
What Are React PropTypes?
PropTypes make sure that the correct data types are used by the components
and that the right data is passed. They also make sure the correct prop type is
used by the components and that the components that receive also get the
right prop types.
Think of it as a kitten going to a pet store. The store doesn’t want snakes, or
tigers, or horses; it wants kittens. PropTypes make sure that the right data
type (kitten) is delivered and not another type of animal.
We’ve already seen how to use props to pass information to components. The
props were passed directly as attributes, and they were also passed in and
used from outside the component. What we didn’t do is check the value types
going into the component through the props, and we didn’t check that
everything worked.
It’s down to us whether we validate the data a prop passes to a component
but, where you are working with complex applications, data validation is
always a good idea.

It’s totally upon us whether to validate the data we get in a component
through props. But in a complex application, it is always a good practice to
validate that data.
Using PropTypes
Using PropTypes requires that the package is added to the application as a
dependency. This is done with the following code, using npm:
npm install --save prop-types
First, PropTypes must be imported from the package called prop-types:
import PropTypes from 'prop-types';
We’ll use PropTypes in the app we created earlier to list user posts. Here it is
being used on the Post component:
Post.proptypes = {
id: PropTypes.number,
content: PropTypes.string,
user: PropTypes.string
}
There 
are 
two 
prop 
validators 
here 
– 
PropTypes.number 
and
PropTypes.string. These are used to ensure the right type of props is received.
In the above code, id was declared as a number, and user and content were
declared as strings.
PropTypes are also helpful to catch bugs and passing props can be enforced
by using isRequired:
Post.proptypes = {
id: PropTypes.number.isRequired,
content: PropTypes.string.isRequired,
user: PropTypes.string.isRequired
}
There are lots of validators in PropTypes and these are the more common
ones:
Component.proptypes = {
stringProp: PropTypes.string,         // The prop is a string
numberProp: PropTypes.number,         // The prop is a number
anyProp: PropTypes.any,               // The prop may be any data type
booleanProp: PropTypes.bool,          // The prop is a function
functionProp: PropTypes.func          // The prop is a function
arrayProp: PropTypes.array            // The prop is an array
}

Default Props
If we have default information that we want to pass to the components using
props, we can use defaultProps. Where a PropType doesn’t use isRequired it
is classed as optional, and defaultProps can be set in these, ensuring there are
values for the props should nothing be passed. Here’s an example:
Class Profile extends React.Component{
// Specifies default values for props
static defaultProps = {
name: 'Stranger'
};
// Renders "Welcome, Stranger":
render() {
return <h2> Welcome, {this.props.name}<h2>
}
}
In this, defaultProps ensures a value for this.props.name, just in case the
parent component doesn’t specify it. If the class called Profile does not have
a name passed to it, it will have a default property of Stranger. This stops
errors from occurring when a prop isn’t passed.
Best practice says that you should use defaultProps for all optional
PropTypes.

Chapter 6
ReactJS Forms
Forms are one of the most important parts of web applications built in React.
They are what lets app users input data and submit it on login screens,
checkout screens, and so on.  Most applications built in React are SPAs
(single page applications) or web apps with just one page where new data is
dynamically displayed. That means, because information cannot be directly
submitted to the server from the form, it is captured client-side and sent using
another JS code.
These forms are unique in the challenge they present – either the browser
handles the majority of elements on the form, using React change events to
collect the data, or React controls the element fully by directly setting the
input value and updating it. The first way is known as an uncontrolled
component because React has no part to play in setting values, while the
second is a controlled component, purely because React is active in updating
any input.
In this chapter, we are going to complete an app that uses forms and form
submissions to submit requests to purchase oranges. Along the way, you will
discover the advantages of using uncontrolled and controlled components,
along with the disadvantages. You will also learn how to set form properties
dynamically to enable fields and disable them based on the form state.
Step One – Use JSX to Create a Basic Form
The first step is to create an empty form using JSX. It must have one element
and a submit button. The form submit event will be handled, and the data
passed to a different service and, by the end of step one, your form will be
able to pass data to asynchronous functions.
First, open the App.js component:
nano src/components/App/App.js

We want to build a form that lets us buy oranges, so create a <div> and give
it a className called <wrapper>. Give it an <h1> tag that contains the text
“Look At Those Oranges!” and also give it an empty form element. You do
this with the code below:
import React from 'react';
import './App.css';
function App() {
return (
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
<form>
</form>
</div>
)
}
export default App;
Now, in <form> tag, you need a <fieldset> element and this needs an <input>
element inside a <label> tag. When you wrap the <input>element in a
<label> element, you help users reading the screen because the label and
input are associated – this also makes your application more accessible.
Lastly, a submit <button> needs to be added at the bottom of your form:
import React from 'react';
import './App.css';
function App() {
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
<form>
<fieldset>
<label>
<p>Name</p>
<input name="name" />
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)
}
export default App;
Save your file and close it. Now open App.css so you can set up the styling:
nano src/components/App/App.css

Now add some padding to .wrapper and add margin to the fieldset. This will
provide space between the elements. 
.wrapper {
padding: 5px 20px;
}
.wrapper fieldset {
margin: 20px 0;
}
Save the file and close it; your browser reloads, and a basic form appears on
the screen, saying “Look At Those Oranges!” with a submit button beneath it.
Click the Submit button, and the page reloads. Because this is a single page
application, the standard button behavior is prevented with a type=”submit”
so, instead, the submit event will be handled inside the component:
First, open App.js:
nano src/components/App/App.js
Now an event handler needs to be added to the <form> element, not <button>
as you might think. Create a function and call it handleSubmit – it will take
an argument of SyntheticEvent, which wraps around the Event object and has
an identical interface. By calling .preventDefault, you can stop the form being
submitted by the page and trigger an alert confirming the form submission:
import React from 'react';
import './App.css';
function App() {
const handleSubmit = event => {
event.preventDefault();
alert(‘The form is submitted.')
}
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
<form onSubmit={handleSubmit}>
<fieldset>
<label>
<p>Name</p>
<input name="name" />
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)

}
export default App;
Again, save your file, and the browser reloads. Click the submit button, and
you will get an alert telling you the form was submitted – the window doesn’t
reload.
Lots of React applications require you to send data to external services, such
as a Web API. When the service has been resolved, a success message may
be shown, or you may direct the user elsewhere, or you can do both.
Simulating an API requires that the setTimeout function is added to the
handleSubmit function, resulting in an asynchronous operation that waits a
specified time before it completes – this is similar to how an external data
request behaves. Then the useState Hook is used to create two things – a
submitting variable with a setSubmitting function. When the data is
submitted, call setSubmitting(true) and, when the timeout has been resolved,
setSubmitting(false) is called.
import React, { useState } from 'react';
import './App.css';
function App() {
const [submitting, setSubmitting] = useState(false);
const handleSubmit = event => {
event.preventDefault();
setSubmitting(true);
setTimeout(() => {
setSubmitting(false);
}, 3000)
}
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
{submitting &&
<div>Submitting Form...</div>
}
<form onSubmit={handleSubmit}>
<fieldset>
<label>
<p>Name</p>
<input name="name" />
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)

}
export default App;
You will also display a short HTML message that tells the user their form is
being submitted when submitting is true.
Save your file, the browser reloads, and press submit – your message is
displayed.
You now have a basic form that can handle the submit event within a React
component. It uses the onSubmit event handler to connect to your JSX, and
hooks are used to display alerts when the handleSubmit event runs.
In step two, we’ll be adding some more user inputs and learning how the data
is saved to state while the form is being completed by the user.
Step Two – Using Uncontrolled Components to Collect Form
Data
Now we are going to use uncontrolled components to collect form data.
These are components where the value is not set by React. Rather than the
data being set on the component, the onChange event is connected to for
collecting user input. As the components are built, you will learn how
different input types are handled by React and how to collect form data into
one object using a reusable function.
At the end of step two, you will know how to build forms using different
elements, such as checkboxes and dropdowns.  You will also know how to
collect form data, submit and display it.
NOTE
Most of your React applications will be built using controlled components
but starting with uncontrolled components lets you understand them and learn
how to avoid bugs and accidental loops that might get introduced when a
value is incorrectly set.
Right now, you have a form that submits information, but we don’t have
information to submit. There is one input <element> in the form, but data is
not being collected or stored in the component. To do this and be able to
process data on a user-submitted form,  you need a way of managing state,

and then each input needs to be connected to with an event handler.
Open App.js again and create a formData object with a setFormData function
by using the useReducer hook. The reducer function needs the name and the
value pulled from the event.target object. Then the state must be updated –
the current state is spread while the name and value are added at the end. This
will result in a state object being created to preserve while specific values are
overwritten as they change:
import React, { useReducer, useState } from 'react';
import './App.css';
const formReducer = (state, event) => {
return {
...state,
[event.target.name]: event.target.value
}
}
function App() {
const [formData, setFormData] = useReducer(formReducer, {});
const [submitting, setSubmitting] = useState(false);
const handleSubmit = event => {
event.preventDefault();
setSubmitting(true);
setTimeout(() => {
setSubmitting(false);
}, 3000)
}
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
{submitting &&
<div>Submitting Form...</div>
}
<form onSubmit={handleSubmit}>
<fieldset>
<label>
<p>Name</p>
<input name="name" onChange={setFormData}/>
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)
}
export default App;
Once you have made the reducer, setFormData needs to be added on the

input to the onChange event handler – this will cause the browser to reload. If
you tried typing the input in, you would get an error:
What causes this is that SyntheticEvent has been reused, and, as such, it can’t
be passed to any asynchronous function. In simple terms, the event cannot be
passed directly. Fixing this requires the data you need to be pulled out before
the reducer function is called.
The reducer function needs to be updated, so it takes an object with a name
and value property. A function called handleChange needs to be created to
pull data out of event.target and pass the object to setFormData. Lastly, the
onChange event handler needs to be updated so it can use the new function:
import React, { useReducer, useState } from 'react';
import './App.css';
const formReducer = (state, event) => {<^>
return {
...state,
[event.name]: event.value
}
}
function App() {
const [formData, setFormData] = useReducer(formReducer, {});
const [submitting, setSubmitting] = useState(false);
const handleSubmit = event => {
event.preventDefault();
setSubmitting(true);
setTimeout(() => {
setSubmitting(false);
}, 3000);
}

const handleChange = event => {
setFormData({
name: event.target.name,
value: event.target.value,
});
}
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
{submitting &&
<div>Submitting Form...</div>
}
<form onSubmit={handleSubmit}>
<fieldset>
<label>
<p>Name</p>
<input name="name" onChange={handleChange}/>
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)
}
export default App;
Save your file, the page refreshes and you can enter data.
As you are now collecting the form state, the user display message can be
updated to show an unordered list <ul> element with the data in it. Use
Object.entries to convert the data into an array, map over the data to convert
each array member to a <li> element, including name and value. Make sure
name is used as the element’s key prop.
...
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
{submitting &&
<div>
The following is being submitted
<ul>
{Object.entries(formData).map(([name, value]) => (
<li key={name}><strong>{name}</strong>:{value.toString()}</li>
))}
</ul>
</div>
}
<form onSubmit={handleSubmit}>
<fieldset>
<label>
<p>Name</p>

<input name="name" onChange={handleChange}/>
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)
}
export default App;
Again, save the file, the page will reload and you can enter data and submit it.
You now have a basic form, and more elements can be added to it. Create one
more <fiedlset> element and add to is a <select> element. This will contain
different orange varieties for each <option>, along with an <inout> that has a
type=”checkbox” for the option to gift wrap.
Each element needs the handleChange function added to the onChange event
handler:
...
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
{submitting &&
<div>
The following is being submitted:
<ul>
{Object.entries(formData).map(([name, value]) => (
<li key={name}><strong>{name}</strong>: {value.toString()}</li>
))}
</ul>
</div>
}
<form onSubmit={handleSubmit}>
<fieldset>
<label>
<p>Name</p>
<input name="name" onChange={handleChange}/>
</label>
</fieldset>
<fieldset>
<label>
<p>Oranges</p>
<select name="orange" onChange={handleChange}>
<option value="">--Please choose an option--</option>
<option value="seville">Seville</option>
<option value="andrew">Andrew</option>
<option value="blood-orange">Blood Orange</option>
</select>
</label>
<label>
<p>Count</p>

<input type="number" name="count" onChange={handleChange} step="1"/>
</label>
<label>
<p>Gift Wrap</p>
<input type="checkbox" name="gift-wrap" onChange={handleChange} />
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)
}
export default App;
Save your file, the page reloads and you see a series of input types for the
form.
You do need to take a special case into consideration – the gift wrapping
checkbox value must always be set to “on,” whether the item has been
checked or not. Rather than the event’s value, the checked property is
required instead.
The handleChange function needs to be updated to check if event.target.type
is a checkbox. If yes, the event.target.checked property must be passed as the
value rather than event.target.value:
import React, { useReducer, useState } from 'react';
import './App.css';
function App() {
const [formData, setFormData] = useReducer(formReducer, {});
const [submitting, setSubmitting] = useState(false);
const handleSubmit = event => {
event.preventDefault();
setSubmitting(true);
setTimeout(() => {
setSubmitting(false);
}, 3000);
}
const handleChange = event => {
const isCheckbox = event.target.type === 'checkbox';
setFormData({
name: event.target.name,
value: isCheckbox ? event.target.checked : event.target.value,
})
}
...
This code makes the conditional statement using the ? ternary operator.

Save the file, the browser will refresh and you can fill the form out and click
submit. The alert will match with the data from the form.
This step taught you how to create an uncontrolled form component, use the
useReducer Hook to save form data to a state and then reuse the data in other
components. You also added other form component types and changed the
function so the right data was saved based on the element type.
Next, we look at converting those components into controlled one by setting
the component value dynamically.
Step Three – Using Controlled Components to Update Form
Data
Now we’ll learn how to use controlled components to set data and update it
dynamically. A value prop will be added to each component to set the form
data or update it, and we will also look at how the form data is reset on
submit.
This step will teach you how to control form data dynamically with React
props and state.
When you use uncontrolled components, there is no need even to consider
synchronizing data because your application is always going to have the
recent changes. However, some situations will arise where you need to read
from an input component and write to it, and this requires the component to
have a dynamic value.
In the last step, a form was submitted, but even after a successful submission,
the original data was still on the form. The data needs to be erased for each
input, and that requires the components to be changed from uncontrolled to
controlled.
Controlled components are much the same as uncontrolled ones but with one
difference – the value prop is updated by React. This is convenient but, if you
are not careful in updating the value prop correctly, it will appear as if the
component is broken, and it won’t look as if it is updating.
In the form you created, data is already being stored, so converting the
components requires that the value prop is updated using data out of the

formData state. However, values must be defined; undefined values will
throw errors in the console.
Because you have an empty object for the initial state, the value must be set
as a formData value or an empty string, or some other default value. For
example, the name value would be formData.name || ”:
...
return(
<div className="wrapper">
<h1>Look At Those Oranges!</h1>
{submitting &&
<div>
The following is being submitted
<ul>
{Object.entries(formData).map(([name, value]) => (
<li key={name}><strong>{name}</strong>: {value.toString()}</li>
))}
</ul>
</div>
}
<form onSubmit={handleSubmit}>
<fieldset>
<label>
<p>Name</p>
<input name="name" onChange={handleChange} value={formData.name ||
''}/>
</label>
</fieldset>
<fieldset>
<label>
<p>Oranges</p>
<select name="orange" onChange={handleChange} value={formData.orange ||
''}>
<option value="">--Please choose an option--</option>
<option value="seville">Seville</option>
<option value="andrew">Andrew</option>
<option value="blood-orange">Blood Orange</option>
</select>
</label>
<label>
<p>Count</p>
<input type="number" name="count" onChange={handleChange} step="1"
value={formData.count || ''}/>
</label>
<label>
<p>Gift Wrap</p>
<input type="checkbox" name="gift-wrap" onChange={handleChange}
checked={formData['gift-wrap'] || false}/>
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)

}
export default App;
As in the last step, the checkbox is different. Rather than a value being set,
the checked attribute must be set. If it is truthy, the box is shown a checked in
the browser.  Use formData[‘gift-wrap’] || false for setting the initial checked
attribute.
If you want the form pre-filled, put some default data into the formData state,
Give count a default value by providing { count: 100 } to formState. You also
have the option of setting the initial object’s default values, but first, you
would need the falsy values filtered out before the form information was
displayed:
function App() {
const [formData, setFormData] = useReducer(formReducer, {
count: 100,
});
const [submitting, setSubmitting] = useState(false);
...
Save your file, the browser reloads, and the default data input will show on
the screen.
NOTE
Don’t confuse the value and placeholder attributes – the latter is browser-
native. The placeholder attribute will display information that changes as
soon as a user inputs new data – the old data is never stored. The value can be
actively edited but placeholders are nothing more than a guide for the users.
Now your components are active, the data can be cleared on submit. This
requires formReducer to be given a new condition. Where event.reset is
truthy, an object is returned for each form element and will contain empty
values. Make sure each input has a value. If an empty or incomplete object is
returned, the value is undefined and, as such, the component cannot update.
After the new event condition is added to formReducer, your submit function
can be updated so that, when the function is resolved, the state is reset:
import React, { useReducer, useState } from 'react';
import './App.css';
const formReducer = (state, event) => {
if(event.reset) {
return {

orange: '',
count: 0,
name: '',
'gift-wrap': false,
}
}
return {
...state,
[event.name]: event.value
}
}
function App() {
const [formData, setFormData] = useReducer(formReducer, {
count: 100
});
const [submitting, setSubmitting] = useState(false);
const handleSubmit = event => {
event.preventDefault();
setSubmitting(true);
setTimeout(() => {
setSubmitting(false);
setFormData({
reset: true
})
}, 3000);
}
...
Save your file and the browser reloads with the form clearing on submit.
This step taught you how to convert uncontrolled components into controlled
ones by dynamically setting the checked or value attributes. You also looked
at setting default states to refill data and updating formReducer to clear the
data and return default values.
In the last step we will look at dynamically forming component properties
and disabling forms while they are submitting.
Step Four – Update Form Properties Dynamically
Lastly, we will discover how to update the form element properties
dynamically. The properties are set based on some previous choices and
disable the form at submit to stop several submissions from being made.
Right now, the components are all static and don’t change as the form does.
Most applications have dynamic forms. Fields change, also based on previous

data, validating and showing errors. As other components are filled in, the
fields may expand or disappear.
Component properties and attributes can be set dynamically in most React
components and, as data changes, they re-render.
Have a go at setting an input, so it is disabled until another input meets a
specific condition. We’ll do this with the gift-wrapping checkbox – disable it
until the Seville option is picked by a user.
Open App.js and put the disabled attribute in the checkbox, making the
property truth when formData.orange is Seville:
...
<fieldset>
<label>
<p>Oranges</p>
<select name="orange" onChange={handleChange} value={formData.orange ||
''}>
<option value="">--Please choose an option--</option>
<option value="seville">\Seville</option>
<option value="andrew">Andrew</option>
<option value="blood-orange">Blood Orange</option>
</select>
</label>
<label>
<p>Count</p>
<input type="number" name="count" onChange={handleChange} step="1"
value={formData.count || ''}/>
</label>
<label>
<p>Gift Wrap</p>
<input
checked={formData['gift-wrap'] || false}
disabled={formData.orange !== 'seville'}
name="gift-wrap"
onChange={handleChange}
type="checkbox"
/>
</label>
</fieldset>
<button type="submit">Submit</button>
</form>
</div>
)
}
export default App;
Save the file, the browser reloads and by default, the checkbox is disabled. If
Seville is chosen as the orange type,  the element is enabled.

As well as changing an individual component’s properties, whole groups of
components can also be modified with an update to the fieldset component.
For example, the form could be disabled while active submission takes place.
This stops double – or more – submissions and stops the user from changing
any fields before handleSubmit has fully resolved.
To do this, disabled={submitting} should be added to each <fieldset> and
<button> element:
<form onSubmit={handleSubmit}>
<fieldset disabled={submitting}>
<label>
<p>Name</p>
<input name="name" onChange={handleChange} value={formData.name ||
''}/>
</label>
</fieldset>
<fieldset disabled={submitting}>
<label>
<p>Oranges</p>
<select name="orange" onChange={handleChange} value={formData.orange ||
''}>
<option value="">--Please choose an option--</option>
<option value="seville">Seville</option>
<option value="andrew">Andrew</option>
<option value="blood-orange">Blood Orange</option>
</select>
</label>
<label>
<p>Count</p>
<input type="number" name="count" onChange={handleChange} step="1"
value={formData.count || ''}/>
</label>
<label>
<p>Gift Wrap</p>
<input
checked={formData['gift-wrap'] || false}
disabled={formData.orange !== 'seville'}
name="gift-wrap"
onChange={handleChange}
type="checkbox"
/>
</label>
</fieldset>
<button type="submit" disabled={submitting}>Submit</button>
</form>
</div>
)
}
export default App;

For the last time, save your file, and the browser refreshes. When the form is
submitted, the fields are disabled until the submitting function has fully
resolved.
Any attribute on an input component can be updated, and this is useful where
maxvalue needs to be changed for number inputs, or dynamic pattern
attributes need to be added for validation.
In this last step, you learned how attributes are dynamically set on form
components. A property was added to enable or disable a component
dynamically based on another component’s input, and you also used the
<fieldset> component to disable whole sections.
Forms are a critical part of a rich web app, and React provides lots of options
to connect and control elements and forms. Properties can be dynamically
updated, and that includes value input elements. If you want simplicity, use
uncontrolled components but these are not suitable for every situation. Where
components need to be prepopulated with data or cleared, you should use
controlled components as they provide more opportunities for updating data.
They also allow you another abstraction level that could cause accidental re-
renders or bugs.
No matter which approach you choose, React lets you update and adapt your
forms dynamically to match the needs of your users and your applications.

Chapter 7
ReactJS Events
Most of an application’s behavior is based on events. Whenever a value is
entered by a user into a form, it’s an event. When a user clicks on a submit
button, it’s an event. Events can be triggered in lots of ways, and applications
are built to listen for these events so that they can do something else as a
response.
If you have experience with JavaScript, you are probably already comfortable
with events.  But React handles them in a different, somewhat distinct
manner. Instead of DOM events being targeted, they are wrapped in an event
wrapper – more about that in a bit. First, we need to look at creating, adding,
and listening for React events.
Creating Events
The first thing to do is create a form with an input and a button. When a value
gets entered, an event is triggered. The button calls a function to reverse the
value. Here’s how it works:
The user enters text into an empty input field
When a value is entered in the input, an onChange event gets
triggered, calling the handleChange function used for setting a
new input state
Another event gets triggered when the Reverse Text button gets
clicked. The handleReverse() function is called, setting a new
reversedText state.
Let’s see all that in a code:
class App extends React.Component {
state = {
/*  Initial State */
input: "",

reversedText: ""
};
/* handleChange() function to set a new input state */
handleChange = event => {
const value = event.target.value;
this.setState({
input: value
});
};
/* handleReverse() function that reverses input and sets it as a new reversedText state */
handleReverse = event => {
event.preventDefault();
const text = this.state.input;
this.setState({
reversedText: text
.split("")
.reverse()
.join("")
});
};
render() {
return (
<React.Fragment>
{ /* handleReverse() is called when the form is submitted */ }
<form onSubmit={this.handleReverse}>
<div>
{ /* Render input entered */}
<label>Text: {this.state.input}</label>
</div>
<div>
{ /* handleChange() is triggered when text is entered */ }
<input
type="text"
value={this.state.input}
onChange={this.handleChange}
placeholder="Enter a text"
/>
</div>
<div>
<button>Reverse Text</button>
</div>
</form>
{ /* Render reversed text */}
<p>Reversed Text: {this.state.reversedText}</p>
</React.Fragment>
);
}
}}
Listening To Component Events
Assume that you have a component that looks like this:
Let’s say you have a component like this;

class IncrementButton extends React.Component{
render() {
return (
<React.Fragment>
<button>+</button>
</React.Fragment>
)
}
}
If you added it into your App component, like this, will it work?
class App extends React.Component{
state = {
count: 0
}
handleIncrement = (event) => {
this.setState({ count: this.state.count + 1})
}
render() {
return(
<React.Fragment>
<h1>{this.state.count}</h1>
<IncrementButton onClick={this.handleIncrement} />
</React.Fragment>
)
}
}
No and the simple reason is, events can only be listened to on DOM
elements. And, as you learned earlier, DOM elements are wrapped in React
components which means that, to listen for an event, we need to pass through
another layer. We can get around this by passing the event handler to the
child component as a prop, and then passing the prop as an attribute to the
click event, like this:
class IncrementButton extends React.Component{
render() {
return (
<React.Fragment>
<button onClick={this.props.increaseButton}>+</button>
</React.Fragment>
)
}
}
class App extends React.Component{
state = {
count: 0
}
handleIncrement = (event) => {

this.setState({ count: this.state.count + 1})
}
render() {
return(
<React.Fragment>
<h1>{this.state.count}</h1>
<IncrementButton increaseButton={this.handleIncrement} />
</React.Fragment>
)
}
}
An alternative way would be to use a stateless functional component:
const IncrementButton = (props) => {
return (
<React.Fragment>
<button onClick={props.increaseButton}>+</button>
</React.Fragment>
)
}
Adding Event Listeners
On occasion, you may want to use specific DOM events that get triggered
after a component is mounted.  We can this in action with the resize event,
where we want to see what a window width is whenever it gets resized.
class App extends React.Component{
state = {
windowWith: window.innerWidth
}
handleResize = (event) => {
this.setState({ windowWith: window.innerWidth })
}
render() {
return(
<React.Fragment>
<h1>Window Width</h1>
<h1>{this.state.windowWith}</h1>
</React.Fragment>
)
}
}
If we went ahead and created a component and then tried like in the code
below, the event doesn’t get triggered. In this case, the handleResize() event
listener must be added, along with the event type:
class App extends React.Component{
state = {

windowWith: window.innerWidth
}
handleResize = (event) => {
this.setState({ windowWith: window.innerWidth })
}
componentDidMount() {
window.addEventListener('resize', this.handleResize)
}
componentDidUnmount() {
window.removeEventListener('resize', this.handleResize)
}
render() {
return(
<React.Fragment>
<h1>Window Width</h1>
<h1>{this.state.windowWith}</h1>
</React.Fragment>
)
}
}
Now, whenever the component is mounted, the event listener is added, which
means the component is listening actively to the browser window and,
whenever the width is updated, it will display the new value.
So, we learned that React wouldn't directly connect to a DOM event but to a
synthetic event – this is the React component wrapped around the DOM
event.  We also looked into how to create an event listener, attaching it to a
Synthetic Event and ensuring that, when the events are triggered, the
component updates. Now we need to look at handling events.
Handling Events
Although event handling with React elements is much the same as event
handling of DOM elements, there are a few differences in syntax:
camelCase is used for naming React events, not lowercase
in JSX, functions as passed as event handlers, not strings
Here’s an example of HTML:
<button onclick="activateLasers()">
Activate Lasers

</button>
Which is a little different from React:
<button onClick={activateLasers}>  Activate Lasers
</button>
There is one more difference – in React, you cannot prevent default behavior
by returning false; instead, preventDefault must be explicitly called. For
example,  when you are working in plain HTML, the following can be
written to stop the default link behavior, which is to open a new page:
<a href="#" onclick="console.log('The link was clicked.'); return false">
Click me
</a>
Written in React, this would look like:
function ActionLink() {
function handleClick(e) {    e.preventDefault();    console.log('The link was clicked.');  }
return (
<a href="#" onClick={handleClick}>      Click me
</a>
);
}
In this example, we have a synthetic event called e, and these types of events
are defined by React as per the W3C spec, which means they work cross-
browser. React events work a little differently than native events.
With React, addEventListener doesn’t typically need to be called when you
want listeners added to a DOM event once created. Instead, a listener is
provided at the time the element is first rendered.
When you use an ES6 class to define a component, it is common for event
handlers to be class methods. Take the Toggle component below, for
example. A button is rendered, allowing users to toggle between On and Off:
class Toggle extends React.Component {
constructor(props) {
super(props);
this.state = {isToggleOn: true};
// It is necessary to bind to ensure `this` works in the callback    this.handleClick =
this.handleClick.bind(this);  }
handleClick() {    this.setState(state => ({      isToggleOn: !state.isToggleOn    }));  }
render() {
return (
<button onClick={this.handleClick}>        {this.state.isToggleOn ? 'ON' : 'OFF'}

</button>
);
}
}
ReactDOM.render(
<Toggle />,
document.getElementById('root')
);
What you must be aware of is what this means in a JSX callback. By default,
JavaScript methods don’t get bound. So, if this.handleClick is not bound and
passed to onClick, when the function gets called, it will be undefined.
This behavior is not specific to React; it is the way JavaScript functions
work. If a method is referred to without () added to it, like onClick-
{this.handleClick}, the method should be bound.
If you find calling bind irritating, you can get around it in two ways. First, if
you make use of the public class fields syntax, which are experimental, class
fields can be used to bind a callback properly:
class LoggingButton extends React.Component {
// This syntax makes sure `this` is bound within handleClick.  // Warning: this is
*experimental* syntax.  handleClick = () => {    console.log('this is:', this);  }
render() {
return (
<button onClick={this.handleClick}>
Click me
</button>
);
}
}
By default, this syntax has been enabled in the Create React App.
The second way is this – if the class fields syntax isn’t being use, an arrow
function may be added to the callback:
class LoggingButton extends React.Component {
handleClick() {
console.log('this is:', this);
}
render() {
// This syntax makes sure `this` is bound within handleClick    return (      <button
onClick={() => this.handleClick()}>        Click me
</button>
);
}
}

However, there is a problem with this. Every time LoggingButton renders, a
different callback gets created. Most of the time, there is nothing wrong with
this but if the callback gets passed to lower components as a prop, the
components might do some additional rendering. Generally, we would
recommend that binding is done in the constructor or with the first method,
the class fields syntax – that will avoid this kind of issue with performance.
Passing an Argument to an Event Handler
It is common in loops to want an extra parameter passed to an event handler.
For example, if the row ID is id, either of these will work:
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
These are equivalent to one another and respectively use an arrow function
and Function.prototype.bind.
Both times, the e argument represents a React event and is passed after the ID
as an additional parameter. The arrow function means having to pass it
explicitly, but when you use bind, additional arguments are forwarded
automatically.

Chapter 8
ReactJS Refs
This chapter will look at why a framework designed for abstracting code
away from being manipulated by DOM leaves a backdoor wide open for
developers to get in.  Like a lot of the UI libraries, React gives a way of
rethinking views as the results of a component’s state, and that is a world
away from how applications are usually built.
When we start to learn these concepts, we find out just how easy simple
problems can be resolved, frontend problems that used to give us all sorts of
headaches. One of the benefits comes from the ability to use React and JSX,
two abstraction mechanisms we use for creating views rather than using
DOM spec methods.
What the React team did was something that the authors of all the libraries
should do – they gave us escape mechanisms, keeping the library open and
operations for situations other than those they were designed for, not to
mention situations that might not be compatible with the model.
Creating Refs
Those escape mechanisms are called refs but, although I’m going to show
you how they work, you really should avoid them if you can help it.
When we use a ref to obtain a node and then modify its DOM structure or an
attribute, conflict can arise with React’s update and diff approaches.  Later
we’ll take a look at anti-patterns but first, an example of a simple component
and using refs to grab node elements:
import React from 'react'
class ActionButton extends React.Component {
render() {
const { label, action } = this.props
return (
<button onClick={action}>{label}</button>

)
}
}
Here, the button expression is how JSX calls the statement called
React.createElement(‘button’). However, this is not an HTML Button
element representation; it is a React element.
Gaining access to the HTML element needs a React reference created and
then passed to the HTML element:
import React, { createRef } from 'react'
class ActionButton extends React.Component {
constructor() {
super()
this.buttonRef = createRef()
}
render() {
const { label, action } = this.props
return (
<button onClick={action} ref={this.buttonRef}>{label}</button>
)
}
}
By doing this, at any point in the component’s lifecycle, the HTML element
can be accessed at this.buttonRef.current.
But where do functions that act like components come in?
A recent release by the React team included Hooks that allow you to pair
with the features class shared by the components.
So,  now useRef can be imported for refs in the function components too:
import React, { useRef } from 'react'
function ActionButton({ label, action }) {
const buttonRef = useRef(null)
return (
<button onClick={action} ref={buttonRef}>{label}</button>
)
}
}
We know how DOM nodes can be accessed inside React components so let’s
see how this could be useful.

Using React Refs
React has expanded numerous concepts in the web sphere and one of these is
declarative views. Before these, we used to call functions to modify the DOM
explicitly.  As we mentioned at the start of the chapter, views are now
declared based on state, and, although functions are still called to alter the
state, we have no control over when or if the DOM will change.
This is called inversion of control and, if we didn’t use refs, we would lose
this imperative nature.  Here are some uses where refs can work in your code.
Focus Control
Focus can be achieved in an element programmatically. To do this, focus()
must be called on the node instance. DOM will expose this as a function call
so creating a ref and doing it manually when needed is the best way around
this.
import React from "react";
class InputModal extends React.Component {
constructor(props) {
super(props);
this.state = { value: props.initialValue };
}
onChange = e => {
this.setState({ value: e.target.value });
};
onSubmit = e => {
e.preventDefault();
const { value } = this.state;
const { onSubmit, onClose } = this.props;
onSubmit(value);
onClose();
};
render() {
const { value } = this.state;
return (
<div className="modal--overlay">
<div className="modal">
<h1>Insert a new value</h1>
<form action="?" onSubmit={this.onSubmit}>
<input
type="text"
onChange={this.onChange}
value={value}
/>
<button>Save new value</button>
</form>

</div>
</div>
);
}
}
export default InputModal;
This modal lets the user modify values that have already been set. If the input
were on focus at the time the modal opens, the user would have a much better
experience. Smooth keyboard transitions between the screens could be
enabled, and the first thing to do is get an input reference:
import React, { createRef } from "react";
class InputModal extends React.Component {
constructor(props) {
super(props);
this.inputRef = createRef();
this.state = { value: props.initialValue };
}
onChange = e => {
this.setState({ value: e.target.value });
};
onSubmit = e => {
e.preventDefault();
const { value } = this.state;
const { onSubmit, onClose } = this.props;
onSubmit(value);
onClose();
};
render() {
const { value } = this.state;
return (
<div className="modal--overlay">
<div className="modal">
<h1>Insert a new value</h1>
<form action="?" onSubmit={this.onSubmit}>
<input
ref={this.inputRef}
type="text"
onChange={this.onChange}
value={value}
/>
<button>Save new value</button>
</form>
</div>
</div>
);
}
}

export default InputModal;
When the modal mounts, focus is imperatively called on the input ref:
import React, { createRef } from "react";
class InputModal extends React.Component {
constructor(props) {
super(props);
this.inputRef = createRef();
this.state = { value: props.initialValue };
}
componentDidMount() {
this.inputRef.current.focus();
}
onChange = e => {
this.setState({ value: e.target.value });
};
onSubmit = e => {
e.preventDefault();
const { value } = this.state;
const { onSubmit, onClose } = this.props;
onSubmit(value);
onClose();
};
render() {
const { value } = this.state;
return (
<div className="modal--overlay">
<div className="modal">
<h1>Insert a new value</h1>
<form action="?" onSubmit={this.onSubmit}>
<input
ref={this.inputRef}
type="text"
onChange={this.onChange}
value={value}
/>
<button>Save new value</button>
</form>
</div>

</div>
);
}
}
export default InputModal;
Don’t forget; the element must be accessed via the current property.
Detect Contained Elements
In the same way, you may want to know if an element used to dispatch events
should create some kind of action on the application. As an example, the
Modal component could close if it is clicked outside of itself:
import React, { createRef } from "react";
class InputModal extends React.Component {
constructor(props) {
super(props);
this.inputRef = createRef();
this.modalRef = createRef();
this.state = { value: props.initialValue };
}
componentDidMount() {
this.inputRef.current.focus();
document.body.addEventListener("click", this.onClickOutside);
}
componentWillUnmount() {
document.removeEventListener("click", this.onClickOutside);
}
onClickOutside = e => {
const { onClose } = this.props;
const element = e.target;
if (this.modalRef.current
&& !this.modalRef.current.contains(element)) {
e.preventDefault();
e.stopPropagation();
onClose();
}
};
onChange = e => {
this.setState({ value: e.target.value });
};
onSubmit = e => {
e.preventDefault();
const { value } = this.state;
const { onSubmit, onClose } = this.props;

onSubmit(value);
onClose();
};
render() {
const { value } = this.state;
return (
<div className="modal--overlay">
<div className="modal" ref={this.modalRef}>
<h1>Insert a new value</h1>
<form action="?" onSubmit={this.onSubmit}>
<input
ref={this.inputRef}
type="text"
onChange={this.onChange}
value={value}
/>
<button>Save new value</button>
</form>
</div>
</div>
);
}
}
export default InputModal;
What we are doing here is looking to see if the element click is outside the
limits of the modal. If yes, we stop any further actions and call the callback,
onClose. This is because the Modal components expect their parent
components to control them.
Don’t forget to check the current DOM element reference still exists – React
state changes are asynchronous.
Achieving this requires a global click listener is added to the body element
but you must remember that, when an element is unmounted, the listener
must be cleaned.
Integration with DOM-Based Libraries
Although React is good, there are plenty of libraries and ecosystems outside
of it that have long been used on the web, and it makes perfect sense to take
advantage of how they can be used for certain problems.
One of the more popular libraries for animations is GreenSock, and using it
requires a DOM element to be sent to any GreenSock method. By using refs,
we can combine GreenSock and Ref so, going back to the modal we created

earlier, let’s add some animation to make it better:
import React, { createRef } from "react";
import gsap from "gsap";
class InputModal extends React.Component {
constructor(props) {
super(props);
this.inputRef = createRef();
this.modalRef = createRef();
this.overlayRef = createRef();
this.state = { value: props.initialValue };
const onComplete = () => {
this.inputRef.current.focus();
};
const timeline = gsap.timeline({ paused: true, onComplete });
this.timeline = timeline;
}
componentDidMount() {
this.timeline
.from(this.overlayRef.current, {
duration: 0.25,
autoAlpha: 0
})
.from(this.modalRef.current, {
duration: 0.25,
autoAlpha: 0,
y: 25
});
this.timeline.play();
document.body.addEventListener("click", this.onClickOutside);
}
componentWillUnmount() {
this.timeline.kill();
document.removeEventListener("click", this.onClickOutside);
}
onClickOutside = e => {
const { onClose } = this.props;
const element = e.target;
if (this.modalRef.current
&& !this.modalRef.current.contains(element)) {
e.preventDefault();
e.stopPropagation();
onClose();
}
};
onChange = e => {
this.setState({ value: e.target.value });
};
onSubmit = e => {
e.preventDefault();
const { value } = this.state;

const { onSubmit, onClose } = this.props;
onSubmit(value);
onClose();
};
render() {
const { value } = this.state;
return (
<div className="modal--overlay" ref={this.overlayRef}>
<div className="modal" ref={this.modalRef}>
<h1>Insert a new value</h1>
<form action="?" onSubmit={this.onSubmit}>
<input
ref={this.inputRef}
type="text"
onChange={this.onChange}
value={value}
/>
<button>Save new value</button>
</form>
</div>
</div>
);
}
}
export default InputModal;
At constructor level, the initial animation values are being set up, and these
modify our DOM reference styles. The timeline will only come into play
when the component is mounted.
When the element gets unmounted, the DOM state and actions are cleaned up
by using the kill() method to terminate running animations. The kill()method
comes from the Timeline instance.
Rule of Thumb for Using Refs
Now you know how refs work, it can be all too easy to use them when they
are not really needed. You can achieve something in a React component in
more than one way, and falling into an anti-pattern is so easy. When it comes
to using refs, a simple rule of thumb is to imperatively call functions when
you have a behavior React doesn’t let you have control over.
An easier way to explain it is this – a function needs to be called, and the
function is not associated with any React artifact or method. Here’s a short
example of a common anti-pattern:
import React, { createRef } from 'react';

class Form extends React.Component {
constructor(props) {
super(props)
this.inputRef = createRef()
this.state = { storedValue: '' }
}
onSubmit = (e) => {
e.preventDefault()
this.setState({ storedValue: this.inputRef.current.value })
}
render() {
return (
<div className="modal">
<form action="?" onSubmit={this.onSubmit}>
<input
ref={this.inputRef}
type="text"
/>
<button>Submit</button>
</form>
</div>
)
}
}
This approach works, to be fair, when you need a value sent on submit.
The big issue is this – when we know that a ref is an escape mechanism from
the view model in React, we are looking into the values or properties of
DOM elements that we can access via the React interface.
When we control the value of an input, we always have a way of checking its
value:
render() {
const { value } = this.state
return (
<input
type="text"
onChange={e => this.setState({ value: e.target.value })}
value={value}
/>
)
}
So, back to the rule of imperatively calling functions for behaviors you
cannot control. We have an uncontrolled input, and we create a ref in it

without imperatively calling it. The function exists, but it isn’t satisfied as
you have control over the input value.
Forwarding Refs
We now know that refs are useful in some situations, but the examples we
used in this chapter are simple compared to what you would find in the
codebase for a modern web application.
Today, components are a lot more complex, and we rarely directly use plain
HTML elements. What is more common is to have one or more nodes
included in the code, encapsulating logic around the behavior of the view:
import React from 'react'
const LabelledInput = (props) => {
const { id, label, value, onChange } = props
return (
<div class="labelled--input">
<label for={id}>{label}</label>
<input id={id} onChange={onChange} value={value} />
</div>
)
}
export default LabelledInput
Now we have another issue. If we pass this component a ref, we get a React
component reference returned and not the input element we want. Thankfully,
there is a native solution for this in React, and it’s called forwardRef. These
allow you to define what element the ref is being pointed at internally.
import React from 'react'
const LabelledInput = (props, ref) => {
const { id, label, value, onChange } = props
return (
<div class="labelled--input">
<label for={id}>{label}</label>
<input id={id} onChange={onChange} value={value} ref={ref}/>
</div>
)
}
export default React.forwardRef(InputCombo)
Achieving this requires a second argument to be passed to the function and
put inside the relevant element. When a ref value is now passed by a parent

component, the input is obtained. This is useful for avoiding a situation
whereby component properties and internals are exposed, breaking the
encapsulation.
Now, the form example that failed to achieve focus will now work as it
should.
When you use the interface to access the DOM, the library maintains the
React internals in place. If you break the model using anti-patterns, it can
make it difficult to create bugs or make performance improvements.
You should only use refs when making an implicit function call that React
cannot handle using its own methods. And you must make sure they do not
change your component’s internal states.

Chapter 9
ReactJS Lists and Keys
When it comes to developing a website’s user interface, lists are very useful
as they are used to display website menus, like the navigation bar menu.
Standard JS uses arrays to create lists, and it is very similar to React. We’ll
look at that in detail shortly but first, a quick look at how lists are traversed
and updated in standard JS. For traversing, we can use the map() function, as
you see in the code below:
<script type="text/javascript">
var numbers = [1,2,3,4,5];
const updatedNums = numbers.map((number)=>{
return (number + 2);
});
console.log(updatedNums);
</script>
Running that code will provide the following output:
[3, 4, 5, 6, 7]
Let’s try creating a list of elements in ReactJS. The list numbers from the
above code will be rendered in the browser as an unordered list element
instead of having to log into the console. We will use the JS map() function
to traverse the list and the elements we want updated will be enclosed
between the <li> </li> elements. Lastly, the new list will be wrapped in <ul>
</ul> elements and rendered to the DOM.
Here’s what that will look like:
import React from 'react';
import ReactDOM from 'react-dom';
const numbers = [1,2,3,4,5];
const updatedNums = numbers.map((number)=>{
return <li>{number}</li>;
});
ReactDOM.render(

<ul>
{updatedNums}
</ul>,
document.getElementById('root')
);
This code will out an unordered list, as you can see below:
Rendering Lists in Components
In the React code above, the list was rendered directly to the DOM, but this is
not good React practice. We already know that everything in React is an
individual component. Think about a Navigation menu on a website – it
should be pretty obvious that navigation menu items are not hard-coded on
any website. Instead,  these items get fetched from a database and shown in
the browser as lists. From the point of view of a component, we could say
that a list is passed, using props, to the component. The list then gets rendered
to the DOM using the component. The code above could be updated so that a
component takes an array as props and an unordered list is then returned:
import React from 'react';
import ReactDOM from 'react-dom';
// Component that returns an
// unordered list
function Navmenu(props)
{
const list = props.menuitems;

const updatedList = list.map((listItems)=>{
return <li>{listItems}</li>;
});
return(
<ul>{updatedList}</ul>
);
}
const menuItems = [1,2,3,4,5];
ReactDOM.render(
<Navmenu menuitems = {menuItems} />,
document.getElementById('root')
);
And the output will look like this:
While the unordered list is rendered successfully to the browser, you will see
an error message on the console, saying:
Warning: Each child in an array or iterator should have a unique "key" prop
This warning message is telling us that our list items need unique keys – one
each. A key is a string attribute that must be included when lists of elements
are created in React. We’ll cover keys a bit later. For now, we want a string
key assigned to each item in the list in the code above:
Here is the updated code:
import React from 'react';
import ReactDOM from 'react-dom';

// Component that returns an
// unordered list
function Navmenu(props)
{
const list = props.menuitems;
const updatedList = list.map((listItems)=>{
return(
<li key={listItems.toString()}>
{listItems}
</li>
);
});
return(
<ul>{updatedList}</ul>
);
}
const menuItems = [1,2,3,4,5];
ReactDOM.render(
<Navmenu menuitems = {menuItems} />,
document.getElementById('root')
);
We get the same output from this code as we did the previous one, but we
don’t get the warning message this time. In React, keys are used as a way of
identifying which elements of a list have changed, been deleted, or been
updated. In other words, keys provide each element with its own identity.
All About Keys
So, we know that keys are string attributes needed for creating React lists.
They are used to identify changes in list elements so, the next thing we need
to consider is what to use as a key for the list items. Best practice
recommends using strings to give each element its own identity. In the next
example, you can see a list with strings used as keys:
const numbers = [ 1, 2, 3, 4, 5 ];
const updatedNums = numbers.map((number)=>{
return <li>{ number } </li>;
});

Array indexes can also be assigned as keys to the items – the example below
shows array indexes being assigned:
const numbers = [ 1, 2, 3, 4, 5 ];
const updatedNums = numbers.map((number, index)=>{
return <li>{ number } </li>;
});
Although I have shown you how to do this, it is not a recommended practice.
If, at some point in the future, the order of the array elements changes, things
will get might confusing as the element keys will also change.
How to Use Keys with Components
Think about this. You have a list of items, and a separate component has been
created for them; you want to extract the items from the component. You will
need the keys assigned to the component being returned from the iterator and
not to the items in the list. So, the keys should be assigned to <Component />
and not <li>. To avoid making mistakes, best practice recommends bearing in
mind one thing – whenever you return something from inside the map()
function, it needs a key assigned to it.
The first example below shows you how NOT to use keys:
import React from 'react';
import ReactDOM from 'react-dom';
// Component you want extracted
function MenuItems(props)
{
const item = props.item;
return(
<li>
{item}
</li>    
);
}
// Component that returns an
// unordered list
function Navmenu(props)
{
const list = props.menuitems;

const updatedList = list.map((listItems)=>{
return (
);
});
return(
<ul>{updatedList}</ul>);
}
const menuItems = [1, 2, 3, 4, 5];
ReactDOM.render(
,
document.getElementById('root')
);
And the output would look like this: 
Here you can see that, while the list has been successfully rendered, you still
get a warning that you haven’t assigned keys to the elements in the iterator.
This happened because key was not assigned to the elements being returned
to the map() iterator:
Now you can see the right way to use keys:
import React from 'react';
import ReactDOM from 'react-dom';

// Component you want extracted
function MenuItems(props)
{
const item = props.item;
return(
<li>
{item}
</li>    
);
}
// Component that returns an
// unordered list
function Navmenu(props)
{
const list = props.menuitems;
const updatedList = list.map((listItems)=>{
return (
);
});
return(
<ul>{updatedList}</ul>);
}
const menuItems = [1, 2, 3, 4, 5];
ReactDOM.render(
,
document.getElementById('root')
);
Run that code, and it will be successful; no warning message will appear.
Key Uniqueness
You know that you need to assign unique keys to each array element, but that
doesn’t mean globally unique keys. Every element in the array must have its
own unique key, so you could have two or more arrays, each having the same
set of keys, so long as each element key is not the same as any other.
In the next code example, there are two arrays – menuItems1 and

menuItems2. The first five items in each array share the same keys, but the
code will be successful, and there will be no warning message.
import React from 'react';
import ReactDOM from 'react-dom';
// Component you want extracted
function MenuItems(props)
{
const item = props.item;
return(
<li>
{item}
</li>    
);
}
// Component that returns an
// unordered list
function Navmenu(props)
{
const list = props.menuitems;
const updatedList = list.map((listItems)=>{
return (
);
});
return(
<ul>{updatedList}</ul>);
}
const menuItems1 = [1, 2, 3, 4, 5];
const menuItems2 = [1, 2, 3, 4, 5, 6];
ReactDOM.render(
<div>
</div>,
document.getElementById('root')

);
NOTE
Do not confuse keys with props; they are not the same. The only thing that is
the same is the method used to assign keys to components is the same as that
of the props. Keys live inside React, and you cannot access them from the
inside of a component like you can with props. So, the same value that you
assigned to the key can be used for any prop being passed to the component.

Chapter 10
ReactJS Router
In this chapter, you have the option of joining in by cloning examples from
GitHub. The links are provided for you.
In ReactJS, routing is what lets us move around the application when users
type in a URL or click on a link, icon, button, or any other element on the
application. This chapter will give you an overview of how to use routing in
your React application. To add routing capabilities to your React application,
you will need to use a very popular library called React-Router, and there are
three variants of it:
=> react-router – this is the core library
=> react-router-dom – a core library variant for use in web
applications
=> react-router-native – a core library variant used in
combination with react-native in developing iOS and Android
mobile applications
More often than not, you won’t just install the core library by itself; you need
to choose between the dom and native variants, too, depending on whether
you are developing for mobile or web applications.  Both of those variants
import the core library’s functionality.
We will be concentrating on web apps in this chapter, so we will be using
react-router-dom. You can install this library in your project by going into the
project directory and running this command:
npm install --save react-router-dom
Routers
In the react-router package, you will find several routers you can use,

depending on which platform you are developing an application for. These
include HashRouter, BrowserRouter, and MemoryRouter.
We’ll focus on browser-based applications, so we’ll use HashRouter and
BrowserRouter.
BrowserRouter is used in applications with dynamic servers. These can
handle any URL type, whereas HashRouter is for static websites where the
server can only respond to requests for known files.
We’ll use BrowserRouter, assuming our application server is dynamic. Keep
in mind that routers will only expect to receive one child. Here’s an example:
ReactDOM.render(
  <BrowserRouter>
    <App/>
  </BrowserRouter>,
  document.getElementById(‘root’));
Here, we have a component called <App/> - this is a child of
<BrowserRouter> and must be the only one. Routing can take place at any
point in the <App/> component, but good practice states that all routes should
be grouped and placed in one place. We’ll talk more about that later.
The History Object
Every router creates its own history object, where it tracks the current
location and, when that location changes, the application is re-rendered.
Because of this, other React components will rely on that object being there,
and that is why they must be rendered in the router.
BrowserRouter makes use of the HTML5 history API to ensure that the
interface remains synced with the URL present in the browser’s address bar.
The Router-created history object has several properties, one of which is a
location property. This has an object as its value and is one property we will
be focusing on the most in this chapter.
When you render the earlier example in your browser, the React DevTools
window should show the history object. Inside the history, object is the
location object, and that looks like this:
{ pathname, search, hash, state }

This object will derive its properties from the URL of the application.
Routes
One of the most critical parts of the React Router package is the <Route/>
component. This component renders the right UL when the route’s path is
matched by the current location. The route path is a <Route/> component
prop, used to describe the pathname that should be matched by the route, as
you can see in this example:
<Route path=”/items”/>
The route gets matched when the pathname reads is/items, or all the other
paths start with /items. An example of that would be /items/2. If you only
want /items matched exactly, the <Route/> component must take an exact
prop. When you add this, you make sure that the pathname matching the
current location exactly is what gets rendered. Here’s an example of the exact
prop being used:
<Route exact path=”/items” />
When a match is made with a path, a React component needs to be rendered
to provide a UL change.
You should also note that the react-router package uses a package called
Path-to-RegExp t0 transform path strings to regular expressions, which are
then matched to the current location.
There are three props in the <Route/> component that we use to work out
which component needs rendering:
=> component
=> render
=> children
Let’s look at these in a bit more details
Component Prop
This prop is used to define the element Route returns when the path gets
matched. 
The 
provided 
component 
creates 
the 
element 
using

React.createElement, and you can see an example of how to use the
component prop below:
<Route 
  exact 
  path=”/items.” 
  component={Items}
/>
Here, when the path and the current location match, the Items component is
matched.
Render Prop
The render prop allows inline rendering and the ability to give the element
some extra props. It will expect a function that, when the current location and
path match, will return a React element. Here are some examples showing
how the render prop is used on Route components:
<Route 
  exact 
  path=”/items” 
  render={() => (<div>List of Items</div>)}
/>
In this example, when the path and the current location are an exact match, an
element gets created, and the string called List of Items gets rendered in the
browser.
const cat = {category: “food”}
<Route
exact path=”/items”
render={props => <Items {…props} data={dog}/>
/>
And in this example, the extra props are represented by data and get passed
into the Items component. The extra prop in this example is dog.
Children Prop
This prop expects to receive a function capable of returning a React element,
making it very similar to the render prop. However, there is a difference. The
child prop defines an element that gets returned for every path, regardless of
whether the current location and path match or not.
<Route children={props => <Items {…props}/>}/>
In this example, the Items component will always be rendered.

Switch Component
In the react-router library you will also find a <Switch/> component. This is
used to wrap around several <Route/> components. This component will
always only choose the first matching route from all the children routes.
In the next example, you can see the way that multiple routes will behave
when the Switch component is not there:
<Route
path=”/items”
render={() => (<div><em>List of items</em></div>)
/
<Route
path=”/items/2"
render={() => (<div>Item with id of 2</div>)
/>
When navigating to /items/2 in the browser, you will see both of the Route
components rendered by the React elements:
List of items
Item with id of 2
This may well be the intended behavior – the first component will display the
title, and the remaining routes that have the same base path will all render
different user interfaces.
Let’s make a modification to the above example. This time, we will add the
<Switch/> component and see what happens when navigating to /items/2:
<Switch>
<Route
path=”/items”
render={() => (<div><em>List of items</em></div>)}
/>
<Route
path=”/items/2"
render={() => (<div>Item with id of 2</div>)}/>
</Switch>
You will only see List of Items rendered in the browser because the Switch
component will only match with the first path matching the current location.
Here, the route called /items was matched as soon as /items/2 was input into
the address bar in the browser.

Link Component
Another component in the react-router package is the <Link/> component. It
uses hyperlinks to navigate around the different bits of the application. It
works much like the anchor element in HTML, but there is a difference –
when you use the Link component, the page doesn’t reload. Instead, the UI is
changed. With the anchor tag, the page needs to be reloaded for the new UI to
load. Clicking on the Link component ensures the URL is updated.
In this example, we can see how to use the Link component. We create an
app that lets us navigate from categories to items and back.
export const Home = () => (
<div>
Home Component
<ul>
<li>
<Link to=”/items”>Items</Link>
</li>
<li>
<Link to=”/category”>Category</Link>
</li>
</ul>
</div>
);
In the Home component are links to two more components – Items and
Categories.
A prop is used by the <Link/> component to define which location is being
navigated to. The prop may be a location or a string object – if it’s a string, it
gets converted into a location object. Be aware that the pathname has to be
absolute.
If you want to try this on your own machine, you can find the project here.
Clone it and run:
npm install && npm start
You should see something like the following on your screen:

If you click on the Items link, the UI changes and the URL is updated in the
address bar:
The same thing happens if you click the Category link:

Nested Routing
You now understand how both path and the <Route/> component work, so
now we can look at how nested routing works in a React application.
When you have a successful match between the path and location, another
object is created – the match object. In this object is information about the
path and the URL, and these are accessed on the object as properties.
Let’s look at the properties:
=> url: this is a string, and it will return the part of the URL that
is matched
=> path: this is a string that will return a bit of the route path
=> isExact: this is a Boolean – if the match is exact, it will
return true; if not, it returns false
=> params: this is an object with the key-value pairs that the
Path-to-RegExp package matches
For nested routing to be successfully achieved, we need to use match.url for
the nested Links, and we use match.path for the nested routes.
Here, we’ll look at an example to see how nested routing works. First, clone
the project from here and run:
npm install && npm start
This will get the project set up.
There are four components in the project:
=> Header – this contains links for Home, Category and Items
=> Home – this has dummy data in it
=> Items – this has a list containing dummy items
=> Category – this is where you see nested routing and dynamic
routing demonstrated

We will focus our attention on the Category component because this is where
the nested and the dynamic routing are:
export const Category = ({match}) => (
<div>
<h1>Category Component</h1>
<h5>Click on a category</h5>
<ul>
<li>
<Link to={`${match.url}/shoes`}>Shoes</Link</li>
<li>
<Link to={`${match.url}/food`}>Food</Link>
</li>
<li>
<Link to={`${match.url}/dresses`}>Dresses</Link>
</li>
</ul>
);
So, looking at this code snippet, if the Category click were clicked, the route
path would be matched, resulting in the creation of a match object. It would
then be sent to the category component as a prop.
Inside the Category component is an argument list, and there, the match
object gets destructured and match.url is used to link to the categories.
The prop value needs to be constructed on the Link component to the three
URLS for /shoes, /food, and /dresses, and this is done using template literals.
If you were to open that example in your browser and then click the Category
link, you would see three categories. When you click on one, the URL gets
updated, but the UI doesn’t change.

This is a bug and it needs to be fixed. We need the UI to change whenever
one of the category links is clicked and to do this requires a dynamic route
being created in the Category component. That route will have a prop of
match.path and the UI will be changed dynamically:
<Route
path={`${match.path}/:categoryName`}
render={props =>
(<div>
{props.match.params.categoryName} category
</div>
)
}
/>
When you inspect the path prop value in this code, you can see that
:categoryName was used, which is a pathname variable. It is the path
parameter inside the URL that catches whatever comes after /category.
When we pass the value in this way to the path prop, it eliminates the need to
hardcode the routes for the different categories. Also, note that the right path
was constructed using template literals.

Param objects, like the one in the example below, are created with pathnames
like category/food.
{
categoryName: “food”
}
In this example, the render prop is running an inline render, displaying the
param called categoryName from the match object in the props. That should
be the fix we need to make the UI change and now, when you click on a
category, the UI and the URL should update:
Protected Routes

Having a protected route means that, when users attempt to access any bit of
the application without having logged in first, they get redirected and end up
on the login page where they need to sign in.
Ensuring the redirect works properly requires a <redirect/> component from
the react-router package. A to prop is contained in the package, passed as an
object and with the state and pathname, as you can see below:
<Redirect
to={{pathname: ‘/login’, state: {from:props.location}}}
/>
The Redirect component take the place in the stack of the current location
using the pathname the object /login provides. The location the user was
trying to get to is then stored in the state property. The state value is accessed
from inside the Login component by using this.props.location.state.
If, for example, a user tries to get to /admin, which is a protected route,
without signing in, they get sent to the login page. Once they have signed in
successfully, they then get referred to /admin, where they were trying to get
to in the first place.
Custom Routes
Achieving the protected routes concept requires that we understand custom
routes and how to create them. A custom route is nothing more than a route
nested in a component. Usually, this gets done when a decision needs to be
made on whether to render a component.
As far as protected routes are concerned,  specified routes should be accessed
only by a logged-in user. If a user isn’t logged in, they must be sent to the
login page.
In the next example, we look a bit more at custom routes so, first, clone this
project and, as usual, run:
npm install && npm start
In the private route, there are three props – isAuthenticated, component and
path.  Let’s look a bit closer at the private (custom) route.
The props are destructured in the argument list and component is renamed to

Component (note the change from lower to uppercase). The Route
component is passed to the render and …rest props. In the render prop, logic
is written to determine whether a component should render and also which
ones should be rendered when the user is signed in. If not, the user gets sent
to the login page.
In the Login component is a dummy authentication method. When the user
clicks the Login button, this method signs the user in. When that happens
successfully, the redirectToReferrer state property gets set to true, triggering
a redirect, sending them where they originally wanted to go. If they started on
the login route, they are redirected to the /path.
With the cloned project running, go to localhost:3000 and you should see
something like this:
If you are not signed in when you click the Admin link, you get sent to the
/login page and are shown the login button. When you click that, you get sent
to the admin page, which is protected, as you can see below:

Go ahead and practice with this, using the cloned projects and try writing
your own.

Chapter 11
ReactJS – Introduction to Flux
By now, you have learned just how great the React.js library is, but it is only
one part of the entire stack for a successful front-end application. In fact, in
terms of state and data management, React really doesn’t have a lot to offer.
The makers of React, Facebook, have provided quite a bit of useful guidance,
and it comes in the form of an application architecture called Flux. This
architecture (not a framework) is built around a unidirectional data flow using
React Stores, an Action Dispatcher, and Views. Using the Flux pattern can
help resolve some big issues because it embodies important event control
principles, making it easier to reason about React applications, develop them
and maintain them.
In this chapter, we will look at some basic examples of Flux control flow,
talk a bit about Stores and look at using Flux Backbone models and
Collection. For the purposes of this, I am using CoffeeScript – if you don’t
have this, you can still follow along, and the examples may be treated as
pseudocode.
Introducing Flux
Backbone is a great library that contains Models, Views, Routes, and
Collections. It is one of the de facto standard libraries for fully structured
front-end applications and was introduced to React in 2013. So far, most
React examples not in Facebook.com mention Backbone as being used in
tandem.
Unfortunately, it gets somewhat complicated when we rely entirely on
Backbone to handle all the application flow outside of Views in React, and it
won’t take long for complicated event chains to start getting in the way.
Imagine it – you need to send an event to Models from the UI. From there,
the event goes between models and back again, making it very difficult to

track what was being changed by what, where, in what order, and even why.
The Flux tutorial I am about to go through will show you how the Flux
pattern makes it much easier to handle problems like this.
Flux has a memorable slogan – “unidirectional data flow,” and the diagram
below shows the flow:
What is most important to remember is that things flow in this way:
React → Dispatcher → Stores → React.
Let’s dive into these main components and look at the way they connect.
Before we do that, though, the following caveat is offered by the Flux Docs:
Flux is a pattern rather than a framework, and it has no hard dependencies.
However, EventEmitter is often used for our Views as a basis for React and
Stores. The Dispatcher is the one part of Flux that is not easily available
elsewhere but is needed for your Flux toolbox.
So, there are three components in Flux:
1. Views – React = require(‘react’)
2. Dispatcher – Dispatcher = require(‘flux’).Dispatcher
3. Stores 
– 
EventEmitter 
= 
require(‘events’).EventEmitter.

However, as we will see very soon, this will become Backbone =
require(‘backbone’)
We’ll ignore Views as they are part of React, and you already know all about
them. The other two components, we will discuss now.
The Dispatcher
The Flux Dispatcher is a place where all the events used for modifying Stores
get handled. Using it requires a Store to register one callback that will handle
all the events. When a Store needs to be modified, an event needs to be
dispatched.
Here’s an example of part of an app that lets a user place items onto a to-do
list:
# in TodoDispatcher.coffee
Dispatcher = require("flux").Dispatcher
TodoDispatcher = new Dispatcher() # That's all you need!.
module.exports = TodoDispatcher   
# in TodoStore.coffee
TodoDispatcher = require("./TodoDispatcher")
TodoStore = {items: []}
TodoStore.dispatchCallback = (payload) ->
switch payload.actionType
when "add-item"
TodoStore.items.push payload.item
when "delete-last-item"
TodoStore.items.pop()
TodoStore.dispatchToken = TodoDispatcher.registerCallback(TodoStore.dispatchCallback)
module.exports = TodoStore
# in ItemAddComponent.coffee
TodoDispatcher = require("./TodoDispatcher")
ItemAddComponent = React.createClass
handleAddItem: ->
# note: you do not just push to the store directly!
# (because there are restrictions on moving through the dispatcher
# everything is way more modular and maintainable)
TodoDispatcher.dispatch
actionType: "add-item"
item: "hello world"
render: ->
React.DOM.button {
onClick: @handleAddItem
},
"Add Item!"

Because of this, we can now answer these questions:
1. What events are used to modify MyStore?
To answer that, look inside the MyStore.dispatchCallback switch statement.
2. What are the possible sources for the event?
Run a search for actionType.
This is so much easier to do than looking through MyCollection.add,
MyModel.save, and MyModel.set, etc., where it can fast get difficult to find
the answers to those questions.
You should also remember that the Dispatcher uses waitFor to allow
callbacks to run sequentially and synchronously.
# in MessageStore.coffee
MyDispatcher = require("./MyDispatcher")
TodoStore = require("./TodoStore")
MessageStore = {items: []}
MessageStore.dispatchCallback = (payload) ->
switch payload.actionType
when "add-item"
# synchronous event flow!
MyDispatcher.waitFor [TodoStore.dispatchToken]
MessageStore.items.push "an item was added! It was: " + payload.item
module.exports = MessageStore
See how much cleaner your code is when you modify Stores using
Dispatcher, even when you don’t use waitFor.
The Stores
Now, data flows through the Dispatcher into Stores, but how do we get the
data to go from Stores into Views? The Flux docs say that View will listen
for events that the stores View depends on broadcast.
So, like callbacks were registered with Stores, they can also be registered
with Views which, as we know, are React components. React is told to re-

render when a change to the Store is passed in through the Store props.
Here’s an example:
# in TodoListComponent.coffee
React = require("react")
TodoListComponent = React.createClass
componentDidMount: ->
@props.TodoStore.addEventListener "change", =>
@forceUpdate()
, @
componentWillUnmount: ->
# remove callback
render: ->
# show items in a list.
React.DOM.ul {}, @props.TodoStore.items.map (item) ->
React.DOM.li {}, item
That’s good but how does the change event get emitted? According to Flux,
you should use EventEmitter and here is an example:
var MessageStore = merge(EventEmitter.prototype, {
emitChange: function() {
this.emit(CHANGE_EVENT);
},
/**
* @param {function} callback
*/
addChangeListener: function(callback) {
this.on(CHANGE_EVENT, callback);
},
get: function(id) {
return _messages[id];
},
getAll: function() {
return _messages;
},
// etc...
So, you have to write all of that every single time you want to create a Store,
right? And you have to use it whenever you want to display a piece of
information, right? Wrong.  There is a much easier way.
Models and Collections
Backbone offers Models and Collections, which have everything
EventEmitter-based Stores in Flux have.

When Flux tells you to use a raw EventEmitter, they are recommending that,
whenever you create a store, you are recreating between 50 and 75% of the
Models and Collections in Backbone. You can equate the use of
EventEmitter for Stores as being similar to using plain old Node.js for servers
when there are much better, richer options available, microframeworks like
Express.js, for example.
Like Express is built on Node, so are Models and Collections built on
EventEmitter. And it has everything you will need – Backbone will emit a
change event, and it contains getters, setters, query methods, and everything
else you might want.
So, let’s build our Stores using Backbone.
The Flux/Backbone Pattern
This is a combination of Flux architecture and Backbone, and the basic
pattern is:
1. Models or Collections are used to instantiate Stores. The models
or collections have a callback registered with the Dispatcher and
are typically singletons.
2. View components are never used to modify a Store directly, i.e.,
there is no .set() method. Instead, the Actions are dispatched to
the Dispatcher by components.
3. The Stores are queried by View components which trigger events
by binding to their events.
Let’s take these one at a time and use examples from Backbone and Flux:
1. 
Models or Collections are used to instantiate Stores. The
models or collections have a callback registered with the
Dispatcher and are typically singletons.
# in TodoDispatcher.coffee
Dispatcher = require("flux").Dispatcher
TodoDispatcher = new Dispatcher() # That's all you need!
module.exports = TodoDispatcher
# in stores/TodoStore.coffee
Backbone = require("backbone")

TodoDispatcher = require("../dispatcher")
TodoItem = Backbone.Model.extend({})
TodoCollection = Backbone.Collection.extend
model: TodoItem
url: "/todo"
# a callback is registered on init with the Dispatcher
initialize: ->
@dispatchToken = TodoDispatcher.register(@dispatchCallback)
dispatchCallback: (payload) =>
switch payload.actionType
# The model instance is removed from the Store
when "todo-delete"
@remove payload.todo
when "todo-add"
@add payload.todo
when "todo-update"
# do stuff...
@add payload.todo,
merge: true
# ... etc
# the Store is now an instantiated Collection; a singleton.
TodoStore = new TodoCollection()
module.exports = TodoStore
2. 
View components are never used to modify a Store
directly, i.e., there is no .set() method. Instead, the Actions
are dispatched to the Dispatcher by components.
# components/TodoComponent.coffee
React = require("react")
TodoListComponent = React.createClass
handleTodoDelete: ->
# rather than the todo being directly removed from the ToDoStore,
# the Dispatcher is used
TodoDispatcher.dispatch
actionType: "todo-delete"
todo: @props.todoItem
# ... (see below) ...
module.exports = TodoListComponent
3. 
The Stores are queried by View components which trigger
events by binding to their events.
# components/TodoComponent.coffee
React = require("react")
TodoListComponent = React.createClass

handleTodoDelete: ->
# rather than the todo being directly removed from the ToDoStore,
# the Dispatcher is used. #flux
TodoDispatcher.dispatch
actionType: "todo-delete"
todo: @props.todoItem
# ...
componentDidMount: ->
# the Component is bound to the Store's events
@props.TodoStore.on "add remove reset", =>
@forceUpdate()
, @
componentWillUnmount: ->
# All events and callbacks with this context are turned off
@props.TodoStore.off null, null, this
render: ->
React.DOM.ul {},
@props.TodoStore.items.map (todoItem) ->
# TODO: TodoItemComponent, which would bind to
# `this.props.todoItem.on('change')`
TodoItemComponent {
todoItem: todoItem
}
module.exports = TodoListComponent
Try applying this approach to your projects, and you will see that you have
much cleaner, more streamlined code. All those awkward, ugly bits of code
that you spend hours on trying to find a better way can easily be replaced
with a more sensible flow, and you will find that Backbone integrates almost
seamlessly in the pattern, and you will no longer feel as though you are
fighting everything to get it to go together.
Mixin Example
Whenever you add a Store based on Flux and Backbone to a component,
writing this.on() and this.off() code every single time can get frustrating.
In the React Mixin example below, although it is somewhat naïve, it will
make it much easier to do your iteration:
# in FluxBoneMixin.coffee
module.exports = (propName) ->
componentDidMount: ->
@props[propName].on "all", =>
@forceUpdate()
, @
componentWillUnmount: ->
@props[propName].off "all", =>
@forceUpdate()
, @

# in HelloComponent.coffee
React = require("react")
UserStore = require("./stores/UserStore")
TodoStore = require("./stores/TodoStore")
FluxBoneMixin = require("./FluxBoneMixin")
MyComponent = React.createClass
mixins: [
FluxBoneMixin("UserStore"),
FluxBoneMixin("TodoStore"),
]
render: ->
React.DOM.div {},
"Hello, #{ @props.UserStore.get('name') },
you have #{ @props.TodoStore.length }
things to do."
React.renderComponent(
MyComponent {
UserStore: UserStore
TodoStore: TodoStore
}
, document.body.querySelector(".main")
)
Syncing with Web APIs
In the Flux diagram from earlier, you can see that the Web API  is interacted
with only through ActionCreators. This requires the server to respond before
actions can be sent to the Dispatcher, but surely, the Store should know about
any changes before the server does?
We could swap the diagram, flip it around so that the Stores directly interact
through the sync() method in Backbone with a RESTful CRUD API. And this
is so very convenient if you are working with those APIs.
There is no problem with maintaining data integrity either. When .set() is
used to set a new property, a React re-render is triggered by the change event,
and the new data is optimistically displayed. When you try saving it to the
server using .save(),  the request event will tell you how a loading icon
should be displayed. And when everything has gone through, the sync event
tells you that the loading icon needs to be removed, or the error event will let
you know that things need to turn red.
The first layer of defense also has a validation and invalidation event and a
.fetch() method used for getting new information out of the server.

However, if your task is not quite so standard, it may make more sense to use
ActionCreators.
Using Backbone carefully and cleverly can help fill in some of the Flux gaps,
and it will be stunningly simple for anyone, no matter how small, or large
their business may be, to create impressive applications and maintain them.

Chapter 12
ReactJS Animations
It’s easy to forget about adding animation to our web projects simply because
our designs take shape as flat images. When we get down to coding,
compatibility with web browsers is the most important thing in our minds,
along with screen sizes and how we are going to implement the features.
More often than not, how the UI actually moves is the last thing on our minds
and tends to be an afterthought.
This can cause some serious problems because, sometimes, the UI
components need to move. Why? Because the transition between each state
needs to be smooth, and this done by movement. Sometimes we want the
newest content on our web page, or certain actions brought attention to.
As an example, if a price changes on your website, you might want to draw
attention to, ensuring no-one can miss it.
Leaving this kind of thing to the end can cause problems because we end up
trying to throw together a quick solution. The result is jerky, inconsistent
animations that are wrongly applied or, in some cases, forgotten about
altogether.
It doesn’t have to be hard to animate your React apps, though. With React
animation, you get access to plenty of pre-built keyframes and components
that help you easily add animations to your apps very quickly.
Introducing React Animation
React Animation is a relatively new React package that helps you add UI
animation to your projects. The package is full of wrapper components and
pre-built animation keyframes that you can easily and quickly add to your
projects.
Of course, there are other ways to build animations into your apps. You could

use the React Transition group, which allows you to add classes and remove
them so animations can be applied. Unfortunately, React Transition Group
doesn’t include those animations, so that’s something you would still need to
deal with on your own. Or you could choose React Spring, which offers
plenty of advanced tools that help you handle big sets of animated elements.
What you really need is something that falls in-between, something that
makes applying animations to parts of your elements simple, offering plenty
of pre-built animations that you can add to your projects. That’s where React
Animations comes in – it’s easy to use and offers sufficient consistent
flexibility to help you customize the animations as per your project.
Let’s look a bit deeper into what React Animation does for us, beginning
with the helper components.
AnimateOnChange
AnimateOnChange is one of several simple wrapper components that go
around your content, applying animation as you need it.
Sometimes, you want to let your users know that some content has changed
by adding a bit of visible animation. If you need to write that sort of
functionality for multiple parts of the UI, it can soon become boring and
time-consuming, and that’s when mistakes get made. Instead, wrap the
AnimateOnChange component around your content.
Start by installing React Animation with the following command:
npm install react-animation
Now the component can be used like this:
import { AnimateOnChange } from ‘react-animation’
Your content and components go here
Whenever the children content in your website changes, the component
responds to it by applying a fade-out-fade-in animation, fading the old
content out and the new content in.
But this component does more. We can also pass properties in that control the
way the animation works. One of those is the durationOut value, submitted in
milliseconds. This supplies the length of time the fade-out animation takes to

animate the old stuff away. This can be set to a smaller or larger number,
depending on how you want the fade animation to feel.
When you pass the animationOut and animationIn properties, you can also
select which animations apply when you want the content changed. These
properties are supplied with the name of the animation you want from the
package, and you can see a list of these towards the end of the chapter.
You can also choose from a series of bounce animations and use the style
property to set whatever properties you want on the component.  This is
similar to how the React style property works, accepting objects with the
style rules in the standard way.
Custom Animations
The AnimateOnChange component also allows you to create custom
animations in two different ways. First, it lets you create keyframes and pass
animation strings into the animationIn and animationOut properties. Say you
call your keyframes my-anim-out to hide content and my-anim-in when you
want to show new content; these keyframes could be defined like this:
@keyframes custom-animation-in {
from {
transform: rotateX(140deg) scale(32);
}
to {
transform: none;
}
}
@keyframes custom-animation-out {
from {
transform: none;
}
to {
transform: rotateX(-270deg) scale(0);
}
}
The result of this would a zoom effect in 3D that rotates.
The second way is using classes. Let’s say that you want a pseudo-element
for a specific element animated, or perhaps the children of a specified
element. In that case you could apply a top-left class when the animation is in
the out or the in state, and that is done by specifying className.
It can be incredibly useful to have different bits of your UI animated,

especially for letting people see that something has changed on your website.
Perhaps you show stock prices on your site or other live-streamed data, and
you want to use an animation to show when the information changes. Or you
run an online shop and you want to let customers know that they added
something to their online cart. Really, the possibilities are endless.
HideUntilLoaded
Some UI components use background images or another image that may be
dynamic and also potentially very large in terms of file size. We don’t want
our component displaying before we are sure that the image is fully loaded,
as you could end up with only partial images on the site. You may also want
components to remain hidden until the image is fully loaded, and that is
where the component called HideUntilLoaded comes in.
This is used similarly to the last one for wrapping around your content; in this
case, it will tell the content which image it needs to wait for.
You could even pass in a spinner component to visually show the user that
the image is loading – that way, they will know something is happening.
Lastly, an animationIn could be specified for when all the content has loaded
fully.
The HideUntilLoaded component is pretty useful, especially where you have
components relying on big images in the background. This could be images
of your products, with text overlays and drop shadows, or media components
that include text and photos. This component helps you hold them all back
until they are all ready and can be animated together.
Prebuilt Keyframes
The React Animation package also has a range of built-in animations you can
make use of. These can even be added to your project without needing to use
either of the above helper components. However, importing them requires
other associated keyframes:
import 'react-animation/dist/keyframes.css'
import { animations } from 'react-animation'
Once the keyframes have been imported, the animations object can be used in
your component styles. One example could be when you want animations to
pop in when the site is first loaded, and we could do that like this:

const style = {
animation: animations.popIn
}
const MyComponent = () =>
My Component
Here, animations.popIn will evaluate as pop-in 500ms cubic-bezier(0.19, 1,
0.22,1) forwards.
The animations built into the package are:
bounceIn
bounceOut
fadeIn
fadeInUp
fadeOut
popIn
popOut
slideIn
slideOut
Have a think about your project and where you could use animations in your
UI. You could draw the users’ attention to a specific button or use it to fade
items in and out of a list, for example. However you want to do it, consider
using React Animations to help you. Simply install it like this:
npm install react-animation
And then, the components can be imported:
import { AnimateOnChange, HideUntilLoaded } from 'react-animation'
These bring the keyframe definitions you need in automatically so you can
use those components in your project.

Chapter 13
ReactJS Higher Order Components
In React, Higher Order Components, or HOCs, get their inspiration from the
higher order JavaScript function. An HOC is, in simple terms, an advanced
technique that allows you to reuse logic in a component.
Basically, they incorporate the DRY principle – Don’t Repeat Yourself –
which I am sure you have already come across in your programming travels.
It is the best-known software development principle, and it is one of the most
important to observe when you are building applications or writing any kind
of code.
In this chapter, we will discuss what HOCs are, how they are structured, what
they are used for, and lastly, we’ll look at an example.
You do need to have some knowledge of JavaScript and React to get the best
out of this chapter.
Higher-Order Functions in JavaScript
Before we discuss the React HOCs, we’ll take a quick look at the JavaScript
HOCs as these are where the React ones get their inspiration from. As such, it
is critical that you understand them.
JavaScript higher order components take arguments in the form of functions,
and then they return another function. These HOCs are what let us abstract,
not just over values, but over actions. They come in several different forms
and are what use to write less code when we are operating on functions. They
even work on arrays.
Composition is the most interesting part about using these because smaller
functions can be writer to hand a piece of logic. Then, more complex
functions are composed using the smaller ones, reducing the risk of bugs in
the code and making the code more readable and easier to understand.

Some of these higher order functions are already built into JavaScript and
some examples are:
.forEach() – this is used to iterated over each element in an array
using the same code. However, it will not mutate or change the
array in any way and its return is undefined.
.map() – this is used for transforming arrays. It is done by
applying every element in the array with a function and then
using the returned values to build a new array.
.reduce() – this is used to execute a specific function for each
array value, working from the left to the right.
.filter() – this is used to check each individual element in a given
array to check if meets criteria that are specified inside the filter()
method. A new array is returned containing elements matched
with the specified criteria. 
JavaScript contains tons of higher order functions, but you can still create
your own custom ones.
A Custom Higher Order Function Example
Let’s say that we want to write a function used for formatting integers as
currencies. You need to include some kind of customization to specify what
the currency symbol is and to add a separator for the amount – we use the
decimal separator.
We would write a higher order function to take the symbol and the separator
and then format the value that gets passed to it using the decimal operators
and the currency symbol. We will call this higher order function
formatCurrency.
const formatCurrency = function(
currencySymbol,
decimalSeparator  ) {
return function( value ) {
const wholePart = Math.trunc( value / 100 );
let fractionalPart = value % 100;
if ( fractionalPart < 10 ) {
fractionalPart = '0' + fractionalPart;
}
return `${currencySymbol}${wholePart}${decimalSeparator}${fractionalPart}`;

}
}
The formatCurrency function will then return another function that contains a
decimal separator and a fixed currency symbol. The formatter is passed a
value and the value is formatted  with the function – the whole and fractional
parts are extracted. A template literal is used to  construct the function’s
returned value, and the currency symbol, whole part, separator and fractional
part are all concatenated.
Let’s assign a value to the higher order function so we can use it and see what
the result is:
> getLabel = formatCurrency( '$', '.' );
> getLabel( 1999 )
"$15.99" //formatted value
> getLabel( 2499 )
"$34.99" //formatted value
So, what we did here was created a variable and named it getLabel. Then,
formatCurrency was assigned, and the currency formatters were passed to it –
these are the decimal separator and the currency symbol. To use the function,
getLabel (now a function) is called, and the value that needs formatting is
passed in.
That’s all we need to do to create a custom higher order function.
What is a Higher-Order Component?
Right, so an HOC is an advanced element that lets us reuse logic in a React
component. We said that before and it needed.
A component can take arguments in the form of other components, and a new
component, an upgraded one, is returned. Does that sound familiar? It should
do, because it much like the higher order function that takes functions as
arguments, returning new functions.
We commonly use HOCs to design components with shared behavior but
they are designed in a way that they connect in a different way than the
standard pattern of states to props.

Things you need to know about higher order components are:
1. Components are neither modified nor mutated. Instead, new ones
are created
2. HOCs are used for composing components that make it easy to
reuse code
3. HOCs are pure functions. They do not have any side effects and
they only return new components.
Here are some HOCs you may have come across in the real world:
react-redux
connect(mapStateToProps,
mapDispatchToProps)(UserPage)
react-router
withRouter(UserPage)
material-ui withStyles(styles)(UserPage)
Higher Order Component Structure
HOCs are structured in much the same way as higher order functions:
They are components
They take components as arguments
They return new components
The returned component is able to render the component that was
originally passed to it.
In the code example below, you can see how a React HOC is structured:
import React from 'react';
// Take a component as an argument WrappedComponent
const higherOrderComponent = (WrappedComponent) => {
// Return a new component
class HOC extends React.Component {
render() {
return <WrappedComponent />;
}
}
return HOC;
};

As you can see, higherOrderComponent takes WrappedComponent, which is
another component and then returns a new component inside it. Using this
techniques allows us to reuse the logic from a component by creating an
HOC from the component and using it wherever needed.
Use Cases
As a front-end programmer, you will find some common use cases for HOCs
in React:
While a Component is Waiting for Data, You Can Show a
Loader
When you build a web application, you may find you need to include a loader
of some description. This is displayed when a component is loading, i.e.
waiting for specific data to go into its props. The loader could be rendered by
way of using an in-component solution but while this would work, it
wouldn’t be all that nice to look at. It would be far better to write an HOC to
track the props and, while the props are waiting for data or are empty, the
loader can be displayed.
To help explain this, let's create a list of Public API categories using the open
API. List-loading is handled, ensuring customers don’t think that the
application has collapsed when all it is doing is waiting for data.
First, generate a React app:
npx create-react-app repos-list
Next, we can write a basic list component like this:
//List.js
import React from 'react';
const List = (props) => {
const { repos } = props;
if (!repos) return null;
if (!repos.length) return <p>No repos, sorry</p>;
return (
<ul>
{repos.map((repo) => {
return <li key={repo.id}>{repo.full_name}</li>;
})}
</ul>
);
};
export default List;

That is a list component so let’s break the code down and understand what is
going on:
const List = (props) => {};
First, the functional component is initialized, given a name of List and then
the props are passed to it.
const { repos } = props;
Next, a constant is created, called repos, and then passed to the component
props. This allows us to use it for modifying the component.
if (!repos) return null;
if (!repos.length) return <p>No repos, sorry</p>;
What we are saying here is, if the repos prop remains empty after fetching is
finished, null should be returned. Another thing we are doing is a conditional
render. If the repos prop length remains empty, “no repos, sorry” should be
rendered in the browser.
return (
<ul>
{repos.map((repo) => {
return <li key={repo.id}>{repo.full_name}</li>;
})}
</ul>
);
Here, we map through the array called repos. A list is returned, containing the
repos as per their full names and providing a unique key for every entry.
Now, to keep our users happy, we want to handle loading so let’s write an
HOC:
//withdLoading.js
import React from 'react';
function WithLoading(Component) {
return function WithLoadingComponent({ isLoading, ...props }) {
if (!isLoading) return <Component {...props} />;
return <p>Please wait, fetching data might take a while.</p>;
};
}
export default WithLoading;
The text, “Please wait, fetching data might take a while” is displayed while
data is still being fetched by the app and the props are being injected into the
state. We also use isLoading to work out whether to render the component.

In the App.js file you created, the loading logic could be passed to
WithLoading without needing to worry about it in List.
import React from 'react';
import List from './components/List.js';
import WithLoading from './components/withLoading.js';
const ListWithLoading = WithLoading(List);
class App extends React.Component {
state = {
{
};
componentDidMount() {
this.setState({ loading: true });
fetch(`https://api.github.com/users/hacktivist123/repos`)
.then((json) => json.json())
.then((repos) => {
this.setState({ loading: false, repos: repos });
});
}
render() {
return (
<ListWithLoading
isLoading={this.state.loading}
repos={this.state.repos}
/>
);
}
}
export default App;
That code is the whole app so let’s break it down and see what is going on:
class App extends React.Component {
state = {
loading: false,
repos: null,
};
componentDidMount() {
this.setState({ loading: true });
fetch(`https://api.github.com/users/hacktivist123/repos`)
.then((json) => json.json())
.then((repos) => {
this.setState({ loading: false, repos: repos });
});
}
We have done nothing more than create a class component and call it App(). 
We then use two properties to initialize state – loading: false and repo: null.
Loading has an initial state of false and repos has an initial state of null.
When the component begins mounting, the loading property state is set to
true and a fetch request is immediately made to the API URL where the data
we need for populating the List component is held. When the request has

completed, the loading state is set to false and repos state is populated with
the data we fetched with the API request.
const ListWithLoading = WithLoading(List);
In this line, we created a component and called it ListWithLoading. The
WithLoading HOC is passed, and the List component.
render() {
return (
<ListWithLoading
isLoading={this.state.loading}
repos={this.state.repos}
/>
);
}
Here, we have rendered the ListWithLoading component, which we
supercharged by passing it the WithLoading HOC and the List component.
We also passed the value for the loading state and the value for the repos
state to the component as props.
The page is still attempting to get data from the API so the HOC renders text
in the browser:

Once the loading is finished and the props no longer show an empty state, we
can render the repos onto the screen:
Render Components Conditionally
Let’s say that we have a component that should only be rendered when a user
gets authenticated. This would be a protected component. An HOC called
withAuth() can be created to wrap around the protected components and then
a check is done in the HOC to ensure that specific component is rendered
only when the user is authenticated.
You can write a withAuth() HOC as per this example like this:
// withAuth.js
import React from "react";
export function withAuth(Component) {
return class AuthenticatedComponent extends React.Component {
isAuthenticated() {
return this.props.isAuthenticated;
}
/**
* Render
*/
render() {
const loginErrorMessage = (
<div>
Please <a href="/login">login</a> to see this part of the application.
</div>

);
return (
<div>
{ this.isAuthenticated === true ? <Component {...this.props} /> :
loginErrorMessage }
</div>
);
}
};
}
export default withAuth;
So, that is the withAuth() HOC and it will take a component and return
another one called AuthenticatedComponent. This component will check to
see whether the user has been authenticated. If not, another component called
loginErrorMessage is returned. If the user is authenticated, the wrapped
component is returned.
NOTE
Your application logic must be used to set this.props.isAuthenticated, or it
must be retrieved from the global state using react-redux.
We can use the HOC in a protected component like this:
// MyProtectedComponent.js
import React from "react";
import {withAuth} from "./withAuth.js";
export class MyProtectedComponent extends React.Component {
/**
* Render
*/
render() {
return (
<div>
This can only be seen  by authenticated users.
</div>
);
}
}
// Now MyPrivateComponent is wrapped with the function called
requireAuthentication
export default withAuth(MyPrivateComponent);
A component is created that can only be seen by authenticated users. The
component is wrapped in the withAuth HOC to ensure it is protected from

unauthenticated users.
Provide Specific Styling to Your Components
Carrying on with the above use case, specific styles can be rendered for
specific UI states, depending on the UI state that comes from the HOC. For
example, if you need to use specific styles, like fontSize, backgroundColor,
and so on in multiple places, you can use an HOC to provide them – simply
wrap the component with another one that injects a specific className into
the props.
Let’s use a simple component as an example – one that renders the word
“Hello” followed by a person’s name. This component will take two props –
a name and another one that affects the JSX that gets rendered – JSX =
JavaScript XML.
// A simple component
const HelloComponent = ({ name, ...otherProps }) => (
<div {...otherProps}>Hello {name}!/div>
);
Now an HOC can be created and called withStyling, and we can used it to
add a style to the text:
const withStyling = (BaseComponent) => (props) => (
<BaseComponent {...props} style={{ fontWeight: 700, color: 'green' }} />
);
To use the HOC on the HelloComponent, the HOC is wrapped around it. A
pure component is created, called EnhancedHello, and the HOC and
HelloComponent are assigned to it, like this:
const EnhancedHello = withStyling(HelloComponent);
To change the HelloComponent in any way, the EnhancedHello component is
rendered:
<EnhancedHello name='World' />
The HelloComponent text is now:
<div style={{fontWeight: 700, color: 'green' }}>Hello World</div>
Provide Any Prop to a Component

This is one of the most popular uses for HOC components.  The code base
can be studied and we can determine the reusable prop we want to use across
our components. Then the wrapper HOC can be created to give the reusable
prop the right components.
Continuing with the example from above:
Let’s use the example above:
// A simple component
const HelloComponent = ({ name, ...otherProps }) => (
<div {...otherProps}>Hello {name}!</div>
);
Now we can create an HOC and name it withNameChange. This will set the
base component name prop to New Name:
const withNameChange = (BaseComponent) => (props) => (
<BaseComponent {...props} name='New Name' />
);
The HOC is wrapped around the HelloComponent and a pure component is
created, called EnhancedHello2. The HOC and HelloComponent are assigned
like this:
const EnhancedHello2 = withNameChange(HelloComponent);
Changing our HelloComponent is done by rendering the EnhancedHello
component, like this:
<EnhancedHello />
Now the HelloComponent text is this:
<div>Hello New World</div>
Changing the name prop is done like this:
<EnhancedHello name='Shelley' />
Now our HelloComponent Text is this:
<div>Hello Shelley</div>
Building a Higher Order Component - Example
To finish this chapter, we are going to build an HOC. It will take a
component with a name prop and the name prop will be used in the HOC.

First, create a React app using create-react-app:
npx create-react-app my-app
Once the app is generated, the code in your index.js file can be replaced with
this:
import React from 'react';
import { render } from 'react-dom';
const Hello = ({ name }) =>
<h1>
Hello {name}!
</h1>;
function withName(WrappedComponent) {
return class extends React.Component {
render() {
return <WrappedComponent name="Smashing Magazine" {...this.props} />;
}
};
}
const NewComponent = withName(Hello);
const App = () =>
<div>
<NewComponent />
</div>;
render(<App />, document.getElementById('root'));
When the code has been replaced in the index.js file, this is what you should
see on your screen:

Let’s work through this code:
const Hello = ({ name }) =>
<h1>
Hello {name}!
</h1>;
A functional component was created and given a prop called name. “Hello” is
rendered in the component, along the name prop value in an h1 tag:
function withName(WrappedComponent) {
return class extends React.Component {
render() {
return <WrappedComponent name="Smashing Magazine" {...this.props} />;
}
};
}
A higher order functional component was created and called withName(). An
anonymous class component is returned inside, rendering the component in
the HOC wrapper, then a value was assigned to the prop in the wrapped
component.
const NewComponent = withName(Hello);
A new component is created and called NewComponent. The HOC we
created earlier is assigned to the functional component created right at the
start,
const App = () =>
<div>
<NewComponent />
</div>;
render(<App />, document.getElementById('root'));
All we did here was create another functional component and name it App.
This component will render NewComponent – the one we upgraded in a div
with the HOC – and then the react-dom function called render is used to
display it in the browser.
That’s it, all we need to do. The function called withName will take an
argument which is a component and an HOC is returned. If you want to
change things later down the line, all you have to do is edit the HOC.
It really is as simple as that.

Chapter 14
ReactJS Best Practices
As a front-end developer, you should be using React to build your user
interfaces, especially those that are interactive. And while you use React, you
should always keep the best practices in mind, if only to ensure your code is
organized properly.
You already know that React is a Facebook library, allowing integration with
lots of different components.  In fact, it’s fair to say that, as a developer, you
can even create components of your own and allow the rest of the community
to use them.
To help you get the best out of this fantastic library, this chapter will detail
the most fundamental React best practices you should be following.
1. Ensure Your Components are Function-Specific and Small
We already know that React allows you to have some pretty big components,
huge in some cases, used to execute multiple tasks. However, a much better
way of designing your components is to keep them as small as you can,
ensuring that one component corresponds to just one function. In an ideal
world, a component should only render a particular part of the webpage or
modify a specific behavior and this comes with lots of advantages:
A function-specific component can be designed as a standalone,
which makes it much easier to test and maintain.
Every small component should be reusable across your projects.
If a component is designed to execute a general function, the
developer can make it available to the community.
The smaller the component is, the easier it is to implement
optimizations to the app performance

The larger components need to work harder and are likely to be
harder to maintain.
There is a balance between creating one component for one function and
creating large components to do multiple things and this will differ between
organizations. At the end of the day, there is no limit on how many
components you can have and you can recombine them however you want to
get the right result.
2. Create Only the Minimum Number of Components Required –
Reusability is a Critical Part of React.
When you stick to the first rule of having one function per component, you
make significant improvements in component reusability. That means, don’t
bother wasting time creating a component for a function when one already
exists.  Reusing components across one or more projects ensures consistency
and it you also contribute to helping the community.
However, if a component grows too large, too unwieldy and hard to maintain,
it would be better to split it down into several smaller ones.
For example, you could create a Button component that would be able to
handle icons and then, whenever your project needs a button, you have a
component you can call on. By following a modular style, more cases can be
covered by one component. What you have to do is aim for the middle – keep
your components sufficiently abstract but not too complex:
class IconButton extends React.Component {
[...]
render() {
return (
<button onClick={this.props.onClick()}>
<i class={this.props.iconClass}></i>
</button>
);
}
}
3. DRY – Don’t Repeat Yourself. Duplicate Code should be
consolidated.
This is a common sense rule – keep your code concise and as brief as you
can. That rule applies across all computer programming, not just React.

How do you achieve this? By scrutinizing all your code carefully and looking
for similarities and patterns. Where you find them, look further to make sure
you are not duplicating your code – eliminate it where possible. Most of the
time, a little bit of rewriting does the trick.
This is quite heavily reliant on React’s reusability principle. Let’s assume that
you want multiple buttons added, all containing icons. Instead of giving each
button the markup, you could use the IconButton component we created with
the code above. And you can even take that further by using an array to map
everything:
const buttons = ['facebook', 'twitter', 'youtube'];
return (
<div>
{
buttons.map( (button) => {
return (
<IconButton
onClick={doStuff( button )}
iconClass={button}
/>
);
} )
}
</div>
);
4. Use CSS in Your JavaScript
When you start on a new project, common practice dictates that all your CSS
styles are kept in one SCSS file. Potential collisions between names are
prevented by using a global prefix. However, while this works for small
projects, it may not be so good when you scale things up.
Lots of libraries are available to help you write CSS in JavaScript and two of
the most popular are Glamorous and EmotionJS.
Below, you can see how to use EmotionJS to  generate entire CS files for
your project. First, EmotionJS needs to be installed:
npm install – save @emotion/core
Then, EmotionJS needs to be imported into your application:
import { jsx } from '@emotion/core'

An element’s properties can be set like this:
let Component = props => {
return (
<div
css={{
border: '1px'
}}
{...props}
/>
)
}
5. Only Use Comments Where Necessary
You should only add comments to your code where it is absolutely necessary.
Not only does that keep you within the React best practices, but it also makes
sure your code is not full of clutter. Plus, it helps avoid potential conflicts
between your code and comments should you decide to change the code later
down the line.
Attach comments to code only where necessary. This is not only in keeping
with React best practices, but it also serves two purposes at the same time:
It’ll keep code visually clutter free.
You’ll avoid a potential conflict between comment and code, if
you happen to alter the code at some later point in time.
6. Component’s Should be Named After Functions
It’s good practice to name your components after the specific function it is
executing – that way, they are easier to recognize. As an example, if you have
a component named ProductTable, you can see at a glance what it does. If
you go down the route of naming the component by the code’s needs, things
can get confusing, not just for you, but for anyone else who reads your code.
Take another example, a component named Avatar. This component could be
used anywhere, i.e., for users, authors, even in comments. But if you named it
AuthorAvatar, its utility would be somewhat limited.
As an added bonus, when you are sharing components with the community, it
makes sense to name them after the function as it makes them easier to find.

7. Component Names Should be Capitalized
Most coders use a JavaScript extension, JSX, and your component names
should start with capitalized letters. For example, a component should be
called Menu, not menu, or SelectButton, not selectbutton. This is done so
they can be identified by JSX differently from the HTML tags.
In the early days of React, a list was maintained of all the built-in names to
help differentiate them from the custom names. However, constantly
updating the list became too much work and it was eventually scrapped in
favor of using capitalization.
If you are not using JSX, lowercase letters can be used but be aware – this
may lessen their component reusability outside your project.
8. Keep Other Naming Conventions in Mind
When you are working in React, you typically use JSX files. That means all
components created for React should use Pascal case or upper camel case for
naming. This means there are no spaces between the words and the first letter
of each word is capitalized.
If you want a function created to submit forms, upper camel case should be
used to name it SubmitForm, rather than submitForm or submit_form, for
example. Typically, upper camel case is just another name for Pascal case.
9. Keep Stateful Aspects Separate from Rendering
React components may be stateless or stateful. A stateful component stores
information on the state and gives any required context. By contrast, a
stateless component does not have any memory and cannot provide other
parts of the UI with any context. All they do is receive inputs (props) from
the parent component, returning JSX elements. They are reusable, they are
scalable and are similar to JavaScript pure functions.
A best practice in using React says that stateful logic for loading data should
not be kept with rendering stateless logic. It works much better if you have a
stateful component for data loading and a stateless component for data
display, thus reducing component complexity.

In newer React versions, you can use React Hooks for writing stateful
components related to functions. Eventually, this may eliminate the
requirement for class-based components.
Let’s say, for example, that your app fetched data on mount, You want to
manage the main component data, passing the render task, much more
complex, as props to a subcomponent.
import RenderTable from './RenderTable';
class Table extends Component {
state = { loading: true };
render() {
const { loading, tableData } = this.state;
return loading ? <Loading/> : <RenderTable data={tableData}/>;
}
componentDidMount() {
fetchTableData().then( tableData => {
this.setState( { loading: false, tableData } );
} );
}
}
10.        Your Code Should Always Execute as You Expect and it
Must be Testable
In all honesty, this doesn’t really need much explanation. When you write
code, it should always behave as you expect it to, and it should be easily
testable. One more good practice that comes from this is naming test files the
same as your source files but with a .test suffix. That way, you can easily find
the ones you want to test.
11.        Keep All Files Related to a Single Component in One
Folder
And that includes your styling files. If you have small components that relate
only to a specific component, keep them all together in one folder. That way,
you can easily understand the hierarchy – large components have a folder of
their own and smaller ones are split down no subfolders, allowing you to
extra code or modify it when needed.
For example, if you have a Form component, you should keep all the icons,
CSS files, tests, images, and any other related sub-components in one folder.

Be sensible about your naming and you won’t have any trouble finding them
when you need them.
12.        Use Tools, Such as Bit
Tools like Bit help you keep all your React components organized making it
easier to maintain your code and reuse it when needed. As well as that, your
code instantly becomes more discoverable, promoting team collaboration in
component building and helping sync your code across your projects.
13.        Use Snippet Libraries
Code snippets are useful in helping you keep up with all the latest and the
best syntax and they help you to keep as many bugs out of your code as
possible. As such, that makes this one of the best React practices that you
should adhere to. There are lots of snippet libraries, such as Redux, ES7
React, JS Snippets, and so on.
14.        Write Tests for All Your Code
No matter what programming language you use, you should always carry out
enough testing, to make sure your project integrates with other code and
doesn’t harm functionality already in place. So, as a good practice, whenever
you create a new component, you should always write tests. Create a
__Test__ directory in the directory where your component is to store all your
tests.
React tests can be broadly divided into two – using a React app to test the
component functionality, and testing the entire application once it has been
rendered in the browser. The latter can be tested using cross browser tools
while a JavaScript test runner can be used for the former.
The best test runner is called Jest and it can be used to emulate the HTML
DOM, allowing you to test React components using jsdom. You can only get
an accurate test by testing on a real device in a real browser but Jest does give
you a good idea while you are developing your project.
15. Follow the Linting Rules and Break Down Over-Long

Lines
The linting process lets us run a program to look at code for potential errors.
Most of the time it is used for language issues but it can be used to fix other
issues, such as code style automatically. When you use a linter, you can keep
your code free of bugs and errors – or at least most of them.

Chapter 15
Let’s Create a React App
To finish this book off, we’ll walk step by step through setting up a React
app, using the command line and text editors.  We will use npm, which is the
Node Package Manager and, by now, you should already have node installed
on your computer.
Installing Node automatically installs the npm but the latter is separate from
Node.js and updates more frequently. That means, even if Node and npm
have only just been installed on your system, updating npm is a good idea –
thankfully, its built into npm to update itself.
Run the following command in the terminal to make sure you are on the
latest version:
sudo npm install -g npm@latest
Step One: Setting Up a Boilerplate App
You can create React apps manually but Facebook gives us a useful package
called create-react-app – this will generate a boilerplate app for us. An added
benefit of this is that your React apps are consistently structured and can
easily be recognized as you move between your apps. Plus you also get a
development server and a build script.
Installing and running create-react-app requires that we use a package runner
tool called npx – this also makes sure you are running the latest create-react-
app version.
Open your terminal.
First, if you globally installed create-react-app at an earlier time, using npm
install -g create-react-app, you should uninstall it using these commands:
npm uninstall -g create-react-appnpx create-react-app myfirstreactapp

If you haven’t installed it, this is the command to run:
npx create-react-app myfirstreactapp
If you installed Yarn, it gets used by default to create a new project. If you
want to use npm instead, append the creation command with –use- npm, like
this:
npx create-react-app myfirstreactapp --use-npm
When you are done, you will see a few tips on using the application:
Before the app is run, let’s see what the app structure looks like.
Step Two: The React App Structure
In the app you created, change directories and use your text editor to open the
app. You should see a file structure like this:
myfirstreactapp
├── node_modules
├── public
│   ├── favicon.ico
│   ├── index.html

│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
├── src
│   ├── App.css
│   ├── App.js
│   ├── App.test.js
│   ├── index.css
│   ├── index.js
│   ├── logo.svg
│   ├── serviceWorker.js
│   └── setupTests.js
├── .gititgnore
├── package.json
├── package-lock.json
└── README.md
As you can see, create-react-app has set up the main application structure and
some of the developer settings too. Most of the structure is not visible to your
web app users. A tool called webpack is used by React to turn your files and
directories onto static assets, which is what web visitors will see.
Don’t worry about understanding webpack right now. Using create-react-app
gives us the benefit of being able to bypass manual webpack configuration.
.gitignore
When your code is committed, this is the standard file the source control uses

to work out which directories and files should be ignored. Note that a git repo
has not been created by create-react-app in the folder. Instead, if you look at
the file, you can see that several items have been ignored:
package.json

The file above outlines all the React app settings:
name – your app’s name
version – the current app version
“private”: true – this is a failsafe that helps you to not publish
your app accidentally as a public package in npm
dependencies – this is where all the Node modules are versions
the application needs are stored. We have six dependencies –

three for testing, two that let us used react and react-dom in the
JS and one, react-scripts, that gives us a set useful development
scripts to help us work with React.
scripts – this tells us the aliases that can be used for accessing
script commands more efficiently. As an example, if you run
npm test in the command line, react-scripts –env=jsdom is run
behind the scenes.
eslintConfig and browserslist – these are Node modules with
their own value sets. We can see info about the compatibility of
the app with browsers in browserslist, and code linting is looked
after in eslintConfig.
node_modules
In this module, you will find the dependencies and the sub-dependencies of
any packages the current React app is using, as package.json specifies. Have
a look  - it might surprise you just how many there are!
When you run ls -1 | wc -l in the node_modules/ directory, you will see over
800 different subfolders. There is a good reason why this folder is added
straight to .gitignore automatically! But, even with all of these, once the app
is minified and then compressed ready for production, it will still only be
about 50 KB.
package-lock.json
In this file, you will see the dependency tree that was installed in
node_modules/, allowing teams who are working on a private apps to use the
exact same dependency and sub-dependency versions. Here, you will also see
a history of the changes made to package.json so you can easily see back
through the changes to the dependencies.
public
In this directory, you can find the assets that are directly served without
webpack needing to do any other processing. The web app’s entry point is
served by index.html, there is a favicon, which is a header icon, and a
manifest.json.

The manifest.json file is used to configure the behavior of your web app if it
gets added to an Android home screen – for reference, Android users can
have web apps as short cuts and can load them straight from the UI.
src
Here, you can see the JavaScript that webpack processes – this is the core of
your React app. When you browse the src folder, you will see several things:
App.js – the main JS component
App.css – the styles associated with the component
App.test.js – the test suite
Index.js and index.css, which are the styles, are the entry point into the app
and they also kickstart registerServiceWorker.js. This looks after the caching
and updates files for end-users, as well as allowing a capability to work
offline and loading pages faster once the initial visit is out of the way.
As your React app gets bigger, commonly a components/directory is added to
help organize the components and any files related to them, as well as a
views/ directory that organizes the views and their related files.
Step Three: Starting the Development Server
When create-react-app was run, you saw a success message. This told you
that serving the development server required npm start to be run in the app
directory.  A browser tab should automatically open, pointing to
http://localhost:3000/,. If it doesn’t, open a tab yourself and go to that address
and you should see something like this:

Any source code changes will be updated live here so let’s see how that
works.
Leaving your current terminal tab open and running, so it can keep the React
app served, open your text editor and then open src/App.js. Right now, this
looks like a mess of HTML and JavaScript – welcome to JSX. That is how
XML syntax is added to JS by React, providing an intuitive way of building
components in React. At runtime, it gets compiled to JavaScript. 
As a final thing, change the text in the main paragraph in App.js to read
whatever you want it to read and save it. You should see those changes
reflected  on the browser page you opened earlier.
If you left the terminal running, you should be able to switch over to your
browser and see the update:
Congratulations! You’re now up and running with React. You can now begin
adding functionality for your application.

Conclusion
Thank you for taking the time to read my guide. I hope you found it helpful
and now have a good understanding of what React JS is all about. If you have
never built an app using React before, this guide should give you a good
grounding in how to do it. It is different from other libraries, primarily
because it uses JSX, a completely new language that defines how your
visuals will look.
But JSX goes way beyond this, way beyond UI elements. It changes how
your applications are built entirely. Your browser cannot understand native
JSX, so it needs to be converted to JavaScript, and that requires another step.
You could build your application to generate the JavaScript output to
correspond to the relevant JSX source. Or you could use Babel to translate
JSX into JavaScript within the browser. That way is fine for practice and for
getting familiar with React, but it will impact a live app's performance.
React is relatively new, but it is an established library that enables us to
create reusable view components. These components are sharable,
encapsulated, and can easily be maintained. More and more people are using
React in production environments, thanks in no small part to its having a very
active community that helps add new functionality to React almost every day.
It is most definitely worth learning, not least because the world needs more
experts in React to build better user interfaces and help existing companies
make a move to one of the best view libraries available today.
Once again, I hope you found this helpful, and I wish you luck on your front-
end development journey.

References
Animation in React. 2019, www.nearform.com/blog/animation-in-react/.
Atto, Edmond. “Understanding the Fundamentals of Routing in React.”
Medium, 20 Apr. 2020, medium.com/the-andela-way/understanding-
the-fundamentals-of-routing-in-react-b29f806b157e.
“Fullstack React: Introduction to Flux.” Fullstack React, 22 Oct. 2016,
www.newline.co/fullstack-react/30-days-of-react/day-18/.
“Getting Started – React.” Reactjs.org, 2019, reactjs.org/docs/getting-
started.html.
“Handling Events – React.” Reactjs.org, 2019, reactjs.org/docs/handling-
events.html.
“Higher-Order Components in React.” Smashing Magazine, 8 June 2020,
www.smashingmagazine.com/2020/06/higher-order-components-
react/.
“How to Build Forms in React.” DigitalOcean,
www.digitalocean.com/community/tutorials/how-to-build-forms-in-
react.
Priya, img class="avatar" src="https://iotvnaw69daj i optimole
com/AXVzL2w n2y9~6666f/w:60/h:60/q:90/https://www codeinwp
com/wp-content/uploads/2019/01/priya jpeg" alt="Priya" width="60"
height="60" />. “15 React Best Practices You Need to Follow in
2021.” CodeinWP, 5 Sept. 2019, www.codeinwp.com/blog/react-best-
practices/.
“React – a JavaScript Library for Building User Interfaces.” Reactjs.org,
2019, reactjs.org/.
“ReactJS - Component Life Cycle - Tutorialspoint.”
Www.tutorialspoint.com,
www.tutorialspoint.com/reactjs/reactjs_component_life_cycle.htm.

“ReactJS - Components - Tutorialspoint.” Www.tutorialspoint.com,
www.tutorialspoint.com/reactjs/reactjs_components.htm.
“ReactJS - Environment Setup - Tutorialspoint.” Www.tutorialspoint.com,
www.tutorialspoint.com/reactjs/reactjs_environment_setup.htm.
“ReactJS - Forms - Tutorialspoint.” Www.tutorialspoint.com,
www.tutorialspoint.com/reactjs/reactjs_forms.htm.
“ReactJS - Props Overview - Tutorialspoint.” Www.tutorialspoint.com,
www.tutorialspoint.com/reactjs/reactjs_props_overview.ht.
“ReactJS - Refs - Tutorialspoint.” Www.tutorialspoint.com,
www.tutorialspoint.com/reactjs/reactjs_refs.htm.
“ReactJS | Components.” GeeksforGeeks, 10 Mar. 2018,
www.geeksforgeeks.org/reactjs-components/.
“ReactJS | Keys.” GeeksforGeeks, 5 Apr. 2018,
www.geeksforgeeks.org/reactjs-keys/.
Wheeler, Ken. “Getting to Know Flux, the React.js Architecture.” Scotch,
scotch.io/tutorials/getting-to-know-flux-the-react-js-
architecture#:~:text=Flux%20is%20an%20architecture%20that.

JAVASCRIPT
JAVASCRIPT BACK END
PROGRAMMING
Andy Vickler

Introduction
Back-end development describes everything that goes on behind the scenes
when you do something on a web app or website. Mostly, it refers to the
application's server-side and the communication that goes on between the
front-end (the browser) and the database. In a nutshell, it focuses on how
everything works.
Node.js was developed in 2009 by Ryan Dahl, built on the Chrome
JavaScript Engine. According to the official documentation, Node.js is
designed to make it easy to build scalable, fast network applications using a
lightweight, efficient I/O model that is non-blocking and event-driven. That
makes it perfect for real-time, data-intensive applications running on
distributed devices.
It is open-source. It works cross-platform, using JavaScript to write
applications that can run inside the Node.js runtime in Linux, Windows, and
OS X. It provides a great library full of JS modules and making development
simple.
Who This Book is For
This book is aimed at people who already have experience in software
programming and want to go one step further. It will provide a sufficient
understanding of the primary Node.js components, together with simple,
practical examples.
Prerequisites
You must have at least a basic understanding of JavaScript and some ideas of
other technologies, such as CSS, HTML, AJAX, and so on.
Node.js Features
Event-Driven and Asynchronous – All Node.js APIs are
asynchronous, i.e., they are non-blocking. This means that a

Node.js server will never wait for data to come back from an
API; it will move on to the next one, and the Events notification
mechanism will help get the response from previous calls.
Fast – as it is built on the Google Chrome V8 JavaScript Engine,
it is one of the fastest libraries for code execution
Single-Thread, Scalable – using a single-thread model
containing event-looping, the server can respond in a non-
blocking manner, making it scalable. The single-threaded
program can serve many more requests than the traditional
servers, such as Apache HTTP.
No Buffering – data is never buffered in Node.js applications;
instead, it is output in large chunks.
If you really want to get to grips with back-end JavaScript programming, you
need to start with Node.js. so settle in and let's dive in.

Chapter One
Setting Up Your Node.js Environment
In this first chapter, it makes sense to start by setting up your Node.js
environment. Here. I will show you the tools you need and how to do it. You
can set up the Node.js development environment in Linux, Mac, Windows,
and Solaris and, regardless of platform, you will need the following:
Node.js
NPM – Node Package Manager
IDE – Integrated Development Environment or you can use any
compatible Text Editor.
Since version 0.6.0, the Node.js download has included the package manager,
so you won't need to do a separate install for it.
Windows
To install Node.js on Windows, go to https://nodejs.org. Your operating
system will automatically be detected, and the correct download link will be
displayed.
Click on the LTS or Current button to download the Node MSI – the Current
button is best as it gives you the latest version. Once the MSI is downloaded,
double-click on it, and you will see an installation screen like this:

Click on the Next button, and the License Agreement will appear; read it and
accept it and then click on Install.Node.js will be quickly installed on your
computer; click the Finish button to complete it.
Verify the Installation
Now that Node.js is installed, you can verify the installation by launching the
command prompt. Click on your Start bar, type in Command Prompt, and
click the result. Now type the following command:
node -v
If the installation were successful, you would see a screen showing your
Node version; if you don't see that, you need to try installing it again.
Mac and Linux
First, go to the official Node.js website – https://nodejs.org/en/download.

Click the right installer for your system, as seen in the screenshot below:
When the right package has downloaded, click on the installer, and the
Node.js Installation Wizard will load. Click the Continue button and follow
the on-screen steps. Once successful, you will see an installation summary
telling you where NPM and Node.js have been installed.

Verify the Download
Open your terminal window and verify the installation by typing the
following command (note, the $ sign is the command prompt):
node -v
You should see the version number shown on your screen.
Mac or Linux users also have an alternative method of installing Node.js.  It
involves using the Homebrew (Mac) or Linuxbrew (Linux) package manager
and installing Node.js directly from the command line. If you use Linux, you
will need to install extra dependencies, such as Ruby v 1.8.6 or above and
GCC v4.2 or above, before you can install Node.js.
When you are ready to install it, type the following command at the prompt:
$ brew install node
IDE Installation
Node.js makes use of JavaScript when it develops applications, so any text

editor tool or IDE can be used so long as it supports JavaScript.  That said, I
would recommend you use an IDE that has support for auto-complete
features for the Node.js API, for example, Sublime Text, Aptana, Eclipse,
Visual Studio, etc.
IDE – Visual Studio Code
Node.js application uses JavaScript to develop an application. So, you can
use any IDE or text editor tool that supports JavaScript syntax. However, an
IDE that supports auto-complete features for Node.js API is recommended,
e.g., Visual Studio, Sublime Text, Eclipse, Aptana, etc.
Visual Studio Code supports both TypeScript and JavaScript languages right
from the word go, and it also supports debugging. You will need the Node.js
runtime on your machine to run Node.js applications, though.
Once Node.js is installed on your system, including the Node Package
Manager, we can install VSC:
Windows
Open https://code.visualstudio.com/download and download VSC for your
system. When it's done, open the folder and run the installer – it will be called
VSCodeUserSetup (version).exe. When the License agreement age loads,
accept it and click on Next. On the next page, click on the option to Create a
Desktop Icon – this allows you easy access from your desktop. Click on Next

Lastly, click the Install button. When the installation is done, click on Finish,
and Visual Studio Code will open.
Mac
First, go to https://code.visualstudio.com/download and download the Mac
version of Visual Studio Code. The file downloads in .zip format; find it and
double-click to see the file contents. Find the file called Visual Studio
Code.app and drag it to your Applications folder. Double click the file to
open it
Hello World
Let's begin with VSC by creating the Hello World application.
Create a folder, call it hello, and then open your command prompt. Go to the
folder and go into VS Code. Here are the commands you need:
mkdir hello

cd hello
code.
Now go to the File Explorer toolbar and press the button that says New File;
call it app.js. When you use the file extension of .js, VSC can interpret it as a
JavaScript file and use the JS language service to evaluate the file contents.
In the app.js file, create a string variable and send its contents to the console,
like this:
var msg = 'Hello World';
console.log(msg);
You may have noticed that when you typed in console. you were
automatically presented with IntelliSense on the console object. VS Code
also knows that msg is a string and that it is based on the Hello World
initialization. As such, when msg is typed, IntelliSense will show you all the
msg string functions.
Save your file using CTRL+S, and now we can run the app. On your
terminal, type in:
node app.js
The output should be the words "Hello World.
The Integrated Terminal
VS Code also has an integrated terminal where you can run your shell
commands, but it also allows you to directly run Node.js without needing to
come out of VS Code when you run command-line tools.
To open the integrated terminal, go to View>Terminal, and when the terminal
opens, you can run Node.js from there.
Debugging Hello World
VS Code also has a built-in debugger, which helps debug your Node.js apps,
so let's try it with the Hello World application we created. First, we need a
breakpoint set in app.js, so place your editor cursor on line 1 and press F9.
Alternatively, click in the left gutter beside the line numbers – you will see a
red circle.
To begin debugging your code, go to the Activity bar and click on Run View.

Then click on the green arrow on the Debug toolbar or press F5. Your app
will now be debugged and, when it gets to the breakpoint, you can step
through the application. VS Code shows the debug mode as a different-
colored status bar, and you will see the DEBUG console on the screen.
That was a simple example with a simple code to show you how VS Code
works. Let's take it one step further and use it with a full-stack web app built
in Node.js. First, come out of the Hello World folder as you won't need it
anymore. If you want, you can delete it. Instead, we are going to create an
Express app.
An Express Application
Express is one of the most popular frameworks for building Node.js
applications and running them – we will be going over it in far more detail in
a later chapter; for now, this is just a quick example.
Express offers several tools, one of which is the Express Generator that helps
you create or scaffold a new application. Express Generator is an npm
module, and you install it using the npm command-line tool.
First, open your terminal and type npm –help to check that you installed it

properly – you should see documentation about its use on the screen.
Now install Express Generator using the following command:
npm install -g express-generator
Note the inclusion of the -g switch; this globally installs Express Generator
on your computer, allowing you to run it from wherever you want.
Next, use the command below to create a new application named
myExpressApp:
express myExpressApp --view pug
A new folder will be created, called myExpressApp, and it will contain your
application contents. The parameters at the end of the command, --view pug,
inform the generator it should use the pug template engine.
You will also need to install application dependencies, all of which are npm
modules do, navigate to the folder, and execute the npm install command:
cd myExpressApp
npm install
Now we need to make sure the application will run. In the generated Express
application is a file called package.json and, in that, is a start script that runs
node./bin/www – this will get the Node.js application running. Type the
following in a terminal within the Express app folder:
npm start
The Node.js web server starts up; navigate to http://localhost:3000, and you
can see the application running.
Close down the browser and open a terminal in the myExpressApp folder;
press CTRL+C to stop the server. Now open VS Code:
code .
If you used the integrated terminal to install the generator and create your
app, all you need to do is use File>Folder to open the app from the open VS
Code instance.
Great Code Editing

Open the app.js file and find the Node.js global object called __dirname.
Hover the cursor over it, and you will see that VS Code sees __dirname as a
string. And you can get IntelliSense against the framework. For example, you
can get IntelliSense against something you require in the code, such as
HTTP, while typing it in the VS Code.
VS Code uses declaration files of TypeScript type to provide VS Code with
metadata about the JS frameworks your application consumes. Type
declarations use TypeScript to enable Express to know the function and
parameter data types. This lets VS Code provide the best IntelliSense
experience, and there is no need for you to worry about downloading these
files – thanks to the Automatic Type Acquisition features, VS Code
automatically installs them.
You can also reference other modules in different files in your code. For
example, we needed the ./routes/index module in app.js, and that exports an
Express.Router class.
Debugging the Express App
First, your Express application needs a debugger configuration file created,
called launch.json. Go to the Activity bar and click on the Run icon. Then
click the Configure icon (it looks like a gear) in the Run view to create the
default launch.json file. In Configurations, make sure the type property is set
to node – this will ensure the Node.js environment is selected. When the file
has been created, VS Code looks for the start script in package.json and uses
the value as the program for the Launch Program configuration – in our case,
it is ${workspaceFolder}\\bin\\www.
{
"version": "0.2.0",
"configurations": [
{
"type": "node",
"request": "launch",
"name": "Launch Program",
"program": "${workspaceFolder}\\bin\\www"
}
]
}
Save the file and go to the Run View. Click the Configuration option and
ensure Launch Program is selected. Open app.js and set your breakpoint

where the Express app object is, near the beginning of the file, by clicking the
left gutter. Start the debug by pressing F5, and the server is started in a new
terminal. From the breakpoint, you can step through the code, create watches
and inspect the variables.
That ends this first chapter. Your Node.js environment has been set up, so
now we can look at the REPL terminal.

Chapter Two
Node.js - REPL Terminal
REPL or Read-Eval-Print-Loop is an interactive shell where Node.js
expressions are evaluated. REPL reads user-entered code, evaluates the result
of the interpretation, prints it so the user can see it, and loops until given the
signal to quit.
It comes built-in as a part of Node.js and gives users a quick and easy way to
explore and test JS code in the Node environment without needing to save
and store it in files first.
Prerequisites
To follow along with this chapter, you will need two things:
Node.js installed on your computer – see the previous chapter
Some knowledge of JavaScript and how to code in it
Step One — Start and Stop the REPL
So long as Node is installed on your computer, you also have the REPL. So
starting it is easy – open your command-line shell and type in the following:
node
This will bring up the REPL prompt, which looks like this:
>
When you see the > symbol, it tells you that JavaScript code can be input for
immediate evaluation.
Let's try an example. Type the following into the REPL to add two numbers:
> 2 + 3

Now press ENTER, and REPL does the evaluation and returns the result:
5
If you want to get out of the REPL, type .exit. Alternatively, press CTRL+C
twice or CTRL+D once, and you will go back to the shell prompt.
Now you know how to start and stop the REPL, let's look at using it for
simple JavaScript code execution.
Step Two — Execute Code in the REPL
You can use the REPL to quickly test your JavaScript code without creating
files to store it in, and virtually all Node.js or JavaScript expressions may be
executed here.  In step one, we tried an expression to add two numbers, so
now let's have a go at division.
Start a REPL:
node
And type the following at the prompt:
> 20 / 5
Press the ENTER key, and you will see, as you would expect, an output of:
4
We can also test string operations in the REPL. Let's try to concatenate a pair
of strings in the REPL. Type the following:
> "Hello " + "World"
Press ENTER again, and the REPL evaluates the result of the expression,
outputting:
'Hello World'
NOTE
You might have spotted that the output is enclosed in single quotes rather
than double. Unlike many other programming languages, the quotes used in
JavaScript strings have no effect on their value. If you used a single quote in
your string input, REPL is clever enough to change it to double quotes in the
output.

Calling Functions
When you write Node.js code, messages are commonly printed using the
global console.log method or another function similar to it.
Type the command below at the REPL prompt:
> console.log("Hey")
Press the ENTER key, and you should see the following:
Hey
undefined
The first line of the output is what we get from console.log. The message in
the string is printed to the stdout stream, which is your screen. Note the
absence of quotes – this is because console.log prints strings without them.
The second line that reads 'undefined' is the function's return value.
Creating Variables
Very rarely will you only be working with literals in JavaScript. When you
create variables in the REPL, it works much the same as when you work with
.js files.
Type the command below at the prompt:
> let age = 45
Press the ENTER key, and you will see the following:
undefined
As before, when we used console.log, the command's return value is
'undefined.' The variable called age will remain available until the REPL
session is closed. So, for example, you could multiply it by three, like this:
> age *
Press ENTER and the output will be:
135
Because the REPL returns values, there is no need to use functions like
console.log to see the output. By default, REPL values will automatically
show on the screen.

Multi-Line Blocks
Also supported are multi-line blocks. For example, we could create a function
that will add 10 to any given number.
Begin the function by inputting the following:
> const add10 = (num) => {
Press ENTER, and the prompt will change, looking like this: 
...
Why did it do that? Because the REPL saw a curly bracket at the end of the
command and assumed that there would be more lines of code, and these
must be indented. To make reading it easier, the REPL puts three dots and a
space on the following line, so the next code line looks like it is indented.
Enter the next two lines of this function, one line at a time, and press ENTER
after each one:
... return num + ;
... }
When you press ENTER after the closing bracket, the output will read: 
undefined
This is the value of the function being assigned to a variable, and the …
prompt is replaced once more with the > prompt.
undefined
>
Next, we can call add10() on a specified value:
> add10(10)
As you would expect, the output shows:
20
The REPL can be used to try pieces of JS code before you add them to your
programs. And, to make things even easier for you, there are some shortcuts
in the REPL.

Step Three — Mastering REPL Shortcuts
There are shortcuts in the REPL that can help to cut down on time spent
coding. For a start, it will retain a history showing all entered commands and
lets you go through them and repeat commands where needed.
For example, input this string:
"The answer to everything is 50"
The result from this is: 
'The answer to everything is 50'
We can edit this and change "50" to "40" so, at the prompt, press the UP
arrow to go to the last command used:
> "The answer to everything is 50"
Shift the cursor left, delete the 5, and input 4; press ENTER, and this is what
you see:
'The answer to everything is 40'
Carry on pressing the UP arrow, and it will take you back through your
command history until you get to the first one used in the current session.
Using the DOWN arrow will take you to the most recently used commands.
When you have finished playing about with this and seeing how it all works,
press the DOWN key repeatedly until you get back to the prompt.
To get the last value evaluated, you can use the underscore. Type it at the
prompt:
_
Then press the ENTER key
The output on the screen is the last string entered:
'The answer to everything is 40'
Also, in the REPL is an autocomplete function you can use on keywords,
variables, and functions. Let's say that you want to use the Math.sqrt function
to find a given number's square root; you would enter the first few characters:
> Math.sq
Press on the TAB key, and the function is autocompleted:

> Math.sqrt
Should there be more than one autocomplete possibility, REPL will show you
all the options available.
Try entering the following at the command:
> Math.
Press the TAB button twice, and you will be shown the potential
autocompletion options:
> Math.
Math.__defineGetter__      Math.__defineSetter__      Math.__lookupGetter__
Math.__lookupSetter__     Math.__proto__             
Math.constructor
Math.hasOwnProperty        Math.isPrototypeOf                       Math.propertyIsEnumerable
Math.toLocaleString        Math.toString              
Math.valueOf
Math.E                     
Math.LN10                                Math.LN2
Math.LOG10E               
Math.LOG2E                 
Math.PI
Math.SQRT1_2               Math.SQRT2                 
Math.abs
Math.acos                  
Math.acosh                               Math.asin
Math.asinh                
Math.atan                                              Math.atan2
Math.atanh                 
Math.cbrt                  
              Math.ceil
Math.clz32                 
Math.cos                   
              Math.cosh
Math.exp                   
Math.expm1                               Math.floor
Math.fround                
Math.hypot                 
Math.imul
Math.log                  
Math.log10                               Math.log1p
Math.log2                  
Math.max                                 Math.min
Math.pow                   
Math.random                
Math.round
Math.sign                  
Math.sin                                               Math.sinh
Math.sqrt                  
Math.tan                                              Math.tanh
Math.trunc
How many rows and columns you see depends on your shell screen size, but
the above list contains all the properties and functions from the Math module.
To get another line in the prompt without needing to execute the current line,
press the CTRL+C buttons.
Those are just a couple of the REPL shortcuts, and they all make your coding
far more efficient. However, something else also helps increase productivity,
and that's the REPL commands.
Step Four — The REPL Commands
Some specific keywords help control the REPL behavior, and each starts with

a dot (.).
.help
If you want to see all the commands available, use this command:
> .help
You won't see huge lists of them because there are not that many, but they are
all useful for helping you do things in the REPL:
.break    
If you get stuck, this can get you out
.clear    
Alias for .break
.editor   
Enter into editor mode
.exit     
Exit the REPL
.help     
Print the help message
.load     
Load JS into the REPL session from a file
.save     
Save evaluated commands from this session to a file
If you want to get out of the current expression, press ^C, or if you want to
exit the REPL, press ^D.
If you need refreshing on what a command does, simply go back to the .help
command to find out.
.break/.clear
You can exit from a multi-line expression by using .clear or .break. Let's start
a for loop, like this:
> for (let i = 0; i < 100000000; i++) {
If you want to exit from more lines, use the .clear or .break command rather
than inputting the next line. This will break you out of the loop:
... .break
A new prompt appears:
>
And the REPL goes to a new line without having to execute the code. This
works in a similar way to pressing CTRL+C.
.save and .load

You can use the .save command to store all code run since the REPL started
in a single file, while the .load command will run the JS code in a file in the
REPL.
Use the CTRL+D or  .exit command to get out of the session and start a new
session using node. The only code saved will be what you are going to write
now. Create an array listing some vegetables:
> vegetables = ['pepper', 'onion', 'potato']
The next line will show you the REPL output:
[ 'pepper', 'onion', 'potato' ]
Save this to a file and call it vegetables.js
> .save vegetables.js
Now you will see the following message:
Session saved to: vegetables.js
The file will be saved to the directory where the REPL was opened. For
example, if it was opened in your home directory, that's where your file will
be saved:
Come out of the session and use node to open a new REPL. Load the file at
the prompt like this:
> .load vegetables.js
The result will be
vegetables = ['pepper', 'onion', 'potato']
[ 'pepper', 'onion', 'potato' ]
The .load command can be used to read each code line and execute it, as you
would expect a JavaScript interpreter to do. Now the vegetables variable can
be used as though it had been in the current session all the time.
Type in the following:
> vegetables[1]
Press ENTER, and you will see the following output:
'onion'

Any JavaScript file can be loaded with this command, not just the items you
save. To show you a quick demonstration of this, open your code editor or, if
you are using it, a command-line editor called nano. Now create a file and
call it walnuts.js:
You can load any JavaScript file with the .load command, not only items you
saved. Let's quickly demonstrate by opening your preferred code editor
or nano, a command-line editor, and create a new file called walnuts.js:
nano walnuts.js
With the file open, input the following:
Now that the file is open, type the following:
walnuts.js
console.log('I love walnuts!');
Save and exit by pressing CTRL+X and, in the directory where walnuts.js
was saved, start the REPL using node. Then load the walnuts.js file in the
session:
> .load walnuts.js
Using the .load command, you can execute the console statement, and you
will see the following:
console.log('I love walnuts!');
I love walnuts!
undefined
>
If you end up using REPL for longer than you thought you would, or you
have a piece of code that you want to go further into or share, use the .load
and .save commands to help you.
That was a brief look at the REPL in Node.js. In the next chapter, we will
look at the package manager.

Chapter Three
Node.js - Package Manager (NPM)
By January 2017, the npm had more than 350,000 different packages and,
with that number continually increasing, it is now one of the largest language
code repositories in the world. It’s safe to say that, if you can think of it, there
is likely to be a package for it!
Npm started life as a way of downloading Node.js packages and managing
their dependencies. It has now become one of the most popular tools for use
in frontend JavaScript development and is used for lots of different things:
Downloads and Installing Dependencies
Npm is used to manage all your project’s download dependencies.  If your
package contains a file called package.json, running npm install will ensure
that your project gets everything it needs. This will all be installed in a folder
called node_modules – if that folder doesn’t already exist, npm will create it.
Installing and Updating Packages
Single packages can be installed by running the following command:
npm install <package-name>
More often than not, other flags will be added to the command, like:
--save – this installs and then adds an entry to the file called
dependencies in package.json
--save-dev -this installs and then adds an entry to the file called
dependencies in package.json
The difference between these is that devDependencies tend to be
development tools, such as testing libraries, and dependencies are found
bundled in the app.

You can also update packages by running this command:
npm update
npm checks every package, looking for an updated version that matches the
restraints of your version. And if you have a single package you want to be
updated, simply specify the package name:
npm update <package-name>
Versioning
As well as standard downloads, you can also use npm for versioning,
allowing you to specify a specific package version or ask for a version above
or below the one you need. Most of the time, libraries are only compatible
with another library’s major release. Or you may have a lib causing an issue
because it has an unfixed bug in it.
When you explicitly specify a library version, it helps everyone stay on that
version, ensuring an entire team is working on the same version until
package.json gets updated.
In cases like these, versioning is helpful, and npm will always follow the
semver (semantic versioning) standard.
Running Tasks
The format to specify command-line tasks is supported by package.json and
you can run these tasks with this:
npm run <task-name>
Here’s an example:
{
"scripts": {
"start-dev": "node lib/server-development",
"start": "node lib/server-production"
},
}
It is also common to run Webpack using this feature too:
{
"scripts": {
"watch": "webpack --watch --progress --colors --config webpack.conf.js",
"dev": "webpack --progress --colors --config webpack.conf.js",

"prod": "NODE_ENV=production webpack -p --config webpack.conf.js",
},
}
Instead of having to type long commands, of having to try remembering them
and making sure you don’t mistype them, you can do this instead:
$ npm run watch
$ npm run dev
$ npm run prod
Where Does npm Install the Packages?
When npm is used to install packages, you can use two installation types –
local or global installation.
When you type install commands in npm, like this:
npm install lodash
by default, the package gets installed in the current tree, in the subfolder
called node_modules. At the same time, the lodash entry is also added to the
dependencies property in package.json in the current folder.
To do a global installation, you need to add the -g flag:
npm install -g lodash
This time, the package uses a global location instead of installing the package
in the local folder. But where?
The root -g command tells you the exact location on your computer. On a
Linux or Mac system, this might be /usr/local/lib/node_modules, while on
Windows, 
it 
might 
be 
in
C:\Users\YOU\AppData\Roaming\nom\node_modules.
If you manage Node.js versions using npm, those locations would be
different.
Using or Executing Packages Installed With npm
When you use npm to install a package in the folder called node_modules, or
globally, how is that used in Node.js code. Let’s say you install the popular
JS utility library, lodash, using this command:

npm install lodash
The package will be installed in the local node_modules folder. Using it in
your code requires that you import it to the program using the require
command:
const _ = require('lodash')
So, what about if you have an executable package?
The executable file would go to the node_modules/.bin/ folder instead.
One of the easiest ways to demonstrate this is using the cowsay package,
which has a command-line program. This program can be executed to make
an animal, like a cow, say something.
When the package is installed like this
npm install cowsay
it installs along with required dependencies in the node_modules folder:
A hidden bin folder contains the symbolic links pointing to the cowsay
binaries:

So, how are these executed?
You could run it by typing ./node_modules/.bin/cowsay and it will work.
However npx, which is in recent npm versions, is better. All you do is run:
npx cowsay
And the package location will be automatically found.

Chapter Four
Node.js Callbacks and Promises
When you first start out with Node.js, one of the first things you are likely to
come across is callbacks. Before we look into what callbacks are, we need to
know why they exist, and this is down to Node's asynchronous nature. Most
people know that asynchronous programming is “better but harder.” That
might sound somewhat simplistic so let’s look at it by comparing
synchronous with asynchronous code.
The first thing you will see is that the asynchronous version of code is
nothing short of ugly. It looks like it is overly complicated, but we’re not
getting that much more out of it than we do from synchronous code.
However, it’s undeniable that there are gains, so let’s talk about them.
Asynchronous code is pretty cool in that while your code is hanging about,
waiting for something like an API call or a database response, it isn’t hanging
about not doing anything. With synchronous code, when it’s doing
something, it blocks up your code, and if it takes a long time to do that thing,
it brings everything else to a halt. With asynchronous code, you can get on
with other things at the same time. This is one of the primary reasons why
Node.js even exists – asynchronous servers can get on with processing
requests while waiting for I/O or Input/Output.
Yes, when you do asynchronous programming, which we will be delving
deeper into in the next chapter, things do feel more complicated, but it isn’t
that hard to understand, and it offers benefits that are well worth the time it
takes to understand it.
So, now we understand that a little better, let’s get deeper into callbacks.
What, exactly, are they?
Callbacks are nothing more than functions passed to other functions as
arguments, which the receiving function will then use, or call it back.

Have a look at this simple example of a callback function in action:
fs.readFile(funFileName, function(err, file) {
    if(err)
        handleError(err);
    console.log("file: ", file)
})
Once fs.readFile has fetched the funFileName file, the callback function is
executed. This function will then handle any errors thrown, logging the file it
retrieves to the console.
The callback function takes two arguments or parameters – err and file.
Convention dictates that the callback function’s first argument is an error. If
the parent function throws an error, it is there to be dealt with but, if an error
is not thrown, which does happen sometimes, the function’s first argument
must be null. Convention also dictates that the functions that follow this are
the response data.
Ok, so that’s fine but, why didn’t we just write our code like this?
let file = fs.readFile(fooFileName);console.log("file: ", file);
The short answer to that is async.
The second example shows that the file is not defined when we try logging it.
This is because fs.readFile won’t have finished fetching before we reach
console.log().
However, it is worth noting that the following will work:
let file = 1+1;console.log("file: ", file);
To those of you who really are new to this and have only worked with
synchronous programming, this will feel somewhat confusing, not to mention
a little cumbersome. With synchronous programming, your life has been
easy, filled with logic, and then, all of a sudden, line four can be executed
before line three! So, should callbacks be used all over the place, all of the
time, just in case? The answer to that is a resounding no.
You should only ever use a callback when you don’t know that something is
going to be done. Again, think of getting data from databases, API calls, and
so on. These all take time, so the callback needs to be called when the event
has happened, which is where we get the term “event-driven programming.”

If you don’t feel like you really understand this right now, don’t worry – you
are not the only one, and the only real way to understand it is to do it. 
Let’s move onto a more in-depth look at asynchronous programming and all
it entails.

Chapter Five
Asynchronous JavaScript Programming
In this chapter, we are going to look at asynchronous JavaScript
programming but, first, we need to look back at some of the issues of
asynchronous JavaScript. We’ll then look at asynchronous techniques and
show how they can help us get around these problems.
Synchronous JavaScript
To understand asynchronous JavaScript, we must first understand
synchronous JavaScript. Much of the basic JavaScript code you see revolves
around synchronous code – you run code and, as soon as the browser is able
to, it returns the result. Here’s a very simple example:
const btn = document.querySelector('button');
btn.addEventListener('click', () => {
alert('You clicked on me!');
let pElem = document.createElement('p');
pElem.textContent = 'This is a new paragraph.';
document.body.appendChild(pElem);
});
Here, each line is executed one after the other:
First, we get a reference to a readily available <button> element in the DOM.
Then a click event listener is added; when the button gets clicked, four things
happen in order:
1. An alert() message is displayed
2. After dismissing the alert, a <p> element is created
3. The element is then provided with text
4. The paragraph is appended to the document body
Now, here’s where the problem with synchronous code lies – JavaScript is

single-threaded so, while each of those operations listed above is happening,
nothing else can. Each step is dependent on the previous one completed
before it can run – until it does, all other operations are blocked. Take the
example above – once the button is clicked, the alert message appears. Until
the OK button on the message has been clicked, the paragraph will not
appear.
NOTE
While alert() is useful for demonstrating how synchronous blocking
operations work, it isn’t suited for real-world applications.
Asynchronous JavaScript
Because of the issues surrounding blocking, most Web APIs prefer to run
asynchronous code, especially where the application needs to fetch or have
access to an external resource. That could include getting a file off the
network, getting into a database to return data from it, accessing a web cam’s
video stream, broadcasting display onto a VR headset, and so on.
So, why can’t we do this using synchronous code? We can demonstrate that
with an example. When an image is fetched from the server, the result cannot
be immediately returned, which means the code below, which is pseudocode,
will not work.
let response = fetch('myImage.png'); // fetch is asynchronous
let blob = response.blob();
// somehow display image blob in the UI
The code doesn’t work because we have no idea how long it will take the
image to download. So, when the second code line is run, an error is thrown –
this may be every time, or it may be intermittent – because there is no
available response. You really need your code to wait for the response before
it attempts anything else.
Asynchronous code comes in two styles – callbacks and promise-style, which
is the newer code style. We’ll look at both of these now.
Async Callbacks
A callback is a function that we specify as an argument when we call a
function that executes background code. Once the background code is run,

the callback function is called to tell you that the work is complete or that
something interesting has happened. Callbacks are old-fashioned, but they are
still in use in some of the older but common APIs.
In the code above, we saw an example of one async callback – it was in the
addEventListener() method as the second parameter:
btn.addEventListener('click', () => {
alert('You clicked on me!');
let pElem = document.createElement('p');
pElem.textContent = 'This is a new paragraph.';
document.body.appendChild(pElem);
});
The first parameter indicates what event type we want to listen for, while the
second is the callback function, not invoked until the event has fired.
When a callback function is passed to another function as a parameter, all we
do is pass a reference to the function as the argument; for example, the
callback function does not get immediately executed.  The containing
function executes the callback when the time is right.
It is simple enough to write functions containing callbacks. Here’s an
example that loads resources using XMLHttpRequest API:
function loadAsset(url, type, callback) {
let xhr = new XMLHttpRequest();
xhr.open('GET', url);
xhr.responseType = type;
xhr.onload = function() {
callback(xhr.response);
};
xhr.send();
}
function displayImage(blob) {
let objectURL = URL.createObjectURL(blob);
let image = document.createElement('img');
image.src = objectURL;
document.body.appendChild(image);
}
loadAsset('coffee.jpg', 'blob', displayImage);
A displayImage() function is created to represent a blob. This blob has been
passed to the function as an object URL; an image is created to show the

URL in, and this is appended to the <body> of the document. A loadAsset()
function is created, taking a parameter which is a callback and content type
and a URL to fetch. XMLHttpRequest, often seen as XHR, is used to fetch
the resource from the specified URL, and the response is passed to the
callback so it can do something with it. In our case, the callback waits for
XHR to use the onload event handler to download the resource, which then
gets passed back to the callback.
Callbacks are quite versatile in that they let you control what order the
functions are run in and determine the data that passes between them, but
they also let you pass data to other functions, dependent on the current
situation. In that way, different actions can run on the downloaded response,
such as displayText(), processJSON(), and so on.
Be aware that not every callback is async; some are synchronous, and one
example of that is when Array.prototype.forEach() is used for looping
through an array of items:
const gods = ['Apollo', ‘Demeter’, 'Ares', 'Hades'];
gods.forEach(function (eachName, index){
console.log(index + '. ' + eachName);
});
Here, an array containing names of Gods is looped, though, and the index
numbers and relevant values are printed to the console. The forEach()
parameter is a callback function, and this also accepts two parameters. These
are references to the array name and the index values. However, what it
doesn’t do is wait – it will run straight away.
Promises
Promises are the newest async code style typically used in today’s Web APIs.
One of the best examples is an API called fetch(), which is a modern version
of XMLHttpRequest and is far more efficient. Here’s an example:
fetch('products.json').then(function(response) {
return response.json();
}).then(function(json) {
products = json;
initialize();
}).catch(function(err) {
console.log('Fetch problem: ' + err.message);
});

In this code, fetch() takes just one parameter: the URL of the network
resource you want to fetch, and it returns a promise. Promises are objects that
represent the failure or the completion of an async operation, a representation
of an intermediate state if you like. It is just the browser saying to you that it
promises to get an answer back to you as soon as possible – and that is where
the name comes from.
This can take a little getting used to and feels somewhat like Schrodinger’s
cat – none of the potential outcomes has happened, and fetch() is waiting for
the browser result, which will come sometime in the future. There are also
another three blocks of code chained to the fetch():
There are two then() blocks, both of which have a callback
function. This function runs only if the operation before it is
successful, and each of the callbacks receives an input of the
result of that previous operation. That way, you can continue on
and do something else. The .then() blocks return a promise and
several .then() blocks can be chained together, allowing
asynchronous operations to run, one after the other, in order.
There is also a catch() block at the end, which will only run if
one or both .then() blocks fail. Like the try…catch blocks in
synchronous JavaScript, the catch() block has an error object in
it, which is used to report any errors that occur. It is worth noting
that the synchronous try…catch doesn’t work with promises.
The Event Queue
Async operations, such as promises, are placed into event queues. To avoid
the subsequent code from getting blocked, these queues run once the main
thread has been processed, and when the queued operations are finished, they
return their results to JavaScript.
Promises vs. Callbacks
Promises are somewhat similar to callbacks and are nothing more than
returned objects with callback functions attached rather than callbacks passed
into a function. But promises have been specifically designed for async
operations and have several advantages over the callback:
Several async operations can be chained together with as many

.then() operations as needed. The result is passed from one as an
input to the next, something that is hard to do with callbacks –
try it and you end up with a complete mess.
Promises are always called in the exact order they go into the
event queue.
It is easier to handle errors as they are all taken care of with one
.catch() block, placed at the end, instead of being handled
individually at each level.
Promises also get away inversion of control, whereas the old
callbacks lose control of function execution when a callback is
passed to a third-party library.
Asynchronous Code Nature
Let’s look at another example showing the real nature of asynchronous code.
It shows what could happen when we don’t fully know what order the code
will execute in and the consequences of treating asynchronous and
synchronous code the same.  This is a similar example to what we have
already looked at but, this time, several console.log() statements are included
to show the order that you might assume the code will execute in:
console.log ('Starting');
let image;
fetch('coffee.jpg').then((response) => {
console.log('It worked :)')
return response.blob();
}).then((myBlob) => {
let objectURL = URL.createObjectURL(myBlob);
image = document.createElement('img');
image.src = objectURL;
document.body.appendChild(image);
}).catch((error) => {
console.log('There is a problem with your fetch operation: ' + error.message);
});
console.log ('All done!');
The browser starts to execute the code. It sees the initial console.log()
statement and executes it, followed by the image variable being created. Then
it goes to the following line and starts to execute the fetch() block. However,
the fetch() asynchronously executes without blocking and, after the code

related to the promise is executed, the rest of the code continues. Thus, the
last console.log() is reached, and the result is output on the console.
Only when fetch() is finished, and the result is delivered via the .then() blocks
will the second of the console.log() messages appear on the console. As you
see, the messages appear in an order that doesn’t relate to what you would
expect:
Starting
All done!
It worked :)
If you find this confusing, have a look at this example:
console.log("registering click handler");
button.addEventListener('click', () => {
console.log("get click");
});
console.log("all done");
This is much the same in the way it behaves – the first and the third
console.log() messages are immediately shown, but the middle one has been
blocked until the mouse button is clicked. In the first example, the difference
was that the middle message was blocked, waiting for a resource to be
displayed on the screen rather than a button being clicked.
This kind of setup could cause real issues in less trivial code. Async code
blocks cannot be included if they return a result that is then relied on in a later
sync block. There is no way of guaranteeing the async function returns before
the browser processes the sync block.
To see how this works, take the following as an example:
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Simple async sync example</title>
</head>
<body>
<script>
console.log ('Starting');
let image;

fetch('coffee.jpg').then((response) => {
console.log('It worked :)')
return response.blob();
}).then((myBlob) => {
let objectURL = URL.createObjectURL(myBlob);
image = document.createElement('img');
image.src = objectURL;
document.body.appendChild(image);
}).catch((error) => {
console.log('There is a problem with your fetch operation: ' + error.message);
});
console.log ('All done!');
</script>
</body>
</html>
Change the fourth console.log() to:
console.log ('All done! ' + image.src + 'displayed.');
Now your console should display an error rather than message three:
TypeError: image is undefined; can't access its "src" property
This happens when the browser attempts to run console.log() number three
and the fetch() block hasn’t completed – the image variable does not yet have
a value.
NOTE
You cannot use fetch() to get files off your local filesystem, for security
reasons, so you will need to run the example above through a local
webserver.
Fixing this fetch() problem and ensuring that all the console.log() statements
appear in the order you want could be done by making the third one run
async. You do this by putting it inside a .then() block chained to the second
one, or you could place it in the second .then() block.

Chapter Six
Node.js Event Loops 
and Event Emitters
Event loops help Node.js carry out non-blocking I/O operations, even though
JS is a single-threaded language. To do this, operations are offloaded to the
system kernel whenever it is possible to do so.
These days, kernels are multi-threaded, which means they can handle several
operations at once as they execute in the background.  When one has
completed, the kernel lets node.js know, ensuring the right callback goes on
the poll queue to be executed at some point. You will understand this by the
end of the chapter.
When Node.js is started, the event loop is initialized. The input script
provided is processed or dropped onto the REPL – this can take schedule
timers, async API calls, or it can call process.nextTick() - and the event loop
is processed.
In the diagram below, you can see a simple overview of the order of
operations in the event loop:
┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
└───────────────────────────┘

Each of the boxes in the above diagram is called event loop phases.  Each
phase contains a FIFO (First In First Out) queue of callbacks that need
executing. When the event loop goes into any phase, the phase-specific
operations are performed, and the callbacks in the phase queue are executed
until they are all done, or the callback limit has been reached. When this
happens, the event loop goes to the next phase and so on throughout the
order.
Any one of the operations can result in more operations being scheduled, and
the kernel queues new events processing in the poll phase. It is possible for
poll events to be queued at the same time as polling events get processed. The
result of this is much longer running callbacks, leading to the poll phase
running for longer than the timer allows.
Phase Overview
Between each, the event loop runs, Node.js looks to see if any timers or
asynchronous I/O needs to be run; if not, it will cleanly shut down.
Timers
Timers are used to specify the threshold after which given callbacks are
executed instead of waiting for the exact time someone requires executions.
These callbacks run as soon as they are scheduled after the threshold but may
be delayed by other callbacks scheduling in the operating system. Technically
speaking, the timer executions are controlled by the poll phase.
Let’s say you want a timeout scheduled to execute after a threshold of 100ms;
in that case, your script would begin asynchronous reading of a file that takes
95 ms:
const fs = require('fs');
function someAsyncOperation(callback) {
// This takes 95ms to complete
fs.readFile('/path/to/file', callback);
}
const timeoutScheduled = Date.now();
setTimeout(() => {
const delay = Date.now() - timeoutScheduled;
console.log(`${delay}ms have passed since scheduling`);
}, 100);

// do someAsyncOperation that takes 95 ms to complete
someAsyncOperation(() => {
const startCallback = Date.now();
// do something else that takes 10ms...
while (Date.now() - startCallback < 10) {
// do nothing
}
});
When the event loop goes into the poll phase, there is an empty queue –
fs.readfile() has not completed – so the loop waits for the specified number of
remaining ms until the threshold for the earliest timer is reached. In the
meantime, fs.readFile() continues reading the file, and the callback, taking 10
ms, gets put on the poll queue and then executed. Once the callback is
complete, all the queued callbacks are finished, and the event loop can see
that the soonest timer’s threshold is reached. It goes back to the timers phase,
and the timer callback is executed. The delay between the scheduled timer
and execution of its callback is 105 ms in this example.
NOTE
Preventing starvation of the event loop by the poll phase requires a library
called libuv have a hard maximum before it ceases to poll for new events.
That maximum is system-dependent. Libuv is a C library responsible for
implementing the event loop and all the platform’s asynchronous behaviors.
Pending callbacks
The pending callbacks phase is responsible for executing callbacks for
system operations like TCP error types. For example, if ECONNREFUSED
is received by a TCP socket during an attempt to connect, the error may not
be reported immediately by some *nix systems. Instead, it gets queued in the
pending callbacks phase, waiting for execution.
This phase executes callbacks for some system operations, such as types of
TCP errors. For example, if a TCP socket receives ECONNREFUSED when
attempting to connect, some *nix systems want to wait to report the error.
This will be queued to execute in the pending callbacks phase.
Poll
There are two main functions to the poll phase:
To calculate the length of time to block and poll for I/O

Process poll queue events
When the event loop goes into the poll phase, if no timers have been
scheduled, one of the two things below can happen:
1. If the queue isn’t empty, the loop iterates through the callback
queue, asynchronously executing them until the hard limit is
reached, or the queue is empty
2. If the queue is empty, one of two things can happen:
If setImmediate() has been used to schedule scripts, the
poll phase is ended by the event loop. The loop then goes
on to the check phase and executes all the scheduled
scripts.
If setImmediate() has not been used to schedule the
scripts, the event loop waits until callbacks are added to
the queue, at which point, they will be immediately
executed.
When there is nothing left in the poll queue, the event loop looks for timers
who have reached their time thresholds. If there is at least one ready, the
event loop goes back to the timers phase and executes the callbacks.
Check
The check phase allows callbacks to execute immediately upon completion of
the poll phase. If the phase is idle and setImmediate() has queued some
scripts, the loop continues checking the phase instead of waiting.
setImmediate() is a timer, a special one running in a different event loop
phase. The libuv API is used to schedule the execution of callbacks once the
poll phase is complete. Typically, when code is executing, the event loop has
to hit the poll phase at some point. It waits there for incoming requests,
connections, etc., but if setImmediate has been used to schedule a callback
and the poll phase is idle, rather than wait for the poll events, the loop will
end and carry on to the check phase.
Close Callbacks

If a handle or socket has been abruptly closed, i.e., with socket.destroy(), the
‘close’ event is emitted during the close callbacks phase. Otherwise,
process.nextTick() is used to emit it instead.
setImmediate() vs setTimeout()
These are quite similar, but when they are called, they may act in different
ways.
setImmediate() executes scripts when the current poll phase is
done
setTimeout() schedules a script to run once a minimum ms
threshold has elapsed
The order of execution varies and is dependent on the calling context. If they
both get called from the main module, the process performance binds their
timing, but other machine applications can impact the performance.
Let’s say, for example, that the following script is run. It is not in the main
module, which is an I/O cycle so the order of execution is non-deterministic
as the performance process binds it:
// timeout_vs_immediate.js
setTimeout(() => {
console.log('timeout');
}, 0);
setImmediate(() => {
console.log('immediate');
});
$ node timeout_vs_immediate.js
timeout
immediate
$ node timeout_vs_immediate.js
immediate
timeout
On the other hand, if the two calls are placed within an I/O cycle, the
immediate one is the first to be executed:
// timeout_vs_immediate.js
const fs = require('fs');
fs.readFile(__filename, () => {
setTimeout(() => {
console.log('timeout');

}, 0);
setImmediate(() => {
console.log('immediate');
});
});
$ node timeout_vs_immediate.js
immediate
timeout
$ node timeout_vs_immediate.js
immediate
timeout
Using setImmediate() has one primary advantage over setTimeout(); if it is
scheduled in an I/O cycle, it is executed first, before the timers, regardless of
how many there are.
process.nextTick()
You might also have seen that process.nextTick() is not in the diagram above,
despite it being a part of the asynchronous API. Technically, it is not a part of
the event loop. nextTickQueue is processed first once the current operation is
finished, no matter what the event loop’s current phase is.
Going back to that diagram, whenever process.nextTick() is called in a phase,
all the callbacks passed to it get resolved before the event loop can continue.
However, this can lead to bad stuff happening – because recursive
process.nextTick() calls are made, it lets your I/O starve. This stops the event
loop from getting to the poll phase.
So, why would Node.js allow this to happen? It is part of the design
philosophy that allows for an API always being asynchronous, whether it
needs to be or not. Have a look at this example:
function apiCall(arg, callback) {
if (typeof arg !== 'string')
return process.nextTick(callback,
new TypeError('argument should be a string'));
}
The code checks the argument, and if it isn’t right, the error is passed to the
callback. The recently updated API allows arguments to be passed to
process.nextTick(), which means it can take arguments that were passed after
the callback. These are then propagated as callback arguments, eliminating
the need to nest functions.

What we have done is passed an error to the user, but this only happens when
the rest of the user code has been executed. Process.nextTick allows a
guarantee that the apiCall() callback is run only once the remaining user code
and before the event loop can go on. Achieving this is done by allowing the
JS stack to unwind. Then the specified callback is immediately executed,
allowing recursive calls to be made to process.nextTick() without getting to a
RangeError: Maximum call stack size exceeded from v8.
However, this can cause some problems. Have a look at this code:
let bar;
// the signature is asynchronous but synchronously calls callback
function someAsyncApiCall(callback) { callback(); }
// the callback gets called before `someAsyncApiCall` is finished.
someAsyncApiCall(() => {
// because someAsyncApiCall hasn't finished, bar doesn’t get a value assigned
console.log('bar', bar); // undefined
});
bar = 1;
someAsyncApiCall() is defined with an asynchronous signature even though
it is synchronous in its operations. When called, the someAsyncApiCall() is
called in the event loop phase because someAsyncApiCall() does nothing
asynchronously. This is because the callback attempts to reference bar despite
the variable potentially not being in scope because the script has not been
completed.
When you put the callback in process.nextTick(), the script can still complete,
allowing initialization of all the functions, variables, etc., before the callback
is called. It also stops the event loop from continuing. It could also be useful
for alerting the user to an error before the event loop can proceed. Here’s the
previous process.nextTick() example:
let bar;
function someAsyncApiCall(callback) {
process.nextTick(callback);
}
someAsyncApiCall(() => {
console.log('bar', bar); // 1
});
bar = 1;

And another real-world example:
const server = net.createServer(() => {}).listen(8080);
server.on('listening', () => {});
When it is just a port being passed, the port is immediately bound. This
means the listening callback could be immediately called, but there’s a
problem – the on(‘listening’) callback will not yet have been set. Getting
around this requires that the listening event go into a nextTick() queue to
complete the script. This way, users can set whatever event handlers are
required.
process.nextTick() vs setImmediate()
These are very similar calls but with confusing names:
process.nextTick() will immediately fire on the same phase
setImmediate() will wait for the following event loop iteration or
tick before firing.
Really, these two names should be swapped over, given that
process.nextTick() is more immediate to fire than setImmediate(). However,
this is something that comes from the early days isn’t likely to change. The
simple reason for that is because it breaks quite a lot of the npm packages.
More modules get added daily, and that leads to more potential breakages, so,
while confusing, the names will not change.
It is our recommendation that you use setImmediate() all the time.
Why process.nextTick()?
There are a couple of good reasons why you should use process.nextTick():
Users can better handle errors, clean out any resources they don’t
need, or submit requests again before the loop carries on.
Sometimes, a callback needs to run between the call stack
unwinding and the event loop continuing.
One of the best examples is matching user expectations and a simple example
of that is:

const server = net.createServer();
server.on('connection', (conn) => { });
server.listen(8080);
server.on('listening', () => { });
Let’s assume that we have listen() running at the start of the event loop, but
the callback is in setImmediate(). If a hostname is not passed, port binding
happens straight away. The event loop needs to get to the poll phase before it
can proceed, and that means a non-zero chance of a connection being
received so the connection event could be fired before the listening event.
Another example would be to run a function constructor that inherits from
EventEmitter and wants an event called in the constructor:
const EventEmitter = require('events');
const util = require('util');
function MyEmitter() {
EventEmitter.call(this);
this.emit('event');
}
util.inherits(MyEmitter, EventEmitter);
const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
console.log('an event occurred!');
});
An event cannot be emitted immediately from a constructor because the
script hasn’t processed far enough for the user to assign the event a callback.
In the constructor, process.nextTick() can be used to set a callback. The event
is emitted by the callback once the constructor is done, and this gives the
results the user expects:
const EventEmitter = require('events');
const util = require('util');
function MyEmitter() {
EventEmitter.call(this);
// use nextTick to emit the event when a handler is assigned
process.nextTick(() => {
this.emit('event');
});
}
util.inherits(MyEmitter, EventEmitter);
const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
console.log('an event occurred!');
});

Chapter Seven
Node.js Buffers
While pure JavaScript is good for using with Unicode-encoded strings, it
isn’t very good where straight binary data is concerned. On a browser, most
data is in string format, so this is fine but, things are different for the Node.js
servers. These also have TCP streams to deal with, and they need to read the
filesystem and write to it. Both of these mean that we also need to deal with
binary data streams.
One way of handling this is to use strings, which is what Node.js used to do.
However, this is a troublesome approach – not only is it slow, but it also
means you are working with APIs for strings and not with binary data. And
they also seem to break quite easily in very strange ways.
So, what do you use instead of a binary string? A buffer.
What Are Buffers?
InNode.js, the Buffer class is meant for handling raw binary data. Every
buffer corresponds to raw memory that has been allocated externally to V8.
Buffers are quite similar in the way they act to integer arrays, but they cannot
be resized, and they include tons of methods designed specifically for
handling binary data. In a buffer, the integers represent bytes, one byte for
each buffer, and that means they are limited in values to between 0 and 255
inclusively. When you print the Buffer instance using console.log(), the result
is a chain full of hexadecimal values.
Typically, the context buffers are seen in is binary data coming out of
streams, like fs.createReadStream.
Creating Buffers
There are several ways a buffer can be created:
var buffer = Buffer.alloc(8);
// This prints 8 bytes of zero:

// <Buffer 00 00 00 00 00 00 00 00>
This way, the buffer has been initialized and has eight zero bytes.
var buffer = Buffer.from([ 8, 6, 7, 5, 3, 0, 9]);
// This prints 8 bytes of certain values:
// <Buffer 08 06 07 05 03 00 09>
This way, the buffer is initialized to the array contents. Bear in mind that the
array contents are integers that represent bytes.
var buffer = Buffer.from("I'm a string!", "utf-8");
// This prints a chain of values in utf-8:
// <Buffer 49 27 6d 20 61 20 73 74 72 69 6e 67 21>
In this third way, the buffer is initialized to a binary encoding. This is the first
string that the second argument specifies – utf-8. This is one of the most
common methods of encoding with Node.js.
Writing to Buffers
Given that we already created a buffer:
> var buffer = Buffer.alloc(16)
Strings can be written to it:
> buffer.write("Hello", "utf-8")
5
Buffer.write’s first argument is the string that needs to be written to the
buffers, while the second one is the string encoding. Because it defaults to
utf-8, the argument is irrelevant.
We got a result of 5 from buffer.write, which means the first five bytes were
written to the buffer. It is pure coincidence that the string “Hello,” also
happens to be five characters long because each character is coincidentally 8
bits. That is useful information for when you want the message completed:
> buffer.write(" world!", 5, "utf-8")
7
When there are three arguments to buffer.write, the second one is indicative
of an offset, which is the buffer index to begin writing at.
Reading from Buffers:
toString:

The commonest way of reading buffers is with the toString method because
the vast majority of buffers have text in them:
> buffer.toString('utf-8')
'Hello world!\u0000k\t'
Once again, the initial argument is the encoding and, here, we can see that not
all the buffer was used. However, because we happen to know the number of
bytes written to the buffer, we can just add some more arguments, allowing
us to stringify the interesting slice:
> buffer.toString("utf-8", 0, 12)
'Hello world!'
Individual Octets
It is also possible to use a syntax similar to an array to set individual bytes:
> buffer[12] = buffer[11];
33
> buffer[13] = "1".charCodeAt();
49
> buffer[14] = buffer[13];
49
> buffer[15] = 33
33
> buffer.toString("utf-8")
'Hello world!!11!'
Here, the remaining bytes were set by hand to represent the 1 and ! characters
encoded by utf-8.
More Fun With Buffers
Buffer.isBuffer(object)
We use this method to check whether an object is actually a buffer, much like
the Array.isArray method.
Buffer.byteLength(string, encoding)
This function lets us check how many bytes are needed for encoding a string
that has a specified encoding – this defaults to the utf-8 encoding. The length
will not be the same as the string length as lots of characters need a lot more
bytes for encoding. Here’s an example:
> var snowman = " ☃";
> snowman.length
1

> Buffer.byteLength(snowman)
3
This is a Unicode snowman and it has just one character. However, encoding
it requires three bytes.
buffer.length
This is your buffer length, used for representing the amount of allocated
memory. It won’t be the same as the buffer content’s size as buffers can be
only half full. Here’s an example:
> var buffer = Buffer.alloc(16)
> buffer.write(snowman)
3
> buffer.length
16
Here, the contents we write to the buffer have just three groups because they
are representing a single-character snowman. However, the buffer still has a
length of 16, the same as it was initialized with.
buffer.copy(target, targetStart=0, sourceStart=0,
sourceEnd=buffer.length)
Using buffer.copy lets us copy one buffer’s contents to another one. The
initial argument is the target buffer where the buffer contents are copied to.
The remaining arguments let us copy subsections of the source buffer to the
target buffer. Here’s an example:
> var frosty = Buffer.alloc(24)
> var snowman = Buffer.from(" ☃", "utf-8")
> frosty.write("Happy birthday! ", "utf-8")
16
> snowman.copy(frosty, 16)
3
> frosty.toString("utf-8", 0, 19)
'Happy birthday! ☃'
Here, the snowman buffer was copied to the frosty buffer. The snowman
buffer has a character three bytes long, while the frosty buffer contains the
first 16 bytes that were written to it. The result is that 19 bytes of the buffer
are taken up.
buffer.slice(start, end=buffer.length)

The API for this method is typically the same as the API for
Array.prototype.slice, but there is a significant difference – the slice is only
referencing a subset of the memory space; it is NOT a new one. When you
modify the slice, you also modify the buffer. For example:
var puddle = frosty.slice(16, 19)
> puddle.toString()
' ☃'
> puddle.write("___")
3
> frosty.toString("utf-8", 0, 19)
'Happy birthday! ___'
And now, Frosty is nothing more than a bunch of underscores!
In the next chapter, we move on to Node.js Streams

Chapter Eight
Node.js Streams
Node.js streams are not easy to work with and they are certainly not easy to
understand. Some of the biggest names in the business fear them and find
them hard to works with so how are you supposed to understand them?
Don’t worry, in this chapter, we will simplify things as much as we possibly
can.
What Are Streams?
They are one of the most fundamental concepts behind any Node.js
applications. Streams are a method to handle data and sequentially or read
and write input to output.
Streams can be used to read and write network communications, files, and
any other end-to-end exchange of information, and they do it quite efficiently
too. So what makes them unique?
Rather than a file being read all at once into a file, as is traditional, streams
take data in chunks, reading it a bit at a time and processing it without
needing it all to stay in memory.
When you work with large amounts of data, streams come into their own,
proving incredibly powerful. For example, some files are larger than the
memory space you have free, which makes it all but impossible to read the
entire file into memory for processing. Because streams can process data in
smaller chunks, larger files can easily be read.
For example, take Netflix, YouTube, or some other streaming service. When
you use these services, the files don’t need to be downloaded before watching
and listening to them. Your browser will receive the video and audio as a
continuous stream of data chunks, allowing you to listen and watch without
interruption.

However, streams are not just about big data and media. They also provide us
with another powerful aspect of coding – composability. When you have
composability in mind while designing, you can combine multiple
components is a specific way to get the same result type. Node.js allows us to
compose powerful code, using streams to pipe data between smaller code
chunks.
Why Streams
Because streams give us two very big advantages over other methods of data
handling:
1. Memory efficiency: There is no need for large amounts of data
to be loaded in memory before it is processed.
2. Time efficiency: When you can process data the minute you
have it, rather than waiting for it to be transferred, it is
significantly quicker.
Node.js has four types of streams:
1. Writable – these are streams we can write data to. For example,
we 
can 
use 
streams 
to 
write 
data 
to 
files 
using
fs.createWriteStream().
2. Readable – these are streams we can read data from. For
example, 
we 
can 
read 
a 
file’s 
contents 
using
fs.createReadStream().
3. Duplex – these are streams we can both read from and write to.
A good example of this is net.Socket.
4. Transform – these are streams that can transform or modify data
at the time we read and write it. For example, compressed data
can be written with file-compression, and decompressed data can
be read to and from files.
If you have experience with Node.js, no doubt you have already stumbled
over streams. In an HTTP server based on Node.js, for example, response is a
writable stream while request is a readable one. If you have used the fs
module, you’ve worked with readable and writable streams. When you use

Express, you are interacting with a client using streams. And, because of TLS
stacks, TCP stocks and other Node.js-based connections, you are also
working with streams in every database connection driver you use.
A Practical Example
To create a readable stream, we require Readable stream and it needs to be
initialized.
const Stream = require('stream')
const readableStream = new Stream.Readable()
Once the stream is initialized, data can be sent to it:
readableStream.push('ping!')
readableStream.push('pong!')
Async Iterator
The async iterator should be used when you are working with streams.
Asynchronous iteration is a protocol used to asynchronously retrieve what is
in a data container – this means the current task can be stopped before the
item is retrieved. It is also important to keep in mind that when you
implement the stream async iterator, it uses its internal readable event.
The async iterator can be used to read from a readable stream:
import * as fs from 'fs';
async function logChunks(readable) {
for await (const chunk of readable) {
console.log(chunk);
}
}
const readable = fs.createReadStream(
'tmp/test.txt', {encoding: 'utf8'});
logChunks(readable);
// Output:
// 'This is a test!\n'
The contents of a readable string can also be collected in a string:
import {Readable} from 'stream';
async function readableToString2(readable) {
let result = '';
for await (const chunk of readable) {
result += chunk;
}

return result;
}
const readable = Readable.from('Good morning!', {encoding: 'utf8'});
assert.equal(await readableToString2(readable), 'Good morning!');
In this case, we used an async function because we wanted a promise
returned.
You should also remember that async functions must not be mixed with
EventEmitter. There isn’t any way for rejections to be caught when emitted in
event handlers, which means memory leaks and bugs are hard to track.
Currently, the best practice is to wrap an async function’s content in a try…
catch block and handle the errors.
Readable.from(): How to Create a Readable Stream from Iterables
stream.Readable.from(iterable, [options]) is a utility method used to create
readable streams from iterators, where iterable is used to hold the data.
Options is an optional parameter, and you can use it to specify text encoding,
among other things:
const { Readable } = require('stream');
async function * generate() {
yield 'hello';
yield 'streams';
}
const readable = Readable.from(generate());
readable.on('data', (chunk) => {
console.log(chunk);
});
Two Reading Modes
The Streams API tells us that readable streams can operate in two different
modes – paused and flowing. And Readable streams can be in or out of object
mode, whether it is in paused or flowing mode.
Flowing mode – data gets read automatically from the
underlying system. It is given to an application quickly, and this
is one with events and the EventEmitter interface.
Paused mode – for data chunks to be read off the stream, the
stream.read() method needs to be explicitly called.

We can listen to data events and attach callbacks in flowing mode if we want
data read from a stream. When data becomes available, a data event is
emitted by the readable stream, and the callback is executed. Here’s an
example:
var fs = require("fs");
var data = '';
var readerStream = fs.createReadStream('file.txt'); //Create a readable stream
readerStream.setEncoding('UTF8'); // Set the encoding to utf8.
// Handle stream events --> data, end, and error
readerStream.on('data', function(chunk) {
data += chunk;
});
readerStream.on('end',function() {
console.log(data);
});
readerStream.on('error', function(err) {
console.log(err.stack);
});
console.log("Program Ended");
fs.createReadStream() is a function call that provides a readable stream. To
start with, the stream will be in a static state, but it starts flowing when a data
event is listened to and a callback attached. Once that happens, data chunks
get read and then passed into the callback. It is down to the stream
implementer to determine how often data events get emitted. For example,
HTTP requests might emit the data event when a few KBs of data of been
read. If your data is coming from files, you could opt to have the data event
emit after each line is read.
When all the data is read, an end event is emitted by the stream. In the code
above, the event was listened to so we know when the end was reached. 
And, if an error is detected, it is emitted and notified by the stream.
In paused mode, read() must be repeatedly called on  the stream instance until
all the data chunks are read. Here’s an example:
var fs = require('fs');
var readableStream = fs.createReadStream('file.txt');
var data = '';
var chunk;
readableStream.on('readable', function() {
while ((chunk=readableStream.read()) != null) {

data += chunk;
}
});
readableStream.on('end', function() {
console.log(data)
});
The internal buffer is where the read() function reads its data from and
returns it. If there isn’t anything to read, null is returned. We check the while
loop for null, and then the loop is terminated. Readable events are only
emitted when data chunks can be read from the stream.
Every Readable stream starts in paused mode but can be changed to flowing
in one of these ways:
Add a data event handler
Call the method, stream.resume()
Call the method, stream.pipe(), which sends data into a Writable.
And Readables can change from flowing to paused in one of these ways:
The stream.pause() method can be called if no pipe destinations
exist
All existing pipe destinations can be removed if there are several,
the stream.unpipe() method can be called.
One of the most important things you need to remember is that no Readably
will generate any data until there is a mechanism in place to consume or
ignore the data. If a consuming mechanism is in place and it gets removed or
disabled, the Readable will try to stop the data generation. If a readable event
handler is added, the stream automatically stops flowing, and the data is
consumed by readable.read(). If a readable event handler gets taken away, the
stream automatically flows, provided a data event handler is in place.
How to Create a Writable Stream
Writing data to a writable stream requires write() to be called on the stream
instance, like in this example:
var fs = require('fs');

var readableStream = fs.createReadStream('file1.txt');
var writableStream = fs.createWriteStream('file2.txt');
readableStream.setEncoding('utf8');
readableStream.on('data', function(chunk) {
writableStream.write(chunk);
});
This is straightforward code. All it does is reads data chunks off an input
stream and uses write() to write to the destination. The function returns a
Boolean value to indicate whether the operation was successful or otherwise.
Those Boolean values are true and false – true indicates a successful write
and that you can continue writing data, while false indicates that something
isn’t right and no more data can be written for now. A drain event will be
emitted in this case to tell you when you can begin writing again.
When the writable.end() method is called, it tells us that data is no longer
being written to the Writable. If an optional callback function was provided,
it will be attached for the finish event as a listener:
// Write 'hello, ' and end with 'world!'.
const fs = require('fs');
const file = fs.createWriteStream('example.txt');
file.write('hello, ');
file.end('world!');
// \You cannot Write anymore!
A writable stream allows you to read data off a readable stream:
const Stream = require('stream')
const readableStream = new Stream.Readable()
const writableStream = new Stream.Writable()
writableStream._write = (chunk, encoding, next) => {
console.log(chunk.toString())
next()
}
readableStream.pipe(writableStream)
readableStream.push('ping!')
readableStream.push('pong!')
writableStream.end()
Async iterators can also be used for writing to a writable stream – this is the
recommended course of action:
import * as util from 'util';
import * as stream from 'stream';
import * as fs from 'fs';
import {once} from 'events';

const finished = util.promisify(stream.finished); // (A)
async function writeIterableToFile(iterable, filePath) {
const writable = fs.createWriteStream(filePath, {encoding: 'utf8'});
for await (const chunk of iterable) {
if (!writable.write(chunk)) { // (B)
// Handle backpressure
await once(writable, 'drain');
}
}
writable.end(); // (C)
// Wait until done. Throws if there are errors.
await finished(writable);
}
await writeIterableToFile(
['One', ' line of text.\n'], 'tmp/log.txt');
assert.equal(
fs.readFileSync('tmp/log.txt', {encoding: 'utf8'}),
'One line of text.\n');
By default, stream.finished() is based on a callback but you can use
util.promisify() (line A) to transform it into a promise-based version.
This example shows it being used in two patterns:
Write to a writable stream and handle backpressure (line B):
if (!writable.write(chunk)) {
await once(writable, 'drain');
}
Close a writable stream and wait for writing to be done (line C):
writable.end();
await finished(writable);
pipeline()
Piping is another mechanism whereby the output from one stream is provided
to another. Normally, pipelines are used to obtain the data out of a stream and
then pass it to another, and there is no limit on how many you can use. In
simple terms, you use pipelines to process streamed data over several steps.
One of the latest additions to Node was a module method called
stream.pipeline(). This is used for piping between streams to forward errors,
clean up and provide callbacks for when the pipeline finishes.
Here is an example:
const { pipeline } = require('stream');
const fs = require('fs');
const zlib = require('zlib');

// The pipeline API is used to make it easy pipe multiple streams
// together and be notified when the pipeline has completely finished.
// A pipeline to gzip can move a potentially large video file in an efficient manner.
pipeline(
fs.createReadStream('The.Matrix.1080p.mkv'),
zlib.createGzip(),
fs.createWriteStream('The.Matrix.1080p.mkv.gz'),
(err) => {
if (err) {
console.error('Pipeline failed', err);
} else {
console.log('Pipeline succeeded');
}
}
);
Always make sure you use pipeline and not pipe as the latter is not safe to
use.
The Stream Module
The stream module in Node.js is the foundation on which all the streaming
APIs are built. It is a native module to Node.js, there by default when you
install it. It is an EventEmitter class instance used to asynchronously handle
Node events. This means that, inherently, streams are event-based.
Accessing the stream module is done like this:
const stream = require('stream');
The stream module is good for when you want new stream instance types
created. Typically, when you want streams consumed, you do not need to use
the stream module.
Streams-Powered Node APIs
Because of their many advantages, some Node.js core modules provide us
with native capabilities to handle streams. The most notable capabilities are:
net.Socket – this is the primary node API streams are based on
and underlies almost all of the rest of these APIs.
process.stdin – a stream that is connected to stdin is returned
process.stfout – a stream that is connected to stdout is returned
process.stderr – a stream that is connected to stderr is returned

fs.createReadStream() -  a readable stream is created to a file
fs.createWriteStream() – a writable stream is created to a file
net.connect – a stream-based connection is initiated
http.request() - an http.ClientRequest class instance is returned
– this is a writable stream.
zlib.createGzip() – this uses a compression algorithm called
gzip to compress data into a stream
zlib.createGunzip() - this decompresses gzip streams
zlib.createDeflate() – this uses a compression algorithm called
deflate to compress data into a stream
zlib.createInflate() - this decompresses deflate streams
To finish this chapter, these are some of the most important events related to
the writable streams:
error – this is emitted to tell us that an error happens during
piping/writing
pipeline – the writable stream emits this when readable streams
are piped into writable streams.
unpipe – this is emitted when unpipe is called on the readable
stream. It stops it from being piped into the destination stream.
Hopefully, I have been able to give you a basic idea of streams in this
chapter. Some of the most powerful Node.js features are pipes, streams, and
chaining, and streams have the ability to help you write clean, neat code that
helps perform I/O.

Chapter Nine
Node.js File System
Node.js has been helping developers to run server-side code for some time
now, helping them generate and deliver dynamic content to web clients. It
has two primary features that make it stand out – it is event-driven, and it has
a non-blocking I/O model.
To help it handle certain file operations, such as creating files, reading from
and writing to, even deleting them, Node.js has an in-built module. It is called
the FS module, which stands for File System. Node.js provides file I/O
functionality through wrappers around the POSIX functions. Every FS
operation can have one of two forms, depending on the user requirements –
synchronous and asynchronous.
If you want to use the file system module, you need to use the require()
method:
var fs = require('fs');
Common Uses for the File System Module
Reading files
Writing files
Appending files
Closing files
Deleting files
We will touch on those a little more later on.
What is the Synchronous and Asynchronous Approach?
Synchronous approach – these are blocking functions. They
wait for each operation to finish, and then they will execute the
next operation. This is why they are known as blocking – they

block the subsequent command from executing. Simply put, a
command cannot be executed unless and until the current one is
done.
Asynchronous approach – these are non-blocking functions.
They do not wait for one command to finish before executing the
next one. Instead, all operations are executed on the first go
around. Each operation’s result is handled once the result is in,
i.e., each command is executed as soon as possible after the
previous command is executed, and the previous command will
remain in the background, processing data and producing the
result.
Use Cases
Where your operations don’t query large data from DB or do any
other heavy lifting, you can use Synchronous; otherwise, you
should use Asynchronous.
When you use Asynchronous, you can display a progress
indicator to users while continuing with the heavy lifting in the
background – this works well for GUI applications.
Some of the more common I/O operations that use the fs module are:
Reading Files
To asynchronously read a physical file, use:
fs.readFile()
An example of how it works:
fs.readFile(fileName [,options], callback)
Parameters
There are three parameters or arguments here:
filename: the full path and file name in string format.
options: this can be a string or an object, and it can include flags
and encoding. The default flag is ‘r’ and utf8 is the default

encoding.
callback: this is a function that has two parameters – fd and err.
It is called when the operation has finished.
In the next example, you can see how a file called TestFile.txt is
asynchronously read:
var fs = require('fs');
fs.readFile('TestFile.txt', function (err, data) {
if (err) throw err;
console.log(data);
});
This code asynchronously reads TestFile.txt on the Windows operating
system. The callback function is executed when the read operation has been
completed. The operation will successfully complete, or it will throw an
error. If an error is thrown, the err parameter has all the error information in
it. In the data parameter, you will find the specified file’s content.
This is a sample file called TextFile.txt with this content:
This test file tests the fs module of Node.js
Running it will give you the following result:
C:\> node server.js
This test file tests the fs module of Node.js
If you want to read the file synchronously, use the method called
fs.readFileSync():
var fs = require('fs');
var data = fs.readFileSync('dummyfile.txt', 'utf8');
console.log(data);
Writing Files
The fs.writeFile method is used for writing data to files. If the file is already
in existence, the existing content is overwritten, but the method will create
the file and write the data to it if it doesn't exist.
Signature:

fs.writeFile(filename, data[, options], callback)
Parameters
This method has four parameters:
filename: the full path and file name as a string.
Data: this is what gets written into the file.
options: this can be a string or an object and it can include flags
and encoding. The default flag is ‘r’ and utf8 is the default
encoding.
callback: this is a function that has two parameters – fd and err.
It is called when the operation has finished.
In the next example you can see a new file named test.txt being created and
“hello World” written asynchronously into it:
var fs = require('fs');
fs.writeFile('test.txt', 'Hello World!', function (err) {
if (err)
console.log(err);
else
console.log('Write operation complete.');
});
And if you want to append this content to a file that already exists, use the
method called fs.appendFile():
var fs = require('fs');
fs.appendFile('test.txt', 'Hello World!', function (err) {
if (err)
console.log(err);
else
console.log('Append operation complete.');
});
Open Files
The fs.open() method can be used for opening files to read or write to
Signature:
fs.open(path, flags[, mode], callback)
Parameters:

path: the full path and file name as a string.
Flag: this is the flag required for performing the operation.
Mode: this indicates which mode is required – read, write,
readwrite. The default is readwrite, which is 0666..
callback: this is a function that has two parameters – fd and err.
It is called when the operation has finished.
Flags
Just to divert slightly, these are the flags you can use in read/write operations:
FLAG
DESCRIPTION
r
Opens a file so it can be read. If the file doesn’t exist, an
exception happens
rs
Opens a file to be read in synchronous mode
rs+
Opens a file for reading from and writing to. The OS is told to
open the file synchronously
w
Opens a file to be written to. If it doesn’t exist, the file is created
and if it does exist, it will be truncated
wx
Similar to the ‘w’ flag but, if the path exists, it will fail
w+
Opens a file to be written to. If it doesn’t exist, the file is created
and if it does exist, it will be truncated
wx+
Similar to the ‘w+’ flag but, if the path exists, it fails
a
Opens a file to be appended to. If the file does not exist, it is
created
ax
Similar to the ‘a’ flag but, if the path exists, it fails
a+
Opens a file to be appended to. If it doesn’t exist, the file is
created
ax+
Similar to the ‘a’ flag but, if the path exists, it fails.

In the example below, you can see an existing file being opened and its
contents read:
var fs = require('fs');
fs.open('TestFile.txt', 'r', function (err, fd) {
if (err) {
return console.error(err);
}
var buffr = new Buffer(1024);
fs.read(fd, buffr, 0, buffr.length, 0, function (err, bytes) {
if (err) throw err;
// Print read bytes only, avoiding the junk.
if (bytes > 0) {
console.log(buffr.slice(0, bytes).toString());
}
// Close the opened file.
fs.close(fd, function (err) {
if (err) throw err;
});
});
});
Delete Files
If you want to delete a file, use the fs.unlink() method
Signature:
fs.unlink(path, callback);
Parameters:
There are two parameters:
path: the full path and file name as a string.
callback: this is a function that has two parameters – fd and err.
It is called when the operation has finished.
In the example below, you can see an existing file being deleted:

var fs = require('fs');
fs.unlink('test.txt', function () {
console.log('write operation complete.');
});
Important fs.module Methods
This is a list of the most important methods in the FS module:
METHOD
DESCRIPTION
fs.access()
Looks to see if the file exists and it can be
accessed by Node.js with its permissions
fs.appendFile()
Appends data to files – it will create a file
if the specified one doesn’t exist
fs.chmod()
Change a specified file’s permissions.
Related to fs.lchmod() and fs.fchmod().
fs.chown()
Change a specified file’s owner and/or
group. Related to fs.chown() and
fs.lchown()
fs.close()
Close a file descriptor
fs.copyFile()
Copy a specified file
fs.createReadStream()
Create readable file streams
fs.createWriteStream()
Create writable file streams
fs.link()
Create hard links to specified files
fs.mkdir()
Create new folders
fs.mkdtemp()
Create temporary directories
fs.open()
Set the required file mode
fs.readdir()
Read a specified directory’s contents
fs.readFile()
Read a specified file’s contents. Related to

fs.read()
fs.readlink()
Read a symbolic link’s specified value
fs.realpath()
Resolve relative file path pointers to the
full path
fs.rename()
Rename specified files or folders
fs.rmdir()
Remove a specified folder
fs.stat()
Return the status of the specified filename.
Related to fs.fstat() and fs.lstat()
fs.symlink()
Create new symbolic links to specified files
fs.truncate()
Truncate a specified file to the specified
length. Related to fs.ftruncate()
fs.unlink()
Remove specified files or symbolic links
fs.unwatchFile()
Stop watching a file for changes
fs.utimes()
Change a specified file’s timestamp.
Related to fs.futimes()
fs.watchFile()
Start watching a specified file for changes.
Related to fs.watch()
fs.writeFile()
Write data to a specified file. RE
There is one peculiarity you should know about the fs module – by default,
all its methods are asynchronous but, by appending sync() you can get them
to work synchronously:
For example, fs.rename() becomes fs.renameSync() and fs.write() becomes
fs.writeSync().
This can make a significant difference in how your application flows. Let’s
look at the fs.rename() method, where a callback is used with the
asynchronous API:
const fs = require('fs')
fs.rename('before.json', 'after.json', err => {

if (err) {
return console.error(err)
}
//done
})
You can use asynchronous APIs like, handling errors with a try/catch block:
const fs = require('fs')
try {
fs.renameSync('before.json', 'after.json')
//done
} catch (err) {
console.error(err)
}
The difference is, in the second example, your script blocks until the file
operation has completed successfully.

Chapter Ten
Node.js Global Objects
This chapter is split into two – the first part discusses the Node.js global
object, while the second part looks at the node.js global objects. These are
different, as you will see.
Global Object
The global object is the top-level object, and we can access it from
everywhere.  In fact, you’ve probably been using its modules and functions
without even realizing it.  Let’s say that we want to see whether a variable is
an array:
let x = [1, 2, 3];
let result = Array.isArray(x) // true
So, how is Array used without needing to use it as a module? The global
object. To see what is in the global object, all you need to do is get into the
REPL using the node command.
Open the command-line interface and run the node command with no
options. Then press the tab key twice, and you will see all the modules and
functions available in the global object – these can be used without requiring
modules.

Global Modules and Functions
I have no doubt that, along the way, you have used quite a few of these, such
as NaN, isNaN, Infinity, Promise, String, and so on. When you want to add
something o the global object, you must first mutate the global object:
global.myName = “marypoppins”
Now, myName can be called from anywhere in your project. Here’s an easy
example for you:
FirstFile.js
global.myName = "marypoppins";
SecondFile.js
require('FirstFile.js');
console.log(myName); // It will log "marypoppins"
That was just for the purpose of demonstration – best practice for Node.js
dictates that the global object should n0t be modified for any reason.

Let’s move on to two very important modules in the global object – process
and buffer.
Process
This object contains a lot of useful information about the process:
Process.versions – this tells us what version each of the node
core modules is, such as openssl, zlib, v8, and more.
Process.env – tells us some important stuff about the
environment where node runs. Here are some good examples:
>process.env.shell
‘/usr/bin/fish’
>process.env.LANG
‘en_US.UTF-8’
>process.env.USER
‘marypoppins’
>

We can also use process.stdin, process.stdout, and process.stderr, all of which
are streams, to interact with the environment.
The process object is an EventEmitter instance, and this means the object can
be used to register event listeners:
And the result of this code is:
You can also use process.exit(exitCode) to end your code with the exit code
you want to use.
Buffer
A buffer is a memory chunk that is external to the v8 heap and is used to help
us put data into the memory. In simple terms, it is a low-level data structure
representing a  binary data sequence; once allocated, there is no way to resize
it. Reading from the buffer requires the encoding is specified.
Some of the ways a buffer can be created are:
Buffer.from() - this uses anything, such as an image, file, or
string, to create a buffer
Buffer.alloc() – this creates filled buffers with specified sizes
Buffer.allocUnsafe() - this creates buffers with specified sizes
that may contain old data but offer advantages in terms of
performance. This can also be filled using .fill().
The image below shows the difference between Buffer.alloc() and

Buffer.allocUnsafe().
As you can see, the alloc-created buffer has no data but the unsafe buffer has
some old data in it. Here’s another example:
Before you see what the console outputs, have a guess at the results:
<Buffer 48 65 6c 6c 6f 20 47 75 79 73 2e 2e 2e>
Hello Guys...
Hello Guys...
In line 3, we used Buffer.from to create the buffer. Now, when buffer is
logged, we see the binary data sequence.  We actually see the string because
the .toString method has a default encoding of utf8. Usually, string_decoder,
which is an internal nodejs package, is needed. With stringDecoder, a
decoder object can be instantiated, and our encoding can be passed in its
constructor, and the write() method is used to covert the buffer into a piece of
decoded data.
Global Objects
As you have gathered by now, Node.js is modular in its approach, which

means when a function, variable, or object is defined inside a file, it is local
to the file, and the file gets treated as a module. When you want to use a
variable you defined in one file in a different one, you need to use the
module.exports 
syntax 
to 
export 
the 
variable 
and 
then 
use
require(path_of_file) to import into the other one.
In Node.js, global objects work a little differently.  Because they are global
and can be accessed in all modules, there is no need to import or export them
– they can be directly used in your application, anywhere you want.
We’re going to look at some of the more important and common Node.js
global objects.
Prerequisites
You will need Node.js installed, and you need a basic knowledge of the
command line or terminal
We’re going to look at these global objects:
process
__dirname
__filename
require()
module
URL
To start with, create a new folder in the home directory and call it nodejs:
mkdir nodejs
Now get into that folder:
cd nodejs
Once you are in the nodejs directory, create a new file and call it main.js
touch main.js

NOTE
If you are using Windows, touch will not work. The only way around it is to
use a text editor to create your file and then save it in your nodejs directory.
Let’s look at these objects.
Process
This global object gives you lots of useful information about your program
execution environment. Some information it provides includes the
architecture, the platform, process ID, uptime, environmental variables,
current working directory, and more. Here are some of the more common
functions and properties in the object:
process.arch – the CPU architecture of the operating system is
returned, Some values include x32, x64, and ia32.
process.platform – this returns the OS or platform where the
program is being executed on. Some examples of returned strings
include openbsd, linux, freebsd, and win32.
process.id – this returns the PID, or process id of the node’s
process
process.cwd() – this is a method that returns the current working
directory of the executing program
process.chdir(directory) -  this method is used for changing the
current working directory
The process object has many properties but we are going to focus our
attention on the four primary ones and create a program with them:
Open main.js and input the following:
// print current working directory
console.log(`Starting directory: ${process.cwd()}`);
console.log(`This platform is ${process.platform}`);
console.log(`Process PID: ${process.pid}`);
console.log(`The CPU Architecture is: ${process.arch}`); 
// change working directory to Documents
process.chdir('../Documents');  
console.log(`Ending directory: ${process.cwd()}`);

Now run this, ensuring you are in the nodejs directory when you do so:
node main.js
And the output is something like:
Starting directory: /home/<your username>/nodejs
This platform is linux
Process PID: 19253
The CPU Architecture is: x64
Ending directory: /home/<your username>/Documents
require()
This method is used for importing or loading JSON, local files, and modules.
If you want to import JSON or a local module, the file’s relative path is
required:
Local Module.
const localModule = require('.path/filename.js');
JSON file.
const jsonData = require('.path/filename.json');
If you want a module imported from the node_modules directory or a built-in
Nodejs module, the module name must be passed to the require() method:
// fs is a built-in module
const fileSystem = require('fs');
__dirname
This returns the path of the directory where the script is being executed. You
will not be able to access it in the Node.js REPL.
Take the code out of main.js and add this in instead:
console.log(__dirname);
The output will be:
/home/<your username>/nodejs
This is useful when you want to use Node.js to read and write files.

__filename
This returns the executing file’s absolute path. Again, it cannot be accessed in
the REPL.
Remove the code from main.js and put this in instead:
console.log(__filename);
The output will be:
/home/<your username>/nodejs/main.js
module
The module global object references the current module and in it is
information concerning the current module CommonJS can use for working
out how the module should be imported.
Whenever a file is created, like the main.js file we created earlier, it turns into
a module. Logging the module allows us to get information about our main.js
module:
console.log(module);
When you log the module, an object is returned with all the information
about the module:
Module {
id: '.',
path: '/home/<your username>/nodejs',
exports: {},
parent: null,
filename: '/home/<your username>/nodejs/main.js',
loaded: false,
children: [],
paths: [
'/home/<your username>/nodejs/node_modules',
'/home/<your username>/node_modules',
'/home/node_modules',
'/node_modules'
]
}
When the main.js module is being imported in another file by CommonJS, it
will look in the paths that come from Module.paths for the main.js file.
URL
This is a constructor method used for parsing the URL and returning an

object that has the parsed data in it.
Delete everything from main.js so we can parse the following URL (this is
not a real URL) – https://www.marypoppins.madeup. If you want, you can
try this with a real URL – just input the details:
const url = new URL('https://www.marypoppins.madeup/');
console.log(`The url protocol: ${url.protocol}`);
console.log(`The url path : ${url.pathname}`); 
console.log(`The url hostname: ${url.hostname}`);
The output will be
The url protocol: https:
The url path : /articles/
The url hostname: www.marypoppins,madeup
Now you know what the global object is and how to use the most common
global objects Node.js has to offer.

Chapter Eleven
Node.JS Utility Modules
The Node.js module library contains quite a few utility modules commonly
used while developing applications based on Node. This chapter will detail
those modules, what they are used for, and give a few code examples.
OS Module
The OS module provides utility functions related to the operating system.
The syntax below is used to import it:
var os = require("os")
OS Module Methods
These are the methods for the OS module:
METHOD
DESCRIPTION
os.tmpdir()
Will return the default directory
for the OS temp files
os.endianness()
Returns the CPU’s endianness,
with possible values of LE or BE
os.hostname()
Returns the operating system’s
hostname
os.type()
Returns the system name for the
operating system
os.arch()
Returns the CPU architecture for
the operating system. Possible
values are arm, x64 and ia32.
os.platform()
Returns the OS platform
os.release()
Returns the release version of the

operating system
os.uptime()
Returns system uptime (seconds)
os.loadavg()
Returns an array with load
averages of 1, 5, and 15 minutes
os.totalmem()
Returns the total system memory
amount (bytes)
os.freemem()
Returns the free system memory
amount (bytes)
os.cpus()
Returns an object array with
information about each installed
CPU/core. This includes the speed
(MHz), model, and times – how
much time in seconds was spend
in irq, idle, sys, nice, and user by
the CPU/core
os.networkInterfaces()
Provides a list of the network
interfaces
OS Module Properties
The primary property for this module is os.EOL. It is a constant that defines
the right End-of-Line marker for the specific operating system.
In the code demonstration below, you can see some of the OS module
methods. If you want to join in, create a file, call it main.js and input this
code:
var os = require("os");
// Endianness
console.log('endianness : ' + os.endianness());
// OS type
console.log('type : ' + os.type());
// OS platform
console.log('platform : ' + os.platform());
// Total system memory
console.log('total memory : ' + os.totalmem() + " bytes.");

// Total free memory
console.log('free memory : ' + os.freemem() + " bytes.");
Run the program and you should see something similar to the following:
$ node main.js
Verify the Output.
endianness : LE
type : Linux
platform : linux
total memory : 25103400960 bytes.
free memory : 20676710400 bytes.
Path Module
This module contains utilities to help us handle and transform file paths. The
following syntax is used for importing it:
var path = require("path")
Path Module Methods
These are the Path Module methods you are likely to use:
METHOD
DESCRIPTION
path.normalize(p)
Used to normalize string paths,
take care of the “.” and “..” bits
path.join([path1][, path2][, ...])
Joins the arguments and the
resulting path is normalized
path.resolve([from ...], to)
Will resolve to an absolute path
path.isAbsolute(path)
Determines if a path is absolute.
No matter what the working
directory is, absolute paths always
resolve to the same location.
path.relative(from, to)
Solves the relative path between
from and to
path.dirname(p)
Returns a path’s directory name
path.basename(p[, ext])
Returns a path’s last portion
path.extname(p)
Returns a path’s extension form

the final ‘.’ to the string’s end in
the path’s last portion. If the last
portion does not have a ‘.’ or ‘.’ is
its first character, an empty string
is returned
path.parse(pathString)
Returns an object from the path
string
path.format(pathObject)
Returns a path string from an
object
Path Module Properties
These are the properties for the Path module:
PROPERTIES
DESCRIPTION
path.sep
File 
separator 
specific 
to 
the
platform and is / or \\
path.delimiter
Path delimiter specific to the
platform and : or ;
path.posix
Gives access to the path methods
mentioned above but only allows
interaction in a way compatible with
posix
path.win32
This also gives us access to the path
methods mentioned above but only
allows 
interaction 
in 
a 
way
compatible with win32
Here, you can see the Path module methods at work.
Clear the contents of your main.js file and add the following:
var path = require("path");
// Normalization
console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));
// Join
console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));

// Resolve
console.log('resolve : ' + path.resolve('main.js'));
// extName
console.log('ext name : ' + path.extname('main.js'));
Run the file and you should see something like this:
$ node main.js
Verify the Output.
normalization : /test/test1/2slashes/1slash
joint path : /test/test1/2slashes/1slash
resolve : /web/com/1427176256_27423/main.js
ext name : .js
Net Module
The net module provides clients and serves as streams and also provides an
asynchronous wrapper to go around the network. The following syntax is
used to import it:
var net = require("net")
Net Module Methods
These are the methods in the Net module:
METHODS
DESCRIPTION
net.createServer([options][,
connectionListener])
Creates a TCP server and the
argument
(connectionListener) is set
automatically as the
connection event listener
net.connect(options[, connectionListener])
This is a factory method,
returning a net.Socket and
connecting to the address and
port supplied
net.createConnection(options[,
connectionListener])
Same as above
net.connect(port[, host][,
connectListener])
Creates a TCP connection to
the port on the host. If there is
no host, it defaults to
localhost. The argument,

connectListener, is added as
the connect event listener and,
like the previous two
methods, it also returns a
net.Socket.
net.connect(path[, connectListener])
Creates a Unix socket
connection to the path. The
argument, connectListener, is
added as the connect event
listener and, like the previous
methods, it also returns a
net.Socket.
net.createConnection(path[,
connectListener])
As above
net.isIP(input)
Tests to see if the input is an
IP address and returns 0 if the
string is invalid, 4 if it is an IP
v4 address and 6 if it is an IP
v6 address
net.isIPv4(input)
Will return true if the input is
an IP v4 address, false if
otherwise
net.isIPv6(input)
Will return true if the input is
an IP v6 address, false if
otherwise
Class - net.Server
The net.Server class is used for creating local or TCP servers.
net.Server Methods
These are the methods that go with this class:
METHODS
DESCRIPTION
server.listen(port[, 
host][, 
backlog][,
Allows you to start accepting

callback])
connections on a given port
and host. If there is no host
specified, connections will be
accepted by the server if they
are directed to IPv4 addresses
(INADDR_ANY). If the port
number is missing, a random
port is assigned.
server.listen(path[, callback])
Starts a local socket server
that listens on a given path
for connections
server.listen(handle[, callback])
You can set the handle object
as a socket or server so long
as it has an {fd: <n>} object
or an underlying _handle
member. The server is forced
to accept connections on the
given handle but it is assumed
that 
the 
handle 
or 
file
descriptor is bound to a
domain 
socket 
or 
port.
Windows does not support
listening on file descriptors.
server.listen(options[, callback])
In this method, the host, port,
option properties backlog and
callback function (optional)
behave in the same way as
they 
do 
on 
a
server.listen(port, 
[host],
[backlog], 
[callback] 
call.
You can also use the path
option 
to 
specify 
UNIX
sockets.
server.close([callback])
This is closed when there are
no more open connections
and a close event is emitted

by the server
server.address()
This method will return the
bound address, the server port
and the address family name
that the operating system
reports
server.unref()
When you call unref on the
server, the program can exit if
the event system has no other
active server. Calling unref
will have no effect if the
server is unrefd.
server.ref()
The opposite of above – if
you call ref on a server that
was previously unrefd, the
program cannot exit if it is
the sole remaining server.
Where the server is refd, it
will have no effect if you call
ref again.
server.getConnections(callback)
Obtain 
the 
number 
of
concurrent 
connections
asynchronously. This works
with sockets that are sent to
forks and callback needs two
parameters – err and count
Events
These events go with the above method:
EVENT
DESCRIPTION
listening
This event is emitted once the
server is bound when server.listen is
called

connection
Emitted once a new connection has
been made. The connection object,
socket object, can be accessed by
the event handler and socket is a
net.Socket instance.
close
Emitted once the server is closed. If
there are existing connections, this
cannot be emitted until they are all
closed
error
Emitted when an error has occurred.
Immediately after this event, the
close event is called.
Class - net.Socket
This is a local or TCP socket abstraction and instances of net.Socket are used
for implementing duplex Stream interfaces. The user can create them and
they can be used with connect() as a client or Node can create them and pass
them to user through a server’s connection event.
net.Socket Events
These are the events emitted by net.Socket:
EVENT
DESCRIPTION
Lookup
This event is emitted once the
hostname is resolved but before the
connection. This does not apply to
UNIX sockets
connect
Emitted after a socket connection has
been established successfully
data
Emitted any time data gets received.
String or Buffer are used for the
argument 
data 
and
socket.setEncoding() is used to set the
data encoding

end
Emitted when an FIN packet is sent
by the other end of the socket
timeout
Emitted when inactivity causes the
socket to time out. It is purely to tell
you that the socket is idle and the
connection must be manually closed
by the user
drain
Emitted after the write buffer empties
and can be used for throttling uploads
error
Emitted after an error has occurred
and is followed immediately by the
close event
close
Emitted only when the socket has
closed 
completely. 
It 
takes 
an
argument of had_error, a Boolean that
tells you if a transmission error causes
the socket to close.
net.Socket Properties
These are the properties net.Socket uses to control the socket interactions
PROPERTIES
DESCRIPTION
socket.bufferSize
Indicates how many buffered
characters are waiting to be
written
socket.remoteAddress
Remote IP address in a string
representation.
socket.remoteFamily
Remote IP family in string
representation, either IPv4 or
IPv6

socket.remotePort
Numerically 
represents 
the
remote port
socket.localAddress
Represents the local IP address
being connected to by the remote
client 
and 
is 
a 
string
representation. I.e. if you listen on
0.0.0.0 and a remote client uses
192.168.1.1 
to 
connect 
on,
192.168.1.1 is the value
socket.localPort
Numerically represents the local
port
socket.bytesRead
Indicates how many bytes were
received
socket.bytesWritten
Indicates the how many bytes
were sent
net.Socket Methods
And these are the net.Socket methods
METHODS
DESCRIPTION
new net.Socket([options])
This method is used to
construct new socket objects
socket.connect(port[, host][,
connectListener])
Used to open a connection for
a specified socket. If the host
and port are provided, the
socket opens as TCP but, if
host is not provided, it will be
assumed as localhost. If the
path is provided, the socket
opens to the path as a UNIX
socket
socket.connect(path[, connectListener])
Used to open a connection for
a specified socket. If the host

and port are provided, the
socket opens as TCP but, if
host is not provided, it will be
assumed as localhost. If the
path is provided, the socket
opens to the path as a UNIX
socket
socket.setEncoding([encoding])
Used to set the socket
encoding as a Readable
Stream
socket.write(data[, encoding][, callback])
Used for sending data on the
socket. If it is a string, the
second argument is used to
specify what the encoding is –
the default is UTF8
socket.end([data][, encoding])
Used to send a FIN package,
which half closes the socket.
The server may still be able to
send data
socket.destroy()
Used to make sure that I/O
activity cannot happen on the
socket. This is only necessary
where there are errors, such as
the parse error, etc.
socket.pause()
Used to pause the data
reading, which means data
events stop being emitted.
This is useful when you want
uploads throttled back.
socket.resume()
Used to resume data reading
after a call to the pause
method
socket.setTimeout(timeout[, callback])
Used to set the socket so it
times out after a specified
number of inactive timeout

milliseconds on the socket. By
default, there is no timeout on
net.socket.
socket.setNoDelay([noDelay])
Used for disabling the Nagle
algorithm. This algorithm is
used by default by TCP
connections and, before they
send data off, it is buffered. If
noDelay is set as true, it fires
off data immediately
socket.write() is called. By
default, noDelay is set as true.
socket.setKeepAlive([enable][,
initialDelay])
Helps to enable or disable the
keep-alive functionality.
Optionally, it can also set the
delay before an idle socket
sends the initial keepalive
probe. By default, enable is set
to false.
socket.address()
Returns the address family
name, the bound address and
the socket port the OS reports.
An object with three properties
is returned, i.e. {port 23467,
family: ‘IPv6’, address:
‘128.0.1.1’}
socket.unref()
When you call unref on the
socket, the program can exit if
the event system has no other
active socket. Calling unref
will have no effect if the
socket is unrefd.
socket.ref()
The opposite of above – if you
call ref on a socket that was
previously unrefd, the program

cannot exit if it is the sole
remaining socket. Where the
socket is refd, it will have no
effect if you call ref again.
Here’s an example of these methods being used. First, create a new file and
call it server.js. Then input the following:
var net = require('net');
var server = net.createServer(function(connection) {
console.log('client connected');
connection.on('end', function() {
console.log('client disconnected');
});
connection.write('Hello World!\r\n');
connection.pipe(connection);
});
server.listen(8080, function() {
console.log('server is listening');
});
Now run it and see what the output is:
$ node server.js
Verify the Output.
server is listening
Next, create another new file called client.js and input this code:
File: client.js
var net = require('net');
var client = net.connect({port: 8080}, function() {
console.log('connected to server!');
});
client.on('data', function(data) {
console.log(data.toString());
client.end();
});
client.on('end', function() {
console.log('disconnected from server');
});

Now try running this file from a different terminal and see what the output is:
$ node client.js
Verify the Output.
connected to server!
Hello World!
disconnected from server
Lastly, on the terminal where you are running the server.js file, verify the
output:
server is listening
client connected
client disconnected
DNS Module
The DNS module contains functions that allow us to do DNS lookup and use
the name resolution functionalities that underly the operating system.  It gives
us an asynchronous wrapper for the network, and the following syntax is
needed to import it:
var dns = require("dns")
DNS Module Methods
These are the methods that come from the DNS Module:
METHOD
DESCRIPTION
dns.lookup(hostname[, options], callback)
This method is used to resolve
hostnames into the first IPv4
(A) or IPv6 (AAAA) record.
The options parameter can be
an integer or object but if this
is not provides, both IPv4 and
6 addresses are valid. If it is
set as an integer, it is 4 or 6
dns.lookupService(address, port, callback)
Uses getnameinfo to resolve
the specified port and address
into a service and hostname.
dns.resolve(hostname[, rrtype], callback)
Used to resolve a hostname

into an array containing
record types that rrtype
specifies.
dns.resolve4(hostname, callback)
As above but only as far as
IPv4 or A record queries are
concerned.
dns.resolve6(hostname, callback)
As above but for IPv6 or
AAAA record queries
dns.resolveMx(hostname, callback)
As above but only for MX
record or mail exchange
queries
dns.resolveTxt(hostname, callback)
As above but for TXT record
or text queries.
dns.resolveSrv(hostname, callback)
As above but for SRV records
or service record queries
dns.resolveSoa(hostname, callback)
As above but only for SOA or
start of authority records
dns.resolveNs(hostname, callback)
As above but only for NS or
name server records
dns.resolveCname(hostname, callback)
As above but only for
CNAME or canonical records
dns.reverse(ip, callback)
Reverse resolves IP address to
a hostnames array
dns.getServers()
Used to return an array
containing IP addresses as a
string currently in use for
resolution
dns.setServers(servers)
Used to set a given array of IP
addresses in string format as
the servers needed to resolve
them
DNS Module rrtypes

These are the valid rrtypes the dns,resolve() method uses:
A - the default, IPv4 addresses
AAAA – Ipv6 addresses
MX – these are the mail exchange records
SRV – these are the SRV records
TXT – these are the text records
PTR – this is used to do reverse IP lookups
CNAME – these are canonical name records
NS – these are the name server records
SOA – these are the start of authority records
DNS Module Error Codes
All of the DNS queries may return one of these codes:
•                    dns.NODATA – no data was returned with the DNS server
answer
•                    dns.FORMERR – according to the DNS server, the query has
been misformatted.
•                    dns.SERVFAIL – a general failure was returned by the DNS
server
•                    dns.NOTFOUND − Domain name was not found.
•                    dns.NOTIMP − DNS server hasn’t implemented the requested
operation.
•                    dns.REFUSED − DNS server has refused the query.
•                    dns.BADQUERY – the DNS query is misformatted
•                    dns.BADNAME – the hostname is misformatted
•                    dns.BADFAMILY – the address family is unsupported

•                    dns.BADRESP – the DNS reply is misformatted
•                    dns.CONNREFUSED – the DNS servers could not be
contacted
•                    dns.TIMEOUT – DNS server contact timed out
•                    dns.EOF − End of file.
•                    dns.FILE – there was an error reading the file.
•                    dns.NOMEM − Out of memory.
•                    dns.DESTRUCTION – The channel is being destroyed.
•                    dns.BADSTR – the string is misformatted.
•                    dns.BADFLAGS – the specified flags are illegal.
•                    dns.NONAME – the specified hostname is not numeric.
•                    dns.BADHINTS – the illegal hints flags was specified.
•                    dns.NOTINITIALIZED − c-ares library initialization has not
yet been performed.
•                    dns.LOADIPHLPAPI − error loading the iphlpapi.dll.
•                    dns.ADDRGETNETWORKPARAMS − the
GetNetworkParams function was not found.
•                    dns.CANCELLED − DNS query was cancelled.
Here’s a live example for you. Find your main.js file and clear the contents.
Then add the following:
var dns = require('dns');
dns.lookup('www.google.com', function onLookup(err, address, family) {
console.log('address:', address);
dns.reverse(address, function (err, hostnames) {
if (err) {
console.log(err.stack);
}
console.log('reverse for ' + address + ': ' + JSON.stringify(hostnames));
});

});
Run the file to see what the output is:
$ node main.js
Now verify that output:
address: 173.194.46.83
reverse for 173.194.46.83: ["ord08s11-in-f19.1e100.net"]
Domain Module
Our last utility module is the Domain module, used to help us handle several
I/O operations as one group. It intercepts unhandled errors using external or
internal binding. If these were not handled, the Node application would just
crash.
•       Internal Binding – the error emitter executes the code in the
domain’s run method
•       External Binding – the error emitter uses its own add method to be
explicitly added to the domain.
The following syntax is used to import the module:
var domain = require("domain")
The domain module’s domain class provides the functionality to route
uncaught exceptions and errors to the active Domain object. It is the
EventEmitter’s child class, and its error event needs to be listened to for
handling any caught errors. The syntax below creates it:
var domain = require("domain");
var child = domain.create();
Domain Module Methods
These are the Domain Module methods:
METHODS
DESCRIPTION
domain.run(function)
This method runs the specified
function in the domain context. It
binds all timers, event emitter and

low level requests implicitly. This
is the basic way domains are used
domain.add(emitter)
Adds emitters to the domain
explicitly. If any of the event
handlers the emitter calls throws
an error or an error event is
emitted by the emitter, it gets sent
to the error event for the domain,
just as it is with implicit binding.
domain.remove(emitter)
The opposite of above, the
domain handling is removed from
the given emitter
domain.bind(callback)
The function that gets returned is
a wrapper around the callback
function supplied. When that
function is called, thrown errors
get sent to the error event in the
domain
domain.intercept(callback)
Almost 
the 
same 
as
domain.bind(callback) but as well
catching errors, it intercepts any
error message that gets sent to the
function as the first argument
domain.enter()
Used by the bind, run and
intercept methods and helps set
the 
domain. 
It 
sets
process.domain 
and
domain.active to the domain and
pushes that domain implicitly
onto the domain stack the domain
module managers. The call to this
method delimits the start of the
asynchronous call chain and I/O
operations that are bound to

specific domains.
domain.exit()
This method will pop the current
domain off the stack and exit it.
When execution is switched to
the 
context 
of 
another
asynchronous call chain, the
current domain must be exited.
The call to exit will delimit an
interruption to or the end of the
call chain and any I/O bound to a
specific domain.
domain.dispose()
When this method is called, the
domain cannot be used by any
callback that is bound into the
domain using intercept, bind or
run and a dispose event gets
emitted
Domain Module Properties
There is one primary domain module property called domain.members. It is
an array containing event emitters and timers added to the domain explicitly.
Now for an example showing all this working. Clear your main.js file and
add the following code:
var EventEmitter = require("events").EventEmitter;
var domain = require("domain");
var emitter1 = new EventEmitter();
// Create a domain
var domain1 = domain.create();
domain1.on('error', function(err) {
console.log("domain1 handled this error ("+err.message+")");
});
// Explicit binding
domain1.add(emitter1);
emitter1.on('error',function(err) {
console.log("listener handled this error ("+err.message+")");

});
emitter1.emit('error',new Error('To be handled by listener'));
emitter1.removeAllListeners('error');
emitter1.emit('error',new Error('To be handled by domain1'));
var domain2 = domain.create();
domain2.on('error', function(err) {
console.log("domain2 handled this error ("+err.message+")");
});
// Implicit binding
domain2.run(function() {
var emitter2 = new EventEmitter();
emitter2.emit('error',new Error('To be handled by domain2'));  
});
domain1.remove(emitter1);
emitter1.emit('error', new Error('Converted to exception. System will crash!'));
Run the file to see the output:
$ node main.js
And finally, verify the output:
listener handled this error (To be handled by listener)
domain1 handled this error (To be handled by domain1)
domain2 handled this error (To be handled by domain2)
events.js:72 throw er; // Unhandled 'error' event
^
Error: Converted to exception. System will crash!
at Object. (/web/com/1427722220_30772/main.js:40:24)
at Module._compile (module.js:456:26)
at Object.Module._extensions..js (module.js:474:10)
at Module.load (module.js:356:32)
at Function.Module._load (module.js:312:12)
at Function.Module.runMain (module.js:497:10)
at startup (node.js:119:16)
at node.js:906:3

Chapter Twelve
Node.js Web Module
Web servers are software applications; it’s as simple as that. They handle
HTTP requests that the HTTP client sends them – that could be a web
browser – and they respond by returning a web page. Typically, web servers
will deliver HTML documents with style sheets. Images and scripts.
Most web servers have support for server-side scripts, and they do this using
a scripting language or sending the task elsewhere, usually to application
servers that retrieve data out of databases and perform some complex logic.
Then, the result is sent through the webserver to the HTTP client.
One of the most common is an open-source project called Apache webserver.
Web Application Architecture
Usually, web applicationS are split into four separate layers, as you can see in
the diagram below:
Let’s break this diagram down:

Client – The client layer is made up of applications, mobile
browsers, or web browsers that can make and send the web
server HTTP requests.
Server – The server layer is where the webserver resides, and
this can intercept any request the client makes and send it the
response.
Business – The business layer is where the application server
resides. The web server utilizes this for the processing that needs
to be done. It interacts with the final layer, the data layer, through
an external program or the database.
Data – The data layer contains databases and other data sources.
Using Node to Create a Web Server
In Node.js, you have access to an http module. This is used for creating a
server’s HTTP client. Below you can see the absolute minimum structure of
an HTTP server listening at port 8081. First, create a program called server.js
and then add this code to it:
var http = require('http');
var fs = require('fs');
var url = require('url');
// Create the server
http.createServer( function (request, response) { 
// Parse the request that contains the file name
var pathname = url.parse(request.url).pathname;
// Print the name of the file the request was made for.
console.log("Request for " + pathname + " received.");
// Read the requested file content from the file system
fs.readFile(pathname.substr(1), function (err, data) {
if (err) {
console.log(err);
// HTTP Status: 404 : NOT FOUND
// Content Type: text/plain
response.writeHead(404, {'Content-Type': 'text/html'});
} else {
//Page found

// HTTP Status: 200 : OK
// Content Type: text/plain
response.writeHead(200, {'Content-Type': 'text/html'});             
// Write the content of file to the response body
response.write(data.toString());
}
// Send the response body
response.end();
});  
}).listen(8081);
// Console prints the message
console.log('Server running at http://127.0.0.1:8081/');
Next, create another file, this one an html file, and name it index.htm. Save it
in the same directory server.js was created in:
<html>
<head>
<title>Sample Page</title>
</head>
<body>
Hello World!
</body>
</html>
Now you can run server.js to see what the output is:
$ node server.js
Lastly, the output needs to be verified:
Server running at http://127.0.0.1:8081/
Make a Request to Node.js Server
Open 
the 
browser 
you 
use 
and 
then 
open 
this 
address 
–
http://127.0.0.1:8081/index.htm and you should see something like this:

The output needs to be verified at the server end.
Server running at http://127.0.0.1:8081/
Request for /index.htm received.
Create a Web Client Using Node
You can also use the http module to create a web client. First, create a file
called client.js and copy the following into it:
var http = require('http');
// Options the request will use
var options = {
host: 'localhost',
port: '8081',
path: '/index.htm'
};
// We use a callback function to deal with the response
var callback = function(response) {
// The stream is continuously updated with data
var body = '';
response.on('data', function(data) {
body += data;
});
response.on('end', function() {
// Data completely received.
console.log(body);
});

}
// Make a request to the server
var req = http.request(options, callback);
req.end();
Now open a different command terminal to server.js and run client.js to see
what the result is:
$ node client.js
Don’t forget to verify the output:
<html>
<head>
<title>Sample Page</title>
</head>
<body>
Hello World!
</body>
</html>
And then verify at the server end:
Server running at http://127.0.0.1:8081/
Request for /index.htm received.
As you can see, the web module is pretty easy to use for creating web servers
and clients.

Chapter Thirteen
Node.js Express Framework
In this chapter, we are going to look at Express, a framework built as a
flexible but minimal web app framework for Node.js. It provides a robust
feature set that helps us build both single and multiple-page web applications,
as well as hybrid ones.
What is Express.js?
It is a web application server framework built on Node.js to help us build
different types of web applications. Now the standard Node.js server
framework is the backend of the MEAN stack. This is an open-source, free
software stack that helps us in building dynamic web applications and
websites, and it has these components:
1. MongoDB – this is the standard NoSQL database
2. Express.js – this is the default framework for web applications
3. Angular.js – this is the JavaScript MVC framework that we use
in web applications
4. Node.js – this is the framework for scalable networking and
server-side applications
With the Express framework, you can easily develop applications that can
handle several request types, such as PUT, GET, DELETE, and POST
requests.
Installing and Using Express
Express is easy enough to install; it’s done from the Node Package Manager
by opening the command line and inputting this command:
npm install express

This command is asking the Node Package Manager to download the Express
modules and install them.
Let’s start by creating a Hello World application. All it will do is create a
server module. This listens on port 3000, and, in this example, if a request
comes through this port on the browser, the server application sends the
response – in this case, Hello World – to the client.
var express=require('express');
var app=express();
app.get('/',function(req,res)
{
res.send('Hello World!');
});
var server=app.listen(3000,function() {});
Code Explanation:
1. In line one, the require function is used to include the specified
module, in this case, the express module
2. Before the module can be used, an object must be made from it
3. In line three, we create the callback function, which gets called
when the root of the web application is browsed to – the root is
http://localhost:3000. The callback function sends the response,
which is a string reading Hello World, to the web page as a
response.
4. The string, Hello World, is sent by the callback function to the
client. A parameter of res is used for sending the content to the
web page. The parameter is provided in the request module and
allows the content to be sent to the web page.
5. Lastly, listen to function is used to make the application listen on
port 3000 to client requests. Any available port can be specified.
Provided the command successfully executes, you should see something like
thin in your browser when the code is run:
Output:

From this output, you can see that if the localhost URL is browsed to on port
3000,  the string, Hello World, is shown on your page. Provided you browse
to the specified port that the server listens to, you can see the right output on
your screen.
What are Routes?
Routes determine how a client request for a specific endpoint is responded to
by the application. For example, the client can make http requests, such as
POST, GET, DELETE, or PUT, for any URL, such as these:
http://localhost:3000/Books
http://localhost:3000/Students
In this example, when a GET request is made on the first of the URLs, the
ideal output would be a list of books, while if it was made on the second one,
you would see a list of students. Based on what URL you access, certain
functionality is invoked on the webserver, and the response is sent on to the
client – that is how routing works.
Each route can have at least one handler function and, when the route is
matched, these are executed.

The typical route syntax is:
app.METHOD(PATH, HANDLER)
In the syntax:
1. app is an express module instance
2. METHOD is one of the HTTP request methods, i.e., POST,
GET, DELETE, or PUT
3. PATH indicates a server path
4. HANDLER is a function that is executed when a route has been
matched
Let’s see how routes can be implemented in Express. We will create three
routes:
1. A /Node route – this displays the Node Tutorial string when the
route is accessed
2. A /Angular route – this displays the Angular Tutorial string if the
route is accessed
3. A default route / - this will display the Welcome to My Tutorials
String
The basic code is the same as we have seen previously, and the code below is
an add-on showing how to implement routing:
var express = require('express');
var app = express();
app.route('/Node').get(function(req,res)
{
res.send("Node Tutorial");
});
app.route('/Angular').get(function(req,res)
{
res.send("Angular Tutorial");
});
app.get('/',function(req,res){
res.send('Welcome to My Tutorials');
}));
Code Explanation:

1. The route is defined if the http://localhost:3000/Node URL is
accessed in the browser. A callback function is attached to the
route, and this is called when the Node URL is browsed to.
There are two parameters to the callback function:
res is the primary parameter used for sending information
to the client
req is the secondary parameter and contains information
pertaining to the request.  On occasion, other parameters
may be sent with the request, and the req parameter helps
find those parameters.
2. The send function is used to  send the Node Tutorial string to the
client should the Node route be chosen
3. The route is defined if the http://localhost:3000/Angular URL is
visited in the browser. A callback function is attached to the
callback function, which is called when the Angular URL is
browsed to.
4. The send function is used to send the Angular Tutorial string to
the client should the Angular route be chosen.
5. The default route is chosen if the http://localhost:3000/Angular
URL is visited in the browser – this is the application root. When
this is chosen,  the Welcome to My Tutorials message is sent to
the client.
Provided the command successfully executes, you should see the Welcome to
My Tutorials screen in your browser.
The output will show that, by browsing to the localhost on port 3000 URL,
the Welcome to My Tutorials message is shown on the screen – this is the
default message that we specified in the code.
Building a Web Server with Express.js
In our example above, we saw how to decide what the output should be based

on a route. This is what is used in modern-day web applications, while the
rest of the webserver is all about using Node.js templates.
When you create quick Node applications on the fly, one of the easiest ways
to do it is to use Node.js templates. There are loads of frameworks in the
market, and we are going to use the jade framework.
The Node Package Manager is used to install jade by inputting the following
on the command line:
npm install jade
This command asks the NPM to download the modules we want and install
them.
Let’s create a jade template. Create a new file and call it index.jade and put
the following code in, making sure the file is created in the folder called
views.
The page title is going to be changed to the value that gets passed when
invoking the template. We are also indicating that the header tag text will be
replaced with what is passed in the template.
var express=require('express');
var app=express();
app.set('view engine','jade');
app.get('/',function(req,res)
{
res.render('index',
{title:'My Tutorials',message:'Welcome'})

});
var server=app.listen(3000,function() {});
Code Explanation:
1. First, “view engine” is specified in the applications – this is used
for rendering the templates and, because jade is being used, that
is what we specify.
2. We use the render function for rendering the web page. Here, we
render the index.jade template we created before.
3. We pass two values into the title and message parameters – “My
Tutorials” and “Welcome” respectively. These are replaced by
the parameters we specified in the template for the title and
message parameters.
If you successfully execute the command, you will see the Welcome screen
in your browser.
From the output, you can see that the page title is set as My Tutorials and the
page header is set as Welcome. This happens because we invoked the Jade
template in the application.
Quick Summary
The Express framework is commonly used in the development of
applications in Node.js and is built on the Node framework. It is used to help
us build server-based applications quickly.
We use routes to divert our users to different areas in the application based on
what they request – the route responses may be varied based on what the user
needs to see.
Lastly, templates are used for efficiently injecting the right content, and one
of the more popular templating engines for Node applications is Jade.

Chapter Fourteen
Node.js RESTful API
Let’s start with the name – REST comes from Representational State
Transfer. First introduced in 2000 by Roy Fielding, REST is an architecture
with web-based standards that uses the HTTP protocol. REST revolves
around resources – all components are resources, and a common interface
accesses these by using the standard HTTP methods.
REST servers basically provide an access point to the resources, and the
REST client uses the HTTP protocol to access the resources and modify
them. URIs and global IDs are used to identify each resource, and REST
represents resources in different ways, such as XML, and text but the most
common representation is JSON,
HTTP Methods
These are the four most common HTTP methods used in REST architecture:
GET – used for providing read-only access to resources.
PUT – used for creating new resources.
DELETE – used for removing resources.
POST – used for updating resources or creating new ones.
RESTful Web Services
Web services are collections containing standards and open protocols for the
exchange of data between systems and applications. Software applications
use web services for data exchange over computer networks – these
applications are written in all sorts of programming languages and are run on
all platforms. The interoperability, i.e., when Python and Java communicate
or Linux applications and Windows applications, is all down to the open
standards.

When a web service is based on REST architecture, it is called a RESTful
web service. These implement the REST architecture concept by using HTTP
methods. Typically, a RESTful web service will define a Uniform Resource
Identifier (URI), a service that provides a representation of the resources, like
JSON and the HTTP methods.
How to Create RESTful for a Library
Let’s say that we have a database, based on JSON, containing a list of users
in a file called users.json:
{
"user1" : {
"name" : "michael",
"password" : "password1",
"profession" : "teacher",
"id": 1
},
"user2" : {
"name" : "sara",
"password" : "password2",
"profession" : "scientist",
"id": 2
},
"user3" : {
"name" : "ronnie",
"password" : "password3",
"profession" : "clerk",
"id": 3
}
}
Using this information we can provide all of these RESTful APIs:
URI
HTTP
Method
POST Body
Result
1
listUsers
GET
Empty
Shows list of all
the users
2
addUser
POST
JSON string
Adds a new
user’s details
3
deleteUser
DELETE
JSON string
Deletes a user

4
:id
GET
Empty
Shows a user’s
details
I am assuming that, by now, you already know how to pass values, using
form data or AJAX, from the front end and how to use the Express Request
object to process them.
List Users
The first RESTful API we will implement is listUsers. Create a file called
server.js and add the following code:
var express = require('express');
var app = express();
var fs = require("fs");
app.get('/listUsers', function (req, res) {
fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) {
console.log( data );
res.end( data );
});
})
var server = app.listen(8081, function () {
var host = server.address().address
var port = server.address().port
console.log("Example app listening at http://%s:%s", host, port)
})
Now use http://127.0.0.1:8001/listUsers together with HTTP Method: GET
on a local machine. Make sure you use a REST client so you can access the
API and you should see the result below – given IP addresses can be changed
when you use this code in a production environment:
{
"user1" : {
"name" : "michael",
"password" : "password1",
"profession" : "teacher",
"id": 1
},
"user2" : {
"name" : "sara",
"password" : "password2",
"profession" : "scientist",
"id": 2
},

"user3" : {
"name" : "ronnie",
"password" : "password3",
"profession" : "clerk",
"id": 3
}
}
Add User
The next RESTful API we will implement is newUser, using these details:
user = {
"user4" : {
"name" : "monica",
"password" : "password4",
"profession" : "teacher",
"id": 4
}
}
The same input can be accepted in the JSON form using an AJAX call but,
for the purposes of this chapter, we are hard-coding everything. Clear your
server.js file and add the following:
server.js
var express = require('express');
var app = express();
var fs = require("fs");
var user = {
"user4" : {
"name" : "monica",
"password" : "password4",
"profession" : "teacher",
"id": 4
}
}
app.post('/addUser', function (req, res) {
// First read existing users.
fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) {
data = JSON.parse( data );
data["user4"] = user["user4"];
console.log( data );
res.end( JSON.stringify(data));
});
})
var server = app.listen(8081, function () {
var host = server.address().address
var port = server.address().port
console.log("Example app listening at http://%s:%s", host, port)
})

Now attempt to access it via URL:http://127.0.0.1:8081/addUser and HTTP
Method : POST. Use a local machine and a REST client and you should see
the following:
{
"user1":{"name":"michael","password":"password1","profession":"teacher","id":1},
"user2":{"name":"sara","password":"password2","profession":"scientist","id":2},
"user3":{"name":"ronnie","password":"password3","profession":"clerk","id":3},
"user4":{"name":"monica","password":"password4","profession":"teacher","id":4}
}
Show Detail
Now we want to implement a RESTful API that is called with the user ID and
displays the corresponding user’s details. Again, clear the server.js file and
add this code:
server.js
var express = require('express');
var app = express();
var fs = require("fs");
app.get('/:id', function (req, res) {
// First read existing users.
fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) {
var users = JSON.parse( data );
var user = users["user" + req.params.id]
console.log( user );
res.end( JSON.stringify(user));
});
})
var server = app.listen(8081, function () {
var host = server.address().address
var port = server.address().port
console.log("Example app listening at http://%s:%s", host, port)
})
The same as before, use a local machine and a REST client to try accessing it
using http://127.0.0.1:8081/2 and HTTP Method : GET and you should see
this:
{"name":"sara","password":"password2","profession":"scientist","id":2}
Delete User
This is much like the addUSer API. The input data comes via req.body and,
using the user ID, we delete the right user from the system. Keeping things

simple, we will delete user ID 2. Clear the server.js file and add this code:
var express = require('express');
var app = express();
var fs = require("fs");
var id = 2;
app.delete('/deleteUser', function (req, res) {
// First read existing users.
fs.readFile( __dirname + "/" + "users.json", 'utf8', function (err, data) {
data = JSON.parse( data );
delete data["user" + 2];
console.log( data );
res.end( JSON.stringify(data));
});
})
var server = app.listen(8081, function () {
var host = server.address().address
var port = server.address().port
console.log("Example app listening at http://%s:%s", host, port)
})
Once more, using a local machine and a REST client, access
http://127.0.0.1:8081/deleteUser and HTTP Method : DELETE and you
should see this:
{"user1":{"name":"michael","password":"password1","profession":"teacher","id":1},
"user3":{"name":"ronnie","password":"password3","profession":"clerk","id":3}}
There isn’t much more to the RESTful APIs  - all you need to know is how to
define the APIs and use the HTTP Methods.

Chapter Fifteen
Node.js Scalable Applications
Node.js scalability is not something that was stuffed in later; it is a core part
of the Node runtime. The reason Node is named as it emphasizes how a Node
application should be built – of distributed, small nodes that talk to each
other.
Let me ask you a few questions:
1. Do your Node applications have multiple nodes?
2. Do you have a Node process running on all the CPU cores on
your production machines, and are all the requests between them
load-balanced?
3. Did you know that there is a built-in module in Node to help you
with all of this?
It’s called Cluster, and it provides a solution to help you utilize the CPU
power your machine offers. More than that, it also ensures your Node
processes have better availability and gives an option for restarting the entire
application without any downtime.
Putting that aside, let’s dive into scalability strategies.
Strategies of Scalability
One of the best reasons why we scale our Node applications is because of the
workload, but it isn’t the only reason – two others include increasing
availability and increasing the tolerance to failure.
There are three primary ways an application can be scaled:
1. Cloning

The easiest way of scaling applications, especially large ones, is cloning it
several times and having each clone handle a certain part of the workload, for
example, with a load balancer. This costs little in development time and is
one of the most effective ways of doing it. This is the absolute minimum
strategy that you should be doing, and you can use the Cluster module built
into Node to make implementing the strategy simple on a single server.
2. Decomposing
An application can also be scaled by decomposing it. This is done based on
services and functionalities, which means having several applications with
their own codebases and, on occasion, their own User Interface and dedicated
database.
We typically associate the decomposition strategy with a term called
Microservice. Micro indicates that the services should be small, but the
reality is that the service size isn’t important; what is important is how high
cohesion and loose coupling are enforced between the services. 
Implementing this strategy is not always easy and has the potential to cause
long-term issues; done right, it offers huge advantages.
3. Splitting
The final strategy involves splitting the application into several smaller
instances – each instance is responsible for its own small part of the
application's data. Often, you will see this strategy known as sharding or
horizontal partitioning in databases. In data partitioning, a lookup step is
required before every operation. This determines which application instance
should be used. For example,  we might want our users partitioned based on
language or country, and we would need that information looked up first.
When you scale a large application successfully, eventually, all three of these
strategies should be implemented. While Node.js does make it simple to do
all of this, I will be focusing on using the first strategy, cloning, as it is the
most basic, and take a look at the Node.js tools needed to implement it.
Before you move on, you do need to have a good idea of how the Node child
processes work.

The Cluster Module
You can use the built-in cluster module to enable load balancing over the
CPU cores in an environment. The module is based on the fork method from
the child process module, allowing the main application process to be forked
as many times as there are CPU cores. Then, it takes over the requests that go
to the main process over the forked processes and load balances them.
The Cluster module is a helper provided by Node.js, helping us get this
cloning strategy implemented but only on a single machine. Where you have
larger machines with multiple resources or when it works out cheaper and
easier to add extra resources to a single machine over adding other machines,
the Cluster module works well, helping you implement the strategy quickly.
Even a small machine is likely to have several cores; even if you are not
concerned about your Node server’s load, the Cluster module should be
enabled anyway, increasing your server's availability and fault tolerance
level. It is easy to do and, when you use a process manager, such as PM2, for
example, all you have to do is provide the launch command with an
argument.
Let’s look at how the cluster module is used natively and how it works.
The Cluster module structure is quite simple. A master process is created to
fork and manage several worker processes. The worker processes each
represent an application instance that needs to be scaled. The master process
handles all the incoming requests and decides which worker process an
incoming request should be handled by.

The master process has a relatively easy job because it picks the worker
process using a round-robin algorithm. This is already enabled as a default
setting on all platforms except for Windows, and global modification can let
the operating system handle the load balancing.
The load is evenly distributed across the available processes by the round-
robin algorithm, using a rotational basis process. The first incoming request
goes to the first available worker process, the second to the second process,
and so on. When the list has got to the end, the algorithm will go right back to
the beginning and start over.
This is one of the easiest load balancing algorithms to use, but it’s one of
many. There are other algorithms that allow priorities to be assigned and the
least loaded server selected or the one that responds the quickest.
Load-Balancing an HTTP Server
Let’s get into some practical work. We want to close a simple HTTP server
and load balance it using the Cluster module. We’ll use the hello-world
example server from Node and modify it slightly to simulate CPU work
before it responds.
Create a server.js file and add the following code:

// server.js
const http = require('http');
const pid = process.pid;
http.createServer((req, res) => {
for (let i=0; i<1e7; i++); // simulate CPU work
res.end(`Handled by process ${pid}`);
}).listen(8080, () => {
console.log(`Started process ${pid}`);
});
I have included process pid inside the HTTP response. This will verify our
balancer will work by identifying the application instance that is handling a
request.
Before a cluster is created for cloning the server into several worker
processes, we need to run a benchmark to see how many requests can be
handled by the server every second. The Apache benchmarking tool is a good
one for this; once the server code above has been run, go ahead and run the
command below:
ab -c200 -t10 http://localhost:8080/
This uses 200 concurrent connections to test-load our server for 10 seconds.
My machine managed about 51 requests every second when I tried it, but
these results will differ by machine and platform. This is just a simple test
that gives you an idea of performance but must not be taken as being 100%

accurate – all it will show you is what difference using a cluster makes on an
environment with several cores.
We now have a benchmark we can use for reference, so now is the time to
use the Cluster module to use cloning to scale the application.
Using the same server as your server.js file, create another new file and name
it cluster.js. This is for the master process and needs the following content:
// cluster.js
const cluster = require('cluster');
const os = require('os');
if (cluster.isMaster) {
const cpus = os.cpus().length;
console.log(`Forking for ${cpus} CPUs`);
for (let i = 0; i<cpus; i++) {
cluster.fork();
}
} else {
require('./server');
}
In our cluste.js file, first, we required the os and the cluster modules. The os
module is used to read how many CPU cores that os.cpus() can work with.
With the cluster module, we get the isMaster Boolean flag that is used to see
if the cluster.js file is loaded as a master process. When the file is executed
the first time, the master process is executed, and the isMaster flag is set a
true. The master process can be instructed to fork the server as many times as
there are CPU cores.
Now that we have used the os module to read how many CPU cores we
have,  we can use a for loop over the number to call the cluster.fork method.
All the for loop does is creates the number of workers that matches the
number of system CPUs, taking full advantage of the system’s processing
power.
When cluster.fork is executed in the master process, cluster.js is run once
more but in worker mode this time, with isMaster set as false. If you need it,
there is an isWorker flag that can be run in this case, set as true.
The application can begin to do the real work when it is run in worker mode,
and this is where the server logic needs to be defined. In this example, we can
require the server.js file we created to do this.

That’s pretty much it. That is how you can take advantage of your machine’s
processing power and testing the cluster is as simple as running cluster.js:
Because my machine has eight cores, eight processes were started. What you
must understand is that each process is a different Node.js process – every
individual worker process has an event loop and memory space of its own.
Now, when the webserver is hit multiple times, different worker processes
will begin handling the request, and each process has its own process id. The
workers are not sequentially rotated because the cluster module only picks a
worker after performing a few optimizations, but the load will be evenly
distributed throughout all the worker processes.
The ab command we used above can now be used again to load-test the
process clusters:

The cluster created on my machine could handle around 181 requests every
second, compared to the 52 requests per second we got from a single Node
process. With just a couple of lines of code, we tripled this simple app’s
performance.
Broadcasting Messages to All Workers
The communication between the master and worker processes is simple
because the child_process.fork API is being used under the hood by the
Cluster module. This means there are also available communication channels
between the master and each worker process.
Using our example from above, the list of worker objects can be accessed
using cluster.workers. This is another object containing references to each
worker and used for reading information about them. Because there are
communication channels between the master and worker processes,
broadcasting a message to them all requires nothing more than a loop over
the workers. Here’s an example:
Object.values(cluster.workers).forEach(worker => {
worker.send(`Hello Worker ${worker.id}`);
});
Object.values is used to obtain an array containing the workers in the
cluster.workers object. The send function is used, for each individual worker,

to send the values that we want.
In our server.js file, which is the worker file, when a message is received
from the master process, it is read by registering a message event handler on
the global process object. Here’s an example:
process.on('message', msg => {
console.log(`Message from master: ${msg}`);
});
When I test these additions to our server/cluster example, this is what I see:
Here, the master process sent every worker a message. One thing to note
from this is that the workers didn’t start in the order they were in.
Let’s make things a bit more practical. We want to make our server reply
with a number indicating how many users were created in the database. We
need a mock function that will return the number indicating how many users
are in the database and, whenever it is called, we want the value squared –
this is known as dream growth:
// **** Mock DB Call
const numberOfUsersInDB = function() {
this.count = this.count || 5;
this.count = this.count * this.count;
return this.count;
}
// ****

Whenever we call numberOfUsersInDB, we assume that a connection to the
database has been made. To get away from multiple DB requests being made,
we want this call cached for a set period, like 10 seconds.  What we don’t
want is the eight forked workers doing their own requests because we don’t
want eight requests every 10 seconds. Instead, the master process can just do
one request and let the workers know the new user count value through the
communication interface.
For example, in the master process mode, we can use one loop for
broadcasting that value to all of the workers:
// Immediately after fork loop within isMaster=true block
const updateWorkers = () => {
const usersCount = numberOfUsersInDB();
Object.values(cluster.workers).forEach(worker => {
worker.send({ usersCount });
});
};
updateWorkers();
setInterval(updateWorkers, 10000);
Here, updateWorkers was invoked for the first time, and then a setInterval
was used to invoke it every 10 seconds. That way, all the workers will get the
new value for the user count every 10 seconds via the communication
channel, ensuring that only a single connection is made to the database.
The usersCount value can be used in the server code, with the exact same
handler for the message event. We need to use a module global variable to
cache the value, and then we can use it where we need it.
Here’s another example:
const http = require('http');
const pid = process.pid;
let usersCount;
http.createServer((req, res) => {
for (let i=0; i<1e7; i++); // simulate CPU work
res.write(`Handled by process ${pid}\n`);
res.end(`Users: ${usersCount}`);
}).listen(8080, () => {
console.log(`Started process ${pid}`);
});
process.on('message', msg => {
usersCount = msg.usersCount;
});

Here, the worker web server is made to respond with the value of the cached
usersCount. If the cluster code were tested now, you would get a value of 25
within the first 10 seconds, as the total user count from all the workers – and
don’t forget, only one DB request gets made. After a further 10 seconds, you
would see all the workers start to report the new count of 625, with just one
more request being made.
This is all down to there being communication channels running between the
workers and the master process.
Increasing Availability of the Server
When you run a single Node application instance, there is a problem in that
the instance must be restarted whenever it crashes. That means there will be
some downtime between the crash and the restart, even with automated
processes.
This will also apply when the server needs to deploy new code and has to be
restarted – with a single instance, there will be some downtime, and that will
affect the system availability.
When you are working with several instances, you just need a few extra lines
of code to increase the system availability.
The example below is a simulation of the server process randomly crashing.
To do this a call to process.exit is made in a timer that will fire after a random
time:
// In server.js
setTimeout(() => {
process.exit(1) // death by random timeout
}, Math.random() * 10000);
When worker processes exit in this manner, the master process is sent a
notification. This is done with the cluster model object’s exit event and a
handler can be registered for the event, with a new worker process being
forked whenever another worker process exits. Here’s an example:
// Immediately after fork loop within isMaster=true block
cluster.on('exit', (worker, code, signal) => {
if (code !== 0 && !worker.exitedAfterDisconnect) {
console.log(`Worker ${worker.id} crashed. ` +
'Starting a new worker...');
cluster.fork();

}
});
It makes sense to add an if condition as this ensures the worker process
crashed and wasn’t disconnected manually by the user or that the master
process didn’t kill it. For example, the master process may determine that too
many resources are being used based on what load patterns it observes, and if
that is the case, it will need to kill some workers. To do this, the disconnect
methods can be used on a worker and the exitedAfterDisconnect flag set as
true. The if statement we included guards against a new worker being forked
in that case.
If the cluster were run using the above handler, along with the server.js
random crash, workers will begin crashing after a random amount of time in
seconds. The master process will begin forking new ones to increase the
system’s availability. The availability can actually be measured with the ab
command we used earlier – it will show you the number of requests the
server cannot handle. That’s because some of the requests will be unlucky
enough to face the crash and that cannot really be avoided.
I tested this code, and I got 17 failed requests in the 10-second test out of
more than 1800, and that was using 200 concurrent requests:
That shows availability of more than 99%. With just a couple of extra lines of

code, we can forget about process crashes because the master guardian is
watching them for us.
Zero-Downtime Restarts
So, what about when we want all worker processes restarted, say when we
need new code deployed?
We’ve got several running instances so, rather than all of them be restarted
together; they can be restarted one at a time, leaving the other workers
serving requests while one is restarted.
This is pretty easy to implement using the Cluster module. Once the master
process is up and running, we don’t want it restarted so we need to find a way
of sending a command to it to tell it to begin restarting the workers. If you are
using Linux, this is easy because you just listen to SIGUSR2, or some other
process signal. The kill command can be triggered on the process id, and the
signal passed:
// In Node
process.on('SIGUSR2', () => { ... });
// To trigger that
$ kill -SIGUSR2 PID
In this way, the master process is not killed, and we can tell it to start doing
something else. SIGUSR2 is the correct signal to use in this case because it is
a user command. SIGUSR1 is used by Node as a debugger, and you really
don’t want any conflicts.
On Windows, there is no support for those process signals, so another way
needs to be found. There are few ways – we could use socket or standard
input. Or we could monitor the process.pid file for a remove event. To keep
things simple, I’m using Linux though, so you may just have to read this and
not follow along practically if you use another system.
While Node does work okay on Windows, Linux is a safer platform for
hosting Node applications on. It might interest you to know that, if you are
using the latest Windows versions, you can make use of a Linux subsystem –
if you are interested, look at Bash on Windows.
Back to our example,  when the SIGUSR2 signal is received by the master
process, it tells it the workers can be restarted but we want this done one at a

time. What this means is that the master process should only restart a worker
when the previous one has been restarted.
To start this, what we need is a reference to all the current workers and we do
this using the cluster.workers object. Then, the workers can be stored in an
array:
const workers = Object.values(cluster.workers);
After that, a restartWorker function can be created to receive an index for the
worker that needs to be restarted. That way, the function can call itself when
it is ready for a worker, ensuring the workers are restarted in sequence.
Here’s an example of that function:
const restartWorker = (workerIndex) => {
const worker = workers[workerIndex];
if (!worker) return;
worker.on('exit', () => {
if (!worker.exitedAfterDisconnect) return;
console.log(`Exited process ${worker.process.pid}`);
cluster.fork().on('listening', () => {
restartWorker(workerIndex + 1);
});
});
worker.disconnect();
};
restartWorker(0);
In the function, we get a reference to worker that needs to be restarted. This
function is being called recursively so a sequence can be forms so we need to
add a stop condition. When there are no workers left to restart, we can return.
Then, we want to use worker.disconnect to disconnect the worker but, before
the next worker is restarted, a new worker needs to be forked to replace the
one being disconnected.
The exit event can be used on the worker to fork new workers when a current
one is already in existence. However, we need to be sure that, after a
disconnect call, the exit action got triggered, and we can do that using the
exitedAfterDisconnect flag. If the flag is not true, something other than the
disconnect call triggered the exit – in that case, we can return, and we don’t
need to do anything else. However, if it is true, a new worker can be forked to

replace the disconnected one.
When the new worker is ready, the next one can be restarted. However, keep
in mind that fork processes are not synchronous, so the next worker cannot
just be restarted after the call to fork. Instead, the listening event needs to be
monitored on the new forked worker – this will tell us that the worker is
connected. Once we get the event, the next worker in the sequence can be
restarted safely.
That is all that is needed for a restart with zero downtime. Testing it is just a
case of reading the master process id that is going to the SIGUSR2 signal:
console.log(`Master PID: ${process.pid}`);
Start the cluster, then the master process id needs to be copied, and the kill -
SIGUSR2 PID command is used to restart the cluster. The ab command can
also be run while the cluster is being restarted, showing you the effect this
will have on the system availability. In theory, you should not get any failed
requests:
PM2, and other process monitors that you use in production should make all
of this pretty easy to do, as well as providing you with tons of features to
keep an eye on your Node application’s health. As an example, if you use
PM2 and want a cluster launched for any application, all you need is the -i

argument:
pm2 start server.js -i max
And a zero downtime restart requires just this simple command:
pm2 reload all
However, while it's easy for me to tell you which commands to use,
understanding what is happening under the hood is very important.
Shared State and Sticky Load Balancing
Like all good things, there is always a cost. When a Node application is load-
balanced, some of the features that suit single processes are lost, and this is
similar to what you might know as thread safety in other programming
languages. Thread safety is all about data sharing between threads but, in our
cases, it’s all about data sharing between the worker processes.
Take the cluster setup, for example. Things can no longer be cached in
memory because each worker process has memory space of its own. Caching
something in one worker’s memory means it is not accessible to any of the
other workers.
If something needs to be cached in a cluster setup, a separate entity is
required. All workers need to be able to read and write to the API for that
entity, which could be a database server or, where you want in-memory cache
used, Redis or another server could be used. Alternatively, you could create a
Node process containing a Read/Write API that all the other workers can talk
to.

This isn’t a disadvantage though, and you shouldn’t see it that way – using
separate entities for caching needs falls under one of the scalability strategies
– decomposing. In fact, even if you are using a single-core machine, you
should really be doing this anyway.
When running a cluster setup, besides caching, something else becomes a
problem – general stateful communication. Because there is no guarantee the
communication will be with the same worker, it isn’t an option to create
stateful channels on any specific worker.  User authentication is one of the
most common examples of this:

In a cluster setup, the authentication request is sent to the master balancer
process. From there, it is sent on to a worker – in this example, we assume
that to be Worker A:
Now, Worker A recognizes this user’s state. However, if another request is
made by the same user, eventually it will be sent to the other workers by the
load balancer, even though they don’t have the user authenticated. It will no

longer work to keep a reference to authenticated user sessions in memory for
a single instance.
We can solve this in a few ways. We could just share the state across all the
workers – this is done by storing the information for these sessions in a Redis
node or a shared database. However, some code changes would be needed for
this strategy and it isn’t always an option to do that.
If modifying the code to make this shared session storage is not possible,
another strategy could be used, although it isn’t as efficient.  You can use
something called Sticky Load Balancing, and implementing it is easier as it is
supported out of the box by many load balancers. It’s a simple idea – when a
user is authenticated with an instance of a worker, a record of the relationship
is maintained on the load balancer level:
Now, when a new request is sent by the same user, a lookup is done in the
record to work out which server has the authenticated session; the requests
are then sent to that server, rather than using the standard distributed
behavior. That way, the server-side code doesn’t have to be changed. What
we don’t get is the load balancing benefits for the authenticated users so it
really is something you should use if there is no other way.
Sticky load balancing is not actually supported by the cluster module, but
there are some load balancers that do it by default.

Chapter Sixteen
Node.js Packaging
In recent times, the popularity of Node.js has shot up, with JavaScript being
ranked as the top programming language for many years – by now, you
should understand why that isn’t so surprising.
JavaScript is the ubiquitous front-end web programming language, meaning
developers use and understand it, no matter what programming language they
have used in the past – C, C#, Java, Ruby, and so on. Because the number of
developers already using JavaScript is so huge, the community is already full
of frameworks and libraries, offering help for just about every requirement.
That means it’s the right approach to use it for server-side projects.
Things Do Go Wrong
Sometimes, and for no apparent reason, many programmers who switch from
a compiled to a scripted language leave their good programming habits
behind.
All too often, we see programmers developing applications in Node.js, or
pure JS applications using Node.js, storing their code somewhere like GitHub
and then trying to pull it straight to their production servers. Then they follow
it with an npm install and a web build – sometimes, they write tests but, more
often than not, they decide it is much easier to rebuild it all whenever they
deploy their application. This can cause a number of problems:
Dependency Versioning
When your packages.json file includes a semver, you could end up with your
config telling you a package dependency requires a match to a specific
version, say 4.17.2. Your production machine will pull 4.17.3 down, and then
4.17.4 is used to run tests against. By the time you get to deploy your
production, the author of the library has updated it once again, and your
software ends up on version 4.17.9 – this is in production. Many times,

library authors have updated their libraries with significant changes that can
break production, whether they did it accidentally or just didn’t realize what
effect their changes would have.  Their update bumps up the version number,
and this can cause broad versioning, leading to serious code crashes. This is
further exacerbated by a dependency chain that is incredibly complex in your
node_modules.
Let’s say you have Module A, an explicitly dependent module that depends
on a version range of Module B. In turn, Module B is dependent on a version
range of several more modules. Don’t forget – when npm install is run, you
are not just dynamically determining your modules and resolving them – it is
everything else in the dependency chain. Using the recently added package-
lock feature can go some way towards mitigating this so long as the file is
committed to source control.
Deployment Success is Not In Your Control
Whenever your application is deployed, you download new dependencies
that are potentially untested. And that’s only if everything goes to plan. It
isn’t news that npm doesn’t support the ability to push new files onto old
versions anymore but, more than once, we’ve seen production releases failing
because the packages weren’t downloaded – typically because npm was
down or there were issues with the network. Often, this installation failure
goes hand-in-hand with the old version being overwritten. The result of this is
a server that is worth nothing until npm access is brought back. I can tell you
of one case where a developer was doing a fresh install every time they
wanted a new server from their AWS Elastic Beanstalk, when the farm they
already had was loaded.  Because the npm servers were out, the new ones
couldn’t come online and because not all the traffic could be handled, the
website, which was working just fine, suddenly crashed too – many days
before, the original installation had succeeded and all the new servers were
getting the same product version deployed to them.
Luckily, there is a way out of this.
Packaging Your Node.js App
We should be able to agree on one thing – all JS applications should be
treated the way we treat any other compiled language – at build time, the

applications should be packaged up into an artifact that can be deployed.
Let’s assume, for the purposes of this chapter, that we are going to develop
the RandomQuote-JS dummy app. We could do this as a very simple build
step:
> npm install
> gulp build    # insert the build tool you want
> zip -r ../RandomQuotes.1.0.zip .
# ../RandomQuotes.1.0.zip created (5.2 MB)
The zip file that gets generated could then be extracted onto your production
servers and the application would be ready to run as it is.  However, here we
have zipped the entire application directory and most of this is the libraries
needed to compile and debug the application. The typescript compilers are
not really needed, neither are the testing frameworks or webpack libraries,
once the application has been fully built and is ready to put into production.
The big question is, how do we keep the production and dev-time
dependencies separate?
Running the following npm removes all the packages specified in the
package.json devDependencies section from node_modules:
npm prune --production
It is recommended that you run this before your entire application is zipped
into  an archive file, no matter whether you use a manual process or a
deployment tool such as VSTS, Octopus Deploy, or Chef.
We can make the entire process simpler by using octojs. This is Node.js cli
tool released by Octopus Deploy and helps us create the zip or tar.gz files
without needing to do that prune step first. By default, the package name gets
generated with the same name and same version as you have in the
package.json file for your project. However, all of those values can be
overridden. You can use octojs in two ways – imported and then used as part
of your application’s build process or through the console.
Package Using the Command-Line
The easiest way is globally installing the tool:
> npm install -g @octopusdeploy/octojs

Now, you can invoke octojs from inside any project and get it to package
your application. Let’s assume that we built our project and tested it; we can
now package it in this simple way:
> octojs pack -O C:\Bin --gitignore --dependencies prod
Created package C:\Bin\RandomQuotes.1.0.0.zip (1.66 MB)
The generated package size is significantly smaller and the ID and version for
the package come from the project. Now the package is generated, it can be
pushed straight to the built-in Octopus Deploy feed so it can be deployed:
> 
octojs 
push 
--package 
C:\Bin\ramdomquotes.1.0.0.zip 
--server
http://octopusserver.acme.com --apiKey API-F2K29BA08AA123
Push response 201 - Created
Package Using the Code
An alternative way is to package your project and push it through your code
by one step, using the same library:
var octo = require("@octopusdeploy/octojs");
octo.pack({dependencies: 'prod', bypassDisk: true, root: "."},
(err, data) => {
console.log("Uploading package: "+ data.name);
octo.push(data.stream, {
apiKey: 'API-F2K29BA08AA123 ',
server: 'http://octopusserver.acme.com',
name: data.name
}, () => console.log("Uploaded"));
}
})
.append('hello.txt', new Buffer('This Is An Additional File'))
.finalize(true);
You can find the octojs library on GitHub as an open source package, along
with both grunt and gulp versions to help your get your project packaged
during the building process.
Node is a Serious Language
And it’s time we started treating it as such in our CD pipelines. What this
means is that dependencies can be downloaded and built or transpiled on the
build server once and the result packaged with its dependencies into one self-
contained package for deployment.

You can use the Octopus JS libraries to help you with this but, at the end of
the day, it really doesn’t matter how the application is built and packaged,
what tool you use to do it with; all that really matters is that it is only built
once and then deployed across each environment.

Chapter Seventeen
MongoDB + Mongoose with Node.js – Best
Practices for Back End Developers
MongoDB has to be one of the most popular of all NOSQL databases and it
is backed up with a fantastic ecosystem and a great community. This chapter
will cover some of the best practices to follow when you use MongoDB and
Mongoose with your Node.js applications:
Why You Need Mongoose
Understanding Mongoose requires that we understand the way MongoDB
and databases work at an architectural level.
Let’s say you have:
1. A database server, i.e. a MongoDB community server
2. A running Node.js script as a process
The server will typically listen on a TCP socket while the Node.js process
connects to the server with a TCP connection. However, MongoDB also has
a protocol of its own to help it understand what the process, which is the
client, needs from the database.
Rather than learning all the messages needed to be sent on the TCP layer, we
can use driver software to help us abstract it all away. In this case we use the
MongoDB driver, which you can find here as an npm package.
Now, what you need to remember is that, while this driver can connect and
abstract the low-level communication requests and responses from us, it will
only take us, as developers, so far along the path.
MongoDB is what is known as a schemaless database, and that means you
have far more power than you really need when you are just starting out. The

more power you have, the more surface area there is for things to go wrong.
Cut down your surface area of bugs and wrong-turns and you are well on the
way, but that requires something a little bit more.
That’s where Mongoose comes in – an abstraction over the driver we
mentioned above.
Generally, with abstractions, each one reduces your low-level operational
power.  But that isn’t always a bad thing because, on occasion, it can even
boost your productivity 1000 times or more over because, at the end of the
day, there is never really a need for you to fully access the underlying API.
One way you can think about this is that, technically, a real-time chat
application could be created in both Python and C. As a developer, Python
helps you implement it much faster with better productivity. C is the more
efficient option but it will cost you big-time in development productivity and
speed, not to mention in crashes and bugs. And, mostly, implementing
websockets doesn’t require the power you get from C.
In much the same way, Mongoose lets you reduce your lower-level API
access surface area but it comes with a great DX and many potential gains.
Connecting Mongoose + MongoDB
First, we want to see how MongoDB databases should be connected with
Mongoose:
mongoose.connect(DB_CONNECTION_STRING, {
useNewUrlParser: true,
useUnifiedTopology: true,
useCreateIndex: true,
useFindAndModify: false
})
Using this format for the connection ensures that you are using the Mongoose
URL Parser and are not using any practices that are now deprecated.
Performing Mongoose Operations
Now we can look at the Mongoose operations and how they should be
performed. Mongoose provides two options:
1. Cursor-based querying

2. Full fetching query
Cursor-Based Querying
Cursor-based querying is all about working with just one record at any one
time, while fetching single or batches of documents off the database. This is
one of the more efficient methods to use when you have large amounts of
data and an environment limited in memory.
Let’s say that you have documents totaling about 10GB and they need to be
parsed on a 1-core 1 GB cloud server. The whole thing cannot be fetched at
once as it simply wouldn’t fit in your environment so the only decent option
is to use cursor-based querying.
Full Fetching Querying
This query type allows you to get the entire query response at once,  and this
is mostly what you will use – that is what we will focus on here.
Using Mongoose Models
Models are Mongoose’s superpower, helping you to enforce the schema rules
and seamlessly integrate Node code into the database cells. So, first, we need
a good model defined:
import mongoose from 'mongoose'
const CompletedSchema = new mongoose.Schema(
{
type: { type: String, enum: ['course', 'classroom'], required: true },
parentslug: { type: String, required: true },
slug: { type: String, required: true },
userid: { type: String, required: true }
},
{ collection: 'completed' }
)
CompletedSchema.index({ slug: 1, userid: 1 }, { unique: true })
const model = mongoose.model('Completed', CompletedSchema)
export default model
Some of the more interesting things you need to note from this is:
1. Required: should be kept true on all required fields as far as
possible. This can save you so much pain, especially when you
are not using TypeScript, or other static type-checking systems

to help you get the property names right on your created objects. 
2. Indexes and unique fields should be defined and you can also
add unique properties in a schema. I won’t go into depth on
indexes here as it is quite a broad subject but they can help speed
your queries up significantly, especially on a large scale.
3. Collection names should be explicitly defined. While Mongoose
is able to provide a collection name automatically, based on the
model’s name, this is quite a bit of abstraction, too much for
what we want. At the very least, you should know the collection
and database names in your codebase.
4. Use enums to restrict values if possible.
Performing CRUD Operations
CRUD stands for Create, Read, Update, Delete – the fundamental options for
manipulating data in a database. Let’s finish off by looking at a few
examples.
The Create Operation
This is simply for creating new database records. We’ll use the model we
defined earlier to create the record:
try {
const res = await CompletedSchema.create(record)
} catch(error) {
console.error(error)
// handle the error
}
Again, there are a couple of things to note:
1. Don’t use callbacks, use async-wait instead.
2. You should use try-catch blocks with queries because queries
can fail for several reasons, including incorrect values, duplicate
records, etc.
The Read Operation
This operation reads values from the database but, while it sounds simple,

there are a couple of things to be aware of with Mongoose:
const res = await CompletedSchema.find(info).lean()
1. Did you spot the lean() function? This is one of the best
functions for performance and, by default, Mongoose takes the
documents returned from the database, processes them and adds
magic methods to them, such as .save.
2. When .lean() is used, plain JSON objects are returned and not the
documents heavy on resources and memory. This makes your
queries much faster and it doesn’t cost so much in terms of your
CPU, either.
3. That said, .lean() can be left out if you are thinking about
updating the data.
The Update Operation
Without .lean() being fired, if you already have a Mongoose document, the
object property can be modified and saved with object.save():
const doc = await CompletedSchema.findOne(info)
doc.slug = 'something-else'
await doc.save()
Here, we are making two database calls – findOne and doc.save. Where
possible, try to have as few requests as possible hitting the database. When
you compare network, memory and disk, network is almost always going to
be the slowest.
The other case lets you use something like this to make just one call to your
database:
const res = await CompletedSchema.updateOne(<condition>, <query>).lean()
The Delete Operation
Lastly, the delete operation which Mongoose also makes straightforward.
Here’s how a single document can be deleted:
const res = await CompletedSchema.deleteOne(<condition>)
In much the same way as updateOne, deleteOne will also take the document’s
matching condition as its first argument.

Another method, deleteMany, should be used when you have multiple
documents to be deleted.  However, where you want to avoid deleting
multiple queries, use deleteOne, especially where you are attempting to
execute your own queries.

Conclusion
Thank you for taking the time to read my guide. Over the years, JavaScript
has risen in popularity, and today, the face of web development has changed
beyond all recognition. Several years ago, we could not have even imagined
the things we can do today on the web, using JavaScript in the browser and
the server. Back then, anything remotely like that would have been
encapsulated inside a Java Applet, Flash, or other similar sandboxed
environments.
For more than 20 years, we have lived with the stateless-web based on a
stateless request-response paradigm, but now we have web applications based
on two-way, real-time connections. Node.js has made it possible for the
server and the client to initiate communication and freely exchange data. The
typical response paradigm is in direct contrast to this, with the client always
being the one to initiate communications. All of this is based on an open web
stack of JS, CSS, and HTML, running on port 80.
Sure, you can argue that this has been around for years. We've long had Java
Applets and Flash, but these are nothing more than sandboxed environments
that use the web as a form of transport to the client.  Being sandboxed, they
were isolated, running on non-standard ports that likely needed extra things,
such as more permissions.
Node.js has all the advantages and is now used by high-profile companies
that depend almost entirely on what it offers. And that means there will
always be room for one more Node.js expert in the world – is it you?

References
"An Introduction to the Npm Package Manager." An Introduction to the Npm
Package Manager, nodejs.dev/learn/an-introduction-to-the-npm-
package-manager.
"Build Node.js Apps with Visual Studio Code." Code.visualstudio.com,
code.visualstudio.com/docs/nodejs/nodejs-tutorial.
Deploy, Octopus. "Packaging Node.js Applications." Octopus Deploy,
octopus.com/blog/deploying-nodejs.
"Global Object." Javascript.info, javascript.info/global-object.
"How to Use the Node.js REPL." DigitalOcean,
www.digitalocean.com/community/tutorials/how-to-use-the-node-js-
repl.
"Introducing Asynchronous JavaScript - Learn Web Development | MDN."
Developer.mozilla.org, developer.mozilla.org/en-
US/docs/Learn/JavaScript/Asynchronous/Introducing.
“Introduction to Backend Development.” DEV Community,
dev.to/kaperskyguru/introduction-to-backend-development-506a.
jsmanifest. "Callbacks vs. Promises in JavaScript." Medium, 3 Dec. 2019,
medium.com/better-programming/callbacks-vs-promises-in-
javascript-1f074e93a3b5.
Node.js. "How to Use Buffers in Node.js." Node.js,
nodejs.org/en/knowledge/advanced/buffers/how-to-use-buffers/.
---. "The Node.js Event Loop, Timers, and Process.nextTick()." Node.js,
nodejs.org/en/docs/guides/event-loop-timers-and-nexttick
“Node.js - RESTful API - Tutorialspoint.” Www.tutorialspoint.com,
www.tutorialspoint.com/nodejs/nodejs_restful_api.htm.
"Node.js - Utility Modules - Tutorialspoint." Www.tutorialspoint.com,
www.tutorialspoint.com/nodejs/nodejs_utility_module.htm.
"Node.js | File System." GeeksforGeeks, 10 May 2020,
www.geeksforgeeks.org/node-js-file-system/.

“Node.js Callback Concept - JavaTpoint.” Www.javatpoint.com,
www.javatpoint.com/nodejs-callbacks.
"Node.js Console - REPL." Www.tutorialsteacher.com,
www.tutorialsteacher.com/nodejs/nodejs-console-repl.
"Node.js Express FrameWork Tutorial - Learn in 10 Minutes."
Www.guru99.com, www.guru99.com/node-js-express.html.
"Node.js Tutorial - Tutorialspoint." Tutorialspoint.com, 2019,
www.tutorialspoint.com/nodejs/index.htm.
Oelbadrawi. "Step by Step Building Your First Node.JS Project." Medium, 14
Oct. 2020, medium.com/swlh/step-by-step-building-your-first-node-
js-project-45489f15aaa1.
OPTASY. “How to Scale Your Node.js App: Best Strategies and Built-in
Tools for Scalability.” Medium, 4 Feb. 2020,
medium.com/@OPTASY.com/how-to-scale-your-node-js-app-best-
strategies-and-built-in-tools-for-scalability-a1725df082f5.
"Understanding Streams in Node.js." The NodeSource Blog - Node.js
Tutorials, Guides, and Updates, 22 Nov. 2019,
nodesource.com/blog/understanding-streams-in-nodejs/

