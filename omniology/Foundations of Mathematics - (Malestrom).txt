Copyright c⃝1995–2007 by Stephen G. Simpson
Foundations of Mathematics
Stephen G. Simpson
October 16, 2008
Department of Mathematics
The Pennsylvania State University
University Park, State College PA 16802
simpson@math.psu.edu
This is a set of lecture notes for my course, Foundations of Mathematics I,
oﬀered as Mathematics 558 at the Pennsylvania State University, most recently
in Spring 2007.
1

Contents
1
Computable Functions
6
1.1
Primitive Recursive Functions . . . . . . . . . . . . . . . . . . . .
6
1.2
The Ackermann Function
. . . . . . . . . . . . . . . . . . . . . .
13
1.3
Computable Functions . . . . . . . . . . . . . . . . . . . . . . . .
17
1.4
Partial Recursive Functions . . . . . . . . . . . . . . . . . . . . .
23
1.5
The Enumeration Theorem
. . . . . . . . . . . . . . . . . . . . .
25
1.6
Consequences of the Enumeration Theorem . . . . . . . . . . . .
30
1.7
Unsolvable Problems . . . . . . . . . . . . . . . . . . . . . . . . .
34
1.8
The Recursion Theorem . . . . . . . . . . . . . . . . . . . . . . .
39
1.9
The Arithmetical Hierarchy . . . . . . . . . . . . . . . . . . . . .
41
2
Undecidability of Arithmetic
48
2.1
Terms, Formulas, and Sentences . . . . . . . . . . . . . . . . . . .
48
2.2
Arithmetical Deﬁnability . . . . . . . . . . . . . . . . . . . . . . .
50
2.3
G¨odel Numbers of Formulas . . . . . . . . . . . . . . . . . . . . .
57
3
The Real Number System
60
3.1
Quantiﬁer Elimination . . . . . . . . . . . . . . . . . . . . . . . .
60
3.2
Decidability of the Real Number System . . . . . . . . . . . . . .
66
4
Informal Set Theory
69
4.1
Operations on Sets . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.2
Cardinal Numbers
. . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.3
Well-Orderings and Ordinal Numbers
. . . . . . . . . . . . . . .
74
4.4
Transﬁnite Recursion . . . . . . . . . . . . . . . . . . . . . . . . .
78
4.5
Cardinal Numbers, Continued . . . . . . . . . . . . . . . . . . . .
81
4.6
Cardinal Arithmetic
. . . . . . . . . . . . . . . . . . . . . . . . .
83
4.7
Some Classes of Cardinals . . . . . . . . . . . . . . . . . . . . . .
85
4.8
Pure Well-Founded Sets . . . . . . . . . . . . . . . . . . . . . . .
87
4.9
Set-Theoretic Foundations . . . . . . . . . . . . . . . . . . . . . .
88
5
Axiomatic Set Theory
92
5.1
The Axioms of Set Theory . . . . . . . . . . . . . . . . . . . . . .
92
5.2
Models of Set Theory
. . . . . . . . . . . . . . . . . . . . . . . .
96
2

5.3
Transitive Models and Inaccessible Cardinals
. . . . . . . . . . .
99
5.4
Constructible Sets
. . . . . . . . . . . . . . . . . . . . . . . . . . 103
5.5
Forcing
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
5.6
Independence of CH . . . . . . . . . . . . . . . . . . . . . . . . . 111
6
Topics in Set Theory
114
6.1
Stationary Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
6.2
Large Cardinals . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
6.3
Ultraﬁlters and Ultraproducts . . . . . . . . . . . . . . . . . . . . 116
6.4
Measurable Cardinals
. . . . . . . . . . . . . . . . . . . . . . . . 119
6.5
Ramsey’s Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . 119
3

List of Figures
1.1
Register Machine Instructions . . . . . . . . . . . . . . . . . . . .
18
1.2
An Addition Program . . . . . . . . . . . . . . . . . . . . . . . .
18
1.3
The Initial Functions . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.4
Generalized Composition
. . . . . . . . . . . . . . . . . . . . . .
20
1.5
A Multiplication Program . . . . . . . . . . . . . . . . . . . . . .
21
1.6
Primitive Recursion
. . . . . . . . . . . . . . . . . . . . . . . . .
22
1.7
Minimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
1.8
A Program with Labeled Instructions
. . . . . . . . . . . . . . .
27
1.9
Incrementing Pi . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.10 Decrementing Pi
. . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.11 Stopping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
1.12 Parametrization . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
4

List of Tables
1.1
The Ackermann branches. . . . . . . . . . . . . . . . . . . . . . .
14
5

Chapter 1
Computable Functions
We use N to denote the set of natural numbers,
N = {0, 1, 2, . . .} .
For k ≥1, the k-fold Cartesian product
N × . . . × N
|
{z
}
k
is denoted Nk. A k-place function is a function f : Nk →N and is sometimes
indicated with the lambda-notation,
f = λx1 · · · xk [ f(x1, . . . , xk) ] .
A number-theoretic function is a k-place function for some k ≥1.
The purpose of this chapter is to deﬁne and study an important class of
number-theoretic functions, the recursive functions (sometimes called the com-
putable functions). We begin with a certain subclass known as the primitive
recursive functions.
1.1
Primitive Recursive Functions
Loosely speaking, a recursion is any kind of inductive deﬁnition, and a primitive
recursion is an especially straightforward kind of recursion, in which the value
of a number-theoretic function at argument x + 1 is deﬁned in terms of the
value at argument x. For example, the factorial function λx [ x! ] is deﬁned by
the primitive recursion equations 0! = 1, (x + 1)! = x!(x + 1).
A number-
theoretic function is said to be primitive recursive if it can be built up by means
of primitive recursions. This concept is made precise in the following deﬁnition.
Deﬁnition 1.1.1 (Primitive Recursive Functions). The class PR of primitive
recursive functions is the smallest class C of number-theoretic functions having
the following closure properties.
6

1. The constant zero function Z = λx [ 0 ] belongs to C.
2. The successor function S = λx [ x + 1 ] belongs to C.
3. For each k ≥1 and 1 ≤i ≤k, the projection function Pki = λx1 · · · xk [ xi ]
belongs to C.
4. C is closed under generalized composition. This means that whenever the
k-place functions
λx1 · · · xk [ g1(x1, . . . , xk) ], . . . , λx1 · · · xk [ gm(x1, . . . , xk) ]
and the m-place function λy1 · · · ym [ h(y1, . . . , ym) ] all belong to C, then
the k-place function
f = λx1 · · · xk [ h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)) ]
also belongs to C. Here f is deﬁned by
f(x1, . . . , xk) = h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)) .
5. C is closed under primitive recursion.
This means that whenever the
k-place function λx1 · · · xk [ g(x1, . . . , xk) ] and the (k+2)-place function
λyzx1 · · · xk [ h(y, z, x1, . . . , xk) ]
belong to C, then the (k+1)-place function λyx1 · · · xk [ f(y, x1, . . . , xk) ]
deﬁned by
f(0, x1, . . . , xk)
=
g(x1, . . . , xk)
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk)
also belongs to C.
We now list some examples of primitive recursive functions.
Examples 1.1.2.
1. The recursion equations
x + 0
=
x
x + (y + 1)
=
(x + y) + 1
show that the addition function λxy [ x + y ] is primitive recursive.
2. The recursion equations
x · 0
=
0
x · (y + 1)
=
(x · y) + x
show that the multiplication function λxy [ x · y ] is primitive recursive.
7

3. The recursion equations
x0
=
1
xy+1
=
xy · x
show that the exponentiation function λxy [ xy ] is primitive recursive.
4. As already mentioned, the recursion equations
0!
=
1
(x + 1)!
=
x! · (x + 1)
show that the factorial function λx [ x! ] is primitive recursive.
We now proceed to further enlarge our library of primitive recursive func-
tions. First, the recursion equations P(0) = 0, P(x + 1) = x show that the
“predecessor” function
P(x) =

x −1
if x > 0 ,
0
if x = 0
is primitive recursive. We can then obtain the truncated subtraction function
x ·−y =
 x −y
if x ≥y ,
0
if x < y
using primitive recursion equations x ·−0 = x, x ·−(y+1) = P(x ·−y). (Truncated
subraction is useful because ordinary subtraction is not a function from N2 into
N.) We shall also have use for
|x −y| = (x ·−y) + (y ·−x)
and α(x) = 1 ·−x. Note that
α(x) =

0
if x > 0 ,
1
if x = 0 .
The following exercise will become easy after we have developed a little more
machinery.
Exercise 1.1.3. Show that the Fibonacci function, deﬁned by
ﬁb(0)
=
0 ,
ﬁb(1)
=
1 ,
ﬁb(x + 2)
=
ﬁb(x) + ﬁb(x + 1)
is primitive recursive. (The ﬁrst few values of this function are 0, 1, 1, 2, 3, 5,
8, 13, 21, 34, 55, . . . .)
8

In addition to primitive recursive functions, we shall want to consider prim-
itive recursive predicates. By a k-place predicate we mean a subset of Nk. If
R ⊆Nk is a k-place predicate and x1, . . . , xk are elements of N, we say that
R(x1, . . . , xk) is true if ⟨x1, . . . , xk⟩∈R, otherwise false. A number-theoretic
predicate is a k-place predicate for some k ≥1.
Deﬁnition 1.1.4. A k-place predicate R ⊆Nk is said to be primitive recursive
if its characteristic function
χR(x1, . . . , xk) =
 1
if R(x1, . . . , xk) is true
0
if R(x1, . . . , xk) is false
is primitive recursive.
For example, the 2-place predicates x = y and x < y are primitive recursive,
since χ=(x, y) = α(|x −y|) and χ<(x, y) = α(α(y ·−x)).
Lemma 1.1.5 (Boolean Connectives). If P and Q are primitive recursive pred-
icates, then so are ¬ P, P ∧Q, and P ∨Q. (Here ¬ , ∧, and ∨denote negation,
conjunction, and (nonexclusive) disjunction, respectively.)
Proof. We have χ¬ P = α(χP ) and χP ∧Q = χP · χQ. Also
χP ∨Q = α(α(χP ) · α(χQ))
since P ∨Q ≡¬ ((¬ P) ∧(¬ Q)) (de Morgan’s law).
Lemma 1.1.6 (Iterated Sums and Products). If f(x, y, z1, . . . , zk) is a primitive
recursive function, then so are
g(y, z1, . . . , zk) =
y−1
X
x=0
f(x, y, z1, . . . , zk)
(= 0 if y = 0)
and
h(y, z1, . . . , zk) =
y−1
Y
x=0
f(x, y, z1, . . . , zk)
(= 1 if y = 0) .
Proof. We have g(y, z1, . . . , zk) = g∗(y, y, z1, . . . , zk) where
g∗(w, y, z1, . . . , zk) =
w−1
X
x=0
f(x, y, z1, . . . , zk) .
The recursion equations
g∗(0, y, z1, . . . , zk)
=
0
g∗(w + 1, y, z1, . . . , zk)
=
g∗(w, y, z1, . . . , zk) + f(w, y, z1, . . . , zk)
show that g∗is primitive recursive, hence g is primitive recursive. The treatment
of h is similar.
9

Lemma 1.1.7 (Finite Conjuction and Disjunction). If R(x, y, z1, . . . , zk) is a
primitive recursive predicate, then so are
P(y, z1, . . . , zk) ≡
y−1
^
x=0
R(x, y, z1, . . . , zk)
and
Q(y, z1, . . . , zk) ≡
y−1
_
x=0
R(x, y, z1, . . . , zk) .
Proof. We have
χP (y, z1, . . . , zk) =
y−1
Y
x=0
χR(x, y, z1, . . . , zk)
and
χQ(y, z1, . . . , zk) = α
 y−1
Y
x=0
α(χR(x, y, z1, . . . , zk))
!
so our result follows from the previous lemma.
Note that Vy−1
x=0 and Wy−1
x=0 can be paraphrased as “for all x in the range
0 ≤x < y” and “there exists x in the range 0 ≤x < y”, respectively. These
operators are sometimes called bounded quantiﬁers.
The above lemmas make it easy to show that many familiar predicates are
primitive recursive. For example, the set (i.e., 1-place predicate) of prime num-
bers is primitive recursive, since
Prime (x)
≡
x is a prime number
≡
x > 1 ∧¬ W
u<x
W
v<x (x = u · v ∧u > 1 ∧v > 1) .
Similarly, the following lemma can be used to show that many familiar func-
tions are primitive recursive.
Lemma 1.1.8 (Bounded Least Number Operator). If R(x, y, z1, . . . , zk) is a
primitive recursive predicate, then the function
f(y, z1, . . . , zk) =



least x < y such that R(x, y, z1, . . . , zk) holds ,
if such x exists ,
y otherwise
is primitive recursive.
Proof. We have
f(y, z1, . . . , zk)
=
Py−1
x=0

x · χR(x, y, z1, . . . , zk) · Qx−1
w=0 α(χR(w, y, z1, . . . , zk))

+ y · Qy−1
x=0 α(χR(x, y, z1, . . . , zk)) ,
so f is primitive recursive.
10

For example, consider the function λn [ pn ] which enumerates the prime
numbers in increasing order. (The ﬁrst few values of this function are p0 = 2,
p1 = 3, p2 = 5, p3 = 7, . . . .) We want to use the bounded least number operator
to show that λn [ pn ] is primitive recursive. First, recall a famous theorem of
Euclid which gives the bound pn+1 ≤pn!+1. We can then write p0 = 2, pn+1 =
least x ≤pn! + 1 such that Prime (x) and x > pn. Thus λn [ pn ] is primitive
recursive.
As another application of the bounded least number operator, note that the
functions
Quotient (y, x)
=
⌊y/x⌋
=
q ,
Remainder (y, x)
=
(y mod x)
=
r ,
where y = q · x + r, 0 ≤r < x, 0 ≤q, are primitive recursive, in view of
Quotient (y, x)
=
least q ≤y such that W
r<x(y = q · x + r) ,
Remainder (y, x)
=
least r < x such that W
q≤y(y = q · x + r) .
Using the bounded least number operator, we can obtain a primitive recur-
sive method of encoding ordered pairs of natural numbers as single numbers.
For our pairing function we use λuv [ 2u3v ]. The unpairing functions are then
λz [ (z)0 ] and λz [ (z)1 ], where
(z)n
=
least w < z such that Remainder(z, pw+1
n
) ̸= 0
=
the exponent of pn in the prime power factorization of z .
Note that (2u3v)0 = u and (2u3v)1 = v.
More generally, we can encode variable-length ﬁnite sequences of natural
numbers as single numbers. The sequence ⟨a0, a1, . . . , am−1⟩is encoded by
a =
Y
x<m
pax
x ,
and for decoding we can use the primitive recursive function λzx [ (z)x ], since
(a)x = ax. This method of prime power coding will be used extensively in the
proof of the Enumeration Theorem, below.
The pairing and unpairing functions make it easy to show that the Fibonacci
function is primitive recursive (cf. Exercise 1.1.3). Namely, we ﬁrst note that
the auxiliary function λx [ ﬁbpair(x) ], deﬁned by
ﬁbpair(x) = 2ﬁb(x)3ﬁb(x+1) ,
is primitive recursive in view of
ﬁbpair(0)
=
2031 ,
ﬁbpair(x + 1)
=
2(ﬁbpair(x))13(ﬁbpair(x))0+(ﬁbpair(x))1 .
Then λx [ ﬁb(x) ] is primitive recursive since ﬁb(x) = (ﬁbpair(x))0.
11

Exercise 1.1.9. Show that the 2-place number-theoretic functions GCD(x, y)
and LCM(x, y), the greatest common divisor and least common multiple of x
and y, are primitive recursive.
Solution.
GCD(x, y) = least z ≤max(x, y) such that Remainder(x, z) =
Remainder(y, z) = 0. LCM(x, y) = least z ≤x · y such that Remainder(z, x) =
Remainder(z, y) = 0.
Exercise 1.1.10. Show that the 1-place number-theoretic function f(n) given
by
f(n) = 1 +
n−1
X
k=0
f(k)n
is primitive recursive.
Solution. Consider the so-called course-of-values function
ef(n) =
n−1
Y
k=0
pf(k)
k
,
i.e., ef(n) encodes the variable-length ﬁnite sequence ⟨f(0), f(1), . . . , f(n −1)⟩
via prime power coding. Then ef(n) is primitive recursive, in view of the recur-
sion equations ef(0) = 1 and
ef(n + 1) = ef(n) · ph(n, e
f(n))
n
,
where h(n, z) = 1 + Pn−1
k=0((z)k)n.
It now follows that f(n) = ( ef(n + 1))n
is primitive recursive.
This general technique is known as
course-of-values
recursion.
Exercise 1.1.11. Show that the function λn
 nth digit of
√
2

is primitive
recursive.
Solution. The nth digit of
√
2 is f(n) = Remainder(g(n), 10), where g(n) = the
least x < 4 · 102n such that (x + 1)2 > 2 · 102n.
Exercise 1.1.12. Show that the 1-place number-theoretic function
f(n) = the nth decimal digit of π = 3.141592 · · ·
is primitive recursive.
Hint: You may want to use the fact that |π −a/b| > 1/b42 for all integers
a, b > 1. This result is due to K. Mahler, On the approximation of π, Nederl.
Akad. Wetensch. Proc. Ser. A., 56, Indagationes Math., 15, 30–42, 1953.
Solution. We use the well-known series
π
4 = 1 −1
3 + 1
5 −1
7 + 1
9 −· · · =
∞
X
n=0
(−1)n
2n + 1 ,
12

i.e.,
π = 4 −4
3 + 4
5 −4
7 + 4
9 −· · · =
∞
X
n=0
(−1)n4
2n + 1 .
Let Sk be the kth partial sum of this series. We have Sk = a(k)/b(k) where the
functions a(k) and b(k) are primitive recursive, namely
a(k) =
k
X
n=0
(−1)n4(2k + 1)!
2n + 1
and b(k) = (2k + 1)!. Note also that the functions
g(n, a, b) = (µi < 10nb) (10ia ≥10nb)
and
h(n, a, b) = Rem(Quot(10g(n,a,b)a, b), 10) = the nth digit of a/b
is primitive recursive. By Mahler’s result, for each n there exists k < 1050n
such that Sk and Sk+1 have the same ﬁrst n digits. Since π lies between Sk
and Sk+1, it follows that Sk and π have the same ﬁrst n digits, so in partic-
ular f(n) = the nth digit of Sk. Using the bounded least number operator,
we have f(n) = h(n, a(k(n)), b(k(n))) where k(n) = the least k < 1050n such
that Vn
m=0 g(m, a(k), b(k)) = g(m, a(k + 1), b(k + 1)). Clearly this is primitive
recursive.
1.2
The Ackermann Function
In this section we present an example of a function which is not primitive re-
cursive, yet is clearly computable in some intuitive sense. The precise concept
of computability which we have in mind will be explained in the next section.
Deﬁnition 1.2.1. We deﬁne a sequence of 1-place functions An, n ∈N, as
follows:
A0(x)
=
2x,
An+1(x)
=
AnAn · · · An
|
{z
}
x
(1) .
Thus A0(x) = 2x, A1(x) = 2x, A2(x) = 22···2
(height x), etc.
Exercise 1.2.2 (the Ackermann hierarchy).
1. Show that, for each n, λx [ An(x) ] is primitive recursive.
2. Show that
(a) An(x + 1) > An(x) > x for all x ≥1 and all n.
13

(b) An+1(x) ≥An(x + 1) for all x ≥3 and all n.
3. Show that for each k-place primitive recursive function
λx1 . . . xk [ f(x1, . . . , xk) ]
there exists n such that
f(x1, . . . , xk) ≤An(max(3, x1, . . . , xk))
for all x1, . . . , xk.
4. Show that the 2-place function λnx [ An(x) ] is not primitive recursive.
This is known as the Ackermann function.
5. Show that the 3-place relation λnxy [ An(x) = y ] is primitive recursive.
Use this to show that the Ackermann function is computable, i.e., recur-
sive, in the sense of Section 1.3.
Solutions.
1. Show that An(1) = 2, An(2) = 4, and An+1(3) = An(4) for all n. Compute
An(x) for all n, x with n + x ≤8.
Solution. For all n we have An+1(1) = An(1), hence by induction An(1) =
A0(1) = 2.
Also An+1(2) = An(An(1)) = An(2), hence by induction
An(2) = A0(2) = 4.
Also, for all n and x we have An+1(x + 1) =
An(An+1(x)), in particular An+1(3) = An(An+1(2)) = An(4). Table 1.1
shows An(x) for small values of n, x.
Table 1.1: The Ackermann branches.
0
1
2
3
4
5
A0
0
2
4
6
8
10
A1
1
2
4
8
16
32
A2
1
2
4
16
216
2216
A3
1
2
4
216
22···2
(height 216)
22···2
(height 22···2
(height 216))
A4
1
2
4
22···2
(height 216)
A3(22···2
(height 216))
A5
1
2
4
A3(22···2
(height 216))
A6
1
2
4
2. Prove the following:
14

(a) An(x + 1) > An(x) > x for all x ≥1 and all n.
(b) An+1(x) ≥An(x + 1) for all x ≥3 and all n.
(c) For each primitive recursive function f(x1, . . . , xk) there exists n such
that An covers f, i.e.,
f(x1, . . . , xk) ≤An(max(3, x1, . . . , xk))
for all x1, . . . , xk.
(d) The 1-place function λx (Ax(x)) is not primitive recursive.
(e) The 2-place function λxy (Ax(y)) is not primitive recursive.
Solution. First we prove An(x + 1) > An(x) > x for x ≥1, by induction
on n.
For n = 0 we have A0(x + 1) = 2x + 2 > 2x = A0(x) for all
x, and A0(x) = 2x > x for x ≥1.
For n + 1 and x ≥1 we have
An+1(x + 1) = An(An+1(x)) > An+1(x) by inductive hypothesis. Thus
An+1 is strictly monotone. Since An+1(0) > 0, it follows that An+1(x) > x
for all x.
Next we prove An+1(x) ≥An(x+1) for x ≥3, by induction on x. For x = 3
we have An+1(3) = An(4) as noted above, and inductively An+1(x + 1) =
An(An+1(x)) ≥An(An(x+1)) ≥An(x+2), since An is strictly monotone
and An(x + 1) ≥x + 2 by what has already been proved.
Next we prove that each primitive recursive function is covered by An for
some n. We prove this by induction on the class of primitive recursive
functions. We begin by noting that the initial functions are covered by
A0.
Suppose f is obtained by generalized composition, say
f(x1, . . . , xk) = h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)).
Let n be such that An covers h and An+1 covers g1, . . . , gm. We then have
f(x1, . . . , xk)
=
h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk))
≤
An(max(3, g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)))
≤
An(An+1(max(3, x1, . . . , xk)))
=
An+1(max(3, x1, . . . , xk) + 1)
≤
An+2(max(3, x1, . . . , xk)),
i.e., An+2 covers f.
Suppose f is obtained by primitive recursion, say
f(0, x1, . . . , xk)
=
g(x1, . . . , xk),
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk).
Let n be such that An covers h and An+1 covers g. We ﬁrst claim that
f(y, x1, . . . , xk) ≤An+1(y + max(3, x1, . . . , xk))
15

for all y, x1, . . . , xk.
We prove this by induction on y.
For y = 0 we
have f(0, x1, . . . , xk) = g(x1, . . . , xk) ≤An+1(max(3, x1, . . . , xk)). For the
inductive step we have
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk)
≤
An(max(3, y, f(y, x1, . . . , xk), x1, . . . , xk)
≤
An(max(3, y, An+1(y + max(3, x1, . . . , xk)), x1, . . . , xk)
=
An(An+1(y + max(3, x1, . . . , xk)))
=
An+1(y + 1 + max(3, x1, . . . , xk))
and this proves our claim. We then have
f(y, x1, . . . , xk)
≤
An+1(y + max(3, x1, . . . , xk))
≤
An+1(2 max(3, y, x1, . . . , xk))
≤
An+1(An+2(max(3, y, x1, . . . , xk)))
=
An+2(max(3, y, x1, . . . , xk) + 1)
≤
An+3(max(3, y, x1, . . . , xk)),
i.e., An+3 covers f. This completes the proof that each primitive recursive
function is covered by An for some n.
Now, if Ax(x) were primitive recursive, then Ax(x)+1 would be primitive
recursive, hence covered by An for some n ≥3. But then in particular
An(n) + 1 ≤An(max(3, n)) = An(n), a contradiction. Thus the 1-place
function Ax(x) is not primitive recursive. It follows immediately that the
2-place function Ax(y) is not primitive recursive.
3. Show that the 3-place relation
{⟨x, y, z⟩| Ax(y) = z}
is primitive recursive.
Use this to prove that λxy (Ax(y)) is recursive.
Hence λx (Ax(x)) is recursive.
Solution. For all x, y > 0 we have
0 < y < Ax(y) = Ax−1(Ax(y −1)) = Ax−1(y′)
where y′ = Ax(y −1).
Since Ax−1(y′) = Ax(y) ≥2, it follows that
0 < y′ < Ax−1(y′) = Ax(y). Repeating this step x times, we obtain a
ﬁnite sequence y0, y1, y2, . . . , yx starting with y such that
Ax(y) = Ax(y0) = Ax−1(y1) = Ax−2(y2) = · · · = A0(yx) = 2yx,
and each of y0, y1, . . . , yx is > 0 and < Ax(y). Moreover, if y > 2 then we
also have x < Ax(y). Thus the 3-place predicate Ax(y) = z can be deﬁned
16

by course-of-values recursion on z as follows:
Ax(y) = z if and only if
(x = 0 ∧z = 2y) ∨
(x > 0 ∧y = 0 ∧z = 1) ∨
(x > 0 ∧y = 1 ∧z = 2) ∨
(x > 0 ∧y = 2 ∧z = 4) ∨
(x > 0 ∧y > 2 ∧x < z ∧∃y0, y1, . . . , yx < z
(y0 = y ∧∀i < x (yi+1 = Ax−i(yi −1)) ∧z = 2yx)).
Actually, the function being deﬁned by primitive recursion is
a(w) = Q{p2x3y5z | Ax(y) = z ∧x, y, z < w}.
In any case, it follows that the 3-place predicate Ax(y) = z is primitive
recursive.
Applying the least number operator, we see that the 2-place function
Ax(y) is recursive. It follows immediately that the 1-place function Ax(x)
is recursive.
1.3
Computable Functions
In this section we deﬁne the class of computable (i.e., recursive) number-theoretic
functions. We show that the primitive recursive functions form a proper subclass
of the computable functions.
Our deﬁnition will be given in terms of a register machine. We assume the
existence of inﬁnitely many registers R1, R2, . . . , Ri, . . . . At any given time,
each register contains a natural number. If the number contained in Ri is 0, we
say that Ri is empty. At any given time, all but ﬁnitely many of the registers
are empty. The basic actions that the machine can perform are to increment or
decrement a register, i.e., add or subtract 1 from the number contained in it.
A register machine program consists of ﬁnitely many instructions linked to-
gether in a ﬂow diagram indicating the order in which the instructions are to
be executed. There are four types of instructions: R+
i , R−
i , start, and stop.
Each program contains exactly one start instruction, which is executed ﬁrst.
An R+
i instruction is executed by incrementing Ri and then proceeding to an-
other, speciﬁed, instruction. An R−
i
instruction is executed by testing Ri for
emptiness. If Ri is empty, we proceed to one of two speciﬁed instructions. If Ri
is nonempty, we decrement it and then proceed to the other of the two speciﬁed
instructions. A stop instruction causes execution of the program to halt. See
Figure 1.1.
For example, consider the addition program depicted in Figure 1.2. If we run
this program starting with natural numbers x and y in R1 and R2 respectively,
the run will eventually halt with x + y in R3.
17

start
ONML
HIJK
/
?
?
?
?
?
?
?
/ R+
i
ONML
HIJK
/
?






begin run of program
increment register Ri
?
?
?
?
?
?
?
/ R−
i
ONML
HIJK e
/
?
?
?
?
?
?
?
?






?
?
?
?
?
?
?
/ stop
ONML
HIJK
?






if Ri empty go to e,
terminate run of program
otherwise decrement Ri
Figure 1.1: Register Machine Instructions
start
ONML
HIJK
/ R−
3
ONML
HIJK
cd
ab
`g
=
e
/ R−
1
ONML
HIJK

e
/ R−
2
ONML
HIJK

e
/ stop
ONML
HIJK
R+
3
ONML
HIJK
O
R+
3
ONML
HIJK
O
Figure 1.2: An Addition Program
18

Let P be a register machine program, and let x1, . . . , xk be natural numbers,
i.e., elements of N. We write P(x1, . . . , xk) to denote the unique run of P starting
with x1 in R1, . . . , xk in Rk, and all other registers empty. Uniqueness follows
from the fact that the register machine operates deterministically.
Deﬁnition 1.3.1 (Computable Functions). A k-place number-theoretic func-
tion
λx1 . . . xk [ f(x1, . . . , xk) ]
is said to be computable if there exists a register machine program P which
computes it, i.e.
for all x1, . . . , xk ∈N, P(x1, . . . , xk) eventually halts with
y = f(x1, . . . , xk) in Rk+1.
For example, the addition program of Figure 1.2 shows that λx1x2 [ x1 +x2 ]
is computable.
We shall now prove that all primitive recursive functions are computable.
Lemma 1.3.2. The initial functions Z, S, and Pki, 1 ≤i ≤k, are computable.
Proof. The functions Z = λx [ 0 ], S = λx [ x + 1 ], and Pki = λx1 . . . xk [ xi ] are
computed by the register machine programs given in Figure 1.3.
Zero
start
ONML
HIJK
/ stop
ONML
HIJK
Successor
start
ONML
HIJK
/ R−
1
ONML
HIJK

e
/ R+
2
ONML
HIJK
/ stop
ONML
HIJK
R+
2
ONML
HIJK
O
Projection
start
ONML
HIJK
/ R−
i
ONML
HIJK

e
/ stop
ONML
HIJK
R+
k+1
WVUT
PQRS
O
Figure 1.3: The Initial Functions
19

start
ONML
HIJK

F −
1
ONML
HIJK

e
/ . . .
e / F −
k
ONML
HIJK

e
/ G1
/ G−
1 k+1
_^]\
XYZ[

e
/ . . .
e / Gm
/ G−
m k+1
_^]\
XYZ[

e
/ H

G+
11
ONML
HIJK

G+
1k
ONML
HIJK

H+
1
ONML
HIJK
O
H+
m
ONML
HIJK
O
...

...

F +
k+1
ONML
HIJK
/ H−
m+1
_^]\
XYZ[
o
e

G+
m1
ONML
HIJK
G
G+
mk
ONML
HIJK
G
stop
ONML
HIJK
Figure 1.4: Generalized Composition
Lemma 1.3.3. The class of computable functions is closed under generalized
composition.
Proof. Assume that
λx1 . . . xk [ g1(x1, . . . , xk) ] , . . . , λx1 . . . xk [ gm(x1, . . . , xk) ]
and λy1 . . . ym [ h(y1, . . . , ym) ] are computed by register machine programs G1,
. . . , Gm, H respectively. For convenience we regard these programs as being
executed on pairwise disjoint sets of registers. We use Gj1, . . . , Gjk, Gj,k+1,
. . . to denote the registers on which Gj is executed, 1 ≤j ≤m. We use H1, . . . ,
Hm, Hm+1, . . . to denote the registers on which H is executed.
To compute λx1 . . . xk [ f(x1, . . . , xk) ] where
f(x1, . . . , xk) = h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)) .
we shall use a register machine program F which we regard as being executed
on registers F1, . . . , Fk, Fk+1, . . . . In order to make it easy for F to call G1,
. . . , Gm, H, the registers of G1, . . . , Gm, H will be among the auxiliary registers
of F. (The auxiliary registers of F are the registers Fi, i ≥k + 2.) Actually,
the auxiliary registers of F consist precisely of the registers of G1, . . . , Gm, H.
Our program F is given in Figure 1.4.
Lemma 1.3.4. The class of computable functions is closed under primitive
recursion.
20

In proving this lemma, the idea will be to write a program containing a loop
which repeatedly calls the iterator h. Let us ﬁrst illustrate this idea with a
simple example.
Example 1.3.5. The multiplication function λx1x2 [ x1 · x2 ] is computed by
iterated addition, using the program given in Figure 1.5.
start
ONML
HIJK
/ R−
1
ONML
HIJK
e

/ R−
2
ONML
HIJK

e
/ R−
4
ONML
HIJK

e
z
stop
ONML
HIJK
R+
3
ONML
HIJK

R+
2
ONML
HIJK
O
R+
4
ONML
HIJK
D
Figure 1.5: A Multiplication Program
Exercise 1.3.6. Write a register machine program which computes the ex-
ponential function, i.e., the 2-place number-theoretic function exp(x, y) = xy.
Note that x0 = 1 for all x.
Proof of Lemma 1.3.4. Assume that λx1 . . . xk [ g(x1, . . . , xk) ] and
λyzx1 . . . xk [ h(y, z, x1, . . . , xk) ]
are computed by register machine programs G and H with registers G1, . . . ,
Gk, Gk+1, . . . and H1, H2, H3, . . . , Hk+2, Hk+3, . . . respectively. To compute
λyx1 . . . xk [ f(y, x1, . . . , xk) ] where
f(0, x1, . . . , xk)
=
g(x1, . . . , xk) ,
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk) ,
we use a register machine program F with registers F1, F2, . . . , Fk+1, Fk+2,
. . . . See Figure 1.6. The auxiliary registers Fi, i ≥k + 3 of F consist of the
registers of G and H plus two additional registers, U and V .
Theorem 1.3.7. Every primitive recursive function is computable.
21

start
ONML
HIJK

F −
2
ONML
HIJK

e
/ V −
ONML
HIJK

e
/ . . .
e
/ F −
k+1
ONML
HIJK

e
/ V −
ONML
HIJK

e
/ G

H+
2
ONML
HIJK

V +
ONML
HIJK

F +
2
ONML
HIJK
O
V +
ONML
HIJK

F +
k+1
ONML
HIJK
O
F −
1
ONML
HIJK
e

/ G−
k+1
WVUT
PQRS
O
z{
e
~

G+
1
ONML
HIJK
D
G+
k
ONML
HIJK
D
F +
k+2
ONML
HIJK
/ G−
k+1
WVUT
PQRS
o
e

stop
ONML
HIJK
H+
2
ONML
HIJK

U +
ONML
HIJK

. . .
o
H−
4
ONML
HIJK
`gfecd
}
e
o
H−
3
ONML
HIJK
`gfecd
}
e
o
H−
k+3
WVUT
PQRS
O
e
o
U −
ONML
HIJK

e
/ V −
ONML
HIJK

e
/ F −
2
ONML
HIJK

e
/ V −
ONML
HIJK

e
/ . . .
e
/ F −
k+1
ONML
HIJK

e
/ V −
ONML
HIJK

e
/ H

H−
2
ONML
HIJKfecd
ab
]
e
O
V +
ONML
HIJK

U +
ONML
HIJK
O
V +
ONML
HIJK

F +
2
ONML
HIJK
O
V +
ONML
HIJK

F +
k+1
ONML
HIJK
O
F −
1
ONML
HIJK
e

/ H−
1
ONML
HIJKfecd
ab
]
e
O
H+
1
ONML
HIJK
D
H+
3
ONML
HIJK
D
H+
k+2
WVUT
PQRS
D
F +
k+2
ONML
HIJK
/ H−
k+3
WVUT
PQRS
o
e

stop
ONML
HIJK
Figure 1.6: Primitive Recursion
22

Proof. The above lemmas show that the computable functions form a class
which contains the initial functions and is closed under generalized composition
and primitive recursion. Since the primitive recursive functions were deﬁned as
the smallest such class, our theorem follows.
1.4
Partial Recursive Functions
A k-place partial function is a function ψ : dom(ψ) →N where dom(ψ) ⊆Nk.
We sometimes abbreviate this as ψ : Nk
P
−→N. We use dom(ψ) and rng(ψ) to
denote the domain and range of ψ, respectively. If dom(ψ) = Nk, we say that
ψ is total. Thus a total k-place function is just what we have previously called
a k-place function.
The use of partial functions leads to expressions which may or may not have
a numerical value. (For example, ψ(x1, . . . , xk) + 3 has a numerical value if
and only if ⟨x1, . . . , xk⟩∈dom(ψ)). If E is such an expression, we say that E is
deﬁned or convergent (abbreviated E ↓) if E has a numerical value. We say that
E is undeﬁned or divergent (abbreviated E ↑) if E does not have a numerical
value. We write E1 ≃E2 to mean that E1 and E2 are both deﬁned and equal,
or both undeﬁned.
Deﬁnition 1.4.1 (Recursive Functions and Predicates). A k-place (total) func-
tion is said to be recursive if and only if it is computable. A k-place predicate
is said to be recursive if its characteristic function is recursive.
Deﬁnition 1.4.2 (Partial Recursive Functions). A k-place partial function ψ is
said to be partial recursive if it is computed by some register machine program
P. This means that, for all x1, . . . , xk ∈N,
ψ(x1, . . . , xk) ≃the number in Rk+1 if and when P(x1, . . . , xk) stops .
In particular, ψ(x1, . . . , xk) is deﬁned if and only if P(x1, . . . , xk) eventually
stops.
Partial recursive functions arise because a particular run of a register ma-
chine program may or may not eventually stop. One way this can happen is
because of an unbounded search, as in the following lemma.
Lemma 1.4.3 (Unbounded Least Number Operator). Let P(x1, . . . , xk, y) be
a (k+1)-place recursive predicate. Then the k-place partial function ψ deﬁned
by
ψ(x1, . . . , xk) ≃least y such that P(x1, . . . , xk, y) holds
is partial recursive.
23

start
ONML
HIJK

F +
k+1
ONML
HIJK
~~~~~~~
. . .
o
P −
2
ONML
HIJK
`gfecd
}
e
o
P −
1
ONML
HIJK
`gfecd
}
e
o
F −
1
ONML
HIJK

e
/ V −
ONML
HIJK

e
/ . . .
e / F −
k+1
ONML
HIJK

e
/ V −
ONML
HIJK

e
/ P
/ P −
k+2
ONML
HIJK

e
_???????
V +
ONML
HIJK

F +
1
ONML
HIJK
O
V +
ONML
HIJK

F +
k+1
ONML
HIJK
O
stop
ONML
HIJK
P +
1
ONML
HIJK
D
P +
k+1
ONML
HIJK
D
Figure 1.7: Minimization
Proof. Assume that χP is computed by a register machine program P with
registers P1, . . . , Pk, Pk+1, Pk+2, . . . . To compute ψ we use a register machine
program F with registers F1, F2, . . . , Fk+1, . . . . The auxiliary registers Fi,
i ≥k + 2, of F are the registers of P plus an additional register V .
See
Figure 1.7.
The unbounded least number operator is sometimes called the minimization
operator. As a byproduct of the work in the next section, we shall see that all
partial recursive functions can be obtained from primitive recursive functions
by composition and minimization.
Exercise 1.4.4. Show that the function f(n) = nth digit of π is recursive.
Hint: Use an inﬁnite series such as
π
4 = 1 −1
3 + 1
5 −1
7 + 1
9 −· · ·
plus the fact that π is irrational.
Solution. This follows from Exercise 1.1.12. A solution not using Mahler’s result
is as follows.
Let Sk be the kth partial sum of the alternating series
π = 4 −4
3 + 4
5 −4
7 + 4
9 −· · · =
∞
X
n=0
(−1)n4
2n + 1 ,
24

We have Sk = a(k)/b(k) where a(k) and b(k) are primitive recursive. Since π is
irrational, it follows that for each n there exists k such that Sk and Sk+1 have
the same ﬁrst n digits. Since π lies between Sk and Sk+1, it follows that Sk and
π have the same ﬁrst n digits, so in particular f(n) = the nth digit of Sk. Note
also that the function
h(n, a, b) = nth digit of a/b
is primitive recursive. Using the least number operator, we have f(n) = h(n, a(k(n)), b(k(n)))
where k(n) = the least k such that Vn
m=0 h(m, a(k), b(k)) = h(m, a(k +1), b(k +
1)). Clearly this is recursive.
Exercise 1.4.5. Show that there exists a computable function which is not
primitive recursive. (By 1.2.2 it suﬃces to show that the Ackermann function
λnx [ An(x) ] is computable.)
Exercise 1.4.6. Let f : N
1−1 onto
−→
N be a permutation of N, the set of natural
numbers. Show that if f is recursive, then the inverse permutation f −1 is also
recursive.
Solution. Using the least number operator, we have f −1(y) = the least x such
that f(x) = y.
Exercise 1.4.7. Give an example of a primitive recursive permutation of N
whose inverse is not primitive recursive.
Solution. From our study of the Ackermann function in Section 1.2, we know
that the predicate {⟨x, y⟩| Ax(x) = y} is primitive recursive, although the one-
to-one increasing function x 7→Ax(x) is not. Let B be the range of x 7→Ax(x),
i.e., B = {y | ∃x (Ax(x) = y)}. Then B is primitive recursive, because y ∈B ⇔
Wy−1
x=0 Ax(x) = y. Note also that B is inﬁnite and coinﬁnite.
For any inﬁnite set S ⊆N, let πS : N →N be the principal function of S,
i.e.,
S = {πS(0) < πS(1) < · · · < πS(n) < πS(n + 1) < · · ·}
where πS(n) = the nth element of S. Let f be the permutation of N deﬁned by
f(y) =
( 2π−1
B (y)
if y ∈B,
2π−1
N\B(y) + 1
if y ∈N \ B.
By course-of-values recursion, f is primitive recursive.
However, f −1 is not
primitive recursive, because f −1(2x) = πB(x) = Ax(x).
1.5
The Enumeration Theorem
To each register machine program E we shall assign a unique number e = #(E).
This number will be called the G¨odel number of E and will also be called an
index of the k-place partial recursive function which is computed by E
25

Recall that our register machine is equipped with inﬁnitely many registers
Ri, i ≥1. Initially all of the registers are empty except for R1, . . . , Rk which
contain the arguments x1, . . . , xk. We assume that our program E is given
as a numbered sequence of instructions I1, . . . , Il. By convention our machine
starts by executing I1 and stops when it attempts to execute the nonexistent
instruction I0. Each instruction Im, 1 ≤m ≤l, is of the form
increment Ri then go to instruction In0,
(1.0)
or
if Ri is empty go to In0, otherwise
decrement Ri then go to instruction In1.
(1.1)
Here n0 and n1 are in the range 0 ≤n ≤l. To each instruction Im we assign a
G¨odel number #(Im), where
#(Im) =
(
3i · 5n0
for Im as in (1.0) ,
2 · 3i · 5n0 · 7n1
for Im as in (1.1) .
The G¨odel number of the entire program E is then deﬁned as
#(E) =
lY
m=1
p#(Im)
m
,
where p0, p1, p2, . . . are the prime numbers 2, 3, 5, . . . in increasing order.
Example 1.5.1. Let E be the program in Figure 1.8, which computes λx [ x+1 ].
Listing the instructions I1, I2, I3 as shown in the ﬁgure, we have
#(I1)
=
2 · 31 · 53 · 72 = 2 · 3 · 125 · 49 = 36750 ,
#(I2)
=
32 · 51 = 45 ,
#(I3)
=
32 · 50 = 9 ,
so that
#(E) = 3#(I1) · 5#(I2) · 7#(I3) = 336750 · 545 · 79 .
Lemma 1.5.2. The 1-place predicate
Program(e) ≡(e is the G¨odel number of some register machine program)
is primitive recursive.
Proof. We have
Program(e)
≡
e_
l=0
Program(e, l)
26

I1
I3
start
ONML
HIJK
/ R−
1
ONML
HIJK

e
/ R+
2
ONML
HIJK
/ stop
ONML
HIJK
R+
2
ONML
HIJK
O
I2
Figure 1.8: A Program with Labeled Instructions
where Program(e, l) says that e is the G¨odel number of a register machine
program consisting of l instructions I1, . . . , Il. We then have
Program(e, l)
≡
e =
lY
m=1
p(e)m
m
∧
l^
m=1
e_
i=1
l_
n0=0
l_
n1=0

(e)m = 3i · 5n0 ∨(e)m = 2 · 3i · 5n0 · 7n1 
,
the idea being that (e)m = #(Im). This proves the lemma.
Deﬁnition 1.5.3. We denote by ϕ(k)
e
the k-place partial computable function
which is computed by the register machine program E whose G¨odel number is
e. In more detail, we deﬁne
ϕ(k)
e (x1, · · · , xk) ≃
the number in Rk+1 if and when E(x1, · · · , xk)
stops, where e = #(E), and undeﬁned otherwise.
Note that if e is not the G¨odel number of a register machine program, then
ϕ(k)
e (x1, · · · , xk) is undeﬁned for all x1, . . . , xk, so in this case ϕ(k)
e
is the empty
function.
If ψ is a k-place partial recursive function, an index of ψ is any number e
such that ψ = ϕ(k)
e , i.e., e is the G¨odel number of a program which computes ψ.
Clearly ψ has many diﬀerent indices, since there are many diﬀerent programs
which compute ψ.
Exercise 1.5.4. Find an index of the function
α(x) =
(
1
if x = 0,
0
if x > 0.
27

Solution. Clearly the labeled program
I1
I2
start
ONML
HIJK
/ R−
1
ONML
HIJK
?
?
?
?
?
?
?
e
/ R+
2
ONML
HIJK

stop
ONML
HIJK
computes α. We have #(I1) = 2 · 31 · 52 · 70 = 150 and #(I2) = 32 · 50 = 9, so
an index of α is e = 3#(I1) · 5#(I2) = 3150 · 59. In other words, ϕ(1)
e
= α.
The main theorem on indices reads as follows.
Theorem 1.5.5 (The Enumeration Theorem). For each k ≥1, the (k+1)-place
partial function
λex1 . . . xk [ ϕ(k)
e (x1, . . . , xk) ]
is partial recursive.
Remark 1.5.6. The Enumeration Theorem entails the existence of a “univer-
sal” program, i.e., a register machine program which can emulate the action of
any other register machine program. This concept underlies the stored program
digital computer.
In the proof of the Enumeration Theorem, the following easy lemma will be
useful.
Lemma 1.5.7 (Deﬁnition by Cases). Let P1 and P2 be k-place primitive re-
cursive predicates and let f1 and f2 be k-place primitive recursive functions.
Assume that P1 and P2 are mutually exclusive and exhaustive, i.e., for each
k-tuple ⟨x1, . . . , xk⟩∈Nk, either P1(x1, . . . , xk) or P2(x1, . . . , xk) holds but not
both. Then the k-place function f deﬁned by
f(x1, . . . , xk) =
(
f1(x1, . . . , xk)
if P1(x1, . . . , xk) holds
f2(x2, . . . , xk)
if P2(x1, . . . , xk) holds
is primitive recursive.
Proof. This is clear since f = f1 · χP1 + f2 · χP2. The extension to more than
two cases is also easy.
Proof of the Enumeration Theorem.
28

The idea of the proof is to represent the state of E(x1, . . . , xk) after executing
n instructions by a single number
z
=
State (e, x1, . . . , xk, n)
=
pm
0 · Q∞
i=1 pzi
i ,
where zi is the number in register Ri, and Im is the next instruction to be
executed. Note that (z)0 = m and, for all i ≥1, (z)i = zi.
We ﬁrst show that the State function is primitive recursive. We have
State (e, x1, . . . , xk, 0)
=
p1
0 · px1
1 · . . . · pxk
k
(begin by executing I1) ,
State (e, x1, . . . , xk, n + 1)
=
NextState (e, State (e, x1, . . . , xk, n)) ,
NextState (e, z) =











z · pi · p−m+n0
0
if ((e)m)0 = 0 ,
z · p−m+n0
0
if ((e)m)0 = 1 and (z)i = 0 ,
z · p−1
i
· p−m+n1
0
if ((e)m)0 = 1 and (z)i > 0 ,
z
otherwise ,
where
m = (z)0 ,
i = ((e)m)1 ,
n0 = ((e)m)2 ,
n1 = ((e)m)3 .
We are now ready to prove the theorem. We use the least number operator
to obtain
Stop (e, x1, . . . , xk)
≃
least n such that (State (e, x1, . . . , xk, n))0 = 0
∧Program(e) .
(The idea is that our machine stops if and when it is about to execute I0. Note
that Stop (e, x1, . . . , xk) is undeﬁned if e is not the G¨odel number of a register
machine program.) We then use composition to get
FinalState (e, x1, . . . , xk)
≃
State (e, x1, . . . , xk, Stop (e, x1, . . . , xk))
(the state of our machine if and when it stops)
and
Output (e, x1, . . . , xk)
≃
(FinalState (e, x1, . . . , xk))k+1
(the number that is ﬁnally in register Rk+1) .
Since the Output function was obtained by composition, primitive recursion and
the least number operator, it is partial recursive. Moreover, for all e and x1,
. . . , xk, we clearly have
ϕ(k)
e (x1, . . . , xk) ≃Output (e, x1, . . . , xk) .
This completes the proof of the Enumeration Theorem.
29

Exercise 1.5.8. Let f : Nk →N be a k-place total recursive function. Show
that f is primitive recursive if and only if there exists an index e of f such that
λx1 . . . xk [ Stop (e, x1, . . . , xk) ]
is majorized by some primitive recursive function. (See also Exercise 1.2.2.)
Exercise 1.5.9. Fix k ≥1. Construct a k+1-place total recursive function
Φk : Nk+1 →N with the following properties:
1. for each e ∈N, the k-place function λx1 . . . xk [ Φk(e, x1, . . . , xk) ] is prim-
itive recursive;
2. for each k-place primitive recursive function f : Nk →N, there exists an
e such that f = λx1 . . . xk [ Φk(e, x1, . . . , xk) ].
Exercise 1.5.10. Given a k-place partial recursive function ψ(x1, . . . , xk), show
that there is a 1-place partial recursive function ψ∗(x) such that
ψ∗(px1
1 · · · pxk
k ) ≃pψ(x1,...,xk)
k+1
for all x1, . . . , xk, and ψ∗is computable by a register machine program which
uses only two registers, R1 and R2.
Solution. We begin with a register machine program P which computes ψ(x1, . . . , xk).
Let P1, . . . , Pk, Pk+1, . . . , Ps be the registers used in P. We may safely assume
that, whenever P(x1, . . . , xk) halts, it leaves all registers except Pk+1 empty.
We transform P into a program R which uses only two registers, R1 and R2.
The idea is that, if P1, . . . , Ps contain z1, . . . , zs respectively, then R1 contains
z = pz1
1 · · · pzs
s , while R2 contains 0.
Incrementing (decrementing) Pi corre-
sponds to multiplication (division) by pi. Each instruction in P is replaced by
a corresponding set of instructions in R.
We replace
/ P +
i
ONML
HIJK
/
in P by Figure 1.9 in R.
We replace
/ P −
i
ONML
HIJK
/
e
?
?
?
?
?
?
?
A
B
in P by Figure 1.10 in R.
We replace
/ stop
ONML
HIJK
in P by Figure 1.11 in R.
1.6
Consequences of the Enumeration Theorem
In this section we present some important consequences of the Enumeration
Theorem.
30

/ R−
1
ONML
HIJK

e
/ R−
2
ONML
HIJK

e
/
R+
2
ONML
HIJK

R+
1
ONML
HIJK
O
...

R+
2
ONML
HIJK
F
The number of R+
2 instructions is pi.
Figure 1.9: Incrementing Pi
R+
1
ONML
HIJK

/ R−
1
ONML
HIJK

e
/ R−
2
ONML
HIJK
O
e
/ A
R+
1
ONML
HIJK

R+
2
ONML
HIJK
?






R−
1
ONML
HIJK

e
/ R+
1
ONML
HIJK
/ R−
2
ONML
HIJK
e

?






R+
1
ONML
HIJK

...

...
O
B
...

R−
1
ONML
HIJK
W0000000000000000
e
/ R+
1
ONML
HIJK
O
R+
1
ONML
HIJK
W0000000000000000
The number of R−
1 instructions is pi.
Figure 1.10: Decrementing Pi
31

/ R−
1
ONML
HIJK

e
/ stop
ONML
HIJK
R+
2
ONML
HIJK
O
Figure 1.11: Stopping
Theorem 1.6.1. All partial recursive functions can be obtained from primitive
recursive functions by composition and minimization.
Proof. This is immediate from the proof of the Enumeration Theorem. The
State function is primitive recursive, the Stop function is obtained from the
State function by minimization, and the FinalState and Output functions are
obtained by composing the Stop and State functions with the primitive recursive
function λz [ (z)k+1 ].
The following characterizations of the class of partial recursive functions do
not involve register machines and are similar to our deﬁnition of the class of
primitive recursive functions.
Corollary 1.6.2. The class of partial recursive functions is the smallest class
of functions containing the primitive recursive functions and closed under com-
position and minimization.
Corollary 1.6.3. The class of partial recursive functions is the smallest class of
functions containing the initial functions and closed under composition, primi-
tive recursion, and minimization.
Proof. Both corollaries are immediate from the previous theorem and Lem-
mas 1.3.2, 1.3.3, 1.3.4, 1.4.3.
Next we present an interesting example showing that the consideration of
partial functions is in some sense unavoidable or inherent in recursive function
theory.
Example 1.6.4. We present an example of a partial recursive function ψ :
N
P
−→N which cannot be extended to a total recursive function f : N →N.
Namely, we deﬁne
ψ(x) ≃ϕ(1)
x (x) + 1 .
By the Enumeration Theorem, ψ is a partial recursive function.
Suppose ψ
were extendible to a total recursive function f. Let e be an index of f. Then
ψ(e) ≃ϕ(1)
e (e) + 1 ≃f(e) + 1 is deﬁned, hence f(e) ≃ψ(e) ≃f(e) + 1, a
contradiction.
32

Deﬁnition 1.6.5. A set A ⊆N is said to be recursive if its characteristic
function χA : N →N is recursive. More generally, a k-place predicate R ⊆Nk
is said to be recursive if its characteristic function χR : Nk →N is recursive.
Example 1.6.6. We present an example of a nonrecursive set.
Let K be
the subset of N consisting of all x ∈N such that ϕ(1)
x (x) is deﬁned.
Thus
K = dom(ψ) where ψ is as in the previous example. We claim that K is not
recursive. If K were recursive, then the total function f : N →N deﬁned by
f(x) =
(
ψ(x)
if x ∈K,
0
if x /∈K
would be recursive, contradicting the fact that ψ is not extendible to a total
recursive function.
Deﬁnition 1.6.7. A pair of sets A, B ⊆N is said to be recursively inseparable
if there is no recursive set X such that A ⊆X and X ∩B = ∅.
Exercise 1.6.8. Letting Kn = {x ∈N | ϕ(1)
x (x) ≃n}, show that K0 and K1
are recursively inseparable.
Exercise 1.6.9. Show that there exists a set A ⊆N which is recursive but not
primitive recursive.
(Caution: It can be shown that the 3-place predicate z = Ax(y) is prim-
itive recursive, even though the 2-place function λxy [ Ax(y) ] is not primitive
recursive. See Exercises 1.2.2, 1.4.5, 1.5.8, 1.5.9.)
Remark 1.6.10 (Church’s Thesis). Perhaps the most important consequence
of the proof of the Enumeration Theorem is that it provides strong evidence for
Church’s Thesis. We shall ﬁrst explain what Church’s Thesis says, and then we
shall present the evidence for it.
The context of Church’s Thesis is that, as mathematicians, we have an in-
tuitive notion of what it means for a function f : Nk →N to be algorithmically
computable. Since recursive functions are register machine computable, they
are obviously algorithmically computable in the intuitive sense. Church’s The-
sis states the converse: All functions f : Nk →N which are algoritmically
computable in the intuitive sense are in fact recursive.
To present our evidence for Church’s thesis, assume that we are given a func-
tion f : Nk →N which is algorithmically computable in the intuitive sense. We
want to show that f is recursive. Since the given algorithm for f is presumably
deterministic, the execution of the algorithm should be describable as a sequence
of states with deterministic transition from one state to the next. The precise
nature of the states depends on the nature of the algorithm, but no matter what
the states actually consist of, it should be possible to view them as ﬁnite strings
of symbols and to assign G¨odel numbers to them. Once this has been done, the
transition from the G¨odel number of one state to the G¨odel number of the next
state should be very simple, in particular primitive recursive. Thus we should
33

be able to carry out an analysis similar to what is in the proof of Theorem 1.5.5
(State, NextState, Stop, etc.). Such an analysis will show that f is obtained
from primitive recursive functions by means of composition and minimization.
It will then follow by Corollary 1.6.2 that f is recursive.
The argument in the previous paragraph is of necessity nonrigorous. How-
ever, it can be specialized to provide rigorous proofs that various models of com-
putation (similar to but diﬀering in details from register machine computability)
give rise to exactly the same class of functions, the recursive functions. Some
of the models of computation that have been analyzed in this way are: Turing
machines, Markov algorithms, Kleene’s equation calculus. There is no reason
to think that the same analysis could not be carried out for any similar model.
This constitutes very strong evidence for Church’s thesis.
Note that the same arguments and evidence apply more generally in case f
is a partial rather than a total function. From now on, we shall take Church’s
Thesis for granted and identify the class of partial recursive functions with the
class of partial functions from Nk into N that are algorithmically computable in
the intuitive sense.
The fact that the intuitive notion of algorithmic computability is captured
by a rigorous mathematical notion of recursiveness is one of the successes of
modern mathematical logic.
1.7
Unsolvable Problems
The purpose of this section is twofold: (1) to discuss and make precise the con-
cept of an unsolvable mathematical problem, and (2) to present some important
examples of such problems.
We begin with a preliminary clariﬁcation.
In certain contexts, the word
problem refers to a mathematical statement which has a deﬁnite truth value,
True or False, but whose truth value is unknown at the present time. (An ex-
ample of a problem in this sense is the Riemann Hypothesis.) However, we shall
not deal with this type of problem now. Instead, we consider a somewhat dif-
ferent concept. For us in this section, a problem is any mathematical statement
that involves a parameter. A solution of such a problem would be an algorithm
which would enable us to compute the truth value of the problem statement for
any given value of the parameter. The problem is said to be solvable if there
exists such an algorithm, otherwise unsolvable. An instance of a problem is the
specialization of the problem statement to a particular parameter value.
As an example of a solvable problem, we mention:
Example 1.7.1. The statement “n is prime” represents the problem of deciding
whether an arbitrary number n ∈N is prime or composite. Here the parameter
is the variable n. For any particular n (e.g. n = 123456789), the question of
whether this particular n is prime or composite is an instance (i.e., special case)
of the general “primality problem”. Since the set of prime numbers
{n ∈N | n is prime}
34

is primitive recursive, the general primality problem is solvable.
On the other hand, we have the following example of an unsolvable problem.
Example 1.7.2. The set K deﬁned in Example 1.6.6 is nonrecursive. Hence by
Church’s Thesis there is no algorithm to decide whether or not a given number
n belongs to K. It is therefore appropriate to describe the membership problem
for K (i.e., the problem of computing the truth value of n ∈K for any given n)
as an unsolvable problem.
The ability to distinguish solvable problems from unsolvable ones is of basic
importance for the mathematical enterprise. Among the most famous unsolvable
mathematical problems are:
Example 1.7.3 (Hilbert’s Tenth Problem). Hilbert’s Tenth Problem is to de-
termine, for a given polynomial p in several variables with integral coeﬃents,
p ∈Z[X1, . . . , Xn], whether or not the equation p(X1, . . . , Xn) = 0 has a solu-
tion in integers X1, . . . , Xn ∈N. This problem encompasses the entire theory
of Diophantine equations. A theorem of Matijaseviˇc shows that Hilbert’s Tenth
Problem is unsolvable. Actually Matijaseviˇc produced a particular polynomial
p(X0, X1, . . . , X9)
with 10 indeterminates, such that
{n ∈N | p(n, a1, . . . , a9) = 0 for some a1, . . . , a9 ∈Z}
is nonrecursive. Once again, our notion of unsolvable problem is related to the
existence of a nonrecursive set, namely the set of parameter values n for which
the problem statement holds.
Example 1.7.4 (Word Problems). Let G be a group presented by ﬁnitely many
generators and relations. The word problem for G is the problem of determining,
for a given word w in the generators of G and their inverses, whether or not
w = 1 in G. In this case the parameter is w, and the word problem for G is
solvable if and only if there exists an algorithm for determining whether or not a
given word w is equal to 1 in G. It is known that the word problem is solvable for
some groups G and not solvable for others. For example, the word problem for
free groups or groups with one relation is solvable, but Boone and Novikov have
exhibited groups G with ﬁnitely many relations such that the word problem for
G is unsolvable.
Example 1.7.5 (The Halting Problem).
Some famous unsolvable problems arise from computability theory itself. One
of these is the Halting Problem: To determine whether or not a given register
machine program P will eventually stop, if started with all registers empty. By
G¨odel numbering, we can identify the Halting Problem with the problem of
deciding whether a given natural number e belongs to the set
H = {e ∈N | ϕ(1)
e (0) is deﬁned} .
35

We shall prove below that H is nonrecursive, i.e., the Halting Problem is un-
solvable.
In all of the above examples, the issue of solvability or unsolvability of a
particular problem was rephrased as an issue of whether or not a particular
subset of N is recursive. Such considerations based on Church’s Thesis motivate
the following deﬁnition:
Deﬁnition 1.7.6 (Unsolvability). Recall that a set A ⊆N is said to be recursive
if and only if its characteristic function χA : N →{0, 1} is recursive. A problem
is deﬁned to be a subset of N. If A ⊆N is a problem in this sense, the problem
A is said to be solvable if A is recursive, and unsolvable if A is nonrecursive.
We shall prove the unsolvability of the Halting Problem, i.e., the nonrecur-
siveness of the set H in Example 1.7.5 above. The proof will be accomplished
by showing that the problem of membership in K is “reducible” to the problem
of membership in H. In this context, reducibility of one problem to another
means that each instance of the former problem can be eﬀectively converted to
an equivalent instance of the latter problem. Our precise notion of reducibility
is given by:
Deﬁnition 1.7.7 (Reducibility). Let A and B be subsets of N (i.e., problems,
cf. Deﬁnition 1.7.6). We say that A is reducible to B if there exists a recursive
function f : N →N such that, for all n ∈N, n ∈A implies f(n) ∈B, and n /∈A
implies f(n) /∈B.
Lemma 1.7.8. Suppose that A is reducible to B. If B is recursive, then A is
recursive. If A is nonrecursive, then B is nonrecursive.
Proof. The ﬁrst statement follows easily from the fact that χA(x) = χB(f(x)).
The second statement follows since it is the contrapositive of the ﬁrst.
Exercise 1.7.9. Write A ≤m B to mean that A is reducible to B. Show that
1. A ≤m A for all A ⊆N.
2. A ≤m B and B ≤m C imply A ≤m C.
3. If ∅̸=B̸= N, then for every recursive set A we have A ≤m B.
In order to prove that the set H is nonrecursive, we shall need the following
important technical result:
Theorem 1.7.10 (The Parametrization Theorem). Let θ(x0, x1, . . . , xk) be a
(k+1)-ary partial recursive function. Then we can ﬁnd a unary primitive recur-
sive function f(x0) such that, for all x0, x1, . . . , xk ∈N,
ϕ(k)
f(x0)(x1, . . . , xk) ≃θ(x0, x1, . . . , xk) .
36

Proof. Let T be a register machine program which computes the k+1-ary partial
recursive function θ. The idea of the proof is to let f(x0) be the G¨odel number
of a program which is similar to T but has x0 hard-coded as the ﬁrst argument
of θ.
Formally, let T ′ be a register machine program which computes the k+1-ary
partial recursive function
θ′(x1, . . . , xk, x0) ≃θ(x0, x1, . . . , xk) .
Let I1, . . . , Il be the instructions of T ′, and let T ′′ be the same as T ′ but modiﬁed
so that the instructions are numbered I5, . . . , Il+4 instead of I1, . . . , Il. Then for
any given x0 ∈N, the program T ′′′
x0 depicted in Figure 1.12 computes the k-ary
partial recursive function λx1 . . . xk [ θ′(x1, . . . , xk, x0) ], i.e. λx1 . . . xk [ θ(x0, x1, . . . , xk) ].
The instructions of T ′′′
x0 are numbered as I1, . . . , Il+x0+5. Let f(x0) be the G¨odel
number of T ′′′
x0 . Note that
f(x0)
=
Ql+x0+5
m=1
p#(Im)
m
=
Ql+4
m=1 p#(Im)
m
· Ql+x0+4
m=l+5 p3k+1·5m+1
m
· p2·3k+1·55·75
l+x0+5
where the ﬁrst factor Ql+4
m=1 p#(Im)
m
does not depend on x0. Thus f(x0) is a
primitive recursive function of x0. This completes the proof.
I1
Il+5
. . .
Il+x0+4
Il+x0+5
I5 · · · Il+4
I2
I3
start
ONML
HIJK
/ R+
k+1
WVUT
PQRS
/ R+
k+1
WVUT
PQRS
/ . . .
/ R+
k+1
WVUT
PQRS
/ R−
k+1
WVUT
PQRS
/
e
/ T
′′
/ R−
k+1
WVUT
PQRS
cd
ab
`g
=
e
/ R−
k+2
WVUT
PQRS

e
/ stop
ONML
HIJK
x0
R+
k+1
WVUT
PQRS
O
I4
Figure 1.12: Parametrization
We can now prove that the Halting Problem is unsolvable.
Theorem 1.7.11 (Unsolvability of the Halting Problem). The Halting Problem
is unsolvable. In other words, the set
H = {x ∈N | ϕ(1)
x (0) is deﬁned}
of Example 1.7.5 is nonrecursive.
37

Proof. Let H be as in Example 1.7.5 and let K be as in Example 1.6.6, i.e.,
K = {x ∈N | ϕ(1)
x (x) is deﬁned} .
We shall prove that K is reducible to H. Since K is known to be nonrecursive
(Example 1.6.6), it will follow by Lemma 1.7.8 that H is nonrecursive.
Consider the partial recursive function θ(x, y) ≃ϕ(1)
x (x). Note that θ is a
2-place function. By the Enumeration Theorem, θ is partial recursive. By the
Parametrization Theorem applied with k = 1, we can ﬁnd a primitive recursive
function f : N →N such that
ϕ(1)
f(x)(y) ≃θ(x, y) ,
i.e.,
ϕ(1)
f(x)(y) ≃ϕ(1)
x (x)
for all x and y. In particular, if x ∈K then ϕ(1)
x (x) is deﬁned, hence ϕ(1)
f(x)(0) is
deﬁned, i.e., f(x) ∈H. On the other hand, if x /∈K then ϕ(1)
x (x) is undeﬁned,
hence ϕ(1)
f(x)(0) is undeﬁned, i.e., f(x) /∈H. Thus K is reducible to H via f.
This completes the proof.
Exercise 1.7.12. Show that the following sets and predicates are nonrecursive:
1. {x ∈N | ϕ(1)
x
: N
P
−→N is total}.
2. {x ∈N | ϕ(1)
x
is the empty function}.
3. {⟨x, y⟩∈N × N | ϕ(1)
x
= ϕ(1)
y }.
4. {⟨x, y⟩∈N × N | y ∈rng(ϕ(1)
x )}.
5. {x ∈N | 0 ∈rng(ϕ(1)
x )}.
6. {x ∈N | rng(ϕ(1)
x ) is inﬁnite}.
Exercise 1.7.13 (Rice’s Theorem). Let P be the class of 1-place partial recur-
sive functions. For C ⊆P, deﬁne IC to be the set of indices of functions in C,
i.e.,
IC = {x ∈N | ϕ(1)
x
∈C} .
Show that if ∅̸= C ̸= P then IC is nonrecursive.
Solution. Let e0 be an index of the empty function. Let e1 be an index such
that ϕ(1)
e1 ∈C if and only if ϕ(1)
e0 /∈C. By the Enumeration and Parametrization
theorems, we can ﬁnd a primitive recursive function f such that
ϕ(1)
f(x)(y) ≃
(
ϕ(1)
e1 (y)
if ϕ(1)
x (x) ↓,
↑
otherwise,
38

for all x and y.
Thus x ∈K implies ϕ(1)
f(x) = ϕ(1)
e1 , while x /∈K implies
ϕ(1)
f(x) = ϕ(1)
e0 . Thus f reduces K either to IC (if ϕ(1)
e1 ∈C) or to the complement
of IC (if ϕ(1)
e1 /∈C). In either case it follows that IC is not recursive.
1.8
The Recursion Theorem
In this section we present an interesting and mysterious theorem known as the
Recursion Theorem.
Theorem 1.8.1 (The Recursion Theorem). Let θ(w, x1, . . . , xk) be a partial
recursive function. Then we can ﬁnd an index e such that, for all x1, . . . , xk,
ϕ(k)
e (x1, . . . , xk)
≃
θ(e, x1, . . . , xk) .
Proof. Applying the Parametrization Theorem and the Enumeration Theorem,
we can ﬁnd primitive recursive functions f and d such that, for all w, u, x1, . . . , xk,
ϕ(k)
f(w)(x1, . . . , xk)
≃
θ(w, x1, . . . , xk) .
and
ϕ(k)
d(u)(x1, . . . , xk)
≃
ϕ(k)
ϕ(1)
u (u)(x1, . . . , xk) .
Let v be an index of f ◦d, i.e., ϕ(1)
v (u) = f(d(u)) for all u. Then
ϕ(k)
d(v)(x1, . . . , xk)
≃
ϕ(k)
ϕ(1)
v
(v)(x1, . . . , xk)
≃
ϕ(k)
f(d(v))(x1, . . . , xk)
≃
θ(d(v), x1, . . . , xk)
so we may take e = d(v). This completes the proof.
Example 1.8.2. As an example, if we take θ(w, x) = w + x, then we obtain an
index e such that ϕ(1)
e (x) = e + x for all x.
Example 1.8.3. As another illustration of the Recursion Theorem, we now
use it to prove that the Ackermann function λnx [ An(x) ] (see Section 1.2) is
computable. The recursion equations deﬁning the Ackermann function can be
written as
A0(x)
=
2x
An+1(0)
=
1
An+1(x + 1)
=
An(An+1(x)) .
Writing A(x, y) = Ax(y), this becomes
A(0, y)
=
2y
A(x + 1, 0)
=
1
A(x + 1, y + 1)
=
A(x, A(x + 1, y))
39

or in other words
A(x, y)
=





2y
if x = 0 ,
1
if x > 0 and y = 0 ,
A(x ·−1, A(x, y ·−1))
if x > 0 and y > 0 .
By the Enumeration Theorem together with the Recursion Theorem, we can
ﬁnd an index e such that
ϕ(2)
e (x, y)
≃







2y
if x = 0 ,
1
if x > 0 and y = 0 ,
ϕ(2)
e (x ·−1, ϕ(2)
e (x, y ·−1))
if x > 0 and y > 0 .
It is then straightforward to prove by induction on x that, for all y, ϕ(2)
e (x, y) ≃
A(x, y). This completes the proof.
Exercise 1.8.4.
1. Find a primitive recursive function f(x, y) such that, for all x and y,
ϕ(1)
f(x,y) = ϕ(1)
x
◦ϕ(1)
y
.
2. Find a primitive recursive function g(x, y) such that, for all x and y,
dom(ϕ(1)
g(x,y)) = dom(ϕ(1)
x ) ∩dom(ϕ(1)
y ) .
3. Find a primitive recursive function h(x, y) such that, for all x and y,
dom(ϕ(1)
h(x,y)) = dom(ϕ(1)
x ) ∪dom(ϕ(1)
y ) .
Solution.
1. By the Enumeration Theorem and the Parametrization Theorem, ﬁnd a
primitive recursive function bf(w) such that
ϕ(1)
b
f(w)(z) ≃ϕ(1)
(w)1(ϕ(1)
(w)2(z))
for all w, z. Then f(x, y) = bf(3x5y) has the desired property.
2. By the Enumeration Theorem and the Parametrization Theorem, ﬁnd a
primitive recursive function bg(w) such that
ϕ(1)
bg(w)(z) ≃ϕ(1)
(w)1(z) + ϕ(1)
(w)2(z)
for all w, z. Then g(x, y) = bg(3x5y) has the desired property.
40

3. By the Parametrization Theorem, ﬁnd a primitive recursive function bh(w)
such that
ϕ(1)
bh(w)(z) ≃least n such that (State((w)1, z, n))0 · (State((w)2, z, n))0 = 0
for all w, z. Then h(x, y) = bh(3x5y) has the desired property.
Exercise 1.8.5.
1. Find a primitive recursive function f(x) such that for all x, if ϕ(1)
x
is a
permutation of N, then ϕ(1)
f(x) is the inverse permutation.
2. What happens if ϕ(1)
x
is assumed only to be partial and one-to-one, and
not necessarily a permutation?
Solution. Consider the partial recursive function θ(x, y) ≃least w such that
(State(x, (w)1, (w)2))0 = 0 and (State(x, (w)1, (w)2))2 = y. By construction, if
ϕ(1)
x (z) ≃y then (θ(x, y))1 ≃z. Therefore, by the Parametrization Theorem,
let f(x) be a primitive recursive function such that ϕ(1)
f(x)(y) ≃(θ(x, y))1. This
works even if ϕ(1)
x
is only assumed to be partial and one-to-one.
Exercise 1.8.6. Find m and n such that m ̸= n and ϕ(1)
m (0) = n and ϕ(1)
n (0) =
m.
Solution. By the Parametrization Theorem, let f be a 1-place primitive recursive
function such that ϕ(1)
f(x)(y) = x for all x, y. The construction of f in the proof of
the Parametrization Theorem shows that f(x) > x for all x. By the Recursion
Theorem, let e be such that ϕ(1)
e (y) ≃f(e) for all y. In particular we have
ϕ(1)
e (0) ≃f(e), ϕ(1)
f(e)(0) = e, and f(e) > e. So take m = e and n = f(e).
1.9
The Arithmetical Hierarchy
In this section we study some important classes of number-theoretic predicates:
Σ0
1, Π0
1, Σ0
2, Π0
2, . . . . These classes collectively are known as the arithmetical
hierarchy.
Deﬁnition 1.9.1 (The Arithmetical Hierarchy). We deﬁne Σ0
0 and Π0
0 to be
the class of primitive recursive predicates. For n ≥1, we deﬁne Σ0
n to be the
class of k-place predicates P ⊆Nk (for any k ≥1) such that P can be written
in the form
P(x1, . . . , xk) ≡∃y R(x1, . . . , xk, y)
where R is a k+1-place predicate belonging to the class Π0
n−1. Similarly, we
deﬁne Π0
n to be the class of predicates that can be written in the form
P(x1, . . . , xk) ≡∀y R(x1, . . . , xk, y)
where R belongs to the class Σ0
n−1.
41

For example, a predicate P(x1, . . . , xk) belongs to the class Σ0
3 if and only if
it can be written in the form
∃y1∀y2∃y3 R(x1, . . . , xk, y1, y2, y3)
where R is primitive recursive. Similarly, P belongs to the class Π0
3 if and only
if it can be written in the form
∀y1∃y2∀y3 R(x1, . . . , xk, y1, y2, y3)
where R is primitive recursive.
Theorem 1.9.2. We have:
1. The classes Σ0
n and Π0
n are included in the classes Σ0
n+1 and Π0
n+1.
2. The classes Σ0
n and Π0
n are closed under conjunction and disjunction.
3. The classes Σ0
n and Π0
n are closed under bounded quantiﬁcation.
4. For n ≥1, the class Σ0
n is closed under existential quantiﬁcation.
5. For n ≥1, the class Π0
n is closed under universal quantiﬁcation.
6. A predicate P belongs to Σ0
n (respectively Π0
n) if and only if ¬ P belongs
to Π0
n (respectively Σ0
n).
Proof. Straightforward.
Theorem 1.9.3. A k-place predicate P ⊆Nk belongs to the class Σ0
1 if and
only if P = dom(ψ) for some k-place partial recursive function ψ : Nk
P
−→N.
Proof. If P is Σ0
1, then we have
P(x1, . . . , xk)
≡
∃y R(x1, . . . , xk, y)
where R is primitive recursive, hence P = dom(ψ) where
ψ(x1, . . . , xk)
≃
least y such that R(x1, . . . , xk, y) holds ,
and clearly ψ is partial recursive. Conversely, if P = dom(ψ), then letting e be
an index of ψ, we have as in the proof of the Enumeration Theorem
P(x1 . . . , xk)
≡
∃n (State(e, x1, . . . , xk, n))0 = 0 ,
hence P is Σ0
1.
Corollary 1.9.4. P ⊆Nk is Σ0
1 if and only if
P(x1, . . . , xk) ≡∃y R(x1, . . . , xk, y)
where R ⊆Nk+1 is recursive (not only primitive recursive).
42

Remark 1.9.5. It follows that, in the deﬁnition of Σ0
n and Π0
n for n ≥1, we
may replace “primitive recursive” by “recursive”.
Exercises 1.9.6. If ψ is a k-place partial function, the graph of ψ is the (k+1)-
place predicate Gψ = {⟨x1, . . . , xk, y⟩| ψ(x1, . . . , xk) ≃y}.
1. Show that ψ is partial recursive if and only if the graph of ψ is Σ0
1.
2. Show that, for every (k+1)-place Σ0
1 predicate P(x1, . . . , xk, y) there exists
a k-place partial recursive function ψ(x1, . . . , xk) which uniformizes P, i.e.,
Gψ ⊆P and dom(ψ) = {⟨x1, . . . , xk⟩| ∃y P(x1, . . . , xk, y)}.
Deﬁnition 1.9.7. Let A be an inﬁnite subset of N. The principal function of
A is the one-to-one function πA : N →N that enumerates the elements of A in
increasing order.
Lemma 1.9.8. Let A be an inﬁnite subset of N. The set A is recursive if and
only if the function πA is recursive.
Proof. If A is recursive then the functions νA and πA deﬁned by
νA(x)
=
least y such that y ≥x and y ∈A
πA(0)
=
νA(0)
πA(x + 1)
=
νA(πA(x) + 1)
are obviously recursive. Conversely, if πA is recursive then we have
y ∈A
if and only if
y_
x=0
πA(x) = y .
Since the class of recursive predicates is closed under bounded quantiﬁcation, it
follows that A is recursive.
Theorem 1.9.9. For A ⊆N, the following are pairwise equivalent:
1. A is Σ0
1;
2. A = dom(ψ) for some partial recursive function ψ : N
P
−→N;
3. A = rng(ψ) for some partial recursive function ψ : N
P
−→N;
4. A = ∅or A = rng(f) for some total recursive function f : N →N;
5. A is ﬁnite or A = rng(f) for some one-to-one total recursive function
f : N →N.
43

Proof. The equivalence of 1 and 2 is a special case of Theorem 1.9.3, and the
fact that 3 implies 1 is proved similarly. It is easy to see that 5 implies 4 and 4
implies 3. To see that 1 implies 5, suppose that A ⊆N is inﬁnite and Σ0
1, say
x ∈A ≡∃yR(x, y)
where R is primitive recursive. Put
B =
(
2x3y
 R(x, y) ∧¬
y−1
_
z=0
R(x, z)
)
.
Then B is an inﬁnite primitive recursive set, so by Lemma 1.9.8, πB is a one-to-
one recursive function. Putting f(n) = (πB(n))0, we see that f is a one-to-one
recursive function and A = rng(f). This completes the proof.
Remark 1.9.10. A set A satisfying the conditions of Theorem 1.9.9 is some-
times called a recursively enumerable set.
Exercises 1.9.11.
1. Show that every nonempty recursively enumerable set is the range of a
primitive recursive function.
2. Find an inﬁnite primitive recursive set that is not the range of a one-to-one
primitive recursive function.
Deﬁnition 1.9.12. For each n ∈N, the class ∆0
n is deﬁned to be the intersection
of the classes Σ0
n and Π0
n.
Theorem 1.9.13. A k-place predicate P ⊆Nk belongs to the class ∆0
1 if and
only if P is recursive.
Proof. If P is recursive, it follows easily by Theorem 1.9.3 that P is ∆0
1. Con-
versely, if P is ∆0
1, then we have
P(x1, . . . , xk)
≡
∃y R1(x1, . . . , xk, y)
≡
∀y R2(x1, . . . , xk, y)
where R1 and R2 are primitive recursive. Deﬁne a total recursive function f by
f(x1, . . . , xk)
=
least y such that R1(x1, . . . , xk, y) ∨¬ R2(x1, . . . , xk, y) .
Then we have
P(x1, . . . , xk)
≡
R1(x1, . . . , xk, f(x1, . . . , xk)) ,
hence P is recursive.
44

Exercise 1.9.14. A function f : Nk →N is said to be limit-recursive if there
exists a recursive function g : Nk+1 →N such that
f(x1, . . . , xk) = lim
y g(x1, . . . , xk, y)
for all x1, . . . , xk ∈N. Show that a predicate P is ∆0
2 if and only if its charac-
teristic function χP is limit-recursive.
Solution. For simplicity, let x be an abbreviation for x1, . . . , xk.
First assume that χP is limit-recursive, say
χP (x) = lim
n f(n, x)
for all x, where f(n, x) is a recursive function. Then we have
P(x) ≡∃m ∀n (n ≥m ⇒f(n, x) = 1)
and
¬ P(x) ≡∃m ∀n (n ≥m ⇒f(n, x) = 0)
so P is ∆0
2.
For the converse, assume that P is ∆0
2, say
P(x) ≡∃y ∀z R1(x, y, z)
and
¬ P(x) ≡∃y ∀z R0(x, y, z)
where R1 and R0 are primitive recursive predicates. Using the bounded least
number operator, deﬁne g(n, x) = the least y < n such that either ∀z <
n R1(x, y, z) or ∀z < n R0(x, y, z) or both, if such a y exists, and g(n, x) =
n otherwise.
Thus g(n, x) is a primitive recursive function, and it is easy
to see that, for all x, g(x) = limn g(n, x) exists and is equal to the least y
such that ∀z R1(x, y, z) or ∀z R0(x, y, z).
Now deﬁne h(n, x) = 1 if ∀z <
n R1(x, g(n, x), z), and h(n, x) = 0 otherwise. Thus h(n, x) is again a primi-
tive recursive function, and for all x, h(x) = limn h(n, x) exists. Moreover P(x)
implies h(x) = 1, and ¬ P(x) implies h(x) = 0. Thus χP is limit-recursive. This
completes the proof.
Theorem 1.9.15 (Universal Σ0
n Predicate). For each n ≥1 and k ≥1, we can
ﬁnd a predicate U = Un,k with the following properties:
1. U is a k+1-place predicate belonging to the class Σ0
n; and
2. for any k-place predicate P belonging to the class Σ0
n, there exists an e ∈N
such that
P(x1, . . . , xk) ≡U(e, x1, . . . , xk)
for all x1, . . . , xk.
45

Proof. This is a straightforward consequence of the Enumeration Theorem. The
proof is by induction on n. For n = 1 we have
U1,k(e, x1, . . . , xk) ≡ϕ(k)
e (x1, . . . , xk) ↓≡∃s (State(e, x1, . . . , xk, s))0 = 0
in view of Theorem 1.9.3. For n > 1 we have
Un,k(e, x1, . . . , xk) ≡∃y ¬ Un−1,k+1(e, x1, . . . , xk, y) .
This completes the proof.
Lemma 1.9.16. Let A, B ⊆N and assume that A is reducible to B. Assume
n ≥1. If B belongs to Σ0
n, then so does A. If B belongs to Π0
n, then so does A.
Proof. Suppose for example that B belongs to Σ0
3. Then we have
x ∈B
if and only if
∃y1 ∀y2 ∃y3 R(x, y1, y2, y3)
where R ⊆N4 is a primitive recursive predicate. If A is reducible to B via the
recursive function f, then we have
x ∈A
if and only if
f(x) ∈B
if and only if
∃y1 ∀y2 ∃y3 R(f(x), y1, y2, y3) .
Note that the predicate R(f(x), y1, y2, y3) is recursive, hence ∆0
1. It follows that
the predicate ∃y3 R(f(x), y1, y2, y3) is Σ0
1. Hence A is Σ0
3.
Deﬁnition 1.9.17. Given n ≥1, a set B ⊆N is said to be complete Σ0
n if
1. B belongs to the class Σ0
n; and
2. for any set A ⊆N belonging to the class Σ0
n, A is reducible to B.
The notion of complete Π0
n set is deﬁned similarly.
Theorem 1.9.18. For each n ≥1 there exists a complete Σ0
n set. For each
n ≥1 there exists a complete Π0
n set. For each n ≥1, a complete Σ0
n set is not
Π0
n, and a complete Π0
n set is not Σ0
n.
Proof. By Theorem 1.9.15 let U(e, x) be a universal Σ0
n predicate. Obviously
the set {2e3x | U(e, x)} is Σ0
n complete. To show that a Σ0
n complete set can
never be Π0
n, it suﬃces by Lemma 1.9.16 to show that there exists a Σ0
n set which
is not Π0
n. A simple diagonal argument shows that the Σ0
n set {x | U(x, x)} is
not Π0
n. This completes the proof of the Σ0
n part of the theorem. The Π0
n part
follows easily by taking complements.
Corollary 1.9.19. For all n ∈N we have
∆0
n ⊆Σ0
n ,
∆0
n ⊆Π0
n ,
Σ0
n ∪Π0
n ⊆∆0
n+1
and, except for n = 0, all of these inclusions are proper.
46

Proof. Given n ≥1, let A be a complete Σ0
n set. Then the complement B = N\A
is complete Π0
n.
Clearly A belongs to Σ0
n \ ∆0
n and B belongs to Π0
n \ ∆0
n.
Moreover it follows by Theorem 1.9.2 and Lemma 1.9.16 that the set
A ⊕B
=
{2x | x ∈A} ∪{2x + 1 | x ∈B}
belongs to ∆0
n+1 \ (Σ0
n ∪Π0
n).
Exercises 1.9.20.
1. Show that the sets
H = {x | ϕ(1)
x (0) is deﬁned}
and
K = {x | ϕ(1)
x (x) is deﬁned}
are complete Σ0
1 sets.
2. Show that the set
T = {x | ϕ(1)
x
is total}
is a complete Π0
2 set.
Exercise 1.9.21. What reducibility and non-reducibility relations exist among
the following sets? Note that H, T , E, and S are index sets.
K = {x ∈N | ϕ(1)
x (x) ↓},
H = {x ∈N | ϕ(1)
x (0) ↓},
T = {x ∈N | ϕ(1)
x
is total},
E = {x ∈N | ϕ(1)
x
is the empty function},
S = {x ∈N | dom(ϕ(1)
x ) is inﬁnite}.
Prove your answers.
Hint: Using the Parametrization Theorem as in the proof of Theorem 1.7.11,
show that H and K are Σ0
1 complete, S and T are Π0
2 complete, and E is Π0
1
complete. These completeness facts, together with Lemma 1.9.16 and Theorem
1.9.18, determine the reducibility relations among H, K, S, T , and E.
47

Chapter 2
Undecidability of
Arithmetic
We are going to show that arithmetic is undecidable. This means that there is
no algorithm to decide whether a given sentence in the language of arithmetic
is true or false.
2.1
Terms, Formulas, and Sentences
By arithmetic we mean the set of sentences which are true in the structure
(N, +, ·, 0, 1, =). Here N = {0, 1, 2, . . .} is the set of non-negative integers, +
and · denote the 2-place operations of addition and multiplication on N, and =
denotes the 2-place relation of equality between elements of N. For the beneﬁt
of the reader who has not previously studied mathematical logic, we shall now
review the concept of a sentence being true in a structure. Since we are only
interested in the particular structure (N, +, ·, 0, 1, =), we shall concentrate on
that case.
It is ﬁrst necessary to deﬁne a language appropriate for the structure
(N, +, ·, 0, 1, =).
Our language contains inﬁnitely many variables x0, x1, . . . , xn, . . . which are
usually denoted by letters such as x, y, z, . . . . Each of these variables is also a
term of our language. In addition the symbols 0 and 1 are terms. Other terms
are built up using the 2-place operation symbols + and ·. Examples of terms
are
1 + 1 + 1 ,
x + 1 ,
(x + y) · z + x .
When writing terms, we may employ the usual abbreviations.
For instance
1 + 1 + 1 = 3 and x · x · x = x3. Thus a term is essentially a polynomial in
several variables with non-negative integer coeﬃcients.
48

An atomic formula is a formula of the form t1 = t2 where t1 and t2 are
terms. Examples of atomic formulas are
x + 1 = y ,
x = 3y2 + 1 .
Formulas are built from atomic formulas by using the Boolean propositional
connectives ∧, ∨, ¬ (and, or, not) and the quantiﬁers ∀, ∃(for all, there exists).
An example of a formula is
∃z (x + z + 1 = y)
(2.1)
In this formula, x, y and z are to be interpreted as variables ranging over the
set N. Similarly the expression ∃z . . . is to be interpreted as “there exists a
non-negative integer z in N such that . . . .” Thus the formula (2.1) expresses
the assertion that x is less than y.
From now on we shall write x < y as
an abbreviation for (2.1).
This idea of introducing new relation symbols as
abbreviations for formulas allows us to expand our language indeﬁnitely.
Another example of a formula is
x > 1 ∧¬ ∃y ∃z (y > 1 ∧z > 1 ∧x = y · z) .
(2.2)
This formula expresses the assertion that x is a prime number. Thus we might
choose to abbreviate (2.2) by some expression such as Prime(x) or “x is prime.”
In any particular formula, a free variable is a variable which is not acted on
by any quantiﬁer in that formula. For example, the free variables of (2.1) are x
and y, while in (2.2) the only free variable is x. A sentence is a formula with
no free variables. Examples of sentences are
∀x (∃y (x = 2y) ∨∃y (x = 2y + 1))
(2.3)
and
∀x ∃y (x = y + 1) .
(2.4)
When interpreting formulas or sentences in the structure (N, +, ·, 0, 1, =),
please bear in mind that the quantiﬁers ∀and ∃range over the set of non-
negative integers, N. Thus ∀x means “for all x in N,” and ∃x means “for some
x in N” or “there exists x in N such that . . . .”
With this understanding, we
know what it means for a sentence of our language to be true or false in the
structure (N, +, ·, 0, 1, =). For example (2.3) is true (because every element of
N is either even or odd) and (2.4) is false (because not every element of N is the
successor of some other element of N).
Let F(x1, . . . , xk) be a formula whose free variables are x1, . . . , xk. Then for
any non-negative integers a1, . . . , ak ∈N, we can form the sentence F(a1, . . . , ak)
which is obtained by substituting (“plugging in”) the constants a1, . . . , ak for
the free occurrences of the variables x1, . . . , xk. For example, let F(x, y) be the
formula
∃z (x2 + z = y)
49

with free variables x and y. Then for any particular non-negative integers m
and n, F(m, n) is a sentence which expresses the assertion that m2 is less than
or equal to n. For instance F(5, 40) is true and F(5, 20) is false.
This completes our review of the concept of a sentence being true or false in
the structure (N, +, ·, 0, 1, =).
Exercise 2.1.1. Write a sentence expressing Goldbach’s Conjecture: Every
even number is the sum of two prime numbers.
2.2
Arithmetical Deﬁnability
We now present a key deﬁnition.
Deﬁnition 2.2.1 (Arithmetical Deﬁnability). A k-place partial function
λx1 · · · xk [ ψ(x1, . . . , xk) ]
is said to be arithmetically deﬁnable if there exists a formula
F(x1, . . . , xk, xk+1)
with free variables x1, . . . , xk, xk+1, such that for all m1, . . . , mk, n ∈N,
ψ(m1, . . . , mk) ≃n
if and only if
F(m1, ..., mk, n) is true.
(Of course it doesn’t matter whether we use the variables x1, . . . , xk, xk+1 or
some other set of k + 1 distinct variables.)
For example, the 1-place function λx [ 2x ] is arithmetically deﬁnable, by the
formula y = 2x. (Here we are using a formula with two free variables x and y.)
As another example, note that the 2-place functions λxy [ Quotient(y, x) ] and
λxy [ Remainder(y, x) ] (the quotient and remainder of y on division by x) are
arithmetically deﬁnable, by the formulas
∃u ∃v (y = u · x + v ∧v < x ∧z = u)
and
∃u ∃v (y = u · x + v ∧v < x ∧z = v)
respectively. (Here we are using formulas with free variables x, y, and z.)
Exercise 2.2.2. Show that the function
λxy [ least common multiple of x and y ]
is arithmetically deﬁnable.
50

Remark 2.2.3. A more “mathematical” characterization of arithmetical de-
ﬁnability, not involving formulas, may be given as follows.
Let us say that
a predicate P ⊆Nk is strongly Diophantine if there exists a polynomial with
integer coeﬃcients, f(x1, . . . , xk) ∈Z[x1, . . . , xk], such that
P = {⟨a1, . . . , ak⟩∈Nk | f(a1, . . . , ak) = 0}.
For Q ⊆Nk+1, the projection of Q is given as
π(Q) = {⟨a1, . . . , ak⟩∈Nk | ⟨a1, . . . , ak, ak+1⟩∈Q for some ak+1 ∈N} .
Then, the arithmetically deﬁnable predicates may be characterized as the small-
est class of number-theoretic predicates which contains all strongly Diophantine
predicates and is closed under union, complementation, and projection. Clearly
each arithmetically deﬁnable predicate is obtained by applying these operations
only a ﬁnite number of times.
Exercise 2.2.4. Show that the following number-theoretic predicates are arith-
metically deﬁnable, by exhibiting formulas which deﬁne them over the structure
(N, +, ·, 0, 1, =).
1. GCD(x, y) = z.
2. LCM(x, y) = z.
3. Quotient(x, y) = z.
4. Remainder(x, y) = z.
5. x is the largest prime number less than y.
6. x is the product of all the prime numbers less than y.
Remark 2.2.5. The principal result of this section, Theorem 2.2.21 below, is
that all recursive functions and predicates are arithmetically deﬁnable. From
this it will follow easily that there exists an arithmetically deﬁnable predicate
which is not recursive (Corollary 2.2.22 below). In addition, we shall character-
ize the class of arithmetically deﬁnable predicates in terms of the arithmetical
hierarchy (Theorem 2.2.23 below).
Lemma 2.2.6. The initial functions are arithmetically deﬁnable.
Proof. The constant zero function λx [ 0 ] is deﬁned by the formula
x = x ∧y = 0 .
The successor function λx [ x + 1 ] is deﬁned by the formula
y = x + 1 .
For 1 ≤i ≤k, the projection function λx1 . . . xk [ xi ] is deﬁned by the formula
x1 = x1 ∧. . . ∧xk = xk ∧y = xi .
This completes the proof.
51

Lemma 2.2.7. If the functions g1(x1, . . . , xk), . . . , gm(x1, . . . , xk) and h(y1, . . . , ym)
are arithmetically deﬁnable, then so is the function
f(x1, . . . , xk)
=
h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk))
obtained by composition.
Proof. Let g1(x1, . . . , xk), . . . , gm(x1, . . . , xk), h(y1, . . . , ym) be deﬁned by the
formulas
G1(x1, . . . , xk, y) , . . . , Gm(x1, . . . , xk, y) , H(y1, . . . , ym, z)
respectively. Then f(x1, . . . , xk) is deﬁned by the formula
∃y1 · · · ∃ym(G1(x1, . . . , xk, y1) ∧. . . ∧Gm(x1, . . . , xk, ym) ∧H(y1, . . . , ym, z))
which we may abbreviate as F(x1, . . . , xk, z). This proves the lemma.
A k-place predicate P(x1, . . . , xk) is said to be arithmetically deﬁnable if it
is deﬁnable over the structure (N, +, ·, 0, 1, =) by a formula with k free variables
x1, . . . , xk.
Lemma 2.2.8. If the k+1-place predicate R(x1, . . . , xk, y) is arithmetically
deﬁnable, then so is the k-place partial function
ψ(x1, . . . , xk)
≃
least y such that R(x1, . . . , xk, y) holds.
Proof. Our λx1 . . . xk[ψ(x1, . . . , xk)] is arithmetically deﬁnable by the formula
R(x1, . . . , xk, y) ∧¬ ∃z (z < y ∧R(x1, . . . , xk, z))
which we may abbreviate as F(x1, . . . , xk, y). This proves the lemma.
It remains to prove:
Lemma 2.2.9. If the total k-place function g(y1, . . . , yk) and the total k+2-
place function h(x, z, y1, . . . , yk) are arithmetically deﬁnable, then so is the total
k+1-place function
f(x, y1, . . . , yk)
obtained by primitive recursion:
f(0, y1, . . . , yk)
=
g(y1, . . . , yk) ,
f(x + 1, y1, . . . , yk)
=
h(x, f(x, y1, . . . , yk), y1, . . . , yk)) .
In order to prove Lemma 2.2.9, we need some deﬁnitions and lemmas from
number theory. Two positive integers m and n are said to be relatively prime if
they have no common factor greater than 1. A set of positive integers is said to
be pairwise relatively prime if any two distinct integers in the set are relatively
prime.
52

Lemma 2.2.10. Given a positive integer k, we can ﬁnd inﬁnitely many positive
integers a such that the k integers in the set
a + 1 , 2a + 1 , . . . , ka + 1
are pairwise relatively prime.
Proof. Let a be any positive integer which is divisible by all of the prime numbers
which are less than k. We claim that a + 1, 2a + 1, . . . , ka + 1 are pairwise
relatively prime. Suppose not. Let i and j be such that 1 ≤i < j ≤k and ia+1
and ja+1 are not relatively prime. Let p be a prime number which is a factor of
both ia+1 and ja+1. Then p cannot be a factor of m. Hence p is greater than
or equal to k. On the other hand p is a factor of (ja + 1) −(ia + 1) = (j −i)a.
Hence p is a factor of j −i. But j −i is less than k, hence p is less than k, a
contradiction.
Example 2.2.11. If k = 5, the primes less than k are 2 and 3, so we can take
a to be any multiple of 6. Then the integers a + 1, 2a + 1, 3a + 1, 4a + 1,
5a + 1 will be pairwise relatively prime. Taking a = 6 we see that 7, 13, 19, 25,
31 are paiwise relatively prime. Taking a = 12 we see that 13, 25, 37, 49, 61
are pairwise relatively prime. And taking a = 600 we see that 601, 1201, 1801,
2401, 3001 are pairwise relatively prime.
Lemma 2.2.12 (Chinese Remainder Theorem). Let m1, . . . , mk be a set of k
distinct positive integers which are pairwise relatively prime. Then for any given
non-negative integers ri < mi, 1 ≤i ≤k, we can ﬁnd a non-negative integer r
such that Remainder(r, mi) = ri for all i.
Proof. Let m be the product of m1, . . . , mk. For any non-negative integer r
less than m, deﬁne the remainder sequence of r to be the sequence ⟨r1, . . . , rk⟩
where ri = Remainder(r, mi).
We claim that any two distinct non-negative
integers less than m have distinct remainder sequences. To see this, let r and
s be non-negative integers less than m. If r and s have the same remainder
sequence, then r −s is divisible by each of m1, . . . , mk. Since m1, . . . , mk are
pairwise relatively prime, it follows that r −s is divisible by m. Since r and
s are both less than m, we must have r = s. This proves the claim. Deﬁne a
possible remainder sequence to be any sequence ⟨r1, . . . , rk⟩with 0 ≤ri < mi
for all i. The number of possible remainder sequences is exactly m. From this
and the claim, we see that any possible remainder sequence must actually occur
as the remainder sequence associated with some r in the range 0 ≤r < m. The
lemma follows immediately.
Example 2.2.13. Continuing the previous example, we see that for any non-
negative integers r1 < 7, r2 < 13, r3 < 19, r4 < 25, r5 < 31, there must be a
non-negative integer r less than 7·13·19·25·31 such that Remainder(r, 7) = r1,
. . . , Remainder(r, 31) = r5. We may view the integer r as a “code” for the
sequence (r1, r2, r3, r4, r5). The “decoding” is accomplished by means of the
key integer 6, since ri = Remainder(r, 6i + 1).
53

Deﬁnition 2.2.14. For any non-negative integers r, a, i, we deﬁne
β(r, a, i)
=
Remainder(r, a · (i + 1) + 1) .
This 3-place function is known as G¨odel’s β-function. Note that the β-function
is arithmetically deﬁnable.
The signiﬁcance of the β-function is that it can be used to encode an ar-
bitrary sequence of non-negative integers ⟨r0, r1, . . . , rk⟩by means of two non-
negative integers r and a. We make this precise in the following lemma.
Lemma 2.2.15. Given a ﬁnite sequence of non-negative integers r0, r1, . . . , rk,
we can ﬁnd a pair of non-negative integers r and a such that β(r, a, 0) = r0,
β(r, a, 1) = r1, . . . , β(r, a, k) = rk.
Proof. By Lemma 2.2.10 (replacing k by k + 1), we can ﬁnd a positive integer a
such that r0 < a+1, r1 < 2a+1, . . . , rk < (k +1)·a+1, and furthermore a+1,
2a + 1, . . . , (k + 1) · a + 1 are pairwise relatively prime. Then by Lemma 2.2.12
we can ﬁnd a non-negative integer r such that Remainder(r, a + 1) = r0,
Remainder(r, 2a + 1) = r1, . . . , Remainder(r, (k + 1) · a + 1) = rk. This proves
the lemma.
Exercise 2.2.16. Find a pair of numbers r, a such that β(r, a, 0) = 11, β(r, a, 1) =
19, β(r, a, 2) = 30, β(r, a, 3) = 37, β(r, a, 4) = 51.
Hint: First ﬁnd an appropriate a by hand. Then write a small computer program
to ﬁnd r by brute force.
We are now ready to prove Lemma 2.2.9.
Proof of Lemma 2.2.9. Let the total functions g(y1, . . . , yk) and h(x, z, y1, . . . , yk)
be deﬁned by the formulas G(y1, . . . , yk, w) and H(x, z, y1, . . . , yk, w) respec-
tively. We wish to write down a formula F(x, y1, . . . , yk, w) which would say that
there exists a ﬁnite sequence r0, r1, . . . , rx such that G(y1, . . . , yk, r0) holds, and
H(i, ri, y1, . . . , yk, ri+1) holds for all i < x, and ﬁnally rx = w. If we could do
this, then clearly F(x, y1, . . . , yk, w) would deﬁne the function f(x, y1, . . . , yk).
This would prove the lemma. The only diﬃculty is that our language is not
powerful enough to talk directly about ﬁnite sequences of variable length in
the required way.
Our language allows us to say things like “there exists a
non-negative integer r such that . . . ,” but it does not allow us to directly say
things like “there exists a sequence of non-negative integers r0, r1, . . . , rx (of
variable length, x) such that . . . .” The way to overcome this diﬃculty is to
use the β-function. Instead of saying “there exists a ﬁnite sequence r0, r1, . . . ,
rk,” we can say “there exists a pair of non-negative integers r and a which
encode the required sequence, via the β-function.” Namely, we write down a
formula F(x, y1, . . . , yk, w) which says, informally, there exist r and a such that
G(y1, . . . , yk, β(r, a, 0)) holds, and H(i, β(r, a, i), y1, . . . , yk, β(r, a, i + 1)) holds
for all i < x, and ﬁnally β(r, a, x) = w. By Lemma 2.2.15 it is clear that this
54

formula deﬁnes the function f(x, y1, . . . , yk). Formally, let B(r, a, i, w) be a for-
mula which deﬁnes the β-function. We may then take F(x, y1, . . . , yk, w) to be
the formula
∃r ∃a ( ∃u (B(r, a, 0, u) ∧G(y1, . . . , yk, u)) ∧B(r, a, x, w) ∧
∀i ( i ≥x ∨∃u ∃v (B(r, a, i, u) ∧B(r, a, i + 1, v) ∧H(i, u, y1, . . . , yk, v)) ) ) .
This completes the proof of Lemma 2.2.9.
Example 2.2.17. The exponential function λxy [ yx ] is arithmetically deﬁnable
by the formula
∃r ∃a ( B(r, a, 0, 1) ∧B(r, a, x, w) ∧
∀i ( i ≥x ∨∃u ∃v (B(r, a, i, u) ∧B(r, a, i + 1, v) ∧v = u · y) ) )
which we may abbreviate as Exp(x, y, w), meaning that yx = w.
Exercise 2.2.18. Consider the function f : N →N deﬁned by
f(n) =
(
n/2
if n is even,
3n + 1
if n is odd.
For each k ∈N let
f k = f ◦· · · ◦f
|
{z
}
k
,
i.e., f 0(n) = n and f k+1(n) = f(f k(n)).
Write a formula F(x, y, z) in the language +, ·, 0, 1, =, < which, when in-
terpreted over the natural number system N, deﬁnes the 3-place predicate
f x(y) = z.
Exercise 2.2.19. Show that the function λx [ the xth Fibonacci number ] is
arithmetically deﬁnable.
Exercise 2.2.20. Which of the following number-theoretic predicates are arith-
metically deﬁnable? Prove your answers.
1. x is the sum of all the prime numbers less than y.
2. xy = z.
3. x! = y.
Theorem 2.2.21. Every partial recursive function is arithmetically deﬁnable.
Proof. Recall that the partial recursive functions have been characterized as the
smallest class of functions which includes the initial functions and is closed under
composition, primitive recursion, and the least-number operator. Lemma 2.2.6
says that the class of arithmetically deﬁnable functions includes the initial func-
tions. Lemmas 2.2.7, 2.2.8, and 2.2.9 say that the class of arithmetically de-
ﬁnable functions is closed under composition, the least-number operator, and
primitive recursion, respectively.
It follows that the arithmetically deﬁnable
functions include the partial recursive functions.
55

Corollary 2.2.22. There exists a set K ⊆N which is arithmetically deﬁnable
but not recursive.
Proof. Recall that
K = {x ∈N | ϕ(1)
x (x) is convergent}
is our basic example of a non-recursive set.
By the Enumeration Theorem,
the 2-place partial function λxy[ϕ(1)
x (y)] is partial recursive. Hence, by Theo-
rem 2.2.21 λxy[ϕ(1)
x (y)] is arithmetically deﬁnable. Let F(x, y, z) be a formula
which deﬁnes this function. Then K is deﬁned by the formula ∃zF(x, x, z). This
completes the proof.
More generally, recall our discussion of the arithmetical hierarchy in Chap-
ter 1, Section 1.9. The next theorem characterizes arithmetically deﬁnability
(Deﬁnition 2.2.1) in terms of the arithmetical hierarchy (Deﬁnition 1.9.1).
Theorem 2.2.23. Let P be a k-place predicate, P ⊆Nk. The following are
equivalent:
1. P is arithmetically deﬁnable;
2. P belongs to the arithmetical hierarchy, i.e., P belongs to the class Σ0
n for
some n ∈N.
Proof. Theorem 2.2.21 implies that every predicate in the class Σ0
0 (= Π0
0) is
arithmetically deﬁnable. From this it is straightforward to prove by induction
on n ∈N that every predicate in the class Σ0
n ∪Π0
n is arithmetically deﬁnable.
For the converse, put
Σ0
∞
=
[
n∈N
Σ0
n
=
[
n∈N
Π0
n .
By Theorem 1.9.2, the class Σ0
∞is closed under Boolean connectives ∧, ∨, ¬ and
universal and existential quantiﬁcation ∀and ∃. From this it follows that every
arithmetically deﬁnable predicate P belongs to the class Σ0
∞; this is proved by
induction on the number of symbols in a deﬁning formula for P.
Exercise 2.2.24. Let A and B be subsets of N. Prove that if A is reducible to
B and B is arithmetically deﬁnable, then A is arithmetically deﬁnable.
Exercise 2.2.25. For each n ≥1 let Cn be a set which is Σ0
n complete. Consider
the set B = {2n3x | x ∈Cn}. Prove that B is not arithmetically deﬁnable.
Remark 2.2.26 (Hilbert’s Tenth Problem). A reﬁnement of Theorem 2.2.23
due to Matiyasevich 1967 is as follows. Let us say that P ⊆Nk is Diophantine
if P = πl(Q) for some l ≥0 and some strongly Diophantine Q ⊆Nk+l. Thus
P = {⟨a1, . . . , ak⟩∈Nk | ∃⟨b1, . . . , bl⟩∈Nl (f(a1, . . . , ak, b1, . . . , bl) = 0)}
56

where f(x1, . . . , xk, y1, . . . , yl) is a polynomial with integer coeﬃcients. Matiya-
sevich’s Theorem states that P is Diophantine if and only if P is Σ0
1.
A corollary of Matiyasevich’s Theorem is that, for example, the sets K and H
are Diophantine. Thus, we can ﬁnd a polynomial f(z, x1, . . . , xl) with integer
coeﬃcients, such that the set of a ∈N for which f(a, x1, . . . , xl) = 0 has a
solution in N is nonrecursive. Here it is known that one can take l = 9, but
l = 8 is an open question.
Hilbert’s Tenth Problem, as stated in Hilbert’s famous 1900 problem list,
reads as follows:
To ﬁnd an algorithm which allows us, given a polynomial equation in
several variables with integer coeﬃcients, to decide in a ﬁnite number
of steps whether or not the equation has a solution in integers.
From Matiyasevich’s Theorem plus the unsolvability of the Halting Problem, it
follows that there is no such algorithm. In other words, Hilbert’s Tenth Problem
is unsolvable.
A full exposition of Hilbert’s Tenth Problem and the proof of Matiyasevich’s
Theorem is in my lecture notes for Math 574, Spring 2005, at
http://www.math.psu.edu/simpson/notes/.
Exercise 2.2.27. Recall that N = {0, 1, 2, . . .} = the natural numbers, while
Z = {. . . , −2, −1, 0, 1, 2, . . .} = the integers. In our formulation of Matiyase-
vich’s Theorem, we have spoken of solutions in N. What happens if we replace
“solution in N” by “solution in Z”?
Hint: Use the following well-known theorem of Lagrange: For each n ∈N there
exist a, b, c, d ∈N such that n = a2 + b2 + c2 + d2.
2.3
G¨odel Numbers of Formulas
For each formula F in the language of arithmetic, we shall deﬁne a unique
positive integer #(F), which will be called the G¨odel number of F. The number
#(F) will serve as a “code” for the formula F.
Before assigning G¨odel numbers to formulas, we shall ﬁrst assign G¨odel
numbers to terms. We deﬁne
#(0)
=
1
#(1)
=
3
#(xi)
=
32 · 5i
#(t1 + t2)
=
33 · 5#(t1) · 7#(t2)
#(t1 · t2)
=
34 · 5#(t1) · 7#(t2)
For example, the G¨odel number of the term 1 + x0 is
#(1 + x0) = 33 · 53 · 79
57

since #(1) = 3 and #(x0) = 9.
We now deﬁne the G¨odel numbers of formulas:
#(t1 = t2)
=
2 · 5#(t1) · 7#(t2)
#(F ∧G)
=
2 · 3 · 5#(F ) · 7#(G)
#(F ∨G)
=
2 · 32 · 5#(F ) · 7#(G)
#(¬ F)
=
2 · 33 · 5#(F )
#(∀xiF)
=
2 · 34 · 5i · 7#(F )
#(∃xiF)
=
2 · 35 · 5i · 7#(F )
For example, the G¨odel number of the formula ∃x1(x1 = 1) is
#(∃x1(x1 = 1))
=
2 · 35 · 51 · 72·545·73
since #(x1) = 45, #(1) = 3, and #(x1 = 1) = 2 · 545 · 73.
If F is any collection of formulas, we denote by #(F) the collection of all
G¨odel numbers of formulas in F. Let
Fml = #(all formulas) ,
Snt = #(all sentences) ,
and
TrueSnt = #(all true sentences) .
Note that Fml, Snt, and TrueSnt are subsets of N.
Theorem 2.3.1. The sets Fml and Snt are primitive recursive.
Proof. The proof is straightforward and we omit it.
We are going to prove that the set TrueSnt is nonrecursive. In other words,
the problem of deciding whether a given sentence of the language of arithmetic
is true or false is unsolvable. This result may be paraphrased as “arithmetical
truth is undecidable,” or simply, “arithmetic is undecidable.”
Theorem 2.3.2. Every arithmetically deﬁnable set A ⊆N is reducible to
TrueSnt.
Proof. Given an arithmetically deﬁnable set A, let F(x1) be a formula with one
free variable x which deﬁnes A, i.e.,
A
=
{m ∈N | F(m) is true} .
Deﬁne
f(m)
=
#(∃x1(x1 = m ∧F(x1))) .
58

Thus for all m ∈N we have that m ∈A if and only if f(m) ∈TrueSnt. We
claim that the function f : N →N is primitive recursive. This is clear since
f(m) = 2 · 33 · 72·3·5#(x1=m)·7#(F (x1))
where
#(x1 = m) = 2 · 545 · 7#(m) ,
and #(m) = #(1 + . . . + 1
|
{z
}
m
) can be deﬁned primitive recursively by
#(0)
=
1 ,
#(m + 1)
=
33 · 5#(m) · 73 .
Thus A is reducible to TrueSnt via f. This proves the theorem.
Theorem 2.3.3. TrueSnt is not recursive.
Proof. By Corollary 2.2.22 we have an arithmetically deﬁnable set K which is
not recursive. By the previous theorem K is reducible to TrueSnt. Hence by
Lemma 1.7.8 TrueSnt is not recursive.
More generally we have the following theorem, which may be paraphrased
as “arithmetical truth is not arithmetically deﬁnable.”
Theorem 2.3.4 (Tarski). TrueSnt is not arithmetically deﬁnable.
Proof. Suppose that TrueSnt were arithmetically deﬁnable.
Then by Theo-
rem 2.2.23 we would have that TrueSnt belongs to the class Σ0
n for some n.
By Theorem 1.9.18, let C be a complete Σ0
n+1 set. By Theorem 2.2.23 C is
arithmetically deﬁnable. Hence by Theorem 2.3.2 C is reducible to TrueSnt.
Hence by Lemma 1.9.16 C belongs to the class Σ0
n. This contradicts that fact
(Theorem 1.9.18) that a complete Σ0
n+1 set can never belong to the class Σ0
n.
This completes the proof.
Exercise 2.3.5. Prove that the set Fml of all G¨odel numbers of formulas is
primitive recursive.
Exercise 2.3.6. Prove that the set Snt of all G¨odel numbers of sentences is
primitive recursive.
59

Chapter 3
The Real Number System
In Chapter 2 we have shown that TrueSntN is nonrecursive, i.e., the theory of
the natural number system is undecidable. In this Chapter we shall show that,
by contrast, TrueSntR is recursive, i.e., the theory of the real number system is
decidable.
3.1
Quantiﬁer Elimination
Let LOR be the language of ordered rings, i.e.,
LOR = (+, −, ·, 0, 1, <, =)
where + and · are 2-ary operation symbols, −is a 1-ary operation symbol, <
and = are 2-place predicate symbols, and 0 and 1 are constant symbols. We
consider the LOR-structure
R = (R, +R, −R, ·R, 0R, 1R, <R, =R) ,
i.e., the real number system, the ordered ﬁeld of real numbers. Formulas of LOR
are interpreted with reference to R, i.e., ∃x . . . means “there exists x ∈R such
that . . . ,” etc.
Two LOR-formulas F and G are said to be equivalent if they have the same
free variables x1, . . . , xk and deﬁne the same k-place predicate P ⊆Rk. An
equivalent condition is that the sentence
∀x1 · · · ∀xk (F(x1, . . . , xk) ⇔G(x1, . . . , xk))
is true in R.
We are going to prove the following theorem, due originally to Tarski:
Theorem 3.1.1 (Quantiﬁer Elimination). For any LOR-formula F, we can ﬁnd
an equivalent quantiﬁer free LOR-formula F ∗.
60

Example 3.1.2. The formula
∃x (ax2 + bx + c = 0)
is equivalent to the quantiﬁer free formula
(a = 0 ∧b = 0 ∧c = 0) ∨(a = 0 ∧b ̸= 0) ∨(a ̸= 0 ∧b2 −4ac ≥0) .
Exercise 3.1.3. Find quantiﬁer-free formulas in the language +, −, ·, 0, 1, <, =
which are equivalent, over the real number system R, to:
1. ∃x (ax2 + bx + c > 0).
2. ∃x (ax3 + bx2 + cx + d > 0).
3. ∃x (ax4 + bx3 + cx2 + dx + e > 0).
Exercise 3.1.4. Does there exist a constant c such that the following holds?
Given a formula F(x) in the language +, ·, 0, 1, = with exactly one
free variable x, we can ﬁnd a formula F ∗(x) in the same language
which is equivalent to F(x) over the natural number system N, and
which contains at most c quantiﬁers.
Prove your answer.
Remark 3.1.5. The only properties of R that will be used in the proof of
Theorem 3.1.1 are: (1) R is a commutative ordered ﬁeld; and (2) R has the
intermediate value property for polynomials, i.e.,
( x < y ∧p(x) < 0 < p(y) ) ⇒∃z ( x < z < y ∧p(z) = 0 )
for any polynomial p(x) ∈R[x]. An ordered ﬁeld with these properties is called
a real closed ordered ﬁeld. This is related to Hilbert’s 17th Problem.
Remark 3.1.6. The proof of Theorem 3.1.1 which we shall present below is
due to P. J. Cohen. In order to present the proof, we shall deﬁne and study a
class of functions called the eﬀective functions. This notion of eﬀectivity has no
importance beyond the proof of Theorem 3.1.1. See also Corollary 3.1.21 below.
Deﬁnition 3.1.7. A predicate A on the reals, i.e., A ⊆Rk, is said to be ef-
fective if it is deﬁnable over R by a quantiﬁer free formula. That is, A is a
Boolean combination of sets in Rk which are deﬁned by equations and inequa-
tions p(x1, . . . , xk) = 0, p(x1, . . . , xk) > 0, where p ∈Z[x1, . . . , xk].
Remark 3.1.8. If we allow parameters from R, we get semi-algebraic sets.
Thus “eﬀective = semi-algebraic with parameters from Z”.
Deﬁnition 3.1.9. A function f : D →R, D ⊆Rk is said to be eﬀective if
61

1. D is eﬀective, and
2. for every eﬀective predicate A(x1, . . . , xk, y, z1, . . . , zn), the predicate
B(x1, . . . , xk, z1, . . . , zn) ≡A(x1, . . . , xk, f(x1, . . . , xk), z1, . . . , zn)
is eﬀective.
Example 3.1.10. It can be shown that the function √x is eﬀective. This is
because, ﬁrst, the domain of √x is the eﬀective set {x ∈R | x ≥0}, and second,
for instance, √x > 3 ≡x > 9.
In order to prove Theorem 3.1.1, we shall build up a library of eﬀective
functions. We shall use notations such as x and y to abbreviate sequences of
variables such as x1, . . . , xk and y1, . . . , ym.
Lemma 3.1.11. The functions x + y, x · y, −x and x/y are eﬀective.
Proof. For x+y, x·y and −x there is nothing to prove. For x/y, note ﬁrst that
the domain is {(x, y) | y ̸= 0} which is obviously eﬀective. It remains to show
that if A(z, . . .) is an eﬀective predicate then so is A(x/y, . . .). The latter is a
Boolean combination of predicates of the form
an
x
y
n
+ . . . + a1
x
y

+ a0 > 0
and this is equivalent to the atomic formula
anxn + an−1xn−1y + . . . + a1xyn−1 + a0yn > 0 ,
assuming as we may that n is even.
Corollary 3.1.12. Any rational function
f(x1, . . . , xk) ∈Q(x1, . . . , xk)
is eﬀective.
Lemma 3.1.13. The composition of eﬀective functions is eﬀective.
Proof. Consider for instance f(g(x)) where f and g are eﬀective 1-place func-
tions. If D(y) is a quantiﬁer-free formula deﬁning the dom(f), then D(g(x))
deﬁnes the dom(fg), which is therefore eﬀective. If A(y, z) is any eﬀective pred-
icate, then clearly A(f(y), z) is eﬀective, hence A(f(g(x)), z) is eﬀective.
Lemma 3.1.14. The function
sgn(x) =





1
if x > 0
0
if x = 0
−1
if x < 0.
is eﬀective.
62

Proof. Let A(y, z) be an eﬀective predicate. Then A(sgn(x), z) is equivalent to
equivalent to
(x > 0 ∧A(1, z)) ∨(x = 0 ∧A(0, z)) ∨(x < 0 ∧A(−1, z))
which is again eﬀective. This proves the lemma.
More generally we have:
Lemma 3.1.15. If a function f(x) takes only ﬁnitely many values, all integers,
then f(x) is eﬀective if and only if for each j ∈Z, the predicate f(x) = j is
eﬀective.
Proof. If: Let j1, . . . , jn be the ﬁnitely many values. For any eﬀective predicate
A(y, z), the predicate A(f(x), z) is equivalent to
(f(x) = j1 ∧A(j1, z)) ∨· · · ∨(f(x) = jn ∧A(jn, z))
and is therefore eﬀective.
Only if: Trivial.
Lemma 3.1.16 (Deﬁnition by Cases). If two functions f1(x) and f2(x) and a
predicate A(x) are eﬀective, then the function
f(x) =
(
f1(x)
if A(x),
f2(x)
if ¬ A(x)
is eﬀective.
Proof. We must show that, for each eﬀective predicate B(y, z), the predicate
C(x, z) ≡B(f(x), z) is eﬀective. This is so because C(x, z) is equivalent to
(A(x) ∧B(f1(x), z)) ∨(¬ A(x) ∧B(f2(x), z)) .
Since f1(x) and f2(x) and B(y, z) are eﬀective, B(f1(x), z) and B(f2(x), z) are
eﬀective. Since A(x) is eﬀective, it follows that C(x, z) is eﬀective. This proves
the lemma.
The extension of the previous lemma to more than two cases is obvious.
Lemma 3.1.17. A function f(x) is eﬀective if and only if for every positive
integer d ≥1 and every polynomial q(y) ∈R[y] of degree d, sgn(q(f(x))) is an
eﬀective function of x and the d + 1 coeﬃcients of q(y).
Proof. Only if: Trivial, since for instance
sgn(q(f(x))) = 1
≡
q(f(x)) > 0
≡
A(f(x)),
where A(y) is the predicate q(y) > 0.
63

If: We must show that if A(y, z) is eﬀective then A(f(x), z) is eﬀective. Note
that A(y, z) can be viewed as a Boolean combination of atomic predicates of the
form p(y, z) > 0, for various polynomials p(y, z) with coeﬃcients in Z. It suﬃces
to show that the predicates p(f(x), z) > 0 are eﬀective. In order to show this,
write p(y, z) = q(y) ∈Z[z][y] i.e., q(y) is a polynomial in y whose coeﬃcients
are polynomials in z with integer coeﬃcients. Then
p(f(x), z) > 0
≡
sgn(q(f(x))) = 1 .
By assumption sgn(q(f(x))) is an eﬀective function of x and the coﬃcients of
q; hence by composition sgn(q(f(x))) is an eﬀective function of x and z.
The next lemma says that the real roots of a polynomial are eﬀective func-
tions of the coeﬃcients. For example, the quadratic formula
x = −b ±
√
b2 −4ac
2a
shows that the roots of ax2 + bx + c are eﬀective functions of a, b and c.
Lemma 3.1.18 (Main Lemma). Let p(x) = anxn + · · · + a1x + a0 ∈R[x].
Write a = a0, . . . , an. There are n + 1 eﬀective functions ξ1(a), . . . , ξn(a), and
k = k(a) such that
ξ1(a) < · · · < ξk(a)
are all of the real roots of p(x).
Proof. By induction on n. Let
p′(x)
=
nanxn−1 + · · · + 2a2x + a1
be the derivative of p(x). This is of degree ≤n−1. By inductive hypothesis, the
roots of p′(x) are among t1 < · · · < tm, m = n −1, where the ti’s are eﬀective
function of a. Note that p(x) is monotone on each of the open intervals
(−∞, t1) , (t1, t2) , . . . , (tm−1, tm) , (tm, +∞)
So, in each of these intervals, there is at most one root of p(x). In addition the
ti’s could be roots of p(x). Thus the number of roots is determined by sgn(p(ti)),
1 ≤i ≤n −1 and sgn(p′(t1 −1)) and sgn(p′(tn + 1)). We can therefore use
deﬁnition by cases to obtain k(a) as an eﬀective function of a.
It remains to show that the roots themselves are eﬀective functions of a.
Consider for example a root ξ = ξ(a) in the interval (t1, t2) where p(t1) > 0 and
p(t2) < 0. By the previous lemma, it suﬃces to show that, for each d ≥1 and
polynomial q(x) of degree d, sgn(q(ξ)) is eﬀective (as a function of a and the
coeﬃcients of q).
Replacing q(x) by its remainder on division by p(x), we may assume deg(q(x)) <
n. [Details: Long division gives q(x) = p(x) · f(x) + r(x), where deg(r(x)) < n
and the coeﬃcients of r(x) are eﬀective functions of the coeﬃcients of p(x) and
q(x). We can replace q(x) by r(x).]
64

By induction hypothesis, the roots of q(x) can be found eﬀectively. Let the
roots of q(x) be among u1 < · · · < um. Then the sign of q(x) on the m + 1
intervals
(−∞, u1) , (u1, u2) , . . . , (um−1, um) , (um, +∞)
is given by m + 1 eﬀective functions
sgn(q(u1−1)) , sgn

q
u1 + u2
2

, . . . , sgn

q
um−1 + um
2

, sgn(q(um+1)) .
Moreover the position of ξ relative to the ui’s is determined by the positions of t1
and t2 relative to the ui’s and by the sgn(p(ui))’s. Thus we can use deﬁnition by
cases to obtain sgn(q(ξ)) as an eﬀective function. In view of the previous lemma
characterizing eﬀective functions, this shows that ξ is an eﬀective function. The
proof of the Main Lemma is now complete.
Lemma 3.1.19. If A(x1, x2, . . . , xk) is an eﬀective predicate, then the predicate
B(x2, . . . , xk)
≡
∃x1 A(x1, x2, . . . , xk)
is eﬀective.
Proof. The predicate A(x1, x2, . . . , xk) may be viewed as a Boolean combination
of polynomial inequalities of the form pi(x1) > 0, 1 ≤i ≤l, where the coeﬃ-
cients of the pi(x)’s are polynomials in x2, . . . , xk with integer coeﬃcients. By
the Main Lemma, the roots of the pi(x)’s are eﬀective function of x2, . . . , xk. Let
ξ1, . . . , ξm be all of these roots. Hence the pi(x)’s change sign only at ξ1, . . . , ξm.
It follows that
∃x1 A(x1, x2, . . . , xk)
is equivalent to a ﬁnite disjunction
A(η1, x2, . . . , xk) ∨· · · ∨A(ηn, x2, . . . , xk) ,
where η1, . . . , ηn is a list of all the ξi’s and (ξi + ξj)/2’s and ξi ± 1’s. Since the
ηi’s are eﬀective functions of x2, . . . , xk, it follows that the above disjunction is
an eﬀective predicate of x2, . . . , xk. This proves the lemma.
Theorem 3.1.20. Any predicate A ⊆Rk which is deﬁnable over R is eﬀective.
Proof. A ⊆Rk is deﬁned over R by a formula F(x1, . . . , xk) of LOR. Therefore,
it suﬃces to show that any formula F of LOR is equivalent over R to a quantiﬁer
free formula F ∗. We shall prove this by induction on the number of symbols in
F.
If F is quantiﬁer free, we may take F ∗≡F.
If F ≡¬ G, then we may take F ∗≡¬ G∗.
If F ≡G ∧H, then we may take F ∗≡G∗∧H∗.
If F ≡∃x G, let F(y) ≡∃x G(x, y), where y is a list of the free variables
of F.
By the inductive hypothesis, G(x, y) is equivalent to a quantiﬁer-free
formula G∗(x, y). Then G∗(x, y) deﬁnes an eﬀective predicate B(x, y). By the
65

previous lemma, the predicate A(y) ≡∃x B(x, y) is eﬀective, i.e., is deﬁned by
a quantiﬁer free formula F ∗(y). Clearly F is equivalent to F ∗. This completes
the proof.
Corollary 3.1.21. For a predicate A ⊆Rk the following three conditions are
equivalent:
1. A is eﬀective.
2. A is deﬁnable over R.
3. A is deﬁnable over R by a quantiﬁer free formula.
Similarly for functions f : D →R, D ⊆Rk.
Proof. For predicates this follows immediately from Theorem 3.1.20. Consider
now a function f. Note ﬁrst that if f is eﬀective then the predicate y = f(x) is
eﬀective, i.e., deﬁnable by a quantiﬁer free formula. Conversely, suppose that f
is deﬁnable. Then for any eﬀective predicate A(y, z), the predicate A(f(x), z) is
equivalent to the deﬁnable predicate ∃y (y = f(x) ∧A(y, z)), which is therefore
eﬀective in view of what has already been proved. Thus f is eﬀective.
Theorem 3.1.22 (Quantiﬁer Elimination). If a predicate A ⊆Rk is deﬁnable
over R, then it is deﬁnable over R by a quantiﬁer free formula.
Proof. This is merely a restatement of the previous corollary.
Proof of Theorem 3.1.1. Theorem 3.1.1 is a restatement of the previous theo-
rem.
3.2
Decidability of the Real Number System
Theorem 3.2.1. Given a formula F of LOR, there is an algorithm to ﬁnd an
equivalent quantiﬁer free formula F ∗.
Proof. The algorithm can be obtained by tracing back through the proof of
Theorem 3.1.22.
Theorem 3.2.2. Given a sentence S of LOR, there is an algorithm to determine
whether or not R satisﬁes S, i.e., whether S is true in the real number system.
Proof. Given a sentence S, a special case of the previous theorem is that we can
algorithmically compute S∗, an equivalent quantiﬁer free sentence. But then S∗
is a Boolean combination of atomic sentences of the form t1 = t2 and t1 < t2
where t1 and t2 are variable-free terms, for example 1+(0+1) < (1+1)·−(1+0),
and the truth value of such sentences is easily computed. This completes the
proof.
66

Corollary 3.2.3. The set
TrueSntR = {#(S) | S is a sentence ∧S is true in R}
is recursive.
Proof. This follows from the previous Theorem plus Church’s Thesis. Alterna-
tively, we can convert the proof of Theorem 3.1.1 into a rigorous proof that the
function taking #(F) to #(F ∗) is primitive recursive.
Exercise 3.2.4. Recall that N = {0, 1, 2, . . .} = the natural numbers, Z =
{. . . , −2, −1, 0, 1, 2, . . .} = the integers, and R = (−∞, ∞) = the real numbers.
Show that TrueSntN and TrueSntZ are not recursive. (This is in contrast to
the fact that TrueSntR is recursive.)
Theorem 3.2.5. The theory of the ordered ring of real numbers is decidable.
Proof. This is a restatement of the previous corollary.
Corollary 3.2.6. Plane and solid geometry are decidable.
Proof. By the methods of Cartesian analytic geometry, the theory of points,
lines and circles in the plane is interpretable into the theory of the real numbers.
For example, a point is an ordered pair (x, y) where x and y are real numbers.
A line is an ordered quadruple (a, b, u, v) where (u, v) ̸= (0, 0). A point (x, y)
lies on a line (a, b, u, v) if and only if
∃t (x = a + tu ∧y = b + tv) .
Two lines are considered identical if and only if they contain the same points.
A circle is an ordered triple (a, b, r) where r > 0. A point (x, y) lies on a circle
(a, b, r) if and only if (x −a)2 + (y −b)2 = r2. A triangle consists of three
non-collinear points, the vertices of the triangle. Etc., etc.
Similarly for the theory of points, lines, planes, circles, and spheres in space.
Exercise 3.2.7. Write sentences of the language +, −, ·, 0, 1, <, = which, when
interpreted over the real number system, express the following statements of
Euclidean plane geometry.
1. For every two points, there is a unique line passing through them.
2. For every three non-collinear points, there is a unique circle passing through
them.
3. For every line L and circle C, the intersection of L and C consists of at
most two points.
4. Given a line L and a point P, among all points on L there is exactly one
which is at minimum distance from P.
67

5. For every circle C and point P lying on C, there exists one and only one
line L such that L ∩C = P. (I.e., a tangent line.)
6. Every line segment has a unique midpoint.
7. Every angle can be uniquely bisected.
Exercise 3.2.8. Explain in detail how you would translate the following state-
ments of Euclidean plane geometry into sentences of the language +, −, ·, 0, 1, <
, = over the real number system.
1. The three angle bisectors of any triangle meet in a single point.
2. Every angle can be uniquely trisected.
Exercise 3.2.9. Recall that N = {0, 1, 2, . . .} = the natural numbers, Z =
{. . . , −2, −1, 0, 1, 2, . . .} = the integers, and R = (−∞, ∞) = the real numbers.
According to Matiyasevich’s Theorem, we can ﬁnd a polynomial
f(w, x1, . . . , xk)
with integer coeﬃcients, such that the set of a ∈N for which the equation
f(a, x1, . . . , xk) = 0 has a solution in N is noncomputable.
1. Discuss the analogous question in which “solution in N” is replaced by
“solution in Z”.
2. Discuss analogous questions in which “solution in N” is replaced by “so-
lution in R”.
68

Chapter 4
Informal Set Theory
The purpose of this chapter is to develop set theory in an informal, preaxiomatic
way. A good reference for this material is Na¨ıve Set Theory by P. R. Halmos.
4.1
Operations on Sets
Informally, a set is any collection of objects which may be regarded as a com-
pleted totality. We use capital letters X, Y , . . .
to denote sets. If a is any
object and X is any set, we write a ∈X to mean that a belongs to X, and
a /∈X to mean that a does not belong to X. Synonyms for “belongs to” are “is
an element of”, “is a member of”, and “is contained in”.
Since a set is nothing but a collection of elements, the set itself having no
further structure, it follows that two sets are equal if and only if they contain
exactly the same elements. Symbolically,
X = Y
⇔
∀a (a ∈X ⇔a ∈Y ) .
This is known as the principle of extensionality. It can be taken as a deﬁnition
of equality between sets.
If P(a) is any deﬁnite property that an object a may or may not have,
we use the notation {a | P(a)} to denote the set of all objects a which have
property P, if such a set exists. (If such a set exists, it will be unique in view
of extensionality.)
In order to be a set, a collection of objects must be limited in size and
deﬁnite. These requirements are rather vague, but we shall try to give some
explanation of what they entail. Deﬁniteness means that any object a either
belongs or does not belong to the collection, i.e., there is no third possibility.
Limitedness means that the collection is in some sense not too large. The need
for some limitation-of-size requirement will be shown below in connection with
the Russell paradox.
One of the most basic concepts in set theory is that of one set being included
in another. We say that Y is a subset of X, symbolically Y ⊆X, if every element
69

of Y is an element of X, i.e.,
∀a (a ∈Y ⇒a ∈X) .
If P(a) is any deﬁnite property as above, and if X is any set, we can form
a subset Y = {a ∈X | P(a)}, consisting of all elements a of X which have
property P. Thus
∀a(a ∈Y ⇔(a ∈X ∧P(a))) .
Note that any set X is itself a mathematical object and as such can be an
element of another set. Indeed, given a set X, we can form a set
P(X) = {Y | Y ⊆X} ,
called the power set of X, whose elements are all possible subsets of X.
We now prove a theorem which implies that not all deﬁnite collections of
mathematical objects are sets. This means that some limitation-of-size principle
is needed.
Theorem 4.1.1 (Russell Paradox). The collection of all sets is not itself a set.
Proof. Suppose to the contrary that there were a set S consisting of all sets.
Form the subset D consisting of all sets which are not members of themselves.
Symbolically,
D = {X ∈S | X /∈X} .
Then D ∈D if and only if D /∈D, a contradiction. This completes the proof.
The Russell Paradox shows that we cannot form sets with complete freedom.
Nevertheless, a wide variety of sets can be formed. Some examples of sets are ∅
(the empty set, i.e., the unique set which has no elements), {∅} (the one-element
set whose unique element is the empty set), {∅, {∅}}, etc. For any objects a,
b, and c, we can form the set {a, b, c} whose elements are exactly a, b, and c.
The cardinality of this set will be one, two or three depending on which of a,
b, and c are equal to each other. Some examples of inﬁnite sets are N (the
set of natural numbers), R (the set of real numbers), P(N), P(R), P(P(R)),
etc. Another source of examples is subsets deﬁned by properties, for example
{n ∈N | n is prime} and {X ⊆R | X is countably inﬁnite}. Further sets can
be obtained using the set operations discussed below.
Given two objects a and b, there is an object (a, b) called the ordered pair of
a and b. The ordered pair operation is assumed to have the following property:
(a, b) = (a′, b′)
⇔
(a = a′ ∧b = b′) .
Given two sets X and Y , the Cartesian product X × Y is the set of all ordered
pairs (a, b) such that a ∈X and b ∈Y .
For any set X, a function with domain X is a rule f associating to each
object a ∈X a deﬁnite, unique object f(a). In this case we write dom(f) = X
and rng(f) = {f(a) | a ∈X}. The latter is again a set, called the range of F.
70

If f is a function and Z is a set, there is a unique function f↾Z, the restriction
of f to Z, whose domain is dom(f) ∩Z and such that (f↾Z)(a) = f(a) for all
a in its domain.
We write f : X →Y to mean that f is a function, dom(f) = X, and
rng(f) ⊆Y . The set of all such functions is denoted Y X.
Summarizing some of the above points, we have the following binary opera-
tions on sets:
X ∪Y
=
{a | a ∈X ∨a ∈Y }
(union) ,
X ∩Y
=
{a | a ∈X ∧a ∈Y }
(intersection) ,
X \ Y
=
{a | a ∈X ∧a /∈Y }
(diﬀerence) ,
X × Y
=
{(a, b) | a ∈X ∧b ∈Y }
(product) ,
XY
=
{f | f : Y →X}
(exponential) .
By an indexed collection with index set I, we mean simply a function f
whose domain is I. In discussing indexed collections, we use notation such as
f = ⟨ai⟩i∈I where ai = f(i). For example, an ordered n-tuple ⟨a1, . . . , an⟩is
a function whose domain is {1, . . . , n}, and a sequence ⟨an⟩n∈N is a function
whose domain is N.
Given an indexed collection of sets ⟨Xi⟩i∈I, the following operations are
deﬁned.
S
i∈I Xi
=
{a | ∃i ∈I (a ∈Xi)}
(union) ,
T
i∈I Xi
=
{a | ∀i ∈I (a ∈Xi)}
(intersection) ,
Q
i∈I Xi
=
{⟨ai⟩i∈I | ∀i ∈I (ai ∈Xi)}
(product) .
If in the latter operation we take all of the sets Xi to be the same set X, we get
the Cartesian power
Q
i∈I X = XI
which is the same as the previously mentioned exponential.
The Axiom of Choice is the assertion that, for any indexed collection of sets
⟨Xi⟩i∈I, if ∀i ∈I (Xi ̸= ∅) then Q
i∈I Xi ̸= ∅. This implies that it is possible
to choose one element ai ∈Xi for each i ∈I. In the early years of set theory,
there was some controversy about the Axiom of Choice. Nowadays the Axiom of
Choice is accepted as being intuitively obvious, but we shall follow the custom
of indicating which proofs use it.
4.2
Cardinal Numbers
A function f is said to be one-to-one if for all a, a′ ∈dom(f), a ̸= a′ implies
f(a) ̸= f(a′).
Note that in this case there is an inverse function f −1 with
dom(f −1) = rng(f) and rng(f −1) = dom(f), deﬁned by
f −1(b) = a
⇔
f(a) = b .
71

Deﬁnition 4.2.1. If X and Y are sets, we say X is equinumerous with Y ,
written X ≈Y , if there exists a one-to-one correspondence between X and Y ,
i.e., a one-to-one function f with dom(f) = X and rng(f) = Y .
Lemma 4.2.2.
1. X ≈X.
2. X ≈Y if and only if Y ≈X.
3. X ≈Y and Y ≈Z imply X ≈Z.
Proof. Straightforward.
Because of the preceding lemma, we can associate to any set X an object
card(X), the cardinality or cardinal number of X, in such a way that
X ≈Y
⇔
card(X) = card(Y ) .
If X is ﬁnite, we take card(X) to be the number of elements in X. For inﬁnite
sets X, it is not important at this stage what sort of object the cardinal number
card(X) is, so long as the above property holds. We use Greek letters κ, λ, µ,
ν, . . . to denote cardinal numbers.
Deﬁnition 4.2.3. We write X ≼Y to mean that X ≈X1 for some X1 ⊆Y .
Lemma 4.2.4.
1. If X ≈X′ and Y ≈Y ′, then X ≼Y if and only if X′ ≼Y ′.
2. X ≼X.
3. X ≼Y and Y ≼Z imply X ≼Z.
4. X ≼Y and Y ≼X imply X ≈Y .
5. For all sets X and Y , either X ≼Y or Y ≼X.
Proof. Parts 1, 2, and 3 are straightforward.
Parts 4 and 5 will be proved
later, as consequences of the Well-Ordering Theorem. Part 4 is known as the
Cantor-Schroeder-Bernstein Theorem.
We can now make the following deﬁnition for cardinal numbers: κ ≤λ if and
only if X ≼Y where κ = card(X) and λ = card(Y ). This does not depend on
the choice of X and Y , as noted in part 1 of Lemma 4.2.4. The rest of Lemma
4.2.4 implies that ≤is a linear ordering of the cardinal numbers, i.e., we have:
1. κ ≤κ.
2. (κ ≤λ ∧λ ≤µ) ⇒κ ≤µ.
3. (κ ≤λ ∧λ ≤κ) ⇒κ = λ.
72

4. ∀κ ∀λ (κ ≤λ ∨λ ≤κ).
Deﬁnition 4.2.5 (Cardinal Arithmetic). For cardinal numbers κ = card(X)
and λ = card(Y ), we deﬁne
1. κ + λ = card(X ∪Y ).
2. κ · λ = card(X × Y ).
3. κλ = card(XY ).
(In the deﬁnition of κ + λ, it is assumed that X ∩Y = ∅.)
For example, 2κ = card(P(X)) where κ = card(X).
Theorem 4.2.6. For cardinal numbers κ, λ, and µ, we have
1. κ + λ = λ + κ.
2. (κ + λ) + µ = κ + (λ + µ).
3. κ · λ = λ · κ.
4. (κ · λ) · µ = κ · (λ · µ).
5. κ · (λ + µ) = κ · λ + κ · µ.
6. κλ+µ = κλ · κµ.
7. κλ·µ = (κλ)µ.
8. κ + 0 = κ, κ · 0 = 0, κ · 1 = κ.
Proof. Straightforward.
Later we shall prove that, for inﬁnite cardinal numbers κ and λ,
κ + λ
=
κ · λ
=
max(κ, λ) .
Theorem 4.2.7 (Cantor’s Theorem). For any cardinal number κ, we have
2κ > κ. In other words, for any set X, we have X ≼P(X) and P(X) ̸≼X.
Proof. We have X ≼P(X) via the one-to-one function f : X →P(X) where
f(a) = {a}.
Suppose now that P(X) ≼X holds.
Let g : P(X) →X be
one-to-one. Put
D = {a ∈X | a ∈rng(g) ∧a /∈g−1(a)} .
Then g(D) ∈D if and only if g(D) /∈D, a contradiction.
73

Exercise 4.2.8. Deﬁne ℵ0 = card(N). Without using the Cantor-Schroeder-
Bernstein Theorem, prove that
ℵ0 = card(Z) = card(Q)
and
2ℵ0 = card(R) = card(C) = card([0, 1]) = card([0, 1] × [0, 1]).
Deﬁnition 4.2.9. If ⟨κi⟩i∈I is an indexed set of cardinal numbers, we deﬁne
1. P
i∈I κi = card(S
i∈I Xi)
2. Q
i∈I κi = card(Q
i∈I Xi)
where κi = card(Xi). In the deﬁnition of P
i∈I κi, it is assumed that Xi∩Xj = ∅
for all i, j ∈I with i ̸= j.
Exercise 4.2.10 (K¨onig’s Theorem). Suppose that ⟨κi⟩i∈I and ⟨λi⟩i∈I are in-
dexed sets of cardinal numbers with the same index set I. Show that if κi < λi
for all i ∈I, then
X
i∈I
κi <
Y
i∈I
λi .
Remark 4.2.11. Cantor’s Theorem may be viewed as the special case of
K¨onig’s Theorem with κi = 1 and λi = 2.
The Axiom of Choice may be
viewed as the special case of K¨onig’s Theorem with κi = 0 and λi > 0.
4.3
Well-Orderings and Ordinal Numbers
Deﬁnition 4.3.1. Given a set A, a relation on A is a set R ⊆A × A.
A
relational structure is an ordered pair (A, R) where A is a set and R ⊆A × A.
We sometimes write aRa′ instead of (a, a′) ∈R.
Deﬁnition 4.3.2. Given two relational structures (A, R) and (B, S), an isomor-
phism from (A, R) to (B, S) is a one-to-one function f such that dom(f) = A,
rng(f) = B, and
aRa′
⇔
f(a)Sf(a′)
for all a, a′ ∈A.
We say that (A, R) is isomorphic to (B, S), symbolically
(A, R) ∼= (B, S), if there exists an isomorphism from (A, R) to (B, S).
Lemma 4.3.3.
1. (A, R) ∼= (A, R).
2. (A, R) ∼= (B, S) if and only if (B, S) ∼= (A, R).
3. (A, R) ∼= (B, S) and (B, S) ∼= (C, T ) imply (A, R) ∼= (C, T ).
74

Proof. Straightforward.
Because of the preceding lemma, we can associate to any relational structure
(A, R) a mathematical object type(A, R), the isomorphism type of (A, R), in
such a way that
(A, R) ∼= (B, S)
⇔
type(A, R) = type(B, S) .
It is not important at this stage exactly what sort of mathematical object
type(A, R) is, so long as the above property holds.
Deﬁnition 4.3.4. A relational structure (A, R) is said to be well-founded if for
every nonempty set X ⊆A, there exists a ∈X such that there is no b ∈X with
bRa. Such an a might be called an R-minimal element of X.
Lemma 4.3.5. A relational structure (A, R) is well-founded if and only if there
is no inﬁnite descending R-sequence. (By an inﬁnite descending R-sequence we
mean a sequence ⟨an⟩n∈N such that an+1Ran for all n ∈N.)
Proof. If ⟨an⟩n∈N is an inﬁnite descending R-sequence, then X = {an | n ∈N}
is a counterexample to well-foundedness of (A, R). Conversely, suppose that
X ⊆A is a counterexample to well-foundedness. Then we have X ̸= ∅and
∀a ∈X ∃b ∈X bRa. By the Axiom of Choice, there is a function f : X →X
such that f(a)Ra for all a ∈X. Pick an element a0 ∈X and deﬁne ⟨an⟩n∈N
recursively by putting an+1 = f(an) for all n ∈N. This is an inﬁnite descending
R-sequence. The lemma is proved.
Deﬁnition 4.3.6. A linear ordering is a relational structure (A, R) with the
following properties: aRb and bRc imply aRc; and for all a, b ∈A exactly one of
aRb, a = b, bRa hold. A well-ordering is a linear ordering which is well-founded.
Note that if (A, R) is a well-ordering and X is a nonempty subset of A, then
X has an R-least element, i.e., there is a unique a ∈X such that aRb holds for
all b ∈X, b ̸= a.
Deﬁnition 4.3.7. An ordinal number is the isomorphism type of a well-ordering.
For n ∈N, we identify n with the ordinal number which is the order type of
all n-element well-orderings. Another important ordinal number is ω, the order
type of N itself (more precisely of (N, <) = (N, {(m, n) ∈N × N | m < n})).
The following deﬁnition and exercise show how to generate further examples of
ordinal numbers.
Deﬁnition 4.3.8. Let α = type(A, R) and β = type(B, S) be ordinal numbers.
We deﬁne
1. α + β = type(A ∪B, R ∪S ∪(A × B)). Here we assume that A ∩B = ∅.
2. α · β = type(A × B, {((a, b), (a′, b′)) | bSb′ ∨(b = b′ ∧aRa′)}).
75

Thus we have operations of ordinal addition, α + β, and ordinal multiplication,
α · β. (Later we shall deﬁne an analogous operation of ordinal exponentiation,
αβ.) Note that the commutative laws fail, for example 1 + ω = ω ̸= ω + 1 and
2 · ω = ω ̸= ω · 2 = ω + ω. However, we have the following properties.
Exercise 4.3.9. Prove the following laws of ordinal arithmetic.
1. (α + β) + γ = α + (β + γ).
2. (α · β) · γ = α · (β · γ).
3. α · (β + γ) = α · β + α · γ.
4. α + 0 = 0 + α = α, α · 0 = 0 · α = 0, α · 1 = 1 · α = α.
Give an example showing the failure of (α + β) · γ = α · γ + β · γ.
Deﬁnition 4.3.10. If (A, R) is a linear ordering, an initial segment of (A, R)
is any subset of A of the form {b | bRa}, where a ∈A. Note that
({b | bRa}, {(c, b) | cRb ∧bRa})
is again a linear ordering, and we sometimes identify the initial segment with
this ordering.
Theorem 4.3.11 (Comparability of Well-Orderings). Let (A, R) and (B, S) be
well-orderings. Then exactly one of the following holds.
1. (A, R) ∼= (B, S);
2. (A, R) ∼= some initial segment of (B, S);
3. (B, S) ∼= some initial segment of (A, R).
Moreover, in each case, the isomorphism is unique.
Proof. We ﬁrst prove that the isomorphism is unique. Suppose for instance that
f1 and f2 are two diﬀerent isomorphisms from (A, R) to (B, S) or to some initial
segment of (B, S). Then {a ∈A | f1(a) ̸= f2(a)} is a nonempty subset of A, so
let a be its R-least element. Then f1(a′) = f2(a′) for all a′Ra but f1(a) ̸= f2(a),
say f1(a)Sf2(a). Then f1(a) /∈rng(f2), contradicting the fact that rng(f2) is B
or an initial segment of B with respect to S.
Now let f be a function with dom(f) ⊆A and rng(f) ⊆B, deﬁned by
putting f(a) = the unique b ∈B such that
({a′ | a′Ra}, {(a′′, a′) | a′′Ra′ ∧a′Ra}) ∼= ({b′ | b′Sb}, {(b′′, b′) | b′′Sb′ ∧b′Sb}) ,
provided such a b exists. If for a given a ∈A no such b exists, f(a) is undeﬁned.
If b exists, its uniqueness follows from what we have already proved. It is clear
that a′Ra and a ∈dom(f) imply a′ ∈dom(f), and b′Rb and b ∈rng(f) imply
b′ ∈rng(f).
76

We claim that dom(f) = A or rng(f) = B or both. If not, let a be the
R-least element of A \ dom(f), and let b be the S-least element of B \ rng(f).
Then f is an isomorphism from ({a′ | a′Ra}, {(a′′, a′) | a′′Ra′ ∧a′Ra}) to ({b′ |
b′Sb}, {(b′′, b′) | b′′Sb′ ∧b′Sb}). This implies that a ∈dom(f), a contradiction.
The claim is proved.
If both dom(f) = A and rng(f) = B, then we have (A, R) ∼= (B, S). If
dom(f) ̸= A, then letting a be the R-least element of A \ dom(f), we see that
f is an isomorphism from ({a′ | a′Ra}, {(a′′, a′) | a′′Ra′ ∧a′Ra}) to (B, S). If
rng(f) ̸= B, then letting b be the S-least element of B \ rng(f), we see that
f is an isomorphism from (A, R) to ({b′ | b′Sb}, {(b′′, b′) | b′′Sb′ ∧b′Sb}). This
completes the proof of the theorem.
Deﬁnition 4.3.12. For ordinal numbers α and β, we deﬁne α < β to mean
that (A, R) ∼= some initial segment of (B, S), where α = type(A, R) and β =
type(B, S). We deﬁne α ≤β to mean α < β ∨α = β.
Lemma 4.3.13. For all ordinal numbers α and β, exactly one of α < β, α = β,
and β < α holds. Moreover α < β and β < γ imply α < γ.
Proof. The ﬁrst part follows from comparability of well-orderings. The second
part is straightforward.
Exercise 4.3.14. For ordinal numbers α, β, γ, prove that α < β if and only if
α + γ = β for some γ > 0.
Lemma 4.3.15. If (A, R) is a well-ordering and B ⊆A, then (B, R ∩(B × B))
is a well-ordering, and
type(B, R ∩(B × B)) ≤type(A, R) .
Proof. Straightforward, using comparability of well-orderings.
The next theorem implies that any well-ordering is isomorphic to an initial
segment of the ordinal numbers.
Theorem 4.3.16. For any ordinal number α, the relational structure
({β | β < α}, {(γ, β) | γ < β < α})
is a well-ordering of type α.
Proof. Let (A, R) be some ﬁxed well-ordering of type α. Deﬁne f : A →{β |
β < α} by
f(b) = type({c ∈A | cRb}, {(d, c) | dRc ∧cRb}) .
It is straightforward to verify that f is an isomorphism from (A, R) onto
({β | β < α}, {(γ, β) | γ < β < α}) .
This proves the theorem.
77

Corollary 4.3.17. For any ordinal number α, there is a set {β | β < α}
consisting of all smaller ordinal numbers.
Proof. This follows from the previous theorem.
Lemma 4.3.18. Let X be a set of ordinal numbers. Then there is an ordinal
number γ = sup X which is the least upper bound of X under <, i.e., ∀α (α ∈
X ⇒α ≤γ) and ∀β (β < γ ⇒∃α (α ∈X ∧β < α)).
Proof. Put
A = {α | ∃β (β ∈X ∧α < β)} =
[
β∈X
{α | α < β} .
It is straightforward to verify that
(A, {(α, β) ∈A × A | α < β})
is a well-ordering. Let γ be the type of this well-ordering. It is straightforward
to verify that A = {α | α < γ} and that γ = sup X.
Exercise 4.3.19. If α is an ordinal number and X is a nonempty set of ordinal
numbers, show that α+sup X = sup{α+β | β ∈X} and α·sup X = sup{α·β |
β ∈X}.
Lemma 4.3.20. Let X be a nonempty set of ordinal numbers. Then X has a
smallest element under <.
Proof. Put α = sup X. Then X is a nonempty subset of {β | β ≤α}. The latter
set of ordinal numbers is well-ordered under <, hence X has a least element.
Theorem 4.3.21 (Burali-Forti Paradox). The class Ord of all ordinal numbers
is not a set.
Proof. If Ord were a set, then by the above lemmas, (Ord, <) would be a well-
ordering. Letting α be the type of this well-ordering, we see that (Ord, <) would
be isomorphic to an initial segment of itself, namely ({β | β < α}, {(γ, β) | γ <
β < α}). This contradiction completes the proof.
4.4
Transﬁnite Recursion
By a class we mean a collection of objects which is not necessarily a set. Every
set is a class, but not every class is a set. Examples of classes which are not sets
are Set = {X | X is a set} and Ord = {α | α is an ordinal}. These classes are
“too big” to be sets. We have seen this in connection with the Russell Paradox
and the Burali-Forti Paradox.
If C is a class, then by a function with domain C we mean a rule F which
associates to each element a of C a uniquely deﬁned object F(a). For example,
although the class Ord of all ordinal numbers is not a set, we shall be interested
in functions with domain Ord. The next theorem gives us a powerful method
for deﬁning such functions.
78

Theorem 4.4.1 (Transﬁnite Recursion). Let F be the class of all functions
whose domain is an initial segment of Ord. Suppose that G is a function with
domain F. Then there is a unique function F with domain Ord such that, for
all ordinal numbers α,
F(α) = G(F↾{β | β < α}) .
Proof. Let us say that f ∈F is good if for all β ∈dom(f), f(β) = G(f↾{γ |
γ < β}). We claim that for all ordinal numbers α, there is at most one good f
with dom(f) = {β | β < α}. If not, let f1 ̸= f2 be two such f’s. Let γ be the
smallest β < α such that f1(β) ̸= f2(β). Then f1↾{β | β < γ} = f2↾{β | β < γ},
hence
f1(γ) = G(f1↾{β | β < γ}) = G(f2↾{β | β < γ}) = f2(γ) ,
a contradiction.
Using the above claim, let fα be the unique good f with dom(f) = {β |
β < α}, if it exists. We claim that fα exists for all α. If not, let α be the
smallest counterexample. Then fβ exists for all β < α, and it is easy to check
that {(β, G(fβ)) | β < α} is good. This contradicts the choice of α. Thus fα
exists for all α. Deﬁne F by putting F(α) = G(fα) for all α. It is easy to check
that F↾{β | β < α} = fα and that F satisﬁes the desired conclusions. This
completes the proof.
As an example of transﬁnite recursion, we deﬁne the following operations of
ordinal arithmetic.
Deﬁnition 4.4.2.
1. α + β = sup{α, (α + γ) + 1 | γ < β}.
2. α · β = sup{(α · γ) + α | γ < β}.
3. αβ = sup{1, αγ · α | γ < β} (assuming α > 0).
Exercise 4.4.3. Show that parts 1 and 2 of Deﬁnition 4.4.2 agree with parts 1
and 2 of Deﬁnition 4.3.8. In the next exercise we show how to extend Deﬁnition
4.3.8 to encompass part 3 of Deﬁnition 4.4.2.
Exercise 4.4.4. Let α = type(A, R) and β = type(B, S) be ordinal numbers.
Show that αβ = type(C, T ) where C is the set of all f : B →A such that, for
all but ﬁnitely many b ∈B, f(b) = a0, where a0 is the R-least element of A.
Here T is the set of all (f1, f2) ∈C × C such that f1(b′)Rf2(b′), where b′ is the
S-greatest b ∈B such that f1(b) ̸= f2(b).
Exercise 4.4.5. If α is an ordinal number and X is a nonempty set of ordinal
numbers, show that
1. α + sup X = sup{α + β | β ∈X},
79

2. α · sup X = sup{α · β | β ∈X}, and
3. αsup X = sup{αβ | β ∈X}.
Exercise 4.4.6. For ordinal numbers α, β, and γ, show that
1. (α + β) + γ = α + (β + γ).
2. (α · β) · γ = α · (β · γ).
3. α · (β + γ) = α · β + α · γ.
4. αβ+γ = αβ · αγ.
5. αβ·γ = (αβ)γ.
6. α + 0 = 0 + α = α, α · 0 = 0 · α = 0, α · 1 = 1 · α = α.
7. α0 = 1.
8. 0α = 0 provided α > 0.
9. α1 = α, 1α = 1.
Exercise 4.4.7. Show that β < γ implies the following:
1. α + β < α + γ;
2. α · β < α · γ provided α > 0;
3. αβ < αγ provided α > 1.
Deﬁnition 4.4.8. A successor ordinal is an ordinal number of the form α + 1.
A limit ordinal is an ordinal number δ such that δ > 0 and α + 1 < δ for all
α < δ. Examples of limit ordinals are ω and ω · 2.
Exercise 4.4.9. Show that α + 1 is the smallest ordinal number β > α. Show
that every ordinal number is either 0, a successor ordinal, or a limit ordinal.
Show that δ > 0 is a limit ordinal if and only if δ = sup{α | α < δ}. Show that
δ > 0 is a limit ordinal if and only if δ = ω · α for some α > 0.
Exercise 4.4.10. Show that the operations of ordinal arithmetic could have
been deﬁned by transﬁnite recursion as follows (letting δ denote a limit ordinal):
1. α + 0 = α, α + (β + 1) = (α + β) + 1, α + δ = sup{α + β | β < δ}.
2. α · 0 = 0, α · (β + 1) = (α · β) + α, α · δ = sup{α · β | β < δ}.
3. α0 = 1, αβ+1 = (αβ) · α, αδ = sup{αβ | β < δ} (assuming α > 0).
Exercise 4.4.11. For an ordinal number δ > 0, show that the following are
equivalent.
1. α + δ = δ for all α < δ.
80

2. α + β < δ for all α, β < δ.
3. δ = ωα for some α ≤δ.
An ordinal number with these properties is said to be additively indecomposable.
Exercise 4.4.12. Show that for any ordinal number α, there is one and only
one way to write α in the form α = α1 + · · · + αn where α1 ≥· · · ≥αn > 0 are
additively indecomposable, and n ∈N.
4.5
Cardinal Numbers, Continued
Lemma 4.5.1. Given a set X, there exists a choice function for X, i.e., a
function
c : P(X) \ {∅} →X
such that c(Y ) ∈Y for all Y ⊆X, Y ̸= ∅.
Proof. Consider the indexed set of sets ⟨Xi⟩i∈I, where I = P(X) \ {∅} and
Xi = i for all i ∈I. By the Axiom of Choice, Q
i∈I Xi is nonempty, i.e., there
exists ⟨ai⟩i∈I such that ai ∈Xi for all i ∈I. Putting c(i) = ai we obtain our
choice function.
Theorem 4.5.2 (Well-Ordering Theorem). Given a set X, we can ﬁnd a rela-
tion R ⊆X × X such that (X, R) is a well-ordering.
Proof. We shall prove the theorem in the following equivalent formulation: For
any set X, there exists an ordinal number α such that X ≈{β | β < α}.
(Neither α nor the one-to-one function from X onto {β | β < α} is asserted to
be unique.)
Fix a choice function c for X.
Fix an object a0 such that a0 /∈X. By
transﬁnite recursion, deﬁne
F(α) =
( c(X \ rng(F↾{β | β < α})),
if X \ rng(F↾{β | β < α}) ̸= ∅
a0
otherwise.
We claim that F(α) = a0 for some α. If not, we would have F(α) ∈X for
all α, and F(α) ̸= F(β) for all α ̸= β. Form the set
Y = rng(F) = {a ∈X | ∃α(F(α) = a)} .
Then F −1 is a function with domain Y , and we have rng(F −1) = Ord, hence
Ord is a set. This contradiction proves the claim.
Let α be the smallest ordinal number such that F(α) = a0. Then F↾{β |
β < α} is one-to-one, and rng(F↾{β | β < α}) = X. Thus {β | β < α} ≈X.
Our theorem is proved.
81

Remark 4.5.3. The previous theorem shows that the Axiom of Choice implies
the Well-Ordering Theorem. There is also a converse: the Well-Ordering Theo-
rem implies the Axiom of Choice. To see this, suppose we have an indexed set
of nonempty sets ⟨Xi⟩i∈I. Put A = S
i∈I Xi. By the Well-Ordering Theorem,
there exists R ⊆A × A such that (A, R) is a well-ordering. Deﬁne ⟨ai⟩i∈I by
putting ai = the R-least element of Xi. Thus ⟨ai⟩i∈I ∈Q
i∈I Xi and we have
proved the Axiom of Choice from the Well-Ordering theorem.
Exercise 4.5.4. Let X be a set of sets. By a chain within X we mean a set
C ⊆X such that for all U, V ∈C either U ⊆V or V ⊆U. A chain within X is
said to be maximal if it is not properly included in any other chain within X.
Use the Axiom of Choice plus transﬁnite recursion to prove that there exists
a maximal chain within X.
Note: This is a version of Zorn’s Lemma.
Deﬁnition 4.5.5. An initial ordinal is an ordinal number α such that, for all
β < α,
{γ | γ < α} ̸≈{γ | γ < β} .
The ﬁnite ordinal numbers 0, 1, 2, . . .
are initial ordinals, as is the ﬁrst
inﬁnite ordinal number ω. But it is easy to see that ordinal numbers such as
ω + 1, ω + 2, . . . , ω · 2, ω · 2 + 1, . . . are not initial ordinals. Another simple
fact worth noting is that every inﬁnite initial ordinal is a limit ordinal.
Deﬁnition 4.5.6. For any set X, we deﬁne |X| to be the smallest ordinal
number α such that X ≈{β | β < α}. (The existence of such an ordinal is a
consequence of the Well-Ordering Theorem.) Clearly |X| is an initial ordinal.
In fact, |X| is the unique initial ordinal such that X ≈{β | β < α}.
Lemma 4.5.7. If X ⊆{β | β < α}, then |X| ≤α.
Proof. Immediate from Lemma 4.3.15.
Theorem 4.5.8. For all sets X and Y we have
X ≈Y
if and only if |X| = |Y | ,
and
X ≼Y
if and only if |X| ≤|Y | .
Proof. The ﬁrst equivalence is obvious, as is the fact that |X| ≤|Y | implies
X ≼Y . Suppose now that X ≼Y . Then X ≈Z for some Z ⊆{β | β < |Y |}.
By the previous lemma it follows that |X| = |Z| ≤|Y |. This completes the
proof.
Remark 4.5.9. By the previous theorem, we have card(X) = card(Y ) if and
only if |X| = |Y |, and card(X) < card(Y ) if and only if |X| < |Y |. Thus we may
identify cardinal numbers with initial ordinals.
From now on we shall make
this identiﬁcation, writing card(X) = |X|.
For instance, the ﬁnite cardinal
numbers are now identiﬁed with the ﬁnite ordinal numbers, and the smallest
inﬁnite cardinal number is the same as the ordinal number ω.
82

Theorem 4.5.10.
1. If X ≼Y and Y ≼X, then X ≈Y .
2. For all sets X and Y , either X ≼Y or Y ≼X.
Proof. Both parts follow from the previous theorem plus the fact that |X| and
|Y | are ordinal numbers, hence exactly one of |X| < |Y |, |X| = |Y |, |Y | < |X|
holds.
4.6
Cardinal Arithmetic
We now present some basic results about the arithmetic of inﬁnite cardinal
numbers. Most of these results are easy consequences of the following lemma.
Lemma 4.6.1. For inﬁnite cardinals κ, we have κ · κ = κ.
Proof. If not, let κ be the smallest counterexample. Note that κ is an inﬁnite
initial ordinal, and λ · λ < κ for all λ < κ.
Put A = {α | α < κ} and R = {(α′, α) | α′ < α < κ}. Thus (A, R) is a
well-ordering of type κ. Note that |A| = κ but every initial segment I of (A, R)
has |I| < κ.
Put B = A × A and deﬁne S ⊆B × B by
(α′, β′)S(α, β)
if and only if
max(α′, β′) < max(α, β) ∨
(max(α′, β′) = max(α, β) ∧α′ < α) ∨
(max(α′, β′) = max(α, β) ∧α′ = α ∧β′ < β) .
It is straightforward to verify that (B, S) is a well-ordering.
If J ⊆B is any initial segment of (B, S), we have J ⊆I × I where I is
an appropriately chosen initial segment of (A, R). Thus every initial segment
of (B, S) has cardinality < κ. Hence (A, R) cannot be isomorphic to an initial
segment of (B, S). From comparability of well-orderings, it follows that (B, S)
is isomorphic to (A, R). In particular B ≈A. In other words, A×A ≈A, hence
κ · κ = κ. This completes the proof.
Theorem 4.6.2. For inﬁnite cardinals κ and λ, we have
κ + λ = κ · λ = max(κ, λ) .
Proof. Put µ = max(κ, λ). Then by the previous lemma we have
µ ≤κ + λ ≤µ + µ = 2 · µ ≤µ · µ = µ
and
µ ≤κ · λ ≤µ · µ = µ .
This proves the theorem.
83

Theorem 4.6.3. For λ inﬁnite and 2 ≤κ ≤2λ, we have κλ = 2λ.
Proof. 2λ ≤κλ ≤(2λ)λ = 2λ·λ = 2λ.
For any set X, let X∗be the set of ﬁnite sequences of elements of X, i.e.,
X∗= {⟨ai⟩i<n | n < ω, ai ∈X for all i < n} .
Theorem 4.6.4. For any inﬁnite set X, we have |X∗| = |X|.
Proof. Putting κ = |X|, we have κ2 = κ · κ = κ and it is easy to prove by
induction on n that κn = κ for all n ≥1, n < ω. Hence we have
|X∗| =
X
n<ω
κn = ω · κ = κ .
This proves the theorem.
Deﬁnition 4.6.5. For any ordinal β we deﬁne β+ = the smallest initial ordinal
κ > β. To each ordinal number α we associate an inﬁnite initial ordinal ωα as
follows, by transﬁnite recursion:
1. ω0 = ω,
2. ωα+1 = ω+
α ,
3. ωδ = supα<δ ωα for limit ordinals δ.
Remark 4.6.6. It is easy to see that ⟨ωα⟩α∈Ord is a strictly increasing enumer-
ation of all the inﬁnite initial ordinals, i.e., the inﬁnite cardinals. It follows that
the class Card = {κ | κ is an inﬁnite cardinal} is not a set.
Exercise 4.6.7. Prove that there exist arbitrarily large ordinals α such that
α = ωα.
Remark 4.6.8. Although cardinals are now the same thing as initial ordinals,
the notation ℵα = ωα is sometimes used in order to maintain a notational
distinction between cardinals and initial ordinals. ℵα is taken to be a cardinal,
while ωα is an initial ordinal. For example, even though ℵ0 is the same thing
as ω, ℵ0 is thought of as the cardinality of the set of natural numbers, while ω
is thought of as the order type of the natural numbers under <.
Theorem 4.6.9. Let N, Q, and R be the set of natural numbers, the rational
numbers, and the real numbers respectively. The cardinalities of these sets are
given by |N| = |Q| = ℵ0, |R| = 2ℵ0.
Proof. The fact that |N| = ℵ0 is obvious. Since N ⊆Q and each rational number
q ∈Q is of the form q = ±m/n for some (m, n) ∈N × N, we have
|N| ≤|Q| ≤2 · |N| · |N| = |N|
so |Q| = |N| = ℵ0. For the real numbers, note ﬁrst that P(N) ≼R via the
function which sends X ⊆N to P
n∈X 2/3n. Hence 2ℵ0 ≤|R|. On the other
hand, R ≼P(Q) ≈P(N) via the function which sends x ∈R to {q ∈Q | q < x}.
Thus |R| = 2ℵ0.
84

Exercise 4.6.10. Prove that |RN| = 2ℵ0 and |RR| = 22ℵ0 .
The most important problem of inﬁnite cardinal arithmetic is the Continuum
Problem: What is the cardinality of R? Equivalently, what is the ordinal number
β such that 2ℵ0 = ℵβ? By Cantor’s Theorem we have 2ℵ0 ≥ℵ1. The assertion
that 2ℵ0 = ℵ1 is known as the Continuum Hypothesis, or CH.
More generally, for any inﬁnite cardinal κ, Cantor’s Theorem tells us that
2κ ≥κ+, and we can ask whether 2κ = κ+. The assertion that 2κ = κ+ for
all inﬁnite cardinals κ (equivalently, 2ℵα = ℵα+1 for all ordinal numbers α) is
known as the Generalized Continuum Hypothesis, or GCH.
Exercise 4.6.11. Prove that 2ℵ0 ̸= ℵω. (Hint: Use K¨onig’s Theorem.)
4.7
Some Classes of Cardinals
A cardinal is said to be uncountable if it is > ℵ0. In this section we introduce
some important classes of uncountable cardinals.
Deﬁnition 4.7.1. Let λ be an uncountable cardinal. We say that λ is a suc-
cessor cardinal if λ = κ+ for some κ < λ. We say that λ is a limit cardinal if
κ+ < λ for all κ < λ. We say that λ is a strong limit cardinal if 2κ < λ for all
κ < λ.
Note that λ is a successor cardinal if and only if λ = ℵα+1 for some successor
ordinal α + 1, and λ is a limit cardinal if and only if λ = ℵδ for some limit
ordinal δ. The ﬁrst few uncountable successor cardinals are ℵ1, ℵ2, . . . . The
ﬁrst uncountable limit cardinal is ℵω. Clearly every strong limit cardinal is a
limit cardinal, and the GCH implies that every limit cardinal is a strong limit
cardinal.
Lemma 4.7.2. Every uncountable cardinal is either a successor cardinal or a
limit cardinal, and exactly one of these possibilities holds.
Proof. Obvious.
Deﬁnition 4.7.3. An inﬁnite cardinal λ is said to be regular if it is not the sum
of fewer than λ cardinals each less than λ. In other words, for any indexed set
of cardinals ⟨κi⟩i∈I with |I| < λ and κi < λ for all i ∈I, we have P
i∈I κi < λ.
Trivially ℵ0 is regular, since it is not the sum of a ﬁnite set of ﬁnite cardinals.
Theorem 4.7.4. Every uncountable successor cardinal is regular.
Proof. Let λ be an uncountable successor cardinal. Thus λ = κ+ where κ is an
inﬁnite cardinal. Given an indexed set of cardinals ⟨κi⟩i∈I, we see that κi < λ
implies κi ≤κ, also |I| < λ implies |I| ≤κ, hence
X
i∈I
κi ≤
X
i∈I
κ = |I| · κ ≤κ · κ = κ < λ.
This shows that λ is regular.
85

In particular ℵ1, ℵ2, . . . are regular. An inﬁnite cardinal is said to be sin-
gular if it is not regular. The ﬁrst singular cardinal is ℵω, since ℵω = P
n∈N ℵn.
Exercise 4.7.5. Let α be an ordinal number which is > ω. Show that α is
a regular cardinal (i.e., a regular initial ordinal) if and only if, for every set of
ordinal numbers X with sup X = α, we have type(X) = α.
Deﬁnition 4.7.6. Let λ be an uncountable cardinal.
The coﬁnality of λ,
written cf(λ), is the smallest cardinal κ such that λ = P
i∈I λi for some indexed
set of cardinals λi < λ, i ∈I, with |I| = κ.
Exercise 4.7.7. Prove the following facts.
1. cf(λ) is regular.
2. λ is regular if and only if cf(λ) = λ.
3. λ is singular if and only if cf(λ) < λ.
4. λcf(λ) > λ. (Hint: Use K¨onig’s Theorem.)
5. For any inﬁnite cardinal κ we have cf(µκ) > κ for all µ > 1. In particular,
cf(2κ) > κ.
Exercise 4.7.8. Let κ be an inﬁnite regular cardinal. Show that there exist
arbitrarily large strong limit cardinals λ such that cf(λ) = κ. Moreover, for all
such λ we have λµ = λ for all µ < κ.
Exercise 4.7.9. Assuming the GCH, prove that for all inﬁnite cardinals κ and
λ we have
λκ =







λ
if κ < cf(λ),
λ+
if cf(λ) ≤κ ≤λ,
κ+
if κ ≥λ.
Deﬁnition 4.7.10. An inaccessible cardinal is an uncountable, regular, strong
limit cardinal. A weakly inaccessible cardinal is an uncountable, regular, limit
cardinal.
Remark 4.7.11. Clearly every inaccessible cardinal is weakly inaccessible, and
the GCH implies that every weakly inaccessible cardinal is inaccessible. It can
be shown that every weakly inaccessible cardinal is a ﬁxed point of the ℵα’s, i.e.,
such cardinals are of the form λ = ℵλ. Moreover, every strongly inaccessible
cardinal has λκ = λ for all κ < λ.
The existence of inaccessible and/or weakly inaccessible cardinals is not ob-
vious. Indeed, we shall see later that the existence of such cardinals cannot be
established using the accepted axioms of set theory.
86

4.8
Pure Well-Founded Sets
A set X is said to be transitive if, for every set Y such that Y ∈X, we have
Y ⊆X.
Lemma 4.8.1. Given a set X, there is a smallest transitive set TC(X) including
X. (TC(X) is called the transitive closure of X.)
Proof. Deﬁne U(X) = S{Y | Y ∈X, Y a set}. By recursion on n < ω deﬁne
TC0(X)
=
X
TCn+1(X)
=
U(TCn(X)) .
Then TC(X) = S
n∈N TCn(X) is easily seen to be the smallest transitive set Y
such that Y ⊇X.
For any set A, we write
∈|A = {(b, a) | a, b ∈A, a is a set, b ∈a} .
Deﬁnition 4.8.2. A set X is said to be well-founded if the relational structure
(TC(X), ∈|TC(X)) is well-founded.
Applying Lemma 4.3.5 to the relational structure (TC(X), ∈|TC(X)), we see
that X is well-founded if and only if there is no inﬁnite sequence of sets ⟨Xn⟩n∈N
with
X = X0 ∋X1 ∋· · · ∋Xn ∋· · · .
Deﬁnition 4.8.3. A set X is said to be pure if every element of TC(X) is a
set. In other words, X is a pure set if not only X but also all the elements of
X, elements of elements of X, . . . , are sets.
By transﬁnite recursion we deﬁne transitive sets Rα, α ∈Ord, as follows:
R0
=
∅
Rα+1
=
P(Rα)
Rδ
=
S
α<δ Rα for limit ordinals δ .
By transﬁnite induction on α ∈Ord, it is clear that β < α implies Rβ ∈Rα,
hence β ≤α implies Rβ ⊆Rα.
Theorem 4.8.4. X ∈S
α∈Ord Rα if and only if X is a pure, well-founded set.
Proof. It is straightforward to prove by transﬁnite induction on α that all el-
ements of Rα are pure and well-founded. Conversely, suppose X is pure and
well-founded.
We claim that, for all Y ∈TC({X}), there exists an ordinal
number α such that Y ∈Rα. If not, let Y ∈TC({X}) be ∈-minimal such that
no such α exists. For each Z ∈Y , let f(Z) be the least ordinal number β such
that Z ∈Rβ. Put γ = supZ∈Y f(Z). Then Y ⊆Rγ, hence Y ∈P(Rγ) = Rγ+1,
a contradiction. This proves the claim. In particular, X ∈Rα for some α. This
proves the theorem.
87

The class of all pure, well-founded sets is denoted V . Thus we have
V
=
[
α∈Ord
Rα .
If X is a pure, well-founded set, we deﬁne the rank of X to be the least ordinal
number α such that X ⊆Rα. Then clearly
rank X = sup{rankY + 1 | Y ∈X} .
Moreover, for all ordinals α we have
Rα = {X | X is a pure well-founded set of rank < α} ,
and rank Rα = α.
Exercise 4.8.5. Assuming the GCH, prove that |Rω+α| = ℵα for all ordinals
α.
4.9
Set-Theoretic Foundations
In the next chapter we shall begin the study of axiomatic set theory. In ax-
iomatic studies of set theory, the set concept is usually restricted to pure,
well-founded sets.
This restriction tends to isolate set theory from the rest
of mathematics. Nevertheless, the restriction is partially justiﬁed by the fact
that many or most mathematical objects can be reconstructed or redeﬁned as
pure, well-founded sets.
For example, the natural numbers 0, 1, 2, . . . are not ordinarily regarded as
being sets, but within the universe of pure, well-founded sets, it is possible to
deﬁne a structural replica of the natural numbers. Thus, from a certain per-
spective, natural numbers can be viewed as certain kinds of pure, well-founded
sets.
A similar remark applies to each of following mathematical concepts: natural
number, real number, ordinal number, cardinal number, ordered pair, function.
For each concept in this list, it is possible to identify mathematical objects of
the given type with certain pure, well-founded sets. The purpose of this section
is to show exactly how these identiﬁcations can be made. We begin with ordered
pairs and progress to functions, ordinal numbers, and real numbers.
Deﬁnition 4.9.1. For any two objects a and b, let us write
(a, b) = {{a}, {a, b}} .
Thus (a, b) is a set. Note that if a and b are pure, well-founded sets, then so is
(a, b).
Lemma 4.9.2. If (a, b) = (a′, b′) then a = a′ and b = b′.
88

Proof. Putting X = (a, b), we see that a is the unique element of T
Y ∈X Y , and
b is the unique element of S
Y ∈X Y \ {a} if the latter is nonempty, otherwise
b = a. Thus a and b can be recovered from (a, b) by single-valued set-theoretic
operations. The lemma follows.
By the above lemma, we may view (a, b) as the ordered pair formed from a
and b. From now on we shall make this identiﬁcation, which is customary in
pure set theory.
In an earlier section of these notes, we deﬁned a function with domain X
to be a rule associating to each a ∈X a unique b. In pure set theory, it is
customary to replace this deﬁnition by the following, which we shall use from
now on.
Deﬁnition 4.9.3. A function is a set of ordered pairs, f, which is single-valued,
i.e.,
∀a ∀b ∀c (((a, b) ∈f ∧(a, c) ∈f) ⇒b = c) .
The domain of f is dom(f) = {a | ∃b ((a, b) ∈f)}. If f is a function and
a ∈dom(f) we write f(a) = the unique b such that (a, b) ∈f.
The pure set-theoretic reconstruction of the ordinal numbers, due to von
Neumann, is as follows:
Deﬁnition 4.9.4. A von Neumann ordinal is a transitive, pure, well-founded
set A such that (A, ∈|A) is a well-ordering.
Note that if A is a von Neumann ordinal, then for each b ∈A, the initial segment
B = {a | a ∈b} is again a von Neumann ordinal.
Lemma 4.9.5. For each ordinal number α, there is a unique von Neumann
ordinal Aα such that type(Aα, ∈|Aα) = α. Moreover, the rank of Aα is α.
Proof. By transﬁnite recursion we deﬁne Aα = {Aβ | β < α} for all ordinals α.
By transﬁnite induction on α, it is straightforward to verify that Aα is the unique
von Neumann ordinal such that type(Aα, ∈|Aα) = α, and that rank(Aα) =
α.
Remark 4.9.6. It is customary in pure set theory to identify the ordinal number
α with the von Neumann ordinal Aα. From now on we shall make this identiﬁ-
cation. Thus we have 0 = ∅= {}, 1 = {0} = {{}}, 2 = {0, 1} = {{}, {{}}}, . . . ,
ω = {0, 1, 2, . . .} = N. Moreover, for all ordinals α we have α = {β | β < α}
and α + 1 = α ∪{α}. Also, if X is any set of ordinals, then
sup X =
[
X =
[
α∈X
α .
As for cardinal numbers, we have already seen how cardinal numbers may be
identiﬁed with certain ordinal numbers, namely, the initial ordinals. Thus, we
already know how to identify cardinal numbers with certain pure, well-founded
sets.
89

Finally, we turn to the set-theoretic construction of the real number sys-
tem. The construction emplys the usual factorization of a set by an equivalence
relation, as per the following deﬁnitions and remark.
Deﬁnition 4.9.7. Let A be a set. An equivalence relation on A is a binary
relation R ⊆A × A with the following properties: aRb and bRc imply aRc; aRb
implies bRa; and aRa for all a ∈A.
Deﬁnition 4.9.8. Let R be an equivalence relation on A. For any a ∈A we
write [a]R = {b ∈A | aRb}, the equivalence class of a with respect to R. We
write A/R = {[a]R | a ∈A}.
Remark 4.9.9. Let R be an equivalence relation on A. Then aRb if and only
if [a]R = [b]R. Moreover A/R is a partition of A, i.e., a collection of pairwise
disjoint sets whose union is A.
Deﬁnition 4.9.10 (the real number system). In order to deﬁne the real num-
ber system, we follow Dedekind and begin with the natural number system
(N, +, ·, 0, 1, =, <).
The integers are deﬁned by putting Z = (N × N)/≡Z, where (m, n) ≡Z
(m′, n′) if and only if m + n′ = m′ + n. The ordered ring structure of Z is given
by
[(m, n)] +Z [(m′, n′)]
=
[(m + m′, n + n′)]
[(m, n)] ·Z [(m′, n′)]
=
[(mm′ + nn′, mn′ + m′n)]
−Z [(m, n)]
=
[(n, m)]
0Z
=
[(0, 0)]
1Z
=
[(1, 0)]
[(m, n)] = [(m′, n′)]
⇔
m + n′ = m′ + n
[(m, n)] <Z [(m′, n′)]
⇔
m + n′ < m′ + n
The rationals are deﬁned by putting Q = (Z × Z+)/≡Q, where Z+ = {b ∈
Z | b > 0}, and (a, b) ≡Q (a′, b′) if and only if a · b′ = a′ · b. The ordered ring
structure of Q is given by
[(a, b)] +Q [(a′, b′)]
=
[(ab′ + a′b, b · b′)]
[(a, b)] ·Q [(a′, b′)]
=
[(aa′, bb′)]
−Q [(a, b)]
=
[(−a, b)]
0Q
=
[(0, 1)]
1Q
=
[(1, 1)]
[(a, b)] = [(a′, b′)]
⇔
ab′ = a′b
[(a, b)] <Q [(a′, b′)]
⇔
ab′ < a′b
Finally, the reals are deﬁned by putting R = S/≡R. Here S is deﬁned to be
the set of Cauchy sequences over Q, i.e., sequences ⟨qn⟩n∈N ∈QN satisying
∀ε > 0 ∃m ∀n (n > m ⇒|qm −qn| < ε) .
90

And ≡R is the equivalence relation on S deﬁned by putting ⟨qn⟩n ≡R ⟨q′
n⟩n if
and only if limn |qn −q′
n| = 0, i.e.,
∀ε > 0 ∃m ∀n (n > m ⇒|qn −q′
n| < ε) .
The ordered ring structure of R is given by
[⟨q⟩n] +R [⟨q′
n⟩n]
=
[⟨qn + q′
n⟩n]
[ ⟨qn⟩n] ·R [⟨q′
n⟩n]
=
[⟨qn · q′
n⟩n]
−R [⟨qn⟩n]
=
[⟨−qn⟩n]
0R
=
[⟨0⟩n]
1R
=
[⟨1⟩n]
[ ⟨qn⟩n] = [⟨q′
n⟩n]
⇔
∀ε > 0 ∃m ∀n (n > m ⇒|qn −q′
n| < ε)
[ ⟨qn⟩n] <R [⟨q′
n⟩n]
⇔
∃ε > 0 ∃m ∀n (n > m ⇒qn + ε < q′
n)
Exercise 4.9.11. Show that the real number system is complete, i.e., every
nonempty bounded subset of R has a least upper bound.
Remark 4.9.12. In this section we have shown how many or most mathemati-
cal objects may be redeﬁned or reconstructed as pure, well-founded sets. In this
sense, pure set theory may be said to encompass virtually all of mathematics,
and one may speak of the set-theoretic foundations of mathematics. This is why
set theory is viewed as being of fundamental or foundational importance.
91

Chapter 5
Axiomatic Set Theory
This chapter is an introduction to axiomatic set theory.
5.1
The Axioms of Set Theory
Deﬁnition 5.1.1. We deﬁne L∈, the language of set theory.
The language
contains variables x, y, z, . . .. The atomic formulas of the language are x = y
and x ∈y, where x and y are variables. Formulas are built up as usual from
atomic formulas by means of propositional connectives ∧, ∨, ¬ , ⇒, ⇔and
quantiﬁers ∀, ∃. The notion of free variable is deﬁned as usual. A sentence is a
formula with no free variables.
Remark 5.1.2. The standard or intended interpretation of L∈is that the
variables are to range over the class of pure, well-founded sets. Thus formulas
and sentences are normally interpreted as making assertions about pure, well-
founded sets. This standard interpretation or model of L∈is sometimes known
as the real world.
Example 5.1.3. An example of a sentence of L∈is
∀x ∀y (x = y ⇔∀u (u ∈x ⇔u ∈y)) .
This sentence asserts the extensionality principle for pure, well-founded sets:
two pure, well-founded sets are equal if and only if they contain the same pure,
well-founded sets as elements.
Example 5.1.4. An example of a formula of L∈is
∀u (u ∈z ⇔(u = x ∨u = y)) .
This formula has free variables x, y, and z. It asserts that z is the unordered
pair {x, y}, i.e., the set whose only elements are x and y.
92

As mentioned above, the standard interpretation of L∈is in terms of the
real world, i.e., the class of pure, well-founded sets. In later sections of this
chapter, we shall consider interpretations or models of L∈other than the real
world. Such alternative interpretations play an essential role in axiomatic set
theory.
We can expand the language L∈indeﬁnitely by introducing abbreviations.
Some important abbreviations are given in the following deﬁnition.
Deﬁnition 5.1.5.
1. (unordered pair) z = {x, y} is an abbreviation for
∀u (u ∈z ⇔(u = x ∨u = y)).
2. (singleton) z = {x} is an abbreviation for z = {x, x}.
3. (ordered pair) z = (x, y) is an abbreviation for z = {{x}, {x, y}}, i.e.,
∃u ∃v (u = {x} ∧v = {x, y} ∧z = {u, v}).
4. (subset) x ⊆y is an abbreviation for ∀u (u ∈x ⇒u ∈y).
5. (powerset) z = P(x) is an abbreviation for
∀y (y ∈z ⇔y ⊆x).
6. (union of a set of sets) z = S x is an abbreviation for
∀u (u ∈z ⇔∃v (v ∈x ∧u ∈v)).
7. (union of two sets) z = x ∪y is an abbreviation for z = S{x, y}, i.e.,
∃w (w = {x, y} ∧z = S w).
8. (intersection of a set of sets) z = T x is an abbreviation for
∀u (u ∈z ⇔∀v (v ∈x ⇒u ∈v)).
9. (intersection of two sets) z = x∩y is an abbreviation for z = T{x, y}, i.e.,
∃w (w = {x, y} ∧z = T w).
10. (empty set) x = ∅and x = {} are abbreviations for ∀u (u /∈x).
Using these abbreviations, we can write down sentences expressing some of
the axioms of Zermelo-Fraenkel set theory:
Deﬁnition 5.1.6 (Some Axioms of Set Theory).
93

1. Axiom of Extensionality: ∀x ∀y (x = y ⇔∀u (u ∈x ⇔u ∈y)).
2. Empty Set Axiom: ∃x (x = ∅).
3. Pairing Axiom: ∀x ∀y ∃z (z = {x, y}).
4. Union Axiom: ∀x ∃z (z = S x).
5. Power Set Axiom: ∀x ∃z (z = P(x)).
6. Axiom of Foundation: ∀x (x ̸= ∅⇒∃u (u ∈x ∧u ∩x = ∅)).
Most of the above axioms are self-explanatory. Only the Axiom of Founda-
tion needs explanation. The Axiom of Foundation is an attempt to express the
idea that all of the sets under consideration are well-founded. This is expressed
by saying that, for all sets x, if x is nonempty then x contains an element u
which is ∈-minimal. Note that, for u ∈x, u ∩x = ∅means that u is ∈-minimal
among elements of x, i.e., there is no element v of x such that v ∈u.
We now introduce some more abbreviations and axioms.
Deﬁnition 5.1.7.
1. (Cartesian product) z = x × y is an abbreviation of
∀w (w ∈z ⇔∃u ∃v (u ∈x ∧v ∈y ∧w = (u, v))).
2. (function) Fcn(f) is an abbreviation for a formula saying that f is a func-
tion, i.e.,
∀w (w ∈f ⇒∃x ∃y (w = (x, y)))∧∀x ∀y ∀z (((x, y) ∈f∧(x, z) ∈f) ⇒y = z) .
3. (value of a function) y = f(x) is an abbreviation of
Fcn(f) ∧(x, y) ∈f.
4. (domain of a function) z = dom(f) is an abbreviation of
Fcn(f) ∧∀x (x ∈z ⇔∃y (x, y) ∈f).
5. (generalized Cartesian product) z = Q f is an abbreviation of
Fcn(f)∧∀g (g ∈z ⇔(dom(g) = dom(f)∧∀x (x ∈dom(f) ⇒g(x) ∈f(x)))) .
Deﬁnition 5.1.8. The Axiom of Choice is the sentence
∀f ((Fcn(f) ∧∀x (x ∈dom(f) ⇒f(x) ̸= ∅)) ⇒Q f ̸= ∅).
Deﬁnition 5.1.9. The Axiom of Inﬁnity is the sentence
94

∃z (∅∈z ∧∀x (x ∈z ⇒x ∪{x} ∈z)).
The purpose of the Axiom of Inﬁnity is to assert the existence of at least
one inﬁnite set. This is accomplished by asserting the existence of a set that
contains all of the sets 0 = {} = ∅, 1 = {0}, 2 = {0, 1}, 3 = {0, 1, 2}, . . . .
We now introduce the two remaining axioms of Zermelo-Fraenkel set theory.
Actually, these two so-called axioms are not individual axioms, but rather axiom
schemes.
An axiom scheme is an inﬁnite set of axioms all of which have a
common form.
Recall that, if F is a formula with free variables x1, . . . , xn, then the universal
closure of F is the sentence ∀x1 · · · ∀xn F.
Deﬁnition 5.1.10.
1. The Comprehension Scheme is an inﬁnite set of axioms, consisting the
universal closures of all formulas of the form
∃z ∀u (u ∈z ⇔(u ∈x ∧F(u))) ,
where F(u) is any formula in which z does not occur freely.
2. For any formula F(u), we write z = {u ∈x | F(u)} as an abbreviation for
∀u (u ∈z ⇔(u ∈x ∧F(u))) .
The Comprehension Scheme is our attempt to express the principle that,
given a set x and a property P that particular elements of x may or may
not have, there necessarily exists a set z ⊆x consisting of all elements of x
which have the given property P. Since our language L∈does not enable us to
discuss or quantify over arbitrary properties, we restrict attention to properties
that are deﬁnable, i.e., expressible by means of a formula F(u). The syntactical
requirement that the variable z does not occur freely in F(u) is imposed in order
to avoid obvious contradictions such as z = {u ∈x | u /∈z}, the idea being that
the set z should be in some sense logically subordinate to the property P.
The Comprehension Scheme is extremely useful and important. For example,
given a function f, the Comprehension Scheme together with the Union, Pairing,
and Power Set Axioms logically imply the existence of a set z which is the domain
of f,
z = domf = {x ∈S S f | ∃y ((x, y) ∈f)},
and of the generalized Cartesian product
Q f = {g ∈PPP(S S f ∪S S S f) | domg = z ∧∀x (x ∈z ⇒g(x) ∈f(x))}.
Deﬁnition 5.1.11.
1. We write ∃! x to mean “there exists exactly one x such that”. In other
words, for any formula F(x) in which x occurs as a free variable, ∃! x F(x)
is an abbreviation of
∃y ∀x (F(x) ⇔x = y) .
95

2. The Replacement Scheme is an inﬁnite set of axioms, consisting of the
universal closures of all formulas of the form
∀u (u ∈x ⇒∃! v F(u, v)) ⇒∃y ∀v (v ∈y ⇔∃u (u ∈x ∧F(u, v))) ,
where F(u, v) is any formula in which y does not occur freely.
The Replacement Scheme is our attempt to express the principle that, given
a set x and a rule associating to each element u of x a unique object v, there
exists a set y consisting of all the objects v which are associated to elements of x.
Since our language L∈does not enable us to discuss or quantify over arbitrary
rules, we restrict attention to rules that are deﬁnable, i.e., expressible by means
of a formula F(u, v). The syntactical requirement that the variable y does not
occur freely in F(u, v) is imposed in order to avoid obvious contradictions.
We have now introduced all of the axioms of Zermelo/Fraenkel set theory.
We have, ﬁnally:
Deﬁnition 5.1.12 (Zermelo/Fraenkel Set Theory). The axioms of Zermelo/Fraenkel
set theory are as follows: the Axiom of Extensionality, the Empty Set Axiom,
the Pairing Axiom, the Union Axiom, the Power Set Axiom, the Axiom of Foun-
dation, the Axiom of Inﬁnity, the Comprehension Scheme, and the Replacement
Scheme. We use ZF as an abbreviation for “Zermelo/Fraenkel set theory”.
Deﬁnition 5.1.13 (ZFC). The axioms of ZFC consist of the axioms of ZF plus
the Axiom of Choice.
The Zermelo/Fraenkel axioms together with the Axiom of Choice constitute
the commonly accepted, rigorous, set-theoretic foundation of mathematics. A
mathematical theorem is regarded as proved if and only if it is clear how to de-
duce it as a theorem of ZFC, i.e., a logical consequence1 of the ZFC axioms. It
can be shown that all of the theorems of 19th and 20th century rigorous math-
ematics are logical consequences of the ZFC axioms. In particular, essentially
all of the results of Chapter 4 can be stated and proved as theorems of ZFC.
5.2
Models of Set Theory
As mentioned above, the intended interpretation of L∈is the so-called real world,
i.e., the class of pure, well-founded sets. However, the general notion of pure,
well-founded set is rather vague. In order to study and delimit this vagueness,
axiomatic set theorists frequently consider alternative interpretations of L∈.
One important class of interpretations of L∈is given in terms of relational
structures. Recall that a relational structure is an ordered pair (A, E) where A
is a set and E ⊆A × A. Given a relational structure (A, E) and a sentence F
of L∈, it makes sense to ask whether F is true in (A, E), i.e., true when the
variables are interpreted as ranging over A and x ∈y is interpreted as xEy, i.e.,
(x, y) ∈E.
1The notions of theorem and logical consequence that we are using here will be explained
in the next section.
96

Examples 5.2.1. The Axiom of Extensionality is true in a particular relational
structure (A, E) if and only if (A, E) is extensional, i.e., for all a, b ∈A, a ̸=
b implies {c | cEa} ̸= {c | cEb}.
Note that some relational structures are
extensional and some are not. An example of an extensional relational structure
is any linear ordering. An example of a nonextensional relational structure is
(A, E) whenever |A| ≥2 and E = ∅.
Thus a relational structure is extensional if and only if it is a model of
(i.e., satisﬁes) the Axiom of Extensionality. The general point here is that any
collection of sentences of L∈deﬁnes a property of relational structures, namely
the property of satisfying the given sentences. We formalize this in the following
deﬁnition.
Deﬁnition 5.2.2. Let S be any set of sentences of L∈. A model of S is a
relational structure (A, E) such that all of the sentences of S are true in (A, E).
We say that S is consistent if there exists a model of S. If F is another sentence
of L∈, we say that F is a logical consequence of S, written S ⊢F, if F is true
in every model of S.
Note that if S is inconsistent then all sentences are logical consequences of S,
so the notion of logical consequence is uninteresting in this case. If however S is
consistent, then it is meaningful to ask which sentences are logical consequences
of S, i.e., what conclusions follow when the sentences of S are assumed as
axioms. This is the kind of question which axiomatic set theory seeks to answer.
Naturally the focus is on sets of sentences which make assertions that could
reasonably be true in the intended model, i.e., the real world, i.e., the class of
all pure, well-founded sets.
As an easy example of the notion of logical consequence, note that the sen-
tence ∀x (x /∈x) is a logical consequence of the Axiom of Foundation plus the
Pairing Axiom. This is so because x ∈x would imply that {x} has no ∈-minimal
element.
Specializing Deﬁnition 5.2.2 to S = ZF and S = ZFC, we have:
Deﬁnition 5.2.3. A model of ZFC is a relational structure (A, E) such that
(A, E) satisﬁes all of the Zermelo/Fraenkel axioms plus the Axiom of Choice.
A theorem of ZFC is any sentence which is a logical consequence of the ZFC
axioms. The notions model of ZF and theorem of ZF are deﬁned similarly.
Axiomatic set theory is essentially the study of models of ZF and of ZFC,
with an eye to discovering which set-theoretic propositions follow or do not
follow from these axiom systems. For instance, one of the important results2 of
axiomatic set theory is that there exists a model of ZF which is not a model of
ZFC. In other words, the Axiom of Choice is not a logical consequence of the
ZF axioms. Another key result is that both the Continuum Hypothesis and its
negation are consistent with ZFC. In other words, CH is independent of ZFC.
Thus the ZFC axioms, although powerful and ﬂexible, do not suﬃce to answer
basic set-theoretic questions such as the Continuum Problem.
2This result will not be proved here.
97

We end this section by presenting some general deﬁnitions and results con-
cerning relational structures.
Deﬁnition 5.2.4. Let (A, E) be a relational structure. A k-place predicate P ⊆
Ak is said to be deﬁnable over (A, E) if there exists a formula F(x1, . . . , xk, y1, . . . , ym)
of L∈and parameters b1, . . . , bm ∈A such that
P = {⟨a1, . . . , ak⟩∈Ak | (A, E) satisﬁes F(a1, . . . , ak, b1, . . . , bm)} .
(5.1)
More generally, given B ⊆A, we say that P ⊆Ak is deﬁnable over (A, E)
allowing parameters from B if there exists a formula
F(x1, . . . , xk, y1, . . . , ym)
of L∈and parameters b1, . . . , bm ∈B such that (5.1) holds.
Deﬁnition 5.2.5. Let (A, E) be a relational structure. Then Def((A, E)) is the
set of all subsets of A that are deﬁnable over (A, E). Note that Def((A, E)) ⊆
P(A).
Lemma 5.2.6. Let (A, E) be a relational structure.
1. If A is ﬁnite, then Def((A, E)) = P(A) and |Def((A, E)| = 2|A|.
2. If A is inﬁnite, then |Def((A, E))| = |A|.
Proof. For ﬁnite A the result is obvious. Suppose now that A is inﬁnite. By
G¨odel numbering, the set of all formulas of L∈is countable. Since any element
of Def((A, E)) is determined by a formula and a ﬁnite sequence of parameters
from A, we have
|Def((A, E))| ≤ℵ0 · |A∗| = |A| .
On the other hand {{a} | a ∈A} ⊆Def((A, E)), hence |A| ≤|Def((A, E))|.
This completes the proof.
Deﬁnition 5.2.7. Let (A, E) and (A′, E′) be relational structures. We say that
(A′, E′) is a substructure of (A, E), abbreviated (A′, E′) ⊆(A, E), if A′ ⊆A
and E′ = E ∩(A′ × A′). We say that (A′, E′) is an elementary substructure
of (A, E), abbreviated (A′, E′) ⊆elem (A, E), if (A′, E′) ⊆(A, E) and, for all
formulas F(x1, . . . , xn) and a1, . . . , an ∈A′, (A, E) satisﬁes F(a1, . . . , an) if and
only if (A′, E′) satisﬁes F(a1, . . . , an).
Lemma 5.2.8. Given (A′, E′) ⊆(A, E), we have (A′, E′) ⊆elem (A, E) if and
only if every nonempty subset of A which is deﬁnable over (A, E) allowing
parameters from A′ has a nonempty intersection with A′.
Proof. Straightforward.
Recall that a relational structure (A, E) is said to be countable if the under-
lying set A is countable.
98

Theorem 5.2.9 (L¨owenheim/Skolem Theorem). For any relational structure
(A, E), there exists a countable elementary substructure (A′, E′) ⊆elem (A, E).
Proof. Let c : P(A) \ {∅} →A be a choice function for A. We deﬁne recursively
a sequence of sets An ⊆A, n ∈N, by A0 = ∅, An+1 = {c(X) | ∅̸= X ⊆A∧X is
deﬁnable over (A, E) allowing parameters from An}. Note that An ⊆An+1 for
all n. By induction on n it is straightforward to show that An is countable for all
n. Hence A′ = S{An | n ∈N} is countable. Moreover c(X) ∈A′ for all X ̸= ∅
deﬁnable over (A, E) allowing parameters from A′. Hence by Lemma 5.2.8 we
have (A′, E′) ⊆elem (A, E), where E′ = E ∩(A′ × A′).
This completes the
proof.
Corollary 5.2.10 (Skolem Paradox). If ZFC is consistent, then there exists a
countable model of ZFC.
Proof. Assume that ZFC is consistent. Then there exists a model (A, E) of
ZFC. By Theorem 5.2.9 (A, E) has a countable elementary submodel, (A′, E′).
Then (A′, E′) is a countable model of ZFC.
The Skolem Paradox is called a paradox for the following reason: the exis-
tence of a countable model of ZFC would seem to contradict the fact that the
existence of uncountable sets is a theorem of ZFC. Actually, there is no contra-
diction here, because a set that is uncountable within a particular model (A, E)
may be countable in the real world. In other words, the notion of countability
is relative to the model under consideration (as are many other set-theoretic
notions).
A straightforward generalization of Theorem 5.2.9 is:
Theorem 5.2.11 (Generalized L¨owenheim-Skolem Theorem). Let κ be an in-
ﬁnite cardinal. Let (A, E) be a relational structure such that |A| ≥κ, and let
X ⊆A be a subset of A such that |X| ≤κ. Then there exists an elementary
substructure (A′, E′) of (A, E) such that X ⊆A′ and |A′| = κ.
Proof. Straightforward.
Exercise 5.2.12. Prove Theorem 5.2.11.
5.3
Transitive Models and Inaccessible Cardi-
nals
In this section we study an important class of models. Recall that a set T is
transitive if and only if every element of T is a subset of T .
Deﬁnition 5.3.1. Let S be a set of sentences of L∈. A transitive model of
S is any transitive, pure, well-founded set T such that the relational structure
(T, ∈|T ) satisﬁes all the sentences of S. In this context it is customary to identify
the transitive set T with the relational structure (T, ∈|T ).
99

Note that every transitive model is well-founded and extensional. The fol-
lowing theorem provides a converse and thereby characterizes transitive models
up to isomorphism among arbitrary models.
Theorem 5.3.2. Let (A, E) be a relational structure which is well-founded
and extensional. Then there exists a transitive, pure, well-founded set T such
that the relational structures (A, E) and (T, ∈|T ) are isomorphic. Moreover the
transitive set T and the isomorphism f : (A, E) ∼= (T, ∈|T ) are unique.
Proof. Fix an object a0 /∈A. By transﬁnite recursion on the rank of an arbitrary
pure, well-founded set x, deﬁne F(x) as follows: F(x) = the unique a ∈A such
that rng(F↾x) = {b | bEa} if such an a exists; F(x) = a0 otherwise. Note
that F(x) = F(y) ∈A implies x = y. Hence T = rng(F −1↾A) is a set. It is
easy to verify that T is a transitive, pure, well-founded set and that F↾T is an
isomorphism of (T, ∈|T ) onto (A, E). Hence f = F −1↾A is an isomorphism of
(A, E) onto (T, ∈|T ). It is straightforward to verify that T and f are unique.
Corollary 5.3.3. If (A, E) is a relational structure, then the following asser-
tions are equivalent:
1. (A, E) is isomorphic to some transitive model (T, ∈|T );
2. (A, E) is well-founded and extensional.
The rest of this section is devoted to the study of transitive models, i.e.,
relational structures of the form (A, ∈|A) where T is a transitive, pure, well-
founded set. The following deﬁnition concerning transitive models is of general
interest.
Deﬁnition 5.3.4. Let T be any transitive, pure, well-founded set. A k-place
predicate P ⊆T k is said to be deﬁnable over T if and only if it is deﬁnable over
(T, ∈|T ) (allowing parameters from T ). We write
Def(T ) = Def((T, ∈|T )) = {X ⊆T | X is deﬁnable over T } .
Of particular interest are transitive models of ZFC. The following lemma
consists of some simple remarks characterizing which transitive models satisfy
which axioms of ZFC.
Lemma 5.3.5. Let T be a transitive, pure, well-founded set.
1. T always satisﬁes the Axiom of Extensionality.
2. T always satisﬁes the Axiom of Foundation.
3. T satisﬁes the Pairing Axiom if and only if T is closed under pairing, i.e.,
∀a ∀b ((a ∈T ∧b ∈T ) ⇒{a, b} ∈T ).
4. T satisﬁes the Union Axiom if and only if T is closed under union, i.e.,
100

∀a (a ∈T ⇒S a ∈T ).
5. T satisﬁes the Empty Set Axiom if and only if ∅∈T .
6. T satisﬁes the Axiom of Inﬁnity if and only if ∃a (a ∈T ∧ω ⊆a).
7. T satisﬁes the Power Set Axiom if and only if
∀a (a ∈T ⇒P(a) ∩T ∈T ).
8. T satisﬁes the Axiom of Choice if and only if, for every indexed family of
nonempty sets ⟨ai⟩i∈I ∈T , we have T ∩Q
i∈I ai ̸= ∅.
9. T satisﬁes the Comprehension Scheme if and only if, for all X ∈Def(T ),
we have
∀a (a ∈T ⇒a ∩X ∈T ).
10. T satisﬁes the Replacement Scheme if and only if for all functions F : T →
T such that F ∈Def(T ), we have
∀a (a ∈T ⇒rng(F↾a) ∈T ).
Proof. Straightforward.
We shall now show that inaccessible cardinals give rise to transitive models
of ZFC. Recall that an inaccessible cardinal is a regular, uncountable, strong
limit cardinal.
Recall also that we have identiﬁed cardinals with initial von
Neumann ordinals (cf. Sections 4.4.5 and 4.4.8).
Lemma 5.3.6. Let δ be a limit ordinal > ω. Then Rδ is a transitive model of
all of the ZFC axioms except possibly the Replacement Scheme.
Proof. We apply Lemma 5.3.5. The Axioms of Extensionality and Foundation
hold in Rδ because Rδ is a transitive, pure, well-founded set.
The Empty
Set, Power Set, Pairing, and Union Axioms and the Axiom of Choice and the
Comprehension Scheme hold in Rδ because δ is a limit ordinal. The Axiom of
Inﬁnity holds in Rδ because ω ∈Rδ, since ω < δ.
Lemma 5.3.7. An inﬁnite cardinal λ is regular if and only if, for all X ⊆λ,
|X| < λ implies sup X < λ.
Proof. Straightforward.
Lemma 5.3.8. If λ is an inaccessible cardinal, then
1. ∀x ((x ⊆Rλ ∧|x| < λ) ⇒x ∈Rλ).
2. ∀x (x ∈Rλ ⇒|x| < λ).
101

3. |Rλ| = λ.
Proof.
1.
Deﬁne ρ : x →λ by ρ(u) = rank(u).
Then |rngρ| ≤|x| < λ.
Since λ is regular, it follows by the previous lemma that sup(rngρ) < λ, say
rngρ ⊆α < λ. Hence x ⊆Rα, hence x ∈Rα+1 ⊆Rλ since λ is a limit ordinal.
2. By transﬁnite induction on α < λ we prove |Rα| < λ. We have R0 = ∅.
If |Rα| = κ < λ, then |Rα+1| = |P(Rα)| = 2κ < λ since λ is a strong limit
cardinal. For limit ordinals δ < λ, we have inductively |Rδ| = | S
α<δ Rα| =
supα<δ |Rα| < λ, since |Rα| < λ and λ is regular.
3. |Rλ| = supα<λ |Rα| = λ.
Theorem 5.3.9. Let λ be an inaccessible cardinal. Then Rλ is a transitive
model of ZFC.
Proof. Clearly λ is a limit ordinal > ω, hence by Lemma 5.3.6 we see that Rλ
satisﬁes all of the ZFC axioms except possibly the Replacement Scheme.
Let F : Rλ →Rλ and a ∈Rλ be given.
Then rng(F↾a) ⊆Rλ and
|rng(F↾a)| ≤|a| < λ, hence by the previous lemma rng(F↾a) ∈Rλ.
Spe-
cializing this to the case when F is deﬁnable over Rλ, we see by Lemma 5.3.5
that the Replacement Scheme holds in Rλ. This completes the proof.
Corollary 5.3.10. If there exists an inaccessible cardinal, then ZFC is consis-
tent.
Proof. Immediate from the theorem.
Exercise 5.3.11. A hereditarily ﬁnite set is a ﬁnite set x such that all elements
of x, elements of elements of x, . . . , are ﬁnite sets. Show that Rω is the set of
all hereditarily ﬁnite, pure, well-founded sets. Show that Rω is a model of all
of the axioms of ZFC except the Axiom of Inﬁnity.
Exercise 5.3.12. Deﬁne E ⊆N by putting mEn if and only if 2m occurs in
the binary expansion of n, i.e., m = ni for some i where n = 2n1 + · · · + 2nk.
1. Show that (N, E) ∼= (Rω, ∈|Rω).
2. Conclude that P ⊆ωk is deﬁnable over Rω if and only if P is arithmetical.
Theorem 5.3.13. If there exists an inaccessible cardinal, then the existence of
an inaccessible cardinal is not a theorem of ZFC.
Proof. Assume that there exists an inaccessible cardinal. Let λ be the smallest
inaccessible cardinal. By the previous theorem, Rλ is a model of ZFC. We claim
that Rλ also satisﬁes “inaccessible cardinals do not exist”. To see this, suppose
that Rλ satisﬁes “there exists at least one inaccessible cardinal”. Let κ ∈Rλ
be such that Rλ satisﬁes “κ is an inaccessible cardinal”. Then it is easy to see
that κ is also an inaccessible cardinal in the real world. But clearly κ < λ.
This contradicts the choice of λ. Thus Rλ is a model of ZFC + “inaccessible
cardinals do not exist”.
102

The previous theorem shows that, if we assume only the axioms of ZFC,
then we cannot hope to prove the existence of inaccessible cardinals.
Exercise 5.3.14. Show that, if two or more inaccessible cardinals exist, then
the existence of two or more inaccessible cardinals is not a theorem of ZFC +
“there exists at least one inaccessible cardinal”.
Theorem 5.3.15. If there exists an inaccessible cardinal, then there exists a
countable, transitive model of ZFC.
Proof. Let λ be an inaccessible cardinal. Then (Rλ, ∈|Rλ) is a model of ZFC.
By the L¨owenheim-Skolem Theorem, there exists a countable set A ⊆Rλ such
that (A, ∈|A) is an elementary submodel of (Rλ, ∈|Rλ).
Thus (A, ∈|A) is a
countable, well-founded, extensional model of ZFC. By Theorem 5.3.2, (A, ∈|A)
is isomorphic to a transitive model (T, ∈|T ).
Thus (T, ∈|T ) is a countable,
transitive model of ZFC.
Exercise 5.3.16. Let λ be an inaccessible cardinal.
Prove that there ex-
ists a limit ordinal δ < λ such that (Rδ, ∈|Rδ) is an elementary submodel of
(Rλ, ∈|Rλ).
5.4
Constructible Sets
Recall that, if T is any transitive, pure, well-founded set, Def(T ) is the set of all
subsets of T that are deﬁnable over T (i.e., over (T, ∈|T )) allowing parameters
from T .
Deﬁnition 5.4.1. By transﬁnite recursion we deﬁne Lα, α ∈Ord, as follows:
L0
=
∅
Lα+1
=
Def(Lα)
Lδ
=
S
α<δ Lα
for limit ordinals δ .
A set X is said to be constructible if X ∈Lα for some ordinal α. The class of
all constructible sets is denoted L.
Lemma 5.4.2. For all ordinals α, Lα is a transitive, pure, well-founded set,
and Lα ⊆Rα.
Proof. For any transitive, pure, well-founded set T , we have T ⊆Def(T ) ⊆P(T )
and hence Def(T ) is again a transitive, pure, well-founded set.
With these
observations, the lemma follows easily by transﬁnite induction on α.
Lemma 5.4.3. For all ordinals α, we have α = Lα ∩Ord.
Proof. If T is any transitive, pure, well-founded set, then for any a ∈T we
have that a is an ordinal (i.e., a von Neumann ordinal) if and only if T satisﬁes
“a is transitive and (a, ∈|a) is a linear ordering”. Thus T ∩Ord ∈Def(T ).
With this observation, the lemma follows easily by transﬁnite induction on (von
Neumann) ordinals α.
103

We are going to show that the constructible sets form a model of ZFC.
Some of the axioms of ZFC are straightforwardly veriﬁed in L using Lemma 5.3.5.
For instance, the Union Axiom holds in L because x ∈Lα implies S x ∈Lα.
The Pairing Axiom holds in L because x, y ∈Lα implies {x, y} ∈Lα+1. The
Empty Set Axiom holds in L because ∅∈L1. The Axiom of Inﬁnity holds in
L because ω ∈Lω+1. The Axioms of Extensionality and Foundation hold in L
because L is transitive and consists of pure, well-founded sets.
To show that the Power Set Axiom holds in L, let X be any constructible
set. For each Y ∈P(X) ∩L put ρ(Y ) = the least β such that Y ∈Lβ. Put
α = sup{ρ(Y ) | Y ∈P(X) ∩L}. Thus P(X) ∩L ⊆Lα. Hence P(X) ∩L is
deﬁnable over Lα; namely, it is the set of all Y ∈Lα such that Lα satisﬁes
Y ⊆X. Hence P(X) ∩L ∈Def(Lα) = Lα+1. We have now shown that for all
X ∈L, P(X) ∩L ∈L. From this it follows by Lemma 5.3.5 that the Power Set
Axiom holds in L.
To show that Comprehension and Replacement hold in L, we shall need the
following lemmas.
Lemma 5.4.4. Let f1, . . . , fk be functions from Ord to Ord. Then there exist
arbitrarily large ordinals α such that α is closed under f1, . . . , fk, i.e., fi(β) < α
for all β < α, 1 ≤i ≤k.
Proof. Given an ordinal γ, deﬁne an increasing sequence of ordinals αn, n ∈N
inductively by α0 = γ, αn+1 = max(αn + 1, sup{fi(β) | β < αn, 1 ≤i ≤
k}). Putting α = sup{αn | n ∈N} we see that α > γ and α is closed under
f1, . . . , fk.
Lemma 5.4.5 (reﬂection). Let F(x1, . . . , xn) be a formula of L∈with free vari-
ables x1, . . . , xn. Then there exist arbitrarily large ordinals α such that, for all
a1, . . . , an ∈Lα, L satisﬁes F(a1, . . . , an) if and only if Lα satisﬁes F(a1, . . . , an).
Proof. Replacing ∀by ¬ ∃¬ as necessary, we may safely assume that F contains
no occurrences of ∀. Now let ∃y Gi, i = 1, . . . , k be a list of the subformulas of F
of the form ∃y G. Write Gi ≡Gi(y, xi1, . . . , xini) where xi1, . . . , xini are the free
variables of ∃y Gi. For a1, . . . , ani ∈L, put gi(a1, . . . , ani) = the least ordinal
β such that a1, . . . , ani ∈Lβ and such that, if L satisﬁes ∃y Gi(y, a1, . . . , ani),
then L satisﬁes Gi(b, a1, . . . , ani) for some b ∈Lβ. Deﬁne fi : Ord →Ord by
fi(β) = sup{gi(a1, . . . , ani) | a1, . . . , ani ∈Lβ}. By the previous lemma, there
exist arbitrarily large ordinals α such that that α is closed under f1, . . . , fk. It
is straightforward to verify that such an α has the desired property.
Remark 5.4.6. The proof of the previous lemma used only the following prop-
erties of the constructible hierarchy: α ≤β implies Lα ⊆Lβ; and Lδ = S
α<δ Lα
for limit ordinals δ. Since the Rα hierarchy also has these properties, the same
lemma holds for the Rα hierarchy as well. This has the following interesting
consequence: If F1, . . . , Fk is a ﬁnite set of sentences that are true in the real
world, then there exist arbitrarily large ordinals α such that F1, . . . , Fk are true
in Rα.
104

Lemma 5.4.7. L satisﬁes the Comprehension and Replacement Schemes.
Proof. To show that the Replacement Scheme holds in L, let f : L →L be a
function which is deﬁnable over L. We must prove that, for all a ∈L, rng(f↾a) =
{f(u) | u ∈a} also belongs to L. Note ﬁrst that, since f is deﬁnable over L,
we have parameters c1, . . . , cn ∈L and a formula F(u, v, z1, . . . , zn) with free
variables u, v, z1, . . . , zn such that, for all u ∈L, f(u) = the unique v ∈L such
that L satisﬁes F(u, v, c1, . . . , cn). Now given a ∈L, put b = rng(f↾a). We
must show that b ∈L. Let β be an ordinal so large that a, c1, . . . , cn ∈Lβ
and b ⊆Lβ. By Reﬂection, let α be such that α > β and, for all u, v ∈Lα,
L satisﬁes F(u, v, c1, . . . , cn) if and only if Lα satisﬁes F(u, v, c1, . . . , cn). We
claim that b is deﬁnable over Lα. This is clear since
b
=
{v ∈L | L satisﬁes ∃u (u ∈a ∧F(u, v, c1, . . . , cn))}
=
{v ∈Lα | Lα satisﬁes ∃u (u ∈a ∧F(u, v, c1, . . . , cn))} .
Thus b ∈Def(Lα) = Lα+1, whence b ∈L. This shows that the Replacement
Scheme holds in L. The proof that the Comprehension Scheme holds in L is
similar.
We introduce some more abbreviations:
Deﬁnition 5.4.8.
1. Const(x) is an abbreviation for a formula asserting that a given pure, well-
founded set x is constructible. In more detail, Const(x) asserts the exis-
tence of a transﬁnite sequence of sets ⟨Lβ⟩β≤α such that Lβ = S{Def(Lγ) |
γ < β} for all β ≤α, and x ∈Lα.
2. Recall that V is the class of all pure, well-founded sets, and L is the
class of all constructible sets. We use V = L to abbreviate ∀x Const(x).
Thus V = L is a sentence asserting that all pure, well-founded sets are
constructible.
Theorem 5.4.9. The class L of constructible sets satisﬁes the ZF axioms plus
V = L.
Proof. The above lemmas show that L satisﬁes the ZF axioms. It is tedious but
straightforward to show that L satisﬁes V = L.
Lemma 5.4.10. For all ordinals α ≥ω, we have |Lα| = |α|.
Proof. By Lemma 5.2.6 we have |Lω| = ℵ0 and, for α ≥ω, |Lα+1| = |Def(Lα)| =
|Lα|. From this the lemma easily follows by induction on α ≥ω.
Theorem 5.4.11. The class L of constructible sets satisﬁes the Axiom of
Choice.
105

Proof. Lemma 5.4.10 implies that each Lα is well-orderable. Reﬁning the proof
of Lemma 5.4.10, we can explicitly deﬁne by transﬁnite recursion a function
F : Ord →V such that, for all ordinals α, F(α) is a well-ordering of Lα. Since
the deﬁnition of F is explicit, its validity does not depend on the Axiom of
Choice. Hence by Theorem 5.4.9 the deﬁnition of F can be carried out within L.
In particular L satisﬁes that each Lα is well-orderable. Hence by Remark 4.5.3
L satisﬁes the Axiom of Choice. This argument actually shows that the Axiom
of Choice follows from ZF plus V = L.
Our remaining goal with respect to constructible sets is to show that L
satisﬁes the GCH.
Lemma 5.4.12. There is a sentence S of L∈with the following property. For
all transitive sets A, A satisﬁes S if and only if A = Lα for some limit ordinal
α.
Proof. The construction of the sentence S is straightforward but tedious. Roughly
speaking, S is identical with the sentence V = L of Deﬁnition 5.4.8. For de-
tails of the construction of S, see Boolos and Putnam, “Degrees of unsolvability
of constructible sets of integers,” Journal of Symbolic Logic, Volume 33, 1968,
pages 497–513.
Lemma 5.4.13. If a is any constructible subset of ω, then a ∈Lα for some
countable ordinal α. More generally, if a ∈P(κ) ∩L where κ is an inﬁnite
cardinal, then a ∈Lα for some ordinal α such that |Lα| = κ.
Proof. Let κ be an inﬁnite cardinal. Suppose that a ⊆κ and a is constructible.
Let δ > κ be a limit ordinal such that a ∈Lδ. By the Generalized L¨owenheim/-
Skolem Theorem (Theorem 5.2.11), we can ﬁnd a set A ⊆Lδ such that κ ∪
{a} ⊆A, |A| = κ, and (A, ∈|A) is an elementary submodel of (Lδ, ∈|Lδ). By
Theorem 5.3.2 and Lemma 5.4.12, we have (A, ∈|A) ∼= (Lα, ∈|Lα) for some
limit ordinal α. Since κ ∪{a} is a transitive subset of A, it follows by another
application of Theorem 5.3.2 that κ ∪{a} ⊆Lα. In particular a ∈Lα. Clearly
|Lα| = κ, and this completes the proof.
Lemma 5.4.14. For any inﬁnite cardinal κ, we have |P(κ) ∩L| ≤κ+.
Proof. From the previous lemma we have P(κ) ∩L ⊆Lκ+. The desired conclu-
sion is immediate, since |Lκ+| = |κ+|.
Theorem 5.4.15. The class L of constructible sets satisﬁes the Generalized
Continuum Hypothesis.
Proof. Since L satisﬁes the axioms of set theory, the proof of the previous lemma
can be carried out within L. Thus for all inﬁnite cardinals κ of L, we have within
L that |P(κ)| = κ+, hence 2κ = κ+. This proves the theorem.
Theorem 5.4.16.
106

1. If ZF has a transitive model, then so does ZFC + GCH.
2. If ZF is consistent, then so is ZFC + GCH.
Proof. Let A be a transitive model of ZF. Within A we can carry out the
deﬁnition of L to obtain a transitive submodel B (sometimes called an “inner
model”) consisting of the constructible sets of A. (It can be shown that B =
Lα where α is the least ordinal that is not an element of A.) The proofs of
theorems 5.4.9, 5.4.11, and 5.4.15 then show that B is a model of ZF plus
V = L plus the Axiom of Choice plus the GCH. This proves the ﬁrst part. The
proof of the second part is similar, starting with a model (A, E) that is not
necessarily transitive.
Remark 5.4.17. The previous theorem, due to G¨odel 1939, is one of the most
signiﬁcant achievements of axiomatic set theory. The second part is sometimes
described as a relative consistency result: ZFC + GCH is consistent relative to
ZF.
5.5
Forcing
Let M be a countable transitive model of ZFC. Let P = (P, ≤) be a partially
ordered set belonging to M. We say that p, q ∈P are compatible if there exists
r ∈P such that r ≤p and r ≤q. If p, q ∈P are incompatible, we write p ⊥q.
Deﬁnition 5.5.1. A ﬁlter on P is a set G ⊆P such that
1. p, q ∈G implies ∃r ∈G (r ≤p, q);
2. p ∈G, p ≤q imply q ∈G.
Deﬁnition 5.5.2. D ⊆P is dense open if
1. ∀p ∈P ∃q ≤p (q ∈D);
2. ∀p ∈D ∀q ≤p (q ∈D).
Deﬁnition 5.5.3. A ﬁlter G ⊆P is said to be M-generic if G ∩D ̸= ∅for all
dense open D ⊆P such that D ∈M.
Lemma 5.5.4. Given p ∈P we can ﬁnd an M-generic ﬁlter G ⊆P such that
p ∈G.
Proof. Let {Dn | n ∈N} be an enumeration of {D ∈M | D dense open in P}.
Put p0 = p and, given pn, let pn+1 ≤pn be such that pn+1 ∈Dn. It is easy to
verify that G = {q ∈P | ∃n (pn ≤q)} is an M-generic ﬁlter.
Deﬁnition 5.5.5. Let G be an M-generic ﬁlter. We put
M[G] = {aG | a ∈M},
107

where
aG = {bG | (p, b) ∈a for some p ∈G}.
Remark 5.5.6. Think of each a ∈M as a “name” for aG ∈M[G]. We shall
show that M[G] is a countable transitive model of ZFC containing M.
Lemma 5.5.7. M[G] is a countable transitive set. We have M[G] ⊇M ∪{G},
and Ord ∩M[G] = Ord ∩M.
Proof. It is obvious from the deﬁnition that M[G] is a countable transitive set.
For all a ∈M we have a = (˙a)G, where ˙a = P × {˙b | b ∈a}. We also have
G = ( ˙G)G, where ˙G = {(p, ˙p) | p ∈P}. Thus M ∪{G} ⊆M[G], and from this
it follows that Ord ∩M ⊆Ord ∩M[G]. On the other hand, for each a ∈M we
clearly have rank(a) ≥rank(aG), hence Ord ∩M ⊇Ord ∩M[G].
A major result is:
Theorem 5.5.8. M[G] is a countable transitive model of ZFC.
Remark 5.5.9. The proof of Theorem 5.5.8 is long and employs a new method
known as forcing. However, some parts of the proof are easy and do not require
forcing.
For example, given a, b ∈M, put c = P × {a, b}, then cG = {aG, bG}. This
shows that M[G] satisﬁes the Pairing Axiom. Also, M[G] satisﬁes the Axiom of
Inﬁnity because ω = ( ˙ω)G ∈M[G]. Furthermore, M[G] satisﬁes Extensionality
and Foundation automatically, because M[G] is a transitive set.
So far we have not used the assumption that G is an M-generic ﬁlter.
In order to prove the rest of Theorem 5.5.8, we now introduce the method
of forcing.
Deﬁnition 5.5.10. The forcing language consists of binary relation symbols ∈
and = plus constant symbols a for each a ∈M. Sentences of the forcing language
are of the form F(a1, . . . , an), where F(x1, . . . , xn) is a formula of L∈with free
variables x1, . . . , xn, and a1, . . . , an ∈M. We have M[G] |= F(a1, . . . , an) if and
only if F(a1, . . . , an) is true in M[G], where quantiﬁers are interpreted as ranging
over M[G], and a1, . . . , an are interpreted as (a1)G, . . . , (an)G respectively.
Deﬁnition 5.5.11 (forcing). Let p ∈P and let F be a sentence of the forcing
language. We say that p ∥−F (read p forces F) if and only if M[G] |= F for all
M-generic ﬁlters G such that p ∈G.
Lemma 5.5.12 (the extension lemma). If p ∥−F and q ≤p, then q ∥−F.
Proof. This is obvious, because q ∈G, q ≤p imply p ∈G.
Lemma 5.5.13 (deﬁnability of forcing). For each formula F(x1, . . . , xn) there
is a formula F ∗(p, x1, . . . , xn) such that, for all p ∈P and a1, . . . , an ∈M,
p ∥−F(a1, . . . , an) if and only if M |= F ∗(p, a1, . . . , an).
108

Lemma 5.5.14 (forcing equals truth). M[G] |= F if and only if ∃p ∈G (p ∥−F).
Proof. We shall prove Lemmas 5.5.13 and 5.5.14 by simultaneous induction on
the number of connectives and quantiﬁers in F. We assume that F contains
only ∧, ¬ , and ∀(not ∨, ⇒, ⇔, ∃).
For the base step, we need to ﬁnd formulas ∈∗(p, x, y) and =∗(p, x, y) of
L∈deﬁning the relations p ∥−a ∈b and p ∥−a = b, respectively, over M. The
formulas ∈∗and =∗are deﬁned by a rather complicated simultaneous transﬁnite
recursion within M. The properties
p ∥−a ∈b if and only if M |= ∈∗(p, a, b)
and
p ∥−a = b if and only if M |= =∗(p, a, b)
are proved by transﬁnite induction on rank(a) and rank(b). We omit the details.
For the inductive step, note that
p ∥−F1 ∧F2 if and only if p ∥−F1 and p ∥−F2,
and
p ∥−∀x F(x) if and only if p ∥−F(a) for all a ∈M.
Thus we may deﬁne (F1 ∧F2)∗= F ∗
1 ∧F ∗
2 and (∀x F(x))∗= ∀x F ∗(x). This
takes care of ∧and ∀. For ¬ , we claim that
p ∥−¬ F if and only if ¬ ∃q ≤p (q ∥−F).
To see this, assume the right hand side. Let G be generic with p ∈G. To show
M[G] |= ¬ F. Otherwise, M[G] |= F so let q ∈G be such that q ∥−F. Let
r ∈G be such that r ≤p and r ≤q. Then r ≤p and r ∥−F, contradicting
our assumption. For the converse, assume the left hand side. Suppose q ≤p,
q ∥−F. Let G be generic such that q ∈G. Then M[G] |= F. Also p ∈G since
q ≤p. Therefore p does not force ¬ F, contradicting our assumption.
Thus, for deﬁnability of forcing, we may take
(¬ F)∗(p, a1, . . . , an) ≡¬ (∃q ≤p) F ∗(q, a1, . . . , an).
For focing equals truth, suppose M[G] |= ¬ F. To show (∃p ∈G) p ∥−¬ F. Put
D = {p | p ∥−F or p ∥−¬ F}. Clearly D is dense open. By deﬁnability of
forcing, D ∈M. Let p ∈D ∩G. If p ∥−F, then M[G] |= F, a contradiction.
Hence p ∥−¬ F.
We now proceed to the proof of Theorem 5.5.8.
Lemma 5.5.15. M[G] |= the Comprehension Scheme.
Proof. Given a, a1, . . . , an ∈M, to ﬁnd c ∈M such that
M[G] |= ∀u (u ∈c ⇔(u ∈a ∧F(u, a1, . . . , an))).
Put
109

c = {(p, b) | b ∈S S a and p ∥−b ∈a ∧F(b, a1, . . . , an)}.
Then c ∈M, by Deﬁnability of Forcing in M. Then, by the Forcing Equals
Truth Lemma, we have
cG = {bG | b ∈S S a and M[G] |= F(b, a1, . . . , an)}.
Lemma 5.5.16. M[G] |= the Power Set Axiom.
Proof. Given a ∈M, put c = P × P(P × S S a) ∩M. We claim that
cG ⊇P(aG) ∩M[G].
To see this, given eG ∈M[G], let d = {(p, b) ∈P × S S a | p ∥−b ∈e ∩a}. By
deﬁnability of forcing, d ∈M, hence dG ∈cG. Moreover dG = eG ∩aG. This
proves our claim. The Power Set Axiom follows by Comprehension in M[G],
since P(aG) ∩M[G] = {dG ∈cG | M[G] |= d ⊆a}.
Lemma 5.5.17. M[G] |= the Union Axiom.
Proof. This is similar to the Power Set Axiom. Given a ∈M put
c = P × S S S S a.
Then cG ⊇S aG, and the Union Axiom follows by Comprehension in M[G].
Lemma 5.5.18. M[G] |= the Replacement Scheme.
Proof. It suﬃces to prove that M[G] |= the Bounding Scheme:
∀w1 · · · wn [ ∀u ∃! v F(u, v, w1, . . . , wn) ⇒∀x ∃y ∀u ∈x ∃v ∈
y F(u, v, w1, . . . , wn) ].
This is because Bounding plus Comprehension implies Replacement.
Given a, a1, . . . , an ∈M, let c ∈M be such that, for all (p, b) ∈P × S S a,
if there exists d ∈M such that p ∥−F(b, d, a1, . . . , an), then c contains such a
d. We then have
M[G] |= ∀u ∃! v F(u, v, w1, . . . , wn) ⇒∀u ∈a ∃v ∈c′ F(u, v, a1, . . . , an),
where c′ ∈M, namely c′ = P × c. Thus M[G] |= Bounding.
Lemma 5.5.19. M[G] |= the Axiom of Choice.
Proof. Given aG ∈M[G], let f ∈M map an ordinal α onto S S a.
Since
M ⊆M[G], we have f = ( ˙f)G ∈M[G].
Composing f with the function
b 7→bG, we obtain in M[G] a mapping of α = ( ˙α)G onto {bG | b ∈S S a} ⊇aG.
Thus aG is well orderable in M[G].
The proof of Theorem 5.5.8 is now complete.
As a ﬁrst application, we prove the independence of V = L.
Theorem 5.5.20. There exists a countable transitive model of ZFC plus V ̸= L.
110

Proof. Let M be a countable transitive model of ZFC. Let P be the set of ﬁnite
partial functions from ω into 2 = {0, 1}. Partially order P by putting p ≤q if
and only if p extends q. Then P ∈M. Let G be an M-generic ﬁlter on P. By
Theorem 5.5.8 we have M[G] |= ZFC.
Note that p, q ∈P are compatible if and only if p ∪q ∈P. Thus g = S G
is a partial function from ω into 2. We claim that dom(g) = ω. To see this,
given n ∈ω, put Dn = {p ∈P | n ∈dom(g)}. Clearly Dn is dense open, and
Dn ∈M. Letting p ∈G ∩Dn, we see that n ∈dom(p), hence n ∈dom(g).
Thus g : ω →2 and g ∈M[G]. We claim that g /∈M. If g ∈M, then clearly
G = {p ∈P | p ⊆g} ∈M, so let D = P \ G = {p ∈P | p /∈G}. Then D ∈M,
and clearly D is dense open. But G ∩D = ∅, a contradiction.
We claim that M[G] |= V ̸= L. In fact,
M[G] |= ˙g /∈L ∧˙g : ω →2
where (˙g)G = g.
5.6
Independence of CH
As in the previous section, let M be a countable transitive model of ZFC, let P
be a partially ordered set belonging to M, and let G be an M-generic ﬁlter on
P. We begin with a discussion of cardinal collapsing and cardinal preservation
in M[G].
Remark 5.6.1. Clearly every cardinal of M[G] is a cardinal of M. However,
the converse does not always hold. Cardinals of M can be collapsed in M[G].
Example 5.6.2. Let κ be an uncountable cardinal of M. Let P be the set of
ﬁnite partial functions from ω into κ, ordered by p ≤q if and only if p extends
q. Let G be an M-generic ﬁlter on P. Put g = S G. As in the proof of Theorem
5.5.20, we see that g : ω →κ.
We claim that rng(g) = κ. To see this, give α < κ, put Dα = {p ∈P | α ∈
rng(p)}. Clearly Dα ∈M. Because ω is inﬁnite, Dα is dense open. Letting
p ∈G ∩Dα, we see that α ∈rng(p), hence α ∈rng(g).
Thus g ∈M[G] maps ω onto κ. It follows that M[G] |= “ ˙κ is a countable
ordinal”. In particular κ is not a cardinal of M[G].
On the other hand, cardinals of M are often preserved, i.e., remain cardinals
in M[G].
Lemma 5.6.3. Suppose M |= “κ is a cardinal > |P|”. Then M[G] |= “κ is a
cardinal”. In other words, all cardinals > |P| in M are preserved in M[G].
Proof. Suppose not, say fG : λ →κ, λ < κ, rng(fG) = κ, fG ∈M[G]. Then in
M we have
∀α < κ ∃β < λ ∃p ∈P (p ∥−f | ˙λ →˙κ and p ∥−f( ˙β) = ˙α).
111

By the Pigeonhole Principle, we can ﬁnd p ∈P, β < λ, α1 < α2 < κ such that
p ∥−f : ˙λ →˙κ and p ∥−f( ˙β) = ˙α1 and f( ˙β) = ˙α2. This is a contradiction.
Deﬁnition 5.6.4. An antichain in P is a set A ⊆P such that the elements
of A are pairwise incompatible. P is said to have the countable chain condition
(c.c.c.) if every antichain of P is countable.
Lemma 5.6.5. Suppose M |= P is c.c.c. Then all cardinals of M are preserved
in M[G].
Proof. Suppose not, say κ > λ, M |= “κ is a cardinal”, M[G] |= “f maps ˙λ onto
˙κ”. Fix p ∈P such that p ∥−“f maps ˙λ onto ˙κ”. Reasoning within M, for α < κ
and β < λ say that α is a possible value of f(β) if ∃q ≤p (q ∥−f( ˙β) = ˙α). Let
Xβ = {α | α is a possible value of f(β)}. Note that κ = S
β<λ Xβ. Therefore,
some Xβ is uncountable. Fix such a β. For each α ∈Xβ let qα ≤p be such
that qα ∥−f( ˙β) = ˙α. Note that α1, α2 ∈Xβ, α1 ̸= α2 implies qα1 ⊥qα2. Thus
Aβ = {qα | α ∈Xβ} is an uncountable antichain in P. This contradicts the
assumption that P is c.c.c.
We now proceed to the independence of the Continuum Hypothesis.
Deﬁnition 5.6.6. A ∆-system is an indexed family of sets ⟨Xi⟩i∈I such that,
for some ﬁxed set D, Xi ∩Xj = D for all i, j ∈I, i ̸= j.
Lemma 5.6.7 (the ∆-system lemma). Any uncountable family of ﬁnite sets
contains an uncountable subfamily which is a ∆-system.
Proof. Let ⟨Xi⟩i∈I be an uncountable family of ﬁnite sets. We may safely assume
that |I| = ℵ1 and that S
i∈I Xi ⊆ω1. Passing to an uncountable subfamily, we
may assume that ∃n ∀i ∈I |Xi| = n. For each i ∈I, let Xi(1) < · · · < Xi(n) be
the elements of Xi.
Case 1: For each k = 1, . . . , n, {Xi(k) : i ∈I} is countable. In this case,
S
i∈I Xi is countable. Hence, by passing to an uncountable subfamily, we may
assume Xi = Xj for all i, j ∈I. In particular, we have an uncountable ∆-system.
Case 2: Otherwise. Let k be as small as possible such that {Xi(k) | i ∈I}
is uncountable. Then, for each l < k, {Xi(l) | i ∈I} is countable. By passing
to an uncountable subfamily, we may assume Xi(l) = Xj(l) for all l < k and all
i, j ∈I. Thus we have a ﬁxed ﬁnite set D = {Xi(l) | 1 ≤l < k} for all i ∈I.
Since {Xi(k) | i ∈I} is uncountable, we may use transﬁnite recursion to deﬁne
a function f : ω1 →I such that, for each α < ω1, Xf(α)(k) > supβ<α Xf(β)(n).
Then ⟨Xf(α)⟩α<ω1 is an uncountable ∆-system contained in ⟨Xi⟩i∈I.
Lemma 5.6.8. Let X be any set. Let P be the set of ﬁnite partial functions
from X into {0, 1}, ordered by putting p ≤q if and only if p ⊇q. Then P is
c.c.c.
Proof. Suppose not.
Let ⟨pi⟩i∈I be an uncountable antichain in P.
By the
∆-system lemma, we may pass to a subfamily such that ⟨dom(pi)⟩i∈I is a ∆-
system. Say dom(pi)∩dom(pj) = D for all i, j ∈I, i ̸= j. There are only ﬁnitely
112

many functions from D into {0, 1}, so by passing to an uncountable subfamily
we may assume that pi↾D = pj↾D for all i, j ∈I. Then for all i, j ∈I we have
that pi ∪pj is a function, hence pi and pj are compatible, a contradiction.
Theorem 5.6.9. Let M be a countable transitive model of ZFC. Let κ be an
uncountable cardinal of M. Then there exists a countable transitive model M ′
of ZFC extending M such that (1) M ′ satisﬁes 2ℵ0 ≥κ, and (2) M ′ has the
same ordinals and cardinals as M.
Proof. Let P be the set of ﬁnite partial functions from κ × ω into {0, 1}. Let
G be an M-generic ﬁlter on P. By Lemma 5.5.7 and Theorem 5.5.8, M[G] is a
countable transitive model of ZFC which includes M and has the same ordinals
as M. By Lemma 5.6.8 P is c.c.c. By Lemma 5.6.5 M[G] has the same cardinals
as M.
Put g = S G. As in the proof of Theorem 5.5.20 we see that g ∈M[G] and
g : κ × ω →{0, 1}. For α < κ deﬁne gα : ω →{0, 1} by gα(n) = g((α, n)). We
claim that gα ̸= gβ for all α < β < κ. To see this, let Dαβ be the set of p ∈P
such that p((α, n)) ̸= p((β, n)) for some n ∈ω such that (α, n), (β, n) ∈dom(p).
Clearly Dαβ ∈M and is dense open. Hence G ∩Dαβ ̸= ∅. Hence gα ̸= gβ.
It is now clear that M[G] |= 2ℵ0 ≥˙κ. Thus we may take M ′ = M[G].
113

Chapter 6
Topics in Set Theory
6.1
Stationary Sets
Deﬁnition 6.1.1. Let S be a set of ordinals. We say that S is unbounded in a
limit ordinal δ if sup(S ∩δ) = δ. We say that S is closed in κ if S ⊆κ and, for
all limit ordinals δ < κ, if S is unbounded in δ then δ ∈S. A closed unbounded
set in κ (sometimes called a club of κ) is any subset of κ which is closed in κ
and unbounded in κ.
Lemma 6.1.2. Let κ be a regular uncountable cardinal.
1. If Ci, i ∈I, is a collection of closed unbounded sets in κ, and if |I| < κ,
then T
i∈I Ci is again a closed unbounded set in κ.
2. If Cα, α < κ is a collection of closed unbounded sets in κ indexed by the
ordinals less than κ, then the diagonal intersection
△α<κCα = {β < κ | β ∈Cα for all α < β}
is again a closed unbounded set in κ.
Proof. Straightforward.
Deﬁnition 6.1.3. Let κ be a regular uncountable cardinal. A set S ⊆κ is said
to be stationary in κ if S ∩C ̸= ∅for every closed unbounded set C in κ.
Lemma 6.1.4. Let κ be a regular uncountable cardinal, and let S ⊆κ be
stationary in κ. Suppose S = S
i∈I Si where |I| < κ. Then Si is stationary for
some i ∈I.
Proof. Suppose the conclusion fails. Then for each i ∈I let Ci be a closed
unbounded set such that Si ∩Ci = ∅. By Lemma 6.1.2.1, C = T
i∈I Ci is a
closed unbounded set. Since S is stationary, S ∩C is nonempty, say α ∈S ∩C.
Then for each i ∈I we have α /∈Si, a contradiction.
114

Theorem 6.1.5 (Fodor’s Theorem). Let κ be a regular uncountable cardinal,
and let S ⊆κ be stationary in κ. Suppose f : S →κ is such that f(α) < α for
all α ∈S. Then f is constant on a stationary set. In other words, there exist a
stationary S0 ⊆S and a β0 < κ such that f(α) = β0 for all α ∈S0.
Proof. Similar to the proof of the previous lemma, using 6.1.2.2 instead of
6.1.2.1. The details are left as an exercise for the reader.
Theorem 6.1.6. For any regular uncountable cardinal κ, there exists a sta-
tionary set S ⊆κ such that κ \ S is also stationary.
Proof. . . .
We state without proof the following theorem of Solovay.
Theorem 6.1.7. Let κ be a regular uncountable cardinal. Any stationary set
S ⊆κ can be decomposed into κ pairwise disjoint stationary sets.
6.2
Large Cardinals
Deﬁnition 6.2.1 (hyperinaccessible cardinals). For each n < ω we deﬁne a
class of cardinals called the n-hyperinaccessible cardinals. We deﬁne κ to be 0-
hyperinaccessible if it is inaccessible. We deﬁne κ to be n+1-hyperinaccessible
if it is inaccessible and
{λ < κ | λ is n-hyperinaccessible}
is unbounded in κ.
Deﬁnition 6.2.2 (Mahlo cardinals). For each n < ω we deﬁne a class of cardi-
nals called the n-Mahlo cardinals. We deﬁne κ to be 0-Mahlo if it is inaccessible.
We deﬁne κ to be n+1-Mahlo if it is inaccessible and {λ < κ | λ is n-Mahlo} is
stationary in κ.
Exercise 6.2.3. Show that n+1-hyperinaccessible implies n-hyperinaccessible.
Show that n+1-Mahlo implies n-Mahlo. Show that 1-Mahlo implies n-hyperinaccessible
for all n < ω.
Lemma 6.2.4. Let δ be a limit ordinal. Suppose κ < δ and n < ω. Then κ is
n-hyperinaccessible if and only if Rδ satisﬁes “κ is n-hyperinaccessible.” Also,
κ is n-Mahlo if and only if Rδ satisﬁes “κ is n-Mahlo.”
Proof. Straightforward.
Theorem 6.2.5.
1. The existence of an n+1-hyperinaccessible cardinal is not provable in ZFC
+ “for all α there exists κ > α such that κ is n-hyperinaccessible” (as-
suming this theory is consistent).
115

2. The existence of an n+1-Mahlo cardinal is not provable in ZFC + “for
all α there exists κ > α such that κ is n-Mahlo” (assuming this theory is
consistent).
Proof. Straightforward using the previous lemma.
Lemma 6.2.6.
1. If κ is a cardinal, then L satisﬁes “κ is a cardinal.”
2. If κ is a regular cardinal, then L satisﬁes “κ is a regular cardinal.”
3. If κ is n-hyperinaccessible, then L satisﬁes “κ is n-hyperinaccessible.”
4. If κ is n-Mahlo, then L satisﬁes “κ is n-Mahlo.”
Proof. Straightforward.
Theorem 6.2.7.
1. If ZFC + “there exists an n-hyperinaccessible cardinal” is consistent, then
so is ZFC + V = L + “there exists an n-hyperinaccessible cardinal.”
2. If ZFC + “there exists an n-Mahlo cardinal” is consistent, then so is ZFC
+ V = L + “there exists an n-Mahlo cardinal.”
Proof. Straightforward using the previous lemma.
6.3
Ultraﬁlters and Ultraproducts
Deﬁnition 6.3.1. Let I be a nonempty set. A ﬁlter on I is a set F ⊆P(I)
such that
1. ∅/∈F and I ∈F;
2. if X1, . . . , Xn ∈F then X1 ∩. . . ∩Xn ∈F;
3. if X ∈F and X ⊆Y ∈P(I) then Y ∈F.
Examples 6.3.2.
1. F = {I}.
2. F = {X ⊆I | X ⊇X0}, where ∅̸= X0 ⊆I. Such an F is called a
principal ﬁlter.
3. F = {X ⊆I | X is coﬁnite, i.e., I \ X is ﬁnite} (assuming I is inﬁnite).
4. F = {X ⊆I | |I \ X| < κ}, where κ is any inﬁnite cardinal ≤|I|.
5. I = Rn, F = {X ⊆Rn | Rn \ X has Lebesgue measure 0}. Here we could
replace Rn by any measure space.
116

6. I = Rn, F = {X ⊆Rn | Rn \ X is meager}. Here we could replace Rn by
any complete metric space.
7. Let I = κ where κ is a regular uncountable cardinal. Then
F = {X ⊆κ | X ⊇C for some closed unbounded set C ⊆κ}
is a ﬁlter, known as the closed unbounded ﬁlter on κ.
8. Let A be an uncountable set. Put
I = Pc(A) = {Y ⊆A | Y is countable} .
Recall that A<ω is the set of ﬁnite sequences of elements of A. Given
f : A<ω →A, put
Cf = {Y ∈Pc(A) | Y is closed under f, i.e., f[Y <ω] ⊆Y } .
Then
Fc(A) = {X ⊆Pc(A) | X ⊇Cf for some f}
is a ﬁlter known as the closed unbounded ﬁlter on Pc(A).
Deﬁnition 6.3.3. Let κ be an inﬁnite cardinal. A ﬁlter F is said to be κ-
additive if T
i∈I Xi ∈F whenever Xi ∈F for all i ∈I, |I| < κ.
Examples 6.3.4.
1. Every ﬁlter is ﬁnitely additive, i.e., ℵ0-additive.
2. The Lebesgue and Baire ﬁlters on Rn are countably additive, i.e., ℵ1-
additive.
3. For any inﬁnite cardinal κ ≤|I|, the ﬁlter {X ⊆I | |I −X| < κ} is
κ-additive.
4. For any regular uncountable cardinal κ, the closed unbounded ﬁlter on κ
is κ-additive.
5. For any uncountable set A, the closed unbounded ﬁlter on Pc(A) is count-
ably additive.
Deﬁnition 6.3.5. An ultraﬁlter on I is a ﬁlter U on I such that for all X ⊆I
either X ∈U or I \ X ∈U.
Remark 6.3.6. The ﬁlters in 6.3.2.3–8 are not ultraﬁlters. Indeed, it is diﬃ-
cult to ﬁnd explicit examples of nonprincipal ultraﬁlters. However, as we shall
now show, nonprincipal ultraﬁlters can be constructed by means of transﬁnite
recursion plus the Axiom of Choice.
Theorem 6.3.7. Any ﬁlter F on I can be extended to an ultraﬁlter U on I.
117

Proof. Say that G ⊆P(I) has the ﬁnite intersection property (f.i.p.) if Y1 ∩. . .∩
Ym ̸= ∅for all Y1, . . . , Ym ∈G.
By the well-ordering theorem, let κ = |P(I)|, say
P(I) = {Xα | α < κ} .
We shall use transﬁnite recursion to deﬁne a sequence of sets Fα ⊆P(I), α ≤κ,
each of which has the f.i.p.
Stage 0. Put F0 = F. Note that F has the f.i.p. since it is a ﬁlter.
Stage α + 1.
Assume inductively that Fα has the f.i.p.
We claim that
at least one of Fα ∪{Xα}, Fα ∪{I \ Xα} has the f.i.p. Otherwise we would
have Xα ∩Y1 ∩. . . ∩Ym = ∅, Y1, . . . , Ym ∈Fα, (I \ Xα) ∩Z1 ∩. . . ∩Zm = ∅,
Z1, . . . , Zn ∈Fα. Then Y1 ∩. . . ∩Ym ∩Z1 ∩. . . ∩Zn = ∅so Fα does not have
the f.i.p., a contradiction. We therefore set
Fα+1 =
(
Fα ∪{Xα}
if this has the f.i.p.,
Fα ∪{I \ Xα}
otherwise.
Then clearly Fα+1 has the f.i.p.
Stage δ, where δ is a limit ordinal. Put Fδ = S
α<δ Fα. Clearly this has the
f.i.p.
Finally put U = Fκ = S
α<κ Fα.
Clearly U has the f.i.p. and for every
X ∈P(I) either X ∈U or I \ X ∈U. It follows easily that U is an ultraﬁlter.
This completes the proof.
Lemma 6.3.8. Any principal ultraﬁlter U on I is of the form
U = {X ⊆I | i0 ∈X}
for some ﬁxed i0 ∈I.
Proof. Let U be a principal ultraﬁlter on I. By deﬁnition we have
U = {X ⊆I | X ⊇X0}
where ∅̸= X0 ⊆I. If |X0| ≥2, let Y ⊆I be such that Y ∩X0 ̸= ∅and
(I \ Y ) ∩X0 ̸= ∅. Then Y, I \ Y /∈U, a contradiction. Thus |X0| = 1, i.e.,
X0 = {i0} for some i0 ∈I. This proves the lemma.
Theorem 6.3.9. For every inﬁnite set I there exists a nonprincipal ultraﬁlter
U on I.
Proof. Consider the ﬁlter F = {X ⊆I | I\X is ﬁnite}. By Theorem 6.3.7, let U
be an ultraﬁlter on I such that F ⊆U. For all i0 ∈I we have I \ {i0} ∈F ⊆U,
hence {i0} /∈U. Thus U is nonprincipal.
Deﬁnition 6.3.10. A structure is a relational structure, i.e., an ordered pair
(A, E) where A is a nonempty set and E ⊆A × A.
118

Deﬁnition 6.3.11 (ultraproduct). Suppose we are given an indexed family of
structures ⟨(Ai, Ei)⟩i∈I and an ultraﬁlter U on the index set I. We are going to
deﬁne a structure
(A, E) =
Y
U
⟨(Ai, Ei)⟩i∈I
known as an ultraproduct. Recall that
Y
i∈I
Ai =
(
f
 f : I →
[
i∈I
Ai, f(i) ∈Ai for all i ∈I
)
.
For f, g ∈Q
i∈I Ai deﬁne
f ≈g
⇔def
f ≈U g
⇔def
{i ∈I | f(i) = g(i)} ∈U .
This is an equivalence relation. We deﬁne
[f] =def [f]U =def
(
g ∈
Y
i∈I
Ai
 f ≈U g
)
and
A =
Y
U
⟨Ai⟩i∈I =
Y
i∈I
Ai

U =
(
[f]U
 f ∈
Y
i∈I
Ai
)
.
Finally, for f, g ∈Q
i∈I Ai, we deﬁne
([f], [g]) ∈E ⇔def {i ∈I | (f(i), g(i)) ∈Ei} ∈U .
Note that this last deﬁnition is independent of representatives, i.e., f ≈f ′,
g ≈g′, ([f], [g]) ∈E imply ([f ′], [g′]) ∈E. Thus E ⊆A × A is well-deﬁned, and
so (A, E) is a structure.
Theorem 6.3.12 ( Lo´s’s Theorem). Let (A, E) = Q
U⟨(Ai, Ei)⟩i∈I be an ultra-
product. Let ψ(x1, . . . , xk) be a formula with free variables among x1, . . . , xk.
Then for all [f1], . . . , [fk] ∈A we have
|=(A,E) ψ([f1], . . . , [fk]) ⇔{i ∈I | |=(Ai,Ei) ψ(f1(i), . . . , fk(i))} ∈U .
6.4
Measurable Cardinals
6.5
Ramsey’s Theorem
119

Index
Rα, 87
∆0
n predicate, 44
Π0
n predicate, 41
Σ0
n predicate, 41
ℵα, 84
↓, 23
κ-additive, 117
ω, 75
ωα, 84
≃, 23
↑, 23
 Lo´s’s theorem, 119
Ackermann function, 13, 25, 30, 33, 39
additive, 117
additively indecomposable ordinal, 80
arithmetic, 48
cardinal, 73
language of, 48
ordinal, 75, 79, 80
arithmetical deﬁnability, 50–56, 59
arithmetical hierarchy, 41–47, 56
arithmetical truth, 58, 59
axioms
of set theory, 92–96
axiom of choice, 94, 97, 101, 106
axiom of inﬁnity, 94
axiom scheme, 95
Boolean connective, 9, 49
bounded
least number operator, 10
quantiﬁer, 10
Cantor’s theorem, 73
cardinal
hyperinaccessible, 115
inaccessible, 86
limit, 85
Mahlo, 115
regular, 85
singular, 86
strong limit, 85
successor, 85
uncountable, 85
weakly inaccessible, 86
cardinal arithmetic, 73
cardinal number, 71–74, 81–86
cases
deﬁnition by, 28, 63
Cauchy sequence, 90
CH, 85, 97
characteristic function, 9
Chinese remainder theorem, 53
Church’s thesis, 33
class, 78
closed, 114
closed unbounded ﬁlter, 117
club, 114
coﬁnality, 86
complete, 46
comprehension, 95, 101
computable function, 17–23
connective
Boolean, 9, 49
propositional, 49
consequence
logical, 97
consistency, 97
relative, 107
constructible set, 103–107
Continuum Hypothesis, 85
continuum hypothesis, 85, 97, 106
Continuum Problem, 85
120

continuum problem, 85, 97
convergent, 23
countably additive, 117
course-of-values recursion, 12
decidability, 67
Def, 98
deﬁnability
arithmetical, 50–56, 59
over the real number system, 60
over a relational structure, 98
over the real number system, 66
deﬁned, 23
deﬁnition by cases, 28, 63
dense open set, 107
diagonal intersection, 114
divergent, 23
eﬀective function, 61
enumeration theorem, 28
equivalence relation, 90
extensionality, 92, 94, 97, 100
f.i.p., 118
falsity, 49
ﬁlter, 107, 116
closed unbounded, 117
principal, 116
ﬁnitely additive, 117
ﬁnite intersection property, 118
Fodor’s theorem, 115
forcing, 108
formula, 48, 60, 92
function, 89
computable, 17–23
eﬀective, 61
limit-recursive, 44
number-theoretic, 6
partial, 23
partial recursive, 23
primitive recursive, 6–13, 30
recursive, 23
total, 23
G¨odel number
of a formula, 57
of a program, 26, 27
GCH, 85, 107
generalized continuum hypothesis, 85,
106
halting problem, 35, 37
Hilbert’s 10th problem, 35
Hilbert’s 17th problem, 61
hyperinaccessible cardinal, 115
inaccessible cardinal, 86, 101–103
index
of a partial recursive function, 26,
27
induction
transﬁnite, 78
initial ordinal, 82
isomorphism, 74
K¨onig’s Theorem, 74
L, 103, 106
L¨owenheim/Skolem theorem, 99
language
of arithmetic, 48
of ordered rings, 60
of set theory, 92–96
least number operator, 23
bounded, 10
limit-recursive function, 44
limit cardinal, 85
limit ordinal, 80
linear ordering, 75
logical consequence, 97
Mahlo cardinal, 115
minimization, 24, 30
model, 97
number
cardinal, 71–74, 81–86
ordinal, 75, 89
number systems, 90
ordered ﬁeld, 60
ordered pair, 70, 89
ordering
121

linear, 75
well, 75
ordinal, 75, 89
additively indecomposable, 80
initial, 82
limit, 80
successor, 80
von Neumann, 89
ordinal arithmetic, 75, 79, 80
ordinal number, 75, 89
parameter, 98
parametrization theorem, 36
partial function, 23
partial recursive function, 23, 32
power set, 93, 101
predicate, 9
primitive recursive
function, 6–13, 30
predicate, 9
principal ﬁlter, 116
principal function, 43
program, 17
propositional connective, 49
pure set, 87, 92, 93, 96, 97, 102, 104
quantiﬁer, 49
bounded, 10
quantiﬁer elimination, 60, 66
real number system, 60, 90
real world, 92, 93, 97
recursion
course-of-values, 12
primitive, 6
transﬁnite, 78
recursion theorem, 39
recursively enumerable set, 44
recursive function, 23
reducible, 36
register machine program, 17
regular cardinal, 85
relational structure, 74, 96
relative consistency, 107
replacement, 95, 101
Rice’s theorem, 38
scheme, 95
sentence, 49
set theory
axioms of, 92–96
language of, 92–96
models of, 93, 96, 97, 99–104
singular cardinal, 86
Skolem paradox, 99
Solovay, 115
state, 29
stationary, 114
strong limit cardinal, 85
structure
arithmetic, 48
real number system, 60
relational, 74, 96
successor cardinal, 85
successor ordinal, 80
term, 48
total function, 23
transﬁnite induction, 78
transﬁnite recursion, 78
transitive model, 99–103
transitive set, 87, 99
truth
arithmetical, 49, 58, 59
ultraﬁlter, 117
ultraproduct, 119
unbounded, 114
uncountable cardinal, 85
undecidability, 58
undeﬁned, 23
universal
Σ0
n predicate, 45
register machine program, 28
unsolvable problem, 34–39, 58
V , 88
von Neumann ordinal, 89
weakly inaccessible cardinal, 86
well-founded, 75
well-ordering, 75
well-ordering theorem, 81
122

word problem, 35
Zermelo/Fraenkel set theory, 96
ZF, 96
ZFC, 96
123

