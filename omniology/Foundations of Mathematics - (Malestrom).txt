Copyright câƒ1995â€“2007 by Stephen G. Simpson
Foundations of Mathematics
Stephen G. Simpson
October 16, 2008
Department of Mathematics
The Pennsylvania State University
University Park, State College PA 16802
simpson@math.psu.edu
This is a set of lecture notes for my course, Foundations of Mathematics I,
oï¬€ered as Mathematics 558 at the Pennsylvania State University, most recently
in Spring 2007.
1

Contents
1
Computable Functions
6
1.1
Primitive Recursive Functions . . . . . . . . . . . . . . . . . . . .
6
1.2
The Ackermann Function
. . . . . . . . . . . . . . . . . . . . . .
13
1.3
Computable Functions . . . . . . . . . . . . . . . . . . . . . . . .
17
1.4
Partial Recursive Functions . . . . . . . . . . . . . . . . . . . . .
23
1.5
The Enumeration Theorem
. . . . . . . . . . . . . . . . . . . . .
25
1.6
Consequences of the Enumeration Theorem . . . . . . . . . . . .
30
1.7
Unsolvable Problems . . . . . . . . . . . . . . . . . . . . . . . . .
34
1.8
The Recursion Theorem . . . . . . . . . . . . . . . . . . . . . . .
39
1.9
The Arithmetical Hierarchy . . . . . . . . . . . . . . . . . . . . .
41
2
Undecidability of Arithmetic
48
2.1
Terms, Formulas, and Sentences . . . . . . . . . . . . . . . . . . .
48
2.2
Arithmetical Deï¬nability . . . . . . . . . . . . . . . . . . . . . . .
50
2.3
GÂ¨odel Numbers of Formulas . . . . . . . . . . . . . . . . . . . . .
57
3
The Real Number System
60
3.1
Quantiï¬er Elimination . . . . . . . . . . . . . . . . . . . . . . . .
60
3.2
Decidability of the Real Number System . . . . . . . . . . . . . .
66
4
Informal Set Theory
69
4.1
Operations on Sets . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.2
Cardinal Numbers
. . . . . . . . . . . . . . . . . . . . . . . . . .
71
4.3
Well-Orderings and Ordinal Numbers
. . . . . . . . . . . . . . .
74
4.4
Transï¬nite Recursion . . . . . . . . . . . . . . . . . . . . . . . . .
78
4.5
Cardinal Numbers, Continued . . . . . . . . . . . . . . . . . . . .
81
4.6
Cardinal Arithmetic
. . . . . . . . . . . . . . . . . . . . . . . . .
83
4.7
Some Classes of Cardinals . . . . . . . . . . . . . . . . . . . . . .
85
4.8
Pure Well-Founded Sets . . . . . . . . . . . . . . . . . . . . . . .
87
4.9
Set-Theoretic Foundations . . . . . . . . . . . . . . . . . . . . . .
88
5
Axiomatic Set Theory
92
5.1
The Axioms of Set Theory . . . . . . . . . . . . . . . . . . . . . .
92
5.2
Models of Set Theory
. . . . . . . . . . . . . . . . . . . . . . . .
96
2

5.3
Transitive Models and Inaccessible Cardinals
. . . . . . . . . . .
99
5.4
Constructible Sets
. . . . . . . . . . . . . . . . . . . . . . . . . . 103
5.5
Forcing
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
5.6
Independence of CH . . . . . . . . . . . . . . . . . . . . . . . . . 111
6
Topics in Set Theory
114
6.1
Stationary Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
6.2
Large Cardinals . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
6.3
Ultraï¬lters and Ultraproducts . . . . . . . . . . . . . . . . . . . . 116
6.4
Measurable Cardinals
. . . . . . . . . . . . . . . . . . . . . . . . 119
6.5
Ramseyâ€™s Theorem . . . . . . . . . . . . . . . . . . . . . . . . . . 119
3

List of Figures
1.1
Register Machine Instructions . . . . . . . . . . . . . . . . . . . .
18
1.2
An Addition Program . . . . . . . . . . . . . . . . . . . . . . . .
18
1.3
The Initial Functions . . . . . . . . . . . . . . . . . . . . . . . . .
19
1.4
Generalized Composition
. . . . . . . . . . . . . . . . . . . . . .
20
1.5
A Multiplication Program . . . . . . . . . . . . . . . . . . . . . .
21
1.6
Primitive Recursion
. . . . . . . . . . . . . . . . . . . . . . . . .
22
1.7
Minimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
1.8
A Program with Labeled Instructions
. . . . . . . . . . . . . . .
27
1.9
Incrementing Pi . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.10 Decrementing Pi
. . . . . . . . . . . . . . . . . . . . . . . . . . .
31
1.11 Stopping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
1.12 Parametrization . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
4

List of Tables
1.1
The Ackermann branches. . . . . . . . . . . . . . . . . . . . . . .
14
5

Chapter 1
Computable Functions
We use N to denote the set of natural numbers,
N = {0, 1, 2, . . .} .
For k â‰¥1, the k-fold Cartesian product
N Ã— . . . Ã— N
|
{z
}
k
is denoted Nk. A k-place function is a function f : Nk â†’N and is sometimes
indicated with the lambda-notation,
f = Î»x1 Â· Â· Â· xk [ f(x1, . . . , xk) ] .
A number-theoretic function is a k-place function for some k â‰¥1.
The purpose of this chapter is to deï¬ne and study an important class of
number-theoretic functions, the recursive functions (sometimes called the com-
putable functions). We begin with a certain subclass known as the primitive
recursive functions.
1.1
Primitive Recursive Functions
Loosely speaking, a recursion is any kind of inductive deï¬nition, and a primitive
recursion is an especially straightforward kind of recursion, in which the value
of a number-theoretic function at argument x + 1 is deï¬ned in terms of the
value at argument x. For example, the factorial function Î»x [ x! ] is deï¬ned by
the primitive recursion equations 0! = 1, (x + 1)! = x!(x + 1).
A number-
theoretic function is said to be primitive recursive if it can be built up by means
of primitive recursions. This concept is made precise in the following deï¬nition.
Deï¬nition 1.1.1 (Primitive Recursive Functions). The class PR of primitive
recursive functions is the smallest class C of number-theoretic functions having
the following closure properties.
6

1. The constant zero function Z = Î»x [ 0 ] belongs to C.
2. The successor function S = Î»x [ x + 1 ] belongs to C.
3. For each k â‰¥1 and 1 â‰¤i â‰¤k, the projection function Pki = Î»x1 Â· Â· Â· xk [ xi ]
belongs to C.
4. C is closed under generalized composition. This means that whenever the
k-place functions
Î»x1 Â· Â· Â· xk [ g1(x1, . . . , xk) ], . . . , Î»x1 Â· Â· Â· xk [ gm(x1, . . . , xk) ]
and the m-place function Î»y1 Â· Â· Â· ym [ h(y1, . . . , ym) ] all belong to C, then
the k-place function
f = Î»x1 Â· Â· Â· xk [ h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)) ]
also belongs to C. Here f is deï¬ned by
f(x1, . . . , xk) = h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)) .
5. C is closed under primitive recursion.
This means that whenever the
k-place function Î»x1 Â· Â· Â· xk [ g(x1, . . . , xk) ] and the (k+2)-place function
Î»yzx1 Â· Â· Â· xk [ h(y, z, x1, . . . , xk) ]
belong to C, then the (k+1)-place function Î»yx1 Â· Â· Â· xk [ f(y, x1, . . . , xk) ]
deï¬ned by
f(0, x1, . . . , xk)
=
g(x1, . . . , xk)
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk)
also belongs to C.
We now list some examples of primitive recursive functions.
Examples 1.1.2.
1. The recursion equations
x + 0
=
x
x + (y + 1)
=
(x + y) + 1
show that the addition function Î»xy [ x + y ] is primitive recursive.
2. The recursion equations
x Â· 0
=
0
x Â· (y + 1)
=
(x Â· y) + x
show that the multiplication function Î»xy [ x Â· y ] is primitive recursive.
7

3. The recursion equations
x0
=
1
xy+1
=
xy Â· x
show that the exponentiation function Î»xy [ xy ] is primitive recursive.
4. As already mentioned, the recursion equations
0!
=
1
(x + 1)!
=
x! Â· (x + 1)
show that the factorial function Î»x [ x! ] is primitive recursive.
We now proceed to further enlarge our library of primitive recursive func-
tions. First, the recursion equations P(0) = 0, P(x + 1) = x show that the
â€œpredecessorâ€ function
P(x) =

x âˆ’1
if x > 0 ,
0
if x = 0
is primitive recursive. We can then obtain the truncated subtraction function
x Â·âˆ’y =
 x âˆ’y
if x â‰¥y ,
0
if x < y
using primitive recursion equations x Â·âˆ’0 = x, x Â·âˆ’(y+1) = P(x Â·âˆ’y). (Truncated
subraction is useful because ordinary subtraction is not a function from N2 into
N.) We shall also have use for
|x âˆ’y| = (x Â·âˆ’y) + (y Â·âˆ’x)
and Î±(x) = 1 Â·âˆ’x. Note that
Î±(x) =

0
if x > 0 ,
1
if x = 0 .
The following exercise will become easy after we have developed a little more
machinery.
Exercise 1.1.3. Show that the Fibonacci function, deï¬ned by
ï¬b(0)
=
0 ,
ï¬b(1)
=
1 ,
ï¬b(x + 2)
=
ï¬b(x) + ï¬b(x + 1)
is primitive recursive. (The ï¬rst few values of this function are 0, 1, 1, 2, 3, 5,
8, 13, 21, 34, 55, . . . .)
8

In addition to primitive recursive functions, we shall want to consider prim-
itive recursive predicates. By a k-place predicate we mean a subset of Nk. If
R âŠ†Nk is a k-place predicate and x1, . . . , xk are elements of N, we say that
R(x1, . . . , xk) is true if âŸ¨x1, . . . , xkâŸ©âˆˆR, otherwise false. A number-theoretic
predicate is a k-place predicate for some k â‰¥1.
Deï¬nition 1.1.4. A k-place predicate R âŠ†Nk is said to be primitive recursive
if its characteristic function
Ï‡R(x1, . . . , xk) =
 1
if R(x1, . . . , xk) is true
0
if R(x1, . . . , xk) is false
is primitive recursive.
For example, the 2-place predicates x = y and x < y are primitive recursive,
since Ï‡=(x, y) = Î±(|x âˆ’y|) and Ï‡<(x, y) = Î±(Î±(y Â·âˆ’x)).
Lemma 1.1.5 (Boolean Connectives). If P and Q are primitive recursive pred-
icates, then so are Â¬ P, P âˆ§Q, and P âˆ¨Q. (Here Â¬ , âˆ§, and âˆ¨denote negation,
conjunction, and (nonexclusive) disjunction, respectively.)
Proof. We have Ï‡Â¬ P = Î±(Ï‡P ) and Ï‡P âˆ§Q = Ï‡P Â· Ï‡Q. Also
Ï‡P âˆ¨Q = Î±(Î±(Ï‡P ) Â· Î±(Ï‡Q))
since P âˆ¨Q â‰¡Â¬ ((Â¬ P) âˆ§(Â¬ Q)) (de Morganâ€™s law).
Lemma 1.1.6 (Iterated Sums and Products). If f(x, y, z1, . . . , zk) is a primitive
recursive function, then so are
g(y, z1, . . . , zk) =
yâˆ’1
X
x=0
f(x, y, z1, . . . , zk)
(= 0 if y = 0)
and
h(y, z1, . . . , zk) =
yâˆ’1
Y
x=0
f(x, y, z1, . . . , zk)
(= 1 if y = 0) .
Proof. We have g(y, z1, . . . , zk) = gâˆ—(y, y, z1, . . . , zk) where
gâˆ—(w, y, z1, . . . , zk) =
wâˆ’1
X
x=0
f(x, y, z1, . . . , zk) .
The recursion equations
gâˆ—(0, y, z1, . . . , zk)
=
0
gâˆ—(w + 1, y, z1, . . . , zk)
=
gâˆ—(w, y, z1, . . . , zk) + f(w, y, z1, . . . , zk)
show that gâˆ—is primitive recursive, hence g is primitive recursive. The treatment
of h is similar.
9

Lemma 1.1.7 (Finite Conjuction and Disjunction). If R(x, y, z1, . . . , zk) is a
primitive recursive predicate, then so are
P(y, z1, . . . , zk) â‰¡
yâˆ’1
^
x=0
R(x, y, z1, . . . , zk)
and
Q(y, z1, . . . , zk) â‰¡
yâˆ’1
_
x=0
R(x, y, z1, . . . , zk) .
Proof. We have
Ï‡P (y, z1, . . . , zk) =
yâˆ’1
Y
x=0
Ï‡R(x, y, z1, . . . , zk)
and
Ï‡Q(y, z1, . . . , zk) = Î±
 yâˆ’1
Y
x=0
Î±(Ï‡R(x, y, z1, . . . , zk))
!
so our result follows from the previous lemma.
Note that Vyâˆ’1
x=0 and Wyâˆ’1
x=0 can be paraphrased as â€œfor all x in the range
0 â‰¤x < yâ€ and â€œthere exists x in the range 0 â‰¤x < yâ€, respectively. These
operators are sometimes called bounded quantiï¬ers.
The above lemmas make it easy to show that many familiar predicates are
primitive recursive. For example, the set (i.e., 1-place predicate) of prime num-
bers is primitive recursive, since
Prime (x)
â‰¡
x is a prime number
â‰¡
x > 1 âˆ§Â¬ W
u<x
W
v<x (x = u Â· v âˆ§u > 1 âˆ§v > 1) .
Similarly, the following lemma can be used to show that many familiar func-
tions are primitive recursive.
Lemma 1.1.8 (Bounded Least Number Operator). If R(x, y, z1, . . . , zk) is a
primitive recursive predicate, then the function
f(y, z1, . . . , zk) =
ï£±
ï£²
ï£³
least x < y such that R(x, y, z1, . . . , zk) holds ,
if such x exists ,
y otherwise
is primitive recursive.
Proof. We have
f(y, z1, . . . , zk)
=
Pyâˆ’1
x=0

x Â· Ï‡R(x, y, z1, . . . , zk) Â· Qxâˆ’1
w=0 Î±(Ï‡R(w, y, z1, . . . , zk))

+ y Â· Qyâˆ’1
x=0 Î±(Ï‡R(x, y, z1, . . . , zk)) ,
so f is primitive recursive.
10

For example, consider the function Î»n [ pn ] which enumerates the prime
numbers in increasing order. (The ï¬rst few values of this function are p0 = 2,
p1 = 3, p2 = 5, p3 = 7, . . . .) We want to use the bounded least number operator
to show that Î»n [ pn ] is primitive recursive. First, recall a famous theorem of
Euclid which gives the bound pn+1 â‰¤pn!+1. We can then write p0 = 2, pn+1 =
least x â‰¤pn! + 1 such that Prime (x) and x > pn. Thus Î»n [ pn ] is primitive
recursive.
As another application of the bounded least number operator, note that the
functions
Quotient (y, x)
=
âŒŠy/xâŒ‹
=
q ,
Remainder (y, x)
=
(y mod x)
=
r ,
where y = q Â· x + r, 0 â‰¤r < x, 0 â‰¤q, are primitive recursive, in view of
Quotient (y, x)
=
least q â‰¤y such that W
r<x(y = q Â· x + r) ,
Remainder (y, x)
=
least r < x such that W
qâ‰¤y(y = q Â· x + r) .
Using the bounded least number operator, we can obtain a primitive recur-
sive method of encoding ordered pairs of natural numbers as single numbers.
For our pairing function we use Î»uv [ 2u3v ]. The unpairing functions are then
Î»z [ (z)0 ] and Î»z [ (z)1 ], where
(z)n
=
least w < z such that Remainder(z, pw+1
n
) Ì¸= 0
=
the exponent of pn in the prime power factorization of z .
Note that (2u3v)0 = u and (2u3v)1 = v.
More generally, we can encode variable-length ï¬nite sequences of natural
numbers as single numbers. The sequence âŸ¨a0, a1, . . . , amâˆ’1âŸ©is encoded by
a =
Y
x<m
pax
x ,
and for decoding we can use the primitive recursive function Î»zx [ (z)x ], since
(a)x = ax. This method of prime power coding will be used extensively in the
proof of the Enumeration Theorem, below.
The pairing and unpairing functions make it easy to show that the Fibonacci
function is primitive recursive (cf. Exercise 1.1.3). Namely, we ï¬rst note that
the auxiliary function Î»x [ ï¬bpair(x) ], deï¬ned by
ï¬bpair(x) = 2ï¬b(x)3ï¬b(x+1) ,
is primitive recursive in view of
ï¬bpair(0)
=
2031 ,
ï¬bpair(x + 1)
=
2(ï¬bpair(x))13(ï¬bpair(x))0+(ï¬bpair(x))1 .
Then Î»x [ ï¬b(x) ] is primitive recursive since ï¬b(x) = (ï¬bpair(x))0.
11

Exercise 1.1.9. Show that the 2-place number-theoretic functions GCD(x, y)
and LCM(x, y), the greatest common divisor and least common multiple of x
and y, are primitive recursive.
Solution.
GCD(x, y) = least z â‰¤max(x, y) such that Remainder(x, z) =
Remainder(y, z) = 0. LCM(x, y) = least z â‰¤x Â· y such that Remainder(z, x) =
Remainder(z, y) = 0.
Exercise 1.1.10. Show that the 1-place number-theoretic function f(n) given
by
f(n) = 1 +
nâˆ’1
X
k=0
f(k)n
is primitive recursive.
Solution. Consider the so-called course-of-values function
ef(n) =
nâˆ’1
Y
k=0
pf(k)
k
,
i.e., ef(n) encodes the variable-length ï¬nite sequence âŸ¨f(0), f(1), . . . , f(n âˆ’1)âŸ©
via prime power coding. Then ef(n) is primitive recursive, in view of the recur-
sion equations ef(0) = 1 and
ef(n + 1) = ef(n) Â· ph(n, e
f(n))
n
,
where h(n, z) = 1 + Pnâˆ’1
k=0((z)k)n.
It now follows that f(n) = ( ef(n + 1))n
is primitive recursive.
This general technique is known as
course-of-values
recursion.
Exercise 1.1.11. Show that the function Î»n
 nth digit of
âˆš
2

is primitive
recursive.
Solution. The nth digit of
âˆš
2 is f(n) = Remainder(g(n), 10), where g(n) = the
least x < 4 Â· 102n such that (x + 1)2 > 2 Â· 102n.
Exercise 1.1.12. Show that the 1-place number-theoretic function
f(n) = the nth decimal digit of Ï€ = 3.141592 Â· Â· Â·
is primitive recursive.
Hint: You may want to use the fact that |Ï€ âˆ’a/b| > 1/b42 for all integers
a, b > 1. This result is due to K. Mahler, On the approximation of Ï€, Nederl.
Akad. Wetensch. Proc. Ser. A., 56, Indagationes Math., 15, 30â€“42, 1953.
Solution. We use the well-known series
Ï€
4 = 1 âˆ’1
3 + 1
5 âˆ’1
7 + 1
9 âˆ’Â· Â· Â· =
âˆ
X
n=0
(âˆ’1)n
2n + 1 ,
12

i.e.,
Ï€ = 4 âˆ’4
3 + 4
5 âˆ’4
7 + 4
9 âˆ’Â· Â· Â· =
âˆ
X
n=0
(âˆ’1)n4
2n + 1 .
Let Sk be the kth partial sum of this series. We have Sk = a(k)/b(k) where the
functions a(k) and b(k) are primitive recursive, namely
a(k) =
k
X
n=0
(âˆ’1)n4(2k + 1)!
2n + 1
and b(k) = (2k + 1)!. Note also that the functions
g(n, a, b) = (Âµi < 10nb) (10ia â‰¥10nb)
and
h(n, a, b) = Rem(Quot(10g(n,a,b)a, b), 10) = the nth digit of a/b
is primitive recursive. By Mahlerâ€™s result, for each n there exists k < 1050n
such that Sk and Sk+1 have the same ï¬rst n digits. Since Ï€ lies between Sk
and Sk+1, it follows that Sk and Ï€ have the same ï¬rst n digits, so in partic-
ular f(n) = the nth digit of Sk. Using the bounded least number operator,
we have f(n) = h(n, a(k(n)), b(k(n))) where k(n) = the least k < 1050n such
that Vn
m=0 g(m, a(k), b(k)) = g(m, a(k + 1), b(k + 1)). Clearly this is primitive
recursive.
1.2
The Ackermann Function
In this section we present an example of a function which is not primitive re-
cursive, yet is clearly computable in some intuitive sense. The precise concept
of computability which we have in mind will be explained in the next section.
Deï¬nition 1.2.1. We deï¬ne a sequence of 1-place functions An, n âˆˆN, as
follows:
A0(x)
=
2x,
An+1(x)
=
AnAn Â· Â· Â· An
|
{z
}
x
(1) .
Thus A0(x) = 2x, A1(x) = 2x, A2(x) = 22Â·Â·Â·2
(height x), etc.
Exercise 1.2.2 (the Ackermann hierarchy).
1. Show that, for each n, Î»x [ An(x) ] is primitive recursive.
2. Show that
(a) An(x + 1) > An(x) > x for all x â‰¥1 and all n.
13

(b) An+1(x) â‰¥An(x + 1) for all x â‰¥3 and all n.
3. Show that for each k-place primitive recursive function
Î»x1 . . . xk [ f(x1, . . . , xk) ]
there exists n such that
f(x1, . . . , xk) â‰¤An(max(3, x1, . . . , xk))
for all x1, . . . , xk.
4. Show that the 2-place function Î»nx [ An(x) ] is not primitive recursive.
This is known as the Ackermann function.
5. Show that the 3-place relation Î»nxy [ An(x) = y ] is primitive recursive.
Use this to show that the Ackermann function is computable, i.e., recur-
sive, in the sense of Section 1.3.
Solutions.
1. Show that An(1) = 2, An(2) = 4, and An+1(3) = An(4) for all n. Compute
An(x) for all n, x with n + x â‰¤8.
Solution. For all n we have An+1(1) = An(1), hence by induction An(1) =
A0(1) = 2.
Also An+1(2) = An(An(1)) = An(2), hence by induction
An(2) = A0(2) = 4.
Also, for all n and x we have An+1(x + 1) =
An(An+1(x)), in particular An+1(3) = An(An+1(2)) = An(4). Table 1.1
shows An(x) for small values of n, x.
Table 1.1: The Ackermann branches.
0
1
2
3
4
5
A0
0
2
4
6
8
10
A1
1
2
4
8
16
32
A2
1
2
4
16
216
2216
A3
1
2
4
216
22Â·Â·Â·2
(height 216)
22Â·Â·Â·2
(height 22Â·Â·Â·2
(height 216))
A4
1
2
4
22Â·Â·Â·2
(height 216)
A3(22Â·Â·Â·2
(height 216))
A5
1
2
4
A3(22Â·Â·Â·2
(height 216))
A6
1
2
4
2. Prove the following:
14

(a) An(x + 1) > An(x) > x for all x â‰¥1 and all n.
(b) An+1(x) â‰¥An(x + 1) for all x â‰¥3 and all n.
(c) For each primitive recursive function f(x1, . . . , xk) there exists n such
that An covers f, i.e.,
f(x1, . . . , xk) â‰¤An(max(3, x1, . . . , xk))
for all x1, . . . , xk.
(d) The 1-place function Î»x (Ax(x)) is not primitive recursive.
(e) The 2-place function Î»xy (Ax(y)) is not primitive recursive.
Solution. First we prove An(x + 1) > An(x) > x for x â‰¥1, by induction
on n.
For n = 0 we have A0(x + 1) = 2x + 2 > 2x = A0(x) for all
x, and A0(x) = 2x > x for x â‰¥1.
For n + 1 and x â‰¥1 we have
An+1(x + 1) = An(An+1(x)) > An+1(x) by inductive hypothesis. Thus
An+1 is strictly monotone. Since An+1(0) > 0, it follows that An+1(x) > x
for all x.
Next we prove An+1(x) â‰¥An(x+1) for x â‰¥3, by induction on x. For x = 3
we have An+1(3) = An(4) as noted above, and inductively An+1(x + 1) =
An(An+1(x)) â‰¥An(An(x+1)) â‰¥An(x+2), since An is strictly monotone
and An(x + 1) â‰¥x + 2 by what has already been proved.
Next we prove that each primitive recursive function is covered by An for
some n. We prove this by induction on the class of primitive recursive
functions. We begin by noting that the initial functions are covered by
A0.
Suppose f is obtained by generalized composition, say
f(x1, . . . , xk) = h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)).
Let n be such that An covers h and An+1 covers g1, . . . , gm. We then have
f(x1, . . . , xk)
=
h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk))
â‰¤
An(max(3, g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)))
â‰¤
An(An+1(max(3, x1, . . . , xk)))
=
An+1(max(3, x1, . . . , xk) + 1)
â‰¤
An+2(max(3, x1, . . . , xk)),
i.e., An+2 covers f.
Suppose f is obtained by primitive recursion, say
f(0, x1, . . . , xk)
=
g(x1, . . . , xk),
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk).
Let n be such that An covers h and An+1 covers g. We ï¬rst claim that
f(y, x1, . . . , xk) â‰¤An+1(y + max(3, x1, . . . , xk))
15

for all y, x1, . . . , xk.
We prove this by induction on y.
For y = 0 we
have f(0, x1, . . . , xk) = g(x1, . . . , xk) â‰¤An+1(max(3, x1, . . . , xk)). For the
inductive step we have
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk)
â‰¤
An(max(3, y, f(y, x1, . . . , xk), x1, . . . , xk)
â‰¤
An(max(3, y, An+1(y + max(3, x1, . . . , xk)), x1, . . . , xk)
=
An(An+1(y + max(3, x1, . . . , xk)))
=
An+1(y + 1 + max(3, x1, . . . , xk))
and this proves our claim. We then have
f(y, x1, . . . , xk)
â‰¤
An+1(y + max(3, x1, . . . , xk))
â‰¤
An+1(2 max(3, y, x1, . . . , xk))
â‰¤
An+1(An+2(max(3, y, x1, . . . , xk)))
=
An+2(max(3, y, x1, . . . , xk) + 1)
â‰¤
An+3(max(3, y, x1, . . . , xk)),
i.e., An+3 covers f. This completes the proof that each primitive recursive
function is covered by An for some n.
Now, if Ax(x) were primitive recursive, then Ax(x)+1 would be primitive
recursive, hence covered by An for some n â‰¥3. But then in particular
An(n) + 1 â‰¤An(max(3, n)) = An(n), a contradiction. Thus the 1-place
function Ax(x) is not primitive recursive. It follows immediately that the
2-place function Ax(y) is not primitive recursive.
3. Show that the 3-place relation
{âŸ¨x, y, zâŸ©| Ax(y) = z}
is primitive recursive.
Use this to prove that Î»xy (Ax(y)) is recursive.
Hence Î»x (Ax(x)) is recursive.
Solution. For all x, y > 0 we have
0 < y < Ax(y) = Axâˆ’1(Ax(y âˆ’1)) = Axâˆ’1(yâ€²)
where yâ€² = Ax(y âˆ’1).
Since Axâˆ’1(yâ€²) = Ax(y) â‰¥2, it follows that
0 < yâ€² < Axâˆ’1(yâ€²) = Ax(y). Repeating this step x times, we obtain a
ï¬nite sequence y0, y1, y2, . . . , yx starting with y such that
Ax(y) = Ax(y0) = Axâˆ’1(y1) = Axâˆ’2(y2) = Â· Â· Â· = A0(yx) = 2yx,
and each of y0, y1, . . . , yx is > 0 and < Ax(y). Moreover, if y > 2 then we
also have x < Ax(y). Thus the 3-place predicate Ax(y) = z can be deï¬ned
16

by course-of-values recursion on z as follows:
Ax(y) = z if and only if
(x = 0 âˆ§z = 2y) âˆ¨
(x > 0 âˆ§y = 0 âˆ§z = 1) âˆ¨
(x > 0 âˆ§y = 1 âˆ§z = 2) âˆ¨
(x > 0 âˆ§y = 2 âˆ§z = 4) âˆ¨
(x > 0 âˆ§y > 2 âˆ§x < z âˆ§âˆƒy0, y1, . . . , yx < z
(y0 = y âˆ§âˆ€i < x (yi+1 = Axâˆ’i(yi âˆ’1)) âˆ§z = 2yx)).
Actually, the function being deï¬ned by primitive recursion is
a(w) = Q{p2x3y5z | Ax(y) = z âˆ§x, y, z < w}.
In any case, it follows that the 3-place predicate Ax(y) = z is primitive
recursive.
Applying the least number operator, we see that the 2-place function
Ax(y) is recursive. It follows immediately that the 1-place function Ax(x)
is recursive.
1.3
Computable Functions
In this section we deï¬ne the class of computable (i.e., recursive) number-theoretic
functions. We show that the primitive recursive functions form a proper subclass
of the computable functions.
Our deï¬nition will be given in terms of a register machine. We assume the
existence of inï¬nitely many registers R1, R2, . . . , Ri, . . . . At any given time,
each register contains a natural number. If the number contained in Ri is 0, we
say that Ri is empty. At any given time, all but ï¬nitely many of the registers
are empty. The basic actions that the machine can perform are to increment or
decrement a register, i.e., add or subtract 1 from the number contained in it.
A register machine program consists of ï¬nitely many instructions linked to-
gether in a ï¬‚ow diagram indicating the order in which the instructions are to
be executed. There are four types of instructions: R+
i , Râˆ’
i , start, and stop.
Each program contains exactly one start instruction, which is executed ï¬rst.
An R+
i instruction is executed by incrementing Ri and then proceeding to an-
other, speciï¬ed, instruction. An Râˆ’
i
instruction is executed by testing Ri for
emptiness. If Ri is empty, we proceed to one of two speciï¬ed instructions. If Ri
is nonempty, we decrement it and then proceed to the other of the two speciï¬ed
instructions. A stop instruction causes execution of the program to halt. See
Figure 1.1.
For example, consider the addition program depicted in Figure 1.2. If we run
this program starting with natural numbers x and y in R1 and R2 respectively,
the run will eventually halt with x + y in R3.
17

start
ONML
HIJK
/
?
?
?
?
?
?
?
/ R+
i
ONML
HIJK
/
?






begin run of program
increment register Ri
?
?
?
?
?
?
?
/ Râˆ’
i
ONML
HIJK e
/
?
?
?
?
?
?
?
?






?
?
?
?
?
?
?
/ stop
ONML
HIJK
?






if Ri empty go to e,
terminate run of program
otherwise decrement Ri
Figure 1.1: Register Machine Instructions
start
ONML
HIJK
/ Râˆ’
3
ONML
HIJK
cd
ab
`g
=
e
/ Râˆ’
1
ONML
HIJK

e
/ Râˆ’
2
ONML
HIJK

e
/ stop
ONML
HIJK
R+
3
ONML
HIJK
O
R+
3
ONML
HIJK
O
Figure 1.2: An Addition Program
18

Let P be a register machine program, and let x1, . . . , xk be natural numbers,
i.e., elements of N. We write P(x1, . . . , xk) to denote the unique run of P starting
with x1 in R1, . . . , xk in Rk, and all other registers empty. Uniqueness follows
from the fact that the register machine operates deterministically.
Deï¬nition 1.3.1 (Computable Functions). A k-place number-theoretic func-
tion
Î»x1 . . . xk [ f(x1, . . . , xk) ]
is said to be computable if there exists a register machine program P which
computes it, i.e.
for all x1, . . . , xk âˆˆN, P(x1, . . . , xk) eventually halts with
y = f(x1, . . . , xk) in Rk+1.
For example, the addition program of Figure 1.2 shows that Î»x1x2 [ x1 +x2 ]
is computable.
We shall now prove that all primitive recursive functions are computable.
Lemma 1.3.2. The initial functions Z, S, and Pki, 1 â‰¤i â‰¤k, are computable.
Proof. The functions Z = Î»x [ 0 ], S = Î»x [ x + 1 ], and Pki = Î»x1 . . . xk [ xi ] are
computed by the register machine programs given in Figure 1.3.
Zero
start
ONML
HIJK
/ stop
ONML
HIJK
Successor
start
ONML
HIJK
/ Râˆ’
1
ONML
HIJK

e
/ R+
2
ONML
HIJK
/ stop
ONML
HIJK
R+
2
ONML
HIJK
O
Projection
start
ONML
HIJK
/ Râˆ’
i
ONML
HIJK

e
/ stop
ONML
HIJK
R+
k+1
WVUT
PQRS
O
Figure 1.3: The Initial Functions
19

start
ONML
HIJK

F âˆ’
1
ONML
HIJK

e
/ . . .
e / F âˆ’
k
ONML
HIJK

e
/ G1
/ Gâˆ’
1 k+1
_^]\
XYZ[

e
/ . . .
e / Gm
/ Gâˆ’
m k+1
_^]\
XYZ[

e
/ H

G+
11
ONML
HIJK

G+
1k
ONML
HIJK

H+
1
ONML
HIJK
O
H+
m
ONML
HIJK
O
...

...

F +
k+1
ONML
HIJK
/ Hâˆ’
m+1
_^]\
XYZ[
o
e

G+
m1
ONML
HIJK
G
G+
mk
ONML
HIJK
G
stop
ONML
HIJK
Figure 1.4: Generalized Composition
Lemma 1.3.3. The class of computable functions is closed under generalized
composition.
Proof. Assume that
Î»x1 . . . xk [ g1(x1, . . . , xk) ] , . . . , Î»x1 . . . xk [ gm(x1, . . . , xk) ]
and Î»y1 . . . ym [ h(y1, . . . , ym) ] are computed by register machine programs G1,
. . . , Gm, H respectively. For convenience we regard these programs as being
executed on pairwise disjoint sets of registers. We use Gj1, . . . , Gjk, Gj,k+1,
. . . to denote the registers on which Gj is executed, 1 â‰¤j â‰¤m. We use H1, . . . ,
Hm, Hm+1, . . . to denote the registers on which H is executed.
To compute Î»x1 . . . xk [ f(x1, . . . , xk) ] where
f(x1, . . . , xk) = h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk)) .
we shall use a register machine program F which we regard as being executed
on registers F1, . . . , Fk, Fk+1, . . . . In order to make it easy for F to call G1,
. . . , Gm, H, the registers of G1, . . . , Gm, H will be among the auxiliary registers
of F. (The auxiliary registers of F are the registers Fi, i â‰¥k + 2.) Actually,
the auxiliary registers of F consist precisely of the registers of G1, . . . , Gm, H.
Our program F is given in Figure 1.4.
Lemma 1.3.4. The class of computable functions is closed under primitive
recursion.
20

In proving this lemma, the idea will be to write a program containing a loop
which repeatedly calls the iterator h. Let us ï¬rst illustrate this idea with a
simple example.
Example 1.3.5. The multiplication function Î»x1x2 [ x1 Â· x2 ] is computed by
iterated addition, using the program given in Figure 1.5.
start
ONML
HIJK
/ Râˆ’
1
ONML
HIJK
e

/ Râˆ’
2
ONML
HIJK

e
/ Râˆ’
4
ONML
HIJK

e
z
stop
ONML
HIJK
R+
3
ONML
HIJK

R+
2
ONML
HIJK
O
R+
4
ONML
HIJK
D
Figure 1.5: A Multiplication Program
Exercise 1.3.6. Write a register machine program which computes the ex-
ponential function, i.e., the 2-place number-theoretic function exp(x, y) = xy.
Note that x0 = 1 for all x.
Proof of Lemma 1.3.4. Assume that Î»x1 . . . xk [ g(x1, . . . , xk) ] and
Î»yzx1 . . . xk [ h(y, z, x1, . . . , xk) ]
are computed by register machine programs G and H with registers G1, . . . ,
Gk, Gk+1, . . . and H1, H2, H3, . . . , Hk+2, Hk+3, . . . respectively. To compute
Î»yx1 . . . xk [ f(y, x1, . . . , xk) ] where
f(0, x1, . . . , xk)
=
g(x1, . . . , xk) ,
f(y + 1, x1, . . . , xk)
=
h(y, f(y, x1, . . . , xk), x1, . . . , xk) ,
we use a register machine program F with registers F1, F2, . . . , Fk+1, Fk+2,
. . . . See Figure 1.6. The auxiliary registers Fi, i â‰¥k + 3 of F consist of the
registers of G and H plus two additional registers, U and V .
Theorem 1.3.7. Every primitive recursive function is computable.
21

start
ONML
HIJK

F âˆ’
2
ONML
HIJK

e
/ V âˆ’
ONML
HIJK

e
/ . . .
e
/ F âˆ’
k+1
ONML
HIJK

e
/ V âˆ’
ONML
HIJK

e
/ G

H+
2
ONML
HIJK

V +
ONML
HIJK

F +
2
ONML
HIJK
O
V +
ONML
HIJK

F +
k+1
ONML
HIJK
O
F âˆ’
1
ONML
HIJK
e

/ Gâˆ’
k+1
WVUT
PQRS
O
z{
e
~

G+
1
ONML
HIJK
D
G+
k
ONML
HIJK
D
F +
k+2
ONML
HIJK
/ Gâˆ’
k+1
WVUT
PQRS
o
e

stop
ONML
HIJK
H+
2
ONML
HIJK

U +
ONML
HIJK

. . .
o
Hâˆ’
4
ONML
HIJK
`gfecd
}
e
o
Hâˆ’
3
ONML
HIJK
`gfecd
}
e
o
Hâˆ’
k+3
WVUT
PQRS
O
e
o
U âˆ’
ONML
HIJK

e
/ V âˆ’
ONML
HIJK

e
/ F âˆ’
2
ONML
HIJK

e
/ V âˆ’
ONML
HIJK

e
/ . . .
e
/ F âˆ’
k+1
ONML
HIJK

e
/ V âˆ’
ONML
HIJK

e
/ H

Hâˆ’
2
ONML
HIJKfecd
ab
]
e
O
V +
ONML
HIJK

U +
ONML
HIJK
O
V +
ONML
HIJK

F +
2
ONML
HIJK
O
V +
ONML
HIJK

F +
k+1
ONML
HIJK
O
F âˆ’
1
ONML
HIJK
e

/ Hâˆ’
1
ONML
HIJKfecd
ab
]
e
O
H+
1
ONML
HIJK
D
H+
3
ONML
HIJK
D
H+
k+2
WVUT
PQRS
D
F +
k+2
ONML
HIJK
/ Hâˆ’
k+3
WVUT
PQRS
o
e

stop
ONML
HIJK
Figure 1.6: Primitive Recursion
22

Proof. The above lemmas show that the computable functions form a class
which contains the initial functions and is closed under generalized composition
and primitive recursion. Since the primitive recursive functions were deï¬ned as
the smallest such class, our theorem follows.
1.4
Partial Recursive Functions
A k-place partial function is a function Ïˆ : dom(Ïˆ) â†’N where dom(Ïˆ) âŠ†Nk.
We sometimes abbreviate this as Ïˆ : Nk
P
âˆ’â†’N. We use dom(Ïˆ) and rng(Ïˆ) to
denote the domain and range of Ïˆ, respectively. If dom(Ïˆ) = Nk, we say that
Ïˆ is total. Thus a total k-place function is just what we have previously called
a k-place function.
The use of partial functions leads to expressions which may or may not have
a numerical value. (For example, Ïˆ(x1, . . . , xk) + 3 has a numerical value if
and only if âŸ¨x1, . . . , xkâŸ©âˆˆdom(Ïˆ)). If E is such an expression, we say that E is
deï¬ned or convergent (abbreviated E â†“) if E has a numerical value. We say that
E is undeï¬ned or divergent (abbreviated E â†‘) if E does not have a numerical
value. We write E1 â‰ƒE2 to mean that E1 and E2 are both deï¬ned and equal,
or both undeï¬ned.
Deï¬nition 1.4.1 (Recursive Functions and Predicates). A k-place (total) func-
tion is said to be recursive if and only if it is computable. A k-place predicate
is said to be recursive if its characteristic function is recursive.
Deï¬nition 1.4.2 (Partial Recursive Functions). A k-place partial function Ïˆ is
said to be partial recursive if it is computed by some register machine program
P. This means that, for all x1, . . . , xk âˆˆN,
Ïˆ(x1, . . . , xk) â‰ƒthe number in Rk+1 if and when P(x1, . . . , xk) stops .
In particular, Ïˆ(x1, . . . , xk) is deï¬ned if and only if P(x1, . . . , xk) eventually
stops.
Partial recursive functions arise because a particular run of a register ma-
chine program may or may not eventually stop. One way this can happen is
because of an unbounded search, as in the following lemma.
Lemma 1.4.3 (Unbounded Least Number Operator). Let P(x1, . . . , xk, y) be
a (k+1)-place recursive predicate. Then the k-place partial function Ïˆ deï¬ned
by
Ïˆ(x1, . . . , xk) â‰ƒleast y such that P(x1, . . . , xk, y) holds
is partial recursive.
23

start
ONML
HIJK

F +
k+1
ONML
HIJK
~~~~~~~
. . .
o
P âˆ’
2
ONML
HIJK
`gfecd
}
e
o
P âˆ’
1
ONML
HIJK
`gfecd
}
e
o
F âˆ’
1
ONML
HIJK

e
/ V âˆ’
ONML
HIJK

e
/ . . .
e / F âˆ’
k+1
ONML
HIJK

e
/ V âˆ’
ONML
HIJK

e
/ P
/ P âˆ’
k+2
ONML
HIJK

e
_???????
V +
ONML
HIJK

F +
1
ONML
HIJK
O
V +
ONML
HIJK

F +
k+1
ONML
HIJK
O
stop
ONML
HIJK
P +
1
ONML
HIJK
D
P +
k+1
ONML
HIJK
D
Figure 1.7: Minimization
Proof. Assume that Ï‡P is computed by a register machine program P with
registers P1, . . . , Pk, Pk+1, Pk+2, . . . . To compute Ïˆ we use a register machine
program F with registers F1, F2, . . . , Fk+1, . . . . The auxiliary registers Fi,
i â‰¥k + 2, of F are the registers of P plus an additional register V .
See
Figure 1.7.
The unbounded least number operator is sometimes called the minimization
operator. As a byproduct of the work in the next section, we shall see that all
partial recursive functions can be obtained from primitive recursive functions
by composition and minimization.
Exercise 1.4.4. Show that the function f(n) = nth digit of Ï€ is recursive.
Hint: Use an inï¬nite series such as
Ï€
4 = 1 âˆ’1
3 + 1
5 âˆ’1
7 + 1
9 âˆ’Â· Â· Â·
plus the fact that Ï€ is irrational.
Solution. This follows from Exercise 1.1.12. A solution not using Mahlerâ€™s result
is as follows.
Let Sk be the kth partial sum of the alternating series
Ï€ = 4 âˆ’4
3 + 4
5 âˆ’4
7 + 4
9 âˆ’Â· Â· Â· =
âˆ
X
n=0
(âˆ’1)n4
2n + 1 ,
24

We have Sk = a(k)/b(k) where a(k) and b(k) are primitive recursive. Since Ï€ is
irrational, it follows that for each n there exists k such that Sk and Sk+1 have
the same ï¬rst n digits. Since Ï€ lies between Sk and Sk+1, it follows that Sk and
Ï€ have the same ï¬rst n digits, so in particular f(n) = the nth digit of Sk. Note
also that the function
h(n, a, b) = nth digit of a/b
is primitive recursive. Using the least number operator, we have f(n) = h(n, a(k(n)), b(k(n)))
where k(n) = the least k such that Vn
m=0 h(m, a(k), b(k)) = h(m, a(k +1), b(k +
1)). Clearly this is recursive.
Exercise 1.4.5. Show that there exists a computable function which is not
primitive recursive. (By 1.2.2 it suï¬ƒces to show that the Ackermann function
Î»nx [ An(x) ] is computable.)
Exercise 1.4.6. Let f : N
1âˆ’1 onto
âˆ’â†’
N be a permutation of N, the set of natural
numbers. Show that if f is recursive, then the inverse permutation f âˆ’1 is also
recursive.
Solution. Using the least number operator, we have f âˆ’1(y) = the least x such
that f(x) = y.
Exercise 1.4.7. Give an example of a primitive recursive permutation of N
whose inverse is not primitive recursive.
Solution. From our study of the Ackermann function in Section 1.2, we know
that the predicate {âŸ¨x, yâŸ©| Ax(x) = y} is primitive recursive, although the one-
to-one increasing function x 7â†’Ax(x) is not. Let B be the range of x 7â†’Ax(x),
i.e., B = {y | âˆƒx (Ax(x) = y)}. Then B is primitive recursive, because y âˆˆB â‡”
Wyâˆ’1
x=0 Ax(x) = y. Note also that B is inï¬nite and coinï¬nite.
For any inï¬nite set S âŠ†N, let Ï€S : N â†’N be the principal function of S,
i.e.,
S = {Ï€S(0) < Ï€S(1) < Â· Â· Â· < Ï€S(n) < Ï€S(n + 1) < Â· Â· Â·}
where Ï€S(n) = the nth element of S. Let f be the permutation of N deï¬ned by
f(y) =
( 2Ï€âˆ’1
B (y)
if y âˆˆB,
2Ï€âˆ’1
N\B(y) + 1
if y âˆˆN \ B.
By course-of-values recursion, f is primitive recursive.
However, f âˆ’1 is not
primitive recursive, because f âˆ’1(2x) = Ï€B(x) = Ax(x).
1.5
The Enumeration Theorem
To each register machine program E we shall assign a unique number e = #(E).
This number will be called the GÂ¨odel number of E and will also be called an
index of the k-place partial recursive function which is computed by E
25

Recall that our register machine is equipped with inï¬nitely many registers
Ri, i â‰¥1. Initially all of the registers are empty except for R1, . . . , Rk which
contain the arguments x1, . . . , xk. We assume that our program E is given
as a numbered sequence of instructions I1, . . . , Il. By convention our machine
starts by executing I1 and stops when it attempts to execute the nonexistent
instruction I0. Each instruction Im, 1 â‰¤m â‰¤l, is of the form
increment Ri then go to instruction In0,
(1.0)
or
if Ri is empty go to In0, otherwise
decrement Ri then go to instruction In1.
(1.1)
Here n0 and n1 are in the range 0 â‰¤n â‰¤l. To each instruction Im we assign a
GÂ¨odel number #(Im), where
#(Im) =
(
3i Â· 5n0
for Im as in (1.0) ,
2 Â· 3i Â· 5n0 Â· 7n1
for Im as in (1.1) .
The GÂ¨odel number of the entire program E is then deï¬ned as
#(E) =
lY
m=1
p#(Im)
m
,
where p0, p1, p2, . . . are the prime numbers 2, 3, 5, . . . in increasing order.
Example 1.5.1. Let E be the program in Figure 1.8, which computes Î»x [ x+1 ].
Listing the instructions I1, I2, I3 as shown in the ï¬gure, we have
#(I1)
=
2 Â· 31 Â· 53 Â· 72 = 2 Â· 3 Â· 125 Â· 49 = 36750 ,
#(I2)
=
32 Â· 51 = 45 ,
#(I3)
=
32 Â· 50 = 9 ,
so that
#(E) = 3#(I1) Â· 5#(I2) Â· 7#(I3) = 336750 Â· 545 Â· 79 .
Lemma 1.5.2. The 1-place predicate
Program(e) â‰¡(e is the GÂ¨odel number of some register machine program)
is primitive recursive.
Proof. We have
Program(e)
â‰¡
e_
l=0
Program(e, l)
26

I1
I3
start
ONML
HIJK
/ Râˆ’
1
ONML
HIJK

e
/ R+
2
ONML
HIJK
/ stop
ONML
HIJK
R+
2
ONML
HIJK
O
I2
Figure 1.8: A Program with Labeled Instructions
where Program(e, l) says that e is the GÂ¨odel number of a register machine
program consisting of l instructions I1, . . . , Il. We then have
Program(e, l)
â‰¡
e =
lY
m=1
p(e)m
m
âˆ§
l^
m=1
e_
i=1
l_
n0=0
l_
n1=0

(e)m = 3i Â· 5n0 âˆ¨(e)m = 2 Â· 3i Â· 5n0 Â· 7n1 
,
the idea being that (e)m = #(Im). This proves the lemma.
Deï¬nition 1.5.3. We denote by Ï•(k)
e
the k-place partial computable function
which is computed by the register machine program E whose GÂ¨odel number is
e. In more detail, we deï¬ne
Ï•(k)
e (x1, Â· Â· Â· , xk) â‰ƒ
the number in Rk+1 if and when E(x1, Â· Â· Â· , xk)
stops, where e = #(E), and undeï¬ned otherwise.
Note that if e is not the GÂ¨odel number of a register machine program, then
Ï•(k)
e (x1, Â· Â· Â· , xk) is undeï¬ned for all x1, . . . , xk, so in this case Ï•(k)
e
is the empty
function.
If Ïˆ is a k-place partial recursive function, an index of Ïˆ is any number e
such that Ïˆ = Ï•(k)
e , i.e., e is the GÂ¨odel number of a program which computes Ïˆ.
Clearly Ïˆ has many diï¬€erent indices, since there are many diï¬€erent programs
which compute Ïˆ.
Exercise 1.5.4. Find an index of the function
Î±(x) =
(
1
if x = 0,
0
if x > 0.
27

Solution. Clearly the labeled program
I1
I2
start
ONML
HIJK
/ Râˆ’
1
ONML
HIJK
?
?
?
?
?
?
?
e
/ R+
2
ONML
HIJK

stop
ONML
HIJK
computes Î±. We have #(I1) = 2 Â· 31 Â· 52 Â· 70 = 150 and #(I2) = 32 Â· 50 = 9, so
an index of Î± is e = 3#(I1) Â· 5#(I2) = 3150 Â· 59. In other words, Ï•(1)
e
= Î±.
The main theorem on indices reads as follows.
Theorem 1.5.5 (The Enumeration Theorem). For each k â‰¥1, the (k+1)-place
partial function
Î»ex1 . . . xk [ Ï•(k)
e (x1, . . . , xk) ]
is partial recursive.
Remark 1.5.6. The Enumeration Theorem entails the existence of a â€œuniver-
salâ€ program, i.e., a register machine program which can emulate the action of
any other register machine program. This concept underlies the stored program
digital computer.
In the proof of the Enumeration Theorem, the following easy lemma will be
useful.
Lemma 1.5.7 (Deï¬nition by Cases). Let P1 and P2 be k-place primitive re-
cursive predicates and let f1 and f2 be k-place primitive recursive functions.
Assume that P1 and P2 are mutually exclusive and exhaustive, i.e., for each
k-tuple âŸ¨x1, . . . , xkâŸ©âˆˆNk, either P1(x1, . . . , xk) or P2(x1, . . . , xk) holds but not
both. Then the k-place function f deï¬ned by
f(x1, . . . , xk) =
(
f1(x1, . . . , xk)
if P1(x1, . . . , xk) holds
f2(x2, . . . , xk)
if P2(x1, . . . , xk) holds
is primitive recursive.
Proof. This is clear since f = f1 Â· Ï‡P1 + f2 Â· Ï‡P2. The extension to more than
two cases is also easy.
Proof of the Enumeration Theorem.
28

The idea of the proof is to represent the state of E(x1, . . . , xk) after executing
n instructions by a single number
z
=
State (e, x1, . . . , xk, n)
=
pm
0 Â· Qâˆ
i=1 pzi
i ,
where zi is the number in register Ri, and Im is the next instruction to be
executed. Note that (z)0 = m and, for all i â‰¥1, (z)i = zi.
We ï¬rst show that the State function is primitive recursive. We have
State (e, x1, . . . , xk, 0)
=
p1
0 Â· px1
1 Â· . . . Â· pxk
k
(begin by executing I1) ,
State (e, x1, . . . , xk, n + 1)
=
NextState (e, State (e, x1, . . . , xk, n)) ,
NextState (e, z) =
ï£±
ï£´
ï£´
ï£´
ï£´
ï£²
ï£´
ï£´
ï£´
ï£´
ï£³
z Â· pi Â· pâˆ’m+n0
0
if ((e)m)0 = 0 ,
z Â· pâˆ’m+n0
0
if ((e)m)0 = 1 and (z)i = 0 ,
z Â· pâˆ’1
i
Â· pâˆ’m+n1
0
if ((e)m)0 = 1 and (z)i > 0 ,
z
otherwise ,
where
m = (z)0 ,
i = ((e)m)1 ,
n0 = ((e)m)2 ,
n1 = ((e)m)3 .
We are now ready to prove the theorem. We use the least number operator
to obtain
Stop (e, x1, . . . , xk)
â‰ƒ
least n such that (State (e, x1, . . . , xk, n))0 = 0
âˆ§Program(e) .
(The idea is that our machine stops if and when it is about to execute I0. Note
that Stop (e, x1, . . . , xk) is undeï¬ned if e is not the GÂ¨odel number of a register
machine program.) We then use composition to get
FinalState (e, x1, . . . , xk)
â‰ƒ
State (e, x1, . . . , xk, Stop (e, x1, . . . , xk))
(the state of our machine if and when it stops)
and
Output (e, x1, . . . , xk)
â‰ƒ
(FinalState (e, x1, . . . , xk))k+1
(the number that is ï¬nally in register Rk+1) .
Since the Output function was obtained by composition, primitive recursion and
the least number operator, it is partial recursive. Moreover, for all e and x1,
. . . , xk, we clearly have
Ï•(k)
e (x1, . . . , xk) â‰ƒOutput (e, x1, . . . , xk) .
This completes the proof of the Enumeration Theorem.
29

Exercise 1.5.8. Let f : Nk â†’N be a k-place total recursive function. Show
that f is primitive recursive if and only if there exists an index e of f such that
Î»x1 . . . xk [ Stop (e, x1, . . . , xk) ]
is majorized by some primitive recursive function. (See also Exercise 1.2.2.)
Exercise 1.5.9. Fix k â‰¥1. Construct a k+1-place total recursive function
Î¦k : Nk+1 â†’N with the following properties:
1. for each e âˆˆN, the k-place function Î»x1 . . . xk [ Î¦k(e, x1, . . . , xk) ] is prim-
itive recursive;
2. for each k-place primitive recursive function f : Nk â†’N, there exists an
e such that f = Î»x1 . . . xk [ Î¦k(e, x1, . . . , xk) ].
Exercise 1.5.10. Given a k-place partial recursive function Ïˆ(x1, . . . , xk), show
that there is a 1-place partial recursive function Ïˆâˆ—(x) such that
Ïˆâˆ—(px1
1 Â· Â· Â· pxk
k ) â‰ƒpÏˆ(x1,...,xk)
k+1
for all x1, . . . , xk, and Ïˆâˆ—is computable by a register machine program which
uses only two registers, R1 and R2.
Solution. We begin with a register machine program P which computes Ïˆ(x1, . . . , xk).
Let P1, . . . , Pk, Pk+1, . . . , Ps be the registers used in P. We may safely assume
that, whenever P(x1, . . . , xk) halts, it leaves all registers except Pk+1 empty.
We transform P into a program R which uses only two registers, R1 and R2.
The idea is that, if P1, . . . , Ps contain z1, . . . , zs respectively, then R1 contains
z = pz1
1 Â· Â· Â· pzs
s , while R2 contains 0.
Incrementing (decrementing) Pi corre-
sponds to multiplication (division) by pi. Each instruction in P is replaced by
a corresponding set of instructions in R.
We replace
/ P +
i
ONML
HIJK
/
in P by Figure 1.9 in R.
We replace
/ P âˆ’
i
ONML
HIJK
/
e
?
?
?
?
?
?
?
A
B
in P by Figure 1.10 in R.
We replace
/ stop
ONML
HIJK
in P by Figure 1.11 in R.
1.6
Consequences of the Enumeration Theorem
In this section we present some important consequences of the Enumeration
Theorem.
30

/ Râˆ’
1
ONML
HIJK

e
/ Râˆ’
2
ONML
HIJK

e
/
R+
2
ONML
HIJK

R+
1
ONML
HIJK
O
...

R+
2
ONML
HIJK
F
The number of R+
2 instructions is pi.
Figure 1.9: Incrementing Pi
R+
1
ONML
HIJK

/ Râˆ’
1
ONML
HIJK

e
/ Râˆ’
2
ONML
HIJK
O
e
/ A
R+
1
ONML
HIJK

R+
2
ONML
HIJK
?






Râˆ’
1
ONML
HIJK

e
/ R+
1
ONML
HIJK
/ Râˆ’
2
ONML
HIJK
e

?






R+
1
ONML
HIJK

...

...
O
B
...

Râˆ’
1
ONML
HIJK
W0000000000000000
e
/ R+
1
ONML
HIJK
O
R+
1
ONML
HIJK
W0000000000000000
The number of Râˆ’
1 instructions is pi.
Figure 1.10: Decrementing Pi
31

/ Râˆ’
1
ONML
HIJK

e
/ stop
ONML
HIJK
R+
2
ONML
HIJK
O
Figure 1.11: Stopping
Theorem 1.6.1. All partial recursive functions can be obtained from primitive
recursive functions by composition and minimization.
Proof. This is immediate from the proof of the Enumeration Theorem. The
State function is primitive recursive, the Stop function is obtained from the
State function by minimization, and the FinalState and Output functions are
obtained by composing the Stop and State functions with the primitive recursive
function Î»z [ (z)k+1 ].
The following characterizations of the class of partial recursive functions do
not involve register machines and are similar to our deï¬nition of the class of
primitive recursive functions.
Corollary 1.6.2. The class of partial recursive functions is the smallest class
of functions containing the primitive recursive functions and closed under com-
position and minimization.
Corollary 1.6.3. The class of partial recursive functions is the smallest class of
functions containing the initial functions and closed under composition, primi-
tive recursion, and minimization.
Proof. Both corollaries are immediate from the previous theorem and Lem-
mas 1.3.2, 1.3.3, 1.3.4, 1.4.3.
Next we present an interesting example showing that the consideration of
partial functions is in some sense unavoidable or inherent in recursive function
theory.
Example 1.6.4. We present an example of a partial recursive function Ïˆ :
N
P
âˆ’â†’N which cannot be extended to a total recursive function f : N â†’N.
Namely, we deï¬ne
Ïˆ(x) â‰ƒÏ•(1)
x (x) + 1 .
By the Enumeration Theorem, Ïˆ is a partial recursive function.
Suppose Ïˆ
were extendible to a total recursive function f. Let e be an index of f. Then
Ïˆ(e) â‰ƒÏ•(1)
e (e) + 1 â‰ƒf(e) + 1 is deï¬ned, hence f(e) â‰ƒÏˆ(e) â‰ƒf(e) + 1, a
contradiction.
32

Deï¬nition 1.6.5. A set A âŠ†N is said to be recursive if its characteristic
function Ï‡A : N â†’N is recursive. More generally, a k-place predicate R âŠ†Nk
is said to be recursive if its characteristic function Ï‡R : Nk â†’N is recursive.
Example 1.6.6. We present an example of a nonrecursive set.
Let K be
the subset of N consisting of all x âˆˆN such that Ï•(1)
x (x) is deï¬ned.
Thus
K = dom(Ïˆ) where Ïˆ is as in the previous example. We claim that K is not
recursive. If K were recursive, then the total function f : N â†’N deï¬ned by
f(x) =
(
Ïˆ(x)
if x âˆˆK,
0
if x /âˆˆK
would be recursive, contradicting the fact that Ïˆ is not extendible to a total
recursive function.
Deï¬nition 1.6.7. A pair of sets A, B âŠ†N is said to be recursively inseparable
if there is no recursive set X such that A âŠ†X and X âˆ©B = âˆ….
Exercise 1.6.8. Letting Kn = {x âˆˆN | Ï•(1)
x (x) â‰ƒn}, show that K0 and K1
are recursively inseparable.
Exercise 1.6.9. Show that there exists a set A âŠ†N which is recursive but not
primitive recursive.
(Caution: It can be shown that the 3-place predicate z = Ax(y) is prim-
itive recursive, even though the 2-place function Î»xy [ Ax(y) ] is not primitive
recursive. See Exercises 1.2.2, 1.4.5, 1.5.8, 1.5.9.)
Remark 1.6.10 (Churchâ€™s Thesis). Perhaps the most important consequence
of the proof of the Enumeration Theorem is that it provides strong evidence for
Churchâ€™s Thesis. We shall ï¬rst explain what Churchâ€™s Thesis says, and then we
shall present the evidence for it.
The context of Churchâ€™s Thesis is that, as mathematicians, we have an in-
tuitive notion of what it means for a function f : Nk â†’N to be algorithmically
computable. Since recursive functions are register machine computable, they
are obviously algorithmically computable in the intuitive sense. Churchâ€™s The-
sis states the converse: All functions f : Nk â†’N which are algoritmically
computable in the intuitive sense are in fact recursive.
To present our evidence for Churchâ€™s thesis, assume that we are given a func-
tion f : Nk â†’N which is algorithmically computable in the intuitive sense. We
want to show that f is recursive. Since the given algorithm for f is presumably
deterministic, the execution of the algorithm should be describable as a sequence
of states with deterministic transition from one state to the next. The precise
nature of the states depends on the nature of the algorithm, but no matter what
the states actually consist of, it should be possible to view them as ï¬nite strings
of symbols and to assign GÂ¨odel numbers to them. Once this has been done, the
transition from the GÂ¨odel number of one state to the GÂ¨odel number of the next
state should be very simple, in particular primitive recursive. Thus we should
33

be able to carry out an analysis similar to what is in the proof of Theorem 1.5.5
(State, NextState, Stop, etc.). Such an analysis will show that f is obtained
from primitive recursive functions by means of composition and minimization.
It will then follow by Corollary 1.6.2 that f is recursive.
The argument in the previous paragraph is of necessity nonrigorous. How-
ever, it can be specialized to provide rigorous proofs that various models of com-
putation (similar to but diï¬€ering in details from register machine computability)
give rise to exactly the same class of functions, the recursive functions. Some
of the models of computation that have been analyzed in this way are: Turing
machines, Markov algorithms, Kleeneâ€™s equation calculus. There is no reason
to think that the same analysis could not be carried out for any similar model.
This constitutes very strong evidence for Churchâ€™s thesis.
Note that the same arguments and evidence apply more generally in case f
is a partial rather than a total function. From now on, we shall take Churchâ€™s
Thesis for granted and identify the class of partial recursive functions with the
class of partial functions from Nk into N that are algorithmically computable in
the intuitive sense.
The fact that the intuitive notion of algorithmic computability is captured
by a rigorous mathematical notion of recursiveness is one of the successes of
modern mathematical logic.
1.7
Unsolvable Problems
The purpose of this section is twofold: (1) to discuss and make precise the con-
cept of an unsolvable mathematical problem, and (2) to present some important
examples of such problems.
We begin with a preliminary clariï¬cation.
In certain contexts, the word
problem refers to a mathematical statement which has a deï¬nite truth value,
True or False, but whose truth value is unknown at the present time. (An ex-
ample of a problem in this sense is the Riemann Hypothesis.) However, we shall
not deal with this type of problem now. Instead, we consider a somewhat dif-
ferent concept. For us in this section, a problem is any mathematical statement
that involves a parameter. A solution of such a problem would be an algorithm
which would enable us to compute the truth value of the problem statement for
any given value of the parameter. The problem is said to be solvable if there
exists such an algorithm, otherwise unsolvable. An instance of a problem is the
specialization of the problem statement to a particular parameter value.
As an example of a solvable problem, we mention:
Example 1.7.1. The statement â€œn is primeâ€ represents the problem of deciding
whether an arbitrary number n âˆˆN is prime or composite. Here the parameter
is the variable n. For any particular n (e.g. n = 123456789), the question of
whether this particular n is prime or composite is an instance (i.e., special case)
of the general â€œprimality problemâ€. Since the set of prime numbers
{n âˆˆN | n is prime}
34

is primitive recursive, the general primality problem is solvable.
On the other hand, we have the following example of an unsolvable problem.
Example 1.7.2. The set K deï¬ned in Example 1.6.6 is nonrecursive. Hence by
Churchâ€™s Thesis there is no algorithm to decide whether or not a given number
n belongs to K. It is therefore appropriate to describe the membership problem
for K (i.e., the problem of computing the truth value of n âˆˆK for any given n)
as an unsolvable problem.
The ability to distinguish solvable problems from unsolvable ones is of basic
importance for the mathematical enterprise. Among the most famous unsolvable
mathematical problems are:
Example 1.7.3 (Hilbertâ€™s Tenth Problem). Hilbertâ€™s Tenth Problem is to de-
termine, for a given polynomial p in several variables with integral coeï¬ƒents,
p âˆˆZ[X1, . . . , Xn], whether or not the equation p(X1, . . . , Xn) = 0 has a solu-
tion in integers X1, . . . , Xn âˆˆN. This problem encompasses the entire theory
of Diophantine equations. A theorem of MatijaseviË‡c shows that Hilbertâ€™s Tenth
Problem is unsolvable. Actually MatijaseviË‡c produced a particular polynomial
p(X0, X1, . . . , X9)
with 10 indeterminates, such that
{n âˆˆN | p(n, a1, . . . , a9) = 0 for some a1, . . . , a9 âˆˆZ}
is nonrecursive. Once again, our notion of unsolvable problem is related to the
existence of a nonrecursive set, namely the set of parameter values n for which
the problem statement holds.
Example 1.7.4 (Word Problems). Let G be a group presented by ï¬nitely many
generators and relations. The word problem for G is the problem of determining,
for a given word w in the generators of G and their inverses, whether or not
w = 1 in G. In this case the parameter is w, and the word problem for G is
solvable if and only if there exists an algorithm for determining whether or not a
given word w is equal to 1 in G. It is known that the word problem is solvable for
some groups G and not solvable for others. For example, the word problem for
free groups or groups with one relation is solvable, but Boone and Novikov have
exhibited groups G with ï¬nitely many relations such that the word problem for
G is unsolvable.
Example 1.7.5 (The Halting Problem).
Some famous unsolvable problems arise from computability theory itself. One
of these is the Halting Problem: To determine whether or not a given register
machine program P will eventually stop, if started with all registers empty. By
GÂ¨odel numbering, we can identify the Halting Problem with the problem of
deciding whether a given natural number e belongs to the set
H = {e âˆˆN | Ï•(1)
e (0) is deï¬ned} .
35

We shall prove below that H is nonrecursive, i.e., the Halting Problem is un-
solvable.
In all of the above examples, the issue of solvability or unsolvability of a
particular problem was rephrased as an issue of whether or not a particular
subset of N is recursive. Such considerations based on Churchâ€™s Thesis motivate
the following deï¬nition:
Deï¬nition 1.7.6 (Unsolvability). Recall that a set A âŠ†N is said to be recursive
if and only if its characteristic function Ï‡A : N â†’{0, 1} is recursive. A problem
is deï¬ned to be a subset of N. If A âŠ†N is a problem in this sense, the problem
A is said to be solvable if A is recursive, and unsolvable if A is nonrecursive.
We shall prove the unsolvability of the Halting Problem, i.e., the nonrecur-
siveness of the set H in Example 1.7.5 above. The proof will be accomplished
by showing that the problem of membership in K is â€œreducibleâ€ to the problem
of membership in H. In this context, reducibility of one problem to another
means that each instance of the former problem can be eï¬€ectively converted to
an equivalent instance of the latter problem. Our precise notion of reducibility
is given by:
Deï¬nition 1.7.7 (Reducibility). Let A and B be subsets of N (i.e., problems,
cf. Deï¬nition 1.7.6). We say that A is reducible to B if there exists a recursive
function f : N â†’N such that, for all n âˆˆN, n âˆˆA implies f(n) âˆˆB, and n /âˆˆA
implies f(n) /âˆˆB.
Lemma 1.7.8. Suppose that A is reducible to B. If B is recursive, then A is
recursive. If A is nonrecursive, then B is nonrecursive.
Proof. The ï¬rst statement follows easily from the fact that Ï‡A(x) = Ï‡B(f(x)).
The second statement follows since it is the contrapositive of the ï¬rst.
Exercise 1.7.9. Write A â‰¤m B to mean that A is reducible to B. Show that
1. A â‰¤m A for all A âŠ†N.
2. A â‰¤m B and B â‰¤m C imply A â‰¤m C.
3. If âˆ…Ì¸=BÌ¸= N, then for every recursive set A we have A â‰¤m B.
In order to prove that the set H is nonrecursive, we shall need the following
important technical result:
Theorem 1.7.10 (The Parametrization Theorem). Let Î¸(x0, x1, . . . , xk) be a
(k+1)-ary partial recursive function. Then we can ï¬nd a unary primitive recur-
sive function f(x0) such that, for all x0, x1, . . . , xk âˆˆN,
Ï•(k)
f(x0)(x1, . . . , xk) â‰ƒÎ¸(x0, x1, . . . , xk) .
36

Proof. Let T be a register machine program which computes the k+1-ary partial
recursive function Î¸. The idea of the proof is to let f(x0) be the GÂ¨odel number
of a program which is similar to T but has x0 hard-coded as the ï¬rst argument
of Î¸.
Formally, let T â€² be a register machine program which computes the k+1-ary
partial recursive function
Î¸â€²(x1, . . . , xk, x0) â‰ƒÎ¸(x0, x1, . . . , xk) .
Let I1, . . . , Il be the instructions of T â€², and let T â€²â€² be the same as T â€² but modiï¬ed
so that the instructions are numbered I5, . . . , Il+4 instead of I1, . . . , Il. Then for
any given x0 âˆˆN, the program T â€²â€²â€²
x0 depicted in Figure 1.12 computes the k-ary
partial recursive function Î»x1 . . . xk [ Î¸â€²(x1, . . . , xk, x0) ], i.e. Î»x1 . . . xk [ Î¸(x0, x1, . . . , xk) ].
The instructions of T â€²â€²â€²
x0 are numbered as I1, . . . , Il+x0+5. Let f(x0) be the GÂ¨odel
number of T â€²â€²â€²
x0 . Note that
f(x0)
=
Ql+x0+5
m=1
p#(Im)
m
=
Ql+4
m=1 p#(Im)
m
Â· Ql+x0+4
m=l+5 p3k+1Â·5m+1
m
Â· p2Â·3k+1Â·55Â·75
l+x0+5
where the ï¬rst factor Ql+4
m=1 p#(Im)
m
does not depend on x0. Thus f(x0) is a
primitive recursive function of x0. This completes the proof.
I1
Il+5
. . .
Il+x0+4
Il+x0+5
I5 Â· Â· Â· Il+4
I2
I3
start
ONML
HIJK
/ R+
k+1
WVUT
PQRS
/ R+
k+1
WVUT
PQRS
/ . . .
/ R+
k+1
WVUT
PQRS
/ Râˆ’
k+1
WVUT
PQRS
/
e
/ T
â€²â€²
/ Râˆ’
k+1
WVUT
PQRS
cd
ab
`g
=
e
/ Râˆ’
k+2
WVUT
PQRS

e
/ stop
ONML
HIJK
x0
R+
k+1
WVUT
PQRS
O
I4
Figure 1.12: Parametrization
We can now prove that the Halting Problem is unsolvable.
Theorem 1.7.11 (Unsolvability of the Halting Problem). The Halting Problem
is unsolvable. In other words, the set
H = {x âˆˆN | Ï•(1)
x (0) is deï¬ned}
of Example 1.7.5 is nonrecursive.
37

Proof. Let H be as in Example 1.7.5 and let K be as in Example 1.6.6, i.e.,
K = {x âˆˆN | Ï•(1)
x (x) is deï¬ned} .
We shall prove that K is reducible to H. Since K is known to be nonrecursive
(Example 1.6.6), it will follow by Lemma 1.7.8 that H is nonrecursive.
Consider the partial recursive function Î¸(x, y) â‰ƒÏ•(1)
x (x). Note that Î¸ is a
2-place function. By the Enumeration Theorem, Î¸ is partial recursive. By the
Parametrization Theorem applied with k = 1, we can ï¬nd a primitive recursive
function f : N â†’N such that
Ï•(1)
f(x)(y) â‰ƒÎ¸(x, y) ,
i.e.,
Ï•(1)
f(x)(y) â‰ƒÏ•(1)
x (x)
for all x and y. In particular, if x âˆˆK then Ï•(1)
x (x) is deï¬ned, hence Ï•(1)
f(x)(0) is
deï¬ned, i.e., f(x) âˆˆH. On the other hand, if x /âˆˆK then Ï•(1)
x (x) is undeï¬ned,
hence Ï•(1)
f(x)(0) is undeï¬ned, i.e., f(x) /âˆˆH. Thus K is reducible to H via f.
This completes the proof.
Exercise 1.7.12. Show that the following sets and predicates are nonrecursive:
1. {x âˆˆN | Ï•(1)
x
: N
P
âˆ’â†’N is total}.
2. {x âˆˆN | Ï•(1)
x
is the empty function}.
3. {âŸ¨x, yâŸ©âˆˆN Ã— N | Ï•(1)
x
= Ï•(1)
y }.
4. {âŸ¨x, yâŸ©âˆˆN Ã— N | y âˆˆrng(Ï•(1)
x )}.
5. {x âˆˆN | 0 âˆˆrng(Ï•(1)
x )}.
6. {x âˆˆN | rng(Ï•(1)
x ) is inï¬nite}.
Exercise 1.7.13 (Riceâ€™s Theorem). Let P be the class of 1-place partial recur-
sive functions. For C âŠ†P, deï¬ne IC to be the set of indices of functions in C,
i.e.,
IC = {x âˆˆN | Ï•(1)
x
âˆˆC} .
Show that if âˆ…Ì¸= C Ì¸= P then IC is nonrecursive.
Solution. Let e0 be an index of the empty function. Let e1 be an index such
that Ï•(1)
e1 âˆˆC if and only if Ï•(1)
e0 /âˆˆC. By the Enumeration and Parametrization
theorems, we can ï¬nd a primitive recursive function f such that
Ï•(1)
f(x)(y) â‰ƒ
(
Ï•(1)
e1 (y)
if Ï•(1)
x (x) â†“,
â†‘
otherwise,
38

for all x and y.
Thus x âˆˆK implies Ï•(1)
f(x) = Ï•(1)
e1 , while x /âˆˆK implies
Ï•(1)
f(x) = Ï•(1)
e0 . Thus f reduces K either to IC (if Ï•(1)
e1 âˆˆC) or to the complement
of IC (if Ï•(1)
e1 /âˆˆC). In either case it follows that IC is not recursive.
1.8
The Recursion Theorem
In this section we present an interesting and mysterious theorem known as the
Recursion Theorem.
Theorem 1.8.1 (The Recursion Theorem). Let Î¸(w, x1, . . . , xk) be a partial
recursive function. Then we can ï¬nd an index e such that, for all x1, . . . , xk,
Ï•(k)
e (x1, . . . , xk)
â‰ƒ
Î¸(e, x1, . . . , xk) .
Proof. Applying the Parametrization Theorem and the Enumeration Theorem,
we can ï¬nd primitive recursive functions f and d such that, for all w, u, x1, . . . , xk,
Ï•(k)
f(w)(x1, . . . , xk)
â‰ƒ
Î¸(w, x1, . . . , xk) .
and
Ï•(k)
d(u)(x1, . . . , xk)
â‰ƒ
Ï•(k)
Ï•(1)
u (u)(x1, . . . , xk) .
Let v be an index of f â—¦d, i.e., Ï•(1)
v (u) = f(d(u)) for all u. Then
Ï•(k)
d(v)(x1, . . . , xk)
â‰ƒ
Ï•(k)
Ï•(1)
v
(v)(x1, . . . , xk)
â‰ƒ
Ï•(k)
f(d(v))(x1, . . . , xk)
â‰ƒ
Î¸(d(v), x1, . . . , xk)
so we may take e = d(v). This completes the proof.
Example 1.8.2. As an example, if we take Î¸(w, x) = w + x, then we obtain an
index e such that Ï•(1)
e (x) = e + x for all x.
Example 1.8.3. As another illustration of the Recursion Theorem, we now
use it to prove that the Ackermann function Î»nx [ An(x) ] (see Section 1.2) is
computable. The recursion equations deï¬ning the Ackermann function can be
written as
A0(x)
=
2x
An+1(0)
=
1
An+1(x + 1)
=
An(An+1(x)) .
Writing A(x, y) = Ax(y), this becomes
A(0, y)
=
2y
A(x + 1, 0)
=
1
A(x + 1, y + 1)
=
A(x, A(x + 1, y))
39

or in other words
A(x, y)
=
ï£±
ï£´
ï£²
ï£´
ï£³
2y
if x = 0 ,
1
if x > 0 and y = 0 ,
A(x Â·âˆ’1, A(x, y Â·âˆ’1))
if x > 0 and y > 0 .
By the Enumeration Theorem together with the Recursion Theorem, we can
ï¬nd an index e such that
Ï•(2)
e (x, y)
â‰ƒ
ï£±
ï£´
ï£´
ï£²
ï£´
ï£´
ï£³
2y
if x = 0 ,
1
if x > 0 and y = 0 ,
Ï•(2)
e (x Â·âˆ’1, Ï•(2)
e (x, y Â·âˆ’1))
if x > 0 and y > 0 .
It is then straightforward to prove by induction on x that, for all y, Ï•(2)
e (x, y) â‰ƒ
A(x, y). This completes the proof.
Exercise 1.8.4.
1. Find a primitive recursive function f(x, y) such that, for all x and y,
Ï•(1)
f(x,y) = Ï•(1)
x
â—¦Ï•(1)
y
.
2. Find a primitive recursive function g(x, y) such that, for all x and y,
dom(Ï•(1)
g(x,y)) = dom(Ï•(1)
x ) âˆ©dom(Ï•(1)
y ) .
3. Find a primitive recursive function h(x, y) such that, for all x and y,
dom(Ï•(1)
h(x,y)) = dom(Ï•(1)
x ) âˆªdom(Ï•(1)
y ) .
Solution.
1. By the Enumeration Theorem and the Parametrization Theorem, ï¬nd a
primitive recursive function bf(w) such that
Ï•(1)
b
f(w)(z) â‰ƒÏ•(1)
(w)1(Ï•(1)
(w)2(z))
for all w, z. Then f(x, y) = bf(3x5y) has the desired property.
2. By the Enumeration Theorem and the Parametrization Theorem, ï¬nd a
primitive recursive function bg(w) such that
Ï•(1)
bg(w)(z) â‰ƒÏ•(1)
(w)1(z) + Ï•(1)
(w)2(z)
for all w, z. Then g(x, y) = bg(3x5y) has the desired property.
40

3. By the Parametrization Theorem, ï¬nd a primitive recursive function bh(w)
such that
Ï•(1)
bh(w)(z) â‰ƒleast n such that (State((w)1, z, n))0 Â· (State((w)2, z, n))0 = 0
for all w, z. Then h(x, y) = bh(3x5y) has the desired property.
Exercise 1.8.5.
1. Find a primitive recursive function f(x) such that for all x, if Ï•(1)
x
is a
permutation of N, then Ï•(1)
f(x) is the inverse permutation.
2. What happens if Ï•(1)
x
is assumed only to be partial and one-to-one, and
not necessarily a permutation?
Solution. Consider the partial recursive function Î¸(x, y) â‰ƒleast w such that
(State(x, (w)1, (w)2))0 = 0 and (State(x, (w)1, (w)2))2 = y. By construction, if
Ï•(1)
x (z) â‰ƒy then (Î¸(x, y))1 â‰ƒz. Therefore, by the Parametrization Theorem,
let f(x) be a primitive recursive function such that Ï•(1)
f(x)(y) â‰ƒ(Î¸(x, y))1. This
works even if Ï•(1)
x
is only assumed to be partial and one-to-one.
Exercise 1.8.6. Find m and n such that m Ì¸= n and Ï•(1)
m (0) = n and Ï•(1)
n (0) =
m.
Solution. By the Parametrization Theorem, let f be a 1-place primitive recursive
function such that Ï•(1)
f(x)(y) = x for all x, y. The construction of f in the proof of
the Parametrization Theorem shows that f(x) > x for all x. By the Recursion
Theorem, let e be such that Ï•(1)
e (y) â‰ƒf(e) for all y. In particular we have
Ï•(1)
e (0) â‰ƒf(e), Ï•(1)
f(e)(0) = e, and f(e) > e. So take m = e and n = f(e).
1.9
The Arithmetical Hierarchy
In this section we study some important classes of number-theoretic predicates:
Î£0
1, Î 0
1, Î£0
2, Î 0
2, . . . . These classes collectively are known as the arithmetical
hierarchy.
Deï¬nition 1.9.1 (The Arithmetical Hierarchy). We deï¬ne Î£0
0 and Î 0
0 to be
the class of primitive recursive predicates. For n â‰¥1, we deï¬ne Î£0
n to be the
class of k-place predicates P âŠ†Nk (for any k â‰¥1) such that P can be written
in the form
P(x1, . . . , xk) â‰¡âˆƒy R(x1, . . . , xk, y)
where R is a k+1-place predicate belonging to the class Î 0
nâˆ’1. Similarly, we
deï¬ne Î 0
n to be the class of predicates that can be written in the form
P(x1, . . . , xk) â‰¡âˆ€y R(x1, . . . , xk, y)
where R belongs to the class Î£0
nâˆ’1.
41

For example, a predicate P(x1, . . . , xk) belongs to the class Î£0
3 if and only if
it can be written in the form
âˆƒy1âˆ€y2âˆƒy3 R(x1, . . . , xk, y1, y2, y3)
where R is primitive recursive. Similarly, P belongs to the class Î 0
3 if and only
if it can be written in the form
âˆ€y1âˆƒy2âˆ€y3 R(x1, . . . , xk, y1, y2, y3)
where R is primitive recursive.
Theorem 1.9.2. We have:
1. The classes Î£0
n and Î 0
n are included in the classes Î£0
n+1 and Î 0
n+1.
2. The classes Î£0
n and Î 0
n are closed under conjunction and disjunction.
3. The classes Î£0
n and Î 0
n are closed under bounded quantiï¬cation.
4. For n â‰¥1, the class Î£0
n is closed under existential quantiï¬cation.
5. For n â‰¥1, the class Î 0
n is closed under universal quantiï¬cation.
6. A predicate P belongs to Î£0
n (respectively Î 0
n) if and only if Â¬ P belongs
to Î 0
n (respectively Î£0
n).
Proof. Straightforward.
Theorem 1.9.3. A k-place predicate P âŠ†Nk belongs to the class Î£0
1 if and
only if P = dom(Ïˆ) for some k-place partial recursive function Ïˆ : Nk
P
âˆ’â†’N.
Proof. If P is Î£0
1, then we have
P(x1, . . . , xk)
â‰¡
âˆƒy R(x1, . . . , xk, y)
where R is primitive recursive, hence P = dom(Ïˆ) where
Ïˆ(x1, . . . , xk)
â‰ƒ
least y such that R(x1, . . . , xk, y) holds ,
and clearly Ïˆ is partial recursive. Conversely, if P = dom(Ïˆ), then letting e be
an index of Ïˆ, we have as in the proof of the Enumeration Theorem
P(x1 . . . , xk)
â‰¡
âˆƒn (State(e, x1, . . . , xk, n))0 = 0 ,
hence P is Î£0
1.
Corollary 1.9.4. P âŠ†Nk is Î£0
1 if and only if
P(x1, . . . , xk) â‰¡âˆƒy R(x1, . . . , xk, y)
where R âŠ†Nk+1 is recursive (not only primitive recursive).
42

Remark 1.9.5. It follows that, in the deï¬nition of Î£0
n and Î 0
n for n â‰¥1, we
may replace â€œprimitive recursiveâ€ by â€œrecursiveâ€.
Exercises 1.9.6. If Ïˆ is a k-place partial function, the graph of Ïˆ is the (k+1)-
place predicate GÏˆ = {âŸ¨x1, . . . , xk, yâŸ©| Ïˆ(x1, . . . , xk) â‰ƒy}.
1. Show that Ïˆ is partial recursive if and only if the graph of Ïˆ is Î£0
1.
2. Show that, for every (k+1)-place Î£0
1 predicate P(x1, . . . , xk, y) there exists
a k-place partial recursive function Ïˆ(x1, . . . , xk) which uniformizes P, i.e.,
GÏˆ âŠ†P and dom(Ïˆ) = {âŸ¨x1, . . . , xkâŸ©| âˆƒy P(x1, . . . , xk, y)}.
Deï¬nition 1.9.7. Let A be an inï¬nite subset of N. The principal function of
A is the one-to-one function Ï€A : N â†’N that enumerates the elements of A in
increasing order.
Lemma 1.9.8. Let A be an inï¬nite subset of N. The set A is recursive if and
only if the function Ï€A is recursive.
Proof. If A is recursive then the functions Î½A and Ï€A deï¬ned by
Î½A(x)
=
least y such that y â‰¥x and y âˆˆA
Ï€A(0)
=
Î½A(0)
Ï€A(x + 1)
=
Î½A(Ï€A(x) + 1)
are obviously recursive. Conversely, if Ï€A is recursive then we have
y âˆˆA
if and only if
y_
x=0
Ï€A(x) = y .
Since the class of recursive predicates is closed under bounded quantiï¬cation, it
follows that A is recursive.
Theorem 1.9.9. For A âŠ†N, the following are pairwise equivalent:
1. A is Î£0
1;
2. A = dom(Ïˆ) for some partial recursive function Ïˆ : N
P
âˆ’â†’N;
3. A = rng(Ïˆ) for some partial recursive function Ïˆ : N
P
âˆ’â†’N;
4. A = âˆ…or A = rng(f) for some total recursive function f : N â†’N;
5. A is ï¬nite or A = rng(f) for some one-to-one total recursive function
f : N â†’N.
43

Proof. The equivalence of 1 and 2 is a special case of Theorem 1.9.3, and the
fact that 3 implies 1 is proved similarly. It is easy to see that 5 implies 4 and 4
implies 3. To see that 1 implies 5, suppose that A âŠ†N is inï¬nite and Î£0
1, say
x âˆˆA â‰¡âˆƒyR(x, y)
where R is primitive recursive. Put
B =
(
2x3y
 R(x, y) âˆ§Â¬
yâˆ’1
_
z=0
R(x, z)
)
.
Then B is an inï¬nite primitive recursive set, so by Lemma 1.9.8, Ï€B is a one-to-
one recursive function. Putting f(n) = (Ï€B(n))0, we see that f is a one-to-one
recursive function and A = rng(f). This completes the proof.
Remark 1.9.10. A set A satisfying the conditions of Theorem 1.9.9 is some-
times called a recursively enumerable set.
Exercises 1.9.11.
1. Show that every nonempty recursively enumerable set is the range of a
primitive recursive function.
2. Find an inï¬nite primitive recursive set that is not the range of a one-to-one
primitive recursive function.
Deï¬nition 1.9.12. For each n âˆˆN, the class âˆ†0
n is deï¬ned to be the intersection
of the classes Î£0
n and Î 0
n.
Theorem 1.9.13. A k-place predicate P âŠ†Nk belongs to the class âˆ†0
1 if and
only if P is recursive.
Proof. If P is recursive, it follows easily by Theorem 1.9.3 that P is âˆ†0
1. Con-
versely, if P is âˆ†0
1, then we have
P(x1, . . . , xk)
â‰¡
âˆƒy R1(x1, . . . , xk, y)
â‰¡
âˆ€y R2(x1, . . . , xk, y)
where R1 and R2 are primitive recursive. Deï¬ne a total recursive function f by
f(x1, . . . , xk)
=
least y such that R1(x1, . . . , xk, y) âˆ¨Â¬ R2(x1, . . . , xk, y) .
Then we have
P(x1, . . . , xk)
â‰¡
R1(x1, . . . , xk, f(x1, . . . , xk)) ,
hence P is recursive.
44

Exercise 1.9.14. A function f : Nk â†’N is said to be limit-recursive if there
exists a recursive function g : Nk+1 â†’N such that
f(x1, . . . , xk) = lim
y g(x1, . . . , xk, y)
for all x1, . . . , xk âˆˆN. Show that a predicate P is âˆ†0
2 if and only if its charac-
teristic function Ï‡P is limit-recursive.
Solution. For simplicity, let x be an abbreviation for x1, . . . , xk.
First assume that Ï‡P is limit-recursive, say
Ï‡P (x) = lim
n f(n, x)
for all x, where f(n, x) is a recursive function. Then we have
P(x) â‰¡âˆƒm âˆ€n (n â‰¥m â‡’f(n, x) = 1)
and
Â¬ P(x) â‰¡âˆƒm âˆ€n (n â‰¥m â‡’f(n, x) = 0)
so P is âˆ†0
2.
For the converse, assume that P is âˆ†0
2, say
P(x) â‰¡âˆƒy âˆ€z R1(x, y, z)
and
Â¬ P(x) â‰¡âˆƒy âˆ€z R0(x, y, z)
where R1 and R0 are primitive recursive predicates. Using the bounded least
number operator, deï¬ne g(n, x) = the least y < n such that either âˆ€z <
n R1(x, y, z) or âˆ€z < n R0(x, y, z) or both, if such a y exists, and g(n, x) =
n otherwise.
Thus g(n, x) is a primitive recursive function, and it is easy
to see that, for all x, g(x) = limn g(n, x) exists and is equal to the least y
such that âˆ€z R1(x, y, z) or âˆ€z R0(x, y, z).
Now deï¬ne h(n, x) = 1 if âˆ€z <
n R1(x, g(n, x), z), and h(n, x) = 0 otherwise. Thus h(n, x) is again a primi-
tive recursive function, and for all x, h(x) = limn h(n, x) exists. Moreover P(x)
implies h(x) = 1, and Â¬ P(x) implies h(x) = 0. Thus Ï‡P is limit-recursive. This
completes the proof.
Theorem 1.9.15 (Universal Î£0
n Predicate). For each n â‰¥1 and k â‰¥1, we can
ï¬nd a predicate U = Un,k with the following properties:
1. U is a k+1-place predicate belonging to the class Î£0
n; and
2. for any k-place predicate P belonging to the class Î£0
n, there exists an e âˆˆN
such that
P(x1, . . . , xk) â‰¡U(e, x1, . . . , xk)
for all x1, . . . , xk.
45

Proof. This is a straightforward consequence of the Enumeration Theorem. The
proof is by induction on n. For n = 1 we have
U1,k(e, x1, . . . , xk) â‰¡Ï•(k)
e (x1, . . . , xk) â†“â‰¡âˆƒs (State(e, x1, . . . , xk, s))0 = 0
in view of Theorem 1.9.3. For n > 1 we have
Un,k(e, x1, . . . , xk) â‰¡âˆƒy Â¬ Unâˆ’1,k+1(e, x1, . . . , xk, y) .
This completes the proof.
Lemma 1.9.16. Let A, B âŠ†N and assume that A is reducible to B. Assume
n â‰¥1. If B belongs to Î£0
n, then so does A. If B belongs to Î 0
n, then so does A.
Proof. Suppose for example that B belongs to Î£0
3. Then we have
x âˆˆB
if and only if
âˆƒy1 âˆ€y2 âˆƒy3 R(x, y1, y2, y3)
where R âŠ†N4 is a primitive recursive predicate. If A is reducible to B via the
recursive function f, then we have
x âˆˆA
if and only if
f(x) âˆˆB
if and only if
âˆƒy1 âˆ€y2 âˆƒy3 R(f(x), y1, y2, y3) .
Note that the predicate R(f(x), y1, y2, y3) is recursive, hence âˆ†0
1. It follows that
the predicate âˆƒy3 R(f(x), y1, y2, y3) is Î£0
1. Hence A is Î£0
3.
Deï¬nition 1.9.17. Given n â‰¥1, a set B âŠ†N is said to be complete Î£0
n if
1. B belongs to the class Î£0
n; and
2. for any set A âŠ†N belonging to the class Î£0
n, A is reducible to B.
The notion of complete Î 0
n set is deï¬ned similarly.
Theorem 1.9.18. For each n â‰¥1 there exists a complete Î£0
n set. For each
n â‰¥1 there exists a complete Î 0
n set. For each n â‰¥1, a complete Î£0
n set is not
Î 0
n, and a complete Î 0
n set is not Î£0
n.
Proof. By Theorem 1.9.15 let U(e, x) be a universal Î£0
n predicate. Obviously
the set {2e3x | U(e, x)} is Î£0
n complete. To show that a Î£0
n complete set can
never be Î 0
n, it suï¬ƒces by Lemma 1.9.16 to show that there exists a Î£0
n set which
is not Î 0
n. A simple diagonal argument shows that the Î£0
n set {x | U(x, x)} is
not Î 0
n. This completes the proof of the Î£0
n part of the theorem. The Î 0
n part
follows easily by taking complements.
Corollary 1.9.19. For all n âˆˆN we have
âˆ†0
n âŠ†Î£0
n ,
âˆ†0
n âŠ†Î 0
n ,
Î£0
n âˆªÎ 0
n âŠ†âˆ†0
n+1
and, except for n = 0, all of these inclusions are proper.
46

Proof. Given n â‰¥1, let A be a complete Î£0
n set. Then the complement B = N\A
is complete Î 0
n.
Clearly A belongs to Î£0
n \ âˆ†0
n and B belongs to Î 0
n \ âˆ†0
n.
Moreover it follows by Theorem 1.9.2 and Lemma 1.9.16 that the set
A âŠ•B
=
{2x | x âˆˆA} âˆª{2x + 1 | x âˆˆB}
belongs to âˆ†0
n+1 \ (Î£0
n âˆªÎ 0
n).
Exercises 1.9.20.
1. Show that the sets
H = {x | Ï•(1)
x (0) is deï¬ned}
and
K = {x | Ï•(1)
x (x) is deï¬ned}
are complete Î£0
1 sets.
2. Show that the set
T = {x | Ï•(1)
x
is total}
is a complete Î 0
2 set.
Exercise 1.9.21. What reducibility and non-reducibility relations exist among
the following sets? Note that H, T , E, and S are index sets.
K = {x âˆˆN | Ï•(1)
x (x) â†“},
H = {x âˆˆN | Ï•(1)
x (0) â†“},
T = {x âˆˆN | Ï•(1)
x
is total},
E = {x âˆˆN | Ï•(1)
x
is the empty function},
S = {x âˆˆN | dom(Ï•(1)
x ) is inï¬nite}.
Prove your answers.
Hint: Using the Parametrization Theorem as in the proof of Theorem 1.7.11,
show that H and K are Î£0
1 complete, S and T are Î 0
2 complete, and E is Î 0
1
complete. These completeness facts, together with Lemma 1.9.16 and Theorem
1.9.18, determine the reducibility relations among H, K, S, T , and E.
47

Chapter 2
Undecidability of
Arithmetic
We are going to show that arithmetic is undecidable. This means that there is
no algorithm to decide whether a given sentence in the language of arithmetic
is true or false.
2.1
Terms, Formulas, and Sentences
By arithmetic we mean the set of sentences which are true in the structure
(N, +, Â·, 0, 1, =). Here N = {0, 1, 2, . . .} is the set of non-negative integers, +
and Â· denote the 2-place operations of addition and multiplication on N, and =
denotes the 2-place relation of equality between elements of N. For the beneï¬t
of the reader who has not previously studied mathematical logic, we shall now
review the concept of a sentence being true in a structure. Since we are only
interested in the particular structure (N, +, Â·, 0, 1, =), we shall concentrate on
that case.
It is ï¬rst necessary to deï¬ne a language appropriate for the structure
(N, +, Â·, 0, 1, =).
Our language contains inï¬nitely many variables x0, x1, . . . , xn, . . . which are
usually denoted by letters such as x, y, z, . . . . Each of these variables is also a
term of our language. In addition the symbols 0 and 1 are terms. Other terms
are built up using the 2-place operation symbols + and Â·. Examples of terms
are
1 + 1 + 1 ,
x + 1 ,
(x + y) Â· z + x .
When writing terms, we may employ the usual abbreviations.
For instance
1 + 1 + 1 = 3 and x Â· x Â· x = x3. Thus a term is essentially a polynomial in
several variables with non-negative integer coeï¬ƒcients.
48

An atomic formula is a formula of the form t1 = t2 where t1 and t2 are
terms. Examples of atomic formulas are
x + 1 = y ,
x = 3y2 + 1 .
Formulas are built from atomic formulas by using the Boolean propositional
connectives âˆ§, âˆ¨, Â¬ (and, or, not) and the quantiï¬ers âˆ€, âˆƒ(for all, there exists).
An example of a formula is
âˆƒz (x + z + 1 = y)
(2.1)
In this formula, x, y and z are to be interpreted as variables ranging over the
set N. Similarly the expression âˆƒz . . . is to be interpreted as â€œthere exists a
non-negative integer z in N such that . . . .â€ Thus the formula (2.1) expresses
the assertion that x is less than y.
From now on we shall write x < y as
an abbreviation for (2.1).
This idea of introducing new relation symbols as
abbreviations for formulas allows us to expand our language indeï¬nitely.
Another example of a formula is
x > 1 âˆ§Â¬ âˆƒy âˆƒz (y > 1 âˆ§z > 1 âˆ§x = y Â· z) .
(2.2)
This formula expresses the assertion that x is a prime number. Thus we might
choose to abbreviate (2.2) by some expression such as Prime(x) or â€œx is prime.â€
In any particular formula, a free variable is a variable which is not acted on
by any quantiï¬er in that formula. For example, the free variables of (2.1) are x
and y, while in (2.2) the only free variable is x. A sentence is a formula with
no free variables. Examples of sentences are
âˆ€x (âˆƒy (x = 2y) âˆ¨âˆƒy (x = 2y + 1))
(2.3)
and
âˆ€x âˆƒy (x = y + 1) .
(2.4)
When interpreting formulas or sentences in the structure (N, +, Â·, 0, 1, =),
please bear in mind that the quantiï¬ers âˆ€and âˆƒrange over the set of non-
negative integers, N. Thus âˆ€x means â€œfor all x in N,â€ and âˆƒx means â€œfor some
x in Nâ€ or â€œthere exists x in N such that . . . .â€
With this understanding, we
know what it means for a sentence of our language to be true or false in the
structure (N, +, Â·, 0, 1, =). For example (2.3) is true (because every element of
N is either even or odd) and (2.4) is false (because not every element of N is the
successor of some other element of N).
Let F(x1, . . . , xk) be a formula whose free variables are x1, . . . , xk. Then for
any non-negative integers a1, . . . , ak âˆˆN, we can form the sentence F(a1, . . . , ak)
which is obtained by substituting (â€œplugging inâ€) the constants a1, . . . , ak for
the free occurrences of the variables x1, . . . , xk. For example, let F(x, y) be the
formula
âˆƒz (x2 + z = y)
49

with free variables x and y. Then for any particular non-negative integers m
and n, F(m, n) is a sentence which expresses the assertion that m2 is less than
or equal to n. For instance F(5, 40) is true and F(5, 20) is false.
This completes our review of the concept of a sentence being true or false in
the structure (N, +, Â·, 0, 1, =).
Exercise 2.1.1. Write a sentence expressing Goldbachâ€™s Conjecture: Every
even number is the sum of two prime numbers.
2.2
Arithmetical Deï¬nability
We now present a key deï¬nition.
Deï¬nition 2.2.1 (Arithmetical Deï¬nability). A k-place partial function
Î»x1 Â· Â· Â· xk [ Ïˆ(x1, . . . , xk) ]
is said to be arithmetically deï¬nable if there exists a formula
F(x1, . . . , xk, xk+1)
with free variables x1, . . . , xk, xk+1, such that for all m1, . . . , mk, n âˆˆN,
Ïˆ(m1, . . . , mk) â‰ƒn
if and only if
F(m1, ..., mk, n) is true.
(Of course it doesnâ€™t matter whether we use the variables x1, . . . , xk, xk+1 or
some other set of k + 1 distinct variables.)
For example, the 1-place function Î»x [ 2x ] is arithmetically deï¬nable, by the
formula y = 2x. (Here we are using a formula with two free variables x and y.)
As another example, note that the 2-place functions Î»xy [ Quotient(y, x) ] and
Î»xy [ Remainder(y, x) ] (the quotient and remainder of y on division by x) are
arithmetically deï¬nable, by the formulas
âˆƒu âˆƒv (y = u Â· x + v âˆ§v < x âˆ§z = u)
and
âˆƒu âˆƒv (y = u Â· x + v âˆ§v < x âˆ§z = v)
respectively. (Here we are using formulas with free variables x, y, and z.)
Exercise 2.2.2. Show that the function
Î»xy [ least common multiple of x and y ]
is arithmetically deï¬nable.
50

Remark 2.2.3. A more â€œmathematicalâ€ characterization of arithmetical de-
ï¬nability, not involving formulas, may be given as follows.
Let us say that
a predicate P âŠ†Nk is strongly Diophantine if there exists a polynomial with
integer coeï¬ƒcients, f(x1, . . . , xk) âˆˆZ[x1, . . . , xk], such that
P = {âŸ¨a1, . . . , akâŸ©âˆˆNk | f(a1, . . . , ak) = 0}.
For Q âŠ†Nk+1, the projection of Q is given as
Ï€(Q) = {âŸ¨a1, . . . , akâŸ©âˆˆNk | âŸ¨a1, . . . , ak, ak+1âŸ©âˆˆQ for some ak+1 âˆˆN} .
Then, the arithmetically deï¬nable predicates may be characterized as the small-
est class of number-theoretic predicates which contains all strongly Diophantine
predicates and is closed under union, complementation, and projection. Clearly
each arithmetically deï¬nable predicate is obtained by applying these operations
only a ï¬nite number of times.
Exercise 2.2.4. Show that the following number-theoretic predicates are arith-
metically deï¬nable, by exhibiting formulas which deï¬ne them over the structure
(N, +, Â·, 0, 1, =).
1. GCD(x, y) = z.
2. LCM(x, y) = z.
3. Quotient(x, y) = z.
4. Remainder(x, y) = z.
5. x is the largest prime number less than y.
6. x is the product of all the prime numbers less than y.
Remark 2.2.5. The principal result of this section, Theorem 2.2.21 below, is
that all recursive functions and predicates are arithmetically deï¬nable. From
this it will follow easily that there exists an arithmetically deï¬nable predicate
which is not recursive (Corollary 2.2.22 below). In addition, we shall character-
ize the class of arithmetically deï¬nable predicates in terms of the arithmetical
hierarchy (Theorem 2.2.23 below).
Lemma 2.2.6. The initial functions are arithmetically deï¬nable.
Proof. The constant zero function Î»x [ 0 ] is deï¬ned by the formula
x = x âˆ§y = 0 .
The successor function Î»x [ x + 1 ] is deï¬ned by the formula
y = x + 1 .
For 1 â‰¤i â‰¤k, the projection function Î»x1 . . . xk [ xi ] is deï¬ned by the formula
x1 = x1 âˆ§. . . âˆ§xk = xk âˆ§y = xi .
This completes the proof.
51

Lemma 2.2.7. If the functions g1(x1, . . . , xk), . . . , gm(x1, . . . , xk) and h(y1, . . . , ym)
are arithmetically deï¬nable, then so is the function
f(x1, . . . , xk)
=
h(g1(x1, . . . , xk), . . . , gm(x1, . . . , xk))
obtained by composition.
Proof. Let g1(x1, . . . , xk), . . . , gm(x1, . . . , xk), h(y1, . . . , ym) be deï¬ned by the
formulas
G1(x1, . . . , xk, y) , . . . , Gm(x1, . . . , xk, y) , H(y1, . . . , ym, z)
respectively. Then f(x1, . . . , xk) is deï¬ned by the formula
âˆƒy1 Â· Â· Â· âˆƒym(G1(x1, . . . , xk, y1) âˆ§. . . âˆ§Gm(x1, . . . , xk, ym) âˆ§H(y1, . . . , ym, z))
which we may abbreviate as F(x1, . . . , xk, z). This proves the lemma.
A k-place predicate P(x1, . . . , xk) is said to be arithmetically deï¬nable if it
is deï¬nable over the structure (N, +, Â·, 0, 1, =) by a formula with k free variables
x1, . . . , xk.
Lemma 2.2.8. If the k+1-place predicate R(x1, . . . , xk, y) is arithmetically
deï¬nable, then so is the k-place partial function
Ïˆ(x1, . . . , xk)
â‰ƒ
least y such that R(x1, . . . , xk, y) holds.
Proof. Our Î»x1 . . . xk[Ïˆ(x1, . . . , xk)] is arithmetically deï¬nable by the formula
R(x1, . . . , xk, y) âˆ§Â¬ âˆƒz (z < y âˆ§R(x1, . . . , xk, z))
which we may abbreviate as F(x1, . . . , xk, y). This proves the lemma.
It remains to prove:
Lemma 2.2.9. If the total k-place function g(y1, . . . , yk) and the total k+2-
place function h(x, z, y1, . . . , yk) are arithmetically deï¬nable, then so is the total
k+1-place function
f(x, y1, . . . , yk)
obtained by primitive recursion:
f(0, y1, . . . , yk)
=
g(y1, . . . , yk) ,
f(x + 1, y1, . . . , yk)
=
h(x, f(x, y1, . . . , yk), y1, . . . , yk)) .
In order to prove Lemma 2.2.9, we need some deï¬nitions and lemmas from
number theory. Two positive integers m and n are said to be relatively prime if
they have no common factor greater than 1. A set of positive integers is said to
be pairwise relatively prime if any two distinct integers in the set are relatively
prime.
52

Lemma 2.2.10. Given a positive integer k, we can ï¬nd inï¬nitely many positive
integers a such that the k integers in the set
a + 1 , 2a + 1 , . . . , ka + 1
are pairwise relatively prime.
Proof. Let a be any positive integer which is divisible by all of the prime numbers
which are less than k. We claim that a + 1, 2a + 1, . . . , ka + 1 are pairwise
relatively prime. Suppose not. Let i and j be such that 1 â‰¤i < j â‰¤k and ia+1
and ja+1 are not relatively prime. Let p be a prime number which is a factor of
both ia+1 and ja+1. Then p cannot be a factor of m. Hence p is greater than
or equal to k. On the other hand p is a factor of (ja + 1) âˆ’(ia + 1) = (j âˆ’i)a.
Hence p is a factor of j âˆ’i. But j âˆ’i is less than k, hence p is less than k, a
contradiction.
Example 2.2.11. If k = 5, the primes less than k are 2 and 3, so we can take
a to be any multiple of 6. Then the integers a + 1, 2a + 1, 3a + 1, 4a + 1,
5a + 1 will be pairwise relatively prime. Taking a = 6 we see that 7, 13, 19, 25,
31 are paiwise relatively prime. Taking a = 12 we see that 13, 25, 37, 49, 61
are pairwise relatively prime. And taking a = 600 we see that 601, 1201, 1801,
2401, 3001 are pairwise relatively prime.
Lemma 2.2.12 (Chinese Remainder Theorem). Let m1, . . . , mk be a set of k
distinct positive integers which are pairwise relatively prime. Then for any given
non-negative integers ri < mi, 1 â‰¤i â‰¤k, we can ï¬nd a non-negative integer r
such that Remainder(r, mi) = ri for all i.
Proof. Let m be the product of m1, . . . , mk. For any non-negative integer r
less than m, deï¬ne the remainder sequence of r to be the sequence âŸ¨r1, . . . , rkâŸ©
where ri = Remainder(r, mi).
We claim that any two distinct non-negative
integers less than m have distinct remainder sequences. To see this, let r and
s be non-negative integers less than m. If r and s have the same remainder
sequence, then r âˆ’s is divisible by each of m1, . . . , mk. Since m1, . . . , mk are
pairwise relatively prime, it follows that r âˆ’s is divisible by m. Since r and
s are both less than m, we must have r = s. This proves the claim. Deï¬ne a
possible remainder sequence to be any sequence âŸ¨r1, . . . , rkâŸ©with 0 â‰¤ri < mi
for all i. The number of possible remainder sequences is exactly m. From this
and the claim, we see that any possible remainder sequence must actually occur
as the remainder sequence associated with some r in the range 0 â‰¤r < m. The
lemma follows immediately.
Example 2.2.13. Continuing the previous example, we see that for any non-
negative integers r1 < 7, r2 < 13, r3 < 19, r4 < 25, r5 < 31, there must be a
non-negative integer r less than 7Â·13Â·19Â·25Â·31 such that Remainder(r, 7) = r1,
. . . , Remainder(r, 31) = r5. We may view the integer r as a â€œcodeâ€ for the
sequence (r1, r2, r3, r4, r5). The â€œdecodingâ€ is accomplished by means of the
key integer 6, since ri = Remainder(r, 6i + 1).
53

Deï¬nition 2.2.14. For any non-negative integers r, a, i, we deï¬ne
Î²(r, a, i)
=
Remainder(r, a Â· (i + 1) + 1) .
This 3-place function is known as GÂ¨odelâ€™s Î²-function. Note that the Î²-function
is arithmetically deï¬nable.
The signiï¬cance of the Î²-function is that it can be used to encode an ar-
bitrary sequence of non-negative integers âŸ¨r0, r1, . . . , rkâŸ©by means of two non-
negative integers r and a. We make this precise in the following lemma.
Lemma 2.2.15. Given a ï¬nite sequence of non-negative integers r0, r1, . . . , rk,
we can ï¬nd a pair of non-negative integers r and a such that Î²(r, a, 0) = r0,
Î²(r, a, 1) = r1, . . . , Î²(r, a, k) = rk.
Proof. By Lemma 2.2.10 (replacing k by k + 1), we can ï¬nd a positive integer a
such that r0 < a+1, r1 < 2a+1, . . . , rk < (k +1)Â·a+1, and furthermore a+1,
2a + 1, . . . , (k + 1) Â· a + 1 are pairwise relatively prime. Then by Lemma 2.2.12
we can ï¬nd a non-negative integer r such that Remainder(r, a + 1) = r0,
Remainder(r, 2a + 1) = r1, . . . , Remainder(r, (k + 1) Â· a + 1) = rk. This proves
the lemma.
Exercise 2.2.16. Find a pair of numbers r, a such that Î²(r, a, 0) = 11, Î²(r, a, 1) =
19, Î²(r, a, 2) = 30, Î²(r, a, 3) = 37, Î²(r, a, 4) = 51.
Hint: First ï¬nd an appropriate a by hand. Then write a small computer program
to ï¬nd r by brute force.
We are now ready to prove Lemma 2.2.9.
Proof of Lemma 2.2.9. Let the total functions g(y1, . . . , yk) and h(x, z, y1, . . . , yk)
be deï¬ned by the formulas G(y1, . . . , yk, w) and H(x, z, y1, . . . , yk, w) respec-
tively. We wish to write down a formula F(x, y1, . . . , yk, w) which would say that
there exists a ï¬nite sequence r0, r1, . . . , rx such that G(y1, . . . , yk, r0) holds, and
H(i, ri, y1, . . . , yk, ri+1) holds for all i < x, and ï¬nally rx = w. If we could do
this, then clearly F(x, y1, . . . , yk, w) would deï¬ne the function f(x, y1, . . . , yk).
This would prove the lemma. The only diï¬ƒculty is that our language is not
powerful enough to talk directly about ï¬nite sequences of variable length in
the required way.
Our language allows us to say things like â€œthere exists a
non-negative integer r such that . . . ,â€ but it does not allow us to directly say
things like â€œthere exists a sequence of non-negative integers r0, r1, . . . , rx (of
variable length, x) such that . . . .â€ The way to overcome this diï¬ƒculty is to
use the Î²-function. Instead of saying â€œthere exists a ï¬nite sequence r0, r1, . . . ,
rk,â€ we can say â€œthere exists a pair of non-negative integers r and a which
encode the required sequence, via the Î²-function.â€ Namely, we write down a
formula F(x, y1, . . . , yk, w) which says, informally, there exist r and a such that
G(y1, . . . , yk, Î²(r, a, 0)) holds, and H(i, Î²(r, a, i), y1, . . . , yk, Î²(r, a, i + 1)) holds
for all i < x, and ï¬nally Î²(r, a, x) = w. By Lemma 2.2.15 it is clear that this
54

formula deï¬nes the function f(x, y1, . . . , yk). Formally, let B(r, a, i, w) be a for-
mula which deï¬nes the Î²-function. We may then take F(x, y1, . . . , yk, w) to be
the formula
âˆƒr âˆƒa ( âˆƒu (B(r, a, 0, u) âˆ§G(y1, . . . , yk, u)) âˆ§B(r, a, x, w) âˆ§
âˆ€i ( i â‰¥x âˆ¨âˆƒu âˆƒv (B(r, a, i, u) âˆ§B(r, a, i + 1, v) âˆ§H(i, u, y1, . . . , yk, v)) ) ) .
This completes the proof of Lemma 2.2.9.
Example 2.2.17. The exponential function Î»xy [ yx ] is arithmetically deï¬nable
by the formula
âˆƒr âˆƒa ( B(r, a, 0, 1) âˆ§B(r, a, x, w) âˆ§
âˆ€i ( i â‰¥x âˆ¨âˆƒu âˆƒv (B(r, a, i, u) âˆ§B(r, a, i + 1, v) âˆ§v = u Â· y) ) )
which we may abbreviate as Exp(x, y, w), meaning that yx = w.
Exercise 2.2.18. Consider the function f : N â†’N deï¬ned by
f(n) =
(
n/2
if n is even,
3n + 1
if n is odd.
For each k âˆˆN let
f k = f â—¦Â· Â· Â· â—¦f
|
{z
}
k
,
i.e., f 0(n) = n and f k+1(n) = f(f k(n)).
Write a formula F(x, y, z) in the language +, Â·, 0, 1, =, < which, when in-
terpreted over the natural number system N, deï¬nes the 3-place predicate
f x(y) = z.
Exercise 2.2.19. Show that the function Î»x [ the xth Fibonacci number ] is
arithmetically deï¬nable.
Exercise 2.2.20. Which of the following number-theoretic predicates are arith-
metically deï¬nable? Prove your answers.
1. x is the sum of all the prime numbers less than y.
2. xy = z.
3. x! = y.
Theorem 2.2.21. Every partial recursive function is arithmetically deï¬nable.
Proof. Recall that the partial recursive functions have been characterized as the
smallest class of functions which includes the initial functions and is closed under
composition, primitive recursion, and the least-number operator. Lemma 2.2.6
says that the class of arithmetically deï¬nable functions includes the initial func-
tions. Lemmas 2.2.7, 2.2.8, and 2.2.9 say that the class of arithmetically de-
ï¬nable functions is closed under composition, the least-number operator, and
primitive recursion, respectively.
It follows that the arithmetically deï¬nable
functions include the partial recursive functions.
55

Corollary 2.2.22. There exists a set K âŠ†N which is arithmetically deï¬nable
but not recursive.
Proof. Recall that
K = {x âˆˆN | Ï•(1)
x (x) is convergent}
is our basic example of a non-recursive set.
By the Enumeration Theorem,
the 2-place partial function Î»xy[Ï•(1)
x (y)] is partial recursive. Hence, by Theo-
rem 2.2.21 Î»xy[Ï•(1)
x (y)] is arithmetically deï¬nable. Let F(x, y, z) be a formula
which deï¬nes this function. Then K is deï¬ned by the formula âˆƒzF(x, x, z). This
completes the proof.
More generally, recall our discussion of the arithmetical hierarchy in Chap-
ter 1, Section 1.9. The next theorem characterizes arithmetically deï¬nability
(Deï¬nition 2.2.1) in terms of the arithmetical hierarchy (Deï¬nition 1.9.1).
Theorem 2.2.23. Let P be a k-place predicate, P âŠ†Nk. The following are
equivalent:
1. P is arithmetically deï¬nable;
2. P belongs to the arithmetical hierarchy, i.e., P belongs to the class Î£0
n for
some n âˆˆN.
Proof. Theorem 2.2.21 implies that every predicate in the class Î£0
0 (= Î 0
0) is
arithmetically deï¬nable. From this it is straightforward to prove by induction
on n âˆˆN that every predicate in the class Î£0
n âˆªÎ 0
n is arithmetically deï¬nable.
For the converse, put
Î£0
âˆ
=
[
nâˆˆN
Î£0
n
=
[
nâˆˆN
Î 0
n .
By Theorem 1.9.2, the class Î£0
âˆis closed under Boolean connectives âˆ§, âˆ¨, Â¬ and
universal and existential quantiï¬cation âˆ€and âˆƒ. From this it follows that every
arithmetically deï¬nable predicate P belongs to the class Î£0
âˆ; this is proved by
induction on the number of symbols in a deï¬ning formula for P.
Exercise 2.2.24. Let A and B be subsets of N. Prove that if A is reducible to
B and B is arithmetically deï¬nable, then A is arithmetically deï¬nable.
Exercise 2.2.25. For each n â‰¥1 let Cn be a set which is Î£0
n complete. Consider
the set B = {2n3x | x âˆˆCn}. Prove that B is not arithmetically deï¬nable.
Remark 2.2.26 (Hilbertâ€™s Tenth Problem). A reï¬nement of Theorem 2.2.23
due to Matiyasevich 1967 is as follows. Let us say that P âŠ†Nk is Diophantine
if P = Ï€l(Q) for some l â‰¥0 and some strongly Diophantine Q âŠ†Nk+l. Thus
P = {âŸ¨a1, . . . , akâŸ©âˆˆNk | âˆƒâŸ¨b1, . . . , blâŸ©âˆˆNl (f(a1, . . . , ak, b1, . . . , bl) = 0)}
56

where f(x1, . . . , xk, y1, . . . , yl) is a polynomial with integer coeï¬ƒcients. Matiya-
sevichâ€™s Theorem states that P is Diophantine if and only if P is Î£0
1.
A corollary of Matiyasevichâ€™s Theorem is that, for example, the sets K and H
are Diophantine. Thus, we can ï¬nd a polynomial f(z, x1, . . . , xl) with integer
coeï¬ƒcients, such that the set of a âˆˆN for which f(a, x1, . . . , xl) = 0 has a
solution in N is nonrecursive. Here it is known that one can take l = 9, but
l = 8 is an open question.
Hilbertâ€™s Tenth Problem, as stated in Hilbertâ€™s famous 1900 problem list,
reads as follows:
To ï¬nd an algorithm which allows us, given a polynomial equation in
several variables with integer coeï¬ƒcients, to decide in a ï¬nite number
of steps whether or not the equation has a solution in integers.
From Matiyasevichâ€™s Theorem plus the unsolvability of the Halting Problem, it
follows that there is no such algorithm. In other words, Hilbertâ€™s Tenth Problem
is unsolvable.
A full exposition of Hilbertâ€™s Tenth Problem and the proof of Matiyasevichâ€™s
Theorem is in my lecture notes for Math 574, Spring 2005, at
http://www.math.psu.edu/simpson/notes/.
Exercise 2.2.27. Recall that N = {0, 1, 2, . . .} = the natural numbers, while
Z = {. . . , âˆ’2, âˆ’1, 0, 1, 2, . . .} = the integers. In our formulation of Matiyase-
vichâ€™s Theorem, we have spoken of solutions in N. What happens if we replace
â€œsolution in Nâ€ by â€œsolution in Zâ€?
Hint: Use the following well-known theorem of Lagrange: For each n âˆˆN there
exist a, b, c, d âˆˆN such that n = a2 + b2 + c2 + d2.
2.3
GÂ¨odel Numbers of Formulas
For each formula F in the language of arithmetic, we shall deï¬ne a unique
positive integer #(F), which will be called the GÂ¨odel number of F. The number
#(F) will serve as a â€œcodeâ€ for the formula F.
Before assigning GÂ¨odel numbers to formulas, we shall ï¬rst assign GÂ¨odel
numbers to terms. We deï¬ne
#(0)
=
1
#(1)
=
3
#(xi)
=
32 Â· 5i
#(t1 + t2)
=
33 Â· 5#(t1) Â· 7#(t2)
#(t1 Â· t2)
=
34 Â· 5#(t1) Â· 7#(t2)
For example, the GÂ¨odel number of the term 1 + x0 is
#(1 + x0) = 33 Â· 53 Â· 79
57

since #(1) = 3 and #(x0) = 9.
We now deï¬ne the GÂ¨odel numbers of formulas:
#(t1 = t2)
=
2 Â· 5#(t1) Â· 7#(t2)
#(F âˆ§G)
=
2 Â· 3 Â· 5#(F ) Â· 7#(G)
#(F âˆ¨G)
=
2 Â· 32 Â· 5#(F ) Â· 7#(G)
#(Â¬ F)
=
2 Â· 33 Â· 5#(F )
#(âˆ€xiF)
=
2 Â· 34 Â· 5i Â· 7#(F )
#(âˆƒxiF)
=
2 Â· 35 Â· 5i Â· 7#(F )
For example, the GÂ¨odel number of the formula âˆƒx1(x1 = 1) is
#(âˆƒx1(x1 = 1))
=
2 Â· 35 Â· 51 Â· 72Â·545Â·73
since #(x1) = 45, #(1) = 3, and #(x1 = 1) = 2 Â· 545 Â· 73.
If F is any collection of formulas, we denote by #(F) the collection of all
GÂ¨odel numbers of formulas in F. Let
Fml = #(all formulas) ,
Snt = #(all sentences) ,
and
TrueSnt = #(all true sentences) .
Note that Fml, Snt, and TrueSnt are subsets of N.
Theorem 2.3.1. The sets Fml and Snt are primitive recursive.
Proof. The proof is straightforward and we omit it.
We are going to prove that the set TrueSnt is nonrecursive. In other words,
the problem of deciding whether a given sentence of the language of arithmetic
is true or false is unsolvable. This result may be paraphrased as â€œarithmetical
truth is undecidable,â€ or simply, â€œarithmetic is undecidable.â€
Theorem 2.3.2. Every arithmetically deï¬nable set A âŠ†N is reducible to
TrueSnt.
Proof. Given an arithmetically deï¬nable set A, let F(x1) be a formula with one
free variable x which deï¬nes A, i.e.,
A
=
{m âˆˆN | F(m) is true} .
Deï¬ne
f(m)
=
#(âˆƒx1(x1 = m âˆ§F(x1))) .
58

Thus for all m âˆˆN we have that m âˆˆA if and only if f(m) âˆˆTrueSnt. We
claim that the function f : N â†’N is primitive recursive. This is clear since
f(m) = 2 Â· 33 Â· 72Â·3Â·5#(x1=m)Â·7#(F (x1))
where
#(x1 = m) = 2 Â· 545 Â· 7#(m) ,
and #(m) = #(1 + . . . + 1
|
{z
}
m
) can be deï¬ned primitive recursively by
#(0)
=
1 ,
#(m + 1)
=
33 Â· 5#(m) Â· 73 .
Thus A is reducible to TrueSnt via f. This proves the theorem.
Theorem 2.3.3. TrueSnt is not recursive.
Proof. By Corollary 2.2.22 we have an arithmetically deï¬nable set K which is
not recursive. By the previous theorem K is reducible to TrueSnt. Hence by
Lemma 1.7.8 TrueSnt is not recursive.
More generally we have the following theorem, which may be paraphrased
as â€œarithmetical truth is not arithmetically deï¬nable.â€
Theorem 2.3.4 (Tarski). TrueSnt is not arithmetically deï¬nable.
Proof. Suppose that TrueSnt were arithmetically deï¬nable.
Then by Theo-
rem 2.2.23 we would have that TrueSnt belongs to the class Î£0
n for some n.
By Theorem 1.9.18, let C be a complete Î£0
n+1 set. By Theorem 2.2.23 C is
arithmetically deï¬nable. Hence by Theorem 2.3.2 C is reducible to TrueSnt.
Hence by Lemma 1.9.16 C belongs to the class Î£0
n. This contradicts that fact
(Theorem 1.9.18) that a complete Î£0
n+1 set can never belong to the class Î£0
n.
This completes the proof.
Exercise 2.3.5. Prove that the set Fml of all GÂ¨odel numbers of formulas is
primitive recursive.
Exercise 2.3.6. Prove that the set Snt of all GÂ¨odel numbers of sentences is
primitive recursive.
59

Chapter 3
The Real Number System
In Chapter 2 we have shown that TrueSntN is nonrecursive, i.e., the theory of
the natural number system is undecidable. In this Chapter we shall show that,
by contrast, TrueSntR is recursive, i.e., the theory of the real number system is
decidable.
3.1
Quantiï¬er Elimination
Let LOR be the language of ordered rings, i.e.,
LOR = (+, âˆ’, Â·, 0, 1, <, =)
where + and Â· are 2-ary operation symbols, âˆ’is a 1-ary operation symbol, <
and = are 2-place predicate symbols, and 0 and 1 are constant symbols. We
consider the LOR-structure
R = (R, +R, âˆ’R, Â·R, 0R, 1R, <R, =R) ,
i.e., the real number system, the ordered ï¬eld of real numbers. Formulas of LOR
are interpreted with reference to R, i.e., âˆƒx . . . means â€œthere exists x âˆˆR such
that . . . ,â€ etc.
Two LOR-formulas F and G are said to be equivalent if they have the same
free variables x1, . . . , xk and deï¬ne the same k-place predicate P âŠ†Rk. An
equivalent condition is that the sentence
âˆ€x1 Â· Â· Â· âˆ€xk (F(x1, . . . , xk) â‡”G(x1, . . . , xk))
is true in R.
We are going to prove the following theorem, due originally to Tarski:
Theorem 3.1.1 (Quantiï¬er Elimination). For any LOR-formula F, we can ï¬nd
an equivalent quantiï¬er free LOR-formula F âˆ—.
60

Example 3.1.2. The formula
âˆƒx (ax2 + bx + c = 0)
is equivalent to the quantiï¬er free formula
(a = 0 âˆ§b = 0 âˆ§c = 0) âˆ¨(a = 0 âˆ§b Ì¸= 0) âˆ¨(a Ì¸= 0 âˆ§b2 âˆ’4ac â‰¥0) .
Exercise 3.1.3. Find quantiï¬er-free formulas in the language +, âˆ’, Â·, 0, 1, <, =
which are equivalent, over the real number system R, to:
1. âˆƒx (ax2 + bx + c > 0).
2. âˆƒx (ax3 + bx2 + cx + d > 0).
3. âˆƒx (ax4 + bx3 + cx2 + dx + e > 0).
Exercise 3.1.4. Does there exist a constant c such that the following holds?
Given a formula F(x) in the language +, Â·, 0, 1, = with exactly one
free variable x, we can ï¬nd a formula F âˆ—(x) in the same language
which is equivalent to F(x) over the natural number system N, and
which contains at most c quantiï¬ers.
Prove your answer.
Remark 3.1.5. The only properties of R that will be used in the proof of
Theorem 3.1.1 are: (1) R is a commutative ordered ï¬eld; and (2) R has the
intermediate value property for polynomials, i.e.,
( x < y âˆ§p(x) < 0 < p(y) ) â‡’âˆƒz ( x < z < y âˆ§p(z) = 0 )
for any polynomial p(x) âˆˆR[x]. An ordered ï¬eld with these properties is called
a real closed ordered ï¬eld. This is related to Hilbertâ€™s 17th Problem.
Remark 3.1.6. The proof of Theorem 3.1.1 which we shall present below is
due to P. J. Cohen. In order to present the proof, we shall deï¬ne and study a
class of functions called the eï¬€ective functions. This notion of eï¬€ectivity has no
importance beyond the proof of Theorem 3.1.1. See also Corollary 3.1.21 below.
Deï¬nition 3.1.7. A predicate A on the reals, i.e., A âŠ†Rk, is said to be ef-
fective if it is deï¬nable over R by a quantiï¬er free formula. That is, A is a
Boolean combination of sets in Rk which are deï¬ned by equations and inequa-
tions p(x1, . . . , xk) = 0, p(x1, . . . , xk) > 0, where p âˆˆZ[x1, . . . , xk].
Remark 3.1.8. If we allow parameters from R, we get semi-algebraic sets.
Thus â€œeï¬€ective = semi-algebraic with parameters from Zâ€.
Deï¬nition 3.1.9. A function f : D â†’R, D âŠ†Rk is said to be eï¬€ective if
61

1. D is eï¬€ective, and
2. for every eï¬€ective predicate A(x1, . . . , xk, y, z1, . . . , zn), the predicate
B(x1, . . . , xk, z1, . . . , zn) â‰¡A(x1, . . . , xk, f(x1, . . . , xk), z1, . . . , zn)
is eï¬€ective.
Example 3.1.10. It can be shown that the function âˆšx is eï¬€ective. This is
because, ï¬rst, the domain of âˆšx is the eï¬€ective set {x âˆˆR | x â‰¥0}, and second,
for instance, âˆšx > 3 â‰¡x > 9.
In order to prove Theorem 3.1.1, we shall build up a library of eï¬€ective
functions. We shall use notations such as x and y to abbreviate sequences of
variables such as x1, . . . , xk and y1, . . . , ym.
Lemma 3.1.11. The functions x + y, x Â· y, âˆ’x and x/y are eï¬€ective.
Proof. For x+y, xÂ·y and âˆ’x there is nothing to prove. For x/y, note ï¬rst that
the domain is {(x, y) | y Ì¸= 0} which is obviously eï¬€ective. It remains to show
that if A(z, . . .) is an eï¬€ective predicate then so is A(x/y, . . .). The latter is a
Boolean combination of predicates of the form
an
x
y
n
+ . . . + a1
x
y

+ a0 > 0
and this is equivalent to the atomic formula
anxn + anâˆ’1xnâˆ’1y + . . . + a1xynâˆ’1 + a0yn > 0 ,
assuming as we may that n is even.
Corollary 3.1.12. Any rational function
f(x1, . . . , xk) âˆˆQ(x1, . . . , xk)
is eï¬€ective.
Lemma 3.1.13. The composition of eï¬€ective functions is eï¬€ective.
Proof. Consider for instance f(g(x)) where f and g are eï¬€ective 1-place func-
tions. If D(y) is a quantiï¬er-free formula deï¬ning the dom(f), then D(g(x))
deï¬nes the dom(fg), which is therefore eï¬€ective. If A(y, z) is any eï¬€ective pred-
icate, then clearly A(f(y), z) is eï¬€ective, hence A(f(g(x)), z) is eï¬€ective.
Lemma 3.1.14. The function
sgn(x) =
ï£±
ï£´
ï£²
ï£´
ï£³
1
if x > 0
0
if x = 0
âˆ’1
if x < 0.
is eï¬€ective.
62

Proof. Let A(y, z) be an eï¬€ective predicate. Then A(sgn(x), z) is equivalent to
equivalent to
(x > 0 âˆ§A(1, z)) âˆ¨(x = 0 âˆ§A(0, z)) âˆ¨(x < 0 âˆ§A(âˆ’1, z))
which is again eï¬€ective. This proves the lemma.
More generally we have:
Lemma 3.1.15. If a function f(x) takes only ï¬nitely many values, all integers,
then f(x) is eï¬€ective if and only if for each j âˆˆZ, the predicate f(x) = j is
eï¬€ective.
Proof. If: Let j1, . . . , jn be the ï¬nitely many values. For any eï¬€ective predicate
A(y, z), the predicate A(f(x), z) is equivalent to
(f(x) = j1 âˆ§A(j1, z)) âˆ¨Â· Â· Â· âˆ¨(f(x) = jn âˆ§A(jn, z))
and is therefore eï¬€ective.
Only if: Trivial.
Lemma 3.1.16 (Deï¬nition by Cases). If two functions f1(x) and f2(x) and a
predicate A(x) are eï¬€ective, then the function
f(x) =
(
f1(x)
if A(x),
f2(x)
if Â¬ A(x)
is eï¬€ective.
Proof. We must show that, for each eï¬€ective predicate B(y, z), the predicate
C(x, z) â‰¡B(f(x), z) is eï¬€ective. This is so because C(x, z) is equivalent to
(A(x) âˆ§B(f1(x), z)) âˆ¨(Â¬ A(x) âˆ§B(f2(x), z)) .
Since f1(x) and f2(x) and B(y, z) are eï¬€ective, B(f1(x), z) and B(f2(x), z) are
eï¬€ective. Since A(x) is eï¬€ective, it follows that C(x, z) is eï¬€ective. This proves
the lemma.
The extension of the previous lemma to more than two cases is obvious.
Lemma 3.1.17. A function f(x) is eï¬€ective if and only if for every positive
integer d â‰¥1 and every polynomial q(y) âˆˆR[y] of degree d, sgn(q(f(x))) is an
eï¬€ective function of x and the d + 1 coeï¬ƒcients of q(y).
Proof. Only if: Trivial, since for instance
sgn(q(f(x))) = 1
â‰¡
q(f(x)) > 0
â‰¡
A(f(x)),
where A(y) is the predicate q(y) > 0.
63

If: We must show that if A(y, z) is eï¬€ective then A(f(x), z) is eï¬€ective. Note
that A(y, z) can be viewed as a Boolean combination of atomic predicates of the
form p(y, z) > 0, for various polynomials p(y, z) with coeï¬ƒcients in Z. It suï¬ƒces
to show that the predicates p(f(x), z) > 0 are eï¬€ective. In order to show this,
write p(y, z) = q(y) âˆˆZ[z][y] i.e., q(y) is a polynomial in y whose coeï¬ƒcients
are polynomials in z with integer coeï¬ƒcients. Then
p(f(x), z) > 0
â‰¡
sgn(q(f(x))) = 1 .
By assumption sgn(q(f(x))) is an eï¬€ective function of x and the coï¬ƒcients of
q; hence by composition sgn(q(f(x))) is an eï¬€ective function of x and z.
The next lemma says that the real roots of a polynomial are eï¬€ective func-
tions of the coeï¬ƒcients. For example, the quadratic formula
x = âˆ’b Â±
âˆš
b2 âˆ’4ac
2a
shows that the roots of ax2 + bx + c are eï¬€ective functions of a, b and c.
Lemma 3.1.18 (Main Lemma). Let p(x) = anxn + Â· Â· Â· + a1x + a0 âˆˆR[x].
Write a = a0, . . . , an. There are n + 1 eï¬€ective functions Î¾1(a), . . . , Î¾n(a), and
k = k(a) such that
Î¾1(a) < Â· Â· Â· < Î¾k(a)
are all of the real roots of p(x).
Proof. By induction on n. Let
pâ€²(x)
=
nanxnâˆ’1 + Â· Â· Â· + 2a2x + a1
be the derivative of p(x). This is of degree â‰¤nâˆ’1. By inductive hypothesis, the
roots of pâ€²(x) are among t1 < Â· Â· Â· < tm, m = n âˆ’1, where the tiâ€™s are eï¬€ective
function of a. Note that p(x) is monotone on each of the open intervals
(âˆ’âˆ, t1) , (t1, t2) , . . . , (tmâˆ’1, tm) , (tm, +âˆ)
So, in each of these intervals, there is at most one root of p(x). In addition the
tiâ€™s could be roots of p(x). Thus the number of roots is determined by sgn(p(ti)),
1 â‰¤i â‰¤n âˆ’1 and sgn(pâ€²(t1 âˆ’1)) and sgn(pâ€²(tn + 1)). We can therefore use
deï¬nition by cases to obtain k(a) as an eï¬€ective function of a.
It remains to show that the roots themselves are eï¬€ective functions of a.
Consider for example a root Î¾ = Î¾(a) in the interval (t1, t2) where p(t1) > 0 and
p(t2) < 0. By the previous lemma, it suï¬ƒces to show that, for each d â‰¥1 and
polynomial q(x) of degree d, sgn(q(Î¾)) is eï¬€ective (as a function of a and the
coeï¬ƒcients of q).
Replacing q(x) by its remainder on division by p(x), we may assume deg(q(x)) <
n. [Details: Long division gives q(x) = p(x) Â· f(x) + r(x), where deg(r(x)) < n
and the coeï¬ƒcients of r(x) are eï¬€ective functions of the coeï¬ƒcients of p(x) and
q(x). We can replace q(x) by r(x).]
64

By induction hypothesis, the roots of q(x) can be found eï¬€ectively. Let the
roots of q(x) be among u1 < Â· Â· Â· < um. Then the sign of q(x) on the m + 1
intervals
(âˆ’âˆ, u1) , (u1, u2) , . . . , (umâˆ’1, um) , (um, +âˆ)
is given by m + 1 eï¬€ective functions
sgn(q(u1âˆ’1)) , sgn

q
u1 + u2
2

, . . . , sgn

q
umâˆ’1 + um
2

, sgn(q(um+1)) .
Moreover the position of Î¾ relative to the uiâ€™s is determined by the positions of t1
and t2 relative to the uiâ€™s and by the sgn(p(ui))â€™s. Thus we can use deï¬nition by
cases to obtain sgn(q(Î¾)) as an eï¬€ective function. In view of the previous lemma
characterizing eï¬€ective functions, this shows that Î¾ is an eï¬€ective function. The
proof of the Main Lemma is now complete.
Lemma 3.1.19. If A(x1, x2, . . . , xk) is an eï¬€ective predicate, then the predicate
B(x2, . . . , xk)
â‰¡
âˆƒx1 A(x1, x2, . . . , xk)
is eï¬€ective.
Proof. The predicate A(x1, x2, . . . , xk) may be viewed as a Boolean combination
of polynomial inequalities of the form pi(x1) > 0, 1 â‰¤i â‰¤l, where the coeï¬ƒ-
cients of the pi(x)â€™s are polynomials in x2, . . . , xk with integer coeï¬ƒcients. By
the Main Lemma, the roots of the pi(x)â€™s are eï¬€ective function of x2, . . . , xk. Let
Î¾1, . . . , Î¾m be all of these roots. Hence the pi(x)â€™s change sign only at Î¾1, . . . , Î¾m.
It follows that
âˆƒx1 A(x1, x2, . . . , xk)
is equivalent to a ï¬nite disjunction
A(Î·1, x2, . . . , xk) âˆ¨Â· Â· Â· âˆ¨A(Î·n, x2, . . . , xk) ,
where Î·1, . . . , Î·n is a list of all the Î¾iâ€™s and (Î¾i + Î¾j)/2â€™s and Î¾i Â± 1â€™s. Since the
Î·iâ€™s are eï¬€ective functions of x2, . . . , xk, it follows that the above disjunction is
an eï¬€ective predicate of x2, . . . , xk. This proves the lemma.
Theorem 3.1.20. Any predicate A âŠ†Rk which is deï¬nable over R is eï¬€ective.
Proof. A âŠ†Rk is deï¬ned over R by a formula F(x1, . . . , xk) of LOR. Therefore,
it suï¬ƒces to show that any formula F of LOR is equivalent over R to a quantiï¬er
free formula F âˆ—. We shall prove this by induction on the number of symbols in
F.
If F is quantiï¬er free, we may take F âˆ—â‰¡F.
If F â‰¡Â¬ G, then we may take F âˆ—â‰¡Â¬ Gâˆ—.
If F â‰¡G âˆ§H, then we may take F âˆ—â‰¡Gâˆ—âˆ§Hâˆ—.
If F â‰¡âˆƒx G, let F(y) â‰¡âˆƒx G(x, y), where y is a list of the free variables
of F.
By the inductive hypothesis, G(x, y) is equivalent to a quantiï¬er-free
formula Gâˆ—(x, y). Then Gâˆ—(x, y) deï¬nes an eï¬€ective predicate B(x, y). By the
65

previous lemma, the predicate A(y) â‰¡âˆƒx B(x, y) is eï¬€ective, i.e., is deï¬ned by
a quantiï¬er free formula F âˆ—(y). Clearly F is equivalent to F âˆ—. This completes
the proof.
Corollary 3.1.21. For a predicate A âŠ†Rk the following three conditions are
equivalent:
1. A is eï¬€ective.
2. A is deï¬nable over R.
3. A is deï¬nable over R by a quantiï¬er free formula.
Similarly for functions f : D â†’R, D âŠ†Rk.
Proof. For predicates this follows immediately from Theorem 3.1.20. Consider
now a function f. Note ï¬rst that if f is eï¬€ective then the predicate y = f(x) is
eï¬€ective, i.e., deï¬nable by a quantiï¬er free formula. Conversely, suppose that f
is deï¬nable. Then for any eï¬€ective predicate A(y, z), the predicate A(f(x), z) is
equivalent to the deï¬nable predicate âˆƒy (y = f(x) âˆ§A(y, z)), which is therefore
eï¬€ective in view of what has already been proved. Thus f is eï¬€ective.
Theorem 3.1.22 (Quantiï¬er Elimination). If a predicate A âŠ†Rk is deï¬nable
over R, then it is deï¬nable over R by a quantiï¬er free formula.
Proof. This is merely a restatement of the previous corollary.
Proof of Theorem 3.1.1. Theorem 3.1.1 is a restatement of the previous theo-
rem.
3.2
Decidability of the Real Number System
Theorem 3.2.1. Given a formula F of LOR, there is an algorithm to ï¬nd an
equivalent quantiï¬er free formula F âˆ—.
Proof. The algorithm can be obtained by tracing back through the proof of
Theorem 3.1.22.
Theorem 3.2.2. Given a sentence S of LOR, there is an algorithm to determine
whether or not R satisï¬es S, i.e., whether S is true in the real number system.
Proof. Given a sentence S, a special case of the previous theorem is that we can
algorithmically compute Sâˆ—, an equivalent quantiï¬er free sentence. But then Sâˆ—
is a Boolean combination of atomic sentences of the form t1 = t2 and t1 < t2
where t1 and t2 are variable-free terms, for example 1+(0+1) < (1+1)Â·âˆ’(1+0),
and the truth value of such sentences is easily computed. This completes the
proof.
66

Corollary 3.2.3. The set
TrueSntR = {#(S) | S is a sentence âˆ§S is true in R}
is recursive.
Proof. This follows from the previous Theorem plus Churchâ€™s Thesis. Alterna-
tively, we can convert the proof of Theorem 3.1.1 into a rigorous proof that the
function taking #(F) to #(F âˆ—) is primitive recursive.
Exercise 3.2.4. Recall that N = {0, 1, 2, . . .} = the natural numbers, Z =
{. . . , âˆ’2, âˆ’1, 0, 1, 2, . . .} = the integers, and R = (âˆ’âˆ, âˆ) = the real numbers.
Show that TrueSntN and TrueSntZ are not recursive. (This is in contrast to
the fact that TrueSntR is recursive.)
Theorem 3.2.5. The theory of the ordered ring of real numbers is decidable.
Proof. This is a restatement of the previous corollary.
Corollary 3.2.6. Plane and solid geometry are decidable.
Proof. By the methods of Cartesian analytic geometry, the theory of points,
lines and circles in the plane is interpretable into the theory of the real numbers.
For example, a point is an ordered pair (x, y) where x and y are real numbers.
A line is an ordered quadruple (a, b, u, v) where (u, v) Ì¸= (0, 0). A point (x, y)
lies on a line (a, b, u, v) if and only if
âˆƒt (x = a + tu âˆ§y = b + tv) .
Two lines are considered identical if and only if they contain the same points.
A circle is an ordered triple (a, b, r) where r > 0. A point (x, y) lies on a circle
(a, b, r) if and only if (x âˆ’a)2 + (y âˆ’b)2 = r2. A triangle consists of three
non-collinear points, the vertices of the triangle. Etc., etc.
Similarly for the theory of points, lines, planes, circles, and spheres in space.
Exercise 3.2.7. Write sentences of the language +, âˆ’, Â·, 0, 1, <, = which, when
interpreted over the real number system, express the following statements of
Euclidean plane geometry.
1. For every two points, there is a unique line passing through them.
2. For every three non-collinear points, there is a unique circle passing through
them.
3. For every line L and circle C, the intersection of L and C consists of at
most two points.
4. Given a line L and a point P, among all points on L there is exactly one
which is at minimum distance from P.
67

5. For every circle C and point P lying on C, there exists one and only one
line L such that L âˆ©C = P. (I.e., a tangent line.)
6. Every line segment has a unique midpoint.
7. Every angle can be uniquely bisected.
Exercise 3.2.8. Explain in detail how you would translate the following state-
ments of Euclidean plane geometry into sentences of the language +, âˆ’, Â·, 0, 1, <
, = over the real number system.
1. The three angle bisectors of any triangle meet in a single point.
2. Every angle can be uniquely trisected.
Exercise 3.2.9. Recall that N = {0, 1, 2, . . .} = the natural numbers, Z =
{. . . , âˆ’2, âˆ’1, 0, 1, 2, . . .} = the integers, and R = (âˆ’âˆ, âˆ) = the real numbers.
According to Matiyasevichâ€™s Theorem, we can ï¬nd a polynomial
f(w, x1, . . . , xk)
with integer coeï¬ƒcients, such that the set of a âˆˆN for which the equation
f(a, x1, . . . , xk) = 0 has a solution in N is noncomputable.
1. Discuss the analogous question in which â€œsolution in Nâ€ is replaced by
â€œsolution in Zâ€.
2. Discuss analogous questions in which â€œsolution in Nâ€ is replaced by â€œso-
lution in Râ€.
68

Chapter 4
Informal Set Theory
The purpose of this chapter is to develop set theory in an informal, preaxiomatic
way. A good reference for this material is NaÂ¨Ä±ve Set Theory by P. R. Halmos.
4.1
Operations on Sets
Informally, a set is any collection of objects which may be regarded as a com-
pleted totality. We use capital letters X, Y , . . .
to denote sets. If a is any
object and X is any set, we write a âˆˆX to mean that a belongs to X, and
a /âˆˆX to mean that a does not belong to X. Synonyms for â€œbelongs toâ€ are â€œis
an element ofâ€, â€œis a member ofâ€, and â€œis contained inâ€.
Since a set is nothing but a collection of elements, the set itself having no
further structure, it follows that two sets are equal if and only if they contain
exactly the same elements. Symbolically,
X = Y
â‡”
âˆ€a (a âˆˆX â‡”a âˆˆY ) .
This is known as the principle of extensionality. It can be taken as a deï¬nition
of equality between sets.
If P(a) is any deï¬nite property that an object a may or may not have,
we use the notation {a | P(a)} to denote the set of all objects a which have
property P, if such a set exists. (If such a set exists, it will be unique in view
of extensionality.)
In order to be a set, a collection of objects must be limited in size and
deï¬nite. These requirements are rather vague, but we shall try to give some
explanation of what they entail. Deï¬niteness means that any object a either
belongs or does not belong to the collection, i.e., there is no third possibility.
Limitedness means that the collection is in some sense not too large. The need
for some limitation-of-size requirement will be shown below in connection with
the Russell paradox.
One of the most basic concepts in set theory is that of one set being included
in another. We say that Y is a subset of X, symbolically Y âŠ†X, if every element
69

of Y is an element of X, i.e.,
âˆ€a (a âˆˆY â‡’a âˆˆX) .
If P(a) is any deï¬nite property as above, and if X is any set, we can form
a subset Y = {a âˆˆX | P(a)}, consisting of all elements a of X which have
property P. Thus
âˆ€a(a âˆˆY â‡”(a âˆˆX âˆ§P(a))) .
Note that any set X is itself a mathematical object and as such can be an
element of another set. Indeed, given a set X, we can form a set
P(X) = {Y | Y âŠ†X} ,
called the power set of X, whose elements are all possible subsets of X.
We now prove a theorem which implies that not all deï¬nite collections of
mathematical objects are sets. This means that some limitation-of-size principle
is needed.
Theorem 4.1.1 (Russell Paradox). The collection of all sets is not itself a set.
Proof. Suppose to the contrary that there were a set S consisting of all sets.
Form the subset D consisting of all sets which are not members of themselves.
Symbolically,
D = {X âˆˆS | X /âˆˆX} .
Then D âˆˆD if and only if D /âˆˆD, a contradiction. This completes the proof.
The Russell Paradox shows that we cannot form sets with complete freedom.
Nevertheless, a wide variety of sets can be formed. Some examples of sets are âˆ…
(the empty set, i.e., the unique set which has no elements), {âˆ…} (the one-element
set whose unique element is the empty set), {âˆ…, {âˆ…}}, etc. For any objects a,
b, and c, we can form the set {a, b, c} whose elements are exactly a, b, and c.
The cardinality of this set will be one, two or three depending on which of a,
b, and c are equal to each other. Some examples of inï¬nite sets are N (the
set of natural numbers), R (the set of real numbers), P(N), P(R), P(P(R)),
etc. Another source of examples is subsets deï¬ned by properties, for example
{n âˆˆN | n is prime} and {X âŠ†R | X is countably inï¬nite}. Further sets can
be obtained using the set operations discussed below.
Given two objects a and b, there is an object (a, b) called the ordered pair of
a and b. The ordered pair operation is assumed to have the following property:
(a, b) = (aâ€², bâ€²)
â‡”
(a = aâ€² âˆ§b = bâ€²) .
Given two sets X and Y , the Cartesian product X Ã— Y is the set of all ordered
pairs (a, b) such that a âˆˆX and b âˆˆY .
For any set X, a function with domain X is a rule f associating to each
object a âˆˆX a deï¬nite, unique object f(a). In this case we write dom(f) = X
and rng(f) = {f(a) | a âˆˆX}. The latter is again a set, called the range of F.
70

If f is a function and Z is a set, there is a unique function fâ†¾Z, the restriction
of f to Z, whose domain is dom(f) âˆ©Z and such that (fâ†¾Z)(a) = f(a) for all
a in its domain.
We write f : X â†’Y to mean that f is a function, dom(f) = X, and
rng(f) âŠ†Y . The set of all such functions is denoted Y X.
Summarizing some of the above points, we have the following binary opera-
tions on sets:
X âˆªY
=
{a | a âˆˆX âˆ¨a âˆˆY }
(union) ,
X âˆ©Y
=
{a | a âˆˆX âˆ§a âˆˆY }
(intersection) ,
X \ Y
=
{a | a âˆˆX âˆ§a /âˆˆY }
(diï¬€erence) ,
X Ã— Y
=
{(a, b) | a âˆˆX âˆ§b âˆˆY }
(product) ,
XY
=
{f | f : Y â†’X}
(exponential) .
By an indexed collection with index set I, we mean simply a function f
whose domain is I. In discussing indexed collections, we use notation such as
f = âŸ¨aiâŸ©iâˆˆI where ai = f(i). For example, an ordered n-tuple âŸ¨a1, . . . , anâŸ©is
a function whose domain is {1, . . . , n}, and a sequence âŸ¨anâŸ©nâˆˆN is a function
whose domain is N.
Given an indexed collection of sets âŸ¨XiâŸ©iâˆˆI, the following operations are
deï¬ned.
S
iâˆˆI Xi
=
{a | âˆƒi âˆˆI (a âˆˆXi)}
(union) ,
T
iâˆˆI Xi
=
{a | âˆ€i âˆˆI (a âˆˆXi)}
(intersection) ,
Q
iâˆˆI Xi
=
{âŸ¨aiâŸ©iâˆˆI | âˆ€i âˆˆI (ai âˆˆXi)}
(product) .
If in the latter operation we take all of the sets Xi to be the same set X, we get
the Cartesian power
Q
iâˆˆI X = XI
which is the same as the previously mentioned exponential.
The Axiom of Choice is the assertion that, for any indexed collection of sets
âŸ¨XiâŸ©iâˆˆI, if âˆ€i âˆˆI (Xi Ì¸= âˆ…) then Q
iâˆˆI Xi Ì¸= âˆ…. This implies that it is possible
to choose one element ai âˆˆXi for each i âˆˆI. In the early years of set theory,
there was some controversy about the Axiom of Choice. Nowadays the Axiom of
Choice is accepted as being intuitively obvious, but we shall follow the custom
of indicating which proofs use it.
4.2
Cardinal Numbers
A function f is said to be one-to-one if for all a, aâ€² âˆˆdom(f), a Ì¸= aâ€² implies
f(a) Ì¸= f(aâ€²).
Note that in this case there is an inverse function f âˆ’1 with
dom(f âˆ’1) = rng(f) and rng(f âˆ’1) = dom(f), deï¬ned by
f âˆ’1(b) = a
â‡”
f(a) = b .
71

Deï¬nition 4.2.1. If X and Y are sets, we say X is equinumerous with Y ,
written X â‰ˆY , if there exists a one-to-one correspondence between X and Y ,
i.e., a one-to-one function f with dom(f) = X and rng(f) = Y .
Lemma 4.2.2.
1. X â‰ˆX.
2. X â‰ˆY if and only if Y â‰ˆX.
3. X â‰ˆY and Y â‰ˆZ imply X â‰ˆZ.
Proof. Straightforward.
Because of the preceding lemma, we can associate to any set X an object
card(X), the cardinality or cardinal number of X, in such a way that
X â‰ˆY
â‡”
card(X) = card(Y ) .
If X is ï¬nite, we take card(X) to be the number of elements in X. For inï¬nite
sets X, it is not important at this stage what sort of object the cardinal number
card(X) is, so long as the above property holds. We use Greek letters Îº, Î», Âµ,
Î½, . . . to denote cardinal numbers.
Deï¬nition 4.2.3. We write X â‰¼Y to mean that X â‰ˆX1 for some X1 âŠ†Y .
Lemma 4.2.4.
1. If X â‰ˆXâ€² and Y â‰ˆY â€², then X â‰¼Y if and only if Xâ€² â‰¼Y â€².
2. X â‰¼X.
3. X â‰¼Y and Y â‰¼Z imply X â‰¼Z.
4. X â‰¼Y and Y â‰¼X imply X â‰ˆY .
5. For all sets X and Y , either X â‰¼Y or Y â‰¼X.
Proof. Parts 1, 2, and 3 are straightforward.
Parts 4 and 5 will be proved
later, as consequences of the Well-Ordering Theorem. Part 4 is known as the
Cantor-Schroeder-Bernstein Theorem.
We can now make the following deï¬nition for cardinal numbers: Îº â‰¤Î» if and
only if X â‰¼Y where Îº = card(X) and Î» = card(Y ). This does not depend on
the choice of X and Y , as noted in part 1 of Lemma 4.2.4. The rest of Lemma
4.2.4 implies that â‰¤is a linear ordering of the cardinal numbers, i.e., we have:
1. Îº â‰¤Îº.
2. (Îº â‰¤Î» âˆ§Î» â‰¤Âµ) â‡’Îº â‰¤Âµ.
3. (Îº â‰¤Î» âˆ§Î» â‰¤Îº) â‡’Îº = Î».
72

4. âˆ€Îº âˆ€Î» (Îº â‰¤Î» âˆ¨Î» â‰¤Îº).
Deï¬nition 4.2.5 (Cardinal Arithmetic). For cardinal numbers Îº = card(X)
and Î» = card(Y ), we deï¬ne
1. Îº + Î» = card(X âˆªY ).
2. Îº Â· Î» = card(X Ã— Y ).
3. ÎºÎ» = card(XY ).
(In the deï¬nition of Îº + Î», it is assumed that X âˆ©Y = âˆ….)
For example, 2Îº = card(P(X)) where Îº = card(X).
Theorem 4.2.6. For cardinal numbers Îº, Î», and Âµ, we have
1. Îº + Î» = Î» + Îº.
2. (Îº + Î») + Âµ = Îº + (Î» + Âµ).
3. Îº Â· Î» = Î» Â· Îº.
4. (Îº Â· Î») Â· Âµ = Îº Â· (Î» Â· Âµ).
5. Îº Â· (Î» + Âµ) = Îº Â· Î» + Îº Â· Âµ.
6. ÎºÎ»+Âµ = ÎºÎ» Â· ÎºÂµ.
7. ÎºÎ»Â·Âµ = (ÎºÎ»)Âµ.
8. Îº + 0 = Îº, Îº Â· 0 = 0, Îº Â· 1 = Îº.
Proof. Straightforward.
Later we shall prove that, for inï¬nite cardinal numbers Îº and Î»,
Îº + Î»
=
Îº Â· Î»
=
max(Îº, Î») .
Theorem 4.2.7 (Cantorâ€™s Theorem). For any cardinal number Îº, we have
2Îº > Îº. In other words, for any set X, we have X â‰¼P(X) and P(X) Ì¸â‰¼X.
Proof. We have X â‰¼P(X) via the one-to-one function f : X â†’P(X) where
f(a) = {a}.
Suppose now that P(X) â‰¼X holds.
Let g : P(X) â†’X be
one-to-one. Put
D = {a âˆˆX | a âˆˆrng(g) âˆ§a /âˆˆgâˆ’1(a)} .
Then g(D) âˆˆD if and only if g(D) /âˆˆD, a contradiction.
73

Exercise 4.2.8. Deï¬ne â„µ0 = card(N). Without using the Cantor-Schroeder-
Bernstein Theorem, prove that
â„µ0 = card(Z) = card(Q)
and
2â„µ0 = card(R) = card(C) = card([0, 1]) = card([0, 1] Ã— [0, 1]).
Deï¬nition 4.2.9. If âŸ¨ÎºiâŸ©iâˆˆI is an indexed set of cardinal numbers, we deï¬ne
1. P
iâˆˆI Îºi = card(S
iâˆˆI Xi)
2. Q
iâˆˆI Îºi = card(Q
iâˆˆI Xi)
where Îºi = card(Xi). In the deï¬nition of P
iâˆˆI Îºi, it is assumed that Xiâˆ©Xj = âˆ…
for all i, j âˆˆI with i Ì¸= j.
Exercise 4.2.10 (KÂ¨onigâ€™s Theorem). Suppose that âŸ¨ÎºiâŸ©iâˆˆI and âŸ¨Î»iâŸ©iâˆˆI are in-
dexed sets of cardinal numbers with the same index set I. Show that if Îºi < Î»i
for all i âˆˆI, then
X
iâˆˆI
Îºi <
Y
iâˆˆI
Î»i .
Remark 4.2.11. Cantorâ€™s Theorem may be viewed as the special case of
KÂ¨onigâ€™s Theorem with Îºi = 1 and Î»i = 2.
The Axiom of Choice may be
viewed as the special case of KÂ¨onigâ€™s Theorem with Îºi = 0 and Î»i > 0.
4.3
Well-Orderings and Ordinal Numbers
Deï¬nition 4.3.1. Given a set A, a relation on A is a set R âŠ†A Ã— A.
A
relational structure is an ordered pair (A, R) where A is a set and R âŠ†A Ã— A.
We sometimes write aRaâ€² instead of (a, aâ€²) âˆˆR.
Deï¬nition 4.3.2. Given two relational structures (A, R) and (B, S), an isomor-
phism from (A, R) to (B, S) is a one-to-one function f such that dom(f) = A,
rng(f) = B, and
aRaâ€²
â‡”
f(a)Sf(aâ€²)
for all a, aâ€² âˆˆA.
We say that (A, R) is isomorphic to (B, S), symbolically
(A, R) âˆ¼= (B, S), if there exists an isomorphism from (A, R) to (B, S).
Lemma 4.3.3.
1. (A, R) âˆ¼= (A, R).
2. (A, R) âˆ¼= (B, S) if and only if (B, S) âˆ¼= (A, R).
3. (A, R) âˆ¼= (B, S) and (B, S) âˆ¼= (C, T ) imply (A, R) âˆ¼= (C, T ).
74

Proof. Straightforward.
Because of the preceding lemma, we can associate to any relational structure
(A, R) a mathematical object type(A, R), the isomorphism type of (A, R), in
such a way that
(A, R) âˆ¼= (B, S)
â‡”
type(A, R) = type(B, S) .
It is not important at this stage exactly what sort of mathematical object
type(A, R) is, so long as the above property holds.
Deï¬nition 4.3.4. A relational structure (A, R) is said to be well-founded if for
every nonempty set X âŠ†A, there exists a âˆˆX such that there is no b âˆˆX with
bRa. Such an a might be called an R-minimal element of X.
Lemma 4.3.5. A relational structure (A, R) is well-founded if and only if there
is no inï¬nite descending R-sequence. (By an inï¬nite descending R-sequence we
mean a sequence âŸ¨anâŸ©nâˆˆN such that an+1Ran for all n âˆˆN.)
Proof. If âŸ¨anâŸ©nâˆˆN is an inï¬nite descending R-sequence, then X = {an | n âˆˆN}
is a counterexample to well-foundedness of (A, R). Conversely, suppose that
X âŠ†A is a counterexample to well-foundedness. Then we have X Ì¸= âˆ…and
âˆ€a âˆˆX âˆƒb âˆˆX bRa. By the Axiom of Choice, there is a function f : X â†’X
such that f(a)Ra for all a âˆˆX. Pick an element a0 âˆˆX and deï¬ne âŸ¨anâŸ©nâˆˆN
recursively by putting an+1 = f(an) for all n âˆˆN. This is an inï¬nite descending
R-sequence. The lemma is proved.
Deï¬nition 4.3.6. A linear ordering is a relational structure (A, R) with the
following properties: aRb and bRc imply aRc; and for all a, b âˆˆA exactly one of
aRb, a = b, bRa hold. A well-ordering is a linear ordering which is well-founded.
Note that if (A, R) is a well-ordering and X is a nonempty subset of A, then
X has an R-least element, i.e., there is a unique a âˆˆX such that aRb holds for
all b âˆˆX, b Ì¸= a.
Deï¬nition 4.3.7. An ordinal number is the isomorphism type of a well-ordering.
For n âˆˆN, we identify n with the ordinal number which is the order type of
all n-element well-orderings. Another important ordinal number is Ï‰, the order
type of N itself (more precisely of (N, <) = (N, {(m, n) âˆˆN Ã— N | m < n})).
The following deï¬nition and exercise show how to generate further examples of
ordinal numbers.
Deï¬nition 4.3.8. Let Î± = type(A, R) and Î² = type(B, S) be ordinal numbers.
We deï¬ne
1. Î± + Î² = type(A âˆªB, R âˆªS âˆª(A Ã— B)). Here we assume that A âˆ©B = âˆ….
2. Î± Â· Î² = type(A Ã— B, {((a, b), (aâ€², bâ€²)) | bSbâ€² âˆ¨(b = bâ€² âˆ§aRaâ€²)}).
75

Thus we have operations of ordinal addition, Î± + Î², and ordinal multiplication,
Î± Â· Î². (Later we shall deï¬ne an analogous operation of ordinal exponentiation,
Î±Î².) Note that the commutative laws fail, for example 1 + Ï‰ = Ï‰ Ì¸= Ï‰ + 1 and
2 Â· Ï‰ = Ï‰ Ì¸= Ï‰ Â· 2 = Ï‰ + Ï‰. However, we have the following properties.
Exercise 4.3.9. Prove the following laws of ordinal arithmetic.
1. (Î± + Î²) + Î³ = Î± + (Î² + Î³).
2. (Î± Â· Î²) Â· Î³ = Î± Â· (Î² Â· Î³).
3. Î± Â· (Î² + Î³) = Î± Â· Î² + Î± Â· Î³.
4. Î± + 0 = 0 + Î± = Î±, Î± Â· 0 = 0 Â· Î± = 0, Î± Â· 1 = 1 Â· Î± = Î±.
Give an example showing the failure of (Î± + Î²) Â· Î³ = Î± Â· Î³ + Î² Â· Î³.
Deï¬nition 4.3.10. If (A, R) is a linear ordering, an initial segment of (A, R)
is any subset of A of the form {b | bRa}, where a âˆˆA. Note that
({b | bRa}, {(c, b) | cRb âˆ§bRa})
is again a linear ordering, and we sometimes identify the initial segment with
this ordering.
Theorem 4.3.11 (Comparability of Well-Orderings). Let (A, R) and (B, S) be
well-orderings. Then exactly one of the following holds.
1. (A, R) âˆ¼= (B, S);
2. (A, R) âˆ¼= some initial segment of (B, S);
3. (B, S) âˆ¼= some initial segment of (A, R).
Moreover, in each case, the isomorphism is unique.
Proof. We ï¬rst prove that the isomorphism is unique. Suppose for instance that
f1 and f2 are two diï¬€erent isomorphisms from (A, R) to (B, S) or to some initial
segment of (B, S). Then {a âˆˆA | f1(a) Ì¸= f2(a)} is a nonempty subset of A, so
let a be its R-least element. Then f1(aâ€²) = f2(aâ€²) for all aâ€²Ra but f1(a) Ì¸= f2(a),
say f1(a)Sf2(a). Then f1(a) /âˆˆrng(f2), contradicting the fact that rng(f2) is B
or an initial segment of B with respect to S.
Now let f be a function with dom(f) âŠ†A and rng(f) âŠ†B, deï¬ned by
putting f(a) = the unique b âˆˆB such that
({aâ€² | aâ€²Ra}, {(aâ€²â€², aâ€²) | aâ€²â€²Raâ€² âˆ§aâ€²Ra}) âˆ¼= ({bâ€² | bâ€²Sb}, {(bâ€²â€², bâ€²) | bâ€²â€²Sbâ€² âˆ§bâ€²Sb}) ,
provided such a b exists. If for a given a âˆˆA no such b exists, f(a) is undeï¬ned.
If b exists, its uniqueness follows from what we have already proved. It is clear
that aâ€²Ra and a âˆˆdom(f) imply aâ€² âˆˆdom(f), and bâ€²Rb and b âˆˆrng(f) imply
bâ€² âˆˆrng(f).
76

We claim that dom(f) = A or rng(f) = B or both. If not, let a be the
R-least element of A \ dom(f), and let b be the S-least element of B \ rng(f).
Then f is an isomorphism from ({aâ€² | aâ€²Ra}, {(aâ€²â€², aâ€²) | aâ€²â€²Raâ€² âˆ§aâ€²Ra}) to ({bâ€² |
bâ€²Sb}, {(bâ€²â€², bâ€²) | bâ€²â€²Sbâ€² âˆ§bâ€²Sb}). This implies that a âˆˆdom(f), a contradiction.
The claim is proved.
If both dom(f) = A and rng(f) = B, then we have (A, R) âˆ¼= (B, S). If
dom(f) Ì¸= A, then letting a be the R-least element of A \ dom(f), we see that
f is an isomorphism from ({aâ€² | aâ€²Ra}, {(aâ€²â€², aâ€²) | aâ€²â€²Raâ€² âˆ§aâ€²Ra}) to (B, S). If
rng(f) Ì¸= B, then letting b be the S-least element of B \ rng(f), we see that
f is an isomorphism from (A, R) to ({bâ€² | bâ€²Sb}, {(bâ€²â€², bâ€²) | bâ€²â€²Sbâ€² âˆ§bâ€²Sb}). This
completes the proof of the theorem.
Deï¬nition 4.3.12. For ordinal numbers Î± and Î², we deï¬ne Î± < Î² to mean
that (A, R) âˆ¼= some initial segment of (B, S), where Î± = type(A, R) and Î² =
type(B, S). We deï¬ne Î± â‰¤Î² to mean Î± < Î² âˆ¨Î± = Î².
Lemma 4.3.13. For all ordinal numbers Î± and Î², exactly one of Î± < Î², Î± = Î²,
and Î² < Î± holds. Moreover Î± < Î² and Î² < Î³ imply Î± < Î³.
Proof. The ï¬rst part follows from comparability of well-orderings. The second
part is straightforward.
Exercise 4.3.14. For ordinal numbers Î±, Î², Î³, prove that Î± < Î² if and only if
Î± + Î³ = Î² for some Î³ > 0.
Lemma 4.3.15. If (A, R) is a well-ordering and B âŠ†A, then (B, R âˆ©(B Ã— B))
is a well-ordering, and
type(B, R âˆ©(B Ã— B)) â‰¤type(A, R) .
Proof. Straightforward, using comparability of well-orderings.
The next theorem implies that any well-ordering is isomorphic to an initial
segment of the ordinal numbers.
Theorem 4.3.16. For any ordinal number Î±, the relational structure
({Î² | Î² < Î±}, {(Î³, Î²) | Î³ < Î² < Î±})
is a well-ordering of type Î±.
Proof. Let (A, R) be some ï¬xed well-ordering of type Î±. Deï¬ne f : A â†’{Î² |
Î² < Î±} by
f(b) = type({c âˆˆA | cRb}, {(d, c) | dRc âˆ§cRb}) .
It is straightforward to verify that f is an isomorphism from (A, R) onto
({Î² | Î² < Î±}, {(Î³, Î²) | Î³ < Î² < Î±}) .
This proves the theorem.
77

Corollary 4.3.17. For any ordinal number Î±, there is a set {Î² | Î² < Î±}
consisting of all smaller ordinal numbers.
Proof. This follows from the previous theorem.
Lemma 4.3.18. Let X be a set of ordinal numbers. Then there is an ordinal
number Î³ = sup X which is the least upper bound of X under <, i.e., âˆ€Î± (Î± âˆˆ
X â‡’Î± â‰¤Î³) and âˆ€Î² (Î² < Î³ â‡’âˆƒÎ± (Î± âˆˆX âˆ§Î² < Î±)).
Proof. Put
A = {Î± | âˆƒÎ² (Î² âˆˆX âˆ§Î± < Î²)} =
[
Î²âˆˆX
{Î± | Î± < Î²} .
It is straightforward to verify that
(A, {(Î±, Î²) âˆˆA Ã— A | Î± < Î²})
is a well-ordering. Let Î³ be the type of this well-ordering. It is straightforward
to verify that A = {Î± | Î± < Î³} and that Î³ = sup X.
Exercise 4.3.19. If Î± is an ordinal number and X is a nonempty set of ordinal
numbers, show that Î±+sup X = sup{Î±+Î² | Î² âˆˆX} and Î±Â·sup X = sup{Î±Â·Î² |
Î² âˆˆX}.
Lemma 4.3.20. Let X be a nonempty set of ordinal numbers. Then X has a
smallest element under <.
Proof. Put Î± = sup X. Then X is a nonempty subset of {Î² | Î² â‰¤Î±}. The latter
set of ordinal numbers is well-ordered under <, hence X has a least element.
Theorem 4.3.21 (Burali-Forti Paradox). The class Ord of all ordinal numbers
is not a set.
Proof. If Ord were a set, then by the above lemmas, (Ord, <) would be a well-
ordering. Letting Î± be the type of this well-ordering, we see that (Ord, <) would
be isomorphic to an initial segment of itself, namely ({Î² | Î² < Î±}, {(Î³, Î²) | Î³ <
Î² < Î±}). This contradiction completes the proof.
4.4
Transï¬nite Recursion
By a class we mean a collection of objects which is not necessarily a set. Every
set is a class, but not every class is a set. Examples of classes which are not sets
are Set = {X | X is a set} and Ord = {Î± | Î± is an ordinal}. These classes are
â€œtoo bigâ€ to be sets. We have seen this in connection with the Russell Paradox
and the Burali-Forti Paradox.
If C is a class, then by a function with domain C we mean a rule F which
associates to each element a of C a uniquely deï¬ned object F(a). For example,
although the class Ord of all ordinal numbers is not a set, we shall be interested
in functions with domain Ord. The next theorem gives us a powerful method
for deï¬ning such functions.
78

Theorem 4.4.1 (Transï¬nite Recursion). Let F be the class of all functions
whose domain is an initial segment of Ord. Suppose that G is a function with
domain F. Then there is a unique function F with domain Ord such that, for
all ordinal numbers Î±,
F(Î±) = G(Fâ†¾{Î² | Î² < Î±}) .
Proof. Let us say that f âˆˆF is good if for all Î² âˆˆdom(f), f(Î²) = G(fâ†¾{Î³ |
Î³ < Î²}). We claim that for all ordinal numbers Î±, there is at most one good f
with dom(f) = {Î² | Î² < Î±}. If not, let f1 Ì¸= f2 be two such fâ€™s. Let Î³ be the
smallest Î² < Î± such that f1(Î²) Ì¸= f2(Î²). Then f1â†¾{Î² | Î² < Î³} = f2â†¾{Î² | Î² < Î³},
hence
f1(Î³) = G(f1â†¾{Î² | Î² < Î³}) = G(f2â†¾{Î² | Î² < Î³}) = f2(Î³) ,
a contradiction.
Using the above claim, let fÎ± be the unique good f with dom(f) = {Î² |
Î² < Î±}, if it exists. We claim that fÎ± exists for all Î±. If not, let Î± be the
smallest counterexample. Then fÎ² exists for all Î² < Î±, and it is easy to check
that {(Î², G(fÎ²)) | Î² < Î±} is good. This contradicts the choice of Î±. Thus fÎ±
exists for all Î±. Deï¬ne F by putting F(Î±) = G(fÎ±) for all Î±. It is easy to check
that Fâ†¾{Î² | Î² < Î±} = fÎ± and that F satisï¬es the desired conclusions. This
completes the proof.
As an example of transï¬nite recursion, we deï¬ne the following operations of
ordinal arithmetic.
Deï¬nition 4.4.2.
1. Î± + Î² = sup{Î±, (Î± + Î³) + 1 | Î³ < Î²}.
2. Î± Â· Î² = sup{(Î± Â· Î³) + Î± | Î³ < Î²}.
3. Î±Î² = sup{1, Î±Î³ Â· Î± | Î³ < Î²} (assuming Î± > 0).
Exercise 4.4.3. Show that parts 1 and 2 of Deï¬nition 4.4.2 agree with parts 1
and 2 of Deï¬nition 4.3.8. In the next exercise we show how to extend Deï¬nition
4.3.8 to encompass part 3 of Deï¬nition 4.4.2.
Exercise 4.4.4. Let Î± = type(A, R) and Î² = type(B, S) be ordinal numbers.
Show that Î±Î² = type(C, T ) where C is the set of all f : B â†’A such that, for
all but ï¬nitely many b âˆˆB, f(b) = a0, where a0 is the R-least element of A.
Here T is the set of all (f1, f2) âˆˆC Ã— C such that f1(bâ€²)Rf2(bâ€²), where bâ€² is the
S-greatest b âˆˆB such that f1(b) Ì¸= f2(b).
Exercise 4.4.5. If Î± is an ordinal number and X is a nonempty set of ordinal
numbers, show that
1. Î± + sup X = sup{Î± + Î² | Î² âˆˆX},
79

2. Î± Â· sup X = sup{Î± Â· Î² | Î² âˆˆX}, and
3. Î±sup X = sup{Î±Î² | Î² âˆˆX}.
Exercise 4.4.6. For ordinal numbers Î±, Î², and Î³, show that
1. (Î± + Î²) + Î³ = Î± + (Î² + Î³).
2. (Î± Â· Î²) Â· Î³ = Î± Â· (Î² Â· Î³).
3. Î± Â· (Î² + Î³) = Î± Â· Î² + Î± Â· Î³.
4. Î±Î²+Î³ = Î±Î² Â· Î±Î³.
5. Î±Î²Â·Î³ = (Î±Î²)Î³.
6. Î± + 0 = 0 + Î± = Î±, Î± Â· 0 = 0 Â· Î± = 0, Î± Â· 1 = 1 Â· Î± = Î±.
7. Î±0 = 1.
8. 0Î± = 0 provided Î± > 0.
9. Î±1 = Î±, 1Î± = 1.
Exercise 4.4.7. Show that Î² < Î³ implies the following:
1. Î± + Î² < Î± + Î³;
2. Î± Â· Î² < Î± Â· Î³ provided Î± > 0;
3. Î±Î² < Î±Î³ provided Î± > 1.
Deï¬nition 4.4.8. A successor ordinal is an ordinal number of the form Î± + 1.
A limit ordinal is an ordinal number Î´ such that Î´ > 0 and Î± + 1 < Î´ for all
Î± < Î´. Examples of limit ordinals are Ï‰ and Ï‰ Â· 2.
Exercise 4.4.9. Show that Î± + 1 is the smallest ordinal number Î² > Î±. Show
that every ordinal number is either 0, a successor ordinal, or a limit ordinal.
Show that Î´ > 0 is a limit ordinal if and only if Î´ = sup{Î± | Î± < Î´}. Show that
Î´ > 0 is a limit ordinal if and only if Î´ = Ï‰ Â· Î± for some Î± > 0.
Exercise 4.4.10. Show that the operations of ordinal arithmetic could have
been deï¬ned by transï¬nite recursion as follows (letting Î´ denote a limit ordinal):
1. Î± + 0 = Î±, Î± + (Î² + 1) = (Î± + Î²) + 1, Î± + Î´ = sup{Î± + Î² | Î² < Î´}.
2. Î± Â· 0 = 0, Î± Â· (Î² + 1) = (Î± Â· Î²) + Î±, Î± Â· Î´ = sup{Î± Â· Î² | Î² < Î´}.
3. Î±0 = 1, Î±Î²+1 = (Î±Î²) Â· Î±, Î±Î´ = sup{Î±Î² | Î² < Î´} (assuming Î± > 0).
Exercise 4.4.11. For an ordinal number Î´ > 0, show that the following are
equivalent.
1. Î± + Î´ = Î´ for all Î± < Î´.
80

2. Î± + Î² < Î´ for all Î±, Î² < Î´.
3. Î´ = Ï‰Î± for some Î± â‰¤Î´.
An ordinal number with these properties is said to be additively indecomposable.
Exercise 4.4.12. Show that for any ordinal number Î±, there is one and only
one way to write Î± in the form Î± = Î±1 + Â· Â· Â· + Î±n where Î±1 â‰¥Â· Â· Â· â‰¥Î±n > 0 are
additively indecomposable, and n âˆˆN.
4.5
Cardinal Numbers, Continued
Lemma 4.5.1. Given a set X, there exists a choice function for X, i.e., a
function
c : P(X) \ {âˆ…} â†’X
such that c(Y ) âˆˆY for all Y âŠ†X, Y Ì¸= âˆ….
Proof. Consider the indexed set of sets âŸ¨XiâŸ©iâˆˆI, where I = P(X) \ {âˆ…} and
Xi = i for all i âˆˆI. By the Axiom of Choice, Q
iâˆˆI Xi is nonempty, i.e., there
exists âŸ¨aiâŸ©iâˆˆI such that ai âˆˆXi for all i âˆˆI. Putting c(i) = ai we obtain our
choice function.
Theorem 4.5.2 (Well-Ordering Theorem). Given a set X, we can ï¬nd a rela-
tion R âŠ†X Ã— X such that (X, R) is a well-ordering.
Proof. We shall prove the theorem in the following equivalent formulation: For
any set X, there exists an ordinal number Î± such that X â‰ˆ{Î² | Î² < Î±}.
(Neither Î± nor the one-to-one function from X onto {Î² | Î² < Î±} is asserted to
be unique.)
Fix a choice function c for X.
Fix an object a0 such that a0 /âˆˆX. By
transï¬nite recursion, deï¬ne
F(Î±) =
( c(X \ rng(Fâ†¾{Î² | Î² < Î±})),
if X \ rng(Fâ†¾{Î² | Î² < Î±}) Ì¸= âˆ…
a0
otherwise.
We claim that F(Î±) = a0 for some Î±. If not, we would have F(Î±) âˆˆX for
all Î±, and F(Î±) Ì¸= F(Î²) for all Î± Ì¸= Î². Form the set
Y = rng(F) = {a âˆˆX | âˆƒÎ±(F(Î±) = a)} .
Then F âˆ’1 is a function with domain Y , and we have rng(F âˆ’1) = Ord, hence
Ord is a set. This contradiction proves the claim.
Let Î± be the smallest ordinal number such that F(Î±) = a0. Then Fâ†¾{Î² |
Î² < Î±} is one-to-one, and rng(Fâ†¾{Î² | Î² < Î±}) = X. Thus {Î² | Î² < Î±} â‰ˆX.
Our theorem is proved.
81

Remark 4.5.3. The previous theorem shows that the Axiom of Choice implies
the Well-Ordering Theorem. There is also a converse: the Well-Ordering Theo-
rem implies the Axiom of Choice. To see this, suppose we have an indexed set
of nonempty sets âŸ¨XiâŸ©iâˆˆI. Put A = S
iâˆˆI Xi. By the Well-Ordering Theorem,
there exists R âŠ†A Ã— A such that (A, R) is a well-ordering. Deï¬ne âŸ¨aiâŸ©iâˆˆI by
putting ai = the R-least element of Xi. Thus âŸ¨aiâŸ©iâˆˆI âˆˆQ
iâˆˆI Xi and we have
proved the Axiom of Choice from the Well-Ordering theorem.
Exercise 4.5.4. Let X be a set of sets. By a chain within X we mean a set
C âŠ†X such that for all U, V âˆˆC either U âŠ†V or V âŠ†U. A chain within X is
said to be maximal if it is not properly included in any other chain within X.
Use the Axiom of Choice plus transï¬nite recursion to prove that there exists
a maximal chain within X.
Note: This is a version of Zornâ€™s Lemma.
Deï¬nition 4.5.5. An initial ordinal is an ordinal number Î± such that, for all
Î² < Î±,
{Î³ | Î³ < Î±} Ì¸â‰ˆ{Î³ | Î³ < Î²} .
The ï¬nite ordinal numbers 0, 1, 2, . . .
are initial ordinals, as is the ï¬rst
inï¬nite ordinal number Ï‰. But it is easy to see that ordinal numbers such as
Ï‰ + 1, Ï‰ + 2, . . . , Ï‰ Â· 2, Ï‰ Â· 2 + 1, . . . are not initial ordinals. Another simple
fact worth noting is that every inï¬nite initial ordinal is a limit ordinal.
Deï¬nition 4.5.6. For any set X, we deï¬ne |X| to be the smallest ordinal
number Î± such that X â‰ˆ{Î² | Î² < Î±}. (The existence of such an ordinal is a
consequence of the Well-Ordering Theorem.) Clearly |X| is an initial ordinal.
In fact, |X| is the unique initial ordinal such that X â‰ˆ{Î² | Î² < Î±}.
Lemma 4.5.7. If X âŠ†{Î² | Î² < Î±}, then |X| â‰¤Î±.
Proof. Immediate from Lemma 4.3.15.
Theorem 4.5.8. For all sets X and Y we have
X â‰ˆY
if and only if |X| = |Y | ,
and
X â‰¼Y
if and only if |X| â‰¤|Y | .
Proof. The ï¬rst equivalence is obvious, as is the fact that |X| â‰¤|Y | implies
X â‰¼Y . Suppose now that X â‰¼Y . Then X â‰ˆZ for some Z âŠ†{Î² | Î² < |Y |}.
By the previous lemma it follows that |X| = |Z| â‰¤|Y |. This completes the
proof.
Remark 4.5.9. By the previous theorem, we have card(X) = card(Y ) if and
only if |X| = |Y |, and card(X) < card(Y ) if and only if |X| < |Y |. Thus we may
identify cardinal numbers with initial ordinals.
From now on we shall make
this identiï¬cation, writing card(X) = |X|.
For instance, the ï¬nite cardinal
numbers are now identiï¬ed with the ï¬nite ordinal numbers, and the smallest
inï¬nite cardinal number is the same as the ordinal number Ï‰.
82

Theorem 4.5.10.
1. If X â‰¼Y and Y â‰¼X, then X â‰ˆY .
2. For all sets X and Y , either X â‰¼Y or Y â‰¼X.
Proof. Both parts follow from the previous theorem plus the fact that |X| and
|Y | are ordinal numbers, hence exactly one of |X| < |Y |, |X| = |Y |, |Y | < |X|
holds.
4.6
Cardinal Arithmetic
We now present some basic results about the arithmetic of inï¬nite cardinal
numbers. Most of these results are easy consequences of the following lemma.
Lemma 4.6.1. For inï¬nite cardinals Îº, we have Îº Â· Îº = Îº.
Proof. If not, let Îº be the smallest counterexample. Note that Îº is an inï¬nite
initial ordinal, and Î» Â· Î» < Îº for all Î» < Îº.
Put A = {Î± | Î± < Îº} and R = {(Î±â€², Î±) | Î±â€² < Î± < Îº}. Thus (A, R) is a
well-ordering of type Îº. Note that |A| = Îº but every initial segment I of (A, R)
has |I| < Îº.
Put B = A Ã— A and deï¬ne S âŠ†B Ã— B by
(Î±â€², Î²â€²)S(Î±, Î²)
if and only if
max(Î±â€², Î²â€²) < max(Î±, Î²) âˆ¨
(max(Î±â€², Î²â€²) = max(Î±, Î²) âˆ§Î±â€² < Î±) âˆ¨
(max(Î±â€², Î²â€²) = max(Î±, Î²) âˆ§Î±â€² = Î± âˆ§Î²â€² < Î²) .
It is straightforward to verify that (B, S) is a well-ordering.
If J âŠ†B is any initial segment of (B, S), we have J âŠ†I Ã— I where I is
an appropriately chosen initial segment of (A, R). Thus every initial segment
of (B, S) has cardinality < Îº. Hence (A, R) cannot be isomorphic to an initial
segment of (B, S). From comparability of well-orderings, it follows that (B, S)
is isomorphic to (A, R). In particular B â‰ˆA. In other words, AÃ—A â‰ˆA, hence
Îº Â· Îº = Îº. This completes the proof.
Theorem 4.6.2. For inï¬nite cardinals Îº and Î», we have
Îº + Î» = Îº Â· Î» = max(Îº, Î») .
Proof. Put Âµ = max(Îº, Î»). Then by the previous lemma we have
Âµ â‰¤Îº + Î» â‰¤Âµ + Âµ = 2 Â· Âµ â‰¤Âµ Â· Âµ = Âµ
and
Âµ â‰¤Îº Â· Î» â‰¤Âµ Â· Âµ = Âµ .
This proves the theorem.
83

Theorem 4.6.3. For Î» inï¬nite and 2 â‰¤Îº â‰¤2Î», we have ÎºÎ» = 2Î».
Proof. 2Î» â‰¤ÎºÎ» â‰¤(2Î»)Î» = 2Î»Â·Î» = 2Î».
For any set X, let Xâˆ—be the set of ï¬nite sequences of elements of X, i.e.,
Xâˆ—= {âŸ¨aiâŸ©i<n | n < Ï‰, ai âˆˆX for all i < n} .
Theorem 4.6.4. For any inï¬nite set X, we have |Xâˆ—| = |X|.
Proof. Putting Îº = |X|, we have Îº2 = Îº Â· Îº = Îº and it is easy to prove by
induction on n that Îºn = Îº for all n â‰¥1, n < Ï‰. Hence we have
|Xâˆ—| =
X
n<Ï‰
Îºn = Ï‰ Â· Îº = Îº .
This proves the theorem.
Deï¬nition 4.6.5. For any ordinal Î² we deï¬ne Î²+ = the smallest initial ordinal
Îº > Î². To each ordinal number Î± we associate an inï¬nite initial ordinal Ï‰Î± as
follows, by transï¬nite recursion:
1. Ï‰0 = Ï‰,
2. Ï‰Î±+1 = Ï‰+
Î± ,
3. Ï‰Î´ = supÎ±<Î´ Ï‰Î± for limit ordinals Î´.
Remark 4.6.6. It is easy to see that âŸ¨Ï‰Î±âŸ©Î±âˆˆOrd is a strictly increasing enumer-
ation of all the inï¬nite initial ordinals, i.e., the inï¬nite cardinals. It follows that
the class Card = {Îº | Îº is an inï¬nite cardinal} is not a set.
Exercise 4.6.7. Prove that there exist arbitrarily large ordinals Î± such that
Î± = Ï‰Î±.
Remark 4.6.8. Although cardinals are now the same thing as initial ordinals,
the notation â„µÎ± = Ï‰Î± is sometimes used in order to maintain a notational
distinction between cardinals and initial ordinals. â„µÎ± is taken to be a cardinal,
while Ï‰Î± is an initial ordinal. For example, even though â„µ0 is the same thing
as Ï‰, â„µ0 is thought of as the cardinality of the set of natural numbers, while Ï‰
is thought of as the order type of the natural numbers under <.
Theorem 4.6.9. Let N, Q, and R be the set of natural numbers, the rational
numbers, and the real numbers respectively. The cardinalities of these sets are
given by |N| = |Q| = â„µ0, |R| = 2â„µ0.
Proof. The fact that |N| = â„µ0 is obvious. Since N âŠ†Q and each rational number
q âˆˆQ is of the form q = Â±m/n for some (m, n) âˆˆN Ã— N, we have
|N| â‰¤|Q| â‰¤2 Â· |N| Â· |N| = |N|
so |Q| = |N| = â„µ0. For the real numbers, note ï¬rst that P(N) â‰¼R via the
function which sends X âŠ†N to P
nâˆˆX 2/3n. Hence 2â„µ0 â‰¤|R|. On the other
hand, R â‰¼P(Q) â‰ˆP(N) via the function which sends x âˆˆR to {q âˆˆQ | q < x}.
Thus |R| = 2â„µ0.
84

Exercise 4.6.10. Prove that |RN| = 2â„µ0 and |RR| = 22â„µ0 .
The most important problem of inï¬nite cardinal arithmetic is the Continuum
Problem: What is the cardinality of R? Equivalently, what is the ordinal number
Î² such that 2â„µ0 = â„µÎ²? By Cantorâ€™s Theorem we have 2â„µ0 â‰¥â„µ1. The assertion
that 2â„µ0 = â„µ1 is known as the Continuum Hypothesis, or CH.
More generally, for any inï¬nite cardinal Îº, Cantorâ€™s Theorem tells us that
2Îº â‰¥Îº+, and we can ask whether 2Îº = Îº+. The assertion that 2Îº = Îº+ for
all inï¬nite cardinals Îº (equivalently, 2â„µÎ± = â„µÎ±+1 for all ordinal numbers Î±) is
known as the Generalized Continuum Hypothesis, or GCH.
Exercise 4.6.11. Prove that 2â„µ0 Ì¸= â„µÏ‰. (Hint: Use KÂ¨onigâ€™s Theorem.)
4.7
Some Classes of Cardinals
A cardinal is said to be uncountable if it is > â„µ0. In this section we introduce
some important classes of uncountable cardinals.
Deï¬nition 4.7.1. Let Î» be an uncountable cardinal. We say that Î» is a suc-
cessor cardinal if Î» = Îº+ for some Îº < Î». We say that Î» is a limit cardinal if
Îº+ < Î» for all Îº < Î». We say that Î» is a strong limit cardinal if 2Îº < Î» for all
Îº < Î».
Note that Î» is a successor cardinal if and only if Î» = â„µÎ±+1 for some successor
ordinal Î± + 1, and Î» is a limit cardinal if and only if Î» = â„µÎ´ for some limit
ordinal Î´. The ï¬rst few uncountable successor cardinals are â„µ1, â„µ2, . . . . The
ï¬rst uncountable limit cardinal is â„µÏ‰. Clearly every strong limit cardinal is a
limit cardinal, and the GCH implies that every limit cardinal is a strong limit
cardinal.
Lemma 4.7.2. Every uncountable cardinal is either a successor cardinal or a
limit cardinal, and exactly one of these possibilities holds.
Proof. Obvious.
Deï¬nition 4.7.3. An inï¬nite cardinal Î» is said to be regular if it is not the sum
of fewer than Î» cardinals each less than Î». In other words, for any indexed set
of cardinals âŸ¨ÎºiâŸ©iâˆˆI with |I| < Î» and Îºi < Î» for all i âˆˆI, we have P
iâˆˆI Îºi < Î».
Trivially â„µ0 is regular, since it is not the sum of a ï¬nite set of ï¬nite cardinals.
Theorem 4.7.4. Every uncountable successor cardinal is regular.
Proof. Let Î» be an uncountable successor cardinal. Thus Î» = Îº+ where Îº is an
inï¬nite cardinal. Given an indexed set of cardinals âŸ¨ÎºiâŸ©iâˆˆI, we see that Îºi < Î»
implies Îºi â‰¤Îº, also |I| < Î» implies |I| â‰¤Îº, hence
X
iâˆˆI
Îºi â‰¤
X
iâˆˆI
Îº = |I| Â· Îº â‰¤Îº Â· Îº = Îº < Î».
This shows that Î» is regular.
85

In particular â„µ1, â„µ2, . . . are regular. An inï¬nite cardinal is said to be sin-
gular if it is not regular. The ï¬rst singular cardinal is â„µÏ‰, since â„µÏ‰ = P
nâˆˆN â„µn.
Exercise 4.7.5. Let Î± be an ordinal number which is > Ï‰. Show that Î± is
a regular cardinal (i.e., a regular initial ordinal) if and only if, for every set of
ordinal numbers X with sup X = Î±, we have type(X) = Î±.
Deï¬nition 4.7.6. Let Î» be an uncountable cardinal.
The coï¬nality of Î»,
written cf(Î»), is the smallest cardinal Îº such that Î» = P
iâˆˆI Î»i for some indexed
set of cardinals Î»i < Î», i âˆˆI, with |I| = Îº.
Exercise 4.7.7. Prove the following facts.
1. cf(Î») is regular.
2. Î» is regular if and only if cf(Î») = Î».
3. Î» is singular if and only if cf(Î») < Î».
4. Î»cf(Î») > Î». (Hint: Use KÂ¨onigâ€™s Theorem.)
5. For any inï¬nite cardinal Îº we have cf(ÂµÎº) > Îº for all Âµ > 1. In particular,
cf(2Îº) > Îº.
Exercise 4.7.8. Let Îº be an inï¬nite regular cardinal. Show that there exist
arbitrarily large strong limit cardinals Î» such that cf(Î») = Îº. Moreover, for all
such Î» we have Î»Âµ = Î» for all Âµ < Îº.
Exercise 4.7.9. Assuming the GCH, prove that for all inï¬nite cardinals Îº and
Î» we have
Î»Îº =
ï£±
ï£´
ï£´
ï£²
ï£´
ï£´
ï£³
Î»
if Îº < cf(Î»),
Î»+
if cf(Î») â‰¤Îº â‰¤Î»,
Îº+
if Îº â‰¥Î».
Deï¬nition 4.7.10. An inaccessible cardinal is an uncountable, regular, strong
limit cardinal. A weakly inaccessible cardinal is an uncountable, regular, limit
cardinal.
Remark 4.7.11. Clearly every inaccessible cardinal is weakly inaccessible, and
the GCH implies that every weakly inaccessible cardinal is inaccessible. It can
be shown that every weakly inaccessible cardinal is a ï¬xed point of the â„µÎ±â€™s, i.e.,
such cardinals are of the form Î» = â„µÎ». Moreover, every strongly inaccessible
cardinal has Î»Îº = Î» for all Îº < Î».
The existence of inaccessible and/or weakly inaccessible cardinals is not ob-
vious. Indeed, we shall see later that the existence of such cardinals cannot be
established using the accepted axioms of set theory.
86

4.8
Pure Well-Founded Sets
A set X is said to be transitive if, for every set Y such that Y âˆˆX, we have
Y âŠ†X.
Lemma 4.8.1. Given a set X, there is a smallest transitive set TC(X) including
X. (TC(X) is called the transitive closure of X.)
Proof. Deï¬ne U(X) = S{Y | Y âˆˆX, Y a set}. By recursion on n < Ï‰ deï¬ne
TC0(X)
=
X
TCn+1(X)
=
U(TCn(X)) .
Then TC(X) = S
nâˆˆN TCn(X) is easily seen to be the smallest transitive set Y
such that Y âŠ‡X.
For any set A, we write
âˆˆ|A = {(b, a) | a, b âˆˆA, a is a set, b âˆˆa} .
Deï¬nition 4.8.2. A set X is said to be well-founded if the relational structure
(TC(X), âˆˆ|TC(X)) is well-founded.
Applying Lemma 4.3.5 to the relational structure (TC(X), âˆˆ|TC(X)), we see
that X is well-founded if and only if there is no inï¬nite sequence of sets âŸ¨XnâŸ©nâˆˆN
with
X = X0 âˆ‹X1 âˆ‹Â· Â· Â· âˆ‹Xn âˆ‹Â· Â· Â· .
Deï¬nition 4.8.3. A set X is said to be pure if every element of TC(X) is a
set. In other words, X is a pure set if not only X but also all the elements of
X, elements of elements of X, . . . , are sets.
By transï¬nite recursion we deï¬ne transitive sets RÎ±, Î± âˆˆOrd, as follows:
R0
=
âˆ…
RÎ±+1
=
P(RÎ±)
RÎ´
=
S
Î±<Î´ RÎ± for limit ordinals Î´ .
By transï¬nite induction on Î± âˆˆOrd, it is clear that Î² < Î± implies RÎ² âˆˆRÎ±,
hence Î² â‰¤Î± implies RÎ² âŠ†RÎ±.
Theorem 4.8.4. X âˆˆS
Î±âˆˆOrd RÎ± if and only if X is a pure, well-founded set.
Proof. It is straightforward to prove by transï¬nite induction on Î± that all el-
ements of RÎ± are pure and well-founded. Conversely, suppose X is pure and
well-founded.
We claim that, for all Y âˆˆTC({X}), there exists an ordinal
number Î± such that Y âˆˆRÎ±. If not, let Y âˆˆTC({X}) be âˆˆ-minimal such that
no such Î± exists. For each Z âˆˆY , let f(Z) be the least ordinal number Î² such
that Z âˆˆRÎ². Put Î³ = supZâˆˆY f(Z). Then Y âŠ†RÎ³, hence Y âˆˆP(RÎ³) = RÎ³+1,
a contradiction. This proves the claim. In particular, X âˆˆRÎ± for some Î±. This
proves the theorem.
87

The class of all pure, well-founded sets is denoted V . Thus we have
V
=
[
Î±âˆˆOrd
RÎ± .
If X is a pure, well-founded set, we deï¬ne the rank of X to be the least ordinal
number Î± such that X âŠ†RÎ±. Then clearly
rank X = sup{rankY + 1 | Y âˆˆX} .
Moreover, for all ordinals Î± we have
RÎ± = {X | X is a pure well-founded set of rank < Î±} ,
and rank RÎ± = Î±.
Exercise 4.8.5. Assuming the GCH, prove that |RÏ‰+Î±| = â„µÎ± for all ordinals
Î±.
4.9
Set-Theoretic Foundations
In the next chapter we shall begin the study of axiomatic set theory. In ax-
iomatic studies of set theory, the set concept is usually restricted to pure,
well-founded sets.
This restriction tends to isolate set theory from the rest
of mathematics. Nevertheless, the restriction is partially justiï¬ed by the fact
that many or most mathematical objects can be reconstructed or redeï¬ned as
pure, well-founded sets.
For example, the natural numbers 0, 1, 2, . . . are not ordinarily regarded as
being sets, but within the universe of pure, well-founded sets, it is possible to
deï¬ne a structural replica of the natural numbers. Thus, from a certain per-
spective, natural numbers can be viewed as certain kinds of pure, well-founded
sets.
A similar remark applies to each of following mathematical concepts: natural
number, real number, ordinal number, cardinal number, ordered pair, function.
For each concept in this list, it is possible to identify mathematical objects of
the given type with certain pure, well-founded sets. The purpose of this section
is to show exactly how these identiï¬cations can be made. We begin with ordered
pairs and progress to functions, ordinal numbers, and real numbers.
Deï¬nition 4.9.1. For any two objects a and b, let us write
(a, b) = {{a}, {a, b}} .
Thus (a, b) is a set. Note that if a and b are pure, well-founded sets, then so is
(a, b).
Lemma 4.9.2. If (a, b) = (aâ€², bâ€²) then a = aâ€² and b = bâ€².
88

Proof. Putting X = (a, b), we see that a is the unique element of T
Y âˆˆX Y , and
b is the unique element of S
Y âˆˆX Y \ {a} if the latter is nonempty, otherwise
b = a. Thus a and b can be recovered from (a, b) by single-valued set-theoretic
operations. The lemma follows.
By the above lemma, we may view (a, b) as the ordered pair formed from a
and b. From now on we shall make this identiï¬cation, which is customary in
pure set theory.
In an earlier section of these notes, we deï¬ned a function with domain X
to be a rule associating to each a âˆˆX a unique b. In pure set theory, it is
customary to replace this deï¬nition by the following, which we shall use from
now on.
Deï¬nition 4.9.3. A function is a set of ordered pairs, f, which is single-valued,
i.e.,
âˆ€a âˆ€b âˆ€c (((a, b) âˆˆf âˆ§(a, c) âˆˆf) â‡’b = c) .
The domain of f is dom(f) = {a | âˆƒb ((a, b) âˆˆf)}. If f is a function and
a âˆˆdom(f) we write f(a) = the unique b such that (a, b) âˆˆf.
The pure set-theoretic reconstruction of the ordinal numbers, due to von
Neumann, is as follows:
Deï¬nition 4.9.4. A von Neumann ordinal is a transitive, pure, well-founded
set A such that (A, âˆˆ|A) is a well-ordering.
Note that if A is a von Neumann ordinal, then for each b âˆˆA, the initial segment
B = {a | a âˆˆb} is again a von Neumann ordinal.
Lemma 4.9.5. For each ordinal number Î±, there is a unique von Neumann
ordinal AÎ± such that type(AÎ±, âˆˆ|AÎ±) = Î±. Moreover, the rank of AÎ± is Î±.
Proof. By transï¬nite recursion we deï¬ne AÎ± = {AÎ² | Î² < Î±} for all ordinals Î±.
By transï¬nite induction on Î±, it is straightforward to verify that AÎ± is the unique
von Neumann ordinal such that type(AÎ±, âˆˆ|AÎ±) = Î±, and that rank(AÎ±) =
Î±.
Remark 4.9.6. It is customary in pure set theory to identify the ordinal number
Î± with the von Neumann ordinal AÎ±. From now on we shall make this identiï¬-
cation. Thus we have 0 = âˆ…= {}, 1 = {0} = {{}}, 2 = {0, 1} = {{}, {{}}}, . . . ,
Ï‰ = {0, 1, 2, . . .} = N. Moreover, for all ordinals Î± we have Î± = {Î² | Î² < Î±}
and Î± + 1 = Î± âˆª{Î±}. Also, if X is any set of ordinals, then
sup X =
[
X =
[
Î±âˆˆX
Î± .
As for cardinal numbers, we have already seen how cardinal numbers may be
identiï¬ed with certain ordinal numbers, namely, the initial ordinals. Thus, we
already know how to identify cardinal numbers with certain pure, well-founded
sets.
89

Finally, we turn to the set-theoretic construction of the real number sys-
tem. The construction emplys the usual factorization of a set by an equivalence
relation, as per the following deï¬nitions and remark.
Deï¬nition 4.9.7. Let A be a set. An equivalence relation on A is a binary
relation R âŠ†A Ã— A with the following properties: aRb and bRc imply aRc; aRb
implies bRa; and aRa for all a âˆˆA.
Deï¬nition 4.9.8. Let R be an equivalence relation on A. For any a âˆˆA we
write [a]R = {b âˆˆA | aRb}, the equivalence class of a with respect to R. We
write A/R = {[a]R | a âˆˆA}.
Remark 4.9.9. Let R be an equivalence relation on A. Then aRb if and only
if [a]R = [b]R. Moreover A/R is a partition of A, i.e., a collection of pairwise
disjoint sets whose union is A.
Deï¬nition 4.9.10 (the real number system). In order to deï¬ne the real num-
ber system, we follow Dedekind and begin with the natural number system
(N, +, Â·, 0, 1, =, <).
The integers are deï¬ned by putting Z = (N Ã— N)/â‰¡Z, where (m, n) â‰¡Z
(mâ€², nâ€²) if and only if m + nâ€² = mâ€² + n. The ordered ring structure of Z is given
by
[(m, n)] +Z [(mâ€², nâ€²)]
=
[(m + mâ€², n + nâ€²)]
[(m, n)] Â·Z [(mâ€², nâ€²)]
=
[(mmâ€² + nnâ€², mnâ€² + mâ€²n)]
âˆ’Z [(m, n)]
=
[(n, m)]
0Z
=
[(0, 0)]
1Z
=
[(1, 0)]
[(m, n)] = [(mâ€², nâ€²)]
â‡”
m + nâ€² = mâ€² + n
[(m, n)] <Z [(mâ€², nâ€²)]
â‡”
m + nâ€² < mâ€² + n
The rationals are deï¬ned by putting Q = (Z Ã— Z+)/â‰¡Q, where Z+ = {b âˆˆ
Z | b > 0}, and (a, b) â‰¡Q (aâ€², bâ€²) if and only if a Â· bâ€² = aâ€² Â· b. The ordered ring
structure of Q is given by
[(a, b)] +Q [(aâ€², bâ€²)]
=
[(abâ€² + aâ€²b, b Â· bâ€²)]
[(a, b)] Â·Q [(aâ€², bâ€²)]
=
[(aaâ€², bbâ€²)]
âˆ’Q [(a, b)]
=
[(âˆ’a, b)]
0Q
=
[(0, 1)]
1Q
=
[(1, 1)]
[(a, b)] = [(aâ€², bâ€²)]
â‡”
abâ€² = aâ€²b
[(a, b)] <Q [(aâ€², bâ€²)]
â‡”
abâ€² < aâ€²b
Finally, the reals are deï¬ned by putting R = S/â‰¡R. Here S is deï¬ned to be
the set of Cauchy sequences over Q, i.e., sequences âŸ¨qnâŸ©nâˆˆN âˆˆQN satisying
âˆ€Îµ > 0 âˆƒm âˆ€n (n > m â‡’|qm âˆ’qn| < Îµ) .
90

And â‰¡R is the equivalence relation on S deï¬ned by putting âŸ¨qnâŸ©n â‰¡R âŸ¨qâ€²
nâŸ©n if
and only if limn |qn âˆ’qâ€²
n| = 0, i.e.,
âˆ€Îµ > 0 âˆƒm âˆ€n (n > m â‡’|qn âˆ’qâ€²
n| < Îµ) .
The ordered ring structure of R is given by
[âŸ¨qâŸ©n] +R [âŸ¨qâ€²
nâŸ©n]
=
[âŸ¨qn + qâ€²
nâŸ©n]
[ âŸ¨qnâŸ©n] Â·R [âŸ¨qâ€²
nâŸ©n]
=
[âŸ¨qn Â· qâ€²
nâŸ©n]
âˆ’R [âŸ¨qnâŸ©n]
=
[âŸ¨âˆ’qnâŸ©n]
0R
=
[âŸ¨0âŸ©n]
1R
=
[âŸ¨1âŸ©n]
[ âŸ¨qnâŸ©n] = [âŸ¨qâ€²
nâŸ©n]
â‡”
âˆ€Îµ > 0 âˆƒm âˆ€n (n > m â‡’|qn âˆ’qâ€²
n| < Îµ)
[ âŸ¨qnâŸ©n] <R [âŸ¨qâ€²
nâŸ©n]
â‡”
âˆƒÎµ > 0 âˆƒm âˆ€n (n > m â‡’qn + Îµ < qâ€²
n)
Exercise 4.9.11. Show that the real number system is complete, i.e., every
nonempty bounded subset of R has a least upper bound.
Remark 4.9.12. In this section we have shown how many or most mathemati-
cal objects may be redeï¬ned or reconstructed as pure, well-founded sets. In this
sense, pure set theory may be said to encompass virtually all of mathematics,
and one may speak of the set-theoretic foundations of mathematics. This is why
set theory is viewed as being of fundamental or foundational importance.
91

Chapter 5
Axiomatic Set Theory
This chapter is an introduction to axiomatic set theory.
5.1
The Axioms of Set Theory
Deï¬nition 5.1.1. We deï¬ne Lâˆˆ, the language of set theory.
The language
contains variables x, y, z, . . .. The atomic formulas of the language are x = y
and x âˆˆy, where x and y are variables. Formulas are built up as usual from
atomic formulas by means of propositional connectives âˆ§, âˆ¨, Â¬ , â‡’, â‡”and
quantiï¬ers âˆ€, âˆƒ. The notion of free variable is deï¬ned as usual. A sentence is a
formula with no free variables.
Remark 5.1.2. The standard or intended interpretation of Lâˆˆis that the
variables are to range over the class of pure, well-founded sets. Thus formulas
and sentences are normally interpreted as making assertions about pure, well-
founded sets. This standard interpretation or model of Lâˆˆis sometimes known
as the real world.
Example 5.1.3. An example of a sentence of Lâˆˆis
âˆ€x âˆ€y (x = y â‡”âˆ€u (u âˆˆx â‡”u âˆˆy)) .
This sentence asserts the extensionality principle for pure, well-founded sets:
two pure, well-founded sets are equal if and only if they contain the same pure,
well-founded sets as elements.
Example 5.1.4. An example of a formula of Lâˆˆis
âˆ€u (u âˆˆz â‡”(u = x âˆ¨u = y)) .
This formula has free variables x, y, and z. It asserts that z is the unordered
pair {x, y}, i.e., the set whose only elements are x and y.
92

As mentioned above, the standard interpretation of Lâˆˆis in terms of the
real world, i.e., the class of pure, well-founded sets. In later sections of this
chapter, we shall consider interpretations or models of Lâˆˆother than the real
world. Such alternative interpretations play an essential role in axiomatic set
theory.
We can expand the language Lâˆˆindeï¬nitely by introducing abbreviations.
Some important abbreviations are given in the following deï¬nition.
Deï¬nition 5.1.5.
1. (unordered pair) z = {x, y} is an abbreviation for
âˆ€u (u âˆˆz â‡”(u = x âˆ¨u = y)).
2. (singleton) z = {x} is an abbreviation for z = {x, x}.
3. (ordered pair) z = (x, y) is an abbreviation for z = {{x}, {x, y}}, i.e.,
âˆƒu âˆƒv (u = {x} âˆ§v = {x, y} âˆ§z = {u, v}).
4. (subset) x âŠ†y is an abbreviation for âˆ€u (u âˆˆx â‡’u âˆˆy).
5. (powerset) z = P(x) is an abbreviation for
âˆ€y (y âˆˆz â‡”y âŠ†x).
6. (union of a set of sets) z = S x is an abbreviation for
âˆ€u (u âˆˆz â‡”âˆƒv (v âˆˆx âˆ§u âˆˆv)).
7. (union of two sets) z = x âˆªy is an abbreviation for z = S{x, y}, i.e.,
âˆƒw (w = {x, y} âˆ§z = S w).
8. (intersection of a set of sets) z = T x is an abbreviation for
âˆ€u (u âˆˆz â‡”âˆ€v (v âˆˆx â‡’u âˆˆv)).
9. (intersection of two sets) z = xâˆ©y is an abbreviation for z = T{x, y}, i.e.,
âˆƒw (w = {x, y} âˆ§z = T w).
10. (empty set) x = âˆ…and x = {} are abbreviations for âˆ€u (u /âˆˆx).
Using these abbreviations, we can write down sentences expressing some of
the axioms of Zermelo-Fraenkel set theory:
Deï¬nition 5.1.6 (Some Axioms of Set Theory).
93

1. Axiom of Extensionality: âˆ€x âˆ€y (x = y â‡”âˆ€u (u âˆˆx â‡”u âˆˆy)).
2. Empty Set Axiom: âˆƒx (x = âˆ…).
3. Pairing Axiom: âˆ€x âˆ€y âˆƒz (z = {x, y}).
4. Union Axiom: âˆ€x âˆƒz (z = S x).
5. Power Set Axiom: âˆ€x âˆƒz (z = P(x)).
6. Axiom of Foundation: âˆ€x (x Ì¸= âˆ…â‡’âˆƒu (u âˆˆx âˆ§u âˆ©x = âˆ…)).
Most of the above axioms are self-explanatory. Only the Axiom of Founda-
tion needs explanation. The Axiom of Foundation is an attempt to express the
idea that all of the sets under consideration are well-founded. This is expressed
by saying that, for all sets x, if x is nonempty then x contains an element u
which is âˆˆ-minimal. Note that, for u âˆˆx, u âˆ©x = âˆ…means that u is âˆˆ-minimal
among elements of x, i.e., there is no element v of x such that v âˆˆu.
We now introduce some more abbreviations and axioms.
Deï¬nition 5.1.7.
1. (Cartesian product) z = x Ã— y is an abbreviation of
âˆ€w (w âˆˆz â‡”âˆƒu âˆƒv (u âˆˆx âˆ§v âˆˆy âˆ§w = (u, v))).
2. (function) Fcn(f) is an abbreviation for a formula saying that f is a func-
tion, i.e.,
âˆ€w (w âˆˆf â‡’âˆƒx âˆƒy (w = (x, y)))âˆ§âˆ€x âˆ€y âˆ€z (((x, y) âˆˆfâˆ§(x, z) âˆˆf) â‡’y = z) .
3. (value of a function) y = f(x) is an abbreviation of
Fcn(f) âˆ§(x, y) âˆˆf.
4. (domain of a function) z = dom(f) is an abbreviation of
Fcn(f) âˆ§âˆ€x (x âˆˆz â‡”âˆƒy (x, y) âˆˆf).
5. (generalized Cartesian product) z = Q f is an abbreviation of
Fcn(f)âˆ§âˆ€g (g âˆˆz â‡”(dom(g) = dom(f)âˆ§âˆ€x (x âˆˆdom(f) â‡’g(x) âˆˆf(x)))) .
Deï¬nition 5.1.8. The Axiom of Choice is the sentence
âˆ€f ((Fcn(f) âˆ§âˆ€x (x âˆˆdom(f) â‡’f(x) Ì¸= âˆ…)) â‡’Q f Ì¸= âˆ…).
Deï¬nition 5.1.9. The Axiom of Inï¬nity is the sentence
94

âˆƒz (âˆ…âˆˆz âˆ§âˆ€x (x âˆˆz â‡’x âˆª{x} âˆˆz)).
The purpose of the Axiom of Inï¬nity is to assert the existence of at least
one inï¬nite set. This is accomplished by asserting the existence of a set that
contains all of the sets 0 = {} = âˆ…, 1 = {0}, 2 = {0, 1}, 3 = {0, 1, 2}, . . . .
We now introduce the two remaining axioms of Zermelo-Fraenkel set theory.
Actually, these two so-called axioms are not individual axioms, but rather axiom
schemes.
An axiom scheme is an inï¬nite set of axioms all of which have a
common form.
Recall that, if F is a formula with free variables x1, . . . , xn, then the universal
closure of F is the sentence âˆ€x1 Â· Â· Â· âˆ€xn F.
Deï¬nition 5.1.10.
1. The Comprehension Scheme is an inï¬nite set of axioms, consisting the
universal closures of all formulas of the form
âˆƒz âˆ€u (u âˆˆz â‡”(u âˆˆx âˆ§F(u))) ,
where F(u) is any formula in which z does not occur freely.
2. For any formula F(u), we write z = {u âˆˆx | F(u)} as an abbreviation for
âˆ€u (u âˆˆz â‡”(u âˆˆx âˆ§F(u))) .
The Comprehension Scheme is our attempt to express the principle that,
given a set x and a property P that particular elements of x may or may
not have, there necessarily exists a set z âŠ†x consisting of all elements of x
which have the given property P. Since our language Lâˆˆdoes not enable us to
discuss or quantify over arbitrary properties, we restrict attention to properties
that are deï¬nable, i.e., expressible by means of a formula F(u). The syntactical
requirement that the variable z does not occur freely in F(u) is imposed in order
to avoid obvious contradictions such as z = {u âˆˆx | u /âˆˆz}, the idea being that
the set z should be in some sense logically subordinate to the property P.
The Comprehension Scheme is extremely useful and important. For example,
given a function f, the Comprehension Scheme together with the Union, Pairing,
and Power Set Axioms logically imply the existence of a set z which is the domain
of f,
z = domf = {x âˆˆS S f | âˆƒy ((x, y) âˆˆf)},
and of the generalized Cartesian product
Q f = {g âˆˆPPP(S S f âˆªS S S f) | domg = z âˆ§âˆ€x (x âˆˆz â‡’g(x) âˆˆf(x))}.
Deï¬nition 5.1.11.
1. We write âˆƒ! x to mean â€œthere exists exactly one x such thatâ€. In other
words, for any formula F(x) in which x occurs as a free variable, âˆƒ! x F(x)
is an abbreviation of
âˆƒy âˆ€x (F(x) â‡”x = y) .
95

2. The Replacement Scheme is an inï¬nite set of axioms, consisting of the
universal closures of all formulas of the form
âˆ€u (u âˆˆx â‡’âˆƒ! v F(u, v)) â‡’âˆƒy âˆ€v (v âˆˆy â‡”âˆƒu (u âˆˆx âˆ§F(u, v))) ,
where F(u, v) is any formula in which y does not occur freely.
The Replacement Scheme is our attempt to express the principle that, given
a set x and a rule associating to each element u of x a unique object v, there
exists a set y consisting of all the objects v which are associated to elements of x.
Since our language Lâˆˆdoes not enable us to discuss or quantify over arbitrary
rules, we restrict attention to rules that are deï¬nable, i.e., expressible by means
of a formula F(u, v). The syntactical requirement that the variable y does not
occur freely in F(u, v) is imposed in order to avoid obvious contradictions.
We have now introduced all of the axioms of Zermelo/Fraenkel set theory.
We have, ï¬nally:
Deï¬nition 5.1.12 (Zermelo/Fraenkel Set Theory). The axioms of Zermelo/Fraenkel
set theory are as follows: the Axiom of Extensionality, the Empty Set Axiom,
the Pairing Axiom, the Union Axiom, the Power Set Axiom, the Axiom of Foun-
dation, the Axiom of Inï¬nity, the Comprehension Scheme, and the Replacement
Scheme. We use ZF as an abbreviation for â€œZermelo/Fraenkel set theoryâ€.
Deï¬nition 5.1.13 (ZFC). The axioms of ZFC consist of the axioms of ZF plus
the Axiom of Choice.
The Zermelo/Fraenkel axioms together with the Axiom of Choice constitute
the commonly accepted, rigorous, set-theoretic foundation of mathematics. A
mathematical theorem is regarded as proved if and only if it is clear how to de-
duce it as a theorem of ZFC, i.e., a logical consequence1 of the ZFC axioms. It
can be shown that all of the theorems of 19th and 20th century rigorous math-
ematics are logical consequences of the ZFC axioms. In particular, essentially
all of the results of Chapter 4 can be stated and proved as theorems of ZFC.
5.2
Models of Set Theory
As mentioned above, the intended interpretation of Lâˆˆis the so-called real world,
i.e., the class of pure, well-founded sets. However, the general notion of pure,
well-founded set is rather vague. In order to study and delimit this vagueness,
axiomatic set theorists frequently consider alternative interpretations of Lâˆˆ.
One important class of interpretations of Lâˆˆis given in terms of relational
structures. Recall that a relational structure is an ordered pair (A, E) where A
is a set and E âŠ†A Ã— A. Given a relational structure (A, E) and a sentence F
of Lâˆˆ, it makes sense to ask whether F is true in (A, E), i.e., true when the
variables are interpreted as ranging over A and x âˆˆy is interpreted as xEy, i.e.,
(x, y) âˆˆE.
1The notions of theorem and logical consequence that we are using here will be explained
in the next section.
96

Examples 5.2.1. The Axiom of Extensionality is true in a particular relational
structure (A, E) if and only if (A, E) is extensional, i.e., for all a, b âˆˆA, a Ì¸=
b implies {c | cEa} Ì¸= {c | cEb}.
Note that some relational structures are
extensional and some are not. An example of an extensional relational structure
is any linear ordering. An example of a nonextensional relational structure is
(A, E) whenever |A| â‰¥2 and E = âˆ….
Thus a relational structure is extensional if and only if it is a model of
(i.e., satisï¬es) the Axiom of Extensionality. The general point here is that any
collection of sentences of Lâˆˆdeï¬nes a property of relational structures, namely
the property of satisfying the given sentences. We formalize this in the following
deï¬nition.
Deï¬nition 5.2.2. Let S be any set of sentences of Lâˆˆ. A model of S is a
relational structure (A, E) such that all of the sentences of S are true in (A, E).
We say that S is consistent if there exists a model of S. If F is another sentence
of Lâˆˆ, we say that F is a logical consequence of S, written S âŠ¢F, if F is true
in every model of S.
Note that if S is inconsistent then all sentences are logical consequences of S,
so the notion of logical consequence is uninteresting in this case. If however S is
consistent, then it is meaningful to ask which sentences are logical consequences
of S, i.e., what conclusions follow when the sentences of S are assumed as
axioms. This is the kind of question which axiomatic set theory seeks to answer.
Naturally the focus is on sets of sentences which make assertions that could
reasonably be true in the intended model, i.e., the real world, i.e., the class of
all pure, well-founded sets.
As an easy example of the notion of logical consequence, note that the sen-
tence âˆ€x (x /âˆˆx) is a logical consequence of the Axiom of Foundation plus the
Pairing Axiom. This is so because x âˆˆx would imply that {x} has no âˆˆ-minimal
element.
Specializing Deï¬nition 5.2.2 to S = ZF and S = ZFC, we have:
Deï¬nition 5.2.3. A model of ZFC is a relational structure (A, E) such that
(A, E) satisï¬es all of the Zermelo/Fraenkel axioms plus the Axiom of Choice.
A theorem of ZFC is any sentence which is a logical consequence of the ZFC
axioms. The notions model of ZF and theorem of ZF are deï¬ned similarly.
Axiomatic set theory is essentially the study of models of ZF and of ZFC,
with an eye to discovering which set-theoretic propositions follow or do not
follow from these axiom systems. For instance, one of the important results2 of
axiomatic set theory is that there exists a model of ZF which is not a model of
ZFC. In other words, the Axiom of Choice is not a logical consequence of the
ZF axioms. Another key result is that both the Continuum Hypothesis and its
negation are consistent with ZFC. In other words, CH is independent of ZFC.
Thus the ZFC axioms, although powerful and ï¬‚exible, do not suï¬ƒce to answer
basic set-theoretic questions such as the Continuum Problem.
2This result will not be proved here.
97

We end this section by presenting some general deï¬nitions and results con-
cerning relational structures.
Deï¬nition 5.2.4. Let (A, E) be a relational structure. A k-place predicate P âŠ†
Ak is said to be deï¬nable over (A, E) if there exists a formula F(x1, . . . , xk, y1, . . . , ym)
of Lâˆˆand parameters b1, . . . , bm âˆˆA such that
P = {âŸ¨a1, . . . , akâŸ©âˆˆAk | (A, E) satisï¬es F(a1, . . . , ak, b1, . . . , bm)} .
(5.1)
More generally, given B âŠ†A, we say that P âŠ†Ak is deï¬nable over (A, E)
allowing parameters from B if there exists a formula
F(x1, . . . , xk, y1, . . . , ym)
of Lâˆˆand parameters b1, . . . , bm âˆˆB such that (5.1) holds.
Deï¬nition 5.2.5. Let (A, E) be a relational structure. Then Def((A, E)) is the
set of all subsets of A that are deï¬nable over (A, E). Note that Def((A, E)) âŠ†
P(A).
Lemma 5.2.6. Let (A, E) be a relational structure.
1. If A is ï¬nite, then Def((A, E)) = P(A) and |Def((A, E)| = 2|A|.
2. If A is inï¬nite, then |Def((A, E))| = |A|.
Proof. For ï¬nite A the result is obvious. Suppose now that A is inï¬nite. By
GÂ¨odel numbering, the set of all formulas of Lâˆˆis countable. Since any element
of Def((A, E)) is determined by a formula and a ï¬nite sequence of parameters
from A, we have
|Def((A, E))| â‰¤â„µ0 Â· |Aâˆ—| = |A| .
On the other hand {{a} | a âˆˆA} âŠ†Def((A, E)), hence |A| â‰¤|Def((A, E))|.
This completes the proof.
Deï¬nition 5.2.7. Let (A, E) and (Aâ€², Eâ€²) be relational structures. We say that
(Aâ€², Eâ€²) is a substructure of (A, E), abbreviated (Aâ€², Eâ€²) âŠ†(A, E), if Aâ€² âŠ†A
and Eâ€² = E âˆ©(Aâ€² Ã— Aâ€²). We say that (Aâ€², Eâ€²) is an elementary substructure
of (A, E), abbreviated (Aâ€², Eâ€²) âŠ†elem (A, E), if (Aâ€², Eâ€²) âŠ†(A, E) and, for all
formulas F(x1, . . . , xn) and a1, . . . , an âˆˆAâ€², (A, E) satisï¬es F(a1, . . . , an) if and
only if (Aâ€², Eâ€²) satisï¬es F(a1, . . . , an).
Lemma 5.2.8. Given (Aâ€², Eâ€²) âŠ†(A, E), we have (Aâ€², Eâ€²) âŠ†elem (A, E) if and
only if every nonempty subset of A which is deï¬nable over (A, E) allowing
parameters from Aâ€² has a nonempty intersection with Aâ€².
Proof. Straightforward.
Recall that a relational structure (A, E) is said to be countable if the under-
lying set A is countable.
98

Theorem 5.2.9 (LÂ¨owenheim/Skolem Theorem). For any relational structure
(A, E), there exists a countable elementary substructure (Aâ€², Eâ€²) âŠ†elem (A, E).
Proof. Let c : P(A) \ {âˆ…} â†’A be a choice function for A. We deï¬ne recursively
a sequence of sets An âŠ†A, n âˆˆN, by A0 = âˆ…, An+1 = {c(X) | âˆ…Ì¸= X âŠ†Aâˆ§X is
deï¬nable over (A, E) allowing parameters from An}. Note that An âŠ†An+1 for
all n. By induction on n it is straightforward to show that An is countable for all
n. Hence Aâ€² = S{An | n âˆˆN} is countable. Moreover c(X) âˆˆAâ€² for all X Ì¸= âˆ…
deï¬nable over (A, E) allowing parameters from Aâ€². Hence by Lemma 5.2.8 we
have (Aâ€², Eâ€²) âŠ†elem (A, E), where Eâ€² = E âˆ©(Aâ€² Ã— Aâ€²).
This completes the
proof.
Corollary 5.2.10 (Skolem Paradox). If ZFC is consistent, then there exists a
countable model of ZFC.
Proof. Assume that ZFC is consistent. Then there exists a model (A, E) of
ZFC. By Theorem 5.2.9 (A, E) has a countable elementary submodel, (Aâ€², Eâ€²).
Then (Aâ€², Eâ€²) is a countable model of ZFC.
The Skolem Paradox is called a paradox for the following reason: the exis-
tence of a countable model of ZFC would seem to contradict the fact that the
existence of uncountable sets is a theorem of ZFC. Actually, there is no contra-
diction here, because a set that is uncountable within a particular model (A, E)
may be countable in the real world. In other words, the notion of countability
is relative to the model under consideration (as are many other set-theoretic
notions).
A straightforward generalization of Theorem 5.2.9 is:
Theorem 5.2.11 (Generalized LÂ¨owenheim-Skolem Theorem). Let Îº be an in-
ï¬nite cardinal. Let (A, E) be a relational structure such that |A| â‰¥Îº, and let
X âŠ†A be a subset of A such that |X| â‰¤Îº. Then there exists an elementary
substructure (Aâ€², Eâ€²) of (A, E) such that X âŠ†Aâ€² and |Aâ€²| = Îº.
Proof. Straightforward.
Exercise 5.2.12. Prove Theorem 5.2.11.
5.3
Transitive Models and Inaccessible Cardi-
nals
In this section we study an important class of models. Recall that a set T is
transitive if and only if every element of T is a subset of T .
Deï¬nition 5.3.1. Let S be a set of sentences of Lâˆˆ. A transitive model of
S is any transitive, pure, well-founded set T such that the relational structure
(T, âˆˆ|T ) satisï¬es all the sentences of S. In this context it is customary to identify
the transitive set T with the relational structure (T, âˆˆ|T ).
99

Note that every transitive model is well-founded and extensional. The fol-
lowing theorem provides a converse and thereby characterizes transitive models
up to isomorphism among arbitrary models.
Theorem 5.3.2. Let (A, E) be a relational structure which is well-founded
and extensional. Then there exists a transitive, pure, well-founded set T such
that the relational structures (A, E) and (T, âˆˆ|T ) are isomorphic. Moreover the
transitive set T and the isomorphism f : (A, E) âˆ¼= (T, âˆˆ|T ) are unique.
Proof. Fix an object a0 /âˆˆA. By transï¬nite recursion on the rank of an arbitrary
pure, well-founded set x, deï¬ne F(x) as follows: F(x) = the unique a âˆˆA such
that rng(Fâ†¾x) = {b | bEa} if such an a exists; F(x) = a0 otherwise. Note
that F(x) = F(y) âˆˆA implies x = y. Hence T = rng(F âˆ’1â†¾A) is a set. It is
easy to verify that T is a transitive, pure, well-founded set and that Fâ†¾T is an
isomorphism of (T, âˆˆ|T ) onto (A, E). Hence f = F âˆ’1â†¾A is an isomorphism of
(A, E) onto (T, âˆˆ|T ). It is straightforward to verify that T and f are unique.
Corollary 5.3.3. If (A, E) is a relational structure, then the following asser-
tions are equivalent:
1. (A, E) is isomorphic to some transitive model (T, âˆˆ|T );
2. (A, E) is well-founded and extensional.
The rest of this section is devoted to the study of transitive models, i.e.,
relational structures of the form (A, âˆˆ|A) where T is a transitive, pure, well-
founded set. The following deï¬nition concerning transitive models is of general
interest.
Deï¬nition 5.3.4. Let T be any transitive, pure, well-founded set. A k-place
predicate P âŠ†T k is said to be deï¬nable over T if and only if it is deï¬nable over
(T, âˆˆ|T ) (allowing parameters from T ). We write
Def(T ) = Def((T, âˆˆ|T )) = {X âŠ†T | X is deï¬nable over T } .
Of particular interest are transitive models of ZFC. The following lemma
consists of some simple remarks characterizing which transitive models satisfy
which axioms of ZFC.
Lemma 5.3.5. Let T be a transitive, pure, well-founded set.
1. T always satisï¬es the Axiom of Extensionality.
2. T always satisï¬es the Axiom of Foundation.
3. T satisï¬es the Pairing Axiom if and only if T is closed under pairing, i.e.,
âˆ€a âˆ€b ((a âˆˆT âˆ§b âˆˆT ) â‡’{a, b} âˆˆT ).
4. T satisï¬es the Union Axiom if and only if T is closed under union, i.e.,
100

âˆ€a (a âˆˆT â‡’S a âˆˆT ).
5. T satisï¬es the Empty Set Axiom if and only if âˆ…âˆˆT .
6. T satisï¬es the Axiom of Inï¬nity if and only if âˆƒa (a âˆˆT âˆ§Ï‰ âŠ†a).
7. T satisï¬es the Power Set Axiom if and only if
âˆ€a (a âˆˆT â‡’P(a) âˆ©T âˆˆT ).
8. T satisï¬es the Axiom of Choice if and only if, for every indexed family of
nonempty sets âŸ¨aiâŸ©iâˆˆI âˆˆT , we have T âˆ©Q
iâˆˆI ai Ì¸= âˆ….
9. T satisï¬es the Comprehension Scheme if and only if, for all X âˆˆDef(T ),
we have
âˆ€a (a âˆˆT â‡’a âˆ©X âˆˆT ).
10. T satisï¬es the Replacement Scheme if and only if for all functions F : T â†’
T such that F âˆˆDef(T ), we have
âˆ€a (a âˆˆT â‡’rng(Fâ†¾a) âˆˆT ).
Proof. Straightforward.
We shall now show that inaccessible cardinals give rise to transitive models
of ZFC. Recall that an inaccessible cardinal is a regular, uncountable, strong
limit cardinal.
Recall also that we have identiï¬ed cardinals with initial von
Neumann ordinals (cf. Sections 4.4.5 and 4.4.8).
Lemma 5.3.6. Let Î´ be a limit ordinal > Ï‰. Then RÎ´ is a transitive model of
all of the ZFC axioms except possibly the Replacement Scheme.
Proof. We apply Lemma 5.3.5. The Axioms of Extensionality and Foundation
hold in RÎ´ because RÎ´ is a transitive, pure, well-founded set.
The Empty
Set, Power Set, Pairing, and Union Axioms and the Axiom of Choice and the
Comprehension Scheme hold in RÎ´ because Î´ is a limit ordinal. The Axiom of
Inï¬nity holds in RÎ´ because Ï‰ âˆˆRÎ´, since Ï‰ < Î´.
Lemma 5.3.7. An inï¬nite cardinal Î» is regular if and only if, for all X âŠ†Î»,
|X| < Î» implies sup X < Î».
Proof. Straightforward.
Lemma 5.3.8. If Î» is an inaccessible cardinal, then
1. âˆ€x ((x âŠ†RÎ» âˆ§|x| < Î») â‡’x âˆˆRÎ»).
2. âˆ€x (x âˆˆRÎ» â‡’|x| < Î»).
101

3. |RÎ»| = Î».
Proof.
1.
Deï¬ne Ï : x â†’Î» by Ï(u) = rank(u).
Then |rngÏ| â‰¤|x| < Î».
Since Î» is regular, it follows by the previous lemma that sup(rngÏ) < Î», say
rngÏ âŠ†Î± < Î». Hence x âŠ†RÎ±, hence x âˆˆRÎ±+1 âŠ†RÎ» since Î» is a limit ordinal.
2. By transï¬nite induction on Î± < Î» we prove |RÎ±| < Î». We have R0 = âˆ….
If |RÎ±| = Îº < Î», then |RÎ±+1| = |P(RÎ±)| = 2Îº < Î» since Î» is a strong limit
cardinal. For limit ordinals Î´ < Î», we have inductively |RÎ´| = | S
Î±<Î´ RÎ±| =
supÎ±<Î´ |RÎ±| < Î», since |RÎ±| < Î» and Î» is regular.
3. |RÎ»| = supÎ±<Î» |RÎ±| = Î».
Theorem 5.3.9. Let Î» be an inaccessible cardinal. Then RÎ» is a transitive
model of ZFC.
Proof. Clearly Î» is a limit ordinal > Ï‰, hence by Lemma 5.3.6 we see that RÎ»
satisï¬es all of the ZFC axioms except possibly the Replacement Scheme.
Let F : RÎ» â†’RÎ» and a âˆˆRÎ» be given.
Then rng(Fâ†¾a) âŠ†RÎ» and
|rng(Fâ†¾a)| â‰¤|a| < Î», hence by the previous lemma rng(Fâ†¾a) âˆˆRÎ».
Spe-
cializing this to the case when F is deï¬nable over RÎ», we see by Lemma 5.3.5
that the Replacement Scheme holds in RÎ». This completes the proof.
Corollary 5.3.10. If there exists an inaccessible cardinal, then ZFC is consis-
tent.
Proof. Immediate from the theorem.
Exercise 5.3.11. A hereditarily ï¬nite set is a ï¬nite set x such that all elements
of x, elements of elements of x, . . . , are ï¬nite sets. Show that RÏ‰ is the set of
all hereditarily ï¬nite, pure, well-founded sets. Show that RÏ‰ is a model of all
of the axioms of ZFC except the Axiom of Inï¬nity.
Exercise 5.3.12. Deï¬ne E âŠ†N by putting mEn if and only if 2m occurs in
the binary expansion of n, i.e., m = ni for some i where n = 2n1 + Â· Â· Â· + 2nk.
1. Show that (N, E) âˆ¼= (RÏ‰, âˆˆ|RÏ‰).
2. Conclude that P âŠ†Ï‰k is deï¬nable over RÏ‰ if and only if P is arithmetical.
Theorem 5.3.13. If there exists an inaccessible cardinal, then the existence of
an inaccessible cardinal is not a theorem of ZFC.
Proof. Assume that there exists an inaccessible cardinal. Let Î» be the smallest
inaccessible cardinal. By the previous theorem, RÎ» is a model of ZFC. We claim
that RÎ» also satisï¬es â€œinaccessible cardinals do not existâ€. To see this, suppose
that RÎ» satisï¬es â€œthere exists at least one inaccessible cardinalâ€. Let Îº âˆˆRÎ»
be such that RÎ» satisï¬es â€œÎº is an inaccessible cardinalâ€. Then it is easy to see
that Îº is also an inaccessible cardinal in the real world. But clearly Îº < Î».
This contradicts the choice of Î». Thus RÎ» is a model of ZFC + â€œinaccessible
cardinals do not existâ€.
102

The previous theorem shows that, if we assume only the axioms of ZFC,
then we cannot hope to prove the existence of inaccessible cardinals.
Exercise 5.3.14. Show that, if two or more inaccessible cardinals exist, then
the existence of two or more inaccessible cardinals is not a theorem of ZFC +
â€œthere exists at least one inaccessible cardinalâ€.
Theorem 5.3.15. If there exists an inaccessible cardinal, then there exists a
countable, transitive model of ZFC.
Proof. Let Î» be an inaccessible cardinal. Then (RÎ», âˆˆ|RÎ») is a model of ZFC.
By the LÂ¨owenheim-Skolem Theorem, there exists a countable set A âŠ†RÎ» such
that (A, âˆˆ|A) is an elementary submodel of (RÎ», âˆˆ|RÎ»).
Thus (A, âˆˆ|A) is a
countable, well-founded, extensional model of ZFC. By Theorem 5.3.2, (A, âˆˆ|A)
is isomorphic to a transitive model (T, âˆˆ|T ).
Thus (T, âˆˆ|T ) is a countable,
transitive model of ZFC.
Exercise 5.3.16. Let Î» be an inaccessible cardinal.
Prove that there ex-
ists a limit ordinal Î´ < Î» such that (RÎ´, âˆˆ|RÎ´) is an elementary submodel of
(RÎ», âˆˆ|RÎ»).
5.4
Constructible Sets
Recall that, if T is any transitive, pure, well-founded set, Def(T ) is the set of all
subsets of T that are deï¬nable over T (i.e., over (T, âˆˆ|T )) allowing parameters
from T .
Deï¬nition 5.4.1. By transï¬nite recursion we deï¬ne LÎ±, Î± âˆˆOrd, as follows:
L0
=
âˆ…
LÎ±+1
=
Def(LÎ±)
LÎ´
=
S
Î±<Î´ LÎ±
for limit ordinals Î´ .
A set X is said to be constructible if X âˆˆLÎ± for some ordinal Î±. The class of
all constructible sets is denoted L.
Lemma 5.4.2. For all ordinals Î±, LÎ± is a transitive, pure, well-founded set,
and LÎ± âŠ†RÎ±.
Proof. For any transitive, pure, well-founded set T , we have T âŠ†Def(T ) âŠ†P(T )
and hence Def(T ) is again a transitive, pure, well-founded set.
With these
observations, the lemma follows easily by transï¬nite induction on Î±.
Lemma 5.4.3. For all ordinals Î±, we have Î± = LÎ± âˆ©Ord.
Proof. If T is any transitive, pure, well-founded set, then for any a âˆˆT we
have that a is an ordinal (i.e., a von Neumann ordinal) if and only if T satisï¬es
â€œa is transitive and (a, âˆˆ|a) is a linear orderingâ€. Thus T âˆ©Ord âˆˆDef(T ).
With this observation, the lemma follows easily by transï¬nite induction on (von
Neumann) ordinals Î±.
103

We are going to show that the constructible sets form a model of ZFC.
Some of the axioms of ZFC are straightforwardly veriï¬ed in L using Lemma 5.3.5.
For instance, the Union Axiom holds in L because x âˆˆLÎ± implies S x âˆˆLÎ±.
The Pairing Axiom holds in L because x, y âˆˆLÎ± implies {x, y} âˆˆLÎ±+1. The
Empty Set Axiom holds in L because âˆ…âˆˆL1. The Axiom of Inï¬nity holds in
L because Ï‰ âˆˆLÏ‰+1. The Axioms of Extensionality and Foundation hold in L
because L is transitive and consists of pure, well-founded sets.
To show that the Power Set Axiom holds in L, let X be any constructible
set. For each Y âˆˆP(X) âˆ©L put Ï(Y ) = the least Î² such that Y âˆˆLÎ². Put
Î± = sup{Ï(Y ) | Y âˆˆP(X) âˆ©L}. Thus P(X) âˆ©L âŠ†LÎ±. Hence P(X) âˆ©L is
deï¬nable over LÎ±; namely, it is the set of all Y âˆˆLÎ± such that LÎ± satisï¬es
Y âŠ†X. Hence P(X) âˆ©L âˆˆDef(LÎ±) = LÎ±+1. We have now shown that for all
X âˆˆL, P(X) âˆ©L âˆˆL. From this it follows by Lemma 5.3.5 that the Power Set
Axiom holds in L.
To show that Comprehension and Replacement hold in L, we shall need the
following lemmas.
Lemma 5.4.4. Let f1, . . . , fk be functions from Ord to Ord. Then there exist
arbitrarily large ordinals Î± such that Î± is closed under f1, . . . , fk, i.e., fi(Î²) < Î±
for all Î² < Î±, 1 â‰¤i â‰¤k.
Proof. Given an ordinal Î³, deï¬ne an increasing sequence of ordinals Î±n, n âˆˆN
inductively by Î±0 = Î³, Î±n+1 = max(Î±n + 1, sup{fi(Î²) | Î² < Î±n, 1 â‰¤i â‰¤
k}). Putting Î± = sup{Î±n | n âˆˆN} we see that Î± > Î³ and Î± is closed under
f1, . . . , fk.
Lemma 5.4.5 (reï¬‚ection). Let F(x1, . . . , xn) be a formula of Lâˆˆwith free vari-
ables x1, . . . , xn. Then there exist arbitrarily large ordinals Î± such that, for all
a1, . . . , an âˆˆLÎ±, L satisï¬es F(a1, . . . , an) if and only if LÎ± satisï¬es F(a1, . . . , an).
Proof. Replacing âˆ€by Â¬ âˆƒÂ¬ as necessary, we may safely assume that F contains
no occurrences of âˆ€. Now let âˆƒy Gi, i = 1, . . . , k be a list of the subformulas of F
of the form âˆƒy G. Write Gi â‰¡Gi(y, xi1, . . . , xini) where xi1, . . . , xini are the free
variables of âˆƒy Gi. For a1, . . . , ani âˆˆL, put gi(a1, . . . , ani) = the least ordinal
Î² such that a1, . . . , ani âˆˆLÎ² and such that, if L satisï¬es âˆƒy Gi(y, a1, . . . , ani),
then L satisï¬es Gi(b, a1, . . . , ani) for some b âˆˆLÎ². Deï¬ne fi : Ord â†’Ord by
fi(Î²) = sup{gi(a1, . . . , ani) | a1, . . . , ani âˆˆLÎ²}. By the previous lemma, there
exist arbitrarily large ordinals Î± such that that Î± is closed under f1, . . . , fk. It
is straightforward to verify that such an Î± has the desired property.
Remark 5.4.6. The proof of the previous lemma used only the following prop-
erties of the constructible hierarchy: Î± â‰¤Î² implies LÎ± âŠ†LÎ²; and LÎ´ = S
Î±<Î´ LÎ±
for limit ordinals Î´. Since the RÎ± hierarchy also has these properties, the same
lemma holds for the RÎ± hierarchy as well. This has the following interesting
consequence: If F1, . . . , Fk is a ï¬nite set of sentences that are true in the real
world, then there exist arbitrarily large ordinals Î± such that F1, . . . , Fk are true
in RÎ±.
104

Lemma 5.4.7. L satisï¬es the Comprehension and Replacement Schemes.
Proof. To show that the Replacement Scheme holds in L, let f : L â†’L be a
function which is deï¬nable over L. We must prove that, for all a âˆˆL, rng(fâ†¾a) =
{f(u) | u âˆˆa} also belongs to L. Note ï¬rst that, since f is deï¬nable over L,
we have parameters c1, . . . , cn âˆˆL and a formula F(u, v, z1, . . . , zn) with free
variables u, v, z1, . . . , zn such that, for all u âˆˆL, f(u) = the unique v âˆˆL such
that L satisï¬es F(u, v, c1, . . . , cn). Now given a âˆˆL, put b = rng(fâ†¾a). We
must show that b âˆˆL. Let Î² be an ordinal so large that a, c1, . . . , cn âˆˆLÎ²
and b âŠ†LÎ². By Reï¬‚ection, let Î± be such that Î± > Î² and, for all u, v âˆˆLÎ±,
L satisï¬es F(u, v, c1, . . . , cn) if and only if LÎ± satisï¬es F(u, v, c1, . . . , cn). We
claim that b is deï¬nable over LÎ±. This is clear since
b
=
{v âˆˆL | L satisï¬es âˆƒu (u âˆˆa âˆ§F(u, v, c1, . . . , cn))}
=
{v âˆˆLÎ± | LÎ± satisï¬es âˆƒu (u âˆˆa âˆ§F(u, v, c1, . . . , cn))} .
Thus b âˆˆDef(LÎ±) = LÎ±+1, whence b âˆˆL. This shows that the Replacement
Scheme holds in L. The proof that the Comprehension Scheme holds in L is
similar.
We introduce some more abbreviations:
Deï¬nition 5.4.8.
1. Const(x) is an abbreviation for a formula asserting that a given pure, well-
founded set x is constructible. In more detail, Const(x) asserts the exis-
tence of a transï¬nite sequence of sets âŸ¨LÎ²âŸ©Î²â‰¤Î± such that LÎ² = S{Def(LÎ³) |
Î³ < Î²} for all Î² â‰¤Î±, and x âˆˆLÎ±.
2. Recall that V is the class of all pure, well-founded sets, and L is the
class of all constructible sets. We use V = L to abbreviate âˆ€x Const(x).
Thus V = L is a sentence asserting that all pure, well-founded sets are
constructible.
Theorem 5.4.9. The class L of constructible sets satisï¬es the ZF axioms plus
V = L.
Proof. The above lemmas show that L satisï¬es the ZF axioms. It is tedious but
straightforward to show that L satisï¬es V = L.
Lemma 5.4.10. For all ordinals Î± â‰¥Ï‰, we have |LÎ±| = |Î±|.
Proof. By Lemma 5.2.6 we have |LÏ‰| = â„µ0 and, for Î± â‰¥Ï‰, |LÎ±+1| = |Def(LÎ±)| =
|LÎ±|. From this the lemma easily follows by induction on Î± â‰¥Ï‰.
Theorem 5.4.11. The class L of constructible sets satisï¬es the Axiom of
Choice.
105

Proof. Lemma 5.4.10 implies that each LÎ± is well-orderable. Reï¬ning the proof
of Lemma 5.4.10, we can explicitly deï¬ne by transï¬nite recursion a function
F : Ord â†’V such that, for all ordinals Î±, F(Î±) is a well-ordering of LÎ±. Since
the deï¬nition of F is explicit, its validity does not depend on the Axiom of
Choice. Hence by Theorem 5.4.9 the deï¬nition of F can be carried out within L.
In particular L satisï¬es that each LÎ± is well-orderable. Hence by Remark 4.5.3
L satisï¬es the Axiom of Choice. This argument actually shows that the Axiom
of Choice follows from ZF plus V = L.
Our remaining goal with respect to constructible sets is to show that L
satisï¬es the GCH.
Lemma 5.4.12. There is a sentence S of Lâˆˆwith the following property. For
all transitive sets A, A satisï¬es S if and only if A = LÎ± for some limit ordinal
Î±.
Proof. The construction of the sentence S is straightforward but tedious. Roughly
speaking, S is identical with the sentence V = L of Deï¬nition 5.4.8. For de-
tails of the construction of S, see Boolos and Putnam, â€œDegrees of unsolvability
of constructible sets of integers,â€ Journal of Symbolic Logic, Volume 33, 1968,
pages 497â€“513.
Lemma 5.4.13. If a is any constructible subset of Ï‰, then a âˆˆLÎ± for some
countable ordinal Î±. More generally, if a âˆˆP(Îº) âˆ©L where Îº is an inï¬nite
cardinal, then a âˆˆLÎ± for some ordinal Î± such that |LÎ±| = Îº.
Proof. Let Îº be an inï¬nite cardinal. Suppose that a âŠ†Îº and a is constructible.
Let Î´ > Îº be a limit ordinal such that a âˆˆLÎ´. By the Generalized LÂ¨owenheim/-
Skolem Theorem (Theorem 5.2.11), we can ï¬nd a set A âŠ†LÎ´ such that Îº âˆª
{a} âŠ†A, |A| = Îº, and (A, âˆˆ|A) is an elementary submodel of (LÎ´, âˆˆ|LÎ´). By
Theorem 5.3.2 and Lemma 5.4.12, we have (A, âˆˆ|A) âˆ¼= (LÎ±, âˆˆ|LÎ±) for some
limit ordinal Î±. Since Îº âˆª{a} is a transitive subset of A, it follows by another
application of Theorem 5.3.2 that Îº âˆª{a} âŠ†LÎ±. In particular a âˆˆLÎ±. Clearly
|LÎ±| = Îº, and this completes the proof.
Lemma 5.4.14. For any inï¬nite cardinal Îº, we have |P(Îº) âˆ©L| â‰¤Îº+.
Proof. From the previous lemma we have P(Îº) âˆ©L âŠ†LÎº+. The desired conclu-
sion is immediate, since |LÎº+| = |Îº+|.
Theorem 5.4.15. The class L of constructible sets satisï¬es the Generalized
Continuum Hypothesis.
Proof. Since L satisï¬es the axioms of set theory, the proof of the previous lemma
can be carried out within L. Thus for all inï¬nite cardinals Îº of L, we have within
L that |P(Îº)| = Îº+, hence 2Îº = Îº+. This proves the theorem.
Theorem 5.4.16.
106

1. If ZF has a transitive model, then so does ZFC + GCH.
2. If ZF is consistent, then so is ZFC + GCH.
Proof. Let A be a transitive model of ZF. Within A we can carry out the
deï¬nition of L to obtain a transitive submodel B (sometimes called an â€œinner
modelâ€) consisting of the constructible sets of A. (It can be shown that B =
LÎ± where Î± is the least ordinal that is not an element of A.) The proofs of
theorems 5.4.9, 5.4.11, and 5.4.15 then show that B is a model of ZF plus
V = L plus the Axiom of Choice plus the GCH. This proves the ï¬rst part. The
proof of the second part is similar, starting with a model (A, E) that is not
necessarily transitive.
Remark 5.4.17. The previous theorem, due to GÂ¨odel 1939, is one of the most
signiï¬cant achievements of axiomatic set theory. The second part is sometimes
described as a relative consistency result: ZFC + GCH is consistent relative to
ZF.
5.5
Forcing
Let M be a countable transitive model of ZFC. Let P = (P, â‰¤) be a partially
ordered set belonging to M. We say that p, q âˆˆP are compatible if there exists
r âˆˆP such that r â‰¤p and r â‰¤q. If p, q âˆˆP are incompatible, we write p âŠ¥q.
Deï¬nition 5.5.1. A ï¬lter on P is a set G âŠ†P such that
1. p, q âˆˆG implies âˆƒr âˆˆG (r â‰¤p, q);
2. p âˆˆG, p â‰¤q imply q âˆˆG.
Deï¬nition 5.5.2. D âŠ†P is dense open if
1. âˆ€p âˆˆP âˆƒq â‰¤p (q âˆˆD);
2. âˆ€p âˆˆD âˆ€q â‰¤p (q âˆˆD).
Deï¬nition 5.5.3. A ï¬lter G âŠ†P is said to be M-generic if G âˆ©D Ì¸= âˆ…for all
dense open D âŠ†P such that D âˆˆM.
Lemma 5.5.4. Given p âˆˆP we can ï¬nd an M-generic ï¬lter G âŠ†P such that
p âˆˆG.
Proof. Let {Dn | n âˆˆN} be an enumeration of {D âˆˆM | D dense open in P}.
Put p0 = p and, given pn, let pn+1 â‰¤pn be such that pn+1 âˆˆDn. It is easy to
verify that G = {q âˆˆP | âˆƒn (pn â‰¤q)} is an M-generic ï¬lter.
Deï¬nition 5.5.5. Let G be an M-generic ï¬lter. We put
M[G] = {aG | a âˆˆM},
107

where
aG = {bG | (p, b) âˆˆa for some p âˆˆG}.
Remark 5.5.6. Think of each a âˆˆM as a â€œnameâ€ for aG âˆˆM[G]. We shall
show that M[G] is a countable transitive model of ZFC containing M.
Lemma 5.5.7. M[G] is a countable transitive set. We have M[G] âŠ‡M âˆª{G},
and Ord âˆ©M[G] = Ord âˆ©M.
Proof. It is obvious from the deï¬nition that M[G] is a countable transitive set.
For all a âˆˆM we have a = (Ë™a)G, where Ë™a = P Ã— {Ë™b | b âˆˆa}. We also have
G = ( Ë™G)G, where Ë™G = {(p, Ë™p) | p âˆˆP}. Thus M âˆª{G} âŠ†M[G], and from this
it follows that Ord âˆ©M âŠ†Ord âˆ©M[G]. On the other hand, for each a âˆˆM we
clearly have rank(a) â‰¥rank(aG), hence Ord âˆ©M âŠ‡Ord âˆ©M[G].
A major result is:
Theorem 5.5.8. M[G] is a countable transitive model of ZFC.
Remark 5.5.9. The proof of Theorem 5.5.8 is long and employs a new method
known as forcing. However, some parts of the proof are easy and do not require
forcing.
For example, given a, b âˆˆM, put c = P Ã— {a, b}, then cG = {aG, bG}. This
shows that M[G] satisï¬es the Pairing Axiom. Also, M[G] satisï¬es the Axiom of
Inï¬nity because Ï‰ = ( Ë™Ï‰)G âˆˆM[G]. Furthermore, M[G] satisï¬es Extensionality
and Foundation automatically, because M[G] is a transitive set.
So far we have not used the assumption that G is an M-generic ï¬lter.
In order to prove the rest of Theorem 5.5.8, we now introduce the method
of forcing.
Deï¬nition 5.5.10. The forcing language consists of binary relation symbols âˆˆ
and = plus constant symbols a for each a âˆˆM. Sentences of the forcing language
are of the form F(a1, . . . , an), where F(x1, . . . , xn) is a formula of Lâˆˆwith free
variables x1, . . . , xn, and a1, . . . , an âˆˆM. We have M[G] |= F(a1, . . . , an) if and
only if F(a1, . . . , an) is true in M[G], where quantiï¬ers are interpreted as ranging
over M[G], and a1, . . . , an are interpreted as (a1)G, . . . , (an)G respectively.
Deï¬nition 5.5.11 (forcing). Let p âˆˆP and let F be a sentence of the forcing
language. We say that p âˆ¥âˆ’F (read p forces F) if and only if M[G] |= F for all
M-generic ï¬lters G such that p âˆˆG.
Lemma 5.5.12 (the extension lemma). If p âˆ¥âˆ’F and q â‰¤p, then q âˆ¥âˆ’F.
Proof. This is obvious, because q âˆˆG, q â‰¤p imply p âˆˆG.
Lemma 5.5.13 (deï¬nability of forcing). For each formula F(x1, . . . , xn) there
is a formula F âˆ—(p, x1, . . . , xn) such that, for all p âˆˆP and a1, . . . , an âˆˆM,
p âˆ¥âˆ’F(a1, . . . , an) if and only if M |= F âˆ—(p, a1, . . . , an).
108

Lemma 5.5.14 (forcing equals truth). M[G] |= F if and only if âˆƒp âˆˆG (p âˆ¥âˆ’F).
Proof. We shall prove Lemmas 5.5.13 and 5.5.14 by simultaneous induction on
the number of connectives and quantiï¬ers in F. We assume that F contains
only âˆ§, Â¬ , and âˆ€(not âˆ¨, â‡’, â‡”, âˆƒ).
For the base step, we need to ï¬nd formulas âˆˆâˆ—(p, x, y) and =âˆ—(p, x, y) of
Lâˆˆdeï¬ning the relations p âˆ¥âˆ’a âˆˆb and p âˆ¥âˆ’a = b, respectively, over M. The
formulas âˆˆâˆ—and =âˆ—are deï¬ned by a rather complicated simultaneous transï¬nite
recursion within M. The properties
p âˆ¥âˆ’a âˆˆb if and only if M |= âˆˆâˆ—(p, a, b)
and
p âˆ¥âˆ’a = b if and only if M |= =âˆ—(p, a, b)
are proved by transï¬nite induction on rank(a) and rank(b). We omit the details.
For the inductive step, note that
p âˆ¥âˆ’F1 âˆ§F2 if and only if p âˆ¥âˆ’F1 and p âˆ¥âˆ’F2,
and
p âˆ¥âˆ’âˆ€x F(x) if and only if p âˆ¥âˆ’F(a) for all a âˆˆM.
Thus we may deï¬ne (F1 âˆ§F2)âˆ—= F âˆ—
1 âˆ§F âˆ—
2 and (âˆ€x F(x))âˆ—= âˆ€x F âˆ—(x). This
takes care of âˆ§and âˆ€. For Â¬ , we claim that
p âˆ¥âˆ’Â¬ F if and only if Â¬ âˆƒq â‰¤p (q âˆ¥âˆ’F).
To see this, assume the right hand side. Let G be generic with p âˆˆG. To show
M[G] |= Â¬ F. Otherwise, M[G] |= F so let q âˆˆG be such that q âˆ¥âˆ’F. Let
r âˆˆG be such that r â‰¤p and r â‰¤q. Then r â‰¤p and r âˆ¥âˆ’F, contradicting
our assumption. For the converse, assume the left hand side. Suppose q â‰¤p,
q âˆ¥âˆ’F. Let G be generic such that q âˆˆG. Then M[G] |= F. Also p âˆˆG since
q â‰¤p. Therefore p does not force Â¬ F, contradicting our assumption.
Thus, for deï¬nability of forcing, we may take
(Â¬ F)âˆ—(p, a1, . . . , an) â‰¡Â¬ (âˆƒq â‰¤p) F âˆ—(q, a1, . . . , an).
For focing equals truth, suppose M[G] |= Â¬ F. To show (âˆƒp âˆˆG) p âˆ¥âˆ’Â¬ F. Put
D = {p | p âˆ¥âˆ’F or p âˆ¥âˆ’Â¬ F}. Clearly D is dense open. By deï¬nability of
forcing, D âˆˆM. Let p âˆˆD âˆ©G. If p âˆ¥âˆ’F, then M[G] |= F, a contradiction.
Hence p âˆ¥âˆ’Â¬ F.
We now proceed to the proof of Theorem 5.5.8.
Lemma 5.5.15. M[G] |= the Comprehension Scheme.
Proof. Given a, a1, . . . , an âˆˆM, to ï¬nd c âˆˆM such that
M[G] |= âˆ€u (u âˆˆc â‡”(u âˆˆa âˆ§F(u, a1, . . . , an))).
Put
109

c = {(p, b) | b âˆˆS S a and p âˆ¥âˆ’b âˆˆa âˆ§F(b, a1, . . . , an)}.
Then c âˆˆM, by Deï¬nability of Forcing in M. Then, by the Forcing Equals
Truth Lemma, we have
cG = {bG | b âˆˆS S a and M[G] |= F(b, a1, . . . , an)}.
Lemma 5.5.16. M[G] |= the Power Set Axiom.
Proof. Given a âˆˆM, put c = P Ã— P(P Ã— S S a) âˆ©M. We claim that
cG âŠ‡P(aG) âˆ©M[G].
To see this, given eG âˆˆM[G], let d = {(p, b) âˆˆP Ã— S S a | p âˆ¥âˆ’b âˆˆe âˆ©a}. By
deï¬nability of forcing, d âˆˆM, hence dG âˆˆcG. Moreover dG = eG âˆ©aG. This
proves our claim. The Power Set Axiom follows by Comprehension in M[G],
since P(aG) âˆ©M[G] = {dG âˆˆcG | M[G] |= d âŠ†a}.
Lemma 5.5.17. M[G] |= the Union Axiom.
Proof. This is similar to the Power Set Axiom. Given a âˆˆM put
c = P Ã— S S S S a.
Then cG âŠ‡S aG, and the Union Axiom follows by Comprehension in M[G].
Lemma 5.5.18. M[G] |= the Replacement Scheme.
Proof. It suï¬ƒces to prove that M[G] |= the Bounding Scheme:
âˆ€w1 Â· Â· Â· wn [ âˆ€u âˆƒ! v F(u, v, w1, . . . , wn) â‡’âˆ€x âˆƒy âˆ€u âˆˆx âˆƒv âˆˆ
y F(u, v, w1, . . . , wn) ].
This is because Bounding plus Comprehension implies Replacement.
Given a, a1, . . . , an âˆˆM, let c âˆˆM be such that, for all (p, b) âˆˆP Ã— S S a,
if there exists d âˆˆM such that p âˆ¥âˆ’F(b, d, a1, . . . , an), then c contains such a
d. We then have
M[G] |= âˆ€u âˆƒ! v F(u, v, w1, . . . , wn) â‡’âˆ€u âˆˆa âˆƒv âˆˆcâ€² F(u, v, a1, . . . , an),
where câ€² âˆˆM, namely câ€² = P Ã— c. Thus M[G] |= Bounding.
Lemma 5.5.19. M[G] |= the Axiom of Choice.
Proof. Given aG âˆˆM[G], let f âˆˆM map an ordinal Î± onto S S a.
Since
M âŠ†M[G], we have f = ( Ë™f)G âˆˆM[G].
Composing f with the function
b 7â†’bG, we obtain in M[G] a mapping of Î± = ( Ë™Î±)G onto {bG | b âˆˆS S a} âŠ‡aG.
Thus aG is well orderable in M[G].
The proof of Theorem 5.5.8 is now complete.
As a ï¬rst application, we prove the independence of V = L.
Theorem 5.5.20. There exists a countable transitive model of ZFC plus V Ì¸= L.
110

Proof. Let M be a countable transitive model of ZFC. Let P be the set of ï¬nite
partial functions from Ï‰ into 2 = {0, 1}. Partially order P by putting p â‰¤q if
and only if p extends q. Then P âˆˆM. Let G be an M-generic ï¬lter on P. By
Theorem 5.5.8 we have M[G] |= ZFC.
Note that p, q âˆˆP are compatible if and only if p âˆªq âˆˆP. Thus g = S G
is a partial function from Ï‰ into 2. We claim that dom(g) = Ï‰. To see this,
given n âˆˆÏ‰, put Dn = {p âˆˆP | n âˆˆdom(g)}. Clearly Dn is dense open, and
Dn âˆˆM. Letting p âˆˆG âˆ©Dn, we see that n âˆˆdom(p), hence n âˆˆdom(g).
Thus g : Ï‰ â†’2 and g âˆˆM[G]. We claim that g /âˆˆM. If g âˆˆM, then clearly
G = {p âˆˆP | p âŠ†g} âˆˆM, so let D = P \ G = {p âˆˆP | p /âˆˆG}. Then D âˆˆM,
and clearly D is dense open. But G âˆ©D = âˆ…, a contradiction.
We claim that M[G] |= V Ì¸= L. In fact,
M[G] |= Ë™g /âˆˆL âˆ§Ë™g : Ï‰ â†’2
where (Ë™g)G = g.
5.6
Independence of CH
As in the previous section, let M be a countable transitive model of ZFC, let P
be a partially ordered set belonging to M, and let G be an M-generic ï¬lter on
P. We begin with a discussion of cardinal collapsing and cardinal preservation
in M[G].
Remark 5.6.1. Clearly every cardinal of M[G] is a cardinal of M. However,
the converse does not always hold. Cardinals of M can be collapsed in M[G].
Example 5.6.2. Let Îº be an uncountable cardinal of M. Let P be the set of
ï¬nite partial functions from Ï‰ into Îº, ordered by p â‰¤q if and only if p extends
q. Let G be an M-generic ï¬lter on P. Put g = S G. As in the proof of Theorem
5.5.20, we see that g : Ï‰ â†’Îº.
We claim that rng(g) = Îº. To see this, give Î± < Îº, put DÎ± = {p âˆˆP | Î± âˆˆ
rng(p)}. Clearly DÎ± âˆˆM. Because Ï‰ is inï¬nite, DÎ± is dense open. Letting
p âˆˆG âˆ©DÎ±, we see that Î± âˆˆrng(p), hence Î± âˆˆrng(g).
Thus g âˆˆM[G] maps Ï‰ onto Îº. It follows that M[G] |= â€œ Ë™Îº is a countable
ordinalâ€. In particular Îº is not a cardinal of M[G].
On the other hand, cardinals of M are often preserved, i.e., remain cardinals
in M[G].
Lemma 5.6.3. Suppose M |= â€œÎº is a cardinal > |P|â€. Then M[G] |= â€œÎº is a
cardinalâ€. In other words, all cardinals > |P| in M are preserved in M[G].
Proof. Suppose not, say fG : Î» â†’Îº, Î» < Îº, rng(fG) = Îº, fG âˆˆM[G]. Then in
M we have
âˆ€Î± < Îº âˆƒÎ² < Î» âˆƒp âˆˆP (p âˆ¥âˆ’f | Ë™Î» â†’Ë™Îº and p âˆ¥âˆ’f( Ë™Î²) = Ë™Î±).
111

By the Pigeonhole Principle, we can ï¬nd p âˆˆP, Î² < Î», Î±1 < Î±2 < Îº such that
p âˆ¥âˆ’f : Ë™Î» â†’Ë™Îº and p âˆ¥âˆ’f( Ë™Î²) = Ë™Î±1 and f( Ë™Î²) = Ë™Î±2. This is a contradiction.
Deï¬nition 5.6.4. An antichain in P is a set A âŠ†P such that the elements
of A are pairwise incompatible. P is said to have the countable chain condition
(c.c.c.) if every antichain of P is countable.
Lemma 5.6.5. Suppose M |= P is c.c.c. Then all cardinals of M are preserved
in M[G].
Proof. Suppose not, say Îº > Î», M |= â€œÎº is a cardinalâ€, M[G] |= â€œf maps Ë™Î» onto
Ë™Îºâ€. Fix p âˆˆP such that p âˆ¥âˆ’â€œf maps Ë™Î» onto Ë™Îºâ€. Reasoning within M, for Î± < Îº
and Î² < Î» say that Î± is a possible value of f(Î²) if âˆƒq â‰¤p (q âˆ¥âˆ’f( Ë™Î²) = Ë™Î±). Let
XÎ² = {Î± | Î± is a possible value of f(Î²)}. Note that Îº = S
Î²<Î» XÎ². Therefore,
some XÎ² is uncountable. Fix such a Î². For each Î± âˆˆXÎ² let qÎ± â‰¤p be such
that qÎ± âˆ¥âˆ’f( Ë™Î²) = Ë™Î±. Note that Î±1, Î±2 âˆˆXÎ², Î±1 Ì¸= Î±2 implies qÎ±1 âŠ¥qÎ±2. Thus
AÎ² = {qÎ± | Î± âˆˆXÎ²} is an uncountable antichain in P. This contradicts the
assumption that P is c.c.c.
We now proceed to the independence of the Continuum Hypothesis.
Deï¬nition 5.6.6. A âˆ†-system is an indexed family of sets âŸ¨XiâŸ©iâˆˆI such that,
for some ï¬xed set D, Xi âˆ©Xj = D for all i, j âˆˆI, i Ì¸= j.
Lemma 5.6.7 (the âˆ†-system lemma). Any uncountable family of ï¬nite sets
contains an uncountable subfamily which is a âˆ†-system.
Proof. Let âŸ¨XiâŸ©iâˆˆI be an uncountable family of ï¬nite sets. We may safely assume
that |I| = â„µ1 and that S
iâˆˆI Xi âŠ†Ï‰1. Passing to an uncountable subfamily, we
may assume that âˆƒn âˆ€i âˆˆI |Xi| = n. For each i âˆˆI, let Xi(1) < Â· Â· Â· < Xi(n) be
the elements of Xi.
Case 1: For each k = 1, . . . , n, {Xi(k) : i âˆˆI} is countable. In this case,
S
iâˆˆI Xi is countable. Hence, by passing to an uncountable subfamily, we may
assume Xi = Xj for all i, j âˆˆI. In particular, we have an uncountable âˆ†-system.
Case 2: Otherwise. Let k be as small as possible such that {Xi(k) | i âˆˆI}
is uncountable. Then, for each l < k, {Xi(l) | i âˆˆI} is countable. By passing
to an uncountable subfamily, we may assume Xi(l) = Xj(l) for all l < k and all
i, j âˆˆI. Thus we have a ï¬xed ï¬nite set D = {Xi(l) | 1 â‰¤l < k} for all i âˆˆI.
Since {Xi(k) | i âˆˆI} is uncountable, we may use transï¬nite recursion to deï¬ne
a function f : Ï‰1 â†’I such that, for each Î± < Ï‰1, Xf(Î±)(k) > supÎ²<Î± Xf(Î²)(n).
Then âŸ¨Xf(Î±)âŸ©Î±<Ï‰1 is an uncountable âˆ†-system contained in âŸ¨XiâŸ©iâˆˆI.
Lemma 5.6.8. Let X be any set. Let P be the set of ï¬nite partial functions
from X into {0, 1}, ordered by putting p â‰¤q if and only if p âŠ‡q. Then P is
c.c.c.
Proof. Suppose not.
Let âŸ¨piâŸ©iâˆˆI be an uncountable antichain in P.
By the
âˆ†-system lemma, we may pass to a subfamily such that âŸ¨dom(pi)âŸ©iâˆˆI is a âˆ†-
system. Say dom(pi)âˆ©dom(pj) = D for all i, j âˆˆI, i Ì¸= j. There are only ï¬nitely
112

many functions from D into {0, 1}, so by passing to an uncountable subfamily
we may assume that piâ†¾D = pjâ†¾D for all i, j âˆˆI. Then for all i, j âˆˆI we have
that pi âˆªpj is a function, hence pi and pj are compatible, a contradiction.
Theorem 5.6.9. Let M be a countable transitive model of ZFC. Let Îº be an
uncountable cardinal of M. Then there exists a countable transitive model M â€²
of ZFC extending M such that (1) M â€² satisï¬es 2â„µ0 â‰¥Îº, and (2) M â€² has the
same ordinals and cardinals as M.
Proof. Let P be the set of ï¬nite partial functions from Îº Ã— Ï‰ into {0, 1}. Let
G be an M-generic ï¬lter on P. By Lemma 5.5.7 and Theorem 5.5.8, M[G] is a
countable transitive model of ZFC which includes M and has the same ordinals
as M. By Lemma 5.6.8 P is c.c.c. By Lemma 5.6.5 M[G] has the same cardinals
as M.
Put g = S G. As in the proof of Theorem 5.5.20 we see that g âˆˆM[G] and
g : Îº Ã— Ï‰ â†’{0, 1}. For Î± < Îº deï¬ne gÎ± : Ï‰ â†’{0, 1} by gÎ±(n) = g((Î±, n)). We
claim that gÎ± Ì¸= gÎ² for all Î± < Î² < Îº. To see this, let DÎ±Î² be the set of p âˆˆP
such that p((Î±, n)) Ì¸= p((Î², n)) for some n âˆˆÏ‰ such that (Î±, n), (Î², n) âˆˆdom(p).
Clearly DÎ±Î² âˆˆM and is dense open. Hence G âˆ©DÎ±Î² Ì¸= âˆ…. Hence gÎ± Ì¸= gÎ².
It is now clear that M[G] |= 2â„µ0 â‰¥Ë™Îº. Thus we may take M â€² = M[G].
113

Chapter 6
Topics in Set Theory
6.1
Stationary Sets
Deï¬nition 6.1.1. Let S be a set of ordinals. We say that S is unbounded in a
limit ordinal Î´ if sup(S âˆ©Î´) = Î´. We say that S is closed in Îº if S âŠ†Îº and, for
all limit ordinals Î´ < Îº, if S is unbounded in Î´ then Î´ âˆˆS. A closed unbounded
set in Îº (sometimes called a club of Îº) is any subset of Îº which is closed in Îº
and unbounded in Îº.
Lemma 6.1.2. Let Îº be a regular uncountable cardinal.
1. If Ci, i âˆˆI, is a collection of closed unbounded sets in Îº, and if |I| < Îº,
then T
iâˆˆI Ci is again a closed unbounded set in Îº.
2. If CÎ±, Î± < Îº is a collection of closed unbounded sets in Îº indexed by the
ordinals less than Îº, then the diagonal intersection
â–³Î±<ÎºCÎ± = {Î² < Îº | Î² âˆˆCÎ± for all Î± < Î²}
is again a closed unbounded set in Îº.
Proof. Straightforward.
Deï¬nition 6.1.3. Let Îº be a regular uncountable cardinal. A set S âŠ†Îº is said
to be stationary in Îº if S âˆ©C Ì¸= âˆ…for every closed unbounded set C in Îº.
Lemma 6.1.4. Let Îº be a regular uncountable cardinal, and let S âŠ†Îº be
stationary in Îº. Suppose S = S
iâˆˆI Si where |I| < Îº. Then Si is stationary for
some i âˆˆI.
Proof. Suppose the conclusion fails. Then for each i âˆˆI let Ci be a closed
unbounded set such that Si âˆ©Ci = âˆ…. By Lemma 6.1.2.1, C = T
iâˆˆI Ci is a
closed unbounded set. Since S is stationary, S âˆ©C is nonempty, say Î± âˆˆS âˆ©C.
Then for each i âˆˆI we have Î± /âˆˆSi, a contradiction.
114

Theorem 6.1.5 (Fodorâ€™s Theorem). Let Îº be a regular uncountable cardinal,
and let S âŠ†Îº be stationary in Îº. Suppose f : S â†’Îº is such that f(Î±) < Î± for
all Î± âˆˆS. Then f is constant on a stationary set. In other words, there exist a
stationary S0 âŠ†S and a Î²0 < Îº such that f(Î±) = Î²0 for all Î± âˆˆS0.
Proof. Similar to the proof of the previous lemma, using 6.1.2.2 instead of
6.1.2.1. The details are left as an exercise for the reader.
Theorem 6.1.6. For any regular uncountable cardinal Îº, there exists a sta-
tionary set S âŠ†Îº such that Îº \ S is also stationary.
Proof. . . .
We state without proof the following theorem of Solovay.
Theorem 6.1.7. Let Îº be a regular uncountable cardinal. Any stationary set
S âŠ†Îº can be decomposed into Îº pairwise disjoint stationary sets.
6.2
Large Cardinals
Deï¬nition 6.2.1 (hyperinaccessible cardinals). For each n < Ï‰ we deï¬ne a
class of cardinals called the n-hyperinaccessible cardinals. We deï¬ne Îº to be 0-
hyperinaccessible if it is inaccessible. We deï¬ne Îº to be n+1-hyperinaccessible
if it is inaccessible and
{Î» < Îº | Î» is n-hyperinaccessible}
is unbounded in Îº.
Deï¬nition 6.2.2 (Mahlo cardinals). For each n < Ï‰ we deï¬ne a class of cardi-
nals called the n-Mahlo cardinals. We deï¬ne Îº to be 0-Mahlo if it is inaccessible.
We deï¬ne Îº to be n+1-Mahlo if it is inaccessible and {Î» < Îº | Î» is n-Mahlo} is
stationary in Îº.
Exercise 6.2.3. Show that n+1-hyperinaccessible implies n-hyperinaccessible.
Show that n+1-Mahlo implies n-Mahlo. Show that 1-Mahlo implies n-hyperinaccessible
for all n < Ï‰.
Lemma 6.2.4. Let Î´ be a limit ordinal. Suppose Îº < Î´ and n < Ï‰. Then Îº is
n-hyperinaccessible if and only if RÎ´ satisï¬es â€œÎº is n-hyperinaccessible.â€ Also,
Îº is n-Mahlo if and only if RÎ´ satisï¬es â€œÎº is n-Mahlo.â€
Proof. Straightforward.
Theorem 6.2.5.
1. The existence of an n+1-hyperinaccessible cardinal is not provable in ZFC
+ â€œfor all Î± there exists Îº > Î± such that Îº is n-hyperinaccessibleâ€ (as-
suming this theory is consistent).
115

2. The existence of an n+1-Mahlo cardinal is not provable in ZFC + â€œfor
all Î± there exists Îº > Î± such that Îº is n-Mahloâ€ (assuming this theory is
consistent).
Proof. Straightforward using the previous lemma.
Lemma 6.2.6.
1. If Îº is a cardinal, then L satisï¬es â€œÎº is a cardinal.â€
2. If Îº is a regular cardinal, then L satisï¬es â€œÎº is a regular cardinal.â€
3. If Îº is n-hyperinaccessible, then L satisï¬es â€œÎº is n-hyperinaccessible.â€
4. If Îº is n-Mahlo, then L satisï¬es â€œÎº is n-Mahlo.â€
Proof. Straightforward.
Theorem 6.2.7.
1. If ZFC + â€œthere exists an n-hyperinaccessible cardinalâ€ is consistent, then
so is ZFC + V = L + â€œthere exists an n-hyperinaccessible cardinal.â€
2. If ZFC + â€œthere exists an n-Mahlo cardinalâ€ is consistent, then so is ZFC
+ V = L + â€œthere exists an n-Mahlo cardinal.â€
Proof. Straightforward using the previous lemma.
6.3
Ultraï¬lters and Ultraproducts
Deï¬nition 6.3.1. Let I be a nonempty set. A ï¬lter on I is a set F âŠ†P(I)
such that
1. âˆ…/âˆˆF and I âˆˆF;
2. if X1, . . . , Xn âˆˆF then X1 âˆ©. . . âˆ©Xn âˆˆF;
3. if X âˆˆF and X âŠ†Y âˆˆP(I) then Y âˆˆF.
Examples 6.3.2.
1. F = {I}.
2. F = {X âŠ†I | X âŠ‡X0}, where âˆ…Ì¸= X0 âŠ†I. Such an F is called a
principal ï¬lter.
3. F = {X âŠ†I | X is coï¬nite, i.e., I \ X is ï¬nite} (assuming I is inï¬nite).
4. F = {X âŠ†I | |I \ X| < Îº}, where Îº is any inï¬nite cardinal â‰¤|I|.
5. I = Rn, F = {X âŠ†Rn | Rn \ X has Lebesgue measure 0}. Here we could
replace Rn by any measure space.
116

6. I = Rn, F = {X âŠ†Rn | Rn \ X is meager}. Here we could replace Rn by
any complete metric space.
7. Let I = Îº where Îº is a regular uncountable cardinal. Then
F = {X âŠ†Îº | X âŠ‡C for some closed unbounded set C âŠ†Îº}
is a ï¬lter, known as the closed unbounded ï¬lter on Îº.
8. Let A be an uncountable set. Put
I = Pc(A) = {Y âŠ†A | Y is countable} .
Recall that A<Ï‰ is the set of ï¬nite sequences of elements of A. Given
f : A<Ï‰ â†’A, put
Cf = {Y âˆˆPc(A) | Y is closed under f, i.e., f[Y <Ï‰] âŠ†Y } .
Then
Fc(A) = {X âŠ†Pc(A) | X âŠ‡Cf for some f}
is a ï¬lter known as the closed unbounded ï¬lter on Pc(A).
Deï¬nition 6.3.3. Let Îº be an inï¬nite cardinal. A ï¬lter F is said to be Îº-
additive if T
iâˆˆI Xi âˆˆF whenever Xi âˆˆF for all i âˆˆI, |I| < Îº.
Examples 6.3.4.
1. Every ï¬lter is ï¬nitely additive, i.e., â„µ0-additive.
2. The Lebesgue and Baire ï¬lters on Rn are countably additive, i.e., â„µ1-
additive.
3. For any inï¬nite cardinal Îº â‰¤|I|, the ï¬lter {X âŠ†I | |I âˆ’X| < Îº} is
Îº-additive.
4. For any regular uncountable cardinal Îº, the closed unbounded ï¬lter on Îº
is Îº-additive.
5. For any uncountable set A, the closed unbounded ï¬lter on Pc(A) is count-
ably additive.
Deï¬nition 6.3.5. An ultraï¬lter on I is a ï¬lter U on I such that for all X âŠ†I
either X âˆˆU or I \ X âˆˆU.
Remark 6.3.6. The ï¬lters in 6.3.2.3â€“8 are not ultraï¬lters. Indeed, it is diï¬ƒ-
cult to ï¬nd explicit examples of nonprincipal ultraï¬lters. However, as we shall
now show, nonprincipal ultraï¬lters can be constructed by means of transï¬nite
recursion plus the Axiom of Choice.
Theorem 6.3.7. Any ï¬lter F on I can be extended to an ultraï¬lter U on I.
117

Proof. Say that G âŠ†P(I) has the ï¬nite intersection property (f.i.p.) if Y1 âˆ©. . .âˆ©
Ym Ì¸= âˆ…for all Y1, . . . , Ym âˆˆG.
By the well-ordering theorem, let Îº = |P(I)|, say
P(I) = {XÎ± | Î± < Îº} .
We shall use transï¬nite recursion to deï¬ne a sequence of sets FÎ± âŠ†P(I), Î± â‰¤Îº,
each of which has the f.i.p.
Stage 0. Put F0 = F. Note that F has the f.i.p. since it is a ï¬lter.
Stage Î± + 1.
Assume inductively that FÎ± has the f.i.p.
We claim that
at least one of FÎ± âˆª{XÎ±}, FÎ± âˆª{I \ XÎ±} has the f.i.p. Otherwise we would
have XÎ± âˆ©Y1 âˆ©. . . âˆ©Ym = âˆ…, Y1, . . . , Ym âˆˆFÎ±, (I \ XÎ±) âˆ©Z1 âˆ©. . . âˆ©Zm = âˆ…,
Z1, . . . , Zn âˆˆFÎ±. Then Y1 âˆ©. . . âˆ©Ym âˆ©Z1 âˆ©. . . âˆ©Zn = âˆ…so FÎ± does not have
the f.i.p., a contradiction. We therefore set
FÎ±+1 =
(
FÎ± âˆª{XÎ±}
if this has the f.i.p.,
FÎ± âˆª{I \ XÎ±}
otherwise.
Then clearly FÎ±+1 has the f.i.p.
Stage Î´, where Î´ is a limit ordinal. Put FÎ´ = S
Î±<Î´ FÎ±. Clearly this has the
f.i.p.
Finally put U = FÎº = S
Î±<Îº FÎ±.
Clearly U has the f.i.p. and for every
X âˆˆP(I) either X âˆˆU or I \ X âˆˆU. It follows easily that U is an ultraï¬lter.
This completes the proof.
Lemma 6.3.8. Any principal ultraï¬lter U on I is of the form
U = {X âŠ†I | i0 âˆˆX}
for some ï¬xed i0 âˆˆI.
Proof. Let U be a principal ultraï¬lter on I. By deï¬nition we have
U = {X âŠ†I | X âŠ‡X0}
where âˆ…Ì¸= X0 âŠ†I. If |X0| â‰¥2, let Y âŠ†I be such that Y âˆ©X0 Ì¸= âˆ…and
(I \ Y ) âˆ©X0 Ì¸= âˆ…. Then Y, I \ Y /âˆˆU, a contradiction. Thus |X0| = 1, i.e.,
X0 = {i0} for some i0 âˆˆI. This proves the lemma.
Theorem 6.3.9. For every inï¬nite set I there exists a nonprincipal ultraï¬lter
U on I.
Proof. Consider the ï¬lter F = {X âŠ†I | I\X is ï¬nite}. By Theorem 6.3.7, let U
be an ultraï¬lter on I such that F âŠ†U. For all i0 âˆˆI we have I \ {i0} âˆˆF âŠ†U,
hence {i0} /âˆˆU. Thus U is nonprincipal.
Deï¬nition 6.3.10. A structure is a relational structure, i.e., an ordered pair
(A, E) where A is a nonempty set and E âŠ†A Ã— A.
118

Deï¬nition 6.3.11 (ultraproduct). Suppose we are given an indexed family of
structures âŸ¨(Ai, Ei)âŸ©iâˆˆI and an ultraï¬lter U on the index set I. We are going to
deï¬ne a structure
(A, E) =
Y
U
âŸ¨(Ai, Ei)âŸ©iâˆˆI
known as an ultraproduct. Recall that
Y
iâˆˆI
Ai =
(
f
 f : I â†’
[
iâˆˆI
Ai, f(i) âˆˆAi for all i âˆˆI
)
.
For f, g âˆˆQ
iâˆˆI Ai deï¬ne
f â‰ˆg
â‡”def
f â‰ˆU g
â‡”def
{i âˆˆI | f(i) = g(i)} âˆˆU .
This is an equivalence relation. We deï¬ne
[f] =def [f]U =def
(
g âˆˆ
Y
iâˆˆI
Ai
 f â‰ˆU g
)
and
A =
Y
U
âŸ¨AiâŸ©iâˆˆI =
Y
iâˆˆI
Ai

U =
(
[f]U
 f âˆˆ
Y
iâˆˆI
Ai
)
.
Finally, for f, g âˆˆQ
iâˆˆI Ai, we deï¬ne
([f], [g]) âˆˆE â‡”def {i âˆˆI | (f(i), g(i)) âˆˆEi} âˆˆU .
Note that this last deï¬nition is independent of representatives, i.e., f â‰ˆf â€²,
g â‰ˆgâ€², ([f], [g]) âˆˆE imply ([f â€²], [gâ€²]) âˆˆE. Thus E âŠ†A Ã— A is well-deï¬ned, and
so (A, E) is a structure.
Theorem 6.3.12 ( LoÂ´sâ€™s Theorem). Let (A, E) = Q
UâŸ¨(Ai, Ei)âŸ©iâˆˆI be an ultra-
product. Let Ïˆ(x1, . . . , xk) be a formula with free variables among x1, . . . , xk.
Then for all [f1], . . . , [fk] âˆˆA we have
|=(A,E) Ïˆ([f1], . . . , [fk]) â‡”{i âˆˆI | |=(Ai,Ei) Ïˆ(f1(i), . . . , fk(i))} âˆˆU .
6.4
Measurable Cardinals
6.5
Ramseyâ€™s Theorem
119

Index
RÎ±, 87
âˆ†0
n predicate, 44
Î 0
n predicate, 41
Î£0
n predicate, 41
â„µÎ±, 84
â†“, 23
Îº-additive, 117
Ï‰, 75
Ï‰Î±, 84
â‰ƒ, 23
â†‘, 23
 LoÂ´sâ€™s theorem, 119
Ackermann function, 13, 25, 30, 33, 39
additive, 117
additively indecomposable ordinal, 80
arithmetic, 48
cardinal, 73
language of, 48
ordinal, 75, 79, 80
arithmetical deï¬nability, 50â€“56, 59
arithmetical hierarchy, 41â€“47, 56
arithmetical truth, 58, 59
axioms
of set theory, 92â€“96
axiom of choice, 94, 97, 101, 106
axiom of inï¬nity, 94
axiom scheme, 95
Boolean connective, 9, 49
bounded
least number operator, 10
quantiï¬er, 10
Cantorâ€™s theorem, 73
cardinal
hyperinaccessible, 115
inaccessible, 86
limit, 85
Mahlo, 115
regular, 85
singular, 86
strong limit, 85
successor, 85
uncountable, 85
weakly inaccessible, 86
cardinal arithmetic, 73
cardinal number, 71â€“74, 81â€“86
cases
deï¬nition by, 28, 63
Cauchy sequence, 90
CH, 85, 97
characteristic function, 9
Chinese remainder theorem, 53
Churchâ€™s thesis, 33
class, 78
closed, 114
closed unbounded ï¬lter, 117
club, 114
coï¬nality, 86
complete, 46
comprehension, 95, 101
computable function, 17â€“23
connective
Boolean, 9, 49
propositional, 49
consequence
logical, 97
consistency, 97
relative, 107
constructible set, 103â€“107
Continuum Hypothesis, 85
continuum hypothesis, 85, 97, 106
Continuum Problem, 85
120

continuum problem, 85, 97
convergent, 23
countably additive, 117
course-of-values recursion, 12
decidability, 67
Def, 98
deï¬nability
arithmetical, 50â€“56, 59
over the real number system, 60
over a relational structure, 98
over the real number system, 66
deï¬ned, 23
deï¬nition by cases, 28, 63
dense open set, 107
diagonal intersection, 114
divergent, 23
eï¬€ective function, 61
enumeration theorem, 28
equivalence relation, 90
extensionality, 92, 94, 97, 100
f.i.p., 118
falsity, 49
ï¬lter, 107, 116
closed unbounded, 117
principal, 116
ï¬nitely additive, 117
ï¬nite intersection property, 118
Fodorâ€™s theorem, 115
forcing, 108
formula, 48, 60, 92
function, 89
computable, 17â€“23
eï¬€ective, 61
limit-recursive, 44
number-theoretic, 6
partial, 23
partial recursive, 23
primitive recursive, 6â€“13, 30
recursive, 23
total, 23
GÂ¨odel number
of a formula, 57
of a program, 26, 27
GCH, 85, 107
generalized continuum hypothesis, 85,
106
halting problem, 35, 37
Hilbertâ€™s 10th problem, 35
Hilbertâ€™s 17th problem, 61
hyperinaccessible cardinal, 115
inaccessible cardinal, 86, 101â€“103
index
of a partial recursive function, 26,
27
induction
transï¬nite, 78
initial ordinal, 82
isomorphism, 74
KÂ¨onigâ€™s Theorem, 74
L, 103, 106
LÂ¨owenheim/Skolem theorem, 99
language
of arithmetic, 48
of ordered rings, 60
of set theory, 92â€“96
least number operator, 23
bounded, 10
limit-recursive function, 44
limit cardinal, 85
limit ordinal, 80
linear ordering, 75
logical consequence, 97
Mahlo cardinal, 115
minimization, 24, 30
model, 97
number
cardinal, 71â€“74, 81â€“86
ordinal, 75, 89
number systems, 90
ordered ï¬eld, 60
ordered pair, 70, 89
ordering
121

linear, 75
well, 75
ordinal, 75, 89
additively indecomposable, 80
initial, 82
limit, 80
successor, 80
von Neumann, 89
ordinal arithmetic, 75, 79, 80
ordinal number, 75, 89
parameter, 98
parametrization theorem, 36
partial function, 23
partial recursive function, 23, 32
power set, 93, 101
predicate, 9
primitive recursive
function, 6â€“13, 30
predicate, 9
principal ï¬lter, 116
principal function, 43
program, 17
propositional connective, 49
pure set, 87, 92, 93, 96, 97, 102, 104
quantiï¬er, 49
bounded, 10
quantiï¬er elimination, 60, 66
real number system, 60, 90
real world, 92, 93, 97
recursion
course-of-values, 12
primitive, 6
transï¬nite, 78
recursion theorem, 39
recursively enumerable set, 44
recursive function, 23
reducible, 36
register machine program, 17
regular cardinal, 85
relational structure, 74, 96
relative consistency, 107
replacement, 95, 101
Riceâ€™s theorem, 38
scheme, 95
sentence, 49
set theory
axioms of, 92â€“96
language of, 92â€“96
models of, 93, 96, 97, 99â€“104
singular cardinal, 86
Skolem paradox, 99
Solovay, 115
state, 29
stationary, 114
strong limit cardinal, 85
structure
arithmetic, 48
real number system, 60
relational, 74, 96
successor cardinal, 85
successor ordinal, 80
term, 48
total function, 23
transï¬nite induction, 78
transï¬nite recursion, 78
transitive model, 99â€“103
transitive set, 87, 99
truth
arithmetical, 49, 58, 59
ultraï¬lter, 117
ultraproduct, 119
unbounded, 114
uncountable cardinal, 85
undecidability, 58
undeï¬ned, 23
universal
Î£0
n predicate, 45
register machine program, 28
unsolvable problem, 34â€“39, 58
V , 88
von Neumann ordinal, 89
weakly inaccessible cardinal, 86
well-founded, 75
well-ordering, 75
well-ordering theorem, 81
122

word problem, 35
Zermelo/Fraenkel set theory, 96
ZF, 96
ZFC, 96
123

