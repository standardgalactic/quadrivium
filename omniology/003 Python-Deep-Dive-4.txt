Copyright © MathByte Academy

Course philosophy
the Python language
the standard library
idiomatic Python
becoming an expert Python developer
obtaining a deeper understanding of the Python language
and the standard library
this is NOT an introductory course
à refer to prerequisites video or course description
à canonical CPython 3.6+ implementation
this is NOT cookbook course
Copyright © MathByte Academy

Course Topics
focused on Object Oriented Programming (OOP) concepts in Python
à classes (types) and objects
à single inheritance
à functions, methods and properties
à descriptors
à enumerations
à exceptions
à polymorphism and special dunder methods
Copyright © MathByte Academy

Included Course Materials
lecture videos
Jupyter notebooks
coding videos
projects, exercises and solutions
github repository for all code
https://github.com/fbaptiste/python-deepdive
PDFs of all lecture slides
Copyright © MathByte Academy

Copyright © MathByte Academy

Python 3: Deep Dive (Part 4) - Prerequisites
à assumes you are not a beginner programmer
à must have practical experience programming in Python already
à real projects, not just a bootcamp course and some isolated exercises
à this is not a cookbook course!
à does not explain how to solve specific problems
à does explain Python fundamentals
à how various concepts work and can be used
à solid understanding of basic Computer Science concepts
Copyright © MathByte Academy

Python 3: Deep Dive (Part 4) - Prerequisites
functions and function arguments
packing and unpacking iterables
my_func(*my_list)
f, *_, l = (1, 2, 3, 4, 5)
closures
decorators
nested scopes
free variables
Boolean truth values
id
lambdas
== vs is
This course assumes that you have in-depth knowledge of functional programming in Python:
zip
sorted
any
all
scopes and namespaces
à itertools module
Copyright © MathByte Academy

Python 3: Deep Dive (Part 4) - Prerequisites
This course assumes that you have in-depth knowledge of:
sequences
iterables
iterators
comprehensions
context managers
importing modules and symbols
mapping types
à dictionaries
sets
collections module
object equality and hashing
à yield  __iter__  __next__  __getitem__
generators
à list, dictionary, set, generator exp
à relation to functions and closures
Copyright © MathByte Academy

Python 3: Deep Dive (Part 4) - Prerequisites
You should have some basic exposure to creating and using classes in Python
class Person:
def __init__(self, name, age):
self.name = name
self._age = age
@property
def age(self):
return self._age
def __eq__(self, other):
return isinstance(other, Person) and self.name == other.name
def __hash__(self):
return hash(self.name)
def __lt__(self, other):
…
Copyright © MathByte Academy

Python 3: Deep Dive (Part 4) - Prerequisites
Most code examples are provided using Jupyter Notebooks
Freely available
https://jupyter.org/
GitHub and git
https://github.com/fbaptiste/python-deepdive
à know how to work with Python virtual environments
à pip install
Copyright © MathByte Academy

Copyright © MathByte Academy

à what are objects in general
à what are classes
à instantiating and initializing objects from a class
à class and instance attributes
à functions
à function bindings and methods
à properties
à instance methods
à class methods
à static methods
à data
Copyright © MathByte Academy

Copyright © MathByte Academy

What is an object?
a container
contains data
contains functionality
à state
à behavior
à attributes
à methods
my_car
brand = Ferrari
model = 599XX
year = 2010
state
accelerate
brake
steer
behavior
dot notation
my_car.brand à Ferrari
my_car.purchase_price = 1_600_000
my_car.accelerate(10)
my_car.steer(-15)
Copyright © MathByte Academy

Creating objects
How do we create the "container"?
How do we define and set state?
How do we define and implement behavior?
Many languages use a class-based approach
à C++, Java, Python, etc
A class is like a template used to create objects
à also called a type
à objects created from that class are called instances
of that class or type
Copyright © MathByte Academy

Classes
Classes are themselves objects
They have attributes (state)
à e.g. class name (or type name)
They have behavior
à e.g. how to create an instance of the class
if a class is an object, and objects are created from classes, how are classes created?
Python à classes are created from the type metaclass
Copyright © MathByte Academy

Instances
Classes have behavior
à they are callable
MyClass()
à this returns an instance of the class
à often called objects, differentiating from class
(even though a class is technically an object as well)
Instances are created from classes
their type is the class they were created from
if MyClass is a class in Python
and my_obj is an instance of that class
my_obj = MyClass()
type(my_obj) à MyClass
this is an object
(classes are objects)
isinstance(my_obj, MyClass)
à True
Copyright © MathByte Academy

Creating Classes
use the class keyword
class MyClass:
pass
à Python creates an object
à called MyClass
à of type type
à automatically provides us certain attributes (state) and methods (behavior)
MyClass.__name__
à 'MyClass'
string
MyClass()
à returns an instance of MyClass
(state)
(behavior)
type(MyClass) à type
isinstance(MyClass, type) à True
Copyright © MathByte Academy

Copyright © MathByte Academy

Defining Attributes in Classes
class MyClass:
language = 'Python'
version = '3.6'
MyClass is a class à it is an object
in addition to whatever attributes Python automatically creates for us
à it also has language and version attributes
e.g. __name__ with a state of 'MyClass'
with a state of 'Python' and '3.6' respectively
(of type type)
Copyright © MathByte Academy

Retrieving Attribute Values from Objects
class MyClass:
language = 'Python'
version = '3.6'
à getattr function
getattr(object_symbol, attribute_name, optional_default)
getattr(MyClass, 'language')
à 'Python'
getattr(MyClass, 'x')
à AttributeError exception
getattr(MyClass, 'x', 'N/A')
à 'N/A'
à dot notation (shorthand)
MyClass.language
à 'Python'
MyClass.x
à AttributeError exception
Copyright © MathByte Academy

Setting Attribute Values in Objects
class MyClass:
language = 'Python'
version = '3.6'
à setattr function
setattr(object_symbol, attribute_name, attribute_value)
setattr(MyClass, 'version', '3.7')
object symbol
string
this has modified the state of  MyClass
à MyClass was mutated
getattr(MyClass, 'version')
MyClass.version
à '3.7'
MyClass.version = '3.7'
Copyright © MathByte Academy

Setting Attribute Values in Objects
class MyClass:
language = 'Python'
version = '3.6'
What happens if we call setattr for an attribute we did not define in our class?
Python is a dynamic language
à can modify our classes at runtime (usually)
setattr(MyClass, 'x', 100)
à MyClass now has a new attribute named x with a state of 100
getattr(MyClass, 'x')
MyClass.x
à 100
MyClass.x = 100
or
Copyright © MathByte Academy

Where is the state stored?
à in a dictionary
class MyClass:
language = 'Python'
version = '3.6'
MyClass.__dict__
mappingproxy({'__module__': '__main__',
'language': 'Python',
'version': '3.6',
'__dict__': <attribute '__dict__' of 'MyClass' objects>,
'__weakref__': <attribute '__weakref__' of 'MyClass' objects>,
'__doc__': None})
à not directly mutable dictionary (but setattr can)
à ensures keys are strings (helps speed things up for Python)
class namespace
Copyright © MathByte Academy

Mutating Attributes
We saw we can modify the sate or create a brand new attribute using setattr or the dot notation
class MyClass:
language = 'Python'
version = '3.6'
MyClass.__dict__
à mappingproxy({'language': 'Python',
'version': '3.6', …})
setattr(MyClass, 'x', 100)
MyClass.x = 100
or
MyClass.__dict__
à mappingproxy({'language': 'Python',
'version': '3.6', 
'x': 100, …})
We can then mutate MyClass:
And this is reflected in the namespace:
Copyright © MathByte Academy

Yes! (usually)
à delattr(obj_symbol, attribute_name)
Deleting Attributes
So if we can mutate the namespace at runtime by using setattr (or equivalent dot notation)
Can we remove an attribute at runtime?
or del keyword
class MyClass:
language = 'Python'
version = '3.6'
MyClass.__dict__
à mappingproxy({'language': 'Python',
'version': '3.6', …})
delattr(MyClass, 'version') 
del MyClass.version
or
MyClass.__dict__
à mappingproxy({'language': 'Python',
…})
à version has been removed from namespace
Copyright © MathByte Academy

Accessing the Namespace Directly
As we saw the class namespace uses a dictionary, which we can request using the __dict__ 
attribute of the class
The __dict__ attribute of a class returns a mappingproxy object
Although this is not a dict, it is still a hash map (dictionary), so we can at least read access the 
class namespace directly – not common practice!!
class MyClass:
language = 'Python'
version = '3.6'
MyClass.language
getattr(MyClass, 'language')
MyClass.__dict__['language']
à 'Python'
Be careful with this – sometimes classes have attributes that don't show up in that dictionary!
(we'll come back to that later)
Copyright © MathByte Academy

Copyright © MathByte Academy

Setting an Attribute Value to a Callable
Attribute values can be any object
à other classes
à any callable
à anything…
So we can do this:
class MyClass:
language = 'Python'
def say_hello():
print('Hello World!')
say_hello is also an attribute of the class
à its value happens to be a callable
mappingproxy({'language': 'Python',
'say_hello': <function __main__.MyClass.say_hello()>, ...})
MyClass.__dict__ à
Copyright © MathByte Academy

How do we call it?
We could get it straight from the namespace dictionary:
my_func = MyClass.__dict__['say_hello']
my_func()
à 'Hello World!'
or we could use getattr:
MyClass.__dict__['say_hello']()
à 'Hello World!'
getattr(MyClass, 'say_hello')()
à 'Hello World!'
or we can use dot notation:
MyClass.say_hello()
à 'Hello World!'
Copyright © MathByte Academy

Copyright © MathByte Academy

Classes are Callable
When we create a class using the class keyword
Python automatically adds behaviors to the class
in particular:
à it adds something to make the class callable
à the return value of that callable is an object
à the type of that object is the class object
we say the object is an instance of 
the class
my_obj = MyClass()
type(my_obj) à MyClass
isinstance(my_obj, MyClass)
à True
also called class instantiation
or instantiating the class
Copyright © MathByte Academy

Instantiating Classes
When we call a class, a class instance object is created
This class instance object has its own namespace
à distinct from the namespace of the class that was used to create the object
This object has some attributes Python automatically implements for us:
à __class__ tells us which class was used to instantiate the object
à __dict__ is the object's local namespace
à prefer using type(obj) instead of obj.__class__
Copyright © MathByte Academy

Copyright © MathByte Academy

Data Attributes, Classes and Instances
Let's focus on data attributes first (i.e. not functions)
class MyClass:
language = 'Python'
my_obj = MyClass()
MyClass.__dict__
à {'language': 'Python'}
my_obj.__dict__
à {}
MyClass.language
à Python starts looking for language attribute in MyClass namespace
à MyClass.language à 'Python'
my_obj.language
à Python starts looking in my_obj namespace
à if it finds it, returns it
à if not, it looks in the type (class) of my_obj, i.e. MyClass
à 'Python'
Copyright © MathByte Academy

Data Attributes, Classes and Instances
class MyClass:
language = 'Python'
my_obj = MyClass()
MyClass.language à 'Python'
my_obj.__dict__ à {}
my_obj.language = 'java'
my_obj.__dict__ à {'language': 'java'}
my_obj.language à 'java'
MyClass.language à 'Python'
other_obj = MyClass()
other_obj.__dict__ = {}
other_obj.language à 'Python'
class attribute
instance attribute
Copyright © MathByte Academy

Copyright © MathByte Academy

Function Attributes, Classes and Instances
What happens when attributes are functions is different!
class MyClass:
def say_hello():
print('Hello World!')
my_obj = MyClass()
MyClass.say_hello
<function __main__.MyClass.say_hello()>
<bound method MyClass.say_hello of <__main__.MyClass
object at 0x10383f860>>
my_obj.say_hello
Same with getattr:
getattr(my_obj, 'say_hello')
<bound method MyClass.say_hello of <__main__.MyClass
object at 0x10383f860>>
MyClass.say_hello() à 'Hello World!'
my_obj.say_hello() à TypeError
say_hello() takes 0 positional 
arguments but 1 was given
bound?
method?
Copyright © MathByte Academy

Methods
method is an actual object type in Python
like a function, it is callable
but unlike a function if is bound to some object
and that object is passed to the method as its first parameter
my_obj.say_hello()
à say_hello is a method object
à it is bound to my_obj
à when my_obj.say_hello is called, the bound object my_obj is 
injected as the first parameter to the method say_hello
so it's essentially calling this:
MyClass.say_hello(my_obj)
One advantage of this is that say_hello now has a handle to the object's 
namespace!
à the object it is bound to
à but there's more to it than just calling the function this way – method object
Copyright © MathByte Academy

à instance
à function
Methods
Methods are objects that combine:
__self__
__func__
à the instance the method is bound to
à the original function (defined in the class)
calling obj.method(args)
à method.__func__(method.__self__, args)
(of some class)
à like any object it has attributes
class Person:
def hello(self):
pass
p = Person()
p.hello.__self__
p.hello.__func__
Copyright © MathByte Academy

Instance Methods
This means we have to account for that "extra" argument when we define functions in our 
classes – otherwise we cannot use them as methods bound to our instances
These functions are usually called instance methods
class MyClass:
def say_hello(obj):
print('Hello World!')
we often call this an instance method
but not actually a method object yet!
at this point it's just a regular function
my_obj = MyClass()
my_obj.say_hello
now it's a method
and is bound to my_obj, an instance of MyClass
instance method
first param will receive instance object
my_obj.say_hello()
à 'Hello World!'
à MyClass.say_hello(my_obj)
Copyright © MathByte Academy

Instance Methods
Of course functions in our classes can have their own parameters
When we call the corresponding instance method with arguments à passed to the method as well
class MyClass:
language = 'Python'
def say_hello(obj, name):
return f'Hello {name}! I am {obj.language}. '
And the method still receives the instance object reference as the first argument
python = MyClass()
python.say_hello('John')
à 'Hello John! I am Python'
java = MyClass()
java.language = 'Java'
java.say_hello('John')
à 'Hello John! I am Java'
à we have access to the instance (and class) attributes!
à MyClass.say_hello(python, 'John')
à MyClass.say_hello(java, 'John')
Copyright © MathByte Academy

Copyright © MathByte Academy

Initializing Class Instances
When we instantiate a class, by default Python does two separate things:
à creates a new instance of the class
à initializes the namespace of the class
class MyClass:
language = 'Python'
obj = MyClass()
obj.__dict__ à {}
We can provide a custom initializer method that Python will use instead of its own:
class MyClass:
language = 'Python'
def __init__(obj, version):
obj.version = version
notice that __init__ is defined to 
work as a bound instance method
Copyright © MathByte Academy

Deconstructing  this…
class MyClass:
language = 'Python'
def __init__(obj, version):
obj.version = version
language is a class attribute
à in class namespace
__init__ is a class attribute
à in class namespace
(as a function)
when we call MyClass('3.7')
à Python creates a new instance of the object with an empty namespace
à if we have defined an __init__ function in the class
à it calls obj.__init__('3.7')
à bound method
à MyClass.__init__(obj, '3.7')
à our function runs and adds version to obj's namespace
à version is an instance attribute
obj.__dict__ à {'version': '3.7'} 
a standard convention is to use an argument named self
self (convention)
Copyright © MathByte Academy

Important!
By the time __init__ is called
Python has already created the object and a namespace for it (like a __dict__ in most cases)
then __init__ is called as a method bound to the newly created instance
We can actually also specify a custom function to create the object
__new__
we'll come back to this later
But __init__ is not creating the object, it is only running some code after the 
instance has been created
Copyright © MathByte Academy

Copyright © MathByte Academy

Instances and Setting Function Attributes at Runtime
We saw that we can add to an instance namespace directly at runtime by using setattr or the dot 
notation
class MyClass:
language = 'Python'
obj = MyClass()
obj.__dict__ à {}
obj.version = '3.7'
obj.__dict__ à {'version': '3.7'}
What happens if we create a new attribute whose value is a function?
obj.say_hello = lambda: 'Hello World!'
then
obj.say_hello
à function
not a bound method!
obj.say_hello() à 'Hello World!'
but say_hello does not have access to the instance namespace
Copyright © MathByte Academy

Can we create and bind a method to an instance at runtime?
Yes
à just need to define a method that binds the function to the instance
class MyClass:
language = 'Python'
obj = MyClass()
from types import MethodType
MethodType(function, object)
function we want to bind
the object to bind to
obj.say_hello = MethodType(lambda self: f'Hello {self.language}!', obj)
say_hello is now a method bound to obj
à only obj has been affected
à no other instances have that method
à 'Hello Python!'
Copyright © MathByte Academy

Copyright © MathByte Academy

Properties
We saw that we can define "bare" attributes in classes and instances
class MyClass:
def __init__(self, language):
self.language = language 
obj = MyClass('Python')
print(obj.language)
obj.language = 'Java'
direct access to 
language
attribute
In many languages direct access to attributes is highly discouraged
Instead the convention is to make the attribute private, and create public getter and setter methods
Although we don't have private attributes in Python, we could write it this way:
class MyClass:
def __init__(self, language):
self._language = language
def get_language(self):
return self._language
def set_language(self, value):
self._language = value 
What code would you rather write?
print(obj.language)
obj.language = 'Java'
or
print(obj.get_language())
obj.set_language('Java')
Copyright © MathByte Academy

Properties
class MyClass:
def __init__(self, language):
self._language = language
def get_language(self):
return self._language
def set_language(self, value):
self._language = value 
In this case, language is considered an instance property
But is only accessible via the get_language and 
set_language methods
There are some good reasons why we might want to approach attributes using this programming style
à provides control on how an attribute's value is set and returned
If you start with a class that provides direct access to the language attribute, and later need to 
change it to use accessor methods, you will change the interface of the class
any code that uses the attribute directly: obj.language = 'Java'
will need to be refactored to use 
the accessor methods instead:
obj.set_language('Java')
Copyright © MathByte Academy

Python has a Solution!
We can use the property class to define properties in a class:
class MyClass:
def __init__(self, language):
self.language = language
class MyClass:
def __init__(self, language):
self._language = language
def get_language(self):
return self._language
def set_language(self, value):
self._language = value
language = property(fget=get_language, fset=set_language)
m = MyClass('Python')
m.language = 'Java'
print(m.language)
m = MyClass('Python')
m.language = 'Java'
print(m.language)
à changed an attribute to a property without changing the class interface!
Copyright © MathByte Academy

The property Class
property is a class (type)
à constructor has a few parameters:
fget
fset
fdel
doc
specifies the function to use to get instance property value
specifies the function to use to set the instance property value
specifies the function to call when deleting the instance property
a string representing the docstring for the property
In general we start with plain attributes, and if later we need to change to a 
property we can easily do so using the property class without changing the 
interface
Copyright © MathByte Academy

class MyClass:
def __init__(self, language):
self._language = language
def get_language(self):
return self._language
def set_language(self, value):
self._language = value
language = property(fget=get_language, fset=set_language)
m = MyClass('Python')
m.__dict__ à {'_language': 'Python'}
m.language = 'Java'
m.__dict__ à {'_language': 'Java'}
'language' is not in m.__dict__
Remember how Python looks for attributes:
à searches instance namespace first
à but also looks in class namespace
à finds language which is a property object that has get and set accessors
à uses the accessor methods
(how? à later…)
Copyright © MathByte Academy

Copyright © MathByte Academy

The property Class
The property class can be instantiated in different ways:
x = property(fget=get_x, fset=set_x)
The class defines methods (getter, setter, deleter) that can take a callable as an argument 
and returns the instance with the appropriate method now set
Could create it this way instead:
x = property()
x = x.getter(get_x)
x = x.setter(set_x)
or
x = property(get_x)
x = x.setter(set_x)
Copyright © MathByte Academy

def MyClass:
def __init__(self, language):
self._language = language
def language(self):
return self._language
language = property(language)
remind you of decorators?
Instead we can write:
def MyClass:
def __init__(self, language):
self._language = language
@property
def language(self):
return self._language
we now have a property language
with a getter method defined
Next, we may want to define a setter method as well
Copyright © MathByte Academy

def MyClass:
def __init__(self, language):
self._language = language
@property
def language(self):
return self._language
at this point language is now a property instance
def set_language(self, value):
self._language = value
this is a setter method
which we need to assign to the 
language property
language = language.setter(set_language)
But again, we can rewrite this using the @ decorator syntax:
@language.setter
def language(self, value):
self._language = value
Copyright © MathByte Academy

If you find this a bit confusing, think of doing it this way first:
def MyClass:
def __init__(self, language):
self._language = language
@property
def language(self):
return self._language
lang_prop = language
def language(self, value):
self._language = value
language = lang_prop.setter(language)
redefine the symbol language as a method
assign the setter method to the property object
make the language symbol refer 
to the property object again
del lang_prop
delete lang_prop symbol
from namespace
store a reference to the language object
(of type property)
(setter returns the property object itself)
Copyright © MathByte Academy

To summarize, we can use decorators to create property type objects as well:
def MyClass:
def __init__(self, language):
self._language = language
@property
def language(self):
return self._language
@language.setter
def language(self, value)
self._language = value
function name defines the property instance name (symbol)
language is now a property instance (an object)
we use the setter method of the language property object
important to use the same name, 
otherwise we end up with a new 
symbol for our property!
(we'll see this in the code video)
Copyright © MathByte Academy

Copyright © MathByte Academy

"Read-Only" Properties
To create a read-only property, we just need to create a property with only the get accessor defined
à not truly read-only since underlying storage variable could be accessed directly
à useful for computed properties
class Circle:
def __init__(self, r):
self.r = r
def area(self):
return math.pi * self.r * self.r
c = Circle(1)
c.area() à 3.14…
class Circle:
def __init__(self, r):
self.r = r
@property
def area(self):
return math.pi * self.r * self.r
c = Circle(1)
c.area à 3.14…
feels more natural
since area is really a 
property of a circle
Copyright © MathByte Academy

Application: Caching Computed Properties
Using property setters is sometimes useful for controlling how other computed properties are cached
à Circle
à area is a computed property
à lazy computation – only calculate area if requested
à cache value – so if re-requested we save the computation
à but what if someone changes the radius?
à need to invalidate the cache
à control setting the radius using a property
à we are now aware when the property has been changed
Copyright © MathByte Academy

Application: Caching Computed Properties
class Circle:
def __init__(self, r):
self._r = r
self._area = None
setting _area cache to None
@property
def radius(self):
return self._r
@radius.setter
def radius(self, r):
if r < 0:
raise ValueError('Radius must be non-negative')
self._r = r
self._area = None
@property
def area(self):
if self._area is None:
self._area = math.pi * (self.radius ** 2)
return self._area
invalidate cache
calculate and cache area if not 
already cached
Copyright © MathByte Academy

Copyright © MathByte Academy

Deleting Properties
Just like we can delete attributes from an object:
c = Circle()
c.color = 'yellow'
c.color à yellow
del c.color
c.color à AttributeError
We can also support deleting properties from an instance object:
deleter argument of the property initializer
@prop_name.deleter
à generally used to perform some cleanup activity upon deletion of the property
à not used very often
Important:
calling the deleter runs code contained in the deleter method
à does not remove property from class itself
or
delattr(c, 'color')
à it just calls the deleter method
Copyright © MathByte Academy

Deleting Properties
class Circle:
def __init__(self, color):
self._color = color
def get_color(self):
return self._color
def set_color(self, value):
self._color = value
def del_color(self):
del self._color
color = property(get_color, set_color, del_color)
when this method is invoked, it will remove _color 
from the instance namespace (dictionary)
c = Color('yellow')
c.color à 'yellow'
c.__dict__ à {'_color': 'yellow'}
del c.color
c.__dict__ à {}
c.color
à AttributeError
c._color
Copyright © MathByte Academy

Deleting Properties
We can also use the decorator syntax:
class UnitCircle:
def __init__(self, color):
self._color = color
@property
def color(self):
return self._color
@color.setter
def color(self, value):
self._color = value
@color.deleter
def color(self):
del self._color
c = UnitCircle('red')
c.__dict__ à {'_color': 'red'}
del c.color
c.__dict__ à {}
c.color à AttributeError
But the property still exists à defined on class
c.color = 'blue'
c.__dict__ à {'_color': 'blue'}
c.color à 'blue'
à because getter tries to read self._color
Copyright © MathByte Academy

Copyright © MathByte Academy

The property Class
Can we define properties without using the property class?
Yes!
The property class is a convenience class, but we don't have to use it
But it is really convenient and works just fine most of the time!
Where might it fall short?
Reusability
If we want to have the same property (with same functionality) in 
many different classes, having to redefine the accessor methods 
in each of the classes can become tedious
More control
may want more control over a property's behaviors
We'll come back to this when we study data descriptors
Copyright © MathByte Academy

Another Question
We saw how to use the property class (and corresponding decorators) to define instance properties
Can we create class properties (that are bound to the class)
à like a class attribute, but using accessor methods
à Yes!
à metaclasses
Copyright © MathByte Academy

Copyright © MathByte Academy

Class Methods
When we define a function in a class
à how we call it will alter behavior
class MyClass:
def hello():
return 'Hello'
MyClass.hello à just a plain function defined in MyClass
MyClass.hello() à Hello
m = MyClass()
m.hello
à method bound to object m
m.hello() à TypeError (missing argument)
Can we create a function in a class that will always be bound to the class, and never the instance?
à instance method
à @classmethod
MyClass.fn à method bound to MyClass
m.fn à method bound to MyClass
Copyright © MathByte Academy

Class Methods
class MyClass:
def hello():
print('hello…')
def inst_hello(self):
print(f'hello from {self}')
@classmethod
def cls_hello(cls):
print(f'hello from {cls}') 
hello
inst_hello
cls_hello
MyClass
Instance
à call will fail!
regular function
regular function
method bound to class
method bound to instance
method bound to class
by default, any 
function defined in a 
class will be handled 
as a bound method 
when called from an 
instance
method bound to instance
Copyright © MathByte Academy

Static Methods
So can we define a function in a class that will never be bound to any object when called?
à Yes!
à in Python, those are called static methods
à @staticmethod
class Circle:
@staticmethod
def help():
return 'help available'
Circle.help()
à help available
c = Circle()
c.help()
à help available
type(Circle.help) à function
type(c.help) à function
Copyright © MathByte Academy

class MyClass:
def inst_hello(self):
print(f'hello from {self}')
@classmethod
def cls_hello(cls):
print(f'hello from {cls}') 
@staticmethod
def static_hello():
print('static hello')
Recap
function bound to instance when called from 
instance - will receive instance as first 
parameter
function bound to class when called from 
either the class or the instance - will receive the 
class (MyClass) as first parameter
static method is never bound to anything –
receives no extra argument no matter how it is 
called
Copyright © MathByte Academy

Why use static methods?
à cases where it makes sense for a function to live in a class
à but does not need access to either the instance or the class state
Timer
start(self)
à instance method
end(self)
à instance method
timezone
à class attribute
current_time_utc()
à static method
current_time(cls)
à class method (needs class time zone)
à allows us to modify time zone for all instances
Copyright © MathByte Academy

Copyright © MathByte Academy

Not all types are in the builtin module…
Certain types that we use commonly in Python
int
str
list
tuple
are part of the builtins
l = [1, 2, 3]
type(l) is list
à True
isinstance(l, list)
But some types are not available directly in the builtins
functions
modules
generators
list is a type
def my_func():
pass
print(type(my_func))
…
…
à 'function'
this is a string
but type(my_func)
actually returns a type (think class)
Copyright © MathByte Academy

The types Module
The function type can actually be found in the types module
import types
def my_func():
pass
type(my_func) is types.FunctionType
isinstance(my_func, types.FunctionType)
à True
Nothing fancy, just that some standard types are not 
available directly in the builtins
types.ModuleType
types.FunctionType
types.GeneratorType
…
Copyright © MathByte Academy

Copyright © MathByte Academy

Nested scopes in Class definitions
# module1.py
class Python:
kingdom = 'animalia'
phylum = 'chordata'
family = 'pythonidae'
def __init__(self, species):
self.species = species    
def say_hello(self):
return 'ssss…'
p = Python('monty')
à module has its own (global) scope
à class body has its own scope
contains Python, p
à what about the scope of functions
defined in the body of a class?
à turns out they are NOT nested inside the 
class body scope
à symbols __init__, say_hello are in the class 
body scope
contains kingdom, phylum , family , __init__
, say_hello
à but functions themselves are nested in the 
class's containing scope
(module1 in this example)
Copyright © MathByte Academy

# module1.py
class Python:
kingdom = 'animalia'
phylum = 'chordata'
family = 'pythonidae'
__init__ = callable_1
say_hello = callable_2
p = Python('monty')
Think of it this way
def callable_1(self, species):
self.species = species
def callable_2(self):
return 'ssss…'
à when Python looks for a symbol in a function, it will therefore not use the class body scope!
Copyright © MathByte Academy

In practical terms…
class Account:
COMP_FREQ = 12
APR = 0.02  # 2%
APY = (1 + APR/COMP_FREQ) ** COMP_FREQ - 1
def monthly_interest(self):
return self.balance * self.APY
def __init__(self, balance):
self.balance = balance
this works because APR and 
COMP_FREQ are symbols in the 
same (class body) namespace
this works because we used self.APY
@classmethod
def monthly_interest_2(cls, amount):
return amount * cls.APY
this works because we used cls.APY
@staticmethod
def monthly_interest_3(amount):
return amount * Account.APY
this works because we used Account.APY
def monthly_interest_3(self):
return self.amount * APY
this will fail if APY is not defined in this function's 
scope or in any enclosing scope
BEWARE: This can produce subtle bugs!
Copyright © MathByte Academy

Copyright © MathByte Academy

Recap
class Circle:
def __init__(self, r):
self._r = r
custom initializer à instance method (bound to instance)
@staticmethod
def create_unit_circle():
return Circle(1)
static method – not bound to anything
origin = (0, 0)
class attribute – Circle.origin
_r is an instance attribute
(private by convention only)
@classmethod
def set_origin(cls, x, y):
cls.origin = (x, y)
class method – bound to class
c = Circle()
à c in an instance of Circle
à can still access using c._r
Circle.set_origin(10, 10)
c2 = Circle.create_unit_circle()
à can also be called using c.set_origin(10, 10)
@property
def radius(self):
return self._r
@radius.setter
def radius(self, value):
self._r = value
instance property (radius) with getter/setter methods
def double_radius(self):
self._r *= 2
instance method – bound to instance
c.double_radius()
Copyright © MathByte Academy

Copyright © MathByte Academy

Polymorphism
the ability to define a generic type of behavior that will (potentially) behave differently when 
applied to different types
Python is very polymorphic in nature
à duck typing
if it walks like a duck and quacks like a duck then it is a duck
à e.g. when we iterate over a collection
à object just needs to supports the iterable protocol
does it matter if the collection is a list, a tuple, a dictionary, a generator?
No - only thing we care about is that it supports the iterable protocol, so we can call
iter() 
to get an iterator, that itself can be anything as long as it 
implements the iterator protocol
Copyright © MathByte Academy

Polymorphism
Similarly, operators such as +, -, *, / are polymorphic
à integer, floats, decimals, complex numbers
à lists, tuples
à custom objects
We can add support to our own classes for the + operator by implementing __add__ method
We'll come back to polymorphism in the context of inheritance later
Copyright © MathByte Academy

Special Methods
We can add support in our classes for many of Python's functionality using special methods
These are methods that start with a double underscore and end with a double underscore
Never use this naming standard for your own methods or attributes
Although you may not clash with Python's current special methods, it may in the future
No need to use __my_func__
à just use something else!
à dunder methods
Copyright © MathByte Academy

Special Methods
We've already seen many such special methods
__init__
à used during class instantiation
__enter__
__exit__
__getitem__
__setitem__
__delitem__
__len__
à implements len()
__iter__
__next__
iterables and iterators
iter() and next()
sequence types
a[i], a[i:j], del a[i]
context managers
with ctx() as obj:
__contains__
à implements in
in this section we'll study a few more
Copyright © MathByte Academy

__str__
__repr__
Copyright © MathByte Academy

__str__ vs __repr__
à both used for creating a string representation of an object
à typically __repr__ is used by developers
à try to make it so that the string could be used to recreated the object
à otherwise make it as descriptive as possible
à useful for debugging
à __str__ is used by str() and print() functions, as well as various formatting functions
à typically used for display purposes to end user, logging, etc
à if __str__ is not implemented, Python will look for __repr__ instead
à called when using the repr() function
à if neither is implemented and since all objects inherit from 
Object, will use __repr__ defined there instead
à we'll come back to this after we discuss inheritance
Copyright © MathByte Academy

Copyright © MathByte Academy

Special Methods: Arithmetic Operators
__add__
__sub__
__mul__
__truediv__
__floordiv__
__mod__
__pow__
+
-
*
/
//
%
**
à to indicate the operation is not supported, implement method 
and return NotImplemented
__matmul__
@
New in 3.5: Currently Python does not have 
this operator implemented in any type, but 
this was added for better numpy support, 
which does implement this for matrix 
multiplication. We can use too of course.
Copyright © MathByte Academy

Special Methods: Reflected Operators
Consider a + b
à Python will attempt to call a.__add__(b)
if this returns NotImplemented
Python will swap the operands and try this instead:
b.__radd__(a)
__radd__
__rsub__
__rmul__
__rtruediv__
__rfloordiv__
__rmod__
__rpow__
à we'll look at some code examples where this might be useful
AND
operands are not of the same type
Copyright © MathByte Academy

Special Methods: In-Place Operators
__iadd__
__isub__
__imul__
__itruediv__
__ifloordiv__
__imod__
__ipow__
+=
-=
*=
/=
//=
%=
**=
Copyright © MathByte Academy

Special Methods: Unary Operators, Functions
__neg__
__pos__
__abs__
-a
+a
abs(a)
Copyright © MathByte Academy

Copyright © MathByte Academy

Special Methods: Rich Comparisons
__lt__
__le__
__eq__
__ne__
__gt__
__ge__
<
<=
==
!=
>
>=
à return NotImplemented
à Python automatically uses the reflection
Reflections
__gt__
__ge__
__ne__
__eq__
__lt__
__le__
if a < b returns NotImplemented
à Python will try
b > a
Copyright © MathByte Academy

Copyright © MathByte Academy

Special Methods: Hashing and Equality
Recall that for an object to be usable in a mapping type
à key in a dictionary
à element of a set
it must be hashable
à implement __hash__
à should also implement __eq__
If __eq__ is implemented, __hash__ is implicitly set to None unless __hash__ is implemented
By default, when an override is not specified:
__hash__ uses id of object
(but only do so for immutable objects)
__eq__ uses identity comparison (is)
Copyright © MathByte Academy

Copyright © MathByte Academy

Special Methods: Boolean
Every object in Python has an associated truth (boolean) value
any non-zero number à True
False otherwise (i.e if equal to 0)
an empty collection (len() is 0) à False
True otherwise
By default, any custom object also has a truth value
à can override this by defining the __bool__ method
à if __bool__ is not defined
à must return True / False
à Python looks for __len__
0 à False, anything else will be True
à if neither present, always returns True
Copyright © MathByte Academy

Copyright © MathByte Academy

Special Methods: Callables
Any object can be made to emulate a callable by implementing a __call__ method
class Person:
def __call__(self, name):
return f'Hello {name}'
p = Person()
p('Eric')
à Eric
à p.__call__('Eric')
à useful for creating function-like objects that need to maintain state
à useful for creating decorator classes
Copyright © MathByte Academy

__del__
Copyright © MathByte Academy

A Class Finalizer
The garbage collector destroys objects that are no longer referenced anywhere
à hook into that lifecycle event
à use the __del__ method
The __del__ method will get called right before the object is destroyed by the GC
à so the GC determines when this method is called
à __del__ is sometimes called the class finalizer
(sometimes called the destructor, but not entirely accurate, since 
GC destroys the object)
Copyright © MathByte Academy

When does __del__ get called?
à that's the basic issue with the __del__ method
à we do not control when it will get called!
called only when all references to the object are gone
à have to be extremely careful with our code
à easy to inadvertently create additional references, or circular references
Copyright © MathByte Academy

Additional Issues
If __del__ contains references to global variables, or other objects
à those objects may be gone by the time __del__ is called
If an exception occurs in the __del__ method
à exception is not raised – it is silenced
à exception description is sent to stderr
à main program will not be aware something went wrong during finalization
à prefer using context managers to clean up resources
à personally I do not use __del__
Copyright © MathByte Academy

__format__
Copyright © MathByte Academy

Yet another representation…
We know we can use the format() function to precisely format certain types
à numbers, dates, etc
We can support this in our custom classes by implementing the __format__ method
à see https://docs.python.org/3/library/string.html#formatspec
format(value, format_spec)
à if format_spec is not supplied, it defaults to an empty string
à and it will instead use str(value)
(which in turn may fall back to repr)
Copyright © MathByte Academy

Implementation
Implementing our own format specification is difficult!
à beyond scope of this course
Frequently we delegate formatting back to another type that already supports it
Copyright © MathByte Academy

Copyright © MathByte Academy

Modular Arithmetic
For this project we are going to implement a special Mod class to implement some concepts in 
modular arithmetic
You can look at these resources for more information on modular arithmetic
https://en.wikipedia.org/wiki/Modular_arithmetic
https://www.khanacademy.org/computing/computer-science/cryptography#modarithmetic
but here's what we'll need for this project…
Copyright © MathByte Academy

Modular Arithmetic
Two numbers, a and b, are said to be congruent modulo n:
a = b (mod n)
if their residues are equal
à assume n is a positive integer
Example:
7 % 12 à 7
19 % 12 à 7
à 7 is congruent to 19 modulo 12
(think of a twelve hour clock for example)
à the residue of a number a modulo n, is simply a % n
à assume a and b are integers
i.e. a % n == b % n
Copyright © MathByte Academy

Project
à create a class, called Mod
à initialize with value and modulus arguments
à ensure modulus and value are both integers
à moreover, modulus should be positive
à store the value as the residue
i.e. if value = 8 and modulus = 3, store value as 2 (8 % 3)
à implement congruence for the == operator
à allow comparison of a Mod object to an int (in which case use the residue of the int)
à allow comparison of two Mod objects only if they have the same modulus
should be read-only
à ensure objects remain hashable
Copyright © MathByte Academy

Project
à provide an implementation so that int(mod_object) will return the residue
à provide a proper representation (repr)
à implement the operators: +, - *, **
à support other operand to be Mod (with same modulus only)
à support other operand to be an integer (and use the same modulus)
à always return a Mod instance
perform the +, - *, ** operations on the values (so there's nothing complicated here)
i.e. Mod(2, 3) + 16 à Mod(2 + 16, 3) à Mod(0, 3) 
à implement the corresponding in-place arithmetic operators
à implement ordering (makes sense since we are comparing residues)
à support other operand to be a Mod (with same modulus), or an integer
Copyright © MathByte Academy

Copyright © MathByte Academy

Mutiple vs Single Inheritance
Python supports multiple inheritance
àmultiple inheritance can get a bit tricky
We're going to study single inheritance first
à can inherit from more than one class
à later we'll look at multiple inheritance, and some useful use cases
à inheriting from a single class
à technically all classes inherit from the object class
à single inheritance chain
Copyright © MathByte Academy

Copyright © MathByte Academy

Inheritance
à fundamental concept in object oriented programming
à classes define properties and methods
à they can form a natural hierarchy
Shape
Polygon
Ellipse
Circle
Quadrilateral
Triangle
Rectangle
Square
Isosceles
Equilateral
IS-A relationships
characteristics (state and behavior)
à inherit
à override
à extend
(e.g. translate center pt)
(e.g. # sides in triangle)
(e.g. # sides in polygon)
Line
Copyright © MathByte Academy

single inheritance à single parent
Terminology
Student inherits from Person
Student is a subclass of Person
Student subclasses Person
Student extends Person
Student is a child of Person
Person is a parent of Student
Parent
Children
Person
-
name
-
eat()
Student
-
study()
Teacher
-
teach()
Student derives from Person
Copyright © MathByte Academy

Instances
Objects that are created from a class are called instances of that class
s1 = Student()
t1 = Teacher()
p1 = Person()
s1 is a Student
à Student inherits from Person
à s1 is a Person
à but p1 is not a Student
p1 is a Person
à s1 is not a Teacher
à but p1 is not a Teacher
Person
Student
Teacher
à s1 is an instance of Student
à s1 is an instance of Person
Copyright © MathByte Academy

à s1 is not a Teacher
s1 = Student()
t1 = Teacher()
p1 = Person()
Person
Student
Teacher
à s1 is an instance of Student
à s1 is an instance of Person
isinstance() vs type()
isinstance(s1, Student) à True
isinstance(s1, Person) à True
isinstance(s1, Teacher) à False
à p1 is not a Student
isinstance(p1, Student) à False
type(instance)
à returns the class the instance was created from
type(s1) à Student
type(t1) à Teacher
type(p1) à Person
Copyright © MathByte Academy

isinstance() vs type()
à more often use isinstance() rather than type()
why?
à often more concerned whether an object has certain behaviors
Let's say we want to call the eat() method of an object if it has one
we could do this:
if type(obj) is Person:
obj.eat()
à but if obj is a Student (or Teacher), this won't call its eat() method
if type(obj) in [Person, Student, Teacher]:
obj.eat()
Much simpler to use isinstance():
if isinstance(obj, Person):
obj.eat()
tip: when using isinstance, try to use the least restrictive parent class you actually need
Instead we could write:
Copyright © MathByte Academy

The issubclass() function
Used to inspect inheritance relationships between classes (not instances)
Person
Student
Teacher
CollegeStudent
HighSchoolStudent
issubclass(Student, Person)
à True
issubclass(CollegeStudent, Student)
à True
issubclass(CollegeStudent, Person)
à True
issubclass(Student, Teacher)
issubclass(Person, Student)
à False
à False
Note:
à Person is a parent of Student
à Person is an ancestor of CollegeStudent
à Person is not a parent of CollegeStudent
à parent is a direct relationship
à subclass is not necessarily direct
Copyright © MathByte Academy

Defining Subclasses
class Person:
pass
class Student(Person):
pass
class Teacher(Person):
pass
class CollegeStudent(Student):
pass
class HighSchoolStudent(Student):
pass
what about this one?
is it inheriting from nothing?
à the object class
(we'll come back to this)
Copyright © MathByte Academy

object
Copyright © MathByte Academy

The object Class
when we define a class that does not inherit from another class explicitly
à Python makes the class inherit from object implicitly
à object is a class (even though it does not use a camel case)
type(object) à type
type(Person) à type
à this means every class we create is a subclass of object
Person
Student
Teacher
object
issubclass(Student, object) à True
isinstance(s1, object)
à True
à every object, even functions, modules, …
class Person:
pass
same as
class Person(object):
pass
not needed
Copyright © MathByte Academy

Implications of inheriting from object
à any class we create automatically inherits behaviors and attributes from the object class
à __name__
à __init__
à __repr__
à __hash__
and many more…
So even if we create an "empty" class:
class Person:
pass
p = Person()
p.__repr__
à <__main__.Person object at 0x106cb79e8>
p.__hash__
à -9223372036579215458
à __new__
à __eq__
p == p
à True
it will use whatever default implementation object has defined
Copyright © MathByte Academy

Copyright © MathByte Academy

Overriding Functionality
When we inherit from another a class, we inherit its attributes, including all callables
à we can choose to redefine an existing callable in the sub class
à this is called overriding
class Person:
def say_hello(self):
return 'Hello!'
def say_bye(self):
return 'Bye!'
class Student(Person):
def say_hello(self):
return 'Yo!'
p = Person()
s = Student()
<obj>.say_hello()
<obj>.say_bye()
Hello!
Yo!
Bye!
Bye!
uses override
uses inherited
Copyright © MathByte Academy

Overriding Functionality
When we create any class, we can override any method defined in the parent class, including 
inherited ones
à including those defined in object
class Person:
def __init__(self, name):
self.name = name
def __repr__(self):
return f'Person(name={self.name})'
p = Person('john')
str(p) à Person(name=john)
s = Student('eric'')
str(s) à Student(name=eric)
class Student(Person):
def __repr__(self):
return f'Student(name={self.name})'
overrides __init__ in object
overrides __repr__ in object
overrides __repr__ in Person
inherits __init__ from Person
Copyright © MathByte Academy

Tip
Objects have a property:
à returns the class the object was created from
Classes have a property:
__name__
à returns a string containing the name of the class
To get the name (string) of the class used to create an object
à object.__class__.__name__
class Person:
def __init__(self, name):
self.name = name
def __repr__(self):
return f'Person(name={self.name})'
class Student(Person):
def __repr__(self):
return f'Student(name={self.name})'
__class__
class Person:
def __init__(self, name):
self.name = name
def __repr__(self):
return f'{self.__class__.__name__}(name={self.name})'
class Student(Person):
pass
instead we can do this, and get the same effect:
Copyright © MathByte Academy

Overriding and the inheritance chain
à there are some subtle points here to note.
Suppose we have this type of hierarchy:
Person
- eat() à "Person eats"
- sleep() à "Person sleeps"
- work() à "Person works"
- routine() à eat() work() sleep()
p = Person()
p.routine() à
Person eats
Person works
Person sleeps
Now we create a Student class that overrides the work() method only:
Student:
- work() à "Student studies"
what happens when we call routine() on a Student instance?
s = Student()
à runs routine as defined in Person class – but bound to s
à routine calls eat()
à sleep() in Person class bound to s
à … calls work()
à finds the override in Student!!!
à uses the override in Student
à Person eats
à Student studies
à Person sleeps
à s.routine()
à… calls sleep()
à eat() in Person class bound to s
Copyright © MathByte Academy

Copyright © MathByte Academy

Extending Functionality
We can also extend functionality
à creating a more specialized class
class Person:
pass
class Student(Person):
def study():
return "study…study…study"
Student now has "extra" functionality
à study()
Copyright © MathByte Academy

Copyright © MathByte Academy

Delegating to parent
Often when overriding methods, we need to delegate back to the parent class
The most common example is the __init__ method
à calling a method specifically in the ancestry hierarchy (or a sibling class as we'll see later)
class Person:
def __init__(self, name, age):
self.name = name
self.age = age
class Student(Person):
def __init__(self, name, age, major):
self.major = major
self.name = name
self.age = age
there has to be a 
better way!
We can explicitly call a method from the parent class
à delegating to parent
à super()
super().method()
à will call method in the parent, but bound to the instance it is called from
Copyright © MathByte Academy

Example
class Person:
def sing(self):
return "I'm a lumberjack and I'm OK"
class Student(Person):
def sing(self):
return super().sing() + '\n' + "I sleep all night and I work all day" 
s = Student()
print(s.sing())
à
I'm a lumberjack and I'm OK
I sleep all night and I work all day
Careful! If you forget super() in super().sing() and 
use self.sing() you'll end up with infinite recursion!
Copyright © MathByte Academy

Example
à delegation works its way up the inheritance hierarchy until it finds what it needs
class Person:
def sing(self):
return "I'm a lumberjack and I'm OK"
class MusicStudent(Student):
def sing(self):
return super().sing() + '\n' + "I sleep all night and I work all day" 
class Student(Person):
pass
m = MusicStudent()
print(m.sing())
à
I'm a lumberjack and I'm OK
I sleep all night and I work all day
print(s.sing())
à
I'm a lumberjack and I'm OK
s = Student()
Copyright © MathByte Academy

Example
__init__
class Person:
def __init__(self, name, age):
self.name = name
self.age = age
class Student:
def __init__(self, name, age, major):
super().__init__(name, age)
self.major = major
delegate back to parent
and do some additional work
When delegating, you don't have to delegate first
class Student:
def __init__(self, name, age, major):
self.major = major
super().__init__(name, age)
but usually safer to do so
Copyright © MathByte Academy

Why?
à executing the delegate method may modify something you've already set in the instance
class Person:
def __init__(self, name, age):
self.name = name
self.age = age
self.major = 'N/A'
class Student(Person):
def __init__(self, name, age, major):
self.major = major
super().__init__(name, age)
s = Student('douglas', 42, 'literature')
self.name à douglas
self.age à 42
self.major à N/A
Copyright © MathByte Academy

Delegation and Method Binding
when we call a method from an instance
à method is bound to the instance
when we delegate from an instance to parent method
à method is also bound to the instance it was called from
class Person:
def hello(self):
print('In Person class:', self)
class Student(Person):
def hello(self):
print('In Student class:', self)
super().hello()
p = Person()
s = Student()
p.hello() à In Person class: <__main__.Person object at 0x106cc3128>
à
In Student class: <__main__.Student object at 0x106cc3da0> 
In Person class <__main__.Student object at 0x106cc3da0>
s.hello()
Copyright © MathByte Academy

Where things get really weird…
Since delegated method are bound to the calling instance
à any method called from the parent class will use the calling instance's "version" of the method
class Student(Person):
def do_work(self):
print('Student studies')        
def routine(self):
super().routine()
print('but not before a quick game!') 
class Person:
def wake_up(self):
print('Person awakes')
def do_work(self):
print('Person works')
def sleep(self):
print('Person sleeps')
def routine(self):
self.wake_up()
self.do_work()
self.sleep()
p = Person()
p.routine()
Person awakes
Person works 
Person sleeps
à
s = Student()
s.routine()
à Person awakes
Student studies
Person sleeps
but not before a quick game!
Copyright © MathByte Academy

Copyright © MathByte Academy

Slots
Remember that instance attributes are normally stored in a local dictionary of class instances
class Point:
def __init__(self, x, y):
self.x = x
self.y = y
p = Point(0,0)
p.__dict__ à {'x': 0, 'y': 0}
As we know there is a certain memory overhead with dictionaries
What happens if we have thousands of instances of Point?
à a lot of overhead!
Python 3.3 introduced key sharing dictionaries to help alleviate this problem
à but we can do even better
à slots
Copyright © MathByte Academy

Slots
We can tell Python that a class will contain only certain pre-determined attributes
à Python will then use a more compact data structure to store attribute values
class Point:
__slots__ = ('x', 'y')
def __init__(self, x, y):
self.x = x
self.y = y
an iterable containing the attribute names we will 
use in our class
p = Point(0,0)
p.__dict__
vars(p)
à Attribute Error: Point object has not attribute __dict__
à TypeError: vars() argument must have __dict__ attribute 
dir(p)
à […, 'x', 'y']
p.x à 0
p.x = 100
p.x à 100
Copyright © MathByte Academy

Slots
memory savings, even compared to key sharing dictionaries, can be substantial
class Point:
def __init__(self, x, y):
self.x = x
self.y = y
class Point:
__slots__ = ('x', 'y')
def __init__(self, x, y):
self.x = x
self.y = y
10,000 instances
1,729 KB
635 KB
Isn’t creating that many instances of an object rare?
à depends on your program
à example: returning multiple rows from a database and putting each row into an object
à use slots in cases where you know you will benefit substantially
Copyright © MathByte Academy

Slots
using slots results in generally faster operations (on average)
def manipulate_dict():
p = PersonDict()
p.name = 'John'
p.name
del p.name
def manipulate_slots():
p = PersonSlots()
p.name = 'John'
p.name
del p.name
class PersonDict:
pass
class PersonSlots:
__slots__ = ('name', )
à about 30% faster
timeit(manipulate_dict)
timeit(manipulate_slots)
Copyright © MathByte Academy

Slots
So why not use slots all the time then?
à if we use slots, then we cannot add attributes to our objects that are not defined in slots
class Point:
__slots__ = ('x', 'y')
def __init__(self, x, y):
self.x = x
self.y = y
p = Point(0,0)
p.z = 100
à AttributeError: 'Point' object 
has no attribute 'z'
setattr(p, 'z', 100)
à can cause difficulties in multiple inheritance
Copyright © MathByte Academy

Copyright © MathByte Academy

Slots and Single Inheritance
So what happens if we create a base class with slots and extend it?
class Person:
__slots__ = 'name',
class Student(Person):
pass
we don't specify slots in subclass
s = Student()
s.name = 'Alex'
s.__dict__
à {}
in fact:
s.age = 18
à works just fine
so there is an instance dict
s.__dict__
à {'age': 18}
Copyright © MathByte Academy

Slots and Single Inheritance
So subclasses will use slots from the parents (if present), and will also use an instance dictionary
What if we want our subclass to also just use slots?
à specify __slots__ in the subclass
à but only specify the additional ones
à don't re-specify slots from up the inheritance chain
class Person:
__slots__ = 'name', 
class Student(Person):
__slots__ = 'age', 
à Students will now use slots for both name and age
Copyright © MathByte Academy

Slots and Single Inheritance
What happens if we do re-specify some slots?
à works (kind of)
class Person:
__slots__ = 'name', 
class Student(Person):
__slots__ = 'name', 'age'
à memory usage has increased
à may actually break in the future
Python docs:
In the future, a check may be added to prevent this.
à hides the attribute defined in the parent class
Copyright © MathByte Academy

à hides the attribute defined in the parent class
class Person:
def __init__(self, name):
self.name = name
@property
def name(self):
return self._name.upper()
@name.setter
def name(self, value):
self._name = value
p = Person('Alex')
p.name à ALEX
class Student(Person):
__slots__ = 'name', 'age'
def __init__(self, name, age):
self.name = name
self.age = age
s = Student('Alex', 18)
s.name à Alex
What happens if we redefine a slot attribute in a subclass?
Copyright © MathByte Academy

What happens when a subclass defines slots but inherits from a parent that does not?
class Person:
pass
class Student(Person):
__slots__ = 'name', 'age'
Student will use slots for name and age
à but an instance dictionary will always be present too
Copyright © MathByte Academy

How are slotted attributes different from properties?
à a slotted attribute is not stored in an instance dictionary
à properties are also not in an instance dictionary
class Useless:
@property
def useless(self):
return 'useless!'
@useless.setter
def useless(self, value):
pass
obj = Useless()
obj.useless à 'useless!'
obj.__dict__ à {}
they are not different – in fact they both use data descriptors
à we'll cover data descriptors later
à slots essentially create properties (getters, setters, deleters, and storage) for us
obj.useless = 'something else'
à in both cases, the attributes are present in the class dictionary
Copyright © MathByte Academy

The best of both worlds
slots à faster attribute access, less memory
instance dictionary à can add attributes arbitrarily at run-time
à can we do both?
à yes!
à specify __dict__ as a slot
class Person:
__slots__ = 'name', '__dict__'
p.name = 'Alex'
p.age = 18
p.__dict__
à {'age': 18}
à uses slots for name, and an instance dict for age
Copyright © MathByte Academy

Copyright © MathByte Academy

what are descriptors?
non-data vs data descriptors
the underpinning mechanism for properties, methods, slots, and even functions!
writing custom data descriptors
avoiding common storage pitfalls
weak references and weak dictionaries
Copyright © MathByte Academy

Copyright © MathByte Academy

Descriptors
Let's look at a problem we want to solve:
Suppose we want a Point2D class whose coordinates must always be integers
à plain attributes for x and y cannot guarantee this
à instead we can use a property with getter and setter methods
Let's implement x first:
class Point2D:
@property
def x(self):
return self._x
@x.setter
def x(self, value):
self._x = int(value)
def __init__(self, x):
self.x = x
Copyright © MathByte Academy

OK, so now we do the same thing for y:
class Point2D:
@property
def x(self):
return self._x
@x.setter
def x(self, value):
self._x = int(value)
@property
def y(self):
return self._y
@y.setter
def y(self, value):
self._y = int(value)
def __init__(self, x, y):
self.x = x
self.y = y
this is tedious, repetitive boiler plate code!
better way needed!
Copyright © MathByte Academy

Descriptors
What if we could write a separate class like this:
class IntegerValue:
def get(self):
return self._value
def set(self, value):
self._value = int(value)
def __init__(self, value=None):
if value:
self.set(value)
and somehow use that in our class in this way:
class Point2D:
x = IntegerValue()
y = IntegerValue()
and have code like this work by actually calling the get and set methods:
p = Point2D()
p.x = 100.1
p.x à 100
Copyright © MathByte Academy

Descriptors
Of course the previous code will not work as expected:
p.x = 100.1
à will just create a new instance variable x with the float that will shadow the 
class attribute
à use these get and set methods of the IntegerValue instance
class Point2D:
x = IntegerValue()
y = IntegerValue()
these are bound to the class, not the instances
à even if we use the get and set methods ourselves, we are still dealing with 
IntegerValue instances bound to the class Point2D, not instances of the class
à need to be able to tell Python two things:
x = IntegerValue
à this is meant to be bound to instances at run-time
p.x
Copyright © MathByte Academy

Descriptors
And this is where the descriptor protocol comes in
There are 4 main methods that make up the descriptor protocol – they are not all required.
à __get__
à __set__
à __delete__
à __set_name__
Two categories of descriptors:
those that implement __get__ only
used to get an attribute value
used to set an attribute value
used to delete an attribute
à non-data descriptors
those that implement __set__ and/or __delete__ à data descriptors
the distinction is really important as we'll see later
new in Python 3.6 – I'll come back to this later
p.x
p.x = 100
del p.x
Copyright © MathByte Academy

Using a Descriptor Class
class Logger:
current_time = TimeUTC()
from datetime import datetime
class TimeUTC:
def __get__(self, instance, owner_class):
return datetime.utcnow().isoformat()
We first define a class that implements the __get__ method only
à non-data descriptor
Next we use it in our class by specifying it as a class attribute
we'll come back to 
what those are
And we can use it this way:
l = Logger()
l.current_time
à '2019-03-13T18:59:49.435411'
à as you can see it called __get__
Copyright © MathByte Academy

Copyright © MathByte Academy

The __get__ method
Important to understand how __get__ is being called
class TimeUTC:
def __get__(self, instance, owner_class):
return datetime.utcnow().isoformat()
class Logger:
current_time = TimeUTC()
à Logger defines a single instance of TimeUTC as a class attribute
à because TimeUTC implements __get__ Python will use that method when retrieving the 
instance attribute value
But we can access the attribute from:
à the Logger class itself
à an instance of the Logger class
So, when __get__ is called, we may want to know:
à which instance was used (if any)
à None if called from class
Logger.current_time
l.current_time
à what class owns the TimeUTC (descriptor) instance
à Logger in this case
à this is why we have the signature: __get__(self, instance, owner_class)
Copyright © MathByte Academy

The __get__ method
So we can return different values from __get__ depending on:
à called from class
à called from instance
very often, we choose to:
à return the descriptor (TimeUTC) instance when called from class itself (Logger class)
à gives us an easy handle to the descriptor instance
à return the attribute value when called from an instance of the class (Logger instance)
class TimeUTC:
def __get__(self, instance, owner_class):
if not instance:
return self
return datetime.utcnow().isoformat()
Copyright © MathByte Academy

The __set__ method
The __set__ signature is as follows:
self, instance, value
à self: just like for the __get__, this references the descriptor instance, like any regular method
à instance: the instance the __set__ method was called from
à value: the value we want to assign to the attribute
You'll notice there is no owner_class like we have in the __get__ method
à setters (and deleters) are always called from instances
à descriptors are meant to be used for instance properties
Copyright © MathByte Academy

Caveat with Set and Delete (and Get)
There is one really important caveat with __set__ and __delete__
class Logger:
current_time = TimeUTC()
notice that we have only created a single instance 
of the descriptor
So what happens when we do this?
à any instance of Logger will be referencing the same instance of TimeUTC
à the same instance of TimeUTC is shared by all instances of Logger
à in this case it does not matter
__get__ just returns the current UTC time
l1 = Logger()
l2 = Logger()
Copyright © MathByte Academy

Caveat with Set and Delete (and Get)
But what happens when we have to "store" and "retrieve" data from the instances?
class Point2D:
x = IntegerValue()
y = IntegerValue()
Suppose IntegerValue is a data descriptor
à implements __get__ and __set__ methods
two separate instances of IntegerValue
assigned to the class attributes x and y
p1 = Point2D()
p2 = Point2D()
two separate instances of Point2D
but what object does p1.x reference?
à the class attribute x
what about p2.x?
à the same class attribute x
à the same instance of IntegerValue
à we have to be mindful of which instance we are "storing" the data for
à this is one of the reasons both __get__ and __set__ need to know the instance
à one of the arguments
Copyright © MathByte Academy

Copyright © MathByte Academy

Where to store the attribute value?
à we know the instance we are dealing with in both __get__ and __set__
à could maybe store it in the instance dictionary?
that might work…
but remember __slots__?
à we're not guaranteed to have an instance dictionary available
à so, maybe we use a dictionary that's local to the data descriptor instance
à key = object
à value = attribute value
à problem if object is not hashable!
à even if we were, what symbol to use? Might overwrite an existing attribute…
Copyright © MathByte Academy

Assuming our objects are hashable…
à create a dictionary in the data descriptor instance
(e.g. in IntegerValue instance)
à when using __set__ save the value in the dictionary using instance as a key
à when using __get__ lookup the instance in the dictionary and return the value
class IntegerValue:
def __init__(self):
self.data = {}
def __set__(self, instance, value):
self.data[instance] = int(value)
def __get__(self, instance, owner_class):
if not instance:
return self
return self.data.get(instance)
class Point2D:
x = IntegerValue()
y = IntegerValue()
à works, but…
Copyright © MathByte Academy

class IntegerValue:
def __init__(self):
self.data = {}
def __set__(self, instance, value):
self.data[instance] = int(value)
def __get__(self, instance, owner_class):
if not instance:
return self
return self.data.get(instance)
class Point2D:
x = IntegerValue()
y = IntegerValue()
p = Point2D()
à p is now a key in self.data
à reference count is 1
p.x = 100.1
à have a second reference to that point object
à reference count is 2
del p
à our local (or global) reference to point is gone
à but reference count is still 1
à object is not garbage collected!
Copyright © MathByte Academy

Copyright © MathByte Academy

Strong References
p1 = Person()
p2 = p1
object
p1
p2
these are called strong references
del p1
à there is still a strong reference (p2) to the object
à object is still "alive", so Python does not garbage collect it
del p2
à no more strong references to object
à object will be garbage collected by Python
à that's the problem we faced in our data descriptor
Copyright © MathByte Academy

Weak References
There is another type of object reference in Python
à weak reference
think of it as a reference to an object that does not affect the reference count 
as far as the memory manager is concerned
object
p1
strong
p2
weak
del p1
à no more (strong) references to object
à object is garbage collected
à p2 is "dead"
à so for our data descriptor instead of storing the object as key
à store a weak reference to the object
Copyright © MathByte Academy

Weak References
à use the weakref module
p1 = Person()
à p1 has a strong reference to the object
p2 = weakref.ref(p1)
à p2 is an (other) object that contains a weak reference to the object
à p2 is a callable
p2()
à returns the original object
Careful:
p3 = p2()
à you just created a strong reference to the object!
à or None if the object has been garbage collected
Copyright © MathByte Academy

Dictionaries of Weak References
So, we'll want to create a dictionary of weak references (for our keys) for our data descriptor
à weakref has a WeakKeyDictionary to do just that!
d = WeakKeyDictionary()
d[p1] = 'some value'
à a weak reference is used for the Person instance
p1 = Person()
à p1 is a strong reference to the Person instance
del p1
à no more strong references à garbage collected
à item is automatically removed from weak key dictionary
(so be careful if you’re iterating over the dictionary views if that 
happens during the iteration! 
We won’t need to, so won't be a problem for our use-case)
Copyright © MathByte Academy

Copyright © MathByte Academy

Outstanding Problem
I will show you in the code section how to use the WeakKeyDictionary approach
à but technique only works for hashable objects
à cannot use the object as the key in a dictionary
à use id(instance) as the key
Instead we'll try this approach first:
à still has a drawback
if an object is finalized, the corresponding entry still remains in dictionary
à unnecessary clutter
à potential risks if id is re-used
(that was a big advantage of the WeakKeyDictionary)
à but at least we don't maintain strong reference to object
Copyright © MathByte Academy

Final Approach!!
weakref.ref à callback functionality
à automatically calls a custom function when the object is being finalized
à use regular data dictionary
à use id(instance) as key
à use (weak_ref, value) as corresponding dictionary value
à for each weak_ref register a callback function
à callback function will remove dead entry from dictionary
We can now implement data descriptors that:
à have instance specific storage
à do not use the instance itself for storage (__slots__ problem)
à handle non-hashable objects
à keep the data storage mechanism clean
Copyright © MathByte Academy

__set_name__
Copyright © MathByte Academy

The __set_name__ Method
à New in Python 3.6
This is a very handy method that gets called (once) when the descriptor is first instantiated
à that opens up some new possibilities
à better error messages
à include name of attribute that raised the exception
à useful application in descriptors used for validation
Copyright © MathByte Academy

Application
Here's a pretty typical application of using custom descriptors
à again, key here is re-usability
Suppose we have some attributes in a non-slotted class that need to be validated each time they 
are set
à get property name from __set_name__
à __set__
à validate data
à if OK, store data in instance dictionary, under the same name
à wait a minute! does instance dictionary not shadow class attribute?
à not always with descriptors!
Copyright © MathByte Academy

Copyright © MathByte Academy

Property Value Lookup Resolution
Interesting thing:
à class can have a property (descriptor) called x
à it can have an instance dictionary __dict__
à that dictionary can contain a key, also called x
what happens when we do this:
obj.x
or
obj.x = value
à does it use __dict__ entry, or the descriptor?
Copyright © MathByte Academy

It depends…
on whether the descriptor is a data or non-data descriptor
data descriptors
(both __get__ and __set__ are defined)
à always override the instance dictionary (by default – can override this behavior)
class MyClass:
prop = DataDescriptor()
m = MyClass()
m.prop = value_1
m.__dict__['prop'] = value_2
m.prop à value_1
m.prop à value_1
m.prop = value_3
à modifies the property value, not the 
dictionary entry
Copyright © MathByte Academy

It depends…
non-data descriptors
(only __get__ is defined, and potentially __set_name__)
à looks in the instance dictionary first
à if not present, uses the data descriptor
class MyClass:
prop = NonDataDescriptor()
m = MyClass()
m.prop
à 'prop' is not in m.__dict__, so calls __get__
m.prop = 100
à prop is a non-data descriptor
à m.__dict__ is now {'prop': 100}
m.prop
à 'prop' is in m.__dict__, so uses that value
Copyright © MathByte Academy

Copyright © MathByte Academy

property objects are data descriptors
Back to properties…
à they have __get__, __set__ and __delete__ methods
age = property(fget=get_age, fset=set_age)
p.age
à in turn calls get_age(p) 
p.age = 10
à in turn calls set_age(p, 10)
if fset was not defined
à __set__ sees fset is not defined
à calls __get__
à calls __set__
à calls __set__
à raises an AttributeError (can't set attribute)
Copyright © MathByte Academy

Copyright © MathByte Academy

Functions and Descriptors
one more thing I want to discuss regarding descriptors
à no real practical use, but good to understand how Python does some of its "magic"
When we write a class with an 
instance methods like this:
class Person:
def __init__(self, name):
self.name = name
def say_hello(self):
return f'{self.name} says hello'
Then we can write code like this:
p = Person('Alex')
p.say_hello()
How does the function end up being bound to the instance?
Does Python have C code that says "oh, this function is defined inside a class, and 
being called from an instance, do something different"?
No!
à functions are objects that implement the (non-data) descriptor protocol!
Copyright © MathByte Academy

Copyright © MathByte Academy

Project
We have a project where we need to define classes that have fields that we want validated 
before we can set their value.
This might be because these objects will later be serialized into a database, and we need to 
ensure the data is valid before we write to the database.
Write two data descriptors:
IntegerField
CharField
à only allows integral numbers, between minimum and maximum value
à only allows strings with a minimum and maximum length
Part 1
So we want to be able use the descriptors like this:
class Person:
name = CharField(1, 50)
age = IntegerField(0, 200)
Copyright © MathByte Academy

Part 2
You probably wrote two unrelated classes to do this.
But you'll notice there's quite a bit of code duplication, with only the actual validation being different
Refactor your code and create a BaseValidator class that will handle the common functionality
Then change your IntegerField and CharField descriptors to inherit from BaseValidator
If you haven't coded you descriptors that way already, make sure you can also omit one or both 
of the minimum and maximum values where it makes sense.
For example we may want to specify a string field that has no maximum limit.
Or we may want an integer field that has an upper bound, but no lower bound. 
Or maybe no bounds at all.
Copyright © MathByte Academy

Good luck!
don't forget unit tests!
Copyright © MathByte Academy

Copyright © MathByte Academy

In this section we'll cover:
how to deal with multiple related constants
what are enumerations and why have them?
Python's support for enumerations
Python enumerations are versatile
à lots of associated functionality!
STATUS_STARTED = 'started'
STATUS_PENDING = 'pending'
STATUS_ERROR = 'error'
STATUS_OK = 'ok'
STATUSES = [STATUS_STARTED, …, STATUS_OK]
Copyright © MathByte Academy

Copyright © MathByte Academy

How to deal with collections of related constants?
We could try this approach:
RED = 1
GREEN = 2
BLUE = 3
COLORS = (RED, GREEN, BLUE)
and then we could use it in our code this way:
pixel_color = {RED: 255, BLUE: 0, GREEN: 200}
pixel_color[RED] à 255
Copyright © MathByte Academy

But there's some downsides:
1 in COLORS à True
RED in COLORS à True
but:
is 1 really a color?
does the string 'RED' correspond to a valid color name?
à maybe do this instead:
RED = 'red'
GREEN = 'green'
BLUE = 'blue'
COLORS = (RED, GREEN, BLUE)
à repetitive code!
à later can change associated values:
RED = 'violet'
à could run into bugs
RED = 'red'
GREEN = 'red'
BLUE = 'blue'
à non-unique values by mistake!
à RED * 2
à this is meaningless!
RED < GREEN à True
à meaningless!
Copyright © MathByte Academy

What we really want…
an immutable collection of related constant members:
à unique associated values
à have unique names (that may have meaning)
à have an associated constant value
à operations such as RED * 2 or RED < GREEN are not even allowed
à supports enumerating members by name
à 'RED', 'GREEN', 'BLUE'
à lookup member by name
à lookup member by value
Copyright © MathByte Academy

Maybe use a class?
class Colors:
RED = 1
GREEN = 2
BLUE = 3
Colors.RED
hasattr(Colors, 'RED')
getattr(Colors, 'RED')
à how do we look up a member based on it's value?
à how do we iterate the members?
à we can, but is order preserved?
à still cannot guarantee uniqueness of values
Copyright © MathByte Academy

Aliases
Sometimes we want multiple symbols to refer to the same "thing"
Consider RECTANGLE, SQUARE and RHOMBUS to be aliases for POLY_4
POLY_4 = 4
RECTANGLE = 4
SQUARE = 4
RHOMBUS = 4
POLY_3 = 3
TRIANGLE = 3
EQUILATERAL = 3
ISOSCELES = 3
à lookup value 3
à return POLY_3
à lookup name SQUARE
à return POLY_4
Consider TRIANGLE, EQUILATERAL and ISOCELES to be aliases for POLY_3
à values are still unique, names are just 
aliases to the first one
POLY_4
(4)
RECTANGLE
SQUARE
RHOMBUS
Copyright © MathByte Academy

Copyright © MathByte Academy

Python Enumerations
à PEP 435
à Python 3.4
à enum module
à Enum type
à specialized enumerations: IntEnum, Flag, and IntFlag
Python 3.6
à enumerations are created by subclassing Enum
Copyright © MathByte Academy

Terminology
class Color(Enum):
RED = 1
GREEN = 2
BLUE = 3
à Color is called an enumeration
à Color.RED is called an enumeration member
à members have associated values
à the type of a member is the enumeration it belongs to
Copyright © MathByte Academy

The basics…
type(Color.RED)
à True
str(Color.RED)
à 'Color.RED'
à '<Color.RED: 1>'
repr(Color.RED)
Color.RED.name
à 'RED'
Color.RED.value
à 1
isinstance(Color.RED, Color)
à Color
class Color(Enum):
RED = 1
GREEN = 2
BLUE = 3
Copyright © MathByte Academy

Equality and Membership
member equality is done using identity
à is
(but == works too)
membership uses in
Color.GREEN in Color
à True
Color.RED is Color.RED
à True
Color.RED is Color.BLUE
à False
à note that member and it's associated value are not equal!
Color.RED == 1
à False
class Color(Enum):
RED = 1
GREEN = 2
BLUE = 3
Copyright © MathByte Academy

Members are hashable
Enumeration members are always hashable
à can be used as keys in dictionaries
à can be used as elements of a set
class Color(Enum):
RED = 1
GREEN = 2
BLUE = 3
pixel_color = {
Color.RED: 100,
Color.GREEN: 25,
Color.BLUE: 255
}
Copyright © MathByte Academy

Programmatic Access to Members
class Color(Enum):
RED = 1
GREEN = 2
BLUE = 3
can reference a member this way:
Color.RED
how to "get" a member using:
à value
à string of the name
(e.g. 1)
(e.g. 'RED')
à to get a member by value
enumerations are callable
Color(2)
à Color.GREEN
à to get a member by name
Color['GREEN']
à Color.GREEN
Color(2) is Color['GREEN'] à True
enumerations implement __getitem__ method
Copyright © MathByte Academy

Enumerating Members
class Color(Enum):
RED = 1
GREEN = 2
BLUE = 3
à enumerations are iterables
list(Color) à [Color.RED, Color.GREEN, Color.BLUE]
à definition order is preserved
class Color(Enum):
GREEN = 2
BLUE = 3
RED = 1
list(Color) à [Color.GREEN, Color.BLUE, Color.RED]
à has nothing to do with member value
à Enumerations have a __members__ property
à returns a mapping proxy (immutable dict)
à keys are the names (as strings), and values are the values
Copyright © MathByte Academy

Constant Members and Constant Values
Once an enumeration has been declared:
à member list is immutable
(cannot add or remove members)
à member values are immutable
à cannot be subclassed (extended via inheritance)
à unless it contains no members!
(we'll come back to that later)
Copyright © MathByte Academy

Copyright © MathByte Academy

Members are unique
Recall that members are guaranteed to be unique
So this should not work:
class Color(Enum):
red = 1
crimson = 1
carmine = 1
blue = 2
aquamarine = 2
but it works!!!
Copyright © MathByte Academy

Aliases
class Color(Enum):
red = 1
crimson = 1
carmine = 1
blue = 2
aquamarine = 2
we still have unique members
but we now also have aliases
à in fact our enumeration contains only two members:
à Color.red
à Color.blue
The remaining "members" point to these two members:
Color.carmine à Color.red
list(Color) à Color.red, Color.blue
Color.crimson à Color.red
Color.aquamarine à Color.blue
Color.crimson is Color.red à True
Color.carmine is Color.crimson à True
Copyright © MathByte Academy

Lookups
Lookups with aliases will always return the "master" member
class Color(Enum):
red = 1
crimson = 1
carmine = 1
blue = 2
aquamarine = 2
Color(1) à Color.red
Color['crimson'] à Color.red
Containment
Color.crimson in Color à True
Copyright © MathByte Academy

Iterating Aliases
class Color(Enum):
red = 1
crimson = 1
carmine = 1
blue = 2
aquamarine = 2
list(Color) à Color.red, Color.blue
à the only way to see the aliases is to use __members__
Color.__members__
{
'red': <Color.red: 1>, 
'crimson': <Color.red: 1>, 
'carmine': <Color.red: 1>, 
'blue': <Color.blue: 2>, 
'aquamarine': <Color.aquamarine: 3>
}
à mappingproxy
à note how keys are different, but point to the same member
Copyright © MathByte Academy

Ensuring Unique Values
à we may want to guarantee that our enumerations do not contain aliases (unique values)
à we could just be careful writing our code!
à or use the @enum.unique decorator
@enum.unique
class Color(Enum):
red = 1
crimson = 1
carmine = 1
blue = 2
aquamarine = 2
à ValueError: duplicate values found
(when class is compiled)
Copyright © MathByte Academy

Copyright © MathByte Academy

Customizing
Enums are classes
class attributes become instances of that class
à members
We can define functions in the enumeration class
à become bound methods when called from a member (instance of the class)
à custom methods
à implement dunder methods
__str__  __repr__  __eq__  __lt__  etc…
Copyright © MathByte Academy

Member Truthyness
by default, every member of an enum is truthy
à irrespective of the member value
class State(Enum):
READY = 1
BUSY = 0
bool(State.READY) à True
bool(State.BUSY) à True
So we can implement the __bool__ method to override this behavior:
class State(Enum):
READY = 1
BUSY = 0
def __bool__(self):
return bool(self.value)
bool(State.READY) à True
bool(State.BUSY) à False
Copyright © MathByte Academy

Extending Enums
enumerations are classes
à they can be extended (subclassed)
BUT…
only if they do not contain any members
à cannot create a partial enum with some members and extended it with more members
à might seem limiting, but not really
à create a base enum with functionality (methods)
à use it as a base class for other enumerations that define their members
Copyright © MathByte Academy

Copyright © MathByte Academy

Auto generating associated values
à Python 3.6
We can use enum.auto() as member values
Behind the scenes, uses a method in the Enum class:
_generate_next_value_
à default implementation results in sequential integer numbers
class Number(enum.Enum):
ONE = enum.auto()
TWO = enum.auto()
THREE = enum.auto()
Number.ONE.value à 1
Number.TWO.value à 2
NumberTHREE.value à 3
Copyright © MathByte Academy

_generate_next_value_(name, start, count, last_values)
arguments:
name
start
count
last_values
the name of the member
(only actually used in functional creation – not covered in this course)
the number of members already created (be careful with aliases!)
a list of all preceding values
returns:
value to be assigned to member
à static method
à called by enum.auto() 
Copyright © MathByte Academy

Overriding
The default implementation of _generate_next_value_ generates sequential integer numbers
à be careful mixing auto() and your own values!
à safer not do do it
à override the default implementation by implementing _generate_next_value_ in our enum
Copyright © MathByte Academy

Copyright © MathByte Academy

Application Exceptions
In many cases, especially in larger projects, we want to have an easy way to generate exceptions
à raise consistent exception types
à associated exception code
à associated default exception message
à ability for our user to easily list out all the possible exceptions in our app
This is very common when writing REST APIs for example
à many ways to do this, but here we want to practice using enumerations
Copyright © MathByte Academy

Functionality
à single enumeration AppException
à exceptions have a name (key) and three associated values
•
name (e.g. NotAnInteger)
•
code (e.g. 100)
•
default message (e.g. 'Value is not an integer.')
•
associated exception type (e.g. ValueError)
à lookup by exception name (key) or code (value)
à method to raise an exception
AppException.Timeout.throw()
à ability to override default message when throwing exception
AppException.Timeout.throw('Timeout connecting to DB.)
AppException['NotAnInteger']
AppException(100)
Copyright © MathByte Academy

Tips
enumeration members will be defined using a tuple containing three values
à code, exception type (class name), default message
NotAnInteger = 100, ValueError, 'Value is not an integer'
Use the __new__ approach I showed you earlier
Make the value the error code
Provide an additional property for message
Copyright © MathByte Academy

Copyright © MathByte Academy

In this section
what are exceptions?
à not necessarily errors
Python's exception class hierarchy
handling exceptions
exception propagation
raising exceptions
creating our own exception classes
à custom hierarchy
à extending functionality
Copyright © MathByte Academy

Copyright © MathByte Academy

What are exceptions?
à exceptions are objects
à when an exception is raised
à trigger a special execution propagation workflow
à exception handling
à if current call does not handle exception it is propagated up to caller
à call stack trace is maintained
à documents origin of exception
à every call in the stack 
à they are instances of some class
Copyright © MathByte Academy

Call Stack
à call function_1
à calls function_2
à calls function_3
function_1
function_1
function_2
function_1
function_2
function_3
Call Stack
Copyright © MathByte Academy

Exception Propagation
function_1
function_2
function_3
exception is raised in function_3
if unhandled, propagates to function_2
if unhandled, propagates to function_1
if unhandled, program terminates
à stack trace will contain information describing this call stack
Copyright © MathByte Academy

Exception Handling
exceptions are not necessarily fatal, i.e. do not necessarily result in program termination
à we can handle exceptions as they occur
à do something and let program continue running "normally"
à do something and let original exception propagate
à do something and raise a different exception
à try
à except
à finally
à else
(compound statement)
Copyright © MathByte Academy

What are exceptions used for?
à exceptions are not necessarily errors
à indicate some sort of anomalous behavior
à sometimes not even that
consider StopIteration exception raised by iterators
after all we would expect this to happen à not really anomalous!
Copyright © MathByte Academy

Two main categories of exceptions
à compilation exceptions
à execution exceptions
(e.g. SyntaxError)
(e.g. ValueError, KeyError, StopIteration)
Python's built-in exception classes use inheritance to form a class hierarchy
base exception for every exception in Python
à BaseException
à but do not inherit from this one
Copyright © MathByte Academy

Python's Exception Hierarchy
à see https://docs.python.org/3/library/exceptions.html#bltin-exceptions for full list
BaseException
SystemExit
KeyboardInterrupt
GeneratorExit
Exception
(raised on sys.exit())
(raised on Ctrl-C for example)
(raised when generator or coroutine is closed)
à everything else!
Copyright © MathByte Academy

Python's Exception Hierarchy
à most of the time any exception we work with inherits from Exception
direct subclasses of Exception include:
•
ArithmeticError
•
AttributeError
•
LookupError
•
SyntaxError
•
RuntimeError
•
TypeError
•
ValueError
•
FloatingPointError
•
ZeroDivisionError
•
IndexError
•
Key Error
and more…
exception objects are instances of these classes
Copyright © MathByte Academy

Python's Exception Hierarchy
when exceptions inherit from other exceptions:
Exception
LookupError
IndexError
an IndexError exception IS-A LookupError exception
a LookupError exception IS-A Exception exception
an IndexError exception IS-A Exception exception
à if we catch a LookupError exception
à it will also catch an IndexError exception
à if we catch an Exception exception
à it will also catch any subclass of Exception
à broad catch – usually bad practice
Copyright © MathByte Academy

Basic Exception Handling
the try statement is used to for exception handling
à multi-part statement
à basic:
try:
…
except ValueError:
…
à get a handle to exception object in except clause:
try:
…
except ValueError as ex:
…
à we'll come back to the try statement
Copyright © MathByte Academy

Copyright © MathByte Academy

Handling exceptions using try
the full try statement has these clauses:
try:
code that we want to protect from 
some potential exception(s)
except <ExceptionType> as ex:
code that will run if that specified 
<ExceptionType> occurs (or any subclass)
finally:
code that always executes –
whether exception occurred or not
else:
code that executes if try terminates normally
(an except clause must be present)
à keep this guarded code as short as possible
à often just a single statement!
à only guard code where you can do 
something about the exception
Copyright © MathByte Academy

à may appear 0 or more times
Handling exceptions using try
the try statement clauses are quite flexible
try:
except <ExceptionType> as ex:
à allows handling different exception types in different ways
à as ex is optional
à <ExceptionType> is optional
à broad exception handler - be careful!
finally:
à appears 0 or 1 times
else:
à appears 0 or 1 times
à only allowed if an except clause is present
à this is required
à and of course they can be nested
Copyright © MathByte Academy

Handling Multiple Exception Types
try:
…
except TypeError:
…
except AttributeError:
…
except IndexError:
…
always go from most specific to least specific 
(in terms of class hierarchy)
first except match will run
Copyright © MathByte Academy

except order matters
l = [1, 2, 3]
try:
l[3]
except IndexError:
print('invalid index')
except LookupError:
print('lookup error')
Exception à LookupError
à IndexError
à KeyError
à 'invalid index'
l = [1, 2, 3]
try:
l[3]
except LookupError:
print(lookup error')
except IndexError:
print(index error')
à 'lookup error'
Copyright © MathByte Academy

Grouping Exception Handlers
à sometimes we want to handle multiple exception types in the same way
try:
…
except ValueError as ex:
log(ex)
except TypeError as ex:
log(ex)
à in that case group the exception types in a single except clause
try:
…
except (ValueError, TypeError) as ex:
log(ex)
Copyright © MathByte Academy

Bare Exception Handlers
à exception handlers that do not specify an exception type
à catch any exception
à overly broad for general use
à but good in certain circumstances
à do some cleanup work, logging, … and re-raise exception
à we'll come back to that
try:
…
except:
…
how do we know what the exception is?
sys.exc_info()
à tuple
exc_type, exc_value, exc_traceback
à returns info about current exception
Copyright © MathByte Academy

Exception Objects
What properties and methods an exception object has depends on the exception
args
à arguments used to create exception object
__traceback__
standard exceptions have at least these two properties:
à the traceback object
à use the traceback module for easier visualization
à print_tb
à print_exception
à tb is same object as last item returned by sys.exc_info()
à not needed unless you are writing really advanced 
Python code (like frameworks)
à may be good for logging
à often error message
Copyright © MathByte Academy

try… finally…
à finally code block is guaranteed to run, exception or no exception
à can actually do this
try:
…
finally:
…
à the exception is not handled – so it will propagate up
à but finally block runs before propagation
à useful for cleanup code
à no except clauses
Copyright © MathByte Academy

What happens if an exception handler itself raise an exception?
works as normal – if the exception is not handled, it is propagated up
à exception handling can be nested inside an except handler
à not just inside the try clause
à in fact can be nested inside else, or even finally
Copyright © MathByte Academy

Handling Exceptions vs Avoiding Exceptions
It's easier to ask forgiveness than it is to get permission.
Grace Hopper
Sometimes referred to as the EAFP principle in Python
(Easier to Ask For Permission)
Consider these two alternatives:
try:
with open(fname, 'r') as f:
…
except OSError:
# do something
if os.path.exists(fname) and not os.path.isdir(fname):
f = open(fname, 'r')
….
f.close()
this does not even begin to 
address possible permission 
issues!
Also things could go wrong while 
writing to the file, and we won't close 
it (hence the context manager)
Copyright © MathByte Academy

Copyright © MathByte Academy

Raising an Exception
à use the raise statement
à raised object must be an instance of BaseException
à i.e. class must be a subclass of BaseException
(does not have to be a direct subclass)
raise ValueError()
Copyright © MathByte Academy

BaseException
à __init__ can handle *args
à accessible via args attribute of exception object (instance)
à used for str() and repr() representations
ex = ValueError('a', 'b', 'c')
ex.args à ('a', 'b', 'c')
à subclasses inherit this behavior
str(ex) à "('a', 'b', 'c')"
repr(ex) à "ValueError('a', 'b', 'c')"
à typically use first argument for the main "message"
Copyright © MathByte Academy

Re-Raising current exception being handled
When are handling an exception
à inside an except block
à we can re-raise the current exception
raise
(no exception object specified)
à this will resume exception propagation 
try:
…
except:
# bare except!
log('…')
raise
à very handy to catch any exception
à log it
à resume as if we had not interrupted it
à perfectly acceptable use of bare except
Copyright © MathByte Academy

Exception Traceback
à we have seen: exception handlers that themselves raise exceptions (nested exceptions)
à "final" exception traceback shows us a history of this
à traceback
try:
raise ValueError()
except ValueError:
try:
raise TypeError()
except TypeError:
raise KeyError()
KeyError
TypeError
ValueError
à sometimes this is too much information for our user
à our internal implementations should maybe remain opaque
Copyright © MathByte Academy

Using raise… from…
We can control (to some extent) what traceback is included
try:
raise ValueError()
except ValueError:
try:
raise TypeError()
except TypeError:
raise KeyError() from None
KeyError
try:
raise ValueError()
except ValueError as ex_1:
try:
raise TypeError()
except TypeError:
raise KeyError() from ex_1
KeyError
ValueError
à useful to hide exception stacks that are just implementation details
Copyright © MathByte Academy

Copyright © MathByte Academy

Creating New Exception Classes
à create a new class that inherits from Exception (or one of its subclasses)
à recall BaseException is the base class for all exceptions
BaseException
Exception
SystemExit
KeyboardInterrupt
GeneratorExit
very specialized
The standard is that most exceptions, including custom exceptions, inherit from Exception
à can still broadly trap using Exception
à without trapping SystemExit, KeyboardInterrupt, etc
Copyright © MathByte Academy

Creating New Exception Classes
class WidgetException(Exception):
"""base custom exception for Widget library"""
class WidgetValueError(ValueError):
"""custom ValueError exception"""
class OutOfStockException(WidgetException):
"""out of stock exception"""
Copyright © MathByte Academy

Creating an Exception Hierarchy
à often we have an entire set of custom exceptions
à keep the exceptions organized
à just like Python
à create a hierarchy of custom exceptions
class WidgetException(Exception)
class StockException(WidgetException)
class OutOfStock(StockException)
class OverInventoryLimit(StockException)
class SalesException(WidgetException)
class OverOrderLimit(SalesException)
class CouponCodeInvalid(SalesException)
à allows trapping exceptions at multiple levels
à except StockException
à except OutOfStock
à except WidgetException
Copyright © MathByte Academy

Extending Functionality
à exceptions are classes
à add functionality (properties, methods, attributes)
à even implement special methods (__str__, __repr__, etc)
à for example, add auto-logging to your exceptions
à use for consistent output mechanisms (e.g. json representation of the exception)
Copyright © MathByte Academy

Multiple Inheritance
Exceptions, like any class, can inherit from multiple classes
Keeping it simple
à custom exception can inherit from multiple exceptions
class WidgetException(Exception)
class SalesException(WidgetException)
class InvalidSalePrice(SalesException, ValueError)
à if an InvalidSalePrice exception is raised
à can be trapped with either InvalidSalePrice or ValueError
Copyright © MathByte Academy

Copyright © MathByte Academy

What is metaprogramming?
Wikipedia:
Metaprogramming is a programming technique in which computer programs 
have the ability to treat other programs as their data. 
It means that a program can be designed to read, generate, analyze or 
transform other programs, and even modify itself while running.
à basic idea is we can use code to modify code
à keeps code DRY
à Don't Repeat Yourself
à some functionality requires Python 3.6 or above
Copyright © MathByte Academy

You already know some metaprogramming techniques…
à decorators
use code to modify the behavior of another piece of code
à we'll explore class decorators a bit, where we decorate classes, not just functions
à descriptors
use code to essentially modify the behavior of the dot (.) operator
à as well as decorator classes where we use classes to decorate
Copyright © MathByte Academy

Metaclasses
We'll look at what metaclasses are
à how they are used in the creation of classes (types)
à how we can use them to hook into the class creation cycle
à we'll still stick to single inheritance
à metaclasses don't always play nicely with multiple inheritance
à think of a metaclass as a class(type) factory
Copyright © MathByte Academy

Word of caution
à superficially, metaclasses are not difficult to understand
à knowing when to use a metaclass is not easy
à unless you come across a problem where the use of a metaclass is obvious
à don't use them!
à makes code harder to read
à just because you have a new hammer, does not mean everything is a nail
à if you're writing a library/framework
à maybe use metaclasses
à if you're writing application code
à probably not!
“Metaclasses are deeper magic than 99% of users should ever worry about. If you 
wonder whether you need them, you don’t (the people who actually need them know 
with certainty that they need them, and don’t need an explanation about why).”
— Tim Peters
à but the details can get complicated
à beware of the "solution in search of a problem" syndrome!
Copyright © MathByte Academy

Word of caution
so you are unlikely to ever need to use metaclasses
à unless you’re writing a library or framework
à still good to understand how they work
à provides deeper insight into Python internal mechanics and how things work
à it's actually fun!
à worth the time to understand, even if you don't use
Copyright © MathByte Academy

Word of caution
this is going to be a wild ride!
à you will get confused
à when you do, go back to previous lectures and code videos
à some of the concepts just take time to absorb and remember
(I still do on occasion)
à don't rush
à you will probably need to watch some videos multiple times
à take time to experiment with code
Copyright © MathByte Academy

__new__
Copyright © MathByte Academy

Constructing Instances of a Class
à call the class
ex: Person('Guido')
à classes are callable
à how? back to that later
à the new class instance is created
à the __init__ method is called (bound to the new object)
à but how is the new instance actually created?
(and initialized in some ways)
à after the instance has been created
à gives us a "hook" to customize the initialization
Copyright © MathByte Academy

The __new__ Method
à object implements the __new__ method
à it is a default implementation of __new__
à used in the creation of instances of any class
à can be called directly
p = object.__new__(Person)
class Person:
def __init__(self, name):
self.name = name
à __init__ is not called
à p is a new object, an instance of Person
à do it ourselves
p.__init__('Raymond')
Copyright © MathByte Academy

The __new__ Method
object.__new__(class, *args, **kwargs)
à accepts *args, **kwargs
à signature must match __init__ of class
à but it just ignores these arguments
à can override __new__ in our custom classes
à should return a new object
à should be an instance of the class
à but does not have to be
à it is a static method
à not bound to object
à class is the symbol for the class we want to instantiate
à returns a new object of type class
Copyright © MathByte Academy

Overriding the __new__ Method
à typically we do something before/after creating the new instance
à delegating actual creation to object.__new__
à in practice we use super().__new__
à ensures inheritance works properly
class Person:
def __new__(cls, name, age):
# can do things here
# create the object we want to return
instance = object.__new__(cls)
# more code here
# and finally return the object we want
return instance
super().__new__(cls)
Copyright © MathByte Academy

How is __new__ Called?
à it is called by Python when we call the class
Person('Guido')
à Python calls __new__(Person, 'Guido')
à __new__ returns an object
à if that object is of the same type as the one "requested"
à new_object.__init__('Guido') is called
à new object is returned from call
p = Person('Guido')
à we'll come back to how later
Copyright © MathByte Academy

Remember
__new__ is a static method
à done implicitly for us by Python
class Person:
@staticmethod
def __new__(cls, name):
return super().__new__(cls)
à don't need to use @staticmethod
class Person:
def __new__(cls, name):
return super().__new__(cls)
Copyright © MathByte Academy

Copyright © MathByte Academy

Classes are created somehow…
class Person:
pass
When Python encounters a class as it compiles (executes) our code
à a symbol Person is created in the namespace
à that symbol is a reference to the class Person (it is an object)
à how does Python create that class?
à a class is an instance of type
à that's why a class is also called a type
à type is a callable
(and is in fact a type (class) itself, and inherits from object)
Copyright © MathByte Academy

The inner mechanics of class creation
Step 1: The class body is extracted (basically just a blob of text, but it is valid code)
class Person:
planet = 'Earth'
name = property(fget=lambda self: self._name)
def __init__(self, name):
self._name = name
class body
Step 2: A new dictionary is created – this will be the namespace of the new class
Step 3: the body code is executed inside that namespace, thereby populating the namespace
(Think of this code directly inside a module: after the code has been executed, the 
module namespace will contain planet, name, __init__)
Step 4: A new type instance is created using the name of the class, the base 
classes and the populated dictionary
class name
à type(class_name, class_bases, class_dict)
Copyright © MathByte Academy

Calling type
à type is itself a class
what happens when we call type?
à type(class_name, class_bases, class_dict)
à creates an instance of type
what happens when we call a custom class (e.g. Person('Alex'))?
à creates an instance of that custom class (e.g. Person instance)
à which will be a type (or class)
à named class_name
à inherits from class_bases
à class dictionary will be class_dict
Copyright © MathByte Academy

type
Copyright © MathByte Academy

Using type to create new types
we saw how to use type to create new types (classes)
type(class_name, class_bases, class_dict)
à type is a class
à type is an object
à like any object it inherits from object
à it has __new__, and __init__
à is is callable
à calls __new__
à just like calling any class
à calling it creates a new instance of type
type(name, bases, cls_dict)
à type.__new__(type, name, bases, cls_dict)
à returns an instance of type
Copyright © MathByte Academy

type is a class, so…
à can be used as a base class for a custom class
class MyType(type)
à we can override __new__
à essentially we can create custom types
MyClass = MyType(name, bases, cls_dict)
à __new__(MyType, name, bases, cls_dict)
à returns an instance of MyType
à instance is still a type instance 
à but MyType subclasses type
à tweak things, but delegate to type for actual type creation
Copyright © MathByte Academy

Copyright © MathByte Academy

Finally…
we have reached the point where metaclasses becomes easy!
à we saw how type is used to create classes
type(name, bases, dict_)
à we saw how we can customize type by subclassing it and overriding __new__
MyType(name, bases, dict_)
à tedious!
get the class code as text
create the class dictionary
exec the code within that dictionary
determine the bases
call type (or MyType)
Copyright © MathByte Academy

Creating classes normally
à to create a new type (class), we usually don't call type
class Student(Person):
pass
somehow Python does all the manual steps we were doing
à class name, bases, class dictionary, class body code
à and calls type(name, bases, dict_)
à so if we have
class MyType(type):
def __new__(cls, name, bases, dict_):
…
à we just want to tell Python
use this
instead of this
à "this" has a technical name…
à metaclass
Copyright © MathByte Academy

Metaclass
à to create a class, another class is used
à typically type
à the class used to create a class, is called the metaclass of that class
à by default Python uses type as the metaclass
à but we can override this
class Person(metaclass=MyType):
…
à so default is actually:
class Person(metaclass=type):
…
Copyright © MathByte Academy

Putting it together
class MyType(type):
def __new__(mcls, name, bases, cls_dict):
# tweak things
# create the class itself via delegation
new_class = super().__new__(mcls, name, bases, cls_dict)
# tweak some more
# and return the new class
return new_class
first argument is the metaclass (MyType)
class Person(metaclass=MyType):
def __init__(self, name):
self.name = name
second argument is the name of the class being created
does all the manual steps: name, code, class dict, 
bases
then calls MyType(name, bases, cls_dict)
à MyType.__new__(MyType, name, bases, cls_dict)
Copyright © MathByte Academy

Copyright © MathByte Academy

Metaclasses aren't always the best approach…
à metaclasses are very powerful
à but they can be hard to understand when reading code
à sometimes decorators can work just as well
à generally easier to understand
à more functional in nature
Copyright © MathByte Academy

Decorating Classes
@my_dec
class MyClass:
…
recall what the decorator @ syntax actually does with a function:
@my_dec
def my_func():
pass
def my_func():
pass
my_func = my_dec(my_func)
à
same with class
@my_dec
class MyClass:
pass
class MyClass:
pass
MyClass = my_dec(MyClass)
à
Copyright © MathByte Academy

Decorating Classes
à write a decorator that expects a class as the input
à and returns the tweaked class
def savings_account(cls):
cls.account_type = 'Savings'
return cls
@savings_account
class BankAccount:
def __init__(self, account_number, balance):
self.account_number = account_number
self.balance = balance
same as doing this:
class BankAccount:
def __init__(self, account_number, balance):
self.account_number = account_number
self.balance = balance
BankAccount = savings_account(BankAccount)
à class is created first
à then it's decorated
Copyright © MathByte Academy

Can even make the decorator parametrized
def apr(rate):
def inner(cls):
cls.apr = apr
cls.apy = …
return cls
return inner
à account_type is a decorator factory
à it returns a decorator
@apr(0.02)
class SavingsAccount():
pass
@apr(0.0)
class CheckingAccount():
pass
à could use a metaclass instead
à would need to pass the rate parameter to the metaclass
à possible, we haven't learned that yet
à overkill!
Copyright © MathByte Academy

Class decorators can be used to…
create, delete or modify class attributes
à plain attributes
à modify methods
à maybe even apply decorators to class methods
à this is also metaprogramming
Copyright © MathByte Academy

Copyright © MathByte Academy

Classes can be used as decorators too
à don't confuse with class decorators
à Class instances can be callable
à implement __call__ method
à parallel to decorator functions
def decorator(fn):
def wrapper(*args, **kwargs):
return fn(*args, **kwargs)
return wrapper
class Decorator:
def __init__(self, fn):
self.fn = fn
def __call__(self, *args, **kwargs):
return self.fn(*args, **kwargs)
fn is captured by closure
fn is captured by __init__
fn is called by calling wrapper
fn is called by calling __call__
à here we want to use a class to decorate functions
Copyright © MathByte Academy

Function vs Class approach
my_func = decorator(my_func)
à calling my_func actually calls the wrapped function returned from calling decorator
my_func = Decorator(my_func)
def decorator(fn):
def wrapper(*args, **kwargs):
return fn(*args, **kwargs)
return wrapper
class Decorator:
def __init__(self, fn):
self.fn = fn
def __call__(self, *args, **kwargs):
return self.fn(*args, **kwargs)
à my_func is an instance of Decorator
à calling my_func calls the __call__ method of the instance
Copyright © MathByte Academy

Major Difference
à both approaches work fine to decorate functions
à one major difference
à function decorator, decorated function is still a function
à class decorator, decorated function is now an instance of a class
à it is not a function
Copyright © MathByte Academy

à this affects our ability to decorate class methods using the decorator class
How do functions defined in a class become methods when called from instance?
à functions are non-data descriptors
Major Difference
à Python calls the __get__ method of the function
à if called from instance it returns a bound method
à if not, it just returns itself
à we can implement similar functionality in our decorator
à decorator class will now work with instance, class and static methods
Copyright © MathByte Academy

Copyright © MathByte Academy

Pros and Cons
Class Decorator
Metaclass
easier to understand
harder to understand
can stack decorators
can only specify a single metaclass
subclasses do not "inherit" decorator
subclasses "inherit" parent metaclass
can decorate classes in an 
inheritance chain with different 
decorators
only a single custom metaclass (or 
subclasses thereof, using multiple 
inheritance) can be in play in an 
inheritance chain
Copyright © MathByte Academy

Copyright © MathByte Academy

Metaclass Usage
class Metaclass(type):
def __new__(mcls, name, bases, cls_dict):
return super().__new__(mcls, name, bases, cls_dict)
class MyClass(metaclass=Metaclass):
pass
à can we pass extra parameters to Metaclass.__new__?
à yes, starting in Python 3.6
Copyright © MathByte Academy

Passing Additional Parameters to the Metaclass
class Metaclass(type):
def __new__(mcls, name, bases, cls_dict, arg1, arg2, arg3=None):
return super().__new__(mcls, name, bases, cls_dict)
à specify these extra arguments when we define the custom class
à they must be passed as named arguments
class MyClass(metaclass=Metaclass, arg1=val1, arg2=val2):
pass
why named arguments?
à positional arguments are used to specify parent classes
Copyright © MathByte Academy

__prepare__
Copyright © MathByte Academy

Recall…
à __new__(mcls, name, bases, cls_dict)
à where does cls_dict come from?
When the metaclass is called (via class MyClass(metaclass=MyMeta))
à Python determines and sends to the __new__ method of the metaclass
à in a metaclass
à name of the class we are creating (name)
à the classes we are inheriting from (bases)
à a dictionary used as the class namespace (cls_dict) 
à the metaclass used to create the class (mcls)
à __prepare__ method of the metaclass
à type implements it
Copyright © MathByte Academy

The __prepare__ Method
à type implements a default __prepare__ method
à it is also a static method (like __new__)
à if additional (named) args are passed to metaclass, they are also passed to __prepare__
à Python calls __prepare__ before it calls __new__
à the return value of __prepare__ must be a mapping type (e.g. a dict)
à then calls __new__, passing that return value as the class dictionary argument
à Python manipulates that dictionary a bit
Copyright © MathByte Academy

__call__
Copyright © MathByte Academy

class Student(Person, metaclass=MyMeta):
class_attr = 100
def my_func(self):
pass
Declarative Creation of Classes
when Python executes this code:
it is essentially doing the following steps for us:
à name = 'Student'
à bases = (Person, )
à creates a class dictionary, by calling __prepare__
à executes the class body within that class dictionary
à calls the metaclass to create the Student class
à assigns the created class to the symbol Student in our scope
MyMeta(name, bases, class_dict)
à plus a few other things (__qualname__, __doc__)
Copyright © MathByte Academy

Programmatic Creation of Classes
We can reproduce those same steps ourselves
à define name, bases
à create an initial class dictionary
(so like calling __prepare__, but there is no __prepare__
here, we're on our own)
à execute the code in the context of the class dictionary
à fully populated class dictionary
à calculate and add __qualname__ to class dictionary
à add __doc__ to class dictionary
à call metaclass
type(name, bases, class_dict)
à there's a lot going on
à at the end though, the metaclass is called
Copyright © MathByte Academy

How do we make instances of our custom class callable?
à implement the __call__ method in our class
à instances of the class Person are now callable
class Person:
def __call__(self):
print('__call__')
p = Person()
à call the class to create an instance of it
p()
à '__call__'
à __call__ was called as a method bound to p
à so an object is callable if the class used to create it implements __call__
à but the Person class is itself callable
à so the class used to create Person must implement __call__
à the metaclass of Person
Copyright © MathByte Academy

What does the __call__ Method in  type do?
à it is called when we create instances of our  Person class
p = Person(…)
à calls Person.__new__ to create a new instance of the Person class
à calls __init__ bound to that new instance returned by __new__
à type is a class that implements a __call__ method
à it will get called as a method bound to the Person class
à returns the new, initialized instance of Person
Copyright © MathByte Academy

Person
__new__
__init__
type/custom
__call__
p = Person()
instance creation
instance
of
type.__call__
Person.__new__
Person
instance
initialized instance of Person
Instance Creation
Copyright © MathByte Academy

The metaclass of type
à a class is callable because it's metaclass implements __call__
à every class has a metaclass
à the class we use to create the class
à type is a class
à it also has a metaclass
à type(type) is type
à itself
à so it has a __call__ method
à that's why type is callable
à it behaves the same way
à calls type.__new__
à returns the newly created object (the class)
à calls __init__ bound to the newly created object (the class)
à returns the newly created object (the class)
Copyright © MathByte Academy

type/custom
__new__
__init__
type(type/custom)
__call__
Person = type(name, bases, cls_dict)
instance (of type) creation
instance
of
type.__call__
type.__new__
Person
class
initialized Person class
Class Creation
Copyright © MathByte Academy

Python process
__qualname__
__docs__
Declarative Approach
à when we use class declaration, process is almost the same, just tweaked a bit
class Person(metaclass=type):
…
type(type/custom)
__call__
instance (of type) creation
type/custom
__new__
__init__
__prepare__
new Person class
Copyright © MathByte Academy

Copyright © MathByte Academy

The Attribute Accessors
Whenever we write code like this:
print(person.name)
or
getattr(person, 'name')
à we are getting an attribute value from the object
à Python is doing that for us
à as we have seen, that attribute's value could be living in any number of places
à instance dictionary
à class attribute
à descriptor
à in a parent class
Copyright © MathByte Academy

The __getattribute__ Method
à getting an attribute value will call __getattribute__ on our object
à Python provides a default implementation
à it does a lot of work!
à but we can override it
à implement __getattribute__(self, name)
à if we do, we often use super().__getattribute__ to do the actual work
à remember even calling a method first needs to get the method from the object
à special __ methods are looked up differently than our own attributes
Copyright © MathByte Academy

The __getattr__ Method
If the __getattribute__ method cannot find the requested attribute
à raises AttributeError
à Python then tries to call __getattr__
à think of it as a "last resort" attempt to find an attribute
à but only called if __getattribute__ fails to find attribute
à we can also override this method
à default implementation does nothing but re-raise AttributeError
à more common than overriding __getattribute__
à attribute access is a combination of __getattribute__
and, possibly __getattr__
Copyright © MathByte Academy

Default attribute lookup flow
obj.attr
obj.__getattribute__('attr')
in class (incl parents) dict?
__getattr__
data descriptor?
yes
__get__
yes
return it
yes
__get__
yes
return it
yes
in instance dict?
no
AttributeError
no
in instance dict?
no
non-data descriptor?
no
return class attr
no
AttributeError
can override
can override
(often using 
delegation to 
super)
Copyright © MathByte Academy

Caution
à very easy to get into infinite recursion bugs!
à just use super().__getattribute__ to bypass your own overrides
à we'll see examples in the coding section
Copyright © MathByte Academy

Overriding Access for Class Attributes
à __getattribute__ and __getattr__ are instance methods
à how do we override class attribute access?
à override __getattribute__ and __getattr__ in the metaclass
à since classes are instances of a metaclass
Copyright © MathByte Academy

Copyright © MathByte Academy

The __setattr__ Method
We saw how __getattribute__ and __getattr__ get used
à getting an attribute
What about setting attributes?
à __setattr__(self, name, value)
à there is no __setattribute__ like with the getters
à if setting an attribute that does not exist, it is created in the object __dict__
à unless there is no __dict__
Copyright © MathByte Academy

Default attribute setter flow
obj.attr = value
obj.__setattr__('attr', value)
in class (incl parents) dict?
data descriptor?
yes
__set__
yes
insert / update it
yes
obj.__dict__ available?
no
AttributeError
no
no
can override
(often using 
delegation to 
super)
Copyright © MathByte Academy

à the same caveats regarding infinite recursion apply here 
à for class attributes
à use super().__setattr__
à use metaclass
à especially careful when overriding both getters and setters
Copyright © MathByte Academy

