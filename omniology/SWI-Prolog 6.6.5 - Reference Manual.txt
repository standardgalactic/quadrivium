˜
VU University Amsterdam
De Boelelaan 1081a, 1081 HV Amsterdam
The Netherlands
University of Amsterdam
Kruislaan 419, 1098 VA Amsterdam
The Netherlands
Reference Manual
Updated for version 6.6.5, April 2014
Jan Wielemaker
J.Wielemaker@vu.nl
http://www.swi-prolog.org
SWI-Prolog is a comprehensive and portable implementation of the Prolog programming
language. SWI-Prolog aims to be a robust and scalable implementation supporting a
wide range of applications. In particular, it ships with a wide range of interface libraries,
providing interfaces to other languages, databases, graphics and networking. It provides
extensive support for managing HTML/SGML/XML and RDF documents. The system
is particularly suited for server applications due to robust support for multithreading and
HTTP server libraries.
SWI-Prolog is designed in the ‘Edinburgh tradition’. In addition to the ISO Prolog stan-
dard it is largely compatible to Quintus, SICStus and YAP Prolog. SWI-Prolog provides
a compatibility framework developed in cooperation with YAP and instantiated for YAP,
SICStus and IF/Prolog.
SWI-Prolog aims at providing a good development environment, including extensive ed-
itor support, graphical source-level debugger, autoloading and ‘make’ facility and much
more. SWI-Prolog editor and the PDT plugin for Eclipse provide alternative environ-
ments.
This document gives an overview of the features, system limits and built-in predicates.

˜
This
work
is
licensed
under
the
Creative
Commons
Attribution-
ShareAlike
3.0
Unported
License.
To
view
a
copy
of
this
license,
visit
http://creativecommons.org/licenses/by-sa/3.0/
or
send
a
let-
ter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California,
94041, USA.

Contents
1
Introduction
10
1.1
Positioning SWI-Prolog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
10
1.2
Status and releases
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.3
Should I be using SWI-Prolog? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
1.4
Support the SWI-Prolog project
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
1.5
Implementation history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
1.6
Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2
Overview
15
2.1
Getting started quickly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.1.1
Starting SWI-Prolog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
2.1.2
Executing a query
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
2.2
The user’s initialisation ﬁle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
2.3
Initialisation ﬁles and goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
2.4
Command line options
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
2.4.1
Informational command line options . . . . . . . . . . . . . . . . . . . . . .
18
2.4.2
Command line options for running Prolog . . . . . . . . . . . . . . . . . . .
18
2.4.3
Controlling the stack sizes . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
2.4.4
Running goals from the command line . . . . . . . . . . . . . . . . . . . . .
20
2.4.5
Compilation options
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
2.4.6
Maintenance options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
2.5
GNU Emacs Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
2.6
Online Help . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
2.7
Command line history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
2.8
Reuse of top-level bindings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
2.9
Overview of the Debugger
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
24
2.10 Compilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
2.10.1 During program development
. . . . . . . . . . . . . . . . . . . . . . . . .
27
2.10.2 For running the result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
2.11 Environment Control (Prolog ﬂags)
. . . . . . . . . . . . . . . . . . . . . . . . . .
30
2.12 An overview of hook predicates
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
2.13 Automatic loading of libraries
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
2.14 Garbage Collection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
2.15 Syntax Notes
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
2.15.1 ISO Syntax Support
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
2.16 Rational trees (cyclic terms)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
2.17 Just-in-time clause indexing
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
2.17.1 Future directions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.17.2 Indexing and portability
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2.18 Wide character support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
SWI-Prolog 6.6 Reference Manual

2
2.18.1 Wide character encodings on streams
. . . . . . . . . . . . . . . . . . . . .
52
2.19 System limits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
2.19.1 Limits on memory areas . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
2.19.2 Other Limits
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
2.19.3 Reserved Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
2.20 SWI-Prolog and 64-bit machines . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
2.20.1 Supported platforms
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
2.20.2 Comparing 32- and 64-bits Prolog . . . . . . . . . . . . . . . . . . . . . . .
56
2.20.3 Choosing between 32- and 64-bit Prolog . . . . . . . . . . . . . . . . . . . .
57
3
Initialising and Managing a Prolog Project
58
3.1
The project source ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
3.1.1
File Names and Locations . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
3.1.2
Project Special Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
3.1.3
International source ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3.2
Using modules
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3.3
The test-edit-reload cycle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
3.3.1
Locating things to edit . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
3.3.2
Editing and incremental compilation . . . . . . . . . . . . . . . . . . . . . .
62
3.4
Using the PceEmacs built-in editor . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
3.4.1
Activating PceEmacs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
62
3.4.2
Blufﬁng through PceEmacs
. . . . . . . . . . . . . . . . . . . . . . . . . .
63
3.4.3
Prolog Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
65
3.5
The Graphical Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
67
3.5.1
Invoking the window-based debugger . . . . . . . . . . . . . . . . . . . . .
67
3.6
The Prolog Navigator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
3.7
Cross-referencer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
68
3.8
Accessing the IDE from your program . . . . . . . . . . . . . . . . . . . . . . . . .
70
3.9
Summary of the IDE
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
4
Built-in Predicates
72
4.1
Notation of Predicate Descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
4.2
Character representation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
4.3
Loading Prolog source ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
4.3.1
Conditional compilation and program transformation . . . . . . . . . . . . .
83
4.3.2
Loading ﬁles, active code and threads . . . . . . . . . . . . . . . . . . . . .
86
4.3.3
Quick load ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
88
4.4
Editor Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
4.4.1
Customizing the editor interface . . . . . . . . . . . . . . . . . . . . . . . .
89
4.5
List the program, predicates or clauses . . . . . . . . . . . . . . . . . . . . . . . . .
91
4.6
Verify Type of a Term . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
4.7
Comparison and Uniﬁcation of Terms . . . . . . . . . . . . . . . . . . . . . . . . .
93
4.7.1
Standard Order of Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . .
93
4.7.2
Special uniﬁcation and comparison predicates . . . . . . . . . . . . . . . . .
94
4.8
Control Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
96
4.9
Meta-Call Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
98
4.10 ISO compliant Exception handling . . . . . . . . . . . . . . . . . . . . . . . . . . .
101
SWI-Prolog 6.6 Reference Manual

Contents
3
4.10.1 Debugging and exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . .
102
4.10.2 The exception term . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
103
4.10.3 Printing messages
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
103
4.11 Handling signals
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
107
4.11.1 Notes on signal handling . . . . . . . . . . . . . . . . . . . . . . . . . . . .
108
4.12 DCG Grammar rules
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
108
4.13 Database . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
110
4.13.1 Update view
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
113
4.13.2 Indexing databases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
113
4.14 Declaring predicate properties
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
114
4.15 Examining the program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
115
4.16 Input and output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
4.16.1 Predeﬁned stream aliases . . . . . . . . . . . . . . . . . . . . . . . . . . . .
120
4.16.2 ISO Input and Output Streams . . . . . . . . . . . . . . . . . . . . . . . . .
121
4.16.3 Edinburgh-style I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
128
4.16.4 Switching between Edinburgh and ISO I/O . . . . . . . . . . . . . . . . . .
130
4.16.5 Write onto atoms, code-lists, etc. . . . . . . . . . . . . . . . . . . . . . . . .
130
4.17 Status of streams
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
131
4.18 Primitive character I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
132
4.19 Term reading and writing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
135
4.20 Analysing and Constructing Terms . . . . . . . . . . . . . . . . . . . . . . . . . . .
142
4.20.1 Non-logical operations on terms . . . . . . . . . . . . . . . . . . . . . . . .
144
4.21 Analysing and Constructing Atoms . . . . . . . . . . . . . . . . . . . . . . . . . . .
145
4.22 Localization (locale) support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
148
4.23 Character properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
150
4.23.1 Case conversion
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
152
4.23.2 White space normalization . . . . . . . . . . . . . . . . . . . . . . . . . . .
152
4.23.3 Language-speciﬁc comparison . . . . . . . . . . . . . . . . . . . . . . . . .
152
4.24 Representing text in strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
153
4.25 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
154
4.26 Character Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
4.27 Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
4.27.1 Special purpose integer arithmetic . . . . . . . . . . . . . . . . . . . . . . .
156
4.27.2 General purpose arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . .
156
4.28 Misc arithmetic support predicates . . . . . . . . . . . . . . . . . . . . . . . . . . .
165
4.29 Built-in list operations
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
166
4.30 Finding all Solutions to a Goal . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
168
4.31 Forall
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
169
4.32 Formatted Write . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
170
4.32.1 Writef . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
170
4.32.2 Format
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
171
4.32.3 Programming Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
174
4.33 Terminal Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
175
4.34 Operating System Interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
176
4.34.1 Windows-speciﬁc Operating System Interaction . . . . . . . . . . . . . . . .
177
4.34.2 Dealing with time and date . . . . . . . . . . . . . . . . . . . . . . . . . . .
179
4.34.3 Controlling the swipl-win.exe console window
. . . . . . . . . . . . .
185
SWI-Prolog 6.6 Reference Manual

4
4.35 File System Interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
186
4.36 User Top-level Manipulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
190
4.37 Creating a Protocol of the User Interaction . . . . . . . . . . . . . . . . . . . . . . .
192
4.38 Debugging and Tracing Programs
. . . . . . . . . . . . . . . . . . . . . . . . . . .
192
4.39 Obtaining Runtime Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
195
4.40 Execution proﬁling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
198
4.40.1 Proﬁling predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
198
4.40.2 Visualizing proﬁling data . . . . . . . . . . . . . . . . . . . . . . . . . . . .
199
4.40.3 Information gathering
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
200
4.41 Memory Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
201
4.42 Windows DDE interface
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
202
4.42.1 DDE client interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
202
4.42.2 DDE server mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
203
4.43 Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
204
5
Modules
206
5.1
Why Use Modules? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
206
5.2
Deﬁning a Module
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
206
5.3
Importing Predicates into a Module
. . . . . . . . . . . . . . . . . . . . . . . . . .
207
5.4
Deﬁning a meta-predicate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
209
5.5
Overruling Module Boundaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
211
5.5.1
Explicit manipulation of the calling context . . . . . . . . . . . . . . . . . .
211
5.6
Interacting with modules from the top level
. . . . . . . . . . . . . . . . . . . . . .
212
5.7
Composing modules from other modules . . . . . . . . . . . . . . . . . . . . . . . .
212
5.8
Operators and modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
213
5.9
Dynamic importing using import modules . . . . . . . . . . . . . . . . . . . . . . .
213
5.10 Reserved Modules and using the ‘user’ module
. . . . . . . . . . . . . . . . . . . .
214
5.11 An alternative import/export interface
. . . . . . . . . . . . . . . . . . . . . . . . .
214
5.12 Dynamic Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
215
5.13 Transparent predicates: deﬁnition and context module . . . . . . . . . . . . . . . . .
215
5.14 Module properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
217
5.15 Compatibility of the Module System . . . . . . . . . . . . . . . . . . . . . . . . . .
218
6
Special Variables and Coroutining
219
6.1
Attributed variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
219
6.1.1
Attribute manipulation predicates
. . . . . . . . . . . . . . . . . . . . . . .
221
6.1.2
Attributed variable hooks . . . . . . . . . . . . . . . . . . . . . . . . . . . .
221
6.1.3
Operations on terms with attributed variables . . . . . . . . . . . . . . . . .
222
6.1.4
Special purpose predicates for attributes . . . . . . . . . . . . . . . . . . . .
222
6.2
Coroutining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
223
6.3
Global variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
224
6.3.1
Compatibility of SWI-Prolog Global Variables
. . . . . . . . . . . . . . . .
225
7
CHR: Constraint Handling Rules
226
7.1
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
226
7.2
Syntax and Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
227
7.2.1
Syntax of CHR rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
227
SWI-Prolog 6.6 Reference Manual

Contents
5
7.2.2
Semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
228
7.3
CHR in SWI-Prolog Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
229
7.3.1
Embedding in Prolog Programs
. . . . . . . . . . . . . . . . . . . . . . . .
229
7.3.2
Constraint declaration
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
230
7.3.3
Compilation
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
233
7.4
Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
233
7.4.1
Ports
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
234
7.4.2
Tracing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
234
7.4.3
CHR Debugging Predicates
. . . . . . . . . . . . . . . . . . . . . . . . . .
235
7.5
Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
236
7.6
Backwards Compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
237
7.6.1
The Old SICStus CHR implemenation . . . . . . . . . . . . . . . . . . . . .
237
7.6.2
The Old ECLiPSe CHR implemenation . . . . . . . . . . . . . . . . . . . .
238
7.7
Programming Tips and Tricks
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
238
7.8
Compiler Errors and Warnings . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
239
7.8.1
CHR Compiler Errors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
239
8
Multithreaded applications
241
8.1
Creating and destroying Prolog threads . . . . . . . . . . . . . . . . . . . . . . . . .
241
8.2
Monitoring threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
244
8.3
Thread communication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
245
8.3.1
Message queues
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
245
8.3.2
Signalling threads
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
248
8.3.3
Threads and dynamic predicates . . . . . . . . . . . . . . . . . . . . . . . .
249
8.4
Thread synchronisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
250
8.5
Thread support library(threadutil)
. . . . . . . . . . . . . . . . . . . . . . . . . . .
251
8.5.1
Debugging threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
252
8.5.2
Proﬁling threads
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
253
8.6
Multithreaded mixed C and Prolog applications . . . . . . . . . . . . . . . . . . . .
253
8.6.1
A Prolog thread for each native thread (one-to-one) . . . . . . . . . . . . . .
253
8.6.2
Pooling Prolog engines (many-to-many) . . . . . . . . . . . . . . . . . . . .
255
8.7
Multithreading and the XPCE graphics system . . . . . . . . . . . . . . . . . . . . .
256
9
Foreign Language Interface
257
9.1
Overview of the Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
257
9.2
Linking Foreign Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
257
9.2.1
What linking is provided?
. . . . . . . . . . . . . . . . . . . . . . . . . . .
258
9.2.2
What kind of loading should I be using? . . . . . . . . . . . . . . . . . . . .
258
9.2.3
library(shlib): Utility library for loading foreign objects (DLLs, shared objects) 258
9.2.4
Low-level operations on shared libraries . . . . . . . . . . . . . . . . . . . .
260
9.2.5
Static Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
261
9.3
Interface Data Types
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
262
9.3.1
Type term t: a reference to a Prolog term . . . . . . . . . . . . . . . . . .
262
9.3.2
Other foreign interface types . . . . . . . . . . . . . . . . . . . . . . . . . .
263
9.4
The Foreign Include File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
264
9.4.1
Argument Passing and Control . . . . . . . . . . . . . . . . . . . . . . . . .
264
9.4.2
Atoms and functors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
267
SWI-Prolog 6.6 Reference Manual

6
9.4.3
Analysing Terms via the Foreign Interface . . . . . . . . . . . . . . . . . . .
268
9.4.4
Constructing Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
277
9.4.5
Unifying data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
279
9.4.6
Convenient functions to generate Prolog exceptions . . . . . . . . . . . . . .
285
9.4.7
BLOBS: Using atoms to store arbitrary binary data . . . . . . . . . . . . . .
287
9.4.8
Exchanging GMP numbers . . . . . . . . . . . . . . . . . . . . . . . . . . .
289
9.4.9
Calling Prolog from C . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
291
9.4.10 Discarding Data
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
293
9.4.11 Foreign Code and Modules . . . . . . . . . . . . . . . . . . . . . . . . . . .
294
9.4.12 Prolog exceptions in foreign code . . . . . . . . . . . . . . . . . . . . . . .
295
9.4.13 Catching Signals (Software Interrupts) . . . . . . . . . . . . . . . . . . . . .
297
9.4.14 Miscellaneous
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
298
9.4.15 Errors and warnings
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
300
9.4.16 Environment Control from Foreign Code
. . . . . . . . . . . . . . . . . . .
301
9.4.17 Querying Prolog
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
302
9.4.18 Registering Foreign Predicates . . . . . . . . . . . . . . . . . . . . . . . . .
302
9.4.19 Foreign Code Hooks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
305
9.4.20 Storing foreign data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
306
9.4.21 Embedding SWI-Prolog in other applications . . . . . . . . . . . . . . . . .
309
9.5
Linking embedded applications using swipl-ld . . . . . . . . . . . . . . . . . . . . .
312
9.5.1
A simple example
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
314
9.6
The Prolog ‘home’ directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
315
9.7
Example of Using the Foreign Interface
. . . . . . . . . . . . . . . . . . . . . . . .
317
9.8
Notes on Using Foreign Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
319
9.8.1
Memory Allocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
319
9.8.2
Compatibility between Prolog versions
. . . . . . . . . . . . . . . . . . . .
319
9.8.3
Debugging and proﬁling foreign code (valgrind)
. . . . . . . . . . . . . . .
320
9.8.4
Name Conﬂicts in C modules
. . . . . . . . . . . . . . . . . . . . . . . . .
320
9.8.5
Compatibility of the Foreign Interface . . . . . . . . . . . . . . . . . . . . .
320
10 Generating Runtime Applications
322
10.1 Limitations of qsave program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
324
10.2 Runtimes and Foreign Code
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
324
10.3 Using program resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
325
10.3.1 Resource manipulation predicates . . . . . . . . . . . . . . . . . . . . . . .
326
10.3.2 The swipl-rc program . . . . . . . . . . . . . . . . . . . . . . . . . . . .
327
10.4 Finding Application ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
327
10.4.1 Specifying a ﬁle search path from the command line
. . . . . . . . . . . . .
328
A The SWI-Prolog library
329
A.1
library(aggregate): Aggregation operators on backtrackable predicates . . . . . . . .
329
A.2
library(apply): Apply predicates on a list . . . . . . . . . . . . . . . . . . . . . . . .
332
A.3
library(assoc): Association lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
333
A.4
library(broadcast): Broadcast and receive event notiﬁcations
. . . . . . . . . . . . .
334
A.5
library(charsio): I/O on Lists of Character Codes
. . . . . . . . . . . . . . . . . . .
336
A.6
library(check): Elementary completeness checks
. . . . . . . . . . . . . . . . . . .
338
A.7
library(clpfd): Constraint Logic Programming over Finite Domains . . . . . . . . . .
338
SWI-Prolog 6.6 Reference Manual

Contents
7
A.8
library(clpqr): Constraint Logic Programming over Rationals and Reals . . . . . . .
354
A.8.1
Solver predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
355
A.8.2
Syntax of the predicate arguments . . . . . . . . . . . . . . . . . . . . . . .
356
A.8.3
Use of uniﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
356
A.8.4
Non-linear constraints
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
357
A.8.5
Status and known problems
. . . . . . . . . . . . . . . . . . . . . . . . . .
357
A.9
library(csv): Process CSV (Comma-Separated Values) data . . . . . . . . . . . . . .
358
A.10 library(debug): Print debug messages and test assertions
. . . . . . . . . . . . . . .
359
A.11 library(gensym): Generate unique identiﬁers . . . . . . . . . . . . . . . . . . . . . .
361
A.12 library(lists): List Manipulation
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
362
A.13 library(nb set): Non-backtrackable set . . . . . . . . . . . . . . . . . . . . . . . . .
366
A.14 library(www browser): Activating your Web-browser . . . . . . . . . . . . . . . . .
367
A.15 library(option): Option list processing . . . . . . . . . . . . . . . . . . . . . . . . .
367
A.16 library(optparse): command line parsing . . . . . . . . . . . . . . . . . . . . . . . .
369
A.16.1 Notes and tips . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
373
A.17 library(ordsets): Ordered set manipulation . . . . . . . . . . . . . . . . . . . . . . .
375
A.18 library(pairs): Operations on key-value lists . . . . . . . . . . . . . . . . . . . . . .
378
A.19 library(pio): Pure I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
379
A.19.1 library(pure input): Pure Input from ﬁles
. . . . . . . . . . . . . . . . . . .
379
A.20 library(predicate options): Declare option-processing of predicates . . . . . . . . . .
380
A.20.1 The strength and weakness of predicate options . . . . . . . . . . . . . . . .
381
A.20.2 Options as arguments or environment? . . . . . . . . . . . . . . . . . . . . .
381
A.20.3 Improving on the current situation . . . . . . . . . . . . . . . . . . . . . . .
382
A.21 library(prolog pack): A package manager for Prolog
. . . . . . . . . . . . . . . . .
385
A.22 library(prolog xref): Cross-reference data collection library . . . . . . . . . . . . . .
387
A.22.1 Extending the library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
388
A.23 library(quasi quotations): Deﬁne Quasi Quotation syntax . . . . . . . . . . . . . . .
388
A.24 library(random): Random numbers . . . . . . . . . . . . . . . . . . . . . . . . . . .
390
A.25 library(readutil): Reading lines, streams and ﬁles
. . . . . . . . . . . . . . . . . . .
392
A.26 library(record): Access named ﬁelds in a term . . . . . . . . . . . . . . . . . . . . .
393
A.27 library(registry): Manipulating the Windows registry
. . . . . . . . . . . . . . . . .
395
A.28 library(simplex): Solve linear programming problems . . . . . . . . . . . . . . . . .
396
A.28.1 Example 1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
398
A.28.2 Example 2
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
398
A.28.3 Example 3
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
399
A.29 library(thread pool): Resource bounded thread management
. . . . . . . . . . . . .
400
A.30 library(ugraphs): Unweighted Graphs
. . . . . . . . . . . . . . . . . . . . . . . . .
402
A.31 library(url): Analysing and constructing URL . . . . . . . . . . . . . . . . . . . . .
405
A.32 library(varnumbers): Utilities for numbered terms . . . . . . . . . . . . . . . . . . .
408
B
Hackers corner
409
B.1
Examining the Environment Stack . . . . . . . . . . . . . . . . . . . . . . . . . . .
409
B.2
Ancestral cuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
411
B.3
Syntax extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
411
B.3.1
Block operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
412
B.4
Intercepting the Tracer
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
413
B.5
Breakpoint and watchpoint handling . . . . . . . . . . . . . . . . . . . . . . . . . .
415
SWI-Prolog 6.6 Reference Manual

8
B.6
Adding context to errors: prolog exception hook
. . . . . . . . . . . . . . . . . . .
416
B.7
Hooks using the exception predicate . . . . . . . . . . . . . . . . . . . . . . . . . .
417
B.8
Hooks for integrating libraries
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
417
B.9
Hooks for loading ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
418
B.10 Readline Interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
419
C Compatibility with other Prolog dialects
420
C.1
Some considerations for writing portable code . . . . . . . . . . . . . . . . . . . . .
421
D Glossary of Terms
424
E
SWI-Prolog License Conditions and Tools
429
E.1
The SWI-Prolog kernel and foreign libraries . . . . . . . . . . . . . . . . . . . . . .
429
E.1.1
The SWI-Prolog Prolog libraries . . . . . . . . . . . . . . . . . . . . . . . .
429
E.2
Contributing to the SWI-Prolog project
. . . . . . . . . . . . . . . . . . . . . . . .
430
E.3
Software support to keep track of license conditions . . . . . . . . . . . . . . . . . .
430
E.4
License conditions inherited from used code . . . . . . . . . . . . . . . . . . . . . .
431
E.4.1
Cryptographic routines . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
431
F
Summary
433
F.1
Predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
433
F.2
Library predicates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
448
F.2.1
library(aggregate) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
448
F.2.2
library(apply) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
448
F.2.3
library(assoc) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
448
F.2.4
library(broadcast) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
449
F.2.5
library(charsio) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
449
F.2.6
library(check) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
449
F.2.7
library(csv) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
449
F.2.8
library(lists) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
450
F.2.9
library(debug)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
450
F.2.10 library(option)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
451
F.2.11 library(optparse) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
451
F.2.12 library(ordsets) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
451
F.2.13 library(predicate options)
. . . . . . . . . . . . . . . . . . . . . . . . . . .
451
F.2.14 library(prologpack) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
452
F.2.15 library(prologxref) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
452
F.2.16 library(pairs) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
452
F.2.17 library(pio) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
453
F.2.18 library(random) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
453
F.2.19 library(readutil) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
453
F.2.20 library(record)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
453
F.2.21 library(registry) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
453
F.2.22 library(ugraphs) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
454
F.2.23 library(url)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
454
F.2.24 library(www browser) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
454
F.2.25 library(clp/clpfd) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
455
SWI-Prolog 6.6 Reference Manual

Contents
9
F.2.26 library(clpqr) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
455
F.2.27 library(clp/simplex) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
456
F.2.28 library(thread pool) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
456
F.2.29 library(varnumbers)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
456
F.3
Arithmetic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
457
F.4
Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
459
SWI-Prolog 6.6 Reference Manual

Introduction
1
This document is a reference manual. That means that it documents the system, but it does not
explain the basics of the Prolog language and it leaves many details of the syntax, semantics and built-
in primitives undeﬁned where SWI-Prolog follows the standards. This manual is intended for people
that are familiar with Prolog. For those not familiar with Prolog, we recommend to start with a Prolog
textbook such as [Bratko, 1986], [Sterling & Shapiro, 1986] or [Clocksin & Melish, 1987]. For more
advanced Prolog usage we recommend [O’Keefe, 1990].
1.1
Positioning SWI-Prolog
Most implementations of the Prolog language are designed to serve a limited set of use cases. SWI-
Prolog is no exception to this rule. SWI-Prolog positions itself primarily as a Prolog environment for
‘programming in the large’ and use cases where it plays a central role in an application, i.e., where
it acts as ‘glue’ between components. At the same time, SWI-Prolog aims at providing a productive
rapid prototyping environment. Its orientation towards programming in the large is backed up by scal-
ability, compiler speed, program structuring (modules), support for multithreading to accommodate
servers, Unicode and interfaces to a large number of document formats, protocols and programming
languages. Prototyping is facilitated by good development tools, both for command line usage as for
usage with graphical development tools. Demand loading of predicates from the library and a ‘make’
facility avoids the requirement for using declarations and reduces typing.
SWI-Prolog is traditionally strong in education because it is free and portable, but also because of
its compatibility with textbooks and its easy-to-use environment.
Note that these positions do not imply that the system cannot be used with other scenarios. SWI-
Prolog is used as an embedded language where it serves as a small rule subsystem in a large applica-
tion. It is also used as a deductive database. In some cases this is the right choice because SWI-Prolog
has features that are required in the application, such as threading or Unicode support. In general
though, for example, GNU-Prolog is more suited for embedding because it is small and can com-
pile to native code, XSB is better for deductive databases because it provides advanced resolution
techniques (tabling), and ECLiPSe is better at constraint handling.
The syntax and set of built-in predicates is based on the ISO standard [Hodgson, 1998]. Most
extensions follow the ‘Edinburgh tradition’ (DEC10 Prolog and C-Prolog) and Quintus Prolog
[Qui, 1997]. The infrastructure for constraint programming is based on hProlog [Demoen, 2002].
Some libraries are copied from the YAP1 system. Together with YAP we developed a portability
framework (see section C). This framework has been ﬁlled for SICStus Prolog, YAP and IF/Prolog.
1http://www.dcc.fc.up.pt/˜vsc/Yap/
SWI-Prolog 6.6 Reference Manual

1.2. STATUS AND RELEASES
11
1.2
Status and releases
This manual describes version 6.6 of SWI-Prolog. SWI-Prolog is widely considered to be a ro-
bust and scalable implementation of the Prolog language. It is widely used in education and re-
search. In addition, it is in use for 24 × 7 mission critical commercial server processes. The site
http://www.swi-prolog.org is hosted using the SWI-Prolog HTTP server infrastructure. It
receives approximately 2.3 million hits and serves approximately 300 Gbytes on manual data and
downloads each month. SWI-Prolog applications range from student assignments to commercial ap-
plications that count more than one million lines of Prolog code.
SWI-Prolog has two development tracks. Stable releases have an even minor version number
(e.g., 6.2.1) and are released as a branch from the development version when the development version
is considered stable and there is sufﬁcient new functionality to justify a stable release. Stable releases
often get a few patch updates to deal with installation issues or major ﬂaws. A new Development
version is typically released every couple of weeks as a snapshot of the public git repository. ‘Extra
editions’ of the development version may be released after problems that severely hindered the user
in their progress have been ﬁxed.
Known bugs that are not likely to be ﬁxed soon are described as footnotes in this manual.
1.3
Should I be using SWI-Prolog?
There are a number of reasons why it might be better to choose a commercial, or another free, Prolog
system:
• SWI-Prolog comes with no warranties
Although the developers or the community often provide a work-around or a ﬁx for a bug, there
is no place you can go to for guaranteed support. However, the full source archive is available
and can be used to compile and debug SWI-Prolog using free tools on all major platforms.
Users requiring more support should ensure access to knowledgeable developers.
• Performance is your ﬁrst concern
Various free and commercial systems have better performance. But, ‘standard’ Prolog bench-
marks disregard many factors that are often critical to the performance of large applications.
SWI-Prolog is not good at fast calling of simple predicates and if-then-else selection based on
simple built-in tests, but it is fast with dynamic code, meta-calling and predicates that contain
large numbers of clauses. Many of SWI-Prolog’s built-in predicates are written in C and have
excellent performance.
• You need features not offered by SWI-Prolog
Although SWI-Prolog has many features, it also lacks some important features. The most well
known is probably tabling [Freire et al., 1997]. If you require additional features and you have
resources, be it ﬁnancial or expertise, please contact the developers.
On the other hand, SWI-Prolog offers some facilities that are widely appreciated by users:
• Nice environment
SWI-Prolog provides a good command line environment, including ‘Do What I Mean’, auto-
completion, history and a tracer that operates on single key strokes. The system automatically
recompiles modiﬁed parts of the source code using the make/0 command. The system can
SWI-Prolog 6.6 Reference Manual

12
CHAPTER 1. INTRODUCTION
be instructed to open an arbitrary editor on the right ﬁle and line based on its source database.
It ships with various graphical tools and can be combined with the SWI-Prolog editor, PDT
(Eclipse plugin for Prolog) or GNU-Emacs.
• Fast compiler
Even very large applications can be loaded in seconds on most machines. If this is not enough,
there is the Quick Load Format. See qcompile/1 and qsave program/2.
• Transparent compiled code
SWI-Prolog compiled code can be treated just as interpreted code: you can list it, trace it, etc.
This implies you do not have to decide beforehand whether a module should be loaded for
debugging or not, and the performance of debugged code is close to that of normal operation.
• Source level debugger
The source level debugger provides a good overview of your current location in the search tree,
variable bindings, your source code and open choice points. Choice point inspection provides
meaningful insight to both novices and experienced users. Avoiding unintended choice points
often provides a huge increase in performance and a huge saving in memory usage.
• Proﬁling
SWI-Prolog offers an execution proﬁler with either textual output or graphical output. Finding
and improving hotspots in a Prolog program may result in huge speedups.
• Flexibility
SWI-Prolog can easily be integrated with C, supporting non-determinism in Prolog calling C
as well as C calling Prolog (see section 9). It can also be embedded in external programs (see
section 9.5). System predicates can be redeﬁned locally to provide compatibility with other
Prolog systems.
• Threads
Robust support for multiple threads may improve performance and is a key enabling factor for
deploying Prolog in server applications.
• Interfaces
SWI-Prolog ships with many extension packages that provide robust interfaces to processes,
encryption, TCP/IP, TIPC, ODBC, SGML/XML/HTML, RDF, HTTP, graphics and much more.
1.4
Support the SWI-Prolog project
You can support the SWI-Prolog project in several ways. Academics are invited to cite one of the
publications2 on SWI-Prolog. Users can help by identifying and/or ﬁxing problems with the code or
its documentation.3. Users can contribute new features or, more lightweight, contribute packs4. Com-
mercial users may consider contacting the developers5 to sponsor the development of new features or
seek for opportunities to cooperate with the developers or other commercial users.
2http://www.swi-prolog.org/Publications.html
3http://www.swi-prolog.org/howto/SubmitPatch.html
4http://www.swi-prolog.org/pack/list
5mailto:info@swi-prolog.org
SWI-Prolog 6.6 Reference Manual

1.5. IMPLEMENTATION HISTORY
13
1.5
Implementation history
SWI-Prolog started back in 1986 with the requirement for a Prolog that could handle recursive inter-
action with the C-language: Prolog calling C and C calling Prolog recursively. In those days Prolog
systems were not very aware of their environment and we needed such a system to support interactive
applications. Since then, SWI-Prolog’s development has been guided by requests from the user com-
munity, especially focussing on (in arbitrary order) interaction with the environment, scalability, (I/O)
performance, standard compliance, teaching and the program development environment.
SWI-Prolog is based on a simple Prolog virtual machine called ZIP [Bowen et al., 1983,
Neumerkel, 1993] which deﬁnes only 7 instructions. Prolog can easily be compiled into this lan-
guage, and the abstract machine code is easily decompiled back into Prolog. As it is also possible
to wire a standard 4-port debugger in the virtual machine, there is no need for a distinction between
compiled and interpreted code. Besides simplifying the design of the Prolog system itself, this ap-
proach has advantages for program development: the compiler is simple and fast, the user does not
have to decide in advance whether debugging is required, and the system only runs slightly slower in
debug mode compared to normal execution. The price we have to pay is some performance degra-
dation (taking out the debugger from the VM interpreter improves performance by about 20%) and
somewhat additional memory usage to help the decompiler and debugger.
SWI-Prolog extends the minimal set of instructions described in [Bowen et al., 1983] to improve
performance. While extending this set, care has been taken to maintain the advantages of decompi-
lation and tracing of compiled code. The extensions include specialised instructions for uniﬁcation,
predicate invocation, some frequently used built-in predicates, arithmetic, and control (;/2, |/2),
if-then (->/2) and negation-by-failure (\+/1).
1.6
Acknowledgements
Some small parts of the Prolog code of SWI-Prolog are modiﬁed versions of the corresponding Edin-
burgh C-Prolog code: grammar rule compilation and writef/2. Also some of the C-code originates
from C-Prolog: ﬁnding the path of the currently running executable and some of the code underlying
absolute file name/2. Ideas on programming style and techniques originate from C-Prolog
and Richard O’Keefe’s thief editor. An important source of inspiration are the programming tech-
niques introduced by Anjo Anjewierden in PCE version 1 and 2.
Our special thanks go to those who had the fate of using the early versions of this system, sug-
gested extensions or reported bugs. Among them are Anjo Anjewierden, Huub Knops, Bob Wielinga,
Wouter Jansweijer, Luc Peerdeman, Eric Nombden, Frank van Harmelen, Bert Rengel.
Martin Jansche (jansche@novell1.gs.uni-heidelberg.de) has been so kind to reor-
ganise the sources for version 2.1.3 of this manual. Horst von Brand has been so kind to ﬁx many
typos in the 2.7.14 manual. Thanks! Randy Sharp ﬁxed many issues in the 6.0.x version of the manual.
Bart Demoen and Tom Schrijvers have helped me adding coroutining, constraints, global variables
and support for cyclic terms to the kernel. Tom Schrijvers has provided a ﬁrst clp(fd) constraint solver,
the CHR compiler and some of the coroutining predicates. Markus Triska contributed the current
clp(fd) implementation.
Paul Singleton has integrated Fred Dushin’s Java-calls-Prolog side with his Prolog-calls-Java side
into the current bidirectional JPL interface package.
Richard O’Keefe is gratefully acknowledged for his efforts to educate beginners as well as valu-
able comments on proposed new developments.
SWI-Prolog 6.6 Reference Manual

14
CHAPTER 1. INTRODUCTION
Scientiﬁc Software and Systems Limited, www.sss.co.nz has sponsored the development of
the SSL library, unbounded integer and rational number arithmetic and many enhancements to the
memory management of the system.
Leslie de Koninck has made clp(QR) available to SWI-Prolog.
Jeff Rosenwald contributed the TIPC networking library and Google’s protocol buffer handling.
Paulo Moura’s great experience in maintaining Logtalk for many Prolog systems including SWI-
Prolog has helped in many places ﬁxing compatibility issues. He also worked on the MacOS port and
ﬁxed many typos in the 5.6.9 release of the documentation.
SWI-Prolog 6.6 Reference Manual

Overview
2
2.1
Getting started quickly
2.1.1
Starting SWI-Prolog
Starting SWI-Prolog on Unix
By default, SWI-Prolog is installed as ‘swipl’. The command line arguments of SWI-Prolog itself
and its utility programs are documented using standard Unix man pages. SWI-Prolog is normally
operated as an interactive application simply by starting the program:
machine% swipl
Welcome to SWI-Prolog ...
...
1 ?-
After starting Prolog, one normally loads a program into it using consult/1, which may be abbre-
viated by putting the name of the program ﬁle between square brackets. The following goal loads the
ﬁle likes.pl containing clauses for the predicates likes/2:
?- [likes].
% likes compiled, 0.00 sec, 17 clauses
true.
?-
After this point, Unix and Windows users unite, so if you are using Unix please continue at sec-
tion 2.1.2.
Starting SWI-Prolog on Windows
After SWI-Prolog has been installed on a Windows system, the following important new things are
available to the user:
• A folder (called directory in the remainder of this document) called swipl containing the
executables, libraries, etc., of the system. No ﬁles are installed outside this directory.
• A program swipl-win.exe, providing a window for interaction with Prolog. The program
swipl.exe is a version of SWI-Prolog that runs in a console window.
SWI-Prolog 6.6 Reference Manual

16
CHAPTER 2. OVERVIEW
• The ﬁle extension .pl is associated with the program swipl-win.exe. Opening a .pl
ﬁle will cause swipl-win.exe to start, change directory to the directory in which the ﬁle to
open resides, and load this ﬁle.
The normal way to start the likes.pl ﬁle mentioned in section 2.1.1 is by simply double-
clicking this ﬁle in the Windows explorer.
2.1.2
Executing a query
After loading a program, one can ask Prolog queries about the program. The query below asks Prolog
what food ‘sam’ likes. The system responds with X = ⟨value⟩if it can prove the goal for a certain
X. The user can type the semi-colon (;) or spacebar1 if (s)he wants another solution. Use the RETURN
key if you do not want to see the more answers. Prolog completes the output with a full stop (.) if
the user uses the RETURN key or Prolog knows there are no more answers. If Prolog cannot ﬁnd
(more) answers, it writes false. Finally, Prolog answers using an error message to indicate the query
or program contains an error.
?- likes(sam, X).
X = dahl ;
X = tandoori ;
...
X = chips.
?-
Note that the answer written by Prolog is a valid Prolog program that, when executed, produces the
same set of answers as the original program.2
2.2
The user’s initialisation ﬁle
After the system initialisation, the system consults (see consult/1) the user’s startup ﬁle. The
basename of this ﬁle follows conventions of the operating system. On MS-Windows, it is the ﬁle
pl.ini and on Unix systems .plrc. The ﬁle is searched using the file search path/2
clauses for user profile.3 The table below shows the default value for this search path. The
phrase ⟨appdata⟩refers to the Windows CSIDL name for the folder. The actual name depends on the
Windows language. English versions typically use ApplicationData. See also win folder/2
Unix
Windows
home
˜
⟨appdata⟩/SWI-Prolog
After the ﬁrst startup ﬁle is found it is loaded and Prolog stops looking for further startup ﬁles. The
name of the startup ﬁle can be changed with the ‘-f file’ option. If File denotes an absolute path,
1On most installations, single-character commands are executed without waiting for the RETURN key.
2The SWI-Prolog top level differs in several ways from traditional Prolog top level. The current top level was designed
in cooperation with Ulrich Neumerkel.
3Older versions ﬁrst searched in the current working directory. This feature has been removed for security reasons.
Users can implement loading a setup ﬁle from the working directory in their global preference ﬁle.
SWI-Prolog 6.6 Reference Manual

2.3. INITIALISATION FILES AND GOALS
17
this ﬁle is loaded, otherwise the ﬁle is searched for using the same conventions as for the default
startup ﬁle. Finally, if ﬁle is none, no ﬁle is loaded.
The installation provides a ﬁle customize/dotplrc with (commented) commands that are
often used to customize the behaviour of Prolog, such as interfacing to the editor, color selection or
history parameters. Many of the development tools provide menu entries for editing the startup ﬁle
and starting a fresh startup ﬁle from the system skeleton.
See also the -s (script) and -F (system-wide initialisation) in section 2.4 and section 2.3.
2.3
Initialisation ﬁles and goals
Using command line arguments (see section 2.4), SWI-Prolog can be forced to load ﬁles and execute
queries for initialisation purposes or non-interactive operation. The most commonly used options are
-f file or -s file to make Prolog load a ﬁle, -g goal to deﬁne an initialisation goal and
-t goal to deﬁne the top-level goal. The following is a typical example for starting an application
directly from the command line.
machine% swipl -s load.pl -g go -t halt
It tells SWI-Prolog to load load.pl, start the application using the entry point go/0 and —instead
of entering the interactive top level— exit after completing go/0. The -q may be used to suppress
all informational messages.
In MS-Windows, the same can be achieved using a short-cut with appropriately deﬁned command
line arguments. A typically seen alternative is to write a ﬁle run.pl with content as illustrated below.
Double-clicking run.pl will start the application.
:- [load].
% load program
:- go.
% run it
:- halt.
% and exit
Section 2.10.2 discusses further scripting options, and chapter 10 discusses the generation of runtime
executables. Runtime executables are a means to deliver executables that do not require the Prolog
system.
2.4
Command line options
SWI-Prolog can be executed in one of the following modes:
swipl --help
swipl --version
swipl --arch
swipl --dump-runtime-variables
These options must appear as only option. They cause Prolog to print an informational message
and exit. See section 2.4.1.
SWI-Prolog 6.6 Reference Manual

18
CHAPTER 2. OVERVIEW
swipl [option ...] script-ﬁle [arg ...]
These
arguments
are
passed
on
Unix
systems
if
ﬁle
that
starts
with
#!/path/to/executable [option ...] is executed.
Arguments after the script ﬁle
are made available in the Prolog ﬂag argv.
swipl [option ...] prolog-ﬁle ... [[--] arg ...]
This is the normal way to start Prolog. The options are described in section 2.4.2, section 2.4.3
and section 2.4.4. The Prolog ﬂag argc provides access to arg ... If the options are followed
by one or more Prolog ﬁle names (i.e., names with extension .pl, .prolog or (on Windows)
the user preferred extension registered during installation), these ﬁles are loaded. The ﬁrst ﬁle
is registered in the Prolog ﬂag associated file. In addition, pl-win[.exe] switches
to the directory in which this primary source ﬁle is located using working directory/2.
swipl -o output -c prolog-ﬁle ...
The -c option is used to compile a set of Prolog ﬁles into an executable. See section 2.4.5.
swipl -o output -b bootﬁle prolog-ﬁle ...
Bootstrap compilation. See section 2.4.6.
2.4.1
Informational command line options
--arch
When given as the only option, it prints the architecture identiﬁer (see Prolog ﬂag arch) and
exits. See also -dump-runtime-variables. Also available as -arch.
--dump-runtime-variables [=format]
When given as the only option, it prints a sequence of variable settings that can be used in
shell scripts to deal with Prolog parameters. This feature is also used by swipl-ld (see
section 9.5). Below is a typical example of using this feature.
eval ‘swipl --dump-runtime-variables‘
cc -I$PLBASE/include -L$PLBASE/lib/$PLARCH ...
The option can be followed by =sh to dump in POSIX shell format (default) or cmd to dump
in MS-Windows cmd.exe compatible format.
--help
When given as the only option, it summarises the most important options. Also available as -h
and -help.
--version
When given as the only option, it summarises the version and the architecture identiﬁer. Also
available as -v.
2.4.2
Command line options for running Prolog
--home=DIR
Use DIR as home directory. See section 9.6 for details.
SWI-Prolog 6.6 Reference Manual

2.4. COMMAND LINE OPTIONS
19
--quiet
Set the Prolog ﬂag verbose to silent, suppressing informational and banner messages.
Also available as -q.
--nodebug
Disable debugging. See the current prolog flag/2 ﬂag generate debug info for
details.
--nosignals
Inhibit any signal handling by Prolog, a property that is sometimes desirable for embedded
applications. This option sets the ﬂag signals to false. See section 9.4.21 for details.
--pldoc [=port]
Start the PlDoc documentation system on a free network port and launch the user’s browser on
http://localhost:⟨port⟩. If port is speciﬁed, the server is started at the given port and
the browser is not launched.
-tty
Unix only. Switches controlling the terminal for allowing single-character commands to the
tracer and get single char/1. By default, manipulating the terminal is enabled unless
the system detects it is not connected to a terminal or it is running as a GNU-Emacs inferior
process. This ﬂag is sometimes required for smooth interaction with other applications.
--win app
This option is available only in swipl-win.exe and is used for the start-menu item. If
causes plwin to start in the folder ...\My Documents\Prolog or local equivalent
thereof (see win folder/2). The Prolog subdirectory is created if it does not exist.
-O
Optimised compilation. See current prolog flag/2 ﬂag optimise for details.
-s ﬁle
Use ﬁle as a script ﬁle. The script ﬁle is loaded after the initialisation ﬁle speciﬁed with the
-f file option. Unlike -f file, using -s does not stop Prolog from loading the personal
initialisation ﬁle.
-f ﬁle
Use ﬁle as initialisation ﬁle instead of the default .plrc (Unix) or pl.ini (Windows).
‘-f none’ stops SWI-Prolog from searching for a startup ﬁle. This option can be used as an
alternative to -s file that stops Prolog from loading the personal initialisation ﬁle. See also
section 2.2.
-F script
Select a startup script from the SWI-Prolog home directory.
The script ﬁle is named
⟨script⟩.rc.
The default script name is deduced from the executable, taking the leading
alphanumerical characters (letters, digits and underscore) from the program name. -F none
stops looking for a script. Intended for simple management of slightly different versions. One
could, for example, write a script iso.rc and then select ISO compatibility mode using
pl -F iso or make a link from iso-pl to pl.
SWI-Prolog 6.6 Reference Manual

20
CHAPTER 2. OVERVIEW
-x bootﬁle
Boot from bootﬁle instead of the system’s default boot ﬁle.
A boot ﬁle is a ﬁle re-
sulting from a Prolog compilation using the -b or -c option or a program saved using
qsave program/[1,2].
-p alias=path1[:path2 . . . ]
Deﬁne a path alias for ﬁle search path. alias is the name of the alias, and argpath1 ... is a
list of values for the alias. On Windows the list separator is ;. On other systems it is :. A
value is either a term of the form alias(value) or pathname. The computed aliases are added to
file search path/2 using asserta/1, so they precede predeﬁned values for the alias.
See file search path/2 for details on using this ﬁle location mechanism.
--
Stops scanning for more arguments, so you can pass arguments for your application after this
one. See current prolog flag/2 using the ﬂag argv for obtaining the command line
arguments.
2.4.3
Controlling the stack sizes
The default limit for the Prolog stacks is 128 MB on 32-bit and 256 MB on 64-bit hardware. The
128 MB limit on 32-bit systems is the highest possible value and the command line options can thus
only be used to lower the limit. On 64-bit systems, the limit can both be reduced and enlarged. See
section 2.19. Below are two examples, the ﬁrst reducing the local stack limit to catch unbounded
recursion quickly and the second using a big (32 GB) global limit, which is only possible on 64-bit
hardware. Note that setting the limit using the command line only sets a soft limit. Stack parameters
can be changed (both reduced and enlarged) at any time using the predicate set prolog stack/2.
$ swipl -L8m
$ swipl -G32g
-Gsize[kmg]
Limit for the global stack (sometimes also called term stack or heap). This is where compound
terms and large numbers live.
-Lsize[kmg]
Limit for the local stack (sometimes also called environment stack). This is where environments
and choice points live.
-Tsize[kmg]
Limit for the trail stack. This is where we keep track of assignments, so we can rollback on
backtracking or exceptions.
2.4.4
Running goals from the command line
-g goal
Goal is executed just before entering the top level. Default is a predicate which prints the
welcome message. The welcome message can be suppressed with --quiet, but also with
-g true. goal can be a complex term. In this case quotes are normally needed to protect it
from being expanded by the shell. A safe way to run a goal non-interactively is here:
SWI-Prolog 6.6 Reference Manual

2.5. GNU EMACS INTERFACE
21
% swipl <options> -g go,halt -t ’halt(1)’
-t goal
Use goal as interactive top level instead of the default goal prolog/0. goal can be a complex
term. If the top-level goal succeeds SWI-Prolog exits with status 0. If it fails the exit status is
1. If the top level raises an exception, this is printed as an uncaught error and the top level is
restarted. This ﬂag also determines the goal started by break/0 and abort/0. If you want
to stop the user from entering interactive mode, start the application with ‘-g goal’ and give
‘halt’ as top level.
2.4.5
Compilation options
-c ﬁle . . .
Compile ﬁles into an ‘intermediate code ﬁle’. See section 2.10.
-o output
Used in combination with -c or -b to determine output ﬁle for compilation.
2.4.6
Maintenance options
The following options are for system maintenance. They are given for reference only.
-b initﬁle . . .-c ﬁle . . .
Boot compilation. initﬁle . . . are compiled by the C-written bootstrap compiler, ﬁle ... by the
normal Prolog compiler. System maintenance only.
-d token1,token2,...
Print debug messages for DEBUG statements tagged with one of the indicated tokens. Only
has effect if the system is compiled with the -DO DEBUG ﬂag. System maintenance only.
2.5
GNU Emacs Interface
Unfortunately the default Prolog mode of GNU-Emacs is not very good. There are several alternatives
though:
• http://turing.ubishops.ca/home/bruda/emacs-prolog/
• http://stud4.tuwien.ac.at/ e0225855/ediprolog/ediprolog.html
• http://stud4.tuwien.ac.at/ e0225855/pceprolog/pceprolog.html
• http://stud4.tuwien.ac.at/ e0225855/etrace/etrace.html
2.6
Online Help
SWI-Prolog provides an online help system that covers this manual. If the XPCE graphics system is
available, online help opens a graphical window. Otherwise the documentation is shown in the Prolog
console. The help system is controlled by the predicates below. Note that this help system only covers
SWI-Prolog 6.6 Reference Manual

22
CHAPTER 2. OVERVIEW
the core SWI-Prolog manual. The website4 provides an integrated manual that covers the core system
as well as all standard extension packages. It is possible to install the SWI-Prolog website locally by
cloning the website repository git://www.swi-prolog.org/home/pl/git/plweb.git
and following the instructions in the README ﬁle.
help
Equivalent to help(help/1).
help(+What)
Show speciﬁed part of the manual. What is one of:
⟨Name⟩/⟨Arity⟩
Give help on speciﬁed predicate
⟨Name⟩
Give help on named predicate with any arity or C interface
function with that name
⟨Section⟩
Display speciﬁed section.
Section numbers are dash-
separated numbers: 2-3 refers to section 2.3 of the man-
ual. Section numbers are obtained using apropos/1.
Examples:
?- help(assert).
Give help on predicate assert
?- help(3-4).
Display section 3.4 of the manual
?- help(’PL retry’).
Give help on interface function PL retry()
See also apropos/1 and the SWI-Prolog home page at http://www.swi-prolog.org,
which provides a FAQ, an HTML version of the manual for online browsing, and HTML and
PDF versions for downloading.
apropos(+Pattern)
Display all predicates, functions and sections that have Pattern in their name or summary
description. Lowercase letters in Pattern also match a corresponding uppercase letter. Example:
?- apropos(file).
Display predicates, functions and sections
that have ‘ﬁle’ (or ‘File’, etc.) in their sum-
mary description.
explain(+ToExplain)
Give an explanation on the given ‘object’. The argument may be any Prolog data object. If the
argument is an atom, a term of the form Name/Arity or a term of the form Module:Name/Arity,
explain/1 describes the predicate as well as possible references to it. See also gxref/0.
explain(+ToExplain, -Explanation)
Unify Explanation with an explanation for ToExplain. Backtracking yields further explanations.
4http://www.swi-prolog.org
SWI-Prolog 6.6 Reference Manual

2.7. COMMAND LINE HISTORY
23
!!.
Repeat last query
!nr.
Repeat query numbered ⟨nr⟩
!str.
Repeat last query starting with ⟨str⟩
h.
Show history of commands
!h.
Show this list
Table 2.1: History commands
1 ?- maplist(plus(1), "hello", X).
X = [105,102,109,109,112].
2 ?- format(’˜s˜n’, [$X]).
ifmmp
true.
3 ?-
Figure 2.1: Reusing top-level bindings
2.7
Command line history
SWI-Prolog offers a query substitution mechanism similar to what is seen in Unix shells. The avail-
ability of this feature is controlled by set prolog flag/2, using the history Prolog ﬂag. By
default, history is available if the Prolog ﬂag readline is false. To enable this feature, remem-
bering the last 50 commands, put the following into your startup ﬁle (see section 2.2):
:- set_prolog_flag(history, 50).
The history system allows the user to compose new queries from those typed before and remembered
by the system. The available history commands are shown in table 2.1. History expansion is not done
if these sequences appear in quoted atoms or strings.
2.8
Reuse of top-level bindings
Bindings resulting from the successful execution of a top-level goal are asserted in a database if they
are not too large. These values may be reused in further top-level queries as $Var. If the same
variable name is used in a subsequent query the system associates the variable with the latest binding.
Example:
Note that variables may be set by executing =/2:
6 ?- X = statistics.
X = statistics.
7 ?- $X.
SWI-Prolog 6.6 Reference Manual

24
CHAPTER 2. OVERVIEW
28.00 seconds cpu time for 183,128 inferences
4,016 atoms, 1,904 functors, 2,042 predicates, 52 modules
55,915 byte codes; 11,239 external references
Limit
Allocated
In use
Heap
:
624,820 Bytes
Local
stack :
2,048,000
8,192
404 Bytes
Global stack :
4,096,000
16,384
968 Bytes
Trail
stack :
4,096,000
8,192
432 Bytes
true.
2.9
Overview of the Debugger
SWI-Prolog
has
a
6-port
tracer,
extending
the
standard
4-port
tracer
[Byrd, 1980,
Clocksin & Melish, 1987] with two additional ports.
The optional unify port allows the user to
inspect the result after uniﬁcation of the head.
The exception port shows exceptions raised by
throw/1 or one of the built-in predicates. See section 4.10.
The standard ports are called call, exit, redo, fail and unify. The tracer is started by the
trace/0 command, when a spy point is reached and the system is in debugging mode (see spy/1
and debug/0), or when an exception is raised that is not caught.
The interactive top-level goal trace/0 means “trace the next query”.
The tracer shows
the port, displaying the port name, the current depth of the recursion and the goal.
The goal
is printed using the Prolog predicate write term/2.
The style is deﬁned by the Prolog ﬂag
debugger print options and can be modiﬁed using this ﬂag or using the w, p and d com-
mands of the tracer.
On leashed ports (set with the predicate leash/1, default are call, exit, redo and fail)
the user is prompted for an action. All actions are single-character commands which are executed
without waiting for a return, unless the command line option -tty is active. Tracer options:
+ (Spy)
Set a spy point (see spy/1) on the current predicate.
- (No spy)
Remove the spy point (see nospy/1) from the current predicate.
/ (Find)
Search for a port. After the ‘/’, the user can enter a line to specify the port to search for. This
line consists of a set of letters indicating the port type, followed by an optional term, that should
unify with the goal run by the port. If no term is speciﬁed it is taken as a variable, searching for
any port of the speciﬁed type. If an atom is given, any goal whose functor has a name equal to
that atom matches. Examples:
SWI-Prolog 6.6 Reference Manual

2.9. OVERVIEW OF THE DEBUGGER
25
min_numlist([H|T], Min) :-
min_numlist(T, H, Min).
min_numlist([], Min, Min).
min_numlist([H|T], Min0, Min) :-
Min1 is min(H, Min0),
min_numlist(T, Min1, Min).
1 ?- visible(+all), leash(-exit).
true.
2 ?- trace, min_numlist([3, 2], X).
Call: (7) min_numlist([3, 2], _G0) ? creep
Unify: (7) min_numlist([3, 2], _G0)
Call: (8) min_numlist([2], 3, _G0) ? creep
Unify: (8) min_numlist([2], 3, _G0)
ˆ
Call: (9) _G54 is min(2, 3) ? creep
ˆ
Exit: (9) 2 is min(2, 3)
Call: (9) min_numlist([], 2, _G0) ? creep
Unify: (9) min_numlist([], 2, 2)
Exit: (9) min_numlist([], 2, 2)
Exit: (8) min_numlist([2], 3, 2)
Exit: (7) min_numlist([3, 2], 2)
X = 2.
Figure 2.2: Example trace of the program above showing all ports. The lines marked ˆ indicate calls
to transparent predicates. See section 5.
SWI-Prolog 6.6 Reference Manual

26
CHAPTER 2. OVERVIEW
/f
Search for any fail port
/fe solve
Search for a fail or exit port of any goal with name
solve
/c solve(a,
)
Search for a call to solve/2 whose ﬁrst argument
is a variable or the atom a
/a member( ,
)
Search for any port on member/2. This is equiv-
alent to setting a spy point on member/2.
. (Repeat ﬁnd)
Repeat the last ﬁnd command (see ‘/’).
A (Alternatives)
Show all goals that have alternatives.
C (Context)
Toggle ‘Show Context’. If on, the context module of the goal is displayed between square
brackets (see section 5). Default is off.
L (Listing)
List the current predicate with listing/1.
a (Abort)
Abort Prolog execution (see abort/0).
b (Break)
Enter a Prolog break environment (see break/0).
c (Creep)
Continue execution, stop at next port. (Also RETURN, SPACE).
d (Display)
Set the max depth(Depth) option of debugger print options, limiting the depth to
which terms are printed. See also the w and p options.
e (Exit)
Terminate Prolog (see halt/0).
f (Fail)
Force failure of the current goal.
g (Goals)
Show the list of parent goals (the execution stack). Note that due to tail recursion optimization
a number of parent goals might not exist any more.
h (Help)
Show available options (also ‘?’).
i (Ignore)
Ignore the current goal, pretending it succeeded.
l (Leap)
Continue execution, stop at next spy point.
SWI-Prolog 6.6 Reference Manual

2.10. COMPILATION
27
n (No debug)
Continue execution in ‘no debug’ mode.
p (Print)
Set
the
Prolog
ﬂag
debugger print options
to
[quoted(true),
portray(true), max depth(10), priority(699)]. This is the default.
r (Retry)
Undo all actions (except for database and I/O actions) back to the call port of the current goal
and resume execution at the call port.
s (Skip)
Continue execution, stop at the next port of this goal (thus skipping all calls to children of this
goal).
u (Up)
Continue execution, stop at the next port of the parent goal (thus skipping this goal and all
calls to children of this goal). This option is useful to stop tracing a failure driven loop.
w (Write)
Set
the
Prolog
ﬂag
debugger print options
to
[quoted(true),
attributes(write), priority(699)], bypassing portray/1, etc.
The
ideal
4-port
model
[Byrd, 1980]
as
described
in
many
Prolog
books
[Clocksin & Melish, 1987] is not visible in many Prolog implementations because code opti-
misation removes part of the choice and exit points. Backtrack points are not shown if either the goal
succeeded deterministically or its alternatives were removed using the cut. When running in debug
mode (debug/0) choice points are only destroyed when removed by the cut. In debug mode, last
call optimisation is switched off.5
Reference information to all predicates available for manipulating the debugger is in section 4.38.
2.10
Compilation
2.10.1
During program development
During program development, programs are normally loaded using the list abbreviation (?-
[load].). It is common practice to organise a project as a collection of source ﬁles and a load
ﬁle, a Prolog ﬁle containing only use module/[1,2] or ensure loaded/1 directives, possi-
bly with a deﬁnition of the entry point of the program, the predicate that is normally used to start the
program. This ﬁle is often called load.pl. If the entry point is called go, a typical session starts as:
% swipl
<banner>
1 ?- [load].
<compilation messages>
true.
5This implies the system can run out of stack in debug mode, while no problems arise when running in non-debug mode.
SWI-Prolog 6.6 Reference Manual

28
CHAPTER 2. OVERVIEW
2 ?- go.
<program interaction>
When using Windows, the user may open load.pl from the Windows explorer, which will cause
swipl-win.exe to be started in the directory holding load.pl. Prolog loads load.pl before
entering the top level. If Prolog is started from an interactive shell, one may choose the type swipl
-s load.pl.
2.10.2
For running the result
There are various options if you want to make your program ready for real usage. The best choice
depends on whether the program is to be used only on machines holding the SWI-Prolog development
system, the size of the program, and the operating system (Unix vs. Windows).
Using PrologScript
A Prolog source ﬁle can be used directly as a Unix program using the Unix #! magic start. The same
mechanism is useful for specifying additional parameters for running a Prolog ﬁle on Windows. The
Unix #! magic is allowed because if the ﬁrst letter of a Prolog ﬁle is #, the ﬁrst line is treated as a
comment.6 To create a Prolog script, make the ﬁrst line start like this:
#!/path/to/swipl ⟨options⟩-s
Prolog recognises this starting sequence and causes the interpreter to receive the following argu-
ment list:
/path/to/swipl ⟨options⟩-s ⟨script⟩-- ⟨ScriptArguments⟩
Instead of -s, the user may use -f to stop Prolog from looking for a personal initialisation ﬁle.
Here is a simple script doing expression evaluation:
#!/usr/bin/swipl -q -t main -f
eval :-
current_prolog_flag(argv, Argv),
append(_, [--|Args], Argv),
concat_atom(Args, ’ ’, SingleArg),
term_to_atom(Term, SingleArg),
Val is Term,
format(’˜w˜n’, [Val]).
main :-
catch(eval, E, (print_message(error, E), fail)),
halt.
main :-
halt(1).
6The #-sign can be the legal start of a normal Prolog clause. In the unlikely case this is required, leave the ﬁrst line blank
or add a header comment.
SWI-Prolog 6.6 Reference Manual

2.10. COMPILATION
29
And here are two example runs:
% eval 1+2
3
% eval foo
ERROR: Arithmetic: ‘foo/0’ is not a function
%
The Windows version
supports the #! construct too, but here it serves a rather different role. The
Windows shell already allows the user to start Prolog source ﬁles directly through the Windows ﬁle-
type association. However, Windows makes it rather complicated to provide additional parameters
for opening an individual Prolog ﬁle. If the ﬁle starts with #!, the ﬁrst line is analysed to obtain
additional command line arguments. The example below runs the system in ‘quiet’ mode.
#!/usr/bin/swipl -q -s
....
Note the use of /usr/bin/swipl, which speciﬁes the interpreter. This argument is ignored in the
Windows version, but must be present to ensure best cross-platform compatibility.
Creating a shell script
With the introduction of PrologScript (see section 2.10.2), using shell scripts as explained in this
section has become redundant for most applications.
Especially on Unix systems and not-too-large applications, writing a shell script that simply loads
your application and calls the entry point is often a good choice. A skeleton for the script is given
below, followed by the Prolog code to obtain the program arguments.
#!/bin/sh
base=<absolute-path-to-source>
PL=swipl
exec $PL -q -f ’$base/load -t go -- **
go :-
current_prolog_flag(argv, Arguments),
append(_SytemArgs, [--|Args], Arguments), !,
go(Args).
go(Args) :-
...
On Windows systems, similar behaviour can be achieved by creating a shortcut to Prolog, passing the
proper options or writing a .bat ﬁle.
SWI-Prolog 6.6 Reference Manual

30
CHAPTER 2. OVERVIEW
Creating a saved state
For larger programs, as well as for programs that are required to run on systems that do not have
the SWI-Prolog development system installed, creating a saved state is the best solution. A saved
state is created using qsave program/[1,2] or the -c command line option. A saved state
is a ﬁle containing machine-independent7 intermediate code in a format dedicated for fast loading.
Optionally, the emulator may be integrated in the saved state, creating a single ﬁle, but machine-
dependent, executable. This process is described in chapter 10.
Compilation using the -c command line option
This mechanism loads a series of Prolog source ﬁles and then creates a saved state as
qsave program/2 does. The command syntax is:
% swipl [option ...] [-o output] -c file.pl ...
The options argument are options to qsave program/2 written in the format below. The option
names and their values are described with qsave program/2.
--option-name=option-value
For example, to create a stand-alone executable that starts by executing main/0 and for which
the source is loaded through load.pl, use the command
% swipl --goal=main --stand_alone=true -o myprog -c load.pl
This performs exactly the same as executing
% swipl
<banner>
?- [load].
?- qsave_program(myprog,
[ goal(main),
stand_alone(true)
]).
?- halt.
2.11
Environment Control (Prolog ﬂags)
The predicates current prolog flag/2 and set prolog flag/2 allow the user to examine
and modify the execution environment. It provides access to whether optional features are available
on this version, operating system, foreign code environment, command line arguments, version, as
well as runtime ﬂags to control the runtime behaviour of certain predicates to achieve compatibility
with other Prolog environments.
7The saved state does not depend on the CPU instruction set or endianness. Saved states for 32- and 64-bits are not
compatible. Typically, saved states only run on the same version of Prolog on which they have been created.
SWI-Prolog 6.6 Reference Manual

2.11. ENVIRONMENT CONTROL (PROLOG FLAGS)
31
current prolog ﬂag(?Key, -Value)
[ISO]
The predicate current prolog flag/2 deﬁnes an interface to installation features: op-
tions compiled in, version, home, etc.
With both arguments unbound, it will generate all
deﬁned Prolog ﬂags. With ‘Key’ instantiated, it uniﬁes the value of the Prolog ﬂag. Flag values
are typed. Flags marked as bool can have the values true or false. Some Prolog ﬂags
are not deﬁned in all versions, which is normally indicated in the documentation below as “if
present and true”. A boolean Prolog ﬂag is true iff the Prolog ﬂag is present and the Value is
the atom true. Tests for such ﬂags should be written as below:
(
current_prolog_flag(windows, true)
->
<Do MS-Windows things>
;
<Do normal things>
)
Some Prolog ﬂags are scoped to a source ﬁle. This implies that if they are set using a direc-
tive inside a ﬁle, the ﬂag value encountered when loading of the ﬁle started is restored when
loading of the ﬁle is completed. Currently, the following ﬂags are scoped to the source ﬁle:
generate debug info and optimise.
A new thread (see section 8) copies all ﬂags from the thread that created the new thread (its
parent).8 As a consequence, modifying a ﬂag inside a thread does not affect other threads.
access level (atom, changeable)
This ﬂag deﬁnes a normal ‘user’ view (user, default) or a ‘system’ view. In system view
all system code is fully accessible as if it was normal user code. In user view, certain
operations are not permitted and some details are kept invisible.
We leave the exact
consequences undeﬁned, but, for example, system code can be traced using system access
and system predicates can be redeﬁned.
address bits (integer)
Address size of the hosting machine. Typically 32 or 64. Except for the maximum stack
limit, this has few implications to the user. See also the Prolog ﬂag arch.
agc margin (integer, changeable)
If this amount of atoms possible garbage atoms exist perform atom garbage collection at
the ﬁrst opportunity. Initial value is 10,000. May be changed. A value of 0 (zero) disables
atom garbage collection. See also PL register atom().9
apple (bool)
If present and true, the operating system is MacOSX. Deﬁned if the C compiler used
to compile this version of SWI-Prolog deﬁnes __APPLE__. Note that the unix is also
deﬁned for MacOSX.
allow variable name as functor (bool, changeable)
If
true
(default
is
false),
Functor(arg)
is
read
as
if
it
were
written
’Functor’(arg).
Some applications use the Prolog read/1 predicate for
reading an application-deﬁned script language.
In these cases, it is often difﬁcult to
8This is implemented using the copy-on-write tecnhnique.
9Given that SWI-Prolog has no limit on the length of atoms, 10,000 atoms may still occupy a lot of memory. Applications
using extremely large atoms may wish to call garbage collect atoms/0 explicitly or lower the margin.
SWI-Prolog 6.6 Reference Manual

32
CHAPTER 2. OVERVIEW
explain to non-Prolog users of the application that constants and functions can only start
with a lowercase letter. Variables can be turned into atoms starting with an uppercase
atom by calling read term/2 using the option variable names and binding the
variables to their name. Using this feature, F(x) can be turned into valid syntax for such
script languages. Suggested by Robert van Engelen. SWI-Prolog speciﬁc.
argv (list, changeable)
List is a list of atoms representing the application command line arguments. Application
command line arguments are those that have not been processed by Prolog during its
initialization. Note that Prolog’s argument processing stops at -- or the ﬁrst non-option
argument. See also os argv.10
arch (atom)
Identiﬁer
for
the
hardware
and
operating
system
SWI-Prolog
is
running
on.
Used to select foreign ﬁles for the right architecture.
See also section 9.2.3 and
file search path/2.
associated ﬁle (atom)
Set if Prolog was started with a prolog ﬁle as argument. Used by e.g., edit/0 to edit the
initial ﬁle.
autoload (bool, changeable)
If true (default) autoloading of library functions is enabled.
backquoted string (bool, changeable)
If true (default false), read translates text between backquotes into a string object
(see section 4.24). This ﬂag is mainly for compatibility with LPA Prolog.
bounded (bool)
ISO Prolog ﬂag.
If true, integer representation is bound by min integer and
max integer. If false integers can be arbitrarily large and the min integer and
max integer are not present. See section 4.27.2.
break level (integer)
Current break-level. The initial top level (started with -t) has value 0. See break/0.
This ﬂag is absent from threads that are not running a top-level loop.
c cc (atom, changeable)
Name of the C compiler used to compile SWI-Prolog. Normally either gcc or cc. See
section 9.5.
c cﬂags (atom, changeable)
CFLAGS used to compile SWI-Prolog. See section 9.5.
c ldﬂags (atom, changeable)
LDFLAGS used to link SWI-Prolog. See section 9.5.
c libs (atom, changeable)
Libraries needed to link executables that embed SWI-Prolog. Typically -lswipl if the
SWI-Prolog kernel is a shared (DLL). If the SWI-Prolog kernel is in a static library, this
ﬂag also contains the dependencies.
10Prior to version 6.5.2, argv was deﬁned as os argv is now. The change was made for compatibility reasone and
because the current deﬁnition is more practical.
SWI-Prolog 6.6 Reference Manual

2.11. ENVIRONMENT CONTROL (PROLOG FLAGS)
33
c libplso (atom, changeable)
Libraries needed to link extensions (shared object, DLL) to SWI-Prolog. Typically empty
on ELF systems and -lswipl on COFF-based systems. See section 9.5.
char conversion (bool, changeable)
Determines whether character conversion takes place while reading terms.
See also
char conversion/2.
character escapes (bool, changeable)
If true (default), read/1 interprets \ escape sequences in quoted atoms and strings.
May be changed. This ﬂag is local to the module in which it is changed.
colon sets calling context (bool)
Using the construct ⟨module⟩:⟨goal⟩sets the calling context for executing ⟨goal⟩. This
ﬂag is deﬁned by ISO/IEC 13211-2 (Prolog modules standard). See section 5.
color term (bool, changeable)
This ﬂag is managed by library ansi term, which is loaded at startup if the two con-
ditions below are both true. Note that this implies that setting this ﬂag to false from
the system or personal initialization ﬁle (see section 2.2 disables colored output. The
predicate message property/2 can be used to control the actual color scheme
depending in the message type passed to print message/2.
• stream_property(current_output, tty(true))
• \+ current_prolog_flag(color_term, false)
compile meta arguments (atom, changeable)
Experimental ﬂag that controls compilation of arguments passed to meta-calls marked ‘0’
or ‘ˆ’ (see meta predicate/1). Supported values are:
false
(default). Meta-arguments are passed verbatim.
control
Compile meta-arguments that contain control structures ((A,B), (A;B), (A-¿B;C),
etc.). If not compiled at compile time, such arguments are compiled to a temporary
clause before execution.
Using this option enhances performance of processing
complex meta-goals that are known at compile time.
true
Also compile references to normal user predicates. This harms performance (a little),
but enhances the power of poor-mens consistency check used by make/0 and
implemented by list undefined/0.
always
Always create an intermediate clause, even for system predicates. This prepares for
replacing the normal head of the generated predicate with a special reference (similar
to database references as used by, e.g., assert/2) that provides direct access to the
executable code, thus avoiding runtime lookup of predicates for meta-calling.
compiled at (atom)
Describes when the system has been compiled. Only available if the C compiler used to
compile SWI-Prolog provides the
DATE
and
TIME
macros.
console menu (bool)
Set to true in swipl-win.exe to indicate that the console supports menus. See also
section 4.34.3.
SWI-Prolog 6.6 Reference Manual

34
CHAPTER 2. OVERVIEW
cpu count (integer, changeable)
Number of physical CPUs or cores in the system.
The ﬂag is marked read-
write both to allow pretending the system has more or less processors.
See also
thread setconcurrency/2 and the library thread. This ﬂag is not available on
systems where we do not know how to get the number of CPUs. This ﬂag is not included
in a saved state (see qsave program/1).
dde (bool)
Set to true if this instance of Prolog supports DDE as described in section 4.42.
debug (bool, changeable)
Switch debugging mode on/off. If debug mode is activated the system traps encountered
spy points (see spy/1) and trace points (see trace/1). In addition, last-call optimi-
sation is disabled and the system is more conservative in destroying choice points to
simplify debugging.
Disabling these optimisations can cause the system to run out of memory on programs
that behave correctly if debug mode is off.
debug on error (bool, changeable)
If true, start the tracer after an error is detected. Otherwise just continue execution. The
goal that raised the error will normally fail. See also fileerrors/2 and the Prolog
ﬂag report error. May be changed. Default is true, except for the runtime version.
debugger print options (term, changeable)
This argument is given as option-list to write term/2 for printing goals by
the debugger.
Modiﬁed by the ‘w’, ‘p’ and ‘⟨N⟩d’ commands of the debug-
ger.
Default
is
[quoted(true), portray(true), max depth(10),
attributes(portray)].
debugger show context (bool, changeable)
If true, show the context module while printing a stack-frame in the tracer. Normally
controlled using the ‘C’ option of the tracer.
dialect (atom)
Fixed to swi. The code below is a reliable and portable way to detect SWI-Prolog.
is_dialect(swi) :-
catch(current_prolog_flag(dialect, swi), _, fail).
double quotes (codes,chars,atom,string, changeable)
This ﬂag determines how double quoted strings are read by Prolog and is —like
character escapes— maintained for each module. If codes (default), a list of
character codes is returned, if chars a list of one-character atoms, if atom double
quotes are the same as single quotes and ﬁnally, string reads the text into a Prolog
string (see section 4.24). See also atom chars/2 and atom codes/2.
editor (atom, changeable)
Determines the editor used by edit/1. See section 4.5 for details on selecting the editor
used.
emacs inferior process (bool)
If true, SWI-Prolog is running as an inferior process of (GNU/X-)Emacs. SWI-Prolog
assumes this is the case if the environment variable EMACS is t and INFERIOR is yes.
SWI-Prolog 6.6 Reference Manual

2.11. ENVIRONMENT CONTROL (PROLOG FLAGS)
35
encoding (atom, changeable)
Default encoding used for opening ﬁles in text mode. The initial value is deduced from
the environment. See section 2.18.1 for details.
executable (atom)
Pathname of the running executable. Used by qsave program/2 as default emulator.
exit status (integer)
Set by halt/1 to its argument, making the exit status available to hooks registered with
at halt/1.
ﬁle name variables (bool, changeable)
If true (default false), expand $varname and ˜ in arguments of built-in predicates
that accept a ﬁle name (open/3, exists file/1, access file/2, etc.).
The
predicate expand file name/2 can be used to expand environment variables and
wildcard patterns. This Prolog ﬂag is intended for backward compatibility with older
versions of SWI-Prolog.
gc (bool, changeable)
If true (default), the garbage collector is active. If false, neither garbage collection, nor
stack shifts will take place, even not on explicit request. May be changed.
generate debug info (bool, changeable)
If true (default) generate code that can be debugged using trace/0, spy/1, etc. Can
be set to false using the -nodebug. This ﬂag is scoped within a source ﬁle. Many of
the libraries have :- set_prolog_flag(generate_debug_info, false) to
hide their details from a normal trace.11
gmp version (integer)
If Prolog is linked with GMP, this ﬂag gives the major version of the GMP library used.
See also section 9.4.8.
gui (bool)
Set to true if XPCE is around and can be used for graphics.
history (integer, changeable)
If integer > 0, support Unix csh(1)-like history as described in section 2.7. Otherwise,
only support reusing commands through the command line editor. The default is to set
this Prolog ﬂag to 0 if a command line editor is provided (see Prolog ﬂag readline)
and 15 otherwise.
home (atom)
SWI-Prolog’s notion of the home directory. SWI-Prolog uses its home directory to ﬁnd
its startup ﬁle as ⟨home⟩/boot32.prc (32-bit machines) or ⟨home⟩/boot64.prc
(64-bit machines) and to ﬁnd its library as ⟨home⟩/library.
hwnd (integer)
In swipl-win.exe, this refers to the MS-Windows window handle of the console
window.
integer rounding function (down,toward zero)
ISO Prolog ﬂag describing rounding by // and rem arithmetic functions. Value depends
on the C compiler used.
11In the current implementation this only causes a ﬂag to be set on the predicate that causes children to be hidden from
the debugger. The name anticipates further changes to the compiler.
SWI-Prolog 6.6 Reference Manual

36
CHAPTER 2. OVERVIEW
iso (bool, changeable)
Include some weird ISO compatibility that is incompatible with normal SWI-Prolog
behaviour. Currently it has the following effect:
• The //2 (ﬂoat division) always returns a ﬂoat, even if applied to integers that can be
divided.
• In the standard order of terms (see section 4.7.1), all ﬂoats are before all integers.
• atom length/2 yields a type error if the ﬁrst argument is a number.
• clause/[2,3] raises a permission error when accessing static predicates.
• abolish/[1,2] raises a permission error when accessing static predicates.
• Syntax is closer to the ISO standard:
– Unquoted commas and bars appearing as atoms are not allowed.
Instead of
f(,,a) now write f(’,’,a). Unquoted commas can only be used to sep-
arate arguments in functional notation and list notation, and as a conjunction
operator. Unquoted bars can only appear within lists to separate head and tail,
like [Head|Tail], and as inﬁx operator for alternation in grammar rules, like
a --> b | c.
– Within functional notation and list notation terms must have priority below
1000. That means that rules and control constructs appearing as arguments need
bracketing. A term like [a :- b, c]. must now be disambiguated to mean
[(a :- b), c]. or [(a :- b, c)].
– Operators
appearing
as
operands
must
be
bracketed.
Instead
of
X == -, true. write X == (-), true. Currently, this is not en-
tirely enforced.
– Backslash-escaped newlines are interpreted according to the ISO standard. See
section 2.15.1.
large ﬁles (bool)
If present and true, SWI-Prolog has been compiled with large ﬁle support (LFS) and
is capable of accessing ﬁles larger than 2GB on 32-bit hardware. Large ﬁle support is
default on installations built using configure that support it and may be switched off
using the conﬁgure option --disable-largefile.
last call optimisation (bool, changeable)
Determines whether or not last-call optimisation is enabled. Normally the value of this
ﬂag is the negation of the debug ﬂag. As programs may run out of stack if last-call
optimisation is omitted, it is sometimes necessary to enable it during debugging.
max arity (unbounded)
ISO Prolog ﬂag describing there is no maximum arity to compound terms.
max integer (integer)
Maximum integer value if integers are bounded. See also the ﬂag bounded and sec-
tion 4.27.2.
max tagged integer (integer)
Maximum integer value represented as a ‘tagged’ value. Tagged integers require one
word storage. Larger integers are represented as ‘indirect data’ and require signiﬁcantly
more space.
SWI-Prolog 6.6 Reference Manual

2.11. ENVIRONMENT CONTROL (PROLOG FLAGS)
37
min integer (integer)
Minimum integer value if integers are bounded. See also the ﬂag bounded and sec-
tion 4.27.2.
min tagged integer (integer)
Start of the tagged-integer value range.
occurs check (atom, changeable)
This ﬂag controls uniﬁcation that creates an inﬁnite tree (also called cyclic term) and can
have three values. Using false (default), uniﬁcation succeeds, creating an inﬁnite tree.
Using true, uniﬁcation behaves as unify with occurs check/2, failing silently.
Using error, an attempt to create a cyclic term results in an occurs check exception.
The latter is intended for debugging unintentional creations of cyclic terms. Note that this
ﬂag is a global ﬂag modifying fundamental behaviour of Prolog. Changing the ﬂag from
its default may cause libraries to stop functioning properly.
open shared object (bool)
If true, open shared object/2 and friends are implemented, providing access to
shared libraries (.so ﬁles) or dynamic link libraries (.DLL ﬁles).
optimise (bool, changeable)
If true, compile in optimised mode. The initial value is true if Prolog was started with
the -O command line option. The optimise ﬂag is scoped to a source ﬁle.
Currently optimised compilation implies compilation of arithmetic, and deletion of redun-
dant true/0 that may result from expand goal/2.
Later versions might imply various other optimisations such as integrating small predi-
cates into their callers, eliminating constant expressions and other predictable constructs.
Source code optimisation is never applied to predicates that are declared dynamic (see
dynamic/1).
os argv (list, changeable)
List is a list of atoms representing the command line arguments used to invoke SWI-
Prolog. Please note that all arguments are included in the list returned. See argv to get
the application options.
pid (int)
Process identiﬁer of the running Prolog process. Existence of this ﬂag is implementation-
deﬁned.
pipe (bool, changeable)
If true, open(pipe(command), mode, Stream), etc. are supported.
Can be
changed to disable the use of pipes in applications testing this feature. Not recommended.
prompt alternatives on (atom, changeable)
Determines prompting for alternatives in the Prolog top level. Default is determinism,
which implies the system prompts for alternatives if the goal succeeded while leaving
choice points. Many classical Prolog systems behave as groundness: they prompt for
alternatives if and only if the query contains variables.
qcompile (atom, changeable)
This option provides the default for the qcompile(+Atom) option of load files/2.
readline (bool)
If true, SWI-Prolog is linked with the readline library. This is done by default if you have
SWI-Prolog 6.6 Reference Manual

38
CHAPTER 2. OVERVIEW
this library installed on your system. It is also true for the Win32 swipl-win.exe version
of SWI-Prolog, which realises a subset of the readline functionality.
resource database (atom)
Set to the absolute ﬁlename of the attached state. Typically this is the ﬁle boot32.prc,
the ﬁle speciﬁed with -x or the running executable. See also resource/3.
report error (bool, changeable)
If true, print error messages; otherwise suppress them. May be changed. See also the
debug on error Prolog ﬂag. Default is true, except for the runtime version.
runtime (bool)
If present and true, SWI-Prolog is compiled with -DO RUNTIME, disabling various
useful development features (currently the tracer and proﬁler).
sandboxed load (bool, changeable)
If true (default false), load files/2 calls hooks to allow library(sandbox) to
verify the safety of directives.
saved program (bool)
If
present
and
true,
Prolog
has
been
started
from
a
state
saved
with
qsave program/[1,2].
shared object extension (atom)
Extension used by the operating system for shared objects. .so for most Unix systems
and .dll for Windows. Used for locating ﬁles using the file type executable.
See also absolute file name/3.
shared object search path (atom)
Name of the environment variable used by the system to search for shared objects.
signals (bool)
Determine whether Prolog is handling signals (software interrupts). This ﬂag is false
if the hosting OS does not support signal handling or the command line option
-nosignals is active. See section 9.4.21 for details.
stream type check (atom, changeable)
Deﬁnes whether and how strictly the system validates that byte I/O should not be applied
to text streams and text I/O should not be applied to binary streams. Values are false
(no checking), true (full checking) and loose. Using checking mode loose (default),
the system accepts byte I/O from text stream that use ISO Latin-1 encoding and accepts
writing text to binary streams.
system thread id (int)
Available in multithreaded version (see section 8) where the operating system provides
system-wide integer thread identiﬁers. The integer is the thread identiﬁer used by the
operating system for the calling thread. See also thread self/1.
timezone (integer)
Offset in seconds west of GMT of the current time zone.
Set at initialization time
from the timezone variable associated with the POSIX tzset() function.
See also
convert time/2.
toplevel print anon (bool, changeable)
If true, top-level variables starting with an underscore ( ) are printed normally. If false
they are hidden. This may be used to hide bindings in complex queries from the top level.
SWI-Prolog 6.6 Reference Manual

2.11. ENVIRONMENT CONTROL (PROLOG FLAGS)
39
toplevel print factorized (bool, changeable)
If true (default false) show the internal sharing of subterms in the answer substi-
tution. The example below reveals internal sharing of leaf nodes in red-black trees as
implemented by the rbtrees predicate rb new/1:
?- set_prolog_flag(toplevel_print_factorized, true).
?- rb_new(X).
X = t(_S1, _S1), % where
_S1 = black(’’, _G387, _G388, ’’).
If this ﬂag is false, the % where notation is still used to indicate cycles as illustrated
below. This example also shows that the implementation reveals the internal cycle length,
and not the minimal cycle length. Cycles of different length are indistinguishable in Prolog
(as illustrated by S == R).
?- S = s(S), R = s(s(R)), S == R.
S = s(S),
R = s(s(R)).
toplevel print options (term, changeable)
This argument is given as option-list to write term/2 for printing results of
queries.
Default is [quoted(true), portray(true), max depth(10),
attributes(portray)].
toplevel prompt (atom, changeable)
Deﬁne the prompt that is used by the interactive top level. The following ˜ (tilde) se-
quences are replaced:
˜m
Type in module if not user (see module/1)
˜l
Break level if not 0 (see break/0)
˜d
Debugging state if not normal execution (see debug/0, trace/0)
˜!
History event if history is enabled (see ﬂag history)
toplevel var size (int, changeable)
Maximum size counted in literals of a term returned as a binding for a variable in a
top-level query that is saved for re-use using the $ variable reference. See section 2.8.
trace gc (bool, changeable)
If true (default false), garbage collections and stack-shifts will be reported on the
terminal. May be changed. Values are reported in bytes as G+T, where G is the global
stack value and T the trail stack value. ‘Gained’ describes the number of bytes reclaimed.
‘used’ the number of bytes on the stack after GC and ‘free’ the number of bytes allocated,
but not in use. Below is an example output.
% GC: gained 236,416+163,424 in 0.00 sec;
used 13,448+5,808; free 72,568+47,440
tty control (bool, changeable)
Determines whether the terminal is switched to raw mode for get single char/1,
which also reads the user actions for the trace.
May be set.
See also the +/-tty
command line option.
SWI-Prolog 6.6 Reference Manual

40
CHAPTER 2. OVERVIEW
unix (bool)
If present and true, the operating system is some version of Unix. Deﬁned if the C
compiler used to compile this version of SWI-Prolog either deﬁnes __unix__ or unix.
On other systems this ﬂag is not available. See also apple and windows.
unknown (fail,warning,error, changeable)
Determines the behaviour if an undeﬁned procedure is encountered. If fail, the pred-
icate fails silently.
If warn, a warning is printed, and execution continues as if the
predicate was not deﬁned, and if error (default), an existence error exception is
raised. This ﬂag is local to each module and inherited from the module’s import-module.
Using default setup, this implies that normal modules inherit the ﬂag from user, which
in turn inherit the value error from system. The user may change the ﬂag for module
user to change the default for all application modules or for a speciﬁc module. It is
strongly advised to keep the error default and use dynamic/1 and/or multifile/1
to specify possible non-existence of a predicate.
user ﬂags (Atom, changeable)
Deﬁne the behaviour of set prolog flag/2 if the ﬂag is not known. Values are
silent, warning and error.
The ﬁrst two create the ﬂag on-the-ﬂy, where
warning prints a message.
The value error is consistent with ISO: it raises an
existence error and does not create the ﬂag. See also create prolog flag/3. The
default is silent, but future versions may change that. Developers are encouraged to
use another value and ensure proper use of create prolog flag/3 to create ﬂags
for their library.
verbose (Atom, changeable)
This ﬂag is used by print message/2. If its value is silent, messages of type
informational and banner are suppressed. The -q switches the value from the
initial normal to silent.
verbose autoload (bool, changeable)
If true the normal consult message will be printed if a library is autoloaded. By default
this message is suppressed. Intended to be used for debugging purposes.
verbose load (atom, changeable)
Determines messages printed for loading (compiling) Prolog ﬁles. Current values are
full, normal (default) and silent. The value of this ﬂag is normally controlled by
the option silent(Bool) provided by load files/2.
verbose ﬁle search (bool, changeable)
If
true
(default
false),
print
messages
indicating
the
progress
of
absolute file name/[2,3] in locating ﬁles.
Intended for debugging com-
plicated ﬁle-search paths. See also file search path/2.
version (integer)
The version identiﬁer is an integer with value:
10000 × Major + 100 × Minor + Patch
Note that in releases up to 2.7.10 this Prolog ﬂag yielded an atom holding the three
numbers separated by dots. The current representation is much easier for implementing
version-conditional statements.
SWI-Prolog 6.6 Reference Manual

2.11. ENVIRONMENT CONTROL (PROLOG FLAGS)
41
version data (swi(Major, Minor, Patch, Extra))
Part of the dialect compatibility layer; see also the Prolog ﬂag dialect and section C.
Extra provides platform-speciﬁc version information. Currently it is simply uniﬁed to [].
version git (atom)
Available if created from a git repository. See git-describe for details.
warn override implicit import (bool, changeable)
If true (default), a warning is printed if an implicitly imported predicate is clobbered by
a local deﬁnition. See use module/1 for details.
windows (bool)
If present and true, the operating system is an implementation of Microsoft Windows
(NT/2000/XP, etc.). This ﬂag is only available on MS-Windows based versions.
write attributes (atom, changeable)
Deﬁnes how write/1 and friends write attributed variables.
The option values are
described with the attributes option of write term/3. Default is ignore.
write help with overstrike (bool)
Internal ﬂag used by help/1 when writing to a terminal. If present and true it prints
bold and underlined text using overstrike.
xpce (bool)
Available and set to true if the XPCE graphics system is loaded.
xpce version (atom)
Available and set to the version of the loaded XPCE system.
set prolog ﬂag(:Key, +Value)
[ISO]
Deﬁne a new Prolog ﬂag or change its value.
Key is an atom.
If the ﬂag is a system-
deﬁned ﬂag that is not marked changeable above, an attempt to modify the ﬂag yields
a permission error.
If the provided Value does not match the type of the ﬂag, a
type error is raised.
Some ﬂags (e.g., unknown) are maintained on a per-module basis. The addressed module is
determined by the Key argument.
In addition to ISO, SWI-Prolog allows for user-deﬁned Prolog ﬂags. The type of the ﬂag is de-
termined from the initial value and cannot be changed afterwards. Deﬁned types are boolean
(if the initial value is one of false, true, on or off), atom if the initial value is any other
atom, integer if the value is an integer that can be expressed as a 64-bit signed value. Any
other initial value results in an untyped ﬂag that can represent any valid Prolog term.
The behaviour when Key denotes a non-existent key depends on the Prolog ﬂag
user flags.
The default is to deﬁne them silently.
New code is encouraged to use
create prolog flag/3 for portability.
create prolog ﬂag(+Key, +Value, +Options)
[YAP]
Create a new Prolog ﬂag. The ISO standard does not foresee creation of new ﬂags, but many
libraries introduce new ﬂags. Options is a list of the options below. See also user flags.
access(+Access)
Deﬁne access rights for the ﬂag. Values are read write and read only. The default
is read write.
SWI-Prolog 6.6 Reference Manual

42
CHAPTER 2. OVERVIEW
type(+Atom)
Deﬁne a type restriction. Possible values are boolean, atom, integer, float and
term. The default is determined from the initial value. Note that term restricts the term
to be ground.
keep(+Boolean)
If true, to not modify the ﬂag if it already exists. Otherwise (default), this predicate
behaves as set prolog flag/2 if the ﬂag already exists.
2.12
An overview of hook predicates
SWI-Prolog provides a large number of hooks, mainly to control handling messages, debugging,
startup, shut-down, macro-expansion, etc. Below is a summary of all deﬁned hooks with an indication
of their portability.
• portray/1
Hook into write term/3 to alter the way terms are printed (ISO).
• message hook/3
Hook into print message/2 to alter the way system messages are printed (Quin-
tus/SICStus).
• message property/2
Hook into print message/2 that deﬁnes preﬁx, output stream, color, etc.
• library directory/1
Hook into absolute file name/3 to deﬁne new library directories (most Prolog systems).
• ﬁle search path/2
Hook into absolute file name/3 to deﬁne new search paths (Quintus/SICStus).
• term expansion/2
Hook into load files/2 to modify read terms before they are compiled (macro-processing)
(most Prolog systems).
• goal expansion/2
Same as term expansion/2 for individual goals (SICStus).
• prolog load ﬁle/2
Hook into load files/2 to load other data formats for Prolog sources from ‘non-ﬁle’ re-
sources. The load files/2 predicate is the ancestor of consult/1, use module/1,
etc.
• prolog edit:locate/3
Hook into edit/1 to locate objects (SWI).
• prolog edit:edit source/1
Hook into edit/1 to call an internal editor (SWI).
• prolog edit:edit command/2
Hook into edit/1 to deﬁne the external editor to use (SWI).
SWI-Prolog 6.6 Reference Manual

2.13. AUTOMATIC LOADING OF LIBRARIES
43
• prolog list goal/1
Hook into the tracer to list the code associated to a particular goal (SWI).
• prolog trace interception/4
Hook into the tracer to handle trace events (SWI).
• prolog:debug control hook/1
Hook in spy/1, nospy/1, nospyall/0 and debugging/0 to extend these control pred-
icates to higher-level libraries.
• prolog:help hook/1
Hook in help/0, help/1 and apropos/1 to extend the help system.
• resource/3
Deﬁne a new resource (not really a hook, but similar) (SWI).
• exception/3
Old attempt to a generic hook mechanism. Handles undeﬁned predicates (SWI).
• attr unify hook/2
Uniﬁcation hook for attributed variables. Can be deﬁned in any module. See section 6.1 for
details.
2.13
Automatic loading of libraries
If —at runtime— an undeﬁned predicate is trapped, the system will ﬁrst try to import the pred-
icate from the module’s default module (see section 5.9.
If this fails the auto loader is acti-
vated.12 On ﬁrst activation an index to all library ﬁles in all library directories is loaded in core
(see library directory/1, file search path/2 and reload library index/0). If
the undeﬁned predicate can be located in one of the libraries, that library ﬁle is automatically loaded
and the call to the (previously undeﬁned) predicate is restarted. By default this mechanism loads the
ﬁle silently. The current prolog flag/2 key verbose autoload is provided to get verbose
loading. The Prolog ﬂag autoload can be used to enable/disable the autoload system.
Autoloading only handles (library) source ﬁles that use the module mechanism described in chap-
ter 5. The ﬁles are loaded with use module/2 and only the trapped undeﬁned predicate is imported
into the module where the undeﬁned predicate was called. Each library directory must hold a ﬁle
INDEX.pl that contains an index to all library ﬁles in the directory. This ﬁle consists of lines of the
following format:
index(Name, Arity, Module, File).
The predicate make/0 updates the autoload index.
It searches for all library directories
(see library directory/1 and file search path/2) holding the ﬁle MKINDEX.pl or
INDEX.pl. If the current user can write or create the ﬁle INDEX.pl and it does not exist or
is older than the directory or one of its ﬁles, the index for this directory is updated. If the ﬁle
MKINDEX.pl exists, updating is achieved by loading this ﬁle, normally containing a directive calling
12Actually, the hook user:exception/3 is called; only if this hook fails does it call the autoloader.
SWI-Prolog 6.6 Reference Manual

44
CHAPTER 2. OVERVIEW
make library index/2. Otherwise make library index/1 is called, creating an index for
all *.pl ﬁles containing a module.
Below is an example creating an indexed library directory.
% mkdir ˜/lib/prolog
% cd ˜/lib/prolog
% swipl -g true -t ’make_library_index(.)’
If there is more than one library ﬁle containing the desired predicate, the following search schema is
followed:
1. If there is a library ﬁle that deﬁnes the module in which the undeﬁned predicate is trapped, this
ﬁle is used.
2. Otherwise library ﬁles are considered in the order they appear in the library directory/1
predicate and within the directory alphabetically.
autoload path(+DirAlias)
Add DirAlias to the libraries that are used by the autoloader. This extends the search path
autoload and reloads the library index. For example:
:- autoload_path(library(http)).
If this call appears as a directive, it is term-expanded into a clause for user:ﬁle search path/2 and
a directive calling reload library index/0. This keeps source information and allows
for removing this directive.
make library index(+Directory)
Create an index for this directory. The index is written to the ﬁle ’INDEX.pl’ in the speciﬁed
directory. Fails with a warning if the directory does not exist or is write protected.
make library index(+Directory, +ListOfPatterns)
Normally used in MKINDEX.pl, this predicate creates INDEX.pl for Directory, indexing all
ﬁles that match one of the ﬁle patterns in ListOfPatterns.
Sometimes library packages consist of one public load ﬁle and a number of ﬁles used by this
load ﬁle, exporting predicates that should not be used directly by the end user. Such a library
can be placed in a sub-directory of the library and the ﬁles containing public functionality can
be added to the index of the library. As an example we give the XPCE library’s MKINDEX.pl,
including the public functionality of trace/browse.pl to the autoloadable predicates for
the XPCE package.
:- make_library_index(’.’,
[ ’*.pl’,
’trace/browse.pl’
]).
SWI-Prolog 6.6 Reference Manual

2.14. GARBAGE COLLECTION
45
reload library index
Force reloading the index after modifying the set of library directories by changing the rules for
library directory/1, file search path/2, adding or deleting INDEX.pl ﬁles.
This predicate does not update the INDEX.pl ﬁles. Check make library index/[1,2]
and make/0 for updating the index ﬁles.
Normally, the index is reloaded automatically if a predicate cannot be found in the index and
the set of library directories has changed. Using reload library index/0 is necessary if
directories are removed or the order of the library directories is changed.
When creating an executable using either qsave program/2 or the -c command line options,
it is necessarry to load all predicates that would normally be autoloaded explicitly. This is discussed
in section 10. See autoload/0.
2.14
Garbage Collection
SWI-Prolog provides garbage collection, last-call optimization and atom garbage collection. These
features are controlled using Prolog ﬂags (see current prolog flag/2).
2.15
Syntax Notes
SWI-Prolog syntax is close to ISO-Prolog standard syntax, which is closely compatible with Edin-
burgh Prolog syntax. A description of this syntax can be found in the Prolog books referenced in
the introduction. Below are some non-standard or non-common constructs that are accepted by SWI-
Prolog:
• /* .../* ...*/ ...*/
The /* ...*/ comment statement can be nested. This is useful if some code with /* ...*/
comment statements in it should be commented out.
2.15.1
ISO Syntax Support
SWI-Prolog offers ISO compatible extensions to the Edinburgh syntax.
Processor Character Set
The processor character set speciﬁes the class of each character used for parsing Prolog source text.
Character classiﬁcation is ﬁxed to use UCS/Unicode as provided by the C library wchar t based
primitives. See also section 2.18.
Character Escape Syntax
Within quoted atoms (using single quotes: ’<atom>’) special characters are represented using es-
cape sequences. An escape sequence is led in by the backslash (\) character. The list of escape
sequences is compatible with the ISO standard but contains some extensions, and the interpretation of
numerically speciﬁed characters is slightly more ﬂexible to improve compatibility. Undeﬁned escape
characters raise a syntax error exception.13
13Up to SWI-Prolog 6.1.9, undeﬁned escape characters were copied verbatim, i.e., removing the backslash.
SWI-Prolog 6.6 Reference Manual

46
CHAPTER 2. OVERVIEW
\a
Alert character. Normally the ASCII character 7 (beep).
\b
Backspace character.
\c
No output. All input characters up to but not including the ﬁrst non-layout character are skipped.
This allows for the speciﬁcation of pretty-looking long lines. Not supported by ISO. Example:
format(’This is a long line that looks better if it was \c
split across multiple physical lines in the input’)
\⟨NEWLINE⟩
When in ISO mode (see the Prolog ﬂag iso), only skip this sequence. In native mode, white
space that follows the newline is skipped as well and a warning is printed, indicating that this
construct is deprecated and advising to use \c. We advise using \c or putting the layout
before the \, as shown below. Using \c is supported by various other Prolog implementations
and will remain supported by SWI-Prolog. The style shown below is the most compatible
solution.14
format(’This is a long line that looks better if it was \
split across multiple physical lines in the input’)
instead of
format(’This is a long line that looks better if it was\
split across multiple physical lines in the input’)
\e
Escape character (ASCII 27). Not ISO, but widely supported.
\f
Form-feed character.
\n
Next-line character.
\r
Carriage-return only (i.e., go back to the start of the line).
\s
Space character. Intended to allow writing 0’\s to get the character code of the space charac-
ter. Not ISO.
\t
Horizontal tab character.
14Future versions will interpret \⟨return⟩according to ISO.
SWI-Prolog 6.6 Reference Manual

2.15. SYNTAX NOTES
47
\v
Vertical tab character (ASCII 11).
\xXX..\
Hexadecimal speciﬁcation of a character. The closing \ is obligatory according to the ISO
standard, but optional in SWI-Prolog to enhance compatibility with the older Edinburgh stan-
dard. The code \xa\3 emits the character 10 (hexadecimal ‘a’) followed by ‘3’. Characters
speciﬁed this way are interpreted as Unicode characters. See also \u.
\uXXXX
Unicode character speciﬁcation where the character is speciﬁed using exactly 4 hexadecimal
digits. This is an extension to the ISO standard, ﬁxing two problems. First, where \x deﬁnes
a numeric character code, it doesn’t specify the character set in which the character should be
interpreted. Second, it is not needed to use the idiosyncratic closing \ ISO Prolog syntax.
\UXXXXXXXX
Same as \uXXXX, but using 8 digits to cover the whole Unicode set.
\40
Octal character speciﬁcation. The rules and remarks for hexadecimal speciﬁcations apply to
octal speciﬁcations as well.
\\
Escapes the backslash itself. Thus, ’\\’ is an atom consisting of a single \.
\quote
If the current quote (" or ’) is preceded by a backslash, it is copied verbatim. Thus, ’\’’ and
’’’’ both describe the atom with a single ’.
Character escaping is only available if current prolog flag(character escapes, true)
is active (default). See current prolog flag/2. Character escapes conﬂict with writef/2
in two ways: \40 is interpreted as decimal 40 by writef/2, but as octal 40 (decimal 32)
by read.
Also, the writef/2 sequence \l is illegal.
It is advised to use the more widely
supported format/[2,3] predicate instead. If you insist upon using writef/2, either switch
character escapes to false, or use double \\, as in writef(’\\l’).
Syntax for non-decimal numbers
SWI-Prolog implements both Edinburgh and ISO representations for non-decimal numbers. Accord-
ing to Edinburgh syntax, such numbers are written as ⟨radix⟩’<number>, where ⟨radix⟩is a number
between 2 and 36. ISO deﬁnes binary, octal and hexadecimal numbers using 0[bxo]⟨number⟩. For
example: A is 0b100 \/ 0xf00 is a valid expression. Such numbers are always unsigned.
Using digit groups in large integers
SWI-Prolog supports splitting long integers into digit groups. Digit groups can be separated with
the sequence ⟨underscore⟩, ⟨optional white space⟩. If the ⟨radix⟩is 10 or lower, they may also be
separated with exactly one space. The following all express the integer 1 million:
SWI-Prolog 6.6 Reference Manual

48
CHAPTER 2. OVERVIEW
1_000_000
1 000 000
1_000_/*more*/000
Integers can be printed using this notation with format/2, using the ˜I format speciﬁer. For exam-
ple:
?- format(’˜I’, [1000000]).
1_000_000
The current syntax has been proposed by Ulrich Neumerkel on the SWI-Prolog mailinglist.
Unicode Prolog source
The ISO standard speciﬁes the Prolog syntax in ASCII characters. As SWI-Prolog supports Unicode
in source ﬁles we must extend the syntax. This section describes the implication for the source ﬁles,
while writing international source ﬁles is described in section 3.1.3.
The SWI-Prolog Unicode character classiﬁcation is based on version 6.0.0 of the Unicode stan-
dard. Please note that char type/2 and friends, intended to be used with all text except Prolog
source code, is based on the C library locale-based classiﬁcation routines.
• Quoted atoms and strings
Any character of any script can be used in quoted atoms and strings. The escape sequences
\uXXXX and \UXXXXXXXX (see section 2.15.1) were introduced to specify Unicode code
points in ASCII ﬁles.
• Atoms and Variables
We handle them in one item as they are closely related. The Unicode standard deﬁnes a syntax
for identiﬁers in computer languages.15 In this syntax identiﬁers start with ID Start followed
by a sequence of ID Continue codes. Such sequences are handled as a single token in SWI-
Prolog. The token is a variable iff it starts with an uppercase character or an underscore ( ).
Otherwise it is an atom. Note that many languages do not have the notion of character case. In
such languages variables must be written as _name.
• White space
All characters marked as separators (Z*) in the Unicode tables are handled as layout characters.
• Control and unassigned characters
Control and unassigned (C*) characters produce a syntax error if encountered outside quoted
atoms/strings and outside comments.
• Other characters
The ﬁrst 128 characters follow the ISO Prolog standard. Unicode symbol and punctuation
characters (general category S* and P*) act as glueing symbol characters (i.e., just like ==: an
unquoted sequence of symbol characters are combined into an atom).
Other characters (this is mainly No: a numeric character of other type) are currently handled as
‘solo’.
15http://www.unicode.org/reports/tr31/
SWI-Prolog 6.6 Reference Manual

2.15. SYNTAX NOTES
49
Singleton variable checking
A singleton variable is a variable that appears only one time in a clause. It can always be replaced
by _, the anonymous variable. In some cases, however, people prefer to give the variable a name.
As mistyping a variable is a common mistake, Prolog systems generally give a warning (controlled
by style check/1) if a variable is used only once. The system can be informed that a variable is
meant to appear once by starting it with an underscore, e.g., _Name. Please note that any variable,
except plain _, shares with variables of the same name. The term t(_X, _X) is equivalent to
t(X, X), which is different from t(_, _).
As Unicode requires variables to start with an underscore in many languages, this schema needs
to be extended.16 First we deﬁne the two classes of named variables.
• Named singleton variables
Named singletons start with a double underscore (__) or a single underscore followed by an
uppercase letter, e.g., __var or _Var.
• Normal variables
All other variables are ‘normal’ variables. Note this makes _var a normal variable.17
Any normal variable appearing exactly once in the clause and any named singleton variables
appearing more than once are reported. Below are some examples with warnings in the right column.
Singleton messages can be suppressed using the style check/1 directive.
test( ).
test( a).
Singleton variables: [ a]
test( 12).
Singleton variables: [ 12]
test(A).
Singleton variables: [A]
test( A).
test( a).
test( , ).
test( a, a).
test( a,
a).
Singleton-marked variables appearing more than once: [ a]
test( A, A).
Singleton-marked variables appearing more than once: [ A]
test(A, A).
Semantic singletons
Starting with version 6.5.1, SWI-Prolog has syntactic singletons and seman-
tic singletons. The ﬁrst are checked by read clause/3 (and read term/3 using the option
singletons(warning)). The latter are generated by the compiler for variables that appear alone in
a branch. For example, in the code below the variable X is not a syntactic singleton, but the variable
X does not communicate any bindings and replacing X with
does not change the semantics.
test :-
(
test_1(X)
;
test_2(X)
).
16After a proposal by Richard O’Keefe.
17Some Prolog dialects write variables this way.
SWI-Prolog 6.6 Reference Manual

50
CHAPTER 2. OVERVIEW
2.16
Rational trees (cyclic terms)
SWI-Prolog supports rational trees, also known as cyclic terms. ‘Supports’ is so deﬁned that most
relevant built-in predicates terminate when faced with rational trees.
Almost all SWI-Prolog’s
built-in term manipulation predicates process terms in a time that is linear to the amount of mem-
ory used to represent the term on the stack.
The following set of predicates safely handles ra-
tional trees: =../2, ==/2, =@=/2, =/2, @</2, @=</2, @>=/2, @>/2, \==/2, \=@=/2,
\=/2, acyclic term/1, bagof/3, compare/3, copy term/2, cyclic term/1, dif/2,
duplicate term/2,
findall/3,
ground/1,
term hash/2,
numbervars/[3,4],
recorda/3, recordz/3, setof/3, subsumes term/2, term variables/2, throw/1,
unify with occurs check/2, unifiable/3, when/2, write/1 (and related predicates) .
In addition, some built-ins recognise rational trees and raise an appropriate exception. Arithmetic
evaluation belongs to this group. The compiler (asserta/1, etc.) also raises an exception. Future
versions may support rational trees. Predicates that could provide meaningful processing of rational
trees raise a representation error. Predicates for which rational trees have no meaningful
interpretation raise a type error. For example:
1 ?- A = f(A), asserta(a(A)).
ERROR: asserta/1: Cannot represent due to ‘cyclic_term’
2 ?- A = 1+A, B is A.
ERROR: is/2: Type error: ‘expression’ expected, found
‘@(S_1,[S_1=1+S_1])’ (cyclic term)
2.17
Just-in-time clause indexing
SWI-Prolog provides ‘just-in-time’ indexing over multiple arguments.18 ‘Just-in-time’ means that
clause indexes are not built by the compiler (or asserta/1 for dynamic predicates), but on the
ﬁrst call to such a predicate where an index might help (i.e., a call where at least one argument is
instantiated). This section describes the rules used by the indexing logic. Note that this logic is not
‘set in stone’. The indexing capabilities of the system will change. Although this inevitably leads to
some regressing on some particular use cases, we strive to avoid signiﬁcant slowdowns.
The list below describes the clause selection process for various predicates and calls. The alterna-
tives are considered in the order they are presented.
• Special purpose code
Currently two special cases are recognised by the compiler: static code with exactly one clause
and static code with two clauses, one where the ﬁrst argument is the empty list ([]) and one
where the ﬁrst argument is a non-empty list ([_|_]).
• Linear scan on ﬁrst argument
The principal clause list maintains a key for the ﬁrst argument. An indexing key is either a
constant or a functor (name/arity reference). Calls with an instantiated ﬁrst argument and less
than 10 clauses perform a linear scan for a possible matching clause using this index key.
18JIT indexing was added in version 5.11.29 (Oct. 2011).
SWI-Prolog 6.6 Reference Manual

2.17. JUST-IN-TIME CLAUSE INDEXING
51
• Hash lookup
If none of the above applies, the system considers the available hash tables for which the corre-
sponding argument is instantiated. If a table is found with acceptable characteristics, it is used.
Otherwise, there are two cases. First, if no hash table is available for the instantiated arguments,
it assesses the clauses for all instantiated arguments and selects the best candidate for creating
a hash table. Arguments that cannot be indexed are ﬂagged to avoid repeated scanning. Sec-
ond, if there is a hash table for an indexed argument but it has poor characteristics, the system
scans other instantiated arguments to see whether it can create a better hash table. The system
maintains a bit vector on each table in which it marks arguments that are less suitable than the
argument to which the table belongs.
Clauses that have a variable at an otherwise indexable argument must be linked into all hash
buckets. Currently, predicates that have more than 10% such clauses for a speciﬁc argument are
not considered for indexing on that argument.
Disregarding variables, the suitability of an argument for hashing is expressed as the number of
unique indexable values divided by the standard deviation of the number of duplicate values for
each value plus one.19
The indexes of dynamic predicates are deleted if the number of clauses is doubled since its
creation or reduced below 1/4th. The JIT approach will recreate a suitable index on the next
call. Indexes of running predicates cannot be deleted. They are added to a ‘removed index list’
associated to the predicate. Dynamic predicates maintain a counter for the number of goals
running the predicate (a predicate can ‘run’ multiple times due to recursion, open choice points,
and multiple threads) and destroy removed indexes if this count drops to zero. Outdated indexes
of static predicates (e.g., due to reconsult or enlarging multiﬁle predicates) are reclaimed by
garbage collect clauses/0.
2.17.1
Future directions
• The current indexing system is largely prepared for secondary indexes. This implies that if there
are many clauses that match a given key, the system could (JIT) create a secondary index. This
secondary index could exploit another argument or, if the key denotes a functor, an argument
inside the compound term.
• The ‘special cases’ can be extended. This is notably attractive for static predicates with a
relatively small number of clauses where a hash lookup is too costly.
2.17.2
Indexing and portability
The base-line functionality of Prolog implementations provides indexing on constants and functor
(name/arity) on the ﬁrst argument. This must be your assumption if wide portability of your program
is important. This can typically be achieved by exploiting term hash/2 or term hash/4 and/or
maintaining multiple copies of a predicate with reordered arguments and wrappers that update all
implementations (assert/retract) and selects the appropriate implementation (query).
YAP provides full JIT indexing, including indexing arguments of compound terms. YAP’s index-
ing has been the inspiration for enhancing SWI-Prolog’s indexing capabilities.
19Earlier versions simply used the number of unique values, but poor distribution of values makes a table less suitable.
This was analysed by Fabien Noth and G¨unter Kniesel.
SWI-Prolog 6.6 Reference Manual

52
CHAPTER 2. OVERVIEW
2.18
Wide character support
SWI-Prolog supports wide characters, characters with character codes above 255 that cannot be rep-
resented in a single byte. Universal Character Set (UCS) is the ISO/IEC 10646 standard that speciﬁes
a unique 31-bit unsigned integer for any character in any language. It is a superset of 16-bit Unicode,
which in turn is a superset of ISO 8859-1 (ISO Latin-1), a superset of US-ASCII. UCS can handle
strings holding characters from multiple languages, and character classiﬁcation (uppercase, lowercase,
digit, etc.) and operations such as case conversion are unambiguously deﬁned.
For this reason SWI-Prolog has two representations for atoms and string objects (see section 4.24).
If the text ﬁts in ISO Latin-1, it is represented as an array of 8-bit characters. Otherwise the text is
represented as an array of 32-bit numbers. This representational issue is completely transparent to the
Prolog user. Users of the foreign language interface as described in chapter 9 sometimes need to be
aware of these issues though.
Character coding comes into view when characters of strings need to be read from or written to
ﬁle or when they have to be communicated to other software components using the foreign language
interface. In this section we only deal with I/O through streams, which includes ﬁle I/O as well as I/O
through network sockets.
2.18.1
Wide character encodings on streams
Although characters are uniquely coded using the UCS standard internally, streams and ﬁles are byte
(8-bit) oriented and there are a variety of ways to represent the larger UCS codes in an 8-bit octet
stream. The most popular one, especially in the context of the web, is UTF-8. Bytes 0 ... 127
represent simply the corresponding US-ASCII character, while bytes 128 ... 255 are used for multi-
byte encoding of characters placed higher in the UCS space. Especially on MS-Windows the 16-bit
Unicode standard, represented by pairs of bytes, is also popular.
Prolog I/O streams have a property called encoding which speciﬁes the used encoding that inﬂu-
ences get code/2 and put code/2 as well as all the other text I/O predicates.
The default encoding for ﬁles is derived from the Prolog ﬂag encoding, which is initialised
from the environment. If the environment variable LANG ends in ”UTF-8”, this encoding is as-
sumed. Otherwise the default is text and the translation is left to the wide-character functions
of the C library.20 The encoding can be speciﬁed explicitly in load files/2 for loading Prolog
source with an alternative encoding, open/4 when opening ﬁles or using set stream/2 on any
open stream. For Prolog source ﬁles we also provide the encoding/1 directive that can be used
to switch between encodings that are compatible with US-ASCII (ascii, iso latin 1, utf8
and many locales). See also section 3.1.3 for writing Prolog ﬁles with non-US-ASCII characters
and section 2.15.1 for syntax issues. For additional information and Unicode resources, please visit
http://www.unicode.org/.
SWI-Prolog currently deﬁnes and supports the following encodings:
octet
Default encoding for binary streams. This causes the stream to be read and written fully
untranslated.
ascii
7-bit encoding in 8-bit bytes. Equivalent to iso latin 1, but generates errors and warnings
on encountering values above 127.
20The Prolog native UTF-8 mode is considerably faster than the generic mbrtowc() one.
SWI-Prolog 6.6 Reference Manual

2.19. SYSTEM LIMITS
53
iso latin 1
8-bit encoding supporting many Western languages. This causes the stream to be read and
written fully untranslated.
text
C library default locale encoding for text ﬁles. Files are read and written using the C library
functions mbrtowc() and wcrtomb(). This may be the same as one of the other locales, notably
it may be the same as iso latin 1 for Western languages and utf8 in a UTF-8 context.
utf8
Multi-byte encoding of full UCS, compatible with ascii. See above.
unicode be
Unicode Big Endian. Reads input in pairs of bytes, most signiﬁcant byte ﬁrst. Can only repre-
sent 16-bit characters.
unicode le
Unicode Little Endian. Reads input in pairs of bytes, least signiﬁcant byte ﬁrst. Can only
represent 16-bit characters.
Note that not all encodings can represent all characters. This implies that writing text to a stream
may cause errors because the stream cannot represent these characters. The behaviour of a stream
on these errors can be controlled using set stream/2. Initially the terminal stream writes the
characters using Prolog escape sequences while other streams generate an I/O exception.
BOM: Byte Order Mark
From section 2.18.1, you may have got the impression that text ﬁles are complicated. This section
deals with a related topic, making life often easier for the user, but providing another worry to the
programmer. BOM or Byte Order Marker is a technique for identifying Unicode text ﬁles as well as
the encoding they use. Such ﬁles start with the Unicode character 0xFEFF, a non-breaking, zero-width
space character. This is a pretty unique sequence that is not likely to be the start of a non-Unicode
ﬁle and uniquely distinguishes the various Unicode ﬁle formats. As it is a zero-width blank, it even
doesn’t produce any output. This solves all problems, or ...
Some formats start off as US-ASCII and may contain some encoding mark to switch to UTF-8,
such as the encoding="UTF-8" in an XML header. Such formats often explicitly forbid the use
of a UTF-8 BOM. In other cases there is additional information revealing the encoding, making the
use of a BOM redundant or even illegal.
The BOM is handled by SWI-Prolog open/4 predicate. By default, text ﬁles are probed for the
BOM when opened for reading. If a BOM is found, the encoding is set accordingly and the property
bom(true) is available through stream property/2. When opening a ﬁle for writing, writing a
BOM can be requested using the option bom(true) with open/4.
2.19
System limits
2.19.1
Limits on memory areas
SWI-Prolog has a number of memory areas which are only enlarged to a certain limit. The internal
data representation limits the local, global and trail stack to 128 MB on 32-bit processors, or more
SWI-Prolog 6.6 Reference Manual

54
CHAPTER 2. OVERVIEW
generally to 2bits-per-pointer−5 bytes. Considering that almost all modern hardware can deal with
this amount of memory with ease, the default limits are set to their maximum on 32-bit hardware.
The representation limits can easily exceed physical memory on 64-bit hardware. The default limits
on 64-bit hardware are double that of 32-bit hardware, which allows for storing the same amount of
(Prolog) data.
The
limits
can
be
changed
from
the
command
line
as
well
as
at
runtime
using
set prolog stack/2. The table below shows these areas. The ﬁrst column gives the option
name to modify the size of the area. The option character is immediately followed by a number and
optionally by a k or m. With k or no unit indicator, the value is interpreted in Kbytes (1024 bytes);
with m, the value is interpreted in Mbytes (1024 × 1024 bytes).
The PrologScript facility described in section 2.10.2 provides a mechanism for specifying options
with the load ﬁle. On Windows the default stack sizes are controlled using the Windows registry
on the key HKEY_CURRENT_USER\Software\SWI\Prolog using the names localSize,
globalSize and trailSize. The value is a DWORD expressing the default stack size in Kbytes.
A GUI for modifying these values is provided using the XPCE package. To use this, start the XPCE
manual tools using manpce/0, after which you ﬁnd Preferences in the File menu.
Considering portability, applications that need to modify the default limits are advised to do so
using set prolog stack/2.
The heap
With the heap, we refer to the memory area used by malloc() and friends. SWI-Prolog uses the area
to store atoms, functors, predicates and their clauses, records and other dynamic data. No limits are
imposed on the addresses returned by malloc() and friends.
2.19.2
Other Limits
Clauses The only limit on clauses is their arity (the number of arguments to the head), which is
limited to 1024. Raising this limit is easy and relatively cheap; removing it is harder.
Atoms and Strings SWI-Prolog has no limits on the sizes of atoms and strings. read/1 and its
derivatives, however, normally limit the number of newlines in an atom or string to 6 to improve
error detection and recovery. This can be switched off with style check/1.
The number of atoms is limited to 16777216 (16M) on 32-bit machines. On 64-bit machines
this is virtually unlimited. See also section 9.4.2.
Memory areas On 32-bit hardware, SWI-Prolog data is packed in a 32-bit word, which contains both
type and value information. The size of the various memory areas is limited to 128 MB for each
of the areas, except for the program heap, which is not limited. On 64-bit hardware there are no
meaningful limits.
Nesting of terms Most built-in predicates that process Prolog terms create an explicitly managed
stack and perform optimization for processing the last argument of a term. This implies they
can process deeply nested terms at constant and low usage of the C stack, and the system raises
a resource error if no more stack can be allocated. Currently only read/1 and write/1 (and
all variations thereof) still use the C stack and may cause the system to crash in an uncontrolled
way (i.e., not mapped to a Prolog exception that can be caught).
SWI-Prolog 6.6 Reference Manual

2.19. SYSTEM LIMITS
55
Option
Default
Area name
Description
-L
128M
local stack
The local stack is used to store
the execution environments of
procedure invocations.
The
space for an environment is re-
claimed when it fails, exits with-
out leaving choice points, the al-
ternatives are cut off with the
!/0 predicate or no choice points
have been created since the invo-
cation and the last subclause is
started (last call optimisation).
-G
128M
global stack
The global stack is used to store
terms created during Prolog’s
execution. Terms on this stack
will be reclaimed by backtrack-
ing to a point before the term
was created or by garbage col-
lection (provided the term is no
longer referenced).
-T
128M
trail stack
The trail stack is used to store as-
signments during execution. En-
tries on this stack remain alive
until backtracking before the
point of creation or the garbage
collector determines they are no
longer needed.
-A
1M
argument stack
The argument stack is used to
store one of the Virtual Ma-
chine’s registers.
The amount
of space needed on this stack is
determined entirely by the depth
in which terms are nested in the
clauses that constitute the pro-
gram. Overﬂow is unlikely.
Table 2.2: Memory areas
SWI-Prolog 6.6 Reference Manual

56
CHAPTER 2. OVERVIEW
Integers On most systems SWI-Prolog is compiled with support for unbounded integers by means of
the GNU GMP library. In practice this means that integers are bound by the global stack size.
Too large integers cause a resource error. On systems that lack GMP, integers are 64-bit
on 32- as well as 64-bit machines.
Integers up to the value of the max tagged integer Prolog ﬂag are represented
more efﬁciently on the stack.
For integers that appear in clauses, the value (below
max tagged integer or not) has little impact on the size of the clause.
Floating point numbers Floating point numbers are represented as C-native double precision ﬂoats,
64-bit IEEE on most machines.
2.19.3
Reserved Names
The boot compiler (see -b option) does not support the module system. As large parts of the sys-
tem are written in Prolog itself we need some way to avoid name clashes with the user’s predicates,
database keys, etc. Like Edinburgh C-Prolog [Pereira, 1986] all predicates, database keys, etc., that
should be hidden from the user start with a dollar ($) sign.
2.20
SWI-Prolog and 64-bit machines
Most of today’s 64-bit platforms are capable of running both 32-bit and 64-bit applications. This asks
for some clariﬁcations on the advantages and drawbacks of 64-bit addressing for (SWI-)Prolog.
2.20.1
Supported platforms
SWI-Prolog can be compiled for a 32- or 64-bit address space on any system with a suitable C com-
piler. Pointer arithmetic is based on the type (u)intptr t from stdint.h, with suitable emulation on
MS-Windows.
2.20.2
Comparing 32- and 64-bits Prolog
Most of Prolog’s memory usage consists of pointers. This indicates the primary drawback: Prolog
memory usage almost doubles when using the 64-bit addressing model. Using more memory means
copying more data between CPU and main memory, slowing down the system.
What then are the advantages? First of all, SWI-Prolog’s addressing of the Prolog stacks does not
cover the whole address space due to the use of type tag bits and garbage collection ﬂags. On 32-bit
hardware the stacks are limited to 128 MB each. This tends to be too low for demanding applications
on modern hardware. On 64-bit hardware the limit is 232 times higher, exceeding the addressing
capabilities of today’s CPUs and operating systems. This implies Prolog can be started with stack
sizes that use the full capabilities of your hardware.
Multi-threaded applications proﬁt much more because every thread has its own set of stacks. The
Prolog stacks start small and are dynamically expanded (see section 2.19.1). The C stack is also
dynamically expanded, but the maximum size is reserved when a thread is started. Using 100 threads
at the maximum default C stack of 8Mb (Linux) costs 800Mb virtual memory!21
21C-recursion over Prolog data structures is removed from most of SWI-Prolog. When removed from all predicates it
will often be possible to use lower limits in threads. See http://www.swi-prolog.org/Devel/CStack.html
SWI-Prolog 6.6 Reference Manual

2.20. SWI-PROLOG AND 64-BIT MACHINES
57
The implications of theoretical performance loss due to increased memory bandwidth implied by
exchanging wider pointers depend on the design of the hardware. We only have data for the popular
IA32 vs. AMD64 architectures. Here, it appears that the loss is compensated for by an instruction set
that has been optimized for modern programming. In particular, the AMD64 has more registers and
the relative addressing capabilities have been improved. Where we see a 10% performance degra-
dation when placing the SWI-Prolog kernel in a Unix shared object, we cannot ﬁnd a measurable
difference on AMD64.
2.20.3
Choosing between 32- and 64-bit Prolog
For those cases where we can choose between 32 and 64 bits, either because the hardware and OS
support both or because we can still choose the hardware and OS, we give guidelines for this decision.
First of all, if SWI-Prolog needs to be linked against 32- or 64-bit native libraries, there is no
choice as it is not possible to link 32- and 64-bit code into a single executable. Only if all required
libraries are available in both sizes and there is no clear reason to use either do the different character-
istics of Prolog become important.
Prolog applications that require more than the 128 MB stack limit provided in 32-bit addressing
mode must use the 64-bit edition. Note however that the limits must be doubled to accommodate the
same Prolog application.
If the system is tight on physical memory, 32-bit Prolog has the clear advantage of using only
slightly more than half of the memory of 64-bit Prolog. This argument applies as long as the applica-
tion ﬁts in the virtual address space of the machine. The virtual address space of 32-bit hardware is
4GB, but in many cases the operating system provides less to user applications.
The only standard SWI-Prolog library adding signiﬁcantly to this calculation is the RDF database
provided by the semweb package. It uses approximately 80 bytes per triple on 32-bit hardware and
150 bytes on 64-bit hardware. Details depend on how many different resources and literals appear in
the dataset as well as desired additional literal indexes.
Summarizing, if applications are small enough to ﬁt comfortably in virtual and physical memory,
simply take the model used by most of the applications on the OS. If applications require more than
128 MB per stack, use the 64-bit edition. If applications approach the size of physical memory, ﬁt
in the 128 MB stack limit and ﬁt in virtual memory, the 32-bit version has clear advantages. For
demanding applications on 64-bit hardware with more than about 6GB physical memory the 64-bit
model is the model of choice.
SWI-Prolog 6.6 Reference Manual

Initialising and Managing a
Prolog Project
3
Prolog text-books give you an overview of the Prolog language. The manual tells you what predicates
are provided in the system and what they do. This chapter explains how to run a project. There is
no ultimate ‘right’ way to do this. Over the years we developed some practice in this area and SWI-
Prolog’s commands are there to support this practice. This chapter describes the conventions and
supporting commands.
The ﬁrst two sections (section 3.1 and section 3.2) only require plain Prolog. The remainder
discusses the use of the built-in graphical tools that require the XPCE graphical library installed on
your system.
3.1
The project source ﬁles
Organisation of source ﬁles depends largely on the size of your project. If you are doing exercises for
a Prolog course you’ll normally use one ﬁle for each exercise. If you have a small project you’ll work
with one directory holding a couple of ﬁles and some ﬁles to link it all together. Even bigger projects
will be organised in sub-projects, each using its own directory.
3.1.1
File Names and Locations
File Name Extensions
The ﬁrst consideration is what extension to use for the source ﬁles.
Tradition calls for
.pl,
but conﬂicts with Perl force the use of another extension on systems where ex-
tensions have global meaning,
such as MS-Windows.
On such systems .pro is the
common alternative.
On MS-Windows,
the alternative extension is stored in the reg-
istry
key
HKEY CURRENT USER/Software/SWI/Prolog/fileExtension
or
HKEY LOCAL MACHINE/Software/SWI/Prolog/fileExtension.
All
versions
of
SWI-Prolog load ﬁles with the extension .pl as well as with the registered alternative extension
without explicitly specifying the extension.
For portability reasons we propose the following
convention:
If there is no conﬂict because you do not use a conﬂicting application or the system does not force
a unique relation between extension and application, use .pl.
With a conﬂict choose .pro and use this extension for the ﬁles you want to load through your ﬁle
manager. Use .pl for all other ﬁles for maximal portability.
Project Directories
Large projects are generally composed of sub-projects, each using its own directory or directory struc-
ture. If nobody else will ever touch your ﬁles and you use only one computer, there is little to worry
SWI-Prolog 6.6 Reference Manual

3.1. THE PROJECT SOURCE FILES
59
about, but this is rarely the case with a large project.
To improve portability, SWI-Prolog uses the POSIX notation for ﬁlenames, which uses the
forward slash (/) to separate directories.
Just before reaching the ﬁle system, SWI-Prolog uses
prolog to os filename/2 to convert the ﬁlename to the conventions used by the hosting oper-
ating system. It is strongly advised to write paths using the /, especially on systems using the \ for
this purpose (MS-Windows). Using \ violates the portability rules and requires you to double the \
due to the Prolog quoted-atom escape rules.
Portable code should use prolog to os filename/2 to convert computed paths into system
paths when constructing commands for shell/1 and friends.
Sub-projects using search paths
Thanks
to
Quintus,
Prolog
adapted
an
extensible
mechanism
for
searching
ﬁles
using
file search path/2. This mechanism allows for comfortable and readable speciﬁcations.
Suppose you have extensive library packages on graph algorithms, set operations and GUI primi-
tives. These sub-projects are likely candidates for re-use in future projects. A good choice is to create
a directory with sub-directories for each of these sub-projects.
Next, there are three options. One is to add the sub-projects to the directory hierarchy of the
current project. Another is to use a completely dislocated directory. Third, the sub-project can be
added to the SWI-Prolog hierarchy. Using local installation, a typical file search path/2 is:
:- prolog_load_context(directory, Dir),
asserta(user:file_search_path(myapp, Dir)).
user:file_search_path(graph, myapp(graph)).
user:file_search_path(ui,
myapp(ui)).
When using sub-projects in the SWI-Prolog hierarchy, one should use the path alias swi as basis. For
a system-wide installation, use an absolute path.
Extensive sub-projects with a small well-deﬁned API should deﬁne a load ﬁle with calls to
use module/1 to import the various library components and export the API.
3.1.2
Project Special Files
There are a number of tasks you typically carry out on your project, such as loading it, creating a
saved state, debugging it, etc. Good practice on large projects is to deﬁne small ﬁles that hold the
commands to execute such a task, name this ﬁle after the task and give it a ﬁle extension that makes
starting easy (see section 3.1.1). The task load is generally central to these tasks. Here is a tentative
list:
• load.pl
Use this ﬁle to set up the environment (Prolog ﬂags and ﬁle search paths) and load the sources.
Quite commonly this ﬁle also provides convenient predicates to parse command line options
and start the application.
• run.pl
Use this ﬁle to start the application. Normally it loads load.pl in silent-mode, and calls one
of the starting predicates from load.pl.
SWI-Prolog 6.6 Reference Manual

60
CHAPTER 3. INITIALISING AND MANAGING A PROLOG PROJECT
• save.pl
Use this ﬁle to create a saved state of the application by loading load.pl and calling
qsave program/2 to generate a saved state with the proper options.
• debug.pl
Loads the program for debugging. In addition to loading load.pl this ﬁle deﬁnes rules for
portray/1 to modify printing rules for complex terms and customisation rules for the debug-
ger and editing environment. It may start some of these tools.
3.1.3
International source ﬁles
As discussed in section 2.18, SWI-Prolog supports international character handling. Its internal en-
coding is UNICODE. I/O streams convert to/from this internal format. This section discusses the
options for source ﬁles not in US-ASCII.
SWI-Prolog can read ﬁles in any of the encodings described in section 2.18. Two encodings are of
particular interest. The text encoding deals with the current locale, the default used by this computer
for representing text ﬁles. The encodings utf8, unicode le and unicode be are UNICODE
encodings: they can represent—in the same ﬁle—characters of virtually any known language. In
addition, they do so unambiguously.
If one wants to represent non US-ASCII text as Prolog terms in a source ﬁle, there are several
options:
• Use escape sequences
This approach describes NON-ASCII as sequences of the form \octal\. The numerical argu-
ment is interpreted as a UNICODE character.1 The resulting Prolog ﬁle is strict 7-bit US-ASCII,
but if there are many NON-ASCII characters it becomes very unreadable.
• Use local conventions
Alternatively the ﬁle may be speciﬁed using local conventions, such as the EUC encoding for
Japanese text. The disadvantage is portability. If the ﬁle is moved to another machine, this
machine must use the same locale or the ﬁle is unreadable. There is no elegant way if ﬁles from
multiple locales must be united in one application using this technique. In other words, it is ﬁne
for local projects in countries with uniform locale conventions.
• Using UTF-8 ﬁles
The best way to specify source ﬁles with many NON-ASCII characters is deﬁnitely the use of
UTF-8 encoding. Prolog can be notiﬁed of this encoding in two ways, using a UTF-8 BOM (see
section 2.18.1) or using the directive :- encoding(utf8). Many of today’s text editors,
including PceEmacs, are capable of editing UTF-8 ﬁles. Projects that were started using local
conventions can be re-coded using the Unix iconv tool or often using commands offered by
the editor.
3.2
Using modules
Modules have been debated ﬁercely in the Prolog world. Despite all counter-arguments we feel they
are extremely useful because:
1To my knowledge, the ISO escape sequence is limited to 3 octal digits, which means most characters cannot be repre-
sented.
SWI-Prolog 6.6 Reference Manual

3.3. THE TEST-EDIT-RELOAD CYCLE
61
• They hide local predicates
This is the reason they were invented in the ﬁrst place. Hiding provides two features. They
allow for short predicate names without worrying about conﬂicts. Given the ﬂat name-space in-
troduced by modules, they still require meaningful module names as well as meaningful names
for exported predicates.
• They document the interface
Possibly more important than avoiding name conﬂicts is their role in documenting which part
of the ﬁle is for public usage and which is private. When editing a module you may assume you
can reorganise anything except the name and the semantics of the exported predicates without
worrying.
• They help the editor
The PceEmacs built-in editor does on-the-ﬂy cross-referencing of the current module, colouring
predicates based on their origin and usage. Using modules, the editor can quickly ﬁnd out what
is provided by the imported modules by reading just the ﬁrst term. This allows it to indicate in
real-time which predicates are not used or not deﬁned.
Using modules is generally easy. Only if you write meta-predicates (predicates reasoning about
other predicates) that are exported from a module is a good understanding required of the resolution
of terms to predicates inside a module. Here is a typical example from readutil.
:- module(read_util,
[ read_line_to_codes/2,
% +Fd, -Codes
read_line_to_codes/3,
% +Fd, -Codes, ?Tail
read_stream_to_codes/2,
% +Fd, -Codes
read_stream_to_codes/3,
% +Fd, -Codes, ?Tail
read_file_to_codes/3,
% +File, -Codes, +Options
read_file_to_terms/3
% +File, -Terms, +Options
]).
3.3
The test-edit-reload cycle
SWI-Prolog does not enforce the use of a particular editor for writing Prolog source code. Editors are
complicated programs that must be mastered in detail for real productive programming. If you are
familiar with a speciﬁc editor you should not be forced to change. You may specify your favourite
editor using the Prolog ﬂag editor, the environment variable EDITOR or by deﬁning rules for
prolog_edit:edit_source/1 (see section 4.5).
The use of a built-in editor, which is selected by setting the Prolog ﬂag editor to pce emacs,
has advantages. The XPCE editor object, around which the built-in PceEmacs is built, can be opened
as a Prolog stream allowing analysis of your source by the real Prolog system.
3.3.1
Locating things to edit
The central predicate for editing something is edit/1, an extensible front-end that searches for
objects (ﬁles, predicates, modules, as well as XPCE classes and methods) in the Prolog database.
SWI-Prolog 6.6 Reference Manual

62
CHAPTER 3. INITIALISING AND MANAGING A PROLOG PROJECT
If multiple matches are found it provides a choice. Together with the built-in completion on atoms
bound to the TAB key this provides a quick way to edit objects:
?- edit(country).
Please select item to edit:
1 chat:country/10
’/staff/jan/lib/prolog/chat/countr.pl’:16
2 chat:country/1
’/staff/jan/lib/prolog/chat/world0.pl’:72
Your choice?
3.3.2
Editing and incremental compilation
One of the nice features of Prolog is that the code can be modiﬁed while the program is running.
Using pure Prolog you can trace a program, ﬁnd it is misbehaving, enter a break environment, modify
the source code, reload it and ﬁnally do retry on the misbehaving predicate and try again. This
sequence is not uncommon for long-running programs. For faster programs one will normally abort
after understanding the misbehaviour, edit the source, reload it and try again.
One of the nice features of SWI-Prolog is the availability of make/0, a simple predicate that
checks all loaded source ﬁles to see which ones you have modiﬁed. It then reloads these ﬁles, consid-
ering the module from which the ﬁle was loaded originally. This greatly simpliﬁes the trace-edit-verify
development cycle. For example, after the tracer reveals there is something wrong with prove/3,
you do:
?- edit(prove).
Now edit the source, possibly switching to other ﬁles and making multiple changes. After ﬁnishing,
invoke make/0, either through the editor UI (Compile/Make (Control-C Control-M)) or on
the top level, and watch the ﬁles being reloaded.2
?- make.
% show compiled into photo_gallery 0.03 sec, 3,360 bytes
3.4
Using the PceEmacs built-in editor
3.4.1
Activating PceEmacs
Initially edit/1 uses the editor speciﬁed in the EDITOR environment variable. There are two ways
to force it to use the built-in editor. One is to set the Prolog ﬂag editor to pce emacs and the
other is by starting the editor explicitly using the emacs/[0,1] predicates.
2Watching these ﬁles is a good habit. If expected ﬁles are not reloaded you may have forgotten to save them from the
editor or you may have been editing the wrong ﬁle (wrong directory).
SWI-Prolog 6.6 Reference Manual

3.4. USING THE PCEEMACS BUILT-IN EDITOR
63
3.4.2
Blufﬁng through PceEmacs
PceEmacs closely mimics Richard Stallman’s GNU-Emacs commands, adding features from modern
window-based editors to make it more acceptable for beginners.3
At the basis, PceEmacs maps keyboard sequences to methods deﬁned on the extended editor
object. Some frequently used commands are, with their key-binding, presented in the menu bar above
each editor window. A complete overview of the bindings for the current mode is provided through
Help/Show key bindings (Control-h Control-b).
Edit modes
Modes are the heart of (Pce)Emacs. Modes deﬁne dedicated editing support for a particular kind of
(source) text. For our purpose we want Prolog mode. There are various ways to make PceEmacs use
Prolog mode for a ﬁle.
• Using the proper extension
If the ﬁle ends in .pl or the selected alternative (e.g. .pro) extension, Prolog mode is selected.
• Using #!/path/to/pl
If the ﬁle is a Prolog Script ﬁle, starting with the line #!/path/to/pl options -s, Pro-
log mode is selected regardless of the extension.
• Using -*- Prolog -*-
If the above sequence appears in the ﬁrst line of the ﬁle (inside a Prolog comment) Prolog mode
is selected.
• Explicit selection
Finally, using File/Mode/Prolog (y)ou can switch to Prolog mode explicitly.
Frequently used editor commands
Below we list a few important commands and how to activate them.
• Cut/Copy/Paste
These commands follow Unix/X11 traditions. You’re best suited with a three-button mouse.
After selecting using the left-mouse (double-click uses word-mode and triple line-mode), the
selected text is automatically copied to the clipboard (X11 primary selection on Unix). Cut is
achieved using the DEL key or by typing something else at the location. Paste is achieved using
the middle-mouse (or wheel) button. If you don’t have a middle-mouse button, pressing the
left- and right-button at the same time is interpreted as a middle-button click. If nothing helps,
there is the Edit/Paste menu entry. Text is pasted at the caret location.
• Undo
Undo is bound to the GNU-Emacs Control- as well as the MS-Windows Control-Z sequence.
• Abort
Multi-key sequences can be aborted at any stage using Control-G.
3Decent merging with MS-Windows control-key conventions is difﬁcult as many conﬂict with GNU-Emacs. Especially
the cut/copy/paste commands conﬂict with important GNU-Emacs commands.
SWI-Prolog 6.6 Reference Manual

64
CHAPTER 3. INITIALISING AND MANAGING A PROLOG PROJECT
• Find
Find (Search) is started using Control-S (forward) or Control-R (backward). PceEmacs imple-
ments incremental search. This is difﬁcult to use for novices, but very powerful once you get
the clue. After one of the above start keys, the system indicates search mode in the status line.
As you are typing the search string, the system searches for it, extending the search with every
character you type. It illustrates the current match using a green background.
If the target cannot be found, PceEmacs warns you and no longer extends the search string.4
During search, some characters have special meaning. Typing anything but these characters
commits the search, re-starting normal edit mode. Special commands are:
Control-S
Search forwards for next.
Control-R
Search backwards for next.
Control-W
Extend search to next word boundary.
Control-G
Cancel search, go back to where it started.
ESC
Commit search, leaving caret at found location.
Backspace
Remove a character from the search string.
• Dynamic Abbreviation
Also called dabbrev, dynamic abbreviation is an important feature of Emacs clones to support
programming. After typing the ﬁrst few letters of an identiﬁer, you may press Alt-/, causing
PceEmacs to search backwards for identiﬁers that start the same and use it to complete the text
you typed. A second Alt-/ searches further backwards. If there are no hits before the caret, it
starts searching forwards. With some practice, this system allows for entering code very fast
with nice and readable identiﬁers (or other difﬁcult long words).
• Open (a ﬁle)
Is called File/Find ﬁle (Control-x Control-f). By default the ﬁle is loaded into the
current window. If you want to keep this window, press Alt-s or click the little icon at the
bottom left to make the window sticky.
• Split view
Sometimes you want to look at two places in the same ﬁle. To do this, use Control-x 2 to create
a new window pointing to the same ﬁle. Do not worry, you can edit as well as move around in
both. Control-x 1 kills all other windows running on the same ﬁle.
These are the most commonly used commands. In section 3.4.3 we discuss speciﬁc support for
dealing with Prolog source code.
4GNU-Emacs keeps extending the string, but why? Adding more text will not make it match.
SWI-Prolog 6.6 Reference Manual

3.4. USING THE PCEEMACS BUILT-IN EDITOR
65
3.4.3
Prolog Mode
In the previous section (section 3.4.2) we explained the basics of PceEmacs. Here we continue with
Prolog-speciﬁc functionality. Possibly the most interesting is Syntax highlighting. Unlike most editors
where this is based on simple patterns, PceEmacs syntax highlighting is achieved by Prolog itself ac-
tually reading and interpreting the source as you type it. There are three moments at which PceEmacs
checks (part of) the syntax.
• After typing a .
After typing a . that is not preceded by a symbol character, the system assumes you completed
a clause, tries to ﬁnd the start of this clause and veriﬁes the syntax. If this process succeeds it
colours the elements of the clause according to the rules given below. Colouring is done using
information from the last full check on this ﬁle. If it fails, the syntax error is displayed in the
status line and the clause is not coloured.
• After the command Control-c Control-s
Acronym for Check Syntax, it performs the same checks as above for the clause surrounding
the caret. On a syntax error, however, the caret is moved to the expected location of the error.5
• After pausing for two seconds
After a short pause (2 seconds), PceEmacs opens the edit buffer and reads it as a whole, creating
an index of deﬁned, called, dynamic, imported and exported predicates. After completing this,
it re-reads the ﬁle and colours all clauses and calls with valid syntax.
• After typing Control-l Control-l
The Control-l command re-centers the window (scrolls the window to make the caret the center
of the window). Typing this command twice starts the same process as above.
The colour schema
itself is deﬁned in emacs/prolog colour. The colouring can be extended
and modiﬁed using multiﬁle predicates. Please check this source ﬁle for details. In general, underlined
objects have a popup (right-mouse button) associated with common commands such as viewing the
documentation or source. Bold text is used to indicate the deﬁnition of objects (typically predicates
when using plain Prolog). Other colours follow intuitive conventions. See table 3.4.3.
Layout support
Layout is not ‘just nice’, it is essential for writing readable code. There is much
debate on the proper layout of Prolog. PceEmacs, being a rather small project, supports only one
particular style for layout.6 Below are examples of typical constructs.
head(arg1, arg2).
head(arg1, arg2) :- !.
head(Arg1, arg2) :- !,
call1(Arg1).
head(Arg1, arg2) :-
5In most cases the location where the parser cannot proceed is further down the ﬁle than the actual error location.
6Deﬁned in Prolog in the ﬁle emacs/prolog mode, you may wish to extend this. Please contribute your extensions!
SWI-Prolog 6.6 Reference Manual

66
CHAPTER 3. INITIALISING AND MANAGING A PROLOG PROJECT
Clauses
Blue bold
Head of an exported predicate
Red bold
Head of a predicate that is not called
Black bold
Head of remaining predicates
Calls in the clause body
Blue
Call to built-in or imported predicate
Red
Call to undeﬁned predicate
Purple
Call to dynamic predicate
Other entities
Dark green
Comment
Dark blue
Quoted atom or string
Brown
Variable
Table 3.1: Colour conventions
(
if(Arg1)
->
then
;
else
).
head(Arg1) :-
(
a
;
b
).
head :-
a(many,
long,
arguments(with,
many,
more),
and([ a,
long,
list,
with,
a,
| tail
])).
PceEmacs uses the same conventions as GNU-Emacs. The TAB key indents the current line according
to the syntax rules. Alt-q indents all lines of the current clause. It provides support for head, calls
(indented 1 tab), if-then-else, disjunction and argument lists broken across multiple lines as illustrated
above.
SWI-Prolog 6.6 Reference Manual

3.5. THE GRAPHICAL DEBUGGER
67
Finding your way around
The command Alt-. extracts name and arity from the caret location and jumps (after conformation
or edit) to the deﬁnition of the predicate. It does so based on the source-location database of loaded
predicates also used by edit/1. This makes locating predicates reliable if all sources are loaded and
up-to-date (see make/0).
In addition, references to ﬁles in use module/[1,2], consult/1, etc. are red if the ﬁle can-
not be found and underlined blue if the ﬁle can be loaded. A popup allows for opening the referenced
ﬁle.
3.5
The Graphical Debugger
SWI-Prolog offers two debuggers. One is the traditional text console-based 4-port Prolog tracer and
the other is a window-based source level debugger. The window-based debugger requires XPCE
installed. It operates based on the prolog trace interception/4 hook and other low-level
functionality described in chapter B.
Window-based tracing provides a much better overview due to the eminent relation to your source
code, a clear list of named variables and their bindings as well as a graphical overview of the call and
choice point stack. There are some drawbacks though. Using a textual trace on the console, one can
scroll back and examine the past, while the graphical debugger just presents a (much better) overview
of the current state.
3.5.1
Invoking the window-based debugger
Whether the text-based or window-based debugger is used is controlled using the predicates
guitracer/0 and noguitracer/0. Entering debug mode is controlled using the normal pred-
icates for this: trace/0 and spy/1. In addition, PceEmacs prolog mode provides the command
Prolog/Break at (Control-c b) to insert a break-point at a speciﬁc location in the source code.
The graphical tracer is particulary useful for debugging threads. The tracer must be loaded from
the main thread before it can be used from a background thread.
guitracer
This predicate installs the above-mentioned hooks that redirect tracing to the window-based
environment. No window appears. The debugger window appears as actual tracing is started
through trace/0, by hitting a spy point deﬁned by spy/1 or a break point deﬁned using the
PceEmacs command Prolog/Break at (Control-c b).
noguitracer
Disable the hooks installed by guitracer/0, reverting to normal text console-based tracing.
gtrace
Utility deﬁned as guitracer,trace.
gdebug
Utility deﬁned as guitracer,debug.
gspy(+Predicate)
Utility deﬁned as guitracer,spy(Predicate).
SWI-Prolog 6.6 Reference Manual

68
CHAPTER 3. INITIALISING AND MANAGING A PROLOG PROJECT
3.6
The Prolog Navigator
Another tool is the Prolog Navigator. This tool can be started from PceEmacs using the command
Browse/Prolog navigator, from the GUI debugger or using the programmatic IDE interface de-
scribed in section 3.8.
3.7
Cross-referencer
A cross-referencer is a tool that examines the caller-callee relation between predicates, and, using this
information to explicate dependency relations between source ﬁles, ﬁnds calls to non-existing pred-
icates and predicates for which no callers can be found. Cross-referencing is useful during program
development, reorganisation, clean-up, porting and other program maintenance tasks. The dynamic
nature of Prolog makes the task non-trivial. Goals can be created dynamically using call/1 after
construction of a goal term. Abstract interpretation can ﬁnd some of these calls, but they can also come
from external communication, making it impossible to predict the callee. In other words, the cross-
referencer has only partial understanding of the program, and its results are necessarily incomplete.
Still, it provides valuable information to the developer.
SWI-Prolog’s cross-referencer is split into two parts. The standard Prolog library prolog xref
is an extensible library for information gathering described in section A.22, and the XPCE library
pce xref provides a graphical front-end for the cross-referencer described here. We demonstrate
the tool on CHAT80, a natural language question and answer system by Fernando C.N. Pereira and
David H.D. Warren.
gxref
Run cross-referencer on all currently loaded ﬁles and present a graphical overview of the result.
As the predicate operates on the currently loaded application it must be run after loading the
application.
The left window (see ﬁgure 3.1) provides browsers for loaded ﬁles and predicates. To avoid
long ﬁle paths, the ﬁle hierarchy has three main branches. The ﬁrst is the current directory hold-
ing the sources. The second is marked alias, and below it are the ﬁle-search-path aliases (see
file search path/2 and absolute file name/3). Here you ﬁnd ﬁles loaded from the sys-
tem as well as modules of the program loaded from other locations using the ﬁle search path. All
loaded ﬁles that fall outside these categories are below the last branch called /. Files where the
system found suspicious dependencies are marked with an exclamation mark. This also holds for
directories holding such ﬁles. Clicking on a ﬁle opens a File info window in the right pane.
The File info window shows a ﬁle, its main properties, its undeﬁned and not-called predicates and
its import and export relations to other ﬁles in the project. Both predicates and ﬁles can be opened
by clicking on them. The number of callers in a ﬁle for a certain predicate is indicated with a blue
underlined number. A left-click will open a list and allow editing the calling predicate.
The Dependencies (see ﬁgure 3.2) window displays a graphical overview of dependencies be-
tween ﬁles. Using the background menu a complete graph of the project can be created. It is also
possible to drag ﬁles onto the graph window and use the menu on the nodes to incrementally expand
the graph. The underlined blue text indicates the number of predicates used in the destination ﬁle.
Left-clicking opens a menu to open the deﬁnition or select one of the callers.
SWI-Prolog 6.6 Reference Manual

3.7. CROSS-REFERENCER
69
Figure 3.1: File info for chattop.pl, part of CHAT80
Figure 3.2: Dependencies between source ﬁles of CHAT80
SWI-Prolog 6.6 Reference Manual

70
CHAPTER 3. INITIALISING AND MANAGING A PROLOG PROJECT
Module and non-module ﬁles
The cross-referencer threads module and non-module project ﬁles
differently. Module ﬁles have explicit import and export relations and the tool shows the usage and
consistency of the relations. Using the Header menu command, the tool creates a consistent import
list for the module that can be included in the ﬁle. The tool computes the dependency relations
between the non-module ﬁles. If the user wishes to convert the project into a module-based one,
the Header command generates an appropriate module header and import list. Note that the cross-
referencer may have missed dependencies and does not deal with meta-predicates deﬁned in one
module and called in another. Such problems must be resolved manually.
Settings
The following settings can be controlled from the settings menu:
Warn autoload
By default disabled. If enabled, modules that require predicates to be autoloaded are ﬂagged
with a warning and the ﬁle info window of a module shows the required autoload predicates.
Warn not called
If enabled (default), the ﬁle overview shows an alert icon for ﬁles that have predicates that are
not called.
3.8
Accessing the IDE from your program
Over the years a collection of IDE components have been developed, each with its own interface.
In addition, some of these components require each other, and loading IDE components must be on
demand to avoid the IDE being part of a saved state (see qsave program/2). For this reason,
access to the IDE is concentrated on a single interface called prolog ide/1:
prolog ide(+Action)
This predicate ensures the IDE-enabling XPCE component is loaded, creates the XPCE class
prolog ide and sends Action to its one and only instance @prolog_ide. Action is one of the
following:
open navigator(+Directory)
Open the Prolog Navigator (see section 3.6) in the given Directory.
open debug status
Open a window to edit spy and trace points.
open query window
Open a little window to run Prolog queries from a GUI component.
thread monitor
Open a graphical window indicating existing threads and their status.
debug monitor
Open a graphical front-end for the debug library that provides an overview of the topics
and catches messages.
xref
Open a graphical front-end for the cross-referencer that provides an overview of predicates
and their callers.
SWI-Prolog 6.6 Reference Manual

3.9. SUMMARY OF THE IDE
71
3.9
Summary of the IDE
The SWI-Prolog development environment consists of a number of interrelated but not (yet) integrated
tools. Here is a list of the most important features and tips.
• Atom completion
The console7 completes a partial atom on the TAB key and shows alternatives on the command
Alt-?.
• Use edit/1 for ﬁnding locations
The command edit/1 takes the name of a ﬁle, module, predicate or other entity registered
through extensions and starts the user’s preferred editor at the right location.
• Select editor
External editors are selected using the EDITOR environment variable, by setting the Prolog ﬂag
editor, or by deﬁning the hook prolog edit:edit source/1.
• Update Prolog after editing
Using make/0, all ﬁles you have edited are re-loaded.
• PceEmacs
Offers syntax highlighting and checking based on real-time parsing of the editor’s buffer, layout
support and navigation support.
• Using the graphical debugger
The predicates guitracer/0 and noguitracer/0 switch between traditional text-based
and window-based debugging. The tracer is activated using the trace/0, spy/1 or menu
items from PceEmacs or the Prolog Navigator.
• The Prolog Navigator
Shows the ﬁle structure and structure inside the ﬁle. It allows for loading ﬁles, editing, setting
spy points, etc.
7On Windows this is realised by swipl-win.exe, on Unix through the GNU readline library, which is included automati-
cally when found by configure.
SWI-Prolog 6.6 Reference Manual

Built-in Predicates
4
4.1
Notation of Predicate Descriptions
We have tried to keep the predicate descriptions clear and concise. First, the predicate name is printed
in bold face, followed by the arguments in italics. Arguments are preceded by a mode indicator.
There is no complete agreement on mode indicators in the Prolog community. We use the following
deﬁnitions:1
+
Argument must be fully instantiated to a term that satisﬁes the required
argument type. Think of the argument as input.
-
Argument must be unbound. Think of the argument as output.
?
Argument must be bound to a partial term of the indicated type.
Note that a variable is a partial term for any type.
Think of the
argument as either input or output or both input and output.
For
example, in stream property(S, reposition(Bool)), the
reposition part of the term is input and the uninstantiated Bool is
output.
:
Argument is a meta-argument. Implies +. See chapter 5 for more infor-
mation on module handling.
@
Argument is not further instantiated. Typically used for type tests.
!
Argument contains a mutable structure that may be modiﬁed using
setarg/3 or nb setarg/3.
Referring to a predicate in running text is done using a predicate indicator. The canonical and
most generic form of a predicate indicator is a term ⟨module⟩:⟨name⟩/⟨arity⟩. If the module is irrele-
vant (built-in predicate) or can be inferred from the context it is often omitted. Compliant to the ISO
standard draft on DCG (see section 4.12), SWI-Prolog also allows for [⟨module⟩]:⟨name⟩//⟨arity⟩to
refer to a grammar rule. For all non-negative arity, ⟨name⟩//⟨arity⟩is the same as ⟨name⟩/⟨arity⟩+2,
regardless of whether or not the referenced predicate is deﬁned or can be used as a grammar rule. The
//-notation can be used in all places that traditionally allow for a predicate indicator, e.g., the module
declaration, spy/1, and dynamic/1.
4.2
Character representation
In traditional (Edinburgh) Prolog, characters are represented using character codes. Character codes
are integer indices into a speciﬁc character set. Traditionally the character set was 7-bit US-ASCII.
1These deﬁnitions are taken from PlDoc. The current manual has only one mode declaration per predicate and therefore
predicates with mode (+,-) and (-,+) are described as (?,?). The @-mode is often replaced by +.
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
73
8-bit character sets have been allowed for a long time, providing support for national character sets,
of which iso-latin-1 (ISO 8859-1) is applicable to many Western languages.
ISO Prolog introduces three types, two of which are used for characters and one for accessing
binary streams (see open/4). These types are:
• code
A character code is an integer representing a single character. As ﬁles may use multi-byte
encoding for supporting different character sets (utf-8 encoding for example), reading a code
from a text ﬁle is in general not the same as reading a byte.
• char
Alternatively, characters may be represented as one-character atoms. This is a natural repre-
sentation, hiding encoding problems from the programmer as well as providing much easier
debugging.
• byte
Bytes are used for accessing binary streams.
In SWI-Prolog, character codes are always the Unicode equivalent of the encoding. That is,
if get code/1 reads from a stream encoded as KOI8-R (used for the Cyrillic alphabet), it re-
turns the corresponding Unicode code points. Similarly, assembling or disassembling atoms using
atom codes/2 interprets the codes as Unicode points. See section 2.18.1 for details.
To ease the pain of the two character representations (code and char), SWI-Prolog’s built-in predi-
cates dealing with character data work as ﬂexible as possible: they accept data in any of these formats
as long as the interpretation is unambiguous. In addition, for output arguments that are instantiated,
the character is extracted before uniﬁcation. This implies that the following two calls are identical,
both testing whether the next input character is an a.
peek_code(Stream, a).
peek_code(Stream, 97).
The two character representations are handled by a large number of built-in predicates,
all of which are ISO-compatible.
For converting between code and character there is
char code/2.
For breaking atoms and numbers into characters there are atom chars/2,
atom codes/2, number chars/2 and number codes/2.
For character I/O on streams
there are get char/[1,2], get code/[1,2], get byte/[1,2], peek char/[1,2],
peek code/[1,2],
peek byte/[1,2],
put code/[1,2],
put char/[1,2]
and
put byte/[1,2]. The Prolog ﬂag double quotes controls how text between double quotes is
interpreted.
4.3
Loading Prolog source ﬁles
This section deals with loading Prolog source ﬁles. A Prolog source ﬁle is a plain text ﬁle containing
a Prolog program or part thereof. Prolog source ﬁles come in three ﬂavours:
SWI-Prolog 6.6 Reference Manual

74
CHAPTER 4. BUILT-IN PREDICATES
A traditional Prolog source ﬁle contains Prolog clauses and directives, but no module declara-
tion (see module/1). They are normally loaded using consult/1 or ensure loaded/1.
Currently, a non-module ﬁle can only be loaded into a single module.2
A module Prolog source ﬁle starts with a module declaration. The subsequent Prolog code is loaded
into the speciﬁed module, and only the exported predicates are made available to the context
loading the module. Module ﬁles are normally loaded with use module/[1,2]. See chap-
ter 5 for details.
An include Prolog source ﬁle is loaded using the include/1 directive, textually including Prolog
text into another Prolog source. A ﬁle may be included into multiple source ﬁles and is typically
used to share declarations such as multiﬁle or dynamic between source ﬁles.
Prolog source ﬁles are located using absolute file name/3 with the following options:
locate_prolog_file(Spec, Path) :-
absolute_file_name(Spec,
[ file_type(prolog),
access(read)
],
Path).
The
file type(prolog)
option
is
used
to
determine
the
extension
of
the
ﬁle
using
prolog file type/2. The default extension is .pl. Spec allows for the path alias construct de-
ﬁned by absolute file name/3. The most commonly used path alias is library(LibraryFile).
The example below loads the library ﬁle ordsets.pl (containing predicates for manipulating or-
dered sets).
:- use_module(library(ordsets)).
SWI-Prolog recognises grammar rules (DCG) as deﬁned in [Clocksin & Melish, 1987]. The user
may deﬁne additional compilation of the source ﬁle by deﬁning the dynamic multiﬁle predicates
term expansion/2, term expansion/4, goal expansion/2 and goal expansion/4.
It is not allowed to use assert/1,
retract/1 or any other database predicate in
term expansion/2 other than for local computational purposes.3 Code that needs to create ad-
ditional clauses must use compile aux clauses/1. See library(apply macros) for an
example.
A directive is an instruction to the compiler. Directives are used to set (predicate) properties (see
section 4.14), set ﬂags (see set prolog flag/2) and load ﬁles (this section). Directives are terms
of the form :- ⟨term⟩.. Here are some examples:
:- use_module(library(lists)).
:- dynamic
store/2.
% Name, Value
2This limitation may be lifted in the future. Existing limitations in SWI-Prolog’s source code administration make this
non-trivial.
3It does work for normal loading, but not for qcompile/1.
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
75
Predicate
if
must be module
import
consult/1
true
false
all
ensure loaded/1
not loaded
false
all
use module/1
not loaded
true
all
use module/2
not loaded
true
speciﬁed
reexport/1
not loaded
true
all
reexport/2
not loaded
true
speciﬁed
Table 4.1: Properties of the ﬁle-loading predicates. The import column speciﬁes what is imported if
the loaded ﬁle is a module ﬁle.
The directive initialization/1 can be used to run arbitrary Prolog goals. The speciﬁed goal is
started after loading the ﬁle in which it appears has completed.
SWI-Prolog compiles code as it is read from the ﬁle, and directives are executed as goals. This
implies that directives may call any predicate that has been deﬁned before the point where the directive
appears. It also accepts ?- ⟨term⟩. as a synonym.
SWI-Prolog does not have a separate reconsult/1 predicate. Reconsulting is implied auto-
matically by the fact that a ﬁle is consulted which is already loaded.
Advanced topics are handled in subsequent sections: mutually dependent ﬁles (section 4.3.2),
multithreaded loading (section 4.3.2) and reloading running code (section 4.3.2).
The core of the family of loading predicates is load files/2. The predicates consult/1,
ensure loaded/1, use module/1, use module/2 and reexport/1 pass the ﬁle argument
directly to load files/2 and pass additional options as expressed in the table 4.1:
load ﬁles(:Files, +Options)
The predicate load files/2 is the parent of all the other loading predicates except for
include/1. It currently supports a subset of the options of Quintus load files/2. Files
is either a single source ﬁle or a list of source ﬁles. The speciﬁcation for a source ﬁle is handed
to absolute file name/2. See this predicate for the supported expansions. Options is a
list of options using the format OptionName(OptionValue).
The following options are currently supported:
autoload(Bool)
If true (default false), indicate that this load is a demand load. This implies that,
depending on the setting of the Prolog ﬂag verbose autoload, the load action is
printed at level informational or silent.
See also print message/2 and
current prolog flag/2.
derived from(File)
Indicate that the loaded ﬁle is derived from File. Used by make/0 to time-check and
load the original ﬁle rather than the derived ﬁle.
dialect(+Dialect)
Load Files with enhanced compatibility with the target Prolog system identiﬁed by Di-
alect. See expects dialect/1 and section C for details.
encoding(Encoding)
Specify the way characters are encoded in the ﬁle. Default is taken from the Prolog ﬂag
encoding. See section 2.18.1 for details.
SWI-Prolog 6.6 Reference Manual

76
CHAPTER 4. BUILT-IN PREDICATES
expand(Bool)
If true, run the ﬁlenames through expand file name/2 and load the returned ﬁles.
Default is false, except for consult/1 which is intended for interactive use. Flexible
location of ﬁles is deﬁned by file search path/2.
format(+Format)
Used to specify the ﬁle format if data is loaded from a stream using the stream(Stream)
option. Default is source, loading Prolog source text. If qlf, load QLF data (see
qcompile/1).
if(Condition)
Load the ﬁle only if the speciﬁed condition is satisﬁed. The value true loads the ﬁle
unconditionally, changed loads the ﬁle if it was not loaded before or has been modiﬁed
since it was loaded the last time, and not loaded loads the ﬁle if it was not loaded
before.
imports(Import)
Specify what to import from the loaded module. The default for use module/1 is
all. Import is passed from the second argument of use module/2. Traditionally it is
a list of predicate indicators to import. As part of the SWI-Prolog/YAP integration, we
also support Pred as Name to import a predicate under another name. Finally, Import
can be the term except(Exceptions), where Exceptions is a list of predicate indicators
that specify predicates that are not imported or Pred as Name terms to denote renamed
predicates. See also reexport/2 and use module/2.4
If Import equals all, all operators are imported as well. Otherwise, operators are not
imported. Operators can be imported selectively by adding terms op(Pri,Assoc,Name) to
the Import list. If such a term is encountered, all exported operators that unify with this
term are imported. Typically, this construct will be used with all arguments unbound to
import all operators or with only Name bound to import a particular operator.
modiﬁed(TimeStamp)
Claim that the source was loaded at TimeStamp without checking the source. This option
is intended to be used together with the stream(Input) option, for example after
extracting the time from an HTTP server or database.
must be module(Bool)
If true, raise an error if the ﬁle is not a module ﬁle. Used by use module/[1,2].
qcompile(Atom)
How to deal with quick-load-ﬁle compilation by qcompile/1. Values are:
never
Default. Do not use qcompile unless called explicitly.
auto
Use qcompile for all writeable ﬁles. See comment below.
large
Use qcompile if the ﬁle is ‘large’. Currently, ﬁles larger than 100 Kbytes are consid-
ered large.
4BUG: Name/Arity as NewName is currently implemented using a link clause. This harms efﬁciency and does not allow
for querying the relation through predicate property/2.
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
77
part
If this load file/2 appears in a directive of a ﬁle that is compiled into Quick
Load Format using qcompile/1, the contents of the argument ﬁles are included in
the .qlf ﬁle instead of the loading directive.
If this option is not present, it uses the value of the Prolog ﬂag qcompile as default.
redeﬁne module(+Action)
Deﬁnes what to do if a ﬁle is loaded that provides a module that is already loaded from
another ﬁle. Action is one of false (default), which prints an error and refuses to load
the ﬁle, or true, which uses unload file/1 on the old ﬁle and then proceeds loading
the new ﬁle. Finally, there is ask, which starts interaction with the user. ask is only
provided if the stream user input is associated with a terminal.
reexport(Bool)
If true re-export the imported predicate. Used by reexport/1 and reexport/2.
register(Bool)
If false, do not register the load location and options.
This option is used by
make/0 and load hotfixes/1 to avoid polluting the load-context database. See
source file property/2.
sandboxed(Bool)
Load the ﬁle in sandboxed mode. This option controls the ﬂag sandboxed load. The
only meaningful value for Bool is true. Using false while the Prolog ﬂag is set to
true raises a permission error.
scope settings(Bool)
Scope style check/1 and expects dialect/1 to the ﬁle and ﬁles loaded from
the ﬁle after the directive. Default is true. The system and user initialization ﬁles (see
-f and -F) are loading with scope settings(false).
silent(Bool)
If true, load the ﬁle without printing a message. The speciﬁed value is the default for
all ﬁles loaded as a result of loading the speciﬁed ﬁles. This option writes the Prolog ﬂag
verbose load with the negation of Bool.
stream(Input)
This SWI-Prolog extension compiles the data from the stream Input. If this option is
used, Files must be a single atom which is used to identify the source location of the
loaded clauses as well as to remove all clauses if the data is reconsulted.
This option is added to allow compiling from non-ﬁle locations such as databases, the
web, the user (see consult/1) or other servers. It can be combined with format(qlf)
to load QLF data from a stream.
The load files/2 predicate can be hooked to load other data or data from objects other than
ﬁles. See prolog load file/2 for a description and http/http load for an example.
All hooks for load files/2 are documented in section B.9.
consult(:File)
Read File as a Prolog source ﬁle. Calls to consult/1 may be abbreviated by just typing a
number of ﬁlenames in a list. Examples:
SWI-Prolog 6.6 Reference Manual

78
CHAPTER 4. BUILT-IN PREDICATES
?- consult(load).
% consult load or load.pl
?- [library(lists)].
% load library lists
?- [user].
% Type program on the terminal
The predicate consult/1 is equivalent to load_files(File, []), except for handling
the special ﬁle user, which reads clauses from the terminal. See also the stream(Input)
option of load files/2.
ensure loaded(:File)
If the ﬁle is not already loaded, this is equivalent to consult/1. Otherwise, if the ﬁle deﬁnes
a module, import all public predicates. Finally, if the ﬁle is already loaded, is not a module
ﬁle, and the context module is not the global user module, ensure loaded/1 will call
consult/1.
With this semantics, we hope to get as close as possible to the clear semantics with-
out the presence of a module system.
Applications using modules should consider using
use module/[1,2].
Equivalent to load_files(Files, [if(not_loaded)]).5
include(+File)
[ISO]
Textually include the content of File in the ﬁle in which the directive :- include(File).
appears. The include construct is only honoured if it appears as a directive in a source ﬁle.
Textual include (similar to C/C++ #include) is obviously useful for sharing declarations such
as dynamic/1 or multifile/1 by including a ﬁle with directives from multiple ﬁles that
use these predicates.
Textual including ﬁles that contain clauses is less obvious. Normally, in SWI-Prolog, clauses
are owned by the ﬁle in which they are deﬁned. This information is used to replace the old
deﬁnition after the ﬁle has beeen modiﬁed and is reloaded by, e.g., make/0. As we understand
it, include/1 is intended to include the same ﬁle multiple times. Including a ﬁle holding
clauses multiple times into the same module is rather meaningless as it just duplicates the same
clauses. Including a ﬁle holding clauses in multiple modules does not suffer from this problem,
but leads to multiple equivalent copies of predicates. Using use module/1 can achieve the
same result while sharing the predicates.
Despite these observations, various projects seem to be using include/1 to load ﬁles hold-
ing clauses, typically loading them only once. Such usage would allow replacement by, e.g.,
consult/1. Unfortunately, the same project might use include/1 to share directives. An-
other example of a limitation of mapping to consult/1 is that if the clauses of a predicate
are distributed over two included ﬁles, discontiguous/1 is appropriate, while if they are
distributed over two consulted ﬁles, one must use multifile/1.
To accommodate included ﬁles holding clauses, SWI-Prolog distinguishes between the source
location of a clause (in this case the included ﬁle) and the owner of a clause (the ﬁle that includes
the ﬁle holding the clause). The source location is used by, e.g., edit/1, the graphical tracer,
etc., while the owner is used to determine which clauses are removed if the ﬁle is modiﬁed.
Relevant information is found with the following predicates:
5On older versions the condition used to be if(changed). Poor time management on some machines or copying
often caused problems. The make/0 predicate deals with updating the running system after changing the source code.
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
79
• source file/2 describes the owner relation.
• predicate property/2 describes the source location (of the ﬁrst clause).
• clause property/2 provides access to both source and ownership.
• source file property/2 can be used to query include relationships between ﬁles.
require(+ListOfNameAndArity)
Declare that this ﬁle/module requires the speciﬁed predicates to be deﬁned “with their com-
monly accepted deﬁnition”. This predicate originates from the Prolog portability layer for
XPCE. It is intended to provide a portable mechanism for specifying that this module requires
the speciﬁed predicates.
The implementation normally ﬁrst veriﬁes whether the predicate is already deﬁned. If not, it
will search the libraries and load the required library.
SWI-Prolog, having autoloading, does not load the library. Instead it creates a procedure header
for the predicate if it does not exist. This will ﬂag the predicate as ‘undeﬁned’. See also
check/0 and autoload/0.
encoding(+Encoding)
This directive can appear anywhere in a source ﬁle to deﬁne how characters are encoded in the
remainder of the ﬁle. It can be used in ﬁles that are encoded with a superset of US-ASCII,
currently UTF-8 and ISO Latin-1. See also section 2.18.1.
make
Consult all source ﬁles that have been changed since they were consulted. It checks all loaded
source ﬁles: ﬁles loaded into a compiled state using pl -c ... and ﬁles loaded using
consult/1 or one of its derivatives.
The predicate make/0 is called after edit/1,
automatically reloading all modiﬁed ﬁles. If the user uses an external editor (in a separate
window), make/0 is normally used to update the program after editing. In addition, make/0
updates the autoload indices (see section 2.13) and runs list undefined/0 from the
check library to report on undeﬁned predicates.
library directory(?Atom)
Dynamic predicate used to specify library directories. Default ./lib, ˜/lib/prolog and
the system’s library (in this order) are deﬁned. The user may add library directories using
assertz/1, asserta/1 or remove system defaults using retract/1. Deprecated. New
code should use file search path/2.
ﬁle search path(+Alias, ?Path)
Dynamic predicate used to specify ‘path aliases’. This feature is best described using an exam-
ple. Given the deﬁnition:
file_search_path(demo, ’/usr/lib/prolog/demo’).
the ﬁle speciﬁcation demo(myfile) will be expanded to /usr/lib/prolog/demo/
myfile. The second argument of file search path/2 may be another alias.
Below is the initial deﬁnition of the ﬁle search path. This path implies swi(⟨Path⟩) and refers
to a ﬁle in the SWI-Prolog home directory. The alias foreign(⟨Path⟩) is intended for storing
shared libraries (.so or .DLL ﬁles). See also load foreign library/[1,2].
SWI-Prolog 6.6 Reference Manual

80
CHAPTER 4. BUILT-IN PREDICATES
user:file_search_path(library, X) :-
library_directory(X).
user:file_search_path(swi, Home) :-
current_prolog_flag(home, Home).
user:file_search_path(foreign, swi(ArchLib)) :-
current_prolog_flag(arch, Arch),
atom_concat(’lib/’, Arch, ArchLib).
user:file_search_path(foreign, swi(lib)).
user:file_search_path(path, Dir) :-
getenv(’PATH’, Path),
(
current_prolog_flag(windows, true)
->
atomic_list_concat(Dirs, (;), Path)
;
atomic_list_concat(Dirs, :, Path)
),
member(Dir, Dirs).
The file search path/2 expansion is used by all loading predicates as well as by
absolute file name/[2,3].
The Prolog ﬂag verbose file search can be set to true to help debugging Prolog’s
search for ﬁles.
expand ﬁle search path(+Spec, -Path)
Uniﬁes Path with all possible expansions of the ﬁlename speciﬁcation Spec.
See also
absolute file name/3.
prolog ﬁle type(?Extension, ?Type)
This dynamic multiﬁle predicate deﬁned in module user determines the extensions considered
by file search path/2. Extension is the ﬁlename extension without the leading dot, and
Type denotes the type as used by the file type(Type) option of file search path/2.
Here is the initial deﬁnition of prolog file type/2:
user:prolog_file_type(pl,
prolog).
user:prolog_file_type(Ext,
prolog) :-
current_prolog_flag(associate, Ext),
Ext \== pl.
user:prolog_file_type(qlf,
qlf).
user:prolog_file_type(Ext,
executable) :-
current_prolog_flag(shared_object_extension, Ext).
Users can add extensions for Prolog source ﬁles to avoid conﬂicts (for example with perl)
as well as to be compatible with another Prolog implementation. We suggest using .pro for
avoiding conﬂicts with perl. Overriding the system deﬁnitions can stop the system from
ﬁnding libraries.
source ﬁle(?File)
True if File is a loaded Prolog source ﬁle. File is the absolute and canonical path to the source
ﬁle.
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
81
source ﬁle(?Pred, ?File)
True if the predicate speciﬁed by Pred was loaded from ﬁle File, where File is an absolute path
name (see absolute file name/2). Can be used with any instantiation pattern, but the
database only maintains the source ﬁle for each predicate. See also clause property/2.
Note that the relation between ﬁles and predicates is more complicated if include/1 is used.
The predicate describes the owner of the predicate. See include/1 for details.
source ﬁle property(?File, ?Property)
True when Property is a property of the loaded ﬁle File. If File is non-var, it can be a ﬁle
speciﬁcation that is valid for load files/2. Deﬁned properties are:
derived from(Original, OriginalModiﬁed)
File was generated from the ﬁle Original, which was last modiﬁed at time OriginalMod-
iﬁed at the time it was loaded. This property is available if File was loaded using the
derived from(Original) option to load files/2.
includes(IncludedFile, IncludedFileModiﬁed)
File used include/1 to include IncludedFile. The last modiﬁed time of IncludedFile
was IncludedFileModiﬁed at the time it was included.
included in(MasterFile, Line)
File was included into MasterFile from line Line. This is the inverse of the includes
property.
load context(Module, Location, Options)
Module is the module into which the ﬁle was loaded. If File is a module, this is the
module into which the exports are imported. Otherwise it is the module into which the
clauses of the non-module ﬁle are loaded.
Location describes the ﬁle location from
which the ﬁle was loaded. It is either a term ⟨ﬁle⟩:⟨line⟩or the atom user if the ﬁle was
loaded from the terminal or another unknown source. Options are the options passed to
load files/2. Note that all predicates to load ﬁles are mapped to load files/2,
using the option argument to specify the exact behaviour.
modiﬁed(Stamp)
File modiﬁcation time when File was loaded. This is used by make/0 to ﬁnd ﬁles whose
modiﬁcation time is different from when it was loaded.
module(Module)
File is a module ﬁle that declares the module Module.
unload ﬁle(+File)
Remove all clauses loaded from File. If File loaded a module, clear the module’s export list
and disassociate it from the ﬁle. File is a canonical ﬁlename or a ﬁle indicator that is valid for
load files/2.
This predicate should be used with care. The multithreaded nature of SWI-Prolog makes re-
moving static code unsafe. Attempts to do this should be reserved for development or situations
where the application can guarantee that none of the clauses associated to File are active.
prolog load context(?Key, ?Value)
Obtain context information during compilation.
This predicate can be used from direc-
tives appearing in a source ﬁle to get information about the ﬁle being loaded.
See also
source location/2 and if/1. The following keys are deﬁned:
SWI-Prolog 6.6 Reference Manual

82
CHAPTER 4. BUILT-IN PREDICATES
Key
Description
module
Module into which ﬁle is loaded
source
File being loaded. If the system is processing an included ﬁle, the value
is the main ﬁle. Returns the original Prolog ﬁle when loading a .qlf
ﬁle.
file
Similar to source, but returns the ﬁle being included when called while
an include ﬁle is being processed
stream
Stream identiﬁer (see current input/1)
directory
Directory in which source lives
dialect
Compatibility mode. See expects dialect/1.
term position
Position
of
last
term
read.
Term
of
the
form
’$stream position’(0,⟨Line⟩,0,0,0).
See
also
stream position data/3.
variable names
A list of ‘Name = Var’ of the last term read. See read term/2 for
details.
script
Boolean that indicates whether the ﬁle is loaded as a script ﬁle (see -s)
The directory is commonly used to add rules to file search path/2, setting up a
search path for ﬁnding ﬁles with absolute file name/3. For example:
:- dynamic user:file_search_path/2.
:- multifile user:file_search_path/2.
:- prolog_load_context(directory, Dir),
asserta(user:file_search_path(my_program_home, Dir)).
...
absolute_file_name(my_program_home(’README.TXT’), ReadMe,
[ access(read) ]),
...
source location(-File, -Line)
If the last term has been read from a physical ﬁle (i.e., not from the ﬁle user or a string), unify
File with an absolute path to the ﬁle and Line with the line number in the ﬁle. New code should
use prolog load context/2.
at halt(:Goal)
Register Goal to be run from PL cleanup(), which is called when the system halts. The
hooks are run in the reverse order they were registered (FIFO). Success or failure executing
a hook is ignored. If the hook raises an exception this is printed using print message/2.
An attempt to call halt/[0,1] from a hook is ignored. Hooks may call cancel halt/1,
causing halt/0 and PL halt(0) to print a message indicating that halting the system has
been cancelled.
cancel halt(+Reason)
If this predicate is called from a hook registered with at halt/1, halting Prolog is cancelled
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
83
and an informational message is printed that includes Reason. This is used by the development
tools to cancel halting the system if the editor has unsafed data and the user decides to cancel.
:- initialization(:Goal)
[ISO]
Call Goal after loading the source ﬁle in which this directive appears has been completed. In
addition, Goal is executed if a saved state created using qsave program/1 is restored.
The ISO standard only allows for using :- Term if Term is a directive. This means that
arbitrary goals can only be called from a directive by means of the initialization/1
directive. SWI-Prolog does not enforce this rule.
The initialization/1 directive must be used to do program initialization in saved states
(see qsave program/1). A saved state contains the predicates, Prolog ﬂags and operators
present at the moment the state was created. Other resources (records, foreign resources, etc.)
must be recreated using initialization/1 directives or from the entry goal of the saved
state.
Up to SWI-Prolog 5.7.11,
Goal was executed immediately rather than after load-
ing the program text in which the directive appears as dictated by the ISO stan-
dard.
In many cases the exact moment of execution is irrelevant,
but there are
exceptions.
For example,
load foreign library/1 must be executed immedi-
ately to make the loaded foreign predicates available for exporting.
SWI-Prolog
now provides the directive use foreign library/1 to ensure immediate loading as
well as loading after restoring a saved state.
If the system encounters a directive
:- initialization(load foreign library(...)), it will load the foreign li-
brary immediately and issue a warning to update your code. This behaviour can be extended
by providing clauses for the multiﬁle hook predicate prolog:initialize now(Term, Ad-
vice), where Advice is an atom that gives advice on how to resolve the compatibility issue.
initialization(:Goal, +When)
Similar to initialization/1, but allows for specifying when Goal is executed while
loading the program text:
now
Execute Goal immediately.
after load
Execute Goal after loading program text. This is the same as initialization/1.
restore
Do not execute Goal while loading the program, but only when restoring a state.
compiling
True if the system is compiling source ﬁles with the -c option or qcompile/1 into
an intermediate code ﬁle.
Can be used to perform conditional code optimisations in
term expansion/2 (see also the -O option) or to omit execution of directives during
compilation.
4.3.1
Conditional compilation and program transformation
ISO Prolog deﬁnes no way for program transformations such as macro expansion or conditional com-
pilation. Expansion through term expansion/2 and expand term/2 can be seen as part of the
SWI-Prolog 6.6 Reference Manual

84
CHAPTER 4. BUILT-IN PREDICATES
de-facto standard. This mechanism can do arbitrary translation between valid Prolog terms read from
the source ﬁle to Prolog terms handed to the compiler. As term expansion/2 can return a list,
the transformation does not need to be term-to-term.
Various Prolog dialects provide the analogous goal expansion/2 and expand goal/2 that
allow for translation of individual body terms, freeing the user of the task to disassemble each clause.
term expansion(+Term1, -Term2)
Dynamic and multiﬁle predicate, normally not deﬁned. When deﬁned by the user all terms
read during consulting are given to this predicate. If the predicate succeeds Prolog will assert
Term2 in the database rather than the read term (Term1). Term2 may be a term of the form
?- Goal. or :- Goal. Goal is then treated as a directive. If Term2 is a list, all terms of
the list are stored in the database or called (for directives). If Term2 is of the form below, the
system will assert Clause and record the indicated source location with it:
’$source location’(⟨File⟩, ⟨Line⟩):⟨Clause⟩
When compiling a module (see chapter 5 and the directive module/2), expand term/2
will ﬁrst try term expansion/2 in the module being compiled to allow for term expan-
sion rules that are local to a module. If there is no local deﬁnition, or the local deﬁnition
fails to translate the term, expand term/2 will try term expansion/2 in module user.
For compatibility with SICStus and Quintus Prolog, this feature should not be used. See also
expand term/2, goal expansion/2 and expand goal/2.
expand term(+Term1, -Term2)
This predicate is normally called by the compiler on terms read from the input to perform
preprocessing. It consists of four steps, where each step processes the output of the previous
step.
1. Test conditional compilation directives and translate all input to [] if we are in a ‘false
branch’ of the conditional compilation. See section 4.3.1.
2. Call term expansion/2. This predicate is ﬁrst tried in the module that is being com-
piled and then in the module user.
3. Call DCG expansion (dcg translate rule/2).
4. Call expand goal/2 on each body term that appears in the output of the previous steps.
goal expansion(+Goal1, -Goal2)
Like term expansion/2, goal expansion/2 provides for macro expansion of Prolog
source code. Between expand term/2 and the actual compilation, the body of clauses anal-
ysed and the goals are handed to expand goal/2, which uses the goal expansion/2
hook to do user-deﬁned expansion.
The predicate goal expansion/2 is ﬁrst called in the module that is being compiled, and
then on the user module. If Goal is of the form Module:Goal where Module is instantiated,
goal expansion/2 is called on Goal using rules from module Module followed by user.
Only goals appearing in the body of clauses when reading a source ﬁle are expanded using
this mechanism, and only if they appear literally in the clause, or as an argument to a deﬁned
meta-predicate that is annotated using ‘0’ (see meta predicate/1). Other cases need a real
predicate deﬁnition.
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
85
expand goal(+Goal1, -Goal2)
This predicate is normally called by the compiler to perform preprocessing using
goal expansion/2.
The predicate computes a ﬁxed-point by applying transforma-
tions until there are no more changes. If optimisation is enabled (see -O and optimise),
expand goal/2 simpliﬁes the result by removing unneeded calls to true/0 and fail/0
as well as unreachable branches.
compile aux clauses(+Clauses)
Compile clauses on behalf of goal expansion/2. This predicate compiles the argument
clauses into static predicates, associating the predicates with the current ﬁle but avoids changing
the notion of current predicate and therefore discontiguous warnings.
dcg translate rule(+In, -Out)
This predicate performs the translation of a term Head-->Body into a normal Prolog clause.
Normally this functionality should be accessed using expand term/2.
Program transformation with source layout info
This sections documents extended versions of the program transformation predicates that also trans-
form the source layout information. Extended layout information is currently processed, but unused.
Future versions will use for the following enhancements:
• More precise locations of warnings and errors
• More reliable setting of breakpoints
• More reliable source layout information in the graphical debugger.
expand goal(+Goal1, ?Layout1, -Goal2, -Layout2)
goal expansion(+Goal1, ?Layout1, -Goal2, -Layout2)
expand term(+Term1, ?Layout1, -Term2, -Layout2)
term expansion(+Term1, ?Layout1, -Term2, -Layout2)
dcg translate rule(+In, ?LayoutIn, -Out, -LayoutOut)
These versions are called before their 2-argument counterparts. The input layout term is either
a variable (if no layout information is available) or a term carrying detailed layout information
as returned by the subterm positions of read term/2.
Conditional compilation
Conditional
compilation
builds
on
the
same
principle
as
term expansion/2,
goal expansion/2 and the expansion of grammar rules to compile sections of the source
code conditionally. One of the reasons for introducing conditional compilation is to simplify writing
portable code. See section C for more information. Here is a simple example:
:- if(\+source_exports(library(lists), suffix/2)).
suffix(Suffix, List) :-
SWI-Prolog 6.6 Reference Manual

86
CHAPTER 4. BUILT-IN PREDICATES
append(_, Suffix, List).
:- endif.
Note that these directives can only appear as separate terms in the input. Typical usage scenarios
include:
• Load different libraries on different dialects.
• Deﬁne a predicate if it is missing as a system predicate.
• Realise totally different implementations for a particular part of the code due to different capa-
bilities.
• Realise different conﬁguration options for your software.
:- if(:Goal)
Compile subsequent code only if Goal succeeds. For enhanced portability, Goal is processed
by expand goal/2 before execution. If an error occurs, the error is printed and processing
proceeds as if Goal has failed.
:- elif(:Goal)
Equivalent to :- else.
:-if(Goal). ... :- endif. In a sequence as below, the
section below the ﬁrst matching elif is processed. If no test succeeds, the else branch is
processed.
:- if(test1).
section_1.
:- elif(test2).
section_2.
:- elif(test3).
section_3.
:- else.
section_else.
:- endif.
:- else
Start ‘else’ branch.
:- endif
End of conditional compilation.
4.3.2
Loading ﬁles, active code and threads
Traditionally, Prolog environments allow for reloading ﬁles holding currently active code. In particu-
lar, the following sequence is a valid use of the development environment:
• Trace a goal
• Find unexpected behaviour of a predicate
SWI-Prolog 6.6 Reference Manual

4.3. LOADING PROLOG SOURCE FILES
87
• Enter a break using the b command
• Fix the sources and reload them using make/0
• Exit the break, retry using the r command
Goals running during the reload keep running on the old deﬁnition, while new goals use the
reloaded deﬁnition, which is why the retry must be used after the reload. This implies that clauses
of predicates that are active during the reload cannot be reclaimed. Normally a small amount of
dead clauses should not be an issue during development.
Such clauses can be reclaimed with
garbage collect clauses/0.
garbage collect clauses
Clean up all dirty predicates, where dirty predicates are deﬁned to be predicates that have both
old and new deﬁnitions due to reloading a source ﬁle while the predicate was active. Of course,
predicates that are active using garbage collect clauses/0 cannot be reclaimed
and remain dirty. Predicates are, like atoms, shared resources and therefore all threads are
suspended during the execution of this predicate.
Compilation of mutually dependent code
Large programs are generally split into multiple ﬁles. If ﬁle A accesses predicates from ﬁle B which
accesses predicates from ﬁle A, we consider this a mutual or circular dependency. If traditional
load predicates (e.g., consult/1) are used to include ﬁle B from A and A from B, loading ei-
ther ﬁle results in a loop. This is because consult/1 is mapped to load files/2 using the
option if(true)(.) Such programs are typically loaded using a load ﬁle that consults all required
(non-module) ﬁles. If modules are used, the dependencies are made explicit using use module/1
statements. The use module/1 predicate, however, maps to load files/2 with the option
if(not loaded)(.) A use module/1 on an already loaded ﬁle merely makes the public predi-
cates of the used module available.
Summarizing, mutual dependency of source ﬁles is fully supported with no precautions when
using modules.
Modules can use each other in an arbitrary dependency graph.
When using
consult/1, predicate dependencies between loaded ﬁles can still be arbitrary, but the consult rela-
tions between ﬁles must be a proper tree.
Compilation with multiple threads
This section discusses compiling ﬁles for the ﬁrst time. For reloading, see section 4.3.2.
In older versions, compilation was thread-safe due to a global lock in load files/2 and the
code dealing with autoloading (see section 2.13). Besides unnecessary stalling when multiple threads
trap unrelated undeﬁned predicates, this easily leads to deadlocks, notably if threads are started from
an initialization/1 directive.6
Starting with version 5.11.27, the autoloader is no longer locked and multiple threads can compile
ﬁles concurrently. This requires special precautions only if multiple threads wish to load the same
ﬁle at the same time. Therefore, load files/2 checks automatically whether some other thread is
already loading the ﬁle. If not, it starts loading the ﬁle. If another thread is already loading the ﬁle, the
6Although such goals are started after loading the ﬁle in which they appear, the calling thread is still likely to hold the
‘load’ lock because it is compiling the ﬁle from which the ﬁle holding the directive is loaded.
SWI-Prolog 6.6 Reference Manual

88
CHAPTER 4. BUILT-IN PREDICATES
thread blocks until the other thread ﬁnishes loading the ﬁle. After waiting, and if the ﬁle is a module
ﬁle, it will make the public predicates available.
Note that this schema does not prevent deadlocks under all situations. Consider two mutually
dependent (see section 4.3.2) module ﬁles A and B, where thread 1 starts loading A and thread 2
starts loading B at the same time. Both threads will deadlock when trying to load the used module.
The current implementation does not detect such cases and the involved threads will freeze. This
problem can be avoided if a mutually dependent collection of ﬁles is always loaded from the same
start ﬁle.
Reloading running code
This section discusses not re-loading of code. Initial loading of code is discussed in section 4.3.2.
As of version 5.5.30, there is basic thread-safety for reloading source ﬁles while other threads
are executing code deﬁned in these source ﬁles. Reloading a ﬁle freezes all threads after mark-
ing the active predicates originating from the ﬁle being reloaded. The threads are resumed after
the ﬁle has been loaded. In addition, after completing loading the outermost ﬁle, the system runs
garbage collect clauses/0.
What does that mean? Unfortunately it does not mean we can ‘hot-swap’ modules. Consider the
case where thread A is executing the recursive predicate P. We ‘ﬁx’ P and reload. The already run-
ning goals for P continue to run the old deﬁnition, but new recursive calls will use the new deﬁnition!
Many similar cases can be constructed with dependent predicates.
It provides some basic security for reloading ﬁles in multithreaded applications during develop-
ment. In the above scenario the system does not crash uncontrolled, but behaves like any broken
program: it may return the wrong bindings, wrong truth value or raise an exception.
Future versions may have an ‘update now’ facility. Such a facility can be implemented on top
of the logical update view. It would allow threads to do a controlled update between processing
independent jobs.
4.3.3
Quick load ﬁles
SWI-Prolog supports compilation of individual or multiple Prolog source ﬁles into ‘Quick Load Files’.
A ‘Quick Load File’ (.qlf ﬁle) stores the contents of the ﬁle in a precompiled format.
These ﬁles load considerably faster than source ﬁles and are normally more compact. They are
machine-independent and may thus be loaded on any implementation of SWI-Prolog. Note, however,
that clauses are stored as virtual machine instructions. Changes to the compiler will generally make
old compiled ﬁles unusable.
Quick Load Files are created using qcompile/1. They are loaded using consult/1 or one
of the other ﬁle-loading predicates described in section 4.3. If consult/1 is given an explicit .pl
ﬁle, it will load the Prolog source. When given a .qlf ﬁle, it will load the ﬁle. When no extension is
speciﬁed, it will load the .qlf ﬁle when present and the .pl ﬁle otherwise.
qcompile(:File)
Takes a ﬁle speciﬁcation as consult/1, etc., and, in addition to the normal compilation,
creates a Quick Load File from File. The ﬁle extension of this ﬁle is .qlf. The basename of
the Quick Load File is the same as the input ﬁle.
If
the
ﬁle
contains
‘:- consult(+File)’,
‘:- [+File]’
or
‘:- load files(+File, [qcompile(part), ...])’
statements,
the
referred
SWI-Prolog 6.6 Reference Manual

4.4. EDITOR INTERFACE
89
ﬁles are compiled into the same .qlf ﬁle. Other directives will be stored in the .qlf ﬁle and
executed in the same fashion as when loading the .pl ﬁle.
For term expansion/2, the same rules as described in section 2.10 apply.
Conditional execution or optimisation may test the predicate compiling/0.
Source references (source file/2) in the Quick Load File refer to the Prolog source ﬁle
from which the compiled code originates.
qcompile(:File, +Options)
As qcompile/1, but processes additional options as deﬁned by load files/2.7
4.4
Editor Interface
SWI-Prolog offers an extensible interface which allows the user to edit objects of the program: predi-
cates, modules, ﬁles, etc. The editor interface is implemented by edit/1 and consists of three parts:
locating, selecting and starting the editor. Any of these parts may be customized. See section 4.4.1.
The built-in edit speciﬁcations for edit/1 (see prolog edit:locate/3) are described in the table
below:
Fully speciﬁed objects
⟨Module⟩:⟨Name⟩/⟨Arity⟩
Refers to a predicate
module(⟨Module⟩)
Refers to a module
ﬁle(⟨Path⟩)
Refers to a ﬁle
source ﬁle(⟨Path⟩)
Refers to a loaded source ﬁle
Ambiguous speciﬁcations
⟨Name⟩/⟨Arity⟩
Refers to this predicate in any module
⟨Name⟩
Refers to (1) the named predicate in any module with any
arity, (2) a (source) ﬁle, or (3) a module.
edit(+Speciﬁcation)
First, exploit prolog edit:locate/3 to translate Speciﬁcation into a list of Locations. If there
is more than one ‘hit’, the user is asked to select from the locations found.
Finally, pro-
log edit:edit source/1 is used to invoke the user’s preferred editor. Typically, edit/1 can be
handed the name of a predicate, module, basename of a ﬁle, XPCE class, XPCE method, etc.
edit
Edit the ‘default’ ﬁle using edit/1. The default ﬁle is the ﬁle loaded with the command line
option -s or, in Windows, the ﬁle loaded by double-clicking from the Windows shell.
4.4.1
Customizing the editor interface
The predicates described in this section are hooks that can be deﬁned to disambiguate speciﬁcations
given to edit/1, ﬁnd the related source, and open an editor at the given source location.
prolog edit:locate(+Spec, -FullSpec, -Location)
Where Spec is the speciﬁcation provided through edit/1. This multiﬁle predicate is used to
7BUG: Option processing is currently incomplete.
SWI-Prolog 6.6 Reference Manual

90
CHAPTER 4. BUILT-IN PREDICATES
enumerate locations where an object satisfying the given Spec can be found. FullSpec is uniﬁed
with the complete speciﬁcation for the object. This distinction is used to allow for ambiguous
speciﬁcations. For example, if Spec is an atom, which appears as the basename of a loaded ﬁle
and as the name of a predicate, FullSpec will be bound to file(Path) or Name/Arity.
Location is a list of attributes of the location.
Normally, this list will contain the term
file(File) and, if available, the term line(Line).
prolog edit:locate(+Spec, -Location)
Same as prolog edit:locate/3, but only deals with fully speciﬁed objects.
prolog edit:edit source(+Location)
Start editor on Location. See prolog edit:locate/3 for the format of a location term. This
multiﬁle predicate is normally not deﬁned.
If it succeeds, edit/1 assumes the editor is
started.
If it fails, edit/1 uses its internal defaults, which are deﬁned by the Prolog ﬂag editor
and/or the environment variable EDITOR.
The following rules apply.
If the Prolog ﬂag
editor is of the format $⟨name⟩, the editor is determined by the environment variable ⟨name⟩.
Else, if this ﬂag is pce emacs or built in and XPCE is loaded or can be loaded, the built-in
Emacs clone is used. Else, if the environment EDITOR is set, this editor is used. Finally, vi is
used as default on Unix systems and notepad on Windows.
See the default user preferences ﬁle dotfiles/dotplrc for examples.
prolog edit:edit command(+Editor, -Command)
Determines how Editor is to be invoked using shell/1. Editor is the determined editor
(see edit source/1), without the full path speciﬁcation, and without a possible (.exe)
extension. Command is an atom describing the command. The following %-sequences are
replaced in Command before the result is handed to shell/1:
%e
Replaced by the (OS) command name of the editor
%f
Replaced by the (OS) full path name of the ﬁle
%d
Replaced by the line number
If the editor can deal with starting at a speciﬁed line, two clauses should be provided. The ﬁrst
pattern invokes the editor with a line number, while the second is used if the line number is
unknown.
The default contains deﬁnitions for vi, emacs, emacsclient, vim, notepad∗and
wordpad∗. Starred editors do not provide starting at a given line number.
Please contribute your speciﬁcations to bugs@swi-prolog.org.
prolog edit:load
Normally an undeﬁned multiﬁle predicate. This predicate may be deﬁned to provide loading
hooks for user extensions to the edit module. For example, XPCE provides the code below to
load swi edit, containing deﬁnitions to locate classes and methods as well as to bind this
package to the PceEmacs built-in editor.
:- multifile prolog_edit:load/0.
SWI-Prolog 6.6 Reference Manual

4.5. LIST THE PROGRAM, PREDICATES OR CLAUSES
91
prolog_edit:load :-
ensure_loaded(library(swi_edit)).
4.5
List the program, predicates or clauses
listing(:Pred)
List predicates speciﬁed by Pred.
Pred may be a predicate name (atom), which lists all
predicates with this name, regardless of their arity.
It can also be a predicate indica-
tor (⟨name⟩/⟨arity⟩or ⟨name⟩//⟨arity⟩), possibly qualiﬁed with a module.
For example:
?- listing(lists:member/2)..
A listing is produced by enumerating the clauses of the predicate using clause/2 and printing
each clause using portray clause/1. This implies that the variable names are generated
(A, B, . . . ) and the layout is deﬁned by rules in portray clause/1.
listing
List all predicates from the calling module using listing/1. For example, ?- listing.
lists clauses in the default user module and ?- lists:listing. lists the clauses in the
module lists.
portray clause(+Clause)
Pretty print a clause. A clause should be speciﬁed as a term ‘⟨Head⟩:- ⟨Body⟩’. Facts are
represented as ‘⟨Head⟩:- true’ or simply ⟨Head⟩. Variables in the clause are written as A,
B, . . . . Singleton variables are written as _. See also portray clause/2.
portray clause(+Stream, +Clause)
Pretty print a clause to Stream. See portray clause/1 for details.
4.6
Verify Type of a Term
Type tests are semi-deterministic predicates that succeed if the argument satisﬁes the requested type.
Type-test predicates have no error condition and do not instantiate their argument. See also library
error.
var(@Term)
[ISO]
True if Term currently is a free variable.
nonvar(@Term)
[ISO]
True if Term currently is not a free variable.
integer(@Term)
[ISO]
True if Term is bound to an integer.
ﬂoat(@Term)
[ISO]
True if Term is bound to a ﬂoating point number.
rational(@Term)
True if Term is bound to a rational number. Rational numbers include integers.
SWI-Prolog 6.6 Reference Manual

92
CHAPTER 4. BUILT-IN PREDICATES
rational(@Term, -Numerator, -Denominator)
True if Term is a rational number with given Numerator and Denominator. The Numerator and
Denominator are in canonical form, which means Denominator is a positive integer and there
are no common divisors between Numerator and Denominator.
number(@Term)
[ISO]
True if Term is bound to an integer or ﬂoating point number.8
atom(@Term)
[ISO]
True if Term is bound to an atom.
blob(@Term, ?Type)
True if Term is a blob of type Type. See section 9.4.7.
string(@Term)
True if Term is bound to a string. Note that string here refers to the built-in atomic type string
as described in section 4.24, Text in double quotes such as "hello" creates a list of character
codes. We illustrate the issues in the example queries below.
?- write("hello").
[104, 101, 108, 108, 111]
true.
?- string("hello").
false.
?- is_list("hello").
true.
atomic(@Term)
[ISO]
True if Term is bound to an atom, string, integer or ﬂoating point number. Note that string
refers to the built-in type. See string/1. Strings in the classical Prolog sense are lists and
therefore compound.
compound(@Term)
[ISO]
True if Term is bound to a compound term. See also functor/3 and =../2.
callable(@Term)
[ISO]
True if Term is bound to an atom or a compound term. This was intended as a type-test for
arguments to call/1 and call/2.. Note that callable only tests the surface term. Terms
such as (22,true) are considered callable, but cause call/1 to raise a type error. Module-
qualiﬁcation of meta-argument (see meta predicate/1) using :/2 causes callable to
succeed on any meta-argument.9 Consider the program and query below:
8As rational numbers are not atomic in the current implementation and we do not want to break the rule that number/1
implies atomic/1, number/1 fails on rational numbers. This will change if rational numbers become atomic.
9We think that callable/1 should be deprecated and there should be two new predicates, one performing a test for
callable that is minimally module aware and possibly consistent with type-checking in call/1 and a second predicate that
tests for atom or compound.
SWI-Prolog 6.6 Reference Manual

4.7. COMPARISON AND UNIFICATION OF TERMS
93
:- meta_predicate p(0).
p(G) :- callable(G), call(G).
?- p(22).
ERROR: Type error: ‘callable’ expected, found ‘22’
ERROR: In:
ERROR:
[6] p(user:22)
ground(@Term)
[ISO]
True if Term holds no free variables.
cyclic term(@Term)
True if Term contains cycles, i.e. is an inﬁnite term. See also acyclic term/1 and sec-
tion 2.16.10
acyclic term(@Term)
[ISO]
True if Term does not contain cycles, i.e. can be processed recursively in ﬁnite time. See also
cyclic term/1 and section 2.16.
4.7
Comparison and Uniﬁcation of Terms
Although uniﬁcation is mostly done implicitly while matching the head of a predicate, it is also pro-
vided by the predicate =/2.
?Term1 = ?Term2
[ISO]
Unify Term1 with Term2. True if the uniﬁcation succeeds. For behaviour on cyclic terms see
the Prolog ﬂag occurs check. It acts as if deﬁned by the following fact:
=(Term, Term).
@Term1 \= @Term2
[ISO]
Equivalent to \+Term1 = Term2. See also dif/2.
4.7.1
Standard Order of Terms
Comparison and uniﬁcation of arbitrary terms. Terms are ordered in the so-called “standard order”.
This order is deﬁned as follows:
1. Variables < Numbers < Atoms < Strings < Compound Terms11
2. Variables are sorted by address. Attaching attributes (see section 6.1) does not affect the order-
ing.
10The predicates cyclic term/1 and acyclic term/1 are compatible with SICStus Prolog. Some Prolog systems
supporting cyclic terms use is cyclic/1.
11Strings might be considered atoms in future versions. See also section 4.24
SWI-Prolog 6.6 Reference Manual

94
CHAPTER 4. BUILT-IN PREDICATES
3. Atoms are compared alphabetically.
4. Strings are compared alphabetically.
5. Numbers are compared by value. Mixed integer/ﬂoat are compared as ﬂoats. If the comparison
is equal, the ﬂoat is considered the smaller value. If the Prolog ﬂag iso is deﬁned, all ﬂoating
point numbers precede all integers.
6. Compound terms are ﬁrst checked on their arity, then on their functor name (alphabetically) and
ﬁnally recursively on their arguments, leftmost argument ﬁrst.
@Term1 == @Term2
[ISO]
True if Term1 is equivalent to Term2. A variable is only identical to a sharing variable.
@Term1 \== @Term2
[ISO]
Equivalent to \+Term1 == Term2.
@Term1 @< @Term2
[ISO]
True if Term1 is before Term2 in the standard order of terms.
@Term1 @=< @Term2
[ISO]
True if both terms are equal (==/2) or Term1 is before Term2 in the standard order of terms.
@Term1 @> @Term2
[ISO]
True if Term1 is after Term2 in the standard order of terms.
@Term1 @>= @Term2
[ISO]
True if both terms are equal (==/2) or Term1 is after Term2 in the standard order of terms.
compare(?Order, @Term1, @Term2)
[ISO]
Determine or test the Order between two terms in the standard order of terms. Order is one of
<, > or =, with the obvious meaning.
4.7.2
Special uniﬁcation and comparison predicates
This section describes special purpose variations on Prolog uniﬁcation.
The predicate
unify with occurs check/2 provides sound uniﬁcation and is part of the ISO standard. The
predicate subsumes term/2 deﬁnes ‘one-sided uniﬁcation’ and is part of the ISO proposal estab-
lished in Edinburgh (2010). Finally, unifiable/3 is a ‘what-if’ version of uniﬁcation that is often
used as a building block in constraint reasoners.
unify with occurs check(+Term1, +Term2)
[ISO]
As =/2, but using sound uniﬁcation. That is, a variable only uniﬁes to a term if this term does
not contain the variable itself. To illustrate this, consider the two queries below.
1 ?- A = f(A).
A = f(A).
2 ?- unify_with_occurs_check(A, f(A)).
false.
SWI-Prolog 6.6 Reference Manual

4.7. COMPARISON AND UNIFICATION OF TERMS
95
The ﬁrst statement creates a cyclic term, also called a rational tree. The second executes log-
ically sound uniﬁcation and thus fails. Note that the behaviour of uniﬁcation through =/2 as
well as implicit uniﬁcation in the head can be changed using the Prolog ﬂag occurs check.
The SWI-Prolog implementation of unify with occurs check/2 is cycle-safe and only
guards against creating cycles, not against cycles that may already be present in one of the
arguments. This is illustrated in the following two queries:
?- X = f(X), Y = X, unify_with_occurs_check(X, Y).
X = Y, Y = f(Y).
?- X = f(X), Y = f(Y), unify_with_occurs_check(X, Y).
X = Y, Y = f(Y).
Some other Prolog systems interpret unify with occurs check/2 as if deﬁned by the
clause below, causing failure on the above two queries. Direct use of acyclic term/1 is
portable and more appropriate for such applications.
unify_with_occurs_check(X,X) :- acyclic_term(X).
+Term1 =@= +Term2
True if Term1 is a variant of (or structurally equivalent to) Term2. Testing for a variant is
weaker than equivalence (==/2), but stronger than uniﬁcation (=/2). Two terms A and B are
variants iff there exists a renaming of the variables in A that makes A equivalent (==) to B and
vice versa.12 Examples:
1
a =@= A
false
2
A =@= B
true
3
x(A,A) =@= x(B,C)
false
4
x(A,A) =@= x(B,B)
true
5
x(A,A) =@= x(A,B)
false
6
x(A,B) =@= x(C,D)
true
7
x(A,B) =@= x(B,A)
true
8
x(A,B) =@= x(C,A)
true
A term is always a variant of a copy of itself. Term copying takes place in, e.g., copy term/2,
findall/3 or proving a clause added with asserta/1. In the pure Prolog world (i.e.,
without attributed variables), =@=/2 behaves as if deﬁned below. With attributed variables,
variant of the attributes is tested rather than trying to satisfy the constraints.
A =@= B :-
copy_term(A, Ac),
copy_term(B, Bc),
numbervars(Ac, 0, N),
12Row 7 and 8 of this table may come as a surprise, but row 8 is satisﬁed by (left-to-right) A →C, B →A and (right-
to-left) C →A, A →B. If the same variable appears in different locations in the left and right term, the variant relation
can be broken by consistent binding of both terms. E.g., after binding the ﬁrst argument in row 8 to a value, both terms are
no longer variant.
SWI-Prolog 6.6 Reference Manual

96
CHAPTER 4. BUILT-IN PREDICATES
numbervars(Bc, 0, N),
Ac == Bc.
The SWI-Prolog implementation is cycle-safe and can deal with variables that are shared be-
tween the left and right argument. Its performance is comparable to ==/2, both on success and
(early) failure. 13
This predicate is known by the name variant/2 in some other Prolog systems. Be aware
of possible differences in semantics if the arguments contain attributed variables or share vari-
ables.14
+Term1 \=@= +Term2
Equivalent to ‘\+Term1 =@= Term2’. See =@=/2 for details.
subsumes term(@Generic, @Speciﬁc)
[ISO]
True if Generic can be made equivalent to Speciﬁc by only binding variables in Generic. The
current implementation performs the uniﬁcation and ensures that the variable set of Speciﬁc is
not changed by the uniﬁcation. On success, the bindings are undone.15 This predicate respects
constraints.
term subsumer(+Special1, +Special2, -General)
General is the most speciﬁc term that is a generalisation of Special1 and Special2. The imple-
mentation can handle cyclic terms.
uniﬁable(@X, @Y, -Uniﬁer)
If X and Y can unify, unify Uniﬁer with a list of Var = Value, representing the bindings required
to make X and Y equivalent.16 This predicate can handle cyclic terms. Attributed variables are
handled as normal variables. Associated hooks are not executed.
?=(@Term1, @Term2)
Succeeds if the syntactic equality of Term1 and Term2 can be decided safely, i.e. if the result of
Term1 == Term2 will not change due to further instantiation of either term. It behaves as if
deﬁned by ?=(X,Y) :- \+ unifiable(X,Y,[_|_]).
4.8
Control Predicates
The predicates of this section implement control structures. Normally the constructs in this section,
except for repeat/0, are translated by the compiler. Please note that complex goals passed as ar-
guments to meta-predicates such as findall/3 below cause the goal to be compiled to a temporary
location before execution. It is faster to deﬁne a sub-predicate (i.e. one character atoms/1 in
the example below) and make a call to this simple predicate.
13The current implementation is contributed by Kuniaki Mukai.
14In many systems variant is implemented using two calls to subsumes term/2.
15This predicate is often named subsumes chk/2 in older Prolog dialects. The current name was established in the ISO
WG17 meeting in Edinburgh (2010). The chk postﬁx was considered to refer to determinism as in e.g., memberchk/2.
16This predicate was introduced for the implementation of dif/2 and when/2 after discussion with Tom Schrijvers and
Bart Demoen. None of us is really happy with the name and therefore suggestions for a new name are welcome.
SWI-Prolog 6.6 Reference Manual

4.8. CONTROL PREDICATES
97
one_character_atoms(As) :-
findall(A, (current_atom(A), atom_length(A, 1)), As).
fail
[ISO]
Always fail. The predicate fail/0 is translated into a single virtual machine instruction.
false
[ISO]
Same as fail, but the name has a more declarative connotation.
true
[ISO]
Always succeed. The predicate true/0 is translated into a single virtual machine instruction.
repeat
[ISO]
Always succeed, provide an inﬁnite number of choice points.
!
[ISO]
Cut. Discard all choice points created since entering the predicate in which the cut appears.
In other words, commit to the clause in which the cut appears and discard choice points that
have been created by goals to the left of the cut in the current clause. Meta calling is opaque to
the cut. This implies that cuts that appear in a term that is subject to meta-calling (call/1)
only affect choice points created by the meta-called term. The following control structures are
transparent to the cut: ;/2, ->/2 and *->/2. Cuts appearing in the condition part of ->/2
and *->/2 are opaque to the cut. The table below explains the scope of the cut with examples.
Prunes here means “prunes X choice point created by X”.
t0 :- (a, !, b).
% prunes a/0 and t0/0
t1 :- (a, !, fail ; b).
% prunes a/0 and t1/0
t2 :- (a -> b, !
; c).
% prunes b/0 and t2/0
t3 :- call((a, !, fail ; b)).
% prunes a/0
t4 :- \+(a, !, fail).
% prunes a/0
:Goal1 , :Goal2
[ISO]
Conjunction. True if both ‘Goal1’ and ‘Goal2’ can be proved. It is deﬁned as follows (this
deﬁnition does not lead to a loop as the second comma is handled by the compiler):
Goal1, Goal2 :- Goal1, Goal2.
:Goal1 ; :Goal2
[ISO]
The ‘or’ predicate is deﬁned as:
Goal1 ; _Goal2 :- Goal1.
_Goal1 ; Goal2 :- Goal2.
:Goal1 | :Goal2
Equivalent to ;/2. Retained for compatibility only. New code should use ;/2.
SWI-Prolog 6.6 Reference Manual

98
CHAPTER 4. BUILT-IN PREDICATES
:Condition -> :Action
[ISO]
If-then and If-Then-Else. The ->/2 construct commits to the choices made at its left-hand
side, destroying choice points created inside the clause (by ;/2), or by goals called by this
clause. Unlike !/0, the choice point of the predicate as a whole (due to multiple clauses) is
not destroyed. The combination ;/2 and ->/2 acts as if deﬁned as:
If -> Then; _Else :- If, !, Then.
If -> _Then; Else :- !, Else.
If -> Then :- If, !, Then.
Please note that (If -> Then) acts as (If -> Then ; fail), making the construct fail if the condition
fails. This unusual semantics is part of the ISO and all de-facto Prolog standards.
:Condition *-> :Action ; :Else
This construct implements the so-called ‘soft-cut’. The control is deﬁned as follows: If Con-
dition succeeds at least once, the semantics is the same as (Condition, Action). If Condition
does not succeed, the semantics is that of (\+ Condition, Else). In other words, if Condition
succeeds at least once, simply behave as the conjunction of Condition and Action, otherwise
execute Else.
The construct A *-> B, i.e. without an Else branch, is translated as the normal conjunction A,
B.17
\+ :Goal
[ISO]
True if ‘Goal’ cannot be proven (mnemonic: + refers to provable and the backslash (\) is
normally used to indicate negation in Prolog).
4.9
Meta-Call Predicates
Meta-call predicates are used to call terms constructed at run time. The basic meta-call mechanism
offered by SWI-Prolog is to use variables as a subclause (which should of course be bound to a valid
goal at runtime). A meta-call is slower than a normal call as it involves actually searching the database
at runtime for the predicate, while for normal calls this search is done at compile time.
call(:Goal)
[ISO]
Invoke Goal as a goal. Note that clauses may have variables as subclauses, which is identical
to call/1.
call(:Goal, +ExtraArg1, . . .)
[ISO]
Append ExtraArg1, ExtraArg2, . . . to the argument list of Goal and call the result. For example,
call(plus(1), 2, X) will call plus(1, 2, X), binding X to 3.
The call/[2..] construct is handled by the compiler. The predicates call/[2-8] are deﬁned
as real (meta-)predicates and are available to inspection through current predicate/1,
predicate property/2, etc.18 Higher arities are handled by the compiler and runtime
system, but the predicates are not accessible for inspection.19
17BUG: The decompiler implemented by clause/2 returns this construct as a normal conjunction too.
18Arities 2..8 are demanded by ISO/IEC 13211-1:1995/Cor.2:2012.
19Future versions of the reﬂective predicate may fake the presence of call/9... Full logical behaviour, generating all
these pseudo predicates, is probably undesirable and will become impossible if max arity is removed.
SWI-Prolog 6.6 Reference Manual

4.9. META-CALL PREDICATES
99
apply(:Goal, +List)
Append the members of List to the arguments of Goal and call the resulting term. For example:
apply(plus(1), [2, X]) calls plus(1, 2, X). New code should use call/[2..] if
the length of List is ﬁxed.
not(:Goal)
True if Goal cannot be proven. Retained for compatibility only. New code should use \+/1.
once(:Goal)
[ISO]
Deﬁned as:
once(Goal) :-
Goal, !.
once/1 can in many cases be replaced with ->/2. The only difference is how the cut behaves
(see !/0). The following two clauses are identical:
1) a :- once((b, c)), d.
2) a :- b, c -> d.
ignore(:Goal)
Calls Goal as once/1, but succeeds, regardless of whether Goal succeeded or not. Deﬁned as:
ignore(Goal) :-
Goal, !.
ignore(_).
call with depth limit(:Goal, +Limit, -Result)
If
Goal
can
be
proven
without
recursion
deeper
than
Limit
levels,
call with depth limit/3 succeeds, binding Result to the deepest recursion level
used during the proof. Otherwise, Result is uniﬁed with depth limit exceeded if the
limit was exceeded during the proof, or the entire predicate fails if Goal fails without exceeding
Limit.
The depth limit is guarded by the internal machinery. This may differ from the depth computed
based on a theoretical model. For example, true/0 is translated into an inline virtual machine
instruction. Also, repeat/0 is not implemented as below, but as a non-deterministic foreign
predicate.
repeat.
repeat :-
repeat.
As a result, call with depth limit/3 may still loop inﬁnitely on programs that should
theoretically ﬁnish in ﬁnite time. This problem can be cured by using Prolog equivalents to
such built-in predicates.
This predicate may be used for theorem provers to realise techniques like iterative deepening.
It was implemented after discussion with Steve Moyle smoyle@ermine.ox.ac.uk.
SWI-Prolog 6.6 Reference Manual

100
CHAPTER 4. BUILT-IN PREDICATES
setup call cleanup(:Setup, :Goal, :Cleanup)
Calls (once(Setup), Goal). If Setup succeeds, Cleanup will be called exactly once after
Goal is ﬁnished: either on failure, deterministic success, commit, or an exception. The exe-
cution of Setup is protected from asynchronous interrupts like call with time limit/2
(package clib) or thread signal/2.
In most uses, Setup will perform temporary
side-effects required by Goal that are ﬁnally undone by Cleanup.
Success or failure of Cleanup is ignored, and choice points it created are destroyed (as
once/1). If Cleanup throws an exception, this is executed as normal.20
Typically, this predicate is used to cleanup permanent data storage required to execute Goal,
close ﬁle descriptors, etc. The example below provides a non-deterministic search for a term in
a ﬁle, closing the stream as needed.
term_in_file(Term, File) :-
setup_call_cleanup(open(File, read, In),
term_in_stream(Term, In),
close(In) ).
term_in_stream(Term, In) :-
repeat,
read(In, T),
(
T == end_of_file
->
!, fail
;
T = Term
).
Note that it is impossible to implement this predicate in Prolog.
The closest approxima-
tion would be to read all terms into a list, close the ﬁle and call member/2.
With-
out setup call cleanup/3 there is no way to gain control if the choice point left by
repeat/0 is removed by a cut or an exception.
setup call cleanup/3 can also be used to test determinism of a goal, providing a portable
alternative to deterministic/1:
?- setup_call_cleanup(true,(X=1;X=2), Det=yes).
X = 1 ;
X = 2,
Det = yes ;
This predicate is under consideration for inclusion into the ISO standard. For compatibility with
other Prolog implementations see call cleanup/2.
setup call catcher cleanup(:Setup, :Goal, +Catcher, :Cleanup)
Similar to setup call cleanup(Setup, Goal, Cleanup) with additional information on the
20BUG: During the execution of Cleanup, garbage collection and stack-shifts are disabled.
SWI-Prolog 6.6 Reference Manual

4.10. ISO COMPLIANT EXCEPTION HANDLING
101
reason for calling Cleanup. Prior to calling Cleanup, Catcher uniﬁes with the termination code
(see below). If this uniﬁcation fails, Cleanup is not called.
exit
Goal succeeded without leaving any choice points.
fail
Goal failed.
!
Goal succeeded with choice points and these are now discarded by the execution of a cut
(or other pruning of the search tree such as if-then-else).
exception(Exception)
Goal raised the given Exception.
external exception(Exception)
Goal succeeded with choice points and these are now discarded due to an exception. For
example:
?- setup_call_catcher_cleanup(true, (X=1;X=2),
Catcher, writeln(Catcher)),
throw(ball).
external_exception(ball)
ERROR: Unhandled exception: Unknown message: ball
call cleanup(:Goal, :Cleanup)
Same as setup call cleanup(true, Goal, Cleanup). This is provided for compatibility
with a number of other Prolog implementations only.
Do not use call cleanup/2 if
you perform side-effects prior to calling that will be undone by Cleanup.
Instead, use
setup call cleanup/3 with an appropriate ﬁrst argument to perform those side-effects.
call cleanup(:Goal, +Catcher, :Cleanup)
Same as setup call catcher cleanup(true, Goal, Catcher, Cleanup). The same warn-
ing as for call cleanup/2 applies.
4.10
ISO compliant Exception handling
SWI-Prolog deﬁnes the predicates catch/3 and throw/1 for ISO compliant raising and catching
of exceptions. In the current implementation (as of 4.0.6), most of the built-in predicates generate
exceptions, but some obscure predicates merely print a message, start the debugger and fail, which
was the normal behaviour before the introduction of exceptions.
catch(:Goal, +Catcher, :Recover)
[ISO]
Behaves as call/1 if no exception is raised when executing Goal. If an exception is raised
using throw/1 while Goal executes, and the Goal is the innermost goal for which Catcher
uniﬁes with the argument of throw/1, all choice points generated by Goal are cut, the system
backtracks to the start of catch/3 while preserving the thrown exception term, and Recover
is called as in call/1.
The overhead of calling a goal through catch/3 is comparable to call/1. Recovery from
an exception is much slower, especially if the exception term is large due to the copying thereof.
SWI-Prolog 6.6 Reference Manual

102
CHAPTER 4. BUILT-IN PREDICATES
throw(+Exception)
[ISO]
Raise an exception. The system looks for the innermost catch/3 ancestor for which Excep-
tion uniﬁes with the Catcher argument of the catch/3 call. See catch/3 for details.
ISO demands that throw/1 make a copy of Exception, walk up the stack to a catch/3 call,
backtrack and try to unify the copy of Exception with Catcher. SWI-Prolog delays making
a copy of Exception and backtracking until it actually ﬁnds a matching catch/3 goal. The
advantage is that we can start the debugger at the ﬁrst possible location while preserving the
entire exception context if there is no matching catch/3 goal. This approach can lead to
different behaviour if Goal and Catcher of catch/3 call shared variables. We assume this to
be highly unlikely and could not think of a scenario where this is useful.21
If an exception is raised in a call-back from C (see chapter 9) and not caught in the same
call-back, PL next solution() fails and the exception context can be retrieved using
PL exception().
4.10.1
Debugging and exceptions
Before the introduction of exceptions in SWI-Prolog a runtime error was handled by printing an error
message, after which the predicate failed. If the Prolog ﬂag debug on error was in effect (default),
the tracer was switched on. The combination of the error message and trace information is generally
sufﬁcient to locate the error.
With exception handling, things are different. A programmer may wish to trap an exception using
catch/3 to avoid it reaching the user. If the exception is not handled by user code, the interactive
top level will trap it to prevent termination.
If we do not take special precautions, the context information associated with an unexpected
exception (i.e., a programming error) is lost. Therefore, if an exception is raised which is not caught
using catch/3 and the top level is running, the error will be printed, and the system will enter trace
mode.
If the system is in a non-interactive call-back from foreign code and there is no catch/3 active
in the current context, it cannot determine whether or not the exception will be caught by the external
routine calling Prolog. It will then base its behaviour on the Prolog ﬂag debug on error:
• current prolog ﬂag(debug on error, false)
The exception does not trap the debugger and is returned to the foreign routine calling Prolog,
where it can be accessed using PL exception(). This is the default.
• current prolog ﬂag(debug on error, true)
If the exception is not caught by Prolog in the current context, it will trap the tracer to help
analyse the context of the error.
While looking for the context in which an exception takes place, it is advised to switch on debug
mode using the predicate debug/0. The hook prolog exception hook/4 can be used to add
more debugging facilities to exceptions. An example is the library http/http error, generating
a full stack trace on errors in the HTTP server library.
21I’d like to acknowledge Bart Demoen for his clariﬁcations on these matters.
SWI-Prolog 6.6 Reference Manual

4.10. ISO COMPLIANT EXCEPTION HANDLING
103
4.10.2
The exception term
Built-in predicates generate exceptions using a term error(Formal, Context). The ﬁrst argument
is the ‘formal’ description of the error, specifying the class and generic deﬁned context information.
When applicable, the ISO error term deﬁnition is used. The second part describes some additional
context to help the programmer while debugging. In its most generic form this is a term of the form
context(Name/Arity, Message), where Name/Arity describes the built-in predicate that raised the
error, and Message provides an additional description of the error. Any part of this structure may be a
variable if no information was present.
4.10.3
Printing messages
The predicate print message/2 is used to print a message term in a human-readable format.
The other predicates from this section allow the user to reﬁne and extend the message system. A
common usage of print message/2 is to print error messages from exceptions. The code below
prints errors encountered during the execution of Goal, without further propagating the exception and
without starting the debugger.
...,
catch(Goal, E,
( print_message(error, E),
fail
)),
...
Another common use is to deﬁne message hook/3 for printing messages that are normally silent,
suppressing messages, redirecting messages or make something happen in addition to printing the
message.
print message(+Kind, +Term)
The predicate print message/2 is used by the system and libraries to print messages.
Kind describes the nature of the message, while Term is a Prolog term that describes the
content.
Printing messages through this indirection instead of using format/3 to the
stream user error allows displaying the message appropriate to the application (termi-
nal, logﬁle, graphics), acting on messages based on their content instead of a string (see
message hook/3) and creating language speciﬁc versions of the messages.
See also
section 4.10.3. The following message kinds are known:
banner
The system banner message. Banner messages can be suppressed by setting the Prolog
ﬂag verbose to silent.
debug(Topic)
Message from library(debug). See debug/3.
error
The message indicates an erroneous situation. This kind is used to print uncaught excep-
tions of type error(Formal, Context). See section introduction (section 4.10.3).
SWI-Prolog 6.6 Reference Manual

104
CHAPTER 4. BUILT-IN PREDICATES
help
User requested help message, for example after entering ‘h’ or ‘?’ to a prompt.
information
Information that is requested by the user. An example is statistics/0.
informational
Typically messages of events are progres that are considered useful to a developer. Such
messages can be suppressed by setting the Prolog ﬂag verbose to silent.
silent
Message that is normally not printed. Applications may deﬁne message hook/3 to act
upon such messages.
trace
Messages from the (command line) tracer.
warning
The message indicates something dubious that is not considered fatal.
For example,
discontiguous predicates (see discontiguous/1).
The predicate print message/2 ﬁrst translates the Term into a list of ‘message lines’ (see
print message lines/3 for details). Next, it calls the hook message hook/3 to allow
the user to intercept the message. If message hook/3 fails it prints the message unless Kind
is silent.
The
print message/2
predicate
and
its
rules
are
in
the
ﬁle
⟨plhome⟩/boot/messages.pl, which may be inspected for more information on the
error messages and related error terms.
If you need to write messages from your own
predicates, it is recommended to reuse the existing message terms if applicable. If no existing
message term is applicable, invent a fairly unique term that represents the event and deﬁne a
rule for the multiﬁle predicate prolog:message//1. See section 4.10.3 for a deeper discussion
and examples.
See also message to string/2.
print message lines(+Stream, +Preﬁx, +Lines)
Print a message (see print message/2) that has been translated to a list of message ele-
ments. The elements of this list are:
⟨Format⟩-⟨Args⟩
Where Format is an atom and Args is a list of format arguments. Handed to format/3.
ﬂush
If this appears as the last element, Stream is ﬂushed (see flush output/1) and no
ﬁnal newline is generated. This is combined with a subsequent message that starts with
at same line to complete the line.
at same line
If this appears as ﬁrst element, no preﬁx is printed for the ﬁrst line and the line position is
not forced to 0 (see format/1, ˜N).
ansi(+Attributes, +Format, +Args)
This message may be intercepted by means of the hook prolog:message line element/2.
The library ansi term implements this hook to achieve coloured output. If it is not
intercepted it invokes format(Stream, Format, Args).
SWI-Prolog 6.6 Reference Manual

4.10. ISO COMPLIANT EXCEPTION HANDLING
105
nl
A new line is started. If the message is not complete, Preﬁx is printed before the remainder
of the message.
begin(Kind, Var)
end(Var)
The entire message is headed by begin(Kind, Var) and ended by end(Var). This feature
is used by, e.g., library ansi term to colour entire messages.
⟨Format⟩
Handed to format/3 as format(Stream, Format, []). Deprecated because it is am-
biguous if Format collides with one of the atomic commands.
See also print message/2 and message hook/3.
message hook(+Term, +Kind, +Lines)
Hook predicate that may be deﬁned in the module user to intercept messages from
print message/2. Term and Kind are the same as passed to print message/2. Lines
is a list of format statements as described with print message lines/3.
See also
message to string/2.
This predicate must be deﬁned dynamic and multiﬁle to allow other modules deﬁning clauses
for it too.
thread message hook(+Term, +Kind, +Lines)
As
message hook/3,
but
this
predicate
is
local
to
the
calling
thread
(see
thread local/1).
This hook is called before message hook/3.
The ‘pre-hook’ is
indented to catch messages they may be produced by calling some goal without affecting other
threads.
message property(+Kind, ?Property)
This hook can be used to deﬁne additional message kinds and the way they are displayed. The
following properties are deﬁned:
color(-Attributes)
Print message using ANSI terminal attributes. See ansi format/3 for details. Here is
an example, printing help messages in blue:
:- multifile user:message_property/2.
user:message_property(help, color([fg(blue)])).
preﬁx(-Preﬁx)
Preﬁx printed before each line. This argument is handed to format/3. The default is
’˜N’. For example, messages of kind warning use ’˜NWarning: ’.
location preﬁx(+Location, -FirstPreﬁx, -ContinuePreﬁx)
Used for printing messages that are related to a source location. Currently, Location is a
term File:Line. FirstPreﬁx is the preﬁx for the ﬁrst line and -ContinuePreﬁx is the preﬁx
for continuation lines. For example, the default for errors is
location_prefix(File:Line, ’˜NERROR: ˜w:˜d:’-[File,Line], ’˜N\t’)).
SWI-Prolog 6.6 Reference Manual

106
CHAPTER 4. BUILT-IN PREDICATES
stream(-Stream)
Stream to which to print the message. Default is user error.
wait(-Seconds)
Amount of time to wait after printing the message. Default is not to wait.
prolog:message line element(+Stream, +Term)
This
hook
is
called
to
print
the
individual
elements
of
a
message
from
print message lines/3.
This hook is used by e.g., library ansi term to colour
messages on ANSI-capable terminals.
message to string(+Term, -String)
Translates a message term into a string object (see section 4.24).
version
Write the SWI-Prolog banner message as well as additional messages registered using
version/1. This is the default initialization goal which can be modiﬁed using -g.
version(+Message)
Register additional messages to be printed by version/0. Each registered message is handed
to the message translation DCG and can thus be deﬁned using the hook prolog:message//1. Of
not deﬁned, it is simply printed.
Printing from libraries
Libraries should not use format/3 or other output predicates directly. Libraries that print informa-
tional output directly to the console are hard to use from code that depend on your textual output,
such as a CGI script. The predicates in section 4.10.3 deﬁne the API for dealing with messages. The
idea behind this is that a library that wants to provide information about its status, progress, events
or problems calls print message/2. The ﬁrst argument is the level. The supported levels are de-
scribed with print message/2. Libraries typically use informational and warning, while
libraries should use exceptions for errors (see throw/1, type error/2, etc.).
The second argument is an arbitrary Prolog term that carries the information of the message, but
not the precise text. The text is deﬁned by the grammar rule prolog:message//1. This distinction is
made to allow for translations and to allow hooks processing the information in a different way (e.g.,
to translate progress messages into a progress bar).
For example, suppose we have a library that must download data from the Internet (e.g., based on
http open/3). The library wants to print the progress after each downloaded ﬁle. The code below
is a good skeleton:
download_urls(List) :-
length(List, Total),
forall(nth1(I, List, URL),
(
download_url(URL),
print_message(informational,
download_url(URL, I, Total)))).
The programmer can now specify the default textual output using the rule below. Note that this
rule may be in the same ﬁle or anywhere else. Notably, the application may come with several rule
SWI-Prolog 6.6 Reference Manual

4.11. HANDLING SIGNALS
107
sets for different languages. This, and the user-hook example below are the reason to represent the
message as a compound term rather than a string. This is similar to using message numbers in non-
symbolic languages. The documentation of print message lines/3 describes the elements that
may appear in the output list.
:- multifile
prolog:message//1.
prolog:message(download_url(URL, I, Total)) -->
{ Perc is round(I*100/Total) },
[ ’Downloaded ˜w; ˜D from ˜D (˜d%)’-[URL, I, Total, Perc] ].
A user of the library may deﬁne rules for message hook/3. The rule below acts on the message
content. Other applications can act on the message level and, for example, popup a message box for
warnings and errors.
:- multifile user:message_hook/3.
message_hook(download_url(URL, I, Total), _Kind, _Lines) :-
<send this information to a GUI component>
In addition, using the command line option -q, the user can disable all informational messages.
4.11
Handling signals
As of version 3.1.0, SWI-Prolog is able to handle software interrupts (signals) in Prolog as well as in
foreign (C) code (see section 9.4.13).
Signals are used to handle internal errors (execution of a non-existing CPU instruction, arith-
metic domain errors, illegal memory access, resource overﬂow, etc.), as well as for dealing with
asynchronous interprocess communication.
Signals are deﬁned by the POSIX standard and part of all Unix machines. The MS-Windows
Win32 provides a subset of the signal handling routines, lacking the vital functionality to raise a signal
in another thread for achieving asynchronous interprocess (or interthread) communication (Unix kill()
function).
on signal(+Signal, -Old, :New)
Determines the reaction on Signal. Old is uniﬁed with the old behaviour, while the behaviour is
switched to New. As with similar environment control predicates, the current value is retrieved
using on signal(Signal, Current, Current).
The action description is an atom denoting the name of the predicate that will be called if
Signal arrives. on signal/3 is a meta-predicate, which implies that ⟨Module⟩:⟨Name⟩refers
to ⟨Name⟩/1 in module ⟨Module⟩. The handler is called with a single argument: the name of
the signal as an atom. The Prolog names for signals are explained below.
Two predicate names have special meaning. throw implies Prolog will map the signal onto
a Prolog exception as described in section 4.10. default resets the handler to the settings
active before SWI-Prolog manipulated the handler.
SWI-Prolog 6.6 Reference Manual

108
CHAPTER 4. BUILT-IN PREDICATES
Signals bound to a foreign function through PL signal() are reported using the term
$foreign function(Address).
After receiving a signal mapped to throw, the exception raised has the following structure:
error(signal(⟨SigName⟩, ⟨SigNum⟩), ⟨Context⟩)
The signal names are deﬁned by the POSIX standard as symbols of the form SIG⟨SIGNAME⟩.
The Prolog name for a signal is the lowercase version of ⟨SIGNAME⟩.
The predicate
current signal/3 may be used to map between names and signals.
Initially, some signals are mapped to throw, while all other signals are default. The fol-
lowing signals throw an exception: fpe, alrm, xcpu, xfsz and vtalrm.
current signal(?Name, ?Id, ?Handler)
Enumerate the currently deﬁned signal handling. Name is the signal name, Id is the numerical
identiﬁer and Handler is the currently deﬁned handler (see on signal/3).
4.11.1
Notes on signal handling
Before deciding to deal with signals in your application, please consider the following:
• Portability
On MS-Windows, the signal interface is severely limited. Different Unix brands support differ-
ent sets of signals, and the relation between signal name and number may vary. Currently, the
system only supports signals numbered 1 to 3222. Installing a signal outside the limited set of
supported signals in MS-Windows crashes the application.
• Safety
Immediately delivered signals (see below) are unsafe. This implies that foreign functions called
from a handler cannot safely use the SWI-Prolog API and cannot use C longjmp(). Handlers
deﬁned as throw are unsafe. Handlers deﬁned to call a predicate are safe. Note that the
predicate can call throw/1, but the delivery is delayed until Prolog is in a safe state.
The C-interface described in section 9.4.13 provides the option PL SIGSYNC to select either
safe synchronous or unsafe asynchronous delivery.
• Time of delivery
Using throw or a foreign handler, signals are delivered immediately (as deﬁned by the OS).
When using a Prolog predicate, delivery is delayed to a safe moment.
Blocking system
calls or foreign loops may cause long delays. Foreign code can improve on that by calling
PL handle signals().
Signals are blocked when the garbage collector is active.
4.12
DCG Grammar rules
Grammar rules form a comfortable interface to difference lists. They are designed both to support
writing parsers that build a parse tree from a list of characters or tokens and for generating a ﬂat list
from a term.
22TBD: the system should support the Unix realtime signals
SWI-Prolog 6.6 Reference Manual

4.12. DCG GRAMMAR RULES
109
Grammar rules look like ordinary clauses using -->/2 for separating the head and body rather
than :-/2. Expanding grammar rules is done by expand term/2, which adds two additional
arguments to each term for representing the difference list.
The body of a grammar rule can contain three types of terms. A callable term is interpreted as a
reference to a grammar rule. Code between {... } is interpreted as plain Prolog code, and ﬁnally, a
list is interpreted as a sequence of literals. The Prolog control-constructs (\+/1, ->/2, ;//2, ,/2
and !/0) can be used in grammar rules.
We illustrate the behaviour by deﬁning a rule set for parsing an integer.
integer(I) -->
digit(D0),
digits(D),
{ number_codes(I, [D0|D])
}.
digits([D|T]) -->
digit(D), !,
digits(T).
digits([]) -->
[].
digit(D) -->
[D],
{ code_type(D, digit)
}.
Grammar rule sets are called using the built-in predicates phrase/2 and phrase/3:
phrase(:DCGBody, ?List)
Equivalent to phrase(DCGBody, InputList, []).
phrase(:DCGBody, ?List, ?Rest)
True when DCGBody applies to the difference List/Rest. Although DCGBody is typically a
callable term that denotes a grammar rule, it can be any term that is valid as the body of a DCG
rule.
The example below calls the rule set ‘integer’ deﬁned in section 4.12, binding Rest to the re-
mainder of the input after matching the integer.
?- phrase(integer(X), "42 times", Rest).
X = 42
Rest = [32, 116, 105, 109, 101, 115]
The next example exploits a complete body.
digit_weight(W) -->
[D],
SWI-Prolog 6.6 Reference Manual

110
CHAPTER 4. BUILT-IN PREDICATES
{ code_type(D, digit(W)) }.
?- phrase(("Version ",
digit_weight(Major),".",digit_weight(Minor)),
"Version 3.4").
Major = 3,
Minor = 4.
See also portray text/1, which can be used to print lists of character codes as a string to the
top level and debugger to facilitate debugging DCGs that process character codes. The library
apply macros compiles phrase/3 if the argument is sufﬁciently instantiated, eliminating
the runtime overhead of translating DCGBody and meta-calling.
As stated above, grammar rules are a general interface to difference lists. To illustrate, we show a
DCG-based implementation of reverse/2:
reverse(List, Reversed) :-
phrase(reverse(List), Reversed).
reverse([])
--> [].
reverse([H|T]) --> reverse(T), [H].
4.13
Database
SWI-Prolog offers three different database mechanisms. The ﬁrst one is the common assert/retract
mechanism for manipulating the clause database. As facts and clauses asserted using assert/1
or one of its derivatives become part of the program, these predicates compile the term given to
them. retract/1 and retractall/1 have to unify a term and therefore have to decompile
the program. For these reasons the assert/retract mechanism is expensive. On the other hand, once
compiled, queries to the database are faster than querying the recorded database discussed below. See
also dynamic/1.
The second way of storing arbitrary terms in the database is using the ‘recorded database’. In this
database terms are associated with a key. A key can be an atom, small integer or term. In the last case
only the functor and arity determine the key. Each key has a chain of terms associated with it. New
terms can be added either at the head or at the tail of this chain.
Following the Edinburgh tradition, SWI-Prolog provides database keys to clauses and records in
the recorded database. As of 5.9.10, these keys are represented by non-textual atoms (‘blobs’, see
section 9.4.7), which makes accessing the database through references safe.
The third mechanism is a special-purpose one. It associates an integer or atom with a key, which
is an atom, integer or term. Each key can only have one atom or integer associated with it.
abolish(:PredicateIndicator)
[ISO]
Removes all clauses of a predicate with functor Functor and arity Arity from the database. All
predicate attributes (dynamic, multiﬁle, index, etc.) are reset to their defaults. Abolishing an
SWI-Prolog 6.6 Reference Manual

4.13. DATABASE
111
imported predicate only removes the import link; the predicate will keep its old deﬁnition in its
deﬁnition module.
According to the ISO standard, abolish/1 can only be applied to dynamic procedures.
This is odd, as for dealing with dynamic procedures there is already retract/1 and
retractall/1. The abolish/1 predicate was introduced in DEC-10 Prolog precisely
for dealing with static procedures. In SWI-Prolog, abolish/1 works on static procedures,
unless the Prolog ﬂag iso is set to true.
It is advised to use retractall/1 for erasing all clauses of a dynamic predicate.
abolish(+Name, +Arity)
Same as abolish(Name/Arity).
The predicate abolish/2 conforms to the Edinburgh
standard, while abolish/1 is ISO compliant.
copy predicate clauses(:From, :To)
Copy all clauses of predicate From to To. The predicate To must be dynamic or undeﬁned. If
To is undeﬁned, it is created as a dynamic predicate holding a copy of the clauses of From. If
To is a dynamic predicate, the clauses of From are added (as in assertz/1) to the clauses of
To. To and From must have the same arity. Acts as if deﬁned by the program below, but at a
much better performance by avoiding decompilation and compilation.
copy_predicate_clauses(From, To) :-
head(From, MF:FromHead),
head(To, MT:ToHead),
FromHead =.. [_|Args],
ToHead =.. [_|Args],
forall(clause(MF:FromHead, Body),
assertz(MT:ToHead, Body)).
head(From, M:Head) :-
strip_module(From, M, Name/Arity),
functor(Head, Name, Arity).
redeﬁne system predicate(+Head)
This directive may be used both in module user and in normal modules to redeﬁne any
system predicate. If the system deﬁnition is redeﬁned in module user, the new deﬁnition is
the default deﬁnition for all sub-modules. Otherwise the redeﬁnition is local to the module.
The system deﬁnition remains in the module system.
Redeﬁning system predicate facilitates the deﬁnition of compatibility packages. Use in other
contexts is discouraged.
retract(+Term)
[ISO]
When Term is an atom or a term it is uniﬁed with the ﬁrst unifying fact or clause in the database.
The fact or clause is removed from the database.
retractall(+Head)
[ISO]
All facts or clauses in the database for which the head uniﬁes with Head are removed. If Head
SWI-Prolog 6.6 Reference Manual

112
CHAPTER 4. BUILT-IN PREDICATES
refers to a predicate that is not deﬁned, it is implicitly created as a dynamic predicate. See also
dynamic/1.23
asserta(+Term)
[ISO]
Assert a fact or clause in the database. Term is asserted as the ﬁrst fact or clause of the corre-
sponding predicate. Equivalent to assert/1, but Term is asserted as ﬁrst clause or fact of the
predicate.
assertz(+Term)
[ISO]
Equivalent to asserta/1, but Term is asserted as the last clause or fact of the predicate.
assert(+Term)
Equivalent to assertz/1. Deprecated: new code should use assertz/1.
asserta(+Term, -Reference)
Asserts a clause as asserta/1 and uniﬁes Reference with a handle to this clause. The handle
can be used to access this speciﬁc clause using clause/3 and erase/1.
assertz(+Term, -Reference)
Equivalent to asserta/1, asserting the new clause as the last clause of the predicate.
assert(+Term, -Reference)
Equivalent to assertz/2. Deprecated: new code should use assertz/2.
recorda(+Key, +Term, -Reference)
Assert Term in the recorded database under key Key.
Key is a small integer (range
min tagged integer . . . max tagged integer, atom or compound term. If the key is
a compound term, only the name and arity deﬁne the key. Reference is uniﬁed with an opaque
handle to the record (see erase/1).
recorda(+Key, +Term)
Equivalent to recorda(Key, Term,
).
recordz(+Key, +Term, -Reference)
Equivalent to recorda/3, but puts the Term at the tail of the terms recorded under Key.
recordz(+Key, +Term)
Equivalent to recordz(Key, Term,
).
recorded(?Key, ?Value, ?Reference)
True if Value is recorded under Key and has the given database Reference. If Reference is given,
this predicate is semi-deterministic. Otherwise, it must be considered non-deterministic. If
neither Reference nor Key is given, the triples are generated as in the code snippet below.24 See
also current key/1.
current_key(Key),
recorded(Key, Value, Reference)
23The ISO standard only allows using dynamic/1 as a directive.
24Note that, without a given Key, some implementations return triples in the order deﬁned by recorda/2 and
recordz/2.
SWI-Prolog 6.6 Reference Manual

4.13. DATABASE
113
recorded(+Key, -Value)
Equivalent to recorded(Key, Value,
).
erase(+Reference)
Erase a record or clause from the database.
Reference is a db-reference returned by
recorda/3, recordz/3 or recorded/3, clause/3, assert/2, asserta/2 or
assertz/2. Fail silently if the referenced object no longer exists.
instance(+Reference, -Term)
Unify Term with the referenced clause or database record. Unit clauses are represented as Head
:- true.
ﬂag(+Key, -Old, +New)
Key is an atom, integer or term. As with the recorded database, if Key is a term, only the name
and arity are used to locate the ﬂag. Unify Old with the old value associated with Key. If the
key is used for the ﬁrst time Old is uniﬁed with the integer 0. Then store the value of New,
which should be an integer, ﬂoat, atom or arithmetic expression, under Key. flag/3 is a
fast mechanism for storing simple facts in the database. The ﬂag database is shared between
threads and updates are atomic, making it suitable for generating unique integer counters.25
4.13.1
Update view
Traditionally, Prolog systems used the immediate update view: new clauses became visible to predi-
cates backtracking over dynamic predicates immediately, and retracted clauses became invisible im-
mediately.
Starting with SWI-Prolog 3.3.0 we adhere to the logical update view, where backtrackable pred-
icates that enter the deﬁnition of a predicate will not see any changes (either caused by assert/1
or retract/1) to the predicate. This view is the ISO standard, the most commonly used and the
most ‘safe’.26 Logical updates are realised by keeping reference counts on predicates and generation
information on clauses. Each change to the database causes an increment of the generation of the
database. Each goal is tagged with the generation in which it was started. Each clause is ﬂagged with
the generation it was created in as well as the generation it was erased from. Only clauses with a
‘created’ . . . ‘erased’ interval that encloses the generation of the current goal are considered visible.
4.13.2
Indexing databases
The indexing capabilities of SWI-Prolog are described in section 2.17. Summarizing, SWI-Prolog
creates indexes for any applicable argument, but only on one argument, and does not index on argu-
ments of compound terms. The predicates below provide building blocks to circumvent the limitations
of the current indexing system.
Programs that aim at portability should consider using term hash/2 and term hash/4 to
design their database such that indexing on constant or functor (name/arity reference) on the ﬁrst
argument is sufﬁcient.
25The flag/3 predicate is not portable. Non-backtrackable global variables (nb setval/2) and non-backtrackable
assignment (nb setarg/3) are more widely recognised special-purpose alternatives for non-backtrackable and/or global
states.
26For example, using the immediate update view, no call to a dynamic predicate is deterministic.
SWI-Prolog 6.6 Reference Manual

114
CHAPTER 4. BUILT-IN PREDICATES
term hash(+Term, -HashKey)
[det]
If Term is a ground term (see ground/1), HashKey is uniﬁed with a positive integer value that
may be used as a hash key to the value. If Term is not ground, the predicate leaves HashKey an
unbound variable. Hash keys are in the range 0 . . . 16, 777, 215, the maximal integer that can
be stored efﬁciently on both 32 and 64 bit platforms.
This predicate may be used to build hash tables as well as to exploit argument indexing to ﬁnd
complex terms more quickly.
The hash key does not rely on temporary information like addresses of atoms and may be as-
sumed constant over different invocations and versions of SWI-Prolog.27 Hashes differ between
big and little endian machines. The term hash/2 predicate is cycle-safe.28
term hash(+Term, +Depth, +Range, -HashKey)
[det]
As term hash/2, but only considers Term to the speciﬁed Depth. The top-level term has
depth 1, its arguments have depth 2, etc. That is, Depth = 0 hashes nothing; Depth = 1 hashes
atomic values or the functor and arity of a compound term, not its arguments; Depth = 2 also
indexes the immediate arguments, etc.
HashKey is in the range [0 . . . Range −1]. Range must be in the range [1 . . . 2147483647]
variant sha1(+Term, -SHA1)
[det]
Compute a SHA1-hash from Term. The hash is represented as a 40-byte hexadecimal atom.
Unlike term hash/2 and friends, this predicate produces a hash key for non-ground terms.
The hash is invariant over variable-renaming (see =@=/2) and constants over different
invocations of Prolog.29
This predicate raises an exception when trying to compute the hash on a cyclic term or at-
tributed term. Attributed terms are not handled because subsumes chk/2 is not considered
well deﬁned for attributed terms. Cyclic terms are not supported because this would require es-
tablishing a canonical cycle. That is, given A=[a—A] and B=[a,a—B], A and B should produce
the same hash. This is not (yet) implemented.
This hash was developed for lookup of solutions to a goal stored in a table. By using a cryp-
tographic hash, heuristic algorithms can often ignore the possibility of hash collisions and thus
avoid storing the goal term itself as well as testing using =@=/2.
4.14
Declaring predicate properties
This section describes directives which manipulate attributes of predicate deﬁnitions. The functors
dynamic/1, multifile/1, discontiguous/1 and public/1 are operators of priority 1150
(see op/3), which implies that the list of predicates they involve can just be a comma-separated list:
:- dynamic
foo/0,
baz/2.
27Last change: version 5.10.4
28BUG: All arguments that (indirectly) lead to a cycle have the same hash key.
29BUG: The hash depends on word order (big/little-endian) and the wordsize (32/64 bits).
SWI-Prolog 6.6 Reference Manual

4.15. EXAMINING THE PROGRAM
115
In SWI-Prolog all these directives are just predicates. This implies they can also be called by a pro-
gram. Do not rely on this feature if you want to maintain portability to other Prolog implementations.
dynamic :PredicateIndicator, . . .
[ISO]
Informs the interpreter that the deﬁnition of the predicate(s) may change during execution
(using assert/1 and/or retract/1). In the multithreaded version, the clauses of dynamic
predicates are shared between the threads.
The directive thread local/1 provides an
alternative where each thread has its own clause list for the predicate. Dynamic predicates can
be turned into static ones using compile predicates/1.
compile predicates(:ListOfPredicateIndicators)
Compile a list of speciﬁed dynamic predicates (see dynamic/1 and assert/1) into normal
static predicates. This call tells the Prolog environment the deﬁnition will not change anymore
and further calls to assert/1 or retract/1 on the named predicates raise a permission
error. This predicate is designed to deal with parts of the program that are generated at runtime
but do not change during the remainder of the program execution.30
multiﬁle :PredicateIndicator, . . .
[ISO]
Informs the system that the speciﬁed predicate(s) may be deﬁned over more than one ﬁle. This
stops consult/1 from redeﬁning a predicate when a new deﬁnition is found.
discontiguous :PredicateIndicator, . . .
[ISO]
Informs the system that the clauses of the speciﬁed predicate(s) might not be together in the
source ﬁle. See also style check/1.
public :PredicateIndicator, . . .
Instructs the cross-referencer that the predicate can be called. It has no semantics.31 The public
declaration can be queried using predicate property/2. The public/1 directive does
not export the predicate (see module/1 and export/1). The public directive is used for
(1) direct calls into the module from, e.g., foreign code, (2) direct calls into the module from
other modules, or (3) ﬂag a predicate as being called if the call is generated by meta-calling
constructs that are not analysed by the cross-referencer.
4.15
Examining the program
current atom(-Atom)
Successively uniﬁes Atom with all atoms known to the system. Note that current atom/1
always succeeds if Atom is instantiated to an atom.
current blob(?Blob, ?Type)
Examine the type or enumerate blobs of the given Type. Typed blobs are supported through
the foreign language interface for storing arbitrary BLOBs (Binary Large Object) or handles to
external entities. See section 9.4.7 for details.
30The speciﬁcation of this predicate is from Richard O’Keefe. The implementation is allowed to optimise the predicate.
This is not yet implemented. In multithreaded Prolog, however, static code runs faster as it does not require synchronisation.
This is particularly true on SMP hardware.
31This declaration is compatible with SICStus. In YAP, public/1 instructs the compiler to keep the source. As the
source is always available in SWI-Prolog, our current interpretation also enhances the compatibility with YAP.
SWI-Prolog 6.6 Reference Manual

116
CHAPTER 4. BUILT-IN PREDICATES
current functor(?Name, ?Arity)
Successively uniﬁes Name with the name and Arity with the arity of functors known to the
system.
current ﬂag(-FlagKey)
Successively uniﬁes FlagKey with all keys used for ﬂags (see flag/3).
current key(-Key)
Successively uniﬁes Key with all keys used for records (see recorda/3, etc.).
current predicate(:PredicateIndicator)
[ISO]
True if PredicateIndicator is a currently deﬁned predicate. A predicate is considered deﬁned
if it exists in the speciﬁed module, is imported into the module or is deﬁned in one of the
modules from which the predicate will be imported if it is called (see section 5.9). Note that
current predicate/1 does not succeed for predicates that can be autoloaded. See also
current predicate/2 and predicate property/2.
If PredicateIndicator is not fully speciﬁed, the predicate only generates values that are deﬁned
in or already imported into the target module. Generating all callable predicates therefore re-
quires enumerating modules using current module/1. Generating predicates callable in
a given module requires enumerating the import modules using import module/2 and the
autoloadable predicates using the predicate property/2 autoload.
current predicate(?Name, :Head)
Classical pre-ISO implementation of current predicate/1, where the predicate is repre-
sented by the head term. The advantage is that this can be used for checking the existence of a
predicate before calling it without the need for functor/3:
call_if_exists(G) :-
current_predicate(_, G),
call(G).
Because of this intended usage, current predicate/2 also succeeds if the predicate can
be autoloaded. Unfortunately, checking the autoloader makes this predicate relatively slow, in
particular because a failed lookup of the autoloader will cause the autoloader to verify that its
index is up-to-date.
predicate property(:Head, ?Property)
True when Head refers to a predicate that has property Property. With sufﬁciently instan-
tiated Head, predicate property/2 tries to resolve the predicate the same way
as calling it would do: if the predicate is not deﬁned it scans the default modules (see
default module/2) and ﬁnally tries the autoloader.
Unlike calling, failure to ﬁnd the
target predicate causes predicate property/2 to fail silently. If Head is not sufﬁciently
bound, only currently locally deﬁned and already imported predicates are enumerated.
See current predicate/1 for enumerating all predicates. A common issue concerns
generating all built-in predicates. This can be achieved using the code below:
generate_built_in(Name/Arity) :-
predicate_property(system:Head, built_in),
SWI-Prolog 6.6 Reference Manual

4.15. EXAMINING THE PROGRAM
117
functor(Head, Name, Arity),
\+ sub_atom(Name, 0, _, _, $).
% discard reserved names
Property is one of:
autoload(File)
True if the predicate can be autoloaded from the ﬁle File. Like undefined, this property
is not generated.
built in
True if the predicate is locked as a built-in predicate. This implies it cannot be redeﬁned
in its deﬁnition module and it can normally not be seen in the tracer.
dynamic
True if assert/1 and retract/1 may be used to modify the predicate. This property
is set using dynamic/1.
exported
True if the predicate is in the public list of the context module.
imported from(Module)
Is true if the predicate is imported into the context module from module Module.
ﬁle(FileName)
Unify FileName with the name of the source ﬁle in which the predicate is deﬁned. See
also source file/2 and the property line count.
Note that this reports the
ﬁle of the ﬁrst clause of a predicate. A more robust interface can be achieved using
nth clause/3 and clause property/2.
foreign
True if the predicate is deﬁned in the C language.
indexed(Indexes)
Indexes32 is a list of additional (hash) indexes on the predicate. Each element of the list
is a term ArgSpec-Index. Currently ArgSpec is an integer denoting the argument position
and Index is a term hash(Buckets, Speedup, IsList). Here Buckets is the number of
buckets in the hash and Speedup is the expected speedup relative to trying all clauses
linearly. IsList indicates that a list is created for all clauses with the same key. This is
currently not used.
interpreted
True if the predicate is deﬁned in Prolog. We return true on this because, although the
code is actually compiled, it is completely transparent, just like interpreted code.
iso
True if the predicate is covered by the ISO standard (ISO/IEC 13211-1).
line count(LineNumber)
Unify LineNumber with the line number of the ﬁrst clause of the predicate. Fails if the
predicate is not associated with a ﬁle. See also source file/2. See also the file
property above, notably the reference to clause property/2.
32This predicate property should be used for analysis and statistics only. The exact representation of Indexes may change
between versions.
SWI-Prolog 6.6 Reference Manual

118
CHAPTER 4. BUILT-IN PREDICATES
multiﬁle
True if there may be multiple (or no) ﬁles providing clauses for the predicate.
This
property is set using multifile/1.
meta predicate(Head)
If the predicate is declared as a meta-predicate using meta predicate/1, unify Head
with the head-pattern. The head-pattern is a compound term with the same name and
arity as the predicate where each argument of the term is a meta-predicate speciﬁer. See
meta predicate/1 for details.
nodebug
Details of the predicate are not shown by the debugger. This is the default for built-
in predicates.
User predicates can be compiled this way using the Prolog ﬂag
generate debug info.
notrace
Do not show ports of this predicate in the debugger.
number of clauses(ClauseCount)
Unify ClauseCount to the number of clauses associated with the predicate. Fails for
foreign predicates.
number of rules(RuleCount)
Unify RuleCount to the number of clauses associated with the predicate. A rule is deﬁned
as a clauses that has a body that is not just true (i.e., a fact).
Fails for foreign
predicates.
This property is used to avoid analysing predicates with only facts in
prolog codewalk.
public
Predicate is declared public using public/1.
Note that without further deﬁnition,
public predicates are considered undeﬁned and this property is not reported.
quasi quotation syntax(T)
he predicate (with arity 4) is declared to provide quasi quotation syntax with
quasi quotation syntax/1.
thread local
If true (only possible on the multithreaded version) each thread has its own clauses for
the predicate. This property is set using thread local/1.
transparent
True if the predicate is declared transparent using the module transparent/1
or
meta predicate/1
declaration.
In
the
latter
case
the
property
meta predicate(Head) is also provided. See chapter 5 for details.
undeﬁned
True if a procedure deﬁnition block for the predicate exists, but there are no clauses for
it and it is not declared dynamic or multiﬁle. This is true if the predicate occurs in the
body of a loaded predicate, an attempt to call it has been made via one of the meta-call
predicates, or the predicate had a deﬁnition in the past. See the library package check
for example usage.
visible
True when predicate can be called without raising a predicate existence error. This means
that the predicate is (1) deﬁned, (2) can be inherited from one of the default modules (see
SWI-Prolog 6.6 Reference Manual

4.15. EXAMINING THE PROGRAM
119
default module/2) or (3) can be autoloaded. The behaviour is logically consistent
iff the property visible is provided explicitly. If the property is left unbound, only
deﬁned predicates are enumerated.
volatile
If true, the clauses are not saved into a saved state by qsave program/[1,2]. This
property is set using volatile/1.
dwim predicate(+Term, -Dwim)
‘Do What I Mean’ (‘dwim’) support predicate. Term is a term, whose name and arity are used
as a predicate speciﬁcation. Dwim is instantiated with the most general term built from Name
and the arity of a deﬁned predicate that matches the predicate speciﬁed by Term in the ‘Do
What I Mean’ sense. See dwim match/2 for ‘Do What I Mean’ string matching. Internal
system predicates are not generated, unless the access level is system (see access level).
Backtracking provides all alternative matches.
clause(:Head, ?Body)
[ISO]
True if Head can be uniﬁed with a clause head and Body with the corresponding clause body.
Gives alternative clauses on backtracking. For facts, Body is uniﬁed with the atom true.
clause(:Head, ?Body, ?Reference)
Equivalent to clause/2, but uniﬁes Reference with a unique reference to the clause (see also
assert/2, erase/1). If Reference is instantiated to a reference the clause’s head and body
will be uniﬁed with Head and Body.
nth clause(?Pred, ?Index, ?Reference)
Provides access to the clauses of a predicate using their index number. Counting starts at 1.
If Reference is speciﬁed it uniﬁes Pred with the most general term with the same name/arity
as the predicate and Index with the index number of the clause. Otherwise the name and arity
of Pred are used to determine the predicate. If Index is provided, Reference will be uniﬁed
with the clause reference. If Index is unbound, backtracking will yield both the indexes and
the references of all clauses of the predicate. The following example ﬁnds the 2nd clause of
append/3:
?- use_module(library(lists)).
...
?- nth_clause(append(_,_,_), 2, Ref), clause(Head, Body, Ref).
Ref = <clause>(0x994290),
Head = lists:append([_G23|_G24], _G21, [_G23|_G27]),
Body = append(_G24, _G21, _G27).
clause property(+ClauseRef, -Property)
Queries properties of a clause. ClauseRef is a reference to a clause as produced by clause/3,
nth clause/3 or prolog frame attribute/3.
Unlike most other predicates that
access clause references, clause property/2 may be used to get information about erased
clauses that have not yet been reclaimed. Property is one of the following:
ﬁle(FileName)
Unify FileName with the name of the ﬁle in which the clause textually appears. Fails if
SWI-Prolog 6.6 Reference Manual

120
CHAPTER 4. BUILT-IN PREDICATES
the clause is created by loading a ﬁle (e.g., clauses added using assertz/1). See also
source.
line count(LineNumber)
Unify LineNumber with the line number of the clause. Fails if the clause is not associated
to a ﬁle.
source(FileName)
Unify FileName with the name of the source ﬁle that created the clause. This is the same
as the file property, unless the ﬁle is loaded from a ﬁle that is textually included into
source using include/1. In this scenario, file is the included ﬁle, while the source
property refers to the main ﬁle.
fact
True if the clause has no body.
erased
True if the clause has been erased, but not yet reclaimed because it is referenced.
predicate(PredicateIndicator)
PredicateIndicator denotes the predicate to which this clause belongs. This is needed to
obtain information on erased clauses because the usual way to obtain this information
using clause/3 fails for erased clauses.
4.16
Input and output
SWI-Prolog provides two different packages for input and output. The native I/O system is based
on the ISO standard predicates open/3, close/1 and friends.33 Being more widely portable and
equipped with a clearer and more robust speciﬁcation, new code is encouraged to use these predicates
for manipulation of I/O streams.
Section 4.16.3 describes tell/1, see/1 and friends, providing I/O in the spirit of the traditional
Edinburgh standard. These predicates are layered on top of the ISO predicates. Both packages are
fully integrated; the user may switch freely between them.
4.16.1
Predeﬁned stream aliases
Each
thread
has
ﬁve
stream
aliases:
user input,
user output,
user error,
current input, and current output.
Newly created threads inherit these stream aliases
from theyr parent.
The user input, user output and user error aliases of the main
thread are initially bound to the standard operating system I/O streams (stdin, stdout and stderr,
normally bound to the POSIX ﬁle handles 0, 1 and 2). These aliases may be re-bound, for ex-
ample if standard I/O refers to a window such as in the swipl-win.exe GUI executable for
Windows. They can be re-bound by the user using set prolog IO/3 and set stream/2 by
setting the alias of a stream (e.g, set stream(S, alias(user output))). An example of
rebinding can be found in library prolog server, providing a telnet service.
The aliases
current input and current output deﬁne the source and destination for predicates that do
not take a stream argument (e.g., read/1, write/1, get code/1, ...). Initially, these are bound
to the same stream as user input and user error. They are re-bound by see/1, tell/1,
set input/1 and set output/1. The current output stream is also temporary re-bound
33Actually based on Quintus Prolog, providing this interface before the ISO standard existed.
SWI-Prolog 6.6 Reference Manual

4.16. INPUT AND OUTPUT
121
by with output to/2 or format/3 using e.g., format(atom(A), .... Note that code
which explicitly writes to the streams user output and user error will not be redirected by
with output to/2.
Compatibility
Note that the ISO standard only deﬁnes the user * streams. The ‘current’ streams
can be accessed using current input/1 and current output/1. For example, an ISO com-
patible implementation of write/1 is
write(Term) :- current_output(Out), write_term(Out, Term).
while SWI-Prolog additionally allows for
write(Term) :- write(current_output, Term).
4.16.2
ISO Input and Output Streams
The predicates described in this section provide ISO compliant I/O, where streams are explicitly cre-
ated using the predicate open/3. The resulting stream identiﬁer is then passed as a parameter to the
reading and writing predicates to specify the source or destination of the data.
This schema is not vulnerable to ﬁlename and stream ambiguities as well as changes to the work-
ing directory. On the other hand, using the notion of current-I/O simpliﬁes reusability of code without
the need to pass arguments around. E.g., see with output to/2.
SWI-Prolog streams are, compatible with the ISO standard, either input or output streams. To
accommodate portability to other systems, a pair of streams can be packed into a stream-pair. See
stream pair/3 for details.
SWI-Prolog stream handles are unique symbols that have no syntactical representation. They are
written as \bnfmeta{stream}(hex-number), which is not valid input for read/1. They are
realised using a blob of type stream (see blob/2 and section 9.4.7).
open(+SrcDest, +Mode, -Stream, +Options)
[ISO]
ISO compliant predicate to open a stream. SrcDest is either an atom specifying a ﬁle, or a
term ‘pipe(Command)’, like see/1 and tell/1. Mode is one of read, write, append
or update. Mode append opens the ﬁle for writing, positioning the ﬁle pointer at the end.
Mode update opens the ﬁle for writing, positioning the ﬁle pointer at the beginning of the ﬁle
without truncating the ﬁle. Stream is either a variable, in which case it is bound to an integer
identifying the stream, or an atom, in which case this atom will be the stream identiﬁer.34 The
Options list can contain the following options:
type(Type)
Using type text (default), Prolog will write a text ﬁle in an operating system compatible
way. Using type binary the bytes will be read or written without any translation. See
also the option encoding.
alias(Atom)
Gives the stream a name. Below is an example. Be careful with this option as stream
names are global. See also set stream/2.
34New code should use the alias(Alias) option for compatibility with the ISO standard.
SWI-Prolog 6.6 Reference Manual

122
CHAPTER 4. BUILT-IN PREDICATES
?- open(data, read, Fd, [alias(input)]).
...,
read(input, Term),
...
encoding(Encoding)
Deﬁne the encoding used for reading and writing text to this stream. The default encoding
for type text is derived from the Prolog ﬂag encoding. For binary streams the
default encoding is octet. For details on encoding issues, see section 2.18.1.
bom(Bool)
Check for a BOM (Byte Order Marker) or write one. If omitted, the default is true
for mode read and false for mode write. See also stream property/2 and
especially section 2.18.1 for a discussion of this feature.
eof action(Action)
Deﬁnes what happens if the end of the input stream is reached. Action eof code makes
get0/1 and friends return -1, and read/1 and friends return the atom end of file.
Repetitive reading keeps yielding the same result. Action error is like eof code, but
repetitive reading will raise an error. With action reset, Prolog will examine the ﬁle
again and return more data if the ﬁle has grown.
buffer(Buffering)
Deﬁnes output buffering. The atom full (default) deﬁnes full buffering, line buffering
by line, and false implies the stream is fully unbuffered. Smaller buffering is useful
if another process or the user is waiting for the output as it is being produced. See also
flush output/[0,1]. This option is not an ISO option.
close on abort(Bool)
If true (default), the stream is closed on an abort (see abort/0). If false, the stream
is not closed. If it is an output stream, however, it will be ﬂushed. Useful for logﬁles and
if the stream is associated to a process (using the pipe/1 construct).
locale(+Locale)
Set the locale that is used by notably format/2 for output on this stream. See sec-
tion 4.22.
lock(LockingMode)
Try to obtain a lock on the open ﬁle. Default is none, which does not lock the ﬁle. The
value read or shared means other processes may read the ﬁle, but not write it. The
value write or exclusive means no other process may read or write the ﬁle.
Locks are acquired through the POSIX function fcntl() using the command F SETLKW,
which makes a blocked call wait for the lock to be released. Please note that fcntl() locks
are advisory and therefore only other applications using the same advisory locks honour
your lock. As there are many issues around locking in Unix, especially related to NFS
(network ﬁle system), please study the fcntl() manual page before trusting your locks!
The lock option is a SWI-Prolog extension.
wait(Bool)
This option can be combined with the lock option. If false (default true), the open
SWI-Prolog 6.6 Reference Manual

4.16. INPUT AND OUTPUT
123
call returns immediately with an exception if the ﬁle is locked. The exception has the
format permission error(lock, source sink, SrcDest).
The option reposition is not supported in SWI-Prolog. All streams connected to a ﬁle may
be repositioned.
open(+SrcDest, +Mode, ?Stream)
[ISO]
Equivalent to open/4 with an empty option list.
open null stream(?Stream)
Open an output stream that produces no output. All counting functions are enabled on such
a stream. It can be used to discard output (like Unix /dev/null) or exploit the counting
properties. The initial encoding of Stream is utf8, enabling arbitrary Unicode output. The
encoding can be changed to determine byte counts of the output in a particular encoding or
validate if output is possible in a particular encoding. For example, the code below determines
the number of characters emitted when writing Term.
write_length(Term, Len) :-
open_null_stream(Out),
write(Out, Term),
character_count(Out, Len0),
close(Out),
Len = Len0.
close(+Stream)
[ISO]
Close the speciﬁed stream. If Stream is not open, an existence error is raised. However, clos-
ing a stream multiple times may crash Prolog.
This is particularly true for multithreaded
applications.
If the closed stream is the current input or output stream, the terminal is made the current input
or output.
close(+Stream, +Options)
[ISO]
Provides close(Stream, [force(true)]) as the only option. Called this way, any resource errors
(such as write errors while ﬂushing the output buffer) are ignored.
stream property(?Stream, ?StreamProperty)
[ISO]
ISO compatible predicate for querying the status of open I/O streams. StreamProperty is one
of:
alias(Atom)
If Atom is bound, test if the stream has the speciﬁed alias. Otherwise unify Atom with the
ﬁrst alias of the stream.35
buffer(Buffering)
SWI-Prolog extension to query the buffering mode of this stream. Buffering is one of
full, line or false. See also open/4.
35BUG: Backtracking does not give other aliases.
SWI-Prolog 6.6 Reference Manual

124
CHAPTER 4. BUILT-IN PREDICATES
buffer size(Integer)
SWI-Prolog extension to query the size of the I/O buffer associated to a stream in bytes.
Fails if the stream is not buffered.
bom(Bool)
If present and true, a BOM (Byte Order Mark) was detected while opening the ﬁle for
reading, or a BOM was written while opening the stream. See section 2.18.1 for details.
close on abort(Bool)
Determine whether or not abort/0 closes the stream. By default streams are closed.
close on exec(Bool)
Determine whether or not the stream is closed when executing a new process (exec() in
Unix, CreateProcess() in Windows). Default is to close streams. This maps to fcntl()
F SETFD using the ﬂag FD CLOEXEC on Unix and (negated) HANDLE FLAG INHERIT
on Windows.
encoding(Encoding)
Query the encoding used for text. See section 2.18.1 for an overview of wide character
and encoding issues in SWI-Prolog.
end of stream(E)
If Stream is an input stream, unify E with one of the atoms not, at or past. See also
at end of stream/[0,1].
eof action(A)
Unify A with one of eof code, reset or error. See open/4 for details.
ﬁle name(Atom)
If Stream is associated to a ﬁle, unify Atom to the name of this ﬁle.
ﬁle no(Integer)
If the stream is associated with a POSIX ﬁle descriptor, unify Integer with the descriptor
number. SWI-Prolog extension used primarily for integration with foreign code. See also
Sﬁleno() from SWI-Stream.h.
input
True if Stream has mode read.
locale(Locale)
True when Locale is the current locale associated with the stream. See section 4.22.
mode(IOMode)
Unify IOMode to the mode given to open/4 for opening the stream. Values are: read,
write, append and the SWI-Prolog extension update.
newline(NewlineMode)
One of posix or dos. If dos, text streams will emit \r\n for \n and discard \r from
input streams. Default depends on the operating system.
nlink(-Count)
Number of hard links to the ﬁle. This expresses the number of ‘names’ the ﬁle has. Not
supported on all operating systems and the value might be bogus. See the documentation
of fstat() for your OS and the value st nlink.
output
True if Stream has mode write, append or update.
SWI-Prolog 6.6 Reference Manual

4.16. INPUT AND OUTPUT
125
position(Pos)
Unify Pos with the current stream position.
A stream position is an opaque
term whose ﬁelds can be extracted using stream position data/3.
See also
set stream position/2.
reposition(Bool)
Unify Bool with true if the position of the stream can be set (see seek/4). It is assumed
the position can be set if the stream has a seek-function and is not based on a POSIX ﬁle
descriptor that is not associated to a regular ﬁle.
representation errors(Mode)
Determines behaviour of character output if the stream cannot represent a character. For
example, an ISO Latin-1 stream cannot represent Cyrillic characters. The behaviour is
one of error (throw an I/O error exception), prolog (write \...\ escape code) or
xml (write &#...; XML character entity). The initial mode is prolog for the user
streams and error for all other streams. See also section 2.18.1 and set stream/2.
timeout(-Time)
Time is the timeout currently associated with the stream. See set stream/2 with the
same option. If no timeout is speciﬁed, Time is uniﬁed to the atom infinite.
type(Type)
Unify Type with text or binary.
tty(Bool)
This property is reported with Bool equal to true if the stream is associated with a
terminal. See also set stream/2.
current stream(?Object, ?Mode, ?Stream)
The predicate current stream/3 is used to access the status of a stream as well as to
generate all open streams. Object is the name of the ﬁle opened if the stream refers to an open
ﬁle, an integer ﬁle descriptor if the stream encapsulates an operating system stream, or the
atom [] if the stream refers to some other object. Mode is one of read or write.
is stream(+Term)
True if Term is a stream name or valid stream handle. This predicate realises a safe test for the
existence of a stream alias or handle.
stream pair(?StreamPair, ?Read, ?Write)
This predicate can be used in mode (-,+,+) to create a stream-pair from an input stream and an
output stream. Stream-pairs can be used by all I/O operations on streams, where the operation
selects the appropriate member of the pair. The predicate close/1 closes both streams of the
pair. Mode (+,-,-) can be used to get access to the underlying streams.
set stream position(+Stream, +Pos)
[ISO]
Set the current position of Stream to Pos. Pos is a term as returned by stream property/2
using the position(Pos) property. See also seek/4.
stream position data(?Field, +Pos, -Data)
Extracts
information
from
the
opaque
stream
position
term
as
returned
by
stream property/2
requesting
the
position(Pos)
property.
Field
is
one
SWI-Prolog 6.6 Reference Manual

126
CHAPTER 4. BUILT-IN PREDICATES
of
line count,
line position,
char count
or
byte count.
See
also
line count/2, line position/2, character count/2 and byte count/2.36
seek(+Stream, +Offset, +Method, -NewLocation)
Reposition the current point of the given Stream. Method is one of bof, current or eof,
indicating positioning relative to the start, current point or end of the underlying object.
NewLocation is uniﬁed with the new offset, relative to the start of the stream.
Positions are counted in ‘units’.
A unit is 1 byte, except for text ﬁles using 2-byte Uni-
code encoding (2 bytes) or wchar encoding (sizeof(wchar t)).
The latter guarantees com-
fortable interaction with wide-character text objects.
Otherwise, the use of seek/4 on
non-binary ﬁles (see open/4) is of limited use, especially when using multi-byte text
encodings (e.g. UTF-8) or multi-byte newline ﬁles (e.g. DOS/Windows).
On text ﬁles,
SWI-Prolog offers reliable backup to an old position using stream property/2 and
set stream position/2. Skipping N character codes is achieved calling get code/2
N times or using copy stream data/3, directing the output to a null stream (see
open null stream/1). If the seek modiﬁes the current location, the line number and char-
acter position in the line are set to 0.
If the stream cannot be repositioned, a permission error is raised. If applying the offset
would result in a ﬁle position less than zero, a domain error is raised. Behaviour when
seeking to positions beyond the size of the underlying object depend on the object and possi-
bly the operating system. The predicate seek/4 is compatible with Quintus Prolog, though
the error conditions and signalling is ISO compliant. See also stream property/2 and
set stream position/2.
set stream(+Stream, +Attribute)
Modify an attribute of an existing stream. Attribute speciﬁes the stream property to set. If
stream is a pair (see stream pair/3) both streams are modiﬁed, unless the property is only
meaningful on one of the streams or setting both is not meaningful. In particular, eof action
only applies to the read stream, representation errors only applies to the write stream
and trying to set alias or line position on a pair results in a permission error
exception. See also stream property/2 and open/4.
alias(AliasName)
Set the alias of an already created stream. If AliasName is the name of one of the standard
streams, this stream is rebound. Thus, set stream(S, current input) is the
same as set input/1, and by setting the alias of a stream to user input, etc., all
user terminal input is read from this stream. See also interactor/0.
buffer(Buffering)
Set the buffering mode of an already created stream. Buffering is one of full, line or
false.
buffer size(+Size)
Set the size of the I/O buffer of the underlying stream to Size bytes.
close on abort(Bool)
Determine whether or not the stream is closed by abort/0. By default, streams are
closed.
36Introduced in version 5.6.4 after extending the position term with a byte count. Compatible with SICStus Prolog.
SWI-Prolog 6.6 Reference Manual

4.16. INPUT AND OUTPUT
127
close on exec(Bool)
Set the close on exec property. See stream property/2.
encoding(Atom)
Deﬁnes the mapping between bytes and character codes used for the stream. See sec-
tion 2.18.1 for supported encodings.
eof action(Action)
Set end-of-ﬁle handling to one of eof code, reset or error.
ﬁle name(FileName)
Set the ﬁlename associated to this stream. This call can be used to set the ﬁle for error
locations if Stream corresponds to FileName and is not obtained by opening the ﬁle
directly but, for example, through a network service.
line position(LinePos)
Set the line position attribute of the stream. This feature is intended to correct position
management of the stream after sending a terminal escape sequence (e.g., setting ANSI
character attributes). Setting this attribute raises a permission error if the stream does
not record positions. See line position/2 and stream property/2 (property
position).
locale(+Locale)
Change the locale of the stream. See section 4.22.
newline(NewlineMode)
Set input or output translation for newlines. See corresponding stream property/2
for details.
In addition to the detected modes, an input stream can be set in mode
detect. It will be set to dos if a \r character was removed.
timeout(Seconds)
This option can be used to make streams generate an exception if it takes longer than
Seconds before any new data arrives at the stream. The value inﬁnite (default) makes the
stream block indeﬁnitely. Like wait for input/3, this call only applies to streams
that support the select() system call. For further information about timeout handling, see
wait for input/3. The exception is of the form
error(timeout error(read, Stream), )
type(Type)
Set the type of the stream to one of text or binary.
See also open/4 and the
encoding property of streams. Switching to binary sets the encoding to octet.
Switching to text sets the encoding to the default text encoding.
record position(Bool)
Do/do not record the line count and line position (see line count/2 and
line position/2).
representation errors(Mode)
Change the behaviour when writing characters to the stream that cannot be represented
by the encoding. See also stream property/2 and section 2.18.1.
tty(Bool)
Modify whether Prolog thinks there is a terminal (i.e. human interaction) connected
to this stream.
On Unix systems the initial value comes from isatty().
On Win-
dows, the initial user streams are supposed to be associated to a terminal.
See also
stream property/2.
SWI-Prolog 6.6 Reference Manual

128
CHAPTER 4. BUILT-IN PREDICATES
set prolog IO(+In, +Out, +Error)
Prepare the given streams for interactive behaviour normally associated to the terminal. In
becomes the user input and current input of the calling thread.
Out becomes
user output and current output.
If Error equals Out an unbuffered stream is
associated to the same destination and linked to user error.
Otherwise Error is used
for user error.
Output buffering for Out is set to line and buffering on Error is
disabled. See also prolog/0 and set stream/2. The clib package provides the library
prolog server, creating a TCP/IP server for creating an interactive session to Prolog.
4.16.3
Edinburgh-style I/O
The package for implicit input and output destinations is (almost) compatible with Edinburgh DEC-10
and C-Prolog. The reading and writing predicates refer to, resp., the current input and output streams.
Initially these streams are connected to the terminal. The current output stream is changed using
tell/1 or append/1. The current input stream is changed using see/1. The stream’s current
value can be obtained using telling/1 for output and seeing/1 for input.
Source and destination are either a ﬁle, user, or a term ‘pipe(Command)’.
The reserved
stream name user refers to the terminal.37 In the predicate descriptions below we will call the
source/destination argument ‘SrcDest’. Below are some examples of source/destination speciﬁca-
tions.
?- see(data).
% Start reading from ﬁle ‘data’.
?- tell(user).
% Start writing to the terminal.
?- tell(pipe(lpr)).
% Start writing to the printer.
Another example of using the pipe/1 construct is shown below.38 Note that the pipe/1 con-
struct is not part of Prolog’s standard I/O repertoire.
getwd(Wd) :-
seeing(Old), see(pipe(pwd)),
collect_wd(String),
seen, see(Old),
atom_codes(Wd, String).
collect_wd([C|R]) :-
get0(C), C \== -1, !,
collect_wd(R).
collect_wd([]).
The effect of tell/1 is not undone on backtracking, and since the stream handle is not speciﬁed
explicitly in further I/O operations when using Edinburgh-style I/O, you may write to unintended
streams more easily than when using ISO compliant I/O. For example, the following query writes
both ”a” and ”b” into the ﬁle ‘out’ :
?- (tell(out), write(a), false ; write(b)), told.
37The ISO I/O layer uses user input, user output and user error.
38As of version 5.3.15, the pipe construct is supported in the MS-Windows version, both for swipl.exe and
swipl-win.exe. The implementation uses code from the LUA programming language (http://www.lua.org).
SWI-Prolog 6.6 Reference Manual

4.16. INPUT AND OUTPUT
129
Compatibility notes
Unlike Edinburgh Prolog systems, telling/1 and seeing/1 do not return the ﬁlename of the
current input/output but rather the stream identiﬁer, to ensure the design pattern below works under
all circumstances:39
...,
telling(Old), tell(x),
...,
told, tell(Old),
...,
The predicates tell/1 and see/1 ﬁrst check for user, the pipe(command) and a stream handle.
Otherwise, if the argument is an atom it is ﬁrst compared to open streams associated to a ﬁle with
exactly the same name. If such a stream exists, created using tell/1 or see/1, output (input) is
switched to the open stream. Otherwise a ﬁle with the speciﬁed name is opened.
The behaviour is compatible with Edinburgh Prolog. This is not without problems. Changing
directory, non-ﬁle streams, and multiple names referring to the same ﬁle easily lead to unexpected
behaviour. New code, especially when managing multiple I/O channels, should consider using the
ISO I/O predicates deﬁned in section 4.16.2.
see(+SrcDest)
Open SrcDest for reading and make it the current input (see set input/1). If SrcDest is a
stream handle, just make this stream the current input. See the introduction of section 4.16.3
for details.
tell(+SrcDest)
Open SrcDest for writing and make it the current output (see set output/1). If SrcDest is a
stream handle, just make this stream the current output. See the introduction of section 4.16.3
for details.
append(+File)
Similar to tell/1, but positions the ﬁle pointer at the end of File rather than truncating an
existing ﬁle. The pipe construct is not accepted by this predicate.
seeing(?SrcDest)
Same as current input/1, except that user is returned if the current input is the stream
user input to improve compatibility with traditional Edinburgh I/O. See the introduction of
section 4.16.3 for details.
telling(?SrcDest)
Same as current output/1, except that user is returned if the current output is the stream
user output to improve compatibility with traditional Edinburgh I/O. See the introduction
of section 4.16.3 for details.
seen
Close the current input stream. The new input stream becomes user input.
39Filenames can be ambiguous and SWI-Prolog streams can refer to much more than just ﬁles.
SWI-Prolog 6.6 Reference Manual

130
CHAPTER 4. BUILT-IN PREDICATES
told
Close the current output stream. The new output stream becomes user output.
4.16.4
Switching between Edinburgh and ISO I/O
The predicates below can be used for switching between the implicit and the explicit stream-based
I/O predicates.
set input(+Stream)
[ISO]
Set
the
current
input
stream
to
become
Stream.
Thus,
open(file, read, Stream), set input(Stream) is equivalent to see(file).
set output(+Stream)
[ISO]
Set the current output stream to become Stream. See also with output to/2.
current input(-Stream)
[ISO]
Get the current input stream. Useful for getting access to the status predicates associated with
streams.
current output(-Stream)
[ISO]
Get the current output stream.
4.16.5
Write onto atoms, code-lists, etc.
with output to(+Output, :Goal)
Run Goal as once/1, while characters written to the current output are sent to Output. The
predicate is SWI-Prolog-speciﬁc, inspired by various posts to the mailinglist. It provides a
ﬂexible replacement for predicates such as sformat/3, swritef/3, term to atom/2,
atom number/2 converting numbers to atoms, etc. The predicate format/3 accepts the
same terms as output argument.
Applications should generally avoid creating atoms by breaking and concatenating other atoms,
as the creation of large numbers of intermediate atoms generally leads to poor performance,
even more so in multithreaded applications. This predicate supports creating difference lists
from character data efﬁciently. The example below deﬁnes the DCG rule term//1 to insert a
term in the output:
term(Term, In, Tail) :-
with_output_to(codes(In, Tail), write(Term)).
?- phrase(term(hello), X).
X = [104, 101, 108, 108, 111]
A Stream handle or alias
Temporarily
switch
current
output
to
the
given
stream.
Redirection
using
with output to/2 guarantees the original output is restored, also if Goal fails
or raises an exception. See also call cleanup/2.
SWI-Prolog 6.6 Reference Manual

4.17. STATUS OF STREAMS
131
atom(-Atom)
Create an atom from the emitted characters. Please note the remark above.
string(-String)
Create a string object as deﬁned in section 4.24.
codes(-Codes)
Create a list of character codes from the emitted characters, similar to atom codes/2.
codes(-Codes, -Tail)
Create a list of character codes as a difference list.
chars(-Chars)
Create a list of one-character atoms from the emitted characters,
similar to
atom chars/2.
chars(-Chars, -Tail)
Create a list of one-character atoms as a difference list.
4.17
Status of streams
wait for input(+ListOfStreams, -ReadyList, +TimeOut)
Wait for input on one of the streams in ListOfStreams and return a list of streams on which
input is available in ReadyList. wait for input/3 waits for at most TimeOut seconds.
Timeout may be speciﬁed as a ﬂoating point number to specify fractions of a second. If Timeout
equals infinite, wait for input/3 waits indeﬁnitely.40
This predicate can be used to implement timeout while reading and to handle input from multi-
ple sources. The following example will wait for input from the user and an explicitly opened
second terminal. On return, Inputs may hold user input or P4 or both.
?- open(’/dev/ttyp4’, read, P4),
wait_for_input([user_input, P4], Inputs, 0).
This predicate relies on the select() call on most operating systems. On Unix this call is imple-
mented for any stream referring to a ﬁle handle, which implies all OS-based streams: sockets,
terminals, pipes, etc. On non-Unix systems select() is generally only implemented for socket-
based streams. See also socket from the clib package.
Note that wait for input/3 returns streams that have data waiting. This does not mean
you can, for example, call read/2 on the stream without blocking as the stream might hold an
incomplete term. The predicate set stream/2 using the option timeout(Seconds) can be
used to make the stream generate an exception if no new data arrives within the timeout period.
Suppose two processes communicate by exchanging Prolog terms. The following code makes
the server immune for clients that write an incomplete term:
...,
tcp_accept(Server, Socket, _Peer),
tcp_open(Socket, In, Out),
40For compatibility reasons, a Timeout value of 0 (integer) also waits indeﬁnitely. To call select() without giving up the
CPU, pass the ﬂoat 0.0. If compatibility with versions older than 5.1.3 is desired, pass the ﬂoat value 1.0e-7.
SWI-Prolog 6.6 Reference Manual

132
CHAPTER 4. BUILT-IN PREDICATES
set_stream(In, timeout(10)),
catch(read(In, Term), _, (close(Out), close(In), fail)),
...,
byte count(+Stream, -Count)
Byte position in Stream.
For binary streams this is the same as character count/2.
For text ﬁles the number may be different due to multi-byte encodings or additional record
separators (such as Control-M in Windows).
character count(+Stream, -Count)
Unify Count with the current character index. For input streams this is the number of characters
read since the open; for output streams this is the number of characters written. Counting starts
at 0.
line count(+Stream, -Count)
Unify Count with the number of lines read or written. Counting starts at 1.
line position(+Stream, -Count)
Unify Count with the position on the current line. Note that this assumes the position is 0 after
the open. Tabs are assumed to be deﬁned on each 8-th character, and backspaces are assumed
to reduce the count by one, provided it is positive.
4.18
Primitive character I/O
See section 4.2 for an overview of supported character representations.
nl
[ISO]
Write a newline character to the current output stream. On Unix systems nl/0 is equivalent to
put(10).
nl(+Stream)
[ISO]
Write a newline to Stream.
put(+Char)
Write Char to the current output stream. Char is either an integer expression evaluating to a
character code or an atom of one character. Deprecated. New code should use put char/1
or put code/1.
put(+Stream, +Char)
Write Char to Stream. See put/1 for details.
put byte(+Byte)
[ISO]
Write a single byte to the output. Byte must be an integer between 0 and 255.
put byte(+Stream, +Byte)
[ISO]
Write a single byte to Stream. Byte must be an integer between 0 and 255.
SWI-Prolog 6.6 Reference Manual

4.18. PRIMITIVE CHARACTER I/O
133
put char(+Char)
[ISO]
Write a character to the current output, obeying the encoding deﬁned for the current output
stream. Note that this may raise an exception if the encoding of the output stream cannot
represent Char.
put char(+Stream, +Char)
[ISO]
Write a character to Stream, obeying the encoding deﬁned for Stream. Note that this may raise
an exception if the encoding of Stream cannot represent Char.
put code(+Code)
[ISO]
Similar to put char/1, but using a character code. Code is a non-negative integer. Note that
this may raise an exception if the encoding of the output stream cannot represent Code.
put code(+Stream, +Code)
[ISO]
Same as put code/1 but directing Code to Stream.
tab(+Amount)
Write Amount spaces on the current output stream. Amount should be an expression that evalu-
ates to a positive integer (see section 4.27).
tab(+Stream, +Amount)
Write Amount spaces to Stream.
ﬂush output
[ISO]
Flush pending output on current output stream. flush output/0 is automatically generated
by read/1 and derivatives if the current input stream is user and the cursor is not at the left
margin.
ﬂush output(+Stream)
[ISO]
Flush output on the speciﬁed stream. The stream must be open for writing.
ttyﬂush
Flush pending output on stream user. See also flush output/[0,1].
get byte(-Byte)
[ISO]
Read the current input stream and unify the next byte with Byte (an integer between 0 and 255).
Byte is uniﬁed with -1 on end of ﬁle.
get byte(+Stream, -Byte)
[ISO]
Read the next byte from Stream and unify Byte with an integer between 0 and 255.
get code(-Code)
[ISO]
Read the current input stream and unify Code with the character code of the next character.
Code is uniﬁed with -1 on end of ﬁle. See also get char/1.
get code(+Stream, -Code)
[ISO]
Read the next character code from Stream.
get char(-Char)
[ISO]
Read the current input stream and unify Char with the next character as a one-character atom.
See also atom chars/2. On end-of-ﬁle, Char is uniﬁed to the atom end of file.
SWI-Prolog 6.6 Reference Manual

134
CHAPTER 4. BUILT-IN PREDICATES
get char(+Stream, -Char)
[ISO]
Unify Char with the next character from Stream as a one-character atom.
See also
get char/2, get byte/2 and get code/2.
get0(-Char)
[deprecated]
Edinburgh version of the ISO get code/1 predicate. Note that Edinburgh Prolog didn’t
support wide characters and therefore technically speaking get0/1 should have been mapped
to get byte/1. The intention of get0/1, however, is to read character codes.
get0(+Stream, -Char)
[deprecated]
Edinburgh version of the ISO get code/2 predicate. See also get0/1.
get(-Char)
[deprecated]
Read the current input stream and unify the next non-blank character with Char. Char is
uniﬁed with -1 on end of ﬁle. The predicate get/1 operates on character codes. See also
get0/1.
get(+Stream, -Char)
[deprecated]
Read the next non-blank character from Stream. See also get/1, get0/1 and get0/2.
peek byte(-Byte)
[ISO]
peek byte(+Stream, -Byte)
[ISO]
peek code(-Code)
[ISO]
peek code(+Stream, -Code)
[ISO]
peek char(-Char)
[ISO]
peek char(+Stream, -Char)
[ISO]
Read the next byte/code/char from the input without removing it. These predicates do not
modify the stream’s position or end-of-ﬁle status. These predicates require a buffered stream
(see set stream/2) and raise a permission error if the stream is unbuffered or the buffer is
too small to hold the longest multi-byte sequence that might need to be buffered.
skip(+Code)
Read the input until Code or the end of the ﬁle is encountered.
A subsequent call to
get code/1 will read the ﬁrst character after Code.
skip(+Stream, +Code)
Skip input (as skip/1) on Stream.
get single char(-Code)
Get a single character from input stream ‘user’ (regardless of the current input stream). Unlike
get code/1, this predicate does not wait for a return. The character is not echoed to the
user’s terminal. This predicate is meant for keyboard menu selection, etc. If SWI-Prolog was
started with the -tty option this predicate reads an entire line of input and returns the ﬁrst
non-blank character on this line, or the character code of the newline (10) if the entire line
consisted of blank characters.
at end of stream
[ISO]
Succeeds after the last character of the current input stream has been read. Also succeeds if
there is no valid current input stream.
SWI-Prolog 6.6 Reference Manual

4.19. TERM READING AND WRITING
135
at end of stream(+Stream)
[ISO]
Succeeds after the last character of the named stream is read, or Stream is not a valid input
stream. The end-of-stream test is only available on buffered input streams (unbuffered input
streams are rarely used; see open/4).
set end of stream(+Stream)
Set the size of the ﬁle opened as Stream to the current ﬁle position. This is typically used in
combination with the open-mode update.
copy stream data(+StreamIn, +StreamOut, +Len)
Copy Len codes from StreamIn to StreamOut. Note that the copy is done using the semantics
of get code/2 and put code/2, taking care of possibly recoding that needs to take place
between two text ﬁles. See section 2.18.1.
copy stream data(+StreamIn, +StreamOut)
Copy all (remaining) data from StreamIn to StreamOut.
read pending input(+StreamIn, -Codes, ?Tail)
Read input pending in the input buffer of StreamIn and return it in the difference list Codes-Tail.
That is, the available characters codes are used to create the list Codes ending in the tail Tail.
This predicate is intended for efﬁcient unbuffered copying and ﬁltering of input coming from
network connections or devices.
The following code fragment realises efﬁcient non-blocking copying of data from an input
to an output stream. The at end of stream/1 call checks for end-of-stream and ﬁlls the
input buffer. Note that the use of a get code/2 and put code/2 based loop requires a
flush output/1 call after each put code/2. The copy stream data/2 does not al-
low for inspection of the copied data and suffers from the same buffering issues.
copy(In, Out) :-
repeat,
(
at_end_of_stream(In)
->
!
;
read_pending_input(In, Chars, []),
format(Out, ’˜s’, [Chars]),
flush_output(Out),
fail
).
4.19
Term reading and writing
This section describes the basic term reading and writing predicates. The predicates format/[1,2]
and writef/2 provide formatted output. Writing to Prolog data structures such as atoms or code-
lists is supported by with output to/2 and format/3.
Reading is sensitive to the Prolog ﬂag character escapes, which controls the interpretation
of the \ character in quoted atoms and strings.
SWI-Prolog 6.6 Reference Manual

136
CHAPTER 4. BUILT-IN PREDICATES
write term(+Term, +Options)
[ISO]
The predicate write term/2 is the generic form of all Prolog term-write predicates. Valid
options are:
attributes(Atom)
Deﬁne how attributed variables (see section 6.1) are written. The default is determined by
the Prolog ﬂag write attributes. Deﬁned values are ignore (ignore the attribute),
dots (write the attributes as {...}), write (simply hand the attributes recursively to
write term/2) and portray (hand the attributes to attr portray hook/2).
backquoted string(Bool)
If true, write a string object (see section 4.24) as ‘... ‘. The default depends on the
Prolog ﬂag backquoted string.
blobs(Atom)
Deﬁne how non-text blobs are handled. By default, this is left to the write handler spec-
iﬁed with the blob type.
Using portray, portray/1 is called for each blob
encountered. See section 9.4.7.
character escapes(Bool)
If true and quoted(true) is active, special characters in quoted atoms and strings are
emitted as ISO escape sequences. Default is taken from the reference module (see below).
cycles(Bool)
If true (default), cyclic terms are written as @(Template, Substitutions), where Substi-
tutions is a list Var = Value. If cycles is false, max depth is not given, and Term
is cyclic, write term/2 raises a domain error.41 See also the cycles option in
read term/2.
ignore ops(Bool)
If true, the generic term representation (⟨functor⟩(⟨args⟩...)) will be used for all terms.
Otherwise (default), operators, list notation and {}/1 will be written using their special
syntax.
max depth(Integer)
If the term is nested deeper than Integer, print the remainder as ellipses (...). A 0 (zero)
value (default) imposes no depth limit. This option also delimits the number of printed
items in a list. Example:
?- write_term(a(s(s(s(s(0)))), [a,b,c,d,e,f]),
[max_depth(3)]).
a(s(s(...)), [a, b|...])
true.
Used by the top level and debugger to limit screen output. See also the Prolog ﬂags
toplevel print options and debugger print options.
module(Module)
Deﬁne the reference module (default user).
This deﬁnes the default value for the
character escapes option as well as the operator deﬁnitions to use. See also op/3.
41The cycles option and the cyclic term representation using the @-term are copied from SICStus Prolog. However, the
default in SICStus is set to false and SICStus writes an inﬁnite term if not protected by, e.g., the depth limit option.
SWI-Prolog 6.6 Reference Manual

4.19. TERM READING AND WRITING
137
numbervars(Bool)
If true, terms of the format $VAR(N), where ⟨N⟩is a positive integer, will be written
as a variable name. If N is an atom it is written without quotes. This extension allows
for writing variables with user-provided names.
The default is false.
See also
numbervars/3.
partial(Bool)
If true (default false), do not reset the logic that inserts extra spaces that separate
tokens where needed. This is intended to solve the problems with the code below. Calling
write value(.) writes .., which cannot be read. By adding partial(true) to the
option list, it correctly emits . .. Similar problems appear when emitting operators
using multiple calls to write term/3.
write_value(Value) :-
write_term(Value, [partial(true)]),
write(’.’), nl.
portray(Bool)
If true, the hook portray/1 is called before printing a term that is not a variable. If
portray/1 succeeds, the term is considered printed. See also print/1. The default
is false. This option is an extension to the ISO write term options.
portray goal(:Goal)
Implies portray(true), but calls Goal rather than the predeﬁned hook portray/1.
Goal is called through call/3, where the ﬁrst argument is Goal, the second is the term
to be printed and the 3rd argument is the current write option list. The write option list is
copied from the write term call, but the list is guaranteed to hold an option priority
that reﬂects the current priority.
priority(Integer)
An integer between 0 and 1200 representing the ‘context priority’. Default is 1200. Can
be used to write partial terms appearing as the argument to an operator. For example:
format(’˜w = ’, [VarName]),
write_term(Value, [quoted(true), priority(699)])
quoted(Bool)
If true, atoms and functors that need quotes will be quoted. The default is false.
spacing(+Spacing)
Determines whether and where extra white space is added to enhance readability. The
default is standard, adding only space where needed for proper tokenization by
read term/3. Currently, the only other value is next argument, adding a space
after a comma used to separate arguments in a term or list.
variable names(+List)
Assign names to variables in Term. List is a list of terms Name = Var, where Name is
an atom that represents a valid Prolog variable name. Terms where Var is bound or is
a variable that does not appear in Term are ignored. Raises an error if List is not a list,
one of the members is not a term Name = Var, Name is not an atom or Name does not
represent a valid Prolog variable name.
SWI-Prolog 6.6 Reference Manual

138
CHAPTER 4. BUILT-IN PREDICATES
The implementation binds the variables from List to a term ’$VAR’(Name).
Like
write canonical/1,
terms that where already bound to ’$VAR’(X) before
write term/2 are printed normally, unless the option numbervars(true) is also pro-
vided. If the option numbervars(true) is used, the user is responsible for avoiding col-
lisions between assigned names and numbered names. See also the variable names
option of read term/2.
Possible variable attributes (see section 6) are ignored. In most cases one should use
copy term/3 to obtain a copy that is free of attributed variables and handle the associ-
ated constraints as appropriate for the use-case.
write term(+Stream, +Term, +Options)
[ISO]
As write term/2, but output is sent to Stream rather than the current output.
write length(+Term, -Length, +Options)
[semidet]
True when Length is the number of characters emitted for write termTerm, Options. In addition
to valid options for write term/2, it processes the option:
max length(+MaxLength)
If provided, fail if Length would be larger than MaxLength. The implementation ensures
that the runtime is limited when computing the length of a huge term with a bounded
maximum.
write canonical(+Term)
[ISO]
Write Term on the current output stream using standard parenthesised preﬁx notation (i.e.,
ignoring operator declarations). Atoms that need quotes are quoted. Terms written with this
predicate can always be read back, regardless of current operator declarations. Equivalent
to write term/2 using the options ignore ops, quoted and numbervars after
numbervars/4 using the singletons option.
Note that due to the use of numbervars/4, non-ground terms must be written using a single
write canonical/1 call. This used to be the case anyhow, as garbage collection between
multiple calls to one of the write predicates can change the _G⟨NNN⟩identity of the variables.
write canonical(+Stream, +Term)
[ISO]
Write Term in canonical form on Stream.
write(+Term)
[ISO]
Write Term to the current output, using brackets and operators where appropriate.
write(+Stream, +Term)
[ISO]
Write Term to Stream.
writeq(+Term)
[ISO]
Write Term to the current output, using brackets and operators where appropriate. Atoms that
need quotes are quoted. Terms written with this predicate can be read back with read/1
provided the currently active operator declarations are identical.
writeq(+Stream, +Term)
[ISO]
Write Term to Stream, inserting quotes.
SWI-Prolog 6.6 Reference Manual

4.19. TERM READING AND WRITING
139
writeln(+Term)
Equivalent to write(Term), nl..
print(+Term)
Prints Term on the current output stream similar to write/1, but for each (sub)term of Term,
the dynamic predicate portray/1 is ﬁrst called.
If this predicate succeeds print as-
sumes the (sub)term has been written. This allows for user-deﬁned term writing. See also
portray text.
print(+Stream, +Term)
Print Term to Stream.
portray(+Term)
A dynamic predicate, which can be deﬁned by the user to change the behaviour of print/1
on (sub)terms.
For each subterm encountered that is not a variable print/1 ﬁrst calls
portray/1 using the term as argument.
For lists, only the list as a whole is given to
portray/1. If portray/1 succeeds print/1 assumes the term has been written.
read(-Term)
[ISO]
Read the next Prolog term from the current input stream and unify it with Term. On a syntax
error read/1 displays an error message, attempts to skip the erroneous term and fails. On
reaching end-of-ﬁle Term is uniﬁed with the atom end of file.
read(+Stream, -Term)
[ISO]
Read Term from Stream.
read clause(+Stream, -Term, +Options)
Equivalent to read term/3, but sets options according to the current compilation context
and optionally processes comments. Deﬁned options:
syntax errors(+Atom)
See read term/3, but the default is dec10 (report and restart).
term position(-TermPos)
Same as for read term/3.
subterm positions(-TermPos)
Same as for read term/3.
variable names(-Bindings)
Same as for read term/3.
process comment(+Boolean)
If true (default), call prolog:comment hook(Comments, TermPos, Term) if this
multiﬁle hook is deﬁned (see prolog:comment hook/3). This is used to drive PlDoc.
comments(-Comments)
If provided, unify Comments with the comments encountered while reading Term. This
option implies process comment(false).
The singletons option of read term/3 is initialised from the active style-checking
mode.
The module option is initialised to the current compilation module (see
prolog load context/2).
SWI-Prolog 6.6 Reference Manual

140
CHAPTER 4. BUILT-IN PREDICATES
read term(-Term, +Options)
[ISO]
Read a term from the current input stream and unify the term with Term. The reading is con-
trolled by options from the list of Options. If this list is empty, the behaviour is the same as
for read/1. The options are upward compatible with Quintus Prolog. The argument order
is according to the ISO standard. Syntax errors are always reported using exception-handling
(see catch/3). Options:
backquoted string(Bool)
If true, read ‘. . .‘ to a string object (see section 4.24). The default depends on the
Prolog ﬂag backquoted string.
character escapes(Bool)
Deﬁnes how to read \ escape sequences in quoted atoms.
See the Prolog ﬂag
character escapes in current prolog flag/2. (SWI-Prolog).
comments(-Comments)
Unify Comments with a list of Position-Comment, where Position is a stream position
object (see stream position data/3) indicating the start of a comment and
Comment is a string object containing the text including delimiters of a comment. It
returns all comments from where the read term/2 call started up to the end of the
term read.
cycles(Bool)
If true (default false), re-instantiate templates as produced by the corresponding
write term/2 option.
Note that the default is false to avoid misinterpretation
of @(Template, Substutions), while the default of write term/2 is true because
emitting cyclic terms without using the template construct produces an inﬁnitely large
term (read: it will generate an error after producing a huge amount of output).
double quotes(Atom)
Deﬁnes how to read ”. . . ” strings. See the Prolog ﬂag double quotes. (SWI-Prolog).
module(Module)
Specify Module for operators, character escapes ﬂag and double quotes ﬂag.
The value of the latter two is overruled if the corresponding read term/3 option is
provided. If no module is speciﬁed, the current ‘source module’ is used. (SWI-Prolog).
quasi quotations(-List)
If present, unify List with the quasi quotations (see section A.23 instead of evaluating
quasi quotations. Each quasi quotation is a term quasi quotation(+Syntax, +Quo-
tation, +VarDict, -Result), where Syntax is the term in {|Syntax||, Quotation is a list
of character codes that represent the quotation, VarDict is a list of Name=Variable and
Result is a variable that shares with the place where the quotation must be inserted. This
option is intended to support tools that manipulate Prolog source text.
singletons(Vars)
As variable names, but only reports the variables occurring only once in the Term
read. Variables starting with an underscore (‘ ’) are not included in this list. (ISO). If Vars
is the constant warning, singleton variables are reported using print message/2.
syntax errors(Atom)
If error (default), throw an exception on a syntax error. Other values are fail, which
causes a message to be printed using print message/2, after which the predicate
SWI-Prolog 6.6 Reference Manual

4.19. TERM READING AND WRITING
141
fails, quiet which causes the predicate to fail silently, and dec10 which causes syntax
errors to be printed, after which read term/[2,3] continues reading the next term.
Using dec10, read term/[2,3] never fails. (Quintus, SICStus).
subterm positions(TermPos)
Describes the detailed layout of the term. The formats for the various types of terms are
given below. All positions are character positions. If the input is related to a normal
stream, these positions are relative to the start of the input; when reading from the
terminal, they are relative to the start of the term.
From-To
Used for primitive types (atoms, numbers, variables).
string position(From, To)
Used to indicate the position of a string enclosed in double quotes (").
brace term position(From, To, Arg)
Term of the form {...}, as used in DCG rules. Arg describes the argument.
list position(From, To, Elms, Tail)
A list. Elms describes the positions of the elements. If the list speciﬁes the tail as
|⟨TailTerm⟩, Tail is uniﬁed with the term position of the tail, otherwise with the atom
none.
term position(From, To, FFrom, FTo, SubPos)
Used for a compound term not matching one of the above. FFrom and FTo describe
the position of the functor. SubPos is a list, each element of which describes the term
position of the corresponding subterm.
term position(Pos)
Uniﬁes Pos with the starting position of the term read. Pos is of the same format as used
by stream property/2.
variables(Vars)
Unify Vars with a list of variables in the term. The variables appear in the order they have
been read. See also term variables/2. (ISO).
variable names(Vars)
Unify Vars with a list of ‘Name = Var’, where Name is an atom describing the variable
name and Var is a variable that shares with the corresponding variable in Term. (ISO).
read term(+Stream, -Term, +Options)
[ISO]
Read term with options from Stream. See read term/2.
read term from atom(+Atom, -Term, +Options)
Use read term/3 to read the next term from Atom. Atom is either an atom or a string object
(see section 4.24). It is not required for Atom to end with a full-stop. This predicate supersedes
atom to term/3.
read history(+Show, +Help, +Special, +Prompt, -Term, -Bindings)
Similar to read term/2 using the option variable names, but allows for history sub-
stitutions. read history/6 is used by the top level to read the user’s actions. Show is
the command the user should type to show the saved events. Help is the command to get an
overview of the capabilities. Special is a list of commands that are not saved in the history.
Prompt is the ﬁrst prompt given.
Continuation prompts for more lines are determined by
SWI-Prolog 6.6 Reference Manual

142
CHAPTER 4. BUILT-IN PREDICATES
prompt/2. A %w in the prompt is substituted by the event number. See section 2.7 for
available substitutions.
SWI-Prolog calls read history/6 as follows:
read_history(h, ’!h’, [trace], ’%w ?- ’, Goal, Bindings)
prompt(-Old, +New)
Set prompt associated with read/1 and its derivatives. Old is ﬁrst uniﬁed with the current
prompt. On success the prompt will be set to New if this is an atom. Otherwise an error
message is displayed. A prompt is printed if one of the read predicates is called and the cursor
is at the left margin. It is also printed whenever a newline is given and the term has not been
terminated. Prompts are only printed when the current input stream is user.
prompt1(+Prompt)
Sets the prompt for the next line to be read. Continuation lines will be read using the prompt
deﬁned by prompt/2.
4.20
Analysing and Constructing Terms
functor(?Term, ?Name, ?Arity)
[ISO]
True when Term is a term with functor Name/Arity. If Term is a variable it is uniﬁed with a new
term whose arguments are all different variables (such a term is called a skeleton). If Term is
atomic, Arity will be uniﬁed with the integer 0, and Name will be uniﬁed with Term. Raises
instantiation error if Term is unbound and Name/Arity is insufﬁciently instantiated.
arg(?Arg, +Term, ?Value)
[ISO]
Term should be instantiated to a term, Arg to an integer between 1 and the arity of Term.
Value is uniﬁed with the Arg-th argument of Term. Arg may also be unbound. In this case
Value will be uniﬁed with the successive arguments of the term.
On successful uniﬁca-
tion, Arg is uniﬁed with the argument number. Backtracking yields alternative solutions.42
The predicate arg/3 fails silently if Arg = 0 or Arg > arity and raises the exception
domain error(not less than zero, Arg) if Arg < 0.
?Term =.. ?List
[ISO]
List is a list whose head is the functor of Term and the remaining arguments are the arguments
of the term. Either side of the predicate may be a variable, but not both. This predicate is called
‘Univ’. Examples:
?- foo(hello, X) =.. List.
List = [foo, hello, X]
?- Term =.. [baz, foo(1)]
Term = baz(foo(1))
42The instantiation pattern (-, +, ?) is an extension to ‘standard’ Prolog. Some systems provide genarg/3 that covers
this pattern.
SWI-Prolog 6.6 Reference Manual

4.20. ANALYSING AND CONSTRUCTING TERMS
143
numbervars(+Term, +Start, -End)
Unify the free variables of Term with a term $VAR(N), where N is the number of the variable.
Counting starts at Start.
End is uniﬁed with the number that should be given to the next
variable. Example:
?- numbervars(foo(A, B, A), 0, End).
A = ’$VAR’(0),
B = ’$VAR’(1),
End = 2.
See also the numbervars option to write term/3 and numbervars/4.
numbervars(+Term, +Start, -End, +Options)
As numbervars/3, but providing the following options:
functor name(+Atom)
Name of the functor to use instead of $VAR.
attvar(+Action)
What to do if an attributed variable is encountered. Options are skip, which causes
numbervars/3 to ignore the attributed variable, bind which causes it to thread it as
a normal variable and assign the next ’$VAR’(N) term to it, or (default) error which
raises a type error exception.43
singletons(+Bool)
If true (default false), numbervars/4 does singleton detection. Singleton variables
are uniﬁed with ’$VAR’(’_’), causing them to be printed as _ by write term/2
using the numbervars option. This option is exploited by portray clause/2 and
write canonical/2.44
var number(@Term, -VarNumber)
True if Term is numbered by numbervars/3 and VarNumber is the number given to this
variable. This predicate avoids the need for uniﬁcation with ’$VAR’(X) and opens the path
for replacing this valid Prolog term by an internal representation that has no textual equivalent.
term variables(+Term, -List)
[ISO]
Unify List with a list of variables, each sharing with a unique variable of Term.45 The variables
in List are ordered in order of appearance traversing Term depth-ﬁrst and left-to-right. See also
term variables/3. For example:
?- term_variables(a(X, b(Y, X), Z), L).
L = [X, Y, Z].
43This behaviour was decided after a long discussion between David Reitter, Richard O’Keefe, Bart Demoen and Tom
Schrijvers.
44BUG: Currently this option is ignored for cyclic terms.
45This predicate used to be called free variables/2. The name term variables/2 is more widely used. The
old predicate is still available from the library backcomp.
SWI-Prolog 6.6 Reference Manual

144
CHAPTER 4. BUILT-IN PREDICATES
term variables(+Term, -List, ?Tail)
Difference list version of term variables/2. That is, Tail is the tail of the variable list
List.
copy term(+In, -Out)
[ISO]
Create a version of In with renamed (fresh) variables and unify it to Out. Attributed variables
(see section 6.1) have their attributes copied. The implementation of copy term/2 can deal
with inﬁnite trees (cyclic terms). As pure Prolog cannot distinguish a ground term from another
ground term with exactly the same structure, ground sub-terms are shared between In and Out.
Sharing ground terms does affect setarg/3. SWI-Prolog provides duplicate term/2 to
create a true copy of a term.
4.20.1
Non-logical operations on terms
Prolog is not able to modify instantiated parts of a term. Lacking that capability makes the language
much safer, but unfortunately there are problems that suffer severely in terms of time and/or memory
usage. Always try hard to avoid the use of these primitives, but they can be a good alternative to using
dynamic predicates. See also section 6.3, discussing the use of global variables.
setarg(+Arg, +Term, +Value)
Extra-logical predicate. Assigns the Arg-th argument of the compound term Term with the
given Value. The assignment is undone if backtracking brings the state back into a position
before the setarg/3 call. See also nb setarg/3.
This predicate may be used for destructive assignment to terms, using them as an extra-logical
storage bin. Always try hard to avoid the use of setarg/3 as it is not supported by many
Prolog systems and one has to be very careful about unexpected copying as well as unexpected
noncopying of terms. A good practice to improve somewhat on this situation is to make sure that
terms whose arguments are subject to setarg/3 have one unused and unshared variable in
addition to the used arguments. This variable avoids unwanted sharing in, e.g., copy term/2,
and causes the term to be considered as non-ground.
nb setarg(+Arg, +Term, +Value)
Assigns the Arg-th argument of the compound term Term with the given Value as setarg/3,
but on backtracking the assignment is not reversed. If Value is not atomic, it is duplicated
using duplicate term/2.
This predicate uses the same technique as nb setval/2.
We therefore refer to the description of nb setval/2 for details on non-backtrackable
assignment of terms. This predicate is compatible with GNU-Prolog setarg(A,T,V,false),
removing the type restriction on Value. See also nb linkarg/3. Below is an example for
counting the number of solutions of a goal.
Note that this implementation is thread-safe,
reentrant and capable of handling exceptions.
Realising these features with a traditional
implementation based on assert/retract or flag/3 is much more complicated.
:- meta_predicate
succeeds_n_times(0, -).
succeeds_n_times(Goal, Times) :-
Counter = counter(0),
(
Goal,
SWI-Prolog 6.6 Reference Manual

4.21. ANALYSING AND CONSTRUCTING ATOMS
145
arg(1, Counter, N0),
N is N0 + 1,
nb_setarg(1, Counter, N),
fail
;
arg(1, Counter, Times)
).
nb linkarg(+Arg, +Term, +Value)
As nb setarg/3, but like nb linkval/2 it does not duplicate Value. Use with extreme
care and consult the documentation of nb linkval/2 before use.
duplicate term(+In, -Out)
Version of copy term/2 that also copies ground terms and therefore ensures that destruc-
tive modiﬁcation using setarg/3 does not affect the copy.
See also nb setval/2,
nb linkval/2, nb setarg/3 and nb linkarg/3.
same term(@T1, @T2)
[semidet]
True if T1 and T2 are equivalent and will remain equivalent, even if setarg/3 is used on
either of them. This means T1 and T2 are the same variable, equivalent atomic data or a
compound term allocated at the same address.
4.21
Analysing and Constructing Atoms
These predicates convert between Prolog constants and lists of character codes.
The predicates
atom codes/2, number codes/2 and name/2 behave the same when converting from a con-
stant to a list of character codes. When converting the other way around, atom codes/2 will
generate an atom, number codes/2 will generate a number or exception and name/2 will return
a number if possible and an atom otherwise.
The ISO standard deﬁnes atom chars/2 to describe the ‘broken-up’ atom as a list of one-
character atoms instead of a list of codes.
Up to version 3.2.x, SWI-Prolog’s atom chars/2
behaved like atom codes, compatible with Quintus and SICStus Prolog. As of 3.3.x, SWI-Prolog
atom codes/2 and atom chars/2 are compliant to the ISO standard.
To ease the pain of all variations in the Prolog community, all SWI-Prolog predicates behave as
ﬂexible as possible. This implies the ‘list-side’ accepts either a code-list or a char-list and the ‘atom-
side’ accepts all atomic types (atom, number and string).
atom codes(?Atom, ?String)
[ISO]
Convert between an atom and a list of character codes. If Atom is instantiated, it will be trans-
lated into a list of character codes and the result is uniﬁed with String. If Atom is unbound and
String is a list of character codes, Atom will be uniﬁed with an atom constructed from this list.
atom chars(?Atom, ?CharList)
[ISO]
As atom codes/2, but CharList is a list of one-character atoms rather than a list of character
codes.46
46Up to version 3.2.x, atom chars/2 behaved as the current atom codes/2. The current deﬁnition is compliant
with the ISO standard.
SWI-Prolog 6.6 Reference Manual

146
CHAPTER 4. BUILT-IN PREDICATES
?- atom_chars(hello, X).
X = [h, e, l, l, o]
char code(?Atom, ?Code)
[ISO]
Convert between character and character code for a single character.47
number chars(?Number, ?CharList)
[ISO]
Similar to atom chars/2, but converts between a number and its representation as a list of
one-character atoms. Fails with a syntax error if Number is unbound or CharList does not
describe a number. Following the ISO standard, it allows for leading white space (including
newlines) and does not allow for trailing white space.48
number codes(?Number, ?CodeList)
[ISO]
As number chars/2, but converts to a list of character codes rather than one-character
atoms. In the mode (-, +), both predicates behave identically to improve handling of non-ISO
source.
atom number(?Atom, ?Number)
Realises the popular combination of atom codes/2 and number codes/2 to convert
between atom and number (integer or ﬂoat) in one predicate, avoiding the intermediate list.
Unlike the ISO number codes/2 predicates, atom number/2 fails silently in mode (+,-)
if Atom does not represent a number.49 See also atomic list concat/2 for assembling
an atom from atoms and numbers.
name(?Atomic, ?CodeList)
CodeList is a list of character codes representing the same text as Atomic. Each of the argu-
ments may be a variable, but not both. When CodeList describes an integer or ﬂoating point
number and Atomic is a variable, Atomic will be uniﬁed with the numeric value described by
CodeList (e.g., name(N, "300"), 400 is N + 100 succeeds). If CodeList is not a
representation of a number, Atomic will be uniﬁed with the atom with the name given by the
character code list. When Atomic is an atom or number, the unquoted print representation of it
as a character code list will be uniﬁed with CodeList.
Note that it is not possible to produce the atom ’300’ using name/2,
and that
name(300, CodeList), name(’300’, CodeList) succeeds.
For these reasons,
new code should consider using the ISO predicates atom codes/2 or number codes/2.50
See also atom number/2.
47This is also called atom char/2 in older versions of SWI-Prolog as well as some other Prolog implementations. The
atom char/2 predicate is available from the library backcomp.pl
48ISO also allows for Prolog comments in leading white space. We–and most other implementations–believe this is
incorrect. We also beleive it would have been better not to allow for white space, or to allow for both leading and trailing
white space. Prolog syntax-based conversion can be achieved using format/3 and read from chars/2.
49Versions prior to 6.1.7 raise a syntax error, compliant to number codes/2
50Unfortunately, the ISO predicates provide no neat way to check that a string can be interpreted as a number. The
most sensible way is to use catch/3 to catch the exception from number codes/2; however, this is both slow and
cumbersome. We consider making, e.g., number codes(N, "abc") fail silently in future versions.
SWI-Prolog 6.6 Reference Manual

4.21. ANALYSING AND CONSTRUCTING ATOMS
147
term to atom(?Term, ?Atom)
True if Atom describes a term that uniﬁes with Term. When Atom is instantiated, Atom is
converted and then uniﬁed with Term.
If Atom has no valid syntax, a syntax error
exception is raised. Otherwise Term is “written” on Atom using write term/2 with the
option quoted(true). See also format/3 and with output to/2.
atom to term(+Atom, -Term, -Bindings)
[deprecated]
Use Atom as input to read term/2 using the option variable names and return the
read term in Term and the variable bindings in Bindings. Bindings is a list of Name = Var
couples, thus providing access to the actual variable names.
See also read term/2.
If
Atom has no valid syntax, a syntax error exception is raised.
New code should use
read from atom/3.
atom concat(?Atom1, ?Atom2, ?Atom3)
[ISO]
Atom3 forms the concatenation of Atom1 and Atom2. At least two of the arguments must be
instantiated to atoms. This predicate also allows for the mode (-,-,+), non-deterministically
splitting the 3rd argument into two parts (as append/3 does for lists). SWI-Prolog allows for
atomic arguments. Portable code must use atomic concat/3 if non-atom arguments are
involved.
atomic concat(+Atomic1, +Atomic2, -Atom)
Atom represents the text after converting Atomic1 and Atomic2 to text and concatenating the
result:
?- atomic_concat(name, 42, X).
X = name42.
atomic list concat(+List, -Atom)
[commons]
List is a list of atoms, integers or ﬂoating point numbers. Succeeds if Atom can be uniﬁed with
the concatenated elements of List. Equivalent to atomic list concat(List, ”, Atom).
atomic list concat(+List, +Separator, -Atom)
[commons]
Creates an atom just like atomic list concat/2, but inserts Separator between each pair
of atoms. For example:
?- atomic_list_concat([gnu, gnat], ’, ’, A).
A = ’gnu, gnat’
The SWI-Prolog version of this predicate can also be used to split atoms by instantiating Sepa-
rator and Atom as shown below. We kept this functionality to simplify porting old SWI-Prolog
code where this predicate was called concat atom/3. When used in mode (-,+,+), Separator
must be a non-empty atom. See also split string/4.
?- atomic_list_concat(L, -, ’gnu-gnat’).
L = [gnu, gnat]
SWI-Prolog 6.6 Reference Manual

148
CHAPTER 4. BUILT-IN PREDICATES
atom length(+Atom, -Length)
[ISO]
True if Atom is an atom of Length characters. The SWI-Prolog version accepts all atomic
types, as well as code-lists and character-lists. New code should avoid this feature and use
write length/3 to get the number of characters that would be written if the argument was
handed to write term/3.
atom preﬁx(+Atom, +Preﬁx)
[deprecated]
True if Atom starts with the characters from Preﬁx.
Its behaviour is equivalent to
?- sub atom(Atom, 0,
,
, Preﬁx). Deprecated.
sub atom(+Atom, ?Before, ?Len, ?After, ?Sub)
[ISO]
ISO predicate for breaking atoms. It maintains the following relation: Sub is a sub-atom of
Atom that starts at Before, has Len characters, and Atom contains After characters after the
match.
?- sub_atom(abc, 1, 1, A, S).
A = 1, S = b
The implementation minimises non-determinism and creation of atoms. This is a very ﬂexible
predicate that can do search, preﬁx- and sufﬁx-matching, etc.
sub atom icasechk(+Haystack, ?Start, +Needle)
[semidet]
True when Needle is a sub atom of Haystack starting at Start. The match is ‘half case in-
sensitive’, i.e., uppercase letters in Needle only match themselves, while lowercase letters in
Needle match case insensitively. Start is the ﬁrst 0-based offset inside Haystack where Needle
matches.51
4.22
Localization (locale) support
SWI-Prolog provides (currently limited) support for localized applications.
• The predicates char type/2 and code type/2 query character classes depending on the
locale.
• The predicates collation key/2 and locale sort/2 can be used for locale dependent
sorting of atoms.
• The predicate format time/3 can be used to format time and date representations, where
some of the speciﬁers are locale dependent.
• The predicate format/2 provides locale-speciﬁc formating of numbers. This functionality is
based on a more ﬁne-grained localization model that is the subject of this section.
51This predicate replaces $apropos match/2, used by the help system, while extending it with locating the (ﬁrst) match
and performing case insensitive preﬁx matching. We are still not happy with the name and interface.
SWI-Prolog 6.6 Reference Manual

4.22. LOCALIZATION (LOCALE) SUPPORT
149
A locale is a (optionally named) read-only object that provides information to locale speciﬁc
functions.52 The system creates a default locale object named default from the system locale. This
locale is used as the initial locale for the three standard streams as well as the main thread. Locale
sensitive output predicates such as format/3 get their locale from the stream to which they deliver
their output. New streams get their locale from the thread that created the stream. Threads get their
locale from the thread that created them.
locale create(-Locale, +Default, +Options)
Create a new locale object. Default is either an existing locale or a string that denotes the name
of a locale provided by the system, such as "en_EN.UTF-8". The values read from the
default locale can be modiﬁed using Options. Options provided are:
alias(+Atom)
Give the locale a name.
decimal point(+Atom)
Specify the decimal point to use.
thousands sep(+Atom)
Specify the string that delimits digit groups. Only effective is grouping is also speciﬁed.
grouping(+List)
Specify the grouping of digits. Groups are created from the right (least signiﬁcant) digits,
left of the decimal point. List is a list of integers, specifying the number of digits in each
group, counting from the right. If the last element is repeat(Count), the remaining
digits are grouped in groups of size Count. If the last element is a normal integer, digits
further to the left are not grouped.
For example, the English locale uses
[ decimal_point(’.’), thousands_sep(’,’), grouping([repeat(3)]) ]
Named locales exists until they are destroyed using locale destroy/1 and they are no
longer referenced. Unnamed locales are subject to (atom) garbage collection.
locale destroy(+Locale)
Destroy a locale. If the locale is named, this removes the name association from the locale,
after which the locale is left to be reclaimed by garbage collection.
locale property(?Locale, ?Property)
True when Locale has Property.
Properties are the same as the Options described with
locale create/3.
set locale(+Locale)
Set the default locale for the current thread, as well as the locale for the standard streams
(user input, user output, user error, current output and current input.
This locale is used for new streams, unless overruled using the locale(Locale) option of
open/4 or set stream/2.
52The locale interface described in this section and its effect on format/2 and reading integers from digit groups was
discussed on the SWI-Prolog mailinglist. Most input in this discussion is from Ulrich Neumerkel and Richard O’Keefe.
The predicates in this section were designed by Jan Wielemaker.
SWI-Prolog 6.6 Reference Manual

150
CHAPTER 4. BUILT-IN PREDICATES
current locale(-Locale)
True when Locale is the locale of the calling thread.
4.23
Character properties
SWI-Prolog offers two comprehensive predicates for classifying characters and character codes.
These predicates are deﬁned as built-in predicates to exploit the C-character classiﬁcation’s handling
of locale (handling of local character sets). These predicates are fast, logical and deterministic if
applicable.
In addition, there is the library ctype providing compatibility with some other Prolog systems.
The predicates of this library are deﬁned in terms of code type/2.
char type(?Char, ?Type)
Tests or generates alternative Types or Chars. The character types are inspired by the standard
C <ctype.h> primitives.
alnum
Char is a letter (upper- or lowercase) or digit.
alpha
Char is a letter (upper- or lowercase).
csym
Char is a letter (upper- or lowercase), digit or the underscore (_). These are valid C and
Prolog symbol characters.
csymf
Char is a letter (upper- or lowercase) or the underscore (_). These are valid ﬁrst characters
for C and Prolog symbols.
ascii
Char is a 7-bit ASCII character (0..127).
white
Char is a space or tab, i.e. white space inside a line.
cntrl
Char is an ASCII control character (0..31).
digit
Char is a digit.
digit(Weight)
Char is a digit with value Weight. I.e. char type(X, digit(6) yields X = ’6’.
Useful for parsing numbers.
xdigit(Weight)
Char is a hexadecimal digit with value Weight.
I.e. char type(a, xdigit(X)
yields X = ’10’. Useful for parsing numbers.
graph
Char produces a visible mark on a page when printed. Note that the space is not included!
lower
Char is a lowercase letter.
SWI-Prolog 6.6 Reference Manual

4.23. CHARACTER PROPERTIES
151
lower(Upper)
Char is a lowercase version of Upper. Only true if Char is lowercase and Upper upper-
case.
to lower(Upper)
Char is a lowercase version of Upper. For non-letters, or letter without case, Char and
Lower are the same. See also upcase atom/2 and downcase atom/2.
upper
Char is an uppercase letter.
upper(Lower)
Char is an uppercase version of Lower. Only true if Char is uppercase and Lower lower-
case.
to upper(Lower)
Char is an uppercase version of Lower. For non-letters, or letter without case, Char and
Lower are the same. See also upcase atom/2 and downcase atom/2.
punct
Char is a punctuation character. This is a graph character that is not a letter or digit.
space
Char is some form of layout character (tab, vertical tab, newline, etc.).
end of ﬁle
Char is -1.
end of line
Char ends a line (ASCII: 10..13).
newline
Char is a newline character (10).
period
Char counts as the end of a sentence (.,!,?).
quote
Char is a quote character (", ’, ‘).
paren(Close)
Char is an open parenthesis and Close is the corresponding close parenthesis.
prolog var start
Char can start a Prolog variable name.
prolog atom start
Char can start a unquoted Prolog atom that is not a symbol.
prolog identiﬁer continue
Char can continue a Prolog variable name or atom.
prolog prolog symbol
Char is a Prolog symbol character. Sequences of Prolog symbol characters glue together
to form an unquoted atom. Examples are =.., \=, etc.
code type(?Code, ?Type)
As char type/2, but uses character codes rather than one-character atoms. Please note
SWI-Prolog 6.6 Reference Manual

152
CHAPTER 4. BUILT-IN PREDICATES
that both predicates are as ﬂexible as possible.
They handle either representation if the
argument is instantiated and will instantiate only with an integer code or a one-character atom,
depending of the version used. See also the Prolog ﬂag double quotes, atom chars/2
and atom codes/2.
4.23.1
Case conversion
There is nothing in the Prolog standard for converting case in textual data. The SWI-Prolog predicates
code type/2 and char type/2 can be used to test and convert individual characters. We have
started some additional support:
downcase atom(+AnyCase, -LowerCase)
Converts the characters of AnyCase into lowercase as char type/2 does (i.e. based on
the deﬁned locale if Prolog provides locale support on the hosting platform) and uniﬁes the
lowercase atom with LowerCase.
upcase atom(+AnyCase, -UpperCase)
Converts, similar to downcase atom/2, an atom to uppercase.
4.23.2
White space normalization
normalize space(-Out, +In)
Normalize white space in In. All leading and trailing white space is removed. All non-empty
sequences for Unicode white space characters are replaced by a single space (\u0020)
character. Out uses the same conventions as with output to/2 and format/3.
4.23.3
Language-speciﬁc comparison
This section deals with predicates for language-speciﬁc string comparison operations.
collation key(+Atom, -Key)
Create a Key from Atom for locale-speciﬁc comparison. The key is deﬁned such that if the
key of atom A precedes the key of atom B in the standard order of terms, A is alphabetically
smaller than B using the sort order of the current locale.
The predicate collation key/2 is used by locale sort/2 from library(sort). Please
examine the implementation of locale sort/2 as an example of using this call.
The Key is an implementation-deﬁned and generally unreadable string. On systems that do not
support locale handling, Key is simply uniﬁed with Atom.
locale sort(+List, -Sorted)
Sort a list of atoms using the current locale. List is a list of atoms or string objects (see sec-
tion 4.24). Sorted is uniﬁed with a list containing all atoms of List, sorted to the rules of the
current locale. See also collation key/2 and setlocale/3.
SWI-Prolog 6.6 Reference Manual

4.24. REPRESENTING TEXT IN STRINGS
153
4.24
Representing text in strings
SWI-Prolog supports the data type string. Strings are a time- and space-efﬁcient mechanism to handle
text in Prolog. Strings are stored as a byte array on the global (term) stack and are thus destroyed on
backtracking and reclaimed by the garbage collector.
Strings were added to SWI-Prolog based on an early draft of the ISO standard, offering a mech-
anism to represent temporary character data efﬁciently. As SWI-Prolog strings can handle 0-bytes,
they are frequently used through the foreign language interface (section 9) for storing arbitrary byte
sequences.
Starting with version 3.3, SWI-Prolog offers garbage collection on the atom space as well as
representing 0-bytes in atoms. Although strings and atoms still have different features, new code
should consider using atoms to avoid too many representations for text as well as for compatibility
with other Prolog implementations. Below are some of the differences:
• creation
Creating strings is fast, as the data is simply copied to the global stack. Atoms are unique and
therefore more expensive in terms of memory and time to create. On the other hand, if the same
text has to be represented multiple times, atoms are more efﬁcient.
• destruction
Backtracking destroys strings at no cost. They are cheap to handle by the garbage collector,
but it should be noted that extensive use of strings will cause many garbage collections. Atom
garbage collection is generally faster.
String objects by default have no lexical representation and thus can only be created using the
predicates below or through the foreign language interface (see chapter 9). There are two ways to
make read/1 read text into strings, both controlled through Prolog ﬂags. One is by setting the
double quotes ﬂag to string, and the other is by setting the backquoted string ﬂag to
true. In the latter case, ‘Hello world‘ is read into a string and write term/2 prints strings
between back-quotes if quoted is true. This ﬂag provides compatibility with LPA Prolog string
handling.
atom string(?Atom, ?String)
Bi-directional conversion between an atom and a string. At least one of the two arguments
must be instantiated. Atom can also be an integer or ﬂoating point number.
string codes(?String, ?Codes)
Bi-directional conversion between a string and a list of character codes. At least one of the two
arguments must be instantiated.
string length(+String, -Length)
Unify Length with the number of characters in String. This predicate is functionally equivalent
to atom length/2 and also accepts atoms, integers and ﬂoats as its ﬁrst argument.
string code(?Index, +String, ?Code)
True when Code represents the character at the 0-based Index position in String. If Index
is unbound the string is scanned from index 0. Raises a domain error if Index is negative.
The mode string code(-,+,+) is deterministic if the searched-for Code appears only once
in String. Note that this is similar to sub string(String, Index, 1, , Char), except that
SWI-Prolog 6.6 Reference Manual

154
CHAPTER 4. BUILT-IN PREDICATES
the character is represented as a code in string code/3 and as a one-character string in
sub string/5. See also sub atom/5.
string concat(?String1, ?String2, ?String3)
Similar to atom concat/3, but the unbound argument will be uniﬁed with a string object
rather than an atom. Also, if both String1 and String2 are unbound and String3 is bound to text,
it breaks String3, unifying the start with String1 and the end with String2 as append does with
lists. Note that this is not particularly fast on long strings, as for each redo the system has to
create two entirely new strings, while the list equivalent only creates a single new list-cell and
moves some pointers around.
sub string(+String, ?Start, ?Length, ?After, ?Sub)
Sub is a substring of String starting at Start, with length Length, and String has After characters
left after the match. See also sub atom/5.
4.25
Operators
Operators are deﬁned to improve the readability of source code. For example, without operators, to
write 2*3+4*5 one would have to write +(*(2,3),*(4,5)). In Prolog, a number of operators
have been predeﬁned. All operators, except for the comma (,) can be redeﬁned by the user.
Some care has to be taken before deﬁning new operators. Deﬁning too many operators might
make your source ‘natural’ looking, but at the same time make it hard to understand the limits of
your syntax. To ease the pain, as of SWI-Prolog 3.3.0, operators are local to the module in which
they are deﬁned. Operators can be exported from modules using a term op(Precedence, Type, Name)
in the export list as speciﬁed by module/2. This is an extension speciﬁc to SWI-Prolog and the
recommended mechanism if portability is not an important concern.
The module table of the module user acts as default table for all modules and can be modiﬁed
explicitly from inside a module to achieve compatibility with other Prolog systems:
:- module(prove,
[ prove/1
]).
:- op(900, xfx, user:(=>)).
Unlike what many users think, operators and quoted atoms have no relation: deﬁning an atom as an
operator does not inﬂuence parsing characters into atoms, and quoting an atom does not stop it from
acting as an operator. To stop an atom acting as an operator, enclose it in parentheses like this: (myop).
op(+Precedence, +Type, :Name)
[ISO]
Declare Name to be an operator of type Type with precedence Precedence. Name can also be
a list of names, in which case all elements of the list are declared to be identical operators.
Precedence is an integer between 0 and 1200. Precedence 0 removes the declaration. Type is
one of: xf, yf, xfx, xfy, yfx, fy or fx. The ‘f’ indicates the position of the functor, while
x and y indicate the position of the arguments. ‘y’ should be interpreted as “on this position a
term with precedence lower or equal to the precedence of the functor should occur”. For ‘x’
the precedence of the argument must be strictly lower. The precedence of a term is 0, unless its
SWI-Prolog 6.6 Reference Manual

4.25. OPERATORS
155
1200
xfx
-->, :-
1200
fx
:-, ?-
1150
fx
dynamic,
discontiguous,
initialization,
meta predicate, module transparent, multifile,
thread local, volatile
1100
xfy
;, |
1050
xfy
->, *->
1000
xfy
,
900
fy
\+
900
fx
˜
700
xfx
<, =, =.., =@=, =:=, =<, ==, =\=, >, >=, @<, @=<, @>, @>=,
\=, \==, is
600
xfy
:
500
yfx
+, -, /\, \/, xor
500
fx
?
400
yfx
*, /, //, rdiv, <<, >>, mod, rem
200
xfx
**
200
xfy
ˆ
200
fy
+, -, \
Table 4.2: System operators
principal functor is an operator, in which case the precedence is the precedence of this operator.
A term enclosed in parentheses (...) has precedence 0.
The predeﬁned operators are shown in table 4.2. Operators can be redeﬁned, unless prohibited
by one of the limitations below. Applications must be careful with (re-)deﬁning operators be-
cause changing operators may cause (other) ﬁles to be interpreted differently. Often this will
lead to a syntax error. In other cases, text is read silently into a different term which may lead
to subtle and difﬁcult to track errors.
• It is not allowed to redeﬁne the comma (’,’).
• The bar (|) can only be (re-)deﬁned as inﬁx operator with priority not less than 1001.
• It is not allowed to deﬁne the empty list ([]) or the curly-bracket pair ({}) as operators.
In SWI-Prolog, operators are local to a module (see also section 5.8). Keeping operators in
modules and using controlled import/export of operators as described with the module/2 di-
rective keep the issues manageable. The module system provides the operators from table 4.2
and these operators cannot be modiﬁed. Files that are loaded from the SWI-Prolog directories
resolve operators and predicates from this system module rather than user, which makes the
semantics of the library and development system modules independent of operator changes to
the user module.
current op(?Precedence, ?Type, ?:Name)
[ISO]
True if Name is currently deﬁned as an operator of type Type with precedence Precedence. See
also op/3.
SWI-Prolog 6.6 Reference Manual

156
CHAPTER 4. BUILT-IN PREDICATES
4.26
Character Conversion
Although I wouldn’t really know why you would like to use these features, they are provided for ISO
compliance.
char conversion(+CharIn, +CharOut)
[ISO]
Deﬁne that term input (see read term/3) maps each character read as CharIn to the charac-
ter CharOut. Character conversion is only executed if the Prolog ﬂag char conversion is
set to true and not inside quoted atoms or strings. The initial table maps each character onto
itself. See also current char conversion/2.
current char conversion(?CharIn, ?CharOut)
[ISO]
Queries the current character conversion table. See char conversion/2 for details.
4.27
Arithmetic
Arithmetic can be divided into some special purpose integer predicates and a series of general pred-
icates for integer, ﬂoating point and rational arithmetic as appropriate. The general arithmetic predi-
cates all handle expressions. An expression is either a simple number or a function. The arguments of
a function are expressions. The functions are described in section 4.27.2.
4.27.1
Special purpose integer arithmetic
The predicates in this section provide more logical operations between integers. They are not covered
by the ISO standard, although they are ‘part of the community’ and found as either library or built-in
in many other Prolog systems.
between(+Low, +High, ?Value)
Low and High are integers, High ≥Low. If Value is an integer, Low ≤Value ≤High. When
Value is a variable it is successively bound to all integers between Low and High. If High
is inf or infinite53 between/3 is true iff Value ≥Low, a feature that is particularly
interesting for generating integers from a certain value.
succ(?Int1, ?Int2)
True if Int2 = Int1 + 1 and Int1 ≥0. At least one of the arguments must be instantiated to a
natural number. This predicate raises the domain error not less than zero if called with
a negative integer. E.g. succ(X, 0) fails silently and succ(X, -1) raises a domain error.54
plus(?Int1, ?Int2, ?Int3)
True if Int3 = Int1 + Int2. At least two of the three arguments must be instantiated to integers.
4.27.2
General purpose arithmetic
The general arithmetic predicates are optionally compiled (see set prolog flag/2 and the -O
command line option). Compiled arithmetic reduces global stack requirements and improves perfor-
mance. Unfortunately compiled arithmetic cannot be traced, which is why it is optional.
53We prefer infinite, but some other Prolog systems already use inf for inﬁnity; we accept both for the time being.
54The behaviour to deal with natural numbers only was deﬁned by Richard O’Keefe to support the common count-down-
to-zero in a natural way. Up to 5.1.8, succ/2 also accepted negative integers.
SWI-Prolog 6.6 Reference Manual

4.27. ARITHMETIC
157
+Expr1 > +Expr2
[ISO]
True if expression Expr1 evaluates to a larger number than Expr2.
+Expr1 < +Expr2
[ISO]
True if expression Expr1 evaluates to a smaller number than Expr2.
+Expr1 =< +Expr2
[ISO]
True if expression Expr1 evaluates to a smaller or equal number to Expr2.
+Expr1 >= +Expr2
[ISO]
True if expression Expr1 evaluates to a larger or equal number to Expr2.
+Expr1 =\= +Expr2
[ISO]
True if expression Expr1 evaluates to a number non-equal to Expr2.
+Expr1 =:= +Expr2
[ISO]
True if expression Expr1 evaluates to a number equal to Expr2.
-Number is +Expr
[ISO]
True when Number is the value to which Expr evaluates. Typically, is/2 should be used with
unbound left operand. If equality is to be tested, =:=/2 should be used. For example:
?- 1 is sin(pi/2).
Fails! sin(pi/2) evaluates to the ﬂoat 1.0,
which does not unify with the integer 1.
?- 1 =:= sin(pi/2).
Succeeds as expected.
Arithmetic types
SWI-Prolog deﬁnes the following numeric types:
• integer
If SWI-Prolog is built using the GNU multiple precision arithmetic library (GMP), integer
arithmetic is unbounded, which means that the size of integers is limited by available memory
only. Without GMP, SWI-Prolog integers are 64-bits, regardless of the native integer size of
the platform. The type of integer support can be detected using the Prolog ﬂags bounded,
min integer and max integer. As the use of GMP is default, most of the following
descriptions assume unbounded integer arithmetic.
Internally, SWI-Prolog has three integer representations. Small integers (deﬁned by the Prolog
ﬂag max tagged integer) are encoded directly. Larger integers are represented as 64-bit
values on the global stack. Integers that do not ﬁt in 64 bits are represented as serialised GNU
MPZ structures on the global stack.
• rational number
Rational numbers (Q) are quotients of two integers. Rational arithmetic is only provided if GMP
is used (see above). Rational numbers are currently not supported by a Prolog type. They are
represented by the compound term rdiv(N,M). Rational numbers that are returned from is/2
are canonical, which means M is positive and N and M have no common divisors. Rational
numbers are introduced in the computation using the rational/1, rationalize/1 or
the rdiv/2 (rational division) function. Using the same functor for rational division and for
SWI-Prolog 6.6 Reference Manual

158
CHAPTER 4. BUILT-IN PREDICATES
representing rational numbers allows for passing rational numbers between computations as
well as for using format/3 for printing.
In the long term, it is likely that rational numbers will become atomic as well as a subtype of
number. User code that creates or inspects the rdiv(M,N) terms will not be portable to future
versions. Rationals are created using one of the functions mentioned above and inspected using
rational/3.
• ﬂoat
Floating point numbers are represented using the C type double. On most of today’s platforms
these are 64-bit IEEE ﬂoating point numbers.
Arithmetic functions that require integer arguments accept, in addition to integers, rational num-
bers with (canonical) denominator ‘1’. If the required argument is a ﬂoat the argument is converted to
ﬂoat. Note that conversion of integers to ﬂoating point numbers may raise an overﬂow exception. In
all other cases, arguments are converted to the same type using the order below.
integer →rational number →ﬂoating point number
Rational number examples
The use of rational numbers with unbounded integers allows for exact integer or ﬁxed point arithmetic
under addition, subtraction, multiplication and division. To exploit rational arithmetic rdiv/2 should
be used instead of ‘/’ and ﬂoating point numbers must be converted to rational using rational/1.
Omitting the rational/1 on ﬂoats will convert a rational operand to ﬂoat and continue the arith-
metic using ﬂoating point numbers. Here are some examples.
A is 2 rdiv 6
A = 1 rdiv 3
A is 4 rdiv 3 + 1
A = 7 rdiv 3
A is 4 rdiv 3 + 1.5
A = 2.83333
A is 4 rdiv 3 + rational(1.5)
A = 17 rdiv 6
Note that ﬂoats cannot represent all decimal numbers exactly. The function rational/1 creates
an exact equivalent of the ﬂoat, while rationalize/1 creates a rational number that is within the
ﬂoat rounding error from the original ﬂoat. Please check the documentation of these functions for
details and examples.
Rational numbers can be printed as decimal numbers with arbitrary precision using the
format/3 ﬂoating point conversion:
?- A is 4 rdiv 3 + rational(1.5),
format(’˜50f˜n’, [A]).
2.83333333333333333333333333333333333333333333333333
A = 17 rdiv 6
SWI-Prolog 6.6 Reference Manual

4.27. ARITHMETIC
159
Arithmetic Functions
Arithmetic functions are terms which are evaluated by the arithmetic predicates described in sec-
tion 4.27.2. There are four types of arguments to functions:
Expr
Arbitrary expression, returning either a ﬂoating point value or an
integer.
IntExpr
Arbitrary expression that must evaluate to an integer.
RatExpr
Arbitrary expression that must evaluate to a rational number.
FloatExpr
Arbitrary expression that must evaluate to a ﬂoating point.
For systems using bounded integer arithmetic (default is unbounded, see section 4.27.2 for de-
tails), integer operations that would cause overﬂow automatically convert to ﬂoating point arithmetic.
SWI-Prolog provides many extensions to the set of ﬂoating point functions deﬁned by the ISO
standard. The current policy is to provide such functions on ‘as-needed’ basis if the function is widely
supported elsewhere and notably if it is part of the C99 mathematical library. In addition, we try to
maintain compatibility with YAP.
- +Expr
[ISO]
Result = −Expr
+ +Expr
[ISO]
Result = Expr.
Note that if + is followed by a number, the parser discards the +.
I.e.
?- integer(+1) succeeds.
+Expr1 + +Expr2
[ISO]
Result = Expr1 + Expr2
+Expr1 - +Expr2
[ISO]
Result = Expr1 −Expr2
+Expr1 * +Expr2
[ISO]
Result = Expr1 × Expr2
+Expr1 / +Expr2
[ISO]
Result = Expr1
Expr2. If the ﬂag iso is true, both arguments are converted to ﬂoat and the return
value is a ﬂoat. Otherwise (default), if both arguments are integers the operation returns an
integer if the division is exact. If at least one of the arguments is rational and the other argument
is integer, the operation returns a rational number. In all other cases the return value is a ﬂoat.
See also ///2 and rdiv/2.
+IntExpr1 mod +IntExpr2
[ISO]
Modulo, deﬁned as Result = IntExpr1 - (IntExpr1 div IntExpr2) × IntExpr2, where div is
ﬂoored division.
+IntExpr1 rem +IntExpr2
[ISO]
Remainder
of
integer
division.
Behaves
as
if
deﬁned
by
Result is IntExpr1 - (IntExpr1 // IntExpr2) × IntExpr2
SWI-Prolog 6.6 Reference Manual

160
CHAPTER 4. BUILT-IN PREDICATES
+IntExpr1 // +IntExpr2
[ISO]
Integer division,
deﬁned as Result is rndI(Expr1/Expr2).
The function rndI is the
default
rounding
used
by
the
C
compiler
and
available
through
the
Prolog
ﬂag
integer rounding function.
In the C99 standard,
C-rounding is deﬁned as
towards zero.55
div(+IntExpr1, +IntExpr2)
[ISO]
Integer division, deﬁned as Result is (IntExpr1 - IntExpr1 mod IntExpr2) // IntExpr2. In other
words, this is integer division that rounds towards -inﬁnity. This function guarantees behaviour
that is consistent with mod/2, i.e., the following holds for every pair of integers X, Y where
Y =\= 0.
Q is div(X, Y),
M is mod(X, Y),
X =:= Y*Q+M.
+RatExpr rdiv +RatExpr
Rational number division. This function is only available if SWI-Prolog has been compiled
with rational number support. See section 4.27.2 for details.
+IntExpr1 gcd +IntExpr2
Result is the greatest common divisor of IntExpr1, IntExpr2.
abs(+Expr)
[ISO]
Evaluate Expr and return the absolute value of it.
sign(+Expr)
[ISO]
Evaluate to -1 if Expr < 0, 1 if Expr > 0 and 0 if Expr = 0. If Expr evaluates to a ﬂoat, the
return value is a ﬂoat (e.g., -1.0, 0.0 or 1.0). In particular, note that sign(-0.0) evaluates to 0.0.
See also copysign/1
copysign(+Expr1, +Expr2)
[ISO]
Evaluate to X, where the absolute value of X equals the absolute value of Expr1 and the sign of
X matches the sign of Expr2. This function is based on copysign() from C99, which works on
double precision ﬂoats and deals with handling the sign of special ﬂoating point values such as
-0.0. Our implementation follows C99 if both arguments are ﬂoats. Otherwise, copysign/1
evaluates to Expr1 if the sign of both expressions matches or -Expr1 if the signs do not match.
Here, we use the extended notion of signs for ﬂoating point numbers, where the sign of -0.0
and other special ﬂoats is negative.
max(+Expr1, +Expr2)
[ISO]
Evaluate to the larger of Expr1 and Expr2. Both arguments are compared after converting to
the same type, but the return value is in the original type. For example, max(2.5, 3) compares
the two values after converting to ﬂoat, but returns the integer 3.
min(+Expr1, +Expr2)
[ISO]
Evaluate to the smaller of Expr1 and Expr2. See max/2 for a description of type handling.
55Future versions might guarantee rounding towards zero.
SWI-Prolog 6.6 Reference Manual

4.27. ARITHMETIC
161
.(+Int, [])
A list of one element evaluates to the element. This implies "a" evaluates to the character code
of the letter ‘a’ (97) using the traditional mapping of double quoted string to a list of character
codes. Arithmetic evaluation also translates a string object (see section 4.24) of one character
length into the character code for that character. This implies that expression "a" also works
of the Prolog ﬂag double quotes is set to string. The recommended way to specify the
character code of the letter ‘a’ is 0’a.
random(+IntExpr)
Evaluate to a random integer i for which 0 ≤i < IntExpr. The system has two implemen-
tations. If it is compiled with support for unbounded arithmetic (default) it uses the GMP
library random functions. In this case, each thread keeps its own random state. The default
algorithm is the Mersenne Twister algorithm. The seed is set when the ﬁrst random number in
a thread is generated. If available, it is set from /dev/random. Otherwise it is set from the
system clock. If unbounded arithmetic is not supported, random numbers are shared between
threads and the seed is initialised from the clock when SWI-Prolog was started. The predicate
set random/1 can be used to control the random number generator.
random ﬂoat
Evaluate to a random ﬂoat I for which 0.0 < i < 1.0. This function shares the random state with
random/1. All remarks with the function random/1 also apply for random float/0.
Note that both sides of the domain are open. This avoids evaluation errors on, e.g., log/1 or
//2 while no practical application can expect 0.0.56
round(+Expr)
[ISO]
Evaluate Expr and round the result to the nearest integer.
integer(+Expr)
Same as round/1 (backward compatibility).
ﬂoat(+Expr)
[ISO]
Translate the result to a ﬂoating point number. Normally, Prolog will use integers whenever
possible. When used around the 2nd argument of is/2, the result will be returned as a ﬂoating
point number. In other contexts, the operation has no effect.
rational(+Expr)
Convert the Expr to a rational number or integer. The function returns the input on integers
and rational numbers.
For ﬂoating point numbers, the returned rational number exactly
represents the ﬂoat. As ﬂoats cannot exactly represent all decimal numbers the results may be
surprising. In the examples below, doubles can represent 0.25 and the result is as expected, in
contrast to the result of rational(0.1). The function rationalize/1 remedies this. See
section 4.27.2 for more information on rational number support.
?- A is rational(0.25).
56Richard O’Keefe said: “If you are generating IEEE doubles with the claimed uniformity, then 0 has a 1 in 253 =
1in9, 007, 199, 254, 740, 992 chance of turning up. No program that expects [0.0,1.0) is going to be surprised when 0.0
fails to turn up in a few millions of millions of trials, now is it? But a program that expects (0.0,1.0) could be devastated if
0.0 did turn up.”
SWI-Prolog 6.6 Reference Manual

162
CHAPTER 4. BUILT-IN PREDICATES
A is 1 rdiv 4
?- A is rational(0.1).
A = 3602879701896397 rdiv 36028797018963968
rationalize(+Expr)
Convert the Expr to a rational number or integer. The function is similar to rational/1,
but the result is only accurate within the rounding error of ﬂoating point numbers, generally
producing a much smaller denominator.57
?- A is rationalize(0.25).
A = 1 rdiv 4
?- A is rationalize(0.1).
A = 1 rdiv 10
ﬂoat fractional part(+Expr)
[ISO]
Fractional part of a ﬂoating point number.
Negative if Expr is negative, rational
if Expr is rational and 0 if Expr is integer.
The following relation is always true:
Xisfloatfractionalpart(X) + floatintegerpart(X).
ﬂoat integer part(+Expr)
[ISO]
Integer part of ﬂoating point number. Negative if Expr is negative, Expr if Expr is integer.
truncate(+Expr)
[ISO]
Truncate Expr to an integer. If Expr ≥0 this is the same as floor(Expr). For Expr < 0 this is
the same as ceil(Expr). That is, truncate/1 rounds towards zero.
ﬂoor(+Expr)
[ISO]
Evaluate Expr and return the largest integer smaller or equal to the result of the evaluation.
ceiling(+Expr)
[ISO]
Evaluate Expr and return the smallest integer larger or equal to the result of the evaluation.
ceil(+Expr)
Same as ceiling/1 (backward compatibility).
+IntExpr1 >> +IntExpr2
[ISO]
Bitwise shift IntExpr1 by IntExpr2 bits to the right. The operation performs arithmetic shift,
which implies that the inserted most signiﬁcant bits are copies of the original most signiﬁcant
bits.
+IntExpr1 << +IntExpr2
[ISO]
Bitwise shift IntExpr1 by IntExpr2 bits to the left.
+IntExpr1 \/ +IntExpr2
[ISO]
Bitwise ‘or’ IntExpr1 and IntExpr2.
57The names rational/1 and rationalize/1 as well as their semantics are inspired by Common Lisp.
SWI-Prolog 6.6 Reference Manual

4.27. ARITHMETIC
163
+IntExpr1 /\ +IntExpr2
[ISO]
Bitwise ‘and’ IntExpr1 and IntExpr2.
+IntExpr1 xor +IntExpr2
[ISO]
Bitwise ‘exclusive or’ IntExpr1 and IntExpr2.
\ +IntExpr
[ISO]
Bitwise negation. The returned value is the one’s complement of IntExpr.
sqrt(+Expr)
[ISO]
Result = √Expr
sin(+Expr)
[ISO]
Result = sin Expr. Expr is the angle in radians.
cos(+Expr)
[ISO]
Result = cos Expr. Expr is the angle in radians.
tan(+Expr)
[ISO]
Result = tan Expr. Expr is the angle in radians.
asin(+Expr)
[ISO]
Result = arcsin Expr. Result is the angle in radians.
acos(+Expr)
[ISO]
Result = arccos Expr. Result is the angle in radians.
atan(+Expr)
[ISO]
Result = arctan Expr. Result is the angle in radians.
atan2(+YExpr, +XExpr)
[ISO]
Result = arctan YExpr
XExpr. Result is the angle in radians. The return value is in the range
[−π . . . π]. Used to convert between rectangular and polar coordinate system.
atan(+YExpr, +XExpr)
Same as atan2/2 (backward compatibility).
sinh(+Expr)
Result = sinh Expr. The hyperbolic sine of X is deﬁned as eX−e−X
2
.
cosh(+Expr)
Result = cosh Expr. The hyperbolic cosine of X is deﬁned as eX+e−X
2
.
tanh(+Expr)
Result = tanh Expr. The hyperbolic tangent of X is deﬁned as sinh X
cosh X .
asinh(+Expr)
Result = arcsinh(Expr) (inverse hyperbolic sine).
acosh(+Expr)
Result = arccosh(Expr) (inverse hyperbolic cosine).
SWI-Prolog 6.6 Reference Manual

164
CHAPTER 4. BUILT-IN PREDICATES
atanh(+Expr)
Result = arctanh(Expr). (inverse hyperbolic tangent).
log(+Expr)
[ISO]
Natural logarithm. Result = ln Expr
log10(+Expr)
Base-10 logarithm. Result = lg Expr
exp(+Expr)
[ISO]
Result = eExpr
+Expr1 ** +Expr2
[ISO]
Result = Expr1Expr2. The result is a ﬂoat, unless SWI-Prolog is compiled with unbounded in-
teger support and the inputs are integers and produce an integer result. The integer expressions
0I, 1I and −1I are guaranteed to work for any integer I. Other integer base values generate a
resource error if the result does not ﬁt in memory.
The ISO standard demands a ﬂoat result for all inputs and introduces ˆ/2 for integer expo-
nentiation. The function float/1 can be used on one or both arguments to force a ﬂoating
point result. Note that casting the input result in a ﬂoating point computation, while casting the
output performs integer exponentiation followed by a conversion to ﬂoat.
+Expr1 ˆ +Expr2
[ISO]
In SWI-Prolog, ˆ/2 is equivalent to **/2. The ISO version is similar, except that it produces
a evaluation error if both Expr1 and Expr2 are integers and the result is not an integer. The
table below illustrates the behaviour of the exponentiation functions in ISO and SWI.
Expr1
Expr2
Function
SWI
ISO
Int
Int
**/2
Int or Float
Float
Int
Float
**/2
Float
Float
Float
Int
**/2
Float
Float
Float
Float
**/2
Float
Float
Int
Int
ˆ/2
Int or Float
Int or error
Int
Float
ˆ/2
Float
Float
Float
Int
ˆ/2
Float
Float
Float
Float
ˆ/2
Float
Float
powm(+IntExprBase, +IntExprExp, +IntExprMod)
Result = (IntExprBaseIntExprExp) modulo IntExprMod. Only available when compiled with
unbounded integer support.
This formula is required for Difﬁe-Hellman key-exchange, a
technique where two parties can establish a secret key over a public network.
lgamma(+Expr)
Return the natural logarithm of the absolute value of the Gamma function.58
58Some interfaces also provide the sign of the Gamma function. We canot do that in an arithmetic function. Future
versions may provide a predicate lgamma/3 that returns both the value and the sign.
SWI-Prolog 6.6 Reference Manual

4.28. MISC ARITHMETIC SUPPORT PREDICATES
165
erf(+Expr)
WikipediA: “In mathematics, the error function (also called the Gauss error function) is a
special function (non-elementary) of sigmoid shape which occurs in probability, statistics and
partial differential equations.”
erfc(+Expr)
WikipediA: “The complementary error function.”
pi
[ISO]
Evaluate to the mathematical constant π (3.14159...).
e
Evaluate to the mathematical constant e (2.71828...).
epsilon
Evaluate to the difference between the ﬂoat 1.0 and the ﬁrst larger ﬂoating point number.
cputime
Evaluate to a ﬂoating point number expressing the CPU time (in seconds) used by Prolog up till
now. See also statistics/2 and time/1.
eval(+Expr)
Evaluate Expr. Although ISO standard dictates that ‘A=1+2, B is A’ works and uniﬁes B to 3,
it is widely felt that source level variables in arithmetic expressions should have been limited
to numbers. In this view the eval function can be used to evaluate arbitrary expressions.59
Bitvector functions
The functions below are not covered by the standard. The msb/1 function is
compatible with hProlog. The others are private extensions that improve handling of —unbounded—
integers as bit-vectors.
msb(+IntExpr)
Return the largest integer N such that (IntExpr >> N) /\ 1 =:= 1. This is the (zero-
origin) index of the most signiﬁcant 1 bit in the value of IntExpr, which must evaluate to a
positive integer. Errors for 0, negative integers, and non-integers.
lsb(+IntExpr)
Return the smallest integer N such that (IntExpr >> N) /\ 1 =:= 1.
This is the
(zero-origin) index of the least signiﬁcant 1 bit in the value of IntExpr, which must evaluate to
a positive integer. Errors for 0, negative integers, and non-integers.
popcount(+IntExpr)
Return the number of 1s in the binary representation of the non-negative integer IntExpr.
4.28
Misc arithmetic support predicates
set random(+Option)
Controls the random number generator accessible through the functions random/1 and
random float/0. Note that the library random provides an alternative API to the same
random primitives.
59The eval/1 function was ﬁrst introduced by ECLiPSe and is under consideration for YAP.
SWI-Prolog 6.6 Reference Manual

166
CHAPTER 4. BUILT-IN PREDICATES
seed(+Seed)
Set the seed of the random generator for this thread. Seed is an integer or the atom
random. If random, repeat the initialization procedure described with the function
random/1. Here is an example:
?- set_random(seed(111)), A is random(6).
A = 5.
?- set_random(seed(111)), A is random(6).
A = 5.
state(+State)
Set the generator to a state fetched using the state property of random property/1.
Using other values may lead to undeﬁned behaviour.60
random property(?Option)
True when Option is a current property of the random generator. Currently, this predicate
provides access to the state.
This predicate is not present on systems where the state is
inaccessible.
state(-State)
Describes the current state of the random generator. State is a normal Prolog term that can
be asserted or written to a ﬁle. Applications should make no other assumptions about its
representation. The only meaningful operation is to use as argument to set random/1
using the state(State) option.61
current arithmetic function(?Head)
True when Head is an evaluable function. For example:
?- current_arithmetic_function(sin(_)).
true.
4.29
Built-in list operations
Most list operations are deﬁned in the library lists described in section A.12. Some that are imple-
mented with more low-level primitives are built-in and described here.
is list(+Term)
True if Term is bound to the empty list ([]) or a term with functor ‘.’ and arity 2 and the
second argument is a list.62 This predicate acts as if deﬁned by the deﬁnition below on acyclic
terms. The implementation fails safely if Term represents a cyclic list.
60The limitations of the underlying (GMP) library are unknown, which makes it impossible to validate the State.
61BUG: GMP provides no portable mechanism to fetch and restore the state. The current implementation works, but the
state depends on the platform. I.e., it is generally not possible to reuse the state with another version of GMP or on a CPU
with different datasizes or endian-ness.
62In versions before 5.0.1, is list/1 just checked for [] or [ | ] and proper list/1 had the role of the current
is list/1. The current deﬁnition conforms to the de facto standard. Assuming proper coding standards, there should
only be very few cases where a quick-and-dirty is list/1 is a good choice. Richard O’Keefe pointed at this issue.
SWI-Prolog 6.6 Reference Manual

4.29. BUILT-IN LIST OPERATIONS
167
is_list(X) :-
var(X), !,
fail.
is_list([]).
is_list([_|T]) :-
is_list(T).
memberchk(?Elem, +List)
[]
True when Elem is an element of List. This ‘chk’ variant of member/2 is semi deterministic
and typically used to test membership of a list. Raises a type error if scanning List encounters
a non-list. Note that memberchk/2 does not perform a full list typecheck. For example,
memberchk(a, [a|b]) succeeds without error and memberchk/2 loops on a cyclic list
if Elem is not a member of List.
length(?List, ?Int)
[ISO]
True if Int represents the number of elements in List. This predicate is a true relation and
can be used to ﬁnd the length of a list or produce a list (holding variables) of length Int. The
predicate is non-deterministic, producing lists of increasing length if List is a partial list and
Int is unbound. It raises errors if
• Int is bound to a non-integer.
• Int is a negative integer.
• List is neither a list nor a partial list. This error condition includes cyclic lists.63
This predicate fails if the tail of List is equivalent to Int (e.g., length(L,L)).64
sort(+List, -Sorted)
[ISO]
True if Sorted can be uniﬁed with a list holding the elements of List, sorted to the standard
order of terms (see section 4.7). Duplicates are removed. The implementation is in C, using
natural merge sort.65
The sort/2 predicate can sort a cyclic list, returning a non-cyclic
version with the same elements.
msort(+List, -Sorted)
Equivalent to sort/2, but does not remove duplicates. Raises a type error if List is a
cyclic list or not a list.
keysort(+List, -Sorted)
[ISO]
Sort a list of pairs. List must be a list of Key-Value pairs, terms whose principal functor is (-)/2.
List is sorted on Key according to the standard order of terms (see section 4.7.1). Duplicates are
not removed. Sorting is stable with regard to the order of the Values, i.e., the order of multiple
elements that have the same Key is not changed.
63ISO demands failure here. We think an error is more appropriate.
64This is logically correct. An exception would be more appropriate, but to our best knowledge, current practice in Prolog
does not describe a suitable candidate exception term.
65Contributed by Richard O’Keefe.
SWI-Prolog 6.6 Reference Manual

168
CHAPTER 4. BUILT-IN PREDICATES
The keysort/2 predicate is often used together with library pairs. It can be used to sort
lists on different or multiple criteria. For example, the following predicates sorts a list of atoms
according to their length, maintaining the initial order for atoms that have the same length.
:- use_module(library(pairs)).
sort_atoms_by_length(Atoms, ByLength) :-
map_list_to_pairs(atom_length, Atoms, Pairs),
keysort(Pairs, Sorted),
pairs_values(Sorted, ByLength).
predsort(+Pred, +List, -Sorted)
Sorts
similar
to
sort/2,
but
determines
the
order
of
two
terms
by
calling
Pred(-Delta, +E1, +E2).
This call must unify Delta with one of <, > or =.
If the built-
in predicate compare/3 is used, the result is the same as sort/2. See also keysort/2.
4.30
Finding all Solutions to a Goal
ﬁndall(+Template, :Goal, -Bag)
[ISO]
Create a list of the instantiations Template gets successively on backtracking over Goal and
unify the result with Bag. Succeeds with an empty list if Goal has no solutions. findall/3
is equivalent to bagof/3 with all free variables bound with the existential operator (ˆ), except
that bagof/3 fails when Goal has no solutions.
ﬁndall(+Template, :Goal, -Bag, +Tail)
As findall/3, but returns the result as the difference list Bag-Tail. The 3-argument version
is deﬁned as
findall(Templ, Goal, Bag) :-
findall(Templ, Goal, Bag, [])
bagof(+Template, :Goal, -Bag)
[ISO]
Unify Bag with the alternatives of Template. If Goal has free variables besides the one sharing
with Template, bagof/3 will backtrack over the alternatives of these free variables, unifying
Bag with the corresponding alternatives of Template. The construct +VarˆGoal tells bagof/3
not to bind Var in Goal. bagof/3 fails if Goal has no solutions.
The example below illustrates bagof/3 and the ˆ operator. The variable bindings are printed
together on one line to save paper.
2 ?- listing(foo).
foo(a, b, c).
foo(a, b, d).
foo(b, c, e).
foo(b, c, f).
foo(c, c, g).
SWI-Prolog 6.6 Reference Manual

4.31. FORALL
169
true.
3 ?- bagof(C, foo(A, B, C), Cs).
A = a, B = b, C = G308, Cs = [c, d] ;
A = b, B = c, C = G308, Cs = [e, f] ;
A = c, B = c, C = G308, Cs = [g].
4 ?- bagof(C, Aˆfoo(A, B, C), Cs).
A = G324, B = b, C = G326, Cs = [c, d] ;
A = G324, B = c, C = G326, Cs = [e, f, g].
5 ?-
setof(+Template, +Goal, -Set)
[ISO]
Equivalent to bagof/3, but sorts the result using sort/2 to get a sorted list of alternatives
without duplicates.
4.31
Forall
forall(:Cond, :Action)
[semidet]
For all alternative bindings of Cond, Action can be proven. The example veriﬁes that all arith-
metic statements in the given list are correct. It does not say which is wrong if one proves
wrong.
?- forall(member(Result = Formula, [2 = 1 + 1, 4 = 2 * 2]),
Result =:= Formula).
The predicate forall/2 is implemented as \+ ( Cond, \+ Action), i.e., There is
no instantiation of Cond for which Action is false.. The use of double negation implies that
forall/2 does not change any variable bindings. It proves a relation. The forall/2 con-
trol structure can be used for its side-effects. E.g., the following asserts relations in a list into
the dynamic database:
?- forall(member(Child-Parent), ChildPairs),
assertz(child_of(Child, Parent))).
Using forall/2 as forall(Generator, SideEffect) is preferred over the classical failure
driven loop as shown below because it makes it explicit which part of the construct is the
generator and which part creates the side effects. Also, unexpected failure of the side effect
causes the construct to fail. Failure makes it evident that there is an issue with the code, while
a failure driven loop would succeed with an erroneous result.
...,
(
Generator,
SideEffect,
SWI-Prolog 6.6 Reference Manual

170
CHAPTER 4. BUILT-IN PREDICATES
fail
;
true
)
If your intent is to create variable bindings, the forall/2 control structure is inadequate.
Possibly you are looking for maplist/2, findall/3 or foreach/2.
4.32
Formatted Write
The current version of SWI-Prolog provides two formatted write predicates. The ‘writef’ family
(writef/1, writef/2, swritef/3), is compatible with Edinburgh C-Prolog and should be con-
sidered deprecated. The ‘format’ family (format/1, format/2, format/3), was deﬁned by
Quintus Prolog and currently available in many Prolog systems, although the details vary.
4.32.1
Writef
writef(+Atom)
[deprecated]
Equivalent to writef(Atom, []). See writef/2 for details.
writef(+Format, +Arguments)
[deprecated]
Formatted write. Format is an atom whose characters will be printed. Format may contain
certain special character sequences which specify certain formatting and substitution actions.
Arguments provides all the terms required to be output.
Escape sequences to generate a single special character:
\n
Output a newline character (see also nl/[0,1])
\l
Output a line separator (same as \n)
\r
Output a carriage return character (ASCII 13)
\t
Output the ASCII character TAB (9)
\\
The character \ is output
\%
The character % is output
\nnn
where ⟨nnn⟩is an integer (1-3 digits); the character with
code ⟨nnn⟩is output (NB : ⟨nnn⟩is read as decimal)
Note that \l, \nnn and \\ are interpreted differently when character escapes are in effect. See
section 2.15.1.
Escape sequences to include arguments from Arguments. Each time a % escape sequence is
found in Format the next argument from Arguments is formatted according to the speciﬁcation.
SWI-Prolog 6.6 Reference Manual

4.32. FORMATTED WRITE
171
%t
print/1 the next item (mnemonic: term)
%w
write/1 the next item
%q
writeq/1 the next item
%d
Write
the
term,
ignoring
operators.
See
also
write term/2.
Mnemonic:
old
Edinburgh
display/1
%p
print/1 the next item (identical to %t)
%n
Put the next item as a character (i.e., it is a character code)
%r
Write the next item N times where N is the second item
(an integer)
%s
Write the next item as a String (so it must be a list of char-
acters)
%f
Perform a ttyflush/0 (no items used)
%Nc
Write the next item Centered in N columns
%Nl
Write the next item Left justiﬁed in N columns
%Nr
Write the next item Right justiﬁed in N columns. N is a
decimal number with at least one digit. The item must be
an atom, integer, ﬂoat or string.
swritef(-String, +Format, +Arguments)
[deprecated]
Equivalent to writef/2, but “writes” the result on String instead of the current output stream.
Example:
?- swritef(S, ’%15L%w’, [’Hello’, ’World’]).
S = "Hello
World"
swritef(-String, +Format)
[deprecated]
Equivalent to swritef(String, Format, []).
4.32.2
Format
The format family of predicates is the most versatile and portable66 way to produce textual output.
format(+Format)
Deﬁned as ‘format(Format) :- format(Format, []).’. See format/2 for de-
tails.
format(+Format, :Arguments)
Format is an atom, list of character codes, or a Prolog string. Arguments provides the arguments
required by the format speciﬁcation. If only one argument is required and this single argument
is not a list, the argument need not be put in a list. Otherwise the arguments are put in a list.
66Unfortunately not covered by any standard.
SWI-Prolog 6.6 Reference Manual

172
CHAPTER 4. BUILT-IN PREDICATES
Special sequences start with the tilde (˜), followed by an optional numeric argument, option-
ally followed by a colon modiﬁer (:), 67 followed by a character describing the action to be
undertaken. A numeric argument is either a sequence of digits, representing a positive decimal
number, a sequence ‘⟨character⟩, representing the character code value of the character (only
useful for ˜t) or a asterisk (*), in which case the numeric argument is taken from the next argu-
ment of the argument list, which should be a positive integer. E.g., the following three examples
all pass 46 (.) to ˜t:
?- format(’˜w ˜46t ˜w˜72|˜n’, [’Title’, ’Page’]).
?- format(’˜w ˜‘.t ˜w˜72|˜n’, [’Title’, ’Page’]).
?- format(’˜w ˜*t ˜w˜72|˜n’, [’Title’, 46, ’Page’]).
Numeric conversion (d, D, e, E, f, g and G) accept an arithmetic expression as argument. This
is introduced to handle rational numbers transparently (see section 4.27.2). The ﬂoating point
conversions allow for unlimited precision for printing rational numbers in decimal form. E.g.,
the following will write as many 3’s as you want by changing the ‘70’.
?- format(’˜50f’, [10 rdiv 3]).
3.33333333333333333333333333333333333333333333333333
˜ Output the tilde itself.
a Output the next argument, which must be an atom. This option is equivalent to w, except
that it requires the argument to be an atom.
c Interpret the next argument as a character code and add it to the output. This argument
must be a valid Unicode character code. Note that the actually emitted bytes are deﬁned by
the character encoding of the output stream and an exception may be raised if the output
stream is not capable of representing the requested Unicode character. See section 2.18.1
for details.
d Output next argument as a decimal number. It should be an integer. If a numeric argument
is speciﬁed, a dot is inserted argument positions from the right (useful for doing ﬁxed
point arithmetic with integers, such as handling amounts of money).
The colon modiﬁer (e.g., ˜:d) causes the number to be printed according to the locale of
the output stream. See section 4.22.
D Same as d, but makes large values easier to read by inserting a comma every three digits
left or right of the dot. This is the same as ˜:d, but using the ﬁxed English locale.
e Output next argument as a ﬂoating point number in exponential notation. The numeric
argument speciﬁes the precision. Default is 6 digits. Exact representation depends on the
C library function printf(). This function is invoked with the format %.⟨precision⟩e.
E Equivalent to e, but outputs a capital E to indicate the exponent.
f Floating point in non-exponential notation. The numeric argument deﬁnes the number of
digits right of the decimal point. If the colon modiﬁer (:) is used, the ﬂoat is formatted
using conventions from the current locale, which may deﬁne the decimal point as well as
grouping of digits left of the decimal point.
67The colon modiﬁers is a SWI-Prolog extension, proposed by Richard O’Keefe.
SWI-Prolog 6.6 Reference Manual

4.32. FORMATTED WRITE
173
g Floating point in e or f notation, whichever is shorter.
G Floating point in E or f notation, whichever is shorter.
i Ignore next argument of the argument list. Produces no output.
I Emit a decimal number using Prolog digit grouping (the underscore, _). The argument
describes the size of each digit group. The default is 3. See also section 2.15.1. For
example:
?- A is 1<<100, format(’˜10I’, [A]).
1_2676506002_2822940149_6703205376
k Give the next argument to write canonical/1.
n Output a newline character.
N Only output a newline if the last character output on this stream was not a newline. Not
properly implemented yet.
p Give the next argument to print/1.
q Give the next argument to writeq/1.
r Print integer in radix numeric argument notation. Thus ˜16r prints its argument hex-
adecimal. The argument should be in the range [2, . . . , 36]. Lowercase letters are used for
digits above 9. The colon modiﬁer may be used to form locale-speciﬁc digit groups.
R Same as r, but uses uppercase letters for digits above 9.
s Output text from a list of character codes or a string (see string/1 and section 4.24)
from the next argument.68
@ Interpret the next argument as a goal and execute it.
Output written to the
current output stream is inserted at this place. Goal is called in the module calling
format/3. This option is not present in the original deﬁnition by Quintus, but supported
by some other Prolog systems.
t All remaining space between 2 tab stops is distributed equally over ˜t statements between
the tab stops. This space is padded with spaces by default. If an argument is supplied, it
is taken to be the character code of the character used for padding. This can be used to do
left or right alignment, centering, distributing, etc. See also ˜| and ˜+ to set tab stops. A
tab stop is assumed at the start of each line.
| Set a tab stop on the current position. If an argument is supplied set a tab stop on the
position of that argument. This will cause all ˜t’s to be distributed between the previous
and this tab stop.
+ Set a tab stop (as ˜|) relative to the last tab stop or the beginning of the line if no tab
stops are set before the ˜+. This constructs can be used to ﬁll ﬁelds. The partial format
sequence below prints an integer right-aligned and padded with zeros in 6 columns. The
. . . sequences in the example illustrate that the integer is aligned in 6 columns regardless
of the remainder of the format speciﬁcation.
format(’...˜|˜‘0t˜d˜6+...’, [..., Integer, ...])
w Give the next argument to write/1.
68The s modiﬁer also accepts an atom for compatibility. This is deprecated due to the ambiguity of [].
SWI-Prolog 6.6 Reference Manual

174
CHAPTER 4. BUILT-IN PREDICATES
W Give
the
next
two
arguments
to
write term/2.
For
example,
format(’˜W’, [Term, [numbervars(true)]]). This option is SWI-Prolog
speciﬁc.
Example:
simple_statistics :-
<obtain statistics>
% left to the user
format(’˜tStatistics˜t˜72|˜n˜n’),
format(’Runtime: ˜‘.t ˜2f˜34|
Inferences: ˜‘.t ˜D˜72|˜n’,
[RunT, Inf]),
....
will output
Statistics
Runtime: .................. 3.45
Inferences: .......... 60,345
format(+Output, +Format, :Arguments)
As format/2, but write the output on the given Output. The de-facto standard only allows
Output to be a stream.
The SWI-Prolog implementation allows all valid arguments for
with output to/2.69 For example:
?- format(atom(A), ’˜D’, [1000000]).
A = ’1,000,000’
4.32.3
Programming Format
format predicate(+Char, +Head)
If a sequence ˜c (tilde, followed by some character) is found, the format/3 and friends
ﬁrst check whether the user has deﬁned a predicate to handle the format. If not, the built-in
formatting rules described above are used. Char is either a character code or a one-character
atom, specifying the letter to be (re)deﬁned. Head is a term, whose name and arity are used
to determine the predicate to call for the redeﬁned formatting character. The ﬁrst argument
to the predicate is the numeric argument of the format command, or the atom default if
no argument is speciﬁed. The remaining arguments are ﬁlled from the argument list. The
example below deﬁnes ˜T to print a timestamp in ISO8601 format (see format time/3).
The subsequent block illustrates a possible call.
:- format_predicate(’T’, format_time(_Arg,_Time)).
format_time(_Arg, Stamp) :-
69Earlier versions deﬁned sformat/3. These predicates have been moved to the library backcomp.
SWI-Prolog 6.6 Reference Manual

4.33. TERMINAL CONTROL
175
must_be(number, Stamp),
format_time(current_output, ’%FT%T%z’, Stamp).
?- get_time(Now),
format(’Now, it is ˜T˜n’, [Now]).
Now, it is 2012-06-04T19:02:01+0200
Now = 1338829321.6620328.
current format predicate(?Code, ?:Head)
True when ˜Code is handled by the user-deﬁned predicate speciﬁed by Head.
4.33
Terminal Control
The following predicates form a simple access mechanism to the Unix termcap library to provide
terminal-independent I/O for screen terminals. These predicates are only available on Unix machines.
The SWI-Prolog Windows console accepts the ANSI escape sequences.
tty get capability(+Name, +Type, -Result)
Get the capability named Name from the termcap library. See termcap(5) for the capability
names. Type speciﬁes the type of the expected result, and is one of string, number or
bool. String results are returned as an atom, number results as an integer, and bool results as
the atom on or off. If an option cannot be found, this predicate fails silently. The results are
only computed once. Successive queries on the same capability are fast.
tty goto(+X, +Y)
Goto position (X, Y) on the screen.
Note that the predicates line count/2 and
line position/2 will not have a well-deﬁned behaviour while using this predicate.
tty put(+Atom, +Lines)
Put an atom via the termcap library function tputs(). This function decodes padding information
in the strings returned by tty get capability/3 and should be used to output these
strings. Lines is the number of lines affected by the operation, or 1 if not applicable (as in
almost all cases).
tty size(-Rows, -Columns)
Determine the size of the terminal. Platforms:
Unix If the system provides ioctl calls for this, these are used and tty size/2 properly re-
ﬂects the actual size after a user resize of the window. As a fallback, the system uses
tty get capability/3 using li and co capabilities. In this case the reported size
reﬂects the size at the ﬁrst call and is not updated after a user-initiated resize of the termi-
nal.
Windows Getting the size of the terminal is provided for swipl-win.exe. The requested
value reﬂects the current size. For the multithreaded version the console that is associated
with the user input stream is used.
SWI-Prolog 6.6 Reference Manual

176
CHAPTER 4. BUILT-IN PREDICATES
4.34
Operating System Interaction
shell(+Command, -Status)
Execute Command on the operating system. Command is given to the Bourne shell (/bin/sh).
Status is uniﬁed with the exit status of the command.
On Windows, shell/[1,2] executes the command using the CreateProcess() API and waits
for the command to terminate. If the command ends with a & sign, the command is handed to
the WinExec() API, which does not wait for the new task to terminate. See also win exec/2
and win shell/2. Please note that the CreateProcess() API does not imply the Windows
command interpreter (cmd.exe and therefore commands that are built in the command inter-
preter can only be activated using the command interpreter. For example, a ﬁle can be compied
using the command below.
?- shell(’cmd.exe /C copy file1.txt file2.txt’).
Note that many of the operations that can be achieved using the shell built-in commands can
easily be achieved using Prolog primitives. See make directory/1, delete file/1,
rename file/2, etc. The clib package provides filesex, implementing various high level
ﬁle operations such as copy file/2. Using Prolog primitives instead of shell commands
improves the portability of your program.
The library process provides process create/3 and several related primitives that sup-
port more ﬁne-grained interaction with processes, including I/O redirection and management of
asynchronous processes.
shell(+Command)
Equivalent to ‘shell(Command, 0)’.
shell
Start an interactive Unix shell. Default is /bin/sh; the environment variable SHELL overrides
this default. Not available for Win32 platforms.
getenv(+Name, -Value)
Get environment variable. Fails silently if the variable does not exist. Please note that environ-
ment variable names are case-sensitive on Unix systems and case-insensitive on Windows.
setenv(+Name, +Value)
Set an environment variable. Name and Value must be instantiated to atoms or integers. The en-
vironment variable will be passed to shell/[0-2] and can be requested using getenv/2.
They also inﬂuence expand file name/2.
Environment variables are shared between
threads. Depending on the underlying C library, setenv/2 and unsetenv/1 may not be
thread-safe and may cause memory leaks. Only changing the environment once and before
starting threads is safe in all versions of SWI-Prolog.
unsetenv(+Name)
Remove an environment variable from the environment. Some systems lack the underlying
unsetenv() library function. On these systems unsetenv/1 sets the variable to the empty
string.
SWI-Prolog 6.6 Reference Manual

4.34. OPERATING SYSTEM INTERACTION
177
setlocale(+Category, -Old, +New)
Set/Query the locale setting which tells the C library how to interpret text ﬁles, write num-
bers, dates, etc.
Category is one of all, collate, ctype, messages, monetary,
numeric or time. For details, please consult the C library locale documentation. See also
section 2.18.1. Please note that the locale is shared between all threads and thread-safe usage
of setlocale/3 is in general not possible. Do locale operations before starting threads or
thoroughly study threading aspects of locale support in your environment before using in multi-
threaded environments. Locale settings are used by format time/3, collation key/2
and locale sort/2.
unix(+Command)
This predicate comes from the Quintus compatibility library and provides a partial imple-
mentation thereof. It provides access to some operating system features and unlike the name
suggests, is not operating system speciﬁc. Deﬁned Command’s are below.
system(+Command)
Equivalent to calling shell/1. Use for compatibility only.
shell(+Command)
Equivalent to calling shell/1. Use for compatibility only.
shell
Equivalent to calling shell/0. Use for compatibility only.
cd
Equivalent
to
calling
working directory/2
to
the
expansion
(see
expand file name/2) of ˜. For compatibility only.
cd(+Directory)
Equivalent to calling working directory/2. Use for compatibility only.
argv(-Argv)
Unify Argv with the list of command line arguments provided to this Prolog run. Please
note that Prolog system arguments and application arguments are separated by --.
Integer arguments are passed as Prolog integers, ﬂoat arguments and Prolog ﬂoating
point numbers and all other arguments as Prolog atoms. New applications should use the
Prolog ﬂag argv. See also the Prolog ﬂag argv.
A stand-alone program could use the following skeleton to handle command line argu-
ments. See also section 2.10.2.
main :-
current_prolog_flag(argv, Argv),
append(_PrologArgs, [--|AppArgs], Argv), !,
main(AppArgs).
4.34.1
Windows-speciﬁc Operating System Interaction
The predicates in this section are only available on the Windows version of SWI-Prolog. Their use is
discouraged if there are portably alternatives. For example, win exec/2 and will shell/2 can
often be replaced by the more portable shell/2 or the more powerful process create/3.
SWI-Prolog 6.6 Reference Manual

178
CHAPTER 4. BUILT-IN PREDICATES
win exec(+Command, +Show)
Windows only. Spawns a Windows task without waiting for its completion. Show is one
of the Win32 SW * constants written in lowercase without the SW *: hide maximize
minimize
restore
show
showdefault
showmaximized
showminimized
showminnoactive showna shownoactive shownormal. In addition, iconic is a
synonym for minimize and normal for shownormal.
win shell(+Operation, +File, +Show)
Windows only. Opens the document File using the Windows shell rules for doing so. Operation
is one of open, print or explore or another operation registered with the shell for the
given document type. On modern systems it is also possible to pass a URL as File, opening the
URL in Windows default browser. This call interfaces to the Win32 API ShellExecute(). The
Show argument determines the initial state of the opened window (if any). See win exec/2
for deﬁned values.
win shell(+Operation, +File)
Same as win shell(Operation, File, normal)
win registry get value(+Key, +Name, -Value)
Windows only. Fetches the value of a Windows registry key. Key is an atom formed as a
path name describing the desired registry key. Name is the desired attribute name of the key.
Value is uniﬁed with the value. If the value is of type DWORD, the value is returned as an
integer. If the value is a string, it is returned as a Prolog atom. Other types are currently
not supported.
The default ‘root’ is HKEY CURRENT USER. Other roots can be speciﬁed
explicitly as HKEY CLASSES ROOT, HKEY CURRENT USER, HKEY LOCAL MACHINE
or HKEY USERS. The example below fetches the extension to use for Prolog ﬁles (see
README.TXT on the Windows version):
?- win_registry_get_value(
’HKEY_LOCAL_MACHINE/Software/SWI/Prolog’,
fileExtension,
Ext).
Ext = pl
win folder(?Name, -Directory)
True if Name is the Windows ‘CSIDL’ of Directory. If Name is unbound, all known Windows
special paths are generated.
Name is the CSIDL after deleting the leading CSIDL
and
mapping the constant to lowercase.
Check the Windows documentation for the function
SHGetSpecialFolderPath() for a description of the deﬁned constants. This example extracts the
‘My Documents’ folder:
?- win_folder(personal, MyDocuments).
MyDocuments = ’C:/Documents and Settings/jan/My Documents’
SWI-Prolog 6.6 Reference Manual

4.34. OPERATING SYSTEM INTERACTION
179
win add dll directory(+AbsDir)
This predicate adds a directory to the search path for dependent DLL ﬁles. If possible, this
is achieved with win add dll directory/2.
Otherwise, %PATH% is extended with
the provided directory.
AbsDir may be speciﬁed in the Prolog canonical syntax.
See
prolog to os filename/2.
Note that use foreign library/1 passes an abso-
lute path to the DLL if the destination DLL can be located from the speciﬁcation using
absolute file name/3.
win add dll directory(+AbsDir, -Cookie)
This predicate adds a directory to the search path for dependent DLL ﬁles. If the call is success-
ful it uniﬁes Cookie with a handle that must be passed to win remove dll directory/1
to remove the directory from the search path. Error conditions:
• This predicate is available in the Windows port of SWI-Prolog starting from 6.3.8/6.2.6.
• This predicate fails if Windows does not yet support the underlying primitives. These are
available in recently patched Windows 7 systems and later.
• This predicate throws an acception if the provided path is invalid or the underlying Win-
dows API returns an error.
If
open shared object/2
is
passed
an
absolute
path
to
a
DLL
on
a
Win-
dows
installation
that
supports
AddDllDirectory()
and
friends,70
SWI-Prolog
uses
LoadLibraryEx()
with
the
ﬂags
LOAD LIBRARY SEARCH DLL LOAD DIR
and
LOAD LIBRARY SEARCH DEFAULT DIRS. In this scenario, directories from %PATH%
and not searched. Additional directories can be added using win add dll directory/2.
win remove dll directory(-Cookie)
Remove a DLL search directory installed using win add dll directory/2.
4.34.2
Dealing with time and date
Representing time in a computer system is surprisingly complicated. There are a large number of
time representations in use, and the correct choice depends on factors such as compactness, resolution
and desired operations. Humans tend to think about time in hours, days, months, years or centuries.
Physicists think about time in seconds. But, a month does not have a deﬁned number of seconds.
Even a day does not have a deﬁned number of seconds as sometimes a leap-second is introduced to
synchronise properly with our earth’s rotation. At the same time, resolution demands a range from
better than pico-seconds to millions of years. Finally, civilizations have a wide range of calendars.
Although there exist libraries dealing with most if this complexity, our desire to keep Prolog clean and
lean stops us from fully supporting these.
For human-oriented tasks, time can be broken into years, months, days, hours, minutes, seconds
and a timezone. Physicists prefer to have time in an arithmetic type representing seconds or frac-
tion thereof, so basic arithmetic deals with comparison and durations. An additional advantage of
the physicist’s approach is that it requires much less space. For these reasons, SWI-Prolog uses an
arithmetic type as its prime time representation.
Many C libraries deal with time using ﬁxed-point arithmetic, dealing with a large but ﬁnite time
interval at constant resolution. In our opinion, using a ﬂoating point number is a more natural choice
70Windows 7 with up-to-date patches or Windows 8.
SWI-Prolog 6.6 Reference Manual

180
CHAPTER 4. BUILT-IN PREDICATES
as we can use a natural unit and the interface does not need to be changed if a higher resolution is
required in the future. Our unit of choice is the second as it is the scientiﬁc unit.71 We have placed
our origin at 1970-1-1T0:0:0Z for compatibility with the POSIX notion of time as well as with older
time support provided by SWI-Prolog.
Where older versions of SWI-Prolog relied on the POSIX conversion functions, the current im-
plementation uses libtai to realise conversion between time-stamps and calendar dates for a period of
10 million years.
Time and date data structures
We use the following time representations
TimeStamp
A TimeStamp is a ﬂoating point number expressing the time in seconds since the Epoch at
1970-1-1.
date(Y,M,D,H,Mn,S,Off,TZ,DST)
We call this term a date-time structure. The ﬁrst 5 ﬁelds are integers expressing the year,
month (1..12), day (1..31), hour (0..23) and minute (0..59). The S ﬁeld holds the seconds as a
ﬂoating point number between 0.0 and 60.0. Off is an integer representing the offset relative to
UTC in seconds, where positive values are west of Greenwich. If converted from local time
(see stamp date time/3), TZ holds the name of the local timezone. If the timezone is not
known, TZ is the atom -. DST is true if daylight saving time applies to the current time,
false if daylight saving time is relevant but not effective, and - if unknown or the timezone
has no daylight saving time.
date(Y,M,D)
Date using the same values as described above. Extracted using date time value/3.
time(H,Mn,S)
Time using the same values as described above. Extracted using date time value/3.
Time and date predicates
get time(-TimeStamp)
Return the current time as a TimeStamp.
The granularity is system-dependent.
See sec-
tion 4.34.2.
stamp date time(+TimeStamp, -DateTime, +TimeZone)
Convert a TimeStamp to a DateTime in the given timezone. See section 4.34.2 for details on
the data types. TimeZone describes the timezone for the conversion. It is one of local to
extract the local time, ’UTC’ to extract a UTC time or an integer describing the seconds west
of Greenwich.
date time stamp(+DateTime, -TimeStamp)
Compute the timestamp from a date/9 term. Values for month, day, hour, minute or second
need not be normalized. This ﬂexibility allows for easy computation of the time at any given
71Using Julian days is a choice made by the Eclipse team. As conversion to dates is needed for a human readable notation
of time and Julian days cannot deal naturally with leap seconds, we decided for the second as our unit.
SWI-Prolog 6.6 Reference Manual

4.34. OPERATING SYSTEM INTERACTION
181
number of these units from a given timestamp. Normalization can be achieved following this
call with stamp date time/3. This example computes the date 200 days after 2006-7-14:
?- date_time_stamp(date(2006,7,214,0,0,0,0,-,-), Stamp),
stamp_date_time(Stamp, D, 0),
date_time_value(date, D, Date).
Date = date(2007, 1, 30)
When computing a time stamp from a local time speciﬁcation, the UTC offset (arg 7), TZ (arg 8)
and DST (arg 9) argument may be left unbound and are uniﬁed with the proper information.
The example below, executed in Amsterdam, illustrates this behaviour. On the 25th of March
at 01:00, DST does not apply. At 02.00, the clock is advanced by one hour and thus both 02:00
and 03:00 represent the same time stamp.
1 ?- date_time_stamp(date(2012,3,25,1,0,0,UTCOff,TZ,DST),
Stamp).
UTCOff = -3600,
TZ = ’CET’,
DST = false,
Stamp = 1332633600.0.
2 ?- date_time_stamp(date(2012,3,25,2,0,0,UTCOff,TZ,DST),
Stamp).
UTCOff = -7200,
TZ = ’CEST’,
DST = true,
Stamp = 1332637200.0.
3 ?- date_time_stamp(date(2012,3,25,3,0,0,UTCOff,TZ,DST),
Stamp).
UTCOff = -7200,
TZ = ’CEST’,
DST = true,
Stamp = 1332637200.0.
Note that DST and offset calculation are based on the POSIX function mktime(). If mktime()
returns an error, a representation error dst is generated.
date time value(?Key, +DateTime, ?Value)
Extract values from a date/9 term. Provided keys are:
SWI-Prolog 6.6 Reference Manual

182
CHAPTER 4. BUILT-IN PREDICATES
key
value
year
Calendar year as an integer
month
Calendar month as an integer 1..12
day
Calendar day as an integer 1..31
hour
Clock hour as an integer 0..23
minute
Clock minute as an integer 0..59
second
Clock second as a ﬂoat 0.0..60.0
utc offset
Offset to UTC in seconds (positive is west)
time zone
Name of timezone; fails if unknown
daylight saving
Bool (true) if dst is in effect
date
Term date(Y,M,D)
time
Term time(H,M,S)
format time(+Out, +Format, +StampOrDateTime)
Modelled after POSIX strftime(), using GNU extensions. Out is a destination as speciﬁed with
with output to/2. Format is an atom or string with the following conversions. Conver-
sions start with a tilde (%) character.72 StampOrDateTime is either a numeric time-stamp, a
term date(Y,M,D,H,M,S,O,TZ,DST) or a term date(Y,M,D).
a The abbreviated weekday name according to the current locale. Use format time/4
for POSIX locale.
A The full weekday name according to the current locale. Use format time/4 for POSIX
locale.
b The abbreviated month name according to the current locale. Use format time/4 for
POSIX locale.
B The full month name according to the current locale. Use format time/4 for POSIX
locale.
c The preferred date and time representation for the current locale.
C The century number (year/100) as a 2-digit integer.
d The day of the month as a decimal number (range 01 to 31).
D Equivalent to %m/%d/%y. (For Americans only. Americans should note that in other
countries %d/%m/%y is rather common. This means that in an international context this
format is ambiguous and should not be used.)
e Like %d, the day of the month as a decimal number, but a leading zero is replaced by a
space.
E Modiﬁer. Not implemented.
f Number of microseconds. The f can be preﬁxed by an integer to print the desired number
of digits. E.g., %3f prints milliseconds. This format is not covered by any standard, but
available with different format speciﬁers in various incarnations of the strftime() function.
F Equivalent to %Y-%m-%d (the ISO 8601 date format).
g Like %G, but without century, i.e., with a 2-digit year (00-99).
72Descriptions taken from Linux Programmer’s Manual
SWI-Prolog 6.6 Reference Manual

4.34. OPERATING SYSTEM INTERACTION
183
G The ISO 8601 year with century as a decimal number. The 4-digit year corresponding to
the ISO week number (see %V). This has the same format and value as %y, except that if
the ISO week number belongs to the previous or next year, that year is used instead.
V The ISO 8601:1988 week number of the current year as a decimal number, range 01 to
53, where week 1 is the ﬁrst week that has at least 4 days in the current year, and with
Monday as the ﬁrst day of the week. See also %U and %W.
h Equivalent to %b.
H The hour as a decimal number using a 24-hour clock (range 00 to 23).
I The hour as a decimal number using a 12-hour clock (range 01 to 12).
j The day of the year as a decimal number (range 001 to 366).
k The hour (24-hour clock) as a decimal number (range 0 to 23); single digits are preceded
by a blank. (See also %H.)
l The hour (12-hour clock) as a decimal number (range 1 to 12); single digits are preceded
by a blank. (See also %I.)
m The month as a decimal number (range 01 to 12).
M The minute as a decimal number (range 00 to 59).
n A newline character.
O Modiﬁer to select locale-speciﬁc output. Not implemented.
p Either ‘AM’ or ‘PM’ according to the given time value, or the corresponding strings for
the current locale. Noon is treated as ‘pm’ and midnight as ‘am’.
P Like %p but in lowercase: ‘am’ or ‘pm’ or a corresponding string for the current locale.
r The time in a.m. or p.m. notation. In the POSIX locale this is equivalent to ‘%I:%M:%S
%p’.
R The time in 24-hour notation (%H:%M). For a version including the seconds, see %T
below.
s The number of seconds since the Epoch, i.e., since 1970-01-01 00:00:00 UTC.
S The second as a decimal number (range 00 to 60). (The range is up to 60 to allow for
occasional leap seconds.)
t A tab character.
T The time in 24-hour notation (%H:%M:%S).
u The day of the week as a decimal, range 1 to 7, Monday being 1. See also %w.
U The week number of the current year as a decimal number, range 00 to 53, starting with
the ﬁrst Sunday as the ﬁrst day of week 01. See also %V and %W.
w The day of the week as a decimal, range 0 to 6, Sunday being 0. See also %u.
W The week number of the current year as a decimal number, range 00 to 53, starting with
the ﬁrst Monday as the ﬁrst day of week 01.
x The preferred date representation for the current locale without the time.
X The preferred time representation for the current locale without the date.
y The year as a decimal number without a century (range 00 to 99).
SWI-Prolog 6.6 Reference Manual

184
CHAPTER 4. BUILT-IN PREDICATES
Y The year as a decimal number including the century.
z The timezone as hour offset from GMT using the format HHmm.
Required to emit
RFC822-conforming dates (using ’%a, %d %b %Y %T %z’). Our implementation
supports %:z, which modiﬁes the output to HH:mm as required by XML-Schema. Note
that both notations are valid in ISO 8601. The sequence %:z is compatible to the GNU
date(1) command.
Z The timezone or name or abbreviation.
+ The date and time in date(1) format.
% A literal ‘%’ character.
The table below gives some format strings for popular time representations.
RFC1123
is used by HTTP. The full implementation of http timestamp/2 as available from
http/http header is here.
http_timestamp(Time, Atom) :-
stamp_date_time(Time, Date, ’UTC’),
format_time(atom(Atom),
’%a, %d %b %Y %T GMT’,
Date, posix).
Standard
Format string
xsd
’%FT%T%:z’
ISO8601
’%FT%T%z’
RFC822
’%a, %d %b %Y %T %z’
RFC1123
’%a, %d %b %Y %T GMT’
format time(+Out, +Format, +StampOrDateTime, +Locale)
Format time given a speciﬁed Locale. This predicate is a work-around for lacking proper
portable and thread-safe time and locale handling in current C libraries.
In its current
implementation the only value allowed for Locale is posix, which currently only modiﬁes
the behaviour of the a, A, b and B format speciﬁers. The predicate is used to be able to emit
POSIX locale week and month names for emitting standardised time-stamps such as RFC1123.
parse time(+Text, -Stamp)
Same as parse time(Text, Format, Stamp). See parse time/3.
parse time(+Text, ?Format, -Stamp)
Parse a textual time representation, producing a time-stamp. Supported formats for Text are
in the table below. If the format is known, it may be given to reduce parse time and avoid
ambiguities. Otherwise, Format is uniﬁed with the format encountered.
SWI-Prolog 6.6 Reference Manual

4.34. OPERATING SYSTEM INTERACTION
185
Name
Example
rfc 1123
Fri, 08 Dec 2006 15:29:44 GMT
iso 8601
2006-12-08T17:29:44+02:00
20061208T172944+0200
2006-12-08T15:29Z
2006-12-08
20061208
2006-12
2006-W49-5
2006-342
day of the week(+Date,-DayOfTheWeek)
Computes the day of the week for a given date. Date = date(Year,Month,Day). Days of
the week are numbered from one to seven: Monday = 1, Tuesday = 2, ..., Sunday = 7.
4.34.3
Controlling the swipl-win.exe console window
The Windows executable swipl-win.exe console has a number of predicates to control the appear-
ance of the console. Being totally non-portable, we do not advise using it for your own application,
but use XPCE or another portable GUI platform instead. We give the predicates for reference here.
window title(-Old, +New)
Unify Old with the title displayed in the console and change the title to New.73
win window pos(+ListOfOptions)
Interface to the MS-Windows SetWindowPos() function, controlling size, position and stacking
order of the window. ListOfOptions is a list that may hold any number of the terms below:
size(W, H)
Change the size of the window. W and H are expressed in character units.
position(X, Y)
Change the top-left corner of the window. The values are expressed in pixel units.
zorder(ZOrder)
Change the location in the window stacking order. Values are bottom, top, topmost
and notopmost. Topmost windows are displayed above all other windows.
show(Bool)
If true, show the window, if false hide the window.
activate
If present, activate the window.
win has menu
True if win insert menu/2 and win insert menu item/4 are present.
win insert menu(+Label, +Before)
Insert a new entry (pulldown) in the menu. If the menu already contains this entry, nothing is
73BUG: This predicate should have been called win window title for consistent naming.
SWI-Prolog 6.6 Reference Manual

186
CHAPTER 4. BUILT-IN PREDICATES
done. The Label is the label and, using the Windows convention, a letter preﬁxed with & is
underlined and deﬁnes the associated accelerator key. Before is the label before which this one
must be inserted. Using - adds the new entry at the end (right). For example, the call below
adds an Application entry just before the Help menu.
win_insert_menu(’&Application’, ’&Help’)
win insert menu item(+Pulldown, +Label, +Before, :Goal)
Add an item to the named Pulldown menu.
Label and Before are handled as in
win insert menu/2, but the label - inserts a separator.
Goal is called if the user
selects the item.
4.35
File System Interaction
access ﬁle(+File, +Mode)
True if File exists and can be accessed by this Prolog process under mode Mode. Mode is one
of the atoms read, write, append, exist, none or execute. File may also be the name
of a directory. Fails silently otherwise. access file(File, none) simply succeeds
without testing anything.
If Mode is write or append, this predicate also succeeds if the ﬁle does not exist and the
user has write access to the directory of the speciﬁed location.
exists ﬁle(+File)
True if File exists and is a regular ﬁle. This does not imply the user has read and/or write
permission for the ﬁle.
ﬁle directory name(+File, -Directory)
Extracts the directory part of File. The returned Directory name does not end in /. There
are two special cases. The directory name of / is / itself, and the directory name is . if File
does not contain any / characters. See also directory file path/3 from filesex.
The system ensures that for every valid Path using the Prolog (POSIX) directory separators,
following is true on systems with a sound implementation of same file/2.74
See also
prolog to os filename/2.
...,
file_directory_name(Path, Dir),
file_base_name(Path, File),
directory_file_path(Dir, File, Path2),
same_file(Path, Path2).
ﬁle base name(+File, -BaseName)
Extracts the ﬁlename part from a path speciﬁcation. If File does not contain any directory
separators, File is returned in BaseName. See also file directory name/2.
74On some systems, Path and Path2 refer to the same entry in the ﬁle system, but same file/2 may fail.
SWI-Prolog 6.6 Reference Manual

4.35. FILE SYSTEM INTERACTION
187
same ﬁle(+File1, +File2)
True if both ﬁlenames refer to the same physical ﬁle. That is, if File1 and File2 are the same
string or both names exist and point to the same ﬁle (due to hard or symbolic links and/or
relative vs. absolute paths). On systems that provide stat() with meaningful values for st dev
and st inode, same file/2 is implemented by comparing the device and inode identiﬁers.
On Windows, same file/2 compares the strings returned by the GetFullPathName() system
call.
exists directory(+Directory)
True if Directory exists and is a directory. This does not imply the user has read, search or
write permission for the directory.
delete ﬁle(+File)
Remove File from the ﬁle system.
rename ﬁle(+File1, +File2)
Rename File1 as File2. The semantics is compatible to the POSIX semantics of the rename()
system call as far as the operating system allows.
Notably, if File2 exists, the operation
succeeds (except for possible permission errors) and is atomic (meaning there is no window
where File2 does not exist).
size ﬁle(+File, -Size)
Unify Size with the size of File in bytes.
time ﬁle(+File, -Time)
Unify the last modiﬁcation time of File with Time. Time is a ﬂoating point number expressing
the seconds elapsed since Jan 1, 1970. See also convert time/[2,8] and get time/1.
absolute ﬁle name(+File, -Absolute)
Expand a local ﬁlename into an absolute path.
The absolute path is canonicalised: refer-
ences to . and .. are deleted.
This predicate ensures that expanding a ﬁlename re-
turns the same absolute path regardless of how the ﬁle is addressed.
SWI-Prolog uses
absolute ﬁlenames to register source ﬁles independent of the current working direc-
tory.
See also absolute file name/3.
See also absolute file name/3 and
expand file name/2.
absolute ﬁle name(+Spec, -Absolute, +Options)
Convert the given ﬁle speciﬁcation into an absolute path. Spec is a term Alias(Relative) (e.g.,
(library(lists)), a relative ﬁlename or an absolute ﬁlename. The primary intention of
this predicate is to resolve ﬁles speciﬁed as Alias(Relative). Option is a list of options to guide
the conversion:
extensions(ListOfExtensions)
List
of
ﬁle
extensions
to
try.
Default
is
’’.
For
each
extension,
absolute file name/3 will ﬁrst add the extension and then verify the condi-
tions imposed by the other options. If the condition fails, the next extension on the list is
tried. Extensions may be speciﬁed both as .ext or plain ext.
relative to(+FileOrDir)
Resolve the path relative to the given directory or the directory holding the given
SWI-Prolog 6.6 Reference Manual

188
CHAPTER 4. BUILT-IN PREDICATES
ﬁle.
Without this option, paths are resolved relative to the working directory (see
working directory/2) or, if Spec is atomic and absolute file name/[2,3]
is executed in a directive, it uses the current source ﬁle as reference.
access(Mode)
Imposes the condition access ﬁle(File, Mode). Mode is one of read, write, append,
execute, exist or none. See also access file/2.
ﬁle type(Type)
Deﬁnes extensions. Current mapping: txt implies [’’], prolog implies [’.pl’,
’’], executable implies [’.so’, ’’], qlf implies [’.qlf’, ’’] and
directory implies [’’]. The ﬁle type source is an alias for prolog for com-
patibility with SICStus Prolog. See also prolog file type/2. This predicate only
returns non-directories, unless the option file type(directory) is speciﬁed.
ﬁle errors(fail/error)
If error (default), throw an existence error exception if the ﬁle cannot be found.
If fail, stay silent.75
solutions(ﬁrst/all)
If first (default), the predicate leaves no choice point. Otherwise a choice point will be
left and backtracking may yield more solutions.
expand(true/false)
If true (default is false) and Spec is atomic, call expand file name/2 followed
by member/2 on Spec before proceeding. This is a SWI-Prolog extension.
The Prolog ﬂag verbose file search can be set to true to help debugging Prolog’s
search for ﬁles.
This predicate is derived from Quintus Prolog. In Quintus Prolog, the argument order was
absolute file name(+Spec, +Options, -Path). The argument order has been changed for
compatibility with ISO and SICStus. The Quintus argument order is still accepted.
is absolute ﬁle name(+File)
True if File speciﬁes an absolute path name. On Unix systems, this implies the path starts
with a ‘/’.
For Microsoft-based systems this implies the path starts with ⟨letter⟩:.
This
predicate is intended to provide platform-independent checking for absolute paths. See also
absolute file name/2 and prolog to os filename/2.
ﬁle name extension(?Base, ?Extension, ?Name)
This predicate is used to add, remove or test ﬁlename extensions. The main reason for its
introduction is to deal with different ﬁlename properties in a portable manner. If the ﬁle system
is case-insensitive, testing for an extension will also be done case-insensitive. Extension may
be speciﬁed with or without a leading dot (.). If an Extension is generated, it will not have a
leading dot.
directory ﬁles(+Directory, -Entries)
Unify Entries with a list of entries in Directory. Each member of Entries is an atom denoting an
75Silent operation was the default up to version 3.2.6.
SWI-Prolog 6.6 Reference Manual

4.35. FILE SYSTEM INTERACTION
189
entry relative to Directory. Entries contains all entries, including hidden ﬁles and, if supplied
by the OS, the special entries . and ... See also expand file name/2.76
expand ﬁle name(+WildCard, -List)
Unify List with a sorted list of ﬁles or directories matching WildCard. The normal Unix wild-
card constructs ‘?’, ‘*’, ‘[...]’ and ‘{...}’ are recognised. The interpretation of ‘{...}’
is slightly different from the C shell (csh(1)). The comma-separated argument can be arbitrary
patterns, including ‘{...}’ patterns. The empty pattern is legal as well: ‘\{.pl,\}’ matches
either ‘.pl’ or the empty string.
If the pattern contains wildcard characters, only existing ﬁles and directories are returned. Ex-
panding a ‘pattern’ without wildcard characters returns the argument, regardless of whether or
not it exists.
Before expanding wildcards, the construct $var is expanded to the value of the environment
variable var, and a possible leading ˜ character is expanded to the user’s home directory.77
prolog to os ﬁlename(?PrologPath, ?OsPath)
Convert between the internal Prolog path name conventions and the operating system path
name conventions. The internal conventions follow the POSIX standard, which implies that
this predicate is equivalent to =/2 (unify) on POSIX (e.g., Unix) systems. On Windows systems
it changes the directory separator from \ into /.
read link(+File, -Link, -Target)
If File points to a symbolic link, unify Link with the value of the link and Target to the ﬁle the
link is pointing to. Target points to a ﬁle, directory or non-existing entry in the ﬁle system, but
never to a link. Fails if File is not a link. Fails always on systems that do not support symbolic
links.
tmp ﬁle(+Base, -TmpName)
[deprecated]
Create a name for a temporary ﬁle. Base is an identiﬁer for the category of ﬁle. The TmpName
is guaranteed to be unique.
If the system halts, it will automatically remove all created
temporary ﬁles. Base is used as part of the ﬁnal ﬁlename. Portable applications should limit
themselves to alphanumeric characters.
Because it is possible to guess the generated ﬁlename, attackers may create the ﬁlesystem entry
as a link and possibly create a security issue. New code should use tmp file stream/3.
tmp ﬁle stream(+Encoding, -FileName, -Stream)
Create a temporary ﬁlename FileName and open it for writing in the given Encoding. Encoding
is a text-encoding name or binary. Stream is the output stream. If the OS supports it, the
created ﬁle is only accessible to the current user. If the OS supports it, the ﬁle is created using
the open()-ﬂag O EXCL, which guarantees that the ﬁle did not exist before this call. This
predicate is a safe replacement of tmp file/2. Note that in those cases where the temporary
ﬁle is needed to store output from an external command, the ﬁle must be closed ﬁrst. E.g., the
76This predicate should be considered a misnomer because it returns entries rather than ﬁles. We stick to this name for
compatibility with, e.g., SICStus, Ciao and YAP.
77On Windows, the home directory is determined as follows: if the environment variable HOME exists, this is used. If
the variables HOMEDRIVE and HOMEPATH exist (Windows-NT), these are used. At initialisation, the system will set the
environment variable HOME to point to the SWI-Prolog home directory if neither HOME nor HOMEPATH and HOMEDRIVE
are deﬁned.
SWI-Prolog 6.6 Reference Manual

190
CHAPTER 4. BUILT-IN PREDICATES
following downloads a ﬁle from a URL to a temporary ﬁle and opens the ﬁle for reading (on
Unix systems you can delete the ﬁle for cleanup after opening it for reading):
open_url(URL, In) :-
tmp_file_stream(text, File, Stream),
close(Stream),
process_create(curl, [’-o’, File, URL], []),
open(File, read, In),
delete_file(File).
% Unix-only
Temporary ﬁles created using this call are removed if the Prolog process terminates. Calling
delete file/1 using FileName removes the ﬁle and removes the entry from the adminis-
tration of ﬁles-to-be-deleted.
make directory(+Directory)
Create a new directory (folder) on the ﬁlesystem. Raises an exception on failure. On Unix
systems, the directory is created with default permissions (deﬁned by the process umask
setting).
delete directory(+Directory)
Delete directory (folder) from the ﬁlesystem. Raises an exception on failure. Please note that
in general it will not be possible to delete a non-empty directory.
working directory(-Old, +New)
Unify Old with an absolute path to the current working directory and change working directory
to New. Use the pattern working directory(CWD, CWD) to get the current directory. See
also absolute file name/2 and chdir/1.78 Note that the working directory is shared
between all threads.
chdir(+Path)
Compatibility predicate. New code should use working directory/2.
4.36
User Top-level Manipulation
break
Recursively start a new Prolog top level. This Prolog top level has its own stacks, but shares
the heap with all break environments and the top level. Debugging is switched off on entering a
break and restored on leaving one. The break environment is terminated by typing the system’s
end-of-ﬁle character (control-D). If the -t toplevel command line option is given, this
goal is started instead of entering the default interactive top level (prolog/0).
abort
Abort the Prolog execution and restart the top level. If the -t toplevel command line
option is given, this goal is started instead of entering the default interactive top level.
78BUG: Some of the ﬁle I/O predicates use local ﬁlenames. Changing directory while ﬁle-bound streams are open causes
wrong results on telling/1, seeing/1 and current stream/3.
SWI-Prolog 6.6 Reference Manual

4.36. USER TOP-LEVEL MANIPULATION
191
Aborting is implemented by throwing the reserved exception ’$aborted’. This exception
can be caught using catch/3, but the recovery goal is wrapped with a predicate that prunes
the choice points of the recovery goal (i.e., as once/1) and re-throws the exception. This is
illustrated in the example below, where we press control-C and ‘a’.
?- catch((repeat,fail), E, true).
ˆCAction (h for help) ? abort
% Execution Aborted
halt
[ISO]
Terminate Prolog execution. This is the same as halt(0). See halt/1 for details.
halt(+Status)
[ISO]
Terminate Prolog execution with Status. This predicate calls PL halt() which preforms the
following steps:
1. Set the Prolog ﬂag exit status to Status.
2. Call all hooks registered using at halt/1. If Status equals 0 (zero), any of these hooks
calls cancel halt/1, termination is cancelled.
3. Call all hooks registered using PL at halt(). In the future, if any of these hooks returns
non-zero, termination will be cancelled. Currently, this only prints a warning.
4. Perform the following system cleanup actions:
• Cancel all threads, calling thread at exit/1 registered termination hooks.
Threads not responding within 1 second are cancelled forcefully.
• Flush I/O and close all streams except for standard I/O.
• Reset the terminal if its properties were changed.
• Remove temporary ﬁles and incomplete compilation output.
• Reclaim memory.
5. Call exit(Status) to terminate the process
prolog
This goal starts the default interactive top level. Queries are read from the stream user input.
See also the Prolog ﬂag history. The prolog/0 predicate is terminated (succeeds) by
typing the end-of-ﬁle character (typically control-D).
The following two hooks allow for expanding queries and handling the result of a query. These
hooks are used by the top level variable expansion mechanism described in section 2.8.
expand query(+Query, -Expanded, +Bindings, -ExpandedBindings)
Hook in module user, normally not deﬁned. Query and Bindings represents the query read
from the user and the names of the free variables as obtained using read term/3. If this
predicate succeeds, it should bind Expanded and ExpandedBindings to the query and bindings
to be executed by the top level. This predicate is used by the top level (prolog/0). See also
expand answer/2 and term expansion/2.
SWI-Prolog 6.6 Reference Manual

192
CHAPTER 4. BUILT-IN PREDICATES
expand answer(+Bindings, -ExpandedBindings)
Hook in module user, normally not deﬁned. Expand the result of a successfully executed
top-level query.
Bindings is the query ⟨Name⟩= ⟨Value⟩binding list from the query.
ExpandedBindings must be uniﬁed with the bindings the top level should print.
4.37
Creating a Protocol of the User Interaction
SWI-Prolog offers the possibility to log the interaction with the user on a ﬁle.79 All Prolog interaction,
including warnings and tracer output, are written to the protocol ﬁle.
protocol(+File)
Start protocolling on ﬁle File. If there is already a protocol ﬁle open, then close it ﬁrst. If File
exists it is truncated.
protocola(+File)
Equivalent to protocol/1, but does not truncate the File if it exists.
noprotocol
Stop making a protocol of the user interaction. Pending output is ﬂushed on the ﬁle.
protocolling(-File)
True if a protocol was started with protocol/1 or protocola/1 and uniﬁes File with the
current protocol output ﬁle.
4.38
Debugging and Tracing Programs
This section is a reference to the debugger interaction predicates. A more use-oriented overview of
the debugger is in section 2.9.
If you have installed XPCE, you can use the graphical front-end of the tracer. This front-end is
installed using the predicate guitracer/0.
trace
Start the tracer. trace/0 itself cannot be seen in the tracer. Note that the Prolog top level
treats trace/0 special; it means ‘trace the next goal’.
tracing
True if the tracer is currently switched on. tracing/0 itself cannot be seen in the tracer.
notrace
Stop the tracer. notrace/0 itself cannot be seen in the tracer.
guitracer
Installs hooks (see prolog trace interception/4) into the system that redirect tracing
information to a GUI front-end providing structured access to variable bindings, graphical
overview of the stack and highlighting of relevant source code.
noguitracer
Revert back to the textual tracer.
79A similar facility was added to Edinburgh C-Prolog by Wouter Jansweijer.
SWI-Prolog 6.6 Reference Manual

4.38. DEBUGGING AND TRACING PROGRAMS
193
trace(+Pred)
Equivalent to trace(Pred, +all).
trace(+Pred, +Ports)
Put a trace point on all predicates satisfying the predicate speciﬁcation Pred. Ports is a list
of port names (call, redo, exit, fail). The atom all refers to all ports. If the port is
preceded by a - sign, the trace point is cleared for the port. If it is preceded by a +, the trace
point is set.
The predicate trace/2 activates debug mode (see debug/0). Each time a port (of the 4-
port model) is passed that has a trace point set, the goal is printed as with trace/0. Unlike
trace/0, however, the execution is continued without asking for further information. Exam-
ples:
?- trace(hello).
Trace all ports of hello with any arity in any mod-
ule.
?- trace(foo/2, +fail).
Trace failures of foo/2 in any module.
?- trace(bar/1, -all).
Stop tracing bar/1.
The predicate debugging/0 shows all currently deﬁned trace points.
notrace(:Goal)
Call Goal, but suspend the debugger while Goal is executing. The current implementation cuts
the choice points of Goal after successful completion. See once/1. Later implementations
may have the same semantics as call/1.
debug
Start debugger. In debug mode, Prolog stops at spy and trace points, disables last-call optimi-
sation and aggressive destruction of choice points to make debugging information accessible.
Implemented by the Prolog ﬂag debug.
Note that the min free parameter of all stacks is enlarged to 8 K cells if debug-
ging is switched off in order to avoid excessive GC. GC complicates tracing because
it renames the
G⟨NNN⟩variables and replaces unreachable variables with the atom
\bnfmeta{garbage_collected}. Calling nodebug/0 does not reset the initial free-
margin because several parts of the top level and debugger disable debugging of system code
regions. See also set prolog stack/2.
nodebug
Stop debugger. Implemented by the Prolog ﬂag debug. See also debug/0.
debugging
Print debug status and spy points on current output stream. See also the Prolog ﬂag debug.
spy(+Pred)
Put a spy point on all predicates meeting the predicate speciﬁcation Pred. See section 4.5.
nospy(+Pred)
Remove spy point from all predicates meeting the predicate speciﬁcation Pred.
SWI-Prolog 6.6 Reference Manual

194
CHAPTER 4. BUILT-IN PREDICATES
nospyall
Remove all spy points from the entire program.
leash(?Ports)
Set/query leashing (ports which allow for user interaction). Ports is one of +Name, -Name,
?Name or a list of these. +Name enables leashing on that port, -Name disables it and ?Name
succeeds or fails according to the current setting. Recognised ports are call, redo, exit,
fail and unify. The special shorthand all refers to all ports, full refers to all ports
except for the unify port (default). half refers to the call, redo and fail port.
visible(+Ports)
Set the ports shown by the debugger. See leash/1 for a description of the Ports speciﬁcation.
Default is full.
unknown(-Old, +New)
Edinburgh-Prolog compatibility predicate, interfacing to the ISO Prolog ﬂag unknown. Val-
ues are trace (meaning error) and fail.
If the unknown ﬂag is set to warning,
unknown/2 reports the value as trace.
style check(+Spec)
Modify/query style checking options. Spec is one of the terms below or a list of these.
• +Style enables a style check
• -Style disables a style check
• ?(Style) queries a style check (note the brackets). If Style is unbound, all active style check
options are returned on backtracking.
Loading a ﬁle using load files/2 or one of its derived predicates reset the style checking
options to their value before loading the ﬁle, scoping the option to the remainder of the ﬁle and
all ﬁles loaded after changing the style checking.
singleton(true)
The predicate read clause/3 (used by the compiler to read source code) warns on
variables appearing only once in a term (clause) which have a name not starting with an
underscore. See section 2.15.1 for details on variable handling and warnings.
no effect(true)
This warning is generated by the compiler for BIPs (built-in predicates) that are inlined
by the compiler and for which the compiler can prove that they are meaningless. An
example is using ==/2 against a not-yet-initialised variable as illustrated in the example
below. This comparison is always false.
always_false(X) :-
X == Y,
write(Y).
var branches(false)
Veriﬁes that if a variable is introduced in a branch and used after the branch, it is in-
troduced in all branches. This code aims at bugs following the skeleton below, where
p(Next) may be called with Next unbound.
SWI-Prolog 6.6 Reference Manual

4.39. OBTAINING RUNTIME STATISTICS
195
p(Arg) :-
(
Cond
-> Next = value1
;
true
),
p(Next).
If a variable V is intended to be left unbound, one can use V= . This construct is removed
by the compiler and thus has no implications for the performance of your program.
This check was suggested together with semantic singleton checking. The SWI-Prolog
libraries contain about a hundred clauses that are triggered by this style check. Unlike
semantic singleton analysis, only a tiny fraction of these clauses proofed faulty. In most
cases, the branches failing to bind the variable fail or raise an exception or the caller
handles the case where the variable is unbound. The status of this style check is unclear. It
might be removed in the future or it might be enhanced with a deeper analysis to be more
precise.
atom(true)
The predicate read/1 and derived predicates produce an error message on quoted atoms
or strings with more than 6 unescaped newlines. Newlines may be escaped with \ or \c.
This ﬂag also enables warnings on \⟨newline⟩followed by blank space in native mode.
See section 2.15.1. Note that the ISO standard does not allow for unescaped newlines in
quoted atoms.
discontiguous(true)
Warn if the clauses for a predicate are not together in the same source ﬁle. It is advised
to disable the warning for discontiguous predicates using the discontiguous/1
directive.
charset(false)
Warn on atoms and variable names holding non-ASCII characters that are not quoted.
See also section 2.15.1.
4.39
Obtaining Runtime Statistics
statistics(+Key, -Value)
Unify system statistics determined by Key with Value. The possible keys are given in the
table 4.3. This predicate supports additional keys for compatibility reasons. These keys are
described in table 4.4.
statistics
Display a table of system statistics on the stream user error.
time(:Goal)
Execute Goal just like call/1 and print time used, number of logical inferences and the
average number of lips (logical inferences per second). Note that SWI-Prolog counts the actual
executed number of inferences rather than the number of passes through the call and redo ports
of the theoretical 4-port model. If Goal is non-deterministic, print statistics for each solution,
where the reported values are relative to the previous answer.
SWI-Prolog 6.6 Reference Manual

196
CHAPTER 4. BUILT-IN PREDICATES
Native keys (times as ﬂoat in seconds)
agc
Number of atom garbage collections performed
agc gained
Number of atoms removed
agc time
Time spent in atom garbage collections
process cputime
(User) CPU time since Prolog was started in seconds
cputime
(User) CPU time since thread was started in seconds
inferences
Total number of passes via the call and redo ports since Prolog was started
heapused
Bytes of heap in use by Prolog (0 if not maintained)
heap gc
Number of heap garbage collections performed. Only provided if SWI-Prolog
is conﬁgured with Boehm-GC. See also garbage collect heap/0.
c stack
System (C-) stack limit. 0 if not known.
stack
Total memory in use for stacks in all threads
local
Allocated size of the local stack in bytes
localused
Number of bytes in use on the local stack
locallimit
Size to which the local stack is allowed to grow
local shifts
Number of local stack expansions
global
Allocated size of the global stack in bytes
globalused
Number of bytes in use on the global stack
globallimit
Size to which the global stack is allowed to grow
global shifts
Number of global stack expansions
trail
Allocated size of the trail stack in bytes
trailused
Number of bytes in use on the trail stack
traillimit
Size to which the trail stack is allowed to grow
trail shifts
Number of trail stack expansions
shift time
Time spent in stack-shifts
atoms
Total number of deﬁned atoms
functors
Total number of deﬁned name/arity pairs
clauses
Total number of clauses in the program
modules
Total number of deﬁned modules
codes
Total size of (virtual) executable code in words
threads
MT-version: number of active threads
threads created
MT-version: number of created threads
thread cputime
MT-version: seconds CPU time used by ﬁnished threads.
Supported on
Windows-NT and later, Linux and possibly a few more. Verify it gives plausi-
ble results before using.
Table 4.3: Keys for statistics/2. Space is expressed in bytes. Time is expressed in seconds,
represented as a ﬂoating point number.
SWI-Prolog 6.6 Reference Manual

4.39. OBTAINING RUNTIME STATISTICS
197
Compatibility keys (times in milliseconds)
runtime
[ CPU time, CPU time since last ] (milliseconds, excluding time spent in
garbage collection)
system time
[ System CPU time, System CPU time since last ] (milliseconds)
real time
[ Wall time, Wall time since last ] (integer seconds. See get time/1)
walltime
[ Wall time since start, Wall time since last] (milliseconds, SICStus compati-
bility)
memory
[ Total unshared data, free memory ] (Uses getrusage() if available, otherwise
incomplete own statistics.)
stacks
[ global use, local use ]
program
[ heap, 0 ]
global stack
[ global use, global free ]
local stack
[ local use, local free ]
trail
[ trail use, trail free ]
garbage collection
[ number of GC, bytes gained, time spent, bytes left ] The last column is a SWI-
Prolog extension. It contains the sum of the memory left after each collection,
which can be divided by the count to ﬁnd the average working set size after
GC. Use [Count, Gained, Time| ] for compatiblity.
stack shifts
[ global shifts, local shifts, time spent ]
atoms
[ number, memory use, 0 ]
atom garbage collection
[ number of AGC, bytes gained, time spent ]
core
Same as memory
Table 4.4: Compatibility keys for statistics/2. Time is expressed in milliseconds.
SWI-Prolog 6.6 Reference Manual

198
CHAPTER 4. BUILT-IN PREDICATES
4.40
Execution proﬁling
This section describes the hierarchical execution proﬁler. This proﬁler is based on ideas from gprof
described in [Graham et al., 1982]. The proﬁler consists of two parts: the information-gathering com-
ponent built into the kernel,80 and a presentation component which is deﬁned in the statistics
library. The latter can be hooked, which is used by the XPCE module swi/pce profile to provide
an interactive graphical frontend for the results.
4.40.1
Proﬁling predicates
The following predicates are deﬁned to interact with the proﬁler.
proﬁle(:Goal)
Execute Goal just like once/1, collecting proﬁling statistics, and call show profile([]).
With XPCE installed this opens a graphical interface to examine the collected proﬁling data.
proﬁle(:Goal, +Options)
Execute Goal just like once/1.
Collect proﬁling statistics according to Options and call
show profile/1 with Options. The default collects CPU proﬁling and opens a graphical
interface when provided, printing the ‘plain’ time usage of the top 25 predicates as a ballback.
Options are described below. Remaining options are passed to show profile/1.
time(+Which)
If Which is cpu (default), collect CPU timing statistics.
If wall, collect wall time
statistics based on a 5 millisecond sampling rate. Wall time statistics can be useful if Goal
calls blocking system calls.
show proﬁle(+Options)
This predicate ﬁrst calls prolog:show proﬁle hook/1. If XPCE is loaded, this hook is used to
activate a GUI interface to visualise the proﬁle results. If not, a report is printed to the terminal
according to Options:
top(+N)
Show the only top N predicates. Default is 25.
cummulative(+Bool)
If true (default false), include the time spent in children in the time reported for a
predicate.
proﬁler(-Old, +New)
Query or change the status of the proﬁler. The status is one of
false
The proﬁler is not activated.
cputime
The proﬁler collects CPU statistics.
80There are two implementations; one based on setitimer() using the SIGPROF signal and one using Windows Multi
Media (MM) timers. On other systems the proﬁler is not provided.
SWI-Prolog 6.6 Reference Manual

4.40. EXECUTION PROFILING
199
Figure 4.1: Execution proﬁler showing the activity of the predicate chat:inv map list/5.
walltime
The proﬁler collects wall time statistics.
The value true is accepted as a synonym for cputime for compatibility reasons.
reset proﬁler
Switches the proﬁler to false and clears all collected statistics.
noproﬁle(+Name/+Arity, . . .)
Declares the predicate Name/Arity to be invisible to the proﬁler. The time spent in the named
predicate is added to the caller, and the callees are linked directly to the caller.
This is
particularly useful for simple meta-predicates such as call/1, ignore/1, catch/3, etc.
4.40.2
Visualizing proﬁling data
Browsing the annotated call-tree as described in section 4.40.3 itself is not very attractive. Therefore,
the results are combined per predicate, collecting all callers and callees as well as the propagation
of time and activations in both directions. Figure 4.1 illustrates this. The central yellowish line is
the ‘current’ predicate with counts for time spent in the predicate (‘Self’), time spent in its children
(‘Siblings’), activations through the call and redo ports. Above that are the callers. Here, the two time
ﬁelds indicate how much time is spent serving each of the callers. The columns sum to the time in the
yellowish line. The caller <recursive> is the number of recursive calls. Below the yellowish lines are
the callees, with the time spent in the callee itself for serving the current predicate and the time spent
in the callees of the callee (’Siblings’), so the whole time-block adds up to the ‘Siblings’ ﬁeld of the
current predicate. The ‘Access’ ﬁelds show how many times the current predicate accesses each of
the callees.
The predicates have a menu that allows changing the view of the detail window to the given caller
or callee, showing the documentation (if it is a built-in) and/or jumping to the source.
The statistics shown in the report ﬁeld of ﬁgure 4.1 show the following information:
• samples
Number of times the call-tree was sampled for collecting time statistics. On most hardware, the
resolution of SIGPROF is 1/100 second. This number must be sufﬁciently large to get reliable
timing ﬁgures. The Time menu allows viewing time as samples, relative time or absolute time.
SWI-Prolog 6.6 Reference Manual

200
CHAPTER 4. BUILT-IN PREDICATES
• sec
Total user CPU time with the proﬁler active.
• predicates
Total count of predicates that have been called at least one time during the proﬁle.
• nodes
Number of nodes in the call-tree.
• distortion
How much of the time is spent building the call-tree as a percentage of the total execution time.
Timing samples while the proﬁler is building the call-tree are not added to the call-tree.
4.40.3
Information gathering
While the program executes under the proﬁler, the system builds a dynamic call-tree. It does this using
three hooks from the kernel: one that starts a new goal (profCall), one that tells the system which goal
is resumed after an exit (profExit) and one that tells the system which goal is resumed after a fail
(i.e., which goal is used to retry (profRedo)). The profCall() function ﬁnds or creates the subnode
for the argument predicate below the current node, increments the call-count of this link and returns
the sub-node which is recorded in the Prolog stack-frame. Choice-points are marked with the current
proﬁling node. profExit() and profRedo() pass the proﬁling node where execution resumes.
Just using the above algorithm would create a much too big tree due to recursion. For this reason
the system performs detection of recursion. In the simplest case, recursive procedures increment the
‘recursive’ count on the current node. Mutual recursion, however, is not easily detected. For example,
call/1 can call a predicate that uses call/1 itself. This can be viewed as a recursive invocation,
but this is generally not desirable. Recursion is currently assumed if the same predicate with the
same parent appears higher in the call-graph. Early experience with some non-trivial programs are
promising.
The last part of the proﬁler collects statistics on the CPU time used in each node. On systems
providing setitimer() with SIGPROF, it ‘ticks’ the current node of the call-tree each time the timer
ﬁres. On Windows, a MM-timer in a separate thread checks 100 times per second how much time is
spent in the proﬁled thread and adds this to the current node. See section 4.40.3 for details.
Proﬁling in the Windows Implementation
Proﬁling in the Windows version is similar, but as proﬁling is a statistical process it is good to be
aware of the implementation81 for proper interpretation of the results.
Windows does not provide timers that ﬁre asynchronously, frequent and proportional to the CPU
time used by the process. Windows does provide multi-media timers that can run at high frequency.
Such timers, however, run in a separate thread of execution and they are ﬁred on the wall clock
rather than the amount of CPU time used. The proﬁler installs such a timer running, for saving
CPU time, rather inaccurately at about 100 Hz. Each time it is ﬁred, it determines the CPU time in
milliseconds used by Prolog since the last time it was ﬁred. If this value is non-zero, active predicates
are incremented with this value.
81We hereby acknowledge Lionel Fourquaux, who suggested the design described here after a newsnet enquiry.
SWI-Prolog 6.6 Reference Manual

4.41. MEMORY MANAGEMENT
201
4.41
Memory Management
garbage collect
Invoke the global and trail stack garbage collector. Normally the garbage collector is invoked
automatically if necessary.
Explicit invocation might be useful to reduce the need for
garbage collections in time-critical segments of the code.
After the garbage collection
trim stacks/0 is invoked to release the collected memory resources.
garbage collect atoms
Reclaim unused atoms. Normally invoked after agc margin (a Prolog ﬂag) atoms have been
created. On multithreaded versions the actual collection is delayed until there are no threads
performing normal garbage collection. In this case garbage collect atoms/0 returns
immediately. Note that there is no guarantee it will ever happen, as there may always be threads
performing garbage collection.
trim stacks
Release stack memory resources that are not in use at this moment, returning them to the
operating system. It can be used to release memory resources in a backtracking loop, where
the iterations require typically seconds of execution time and very different, potentially large,
amounts of stack space. Such a loop can be written as follows:
loop :-
generator,
trim_stacks,
potentially_expensive_operation,
stop_condition, !.
The Prolog top-level loop is written this way, reclaiming memory resources after every user
query.
set prolog stack(+Stack, +KeyValue)
Set a parameter for one of the Prolog runtime stacks. Stack is one of local, global, trail
or argument. The table below describes the Key(Value) pairs. Value can be an arithmetic
integer expression. For example, to specify a 2 GB limit for the global stack, one can use:
?- set_prolog_stack(global, limit(2*10**9)).
Current settings can be retrieved with prolog stack property/2.
limit(+Bytes)
Set the limit to which the stack is allowed to grow. If the speciﬁed value is lower than the
current usage a permission error is raised. If the limit is larger than supported, the
system silently reduces the requested limit to the system limit.
min free(+Cells)
Minimum amount of free space after trimming or shifting the stack. Setting this value
higher can reduce the number of garbage collections and stack-shifts at the cost of higher
memory usage. The spare stack amount is reported and speciﬁed in ‘cells’. A cell is 4
SWI-Prolog 6.6 Reference Manual

202
CHAPTER 4. BUILT-IN PREDICATES
bytes in the 32-bit version and 8 bytes on the 64-bit version. See address bits. See
also trim stacks/0 and debug/0.
spare(+Cells)
All stacks trigger overﬂow before actually reaching the limit, so the resulting error can be
handled gracefully. The spare stack is used for print message/2 from the garbage
collector and for handling exceptions.
The default sufﬁces, unless the user redeﬁnes
related hooks. Do not specify large values for this because it reduces the amount of
memory available for your real task.
Related
hooks
are
message hook/3
(redeﬁning
GC
messages),
prolog trace interception/4 and prolog exception hook/4.
prolog stack property(?Stack, ?KeyValue)
True if KeyValue is a current property of Stack. See set prolog stack/2 for deﬁned
properties.
4.42
Windows DDE interface
The predicates in this section deal with MS-Windows ‘Dynamic Data Exchange’ or DDE protocol.82
A Windows DDE conversation is a form of interprocess communication based on sending reserved
window events between the communicating processes.
Failing DDE operations raise an error of the structure below, where Operation is the name of the
(partial) operation that failed and Message is a translation of the operator error code. For some errors,
Context provides additional comments.
error(dde_error(Operation, Message), Context)
4.42.1
DDE client interface
The DDE client interface allows Prolog to talk to DDE server programs. We will demonstrate the use
of the DDE interface using the Windows PROGMAN (Program Manager) application:
1 ?- open_dde_conversation(progman, progman, C).
C = 0
2 ?- dde_request(0, groups, X)
--> Unifies X with description of groups
3 ?- dde_execute(0, ’[CreateGroup("DDE Demo")]’).
true.
4 ?- close_dde_conversation(0).
true.
82This interface is contributed by Don Dwiggins.
SWI-Prolog 6.6 Reference Manual

4.42. WINDOWS DDE INTERFACE
203
For details on interacting with progman, use the SDK online manual section on the Shell DDE
interface. See also the Prolog library(progman), which may be used to write simple Windows
setup scripts in Prolog.
open dde conversation(+Service, +Topic, -Handle)
Open a conversation with a server supporting the given service name and topic (atoms). If
successful, Handle may be used to send transactions to the server. If no willing server is found
this predicate fails silently.
close dde conversation(+Handle)
Close the conversation associated with Handle. All opened conversations should be closed
when they’re no longer needed, although the system will close any that remain open on process
termination.
dde request(+Handle, +Item, -Value)
Request a value from the server. Item is an atom that identiﬁes the requested data, and Value
will be a string (CF TEXT data in DDE parlance) representing that data, if the request is
successful.
dde execute(+Handle, +Command)
Request the DDE server to execute the given command string. Succeeds if the command could
be executed and fails with an error message otherwise.
dde poke(+Handle, +Item, +Command)
Issue a POKE command to the server on the speciﬁed Item. command is passed as data of type
CF TEXT.
4.42.2
DDE server mode
The library(dde) deﬁnes primitives to realise simple DDE server applications in SWI-Prolog.
These features are provided as of version 2.0.6 and should be regarded as prototypes. The C part
of the DDE server can handle some more primitives, so if you need features not provided by this
interface, please study library(dde).
dde register service(+Template, +Goal)
Register a server to handle DDE request or DDE execute requests from other applications.
To register a service for a DDE request, Template is of the form:
+Service(+Topic, +Item, +Value)
Service is the name of the DDE service provided (like progman in the client example above).
Topic is either an atom, indicating Goal only handles requests on this topic, or a variable that
also appears in Goal. Item and Value are variables that also appear in Goal. Item represents the
request data as a Prolog atom.83
The example below registers the Prolog current prolog flag/2 predicate to be accessi-
ble from other applications. The request may be given from the same Prolog as well as from
another application.
83Up to version 3.4.5 this was a list of character codes. As recent versions have atom garbage collection there is no need
for this anymore.
SWI-Prolog 6.6 Reference Manual

204
CHAPTER 4. BUILT-IN PREDICATES
?- dde_register_service(prolog(current_prolog_flag, F, V),
current_prolog_flag(F, V)).
?- open_dde_conversation(prolog, current_prolog_flag, Handle),
dde_request(Handle, home, Home),
close_dde_conversation(Handle).
Home = ’/usr/local/lib/pl-2.0.6/’
Handling DDE execute requests is very similar. In this case the template is of the form:
+Service(+Topic, +Item)
Passing a Value argument is not needed as execute requests either succeed or fail. If Goal
fails, a ‘not processed’ is passed back to the caller of the DDE request.
dde unregister service(+Service)
Stop responding to Service. If Prolog is halted, it will automatically call this on all open
services.
dde current service(-Service, -Topic)
Find currently registered services and the topics served on them.
dde current connection(-Service, -Topic)
Find currently open conversations.
4.43
Miscellaneous
dwim match(+Atom1, +Atom2)
True if Atom1 matches Atom2 in the ‘Do What I Mean’ sense. Both Atom1 and Atom2 may
also be integers or ﬂoats. The two atoms match if:
• They are identical
• They differ by one character (spy ≡spu)
• One character is inserted/deleted (debug ≡deug)
• Two characters are transposed (trace ≡tarce)
• ‘Sub-words’ are glued differently (existsﬁle ≡existsFile ≡exists ﬁle)
• Two adjacent sub-words are transposed (existsFile ≡ﬁleExists)
dwim match(+Atom1, +Atom2, -Difference)
Equivalent to dwim match/2, but uniﬁes Difference with an atom identifying the differ-
ence between Atom1 and Atom2.
The return values are (in the same order as above):
equal, mismatched char, inserted char, transposed char, separated and
transposed word.
wildcard match(+Pattern, +String)
True if String matches the wildcard pattern Pattern. Pattern is very similar to the Unix csh
pattern matcher. The patterns are given below:
SWI-Prolog 6.6 Reference Manual

4.43. MISCELLANEOUS
205
?
Matches one arbitrary character.
*
Matches any number of arbitrary characters.
[...]
Matches one of the characters speciﬁed between the brackets.
⟨char1⟩-⟨char2⟩indicates a range.
{...}
Matches any of the patterns of the comma-separated list between the braces.
Example:
?- wildcard_match(’[a-z]*.{pro,pl}[%˜]’, ’a_hello.pl%’).
true.
sleep(+Time)
Suspend execution Time seconds. Time is either a ﬂoating point number or an integer. Gran-
ularity is dependent on the system’s timer granularity. A negative time causes the timer to
return immediately. On most non-realtime operating systems we can only ensure execution is
suspended for at least Time seconds.
On Unix systems the sleep/1 predicate is realised —in order of preference— by nanosleep(),
usleep(), select() if the time is below 1 minute, or sleep(). On Windows systems Sleep() is used.
SWI-Prolog 6.6 Reference Manual

Modules
5
A Prolog module is a collection of predicates which deﬁnes a public interface by means of a set of
provided predicates and operators. Prolog modules are deﬁned by an ISO standard. Unfortunately,
the standard is considered a failure and, as far as we are aware, not implemented by any concrete
Prolog implementation. The SWI-Prolog module system syntax is derived from the Quintus Prolog
module system. The Quintus module system has been the starting point for the module systems of
a number of mainstream Prolog systems, such as SICStus, Ciao and YAP. The underlying primitives
of the SWI-Prolog module system differ from the mentioned systems. These primitives allow for
multiple modules in a ﬁle, hierarchical modules, emulation of other modules interfaces, etc.
This chapter motivates and describes the SWI-Prolog module system. Novices can start using
the module system after reading section 5.2 and section 5.3. The primitives deﬁned in these sections
sufﬁce for basic usage until one needs to export predicates that call or manage other predicates dy-
namically (e.g., use call/1, assert/1, etc.). Such predicates are called meta predicates and are
discussed in section 5.4. Section 5.5 to section 5.8 describe more advanced issues. Starting with
section 5.9, we discuss more low-level aspects of the SWI-Prolog module system that are used to
implement the visible module system, and can be used to build other code reuse mechanisms.
5.1
Why Use Modules?
In classic Prolog systems, all predicates are organised in a single namespace and any predicate can
call any predicate. Because each predicate in a ﬁle can be called from anywhere in the program, it
becomes very hard to ﬁnd the dependencies and enhance the implementation of a predicate without
risking to break the overall application. This is true for any language, but even worse for Prolog due
to its frequent need for ‘helper predicates’.
A Prolog module encapsulates a set of predicates and deﬁnes an interface. Modules can import
other modules, which makes the dependencies explicit. Given explicit dependencies and a well-
deﬁned interface, it becomes much easier to change the internal organisation of a module without
breaking the overall application.
Explicit dependencies can also be used by the development environment. The SWI-Prolog library
prolog xref can be used to analyse completeness and consistency of modules. This library is used
by the built-in editor PceEmacs for syntax highlighting, jump-to-deﬁnition, etc.
5.2
Deﬁning a Module
Modules are normally created by loading a module ﬁle. A module ﬁle is a ﬁle holding a module/2
directive as its ﬁrst term. The module/2 directive declares the name and the public (i.e., externally
visible) predicates of the module. The rest of the ﬁle is loaded into the module. Below is an example
SWI-Prolog 6.6 Reference Manual

5.3. IMPORTING PREDICATES INTO A MODULE
207
of a module ﬁle, deﬁning reverse/2 and hiding the helper predicate rev/3. A module can use all
built-in predicates and, by default, cannot redeﬁne system predicates.
:- module(reverse, [reverse/2]).
reverse(List1, List2) :-
rev(List1, [], List2).
rev([], List, List).
rev([Head|List1], List2, List3) :-
rev(List1, [Head|List2], List3).
The module is named reverse. Typically, the name of a module is the same as the name of the ﬁle
by which it is deﬁned without the ﬁlename extension, but this naming is not enforced. Modules are
organised in a single and ﬂat namespace and therefore module names must be chosen with some care
to avoid conﬂicts. As we will see, typical applications of the module system rarely use the name of a
module explicitly in the source text.
:- module(+Module, +PublicList)
This directive can only be used as the ﬁrst term of a source ﬁle. It declares the ﬁle to be
a module ﬁle, deﬁning a module named Module.
Note that a module name is an atom.
The module exports the predicates of PublicList. PublicList is a list of predicate indicators
(name/arity or name//arity pairs) or operator declarations using the format op(Precedence,
Type, Name). Operators deﬁned in the export list are available inside the module as well as to
modules importing this module. See also section 4.25.
Compatible to Ciao Prolog, if Module is unbound, it is uniﬁed with the basename without
extension of the ﬁle being loaded.
:- module(+Module, +PublicList, +Dialect)
Same as module/2. The additional Dialect argument provides a list of language options.
Each atom in the list Dialect is mapped to a use module/1 goal as given below. See also
section C. The third argument is supported for compatibility with the Prolog Commons project.
:- use_module(library(dialect/LangOption)).
5.3
Importing Predicates into a Module
Predicates can be added to a module by importing them from another module. Importing adds pred-
icates to the namespace of a module. An imported predicate can be called exactly the same as a
locally deﬁned predicate, although its implementation remains part of the module in which it has been
deﬁned.
Importing the predicates from another module is achieved using the directives use module/1
or use module/2. Note that both directives take ﬁlename(s) as arguments. That is, modules are
imported based on their ﬁlename rather than their module name.
SWI-Prolog 6.6 Reference Manual

208
CHAPTER 5. MODULES
use module(+Files)
Load the ﬁle(s) speciﬁed with Files just like ensure loaded/1. The ﬁles must all be module
ﬁles. All exported predicates from the loaded ﬁles are imported into the module from which
this predicate is called. This predicate is equivalent to ensure loaded/1, except that it
raises an error if Files are not module ﬁles.
The imported predicates act as weak symbols in the module into which they are imported. This
implies that a local deﬁnition of a predicate overrides (clobbers) the imported deﬁnition. If the
ﬂag warn override implicit import is true (default), a warning is printed. Below
is an example of a module that uses library(lists), but redeﬁnes flatten/2, giving it a totally
different meaning:
:- module(shapes, []).
:- use_module(library(lists)).
flatten(cube, square).
flatten(ball, circle).
Loading the above ﬁle prints the following message:
Warning: /home/janw/Bugs/Import/t.pl:5:
Local definition of shapes:flatten/2
overrides weak import from lists
This
warning
can
be
avoided
by
(1)
using
use module/2
to
only
import
the
predicates
from
the
lists
library
that
are
actually
used
in
the
‘shapes’
mod-
ule,
(2)
using
the
except([flatten/2])
option
of
use module/2,
(3)
use
:- abolish(flatten/2).
before
the
local
deﬁnition
or
(4)
setting
warn override implicit import to false.
Globally disabling this warning is
only recommended if overriding imported predicates is common as a result of design choices
or the program is ported from a system that silently overrides imported predicates.
Note that it is always an error to import two modules with use module/1 that export the
same predicate. Such conﬂicts must be resolved with use module/2 as described above.
use module(+File, +ImportList)
Load File, which must be a module ﬁle, and import the predicates as speciﬁed by ImportList.
ImportList is a list of predicate indicators specifying the predicates that will be imported from
the loaded module. ImportList also allows for renaming or import-everything-except. See
also the import option of load files/2.
The ﬁrst example below loads member/2
from the lists library and append/2 under the name list concat, which is how this
predicate is named in YAP. The second example loads all exports from library option except
for meta options/3. These renaming facilities are generally used to deal with portability
issues with as few changes as possible to the actual code. See also section C and section 5.7.
:- use_module(library(lists), [ member/2,
append/2 as list_concat
SWI-Prolog 6.6 Reference Manual

5.4. DEFINING A META-PREDICATE
209
]).
:- use_module(library(option), except([meta_options/3])).
The module/2, use module/1 and use module/2 directives are sufﬁcient to partition a
simple Prolog program into modules. The SWI-Prolog graphical cross-referencing tool gxref/0
can be used to analyse the dependencies between non-module ﬁles and propose module declarations
for each ﬁle.
5.4
Deﬁning a meta-predicate
A meta-predicate is a predicate that calls other predicates dynamically, modiﬁes a predicate, or reasons
about properties of a predicate. Such predicates use either a compound term or a predicate indica-
tor to describe the predicate they address, e.g., assert(name(jan)) or abolish(name/1).
With modules, this simple schema no longer works as each module deﬁnes its own mapping
from name+arity to predicate.
This is resolved by wrapping the original description in a term
⟨module⟩:⟨term⟩, e.g., assert(person:name(jan)) or abolish(person:name/1).
Of course, when calling assert/1 from inside a module, we expect to assert to a predicate
local to this module. In other words, we do not wish to provide this :/2 wrapper by hand. The
meta predicate/1 directive tells the compiler that certain arguments are terms that will be used
to look up a predicate and thus need to be wrapped (qualiﬁed) with ⟨module⟩:⟨term⟩, unless they are
already wrapped.
In the example below, we use this to deﬁne maplist/3 inside a module. The argument ‘2’ in the
meta predicate declaration means that the argument is module-sensitive and refers to a predicate with
an arity that is two more than the term that is passed in. The compiler only distinguishes the values
0..9 and :, which denote module-sensitive arguments, from +, - and ?, which denote modes. The
values 0..9 are used by the cross-referencer and syntax highlighting. Note that the helper predicate
maplist /3 does not need to be declared as a meta-predicate because the maplist/3 wrapper
already ensures that Goal is qualiﬁed as ⟨module⟩:Goal. See the description of meta predicate/1
for details.
:- module(maplist, [maplist/3]).
:- meta_predicate maplist(2, ?, ?).
%%
maplist(:Goal, +List1, ?List2)
%
%
True if Goal can successfully be applied to all
%
successive pairs of elements from List1 and List2.
maplist(Goal, L1, L2) :-
maplist_(L1, L2, Goal).
maplist_([], [], _).
maplist_([H0|T0], [H|T], Goal) :-
call(Goal, H0, H),
maplist_(T0, T, Goal).
SWI-Prolog 6.6 Reference Manual

210
CHAPTER 5. MODULES
meta predicate +Head, . . .
Deﬁne the predicates referenced by the comma-separated list Head as meta-predicates. Each
argument of each head is a meta argument speciﬁer. Deﬁned speciﬁers are given below. Only
0..9, : and ˆ are interpreted; the mode declarations +, - and ? are ignored.
0..9
The argument is a term that is used to reference a predicate with N more arguments than
the given argument term. For example: call(0) or maplist(1, +).
:
The argument is module-sensitive, but does not directly refer to a predicate. For example:
consult(:).
-
The argument is not module-sensitive and unbound on entry.
?
The argument is not module-sensitive and the mode is unspeciﬁed.
*
The argument is not module-sensitive and the mode is unspeciﬁed.
The speciﬁca-
tion * is equivalent to ?.
It is accepted for compatibility reasons.
The predicate
predicate property/2 reports arguments declared using * with ?.
+
The argument is not module-sensitive and bound (i.e., nonvar) on entry.
ˆ
This extension is used to denote the possibly ˆ-annotated goal of setof/3, bagof/3,
aggregate/3 and aggregate/4. It is processed similar to ‘0’, but leaving the ˆ/2
intact.
//
The argument is a DCG body. See phrase/3.
Each argument that is module-sensitive (i.e., marked 0..9, : or ˆ) is qualiﬁed with the context
module of the caller if it is not already qualiﬁed. The implementation ensures that the argument
is passed as ⟨module⟩:⟨term⟩, where ⟨module⟩is an atom denoting the name of a module and
⟨term⟩itself is not a :/2 term where the ﬁrst argument is an atom. Below is a simple declaration
and a number of queries.
:- meta_predicate
meta(0, +).
meta(Module:Term, _Arg) :-
format(’Module=˜w, Term = ˜q˜n’, [Module, Term]).
?- meta(test, x).
Module=user, Term = test
?- meta(m1:test, x).
Module=m1, Term = test
SWI-Prolog 6.6 Reference Manual

5.5. OVERRULING MODULE BOUNDARIES
211
?- m2:meta(test, x).
Module=m2, Term = test
?- m1:meta(m2:test, x).
Module=m2, Term = test
?- meta(m1:m2:test, x).
Module=m2, Term = test
?- meta(m1:42:test, x).
Module=42, Term = test
The meta predicate/1 declaration is the portable mechanism for deﬁning meta-predicates
and replaces the old SWI-Prolog speciﬁc mechanism provided by the deprecated predicates
module transparent/1, context module/1 and strip module/3. See also sec-
tion 5.15.
5.5
Overruling Module Boundaries
The module system described so far is sufﬁcient to distribute programs over multiple modules. There
are, however, cases in which we would like to be able to overrule this schema and explicitly call
a predicate in some module or assert explicitly into some module. Calling in a particular module
is useful for debugging from the user’s top level or to access multiple implementations of the same
interface that reside in multiple modules. Accessing the same interface from multiple modules cannot
be achieved using importing because importing a predicate with the same name and arity from two
modules results in a name conﬂict. Asserting in a different module can be used to create models
dynamically in a new module. See section 5.12.
Direct addressing of modules is achieved using a :/2 explicitly in a program and relies on the
module qualiﬁcation mechanism described in section 5.4. Here are a few examples:
?- assert(world:done).
% asserts done/0 into module world
?- world:asserta(done).
% the same
?- world:done.
% calls done/0 in module world
Note that the second example is the same due to the Prolog ﬂag colon sets calling context.
The system predicate asserta/1 is called in the module world, which is possible because system
predicates are visible in all modules. At the same time, the calling context is set to world. Because
meta arguments are qualiﬁed with the calling context, the resulting call is the same as the ﬁrst example.
5.5.1
Explicit manipulation of the calling context
Quintus’ derived module systems have no means to separate the lookup module (for ﬁnding predi-
cates) from the calling context (for qualifying meta arguments). Some other Prolog implementations
(e.g., ECLiPSe and IF/Proloog) distinguish these operations, using @/2 for setting the calling context
of a goal. This is provided by SWI-Prolog, currently mainly to support compatibility layers.
@(:Goal, +Module)
Execute Goal, setting the calling context to Module. Setting the calling context affects meta-
predicates, for which meta arguments are qualiﬁed with Module and transparent predicates (see
module transparent/1). It has no implications for other predicates.
SWI-Prolog 6.6 Reference Manual

212
CHAPTER 5. MODULES
For example, the code asserta(done)@world is the same as asserta(world:done).
Unlike in world:asserta(done), asserta/1 is resolved in the current module rather
than the module world. This makes no difference for system predicates, but usually does make
a difference for user predicates.
Not that SWI-Prolog does not deﬁne @ as an operator. Some systems deﬁne this construct using
op(900, xfx, @).
5.6
Interacting with modules from the top level
Debugging often requires interaction with predicates that reside in modules: running them, setting spy
points on them, etc. This can be achieved using the ⟨module⟩:⟨term⟩construct explicitly as described
above. In SWI-Prolog, you may also wish to omit the module qualiﬁcation. Setting a spy point
(spy/1) on a plain predicate sets a spy point on any predicate with that name in any module. Editing
(edit/1) or calling an unqualiﬁed predicate invokes the DWIM (Do What I Mean) mechanism,
which generally suggests the correct qualiﬁed query.
Mainly for compatibility, we provide module/1 to switch the module with which the interactive
top level interacts:
module(+Module)
The call module(Module) may be used to switch the default working module for the inter-
active top level (see prolog/0). This may be used when debugging a module. The example
below lists the clauses of file of label/2 in the module tex.
1 ?- module(tex).
true.
tex: 2 ?- listing(file_of_label/2).
...
5.7
Composing modules from other modules
The predicates in this section are intended to create new modules from the content of other mod-
ules. Below is an example to deﬁne a composite module. The example exports all public pred-
icates of module 1, module 2 and module 3, pred/1 from module 4, all predicates from
module 5 except do not use/1 and all predicates from module 6 while renaming pred/1
into mypred/1.
:- module(my_composite, []).
:- reexport([ module_1,
module_2,
module_3
]).
:- reexport(module_4, [ pred/1 ]).
:- reexport(module_5, except([do_not_use/1])).
:- reexport(module_6, except([pred/1 as mypred])).
SWI-Prolog 6.6 Reference Manual

5.8. OPERATORS AND MODULES
213
reexport(+Files)
Load and import predicates as use module/1 and re-export all imported predicates. The
reexport declarations must immediately follow the module declaration.
reexport(+File, +Import)
Import from File as use module/2 and re-export the imported predicates. The reexport
declarations must immediately follow the module declaration.
5.8
Operators and modules
Operators (section 4.25) are local to modules, where the initial table behaves as if it is copied
from the module user (see section 5.10).
A speciﬁc operator can be disabled inside a mod-
ule using :- op(0, Type, Name).
Inheritance from the public table can be restored using
:- op(-1, Type, Name).
In addition to using the op/3 directive, operators can be declared in the module/2 directive as
shown below. Such operator declarations are visible inside the module, and importing such a module
makes the operators visible in the target module. Exporting operators is typically used by modules
that implement sub-languages such as chr (see chapter 7). The example below is copied from the
library clpfd.
:- module(clpfd,
[ op(760, yfx, #<==>),
op(750, xfy, #==>),
op(750, yfx, #<==),
op(740, yfx, #\/),
...
(#<==>)/2,
(#==>)/2,
(#<==)/2,
(#\/)/2,
...
]).
5.9
Dynamic importing using import modules
Until now we discussed the public module interface that is, at least to some extent, portable between
Prolog implementations with a module system that is derived from Quintus Prolog. The remainder of
this chapter describes the underlying mechanisms that can be used to emulate other module systems
or implement other code-reuse mechanisms.
In addition to built-in predicates, imported predicates and locally deﬁned predicates, SWI-Prolog
modules can also call predicates from its import modules. Each module has a (possibly empty) list of
import modules. In the default setup, each new module has a single import module, which is user
for all normal user modules and system for all system library modules. Module user imports from
system where all built-in predicates reside. These special modules are described in more detail in
section 5.10.
SWI-Prolog 6.6 Reference Manual

214
CHAPTER 5. MODULES
The list of import modules can be manipulated and queried using the following predicates, as well
as using set module/1.
import module(+Module, -Import)
[nondet]
True if Module inherits directly from Import.
All normal modules only import from
user, which imports from system.
The predicates add import module/3 and
delete import module/2 can be used to manipulate the import list.
See also
default module/2.
default module(+Module, -Default)
[multi]
True if predicates and operators in Default are visible in Module. Modules are returned in
the same search order used for predicates and operators. That is, Default is ﬁrst uniﬁed with
Module, followed by the depth-ﬁrst transitive closure of import module/2.
add import module(+Module, +Import, +StartOrEnd)
If Import is not already an import module for Module, add it to this list at the start or end
depending on StartOrEnd. See also import module/2 and delete import module/2.
delete import module(+Module, +Import)
Delete Import from the list of import modules for Module. Fails silently if Import is not in the
list.
One usage scenario of import modules is to deﬁne a module that is a copy of another, but where
one or more predicates have an alternative deﬁnition.
5.10
Reserved Modules and using the ‘user’ module
As mentioned above, SWI-Prolog contains two special modules. The ﬁrst one is the module system.
This module contains all built-in predicates. Module system has no import module. The second
special module is the module user. This module forms the initial working space of the user. Initially
it is empty. The import module of module user is system, making all built-in predicates available.
All other modules import from the module user. This implies they can use all predicates im-
ported into user without explicitly importing them. If an application loads all modules from the
user module using use module/1, one achieves a scoping system similar to the C-language,
where every module can access all exported predicates without any special precautions.
5.11
An alternative import/export interface
The use module/1 predicate from section 5.3 deﬁnes import and export relations based on the
ﬁlename from which a module is loaded. If modules are created differently, such as by asserting
predicates into a new module as described in section 5.12, this interface cannot be used. The interface
below provides for import/export from modules that are not created using a module ﬁle.
export(+PredicateIndicator, . . .)
Add predicates to the public list of the context module. This implies the predicate will be
imported into another module if this module is imported with use module/[1,2]. Note
that predicates are normally exported using the directive module/2. export/1 is meant to
handle export from dynamically created modules.
SWI-Prolog 6.6 Reference Manual

5.12. DYNAMIC MODULES
215
import(+PredicateIndicator, . . .)
Import predicates PredicateIndicator into the current context module. PredicateIndicator must
specify the source module using the ⟨module⟩:⟨pi⟩construct. Note that predicates are normally
imported using one of the directives use module/[1,2].
The import/1 alternative
is meant for handling imports into dynamically created modules. See also export/1 and
export list/2.
5.12
Dynamic Modules
So far, we discussed modules that were created by loading a module ﬁle. These modules have been
introduced to facilitate the development of large applications. The modules are fully deﬁned at load-
time of the application and normally will not change during execution. Having the notion of a set of
predicates as a self-contained world can be attractive for other purposes as well. For example, assume
an application that can reason about multiple worlds. It is attractive to store the data of a particular
world in a module, so we extract information from a world simply by invoking goals in this world.
Dynamic modules can easily be created. Any built-in predicate that tries to locate a predicate in a
speciﬁc module will create this module as a side-effect if it did not yet exist. For example:
?- assert(world_a:consistent),
world_a:set_prolog_flag(unknown, fail).
These calls create a module called ‘world a’ and make the call ‘world a:consistent’ succeed. Unde-
ﬁned predicates will not raise an exception for this module (see unknown).
Import and export from a dynamically created world can be achieved using import/1 and
export/1 or by specifying the import module as described in section 5.9.
?- world_b:export(solve/2).
% exports solve/2 from world_b
?- world_c:import(world_b:solve/2).
% and import it to world_c
5.13
Transparent predicates: deﬁnition and context module
The ‘module-transparent’ mechanism is still underlying the actual implementation. Direct usage by
programmers is deprecated. Please use meta predicate/1 to deal with meta-predicates.
The qualiﬁcation of module-sensitive arguments described in section 5.4 is realised using trans-
parent predicates. It is now deprecated to use this mechanism directly. However, studying the un-
derlying mechanism helps to understand SWI-Prolog’s modules. In some respect, the transparent
mechanism is more powerful than meta-predicate declarations.
Each predicate of the program is assigned a module, called its deﬁnition module. The deﬁnition
module of a predicate is always the module in which the predicate was originally deﬁned. Each active
goal in the Prolog system has a context module assigned to it.
The context module is used to ﬁnd predicates for a Prolog term. By default, the context module
is the deﬁnition module of the predicate running the goal. For transparent predicates, however, this
is the context module of the goal inherited from the parent goal. Below, we implement maplist/3
using the transparent mechanism. The code of maplist/3 and maplist /3 is the same as in
SWI-Prolog 6.6 Reference Manual

216
CHAPTER 5. MODULES
section 5.4, but now we must declare both the main predicate and the helper as transparent to avoid
changing the context module when calling the helper.
:- module(maplist, maplist/3).
:- module_transparent
maplist/3,
maplist_/3.
maplist(Goal, L1, L2) :-
maplist_(L1, L2, G).
maplist_([], [], _).
maplist_([H0|T0], [H|T], Goal) :-
call(Goal, H0, H),
maplist_(T0, T, Goal).
Note that any call that translates terms into predicates is subject to the transparent mechanism, not
just the terms passed to module-sensitive arguments. For example, the module below counts the
number of unique atoms returned as bindings for a variable. It works as expected. If we use the
directive :- module transparent count atom results/3. instead, atom result/2
is called wrongly in the module calling count atom results/3.
This can be solved using
strip module/3 to create a qualiﬁed goal and a non-transparent helper predicate that is deﬁned in
the same module.
:- module(count_atom_results,
[ count_atom_results/3
]).
:- meta_predicate count_atom_results(-,0,-).
count_atom_results(A, Goal, Count) :-
setof(A, atom_result(A, Goal), As), !,
length(As, Count).
count_atom_results(_, _, 0).
atom_result(Var, Goal) :-
call(Goal),
atom(Var).
The following predicates support the module-transparent interface:
:- module transparent(+Preds)
Preds is a comma-separated list of name/arity pairs (like dynamic/1). Each goal associated
with a transparent-declared predicate will inherit the context module from its parent goal.
context module(-Module)
Unify Module with the context module of the current goal. context module/1 itself is, of
course, transparent.
SWI-Prolog 6.6 Reference Manual

5.14. MODULE PROPERTIES
217
strip module(+Term, -Module, -Plain)
Used in module-transparent predicates or meta-predicates to extract the referenced module and
plain term. If Term is a module-qualiﬁed term, i.e. of the format Module:Plain, Module and
Plain are uniﬁed to these values. Otherwise, Plain is uniﬁed to Term and Module to the context
module.
5.14
Module properties
The following predicates can be used to query the module system for reﬂexive programming:
current module(?Module)
[nondet]
True if Module is a currently deﬁned module. This predicate enumerates all modules, whether
loaded from a ﬁle or created dynamically. Note that modules cannot be destroyed in the current
version of SWI-Prolog.
module property(?Module, ?Property)
True if Property is a property of Module. Deﬁned properties are:
class(-Class)
True when Class is the class of the module. Deﬁned classes are
user
Default for user-deﬁned modules.
system
Module system and modules from ⟨home⟩/boot.
library
Other modules from the system directories.
test
Modules that create tests.
development
Modules that only support the development environment.
ﬁle(?File)
True if Module was loaded from File.
line count(-Line)
True if Module was loaded from the N-th line of ﬁle.
exports(-ListOfPredicateIndicators)
True if Module exports the given predicates.
Predicate indicators are in canonical
form (i.e., always using name/arity and never the DCG form name//arity).
Fu-
ture versions may also use the DCG form and include public operators.
See also
predicate property/2.
exported operators(-ListOfOperators)
True if Module exports the given operators. Each exported operator is represented as a
term op(Pri,Assoc,Name).
set module(:Property)
Modify properties of the module. Currently, the following properties may be modiﬁed:
SWI-Prolog 6.6 Reference Manual

218
CHAPTER 5. MODULES
base(+Base)
Set the default import module of the current module to Module. Typically, Module is one
of user or system. See section 5.9.
class(+Class)
Set the class of the module. See module property/2.
5.15
Compatibility of the Module System
The SWI-Prolog module system is largely derived from the Quintus Prolog module system, which
is also adopted by SICStus, Ciao and YAP. Originally, the mechanism for deﬁning meta-predicates
in SWI-Prolog was based on the module transparent/1 directive and strip module/3.
Since 5.7.4 it supports the de-facto standard meta predicate/1 directive for implementing meta-
predicates, providing much better compatibility.
The support for the meta predicate/1 mechanism, however, is considerably different.
On most systems, the caller of a meta-predicate is compiled differently to provide the required
⟨module⟩:⟨term⟩qualiﬁcation. This implies that the meta-declaration must be available to the com-
piler when compiling code that calls a meta-predicate. In practice, this implies that other systems pose
the following restrictions on meta-predicates:
• Modules that provide meta-predicates for a module to be compiled must be loaded explicitly by
that module.
• The meta-predicate directives of exported predicates must follow the module/2 directive im-
mediately.
• After changing a meta-declaration, all modules that call the modiﬁed predicates need to be
recompiled.
In SWI-Prolog, meta-predicates are also module-transparent, and qualifying the module-sensitive
arguments is done inside the meta-predicate. As a result, the caller need not be aware that it is calling
a meta-predicate and none of the above restrictions hold for SWI-Prolog. However, code that aims at
portability must obey the above rules.
Other differences are listed below.
• If a module does not deﬁne a predicate, it is searched for in the import modules. By default, the
import module of any user-deﬁned module is the user module. In turn, the user module im-
ports from the module system that provides all built-in predicates. The auto-import hierarchy
can be changed using add import module/3 and delete import module/2.
This mechanism can be used to realise a simple object-oriented system or a hierarchical module
system.
• Operator declarations are local to a module and may be exported. In Quintus and SICStus
all operators are global. YAP and Ciao also use local operators. SWI-Prolog provides global
operator declarations from within a module by explicitly qualifying the operator name with the
user module. I.e., operators are inherited from the import modules (see above).
:- op(precedence, type, user:(operatorname)).
SWI-Prolog 6.6 Reference Manual

Special Variables and
Coroutining
6
This chapter deals with extensions primarily designed to support constraint logic programming (CLP).
The low-level attributed variable interface deﬁned in section 6.1 is not intended for the typical Prolog
programmer. Instead, the typical Prolog programmer should use the coroutining predicates and the
various constraint solvers built on top of attributed variables. CHR (chapter 7) provides a general
purpose constraint handling language.
As a rule of thumb, constraint programming reduces the search space by reordering goals and
joining goals based on domain knowledge. A typical example is constraint reasoning over integer
domains. Plain Prolog has no efﬁcient means to deal with (integer) X > 0 and X < 3. At best
it could translate X > 0 with uninstantiated X to between(1, inﬁnite, X) and a similar primitive
for X < 3. If the two are combined it has no choice but to generate and test over this inﬁnite two-
dimensional space. Instead, a constraint system will delay an uninstantiated goal to X > 0. If, later,
it ﬁnds a value for X it will execute the test. If it ﬁnds X < 3 it will combine this knowledge to infer
that X is in 1..2 (see below). If it never ﬁnds a concrete value for X it can be asked to label X and
produce 1 and 2 on backtracking. See section A.7.
1 ?- [library(clpfd)].
...
true.
2 ?- X #> 0, X #< 3.
X in 1..2.
Using constraints generally makes your program more declarative. There are some caveats though:
• Constraints and cuts do not merge well. A cut after a goal that is delayed prunes the search
space before the condition is true.
• Term-copying operations (assert/1, retract/2, findall/3, copy term/2, etc.)
generally also copy constraints. The effect varies from ok, silent copying of huge constraint
networks to violations of the internal consistency of constraint networks. As a rule of thumb,
copying terms holding attributes must be deprecated.
6.1
Attributed variables
Attributed
variables
provide
a
technique
for
extending
the
Prolog
uniﬁcation
algorithm
[Holzbaur, 1992] by hooking the binding of attributed variables. There is no consensus in the Pro-
log community on the exact deﬁnition and interface to attributed variables. The SWI-Prolog interface
SWI-Prolog 6.6 Reference Manual

220
CHAPTER 6. SPECIAL VARIABLES AND COROUTINING
is identical to the one realised by Bart Demoen for hProlog [Demoen, 2002]. This interface is sim-
ple and available on all Prolog systems that can run the Leuven CHR system (see chapter 7 and the
Leuven CHR page).
Binding an attributed variable schedules a goal to be executed at the ﬁrst possible opportunity.
In the current implementation the hooks are executed immediately after a successful uniﬁcation of
the clause-head or successful completion of a foreign language (built-in) predicate. Each attribute
is associated to a module, and the hook (attr unify hook/2) is executed in this module. The
example below realises a very simple and incomplete ﬁnite domain reasoner:
:- module(domain,
[ domain/2
% Var, ?Domain
]).
:- use_module(library(ordsets)).
domain(X, Dom) :-
var(Dom), !,
get_attr(X, domain, Dom).
domain(X, List) :-
list_to_ord_set(List, Domain),
put_attr(Y, domain, Domain),
X = Y.
%
An attributed variable with attribute value Domain has been
%
assigned the value Y
attr_unify_hook(Domain, Y) :-
(
get_attr(Y, domain, Dom2)
->
ord_intersection(Domain, Dom2, NewDomain),
(
NewDomain == []
->
fail
;
NewDomain = [Value]
->
Y = Value
;
put_attr(Y, domain, NewDomain)
)
;
var(Y)
->
put_attr( Y, domain, Domain )
;
ord_memberchk(Y, Domain)
).
%
Translate attributes from this module to residual goals
attribute_goals(X) -->
{ get_attr(X, domain, List) },
[domain(X, List)].
Before explaining the code we give some example queries:
SWI-Prolog 6.6 Reference Manual

6.1. ATTRIBUTED VARIABLES
221
?- domain(X, [a,b]), X = c
fail
?- domain(X, [a,b]), domain(X, [a,c]).
X = a
?- domain(X, [a,b,c]), domain(X, [a,c]).
domain(X, [a, c])
The predicate domain/2 fetches (ﬁrst clause) or assigns (second clause) the variable a domain,
a set of values the variable can be uniﬁed with. In the second clause, domain/2 ﬁrst associates the
domain with a fresh variable (Y) and then uniﬁes X to this variable to deal with the possibility that
X already has a domain. The predicate attr unify hook/2 (see below) is a hook called after a
variable with a domain is assigned a value. In the simple case where the variable is bound to a concrete
value, we simply check whether this value is in the domain. Otherwise we take the intersection of the
domains and either fail if the intersection is empty (ﬁrst example), assign the value if there is only one
value in the intersection (second example), or assign the intersection as the new domain of the variable
(third example). The nonterminal attribute goals/3 is used to translate remaining attributes to
user-readable goals that, when executed, reinstate these attributes.
6.1.1
Attribute manipulation predicates
attvar(@Term)
Succeeds if Term is an attributed variable. Note that var/1 also succeeds on attributed vari-
ables. Attributed variables are created with put attr/3.
put attr(+Var, +Module, +Value)
If Var is a variable or attributed variable, set the value for the attribute named Module to Value.
If an attribute with this name is already associated with Var, the old value is replaced. Back-
tracking will restore the old value (i.e., an attribute is a mutable term; see also setarg/3).
This predicate raises a representation error if Var is not a variable and a type error if Module is
not an atom.
get attr(+Var, +Module, -Value)
Request the current value for the attribute named Module. If Var is not an attributed variable
or the named attribute is not associated to Var this predicate fails silently. If Module is not an
atom, a type error is raised.
del attr(+Var, +Module)
Delete the named attribute. If Var loses its last attribute it is transformed back into a traditional
Prolog variable. If Module is not an atom, a type error is raised. In all other cases this predicate
succeeds regardless of whether or not the named attribute is present.
6.1.2
Attributed variable hooks
Attribute names are linked to modules. This means that certain operations on attributed variables
cause hooks to be called in the module whose name matches the attribute name.
attr unify hook(+AttValue, +VarValue)
A hook that must be deﬁned in the module to which an attributed variable refers. It is called
after the attributed variable has been uniﬁed with a non-var term, possibly another attributed
variable. AttValue is the attribute that was associated to the variable in this module and VarValue
is the new value of the variable. Normally this predicate fails to veto binding the variable to
VarValue, forcing backtracking to undo the binding. If VarValue is another attributed variable
SWI-Prolog 6.6 Reference Manual

222
CHAPTER 6. SPECIAL VARIABLES AND COROUTINING
the hook often combines the two attributes and associates the combined attribute with VarValue
using put attr/3.
attr portray hook(+AttValue, +Var)
Called by write term/2 and friends for each attribute if the option attributes(portray)
is in effect.
If the hook succeeds the attribute is considered printed.
Otherwise
Module = ... is printed to indicate the existence of a variable.
New infrastructure
dealing with communicating attribute values must be based on copy term/3 and its hook
attribute goals//1.
attribute goals(+Var) //
This nonterminal, if it is deﬁned in a module, is used by copy term/3 to project attributes
of that module to residual goals. It is also used by the top level to obtain residual goals after
executing a query.
6.1.3
Operations on terms with attributed variables
copy term(+Term, -Copy, -Gs)
Create a regular term Copy as a copy of Term (without any attributes), and a list Gs of goals
that represents the attributes. The goal maplist(call,Gs) recreates the attributes for Copy. The
nonterminal attribute goals//1, as deﬁned in the modules the attributes stem from, is
used to convert attributes to lists of goals.
This building block is used by the top level to report pending attributes in a portable and under-
standable fashion. This predicate is the preferred way to reason about and communicate terms
with constraints.
copy term nat(+Term, -Copy)
As copy term/2. Attributes, however, are not copied but replaced by fresh variables.
term attvars(+Term, -AttVars)
AttVars is a list of all attributed variables in Term and its attributes.
That is,
term attvars/2 works recursively through attributes.
This predicate is cycle-safe.
The goal term attvars(Term, []) in an efﬁcient test that Term has no attributes; scanning
the term is aborted after the ﬁrst attributed variable is found.
6.1.4
Special purpose predicates for attributes
Normal user code should deal with put attr/3, get attr/3 and del attr/2. The routines in
this section fetch or set the entire attribute list of a variable. Use of these predicates is anticipated to
be restricted to printing and other special purpose operations.
get attrs(+Var, -Attributes)
Get all attributes of Var. Attributes is a term of the form att(Module, Value, MoreAttributes),
where MoreAttributes is [] for the last attribute.
put attrs(+Var, -Attributes)
Set all attributes of Var. See get attrs/2 for a description of Attributes.
SWI-Prolog 6.6 Reference Manual

6.2. COROUTINING
223
del attrs(+Var)
If Var is an attributed variable, delete all its attributes. In all other cases, this predicate succeeds
without side-effects.
6.2
Coroutining
Coroutining deals with having Prolog goals scheduled for execution as soon as some conditions are
fulﬁlled. In Prolog the most commonly used condition is the instantiation (binding) of a variable.
Scheduling a goal to execute immediately after a variable is bound can be used to avoid instantiation
errors for some built-in predicates (e.g. arithmetic), do work lazy, prevent the binding of a variable
to a particular value, etc. Using freeze/2 for example we can deﬁne a variable that can only be
assigned an even number:
?- freeze(X, X mod 2 =:= 0), X = 3
No
freeze(+Var, :Goal)
Delay the execution of Goal until Var is bound (i.e. is not a variable or attributed variable).
If Var is bound on entry freeze/2 is equivalent to call/1.
The freeze/2 pred-
icate is realised using an attributed variable associated with the module freeze.
Use
frozen(Var, Goal) to ﬁnd out whether and which goals are delayed on Var.
frozen(@Var, -Goal)
Unify Goal with the goal or conjunction of goals delayed on Var. If no goals are frozen on Var,
Goal is uniﬁed to true.
when(@Condition, :Goal)
Execute Goal when Condition becomes true.
Condition is one of ?=(X, Y), nonvar(X),
ground(X), ,(Cond1, Cond2) or ;(Cond1, Cond2). See also freeze/2 and dif/2. The
implementation can deal with cyclic terms in X and Y.
The when/2 predicate is realised using attributed variables associated with the module when.
It is deﬁned in the autoload library when.
dif(@A, @B)
The dif/2 predicate provides a constraint stating that A and B are different terms.
If A and B can never unify, dif/2 succeeds deterministically.
If A and B are iden-
tical it fails immediately, and ﬁnally, if A and B can unify, goals are delayed that
prevent A and B to become equal.
The dif/2 predicate behaves as if deﬁned by
dif(X, Y) :- when(?=(X, Y), X \== Y). See also ?=/2.
The implementa-
tion can deal with cyclic terms.
The dif/2 predicate is realised using attributed variables associated with the module dif. It
is deﬁned in the autoload library dif.
call residue vars(:Goal, -Vars)
Find residual attributed variables left by Goal. This predicate is intended for debugging pro-
grams using coroutining or constraints. Consider a program that poses contradicting constraints
SWI-Prolog 6.6 Reference Manual

224
CHAPTER 6. SPECIAL VARIABLES AND COROUTINING
on a variable. Such programs should fail, but sometimes succeed because the constraint solver
is too weak to detect the contradiction. Ideally, delayed goals and constraints are all executed at
the end of the computation. The meta predicate call residue vars/2 ﬁnds variables that
are given attribute variables or whose attributes are modiﬁed1 by Goal, regardless of whether
or not these variables are reachable from the arguments of Goal.
The predicate has considerable implications. During the execution of Goal, the garbage collec-
tor does not reclaim attributed variables. This causes some degradation of GC performance. In
a well-behaved program there are no such variables, so the space impact is generally minimal.
The actual collection of Vars is implemented using a scan of the trail and global stacks.
6.3
Global variables
Global variables are associations between names (atoms) and terms. They differ in various ways from
storing information using assert/1 or recorda/3.
• The value lives on the Prolog (global) stack. This implies that lookup time is independent of the
size of the term. This is particularly interesting for large data structures such as parsed XML
documents or the CHR global constraint store.
• They support both global assignment using nb setval/2 and backtrackable assignment using
b setval/2.
• Only one value (which can be an arbitrary complex Prolog term) can be associated to a variable
at a time.
• Their value cannot be shared among threads. Each thread has its own namespace and values for
global variables.
• Currently global variables are scoped globally. We may consider module scoping in future
versions.
Both b setval/2 and nb setval/2 implicitly create a variable if the referenced name does
not already refer to a variable.
Global variables may be initialised from directives to make them available during the program
lifetime, but some considerations are necessary for saved states and threads. Saved states do not store
global variables, which implies they have to be declared with initialization/1 to recreate them
after loading the saved state. Each thread has its own set of global variables, starting with an empty
set. Using thread initialization/1 to deﬁne a global variable it will be deﬁned, restored
after reloading a saved state and created in all threads that are created after the registration. Finally,
global variables can be initialised using the exception hook exception/3. The latter technique is
used by CHR (see chapter 7).
b setval(+Name, +Value)
Associate the term Value with the atom Name or replace the currently associated value with
Value. If Name does not refer to an existing global variable, a variable with initial value [] is
created (the empty list). On backtracking the assignment is reversed.
1Tracking modiﬁcations is currently not complete and this feature may be dropped completely in future versions.
SWI-Prolog 6.6 Reference Manual

6.3. GLOBAL VARIABLES
225
b getval(+Name, -Value)
Get the value associated with the global variable Name and unify it with Value. Note that this
uniﬁcation may further instantiate the value of the global variable. If this is undesirable the
normal precautions (double negation or copy term/2) must be taken. The b getval/2
predicate generates errors if Name is not an atom or the requested variable does not exist.
nb setval(+Name, +Value)
Associates a copy of Value created with duplicate term/2 with the atom Name. Note that
this can be used to set an initial value other than [] prior to backtrackable assignment.
nb getval(+Name, -Value)
The nb getval/2 predicate is a synonym for b getval/2, introduced for compatibility
and symmetry.
As most scenarios will use a particular global variable using either non-
backtrackable or backtrackable assignment, using nb getval/2 can be used to document
that the variable is non-backtrackable.
nb linkval(+Name, +Value)
Associates the term Value with the atom Name without copying it. This is a fast special-
purpose variation of nb setval/2 intended for expert users only because the semantics on
backtracking to a point before creating the link are poorly deﬁned for compound terms. The
principal term is always left untouched, but backtracking behaviour on arguments is undone if
the original assignment was trailed and left alone otherwise, which implies that the history that
created the term affects the behaviour on backtracking. Consider the following example:
demo_nb_linkval :-
T = nice(N),
(
N = world,
nb_linkval(myvar, T),
fail
;
nb_getval(myvar, V),
writeln(V)
).
nb current(?Name, ?Value)
Enumerate all deﬁned variables with their value. The order of enumeration is undeﬁned.
nb delete(+Name)
Delete the named global variable.
6.3.1
Compatibility of SWI-Prolog Global Variables
Global variables have been introduced by various Prolog implementations recently. The implemen-
tation of them in SWI-Prolog is based on hProlog by Bart Demoen. In discussion with Bart it was
decided that the semantics of hProlog nb setval/2, which is equivalent to nb linkval/2, is
not acceptable for normal Prolog users as the behaviour is inﬂuenced by how built-in predicates that
construct terms (read/1, =../2, etc.) are implemented.
GNU-Prolog provides a rich set of global variables, including arrays. Arrays can be implemented
easily in SWI-Prolog using functor/3 and setarg/3 due to the unrestricted arity of compound
terms.
SWI-Prolog 6.6 Reference Manual

CHR: Constraint Handling
Rules
7
This chapter is written by Tom Schrijvers, K.U. Leuven, and adjustments by Jan Wielemaker.
The CHR system of SWI-Prolog is the K.U.Leuven CHR system. The runtime environment is
written by Christian Holzbaur and Tom Schrijvers while the compiler is written by Tom Schrijvers.
Both are integrated with SWI-Prolog and licensed under compatible conditions with permission from
the authors.
The main reference for the K.U.Leuven CHR system is:
• T. Schrijvers, and B. Demoen, The K.U.Leuven CHR System: Implementation and Applica-
tion, First Workshop on Constraint Handling Rules: Selected Contributions (Fr¨uhwirth, T. and
Meister, M., eds.), pp. 1–5, 2004.
On the K.U.Leuven CHR website (http://dtai.cs.kuleuven.be/CHR/) you can ﬁnd
more related papers, references and example programs.
7.1
Introduction
Constraint Handling Rules (CHR) is a committed-choice rule-based language embedded in Prolog. It
is designed for writing constraint solvers and is particularly useful for providing application-speciﬁc
constraints. It has been used in many kinds of applications, like scheduling, model checking, abduc-
tion, and type checking, among many others.
CHR has previously been implemented in other Prolog systems (SICStus, Eclipse, Yap), Haskell
and Java. This CHR system is based on the compilation scheme and runtime environment of CHR in
SICStus.
In this documentation we restrict ourselves to giving a short overview of CHR in general and
mainly focus on elements speciﬁc to this implementation. For a more thorough review of CHR we
refer the reader to [Fr¨uhwirth, 2009]. More background on CHR can be found at [Fr¨uhwirth, ].
In section 7.2 we present the syntax of CHR in Prolog and explain informally its operational se-
mantics. Next, section 7.3 deals with practical issues of writing and compiling Prolog programs con-
taining CHR. Section 7.4 explains the (currently primitive) CHR debugging facilities. Section 7.4.3
provides a few useful predicates to inspect the constraint store, and section 7.5 illustrates CHR with
two example programs. Section 7.6 describes some compatibility issues with older versions of this
system and SICStus’ CHR system. Finally, section 7.7 concludes with a few practical guidelines for
using CHR.
SWI-Prolog 6.6 Reference Manual

7.2. SYNTAX AND SEMANTICS
227
7.2
Syntax and Semantics
7.2.1
Syntax of CHR rules
rules --> rule, rules ; [].
rule --> name, actual_rule, pragma, [atom(’.’)].
name --> atom, [atom(’@’)] ; [].
actual_rule --> simplification_rule.
actual_rule --> propagation_rule.
actual_rule --> simpagation_rule.
simplification_rule --> head, [atom(’<=>’)], guard, body.
propagation_rule --> head, [atom(’==>’)], guard, body.
simpagation_rule --> head, [atom(’\’)], head, [atom(’<=>’)],
guard, body.
head --> constraints.
constraints --> constraint, constraint_id.
constraints --> constraint, constraint_id,
[atom(’,’)], constraints.
constraint --> compound_term.
constraint_id --> [].
constraint_id --> [atom(’#’)], variable.
constraint_id --> [atom(’#’)], [atom(’passive’)] .
guard --> [] ; goal, [atom(’|’)].
body --> goal.
pragma --> [].
pragma --> [atom(’pragma’)], actual_pragmas.
actual_pragmas --> actual_pragma.
actual_pragmas --> actual_pragma, [atom(’,’)], actual_pragmas.
actual_pragma --> [atom(’passive(’)], variable, [atom(’)’)].
Note that the guard of a rule may not contain any goal that binds a variable in the head of the rule with
a non-variable or with another variable in the head of the rule. It may, however, bind variables that do
not appear in the head of the rule, e.g. an auxiliary variable introduced in the guard.
SWI-Prolog 6.6 Reference Manual

228
CHAPTER 7. CHR: CONSTRAINT HANDLING RULES
7.2.2
Semantics
In this subsection the operational semantics of CHR in Prolog are presented informally. They do not
differ essentially from other CHR systems.
When a constraint is called, it is considered an active constraint and the system will try to apply
the rules to it. Rules are tried and executed sequentially in the order they are written.
A rule is conceptually tried for an active constraint in the following way. The active constraint
is matched with a constraint in the head of the rule. If more constraints appear in the head, they are
looked for among the suspended constraints, which are called passive constraints in this context. If
the necessary passive constraints can be found and all match with the head of the rule and the guard of
the rule succeeds, then the rule is committed and the body of the rule executed. If not all the necessary
passive constraints can be found, or the matching or the guard fails, then the body is not executed and
the process of trying and executing simply continues with the following rules. If for a rule there are
multiple constraints in the head, the active constraint will try the rule sequentially multiple times, each
time trying to match with another constraint.
This process ends either when the active constraint disappears, i.e. it is removed by some rule, or
after the last rule has been processed. In the latter case the active constraint becomes suspended.
A suspended constraint is eligible as a passive constraint for an active constraint. The other way
it may interact again with the rules is when a variable appearing in the constraint becomes bound to
either a non-variable or another variable involved in one or more constraints. In that case the constraint
is triggered, i.e. it becomes an active constraint and all the rules are tried.
Rule Types
There are three different kinds of rules, each with its speciﬁc semantics:
• simpliﬁcation
The simpliﬁcation rule removes the constraints in its head and calls its body.
• propagation
The propagation rule calls its body exactly once for the constraints in its head.
• simpagation
The simpagation rule removes the constraints in its head after the \ and then calls its body. It is
an optimization of simpliﬁcation rules of the form:
constraints1, constraints2 <=> constraints1, body
Namely, in the simpagation form:
constraints1\constraints2 <=> body
The constraints1 constraints are not called in the body.
Rule Names
Naming a rule is optional and has no semantic meaning. It only functions as documen-
tation for the programmer.
Pragmas
The semantics of the pragmas are:
passive(Identiﬁer)
The constraint in the head of a rule Identiﬁer can only match a passive constraint in that rule.
There is an abbreviated syntax for this pragma. Instead of:
SWI-Prolog 6.6 Reference Manual

7.3. CHR IN SWI-PROLOG PROGRAMS
229
..., c # Id, ... <=> ... pragma passive(Id)
you can also write
..., c # passive, ... <=> ...
Additional pragmas may be released in the future.
:- chr option(+Option, +Value)
It is possible to specify options that apply to all the CHR rules in the module. Options are
speciﬁed with the chr option/2 declaration:
:- chr_option(Option,Value).
and may appear in the ﬁle anywhere after the ﬁrst constraints declaration.
Available options are:
check guard bindings
This option controls whether guards should be checked for (illegal) variable bindings or
not. Possible values for this option are on to enable the checks, and off to disable the
checks. If this option is on, any guard fails when it binds a variable that appears in the
head of the rule. When the option is off (default), the behaviour of a binding in the guard
is undeﬁned.
optimize
This option controls the degree of optimization. Possible values are full to enable
all available optimizations, and off (default) to disable all optimizations. The default
is derived from the SWI-Prolog ﬂag optimise, where true is mapped to full.
Therefore the command line option -O provides full CHR optimization. If optimization
is enabled, debugging must be disabled.
debug
This option enables or disables the possibility to debug the CHR code. Possible values
are on (default) and off. See section 7.4 for more details on debugging. The default is
derived from the Prolog ﬂag generate debug info, which is true by default. See
-nodebug. If debugging is enabled, optimization must be disabled.
7.3
CHR in SWI-Prolog Programs
7.3.1
Embedding in Prolog Programs
The CHR constraints deﬁned in a .pl ﬁle are associated with a module. The default module is user.
One should never load different .pl ﬁles with the same CHR module name.
SWI-Prolog 6.6 Reference Manual

230
CHAPTER 7. CHR: CONSTRAINT HANDLING RULES
7.3.2
Constraint declaration
:- chr constraint(+Speciﬁer)
Every constraint used in CHR rules has to be declared with a chr constraint/1 decla-
ration by the constraint speciﬁer. For convenience multiple constraints may be declared at
once with the same chr constraint/1 declaration followed by a comma-separated list of
constraint speciﬁers.
A constraint speciﬁer is, in its compact form, F/A where F and A are respectively the functor
name and arity of the constraint, e.g.:
:- chr_constraint foo/1.
:- chr_constraint bar/2, baz/3.
In its extended form, a constraint speciﬁer is c(A1,...,An) where c is the constraint’s func-
tor, n its arity and the Ai are argument speciﬁers. An argument speciﬁer is a mode, optionally
followed by a type. Example:
:- chr_constraint get_value(+,?).
:- chr_constraint domain(?int, +list(int)),
alldifferent(?list(int)).
Modes
A mode is one of:
-
The corresponding argument of every occurrence of the constraint is always unbound.
+
The corresponding argument of every occurrence of the constraint is always ground.
?
The corresponding argument of every occurrence of the constraint can have any instantiation,
which may change over time. This is the default value.
Types
A type can be a user-deﬁned type or one of the built-in types. A type comprises a (possibly
inﬁnite) set of values. The type declaration for a constraint argument means that for every instance of
that constraint the corresponding argument is only ever bound to values in that set. It does not state
that the argument necessarily has to be bound to a value.
The built-in types are:
int
The corresponding argument of every occurrence of the constraint is an integer number.
dense int
The corresponding argument of every occurrence of the constraint is an integer that can be used
as an array index. Note that if this argument takes values in [0, n], the array takes O(n) space.
ﬂoat
. . . a ﬂoating point number.
SWI-Prolog 6.6 Reference Manual

7.3. CHR IN SWI-PROLOG PROGRAMS
231
number
. . . a number.
natural
. . . a positive integer.
any
The corresponding argument of every occurrence of the constraint can have any type. This is
the default value.
:- chr type(+TypeDeclaration)
User-deﬁned types are algebraic data types, similar to those in Haskell or the discriminated
unions in Mercury. An algebraic data type is deﬁned using chr type/1:
:- chr_type type ---> body.
If the type term is a functor of arity zero (i.e. one having zero arguments), it names a monomor-
phic type. Otherwise, it names a polymorphic type; the arguments of the functor must be distinct
type variables. The body term is deﬁned as a sequence of constructor deﬁnitions separated by
semi-colons.
Each constructor deﬁnition must be a functor whose arguments (if any) are types. Discriminated
union deﬁnitions must be transparent: all type variables occurring in the body must also occur
in the type.
Here are some examples of algebraic data type deﬁnitions:
:- chr_type color ---> red ; blue ; yellow ; green.
:- chr_type tree --->
empty ; leaf(int) ; branch(tree, tree).
:- chr_type list(T) ---> [] ; [T | list(T)].
:- chr_type pair(T1, T2) ---> (T1 - T2).
Each algebraic data type deﬁnition introduces a distinct type. Two algebraic data types that
have the same bodies are considered to be distinct types (name equivalence).
Constructors may be overloaded among different types: there may be any number of construc-
tors with a given name and arity, so long as they all have different types.
Aliases can be deﬁned using ==. For example, if your program uses lists of lists of integers,
you can deﬁne an alias as follows:
:- chr_type lli == list(list(int)).
SWI-Prolog 6.6 Reference Manual

232
CHAPTER 7. CHR: CONSTRAINT HANDLING RULES
Type Checking
Currently two complementary forms of type checking are performed:
1. Static type checking is always performed by the compiler. It is limited to CHR rule heads and
CHR constraint calls in rule bodies.
Two kinds of type error are detected. The ﬁrst is where a variable has to belong to two types.
For example, in the program:
:-chr_type foo ---> foo.
:-chr_type bar ---> bar.
:-chr_constraint abc(?foo).
:-chr_constraint def(?bar).
foobar @ abc(X) <=> def(X).
the variable X has to be of both type foo and bar. This is reported as a type clash error:
CHR compiler ERROR:
‘--> Type clash for variable _ in rule foobar:
expected type foo in body goal def(_, _)
expected type bar in head def(_, _)
The second kind of error is where a functor is used that does not belong to the declared type.
For example in:
:- chr_type foo ---> foo.
:- chr_type bar ---> bar.
:- chr_constraint abc(?foo).
foo @ abc(bar) <=> true.
bar appears in the head of the rule where something of type foo is expected. This is reported
as:
CHR compiler ERROR:
‘--> Invalid functor in head abc(bar) of rule foo:
found ‘bar’,
expected type ‘foo’!
No runtime overhead is incurred in static type checking.
2. Dynamic type checking checks at runtime, during program execution, whether the arguments
of CHR constraints respect their declared types. The when/2 co-routining library is used to
delay dynamic type checks until variables are instantiated.
The kind of error detected by dynamic type checking is where a functor is used that does not
belong to the declared type. For example, for the program:
SWI-Prolog 6.6 Reference Manual

7.4. DEBUGGING
233
:-chr_type foo ---> foo.
:-chr_constraint abc(?foo).
we get the following error in an erroneous query:
?- abc(bar).
ERROR: Type error: ‘foo’ expected, found ‘bar’
(CHR Runtime Type Error)
Dynamic type checking is weaker than static type checking in the sense that it only checks the
particular program execution at hand rather than all possible executions. It is stronger in the
sense that it tracks types throughout the whole program.
Note that it is enabled only in debug mode, as it incurs some (minor) runtime overhead.
7.3.3
Compilation
The SWI-Prolog CHR compiler exploits term expansion/2 rules to translate the constraint han-
dling rules to plain Prolog. These rules are loaded from the library chr. They are activated if the
compiled ﬁle has the .chr extension or after ﬁnding a declaration in the following format:
:- chr_constraint ...
It is advised to deﬁne CHR rules in a module ﬁle, where the module declaration is immediately
followed by including the library(chr) library as exempliﬁed below:
:- module(zebra, [ zebra/0 ]).
:- use_module(library(chr)).
:- chr_constraint ...
Using this style, CHR rules can be deﬁned in ordinary Prolog .pl ﬁles and the operator deﬁnitions
required by CHR do not leak into modules where they might cause conﬂicts.
7.4
Debugging
The CHR debugging facilities are currently rather limited. Only tracing is currently available. To use
the CHR debugging facilities for a CHR ﬁle it must be compiled for debugging. Generating debug
info is controlled by the CHR option debug, whose default is derived from the SWI-Prolog ﬂag
generate debug info. Therefore debug info is provided unless the -nodebug is used.
SWI-Prolog 6.6 Reference Manual

234
CHAPTER 7. CHR: CONSTRAINT HANDLING RULES
7.4.1
Ports
For CHR constraints the four standard ports are deﬁned:
call
A new constraint is called and becomes active.
exit
An active constraint exits: it has either been inserted in the store after trying all rules or has
been removed from the constraint store.
fail
An active constraint fails.
redo
An active constraint starts looking for an alternative solution.
In addition to the above ports, CHR constraints have ﬁve additional ports:
wake
A suspended constraint is woken and becomes active.
insert
An active constraint has tried all rules and is suspended in the constraint store.
remove
An active or passive constraint is removed from the constraint store.
try
An active constraint tries a rule with possibly some passive constraints. The try port is entered
just before committing to the rule.
apply
An active constraint commits to a rule with possibly some passive constraints. The apply port
is entered just after committing to the rule.
7.4.2
Tracing
Tracing is enabled with the chr trace/0 predicate and disabled with the chr notrace/0 pred-
icate.
When enabled the tracer will step through the call, exit, fail, wake and apply ports,
accepting debug commands, and simply write out the other ports.
The following debug commands are currently supported:
CHR debug options:
<cr>
creep
c
creep
s
skip
g
ancestors
n
nodebug
b
break
SWI-Prolog 6.6 Reference Manual

7.4. DEBUGGING
235
a
abort
f
fail
?
help
h
help
Their meaning is:
creep
Step to the next port.
skip
Skip to exit port of this call or wake port.
ancestors
Print list of ancestor call and wake ports.
nodebug
Disable the tracer.
break
Enter a recursive Prolog top level. See break/0.
abort
Exit to the top level. See abort/0.
fail
Insert failure in execution.
help
Print the above available debug options.
7.4.3
CHR Debugging Predicates
The chr module contains several predicates that allow inspecting and printing the content of the
constraint store.
chr trace
Activate the CHR tracer. By default the CHR tracer is activated and deactivated automatically
by the Prolog predicates trace/0 and notrace/0.
chr notrace
Deactivate the CHR tracer. By default the CHR tracer is activated and deactivated automatically
by the Prolog predicates trace/0 and notrace/0.
chr leash(+Spec)
Deﬁne the set of CHR ports on which the CHR tracer asks for user intervention (i.e. stops).
Spec is either a list of ports as deﬁned in section 7.4.1 or a predeﬁned ‘alias’. Deﬁned aliases
are: full to stop at all ports, none or off to never stop, and default to stop at the call,
exit, fail, wake and apply ports. See also leash/1.
SWI-Prolog 6.6 Reference Manual

236
CHAPTER 7. CHR: CONSTRAINT HANDLING RULES
chr show store(+Mod)
Prints all suspended constraints of module Mod to the standard output. This predicate is auto-
matically called by the SWI-Prolog top level at the end of each query for every CHR module
currently loaded. The Prolog ﬂag chr toplevel show store controls whether the top
level shows the constraint stores. The value true enables it. Any other value disables it.
ﬁnd chr constraint(-Constraint)
Returns a constraint in the constraint store. Via backtracking, all constraints in the store can be
enumerated.
7.5
Examples
Here are two example constraint solvers written in CHR.
• The program below deﬁnes a solver with one constraint, leq/2/, which is a less-than-or-
equal constraint, also known as a partial order constraint.
:- module(leq,[leq/2]).
:- use_module(library(chr)).
:- chr_constraint leq/2.
reflexivity
@ leq(X,X) <=> true.
antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.
idempotence
@ leq(X,Y) \ leq(X,Y) <=> true.
transitivity @ leq(X,Y), leq(Y,Z) ==> leq(X,Z).
When the above program is saved in a ﬁle and loaded in SWI-Prolog, you can call the leq/2
constraints in a query, e.g.:
?- leq(X,Y), leq(Y,Z).
leq(_G23837, _G23841)
leq(_G23838, _G23841)
leq(_G23837, _G23838)
true .
When the query succeeds, the SWI-Prolog top level prints the content of the CHR constraint
store and displays the bindings generated during the query. Some of the query variables may
have been bound to attributed variables, as you see in the above example.
• The program below implements a simple ﬁnite domain constraint solver.
:- module(dom,[dom/2]).
:- use_module(library(chr)).
:- chr_constraint dom(?int,+list(int)).
:- chr_type list(T) ---> [] ; [T|list(T)].
SWI-Prolog 6.6 Reference Manual

7.6. BACKWARDS COMPATIBILITY
237
dom(X,[]) <=> fail.
dom(X,[Y]) <=> X = Y.
dom(X,L) <=> nonvar(X) | memberchk(X,L).
dom(X,L1), dom(X,L2) <=> intersection(L1,L2,L3), dom(X,L3).
When the above program is saved in a ﬁle and loaded in SWI-Prolog, you can call the dom/2
constraints in a query, e.g.:
?- dom(A,[1,2,3]), dom(A,[3,4,5]).
A = 3.
7.6
Backwards Compatibility
7.6.1
The Old SICStus CHR implemenation
There are small differences between the current K.U.Leuven CHR system in SWI-Prolog, older ver-
sions of the same system, and SICStus’ CHR system.
The current system maps old syntactic elements onto new ones and ignores a number of no longer
required elements. However, for each a deprecated warning is issued. You are strongly urged to
replace or remove deprecated features.
Besides differences in available options and pragmas, the following differences should be noted:
• The constraints/1 declaration
This declaration is deprecated. It has been replaced with the chr constraint/1 declara-
tion.
• The option/2 declaration
This declaration is deprecated. It has been replaced with the chr option/2 declaration.
• The handler/1 declaration
In SICStus every CHR module requires a handler/1 declaration declaring a unique handler
name. This declaration is valid syntax in SWI-Prolog, but will have no effect. A warning will
be given during compilation.
• The rules/1 declaration
In SICStus, for every CHR module it is possible to only enable a subset of the available rules
through the rules/1 declaration. The declaration is valid syntax in SWI-Prolog, but has no
effect. A warning is given during compilation.
• Guard bindings
The check guard bindings option only turns invalid calls to uniﬁcation into failure. In
SICStus this option does more: it intercepts instantiation errors from Prolog built-ins such as
is/2 and turns them into failure. In SWI-Prolog, we do not go this far, as we like to separate
concerns more. The CHR compiler is aware of the CHR code, the Prolog system, and the
programmer should be aware of the appropriate meaning of the Prolog goals used in guards and
bodies of CHR rules.
SWI-Prolog 6.6 Reference Manual

238
CHAPTER 7. CHR: CONSTRAINT HANDLING RULES
7.6.2
The Old ECLiPSe CHR implemenation
The old ECLiPSe CHR implementation features a label with/1 construct for labeling variables
in CHR constraints. This feature has long since been abandoned. However, a simple transformation
is all that is required to port the functionality.
label_with Constraint1 if Condition1.
...
label_with ConstraintN if ConditionN.
Constraint1 :- Body1.
...
ConstraintN :- BodyN.
is transformed into
:- chr_constraint my_labeling/0.
my_labeling \ Constraint1 <=> Condition1 | Body1.
...
my_labeling \ ConstraintN <=> ConditionN | BodyN.
my_labeling <=> true.
Be sure to put this code after all other rules in your program! With my labeling/0 (or another
predicate name of your choosing) the labeling is initiated, rather than ECLiPSe’s chr labeling/0.
7.7
Programming Tips and Tricks
In this section we cover several guidelines on how to use CHR to write constraint solvers and how to
do so efﬁciently.
• Check guard bindings yourself
It is considered bad practice to write guards that bind variables of the head and to rely on the
system to detect this at runtime. It is inefﬁcient and obscures the working of the program.
• Set semantics
The CHR system allows the presence of identical constraints, i.e. multiple constraints with the
same functor, arity and arguments. For most constraint solvers, this is not desirable: it affects
efﬁciency and possibly termination. Hence appropriate simpagation rules should be added of
the form:
constraint\constraint <=> true
• Multi-headed rules
Multi-headed rules are executed more efﬁciently when the constraints share one or more vari-
ables.
• Mode and type declarations
Provide mode and type declarations to get more efﬁcient program execution. Make sure to
disable debug (-nodebug) and enable optimization (-O).
SWI-Prolog 6.6 Reference Manual

7.8. COMPILER ERRORS AND WARNINGS
239
• Compile once, run many times
Does consulting your CHR program take a long time in SWI-Prolog? Probably it takes the
CHR compiler a long time to compile the CHR rules into Prolog code. When you disable opti-
mizations the CHR compiler will be a lot quicker, but you may lose performance. Alternatively,
you can just use SWI-Prolog’s qcompile/1 to generate a .qlf ﬁle once from your .pl ﬁle.
This .qlf contains the generated code of the CHR compiler (be it in a binary format). When
you consult the .qlf ﬁle, the CHR compiler is not invoked and consultation is much faster.
• Finding Constraints
The find chr constraint/1 predicate is fairly expensive. Avoid it, if possible. If you
must use it, try to use it with an instantiated top-level constraint symbol.
7.8
Compiler Errors and Warnings
In this section we summarize the most important error and warning messages of the CHR compiler.
7.8.1
CHR Compiler Errors
Type clash for variable ... in rule ...
This error indicates an inconsistency between declared types; a variable can not belong to two
types. See static type checking.
Invalid functor in head ... of rule ...
This error indicates an inconsistency between a declared type and the use of a functor in a rule.
See static type checking.
Cyclic alias deﬁnition: ... == ...
You have deﬁned a type alias in terms of itself, either directly or indirectly.
Ambiguous type aliases You have deﬁned two overlapping type aliases.
Multiple deﬁnitions for type
You have deﬁned the same type multiple times.
Non-ground type in constraint deﬁnition: ...
You have declared a non-ground type for a constraint argument.
Could not ﬁnd type deﬁnition for ...
You have used an undeﬁned type in a type declaration.
Illegal mode/type declaration You have used invalid syntax in a constraint declaration.
Constraint multiply deﬁned There is more than one declaration for the same constraint.
Undeclared constraint ... in head of ...
You have used an undeclared constraint in the head of a rule. This often indicates a misspelled
constraint name or wrong number of arguments.
SWI-Prolog 6.6 Reference Manual

240
CHAPTER 7. CHR: CONSTRAINT HANDLING RULES
Invalid pragma ... in ... Pragma should not be a variable.
You have used a variable as a pragma in a rule. This is not allowed.
Invalid identiﬁer ... in pragma passive in ...
You have used an identiﬁer in a passive pragma that does not correspond to an identiﬁer in the
head of the rule. Likely the identiﬁer name is misspelled.
Unknown pragma ... in ...
You have used an unknown pragma in a rule. Likely the pragma is misspelled or not supported.
Something unexpected happened in the CHR compiler
You have most likely bumped into a bug in the CHR compiler. Please contact Tom Schrijvers
to notify him of this error.
SWI-Prolog 6.6 Reference Manual

Multithreaded applications 8
SWI-Prolog multithreading is based on standard C language multithreading support. It is not like
ParLog or other parallel implementations of the Prolog language. Prolog threads have their own
stacks and only share the Prolog heap: predicates, records, ﬂags and other global non-backtrackable
data. SWI-Prolog thread support is designed with the following goals in mind.
• Multithreaded server applications
Today’s computing services often focus on (internet) server applications. Such applications
often have need for communication between services and/or fast non-blocking service to mul-
tiple concurrent clients. The shared heap provides fast communication, and thread creation is
relatively cheap.1
• Interactive applications
Interactive applications often need to perform extensive computation. If such computations are
executed in a new thread, the main thread can process events and allow the user to cancel the
ongoing computation. User interfaces can also use multiple threads, each thread dealing with
input from a distinct group of windows. See also section 8.7.
• Natural integration with foreign code
Each Prolog thread runs in a native thread of the operating system, automatically making them
cooperate with MT-safe foreign code. In addition, any foreign thread can create its own Prolog
engine for dealing with calling Prolog from C code.
SWI-Prolog multithreading is based on the POSIX thread standard [Butenhof, 1997] used on most
popular systems except for MS-Windows. On Windows it uses the pthread-win32 emulation of POSIX
threads mixed with the Windows native API for smoother and faster operation.
8.1
Creating and destroying Prolog threads
thread create(:Goal, -Id, +Options)
Create a new Prolog thread (and underlying C thread) and start it by executing Goal. If the
thread is created successfully, the thread identiﬁer of the created thread is uniﬁed to Id. Options
is a list of options. The currently deﬁned options are below. Stack size options can also take
the value inf or infinite, which is mapped to the maximum stack size supported by the
platform.
alias(AliasName)
Associate an ‘alias name’ with the thread. This name may be used to refer to the thread
and remains valid until the thread is joined (see thread join/2).
1On an Intel i7-2600K, running Ubuntu Linux 12.04, SWI-Prolog 6.2 creates and joins 32,000 threads per second elapsed
time.
SWI-Prolog 6.6 Reference Manual

242
CHAPTER 8. MULTITHREADED APPLICATIONS
at exit(:AtExit)
Register AtExit as using thread at exit/1 before entering the thread goal. Unlike
calling thread at exit/1 as part of the normal Goal, this ensures the Goal is called.
Using thread at exit/1, the thread may be signalled or run out of resources before
thread at exit/1 is reached.
detached(Bool)
If
false
(default),
the
thread
can
be
waited
for
using
thread join/2.
thread join/2 must be called on this thread to reclaim all resources associated
with the thread. If true, the system will reclaim all associated resources automatically
after the thread ﬁnishes. Please note that thread identiﬁers are freed for reuse after a
detached thread ﬁnishes or a normal thread has been joined. See also thread join/2
and thread detach/1.
If a detached thread dies due to failure or exception of the initial goal, the thread prints a
message using print message/2. If such termination is considered normal, the code
must be wrapped using ignore/1 and/or catch/3 to ensure successful completion.
inherit from(+ThreadId)
Inherit
defaults
from
the
given
ThreadId
instead
of
the
calling
thread.
This
option
was
added
to
ensure
that
the
thread pool manager
(see
thread create in pool/4), which is created lazily, has a predictable state.
The following properties are inherited:
• The prompt (see prompt/2)
• The typein module (see module/1)
• The standard streams (user input, etc.)
• The default encoding (see encoding)
• The default locale (see setlocale/1)
• All prolog ﬂags
• The limits of Prolog stacks (see set prolog stack/2)
global(K-Bytes)
Set the limit to which the global stack of this thread may grow. If omitted, the limit of the
calling thread is used. See also the -G command line option.
local(K-Bytes)
Set the limit to which the local stack of this thread may grow. If omitted, the limit of the
calling thread is used. See also the -L command line option.
c stack(K-Bytes)
Set the limit to which the system stack of this thread may grow. The default, minimum
and maximum values are system-dependent.2.
trail(K-Bytes)
Set the limit to which the trail stack of this thread may grow. If omitted, the limit of the
calling thread is used. See also the -T command line option.
The Goal argument is copied to the new Prolog engine. This implies that further instantiation
of this term in either thread does not have consequences for the other thread: Prolog threads do
not share data from their stacks.
2Older versions used stack. This is still accepted as a synonym.
SWI-Prolog 6.6 Reference Manual

8.1. CREATING AND DESTROYING PROLOG THREADS
243
thread self(-Id)
Get the Prolog thread identiﬁer of the running thread. If the thread has an alias, the alias name
is returned.
thread join(+Id, -Status)
Wait for the termination of the thread with the given Id. Then unify the result status of the
thread with Status. After this call, Id becomes invalid and all resources associated with the
thread are reclaimed. Note that threads with the attribute detached(true) cannot be joined.
See also thread property/2.
A thread that has been completed without thread join/2 being called on it is partly re-
claimed: the Prolog stacks are released and the C thread is destroyed. A small data structure
representing the exit status of the thread is retained until thread join/2 is called on the
thread. Deﬁned values for Status are:
true
The goal has been proven successfully.
false
The goal has failed.
exception(Term)
The thread is terminated on an exception.
See print message/2 to turn system
exceptions into readable messages.
exited(Term)
The thread is terminated on thread exit/1 using the argument Term.
thread detach(+Id)
Switch thread into detached state (see detached(Bool) option at thread create/3) at
runtime. Id is the identiﬁer of the thread placed in detached state. This may be the result of
thread self/1.
One of the possible applications is to simplify debugging. Threads that are created as de-
tached leave no traces if they crash. For non-detached threads the status can be inspected using
thread property/2. Threads nobody is waiting for may be created normally and detach
themselves just before completion. This way they leave no traces on normal completion and
their reason for failure can be inspected.
thread exit(+Term)
[deprecated]
Terminates
the
thread
immediately,
leaving
exited(Term)
as
result
state
for
thread join/2.
If the thread has the attribute detached(true) it terminates, but its
exit status cannot be retrieved using thread join/2, making the value of Term irrelevant.
The Prolog stacks and C thread are reclaimed.
The current implementation does not guarantee proper releasing of all mutexes and proper
cleanup in setup call cleanup/3, etc. Please use the exception mechanism (throw/1)
to abort execution using non-standard control.
thread initialization(:Goal)
Run Goal when thread is started. This predicate is similar to initialization/1, but is
intended for initialization operations of the runtime stacks, such as setting global variables
SWI-Prolog 6.6 Reference Manual

244
CHAPTER 8. MULTITHREADED APPLICATIONS
as described in section 6.3. Goal is run on four occasions: at the call to this predicate, after
loading a saved state, on starting a new thread and on creating a Prolog engine through the C
interface. On loading a saved state, Goal is executed after running the initialization/1
hooks.
thread at exit(:Goal)
Run Goal just before releasing the thread resources. This is to be compared to at halt/1, but
only for the current thread. These hooks are run regardless of why the execution of the thread
has been completed. When these hooks are run, the return code is already available through
thread property/2 using the result of thread self/1 as thread identiﬁer. Note that
there are two scenarios for using exit hooks. Using thread at exit/1 is typically used
if the thread creates a side-effect that must be reverted if the thread dies. Another scenario is
where the creator of the thread wants to be informed when the thread ends. That cannot be
guaranteed by means of thread at exit/1 because it is possible that the thread cannot be
created or dies almost instantly due to a signal or resource error. The at exit(Goal) option
of thread create/3 is designed to deal with this scenario.
thread setconcurrency(-Old, +New)
Determine the concurrency of the process, which is deﬁned as the maximum number of con-
currently active threads. ‘Active’ here means they are using CPU time. This option is provided
if the thread implementation provides pthread setconcurrency(). Solaris is a typical example of
this family. On other systems this predicate uniﬁes Old to 0 (zero) and succeeds silently.
8.2
Monitoring threads
Normal multithreaded applications should not need the predicates from this section because almost
any usage of these predicates is unsafe. For example checking the existence of a thread before sig-
nalling it is of no use as it may vanish between the two calls. Catching exceptions using catch/3 is
the only safe way to deal with thread-existence errors.
These predicates are provided for diagnosis and monitoring tasks. See also section 8.5, describing
more high-level primitives.
thread property(?Id, ?Property)
True if thread Id has Property. Either or both arguments may be unbound, enumerating all
relations on backtracking. Calling thread property/2 does not inﬂuence any thread. See
also thread join/2. For threads that have an alias name, this name is returned in Id instead
of the opaque thread identiﬁer. Deﬁned properties are:
alias(Alias)
Alias is the alias name of thread Id.
detached(Boolean)
Current detached status of the thread.
status(Status)
Current status of the thread. Status is one of:
running
The thread is running. This is the initial status of a thread. Please note that threads
waiting for something are considered running too.
SWI-Prolog 6.6 Reference Manual

8.3. THREAD COMMUNICATION
245
false
The Goal of the thread has been completed and failed.
true
The Goal of the thread has been completed and succeeded.
exited(Term)
The Goal of the thread has been terminated using thread exit/1 with Term as
argument. If the underlying native thread has exited (using pthread exit()) Term is
unbound.
exception(Term)
The Goal of the thread has been terminated due to an uncaught exception (see
throw/1 and catch/3).
See
also
thread statistics/3
to
obtain
resource
usage
information
and
message queue property/2 to get the number of queued messages for a thread.
thread statistics(+Id, +Key, -Value)
Obtains statistical information on thread Id as statistics/2 does in single-threaded appli-
cations. This call supports all keys of statistics/2, although only stack sizes and CPU
time yield different values for each thread.3
mutex statistics
Print usage statistics on internal mutexes and mutexes associated with dynamic predicates.
For each mutex two numbers are printed: the number of times the mutex was acquired and
the number of collisions: the number of times the calling thread has to wait for the mutex.
Generally collision count is close to zero on single-CPU hardware.
8.3
Thread communication
8.3.1
Message queues
Prolog threads can exchange data using dynamic predicates, database records, and other globally
shared data. These provide no suitable means to wait for data or a condition as they can only be
checked in an expensive polling loop. Message queues provide a means for threads to wait for data or
conditions without using the CPU.
Each thread has a message queue attached to it that is identiﬁed by the thread. Additional queues
are created using message queue create/1.
thread send message(+QueueOrThreadId, +Term)
Place Term in the given queue or default queue of the indicated thread (which can even be the
message queue of itself, see thread self/1). Any term can be placed in a message queue,
but note that the term is copied to the receiving thread and variable bindings are thus lost. This
call returns immediately.
If more than one thread is waiting for messages on the given queue and at least one of these
is waiting with a partially instantiated Term, the waiting threads are all sent a wake-up signal,
3There is no portable interface to obtain thread-speciﬁc CPU time and some operating systems provide no access to this
information at all. On such systems the total process CPU is returned. Thread CPU time is supported on MS-Windows,
Linux and MacOSX.
SWI-Prolog 6.6 Reference Manual

246
CHAPTER 8. MULTITHREADED APPLICATIONS
starting a rush for the available messages in the queue. This behaviour can seriously harm
performance with many threads waiting on the same queue as all-but-the-winner perform a
useless scan of the queue. If there is only one waiting thread or all waiting threads wait with an
unbound variable, an arbitrary thread is restarted to scan the queue.4
thread get message(?Term)
Examines the thread message queue and if necessary blocks execution until a term that uniﬁes
to Term arrives in the queue. After a term from the queue has been uniﬁed to Term, the term is
deleted from the queue.
Please note that non-unifying messages remain in the queue. After the following has been
executed, thread 1 has the term b(gnu) in its queue and continues execution using A = gnat.
<thread 1>
thread_get_message(a(A)),
<thread 2>
thread_send_message(Thread_1, b(gnu)),
thread_send_message(Thread_1, a(gnat)),
See also thread peek message/1.
thread peek message(?Term)
Examines the thread message queue and compares the queued terms with Term until
one uniﬁes or the end of the queue has been reached.
In the ﬁrst case the call suc-
ceeds, possibly instantiating Term. If no term from the queue uniﬁes, this call fails. I.e.,
thread peek message/1 never waits and does not remove any term from the queue. See
also thread get message/3.
message queue create(?Queue)
If
Queue
is
an
atom,
create
a
named
queue.
To
avoid
ambiguity
of
thread send message/2, the name of a queue may not be in use as a thread name.
If Queue is unbound an anonymous queue is created and Queue is uniﬁed to its identiﬁer.
message queue create(-Queue, +Options)
Create a message queue from Options. Deﬁned options are:
alias(+Alias)
Same as message queue create(Alias), but according to the ISO draft on Prolog
threads.
max size(+Size)
Maximum
number
of
terms
in
the
queue.
If
this
number
is
reached,
thread send message/2 will suspend until the queue is drained.
The option
can be used if the source, sending messages to the queue, is faster than the drain,
consuming the messages.
4See the documentation for the POSIX thread functions pthread cond signal() v.s. pthread cond broadcast() for back-
ground information.
SWI-Prolog 6.6 Reference Manual

8.3. THREAD COMMUNICATION
247
message queue destroy(+Queue)
[det]
Destroy a message queue created with message queue create/1. A permission error
is raised if Queue refers to (the default queue of) a thread. Other threads that are waiting for
Queue using thread get message/2 receive an existence error.
thread get message(+Queue, ?Term)
[det]
As thread get message/1, operating on a given queue. It is allowed (but not advised)
to get messages from the queue of other threads.
This predicate raises an existence error
exception if Queue doesn’t exist or is destroyed using message queue destroy/1 while
this predicate is waiting.
thread get message(+Queue, ?Term, +Options)
[semidet]
As thread get message/2, but providing additional Options:
deadline(+AbsTime)
The call fails (silently) if no message has arrived before AbsTime. See get time/1
for the representation of absolute time.
If AbsTime is earlier then the current time,
thread get message/3 fails immediately. Both resolution and maximum wait time
is platform-dependent.5
timeout(+Time)
Time is a ﬂoat or integer and speciﬁes the maximum time to wait in seconds. This is a
relative-time version of the deadline option. If both options are provided, the earliest
time is effective.
It Time is 0 or 0.0, thread get message/3 examines the queue but does not sus-
pend if no matching term is available. Note that unlike thread peek message/2, a
matching term is removed from the queue.
It Time < 0, thread get message/3 fails immediately.
thread peek message(+Queue, ?Term)
[semidet]
As thread peek message/1, operating on a given queue. It is allowed to peek into an-
other thread’s message queue, an operation that can be used to check whether a thread has
swallowed a message sent to it.
message queue property(?Queue, ?Property)
True if Property is a property of Queue. Deﬁned properties are:
alias(Alias)
Queue has the given alias name.
max size(Size)
Maximum number of terms that can be in the queue. See message queue create/2.
This property is not present if there is no limit (default).
size(Size)
Queue currently contains Size terms. Note that due to concurrent access the returned
value may be outdated before it is returned. It can be used for debugging purposes as well
as work distribution purposes.
5The implementation uses MsgWaitForMultipleObjects() on MS-Windows and pthread cond timedwait() on other sys-
tems.
SWI-Prolog 6.6 Reference Manual

248
CHAPTER 8. MULTITHREADED APPLICATIONS
The size(Size) property is always present and may be used to enumerate the created message
queues. Note that this predicate does not enumerate threads, but can be used to query the
properties of the default queue of a thread.
Explicit message queues are designed with the worker-pool model in mind, where multiple threads
wait on a single queue and pick up the ﬁrst goal to execute. Below is a simple implementation where
the workers execute arbitrary Prolog goals. Note that this example provides no means to tell when all
work is done. This must be realised using additional synchronisation.
%%
create_workers(?Id, +N)
%
%
Create a pool with Id and number of workers.
%
After the pool is created, post_job/1 can be used to
%
send jobs to the pool.
create_workers(Id, N) :-
message_queue_create(Id),
forall(between(1, N, _),
thread_create(do_work(Id), _, [])).
do_work(Id) :-
repeat,
thread_get_message(Id, Goal),
(
catch(Goal, E, print_message(error, E))
->
true
;
print_message(error, goal_failed(Goal, worker(Id)))
),
fail.
%%
post_job(+Id, +Goal)
%
%
Post a job to be executed by one of the pool’s workers.
post_job(Id, Goal) :-
thread_send_message(Id, Goal).
8.3.2
Signalling threads
These predicates provide a mechanism to make another thread execute some goal as an interrupt.
Signalling threads is safe as these interrupts are only checked at safe points in the virtual machine.
Nevertheless, signalling in multithreaded environments should be handled with care as the receiving
thread may hold a mutex (see with mutex/2). Signalling probably only makes sense to start de-
bugging threads and to cancel no-longer-needed threads with throw/1, where the receiving thread
should be designed carefully to handle exceptions at any point.
thread signal(+ThreadId, :Goal)
Make thread ThreadId execute Goal at the ﬁrst opportunity. In the current implementation, this
SWI-Prolog 6.6 Reference Manual

8.3. THREAD COMMUNICATION
249
implies at the ﬁrst pass through the Call port. The predicate thread signal/2 itself places
Goal into the signalled thread’s signal queue and returns immediately.
Signals (interrupts) do not cooperate well with the world of multithreading, mainly because the
status of mutexes cannot be guaranteed easily. At the call port, the Prolog virtual machine holds
no locks and therefore the asynchronous execution is safe.
Goal can be any valid Prolog goal, including throw/1 to make the receiving thread generate
an exception, and trace/0 to start tracing the receiving thread.
In the Windows version, the receiving thread immediately executes the signal if it reaches a
Windows GetMessage() call, which generally happens if the thread is waiting for (user) input.
8.3.3
Threads and dynamic predicates
Besides queues (section 8.3.1) threads can share and exchange data using dynamic predicates. The
multithreaded version knows about two types of dynamic predicates. By default, a predicate declared
dynamic (see dynamic/1) is shared by all threads. Each thread may assert, retract and run the dy-
namic predicate. Synchronisation inside Prolog guarantees the consistency of the predicate. Updates
are logical: visible clauses are not affected by assert/retract after a query started on the predicate. In
many cases primitives from section 8.4 should be used to ensure that application invariants on the
predicate are maintained.
Besides shared predicates, dynamic predicates can be declared with the thread local/1 di-
rective. Such predicates share their attributes, but the clause list is different in each thread.
thread local +Functor/+Arity, . . .
This directive is related to the dynamic/1 directive. It tells the system that the predicate may
be modiﬁed using assert/1, retract/1, etc., during execution of the program. Unlike
normal shared dynamic data, however, each thread has its own clause list for the predicate. As
a thread starts, this clause list is empty. If there are still clauses when the thread terminates,
these are automatically reclaimed by the system (see also volatile/1). The thread local
property implies the properties dynamic and volatile.
Thread-local dynamic predicates are intended for maintaining thread-speciﬁc state or interme-
diate results of a computation.
It is not recommended to put clauses for a thread-local predicate into a ﬁle, as in the example
below, because the clause is only visible from the thread that loaded the source ﬁle. All other
threads start with an empty clause list.
:- thread_local
foo/1.
foo(gnat).
DISCLAIMER Whether or not this declaration is appropriate in the sense of the proper mech-
anism to reach the goal is still debated. If you have strong feelings in favour or against, please
share them in the SWI-Prolog mailing list.
SWI-Prolog 6.6 Reference Manual

250
CHAPTER 8. MULTITHREADED APPLICATIONS
8.4
Thread synchronisation
All internal Prolog operations are thread-safe. This implies that two Prolog threads can operate on the
same dynamic predicate without corrupting the consistency of the predicate. This section deals with
user-level mutexes (called monitors in ADA or critical sections by Microsoft). A mutex is a MUTual
EXclusive device, which implies that at most one thread can hold a mutex.
Mutexes are used to realise related updates to the Prolog database. With ‘related’, we refer to
the situation where a ‘transaction’ implies two or more changes to the Prolog database. For example,
we have a predicate address/2, representing the address of a person and we want to change the
address by retracting the old and asserting the new address. Between these two operations the database
is invalid: this person has either no address or two addresses, depending on the assert/retract order.
Here is how to realise a correct update:
:- initialization
mutex_create(addressbook).
change_address(Id, Address) :-
mutex_lock(addressbook),
retractall(address(Id, _)),
asserta(address(Id, Address)),
mutex_unlock(addressbook).
mutex create(?MutexId)
Create a mutex. If MutexId is an atom, a named mutex is created. If it is a variable, an anony-
mous mutex reference is returned. There is no limit to the number of mutexes that can be
created.
mutex create(-MutexId, +Options)
Create a mutex using options. Deﬁned options are:
alias(Alias)
Set the alias name. Using mutex create(X, [alias(name)]) is preferred over the equiv-
alent mutex create(name).
mutex destroy(+MutexId)
Destroy a mutex. After this call, MutexId becomes invalid and further references yield an
existence error exception.
with mutex(+MutexId, :Goal)
Execute Goal while holding MutexId. If Goal leaves choice points, these are destroyed (as
in once/1). The mutex is unlocked regardless of whether Goal succeeds, fails or raises an
exception. An exception thrown by Goal is re-thrown after the mutex has been successfully
unlocked. See also mutex create/1 and setup call cleanup/3.
Although described in the thread section, this predicate is also available in the single-threaded
version, where it behaves simply as once/1.
SWI-Prolog 6.6 Reference Manual

8.5. THREAD SUPPORT LIBRARY(THREADUTIL)
251
mutex lock(+MutexId)
Lock the mutex. Prolog mutexes are recursive mutexes: they can be locked multiple times by
the same thread. Only after unlocking it as many times as it is locked does the mutex become
available for locking by other threads. If another thread has locked the mutex the calling thread
is suspended until the mutex is unlocked.
If MutexId is an atom, and there is no current mutex with that name, the mutex is created
automatically using mutex create/1. This implies named mutexes need not be declared
explicitly.
Please note that locking and unlocking mutexes should be paired carefully. Especially make
sure to unlock mutexes even if the protected code fails or raises an exception. For most common
cases, use with mutex/2, which provides a safer way for handling Prolog-level mutexes. The
predicate setup call cleanup/3 is another way to guarantee that the mutex is unlocked
while retaining non-determinism.
mutex trylock(+MutexId)
As mutex lock/1, but if the mutex is held by another thread, this predicates fails immedi-
ately.
mutex unlock(+MutexId)
Unlock the mutex. This can only be called if the mutex is held by the calling thread. If this is
not the case, a permission error exception is raised.
mutex unlock all
Unlock all mutexes held by the current thread. This call is especially useful to handle thread
termination using abort/0 or exceptions. See also thread signal/2.
mutex property(?MutexId, ?Property)
True if Property is a property of MutexId. Deﬁned properties are:
alias(Alias)
Mutex has the deﬁned alias name. See mutex create/2 using the ‘alias’ option.
status(Status)
Current status of the mutex. One of unlocked if the mutex is currently not locked,
or locked(Owner, Count) if mutex is locked Count times by thread Owner. Note that
unless Owner is the calling thread, the locked status can change at any time. There is no
useful application of this property, except for diagnostic purposes.6
8.5
Thread support library(threadutil)
This library deﬁnes a couple of useful predicates for demonstrating and debugging multithreaded
applications. This library is certainly not complete.
threads
Lists all current threads and their status.
6BUG: As Owner and Count are fetched separately from the mutex, the values may be inconsistent.
SWI-Prolog 6.6 Reference Manual

252
CHAPTER 8. MULTITHREADED APPLICATIONS
join threads
Join all terminated threads. For normal applications, dealing with terminated threads must be
part of the application logic, either detaching the thread before termination or making sure it
will be joined. The predicate join threads/0 is intended for interactive sessions to reclaim
resources from threads that died unexpectedly during development.
interactor
Create a new console and run the Prolog top level in this new console.
See also
attach console/0.
In the Windows version a new interactor can also be created
from the Run/New thread menu.
8.5.1
Debugging threads
Support for debugging threads is still very limited. Debug and trace mode are ﬂags that are local
to each thread. Individual threads can be debugged either using the graphical debugger described
in section 3.5 (see tspy/1 and friends) or by attaching a console to the thread and running the
traditional command line debugger (see attach console/0). When using the graphical debugger,
the debugger must be loaded from the main thread (for example using guitracer) before gtrace/0
can be called from a thread.
attach console
If the current thread has no console attached yet, attach one and redirect the user streams (input,
output, and error) to the new console window. On Unix systems the console is an xterm
application. On Windows systems this requires the GUI version swipl-win.exe rather than
the console-based swipl.exe.
This predicate has a couple of useful applications. One is to separate (debugging) I/O of differ-
ent threads. Another is to start debugging a thread that is running in the background. If thread
10 is running, the following sequence starts the tracer on this thread:
?- thread_signal(10, (attach_console, trace)).
tdebug(+ThreadId)
Prepare ThreadId for debugging using the graphical tracer. This implies installing the tracer
hooks in the thread and switching the thread to debug mode using debug/0. The call is
injected into the thread using thread signal/2. We refer to the documentation of this
predicate for asynchronous interaction with threads. New threads created inherit their debug
mode from the thread that created them.
tdebug
Call tdebug/1 in all running threads.
tnodebug(+ThreadId)
Disable debugging thread ThreadId.
tnodebug
Disable debugging in all threads.
SWI-Prolog 6.6 Reference Manual

8.6. MULTITHREADED MIXED C AND PROLOG APPLICATIONS
253
tspy(:Spec, +ThreadId)
Set a spy point as spy/1 and enable the thread for debugging using tdebug/1. Note that a
spy point is a global ﬂag on a predicate that is visible from all threads. Spy points are honoured
in all threads that are in debug mode and ignored in threads that are in nodebug mode.
tspy(:Spec)
Set a spy point as spy/1 and enable debugging in all threads using tdebug/0. Note that
removing spy points can be done using nospy/1. Disabling spy points in a speciﬁc thread is
achieved by tnodebug/1.
8.5.2
Proﬁling threads
In the current implementation, at most one thread can be proﬁled at any moment. Any thread can call
profile/1 to proﬁle the execution of some part of its code. The predicate tprofile/1 allows
for proﬁling the execution of another thread until the user stops collecting proﬁle data.
tproﬁle(+ThreadId)
Start collecting proﬁle data in ThreadId and ask the user to hit ⟨return⟩to stop the proﬁler. See
section 4.40 for details on the execution proﬁler.
8.6
Multithreaded mixed C and Prolog applications
All foreign code linked to the multithreading version of SWI-Prolog should be thread-safe (reentrant)
or guarded in Prolog using with mutex/2 from simultaneous access from multiple Prolog threads.
If you want to write mixed multithreaded C and Prolog applications you should ﬁrst familiarise your-
self with writing multithreaded applications in C (C++).
If you are using SWI-Prolog as an embedded engine in a multithreaded application you can access
the Prolog engine from multiple threads by creating an engine in each thread from which you call
Prolog. Without creating an engine, a thread can only use functions that do not use the term t type
(for example PL new atom()).
The system supports two models. Section 8.6.1 describes the original one-to-one mapping. In this
schema a native thread attaches a Prolog thread if it needs to call Prolog and detaches it when ﬁnished,
as opposed to the model from section 8.6.2, where threads temporarily use a Prolog engine.
8.6.1
A Prolog thread for each native thread (one-to-one)
In the one-to-one model, the thread that called PL initialise() has a Prolog engine at-
tached. If another C thread in the system wishes to call Prolog it must ﬁrst attach an engine us-
ing PL thread attach engine() and call PL thread destroy engine() after all Prolog
work is ﬁnished. This model is especially suitable with long running threads that need to do Prolog
work regularly. See section 8.6.2 for the alternative many-to-many model.
int PL thread self()
Returns the integer Prolog identiﬁer of the engine or -1 if the calling thread has no Prolog
engine. This function is also provided in the single-threaded version of SWI-Prolog, where it
returns -2.
SWI-Prolog 6.6 Reference Manual

254
CHAPTER 8. MULTITHREADED APPLICATIONS
int PL unify thread id(term t t, int i)
Unify t with the Prolog thread identiﬁer for thread i. Thread identiﬁers are normally returned
from PL thread self(). Returns -1 if the thread does not exist or the uniﬁcation fails.
int PL thread attach engine(const PL thread attr t *attr)
Creates a new Prolog engine in the calling thread. If the calling thread already has an engine
the reference count of the engine is incremented. The attr argument can be NULL to create a
thread with default attributes. Otherwise it is a pointer to a structure with the deﬁnition below.
For any ﬁeld with value ‘0’, the default is used. The cancel ﬁeld may be ﬁlled with a pointer
to a function that is called when PL cleanup() terminates the running Prolog engines. If
this function is not present or returns FALSE pthread cancel() is used. The flags ﬁeld deﬁnes
the following ﬂags:
PL THREAD NO DEBUG
If this ﬂag is present, the thread starts in normal no-debug status. By default, the debug
status is inherited from the main thread.
typedef struct
{ unsigned long
local_size;
/* Stack sizes (Kbytes) */
unsigned long
global_size;
unsigned long
trail_size;
unsigned long
argument_size;
char *
alias;
/* alias name */
int
(*cancel)(int thread);
intptr_t
flags;
} PL_thread_attr_t;
The structure may be destroyed after PL thread attach engine() has returned. On suc-
cess it returns the Prolog identiﬁer for the thread (as returned by PL thread self()). If an
error occurs, -1 is returned. If this Prolog is not compiled for multithreading, -2 is returned.
int PL thread destroy engine()
Destroy
the
Prolog
engine
in
the
calling
thread.
Only
takes
ef-
fect
if
PL thread destroy engine()
is
called
as
many
times
as
PL thread attach engine() in this thread.
Returns TRUE on success and FALSE
if the calling thread has no engine or this Prolog does not support threads.
Please note that construction and destruction of engines are relatively expensive operations.
Only destroy an engine if performance is not critical and memory is a critical resource.
int PL thread at exit(void (*function)(void *), void *closure, int global)
Register a handle to be called as the Prolog engine is destroyed. The handler function is called
with one void * argument holding closure. If global is TRUE, the handler is installed for all
threads. Globally installed handlers are executed after the thread-local handlers. If the handler
is installed local for the current thread only (global == FALSE) it is stored in the same FIFO
queue as used by thread at exit/1.
SWI-Prolog 6.6 Reference Manual

8.6. MULTITHREADED MIXED C AND PROLOG APPLICATIONS
255
8.6.2
Pooling Prolog engines (many-to-many)
In this model Prolog engines live as entities that are independent from threads. If a thread needs to
call Prolog it takes one of the engines from the pool and returns the engine when done. This model is
suitable in the following identiﬁed cases:
• Compatibility with the single-threaded version
In the single-threaded version, foreign threads must serialise access to the one and only thread
engine. Functions from this section allow sharing one engine among multiple threads.
• Many native threads with infrequent Prolog work
Prolog threads are expensive in terms of memory and time to create and destroy them. For
systems that use a large number of threads that only infrequently need to call Prolog, it is better
to take an engine from a pool and return it there.
• Prolog status must be handed to another thread
This situation has been identiﬁed by Uwe Lesta when creating a .NET interface for SWI-Prolog.
.NET distributes work for an active internet connection over a pool of threads. If a Prolog engine
contains the state for a connection, it must be possible to detach the engine from a thread and
re-attach it to another thread handling the same connection.
PL engine t PL create engine(PL thread attr t *attributes)
Create a new Prolog engine. attributes is described with PL thread attach engine().
Any thread can make this call after PL initialise() returns success. The returned engine
is not attached to any thread and lives until PL destroy engine() is used on the returned
handle.
In the single-threaded version this call always returns NULL, indicating failure.
int PL destroy engine(PL engine t e)
Destroy the given engine. Destroying an engine is only allowed if the engine is not attached to
any thread or attached to the calling thread. On success this function returns TRUE, on failure
the return value is FALSE.
int PL set engine(PL engine t engine, PL engine t *old)
Make the calling thread ready to use engine. If old is non-NULL the current engine associated
with the calling thread is stored at the given location. If engine equals PL ENGINE MAIN the
initial engine is attached to the calling thread. If engine is PL ENGINE CURRENT the engine is
not changed. This can be used to query the current engine. This call returns PL ENGINE SET
if the engine was switched successfully, PL ENGINE INVAL if engine is not a valid engine
handle and PL ENGINE INUSE if the engine is currently in use by another thread.
Engines can be changed at any time. For example, it is allowed to select an engine to initiate
a Prolog goal, detach it and at a later moment execute the goal from another thread. Note,
however, that the term t, qid t and fid t types are interpreted relative to the engine for
which they are created. Behaviour when passing one of these types from one engine to another
is undeﬁned.
In the single-threaded version this call only succeeds if engine refers to the main engine.
SWI-Prolog 6.6 Reference Manual

256
CHAPTER 8. MULTITHREADED APPLICATIONS
8.7
Multithreading and the XPCE graphics system
GUI applications written in XPCE can beneﬁt from Prolog threads if they need to do expensive com-
putations that would otherwise block the UI. The XPCE message passing system is guarded with a
single mutex, which synchronises both access from Prolog and activation through the GUI. In MS-
Windows, GUI events are processed by the thread that created the window in which the event occurred,
whereas in Unix/X11 they are processed by the thread that dispatches messages. In practice, the most
feasible approach to graphical Prolog implementations is to control XPCE from a single thread and
deploy other threads for (long) computations.
Traditionally, XPCE runs in the foreground (main) thread. We are working towards a situation
where XPCE can run comfortably in a separate thread. A separate XPCE thread can be created using
pce dispatch/1. It is also possible to create this thread as the (pce) is loaded by setting the
xpce threaded to true.
Threads other than the thread in which XPCE runs are provided with two predicates to communi-
cate with XPCE.
in pce thread(:Goal)
[det]
Assuming XPCE is running in the foreground thread, this call gives background threads the
opportunity to make calls to the XPCE thread.
A call to in pce thread/1 succeeds
immediately, copying Goal to the XPCE thread. Goal is added to the XPCE event queue and
executed synchronous to normal user events like typing and clicking.
in pce thread sync(:Goal)
[semidet]
Same as in pce thread/1, but wait for Goal to be completed. Success depends on the suc-
cess of executing Goal. Variable bindings inside Goal are visible to the caller, but it should be
noted that the values are being copied. If Goal throws an exception, this exception is re-thrown
by in pce thread/1. If the calling thread is the ‘pce thread’, in pce thread sync/1
executes a direct meta-call. See also pce thread/1.
Note that in pce thread sync/1 is expensive because it requires copying and thread com-
munication. For example, in pce thread synctrue runs at approximately 50,000 calls
per second (AMD Phenom 9600B, Ubuntu 11.04).
pce dispatch(+Options)
Create a Prolog thread with the alias name pce for XPCE event handling. In the X11 version
this call creates a thread that executes the X11 event-dispatch loop. In MS-Windows it creates
a thread that executes a windows event-dispatch loop. The XPCE event-handling thread has
the alias pce. Options speciﬁes the thread attributes as thread create/3.
SWI-Prolog 6.6 Reference Manual

Foreign Language Interface 9
SWI-Prolog offers a powerful interface to C [Kernighan & Ritchie, 1978]. The main design objectives
of the foreign language interface are ﬂexibility and performance. A foreign predicate is a C function
that has the same number of arguments as the predicate represented. C functions are provided to
analyse the passed terms, convert them to basic C types as well as to instantiate arguments using
uniﬁcation. Non-deterministic foreign predicates are supported, providing the foreign function with a
handle to control backtracking.
C can call Prolog predicates, providing both a query interface and an interface to extract multiple
solutions from a non-deterministic Prolog predicate. There is no limit to the nesting of Prolog calling
C, calling Prolog, etc. It is also possible to write the ‘main’ in C and use Prolog as an embedded
logical engine.
9.1
Overview of the Interface
A special include ﬁle called SWI-Prolog.h should be included with each C source ﬁle that is to be
loaded via the foreign interface. The installation process installs this ﬁle in the directory include in
the SWI-Prolog home directory (?- current prolog flag(home, Home).). This C header
ﬁle deﬁnes various data types, macros and functions that can be used to communicate with SWI-
Prolog. Functions and macros can be divided into the following categories:
• Analysing Prolog terms
• Constructing new terms
• Unifying terms
• Returning control information to Prolog
• Registering foreign predicates with Prolog
• Calling Prolog from C
• Recorded database interactions
• Global actions on Prolog (halt, break, abort, etc.)
9.2
Linking Foreign Modules
Foreign modules may be linked to Prolog in two ways. Using static linking, the extensions, a (short)
ﬁle deﬁning main() which attaches the extension calls to Prolog, and the SWI-Prolog kernel distributed
as a C library, are linked together to form a new executable. Using dynamic linking, the extensions
SWI-Prolog 6.6 Reference Manual

258
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
are linked to a shared library (.so ﬁle on most Unix systems) or dynamic link library (.DLL ﬁle on
Microsoft platforms) and loaded into the running Prolog process.1
9.2.1
What linking is provided?
The static linking schema can be used on all versions of SWI-Prolog.
Whether or not dy-
namic linking is supported can be deduced from the Prolog ﬂag open shared object (see
current prolog flag/2). If this Prolog ﬂag yields true, open shared object/2 and
related predicates are deﬁned. See section 9.2.3 for a suitable high-level interface to these predicates.
9.2.2
What kind of loading should I be using?
All described approaches have their advantages and disadvantages. Static linking is portable and
allows for debugging on all platforms. It is relatively cumbersome and the libraries you need to pass
to the linker may vary from system to system, though the utility program swipl-ld described in
section 9.5 often hides these problems from the user.
Loading shared objects (DLL ﬁles on Windows) provides sharing and protection and is
generally the best choice.
If a saved state is created using qsave program/[1,2], an
initialization/1 directive may be used to load the appropriate library at startup.
Note that the deﬁnition of the foreign predicates is the same, regardless of the linking type used.
9.2.3
library(shlib): Utility library for loading foreign objects (DLLs, shared objects)
This section discusses the functionality of the (autoload) library(shlib), providing an interface
to manage shared libraries. We describe the procedure for using a foreign resource (DLL in Windows
and shared object in Unix) called mylib.
First, one must assemble the resource and make it compatible to SWI-Prolog. The details for this
vary between platforms. The swipl-ld(1) utility can be used to deal with this in a portable manner.
The typical commandline is:
swipl-ld -o mylib file.{c,o,cc,C} ...
Make sure that one of the ﬁles provides a global function install_mylib() that initialises
the module using calls to PL register foreign(). Here is a simple example ﬁle mylib.c, which creates
a Windows MessageBox:
#include <windows.h>
#include <SWI-Prolog.h>
static foreign_t
pl_say_hello(term_t to)
{ char *a;
1The system also contains code to load .o ﬁles directly for some operating systems, notably Unix systems using the
BSD a.out executable format. As the number of Unix platforms supporting this quickly gets smaller and this interface is
difﬁcult to port and slow, it is no longer described in this manual. The best alternative would be to use the dld package on
machines that do not have shared libraries.
SWI-Prolog 6.6 Reference Manual

9.2. LINKING FOREIGN MODULES
259
if ( PL_get_atom_chars(to, &a) )
{ MessageBox(NULL, a, "DLL test", MB_OK|MB_TASKMODAL);
PL_succeed;
}
PL_fail;
}
install_t
install_mylib()
{ PL_register_foreign("say_hello", 1, pl_say_hello, 0);
}
Now write a ﬁle mylib.pl:
:- module(mylib, [ say_hello/1 ]).
:- use_foreign_library(foreign(mylib)).
The ﬁle mylib.pl can be loaded as a normal Prolog ﬁle and provides the predicate deﬁned in
C.
load foreign library(:FileSpec)
[det]
load foreign library(:FileSpec, +Entry:atom)
[det]
Load a shared object or DLL. After loading the Entry function is called without arguments.
The default entry function is composed from =install =, followed by the ﬁle base-name. E.g.,
the load-call below calls the function install_mylib(). If the platform preﬁxes extern
functions with = =, this preﬁx is added before calling.
...
load_foreign_library(foreign(mylib)),
...
Arguments
FileSpec
is a speciﬁcation for absolute file name/3.
If search-
ing the ﬁle fails, the plain name is passed to the OS to try
the default method of the OS for locating foreign objects. The
default deﬁnition of file search path/2 searches <prolog
home>/lib/<arch> on Unix and <prolog home>/bin on Win-
dows.
See also use foreign library/1,2 are intended for use in directives.
use foreign library(+FileSpec)
[det]
use foreign library(+FileSpec, +Entry:atom)
[det]
Load and install a foreign library as load foreign library/1,2 and register the
installation using initialization/2 with the option now. This is similar to using:
SWI-Prolog 6.6 Reference Manual

260
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
:- initialization(load_foreign_library(foreign(mylib))).
but using the initialization/1 wrapper causes the library to be loaded after loading of
the ﬁle in which it appears is completed, while use foreign library/1 loads the library
immediately. I.e. the difference is only relevant if the remainder of the ﬁle uses functionality of
the C-library.
unload foreign library(+FileSpec)
[det]
unload foreign library(+FileSpec, +Exit:atom)
[det]
Unload a shared object or DLL. After calling the Exit function, the shared object is removed
from the process. The default exit function is composed from =uninstall =, followed by the ﬁle
base-name.
current foreign library(?File, ?Public)
Query currently loaded shared libraries.
reload foreign libraries
Reload all foreign libraries loaded (after restore of a state created using qsave program/2.
9.2.4
Low-level operations on shared libraries
The interface deﬁned in this section allows the user to load shared libraries (.so ﬁles on most Unix
systems, .dll ﬁles on Windows). This interface is portable to Windows as well as to Unix machines
providing dlopen(2) (Solaris, Linux, FreeBSD, Irix and many more) or shl open(2) (HP/UX).
It is advised to use the predicates from section 9.2.3 in your application.
open shared object(+File, -Handle)
File is the name of a shared object ﬁle (DLL in MS-Windows).
This ﬁle is attached to
the current process, and Handle is uniﬁed with a handle to the library.
Equivalent to
open shared object(File, Handle, []).
See also open shared object/3
and load foreign library/1.
On errors, an exception shared object(Action, Message) is raised. Message is the return
value from dlerror().
open shared object(+File, -Handle, +Options)
As open shared object/2, but allows for additional ﬂags to be passed. Options is a list of
atoms. now implies the symbols are resolved immediately rather than lazy (default). global
implies symbols of the loaded object are visible while loading other shared objects (by default
they are local). Note that these ﬂags may not be supported by your operating system. Check
the documentation of dlopen() or equivalent on your operating system. Unsupported ﬂags are
silently ignored.
close shared object(+Handle)
Detach the shared object identiﬁed by Handle.
call shared object function(+Handle, +Function)
Call the named function in the loaded shared library. The function is called without arguments
and the return value is ignored. Normally this function installs foreign language predicates
using calls to PL register foreign().
SWI-Prolog 6.6 Reference Manual

9.2. LINKING FOREIGN MODULES
261
9.2.5
Static Linking
Below is an outline of the ﬁle structure required for statically linking SWI-Prolog with foreign ex-
tensions. .../swipl refers to the SWI-Prolog home directory (see the Prolog ﬂag home). ⟨arch⟩
refers to the architecture identiﬁer that may be obtained using the Prolog ﬂag arch.
.../swipl/runtime/⟨arch⟩/libswipl.a
SWI-Library
.../swipl/include/SWI-Prolog.h
Include ﬁle
.../swipl/include/SWI-Stream.h
Stream I/O include ﬁle
.../swipl/include/SWI-Exports
Export declarations (AIX only)
.../swipl/include/stub.c
Extension stub
The deﬁnition of the foreign predicates is the same as for dynamic linking. Unlike with dynamic
linking, however, there is no initialisation function. Instead, the ﬁle .../swipl/include/stub.
c may be copied to your project and modiﬁed to deﬁne the foreign extensions. Below is stub.c,
modiﬁed to link the lowercase example described later in this chapter:
#include <stdio.h>
#include <SWI-Prolog.h>
extern foreign_t pl_lowercase(term, term);
PL_extension predicates[] =
{
/*{ "name",
arity,
function,
PL_FA_<flags> },*/
{ "lowercase", 2
pl_lowercase,
0 },
{ NULL,
0,
NULL,
0 } /* terminating line */
};
int
main(int argc, char **argv)
{ PL_register_extensions(predicates);
if ( !PL_initialise(argc, argv) )
PL_halt(1);
PL_install_readline();
/* delete if not required */
PL_halt(PL_toplevel() ? 0 : 1);
}
Now, a new executable may be created by compiling this ﬁle and linking it to libpl.a from the
runtime directory and the libraries required by both the extensions and the SWI-Prolog kernel. This
may be done by hand, or by using the swipl-ld utility described in section 9.5. If the linking is
performed by hand, the command line option -dump-runtime-variables (see section 2.4) can
be used to obtain the required paths, libraries and linking options to link the new executable.
SWI-Prolog 6.6 Reference Manual

262
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
9.3
Interface Data Types
9.3.1
Type term t: a reference to a Prolog term
The principal data type is term t. Type term t is what Quintus calls QP term ref. This name
indicates better what the type represents: it is a handle for a term rather than the term itself. Terms can
only be represented and manipulated using this type, as this is the only safe way to ensure the Prolog
kernel is aware of all terms referenced by foreign code and thus allows the kernel to perform garbage
collection and/or stack-shifts while foreign code is active, for example during a callback from C.
A term reference is a C unsigned long, representing the offset of a variable on the
Prolog environment stack.
A foreign function is passed term references for the predi-
cate arguments, one for each argument.
If references for intermediate results are needed,
such references may be created using PL new term ref() or PL new term refs().
These
references
normally
live
till
the
foreign
function
returns
control
back
to
Pro-
log.
Their
scope
can
be
explicitly
limited
using
PL open foreign frame()
and
PL close foreign frame()/PL discard foreign frame().
A term t always refers to a valid Prolog term (variable, atom, integer, ﬂoat or compound term).
A term lives either until backtracking takes us back to a point before the term was created, the garbage
collector has collected the term, or the term was created after a PL open foreign frame() and
PL discard foreign frame() has been called.
The foreign interface functions can either read, unify or write to term references. In this document
we use the following notation for arguments of type term t:
term t +t
Accessed in read-mode. The ‘+’ indicates the argument is ‘input’.
term t -t
Accessed in write-mode.
term t ?t
Accessed in unify-mode.
Term references are obtained in any of the following ways:
• Passed as argument
The C functions implementing foreign predicates are passed their arguments as term references.
These references may be read or uniﬁed. Writing to these variables causes undeﬁned behaviour.
• Created by PL new term ref()
A term created by PL new term ref() is normally used to build temporary terms or to be
written by one of the interface functions. For example, PL get arg() writes a reference to
the term argument in its last argument.
• Created by PL new term refs(int n)
This
function
returns
a
set
of
term
references
with
the
same
characteristics
as
PL new term ref(). See PL open query().
• Created by PL copy term ref(term t t)
Creates a new term reference to the same term as the argument. The term may be written to.
See ﬁgure 9.2.
Term references can safely be copied to other C variables of type term t, but all copies will
always refer to the same term.
SWI-Prolog 6.6 Reference Manual

9.3. INTERFACE DATA TYPES
263
term t PL new term ref()
Return a fresh reference to a term. The reference is allocated on the local stack. Allocating
a term reference may trigger a stack-shift on machines that cannot use sparse memory
management for allocation of the Prolog stacks. The returned reference describes a variable.
term t PL new term refs(int n)
Return n new term references. The ﬁrst term reference is returned. The others are t + 1, t + 2,
etc. There are two reasons for using this function. PL open query() expects the arguments
as a set of consecutive term references, and very time-critical code requiring a number of term
references can be written as:
pl_mypredicate(term_t a0, term_t a1)
{ term_t t0 = PL_new_term_refs(2);
term_t t1 = t0+1;
...
}
term t PL copy term ref(term t from)
Create a new term reference and make it point initially to the same term as from. This function
is commonly used to copy a predicate argument to a term reference that may be written.
void PL reset term refs(term t after)
Destroy all term references that have been created after after, including after itself. Any refer-
ence to the invalidated term references after this call results in undeﬁned behaviour.
Note that returning from the foreign context to Prolog will reclaim all references used in the
foreign context. This call is only necessary if references are created inside a loop that never exits
back to Prolog. See also PL open foreign frame(), PL close foreign frame()
and PL discard foreign frame().
Interaction with the garbage collector and stack-shifter
Prolog implements two mechanisms for avoiding stack overﬂow: garbage collection and stack ex-
pansion. On machines that allow for it, Prolog will use virtual memory management to detect stack
overﬂow and expand the runtime stacks. On other machines Prolog will reallocate the stacks and
update all pointers to them. To do so, Prolog needs to know which data is referenced by C code.
As all Prolog data known by C is referenced through term references (term t), Prolog has all the
information necessary to perform its memory management without special precautions from the C
programmer.
9.3.2
Other foreign interface types
atom t An atom in Prolog’s internal representation. Atoms are pointers to an opaque structure. They
are a unique representation for represented text, which implies that atom A represents the same
text as atom B if and only if A and B are the same pointer.
Atoms are the central representation for textual constants in Prolog. The transformation of a
character string C to an atom implies a hash-table lookup. If the same atom is needed often, it
is advised to store its reference in a global variable to avoid repeated lookup.
SWI-Prolog 6.6 Reference Manual

264
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
functor t A functor is the internal representation of a name/arity pair. They are used to ﬁnd the name
and arity of a compound term as well as to construct new compound terms. Like atoms they
live for the whole Prolog session and are unique.
predicate t Handle to a Prolog predicate. Predicate handles live forever (although they can lose their
deﬁnition).
qid t Query
identiﬁer.
Used
by
PL open query(),
PL next solution()
and
PL close query() to handle backtracking from C.
ﬁd t Frame
identiﬁer.
Used
by
PL open foreign frame()
and
PL close foreign frame().
module t A module is a unique handle to a Prolog module. Modules are used only to call predicates
in a speciﬁc module.
foreign t Return type for a C function implementing a Prolog predicate.
control t Passed as additional argument to non-deterministic foreign functions. See PL retry*() and
PL foreign context*().
install t Type for the install() and uninstall() functions of shared or dynamic link libraries. See sec-
tion 9.2.3.
int64 t Actually part of the C99 standard rather than Prolog. As of version 5.5.6, Prolog integers are
64-bit on all hardware. The C99 type int64 t is deﬁned in the stdint.h standard header
and provides platform-independent 64-bit integers. Portable code accessing Prolog should use
this type to exchange integer values. Please note that PL get long() can return FALSE on
Prolog integers that cannot be represented as a C long. Robust code should not assume any of
the integer fetching functions to succeed, even if the Prolog term is known to be an integer.
9.4
The Foreign Include File
9.4.1
Argument Passing and Control
If Prolog encounters a foreign predicate at run time it will call a function speciﬁed in the predicate
deﬁnition of the foreign predicate. The arguments 1, . . . , ⟨arity⟩pass the Prolog arguments to the goal
as Prolog terms. Foreign functions should be declared of type foreign t. Deterministic foreign
functions have two alternatives to return control back to Prolog:
(return) foreign t PL succeed()
Succeed deterministically. PL succeed is deﬁned as return TRUE.
(return) foreign t PL fail()
Fail and start Prolog backtracking. PL fail is deﬁned as return FALSE.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
265
Non-deterministic Foreign Predicates
By default foreign predicates are deterministic. Using the PL FA NONDETERMINISTIC attribute
(see PL register foreign()) it is possible to register a predicate as a non-deterministic predi-
cate. Writing non-deterministic foreign predicates is slightly more complicated as the foreign function
needs context information for generating the next solution. Note that the same foreign function should
be prepared to be simultaneously active in more than one goal. Suppose the natural number below n/2
is a non-deterministic foreign predicate, backtracking over all natural numbers lower than the ﬁrst ar-
gument. Now consider the following predicate:
quotient_below_n(Q, N) :-
natural_number_below_n(N, N1),
natural_number_below_n(N, N2),
Q =:= N1 / N2, !.
In this predicate the function natural number below n/2 simultaneously generates solutions for both
its invocations.
Non-deterministic foreign functions should be prepared to handle three different calls from Prolog:
• Initial call (PL FIRST CALL)
Prolog has just created a frame for the foreign function and asks it to produce the ﬁrst answer.
• Redo call (PL REDO)
The previous invocation of the foreign function associated with the current goal indicated it was
possible to backtrack. The foreign function should produce the next solution.
• Terminate call (PL PRUNED)
The choice point left by the foreign function has been destroyed by a cut. The foreign function
is given the opportunity to clean the environment.
Both the context information and the type of call is provided by an argument of type
control t appended to the argument list for deterministic foreign functions.
The macro
PL foreign control() extracts the type of call from the control argument. The foreign func-
tion can pass a context handle using the PL retry*() macros and extract the handle from the extra
argument using the PL foreign context*() macro.
(return) foreign t PL retry(intptr t value)
The foreign function succeeds while leaving a choice point. On backtracking over this goal the
foreign function will be called again, but the control argument now indicates it is a ‘Redo’ call
and the macro PL foreign context() returns the handle passed via PL retry(). This
handle is a signed value two bits smaller than a pointer, i.e., 30 or 62 bits (two bits are used for
status indication). Deﬁned as return
PL retry(n). See also PL succeed().
(return) foreign t PL retry address(void *)
As PL retry(), but ensures an address as returned by malloc() is correctly recovered by
PL foreign context address().
Deﬁned as return
PL retry address(n).
See also PL succeed().
SWI-Prolog 6.6 Reference Manual

266
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
typedef struct
/* define a context structure */
{ ...
} context;
foreign_t
my_function(term_t a0, term_t a1, control_t handle)
{ struct context * ctxt;
switch( PL_foreign_control(handle) )
{ case PL_FIRST_CALL:
ctxt = malloc(sizeof(struct context));
...
PL_retry_address(ctxt);
case PL_REDO:
ctxt = PL_foreign_context_address(handle);
...
PL_retry_address(ctxt);
case PL_PRUNED:
ctxt = PL_foreign_context_address(handle);
...
free(ctxt);
PL_succeed;
}
}
Figure 9.1: Skeleton for non-deterministic foreign functions
int PL foreign control(control t)
Extracts the type of call from the control argument. The return values are described above.
Note that the function should be prepared to handle the PL PRUNED case and should be aware
that the other arguments are not valid in this case.
intptr t PL foreign context(control t)
Extracts the context from the context argument. If the call type is PL FIRST CALL the context
value is 0L. Otherwise it is the value returned by the last PL retry() associated with this
goal (both if the call type is PL REDO or PL PRUNED).
void * PL foreign context address(control t)
Extracts an address as passed in by PL retry address().
Note: If a non-deterministic foreign function returns using PL succeed() or PL fail(),
Prolog assumes the foreign function has cleaned its environment. No call with control argument
PL PRUNED will follow.
The code of ﬁgure 9.1 shows a skeleton for a non-deterministic foreign predicate deﬁnition.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
267
9.4.2
Atoms and functors
The following functions provide for communication using atoms and functors.
atom t PL new atom(const char *)
Return an atom handle for the given C-string. This function always succeeds. The returned
handle is valid as long as the atom is referenced (see section 9.4.2). The following atoms are
provided as macros, giving access to the empty list symbol and the name of the list constructor.
Prior to version 7, ATOM nil is the same as PL new atom(”[]”) and ATOM dot is the
same as PL new atom(”.”). This is no long the case in SWI-Prolog version 7.
atom t ATOM nil(A)
tomic constant that represents the empty list.
It is adviced to use PL get nil(),
PL put nil() or PL unify nil() where applicable.
atom t ATOM dot(A)
tomic constant that represents the name of the list constructor. The list constructor itself is
created using PL new functor(ATOM dot,2). It is adviced to use PL get list(),
PL put list() or PL unify list() where applicable.
const char* PL atom chars(atom t atom)
Return a C-string for the text represented by the given atom. The returned text will not be
changed by Prolog. It is not allowed to modify the contents, not even ‘temporary’ as the string
may reside in read-only memory. The returned string becomes invalid if the atom is garbage
collected (see section 9.4.2). Foreign functions that require the text from an atom passed in a
term t normally use PL get atom chars() or PL get atom nchars().
functor t PL new functor(atom t name, int arity)
Returns a functor identiﬁer, a handle for the name/arity pair. The returned handle is valid for
the entire Prolog session.
atom t PL functor name(functor t f)
Return an atom representing the name of the given functor.
int PL functor arity(functor t f)
Return the arity of the given functor.
Atoms and atom garbage collection
With the introduction of atom garbage collection in version 3.3.0, atoms no longer live as long as the
process. Instead, their lifetime is guaranteed only as long as they are referenced. In the single-threaded
version, atom garbage collections are only invoked at the call-port. In the multithreaded version (see
chapter 8), they appear asynchronously, except for the invoking thread.
For dealing with atom garbage collection, two additional functions are provided:
void PL register atom(atom t atom)
Increment the reference count of the atom by one. PL new atom() performs this automati-
cally, returning an atom with a reference count of at least one.2
2Otherwise asynchronous atom garbage collection might destroy the atom before it is used.
SWI-Prolog 6.6 Reference Manual

268
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
void PL unregister atom(atom t atom)
Decrement the reference count of the atom. If the reference count drops below zero, an assertion
error is raised.
Please note that the following two calls are different with respect to atom garbage collection:
PL_unify_atom_chars(t, "text");
PL_unify_atom(t, PL_new_atom("text"));
The latter increments the reference count of the atom text, which effectively ensures the atom will
never be collected. It is advised to use the * chars() or * nchars() functions whenever applicable.
9.4.3
Analysing Terms via the Foreign Interface
Each argument of a foreign function (except for the control argument) is of type term t, an opaque
handle to a Prolog term. Three groups of functions are available for the analysis of terms. The ﬁrst
just validates the type, like the Prolog predicates var/1, atom/1, etc., and are called PL is *().
The second group attempts to translate the argument into a C primitive type. These predicates take a
term t and a pointer to the appropriate C type and return TRUE or FALSE depending on successful
or unsuccessful translation. If the translation fails, the pointed-to data is never modiﬁed.
Testing the type of a term
int PL term type(term t)
Obtain the type of a term, which should be a term returned by one of the other interface pred-
icates or passed as an argument. The function returns the type of the Prolog term. The type
identiﬁers are listed below. Note that the extraction functions PL get *() also validate the
type and thus the two sections below are equivalent.
if ( PL_is_atom(t) )
{ char *s;
PL_get_atom_chars(t, &s);
...;
}
or
char *s;
if ( PL_get_atom_chars(t, &s) )
{ ...;
}
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
269
PL VARIABLE
An unbound variable. The value of term as such is
a unique identiﬁer for the variable.
PL ATOM
A Prolog atom.
PL STRING
A Prolog string.
PL INTEGER
A Prolog integer.
PL FLOAT
A Prolog ﬂoating point number.
PL TERM
A compound term. Note that a list is a compound
term ./2.
The
functions
PL is ⟨type⟩
are
an
alternative
to
PL term type().
The
test
PL is variable(term) is equivalent to PL term type(term) == PL VARIABLE,
but
the ﬁrst is considerably faster. On the other hand, using a switch over PL term type() is faster
and more readable then using an if-then-else using the functions below. All these functions return
either TRUE or FALSE.
int PL is variable(term t)
Returns non-zero if term is a variable.
int PL is ground(term t)
Returns non-zero if term is a ground term. See also ground/1. This function is cycle-safe.
int PL is atom(term t)
Returns non-zero if term is an atom.
int PL is string(term t)
Returns non-zero if term is a string.
int PL is integer(term t)
Returns non-zero if term is an integer.
int PL is ﬂoat(term t)
Returns non-zero if term is a ﬂoat.
int PL is callable(term t)
Returns non-zero if term is a callable term. See callable/1 for details.
int PL is compound(term t)
Returns non-zero if term is a compound term.
int PL is functor(term t, functor t)
Returns non-zero if term is compound and its functor is functor. This test is equivalent to
PL get functor(), followed by testing the functor, but easier to write and faster.
int PL is list(term t)
Returns non-zero if term is a compound term with functor ./2 or the atom []. See also
PL is pair() and PL skip list().
int PL is pair(term t)
Returns non-zero if term is a compound term with functor ./2. See also PL is list() and
PL skip list().
SWI-Prolog 6.6 Reference Manual

270
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
int PL is atomic(term t)
Returns non-zero if term is atomic (not variable or compound).
int PL is number(term t)
Returns non-zero if term is an integer or ﬂoat.
int PL is acyclic(term t)
Returns non-zero if term is acyclic (i.e. a ﬁnite tree).
Reading data from a term
The functions PL get *() read information from a Prolog term. Most of them take two arguments.
The ﬁrst is the input term and the second is a pointer to the output value or a term reference.
int PL get atom(term t +t, atom t *a)
If t is an atom, store the unique atom identiﬁer over a. See also PL atom chars() and
PL new atom().
If there is no need to access the data (characters) of an atom, it is
advised to manipulate atoms using their handle. As the atom is referenced by t, it will live
at least as long as t does. If longer live-time is required, the atom should be locked using
PL register atom().
int PL get atom chars(term t +t, char **s)
If t is an atom, store a pointer to a 0-terminated C-string in s. It is explicitly not allowed
to modify the contents of this string. Some built-in atoms may have the string allocated in
read-only memory, so ‘temporary manipulation’ can cause an error.
int PL get string chars(term t +t, char **s, int *len)
If t is a string object, store a pointer to a 0-terminated C-string in s and the length of the string
in len. Note that this pointer is invalidated by backtracking, garbage collection and stack-shifts,
so generally the only save operations are to pass it immediately to a C function that doesn’t
involve Prolog.
int PL get chars(term t +t, char **s, unsigned ﬂags)
Convert the argument term t to a 0-terminated C-string. ﬂags is a bitwise disjunction from two
groups of constants. The ﬁrst speciﬁes which term types should be converted and the second
how the argument is stored. Below is a speciﬁcation of these constants. BUF RING implies,
if the data is not static (as from an atom), that the data is copied to the next buffer from a ring
of 16 buffers. This is a convenient way of converting multiple arguments passed to a foreign
predicate to C-strings. If BUF MALLOC is used, the data must be freed using PL free()
when no longer needed.
With the introduction of wide characters (see section 2.18.1), not all atoms can be converted into
a char*. This function fails if t is of the wrong type, but also if the text cannot be represented.
See the REP * ﬂags below for details.
CVT ATOM
Convert if term is an atom.
CVT STRING
Convert if term is a string.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
271
CVT LIST
Convert if term is a list of of character codes.
CVT INTEGER
Convert if term is an integer.
CVT FLOAT
Convert if term is a ﬂoat. The characters returned are the same as write/1 would write
for the ﬂoating point number.
CVT NUMBER
Convert if term is an integer or ﬂoat.
CVT ATOMIC
Convert if term is atomic.
CVT VARIABLE
Convert variable to print-name
CVT WRITE
Convert any term that is not converted by any of the other ﬂags using write/1. If no
BUF * is provided, BUF RING is implied.
CVT WRITE CANONICAL
As CVT WRITE, but using write canonical/2.
CVT WRITEQ
As CVT WRITE, but using writeq/2.
CVT ALL
Convert if term is any of the above, except for CVT VARIABLE and CVT WRITE*.
CVT EXCEPTION
If conversion fails due to a type error, raise a Prolog type error exception in addition to
failure
BUF DISCARDABLE
Data must copied immediately
BUF RING
Data is stored in a ring of buffers
BUF MALLOC
Data is copied to a new buffer returned by PL malloc(3). When no longer needed the
user must call PL free() on the data.
REP ISO LATIN 1
Text is in ISO Latin-1 encoding and the call fails if text cannot be represented. This ﬂag
has the value 0 and is thus the default.
REP UTF8
Convert the text to a UTF-8 string. This works for all text.
REP MB
Convert to default locale-deﬁned 8-bit string. Success depends on the locale. Conversion
is done using the wcrtomb() C library function.
int PL get list chars(+term t l, char **s, unsigned ﬂags)
Same as PL get chars(l, s, CVT LIST—ﬂags), provided ﬂags contains none of the CVT *
ﬂags.
SWI-Prolog 6.6 Reference Manual

272
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
int PL get integer(+term t t, int *i)
If t is a Prolog integer, assign its value over i.
On 32-bit machines, this is the same as
PL get long(), but avoids a warning from the compiler. See also PL get long().
int PL get long(term t +t, long *i)
If t is a Prolog integer that can be represented as a long, assign its value over i. If t is an
integer that cannot be represented by a C long, this function returns FALSE. If t is a ﬂoating
point number that can be represented as a long, this function succeeds as well.
See also
PL get int64().
int PL get int64(term t +t, int64 t *i)
If t is a Prolog integer or ﬂoat that can be represented as a int64 t, assign its value over
i. Currently all Prolog integers can be represented using this type, but this might change if
SWI-Prolog introduces unbounded integers.
int PL get intptr(term t +t, intptr t *i)
Get an integer that is at least as wide as a pointer.
On most platforms this is the
same as PL get long(), but on Win64 pointers are 8 bytes and longs only 4.
Unlike
PL get pointer(), the value is not modiﬁed.
int PL get bool(term t +t, int *val)
If t has the value true or false, set val to the C constant TRUE or FALSE and return success,
otherwise return failure.
int PL get pointer(term t +t, void **ptr)
In the current system, pointers are represented by Prolog integers, but need some manipu-
lation to make sure they do not get truncated due to the limited Prolog integer range.
PL put pointer() and PL get pointer() guarantee pointers in the range of malloc()
are handled without truncating.
int PL get ﬂoat(term t +t, double *f)
If t is a ﬂoat or integer, its value is assigned over f.
int PL get functor(term t +t, functor t *f)
If t is compound or an atom, the Prolog representation of the name-arity pair will be assigned
over f. See also PL get name arity() and PL is functor().
int PL get name arity(term t +t, atom t *name, int *arity)
If t is compound or an atom, the functor name will be assigned over name and the arity over
arity. See also PL get functor() and PL is functor().
int PL get module(term t +t, module t *module)
If t is an atom, the system will look up or create the corresponding module and assign an
opaque pointer to it over module.
int PL get arg(int index, term t +t, term t -a)
If t is compound and index is between 1 and arity (inclusive), assign a with a term reference to
the argument.
int PL get arg(int index, term t +t, term t -a)
Same as PL get arg(), but no checking is performed, neither whether t is actually a term
nor whether index is a valid argument index.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
273
Exchanging text using length and string
All internal text representation in SWI-Prolog is represented using char * plus length and allow
for 0-bytes in them. The foreign library supports this by implementing a * nchars() function for each
applicable * chars() function. Below we brieﬂy present the signatures of these functions. For full
documentation consult the * chars() function.
int PL get atom nchars(term t t, size t *len, char **s)
See PL get atom chars().
int PL get list nchars(term t t, size t *len, char **s)
See PL get list chars().
int PL get nchars(term t t, size t *len, char **s, unsigned int ﬂags)
See PL get chars().
int PL put atom nchars(term t t, size t len, const char *s)
See PL put atom chars().
int PL put string nchars(term t t, size t len, const char *s)
See PL put string chars().
int PL put list ncodes(term t t, size t len, const char *s)
See PL put list codes().
int PL put list nchars(term t t, size t len, const char *s)
See PL put list chars().
int PL unify atom nchars(term t t, size t len, const char *s)
See PL unify atom chars().
int PL unify string nchars(term t t, size t len, const char *s)
See PL unify string chars().
int PL unify list ncodes(term t t, size t len, const char *s)
See PL unify codes().
int PL unify list nchars(term t t, size t len, const char *s)
See PL unify list chars().
In addition, the following functions are available for creating and inspecting atoms:
atom t PL new atom nchars(size t len, const char *s)
Create a new atom as PL new atom(), but using the given length and characters. If len is
(size t)-1, it is computed from s using strlen().
const char * PL atom nchars(atom t a, size t *len)
Extract the text and length of an atom.
SWI-Prolog 6.6 Reference Manual

274
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
Wide-character versions
Support for exchange of wide-character strings is still under consideration. The functions dealing
with 8-bit character strings return failure when operating on a wide-character atom or Prolog string
object. The functions below can extract and unify both 8-bit and wide atoms and string objects. Wide
character strings are represented as C arrays of objects of the type pl wchar t, which is guaranteed
to be the same as wchar t on platforms supporting this type. For example, on MS-Windows, this
represents 16-bit UCS2 characters, while using the GNU C library (glibc) this represents 32-bit UCS4
characters.
atom t PL new atom wchars(size t len, const pl wchar t *s)
Create atom from wide-character string as PL new atom nchars() does for ISO-Latin-1
strings. If s only contains ISO-Latin-1 characters a normal byte-array atom is created. If len is
(size t)-1, it is computed from s using wcslen().
pl wchar t* PL atom wchars(atom t atom, int *len)
Extract characters from a wide-character atom. Succeeds on any atom marked as ‘text’. If
the underlying atom is a wide-character atom, the returned pointer is a pointer into the atom
structure. If it is an ISO-Latin-1 character, the returned pointer comes from Prolog’s ‘buffer
ring’ (see PL get chars()).
int PL get wchars(term t t, size t *len, pl wchar t **s, unsigned ﬂags)
Wide-character version of PL get chars().
The ﬂags argument is the same as for
PL get chars().
int PL unify wchars(term t t, int type, size t len, const pl wchar t *s)
Unify t with a textual representation of the C wide-character array s. The type argument de-
ﬁnes the Prolog representation and is one of PL ATOM, PL STRING, PL CODE LIST or
PL CHAR LIST.
int PL unify wchars diff(term t +t, term t -tail, int type, size t len, const pl wchar t *s)
Difference list version of PL unify wchars(), only supporting the types PL CODE LIST
and PL CHAR LIST. It serves two purposes.
It allows for returning very long lists from
data read from a stream without the need for a resizing buffer in C. Also, the use of dif-
ference lists is often practical for further processing in Prolog. Examples can be found in
packages/clib/readutil.c from the source distribution.
Reading a list
The functions from this section are intended to read a Prolog list from C. Suppose we expect a list of
atoms; the following code will print the atoms, each on a line:
foreign_t
pl_write_atoms(term_t l)
{ term_t head = PL_new_term_ref();
/* the elements */
term_t list = PL_copy_term_ref(l); /* copy (we modify list) */
while( PL_get_list(list, head, list) )
{ char *s;
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
275
if ( PL_get_atom_chars(head, &s) )
Sprintf("%s\n", s);
else
PL_fail;
}
return PL_get_nil(list);
/* test end for [] */
}
int PL get list(term t +l, term t -h, term t -t)
If l is a list and not [] assign a term reference to the head to h and to the tail to t.
int PL get head(term t +l, term t -h)
If l is a list and not [] assign a term reference to the head to h.
int PL get tail(term t +l, term t -t)
If l is a list and not [] assign a term reference to the tail to t.
int PL get nil(term t +l)
Succeeds if l represents the atom [].
int PL skip list(term t +list, term t -tail, size t *len)
This is a multi-purpose function to deal with lists. It allows for ﬁnding the length of a list,
checking whether something is a list, etc. The reference tail is set to point to the end of the list,
len is ﬁlled with the number of list-cells skipped, and the return value indicates the status of the
list:
PL LIST
The list is a ‘proper’ list: one that ends in [] and tail is ﬁlled with []
PL PARTIAL LIST
The list is a ‘partial’ list: one that ends in a variable and tail is a reference to this variable.
PL CYCLIC TERM
The list is cyclic (e.g. X = [a—X]). tail points to an arbitrary cell of the list and len is at
most twice the cycle length of the list.
PL NOT A LIST
The term list is not a list at all. tail is bound to the non-list term and len is set to the
number of list-cells skipped.
It is allowed to pass 0 for tail and NULL for len.
An example: deﬁning write/1 in C
Figure 9.2 shows a simpliﬁed deﬁnition of write/1 to illustrate the described functions. This sim-
pliﬁed version does not deal with operators. It is called display/1, because it mimics closely the
behaviour of this Edinburgh predicate.
SWI-Prolog 6.6 Reference Manual

276
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
foreign_t
pl_display(term_t t)
{ functor_t functor;
int arity, len, n;
char *s;
switch( PL_term_type(t) )
{ case PL_VARIABLE:
case PL_ATOM:
case PL_INTEGER:
case PL_FLOAT:
PL_get_chars(t, &s, CVT_ALL);
Sprintf("%s", s);
break;
case PL_STRING:
PL_get_string_chars(t, &s, &len);
Sprintf("\"%s\"", s);
break;
case PL_TERM:
{ term_t a = PL_new_term_ref();
PL_get_name_arity(t, &name, &arity);
Sprintf("%s(", PL_atom_chars(name));
for(n=1; n<=arity; n++)
{ PL_get_arg(n, t, a);
if ( n > 1 )
Sprintf(", ");
pl_display(a);
}
Sprintf(")");
break;
default:
PL_fail;
/* should not happen */
}
}
PL_succeed;
}
Figure 9.2: A Foreign deﬁnition of display/1
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
277
9.4.4
Constructing Terms
Terms can be constructed using functions from the PL put *() and PL cons *() families. This
approach builds the term ‘inside-out’, starting at the leaves and subsequently creating compound
terms. Alternatively, terms may be created ‘top-down’, ﬁrst creating a compound holding only vari-
ables and subsequently unifying the arguments. This section discusses functions for the ﬁrst approach.
This approach is generally used for creating arguments for PL call() and PL open query().
void PL put variable(term t -t)
Put a fresh variable in the term, resetting the term reference to its initial state.3
void PL put atom(term t -t, atom t a)
Put an atom in the term reference from a handle.
See also PL new atom() and
PL atom chars().
void PL put bool(term t -t, int val)
Put one of the atoms true or false in the term reference See also PL put atom(),
PL unify bool() and PL get bool().
int PL put atom chars(term t -t, const char *chars)
Put an atom in the term reference constructed from the zero-terminated string. The string itself
will never be referenced by Prolog after this function.
int PL put string chars(term t -t, const char *chars)
Put a zero-terminated string in the term reference.
The data will be copied.
See also
PL put string nchars().
int PL put string nchars(term t -t, size t len, const char *chars)
Put a string, represented by a length/start pointer pair in the term reference. The data will be
copied. This interface can deal with 0-bytes in the string. See also section 9.4.20.
int PL put list chars(term t -t, const char *chars)
Put a list of ASCII values in the term reference.
int PL put integer(term t -t, long i)
Put a Prolog integer in the term reference.
int PL put int64(term t -t, int64 t i)
Put a Prolog integer in the term reference.
int PL put pointer(term t -t, void *ptr)
Put a Prolog integer in the term reference.
Provided ptr is in the ‘malloc()-area’,
PL get pointer() will get the pointer back.
int PL put ﬂoat(term t -t, double f)
Put a ﬂoating-point value in the term reference.
int PL put functor(term t -t, functor t functor)
Create a new compound term from functor and bind t to this term. All arguments of the term
will be variables. To create a term with instantiated arguments, either instantiate the arguments
using the PL unify *() functions or use PL cons functor().
3Older versions created a variable on the global stack.
SWI-Prolog 6.6 Reference Manual

278
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
int PL put list(term t -l)
Same as PL put functor(l, PL new functor(PL new atom(”.”), 2)).
int PL put nil(term t -l)
Same as PL put atom chars(”[]”). Always returns TRUE.
void PL put term(term t -t1, term t +t2)
Make t1 point to the same term as t2.
int PL cons functor(term t -h, functor t f, ... )
Create a term whose arguments are ﬁlled from a variable argument list holding the same number
of term t objects as the arity of the functor. To create the term animal(gnu, 50), use:
{ term_t a1 = PL_new_term_ref();
term_t a2 = PL_new_term_ref();
term_t t
= PL_new_term_ref();
functor_t animal2;
/* animal2 is a constant that may be bound to a global
variable and re-used
*/
animal2 = PL_new_functor(PL_new_atom("animal"), 2);
PL_put_atom_chars(a1, "gnu");
PL_put_integer(a2, 50);
PL_cons_functor(t, animal2, a1, a2);
}
After this sequence, the term references a1 and a2 may be used for other purposes.
int PL cons functor v(term t -h, functor t f, term t a0)
Create a compound term like PL cons functor(), but a0 is an array of term references
as returned by PL new term refs(). The length of this array should match the number of
arguments required by the functor.
int PL cons list(term t -l, term t +h, term t +t)
Create a list (cons-) cell in l from the head h and tail t. The code below creates a list of atoms
from a char **. The list is built tail-to-head. The PL unify *() functions can be used to
build a list head-to-tail.
void
put_list(term_t l, int n, char **words)
{ term_t a = PL_new_term_ref();
PL_put_nil(l);
while( --n >= 0 )
{ PL_put_atom_chars(a, words[n]);
PL_cons_list(l, a, l);
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
279
}
}
Note that l can be redeﬁned within a PL cons list call as shown here because operationally
its old value is consumed before its new value is set.
9.4.5
Unifying data
The functions of this section unify terms with other terms or translated C data structures. Except
for PL unify(), these functions are speciﬁc to SWI-Prolog. They have been introduced because
they shorten the code for returning data to Prolog and at the same time make this more efﬁcient by
avoiding the need to allocate temporary term references and reduce the number of calls to the Prolog
API. Consider the case where we want a foreign function to return the host name of the machine
Prolog is running on. Using the PL get *() and PL put *() functions, the code becomes:
foreign_t
pl_hostname(term_t name)
{ char buf[100];
if ( gethostname(buf, sizeof(buf)) )
{ term_t tmp = PL_new_term_ref();
PL_put_atom_chars(tmp, buf);
return PL_unify(name, tmp);
}
PL_fail;
}
Using PL unify atom chars(), this becomes:
foreign_t
pl_hostname(term_t name)
{ char buf[100];
if ( gethostname(buf, sizeof(buf)) )
return PL_unify_atom_chars(name, buf);
PL_fail;
}
Note that uniﬁcation functions that perform multiple bindings may leave part of the bindings in case
of failure. See PL unify() for details.
int PL unify(term t ?t1, term t ?t2)
Unify two Prolog terms and return TRUE on success.
SWI-Prolog 6.6 Reference Manual

280
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
Care is needed if PL unify() returns FAIL and the foreign function does not immediately
return to Prolog with FAIL. Uniﬁcation may perform multiple changes to either t1 or t2. A
failing uniﬁcation may have created bindings before failure is detected. Already created bind-
ings are not undone. For example, calling PL unify() on a(X, a) and a(c,b) binds X to c and
fails when trying to unify a to b. If control remains in C or even if we want to return success to
Prolog, we must undo such bindings. This is achieved using PL open foreign frame()
and PL rewind foreign frame(), as shown in the snippet below.
{ fid_t fid = PL_open_foreign_frame();
...
if ( !PL_unify(t1, t2) )
PL_rewind_foreign_frame(fid);
...
PL_close_foreign_frame(fid);
}
In addition, PL unify() may have failed on an exception, typically a resource (stack) over-
ﬂow. This can be tested using PL exception(), passing 0 (zero) for the query-id argument.
Foreign functions that encounter an exception must return FAIL to Prolog as soon as possible
or call PL clear exception() if they wish to ignore the exception.
int PL unify atom(term t ?t, atom t a)
Unify t with the atom a and return non-zero on success.
int PL unify bool(term t ?t, int a)
Unify t with either true or false.
int PL unify chars(term t ?t, int ﬂags, size t len, const char *chars)
New function to deal with uniﬁcation of char* with various encodings to a Prolog represen-
tation. The ﬂags argument is a bitwise or specifying the Prolog target type and the encoding of
chars. A Prolog type is one of PL ATOM, PL STRING, PL CODE LIST or PL CHAR LIST. A
representation is one of REP ISO LATIN 1, REP UTF8 or REP MB. See PL get chars()
for a deﬁnition of the representation types. If len is -1 chars must be zero-terminated and the
length is computed from chars using strlen().
If ﬂags includes PL DIFF LIST and type is one of PL CODE LIST or PL CHAR LIST, the
text is converted to a difference list. The tail of the difference list is t + 1.
int PL unify atom chars(term t ?t, const char *chars)
Unify t with an atom created from chars and return non-zero on success.
int PL unify list chars(term t ?t, const char *chars)
Unify t with a list of ASCII characters constructed from chars.
void PL unify string chars(term t ?t, const char *chars)
Unify t with a Prolog string object created from the zero-terminated string chars. The data will
be copied. See also PL unify string nchars().
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
281
void PL unify string nchars(term t ?t, size t len, const char *chars)
Unify t with a Prolog string object created from the string created from the len/chars pair. The
data will be copied. This interface can deal with 0-bytes in the string. See also section 9.4.20.
int PL unify integer(term t ?t, intptr t n)
Unify t with a Prolog integer from n.
int PL unify int64(term t ?t, int64 t n)
Unify t with a Prolog integer from n.
int PL unify ﬂoat(term t ?t, double f)
Unify t with a Prolog ﬂoat from f.
int PL unify pointer(term t ?t, void *ptr)
Unify t with a Prolog integer describing the pointer.
See also PL put pointer() and
PL get pointer().
int PL unify functor(term t ?t, functor t f)
If t is a compound term with the given functor, just succeed. If it is unbound, create a term and
bind the variable, else fail. Note that this function does not create a term if the argument is
already instantiated.
int PL unify list(term t ?l, term t -h, term t -t)
Unify l with a list-cell (./2). If successful, write a reference to the head of the list into h
and a reference to the tail of the list into t. This reference may be used for subsequent calls
to this function. Suppose we want to return a list of atoms from a char **. We could use
the example described by PL put list(), followed by a call to PL unify(), or we can
use the code below. If the predicate argument is unbound, the difference is minimal (the code
based on PL put list() is probably slightly faster). If the argument is bound, the code
below may fail before reaching the end of the word list, but even if the uniﬁcation succeeds,
this code avoids a duplicate (garbage) list and a deep uniﬁcation.
foreign_t
pl_get_environ(term_t env)
{ term_t l = PL_copy_term_ref(env);
term_t a = PL_new_term_ref();
extern char **environ;
char **e;
for(e = environ; *e; e++)
{ if ( !PL_unify_list(l, a, l) ||
!PL_unify_atom_chars(a, *e) )
PL_fail;
}
return PL_unify_nil(l);
}
SWI-Prolog 6.6 Reference Manual

282
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
int PL unify nil(term t ?l)
Unify l with the atom [].
int PL unify arg(int index, term t ?t, term t ?a)
Uniﬁes the index-th argument (1-based) of t with a.
int PL unify term(term t ?t, . . . )
Unify t with a (normally) compound term. The remaining arguments are a sequence of a type
identiﬁer followed by the required arguments. This predicate is an extension to the Quintus and
SICStus foreign interface from which the SWI-Prolog foreign interface has been derived, but
has proved to be a powerful and comfortable way to create compound terms from C. Due to
the vararg packing/unpacking and the required type-switching this interface is slightly slower
than using the primitives. Please note that some bad C compilers have fairly low limits on the
number of arguments that may be passed to a function.
Special attention is required when passing numbers. C ‘promotes’ any integral smaller than int
to int. That is, the types char, short and int are all passed as int. In addition, on most
32-bit platforms int and long are the same. Up to version 4.0.5, only PL INTEGER could
be speciﬁed, which was taken from the stack as long. Such code fails when passing small
integral types on machines where int is smaller than long. It is advised to use PL SHORT,
PL INT or PL LONG as appropriate. Similarly, C compilers promote float to double and
therefore PL FLOAT and PL DOUBLE are synonyms.
The type identiﬁers are:
PL VARIABLE none
No op. Used in arguments of PL FUNCTOR.
PL BOOL int
Unify the argument with true or false.
PL ATOM atom t
Unify the argument with an atom, as in PL unify atom().
PL CHARS const char *
Unify
the
argument
with
an
atom
constructed
from
the
C
char *,
as
in
PL unify atom chars().
PL NCHARS size t, const char *
Unify the argument with an atom constructed from length and char* as in
PL unify atom nchars().
PL UTF8 CHARS const char *
Create an atom from a UTF-8 string.
PL UTF8 STRING const char *
Create a packed string object from a UTF-8 string.
PL MBCHARS const char *
Create an atom from a multi-byte string in the current locale.
PL MBCODES const char *
Create a list of character codes from a multi-byte string in the current locale.
PL MBSTRING const char *
Create a packed string object from a multi-byte string in the current locale.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
283
PL NWCHARS size t, const wchar t *
Create an atom from a length and a wide character pointer.
PL NWCODES size t, const wchar t *
Create a list of character codes from a length and a wide character pointer.
PL NWSTRING size t, const wchar t *
Create a packed string object from a length and a wide character pointer.
PL SHORT short
Unify the argument with an integer, as in PL unify integer(). As short is pro-
moted to int, PL SHORT is a synonym for PL INT.
PL INTEGER long
Unify the argument with an integer, as in PL unify integer().
PL INT int
Unify the argument with an integer, as in PL unify integer().
PL LONG long
Unify the argument with an integer, as in PL unify integer().
PL INT64 int64 t
Unify the argument with a 64-bit integer, as in PL unify int64().
PL INTPTR intptr t
Unify the argument with an integer with the same width as a pointer. On most machines
this is the same as PL LONG. but on 64-bit MS-Windows pointers are 64 bits while longs
are only 32 bits.
PL DOUBLE double
Unify the argument with a ﬂoat, as in PL unify float(). Note that, as the argument
is passed using the C vararg conventions, a ﬂoat must be casted to a double explicitly.
PL FLOAT double
Unify the argument with a ﬂoat, as in PL unify float().
PL POINTER void *
Unify the argument with a pointer, as in PL unify pointer().
PL STRING const char *
Unify the argument with a string object, as in PL unify string chars().
PL TERM term t
Unify a subterm. Note this may be the return value of a PL new term ref() call to
get access to a variable.
PL FUNCTOR functor t, . . .
Unify the argument with a compound term. This speciﬁcation should be followed by
exactly as many speciﬁcations as the number of arguments of the compound term.
PL FUNCTOR CHARS const char *name, int arity, ...
Create a functor from the given name and arity and then behave as PL FUNCTOR.
PL LIST int length, . . .
Create a list of the indicated length. The remaining arguments contain the elements of the
list.
SWI-Prolog 6.6 Reference Manual

284
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
For example, to unify an argument with the term language(dutch), the following skeleton
may be used:
static functor_t FUNCTOR_language1;
static void
init_constants()
{ FUNCTOR_language1 = PL_new_functor(PL_new_atom("language"),1);
}
foreign_t
pl_get_lang(term_t r)
{ return PL_unify_term(r,
PL_FUNCTOR, FUNCTOR_language1,
PL_CHARS, "dutch");
}
install_t
install()
{ PL_register_foreign("get_lang", 1, pl_get_lang, 0);
init_constants();
}
int PL chars to term(const char *chars, term t -t)
Parse the string chars and put the resulting Prolog term into t. chars may or may not be closed
using a Prolog full-stop (i.e., a dot followed by a blank). Returns FALSE if a syntax error
was encountered and TRUE after successful completion. In addition to returning FALSE, the
exception-term is returned in t on a syntax error. See also term to atom/2.
The following example builds a goal term from a string and calls it.
int
call_chars(const char *goal)
{ fid_t fid = PL_open_foreign_frame();
term_t g = PL_new_term_ref();
BOOL rval;
if ( PL_chars_to_term(goal, g) )
rval = PL_call(goal, NULL);
else
rval = FALSE;
PL_discard_foreign_frame(fid);
return rval;
}
...
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
285
call_chars("consult(load)");
...
int PL wchars to term(const pl wchar t *chars, term t -t)
Wide character version of PL chars to term().
char * PL quote(int chr, const char *string)
Return a quoted version of string. If chr is ’\’’, the result is a quoted atom. If chr is ’"’, the
result is a string. The result string is stored in the same ring of buffers as described with the
BUF RING argument of PL get chars();
In the current implementation, the string is surrounded by chr and any occurrence of chr is
doubled. In the future the behaviour will depend on the character escapes Prolog ﬂag.
9.4.6
Convenient functions to generate Prolog exceptions
The typical implementation of a foreign predicate ﬁrst uses the PL get *() functions to extract C data
types from the Prolog terms. Failure of any of these functions is normally because the Prolog term
is of the wrong type. The * ex() family of functions are wrappers around (mostly) the PL get *()
functions, such that we can write code in the style below and get proper exceptions if an argument is
uninstantiated or of the wrong type.
/** set_size(+Name:atom, +Width:int, +Height:int) is det.
static foreign_t
set_size(term_t name, term_t width, term_t height)
{ char *n;
int w, h;
if ( !PL_get_chars(name, &n, CVT_ATOM|CVT_EXCEPTION) ||
!PL_get_integer_ex(with, &w) ||
!PL_get_integer_ex(height, &h) )
return FALSE;
...
}
int PL get atom ex(term t t, atom t *a)
As PL get atom(), but raises a type or instantiation error if t is not an atom.
int PL get integer ex(term t t, int *i)
As PL get integer(), but raises a type or instantiation error if t is not an integer, or a
representation error if the Prolog integer does not ﬁt in a C int.
int PL get long ex(term t t, long *i)
As PL get long(), but raises a type or instantiation error if t is not an atom, or a represen-
tation error if the Prolog integer does not ﬁt in a C long.
SWI-Prolog 6.6 Reference Manual

286
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
int PL get int64 ex(term t t, int64 t *i)
As PL get int64(), but raises a type or instantiation error if t is not an atom, or a represen-
tation error if the Prolog integer does not ﬁt in a C int64 t.
int PL get intptr ex(term t t, intptr t *i)
As PL get intptr(), but raises a type or instantiation error if t is not an atom, or a repre-
sentation error if the Prolog integer does not ﬁt in a C intptr t.
int PL get size ex(term t t, size t *i)
As PL get size(), but raises a type or instantiation error if t is not an atom, or a represen-
tation error if the Prolog integer does not ﬁt in a C size t.
int PL get bool ex(term t t, int *i)
As PL get bool(), but raises a type or instantiation error if t is not an boolean.
int PL get ﬂoat ex(term t t, double *f)
As PL get float(), but raises a type or instantiation error if t is not a ﬂoat.
int PL get char ex(term t t, int *p, int eof)
Get a character code from t, where t is either an integer or an atom with length one. If eof
is TRUE and t is -1, p is ﬁlled with -1. Raises an appropriate error if the conversion is not
possible.
int PL get pointer ex(term t t, void **addrp)
As PL get pointer(), but raises a type or instantiation error if t is not a pointer.
int PL get list ex(term t l, term t h, term t t)
As PL get list(), but raises a type or instantiation error if t is not a list.
int PL get nil ex(term t l)
As PL get nil(), but raises a type or instantiation error if t is not the empty list.
int PL unify list ex(term t l, term t h, term t t)
As PL unify list(), but raises a type error if t is not a variable, list-cell or the empty list.
int PL unify nil ex(term t l)
As PL unify nil(), but raises a type error if t is not a variable, list-cell or the empty list.
int PL unify bool ex(term t t, int val)
As PL unify bool(), but raises a type error if t is not a variable or a boolean.
The second family of functions in this section simpliﬁes the generation of ISO compatible error
terms. Any foreign function that calls this function must return to Prolog with the return code of the
error function or the constant FALSE. If available, these error functions add the name of the calling
predicate to the error context. See also PL raise exception().
int PL instantiation error(term t culprit)
Raise instantiation error. Culprit is ignored, but should be bound to the term that is
not a variable. See instantiation error/1.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
287
int PL uninstantiation error(term t culprit)
Raise uninstantiation error(culprit). This should be called if an argument that
must be unbound at entry is bound to culprit.
int PL representation error(const char *resource)
Raise representation error(resource). See representation error/1.
int PL type error(const char *expected, term t culprit)
Raise type error(expected, culprit). See type error/2.
int PL domain error(const char *expected, term t culprit)
Raise domain error(expected, culprit). See domain error/2.
int PL existence error(const char *type, term t culprit)
Raise existence error(type, culprit). See type error/2.
int PL permission error(const char *operation, const char *type, term t culprit)
Raise
permission error(operation, type, culprit).
See
permission error/3.
int PL resource error(const char *resource)
Raise resource error(resource). See resource error/1.
9.4.7
BLOBS: Using atoms to store arbitrary binary data
SWI-Prolog atoms as well as strings can represent arbitrary binary data of arbitrary length. This
facility is attractive for storing foreign data such as images in an atom. An atom is a unique handle to
this data and the atom garbage collector is able to destroy atoms that are no longer referenced by the
Prolog engine. This property of atoms makes them attractive as a handle to foreign resources, such as
Java atoms, Microsoft’s COM objects, etc., providing safe combined garbage collection.
To exploit these features safely and in an organised manner, the SWI-Prolog foreign interface
allows for creating ‘atoms’ with additional type information. The type is represented by a structure
holding C function pointers that tell Prolog how to handle releasing the atom, writing it, sorting it,
etc. Two atoms created with different types can represent the same sequence of bytes. Atoms are ﬁrst
ordered on the rank number of the type and then on the result of the compare() function. Rank
numbers are assigned when the type is registered.
Deﬁning a BLOB type
The type PL blob t represents a structure with the layout displayed below. The structure contains
additional ﬁelds at the . . . for internal bookkeeping as well as future extensions.
typedef struct PL_blob_t
{ uintptr_t
magic;
/* PL_BLOB_MAGIC */
uintptr_t
flags;
/* Bitwise or of PL_BLOB_* */
char *
name;
/* name of the type */
int
(*release)(atom_t a);
int
(*compare)(atom_t a, atom_t b);
int
(*write)(IOSTREAM *s, atom_t a, int flags);
SWI-Prolog 6.6 Reference Manual

288
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
void
(*acquire)(atom_t a);
...
} PL_blob_t;
For each type, exactly one such structure should be allocated. Its ﬁrst ﬁeld must be initialised to
PL BLOB MAGIC. The ﬂags is a bitwise or of the following constants:
PL BLOB TEXT
If speciﬁed the blob is assumed to contain text and is considered a normal Prolog atom.
PL BLOB UNIQUE
If speciﬁed the system ensures that the blob-handle is a unique reference for a blob with the
given type, length and content. If this ﬂag is not speciﬁed, each lookup creates a new blob.
PL BLOB NOCOPY
By default the content of the blob is copied. Using this ﬂag the blob references the external
data directly. The user must ensure the provided pointer is valid as long as the atom lives. If
PL BLOB UNIQUE is also speciﬁed, uniqueness is determined by comparing the pointer rather
than the data pointed at.
The name ﬁeld represents the type name as available to Prolog. See also current blob/2.
The other ﬁelds are function pointers that must be initialised to proper functions or NULL to get the
default behaviour of built-in atoms. Below are the deﬁned member functions:
void acquire(atom t a)
Called if a new blob of this type is created through PL put blob() or PL unify blob().
This callback may be used together with the release hook to deal with reference-counted
external objects.
int release(atom t a)
The blob (atom) a is about to be released. This function can retrieve the data of the blob using
PL blob data(). If it returns FALSE the atom garbage collector will not reclaim the atom.
int compare(atom t a, atom t b)
Compare the blobs a and b, both of which are of the type associated to this blob type. Return
values are, as memcmp(), < 0 if a is less than b, = 0 if both are equal, and > 0 otherwise.
int write(IOSTREAM *s, atom t a, int ﬂags)
Write the content of the blob a to the stream s respecting the ﬂags. The ﬂags are a bitwise or of
zero or more of the PL WRT * ﬂags deﬁned in SWI-Prolog.h. This prototype is available if
the undocumented SWI-Stream.h is included before SWI-Prolog.h.
If this function is not provided, write/1 emits the content of the blob for blobs of type
PL BLOB TEXT or a string of the format <#hex data> for binary blobs.
If a blob type is registered from a loadable object (shared object or DLL) the blob type must be
deregistered before the object may be released.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
289
int PL unregister blob type(PL blob t *type)
Unlink the blob type from the registered type and transform the type of possible living blobs
to unregistered, avoiding further reference to the type structure, functions referred by it,
as well as the data. This function returns TRUE if no blobs of this type existed and FALSE
otherwise. PL unregister blob type() is intended for the uninstall() hook of foreign
modules, avoiding further references to the module.
Accessing blobs
The blob access functions are similar to the atom accessing functions. Blobs being atoms, the atom
functions operate on blobs and vice versa. For clarity and possible future compatibility issues, how-
ever, it is not advised to rely on this.
int PL is blob(term t t, PL blob t **type)
Succeeds if t refers to a blob, in which case type is ﬁlled with the type of the blob.
int PL unify blob(term t t, void *blob, size t len, PL blob t *type)
Unify t to a new blob constructed from the given data and associated to the given type. See also
PL unify atom nchars().
int PL put blob(term t t, void *blob, size t len, PL blob t *type)
Store the described blob in t. The return value indicates whether a new blob was allocated
(FALSE) or the blob is a reference to an existing blob (TRUE). Reporting new/existing can be
used to deal with external objects having their own reference counts. If the return is TRUE this
reference count must be incremented, and it must be decremented on blob destruction callback.
See also PL put atom nchars().
int PL get blob(term t t, void **blob, size t *len, PL blob t **type)
If t holds a blob or atom, get the data and type and return TRUE. Otherwise return FALSE.
Each result pointer may be NULL, in which case the requested information is ignored.
void * PL blob data(atom t a, size t *len, PL blob t **type)
Get the data and type associated to a blob. This function is mainly used from the callback
functions described in section 9.4.7.
9.4.8
Exchanging GMP numbers
If SWI-Prolog is linked with the GNU Multiple Precision Arithmetic Library (GMP, used by default),
the foreign interface provides functions for exchanging numeric values to GMP types. To access these
functions the header <gmp.h> must be included before <SWI-Prolog.h>. Foreign code using
GMP linked to SWI-Prolog asks for some considerations.
• SWI-Prolog normally rebinds the GMP allocation functions using mp set memory functions().
This means SWI-Prolog must be initialised before the foreign code touches any GMP function.
You can call \cfuncref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, TRUE}
to
force
Prolog’s
GMP
initialization
without
doing
the
rest
of
the
Prolog
ini-
tialization.
If
you
do
not
want
Prolog
rebinding
the
GMP
allocation,
call
\cfuncref{PL_action}{PL_GMP_SET_ALLOC_FUNCTIONS, FALSE}
before
initializing Prolog.
SWI-Prolog 6.6 Reference Manual

290
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
• On Windows, each DLL has its own memory pool. To make exchange of GMP numbers be-
tween Prolog and foreign code possible you must either let Prolog rebind the allocation func-
tions (default) or you must recompile SWI-Prolog to link to a DLL version of the GMP library.
Here is an example exploiting the function mpz nextprime():
#include <gmp.h>
#include <SWI-Prolog.h>
static foreign_t
next_prime(term_t n, term_t prime)
{ mpz_t mpz;
int rc;
mpz_init(mpz);
if ( PL_get_mpz(n, mpz) )
{ mpz_nextprime(mpz, mpz);
rc = PL_unify_mpz(prime, mpz);
} else
rc = FALSE;
mpz_clear(mpz);
return rc;
}
install_t
install()
{ PL_register_foreign("next_prime", 2, next_prime, 0);
}
int PL get mpz(term t t, mpz t mpz)
If t represents an integer, mpz is ﬁlled with the value and the function returns TRUE. Otherwise
mpz is untouched and the function returns FALSE. Note that mpz must have been initialised
before calling this function and must be cleared using mpz clear() to reclaim any storage
associated with it.
int PL get mpq(term t t, mpq t mpq)
If t is an integer or rational number (term rdiv/2), mpq is ﬁlled with the normalised rational
number and the function returns TRUE. Otherwise mpq is untouched and the function returns
FALSE. Note that mpq must have been initialised before calling this function and must be
cleared using mpq clear() to reclaim any storage associated with it.
int PL unify mpz(term t t, mpz t mpz)
Unify t with the integer value represented by mpz and return TRUE on success. The mpz
argument is not changed.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
291
int PL unify mpq(term t t, mpq t mpq)
Unify t with a rational number represented by mpq and return TRUE on success. Note that t is
uniﬁed with an integer if the denominator is 1. The mpq argument is not changed.
9.4.9
Calling Prolog from C
The Prolog engine can be called from C. There are two interfaces for this. For the ﬁrst, a term is
created that could be used as an argument to call/1, and then PL call() is used to call Prolog.
This system is simple, but does not allow to inspect the different answers to a non-deterministic goal
and is relatively slow as the runtime system needs to ﬁnd the predicate. The other interface is based on
PL open query(), PL next solution() and PL cut query() or PL close query().
This mechanism is more powerful, but also more complicated to use.
Predicate references
This section discusses the functions used to communicate about predicates. Though a Prolog predicate
may be deﬁned or not, redeﬁned, etc., a Prolog predicate has a handle that is neither destroyed nor
moved. This handle is known by the type predicate t.
predicate t PL pred(functor t f, module t m)
Return a handle to a predicate for the speciﬁed name/arity in the given module. This function
always succeeds, creating a handle for an undeﬁned predicate if no handle was available. If the
module argument m is NULL, the current context module is used.
predicate t PL predicate(const char *name, int arity, const char* module)
Same as PL pred(), but provides a more convenient interface to the C programmer.
void PL predicate info(predicate t p, atom t *n, int *a, module t *m)
Return information on the predicate p. The name is stored over n, the arity over a, while m
receives the deﬁnition module. Note that the latter need not be the same as speciﬁed with
PL predicate(). If the predicate is imported into the module given to PL predicate(),
this function will return the module where the predicate is deﬁned. Any of the arguments n, a
and m can be NULL.
Initiating a query from C
This section discusses the functions for creating and manipulating queries from C. Note that a foreign
context can have at most one active query. This implies that it is allowed to make strictly nested calls
between C and Prolog (Prolog calls C, calls Prolog, calls C, etc.), but it is not allowed to open multiple
queries and start generating solutions for each of them by calling PL next solution(). Be sure
to call PL cut query() or PL close query() on any query you opened before opening the
next or returning control back to Prolog.
qid t PL open query(module t ctx, int ﬂags, predicate t p, term t +t0)
Opens a query and returns an identiﬁer for it. ctx is the context module of the goal. When
NULL, the context module of the calling context will be used, or user if there is no
calling context (as may happen in embedded systems).
Note that the context module
only matters for meta-predicates.
See meta predicate/1, context module/1 and
module transparent/1. The p argument speciﬁes the predicate, and should be the result
SWI-Prolog 6.6 Reference Manual

292
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
of a call to PL pred() or PL predicate(). Note that it is allowed to store this handle as
global data and reuse it for future queries. The term reference t0 is the ﬁrst of a vector of term
references as returned by PL new term refs(n).
The ﬂags arguments provides some additional options concerning debugging and exception
handling. It is a bitwise or of the following values:
PL Q NORMAL
Normal operation. The debugger inherits its settings from the environment. If an excep-
tion occurs that is not handled in Prolog, a message is printed and the tracer is started to
debug the error.4
PL Q NODEBUG
Switch off the debugger while executing the goal. This option is used by many calls
to hook-predicates to avoid tracing the hooks.
An example is print/1 calling
portray/1 from foreign code.
PL Q CATCH EXCEPTION
If an exception is raised while executing the goal, do not report it, but make it available
for PL exception().
PL Q PASS EXCEPTION
As PL Q CATCH EXCEPTION, but do not invalidate the exception-term while calling
PL close query(). This option is experimental.
PL open query() can return the query identiﬁer ‘0’ if there is not enough space on the
environment stack. This function succeeds, even if the referenced predicate is not deﬁned. In
this case, running the query using PL next solution() will return an existence error. See
PL exception().
The example below opens a query to the predicate is_a/2 to ﬁnd the ancestor of ‘me’. The
reference to the predicate is valid for the duration of the process and may be cached by the
client.
char *
ancestor(const char *me)
{ term_t a0 = PL_new_term_refs(2);
static predicate_t p;
if ( !p )
p = PL_predicate("is_a", 2, "database");
PL_put_atom_chars(a0, me);
PL_open_query(NULL, PL_Q_NORMAL, p, a0);
...
}
4Do not pass the integer 0 for normal operation, as this is interpreted as PL Q NODEBUG for backward compatibility
reasons.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
293
int PL next solution(qid t qid)
Generate the ﬁrst (next) solution for the given query. The return value is TRUE if a solution
was found, or FALSE to indicate the query could not be proven. This function may be called
repeatedly until it fails to generate all solutions to the query.
void PL cut query(qid t qid)
Discards the query, but does not delete any of the data created by the query. It just invalidates
qid, allowing for a new call to PL open query() in this context.
void PL close query(qid t qid)
As PL cut query(), but all data and bindings created by the query are destroyed.
int PL call predicate(module t m, int ﬂags, predicate t pred, term t +t0)
Shorthand for PL open query(), PL next solution(), PL cut query(), generat-
ing a single solution. The arguments are the same as for PL open query(), the return value
is the same as PL next solution().
int PL call(term t t, module t m)
Call term t just like the Prolog predicate once/1. t is called in the module m, or in the context
module if m == NULL. Returns TRUE if the call succeeds, FALSE otherwise. Figure 9.3
shows an example to obtain the number of deﬁned atoms. All checks are omitted to improve
readability.
9.4.10
Discarding Data
The Prolog data created and term references needed to set up the call and/or analyse the result can
in most cases be discarded right after the call. PL close query() allows for destroying the data,
while leaving the term references. The calls below may be used to destroy term references and data.
See ﬁgure 9.3 for an example.
fid t PL open foreign frame()
Create a foreign frame, holding a mark that allows the system to undo bindings and destroy
data created after it, as well as providing the environment for creating term references. This
function is called by the kernel before calling a foreign predicate.
void PL close foreign frame(ﬁd t id)
Discard all term references created after the frame was opened. All other Prolog data is re-
tained. This function is called by the kernel whenever a foreign function returns control back
to Prolog.
void PL discard foreign frame(ﬁd t id)
Same as PL close foreign frame(), but also undo all bindings made since the open and
destroy all Prolog data.
void PL rewind foreign frame(ﬁd t id)
Undo all bindings and discard all term references created since the frame was created, but do
not pop the frame. That is, the same frame can be rewound multiple times, and must eventually
be closed or discarded.
It is obligatory to call either of the two closing functions to discard a foreign frame. Foreign
frames may be nested.
SWI-Prolog 6.6 Reference Manual

294
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
int
count_atoms()
{ fid_t fid = PL_open_foreign_frame();
term_t goal
= PL_new_term_ref();
term_t a1
= PL_new_term_ref();
term_t a2
= PL_new_term_ref();
functor_t s2 = PL_new_functor(PL_new_atom("statistics"), 2);
int atoms;
PL_put_atom_chars(a1, "atoms");
PL_cons_functor(goal, s2, a1, a2);
PL_call(goal, NULL);
/* call it in current module */
PL_get_integer(a2, &atoms);
PL_discard_foreign_frame(fid);
return atoms;
}
Figure 9.3: Calling Prolog
9.4.11
Foreign Code and Modules
Modules are identiﬁed via a unique handle. The following functions are available to query and ma-
nipulate modules.
module t PL context()
Return the module identiﬁer of the context module of the currently active foreign predicate.
int PL strip module(term t +raw, module t *m, term t -plain)
Utility function. If raw is a term, possibly holding the module construct ⟨module⟩:⟨rest⟩, this
function will make plain a reference to ⟨rest⟩and ﬁll module * with ⟨module⟩. For further
nested module constructs the innermost module is returned via module *. If raw is not a module
construct, raw will simply be put in plain. The value pointed to by m must be initialized before
calling PL strip module(), either to the default module or to NULL. A NULL value is
replaced by the current context module if raw carries no module. The following example shows
how to obtain the plain term and module if the default module is the user module:
{ module m = PL_new_module(PL_new_atom("user"));
term_t plain = PL_new_term_ref();
PL_strip_module(term, &m, plain);
...
}
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
295
atom t PL module name(module t module)
Return the name of module as an atom.
module t PL new module(atom t name)
Find an existing module or create a new module with the name name.
9.4.12
Prolog exceptions in foreign code
This section discusses PL exception(), PL throw() and PL raise exception(), the
interface functions to detect and generate Prolog exceptions from C code.
PL throw()
and PL raise exception() from the C interface raise an exception from foreign code.
PL throw() exploits the C function longjmp() to return immediately to the innermost
PL next solution().
PL raise exception() registers the exception term and returns
FALSE. If a foreign predicate returns FALSE, while an exception term is registered, a Prolog ex-
ception will be raised by the virtual machine.
Calling these functions outside the context of a function implementing a foreign predicate results
in undeﬁned behaviour.
PL exception() may be used after a call to PL next solution() fails, and returns a term
reference to an exception term if an exception was raised, and 0 otherwise.
If
a
C
function
implementing
a
predicate
calls
Prolog
and
detects
an
exception
using
PL exception(),
it
can
handle
this
exception
or
return
with
the
exception.
Some caution is required though.
It is not allowed to call PL close query() or
PL discard foreign frame() afterwards, as this will invalidate the exception term. Below
is the code that calls a Prolog-deﬁned arithmetic function (see arithmetic function/1).
If PL next solution() succeeds, the result is analysed and translated to a number, after
which the query is closed and all Prolog data created after PL open foreign frame() is de-
stroyed. On the other hand, if PL next solution() fails and if an exception was raised, just
pass it. Otherwise generate an exception (PL error() is an internal call for building the standard
error terms and calling PL raise exception()). After this, the Prolog environment should be
discarded using PL cut query() and PL close foreign frame() to avoid invalidating the
exception term.
static int
prologFunction(ArithFunction f, term_t av, Number r)
{ int arity = f->proc->definition->functor->arity;
fid_t fid = PL_open_foreign_frame();
qid_t qid;
int rval;
qid = PL_open_query(NULL, PL_Q_NORMAL, f->proc, av);
if ( PL_next_solution(qid) )
{ rval = valueExpression(av+arity-1, r);
PL_close_query(qid);
PL_discard_foreign_frame(fid);
} else
{ term_t except;
SWI-Prolog 6.6 Reference Manual

296
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
if ( (except = PL_exception(qid)) )
{ rval = PL_throw(except);
/* pass exception */
} else
{ char *name = stringAtom(f->proc->definition->functor->name);
/* generate exception */
rval = PL_error(name, arity-1, NULL, ERR_FAILED, f->proc);
}
PL_cut_query(qid);
/* donot destroy data */
PL_close_foreign_frame(fid);
/* same */
}
return rval;
}
int PL raise exception(term t exception)
Generate an exception (as throw/1) and return FALSE. Below is an example returning an
exception from a foreign predicate:
foreign_t
pl_hello(term_t to)
{ char *s;
if ( PL_get_atom_chars(to, &s) )
{ Sprintf("Hello \"%s\"\n", s);
PL_succeed;
} else
{ term_t except = PL_new_term_ref();
PL_unify_term(except,
PL_FUNCTOR_CHARS, "type_error", 2,
PL_CHARS, "atom",
PL_TERM, to);
return PL_raise_exception(except);
}
}
int PL throw(term t exception)
Similar to PL raise exception(), but returns using the C longjmp() function to the
innermost PL next solution().
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
297
term t PL exception(qid t qid)
If PL next solution() fails, this can be due to normal failure of the Prolog call, or because
an exception was raised using throw/1. This function returns a handle to the exception
term if an exception was raised, or 0 if the Prolog goal simply failed. If there is an exception,
PL exception() allocates a term-handle using PL new term ref() that is used to return
the exception term.
Additionally, \cfuncref{PL_exception}{0} returns the pending exception in the cur-
rent query or 0 if no exception is pending. This can be used to check the error status after a
failing call to, e.g., one of the uniﬁcation functions.
void PL clear exception(void)
Tells Prolog that the encountered exception must be ignored. This function must be called if
control remains in C after a previous API call fails with an exception.5
9.4.13
Catching Signals (Software Interrupts)
SWI-Prolog offers both a C and Prolog interface to deal with software interrupts (signals). The Prolog
mapping is deﬁned in section 4.11. This subsection deals with handling signals from C.
If a signal is not used by Prolog and the handler does not call Prolog in any way, the native signal
interface routines may be used.
Some versions of SWI-Prolog, notably running on popular Unix platforms, handle SIG SEGV
for guarding the Prolog stacks. If the application wishes to handle this signal too, it should use
PL signal() to install its handler after initialising Prolog. SWI-Prolog will pass SIG SEGV to the
user code if it detected the signal is not related to a Prolog stack overﬂow.
Any handler that wishes to call one of the Prolog interface functions should call PL signal()
for its installation.
void (*)() PL signal(sig, func)
This function is equivalent to the BSD-Unix signal() function, regardless of the platform used.
The signal handler is blocked while the signal routine is active, and automatically reactivated
after the handler returns.
After a signal handler is registered using this function, the native signal interface redirects the
signal to a generic signal handler inside SWI-Prolog. This generic handler validates the en-
vironment, creates a suitable environment for calling the interface functions described in this
chapter and ﬁnally calls the registered user-handler.
By default, signals are handled asynchronously (i.e., at the time they arrive). It is inherently
dangerous to call extensive code fragments, and especially exception related code from asyn-
chronous handlers. The interface allows for synchronous handling of signals. In this case
the native OS handler just schedules the signal using PL raise(), which is checked by
PL handle signals() at the call- and redo-port. This behaviour is realised by or-ing sig
with the constant PL SIGSYNC.6
Signal handling routines may raise exceptions using PL raise exception(). The use of
PL throw() is not safe. If a synchronous handler raises an exception, the exception is delayed
to the next call to PL handle signals();
5This feature is non-portable. Other Prolog systems (e.g., YAP) have no facilities to ignore raised exceptions, and the
design of YAP’s exception handling does not support such a facility.
6A better default would be to use synchronous handling, but this interface preserves backward compatibility.
SWI-Prolog 6.6 Reference Manual

298
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
int PL raise(int sig)
Register sig for synchronous handling by Prolog.
Synchronous signals are handled at the
call-port or if foreign code calls PL handle signals(). See also thread signal/2.
int PL handle signals(void)
Handle any signals pending from PL raise(). PL handle signals() is called at each
pass through the call- and redo-port at a safe point. Exceptions raised by the handler using
PL raise exception() are properly passed to the environment.
The user may call this function inside long-running foreign functions to handle scheduled inter-
rupts. This routine returns the number of signals handled. If a handler raises an exception, the
return value is -1 and the calling routine should return with FALSE as soon as possible.
int PL get signum ex(term t t, int *sig)
Extract a signal speciﬁcation from a Prolog term and store as an integer signal number in sig.
The speciﬁcation is an integer, a lowercase signal name without SIG or the full signal name.
These refer to the same: 9, kill and SIGKILL. Leaves a typed, domain or instantiation error
if the conversion fails.
9.4.14
Miscellaneous
Term Comparison
int PL compare(term t t1, term t t2)
Compares two terms using the standard order of terms and returns -1, 0 or 1.
See also
compare/3.
int PL same compound(term t t1, term t t2)
Yields TRUE if t1 and t2 refer to physically the same compound term and FALSE otherwise.
Recorded database
In some applications it is useful to store and retrieve Prolog terms from C code. For example, the
XPCE graphical environment does this for storing arbitrary Prolog data as slot-data of XPCE objects.
Please note that the returned handles have no meaning at the Prolog level and the recorded terms
are not visible from Prolog. The functions PL recorded() and PL erase() are the only func-
tions that can operate on the stored term.
Two groups of functions are provided. The ﬁrst group (PL record() and friends) store Prolog
terms on the Prolog heap for retrieval during the same session. These functions are also used by
recorda/3 and friends. The recorded database may be used to communicate Prolog terms between
threads.
record t PL record(term t +t)
Record the term t into the Prolog database as recorda/3 and return an opaque handle to the
term. The returned handle remains valid until PL erase() is called on it. PL recorded()
is used to copy recorded terms back to the Prolog stack.
int PL recorded(record t record, term t -t)
Copy a recorded term back to the Prolog stack. The same record may be used to copy multiple
instances at any time to the Prolog stack. Returns TRUE on success, and FALSE if there
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
299
is not enough space on the stack to accommodate the term. See also PL record() and
PL erase().
void PL erase(record t record)
Remove the recorded term from the Prolog database, reclaiming all associated memory re-
sources.
The second group (headed by PL record external()) provides the same functionality, but
the returned data has properties that enable storing the data on an external device. It has been designed
to make it possible to store Prolog terms fast and compact in an external database. Here are the main
features:
• Independent of session
Records can be communicated to another Prolog session and made visible using
PL recorded external().
• Binary
The representation is binary for maximum performance. The returned data may contain zero
bytes.
• Byte-order independent
The representation can be transferred between machines with different byte order.
• No alignment restrictions
There are no memory alignment restrictions and copies of the record can thus be moved freely.
For example, it is possible to use this representation to exchange terms using shared memory
between different Prolog processes.
• Compact
It is assumed that a smaller memory footprint will eventually outperform slightly faster repre-
sentations.
• Stable
The format is designed for future enhancements without breaking compatibility with older
records.
char * PL record external(term t +t, size t *len)
Record the term t into the Prolog database as recorda/3 and return an opaque handle to the
term. The returned handle remains valid until PL erase external() is called on it.
It is allowed to copy the data and use PL recorded external() on the copy. The user
is responsible for the memory management of the copy. After copying, the original may be
discarded using PL erase external().
PL recorded external() is used to copy such recorded terms back to the Prolog stack.
int PL recorded external(const char *record, term t -t)
Copy a recorded term back to the Prolog stack. The same record may be used to copy mul-
tiple instances at any time to the Prolog stack.
See also PL record external() and
PL erase external().
int PL erase external(char *record)
Remove the recorded term from the Prolog database, reclaiming all associated memory re-
sources.
SWI-Prolog 6.6 Reference Manual

300
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
Getting ﬁle names
The function PL get file name() provides access to Prolog ﬁlenames and its ﬁle-search mech-
anism described with absolute file name/3. Its existence is motivated to realise a uniform
interface to deal with ﬁle properties, search, naming conventions, etc., from foreign code.
int PL get ﬁle name(term t spec, char **name, int ﬂags)
Translate a Prolog term into a ﬁle name. The name is stored in the static buffer ring described
with th PL get chars() option BUF RING. Conversion from the internal UNICODE
encoding is done using standard C library functions.
ﬂags is a bit-mask controlling the
conversion process. Options are:
PL FILE ABSOLUTE
Return an absolute path to the requested ﬁle.
PL FILE OSPATH
Return the name using the hosting OS conventions. On MS-Windows, \ is used to sepa-
rate directories rather than the canonical /.
PL FILE SEARCH
Invoke absolute file name/3. This implies rules from file search path/2
are used.
PL FILE EXIST
Demand the path to refer to an existing entity.
PL FILE READ
Demand read-access on the result.
PL FILE WRITE
Demand write-access on the result.
PL FILE EXECUTE
Demand execute-access on the result.
PL FILE NOERRORS
Do not raise any exceptions.
int PL get ﬁle nameW(term t spec, wchar t **name, int ﬂags)
Same as PL get file name(), but returns the ﬁlename as a wide-character string. This
is intended for Windows to access the Unicode version of the Win32 API. Note that the ﬂag
PL FILE OSPATH must be provided to fetch a ﬁlename in OS native (e.g., C:\x\y) notation.
9.4.15
Errors and warnings
PL warning() prints a standard Prolog warning message to the standard error (user error)
stream. Please note that new code should consider using PL raise exception() to raise a Prolog
exception. See also section 4.10.
int PL warning(format, a1, . . .)
Print an error message starting with ‘[WARNING: ’, followed by the output from format,
followed by a ‘]’ and a newline. Then start the tracer. format and the arguments are the same
as for printf(2). Always returns FALSE.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
301
9.4.16
Environment Control from Foreign Code
int PL action(int, ...)
Perform some action on the Prolog system. int describes the action. Remaining arguments
depend on the requested action. The actions are listed below:
PL ACTION TRACE
Start Prolog tracer (trace/0). Requires no arguments.
PL ACTION DEBUG
Switch on Prolog debug mode (debug/0). Requires no arguments.
PL ACTION BACKTRACE
Print backtrace on current output stream. The argument (an int) is the number of frames
printed.
PL ACTION HALT
Halt Prolog execution. This action should be called rather than Unix exit() to give Prolog
the opportunity to clean up. This call does not return. The argument (an int) is the exit
code. See halt/1.
PL ACTION ABORT
Generate a Prolog abort (abort/0). This call does not return. Requires no arguments.
PL ACTION BREAK
Create a standard Prolog break environment (break/0). Returns after the user types the
end-of-ﬁle character. Requires no arguments.
PL ACTION GUIAPP
Windows: Used to indicate to the kernel that the application is a GUI application if the
argument is not 0, and a console application if the argument is 0. If a fatal error occurs,
the system uses a windows messagebox to report this on a GUI application, and otherwise
simply prints the error and exits.
PL ACTION WRITE
Write the argument, a char * to the current output stream.
PL ACTION FLUSH
Flush the current output stream. Requires no arguments.
PL ACTION ATTACH CONSOLE
Attach a console to a thread if it does not have one. See attach console/0.
PL GMP SET ALLOC FUNCTIONS
Takes an integer argument. If TRUE, the GMP allocations are immediately bound to the
Prolog functions. If FALSE, SWI-Prolog will never rebind the GMP allocation functions.
See mp set memory functions() in the GMP documentation. The action returns FALSE
if there is no GMP support or GMP is already initialised.
int PL backtrace(int depth, int ﬂags)
Print a Prolog backtrace to the standard error stream. The depth argument speciﬁes the max-
imum number of frames to print.
The ﬂags argument is a bitwise or of the constants
PL BT SAFE (0x1) and PL BT USER (0x2).
PL BT SAFE causes frames not to be
printed as normal Prolog goals, but using the predicate, program counter and clause-
number. For example, the dump below indicates the frame is executing the 2nd clause of
SWI-Prolog 6.6 Reference Manual

302
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
PL QUERY ARGC
Return an integer holding the number of ar-
guments given to Prolog from Unix.
PL QUERY ARGV
Return a char ** holding the argument
vector given to Prolog from Unix.
PL QUERY SYMBOLFILE
Return a char * holding the current symbol
ﬁle of the running process.
PL MAX INTEGER
Return a long, representing the maximal inte-
ger value represented by a Prolog integer.
PL MIN INTEGER
Return a long, representing the minimal inte-
ger value.
PL QUERY VERSION
Return a long, representing the version as
10, 000 × M + 100 × m + p, where M is
the major, m the minor version number and p
the patch level. For example, 20717 means
2.7.17.
PL QUERY ENCODING
Return the default stream encoding of Prolog
(of type IOENC).
PL QUERY USER CPU
Get amount of user CPU time of the process
in milliseconds.
Table 9.1: PL query() options
$autoload:load_library_index_p/0 at program pointer 25. This can be interpreted
by dumping the virtual machine code using vm list/1.
[34] $autoload:load_library_index_p/0 [PC=19 in clause 2]
If the constant PL BT USER is speciﬁed, ‘no-debug’ frames are ignored. This predicate may
be used from the C-debugger (e.g., gdb) to get the Prolog stack at a crash location. Here is an
example dumping the top 20 frames of the Prolog stack.
(gdb) call PL_backtrace(20,0)
9.4.17
Querying Prolog
long PL query(int)
Obtain status information on the Prolog system. The actual argument type depends on the
information required. int describes what information is wanted.7 The options are given in
table 9.1.
9.4.18
Registering Foreign Predicates
int PL register foreign in module(char *mod, char *name, int arity, foreign t (*f)(), int ﬂags, ...)
Register the C function f to implement a Prolog predicate. After this call returns successfully a
7Returning pointers and integers as a long is bad style. The signature of this function should be changed.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
303
predicate with name name (a char *) and arity arity (a C int) is created in module mod. If
mod is NULL, the predicate is created in the module of the calling context, or if no context is
present in the module user.
When called in Prolog, Prolog will call function. ﬂags form a bitwise or’ed list of options for
the installation. These are:
PL FA META
Provide meta-predicate info (see below)
PL FA TRANSPARENT
Predicate is module transparent (deprecated)
PL FA NONDETERMINISTIC
Predicate
is
non-deterministic.
See
also
PL retry().
PL FA NOTRACE
Predicate cannot be seen in the tracer
PL FA VARARGS
Use alternative calling convention.
If PL FA META is provided, PL register foreign in module() takes one extra ar-
gument. This argument is of type const char*. This string must be exactly as long as
the number of arguments of the predicate and ﬁlled with characters from the set 0-9:ˆ-+?.
See meta predicate/1 for details.
PL FA TRANSPARENT is implied if at least one
meta-argument is provided (0-9:ˆ).
Note that meta-arguments are not always passed as
⟨module⟩:⟨term⟩. Always use PL strip module() to extract the module and plain term
from a meta-argument.8
Predicates may be registered either before or after PL initialise(). When registered be-
fore initialisation the registration is recorded and executed after installing the system predicates
and before loading the saved state.
Default calling (i.e. without PL FA VARARGS) function is passed the same number of term t
arguments as the arity of the predicate and, if the predicate is non-deterministic, an extra ar-
gument of type control t (see section 9.4.1). If PL FA VARARGS is provided, function is
called with three arguments. The ﬁrst argument is a term t handle to the ﬁrst argument. Fur-
ther arguments can be reached by adding the offset (see also PL new term refs()). The
second argument is the arity, which deﬁnes the number of valid term references in the argument
vector. The last argument is used for non-deterministic calls. It is currently undocumented and
should be deﬁned of type void*. Here is an example:
static foreign_t
atom_checksum(term_t a0, int arity, void* context)
{ char *s;
if ( PL_get_atom_chars(a0, &s) )
{ int sum;
for(sum=0; *s; s++)
sum += *s&0xff;
return PL_unify_integer(a0+1, sum&0xff);
}
return FALSE;
8It is encouraged to pass an additional NULL pointer for non-meta-predicates.
SWI-Prolog 6.6 Reference Manual

304
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
}
install_t
install()
{ PL_register_foreign("atom_checksum", 2,
atom_checksum, PL_FA_VARARGS);
}
int PL register foreign(const char *name, int arity, foreign t (*function)(), int ﬂags, ...)
Same as PL register foreign in module(), passing NULL for the module.
void PL register extensions in module(const char *module, PL extension *e)
Register a series of predicates from an array of deﬁnitions of the type PL extension in the
given module. If module is NULL, the predicate is created in the module of the calling context,
or if no context is present in the module user. The PL extension type is deﬁned as
typedef struct PL_extension
{ char
*predicate_name; /* Name of the predicate */
short
arity;
/* Arity of the predicate */
pl_function_t function;
/* Implementing functions */
short
flags;
/* Or of PL_FA_... */
} PL_extension;
For details, see PL register foreign in module(). Here is an example of its usage:
static PL_extension predicates[] = {
{ "foo",
1,
pl_foo, 0 },
{ "bar",
2,
pl_bar, PL_FA_NONDETERMINISTIC },
{ NULL,
0,
NULL,
0 }
};
main(int argc, char **argv)
{ PL_register_extensions_in_module("user", predicates);
if ( !PL_initialise(argc, argv) )
PL_halt(1);
...
}
void PL register extensions( PL extension *e)
Same as PL register extensions in module() using NULL for the module argu-
ment.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
305
9.4.19
Foreign Code Hooks
For various speciﬁc applications some hooks are provided.
PL dispatch hook t PL dispatch hook(PL dispatch hook t)
If this hook is not NULL, this function is called when reading from the terminal. It is supposed
to dispatch events when SWI-Prolog is connected to a window environment. It can return
two values: PL DISPATCH INPUT indicates Prolog input is available on ﬁle descriptor 0
or PL DISPATCH TIMEOUT to indicate a timeout.
The old hook is returned.
The type
PL dispatch hook t is deﬁned as:
typedef int
(*PL_dispatch_hook_t)(void);
void PL abort hook(PL abort hook t)
Install a hook when abort/0 is executed. SWI-Prolog abort/0 is implemented using C
setjmp()/longjmp() construct. The hooks are executed in the reverse order of their registra-
tion after the longjmp() took place and before the Prolog top level is reinvoked. The type
PL abort hook t is deﬁned as:
typedef void (*PL_abort_hook_t)(void);
int PL abort unhook(PL abort hook t)
Remove a hook installed with PL abort hook(). Returns FALSE if no such hook is found,
TRUE otherwise.
void PL on halt(int (*f)(int, void *), void *closure)
Register the function f to be called if SWI-Prolog is halted. The function is called with two
arguments: the exit code of the process (0 if this cannot be determined) and the closure
argument passed to the PL on halt() call. Handlers must return 0. Other return values
are reserved for future use. See also at halt/1.9 These handlers are called before system
cleanup and can therefore access all normal Prolog resources. See also PL exit hook().
void PL exit hook(int (*f)(int, void *), void *closure)
Similar to PL on halt(),
but the hooks are executed by PL halt() instead of
PL cleanup() just before calling exit().
PL agc hook t PL agc hook(PL agc hook t new)
Register a hook with the atom-garbage collector (see garbage collect atoms/0) that is
called on any atom that is reclaimed. The old hook is returned. If no hook is currently deﬁned,
NULL is returned. The argument of the called hook is the atom that is to be garbage collected.
The return value is an int. If the return value is zero, the atom is not reclaimed. The hook
may invoke any Prolog predicate.
The example below deﬁnes a foreign library for printing the garbage collected atoms for debug-
ging purposes.
9BUG: Although both PL on halt() and at halt/1 are called in FIFO order, all at halt/1 handlers are called
before all PL on halt() handlers.
SWI-Prolog 6.6 Reference Manual

306
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
#include <SWI-Stream.h>
#include <SWI-Prolog.h>
static int
atom_hook(atom_t a)
{ Sdprintf("AGC: deleting %s\n", PL_atom_chars(a));
return TRUE;
}
static PL_agc_hook_t old;
install_t
install()
{ old = PL_agc_hook(atom_hook);
}
install_t
uninstall()
{ PL_agc_hook(old);
}
9.4.20
Storing foreign data
When combining foreign code with Prolog, it can be necessary to make data represented in the foreign
language available to Prolog. For example, to pass it to another foreign function. At the end of this
section, there is a partial implementation of using foreign functions to manage bit-vectors. Another
example is the SGML/XML library that manages a ‘parser’ object, an object that represents the current
state of the parser and that can be directed to perform actions such as parsing a document or make
queries about the document content.
This section provides some hints for handling foreign data in Prolog. There are four options for
storing such data:
• Natural Prolog data
Uses the representation one would choose if no foreign interface was required. For example, a
bitvector representing a list of small integers can be represented as a Prolog list of integers.
• Opaque packed data on the stacks
It is possible to represent the raw binary representation of the foreign object as a
Prolog string (see section 4.24).
Strings may be created from foreign data using
PL put string nchars() and retrieved using PL get string chars(). It is good
practice to wrap the string in a compound term with arity 1, so Prolog can identify the type.
The hook portray/1 rules may be used to streamline printing such terms during develop-
ment.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
307
• Opaque packed data in a blob
Similar to the above solution, binary data can be stored in an atom. The blob interface (sec-
tion 9.4.7) provides additional facilities to assign a type and hook-functions that act on creation
and destruction of the underlying atom.
• Natural foreign data, passed as a pointer
An alternative is to pass a pointer to the foreign data. Again, the pointer is often wrapped in a
compound term.
The choice may be guided using the following distinctions
• Is the data opaque to Prolog
With ‘opaque’ data, we refer to data handled in foreign functions, passed around in Prolog, but
where Prolog never examines the contents of the data itself. If the data is opaque to Prolog, the
selection will be driven solely by simplicity of the interface and performance.
• What is the lifetime of the data
With ‘lifetime’ we refer to how it is decided that the object is (or can be) destroyed. We can
distinguish three cases:
1. The object must be destroyed on backtracking and normal Prolog garbage collection (i.e.,
it acts as a normal Prolog term). In this case, representing the object as a Prolog string
(second option above) is the only feasible solution.
2. The data must survive Prolog backtracking. This leaves two options. One is to represent
the object using a pointer and use explicit creation and destruction, making the program-
mer responsible. The alternative is to use the blob-interface, leaving destruction to the
(atom) garbage collector.
3. The data lives as during the lifetime of a foreign function that implements a predicate. If
the predicate is deterministic, foreign automatic variables are suitable. If the predicate is
non-deterministic, the data may be allocated using malloc() and a pointer may be passed.
See section 9.4.1.
Examples for storing foreign data
In this section, we outline some examples, covering typical cases. In the ﬁrst example, we will deal
with extending Prolog’s data representation with integer sets, represented as bit-vectors. Then, we
discuss the outline of the DDE interface.
Integer sets
with not-too-far-apart upper- and lower-bounds can be represented using bit-vectors.
Common set operations, such as union, intersection, etc., are reduced to simple and’ing and or’ing
the bit-vectors. This can be done using Prolog’s unbounded integers.
For really demanding applications, foreign representation will perform better, especially time-
wise.
Bit-vectors are naturally expressed using string objects.
If the string is wrapped in
bitvector/1, the lower-bound of the vector is 0 and the upper-bound is not deﬁned; an imple-
mentation for getting and putting the sets as well as the union predicate for it is below.
#include <SWI-Prolog.h>
SWI-Prolog 6.6 Reference Manual

308
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))
static functor_t FUNCTOR_bitvector1;
static int
get_bitvector(term_t in, int *len, unsigned char **data)
{ if ( PL_is_functor(in, FUNCTOR_bitvector1) )
{ term_t a = PL_new_term_ref();
PL_get_arg(1, in, a);
return PL_get_string(a, (char **)data, len);
}
PL_fail;
}
static int
unify_bitvector(term_t out, int len, const unsigned char *data)
{ if ( PL_unify_functor(out, FUNCTOR_bitvector1) )
{ term_t a = PL_new_term_ref();
PL_get_arg(1, out, a);
return PL_unify_string_nchars(a, len, (const char *)data);
}
PL_fail;
}
static foreign_t
pl_bitvector_union(term_t t1, term_t t2, term_t u)
{ unsigned char *s1, *s2;
int l1, l2;
if ( get_bitvector(t1, &l1, &s1) &&
get_bitvector(t2, &l2, &s2) )
{ int l = max(l1, l2);
unsigned char *s3 = alloca(l);
if ( s3 )
{ int n;
int ml = min(l1, l2);
for(n=0; n<ml; n++)
s3[n] = s1[n] | s2[n];
for( ; n < l1; n++)
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
309
s3[n] = s1[n];
for( ; n < l2; n++)
s3[n] = s2[n];
return unify_bitvector(u, l, s3);
}
return PL_warning("Not enough memory");
}
PL_fail;
}
install_t
install()
{ PL_register_foreign("bitvector_union", 3, pl_bitvector_union, 0);
FUNCTOR_bitvector1 = PL_new_functor(PL_new_atom("bitvector"), 1);
}
The DDE interface
(see section 4.42) represents another common usage of the foreign interface:
providing communication to new operating system features. The DDE interface requires knowledge
about active DDE server and client channels. These channels contains various foreign data types. Such
an interface is normally achieved using an open/close protocol that creates and destroys a handle. The
handle is a reference to a foreign data structure containing the relevant information.
There are a couple of possibilities for representing the handle. The choice depends on respon-
sibilities and debugging facilities. The simplest approach is to use PL unify pointer() and
PL get pointer(). This approach is fast and easy, but has the drawbacks of (untyped) point-
ers: there is no reliable way to detect the validity of the pointer, nor to verify that it is pointing to a
structure of the desired type. The pointer may be wrapped into a compound term with arity 1 (i.e.,
dde channel(⟨Pointer⟩)), making the type-problem less serious.
Alternatively (used in the DDE interface), the interface code can maintain a (preferably variable
length) array of pointers and return the index in this array. This provides better protection. Especially
for debugging purposes, wrapping the handle in a compound is a good suggestion.
9.4.21
Embedding SWI-Prolog in other applications
With embedded Prolog we refer to the situation where the ‘main’ program is not the Prolog applica-
tion. Prolog is sometimes embedded in C, C++, Java or other languages to provide logic based services
in a larger application. Embedding loads the Prolog engine as a library to the external language. Pro-
log itself only provides for embedding in the C language (compatible with C++). Embedding in Java
is achieved using JPL using a C-glue between the Java and Prolog C interfaces.
The most simple embedded program is below.
The interface function PL initialise()
must be called before any of the other SWI-Prolog foreign language functions described in
SWI-Prolog 6.6 Reference Manual

310
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
this chapter, except for PL initialise hook(), PL new atom(), PL new functor() and
PL register foreign(). PL initialise() interprets all the command line arguments, ex-
cept for the -t toplevel ﬂag that is interpreted by PL toplevel().
int
main(int argc, char **argv)
{
#ifdef READLINE /* Remove if you don’t want readline */
PL_initialise_hook(install_readline);
#endif
if ( !PL_initialise(argc, argv) )
PL_halt(1);
PL_halt(PL_toplevel() ? 0 : 1);
}
int PL initialise(int argc, char **argv)
Initialises the SWI-Prolog heap and stacks, restores the Prolog state, loads the system and
personal initialisation ﬁles, runs the initialization/1 hooks and ﬁnally runs the
-g goal hook.
Special consideration is required for argv[0]. On Unix, this argument passes the part of the
command line that is used to locate the executable. Prolog uses this to ﬁnd the ﬁle holding the
running executable. The Windows version uses this to ﬁnd a module of the running executable.
If the speciﬁed module cannot be found, it tries the module libpl.dll, containing the Prolog
runtime kernel. In all these cases, the resulting ﬁle is used for two purposes:
• See whether a Prolog saved state is appended to the ﬁle. If this is the case, this state will
be loaded instead of the default boot.prc ﬁle from the SWI-Prolog home directory. See
also qsave program/[1,2] and section 9.5.
• Find the Prolog home directory. This process is described in detail in section 9.6.
PL initialise() returns 1 if all initialisation succeeded and 0 otherwise.10
In most cases, argc and argv will be passed from the main program. It is allowed to create
your own argument vector, provided argv[0] is constructed according to the rules above. For
example:
int
main(int argc, char **argv)
{ char *av[10];
int ac = 0;
av[ac++] = argv[0];
av[ac++] = "-x";
10BUG: Various fatal errors may cause PL initialise() to call PL halt(1), preventing it from returning at all.
SWI-Prolog 6.6 Reference Manual

9.4. THE FOREIGN INCLUDE FILE
311
av[ac++] = "mystate";
av[ac]
= NULL;
if ( !PL_initialise(ac, av) )
PL_halt(1);
...
}
Please note that the passed argument vector may be referred from Prolog at any time and should
therefore be valid as long as the Prolog engine is used.
A good setup in Windows is to add SWI-Prolog’s bin directory to your PATH and either pass
a module holding a saved state, or "libpl.dll" as argv[0]. If the Prolog state is attached
to a DLL (see the -dll option of swipl-ld), pass the name of this DLL.
int PL is initialised(int *argc, char ***argv)
Test whether the Prolog engine is already initialised. Returns FALSE if Prolog is not initialised
and TRUE otherwise. If the engine is initialised and argc is not NULL, the argument count used
with PL initialise() is stored in argc. Same for the argument vector argv.
void PL install readline()
Installs the GNU readline line editor. Embedded applications that do not use the Prolog top
level should normally delete this line, shrinking the Prolog kernel signiﬁcantly. Note that the
Windows version does not use GNU readline.
int PL toplevel()
Runs the goal of the -t toplevel switch (default prolog/0) and returns 1 if successful,
0 otherwise.
int PL cleanup(int status)
This function performs the reverse of PL initialise(). It runs the PL on halt() and
at halt/1 handlers, closes all streams (except for the ‘standard I/O’ streams which are
ﬂushed only), deallocates all memory and restores all signal handlers. The status argument is
passed to the various termination hooks and indicates the exit-status.
The function returns TRUE if successful and FALSE otherwise. Currently, FALSE is returned
when an attempt is made to call PL cleanup() recursively or if one of the exit handlers
cancels the termination using cancel halt/1. Exit handlers may only cancel termination if
status is 0.
In theory, this function allows deleting and restarting the Prolog system in the same process. In
practice, SWI-Prolog’s cleanup process is far from complete, and trying to revive the system
using PL initialise() will leak memory in the best case. It can also crash the appliction.
In this state, there is little practical use for this function. If you want to use Prolog temporarily,
consider running it in a separate process. If you want to be able to reset Prolog, your options
are (again) a separate process, modules or threads.
void PL cleanup fork()
Stop intervaltimer that may be running on behalf of profile/1. The call is intended to be
used in combination with fork():
SWI-Prolog 6.6 Reference Manual

312
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
if ( (pid=fork()) == 0 )
{ PL_cleanup_fork();
<some exec variation>
}
The call behaves the same on Windows, though there is probably no meaningful application.
int PL halt(int status)
Clean up the Prolog environment using PL cleanup() and if successful call exit() with the
status argument. Returns FALSE if exit was cancelled by PL cleanup().
Threading, Signals and embedded Prolog
This section applies to Unix-based environments that have signals or multithreading. The Windows
version is compiled for multithreading, and Windows lacks proper signals.
We can distinguish two classes of embedded executables. There are small C/C++ programs that
act as an interfacing layer around Prolog. Most of these programs can be replaced using the normal
Prolog executable extended with a dynamically loaded foreign extension and in most cases this is
the preferred route. In other cases, Prolog is embedded in a complex application that—like Prolog—
wants to control the process environment. A good example is Java. Embedding Prolog is generally
the only way to get these environments together in one process image. Java applications, however, are
by nature multithreaded and appear to do signal handling (software interrupts).
On Unix systems, SWI-Prolog uses three signals:
SIGUSR1 is used to sychronise atom and clause garbage collection. The handler is installed at the
start of garbage collection and reverted to the old setting after completion.
SIGUSR2 has an empty signal handler. This signal is sent to a thread after sending a thread-signal
(see thread signal/2). It causes blocking system calls to return with EINTR, which gives
them the opportunity to react to thread-signals.
SIGINT is used by the top level to activate the tracer (typically bound to control-C). The ﬁrst control-
C posts a request for starting the tracer in a safe, synchronous fashion. If control-C is hit again
before the safe route is executed, it prompts the user whether or not a forced interrupt is desired.
The --nosignals option can be used to inhibit processing of SIGINT. The other signals are
vital for the functioning of SWI-Prolog. If they conﬂict with other applications, signal handling of
either component must be modiﬁed. The SWI-Prolog signals are deﬁned in pl-thread.h of the
source distribution.
9.5
Linking embedded applications using swipl-ld
The utility program swipl-ld (Win32: swipl-ld.exe) may be used to link a combination of C ﬁles
and Prolog ﬁles into a stand-alone executable. swipl-ld automates most of what is described in the
previous sections.
In normal usage, a copy is made of the default embedding template .../swipl/include/
stub.c. The main() routine is modiﬁed to suit your application. PL initialise() must be
SWI-Prolog 6.6 Reference Manual

9.5. LINKING EMBEDDED APPLICATIONS USING SWIPL-LD
313
passed the program name (argv[0]) (Win32: the executing program can be obtained using GetMod-
uleFileName()). The other elements of the command line may be modiﬁed. Next, swipl-ld is
typically invoked as:
swipl-ld -o output stubfile.c [other-c-or-o-files] [plfiles]
swipl-ld will ﬁrst split the options into various groups for both the C compiler and the Prolog
compiler. Next, it will add various default options to the C compiler and call it to create an executable
holding the user’s C code and the Prolog kernel. Then, it will call the SWI-Prolog compiler to create
a saved state from the provided Prolog ﬁles and ﬁnally, it will attach this saved state to the created
emulator to create the requested executable.
Below, it is described how the options are split and which additional options are passed.
-help
Print brief synopsis.
-pl prolog
Select the Prolog to use. This Prolog is used for two purposes: get the home directory as well
as the compiler/linker options and create a saved state of the Prolog code.
-ld linker
Linker used to link the raw executable. Default is to use the C compiler (Win32: link.exe).
-cc C compiler
Compiler for .c ﬁles found on the command line. Default is the compiler used to build SWI-
Prolog accessible through the Prolog ﬂag c cc (Win32: cl.exe).
-c++ C++-compiler
Compiler for C++ source ﬁle (extensions .cpp, .cxx, .cc or .C) found on the command
line. Default is c++ or g++ if the C compiler is gcc (Win32: cl.exe).
-nostate
Just relink the kernel, do not add any Prolog code to the new kernel. This is used to create a new
kernel holding additional foreign predicates on machines that do not support the shared-library
(DLL) interface, or if building the state cannot be handled by the default procedure used by
swipl-ld. In the latter case the state is created separately and appended to the kernel using
cat ⟨kernel⟩⟨state⟩> ⟨out⟩(Win32: copy /b ⟨kernel⟩+⟨state⟩⟨out⟩).
-shared
Link C, C++ or object ﬁles into a shared object (DLL) that can be loaded by the
load foreign library/1 predicate.
If used with -c it sets the proper options to
compile a C or C++ ﬁle ready for linking into a shared object.
-dll
Windows only. Embed SWI-Prolog into a DLL rather than an executable.
-c
Compile C or C++ source ﬁles into object ﬁles. This turns swipl-ld into a replacement for
the C or C++ compiler, where proper options such as the location of the include directory are
passed automatically to the compiler.
SWI-Prolog 6.6 Reference Manual

314
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
-E
Invoke the C preprocessor. Used to make swipl-ld a replacement for the C or C++ compiler.
-pl-options ,. . .
Additional options passed to Prolog when creating the saved state. The ﬁrst character immedi-
ately following pl-options is used as separator and translated to spaces when the argument
is built. Example: -pl-options,-F,xpce passes -F xpce as additional ﬂags to Prolog.
-ld-options ,. . .
Passes options to the linker, similar to -pl-options.
-cc-options ,. . .
Passes options to the C/C++ compiler, similar to -pl-options.
-v
Select verbose operation, showing the various programs and their options.
-o outﬁle
Reserved to specify the ﬁnal output ﬁle.
-llibrary
Speciﬁes a library for the C compiler. By default, -lswipl (Win32: libpl.lib) and the libraries
needed by the Prolog kernel are given.
-Llibrary-directory
Speciﬁes a library directory for the C compiler. By default the directory containing the Prolog
C library for the current architecture is passed.
-g | -Iinclude-directory | -Ddeﬁnition
These options are passed to the C compiler.
By default, the include directory containing
SWI-Prolog.h is passed. swipl-ld adds two additional * -Ddef ﬂags:
-D SWI PROLOG
Indicates the code is to be connected to SWI-Prolog.
-D SWI EMBEDDED
Indicates the creation of an embedded program.
*.o | *.c | *.C | *.cxx | *.cpp
Passed as input ﬁles to the C compiler.
*.pl |*.qlf
Passed as input ﬁles to the Prolog compiler to create the saved state.
*
All other options. These are passed as linker options to the C compiler.
9.5.1
A simple example
The following is a very simple example going through all the steps outlined above. It provides an
arithmetic expression evaluator. We will call the application calc and deﬁne it in the ﬁles calc.c
and calc.pl. The Prolog ﬁle is simple:
SWI-Prolog 6.6 Reference Manual

9.6. THE PROLOG ‘HOME’ DIRECTORY
315
calc(Atom) :-
term_to_atom(Expr, Atom),
A is Expr,
write(A),
nl.
The C part of the application parses the command line options, initialises the Prolog engine, locates
the calc/1 predicate and calls it. The coder is in ﬁgure 9.4.
The application is now created using the following command line:
% swipl-ld -o calc calc.c calc.pl
The following indicates the usage of the application:
% calc pi/2
1.5708
9.6
The Prolog ‘home’ directory
Executables embedding SWI-Prolog should be able to ﬁnd the ‘home’ directory of the devel-
opment environment unless a self-contained saved state has been added to the executable (see
qsave program/[1,2] and section 9.5).
If Prolog starts up, it will try to locate the development environment. To do so, it will try the
following steps until one succeeds:
1. If the --home=DIR is provided, use this.
2. If the environment variable SWI HOME DIR is deﬁned and points to an existing directory, use
this.
3. If the environment variable SWIPL is deﬁned and points to an existing directory, use this.
4. Locate the primary executable or (Windows only) a component (module) thereof and check
whether the parent directory of the directory holding this ﬁle contains the ﬁle swipl. If so,
this ﬁle contains the (relative) path to the home directory. If this directory exists, use this. This
is the normal mechanism used by the binary distribution.
5. If the precompiled path exists, use it. This is only useful for a source installation.
If all fails and there is no state attached to the executable or provided Windows module (see
PL initialise()), SWI-Prolog gives up. If a state is attached, the current working directory is
used.
The file search path/2 alias swi is set to point to the home directory located.
SWI-Prolog 6.6 Reference Manual

316
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
#include <stdio.h>
#include <SWI-Prolog.h>
#define MAXLINE 1024
int
main(int argc, char **argv)
{ char expression[MAXLINE];
char *e = expression;
char *program = argv[0];
char *plav[2];
int n;
/* combine all the arguments in a single string */
for(n=1; n<argc; n++)
{ if ( n != 1 )
*e++ = ’ ’;
strcpy(e, argv[n]);
e += strlen(e);
}
/* make the argument vector for Prolog */
plav[0] = program;
plav[1] = NULL;
/* initialise Prolog */
if ( !PL_initialise(1, plav) )
PL_halt(1);
/* Lookup calc/1 and make the arguments and call */
{ predicate_t pred = PL_predicate("calc", 1, "user");
term_t h0 = PL_new_term_refs(1);
int rval;
PL_put_atom_chars(h0, expression);
rval = PL_call_predicate(NULL, PL_Q_NORMAL, pred, h0);
PL_halt(rval ? 0 : 1);
}
return 0;
}
Figure 9.4: C source for the calc application
SWI-Prolog 6.6 Reference Manual

9.7. EXAMPLE OF USING THE FOREIGN INTERFACE
317
9.7
Example of Using the Foreign Interface
Below is an example showing all stages of the declaration of a foreign predicate that transforms atoms
possibly holding uppercase letters into an atom only holding lowercase letters. Figure 9.5 shows the
C source ﬁle, ﬁgure 9.6 illustrates compiling and loading of foreign code.
/*
Include file depends on local installation */
#include <SWI-Prolog.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
foreign_t
pl_lowercase(term_t u, term_t l)
{ char *copy;
char *s, *q;
int rval;
if ( !PL_get_atom_chars(u, &s) )
return PL_warning("lowercase/2: instantiation fault");
copy = malloc(strlen(s)+1);
for( q=copy; *s; q++, s++)
*q = (isupper(*s) ? tolower(*s) : *s);
*q = ’\0’;
rval = PL_unify_atom_chars(l, copy);
free(copy);
return rval;
}
install_t
install()
{ PL_register_foreign("lowercase", 2, pl_lowercase, 0);
}
Figure 9.5: Lowercase source ﬁle
SWI-Prolog 6.6 Reference Manual

318
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
% gcc -I/usr/local/lib/swipl-\plversion/include -fpic -c lowercase.c
% gcc -shared -o lowercase.so lowercase.o
% swipl
Welcome to SWI-Prolog (Version \plversion)
...
1 ?- load_foreign_library(lowercase).
true.
2 ?- lowercase(’Hello World!’, L).
L = ’hello world!’.
Figure 9.6: Compiling the C source and loading the object ﬁle
SWI-Prolog 6.6 Reference Manual

9.8. NOTES ON USING FOREIGN CODE
319
9.8
Notes on Using Foreign Code
9.8.1
Memory Allocation
SWI-Prolog’s heap memory allocation is based on the malloc(3) library routines. SWI-Prolog
provides the functions below as a wrapper around malloc(). Allocation errors in these functions trap
SWI-Prolog’s fatal-error handler, in which case PL malloc() or PL realloc() do not return.
Portable applications must use PL free() to release strings returned by PL get chars()
using the BUF MALLOC argument. Portable applications may use both PL malloc() and friends or
malloc() and friends but should not mix these two sets of functions on the same memory.
void * PL malloc(size t bytes)
Allocate bytes of memory.
On failure SWI-Prolog’s fatal-error handler is called and
PL malloc() does not return.
Memory allocated using these functions must use
PL realloc() and PL free() rather than realloc() and free().
void * PL realloc(void *mem, size t size)
Change the size of the allocated chunk, possibly moving it. The mem argument must be ob-
tained from a previous PL malloc() or PL realloc() call.
void PL free(void *mem)
Release memory. The mem argument must be obtained from a previous PL malloc() or
PL realloc() call.
Boehm-GC support
To accommodate future use of the Boehm garbage collector11 for heap memory allocation, the in-
terface provides the functions described below. Foreign extensions that wish to use the Boehm-GC
facilities can use these wrappers. Please note that if SWI-Prolog is not compiled to use Boehm-GC
(default), the user is responsible for calling PL free() to reclaim memory.
void* PL malloc atomic(size t bytes)
void* PL malloc uncollectable(size t bytes)
void* PL malloc atomic uncollectable(size t bytes)
If Boehm-GC is not used, these are all the same as PL malloc(). With Boehm-GC, these
map to the corresponding Boehm-GC functions. Atomic means that the content should not
be scanned for pointers, and uncollectable means that the object should never be garbage
collected.
void* PL malloc stubborn(size t bytes)
void PL end stubborn change(void *memory)
These functions allow creating objects, promising GC that the content will not change after
PL end stubborn change().
9.8.2
Compatibility between Prolog versions
Great care is taken to ensure binary compatibility of foreign extensions between different Prolog
versions. Only the much less frequently used stream interface has been responsible for binary incom-
patibilities.
11http://www.hpl.hp.com/personal/Hans Boehm/gc/
SWI-Prolog 6.6 Reference Manual

320
CHAPTER 9. FOREIGN LANGUAGE INTERFACE
Source code that relies on new features of the foreign interface can use the macro PLVERSION
to ﬁnd the version of SWI-Prolog.h and PL query() using the option PL QUERY VERSION to
ﬁnd the version of the attached Prolog system. Both follow the same numbering schema explained
with PL query().
9.8.3
Debugging and proﬁling foreign code (valgrind)
This section is only relevant for Unix users on platforms supported by valgrind. Valgrind is an excel-
lent binary instrumentation platform. Unlike many other instrumentation platforms, valgrind can deal
with code loaded through dlopen().
The callgrind tool can be used to proﬁle foreign code loaded under SWI-Prolog. Compile
the foreign library adding -g option to gcc or swipl-ld. By setting the environment variable
VALGRIND to yes, SWI-Prolog will not release loaded shared objects using dlclose(). This trick
is required to get source information on the loaded library. Without, valgrind claims that the shared
object has no debugging information.12 Here is the complete sequence using bash as login shell:
% VALGRIND=yes valgrind --tool=callgrind pl <args>
<prolog interaction>
% kcachegrind callgrind.out.<pid>
9.8.4
Name Conﬂicts in C modules
In the current version of the system all public C functions of SWI-Prolog are in the symbol table.
This can lead to name clashes with foreign code. Someday I should write a program to strip all these
symbols from the symbol table (why does Unix not have that?). For now I can only suggest you give
your function another name. You can do this using the C preprocessor. If—for example—your foreign
package uses a function warning(), which happens to exist in SWI-Prolog as well, the following macro
should ﬁx the problem:
#define warning warning_
Note that shared libraries do not have this problem as the shared library loader will only look for
symbols in the main executable for symbols that are not deﬁned in the library itself.
9.8.5
Compatibility of the Foreign Interface
The term reference mechanism was ﬁrst used by Quintus Prolog version 3. SICStus Prolog version 3
is strongly based on the Quintus interface. The described SWI-Prolog interface is similar to using the
Quintus or SICStus interfaces, deﬁning all foreign-predicate arguments of type +term. SWI-Prolog
explicitly uses type functor t, while Quintus and SICStus use ⟨name⟩and ⟨arity⟩. As the names
of the functions differ from Prolog to Prolog, a simple macro layer dealing with the names can also
deal with this detail. For example:
#define QP_put_functor(t, n, a) \
PL_put_functor(t, PL_new_functor(n, a))
12Tested using valgrind version 3.2.3 on x64.
SWI-Prolog 6.6 Reference Manual

9.8. NOTES ON USING FOREIGN CODE
321
The PL unify *() functions are lacking from the Quintus and SICStus interface. They can easily
be emulated, or the put/unify approach should be used to write compatible code.
The
PL open foreign frame()/PL close foreign frame()
combination
is
lacking from both other Prologs.
SICStus has PL new term refs(0),
followed by
PL reset term refs(), that allows for discarding term references.
The Prolog interface for the graphical user interface package XPCE shares about 90% of the code
using a simple macro layer to deal with different naming and calling conventions of the interfaces.
SWI-Prolog 6.6 Reference Manual

Generating Runtime
Applications
10
This chapter describes the features of SWI-Prolog for delivering applications that can run without the
development version of the system installed.
A SWI-Prolog runtime executable is a ﬁle consisting of two parts. The ﬁrst part is the emulator,
which is machine-dependent. The second part is the resource archive, which contains the compiled
program in a machine-independent format, startup options and possibly user-deﬁned resources; see
resource/3 and open resource/3.
These two parts can be connected in various ways. The most common way for distributed runtime
applications is to concatenate the two parts. This can be achieved using external commands (Unix:
cat, Windows: copy), or using the stand alone option to qsave program/2. The second
option is to attach a startup script in front of the resource that starts the emulator with the proper
options. This is the default under Unix. Finally, an emulator can be told to use a speciﬁed resource
ﬁle using the -x command line switch.
qsave program(+File, +Options)
Saves the current state of the program to the ﬁle File. The result is a resource archive containing
a saved state that expresses all Prolog data from the running program and all user-deﬁned
resources. Depending on the stand alone option, the resource is headed by the emulator, a
Unix shell script or nothing. Options is a list of additional options:
local(+KBytes)
Limit for the local stack. See section 2.4.3.
global(+KBytes)
Limit for the global stack. See section 2.4.3.
trail(+KBytes)
Limit for the trail stack. See section 2.4.3.
goal(:Callable)
Initialization goal for the new executable (see -g).
toplevel(:Callable)
Top-level goal for the new executable (see -t).
init ﬁle(+Atom)
Default initialization ﬁle for the new executable. See -f.
class(+Class)
If runtime, only read resources from the state (default). If kernel, lock all predicates
as system predicates. If development, save the predicates in their current state and
keep reading resources from their source (if present). See also resource/3.
autoload(+Boolean)
If true (default), run autoload/0 ﬁrst.
SWI-Prolog 6.6 Reference Manual

323
map(+File)
Dump a human-readable trace of what has been saved in File.
op(+Action)
One of save (default) to save the current operator table or standard to use the initial
table of the emulator.
stand alone(+Boolean)
If true, the emulator is the ﬁrst part of the state. If the emulator is started it will test
whether a boot ﬁle (state) is attached to the emulator itself and load this state. Provided
the application has all libraries loaded, the resulting executable is completely independent
of the runtime environment or location where it was built. See also section 2.10.2.
emulator(+File)
File to use for the emulator. Default is the running Prolog image.
foreign(+Action)
If
save,
include
shared
objects
(DLLs)
into
the
saved
state.
See
current foreign library/2. If the program strip is available, this is ﬁrst used
to reduce the size of the shared object. If a state is started, use foreign library/1
ﬁrst tries to locate the foreign resource in the executable.
When found it copies the
content of the resource to a temporary ﬁle and loads it. If possible (Unix), the temporary
object is deleted immediately after opening.1
qsave program(+File)
Equivalent to qsave program(File, []).
autoload
Check the current Prolog program for predicates that are referred to, are undeﬁned and have a
deﬁnition in the Prolog library. Load the appropriate libraries.
This predicate is used by qsave program/[1,2] to ensure the saved state does not depend
on availability of the libraries. The predicate autoload/0 examines all clauses of the loaded
program (obtained with clause/2) and analyzes the body for referenced goals. Such an anal-
ysis cannot be complete in Prolog, which allows for the creation of arbitrary terms at runtime
and the use of them as a goal. The current analysis is limited to the following:
• Direct goals appearing in the body
• Arguments of declared meta-predicates that are marked with an integer (0..9).
See
meta predicate/1.
The analysis of meta-predicate arguments is limited to cases where the argument appears liter-
ally in the clause or is assigned using =/2 before the meta-call. That is, the following fragment
is processed correctly:
...,
Goal = prove(Theory),
forall(current_theory(Theory),
Goal)),
1This option is experimental and currently disabled by default. It will become the default if it proves robust.
SWI-Prolog 6.6 Reference Manual

324
CHAPTER 10. GENERATING RUNTIME APPLICATIONS
But, the calls to prove simple/1 and prove complex/1 in the example below are not
discovered by the analysis and therefore the modules that deﬁne these predicates must be loaded
explicitly using use module/1,2.
...,
member(Goal, [ prove_simple(Theory),
prove_complex(Theory)
]),
forall(current_theory(Theory),
Goal)),
It is good practice to use gxref/0 to make sure that the program has sufﬁcient declarations
such that the analaysis tools can verify that all required predicates can be resolved and that all
code is called. See meta predicate/1, dynamic/1, public/1 and prolog:called by/2.
volatile +Name/Arity, . . .
Declare that the clauses of speciﬁed predicates should not be saved to the program. The volatile
declaration is normally used to prevent the clauses of dynamic predicates that represent data
for the current session from being saved in the state ﬁle.
10.1
Limitations of qsave program
There are three areas that require special attention when using qsave program/[1,2].
• If the program is an embedded Prolog application or uses the foreign language interface, care
has to be taken to restore the appropriate foreign context. See section 10.2 for details.
• If the program uses directives (:- goal. lines) that perform other actions than setting predi-
cate attributes (dynamic, volatile, etc.) or loading ﬁles (consult, etc.), the directive may need to
be preﬁxed with initialization/1.
• Database references as returned by clause/3, recorded/3, etc., are not preserved and may
thus not be part of the database when saved.
10.2
Runtimes and Foreign Code
Some applications may need to use the foreign language interface. Object code is by deﬁnition
machine-dependent and thus cannot be part of the saved program ﬁle.
To complicate the matter even further there are various ways of loading foreign code:
• Using the library(shlib) predicates
This is the preferred way of dealing with foreign code. It loads quickly and ensures an accept-
able level of independence between the versions of the emulator and the foreign code loaded. It
works on Unix machines supporting shared libraries and library functions to load them. Most
modern Unixes, as well as Win32 (Windows 95/NT), satisfy this constraint.
SWI-Prolog 6.6 Reference Manual

10.3. USING PROGRAM RESOURCES
325
• Static linking
This mechanism works on all machines, but generally requires the same C compiler and linker
to be used for the external code as is used to build SWI-Prolog itself.
To make a runtime executable that can run on multiple platforms one must make runtime checks
to ﬁnd the correct way of linking. Suppose we have a source ﬁle myextension.c deﬁning the
installation function install().
If this ﬁle is compiled into a shared library, load foreign library/1 will load this library
and call the installation function to initialise the foreign code. If it is loaded as a static extension,
deﬁne install() as the predicate install/0:
static foreign_t
pl_install()
{ install();
PL_succeed;
}
PL_extension PL_extensions [] =
{
/*{ "name",
arity,
function,
PL_FA_<flags> },*/
{ "install",
0,
pl_install,
0 },
{ NULL,
0,
NULL,
0 } /* terminating line */
};
Now, use the following Prolog code to load the foreign library:
load_foreign_extensions :-
current_predicate(install, install), !, % static loaded
install.
load_foreign_extensions :-
% shared library
load_foreign_library(foreign(myextension)).
:- initialization load_foreign_extensions.
The path alias foreign is deﬁned by file search path/2. By default it searches the di-
rectories ⟨home⟩/lib/⟨arch⟩and ⟨home⟩/lib. The application can specify additional rules for
file search path/2.
10.3
Using program resources
A resource is very similar to a ﬁle. Resources, however, can be represented in two different formats:
on ﬁles, as well as part of the resource archive of a saved state (see qsave program/2).
A resource has a name and a class.
The source data of the resource is a ﬁle.
Resources
are declared by declaring the predicate resource/3.
They are accessed using the predicate
open resource/3.
SWI-Prolog 6.6 Reference Manual

326
CHAPTER 10. GENERATING RUNTIME APPLICATIONS
Before going into details, let us start with an example. Short texts can easily be expressed in Prolog
source code, but long texts are cumbersome. Assume our application deﬁnes a command ‘help’ that
prints a helptext to the screen. We put the content of the helptext into a ﬁle called help.txt. The
following code implements our help command such that help.txt is incorporated into the runtime
executable.
resource(help, text, ’help.txt’).
help :-
open_resource(help, text, In),
call_cleanup(copy_stream_data(In, user_output),
close(In)).
The predicate help/0 opens the resource as a Prolog stream. If we are executing this from the devel-
opment environment, this will actually return a stream to the ﬁle help.txt itself. When executed
from the saved state, the stream will actually be a stream opened on the program resource ﬁle, taking
care of the offset and length of the resource.
10.3.1
Resource manipulation predicates
resource(+Name, +Class, +FileSpec)
This predicate is deﬁned as a dynamic predicate in the module user. Clauses for it may be
deﬁned in any module, including the user module. Name is the name of the resource (an atom).
A resource name may contain any character, except for $ and :, which are reserved for internal
usage by the resource library. Class describes the kind of object stored in the resource. In
the current implementation, it is just an atom. FileSpec is a ﬁle speciﬁcation that may exploit
file search path/2 (see absolute file name/2).
Normally, resources are deﬁned as unit clauses (facts), but the deﬁnition of this predicate also
allows for rules. For proper generation of the saved state, it must be possible to enumerate the
available resources by calling this predicate with all its arguments unbound.
Dynamic rules are useful to turn all ﬁles in a certain directory into resources, without specifying
a resource for each ﬁle. For example, assume the file search path/2 icons refers to
the resource directory containing icon ﬁles. The following deﬁnition makes all these images
available as resources:
resource(Name, image, icons(XpmName)) :-
atom(Name), !,
file_name_extension(Name, xpm, XpmName).
resource(Name, image, XpmFile) :-
var(Name),
absolute_file_name(icons(.), [type(directory)], Dir)
concat(Dir, ’/*.xpm’, Pattern),
expand_file_name(Pattern, XpmFiles),
member(XpmFile, XpmFiles).
SWI-Prolog 6.6 Reference Manual

10.4. FINDING APPLICATION FILES
327
open resource(+Name, ?Class, -Stream)
Opens the resource speciﬁed by Name and Class. If the latter is a variable, it will be uniﬁed to
the class of the ﬁrst resource found that has the speciﬁed Name. If successful, Stream becomes
a handle to a binary input stream, providing access to the content of the resource.
The predicate open resource/3 ﬁrst checks resource/3. When successful it will open
the returned resource source ﬁle. Otherwise it will look in the program’s resource database.
When creating a saved state, the system normally saves the resource contents into the resource
archive, but does not save the resource clauses.
This way, the development environment uses the ﬁles (and modiﬁcations) to the resource/3
declarations and/or ﬁles containing resource info, thus immediately affecting the running envi-
ronment, while the runtime system quickly accesses the system resources.
10.3.2
The swipl-rc program
The utility program swipl-rc can be used to examine and manipulate the contents of a SWI-Prolog
resource ﬁle. The options are inspired by the Unix ar program. The basic command is:
% swipl-rc option resource-file member ...
The options are described below.
l
List contents of the archive.
x
Extract named (or all) members of the archive into the current directory.
a
Add ﬁles to the archive. If the archive already contains a member with the same name, the
contents are replaced. Anywhere in the sequence of members, the options --class=class
and --encoding=encoding may appear. They affect the class and encoding of subsequent
ﬁles. The initial class is data and encoding none.
d
Delete named members from the archive.
This command is also described in the pl(1) Unix manual page.
10.4
Finding Application ﬁles
If your application uses ﬁles that are not part of the saved program such as database ﬁles, conﬁguration
ﬁles, etc., the runtime version has to be able to locate these ﬁles. The file search path/2
mechanism in combination with the -palias command line argument is the preferred way to locate
runtime ﬁles. The ﬁrst step is to deﬁne an alias for the top-level directory of your application. We will
call this directory gnatdir in our examples.
A good place for storing data associated with SWI-Prolog runtime systems is below the emulator’s
home directory. swi is a predeﬁned alias for this directory. The following is a useful default deﬁnition
for the search path.
SWI-Prolog 6.6 Reference Manual

328
CHAPTER 10. GENERATING RUNTIME APPLICATIONS
user:file_search_path(gnatdir, swi(gnat)).
The application should locate all ﬁles using absolute ﬁle name. Suppose gnatdir contains a ﬁle
config.pl to deﬁne the local conﬁguration. Then use the code below to load this ﬁle:
configure_gnat :-
(
absolute_file_name(gnatdir(’config.pl’), ConfigFile)
->
consult(ConfigFile)
;
format(user_error, ’gnat: Cannot locate config.pl˜n’),
halt(1)
).
10.4.1
Specifying a ﬁle search path from the command line
Suppose the system administrator has installed the SWI-Prolog runtime environment in /usr/
local/lib/rt-pl-3.2.0. A user wants to install gnat, but gnat will look for its conﬁgu-
ration in /usr/local/lib/rt-pl-3.2.0/gnat where the user cannot write.
The user decides to install the gnat runtime ﬁles in /users/bob/lib/gnat. For one-time
usage, the user may decide to start gnat using the command:
% gnat -p gnatdir=/users/bob/lib/gnat
SWI-Prolog 6.6 Reference Manual

The SWI-Prolog library
A
This chapter documents the SWI-Prolog library. As SWI-Prolog provides auto-loading, there is little
difference between library predicates and built-in predicates. Part of the library is therefore docu-
mented in the rest of the manual. Library predicates differ from built-in predicates in the following
ways:
• User deﬁnition of a built-in leads to a permission error, while using the name of a library pred-
icate is allowed.
• If autoloading is disabled explicitly or because trapping unknown predicates is disabled (see
unknown/2 and current prolog flag/2), library predicates must be loaded explicitly.
• Using libraries reduces the footprint of applications that don’t need them.
The documentation of the library has just started. Material from the standard packages
should be moved here, some material from other parts of the manual should be moved
too and various libraries are not documented at all.
A.1
library(aggregate): Aggregation operators on backtrackable pred-
icates
Compatibility Quintus, SICStus 4. The forall/2 is a SWI-Prolog built-in and term variables/3
is a SWI-Prolog with a different deﬁnition.
To be done
- Analysing the aggregation template and compiling a predicate for the list aggregation can be done at
compile time.
- aggregate all/3 can be rewritten to run in constant space using non-backtrackable assignment
on a term.
This library provides aggregating operators over the solutions of a predicate. The operations
are a generalisation of the bagof/3, setof/3 and findall/3 built-in predicates. The deﬁned
aggregation operations are counting, computing the sum, minimum, maximum, a bag of solutions and
a set of solutions. We ﬁrst give a simple example, computing the country with the smallest area:
smallest_country(Name, Area) :-
aggregate(min(A, N), country(N, A), min(Area, Name)).
There are four aggregation predicates (aggregate/3, aggregate/4, aggregate all/3
and aggregate/4), distinguished on two properties.
SWI-Prolog 6.6 Reference Manual

330
APPENDIX A. THE SWI-PROLOG LIBRARY
aggregate vs. aggregate all The
aggregate
predicates
use
setof/3
(aggregate/4)
or
bagof/3 (aggregate/3), dealing with existential qualiﬁed variables (VarˆGoal) and pro-
viding multiple solutions for the remaining free variables in Goal. The aggregate all/3
predicate uses findall/3, implicitly qualifying all free variables and providing exactly one
solution, while aggregate all/4 uses sort/2 over solutions that Discriminator (see be-
low) generated using findall/3.
The Discriminator argument The versions with 4 arguments provide a Discriminator argument that
allows for keeping duplicate bindings of a variable in the result. For example, if we wish
to compute the total population of all countries, we do not want to lose results because two
countries have the same population. Therefore we use:
aggregate(sum(P), Name, country(Name, P), Total)
All aggregation predicates support the following operators below in Template. In addition, they
allow for an arbitrary named compound term, where each of the arguments is a term from the list
below. For example, the term r(min(X), max(X)) computes both the minimum and maximum
binding for X.
count
Count number of solutions. Same as sum(1).
sum(Expr)
Sum of Expr for all solutions.
min(Expr)
Minimum of Expr for all solutions.
min(Expr, Witness)
A term min(Min, Witness), where Min is the minimal version of Expr over all solutions,
and Witness is any other template applied to solutions that produced Min. If multiple solutions
provide the same minimum, Witness corresponds to the ﬁrst solution.
max(Expr)
Maximum of Expr for all solutions.
max(Expr, Witness)
As min(Expr, Witness), but producing the maximum result.
set(X)
An ordered set with all solutions for X.
bag(X)
A list of all solutions for X.
Acknowledgements
The
development
of
this
library
was
sponsored
by
SecuritEase,
http://www.securitease.com
SWI-Prolog 6.6 Reference Manual

A.1. LIBRARY(AGGREGATE): AGGREGATION OPERATORS ON BACKTRACKABLE
PREDICATES
331
aggregate(+Template, :Goal, -Result)
[nondet]
Aggregate bindings in Goal according to Template. The aggregate/3 version performs
bagof/3 on Goal.
aggregate(+Template, +Discriminator, :Goal, -Result)
[nondet]
Aggregate bindings in Goal according to Template. The aggregate/4 version performs
setof/3 on Goal.
aggregate all(+Template, :Goal, -Result)
[semidet]
Aggregate bindings in Goal according to Template. The aggregate all/3 version performs
findall/3 on Goal.
aggregate all(+Template, +Discriminator, :Goal, -Result)
[semidet]
Aggregate bindings in Goal according to Template. The aggregate all/4 version performs
findall/3 followed by sort/2 on Goal.
foreach(:Generator, :Goal)
True if conjunction of results is true. Unlike forall/2, which runs a failure-driven loop that
proves Goal for each solution of Generator, foreach/2 creates a conjunction. Each member
of the conjunction is a copy of Goal, where the variables it shares with Generator are ﬁlled
with the values from the corresponding solution.
The implementation executes forall/2 if Goal does not contain any variables that are not
shared with Generator.
Here is an example:
?- foreach(between(1,4,X), dif(X,Y)), Y = 5.
Y = 5.
?- foreach(between(1,4,X), dif(X,Y)), Y = 3.
false.
bug Goal is copied repeatedly, which may cause problems if attributed variables are involved.
free variables(:Generator, +Template, +VarList0, -VarList)
[det]
Find free variables in bagof/setof template. In order to handle variables properly, we have to
ﬁnd all the universally quantiﬁed variables in the Generator. All variables as yet unbound are
universally quantiﬁed, unless
1. they occur in the template
2. they are bound by XˆP, setof/3, or bagof/3
free_variables(Generator, Template, OldList, NewList) ﬁnds this set
using OldList as an accumulator.
author
- Richard O’Keefe
- Jan Wielemaker (made some SWI-Prolog enhancements)
license Public domain (from DEC10 library).
SWI-Prolog 6.6 Reference Manual

332
APPENDIX A. THE SWI-PROLOG LIBRARY
To be done
- Distinguish between control-structures and data terms.
- Exploit our built-in term variables/2 at some places?
sandbox:safe meta(+Goal, -Called)
[semidet,multiﬁle]
Declare the aggregate meta-calls safe. This cannot be proven due to the manipulations of the
argument Goal.
A.2
library(apply): Apply predicates on a list
See also
- apply_macros.pl provides compile-time expansion for part of this library.
- http://www.cs.otago.ac.nz/staffpriv/ok/pllib.htm
To be done Add include/4, include/5, exclude/4, exclude/5
This module deﬁnes meta-predicates that apply a predicate on all members of a list.
include(:Goal, +List1, ?List2)
[det]
Filter elements for which Goal succeeds. True if List2 contains those elements Xi of List1 for
which call(Goal, Xi) succeeds.
See also Older versions of SWI-Prolog had sublist/3 with the same arguments and semantics.
exclude(:Goal, +List1, ?List2)
[det]
Filter elements for which Goal fails. True if List2 contains those elements Xi of List1 for which
call(Goal, Xi) fails.
partition(:Pred, +List, ?Included, ?Excluded)
[det]
Filter elements of List according to Pred. True if Included contains all elements for which
call(Pred, X) succeeds and Excluded contains the remaining elements.
partition(:Pred, +List, ?Less, ?Equal, ?Greater)
[semidet]
Filter List according to Pred in three sets. For each element Xi of List, its destination is de-
termined by call(Pred, Xi, Place), where Place must be uniﬁed to one of <, = or >.
Pred must be deterministic.
maplist(:Goal, ?List)
True if Goal can successfully be applied on all elements of List. Arguments are reordered to
gain performance as well as to make the predicate deterministic under normal circumstances.
maplist(:Goal, ?List1, ?List2)
As maplist/2, operating on pairs of elements from two lists.
maplist(:Goal, ?List1, ?List2, ?List3)
As maplist/2, operating on triples of elements from three lists.
maplist(:Goal, ?List1, ?List2, ?List3, ?List4)
As maplist/2, operating on quadruples of elements from four lists.
SWI-Prolog 6.6 Reference Manual

A.3. LIBRARY(ASSOC): ASSOCIATION LISTS
333
foldl(:Goal, +List, +V0, -V)
foldl(:Goal, +List1, +List2, +V0, -V)
foldl(:Goal, +List1, +List2, +List3, +V0, -V)
foldl(:Goal, +List1, +List2, +List3, +List4, +V0, -V)
Fold a list, using arguments of the list as left argument. The foldl family of predicates is deﬁned
by:
foldl(P, [X11,...,X1n], ..., [Xm1,...,Xmn], V0, Vn) :-
P(X11, ..., Xm1, V0, V1),
...
P(X1n, ..., Xmn, V’, Vn).
scanl(:Goal, +List, +V0, -Values)
scanl(:Goal, +List1, +List2, +V0, -Values)
scanl(:Goal, +List1, +List2, +List3, +V0, -Values)
scanl(:Goal, +List1, +List2, +List3, +List4, +V0, -Values)
Left scan of list. The scanl family of higher order list operations is deﬁned by:
scanl(P, [X11,...,X1n], ..., [Xm1,...,Xmn], V0,
[V0,V1,...,Vn]) :-
P(X11, ..., Xmn, V0, V1),
...
P(X1n, ..., Xmn, V’, Vn).
A.3
library(assoc): Association lists
Authors: Richard A. O’Keefe, L.Damas, V.S.Costa and Markus Triska
Elements of an association list have 2 components: A (unique) key and a value. Keys should be
ground, values need not be. An association list can be used to fetch elements via their keys and to
enumerate its elements in ascending order of their keys. The assoc module uses AVL trees to im-
plement association lists. This makes inserting, changing and fetching a single element an O(log(N))
(where N denotes the number of elements in the list) expected time (and worst-case time) operation.
assoc to list(+Assoc, -List)
List is a list of Key-Value pairs corresponding to the associations in Assoc in ascending order
of keys.
assoc to keys(+Assoc, -List)
List is a list of Keys corresponding to the associations in Assoc in ascending order.
assoc to values(+Assoc, -List)
List is a list of Values corresponding to the associations in Assoc in ascending order of the keys
they are associated to.
empty assoc(-Assoc)
Assoc is uniﬁed with an empty association list.
SWI-Prolog 6.6 Reference Manual

334
APPENDIX A. THE SWI-PROLOG LIBRARY
gen assoc(?Key, +Assoc, ?Value)
Enumerate matching elements of Assoc in ascending order of their keys via backtracking.
get assoc(+Key, +Assoc, ?Value)
Value is the value associated with Key in the association list Assoc.
get assoc(+Key, +Assoc, ?Old, ?NewAssoc, ?New)
NewAssoc is an association list identical to Assoc except that the value associated with Key is
New instead of Old.
list to assoc(+List, -Assoc)
Assoc is an association list corresponding to the Key-Value pairs in List. List must not contain
duplicate keys.
map assoc(:Goal, +Assoc)
Goal(V) is true for every value V in Assoc.
map assoc(:Goal, +AssocIn, ?AssocOut)
AssocOut is AssocIn with Goal applied to all corresponding pairs of values.
max assoc(+Assoc, ?Key, ?Value)
Key and Value are key and value of the element with the largest key in Assoc.
min assoc(+Assoc, ?Key, ?Value)
Key and Value are key and value of the element with the smallest key in Assoc.
ord list to assoc(+List, -Assoc)
Assoc is an association list correspond to the Key-Value pairs in List, which must occur in
strictly ascending order of their keys.
put assoc(+Key, +Assoc, +Value, ?NewAssoc)
NewAssoc is an association list identical to Assoc except that Key is associated with Value. This
can be used to insert and change associations.
is assoc(+Assoc)
True if Assoc is a valid association list. This predicate veriﬁes the validity of each node in the
AVL tree.
A.4
library(broadcast): Broadcast and receive event notiﬁcations
The broadcast library was invented to realise GUI applications consisting of stand-alone compo-
nents that use the Prolog database for storing the application data. Figure A.1 illustrates the ﬂow of
information using this design
The broadcasting service provides two services. Using the ‘shout’ service, an unknown number of
agents may listen to the message and act. The broadcaster is not (directly) aware of the implications.
Using the ‘request’ service, listening agents are asked for an answer one-by-one and the broadcaster
is allowed to reject answers using normal Prolog failure.
Shouting is often used to inform about changes made to a common database. Other messages can
be “save yourself” or “show this”.
Requesting is used to get information while the broadcaster is not aware who might be able to
answer the question. For example “who is showing X?”.
SWI-Prolog 6.6 Reference Manual

A.4. LIBRARY(BROADCAST): BROADCAST AND RECEIVE EVENT NOTIFICATIONS335
Interface
component
Database
manipulation
Prolog database
Broadcast
‘Ether’
Interface
component
listen
broadcast
assert/retract
Querying
Changed-messages
Figure A.1: Information-ﬂow using broadcasting service
broadcast(+Term)
Broadcast Term. There are no limitations to Term, though being a global service, it is good
practice to use a descriptive and unique principal functor. All associated goals are started and
regardless of their success or failure, broadcast/1 always succeeds. Exceptions are passed.
broadcast request(+Term)
Unlike broadcast/1, this predicate stops if an associated goal succeeds.
Backtracking
causes it to try other listeners.
A broadcast request is used to fetch information without
knowing the identity of the agent providing it. C.f. “Is there someone who knows the age of
John?” could be asked using
...,
broadcast_request(age_of(’John’, Age)),
If there is an agent (listener) that registered an ‘age-of’ service and knows about the age of
‘John’ this question will be answered.
listen(+Template, :Goal)
Register a listen channel. Whenever a term unifying Template is broadcasted, call Goal. The
following example traps all broadcasted messages as a variable uniﬁes to any message. It is
commonly used to debug usage of the library.
?- listen(Term, (writeln(Term),fail)).
?- broadcast(hello(world)).
hello(world)
true.
listen(+Listener, +Template, :Goal)
Declare Listener as the owner of the channel. Unlike a channel opened using listen/2,
SWI-Prolog 6.6 Reference Manual

336
APPENDIX A. THE SWI-PROLOG LIBRARY
channels that have an owner can terminate the channel. This is commonly used if an object is
listening to broadcast messages. In the example below we deﬁne a ‘name-item’ displaying the
name of an identiﬁer represented by the predicate name of/2.
:- pce_begin_class(name_item, text_item).
variable(id,
any,
get, "Id visualised").
initialise(NI, Id:any) :->
name_of(Id, Name),
send_super(NI, initialise, name, Name,
message(NI, set_name, @arg1)),
send(NI, slot, id, Id),
listen(NI, name_of(Id, Name),
send(NI, selection, Name)).
unlink(NI) :->
unlisten(NI),
send_super(NI, unlink).
set_name(NI, Name:name) :->
get(NI, id, Id),
retractall(name_of(Id, _)),
assert(name_of(Id, Name)),
broadcast(name_of(Id, Name)).
:- pce_end_class.
unlisten(+Listener)
Deregister all entries created with listen/3 whose Listener unify.
unlisten(+Listener, +Template)
Deregister all entries created with listen/3 whose Listener and Template unify.
unlisten(+Listener, +Template, :Goal)
Deregister all entries created with listen/3 whose Listener, Template and Goal unify.
listening(?Listener, ?Template, ?Goal)
Examine the current listeners. This predicate is useful for debugging purposes.
A.5
library(charsio): I/O on Lists of Character Codes
Compatibility The naming of this library is not in line with the ISO standard. We believe that the SWI-
Prolog native predicates form a more elegant alternative for this library.
This module emulates the Quintus/SICStus library charsio.pl for reading and writing from/to
lists of character codes. Most of these predicates are straight calls into similar SWI-Prolog primitives.
Some can even be replaced by ISO standard predicates.
SWI-Prolog 6.6 Reference Manual

A.5. LIBRARY(CHARSIO): I/O ON LISTS OF CHARACTER CODES
337
format to chars(+Format, +Args, -Codes)
[det]
Use format/2 to write to a list of character codes.
format to chars(+Format, +Args, -Codes, ?Tail)
[det]
Use format/2 to write to a difference list of character codes.
write to chars(+Term, -Codes)
Write a term to a code list. True when Codes is a list of character codes written by write/1
on Term.
write to chars(+Term, -Codes, ?Tail)
Write a term to a code list. Codes\Tail is a difference list of character codes produced by
write/1 on Term.
atom to chars(+Atom, -Codes)
[det]
Convert Atom into a list of character codes.
deprecated Use ISO atom codes/2.
atom to chars(+Atom, -Codes, ?Tail)
[det]
Convert Atom into a difference list of character codes.
number to chars(+Number, -Codes)
[det]
Convert Atom into a list of character codes.
deprecated Use ISO number codes/2.
number to chars(+Number, -Codes, ?Tail)
[det]
Convert Number into a difference list of character codes.
read from chars(+Codes, -Term)
[det]
Read Codes into Term.
Compatibility The SWI-Prolog version does not require Codes to end in a full-stop.
read term from chars(+Codes, -Term, +Options)
[det]
Read Codes into Term. Options are processed by read term/3.
Compatibility sicstus
open chars stream(+Codes, -Stream)
[det]
Open Codes as an input stream.
bug Depends on autoloading library(memfile). As many applications do not need this predi-
cate we do not want to make the entire library dependent on autoloading.
with output to chars(:Goal, -Codes)
[det]
Run Goal as with once/1. Output written to current_output is collected in Codes.
with output to chars(:Goal, -Codes, ?Tail)
[det]
Run Goal as with once/1. Output written to current_output is collected in Codes\Tail.
with output to chars(:Goal, -Stream, -Codes, ?Tail)
[det]
Same as with output to chars/3 using an explicit stream.
The difference list
Codes\Tail contains the character codes that Goal has written to Stream.
SWI-Prolog 6.6 Reference Manual

338
APPENDIX A. THE SWI-PROLOG LIBRARY
A.6
library(check): Elementary completeness checks
This library deﬁnes the predicate check/0 and a few friends that allow for a quick-and-dirty cross-
referencing.
check
Performs
the
three
checking
passes
implemented
by
list undefined/0,
list autoload/0 and list redefined/0.
Please check the deﬁnition of these
predicates for details.
The typical usage of this predicate is right after loading your program to get a quick overview
on the completeness and possible conﬂicts in your program.
list undeﬁned
Scans the database for predicates that have no deﬁnition. A predicate is considered deﬁned if it
has clauses or is declared using dynamic/1 or multifile/1. As a program is compiled,
calls are translated to predicates. If the called predicate is not yet deﬁned it is created as a
predicate without deﬁnition. The same happens with runtime generated calls. This predicate
lists all such undeﬁned predicates that are referenced and not deﬁned in the library. See also
list autoload/0. Below is an example from a real program and an illustration of how to
edit the referencing predicate using edit/1.
?- list_undefined.
Warning: The predicates below are not defined. If these are
Warning: defined at runtime using assert/1, use
Warning: :- dynamic Name/Arity.
Warning:
Warning: rdf_edit:rdfe_retract/4, which is referenced by
Warning:
1-st clause of rdf_edit:undo/4
Warning: rdf_edit:rdfe_retract/3, which is referenced by
Warning:
1-st clause of rdf_edit:delete_object/1
Warning:
1-st clause of rdf_edit:delete_subject/1
Warning:
1-st clause of rdf_edit:delete_predicate/1
?- edit(rdf_edit:undo/4).
list autoload
Lists all undeﬁned (see list undefined/0) predicates that have a deﬁnition in the library
along with the ﬁle from which they will be autoloaded when accessed. See also autoload/0.
list redeﬁned
Lists predicates that are deﬁned in the global module user as well as in a normal module; that
is, predicates for which the local deﬁnition overrules the global default deﬁnition.
A.7
library(clpfd): Constraint Logic Programming over Finite Do-
mains
author Markus Triska
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
339
Introduction
Constraint programming is a declarative formalism that lets you describe conditions a solution must
satisfy. This library provides CLP(FD), Constraint Logic Programming over Finite Domains. It can be
used to model and solve various combinatorial problems such as planning, scheduling and allocation
tasks.
Most predicates of this library are ﬁnite domain constraints, which are relations over integers.
They generalise arithmetic evaluation of integer expressions in that propagation can proceed in all
directions. This library also provides enumeration predicates, which let you systematically search for
solutions on variables whose domains have become ﬁnite.
You can cite this library in your publications as:
@inproceedings{Triska12,
author
= {Markus Triska},
title
= {The Finite Domain Constraint Solver of {SWI-Prolog}},
booktitle = {FLOPS},
series
= {LNCS},
volume
= {7294},
year
= {2012},
pages
= {307-316}
}
Arithmetic constraints
A ﬁnite domain arithmetic expression is one of:
integer
Given value
variable
Unknown integer
?(variable)
Unknown integer
-Expr
Unary minus
Expr + Expr
Addition
Expr * Expr
Multiplication
Expr - Expr
Subtraction
Expr ˆ Expr
Exponentiation
min(Expr,Expr)
Minimum of two expressions
max(Expr,Expr)
Maximum of two expressions
Expr mod Expr
Modulo induced by ﬂoored division
Expr rem Expr
Modulo induced by truncated division
abs(Expr)
Absolute value
Expr / Expr
Truncated integer division
Arithmetic constraints are relations between arithmetic expressions.
The most important arithmetic constraints are:
SWI-Prolog 6.6 Reference Manual

340
APPENDIX A. THE SWI-PROLOG LIBRARY
Expr1 #>= Expr2
Expr1 is greater than or equal to Expr2
Expr1 #=< Expr2
Expr1 is less than or equal to Expr2
Expr1 #= Expr2
Expr1 equals Expr2
Expr1 #\= Expr2
Expr1 is not equal to Expr2
Expr1 #> Expr2
Expr1 is greater than Expr2
Expr1 #< Expr2
Expr1 is less than Expr2
Reiﬁcation
The constraints in/2, #=/2, #\=/2, #</2, #>/2, #=</2, and #>=/2 can be reiﬁed, which
means reﬂecting their truth values into Boolean values represented by the integers 0 and 1. Let P and
Q denote reiﬁable constraints or Boolean variables, then:
#\ Q
True iff Q is false
P #\/ Q
True iff either P or Q
P #/\ Q
True iff both P and Q
P #<==> Q
True iff P and Q are equivalent
P #==> Q
True iff P implies Q
P #<== Q
True iff Q implies P
The constraints of this table are reiﬁable as well.
Examples
Here is an example session with a few queries and their answers:
?- use_module(library(clpfd)).
% library(clpfd) compiled into clpfd 0.06 sec, 633,732 bytes
true.
?- X #> 3.
X in 4..sup.
?- X #\= 20.
X in inf..19\/21..sup.
?- 2*X #= 10.
X = 5.
?- X*X #= 144.
X in -12\/12.
?- 4*X + 2*Y #= 24, X + Y #= 9, [X,Y] ins 0..sup.
X = 3,
Y = 6.
?- Vs = [X,Y,Z], Vs ins 1..3, all_different(Vs), X = 1, Y #\= 2.
Vs = [1, 3, 2],
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
341
X = 1,
Y = 3,
Z = 2.
?- X #= Y #<==> B, X in 0..3, Y in 4..5.
B = 0,
X in 0..3,
Y in 4..5.
In each case, and as for all pure programs, the answer is declaratively equivalent to the original
query, and in many cases the constraint solver has deduced additional domain restrictions.
Search
A common usage of this library is to ﬁrst post the desired constraints among the variables of a model,
and then to use enumeration predicates to search for solutions. As an example of a constraint satis-
faction problem, consider the cryptoarithmetic puzzle SEND + MORE = MONEY, where different
letters denote distinct integers between 0 and 9. It can be modeled in CLP(FD) as follows:
:- use_module(library(clpfd)).
puzzle([S,E,N,D] + [M,O,R,E] = [M,O,N,E,Y]) :-
Vars = [S,E,N,D,M,O,R,Y],
Vars ins 0..9,
all_different(Vars),
S*1000 + E*100 + N*10 + D +
M*1000 + O*100 + R*10 + E #=
M*10000 + O*1000 + N*100 + E*10 + Y,
M #\= 0, S #\= 0.
Sample query and its result (actual variables replaced for readability):
?- puzzle(As+Bs=Cs).
As = [9, _A2, _A3, _A4],
Bs = [1, 0, _B3, _A2],
Cs = [1, 0, _A3, _A2, _C5],
_A2 in 4..7,
all_different([9, _A2, _A3, _A4, 1, 0, _B3, _C5]),
1000*9+91*_A2+ -90*_A3+_A4+ -9000*1+ -900*0+10*_B3+ -1*_C5#=0,
_A3 in 5..8,
_A4 in 2..8,
_B3 in 2..8,
_C5 in 2..8.
Here, the constraint solver has deduced more stringent bounds for all variables. It is good practice
to keep the modeling part separate from the actual search. This lets you observe termination and
SWI-Prolog 6.6 Reference Manual

342
APPENDIX A. THE SWI-PROLOG LIBRARY
determinism properties of the modeling part in isolation from the search. Labeling can then be used
to search for solutions in a separate predicate or goal:
?- puzzle(As+Bs=Cs), label(As).
As = [9, 5, 6, 7],
Bs = [1, 0, 8, 5],
Cs = [1, 0, 6, 5, 2] ;
false.
In this case, it sufﬁces to label a subset of variables to ﬁnd the puzzle’s unique solution, since the
constraint solver is strong enough to reduce the domains of remaining variables to singleton sets. In
general though, it is necessary to label all variables to obtain ground solutions.
Declarative integer arithmetic
You can also use CLP(FD) constraints as a more declarative alternative for ordinary integer arithmetic
with is/2, >/2 etc. For example:
:- use_module(library(clpfd)).
n_factorial(0, 1).
n_factorial(N, F) :-
N #> 0, N1 #= N - 1, F #= N * F1,
n_factorial(N1, F1).
This predicate can be used in all directions. For example:
?- n_factorial(47, F).
F = 258623241511168180642964355153611979969197632389120000000000 ;
false.
?- n_factorial(N, 1).
N = 0 ;
N = 1 ;
false.
?- n_factorial(N, 3).
false.
To make the predicate terminate if any argument is instantiated, add the (implied) constraint F #\=
0 before the recursive call. Otherwise, the query n_factorial(N, 0) is the only non-terminating
case of this kind.
Advanced topics
This library uses goal expansion/2 to rewrite constraints at compilation time. The expansion’s
aim is to transparently bring the performance of CLP(FD) constraints close to that of conventional
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
343
arithmetic predicates (</2, =:=/2, is/2 etc.) when the constraints are used in modes that can also
be handled by built-in arithmetic. To disable the expansion, set the ﬂag clpfd_goal_expansion
to false.
If you set the ﬂag clpfd_monotonic to true, then CLP(FD) is monotonic: Adding new
constraints cannot yield new solutions. When this ﬂag is true, you must wrap variables that occur
in arithmetic expressions with the functor (?)/1. For example, ?(X) #= ?(Y) + ?(Z). The
wrapper can be omitted for variables that are already constrained to integers.
Use call residue vars/2 and copy term/3 to inspect residual goals and the constraints
in which a variable is involved. This library also provides reﬂection predicates (like fd dom/2,
fd size/2 etc.) with which you can inspect a variable’s current domain. These predicates can be
useful if you want to implement your own labeling strategies.
You can also deﬁne custom constraints. The mechanism to do this is not yet ﬁnalised, and we
welcome suggestions and descriptions of use cases that are important to you. As an example of how
it can be done currently, let us deﬁne a new custom constraint oneground(X,Y,Z), where Z shall
be 1 if at least one of X and Y is instantiated:
:- use_module(library(clpfd)).
:- multifile clpfd:run_propagator/2.
oneground(X, Y, Z) :-
clpfd:make_propagator(oneground(X, Y, Z), Prop),
clpfd:init_propagator(X, Prop),
clpfd:init_propagator(Y, Prop),
clpfd:trigger_once(Prop).
clpfd:run_propagator(oneground(X, Y, Z), MState) :-
(
integer(X) -> clpfd:kill(MState), Z = 1
;
integer(Y) -> clpfd:kill(MState), Z = 1
;
true
).
First, clpfd:make propagator/2 is used to transform a user-deﬁned representation of the
new constraint to an internal form.
With clpfd:init propagator/2, this internal form is
then attached to X and Y. From now on, the propagator will be invoked whenever the domains
of X or Y are changed.
Then, clpfd:trigger once/1 is used to give the propagator its
ﬁrst chance for propagation even though the variables’ domains have not yet changed.
Finally,
clpfd:run propagator/2 is extended to deﬁne the actual propagator. As explained, this pred-
icate is automatically called by the constraint solver. The ﬁrst argument is the user-deﬁned represen-
tation of the constraint as used in clpfd:make propagator/2, and the second argument is a
mutable state that can be used to prevent further invocations of the propagator when the constraint has
become entailed, by using clpfd:kill/1. An example of using the new constraint:
?- oneground(X, Y, Z), Y = 5.
Y = 5,
Z = 1,
X in inf..sup.
SWI-Prolog 6.6 Reference Manual

344
APPENDIX A. THE SWI-PROLOG LIBRARY
?Var in +Domain
Var is an element of Domain. Domain is one of:
Integer
Singleton set consisting only of Integer.
Lower .. Upper
All integers I such that Lower =< I =< Upper. Lower must be an integer or the atom inf,
which denotes negative inﬁnity. Upper must be an integer or the atom sup, which denotes
positive inﬁnity.
Domain1 \/ Domain2
The union of Domain1 and Domain2.
+Vars ins +Domain
The variables in the list Vars are elements of Domain.
indomain(?Var)
Bind Var to all feasible values of its domain on backtracking. The domain of Var must be ﬁnite.
label(+Vars)
Equivalent to labeling([], Vars).
labeling(+Options, +Vars)
Assign a value to each variable in Vars. Labeling means systematically trying out values for
the ﬁnite domain variables Vars until all of them are ground. The domain of each variable in
Vars must be ﬁnite. Options is a list of options that let you exhibit some control over the search
process. Several categories of options exist:
The variable selection strategy lets you specify which variable of Vars is labeled next and is one
of:
leftmost
Label the variables in the order they occur in Vars. This is the default.
ff
First fail. Label the leftmost variable with smallest domain next, in order to detect infea-
sibility early. This is often a good strategy.
ffc
Of the variables with smallest domains, the leftmost one participating in most constraints
is labeled next.
min
Label the leftmost variable whose lower bound is the lowest next.
max
Label the leftmost variable whose upper bound is the highest next.
The value order is one of:
up
Try the elements of the chosen variable’s domain in ascending order. This is the default.
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
345
down
Try the domain elements in descending order.
The branching strategy is one of:
step
For each variable X, a choice is made between X = V and X #\= V, where V is determined
by the value ordering options. This is the default.
enum
For each variable X, a choice is made between X = V 1, X = V 2 etc., for all values V i
of the domain of X. The order is determined by the value ordering options.
bisect
For each variable X, a choice is made between X #=< M and X #> M, where M is the
midpoint of the domain of X.
At most one option of each category can be speciﬁed, and an option must not occur repeatedly.
The order of solutions can be inﬂuenced with:
• min(Expr)
• max(Expr)
This generates solutions in ascending/descending order with respect to the evaluation of the
arithmetic expression Expr. Labeling Vars must make Expr ground. If several such options are
speciﬁed, they are interpreted from left to right, e.g.:
?- [X,Y] ins 10..20, labeling([max(X),min(Y)],[X,Y]).
This generates solutions in descending order of X, and for each binding of X, solutions are
generated in ascending order of Y. To obtain the incomplete behaviour that other systems exhibit
with ”maximize(Expr)” and ”minimize(Expr)”, use once/1, e.g.:
once(labeling([max(Expr)], Vars))
Labeling is always complete, always terminates, and yields no redundant solutions.
all different(+Vars)
Vars are pairwise distinct.
all distinct(+Ls)
Like all different/1, with stronger propagation. For example, all distinct/1 can
detect that not all variables can assume distinct values given the following domains:
?- maplist(in, Vs,
[1\/3..4, 1..2\/4, 1..2\/4, 1..3, 1..3, 1..6]),
all_distinct(Vs).
false.
SWI-Prolog 6.6 Reference Manual

346
APPENDIX A. THE SWI-PROLOG LIBRARY
sum(+Vars, +Rel, ?Expr)
The sum of elements of the list Vars is in relation Rel to Expr. Rel is one of #=, #\=, #<, #>,
#=< or #>=. For example:
?- [A,B,C] ins 0..sup, sum([A,B,C], #=, 100).
A in 0..100,
A+B+C#=100,
B in 0..100,
C in 0..100.
scalar product(+Cs, +Vs, +Rel, ?Expr)
Cs is a list of integers, Vs is a list of variables and integers. True if the scalar product of Cs and
Vs is in relation Rel to Expr, where Rel is #=, #\=, #<, #>, #=< or #>=.
?X #>= ?Y
X is greater than or equal to Y.
?X #=< ?Y
X is less than or equal to Y.
?X #= ?Y
X equals Y.
?X #\= ?Y
X is not Y.
?X #> ?Y
X is greater than Y.
?X #< ?Y
X is less than Y. In addition to its regular use in problems that require it, this constraint can
also be useful to eliminate uninteresting symmetries from a problem. For example, all possible
matches between pairs built from four players in total:
?- Vs = [A,B,C,D], Vs ins 1..4,
all_different(Vs),
A #< B, C #< D, A #< C,
findall(pair(A,B)-pair(C,D), label(Vs), Ms).
Ms = [ pair(1, 2)-pair(3, 4),
pair(1, 3)-pair(2, 4),
pair(1, 4)-pair(2, 3)].
#\ +Q
The reiﬁable constraint Q does not hold. For example, to obtain the complement of a domain:
?- #\ X in -3..0\/10..80.
X in inf.. -4\/1..9\/81..sup.
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
347
?P #<==> ?Q
P and Q are equivalent. For example:
?- X #= 4 #<==> B, X #\= 4.
B = 0,
X in inf..3\/5..sup.
The following example uses reiﬁed constraints to relate a list of ﬁnite domain variables to the
number of occurrences of a given value:
:- use_module(library(clpfd)).
vs_n_num(Vs, N, Num) :-
maplist(eq_b(N), Vs, Bs),
sum(Bs, #=, Num).
eq_b(X, Y, B) :- X #= Y #<==> B.
Sample queries and their results:
?- Vs = [X,Y,Z], Vs ins 0..1, vs_n_num(Vs, 4, Num).
Vs = [X, Y, Z],
Num = 0,
X in 0..1,
Y in 0..1,
Z in 0..1.
?- vs_n_num([X,Y,Z], 2, 3).
X = 2,
Y = 2,
Z = 2.
?P #==> ?Q
P implies Q.
?P #<== ?Q
Q implies P.
?P #/\ ?Q
P and Q hold.
?P #\/ ?Q
P or Q holds. For example, the sum of natural numbers below 1000 that are multiples of 3 or 5:
?- findall(N, (N mod 3 #= 0 #\/ N mod 5 #= 0, N in 0..999,
indomain(N)),
Ns),
SWI-Prolog 6.6 Reference Manual

348
APPENDIX A. THE SWI-PROLOG LIBRARY
sum(Ns, #=, Sum).
Ns = [0, 3, 5, 6, 9, 10, 12, 15, 18|...],
Sum = 233168.
lex chain(+Lists)
Lists are lexicographically non-decreasing.
tuples in(+Tuples, +Relation)
Relation must be a list of lists of integers. The elements of the list Tuples are constrained to be
elements of Relation. Arbitrary ﬁnite relations, such as compatibility tables, can be modeled in
this way. For example, if 1 is compatible with 2 and 5, and 4 is compatible with 0 and 3:
?- tuples_in([[X,Y]], [[1,2],[1,5],[4,0],[4,3]]), X = 4.
X = 4,
Y in 0\/3.
As another example, consider a train schedule represented as a list of quadruples, denoting
departure and arrival places and times for each train. In the following program, Ps is a feasible
journey of length 3 from A to D via trains that are part of the given schedule.
:- use_module(library(clpfd)).
trains([[1,2,0,1],
[2,3,4,5],
[2,3,0,1],
[3,4,5,6],
[3,4,2,3],
[3,4,8,9]]).
threepath(A, D, Ps) :-
Ps = [[A,B,_T0,T1],[B,C,T2,T3],[C,D,T4,_T5]],
T2 #> T1,
T4 #> T3,
trains(Ts),
tuples_in(Ps, Ts).
In this example, the unique solution is found without labeling:
?- threepath(1, 4, Ps).
Ps = [[1, 2, 0, 1], [2, 3, 4, 5], [3, 4, 8, 9]].
serialized(+Starts, +Durations)
Describes a set of non-overlapping tasks. Starts = [S 1,...,S n], is a list of variables or integers,
Durations = [D 1,...,D n] is a list of non-negative integers. Constrains Starts and Durations to
denote a set of non-overlapping tasks, i.e.: S i + D i =< S j or S j + D j =< S i for all 1 =< i <
j =< n. Example:
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
349
?- length(Vs, 3),
Vs ins 0..3,
serialized(Vs, [1,2,3]),
label(Vs).
Vs = [0, 1, 3] ;
Vs = [2, 0, 3] ;
false.
See also Dorndorf et al. 2000, ”Constraint Propagation Techniques for the Disjunctive Scheduling
Problem”
element(?N, +Vs, ?V)
The N-th element of the list of ﬁnite domain variables Vs is V. Analogous to nth1/3.
global cardinality(+Vs, +Pairs)
Global Cardinality constraint. Equivalent to global_cardinality(Vs, Pairs, []).
Example:
?- Vs = [_,_,_], global_cardinality(Vs, [1-2,3-_]), label(Vs).
Vs = [1, 1, 3] ;
Vs = [1, 3, 1] ;
Vs = [3, 1, 1].
global cardinality(+Vs, +Pairs, +Options)
Global Cardinality constraint. Vs is a list of ﬁnite domain variables, Pairs is a list of Key-Num
pairs, where Key is an integer and Num is a ﬁnite domain variable. The constraint holds iff each
V in Vs is equal to some key, and for each Key-Num pair in Pairs, the number of occurrences
of Key in Vs is Num. Options is a list of options. Supported options are:
consistency(value)
A weaker form of consistency is used.
cost(Cost, Matrix)
Matrix is a list of rows, one for each variable, in the order they occur in Vs. Each of these
rows is a list of integers, one for each key, in the order these keys occur in Pairs. When
variable v i is assigned the value of key k j, then the associated cost is Matrix {ij}. Cost
is the sum of all costs.
circuit(+Vs)
True if the list Vs of ﬁnite domain variables induces a Hamiltonian circuit. The k-th element of
Vs denotes the successor of node k. Node indexing starts with 1. Examples:
?- length(Vs, _), circuit(Vs), label(Vs).
Vs = [] ;
Vs = [1] ;
Vs = [2, 1] ;
Vs = [2, 3, 1] ;
SWI-Prolog 6.6 Reference Manual

350
APPENDIX A. THE SWI-PROLOG LIBRARY
Vs = [3, 1, 2] ;
Vs = [2, 3, 4, 1] .
cumulative(+Tasks)
Equivalent to cumulative(Tasks, [limit(1)]).
cumulative(+Tasks, +Options)
Tasks is a list of tasks, each of the form task(S_i, D_i, E_i, C_i, T_i). S i de-
notes the start time, D i the positive duration, E i the end time, C i the non-negative resource
consumption, and T i the task identiﬁer. Each of these arguments must be a ﬁnite domain
variable with bounded domain, or an integer. The constraint holds if at any time during the start
and end of each task, the total resource consumption of all tasks running at that time does not
exceed the global resource limit (which is 1 by default). Options is a list of options. Currently,
the only supported option is:
limit(L)
The integer L is the global resource limit.
For example, given the following predicate that relates three tasks of durations 2 and 3 to a list
containing their starting times:
tasks_starts(Tasks, [S1,S2,S3]) :-
Tasks = [task(S1,3,_,1,_),
task(S2,2,_,1,_),
task(S3,2,_,1,_)].
We can use cumulative/2 as follows, and obtain a schedule:
?- tasks_starts(Tasks, Starts), Starts ins 0..10,
cumulative(Tasks, [limit(2)]), label(Starts).
Tasks = [task(0, 3, 3, 1, _G36), task(0, 2, 2, 1, _G45), ...],
Starts = [0, 0, 2] .
automaton(+Signature, +Nodes, +Arcs)
Describes a list of ﬁnite domain variables with a ﬁnite automaton.
Equivalent to
automaton(_, _, Signature, Nodes, Arcs, [], [], _),
a
common
use case of automaton/8. In the following example, a list of binary ﬁnite domain variables
is constrained to contain at least two consecutive ones:
:- use_module(library(clpfd)).
two_consecutive_ones(Vs) :-
automaton(Vs, [source(a),sink(c)],
[arc(a,0,a), arc(a,1,b),
arc(b,0,a), arc(b,1,c),
arc(c,0,c), arc(c,1,c)]).
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
351
Example query:
?- length(Vs, 3), two_consecutive_ones(Vs), label(Vs).
Vs = [0, 1, 1] ;
Vs = [1, 1, 0] ;
Vs = [1, 1, 1].
automaton(?Sequence, ?Template, +Signature, +Nodes, +Arcs, +Counters, +Initials, ?Finals)
Describes a list of ﬁnite domain variables with a ﬁnite automaton. True if the ﬁnite automaton
induced by Nodes and Arcs (extended with Counters) accepts Signature. Sequence is a list
of terms, all of the same shape. Additional constraints must link Sequence to Signature, if
necessary. Nodes is a list of source(Node) and sink(Node) terms. Arcs is a list of
arc(Node,Integer,Node) and arc(Node,Integer,Node,Exprs) terms that
denote the automaton’s transitions. Each node is represented by an arbitrary term. Transitions
that are not mentioned go to an implicit failure node. Exprs is a list of arithmetic expressions,
of the same length as Counters. In each expression, variables occurring in Counters correspond
to old counter values, and variables occurring in Template correspond to the current element of
Sequence. When a transition containing expressions is taken, counters are updated as stated.
By default, counters remain unchanged. Counters is a list of variables that must not occur
anywhere outside of the constraint goal.
Initials is a list of the same length as Counters.
Counter arithmetic on the transitions relates the counter values in Initials to Finals.
The following example is taken from Beldiceanu, Carlsson, Debruyne and Petit: ”Reformu-
lation of Global Constraints Based on Constraints Checkers”, Constraints 10(4), pp 339-362
(2005). It relates a sequence of integers and ﬁnite domain variables to its number of inﬂexions,
which are switches between strictly ascending and strictly descending subsequences:
:- use_module(library(clpfd)).
sequence_inflexions(Vs, N) :-
variables_signature(Vs, Sigs),
automaton(_, _, Sigs,
[source(s),sink(i),sink(j),sink(s)],
[arc(s,0,s), arc(s,1,j), arc(s,2,i),
arc(i,0,i), arc(i,1,j,[C+1]), arc(i,2,i),
arc(j,0,j), arc(j,1,j),
arc(j,2,i,[C+1])],
[C], [0], [N]).
variables_signature([], []).
variables_signature([V|Vs], Sigs) :-
variables_signature_(Vs, V, Sigs).
variables_signature_([], _, []).
variables_signature_([V|Vs], Prev, [S|Sigs]) :-
V #= Prev #<==> S #= 0,
Prev #< V #<==> S #= 1,
SWI-Prolog 6.6 Reference Manual

352
APPENDIX A. THE SWI-PROLOG LIBRARY
Prev #> V #<==> S #= 2,
variables_signature_(Vs, V, Sigs).
Example queries:
?- sequence_inflexions([1,2,3,3,2,1,3,0], N).
N = 3.
?- length(Ls, 5), Ls ins 0..1,
sequence_inflexions(Ls, 3), label(Ls).
Ls = [0, 1, 0, 1, 0] ;
Ls = [1, 0, 1, 0, 1].
transpose(+Matrix, ?Transpose)
Transpose a list of lists of the same length. Example:
?- transpose([[1,2,3],[4,5,6],[7,8,9]], Ts).
Ts = [[1, 4, 7], [2, 5, 8], [3, 6, 9]].
This predicate is useful in many constraint programs. Consider for instance Sudoku:
:- use_module(library(clpfd)).
sudoku(Rows) :-
length(Rows, 9), maplist(length_(9), Rows),
append(Rows, Vs), Vs ins 1..9,
maplist(all_distinct, Rows),
transpose(Rows, Columns),
maplist(all_distinct, Columns),
Rows = [A,B,C,D,E,F,G,H,I],
blocks(A, B, C), blocks(D, E, F), blocks(G, H, I).
length_(L, Ls) :- length(Ls, L).
blocks([], [], []).
blocks([A,B,C|Bs1], [D,E,F|Bs2], [G,H,I|Bs3]) :-
all_distinct([A,B,C,D,E,F,G,H,I]),
blocks(Bs1, Bs2, Bs3).
problem(1, [[_,_,_,_,_,_,_,_,_],
[_,_,_,_,_,3,_,8,5],
[_,_,1,_,2,_,_,_,_],
[_,_,_,5,_,7,_,_,_],
[_,_,4,_,_,_,1,_,_],
[_,9,_,_,_,_,_,_,_],
[5,_,_,_,_,_,_,7,3],
SWI-Prolog 6.6 Reference Manual

A.7. LIBRARY(CLPFD): CONSTRAINT LOGIC PROGRAMMING OVER FINITE
DOMAINS
353
[_,_,2,_,1,_,_,_,_],
[_,_,_,_,4,_,_,_,9]]).
Sample query:
?- problem(1, Rows), sudoku(Rows), maplist(writeln, Rows).
[9, 8, 7, 6, 5, 4, 3, 2, 1]
[2, 4, 6, 1, 7, 3, 9, 8, 5]
[3, 5, 1, 9, 2, 8, 7, 4, 6]
[1, 2, 8, 5, 3, 7, 6, 9, 4]
[6, 3, 4, 8, 9, 2, 1, 5, 7]
[7, 9, 5, 4, 6, 1, 8, 3, 2]
[5, 1, 9, 2, 8, 6, 4, 7, 3]
[4, 7, 2, 3, 1, 9, 5, 6, 8]
[8, 6, 3, 7, 4, 5, 2, 1, 9]
Rows = [[9, 8, 7, 6, 5, 4, 3, 2|...], ... , [...|...]].
zcompare(?Order, ?A, ?B)
Analogous to compare/3, with ﬁnite domain variables A and B. Example:
:- use_module(library(clpfd)).
n_factorial(N, F) :-
zcompare(C, N, 0),
n_factorial_(C, N, F).
n_factorial_(=, _, 1).
n_factorial_(>, N, F) :-
F #= F0*N, N1 #= N - 1,
n_factorial(N1, F0).
This version is deterministic if the ﬁrst argument is instantiated:
?- n_factorial(30, F).
F = 265252859812191058636308480000000.
chain(+Zs, +Relation)
Zs form a chain with respect to Relation. Zs is a list of ﬁnite domain variables that are a chain
with respect to the partial order Relation, in the order they appear in the list. Relation must be
#=, #=<, #>=, #< or #>. For example:
?- chain([X,Y,Z], #>=).
X#>=Y,
Y#>=Z.
SWI-Prolog 6.6 Reference Manual

354
APPENDIX A. THE SWI-PROLOG LIBRARY
fd var(+Var)
True iff Var is a CLP(FD) variable.
fd inf(+Var, -Inf)
Inf is the inﬁmum of the current domain of Var.
fd sup(+Var, -Sup)
Sup is the supremum of the current domain of Var.
fd size(+Var, -Size)
Determine the size of a variable’s domain. Size is the number of elements of the current domain
of Var, or the atom sup if the domain is unbounded.
fd dom(+Var, -Dom)
Dom is the current domain (see in/2) of Var. This predicate is useful if you want to reason
about domains.
It is not needed if you only want to display remaining domains; instead,
separate your model from the search part and let the toplevel display this information via
residual goals.
A.8
library(clpqr): Constraint Logic Programming over Rationals and
Reals
Author: Christian Holzbaur, ported to SWI-Prolog by Leslie De Koninck, K.U. Leuven
This CLP(Q,R) system is a port of the CLP(Q,R) system of Sicstus Prolog by Christian Holzbaur:
Holzbaur C.: OFAI clp(q,r) Manual, Edition 1.3.3, Austrian Research Institute for Artiﬁcial Intelli-
gence, Vienna, TR-95-09, 1995.1 This manual is roughly based on the manual of the above mentioned
CLP(Q,R) implementation.
The CLP(Q,R) system consists of two components: the CLP(Q) library for handling constraints
over the rational numbers and the CLP(R) library for handling constraints over the real numbers (using
ﬂoating point numbers as representation). Both libraries offer the same predicates (with exception of
bb inf/4 in CLP(Q) and bb inf/5 in CLP(R)). It is allowed to use both libraries in one program,
but using both CLP(Q) and CLP(R) constraints on the same variable will result in an exception.
Please note that the clpqr library is not an autoload library and therefore this library must be
loaded explicitly before using it:
:- use_module(library(clpq)).
or
:- use_module(library(clpr)).
1http://www.ai.univie.ac.at/cgi-bin/tr-online?number+95-09
SWI-Prolog 6.6 Reference Manual

A.8. LIBRARY(CLPQR): CONSTRAINT LOGIC PROGRAMMING OVER RATIONALS
AND REALS
355
A.8.1
Solver predicates
The following predicates are provided to work with constraints:
{}(+Constraints)
Adds the constraints given by Constraints to the constraint store.
entailed(+Constraint)
Succeeds if Constraint is necessarily true within the current constraint store. This means that
adding the negation of the constraint to the store results in failure.
inf(+Expression, -Inf)
Computes the inﬁmum of Expression within the current state of the constraint store and returns
that inﬁmum in Inf. This predicate does not change the constraint store.
sup(+Expression, -Sup)
Computes the supremum of Expression within the current state of the constraint store and
returns that supremum in Sup. This predicate does not change the constraint store.
minimize(+Expression)
Minimizes Expression within the current constraint store. This is the same as computing the
inﬁmum and equating the expression to that inﬁmum.
maximize(+Expression)
Maximizes Expression within the current constraint store. This is the same as computing the
supremum and equating the expression to that supremum.
bb inf(+Ints, +Expression, -Inf, -Vertex, +Eps)
This predicate is offered in CLP(R) only. It computes the inﬁmum of Expression within the
current constraint store, with the additional constraint that in that inﬁmum, all variables in Ints
have integral values. Vertex will contain the values of Ints in the inﬁmum. Eps denotes how
much a value may differ from an integer to be considered an integer. E.g. when Eps = 0.001,
then X = 4.999 will be considered as an integer (5 in this case). Eps should be between 0 and
0.5.
bb inf(+Ints, +Expression, -Inf, -Vertex)
This predicate is offered in CLP(Q) only. It behaves the same as bb inf/5 but does not use
an error margin.
bb inf(+Ints, +Expression, -Inf)
The same as bb inf/5 or bb inf/4 but without returning the values of the integers. In
CLP(R), an error margin of 0.001 is used.
dump(+Target, +Newvars, -CodedAnswer)
Returns the constraints on Target in the list CodedAnswer where all variables of Target have
been replaced by NewVars. This operation does not change the constraint store. E.g. in
dump([X,Y,Z],[x,y,z],Cons)
Cons will contain the constraints on X, Y and Z, where these variables have been replaced by
atoms x, y and z.
SWI-Prolog 6.6 Reference Manual

356
APPENDIX A. THE SWI-PROLOG LIBRARY
⟨Constraints⟩
::=
⟨Constraint⟩
single constraint
|
⟨Constraint⟩, ⟨Constraints⟩
conjunction
|
⟨Constraint⟩; ⟨Constraints⟩
disjunction
⟨Constraint⟩
::=
⟨Expression⟩< ⟨Expression⟩
less than
|
⟨Expression⟩> ⟨Expression⟩
greater than
|
⟨Expression⟩=< ⟨Expression⟩
less or equal
|
<=(⟨Expression⟩, ⟨Expression⟩)
less or equal
|
⟨Expression⟩>= ⟨Expression⟩
greater or equal
|
⟨Expression⟩=\= ⟨Expression⟩
not equal
|
⟨Expression⟩=:= ⟨Expression⟩
equal
|
⟨Expression⟩= ⟨Expression⟩
equal
⟨Expression⟩
::=
⟨Variable⟩
Prolog variable
|
⟨Number⟩
Prolog number
|
+⟨Expression⟩
unary plus
|
-⟨Expression⟩
unary minus
|
⟨Expression⟩+ ⟨Expression⟩
addition
|
⟨Expression⟩- ⟨Expression⟩
substraction
|
⟨Expression⟩* ⟨Expression⟩
multiplication
|
⟨Expression⟩/ ⟨Expression⟩
division
|
abs(⟨Expression⟩)
absolute value
|
sin(⟨Expression⟩)
sine
|
cos(⟨Expression⟩)
cosine
|
tan(⟨Expression⟩)
tangent
|
exp(⟨Expression⟩)
exponent
|
pow(⟨Expression⟩)
exponent
|
⟨Expression⟩ˆ ⟨Expression⟩
exponent
|
min(⟨Expression⟩, ⟨Expression⟩)
minimum
|
max(⟨Expression⟩, ⟨Expression⟩)
maximum
Table A.1: CLP(Q,R) constraint BNF
A.8.2
Syntax of the predicate arguments
The arguments of the predicates deﬁned in the subsection above are deﬁned in table A.1. Failing to
meet the syntax rules will result in an exception.
A.8.3
Use of uniﬁcation
Instead of using the {}/1 predicate, you can also use the standard uniﬁcation mechanism to store
constraints. The following code samples are equivalent:
• Uniﬁcation with a variable
{X =:= Y}
{X = Y}
X = Y
SWI-Prolog 6.6 Reference Manual

A.8. LIBRARY(CLPQR): CONSTRAINT LOGIC PROGRAMMING OVER RATIONALS
AND REALS
357
A = B ∗C
B or C is ground
A = 5 * C or A = B * 4
A and (B or C) are ground
20 = 5 * C or 20 = B * 4
A = B/C
C is ground
A = B / 3
A and B are ground
4 = 12 / C
X = min(Y, Z)
Y and Z are ground
X = min(4,3)
X = max(Y, Z)
Y and Z are ground
X = max(4,3)
X = abs(Y )
Y is ground
X = abs(-7)
X = pow(Y, Z)
X and Y are ground
8 = 2 ˆ Z
X = exp(Y, Z)
X and Z are ground
8 = Y ˆ 3
X = Y ˆ Z
Y and Z are ground
X = 2 ˆ 3
X = sin(Y )
X is ground
1 = sin(Y)
X = cos(Y )
Y is ground
X = sin(1.5707)
X = tan(Y )
Table A.2: CLP(Q,R) isolating axioms
• Uniﬁcation with a number
{X =:= 5.0}
{X = 5.0}
X = 5.0
A.8.4
Non-linear constraints
The CLP(Q,R) system deals only passively with non-linear constraints. They remain in a passive
state until certain conditions are satisﬁed. These conditions, which are called the isolation axioms, are
given in table A.2.
A.8.5
Status and known problems
The clpq and clpr libraries are ‘orphaned’, i.e., they currently have no maintainer.
• Top-level output
The top-level output may contain variables not present in the original query:
?- {X+Y>=1}.
{Y=1-X+_G2160, _G2160>=0}.
?-
Nonetheless, for linear constraints this kind of answer means unconditional satisﬁability.
• Dumping constraints
The ﬁrst argument of dump/3 has to be a list of free variables at call-time:
?- {X=1},dump([X],[Y],L).
ERROR: Unhandled exception: Unknown message:
SWI-Prolog 6.6 Reference Manual

358
APPENDIX A. THE SWI-PROLOG LIBRARY
instantiation_error(dump([1],[_G11],_G6),1)
?-
A.9
library(csv): Process CSV (Comma-Separated Values) data
See also RFC 4180
To be done
- Implement immediate assert of the data to avoid possible stack overﬂows.
- Writing creates an intermediate code-list, possibly overﬂowing resources. This waits for pure output!
This library parses and generates CSV data. CSV data is represented in Prolog as a list of rows.
Each row is a compound term, where all rows have the same name and arity.
csv read ﬁle(+File, -Rows)
[det]
csv read ﬁle(+File, -Rows, +Options)
[det]
Read a CSV ﬁle into a list of rows. Each row is a Prolog term with the same arity. Options
is handed to csv//2. Remaining options are processed by phrase from file/3. The
default separator depends on the ﬁle name extension and is \t for .tsv ﬁles and , otherwise.
Suppose we want to create a predicate table/6 from a CSV ﬁle that we know contains 6
ﬁelds per record. This can be done using the code below. Without the option arity(6), this
would generate a predicate table/N, where N is the number of ﬁelds per record in the data.
?- csv_read_file(File, Rows, [functor(table), arity(6)]),
maplist(assert, Rows).
csv(?Rows) //
[det]
csv(?Rows, +Options) //
[det]
Prolog DCG to ‘read/write’ CSV data. Options:
separator(+Code)
The comma-separator. Must be a character code. Default is (of course) the comma.
Character codes can be speciﬁed using the 0’ notion. E.g., using separator(0’;)
parses a semicolon separated ﬁle.
ignore quotes(+Boolean)
If true (default false), threat double quotes as a normal character.
strip(+Boolean)
If true (default false), strip leading and trailing blank space. RFC4180 says that
blank space is part of the data.
convert(+Boolean)
If true (default), use name/2 on the ﬁeld data. This translates the ﬁeld into a number if
possible.
functor(+Atom)
Functor to use for creating row terms. Default is row.
SWI-Prolog 6.6 Reference Manual

A.10. LIBRARY(DEBUG): PRINT DEBUG MESSAGES AND TEST ASSERTIONS
359
arity(?Arity)
Number
of
ﬁelds
in
each
row.
This
predicate
raises
a
domain_error(row_arity(Expected), Found) if a row is found with
different arity.
match arity(+Boolean)
If false (default true), do not reject CSV ﬁles where lines provide a varying number
of ﬁelds (columns). This can be a work-around to use some incorrect CSV ﬁles.
csv read ﬁle row(+File, -Row, +Options)
[nondet]
True when Row is a row in File. First uniﬁes Row with the ﬁrst row in File. Backtracking
yields the second, ... row. This interface is an alternative to csv read file/3 that avoids
loading all rows in memory. Note that this interface does not guarantee that all rows in File
have the same arity.
In addition to the options of csv read file/3, this predicate processes the option:
line(-Line)
Line is uniﬁed with the 1-based line-number from which Row is read. Note that Line is
not the physical line, but rather the logical record number.
To be done Input is read line by line. If a record separator is embedded in a quoted ﬁeld, parsing the
record fails and another line is added to the input. This does not nicely deal with other reasons
why parsing the row may fail.
csv write ﬁle(+File, +Data)
[det]
csv write ﬁle(+File, +Data, +Options)
[det]
Write a list of Prolog terms to a CSV ﬁle. Options are given to csv//2. Remaining options
are given to open/4. The default separator depends on the ﬁle name extension and is \t for
.tsv ﬁles and , otherwise.
csv write stream(+Stream, +Data, +Options)
[det]
Write the rows in Data to Stream. This is similar to csv write file/3, but can deal with
data that is produced incrementally. The example below saves all answers from the predicate
data/3 to File.
save_data(File) :-
setup_call_cleanup(
open(File, write, Out),
forall(data(C1,C2,C3),
csv_write_stream(Out, [row(C1,C2,C3)], [])),
close(Out)),
A.10
library(debug): Print debug messages and test assertions
author Jan Wielemaker
This library is a replacement for format/3 for printing debug messages. Messages are assigned
a topic. By dynamically enabling or disabling topics the user can select desired messages. Debug
statements are removed when the code is compiled for optimization.
SWI-Prolog 6.6 Reference Manual

360
APPENDIX A. THE SWI-PROLOG LIBRARY
See manual for details. With XPCE, you can use the call below to start a graphical monitoring
tool.
?- prolog_ide(debug_monitor).
Using the predicate assertion/1 you can make assumptions about your program explicit,
trapping the debugger if the condition does not hold.
debugging(+Topic)
[semidet]
debugging(-Topic)
[nondet]
debugging(?Topic, ?Bool)
[nondet]
Examine debug topics.
The form debugging(+Topic) may be used to perform more
complex debugging tasks. A typical usage skeleton is:
(
debugging(mytopic)
->
<perform debugging actions>
;
true
),
...
The other two calls are intended to examine existing and enabled debugging tokens and are
typically not used in user programs.
debug(+Topic)
[det]
nodebug(+Topic)
[det]
Add/remove a topic from being printed. nodebug(_) removes all topics. Gives a warning if
the topic is not deﬁned unless it is used from a directive. The latter allows placing debug topics
at the start of a (load-)ﬁle without warnings.
For debug/1, Topic can be a term Topic > Out, where Out is either a stream or stream-alias
or a ﬁlename (atom). This redirects debug information on this topic to the given output.
list debug topics
[det]
List currently known debug topics and their setting.
debug message context(+What)
[det]
Specify additional context for debug messages. What is one of +Context or -Context, and Con-
text is one of thread, time or time(Format), where Format is a format speciﬁcation for
format time/3 (default is %T.%3f). Initially, debug/3 shows only thread information.
debug(+Topic, +Format, :Args)
[det]
Format a message if debug topic is enabled. Similar to format/3 to user_error, but only
prints if Topic is activated through debug/1. Args is a meta-argument to deal with goal for the
@-command.
Output is ﬁrst handed to the hook prolog:debug print hook/3.
If this fails,
Format+Args is translated to text using the message-translation (see
print message/2) for the term debug(Format, Args) and then printed to ev-
ery matching destination (controlled by debug/1) using print message lines/3.
The message is preceded by ’% ’ and terminated with a newline.
SWI-Prolog 6.6 Reference Manual

A.11. LIBRARY(GENSYM): GENERATE UNIQUE IDENTIFIERS
361
See also format/3.
prolog:debug print hook(+Topic, +Format, +Args)
[semidet,multiﬁle]
Hook called by debug/3. This hook is used by the graphical frontend that can be activated
using prolog ide/1:
?- prolog_ide(debug_monitor).
assertion(:Goal)
[det]
Acts similar to C assert() macro. It has no effect if Goal succeeds. If Goal fails or throws
an exception, the following steps are taken:
• call prolog:assertion failed/2. If prolog:assertion failed/2 fails,
then:
– If this is an interactive toplevel thread, print a message, the stack-trace, and ﬁnally
trap the debugger.
– Otherwise, throw error(assertion_error(Reason, G),_) where Reason
is one of fail or the exception raised.
prolog:assertion failed(+Reason, +Goal)
[semidet,multiﬁle]
This hook is called if the Goal of assertion/1 fails. Reason is uniﬁed with either fail
if Goal simply failed or an exception call otherwise. If this hook fails, the default behaviour
is activated.
If the hooks throws an exception it will be propagated into the caller of
assertion/1.
A.11
library(gensym): Generate unique identiﬁers
Gensym (Generate Symbols) is an old library for generating unique symbols (atoms). Such symbols
are generated from a base atom which gets a sequence number appended. Of course there is no
guarantee that ‘catch22’ is not an already deﬁned atom and therefore one must be aware these atoms
are only unique in an isolated context.
The SWI-Prolog gensym library is thread-safe. The sequence numbers are global over all threads
and therefore generated atoms are unique over all threads.
gensym(+Base, -Unique)
Generate a unique atom from base Base and unify it with Unique. Base should be an atom. The
ﬁrst call will return ⟨base⟩1, the next ⟨base⟩2, etc. Note that this is no guarantee that the atom
is unique in the system.
reset gensym(+Base)
Restart generation of identiﬁers from Base at ⟨Base⟩1. Used to make sure a program produces
the same results on subsequent runs. Use with care.
reset gensym
Reset gensym for all registered keys. This predicate is available for compatibility only. New
code is strongly advised to avoid the use of reset gensym or at least to reset only the keys used
by your program to avoid unexpected side effects on other components.
SWI-Prolog 6.6 Reference Manual

362
APPENDIX A. THE SWI-PROLOG LIBRARY
A.12
library(lists): List Manipulation
Compatibility Virtually every Prolog system has library(lists), but the set of provided predicates
is diverse. There is a fair agreement on the semantics of most of these predicates, although error
handling may vary.
This library provides commonly accepted basic predicates for list manipulation in the Prolog
community. Some additional list manipulations are built-in. See e.g., memberchk/2, length/2.
The implementation of this library is copied from many places. These include: ”The Craft of
Prolog”, the DEC-10 Prolog library (LISTRO.PL) and the YAP lists library. Some predicates are
reimplemented based on their speciﬁcation by Quintus and SICStus.
member(?Elem, ?List)
True if Elem is a member of List. The SWI-Prolog deﬁnition differs from the classical one.
Our deﬁnition avoids unpacking each list element twice and provides determinism on the last
element. E.g. this is deterministic:
member(X, [One]).
author Gertjan van Noord
append(?List1, ?List2, ?List1AndList2)
List1AndList2 is the concatenation of List1 and List2
append(+ListOfLists, ?List)
Concatenate a list of lists. Is true if ListOfLists is a list of lists, and List is the concatenation of
these lists.
Arguments
ListOfLists
must be a list of possibly partial lists
preﬁx(?Part, ?Whole)
True
iff
Part
is
a
leading
substring
of
Whole.
This
is
the
same
as
append(Part, _, Whole).
select(?Elem, ?List1, ?List2)
Is true when List1, with Elem removed, results in List2.
selectchk(+Elem, +List, -Rest)
[semidet]
Semi-deterministic removal of ﬁrst element in List that uniﬁes with Elem.
select(?X, ?XList, ?Y, ?YList)
[nondet]
True if XList is uniﬁable with YList apart a single element at the same position that is uniﬁed
with X in XList and with Y in YList. A typical use for this predicate is to replace an element, as
shown in the example below. All possible substitutions are performed on backtracking.
?- select(b, [a,b,c,b], 2, X).
X = [a, 2, c, b] ;
X = [a, b, c, 2] ;
false.
SWI-Prolog 6.6 Reference Manual

A.12. LIBRARY(LISTS): LIST MANIPULATION
363
See also selectchk/4 provides a semidet version.
selectchk(?X, ?XList, ?Y, ?YList)
[semidet]
Semi-deterministic version of select/4.
nextto(?X, ?Y, ?List)
True if Y follows X in List.
delete(+List1, @Elem, -List2)
[det]
Delete matching elements from a list. True when List2 is a list with all elements from List1
except for those that unify with Elem.
Matching Elem with elements of List1 is uses
\+ Elem \= H, which implies that Elem is not changed.
See also select/3, subtract/3.
deprecated There are too many ways in which one might want to delete elements from a list to justify
the name. Think of matching (= vs. ==), delete ﬁrst/all, be deterministic or not.
nth0(?Index, ?List, ?Elem)
True when Elem is the Index’th element of List. Counting starts at 0.
Errors type_error(integer, Index) if Index is not an integer or unbound.
See also nth1/3.
nth1(?Index, ?List, ?Elem)
Is true when Elem is the Index’th element of List. Counting starts at 1.
See also nth0/3.
nth0(?N, ?List, ?Elem, ?Rest)
[det]
Select/insert element at index. True when Elem is the N’th (0-based) element of List and Rest
is the remainder (as in by select/3) of List. For example:
?- nth0(I, [a,b,c], E, R).
I = 0, E = a, R = [b, c] ;
I = 1, E = b, R = [a, c] ;
I = 2, E = c, R = [a, b] ;
false.
?- nth0(1, L, a1, [a,b]).
L = [a, a1, b].
nth1(?N, ?List, ?Elem, ?Rest)
[det]
As nth0/4, but counting starts at 1.
last(?List, ?Last)
Succeeds when Last is the last element of List. This predicate is semidet if List is a list and
multi if List is a partial list.
Compatibility There is no de-facto standard for the argument order of last/2. Be careful when
porting code or use append(_, [Last], List) as a portable alternative.
SWI-Prolog 6.6 Reference Manual

364
APPENDIX A. THE SWI-PROLOG LIBRARY
proper length(@List, -Length)
[semidet]
True when Length is the number of elements in the proper list List. This is equivalent to
proper_length(List, Length) :-
is_list(List),
length(List, Length).
same length(?List1, ?List2)
Is true when List1 and List2 are lists with the same number of elements. The predicate is
deterministic if at least one of the arguments is a proper list. It is non-deterministic if both
arguments are partial lists.
See also length/2
reverse(?List1, ?List2)
Is true when the elements of List2 are in reverse order compared to List1.
permutation(?Xs, ?Ys)
[nondet]
True when Xs is a permutation of Ys. This can solve for Ys given Xs or Xs given Ys, or even
enumerate Xs and Ys together.
The predicate permutation/2 is primarily intended to
generate permutations.
Note that a list of length N has N! permutations, and unbounded
permutation generation becomes prohibitively expensive, even for rather short lists (10! =
3,628,800).
If both Xs and Ys are provided and both lists have equal length the order is |Xs|ˆ2. Simply
testing whether Xs is a permutation of Ys can be achieved in order log(|Xs|) using msort/2
as illustrated below with the semidet predicate is permutation/2:
is_permutation(Xs, Ys) :-
msort(Xs, Sorted),
msort(Ys, Sorted).
The example below illustrates that Xs and Ys being proper lists is not a sufﬁcient condition to
use the above replacement.
?- permutation([1,2], [X,Y]).
X = 1, Y = 2 ;
X = 2, Y = 1 ;
false.
Errors type_error(list, Arg) if either argument is not a proper or partial list.
ﬂatten(+List1, ?List2)
[det]
Is true if List2 is a non-nested version of List1.
See also append/2
deprecated Ending up needing flatten/3 often indicates, like append/3 for appending two lists,
a bad design. Efﬁcient code that generates lists from generated small lists must use difference
lists, often possible through grammar rules for optimal readability.
SWI-Prolog 6.6 Reference Manual

A.12. LIBRARY(LISTS): LIST MANIPULATION
365
max member(-Max, +List)
[semidet]
True when Max is the largest member in the standard order of terms. Fails if List is empty.
See also
- compare/3
- max list/2 for the maximum of a list of numbers.
min member(-Min, +List)
[semidet]
True when Min is the smallest member in the standard order of terms. Fails if List is empty.
See also
- compare/3
- min list/2 for the minimum of a list of numbers.
sum list(+List, -Sum)
[det]
Sum is the result of adding all numbers in List.
max list(+List:list(number), -Max:number)
[semidet]
True if Max is the largest number in List. Fails if List is empty.
See also max member/2.
min list(+List:list(number), -Min:number)
[semidet]
True if Min is the smallest number in List. Fails if List is empty.
See also min member/2.
numlist(+Low, +High, -List)
[semidet]
List is a list [Low, Low+1, ... High]. Fails if High < Low.
Errors
- type_error(integer, Low)
- type_error(integer, High)
is set(@Set)
[det]
True if Set is a proper list without duplicates. Equivalence is based on ==/2. The implemen-
tation uses sort/2, which implies that the complexity is N*log(N) and the predicate may
cause a resource-error. There are no other error conditions.
list to set(+List, ?Set)
[det]
True when Set has the same elements as List in the same order. The left-most copy of duplicate
elements is retained. List may contain variables. Elements E1 and E2 are considered duplicates
iff E1 == E2 holds. The complexity of the implementation is N*log(N).
Errors List is type-checked.
author Ulrich Neumerkel
See also sort/2 can be used to create an ordered set. Many set operations on ordered sets are order
N rather than order N**2. The list to set/2 predicate is is more expensive than sort/2
because it involves, in addition to a sort, three linear scans of the list.
Compatibility Up to version 6.3.11, list to set/2 had complexity N**2 and equality was tested
using =/2.
SWI-Prolog 6.6 Reference Manual

366
APPENDIX A. THE SWI-PROLOG LIBRARY
intersection(+Set1, +Set2, -Set3)
[det]
True if Set3 uniﬁes with the intersection of Set1 and Set2. The complexity of this predicate is
|Set1|*|Set2|
See also ord intersection/3.
union(+Set1, +Set2, -Set3)
[det]
True if Set3 uniﬁes with the union of Set1 and Set2.
The complexity of this predicate is
|Set1|*|Set2|
See also ord union/3.
subset(+SubSet, +Set)
[semidet]
True if all elements of SubSet belong to Set as well.
Membership test is based on
memberchk/2. The complexity is |SubSet|*|Set|.
See also ord subset/2.
subtract(+Set, +Delete, -Result)
[det]
Delete all elements in Delete from Set. Deletion is based on uniﬁcation using memberchk/2.
The complexity is |Delete|*|Set|.
See also ord subtract/3.
A.13
library(nb set): Non-backtrackable set
The library nb set deﬁnes non-backtrackable sets, implemented as binary trees. The sets are repre-
sented as compound terms and manipulated using nb setarg/3. Non-backtrackable manipulation
of datastructures is not supported by a large number of Prolog implementations, but it has several
advantages over using the database. It produces less garbage, is thread-safe, reentrant and deals with
exceptions without leaking data.
Similar to the assoc library, keys can be any Prolog term, but it is not allowed to instantiate or
modify a term.
One of the ways to use this library is to generate unique values on backtracking without generating
all solutions ﬁrst, for example to act as a ﬁlter between a generator producing many duplicates and an
expensive test routine, as outlined below:
generate_and_test(Solution) :-
empty_nb_set(Set),
generate(Solution),
add_nb_set(Solution, Set, true),
test(Solution).
empty nb set(?Set)
True if Set is a non-backtrackable empty set.
SWI-Prolog 6.6 Reference Manual

A.14. LIBRARY(WWW BROWSER): ACTIVATING YOUR WEB-BROWSER
367
add nb set(+Key, !Set)
Add Key to Set. If Key is already a member of Set, add nb set/3 succeeds without modifying
Set.
add nb set(+Key, !Set, ?New)
If Key is not in Set and New is uniﬁed to true, Key is added to Set. If Key is in Set, New is
uniﬁed to false. It can be used for many purposes:
add nb set(+, +, false)
Test membership
add nb set(+, +, true)
Succeed only if new member
add nb set(+, +, Var)
Succeed, binding Var
gen nb set(+Set, -Key)
Generate all members of Set on backtracking in the standard order of terms. To test member-
ship, use add nb set/3.
size nb set(+Set, -Size)
Unify Size with the number of elements in Set.
nb set to list(+Set, -List)
Unify List with a list of all elements in Set in the standard order of terms (i.e., an ordered list).
A.14
library(www browser): Activating your Web-browser
This library deals with the very system-dependent task of opening a web page in a browser. See also
url and the HTTP package.
www open url(+URL)
Open URL in an external web browser. The reason to place this in the library is to centralise
the maintenance on this highly platform- and browser-speciﬁc task. It distinguishes between
the following cases:
• MS-Windows
If it detects MS-Windows it uses win shell/2 to open the URL. The behaviour and
browser started depends on the version of Windows and Windows-shell conﬁguration, but
in general it should be the behaviour expected by the user.
• Other platforms
On other platforms it tests the environment variable (see getenv/2) named BROWSER
or uses netscape if this variable is not set.
If the browser is either mozilla or
netscape, www open url/1 ﬁrst tries to open a new window on a running browser
using the -remote option of Netscape. If this fails or the browser is not mozilla or
netscape the system simply passes the URL as ﬁrst argument to the program.
A.15
library(option): Option list processing
See also
- library(record)
- Option processing capabilities may be declared using the directive predicate options/3.
SWI-Prolog 6.6 Reference Manual

368
APPENDIX A. THE SWI-PROLOG LIBRARY
To be done We should consider putting many options in an assoc or record with appropriate preprocessing
to achieve better performance.
The library(option) provides some utilities for processing option lists. Option lists are
commonly used as an alternative for many arguments. Examples of built-in predicates are open/4
and write term/3. Naming the arguments results in more readable code, and the list nature makes
it easy to extend the list of options accepted by a predicate. Option lists come in two styles, both of
which are handled by this library.
Name(Value) This is the preferred style.
Name = Value This is often used, but deprecated.
Processing options inside time-critical code (loops) can cause serious overhead. One possibility is
to deﬁne a record using library(record) and initialise this using make <record>/2. In addition
to providing good performance, this also provides type-checking and central declaration of defaults.
:- record atts(width:integer=100, shape:oneof([box,circle])=box).
process(Data, Options) :-
make_atts(Options, Attributes),
action(Data, Attributes).
action(Data, Attributes) :-
atts_shape(Attributes, Shape),
...
Options typically have exactly one argument. The library does support options with 0 or more
than one argument with the following restrictions:
• The predicate option/3 and select option/4, involving default are meaningless. They
perform an arg(1, Option, Default), causing failure without arguments and ﬁlling
only the ﬁrst option-argument otherwise.
• meta options/3 can only qualify options with exactly one argument.
option(?Option, +OptionList, +Default)
[semidet]
Get an Option Qfrom OptionList.
OptionList can use the Name=Value as well as the
Name(Value) convention.
Arguments
Option
Term of the form Name(?Value).
option(?Option, +OptionList)
[semidet]
Get an Option from OptionList. OptionList can use the Name=Value as well as the Name(Value)
convention. Fails silently if the option does not appear in OptionList.
Arguments
Option
Term of the form Name(?Value).
SWI-Prolog 6.6 Reference Manual

A.16. LIBRARY(OPTPARSE): COMMAND LINE PARSING
369
select option(?Option, +Options, -RestOptions)
[semidet]
Get and remove Option from an option list. As option/2, removing the matching option
from Options and unifying the remaining options with RestOptions.
select option(?Option, +Options, -RestOptions, +Default)
[det]
Get and remove Option with default value. As select option/3, but if Option is not in
Options, its value is uniﬁed with Default and RestOptions with Options.
merge options(+New, +Old, -Merged)
[det]
Merge two option lists.
Merged is a sorted list of options using the canonical format
Name(Value) holding all options from New and Old, after removing conﬂicting options from
Old.
Multi-values options (e.g., proxy(Host, Port)) are allowed, where both option-name and
arity deﬁne the identity of the option.
meta options(+IsMeta, :Options0, -Options)
[det]
Perform meta-expansion on options that are module-sensitive. Whether an option name is
module-sensitive is determined by calling call(IsMeta, Name). Here is an example:
meta_options(is_meta, OptionsIn, Options),
...
is_meta(callback).
Meta-options must have exactly one argument. This argument will be qualiﬁed.
To be done Should be integrated with declarations from predicate options/3.
A.16
library(optparse): command line parsing
author Marcus Uneson
version 0.20 (2011-04-27)
To be done : validation? e.g, numbers; ﬁle path existence; one-out-of-a-set-of-atoms
This module helps in building a command-line interface to an application. In particular, it provides
functions that take an option speciﬁcation and a list of atoms, probably given to the program on the
command line, and return a parsed representation (a list of the customary Key(Val) by default; or
optionally, a list of Func(Key, Val) terms in the style of current prolog flag/2). It can also
synthesize a simple help text from the options speciﬁcation.
The
terminology
in
the
following
is
partly
borrowed
from
python,
see
http://docs.python.org/library/optparse.html#terminology .
Very brieﬂy,
arguments is what you provide on the command line and for many prologs show up as a list of atoms
Args in current_prolog_flag(argv, Args). For a typical prolog incantation, they can be
divided into
• runtime arguments, which controls the prolog runtime; conventionally, they are ended by ’–’;
• options, which are key-value pairs (with a boolean value possibly implicit) intended to control
your program in one way or another; and
SWI-Prolog 6.6 Reference Manual

370
APPENDIX A. THE SWI-PROLOG LIBRARY
• positional arguments, which is what remains after all runtime arguments and options have been
removed (with implicit arguments – true/false for booleans – ﬁlled in).
Positional arguments are in particular used for mandatory arguments without which your program
won’t work and for which there are no sensible defaults (e.g,, input ﬁle names). Options, by contrast,
offer ﬂexibility by letting you change a default setting. Options are optional not only by etymology:
this library has no notion of mandatory or required options (see the python docs for other rationales
than laziness).
The command-line arguments enter your program as a list of atoms, but the programs perhaps
expects booleans, integers, ﬂoats or even prolog terms. You tell the parser so by providing an options
speciﬁcation. This is just a list of individual option speciﬁcations. One of those, in turn, is a list of
ground prolog terms in the customary Name(Value) format. The following terms are recognized (any
others raise error).
opt(Key)
Key
is
what
the
option
later
will
be
accessed
by,
just
like
for
current_prolog_flag(Key, Value). This term is mandatory (an error is thrown if
missing).
shortﬂags(ListOfFlags)
ListOfFlags denotes any single-dashed, single letter args specifying the current option
(-s , -K, etc). Uppercase letters must be quoted. Usually ListOfFlags will be a singleton
list, but sometimes aliased ﬂags may be convenient.
longﬂags(ListOfFlags)
ListOfFlags
denotes
any
double-dashed
arguments
specifying
the
current
option
(--verbose, --no-debug, etc).
They are basically a more readable alternative to
short ﬂags, except
1. long ﬂags can be speciﬁed as --flag value or --flag=value (but not as
--flagvalue); short ﬂags as -f val or -fval (but not -f=val)
2. boolean
long
ﬂags
can
be
speciﬁed
as
--bool-flag
or
--bool-flag=true
or
--bool-flag true;
and
they
can
be
negated
as
--no-bool-flag
or
--bool-flag=false or --bool-flag false.
Except that shortﬂags must be single characters, the distinction between long and short is in
calling convention, not in namespaces. Thus, if you have shortflags([v]), you can use it
as -v2 or -v 2 or --v=2 or --v 2 (but not -v=2 or --v2).
Shortﬂags and longﬂags both default to []. It can be useful to have ﬂagless options – see
example below.
meta(Meta)
Meta is optional and only relevant for the synthesized usage message and is the name (an atom)
of the metasyntactic variable (possibly) appearing in it together with type and default value
(e.g, x:integer=3, interest:float=0.11). It may be useful to have named variables
(x, interest) in case you wish to mention them again in the help text. If not given the
Meta: part is suppressed – see example below.
SWI-Prolog 6.6 Reference Manual

A.16. LIBRARY(OPTPARSE): COMMAND LINE PARSING
371
type(Type)
Type is one of boolean, atom, integer, float, term. The corresponding argu-
ment will be parsed appropriately. This term is optional; if not given, defaults to term.
default(Default)
Default value. This term is optional; if not given, or if given the special value ’ ’, an uninstan-
tiated variable is created (and any type declaration is ignored).
help(Help)
Help is (usually) an atom of text describing the option in the help text. This term is optional
(but obviously strongly recommended for all options which have ﬂags).
Long lines are subject to basic word wrapping – split on white space, reindent, rejoin. However,
you can get more control by supplying the line breaking yourself: rather than a single line of
text, you can provide a list of lines (as atoms). If you do, they will be joined with the appropriate
indent but otherwise left untouched (see the option mode in the example below).
Absence of mandatory option specs or the presence of more than one for a particular option throws
an error, as do unknown or incompatible types.
As a concrete example from a ﬁctive application, suppose we want the following options to be
read from the command line (long flag(s), short flag(s), meta:type=default, help)
--mode
-m
atom=SCAN
data gathering mode,
one of
SCAN: do this
READ: do that
MAKE: make numbers
WAIT: do nothing
--rebuild-cache
-r
boolean=true
rebuild cache in
each iteration
--heisenberg-threshold
-t,-h
float=0.1
heisenberg threshold
--depths, --iters
-i,-d
K:integer=3
stop after K
iterations
--distances
term=[1,2,3,5]
initial prolog term
--output-file
-o
FILE:atom=_
write output to FILE
--label
-l
atom=REPORT
report label
--verbosity
-v
V:integer=2
verbosity level,
1 <= V <= 3
We may also have some conﬁguration parameters which we currently think not needs to be con-
trolled from the command line, say path(’/some/file/path’).
This interface is described by the following options speciﬁcation (order between the speciﬁcations
of a particular option is irrelevant).
ExampleOptsSpec =
[ [opt(mode
), type(atom), default(’SCAN’),
shortflags([m]),
longflags([’mode’] ),
help([ ’data gathering mode, one of’
SWI-Prolog 6.6 Reference Manual

372
APPENDIX A. THE SWI-PROLOG LIBRARY
, ’
SCAN: do this’
, ’
READ: do that’
, ’
MAKE: fabricate some numbers’
, ’
WAIT: don’’t do anything’])]
, [opt(cache), type(boolean), default(true),
shortflags([r]),
longflags([’rebuild-cache’]),
help(’rebuild cache in each iteration’)]
, [opt(threshold), type(float), default(0.1),
shortflags([t,h]),
longflags([’heisenberg-threshold’]),
help(’heisenberg threshold’)]
, [opt(depth), meta(’K’), type(integer), default(3),
shortflags([i,d]),longflags([depths,iters]),
help(’stop after K iterations’)]
, [opt(distances), default([1,2,3,5]),
longflags([distances]),
help(’initial prolog term’)]
, [opt(outfile), meta(’FILE’), type(atom),
shortflags([o]),
longflags([’output-file’]),
help(’write output to FILE’)]
, [opt(label), type(atom), default(’REPORT’),
shortflags([l]), longflags([label]),
help(’report label’)]
, [opt(verbose),
meta(’V’), type(integer), default(2),
shortflags([v]),
longflags([verbosity]),
help(’verbosity level, 1 <= V <= 3’)]
, [opt(path), default(’/some/file/path/’)]
].
The help text above was accessed by opt_help(ExamplesOptsSpec, HelpText). The
options appear in the same order as in the OptsSpec.
Given ExampleOptsSpec, a command line (somewhat syntactically inconsistent, in order to
demonstrate different calling conventions) may look as follows
ExampleArgs = [ ’-d5’
, ’--heisenberg-threshold’, ’0.14’
, ’--distances=[1,1,2,3,5,8]’
, ’--iters’, ’7’
, ’-ooutput.txt’
, ’--rebuild-cache’, ’true’
SWI-Prolog 6.6 Reference Manual

A.16. LIBRARY(OPTPARSE): COMMAND LINE PARSING
373
, ’input.txt’
, ’--verbosity=2’
].
opt_parse(ExampleOptsSpec, ExampleArgs, Opts, PositionalArgs)
would then succeed with
Opts =
[ mode(’SCAN’)
, label(’REPORT’)
, path(’/some/file/path’)
, threshold(0.14)
, distances([1,1,2,3,5,8])
, depth(7)
, outfile(’output.txt’)
, cache(true)
, verbose(2)
],
PositionalArgs = [’input.txt’].
Note that path(’/some/file/path’) showing up in Opts has a default value (of the im-
plicit type ’term’), but no corresponding ﬂags in OptsSpec. Thus it can’t be set from the command
line. The rest of your program doesn’t need to know that, of course. This provides an alternative
to the common practice of asserting such hard-coded parameters under a single predicate (for in-
stance setting(path, ’/some/file/path’)), with the advantage that you may seamlessly
upgrade them to command-line options, should you one day ﬁnd this a good idea. Just add an ap-
propriate ﬂag or two and a line of help text. Similarly, suppressing an option in a cluttered interface
amounts to commenting out the ﬂags.
opt parse/5 allows more control through an additional argument list.
For instance,
opt_parse(ExampleOptsSpec, ExampleArgs, Opts, PositionalArgs, [output_functor(app
would instead return
Opts =
[ appl_config(verbose, 2),
, appl_config(label, ’REPORT’)
...
]
This representation may be preferable with the empty-ﬂag conﬁguration parameter style above
(perhaps with asserting appl config/2).
A.16.1
Notes and tips
• In the example we were mostly explicit about the types. Since the default is term, which
subsumes integer, float, atom, it may be possible to get away cheaper (e.g., by only
giving booleans). However, it is recommended practice to always specify types: parsing be-
comes more reliable and error messages will be easier to interpret.
SWI-Prolog 6.6 Reference Manual

374
APPENDIX A. THE SWI-PROLOG LIBRARY
• Note that -sbar is taken to mean -s bar, not -s -b -a -r, that is, there is no clustering
of ﬂags.
• -s=foo is disallowed. The rationale is that although some command-line parsers will silently
interpret this as -s =foo, this is very seldom what you want. To have an option argument start
with ’=’ (very un-recommended), say so explicitly.
• The example speciﬁes the option depth twice: once as -d5 and once as --iters 7. The
default when encountering duplicated ﬂags is to keeplast (this behaviour can be controlled,
by ParseOption duplicated ﬂags).
• The order of the options returned by the parsing functions is the same as given on the command
line, with non-overridden defaults prepended and duplicates removed as in previous item. You
should not rely on this, however.
• Unknown ﬂags (not appearing in OptsSpec) will throw errors. This is usually a Good Thing.
Sometimes, however, you may wish to pass along ﬂags to an external program (say, one called
by shell/2), and it means duplicated effort and a maintenance headache to have to specify
all possible ﬂags for the external program explicitly (if it even can be done). On the other
hand, simply taking all unknown ﬂags as valid makes error checking much less efﬁcient and
identiﬁcation of positional arguments uncertain. A better solution is to collect all arguments
intended for passing along to an indirectly called program as a single argument, probably as an
atom (if you don’t need to inspect them ﬁrst) or as a prolog term (if you do).
opt arguments(+OptsSpec, -Opts, -PositionalArgs)
[det]
Extract commandline options according to a speciﬁcation. Convenience predicate, assuming
that command-line arguments can be accessed by current prolog flag/2 (as in swi-
prolog). For other access mechanisms and/or more control, get the args and pass them as a list
of atoms to opt parse/4 or opt parse/5 instead.
Opts is a list of parsed options in the form Key(Value). Dashed args not in OptsSpec are not
permitted and will raise error (see tip on how to pass unknown ﬂags in the module description).
PositionalArgs are the remaining non-dashed args after each ﬂag has taken its argument (ﬁlling
in true or false for booleans). There are no restrictions on non-dashed arguments and they
may go anywhere (although it is good practice to put them last). Any leading arguments for the
runtime (up to and including ’–’) are discarded.
opt parse(+OptsSpec, +ApplArgs, -Opts, -PositionalArgs)
[det]
Equivalent to opt_parse(OptsSpec, ApplArgs, Opts, PositionalArgs, []).
opt parse(+OptsSpec, +ApplArgs, -Opts, -PositionalArgs, +ParseOptions)
[det]
Parse the arguments Args (as list of atoms) according to OptsSpec. Any runtime arguments
(typically terminated by ’–’) are assumed to be removed already.
Opts is a list of parsed options in the form Key(Value), or (with the option functor(Func)
given) in the form Func(Key, Value). Dashed args not in OptsSpec are not permitted and will
raise error (see tip on how to pass unknown ﬂags in the module description). PositionalArgs are
the remaining non-dashed args after each ﬂag has taken its argument (ﬁlling in true or false
SWI-Prolog 6.6 Reference Manual

A.17. LIBRARY(ORDSETS): ORDERED SET MANIPULATION
375
for booleans). There are no restrictions on non-dashed arguments and they may go anywhere
(although it is good practice to put them last). ParseOptions are
output functor(Func)
Set the functor Func of the returned options Func(Key,Value). Default is the special value
’OPTION’ (upper-case), which makes the returned options have form Key(Value).
duplicated ﬂags(Keep)
Controls how to handle options given more than once on the commad line.
Keep is
one of keepfirst, keeplast, keepall with the obvious meaning. Default is
keeplast.
allow empty ﬂag spec(Bool)
If true (default), a ﬂag speciﬁcation is not required (it is allowed that both shortﬂags
and longﬂags be either [] or absent). Flagless options cannot be manipulated from the
command line and will not show up in the generated help. This is useful when you have
(also) general conﬁguration parameters in your OptsSpec, especially if you think they
one day might need to be controlled externally. See example in the module overview.
allow_empty_flag_spec(false) gives the more customary behaviour of raising
error on empty ﬂags.
opt help(+OptsSpec, -Help:atom)
[det]
True when Help is a help string synthesized from OptsSpec.
A.17
library(ordsets): Ordered set manipulation
Ordered sets are lists with unique elements sorted to the standard order of terms (see sort/2). Ex-
ploiting ordering, many of the set operations can be expressed in order N rather than Nˆ2 when
dealing with unordered sets that may contain duplicates. The library(ordsets) is available
in a number of Prolog implementations. Our predicates are designed to be compatible with com-
mon practice in the Prolog community.
The implementation is incomplete and relies partly on
library(oset), an older ordered set library distributed with SWI-Prolog. New applications are
advised to use library(ordsets).
Some of these predicates match directly to corresponding list operations. It is advised to use
the versions from this library to make clear you are operating on ordered sets. An exception is
member/2. See ord memberchk/2.
The ordsets library is based on the standard order of terms. This implies it can handle all Prolog
terms, including variables. Note however, that the ordering is not stable if a term inside the set is
further instantiated. Also note that variable ordering changes if variables in the set are uniﬁed with
each other or a variable in the set is uniﬁed with a variable that is ‘older’ than the newest variable in
the set. In practice, this implies that it is allowed to use member(X, OrdSet) on an ordered set
that holds variables only if X is a fresh variable. In other cases one should cease using it as an ordset
because the order it relies on may have been changed.
is ordset(@Term)
[semidet]
True if Term is an ordered set. All predicates in this library expect ordered sets as input argu-
ments. Failing to fullﬁl this assumption results in undeﬁned behaviour. Typically, ordered sets
are created by predicates from this library, sort/2 or setof/3.
SWI-Prolog 6.6 Reference Manual

376
APPENDIX A. THE SWI-PROLOG LIBRARY
ord empty(?List)
[semidet]
True when List is the empty ordered set. Simply uniﬁes list with the empty list. Not part of
Quintus.
ord seteq(+Set1, +Set2)
[semidet]
True if Set1 and Set2 have the same elements. As both are canonical sorted lists, this is the
same as ==/2.
Compatibility sicstus
list to ord set(+List, -OrdSet)
[det]
Transform a list into an ordered set. This is the same as sorting the list.
ord intersect(+Set1, +Set2)
[semidet]
True if both ordered sets have a non-empty intersection.
ord disjoint(+Set1, +Set2)
[semidet]
True if Set1 and Set2 have no common elements. This is the negation of ord intersect/2.
ord intersect(+Set1, +Set2, -Intersection)
Intersection holds the common elements of Set1 and Set2.
deprecated Use ord intersection/3
ord intersection(+PowerSet, -Intersection)
Intersection of a powerset.
True when Intersection is an ordered set holding all elements
common to all sets in PowerSet.
Compatibility sicstus
ord intersection(+Set1, +Set2, -Intersection)
[det]
Intersection holds the common elements of Set1 and Set2.
ord intersection(+Set1, +Set2, ?Intersection, ?Difference)
[det]
Intersection
and
difference
between
two
ordered
sets.
Intersection
is
the
intersection
between
Set1
and
Set2,
while
Difference
is
deﬁned
by
ord_subtract(Set2, Set1, Difference).
See also ord intersection/3 and ord subtract/3.
ord add element(+Set1, +Element, ?Set2)
[det]
Insert
an
element
into
the
set.
This
is
the
same
as
ord_union(Set1, [Element], Set2).
ord del element(+Set, +Element, -NewSet)
[det]
Delete
an
element
from
an
ordered
set.
This
is
the
same
as
ord_subtract(Set, [Element], NewSet).
SWI-Prolog 6.6 Reference Manual

A.17. LIBRARY(ORDSETS): ORDERED SET MANIPULATION
377
ord selectchk(+Item, ?Set1, ?Set2)
[semidet]
Is true when select(Item, Set1, Set2) and Set1, Set2 are both sorted lists without du-
plicates. This implementation is only expected to work for Item ground and either Set1 or Set2
ground. The ”chk” sufﬁx is meant to remind you of memberchk/2, which also expects its
ﬁrst argument to be ground. ord_selectchk(X, S, T) => ord_memberchk(X, S)
& \+ ord_memberchk(X, T).
author Richard O’Keefe
ord memberchk(+Element, +OrdSet)
[semidet]
True if Element is a member of OrdSet, compared using ==. Note that enumerating elements
of an ordered set can be done using member/2.
Some Prolog implementations also provide ord member/2, with the same semantics as
ord memberchk/2. We believe that having a semidet ord member/2 is unacceptably
inconsistent with the * chk convention. Portable code should use ord memberchk/2 or
member/2.
author Richard O’Keefe
ord subset(+Sub, +Super)
[semidet]
Is true if all elements of Sub are in Super
ord subtract(+InOSet, +NotInOSet, -Diff)
[det]
Diff is the set holding all elements of InOSet that are not in NotInOSet.
ord union(+SetOfSets, -Union)
[det]
True if Union is the union of all elements in the superset SetOfSets. Each member of SetOfSets
must be an ordered set, the sets need not be ordered in any way.
author Copied from YAP, probably originally by Richard O’Keefe.
ord union(+Set1, +Set2, ?Union)
[det]
Union is the union of Set1 and Set2
ord union(+Set1, +Set2, -Union, -New)
[det]
True iff ord_union(Set1, Set2, Union) and ord_subtract(Set2, Set1, New).
ord symdiff(+Set1, +Set2, ?Difference)
[det]
Is true when Difference is the symmetric difference of Set1 and Set2. I.e., Difference contains
all elements that are not in the intersection of Set1 and Set2. The semantics is the same as the
sequence below (but the actual implementation requires only a single scan).
ord_union(Set1, Set2, Union),
ord_intersection(Set1, Set2, Intersection),
ord_subtract(Union, Intersection, Difference).
For example:
?- ord_symdiff([1,2], [2,3], X).
X = [1,3].
SWI-Prolog 6.6 Reference Manual

378
APPENDIX A. THE SWI-PROLOG LIBRARY
A.18
library(pairs): Operations on key-value lists
author Jan Wielemaker
See also keysort/2, library(assoc)
This module implements common operations on Key-Value lists, also known as Pairs. Pairs have
great practical value, especially due to keysort/2 and the library assoc.pl.
This library is based on disussion in the SWI-Prolog mailinglist, including speciﬁcations from
Quintus and a library proposal by Richard O’Keefe.
pairs keys values(?Pairs, ?Keys, ?Values)
[det]
True if Keys holds the keys of Pairs and Values the values.
Deterministic if any argument is instantiated to a ﬁnite list and the others are either free or ﬁnite
lists. All three lists are in the same order.
See also pairs values/2 and pairs keys/2.
pairs values(+Pairs, -Values)
[det]
Remove
the
keys
from
a
list
of
Key-Value
pairs.
Same
as
pairs_keys_values(Pairs, _, Values)
pairs keys(+Pairs, -Keys)
[det]
Remove
the
values
from
a
list
of
Key-Value
pairs.
Same
as
pairs_keys_values(Pairs, Keys, _)
group pairs by key(+Pairs, -Joined:list(Key-Values))
[det]
Group values with the same key. Pairs must be a key-sorted list. For example:
?- group_pairs_by_key([a-2, a-1, b-4], X).
X = [a-[2,1], b-[4]]
Arguments
Pairs
Key-Value list,
sorted to the standard order of terms (as
keysort/2 does)
Joined
List of Key-Group, where Group is the list of Values associated
with Key.
transpose pairs(+Pairs, -Transposed)
[det]
Swap Key-Value to Value-Key. The resulting list is sorted using keysort/2 on the new key.
map list to pairs(:Function, +List, -Keyed)
Create a Key-Value list by mapping each element of List. For example, if we have a list of lists
we can create a list of Length-List using
map_list_to_pairs(length, ListOfLists, Pairs),
SWI-Prolog 6.6 Reference Manual

A.19. LIBRARY(PIO): PURE I/O
379
A.19
library(pio): Pure I/O
This library provides pure list-based I/O processing for Prolog, where the communication to the actual
I/O device is performed transparently through coroutining. This module itself is just an interface to
the actual implementation modules.
A.19.1
library(pure input): Pure Input from ﬁles
author
- Ulrich Neumerkel
- Jan Wielemaker
To be done
- Provide support for alternative input readers, e.g. reading terms, tokens, etc.
- Support non-repositioning streams, such as sockets and pipes.
This module is part of pio.pl, dealing with pure input: processing input streams from the
outside world using pure predicates, notably grammar rules (DCG). Using pure predicates makes
non-deterministic processing of input much simpler.
Pure input uses coroutining (freeze/2) to read input from the external source into a list on
demand. The overhead of lazy reading is more than compensated for by using block reads based on
read pending input/3.
phrase from ﬁle(:Grammar, +File)
[nondet]
Process the content of File using the DCG rule Grammar. The space usage of this mechanism
depends on the length of the not committed part of Grammar.
Committed parts of the
temporary list are reclaimed by the garbage collector, while the list is extended on demand.
Here is a very simple deﬁnition for searching a string in a ﬁle:
... --> []|[_],... .
file_contains(File, Pattern) :-
phrase_from_file((..., Pattern, ...), File).
match_count(File, Pattern, Count) :-
findall(x, file_contains(File, Pattern), Xs),
length(Xs, Count).
This can be called as (note that the pattern must be a string (code list)):
?- match_count(’pure_input.pl’, "file", Count).
phrase from ﬁle(:Grammar, +File, +Options)
[nondet]
As phrase from file/2, providing additional Options. Options are passed to open/4,
except for buffer_size, which is passed to set stream/2. If not speciﬁed, the default
buffer size is 512 bytes.
Of particular importance are the open/4 options type and
encoding.
SWI-Prolog 6.6 Reference Manual

380
APPENDIX A. THE SWI-PROLOG LIBRARY
phrase from stream(:Grammer, +Stream)
Helper for phrase from file/3. This predicate cooperates with syntax error//1 to
generate syntax error locations for grammars.
syntax error(+Error) //
Throw the syntax error Error at the current location of the input. This predicate is designed to
be called from the handler of phrase from file/3.
throws error(syntax_error(Error), Location)
lazy list location(-Location) //
[det]
True when Location is an (error) location term that represents the current location in the DCG
list.
Arguments
Location
is a term file(Name, Line, LinePos, CharNo) or
stream(Stream, Line, LinePos, CharNo) if no ﬁle
is associated to the stream RestLazyList.
Finally, if the Lazy
list is fully materialized (ends in []), Location is uniﬁed with
end_of_file-CharCount.
See also lazy list character count//1 only provides the character count.
lazy list character count(-CharCount) //
True when CharCount is the current character count in the Lazy list. The character count is
computed by ﬁnding the distance to the next frozen tail of the lazy list. CharCount is one of:
• An integer
• A term end of ﬁle-Count
See also lazy list location//1 provides full details of the location for error reporting.
stream to lazy list(+Stream, -List)
[det]
Create a lazy list representing the character codes in Stream. It must be possible to reposition
Stream. List is a list that ends in a delayed goal. List can be uniﬁed completely transparent to a
(partial) list and processed transparently using DCGs, but please be aware that a lazy list is not
the same as a materialized list in all respects.
Typically, this predicate is used as a building block for more high level safe predicates such as
phrase from file/2.
To be done Enhance of lazy list throughout the system.
A.20
library(predicate options): Declare option-processing of predi-
cates
Discussions with Jeff Schultz helped shaping this library
SWI-Prolog 6.6 Reference Manual

A.20. LIBRARY(PREDICATE OPTIONS): DECLARE OPTION-PROCESSING OF
PREDICATES
381
A.20.1
The strength and weakness of predicate options
Many ISO predicates accept options, e.g., open/4, write term/3. Options offer an attractive
alternative to proliferation into many predicates and using high-arity predicates. Properly deﬁned and
used, they also form a mechanism for extending the API of both system and application predicates
without breaking portability. I.e., previously ﬁxed behaviour can be replaced by dynamic behaviour
controlled by an option where the default is the previously deﬁned ﬁxed behaviour. The alternative to
using options is to add an additional argument and maintain the previous deﬁnition. While a series of
predicates with increasing arity is adequate for a small number of additional parameters, the untyped
positional argument handling of Prolog quickly makes this unmanageable.
The ISO standard uses the extensibility offered by options by allowing implementations to extend
the set of accepted options. While options form a perfect solution to maintain backward portability in
a linear development model, it is not well equipped to deal with concurrent branches because
1. There is no API to ﬁnd which options are supported in a particular implementation.
2. While the portability problem caused by a missing predicate in Prolog A can easily be solved
by implementing this predicate, it is much harder to add processing of an additional option to
an already existing predicate.
Different Prolog implementations can be seen as concurrent development branches of the Prolog
language. Different sets of supported options pose a serious portability issue. Using an option O that
establishes the desired behaviour on system A leads (on most systems) to an error or system B. Porting
may require several actions:
• Drop O (if the option is not vital, such as the layout options to write term/3)
• Replace O by O2 (i.e., a differently named option doing the same)
• Something else (cannot be ported; requires a totally different approach, etc.)
Predicates that process options are particularly a problem when writing a compatibility layer to
run programs developed for System A on System B because complete emulation is often hard, may
cause a serious slowdown and is often not needed because the application-to-be-ported only uses
options that are shared by all target Prolog implementations. Unfortunately, the consequences of a
partial emulation cannot be assessed by tools.
A.20.2
Options as arguments or environment?
We distinguish two views on options. One is to see them as additional parameters that require strict
existence, type and domain-checking and the other is to consider them ‘locally scoped environment
variables’. Most systems adopt the ﬁrst option. SWI-Prolog adopts the second: it silently ignores
options that are not supported but does type and domain checking of option-values. The ‘environment’
view is commonly used in applications to create predicates supporting more options using the skeleton
below. This way of programming requires that pred1 and pred2 do not interpret the same option
differently. In cases where this is not true, the options must be distributed by some pred. We have
been using this programming style for many years and in practice it turns out that the need for active
distribution of options is rare. I.e., options either have distinct names or multiple predicates implement
the same option but this has the desired effect. An example of the latter is the encoding option,
which typically needs to be applied consistently.
SWI-Prolog 6.6 Reference Manual

382
APPENDIX A. THE SWI-PROLOG LIBRARY
some_pred(..., Options) :-
pred1(..., Options),
pred2(..., Options).
As stated before, options provide a readable alternative to high-arity predicates and offer a robust
mechanism to evolve the API, but at the cost of some runtime overhead and weaker consistency
checking, both at compiletime and runtime. From our experience, the ‘environment’ approach is
productive, but the consequence is that mistyped options are silently ignored. The option infrastructure
described in this section tries to remedy these problems.
A.20.3
Improving on the current situation
Whether we see options as arguments or locally scoped environment variables, the most obvious
way to improve on the current situation is to provide reﬂective support for options: discover that an
argument is an option-list and ﬁnd what options are supported. Reﬂective access to options can be
used by the compiler and development environment as well as by the runtime system to warn or throw
errors.
Options as types
An obvious approach to deal with options is to deﬁne the different possible option values as a type and
type the argument that processes the option as list(<option type>), as illustrated below. Considering
options as types fully covers the case where we consider options as additional parameters.
:- type open_option ---> type(stream_type) |
alias(atom) | ... .
:- pred open(source_sink, open_mode, stream, list(open_option)).
There are three reasons for considering a different approach:
• There is no consensus about types in the Prolog world, neither about what types should look
like, nor whether or not they are desirable. It is not likely that this debate will be resolved
shortly.
• Considering options as types does not support the ‘environment’ view, which we consider the
most productive.
• Even when using types, we need reﬂective access to what options are provided in order to be
able to write compile or runtime conditional code.
Reﬂective access to options
From the above, we conclude that we require reﬂective access to ﬁnd out whether an option is sup-
ported and valid for a particular predicate. Possible option values must be described by types. Due
to lack of a type system, we use library(error) to describe allowed option values. Predicate
options are declared using predicate options/3:
SWI-Prolog 6.6 Reference Manual

A.20. LIBRARY(PREDICATE OPTIONS): DECLARE OPTION-PROCESSING OF
PREDICATES
383
predicate options(:PI, +Arg, +Options)
[det]
Declare that the predicate PI processes options on Arg. Options is a list of options processed.
Each element is one of:
• Option(ModeAndType) PI processes Option. The option-value must comply to Mode-
AndType. Mode is one of + or - and Type is a type as accepted by must be/2.
• pass to(:PI,Arg) The option-list is passed to the indicated predicate.
Below is an example that processes the option header(boolean) and passes all options to
open/4:
:- predicate_options(write_xml_file/3, 3,
[ header(boolean),
pass_to(open/4, 4)
]).
write_xml_file(File, XMLTerm, Options) :-
open(File, write, Out, Options),
(
option(header(true), Option, true)
->
write_xml_header(Out)
;
true
),
...
This predicate may only be used as a directive and is processed by expand term/2. Option
processing can be speciﬁed at runtime using assert predicate options/3, which is
intended to support program analysis.
assert predicate options(:PI, +Arg, +Options, ?New)
[semidet]
As predicate options(:PI, +Arg, +Options). New is a boolean indicating whether the declara-
tions have changed. If New is provided and false, the predicate becomes semidet and fails
without modiﬁcations if modiﬁcations are required.
The predicates below realise the support for compile and runtime checking for supported options.
current predicate option(:PI, ?Arg, ?Option)
[nondet]
True when Arg of PI processes Option. For example, the following is true:
?- current_predicate_option(open/4, 4, type(text)).
true.
This predicate is intended to support conditional compilation using if/1 ... endif/0. The
predicate current predicate options/3 can be used to access the full capabilities of a
predicate.
check predicate option(:PI, +Arg, +Option)
[det]
Verify predicate options at runtime. Similar to current predicate option/3, but in-
tended to support runtime checking.
SWI-Prolog 6.6 Reference Manual

384
APPENDIX A. THE SWI-PROLOG LIBRARY
Errors
- existence_error(option, OptionName) if the option is not supported by PI.
- type_error(Type, Value) if the option is supported but the value does not match the
option type. See must be/2.
The predicates below can be used in a development environment to inform the user about sup-
ported options. PceEmacs uses this for colouring option names and values.
current option arg(:PI, ?Arg)
[nondet]
True when Arg of PI processes predicate options. Which options are processed can be accessed
using current predicate option/3.
current predicate options(:PI, ?Arg, ?Options)
[nondet]
True when Options is the current active option declaration for PI on Arg.
See
predicate options/3 for the argument descriptions.
If PI is ground and refers to
an undeﬁned predicate, the autoloader is used to obtain a deﬁnition of the predicate.
The
library
can
execute
a
complete
check
of
your
program
using
check predicate options/0:
check predicate options
[det]
Analyse loaded program for erroneous options. This predicate decompiles the current program
and searches for calls to predicates that process options.
For each option list, it validates
whether the provided options are supported and validates the argument type. This predicate
performs partial dataﬂow analysis to track option-lists inside a clause.
See also derive predicate options/0
can
be
used
to
derive
declarations
for
predicates
that
pass
options.
This
predicate
should
normally
be
called
before
check predicate options/0.
The library offers predicates that may be used to create declarations for your application. These
predicates are designed to cooperate with the module system.
derive predicate options
[det]
Derive new predicate option declarations. This predicate analyses the loaded program to ﬁnd
clauses that process options using one of the predicates from library(option) or passes
options to other predicates that are known to process options. The process is repeated until no
new declarations are retrieved.
See also autoload/0 may be used to complete the loaded program.
retractall predicate options
[det]
Remove all dynamically (derived) predicate options.
derived predicate options(:PI, ?Arg, ?Options)
[nondet]
Derive option arguments using static analysis. True when Options is the current derived active
option declaration for PI on Arg.
derived predicate options(+Module)
[det]
Derive predicate option declarations for a module.
The derived options are printed to the
current_output stream.
SWI-Prolog 6.6 Reference Manual

A.21. LIBRARY(PROLOG PACK): A PACKAGE MANAGER FOR PROLOG
385
A.21
library(prolog pack): A package manager for Prolog
See also Installed packages can be inspected using ?- doc_browser.
To be done
- Version logic
- Find and resolve conﬂicts
- Upgrade git packages
- Validate git packages
- Test packages: run tests from directory ‘test’.
The library(prolog_pack) provides the SWI-Prolog package manager. This library lets
you inspect installed packages, install packages, remove packages, etc. It is complemented by the
built-in attach packs/0 that makes installed packages available as libaries.
pack list installed
[det]
List currently installed packages. Unlike pack list/1, only locally installed packages are
displayed and no connection is made to the internet.
See also Use pack list/1 to ﬁnd packages.
pack info(+Pack)
Print more detailed information about Pack.
pack search(+Query)
[det]
pack list(+Query)
[det]
Query package server and installed packages and display results.
Query is matches case-
insensitively against the name and title of known and installed packages. For each matching
package, a single line is displayed that provides:
• Installation status
– p: package, not installed
– i: installed package; up-to-date with public version
– U: installed package; can be upgraded
– A: installed package; newer than publically available
– l: installed package; not on server
• Name@Version
• Name@Version(ServerVersion)
• Title
Hint: ?- pack_list(’’). lists all packages.
The predicates pack list/1 and pack search/1 are synonyms. Both contact the package
server at http://www.swi-prolog.org to ﬁnd available packages.
See also pack list installed/0 to list installed packages without contacting the server.
pack install(+Spec:atom)
[det]
Install a package. Spec is one of
SWI-Prolog 6.6 Reference Manual

386
APPENDIX A. THE SWI-PROLOG LIBRARY
• Archive ﬁle name
• HTTP URL of an archive ﬁle name. This URL may contain a star (*) for the version. In
this case pack install asks for the deirectory content and selects the latest version.
• GIT URL (not well supported yet)
• A local directory name
• A
package
name.
This
queries
the
package
repository
at
http://www.swi-prolog.org
After resolving the type of package, pack install/2 is used to do the actual installation.
pack install(+Name, +Options)
[det]
Install package Name. Options:
url(+URL)
Source for downloading the package
package directory(+Dir)
Directory into which to install the package
interactive(+Boolean)
Use default answer without asking the user if there is a default action.
pack rebuild(+Pack)
[det]
Rebuilt possible foreign components of Pack.
pack rebuild
[det]
Rebuild foreign components of all packages.
environment(-Name, -Value)
[nondet,multiﬁle]
Hook to deﬁne the environment for building packs. This Multiﬁle hook extends the process
environment for building foreign extensions. A value provided by this hook overrules defaults
provided by def environment/2. In addition to changing the environment, this may be
used to pass additional values to the environment, as in:
prolog_pack:environment(’USER’, User) :-
getenv(’USER’, User).
Arguments
Name
is an atom denoting a valid variable name
Value
is either an atom or number representing the value of the variable.
pack upgrade(+Pack)
[semidet]
Try to upgrade the package Pack.
To be done Update dependencies when updating a pack from git?
pack remove(+Name)
[det]
Remove the indicated package.
SWI-Prolog 6.6 Reference Manual

A.22. LIBRARY(PROLOG XREF): CROSS-REFERENCE DATA COLLECTION LIBRARY
387
pack property(?Pack, ?Property)
[nondet]
True when Property is a property of Pack. This interface is intended for programs that wish to
interact with the package manager. Deﬁned properties are:
directory(Directory)
Directory into which the package is installed
version(Version)
Installed version
title(Title)
Full title of the package
author(Author)
Registered author
download(URL)
Ofﬁcial download URL
readme(File)
Package README ﬁle (if present)
todo(File)
Package TODO ﬁle (if present)
A.22
library(prolog xref): Cross-reference data collection library
This library collects information on deﬁned and used objects in Prolog source ﬁles. Typically these
are predicates, but we expect the library to deal with other types of objects in the future. The library is
a building block for tools doing dependency tracking in applications. Dependency tracking is useful
to reveal the structure of an unknown program or detect missing components at compile time, but also
for program transformation or minimising a program saved state by only saving the reachable objects.
This section gives a partial description of the library API, providing some insight in how you can
use it for analysing your program. The library should be further modularized, moving its knowledge
about, for example, XPCE into a different ﬁle and allowing for adding knowledge about other libraries
such as Logtalk. Please do not consider this interface rock-solid.
The library is exploited by two graphical tools in the SWI-Prolog environment: the XPCE front-
end started by gxref/0 and described in section 3.7, and PceEmacs (section 3.4), which exploits
this library for its syntax colouring.
For all predicates described below, Source is the source that is processed. This is normally a
ﬁlename in any notation acceptable to the ﬁle loading predicates (see load files/2). Using the
hooks deﬁned in section A.22.1 it can be anything else that can be translated into a Prolog stream
holding Prolog source text. Callable is a callable term (see callable/1). Callables do not carry a
module qualiﬁer unless the referred predicate is not in the module deﬁned Source.
xref source(+Source)
Gather information on Source. If Source has already been processed and is still up-to-date
according to the ﬁle timestamp, no action is taken. This predicate must be called on a ﬁle
before information can be gathered.
xref current source(?Source)
Source has been processed.
SWI-Prolog 6.6 Reference Manual

388
APPENDIX A. THE SWI-PROLOG LIBRARY
xref clean(+Source)
Remove the information gathered for Source
xref deﬁned(?Source, ?Callable, -How)
Callable is deﬁned in Source. How is one of
dynamic(Line)
Declared dynamic at Line
thread local(Line)
Declared thread local at Line
multifile(Line)
Declared multiﬁle at Line
local(Line)
First clause at Line
foreign(Line)
Foreign library loaded at Line
constraint(Line)
CHR Constraint at Line
imported(File)
Imported from File
xref called(?Source, ?Callable, ?By)
Callable is called in Source by By.
xref exported(?Source, ?Callable)
Callable is public (exported from the module).
xref module(?Source, ?Module)
Source is a module ﬁle deﬁning the given module.
xref built in(?Callable)
True if Callable is a built-in predicate. Currently this is assumed for all predicates deﬁned in
the system module and having the property built in. Built-in predicates are not registered
as ‘called’.
A.22.1
Extending the library
The library provides hooks for extending the rules it uses for ﬁnding predicates called by some pro-
gramming construct.
prolog:called by(+Goal, -Called)
Goal is a non-var subgoal appearing in the called object (typically a clause body). If it succeeds
it must return a list of goals called by Goal. As a special construct, if a term Callable + N
is returned, N variable arguments are added to Callable before further processing. For simple
meta-calls a single fact sufﬁces. Complex rules as used in the html write library provided
by the HTTP package examine the arguments and create a list of called objects.
The current system cannot deal with the same name/arity in different modules that behave dif-
ferently with respect to called arguments.
A.23
library(quasi quotations): Deﬁne Quasi Quotation syntax
author Jan Wielemaker. Introduction of Quasi Quotation was suggested by Michael Hendricks.
See also
SWI-Prolog 6.6 Reference Manual

A.23. LIBRARY(QUASI QUOTATIONS): DEFINE QUASI QUOTATION SYNTAX
389
Inspired by Haskell, SWI-Prolog support quasi quotation. Quasi quotation allows for embedding
(long) strings using the syntax of an external language (e.g., HTML, SQL) in Prolog text and syntax-
aware embedding of Prolog variables in this syntax. At the same time, quasi quotation provides an
alternative to represent long strings and atoms in Prolog.
The basic form of a quasi quotation is deﬁned below. Here, Syntax is an arbitrary Prolog term
that must parse into a callable (atom or compound) term and Quotation is an arbitrary sequence of
characters, not including the sequence |}. If this sequence needs to be embedded, it must be escaped
according to the rules of the target language or the ‘quoter’ must provide an escaping mechanism.
{|Syntax||Quotation|}
While reading a Prolog term, and if the Prolog ﬂag quasi_quotes is set to true (which is the
case if this library is loaded), the parser collects quasi quotations. After reading the ﬁnal full stop, the
parser makes the call below. Here, SyntaxName is the functor name of Syntax above and SyntaxArgs
is a list holding the arguments, i.e., Syntax =.. [SyntaxName|SyntaxArgs]. Splitting the
syntax into its name and arguments is done to make the quasi quotation parser a predicate with a
consistent arity 4, regardless of the number of additional arguments.
call(+SyntaxName, +Content, +SyntaxArgs, +VariableNames, -Result)
The arguments are deﬁned as
• SyntaxName is the principal functor of the quasi quotation syntax. This must be declared using
quasi quotation syntax/1 and there must be a predicate SyntaxName/4.
• Content is an opaque term that carries the content of the quasi quoted material and position
information about the source code. It is passed to with quasi quote input/3.
• SyntaxArgs carries the additional arguments of the Syntax. These are commonly used to make
the parameter passing between the clause and the quasi quotation explicit. For example:
...,
{|html(Name, Address)||
<tr><td>Name<td>Address</tr>
|}
• VariableNames is the complete variable dictionary of the clause as it is made available throug
read term/3 with the option variable_names. It is a list of terms Name = Var.
• Result is a variable that must be uniﬁed to resulting term. Typically, this term is structured Pro-
log tree that carries a (partial) representation of the abstract syntax tree with embedded variables
that pass the Prolog parameters. This term is normally either passed to a predicate that serializes
the abstract syntax tree, or a predicate that processes the result in Prolog. For example, HTML is
commonly embedded for writing HTML documents (see library(http/html_write)).
Examples of languages that may be embedded for processing in Prolog are SPARQL, RuleML
or regular expressions.
SWI-Prolog 6.6 Reference Manual

390
APPENDIX A. THE SWI-PROLOG LIBRARY
The ﬁle library(http/html_quasiquotations) provides the, suprisingly simple,
quasi quotation parser for HTML.
with quasi quotation input(+Content, -Stream, :Goal)
[det]
Process the quasi-quoted Content using Stream parsed by Goal. Stream is a temporary stream
with the following properties:
• Its initial position represents the position of the start of the quoted material.
• It is a text stream, using utf8 encoding.
• It allows for repositioning
• It will be closed after Goal completes.
Arguments
Goal
is executed as once(Goal). Goal must succeed. Failure or ex-
ceptions from Goal are interpreted as syntax errors.
See also phrase from quasi quotation/2 can be used to process a quotation using a gram-
mar.
phrase from quasi quotation(:Grammar, +Content)
[det]
Process the quasi quotation using the DCG Grammar. Failure of the grammer is interpreted as
a syntax error.
See also with quasi quotation input/3 for processing quotations from stream.
quasi quotation syntax(:SyntaxName)
[det]
Declare the predicate SyntaxName/4 to implement the the quasi quote syntax SyntaxName.
Normally used as a directive.
quasi quotation syntax error(+Error)
Report syntax_error(Error) using the current location in the quasi quoted input parser.
throws error(syntax_error(Error), Position)
A.24
library(random): Random numbers
author R.A. O’Keefe, V.S. Costa, L. Damas, Jan Wielemaker
See also Built-in function random/1: A is random(10)
This library is derived from the DEC10 library random. Later, the core random generator was
moved to C. The current version uses the SWI-Prolog arithmetic functions to realise this library.
These functions are based on the GMP library.
random(-R:ﬂoat)
[det]
Binds R to a new random ﬂoat in the open interval (0.0,1.0).
SWI-Prolog 6.6 Reference Manual

A.24. LIBRARY(RANDOM): RANDOM NUMBERS
391
See also
- setrand/1, getrand/1 may be used to fetch/set the state.
- In SWI-Prolog, random/1 is implemented by the function random float/0.
random between(+L:int, +U:int, -R:int)
[semidet]
Binds R to a random integer in [L,U] (i.e., including both L and U). Fails silently if U<L.
random(+L:int, +U:int, -R:int)
[det]
random(+L:ﬂoat, +U:ﬂoat, -R:ﬂoat)
[det]
Generate a random integer or ﬂoat in a range. If L and U are both integers, R is a random
integer in the half open interval [L,U). If L and U are both ﬂoats, R is a ﬂoat in the open interval
(L,U).
deprecated Please use random/1 for generating a random ﬂoat and random between/3 for gen-
erating a random integer. Note that the random between/3 includes the upper bound, while
this predicate excludes the upper bound.
setrand(+State)
[det]
getrand(-State)
[det]
Query/set the state of the random generator.
This is intended for restarting the generator
at a known state only.
The predicate setrand/1 accepts an opaque term returned by
getrand/1. This term may be asserted, written and read. The application may not make
other assumptions about this term.
For compatibility reasons with older versions of this library, setrand/1 also accepts a term
rand(A,B,C), where A, B and C are integers in the range 1..30,000. This argument is used
to seed the random generator. Deprecated.
Errors existence_error(random_state, _) is raised if the underlying infrastructure can-
not fetch the random state. This is currently the case if SWI-Prolog is not compiled with the
GMP library.
See also set random/1 and random property/1 provide the SWI-Prolog native implementa-
tion.
maybe
[semidet]
Succeed/fail with equal probability (variant of maybe/1).
maybe(+P)
[semidet]
Succeed with probability P, fail with probability 1-P
maybe(+K, +N)
[semidet]
Succeed with probability K/N (variant of maybe/1)
random perm2(?A, ?B, ?X, ?Y)
[semidet]
Does X=A,Y=B or X=B,Y=A with equal probability.
random member(-X, +List:list)
[semidet]
X is a random member of List. Equivalent to random between(1, |List|), followed by nth1/3.
Fails of List is the empty list.
Compatibility Quintus and SICStus libraries.
SWI-Prolog 6.6 Reference Manual

392
APPENDIX A. THE SWI-PROLOG LIBRARY
random select(-X, +List, -Rest)
[semidet]
random select(+X, -List, +Rest)
[det]
Randomly select or insert an element. Either List or Rest must be a list. Fails if List is the
empty list.
Compatibility Quintus and SICStus libraries.
randset(+K:int, +N:int, -S:list(int))
[det]
S is a sorted list of K unique random integers in the range 1..N. Implemented by enumerating
1..N and deciding whether or not the number should be part of the set. For example:
?- randset(5, 5, S).
S = [1, 2, 3, 4, 5].
(always)
?- randset(5, 20, S).
S = [2, 7, 10, 19, 20].
See also randseq/3.
bug Slow if N is large and K is small.
randseq(+K:int, +N:int, -List:list(int))
[det]
S is a list of K unique random integers in the range 1..N. The order is random. Works as if
deﬁned by the following code.
randseq(K, N, List) :-
randset(K, N, Set),
random_permutation(Set, List).
See also randset/3.
random permutation(+List, -Permutation)
[det]
random permutation(-List, +Permutation)
[det]
Permutation is a random permutation of List. This is intended to process the elements of List
in random order. The predicate is symmetric.
Errors instantiation error, type_error(list, _).
A.25
library(readutil): Reading lines, streams and ﬁles
This library contains primitives to read lines, ﬁles, multiple terms, etc. The package clib provides
a shared object (DLL) named readutil. If the library can locate this shared object it will use the
foreign implementation for reading character codes. Otherwise it will use a Prolog implementation.
Distributed applications should make sure to deliver the readutil shared object if performance of
these predicates is critical.
read line to codes(+Stream, -Codes)
Read the next line of input from Stream and unify the result with Codes after the line has been
read. A line is ended by a newline character or end-of-ﬁle. Unlike read line to codes/3,
this predicate removes a trailing newline character.
On end-of-ﬁle the atom end of file is returned. See also at end of stream/[0,1].
SWI-Prolog 6.6 Reference Manual

A.26. LIBRARY(RECORD): ACCESS NAMED FIELDS IN A TERM
393
read line to codes(+Stream, -Codes, ?Tail)
Difference-list version to read an input line to a list of character codes. Reading stops at the
newline or end-of-ﬁle character, but unlike read line to codes/2, the newline is retained
in the output.
This predicate is especially useful for reading a block of lines up to some
delimiter. The following example reads an HTTP header ended by a blank line:
read_header_data(Stream, Header) :-
read_line_to_codes(Stream, Header, Tail),
read_header_data(Header, Stream, Tail).
read_header_data("\r\n", _, _) :- !.
read_header_data("\n", _, _) :- !.
read_header_data("", _, _) :- !.
read_header_data(_, Stream, Tail) :-
read_line_to_codes(Stream, Tail, NewTail),
read_header_data(Tail, Stream, NewTail).
read stream to codes(+Stream, -Codes)
Read all input until end-of-ﬁle and unify the result to Codes.
read stream to codes(+Stream, -Codes, ?Tail)
Difference-list version of read stream to codes/2.
read ﬁle to codes(+Spec, -Codes, +Options)
Read
a
ﬁle
to
a
list
of
character
codes.
Spec
is
a
ﬁle
speciﬁcation
for
absolute file name/3.
Codes is the resulting code list.
Options is a list of op-
tions for absolute file name/3 and open/4.
In addition, the option tail(Tail) is
deﬁned, forming a difference-list.
read ﬁle to terms(+Spec, -Terms, +Options)
Read a ﬁle to a list of Prolog terms (see read/1).
Spec is a ﬁle speciﬁcation for
absolute file name/3. Terms is the resulting list of Prolog terms. Options is a list of
options for absolute file name/3 and open/4. In addition, the option tail(Tail) is
deﬁned, forming a difference-list.
A.26
library(record): Access named ﬁelds in a term
The library record provides named access to ﬁelds in a record represented as a compound term such
as point(X, Y). The Prolog world knows various approaches to solve this problem, unfortunately
with no consensus. The approach taken by this library is proposed by Richard O’Keefe on the SWI-
Prolog mailinglist.
The approach automates a technique commonly described in Prolog text-books, where access and
modiﬁcation predicates are deﬁned for the record type. Such predicates are subject to normal im-
port/export as well as analysis by cross-referencers. Given the simple nature of the access predicates,
an optimizing compiler can easily inline them for optimal preformance.
A record is deﬁned using the directive record/1. We introduce the library with a short example:
SWI-Prolog 6.6 Reference Manual

394
APPENDIX A. THE SWI-PROLOG LIBRARY
:- record point(x:integer=0, y:integer=0).
...,
default_point(Point),
point_x(Point, X),
set_x_of_point(10, Point, Point1),
make_point([y(20)], YPoint),
The principal functor and arity of the term used deﬁnes the name and arity of the compound used as
records. Each argument is described using a term of the format below.
⟨name⟩[:⟨type⟩][=⟨default⟩]
In this deﬁnition, ⟨name⟩is an atom deﬁning the name of the argument, ⟨type⟩is an optional type
speciﬁcation as deﬁned by must be/2 from library error, and ⟨default⟩is the default initial value.
The ⟨type⟩defaults to any. If no default value is speciﬁed the default is an unbound variable.
A record declaration creates a set of predicates through term-expansion. We describe these predi-
cates below. In this description, ⟨constructor⟩refers to the name of the record (‘point’ in the example
above) and ⟨name⟩to the name of an argument (ﬁeld).
• default ⟨constructor⟩(-Record)
Create a new record where all ﬁelds have their default values.
This is the same as
make ⟨constructor⟩([], Record).
• make ⟨constructor⟩(+Fields, -Record)
Create a new record where speciﬁed ﬁelds have the speciﬁed values and remaining ﬁelds have
their default value. Each ﬁeld is speciﬁed as a term ⟨name⟩(⟨value⟩). See example in the
introduction.
• make ⟨constructor⟩(+Fields, -Record, -RestFields)
Same as make ⟨constructor⟩/2, but named ﬁelds that do not appear in Record are returned in
RestFields. This predicate is motivated by option-list processing. See library option.
• ⟨constructor⟩⟨name⟩(Record, Value)
Unify Value with argument in Record named ⟨name⟩.2
• ⟨constructor⟩data(?Name, +Record, ?Value)
True when Value is the value for the ﬁeld named Name in Record. This predicate does not
perform type-checking.
• set ⟨name⟩of ⟨constructor⟩(+Value, +OldRecord, -NewRecord)
Replace the value for ⟨name⟩in OldRecord by Value and unify the result with NewRecord.
• set ⟨name⟩of ⟨constructor⟩(+Value, !Record)
Destructively replace the argument ⟨name⟩in Record by Value based on setarg/3. Use with
care.
2Note this is not called ‘get ’ as it performs uniﬁcation and can perfectly well instantiate the argument.
SWI-Prolog 6.6 Reference Manual

A.27. LIBRARY(REGISTRY): MANIPULATING THE WINDOWS REGISTRY
395
• nb set ⟨name⟩of ⟨constructor⟩(+Value, !Record)
As above, but using non-backtrackable assignment based on nb setarg/3. Use with extreme
care.
• set ⟨constructor⟩ﬁelds(+Fields, +Record0, -Record)
Set multiple ﬁelds using the same syntax as make ⟨constructor⟩/2, but starting with Record0
rather than the default record.
• set ⟨constructor⟩ﬁelds(+Fields, +Record0, -Record, -RestFields)
Similar to set ⟨constructor⟩ﬁelds/4, but ﬁelds not deﬁned by ⟨constructor⟩are returned in
RestFields.
• set ⟨constructor⟩ﬁeld(+Field, +Record0, -Record)
Set a single ﬁeld speciﬁed as a term ⟨name⟩(⟨value⟩).
record(+Spec)
The construct :- record Spec, ... is used to deﬁne access to named ﬁelds in a com-
pound.
It is subject to term-expansion (see expand term/2) and cannot be called as a
predicate. See section A.26 for details.
A.27
library(registry): Manipulating the Windows registry
The registry is only available on the MS-Windows version of SWI-Prolog. It loads the foreign
extension plregtry.dll, providing the predicates described below. This library only makes the
most common operations on the registry available through the Prolog user. The underlying DLL
provides a more complete coverage of the Windows registry API. Please consult the sources in pl/
src/win32/foreign/plregtry.c for further details.
In all these predicates, Path refers to a ‘/’ separated path into the registry. This is not an atom
containing ‘/’-characters as used for ﬁlenames, but a term using the functor //2. Windows deﬁnes the
following roots for the registry: classes root, current user, local machine and users.
registry get key(+Path, -Value)
Get the principal (default) value associated to this key. Fails silently if the key does not exist.
registry get key(+Path, +Name, -Value)
Get a named value associated to this key.
registry set key(+Path, +Value)
Set the principal (default) value of this key. Creates (a path to) the key if it does not already
exist.
registry set key(+Path, +Name, +Value)
Associate a named value to this key. Creates (a path to) the key if it does not already exist.
registry delete key(+Path)
Delete the indicated key.
shell register ﬁle type(+Ext, +Type, +Name, +OpenAction)
Register a ﬁle-type. Ext is the extension to associate. Type is the type name, often something
SWI-Prolog 6.6 Reference Manual

396
APPENDIX A. THE SWI-PROLOG LIBRARY
like prolog.type. Name is the name visible in the Windows ﬁle-type browser. Finally,
OpenAction deﬁnes the action to execute when a ﬁle with this extension is opened in the
Windows explorer.
shell register dde(+Type, +Action, +Service, +Topic, +Command, +IfNotRunning)
Associate DDE actions to a type. Type is the same type as used for the 2nd argument of
shell register file type/4, Action is the action to perform, Service and Topic
specify the DDE topic to address, and Command is the command to execute on this topic.
Finally, IfNotRunning deﬁnes the command to execute if the required DDE server is not
present.
shell register prolog(+Ext)
Default registration of SWI-Prolog, which is invoked as part of the initialisation process on
Windows systems. As the source also includes the above predicates, it is given as an example:
shell_register_prolog(Ext) :-
current_prolog_flag(argv, [Me|_]),
atomic_list_concat([’"’, Me, ’" "%1"’], OpenCommand),
shell_register_file_type(
Ext, ’prolog.type’, ’Prolog Source’, OpenCommand),
shell_register_dde(
’prolog.type’, consult,
prolog, control, ’consult(’’%1’’)’, Me),
shell_register_dde(
’prolog.type’, edit,
prolog, control, ’edit(’’%1’’)’, Me).
A.28
library(simplex): Solve linear programming problems
Author: Markus Triska
A linear programming problem consists of a set of (linear) constraints, a number of variables and a
linear objective function. The goal is to assign values to the variables so as to maximize (or minimize)
the value of the objective function while satisfying all constraints.
Many optimization problems can be modeled in this way. Consider having a knapsack with ﬁxed
capacity C, and a number of items with sizes s(i) and values v(i). The goal is to put as many items as
possible in the knapsack (not exceeding its capacity) while maximizing the sum of their values.
As another example, suppose you are given a set of coins with certain values, and you are to ﬁnd
the minimum number of coins such that their values sum up to a ﬁxed amount. Instances of these
problems are solved below.
The simplex module provides the following predicates:
assignment(+Cost, -Assignment)
Cost is a list of lists representing the quadratic cost matrix, where element (i,j) denotes the cost
of assigning entity i to entity j. An assignment with minimal cost is computed and uniﬁed with
Assignment as a list of lists, representing an adjacency matrix.
SWI-Prolog 6.6 Reference Manual

A.28. LIBRARY(SIMPLEX): SOLVE LINEAR PROGRAMMING PROBLEMS
397
constraint(+Constraint, +S0, -S)
Adds a linear or integrality constraint to the linear program corresponding to state S0.
A
linear constraint is of the form ”Left Op C”, where ”Left” is a list of Coefﬁcient*Variable
terms (variables in the context of linear programs can be atoms or compound terms) and
C is a non-negative numeric constant. The list represents the sum of its elements. Op can
be =, =¡ or ¿=. The coefﬁcient ”1” can be omitted. An integrality constraint is of the form
integral(Variable) and constrains Variable to an integral value.
constraint(+Name, +Constraint, +S0, -S)
Like constraint/3, and attaches the name Name (an atom or compound term) to the new
constraint.
constraint add(+Name, +Left, +S0, -S)
Left is a list of Coefﬁcient*Variable terms. The terms are added to the left-hand side of the
constraint named Name. S is uniﬁed with the resulting state.
gen state(-State)
Generates an initial state corresponding to an empty linear program.
maximize(+Objective, +S0, -S)
Maximizes the objective function, stated as a list of ”Coefﬁcient*Variable” terms that repre-
sents the sum of its elements, with respect to the linear program corresponding to state S0. S is
uniﬁed with an internal representation of the solved instance.
minimize(+Objective, +S0, -S)
Analogous to maximize/3.
objective(+State, -Objective)
Uniﬁes Objective with the result of the objective function at the obtained extremum. State must
correspond to a solved instance.
shadow price(+State, +Name, -Value)
Uniﬁes Value with the shadow price corresponding to the linear constraint whose name is
Name. State must correspond to a solved instance.
transportation(+Supplies, +Demands, +Costs, -Transport)
Supplies and Demands are both lists of positive numbers. Their respective sums must be equal.
Costs is a list of lists representing the cost matrix, where an entry (i,j) denotes the cost of
transporting one unit from i to j. A transportation plan having minimum cost is computed and
uniﬁed with Transport in the form of a list of lists that represents the transportation matrix,
where element (i,j) denotes how many units to ship from i to j.
variable value(+State, +Variable, -Value)
Value is uniﬁed with the value obtained for Variable. State must correspond to a solved instance.
All numeric quantities are converted to rationals via rationalize/1, and rational arithmetic is
used throughout solving linear programs. In the current implementation, all variables are implicitly
constrained to be non-negative. This may change in future versions, and non-negativity constraints
should therefore be stated explicitly.
SWI-Prolog 6.6 Reference Manual

398
APPENDIX A. THE SWI-PROLOG LIBRARY
A.28.1
Example 1
This is the ”radiation therapy” example, taken from ”Introduction to Operations Research” by Hillier
and Lieberman. DCG notation is used to implicitly thread the state through posting the constraints:
:- use_module(library(simplex)).
post_constraints -->
constraint([0.3*x1, 0.1*x2] =< 2.7),
constraint([0.5*x1, 0.5*x2] = 6),
constraint([0.6*x1, 0.4*x2] >= 6),
constraint([x1] >= 0),
constraint([x2] >= 0).
radiation(S) :-
gen_state(S0),
post_constraints(S0, S1),
minimize([0.4*x1, 0.5*x2], S1, S).
An example query:
?- radiation(S), variable_value(S, x1, Val1),
variable_value(S, x2, Val2).
Val1 = 15 rdiv 2
Val2 = 9 rdiv 2 ;
A.28.2
Example 2
Here is an instance of the knapsack problem described above, where C = 8, and we have two types of
items: One item with value 7 and size 6, and 2 items each having size 4 and value 4. We introduce
two variables, x(1) and x(2) that denote how many items to take of each type.
knapsack_constrain(S) :-
gen_state(S0),
constraint([6*x(1), 4*x(2)] =< 8, S0, S1),
constraint([x(1)] =< 1, S1, S2),
constraint([x(2)] =< 2, S2, S).
knapsack(S) :-
knapsack_constrain(S0),
maximize([7*x(1), 4*x(2)], S0, S).
An example query yields:
SWI-Prolog 6.6 Reference Manual

A.28. LIBRARY(SIMPLEX): SOLVE LINEAR PROGRAMMING PROBLEMS
399
?- knapsack(S), variable_value(S, x(1), X1),
variable_value(S, x(2), X2).
X1 = 1
X2 = 1 rdiv 2 ;
That is, we are to take the one item of the ﬁrst type, and half of one of the items of the other type to
maximize the total value of items in the knapsack.
If items can not be split, integrality constraints have to be imposed:
knapsack_integral(S) :-
knapsack_constrain(S0),
constraint(integral(x(1)), S0, S1),
constraint(integral(x(2)), S1, S2),
maximize([7*x(1), 4*x(2)], S2, S).
Now the result is different:
?- knapsack_integral(S), variable_value(S, x(1), X1),
variable_value(S, x(2), X2).
X1 = 0
X2 = 2
That is, we are to take only the two items of the second type. Notice in particular that always choosing
the remaining item with best performance (ratio of value to size) that still ﬁts in the knapsack does not
necessarily yield an optimal solution in the presence of integrality constraints.
A.28.3
Example 3
We are given 3 coins each worth 1, 20 coins each worth 5, and 10 coins each worth 20 units of money.
The task is to ﬁnd a minimal number of these coins that amount to 111 units of money. We introduce
variables c(1), c(5) and c(20) denoting how many coins to take of the respective type:
coins -->
constraint([c(1), 5*c(5), 20*c(20)] = 111),
constraint([c(1)] =< 3),
constraint([c(5)] =< 20),
constraint([c(20)] =< 10),
constraint([c(1)] >= 0),
constraint([c(5)] >= 0),
constraint([c(20)] >= 0),
constraint(integral(c(1))),
constraint(integral(c(5))),
constraint(integral(c(20))),
minimize([c(1), c(5), c(20)]).
SWI-Prolog 6.6 Reference Manual

400
APPENDIX A. THE SWI-PROLOG LIBRARY
coins(S) :-
gen_state(S0),
coins(S0, S).
An example query:
?- coins(S), variable_value(S, c(1), C1),
variable_value(S, c(5), C5),
variable_value(S, c(20), C20).
C1 = 1
C5 = 2
C20 = 5
A.29
library(thread pool): Resource bounded thread management
See also http handler/3 and http spawn/2.
The module library(thread_pool) manages threads in pools. A pool deﬁnes properties
of its member threads and the maximum number of threads that can coexist in the pool. The call
thread create in pool/4 allocates a thread in the pool, just like thread create/3. If the
pool is fully allocated it can be asked to wait or raise an error.
The library has been designed to deal with server applications that receive a variety of requests,
such as HTTP servers. Simply starting a thread for each request is a bit too simple minded for such
servers:
• Creating many CPU intensive threads often leads to a slow-down rather than a speedup.
• Creating many memory intensive threads may exhaust resources
• Tasks that require little CPU and memory but take long waiting for external resources can run
many threads.
Using this library, one can deﬁne a pool for each set of tasks with comparable characteristics
and create threads in this pool. Unlike the worker-pool model, threads are not started immediately.
Depending on the design, both approaches can be attractive.
The library is implemented by means of a manager thread with the ﬁxed thread id
__thread_pool_manager. All state is maintained in this manager thread, which receives and
processes requests to create and destroy pools, create threads in a pool and handle messages from
terminated threads. Thread pools are not saved in a saved state and must therefore be recreated using
the initialization/1 directive or otherwise during startup of the application.
SWI-Prolog 6.6 Reference Manual

A.29. LIBRARY(THREAD POOL): RESOURCE BOUNDED THREAD MANAGEMENT401
thread pool create(+Pool, +Size, +Options)
[det]
Create a pool of threads. A pool of threads is a declaration for creating threads with shared
properties (stack sizes) and a limited number of threads.
Threads are created using
thread create in pool/4. If all threads in the pool are in use, the behaviour depends
on the wait option of thread create in pool/4 and the backlog option described
below. Options are passed to thread create/3, except for
backlog(+MaxBackLog)
Maximum number of requests that can be suspended. Default is infinite. Otherwise
it must be a non-negative integer. Using backlog(0) will never delay thread creation
for this pool.
The pooling mechanism does not interact with the detached state of a thread. Threads can
be created both detached and normal and must be joined using thread join/2 if they are
not detached.
thread pool destroy(+Name)
[det]
Destroy the thread pool named Name.
Errors existence_error(thread_pool, Name).
current thread pool(?Name)
[nondet]
True if Name refers to a deﬁned thread pool.
thread pool property(?Name, ?Property)
[nondet]
True if Property is a property of thread pool Name. Deﬁned properties are:
options(Options)
Thread creation options for this pool
free(Size)
Number of free slots on this pool
size(Size)
Total number of slots on this pool
members(ListOfIDs)
ListOfIDs is the list or threads running in this pool
running(Running)
Number of running threads in this pool
backlog(Size)
Number of delayed thread creations on this pool
thread create in pool(+Pool, :Goal, -Id, +Options)
[det]
Create a thread in Pool. Options overrule default thread creation options associated to the pool.
In addition, the following option is deﬁned:
wait(+Boolean)
If true (default) and the pool is full, wait until a member of the pool completes. If
false, throw a resource error.
SWI-Prolog 6.6 Reference Manual

402
APPENDIX A. THE SWI-PROLOG LIBRARY
Errors
- resource_error(threads_in_pool(Pool)) is raised if wait is false or the back-
log limit has been reached.
- existence_error(thread_pool, Pool) if Pool does not exist.
create pool(+PoolName)
[semidet,multiﬁle]
This hook is called if thread create in pool/4 discovers that the thread pool does not
exist. If the hook succeeds, thread create in pool/4 retries creating the thread. For
example, we can use the following declaration to create threads in the pool media, which
holds a maximum of 20 threads.
:- multifile thread_pool:create_pool/1.
thread_pool:create_pool(media) :-
thread_pool_create(media, 20, []).
A.30
library(ugraphs): Unweighted Graphs
Authors: Richard O’Keefe & Vitor Santos Costa
Implementation and documentation are copied from YAP 5.0.1. The ugraph library is
based on code originally written by Richard O’Keefe. The code was then extended to be
compatible with the SICStus Prolog ugraphs library. Code and documentation have been
cleaned and style has been changed to be more in line with the rest of SWI-Prolog.
The ugraphs library was originally released in the public domain. The YAP version is
covered by the Perl Artistic license, version 2.0. This code is dual-licensed under the
modiﬁed GPL as used for all SWI-Prolog libraries or the Perl Artistic license, version
2.0.
The routines assume directed graphs; undirected graphs may be implemented by using two edges.
Originally graphs were represented in two formats.
The SICStus library and this version of
ugraphs.pl only use the S-representation. The S-representation of a graph is a list of (vertex-
neighbors) pairs, where the pairs are in standard order (as produced by keysort) and the neighbors
of each vertex are also in standard order (as produced by sort). This form is convenient for many
calculations. Each vertex appears in the S-representation, even if it has no neighbors.
vertices edges to ugraph(+Vertices, +Edges, -Graph)
Given a graph with a set of Vertices and a set of Edges, Graph must unify with the correspond-
ing S-representation. Note that vertices without edges will appear in Vertices but not in Edges.
Moreover, it is sufﬁcient for a vertex to appear in Edges.
?- vertices_edges_to_ugraph([],[1-3,2-4,4-5,1-5], L).
L = [1-[3,5], 2-[4], 3-[], 4-[5], 5-[]]
In this case all vertices are deﬁned implicitly. The next example shows three unconnected
vertices:
SWI-Prolog 6.6 Reference Manual

A.30. LIBRARY(UGRAPHS): UNWEIGHTED GRAPHS
403
?- vertices_edges_to_ugraph([6,7,8],[1-3,2-4,4-5,1-5], L).
L = [1-[3,5], 2-[4], 3-[], 4-[5], 5-[], 6-[], 7-[], 8-[]] ?
vertices(+Graph, -Vertices)
Unify Vertices with all vertices appearing in Graph. Example:
?- vertices([1-[3,5],2-[4],3-[],4-[5],5-[]], L).
L = [1, 2, 3, 4, 5]
edges(+Graph, -Edges)
Unify Edges with all edges appearing in Graph. Example:
?- edges([1-[3,5],2-[4],3-[],4-[5],5-[]], L).
L = [1-3, 1-5, 2-4, 4-5]
add vertices(+Graph, +Vertices, -NewGraph)
Unify NewGraph with a new graph obtained by adding the list of Vertices to Graph. Example:
?- add_vertices([1-[3,5],2-[]], [0,1,2,9], NG).
NG = [0-[], 1-[3,5], 2-[], 9-[]]
del vertices(+Graph, +Vertices, -NewGraph)
Unify NewGraph with a new graph obtained by deleting the list of Vertices and all edges that
start from or go to a vertex in Vertices from Graph. Example:
?- del_vertices([2,1],
[1-[3,5],2-[4],3-[],4-[5],
5-[],6-[],7-[2,6],8-[]],
NL).
NL = [3-[],4-[5],5-[],6-[],7-[6],8-[]]
add edges(+Graph, +Edges, -NewGraph)
Unify NewGraph with a new graph obtained by adding the list of Edges to Graph. Example:
?- add_edges([1-[3,5],2-[4],3-[],4-[5],
5-[],6-[],7-[],8-[]],
[1-6,2-3,3-2,5-7,3-2,4-5],
NL).
NL = [1-[3,5,6], 2-[3,4], 3-[2], 4-[5],
5-[7], 6-[], 7-[], 8-[]]
SWI-Prolog 6.6 Reference Manual

404
APPENDIX A. THE SWI-PROLOG LIBRARY
del edges(+Graph, +Edges, -NewGraph)
Unify NewGraph with a new graph obtained by removing the list of Edges from Graph. Notice
that no vertices are deleted. Example:
?- del_edges([1-[3,5],2-[4],3-[],4-[5],5-[],6-[],7-[],8-[]],
[1-6,2-3,3-2,5-7,3-2,4-5,1-3],
NL).
NL = [1-[5],2-[4],3-[],4-[],5-[],6-[],7-[],8-[]]
transpose(+Graph, -NewGraph)
Unify NewGraph with a new graph obtained from Graph by replacing all edges of the form
V1-V2 by edges of the form V2-V1. The cost is O(|V |2). Notice that an undirected graph is
its own transpose. Example:
?- transpose([1-[3,5],2-[4],3-[],4-[5],
5-[],6-[],7-[],8-[]], NL).
NL = [1-[],2-[],3-[1],4-[2],5-[1,4],6-[],7-[],8-[]]
neighbours(+Vertex, +Graph, -Vertices)
Unify Vertices with the list of neighbours of vertex Vertex in Graph. Example:
?- neighbours(4,[1-[3,5],2-[4],3-[],
4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).
NL = [1,2,7,5]
neighbors(+Vertex, +Graph, -Vertices)
American version of neighbours/3.
complement(+Graph, -NewGraph)
Unify NewGraph with the graph complementary to Graph. Example:
?- complement([1-[3,5],2-[4],3-[],
4-[1,2,7,5],5-[],6-[],7-[],8-[]], NL).
NL = [1-[2,4,6,7,8],2-[1,3,5,6,7,8],3-[1,2,4,5,6,7,8],
4-[3,5,6,8],5-[1,2,3,4,6,7,8],6-[1,2,3,4,5,7,8],
7-[1,2,3,4,5,6,8],8-[1,2,3,4,5,6,7]]
compose(+LeftGraph, +RightGraph, -NewGraph)
Compose NewGraph by connecting the drains of LeftGraph to the sources of RightGraph.
Example:
?- compose([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).
L = [1-[4], 2-[1,2,4], 3-[]]
SWI-Prolog 6.6 Reference Manual

A.31. LIBRARY(URL): ANALYSING AND CONSTRUCTING URL
405
ugraph union(+Graph1, +Graph2, -NewGraph)
NewGraph is the union of Graph1 and Graph2. Example:
?- ugraph_union([1-[2],2-[3]],[2-[4],3-[1,2,4]],L).
L = [1-[2], 2-[3,4], 3-[1,2,4]]
top sort(+Graph, -Sort)
Generate the set of nodes Sort as a topological sorting of Graph, if one is possible. A toplogical
sort is possible if the graph is connected and acyclic. In the example we show how topological
sorting works for a linear graph:
?- top_sort([1-[2], 2-[3], 3-[]], L).
L = [1, 2, 3]
top sort(+Graph, -Sort0, -Sort)
Generate the difference list Sort-Sort0 as a topological sorting of Graph, if one is possible.
transitive closure(+Graph, -Closure)
Generate the graph Closure as the transitive closure of Graph. Example:
?- transitive_closure([1-[2,3],2-[4,5],4-[6]],L).
L = [1-[2,3,4,5,6], 2-[4,5,6], 4-[6]]
reachable(+Vertex, +Graph, -Vertices)
Unify Vertices with the set of all vertices in Graph that are reachable from Vertex. Example:
?- reachable(1,[1-[3,5],2-[4],3-[],4-[5],5-[]],V).
V = [1, 3, 5]
A.31
library(url): Analysing and constructing URL
author
- Jan Wielemaker
- Lukas Faulstich
deprecated New code should use library(uri), provided by the clib package.
This library deals with the analysis and construction of a URL, Universal Resource Locator. URL
is the basis for communicating locations of resources (data) on the web. A URL consists of a protocol
identiﬁer (e.g. HTTP, FTP, and a protocol-speciﬁc syntax further deﬁning the location. URLs are
standardized in RFC-1738.
The implementation in this library covers only a small portion of the deﬁned protocols. Though the
initial implementation followed RFC-1738 strictly, the current is more relaxed to deal with frequent
violations of the standard encountered in practical use.
SWI-Prolog 6.6 Reference Manual

406
APPENDIX A. THE SWI-PROLOG LIBRARY
global url(+URL, +Base, -Global)
[det]
Translate a possibly relative URL into an absolute one.
Errors syntax_error(illegal_url) if URL is not legal.
is absolute url(+URL)
True if URL is an absolute URL. That is, a URL that starts with a protocol identiﬁer.
http location(?Parts, ?Location)
Construct or analyze an HTTP location. This is similar to parse url/2, but only deals with
the location part of an HTTP URL. That is, the path, search and fragment speciﬁers. In the
HTTP protocol, the ﬁrst line of a message is
<Action> <Location> HTTP/<version>
Arguments
Location
Atom or list of character codes.
parse url(+URL, -Attributes)
[det]
Construct or analyse a URL. URL is an atom holding a URL or a variable. Attributes is a list of
components. Each component is of the format Name(Value). Deﬁned components are:
protocol(Protocol)
The used protocol. This is, after the optional url:, an identiﬁer separated from the
remainder of the URL using :. parse url/2 assumes the http protocol if no protocol
is speciﬁed and the URL can be parsed as a valid HTTP url. In addition to the RFC-1738
speciﬁed protocols, the file protocol is supported as well.
host(Host)
Host-name or IP-address on which the resource is located. Supported by all network-based
protocols.
port(Port)
Integer port-number to access on the \arg{Host}. This only appears if the port is explic-
itly speciﬁed in the URL. Implicit default ports (e.g., 80 for HTTP) do not appear in the
part-list.
path(Path)
(File-) path addressed by the URL. This is supported for the ftp, http and file
protocols. If no path appears, the library generates the path /.
search(ListOfNameValue)
Search-speciﬁcation of HTTP URL. This is the part after the ?, normally used to transfer
data from HTML forms that use the GET protocol. In the URL it consists of a www-form-
encoded list of Name=Value pairs. This is mapped to a list of Prolog Name=Value terms
with decoded names and values.
fragment(Fragment)
Fragment speciﬁcation of HTTP URL. This is the part after the # character.
The example below illustrates all of this for an HTTP URL.
SWI-Prolog 6.6 Reference Manual

A.31. LIBRARY(URL): ANALYSING AND CONSTRUCTING URL
407
?- parse_url(’http://www.xyz.org/hello?msg=Hello+World%21#x’,
P).
P = [ protocol(http),
host(’www.xyz.org’),
fragment(x),
search([ msg = ’Hello World!’
]),
path(’/hello’)
]
By instantiating the parts-list this predicate can be used to create a URL.
parse url(+URL, +BaseURL, -Attributes)
[det]
Similar to parse url/2 for relative URLs. If URL is relative, it is resolved using the absolute
URL BaseURL.
www form encode(+Value, -XWWWFormEncoded)
[det]
www form encode(-Value, +XWWWFormEncoded)
[det]
En/decode to/from application/x-www-form-encoded. Encoding encodes all characters except
RFC 3986 unreserved (ASCII alnum (see code type/2)), and one of ”-. ” using percent
encoding.
Newline is mapped to %OD%OA. When decoding, newlines appear as a single
newline (10) character.
Note that a space is encoded as %20 instead of +. Decoding decodes both to a space.
deprecated Use uri encoded/3 for new code.
set url encoding(?Old, +New)
[semidet]
Query and set the encoding for URLs. The default is utf8. The only other deﬁned value is
iso_latin_1.
To be done Having a global ﬂag is highly inconvenient, but a work-around for old sites using ISO
Latin 1 encoding.
url iri(+Encoded, -Decoded)
[det]
url iri(-Encoded, +Decoded)
[det]
Convert between a URL, encoding in US-ASCII and an IRI. An IRI is a fully expanded
Unicode string. Unicode strings are ﬁrst encoded into UTF-8, after which %-encoding takes
place.
parse url search(?Spec, ?Fields:list(Name=Value))
[det]
Construct or analyze an HTTP search speciﬁcation. This deals with form data using the MIME-
type application/x-www-form-urlencoded as used in HTTP GET requests.
ﬁle name to url(+File, -URL)
[det]
ﬁle name to url(-File, +URL)
[semidet]
Translate between a ﬁlename and a ﬁle:// URL.
To be done Current implementation does not deal with paths that need special encoding.
SWI-Prolog 6.6 Reference Manual

408
APPENDIX A. THE SWI-PROLOG LIBRARY
A.32
library(varnumbers): Utilities for numbered terms
See also numbervars/4, =@=/2 (variant/2).
Compatibility This library was introduced by Quintus and available in many related implementations, al-
though not with exactly the same set of predicates.
This library provides the inverse functionality of the built-in numbervars/3. Note that this
library suffers from the known issues that ’$VAR’(X) is a normal Prolog term and, -unlike the built-in
numbervars-, the inverse predicates do not process cyclic terms. The following predicate is true for
any acyclic term that contains no ’$VAR’(X), integer(X) terms and no constraint variables:
always_true(X) :-
copy_term(X, X2),
numbervars(X),
varnumbers(X, Copy),
Copy =@= X2.
numbervars(+Term)
[det]
Number variables in Term using $VAR(N). Equivalent to numbervars(Term, 0, _).
See also numbervars/3, numbervars/4
varnumbers(+Term, -Copy)
[det]
Inverse of numbervars/1. Equivalent to varnumbers(Term, 0, Copy).
varnumbers(+Term, +Start, -Copy)
[det]
Inverse of numbervars/3. True when Copy is a copy of Term with all variables numbered
>= Start consistently replaced by fresh variables. Variables in Term are shared with Copy
rather than replaced by fresh variables.
Errors domain_error(acyclic_term, Term) if Term is cyclic.
Compatibility Quintus, SICStus. Not in YAP version of this library
max var number(+Term, +Start, -Max)
[det]
True when Max is the max of Start and the highest numbered $VAR(N) term.
author Vitor Santos Costa
Compatibility YAP
SWI-Prolog 6.6 Reference Manual

Hackers corner
B
This appendix describes a number of predicates which enable the Prolog user to inspect the Prolog
environment and manipulate (or even redeﬁne) the debugger. They can be used as entry points for
experiments with debugging tools for Prolog. The predicates described here should be handled with
some care as it is easy to corrupt the consistency of the Prolog system by misusing them.
B.1
Examining the Environment Stack
prolog current frame(-Frame)
[det]
Unify Frame with an integer providing a reference to the parent of the current local stack
frame.
A pointer to the current local frame cannot be provided as the predicate succeeds
deterministically and therefore its frame is destroyed immediately after succeeding.
prolog current choice(-Choice)
[semidet]
Unify Choice with an integer provided a reference to the last choice point. Fails if the current
environment has no choice points. See also prolog choice attribute/3.
prolog frame attribute(+Frame, +Key, :Value)
Obtain information about the local stack frame Frame. Frame is a frame reference as ob-
tained through prolog current frame/1, prolog trace interception/4 or this
predicate. The key values are described below.
alternative
Value is uniﬁed with an integer reference to the local stack frame in which execution is
resumed if the goal associated with Frame fails. Fails if the frame has no alternative
frame.
has alternatives
Value is uniﬁed with true if Frame still is a candidate for backtracking; false other-
wise.
goal
Value is uniﬁed with the goal associated with Frame. If the deﬁnition module of the
active predicate is not the calling context, the goal is represented as ⟨module⟩:⟨goal⟩. Do
not instantiate variables in this goal unless you know what you are doing! Note that the
returned term may contain references to the frame and should be discarded before the
frame terminates.1
1The returned term is actually an illegal Prolog term that may hold references from the global to the local stack to
preserve the variable names.
SWI-Prolog 6.6 Reference Manual

410
APPENDIX B. HACKERS CORNER
parent goal
If Value is instantiated to a callable term, ﬁnd a frame executing the predicate described
by Value and unify the arguments of Value to the goal arguments associated with the
frame. This is intended to check the current execution context. The user must ensure the
checked parent goal is not removed from the stack due to last-call optimisation and be
aware of the slow operation on deeply nested calls.
predicate indicator
Similar to goal, but only returning the [⟨module⟩:]⟨name⟩/⟨arity⟩term describing the
term, not the actual arguments. It avoids creating an illegal term as goal and is used by
the library prolog stack.
clause
Value is uniﬁed with a reference to the currently running clause. Fails if the current
goal is associated with a foreign (C) deﬁned predicate. See also nth clause/3 and
clause property/2.
level
Value is uniﬁed with the recursion level of Frame. The top level frame is at level ‘0’.
parent
Value is uniﬁed with an integer reference to the parent local stack frame of Frame. Fails
if Frame is the top frame.
context module
Value is uniﬁed with the name of the context module of the environment.
top
Value is uniﬁed with true if Frame is the top Prolog goal from a recursive call back
from the foreign language; false otherwise.
hidden
Value is uniﬁed with true if the frame is hidden from the user, either because a parent
has the hide-childs attribute (all system predicates), or the system has no trace-me
attribute.
skipped
Value is true if this frame was skipped in the debugger.
pc
Value is uniﬁed with the program pointer saved on behalf of the parent goal if the parent
goal is not owned by a foreign predicate or belongs to a compound meta-call (e.g.,
call((a,b))).
argument(N)
Value is uniﬁed with the N-th slot of the frame. Argument 1 is the ﬁrst argument of the
goal. Arguments above the arity refer to local variables. Fails silently if N is out of range.
prolog choice attribute(+ChoicePoint, +Key, -Value)
Extract attributes of a choice point.
ChoicePoint is a reference to a choice point as
passed to prolog trace interception/4 on the 3rd argument or obtained using
prolog current choice/1. Key speciﬁes the requested information:
parent
Requests a reference to the ﬁrst older choice point.
SWI-Prolog 6.6 Reference Manual

B.2. ANCESTRAL CUTS
411
frame
Requests a reference to the frame to which the choice point refers.
type
Requests the type.
Deﬁned values are clause (the goal has alternative clauses),
foreign (non-deterministic foreign predicate), jump (clause internal choice point),
top (ﬁrst dummy choice point), catch (catch/3 to allow for undo), debug (help the
debugger), or none (has been deleted).
This predicate is used for the graphical debugger to show the choice point stack.
deterministic(-Boolean)
Uniﬁes its argument with true if no choice point exists that is more recent than the entry of the
clause in which it appears. There are few realistic situations for using this predicate. It is used
by the prolog/0 top level to check whether Prolog should prompt the user for alternatives.
Similar results can be achieved in a more portable fashion using call cleanup/2.
B.2
Ancestral cuts
prolog cut to(+Choice)
Prunes
all
choice
points
created
since
Choice.
Can
be
used
together
with
prolog current choice/1 to implement ancestral cuts.
This predicate is in the
hackers corner because it should not be used in normal Prolog code. It may be used to create
new high level control structures, particularly for compatibility purposes.
B.3
Syntax extensions
Prolog is commonly used to deﬁne domain speciﬁc languages (DSL) as well as to interact with ex-
ternal languages that have a concrete syntax, such as HTML, JavaScript or SQL. Standard Prolog
provides operators (see section 4.25) for extending its syntax. Unfortunately, Prolog’s syntax is rather
peculiar and operators do not allow for commonly seen syntactical patterns such as array subscripting,
expressing attributes, scope or a body using curly brackets, distinguishing identiﬁers or strings from
‘functions’, etc.
The syntactic extensions described in section B.3.1 provide additional constructs to extend the
syntax. These extensions allow for coping with a large part of the curly bracket languages, which
allows for deﬁning DSLs that are more natural to use, in particular for people that are less familiar
with Prolog.
For some external languages it can be sufﬁcient to support the simple data model using a com-
pletely different Prolog concrete syntax. This is for example the case for HTML, as implemented by
the library http/html write. With the extensions of section B.3.1, this also becomes true for the
statistics language R, which was one of the motivations for these extensions. These extensions are
motivated in [Wielemaker & Angelopoulos, ].
Other languages, such as full JavaScript, are too different from Prolog for dealing with them using
(extended) Prolog operator. While most of the JavaScript syntax can be covered with the extended
notion of operators, the produced Prolog term does not unambiguishly describe the JavaScript abstract
syntax. For example, both ++a and a++ are, with the appropriate operator declarations, valid Prolog
syntax. However, they both map to the term ++(a) and thus a Prolog JavaScript serialization does not
SWI-Prolog 6.6 Reference Manual

412
APPENDIX B. HACKERS CORNER
know which these two forms the generate.2 More classical, "string" produces the same Prolog
term as [115,116,114,105,110,103].
An
alternative
to
syntax
extension
using
(extended)
operators
are
quasi
quotations
[Mainland, 2007]. Quasi quotations embed external languages in a Prolog term using their native
syntax. The language is speciﬁed in the quotation. Parsing such a term causes Prolog to call the
associated parser which creates an abstract syntax tree that unambiguosly represents the code frag-
ment and which can be processed in Prolog or serialized for external processing. Quasi quotations are
realised by library quasi quotations, which is documented in section A.23.
B.3.1
Block operators
Introducing curly bracket, array subscripting and empty argument lists is achieved using block opera-
tors.3 The atoms [], {} and () may be declared as an operator, which has the following effect:
[ ]
This operator is typically declared as a low-priority yf postﬁx operator, which allows for
array[index] notation. This syntax produces a term []([index],array).
{ }
This
operator
is
typically
declared
as
a
low-priority
xf
postﬁx
operator,
which
allows
for
head(arg) { body }
notation.
This
syntax
produces
a
term
{}({body},head(arg)).
( )
This operator can only meaningfully be declared as a low-priority xf postﬁx operator, which
allows for name() notation. This syntax produces a term ’()’(name). This transformation
only applies if the opening bracket immediately follows the functor name, i.e., following the
same rules as for constructing a compound term.
Below is an example that illustrates the representation of a typical ‘curly bracket language’ in
Prolog.
?- op(1, xf, ’()’).
?- op(100, xf, {}).
?- op(100, yf, []).
?- op(1100, yf, ;).
?- displayq(func(arg)
{ a[10] = 5;
update();
}).
{}({}(;(=([](’.’(10,[]),a),5),;(’()’(update)))),func(arg))
2This example comes from Richard O’Keefe.
3Introducing block operators was proposed by Jose Morales. It was discussed in the Prolog standardization mailing
list, but there were too many conﬂicts with existing extensions (ECLiPSe and B-Prolog) and doubt their need to reach an
agreement. Increasing need to get to some solution resulted in what is documented in this section.
SWI-Prolog 6.6 Reference Manual

B.4. INTERCEPTING THE TRACER
413
B.4
Intercepting the Tracer
prolog trace interception(+Port, +Frame, +Choice, -Action)
Dynamic predicate, normally not deﬁned. This predicate is called from the SWI-Prolog debug-
ger just before it would show a port. If this predicate succeeds, the debugger assumes that the
trace action has been taken care of and continues execution as described by Action. Otherwise
the normal Prolog debugger actions are performed.
Port denotes the reason to activate the tracer (‘port’ in the 4/5-port, but with some additions):
call
Normal entry through the call port of the 4-port debugger.
redo(PC)
Normal entry through the redo port of the 4-port debugger. The redo port signals resum-
ing a predicate to generate alternative solutions. If PC is 0 (zero), clause indexing has
found another clause that will be tried next. Otherwise, PC is the program counter in the
current clause where execution continues. This implies we are dealing with an in-clause
choice point left by, e.g., ;/2. Note that non-determinism in foreign predicates are also
handled using an in-clause choice point.
unify
The unify port represents the neck instruction, signalling the end of the head-matching
process. This port is normally invisible. See leash/1 and visible/1.
exit
The exit port signals the goal is proved. It is possible for the goal to have alternatives. See
prolog frame attribute/3 to examine the goal stack.
fail
The fail port signals ﬁnal failure of the goal.
exception(Except)
An exception is raised and still pending. This port is activated on each parent frame of the
frame generating the exception until the exception is caught or the user restarts normal
computation using retry. Except is the pending exception term.
break(PC)
A break instruction is executed. PC is program counter. This port is used by the graphi-
cal debugger.
cut call(PC)
A cut is encountered at PC. This port is used by the graphical debugger to visualise the
effect of the cut.
cut exit(PC)
A cut has been executed. See cut call(PC) for more information.
Frame is a reference to the current local stack frame, which can be examined using
prolog frame attribute/3. Choice is a reference to the last choice point and can be
examined using prolog choice attribute/3. Action must be uniﬁed with a term that
speciﬁes how execution must continue. The following actions are deﬁned:
abort
Abort execution. See abort/0.
SWI-Prolog 6.6 Reference Manual

414
APPENDIX B. HACKERS CORNER
continue
Continue (i.e., creep in the command line debugger).
fail
Make the current goal fail.
ignore
Step over the current goal without executing it.
nodebug
Continue execution in normal nodebugging mode. See nodebug/0.
retry
Retry the current frame.
retry(Frame)
Retry the given frame. This must be a parent of the current frame.
skip
Skip over the current goal (i.e., skip in the command line debugger).
Together with the predicates described in section 4.38 and the other predicates of this chapter,
this predicate enables the Prolog user to deﬁne a complete new debugger in Prolog. Besides
this, it enables the Prolog programmer to monitor the execution of a program. The example
below records all goals trapped by the tracer in the database.
prolog_trace_interception(Port, Frame, _PC, continue) :-
prolog_frame_attribute(Frame, goal, Goal),
prolog_frame_attribute(Frame, level, Level),
recordz(trace, trace(Port, Level, Goal)).
To trace the execution of ‘go’ this way the following query should be given:
?- trace, go, notrace.
prolog skip frame(-Frame)
Indicate Frame as a skipped frame and set the ‘skip level’ (see prolog skip level/2 to
the recursion depth of Frame. The effect of the skipped ﬂag is that a redo on a child of this
frame is handled differently. First, a redo trace is called for the child, where the skip level is
set to redo in skip. Next, the skip level is set to skip level of the skipped frame.
prolog skip level(-Old, +New)
Unify Old with the old value of ‘skip level’ and then set this level according to New. New
is an integer, the atom very deep (meaning don’t skip) or the atom skip in redo
(see prolog skip frame/1).
The ‘skip level’ is a setting of each Prolog thread that
disables the debugger on all recursion levels deeper than the level of the variable. See also
prolog skip frame/1.
SWI-Prolog 6.6 Reference Manual

B.5. BREAKPOINT AND WATCHPOINT HANDLING
415
B.5
Breakpoint and watchpoint handling
SWI-Prolog
support
breakpoints.
Breakpoints
can
be
manipulated
with
the
library
prolog breakpoints.
Setting a breakpoint replaces a virtual machine instruction with the
D BREAK instruction. If the virtual machine executes a D BREAK, it performs a callback to decide on
the action to perform. This section describes this callback, called prolog:break hook/6.
prolog:break hook(+Clause, +PC, +FR, +BFR, +Expression, -Action)
[hook,semidet]
Experimental This hook is called if the virtual machine executes a D BREAK, set using
set breakpoint/4. Clause and PC identify the breakpoint. FR and BFR provide the
environment frame and current choicepoint. Expression identiﬁes the action that is interrupted,
and is one of the following:
call(Goal)
The instruction will call Goal. This is generated for nearly all instructions. Note that
Goal is semantically equivalent to the compiled body term, but might differ syntactically.
This is notably the case when artithmetic expressions are compiled in optimized mode
(see optimise). In particular, the arguments of arithmetic expressions have already
been evaluated. Thus, A is 3*B, where B equals 3 results in a term call(A is 9) if
the clause was compiled with optimization enabled.
!
The instruction will call the cut. Because the semantics of metacalling the cut differs
from executing the cut in its original context we do not wrap the cut in call/1.
:-
The breakpoint is on the neck instruction, i.e., after performing the head uniﬁcations.
exit
The breakpoint is on the exit instruction, i.e., at the end of the clause. Note that the exit
instruction may not be reached due to last-call optimisation.
unify exit
The breakpoint is on the completion of an in-lined uniﬁcation while the system is not
in debug mode.
If the system is in debug mode, inlined uniﬁcation is returned as
call(Var=Term).4
If prolog:break hook/6 succeeds, it must unify Action with a value that describes how execution
must continue. Possible values for Action are:
continue
Just continue as if no breakpoint was present.
debug
Continue in debug mode. See debug/0.
trace
Continue in trace mode. See trace/0.
4This hack will disappear if we ﬁnd a good solution for applying D BREAK to inlined uniﬁcation. Only option might
be to place the break on both the uniﬁcation start and end instructions.
SWI-Prolog 6.6 Reference Manual

416
APPENDIX B. HACKERS CORNER
call(Goal)
Execute Goal instead of the goal that would be executed. Goal is executed as call/1,
preserving (non-)determinism and exceptions.
If this hook throws an exception, the exception is propagated normally. If this hook is not
deﬁned or fails, the default action is executed. This implies that, if the thread is in debug mode,
the tracer will be enabled (trace) and otherwise the breakpoint is ignored (continue).
This hook allows for injecting various debugging scenarios into the executable without recom-
piling. The hook can access variables of the calling context using the frame inspection predi-
cates. Here are some examples.
• Create conditional breakpoints by imposing conditions before deciding the return trace.
• Watch variables at a speciﬁc point in the execution. Note that binding of these variables
can be monitored using attributed variables, see section 6.1.
• Dynamically add assertions on variables using assertion/1.
• Wrap the Goal into a meta-call that traces progress of the Goal.
B.6
Adding context to errors: prolog exception hook
The hook prolog exception hook/4 has been introduced in SWI-Prolog 5.6.5 to provide ded-
icated exception handling facilities for application frameworks, for example non-interactive server
applications that wish to provide extensive context for exceptions for ofﬂine debugging.
prolog exception hook(+ExceptionIn, -ExceptionOut, +Frame, +CatcherFrame)
This hook predicate, if deﬁned in the module user, is between raising an exception and
handling it. It is intended to allow a program adding additional context to an exception to
simplify diagnosing the problem. ExceptionIn is the exception term as raised by throw/1 or
one of the built-in predicates. The output argument ExceptionOut describes the exception that
is actually raised. Frame is the innermost frame. See prolog frame attribute/3 and
the library prolog stack for getting information from this. CatcherFrame is a reference to
the frame calling the matching catch/3 or none if the exception is not caught.
The hook is run in ‘nodebug’ mode. If it succeeds, ExceptionOut is considered the current
exception. If it fails, ExceptionIn is used for further processing. The hook is never called
recursively. The hook is not allowed to modify ExceptionOut in such a way that it no longer
uniﬁes with the catching frame.
Typically,
prolog exception hook/4
is
used
to
ﬁll
the
second
argument
of
error(Formal, Context) exceptions.
Formal is deﬁned by the ISO standard, while SWI-
Prolog deﬁnes Context as a term context(Location, Message). Location is bound to a term
⟨name⟩/⟨arity⟩by the kernel. This hook can be used to add more information on the calling
context, such as a full stack trace.
Applications that use exceptions as part of normal processing must do a quick test of the envi-
ronment before starting expensive gathering information on the state of the program.
The hook can call trace/0 to enter trace mode immediately. For example, imagine an appli-
cation performing an unwanted division by zero while all other errors are expected and handled.
SWI-Prolog 6.6 Reference Manual

B.7. HOOKS USING THE EXCEPTION PREDICATE
417
We can force the debugger using the hook deﬁnition below. Run the program in debug mode
(see debug/0) to preserve as much as possible of the error context.
user:prolog_exception_hook(
error(evaluation_error(zero_divisor), _),
_, _, _) :-
trace, fail.
B.7
Hooks using the exception predicate
This section describes the predicate exception/3, which can be deﬁned by the user in the module
user as a multiﬁle predicate. Unlike the name suggests, this is actually a hook predicate that has no
relation to Prolog exceptions as deﬁned by the ISO predicates catch/3 and throw/1.
The predicate exception/3 is called by the kernel on a couple of events, allowing the user to
‘ﬁx’ errors just-in-time. The mechanism allows for lazy creation of objects such as predicates.
exception(+Exception, +Context, -Action)
Dynamic predicate, normally not deﬁned. Called by the Prolog system on run-time exceptions
that can be repaired ‘just-in-time’. The values for Exception are described below. See also
catch/3 and throw/1.
If this hook predicate succeeds it must instantiate the Action argument to the atom fail to
make the operation fail silently, retry to tell Prolog to retry the operation or error to make
the system generate an exception. The action retry only makes sense if this hook modiﬁed
the environment such that the operation can now succeed without error.
undeﬁned predicate
Context is instantiated to a predicate indicator ([module]:⟨name⟩/⟨arity⟩). If the predicate
fails, Prolog will generate an existence error exception.
The hook is intended
to implement alternatives to the built-in autoloader, such as autoloading code from a
database. Do not use this hook to suppress existence errors on predicates. See also
unknown and section 2.13.
undeﬁned global variable
Context is instantiated to the name of the missing global variable. The hook must call
nb setval/2 or b setval/2 before returning with the action retry.
B.8
Hooks for integrating libraries
Some libraries realise an entirely new programming paradigm on top of Prolog. An example is XPCE
which adds an object system to Prolog as well as an extensive set of graphical primitives. SWI-Prolog
provides several hooks to improve the integration of such libraries. See also section 4.5 for editing
hooks and section 4.10.3 for hooking into the message system.
prolog list goal(:Goal)
Hook, normally not deﬁned. This hook is called by the ’L’ command of the tracer in the
module user to list the currently called predicate. This hook may be deﬁned to list only
SWI-Prolog 6.6 Reference Manual

418
APPENDIX B. HACKERS CORNER
relevant clauses of the indicated Goal and/or show the actual source code in an editor. See also
portray/1 and multifile/1.
prolog:debug control hook(:Action)
Hook for the debugger control predicates that allows the creator of more high-level program-
ming languages to use the common front-end predicates to control the debugger. For example,
XPCE uses these hooks to allow for spying methods rather than predicates. Action is one of:
spy(Spec)
Hook in spy/1. If the hook succeeds spy/1 takes no further action.
nospy(Spec)
Hook in nospy/1. If the hook succeeds nospy/1 takes no further action. If spy/1 is
hooked, it is advised to place a complementary hook for nospy/1.
nospyall
Hook in nospyall/0. Should remove all spy points. This hook is called in a failure-
driven loop.
debugging
Hook in debugging/0. It can be used in two ways. It can report the status of the
additional debug points controlled by the above hooks and fail to let the system report the
others, or it succeeds, overruling the entire behaviour of debugging/0.
prolog:help hook(+Action)
Hook into help/0 and help/1. If the hook succeeds, the built-in actions are not executed.
For example, ?- help(picture). is caught by the XPCE help hook to give help on the
class picture. Deﬁned actions are:
help
User entered plain help/0 to give default help. The default performs help(help/1),
giving help on help.
help(What)
Hook in help/1 on the topic What.
apropos(What)
Hook in apropos/1 on the topic What.
B.9
Hooks for loading ﬁles
All loading of source ﬁles is achieved by load files/2. The hook prolog load file/2 can
be used to load Prolog code from non-ﬁles or even load entirely different information, such as foreign
ﬁles.
prolog load ﬁle(+Spec, +Options)
Load a single object. If this call succeeds, load files/2 assumes the action has been taken
care of. This hook is only called if Options does not contain the stream(Input) option. The
hook must be deﬁned in the module user.
This can be used to load from unusual places. For example, library http/http load loads
Prolog directly from an HTTP server. It can also be used to load source in unusual forms, such
SWI-Prolog 6.6 Reference Manual

B.10. READLINE INTERACTION
419
as loading compressed ﬁles without decompressing them ﬁrst. There is currently no example of
that.
prolog:comment hook(+Comments, +Pos, +Term)
This hook allows for processing comments encountered by the compiler. If this hook is deﬁned,
the compiler calls read term/2 with the option comments(Comments).
If the list of
comments returned by read term/2 is not empty it calls this comment hook with the
following arguments.
• Comments is the non-empty list of comments. Each comment is a pair Position-String,
where String is a string object (see section 4.24) that contains the comment including
delimiters. Consecutive line comments are returned as a single comment.
• Pos is a stream-position term that describes the starting position of Term
• Term is the term read.
This hook is exploited by the documentation system. See stream position data/3. See
also read term/3.
B.10
Readline Interaction
The following predicates are available if SWI-Prolog is linked to the GNU readline library. This is by
default the case on non-Windows installations and indicated by the Prolog ﬂag readline.5 See also
readline(3).
rl read init ﬁle(+File)
Read a readline initialisation ﬁle. Readline by default reads ˜/.inputrc. This predicate
may be used to read alternative readline initialisation ﬁles.
rl add history(+Line)
Add a line to the Control-P/Control-N history system of the readline library.
rl write history(+FileName)
Write current history to FileName. Can be used from at halt/1 to save the history.
rl read history(+FileName)
Read history from FileName, appending to the current history.
5swipl-win.exe uses its own history system and does not support these predicates.
SWI-Prolog 6.6 Reference Manual

Compatibility with other
Prolog dialects
C
This chapter explains issues for writing portable Prolog programs. It was started after discussion with
Vitor Santos Costa, the leading developer of YAP Prolog1 YAP and SWI-Prolog have expressed the
ambition to enhance the portability beyond the trivial Prolog examples, including complex libraries
involving foreign code.
Although it is our aim to enhance compatibility, we are still faced with many incompatibilities
between the dialects. As a ﬁrst step both YAP and SWI will provide some instruments that help
developing portable code. A ﬁrst release of these tools appeared in SWI-Prolog 5.6.43. Some of the
facilities are implemented in the base system, others in the library dialect.pl.
• The Prolog ﬂag dialect is an unambiguous and fast way to ﬁnd out which Prolog dialect
executes your program. It has the value swi for SWI-Prolog and yap on YAP.
• The Prolog ﬂag version data is bound to a term swi(Major, Minor, Patch, Extra)
• Conditional compilation using :- if(Condition) ... :- endif is supported. See sec-
tion 4.3.1.
• The predicate expects dialect/1 allows for specifying for which Prolog system the code
was written.
• The predicates exists source/1 and source exports/2 can be used to query the li-
brary content. The require/1 directive can be used to get access to predicates without know-
ing their location.
• The module predicates use module/1, use module/2 have been extended with a notion
for ‘import-except’ and ‘import-as’. This is particularly useful together with reexport/1
and reexport/2 to compose modules from other modules and mapping names.
• Foreign
code
can
expect
SWI PROLOG
when
compiled
for
SWI-Prolog
and
YAP PROLOG
when compiled on YAP.
:- expects dialect(+Dialect)
This directive states that the code following the directive is written for the given Prolog Dialect.
See also dialect. The declaration holds until the end of the ﬁle in which it appears. The
current dialect is available using prolog load context/2.
The exact behaviour of this predicate is still subject to discussion.
Of course, if Dialect
matches the running dialect the directive has no effect. Otherwise we check for the existence of
library(dialect/Dialect) and load it if the ﬁle is found. Currently, this ﬁle has this function-
ality:
1http://yap.sourceforge.net/
SWI-Prolog 6.6 Reference Manual

C.1. SOME CONSIDERATIONS FOR WRITING PORTABLE CODE
421
• Deﬁne system predicates of the requested dialect we do not have.
• Apply goal expansion/2 rules that map conﬂicting predicates to versions emulating
the requested dialect. These expansion rules reside in the dialect compatibility module,
but are applied if prolog load context(dialect, Dialect) is active.
• Modify the search path for library directories, putting libraries compatible with the target
dialect before the native libraries.
• Setup support for the default ﬁlename extension of the dialect.
exists source(+Spec)
Is true if Spec exists as a Prolog source. Spec uses the same conventions as load files/2.
Fails without error if Spec cannot be found.
source exports(+Spec, +Export)
Is true if source Spec exports Export, a predicate indicator. Fails without error otherwise.
C.1
Some considerations for writing portable code
The traditional way to write portable code is to deﬁne custom predicates for all potentially non-
portable code and deﬁne these separately for all Prolog dialects one wishes to support. Here are some
considerations.
• Probably the best reason for this is that it allows to deﬁne minimal semantics required by the
application for the portability predicates. Such functionality can often be mapped efﬁciently to
the target dialect. Contrary, if code was written for dialect X, the deﬁned semantics are those
of dialect X. Emulating all extreme cases and full error handling compatibility may be tedious
and result in a much slower implementation that needed. Take for example call cleanup/2.
The SICStus deﬁnition is fundamentally different from the SWI deﬁnition, but 99% of the appli-
cations just want to make calls like below to guarantee StreamIn is closed, even if process/1
misbehaves.
call_cleanup(process(StreamIn), close(In))
• As a drawback, the code becomes full of my call cleanup, etc. and every potential portability
conﬂict needs to be abstracted. It is hard for people who have to maintain such code later to
grasp the exact semantics of the my * predicates and applications that combine multiple libraries
using this compatibility approach are likely to encounter conﬂicts between the portability layers.
A good start is not to use my *, but a preﬁx derived from the library or application name or
names that explain the intended semantics more precisely.
• Another problem is that most code is initially not written with portability in mind. Instead,
ports are requested by users or arise from the desire to switch Prolog dialect. Typically, we
want to achieve compatibility with the new Prolog dialect with minimal changes, often keeping
compatibility with the original dialect(s). This problem is well known from the C/Unix world
and we advise anyone to study the philosophy of GNU autoconf, from which we will illustrate
some highlights below.
SWI-Prolog 6.6 Reference Manual

422
APPENDIX C. COMPATIBILITY WITH OTHER PROLOG DIALECTS
The GNU autoconf suite, known to most people as configure, was an answer to the frustrating
life of Unix/C programmers when Unix dialects were about as abundant and poorly standardised as
Prolog dialects today. Writing a portable C program can only be achieved using cpp, the C preproces-
sor. The C preprocessor performs two tasks: macro expansion and conditional compilation. Prolog
realises macro expansion through term expansion/2 and goal expansion/2. Conditional
compilation is achieved using :- if(Condition) as explained in section 4.3.1. The situation
appears similar.
The important lesson learned from GNU autoconf is that the last resort for conditional compilation
to achieve portability is to switch on the platform or dialect. Instead, GNU autoconf allows you to
write tests for speciﬁc properties of the platform. Most of these are whether or not some function or
ﬁle is available. Then there are some standard tests for difﬁcult-to-write-portable situations and ﬁnally
there is a framework that allows you to write arbitrary C programs and check whether they can be
compiled and/or whether they show the intended behaviour. Using a separate configure program
is needed in C, as you cannot perform C compilation step or run C programs from the C preprocessor.
In most Prolog environments we do not need this distinction as the compiler is integrated into the
runtime environment and Prolog has excellent reﬂexion capabilities.
We must learn from the distinction to test for features instead of platform (dialect), as this makes
the platform-speciﬁc code robust for future changes of the dialect. Suppose we need compare/3 as
deﬁned in this manual. The compare/3 predicate is not part of the ISO standard, but many systems
support it and it is not unlikely it will become ISO standard or the intended dialect will start supporting
it. GNU autoconf strongly advises to test for the availability:
:- if(\+current_predicate(_, compare(_,_,_))).
compare(<, Term1, Term2) :-
Term1 @< Term2, !.
compare(>, Term1, Term2) :-
Term1 @> Term2, !.
compare(=, Term1, Term2) :-
Term1 == Term2.
:- endif.
This code is much more robust against changes to the intended dialect and, possibly at least as impor-
tant, will provide compatibility with dialects you didn’t even consider porting to right now.
In a more challenging case, the target Prolog has compare/3, but the semantics are different.
What to do? One option is to write a my compare/3 and change all occurrences in the code.
Alternatively you can rename calls using goal expansion/2 like below. This construct will not
only deal with Prolog dialects lacking compare/3 as well as those that only implement it for numeric
comparison or have changed the argument order. Of course, writing rock-solid code would require a
complete test-suite, but this example will probably cover all Prolog dialects that allow for conditional
compilation, have core ISO facilities and provide goal expansion/2, the things we claim a Prolog
dialect should have to start writing portable code for it.
:- if(\+catch(compare(<,a,b), _, fail)).
compare_standard_order(<, Term1, Term2) :-
Term1 @< Term2, !.
compare_standard_order(>, Term1, Term2) :-
Term1 @> Term2, !.
SWI-Prolog 6.6 Reference Manual

C.1. SOME CONSIDERATIONS FOR WRITING PORTABLE CODE
423
compare_standard_order(=, Term1, Term2) :-
Term1 == Term2.
goal_expansion(compare(Order, Term1, Term2),
compare_standard_order(Order, Term1, Term2)).
:- endif.
SWI-Prolog 6.6 Reference Manual

Glossary of Terms
D
anonymous [variable]
The variable _ is called the anonymous variable. Multiple occurrences of _ in a single term are
not shared.
arguments
Arguments are terms that appear in a compound term. A1 and a2 are the ﬁrst and second
argument of the term myterm(A1, a2).
arity
Argument count (= number of arguments) of a compound term.
assert
Add a clause to a predicate. Clauses can be added at either end of the clause-list of a predicate.
See asserta/1 and assertz/1.
atom
Textual constant. Used as name for compound terms, to represent constants or text.
backtracking
Search process used by Prolog. If a predicate offers multiple clauses to solve a goal, they are
tried one-by-one until one succeeds. If a subsequent part of the proof is not satisﬁed with the
resulting variable binding, it may ask for an alternative solution (= binding of the variables),
causing Prolog to reject the previously chosen clause and try the next one.
binding [of a variable]
Current value of the variable. See also backtracking and query.
built-in [predicate]
Predicate that is part of the Prolog system. Built-in predicates cannot be redeﬁned by the user,
unless this is overruled using redefine system predicate/1.
body
Part of a clause behind the neck operator (:-).
clause
‘Sentence’ of a Prolog program. A clause consists of a head and body separated by the neck
operator (:-) or it is a fact. For example:
parent(X) :-
father(X, _).
SWI-Prolog 6.6 Reference Manual

425
Expressed as “X is a parent if X is a father of someone”. See also variable and predicate.
compile
Process where a Prolog program is translated to a sequence of instructions. See also interpreted.
SWI-Prolog always compiles your program before executing it.
compound [term]
Also called structure. It consists of a name followed by N arguments, each of which are terms.
N is called the arity of the term.
context module
If a term is referring to a predicate in a module, the context module is used to ﬁnd the target
module. The context module of a goal is the module in which the predicate is deﬁned, unless
this predicate is module transparent, in which case the context module is inherited from the
parent goal. See also module transparent/1 and meta-predicate.
dynamic [predicate]
A dynamic predicate is a predicate to which clauses may be asserted and from which clauses
may be retracted while the program is running. See also update view.
exported [predicate]
A predicate is said to be exported from a module if it appears in the public list. This im-
plies that the predicate can be imported into another module to make it visible there. See also
use module/[1,2].
fact
Clause without a body. This is called a fact because, interpreted as logic, there is no condition
to be satisﬁed. The example below states john is a person.
person(john).
fail
A goal is said to haved failed if it could not be proven.
ﬂoat
Computer’s crippled representation of a real number. Represented as ‘IEEE double’.
foreign
Computer code expressed in languages other than Prolog. SWI-Prolog can only cooperate
directly with the C and C++ computer languages.
functor
Combination of name and arity of a compound term. The term foo(a, b, c) is said to be a term
belonging to the functor foo/3. foo/0 is used to refer to the atom foo.
goal
Question stated to the Prolog engine. A goal is either an atom or a compound term. A goal
either succeeds, in which case the variables in the compound terms have a binding, or it fails if
Prolog fails to prove it.
SWI-Prolog 6.6 Reference Manual

426
APPENDIX D. GLOSSARY OF TERMS
hashing
Indexing technique used for quick lookup.
head
Part of a clause before the neck operator (:-). This is an atom or compound term.
imported [predicate]
A predicate is said to be imported into a module if it is deﬁned in another module and made
available in this module. See also chapter 5.
indexing
Indexing is a technique used to quickly select candidate clauses of a predicate for a speciﬁc
goal. In most Prolog systems, indexing is done (only) on the ﬁrst argument of the head. If this
argument is instantiated to an atom, integer, ﬂoat or compound term with functor, hashing is
used to quickly select all clauses where the ﬁrst argument may unify with the ﬁrst argument of
the goal. SWI-Prolog supports just-in-time and multi-argument indexing. See section 2.17.
integer
Whole number.
On all implementations of SWI-Prolog integers are at least 64-bit signed
values. When linked to the GNU GMP library, integer arithmetic is unbounded. See also
current prolog flag/2, ﬂags bounded, max integer and min integer.
interpreted
As opposed to compiled, interpreted means the Prolog system attempts to prove a goal by
directly reading the clauses rather than executing instructions from an (abstract) instruction set
that is not or only indirectly related to Prolog.
meta-predicate
A predicate that reasons about other predicates, either by calling them, (re)deﬁning them or
querying properties.
module
Collection of predicates. Each module deﬁnes a name-space for predicates. built-in predicates
are accessible from all modules. Predicates can be published (exported) and imported to make
their deﬁnition available to other modules.
module transparent [predicate]
A predicate that does not change the context module. Sometimes also called a meta-predicate.
multiﬁle [predicate]
Predicate for which the deﬁnition is distributed over multiple source ﬁles. See multifile/1.
neck
Operator (:-) separating head from body in a clause.
operator
Symbol (atom) that may be placed before its operand (preﬁx), after its operand (postﬁx) or
between its two operands (inﬁx).
In Prolog, the expression a+b is exactly the same as the canonical term +(a,b).
SWI-Prolog 6.6 Reference Manual

427
operand
Argument of an operator.
precedence
The priority of an operator.
Operator precedence is used to interpret a+b*c as
+(a, *(b,c)).
predicate
Collection of clauses with the same functor (name/arity). If a goal is proved, the system looks
for a predicate with the same functor, then uses indexing to select candidate clauses and then
tries these clauses one-by-one. See also backtracking.
predicate indicator
Term of the form Name/Arity (traditional) or Name//Arity (ISO DCG proposal), where Name
is an atom and Arity a non-negative integer. It acts as an indicator (or reference) to a predicate
or DCG rule.
priority
In the context of operators a synonym for precedence.
program
Collection of predicates.
property
Attribute of an object. SWI-Prolog deﬁnes various * property predicates to query the status of
predicates, clauses. etc.
prove
Process where Prolog attempts to prove a query using the available predicates.
public list
List of predicates exported from a module.
query
See goal.
retract
Remove a clause from a predicate. See also dynamic, update view and assert.
shared
Two variables are called shared after they are uniﬁed. This implies if either of them is bound,
the other is bound to the same value:
?- A = B, A = a.
A = B, B = a.
singleton [variable]
Variable appearing only one time in a clause. SWI-Prolog normally warns for this to avoid
you making spelling mistakes. If a variable appears on purpose only once in a clause, write
it as _ (see anonymous). Rules for naming a variable and avoiding a warning are given in
section 2.15.1.
SWI-Prolog 6.6 Reference Manual

428
APPENDIX D. GLOSSARY OF TERMS
solution
Bindings resulting from a successfully proven goal.
structure
Synonym for compound term.
string
Used for the following representations of text: a packed array (see section 4.24, SWI-Prolog
speciﬁc), a list of character codes or a list of one-character atoms.
succeed
A goal is said to have succeeded if it has been proven.
term
Value in Prolog. A term is either a variable, atom, integer, ﬂoat or compound term. In addition,
SWI-Prolog also deﬁnes the type string.
transparent
See module transparent.
unify
Prolog process to make two terms equal by assigning variables in one term to values at the
corresponding location of the other term. For example:
?- foo(a, B) = foo(A, b).
A = a,
B = b.
Unlike assignment (which does not exist in Prolog), uniﬁcation is not directed.
update view
How Prolog behaves when a dynamic predicate is changed while it is running. There are two
models. In most older Prolog systems the change becomes immediately visible to the goal, in
modern systems including SWI-Prolog, the running goal is not affected. Only new goals ‘see’
the new deﬁnition.
variable
A Prolog variable is a value that ‘is not yet bound’. After binding a variable, it cannot be
modiﬁed. Backtracking to a point in the execution before the variable was bound will turn it
back into a variable:
?- A = b, A = c.
false.
?- (A = b; true; A = c).
A = b ;
true ;
A = c .
See also unify.
SWI-Prolog 6.6 Reference Manual

SWI-Prolog License Conditions
and Tools
E
SWI-Prolog licensing aims at a large audience, combining ideas from the Free Software Foundation
and the less principal Open Source Initiative. The license aims at the following:
• Make SWI-Prolog and its libraries ‘as free as possible’.
• Allow for easy integration of contributions. See section E.2.
• Free software can build on SWI-Prolog without limitations.
• Non-free (open or proprietary) software can be produced using SWI-Prolog, although con-
tributed pure GPL-ed components cannot be used.
To achieve this, different parts of the system have different licenses. SWI-Prolog programs consist
of a mixture of ‘native’ code (source compiled to machine instructions) and ‘virtual machine’ code
(Prolog source compiled to SWI-Prolog virtual machine instructions, covering both compiled SWI-
Prolog libraries and your compiled application).
For maximal coherence between free licenses, we start with the two prime licenses from the Free
Software Foundation, the GNU General Public License (GPL) and the Lesser GNU General Public
License (LGPL), after which we add a proven (used by the GNU C compiler runtime library as well
as the GNU ClassPath project) exception to deal with the speciﬁc nature of compiled virtual machine
code in a saved state.
E.1
The SWI-Prolog kernel and foreign libraries
The SWI-Prolog kernel and our foreign libraries are distributed under the LGPL. A Prolog executable
consists of the combination of these ‘native’ code components and Prolog virtual machine code. The
SWI-Prolog swipl-rc utility allows for disassembling and re-assembling these parts, a process
satisfying article 6b of the LGPL.
Under the LGPL, SWI-Prolog can be linked to code distributed under arbitrary licenses, provided
a number of requirements are fulﬁlled. The most important requirement is that if an application relies
on a modiﬁed version of SWI-Prolog, the modiﬁed sources must be made available.
E.1.1
The SWI-Prolog Prolog libraries
Lacking a satisfactory technical solution to handle article 6 of the LGPL, this license cannot be used
for the Prolog source code that is part of the SWI-Prolog system (both libraries and kernel code). This
situation is comparable to libgcc, the runtime library used with the GNU C compiler. Therefore,
we use the same proven license terms as this library. The libgcc license is the with a special exception.
Below we rephrase this exception adjusted to our needs:
SWI-Prolog 6.6 Reference Manual

430
APPENDIX E. SWI-PROLOG LICENSE CONDITIONS AND TOOLS
As a special exception, if you link this library with other ﬁles, compiled with a Free
Software compiler, to produce an executable, this library does not by itself cause the
resulting executable to be covered by the GNU General Public License. This exception
does not, however, invalidate any other reasons why the executable ﬁle might be covered
by the GNU General Public License.
E.2
Contributing to the SWI-Prolog project
To achieve maximal coherence using SWI-Prolog for Free and Non-Free software we advise using
LGPL for contributed foreign code and using GPL with the SWI-Prolog exception for Prolog code for
contributed modules.
As a rule of thumb it is advised to use the above licenses whenever possible, and use a strict GPL
compliant license only if the module contains other code under strict GPL compliant licenses.
E.3
Software support to keep track of license conditions
Given the above, it is possible that SWI-Prolog packages and extensions will rely on the GPL.1 The
predicates below allow for registering license requirements for Prolog ﬁles and foreign modules. The
predicate eval license/0 reports which components from the currently conﬁgured system are
distributed under copy-left and open source enforcing licenses (the GPL) and therefore must be re-
placed before distributing linked applications under non-free license conditions.
eval license
Evaluate the license conditions of all loaded components. If the system contains one or more
components that are licenced under GPL-like restrictions the system indicates this program
may only be distributed under the GPL license as well as which components prohibit the use of
other license conditions.
license(+LicenseId, +Component)
Register the fact that Component is distributed under a license identiﬁed by LicenseId. The
most important LicenseId’s are:
swipl
Indicates this module is distributed under the GNU General Public License (GPL) with
the SWI-Prolog exception:2
As a special exception, if you link this library with other ﬁles, compiled with
SWI-Prolog, to produce an executable, this library does not by itself cause the
resulting executable to be covered by the GNU General Public License. This
exception does not, however, invalidate any other reasons why the executable
ﬁle might be covered by the GNU General Public License.
1On the Unix version, the default toplevel uses the GNU readline library for command line editing. This library is
distributed under the GPL. In practice this problem is small as most ﬁnal applications have Prolog embedded, without direct
access to the command line and therefore without need for libreadline.
2This exception is a straight re-phrasing of the license used for libgcc, the GNU C runtime library facing similar
technical issues.
SWI-Prolog 6.6 Reference Manual

E.4. LICENSE CONDITIONS INHERITED FROM USED CODE
431
This should be the default for software contributed to the SWI-Prolog project as it allows
the community to prosper both in the free and non-free world. Still, people using SWI-
Prolog to create non-free applications must contribute sources to improvements they make
to the community.
lgpl
This is the default license for foreign libraries linked with SWI-Prolog.
Use
PL license() to register the condition from foreign code.
gpl
Indicates this module is strictly Free Software, which implies it cannot be used together
with any module that is incompatible with the GPL. Please only use these conditions
when forced by other code used in the component.
Other licenses known to the system are guile,
gnu ada,
x11,
expat,
sml,
public domain, cryptix, bsd, zlib, lgpl compatible and gpl compatible.
New licenses can be deﬁned by adding clauses for the multiﬁle predicate license:license/3. Be-
low is an example. The second argument is either gpl or lgpl to indicate compatibility with
these licenses. Other values cause the license to be interpreted as proprietary. Proprietary
licenses are reported by eval license/0. See the ﬁle boot/license.pl for details.
:- multifile license:license/3.
license:license(mylicense, lgpl,
[ comment(’My personal license’),
url(’http://www.mine.org/license.html’)
]).
:- license(mylicense).
license(+LicenseId)
Intended as a directive in Prolog source ﬁles.
It takes the current ﬁlename and calls
license/2.
void PL license(const char *LicenseId, const char *Component)
Intended for the install() procedure of foreign libraries.
This call can be made before
PL initialise().
E.4
License conditions inherited from used code
E.4.1
Cryptographic routines
Cryptographic routines are used in variant sha1/2 and crypt. These routines are provided
under the following conditions:
Copyright (c) 2002, Dr Brian Gladman, Worcester, UK.
All rights reserved.
LICENSE TERMS
SWI-Prolog 6.6 Reference Manual

432
APPENDIX E. SWI-PROLOG LICENSE CONDITIONS AND TOOLS
The free distribution and use of this software in both source and binary
form is allowed (with or without changes) provided that:
1. distributions of this source code include the above copyright
notice, this list of conditions and the following disclaimer;
2. distributions in binary form include the above copyright
notice, this list of conditions and the following disclaimer
in the documentation and/or other associated materials;
3. the copyright holder’s name is not used to endorse products
built using this software without specific written permission.
ALTERNATIVELY, provided that this notice is retained in full, this product
may be distributed under the terms of the GNU General Public License (GPL),
in which case the provisions of the GPL apply INSTEAD OF those given above.
DISCLAIMER
This software is provided ’as is’ with no explicit or implied warranties
in respect of its properties, including, but not limited to, correctness
and/or fitness for purpose.
SWI-Prolog 6.6 Reference Manual

Summary
F
F.1
Predicates
The predicate summary is used by the Prolog predicate apropos/1 to suggest predicates from a
keyword.
@/2
Call using calling context
!/0
Cut (discard choicepoints)
,/2
Conjunction of goals
->/2
If-then-else
*->/2
Soft-cut
./2
Consult. Also list constructor
;/2
Disjunction of goals. Same as |/2
</2
Arithmetic smaller
=/2
Uniﬁcation
=../2
“Univ.” Term to list conversion
=:=/2
Arithmetic equal
=</2
Arithmetic smaller or equal
==/2
Identical
=@=/2
Structural identical
=\=/2
Arithmetic not equal
>/2
Arithmetic larger
>=/2
Arithmetic larger or equal
?=/2
Test of terms can be compared now
@</2
Standard order smaller
@=</2
Standard order smaller or equal
@>/2
Standard order larger
@>=/2
Standard order larger or equal
\+/1
Negation by failure. Same as not/1
\=/2
Not uniﬁable
\==/2
Not identical
\=@=/2
Not structural identical
ˆ/2
Existential quantiﬁcation (bagof/3, setof/3)
|/2
Disjunction of goals. Same as ;/2
{}/1
DCG escape; constraints
abolish/1
Remove predicate deﬁnition from the database
abolish/2
Remove predicate deﬁnition from the database
abort/0
Abort execution, return to top level
absolute ﬁle name/2
Get absolute path name
SWI-Prolog 6.6 Reference Manual

434
APPENDIX F. SUMMARY
absolute ﬁle name/3
Get absolute path name with options
access ﬁle/2
Check access permissions of a ﬁle
acyclic term/1
Test term for cycles
add import module/3
Add module to the auto-import list
add nb set/2
Add term to a non-backtrackable set
add nb set/3
Add term to a non-backtrackable set
append/1
Append to a ﬁle
apply/2
Call goal with additional arguments
apropos/1
online help Search manual
arg/3
Access argument of a term
assoc to list/2
Convert association tree to list
assert/1
Add a clause to the database
assert/2
Add a clause to the database, give reference
asserta/1
Add a clause to the database (ﬁrst)
asserta/2
Add a clause to the database (ﬁrst)
assertion/1
Make assertions about your program
assertz/1
Add a clause to the database (last)
assertz/2
Add a clause to the database (last)
attach console/0
Attach I/O console to thread
attribute goals/3
Project attributes to goals
attr unify hook/2
Attributed variable uniﬁcation hook
attr portray hook/2
Attributed variable print hook
attvar/1
Type test for attributed variable
at end of stream/0
Test for end of ﬁle on input
at end of stream/1
Test for end of ﬁle on stream
at halt/1
Register goal to run at halt/1
atom/1
Type check for an atom
atom chars/2
Convert between atom and list of characters
atom codes/2
Convert between atom and list of characters codes
atom concat/3
Append two atoms
atom length/2
Determine length of an atom
atom number/2
Convert between atom and number
atom preﬁx/2
Test for start of atom
atom string/2
Conversion between atom and string
atom to term/3
Convert between atom and term
atomic/1
Type check for primitive
atomic concat/3
Concatenate two atomic values to an atom
atomic list concat/2
Append a list of atoms
atomic list concat/3
Append a list of atoms with separator
autoload/0
Autoload all predicates now
autoload path/1
Add directories for autoloading
b getval/2
Fetch backtrackable global variable
b setval/2
Assign backtrackable global variable
bagof/3
Find all solutions to a goal
between/3
Integer range checking/generating
blob/2
Type check for a blob
break/0
Start interactive top level
SWI-Prolog 6.6 Reference Manual

F.1. PREDICATES
435
byte count/2
Byte-position in a stream
call/1
Call a goal
call/[2..]
Call with additional arguments
call cleanup/3
Guard a goal with a cleaup-handler
call cleanup/2
Guard a goal with a cleaup-handler
call residue vars/2
Find residual attributed variables
call shared object function/2
UNIX: Call C-function in shared (.so) ﬁle
call with depth limit/3
Prove goal with bounded depth
callable/1
Test for atom or compound term
cancel halt/1
Cancel halt/0 from an at halt/1 hook
catch/3
Call goal, watching for exceptions
char code/2
Convert between character and character code
char conversion/2
Provide mapping of input characters
char type/2
Classify characters
character count/2
Get character index on a stream
chdir/1
Compatibility: change working directory
chr constraint/1
CHR Constraint declaration
chr show store/1
List suspended CHR constraints
chr trace/0
Start CHR tracer
chr type/1
CHR Type declaration
chr notrace/0
Stop CHR tracer
chr leash/1
Deﬁne CHR leashed ports
chr option/2
Specify CHR compilation options
clause/2
Get clauses of a predicate
clause/3
Get clauses of a predicate
clause property/2
Get properties of a clause
close/1
Close stream
close/2
Close stream (forced)
close dde conversation/1
Win32: Close DDE channel
close shared object/1
UNIX: Close shared library (.so ﬁle)
collation key/2
Sort key for locale dependent ordering
comment hook/3
(hook) handle comments in sources
compare/3
Compare, using a predicate to determine the order
compile aux clauses/1
Compile predicates for goal expansion/2
compile predicates/1
Compile dynamic code to static
compiling/0
Is this a compilation run?
compound/1
Test for compound term
code type/2
Classify a character-code
consult/1
Read (compile) a Prolog source ﬁle
context module/1
Get context module of current goal
convert time/8
Break time stamp into ﬁelds
convert time/2
Convert time stamp to string
copy stream data/2
Copy all data from stream to stream
copy stream data/3
Copy n bytes from stream to stream
copy predicate clauses/2
Copy clauses between predicates
copy term/2
Make a copy of a term
copy term/3
Copy a term and obtain attribute-goals
SWI-Prolog 6.6 Reference Manual

436
APPENDIX F. SUMMARY
copy term nat/2
Make a copy of a term without attributes
create prolog ﬂag/3
Create a new Prolog ﬂag
current arithmetic function/1
Examine evaluable functions
current atom/1
Examine existing atoms
current blob/2
Examine typed blobs
current char conversion/2
Query input character mapping
current ﬂag/1
Examine existing ﬂags
current foreign library/2
shlib Examine loaded shared libraries (.so ﬁles)
current format predicate/2
Enumerate user-deﬁned format codes
current functor/2
Examine existing name/arity pairs
current input/1
Get current input stream
current key/1
Examine existing database keys
current locale/1
Get the current locale
current module/1
Examine existing modules
current op/3
Examine current operator declarations
current output/1
Get the current output stream
current predicate/1
Examine existing predicates (ISO)
current predicate/2
Examine existing predicates
current signal/3
Current software signal mapping
current stream/3
Examine open streams
cyclic term/1
Test term for cycles
day of the week/2
Determine ordinal-day from date
date time stamp/2
Convert sate structure to time-stamp
date time value/3
Extract info from a date structure
dcg translate rule/2
Source translation of DCG rules
dcg translate rule/4
Source translation of DCG rules
dde current connection/2
Win32: Examine open DDE connections
dde current service/2
Win32: Examine DDE services provided
dde execute/2
Win32: Execute command on DDE server
dde register service/2
Win32: Become a DDE server
dde request/3
Win32: Make a DDE request
dde poke/3
Win32: POKE operation on DDE server
dde unregister service/1
Win32: Terminate a DDE service
debug/0
Test for debugging mode
debug/1
Select topic for debugging
debug/3
Print debugging message on topic
debug control hook/1
(hook) Extend spy/1, etc.
debugging/0
Show debugger status
debugging/1
Test where we are debugging topic
default module/2
Query module inheritance
del attr/2
Delete attribute from variable
del attrs/1
Delete all attributes from variable
delete directory/1
Remove a folder from the ﬁle system
delete ﬁle/1
Remove a ﬁle from the ﬁle system
delete import module/2
Remove module from import list
deterministic/1
Test deterministicy of current clause
dif/2
Constrain two terms to be different
SWI-Prolog 6.6 Reference Manual

F.1. PREDICATES
437
directory ﬁles/2
Get entries of a directory/folder
discontiguous/1
Indicate distributed deﬁnition of a predicate
downcase atom/2
Convert atom to lower-case
duplicate term/2
Create a copy of a term
dwim match/2
Atoms match in “Do What I Mean” sense
dwim match/3
Atoms match in “Do What I Mean” sense
dwim predicate/2
Find predicate in “Do What I Mean” sense
dynamic/1
Indicate predicate deﬁnition may change
edit/0
Edit current script- or associated ﬁle
edit/1
Edit a ﬁle, predicate, module (extensible)
elif/1
Part of conditional compilation (directive)
else/0
Part of conditional compilation (directive)
empty assoc/1
Create/test empty association tree
empty nb set/1
Test/create an empty non-backtrackable set
encoding/1
Deﬁne encoding inside a source ﬁle
endif/0
End of conditional compilation (directive)
ensure loaded/1
Consult a ﬁle if that has not yet been done
erase/1
Erase a database record or clause
eval license/0
Evaluate licenses of loaded modules
exception/3
(hook) Handle runtime exceptions
exists directory/1
Check existence of directory
exists ﬁle/1
Check existence of ﬁle
exists source/1
Check existence of a Prolog source
expand answer/2
Expand answer of query
expand ﬁle name/2
Wildcard expansion of ﬁle names
expand ﬁle search path/2
Wildcard expansion of ﬁle paths
expand goal/2
Compiler: expand goal in clause-body
expand goal/4
Compiler: expand goal in clause-body
expand query/4
Expanded entered query
expand term/2
Compiler: expand read term into clause(s)
expand term/4
Compiler: expand read term into clause(s)
expects dialect/1
For which Prolog dialect is this code written?
explain/1
explain Explain argument
explain/2
explain 2nd argument is explanation of ﬁrst
export/1
Export a predicate from a module
fail/0
Always false
false/0
Always false
current prolog ﬂag/2
Get system conﬁguration parameters
ﬁle base name/2
Get ﬁle part of path
ﬁle directory name/2
Get directory part of path
ﬁle name extension/3
Add, remove or test ﬁle extensions
ﬁle search path/2
Deﬁne path-aliases for locating ﬁles
ﬁnd chr constraint/1
Returns a constraint from the store
ﬁndall/3
Find all solutions to a goal
ﬁndall/4
Difference list version of findall/3
ﬂag/3
Simple global variable system
ﬂoat/1
Type check for a ﬂoating point number
SWI-Prolog 6.6 Reference Manual

438
APPENDIX F. SUMMARY
ﬂush output/0
Output pending characters on current stream
ﬂush output/1
Output pending characters on speciﬁed stream
forall/2
Prove goal for all solutions of another goal
format/1
Formatted output
format/2
Formatted output with arguments
format/3
Formatted output on a stream
format time/3
C strftime() like date/time formatter
format time/4
date/time formatter with explicit locale
format predicate/2
Program format/[1,2]
term attvars/2
Find attributed variables in a term
term variables/2
Find unbound variables in a term
term variables/3
Find unbound variables in a term
freeze/2
Delay execution until variable is bound
frozen/2
Query delayed goals on var
functor/3
Get name and arity of a term or construct a term
garbage collect/0
Invoke the garbage collector
garbage collect atoms/0
Invoke the atom garbage collector
garbage collect clauses/0
Invoke clause garbage collector
gen assoc/3
Enumerate members of association tree
gen nb set/2
Generate members of non-backtrackable set
gensym/2
Generate unique atoms from a base
get/1
Read ﬁrst non-blank character
get/2
Read ﬁrst non-blank character from a stream
get assoc/3
Fetch key from association tree
get assoc/5
Fetch key from association tree
get0/1
Read next character
get0/2
Read next character from a stream
get attr/3
Fetch named attribute from a variable
get attrs/2
Fetch all attributes of a variable
get byte/1
Read next byte (ISO)
get byte/2
Read next byte from a stream (ISO)
get char/1
Read next character as an atom (ISO)
get char/2
Read next character from a stream (ISO)
get code/1
Read next character (ISO)
get code/2
Read next character from a stream (ISO)
get single char/1
Read next character from the terminal
get time/1
Get current time
getenv/2
Get shell environment variable
goal expansion/2
Hook for macro-expanding goals
goal expansion/4
Hook for macro-expanding goals
ground/1
Verify term holds no unbound variables
gdebug/0
Debug using graphical tracer
gspy/1
Spy using graphical tracer
gtrace/0
Trace using graphical tracer
guitracer/0
Install hooks for the graphical debugger
gxref/0
Cross-reference loaded program
halt/0
Exit from Prolog
SWI-Prolog 6.6 Reference Manual

F.1. PREDICATES
439
halt/1
Exit from Prolog with status
term hash/2
Hash-value of ground term
term hash/4
Hash-value of term with depth limit
help/0
Give help on help
help/1
Give help on predicates and show parts of manual
help hook/1
(hook) User-hook in the help-system
if/1
Start conditional compilation (directive)
ignore/1
Call the argument, but always succeed
import/1
Import a predicate from a module
import module/2
Query import modules
in pce thread/1
Run goal in XPCE thread
in pce thread sync/1
Run goal in XPCE thread
include/1
Include a ﬁle with declarations
initialization/1
Initialization directive
initialization/2
Initialization directive
instance/2
Fetch clause or record from reference
integer/1
Type check for integer
interactor/0
Start new thread with console and top level
is/2
Evaluate arithmetic expression
is absolute ﬁle name/1
True if arg deﬁnes an absolute path
is assoc/1
Verify association list
is list/1
Type check for a list
is stream/1
Type check for a stream handle
join threads/0
Join all terminated threads interactively
keysort/2
Sort, using a key
last/2
Last element of a list
leash/1
Change ports visited by the tracer
length/2
Length of a list
library directory/1
(hook) Directories holding Prolog libraries
license/1
Deﬁne license for current ﬁle
license/2
Deﬁne license for named module
line count/2
Line number on stream
line position/2
Character position in line on stream
list debug topics/0
List registered topics for debugging
list to assoc/2
Create association tree from list
list to set/2
Remove duplicates from a list
listing/0
List program in current module
listing/1
List predicate
load ﬁles/2
Load source ﬁles with options
load foreign library/1
shlib Load shared library (.so ﬁle)
load foreign library/2
shlib Load shared library (.so ﬁle)
locale create/3
Create a new locale object
locale destroy/1
Destroy a locale object
locale property/2
Query properties of locale objects
locale sort/2
Language dependent sort of atoms
make/0
Reconsult all changed source ﬁles
make directory/1
Create a folder on the ﬁle system
SWI-Prolog 6.6 Reference Manual

440
APPENDIX F. SUMMARY
make library index/1
Create autoload ﬁle INDEX.pl
make library index/2
Create selective autoload ﬁle INDEX.pl
map assoc/2
Map association tree
map assoc/3
Map association tree
max assoc/3
Highest key in association tree
memberchk/2
Deterministic member/2
message hook/3
Intercept print message/2
message line element/2
(hook) Intercept print message lines/3
message property/2
(hook) Deﬁne display of a message
message queue create/1
Create queue for thread communication
message queue create/2
Create queue for thread communication
message queue destroy/1
Destroy queue for thread communication
message queue property/2
Query message queue properties
message to string/2
Translate message-term to string
meta predicate/1
Declare access to other predicates
min assoc/3
Lowest key in association tree
module/1
Query/set current type-in module
module/2
Declare a module
module/3
Declare a module with language options
module property/2
Find properties of a module
module transparent/1
Indicate module based meta-predicate
msort/2
Sort, do not remove duplicates
multiﬁle/1
Indicate distributed deﬁnition of predicate
mutex create/1
Create a thread-synchronisation device
mutex create/2
Create a thread-synchronisation device
mutex destroy/1
Destroy a mutex
mutex lock/1
Become owner of a mutex
mutex property/2
Query mutex properties
mutex statistics/0
Print statistics on mutex usage
mutex trylock/1
Become owner of a mutex (non-blocking)
mutex unlock/1
Release ownership of mutex
mutex unlock all/0
Release ownership of all mutexes
name/2
Convert between atom and list of character codes
nb current/2
Enumerate non-backtrackable global variables
nb delete/1
Delete a non-backtrackable global variable
nb getval/2
Fetch non-backtrackable global variable
nb linkarg/3
Non-backtrackable assignment to term
nb linkval/2
Assign non-backtrackable global variable
nb set to list/2
Convert non-backtrackable set to list
nb setarg/3
Non-backtrackable assignment to term
nb setval/2
Assign non-backtrackable global variable
nl/0
Generate a newline
nl/1
Generate a newline on a stream
nodebug/0
Disable debugging
nodebug/1
Disable debug-topic
noguitracer/0
Disable the graphical debugger
nonvar/1
Type check for bound term
SWI-Prolog 6.6 Reference Manual

F.1. PREDICATES
441
noproﬁle/1
Hide (meta-) predicate for the proﬁler
noprotocol/0
Disable logging of user interaction
normalize space/2
Normalize white space
nospy/1
Remove spy point
nospyall/0
Remove all spy points
not/1
Negation by failure (argument not provable). Same as \+/1
notrace/0
Stop tracing
notrace/1
Do not debug argument goal
nth clause/3
N-th clause of a predicate
number/1
Type check for integer or ﬂoat
number chars/2
Convert between number and one-char atoms
number codes/2
Convert between number and character codes
numbervars/3
Number unbound variables of a term
numbervars/4
Number unbound variables of a term
on signal/3
Handle a software signal
once/1
Call a goal deterministically
op/3
Declare an operator
open/3
Open a ﬁle (creating a stream)
open/4
Open a ﬁle (creating a stream)
open dde conversation/3
Win32: Open DDE channel
open null stream/1
Open a stream to discard output
open resource/3
Open a program resource as a stream
open shared object/2
UNIX: Open shared library (.so ﬁle)
open shared object/3
UNIX: Open shared library (.so ﬁle)
ord list to assoc/2
Convert ordered list to assoc
parse time/2
Parse text to a time-stamp
parse time/3
Parse text to a time-stamp
pce dispatch/1
Run XPCE GUI in separate thread
pce call/1
Run goal in XPCE GUI thread
peek byte/1
Read byte without removing
peek byte/2
Read byte without removing
peek char/1
Read character without removing
peek char/2
Read character without removing
peek code/1
Read character-code without removing
peek code/2
Read character-code without removing
phrase/2
Activate grammar-rule set
phrase/3
Activate grammar-rule set (returning rest)
please/3
Query/change environment parameters
plus/3
Logical integer addition
portray/1
(hook) Modify behaviour of print/1
portray clause/1
Pretty print a clause
portray clause/2
Pretty print a clause to a stream
predicate property/2
Query predicate attributes
predsort/3
Sort, using a predicate to determine the order
print/1
Print a term
print/2
Print a term on a stream
print message/2
Print message from (exception) term
SWI-Prolog 6.6 Reference Manual

442
APPENDIX F. SUMMARY
print message lines/3
Print message to stream
proﬁle/1
Obtain execution statistics
proﬁle/2
Obtain execution statistics
proﬁle count/3
Obtain proﬁle results on a predicate
proﬁler/2
Obtain/change status of the proﬁler
prolog/0
Run interactive top level
prolog choice attribute/3
Examine the choice point stack
prolog current choice/1
Reference to most recent choice point
prolog current frame/1
Reference to goal’s environment stack
prolog cut to/1
Realise global cuts
prolog edit:locate/2
Locate targets for edit/1
prolog edit:locate/3
Locate targets for edit/1
prolog edit:edit source/1
Call editor for edit/1
prolog edit:edit command/2
Specify editor activation
prolog edit:load/0
Load edit/1 extensions
prolog exception hook/4
Rewrite exceptions
prolog ﬁle type/2
Deﬁne meaning of ﬁle extension
prolog frame attribute/3
Obtain information on a goal environment
prolog ide/1
Program access to the development environment
prolog list goal/1
(hook) Intercept tracer ’L’ command
prolog load context/2
Context information for directives
prolog load ﬁle/2
(hook) Program load files/2
prolog skip level/2
Indicate deepest recursion to trace
prolog skip frame/1
Perform ‘skip’ on a frame
prolog stack property/2
Query properties of the stacks
prolog to os ﬁlename/2
Convert between Prolog and OS ﬁlenames
prolog trace interception/4
user Intercept the Prolog tracer
prompt1/1
Change prompt for 1 line
prompt/2
Change the prompt used by read/1
protocol/1
Make a log of the user interaction
protocola/1
Append log of the user interaction to ﬁle
protocolling/1
On what ﬁle is user interaction logged
public/1
Declaration that a predicate may be called
put/1
Write a character
put/2
Write a character on a stream
put assoc/4
Add Key-Value to association tree
put attr/3
Put attribute on a variable
put attrs/2
Set/replace all attributes on a variable
put byte/1
Write a byte
put byte/2
Write a byte on a stream
put char/1
Write a character
put char/2
Write a character on a stream
put code/1
Write a character-code
put code/2
Write a character-code on a stream
qcompile/1
Compile source to Quick Load File
qcompile/2
Compile source to Quick Load File
qsave program/1
Create runtime application
SWI-Prolog 6.6 Reference Manual

F.1. PREDICATES
443
qsave program/2
Create runtime application
random property/1
Query properties of random generation
rational/1
Type check for a rational number
rational/3
Decompose a rational
read/1
Read Prolog term
read/2
Read Prolog term from stream
read clause/3
Read clause from stream
read history/6
Read using history substitution
read link/3
Read a symbolic link
read pending input/3
Fetch buffered input from a stream
read term/2
Read term with options
read term/3
Read term with options from stream
read term from atom/3
Read term with options from atom
recorda/2
Record term in the database (ﬁrst)
recorda/3
Record term in the database (ﬁrst)
recorded/2
Obtain term from the database
recorded/3
Obtain term from the database
recordz/2
Record term in the database (last)
recordz/3
Record term in the database (last)
redeﬁne system predicate/1
Abolish system deﬁnition
reexport/1
Load ﬁles and re-export the imported predicates
reexport/2
Load predicates from a ﬁle and re-export it
reload foreign libraries/0
Reload DLLs/shared objects
reload library index/0
Force reloading the autoload index
rename ﬁle/2
Change name of ﬁle
repeat/0
Succeed, leaving inﬁnite backtrack points
require/1
This ﬁle requires these predicates
reset gensym/1
Reset a gensym key
reset gensym/0
Reset all gensym keys
reset proﬁler/0
Clear statistics obtained by the proﬁler
resource/3
Declare a program resource
retract/1
Remove clause from the database
retractall/1
Remove unifying clauses from the database
same ﬁle/2
Succeeds if arguments refer to same ﬁle
same term/2
Test terms to be at the same address
see/1
Change the current input stream
seeing/1
Query the current input stream
seek/4
Modify the current position in a stream
seen/0
Close the current input stream
set end of stream/1
Set physical end of an open ﬁle
set input/1
Set current input stream from a stream
set locale/1
Set the default local
set module/1
Set properties of a module
set output/1
Set current output stream from a stream
set prolog IO/3
Prepare streams for interactive session
set prolog ﬂag/2
Deﬁne a system feature
set prolog stack/2
Modify stack characteristics
SWI-Prolog 6.6 Reference Manual

444
APPENDIX F. SUMMARY
set random/1
Control random number generation
set stream/2
Set stream attribute
set stream position/2
Seek stream to position
setup call cleanup/3
Undo side-effects safely
setup call catcher cleanup/4
Undo side-effects safely
setarg/3
Destructive assignment on term
setenv/2
Set shell environment variable
setlocale/3
Set/query C-library regional information
setof/3
Find all unique solutions to a goal
shell/0
Execute interactive subshell
shell/1
Execute OS command
shell/2
Execute OS command
show proﬁle/1
Show results of the proﬁler
size ﬁle/2
Get size of a ﬁle in characters
size nb set/2
Determine size of non-backtrackable set
skip/1
Skip to character in current input
skip/2
Skip to character on stream
rl add history/1
Add line to readline(3) history
rl read history/1
Read readline(3) history
rl read init ﬁle/1
Read readline(3) init ﬁle
rl write history/1
Write readline(3) history
sleep/1
Suspend execution for speciﬁed time
sort/2
Sort elements in a list
source exports/2
Check whether source exports a predicate
source ﬁle/1
Examine currently loaded source ﬁles
source ﬁle/2
Obtain source ﬁle of predicate
source ﬁle property/2
Information about loaded ﬁles
source location/2
Location of last read term
spy/1
Force tracer on speciﬁed predicate
stamp date time/3
Convert time-stamp to date structure
statistics/0
Show execution statistics
statistics/2
Obtain collected statistics
stream pair/3
Create/examine a bi-directional stream
stream position data/3
Access ﬁelds from stream position
stream property/2
Get stream properties
string/1
Type check for string
string concat/3
atom concat/3 for strings
string length/2
Determine length of a string
string codes/2
Conversion between string and list of character codes
string code/3
Get or ﬁnd a character code in a string
strip module/3
Extract context module and term
style check/1
Change level of warnings
sub atom/5
Take a substring from an atom
sub atom icasechk/3
Case insensitive substring match
sub string/5
Take a substring from a string
subsumes term/2
One-sided uniﬁcation test
succ/2
Logical integer successor relation
SWI-Prolog 6.6 Reference Manual

F.1. PREDICATES
445
swritef/2
Formatted write on a string
swritef/3
Formatted write on a string
tab/1
Output number of spaces
tab/2
Output number of spaces on a stream
tdebug/0
Switch all threads into debug mode
tdebug/1
Switch a thread into debug mode
tell/1
Change current output stream
telling/1
Query current output stream
term expansion/2
(hook) Convert term before compilation
term expansion/4
(hook) Convert term before compilation
term subsumer/3
Most speciﬁc generalization of two terms
term to atom/2
Convert between term and atom
thread at exit/1
Register goal to be called at exit
thread create/3
Create a new Prolog task
thread detach/1
Make thread cleanup after completion
thread exit/1
Terminate Prolog task with value
thread get message/1
Wait for message
thread get message/2
Wait for message in a queue
thread get message/3
Wait for message in a queue
thread initialization/1
Run action at start of thread
thread join/2
Wait for Prolog task-completion
thread local/1
Declare thread-speciﬁc clauses for a predicate
thread message hook/3
Thread local message hook/3
thread peek message/1
Test for message
thread peek message/2
Test for message in a queue
thread property/2
Examine Prolog threads
thread self/1
Get identiﬁer of current thread
thread send message/2
Send message to another thread
thread setconcurrency/2
Number of active threads
thread signal/2
Execute goal in another thread
thread statistics/3
Get statistics of another thread
threads/0
List running threads
throw/1
Raise an exception (see catch/3)
time/1
Determine time needed to execute goal
time ﬁle/2
Get last modiﬁcation time of ﬁle
tmp ﬁle/2
Create a temporary ﬁlename
tmp ﬁle stream/3
Create a temporary ﬁle and open it
tnodebug/0
Switch off debug mode in all threads
tnodebug/1
Switch off debug mode in a thread
told/0
Close current output
tproﬁle/1
Proﬁle a thread for some period
trace/0
Start the tracer
trace/1
Set trace point on predicate
trace/2
Set/Clear trace point on ports
tracing/0
Query status of the tracer
trim stacks/0
Release unused memory resources
true/0
Succeed
SWI-Prolog 6.6 Reference Manual

446
APPENDIX F. SUMMARY
tspy/1
Set spy point and enable debugging in all threads
tspy/2
Set spy point and enable debugging in a thread
tty get capability/3
Get terminal parameter
tty goto/2
Goto position on screen
tty put/2
Write control string to terminal
tty size/2
Get row/column size of the terminal
ttyﬂush/0
Flush output on terminal
unify with occurs check/2
Logically sound uniﬁcation
uniﬁable/3
Determining binding required for uniﬁcation
unix/1
OS interaction
unknown/2
Trap undeﬁned predicates
unload ﬁle/1
Unload a source ﬁle
unload foreign library/1
shlib Detach shared library (.so ﬁle)
unload foreign library/2
shlib Detach shared library (.so ﬁle)
unsetenv/1
Delete shell environment variable
upcase atom/2
Convert atom to upper-case
use foreign library/1
Load DLL/shared object (directive)
use foreign library/2
Load DLL/shared object (directive)
use module/1
Import a module
use module/2
Import predicates from a module
var/1
Type check for unbound variable
var number/2
Check that var is numbered by numbervars
variant sha1/2
Term-hash for term-variants
version/0
Print system banner message
version/1
Add messages to the system banner
visible/1
Ports that are visible in the tracer
volatile/1
Predicates that are not saved
wait for input/3
Wait for input with optional timeout
when/2
Execute goal when condition becomes true
wildcard match/2
Csh(1) style wildcard match
win add dll directory/1
Add directory to DLL search path
win add dll directory/2
Add directory to DLL search path
win remove dll directory/2
Remove directory from DLL search path
win exec/2
Win32: spawn Windows task
win has menu/0
Win32: true if console menu is available
win folder/2
Win32: get special folder by CSIDL
win insert menu/2
swipl-win.exe: add menu
win insert menu item/4
swipl-win.exe: add item to menu
win shell/2
Win32: open document through Shell
win shell/3
Win32: open document through Shell
win registry get value/3
Win32: get registry value
win window pos/1
Win32: change size and position of window
window title/2
Win32: change title of window
with mutex/2
Run goal while holding mutex
with output to/2
Write to strings and more
working directory/2
Query/change CWD
write/1
Write term
SWI-Prolog 6.6 Reference Manual

F.1. PREDICATES
447
write/2
Write term to stream
writeln/1
Write term, followed by a newline
write canonical/1
Write a term with quotes, ignore operators
write canonical/2
Write a term with quotes, ignore operators on a stream
write length/3
Dermine #characters to output a term
write term/2
Write term with options
write term/3
Write term with options to stream
writef/1
Formatted write
writef/2
Formatted write on stream
writeq/1
Write term, insert quotes
writeq/2
Write term, insert quotes on stream
SWI-Prolog 6.6 Reference Manual

448
APPENDIX F. SUMMARY
F.2
Library predicates
F.2.1
library(aggregate)
aggregate/3
Aggregate bindings in Goal according to Template.
aggregate/4
Aggregate bindings in Goal according to Template.
aggregate all/3
Aggregate bindings in Goal according to Template.
aggregate all/4
Aggregate bindings in Goal according to Template.
foreach/2
True if conjunction of results is true.
free variables/4
Find free variables in bagof/setof template.
safe meta/2
Declare the aggregate meta-calls safe.
F.2.2
library(apply)
exclude/3
Filter elements for which Goal fails.
foldl/4
Fold a list, using arguments of the list as left argument.
foldl/5
Fold a list, using arguments of the list as left argument.
foldl/6
Fold a list, using arguments of the list as left argument.
foldl/7
Fold a list, using arguments of the list as left argument.
include/3
Filter elements for which Goal succeeds.
maplist/2
True if Goal can successfully be applied on all elements of List.
maplist/3
As maplist/2, operating on pairs of elements from two lists.
maplist/4
As maplist/2, operating on triples of elements from three lists.
maplist/5
As maplist/2, operating on quadruples of elements from four lists.
partition/4
Filter elements of List according to Pred.
partition/5
Filter List according to Pred in three sets.
scanl/4
Left scan of list.
scanl/5
Left scan of list.
scanl/6
Left scan of list.
scanl/7
Left scan of list.
F.2.3
library(assoc)
assoc to list/2
Translate assoc into a pairs list
assoc to keys/2
Translate assoc into a key list
assoc to values/2
Translate assoc into a value list
empty assoc/1
Test/create an empty assoc
gen assoc/3
Non-deterministic enumeration of assoc
get assoc/3
Get associated value
get assoc/5
Get and replace associated value
list to assoc/2
Translate pair list to assoc
map assoc/2
Test assoc values
map assoc/3
Map assoc values
max assoc/3
Max key-value of an assoc
min assoc/3
Min key-value of an assoc
ord list to assoc/3
Translate ordered list into an assoc
SWI-Prolog 6.6 Reference Manual

F.2. LIBRARY PREDICATES
449
put assoc/4
Add association to an assoc
F.2.4
library(broadcast)
broadcast/1
Send event notiﬁcation
broadcast request/1
Request all agents
listen/2
Listen to event notiﬁcations
listen/3
Listen to event notiﬁcations
unlisten/1
Stop listening to event notiﬁcations
unlisten/2
Stop listening to event notiﬁcations
unlisten/3
Stop listening to event notiﬁcations
listening/3
Who is listening to event notiﬁcations?
F.2.5
library(charsio)
atom to chars/2
Convert Atom into a list of character codes.
atom to chars/3
Convert Atom into a difference list of character codes.
format to chars/3
Use format/2 to write to a list of character codes.
format to chars/4
Use format/2 to write to a difference list of character codes.
number to chars/2
Convert Atom into a list of character codes.
number to chars/3
Convert Number into a difference list of character codes.
open chars stream/2
Open Codes as an input stream.
read from chars/2
Read Codes into Term.
read term from chars/3
Read Codes into Term.
with output to chars/2
Run Goal as with once/1.
with output to chars/3
Run Goal as with once/1.
with output to chars/4
Same as with output to chars/3 using an explicit stream.
write to chars/2
Write a term to a code list.
write to chars/3
Write a term to a code list.
F.2.6
library(check)
check/0
Program completeness and consistency
list undeﬁned/0
List undeﬁned predicates
list autoload/0
List predicates that require autoload
list redeﬁned/0
List locally redeﬁned predicates
F.2.7
library(csv)
csv read ﬁle/2
Read a CSV ﬁle into a list of rows.
csv read ﬁle/3
Read a CSV ﬁle into a list of rows.
csv read ﬁle row/3
True when Row is a row in File.
csv write ﬁle/2
Write a list of Prolog terms to a CSV ﬁle.
csv write ﬁle/3
Write a list of Prolog terms to a CSV ﬁle.
csv write stream/3
Write the rows in Data to Stream.
csv/3
Prolog DCG to ‘read/write’ CSV data.
SWI-Prolog 6.6 Reference Manual

450
APPENDIX F. SUMMARY
csv/4
Prolog DCG to ‘read/write’ CSV data.
F.2.8
library(lists)
append/2
Concatenate a list of lists.
append/3
List1AndList2 is the concatenation of List1 and List2.
delete/3
Delete matching elements from a list.
ﬂatten/2
Is true if List2 is a non-nested version of List1.
intersection/3
True if Set3 uniﬁes with the intersection of Set1 and Set2.
is set/1
True if Set is a proper list without duplicates.
last/2
Succeeds when Last is the last element of List.
list to set/2
True when Set has the same elements as List in the same order.
max list/2
True if Max is the largest number in List.
max member/2
True when Max is the largest member in the standard order of terms.
member/2
True if Elem is a member of List.
min list/2
True if Min is the smallest number in List.
min member/2
True when Min is the smallest member in the standard order of terms.
nextto/3
True if Y follows X in List.
nth0/3
True when Elem is the Index’th element of List.
nth0/4
Select/insert element at index.
nth1/3
Is true when Elem is the Index’th element of List.
nth1/4
As nth0/4, but counting starts at 1.
numlist/3
List is a list [Low, Low+1, ... High].
permutation/2
True when Xs is a permutation of Ys.
preﬁx/2
True iff Part is a leading substring of Whole.
proper length/2
True when Length is the number of elements in the proper list List.
reverse/2
Is true when the elements of List2 are in reverse order compared to List1.
same length/2
Is true when List1 and List2 are lists with the same number of elements.
select/3
Is true when List1, with Elem removed, results in List2.
select/4
True if XList is uniﬁable with YList apart a single element at the same position that is uniﬁed with X i
selectchk/3
Semi-deterministic removal of ﬁrst element in List that uniﬁes with Elem.
selectchk/4
Semi-deterministic version of select/4.
subset/2
True if all elements of SubSet belong to Set as well.
subtract/3
Delete all elements in Delete from Set.
sum list/2
Sum is the result of adding all numbers in List.
union/3
True if Set3 uniﬁes with the union of Set1 and Set2.
F.2.9
library(debug)
assertion/1
Acts similar to C assert() macro.
assertion failed/2
This hook is called if the Goal of assertion/1 fails.
debug/1
Add/remove a topic from being printed.
debug/3
Format a message if debug topic is enabled.
debug message context/1
Specify additional context for debug messages.
debug print hook/3
Hook called by debug/3.
debugging/1
Examine debug topics.
SWI-Prolog 6.6 Reference Manual

F.2. LIBRARY PREDICATES
451
debugging/2
Examine debug topics.
list debug topics/0
List currently known debug topics and their setting.
nodebug/1
Add/remove a topic from being printed.
F.2.10
library(option)
merge options/3
Merge two option lists.
meta options/3
Perform meta-expansion on options that are module-sensitive.
option/2
Get an Option from OptionList.
option/3
Get an Option Qfrom OptionList.
select option/3
Get and remove Option from an option list.
select option/4
Get and remove Option with default value.
F.2.11
library(optparse)
opt arguments/3
Extract commandline options according to a speciﬁcation.
opt help/2
True when Help is a help string synthesized from OptsSpec.
opt parse/4
Equivalent to opt parse(OptsSpec, ApplArgs, Opts, PositionalArgs, []).
opt parse/5
Parse the arguments Args (as list of atoms) according to OptsSpec.
F.2.12
library(ordsets)
is ordset/1
True if Term is an ordered set.
list to ord set/2
Transform a list into an ordered set.
ord add element/3
Insert an element into the set.
ord del element/3
Delete an element from an ordered set.
ord disjoint/2
True if Set1 and Set2 have no common elements.
ord empty/1
True when List is the empty ordered set.
ord intersect/2
True if both ordered sets have a non-empty intersection.
ord intersect/3
Intersection holds the common elements of Set1 and Set2.
ord intersection/2
Intersection of a powerset.
ord intersection/3
Intersection holds the common elements of Set1 and Set2.
ord intersection/4
Intersection and difference between two ordered sets.
ord memberchk/2
True if Element is a member of OrdSet, compared using ==.
ord selectchk/3
Is true when select(Item, Set1, Set2) and Set1, Set2 are both sorted lists without duplicates.
ord seteq/2
True if Set1 and Set2 have the same elements.
ord subset/2
Is true if all elements of Sub are in Super.
ord subtract/3
Diff is the set holding all elements of InOSet that are not in NotInOSet.
ord symdiff/3
Is true when Difference is the symmetric difference of Set1 and Set2.
ord union/2
True if Union is the union of all elements in the superset SetOfSets.
ord union/3
Union is the union of Set1 and Set2.
ord union/4
True iff ord union(Set1, Set2, Union) and ord subtract(Set2, Set1, New).
F.2.13
library(predicate options)
assert predicate options/4
As predicate options(:PI, +Arg, +Options).
SWI-Prolog 6.6 Reference Manual

452
APPENDIX F. SUMMARY
check predicate option/3
Verify predicate options at runtime.
check predicate options/0
Analyse loaded program for erroneous options.
current option arg/2
True when Arg of PI processes predicate options.
current predicate option/3
True when Arg of PI processes Option.
current predicate options/3
True when Options is the current active option declaration for PI on Arg.
derive predicate options/0
Derive new predicate option declarations.
derived predicate options/1
Derive predicate option declarations for a module.
derived predicate options/3
Derive option arguments using static analysis.
predicate options/3
Declare that the predicate PI processes options on Arg.
retractall predicate options/0
Remove all dynamically (derived) predicate options.
F.2.14
library(prologpack)
environment/2
Hook to deﬁne the environment for building packs.
pack info/1
Print more detailed information about Pack.
pack install/1
Install a package.
pack install/2
Install package Name.
pack list/1
Query package server and installed packages and display results.
pack list installed/0
List currently installed packages.
pack property/2
True when Property is a property of Pack.
pack rebuild/0
Rebuild foreign components of all packages.
pack rebuild/1
Rebuilt possible foreign components of Pack.
pack remove/1
Remove the indicated package.
pack search/1
Query package server and installed packages and display results.
pack upgrade/1
Try to upgrade the package Pack.
F.2.15
library(prologxref)
prolog:called by/2
(hook) Extend cross-referencer
xref built in/1
Examine deﬁned built-ins
xref called/3
Examine called predicates
xref clean/1
Remove analysis of source
xref current source/1
Examine cross-referenced sources
xref deﬁned/3
Examine deﬁned predicates
xref exported/2
Examine exported predicates
xref module/2
Module deﬁned by source
xref source/1
Cross-reference analysis of source
F.2.16
library(pairs)
group pairs by key/2
Group values with the same key.
map list to pairs/3
Create a Key-Value list by mapping each element of List.
pairs keys/2
Remove the values from a list of Key-Value pairs.
pairs keys values/3
True if Keys holds the keys of Pairs and Values the values.
pairs values/2
Remove the keys from a list of Key-Value pairs.
transpose pairs/2
Swap Key-Value to Value-Key.
SWI-Prolog 6.6 Reference Manual

F.2. LIBRARY PREDICATES
453
F.2.17
library(pio)
library(pure input)
phrase from ﬁle/2
Process the content of File using the DCG rule Grammar.
phrase from ﬁle/3
As phrase from ﬁle/2, providing additional Options.
phrase from stream/2
Helper for phrase from ﬁle/3.
stream to lazy list/2
Create a lazy list representing the character codes in Stream.
lazy list character count/3
True when CharCount is the current character count in the Lazy list.
lazy list location/3
True when Location is an (error) location term that represents the current location in the DC
syntax error/3
Throw the syntax error Error at the current location of the input.
F.2.18
library(random)
getrand/1
Query/set the state of the random generator.
maybe/0
Succeed/fail with equal probability (variant of maybe/1).
maybe/1
Succeed with probability P, fail with probability 1-P.
maybe/2
Succeed with probability K/N (variant of maybe/1).
random/1
Binds R to a new random ﬂoat in the open interval (0.0,1.0).
random/3
Generate a random integer or ﬂoat in a range.
random between/3
Binds R to a random integer in [L,U] (i.e., including both L and U).
random member/2
X is a random member of List.
random perm2/4
Does X=A,Y=B or X=B,Y=A with equal probability.
random permutation/2
Permutation is a random permutation of List.
random select/3
Randomly select or insert an element.
randseq/3
S is a list of K unique random integers in the range 1..N.
randset/3
S is a sorted list of K unique random integers in the range 1..N.
setrand/1
Query/set the state of the random generator.
F.2.19
library(readutil)
read line to codes/2
Read line from a stream
read line to codes/3
Read line from a stream
read stream to codes/2
Read contents of stream
read stream to codes/3
Read contents of stream
read ﬁle to codes/3
Read contents of ﬁle
read ﬁle to terms/3
Read contents of ﬁle to Prolog terms
F.2.20
library(record)
record/1
Deﬁne named ﬁelds in a term
F.2.21
library(registry)
This library is only available on Windows systems.
registry get key/2
Get principal value of key
SWI-Prolog 6.6 Reference Manual

454
APPENDIX F. SUMMARY
registry get key/3
Get associated value of key
registry set key/2
Set principal value of key
registry set key/3
Set associated value of key
registry delete key/1
Remove a key
shell register ﬁle type/4
Register a ﬁle-type
shell register dde/6
Register DDE action
shell register prolog/1
Register Prolog
F.2.22
library(ugraphs)
vertices edges to ugraph/3
Create unweighted graph
vertices/2
Find vertices in graph
edges/2
Find edges in graph
add vertices/3
Add vertices to graph
del vertices/3
Delete vertices from graph
add edges/3
Add edges to graph
del edges/3
Delete edges from graph
transpose/2
Invert the direction of all edges
neighbors/3
Find neighbors of vertice
neighbours/3
Find neighbors of vertice
complement/2
Inverse presense of edges
compose/3
top sort/2
Sort graph topologically
top sort/3
Sort graph topologically
transitive closure/2
Create transitive closure of graph
reachable/3
Find all reachable vertices
ugraph union/3
Union of two graphs
F.2.23
library(url)
ﬁle name to url/2
Translate between a ﬁlename and a ﬁle:// URL.
global url/3
Translate a possibly relative URL into an absolute one.
http location/2
Construct or analyze an HTTP location.
is absolute url/1
True if URL is an absolute URL.
parse url/2
Construct or analyse a URL.
parse url/3
Similar to parse url/2 for relative URLs.
parse url search/2
Construct or analyze an HTTP search speciﬁcation.
set url encoding/2
Query and set the encoding for URLs.
url iri/2
Convert between a URL, encoding in US-ASCII and an IRI.
www form encode/2
En/decode to/from application/x-www-form-encoded.
F.2.24
library(www browser)
www open url/1
Open a web-page in a browser
SWI-Prolog 6.6 Reference Manual

F.2. LIBRARY PREDICATES
455
F.2.25
library(clp/clpfd)
#/\/2
P and Q hold.
#</2
X is less than Y.
#<==/2
Q implies P.
#<==>/2
P and Q are equivalent.
#=/2
X equals Y.
#=</2
X is less than or equal to Y.
#==>/2
P implies Q.
#>/2
X is greater than Y.
#>=/2
X is greater than or equal to Y.
#\/1
The reiﬁable constraint Q does not hold.
#\//2
P or Q holds.
#\=/2
X is not Y.
all different/1
Vars are pairwise distinct.
all distinct/1
Like all different/1, with stronger propagation.
automaton/3
Describes a list of ﬁnite domain variables with a ﬁnite automaton.
automaton/8
Describes a list of ﬁnite domain variables with a ﬁnite automaton.
chain/2
Zs form a chain with respect to Relation.
circuit/1
True if the list Vs of ﬁnite domain variables induces a Hamiltonian circuit.
cumulative/1
Equivalent to cumulative(Tasks, [limit(1)]).
cumulative/2
Tasks is a list of tasks, each of the form task(S i, D i, E i, C i, T i).
element/3
The N-th element of the list of ﬁnite domain variables Vs is V.
fd dom/2
Dom is the current domain (see in/2) of Var.
fd inf/2
Inf is the inﬁmum of the current domain of Var.
fd size/2
Determine the size of a variable’s domain.
fd sup/2
Sup is the supremum of the current domain of Var.
fd var/1
True iff Var is a CLP(FD) variable.
global cardinality/2
Global Cardinality constraint.
global cardinality/3
Global Cardinality constraint.
in/2
Var is an element of Domain.
indomain/1
Bind Var to all feasible values of its domain on backtracking.
ins/2
The variables in the list Vars are elements of Domain.
label/1
Equivalent to labeling([], Vars).
labeling/2
Assign a value to each variable in Vars.
lex chain/1
Lists are lexicographically non-decreasing.
scalar product/4
Cs is a list of integers, Vs is a list of variables and integers.
serialized/2
Describes a set of non-overlapping tasks.
sum/3
The sum of elements of the list Vars is in relation Rel to Expr.
transpose/2
Transpose a list of lists of the same length.
tuples in/2
Relation must be a list of lists of integers.
zcompare/3
Analogous to compare/3, with ﬁnite domain variables A and B.
F.2.26
library(clpqr)
entailed/1
Check if constraint is entailed
SWI-Prolog 6.6 Reference Manual

456
APPENDIX F. SUMMARY
inf/2
Find the inﬁmum of an expression
sup/2
Find the supremum of an expression
minimize/1
Minimizes an expression
maximize/1
Maximizes an expression
bb inf/3
Inﬁmum of expression for mixed-integer problems
bb inf/4
Inﬁmum of expression for mixed-integer problems
bb inf/5
Inﬁmum of expression for mixed-integer problems
dump/3
Dump constraints on variables
F.2.27
library(clp/simplex)
assignment/2
Solve assignment problem
constraint/3
Add linear constraint to state
constraint/4
Add named linear constraint to state
constraint add/4
Extend a named constraint
gen state/1
Create empty linear program
maximize/3
Maximize objective function in to linear constraints
minimize/3
Minimize objective function in to linear constraints
objective/2
Fetch value of objective function
shadow price/3
Fetch shadow price in solved state
transportation/4
Solve transportation problem
variable value/3
Fetch value of variable in solved state
F.2.28
library(thread pool)
create pool/1
This hook is called if thread create in pool/4 discovers that the thread pool does not exist.
current thread pool/1
True if Name refers to a deﬁned thread pool.
thread create in pool/4
Create a thread in Pool.
thread pool create/3
Create a pool of threads.
thread pool destroy/1
Destroy the thread pool named Name.
thread pool property/2
True if Property is a property of thread pool Name.
F.2.29
library(varnumbers)
max var number/3
True when Max is the max of Start and the highest numbered $VAR(N) term.
numbervars/1
Number variables in Term using $VAR(N).
varnumbers/2
Inverse of numbervars/1.
varnumbers/3
Inverse of numbervars/3.
SWI-Prolog 6.6 Reference Manual

F.3. ARITHMETIC FUNCTIONS
457
F.3
Arithmetic Functions
*/2
Multiplication
**/2
Power function
+/1
Unary plus (No-op)
+/2
Addition
-/1
Unary minus
-/2
Subtraction
//2
Division
///2
Integer division
/\/2
Bitwise and
<</2
Bitwise left shift
>>/2
Bitwise right shift
./2
List of one character: character code
\/1
Bitwise negation
\//2
Bitwise or
ˆ/2
Power function
abs/1
Absolute value
acos/1
Inverse (arc) cosine
acosh/1
Inverse hyperbolic cosine
asin/1
Inverse (arc) sine
asinh/1
Inverse (arc) sine
atan/1
Inverse hyperbolic sine
atan/2
Rectangular to polar conversion
atanh/1
Inverse hyperbolic tangent
atan2/2
Rectangular to polar conversion
ceil/1
Smallest integer larger than arg
ceiling/1
Smallest integer larger than arg
cos/1
Cosine
cosh/1
Hyperbolic cosine
copysign/2
Apply sign of N2 to N1
cputime/0
Get CPU time
div/2
Integer division
e/0
Mathematical constant
epsilon/0
Floating point precision
eval/1
Evaluate term as expression
exp/1
Exponent (base e)
ﬂoat/1
Explicitly convert to ﬂoat
ﬂoat fractional part/1
Fractional part of a ﬂoat
ﬂoat integer part/1
Integer part of a ﬂoat
ﬂoor/1
Largest integer below argument
gcd/2
Greatest common divisor
integer/1
Round to nearest integer
log/1
Natural logarithm
log10/1
10 base logarithm
lsb/1
Least signiﬁcant bit
SWI-Prolog 6.6 Reference Manual

458
APPENDIX F. SUMMARY
max/2
Maximum of two numbers
min/2
Minimum of two numbers
msb/1
Most signiﬁcant bit
mod/2
Remainder of division
powm/3
Integer exponent and modulo
random/1
Generate random number
random ﬂoat/0
Generate random number
rational/1
Convert to rational number
rationalize/1
Convert to rational number
rdiv/2
Ration number division
rem/2
Remainder of division
round/1
Round to nearest integer
truncate/1
Truncate ﬂoat to integer
pi/0
Mathematical constant
popcount/1
Count 1s in a bitvector
sign/1
Extract sign of value
sin/1
Sine
sinh/1
Hyperbolic sine
sqrt/1
Square root
tan/1
Tangent
tanh/1
Hyperbolic tangent
xor/2
Bitwise exclusive or
SWI-Prolog 6.6 Reference Manual

F.4. OPERATORS
459
F.4
Operators
$
1
fx
Bind top-level variable
ˆ
200
xfy
Predicate
ˆ
200
xfy
Arithmetic function
mod
300
xfx
Arithmetic function
*
400
yfx
Arithmetic function
/
400
yfx
Arithmetic function
//
400
yfx
Arithmetic function
<<
400
yfx
Arithmetic function
>>
400
yfx
Arithmetic function
xor
400
yfx
Arithmetic function
+
500
fx
Arithmetic function
-
500
fx
Arithmetic function
?
500
fx
XPCE: obtainer
\
500
fx
Arithmetic function
+
500
yfx
Arithmetic function
-
500
yfx
Arithmetic function
/\
500
yfx
Arithmetic function
\/
500
yfx
Arithmetic function
:
600
xfy
module:term separator
<
700
xfx
Predicate
=
700
xfx
Predicate
=..
700
xfx
Predicate
=:=
700
xfx
Predicate
<
700
xfx
Predicate
==
700
xfx
Predicate
=@=
700
xfx
Predicate
=\=
700
xfx
Predicate
>
700
xfx
Predicate
>=
700
xfx
Predicate
@<
700
xfx
Predicate
@=<
700
xfx
Predicate
@>
700
xfx
Predicate
@>=
700
xfx
Predicate
is
700
xfx
Predicate
\=
700
xfx
Predicate
\==
700
xfx
Predicate
=@=
700
xfx
Predicate
not
900
fy
Predicate
\+
900
fy
Predicate
,
1000
xfy
Predicate
->
1050
xfy
Predicate
*->
1050
xfy
Predicate
;
1100
xfy
Predicate
|
1105
xfy
Predicate
SWI-Prolog 6.6 Reference Manual

460
APPENDIX F. SUMMARY
discontiguous
1150
fx
Predicate
dynamic
1150
fx
Predicate
module transparent
1150
fx
Predicate
meta predicate
1150
fx
Head
multiﬁle
1150
fx
Predicate
thread local
1150
fx
Predicate
volatile
1150
fx
Predicate
initialization
1150
fx
Predicate
:-
1200
fx
Introduces a directive
?-
1200
fx
Introduces a directive
-->
1200
xfx
DCGrammar: rewrite
:-
1200
xfx
head :- body. separator
SWI-Prolog 6.6 Reference Manual

Bibliography
[Bowen et al., 1983]
D. L. Bowen, L. M. Byrd, and WF. Clocksin. A portable Prolog
compiler. In L. M. Pereira, editor, Proceedings of the Logic Pro-
gramming Workshop 1983, Lisabon, Portugal, 1983. Universidade
nova de Lisboa.
[Bratko, 1986]
I. Bratko. Prolog Programming for Artiﬁcial Intelligence. Addison-
Wesley, Reading, Massachusetts, 1986.
[Butenhof, 1997]
David R. Butenhof. Programming with POSIX threads. Addison-
Wesley, Reading, MA, USA, 1997.
[Byrd, 1980]
L. Byrd. Understanding the control ﬂow of Prolog programs. Logic
Programming Workshop, 1980.
[Clocksin & Melish, 1987]
W. F. Clocksin and C. S. Melish. Programming in Prolog. Springer-
Verlag, New York, Third, Revised and Extended edition, 1987.
[Demoen, 2002]
Bart Demoen. Dynamic attributes, their hProlog implementation,
and a ﬁrst evaluation.
Report CW 350, Department of Com-
puter Science, K.U.Leuven, Leuven, Belgium, oct 2002. URL =
http://www.cs.kuleuven.ac.be/publicaties/rapporten/cw/CW350.abs.html.
[Freire et al., 1997]
Juliana Freire, David S. Warren, Konstantinos Sagonas, Prasad Rao,
and Terrance Swift. XSB: A system for efﬁciently computing well-
founded semantics. In Proceedings of LPNMR 97, pages 430–440,
Berlin, Germany, jan 1997. Springer Verlag. LNCS 1265.
[Fr¨uhwirth, ]
T. Fr¨uhwirth. Thom Fruehwirth’s constraint handling rules website.
http://www.constraint-handling-rules.org.
[Fr¨uhwirth, 2009]
T. Fr¨uhwirth. Constraint Handling Rules. Cambridge University
Press, 2009.
[Graham et al., 1982]
Susan L. Graham, Peter B. Kessler, and Marshall K. McKusick.
gprof: a call graph execution proﬁler. In SIGPLAN Symposium on
Compiler Construction, pages 120–126, 1982.
[Hodgson, 1998]
Jonathan
Hodgson.
validation
suite
for
con-
formance
with
part
1
of
the
standard,
1998,
http://www.sju.edu/˜jhodgson/pub/suite.tar.gz.
[Holzbaur, 1992]
Christian Holzbaur.
Metastructures versus attributed variables in
the context of extensible uniﬁcation. In PLILP, volume 631, pages
260–268. Springer-Verlag, 1992. LNCS 631.
SWI-Prolog 6.6 Reference Manual

462
BIBLIOGRAPHY
[Kernighan & Ritchie, 1978]
B. W. Kernighan and D. M. Ritchie. The C Programming Language.
Prentice-Hall, Englewood Cliffs, New Jersey, 1978.
[Mainland, 2007]
Geoffrey Mainland. Why it’s nice to be quoted: quasiquoting for
haskell.
In Gabriele Keller, editor, Haskell, pages 73–82. ACM,
2007.
[Neumerkel, 1993]
Ulrich Neumerkel.
The binary WAM, a simpliﬁed Prolog en-
gine.
Technical report, Technische Universit¨at Wien, 1993.
http://www.complang.tuwien.ac.at/ulrich/papers/PDF/binwam-
nov93.pdf.
[O’Keefe, 1990]
R. A. O’Keefe. The Craft of Prolog. MIT Press, Massachussetts,
1990.
[Pereira, 1986]
F. Pereira. C-Prolog User’s Manual. EdCaad, University of Edin-
burgh, 1986.
[Qui, 1997]
AI International ltd., Berkhamsted, UK.
Quintus Prolog, User
Guide and Reference Manual, 1997.
[Sterling & Shapiro, 1986]
L. Sterling and E. Shapiro. The Art of Prolog. MIT Press, Cam-
bridge, Massachusetts, 1986.
[Wielemaker & Angelopoulos, ] Jan Wielemaker and Nicos Angelopoulos.
SWI-Prolog 6.6 Reference Manual

